head	1.698;
access;
symbols
	cygwin-1_7_35-release:1.698
	cygwin-1_7_34-release:1.697
	cygwin-1_7_33-release:1.688.2.2
	cygwin-1_7_32-release:1.688.2.1
	cygwin-1_7_31-release:1.688.2.1
	cygwin-1_7_30-release:1.688
	cygwin-1_7_29-release:1.688
	cygwin-1_7_29-release-branchpoint:1.688.0.2
	cygwin-pre-user-db:1.688
	cygwin-1_7_28-release:1.688
	cygwin-1_7_27-release:1.687
	cygwin-1_7_26-release:1.686
	cygwin-1_7_25-release:1.684
	cygwin-1_7_24-release:1.684
	cygwin-1_7_23-release:1.684
	cygwin-1_7_22-release:1.683
	cygwin-1_7_21-release:1.682
	cygwin-1_7_20-release:1.677
	cygwin-1_7_19-release:1.677
	cygwin-64bit-postmerge:1.674
	cygwin-64bit-premerge-branch:1.673.0.2
	cygwin-64bit-premerge:1.673
	cygwin-1_7_18-release:1.673
	post-ptmalloc3:1.669.2.8
	pre-ptmalloc3:1.669.2.8
	cygwin-1_7_17-release:1.670
	cygwin-64bit-branch:1.669.0.2
	cygwin-1_7_16-release:1.666
	cygwin-1_7_15-release:1.662
	cygwin-1_7_14_2-release:1.661
	cygwin-1_7_14-release:1.661
	cygwin-1_7_12-release:1.655
	cygwin-1_7_11-release:1.647
	cygwin-1_7_10-release:1.647
	signal-rewrite:1.633.0.2
	pre-notty:1.629
	cygwin-1_7_9-release:1.626
	cv-post-1_7_9:1.626.0.2
	cygwin-1_7_8-release:1.625
	cygwin-1_7_7-release:1.604
	cygwin-1_7_5-release:1.583
	cygwin-1_7_4-release:1.582
	cygwin-1_7_3-release:1.582
	cygwin-1_7_2-release:1.581
	fifo_doover3:1.575.0.2
	cygwin-1_7_1-release:1.573
	prefifo:1.557
	cv-branch-2:1.551.0.2
	pre-ripout-set_console_state_for_spawn:1.510
	EOL_registry_mounts:1.487
	preoverlapped:1.438
	drop_9x_support_start:1.430
	cr-0x5f1:1.412.0.2
	cv-branch:1.411.0.2
	pre-ptymaster-archetype:1.409
	cr-0x3b58:1.399.0.4
	cr-0x5ef:1.399.0.2
	after-mmap-privanon-noreserve:1.395
	after-mmap-revamp:1.395
	before-mmap-revamp:1.395
	cgf-more-exit-sync:1.395
	post_wait_sig_exit:1.390
	pre_wait_sig_exit:1.390
	reparent-point:1.325
	noreparent:1.325.0.2
	cr-0x5e6:1.312.0.2
	cr-0x9e:1.286.0.6
	cr-0x9d:1.286.0.4
	cgf-deleteme:1.286.0.2
	pre-sigrewrite:1.280
	corinna-01:1.278
	cr-0x9c:1.269.0.4
	cr-0x9b:1.269.0.2
	cr-0x99:1.267
	Z-emcb-cygwin_daemon:1.266.0.2
	w32api-2_2:1.245
	mingw-runtime-2_4:1.245
	pre-cgf-merge:1.269
	cgf-dev-branch:1.238.0.2
	predaemon:1.198
	cygwin_daemon_merge_HEAD:1.198
	pregp02r1:1.197.0.2
	cygnus_cvs_20020108_pre:1.193
	Z-cygwin_daemon_merge-new_HEAD:1.231
	Z-cygwin_daemon_merge_HEAD:1.231
	cygwin_daemon:1.163.0.2
	pre-posix-scan:1.128;
locks; strict;
comment	@// @;
expand	@o@;


1.698
date	2015.02.15.08.59.55;	author corinna;	state Exp;
branches;
next	1.697;

1.697
date	2015.01.22.13.46.11;	author corinna;	state Exp;
branches;
next	1.696;

1.696
date	2014.12.16.09.24.40;	author corinna;	state Exp;
branches;
next	1.695;

1.695
date	2014.12.16.09.16.03;	author corinna;	state Exp;
branches;
next	1.694;

1.694
date	2014.10.28.10.44.49;	author corinna;	state Exp;
branches;
next	1.693;

1.693
date	2014.10.20.10.29.30;	author corinna;	state Exp;
branches;
next	1.692;

1.692
date	2014.08.22.09.21.31;	author corinna;	state Exp;
branches;
next	1.691;

1.691
date	2014.04.18.14.29.49;	author corinna;	state Exp;
branches;
next	1.690;

1.690
date	2014.02.27.10.25.03;	author corinna;	state Exp;
branches;
next	1.689;

1.689
date	2014.02.09.19.44.55;	author corinna;	state Exp;
branches;
next	1.688;

1.688
date	2014.01.22.15.45.29;	author corinna;	state Exp;
branches
	1.688.2.1;
next	1.687;

1.687
date	2013.12.07.10.12.24;	author corinna;	state Exp;
branches;
next	1.686;

1.686
date	2013.11.25.11.38.08;	author corinna;	state Exp;
branches;
next	1.685;

1.685
date	2013.11.24.12.13.35;	author corinna;	state Exp;
branches;
next	1.684;

1.684
date	2013.07.31.10.26.51;	author corinna;	state Exp;
branches;
next	1.683;

1.683
date	2013.07.18.10.11.33;	author corinna;	state Exp;
branches;
next	1.682;

1.682
date	2013.07.15.09.57.20;	author corinna;	state Exp;
branches;
next	1.681;

1.681
date	2013.06.28.10.52.30;	author corinna;	state Exp;
branches;
next	1.680;

1.680
date	2013.06.21.08.14.26;	author corinna;	state Exp;
branches;
next	1.679;

1.679
date	2013.06.17.12.37.09;	author corinna;	state Exp;
branches;
next	1.678;

1.678
date	2013.06.12.17.45.42;	author corinna;	state Exp;
branches;
next	1.677;

1.677
date	2013.05.23.14.23.01;	author corinna;	state Exp;
branches;
next	1.676;

1.676
date	2013.05.01.01.20.37;	author yselkowitz;	state Exp;
branches;
next	1.675;

1.675
date	2013.04.24.10.16.12;	author corinna;	state Exp;
branches;
next	1.674;

1.674
date	2013.04.23.09.44.33;	author corinna;	state Exp;
branches;
next	1.673;

1.673
date	2013.04.12.08.30.47;	author corinna;	state Exp;
branches;
next	1.672;

1.672
date	2013.04.03.11.20.36;	author corinna;	state Exp;
branches;
next	1.671;

1.671
date	2013.01.21.04.34.51;	author cgf;	state Exp;
branches;
next	1.670;

1.670
date	2012.08.16.23.34.44;	author cgf;	state Exp;
branches;
next	1.669;

1.669
date	2012.07.31.19.56.32;	author corinna;	state Exp;
branches
	1.669.2.1;
next	1.668;

1.668
date	2012.07.31.19.36.16;	author corinna;	state Exp;
branches;
next	1.667;

1.667
date	2012.07.29.19.18.04;	author cgf;	state Exp;
branches;
next	1.666;

1.666
date	2012.07.02.19.38.41;	author cgf;	state Exp;
branches;
next	1.665;

1.665
date	2012.07.02.00.40.06;	author cgf;	state Exp;
branches;
next	1.664;

1.664
date	2012.06.22.09.51.29;	author corinna;	state Exp;
branches;
next	1.663;

1.663
date	2012.06.21.09.33.19;	author corinna;	state Exp;
branches;
next	1.662;

1.662
date	2012.04.27.12.07.15;	author corinna;	state Exp;
branches;
next	1.661;

1.661
date	2012.04.21.19.52.11;	author cgf;	state Exp;
branches;
next	1.660;

1.660
date	2012.04.19.17.21.31;	author cgf;	state Exp;
branches;
next	1.659;

1.659
date	2012.04.07.17.32.44;	author cgf;	state Exp;
branches;
next	1.658;

1.658
date	2012.04.06.04.40.49;	author cgf;	state Exp;
branches;
next	1.657;

1.657
date	2012.04.04.12.45.24;	author corinna;	state Exp;
branches;
next	1.656;

1.656
date	2012.04.04.12.06.21;	author corinna;	state Exp;
branches;
next	1.655;

1.655
date	2012.04.02.15.56.43;	author corinna;	state Exp;
branches;
next	1.654;

1.654
date	2012.03.31.20.14.14;	author corinna;	state Exp;
branches;
next	1.653;

1.653
date	2012.03.31.17.38.00;	author cgf;	state Exp;
branches;
next	1.652;

1.652
date	2012.03.29.18.02.54;	author corinna;	state Exp;
branches;
next	1.651;

1.651
date	2012.03.08.14.56.18;	author corinna;	state Exp;
branches;
next	1.650;

1.650
date	2012.03.08.09.36.11;	author corinna;	state Exp;
branches;
next	1.649;

1.649
date	2012.03.05.11.50.25;	author corinna;	state Exp;
branches;
next	1.648;

1.648
date	2012.02.26.14.01.32;	author corinna;	state Exp;
branches;
next	1.647;

1.647
date	2012.01.11.19.07.10;	author cgf;	state Exp;
branches;
next	1.646;

1.646
date	2012.01.02.17.45.51;	author cgf;	state Exp;
branches;
next	1.645;

1.645
date	2012.01.01.18.54.25;	author yselkowitz;	state Exp;
branches;
next	1.644;

1.644
date	2011.12.24.13.11.34;	author corinna;	state Exp;
branches;
next	1.643;

1.643
date	2011.12.17.23.39.47;	author cgf;	state Exp;
branches;
next	1.642;

1.642
date	2011.12.13.14.53.10;	author corinna;	state Exp;
branches;
next	1.641;

1.641
date	2011.12.13.11.54.27;	author corinna;	state Exp;
branches;
next	1.640;

1.640
date	2011.12.03.21.43.26;	author cgf;	state Exp;
branches;
next	1.639;

1.639
date	2011.12.02.16.06.10;	author corinna;	state Exp;
branches;
next	1.638;

1.638
date	2011.10.23.17.19.17;	author cgf;	state Exp;
branches;
next	1.637;

1.637
date	2011.10.18.08.47.08;	author corinna;	state Exp;
branches;
next	1.636;

1.636
date	2011.10.15.22.37.30;	author cgf;	state Exp;
branches;
next	1.635;

1.635
date	2011.10.13.16.47.32;	author corinna;	state Exp;
branches;
next	1.634;

1.634
date	2011.10.13.15.32.10;	author corinna;	state Exp;
branches;
next	1.633;

1.633
date	2011.08.01.17.01.37;	author corinna;	state Exp;
branches;
next	1.632;

1.632
date	2011.07.26.09.54.11;	author corinna;	state Exp;
branches;
next	1.631;

1.631
date	2011.07.05.09.59.34;	author corinna;	state Exp;
branches;
next	1.630;

1.630
date	2011.06.18.08.36.59;	author corinna;	state Exp;
branches;
next	1.629;

1.629
date	2011.06.06.05.02.11;	author cgf;	state Exp;
branches;
next	1.628;

1.628
date	2011.05.28.18.17.08;	author cgf;	state Exp;
branches;
next	1.627;

1.627
date	2011.03.29.10.21.30;	author corinna;	state Exp;
branches;
next	1.626;

1.626
date	2011.03.08.14.26.14;	author corinna;	state Exp;
branches
	1.626.2.1;
next	1.625;

1.625
date	2011.02.15.15.25.59;	author corinna;	state Exp;
branches;
next	1.624;

1.624
date	2011.02.15.10.39.36;	author corinna;	state Exp;
branches;
next	1.623;

1.623
date	2011.02.13.15.43.00;	author corinna;	state Exp;
branches;
next	1.622;

1.622
date	2011.02.02.09.59.10;	author corinna;	state Exp;
branches;
next	1.621;

1.621
date	2011.01.17.14.19.39;	author corinna;	state Exp;
branches;
next	1.620;

1.620
date	2010.12.06.13.09.40;	author corinna;	state Exp;
branches;
next	1.619;

1.619
date	2010.11.23.09.26.16;	author corinna;	state Exp;
branches;
next	1.618;

1.618
date	2010.10.24.18.50.57;	author cgf;	state Exp;
branches;
next	1.617;

1.617
date	2010.10.09.10.54.13;	author corinna;	state Exp;
branches;
next	1.616;

1.616
date	2010.10.07.14.03.26;	author corinna;	state Exp;
branches;
next	1.615;

1.615
date	2010.10.02.19.03.44;	author corinna;	state Exp;
branches;
next	1.614;

1.614
date	2010.09.30.13.52.33;	author corinna;	state Exp;
branches;
next	1.613;

1.613
date	2010.09.30.10.42.34;	author corinna;	state Exp;
branches;
next	1.612;

1.612
date	2010.09.24.12.41.33;	author corinna;	state Exp;
branches;
next	1.611;

1.611
date	2010.09.21.16.41.17;	author corinna;	state Exp;
branches;
next	1.610;

1.610
date	2010.09.21.16.32.22;	author corinna;	state Exp;
branches;
next	1.609;

1.609
date	2010.09.21.16.07.20;	author corinna;	state Exp;
branches;
next	1.608;

1.608
date	2010.09.14.14.10.39;	author corinna;	state Exp;
branches;
next	1.607;

1.607
date	2010.09.13.11.17.36;	author corinna;	state Exp;
branches;
next	1.606;

1.606
date	2010.09.06.09.47.01;	author corinna;	state Exp;
branches;
next	1.605;

1.605
date	2010.08.31.13.48.04;	author corinna;	state Exp;
branches;
next	1.604;

1.604
date	2010.08.27.17.58.43;	author corinna;	state Exp;
branches;
next	1.603;

1.603
date	2010.08.20.14.29.56;	author corinna;	state Exp;
branches;
next	1.602;

1.602
date	2010.08.20.11.18.58;	author corinna;	state Exp;
branches;
next	1.601;

1.601
date	2010.08.18.14.22.07;	author corinna;	state Exp;
branches;
next	1.600;

1.600
date	2010.08.13.11.51.53;	author corinna;	state Exp;
branches;
next	1.599;

1.599
date	2010.08.04.11.25.13;	author corinna;	state Exp;
branches;
next	1.598;

1.598
date	2010.07.04.17.12.26;	author cgf;	state Exp;
branches;
next	1.597;

1.597
date	2010.06.15.12.05.14;	author corinna;	state Exp;
branches;
next	1.596;

1.596
date	2010.06.14.21.16.41;	author corinna;	state Exp;
branches;
next	1.595;

1.595
date	2010.06.09.12.32.14;	author corinna;	state Exp;
branches;
next	1.594;

1.594
date	2010.06.08.15.25.09;	author corinna;	state Exp;
branches;
next	1.593;

1.593
date	2010.06.02.14.52.34;	author corinna;	state Exp;
branches;
next	1.592;

1.592
date	2010.05.26.14.24.47;	author corinna;	state Exp;
branches;
next	1.591;

1.591
date	2010.05.06.10.04.50;	author corinna;	state Exp;
branches;
next	1.590;

1.590
date	2010.04.29.10.38.04;	author corinna;	state Exp;
branches;
next	1.589;

1.589
date	2010.04.26.13.48.04;	author corinna;	state Exp;
branches;
next	1.588;

1.588
date	2010.04.23.11.07.35;	author corinna;	state Exp;
branches;
next	1.587;

1.587
date	2010.04.22.17.42.18;	author corinna;	state Exp;
branches;
next	1.586;

1.586
date	2010.04.22.17.33.28;	author corinna;	state Exp;
branches;
next	1.585;

1.585
date	2010.04.22.09.43.29;	author corinna;	state Exp;
branches;
next	1.584;

1.584
date	2010.04.20.14.32.29;	author cgf;	state Exp;
branches;
next	1.583;

1.583
date	2010.04.09.16.51.08;	author cgf;	state Exp;
branches;
next	1.582;

1.582
date	2010.03.29.17.15.51;	author corinna;	state Exp;
branches;
next	1.581;

1.581
date	2010.02.20.09.17.07;	author corinna;	state Exp;
branches;
next	1.580;

1.580
date	2010.02.15.13.29.02;	author corinna;	state Exp;
branches;
next	1.579;

1.579
date	2010.02.06.15.57.21;	author corinna;	state Exp;
branches;
next	1.578;

1.578
date	2010.01.29.11.20.06;	author corinna;	state Exp;
branches;
next	1.577;

1.577
date	2010.01.12.14.47.46;	author corinna;	state Exp;
branches;
next	1.576;

1.576
date	2010.01.12.10.14.59;	author corinna;	state Exp;
branches;
next	1.575;

1.575
date	2009.12.24.12.53.43;	author corinna;	state Exp;
branches;
next	1.574;

1.574
date	2009.12.21.16.44.37;	author corinna;	state Exp;
branches;
next	1.573;

1.573
date	2009.11.10.08.54.24;	author corinna;	state Exp;
branches;
next	1.572;

1.572
date	2009.11.09.19.46.36;	author corinna;	state Exp;
branches;
next	1.571;

1.571
date	2009.11.02.11.42.04;	author corinna;	state Exp;
branches;
next	1.570;

1.570
date	2009.11.02.10.07.26;	author corinna;	state Exp;
branches;
next	1.569;

1.569
date	2009.10.30.19.58.52;	author corinna;	state Exp;
branches;
next	1.568;

1.568
date	2009.10.09.11.17.17;	author corinna;	state Exp;
branches;
next	1.567;

1.567
date	2009.10.02.06.04.57;	author cgf;	state Exp;
branches;
next	1.566;

1.566
date	2009.09.25.23.55.00;	author ericb;	state Exp;
branches;
next	1.565;

1.565
date	2009.09.22.09.24.30;	author corinna;	state Exp;
branches;
next	1.564;

1.564
date	2009.09.21.19.29.16;	author corinna;	state Exp;
branches;
next	1.563;

1.563
date	2009.08.26.20.32.35;	author corinna;	state Exp;
branches;
next	1.562;

1.562
date	2009.08.25.11.27.03;	author corinna;	state Exp;
branches;
next	1.561;

1.561
date	2009.08.24.11.14.30;	author corinna;	state Exp;
branches;
next	1.560;

1.560
date	2009.08.04.22.35.35;	author cgf;	state Exp;
branches;
next	1.559;

1.559
date	2009.08.01.19.52.46;	author cgf;	state Exp;
branches;
next	1.558;

1.558
date	2009.07.30.08.56.57;	author corinna;	state Exp;
branches;
next	1.557;

1.557
date	2009.07.22.18.21.09;	author corinna;	state Exp;
branches;
next	1.556;

1.556
date	2009.07.22.15.55.47;	author corinna;	state Exp;
branches;
next	1.555;

1.555
date	2009.07.17.09.00.19;	author corinna;	state Exp;
branches;
next	1.554;

1.554
date	2009.07.15.13.27.34;	author corinna;	state Exp;
branches;
next	1.553;

1.553
date	2009.07.14.17.37.42;	author corinna;	state Exp;
branches;
next	1.552;

1.552
date	2009.06.18.09.47.13;	author corinna;	state Exp;
branches;
next	1.551;

1.551
date	2009.06.08.15.22.52;	author corinna;	state Exp;
branches;
next	1.550;

1.550
date	2009.06.02.13.29.30;	author corinna;	state Exp;
branches;
next	1.549;

1.549
date	2009.05.29.20.18.50;	author cgf;	state Exp;
branches;
next	1.548;

1.548
date	2009.05.28.05.10.03;	author cgf;	state Exp;
branches;
next	1.547;

1.547
date	2009.05.13.15.00.06;	author corinna;	state Exp;
branches;
next	1.546;

1.546
date	2009.05.09.15.08.16;	author corinna;	state Exp;
branches;
next	1.545;

1.545
date	2009.04.15.09.58.41;	author corinna;	state Exp;
branches;
next	1.544;

1.544
date	2009.03.26.12.12.11;	author corinna;	state Exp;
branches;
next	1.543;

1.543
date	2009.03.14.18.35.26;	author cgf;	state Exp;
branches;
next	1.542;

1.542
date	2009.03.12.22.03.28;	author corinna;	state Exp;
branches;
next	1.541;

1.541
date	2009.01.29.20.32.08;	author corinna;	state Exp;
branches;
next	1.540;

1.540
date	2009.01.11.16.13.11;	author corinna;	state Exp;
branches;
next	1.539;

1.539
date	2009.01.09.16.20.26;	author corinna;	state Exp;
branches;
next	1.538;

1.538
date	2009.01.09.05.18.01;	author cgf;	state Exp;
branches;
next	1.537;

1.537
date	2009.01.07.14.12.40;	author corinna;	state Exp;
branches;
next	1.536;

1.536
date	2009.01.03.05.12.21;	author cgf;	state Exp;
branches;
next	1.535;

1.535
date	2008.12.25.15.55.31;	author cgf;	state Exp;
branches;
next	1.534;

1.534
date	2008.12.24.16.34.38;	author cgf;	state Exp;
branches;
next	1.533;

1.533
date	2008.12.19.12.15.33;	author corinna;	state Exp;
branches;
next	1.532;

1.532
date	2008.12.18.15.37.19;	author corinna;	state Exp;
branches;
next	1.531;

1.531
date	2008.12.14.06.01.46;	author cgf;	state Exp;
branches;
next	1.530;

1.530
date	2008.11.26.17.21.04;	author cgf;	state Exp;
branches;
next	1.529;

1.529
date	2008.11.11.11.45.05;	author corinna;	state Exp;
branches;
next	1.528;

1.528
date	2008.11.11.03.51.55;	author cgf;	state Exp;
branches;
next	1.527;

1.527
date	2008.10.20.19.30.06;	author corinna;	state Exp;
branches;
next	1.526;

1.526
date	2008.10.09.14.23.09;	author corinna;	state Exp;
branches;
next	1.525;

1.525
date	2008.10.09.09.43.02;	author corinna;	state Exp;
branches;
next	1.524;

1.524
date	2008.10.09.08.56.09;	author corinna;	state Exp;
branches;
next	1.523;

1.523
date	2008.10.08.14.58.26;	author corinna;	state Exp;
branches;
next	1.522;

1.522
date	2008.09.11.04.34.23;	author cgf;	state Exp;
branches;
next	1.521;

1.521
date	2008.08.20.10.53.54;	author corinna;	state Exp;
branches;
next	1.520;

1.520
date	2008.08.15.10.19.12;	author corinna;	state Exp;
branches;
next	1.519;

1.519
date	2008.08.14.14.05.04;	author corinna;	state Exp;
branches;
next	1.518;

1.518
date	2008.07.31.14.48.28;	author corinna;	state Exp;
branches;
next	1.517;

1.517
date	2008.07.30.14.41.59;	author corinna;	state Exp;
branches;
next	1.516;

1.516
date	2008.07.25.15.23.56;	author corinna;	state Exp;
branches;
next	1.515;

1.515
date	2008.07.24.18.25.49;	author corinna;	state Exp;
branches;
next	1.514;

1.514
date	2008.07.16.21.08.22;	author corinna;	state Exp;
branches;
next	1.513;

1.513
date	2008.07.16.20.20.45;	author corinna;	state Exp;
branches;
next	1.512;

1.512
date	2008.07.14.20.22.03;	author corinna;	state Exp;
branches;
next	1.511;

1.511
date	2008.07.02.14.00.27;	author corinna;	state Exp;
branches;
next	1.510;

1.510
date	2008.06.11.14.06.05;	author corinna;	state Exp;
branches;
next	1.509;

1.509
date	2008.05.24.09.54.32;	author corinna;	state Exp;
branches;
next	1.508;

1.508
date	2008.05.23.17.22.18;	author corinna;	state Exp;
branches;
next	1.507;

1.507
date	2008.05.23.15.33.03;	author cgf;	state Exp;
branches;
next	1.506;

1.506
date	2008.05.23.11.00.35;	author corinna;	state Exp;
branches;
next	1.505;

1.505
date	2008.05.23.07.13.47;	author cgf;	state Exp;
branches;
next	1.504;

1.504
date	2008.05.22.11.18.46;	author corinna;	state Exp;
branches;
next	1.503;

1.503
date	2008.05.21.10.23.19;	author corinna;	state Exp;
branches;
next	1.502;

1.502
date	2008.05.21.09.02.42;	author corinna;	state Exp;
branches;
next	1.501;

1.501
date	2008.05.20.18.26.45;	author corinna;	state Exp;
branches;
next	1.500;

1.500
date	2008.05.20.18.19.32;	author corinna;	state Exp;
branches;
next	1.499;

1.499
date	2008.05.20.17.18.08;	author corinna;	state Exp;
branches;
next	1.498;

1.498
date	2008.05.20.15.11.23;	author corinna;	state Exp;
branches;
next	1.497;

1.497
date	2008.05.20.10.18.12;	author corinna;	state Exp;
branches;
next	1.496;

1.496
date	2008.05.13.13.44.04;	author corinna;	state Exp;
branches;
next	1.495;

1.495
date	2008.04.30.08.49.23;	author corinna;	state Exp;
branches;
next	1.494;

1.494
date	2008.04.28.16.01.54;	author corinna;	state Exp;
branches;
next	1.493;

1.493
date	2008.04.23.11.13.52;	author corinna;	state Exp;
branches;
next	1.492;

1.492
date	2008.04.14.09.15.35;	author corinna;	state Exp;
branches;
next	1.491;

1.491
date	2008.04.13.16.47.21;	author corinna;	state Exp;
branches;
next	1.490;

1.490
date	2008.04.07.16.15.45;	author cgf;	state Exp;
branches;
next	1.489;

1.489
date	2008.04.06.09.56.42;	author corinna;	state Exp;
branches;
next	1.488;

1.488
date	2008.04.05.09.30.06;	author corinna;	state Exp;
branches;
next	1.487;

1.487
date	2008.04.03.18.20.54;	author corinna;	state Exp;
branches;
next	1.486;

1.486
date	2008.04.03.15.44.18;	author corinna;	state Exp;
branches;
next	1.485;

1.485
date	2008.04.02.17.45.32;	author corinna;	state Exp;
branches;
next	1.484;

1.484
date	2008.04.02.11.45.14;	author corinna;	state Exp;
branches;
next	1.483;

1.483
date	2008.04.02.11.35.10;	author corinna;	state Exp;
branches;
next	1.482;

1.482
date	2008.03.31.18.03.25;	author corinna;	state Exp;
branches;
next	1.481;

1.481
date	2008.03.22.21.04.16;	author cgf;	state Exp;
branches;
next	1.480;

1.480
date	2008.03.14.20.43.28;	author corinna;	state Exp;
branches;
next	1.479;

1.479
date	2008.03.12.16.07.04;	author corinna;	state Exp;
branches;
next	1.478;

1.478
date	2008.03.12.12.41.49;	author corinna;	state Exp;
branches;
next	1.477;

1.477
date	2008.03.11.12.34.08;	author corinna;	state Exp;
branches;
next	1.476;

1.476
date	2008.03.08.17.28.40;	author corinna;	state Exp;
branches;
next	1.475;

1.475
date	2008.03.07.11.24.51;	author corinna;	state Exp;
branches;
next	1.474;

1.474
date	2008.03.05.18.31.09;	author corinna;	state Exp;
branches;
next	1.473;

1.473
date	2008.02.20.14.42.29;	author corinna;	state Exp;
branches;
next	1.472;

1.472
date	2008.02.15.17.53.10;	author cgf;	state Exp;
branches;
next	1.471;

1.471
date	2008.02.14.16.47.11;	author corinna;	state Exp;
branches;
next	1.470;

1.470
date	2008.02.01.12.37.51;	author corinna;	state Exp;
branches;
next	1.469;

1.469
date	2008.01.31.14.18.49;	author corinna;	state Exp;
branches;
next	1.468;

1.468
date	2008.01.28.12.19.30;	author corinna;	state Exp;
branches;
next	1.467;

1.467
date	2008.01.24.17.29.29;	author corinna;	state Exp;
branches;
next	1.466;

1.466
date	2008.01.22.17.43.22;	author corinna;	state Exp;
branches;
next	1.465;

1.465
date	2007.12.03.14.13.03;	author corinna;	state Exp;
branches;
next	1.464;

1.464
date	2007.11.26.21.30.49;	author cgf;	state Exp;
branches;
next	1.463;

1.463
date	2007.11.08.14.37.59;	author cgf;	state Exp;
branches;
next	1.462;

1.462
date	2007.11.08.14.36.49;	author cgf;	state Exp;
branches;
next	1.461;

1.461
date	2007.10.31.13.23.33;	author corinna;	state Exp;
branches;
next	1.460;

1.460
date	2007.10.23.16.26.27;	author corinna;	state Exp;
branches;
next	1.459;

1.459
date	2007.10.13.11.06.43;	author corinna;	state Exp;
branches;
next	1.458;

1.458
date	2007.10.11.16.26.19;	author corinna;	state Exp;
branches;
next	1.457;

1.457
date	2007.10.10.16.54.08;	author corinna;	state Exp;
branches;
next	1.456;

1.456
date	2007.09.18.11.05.44;	author corinna;	state Exp;
branches;
next	1.455;

1.455
date	2007.08.23.07.43.24;	author corinna;	state Exp;
branches;
next	1.454;

1.454
date	2007.08.21.12.37.39;	author corinna;	state Exp;
branches;
next	1.453;

1.453
date	2007.08.19.15.55.06;	author corinna;	state Exp;
branches;
next	1.452;

1.452
date	2007.08.16.15.07.41;	author corinna;	state Exp;
branches;
next	1.451;

1.451
date	2007.08.16.14.30.53;	author corinna;	state Exp;
branches;
next	1.450;

1.450
date	2007.08.16.10.41.45;	author corinna;	state Exp;
branches;
next	1.449;

1.449
date	2007.08.15.16.27.09;	author corinna;	state Exp;
branches;
next	1.448;

1.448
date	2007.08.14.16.19.13;	author corinna;	state Exp;
branches;
next	1.447;

1.447
date	2007.08.14.15.54.45;	author corinna;	state Exp;
branches;
next	1.446;

1.446
date	2007.08.14.14.48.52;	author corinna;	state Exp;
branches;
next	1.445;

1.445
date	2007.08.13.15.08.25;	author corinna;	state Exp;
branches;
next	1.444;

1.444
date	2007.08.12.15.42.02;	author corinna;	state Exp;
branches;
next	1.443;

1.443
date	2007.08.10.16.47.26;	author corinna;	state Exp;
branches;
next	1.442;

1.442
date	2007.08.01.12.55.25;	author corinna;	state Exp;
branches;
next	1.441;

1.441
date	2007.07.31.15.19.59;	author corinna;	state Exp;
branches;
next	1.440;

1.440
date	2007.07.26.17.30.54;	author corinna;	state Exp;
branches;
next	1.439;

1.439
date	2007.07.19.11.41.16;	author corinna;	state Exp;
branches;
next	1.438;

1.438
date	2007.07.07.16.48.26;	author cgf;	state Exp;
branches;
next	1.437;

1.437
date	2007.05.22.13.03.43;	author corinna;	state Exp;
branches;
next	1.436;

1.436
date	2007.05.22.12.43.31;	author corinna;	state Exp;
branches;
next	1.435;

1.435
date	2007.05.15.01.27.30;	author cgf;	state Exp;
branches;
next	1.434;

1.434
date	2007.03.01.15.13.47;	author cgf;	state Exp;
branches;
next	1.433;

1.433
date	2007.02.27.18.38.22;	author corinna;	state Exp;
branches;
next	1.432;

1.432
date	2007.02.22.18.01.12;	author corinna;	state Exp;
branches;
next	1.431;

1.431
date	2007.02.22.11.17.01;	author corinna;	state Exp;
branches;
next	1.430;

1.430
date	2007.02.20.00.16.17;	author cgf;	state Exp;
branches;
next	1.429;

1.429
date	2007.01.17.19.26.57;	author corinna;	state Exp;
branches;
next	1.428;

1.428
date	2007.01.16.18.01.06;	author corinna;	state Exp;
branches;
next	1.427;

1.427
date	2006.12.12.18.47.25;	author corinna;	state Exp;
branches;
next	1.426;

1.426
date	2006.12.10.16.43.30;	author corinna;	state Exp;
branches;
next	1.425;

1.425
date	2006.12.07.10.04.52;	author corinna;	state Exp;
branches;
next	1.424;

1.424
date	2006.12.05.21.46.26;	author corinna;	state Exp;
branches;
next	1.423;

1.423
date	2006.12.05.13.20.38;	author corinna;	state Exp;
branches;
next	1.422;

1.422
date	2006.11.30.10.17.24;	author corinna;	state Exp;
branches;
next	1.421;

1.421
date	2006.11.23.11.28.52;	author corinna;	state Exp;
branches;
next	1.420;

1.420
date	2006.11.07.17.59.54;	author corinna;	state Exp;
branches;
next	1.419;

1.419
date	2006.11.02.13.39.44;	author corinna;	state Exp;
branches;
next	1.418;

1.418
date	2006.11.02.12.19.16;	author corinna;	state Exp;
branches;
next	1.417;

1.417
date	2006.11.02.11.45.03;	author corinna;	state Exp;
branches;
next	1.416;

1.416
date	2006.10.31.11.40.47;	author corinna;	state Exp;
branches;
next	1.415;

1.415
date	2006.10.09.14.01.52;	author corinna;	state Exp;
branches;
next	1.414;

1.414
date	2006.08.02.15.11.48;	author cgf;	state Exp;
branches;
next	1.413;

1.413
date	2006.08.01.18.00.44;	author cgf;	state Exp;
branches;
next	1.412;

1.412
date	2006.07.19.08.20.26;	author corinna;	state Exp;
branches
	1.412.2.1;
next	1.411;

1.411
date	2006.07.05.08.35.51;	author corinna;	state Exp;
branches
	1.411.2.1;
next	1.410;

1.410
date	2006.07.03.18.30.08;	author corinna;	state Exp;
branches;
next	1.409;

1.409
date	2006.05.28.15.50.14;	author cgf;	state Exp;
branches;
next	1.408;

1.408
date	2006.04.26.16.51.09;	author corinna;	state Exp;
branches;
next	1.407;

1.407
date	2006.03.01.13.47.49;	author corinna;	state Exp;
branches;
next	1.406;

1.406
date	2006.02.17.20.12.11;	author cgf;	state Exp;
branches;
next	1.405;

1.405
date	2006.02.05.18.18.02;	author corinna;	state Exp;
branches;
next	1.404;

1.404
date	2006.02.03.21.33.09;	author corinna;	state Exp;
branches;
next	1.403;

1.403
date	2006.01.31.21.09.43;	author corinna;	state Exp;
branches;
next	1.402;

1.402
date	2006.01.31.16.10.29;	author corinna;	state Exp;
branches;
next	1.401;

1.401
date	2006.01.31.14.43.37;	author corinna;	state Exp;
branches;
next	1.400;

1.400
date	2006.01.24.17.40.55;	author corinna;	state Exp;
branches;
next	1.399;

1.399
date	2006.01.04.16.20.30;	author cgf;	state Exp;
branches;
next	1.398;

1.398
date	2005.12.27.18.10.49;	author corinna;	state Exp;
branches;
next	1.397;

1.397
date	2005.12.22.05.57.54;	author cgf;	state Exp;
branches;
next	1.396;

1.396
date	2005.12.01.17.33.59;	author cgf;	state Exp;
branches;
next	1.395;

1.395
date	2005.10.12.20.38.38;	author cgf;	state Exp;
branches;
next	1.394;

1.394
date	2005.10.11.16.06.10;	author cgf;	state Exp;
branches;
next	1.393;

1.393
date	2005.09.29.16.23.21;	author corinna;	state Exp;
branches;
next	1.392;

1.392
date	2005.09.28.19.22.23;	author corinna;	state Exp;
branches;
next	1.391;

1.391
date	2005.09.28.19.02.50;	author corinna;	state Exp;
branches;
next	1.390;

1.390
date	2005.09.12.21.19.07;	author cgf;	state Exp;
branches;
next	1.389;

1.389
date	2005.08.26.15.11.06;	author corinna;	state Exp;
branches;
next	1.388;

1.388
date	2005.08.25.21.18.26;	author corinna;	state Exp;
branches;
next	1.387;

1.387
date	2005.08.25.20.35.25;	author corinna;	state Exp;
branches;
next	1.386;

1.386
date	2005.08.24.14.17.56;	author cgf;	state Exp;
branches;
next	1.385;

1.385
date	2005.08.24.04.38.39;	author cgf;	state Exp;
branches;
next	1.384;

1.384
date	2005.07.09.17.15.38;	author cgf;	state Exp;
branches;
next	1.383;

1.383
date	2005.07.06.20.05.02;	author cgf;	state Exp;
branches;
next	1.382;

1.382
date	2005.07.05.02.05.07;	author cgf;	state Exp;
branches;
next	1.381;

1.381
date	2005.07.03.02.40.28;	author cgf;	state Exp;
branches;
next	1.380;

1.380
date	2005.06.24.09.15.05;	author corinna;	state Exp;
branches;
next	1.379;

1.379
date	2005.06.14.23.52.53;	author cgf;	state Exp;
branches;
next	1.378;

1.378
date	2005.06.06.16.58.39;	author corinna;	state Exp;
branches;
next	1.377;

1.377
date	2005.05.29.11.04.02;	author corinna;	state Exp;
branches;
next	1.376;

1.376
date	2005.05.17.01.29.27;	author cgf;	state Exp;
branches;
next	1.375;

1.375
date	2005.05.17.01.08.58;	author cgf;	state Exp;
branches;
next	1.374;

1.374
date	2005.05.13.21.05.46;	author cgf;	state Exp;
branches;
next	1.373;

1.373
date	2005.05.13.15.46.06;	author cgf;	state Exp;
branches;
next	1.372;

1.372
date	2005.05.13.03.21.39;	author cgf;	state Exp;
branches;
next	1.371;

1.371
date	2005.05.10.09.08.20;	author corinna;	state Exp;
branches;
next	1.370;

1.370
date	2005.05.09.02.39.34;	author phumblet;	state Exp;
branches;
next	1.369;

1.369
date	2005.05.07.21.06.08;	author cgf;	state Exp;
branches;
next	1.368;

1.368
date	2005.05.06.21.09.58;	author cgf;	state Exp;
branches;
next	1.367;

1.367
date	2005.05.02.03.50.07;	author cgf;	state Exp;
branches;
next	1.366;

1.366
date	2005.04.20.20.50.57;	author cgf;	state Exp;
branches;
next	1.365;

1.365
date	2005.04.20.20.43.36;	author cgf;	state Exp;
branches;
next	1.364;

1.364
date	2005.04.20.18.25.14;	author cgf;	state Exp;
branches;
next	1.363;

1.363
date	2005.04.20.04.06.25;	author cgf;	state Exp;
branches;
next	1.362;

1.362
date	2005.04.16.17.17.33;	author corinna;	state Exp;
branches;
next	1.361;

1.361
date	2005.04.05.04.30.59;	author cgf;	state Exp;
branches;
next	1.360;

1.360
date	2005.04.04.16.07.36;	author cgf;	state Exp;
branches;
next	1.359;

1.359
date	2005.04.03.13.06.42;	author corinna;	state Exp;
branches;
next	1.358;

1.358
date	2005.04.03.08.45.18;	author corinna;	state Exp;
branches;
next	1.357;

1.357
date	2005.03.30.20.01.43;	author corinna;	state Exp;
branches;
next	1.356;

1.356
date	2005.03.29.17.42.50;	author corinna;	state Exp;
branches;
next	1.355;

1.355
date	2005.03.12.02.32.59;	author cgf;	state Exp;
branches;
next	1.354;

1.354
date	2005.03.10.17.02.52;	author corinna;	state Exp;
branches;
next	1.353;

1.353
date	2005.03.09.20.33.21;	author cgf;	state Exp;
branches;
next	1.352;

1.352
date	2005.03.06.21.28.28;	author cgf;	state Exp;
branches;
next	1.351;

1.351
date	2005.03.06.20.15.07;	author cgf;	state Exp;
branches;
next	1.350;

1.350
date	2005.02.27.04.30.08;	author cgf;	state Exp;
branches;
next	1.349;

1.349
date	2005.02.22.19.45.40;	author corinna;	state Exp;
branches;
next	1.348;

1.348
date	2005.02.17.17.21.11;	author cgf;	state Exp;
branches;
next	1.347;

1.347
date	2005.02.13.18.17.29;	author cgf;	state Exp;
branches;
next	1.346;

1.346
date	2005.02.06.11.15.28;	author corinna;	state Exp;
branches;
next	1.345;

1.345
date	2005.02.01.16.49.12;	author cgf;	state Exp;
branches;
next	1.344;

1.344
date	2005.02.01.15.11.44;	author corinna;	state Exp;
branches;
next	1.343;

1.343
date	2005.01.31.21.29.58;	author cgf;	state Exp;
branches;
next	1.342;

1.342
date	2005.01.31.10.28.53;	author corinna;	state Exp;
branches;
next	1.341;

1.341
date	2005.01.29.11.23.06;	author corinna;	state Exp;
branches;
next	1.340;

1.340
date	2005.01.26.04.34.19;	author phumblet;	state Exp;
branches;
next	1.339;

1.339
date	2005.01.25.20.28.40;	author corinna;	state Exp;
branches;
next	1.338;

1.338
date	2005.01.18.13.00.18;	author corinna;	state Exp;
branches;
next	1.337;

1.337
date	2005.01.06.16.36.40;	author cgf;	state Exp;
branches;
next	1.336;

1.336
date	2004.12.26.02.10.30;	author cgf;	state Exp;
branches;
next	1.335;

1.335
date	2004.12.23.21.37.43;	author cgf;	state Exp;
branches;
next	1.334;

1.334
date	2004.12.23.15.26.38;	author cgf;	state Exp;
branches;
next	1.333;

1.333
date	2004.12.22.11.31.30;	author corinna;	state Exp;
branches;
next	1.332;

1.332
date	2004.12.20.17.55.22;	author cgf;	state Exp;
branches;
next	1.331;

1.331
date	2004.12.20.16.31.18;	author cgf;	state Exp;
branches;
next	1.330;

1.330
date	2004.12.19.03.27.09;	author cgf;	state Exp;
branches;
next	1.329;

1.329
date	2004.12.19.02.40.40;	author cgf;	state Exp;
branches;
next	1.328;

1.328
date	2004.12.18.16.41.27;	author cgf;	state Exp;
branches;
next	1.327;

1.327
date	2004.12.18.16.37.44;	author cgf;	state Exp;
branches;
next	1.326;

1.326
date	2004.12.03.02.00.37;	author phumblet;	state Exp;
branches;
next	1.325;

1.325
date	2004.10.28.01.46.01;	author phumblet;	state Exp;
branches;
next	1.324;

1.324
date	2004.10.06.01.33.39;	author phumblet;	state Exp;
branches;
next	1.323;

1.323
date	2004.10.02.02.20.20;	author phumblet;	state Exp;
branches;
next	1.322;

1.322
date	2004.09.24.19.41.19;	author cgf;	state Exp;
branches;
next	1.321;

1.321
date	2004.09.23.00.32.08;	author phumblet;	state Exp;
branches;
next	1.320;

1.320
date	2004.09.12.03.47.56;	author cgf;	state Exp;
branches;
next	1.319;

1.319
date	2004.09.07.23.26.28;	author phumblet;	state Exp;
branches;
next	1.318;

1.318
date	2004.09.03.01.53.12;	author cgf;	state Exp;
branches;
next	1.317;

1.317
date	2004.06.17.13.34.24;	author phumblet;	state Exp;
branches;
next	1.316;

1.316
date	2004.06.08.07.20.04;	author corinna;	state Exp;
branches;
next	1.315;

1.315
date	2004.06.02.21.20.53;	author cgf;	state Exp;
branches;
next	1.314;

1.314
date	2004.05.31.02.20.39;	author phumblet;	state Exp;
branches;
next	1.313;

1.313
date	2004.05.28.19.50.06;	author cgf;	state Exp;
branches;
next	1.312;

1.312
date	2004.05.15.15.55.43;	author cgf;	state Exp;
branches;
next	1.311;

1.311
date	2004.05.12.14.04.23;	author corinna;	state Exp;
branches;
next	1.310;

1.310
date	2004.05.07.03.27.37;	author cgf;	state Exp;
branches;
next	1.309;

1.309
date	2004.05.06.16.26.10;	author phumblet;	state Exp;
branches;
next	1.308;

1.308
date	2004.05.04.15.14.48;	author cgf;	state Exp;
branches;
next	1.307;

1.307
date	2004.05.04.15.09.58;	author cgf;	state Exp;
branches;
next	1.306;

1.306
date	2004.05.04.10.54.06;	author corinna;	state Exp;
branches;
next	1.305;

1.305
date	2004.04.30.17.36.36;	author corinna;	state Exp;
branches;
next	1.304;

1.304
date	2004.04.20.18.46.15;	author cgf;	state Exp;
branches;
next	1.303;

1.303
date	2004.04.20.18.45.16;	author cgf;	state Exp;
branches;
next	1.302;

1.302
date	2004.04.16.21.22.13;	author corinna;	state Exp;
branches;
next	1.301;

1.301
date	2004.04.14.03.08.00;	author phumblet;	state Exp;
branches;
next	1.300;

1.300
date	2004.04.13.20.36.58;	author corinna;	state Exp;
branches;
next	1.299;

1.299
date	2004.04.13.09.04.21;	author corinna;	state Exp;
branches;
next	1.298;

1.298
date	2004.04.12.23.59.23;	author phumblet;	state Exp;
branches;
next	1.297;

1.297
date	2004.04.10.19.24.55;	author corinna;	state Exp;
branches;
next	1.296;

1.296
date	2004.04.10.13.45.10;	author corinna;	state Exp;
branches;
next	1.295;

1.295
date	2004.04.10.00.50.16;	author cgf;	state Exp;
branches;
next	1.294;

1.294
date	2004.04.09.19.33.07;	author corinna;	state Exp;
branches;
next	1.293;

1.293
date	2004.04.08.12.21.15;	author corinna;	state Exp;
branches;
next	1.292;

1.292
date	2004.04.08.01.33.00;	author cgf;	state Exp;
branches;
next	1.291;

1.291
date	2004.03.26.20.02.01;	author cgf;	state Exp;
branches;
next	1.290;

1.290
date	2004.03.25.15.15.27;	author cgf;	state Exp;
branches;
next	1.289;

1.289
date	2004.03.24.21.46.09;	author cgf;	state Exp;
branches;
next	1.288;

1.288
date	2004.02.21.04.46.00;	author cgf;	state Exp;
branches;
next	1.287;

1.287
date	2004.02.17.20.03.01;	author cgf;	state Exp;
branches;
next	1.286;

1.286
date	2003.12.26.18.26.17;	author cgf;	state Exp;
branches;
next	1.285;

1.285
date	2003.12.23.16.26.30;	author cgf;	state Exp;
branches;
next	1.284;

1.284
date	2003.12.15.04.16.42;	author cgf;	state Exp;
branches;
next	1.283;

1.283
date	2003.12.07.22.37.11;	author cgf;	state Exp;
branches;
next	1.282;

1.282
date	2003.12.05.04.33.40;	author cgf;	state Exp;
branches;
next	1.281;

1.281
date	2003.11.28.20.55.58;	author cgf;	state Exp;
branches;
next	1.280;

1.280
date	2003.11.26.13.23.27;	author corinna;	state Exp;
branches;
next	1.279;

1.279
date	2003.11.14.23.40.05;	author rbcollins;	state Exp;
branches;
next	1.278;

1.278
date	2003.10.29.01.15.12;	author cgf;	state Exp;
branches;
next	1.277;

1.277
date	2003.10.25.16.12.45;	author corinna;	state Exp;
branches;
next	1.276;

1.276
date	2003.10.24.08.13.15;	author corinna;	state Exp;
branches;
next	1.275;

1.275
date	2003.10.02.03.50.10;	author cgf;	state Exp;
branches;
next	1.274;

1.274
date	2003.10.01.12.36.39;	author cgf;	state Exp;
branches;
next	1.273;

1.273
date	2003.09.30.21.03.57;	author corinna;	state Exp;
branches;
next	1.272;

1.272
date	2003.09.28.09.44.13;	author corinna;	state Exp;
branches;
next	1.271;

1.271
date	2003.09.27.05.44.58;	author cgf;	state Exp;
branches;
next	1.270;

1.270
date	2003.09.25.00.37.17;	author cgf;	state Exp;
branches;
next	1.269;

1.269
date	2003.09.11.17.46.31;	author cgf;	state Exp;
branches;
next	1.268;

1.268
date	2003.09.10.16.22.49;	author cgf;	state Exp;
branches;
next	1.267;

1.267
date	2003.08.31.18.26.58;	author cgf;	state Exp;
branches;
next	1.266;

1.266
date	2003.08.28.02.04.16;	author cgf;	state Exp;
branches;
next	1.265;

1.265
date	2003.08.19.00.18.48;	author cgf;	state Exp;
branches;
next	1.264;

1.264
date	2003.08.17.16.33.15;	author cgf;	state Exp;
branches;
next	1.263;

1.263
date	2003.08.13.17.28.00;	author corinna;	state Exp;
branches;
next	1.262;

1.262
date	2003.08.05.04.49.44;	author cgf;	state Exp;
branches;
next	1.261;

1.261
date	2003.07.26.04.53.59;	author cgf;	state Exp;
branches;
next	1.260;

1.260
date	2003.07.11.00.54.46;	author cgf;	state Exp;
branches;
next	1.259;

1.259
date	2003.07.04.03.08.26;	author cgf;	state Exp;
branches;
next	1.258;

1.258
date	2003.07.04.03.07.01;	author cgf;	state Exp;
branches;
next	1.257;

1.257
date	2003.06.17.16.52.18;	author cgf;	state Exp;
branches;
next	1.256;

1.256
date	2003.06.16.03.24.11;	author cgf;	state Exp;
branches;
next	1.255;

1.255
date	2003.06.04.22.59.55;	author cgf;	state Exp;
branches;
next	1.254;

1.254
date	2003.05.30.23.43.24;	author cgf;	state Exp;
branches;
next	1.253;

1.253
date	2003.05.30.15.01.33;	author cgf;	state Exp;
branches;
next	1.252;

1.252
date	2003.05.29.03.50.15;	author cgf;	state Exp;
branches;
next	1.251;

1.251
date	2003.05.11.21.52.09;	author corinna;	state Exp;
branches;
next	1.250;

1.250
date	2003.05.11.00.10.10;	author cgf;	state Exp;
branches;
next	1.249;

1.249
date	2003.04.27.03.09.17;	author cgf;	state Exp;
branches;
next	1.248;

1.248
date	2003.03.09.20.31.07;	author cgf;	state Exp;
branches
	1.248.2.1;
next	1.247;

1.247
date	2003.03.08.03.36.39;	author cgf;	state Exp;
branches;
next	1.246;

1.246
date	2003.02.21.14.29.18;	author corinna;	state Exp;
branches;
next	1.245;

1.245
date	2003.02.05.21.12.58;	author cgf;	state Exp;
branches;
next	1.244;

1.244
date	2003.02.05.16.40.51;	author cgf;	state Exp;
branches;
next	1.243;

1.243
date	2003.02.04.19.26.01;	author corinna;	state Exp;
branches;
next	1.242;

1.242
date	2003.01.24.03.53.46;	author cgf;	state Exp;
branches;
next	1.241;

1.241
date	2003.01.21.05.07.28;	author cgf;	state Exp;
branches;
next	1.240;

1.240
date	2003.01.20.02.57.54;	author cgf;	state Exp;
branches;
next	1.239;

1.239
date	2003.01.16.01.49.14;	author cgf;	state Exp;
branches;
next	1.238;

1.238
date	2003.01.10.21.24.04;	author cgf;	state Exp;
branches
	1.238.2.1;
next	1.237;

1.237
date	2003.01.10.20.25.47;	author corinna;	state Exp;
branches;
next	1.236;

1.236
date	2003.01.10.12.32.46;	author corinna;	state Exp;
branches;
next	1.235;

1.235
date	2003.01.09.08.22.04;	author cgf;	state Exp;
branches;
next	1.234;

1.234
date	2002.09.30.04.35.18;	author cgf;	state Exp;
branches
	1.234.16.1;
next	1.233;

1.233
date	2002.09.30.02.51.21;	author cgf;	state Exp;
branches;
next	1.232;

1.232
date	2002.09.23.00.31.30;	author cgf;	state Exp;
branches;
next	1.231;

1.231
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.230;

1.230
date	2002.09.06.04.39.49;	author cgf;	state Exp;
branches;
next	1.229;

1.229
date	2002.09.04.13.11.29;	author corinna;	state Exp;
branches;
next	1.228;

1.228
date	2002.07.24.05.37.46;	author cgf;	state Exp;
branches;
next	1.227;

1.227
date	2002.07.05.21.58.49;	author cgf;	state Exp;
branches;
next	1.226;

1.226
date	2002.07.03.18.02.54;	author cgf;	state Exp;
branches
	1.226.2.1;
next	1.225;

1.225
date	2002.07.01.19.03.26;	author cgf;	state Exp;
branches;
next	1.224;

1.224
date	2002.06.13.03.04.50;	author cgf;	state Exp;
branches;
next	1.223;

1.223
date	2002.06.11.23.30.48;	author cgf;	state Exp;
branches;
next	1.222;

1.222
date	2002.06.09.00.48.38;	author cgf;	state Exp;
branches;
next	1.221;

1.221
date	2002.06.09.00.31.02;	author cgf;	state Exp;
branches;
next	1.220;

1.220
date	2002.06.06.00.09.55;	author cgf;	state Exp;
branches;
next	1.219;

1.219
date	2002.06.05.04.01.42;	author cgf;	state Exp;
branches;
next	1.218;

1.218
date	2002.06.05.01.42.28;	author cgf;	state Exp;
branches;
next	1.217;

1.217
date	2002.06.04.01.40.53;	author cgf;	state Exp;
branches;
next	1.216;

1.216
date	2002.06.01.18.20.51;	author cgf;	state Exp;
branches;
next	1.215;

1.215
date	2002.05.31.23.00.18;	author cgf;	state Exp;
branches;
next	1.214;

1.214
date	2002.05.31.22.53.25;	author cgf;	state Exp;
branches;
next	1.213;

1.213
date	2002.05.31.03.11.21;	author cgf;	state Exp;
branches;
next	1.212;

1.212
date	2002.05.28.01.55.40;	author cgf;	state Exp;
branches;
next	1.211;

1.211
date	2002.05.25.02.22.50;	author cgf;	state Exp;
branches;
next	1.210;

1.210
date	2002.05.24.05.44.10;	author cgf;	state Exp;
branches;
next	1.209;

1.209
date	2002.05.23.20.01.46;	author cgf;	state Exp;
branches;
next	1.208;

1.208
date	2002.05.22.22.09.57;	author cgf;	state Exp;
branches;
next	1.207;

1.207
date	2002.05.18.20.27.49;	author cgf;	state Exp;
branches;
next	1.206;

1.206
date	2002.05.12.03.08.59;	author cgf;	state Exp;
branches;
next	1.205;

1.205
date	2002.05.12.01.41.17;	author cgf;	state Exp;
branches;
next	1.204;

1.204
date	2002.05.04.03.24.35;	author cgf;	state Exp;
branches;
next	1.203;

1.203
date	2002.05.03.02.43.45;	author cgf;	state Exp;
branches;
next	1.202;

1.202
date	2002.05.02.16.46.12;	author corinna;	state Exp;
branches;
next	1.201;

1.201
date	2002.05.02.04.14.40;	author cgf;	state Exp;
branches;
next	1.200;

1.200
date	2002.05.02.04.13.45;	author cgf;	state Exp;
branches;
next	1.199;

1.199
date	2002.03.07.01.31.08;	author cgf;	state Exp;
branches;
next	1.198;

1.198
date	2002.02.22.19.33.41;	author cgf;	state Exp;
branches;
next	1.197;

1.197
date	2002.02.17.04.59.54;	author cgf;	state Exp;
branches;
next	1.196;

1.196
date	2002.01.23.16.50.17;	author corinna;	state Exp;
branches;
next	1.195;

1.195
date	2002.01.15.20.29.09;	author corinna;	state Exp;
branches;
next	1.194;

1.194
date	2002.01.14.20.39.59;	author corinna;	state Exp;
branches;
next	1.193;

1.193
date	2001.12.08.01.27.10;	author cgf;	state Exp;
branches;
next	1.192;

1.192
date	2001.12.07.05.03.32;	author cgf;	state Exp;
branches;
next	1.191;

1.191
date	2001.12.06.22.36.08;	author cgf;	state Exp;
branches;
next	1.190;

1.190
date	2001.12.03.20.09.33;	author cgf;	state Exp;
branches;
next	1.189;

1.189
date	2001.12.03.16.47.18;	author cgf;	state Exp;
branches;
next	1.188;

1.188
date	2001.11.24.21.05.00;	author cgf;	state Exp;
branches
	1.188.2.1;
next	1.187;

1.187
date	2001.11.24.20.57.19;	author cgf;	state Exp;
branches;
next	1.186;

1.186
date	2001.11.24.03.35.58;	author cgf;	state Exp;
branches;
next	1.185;

1.185
date	2001.11.24.03.11.39;	author cgf;	state Exp;
branches;
next	1.184;

1.184
date	2001.11.22.05.59.07;	author cgf;	state Exp;
branches;
next	1.183;

1.183
date	2001.11.21.06.47.57;	author cgf;	state Exp;
branches;
next	1.182;

1.182
date	2001.11.17.20.19.19;	author cgf;	state Exp;
branches;
next	1.181;

1.181
date	2001.11.13.21.49.06;	author corinna;	state Exp;
branches;
next	1.180;

1.180
date	2001.11.05.06.09.07;	author cgf;	state Exp;
branches;
next	1.179;

1.179
date	2001.10.29.05.28.24;	author cgf;	state Exp;
branches;
next	1.178;

1.178
date	2001.10.24.21.56.53;	author cgf;	state Exp;
branches;
next	1.177;

1.177
date	2001.10.19.19.17.04;	author corinna;	state Exp;
branches;
next	1.176;

1.176
date	2001.10.16.20.17.23;	author corinna;	state Exp;
branches;
next	1.175;

1.175
date	2001.10.16.14.53.26;	author corinna;	state Exp;
branches;
next	1.174;

1.174
date	2001.10.16.13.49.38;	author cgf;	state Exp;
branches;
next	1.173;

1.173
date	2001.10.15.23.39.33;	author cgf;	state Exp;
branches;
next	1.172;

1.172
date	2001.10.14.15.49.13;	author cgf;	state Exp;
branches;
next	1.171;

1.171
date	2001.10.13.17.23.35;	author cgf;	state Exp;
branches;
next	1.170;

1.170
date	2001.10.07.21.16.36;	author cgf;	state Exp;
branches;
next	1.169;

1.169
date	2001.10.05.18.23.49;	author cgf;	state Exp;
branches;
next	1.168;

1.168
date	2001.10.05.15.05.07;	author cgf;	state Exp;
branches;
next	1.167;

1.167
date	2001.10.05.00.52.41;	author cgf;	state Exp;
branches;
next	1.166;

1.166
date	2001.10.05.00.17.57;	author cgf;	state Exp;
branches;
next	1.165;

1.165
date	2001.10.04.02.34.19;	author cgf;	state Exp;
branches;
next	1.164;

1.164
date	2001.10.01.04.10.06;	author cgf;	state Exp;
branches;
next	1.163;

1.163
date	2001.09.16.14.26.11;	author duda;	state Exp;
branches
	1.163.2.1;
next	1.162;

1.162
date	2001.09.07.21.32.04;	author cgf;	state Exp;
branches;
next	1.161;

1.161
date	2001.09.06.05.17.22;	author cgf;	state Exp;
branches;
next	1.160;

1.160
date	2001.09.06.03.39.18;	author cgf;	state Exp;
branches;
next	1.159;

1.159
date	2001.08.29.04.43.19;	author cgf;	state Exp;
branches;
next	1.158;

1.158
date	2001.08.07.15.09.54;	author corinna;	state Exp;
branches;
next	1.157;

1.157
date	2001.08.03.11.14.09;	author corinna;	state Exp;
branches;
next	1.156;

1.156
date	2001.07.26.19.22.24;	author cgf;	state Exp;
branches;
next	1.155;

1.155
date	2001.06.28.02.19.57;	author cgf;	state Exp;
branches;
next	1.154;

1.154
date	2001.06.24.22.26.52;	author cgf;	state Exp;
branches;
next	1.153;

1.153
date	2001.06.16.17.09.19;	author cgf;	state Exp;
branches;
next	1.152;

1.152
date	2001.06.15.20.35.51;	author cgf;	state Exp;
branches;
next	1.151;

1.151
date	2001.06.11.15.20.49;	author cgf;	state Exp;
branches;
next	1.150;

1.150
date	2001.06.11.03.38.32;	author cgf;	state Exp;
branches;
next	1.149;

1.149
date	2001.06.11.00.24.28;	author cgf;	state Exp;
branches;
next	1.148;

1.148
date	2001.06.10.10.00.20;	author corinna;	state Exp;
branches;
next	1.147;

1.147
date	2001.06.05.10.45.52;	author duda;	state Exp;
branches;
next	1.146;

1.146
date	2001.06.04.01.28.09;	author cgf;	state Exp;
branches;
next	1.145;

1.145
date	2001.06.03.02.31.16;	author cgf;	state Exp;
branches;
next	1.144;

1.144
date	2001.06.01.14.57.52;	author cgf;	state Exp;
branches;
next	1.143;

1.143
date	2001.05.31.05.25.46;	author cgf;	state Exp;
branches;
next	1.142;

1.142
date	2001.05.25.15.07.46;	author cgf;	state Exp;
branches;
next	1.141;

1.141
date	2001.05.25.08.31.57;	author corinna;	state Exp;
branches;
next	1.140;

1.140
date	2001.05.25.03.13.14;	author cgf;	state Exp;
branches;
next	1.139;

1.139
date	2001.05.14.02.52.12;	author cgf;	state Exp;
branches;
next	1.138;

1.138
date	2001.05.11.21.01.44;	author cgf;	state Exp;
branches;
next	1.137;

1.137
date	2001.05.09.18.59.10;	author cgf;	state Exp;
branches;
next	1.136;

1.136
date	2001.05.08.15.16.49;	author cgf;	state Exp;
branches;
next	1.135;

1.135
date	2001.05.04.20.39.38;	author cgf;	state Exp;
branches;
next	1.134;

1.134
date	2001.05.01.05.26.06;	author cgf;	state Exp;
branches;
next	1.133;

1.133
date	2001.05.01.04.45.19;	author cgf;	state Exp;
branches;
next	1.132;

1.132
date	2001.05.01.02.03.10;	author cgf;	state Exp;
branches;
next	1.131;

1.131
date	2001.04.30.16.52.53;	author cgf;	state Exp;
branches;
next	1.130;

1.130
date	2001.04.30.01.46.31;	author cgf;	state Exp;
branches;
next	1.129;

1.129
date	2001.04.28.23.48.28;	author cgf;	state Exp;
branches;
next	1.128;

1.128
date	2001.04.22.16.19.27;	author cgf;	state Exp;
branches;
next	1.127;

1.127
date	2001.04.20.16.40.04;	author cgf;	state Exp;
branches;
next	1.126;

1.126
date	2001.04.18.21.10.12;	author cgf;	state Exp;
branches;
next	1.125;

1.125
date	2001.04.17.23.12.11;	author cgf;	state Exp;
branches;
next	1.124;

1.124
date	2001.04.17.16.52.09;	author corinna;	state Exp;
branches;
next	1.123;

1.123
date	2001.04.17.16.16.27;	author cgf;	state Exp;
branches;
next	1.122;

1.122
date	2001.04.17.11.47.37;	author corinna;	state Exp;
branches;
next	1.121;

1.121
date	2001.04.17.03.52.08;	author cgf;	state Exp;
branches;
next	1.120;

1.120
date	2001.04.16.03.27.16;	author cgf;	state Exp;
branches;
next	1.119;

1.119
date	2001.04.15.14.00.45;	author corinna;	state Exp;
branches;
next	1.118;

1.118
date	2001.04.13.07.54.20;	author corinna;	state Exp;
branches;
next	1.117;

1.117
date	2001.04.12.21.21.37;	author corinna;	state Exp;
branches;
next	1.116;

1.116
date	2001.04.11.19.09.53;	author cgf;	state Exp;
branches;
next	1.115;

1.115
date	2001.04.02.04.27.12;	author cgf;	state Exp;
branches;
next	1.114;

1.114
date	2001.04.01.05.09.57;	author cgf;	state Exp;
branches;
next	1.113;

1.113
date	2001.04.01.03.06.02;	author cgf;	state Exp;
branches;
next	1.112;

1.112
date	2001.03.29.00.30.39;	author cgf;	state Exp;
branches;
next	1.111;

1.111
date	2001.03.17.17.44.53;	author cgf;	state Exp;
branches;
next	1.110;

1.110
date	2001.03.17.07.09.41;	author cgf;	state Exp;
branches;
next	1.109;

1.109
date	2001.03.17.01.29.14;	author cgf;	state Exp;
branches;
next	1.108;

1.108
date	2001.03.14.11.13.46;	author corinna;	state Exp;
branches;
next	1.107;

1.107
date	2001.03.06.13.05.56;	author corinna;	state Exp;
branches;
next	1.106;

1.106
date	2001.03.05.06.28.23;	author cgf;	state Exp;
branches;
next	1.105;

1.105
date	2001.03.02.11.41.09;	author corinna;	state Exp;
branches;
next	1.104;

1.104
date	2001.02.25.09.34.00;	author corinna;	state Exp;
branches;
next	1.103;

1.103
date	2001.02.22.16.26.13;	author corinna;	state Exp;
branches;
next	1.102;

1.102
date	2001.02.22.16.14.59;	author corinna;	state Exp;
branches;
next	1.101;

1.101
date	2001.02.22.14.51.16;	author corinna;	state Exp;
branches;
next	1.100;

1.100
date	2001.02.22.12.56.36;	author corinna;	state Exp;
branches;
next	1.99;

1.99
date	2001.02.22.11.06.25;	author corinna;	state Exp;
branches;
next	1.98;

1.98
date	2001.02.21.22.59.11;	author corinna;	state Exp;
branches;
next	1.97;

1.97
date	2001.02.21.21.49.36;	author corinna;	state Exp;
branches;
next	1.96;

1.96
date	2001.01.28.06.23.42;	author cgf;	state Exp;
branches;
next	1.95;

1.95
date	2001.01.28.05.51.14;	author cgf;	state Exp;
branches;
next	1.94;

1.94
date	2001.01.27.15.34.38;	author cgf;	state Exp;
branches;
next	1.93;

1.93
date	2001.01.22.20.36.38;	author cgf;	state Exp;
branches;
next	1.92;

1.92
date	2001.01.22.20.29.19;	author cgf;	state Exp;
branches;
next	1.91;

1.91
date	2000.12.19.19.52.57;	author corinna;	state Exp;
branches;
next	1.90;

1.90
date	2000.12.15.22.25.51;	author cgf;	state Exp;
branches;
next	1.89;

1.89
date	2000.12.09.21.31.49;	author cgf;	state Exp;
branches;
next	1.88;

1.88
date	2000.12.09.03.29.33;	author cgf;	state Exp;
branches;
next	1.87;

1.87
date	2000.12.03.06.21.40;	author cgf;	state Exp;
branches;
next	1.86;

1.86
date	2000.12.03.05.16.33;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2000.11.28.18.45.42;	author corinna;	state Exp;
branches;
next	1.84;

1.84
date	2000.11.24.18.04.44;	author cgf;	state Exp;
branches;
next	1.83;

1.83
date	2000.11.17.18.39.47;	author corinna;	state Exp;
branches;
next	1.82;

1.82
date	2000.11.15.00.13.08;	author corinna;	state Exp;
branches;
next	1.81;

1.81
date	2000.11.14.05.53.32;	author cgf;	state Exp;
branches;
next	1.80;

1.80
date	2000.11.13.04.06.40;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2000.11.08.20.36.36;	author cgf;	state Exp;
branches;
next	1.78;

1.78
date	2000.11.06.16.40.29;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2000.11.02.02.15.02;	author cgf;	state Exp;
branches;
next	1.76;

1.76
date	2000.10.31.23.14.29;	author cgf;	state Exp;
branches;
next	1.75;

1.75
date	2000.10.31.23.01.21;	author cgf;	state Exp;
branches;
next	1.74;

1.74
date	2000.10.23.03.35.50;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2000.10.19.03.12.44;	author dj;	state Exp;
branches;
next	1.72;

1.72
date	2000.10.19.00.45.39;	author dj;	state Exp;
branches;
next	1.71;

1.71
date	2000.10.17.01.46.26;	author dj;	state Exp;
branches;
next	1.70;

1.70
date	2000.10.16.23.55.57;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2000.10.15.01.37.06;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2000.10.12.22.15.47;	author cgf;	state Exp;
branches;
next	1.67;

1.67
date	2000.10.10.19.24.32;	author cgf;	state Exp;
branches;
next	1.66;

1.66
date	2000.10.09.18.10.53;	author cgf;	state Exp;
branches;
next	1.65;

1.65
date	2000.10.09.02.53.44;	author cgf;	state Exp;
branches;
next	1.64;

1.64
date	2000.10.07.17.35.36;	author corinna;	state Exp;
branches;
next	1.63;

1.63
date	2000.10.06.19.11.14;	author cgf;	state Exp;
branches;
next	1.62;

1.62
date	2000.10.02.02.26.04;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2000.10.01.01.02.40;	author corinna;	state Exp;
branches;
next	1.60;

1.60
date	2000.09.30.01.56.40;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2000.09.19.03.22.44;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2000.09.18.16.42.28;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2000.09.12.18.41.36;	author cgf;	state Exp;
branches;
next	1.56;

1.56
date	2000.09.11.17.21.13;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2000.09.10.16.43.47;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2000.09.10.03.36.40;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2000.09.08.02.56.54;	author cgf;	state Exp;
branches;
next	1.52;

1.52
date	2000.09.07.16.23.50;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2000.09.06.06.42.08;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2000.09.06.01.56.17;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2000.09.05.21.51.06;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2000.09.05.03.16.28;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2000.09.04.17.52.42;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2000.09.03.04.16.35;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2000.08.22.17.59.53;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.43;

1.43
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2000.08.12.05.35.42;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2000.08.02.16.28.17;	author dj;	state Exp;
branches;
next	1.40;

1.40
date	2000.07.29.17.36.05;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2000.07.28.22.33.43;	author cgf;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2000.07.19.20.14.24;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2000.07.17.19.18.21;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2000.07.02.02.03.50;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2000.07.01.17.30.35;	author corinna;	state Exp;
branches;
next	1.34;

1.34
date	2000.06.16.23.39.02;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2000.06.15.22.14.14;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2000.06.15.20.52.57;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2000.06.15.19.44.50;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2000.06.13.16.48.37;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2000.06.13.04.40.36;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2000.06.08.20.51.11;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2000.06.08.13.24.52;	author corinna;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.08.00.55.27;	author dj;	state Exp;
branches;
next	1.25;

1.25
date	2000.05.30.21.24.50;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2000.05.30.00.38.51;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2000.05.23.14.08.52;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2000.05.17.05.49.51;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2000.05.08.22.50.19;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2000.05.04.19.46.32;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2000.05.03.15.39.10;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2000.05.02.15.42.30;	author dj;	state Exp;
branches;
next	1.17;

1.17
date	2000.04.27.03.26.23;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2000.04.26.05.13.32;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2000.04.25.16.31.14;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.21.14.37.48;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.21.05.32.19;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.20.20.42.14;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.20.04.38.10;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.13.22.43.48;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.13.06.48.14;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.13.01.00.59;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.12.22.50.08;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.02.20.42.42;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.28.21.49.16;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.26.01.54.21;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.16.19.35.18;	author corinna;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.21.05.20.37;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.688.2.1
date	2014.07.16.08.00.59;	author corinna;	state Exp;
branches;
next	1.688.2.2;

1.688.2.2
date	2014.11.13.12.53.04;	author corinna;	state Exp;
branches;
next	;

1.669.2.1
date	2012.08.13.20.04.34;	author corinna;	state Exp;
branches;
next	1.669.2.2;

1.669.2.2
date	2012.10.16.15.18.39;	author corinna;	state Exp;
branches;
next	1.669.2.3;

1.669.2.3
date	2012.10.18.17.16.00;	author corinna;	state Exp;
branches;
next	1.669.2.4;

1.669.2.4
date	2012.11.12.21.58.03;	author corinna;	state Exp;
branches;
next	1.669.2.5;

1.669.2.5
date	2012.11.14.14.40.30;	author corinna;	state Exp;
branches;
next	1.669.2.6;

1.669.2.6
date	2012.12.10.11.45.50;	author corinna;	state Exp;
branches;
next	1.669.2.7;

1.669.2.7
date	2013.01.21.13.52.09;	author corinna;	state Exp;
branches;
next	1.669.2.8;

1.669.2.8
date	2013.02.25.12.53.22;	author corinna;	state Exp;
branches;
next	1.669.2.9;

1.669.2.9
date	2013.03.14.12.09.52;	author corinna;	state Exp;
branches;
next	1.669.2.10;

1.669.2.10
date	2013.03.27.10.23.05;	author corinna;	state Exp;
branches;
next	1.669.2.11;

1.669.2.11
date	2013.04.03.11.24.41;	author corinna;	state Exp;
branches;
next	1.669.2.12;

1.669.2.12
date	2013.04.12.08.30.50;	author corinna;	state Exp;
branches;
next	;

1.626.2.1
date	2011.03.11.10.21.55;	author corinna;	state Exp;
branches;
next	;

1.412.2.1
date	2008.01.24.17.29.42;	author corinna;	state Exp;
branches;
next	1.412.2.2;

1.412.2.2
date	2008.03.05.18.17.39;	author corinna;	state Exp;
branches;
next	;

1.411.2.1
date	2006.07.19.11.11.14;	author corinna;	state Exp;
branches;
next	;

1.248.2.1
date	2003.03.17.19.11.23;	author cgf;	state Exp;
branches;
next	;

1.238.2.1
date	2003.01.16.01.27.31;	author cgf;	state Exp;
branches;
next	1.238.2.2;

1.238.2.2
date	2003.01.16.02.01.28;	author cgf;	state Exp;
branches;
next	1.238.2.3;

1.238.2.3
date	2003.01.24.04.04.20;	author cgf;	state Exp;
branches;
next	1.238.2.4;

1.238.2.4
date	2003.01.25.18.59.43;	author cgf;	state Exp;
branches;
next	1.238.2.5;

1.238.2.5
date	2003.02.05.14.25.09;	author cgf;	state Exp;
branches;
next	1.238.2.6;

1.238.2.6
date	2003.02.07.15.20.03;	author cgf;	state Exp;
branches;
next	1.238.2.7;

1.238.2.7
date	2003.02.14.03.03.29;	author cgf;	state Exp;
branches;
next	1.238.2.8;

1.238.2.8
date	2003.02.14.05.21.51;	author cgf;	state Exp;
branches;
next	1.238.2.9;

1.238.2.9
date	2003.02.23.06.00.22;	author cgf;	state Exp;
branches;
next	1.238.2.10;

1.238.2.10
date	2003.02.23.07.03.23;	author cgf;	state Exp;
branches;
next	1.238.2.11;

1.238.2.11
date	2003.03.09.16.22.58;	author cgf;	state Exp;
branches;
next	1.238.2.12;

1.238.2.12
date	2003.03.09.18.15.57;	author cgf;	state Exp;
branches;
next	1.238.2.13;

1.238.2.13
date	2003.05.10.17.20.53;	author cgf;	state Exp;
branches;
next	1.238.2.14;

1.238.2.14
date	2003.05.26.19.39.06;	author cgf;	state Exp;
branches;
next	1.238.2.15;

1.238.2.15
date	2003.06.06.00.27.50;	author cgf;	state Exp;
branches;
next	1.238.2.16;

1.238.2.16
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.238.2.17;

1.238.2.17
date	2003.08.06.03.58.57;	author cgf;	state Exp;
branches;
next	1.238.2.18;

1.238.2.18
date	2003.08.27.20.19.55;	author cgf;	state Exp;
branches;
next	1.238.2.19;

1.238.2.19
date	2003.09.02.02.31.08;	author cgf;	state Exp;
branches;
next	1.238.2.20;

1.238.2.20
date	2003.09.10.16.23.39;	author cgf;	state Exp;
branches;
next	1.238.2.21;

1.238.2.21
date	2003.09.14.01.35.38;	author cgf;	state Exp;
branches;
next	;

1.234.16.1
date	2002.12.28.07.10.26;	author cgf;	state Exp;
branches;
next	1.234.16.2;

1.234.16.2
date	2002.12.28.16.56.16;	author cgf;	state Exp;
branches;
next	1.234.16.3;

1.234.16.3
date	2002.12.29.06.14.14;	author cgf;	state Exp;
branches;
next	1.234.16.4;

1.234.16.4
date	2003.01.02.06.16.17;	author cgf;	state Exp;
branches;
next	1.234.16.5;

1.234.16.5
date	2003.01.05.03.01.16;	author cgf;	state Exp;
branches;
next	1.234.16.6;

1.234.16.6
date	2003.01.09.08.22.51;	author cgf;	state Exp;
branches;
next	;

1.226.2.1
date	2002.07.06.06.11.52;	author cgf;	state Exp;
branches;
next	;

1.188.2.1
date	2001.12.03.20.30.03;	author cgf;	state Exp;
branches
	1.188.2.1.8.1;
next	;

1.188.2.1.8.1
date	2001.12.06.22.43.50;	author cgf;	state Exp;
branches;
next	1.188.2.1.8.2;

1.188.2.1.8.2
date	2001.12.07.05.04.22;	author cgf;	state Exp;
branches
	1.188.2.1.8.2.2.1;
next	;

1.188.2.1.8.2.2.1
date	2001.12.08.22.07.04;	author cgf;	state Exp;
branches;
next	;

1.163.2.1
date	2001.10.02.12.09.55;	author rbcollins;	state Exp;
branches;
next	1.163.2.2;

1.163.2.2
date	2002.01.04.03.56.09;	author rbcollins;	state Exp;
branches;
next	1.163.2.3;

1.163.2.3
date	2002.01.15.12.52.50;	author rbcollins;	state Exp;
branches;
next	1.163.2.4;

1.163.2.4
date	2002.01.17.04.27.30;	author rbcollins;	state Exp;
branches;
next	1.163.2.5;

1.163.2.5
date	2002.02.28.12.53.25;	author rbcollins;	state Exp;
branches;
next	1.163.2.6;

1.163.2.6
date	2002.06.13.14.34.08;	author rbcollins;	state Exp;
branches;
next	1.163.2.7;

1.163.2.7
date	2002.07.02.10.58.19;	author scottc;	state Exp;
branches;
next	1.163.2.8;

1.163.2.8
date	2002.07.04.20.09.47;	author scottc;	state Exp;
branches;
next	1.163.2.9;

1.163.2.9
date	2002.07.06.22.28.18;	author scottc;	state Exp;
branches;
next	1.163.2.10;

1.163.2.10
date	2002.07.26.19.03.36;	author scottc;	state Exp;
branches;
next	1.163.2.11;

1.163.2.11
date	2002.09.06.09.48.10;	author scottc;	state Exp;
branches;
next	1.163.2.12;

1.163.2.12
date	2002.09.22.10.01.28;	author scottc;	state Exp;
branches;
next	;

1.39.2.1
date	2000.07.29.17.35.07;	author cgf;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.698
log
@	* path.h (path_conv): Make path_flags private.  Rename known_suffix to
	suffix and make private.  Rename normalized_path to posix_path and
	make privtae.  Accommodate name changes throughout in path_conv
	methods.
	(path_conv::known_suffix): New method.  Use throughout instead of
	accessing suffix directly.
	(path_conv::get_win32): Constify.
	(path_conv::get_posix): New method to read posix_path.  Use throughout
	instead of accessing normalized_path directly.
	(path_conv::set_posix): Rename from set_normalized_path.  Accommodate
	name change throughout.
	* spawn.cc (find_exec): Return POSIX path, not Win32 path.
@
text
@/* path.cc: path support.

     Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
     2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015 Red Hat, Inc.

  This file is part of Cygwin.

  This software is a copyrighted work licensed under the terms of the
  Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
  details. */

  /* This module's job is to
     - convert between POSIX and Win32 style filenames,
     - support the `mount' functionality,
     - support symlinks for files and directories

     Pathnames are handled as follows:

     - A \ or : in a path denotes a pure windows spec.
     - Paths beginning with // (or \\) are not translated (i.e. looked
       up in the mount table) and are assumed to be UNC path names.

     The goal in the above set of rules is to allow both POSIX and Win32
     flavors of pathnames without either interfering.  The rules are
     intended to be as close to a superset of both as possible.

     Note that you can have more than one path to a file.  The mount
     table is always prefered when translating Win32 paths to POSIX
     paths.  Win32 paths in mount table entries may be UNC paths or
     standard Win32 paths starting with <drive-letter>:

     Text vs Binary issues are not considered here in path style
     decisions, although the appropriate flags are retrieved and
     stored in various structures.

     Removing mounted filesystem support would simplify things greatly,
     but having it gives us a mechanism of treating disk that lives on a
     UNIX machine as having UNIX semantics [it allows one to edit a text
     file on that disk and not have cr's magically appear and perhaps
     break apps running on UNIX boxes].  It also useful to be able to
     layout a hierarchy without changing the underlying directories.

     The semantics of mounting file systems is not intended to precisely
     follow normal UNIX systems.

     Each DOS drive is defined to have a current directory.  Supporting
     this would complicate things so for now things are defined so that
     c: means c:\.
  */

#include "winsup.h"
#include "miscfuncs.h"
#include <ctype.h>
#include <winioctl.h>
#include <shlobj.h>
#include <sys/param.h>
#include <sys/cygwin.h>
#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "shared_info.h"
#include "cygtls.h"
#include "tls_pbuf.h"
#include "environ.h"
#include <assert.h>
#include <ntdll.h>
#include <wchar.h>
#include <wctype.h>

suffix_info stat_suffixes[] =
{
  suffix_info ("", 1),
  suffix_info (".exe", 1),
  suffix_info (NULL)
};

struct symlink_info
{
  char contents[SYMLINK_MAX + 1];
  char *ext_here;
  int extn;
  unsigned pflags;
  DWORD fileattr;
  int issymlink;
  bool ext_tacked_on;
  int error;
  bool isdevice;
  _major_t major;
  _minor_t minor;
  _mode_t mode;
  int check (char *path, const suffix_info *suffixes, fs_info &fs,
	     path_conv_handle &conv_hdl);
  int set (char *path);
  bool parse_device (const char *);
  int check_sysfile (HANDLE h);
  int check_shortcut (HANDLE h);
  int check_reparse_point (HANDLE h, bool remote);
  int check_nfs_symlink (HANDLE h);
  int posixify (char *srcbuf);
  bool set_error (int);
};

muto NO_COPY cwdstuff::cwd_lock;

static const GUID GUID_shortcut
			= { 0x00021401L, 0, 0, {0xc0, 0, 0, 0, 0, 0, 0, 0x46}};

enum
{
  WSH_FLAG_IDLIST = 0x01,	/* Contains an ITEMIDLIST. */
  WSH_FLAG_FILE = 0x02,		/* Contains a file locator element. */
  WSH_FLAG_DESC = 0x04,		/* Contains a description. */
  WSH_FLAG_RELPATH = 0x08,	/* Contains a relative path. */
  WSH_FLAG_WD = 0x10,		/* Contains a working dir. */
  WSH_FLAG_CMDLINE = 0x20,	/* Contains command line args. */
  WSH_FLAG_ICON = 0x40		/* Contains a custom icon. */
};

struct win_shortcut_hdr
{
  DWORD size;		/* Header size in bytes.  Must contain 0x4c. */
  GUID magic;		/* GUID of shortcut files. */
  DWORD flags;	/* Content flags.  See above. */

  /* The next fields from attr to icon_no are always set to 0 in Cygwin
     and U/Win shortcuts. */
  DWORD attr;	/* Target file attributes. */
  FILETIME ctime;	/* These filetime items are never touched by the */
  FILETIME mtime;	/* system, apparently. Values don't matter. */
  FILETIME atime;
  DWORD filesize;	/* Target filesize. */
  DWORD icon_no;	/* Icon number. */

  DWORD run;		/* Values defined in winuser.h. Use SW_NORMAL. */
  DWORD hotkey;	/* Hotkey value. Set to 0.  */
  DWORD dummy[2];	/* Future extension probably. Always 0. */
};

/* Return non-zero if PATH1 is a prefix of PATH2.
   Both are assumed to be of the same path style and / vs \ usage.
   Neither may be "".
   LEN1 = strlen (PATH1).  It's passed because often it's already known.

   Examples:
   /foo/ is a prefix of /foo  <-- may seem odd, but desired
   /foo is a prefix of /foo/
   / is a prefix of /foo/bar
   / is not a prefix of foo/bar
   foo/ is a prefix foo/bar
   /foo is not a prefix of /foobar
*/

int
path_prefix_p (const char *path1, const char *path2, int len1,
	       bool caseinsensitive)
{
  /* Handle case where PATH1 has trailing '/' and when it doesn't.  */
  if (len1 > 0 && isdirsep (path1[len1 - 1]))
    len1--;

  if (len1 == 0)
    return isdirsep (path2[0]) && !isdirsep (path2[1]);

  if (isdirsep (path2[len1]) || path2[len1] == 0 || path1[len1 - 1] == ':')
    return caseinsensitive ? strncasematch (path1, path2, len1)
			   : !strncmp (path1, path2, len1);

  return 0;
}

/* Return non-zero if paths match in first len chars.
   Check is dependent of the case sensitivity setting. */
int
pathnmatch (const char *path1, const char *path2, int len, bool caseinsensitive)
{
  return caseinsensitive
	 ? strncasematch (path1, path2, len) : !strncmp (path1, path2, len);
}

/* Return non-zero if paths match. Check is dependent of the case
   sensitivity setting. */
int
pathmatch (const char *path1, const char *path2, bool caseinsensitive)
{
  return caseinsensitive
	 ? strcasematch (path1, path2) : !strcmp (path1, path2);
}

/* TODO: This function is used in mkdir and rmdir to generate correct
   error messages in case of paths ending in /. or /.. components.
   Right now, normalize_posix_path will just normalize
   those components away, which changes the semantics.  */
bool
has_dot_last_component (const char *dir, bool test_dot_dot)
{
  /* SUSv3: . and .. are not allowed as last components in various system
     calls.  Don't test for backslash path separator since that's a Win32
     path following Win32 rules. */
  const char *last_comp = strchr (dir, '\0');

  if (last_comp == dir)
    return false;	/* Empty string.  Probably shouldn't happen here? */

  /* Detect run of trailing slashes */
  while (last_comp > dir && *--last_comp == '/')
    continue;

  /* Detect just a run of slashes or a path that does not end with a slash. */
  if (*last_comp != '.')
    return false;

  /* We know we have a trailing dot here.  Check that it really is a standalone "."
     path component by checking that it is at the beginning of the string or is
     preceded by a "/" */
  if (last_comp == dir || *--last_comp == '/')
    return true;

  /* If we're not checking for '..' we're done.  Ditto if we're now pointing to
     a non-dot. */
  if (!test_dot_dot || *last_comp != '.')
    return false;		/* either not testing for .. or this was not '..' */

  /* Repeat previous test for standalone or path component. */
  return last_comp == dir || last_comp[-1] == '/';
}

/* Normalize a POSIX path.
   All duplicate /'s, except for 2 leading /'s, are deleted.
   The result is 0 for success, or an errno error value.  */

int
normalize_posix_path (const char *src, char *dst, char *&tail)
{
  const char *in_src = src;
  char *dst_start = dst;
  bool check_parent = false;
  syscall_printf ("src %s", src);

  if ((isdrive (src) && isdirsep (src[2])) || *src == '\\')
    goto win32_path;

  tail = dst;
  if (!isslash (src[0]))
    {
      if (!cygheap->cwd.get (dst))
	return get_errno ();
      tail = strchr (tail, '\0');
      if (isslash (dst[0]) && isslash (dst[1]))
	++dst_start;
      if (*src == '.')
	{
	  if (tail == dst_start + 1 && *dst_start == '/')
	     tail--;
	  goto sawdot;
	}
      if (tail > dst && !isslash (tail[-1]))
	*tail++ = '/';
    }
  /* Two leading /'s?  If so, preserve them.  */
  else if (isslash (src[1]) && !isslash (src[2]))
    {
      *tail++ = *src++;
      ++dst_start;
    }

  while (*src)
    {
      if (*src == '\\')
	goto win32_path;
      /* Strip runs of /'s.  */
      if (!isslash (*src))
	*tail++ = *src++;
      else
	{
	  check_parent = true;
	  while (*++src)
	    {
	      if (isslash (*src))
		continue;

	      if (*src != '.')
		break;

	    sawdot:
	      if (src[1] != '.')
		{
		  if (!src[1])
		    {
		      *tail++ = '/';
		      goto done;
		    }
		  if (!isslash (src[1]))
		    break;
		}
	      else if (src[2] && !isslash (src[2]))
		break;
	      else
		{
		  /* According to POSIX semantics all elements of path must
		     exist.  To follow it, we must validate our path before
		     removing the trailing component.  Check_parent is needed
		     for performance optimization, in order not to verify paths
		     which are already verified. For example this prevents
		     double check in case of foo/bar/../.. */
		  if (check_parent)
		    {
		      if (tail > dst_start) /* Don't check for / or // dir. */
		      	{
			  *tail = 0;
			  debug_printf ("checking %s before '..'", dst);
			  /* In conjunction with native and NFS symlinks,
			     this call can result in a recursion which eats
			     up our tmp_pathbuf buffers.  This in turn results
			     in a api_fatal call.  To avoid that, we're
			     checking our remaining buffers and return an
			     error code instead.  Note that this only happens
			     if the path contains 15 or more relative native/NFS
			     symlinks with a ".." in the target path. */
			  tmp_pathbuf tp;
			  if (!tp.check_usage (4, 3))
			    return ELOOP;
			  path_conv head (dst, PC_SYM_FOLLOW | PC_POSIX);
			  if (!head.isdir())
			    return ENOENT;
			  /* At this point, dst is a normalized path.  If the
			     normalized path created by path_conv does not
			     match the normalized path we're just testing, then
			     the path in dst contains native symlinks.  If we
			     just plunge along, removing the previous path
			     component, we may end up removing a symlink from
			     the path and the resulting path will be invalid.
			     So we replace dst with what we found in head
			     instead.  All the work replacing symlinks has been
			     done in that path anyway, so why repeat it? */
			  tail = stpcpy (dst, head.get_posix ());
			}
		      check_parent = false;
		    }
		  while (tail > dst_start && !isslash (*--tail))
		    continue;
		  src++;
		}
	    }

	  *tail++ = '/';
	}
	if ((tail - dst) >= NT_MAX_PATH)
	  {
	    debug_printf ("ENAMETOOLONG = normalize_posix_path (%s)", src);
	    return ENAMETOOLONG;
	  }
    }

done:
  *tail = '\0';

  debug_printf ("%s = normalize_posix_path (%s)", dst, in_src);
  return 0;

win32_path:
  int err = normalize_win32_path (in_src, dst, tail);
  if (!err)
    for (char *p = dst; (p = strchr (p, '\\')); p++)
      *p = '/';
  return err ?: -1;
}

inline void
path_conv::add_ext_from_sym (symlink_info &sym)
{
  if (sym.ext_here && *sym.ext_here)
    {
      suffix = path + sym.extn;
      if (sym.ext_tacked_on)
	strcpy ((char *) suffix, sym.ext_here);
    }
}

static void __reg2 mkrelpath (char *dst, bool caseinsensitive);

static void __reg2
mkrelpath (char *path, bool caseinsensitive)
{
  tmp_pathbuf tp;
  char *cwd_win32 = tp.c_get ();
  if (!cygheap->cwd.get (cwd_win32, 0))
    return;

  unsigned cwdlen = strlen (cwd_win32);
  if (!path_prefix_p (cwd_win32, path, cwdlen, caseinsensitive))
    return;

  size_t n = strlen (path);
  if (n < cwdlen)
    return;

  char *tail = path;
  if (n == cwdlen)
    tail += cwdlen;
  else
    tail += isdirsep (cwd_win32[cwdlen - 1]) ? cwdlen : cwdlen + 1;

  memmove (path, tail, strlen (tail) + 1);
  if (!*path)
    strcpy (path, ".");
}

void
path_conv::set_posix (const char *path_copy)
{
  if (path_copy)
    {
      size_t n = strlen (path_copy) + 1;
      char *p = (char *) crealloc_abort ((void *) posix_path, n);
      posix_path = (const char *) memcpy (p, path_copy, n);
    }
}

static inline void
str2uni_cat (UNICODE_STRING &tgt, const char *srcstr)
{
  int len = sys_mbstowcs (tgt.Buffer + tgt.Length / sizeof (WCHAR),
			  (tgt.MaximumLength - tgt.Length) / sizeof (WCHAR),
			  srcstr);
  if (len)
    tgt.Length += (len - 1) * sizeof (WCHAR);
}

PUNICODE_STRING
get_nt_native_path (const char *path, UNICODE_STRING& upath, bool dos)
{
  upath.Length = 0;
  if (path[0] == '/')		/* special path w/o NT path representation. */
    str2uni_cat (upath, path);
  else if (path[0] != '\\')	/* X:\...  or relative path. */
    {
      if (path[1] == ':')	/* X:\... */
	{
	  RtlAppendUnicodeStringToString (&upath, &ro_u_natp);
	  str2uni_cat (upath, path);
	  /* The drive letter must be upper case. */
	  upath.Buffer[4] = towupper (upath.Buffer[4]);
	}
      else
	str2uni_cat (upath, path);
      transform_chars (&upath, 7);
    }
  else if (path[1] != '\\')	/* \Device\... */
    str2uni_cat (upath, path);
  else if ((path[2] != '.' && path[2] != '?')
	   || path[3] != '\\')	/* \\server\share\... */
    {
      RtlAppendUnicodeStringToString (&upath, &ro_u_uncp);
      str2uni_cat (upath, path + 2);
      transform_chars (&upath, 8);
    }
  else				/* \\.\device or \\?\foo */
    {
      RtlAppendUnicodeStringToString (&upath, &ro_u_natp);
      str2uni_cat (upath, path + 4);
    }
  if (dos)
    {
      /* Unfortunately we can't just use transform_chars with the tfx_rev_chars
	 table since only leading and trailing spaces and dots are affected.
	 So we step to every backslash and fix surrounding dots and spaces.
	 That makes these broken filesystems a bit slower, but, hey. */
      PWCHAR cp = upath.Buffer + 7;
      PWCHAR cend = upath.Buffer + upath.Length / sizeof (WCHAR);
      while (++cp < cend)
	if (*cp == L'\\')
	  {
	    PWCHAR ccp = cp - 1;
	    while (*ccp == L'.' || *ccp == L' ')
	      *ccp-- |= 0xf000;
	    while (cp[1] == L' ')
	      *++cp |= 0xf000;
	  }
      while (*--cp == L'.' || *cp == L' ')
	*cp |= 0xf000;
    }
  return &upath;
}

PUNICODE_STRING
path_conv::get_nt_native_path ()
{
  PUNICODE_STRING res;
  if (wide_path)
    res = &uni_path;
  else if (!path)
    res = NULL;
  else
    {
      uni_path.Length = 0;
      uni_path.MaximumLength = (strlen (path) + 10) * sizeof (WCHAR);
      wide_path = (PWCHAR) cmalloc_abort (HEAP_STR, uni_path.MaximumLength);
      uni_path.Buffer = wide_path;
      ::get_nt_native_path (path, uni_path, has_dos_filenames_only ());
      res = &uni_path;
    }
  return res;
}

PWCHAR
path_conv::get_wide_win32_path (PWCHAR wc)
{
  get_nt_native_path ();
  if (!wide_path)
    return NULL;
  wcpcpy (wc, wide_path);
  if (wc[1] == L'?')
    wc[1] = L'\\';
  return wc;
}

static void
warn_msdos (const char *src)
{
  if (user_shared->warned_msdos || !cygwin_finished_initializing)
    return;
  tmp_pathbuf tp;
  char *posix_path = tp.c_get ();
  small_printf ("Cygwin WARNING:\n");
  if (cygwin_conv_path (CCP_WIN_A_TO_POSIX | CCP_RELATIVE, src,
			posix_path, NT_MAX_PATH))
    small_printf (
"  MS-DOS style path detected: %ls\n  POSIX equivalent preferred.\n",
		  src);
  else
    small_printf (
"  MS-DOS style path detected: %ls\n"
"  Preferred POSIX equivalent is: %ls\n",
		  src, posix_path);
  small_printf (
"  CYGWIN environment variable option \"nodosfilewarning\" turns off this\n"
"  warning.  Consult the user's guide for more details about POSIX paths:\n"
"  http://cygwin.com/cygwin-ug-net/using.html#using-pathnames\n");
  user_shared->warned_msdos = true;
}

static DWORD
getfileattr (const char *path, bool caseinsensitive) /* path has to be always absolute. */
{
  tmp_pathbuf tp;
  UNICODE_STRING upath;
  OBJECT_ATTRIBUTES attr;
  FILE_BASIC_INFORMATION fbi;
  NTSTATUS status;
  IO_STATUS_BLOCK io;

  tp.u_get (&upath);
  InitializeObjectAttributes (&attr, &upath,
			      caseinsensitive ? OBJ_CASE_INSENSITIVE : 0,
			      NULL, NULL);
  get_nt_native_path (path, upath, false);

  status = NtQueryAttributesFile (&attr, &fbi);
  if (NT_SUCCESS (status))
    return fbi.FileAttributes;

  if (status != STATUS_OBJECT_NAME_NOT_FOUND
      && status != STATUS_NO_SUCH_FILE) /* File not found on 9x share */
    {
      /* File exists but access denied.  Try to get attribute through
	 directory query. */
      UNICODE_STRING dirname, basename;
      HANDLE dir;
      FILE_BOTH_DIR_INFORMATION fdi;

      RtlSplitUnicodePath (&upath, &dirname, &basename);
      InitializeObjectAttributes (&attr, &dirname,
				  caseinsensitive ? OBJ_CASE_INSENSITIVE : 0,
				  NULL, NULL);
      status = NtOpenFile (&dir, SYNCHRONIZE | FILE_LIST_DIRECTORY,
			   &attr, &io, FILE_SHARE_VALID_FLAGS,
			   FILE_SYNCHRONOUS_IO_NONALERT
			   | FILE_OPEN_FOR_BACKUP_INTENT
			   | FILE_DIRECTORY_FILE);
      if (NT_SUCCESS (status))
	{
	  status = NtQueryDirectoryFile (dir, NULL, NULL, 0, &io,
					 &fdi, sizeof fdi,
					 FileBothDirectoryInformation,
					 TRUE, &basename, TRUE);
	  NtClose (dir);
	  if (NT_SUCCESS (status) || status == STATUS_BUFFER_OVERFLOW)
	    return fdi.FileAttributes;
	}
    }
  SetLastError (RtlNtStatusToDosError (status));
  return INVALID_FILE_ATTRIBUTES;
}

/* Convert an arbitrary path SRC to a pure Win32 path, suitable for
   passing to Win32 API routines.

   If an error occurs, `error' is set to the errno value.
   Otherwise it is set to 0.

   follow_mode values:
	SYMLINK_FOLLOW	    - convert to PATH symlink points to
	SYMLINK_NOFOLLOW    - convert to PATH of symlink itself
	SYMLINK_IGNORE	    - do not check PATH for symlinks
	SYMLINK_CONTENTS    - just return symlink contents
*/

/* TODO: This implementation is only preliminary.  For internal
   purposes it's necessary to have a path_conv::check function which
   takes a UNICODE_STRING src path, otherwise we waste a lot of time
   for converting back and forth.  The below implementation does
   realy nothing but converting to char *, until path_conv handles
   wide-char paths directly. */
void
path_conv::check (const UNICODE_STRING *src, unsigned opt,
		  const suffix_info *suffixes)
{
  tmp_pathbuf tp;
  char *path = tp.c_get ();

  user_shared->warned_msdos = true;
  sys_wcstombs (path, NT_MAX_PATH, src->Buffer, src->Length / sizeof (WCHAR));
  path_conv::check (path, opt, suffixes);
}

void
path_conv::check (const char *src, unsigned opt,
		  const suffix_info *suffixes)
{
  /* The tmp_buf array is used when expanding symlinks.  It is NT_MAX_PATH * 2
     in length so that we can hold the expanded symlink plus a trailer.  */
  tmp_pathbuf tp;
  char *path_copy = tp.c_get ();
  char *pathbuf = tp.c_get ();
  char *tmp_buf = tp.t_get ();
  char *THIS_path = tp.c_get ();
  symlink_info sym;
  bool need_directory = 0;
  bool saw_symlinks = 0;
  bool add_ext = false;
  bool is_relpath;
  char *tail, *path_end;

#if 0
  static path_conv last_path_conv;
  static char last_src[CYG_MAX_PATH];

  if (*last_src && strcmp (last_src, src) == 0)
    {
      *this = last_path_conv;
      return;
    }
#endif

  __try
    {
      int loop = 0;
      path_flags = 0;
      suffix = NULL;
      fileattr = INVALID_FILE_ATTRIBUTES;
      caseinsensitive = OBJ_CASE_INSENSITIVE;
      if (wide_path)
	cfree (wide_path);
      wide_path = NULL;
      if (path)
	{
	  cfree (modifiable_path ());
	  path = NULL;
	}
      close_conv_handle ();
      memset (&dev, 0, sizeof (dev));
      fs.clear ();
      if (posix_path)
	{
	  cfree ((void *) posix_path);
	  posix_path = NULL;
	}
      int component = 0;		// Number of translated components

      if (!(opt & PC_NULLEMPTY))
	error = 0;
      else if (!*src)
	{
	  error = ENOENT;
	  return;
	}

      bool is_msdos = false;
      /* This loop handles symlink expansion.  */
      for (;;)
	{
	  MALLOC_CHECK;
	  assert (src);

	  is_relpath = !isabspath (src);
	  error = normalize_posix_path (src, path_copy, tail);
	  if (error > 0)
	    return;
	  if (error < 0)
	    {
	      if (component == 0)
		is_msdos = true;
	      error = 0;
	    }

	  /* Detect if the user was looking for a directory.  We have to strip
	     the trailing slash initially while trying to add extensions but
	     take it into account during processing */
	  if (tail > path_copy + 2 && isslash (tail[-1]))
	    {
	      need_directory = 1;
	      *--tail = '\0';
	    }
	  path_end = tail;

	  /* Scan path_copy from right to left looking either for a symlink
	     or an actual existing file.  If an existing file is found, just
	     return.  If a symlink is found, exit the for loop.
	     Also: be careful to preserve the errno returned from
	     symlink.check as the caller may need it. */
	  /* FIXME: Do we have to worry about multiple \'s here? */
	  component = 0;		// Number of translated components
	  sym.contents[0] = '\0';

	  int symlen = 0;

	  for (unsigned pflags_or = opt & (PC_NO_ACCESS_CHECK | PC_KEEP_HANDLE);
	       ;
	       pflags_or = 0)
	    {
	      const suffix_info *suff;
	      char *full_path;

	      /* Don't allow symlink.check to set anything in the path_conv
		 class if we're working on an inner component of the path */
	      if (component)
		{
		  suff = NULL;
		  full_path = pathbuf;
		}
	      else
		{
		  suff = suffixes;
		  full_path = THIS_path;
		}

    retry_fs_via_processfd:

	      /* Convert to native path spec sans symbolic link info. */
	      error = mount_table->conv_to_win32_path (path_copy, full_path,
						       dev, &sym.pflags);

	      if (error)
		return;

	      sym.pflags |= pflags_or;

	      if (!dev.exists ())
		{
		  error = ENXIO;
		  return;
		}

	      if (iscygdrive_dev (dev))
		{
		  if (!component)
		    fileattr = FILE_ATTRIBUTE_DIRECTORY
			       | FILE_ATTRIBUTE_READONLY;
		  else
		    {
		      fileattr = getfileattr (THIS_path,
					      sym.pflags & MOUNT_NOPOSIX);
		      dev = FH_FS;
		    }
		  goto out;
		}
	      else if (isdev_dev (dev))
		{
		  /* Make sure that the path handling goes on as with FH_FS. */
		}
	      else if (isvirtual_dev (dev))
		{
		  /* FIXME: Calling build_fhandler here is not the right way to
			    handle this. */
		  fhandler_virtual *fh = (fhandler_virtual *)
					 build_fh_dev (dev, path_copy);
		  virtual_ftype_t file_type;
		  if (!fh)
		    file_type = virt_none;
		  else
		    {
		      file_type = fh->exists ();
		      if (file_type == virt_symlink)
			{
			  fh->fill_filebuf ();
			  symlen = sym.set (fh->get_filebuf ());
			}
		      else if (file_type == virt_fsdir && dev == FH_PROCESS)
			{
			  /* FIXME: This is YA bad hack to workaround that
			     we're checking for isvirtual_dev at this point.
			     This should only happen if the file is actually
			     a virtual file, and NOT already if the preceeding
			     path components constitute a virtual file.

			     Anyway, what we do here is this:  If the descriptor
			     symlink points to a dir, and if there are trailing
			     path components, it's actually pointing somewhere
			     else.  The format_process_fd function returns the
			     full path, resolved symlink plus trailing path
			     components, in its filebuf.  This is a POSIX path
			     we know nothing about, so we have to convert it to
			     native again, calling conv_to_win32_path.  Since
			     basically nothing happened yet, just copy it over
			     into full_path and jump back to the
			     conv_to_win32_path call.  What a mess. */
			  stpcpy (path_copy, fh->get_filebuf ());
			  delete fh;
			  goto retry_fs_via_processfd;
			}
		      delete fh;
		    }
		  switch (file_type)
		    {
		      case virt_directory:
		      case virt_rootdir:
			if (component == 0)
			  fileattr = FILE_ATTRIBUTE_DIRECTORY;
			break;
		      case virt_file:
			if (component == 0)
			  fileattr = 0;
			break;
		      case virt_symlink:
			goto is_virtual_symlink;
		      case virt_pipe:
			if (component == 0)
			  {
			    fileattr = 0;
			    dev.parse (FH_PIPE);
			  }
			break;
		      case virt_socket:
			if (component == 0)
			  {
			    fileattr = 0;
			    dev.parse (FH_TCP);
			  }
			break;
		      case virt_fsdir:
		      case virt_fsfile:
			/* Access to real file or directory via block device
			   entry in /proc/sys.  Convert to real file and go with
			   the flow. */
			dev.parse (FH_FS);
			goto is_fs_via_procsys;
		      case virt_blk:
			/* Block special device.  If the trailing slash has been
			   requested, the target is the root directory of the
			   filesystem on this block device.  So we convert this
			   to a real file and attach the backslash. */
			if (component == 0 && need_directory)
			  {
			    dev.parse (FH_FS);
			    strcat (full_path, "\\");
			    fileattr = FILE_ATTRIBUTE_DIRECTORY
				       | FILE_ATTRIBUTE_DEVICE;
			    goto out;
			  }
			/*FALLTHRU*/
		      case virt_chr:
			if (component == 0)
			  fileattr = FILE_ATTRIBUTE_DEVICE;
			break;
		      default:
			if (component == 0)
			  fileattr = INVALID_FILE_ATTRIBUTES;
			goto virtual_component_retry;
		    }
		  if (component == 0 || dev != FH_NETDRIVE)
		    path_flags |= PATH_RO;
		  goto out;
		}
	      /* devn should not be a device.  If it is, then stop parsing. */
	      else if (dev != FH_FS)
		{
		  fileattr = 0;
		  path_flags = sym.pflags;
		  if (component)
		    {
		      error = ENOTDIR;
		      return;
		    }
		  goto out;		/* Found a device.  Stop parsing. */
		}

	      /* If path is only a drivename, Windows interprets it as the
		 current working directory on this drive instead of the root
		 dir which is what we want. So we need the trailing backslash
		 in this case. */
	      if (full_path[0] && full_path[1] == ':' && full_path[2] == '\0')
		{
		  full_path[2] = '\\';
		  full_path[3] = '\0';
		}

	      /* If the incoming path was given in DOS notation, always treat
		 it as caseinsensitive,noacl path.  This must be set before
		 calling sym.check, otherwise the path is potentially treated
		 casesensitive. */
	      if (is_msdos)
		sym.pflags |= PATH_NOPOSIX | PATH_NOACL;

    is_fs_via_procsys:

	      symlen = sym.check (full_path, suff, fs, conv_handle);

    is_virtual_symlink:

	      if (sym.isdevice)
		{
		  if (component)
		    {
		      error = ENOTDIR;
		      return;
		    }
		  dev.parse (sym.major, sym.minor);
		  dev.setfs (1);
		  dev.mode = sym.mode;
		  fileattr = sym.fileattr;
		  goto out;
		}

	      if (sym.pflags & PATH_SOCKET)
		{
		  if (component)
		    {
		      error = ENOTDIR;
		      return;
		    }
		  fileattr = sym.fileattr;
		  dev.parse (FH_UNIX);
		  dev.setfs (1);
		  goto out;
		}

	      if (!component)
		{
		  /* Make sure that /dev always exists. */
		  fileattr = isdev_dev (dev) ? FILE_ATTRIBUTE_DIRECTORY
					     : sym.fileattr;
		  path_flags = sym.pflags;
		}
	      else if (isdev_dev (dev))
		{
		  /* If we're looking for a non-existing file below /dev,
		     make sure that the device type is converted to FH_FS, so
		     that subsequent code handles the file correctly.  Unless
		     /dev itself doesn't exist on disk.  In that case /dev
		     is handled as virtual filesystem, and virtual filesystems
		     are read-only.  The PC_KEEP_HANDLE check allows to check
		     for a call from an informational system call.  In that
		     case we just stick to ENOENT, and the device type doesn't
		     matter anyway. */
		  if (sym.error == ENOENT && !(opt & PC_KEEP_HANDLE))
		    sym.error = EROFS;
		  else
		    dev = FH_FS;
		}

	      /* If symlink.check found an existing non-symlink file, then
		 it sets the appropriate flag.  It also sets any suffix found
		 into `ext_here'. */
	      if (!sym.issymlink && sym.fileattr != INVALID_FILE_ATTRIBUTES)
		{
		  error = sym.error;
		  if (component == 0)
		    add_ext = true;
		  else if (!(sym.fileattr & FILE_ATTRIBUTE_DIRECTORY))
		    {
		      error = ENOTDIR;
		      goto out;
		    }
		  goto out;	// file found
		}
	      /* Found a symlink if symlen > 0.  If component == 0, then the
		 src path itself was a symlink.  If !follow_mode then
		 we're done.  Otherwise we have to insert the path found
		 into the full path that we are building and perform all of
		 these operations again on the newly derived path. */
	      else if (symlen > 0)
		{
		  saw_symlinks = 1;
		  if (component == 0 && !need_directory
		      && (!(opt & PC_SYM_FOLLOW)
			  || (is_rep_symlink ()
			      && (opt & PC_SYM_NOFOLLOW_REP))))
		    {
		      /* last component of path is a symlink. */
		      set_symlink (symlen);
		      if (opt & PC_SYM_CONTENTS)
			{
			  strcpy (THIS_path, sym.contents);
			  goto out;
			}
		      add_ext = true;
		      goto out;
		    }
		  /* Following a symlink we can't trust the collected
		     filesystem information any longer. */
		  fs.clear ();
		  /* Close handle, if we have any.  Otherwise we're collecting
		     handles while following symlinks. */
		  conv_handle.close ();
		  break;
		}
	      else if (sym.error && sym.error != ENOENT)
		{
		  error = sym.error;
		  goto out;
		}
	      /* No existing file found. */

    virtual_component_retry:
	      /* Find the new "tail" of the path, e.g. in '/for/bar/baz',
		 /baz is the tail. */
	      if (tail != path_end)
		*tail = '/';
	      while (--tail > path_copy + 1 && *tail != '/') {}
	      /* Exit loop if there is no tail or we are at the
		 beginning of a UNC path */
	      if (tail <= path_copy + 1)
		goto out;	// all done

	      /* Haven't found an existing pathname component yet.
		 Pinch off the tail and try again. */
	      *tail = '\0';
	      component++;
	    }

	  /* Arrive here if above loop detected a symlink. */
	  if (++loop > SYMLOOP_MAX)
	    {
	      error = ELOOP;   // Eep.
	      return;
	    }

	  MALLOC_CHECK;


	  /* Place the link content, possibly with head and/or tail,
	     in tmp_buf */

	  char *headptr;
	  if (isabspath (sym.contents))
	    headptr = tmp_buf;	/* absolute path */
	  else
	    {
	      /* Copy the first part of the path (with ending /) and point to
		 the end. */
	      char *prevtail = tail;
	      while (--prevtail > path_copy  && *prevtail != '/') {}
	      int headlen = prevtail - path_copy + 1;;
	      memcpy (tmp_buf, path_copy, headlen);
	      headptr = &tmp_buf[headlen];
	    }

	  /* Make sure there is enough space */
	  if (headptr + symlen >= tmp_buf + (2 * NT_MAX_PATH))
	    {
	    too_long:
	      error = ENAMETOOLONG;
	      set_path ("::ENAMETOOLONG::");
	      return;
	    }

	 /* Copy the symlink contents to the end of tmp_buf.
	    Convert slashes. */
	  for (char *p = sym.contents; *p; p++)
	    *headptr++ = *p == '\\' ? '/' : *p;
	  *headptr = '\0';

	  /* Copy any tail component (with the 0) */
	  if (tail++ < path_end)
	    {
	      /* Add a slash if needed. There is space. */
	      if (*(headptr - 1) != '/')
		*headptr++ = '/';
	      int taillen = path_end - tail + 1;
	      if (headptr + taillen > tmp_buf + (2 * NT_MAX_PATH))
		goto too_long;
	      memcpy (headptr, tail, taillen);
	    }

	  /* Evaluate everything all over again. */
	  src = tmp_buf;
	}

      if (!(opt & PC_SYM_CONTENTS))
	add_ext = true;

    out:
      set_path (THIS_path);
      if (add_ext)
	add_ext_from_sym (sym);
      if (dev == FH_NETDRIVE && component)
	{
	  /* This case indicates a non-existant resp. a non-retrievable
	     share.  This happens for instance if the share is a printer.
	     In this case the path must not be treated like a FH_NETDRIVE,
	     but like a FH_FS instead, so the usual open call for files
	     is used on it. */
	  dev.parse (FH_FS);
	}
      else if (isproc_dev (dev) && fileattr == INVALID_FILE_ATTRIBUTES)
	{
	  /* FIXME: Usually we don't set error to ENOENT if a file doesn't
	     exist.  This is typically indicated by the fileattr content.
	     So, why here?  The downside is that cygwin_conv_path just gets
	     an error for these paths so it reports the error back to the
	     application.  Unlike in all other cases of non-existant files,
	     for which check doesn't set error, so cygwin_conv_path just
	     returns the path, as intended. */
	  error = ENOENT;
	  return;
	}
      else if (!need_directory || error)
	/* nothing to do */;
      else if (fileattr == INVALID_FILE_ATTRIBUTES)
	/* Reattach trailing dirsep in native path. */
	strcat (modifiable_path (), "\\");
      else if (fileattr & FILE_ATTRIBUTE_DIRECTORY)
	path_flags &= ~PATH_SYMLINK;
      else
	{
	  debug_printf ("%s is a non-directory", path);
	  error = ENOTDIR;
	  return;
	}

      if (dev.isfs ())
	{
	  if (strncmp (path, "\\\\.\\", 4))
	    {
	      if (!tail || tail == path)
		/* nothing */;
	      else if (tail[-1] != '\\')
		*tail = '\0';
	      else
		{
		  error = ENOENT;
		  return;
		}
	    }

	  /* If FS hasn't been checked already in symlink_info::check,
	     do so now. */
	  if (fs.inited ()|| fs.update (get_nt_native_path (), NULL))
	    {
	      /* Incoming DOS paths are treated like DOS paths in native
		 Windows applications.  No ACLs, just default settings. */
	      if (is_msdos)
		fs.has_acls (false);
	      debug_printf ("this->path(%s), has_acls(%d)",
			    path, fs.has_acls ());
	      /* CV: We could use this->has_acls() but I want to make sure that
		 we don't forget that the PATH_NOACL flag must be taken into
		 account here. */
	      if (!(path_flags & PATH_NOACL) && fs.has_acls ())
		set_exec (0);  /* We really don't know if this is executable or
				  not here but set it to not executable since
				  it will be figured out later by anything
				  which cares about this. */
	    }
	  /* If the FS has been found to have unrelibale inodes, note
	     that in path_flags. */
	  if (!fs.hasgood_inode ())
	    path_flags |= PATH_IHASH;
	  /* If the OS is caseinsensitive or the FS is caseinsensitive,
	     don't handle path casesensitive. */
	  if (cygwin_shared->obcaseinsensitive || fs.caseinsensitive ())
	    path_flags |= PATH_NOPOSIX;
	  caseinsensitive = (path_flags & PATH_NOPOSIX)
			    ? OBJ_CASE_INSENSITIVE : 0;
	  if (exec_state () != dont_know_if_executable)
	    /* ok */;
	  else if (isdir ())
	    set_exec (1);
	  else if (issymlink () || issocket ())
	    set_exec (0);
	}

      if (opt & PC_NOFULL)
	{
	  if (is_relpath)
	    {
	      mkrelpath (this->modifiable_path (), !!caseinsensitive);
	      /* Invalidate wide_path so that wide relpath can be created
		 in later calls to get_nt_native_path or get_wide_win32_path. */
	      if (wide_path)
		cfree (wide_path);
	      wide_path = NULL;
	    }
	  if (need_directory)
	    {
	      size_t n = strlen (this->path);
	      /* Do not add trailing \ to UNC device names like \\.\a: */
	      if (this->path[n - 1] != '\\' &&
		  (strncmp (this->path, "\\\\.\\", 4) != 0))
		{
		  this->modifiable_path ()[n] = '\\';
		  this->modifiable_path ()[n + 1] = '\0';
		}
	    }
	}

      if (saw_symlinks)
	set_has_symlinks ();

      if (opt & PC_OPEN)
	path_flags |= PATH_OPEN;

      if (opt & PC_CTTY)
	path_flags |= PATH_CTTY;

      if (opt & PC_POSIX)
	{
	  if (tail < path_end && tail > path_copy + 1)
	    *tail = '/';
	  set_posix (path_copy);
	  if (is_msdos && dos_file_warning && !(opt & PC_NOWARN))
	    warn_msdos (src);
	}

#if 0
      if (!error)
	{
	  last_path_conv = *this;
	  strcpy (last_src, src);
	}
#endif
    }
  __except (NO_ERROR)
    {
      error = EFAULT;
    }
  __endtry
}

path_conv::~path_conv ()
{
  if (posix_path)
    {
      cfree ((void *) posix_path);
      posix_path = NULL;
    }
  if (path)
    {
      cfree (modifiable_path ());
      path = NULL;
    }
  if (wide_path)
    {
      cfree (wide_path);
      wide_path = NULL;
    }
  close_conv_handle ();
}

bool
path_conv::is_binary ()
{
  tmp_pathbuf tp;
  PWCHAR bintest = tp.w_get ();
  DWORD bin;

  return GetBinaryTypeW (get_wide_win32_path (bintest), &bin)
	 && (bin == SCS_32BIT_BINARY || bin == SCS_64BIT_BINARY);
}

/* Helper function to fill the fnoi datastructure for a file. */
NTSTATUS
file_get_fnoi (HANDLE h, bool skip_network_open_inf,
	       PFILE_NETWORK_OPEN_INFORMATION pfnoi)
{
  NTSTATUS status;
  IO_STATUS_BLOCK io;

  /* Some FSes (Netapps) don't implement FileNetworkOpenInformation. */
  status = skip_network_open_inf ? STATUS_INVALID_PARAMETER
	   : NtQueryInformationFile (h, &io, pfnoi, sizeof *pfnoi,
				     FileNetworkOpenInformation);
  if (status == STATUS_INVALID_PARAMETER)
    {
      /* Apart from accessing Netapps, this also occurs when accessing SMB
	 share root dirs hosted on NT4. */
      FILE_BASIC_INFORMATION fbi;
      FILE_STANDARD_INFORMATION fsi;

      status = NtQueryInformationFile (h, &io, &fbi, sizeof fbi,
				       FileBasicInformation);
      if (NT_SUCCESS (status))
	{
	  memcpy (pfnoi, &fbi, 4 * sizeof (LARGE_INTEGER));
	  if (NT_SUCCESS (NtQueryInformationFile (h, &io, &fsi,
					 sizeof fsi,
					 FileStandardInformation)))
	    {
	      pfnoi->EndOfFile.QuadPart = fsi.EndOfFile.QuadPart;
	      pfnoi->AllocationSize.QuadPart
		= fsi.AllocationSize.QuadPart;
	    }
	  else
	    pfnoi->EndOfFile.QuadPart
	      = pfnoi->AllocationSize.QuadPart = 0;
	  pfnoi->FileAttributes = fbi.FileAttributes;
	}
    }
  return status;
}

/* Normalize a Win32 path.
   /'s are converted to \'s in the process.
   All duplicate \'s, except for 2 leading \'s, are deleted.

   The result is 0 for success, or an errno error value.
   FIXME: A lot of this should be mergeable with the POSIX critter.  */
int
normalize_win32_path (const char *src, char *dst, char *&tail)
{
  const char *src_start = src;
  bool beg_src_slash = isdirsep (src[0]);

  tail = dst;
  /* Skip long path name prefixes in Win32 or NT syntax. */
  if (beg_src_slash && (src[1] == '?' || isdirsep (src[1]))
      && src[2] == '?' && isdirsep (src[3]))
    {
      src += 4;
      if (src[1] != ':') /* native UNC path */
	src += 2; /* Fortunately the first char is not copied... */
      else
	beg_src_slash = false;
    }
  if (beg_src_slash && isdirsep (src[1]))
    {
      if (isdirsep (src[2]))
	{
	  /* More than two slashes are just folded into one. */
	  src += 2;
	  while (isdirsep (src[1]))
	    ++src;
	}
      else
	{
	  /* Two slashes start a network or device path. */
	  *tail++ = '\\';
	  src++;
	  if (src[1] == '.' && isdirsep (src[2]))
	    {
	      *tail++ = '\\';
	      *tail++ = '.';
	      src += 2;
	    }
	}
    }
  if (tail == dst)
    {
      if (isdrive (src))
	/* Always convert drive letter to uppercase for case sensitivity. */
	*tail++ = cyg_toupper (*src++);
      else if (*src != '/')
	{
	  if (beg_src_slash)
	    tail += cygheap->cwd.get_drive (dst);
	  else if (!cygheap->cwd.get (dst, 0))
	    return get_errno ();
	  else
	    {
	      tail = strchr (tail, '\0');
	      if (tail[-1] != '\\')
		*tail++ = '\\';
	    }
	}
    }

  while (*src)
    {
      /* Strip duplicate /'s.  */
      if (isdirsep (src[0]) && isdirsep (src[1]))
	src++;
      /* Ignore "./".  */
      else if (src[0] == '.' && isdirsep (src[1])
	       && (src == src_start || isdirsep (src[-1])))
	src += 2;

      /* Backup if "..".  */
      else if (src[0] == '.' && src[1] == '.'
	       /* dst must be greater than dst_start */
	       && tail[-1] == '\\')
	{
	  if (!isdirsep (src[2]) && src[2] != '\0')
	      *tail++ = *src++;
	  else
	    {
	      /* Back up over /, but not if it's the first one.  */
	      if (tail > dst + 1)
		tail--;
	      /* Now back up to the next /.  */
	      while (tail > dst + 1 && tail[-1] != '\\' && tail[-2] != ':')
		tail--;
	      src += 2;
	      /* Skip /'s to the next path component. */
	      while (isdirsep (*src))
		src++;
	    }
	}
      /* Otherwise, add char to result.  */
      else
	{
	  if (*src == '/')
	    *tail++ = '\\';
	  else
	    *tail++ = *src;
	  src++;
	}
      if ((tail - dst) >= NT_MAX_PATH)
	return ENAMETOOLONG;
    }
  if (tail > dst + 1 && tail[-1] == '.' && tail[-2] == '\\')
    tail--;
  *tail = '\0';
  debug_printf ("%s = normalize_win32_path (%s)", dst, src_start);
  return 0;
}

/* Various utilities.  */

/* nofinalslash: Remove trailing / and \ from SRC (except for the
   first one).  It is ok for src == dst.  */

void __reg2
nofinalslash (const char *src, char *dst)
{
  int len = strlen (src);
  if (src != dst)
    memcpy (dst, src, len + 1);
  while (len > 1 && isdirsep (dst[--len]))
    dst[len] = '\0';
}

/* conv_path_list: Convert a list of path names to/from Win32/POSIX. */

static int
conv_path_list (const char *src, char *dst, size_t size,
		cygwin_conv_path_t what)
{
  tmp_pathbuf tp;
  char src_delim, dst_delim;
  size_t len;
  bool env_cvt = false;

  if (what == (cygwin_conv_path_t) ENV_CVT)
    {
      what = CCP_WIN_A_TO_POSIX | CCP_RELATIVE;
      env_cvt = true;
    }
  if ((what & CCP_CONVTYPE_MASK) == CCP_WIN_A_TO_POSIX)
    {
      src_delim = ';';
      dst_delim = ':';
    }
  else
    {
      src_delim = ':';
      dst_delim = ';';
    }

  char *srcbuf;
  len = strlen (src) + 1;
  if (len <= NT_MAX_PATH * sizeof (WCHAR))
    srcbuf = (char *) tp.w_get ();
  else
    srcbuf = (char *) alloca (len);

  int err = 0;
  char *d = dst - 1;
  bool saw_empty = false;
  do
    {
      char *srcpath = srcbuf;
      char *s = strccpy (srcpath, &src, src_delim);
      size_t len = s - srcpath;
      if (len >= NT_MAX_PATH)
	{
	  err = ENAMETOOLONG;
	  break;
	}
      /* Paths in Win32 path lists in the environment (%Path%), are often
	 enclosed in quotes (usually paths with spaces).  Trailing backslashes
	 are common, too.  Remove them. */
      if (env_cvt && len)
	{
	  if (*srcpath == '"')
	    {
	      ++srcpath;
	      *--s = '\0';
	      len -= 2;
	    }
	  while (len && s[-1] == '\\')
	    {
	      *--s = '\0';
	      --len;
	    }
	}
      if (len)
	{
	  ++d;
	  err = cygwin_conv_path (what, srcpath, d, size - (d - dst));
	}
      else if ((what & CCP_CONVTYPE_MASK) == CCP_POSIX_TO_WIN_A)
	{
	  ++d;
	  err = cygwin_conv_path (what, ".", d, size - (d - dst));
	}
      else
	{
	  if (env_cvt)
	    saw_empty = true;
	  continue;
	}
      if (err)
	break;
      d = strchr (d, '\0');
      *d = dst_delim;
    }
  while (*src++);

  if (saw_empty)
    err = EIDRM;

  if (d < dst)
    d++;
  *d = '\0';
  return err;
}

/********************** Symbolic Link Support **************************/

/* Create a symlink from FROMPATH to TOPATH. */

extern "C" int
symlink (const char *oldpath, const char *newpath)
{
  return symlink_worker (oldpath, newpath, false);
}

static int
symlink_nfs (const char *oldpath, path_conv &win32_newpath)
{
  /* On NFS, create symlinks by calling NtCreateFile with an EA of type
     NfsSymlinkTargetName containing ... the symlink target name. */
  tmp_pathbuf tp;
  PFILE_FULL_EA_INFORMATION pffei;
  NTSTATUS status;
  HANDLE fh;
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;

  pffei = (PFILE_FULL_EA_INFORMATION) tp.w_get ();
  pffei->NextEntryOffset = 0;
  pffei->Flags = 0;
  pffei->EaNameLength = sizeof (NFS_SYML_TARGET) - 1;
  char *EaValue = stpcpy (pffei->EaName, NFS_SYML_TARGET) + 1;
  pffei->EaValueLength = sizeof (WCHAR) *
    (sys_mbstowcs ((PWCHAR) EaValue, NT_MAX_PATH, oldpath) - 1);
  status = NtCreateFile (&fh, FILE_WRITE_DATA | FILE_WRITE_EA | SYNCHRONIZE,
			 win32_newpath.get_object_attr (attr, sec_none_nih),
			 &io, NULL, FILE_ATTRIBUTE_SYSTEM,
			 FILE_SHARE_VALID_FLAGS, FILE_CREATE,
			 FILE_SYNCHRONOUS_IO_NONALERT
			 | FILE_OPEN_FOR_BACKUP_INTENT,
			 pffei, NT_MAX_PATH * sizeof (WCHAR));
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      return -1;
    }
  NtClose (fh);
  return 0;
}

/* Count backslashes between s and e. */
static inline int
cnt_bs (PWCHAR s, PWCHAR e)
{
  int num = 0;

  while (s < e)
    if (*s++ == L'\\')
      ++num;
  return num;
}

static int
symlink_native (const char *oldpath, path_conv &win32_newpath)
{
  tmp_pathbuf tp;
  path_conv win32_oldpath;
  PUNICODE_STRING final_oldpath, final_newpath;
  UNICODE_STRING final_oldpath_buf;

  if (isabspath (oldpath))
    {
      win32_oldpath.check (oldpath, PC_SYM_NOFOLLOW, stat_suffixes);
      final_oldpath = win32_oldpath.get_nt_native_path ();
    }
  else
    {
      /* The symlink target is relative to the directory in which
	 the symlink gets created, not relative to the cwd.  Therefore
	 we have to mangle the path quite a bit before calling path_conv. */
      ssize_t len = strrchr (win32_newpath.get_posix (), '/')
		    - win32_newpath.get_posix () + 1;
      char *absoldpath = tp.t_get ();
      stpcpy (stpncpy (absoldpath, win32_newpath.get_posix (), len),
	      oldpath);
      win32_oldpath.check (absoldpath, PC_SYM_NOFOLLOW, stat_suffixes);

      /* Try hard to keep Windows symlink path relative. */

      /* 1. Find common path prefix.  Skip leading \\?\, but take pre-increment
            of the following loop into account. */
      PWCHAR c_old = win32_oldpath.get_nt_native_path ()->Buffer + 3;
      PWCHAR c_new = win32_newpath.get_nt_native_path ()->Buffer + 3;
      /* Windows compatible == always check case insensitive.  */
      while (towupper (*++c_old) == towupper (*++c_new))
	;
      /* The last component could share a common prefix, so make sure we end
         up on the first char after the last common backslash. */
      while (c_old[-1] != L'\\')
	--c_old, --c_new;

      /* 2. Check if prefix is long enough.  The prefix must at least points to
            a complete device:  \\?\X:\ or \\?\UNC\server\share\ are the minimum
	    prefix strings.  We start counting behind the \\?\ for speed. */
      int num = cnt_bs (win32_oldpath.get_nt_native_path ()->Buffer + 4, c_old);
      if (num < 1		/* locale drive. */
	  || (win32_oldpath.get_nt_native_path ()->Buffer[6] != L':'
	      && num < 3))	/* UNC path. */
	{
	  /* 3a. No valid common path prefix: Create absolute symlink. */
	  final_oldpath = win32_oldpath.get_nt_native_path ();
	}
      else
	{
	  /* 3b. Common path prefx.  Count number of additional directories
		 in symlink's path, and prepend as much ".." path components
		 to the target path. */
	  PWCHAR e_new = win32_newpath.get_nt_native_path ()->Buffer
			 + win32_newpath.get_nt_native_path ()->Length
			   / sizeof (WCHAR);
	  num = cnt_bs (c_new, e_new);
	  final_oldpath = &final_oldpath_buf;
	  final_oldpath->Buffer = tp.w_get ();
	  PWCHAR e_old = final_oldpath->Buffer;
	  while (num-- > 0)
	    e_old = wcpcpy (e_old, L"..\\");
	  wcpcpy (e_old, c_old);
	}
    }
  /* If the symlink target doesn't exist, don't create native symlink.
     Otherwise the directory flag in the symlink is potentially wrong
     when the target comes into existence, and native tools will fail.
     This is so screwball. This is no problem on AFS, fortunately. */
  if (!win32_oldpath.exists () && !win32_oldpath.fs_is_afs ())
    {
      SetLastError (ERROR_FILE_NOT_FOUND);
      return -1;
    }
  /* Convert native paths to Win32 UNC paths. */
  final_newpath = win32_newpath.get_nt_native_path ();
  final_newpath->Buffer[1] = L'\\';
  /* oldpath may be relative.  Make sure to convert only absolute paths
     to Win32 paths. */
  if (final_oldpath->Buffer[0] == L'\\')
    {
      /* Workaround Windows 8.1 bug.  On Windows 8.1, the ShellExecuteW
	 function does not handle the long path prefix correctly for symlink
	 targets.  Thus, we create simple short paths < MAX_PATH without
	 long path prefix. */
      if (RtlEqualUnicodePathPrefix (final_oldpath, &ro_u_uncp, TRUE)
	  && final_oldpath->Length < (MAX_PATH + 6) * sizeof (WCHAR))
	{
	  final_oldpath->Buffer += 6;
	  final_oldpath->Buffer[0] = L'\\';
	}
      else if (final_oldpath->Length < (MAX_PATH + 4) * sizeof (WCHAR))
	final_oldpath->Buffer += 4;
      else /* Stick to long path, fix native prefix for Win32 API calls. */
	final_oldpath->Buffer[1] = L'\\';
    }
  /* Try to create native symlink. */
  if (!CreateSymbolicLinkW (final_newpath->Buffer, final_oldpath->Buffer,
			    win32_oldpath.isdir ()
			    ? SYMBOLIC_LINK_FLAG_DIRECTORY : 0))
    {
      /* Repair native newpath, we still need it. */
      final_newpath->Buffer[1] = L'?';
      return -1;
    }
  return 0;
}

int
symlink_worker (const char *oldpath, const char *newpath, bool isdevice)
{
  int res = -1;
  size_t len;
  path_conv win32_newpath;
  char *buf, *cp;
  tmp_pathbuf tp;
  unsigned check_opt;
  bool has_trailing_dirsep = false;
  winsym_t wsym_type;

  /* POSIX says that empty 'newpath' is invalid input while empty
     'oldpath' is valid -- it's symlink resolver job to verify if
     symlink contents point to existing filesystem object */
  __try
    {
      if (!*oldpath || !*newpath)
	{
	  set_errno (ENOENT);
	  __leave;
	}

      if (strlen (oldpath) > SYMLINK_MAX)
	{
	  set_errno (ENAMETOOLONG);
	  __leave;
	}

      /* Trailing dirsep is a no-no. */
      len = strlen (newpath);
      has_trailing_dirsep = isdirsep (newpath[len - 1]);
      if (has_trailing_dirsep)
	{
	  newpath = strdup (newpath);
	  ((char *) newpath)[len - 1] = '\0';
	}

      check_opt = PC_SYM_NOFOLLOW | PC_POSIX | (isdevice ? PC_NOWARN : 0);
      /* We need the normalized full path below. */
      win32_newpath.check (newpath, check_opt, stat_suffixes);

      /* Default symlink type is determined by global allow_winsymlinks
	 variable.  Device files are always shortcuts. */
      wsym_type = isdevice ? WSYM_lnk : allow_winsymlinks;
      /* NFS has its own, dedicated way to create symlinks. */
      if (win32_newpath.fs_is_nfs ())
	wsym_type = WSYM_nfs;
      /* MVFS doesn't handle the SYSTEM DOS attribute, but it handles the R/O
	 attribute. Therefore we create symlinks on MVFS always as shortcuts. */
      else if (win32_newpath.fs_is_mvfs ())
	wsym_type = WSYM_lnk;
      /* AFS only supports native symlinks. */
      else if (win32_newpath.fs_is_afs ())
	{
	  /* Bail out if OS doesn't support native symlinks. */
	  if (wincap.max_sys_priv () < SE_CREATE_SYMBOLIC_LINK_PRIVILEGE)
	    {
	      set_errno (EPERM);
	      __leave;
	    }
	  wsym_type = WSYM_nativestrict;
	}
      /* Don't try native symlinks on FSes not supporting reparse points. */
      else if ((wsym_type == WSYM_native || wsym_type == WSYM_nativestrict)
	       && !(win32_newpath.fs_flags () & FILE_SUPPORTS_REPARSE_POINTS))
	wsym_type = WSYM_sysfile;

      /* Attach .lnk suffix when shortcut is requested. */
      if (wsym_type == WSYM_lnk && !win32_newpath.exists ()
	  && (isdevice || !win32_newpath.fs_is_nfs ()))
	{
	  char *newplnk = tp.c_get ();
	  stpcpy (stpcpy (newplnk, newpath), ".lnk");
	  win32_newpath.check (newplnk, check_opt);
	}

      if (win32_newpath.error)
	{
	  set_errno (win32_newpath.error);
	  __leave;
	}

      syscall_printf ("symlink (%s, %S) wsym_type %d", oldpath,
		      win32_newpath.get_nt_native_path (), wsym_type);

      if ((!isdevice && win32_newpath.exists ())
	  || win32_newpath.is_auto_device ())
	{
	  set_errno (EEXIST);
	  __leave;
	}
      if (has_trailing_dirsep && !win32_newpath.exists ())
	{
	  set_errno (ENOENT);
	  __leave;
	}

      /* Handle NFS and native symlinks in their own functions. */
      switch (wsym_type)
	{
	case WSYM_nfs:
	  res = symlink_nfs (oldpath, win32_newpath);
	  __leave;
	case WSYM_native:
	case WSYM_nativestrict:
	  res = symlink_native (oldpath, win32_newpath);
	  if (!res)
	    __leave;
	  /* Strictly native?  Too bad. */
	  if (wsym_type == WSYM_nativestrict)
	    {
	      __seterrno ();
	      __leave;
	    }
	  /* Otherwise, fall back to default symlink type. */
	  wsym_type = WSYM_sysfile;
	  break;
	default:
	  break;
	}

      if (wsym_type == WSYM_lnk)
	{
	  path_conv win32_oldpath;
	  ITEMIDLIST *pidl = NULL;
	  size_t full_len = 0;
	  unsigned short oldpath_len, desc_len, relpath_len, pidl_len = 0;
	  char desc[MAX_PATH + 1], *relpath;

	  if (!isdevice)
	    {
	      /* First create an IDLIST to learn how big our shortcut is
		 going to be. */
	      IShellFolder *psl;

	      /* The symlink target is relative to the directory in which the
		 symlink gets created, not relative to the cwd.  Therefore we
		 have to mangle the path quite a bit before calling path_conv.*/
	      if (isabspath (oldpath))
		win32_oldpath.check (oldpath,
				     PC_SYM_NOFOLLOW,
				     stat_suffixes);
	      else
		{
		  len = strrchr (win32_newpath.get_posix (), '/')
			- win32_newpath.get_posix () + 1;
		  char *absoldpath = tp.t_get ();
		  stpcpy (stpncpy (absoldpath, win32_newpath.get_posix (),
				   len),
			  oldpath);
		  win32_oldpath.check (absoldpath, PC_SYM_NOFOLLOW,
				       stat_suffixes);
		}
	      if (SUCCEEDED (SHGetDesktopFolder (&psl)))
		{
		  WCHAR wc_path[win32_oldpath.get_wide_win32_path_len () + 1];
		  win32_oldpath.get_wide_win32_path (wc_path);
		  /* Amazing but true:  Even though the ParseDisplayName method
		     takes a wide char path name, it does not understand the
		     Win32 prefix for long pathnames!  So we have to tack off
		     the prefix and convert the path to the "normal" syntax
		     for ParseDisplayName.  */
		  WCHAR *wc = wc_path + 4;
		  if (wc[1] != L':') /* native UNC path */
		    *(wc += 2) = L'\\';
		  HRESULT res;
		  if (SUCCEEDED (res = psl->ParseDisplayName (NULL, NULL, wc,
							      NULL, &pidl,
							      NULL)))
		    {
		      ITEMIDLIST *p;

		      for (p = pidl; p->mkid.cb > 0;
			   p = (ITEMIDLIST *)((char *) p + p->mkid.cb))
			;
		      pidl_len = (char *) p - (char *) pidl + 2;
		    }
		  psl->Release ();
		}
	    }
	  /* Compute size of shortcut file. */
	  full_len = sizeof (win_shortcut_hdr);
	  if (pidl_len)
	    full_len += sizeof (unsigned short) + pidl_len;
	  oldpath_len = strlen (oldpath);
	  /* Unfortunately the length of the description is restricted to a
	     length of 2000 bytes.  We don't want to add considerations for
	     the different lengths and even 2000 bytes is not enough for long
	     path names.  So what we do here is to set the description to the
	     POSIX path only if the path is not longer than MAX_PATH characters.
	     We append the full path name after the regular shortcut data
	     (see below), which works fine with Windows Explorer as well
	     as older Cygwin versions (as long as the whole file isn't bigger
	     than 8K).  The description field is only used for backward
	     compatibility to older Cygwin versions and those versions are
	     not capable of handling long path names anyway. */
	  desc_len = stpcpy (desc, oldpath_len > MAX_PATH
				   ? "[path too long]" : oldpath) - desc;
	  full_len += sizeof (unsigned short) + desc_len;
	  /* Devices get the oldpath string unchanged as relative path. */
	  if (isdevice)
	    {
	      relpath_len = oldpath_len;
	      stpcpy (relpath = tp.c_get (), oldpath);
	    }
	  else
	    {
	      relpath_len = strlen (win32_oldpath.get_win32 ());
	      stpcpy (relpath = tp.c_get (), win32_oldpath.get_win32 ());
	    }
	  full_len += sizeof (unsigned short) + relpath_len;
	  full_len += sizeof (unsigned short) + oldpath_len;
	  /* 1 byte more for trailing 0 written by stpcpy. */
	  if (full_len < NT_MAX_PATH * sizeof (WCHAR))
	    buf = tp.t_get ();
	  else
	    buf = (char *) alloca (full_len + 1);

	  /* Create shortcut header */
	  win_shortcut_hdr *shortcut_header = (win_shortcut_hdr *) buf;
	  memset (shortcut_header, 0, sizeof *shortcut_header);
	  shortcut_header->size = sizeof *shortcut_header;
	  shortcut_header->magic = GUID_shortcut;
	  shortcut_header->flags = (WSH_FLAG_DESC | WSH_FLAG_RELPATH);
	  if (pidl)
	    shortcut_header->flags |= WSH_FLAG_IDLIST;
	  shortcut_header->run = SW_NORMAL;
	  cp = buf + sizeof (win_shortcut_hdr);

	  /* Create IDLIST */
	  if (pidl)
	    {
	      *(unsigned short *)cp = pidl_len;
	      memcpy (cp += 2, pidl, pidl_len);
	      cp += pidl_len;
	      CoTaskMemFree (pidl);
	    }

	  /* Create description */
	  *(unsigned short *)cp = desc_len;
	  cp = stpcpy (cp += 2, desc);

	  /* Create relpath */
	  *(unsigned short *)cp = relpath_len;
	  cp = stpcpy (cp += 2, relpath);

	  /* Append the POSIX path after the regular shortcut data for
	     the long path support. */
	  unsigned short *plen = (unsigned short *) cp;
	  cp += 2;
	  *(PWCHAR) cp = 0xfeff;		/* BOM */
	  cp += 2;
	  *plen = sys_mbstowcs ((PWCHAR) cp, NT_MAX_PATH, oldpath)
		  * sizeof (WCHAR);
	  cp += *plen;
	}
      else
	{
	  /* Default technique creating a symlink. */
	  buf = tp.t_get ();
	  cp = stpcpy (buf, SYMLINK_COOKIE);
	  *(PWCHAR) cp = 0xfeff;		/* BOM */
	  cp += 2;
	  /* Note that the terminating nul is written.  */
	  cp += sys_mbstowcs ((PWCHAR) cp, NT_MAX_PATH, oldpath)
		* sizeof (WCHAR);
	}

      OBJECT_ATTRIBUTES attr;
      IO_STATUS_BLOCK io;
      NTSTATUS status;
      ULONG access;
      HANDLE fh;

      access = DELETE | FILE_GENERIC_WRITE;
      if (isdevice && win32_newpath.exists ())
	{
	  status = NtOpenFile (&fh, FILE_WRITE_ATTRIBUTES,
			       win32_newpath.get_object_attr (attr,
							      sec_none_nih),
			       &io, 0, FILE_OPEN_FOR_BACKUP_INTENT);
	  if (!NT_SUCCESS (status))
	    {
	      __seterrno_from_nt_status (status);
	      __leave;
	    }
	  status = NtSetAttributesFile (fh, FILE_ATTRIBUTE_NORMAL);
	  NtClose (fh);
	  if (!NT_SUCCESS (status))
	    {
	      __seterrno_from_nt_status (status);
	      __leave;
	    }
	}
      else if (!isdevice && win32_newpath.has_acls ()
	       && !win32_newpath.isremote ())
	/* If the filesystem supports ACLs, we will overwrite the DACL after the
	   call to NtCreateFile.  This requires a handle with READ_CONTROL and
	   WRITE_DAC access, otherwise get_file_sd and set_file_sd both have to
	   open the file again.
	   FIXME: On remote NTFS shares open sometimes fails because even the
	   creator of the file doesn't have the right to change the DACL.
	   I don't know what setting that is or how to recognize such a share,
	   so for now we don't request WRITE_DAC on remote drives. */
	access |= READ_CONTROL | WRITE_DAC;

      status = NtCreateFile (&fh, access,
			     win32_newpath.get_object_attr (attr, sec_none_nih),
			     &io, NULL, FILE_ATTRIBUTE_NORMAL,
			     FILE_SHARE_VALID_FLAGS,
			     isdevice ? FILE_OVERWRITE_IF : FILE_CREATE,
			     FILE_SYNCHRONOUS_IO_NONALERT
			     | FILE_NON_DIRECTORY_FILE
			     | FILE_OPEN_FOR_BACKUP_INTENT,
			     NULL, 0);
      if (!NT_SUCCESS (status))
	{
	  __seterrno_from_nt_status (status);
	  __leave;
	}
      if (win32_newpath.has_acls ())
	set_file_attribute (fh, win32_newpath, ILLEGAL_UID, ILLEGAL_GID,
			    (io.Information == FILE_CREATED ? S_JUSTCREATED : 0)
			    | S_IFLNK | STD_RBITS | STD_WBITS);
      status = NtWriteFile (fh, NULL, NULL, NULL, &io, buf, cp - buf,
			    NULL, NULL);
      if (NT_SUCCESS (status) && io.Information == (ULONG) (cp - buf))
	{
	  status = NtSetAttributesFile (fh, wsym_type == WSYM_lnk
					    ? FILE_ATTRIBUTE_READONLY
					    : FILE_ATTRIBUTE_SYSTEM);
	  if (!NT_SUCCESS (status))
	    debug_printf ("Setting attributes failed, status = %y", status);
	  res = 0;
	}
      else
	{
	  __seterrno_from_nt_status (status);
	  FILE_DISPOSITION_INFORMATION fdi = { TRUE };
	  status = NtSetInformationFile (fh, &io, &fdi, sizeof fdi,
					 FileDispositionInformation);
	  if (!NT_SUCCESS (status))
	    debug_printf ("Setting delete dispostion failed, status = %y",
			  status);
	}
      NtClose (fh);

    }
  __except (EFAULT) {}
  __endtry
  syscall_printf ("%d = symlink_worker(%s, %s, %d)",
		  res, oldpath, newpath, isdevice);
  if (has_trailing_dirsep)
    free ((void *) newpath);
  return res;
}

static bool
cmp_shortcut_header (win_shortcut_hdr *file_header)
{
  /* A Cygwin or U/Win shortcut only contains a description and a relpath.
     Cygwin shortcuts also might contain an ITEMIDLIST. The run type is
     always set to SW_NORMAL. */
  return file_header->size == sizeof (win_shortcut_hdr)
      && !memcmp (&file_header->magic, &GUID_shortcut, sizeof GUID_shortcut)
      && (file_header->flags & ~WSH_FLAG_IDLIST)
	 == (WSH_FLAG_DESC | WSH_FLAG_RELPATH)
      && file_header->run == SW_NORMAL;
}

int
symlink_info::check_shortcut (HANDLE h)
{
  tmp_pathbuf tp;
  win_shortcut_hdr *file_header;
  char *buf, *cp;
  unsigned short len;
  int res = 0;
  NTSTATUS status;
  IO_STATUS_BLOCK io;
  FILE_STANDARD_INFORMATION fsi;
  LARGE_INTEGER off = { QuadPart:0LL };

  status = NtQueryInformationFile (h, &io, &fsi, sizeof fsi,
				   FileStandardInformation);
  if (!NT_SUCCESS (status))
    {
      set_error (EIO);
      return 0;
    }
  if (fsi.EndOfFile.QuadPart <= (LONGLONG) sizeof (win_shortcut_hdr)
      || fsi.EndOfFile.QuadPart > 4 * 65536)
    return 0;
  if (fsi.EndOfFile.LowPart < NT_MAX_PATH * sizeof (WCHAR))
    buf = (char *) tp.w_get ();
  else
    buf = (char *) alloca (fsi.EndOfFile.LowPart + 1);
  status = NtReadFile (h, NULL, NULL, NULL, &io, buf, fsi.EndOfFile.LowPart,
		       &off, NULL);
  if (!NT_SUCCESS (status))
    {
      if (status != STATUS_END_OF_FILE)
	set_error (EIO);
      return 0;
    }
  file_header = (win_shortcut_hdr *) buf;
  if (io.Information != fsi.EndOfFile.LowPart
      || !cmp_shortcut_header (file_header))
    return 0;
  cp = buf + sizeof (win_shortcut_hdr);
  if (file_header->flags & WSH_FLAG_IDLIST) /* Skip ITEMIDLIST */
    cp += *(unsigned short *) cp + 2;
  if (!(len = *(unsigned short *) cp))
    return 0;
  cp += 2;
  /* Check if this is a device file - these start with the sequence :\\ */
  if (strncmp (cp, ":\\", 2) == 0)
    res = strlen (strcpy (contents, cp)); /* Don't mess with device files */
  else
    {
      /* Has appended full path?  If so, use it instead of description. */
      unsigned short relpath_len = *(unsigned short *) (cp + len);
      if (cp + len + 2 + relpath_len < buf + fsi.EndOfFile.LowPart)
	{
	  cp += len + 2 + relpath_len;
	  len = *(unsigned short *) cp;
	  cp += 2;
	}
      if (*(PWCHAR) cp == 0xfeff)	/* BOM */
	{
	  char *tmpbuf = tp.c_get ();
	  if (sys_wcstombs (tmpbuf, NT_MAX_PATH, (PWCHAR) (cp + 2))
	      > SYMLINK_MAX + 1)
	    return 0;
	  res = posixify (tmpbuf);
	}
      else if (len > SYMLINK_MAX)
	return 0;
      else
	{
	  cp[len] = '\0';
	  res = posixify (cp);
	}
    }
  if (res) /* It's a symlink.  */
    pflags |= PATH_SYMLINK | PATH_LNK;
  return res;
}

int
symlink_info::check_sysfile (HANDLE h)
{
  tmp_pathbuf tp;
  char cookie_buf[sizeof (SYMLINK_COOKIE) - 1];
  char *srcbuf = tp.c_get ();
  int res = 0;
  NTSTATUS status;
  IO_STATUS_BLOCK io;
  bool interix_symlink = false;
  LARGE_INTEGER off = { QuadPart:0LL };

  status = NtReadFile (h, NULL, NULL, NULL, &io, cookie_buf,
		       sizeof (cookie_buf), &off, NULL);
  if (!NT_SUCCESS (status))
    {
      debug_printf ("ReadFile1 failed %y", status);
      if (status != STATUS_END_OF_FILE)
	set_error (EIO);
      return 0;
    }
  off.QuadPart = io.Information;
  if (io.Information == sizeof (cookie_buf)
	   && memcmp (cookie_buf, SYMLINK_COOKIE, sizeof (cookie_buf)) == 0)
    {
      /* It's a symlink.  */
      pflags |= PATH_SYMLINK;
    }
  else if (io.Information == sizeof (cookie_buf)
	   && memcmp (cookie_buf, SOCKET_COOKIE, sizeof (cookie_buf)) == 0)
    pflags |= PATH_SOCKET;
  else if (io.Information >= sizeof (INTERIX_SYMLINK_COOKIE)
	   && memcmp (cookie_buf, INTERIX_SYMLINK_COOKIE,
		      sizeof (INTERIX_SYMLINK_COOKIE) - 1) == 0)
    {
      /* It's an Interix symlink.  */
      pflags |= PATH_SYMLINK;
      interix_symlink = true;
      /* Interix symlink cookies are shorter than Cygwin symlink cookies, so
	 in case of an Interix symlink cooky we have read too far into the
	 file.  Set file pointer back to the position right after the cookie. */
      off.QuadPart = sizeof (INTERIX_SYMLINK_COOKIE) - 1;
    }
  if (pflags & PATH_SYMLINK)
    {
      status = NtReadFile (h, NULL, NULL, NULL, &io, srcbuf,
			   NT_MAX_PATH, &off, NULL);
      if (!NT_SUCCESS (status))
	{
	  debug_printf ("ReadFile2 failed");
	  if (status != STATUS_END_OF_FILE)
	    set_error (EIO);
	}
      else if (*(PWCHAR) srcbuf == 0xfeff 	/* BOM */
	       || interix_symlink)
	{
	  /* Add trailing 0 to Interix symlink target.  Skip BOM in Cygwin
	     symlinks. */
	  if (interix_symlink)
	    ((PWCHAR) srcbuf)[io.Information / sizeof (WCHAR)] = L'\0';
	  else
	    srcbuf += 2;
	  char *tmpbuf = tp.c_get ();
	  if (sys_wcstombs (tmpbuf, NT_MAX_PATH, (PWCHAR) srcbuf)
	      > SYMLINK_MAX + 1)
	    debug_printf ("symlink string too long");
	  else
	    res = posixify (tmpbuf);
	}
      else if (io.Information > SYMLINK_MAX + 1)
	debug_printf ("symlink string too long");
      else
	res = posixify (srcbuf);
    }
  return res;
}

int
symlink_info::check_reparse_point (HANDLE h, bool remote)
{
  tmp_pathbuf tp;
  NTSTATUS status;
  IO_STATUS_BLOCK io;
  PREPARSE_DATA_BUFFER rp = (PREPARSE_DATA_BUFFER) tp.c_get ();
  UNICODE_STRING subst;
  char srcbuf[SYMLINK_MAX + 7];

  /* On remote drives or under heavy load, NtFsControlFile can return with
     STATUS_PENDING.  If so, instead of creating an event object, just set
     io.Status to an invalid value and perform a minimal wait until io.Status
     changed. */
  memset (&io, 0xff, sizeof io);
  status = NtFsControlFile (h, NULL, NULL, NULL, &io,
			    FSCTL_GET_REPARSE_POINT, NULL, 0, (LPVOID) rp,
			    MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
  if (status == STATUS_PENDING)
    {
      while (io.Status == (NTSTATUS) 0xffffffff)
      	Sleep (1L);
      status = io.Status;
    }
  if (!NT_SUCCESS (status))
    {
      debug_printf ("NtFsControlFile(FSCTL_GET_REPARSE_POINT) failed, %y",
		    status);
      set_error (EIO);
      return 0;
    }
  if (rp->ReparseTag == IO_REPARSE_TAG_SYMLINK)
    /* Windows evaluates native symlink literally.  If a remote symlink points
       to, say, C:\foo, it will be handled as if the target is the local file
       C:\foo.  That comes in handy since that's how symlinks are treated under
       POSIX as well. */
    RtlInitCountedUnicodeString (&subst,
		  (WCHAR *)((char *)rp->SymbolicLinkReparseBuffer.PathBuffer
			+ rp->SymbolicLinkReparseBuffer.SubstituteNameOffset),
		  rp->SymbolicLinkReparseBuffer.SubstituteNameLength);
  else if (!remote && rp->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)
    {
      /* Don't handle junctions on remote filesystems as symlinks.  This type
	 of reparse point is handled transparently by the OS so that the
	 target of the junction is the remote directory it is supposed to
	 point to.  If we handle it as symlink, it will be mistreated as
	 pointing to a dir on the local system. */
      RtlInitCountedUnicodeString (&subst,
		  (WCHAR *)((char *)rp->MountPointReparseBuffer.PathBuffer
			  + rp->MountPointReparseBuffer.SubstituteNameOffset),
		  rp->MountPointReparseBuffer.SubstituteNameLength);
      if (RtlEqualUnicodePathPrefix (&subst, &ro_u_volume, TRUE))
	{
	  /* Volume mount point.  Not treated as symlink. The return
	     value of -1 is a hint for the caller to treat this as a
	     volume mount point. */
	  return -1;
	}
    }
  else
    {
      /* Maybe it's a reparse point, but it's certainly not one we recognize.
	 Drop REPARSE attribute so we don't try to use the flag accidentally.
	 It's just some arbitrary file or directory for us. */
      fileattr &= ~FILE_ATTRIBUTE_REPARSE_POINT;
      return 0;
    }
  sys_wcstombs (srcbuf, SYMLINK_MAX + 7, subst.Buffer,
		subst.Length / sizeof (WCHAR));
  pflags |= PATH_SYMLINK | PATH_REP;
  /* A symlink is never a directory. */
  fileattr &= ~FILE_ATTRIBUTE_DIRECTORY;
  return posixify (srcbuf);
}

int
symlink_info::check_nfs_symlink (HANDLE h)
{
  tmp_pathbuf tp;
  NTSTATUS status;
  IO_STATUS_BLOCK io;
  struct {
    FILE_GET_EA_INFORMATION fgei;
    char buf[sizeof (NFS_SYML_TARGET)];
  } fgei_buf;
  PFILE_FULL_EA_INFORMATION pffei;
  int res = 0;

  /* To find out if the file is a symlink and to get the symlink target,
     try to fetch the NfsSymlinkTargetName EA. */
  fgei_buf.fgei.NextEntryOffset = 0;
  fgei_buf.fgei.EaNameLength = sizeof (NFS_SYML_TARGET) - 1;
  stpcpy (fgei_buf.fgei.EaName, NFS_SYML_TARGET);
  pffei = (PFILE_FULL_EA_INFORMATION) tp.w_get ();
  status = NtQueryEaFile (h, &io, pffei, NT_MAX_PATH * sizeof (WCHAR), TRUE,
			  &fgei_buf.fgei, sizeof fgei_buf, NULL, TRUE);
  if (NT_SUCCESS (status) && pffei->EaValueLength > 0)
    {
      PWCHAR spath = (PWCHAR)
		     (pffei->EaName + pffei->EaNameLength + 1);
      res = sys_wcstombs (contents, SYMLINK_MAX + 1,
			  spath, pffei->EaValueLength) - 1;
      pflags |= PATH_SYMLINK;
    }
  return res;
}

int
symlink_info::posixify (char *srcbuf)
{
  /* The definition for a path in a native symlink is a bit weird.  The Flags
     value seem to contain 0 for absolute paths (stored as NT native path)
     and 1 for relative paths.  Relative paths are paths not starting with a
     drive letter.  These are not converted to NT native, but stored as
     given.  A path starting with a single backslash is relative to the
     current drive thus a "relative" value (Flags == 1).
     Funny enough it's possible to store paths with slashes instead of
     backslashes, but they are evaluated incorrectly by subsequent Windows
     calls like CreateFile (ERROR_INVALID_NAME).  So, what we do here is to
     take paths starting with slashes at face value, evaluating them as
     Cygwin specific POSIX paths.
     A path starting with two slashes(!) or backslashes is converted into an
     NT UNC path.  Unfortunately, in contrast to POSIX rules, paths starting
     with three or more (back)slashes are also converted into UNC paths,
     just incorrectly sticking to one redundant leading backslash.  We go
     along with this behaviour to avoid scenarios in which native tools access
     other files than Cygwin.
     The above rules are used exactly the same way on Cygwin specific symlinks
     (sysfiles and shortcuts) to eliminate non-POSIX paths in the output. */

  /* Eliminate native NT prefixes. */
  if (srcbuf[0] == '\\' && !strncmp (srcbuf + 1, "??\\", 3))
    {
      srcbuf += 4;
      if (srcbuf[1] != ':') /* native UNC path */
	*(srcbuf += 2) = '\\';
    }
  if (isdrive (srcbuf))
    mount_table->conv_to_posix_path (srcbuf, contents, 0);
  else if (srcbuf[0] == '\\')
    {
      if (srcbuf[1] == '\\') /* UNC path */
	slashify (srcbuf, contents, 0);
      else /* Paths starting with \ are current drive relative. */
	{
	  char cvtbuf[SYMLINK_MAX + 1];

	  stpcpy (cvtbuf + cygheap->cwd.get_drive (cvtbuf), srcbuf);
	  mount_table->conv_to_posix_path (cvtbuf, contents, 0);
	}
    }
  else /* Everything else is taken as is. */
    slashify (srcbuf, contents, 0);
  return strlen (contents);
}

enum
{
  SCAN_BEG,
  SCAN_LNK,
  SCAN_HASLNK,
  SCAN_JUSTCHECK,
  SCAN_JUSTCHECKTHIS, /* Never try to append a suffix. */
  SCAN_APPENDLNK,
  SCAN_EXTRALNK,
  SCAN_DONE,
};

class suffix_scan
{
  const suffix_info *suffixes, *suffixes_start;
  int nextstate;
  char *eopath;
  size_t namelen;
public:
  const char *path;
  char *has (const char *, const suffix_info *);
  int next ();
  int lnk_match () {return nextstate >= SCAN_APPENDLNK;}
  size_t name_len () {return namelen;}
};

char *
suffix_scan::has (const char *in_path, const suffix_info *in_suffixes)
{
  nextstate = SCAN_BEG;
  suffixes = suffixes_start = in_suffixes;

  const char *fname = strrchr (in_path, '\\');
  fname = fname ? fname + 1 : in_path;
  char *ext_here = strrchr (fname, '.');
  path = in_path;
  eopath = strchr (path, '\0');

  if (!ext_here)
    goto noext;

  if (suffixes)
    {
      /* Check if the extension matches a known extension */
      for (const suffix_info *ex = in_suffixes; ex->name != NULL; ex++)
	if (ascii_strcasematch (ext_here, ex->name))
	  {
	    nextstate = SCAN_JUSTCHECK;
	    suffixes = NULL;	/* Has an extension so don't scan for one. */
	    goto done;
	  }
    }

  /* Didn't match.  Use last resort -- .lnk. */
  if (ascii_strcasematch (ext_here, ".lnk"))
    {
      nextstate = SCAN_HASLNK;
      suffixes = NULL;
    }

 noext:
  ext_here = eopath;

 done:
  namelen = eopath - fname;
  /* Avoid attaching suffixes if the resulting filename would be invalid.
     For performance reasons we don't check the length of a suffix, since
     we know that all suffixes are 4 chars in length.
     
     FIXME: This is not really correct.  A fully functional test should
            work on wide character paths.  This would probably also speed
	    up symlink_info::check. */
  if (namelen > NAME_MAX - 4)
    {
      nextstate = SCAN_JUSTCHECKTHIS;
      suffixes = NULL;
    }
  return ext_here;
}

int
suffix_scan::next ()
{
  for (;;)
    {
      if (!suffixes)
	switch (nextstate)
	  {
	  case SCAN_BEG:
	    suffixes = suffixes_start;
	    if (!suffixes)
	      {
		nextstate = SCAN_LNK;
		return 1;
	      }
	    nextstate = SCAN_EXTRALNK;
	    /* fall through to suffix checking below */
	    break;
	  case SCAN_HASLNK:
	    nextstate = SCAN_APPENDLNK;	/* Skip SCAN_BEG */
	    return 1;
	  case SCAN_EXTRALNK:
	    nextstate = SCAN_DONE;
	    *eopath = '\0';
	    return 0;
	  case SCAN_JUSTCHECK:
	    nextstate = SCAN_LNK;
	    return 1;
	  case SCAN_JUSTCHECKTHIS:
	    nextstate = SCAN_DONE;
	    return 1;
	  case SCAN_LNK:
	  case SCAN_APPENDLNK:
	    nextstate = SCAN_DONE;
	    if (namelen + (*eopath ? 8 : 4) > NAME_MAX)
	      {
		*eopath = '\0';
		return 0;
	      }
	    strcat (eopath, ".lnk");
	    return 1;
	  default:
	    *eopath = '\0';
	    return 0;
	  }

      while (suffixes && suffixes->name)
	if (nextstate == SCAN_EXTRALNK
	    && (!suffixes->addon || namelen > NAME_MAX - 8))
	  suffixes++;
	else
	  {
	    strcpy (eopath, suffixes->name);
	    if (nextstate == SCAN_EXTRALNK)
	      strcat (eopath, ".lnk");
	    suffixes++;
	    return 1;
	  }
      suffixes = NULL;
    }
}

bool
symlink_info::set_error (int in_errno)
{
  bool res;
  if (!(pflags & PATH_NO_ACCESS_CHECK) || in_errno == ENAMETOOLONG || in_errno == EIO)
    {
      error = in_errno;
      res = true;
    }
  else if (in_errno == ENOENT)
    res = true;
  else
    {
      fileattr = FILE_ATTRIBUTE_NORMAL;
      res = false;
    }
  return res;
}

bool
symlink_info::parse_device (const char *contents)
{
  char *endptr;
  _major_t mymajor;
  _major_t myminor;
  _mode_t mymode;

  mymajor = strtol (contents += 2, &endptr, 16);
  if (endptr == contents)
    return isdevice = false;

  contents = endptr;
  myminor = strtol (++contents, &endptr, 16);
  if (endptr == contents)
    return isdevice = false;

  contents = endptr;
  mymode = strtol (++contents, &endptr, 16);
  if (endptr == contents)
    return isdevice = false;

  if ((mymode & S_IFMT) == S_IFIFO)
    {
      mymajor = _major (FH_FIFO);
      myminor = _minor (FH_FIFO);
    }

  major = mymajor;
  minor = myminor;
  mode = mymode;
  return isdevice = true;
}

/* Check if PATH is a symlink.  PATH must be a valid Win32 path name.

   If PATH is a symlink, put the value of the symlink--the file to
   which it points--into BUF.  The value stored in BUF is not
   necessarily null terminated.  BUFLEN is the length of BUF; only up
   to BUFLEN characters will be stored in BUF.  BUF may be NULL, in
   which case nothing will be stored.

   Set *SYML if PATH is a symlink.

   Set *EXEC if PATH appears to be executable.  This is an efficiency
   hack because we sometimes have to open the file anyhow.  *EXEC will
   not be set for every executable file.

   Return -1 on error, 0 if PATH is not a symlink, or the length
   stored into BUF if PATH is a symlink.  */

int
symlink_info::check (char *path, const suffix_info *suffixes, fs_info &fs,
		     path_conv_handle &conv_hdl)
{
  int res;
  HANDLE h;
  NTSTATUS status;
  UNICODE_STRING upath;
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;
  suffix_scan suffix;

  const ULONG ci_flag = cygwin_shared->obcaseinsensitive
			|| (pflags & PATH_NOPOSIX) ? OBJ_CASE_INSENSITIVE : 0;
  /* TODO: Temporarily do all char->UNICODE conversion here.  This should
     already be slightly faster than using Ascii functions. */
  tmp_pathbuf tp;
  tp.u_get (&upath);
  InitializeObjectAttributes (&attr, &upath, ci_flag, NULL, NULL);

  /* This label is used in case we encounter a FS which only handles
     DOS paths.  See below. */
  bool restarted = false;
restart:

  h = NULL;
  res = 0;
  contents[0] = '\0';
  issymlink = true;
  isdevice = false;
  major = 0;
  minor = 0;
  mode = 0;
  pflags &= ~(PATH_SYMLINK | PATH_LNK | PATH_REP);

  PVOID eabuf = &nfs_aol_ffei;
  ULONG easize = sizeof nfs_aol_ffei;

  ext_here = suffix.has (path, suffixes);
  extn = ext_here - path;
  bool had_ext = !!*ext_here;

  /* If the filename is too long, don't even try. */
  if (suffix.name_len () > NAME_MAX)
    {
      set_error (ENAMETOOLONG);
      goto file_not_symlink;
    }

  while (suffix.next ())
    {
      error = 0;
      get_nt_native_path (suffix.path, upath, pflags & PATH_DOS);
      if (h)
	{
	  NtClose (h);
	  h = NULL;
	}
      /* The EA given to NtCreateFile allows to get a handle to a symlink on
	 an NFS share, rather than getting a handle to the target of the
	 symlink (which would spoil the task of this method quite a bit).
	 Fortunately it's ignored on most other file systems so we don't have
	 to special case NFS too much. */
      status = NtCreateFile (&h,
			     READ_CONTROL | FILE_READ_ATTRIBUTES | FILE_READ_EA,
			     &attr, &io, NULL, 0, FILE_SHARE_VALID_FLAGS,
			     FILE_OPEN,
			     FILE_OPEN_REPARSE_POINT
			     | FILE_OPEN_FOR_BACKUP_INTENT,
			     eabuf, easize);
      debug_printf ("%y = NtCreateFile (%S)", status, &upath);
      /* No right to access EAs or EAs not supported? */
      if (!NT_SUCCESS (status)
	  && (status == STATUS_ACCESS_DENIED
	      || status == STATUS_EAS_NOT_SUPPORTED
	      || status == STATUS_NOT_SUPPORTED
	      || status == STATUS_INVALID_NETWORK_RESPONSE
	      /* Or a bug in Samba 3.2.x (x <= 7) when accessing a share's
		 root dir which has EAs enabled? */
	      || status == STATUS_INVALID_PARAMETER))
	{
	  /* If EAs are not supported, there's no sense to check them again
	     with suffixes attached.  So we set eabuf/easize to 0 here once. */
	  if (status == STATUS_EAS_NOT_SUPPORTED
	      || status == STATUS_NOT_SUPPORTED)
	    {
	      eabuf = NULL;
	      easize = 0;
	    }
	  status = NtOpenFile (&h, READ_CONTROL | FILE_READ_ATTRIBUTES,
			       &attr, &io, FILE_SHARE_VALID_FLAGS,
			       FILE_OPEN_REPARSE_POINT
			       | FILE_OPEN_FOR_BACKUP_INTENT);
	  debug_printf ("%y = NtOpenFile (no-EAs %S)", status, &upath);
	}
      if (status == STATUS_OBJECT_NAME_NOT_FOUND)
	{
	  if (ci_flag == 0 && wincap.has_broken_udf ()
	      && (!fs.inited () || fs.is_udf ()))
	    {
	      /* On NT 5.x UDF is broken (at least) in terms of case
		 sensitivity.  When trying to open a file case sensitive,
		 the file appears to be non-existant.  Another bug is
		 described in fs_info::update. */
	      attr.Attributes = OBJ_CASE_INSENSITIVE;
	      status = NtOpenFile (&h, READ_CONTROL | FILE_READ_ATTRIBUTES,
				   &attr, &io, FILE_SHARE_VALID_FLAGS,
				   FILE_OPEN_REPARSE_POINT
				   | FILE_OPEN_FOR_BACKUP_INTENT);
	      debug_printf ("%y = NtOpenFile (broken-UDF, %S)", status, &upath);
	      attr.Attributes = 0;
	      if (NT_SUCCESS (status))
		{
		  if (!fs.inited ())
		    fs.update (&upath, h);
		  if (!fs.is_udf ())
		    {
		      NtClose (h);
		      h = NULL;
		      status = STATUS_OBJECT_NAME_NOT_FOUND;
		    }
		}
	    }
	  /* There are filesystems out in the wild (Netapp, NWFS, and others)
	     which are uncapable of generating pathnames outside the Win32
	     rules.  That means, filenames on these FSes must not have a
	     leading space or trailing dots and spaces.  This code snippet
	     manages them.  I really hope it's streamlined enough not to
	     slow down normal operation.  This extra check only kicks in if
	     we encountered a STATUS_OBJECT_NAME_NOT_FOUND *and* we didn't
	     already attach a suffix *and* the above special case for UDF
	     on XP didn't succeeed. */
	  if (!restarted && !*ext_here && !(pflags & PATH_DOS) && !fs.inited ())
	    {
	      /* Check for trailing dot or space or leading space in
		 last component. */
	      char *p = ext_here - 1;
	      if (*p != '.' && *p != ' ')
		{
		  while (*--p != '\\')
		    ;
		  if (*++p != ' ')
		    p = NULL;
		}
	      if (p)
		{
		  /* If so, check if file resides on one of the known broken
		     FSes only supporting filenames following DOS rules. */
		  if (!fs.inited ())
		    fs.update (&upath, NULL);
		  if (fs.has_dos_filenames_only ())
		    {
		      /* If so, try again.  Since we now know the FS, the
			 filenames will be tweaked to follow DOS rules via the
			 third parameter in the call to get_nt_native_path. */
		      pflags |= PATH_DOS;
		      restarted = true;
		      goto restart;
		    }
		}
	    }
	}
      else if (status == STATUS_NETWORK_OPEN_RESTRICTION
	       || status == STATUS_SYMLINK_CLASS_DISABLED)
	{
	  /* These status codes are returned if you try to open a native
	     symlink and the usage of this kind of symlink is forbidden
	     (see fsutil).  Since we can't open them at all, not even for
	     stat purposes, we have to return a POSIX error code which is
	     at least a bit helpful.

	     Additionally Windows 8 introduces a bug in NFS: If you have
	     a symlink to a directory, with symlinks underneath, resolving
	     the second level of symlinks fails if remote->remote symlinks
	     are disabled in fsutil.  Unfortunately that's the default. */
	  set_error (ELOOP);
	  break;
	}

      if (NT_SUCCESS (status)
	  /* Check file system while we're having the file open anyway.
	     This speeds up path_conv noticably (~10%). */
	  && (fs.inited () || fs.update (&upath, h)))
	{
	  if (fs.is_nfs ())
	    {
	      status = nfs_fetch_fattr3 (h, conv_hdl.nfsattr ());
	      if (NT_SUCCESS (status))
		fileattr = ((conv_hdl.nfsattr ()->type & 7) == NF3DIR)
			    ? FILE_ATTRIBUTE_DIRECTORY : 0;
	    }
	  else
	    {
	      status = file_get_fnoi (h, fs.is_netapp (), conv_hdl.fnoi ());
	      if (NT_SUCCESS (status))
		fileattr = conv_hdl.fnoi ()->FileAttributes;
	    }
	}
      if (!NT_SUCCESS (status))
	{
	  debug_printf ("%y = NtQueryInformationFile (%S)", status, &upath);
	  fileattr = INVALID_FILE_ATTRIBUTES;

	  /* One of the inner path components is invalid, or the path contains
	     invalid characters.  Bail out with ENOENT.

	     Note that additional STATUS_OBJECT_PATH_INVALID and
	     STATUS_OBJECT_PATH_SYNTAX_BAD status codes exist.  The first one
	     is seemingly not generated by NtQueryInformationFile, the latter
	     is only generated if the path is no absolute path within the
	     NT name space, which should not happen and would point to an
	     error in get_nt_native_path.  Both status codes are deliberately
	     not tested here unless proved necessary. */
	  if (status == STATUS_OBJECT_PATH_NOT_FOUND
	      || status == STATUS_OBJECT_NAME_INVALID
	      || status == STATUS_BAD_NETWORK_PATH
	      || status == STATUS_BAD_NETWORK_NAME
	      || status == STATUS_NO_MEDIA_IN_DEVICE)
	    {
	      set_error (ENOENT);
	      goto file_not_symlink;
	    }
	  if (status != STATUS_OBJECT_NAME_NOT_FOUND
	      && status != STATUS_NO_SUCH_FILE) /* ENOENT on NFS or 9x share */
	    {
	      /* The file exists, but the user can't access it for one reason
		 or the other.  To get the file attributes we try to access the
		 information by opening the parent directory and getting the
		 file attributes using a matching NtQueryDirectoryFile call. */
	      UNICODE_STRING dirname, basename;
	      OBJECT_ATTRIBUTES dattr;
	      HANDLE dir;
	      struct {
		FILE_BOTH_DIR_INFORMATION fdi;
		WCHAR dummy_buf[NAME_MAX + 1];
	      } fdi_buf;

	      RtlSplitUnicodePath (&upath, &dirname, &basename);
	      InitializeObjectAttributes (&dattr, &dirname, ci_flag,
					  NULL, NULL);
	      status = NtOpenFile (&dir, SYNCHRONIZE | FILE_LIST_DIRECTORY,
				   &dattr, &io, FILE_SHARE_VALID_FLAGS,
				   FILE_SYNCHRONOUS_IO_NONALERT
				   | FILE_OPEN_FOR_BACKUP_INTENT
				   | FILE_DIRECTORY_FILE);
	      if (!NT_SUCCESS (status))
		{
		  debug_printf ("%y = NtOpenFile(%S)", status, &dirname);
		  /* There's a special case if the file is itself the root
		     of a drive which is not accessible by the current user.
		     This case is only recognized by the length of the
		     basename part.  If it's 0, the incoming file is the
		     root of a drive.  So we at least know it's a directory. */
		  if (basename.Length)
		    fileattr = FILE_ATTRIBUTE_DIRECTORY;
		  else
		    {
		      fileattr = 0;
		      set_error (geterrno_from_nt_status (status));
		    }
		}
	      else
		{
		  status = NtQueryDirectoryFile (dir, NULL, NULL, NULL, &io,
						 &fdi_buf, sizeof fdi_buf,
						 FileBothDirectoryInformation,
						 TRUE, &basename, TRUE);
		  /* Take the opportunity to check file system while we're
		     having the handle to the parent dir. */
		  fs.update (&upath, dir);
		  NtClose (dir);
		  if (!NT_SUCCESS (status))
		    {
		      debug_printf ("%y = NtQueryDirectoryFile(%S)",
				    status, &dirname);
		      if (status == STATUS_NO_SUCH_FILE)
			{
			  /* This can happen when trying to access files
			     which match DOS device names on SMB shares.
			     NtOpenFile failed with STATUS_ACCESS_DENIED,
			     but the NtQueryDirectoryFile tells us the
			     file doesn't exist.  We're suspicious in this
			     case and retry with the next suffix instead of
			     just giving up. */
			  set_error (ENOENT);
			  continue;
			}
		      fileattr = 0;
		    }
		  else
		    {
		      PFILE_NETWORK_OPEN_INFORMATION pfnoi = conv_hdl.fnoi ();

		      fileattr = fdi_buf.fdi.FileAttributes;
		      memcpy (pfnoi, &fdi_buf.fdi.CreationTime, sizeof *pfnoi);
		      /* Amazing, but true:  The FILE_NETWORK_OPEN_INFORMATION
			 structure has the AllocationSize and EndOfFile members
			 interchanged relative to the directory information
			 classes. */
		      pfnoi->AllocationSize.QuadPart
			= fdi_buf.fdi.AllocationSize.QuadPart;
		      pfnoi->EndOfFile.QuadPart
			= fdi_buf.fdi.EndOfFile.QuadPart;
		    }
		}
	      ext_tacked_on = !!*ext_here;
	      goto file_not_symlink;
	    }
	  set_error (ENOENT);
	  continue;
	}

      ext_tacked_on = !!*ext_here;
      /* Don't allow to returns directories with appended suffix.  If we found
	 a directory with a suffix which has been appended here, then this
	 directory doesn't match the request.  So, just do as usual if file
	 hasn't been found. */
      if (ext_tacked_on && !had_ext && (fileattr & FILE_ATTRIBUTE_DIRECTORY))
	{
	  set_error (ENOENT);
	  continue;
	}

      res = -1;

      /* Reparse points are potentially symlinks.  This check must be
	 performed before checking the SYSTEM attribute for sysfile
	 symlinks, since reparse points can have this flag set, too.
	 For instance, Vista starts to create a couple of reparse points
	 with SYSTEM and HIDDEN flags set. */
      if ((fileattr & FILE_ATTRIBUTE_REPARSE_POINT))
	{
	  res = check_reparse_point (h, fs.is_remote_drive ());
	  if (res > 0)
	    {
	      /* A symlink is never a directory. */
	      conv_hdl.fnoi ()->FileAttributes &= ~FILE_ATTRIBUTE_DIRECTORY;
	      break;
	    }
	  else
	    {
	      /* Volume moint point or unrecognized reparse point type.
		 Make sure the open handle is not used in later stat calls.
		 The handle has been opened with the FILE_OPEN_REPARSE_POINT
		 flag, so it's a handle to the reparse point, not a handle
		 to the volumes root dir. */
	      pflags &= ~PC_KEEP_HANDLE;
	      /* Volume mount point:  The filesystem information for the top
		 level directory should be for the volume top level directory,
		 rather than for the reparse point itself.  So we fetch the
		 filesystem information again, but with a NULL handle.
		 This does what we want because fs_info::update opens the
		 handle without FILE_OPEN_REPARSE_POINT. */
	      if (res == -1)
		fs.update (&upath, NULL);
	    }
	}

      /* Windows shortcuts are potentially treated as symlinks.  Valid Cygwin
	 & U/WIN shortcuts are R/O, but definitely not directories. */
      else if ((fileattr & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_DIRECTORY))
	  == FILE_ATTRIBUTE_READONLY && suffix.lnk_match ())
	{
	  HANDLE sym_h;

	  status = NtOpenFile (&sym_h, SYNCHRONIZE | GENERIC_READ, &attr, &io,
			       FILE_SHARE_VALID_FLAGS,
			       FILE_OPEN_FOR_BACKUP_INTENT
			       | FILE_SYNCHRONOUS_IO_NONALERT);
	  if (!NT_SUCCESS (status))
	    res = 0;
	  else
	    {
	      res = check_shortcut (sym_h);
	      NtClose (sym_h);
	    }
	  if (!res)
	    {
	      /* If searching for `foo' and then finding a `foo.lnk' which
		 is no shortcut, return the same as if file not found. */
	      if (ext_tacked_on)
		{
		  fileattr = INVALID_FILE_ATTRIBUTES;
		  set_error (ENOENT);
		  continue;
		}
	    }
	  else if (contents[0] != ':' || contents[1] != '\\'
		   || !parse_device (contents))
	    break;
	}

      /* If searching for `foo' and then finding a `foo.lnk' which is
	 no shortcut, return the same as if file not found. */
      else if (suffix.lnk_match () && ext_tacked_on)
	{
	  fileattr = INVALID_FILE_ATTRIBUTES;
	  set_error (ENOENT);
	  continue;
	}

      /* This is the old Cygwin method creating symlinks.  A symlink will
	 have the `system' file attribute.  Only files can be symlinks
	 (which can be symlinks to directories). */
      else if ((fileattr & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY))
	       == FILE_ATTRIBUTE_SYSTEM)
	{
	  HANDLE sym_h;

	  status = NtOpenFile (&sym_h, SYNCHRONIZE | GENERIC_READ, &attr, &io,
			       FILE_SHARE_VALID_FLAGS,
			       FILE_OPEN_FOR_BACKUP_INTENT
			       | FILE_SYNCHRONOUS_IO_NONALERT);

	  if (!NT_SUCCESS (status))
	    res = 0;
	  else
	    {
	      res = check_sysfile (sym_h);
	      NtClose (sym_h);
	    }
	  if (res)
	    break;
	}

      /* If the file is on an NFS share and could be opened with extended
	 attributes, check if it's a symlink.  Only files can be symlinks
	 (which can be symlinks to directories). */
      else if (fs.is_nfs () && (conv_hdl.nfsattr ()->type & 7) == NF3LNK)
	{
	  res = check_nfs_symlink (h);
	  if (res)
	    break;
	}

    /* Normal file. */
    file_not_symlink:
      issymlink = false;
      syscall_printf ("%s", isdevice ? "is a device" : "not a symlink");
      res = 0;
      break;
    }

  if (h)
    {
      if (pflags & PC_KEEP_HANDLE)
	conv_hdl.set (h);
      else
	NtClose (h);
    }

  syscall_printf ("%d = symlink.check(%s, %p) (%y)",
		  res, suffix.path, contents, pflags);
  return res;
}

/* "path" is the path in a virtual symlink.  Set a symlink_info struct from
   that and proceed with further path checking afterwards. */
int
symlink_info::set (char *path)
{
  strcpy (contents, path);
  pflags = PATH_SYMLINK;
  fileattr = FILE_ATTRIBUTE_NORMAL;
  error = 0;
  issymlink = true;
  isdevice = false;
  ext_tacked_on = false;
  ext_here = NULL;
  extn = major = minor = mode = 0;
  return strlen (path);
}

/* readlink system call */

extern "C" ssize_t
readlink (const char *__restrict path, char *__restrict buf, size_t buflen)
{
  if (buflen < 0)
    {
      set_errno (ENAMETOOLONG);
      return -1;
    }

  path_conv pathbuf (path, PC_SYM_CONTENTS, stat_suffixes);

  if (pathbuf.error)
    {
      set_errno (pathbuf.error);
      syscall_printf ("-1 = readlink (%s, %p, %lu)", path, buf, buflen);
      return -1;
    }

  if (!pathbuf.exists ())
    {
      set_errno (ENOENT);
      return -1;
    }

  if (!pathbuf.issymlink ())
    {
      if (pathbuf.exists ())
	set_errno (EINVAL);
      return -1;
    }

  size_t pathbuf_len = strlen (pathbuf.get_win32 ());
  ssize_t len = MIN (buflen, pathbuf_len);
  memcpy (buf, pathbuf.get_win32 (), len);

  /* errno set by symlink.check if error */
  return len;
}

/* Some programs rely on st_dev/st_ino being unique for each file.
   Hash the path name and hope for the best.  The hash arg is not
   always initialized to zero since readdir needs to compute the
   dirent ino_t based on a combination of the hash of the directory
   done during the opendir call and the hash or the filename within
   the directory.  FIXME: Not bullet-proof. */
/* Cygwin internal */
ino_t __reg2
hash_path_name (ino_t hash, PUNICODE_STRING name)
{
  if (name->Length == 0)
    return hash;

  /* Build up hash. Name is already normalized */
  USHORT len = name->Length / sizeof (WCHAR);
  for (USHORT idx = 0; idx < len; ++idx)
    hash = RtlUpcaseUnicodeChar (name->Buffer[idx])
	   + (hash << 6) + (hash << 16) - hash;
  return hash;
}

ino_t __reg2
hash_path_name (ino_t hash, PCWSTR name)
{
  UNICODE_STRING uname;
  RtlInitUnicodeString (&uname, name);
  return hash_path_name (hash, &uname);
}

ino_t __reg2
hash_path_name (ino_t hash, const char *name)
{
  UNICODE_STRING uname;
  RtlCreateUnicodeStringFromAsciiz (&uname, name);
  ino_t ret = hash_path_name (hash, &uname);
  RtlFreeUnicodeString (&uname);
  return ret;
}

extern "C" char *
getcwd (char *buf, size_t ulen)
{
  char* res = NULL;

  __try
    {
      if (ulen == 0 && buf)
	set_errno (EINVAL);
      else
	res = cygheap->cwd.get (buf, 1, 1, ulen);
    }
  __except (EFAULT) {}
  __endtry
  return res;
}

/* getwd: Legacy. */
extern "C" char *
getwd (char *buf)
{
  return getcwd (buf, PATH_MAX + 1);  /*Per SuSv3!*/
}

extern "C" char *
get_current_dir_name (void)
{
  const char *pwd = getenv ("PWD");
  char *cwd = getcwd (NULL, 0);
  struct stat pwdbuf, cwdbuf;

  if (pwd && strcmp (pwd, cwd) != 0
      && stat64 (pwd, &pwdbuf) == 0
      && stat64 (cwd, &cwdbuf) == 0
      && pwdbuf.st_dev == cwdbuf.st_dev
      && pwdbuf.st_ino == cwdbuf.st_ino)
    {
      cwd = (char *) realloc (cwd, strlen (pwd) + 1);
      strcpy (cwd, pwd);
    }

  return cwd;
}

/* chdir: POSIX 5.2.1.1 */
extern "C" int
chdir (const char *in_dir)
{
  int res = -1;

  __try
    {
      if (!*in_dir)
	{
	  set_errno (ENOENT);
	  __leave;
	}

      syscall_printf ("dir '%s'", in_dir);

      /* Convert path.  First argument ensures that we don't check for
      	 NULL/empty/invalid again. */
      path_conv path (PC_NONULLEMPTY, in_dir, PC_SYM_FOLLOW | PC_POSIX);
      if (path.error)
	{
	  set_errno (path.error);
	  syscall_printf ("-1 = chdir (%s)", in_dir);
	  __leave;
	}

      const char *posix_cwd = NULL;
      dev_t devn = path.get_device ();
      if (!path.exists ())
	set_errno (ENOENT);
      else if (!path.isdir ())
	set_errno (ENOTDIR);
      else if (!isvirtual_dev (devn))
	{
	  /* The sequence chdir("xx"); chdir(".."); must be a noop if xx
	     is not a symlink. This is exploited by find.exe.
	     The posix_cwd is just path.get_posix ().
	     In other cases we let cwd.set obtain the Posix path through
	     the mount table. */
	  if (!isdrive (path.get_posix ()))
	    posix_cwd = path.get_posix ();
	  res = 0;
	}
      else
       {
	 posix_cwd = path.get_posix ();
	 res = 0;
       }

      if (!res)
	res = cygheap->cwd.set (&path, posix_cwd);

      /* Note that we're accessing cwd.posix without a lock here.
	 I didn't think it was worth locking just for strace. */
      syscall_printf ("%R = chdir() cygheap->cwd.posix '%s' native '%S'", res,
		      cygheap->cwd.get_posix (), path.get_nt_native_path ());
    }
  __except (EFAULT)
    {
      res = -1;
    }
  __endtry
  MALLOC_CHECK;
  return res;
}

extern "C" int
fchdir (int fd)
{
  int res;
  cygheap_fdget cfd (fd);
  if (cfd >= 0)
    res = chdir (cfd->get_name ());
  else
    res = -1;

  syscall_printf ("%R = fchdir(%d)", res, fd);
  return res;
}

/******************** Exported Path Routines *********************/

/* Cover functions to the path conversion routines.
   These are exported to the world as cygwin_foo by cygwin.din.  */

#define return_with_errno(x) \
  do {\
    int err = (x);\
    if (!err)\
     return 0;\
    set_errno (err);\
    return -1;\
  } while (0)

extern "C" ssize_t
cygwin_conv_path (cygwin_conv_path_t what, const void *from, void *to,
		  size_t size)
{
  tmp_pathbuf tp;
  path_conv p;
  size_t lsiz = 0;
  char *buf = NULL;
  PWCHAR path = NULL;
  int error = 0;
  bool relative = !!(what & CCP_RELATIVE);
  what &= CCP_CONVTYPE_MASK;
  int ret = -1;

  __try
    {
      if (!from)
	{
	  set_errno (EINVAL);
	  __leave;
	}

      switch (what)
	{
	case CCP_POSIX_TO_WIN_A:
	  {
	    p.check ((const char *) from,
		     PC_POSIX | PC_SYM_FOLLOW | PC_SYM_NOFOLLOW_REP
		     | PC_NO_ACCESS_CHECK | PC_NOWARN | (relative ? PC_NOFULL : 0));
	    if (p.error)
	      {
	        set_errno (p.error);
		__leave;
	      }
	    PUNICODE_STRING up = p.get_nt_native_path ();
	    buf = tp.c_get ();
	    sys_wcstombs (buf, NT_MAX_PATH,
			  up->Buffer, up->Length / sizeof (WCHAR));
	    /* Convert native path to standard DOS path. */
	    if (!strncmp (buf, "\\??\\", 4))
	      {
		buf += 4;
		if (buf[1] != ':') /* native UNC path */
		  *(buf += 2) = '\\';
	      }
	    else if (*buf == '\\')
	      {
		/* Device name points to somewhere else in the NT namespace.
		   Use GLOBALROOT prefix to convert to Win32 path. */
		char *p = buf + sys_wcstombs (buf, NT_MAX_PATH,
					      ro_u_globalroot.Buffer,
					      ro_u_globalroot.Length
					      / sizeof (WCHAR));
		sys_wcstombs (p, NT_MAX_PATH - (p - buf),
			      up->Buffer, up->Length / sizeof (WCHAR));
	      }
	    lsiz = strlen (buf) + 1;
	    /* TODO: Incoming "." is a special case which leads to a trailing
	       backslash ".\\" in the Win32 path.  That's a result of the
	       conversion in normalize_posix_path.  This should not occur
	       so the below code is just a band-aid. */
	    if (relative && !strcmp ((const char *) from, ".")
		&& !strcmp (buf, ".\\"))
	      {
		lsiz = 2;
		buf[1] = '\0';
	      }
	  }
	  break;
	case CCP_POSIX_TO_WIN_W:
	  p.check ((const char *) from,
		   PC_POSIX | PC_SYM_FOLLOW | PC_SYM_NOFOLLOW_REP
		   | PC_NO_ACCESS_CHECK | PC_NOWARN | (relative ? PC_NOFULL : 0));
	  if (p.error)
	    {
	      set_errno (p.error);
	      __leave;
	    }
	  /* Relative Windows paths are always restricted to MAX_PATH chars. */
	  if (relative && !isabspath (p.get_win32 ())
	      && sys_mbstowcs (NULL, 0, p.get_win32 ()) > MAX_PATH)
	    {
	      /* Recreate as absolute path. */
	      p.check ((const char *) from, PC_POSIX | PC_SYM_FOLLOW
					    | PC_NO_ACCESS_CHECK | PC_NOWARN);
	      if (p.error)
		{
		  set_errno (p.error);
		  __leave;
		}
	    }
	  lsiz = p.get_wide_win32_path_len () + 1;
	  path = p.get_nt_native_path ()->Buffer;

	  /* Convert native path to standard DOS path. */
	  if (!wcsncmp (path, L"\\??\\", 4))
	    {
	      path[1] = L'\\';

	      /* Drop long path prefix for short pathnames.  Unfortunately there's
		 quite a bunch of Win32 functions, especially in user32.dll,
		 apparently, which don't grok long path names at all, not even
		 in the UNICODE API. */
	      if ((path[5] == L':' && lsiz <= MAX_PATH + 4)
		  || (!wcsncmp (path + 4, L"UNC\\", 4) && lsiz <= MAX_PATH + 6))
		{
		  path += 4;
		  lsiz -= 4;
		  if (path[1] != L':')
		    {
		      *(path += 2) = '\\';
		      lsiz -= 2;
		    }
		}
	    }
	  else if (*path == L'\\')
	    {
	      /* Device name points to somewhere else in the NT namespace.
		 Use GLOBALROOT prefix to convert to Win32 path. */
	      to = (void *) wcpcpy ((wchar_t *) to, ro_u_globalroot.Buffer);
	      lsiz += ro_u_globalroot.Length / sizeof (WCHAR);
	    }
	  /* TODO: Same ".\\" band-aid as in CCP_POSIX_TO_WIN_A case. */
	  if (relative && !strcmp ((const char *) from, ".")
	      && !wcscmp (path, L".\\"))
	    {
	      lsiz = 2;
	      path[1] = L'\0';
	    }
	  lsiz *= sizeof (WCHAR);
	  break;
	case CCP_WIN_A_TO_POSIX:
	  buf = tp.c_get ();
	  error = mount_table->conv_to_posix_path ((const char *) from, buf,
						   relative);
	  if (error)
	    {
	      set_errno (p.error);
	      __leave;
	    }
	  lsiz = strlen (buf) + 1;
	  break;
	case CCP_WIN_W_TO_POSIX:
	  buf = tp.c_get ();
	  error = mount_table->conv_to_posix_path ((const PWCHAR) from, buf,
						   relative);
	  if (error)
	    {
	      set_errno (error);
	      __leave;
	    }
	  lsiz = strlen (buf) + 1;
	  break;
	default:
	  set_errno (EINVAL);
	  __leave;
	}
      if (!size)
	{
	  ret = lsiz;
	  __leave;
	}
      if (size < lsiz)
	{
	  set_errno (ENOSPC);
	  __leave;
	}
      switch (what)
	{
	case CCP_POSIX_TO_WIN_A:
	case CCP_WIN_A_TO_POSIX:
	case CCP_WIN_W_TO_POSIX:
	  stpcpy ((char *) to, buf);
	  break;
	case CCP_POSIX_TO_WIN_W:
	  wcpcpy ((PWCHAR) to, path);
	  break;
	}
      ret = 0;
    }
  __except (EFAULT) {}
  __endtry
  return ret;
}

extern "C" void *
cygwin_create_path (cygwin_conv_path_t what, const void *from)
{
  void *to;
  ssize_t size = cygwin_conv_path (what, from, NULL, 0);
  if (size <= 0)
    to = NULL;
  else if (!(to = malloc (size)))
    to = NULL;
  if (cygwin_conv_path (what, from, to, size) == -1)
    {
      free (to);
      to = NULL;
    }
  return to;
}

#ifndef __x86_64__	/* Disable deprecated functions on x86_64. */

extern "C" int
cygwin_conv_to_win32_path (const char *path, char *win32_path)
{
  return cygwin_conv_path (CCP_POSIX_TO_WIN_A | CCP_RELATIVE, path, win32_path,
			   MAX_PATH);
}

extern "C" int
cygwin_conv_to_full_win32_path (const char *path, char *win32_path)
{
  return cygwin_conv_path (CCP_POSIX_TO_WIN_A | CCP_ABSOLUTE, path, win32_path,
			   MAX_PATH);
}

/* This is exported to the world as cygwin_foo by cygwin.din.  */

extern "C" int
cygwin_conv_to_posix_path (const char *path, char *posix_path)
{
  return cygwin_conv_path (CCP_WIN_A_TO_POSIX | CCP_RELATIVE, path, posix_path,
			   MAX_PATH);
}

extern "C" int
cygwin_conv_to_full_posix_path (const char *path, char *posix_path)
{
  return cygwin_conv_path (CCP_WIN_A_TO_POSIX | CCP_ABSOLUTE, path, posix_path,
			   MAX_PATH);
}

#endif /* !__x86_64__ */

/* The realpath function is required by POSIX:2008.  */

extern "C" char *
realpath (const char *__restrict path, char *__restrict resolved)
{
  tmp_pathbuf tp;
  char *tpath;

  /* Make sure the right errno is returned if path is NULL. */
  if (!path)
    {
      set_errno (EINVAL);
      return NULL;
    }

  /* Guard reading from a potentially invalid path and writing to a
     potentially invalid resolved. */
  __try
    {
      /* Win32 drive letter paths have to be converted to a POSIX path first,
	 because path_conv leaves the incoming path untouched except for
	 converting backslashes to forward slashes. */
      if (isdrive (path))
	{
	  tpath = tp.c_get ();
	  mount_table->conv_to_posix_path (path, tpath, 0);
	}
      else
	tpath = (char *) path;

      path_conv real_path (tpath, PC_SYM_FOLLOW | PC_POSIX, stat_suffixes);


      /* POSIX 2008 requires malloc'ing if resolved is NULL, and states
	 that using non-NULL resolved is asking for portability
	 problems.  */

      if (!real_path.error && real_path.exists ())
	{
	  if (!resolved)
	    {
	      resolved = (char *)
			 malloc (strlen (real_path.get_posix ()) + 1);
	      if (!resolved)
		return NULL;
	    }
	  strcpy (resolved, real_path.get_posix ());
	  return resolved;
	}

      /* FIXME: on error, Linux puts the name of the path
	 component which could not be resolved into RESOLVED, but POSIX
	 does not require this.  */
      if (resolved)
	resolved[0] = '\0';
      set_errno (real_path.error ?: ENOENT);
    }
  __except (EFAULT) {}
  __endtry
  return NULL;
}

/* Linux provides this extension.  Since the only portable use of
   realpath requires a NULL second argument, we might as well have a
   one-argument wrapper.  */
extern "C" char *
canonicalize_file_name (const char *path)
{
  return realpath (path, NULL);
}

/* Return non-zero if path is a POSIX path list.
   This is exported to the world as cygwin_foo by cygwin.din.

DOCTOOL-START
<sect1 id="add-func-cygwin-posix-path-list-p">
  <para>Rather than use a mode to say what the "proper" path list
  format is, we allow any, and give apps the tools they need to
  convert between the two.  If a ';' is present in the path list it's
  a Win32 path list.  Otherwise, if the first path begins with
  [letter]: (in which case it can be the only element since if it
  wasn't a ';' would be present) it's a Win32 path list.  Otherwise,
  it's a POSIX path list.</para>
</sect1>
DOCTOOL-END
  */

extern "C" int
cygwin_posix_path_list_p (const char *path)
{
  int posix_p = !(strchr (path, ';') || isdrive (path));
  return posix_p;
}

/* These are used for apps that need to convert env vars like PATH back and
   forth.  The conversion is a two step process.  First, an upper bound on the
   size of the buffer needed is computed.  Then the conversion is done.  This
   allows the caller to use alloca if it wants.  */

static int
conv_path_list_buf_size (const char *path_list, bool to_posix)
{
  int i, num_elms, max_mount_path_len, size;
  const char *p;

  path_conv pc(".", PC_POSIX);
  /* The theory is that an upper bound is
     current_size + (num_elms * max_mount_path_len)  */
  /* FIXME: This method is questionable in the long run. */

  unsigned nrel;
  char delim = to_posix ? ';' : ':';
  for (p = path_list, num_elms = nrel = 0; p; num_elms++)
    {
      if (!isabspath (p))
	nrel++;
      p = strchr (++p, delim);
    }

  /* 7: strlen ("//c") + slop, a conservative initial value */
  for (max_mount_path_len = sizeof ("/cygdrive/X"), i = 0;
       i < mount_table->nmounts; i++)
    {
      int mount_len = (to_posix
		       ? mount_table->mount[i].posix_pathlen
		       : mount_table->mount[i].native_pathlen);
      if (max_mount_path_len < mount_len)
	max_mount_path_len = mount_len;
    }

  /* 100: slop */
  size = strlen (path_list)
    + (num_elms * max_mount_path_len)
    + (nrel * strlen (to_posix ? pc.get_posix () : pc.get_win32 ()))
    + 100;

  return size;
}

extern "C" ssize_t
env_PATH_to_posix (const void *win32, void *posix, size_t size)
{
  return_with_errno (conv_path_list ((const char *) win32, (char *) posix,
				     size, ENV_CVT));
}

#ifndef __x86_64__	/* Disable deprecated functions on x86_64. */

extern "C" int
cygwin_win32_to_posix_path_list_buf_size (const char *path_list)
{
  return conv_path_list_buf_size (path_list, true);
}

extern "C" int
cygwin_posix_to_win32_path_list_buf_size (const char *path_list)
{
  return conv_path_list_buf_size (path_list, false);
}

extern "C" int
cygwin_win32_to_posix_path_list (const char *win32, char *posix)
{
  return_with_errno (conv_path_list (win32, posix, MAX_PATH,
		     CCP_WIN_A_TO_POSIX | CCP_RELATIVE));
}

extern "C" int
cygwin_posix_to_win32_path_list (const char *posix, char *win32)
{
  return_with_errno (conv_path_list (posix, win32, MAX_PATH,
		     CCP_POSIX_TO_WIN_A | CCP_RELATIVE));
}

#endif /* !__x86_64__ */

extern "C" ssize_t
cygwin_conv_path_list (cygwin_conv_path_t what, const void *from, void *to,
		       size_t size)
{
  int ret;
  char *winp = NULL;
  void *orig_to = NULL;
  tmp_pathbuf tp;

  switch (what & CCP_CONVTYPE_MASK)
    {
    case CCP_WIN_W_TO_POSIX:
      if (!sys_wcstombs_alloc (&winp, HEAP_NOTHEAP, (const wchar_t *) from,
			       (size_t) -1))
	return -1;
      what = (what & ~CCP_CONVTYPE_MASK) | CCP_WIN_A_TO_POSIX;
      from = (const void *) winp;
      break;
    case CCP_POSIX_TO_WIN_W:
      if (size == 0)
	return conv_path_list_buf_size ((const char *) from, 0)
	       * sizeof (WCHAR);
      what = (what & ~CCP_CONVTYPE_MASK) | CCP_POSIX_TO_WIN_A;
      orig_to = to;
      to = (void *) tp.w_get ();
      size = 65536;
      break;
    }
  switch (what & CCP_CONVTYPE_MASK)
    {
    case CCP_WIN_A_TO_POSIX:
    case CCP_POSIX_TO_WIN_A:
      if (size == 0)
	return conv_path_list_buf_size ((const char *) from,
					what == CCP_WIN_A_TO_POSIX);
      ret = conv_path_list ((const char *) from, (char *) to, size, what);
      /* Free winp buffer in case of CCP_WIN_W_TO_POSIX. */
      if (winp)
      	free (winp);
      /* Convert to WCHAR in case of CCP_POSIX_TO_WIN_W. */
      if (orig_to)
	sys_mbstowcs ((wchar_t *) orig_to, size / sizeof (WCHAR),
		      (const char *) to, (size_t) -1);
      return_with_errno (ret);
      break;
    default:
      break;
    }
  set_errno (EINVAL);
  return -1;
}

/* cygwin_split_path: Split a path into directory and file name parts.
   Buffers DIR and FILE are assumed to be big enough.

   Examples (path -> `dir' / `file'):
   / -> `/' / `'
   "" -> `.' / `'
   . -> `.' / `.' (FIXME: should this be `.' / `'?)
   .. -> `.' / `..' (FIXME: should this be `..' / `'?)
   foo -> `.' / `foo'
   foo/bar -> `foo' / `bar'
   foo/bar/ -> `foo' / `bar'
   /foo -> `/' / `foo'
   /foo/bar -> `/foo' / `bar'
   c: -> `c:/' / `'
   c:/ -> `c:/' / `'
   c:foo -> `c:/' / `foo'
   c:/foo -> `c:/' / `foo'
 */

extern "C" void
cygwin_split_path (const char *path, char *dir, char *file)
{
  int dir_started_p = 0;

  /* Deal with drives.
     Remember that c:foo <==> c:/foo.  */
  if (isdrive (path))
    {
      *dir++ = *path++;
      *dir++ = *path++;
      *dir++ = '/';
      if (!*path)
	{
	  *dir = 0;
	  *file = 0;
	  return;
	}
      if (isdirsep (*path))
	++path;
      dir_started_p = 1;
    }

  /* Determine if there are trailing slashes and "delete" them if present.
     We pretend as if they don't exist.  */
  const char *end = path + strlen (path);
  /* path + 1: keep leading slash.  */
  while (end > path + 1 && isdirsep (end[-1]))
    --end;

  /* At this point, END points to one beyond the last character
     (with trailing slashes "deleted").  */

  /* Point LAST_SLASH at the last slash (duh...).  */
  const char *last_slash;
  for (last_slash = end - 1; last_slash >= path; --last_slash)
    if (isdirsep (*last_slash))
      break;

  if (last_slash == path)
    {
      *dir++ = '/';
      *dir = 0;
    }
  else if (last_slash > path)
    {
      memcpy (dir, path, last_slash - path);
      dir[last_slash - path] = 0;
    }
  else
    {
      if (dir_started_p)
	; /* nothing to do */
      else
	*dir++ = '.';
      *dir = 0;
    }

  memcpy (file, last_slash + 1, end - last_slash - 1);
  file[end - last_slash - 1] = 0;
}

static inline void
copy_cwd_str (PUNICODE_STRING tgt, PUNICODE_STRING src)
{
  RtlCopyUnicodeString (tgt, src);
  if (tgt->Buffer[tgt->Length / sizeof (WCHAR) - 1] != L'\\')
    {
      tgt->Buffer[tgt->Length / sizeof (WCHAR)] = L'\\';
      tgt->Length += sizeof (WCHAR);
    }
}

/*****************************************************************************/

/* The find_fast_cwd_pointer function and parts of the
   cwdstuff::override_win32_cwd method are based on code using the
   following license:

   Copyright 2010 John Carey. All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

      1. Redistributions of source code must retain the above
      copyright notice, this list of conditions and the following
      disclaimer.

      2. Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

   THIS SOFTWARE IS PROVIDED BY JOHN CAREY ``AS IS'' AND ANY EXPRESS
   OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   ARE DISCLAIMED. IN NO EVENT SHALL JOHN CAREY OR CONTRIBUTORS BE
   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
   OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
   BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   DAMAGE. */

void
fcwd_access_t::SetFSCharacteristics (LONG val)
{
  /* Special case FSCharacteristics.  Didn't exist originally. */
  switch (fast_cwd_version ())
    {
    case FCWD_OLD:
      break;
    case FCWD_W7:
      f7.FSCharacteristics = val;
      break;
    case FCWD_W8:
      f8.FSCharacteristics = val;
      break;
    }
}

fcwd_version_t &
fcwd_access_t::fast_cwd_version ()
{
  return cygheap->cwd.fast_cwd_version;
}

void
fcwd_access_t::CopyPath (UNICODE_STRING &target)
{
  /* Copy the Path contents over into the UNICODE_STRING referenced by
     target.  This is used to set the CurrentDirectoryName in the
     user parameter block. */
  target = Path ();
}

void
fcwd_access_t::Free (PVOID heap)
{
  /* Decrement the reference count.  If it's down to 0, free
     structure from heap. */
  if (this && InterlockedDecrement (&ReferenceCount ()) == 0)
    {
      /* In contrast to pre-Vista, the handle on init is always a
	 fresh one and not the handle inherited from the parent
	 process.  So we always have to close it here.  However, the
	 handle could be NULL, if we cd'ed into a virtual dir. */
      HANDLE h = DirectoryHandle ();
      if (h)
	NtClose (h);
      RtlFreeHeap (heap, 0, this);
    }
}

void
fcwd_access_t::FillIn (HANDLE dir, PUNICODE_STRING name,
			ULONG old_dismount_count)
{
  /* Fill in all values into this FAST_CWD structure. */
  DirectoryHandle () = dir;
  ReferenceCount () = 1;
  OldDismountCount () = old_dismount_count;
  /* The new structure stores the device characteristics of the
     volume holding the dir.  RtlGetCurrentDirectory_U checks
     if the FILE_REMOVABLE_MEDIA flag is set and, if so, checks if
     the volume is still the same as the one used when opening
     the directory handle.
     We don't call NtQueryVolumeInformationFile for the \\?\PIPE,
     though.  It just returns STATUS_INVALID_HANDLE anyway. */
  if (fast_cwd_version () != FCWD_OLD)
    {
      SetFSCharacteristics (0);
      if (name != &ro_u_pipedir)
	{
	  IO_STATUS_BLOCK io;
	  FILE_FS_DEVICE_INFORMATION ffdi;
	  if (NT_SUCCESS (NtQueryVolumeInformationFile (dir, &io, &ffdi,
			  sizeof ffdi, FileFsDeviceInformation)))
	    SetFSCharacteristics (ffdi.Characteristics);
	}
    }
  RtlInitEmptyUnicodeString (&Path (), Buffer (),
			     MAX_PATH * sizeof (WCHAR));
  copy_cwd_str (&Path (), name);
}

void
fcwd_access_t::SetDirHandleFromBufferPointer (PWCHAR buf_p, HANDLE dir)
{
  /* Input: The buffer pointer as it's stored in the user parameter block
     and a directory handle.
     This function computes the address to the FAST_CWD structure based
     on the version and overwrites the directory handle.  It is only
     used if we couldn't figure out the address of fast_cwd_ptr. */
  fcwd_access_t *f_cwd;
  switch (fast_cwd_version ())
    {
    case FCWD_OLD:
    default:
      f_cwd = (fcwd_access_t *)
	((PBYTE) buf_p - __builtin_offsetof (FAST_CWD_OLD, Buffer));
    case FCWD_W7:
      f_cwd = (fcwd_access_t *)
	((PBYTE) buf_p - __builtin_offsetof (FAST_CWD_7, Buffer));
    case FCWD_W8:
      f_cwd = (fcwd_access_t *)
	((PBYTE) buf_p - __builtin_offsetof (FAST_CWD_8, Buffer));
    }
  f_cwd->DirectoryHandle () = dir;
}

void
fcwd_access_t::SetVersionFromPointer (PBYTE buf_p, bool is_buffer)
{
  /* Given a pointer to the FAST_CWD structure (is_buffer == false) or a
     pointer to the Buffer within (is_buffer == true), this function
     computes the FAST_CWD version by checking that Path.MaximumLength
     equals MAX_PATH, and that Path.Buffer == Buffer. */
  if (is_buffer)
    buf_p -= __builtin_offsetof (FAST_CWD_8, Buffer);
  fcwd_access_t *f_cwd = (fcwd_access_t *) buf_p;
  if (f_cwd->f8.Path.MaximumLength == MAX_PATH * sizeof (WCHAR)
      && f_cwd->f8.Path.Buffer == f_cwd->f8.Buffer)
    fast_cwd_version () = FCWD_W8;
  else if (f_cwd->f7.Path.MaximumLength == MAX_PATH * sizeof (WCHAR)
	   && f_cwd->f7.Path.Buffer == f_cwd->f7.Buffer)
    fast_cwd_version () = FCWD_W7;
  else
    fast_cwd_version () = FCWD_OLD;
}

/* This function scans the code in ntdll.dll to find the address of the
   global variable used to access the CWD starting with Vista.  While the
   pointer is global, it's not exported from the DLL, unfortunately.
   Therefore we have to use some knowledge to figure out the address.

   This code has been tested on Vista 32/64 bit, Server 2008 32/64 bit,
   Windows 7 32/64 bit, Server 2008 R2 (which is only 64 bit anyway),
   Windows 8 32/64 bit, Windows 8.1 32/64 bit, and Server 2012 R2. */

#ifdef __x86_64__

#define peek32(x)	(*(int32_t *)(x))

static fcwd_access_t **
find_fast_cwd_pointer ()
{
  /* Fetch entry points of relevant functions in ntdll.dll. */
  HMODULE ntdll = GetModuleHandle ("ntdll.dll");
  if (!ntdll)
    return NULL;
  const uint8_t *get_dir = (const uint8_t *)
			   GetProcAddress (ntdll, "RtlGetCurrentDirectory_U");
  const uint8_t *ent_crit = (const uint8_t *)
			    GetProcAddress (ntdll, "RtlEnterCriticalSection");
  if (!get_dir || !ent_crit)
    return NULL;
  /* Search first relative call instruction in RtlGetCurrentDirectory_U. */
  const uint8_t *rcall = (const uint8_t *) memchr (get_dir, 0xe8, 40);
  if (!rcall)
    return NULL;
  /* Fetch offset from instruction and compute address of called function.
     This function actually fetches the current FAST_CWD instance and
     performs some other actions, not important to us. */
  const uint8_t *use_cwd = rcall + 5 + peek32 (rcall + 1);
  /* Next we search for the locking mechanism and perform a sanity check.
     On Pre-Windows 8 we basically look for the RtlEnterCriticalSection call.
     Windows 8 does not call RtlEnterCriticalSection.  The code manipulates
     the FastPebLock manually, probably because RtlEnterCriticalSection has
     been converted to an inline function.  Either way, we test if the code
     uses the FastPebLock. */
  const uint8_t *movrbx;
  const uint8_t *lock = (const uint8_t *)
                        memmem ((const char *) use_cwd, 80,
                                "\xf0\x0f\xba\x35", 4);
  if (lock)
    {
      /* The lock instruction tweaks the LockCount member, which is not at
      	 the start of the PRTL_CRITICAL_SECTION structure.  So we have to
	 subtract the offset of LockCount to get the real address. */
      PRTL_CRITICAL_SECTION lockaddr =
        (PRTL_CRITICAL_SECTION) (lock + 9 + peek32 (lock + 4)
                                 - offsetof (RTL_CRITICAL_SECTION, LockCount));
      /* Test if lock address is FastPebLock. */
      if (lockaddr != NtCurrentTeb ()->Peb->FastPebLock)
        return NULL;
      /* Search `mov rel(%rip),%rbx'.  This is the instruction fetching the
         address of the current fcwd_access_t pointer, and it should be pretty
	 near to the locking stuff. */
      movrbx = (const uint8_t *) memmem ((const char *) lock, 40,
                                         "\x48\x8b\x1d", 3);
    }
  else
    {
      /* Usually the callq RtlEnterCriticalSection follows right after
	 fetching the lock address. */
      int call_rtl_offset = 7;
      /* Search `lea rel(%rip),%rcx'.  This loads the address of the lock into
         %rcx for the subsequent RtlEnterCriticalSection call. */
      lock = (const uint8_t *) memmem ((const char *) use_cwd, 80,
                                       "\x48\x8d\x0d", 3);
      if (!lock)
	{
	  /* Windows 8.1 Preview calls `lea rel(rip),%r12' then some unrelated
	     or, then `mov %r12,%rcx', then `callq RtlEnterCriticalSection'. */
	  lock = (const uint8_t *) memmem ((const char *) use_cwd, 80,
					   "\x4c\x8d\x25", 3);
	  if (!lock)
	    return NULL;
	  call_rtl_offset = 14;
	}
      PRTL_CRITICAL_SECTION lockaddr =
        (PRTL_CRITICAL_SECTION) (lock + 7 + peek32 (lock + 3));
      /* Test if lock address is FastPebLock. */
      if (lockaddr != NtCurrentTeb ()->Peb->FastPebLock)
        return NULL;
      /* Next is the `callq RtlEnterCriticalSection'. */
      lock += call_rtl_offset;
      if (lock[0] != 0xe8)
        return NULL;
      const uint8_t *call_addr = (const uint8_t *)
                                 (lock + 5 + peek32 (lock + 1));
      if (call_addr != ent_crit)
        return NULL;
      /* In contrast to the above Windows 8 code, we don't have to search
	 for the `mov rel(%rip),%rbx' instruction.  It follows right after
	 the call to RtlEnterCriticalSection. */
      movrbx = lock + 5;
    }
  if (!movrbx)
    return NULL;
  /* Check that the next instruction tests if the fetched value is NULL. */
  const uint8_t *testrbx = (const uint8_t *)
			   memmem (movrbx + 7, 3, "\x48\x85\xdb", 3);
  if (!testrbx)
    return NULL;
  /* Compute address of the fcwd_access_t ** pointer. */
  return (fcwd_access_t **) (testrbx + peek32 (movrbx + 3));
}
#else

#define peek32(x)	(*(uint32_t *)(x))

static fcwd_access_t **
find_fast_cwd_pointer ()
{
  /* Fetch entry points of relevant functions in ntdll.dll. */
  HMODULE ntdll = GetModuleHandle ("ntdll.dll");
  if (!ntdll)
    return NULL;
  const uint8_t *get_dir = (const uint8_t *)
			   GetProcAddress (ntdll, "RtlGetCurrentDirectory_U");
  const uint8_t *ent_crit = (const uint8_t *)
			    GetProcAddress (ntdll, "RtlEnterCriticalSection");
  if (!get_dir || !ent_crit)
    return NULL;
  /* Search first relative call instruction in RtlGetCurrentDirectory_U. */
  const uint8_t *rcall = (const uint8_t *) memchr (get_dir, 0xe8, 32);
  if (!rcall)
    return NULL;
  /* Fetch offset from instruction and compute address of called function.
     This function actually fetches the current FAST_CWD instance and
     performs some other actions, not important to us. */
  ptrdiff_t offset = (ptrdiff_t) peek32 (rcall + 1);
  const uint8_t *use_cwd = rcall + 5 + offset;
  /* Find first `push %edi' instruction. */
  const uint8_t *pushedi = (const uint8_t *) memchr (use_cwd, 0x57, 32);
  /* ...which should be followed by `mov crit-sect-addr,%edi' then
     `push %edi', or by just a single `push crit-sect-addr'. */
  const uint8_t *movedi = pushedi + 1;
  const uint8_t *mov_pfast_cwd;
  if (movedi[0] == 0x8b && movedi[1] == 0xff)	/* mov %edi,%edi -> W8 */
    {
      /* Windows 8 does not call RtlEnterCriticalSection.  The code manipulates
      	 the FastPebLock manually, probably because RtlEnterCriticalSection has
	 been converted to an inline function.

	 Next we search for a `mov some address,%eax'.  This address points
	 to the LockCount member of the FastPebLock structure, so the address
	 is equal to FastPebLock + 4. */
      const uint8_t *moveax = (const uint8_t *) memchr (movedi, 0xb8, 16);
      if (!moveax)
	return NULL;
      offset = (ptrdiff_t) peek32 (moveax + 1) - 4;
      /* Compare the address with the known PEB lock as stored in the PEB. */
      if ((PRTL_CRITICAL_SECTION) offset != NtCurrentTeb ()->Peb->FastPebLock)
	return NULL;
      /* Now search for the mov instruction fetching the address of the global
	 PFAST_CWD *. */
      mov_pfast_cwd = moveax;
      do
	{
	  mov_pfast_cwd = (const uint8_t *) memchr (++mov_pfast_cwd, 0x8b, 48);
	}
      while (mov_pfast_cwd && mov_pfast_cwd[1] != 0x1d
	     && (mov_pfast_cwd - moveax) < 48);
      if (!mov_pfast_cwd || mov_pfast_cwd[1] != 0x1d)
	return NULL;
    }
  else
    {
      if (movedi[0] == 0xbf && movedi[5] == 0x57)
	rcall = movedi + 6;
      else if (movedi[0] == 0x68)
	rcall = movedi + 5;
      else if (movedi[0] == 0x88 && movedi[4] == 0x83 && movedi[7] == 0x68)
	{
	  /* Windows 8.1 Preview: The `mov lock_addr,%edi' is actually a
	     `mov %cl,15(%esp), followed by an `or #-1,%ebx, followed by a
	     `push lock_addr'. */
	  movedi += 7;
	  rcall = movedi + 5;
	}
      else
	return NULL;
      /* Compare the address used for the critical section with the known
	 PEB lock as stored in the PEB. */
      if ((PRTL_CRITICAL_SECTION) peek32 (movedi + 1)
	  != NtCurrentTeb ()->Peb->FastPebLock)
	return NULL;
      /* To check we are seeing the right code, we check our expectation that
	 the next instruction is a relative call into RtlEnterCriticalSection. */
      if (rcall[0] != 0xe8)
	return NULL;
      /* Check that this is a relative call to RtlEnterCriticalSection. */
      offset = (ptrdiff_t) peek32 (rcall + 1);
      if (rcall + 5 + offset != ent_crit)
	return NULL;
      mov_pfast_cwd = rcall + 5;
    }
  /* After locking the critical section, the code should read the global
     PFAST_CWD * pointer that is guarded by that critical section. */
  if (mov_pfast_cwd[0] != 0x8b)
    return NULL;
  return (fcwd_access_t **) peek32 (mov_pfast_cwd + 2);
}
#endif

static fcwd_access_t **
find_fast_cwd ()
{
  /* Fetch the pointer but don't set the global fast_cwd_ptr yet.  First
     we have to make sure we know the version of the FAST_CWD structure
     used on the system. */
  fcwd_access_t **f_cwd_ptr = find_fast_cwd_pointer ();
  if (!f_cwd_ptr)
    small_printf ("Cygwin WARNING:\n"
"  Couldn't compute FAST_CWD pointer.  This typically occurs if you're using\n"
"  an older Cygwin version on a newer Windows.  Please update to the latest\n"
"  available Cygwin version from https://cygwin.com/.  If the problem persists,\n"
"  please see https://cygwin.com/problems.html\n\n");
  if (f_cwd_ptr && *f_cwd_ptr)
    {
      /* Just evaluate structure version. */
      fcwd_access_t::SetVersionFromPointer ((PBYTE) *f_cwd_ptr, false);
    }
  else
    {
      /* If we couldn't fetch fast_cwd_ptr, or if fast_cwd_ptr is NULL(*)
	 we have to figure out the version from the Buffer pointer in the
	 ProcessParameters.

	 (*) This is very unlikely to happen when starting the first
	 Cygwin process, since it only happens when starting the
	 process in a directory which can't be used as CWD by Win32, or
	 if the directory doesn't exist.  But *if* it happens, we have
	 no valid FAST_CWD structure, even though upp_cwd_str.Buffer is
	 not NULL in that case.  So we let the OS create a valid
	 FAST_CWD structure temporarily to have something to work with.
	 We know the pipe FS works. */
      PEB &peb = *NtCurrentTeb ()->Peb;

      if (f_cwd_ptr	/* so *f_cwd_ptr == NULL */
	  && !NT_SUCCESS (RtlSetCurrentDirectory_U (&ro_u_pipedir)))
	api_fatal ("Couldn't set directory to %S temporarily.\n"
		   "Cannot continue.", &ro_u_pipedir);
      RtlEnterCriticalSection (peb.FastPebLock);
      fcwd_access_t::SetVersionFromPointer
	((PBYTE) peb.ProcessParameters->CurrentDirectoryName.Buffer, true);
      RtlLeaveCriticalSection (peb.FastPebLock);
    }
  /* Eventually, after we set the version as well, set fast_cwd_ptr. */
  return f_cwd_ptr;
}

void
cwdstuff::override_win32_cwd (bool init, ULONG old_dismount_count)
{
  HANDLE h = NULL;

  PEB &peb = *NtCurrentTeb ()->Peb;
  UNICODE_STRING &upp_cwd_str = peb.ProcessParameters->CurrentDirectoryName;
  HANDLE &upp_cwd_hdl = peb.ProcessParameters->CurrentDirectoryHandle;

  if (wincap.has_fast_cwd ())
    {
      if (fast_cwd_ptr == (fcwd_access_t **) -1)
	fast_cwd_ptr = find_fast_cwd ();
      if (fast_cwd_ptr)
	{
	  /* Default method starting with Vista.  If we got a valid value for
	     fast_cwd_ptr, we can simply replace the RtlSetCurrentDirectory_U
	     function entirely, just as on pre-Vista. */
	  PVOID heap = peb.ProcessHeap;
	  /* First allocate a new fcwd_access_t structure on the heap.
	     The new fcwd_access_t structure is 4 byte bigger than the old one,
	     but we simply don't care, so we allocate always room for the
	     new one. */
	  fcwd_access_t *f_cwd = (fcwd_access_t *)
			    RtlAllocateHeap (heap, 0, sizeof (fcwd_access_t));
	  if (!f_cwd)
	    {
	      debug_printf ("RtlAllocateHeap failed");
	      return;
	    }
	  /* Fill in the values. */
	  f_cwd->FillIn (dir, error ? &ro_u_pipedir : &win32,
			 old_dismount_count);
	  /* Use PEB lock when switching fast_cwd_ptr to the new FAST_CWD
	     structure and writing the CWD to the user process parameter
	     block.  This is equivalent to calling RtlAcquirePebLock/
	     RtlReleasePebLock, but without having to go through the FS
	     selector again. */
	  RtlEnterCriticalSection (peb.FastPebLock);
	  fcwd_access_t *old_cwd = *fast_cwd_ptr;
	  *fast_cwd_ptr = f_cwd;
	  f_cwd->CopyPath (upp_cwd_str);
	  upp_cwd_hdl = dir;
	  RtlLeaveCriticalSection (peb.FastPebLock);
	  old_cwd->Free (heap);
	}
      else
	{
	  /* This is more a hack, and it's only used on Vista and later if we
	     failed to find the fast_cwd_ptr value.  What we do here is to call
	     RtlSetCurrentDirectory_U and let it set up a new FAST_CWD
	     structure.  Afterwards, compute the address of that structure
	     utilizing the fact that the buffer address in the user process
	     parameter block is actually pointing to the buffer in that
	     FAST_CWD structure.  Then replace the directory handle in that
	     structure with our own handle and close the original one.

	     Note that the call to RtlSetCurrentDirectory_U also closes our
	     old dir handle, so there won't be any handle left open.

	     This method is prone to two race conditions:

	     - Due to the way RtlSetCurrentDirectory_U opens the directory
	       handle, the directory is locked against deletion or renaming
	       between the RtlSetCurrentDirectory_U and the subsequent NtClose
	       call.

	     - When another thread calls SetCurrentDirectory at exactly the
	       same time, a crash might occur, or worse, unrelated data could
	       be overwritten or NtClose could be called on an unrelated handle.

	     Therefore, use this *only* as a fallback. */
	  if (!init)
	    {
	      NTSTATUS status =
		RtlSetCurrentDirectory_U (error ? &ro_u_pipedir : &win32);
	      if (!NT_SUCCESS (status))
		{
		  debug_printf ("RtlSetCurrentDirectory_U(%S) failed, %y",
				error ? &ro_u_pipedir : &win32, status);
		  return;
		}
	    }
	  else if (upp_cwd_hdl == NULL)
	    return;
	  RtlEnterCriticalSection (peb.FastPebLock);
	  fcwd_access_t::SetDirHandleFromBufferPointer(upp_cwd_str.Buffer, dir);
	  h = upp_cwd_hdl;
	  upp_cwd_hdl = dir;
	  RtlLeaveCriticalSection (peb.FastPebLock);
	  /* In contrast to pre-Vista, the handle on init is always a fresh one
	     and not the handle inherited from the parent process.  So we always
	     have to close it here. */
	  NtClose (h);
	}
    }
  else
    {
      /* This method is used for all pre-Vista OSes.  We simply set the values
	 for the CWD in the user process parameter block entirely by ourselves
	 under PEB lock condition.  This is how RtlSetCurrentDirectory_U worked
	 in these older OSes, so we're safe.

	 Note that we can't just RtlEnterCriticalSection (peb.FastPebLock)
	 on pre-Vista.  RtlAcquirePebLock was way more complicated back then. */
      RtlAcquirePebLock ();
      if (!init)
	copy_cwd_str (&upp_cwd_str, error ? &ro_u_pipedir : &win32);
      h = upp_cwd_hdl;
      upp_cwd_hdl = dir;
      RtlReleasePebLock ();
      /* Only on init, the handle is potentially a native handle.  However,
	 if it's identical to dir, it's the inherited handle from a Cygwin
	 parent process and must not be closed. */
      if (h && h != dir)
	NtClose (h);
    }
}

/* Initialize cygcwd 'muto' for serializing access to cwd info. */
void
cwdstuff::init ()
{
  cwd_lock.init ("cwd_lock");

  /* Cygwin processes inherit the cwd from their parent.  If the win32 path
     buffer is not NULL, the cwd struct is already set up, and we only
     have to override the Win32 CWD with ours. */
  if (win32.Buffer)
    override_win32_cwd (true, SharedUserData.DismountCount);
  else
    {
      /* Initialize fast_cwd stuff. */
      fast_cwd_ptr = (fcwd_access_t **) -1;
      fast_cwd_version = FCWD_W7;
      /* Initially re-open the cwd to allow POSIX semantics. */
      set (NULL, NULL);
    }
}

/* Chdir and fill out the elements of a cwdstuff struct. */
int
cwdstuff::set (path_conv *nat_cwd, const char *posix_cwd)
{
  NTSTATUS status;
  UNICODE_STRING upath;
  PEB &peb = *NtCurrentTeb ()->Peb;
  bool virtual_path = false;
  bool unc_path = false;
  bool inaccessible_path = false;

  /* Here are the problems with using SetCurrentDirectory.  Just skip this
     comment if you don't like whining.

     - SetCurrentDirectory only supports paths of up to MAX_PATH - 1 chars,
       including a trailing backslash.  That's an absolute restriction, even
       in the UNICODE API.

     - SetCurrentDirectory fails for directories with strict permissions even
       for processes with the SE_BACKUP_NAME privilege enabled.  The reason
       is apparently that SetCurrentDirectory calls NtOpenFile without the
       FILE_OPEN_FOR_BACKUP_INTENT flag set.

     - SetCurrentDirectory does not support case-sensitivity.

     - Unlinking a cwd fails because SetCurrentDirectory seems to open
       directories so that deleting the directory is disallowed.

     - SetCurrentDirectory can naturally not work on virtual Cygwin paths
       like /proc or /cygdrive.

     Unfortunately, even though we have access to the Win32 process parameter
     block, we can't just replace the directory handle.  Starting with Vista,
     the handle is used elsewhere, and just replacing the handle in the process
     parameter block shows quite surprising results.
     FIXME: If we ever find a *safe* way to replace the directory handle in
     the process parameter block, we're back in business.

     Nevertheless, doing entirely without SetCurrentDirectory is not really
     feasible, because it breaks too many mixed applications using the Win32
     API.

     Therefore we handle the CWD all by ourselves and just keep the Win32
     CWD in sync.  However, to avoid surprising behaviour in the Win32 API
     when we are in a CWD which is inaccessible as Win32 CWD, we set the
     Win32 CWD to a "weird" directory in which all relative filesystem-related
     calls fail. */

  cwd_lock.acquire ();

  if (nat_cwd)
    {
      upath = *nat_cwd->get_nt_native_path ();
      if (nat_cwd->isspecial ())
	virtual_path = true;
    }

  /* Memorize old DismountCount before opening the dir.  This value is
     stored in the FAST_CWD structure on Vista and later.  It would be
     simpler to fetch the old DismountCount in override_win32_cwd, but
     Windows also fetches it before opening the directory handle.  It's
     not quite clear if that's really required, but since we don't know
     the side effects of this action, we better follow Windows' lead. */
  ULONG old_dismount_count = SharedUserData.DismountCount;
  /* Open a directory handle with FILE_OPEN_FOR_BACKUP_INTENT and with all
     sharing flags set.  The handle is right now used in exceptions.cc only,
     but that might change in future. */
  HANDLE h = NULL;
  if (!virtual_path)
    {
      IO_STATUS_BLOCK io;
      OBJECT_ATTRIBUTES attr;

      if (!nat_cwd)
	{
	  /* On init, just reopen Win32 CWD with desired access flags.
	     We can access the PEB without lock, because no other thread
	     can change the CWD. */
	  RtlInitUnicodeString (&upath, L"");
	  InitializeObjectAttributes (&attr, &upath,
			OBJ_CASE_INSENSITIVE | OBJ_INHERIT,
			peb.ProcessParameters->CurrentDirectoryHandle, NULL);
	}
      else
	InitializeObjectAttributes (&attr, &upath,
			nat_cwd->objcaseinsensitive () | OBJ_INHERIT,
			NULL, NULL);
      /* First try without FILE_OPEN_FOR_BACKUP_INTENT, to find out if the
	 directory is valid for Win32 apps.  And, no, we can't just call
	 SetCurrentDirectory here, since that would potentially break
	 case-sensitivity. */
      status = NtOpenFile (&h, SYNCHRONIZE | FILE_TRAVERSE, &attr, &io,
			   FILE_SHARE_VALID_FLAGS,
			   FILE_DIRECTORY_FILE
			   | FILE_SYNCHRONOUS_IO_NONALERT);
      if (status == STATUS_ACCESS_DENIED)
	{
	  status = NtOpenFile (&h, SYNCHRONIZE | FILE_TRAVERSE, &attr, &io,
			       FILE_SHARE_VALID_FLAGS,
			       FILE_DIRECTORY_FILE
			       | FILE_SYNCHRONOUS_IO_NONALERT
			       | FILE_OPEN_FOR_BACKUP_INTENT);
	  inaccessible_path = true;
	}
      if (!NT_SUCCESS (status))
	{
	  cwd_lock.release ();
	  __seterrno_from_nt_status (status);
	  return -1;
	}
    }
  /* Set new handle.  Note that we simply overwrite the old handle here
     without closing it.  The handle is also used as Win32 CWD handle in
     the user parameter block, and it will be closed in override_win32_cwd,
     if required. */
  dir = h;

  if (!nat_cwd)
    {
      /* On init, just fetch the Win32 dir from the PEB.  We can access
	 the PEB without lock, because no other thread can change the CWD
	 at that time. */
      PUNICODE_STRING pdir = &peb.ProcessParameters->CurrentDirectoryName;
      RtlInitEmptyUnicodeString (&win32,
				 (PWCHAR) crealloc_abort (win32.Buffer,
							  pdir->Length
							  + sizeof (WCHAR)),
				 pdir->Length + sizeof (WCHAR));
      RtlCopyUnicodeString (&win32, pdir);

      PWSTR eoBuffer = win32.Buffer + (win32.Length / sizeof (WCHAR));
      /* Remove trailing slash if one exists. */
      if ((eoBuffer - win32.Buffer) > 3 && eoBuffer[-1] == L'\\')
	win32.Length -= sizeof (WCHAR);
      if (eoBuffer[0] == L'\\')
	unc_path = true;

      posix_cwd = NULL;
    }
  else
    {
      if (!virtual_path) /* don't mangle virtual path. */
	{
	  /* Convert into Win32 path and compute length. */
	  if (upath.Buffer[1] == L'?')
	    {
	      upath.Buffer += 4;
	      upath.Length -= 4 * sizeof (WCHAR);
	      if (upath.Buffer[1] != L':')
		{
		  /* UNC path */
		  upath.Buffer += 2;
		  upath.Length -= 2 * sizeof (WCHAR);
		  unc_path = true;
		}
	    }
	  else
	    {
	      /* Path via native NT namespace.  Prepend GLOBALROOT prefix
		 to create a valid Win32 path. */
	      PWCHAR buf = (PWCHAR) alloca (upath.Length
					    + ro_u_globalroot.Length
					    + sizeof (WCHAR));
	      wcpcpy (wcpcpy (buf, ro_u_globalroot.Buffer), upath.Buffer);
	      upath.Buffer = buf;
	      upath.Length += ro_u_globalroot.Length;
	    }
	  PWSTR eoBuffer = upath.Buffer + (upath.Length / sizeof (WCHAR));
	  /* Remove trailing slash if one exists. */
	  if ((eoBuffer - upath.Buffer) > 3 && eoBuffer[-1] == L'\\')
	    upath.Length -= sizeof (WCHAR);
	}
      RtlInitEmptyUnicodeString (&win32,
				 (PWCHAR) crealloc_abort (win32.Buffer,
							  upath.Length
							  + sizeof (WCHAR)),
				 upath.Length + sizeof (WCHAR));
      RtlCopyUnicodeString (&win32, &upath);
      if (unc_path)
	win32.Buffer[0] = L'\\';
    }
  /* Make sure it's NUL-terminated. */
  win32.Buffer[win32.Length / sizeof (WCHAR)] = L'\0';

  /* Set drive_length, used in path conversion, and error code, used in
     spawn_guts to decide whether a native Win32 app can be started or not. */
  if (virtual_path)
    {
      drive_length = 0;
      error = ENOTDIR;
    }
  else
    {
      if (!unc_path)
	drive_length = 2;
      else
	{
	  PWCHAR ptr = wcschr (win32.Buffer + 2, L'\\');
	  if (ptr)
	    ptr = wcschr (ptr + 1, L'\\');
	  if (ptr)
	    drive_length = ptr - win32.Buffer;
	  else
	    drive_length = win32.Length / sizeof (WCHAR);
	}
      if (inaccessible_path)
	error = EACCES;
      else if (win32.Length > (MAX_PATH - 2) * sizeof (WCHAR))
	error = ENAMETOOLONG;
      else
	error = 0;
    }
  /* Keep the Win32 CWD in sync.  Don't check for error, other than for
     strace output.  Try to keep overhead low. */
  override_win32_cwd (!nat_cwd, old_dismount_count);

  /* Eventually, create POSIX path if it's not set on entry. */
  tmp_pathbuf tp;
  if (!posix_cwd)
    {
      posix_cwd = (const char *) tp.c_get ();
      mount_table->conv_to_posix_path (win32.Buffer, (char *) posix_cwd, 0);
    }
  posix = (char *) crealloc_abort (posix, strlen (posix_cwd) + 1);
  stpcpy (posix, posix_cwd);

  cwd_lock.release ();
  return 0;
}

const char *
cwdstuff::get_error_desc () const
{
  switch (cygheap->cwd.get_error ())
    {
    case EACCES:
      return "has restricted permissions which render it\n"
	     "inaccessible as Win32 working directory";
    case ENOTDIR:
      return "is a virtual Cygwin directory which does\n"
	     "not exist for a native Windows application";
    case ENAMETOOLONG:
      return "has a path longer than allowed for a\n"
	     "Win32 working directory";
    default:
      break;
    }
  /* That shouldn't occur, unless we defined a new error code
     in cwdstuff::set. */
  return "is not accessible for some unknown reason";
}

/* Store incoming wchar_t path as current posix cwd.  This is called from
   setlocale so that the cwd is always stored in the right charset. */
void
cwdstuff::reset_posix (wchar_t *w_cwd)
{
  size_t len = sys_wcstombs (NULL, (size_t) -1, w_cwd);
  posix = (char *) crealloc_abort (posix, len + 1);
  sys_wcstombs (posix, len + 1, w_cwd);
}

char *
cwdstuff::get (char *buf, int need_posix, int with_chroot, unsigned ulen)
{
  MALLOC_CHECK;

  tmp_pathbuf tp;
  if (ulen)
    /* nothing */;
  else if (buf == NULL)
    ulen = (unsigned) -1;
  else
    {
      set_errno (EINVAL);
      goto out;
    }

  cwd_lock.acquire ();

  char *tocopy;
  if (!need_posix)
    {
      tocopy = tp.c_get ();
      sys_wcstombs (tocopy, NT_MAX_PATH, win32.Buffer,
		    win32.Length / sizeof (WCHAR));
    }
  else
    tocopy = posix;

  debug_printf ("posix %s", posix);
  if (strlen (tocopy) >= ulen)
    {
      set_errno (ERANGE);
      buf = NULL;
    }
  else
    {
      if (!buf)
	buf = (char *) malloc (strlen (tocopy) + 1);
      strcpy (buf, tocopy);
      if (!buf[0])	/* Should only happen when chroot */
	strcpy (buf, "/");
    }

  cwd_lock.release ();

out:
  syscall_printf ("(%s) = cwdstuff::get (%p, %u, %d, %d), errno %d",
		  buf, buf, ulen, need_posix, with_chroot, errno);
  MALLOC_CHECK;
  return buf;
}

/* No need to be reentrant or thread-safe according to SUSv3.
   / and \\ are treated equally.  Leading drive specifiers are
   kept intact as far as it makes sense.  Everything else is
   POSIX compatible. */
extern "C" char *
basename (char *path)
{
  static char buf[4];
  char *c, *d, *bs = path;

  if (!path || !*path)
    return strcpy (buf, ".");
  if (isalpha (path[0]) && path[1] == ':')
    bs += 2;
  else if (strspn (path, "/\\") > 1)
    ++bs;
  c = strrchr (bs, '/');
  if ((d = strrchr (c ?: bs, '\\')) > c)
    c = d;
  if (c)
    {
      /* Trailing (back)slashes are eliminated. */
      while (c && c > bs && c[1] == '\0')
	{
	  *c = '\0';
	  c = strrchr (bs, '/');
	  if ((d = strrchr (c ?: bs, '\\')) > c)
	    c = d;
	}
      if (c && (c > bs || c[1]))
	return c + 1;
    }
  else if (!bs[0])
    {
      stpncpy (buf, path, bs - path);
      stpcpy (buf + (bs - path), ".");
      return buf;
    }
  return path;
}

/* No need to be reentrant or thread-safe according to SUSv3.
   / and \\ are treated equally.  Leading drive specifiers and
   leading double (back)slashes are kept intact as far as it
   makes sense.  Everything else is POSIX compatible. */
extern "C" char *
dirname (char *path)
{
  static char buf[4];
  char *c, *d, *bs = path;

  if (!path || !*path)
    return strcpy (buf, ".");
  if (isalpha (path[0]) && path[1] == ':')
    bs += 2;
  else if (strspn (path, "/\\") > 1)
    ++bs;
  c = strrchr (bs, '/');
  if ((d = strrchr (c ?: bs, '\\')) > c)
    c = d;
  if (c)
    {
      /* Trailing (back)slashes are eliminated. */
      while (c && c > bs && c[1] == '\0')
	{
	  *c = '\0';
	  c = strrchr (bs, '/');
	  if ((d = strrchr (c ?: bs, '\\')) > c)
	    c = d;
	}
      if (!c)
	strcpy (bs, ".");
      else if (c > bs)
	{
	  /* More trailing (back)slashes are eliminated. */
	  while (c > bs && (*c == '/' || *c == '\\'))
	    *c-- = '\0';
	}
      else
	c[1] = '\0';
    }
  else
    {
      stpncpy (buf, path, bs - path);
      stpcpy (buf + (bs - path), ".");
      return buf;
    }
  return path;
}
@


1.697
log
@	* fhandler.h (class fhandler_process): Add fd_type member.
	* fhandler_process.cc (process_tab): Fix indentation.
	(fhandler_process::exists): Rely on format_process_fd returning file
	type in fd_type.
	(struct process_fd_t): Add fd_type member.
	(fhandler_process::fill_filebuf): Allow format_process_fd to set
	this->fd_type member.
	(format_process_fd): Fix path evaluation to allow recognizing trailing
	path components.  Fix check for file descriptor path component.  Return
	virt_symlink in fd_type if no trailing path compenents exist, return
	virt_fsdir otherwise and copy full resulting path into destbuf.
	* path.cc (path_conv::check): If /proc/$PID/fd symlink has trailing
	path components, reparse resulting path as if it's the incoming path.
	Add comment to wail over the outdated and hackish check method, and to
	explain what we do here.
@
text
@d338 1
a338 1
			  tail = stpcpy (dst, head.normalized_path);
d376 1
a376 1
      known_suffix = path + sym.extn;
d378 1
a378 1
	strcpy ((char *) known_suffix, sym.ext_here);
d412 1
a412 1
path_conv::set_normalized_path (const char *path_copy)
d417 2
a418 2
      char *p = (char *) crealloc_abort ((void *) normalized_path, n);
      normalized_path = (const char *) memcpy (p, path_copy, n);
d662 1
a662 1
      known_suffix = NULL;
d676 1
a676 1
      if (normalized_path)
d678 2
a679 2
	  cfree ((void *) normalized_path);
	  normalized_path = NULL;
d1233 1
a1233 1
	  set_normalized_path (path_copy);
d1255 1
a1255 1
  if (normalized_path)
d1257 2
a1258 2
      cfree ((void *) normalized_path);
      normalized_path = NULL;
d1626 2
a1627 2
      ssize_t len = strrchr (win32_newpath.normalized_path, '/')
		    - win32_newpath.normalized_path + 1;
d1629 1
a1629 1
      stpcpy (stpncpy (absoldpath, win32_newpath.normalized_path, len),
d1863 2
a1864 2
		  len = strrchr (win32_newpath.normalized_path, '/')
			- win32_newpath.normalized_path + 1;
d1866 1
a1866 1
		  stpcpy (stpncpy (absoldpath, win32_newpath.normalized_path,
d3246 1
a3246 1
	     The posix_cwd is just path.normalized_path.
d3249 2
a3250 2
	  if (!isdrive(path.normalized_path))
	    posix_cwd = path.normalized_path;
d3255 1
a3255 1
	 posix_cwd = path.normalized_path;
d3582 1
a3582 1
			 malloc (strlen (real_path.normalized_path) + 1);
d3586 1
a3586 1
	  strcpy (resolved, real_path.normalized_path);
d3673 1
a3673 1
    + (nrel * strlen (to_posix ? pc.normalized_path : pc.get_win32 ()))
@


1.696
log
@	* path.cc (find_fast_cwd): Point to problem reporting web site rather
	than to mailing list.
@
text
@d4 1
a4 1
     2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d750 2
d801 23
@


1.695
log
@	* path.cc (warn_msdos): Slightly reformat.
	(find_fast_cwd): Change warning message to urge an update before
	reporting the problem.
@
text
@d4215 1
a4215 1
"  report this problem to the public mailing list cygwin@@cygwin.com\n\n");
@


1.694
log
@	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.
@
text
@d527 1
a527 1
  small_printf ("cygwin warning:\n");
d530 2
a531 1
    small_printf ("  MS-DOS style path detected: %ls\n  POSIX equivalent preferred.\n",
d534 3
a536 1
    small_printf ("  MS-DOS style path detected: %ls\n  Preferred POSIX equivalent is: %ls\n",
d538 4
a541 3
  small_printf ("  CYGWIN environment variable option \"nodosfilewarning\" turns off this warning.\n"
		"  Consult the user's guide for more details about POSIX paths:\n"
		"    http://cygwin.com/cygwin-ug-net/using.html#using-pathnames\n");
d4211 5
a4215 3
    system_printf ("WARNING: Couldn't compute FAST_CWD pointer.  "
		   "Please report this problem to\nthe public mailing "
		   "list cygwin@@cygwin.com");
@


1.693
log
@	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.
@
text
@d520 1
a520 1
void
d523 1
a523 1
  if (user_shared->warned_msdos || !dos_file_warning || !cygwin_finished_initializing)
d1205 1
a1205 1
	  if (is_msdos && !(opt & PC_NOWARN))
@


1.692
log
@	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
@
text
@d2837 7
a2843 1
		  fileattr = basename.Length ? 0 : FILE_ATTRIBUTE_DIRECTORY;
@


1.691
log
@	* cygtls.h (TP_NUM_C_BUFS): Raise to 50 to allow SYMLOOP_MAX recursions
	path_conv <-> normalize_posix_path, plus a bit of buffer.
	(TP_NUM_W_BUFS): Ditto.
	(class san): Change type of _c_cnt and _w_cnt to unsigned.
	* path.cc (normalize_posix_path): Guard recursion into path_conv
	against tmp_pathbuf overflow.  Generate normalized path in call to
	path_conv.  If the path is valid, replace dst with the normalized_path
	from path_conv call.  Add comment to explain why we're doing this.
	* tls_pbuf.cc (tls_pathbuf::destroy): Only free buffers until the
	first buffer pointer is NULL.
	(tmp_pathbuf::c_get): Simplify error message.
	(tmp_pathbuf::w_get): Ditto.
	* tls_pbuf.h (class tmp_pathbuf): Change type of c_buf_old and w_buf_old
	to unsigned.
	(tmp_pathbuf::check_usage): New inline method to check if we have
	enough tmp_pathbuf buffers left to call a function using tmp_pathbuf
	buffers.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
@
text
@d654 1
a654 2
  myfault efault;
  if (efault.faulted ())
d656 22
a677 25
      error = EFAULT;
      return;
    }
  int loop = 0;
  path_flags = 0;
  known_suffix = NULL;
  fileattr = INVALID_FILE_ATTRIBUTES;
  caseinsensitive = OBJ_CASE_INSENSITIVE;
  if (wide_path)
    cfree (wide_path);
  wide_path = NULL;
  if (path)
    {
      cfree (modifiable_path ());
      path = NULL;
    }
  close_conv_handle ();
  memset (&dev, 0, sizeof (dev));
  fs.clear ();
  if (normalized_path)
    {
      cfree ((void *) normalized_path);
      normalized_path = NULL;
    }
  int component = 0;		// Number of translated components
d679 7
a685 7
  if (!(opt & PC_NULLEMPTY))
    error = 0;
  else if (!*src)
    {
      error = ENOENT;
      return;
    }
d687 12
a698 49
  bool is_msdos = false;
  /* This loop handles symlink expansion.  */
  for (;;)
    {
      MALLOC_CHECK;
      assert (src);

      is_relpath = !isabspath (src);
      error = normalize_posix_path (src, path_copy, tail);
      if (error > 0)
	return;
      if (error < 0)
	{
	  if (component == 0)
	    is_msdos = true;
	  error = 0;
	}

      /* Detect if the user was looking for a directory.  We have to strip the
	 trailing slash initially while trying to add extensions but take it
	 into account during processing */
      if (tail > path_copy + 2 && isslash (tail[-1]))
	{
	  need_directory = 1;
	  *--tail = '\0';
	}
      path_end = tail;

      /* Scan path_copy from right to left looking either for a symlink
	 or an actual existing file.  If an existing file is found, just
	 return.  If a symlink is found, exit the for loop.
	 Also: be careful to preserve the errno returned from
	 symlink.check as the caller may need it. */
      /* FIXME: Do we have to worry about multiple \'s here? */
      component = 0;		// Number of translated components
      sym.contents[0] = '\0';

      int symlen = 0;

      for (unsigned pflags_or = opt & (PC_NO_ACCESS_CHECK | PC_KEEP_HANDLE);
	   ;
	   pflags_or = 0)
	{
	  const suffix_info *suff;
	  char *full_path;

	  /* Don't allow symlink.check to set anything in the path_conv
	     class if we're working on an inner component of the path */
	  if (component)
d700 3
a702 2
	      suff = NULL;
	      full_path = pathbuf;
d704 5
a708 1
	  else
d710 2
a711 2
	      suff = suffixes;
	      full_path = THIS_path;
d713 1
d715 8
a722 6
	  /* Convert to native path spec sans symbolic link info. */
	  error = mount_table->conv_to_win32_path (path_copy, full_path, dev,
						   &sym.pflags);

	  if (error)
	    return;
d724 1
a724 1
	  sym.pflags |= pflags_or;
d726 3
a728 1
	  if (!dev.exists ())
d730 2
a731 3
	      error = ENXIO;
	      return;
	    }
d733 7
a739 4
	  if (iscygdrive_dev (dev))
	    {
	      if (!component)
		fileattr = FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_READONLY;
d742 17
a758 3
		  fileattr = getfileattr (THIS_path,
					  sym.pflags & MOUNT_NOPOSIX);
		  dev = FH_FS;
d760 2
a761 14
	      goto out;
	    }
	  else if (isdev_dev (dev))
	    {
	      /* Just make sure that the path handling goes on as with FH_FS. */
	    }
	  else if (isvirtual_dev (dev))
	    {
	      /* FIXME: Calling build_fhandler here is not the right way to handle this. */
	      fhandler_virtual *fh = (fhandler_virtual *) build_fh_dev (dev, path_copy);
	      virtual_ftype_t file_type;
	      if (!fh)
		file_type = virt_none;
	      else
d763 4
a766 2
		  file_type = fh->exists ();
		  if (file_type == virt_symlink)
d768 3
a770 2
		      fh->fill_filebuf ();
		      symlen = sym.set (fh->get_filebuf ());
d772 5
a776 1
		  delete fh;
d778 1
a778 1
	      switch (file_type)
d780 49
a828 39
		  case virt_directory:
		  case virt_rootdir:
		    if (component == 0)
		      fileattr = FILE_ATTRIBUTE_DIRECTORY;
		    break;
		  case virt_file:
		    if (component == 0)
		      fileattr = 0;
		    break;
		  case virt_symlink:
		    goto is_virtual_symlink;
		  case virt_pipe:
		    if (component == 0)
		      {
			fileattr = 0;
			dev.parse (FH_PIPE);
		      }
		    break;
		  case virt_socket:
		    if (component == 0)
		      {
			fileattr = 0;
			dev.parse (FH_TCP);
		      }
		    break;
		  case virt_fsdir:
		  case virt_fsfile:
		    /* Access to real file or directory via block device
		       entry in /proc/sys.  Convert to real file and go with
		       the flow. */
		    dev.parse (FH_FS);
		    goto is_fs_via_procsys;
		  case virt_blk:
		    /* Block special device.  If the trailing slash has been
		       requested, the target is the root directory of the
		       filesystem on this block device.  So we convert this to
		       a real file and attach the backslash. */
		    if (component == 0 && need_directory)
		      {
d830 46
a875 25
			strcat (full_path, "\\");
			fileattr = FILE_ATTRIBUTE_DIRECTORY
				   | FILE_ATTRIBUTE_DEVICE;
			goto out;
		      }
		    /*FALLTHRU*/
		  case virt_chr:
		    if (component == 0)
		      fileattr = FILE_ATTRIBUTE_DEVICE;
		    break;
		  default:
		    if (component == 0)
		      fileattr = INVALID_FILE_ATTRIBUTES;
		    goto virtual_component_retry;
		}
	      if (component == 0 || dev != FH_NETDRIVE)
		path_flags |= PATH_RO;
	      goto out;
	    }
	  /* devn should not be a device.  If it is, then stop parsing now. */
	  else if (dev != FH_FS)
	    {
	      fileattr = 0;
	      path_flags = sym.pflags;
	      if (component)
d877 2
a878 2
		  error = ENOTDIR;
		  return;
a879 2
	      goto out;		/* Found a device.  Stop parsing. */
	    }
d881 6
a886 9
	  /* If path is only a drivename, Windows interprets it as the
	     current working directory on this drive instead of the root
	     dir which is what we want. So we need the trailing backslash
	     in this case. */
	  if (full_path[0] && full_path[1] == ':' && full_path[2] == '\0')
	    {
	      full_path[2] = '\\';
	      full_path[3] = '\0';
	    }
d888 1
a888 6
	  /* If the incoming path was given in DOS notation, always treat
	     it as caseinsensitive,noacl path.  This must be set before
	     calling sym.check, otherwise the path is potentially treated
	     casesensitive. */
	  if (is_msdos)
	    sym.pflags |= PATH_NOPOSIX | PATH_NOACL;
d890 1
a890 1
is_fs_via_procsys:
d892 1
a892 1
	  symlen = sym.check (full_path, suff, fs, conv_handle);
d894 13
a906 1
is_virtual_symlink:
d908 1
a908 3
	  if (sym.isdevice)
	    {
	      if (component)
d910 9
a918 2
		  error = ENOTDIR;
		  return;
a919 6
	      dev.parse (sym.major, sym.minor);
	      dev.setfs (1);
	      dev.mode = sym.mode;
	      fileattr = sym.fileattr;
	      goto out;
	    }
d921 8
a928 3
	  if (sym.pflags & PATH_SOCKET)
	    {
	      if (component)
d930 13
a942 2
		  error = ENOTDIR;
		  return;
a943 29
	      fileattr = sym.fileattr;
	      dev.parse (FH_UNIX);
	      dev.setfs (1);
	      goto out;
	    }

	  if (!component)
	    {
	      /* Make sure that /dev always exists. */
	      fileattr = isdev_dev (dev) ? FILE_ATTRIBUTE_DIRECTORY
					 : sym.fileattr;
	      path_flags = sym.pflags;
	    }
	  else if (isdev_dev (dev))
	    {
	      /* If we're looking for a file below /dev, which doesn't exist,
		 make sure that the device type is converted to FH_FS, so that
		 subsequent code handles the file correctly.
		 Unless /dev itself doesn't exist on disk.  In that case /dev
		 is handled as virtual filesystem, and virtual filesystems are
		 read-only.  The PC_KEEP_HANDLE check allows to check for
		 a call from an informational system call.  In that case we
		 just stick to ENOENT, and the device type doesn't matter
		 anyway. */
	      if (sym.error == ENOENT && !(opt & PC_KEEP_HANDLE))
		sym.error = EROFS;
	      else
		dev = FH_FS;
	    }
d945 4
a948 9
	  /* If symlink.check found an existing non-symlink file, then
	     it sets the appropriate flag.  It also sets any suffix found
	     into `ext_here'. */
	  if (!sym.issymlink && sym.fileattr != INVALID_FILE_ATTRIBUTES)
	    {
	      error = sym.error;
	      if (component == 0)
		add_ext = true;
	      else if (!(sym.fileattr & FILE_ATTRIBUTE_DIRECTORY))
d950 9
a958 2
		  error = ENOTDIR;
		  goto out;
d960 6
a965 13
	      goto out;	// file found
	    }
	  /* Found a symlink if symlen > 0.  If component == 0, then the
	     src path itself was a symlink.  If !follow_mode then
	     we're done.  Otherwise we have to insert the path found
	     into the full path that we are building and perform all of
	     these operations again on the newly derived path. */
	  else if (symlen > 0)
	    {
	      saw_symlinks = 1;
	      if (component == 0 && !need_directory
		  && (!(opt & PC_SYM_FOLLOW)
		      || (is_rep_symlink () && (opt & PC_SYM_NOFOLLOW_REP))))
d967 5
a971 2
		  set_symlink (symlen); // last component of path is a symlink.
		  if (opt & PC_SYM_CONTENTS)
d973 8
a980 1
		      strcpy (THIS_path, sym.contents);
d983 11
a993 1
		  add_ext = true;
d996 17
a1012 7
	      /* Following a symlink we can't trust the collected filesystem
		 information any longer. */
	      fs.clear ();
	      /* Close handle, if we have any.  Otherwise we're collecting
		 handles while following symlinks. */
	      conv_handle.close ();
	      break;
d1014 3
a1016 1
	  else if (sym.error && sym.error != ENOENT)
d1018 2
a1019 2
	      error = sym.error;
	      goto out;
a1020 1
	  /* No existing file found. */
d1022 1
a1022 16
virtual_component_retry:
	  /* Find the new "tail" of the path, e.g. in '/for/bar/baz',
	     /baz is the tail. */
	  if (tail != path_end)
	    *tail = '/';
	  while (--tail > path_copy + 1 && *tail != '/') {}
	  /* Exit loop if there is no tail or we are at the
	     beginning of a UNC path */
	  if (tail <= path_copy + 1)
	    goto out;	// all done

	  /* Haven't found an existing pathname component yet.
	     Pinch off the tail and try again. */
	  *tail = '\0';
	  component++;
	}
a1023 6
      /* Arrive here if above loop detected a symlink. */
      if (++loop > SYMLOOP_MAX)
	{
	  error = ELOOP;   // Eep.
	  return;
	}
d1025 2
a1026 1
      MALLOC_CHECK;
d1028 13
d1042 8
a1049 1
      /* Place the link content, possibly with head and/or tail, in tmp_buf */
d1051 57
a1107 3
      char *headptr;
      if (isabspath (sym.contents))
	headptr = tmp_buf;	/* absolute path */
d1110 3
a1112 6
	  /* Copy the first part of the path (with ending /) and point to the end. */
	  char *prevtail = tail;
	  while (--prevtail > path_copy  && *prevtail != '/') {}
	  int headlen = prevtail - path_copy + 1;;
	  memcpy (tmp_buf, path_copy, headlen);
	  headptr = &tmp_buf[headlen];
d1115 1
a1115 2
      /* Make sure there is enough space */
      if (headptr + symlen >= tmp_buf + (2 * NT_MAX_PATH))
d1117 12
a1128 5
	too_long:
	  error = ENAMETOOLONG;
	  set_path ("::ENAMETOOLONG::");
	  return;
	}
d1130 59
a1188 16
     /* Copy the symlink contents to the end of tmp_buf.
	Convert slashes. */
      for (char *p = sym.contents; *p; p++)
	*headptr++ = *p == '\\' ? '/' : *p;
      *headptr = '\0';

      /* Copy any tail component (with the 0) */
      if (tail++ < path_end)
	{
	  /* Add a slash if needed. There is space. */
	  if (*(headptr - 1) != '/')
	    *headptr++ = '/';
	  int taillen = path_end - tail + 1;
	  if (headptr + taillen > tmp_buf + (2 * NT_MAX_PATH))
	    goto too_long;
	  memcpy (headptr, tail, taillen);
d1191 2
a1192 3
      /* Evaluate everything all over again. */
      src = tmp_buf;
    }
d1194 2
a1195 2
  if (!(opt & PC_SYM_CONTENTS))
    add_ext = true;
d1197 2
a1198 37
out:
  set_path (THIS_path);
  if (add_ext)
    add_ext_from_sym (sym);
  if (dev == FH_NETDRIVE && component)
    {
      /* This case indicates a non-existant resp. a non-retrievable
	 share.  This happens for instance if the share is a printer.
	 In this case the path must not be treated like a FH_NETDRIVE,
	 but like a FH_FS instead, so the usual open call for files
	 is used on it. */
      dev.parse (FH_FS);
    }
  else if (isproc_dev (dev) && fileattr == INVALID_FILE_ATTRIBUTES)
    {
      /* FIXME: Usually we don't set error to ENOENT if a file doesn't
	 exist.  This is typically indicated by the fileattr content.
	 So, why here?  The downside is that cygwin_conv_path just gets
	 an error for these paths so it reports the error back to the
	 application.  Unlike in all other cases of non-existant files,
	 for which check doesn't set error, so cygwin_conv_path just
	 returns the path, as intended. */
      error = ENOENT;
      return;
    }
  else if (!need_directory || error)
    /* nothing to do */;
  else if (fileattr == INVALID_FILE_ATTRIBUTES)
    strcat (modifiable_path (), "\\"); /* Reattach trailing dirsep in native path. */
  else if (fileattr & FILE_ATTRIBUTE_DIRECTORY)
    path_flags &= ~PATH_SYMLINK;
  else
    {
      debug_printf ("%s is a non-directory", path);
      error = ENOTDIR;
      return;
    }
d1200 1
a1200 3
  if (dev.isfs ())
    {
      if (strncmp (path, "\\\\.\\", 4))
d1202 5
a1206 9
	  if (!tail || tail == path)
	    /* nothing */;
	  else if (tail[-1] != '\\')
	    *tail = '\0';
	  else
	    {
	      error = ENOENT;
	      return;
	    }
d1209 2
a1210 2
      /* If FS hasn't been checked already in symlink_info::check, do so now. */
      if (fs.inited ()|| fs.update (get_nt_native_path (), NULL))
d1212 4
a1215 71
	  /* Incoming DOS paths are treated like DOS paths in native
	     Windows applications.  No ACLs, just default settings. */
	  if (is_msdos)
	    fs.has_acls (false);
	  debug_printf ("this->path(%s), has_acls(%d)", path, fs.has_acls ());
	  /* CV: We could use this->has_acls() but I want to make sure that
	     we don't forget that the PATH_NOACL flag must be taken into
	     account here. */
	  if (!(path_flags & PATH_NOACL) && fs.has_acls ())
	    set_exec (0);  /* We really don't know if this is executable or not here
			      but set it to not executable since it will be figured out
			      later by anything which cares about this. */
	}
      /* If the FS has been found to have unrelibale inodes, note
	 that in path_flags. */
      if (!fs.hasgood_inode ())
	path_flags |= PATH_IHASH;
      /* If the OS is caseinsensitive or the FS is caseinsensitive,
	 don't handle path casesensitive. */
      if (cygwin_shared->obcaseinsensitive || fs.caseinsensitive ())
	path_flags |= PATH_NOPOSIX;
      caseinsensitive = (path_flags & PATH_NOPOSIX)
			? OBJ_CASE_INSENSITIVE : 0;
      if (exec_state () != dont_know_if_executable)
	/* ok */;
      else if (isdir ())
	set_exec (1);
      else if (issymlink () || issocket ())
	set_exec (0);
    }

  if (opt & PC_NOFULL)
    {
      if (is_relpath)
	{
	  mkrelpath (this->modifiable_path (), !!caseinsensitive);
	  /* Invalidate wide_path so that wide relpath can be created
	     in later calls to get_nt_native_path or get_wide_win32_path. */
	  if (wide_path)
	    cfree (wide_path);
	  wide_path = NULL;
	}
      if (need_directory)
	{
	  size_t n = strlen (this->path);
	  /* Do not add trailing \ to UNC device names like \\.\a: */
	  if (this->path[n - 1] != '\\' &&
	      (strncmp (this->path, "\\\\.\\", 4) != 0))
	    {
	      this->modifiable_path ()[n] = '\\';
	      this->modifiable_path ()[n + 1] = '\0';
	    }
	}
    }

  if (saw_symlinks)
    set_has_symlinks ();

  if (opt & PC_OPEN)
    path_flags |= PATH_OPEN;

  if (opt & PC_CTTY)
    path_flags |= PATH_CTTY;

  if (opt & PC_POSIX)
    {
      if (tail < path_end && tail > path_copy + 1)
	*tail = '/';
      set_normalized_path (path_copy);
      if (is_msdos && !(opt & PC_NOWARN))
	warn_msdos (src);
d1217 1
a1217 3

#if 0
  if (!error)
d1219 1
a1219 2
      last_path_conv = *this;
      strcpy (last_src, src);
d1221 1
a1221 1
#endif
d1704 1
a1704 4
  myfault efault;
  if (efault.faulted (EFAULT))
    goto done;
  if (!*oldpath || !*newpath)
d1706 5
a1710 3
      set_errno (ENOENT);
      goto done;
    }
d1712 5
a1716 5
  if (strlen (oldpath) > SYMLINK_MAX)
    {
      set_errno (ENAMETOOLONG);
      goto done;
    }
d1718 8
a1725 8
  /* Trailing dirsep is a no-no. */
  len = strlen (newpath);
  has_trailing_dirsep = isdirsep (newpath[len - 1]);
  if (has_trailing_dirsep)
    {
      newpath = strdup (newpath);
      ((char *) newpath)[len - 1] = '\0';
    }
d1727 3
a1729 3
  check_opt = PC_SYM_NOFOLLOW | PC_POSIX | (isdevice ? PC_NOWARN : 0);
  /* We need the normalized full path below. */
  win32_newpath.check (newpath, check_opt, stat_suffixes);
d1731 12
a1742 15
  /* Default symlink type is determined by global allow_winsymlinks variable.
     Device files are always shortcuts. */
  wsym_type = isdevice ? WSYM_lnk : allow_winsymlinks;
  /* NFS has its own, dedicated way to create symlinks. */
  if (win32_newpath.fs_is_nfs ())
    wsym_type = WSYM_nfs;
  /* MVFS doesn't handle the SYSTEM DOS attribute, but it handles the R/O
     attribute.  Therefore we create symlinks on MVFS always as shortcuts. */
  else if (win32_newpath.fs_is_mvfs ())
    wsym_type = WSYM_lnk;
  /* AFS only supports native symlinks. */
  else if (win32_newpath.fs_is_afs ())
    {
      /* Bail out if OS doesn't support native symlinks. */
      if (wincap.max_sys_priv () < SE_CREATE_SYMBOLIC_LINK_PRIVILEGE)
d1744 7
a1750 2
	  set_errno (EPERM);
	  goto done;
d1752 4
a1755 6
      wsym_type = WSYM_nativestrict;
    }
  /* Don't try native symlinks on filesystems not supporting reparse points. */
  else if ((wsym_type == WSYM_native || wsym_type == WSYM_nativestrict)
	   && !(win32_newpath.fs_flags () & FILE_SUPPORTS_REPARSE_POINTS))
    wsym_type = WSYM_sysfile;
d1757 8
a1764 8
  /* Attach .lnk suffix when shortcut is requested. */
  if (wsym_type == WSYM_lnk && !win32_newpath.exists ()
      && (isdevice || !win32_newpath.fs_is_nfs ()))
    {
      char *newplnk = tp.c_get ();
      stpcpy (stpcpy (newplnk, newpath), ".lnk");
      win32_newpath.check (newplnk, check_opt);
    }
d1766 5
a1770 5
  if (win32_newpath.error)
    {
      set_errno (win32_newpath.error);
      goto done;
    }
d1772 2
a1773 2
  syscall_printf ("symlink (%s, %S) wsym_type %d", oldpath,
		  win32_newpath.get_nt_native_path (), wsym_type);
d1775 11
a1785 11
  if ((!isdevice && win32_newpath.exists ())
      || win32_newpath.is_auto_device ())
    {
      set_errno (EEXIST);
      goto done;
    }
  if (has_trailing_dirsep && !win32_newpath.exists ())
    {
      set_errno (ENOENT);
      goto done;
    }
d1787 2
a1788 13
  /* Handle NFS and native symlinks in their own functions. */
  switch (wsym_type)
    {
    case WSYM_nfs:
      res = symlink_nfs (oldpath, win32_newpath);
      goto done;
    case WSYM_native:
    case WSYM_nativestrict:
      res = symlink_native (oldpath, win32_newpath);
      if (!res)
      	goto done;
      /* Strictly native?  Too bad. */
      if (wsym_type == WSYM_nativestrict)
d1790 19
a1808 2
	  __seterrno ();
	  goto done;
a1809 6
      /* Otherwise, fall back to default symlink type. */
      wsym_type = WSYM_sysfile;
      break;
    default:
      break;
    }
d1811 33
a1843 45
  if (wsym_type == WSYM_lnk)
    {
      path_conv win32_oldpath;
      ITEMIDLIST *pidl = NULL;
      size_t full_len = 0;
      unsigned short oldpath_len, desc_len, relpath_len, pidl_len = 0;
      char desc[MAX_PATH + 1], *relpath;

      if (!isdevice)
	{
	  /* First create an IDLIST to learn how big our shortcut is
	     going to be. */
	  IShellFolder *psl;

	  /* The symlink target is relative to the directory in which
	     the symlink gets created, not relative to the cwd.  Therefore
	     we have to mangle the path quite a bit before calling path_conv. */
	  if (isabspath (oldpath))
	    win32_oldpath.check (oldpath,
				 PC_SYM_NOFOLLOW,
				 stat_suffixes);
	  else
	    {
	      len = strrchr (win32_newpath.normalized_path, '/')
		    - win32_newpath.normalized_path + 1;
	      char *absoldpath = tp.t_get ();
	      stpcpy (stpncpy (absoldpath, win32_newpath.normalized_path, len),
		      oldpath);
	      win32_oldpath.check (absoldpath, PC_SYM_NOFOLLOW, stat_suffixes);
	    }
	  if (SUCCEEDED (SHGetDesktopFolder (&psl)))
	    {
	      WCHAR wc_path[win32_oldpath.get_wide_win32_path_len () + 1];
	      win32_oldpath.get_wide_win32_path (wc_path);
	      /* Amazing but true:  Even though the ParseDisplayName method
		 takes a wide char path name, it does not understand the
		 Win32 prefix for long pathnames!  So we have to tack off
		 the prefix and convert the path to the "normal" syntax
		 for ParseDisplayName.  */
	      WCHAR *wc = wc_path + 4;
	      if (wc[1] != L':') /* native UNC path */
		*(wc += 2) = L'\\';
	      HRESULT res;
	      if (SUCCEEDED (res = psl->ParseDisplayName (NULL, NULL, wc, NULL,
						    &pidl, NULL)))
d1845 16
a1860 1
		  ITEMIDLIST *p;
d1862 6
a1867 4
		  for (p = pidl; p->mkid.cb > 0;
		       p = (ITEMIDLIST *)((char *) p + p->mkid.cb))
		    ;
		  pidl_len = (char *) p - (char *) pidl + 2;
a1868 1
	      psl->Release ();
d1870 86
a1956 85
      /* Compute size of shortcut file. */
      full_len = sizeof (win_shortcut_hdr);
      if (pidl_len)
	full_len += sizeof (unsigned short) + pidl_len;
      oldpath_len = strlen (oldpath);
      /* Unfortunately the length of the description is restricted to a
	 length of 2000 bytes.  We don't want to add considerations for
	 the different lengths and even 2000 bytes is not enough for long
	 path names.  So what we do here is to set the description to the
	 POSIX path only if the path is not longer than MAX_PATH characters.
	 We append the full path name after the regular shortcut data
	 (see below), which works fine with Windows Explorer as well
	 as older Cygwin versions (as long as the whole file isn't bigger
	 than 8K).  The description field is only used for backward
	 compatibility to older Cygwin versions and those versions are
	 not capable of handling long path names anyway. */
      desc_len = stpcpy (desc, oldpath_len > MAX_PATH
			       ? "[path too long]" : oldpath) - desc;
      full_len += sizeof (unsigned short) + desc_len;
      /* Devices get the oldpath string unchanged as relative path. */
      if (isdevice)
	{
	  relpath_len = oldpath_len;
	  stpcpy (relpath = tp.c_get (), oldpath);
	}
      else
	{
	  relpath_len = strlen (win32_oldpath.get_win32 ());
	  stpcpy (relpath = tp.c_get (), win32_oldpath.get_win32 ());
	}
      full_len += sizeof (unsigned short) + relpath_len;
      full_len += sizeof (unsigned short) + oldpath_len;
      /* 1 byte more for trailing 0 written by stpcpy. */
      if (full_len < NT_MAX_PATH * sizeof (WCHAR))
	buf = tp.t_get ();
      else
	buf = (char *) alloca (full_len + 1);

      /* Create shortcut header */
      win_shortcut_hdr *shortcut_header = (win_shortcut_hdr *) buf;
      memset (shortcut_header, 0, sizeof *shortcut_header);
      shortcut_header->size = sizeof *shortcut_header;
      shortcut_header->magic = GUID_shortcut;
      shortcut_header->flags = (WSH_FLAG_DESC | WSH_FLAG_RELPATH);
      if (pidl)
	shortcut_header->flags |= WSH_FLAG_IDLIST;
      shortcut_header->run = SW_NORMAL;
      cp = buf + sizeof (win_shortcut_hdr);

      /* Create IDLIST */
      if (pidl)
	{
	  *(unsigned short *)cp = pidl_len;
	  memcpy (cp += 2, pidl, pidl_len);
	  cp += pidl_len;
	  CoTaskMemFree (pidl);
	}

      /* Create description */
      *(unsigned short *)cp = desc_len;
      cp = stpcpy (cp += 2, desc);

      /* Create relpath */
      *(unsigned short *)cp = relpath_len;
      cp = stpcpy (cp += 2, relpath);

      /* Append the POSIX path after the regular shortcut data for
	 the long path support. */
      unsigned short *plen = (unsigned short *) cp;
      cp += 2;
      *(PWCHAR) cp = 0xfeff;		/* BOM */
      cp += 2;
      *plen = sys_mbstowcs ((PWCHAR) cp, NT_MAX_PATH, oldpath) * sizeof (WCHAR);
      cp += *plen;
    }
  else
    {
      /* Default technique creating a symlink. */
      buf = tp.t_get ();
      cp = stpcpy (buf, SYMLINK_COOKIE);
      *(PWCHAR) cp = 0xfeff;		/* BOM */
      cp += 2;
      /* Note that the terminating nul is written.  */
      cp += sys_mbstowcs ((PWCHAR) cp, NT_MAX_PATH, oldpath) * sizeof (WCHAR);
    }
d1958 47
a2004 12
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;
  NTSTATUS status;
  ULONG access;
  HANDLE fh;

  access = DELETE | FILE_GENERIC_WRITE;
  if (isdevice && win32_newpath.exists ())
    {
      status = NtOpenFile (&fh, FILE_WRITE_ATTRIBUTES,
			   win32_newpath.get_object_attr (attr, sec_none_nih),
			   &io, 0, FILE_OPEN_FOR_BACKUP_INTENT);
d2008 16
a2023 1
	  goto done;
d2025 1
a2025 3
      status = NtSetAttributesFile (fh, FILE_ATTRIBUTE_NORMAL);
      NtClose (fh);
      if (!NT_SUCCESS (status))
d2028 6
a2033 1
	  goto done;
d2035 1
a2035 11
    }
  else if (!isdevice && win32_newpath.has_acls () && !win32_newpath.isremote ())
    /* If the filesystem supports ACLs, we will overwrite the DACL after the
       call to NtCreateFile.  This requires a handle with READ_CONTROL and
       WRITE_DAC access, otherwise get_file_sd and set_file_sd both have to
       open the file again.
       FIXME: On remote NTFS shares open sometimes fails because even the
       creator of the file doesn't have the right to change the DACL.
       I don't know what setting that is or how to recognize such a share,
       so for now we don't request WRITE_DAC on remote drives. */
    access |= READ_CONTROL | WRITE_DAC;
a2036 36
  status = NtCreateFile (&fh, access,
			 win32_newpath.get_object_attr (attr, sec_none_nih),
			 &io, NULL, FILE_ATTRIBUTE_NORMAL,
			 FILE_SHARE_VALID_FLAGS,
			 isdevice ? FILE_OVERWRITE_IF : FILE_CREATE,
			 FILE_SYNCHRONOUS_IO_NONALERT
			 | FILE_NON_DIRECTORY_FILE
			 | FILE_OPEN_FOR_BACKUP_INTENT,
			 NULL, 0);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      goto done;
    }
  if (win32_newpath.has_acls ())
    set_file_attribute (fh, win32_newpath, ILLEGAL_UID, ILLEGAL_GID,
			(io.Information == FILE_CREATED ? S_JUSTCREATED : 0)
			| S_IFLNK | STD_RBITS | STD_WBITS);
  status = NtWriteFile (fh, NULL, NULL, NULL, &io, buf, cp - buf, NULL, NULL);
  if (NT_SUCCESS (status) && io.Information == (ULONG) (cp - buf))
    {
      status = NtSetAttributesFile (fh, wsym_type == WSYM_lnk
      					? FILE_ATTRIBUTE_READONLY
					: FILE_ATTRIBUTE_SYSTEM);
      if (!NT_SUCCESS (status))
	debug_printf ("Setting attributes failed, status = %y", status);
      res = 0;
    }
  else
    {
      __seterrno_from_nt_status (status);
      FILE_DISPOSITION_INFORMATION fdi = { TRUE };
      status = NtSetInformationFile (fh, &io, &fdi, sizeof fdi,
				     FileDispositionInformation);
      if (!NT_SUCCESS (status))
	debug_printf ("Setting delete dispostion failed, status = %y", status);
d2038 2
a2039 3
  NtClose (fh);

done:
d3135 10
a3144 7
  myfault efault;
  if (efault.faulted (EFAULT))
      /* errno set */;
  else if (ulen == 0 && buf)
    set_errno (EINVAL);
  else
    res = cygheap->cwd.get (buf, 1, 1, ulen);
d3179 3
a3181 4
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  if (!*in_dir)
d3183 40
a3222 3
      set_errno (ENOENT);
      return -1;
    }
d3224 2
a3225 1
  syscall_printf ("dir '%s'", in_dir);
d3227 6
a3232 4
  /* Convert path.  First argument ensures that we don't check for NULL/empty/invalid
     again. */
  path_conv path (PC_NONULLEMPTY, in_dir, PC_SYM_FOLLOW | PC_POSIX);
  if (path.error)
d3234 1
a3234 3
      set_errno (path.error);
      syscall_printf ("-1 = chdir (%s)", in_dir);
      return -1;
d3236 1
a3236 32

  int res = -1;
  const char *posix_cwd = NULL;
  dev_t devn = path.get_device ();
  if (!path.exists ())
    set_errno (ENOENT);
  else if (!path.isdir ())
    set_errno (ENOTDIR);
  else if (!isvirtual_dev (devn))
    {
      /* The sequence chdir("xx"); chdir(".."); must be a noop if xx
	 is not a symlink. This is exploited by find.exe.
	 The posix_cwd is just path.normalized_path.
	 In other cases we let cwd.set obtain the Posix path through
	 the mount table. */
      if (!isdrive(path.normalized_path))
	posix_cwd = path.normalized_path;
      res = 0;
    }
  else
   {
     posix_cwd = path.normalized_path;
     res = 0;
   }

  if (!res)
    res = cygheap->cwd.set (&path, posix_cwd);

  /* Note that we're accessing cwd.posix without a lock here.  I didn't think
     it was worth locking just for strace. */
  syscall_printf ("%R = chdir() cygheap->cwd.posix '%s' native '%S'", res,
		  cygheap->cwd.get_posix (), path.get_nt_native_path ());
a3273 4
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;

d3281 1
d3283 1
a3283 1
  if (!from)
d3285 5
a3289 3
      set_errno (EINVAL);
      return -1;
    }
d3291 3
a3293 15
  switch (what)
    {
    case CCP_POSIX_TO_WIN_A:
      {
	p.check ((const char *) from,
		 PC_POSIX | PC_SYM_FOLLOW | PC_SYM_NOFOLLOW_REP
		 | PC_NO_ACCESS_CHECK | PC_NOWARN | (relative ? PC_NOFULL : 0));
	if (p.error)
	  return_with_errno (p.error);
	PUNICODE_STRING up = p.get_nt_native_path ();
	buf = tp.c_get ();
	sys_wcstombs (buf, NT_MAX_PATH,
		      up->Buffer, up->Length / sizeof (WCHAR));
	/* Convert native path to standard DOS path. */
	if (!strncmp (buf, "\\??\\", 4))
d3295 11
a3305 13
	    buf += 4;
	    if (buf[1] != ':') /* native UNC path */
	      *(buf += 2) = '\\';
	  }
	else if (*buf == '\\')
	  {
	    /* Device name points to somewhere else in the NT namespace.
	       Use GLOBALROOT prefix to convert to Win32 path. */
	    char *p = buf + sys_wcstombs (buf, NT_MAX_PATH,
					  ro_u_globalroot.Buffer,
					  ro_u_globalroot.Length
					  / sizeof (WCHAR));
	    sys_wcstombs (p, NT_MAX_PATH - (p - buf),
d3307 29
d3337 5
a3341 26
	lsiz = strlen (buf) + 1;
	/* TODO: Incoming "." is a special case which leads to a trailing
	   backslash ".\\" in the Win32 path.  That's a result of the
	   conversion in normalize_posix_path.  This should not occur
	   so the below code is just a band-aid. */
	if (relative && !strcmp ((const char *) from, ".")
	    && !strcmp (buf, ".\\"))
	  {
	    lsiz = 2;
	    buf[1] = '\0';
	  }
      }
      break;
    case CCP_POSIX_TO_WIN_W:
      p.check ((const char *) from,
	       PC_POSIX | PC_SYM_FOLLOW | PC_SYM_NOFOLLOW_REP
	       | PC_NO_ACCESS_CHECK | PC_NOWARN | (relative ? PC_NOFULL : 0));
      if (p.error)
	return_with_errno (p.error);
      /* Relative Windows paths are always restricted to MAX_PATH chars. */
      if (relative && !isabspath (p.get_win32 ())
	  && sys_mbstowcs (NULL, 0, p.get_win32 ()) > MAX_PATH)
	{
	  /* Recreate as absolute path. */
	  p.check ((const char *) from, PC_POSIX | PC_SYM_FOLLOW
					| PC_NO_ACCESS_CHECK | PC_NOWARN);
d3343 19
a3361 4
	    return_with_errno (p.error);
	}
      lsiz = p.get_wide_win32_path_len () + 1;
      path = p.get_nt_native_path ()->Buffer;
d3363 4
a3366 4
      /* Convert native path to standard DOS path. */
      if (!wcsncmp (path, L"\\??\\", 4))
	{
	  path[1] = L'\\';
d3368 6
a3373 10
	  /* Drop long path prefix for short pathnames.  Unfortunately there's
	     quite a bunch of Win32 functions, especially in user32.dll,
	     apparently, which don't grok long path names at all, not even
	     in the UNICODE API. */
	  if ((path[5] == L':' && lsiz <= MAX_PATH + 4)
	      || (!wcsncmp (path + 4, L"UNC\\", 4) && lsiz <= MAX_PATH + 6))
	    {
	      path += 4;
	      lsiz -= 4;
	      if (path[1] != L':')
d3375 7
a3381 2
		  *(path += 2) = '\\';
		  lsiz -= 2;
d3384 46
d3431 1
a3431 1
      else if (*path == L'\\')
d3433 2
a3434 4
	  /* Device name points to somewhere else in the NT namespace.
	     Use GLOBALROOT prefix to convert to Win32 path. */
	  to = (void *) wcpcpy ((wchar_t *) to, ro_u_globalroot.Buffer);
	  lsiz += ro_u_globalroot.Length / sizeof (WCHAR);
d3436 1
a3436 3
      /* TODO: Same ".\\" band-aid as in CCP_POSIX_TO_WIN_A case. */
      if (relative && !strcmp ((const char *) from, ".")
	  && !wcscmp (path, L".\\"))
d3438 8
a3445 2
	  lsiz = 2;
	  path[1] = L'\0';
d3447 1
a3447 21
      lsiz *= sizeof (WCHAR);
      break;
    case CCP_WIN_A_TO_POSIX:
      buf = tp.c_get ();
      error = mount_table->conv_to_posix_path ((const char *) from, buf,
					       relative);
      if (error)
	return_with_errno (error);
      lsiz = strlen (buf) + 1;
      break;
    case CCP_WIN_W_TO_POSIX:
      buf = tp.c_get ();
      error = mount_table->conv_to_posix_path ((const PWCHAR) from, buf,
					       relative);
      if (error)
	return_with_errno (error);
      lsiz = strlen (buf) + 1;
      break;
    default:
      set_errno (EINVAL);
      return -1;
d3449 3
a3451 19
  if (!size)
    return lsiz;
  if (size < lsiz)
    {
      set_errno (ENOSPC);
      return -1;
    }
  switch (what)
    {
    case CCP_POSIX_TO_WIN_A:
    case CCP_WIN_A_TO_POSIX:
    case CCP_WIN_W_TO_POSIX:
      stpcpy ((char *) to, buf);
      break;
    case CCP_POSIX_TO_WIN_W:
      wcpcpy ((PWCHAR) to, path);
      break;
    }
  return 0;
d3510 3
d3522 1
a3522 10
  tmp_pathbuf tp;
  myfault efault;
  if (efault.faulted (EFAULT))
    return NULL;

  /* Win32 drive letter paths have to be converted to a POSIX path first,
     because path_conv leaves the incoming path untouched except for
     converting backslashes to forward slashes. */
  char *tpath;
  if (isdrive (path))
d3524 10
a3533 5
      tpath = tp.c_get ();
      mount_table->conv_to_posix_path (path, tpath, 0);
    }
  else
    tpath = (char *) path;
d3535 1
a3535 1
  path_conv real_path (tpath, PC_SYM_FOLLOW | PC_POSIX, stat_suffixes);
d3538 3
a3540 3
  /* POSIX 2008 requires malloc'ing if resolved is NULL, and states
     that using non-NULL resolved is asking for portability
     problems.  */
d3542 1
a3542 3
  if (!real_path.error && real_path.exists ())
    {
      if (!resolved)
a3543 1
	  resolved = (char *) malloc (strlen (real_path.normalized_path) + 1);
d3545 16
a3560 4
	    return NULL;
	}
      strcpy (resolved, real_path.normalized_path);
      return resolved;
d3562 2
a3563 7

  /* FIXME: on error, Linux puts the name of the path
     component which could not be resolved into RESOLVED, but POSIX
     does not require this.  */
  if (resolved)
    resolved[0] = '\0';
  set_errno (real_path.error ?: ENOENT);
@


1.690
log
@	* path.cc (find_fast_cwd_pointer): Fix preceeding comment.
@
text
@d314 12
a325 1
			  path_conv head (dst);
d328 11
@


1.689
log
@	Introduce reading passwd/group entries from SAM/AD.  Introduce
	/etc/nsswitch.conf file to configure it.
	* Makefile.in (DLL_OFILES): Add ldap.o.
	* autoload.cc: Import ldap functions from wldap32.dll.
	(DsEnumerateDomainTrustsW): Import.
	(NetGroupGetInfo): Import.
	* cygheap.h (class cygheap_domain_info): New class to keep global
	domain info.
	(class cygheap_pwdgrp): New class to keep passwd/group caches and
	configuration info from /etc/nssswitch.conf.
	(struct init_cygheap): Add cygheap_domain_info member "dom" and
	cygheap_pwdgrp member "pg".
	* cygtls.h (struct _local_storage): Remove unused member "res".
	Rearrange slightly, Add members pwbuf and grbuf to implement non-caching
	passwd/group fetching from SAM/AD.  Make pw_pos and pw_pos unsigned.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Add RFC 2307
	uid/gid mapping.
	* fhandler_process.cc: Drop including pwdgrp.h.
	* fhandler_procsysvipc.cc: Ditto.
	* fhandler_registry.cc (fhandler_registry::fstat): Set key uid/gid
	to ILLEGAL_UID/ILLEGAL_GID rather than UNKNOWN_UID/UNKNOWN_GID.
	* grp.cc (group_buf): Drop.
	(gr): Drop.
	(pwdgrp::parse_group): Fill pg_grp.
	(pwdgrp::read_group): Remove.
	(pwdgrp::init_grp): New method.
	(pwdgrp::prep_tls_grbuf): New method.
	(pwdgrp::find_group): New methods.
	(internal_getgrsid): Convert to call new pwdgrp methods.
	(internal_getgrnam): Ditto.
	(internal_getgrgid): Ditto.
	(getgrgid_r): Drop 2nd parameter from internal_getgrgid call.
	(getgrgid32): Ditto.
	(getgrnam_r): Ditto for internal_getgrnam.
	(getgrnam32): Ditto.
	(getgrent32): Convert to call new pwdgrp methods.
	(internal_getgrent): Remove.
	(internal_getgroups): Simplify, especially drop calls to
	internal_getgrent.
	* ldap.cc: New file implementing cyg_ldap class for LDAP access to AD
	and RFC 2307 server.
	* ldap.h: New header, declaring cyg_ldap class.
	* passwd.cc (passwd_buf): Drop.
	(pr): Drop.
	(pwdgrp::parse_passwd): Fill pg_pwd.
	(pwdgrp::read_passwd): Remove.
	(pwdgrp::init_pwd): New method.
	(pwdgrp::prep_tls_pwbuf): New method.
	(find_user): New methods.
	(internal_getpwsid): Convert to call new pwdgrp methods.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(getpwuid32): Drop 2nd parameter from internal_getpwuid call.
	(getpwuid_r): Ditto.
	(getpwnam): Ditto for internal_getpwnam.
	(getpwnam_r): Ditto.
	(getpwent): Convert to call new pwdgrp methods.
	* path.cc (class etc): Remove all methods.
	* path.h (class etc): Drop.
	* pinfo.cc (pinfo_basic::pinfo_basic): Set gid to ILLEGAL_GID rather
	than UNKNOWN_GID.
	(pinfo_init): Ditto.
	* pwdgrp.h (internal_getpwnam): Drop 2nd parameter from declaration.
	(internal_getpwuid): Ditto.
	(internal_getgrgid): Ditto.
	(internal_getgrnam): Ditto.
	(internal_getgrent): Drop declaration.
	(enum fetch_user_arg_type_t): New type.
	(struct fetch_user_arg_t): New type.
	(struct pg_pwd): New type.
	(struct pg_grp): New type.
	(class pwdgrp): Rework to provide functions for file and db requests
	and caching.
	(class ugid_cache_t): New class to provide RFC 2307 uid map caching.
	(ugid_cache): Declare.
	* sec_acl.cc: Drop including pwdgrp.h.
	* sec_auth.cc: Drop including dsgetdc.h and pwdgrp.h.
	(get_logon_server): Convert third parameter to ULONG flags argument
	to allow arbitrary flags values in DsGetDcNameW call and change calls
	to this function throughout.  Use cached account domain name rather
	than calling GetComputerNameW.
	(get_unix_group_sidlist): Remove.
	(get_server_groups): Drop call to get_unix_group_sidlist.
	(verify_token): Rework token group check without calling
	internal_getgrent.
	* sec_helper.cc (cygpsid::pstring): New methods, like string() but
	return pointer to end of string.
	(cygsid::getfromstr): Add wide character implementation.
	(get_sids_info): Add RFC 2307 uid/gid mapping for Samba shares.
	* security.cc: Drop including pwdgrp.h.
	* security.h (DEFAULT_UID): Remove.
	(UNKNOWN_UID): Remove.
	(UNKNOWN_GID): Remove.
	(uinfo_init): Move here from winsup.h.
	(ILLEGAL_UID): Ditto.
	(ILLEGAL_GID): Ditto.
	(UNIX_POSIX_OFFSET): Define.  Add lengthy comment.
	(UNIX_POSIX_MASK): Ditto.
	(MAP_UNIX_TO_CYGWIN_ID): Ditto.
	(ILLEGAL_UID16): Move here from winsup.h.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Ditto.
	(gid16togid32): Ditto.
	(sid_id_auth): New convenience macro for SID component access.
	(sid_sub_auth_count): Ditto.
	(sid_sub_auth): Ditto.
	(sid_sub_auth_rid): Ditto.
	(cygpsid::pstring): Declare.
	(cygsid::getfromstr): Declare wide character variant.
	(cygsid::operator=): Ditto.
	(cygsid::operator*=): Ditto.
	(get_logon_server): Change declaration according to source code.
	* setlsapwd.cc (setlsapwd): Drop 2nd parameter from internal_getpwnam
	call.
	* shared.cc (memory_init): Call cygheap->pg.init in first process.
	* syscalls.cc: Drop including pwdgrp.h.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Ditto.
	* uinfo.cc (internal_getlogin): Drop gratuitious internal_getpwuid
	call.  Fix debug output.  Overwrite user gid in border case of a
	missing passwd file while a group file exists.
	(pwdgrp::add_line): Allocate memory on cygheap.
	(pwdgrp::load): Remove.
	(ugid_cache): Define.
	(cygheap_pwdgrp::init): New method.
	(cygheap_pwdgrp::nss_init_line): New method.
	(cygheap_pwdgrp::_nss_init): New method.
	(cygheap_domain_info::init): New method.
	(logon_sid): Define.
	(get_logon_sid): New function.
	(pwdgrp::add_account_post_fetch): New method.
	(pwdgrp::add_account_from_file): New methods.
	(pwdgrp::add_account_from_windows): New methods.
	(pwdgrp::check_file): New method.
	(pwdgrp::fetch_account_from_line): New method.
	(pwdgrp::fetch_account_from_file): New method.
	(pwdgrp::fetch_account_from_windows): New method.
	* winsup.h: Move aforementioned macros and declarations to security.h.
@
text
@d3915 1
a3915 2
   and W8CP 32/64 bit.  There's some hope this will still work for
   Windows 8 RTM... */
@


1.688
log
@	* path.cc (etc::test_file_change): In case of NtQueryFullAttributesFile
	returning an error, only return true if file actually exists.
@
text
@a4614 136
int etc::curr_ix = 0;
/* Note that the first elements of the below arrays are unused */
bool etc::change_possible[MAX_ETC_FILES + 1];
OBJECT_ATTRIBUTES etc::fn[MAX_ETC_FILES + 1];
LARGE_INTEGER etc::last_modified[MAX_ETC_FILES + 1];

int
etc::init (int n, POBJECT_ATTRIBUTES attr)
{
  if (n > 0)
    /* ok */;
  else if (++curr_ix <= MAX_ETC_FILES)
    n = curr_ix;
  else
    api_fatal ("internal error");

  fn[n] = *attr;
  change_possible[n] = false;
  test_file_change (n);
  paranoid_printf ("fn[%d] %S, curr_ix %d", n, fn[n].ObjectName, curr_ix);
  return n;
}

bool
etc::test_file_change (int n)
{
  NTSTATUS status;
  FILE_NETWORK_OPEN_INFORMATION fnoi;
  bool res;

  status = NtQueryFullAttributesFile (&fn[n], &fnoi);
  if (!NT_SUCCESS (status))
    {
      res = status != STATUS_OBJECT_NAME_NOT_FOUND;
      memset (last_modified + n, 0, sizeof (last_modified[n]));
      debug_printf ("NtQueryFullAttributesFile (%S) failed, %y",
		    fn[n].ObjectName, status);
    }
  else
    {
      res = CompareFileTime ((FILETIME *) &fnoi.LastWriteTime,
			     (FILETIME *) last_modified + n) > 0;
      last_modified[n].QuadPart = fnoi.LastWriteTime.QuadPart;
    }

  paranoid_printf ("fn[%d] %S res %d", n, fn[n].ObjectName, res);
  return res;
}

bool
etc::dir_changed (int n)
{
  /* io MUST be static because NtNotifyChangeDirectoryFile works asynchronously.
     It may write into io after the function has left, which may result in all
     sorts of stack corruption. */
  static IO_STATUS_BLOCK io NO_COPY;
  static HANDLE changed_h NO_COPY;

  if (!change_possible[n])
    {
      NTSTATUS status;

      if (!changed_h)
	{
	  OBJECT_ATTRIBUTES attr;

	  path_conv dir ("/etc");
	  status = NtOpenFile (&changed_h, SYNCHRONIZE | FILE_LIST_DIRECTORY,
			       dir.get_object_attr (attr, sec_none_nih), &io,
			       FILE_SHARE_VALID_FLAGS, FILE_DIRECTORY_FILE);
	  if (!NT_SUCCESS (status))
	    {
#ifdef DEBUGGING
	      system_printf ("NtOpenFile (%S) failed, %y",
			     dir.get_nt_native_path (), status);
#endif
	      changed_h = INVALID_HANDLE_VALUE;
	    }
	  else
	    {
	      status = NtNotifyChangeDirectoryFile (changed_h, NULL, NULL,
						NULL, &io, NULL, 0,
						FILE_NOTIFY_CHANGE_LAST_WRITE
						| FILE_NOTIFY_CHANGE_FILE_NAME,
						FALSE);
	      if (!NT_SUCCESS (status))
		{
#ifdef DEBUGGING
		  system_printf ("NtNotifyChangeDirectoryFile (1) failed, %y",
				 status);
#endif
		  NtClose (changed_h);
		  changed_h = INVALID_HANDLE_VALUE;
		}
	    }
	  memset (change_possible, true, sizeof (change_possible));
	}

      if (changed_h == INVALID_HANDLE_VALUE)
	change_possible[n] = true;
      else if (WaitForSingleObject (changed_h, 0) == WAIT_OBJECT_0)
	{
	  status = NtNotifyChangeDirectoryFile (changed_h, NULL, NULL,
						NULL, &io, NULL, 0,
						FILE_NOTIFY_CHANGE_LAST_WRITE
						| FILE_NOTIFY_CHANGE_FILE_NAME,
						FALSE);
	  if (!NT_SUCCESS (status))
	    {
#ifdef DEBUGGING
	      system_printf ("NtNotifyChangeDirectoryFile (2) failed, %y",
			     status);
#endif
	      NtClose (changed_h);
	      changed_h = INVALID_HANDLE_VALUE;
	    }
	  memset (change_possible, true, sizeof change_possible);
	}
    }

  paranoid_printf ("fn[%d] %S change_possible %d",
		   n, fn[n].ObjectName, change_possible[n]);
  return change_possible[n];
}

bool
etc::file_changed (int n)
{
  bool res = false;
  if (dir_changed (n) && test_file_change (n))
    res = true;
  change_possible[n] = false;	/* Change is no longer possible */
  paranoid_printf ("fn[%d] %S res %d", n, fn[n].ObjectName, res);
  return res;
}

@


1.688.2.1
log
@Pull in forgotten native symlink patch
@
text
@d314 1
a314 12
			  /* In conjunction with native and NFS symlinks,
			     this call can result in a recursion which eats
			     up our tmp_pathbuf buffers.  This in turn results
			     in a api_fatal call.  To avoid that, we're
			     checking our remaining buffers and return an
			     error code instead.  Note that this only happens
			     if the path contains 15 or more relative native/NFS
			     symlinks with a ".." in the target path. */
			  tmp_pathbuf tp;
			  if (!tp.check_usage (4, 3))
			    return ELOOP;
			  path_conv head (dst, PC_SYM_FOLLOW | PC_POSIX);
a316 11
			  /* At this point, dst is a normalized path.  If the
			     normalized path created by path_conv does not
			     match the normalized path we're just testing, then
			     the path in dst contains native symlinks.  If we
			     just plunge along, removing the previous path
			     component, we may end up removing a symlink from
			     the path and the resulting path will be invalid.
			     So we replace dst with what we found in head
			     instead.  All the work replacing symlinks has been
			     done in that path anyway, so why repeat it? */
			  tail = stpcpy (dst, head.normalized_path);
d3915 2
a3916 1
   Windows 8 32/64 bit, Windows 8.1 32/64 bit, and Server 2012 R2. */
@


1.688.2.2
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d520 1
a520 1
static void
d523 1
a523 1
  if (user_shared->warned_msdos || !cygwin_finished_initializing)
d654 23
a676 1
  __try
d678 12
a689 22
      int loop = 0;
      path_flags = 0;
      known_suffix = NULL;
      fileattr = INVALID_FILE_ATTRIBUTES;
      caseinsensitive = OBJ_CASE_INSENSITIVE;
      if (wide_path)
	cfree (wide_path);
      wide_path = NULL;
      if (path)
	{
	  cfree (modifiable_path ());
	  path = NULL;
	}
      close_conv_handle ();
      memset (&dev, 0, sizeof (dev));
      fs.clear ();
      if (normalized_path)
	{
	  cfree ((void *) normalized_path);
	  normalized_path = NULL;
	}
      int component = 0;		// Number of translated components
d691 6
a696 7
      if (!(opt & PC_NULLEMPTY))
	error = 0;
      else if (!*src)
	{
	  error = ENOENT;
	  return;
	}
d698 42
a739 12
      bool is_msdos = false;
      /* This loop handles symlink expansion.  */
      for (;;)
	{
	  MALLOC_CHECK;
	  assert (src);

	  is_relpath = !isabspath (src);
	  error = normalize_posix_path (src, path_copy, tail);
	  if (error > 0)
	    return;
	  if (error < 0)
d741 2
a742 3
	      if (component == 0)
		is_msdos = true;
	      error = 0;
d744 1
a744 5

	  /* Detect if the user was looking for a directory.  We have to strip
	     the trailing slash initially while trying to add extensions but
	     take it into account during processing */
	  if (tail > path_copy + 2 && isslash (tail[-1]))
d746 2
a747 2
	      need_directory = 1;
	      *--tail = '\0';
a748 1
	  path_end = tail;
d750 6
a755 8
	  /* Scan path_copy from right to left looking either for a symlink
	     or an actual existing file.  If an existing file is found, just
	     return.  If a symlink is found, exit the for loop.
	     Also: be careful to preserve the errno returned from
	     symlink.check as the caller may need it. */
	  /* FIXME: Do we have to worry about multiple \'s here? */
	  component = 0;		// Number of translated components
	  sym.contents[0] = '\0';
d757 1
a757 1
	  int symlen = 0;
d759 1
a759 3
	  for (unsigned pflags_or = opt & (PC_NO_ACCESS_CHECK | PC_KEEP_HANDLE);
	       ;
	       pflags_or = 0)
d761 3
a763 2
	      const suffix_info *suff;
	      char *full_path;
d765 5
a769 3
	      /* Don't allow symlink.check to set anything in the path_conv
		 class if we're working on an inner component of the path */
	      if (component)
d771 3
a773 2
		  suff = NULL;
		  full_path = pathbuf;
d775 13
d790 2
a791 25
		  suff = suffixes;
		  full_path = THIS_path;
		}

	      /* Convert to native path spec sans symbolic link info. */
	      error = mount_table->conv_to_win32_path (path_copy, full_path,
						       dev, &sym.pflags);

	      if (error)
		return;

	      sym.pflags |= pflags_or;

	      if (!dev.exists ())
		{
		  error = ENXIO;
		  return;
		}

	      if (iscygdrive_dev (dev))
		{
		  if (!component)
		    fileattr = FILE_ATTRIBUTE_DIRECTORY
			       | FILE_ATTRIBUTE_READONLY;
		  else
d793 2
a794 3
		      fileattr = getfileattr (THIS_path,
					      sym.pflags & MOUNT_NOPOSIX);
		      dev = FH_FS;
d796 1
a796 1
		  goto out;
d798 1
a798 1
	      else if (isdev_dev (dev))
d800 39
a838 53
		  /* Make sure that the path handling goes on as with FH_FS. */
		}
	      else if (isvirtual_dev (dev))
		{
		  /* FIXME: Calling build_fhandler here is not the right way to
			    handle this. */
		  fhandler_virtual *fh = (fhandler_virtual *)
					 build_fh_dev (dev, path_copy);
		  virtual_ftype_t file_type;
		  if (!fh)
		    file_type = virt_none;
		  else
		    {
		      file_type = fh->exists ();
		      if (file_type == virt_symlink)
			{
			  fh->fill_filebuf ();
			  symlen = sym.set (fh->get_filebuf ());
			}
		      delete fh;
		    }
		  switch (file_type)
		    {
		      case virt_directory:
		      case virt_rootdir:
			if (component == 0)
			  fileattr = FILE_ATTRIBUTE_DIRECTORY;
			break;
		      case virt_file:
			if (component == 0)
			  fileattr = 0;
			break;
		      case virt_symlink:
			goto is_virtual_symlink;
		      case virt_pipe:
			if (component == 0)
			  {
			    fileattr = 0;
			    dev.parse (FH_PIPE);
			  }
			break;
		      case virt_socket:
			if (component == 0)
			  {
			    fileattr = 0;
			    dev.parse (FH_TCP);
			  }
			break;
		      case virt_fsdir:
		      case virt_fsfile:
			/* Access to real file or directory via block device
			   entry in /proc/sys.  Convert to real file and go with
			   the flow. */
d840 14
a853 27
			goto is_fs_via_procsys;
		      case virt_blk:
			/* Block special device.  If the trailing slash has been
			   requested, the target is the root directory of the
			   filesystem on this block device.  So we convert this
			   to a real file and attach the backslash. */
			if (component == 0 && need_directory)
			  {
			    dev.parse (FH_FS);
			    strcat (full_path, "\\");
			    fileattr = FILE_ATTRIBUTE_DIRECTORY
				       | FILE_ATTRIBUTE_DEVICE;
			    goto out;
			  }
			/*FALLTHRU*/
		      case virt_chr:
			if (component == 0)
			  fileattr = FILE_ATTRIBUTE_DEVICE;
			break;
		      default:
			if (component == 0)
			  fileattr = INVALID_FILE_ATTRIBUTES;
			goto virtual_component_retry;
		    }
		  if (component == 0 || dev != FH_NETDRIVE)
		    path_flags |= PATH_RO;
		  goto out;
d855 10
a864 2
	      /* devn should not be a device.  If it is, then stop parsing. */
	      else if (dev != FH_FS)
d866 2
a867 8
		  fileattr = 0;
		  path_flags = sym.pflags;
		  if (component)
		    {
		      error = ENOTDIR;
		      return;
		    }
		  goto out;		/* Found a device.  Stop parsing. */
d869 2
d872 9
a880 9
	      /* If path is only a drivename, Windows interprets it as the
		 current working directory on this drive instead of the root
		 dir which is what we want. So we need the trailing backslash
		 in this case. */
	      if (full_path[0] && full_path[1] == ':' && full_path[2] == '\0')
		{
		  full_path[2] = '\\';
		  full_path[3] = '\0';
		}
d882 6
a887 6
	      /* If the incoming path was given in DOS notation, always treat
		 it as caseinsensitive,noacl path.  This must be set before
		 calling sym.check, otherwise the path is potentially treated
		 casesensitive. */
	      if (is_msdos)
		sym.pflags |= PATH_NOPOSIX | PATH_NOACL;
d889 1
a889 1
    is_fs_via_procsys:
d891 1
a891 1
	      symlen = sym.check (full_path, suff, fs, conv_handle);
d893 1
a893 1
    is_virtual_symlink:
d895 3
a897 1
	      if (sym.isdevice)
d899 2
a900 10
		  if (component)
		    {
		      error = ENOTDIR;
		      return;
		    }
		  dev.parse (sym.major, sym.minor);
		  dev.setfs (1);
		  dev.mode = sym.mode;
		  fileattr = sym.fileattr;
		  goto out;
d902 6
d909 3
a911 1
	      if (sym.pflags & PATH_SOCKET)
d913 2
a914 9
		  if (component)
		    {
		      error = ENOTDIR;
		      return;
		    }
		  fileattr = sym.fileattr;
		  dev.parse (FH_UNIX);
		  dev.setfs (1);
		  goto out;
d916 29
d946 9
a954 1
	      if (!component)
d956 2
a957 4
		  /* Make sure that /dev always exists. */
		  fileattr = isdev_dev (dev) ? FILE_ATTRIBUTE_DIRECTORY
					     : sym.fileattr;
		  path_flags = sym.pflags;
d959 13
a971 1
	      else if (isdev_dev (dev))
d973 2
a974 24
		  /* If we're looking for a non-existing file below /dev,
		     make sure that the device type is converted to FH_FS, so
		     that subsequent code handles the file correctly.  Unless
		     /dev itself doesn't exist on disk.  In that case /dev
		     is handled as virtual filesystem, and virtual filesystems
		     are read-only.  The PC_KEEP_HANDLE check allows to check
		     for a call from an informational system call.  In that
		     case we just stick to ENOENT, and the device type doesn't
		     matter anyway. */
		  if (sym.error == ENOENT && !(opt & PC_KEEP_HANDLE))
		    sym.error = EROFS;
		  else
		    dev = FH_FS;
		}

	      /* If symlink.check found an existing non-symlink file, then
		 it sets the appropriate flag.  It also sets any suffix found
		 into `ext_here'. */
	      if (!sym.issymlink && sym.fileattr != INVALID_FILE_ATTRIBUTES)
		{
		  error = sym.error;
		  if (component == 0)
		    add_ext = true;
		  else if (!(sym.fileattr & FILE_ATTRIBUTE_DIRECTORY))
d976 1
a976 26
		      error = ENOTDIR;
		      goto out;
		    }
		  goto out;	// file found
		}
	      /* Found a symlink if symlen > 0.  If component == 0, then the
		 src path itself was a symlink.  If !follow_mode then
		 we're done.  Otherwise we have to insert the path found
		 into the full path that we are building and perform all of
		 these operations again on the newly derived path. */
	      else if (symlen > 0)
		{
		  saw_symlinks = 1;
		  if (component == 0 && !need_directory
		      && (!(opt & PC_SYM_FOLLOW)
			  || (is_rep_symlink ()
			      && (opt & PC_SYM_NOFOLLOW_REP))))
		    {
		      /* last component of path is a symlink. */
		      set_symlink (symlen);
		      if (opt & PC_SYM_CONTENTS)
			{
			  strcpy (THIS_path, sym.contents);
			  goto out;
			}
		      add_ext = true;
d979 1
a979 11
		  /* Following a symlink we can't trust the collected
		     filesystem information any longer. */
		  fs.clear ();
		  /* Close handle, if we have any.  Otherwise we're collecting
		     handles while following symlinks. */
		  conv_handle.close ();
		  break;
		}
	      else if (sym.error && sym.error != ENOENT)
		{
		  error = sym.error;
d982 7
a988 17
	      /* No existing file found. */

    virtual_component_retry:
	      /* Find the new "tail" of the path, e.g. in '/for/bar/baz',
		 /baz is the tail. */
	      if (tail != path_end)
		*tail = '/';
	      while (--tail > path_copy + 1 && *tail != '/') {}
	      /* Exit loop if there is no tail or we are at the
		 beginning of a UNC path */
	      if (tail <= path_copy + 1)
		goto out;	// all done

	      /* Haven't found an existing pathname component yet.
		 Pinch off the tail and try again. */
	      *tail = '\0';
	      component++;
d990 1
a990 3

	  /* Arrive here if above loop detected a symlink. */
	  if (++loop > SYMLOOP_MAX)
d992 2
a993 2
	      error = ELOOP;   // Eep.
	      return;
d995 1
d997 16
a1012 1
	  MALLOC_CHECK;
d1014 6
d1021 1
a1021 2
	  /* Place the link content, possibly with head and/or tail,
	     in tmp_buf */
a1022 13
	  char *headptr;
	  if (isabspath (sym.contents))
	    headptr = tmp_buf;	/* absolute path */
	  else
	    {
	      /* Copy the first part of the path (with ending /) and point to
		 the end. */
	      char *prevtail = tail;
	      while (--prevtail > path_copy  && *prevtail != '/') {}
	      int headlen = prevtail - path_copy + 1;;
	      memcpy (tmp_buf, path_copy, headlen);
	      headptr = &tmp_buf[headlen];
	    }
d1024 1
a1024 8
	  /* Make sure there is enough space */
	  if (headptr + symlen >= tmp_buf + (2 * NT_MAX_PATH))
	    {
	    too_long:
	      error = ENAMETOOLONG;
	      set_path ("::ENAMETOOLONG::");
	      return;
	    }
d1026 3
a1028 57
	 /* Copy the symlink contents to the end of tmp_buf.
	    Convert slashes. */
	  for (char *p = sym.contents; *p; p++)
	    *headptr++ = *p == '\\' ? '/' : *p;
	  *headptr = '\0';

	  /* Copy any tail component (with the 0) */
	  if (tail++ < path_end)
	    {
	      /* Add a slash if needed. There is space. */
	      if (*(headptr - 1) != '/')
		*headptr++ = '/';
	      int taillen = path_end - tail + 1;
	      if (headptr + taillen > tmp_buf + (2 * NT_MAX_PATH))
		goto too_long;
	      memcpy (headptr, tail, taillen);
	    }

	  /* Evaluate everything all over again. */
	  src = tmp_buf;
	}

      if (!(opt & PC_SYM_CONTENTS))
	add_ext = true;

    out:
      set_path (THIS_path);
      if (add_ext)
	add_ext_from_sym (sym);
      if (dev == FH_NETDRIVE && component)
	{
	  /* This case indicates a non-existant resp. a non-retrievable
	     share.  This happens for instance if the share is a printer.
	     In this case the path must not be treated like a FH_NETDRIVE,
	     but like a FH_FS instead, so the usual open call for files
	     is used on it. */
	  dev.parse (FH_FS);
	}
      else if (isproc_dev (dev) && fileattr == INVALID_FILE_ATTRIBUTES)
	{
	  /* FIXME: Usually we don't set error to ENOENT if a file doesn't
	     exist.  This is typically indicated by the fileattr content.
	     So, why here?  The downside is that cygwin_conv_path just gets
	     an error for these paths so it reports the error back to the
	     application.  Unlike in all other cases of non-existant files,
	     for which check doesn't set error, so cygwin_conv_path just
	     returns the path, as intended. */
	  error = ENOENT;
	  return;
	}
      else if (!need_directory || error)
	/* nothing to do */;
      else if (fileattr == INVALID_FILE_ATTRIBUTES)
	/* Reattach trailing dirsep in native path. */
	strcat (modifiable_path (), "\\");
      else if (fileattr & FILE_ATTRIBUTE_DIRECTORY)
	path_flags &= ~PATH_SYMLINK;
d1031 14
a1044 2
	  debug_printf ("%s is a non-directory", path);
	  error = ENOTDIR;
d1048 16
a1063 74
      if (dev.isfs ())
	{
	  if (strncmp (path, "\\\\.\\", 4))
	    {
	      if (!tail || tail == path)
		/* nothing */;
	      else if (tail[-1] != '\\')
		*tail = '\0';
	      else
		{
		  error = ENOENT;
		  return;
		}
	    }

	  /* If FS hasn't been checked already in symlink_info::check,
	     do so now. */
	  if (fs.inited ()|| fs.update (get_nt_native_path (), NULL))
	    {
	      /* Incoming DOS paths are treated like DOS paths in native
		 Windows applications.  No ACLs, just default settings. */
	      if (is_msdos)
		fs.has_acls (false);
	      debug_printf ("this->path(%s), has_acls(%d)",
			    path, fs.has_acls ());
	      /* CV: We could use this->has_acls() but I want to make sure that
		 we don't forget that the PATH_NOACL flag must be taken into
		 account here. */
	      if (!(path_flags & PATH_NOACL) && fs.has_acls ())
		set_exec (0);  /* We really don't know if this is executable or
				  not here but set it to not executable since
				  it will be figured out later by anything
				  which cares about this. */
	    }
	  /* If the FS has been found to have unrelibale inodes, note
	     that in path_flags. */
	  if (!fs.hasgood_inode ())
	    path_flags |= PATH_IHASH;
	  /* If the OS is caseinsensitive or the FS is caseinsensitive,
	     don't handle path casesensitive. */
	  if (cygwin_shared->obcaseinsensitive || fs.caseinsensitive ())
	    path_flags |= PATH_NOPOSIX;
	  caseinsensitive = (path_flags & PATH_NOPOSIX)
			    ? OBJ_CASE_INSENSITIVE : 0;
	  if (exec_state () != dont_know_if_executable)
	    /* ok */;
	  else if (isdir ())
	    set_exec (1);
	  else if (issymlink () || issocket ())
	    set_exec (0);
	}

      if (opt & PC_NOFULL)
	{
	  if (is_relpath)
	    {
	      mkrelpath (this->modifiable_path (), !!caseinsensitive);
	      /* Invalidate wide_path so that wide relpath can be created
		 in later calls to get_nt_native_path or get_wide_win32_path. */
	      if (wide_path)
		cfree (wide_path);
	      wide_path = NULL;
	    }
	  if (need_directory)
	    {
	      size_t n = strlen (this->path);
	      /* Do not add trailing \ to UNC device names like \\.\a: */
	      if (this->path[n - 1] != '\\' &&
		  (strncmp (this->path, "\\\\.\\", 4) != 0))
		{
		  this->modifiable_path ()[n] = '\\';
		  this->modifiable_path ()[n + 1] = '\0';
		}
	    }
d1066 3
a1068 2
      if (saw_symlinks)
	set_has_symlinks ();
d1070 2
a1071 2
      if (opt & PC_OPEN)
	path_flags |= PATH_OPEN;
d1073 37
a1109 2
      if (opt & PC_CTTY)
	path_flags |= PATH_CTTY;
d1111 3
a1113 1
      if (opt & PC_POSIX)
d1115 9
a1123 5
	  if (tail < path_end && tail > path_copy + 1)
	    *tail = '/';
	  set_normalized_path (path_copy);
	  if (is_msdos && dos_file_warning && !(opt & PC_NOWARN))
	    warn_msdos (src);
d1126 2
a1127 2
#if 0
      if (!error)
d1129 71
a1199 4
	  last_path_conv = *this;
	  strcpy (last_src, src);
	}
#endif
d1201 3
a1203 1
  __except (NO_ERROR)
d1205 2
a1206 1
      error = EFAULT;
d1208 1
a1208 1
  __endtry
d1691 4
a1694 1
  __try
d1696 3
a1698 5
      if (!*oldpath || !*newpath)
	{
	  set_errno (ENOENT);
	  __leave;
	}
d1700 5
a1704 5
      if (strlen (oldpath) > SYMLINK_MAX)
	{
	  set_errno (ENAMETOOLONG);
	  __leave;
	}
d1706 8
a1713 8
      /* Trailing dirsep is a no-no. */
      len = strlen (newpath);
      has_trailing_dirsep = isdirsep (newpath[len - 1]);
      if (has_trailing_dirsep)
	{
	  newpath = strdup (newpath);
	  ((char *) newpath)[len - 1] = '\0';
	}
d1715 3
a1717 3
      check_opt = PC_SYM_NOFOLLOW | PC_POSIX | (isdevice ? PC_NOWARN : 0);
      /* We need the normalized full path below. */
      win32_newpath.check (newpath, check_opt, stat_suffixes);
d1719 15
a1733 12
      /* Default symlink type is determined by global allow_winsymlinks
	 variable.  Device files are always shortcuts. */
      wsym_type = isdevice ? WSYM_lnk : allow_winsymlinks;
      /* NFS has its own, dedicated way to create symlinks. */
      if (win32_newpath.fs_is_nfs ())
	wsym_type = WSYM_nfs;
      /* MVFS doesn't handle the SYSTEM DOS attribute, but it handles the R/O
	 attribute. Therefore we create symlinks on MVFS always as shortcuts. */
      else if (win32_newpath.fs_is_mvfs ())
	wsym_type = WSYM_lnk;
      /* AFS only supports native symlinks. */
      else if (win32_newpath.fs_is_afs ())
d1735 2
a1736 7
	  /* Bail out if OS doesn't support native symlinks. */
	  if (wincap.max_sys_priv () < SE_CREATE_SYMBOLIC_LINK_PRIVILEGE)
	    {
	      set_errno (EPERM);
	      __leave;
	    }
	  wsym_type = WSYM_nativestrict;
d1738 15
a1752 4
      /* Don't try native symlinks on FSes not supporting reparse points. */
      else if ((wsym_type == WSYM_native || wsym_type == WSYM_nativestrict)
	       && !(win32_newpath.fs_flags () & FILE_SUPPORTS_REPARSE_POINTS))
	wsym_type = WSYM_sysfile;
d1754 5
a1758 8
      /* Attach .lnk suffix when shortcut is requested. */
      if (wsym_type == WSYM_lnk && !win32_newpath.exists ()
	  && (isdevice || !win32_newpath.fs_is_nfs ()))
	{
	  char *newplnk = tp.c_get ();
	  stpcpy (stpcpy (newplnk, newpath), ".lnk");
	  win32_newpath.check (newplnk, check_opt);
	}
d1760 2
a1761 5
      if (win32_newpath.error)
	{
	  set_errno (win32_newpath.error);
	  __leave;
	}
d1763 11
a1773 2
      syscall_printf ("symlink (%s, %S) wsym_type %d", oldpath,
		      win32_newpath.get_nt_native_path (), wsym_type);
d1775 13
a1787 2
      if ((!isdevice && win32_newpath.exists ())
	  || win32_newpath.is_auto_device ())
d1789 2
a1790 7
	  set_errno (EEXIST);
	  __leave;
	}
      if (has_trailing_dirsep && !win32_newpath.exists ())
	{
	  set_errno (ENOENT);
	  __leave;
d1792 6
d1799 22
a1820 13
      /* Handle NFS and native symlinks in their own functions. */
      switch (wsym_type)
	{
	case WSYM_nfs:
	  res = symlink_nfs (oldpath, win32_newpath);
	  __leave;
	case WSYM_native:
	case WSYM_nativestrict:
	  res = symlink_native (oldpath, win32_newpath);
	  if (!res)
	    __leave;
	  /* Strictly native?  Too bad. */
	  if (wsym_type == WSYM_nativestrict)
d1822 22
a1843 32
	      __seterrno ();
	      __leave;
	    }
	  /* Otherwise, fall back to default symlink type. */
	  wsym_type = WSYM_sysfile;
	  break;
	default:
	  break;
	}

      if (wsym_type == WSYM_lnk)
	{
	  path_conv win32_oldpath;
	  ITEMIDLIST *pidl = NULL;
	  size_t full_len = 0;
	  unsigned short oldpath_len, desc_len, relpath_len, pidl_len = 0;
	  char desc[MAX_PATH + 1], *relpath;

	  if (!isdevice)
	    {
	      /* First create an IDLIST to learn how big our shortcut is
		 going to be. */
	      IShellFolder *psl;

	      /* The symlink target is relative to the directory in which the
		 symlink gets created, not relative to the cwd.  Therefore we
		 have to mangle the path quite a bit before calling path_conv.*/
	      if (isabspath (oldpath))
		win32_oldpath.check (oldpath,
				     PC_SYM_NOFOLLOW,
				     stat_suffixes);
	      else
d1845 1
a1845 27
		  len = strrchr (win32_newpath.normalized_path, '/')
			- win32_newpath.normalized_path + 1;
		  char *absoldpath = tp.t_get ();
		  stpcpy (stpncpy (absoldpath, win32_newpath.normalized_path,
				   len),
			  oldpath);
		  win32_oldpath.check (absoldpath, PC_SYM_NOFOLLOW,
				       stat_suffixes);
		}
	      if (SUCCEEDED (SHGetDesktopFolder (&psl)))
		{
		  WCHAR wc_path[win32_oldpath.get_wide_win32_path_len () + 1];
		  win32_oldpath.get_wide_win32_path (wc_path);
		  /* Amazing but true:  Even though the ParseDisplayName method
		     takes a wide char path name, it does not understand the
		     Win32 prefix for long pathnames!  So we have to tack off
		     the prefix and convert the path to the "normal" syntax
		     for ParseDisplayName.  */
		  WCHAR *wc = wc_path + 4;
		  if (wc[1] != L':') /* native UNC path */
		    *(wc += 2) = L'\\';
		  HRESULT res;
		  if (SUCCEEDED (res = psl->ParseDisplayName (NULL, NULL, wc,
							      NULL, &pidl,
							      NULL)))
		    {
		      ITEMIDLIST *p;
d1847 4
a1850 6
		      for (p = pidl; p->mkid.cb > 0;
			   p = (ITEMIDLIST *)((char *) p + p->mkid.cb))
			;
		      pidl_len = (char *) p - (char *) pidl + 2;
		    }
		  psl->Release ();
d1852 1
d1854 25
a1878 75
	  /* Compute size of shortcut file. */
	  full_len = sizeof (win_shortcut_hdr);
	  if (pidl_len)
	    full_len += sizeof (unsigned short) + pidl_len;
	  oldpath_len = strlen (oldpath);
	  /* Unfortunately the length of the description is restricted to a
	     length of 2000 bytes.  We don't want to add considerations for
	     the different lengths and even 2000 bytes is not enough for long
	     path names.  So what we do here is to set the description to the
	     POSIX path only if the path is not longer than MAX_PATH characters.
	     We append the full path name after the regular shortcut data
	     (see below), which works fine with Windows Explorer as well
	     as older Cygwin versions (as long as the whole file isn't bigger
	     than 8K).  The description field is only used for backward
	     compatibility to older Cygwin versions and those versions are
	     not capable of handling long path names anyway. */
	  desc_len = stpcpy (desc, oldpath_len > MAX_PATH
				   ? "[path too long]" : oldpath) - desc;
	  full_len += sizeof (unsigned short) + desc_len;
	  /* Devices get the oldpath string unchanged as relative path. */
	  if (isdevice)
	    {
	      relpath_len = oldpath_len;
	      stpcpy (relpath = tp.c_get (), oldpath);
	    }
	  else
	    {
	      relpath_len = strlen (win32_oldpath.get_win32 ());
	      stpcpy (relpath = tp.c_get (), win32_oldpath.get_win32 ());
	    }
	  full_len += sizeof (unsigned short) + relpath_len;
	  full_len += sizeof (unsigned short) + oldpath_len;
	  /* 1 byte more for trailing 0 written by stpcpy. */
	  if (full_len < NT_MAX_PATH * sizeof (WCHAR))
	    buf = tp.t_get ();
	  else
	    buf = (char *) alloca (full_len + 1);

	  /* Create shortcut header */
	  win_shortcut_hdr *shortcut_header = (win_shortcut_hdr *) buf;
	  memset (shortcut_header, 0, sizeof *shortcut_header);
	  shortcut_header->size = sizeof *shortcut_header;
	  shortcut_header->magic = GUID_shortcut;
	  shortcut_header->flags = (WSH_FLAG_DESC | WSH_FLAG_RELPATH);
	  if (pidl)
	    shortcut_header->flags |= WSH_FLAG_IDLIST;
	  shortcut_header->run = SW_NORMAL;
	  cp = buf + sizeof (win_shortcut_hdr);

	  /* Create IDLIST */
	  if (pidl)
	    {
	      *(unsigned short *)cp = pidl_len;
	      memcpy (cp += 2, pidl, pidl_len);
	      cp += pidl_len;
	      CoTaskMemFree (pidl);
	    }

	  /* Create description */
	  *(unsigned short *)cp = desc_len;
	  cp = stpcpy (cp += 2, desc);

	  /* Create relpath */
	  *(unsigned short *)cp = relpath_len;
	  cp = stpcpy (cp += 2, relpath);

	  /* Append the POSIX path after the regular shortcut data for
	     the long path support. */
	  unsigned short *plen = (unsigned short *) cp;
	  cp += 2;
	  *(PWCHAR) cp = 0xfeff;		/* BOM */
	  cp += 2;
	  *plen = sys_mbstowcs ((PWCHAR) cp, NT_MAX_PATH, oldpath)
		  * sizeof (WCHAR);
	  cp += *plen;
d1882 2
a1883 8
	  /* Default technique creating a symlink. */
	  buf = tp.t_get ();
	  cp = stpcpy (buf, SYMLINK_COOKIE);
	  *(PWCHAR) cp = 0xfeff;		/* BOM */
	  cp += 2;
	  /* Note that the terminating nul is written.  */
	  cp += sys_mbstowcs ((PWCHAR) cp, NT_MAX_PATH, oldpath)
		* sizeof (WCHAR);
d1885 7
d1893 53
a1945 5
      OBJECT_ATTRIBUTES attr;
      IO_STATUS_BLOCK io;
      NTSTATUS status;
      ULONG access;
      HANDLE fh;
d1947 6
a1952 41
      access = DELETE | FILE_GENERIC_WRITE;
      if (isdevice && win32_newpath.exists ())
	{
	  status = NtOpenFile (&fh, FILE_WRITE_ATTRIBUTES,
			       win32_newpath.get_object_attr (attr,
							      sec_none_nih),
			       &io, 0, FILE_OPEN_FOR_BACKUP_INTENT);
	  if (!NT_SUCCESS (status))
	    {
	      __seterrno_from_nt_status (status);
	      __leave;
	    }
	  status = NtSetAttributesFile (fh, FILE_ATTRIBUTE_NORMAL);
	  NtClose (fh);
	  if (!NT_SUCCESS (status))
	    {
	      __seterrno_from_nt_status (status);
	      __leave;
	    }
	}
      else if (!isdevice && win32_newpath.has_acls ()
	       && !win32_newpath.isremote ())
	/* If the filesystem supports ACLs, we will overwrite the DACL after the
	   call to NtCreateFile.  This requires a handle with READ_CONTROL and
	   WRITE_DAC access, otherwise get_file_sd and set_file_sd both have to
	   open the file again.
	   FIXME: On remote NTFS shares open sometimes fails because even the
	   creator of the file doesn't have the right to change the DACL.
	   I don't know what setting that is or how to recognize such a share,
	   so for now we don't request WRITE_DAC on remote drives. */
	access |= READ_CONTROL | WRITE_DAC;

      status = NtCreateFile (&fh, access,
			     win32_newpath.get_object_attr (attr, sec_none_nih),
			     &io, NULL, FILE_ATTRIBUTE_NORMAL,
			     FILE_SHARE_VALID_FLAGS,
			     isdevice ? FILE_OVERWRITE_IF : FILE_CREATE,
			     FILE_SYNCHRONOUS_IO_NONALERT
			     | FILE_NON_DIRECTORY_FILE
			     | FILE_OPEN_FOR_BACKUP_INTENT,
			     NULL, 0);
d1956 1
a1956 1
	  __leave;
d1958 3
a1960 16
      if (win32_newpath.has_acls ())
	set_file_attribute (fh, win32_newpath, ILLEGAL_UID, ILLEGAL_GID,
			    (io.Information == FILE_CREATED ? S_JUSTCREATED : 0)
			    | S_IFLNK | STD_RBITS | STD_WBITS);
      status = NtWriteFile (fh, NULL, NULL, NULL, &io, buf, cp - buf,
			    NULL, NULL);
      if (NT_SUCCESS (status) && io.Information == (ULONG) (cp - buf))
	{
	  status = NtSetAttributesFile (fh, wsym_type == WSYM_lnk
					    ? FILE_ATTRIBUTE_READONLY
					    : FILE_ATTRIBUTE_SYSTEM);
	  if (!NT_SUCCESS (status))
	    debug_printf ("Setting attributes failed, status = %y", status);
	  res = 0;
	}
      else
d1963 1
a1963 6
	  FILE_DISPOSITION_INFORMATION fdi = { TRUE };
	  status = NtSetInformationFile (fh, &io, &fdi, sizeof fdi,
					 FileDispositionInformation);
	  if (!NT_SUCCESS (status))
	    debug_printf ("Setting delete dispostion failed, status = %y",
			  status);
d1965 11
a1975 1
      NtClose (fh);
d1977 27
d2005 12
a2016 2
  __except (EFAULT) {}
  __endtry
d2814 1
a2814 7
		 if (basename.Length)
		   fileattr = FILE_ATTRIBUTE_DIRECTORY;
		 else
		   {
		     fileattr = 0;
		     set_error (geterrno_from_nt_status (status));
		   }
d3112 7
a3118 10

  __try
    {
      if (ulen == 0 && buf)
	set_errno (EINVAL);
      else
	res = cygheap->cwd.get (buf, 1, 1, ulen);
    }
  __except (EFAULT) {}
  __endtry
d3153 4
a3156 3
  int res = -1;

  __try
d3158 3
a3160 5
      if (!*in_dir)
	{
	  set_errno (ENOENT);
	  __leave;
	}
d3162 1
a3162 34
      syscall_printf ("dir '%s'", in_dir);

      /* Convert path.  First argument ensures that we don't check for
      	 NULL/empty/invalid again. */
      path_conv path (PC_NONULLEMPTY, in_dir, PC_SYM_FOLLOW | PC_POSIX);
      if (path.error)
	{
	  set_errno (path.error);
	  syscall_printf ("-1 = chdir (%s)", in_dir);
	  __leave;
	}

      const char *posix_cwd = NULL;
      dev_t devn = path.get_device ();
      if (!path.exists ())
	set_errno (ENOENT);
      else if (!path.isdir ())
	set_errno (ENOTDIR);
      else if (!isvirtual_dev (devn))
	{
	  /* The sequence chdir("xx"); chdir(".."); must be a noop if xx
	     is not a symlink. This is exploited by find.exe.
	     The posix_cwd is just path.normalized_path.
	     In other cases we let cwd.set obtain the Posix path through
	     the mount table. */
	  if (!isdrive(path.normalized_path))
	    posix_cwd = path.normalized_path;
	  res = 0;
	}
      else
       {
	 posix_cwd = path.normalized_path;
	 res = 0;
       }
d3164 9
a3172 2
      if (!res)
	res = cygheap->cwd.set (&path, posix_cwd);
d3174 17
a3190 4
      /* Note that we're accessing cwd.posix without a lock here.
	 I didn't think it was worth locking just for strace. */
      syscall_printf ("%R = chdir() cygheap->cwd.posix '%s' native '%S'", res,
		      cygheap->cwd.get_posix (), path.get_nt_native_path ());
d3192 13
a3204 5
  __except (EFAULT)
    {
      res = -1;
    }
  __endtry
d3242 4
a3252 1
  int ret = -1;
d3254 1
a3254 1
  __try
d3256 3
a3258 5
      if (!from)
	{
	  set_errno (EINVAL);
	  __leave;
	}
d3260 21
a3280 3
      switch (what)
	{
	case CCP_POSIX_TO_WIN_A:
d3282 7
a3288 11
	    p.check ((const char *) from,
		     PC_POSIX | PC_SYM_FOLLOW | PC_SYM_NOFOLLOW_REP
		     | PC_NO_ACCESS_CHECK | PC_NOWARN | (relative ? PC_NOFULL : 0));
	    if (p.error)
	      {
	        set_errno (p.error);
		__leave;
	      }
	    PUNICODE_STRING up = p.get_nt_native_path ();
	    buf = tp.c_get ();
	    sys_wcstombs (buf, NT_MAX_PATH,
a3289 29
	    /* Convert native path to standard DOS path. */
	    if (!strncmp (buf, "\\??\\", 4))
	      {
		buf += 4;
		if (buf[1] != ':') /* native UNC path */
		  *(buf += 2) = '\\';
	      }
	    else if (*buf == '\\')
	      {
		/* Device name points to somewhere else in the NT namespace.
		   Use GLOBALROOT prefix to convert to Win32 path. */
		char *p = buf + sys_wcstombs (buf, NT_MAX_PATH,
					      ro_u_globalroot.Buffer,
					      ro_u_globalroot.Length
					      / sizeof (WCHAR));
		sys_wcstombs (p, NT_MAX_PATH - (p - buf),
			      up->Buffer, up->Length / sizeof (WCHAR));
	      }
	    lsiz = strlen (buf) + 1;
	    /* TODO: Incoming "." is a special case which leads to a trailing
	       backslash ".\\" in the Win32 path.  That's a result of the
	       conversion in normalize_posix_path.  This should not occur
	       so the below code is just a band-aid. */
	    if (relative && !strcmp ((const char *) from, ".")
		&& !strcmp (buf, ".\\"))
	      {
		lsiz = 2;
		buf[1] = '\0';
	      }
d3291 26
a3316 5
	  break;
	case CCP_POSIX_TO_WIN_W:
	  p.check ((const char *) from,
		   PC_POSIX | PC_SYM_FOLLOW | PC_SYM_NOFOLLOW_REP
		   | PC_NO_ACCESS_CHECK | PC_NOWARN | (relative ? PC_NOFULL : 0));
d3318 4
a3321 19
	    {
	      set_errno (p.error);
	      __leave;
	    }
	  /* Relative Windows paths are always restricted to MAX_PATH chars. */
	  if (relative && !isabspath (p.get_win32 ())
	      && sys_mbstowcs (NULL, 0, p.get_win32 ()) > MAX_PATH)
	    {
	      /* Recreate as absolute path. */
	      p.check ((const char *) from, PC_POSIX | PC_SYM_FOLLOW
					    | PC_NO_ACCESS_CHECK | PC_NOWARN);
	      if (p.error)
		{
		  set_errno (p.error);
		  __leave;
		}
	    }
	  lsiz = p.get_wide_win32_path_len () + 1;
	  path = p.get_nt_native_path ()->Buffer;
d3323 15
a3337 11
	  /* Convert native path to standard DOS path. */
	  if (!wcsncmp (path, L"\\??\\", 4))
	    {
	      path[1] = L'\\';

	      /* Drop long path prefix for short pathnames.  Unfortunately there's
		 quite a bunch of Win32 functions, especially in user32.dll,
		 apparently, which don't grok long path names at all, not even
		 in the UNICODE API. */
	      if ((path[5] == L':' && lsiz <= MAX_PATH + 4)
		  || (!wcsncmp (path + 4, L"UNC\\", 4) && lsiz <= MAX_PATH + 6))
d3339 2
a3340 7
		  path += 4;
		  lsiz -= 4;
		  if (path[1] != L':')
		    {
		      *(path += 2) = '\\';
		      lsiz -= 2;
		    }
a3342 41
	  else if (*path == L'\\')
	    {
	      /* Device name points to somewhere else in the NT namespace.
		 Use GLOBALROOT prefix to convert to Win32 path. */
	      to = (void *) wcpcpy ((wchar_t *) to, ro_u_globalroot.Buffer);
	      lsiz += ro_u_globalroot.Length / sizeof (WCHAR);
	    }
	  /* TODO: Same ".\\" band-aid as in CCP_POSIX_TO_WIN_A case. */
	  if (relative && !strcmp ((const char *) from, ".")
	      && !wcscmp (path, L".\\"))
	    {
	      lsiz = 2;
	      path[1] = L'\0';
	    }
	  lsiz *= sizeof (WCHAR);
	  break;
	case CCP_WIN_A_TO_POSIX:
	  buf = tp.c_get ();
	  error = mount_table->conv_to_posix_path ((const char *) from, buf,
						   relative);
	  if (error)
	    {
	      set_errno (p.error);
	      __leave;
	    }
	  lsiz = strlen (buf) + 1;
	  break;
	case CCP_WIN_W_TO_POSIX:
	  buf = tp.c_get ();
	  error = mount_table->conv_to_posix_path ((const PWCHAR) from, buf,
						   relative);
	  if (error)
	    {
	      set_errno (error);
	      __leave;
	    }
	  lsiz = strlen (buf) + 1;
	  break;
	default:
	  set_errno (EINVAL);
	  __leave;
d3344 1
a3344 1
      if (!size)
d3346 4
a3349 2
	  ret = lsiz;
	  __leave;
d3351 3
a3353 1
      if (size < lsiz)
d3355 2
a3356 2
	  set_errno (ENOSPC);
	  __leave;
d3358 39
a3396 12
      switch (what)
	{
	case CCP_POSIX_TO_WIN_A:
	case CCP_WIN_A_TO_POSIX:
	case CCP_WIN_W_TO_POSIX:
	  stpcpy ((char *) to, buf);
	  break;
	case CCP_POSIX_TO_WIN_W:
	  wcpcpy ((PWCHAR) to, path);
	  break;
	}
      ret = 0;
d3398 1
a3398 3
  __except (EFAULT) {}
  __endtry
  return ret;
a3456 3
  tmp_pathbuf tp;
  char *tpath;

d3466 10
a3475 1
  __try
d3477 5
a3481 10
      /* Win32 drive letter paths have to be converted to a POSIX path first,
	 because path_conv leaves the incoming path untouched except for
	 converting backslashes to forward slashes. */
      if (isdrive (path))
	{
	  tpath = tp.c_get ();
	  mount_table->conv_to_posix_path (path, tpath, 0);
	}
      else
	tpath = (char *) path;
d3483 1
a3483 1
      path_conv real_path (tpath, PC_SYM_FOLLOW | PC_POSIX, stat_suffixes);
d3486 3
a3488 3
      /* POSIX 2008 requires malloc'ing if resolved is NULL, and states
	 that using non-NULL resolved is asking for portability
	 problems.  */
d3490 3
a3492 1
      if (!real_path.error && real_path.exists ())
d3494 1
d3496 4
a3499 16
	    {
	      resolved = (char *)
			 malloc (strlen (real_path.normalized_path) + 1);
	      if (!resolved)
		return NULL;
	    }
	  strcpy (resolved, real_path.normalized_path);
	  return resolved;
	}

      /* FIXME: on error, Linux puts the name of the path
	 component which could not be resolved into RESOLVED, but POSIX
	 does not require this.  */
      if (resolved)
	resolved[0] = '\0';
      set_errno (real_path.error ?: ENOENT);
d3501 7
a3507 2
  __except (EFAULT) {}
  __endtry
@


1.687
log
@	* path.cc (symlink_native): Workaround Windows 8.1 bug: Drop long path
	prefix from symlink target path.  Add comment to explain why.
@
text
@d4 1
a4 1
     2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d4648 1
a4648 1
      res = true;
@


1.686
log
@	Throughout, keep function definitions and declarations in sync with
	newlib in terms of C99 "restrict" keyword.
@
text
@a1555 1
      final_oldpath->Buffer[1] = L'\\';
a1592 1
	  final_oldpath->Buffer[1] = L'\\';
d1620 1
a1620 1
  /* Convert native path to DOS UNC path. */
d1623 19
d1647 1
a1647 1
      /* Repair native path, we still need it. */
@


1.685
log
@	Throughout, drop unnecessary explicit includes of windows header files
	included by default.
	* winlean.h: Add long comment to explain why we have to define certain
	symbols.
	(_NORMALIZE_): Define.
	(_WINNLS_): Drop definition and subsequent undef.
	(_WINNETWK_): Ditto.
	(_WINSVC_): Ditto.

2013-11-23  Eric Blake  <eblake@@redhat.com>
@
text
@d2992 1
a2992 1
readlink (const char *path, char *buf, size_t buflen)
d3416 1
a3416 1
realpath (const char *path, char *resolved)
@


1.684
log
@	* path.cc (normalize_posix_path): Don't check existence of / or // dir
	in parent dir check.
@
text
@a54 4
#include <wingdi.h>
#include <winuser.h>
#include <winnetwk.h>
#include <winnls.h>
@


1.683
log
@	* path.cc (normalize_posix_path): Start checking path before ".." at
	dst, rather than at dst_start, otherwise suffer loss of one leading
	slash in case of UNC paths.
@
text
@d314 8
a321 5
		      *tail = 0;
		      debug_printf ("checking %s before '..'", dst);
		      path_conv head (dst);
		      if (!head.isdir())
		        return ENOENT;
@


1.682
log
@	* path.cc (symlink_native): Fix common prefix search.  Enhance comment.
@
text
@d315 2
a316 2
		      debug_printf ("checking %s before '..'", dst_start);
		      path_conv head (dst_start);
@


1.681
log
@	* path.cc (find_fast_cwd_pointer): Use gas syntax for assembler
	description in all comments.  Make algorithm work on Windows 8.1
	Preview.
@
text
@d1573 6
a1578 5
      /* 1. Find common path prefix. */
      PWCHAR c_old = win32_oldpath.get_nt_native_path ()->Buffer;
      PWCHAR c_new = win32_newpath.get_nt_native_path ()->Buffer;
      /* Windows compatible == always check case insensitive. */
      while (towupper (*c_old++) == towupper (*c_new++))
@


1.680
log
@	* path.cc (cygwin_conv_path): Handle NULL "from" path gracefully.
	* path.sgml (func-cygwin-conv-path): Document returning EINVAL if
	"from" is NULL.
@
text
@d3947 1
a3947 1
      /* Search `mov rbx, rel(rip)'.  This is the instruction fetching the
d3955 5
a3959 2
      /* Search lea rcx, rel(rip).  This loads the address of the lock into
         $rcx for the subsequent RtlEnterCriticalSection call. */
d3963 9
a3971 1
        return NULL;
d3977 2
a3978 2
      /* Next is the call RtlEnterCriticalSection. */
      lock += 7;
d3986 1
a3986 1
	 for the `mov rbx, rel(rip)' instruction.  It follows right after
d4026 1
a4026 1
  /* Find first "push edi" instruction. */
d4028 2
a4029 2
  /* ...which should be followed by "mov edi, crit-sect-addr" then
     "push edi", or by just a single "push crit-sect-addr". */
d4032 1
a4032 1
  if (movedi[0] == 0x8b && movedi[1] == 0xff)	/* mov edi,edi -> W8 */
d4038 1
a4038 1
	 Next we search for a `mov eax, some address'.  This address points
d4066 8
@


1.679
log
@	* path.cc (cnt_bs): New inline function.
	(symlink_native): Fix creating relative native symlink.
@
text
@d3215 6
@


1.678
log
@	* path.cc (normalize_posix_path): Fix long-standing problem which
	allows to access files via ".." using an invalid POSIX path.
@
text
@d1533 12
d1551 1
d1570 42
a1611 4
      UNICODE_STRING dirpath;
      RtlSplitUnicodePath (win32_newpath.get_nt_native_path (), &dirpath, NULL);
      final_oldpath = win32_oldpath.get_nt_native_path ();
      final_oldpath->Buffer += dirpath.Length / sizeof (WCHAR);
@


1.677
log
@	* environ.cc (set_winsymlinks): Handle "winsymlinks:nativestrict"
	option.  On pre-Vista warn the user if the "winsymlinks:native*" option
	is set.
	* globals.cc (enum winsym_t): Add WSYM_nativestrict.
	* path.cc (symlink_native): Don't create native symlink if target
	does not exist.  Explain why.  Improve comments.
	(symlink_worker): Change AFS symlink handling to WSYM_nativestrict.
	Handle WSYM_nativestrict throughout.  Change condition for bail out
	to wsym_type == WSYM_nativestrict.  Add comment.  Fix formatting.
	* shared_info.h (CURR_USER_MAGIC): Change to reflect change in
	class user_info.
	(class user_info): Add member warned_nonativesyms.
@
text
@d243 1
d282 1
d306 15
@


1.676
log
@Throughout, (mainly in fhandler*) fix remaining gcc 4.7 mismatch
warnings between regparm definitions and declarations.
* smallprint.cc (__small_vswprintf): Conditionalize declaration and
setting of l_opt for only x86_64.
* spawn.cc (child_info_spawn::worker): Remove unused 'pid' variable.
* thread.cc (verifyable_object_isvalid): Temporarily define as
non-inline with gcc 4.7+, regardless of target.
@
text
@d1545 10
a1555 1
  /* Convert native to DOS UNC path. */
d1557 1
d1631 1
a1631 1
      wsym_type = WSYM_native;
d1634 1
a1634 1
  else if (wsym_type == WSYM_native
d1675 1
d1677 4
a1680 2
      /* AFS?  Too bad.  Otherwise, just try the default symlink type. */
      if (win32_newpath.fs_is_afs ())
d1685 1
d1870 2
a1871 1
  status = NtCreateFile (&fh, access, win32_newpath.get_object_attr (attr, sec_none_nih),
@


1.675
log
@	* autoload.cc (CreateSymbolicLink): Define.
	* environ.cc (set_winsymlinks): Set allow_winsymlinks.
	(parse_thing): Change "winsymlinks" to set by function.
	* globals.cc (enum winsym_t): Define.
	(allow_winsymlinks): Define as winsym_t.
	(ro_u_afs): New R/O Unicode string.
	* mount.cc (fs_info::update): Fix comment.  Handle AFS.
	(fs_names): Add "afs".
	* mount.h (enum fs_info_type): Add afs.
	(class fs_info): Implement afs.
	* path.cc (symlink): Drop third parameter in call to symlink_worker.
	(symlink_nfs): New function.
	(symlink_native): New function.
	(symlink_worker): Drop third argument.  Handle native symlink type by
	calling symlink_native.  Move code to handle NFS to symlink_nfs.  Fix
	formatting.  Slightly restructure code.
	* path.h (class path_conv): Add fs_is_afs method.
	(symlink_worker): Declare here.
	* security.h: Define privilege constants as unsigned int instead of as
	unsigned long.
	* syscalls.cc (mknod_worker): Set third parameter in symlink_worker
	call to WSYM_lnk.
	* winsup.h (symlink_worker): Drop declaration here.
@
text
@d346 1
a346 1
static void __stdcall
d1365 1
a1365 1
void __stdcall
d2954 1
a2954 1
ino_t __stdcall
d2968 1
a2968 1
ino_t __stdcall
d2976 1
a2976 1
ino_t __stdcall
@


1.674
log
@	* Merge in cygwin-64bit-branch.
@
text
@d1478 79
a1556 1
  return symlink_worker (oldpath, newpath, allow_winsymlinks, false);
d1560 1
a1560 2
symlink_worker (const char *oldpath, const char *newpath, bool use_winsym,
		bool isdevice)
d1564 1
a1564 1
  path_conv win32_newpath, win32_oldpath;
a1565 6
  SECURITY_ATTRIBUTES sa = sec_none_nih;
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;
  NTSTATUS status;
  HANDLE fh;
  ULONG access = DELETE | FILE_GENERIC_WRITE;
a1567 1
  bool mk_winsym = use_winsym;
d1569 1
d1601 7
d1610 17
a1626 1
  mk_winsym |= win32_newpath.fs_is_mvfs ();
d1628 2
a1629 1
  if (mk_winsym && !win32_newpath.exists ()
d1643 2
a1644 2
  syscall_printf ("symlink (%s, %S)", oldpath,
		  win32_newpath.get_nt_native_path ());
d1658 2
a1659 1
  if (!isdevice && win32_newpath.fs_is_nfs ())
d1661 7
a1667 17
      /* On NFS, create symlinks by calling NtCreateFile with an EA of type
	 NfsSymlinkTargetName containing ... the symlink target name. */
      PFILE_FULL_EA_INFORMATION pffei = (PFILE_FULL_EA_INFORMATION) tp.w_get ();
      pffei->NextEntryOffset = 0;
      pffei->Flags = 0;
      pffei->EaNameLength = sizeof (NFS_SYML_TARGET) - 1;
      char *EaValue = stpcpy (pffei->EaName, NFS_SYML_TARGET) + 1;
      pffei->EaValueLength = sizeof (WCHAR) *
	(sys_mbstowcs ((PWCHAR) EaValue, NT_MAX_PATH, oldpath) - 1);
      status = NtCreateFile (&fh, FILE_WRITE_DATA | FILE_WRITE_EA | SYNCHRONIZE,
			     win32_newpath.get_object_attr (attr, sa),
			     &io, NULL, FILE_ATTRIBUTE_SYSTEM,
			     FILE_SHARE_VALID_FLAGS, FILE_CREATE,
			     FILE_SYNCHRONOUS_IO_NONALERT
			     | FILE_OPEN_FOR_BACKUP_INTENT,
			     pffei, NT_MAX_PATH * sizeof (WCHAR));
      if (!NT_SUCCESS (status))
d1669 1
a1669 1
	  __seterrno_from_nt_status (status);
d1672 4
a1675 3
      NtClose (fh);
      res = 0;
      goto done;
d1678 1
a1678 1
  if (mk_winsym)
d1680 1
d1695 5
a1699 5
	if (isabspath (oldpath))
	  win32_oldpath.check (oldpath,
			       PC_SYM_NOFOLLOW,
			       stat_suffixes);
	else
d1768 1
a1768 1
	buf = (char *) tp.w_get ();
d1812 1
a1812 1
      buf = (char *) tp.w_get ();
d1820 7
d1830 1
a1830 1
			   win32_newpath.get_object_attr (attr, sa),
d1856 1
a1856 1
  status = NtCreateFile (&fh, access, win32_newpath.get_object_attr (attr, sa),
d1876 3
a1878 2
      status = NtSetAttributesFile (fh, mk_winsym ? FILE_ATTRIBUTE_READONLY
						  : FILE_ATTRIBUTE_SYSTEM);
d1895 2
a1896 2
  syscall_printf ("%d = symlink_worker(%s, %s, %d, %d)", res, oldpath,
		  newpath, mk_winsym, isdevice);
@


1.673
log
@	* path.cc (symlink_info::check): Drop PC_KEEP_HANDLE flag for
	unrecognized reparse points as well.  Reorganize code and comments
	handling reparse points for better readability.
@
text
@d530 1
a530 1
      FILE_BOTH_DIRECTORY_INFORMATION fdi;
d1216 1
a1216 1
  if (status == STATUS_INVALID_PARAMETER || status == STATUS_NOT_IMPLEMENTED)
d1219 1
a1219 2
	 share root dirs hosted on NT4 (STATUS_INVALID_PARAMETER), or when
	 accessing SMB share root dirs from NT4 (STATUS_NOT_IMPLEMENTED). */
d1652 5
a1656 6
	 length of MAX_PATH up to NT4, and to a length of 2000 bytes
	 since W2K.  We don't want to add considerations for the different
	 lengths and even 2000 bytes is not enough for long path names.
	 So what we do here is to set the description to the POSIX path
	 only if the path is not longer than MAX_PATH characters.  We
	 append the full path name after the regular shortcut data
d1784 1
a1784 1
	debug_printf ("Setting attributes failed, status = %p", status);
d1794 1
a1794 1
	debug_printf ("Setting delete dispostion failed, status = %p", status);
d1839 1
a1839 1
  if (fsi.EndOfFile.QuadPart <= sizeof (win_shortcut_hdr)
d1914 1
a1914 1
      debug_printf ("ReadFile1 failed %p", status);
d2001 1
a2001 1
      debug_printf ("NtFsControlFile(FSCTL_GET_REPARSE_POINT) failed, %p",
d2413 1
a2413 1
      debug_printf ("%p = NtCreateFile (%S)", status, &upath);
d2436 1
a2436 1
	  debug_printf ("%p = NtOpenFile (no-EAs %S)", status, &upath);
d2452 1
a2452 1
	      debug_printf ("%p = NtOpenFile (broken-UDF, %S)", status, &upath);
d2505 16
d2543 1
a2543 1
	  debug_printf ("%p = NtQueryInformationFile (%S)", status, &upath);
d2576 1
a2576 1
		FILE_BOTH_DIRECTORY_INFORMATION fdi;
d2590 1
a2590 1
		  debug_printf ("%p = NtOpenFile(%S)", status, &dirname);
d2610 1
a2610 1
		      debug_printf ("%p = NtQueryDirectoryFile(%S)",
d2788 1
a2788 1
  syscall_printf ("%d = symlink.check(%s, %p) (%p)",
d2826 1
a2826 1
      syscall_printf ("-1 = readlink (%s, %p, %d)", path, buf, buflen);
d2858 2
a2859 2
__ino64_t __stdcall
hash_path_name (__ino64_t hash, PUNICODE_STRING name)
d2872 2
a2873 2
__ino64_t __stdcall
hash_path_name (__ino64_t hash, PCWSTR name)
d2880 2
a2881 2
__ino64_t __stdcall
hash_path_name (__ino64_t hash, const char *name)
d2885 1
a2885 1
  __ino64_t ret = hash_path_name (hash, &uname);
d2916 1
a2916 1
  struct __stat64 pwdbuf, cwdbuf;
d2958 1
a2958 1
  int devn = path.get_devn ();
d3194 1
d3226 2
d3364 8
a3384 7
extern "C" ssize_t
env_PATH_to_posix (const void *win32, void *posix, size_t size)
{
  return_with_errno (conv_path_list ((const char *) win32, (char *) posix,
				     size, ENV_CVT));
}

d3399 2
a3407 1
  size_t orig_size = (size_t) -1;
a3424 1
      orig_size = size;
a3705 2
#define peek32(x)	(*(uint32_t *)(x))

d3715 93
d3838 2
a3839 3
      /* Windows 8 CP 32 bit (after a Windows Update?) does not call
	 RtlEnterCriticalSection.  For some reason the function manipulates
	 the FastPebLock manually, kind of like RtlEnterCriticalSection has
d3893 1
d4018 1
a4018 1
		  debug_printf ("RtlSetCurrentDirectory_U(%S) failed, %p",
d4388 1
a4388 1
  syscall_printf ("(%s) = cwdstuff::get (%p, %d, %d, %d), errno %d",
d4429 1
a4429 1
      debug_printf ("NtQueryFullAttributesFile (%S) failed, %p",
d4467 1
a4467 1
	      system_printf ("NtOpenFile (%S) failed, %p",
d4482 1
a4482 1
		  system_printf ("NtNotifyChangeDirectoryFile (1) failed, %p",
d4504 1
a4504 1
	      system_printf ("NtNotifyChangeDirectoryFile (2) failed, %p",
@


1.672
log
@	* path.cc (class suffix_scan): Add member namelen.
	(suffix_scan::name_len): New method.
	(suffix_scan::has): Store namelen since we have it already anyway.
	Add a bit of explanation and a FIXME to comment.
	(suffix_scan::next): Never attach extra .lnk suffix if resulting
	filename length exceeds NAME_LEN.
	(symlink_info::check): Bail out immediately with ENAMETOOLONG if
	filename length exceeds NAME_LEN.
@
text
@d2656 1
a2656 1
	  if (res == -1)
d2658 13
a2670 1
	      /* Volume mount point.  The filesystem information for the top
d2676 2
a2677 12
	      fs.update (&upath, NULL);
	      /* Make sure the open handle is not used in later stat calls.
		 The handle has been opened with the FILE_OPEN_REPARSE_POINT
		 flag, so it's a handle to the reparse point, not a handle
		 to the volumes root dir. */
	      pflags &= ~PC_KEEP_HANDLE;
	    }
	  else if (res)
	    {
	      /* A symlink is never a directory. */
	      conv_hdl.fnoi ()->FileAttributes &= ~FILE_ATTRIBUTE_DIRECTORY;
	      break;
@


1.671
log
@Throughout, change __attribute__ ((regparm (N))) to just __regN.  Throughout,
(mainly in fhandler*) start fixing gcc 4.7.2 mismatch between regparm
definitions and declarations.
* gendef: Define some functions to take @@ declaration to accommodate _regN
defines which use __stdcall.
* gentls_offsets: Define __regN macros as empty.
* autoload.cc (wsock_init): Remove unneeded regparm attribute.
* winsup.h (__reg1): Define.
(__reg2): Define.
(__reg3): Define.
* advapi32.cc (DuplicateTokenEx): Coerce some initializers to avoid warnings
from gcc 4.7.2.
* exceptions.cc (status_info): Declare struct to use NTSTATUS.
(cygwin_exception::dump_exception): Coerce e->ExceptionCode to NTSTATUS.
* fhandler_clipboard.cc (cygnativeformat): Redefine as UINT to avoid gcc 4.7.2
warnings.
(fhandler_dev_clipboard::read): Ditto.
@
text
@d2150 1
d2156 1
d2197 9
a2205 2
  /* Avoid attaching suffixes if the resulting filename would be invalid. */
  if (eopath - fname > NAME_MAX - 4)
d2246 6
a2252 1
	    nextstate = SCAN_DONE;
d2260 2
a2261 1
	if (nextstate == SCAN_EXTRALNK && !suffixes->addon)
d2380 3
d2385 1
d2387 6
a2392 2
  PVOID eabuf = &nfs_aol_ffei;
  ULONG easize = sizeof nfs_aol_ffei;
a2393 1
  bool had_ext = !!*ext_here;
@


1.670
log
@whitespace cleanup
@
text
@d4 1
a4 1
     2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d344 1
a344 2
static void __stdcall mkrelpath (char *dst, bool caseinsensitive)
  __attribute__ ((regparm (2)));
@


1.669
log
@	* path.cc (etc::dir_changed): Revert muto changes since function is
	called under lock condition anyway.
@
text
@d895 1
a895 1
	         make sure that the device type is converted to FH_FS, so that
d3707 1
a3707 1
         RtlEnterCriticalSection.  For some reason the function manipulates
@


1.669.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d2821 2
a2822 2
ino_t __stdcall
hash_path_name (ino_t hash, PUNICODE_STRING name)
d2835 2
a2836 2
ino_t __stdcall
hash_path_name (ino_t hash, PCWSTR name)
d2843 2
a2844 2
ino_t __stdcall
hash_path_name (ino_t hash, const char *name)
d2848 1
a2848 1
  ino_t ret = hash_path_name (hash, &uname);
d2879 1
a2879 1
  struct stat pwdbuf, cwdbuf;
@


1.669.2.2
log
@	Pull in changes from HEAD
	ChangeLog.64bit: New file.
@
text
@d895 1
a895 1
		 make sure that the device type is converted to FH_FS, so that
d3707 1
a3707 1
	 RtlEnterCriticalSection.  For some reason the function manipulates
@


1.669.2.3
log
@	Avoid various type ambiguity problems showing up in the 64 bit case:
	* cygheap.h (cygheap_user::set_sid): Convert to void.
	(cygheap_user::set_saved_sid): Ditto.
	* devices.h (struct device): Drop operator int& and DWORD& entirely.
	Throughout, use dev_t or fh_devices instead.
	* devices.cc: Regenerate.
	* fhandler.h (class fhandler_base): Convert _refcnt member to LONG.
	(fhandler_base::inc_refcnt): Return LONG.
	(fhandler_base::dec_refcnt): Ditto.
	(fhandler_base::get_major): Return _major_t.
	(fhandler_base::get_minor): Return _minor_t.
	(fhandler_base::get_unit): Delete.  Throughout, use get_minor instead
	of get_unit.
	(fhandler_socket::get_socket): Use SOCKET rather than int.  Only define
	if __INSIDE_CYGWIN_NET__ is defined.
	(fhandler_pty_slave::get_unit): Drop declaration.
	* fhandler_procnet.cc: Include Windows headers early.
	* fhandler_socket.cc: Ditto.
	* fhandler_tty.cc (fhandler_pty_slave::get_unit): Remove.
	* path.h (path_conv::get_device): Rename from get_devn and change return
	type to dev_t.  Accommodate throughout.
	(path_conv::get_unitn): Remove unused method.
	* pinfo.h (class pinfo): Drop operator== for int case.
	(pinfo::operator!): Define.
	* poll.cc: Don't define __INSIDE_CYGWIN_NET__.
	* syscalls.cc (getpgid): Replace use of pinfo::operator== with
	pinfo::operator!.
	* tty.h (tty_min::setntty): Convert 2nd parameter to _minor_t.
	* tty.h (tty_min::getntty): Change return type to dev_t.
	(tty_min::get_minor): Rename from get_unit.  Change return type to
	_minor_t.
@
text
@d2921 1
a2921 1
  dev_t devn = path.get_device ();
@


1.669.2.4
log
@	* cygheap.h (class fcwd_access_t): Add alignment attribute to Buffer
	member of FAST_CWD_* structures to work on 64 bit.
	* path.cc (symlink_info::check_shortcut): Add cast to avoid compiler
	warning.
	(cygwin_conv_path_list): Drop ununsed variable.
	(peek32): Define with int32_t cast on 64 bit to allow easier fetching
	of instruction pointer relative addresses.
	(find_fast_cwd_pointer): Add new implementation for x86_64.
	Tweak a comment in 32 bit version.
@
text
@d1842 1
a1842 1
  if (fsi.EndOfFile.QuadPart <= (LONGLONG) sizeof (win_shortcut_hdr)
d3365 1
d3383 1
d3665 2
a3675 93

#ifdef __x86_64__

#define peek32(x)	(*(int32_t *)(x))

static fcwd_access_t **
find_fast_cwd_pointer ()
{
  /* Fetch entry points of relevant functions in ntdll.dll. */
  HMODULE ntdll = GetModuleHandle ("ntdll.dll");
  if (!ntdll)
    return NULL;
  const uint8_t *get_dir = (const uint8_t *)
			   GetProcAddress (ntdll, "RtlGetCurrentDirectory_U");
  const uint8_t *ent_crit = (const uint8_t *)
			    GetProcAddress (ntdll, "RtlEnterCriticalSection");
  if (!get_dir || !ent_crit)
    return NULL;
  /* Search first relative call instruction in RtlGetCurrentDirectory_U. */
  const uint8_t *rcall = (const uint8_t *) memchr (get_dir, 0xe8, 40);
  if (!rcall)
    return NULL;
  /* Fetch offset from instruction and compute address of called function.
     This function actually fetches the current FAST_CWD instance and
     performs some other actions, not important to us. */
  const uint8_t *use_cwd = rcall + 5 + peek32 (rcall + 1);
  /* Next we search for the locking mechanism and perform a sanity check.
     On Pre-Windows 8 we basically look for the RtlEnterCriticalSection call.
     Windows 8 does not call RtlEnterCriticalSection.  The code manipulates
     the FastPebLock manually, probably because RtlEnterCriticalSection has
     been converted to an inline function.  Either way, we test if the code
     uses the FastPebLock. */
  const uint8_t *movrbx;
  const uint8_t *lock = (const uint8_t *)
                        memmem ((const char *) use_cwd, 80,
                                "\xf0\x0f\xba\x35", 4);
  if (lock)
    {
      /* The lock instruction tweaks the LockCount member, which is not at
      	 the start of the PRTL_CRITICAL_SECTION structure.  So we have to
	 subtract the offset of LockCount to get the real address. */
      PRTL_CRITICAL_SECTION lockaddr =
        (PRTL_CRITICAL_SECTION) (lock + 9 + peek32 (lock + 4)
                                 - offsetof (RTL_CRITICAL_SECTION, LockCount));
      /* Test if lock address is FastPebLock. */
      if (lockaddr != NtCurrentTeb ()->Peb->FastPebLock)
        return NULL;
      /* Search `mov rbx, rel(rip)'.  This is the instruction fetching the
         address of the current fcwd_access_t pointer, and it should be pretty
	 near to the locking stuff. */
      movrbx = (const uint8_t *) memmem ((const char *) lock, 40,
                                         "\x48\x8b\x1d", 3);
    }
  else
    {
      /* Search lea rcx, rel(rip).  This loads the address of the lock into
         $rcx for the subsequent RtlEnterCriticalSection call. */
      lock = (const uint8_t *) memmem ((const char *) use_cwd, 80,
                                       "\x48\x8d\x0d", 3);
      if (!lock)
        return NULL;
      PRTL_CRITICAL_SECTION lockaddr =
        (PRTL_CRITICAL_SECTION) (lock + 7 + peek32 (lock + 3));
      /* Test if lock address is FastPebLock. */
      if (lockaddr != NtCurrentTeb ()->Peb->FastPebLock)
        return NULL;
      /* Next is the call RtlEnterCriticalSection. */
      lock += 7;
      if (lock[0] != 0xe8)
        return NULL;
      const uint8_t *call_addr = (const uint8_t *)
                                 (lock + 5 + peek32 (lock + 1));
      if (call_addr != ent_crit)
        return NULL;
      /* In contrast to the above Windows 8 code, we don't have to search
	 for the `mov rbx, rel(rip)' instruction.  It follows right after
	 the call to RtlEnterCriticalSection. */
      movrbx = lock + 5;
    }
  if (!movrbx)
    return NULL;
  /* Check that the next instruction tests if the fetched value is NULL. */
  const uint8_t *testrbx = (const uint8_t *)
			   memmem (movrbx + 7, 3, "\x48\x85\xdb", 3);
  if (!testrbx)
    return NULL;
  /* Compute address of the fcwd_access_t ** pointer. */
  return (fcwd_access_t **) (testrbx + peek32 (movrbx + 3));
}
#else

#define peek32(x)	(*(uint32_t *)(x))

d3706 3
a3708 2
      /* Windows 8 does not call RtlEnterCriticalSection.  The code manipulates
      	 the FastPebLock manually, probably because RtlEnterCriticalSection has
a3761 1
#endif
@


1.669.2.5
log
@	* ntdll.h: Mark more native structures as tested on 64 bit.
	(struct _FILE_BOTH_DIR_INFORMATION): Rename from
	_FILE_BOTH_DIRECTORY_INFORMATION as per WDK documentation.
	* fhandler_disk_file.cc: Accommodate aforementioned structure name
	change.
	* path.cc: Ditto.
@
text
@d531 1
a531 1
      FILE_BOTH_DIR_INFORMATION fdi;
d2541 1
a2541 1
		FILE_BOTH_DIR_INFORMATION fdi;
@


1.669.2.6
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d1787 1
a1787 1
	debug_printf ("Setting attributes failed, status = %y", status);
d1797 1
a1797 1
	debug_printf ("Setting delete dispostion failed, status = %y", status);
d1917 1
a1917 1
      debug_printf ("ReadFile1 failed %y", status);
d2004 1
a2004 1
      debug_printf ("NtFsControlFile(FSCTL_GET_REPARSE_POINT) failed, %y",
d2394 1
a2394 1
      debug_printf ("%y = NtCreateFile (%S)", status, &upath);
d2417 1
a2417 1
	  debug_printf ("%y = NtOpenFile (no-EAs %S)", status, &upath);
d2433 1
a2433 1
	      debug_printf ("%y = NtOpenFile (broken-UDF, %S)", status, &upath);
d2508 1
a2508 1
	  debug_printf ("%y = NtQueryInformationFile (%S)", status, &upath);
d2555 1
a2555 1
		  debug_printf ("%y = NtOpenFile(%S)", status, &dirname);
d2575 1
a2575 1
		      debug_printf ("%y = NtQueryDirectoryFile(%S)",
d2751 1
a2751 1
  syscall_printf ("%d = symlink.check(%s, %p) (%y)",
d2789 1
a2789 1
      syscall_printf ("-1 = readlink (%s, %p, %lu)", path, buf, buflen);
d3975 1
a3975 1
		  debug_printf ("RtlSetCurrentDirectory_U(%S) failed, %y",
d4345 1
a4345 1
  syscall_printf ("(%s) = cwdstuff::get (%p, %u, %d, %d), errno %d",
d4386 1
a4386 1
      debug_printf ("NtQueryFullAttributesFile (%S) failed, %y",
d4424 1
a4424 1
	      system_printf ("NtOpenFile (%S) failed, %y",
d4439 1
a4439 1
		  system_printf ("NtNotifyChangeDirectoryFile (1) failed, %y",
d4461 1
a4461 1
	      system_printf ("NtNotifyChangeDirectoryFile (2) failed, %y",
@


1.669.2.7
log
@Pull in changes from HEAD
@
text
@d4 1
a4 1
     2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d344 2
a345 1
static void __reg2 mkrelpath (char *dst, bool caseinsensitive);
@


1.669.2.8
log
@	* cygwin64.din: Remove all deprecated cygwin32_foo and cygwin_foo
	path conversion functions.
	* path.cc: Disable aforementioned functions on x86_64.
	* include/sys/cygwin.h: Don't declare aforementioned functions on
	x86_64.
@
text
@a3155 1
#ifndef __x86_64__	/* Disable deprecated functions on x86_64. */
a3186 2
#endif /* !__x86_64__ */

a3322 8
extern "C" ssize_t
env_PATH_to_posix (const void *win32, void *posix, size_t size)
{
  return_with_errno (conv_path_list ((const char *) win32, (char *) posix,
				     size, ENV_CVT));
}

#ifndef __x86_64__	/* Disable deprecated functions on x86_64. */
d3336 7
a3356 2
#endif /* !__x86_64__ */

@


1.669.2.9
log
@	Remove more old cruft.  Remove Windows NT4 and 2000 from comments
	throughout, unless it still makes sense.
	* dlfcn.cc (dlopen): Drop W2K-only code to make loaded DLL persistent.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Drop code
	trying to use information from NtQueryVolumeInformationFile.
	* fhandler_socket.cc (fhandler_socket::close): Drop code snippet
	disabled since 2008.
	* mount.cc (MINIMAL_WIN_NTFS_FLAGS): Add flag values set on all
	NTFS since Windows XP.
	(get_volume_path_names_for_volume_name): Remove.
	(dos_drive_mappings::dos_drive_mappings): Call Win32 function
	GetVolumePathNamesForVolumeNameW directly.
	* path.cc (file_get_fnoi): Drop test for NT4-only return code.
	* sched.cc: Add FIXME to global comment.  Reformat comments throughout.
	* spawn.cc (child_info_spawn::worker): Just call official IsProcessInJob
	function rather than to test undocumented TEB member.
	* winlean.h: Drop Mingw32-related defines.
	* include/limits.h (PTHREAD_KEYS_MAX): Raise value to reflect minimum
	value available on XP and later.

2013-03-13  Corinna Vinschen  <corinna@@vinschen.de>
@
text
@d1216 1
a1216 1
  if (status == STATUS_INVALID_PARAMETER)
d1219 2
a1220 1
	 share root dirs hosted on NT4. */
d1653 6
a1658 5
	 length of 2000 bytes.  We don't want to add considerations for
	 the different lengths and even 2000 bytes is not enough for long
	 path names.  So what we do here is to set the description to the
	 POSIX path only if the path is not longer than MAX_PATH characters.
	 We append the full path name after the regular shortcut data
@


1.669.2.10
log
@	* ntdll.h (STATUS_NETWORK_OPEN_RESTRICTION): Define.
	(STATUS_SYMLINK_CLASS_DISABLED): Define.
	* path.cc (symlink_info::check): Handle STATUS_NETWORK_OPEN_RESTRICTION
	and STATUS_SYMLINK_CLASS_DISABLED status codes.  Explain why.
@
text
@a2482 16
      else if (status == STATUS_NETWORK_OPEN_RESTRICTION
	       || status == STATUS_SYMLINK_CLASS_DISABLED)
	{
	  /* These status codes are returned if you try to open a native
	     symlink and the usage of this kind of symlink is forbidden
	     (see fsutil).  Since we can't open them at all, not even for
	     stat purposes, we have to return a POSIX error code which is
	     at least a bit helpful.

	     Additionally Windows 8 introduces a bug in NFS: If you have
	     a symlink to a directory, with symlinks underneath, resolving
	     the second level of symlinks fails if remote->remote symlinks
	     are disabled in fsutil.  Unfortunately that's the default. */
	  set_error (ELOOP);
	  break;
	}
@


1.669.2.11
log
@Pull in partial changes from HEAD
@
text
@a2147 1
  size_t namelen;
a2152 1
  size_t name_len () {return namelen;}
d2193 2
a2194 9
  namelen = eopath - fname;
  /* Avoid attaching suffixes if the resulting filename would be invalid.
     For performance reasons we don't check the length of a suffix, since
     we know that all suffixes are 4 chars in length.
     
     FIXME: This is not really correct.  A fully functional test should
            work on wide character paths.  This would probably also speed
	    up symlink_info::check. */
  if (namelen > NAME_MAX - 4)
d2235 1
a2236 6
	    if (namelen + (*eopath ? 8 : 4) > NAME_MAX)
	      {
		*eopath = '\0';
		return 0;
	      }
	    strcat (eopath, ".lnk");
d2244 1
a2244 2
	if (nextstate == SCAN_EXTRALNK
	    && (!suffixes->addon || namelen > NAME_MAX - 8))
d2363 3
a2368 2
  ext_here = suffix.has (path, suffixes);
  extn = ext_here - path;
a2369 8

  /* If the filename is too long, don't even try. */
  if (suffix.name_len () > NAME_MAX)
    {
      set_error (ENAMETOOLONG);
      goto file_not_symlink;
    }

@


1.669.2.12
log
@Pull in changes from HEAD
@
text
@d2670 1
a2670 1
	  if (res > 0)
d2672 1
a2672 13
	      /* A symlink is never a directory. */
	      conv_hdl.fnoi ()->FileAttributes &= ~FILE_ATTRIBUTE_DIRECTORY;
	      break;
	    }
	  else
	    {
	      /* Volume moint point or unrecognized reparse point type.
		 Make sure the open handle is not used in later stat calls.
		 The handle has been opened with the FILE_OPEN_REPARSE_POINT
		 flag, so it's a handle to the reparse point, not a handle
		 to the volumes root dir. */
	      pflags &= ~PC_KEEP_HANDLE;
	      /* Volume mount point:  The filesystem information for the top
d2678 12
a2689 2
	      if (res == -1)
		fs.update (&upath, NULL);
@


1.668
log
@	* path.cc (etc::dir_changed): Change `io' to a static NO_COPY
	variable.  Explain why.  Add a muto to guard overwriting the changed_h
	handle by multiple concurrent threads.
	* path.h (class etc): Drop unused changed_h member.
@
text
@a4313 2
  static muto lock NO_COPY;
  static HANDLE changed_h NO_COPY;
d4318 1
d4328 5
a4332 2
	  lock.init ("etc_dir_changed_lock")->acquire ();
	  if (!changed_h)
a4333 8
	      path_conv dir ("/etc");
	      status = NtOpenFile (&changed_h,
				   SYNCHRONIZE | FILE_LIST_DIRECTORY,
				   dir.get_object_attr (attr, sec_none_nih),
				   &io, FILE_SHARE_VALID_FLAGS,
				   FILE_DIRECTORY_FILE);
	      if (!NT_SUCCESS (status))
		{
d4335 2
a4336 2
		  system_printf ("NtOpenFile (%S) failed, %p",
				 dir.get_nt_native_path (), status);
d4338 5
a4342 5
		  changed_h = INVALID_HANDLE_VALUE;
		}
	      else
		{
		  status = NtNotifyChangeDirectoryFile (changed_h, NULL, NULL,
d4347 2
a4348 2
		  if (!NT_SUCCESS (status))
		    {
d4350 2
a4351 2
		      system_printf ("NtNotifyChangeDirectoryFile (1) failed, "
				     "%p", status);
d4353 2
a4354 3
		      NtClose (changed_h);
		      changed_h = INVALID_HANDLE_VALUE;
		    }
a4355 1
	      memset (change_possible, true, sizeof (change_possible));
d4357 1
a4357 1
	  lock.release ();
@


1.667
log
@* fhandler_termios.cc (fhandler_termios::line_edit): Use special case '%0c'
handling to print non-printable characters using hex notation.
* smallprint.cc (__small_vsprintf): Semi-reimplement printing of non-printable
characters in hex but only when padding is specified.
* dcrt0.cc (dll_crt0_0): Remove tty_list initialization.
* shared.cc (memory_init): Initialize tty_list here.
* path.cc (path_conv::check): Remove unneeded parentheses from if check.
@
text
@d4314 7
a4322 1
      static HANDLE changed_h NO_COPY;
a4323 1
      IO_STATUS_BLOCK io;
d4329 2
a4330 5
	  path_conv dir ("/etc");
	  status = NtOpenFile (&changed_h, SYNCHRONIZE | FILE_LIST_DIRECTORY,
			       dir.get_object_attr (attr, sec_none_nih), &io,
			       FILE_SHARE_VALID_FLAGS, FILE_DIRECTORY_FILE);
	  if (!NT_SUCCESS (status))
d4332 8
d4341 2
a4342 2
	      system_printf ("NtOpenFile (%S) failed, %p",
			     dir.get_nt_native_path (), status);
d4344 5
a4348 5
	      changed_h = INVALID_HANDLE_VALUE;
	    }
	  else
	    {
	      status = NtNotifyChangeDirectoryFile (changed_h, NULL, NULL,
d4353 2
a4354 2
	      if (!NT_SUCCESS (status))
		{
d4356 2
a4357 2
		  system_printf ("NtNotifyChangeDirectoryFile (1) failed, %p",
				 status);
d4359 3
a4361 2
		  NtClose (changed_h);
		  changed_h = INVALID_HANDLE_VALUE;
d4363 1
d4365 1
a4365 1
	  memset (change_possible, true, sizeof (change_possible));
@


1.666
log
@* path.cc (symlink_info::check): Remove unneeded/unused variable.
@
text
@d1156 1
a1156 1
  if ((opt & PC_POSIX))
@


1.665
log
@* path.cc: Perform some whitespace fixups throughout.
@
text
@a2374 2
      bool no_ea = false;

a2404 1
	  no_ea = true;
@


1.664
log
@	* path.cc (realpath): Fix comment.
@
text
@d115 2
a116 1
enum {
d127 18
a144 18
  {
    DWORD size;		/* Header size in bytes.  Must contain 0x4c. */
    GUID magic;		/* GUID of shortcut files. */
    DWORD flags;	/* Content flags.  See above. */

    /* The next fields from attr to icon_no are always set to 0 in Cygwin
       and U/Win shortcuts. */
    DWORD attr;	/* Target file attributes. */
    FILETIME ctime;	/* These filetime items are never touched by the */
    FILETIME mtime;	/* system, apparently. Values don't matter. */
    FILETIME atime;
    DWORD filesize;	/* Target filesize. */
    DWORD icon_no;	/* Icon number. */

    DWORD run;		/* Values defined in winuser.h. Use SW_NORMAL. */
    DWORD hotkey;	/* Hotkey value. Set to 0.  */
    DWORD dummy[2];	/* Future extension probably. Always 0. */
  };
d1355 2
a1356 2
   if (tail > dst + 1 && tail[-1] == '.' && tail[-2] == '\\')
     tail--;
@


1.663
log
@	* path.cc (realpath): Call mount_info::conv_to_posix_path rather than
	mount_info::cygdrive_posix_path to convert DOS paths to POSIX paths.
	Add comment to explain why that's necessary at all.
@
text
@d3210 2
a3211 2
     because path_conv lets the incoming path untouched except for converting
     backslashes to forward slashes. */
@


1.662
log
@	* path.cc (find_fast_cwd_pointer): Fix for W8 CP 32 bit.
@
text
@d3209 3
d3216 1
a3216 1
      mount_table->cygdrive_posix_path (path, tpath, 0);
@


1.661
log
@* dtable.cc (fh_alloc): Only disallow opening of nonexistent on-disk device.
* path.cc (path_conv::check): Remove PATH_KEPT_HANDLE setting.
* path.h (path_types): Remove PATH_KEPT_HANDLE.
(path_conv::kept_handle): Delete now-unneeded function.
@
text
@d3702 30
a3731 4
  if (movedi[0] == 0xbf && movedi[5] == 0x57)
    rcall = movedi + 6;
  else if (movedi[0] == 0x68)
    rcall = movedi + 5;
d3733 22
a3754 14
    return NULL;
  /* Compare the address used for the critical section with the known
     PEB lock as stored in the PEB. */
  if ((PRTL_CRITICAL_SECTION) peek32 (movedi + 1)
      != NtCurrentTeb ()->Peb->FastPebLock)
    return NULL;
  /* To check we are seeing the right code, we check our expectation that
     the next instruction is a relative call into RtlEnterCriticalSection. */
  if (rcall[0] != 0xe8)
    return NULL;
  /* Check that this is a relative call to RtlEnterCriticalSection. */
  offset = (ptrdiff_t) peek32 (rcall + 1);
  if (rcall + 5 + offset != ent_crit)
    return NULL;
d3757 1
a3757 2
  const uint8_t *movesi = rcall + 5;
  if (movesi[0] != 0x8b)
d3759 1
a3759 1
  return (fcwd_access_t **) peek32 (movesi + 2);
@


1.660
log
@* dtable.cc (fh_alloc): Keep fh which was flagged as error if it is for an
on-disk device and we were stating it.
* path.cc (path_conv::check): Set PATH_KEPT_HANDLE.
* path.h (path_types): Add PATH_KEPT_HANDLE.
(path_conv::kept_handle): Implement.
@
text
@a1154 3
  if (opt & PC_KEEP_HANDLE)
    path_flags |= PATH_KEPT_HANDLE;

@


1.659
log
@* dtable.cc (cygwin_attach_handle_to_fd): Defend against NULL return from
build_fh_*.
(dtable::init_std_file_from_handle): Ditto.
* mmap.cc (mmap_record::alloc_fh): Ditto.
* path.cc (path_conv::check): Ditto.
@
text
@d1155 3
@


1.658
log
@* path.c (path_conv::check): Avoid directly referencing fields of the dev
structure when it can be easily avoided.
@
text
@d747 4
a750 2
	      virtual_ftype_t file_type = fh->exists ();
	      if (file_type == virt_symlink)
d752 7
a758 2
		  fh->fill_filebuf ();
		  symlen = sym.set (fh->get_filebuf ());
a759 1
	      delete fh;
@


1.657
log
@	* fhandler_nodevice.cc (fhandler_nodevice::open): Convert EROFS to
	ENOENT if non-existent file got opened for reading only.  Explain why.
	* path.cc (path_conv::check): Stick to ENOENT if file has been opened
	for informational purposes only.  Add to comment.
@
text
@d899 1
a899 1
		dev.d.devn = FH_FS;
@


1.656
log
@	* path.cc (path_conv::check): Convert device type to FH_FS for
	non-existant files on /dev, unless /dev itself doesn't exist on disk.
	Add comment to explain why.
@
text
@d892 5
a896 2
		 read-only. */
	      if (sym.error == ENOENT)
@


1.655
log
@	* devices.h (FH_CYGDRIVE): Define as DEV_VIRTFS_MAJOR class device.
	(DEV_CYGDRIVE_MAJOR): Remove.
	(iscygdrive_dev): Define.
	* dtable.cc (fh_alloc): Accommodate above change.
	* path.cc (path_conv::check): Use iscygdrive_dev to check for cygdrive.
	* syscalls.cc (fhandler_base::set_ino_and_dev): Drop check for
	DEV_CYGDRIVE_MAJOR from conditional.
@
text
@d885 13
@


1.654
log
@	* devices.cc: Regenerate.
	* devices.h (device::exists_func): New member function pointer,
	replacing noexpose.
	(device::expose): Remove.
	(device::exists_never): Declare.
	(device::exists_ptys): Declare.
	(device::exists_cons): Declare.
	(device::exists_console): Declare.
	(device::exists_nt_dev): Declare.
	(device::exists): Declare.
	* devices.in (dev_storage): Replace former noexpose values with
	pointers to matching exists_XXX method.
	(device::exists_never): New method.
	(device::exists_ptys): New method.
	(device::exists_cons): New method.
	(device::exists_console): New method.
	(device::exists_nt_dev): New method.
	(device::exists): New method.
	* fhandler_dev.cc (fhandler_dev::readdir): Replace call to
	device::expose with call to device::exists and drop all further
	existence filtering since it's done in device::exists now.
	* path.cc (path_conv::check): Replace call to device::expose with call
	to device::exists.
@
text
@d727 1
a727 1
	  if (dev.get_major () == DEV_CYGDRIVE_MAJOR)
@


1.653
log
@(Interim checkin while we work on this)
* devices.cc: Regenerate.
* devices.h (device::noexpose): New field.
(device::dev_on_fs): Make a bit field.
(get_major): Use proper type for declaration.
(expose): New field.
(ext_dev_storage): Delete declaration.
(dev_storage_size): Ditto.
(dev_storage): New declaration.
(dev_storage_end): Ditto.
* devices.in: Mark /dev/ptym*, /dev/com*, /dev/pipe, /dev/fifo, and "/dev" as
"no expose".
* fhandler.h (fhandler_dev::lastrealpos): Delete declaration.
(fhandler_dev::devidx): Declare new field.
* fhandler_disk_file.cc: Move fhandler_dev functions into fhandler_dev.cc.
* fhandler_dev.cc: Add includes needed for functions moved from
fhandler_disk_file.cc.
(dev_storage_scan_start): Define place to start listing devices.
(dev_storage_size): Define size of array to scan.
(fhandler_dev::fhandler_dev): Move here from fhandler_disk_file.cc.
(fhandler_dev::opendir): Ditto.
(fhandler_dev::readdir): Just check devidx for non-NULL to determine when to go
to disk for /dev content.  Use dev_storage rather than ext_dev_storage.
Iterate over dev_storage using devidx pointer.  Use accessor functions rather
than raw references to the device struct.  Only increment dir->__d_position
when we are actually going to be returning something.  Add debug_printf for
exit.
(fhandler_dev::rewinddir): Set devidx as appropriate depending on whether
there's a /dev on disk or not.
* gendevices: Don't mark dev_storage static but do put it in the _RDATA
section.
* path.cc (path_conv::check): Use new "device::expose()" function to decide to
forbid programs from referencing internal device types.
@
text
@d721 1
a721 1
	  if (!dev.expose ())
@


1.652
log
@	* Makefile.in (DLL_OFILES): Add fhandler_dev.o.
	* devices.h (DEV_DEV_MAJOR): Define.
	(FH_DEV): Redefine in terms of DEV_DEV_MAJOR.
	(ext_dev_storage): Declare.
	(dev_storage_size): Declare.
	(dev_dev_storage): Declare.
	(dev_dev): Define.
	(isdev_dev): Define.
	* devices.in (dev_dev_storage): Activate.
	(ext_dev_storage): Define as externally available pointer to
	dev_storage.
	(dev_storage_size): Define to contain number of dev_storage elements.
	* dir.cc (rmdir): Handle /dev as always not empty.
	* dtable.cc (fh_alloc): Handle DEV_DEV_MAJOR.
	* fhandler.h (fhandler_dev): New class, derived from fhandler_disk_file.
	(fhandler_union): Add fhandler_dev member.
	* fhandler_disk_file.cc (class __DIR_mounts): Handle /dev directory
	to make sure it always exists.
	* fhandler_dev.cc: New file implementing /dev.
	* globals.cc (ro_u_dev): New R/O unicode string.
	* path.cc (path_conv::check): Handle FH_DEV device.
@
text
@d721 6
@


1.651
log
@	* path.cc (readlink): Avoid calling strlen() twice.
@
text
@d733 1
a733 1
	  else if (dev == FH_DEV)
d735 1
a735 9
	      dev = FH_FS;
#if 0
	      fileattr = getfileattr (THIS_path, sym.pflags & MOUNT_NOPOSIX);
	      if (!component && fileattr == INVALID_FILE_ATTRIBUTES)
		{
		  fileattr = FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_READONLY;
		  goto out;
		}
#endif
d874 3
a876 1
	      fileattr = sym.fileattr;
@


1.650
log
@	* Throughout, replace usage of w32api's min with MIN from sys/param.h.
@
text
@d2786 2
a2787 1
  ssize_t len = MIN (buflen, strlen (pathbuf.get_win32 ()));
@


1.649
log
@	* cygheap.h (enum fcwd_version_t): Move here from path.cc.
	(class fcwd_access_t): Ditto.  Only declare methods.
	(class cwdstuff): Move fast_cwd_ptr and fast_cwd_version from shared
	DLL section here.
	* path.cc: Keep fcwd_access_t method definitions.
	(fcwd_access_t::fast_cwd_version): New method.
	(find_fast_cwd_pointer): Change comment.  Mention test on W8CP.
	(cwdstuff::init): Initialize fast_cwd_ptr and fast_cwd_version.
@
text
@d60 1
d2786 1
a2786 1
  ssize_t len = min (buflen, strlen (pathbuf.get_win32 ()));
@


1.648
log
@	* environ.cc (dos_file_warning): Drop declaration.
	(ignore_case_with_glob): Ditto.
	(allow_winsymlinks): Ditto.
	(reset_com): Move definition to globals.cc.
	(struct parse_thing): Add "detect_bloda" option.
	* fhandler_serial.cc (fhandler_serial::open): Drop (incorrect)
	declaration of reset_com.
	* globals.cc (ignore_case_with_glob): Move definition into C++-only
	block.
	(dos_file_warning): Define.
	(allow_winsymlinks): Define.
	(reset_com): Define.
	(detect_bloda): Define.
	* path.cc (dos_file_warning): Drop definition here.
	(allow_winsymlinks): Drop definition here.
@
text
@d3513 3
a3515 75
/* This class is used to store the CWD starting with Windows Vista.
   The CWD storage in the RTL_USER_PROCESS_PARAMETERS block is only
   an afterthought now.  The actual CWD storage is a FAST_CWD structure
   which is allocated on the process heap.  The new method only requires
   minimal locking and it's much more multi-thread friendly.  Presumably
   it minimizes contention when accessing the CWD.
   The class fcwd_access_t is supposed to encapsulate the gory implementation
   details depending on OS version from the calling functions. */
class fcwd_access_t {
  /* This is the layout used in Windows 8 developer preview. */
  struct FAST_CWD_8 {
    LONG           ReferenceCount;	/* Only release when this is 0. */
    HANDLE         DirectoryHandle;
    ULONG          OldDismountCount;	/* Reflects the system DismountCount
					   at the time the CWD has been set. */
    UNICODE_STRING Path;		/* Path's Buffer member always refers
					   to the following Buffer array. */
    LONG           FSCharacteristics;	/* Taken from FileFsDeviceInformation */
    WCHAR          Buffer[MAX_PATH];
  };
  /* This is the layout used in Windows 7 and Vista. */
  struct FAST_CWD_7 {
    UNICODE_STRING Path;		/* Path's Buffer member always refers
					   to the following Buffer array. */
    HANDLE         DirectoryHandle;
    LONG           FSCharacteristics;	/* Taken from FileFsDeviceInformation */
    LONG           ReferenceCount;	/* Only release when this is 0. */
    ULONG          OldDismountCount;	/* Reflects the system DismountCount
					   at the time the CWD has been set. */
    WCHAR          Buffer[MAX_PATH];
  };
  /* This is the old FAST_CWD structure up to the patch from KB 2393802,
     release in February 2011. */
  struct FAST_CWD_OLD {
    LONG           ReferenceCount;	/* Only release when this is 0. */
    HANDLE         DirectoryHandle;
    ULONG          OldDismountCount;	/* Reflects the system DismountCount
					   at the time the CWD has been set. */
    UNICODE_STRING Path;		/* Path's Buffer member always refers
					   to the following Buffer array. */
    WCHAR          Buffer[MAX_PATH];
  };
  union {
    FAST_CWD_OLD fold;
    FAST_CWD_7   f7;
    FAST_CWD_8   f8;
  };

  /* Type of FAST_CWD used on this system.  Keeping this information available
     in shared memory avoids to test for the version every time around.
     Default to new version. */
  enum fcwd_version_t {
    FCWD_OLD,
    FCWD_W7,
    FCWD_W8
  };
  static fcwd_version_t fast_cwd_version;

#define IMPLEMENT(type, name) \
  type name () { \
    switch (fast_cwd_version) { \
      case FCWD_OLD: \
      default: \
	return fold.name; \
      case FCWD_W7: \
	return f7.name; \
      case FCWD_W8: \
	return f8.name; \
    } \
  }
  IMPLEMENT (LONG &, ReferenceCount)
  IMPLEMENT (HANDLE &, DirectoryHandle)
  IMPLEMENT (ULONG &, OldDismountCount)
  IMPLEMENT (UNICODE_STRING &, Path)
  IMPLEMENT (WCHAR *, Buffer)
d3517 1
a3517 1
  void SetFSCharacteristics (LONG val)
d3519 97
a3615 106
      switch (fast_cwd_version)
	{
	case FCWD_OLD:
	  break;
	case FCWD_W7:
	  f7.FSCharacteristics = val;
	  break;
	case FCWD_W8:
	  f8.FSCharacteristics = val;
	  break;
	}
    }
public:
  void CopyPath (UNICODE_STRING &target)
    {
      /* Copy the Path contents over into the UNICODE_STRING referenced by
	 target.  This is used to set the CurrentDirectoryName in the
	 user parameter block. */
      target = Path ();
    }
  void Free (PVOID heap)
    {
      /* Decrement the reference count.  If it's down to 0, free
	 structure from heap. */
      if (this && InterlockedDecrement (&ReferenceCount ()) == 0)
	{
	  /* In contrast to pre-Vista, the handle on init is always a
	     fresh one and not the handle inherited from the parent
	     process.  So we always have to close it here.  However, the
	     handle could be NULL, if we cd'ed into a virtual dir. */
	  HANDLE h = DirectoryHandle ();
	  if (h)
	    NtClose (h);
	  RtlFreeHeap (heap, 0, this);
	}
    }
  void FillIn (HANDLE dir, PUNICODE_STRING name, ULONG old_dismount_count)
    {
      /* Fill in all values into this FAST_CWD structure. */
      DirectoryHandle () = dir;
      ReferenceCount () = 1;
      OldDismountCount () = old_dismount_count;
      /* The new structure stores the device characteristics of the
	 volume holding the dir.  RtlGetCurrentDirectory_U checks
	 if the FILE_REMOVABLE_MEDIA flag is set and, if so, checks if
	 the volume is still the same as the one used when opening
	 the directory handle.
	 We don't call NtQueryVolumeInformationFile for the \\?\PIPE,
	 though.  It just returns STATUS_INVALID_HANDLE anyway. */
      if (fast_cwd_version != FCWD_OLD)
	{
	  SetFSCharacteristics (0);
	  if (name != &ro_u_pipedir)
	    {
	      IO_STATUS_BLOCK io;
	      FILE_FS_DEVICE_INFORMATION ffdi;
	      if (NT_SUCCESS (NtQueryVolumeInformationFile (dir, &io, &ffdi,
			      sizeof ffdi, FileFsDeviceInformation)))
		SetFSCharacteristics (ffdi.Characteristics);
	    }
	}
      RtlInitEmptyUnicodeString (&Path (), Buffer (),
				 MAX_PATH * sizeof (WCHAR));
      copy_cwd_str (&Path (), name);
    }

  static void SetDirHandleFromBufferPointer (PWCHAR buf_p, HANDLE dir)
    {
      /* Input: The buffer pointer as it's stored in the user parameter block
	 and a directory handle.
	 This function computes the address to the FAST_CWD structure based
	 on the version and overwrites the directory handle.  It is only
	 used if we couldn't figure out the address of fast_cwd_ptr. */
      fcwd_access_t *f_cwd;
      switch (fast_cwd_version)
	{
	case FCWD_OLD:
	default:
	  f_cwd = (fcwd_access_t *)
	    ((PBYTE) buf_p - __builtin_offsetof (FAST_CWD_OLD, Buffer));
	case FCWD_W7:
	  f_cwd = (fcwd_access_t *)
	    ((PBYTE) buf_p - __builtin_offsetof (FAST_CWD_7, Buffer));
	case FCWD_W8:
	  f_cwd = (fcwd_access_t *)
	    ((PBYTE) buf_p - __builtin_offsetof (FAST_CWD_8, Buffer));
	}
      f_cwd->DirectoryHandle () = dir;
    }
  static void SetVersionFromPointer (PBYTE buf_p, bool is_buffer)
    {
      /* Given a pointer to the FAST_CWD structure (is_buffer == false) or a
	 pointer to the Buffer within (is_buffer == true), this function
	 computes the FAST_CWD version by checking that Path.MaximumLength
	 equals MAX_PATH, and that Path.Buffer == Buffer. */
      if (is_buffer)
	buf_p -= __builtin_offsetof (FAST_CWD_8, Buffer);
      fcwd_access_t *f_cwd = (fcwd_access_t *) buf_p;
      if (f_cwd->f8.Path.MaximumLength == MAX_PATH * sizeof (WCHAR)
	  && f_cwd->f8.Path.Buffer == f_cwd->f8.Buffer)
	fast_cwd_version = FCWD_W8;
      else if (f_cwd->f7.Path.MaximumLength == MAX_PATH * sizeof (WCHAR)
	       && f_cwd->f7.Path.Buffer == f_cwd->f7.Buffer)
	fast_cwd_version = FCWD_W7;
      else
	fast_cwd_version = FCWD_OLD;
d3617 22
a3638 14
};
fcwd_access_t::fcwd_version_t fcwd_access_t::fast_cwd_version
  __attribute__((section (".cygwin_dll_common"), shared))
  = fcwd_access_t::FCWD_W7;
/* fast_cwd_ptr is a pointer to the global RtlpCurDirRef pointer in
   ntdll.dll pointing to the FAST_CWD structure which constitutes the CWD.
   Unfortunately RtlpCurDirRef is not exported from ntdll.dll.
   We put the pointer into the common shared DLL segment.  This allows to
   restrict the call to find_fast_cwd_pointer() to once per Cygwin session
   per user session.  This works, because ASLR randomizes the load address
   of DLLs only once at boot time. */
static fcwd_access_t **fast_cwd_ptr
  __attribute__((section (".cygwin_dll_common"), shared))
  = (fcwd_access_t **) -1;
d3648 3
a3650 2
   Windows 7 32/64 bit, and Server 2008 R2 (which is only 64 bit anyway).
   There's some hope that this will still work for Windows 8... */
d3881 7
a3887 2
    /* Initially re-open the cwd to allow POSIX semantics. */
    set (NULL, NULL);
@


1.647
log
@Update copyright on all files checked in so far this year.
* fhandler.h: Use #pragma once rather than ifdef guards.
(fhandler_console::tc_getpgid): Return our pgid if we have never opened a
console.
* fork.cc: Rearrange includes to accommodate fhandler.h use of pinfo.h.
* sigproc.cc: Ditto.
* spawn.cc: Ditto.
(child_info_spawn::worker): Query myself->pgid rather than calling expensive
function.
* thread.h: Use #pragma once rather than ifdef guards.
* pinfo.h: Use #pragma once rather than ifdef guards.
(pinfo::remember): Don't define if sigproc.h has not been included.
(pinfo::reattach): Ditto.
* sigproc.h: Use #pragma once rather than ifdef guards.  Use different test to
see if pinfo.h has been included.
@
text
@a75 2
bool dos_file_warning = true;

a1452 4
/* If TRUE create symlinks as Windows shortcuts, if false create symlinks
   as normal files with magic number and system bit set. */
bool allow_winsymlinks = false;

@


1.646
log
@* path.cc (get_current_dir_name): Avoid memory leak.  Don't return PWD contents
if directory doesn't actually exist.
@
text
@d4 1
a4 1
     2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
@


1.645
log
@	* cygwin.din (get_current_dir_name): Export.
	* path.cc (get_current_dir_name): New function.
	* posix.sgml (std-gnu): Add get_current_dir_name.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d2861 1
a2861 1
  char *pwd = getenv ("PWD");
d2863 1
d2865 5
a2869 1
  if (pwd)
d2871 2
a2872 8
      struct __stat64 pwdbuf, cwdbuf;
      stat64 (pwd, &pwdbuf);
      stat64 (cwd, &cwdbuf);
      if ((pwdbuf.st_dev == cwdbuf.st_dev) && (pwdbuf.st_ino == cwdbuf.st_ino))
        {
          cwd = (char *) malloc (strlen (pwd) + 1);
          strcpy (cwd, pwd);
        }
@


1.644
log
@	* path.cc (struct symlink_info): Add bool argument to declaration of
	check_reparse_point.
	(symlink_info::check_reparse_point): Add bool argument to indicate
	remote drive.  Handle STATUS_PENDING.  Don't evaluate junctions on
	remote drives.  Fix comments.
	(symlink_info::check): Drop check for is_remote_drive and associated
	comment here.  Add fs.is_remote_drive as second parameter to
	check_reparse_point call.
@
text
@d2858 21
@


1.643
log
@Clean up whitespace.
@
text
@d105 1
a105 1
  int check_reparse_point (HANDLE h);
d1961 1
a1961 1
symlink_info::check_reparse_point (HANDLE h)
d1970 7
a1976 2
  status = NtFsControlFile (h, NULL, NULL, NULL, &io, FSCTL_GET_REPARSE_POINT,
			    NULL, 0, (LPVOID) rp,
d1978 6
d1992 4
d2000 1
a2000 1
  else if (rp->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)
d2002 5
d2021 3
a2023 4
      /* Maybe it's a reparse point, but it's certainly not one we
	 recognize.  Drop the REPARSE file attribute so we don't even
	 try to use the flag for some special handling.  It's just some
	 arbitrary file or directory for us. */
d2619 1
a2619 8
	  /* Don't check reparse points on remote filesystems.  A reparse point
	     pointing to another file on the remote system will be mistreated
	     as pointing to a local file on the local system.  This breaks the
	     way reparse points are transparently handled on remote systems. */
	  if (fs.is_remote_drive())
	    res = 0;
	  else
	    res = check_reparse_point (h);
@


1.642
log
@	* path.cc (conv_path_list): Fix a condition.
	(cygwin_conv_path): Revert WIN_A conversion to current locale codeset.
@
text
@d3492 1
a3492 1
   it minimizes contention when accessing the CWD. 
d3643 1
a3643 1
	  f_cwd = (fcwd_access_t *) 
d3646 1
a3646 1
	  f_cwd = (fcwd_access_t *) 
d3649 1
a3649 1
	  f_cwd = (fcwd_access_t *) 
d3657 1
a3657 1
         pointer to the Buffer within (is_buffer == true), this function
d3772 1
a3772 1
	 
@


1.641
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Call
	file_get_fnoi instead of NtQueryInformationFile.
	* path.cc (file_get_fnoi): New helper function to collect a
	FILE_NETWORK_OPEN_INFORMATION block.
	(symlink_info::check): Call file_get_fnoi rather than
	NtQueryInformationFile to collect a FILE_NETWORK_OPEN_INFORMATION block.
	* path.h (file_get_fnoi): Declare.
@
text
@d1371 1
a1371 1
  if (what & CCP_WIN_A_TO_POSIX)
d2949 1
a2949 1
  what &= ~CCP_RELATIVE;
d2962 2
a2963 5
	UINT cp = AreFileApisANSI () ? CP_ACP : CP_OEMCP;
	int len = WideCharToMultiByte (cp, WC_NO_BEST_FIT_CHARS,
				       up->Buffer, up->Length / sizeof (WCHAR),
				       buf, NT_MAX_PATH, NULL, NULL);
	buf[len] = '\0';
d2975 6
a2980 8
	    char *p = buf + WideCharToMultiByte (cp, WC_NO_BEST_FIT_CHARS,
				       ro_u_globalroot.Buffer,
				       ro_u_globalroot.Length / sizeof (WCHAR),
				       buf, NT_MAX_PATH, NULL, NULL);
	    len = WideCharToMultiByte (cp, WC_NO_BEST_FIT_CHARS,
				       up->Buffer, up->Length / sizeof (WCHAR),
				       p, NT_MAX_PATH - (p - buf), NULL, NULL);
	    p[len] = '\0';
d3052 6
a3057 10
      {
	UINT cp = AreFileApisANSI () ? CP_ACP : CP_OEMCP;
	PWCHAR wbuf = tp.w_get ();
	MultiByteToWideChar (cp, 0, (const char *) from, -1, wbuf, NT_MAX_PATH);
	buf = tp.c_get ();
	error = mount_table->conv_to_posix_path (wbuf, buf, relative);
	if (error)
	  return_with_errno (error);
	lsiz = strlen (buf) + 1;
      }
@


1.640
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d1183 42
d2467 1
a2467 36
	      PFILE_NETWORK_OPEN_INFORMATION pfnoi = conv_hdl.fnoi ();

	      /* Netapps don't implement FileNetworkOpenInformation. */
	      status = fs.is_netapp ()
		       ? STATUS_INVALID_PARAMETER
		       : NtQueryInformationFile (h, &io, pfnoi, sizeof *pfnoi,
						 FileNetworkOpenInformation);
	      if (status == STATUS_INVALID_PARAMETER
		  || status == STATUS_NOT_IMPLEMENTED)
		{
		  /* Apart from accessing Netapps, this also occurs when
		     accessing SMB share root dirs hosted on NT4
		     (STATUS_INVALID_PARAMETER), or when trying to access
		     SMB share root dirs from NT4 (STATUS_NOT_IMPLEMENTED). */
		  FILE_BASIC_INFORMATION fbi;
		  FILE_STANDARD_INFORMATION fsi;

		  status = NtQueryInformationFile (h, &io, &fbi, sizeof fbi,
						   FileBasicInformation);
		  if (NT_SUCCESS (status))
		    {
		      memcpy (pfnoi, &fbi, 4 * sizeof (LARGE_INTEGER));
		      if (NT_SUCCESS (NtQueryInformationFile (h, &io, &fsi,
						     sizeof fsi,
						     FileStandardInformation)))
			{
			  pfnoi->EndOfFile.QuadPart = fsi.EndOfFile.QuadPart;
			  pfnoi->AllocationSize.QuadPart
			    = fsi.AllocationSize.QuadPart;
			}
		      else
			pfnoi->EndOfFile.QuadPart
			  = pfnoi->AllocationSize.QuadPart = 0;
		      pfnoi->FileAttributes = fbi.FileAttributes;
		    }
		}
d2469 1
a2469 1
		fileattr = pfnoi->FileAttributes;
@


1.639
log
@	* path.cc (conv_path_list): Take cygwin_conv_path_t as third parameter.
	Allow all types of CCP conversions.  Accommodate throughout.
	(cygwin_conv_path): Use current ANSI or OEM codepage for WIN_A
	conversions, depending on current file API codepage setting.
	(cygwin_conv_path_list): Allow all CCP conversion types.
	* include/sys/cygwin.h (CCP_CONVTYPE_MASK): Add to cygwin_conv_path_t
	enum for convenience.
@
text
@d1742 1
a1742 1
  syscall_printf ("%d = symlink_worker (%s, %s, %d, %d)", res, oldpath,
d2717 1
a2717 1
  syscall_printf ("%d = symlink.check (%s, %p) (%p)",
d2893 1
a2893 1
  syscall_printf ("%d = chdir() cygheap->cwd.posix '%s' native '%S'", res,
d2909 1
a2909 1
  syscall_printf ("%d = fchdir (%d)", res, fd);
@


1.638
log
@* path.cc (path_conv::get_nt_native_path): Avoid dereferencing path when it is
NULL.
@
text
@d58 1
d1316 2
a1317 1
conv_path_list (const char *src, char *dst, size_t size, int to_posix)
a1320 1
  cygwin_conv_path_t conv_fn;
d1322 1
d1324 6
a1329 1
  if (to_posix)
a1332 1
      conv_fn = CCP_WIN_A_TO_POSIX | CCP_RELATIVE;
a1337 1
      conv_fn = CCP_POSIX_TO_WIN_A | CCP_RELATIVE;
d1363 1
a1363 1
      if (to_posix == ENV_CVT && len)
d1380 1
a1380 1
	  err = cygwin_conv_path (conv_fn, srcpath, d, size - (d - dst));
d1382 1
a1382 1
      else if (!to_posix)
d1385 1
a1385 1
	  err = cygwin_conv_path (conv_fn, ".", d, size - (d - dst));
d1389 1
a1389 1
	  if (to_posix == ENV_CVT)
d2955 5
a2959 1
	sys_wcstombs (buf, NT_MAX_PATH, up->Buffer, up->Length / sizeof (WCHAR));
d2971 8
a2978 6
	    char *p = buf + sys_wcstombs (buf, NT_MAX_PATH,
					  ro_u_globalroot.Buffer,
					  ro_u_globalroot.Length
					  / sizeof (WCHAR));
	    sys_wcstombs (p, NT_MAX_PATH - (p - buf),
			  up->Buffer, up->Length / sizeof (WCHAR));
d3050 10
a3059 6
      buf = tp.c_get ();
      error = mount_table->conv_to_posix_path ((const char *) from, buf,
					       relative);
      if (error)
	return_with_errno (error);
      lsiz = strlen (buf) + 1;
d3298 2
a3299 1
  return_with_errno (conv_path_list (win32, posix, MAX_PATH, 1));
d3305 2
a3306 1
  return_with_errno (conv_path_list (posix, win32, MAX_PATH, 0));
d3313 7
a3319 3
  /* FIXME: Path lists are (so far) always retaining relative paths. */
  what &= ~CCP_RELATIVE;
  switch (what)
d3322 6
d3329 8
a3336 2
      /*FIXME*/
      api_fatal ("wide char path lists not yet supported");
d3338 3
d3346 9
a3354 2
      return_with_errno (conv_path_list ((const char *) from, (char *) to,
					 size, what == CCP_WIN_A_TO_POSIX));
@


1.637
log
@	* path.cc: Extend two comments.  Mention the name RtlpCurDirRef
	for reference.
@
text
@d453 6
a458 1
  if (!wide_path)
d465 1
d467 1
a467 1
  return &uni_path;
@


1.636
log
@* cygerrno.h (__set_errno): Modify debugging output to make searching strace
logs easier.  Throughout, change /dev/tty* to /dev/pty*.  Throughout, add flags
argument to fhandler_*::dup methods.
* devices.in: Rename (temporarily?) /dev/ttyN to /dev/ptyN.  Add /dev/ptymN
devices for pty masters.
* devices.cc: Regenerate.
* devices.h (MAX_CONSOLES): Set to max number supported by devices.in.
(fh_devices::FH_PTMX): Rename from FH_PTYM.
(device::operator int): Return by reference.
* dtable.cc (fh_alloc): Take pc as an argument rather than just the device.
This makes debugging easier since more information is available.  Actually
implement handling for already-allocated pty master devices.  Make different
decisions when generating fhandler for not-opened devices.  Add kludge to deal
with opening /dev/tty.
(cnew_no_ctor): New macro.
(build_fh_pc): Make debugging output more verbose.  Use new clone() fhandler
interface to duplicate archetypes.  Reset last term opened.
(dtable::dup_worker): Use Use new clone() fhandler interface to duplicate
archetypes.  Pass flags to child dup handler.
(dtable::dup3): Set O_NOCTTY flag if newfd is not stdin/stdout/stderr.
* fhandler.cc (fhandler_base::reset): Rename from operator =() and reduce
functionality and sense of copy direction.
(fhandler_base::open_with_arch): Use published interface to query io_handle().
Use new copyto() fhandler method to copy from/to found archetype.
* fhandler.h: Throughout, delete size(), add copyout, clone, and fhandler_*
(void *) methods.
(fhandler_base::reset): Rename from operator =().
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): change "protected" region to "private".
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): Rearrange protected/public.
(fhandler_termios::fhandler_termios): Remember last fhandler_termios "opened".
(fhandler_termios::~fhandler_termios): Forget last fhandler_termios opened.
(ioctl): Rename from ioctl_termios.  Take a void * argument.  Reflect argument
change in pinfo::set_ctty.
(fhandler_console::dup): Declare new function.  Set ctty here if appropriate.
(fhandler_pty_master::from_master): Privatize.
(fhandler_pty_master::to_master): Ditto.
(fhandler_pty_master::dwProcessId): Ditto.
(fhandler_pty_master::fhandler_pty_master): Add an `int' argument.
(fhandler_pty_master::open_setup): Declare new function.
(fhandler_pty_master::~fhandler_pty_master): Declare new method.
(fhandler_nodevice): Remove commented out function declaration.
* fhandler_console.cc: Use get_ttyp() instead of tc() throughout.
(fhandler_console::dup): Define new function to set controlling ctty on dup, as
appropriate.
(fhandler_console::ioctl): Reflect ioctl_termios name change.
(fhandler_console::setup): Rename from get_tty_stuff.
(fhandler_console::open_setup): Reflect argument change in pinfo::set_ctty.
(fhandler_console::fhandler_console): Set _tc here.
* fhandler_termios.cc (handler_termios::ioctl): Rename.  Take a void * arg like
other ioctl functions.
* fhandler_tty.cc (fhandler_pty_slave::dup): Call myself->set_ctty to
potentially reset the controlling terminal.
(fhandler_pty_slave::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_slave::fhandler_pty_slave): Take a "unit" argument.  Call setup()
here so that we will know the unit number of this fhandler as soon as possible.
Set the unit as appropriate.
(handler_pty_master::open): Move most stuff to constructor and open_setup.
(handler_pty_slave::open_setup): Reflect argument change in pinfo::set_ctty.
(handler_pty_master::open_setup): Define new function.
(fhandler_pty_master::cleanup): Clear handles as a flag that the destructor
does not have to do "close" operations.
(fhandler_pty_master::close): Ditto.
(fhandler_pty_master::~fhandler_pty_master): Define new method.
(fhandler_pty_master::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_master::setup): Allocate tty here.  Rely on handles being
returned from allocated test rather than opening them here.  Avoid setting
_need_nl here since it is already zeroed in the constructor.  Set up device
information with DEV_TTYM_MAJOR.
* path.h (path_conv &operator =): Take a const argument.
(path_conv::dup): Ditto.
(pathconv_arg::PC_OPEN): New enum.
(pathconv_arg::PC_CTTY): Ditto.
(path_types::PATH_CTTY): Ditto.
(path_types::PATH_OPEN): Ditto.
(path_conv::isopen): New method.
(path_conv::isctty_capable): Ditto.
* path.cc (path_conv::check): Set PATH_OPEN and PATH_CTTY as appropriate.
* pipe.cc (fhandler_pipe::open): Use copyto to copy pipe handle.
* syscall.cc (open): Reinstate fd > 2 check to disallow resetting ctty on
non-std* handles.
* tty.cc (tty_list::allocate): Pass out handles for allocated tty.  use
`not_allocated' to find unallocated ttys.  Avoid keeping the lock since the
allocation of the tty should be sufficient to prevent multiple access.
(tty::not_allocated): Clarify comment.  Rename.  Return handles when an unused
tty is found.  Simply test for existing tty.
(tty::exists): Rewrite to use `not_allocated'.
* tty.h (NTTYS): Reset down to actual number supported by devices.in.
(tty::not_allocated): Declare new function.
(tty_list::allocate): Pass out read/write tty handles.  Zero them when not
found.
* fhandler_proc.cc: Reflect name change from FH_PTYM -> FH_PTMX.
* pinfo.h (pinfo::set_ctty): Reduce/reorder arguments passed in.
* pinfo.cc (pinfo::set_ctty): Ditto.  Just use tc() built into the passed-in
fhandler_termios pointer.  Return true if ctty is assigned.
* syscalls.cc (open): Call build_fh_pc with PC_OPEN flag.  Set PC_CTTY if
appropriate.
(stat_worker): Remove is_dev_tty () stuff.
@
text
@d3629 3
a3631 2
/* fast_cwd_ptr is a pointer to the global pointer in ntdll.dll pointing
   to the FAST_CWD structure which constitutes the CWD.
d3722 12
a3733 3
      /* If we couldn't fetch fast_cwd_ptr, or if fast_cwd_ptr is NULL(*) we
	 have to figure out the version from the Buffer pointer in the
	 ProcessParameters. */
@


1.635
log
@	* path.cc (find_fast_cwd_pointer): Allow 'push crit-sect-addr' instead
	of 'mov edi, crit-sect-addr; push edi' and set rcall accordingly.
@
text
@d1121 6
@


1.634
log
@	* path.cc (copy_cwd_str): Move up in file to be accessible from
	class fcwd_access_t.
	(class fcwd_access_t): New class to consolidate and hide the details
	of the various FAST_CWD implementations.  Add implementation for
	Windows 8 Developer Preview.
	(fast_cwd_version): Make static private member of fcwd_access_t.
	(fast_cwd_ptr): Change base type to fcwd_access_t.
	(find_fast_cwd_pointer): Return fcwd_access_t**.
	(find_fast_cwd): Ditto.  Rip out all FAST_CWD implementations and use
	fcwd_access_t methods instead.
	(cwdstuff::override_win32_cwd): Ditto.
@
text
@d3668 1
a3668 1
     "push edi". */
d3670 5
a3674 1
  if (movedi[0] != 0xbf || movedi[5] != 0x57)
a3682 1
  rcall = movedi + 6;
@


1.633
log
@	* syscalls.cc (faccessat): Fix parens in flag expression when calling
	build_fh_name.

	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Fix typo in
	comment.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto.
	* path.cc (symlink_worker): Ditto.
@
text
@d3389 11
d3434 1
a3434 1
/* This structure is used to store the CWD starting with Windows Vista.
d3439 18
a3456 3
   it minimizes contention when accessing the CWD. */
typedef struct _FAST_CWD {
  UNICODE_STRING Path;			/* Path's Buffer member always refers
d3458 4
a3461 4
  HANDLE         DirectoryHandle;
  LONG           FSCharacteristics;	/* Taken from FileFsDeviceInformation */
  LONG           ReferenceCount;	/* Only release when this is 0. */
  ULONG          OldDismountCount;	/* Reflects the system DismountCount
d3463 8
a3470 10
  WCHAR          Buffer[MAX_PATH];
} FAST_CWD, *PFAST_CWD;

/* This is the old FAST_CWD structure up to the patch from KB 2393802,
   release in February 2011.  Hopefully it's not used for long anymore,
   but for quite some time we can't rely on this fact. */
typedef struct _FAST_CWD_OLD {
  LONG           ReferenceCount;	/* Only release when this is 0. */
  HANDLE         DirectoryHandle;
  ULONG          OldDismountCount;	/* Reflects the system DismountCount
d3472 1
a3472 1
  UNICODE_STRING Path;			/* Path's Buffer member always refers
d3474 149
a3622 3
  WCHAR          Buffer[MAX_PATH];
} FAST_CWD_OLD, *PFAST_CWD_OLD;

a3624 1

d3629 3
a3631 7
static PFAST_CWD *fast_cwd_ptr
  __attribute__((section (".cygwin_dll_common"), shared)) = (PFAST_CWD *) -1;
/* Type of FAST_CWD used on this system.  Keeping this information available
   in shared memory avoids to test for the version every time around.
   Default to new version. */
static int fast_cwd_version
  __attribute__((section (".cygwin_dll_common"), shared)) = 1;
d3643 1
a3643 1
static PFAST_CWD *
d3691 1
a3691 12
  return (PFAST_CWD *) peek32 (movesi + 2);
}

static inline void
copy_cwd_str (PUNICODE_STRING tgt, PUNICODE_STRING src)
{
  RtlCopyUnicodeString (tgt, src);
  if (tgt->Buffer[tgt->Length / sizeof (WCHAR) - 1] != L'\\')
    {
      tgt->Buffer[tgt->Length / sizeof (WCHAR)] = L'\\';
      tgt->Length += sizeof (WCHAR);
    }
d3694 1
a3694 1
static PFAST_CWD *
d3700 1
a3700 1
  PFAST_CWD *f_cwd_ptr = find_fast_cwd_pointer ();
d3707 2
a3708 7
      /* Fortunately it's simple to check for the new structure.
	 Path.MaximumLength takes the same space as the high word of
	 the old ReferenceCount.  We know that MaximumLength is always
	 MAX_PATH.  For the ref count this would account for a
	 pratically impossible value between 34078720 and 34079240. */
      fast_cwd_version = ((*f_cwd_ptr)->Path.MaximumLength
			  == MAX_PATH * sizeof (WCHAR)) ? 1 : 0;
d3712 3
a3714 15
      /* If we couldn't fetch fast_cwd_ptr, or if fast_cwd_ptr is
	 NULL(*) we have to figure out the version from the Buffer
	 pointer in the ProcessParameters.  We must make sure not
	 to access memory outside of the structure.  Therefore we
	 check the Path.Buffer pointer,
	 which would be the ReferenceCount in the old structure.

	 (*) This is very unlikely to happen when starting the first
	 Cygwin process, since it only happens when starting the
	 process in a directory which can't be used as CWD by Win32, or
	 if the directory doesn't exist.  But *if* it happens, we have
	 no valid FAST_CWD structure, even though upp_cwd_str.Buffer is
	 not NULL in that case.  So we let the OS create a valid
	 FAST_CWD structure temporarily to have something to work with.
	 We know the pipe FS works. */
d3722 2
a3723 4
      PFAST_CWD f_cwd = (PFAST_CWD)
		((PBYTE) peb.ProcessParameters->CurrentDirectoryName.Buffer
		 - __builtin_offsetof (struct _FAST_CWD, Buffer));
      fast_cwd_version = (f_cwd->Path.Buffer == f_cwd->Buffer) ? 1 : 0;
a3732 2
  NTSTATUS status;
  IO_STATUS_BLOCK io;
d3741 1
a3741 1
      if (fast_cwd_ptr == (PFAST_CWD *) -1)
d3749 2
a3750 2
	  /* First allocate a new FAST_CWD structure on the heap.
	     The new FAST_CWD structure is 4 byte bigger than the old one,
d3753 2
a3754 2
	  PFAST_CWD f_cwd = (PFAST_CWD)
			    RtlAllocateHeap (heap, 0, sizeof (FAST_CWD));
d3761 14
a3774 73
	  if (fast_cwd_version)
	    {
	      /* New FAST_CWD structure. */
	      FILE_FS_DEVICE_INFORMATION ffdi;

	      RtlInitEmptyUnicodeString (&f_cwd->Path, f_cwd->Buffer,
					 MAX_PATH * sizeof (WCHAR));
	      f_cwd->DirectoryHandle = dir;
	      /* The new structure stores the device characteristics of the
		 volume holding the dir.  RtlGetCurrentDirectory_U checks
		 if the FILE_REMOVABLE_MEDIA flag is set and, if so, checks if
		 the volume is still the same as the one used when opening
		 the directory handle.
		 We don't call NtQueryVolumeInformationFile for the \\?\PIPE,
		 though.  It just returns STATUS_INVALID_HANDLE anyway. */
	      f_cwd->FSCharacteristics =
		(!error
		 && NT_SUCCESS (NtQueryVolumeInformationFile (dir, &io, &ffdi,
				       sizeof ffdi, FileFsDeviceInformation)))
		? ffdi.Characteristics : 0;
	      f_cwd->ReferenceCount = 1;
	      f_cwd->OldDismountCount = old_dismount_count;
	      copy_cwd_str (&f_cwd->Path, error ? &ro_u_pipedir : &win32);
	      /* Use PEB lock when switching fast_cwd_ptr to the new FAST_CWD
		 structure and writing the CWD to the user process parameter
		 block.  This is equivalent to calling RtlAcquirePebLock/
		 RtlReleasePebLock, but without having to go through the FS
		 selector again. */
	      RtlEnterCriticalSection (peb.FastPebLock);
	      PFAST_CWD old_cwd = *fast_cwd_ptr;
	      *fast_cwd_ptr = f_cwd;
	      upp_cwd_str = f_cwd->Path;
	      upp_cwd_hdl = dir;
	      RtlLeaveCriticalSection (peb.FastPebLock);
	      /* Decrement the reference count.  If it's down to 0, free
		 structure from heap. */
	      if (old_cwd
		  && InterlockedDecrement (&old_cwd->ReferenceCount) == 0)
		{
		  /* In contrast to pre-Vista, the handle on init is always a
		     fresh one and not the handle inherited from the parent
		     process.  So we always have to close it here.  However, the
		     handle could be NULL, if we cd'ed into a virtual dir. */
		  if (old_cwd->DirectoryHandle)
		    NtClose (old_cwd->DirectoryHandle);
		  RtlFreeHeap (heap, 0, old_cwd);
		}
	    }
	  else
	    {
	      /* Old FAST_CWD structure.  Same procedure as above, except for
		 the non-existant FSCharacteristics member. */
	      PFAST_CWD_OLD f_cwd_old = (PFAST_CWD_OLD) f_cwd;
	      f_cwd_old->ReferenceCount = 1;
	      f_cwd_old->DirectoryHandle = dir;
	      f_cwd_old->OldDismountCount = old_dismount_count;
	      RtlInitEmptyUnicodeString (&f_cwd_old->Path, f_cwd_old->Buffer,
					 MAX_PATH * sizeof (WCHAR));
	      copy_cwd_str (&f_cwd_old->Path, error ? &ro_u_pipedir : &win32);
	      RtlEnterCriticalSection (peb.FastPebLock);
	      PFAST_CWD_OLD old_cwd = (PFAST_CWD_OLD) *fast_cwd_ptr;
	      *fast_cwd_ptr = (PFAST_CWD) f_cwd_old;
	      upp_cwd_str = f_cwd_old->Path;
	      upp_cwd_hdl = dir;
	      RtlLeaveCriticalSection (peb.FastPebLock);
	      if (old_cwd
		  && InterlockedDecrement (&old_cwd->ReferenceCount) == 0)
		{
		  if (old_cwd->DirectoryHandle)
		    NtClose (old_cwd->DirectoryHandle);
		  RtlFreeHeap (heap, 0, old_cwd);
		}
	    }
d3804 2
a3805 2
	      status = RtlSetCurrentDirectory_U (error ? &ro_u_pipedir
						       : &win32);
d3816 1
a3816 14
	  if (fast_cwd_version)
	    {
	      PFAST_CWD f_cwd = (PFAST_CWD)
			((PBYTE) upp_cwd_str.Buffer
			 - __builtin_offsetof (struct _FAST_CWD, Buffer));
	      f_cwd->DirectoryHandle = dir;
	    }
	  else
	    {
	      PFAST_CWD_OLD f_cwd_old = (PFAST_CWD_OLD)
			((PBYTE) upp_cwd_str.Buffer
			 - __builtin_offsetof (struct _FAST_CWD_OLD, Buffer));
	      f_cwd_old->DirectoryHandle = dir;
	    }
@


1.632
log
@	* ntdll.h: Fix typo in comment.
	* path.cc: Ditto.
@
text
@d1683 1
a1683 1
       I don't know what setting that is or howq to recognize such a share,
@


1.631
log
@	* fhandler.cc (fhandler_base::open): Don't open file with WRITE_DAC
	access on remote filesystem.  Explain why.
	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Ditto for
	directories.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto for sockets.
	* path.cc (symlink_worker): Ditto for symlinks.
@
text
@d430 1
a430 1
	 table since only leading and trainlig spaces and dots are affected.
@


1.630
log
@	* path.cc (normalize_win32_path): Skip all slashes after recognizing
	a ".." path component.  Add comment.
@
text
@d1676 1
a1676 1
  else if (!isdevice && win32_newpath.has_acls ())
d1680 5
a1684 1
       open the file again. */
@


1.629
log
@whitespace elimination
@
text
@d1261 2
a1262 1
	      if (isdirsep (*src))
@


1.628
log
@* autoload.cc: Call _api_fatal in asm.
* child_info.h: Redefine CURR_CHILD_INFO_MAGIC.
(child_info_fork::abort): Rename from handle_failure.  Change arguments.
* cygtls.h (_local_storage::ttybuf): New field.
* dcrt0.cc (vapi_fatal): Split api_fatal.  Add "in forked process" to message
when appropriate.
(api_fatal): Use vapi_fatal.
* devices.h: Make multiple inclusion safe.
(fh_devices): Add FH_CONS* stuff.  Reorder slightly.
(device): Eliminate anonymous union.  Add more ways to access minor/major.
(device::setunit): Accommodate no-longer-anonymous union.
(device::is_fs): Ditto.
(device::is_fs_special): Ditto.
(device::major): New function.
(device::minor): Ditto.
(device::is_device): New function.
(device::not_device): Ditto.
(device::operator int): New operator.
(device::operator fh_devices): Ditto.
(device::operator bool): Ditto.
(device::operator DWORD): Ditto.
(device::operator =): Ditto.
(isproc_dev): New function.
(isprocsys_dev): Ditto.
(iscons_dev): Ditto.
(istty_slave_dev): Ditto.
* devices.in: Add new "/dev/cons*" strings.  Accommodate no-longer-anonymous
union throughout.
(BRACK): Use more precise method for initialization.
* devices.cc: Regenerate.
* dtable.cc (dtable::stdio_init): Use get_cttyp instead of get_tty.
(dtable::find_archetype): Use new DWORD operator in device to test archetypes.
(dtable::init_std_file_from_handle): Use different method to initialize 'dev'.
Adapt to different ctty handling and accommodate /dev/cons*.
(fh_alloc): Accommodate no-longer-anonymous union.  Adapt to new /dev/cons*.
(build_fh_pc): Make debugging output more useful.
* exceptions.cc (ctrl_c_handler): Use get_cttyp instead of get_tty.
* external.cc (fillout_pinfo): Accommodate new cons* stuff.
* fhandler.cc (fhandler_base::read): Eliminate is_slow() test.
* fhandler.h (fhandler_base::*): Adapt to changes in device.h.
(fhandler_*::is_slow): Delete.
( fhandler_proc::get_proc_fhandler): Return fh_devices type.
* fhandler_console.cc (open_shared_console): New function.
(console_unit): New class.
(console_unit::console_unit): New constructor.
(enum_windows): New function.  Declare as friend to console_unit.
(fhandler_console::set_unit): New function.
(fhandler_console::get_tty_stuff): Call set_unit to set the unit number and
determine if initialization is needed.  Eliminate flags parameter.
(tty_list::get_cttyp): Rename (sorta) from get_tty.  Return pointer to correct
tty_min.
(fhandler_console::open): Adapt to elimination of argument to get_tty_stuff.
(fhandler_console::output_tcsetattr): Properly detect error condition.
(fhandler_console::fixup_after_fork_exec): Adapt to get_tty_stuff() setting tc
automatically.
* fhandler_proc.cc: Use FH_BAD rather than 0 throughout where using fh_devices
enum.
(fhandler_proc::get_proc_fhandler): Return fh_devices.  Adapt to devices.h
changes.
* fhandler_process.cc: Adapt to devices.h changes.  Use FH_BAD rather than 0
throughout where using fh_devices enum.
* fhandler_procnet.cc: Ditto.
* fhandler_procsys.cc: Ditto.
* fhandler_procsysvipc.cc: Ditto.
* fhandler_tape.cc (fhandler_dev_tape::fhandler_dev_tape): Ditto.
* fhandler_termios.cc (handler_termios::bg_check): Use tc->ttyname() rather
than assuming that we can construct a tty.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Just return
get_minor() of dev.
(fhandler_pty_master::process_slave_output): Add slightly more debugging info.
(fhandler_tty_slave::fhandler_tty_slave): Change name from ntty to unit.
(fhandler_pty_master::open): Ditto.
(fhandler_tty_slave::ioctl): Adapt to change which causes ctty to represent a
complete device.
(fhandler_tty_master::init_console): Add debugging for failure path.
(fhandler_pty_master::setup): Use get_unit() to retrieve unit number rather
than relying on raw ntty.
(fhandler_pty_master::setup): Ditto.
* fhandler_virtual.h (virt_tab_t): Redefine fhandler as fh_devices.
* fork.cc: Remove obsolete vfork stuff.
(frok::child): Don't assume that a ctty == 0 is valid.
* mount.cc (mount_info::conv_to_win32_path): Adapt to device struct changes.
(mount_info::conv_to_win32_path): Ditto.
* path.cc (path_conv::check): Retrive major/minor numbers via a method rather
than accessing them directly from device.  Rely on dev operators to
set/retrieve device information as required by device struct change.
* path.h (isproc_dev): Move to devices.h.
(isprocsys_dev): Ditto.
(isvirtual_dev): Ditto.
(path_conv:{isdevice,isfifo,isspecial,iscygdrive,issocket,get_devn,get_unitn}):
Use device methods to access/manipulate devices.
* pinfo.cc (pinfo::exit): Don't assume that ctty == 0 is valid.  Use iscons_dev
to determine if a device is a console.
(_pinfo::_ctty): Use device::parse to generate tty/cons name.
(_pinfo::set_ctty): Don't assume that ctty == 0 is valid.  Remove redundant
info from debugging.
* shared.cc (offsets): Remove console offset.
* shared_info.h (shared_locations): Ditto.
* syscalls.cc (umask): Use device methods to manipulate device information.
(ctermid): Use device::parse to generate term device name.
* tlsoffsets.h: Regenerate.
* tty.cc (ttyslot): Return minor number of ctty since ctty now represents a
full device.
(tty::create_master): Set ctty to a complete device.
(tty_list::attach): Rework to detect new /dev/cons* stuff.
(tty_list::terminate): Adapt to changes to ctty.
(tty_list::init): Adapt to change to setntty - pass in device major number.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Define new function.
* tty.h (tty_min::ntty): Redefine as fh_devices.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Declare new function.
(tty::getntty): Declare as const.
(tty_list::operator []): Assure that only minor part of argument is used.
* dll_init.cc (dll_list::alloc): Detect mismatch of data segments early issuing
an explicit error message if necessary.
* heap.cc (heap_init): Adapt to changes from fork->handle_failure to
fork->abort.
* pinfo.h (EXITCODE_FORK_FAILED): New enum.  (from Ryan Johnson)
* sigproc.cc (child_info_fork::abort): Rename from handle_failure.  Change
arguments to allow passing in a printf-like message.
* winsup.h (api_fatal): Delete macro definition.
(api_fatal): Redefine from __api_fatal.
(vapi_fatal): Declare new function.
* include/sys/strace.h (strace_vprintf): Define new macro.
* ntdll.h (_SYSTEM_INFORMATION_CLASS): Add SystemHandleInformation.
@
text
@d430 1
a430 1
         table since only leading and trainlig spaces and dots are affected.
d445 1
a445 1
      	*cp |= 0xf000;
d920 1
a920 1
	         handles while following symlinks. */
d1023 1
a1023 1
         exist.  This is typically indicated by the fileattr content.
d1858 1
a1858 1
         in case of an Interix symlink cooky we have read too far into the
d1923 1
a1923 1
      RtlInitCountedUnicodeString (&subst, 
d2361 1
a2361 1
	         last component. */
d2379 1
a2379 1
		         filenames will be tweaked to follow DOS rules via the
d2535 1
a2535 1
		         structure has the AllocationSize and EndOfFile members
d2553 1
a2553 1
         a directory with a suffix which has been appended here, then this
d2589 1
a2589 1
	         The handle has been opened with the FILE_OPEN_REPARSE_POINT
d2639 1
a2639 1
        {
d2943 1
a2943 1
	    /* Device name points to somewhere else in the NT namespace. 
d3007 1
a3007 1
	  /* Device name points to somewhere else in the NT namespace. 
d3015 1
a3015 1
      	{
d3458 1
a3458 1
   in shared memory avoids to test for the version every time around. 
d3571 1
a3571 1
	 FAST_CWD structure temporarily to have something to work with. 
d3576 1
a3576 1
	  && !NT_SUCCESS (RtlSetCurrentDirectory_U (&ro_u_pipedir))) 
d3638 1
a3638 1
	      f_cwd->FSCharacteristics = 
d3717 1
a3717 1
	     
d3721 1
a3721 1
	     
d3763 1
a3763 1
         for the CWD in the user process parameter block entirely by ourselves
d3766 1
a3766 1
	 
d3812 1
a3812 1
     
d3887 1
a3887 1
         directory is valid for Win32 apps.  And, no, we can't just call
d3895 1
a3895 1
      	{
d3958 1
a3958 1
	         to create a valid Win32 path. */
@


1.627
log
@	* autoload.cc (winmm): Remove time functions.  Don't treat
	unloadable wave functions as fatal.
	* hires.h (hires_ms::timeGetTime_ns): New private method.
	(hires_ms::dmsecs): Call timeGetTime_ns here.
	* ntdll.h (struct _KSYSTEM_TIME): Define.
	(KUSER_SHARED_DATA): Redefine to allow access to InterruptTime.
	(SharedUserData): Define here.
	(NtQueryTimerResolution): Declare.
	(NtSetTimerResolution): Declare.
	* path.cc (SharedUserData): Move to ntdll.h.
	* times.cc (hires_ms::timeGetTime_ns): New private method.
	Use throughout instead of timeGetTime.  Document entire functionality
	of timeGetTime in case we need it.
	(hires_ms::resolution): Try a call to NtQueryTimerResolution
	to fetch current period.  Fall back to heuristic if that fails.
	Cast to DWORD in assignments to minperiod.
	(clock_setres): Align period to possible values per a call to
	NtQueryTimerResolution.  Explain why.  Replace calls to timeBeginPeriod
	and timeEndPeriod with underlying call to NtSetTimerResolution.  Use
	status code from NtSetTimerResolution to compute errno.
	Convert period to ULONGLONG and store 100ns value to simplify code.
@
text
@d715 1
a715 1
	  if (dev.major == DEV_CYGDRIVE_MAJOR)
d723 1
a723 1
		  dev.devn = FH_FS;
d729 1
a729 1
	      dev.devn = FH_FS;
d739 1
a739 1
	  else if (isvirtual_dev (dev.devn))
d807 1
a807 1
	      if (component == 0 || dev.devn != FH_NETDRIVE)
d812 1
a812 1
	  else if (dev.devn != FH_FS)
d1011 1
a1011 1
  if (dev.devn == FH_NETDRIVE && component)
d1020 1
a1020 1
  else if (isproc_dev (dev.devn) && fileattr == INVALID_FILE_ATTRIBUTES)
@


1.626
log
@	* fhandler.cc (fhandler_base::open): When creating a file on a
	filesystem supporting ACLs, create the file with WRITE_DAC access.
	Explain why.
	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Ditto for
	directories.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto for sockets.
	* path.cc (symlink_worker): Ditto for symlinks.
	* security.cc (get_file_sd): Always call GetSecurityInfo for directories
	on XP and Server 2003.  Improve comment to explain why.
	(set_file_attribute): Explicitely cast mode_t value to bool in call to
	get_file_sd.
	* wincap.h (wincaps::use_get_sec_info_on_dirs): New element.
	* wincap.cc: Implement above element throughout.
@
text
@a3462 5
/* This is the mapping of the KUSER_SHARED_DATA structure into the 32 bit
   user address space.  We need it here to access the current DismountCount. */
static KUSER_SHARED_DATA &SharedUserData
			 = *(volatile PKUSER_SHARED_DATA) 0x7ffe0000;

@


1.626.2.1
log
@	* autoload.cc (winmm): Rremove time functions.  Don't treat
	unloadable wave functions as fatal.
	* hires.h (hires_ms::timeGetTime_ns): New private method.
	(hires_ms::dmsecs): Call timeGetTime_ns here.
	* ntdll.h (struct _KSYSTEM_TIME): Define.
	(KUSER_SHARED_DATA): Redefine to allow access to InterruptTime.
	(SharedUserData): Define here.
	(NtQueryTimerResolution): Declare.
	(NtSetTimerResolution): Declare.
	* path.cc (SharedUserData): Move to ntdll.h.
	* times.cc (hires_ms::timeGetTime_ns): New private method.
	Use throughout instead of timeGetTime.
	(hires_ms::resolution): Try a call to NtQueryTimerResolution
	to fetch current period.  Fall back to heuristic if that fails.
	(clock_setres): Align period to possible values per a call to
	NtQueryTimerResolution.  Explain why.  Replace calls to
	timeBeginPeriod and timeEndPeriod with underlying call to
	NtSetTimerResolution.
@
text
@d3463 5
@


1.625
log
@	* devices.in: Throughout use slashes instead of backslashes in the
	native path of devices not backed by native NT devices.
	* devices.cc: Regenerate.
	* globals.cc (ro_u_pmem): Use correct case.
	(ro_u_globalroot): New R/O unicode string.
	* path.cc (path_conv::check): Fix incorrect handling of /proc/sys
	block devices if they are just visited due to a component check.
	(symlink_info::posixify): Fix typo in comment.
	(cygwin_conv_path): Use ro_u_globalroot instead of string constant.
	(fast_cwd_version): New shared variable to store FAST_CWD version
	used on the system.
	(find_fast_cwd_pointer): Rename from find_fast_cwd_pointers.  Don't
	set global fast_cwd_ptr pointer here.  Return pointer value instead.
	(find_fast_cwd): New function to set fast_cwd_ptr and fast_cwd_version.
	(cwdstuff::override_win32_cwd): Call find_fast_cwd from here.
	Check for fast_cwd_version to differ between old and new FAST_CWD
	structure.  Check old_cwd for NULL to avoid SEGV.  Don't set CWD if
	we have neitehr a valid fast_cwd_ptr, nor a valid CWD handle in the
	process parameter block.
	(cwdstuff::set): Create Win32 path taking /proc/sys paths into account.
	* spawn.cc (spawn_guts): Recode creating runpath.  Also take /proc/sys
	paths into account.  Drop special CWD handling when starting non-Cygwin
	processes.
@
text
@d1418 1
d1675 8
a1682 2
  status = NtCreateFile (&fh, DELETE | FILE_GENERIC_WRITE,
			 win32_newpath.get_object_attr (attr, sa),
@


1.624
log
@	Revert change from 2010-08-31:
	* path.cc (normalize_posix_path): Drop support for //./ and //?/
	prefixes.
	(path_conv::check): Ditto.
@
text
@d789 1
a789 1
		    if (component || need_directory)
d792 3
a794 8
			if (component == 0)
			  {
			    strcat (full_path, "\\");
			    fileattr = FILE_ATTRIBUTE_DIRECTORY
				       | FILE_ATTRIBUTE_DEVICE;
			  }
			else
			  fileattr = 0;
d1994 1
a1994 1
     just incorrectly sticking to one redundant leading backslashe.  We go
d2938 4
a2941 1
	    char *p = stpcpy (buf, "\\\\.\\GLOBALROOT");
d3002 2
a3003 2
	  to = (void *) wcpcpy ((wchar_t *) to, L"\\\\.\\GLOBALROOT");
	  lsiz += sizeof ("\\\\.\\GLOBALROOT") - 1;
d3379 1
a3379 1
/* The find_fast_cwd_pointers function and parts of the
d3445 1
a3445 1
   restrict the call to find_fast_cwd_pointers() to once per Cygwin session
d3450 5
d3471 2
a3472 2
static void
find_fast_cwd_pointers ()
a3473 2
  /* Note that we have been called. */
  fast_cwd_ptr = NULL;
d3477 1
a3477 1
    return;
d3483 1
a3483 1
    return;
d3487 1
a3487 1
    return;
d3499 1
a3499 1
    return;
d3504 1
a3504 1
    return;
d3509 1
a3509 1
    return;
d3513 1
a3513 1
    return;
d3518 2
a3519 2
    return;
  fast_cwd_ptr = (PFAST_CWD *) peek32 (movesi + 2);
d3533 55
d3592 1
d3602 1
a3602 7
	{
	  find_fast_cwd_pointers ();
	  if (!fast_cwd_ptr)
	    system_printf ("WARNING: Couldn't compute FAST_CWD pointer.  "
			   "Please report this problem to\nthe public mailing "
			   "list cygwin@@cygwin.com");
	}
d3620 2
a3621 6
	  /* Fill in the values.  Fortunately it's simple to check for the
	     new structure.  Path.MaximumLength takes the same space as the
	     high word of the old ReferenceCount.  We know that MaximumLength
	     is always MAX_PATH.  For the ref count this would account for a
	     pratically impossible value between 34078720 and 34079240. */
	  if ((*fast_cwd_ptr)->Path.MaximumLength == MAX_PATH * sizeof (WCHAR))
a3623 1
	      IO_STATUS_BLOCK io;
d3657 2
a3658 1
	      if (InterlockedDecrement (&old_cwd->ReferenceCount) == 0)
d3671 2
a3672 2
	      /* Old FAST_CWD structure.  Otherwise same procedure as above,
	         except for the non-existant FSCharacteristics member. */
d3686 2
a3687 1
	      if (InterlockedDecrement (&old_cwd->ReferenceCount) == 0)
d3732 2
d3735 7
a3741 5
	  PFAST_CWD f_cwd = (PFAST_CWD)
			    ((PBYTE) upp_cwd_str.Buffer
			     - __builtin_offsetof (struct _FAST_CWD, Buffer));
	  if (f_cwd->Path.MaximumLength == MAX_PATH * sizeof (WCHAR))
	    f_cwd->DirectoryHandle = dir;
d3743 6
a3748 1
	    ((PFAST_CWD_OLD) f_cwd)->DirectoryHandle = dir;
d3938 1
a3938 3
      if (virtual_path) /* don't mangle virtual path. */
	;
      else
d3940 14
a3953 3
	  /* Compute length on Win32 path. */
	  size_t len = upath.Length / sizeof (WCHAR) - 4;
	  if (RtlEqualUnicodePathPrefix (&upath, &ro_u_uncp, TRUE))
d3955 8
a3962 2
	      len -= 2;
	      unc_path = true;
a3963 4
	  /* Convert to a Win32 path. */
	  upath.Buffer += upath.Length / sizeof (WCHAR) - len;
	  upath.Length = len * sizeof (WCHAR);

@


1.623
log
@	* path.cc (struct _FAST_CWD): Redefine to new layout used since patch
	for KB 2393802.  Adjust comments throughout.
	(struct _FAST_CWD_OLD): Rename former definition.
	(cwdstuff::override_win32_cwd): Check if the OS is using the old or the
	new FAST_CWD structure layout and handle accordingly.
@
text
@a268 8
      /* Is that a //?/ or //./ prefix into the native NT namespace?
	 If so, preserve it. */
      if ((src[1] == '.' || src[1] == '?') && isslash (src[2]))
	{
	  *tail++ = *src++;
	  *tail++ = *src++;
	  dst_start += 2;
	}
a837 7
	  /* Otherwise, if the user requires a directory and explicitely
	     specified a path into the native NT namespace, add the trailing
	     backslash.  It's needed to access the root dir. */
	  else if (need_directory
		   && full_path[0] == '\\' && full_path[1] == '\\'
		   && (full_path[2] == '.' || full_path[2] == '?'))
	    strcat (full_path, "\\");
@


1.622
log
@	* path.cc (conv_path_list): Remove enclosing quotes and trailing
	backslashes from Win32 environment path lists.
@
text
@d3435 14
d3456 1
a3456 1
} FAST_CWD, *PFAST_CWD;
d3573 4
a3576 1
	  /* First allocate a new FAST_CWD strcuture on the heap. */
d3584 54
a3637 21
	  /* Fill in the values. */
	  f_cwd->ReferenceCount = 1;
	  f_cwd->DirectoryHandle = dir;
	  f_cwd->OldDismountCount = old_dismount_count;
	  RtlInitEmptyUnicodeString (&f_cwd->Path, f_cwd->Buffer,
				     MAX_PATH * sizeof (WCHAR));
	  copy_cwd_str (&f_cwd->Path, error ? &ro_u_pipedir : &win32);
	  /* Use PEB lock when switching fast_cwd_ptr to the new FAST_CWD
	     structure and writing the CWD to the user process parameter
	     block.  This is equivalent to calling RtlAcquirePebLock/
	     RtlReleasePebLock, but without having to go through the FS
	     selector again. */
	  RtlEnterCriticalSection (peb.FastPebLock);
	  PFAST_CWD old_cwd = *fast_cwd_ptr;
	  *fast_cwd_ptr = f_cwd;
	  upp_cwd_str = f_cwd->Path;
	  upp_cwd_hdl = dir;
	  RtlLeaveCriticalSection (peb.FastPebLock);
	  /* Decrement the reference count.  If it's down to 0, free structure
	     from heap. */
	  if (old_cwd && InterlockedDecrement (&old_cwd->ReferenceCount) == 0)
d3639 21
a3659 7
	      /* In contrast to pre-Vista, the handle on init is always a fresh
		 one and not the handle inherited from the parent process.  So
		 we always have to close it here.  However, the handle could
		 be NULL, if we cd'ed into a virtual dir. */
	      if (old_cwd->DirectoryHandle)
		NtClose (old_cwd->DirectoryHandle);
	      RtlFreeHeap (heap, 0, old_cwd);
d3703 4
d3708 1
a3708 1
	  f_cwd->DirectoryHandle = upp_cwd_hdl = dir;
@


1.621
log
@	* path.cc (path_conv::check): Don't follow reparse point symlinks if
	PC_SYM_NOFOLLOW_REP flag is set.
	(cygwin_conv_path): Set PC_SYM_NOFOLLOW_REP flag when converting from
	POSIX to Win32.
	* path.h (enum pathconv_arg): Define PC_SYM_NOFOLLOW_REP flag.
@
text
@d1354 3
a1356 2
      char *s = strccpy (srcbuf, &src, src_delim);
      size_t len = s - srcbuf;
d1362 17
d1382 1
a1382 1
	  err = cygwin_conv_path (conv_fn, srcbuf, d, size - (d - dst));
@


1.620
log
@	* path.cc (path_conv::check): Don't generate ENOENT for non-existant
	CYGDRIVE and NETDRIVE paths.  Add comment.
@
text
@d4 1
a4 1
     2006, 2007, 2008, 2009, 2010 Red Hat, Inc.
d923 3
a925 1
	      if (component == 0 && !need_directory && !(opt & PC_SYM_FOLLOW))
d2922 2
a2923 2
		 PC_POSIX | PC_SYM_FOLLOW | PC_NO_ACCESS_CHECK | PC_NOWARN
		 | (relative ? PC_NOFULL : 0));
d2958 3
a2960 3
      p.check ((const char *) from, PC_POSIX | PC_SYM_FOLLOW
				    | PC_NO_ACCESS_CHECK | PC_NOWARN
				    | (relative ? PC_NOFULL : 0));
@


1.619
log
@	* path.cc (symlink_info::check): Don't use FileNetworkOpenInformation
	on Netapps.  Relax condition for workaround.  Always request size
	information via FileStandardInformation info class in workaround.
@
text
@d1038 1
a1038 1
  else if (isvirtual_dev (dev.devn) && fileattr == INVALID_FILE_ATTRIBUTES)
d1040 7
@


1.618
log
@* dcrt0.cc (do_exit): Don't set thread termination until all fds have been
closed since an fd may rely on a thread.
* fhandler_tty.cc: Reformat comment.
(fhandler_pty_master::pty_master_thread): Refuse ERROR_PIPE_CONNECTED state as
an error.
* globals.cc (exit_states): Reorder ES_THREADTERM.
* path.cc (find_fast_cwd_pointers): Remove excessively wordy DEBUGGING output.
@
text
@d2391 11
a2401 8
	      status = NtQueryInformationFile (h, &io, pfnoi, sizeof *pfnoi,
					       FileNetworkOpenInformation);
	      if ((status == STATUS_INVALID_PARAMETER
		   || status == STATUS_NOT_IMPLEMENTED)
		  && RtlEqualUnicodePathPrefix (&upath, &ro_u_uncp, FALSE))
	      	{
		  /* This occurs when accessing SMB share root dirs hosted on
		     NT4 (STATUS_INVALID_PARAMETER), or when trying to access
d2404 1
d2411 11
a2421 2
		      pfnoi->EndOfFile.QuadPart
			= pfnoi->AllocationSize.QuadPart = 0;
@


1.617
log
@	* cygheap.h (cwdstuff::override_win32_cwd): Declare.
	* ntdll.h (struct _PEB): Add members accessed by the fast cwd method
	starting with Vista.
	(struct _KUSER_SHARED_DATA): Define with only the DismountCount.
	(RtlAllocateHeap): Declare.
	(RtlEnterCriticalSection): Declare.
	(RtlFreeHeap): Declare.
	(RtlLeaveCriticalSection): Declare.
	* path.cc (get_user_proc_parms): Remove.
	(struct _FAST_CWD): New structure.
	(fast_cwd_ptr): Define.
	(SharedUserData): Define.
	(peek32): Define.
	(find_fast_cwd_pointers): New function to find the global pointer
	to the current FAST_CWD structure.
	(copy_cwd_str): New helper function.
	(cwdstuff::override_win32_cwd): New method to set the Win32 CWD.
	(cwdstuff::init): Just call override_win32_cwd from here when
	started from native Win32 parent.
	(cwdstuff::set): Access Win32 CWD via PEB reference instead of using
	get_user_proc_parms function.  Memorize old DismountCount before
	opening directory handle.  Call override_win32_cwd to set up Win32 CWD.
	Be more verbose in comments.
	* wincap.h (wincaps::has_fast_cwd): New element.
	* wincap.cc: Implement has_fast_cwd element throughout.
@
text
@a3479 3
#ifdef DEBUGGING
  system_printf ("fast_cwd_ptr: %p", fast_cwd_ptr);
#endif
@


1.616
log
@	* fhandler.h (fhandler_base::get_stat_access): Delete.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Always check
	executable suffix to get x-bits for .exe files also in notexec case.
	Always reopen file when checking for file header.
	* ntdll.h (wait_pending): Delete.
	* path.cc (symlink_info::check_shortcut): Drop call to wait_pending
	since file is always opened for sync IO.
	(symlink_info::check_sysfile): Ditto.
	(MIN_STAT_ACCESS): Remove.
	(FULL_STAT_ACCESS): Remove.
	(symlink_info::check): Drop access flag.  Revert to open file with
	just read attributes access.  Reorder symlink check to check for
	reparse points first.  Don't check reparse points for anything else,
	even on remote drives.  Open file for GENERIC_READ when trying to
	read shortcuts or system-bit symlinks. Accommodate dropped access
	flag in call to path_conv_handle::set.
	* path.h (class path_conv_handle): Drop access flag and accommodate
	all related methods.
@
text
@d3356 131
a3486 2
static inline PRTL_USER_PROCESS_PARAMETERS
get_user_proc_parms ()
d3488 144
a3631 1
  return NtCurrentTeb ()->Peb->ProcessParameters;
d3641 2
a3642 1
     buffer is not NULL, the cwd struct is already set up. */
d3644 4
a3647 4
    return;

  /* Initially re-open the cwd to allow POSIX semantics. */
  set (NULL, NULL);
d3656 1
d3707 7
d3731 1
a3731 1
			get_user_proc_parms ()->CurrentDirectoryHandle, NULL);
d3761 4
a3764 3
  /* Set new handle.  It's only used when creating stackdumps so far. */
  if (dir)
    NtClose (dir);
d3772 1
a3772 1
      PUNICODE_STRING pdir = &get_user_proc_parms ()->CurrentDirectoryName;
d3853 1
a3853 7
  if (nat_cwd)
    {
      status = RtlSetCurrentDirectory_U (error ? &ro_u_pipedir : &win32);
      if (!NT_SUCCESS (status))
	debug_printf ("RtlSetCurrentDirectory_U(%S) failed, %p",
		      error ? &ro_u_pipedir : &win32, status);
    }
@


1.615
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Simplify.
	Just call nfs_fetch_fattr3 if called via fstat.
	* nfs.cc (nfs_fetch_fattr3): New function to fetch NFS fattr3 info from
	file handle.
	* nfs.h (nfs_fetch_fattr3): Declare.
	* path.cc (symlink_info::check): Simplify NFS case.  Just call
	nfs_fetch_fattr3.
@
text
@a1754 1
  status = wait_pending (status, h, io);
a1818 1
  status = wait_pending (status, h, io);
a1851 1
      status = wait_pending (status, h, io);
a2256 4
# define MIN_STAT_ACCESS	(READ_CONTROL | FILE_READ_ATTRIBUTES)
# define FULL_STAT_ACCESS	(SYNCHRONIZE | GENERIC_READ)
  ACCESS_MASK access = 0;

d2274 4
a2277 2
      status = NtCreateFile (&h, access = FULL_STAT_ACCESS, &attr, &io, NULL,
			     0, FILE_SHARE_VALID_FLAGS, FILE_OPEN,
d2281 1
a2281 12
      if (status == STATUS_ACCESS_DENIED && eabuf)
	{
	  status = NtCreateFile (&h, access = MIN_STAT_ACCESS | FILE_READ_EA,
				 &attr, &io, NULL, 0, FILE_SHARE_VALID_FLAGS,
				 FILE_OPEN,
				 FILE_OPEN_REPARSE_POINT
				 | FILE_OPEN_FOR_BACKUP_INTENT,
				 eabuf, easize);
	  debug_printf ("%p = NtCreateFile (2:%S)", status, &upath);
	}
      else
	debug_printf ("%p = NtCreateFile (1:%S)", status, &upath);
d2301 2
a2302 2
	  status = NtOpenFile (&h, access = FULL_STAT_ACCESS, &attr, &io,
			       FILE_SHARE_VALID_FLAGS,
d2305 1
a2305 10
	  if (status == STATUS_ACCESS_DENIED)
	    {
	      status = NtOpenFile (&h, access = MIN_STAT_ACCESS, &attr, &io,
				   FILE_SHARE_VALID_FLAGS,
				   FILE_OPEN_REPARSE_POINT
				   | FILE_OPEN_FOR_BACKUP_INTENT);
	      debug_printf ("%p = NtOpenFile (no-EAs 2:%S)", status, &upath);
	    }
	  else
	    debug_printf ("%p = NtOpenFile (no-EA 1:%S)", status, &upath);
d2537 38
d2577 1
a2577 1
      if ((fileattr & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_DIRECTORY))
d2580 7
a2586 1
	  if (!(access & GENERIC_READ))
d2589 4
a2592 1
	    res = check_shortcut (h);
d2595 2
a2596 2
	      /* If searching for `foo' and then finding a `foo.lnk' which is
		 no shortcut, return the same as if file not found. */
a2617 37
      /* Reparse points are potentially symlinks.  This check must be
	 performed before checking the SYSTEM attribute for sysfile
	 symlinks, since reparse points can have this flag set, too.
	 For instance, Vista starts to create a couple of reparse points
	 with SYSTEM and HIDDEN flags set.
	 Also don't check reparse points on remote filesystems.
	 A reparse point pointing to another file on the remote system will be
	 mistreated as pointing to a local file on the local system.  This
	 breaks the way reparse points are transparently handled on remote
	 systems. */
      else if ((fileattr & FILE_ATTRIBUTE_REPARSE_POINT)
	       && !fs.is_remote_drive())
	{
	  res = check_reparse_point (h);
	  if (res == -1)
	    {
	      /* Volume mount point.  The filesystem information for the top
		 level directory should be for the volume top level directory,
		 rather than for the reparse point itself.  So we fetch the
		 filesystem information again, but with a NULL handle.
		 This does what we want because fs_info::update opens the
		 handle without FILE_OPEN_REPARSE_POINT. */
	      fs.update (&upath, NULL);
	      /* Make sure the open handle is not used in later stat calls.
	         The handle has been opened with the FILE_OPEN_REPARSE_POINT
		 flag, so it's a handle to the reparse point, not a handle
		 to the volumes root dir. */
	      pflags &= ~PC_KEEP_HANDLE;
	    }
	  else if (res)
	    {
	      /* A symlink is never a directory. */
	      conv_hdl.fnoi ()->FileAttributes &= ~FILE_ATTRIBUTE_DIRECTORY;
	      break;
	    }
	}

d2624 8
a2631 1
	  if (!(access & GENERIC_READ))
d2634 4
a2637 1
	    res = check_sysfile (h);
d2663 1
a2663 1
	conv_hdl.set (h, access);
@


1.614
log
@	* fhandler.cc: Drop including nfs.h.
	* fhandler_disk_file.cc: Ditto.
	(fhandler_base::fstat_by_nfs_ea): Use fattr3 from path_conv member,
	unless called from fstat.
	* path.cc: Drop including nfs.h.
	(symlink_info::check): Rearrange definition of file info buffers.
	Fetch fattr3 info for files on NFS and store in conv_hdl for later
	use in fhandler_base::fstat_by_nfs_ea.  Use fattr3 file type to
	recognize symlink on NFS and try to fetch symlink target only for
	actual symlinks.
	* path.h: Include nfs.h.
	(class path_conv_handle): Change file info storage to union of
	FILE_NETWORK_OPEN_INFORMATION and fattr3 structures.
	(path_conv_handle::fnoi): Align to aforementioned change.
	(path_conv_handle::nfsattr): New method.
	(path_conv::nfsattr): New method.
@
text
@d2407 1
a2407 15
	      struct {
		FILE_FULL_EA_INFORMATION ffei;
		char buf[sizeof (NFS_V3_ATTR) + sizeof (fattr3)];
	      } ffei_buf; 
	      struct {
		 FILE_GET_EA_INFORMATION fgei;
		 char buf[sizeof (NFS_V3_ATTR)];
	      } fgei_buf;

	      fgei_buf.fgei.NextEntryOffset = 0;
	      fgei_buf.fgei.EaNameLength = sizeof (NFS_V3_ATTR) - 1;
	      stpcpy (fgei_buf.fgei.EaName, NFS_V3_ATTR);
	      status = NtQueryEaFile (h, &io, &ffei_buf.ffei, sizeof ffei_buf,
				      TRUE, &fgei_buf.fgei, sizeof fgei_buf,
				      NULL, TRUE);
d2409 2
a2410 7
		{
		  fattr3 *nfs_attr = (fattr3 *)
			(ffei_buf.ffei.EaName + ffei_buf.ffei.EaNameLength + 1);
		  memcpy (conv_hdl.nfsattr (), nfs_attr, sizeof (fattr3));
		  fileattr = ((nfs_attr->type & 7) == NF3DIR)
			     ? FILE_ATTRIBUTE_DIRECTORY : 0;
		}
@


1.613
log
@	* path.cc (symlink_info::check): Remove erroneous assumption about
	required permissions when reading NFS symlinks.
@
text
@a69 1
#include "nfs.h"
a2399 3
      FILE_BASIC_INFORMATION fbi;
      PFILE_NETWORK_OPEN_INFORMATION pfnoi = conv_hdl.fnoi ();

d2407 15
a2421 6
	      /* NFS doesn't handle FileNetworkOpenInformation when called
	         via NtQueryInformationFile (STATUS_INVALID_PARAMETER).
		 Since we only need FileAttributes for NFS anyway, we just
		 fetch the FileBasicInformation. */
	      status = NtQueryInformationFile (h, &io, &fbi, sizeof fbi,
					       FileBasicInformation);
d2423 7
a2429 1
		fileattr = fbi.FileAttributes;
d2433 2
d2444 2
d2547 2
d2647 1
a2647 1
	      pfnoi->FileAttributes &= ~FILE_ATTRIBUTE_DIRECTORY;
d2669 1
a2669 1
      else if (fs.is_nfs () && !no_ea && !(fileattr & FILE_ATTRIBUTE_DIRECTORY))
@


1.612
log
@	* errno.cc (errmap): Map ERROR_BAD_NET_RESP to ENOSYS.
	* fhandler_disk_file.cc (fhandler_disk_file::facl): Handle ENOSYS and
	point to  the explanation.
	* ntdll.h (STATUS_NOT_IMPLEMENTED): Define.
	* path.cc (symlink_info::check): Handle the inability of NT4 to use
	FileNetworkOpenInformation on share root dirs in either direction.
	* path.h (slash_unc_prefix_p): Remove unused declaration.
	* security.cc (get_info_from_sd): Handle ENOSYS from get_file_sd.
	Explain when this happens.
@
text
@d2654 1
a2654 4
	  if (!(access & GENERIC_READ))
	    res = 0;
	  else
	    res = check_nfs_symlink (h);
@


1.611
log
@	* path.cc (cwdstuff::set): Replace constant 2 with sizeof(WCHAR) where
	appropriate.
@
text
@d2424 17
@


1.610
log
@	* mount.h (class fs_info): Add has_buggy_reopen flag and accessor
	methods.
	* mount.cc (fs_info::update): Set has_buggy_reopen flag for NWFS.
	Add comment.
	* path.h (path_conv::get_object_attr) Make inline method.
	(path_conv::init_reopen_attr): New inline method.
	* path.cc (path_conv::get_object_attr): Remove.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Use
	path_conv::init_reopen_attr method to initialize OBJECT_ATTRIBUTE for
	reopening file.
	(fhandler_disk_file::fchmod): Ditto.
	(fhandler_base::utimens_fs): Ditto.
	(fhandler_disk_file::rewinddir): Ditto.
	* syscalls.cc (unlink_nt): Ditto.
@
text
@d3486 3
a3488 2
							  pdir->Length + 2),
				 pdir->Length + 2);
d3524 3
a3526 2
							  upath.Length + 2),
				 upath.Length + 2);
@


1.609
log
@	* fhandler.cc (fhandler_base::open): Always open NFS files with
	FILE_READ_EA, even when opening with O_WRONLY to allow fstat.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Call
	FlushFileBuffers if file has been opened for writing.  Explain why.
	(fhandler_base::fstat_by_handle): Renew content of pc.fnoi if called
	via fstat.  Explain why.  Fix formatting.
	* path.cc (symlink_info::check): Try to open file the second time with
	FILE_READ_EA permissions since it's needed in later calls to
	fhandler_base::fstat_by_nfs_ea.
@
text
@a472 12
POBJECT_ATTRIBUTES
path_conv::get_object_attr (OBJECT_ATTRIBUTES &attr, SECURITY_ATTRIBUTES &sa)
{
  if (!get_nt_native_path ())
    return NULL;
  InitializeObjectAttributes (&attr, &uni_path,
			      objcaseinsensitive ()
			      | (sa.bInheritHandle ? OBJ_INHERIT : 0),
			      NULL, sa.lpSecurityDescriptor);
  return &attr;
}

@


1.608
log
@	* path.cc (symlink_info::check): Make sure AllocationSize and EndOfFile
	are stored in the right order when fetching the info from the
	NtQueryDirectoryFile result.
@
text
@d2299 1
a2299 1
      if (status == STATUS_ACCESS_DENIED)
d2301 3
a2303 2
	  status = NtCreateFile (&h, access = MIN_STAT_ACCESS, &attr, &io,
				 NULL, 0, FILE_SHARE_VALID_FLAGS, FILE_OPEN,
@


1.607
log
@	* fhandler.h (class fhandler_base): Change inheritance of fstat_helper
	and fstat_by_...  methods to private.
	(fhandler_base::fstat_helper): Drop all redundant arguments.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Drop call
	to fstat_by_nfs_ea here.  Drop fetching basic file information.
	Drop setting file attributes.  Accommodate change in fstat_helper call.
	(fhandler_base::fstat_by_name): Simplify.  Only fetch directory
	information to get the inode number.  Drop setting file attributes.
	Accommodate change in fstat_helper call.
	(fhandler_base::fstat_fs): Call fstat_by_nfs_ea if on NFS.
	(fhandler_base::fstat_helper): Drop all redundant arguments.  Use
	information already collected in the fhandler.  Move heading comment
	into code and drop dwFileAttributes comment.
	* mmap.cc (mmap64): Call fstat_fs rather than fstat_by_handle.
	* mount.cc (fs_info::update): Note that has_buggy_basic_info is unused.
	* path.cc (symlink_info::check_reparse_point): Add comment.
	(symlink_info::check): Fetch FileNetworkOpenInformation rather than
	FileBasicInformation throughout, except on NFS.  Explain why.  Store
	FILE_NETWORK_OPEN_INFORMATION in conv_hdl.  Remove
	FILE_ATTRIBUTE_DIRECTORY attribute in conv_hdl for reparse point
	symlinks.
	* path.h (class path_conv_handle): Add FILE_NETWORK_OPEN_INFORMATION
	member _fnoi.
	(path_conv_handle::fnoi): New accessor method for _fnoi.
	(path_conv::fnoi): New accessor method for cubv_hdl._fnoi.

	* fhandler_tty.cc (fhandler_tty_slave::init): Use tty::setpgid method.
@
text
@d2528 8
@


1.606
log
@	* Makefile.in (DLL_OFILES): Add fhandler_procsys.o.
	* devices.h (enum fh_devices): Add FH_PROCSYS.
	* devices.in (dev_procsys_storage): New device.
	* devices.cc: Regenerate.
	* dtable.cc (build_fh_pc): Add code to allocate fhandler_procsys.
	* fhandler.h (proc_len): Convert to size_t.
	(procsys): Declare.
	(procsys_len): Declare.
	(enum virtual_ftype_t): Move here from fhandler_virtual.h.
	Add members supported by fhandler_procsys.
	(fhandler_virtual::exists): Return virtual_ftype_t.  Change
	in all derived classes.
	(class fhandler_procsys): New class.
	(fhandler_union): Add fhandler_procnet and fhandler_procsys members.
	* fhandler_disk_file.cc (__DIR_mounts::check_missing_mount): Use
	ro_u_proc.
	(fhandler_base::fstat_by_handle): Don't copy attributes if file is an
	NT device.
	(fhandler_base::fstat_by_name): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::exists): Return
	virtual_ftype_t.
	* fhandler_proc.cc (proc_tab): Sort alphabetically.  Use _VN macro
	to store length.
	(proc_len): Change to size_t.
	(proc_tab_cmp): New static function.
	(virt_tab_search): New function to search entry in virt_tab_t
	arrays.  Use throughout in /proc and sibling classes instead of
	loop.
	(fhandler_proc::exists): Return virtual_ftype_t.
	* fhandler_process.cc (process_tab): Sort alphabetically.  Use _VN
	macro to store length.
	(fhandler_process::exists): Return virtual_ftype_t.
	(fhandler_process::open): Simplify code.
	* fhandler_procnet.cc (procnet_tab): Sort alphabetically.  Use _VN
	macro to store length.
	(fhandler_procnet::exists): Return virtual_ftype_t.
	(fhandler_procnet::open): Simplify.
	* fhandler_procsys.cc: New file.
	* fhandler_registry.cc (fhandler_registry::exists): Return
	virtual_ftype_t.
	* fhandler_virtual.cc (fhandler_virtual::exists): Ditto.
	* fhandler_virtual.h (enum virtual_ftype_t): Move to fhandler.h.
	(virt_tab_t): Add name_len member.
	(_VN): New macro.
	(virt_tab_search): Declare.
	* mount.cc (mount_info::conv_to_win32_path): Fix comment.  Backslashify
	isprocsys_dev paths.
	* ntdll.h (STATUS_OBJECT_TYPE_MISMATCH): Define
	(STATUS_INSTANCE_NOT_AVAILABLE): Define.
	(STATUS_PIPE_NOT_AVAILABLE): Define.
	(STATUS_INVALID_PIPE_STATE): Define.
	(STATUS_PIPE_BUSY): Define.
	(SYMBOLIC_LINK_QUERY): Define.
	(NtOpenSymbolicLinkObject): Declare.
	(NtQuerySymbolicLinkObject): Declare.
	* path.cc (path_conv::check): Accommodate fact that exists method
	returns virtual_ftype_t now.  Add cases for new virtual_ftype_t
	types.
	(cygwin_conv_path): Add GLOBALROOT prefix to native device paths.
	Make sure to strip \\?\ prefix only for actual filesystem-based
	paths, not for all paths.
	* path.h (isproc_dev): Add FH_PROCSYS.
	(isprocsys_dev): Define.
@
text
@d1949 1
a2241 1
  FILE_BASIC_INFORMATION fbi;
d2412 3
d2418 22
a2439 7
	  && (fs.inited () || fs.update (&upath, h))
	  && NT_SUCCESS (status = fs.has_buggy_basic_info ()
			 ? NtQueryAttributesFile (&attr, &fbi)
			 : NtQueryInformationFile (h, &io, &fbi, sizeof fbi,
						   FileBasicInformation)))
	fileattr = fbi.FileAttributes;
      else
d2525 4
a2528 1
		    fileattr = fdi_buf.fdi.FileAttributes;
d2614 5
a2618 1
	    break;
@


1.605
log
@	* path.cc (normalize_posix_path): Preserve //./ and //?/ prefixes.
	(path_conv::check): Allow access to root directory of native NT disk
	devices.
@
text
@d764 2
a765 2
	      int file_type = fh->exists ();
	      if (file_type == -2)
d773 2
a774 2
		  case 1:
		  case 2:
d778 1
a778 1
		  case -1:
d782 1
a782 1
		  case -2:	/* /proc/self or /proc/<pid>/symlinks */
d784 1
a784 1
		  case -3:	/* /proc/<pid>/fd/pipe:[] */
d791 1
a791 1
		  case -4:	/* /proc/<pid>/fd/socket:[] */
d798 30
d874 2
d2885 8
d2934 2
a2935 1
	  if (lsiz <= MAX_PATH + 4 || (path[5] != L':' && lsiz <= MAX_PATH + 6))
d2946 7
d2994 1
a2994 1
      strcpy ((char *) to, buf);
d2997 1
a2997 1
      wcscpy ((PWCHAR) to, path);
@


1.604
log
@	* external.cc (sync_wincwd): Remove.
	(cygwin_internal): Drop CW_SYNC_WINCWD case.
	* globals.cc (ro_u_pipedir): New R/O unicode string.
	* ntdll.h (RtlSetCurrentDirectory_U): Declare.
	* path.cc (cwdstuff::set): Improve comments.  Drop setting Win32 CWD to
	\\?\PIPE\ on init.  Keep Win32 CWD in sync, if possible.  Set to
	\\?\PIPE\ otherwise.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Revert to 230.
	* include/sys/cygwin.h (cygwin_getinfo_types): Remove CW_SYNC_WINCWD.
@
text
@d270 8
d829 7
@


1.603
log
@	* path.cc (path_conv::check): Close handle in conv_handle if we're
	following a symlink.
@
text
@d3289 1
d3295 2
a3296 1
  /* Here are the problems with using SetCurrentDirectory:
d3302 3
a3304 4
     - SetCurrentDirectory fails for directories with strict
       permissions even for processes with the SE_BACKUP_NAME
       privilege enabled.  The reason is apparently that
       SetCurrentDirectory calls NtOpenFile without the
d3309 2
a3310 2
     - Unlinking a cwd fails because SetCurrentDirectory seems to
       open directories so that deleting the directory is disallowed.
d3315 16
a3330 5
     Therefore, we do without SetCurrentDirectory and handle the CWD all
     by ourselves.  To avoid surprising behaviour in the Win32 API which
     would stem from the fact that the Win32 CWD is different from the
     POSIX CWD, we move the Win32 CWD to an invalid directory in which
     typical relative Win32 path handling fails.  */
a3346 1
      NTSTATUS status;
d3365 3
a3367 1
         directory is valid for Win32 apps. */
a3412 9

      /* When inited move the actual Win32 CWD out of the way, as explained
	 above.  Surprisingly, the PIPE filesystem seems to be usable as CWD
	 on all Windows systems. */
      if (!SetCurrentDirectoryW (L"\\\\?\\PIPE\\"))
	system_printf (
"WARNING: Couldn't set Win32 CWD to //?/PIPE (error %E).  This will\n"
"probably not affect normal POSIX path operations.  However, please report\n"
"this problem to the mailing list mailto:cygwin@@cygwin.com.  Thank you.");
d3475 9
@


1.602
log
@	* fhandler_disk_file.cc (readdir_check_reparse_point): Rename from
	is_volume_mountpoint.  Return valid d_type value for underlying
	reparse point type.
	(readdir_get_ino): Don't rely on the handle set in pc.check.  Open
	file here if pc.handle() is NULL.
	(fhandler_disk_file::readdir_helper): Try to set a correct d_type value
	more diligent.
	(fhandler_disk_file::readdir): Don't reset dirent_set_d_ino unless
	we're really sure it's due to an untrusted FS.  Simplify usage of
	FileAttributes, which is 0 if buf is NULL, anyway.  Set d_type
	correctly for faked "." and ".." entries.  Improve debug output.
	* path.cc (symlink_info::check): Don't keep handle to volume mount
	point open.  Explain why.
@
text
@d903 3
@


1.601
log
@	* exceptions.cc (open_stackdumpfile): Don't try to open file if we
	have no filesystem based CWD.  Add comment.
	* path.cc (cwdstuff::set): Set CWD handle to NULL if CWD is a virtual
	path.  Simplify matching comment.
@
text
@d2536 5
@


1.600
log
@	* cygheap.h (class cwdstuff): Make drive_length private.
	Add "error" member.
	(cwdstuff::get_error): New inline method.
	(cwdstuff::get_error_desc): Declare.
	(cwdstuff::set): Change first parameter to pointer to path_conv.
	* path.cc (chdir): Drop doit.  Align call to cwdstuff::set to
	new arguments.
	(cwdstuff::init): Only call cwdstuff::set if it's not already
	initialized.  Add comment.  Drop third parameter in call to
	cwdstuff::set.
	(cwdstuff::set): Partially rewrite.  Add lots of comments to explain
	everything.  Drop "doit" since it's not used anymore.  Always create
	new handle to CWD if not in a virtual path.  Drop PEB locking when
	reading PEB values in init phase.  Check for accessibility to set
	correct error code.  Drop Vista workaround.  Never write back into PEB.
	Set Win32 CWD to \\?\PIPE\ on init.  Simplify creation of win32 path.
	Set new error member to a meaningful value.
	(cwdstuff::get_error_desc): New method to generate error message
	from cwd error code.
	* spawn.cc (spawn_guts): Call cwdstuff::get_error_desc to create
	more meaningful error message when not being able to start native
	Win32 app due to CWD restrictions.  When starting native Win32 app,
	lock cwd and use in calls to CreateProcessW/CreateProcessAsUserW.
@
text
@d3324 1
a3326 1
      HANDLE h;
a3365 11
      /* Note that we don't set the dir handle to NULL for virtual paths.
	 The handle is used to generate a stackdump file.  Since we can't
	 create a stackdump in a virtual path, we have at least *some*
	 directory handle to generate the stackdump in.

	 However, note that we have to make sure that we don't use the handle
	 wrongly as soon as we start to use it in other cases as well. */
      HANDLE old_dir = dir;
      dir = h;
      if (old_dir)
	NtClose (old_dir);
d3367 4
@


1.599
log
@	* path.cc (cygwin_conv_path): Rearrange test for "." in POSIX to
	relative DOS path conversion.  Simplify fixing the path.
	In CCP_POSIX_TO_WIN_W conversion, always drop long path prefix if path
	fits into MAX_PATH.  Explain why.
@
text
@a2731 1
  bool doit = false;
a2747 1
      doit = true;
d2756 1
a2756 1
    res = cygheap->cwd.set (path.get_nt_native_path (), posix_cwd, doit);
d3267 6
d3274 1
a3274 1
  set (NULL, NULL, true);
d3279 1
a3279 1
cwdstuff::set (PUNICODE_STRING nat_cwd, const char *posix_cwd, bool doit)
a3280 1
  int res = 0;
d3282 29
a3310 1
  size_t len = 0;
d3316 3
a3318 9
      upath = *nat_cwd;
      if (upath.Buffer[0] == L'/') /* Virtual path.  Never use in PEB. */
	doit = false;
      else
	{
	  len = upath.Length / sizeof (WCHAR) - 4;
	  if (RtlEqualUnicodePathPrefix (&upath, &ro_u_uncp, TRUE))
	    len -= 2;
	}
d3321 4
a3324 1
  if (doit)
a3325 12
      /* We utilize the user parameter block.  The directory is
	 stored manually there.  Why the hassle?

	 - SetCurrentDirectory fails for directories with strict
	   permissions even for processes with the SE_BACKUP_NAME
	   privilege enabled.  The reason is apparently that
	   SetCurrentDirectory calls NtOpenFile without the
	   FILE_OPEN_FOR_BACKUP_INTENT flag set.

	 - Unlinking a cwd fails because SetCurrentDirectory seems to
	   open directories so that deleting the directory is disallowed.
	   The below code opens with *all* sharing flags set. */
a3329 1
      PHANDLE phdl;
d3331 16
a3346 8
      RtlAcquirePebLock ();
      phdl = &get_user_proc_parms ()->CurrentDirectoryHandle;
      if (!nat_cwd) /* On init, just reopen CWD with desired access flags. */
	RtlInitUnicodeString (&upath, L"");
      /* This is for Win32 apps only.  No case sensitivity here... */
      InitializeObjectAttributes (&attr, &upath,
				  OBJ_CASE_INSENSITIVE | OBJ_INHERIT,
				  nat_cwd ? NULL : *phdl, NULL);
d3350 10
a3359 2
			   | FILE_SYNCHRONOUS_IO_NONALERT
			   | FILE_OPEN_FOR_BACKUP_INTENT);
d3362 1
a3362 1
	  RtlReleasePebLock ();
d3364 1
a3364 2
	  res = -1;
	  goto out;
d3366 47
a3412 12
      /* Workaround a problem in Vista/Longhorn which fails in subsequent
	 calls to CreateFile with ERROR_INVALID_HANDLE if the handle in
	 CurrentDirectoryHandle changes without calling SetCurrentDirectory,
	 and the filename given to CreateFile is a relative path.  It looks
	 like Vista stores a copy of the CWD handle in some other undocumented
	 place.  The NtClose/DuplicateHandle reuses the original handle for
	 the copy of the new handle and the next CreateFile works.
	 Note that this is not thread-safe (yet?) */
      NtClose (*phdl);
      if (DuplicateHandle (GetCurrentProcess (), h, GetCurrentProcess (), phdl,
			   0, TRUE, DUPLICATE_SAME_ACCESS))
	NtClose (h);
a3413 13
	*phdl = h;
      dir = *phdl;

      /* No need to set path on init. */
      if (nat_cwd
	  /* TODO:
	     Check the length of the new CWD.  Windows can only handle
	     CWDs of up to MAX_PATH length, including a trailing backslash.
	     If the path is longer, it's not an error condition for Cygwin,
	     so we don't fail.  Windows on the other hand has a problem now.
	     For now, we just don't store the path in the PEB and proceed as
	     usual. */
	  && len <= MAX_PATH - (nat_cwd->Buffer[len - 1] == L'\\' ? 1 : 2))
d3415 7
a3423 2
	  if (upath.Buffer[1] == L'\\') /* UNC path */
	    upath.Buffer[0] = L'\\';
d3425 5
a3429 8
	  /* Append backslash if necessary. */
	  if (upath.Buffer[len - 1] != L'\\')
	    {
	      upath.Buffer[len] = L'\\';
	      upath.Length += sizeof (WCHAR);
	    }
	  RtlCopyUnicodeString (&get_user_proc_parms ()->CurrentDirectoryName,
				&upath);
d3431 17
a3447 2

      RtlReleasePebLock ();
d3449 1
a3449 2

  if (nat_cwd || !win32.Buffer)
d3451 2
a3452 22
      /* If there is no win32 path */
      if (!nat_cwd)
	{
	  PUNICODE_STRING pdir;

	  RtlAcquirePebLock ();
	  pdir = &get_user_proc_parms ()->CurrentDirectoryName;
	  RtlInitEmptyUnicodeString (&win32,
				     (PWCHAR) crealloc_abort (win32.Buffer,
							      pdir->Length + 2),
				     pdir->Length + 2);
	  RtlCopyUnicodeString (&win32, pdir);
	  RtlReleasePebLock ();

	  PWSTR eoBuffer = win32.Buffer + (win32.Length / sizeof (WCHAR));
	  /* Remove trailing slash if one exists.  FIXME: Is there a better way to
	     do this? */
	  if ((eoBuffer - win32.Buffer) > 3 && eoBuffer[-1] == L'\\')
	    win32.Length -= sizeof (WCHAR);

	  posix_cwd = NULL;
	}
a3454 36
	  bool unc = false;

	  if (upath.Buffer[0] == L'/') /* Virtual path, don't mangle. */
	    ;
	  else if (!doit)
	    {
	      /* Convert to a Win32 path. */
	      upath.Buffer += upath.Length / sizeof (WCHAR) - len;
	      if (upath.Buffer[1] == L'\\') /* UNC path */
		unc = true;
	      upath.Length = len * sizeof (WCHAR);
	    }
	  else
	    {
	      PWSTR eoBuffer = upath.Buffer + (upath.Length / sizeof (WCHAR));
	      /* Remove trailing slash if one exists.  FIXME: Is there a better way to
		 do this? */
	      if ((eoBuffer - upath.Buffer) > 3 && eoBuffer[-1] == L'\\')
		upath.Length -= sizeof (WCHAR);
	    }
	  RtlInitEmptyUnicodeString (&win32,
				     (PWCHAR) crealloc_abort (win32.Buffer,
							      upath.Length + 2),
				     upath.Length + 2);
	  RtlCopyUnicodeString (&win32, &upath);
	  if (unc)
	    win32.Buffer[0] = L'\\';
	}
      /* Make sure it's NUL-terminated. */
      win32.Buffer[win32.Length / sizeof (WCHAR)] = L'\0';
      if (!doit)			 /* Virtual path */
	drive_length = 0;
      else if (win32.Buffer[1] == L':')	 /* X: */
	drive_length = 2;
      else if (win32.Buffer[1] == L'\\') /* UNC path */
	{
d3463 7
a3469 2
      else				 /* Shouldn't happen */
	drive_length = 0;
d3471 6
a3476 8
      tmp_pathbuf tp;
      if (!posix_cwd)
	{
	  posix_cwd = (const char *) tp.c_get ();
	  mount_table->conv_to_posix_path (win32.Buffer, (char *) posix_cwd, 0);
	}
      posix = (char *) crealloc_abort (posix, strlen (posix_cwd) + 1);
      stpcpy (posix, posix_cwd);
d3478 2
a3480 1
out:
d3482 23
a3504 1
  return res;
@


1.598
log
@* path.cc (path_conv::check): Move fs-specific settings to a point where we
know that we have filled out the filesystem information.
* path.h (path_conv::path_conv): Use consistent initialization for
constructors.
* include/sys/cygwin.h: Define CW_STRERROR.
* include/cygwin/version.h: Bump CYGWIN_VERSION_API_MINOR to 228.
* include/external.h: Implement CW_STRERROR.
@
text
@d2808 1
d2837 1
a2837 1
	if (!strcmp ((const char *) from, ".") && relative
d2840 2
a2841 2
	    --lsiz;
	    buf[lsiz - 1] = '\0';
d2862 22
d2885 2
a2886 2
      if (!strcmp ((const char *) from, ".") && relative
	  && !wcscmp (p.get_nt_native_path ()->Buffer, L".\\"))
d2888 2
a2889 3
	  --lsiz;
	  p.get_nt_native_path ()->Length -= sizeof (WCHAR);
	  p.get_nt_native_path ()->Buffer[lsiz - 1] = L'\0';
d2928 1
a2928 1
      p.get_wide_win32_path ((PWCHAR) to);
@


1.597
log
@	* dtable.cc (dtable::dup_worker): Reset path_conv handle in duplicated
	fhandler.
	* fhandler.cc (fhandler_base::fstatvfs): Keep handle in created
	path_conv.
	* fhandler.h (fhandler_base::get_stat_access): New method.
	(fhandler_base::get_stat_handle): New method.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Use handle
	returned by get_stat_handle.  Only request inode from system if it
	isn't already set in the fhandler, and only for filesystems supporting
	them.
	(fhandler_base::fstat_fs): Use handle returned by get_stat_handle.
	Change the way open_fs is called.  Explain why.
	(fhandler_base::fstat_helper): Use handle returned by get_stat_handle.
	Never use 0 inode number.  Simplify executable recognition by re-using
	get_stat_handle if file could be opened with sufficient rights.
	(fhandler_disk_file::fstatvfs): Use handle returned by get_stat_handle.
	(fhandler_disk_file::facl): Use handle returned by get_stat_handle in
	GETACL and GETACLCNT cases.
	(fhandler_disk_file::link): Use handle returned by get_stat_handle
	instead of opening file here again.  Add comment.
	(readdir_get_ino): Keep handle in created path_conv and drop
	opening file.
	* ntdll.h (wait_pending): New helper function.
	* path.cc (symlink_info::check): Drop unused 'opt' parameter from
	declaration.  Add path_conv_handle argument.
	(path_conv::check): Make sure conv_handle is closed.  Keep
	PC_KEEP_HANDLE flag in pflags_or.  Accommodate call to sym.check to
	new args.
	(path_conv::~path_conv): Close conv_handle.
	(symlink_info::check_shortcut): Don't re-open file here, just use
	incoming handle.  Drop goto's and label out.
	(symlink_info::check_sysfile): Don't re-open file here, just use
	incoming handle.  Keep track of file position to accommodate the fact
	that file has been opened asynchronously in calling function.
	(symlink_info::check_nfs_symlink): Don't re-open file here, just use
	incoming handle.
	(symlink_info::check): Drop unused 'opt' parameter.  Add
	path_conv_handle argument.  Always try to open file with GENERIC_READ
	rights first to allow reading file content w/o having to re-open the
	file.  Drop back to READ_CONTROL | FILE_READ_ATTRIBUTES otherwise.
	Call symlink test functions (except for check_reparse_point) only if
	file could be opened with GENERIC_READ.  Keep file handle open if
	PC_KEEP_HANDLE is set in pflags.
	* path.h (enum pathconv_arg): Add PC_KEEP_HANDLE flag.
	(class path_conv_handle): New class.
	(class path_conv): Add conv_handle member.
	(path_conv::operator =): Duplicate conv_handle.
	(path_conv::handle): New method.
	(path_conv::access): New method.
	(path_conv::reset_conv_handle): New method.
	(path_conv::close_conv_handle): New method.
@
text
@a863 10
	      /* If the FS has been found to have unrelibale inodes, note
	         that in path_flags. */
	      if (!fs.hasgood_inode ())
		path_flags |= PATH_IHASH;
	      /* If the OS is caseinsensitive or the FS is caseinsensitive,
	         don't handle path casesensitive. */
	      if (cygwin_shared->obcaseinsensitive || fs.caseinsensitive ())
		path_flags |= PATH_NOPOSIX;
	      caseinsensitive = (path_flags & PATH_NOPOSIX)
				? OBJ_CASE_INSENSITIVE : 0;
d1050 10
@


1.596
log
@	* path.cc (path_conv::check): Return with ENOTDIR if component is a
	device.
@
text
@d99 2
a100 2
  int check (char *path, const suffix_info *suffixes, unsigned opt,
	     fs_info &fs);
d642 1
d699 3
a701 1
      for (unsigned pflags_or = opt & PC_NO_ACCESS_CHECK; ; pflags_or = 0)
d829 1
a829 1
	  symlen = sym.check (full_path, suff, opt, fs);
d1130 1
d1690 1
a1690 1
symlink_info::check_shortcut (HANDLE in_h)
a1696 1
  OBJECT_ATTRIBUTES attr;
a1697 1
  HANDLE h;
d1700 1
a1701 7
  InitializeObjectAttributes (&attr, &ro_u_empty, 0, in_h, NULL);
  status = NtOpenFile (&h, FILE_READ_DATA | SYNCHRONIZE,
		       &attr, &io, FILE_SHARE_VALID_FLAGS,
		       FILE_OPEN_FOR_BACKUP_INTENT
		       | FILE_SYNCHRONOUS_IO_NONALERT);
  if (!NT_SUCCESS (status))
    return 0;
d1707 1
a1707 1
      goto out;
d1711 1
a1711 1
    goto out;
d1716 4
a1719 2
  if (!NT_SUCCESS (NtReadFile (h, NULL, NULL, NULL,
			       &io, buf, fsi.EndOfFile.LowPart, NULL, NULL)))
d1721 3
a1723 2
      set_error (EIO);
      goto out;
d1728 1
a1728 1
    goto out;
d1733 1
a1733 1
    goto out;
d1753 1
a1753 1
	    goto out;
d1757 1
a1757 1
	goto out;
a1765 3

out:
  NtClose (h);
d1770 1
a1770 1
symlink_info::check_sysfile (HANDLE in_h)
a1775 1
  OBJECT_ATTRIBUTES attr;
a1776 1
  HANDLE h;
d1779 1
d1781 3
a1783 5
  InitializeObjectAttributes (&attr, &ro_u_empty, 0, in_h, NULL);
  status = NtOpenFile (&h, FILE_READ_DATA | SYNCHRONIZE,
		       &attr, &io, FILE_SHARE_VALID_FLAGS,
		       FILE_OPEN_FOR_BACKUP_INTENT
		       | FILE_SYNCHRONOUS_IO_NONALERT);
a1784 4
    return 0;
  else if (!NT_SUCCESS (status = NtReadFile (h, NULL, NULL, NULL, &io,
					     cookie_buf, sizeof (cookie_buf),
					     NULL, NULL)))
d1789 1
d1791 2
a1792 1
  else if (io.Information == sizeof (cookie_buf)
d1811 1
a1811 3
      FILE_POSITION_INFORMATION fpi;
      fpi.CurrentByteOffset.QuadPart = sizeof (INTERIX_SYMLINK_COOKIE) - 1;
      NtSetInformationFile (h, &io, &fpi, sizeof fpi, FilePositionInformation);
d1816 2
a1817 1
			   NT_MAX_PATH, NULL, NULL);
a1844 1
  NtClose (h);
a1907 1
  OBJECT_ATTRIBUTES attr;
a1915 5
  InitializeObjectAttributes (&attr, &ro_u_empty, 0, h, NULL);
  status = NtOpenFile (&h, FILE_READ_EA, &attr, &io, FILE_SHARE_VALID_FLAGS,
		       FILE_OPEN_REPARSE_POINT | FILE_OPEN_FOR_BACKUP_INTENT);
  if (!NT_SUCCESS (status))
    return 0;
a1923 1
  NtClose (h);
d1929 1
a1929 1
		      spath, pffei->EaValueLength);
d2182 2
a2183 2
symlink_info::check (char *path, const suffix_info *suffixes, unsigned opt,
		     fs_info &fs)
d2223 4
d2244 2
a2245 4
      status = NtCreateFile (&h,
			     READ_CONTROL | FILE_READ_ATTRIBUTES,
			     &attr, &io, NULL, 0, FILE_SHARE_VALID_FLAGS,
			     FILE_OPEN,
d2249 11
a2259 1
      debug_printf ("%p = NtCreateFile (%S)", status, &upath);
d2279 2
a2280 2
	  status = NtOpenFile (&h, READ_CONTROL | FILE_READ_ATTRIBUTES,
			       &attr, &io, FILE_SHARE_VALID_FLAGS,
d2283 10
a2292 1
	  debug_printf ("%p = NtOpenFile (no-EA, %S)", status, &upath);
d2484 4
a2487 1
	  res = check_shortcut (h);
d2547 4
a2550 1
	  res = check_sysfile (h);
d2555 2
a2556 2
      /* If the file could be opened with FILE_READ_EA, and if it's on a
	 NFS share, check if it's a symlink.  Only files can be symlinks
d2560 4
a2563 1
	  res = check_nfs_symlink (h);
d2577 6
a2582 1
    NtClose (h);
@


1.595
log
@	* path.cc (symlink_info::check_shortcut): Use ro_u_empty rather than
	local UNICODE_STRING object.
	(symlink_info::check_sysfile): Ditto.  Return immediately if NtOpenFile
	failed to avoid closing random handle.  Improve debug output in case
	NtReadFile failed.
@
text
@d832 5
@


1.594
log
@	* path.cc (symlink_info::check): Set h to NULL after closing handle
	in udf check.  Remove overagressive bracketing.  Don't set h to NULL
	without closing the handle.  Fix using wrong handle in checking
	file system when using parent directory handle.
@
text
@a1687 1
  UNICODE_STRING same = { 0, 0, (PWCHAR) L"" };
d1694 1
a1694 1
  InitializeObjectAttributes (&attr, &same, 0, in_h, NULL);
a1774 1
  UNICODE_STRING same = { 0, 0, (PWCHAR) L"" };
d1781 1
a1781 1
  InitializeObjectAttributes (&attr, &same, 0, in_h, NULL);
d1787 1
a1787 1
    ;
d1792 1
a1792 1
      debug_printf ("ReadFile1 failed");
@


1.593
log
@	* ntdll.h (STATUS_BAD_NETWORK_PATH): Define.
	(STATUS_BAD_NETWORK_NAME): Define.
	* path.cc (symlink_info::check): Convert STATUS_BAD_NETWORK_PATH and
	STATUS_BAD_NETWORK_NAME into an immediate ENOENT.
@
text
@d2311 1
d2359 1
a2359 1
	  && (fs.inited () || (fs.update (&upath, h)))
a2367 1
	  h = NULL;
d2430 1
a2430 1
		  fs.update (&upath, h);
@


1.592
log
@	* path.cc (symlink_info::check): Don't try to handle remote reparse
	points as symlinks.  Explain why.
@
text
@d2382 2
@


1.591
log
@	* path.cc (path_conv::check): Drop setting sym.pflags before calling
	mount_info::conv_to_win32_path since the flag value is overwritten by
	mount_info::conv_to_win32_path anyway.
	Set flags for DOS paths before calling symlink_info::check so they can
	be used in that function already.
@
text
@d2506 8
a2513 2
	 with SYSTEM and HIDDEN flags set. */
      else if (fileattr & FILE_ATTRIBUTE_REPARSE_POINT)
@


1.590
log
@	* mount.cc (struct opt): Add "dos" and "ihash" options.
	(fillout_mntent): Ditto.
	* path.cc (path_conv::get_nt_native_path): Use path_conv's
	has_dos_filenames_only method.
	(path_conv::check): Add PATH_IHASH flag if FS has unreliable inode
	numbers.
	(symlink_info::check_shortcut): Or symlink flags to pflags.
	(symlink_info::check_sysfile): Ditto.  Change test accordingly.
	(symlink_info::check_reparse_point): Ditto.
	(symlink_info::check_nfs_symlink): Ditto.
	(symlink_info::check): Check PATH_DOS flag in call to get_nt_native_path
	to utilize mount flag.  Ditto in test for potential restarting.  Set
	PATH_DOS if FS only allows DOS filename rules.
	* path.h (enum path_types): Add PATH_DOS and PATH_IHASH.
	(path_conv::hasgood_inode): Check PATH_IHASH instead of
	fs.hasgood_inode.
	(path_conv::has_dos_filenames_only): New method.
	* include/sys/mount.h (MOUNT_DOS): New mount flag.
	(MOUNT_IHASH): Ditto.
@
text
@a707 1
	      sym.pflags = 0;
a712 1
	      sym.pflags = path_flags;
d819 7
a863 4
	      /* If the incoming path was given in DOS notation, always treat
	         it as caseinsensitive,noacl path. */
	      else if (is_msdos)
		path_flags |= PATH_NOPOSIX | PATH_NOACL;
@


1.589
log
@	* mount.h (fs_info::inited): New inline method.
	* path.cc (path_conv::check): Clear filesystem info if following a
	symlink.  Use new fs_info::inited method to check if FS info is already
	available.
	(symlink_info::check): Drop fs_update_called.  Use fs_info::inited
	method instead.  Streamline test for leading space and trailing dot or
	space.  Add comments.
@
text
@d460 1
a460 1
      ::get_nt_native_path (path, uni_path, fs.has_dos_filenames_only ());
d851 4
d1761 1
a1761 1
    pflags = PATH_SYMLINK | PATH_LNK;
d1801 1
a1801 1
      pflags = PATH_SYMLINK;
d1811 1
a1811 1
      pflags = PATH_SYMLINK;
d1820 1
a1820 1
  if (pflags == PATH_SYMLINK)
d1905 1
a1905 1
  pflags = PATH_SYMLINK | PATH_REP;
d1944 1
a1944 1
      pflags = PATH_SYMLINK;
d2243 1
a2243 1
      get_nt_native_path (suffix.path, upath, fs.has_dos_filenames_only ());
d2323 1
a2323 2
	  if (!restarted && !*ext_here
	      && (!fs.inited () || fs.has_dos_filenames_only ()))
d2346 1
@


1.588
log
@	* path.h (get_nt_native_path): Add third parameter to declaration and
	declare with regparms.
	* path.cc (get_nt_native_path): Add third parameter to allow conversion
	of leading and trailing dots and spaces on filesystems only supporting
	filenames following DOS rules.
	(path_conv::get_nt_native_path): Call get_nt_native_path according to
	fs.has_dos_filenames_only flag.
	(getfileattr): Accommodate new parameter to get_nt_native_path.
	(symlink_info::check): Revamp fs_update_called handling to call
	fs.update only once per call.  Call get_nt_native_path according to
	fs.has_dos_filenames_only flag.  Streamline filesystem dependent code
	not to be called more than once unnecessarily.  Drop code tweaking
	incoming path for broken filesystems only allowing DOS pathnames.
	Rely on changed get_nt_native_path instead.
	* mount.cc (fillout_mntent): Accommodate new parameter to
	get_nt_native_path.
	* strfuncs.cc (tfx_rev_chars): New conversion table with comment.
	(sys_cp_wcstombs): Use tfx_rev_chars rather than tfx_chars.
@
text
@d897 4
a900 2
	      else
		break;
d1031 2
a1032 2
      /* FS has been checked already for existing files. */
      if (exists () || fs.update (get_nt_native_path (), NULL))
a2202 1
  bool fs_update_called = false;
d2286 1
a2286 1
	      && (!fs_update_called || fs.is_udf ()))
d2301 2
a2302 2
		  if (!fs_update_called)
		    fs_update_called = fs.update (&upath, h);
d2320 1
a2320 1
	      && (!fs_update_called || fs.has_dos_filenames_only ()))
d2322 1
a2322 1
	      /* Check for leading space or trailing dot or space in
d2324 9
a2332 9
	      char *pend = ext_here;
	      if (pend[-1] == '.' || pend[-1] == ' ')
		--pend;
	      char *pbeg = pend;
	      while (pbeg[-1] != '\\')
	      	--pbeg;
	      /* If so, call fs.update to check if the filesystem is one of
		 the broken ones. */
	      if (*pbeg == ' ' || *pend != '\0')
d2334 4
a2337 2
		  if (!fs_update_called)
		    fs_update_called = fs.update (&upath, NULL);
d2340 3
a2342 1
		      /* If so, try again. */
d2353 1
a2353 1
	  && (fs_update_called || (fs_update_called = fs.update (&upath, h)))
d2423 1
a2423 1
		  fs_update_called = fs.update (&upath, h);
@


1.587
log
@	* path.cc (symlink_info::check): Make sure to restart only once.
@
text
@d396 1
a396 1
get_nt_native_path (const char *path, UNICODE_STRING& upath)
d428 20
d460 1
a460 1
      ::get_nt_native_path (path, uni_path);
d524 1
a524 1
  get_nt_native_path (path, upath);
d2201 1
d2203 2
a2204 2
  ULONG ci_flag = cygwin_shared->obcaseinsensitive || (pflags & PATH_NOPOSIX)
		  ? OBJ_CASE_INSENSITIVE : 0;
a2235 1
      bool fs_update_called = false;
d2238 1
a2238 1
      get_nt_native_path (suffix.path, upath);
d2284 2
a2285 1
	  if (ci_flag == 0 && wincap.has_broken_udf ())
d2300 3
a2302 4
		  fs.update (&upath, h);
		  if (fs.is_udf ())
		    fs_update_called = true;
		  else
d2318 2
a2319 1
	  if (!restarted && !*ext_here && !fs_update_called)
d2324 1
a2324 1
	      while (pend[-1] == '.' || pend[-1] == ' ')
d2331 1
a2331 3
	      if ((*pbeg == ' ' || *pend != '\0')
		  && fs.update (&upath, NULL)
		  && fs.has_dos_filenames_only ())
d2333 8
a2340 9
		  /* If so, strip leading spaces and trailing dots and spaces
		     from filename and... */
		  if (pbeg)
		    while (*pbeg == ' ')
		      memmove (pbeg, pbeg + 1, --pend - pbeg);
		  *pend = '\0';
		  /* ...try again. */
		  restarted = true;
		  goto restart;
d2348 1
a2348 1
	  && (fs_update_called || fs.update (&upath, h))
d2418 1
a2418 1
		  fs.update (&upath, h);
@


1.586
log
@	* mount.cc (GETVOLINFO_VALID_MASK): Drop FILE_SEQUENTIAL_WRITE_ONCE
	from mask.  Expand the comment a bit.
	(WIN_FAT_FLAGS): New define.
	(FS_IS_WINDOWS_FAT): New macro.
	(fs_info::update): Handle remote FS faking to be FAT.  Subsume under
	CIFS.  Check for NWFS and has_buggy_basic_info only for remote
	filesystems.  Add check for has_dos_filenames_only.
	* mount.h (class fs_info): Add has_dos_filenames_only status flag.
	Implement accessors.
	* path.cc (symlink_info::check): Rearrange variable definitions to
	clear them up.  Add a restart label to allow a clean restart within
	the method.  Add a check for broken filesystems only allowing DOS
	pathnames in case we encounter a STATUS_OBJECT_NAME_NOT_FOUND status.
	If all checks point to one of that, restart method with tweaked
	incoming path.  Add lengthy comments to explain what we do.
@
text
@d2192 1
d2298 1
a2298 1
	  if (!*ext_here && !fs_update_called)
d2321 1
@


1.585
log
@	* path.cc (symlink_info::check): Fix a comment.
@
text
@d2173 7
a2179 2
  HANDLE h = NULL;
  int res = 0;
d2181 15
a2196 1

a2198 2
  ext_here = suffix.has (path, suffixes);
  extn = ext_here - path;
a2202 2
  ULONG ci_flag = cygwin_shared->obcaseinsensitive || (pflags & PATH_NOPOSIX)
		  ? OBJ_CASE_INSENSITIVE : 0;
d2204 2
a2205 7
  /* TODO: Temporarily do all char->UNICODE conversion here.  This should
     already be slightly faster than using Ascii functions. */
  tmp_pathbuf tp;
  UNICODE_STRING upath;
  OBJECT_ATTRIBUTES attr;
  tp.u_get (&upath);
  InitializeObjectAttributes (&attr, &upath, ci_flag, NULL, NULL);
a2212 3
      FILE_BASIC_INFORMATION fbi;
      NTSTATUS status;
      IO_STATUS_BLOCK io;
d2261 37
a2297 14
      if (status == STATUS_OBJECT_NAME_NOT_FOUND && ci_flag == 0
	  && wincap.has_broken_udf ())
        {
	  /* On NT 5.x UDF is broken (at least) in terms of case sensitivity.
	     When trying to open a file case sensitive, the file appears to be
	     non-existant.  Another bug is described in fs_info::update. */
	  attr.Attributes = OBJ_CASE_INSENSITIVE;
	  status = NtOpenFile (&h, READ_CONTROL | FILE_READ_ATTRIBUTES,
			       &attr, &io, FILE_SHARE_VALID_FLAGS,
			       FILE_OPEN_REPARSE_POINT
			       | FILE_OPEN_FOR_BACKUP_INTENT);
	  debug_printf ("%p = NtOpenFile (broken-UDF, %S)", status, &upath);
	  attr.Attributes = 0;
	  if (NT_SUCCESS (status))
d2299 22
a2320 7
	      fs.update (&upath, h);
	      if (fs.is_udf ())
		fs_update_called = true;
	      else
	      	{
		  NtClose (h);
		  status = STATUS_OBJECT_NAME_NOT_FOUND;
@


1.584
log
@* path.cc (cygwin_create_path): Free memory on error.
@
text
@d2438 5
a2442 5
		 level directory should be for the volume top level directory
		 itself, rather than for the reparse point itself.  So we
		 fetch the filesystem information again, but with a NULL
		 handle.  This does what we want because fs_info::update opens
		 the handle without FILE_OPEN_REPARSE_POINT. */
@


1.583
log
@* path.cc (path_conv::set_normalized_path): Use crealloc_abort to avoid a
memory leak.
* path.h (path_conv::operator =): Just use cstrdup to allocate normalized_path,
avoiding attempt to free a pointer which is allocated in another pc.
@
text
@d2815 3
a2817 3
    return NULL;
  if (!(to = malloc (size)))
    return NULL;
d2819 4
a2822 1
    return NULL;
@


1.582
log
@	* spawn.cc (find_exec): Enable finding paths in backslash notation,
	especially for the exec[vl]p functions.

	* path.cc (symlink_info::check): Disable returning directories with
	suffix appended here.
@
text
@d380 1
a380 1
      char *p = (char *) cmalloc_abort (HEAP_STR, n);
@


1.581
log
@	* path.cc (warn_msdos): Enforce extended hex printing of multibyte
	pathnames.
@
text
@d2200 1
d2384 9
@


1.580
log
@	* path.cc (path_conv::check): Treat native DOS paths as "noacl".
@
text
@d479 1
a479 1
    small_printf ("  MS-DOS style path detected: %s\n  POSIX equivalent preferred.\n",
d482 1
a482 1
    small_printf ("  MS-DOS style path detected: %s\n  Preferred POSIX equivalent is: %s\n",
@


1.579
log
@	* path.cc (symlink_info::check_nfs_symlink): Reopen file with
	FILE_READ_EA access since, surprisingly, you need it to read EAs even
	on NFS.
@
text
@d831 3
a833 5
	      /* If the OS is caseinsensitive or the FS is caseinsensitive or
	         the incoming path was given in DOS notation, don't handle
		 path casesensitive. */
	      if (cygwin_shared->obcaseinsensitive || fs.caseinsensitive ()
		  || is_msdos)
d835 4
@


1.578
log
@	Throughout, use FileBothDirectoryInformation info class rather than
	FileDirectoryInformation info class to avoid problems with incomplete
	filesystem implementations.  Fix comments accordingly.
	* fhandler_disk_file.cc (fhandler_disk_file::readdir_helper): Set
	fname->Length to 0 in error case to avoid potential crash in debug
	output.
	(fhandler_disk_file::readdir): Try to speed up the working default case.
	Check for STATUS_INVALID_NETWORK_RESPONSE as potential status value
	returned by filesystems not implementing FileIdBothDirectoryInformation.
	* ntdll.h (STATUS_INVALID_NETWORK_RESPONSE): Define.
	(FILE_BOTH_DIRECTORY_INFORMATION): Rename to official name.
	* path.cc (symlink_info::check): Don't request FILE_READ_EA access, it's
	not required for NFS.  Try to speed up the working default case.  Check
	for STATUS_INVALID_NETWORK_RESPONSE as potential status value returned
	by filesystems not supporting non-NULL EA parameters.  Fix the way
	fs.update is called.  Improve debug output.
@
text
@d1887 1
d1896 5
d1909 1
@


1.577
log
@	* globals.cc (ro_u_nwfs): New R/O unicode string.
	* mount.cc (fs_info::update): Check for NWFS filesystem.  Set
	has_buggy_basic_info, if so.  Add comment to explain why.
	(fillout_mntent): Add "nwfs" string to fs_names array.
	* mount.h (enum fs_info_type): Add nwfs.
	(class fs_info): Add has_buggy_basic_info status flag.  Add accessors
	for has_buggy_basic_info and is_nwfs.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Accommodate
	filesystems with broken FileBasicInformation handling.
	* path.cc (symlink_info::check): Ditto.
	* path.h (path_conv::has_buggy_basic_info): Add method.
@
text
@d517 1
a517 1
      FILE_DIRECTORY_INFORMATION fdi;
d532 1
a532 1
					 FileDirectoryInformation,
d2212 1
a2212 1
			     READ_CONTROL | FILE_READ_ATTRIBUTES | FILE_READ_EA,
d2218 1
d2220 8
a2227 5
      if (status == STATUS_ACCESS_DENIED || status == STATUS_EAS_NOT_SUPPORTED
	  || status == STATUS_NOT_SUPPORTED
	  /* Or a bug in Samba 3.2.x (x <= 7) when accessing a share's root dir
	     which has EAs enabled? */
	  || status == STATUS_INVALID_PARAMETER)
d2242 1
d2255 1
a2269 5
      /* Check file system while we're having the file open anyway.
	 This speeds up path_conv noticably (~10%). */
      if (!fs_update_called)
	fs.update (&upath, h);

d2271 3
d2313 1
a2313 1
		FILE_DIRECTORY_INFORMATION fdi;
d2339 1
a2339 1
						 FileDirectoryInformation,
@


1.576
log
@	* dtable.cc (build_fh_name_worker): Remove.  Move all functionality
	back into build_fh_name.
	(build_fh_name): Drop unused HANDLE parameter.  Drop call to pc.fillin.
	Remove disabled build_fh_name with UNICODE_STRING name parameter.
	* dtable.h (build_fh_name): Drop HANDLE parameter from declaration.
	Remove declaration for build_fh_name with UNICODE_STRING name parameter.
	* path.cc (path_conv::fillin): Remove.
	(symlink_info::check): Fix comment.
	* path.h (path_conv::fillin): Remove declaration.
	* dir.cc: Accommodate change in build_fh_name parameters throughout.
	* sec_acl.cc: Ditto.
	* syscalls.cc: Ditto.

	* ntea.cc (getxattr_worker): Fix debug output.
	(setxattr_worker): Ditto.
	* times.cc (utimens_worker): Ditto.
@
text
@d2263 6
d2270 3
a2272 2
	  && NT_SUCCESS (status
			 = NtQueryInformationFile (h, &io, &fbi, sizeof fbi,
a2368 5
      /* Check file system while we're having the file open anyway.
	 This speeds up path_conv noticably (~10%). */
      if (!fs_update_called)
	fs.update (&upath, h);

@


1.575
log
@	* path.cc (symlink_info::check): Set fileattr to
	FILE_ATTRIBUTE_DIRECTORY in a certain error condition.  Explain why.
@
text
@d4 1
a4 1
     2006, 2007, 2008, 2009 Red Hat, Inc.
a374 13
path_conv::fillin (HANDLE h)
{
  IO_STATUS_BLOCK io;
  FILE_BASIC_INFORMATION fbi;

  if (NT_SUCCESS (NtQueryInformationFile (h, &io, &fbi, sizeof fbi,
					  FileBasicInformation)))
    fileattr = fbi.FileAttributes;
  else
    fileattr = INVALID_FILE_ATTRIBUTES;
}

void
d2279 1
a2279 1
	     is seemingly not generated by NtQueryAttributesFile, the latter
@


1.574
log
@	* path.cc (cygwin_conv_path): Add band-aid including comment to avoid
	conversion from POSIX "." to Win32 ".\\".
@
text
@d2330 6
a2335 1
		  fileattr = 0;
@


1.573
log
@	* fhandler_disk_file.cc (is_volume_mountpoint): Align check with
	symlink_info::check_reparse_point().
	* path.cc (symlink_info::check_reparse_point): Rearrange slightly.
	Add code path for unrecognized repare point types.  Add comment.
@
text
@d2712 10
d2740 10
a2749 1
      lsiz = (p.get_wide_win32_path_len () + 1) * sizeof (WCHAR);
@


1.572
log
@	* path.cc (symlink_info::check_reparse_point): Always check
	SubstituteName for volume string to recognize volume mount points.
	Reuse subst when calling sys_wcstombs.
	* syscalls.cc (rename): Set errno to EBUSY when trying to rename
	volume mount points.  Explain why.
@
text
@d1847 1
d1861 4
a1864 8
    {
      sys_wcstombs (srcbuf, SYMLINK_MAX + 1,
		    (WCHAR *)((char *)rp->SymbolicLinkReparseBuffer.PathBuffer
			  + rp->SymbolicLinkReparseBuffer.SubstituteNameOffset),
		    rp->SymbolicLinkReparseBuffer.SubstituteNameLength / sizeof (WCHAR));
      pflags = PATH_SYMLINK | PATH_REP;
      fileattr &= ~FILE_ATTRIBUTE_DIRECTORY;
    }
a1866 2
      UNICODE_STRING subst;

a1877 4
      sys_wcstombs (srcbuf, SYMLINK_MAX + 1, subst.Buffer,
		    subst.Length / sizeof (WCHAR));
      pflags = PATH_SYMLINK | PATH_REP;
      fileattr &= ~FILE_ATTRIBUTE_DIRECTORY;
d1879 13
@


1.571
log
@	* miscfuncs.h (transform_chars): Declare.  Define inline variation here.
	* mount.cc (mount_info::from_fstab): Remove extern declaration of
	transform_chars.
	* path.cc (tfx_chars): Move to strfuncs.cc.
	(transform_chars): Ditto.
	* strfunc.cc (tfx_chars): Moved here from path.cc.
	(transform_chars): Ditto.
	(sys_cp_wcstombs): Make UNICODE private use area conversion roundtrip
	save for all characters.
	(sys_cp_mbstowcs): Ditto, by removing special case for UTF-8 sequences
	representing U+f0XX UNICODE chars.  Fix typo in comment.
@
text
@d1876 1
a1876 2
      if (rp->MountPointReparseBuffer.PrintNameLength == 0
	  || RtlEqualUnicodePathPrefix (&subst, &ro_u_volume, TRUE))
d1883 2
a1884 4
      sys_wcstombs (srcbuf, SYMLINK_MAX + 1,
		    (WCHAR *)((char *)rp->MountPointReparseBuffer.PathBuffer
			    + rp->MountPointReparseBuffer.SubstituteNameOffset),
		    rp->MountPointReparseBuffer.SubstituteNameLength / sizeof (WCHAR));
@


1.570
log
@path.cc
@
text
@a397 57
/* Transform characters invalid for Windows filenames to the Unicode private
   use area in the U+f0XX range.  The affected characters are all control
   chars 1 <= c <= 31, as well as the characters " * : < > ? |.  The backslash
   is affected as well, but we can't transform it as long as we accept Win32
   paths as input.
   The reverse functionality is in strfuncs.cc, function sys_cp_wcstombs. */
static const WCHAR tfx_chars[] = {
            0, 0xf000 |   1, 0xf000 |   2, 0xf000 |   3,
 0xf000 |   4, 0xf000 |   5, 0xf000 |   6, 0xf000 |   7,
 0xf000 |   8, 0xf000 |   9, 0xf000 |  10, 0xf000 |  11,
 0xf000 |  12, 0xf000 |  13, 0xf000 |  14, 0xf000 |  15,
 0xf000 |  16, 0xf000 |  17, 0xf000 |  18, 0xf000 |  19,
 0xf000 |  20, 0xf000 |  21, 0xf000 |  22, 0xf000 |  23,
 0xf000 |  24, 0xf000 |  25, 0xf000 |  26, 0xf000 |  27,
 0xf000 |  28, 0xf000 |  29, 0xf000 |  30, 0xf000 |  31,
          ' ',          '!', 0xf000 | '"',          '#',
          '$',          '%',          '&',           39,
          '(',          ')', 0xf000 | '*',          '+',
          ',',          '-',          '.',          '\\',
          '0',          '1',          '2',          '3',
          '4',          '5',          '6',          '7',
          '8',          '9', 0xf000 | ':',          ';',
 0xf000 | '<',          '=', 0xf000 | '>', 0xf000 | '?',
          '@@',          'A',          'B',          'C',
          'D',          'E',          'F',          'G',
          'H',          'I',          'J',          'K',
          'L',          'M',          'N',          'O',
          'P',          'Q',          'R',          'S',
          'T',          'U',          'V',          'W',
          'X',          'Y',          'Z',          '[',
          '\\',          ']',          '^',          '_',
          '`',          'a',          'b',          'c',
          'd',          'e',          'f',          'g',
          'h',          'i',          'j',          'k',
          'l',          'm',          'n',          'o',
          'p',          'q',          'r',          's',
          't',          'u',          'v',          'w',
          'x',          'y',          'z',          '{',
 0xf000 | '|',          '}',          '~',          127
};

void
transform_chars (PWCHAR path, PWCHAR path_end)
{
  for (; path <= path_end; ++path)
    if (*path < 128)
      *path = tfx_chars[*path];
}

static inline
void
transform_chars (PUNICODE_STRING upath, USHORT start_idx)
{
  transform_chars (upath->Buffer + start_idx,
		   upath->Buffer + upath->Length / sizeof (WCHAR) - 1);
}

@


1.569
log
@	* sec_helper.cc (security_descriptor::free): If sd_size is 0, call
	LocalFree instead of ::free.

	* sec_acl.cc: Throughout replace old ACE flag definitions with current
	definitions as used in MSDN man pages.
	* security.cc: Ditto.

	* fhandler.cc (fhandler_base::open): Make sure file has really been
	just created before fixing file permissions.  Add S_JUSTCREATED
	attribute to set_file_attribute call.
	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Always create dir
	with default security descriptor and fix descriptor afterwards.
	Add S_JUSTCREATED flag to set_file_attribute call.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto for AF_LOCAL
	socket files.
	* path.cc (symlink_worker): Ditto for symlinks.
	* security.cc (get_file_sd): Call GetSecurityInfo rather than
	NtQuerySecurityObject.  Explain why.  Change error handling accordingly.
	(alloc_sd): Skip non-inherited, non-standard entries in ACL if
	S_JUSTCREATED attribute is set.  Explain why.  Minor format fixes.
	* security.h (S_JUSTCREATED): New define.
	(security_descriptor::operator=): New operator.
@
text
@d404 1
a404 1
WCHAR tfx_chars[] NO_COPY = {
@


1.568
log
@	* path.cc (tfx_chars): Convert all ASCII control characters except
	ASCII NUL as well.  Change layout to make the conversions more clear.
	Add comment.
@
text
@a1401 1
  security_descriptor sd;
a1661 5
  /* See comments in fhander_base::open () for an explanation why we defer
     setting security attributes on remote files. */
  if (win32_newpath.has_acls () && !win32_newpath.isremote ())
    set_security_attribute (win32_newpath, S_IFLNK | STD_RBITS | STD_WBITS,
			    &sa, sd);
d1676 1
a1676 1
  if (win32_newpath.has_acls () && win32_newpath.isremote ())
d1678 2
a1679 1
			S_IFLNK | STD_RBITS | STD_WBITS);
@


1.567
log
@* dcrt0.cc (dll_crt0_1): Move cxx_malloc reset kluge from here.
(check_sanity_and_sync): to here.
* path.cc (has_dot_last_component): Rewrite to detect some corner cases that
were previously uncaught.
@
text
@d398 6
d405 32
a436 16
   0,   1,   2,   3,   4,   5,   6,   7,
   8,   9,  10,  11,  12,  13,  14,  15,
  16,  17,  18,  19,  20,  21,  22,  23,
  24,  25,  26,  27,  28,  29,  30,  31,
  32, '!', 0xf000 | '"', '#', '$', '%', '&',  39,
  '(', ')', 0xf000 | '*', '+', ',', '-', '.', '\\',
 '0', '1', '2', '3', '4', '5', '6', '7',
 '8', '9', 0xf000 | ':', ';', 0xf000 | '<', '=', 0xf000 | '>', 0xf000 | '?',
 '@@', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
 'X', 'Y', 'Z', '[',  '\\', ']', '^', '_',
 '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',
 'x', 'y', 'z', '{', 0xf000 | '|', '}', '~', 127
@


1.566
log
@Provide euidaccess, canonicalize_file_name; fix fchmodat.

* syscalls.cc (fchmodat): lchmod is not yet implemented.
(euidaccess): New function.
* path.cc (realpath): Update comment.
(canonicalize_file_name): New function.
* include/cygwin/stdlib.h (canonicalize_file_name): Declare it.
* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
* cygwin.din: Export canonicalize_file_name, eaccess, euidaccess.
* posix.sgml: Mention them.
@
text
@d206 26
a231 17
  const char *last_comp = strrchr (dir, '/');
  if (!last_comp)
    last_comp = dir;
  else {
    /* Check for trailing slash.  If so, hop back to the previous slash. */
    if (!last_comp[1])
      while (last_comp > dir)
	if (*--last_comp == '/')
	  break;
    if (*last_comp == '/')
      ++last_comp;
  }
  return last_comp[0] == '.'
	 && ((last_comp[1] == '\0' || last_comp[1] == '/')
	     || (test_dot_dot
		 && last_comp[1] == '.'
		 && (last_comp[2] == '\0' || last_comp[2] == '/')));
@


1.565
log
@	* path.cc (symlink_worker): Rework error handling to generate Linux
	compatible errno in case of trailing slash in newpath.
@
text
@d2848 1
a2848 1
/* The realpath function is supported on some UNIX systems.  */
d2879 3
a2881 5
  /* Linux has this funny non-standard extension.  If "resolved" is NULL,
     realpath mallocs the space by itself and returns it to the application.
     The application is responsible for calling free() then.  This extension
     is backed by POSIX, which allows implementation-defined behaviour if
     "resolved" is NULL.  That's good enough for us to do the same here. */
d2895 3
a2897 2
  /* FIXME: on error, we are supposed to put the name of the path
     component which could not be resolved into RESOLVED.  */
d2904 9
@


1.564
log
@	* cygheap.h (cwdstuff::get_posix): Convert to const inline method just
	returning pointer to posix path.
	(cwdstuff::reset_posix): Convert to non-inline method taking a wchar_t
	pointer.
	* path.cc (cwdstuff::set): Revert change from 2009-05-13.  Set posix
	to valid incoming path again.
	(cwdstuff::reset_posix): New implementation setting posix path from
	incoming wchar_t path.  Explain usage.
	(cwdstuff::get_posix): Drop implementation.
	(cwdstuff::get): Drop special case to handle empty posix path.
	* syscalls.cc (internal_setlocale): Store old posix cwd as wide char
	path.  Restore posix cwd using new charset.  Explain why.
@
text
@d1379 1
d1399 1
d1401 2
a1402 2
  /* Trailing dirsep is a no-no. */
  if (isdirsep (newpath[len - 1]))
d1404 2
a1405 2
      set_errno (ENOENT);
      goto done;
d1438 5
d1677 2
@


1.563
log
@	* path.h (INTERIX_SYMLINK_COOKIE): Define.
	* path.cc (symlink_info::check_sysfile): Read Interix symlinks as well.
@
text
@d3309 2
a3310 2
      if (posix)
      	posix[0] = '\0';
d3318 4
a3321 3
/* Copy the value for either the posix or the win32 cwd into a buffer. */
char *
cwdstuff::get_posix ()
d3323 3
a3325 10
  if (!posix || !*posix)
    {
      tmp_pathbuf tp;

      char *tocopy = tp.c_get ();
      mount_table->conv_to_posix_path (win32.Buffer, tocopy, 0);
      posix = (char *) crealloc_abort (posix, strlen (tocopy) + 1);
      stpcpy (posix, tocopy);
    }
  return posix;
a3352 7
  else if (!posix || !*posix)
    {
      tocopy = tp.c_get ();
      mount_table->conv_to_posix_path (win32.Buffer, tocopy, 0);
      posix = (char *) crealloc_abort (posix, strlen (tocopy) + 1);
      stpcpy (posix, tocopy);
    }
@


1.562
log
@	* mount.cc (fs_info::update): Add comment.
	* path.cc (symlink_info::check_reparse_point): Return -1 for volume
	mount points.  Explain why.
	(symlink_info::check): Call fs.update again for volume mount points.
	Explain why.
@
text
@d1787 1
d1809 20
a1828 1

d1837 2
a1838 1
      else if (*(PWCHAR) srcbuf == 0xfeff)	/* BOM */
d1840 6
d1847 1
a1847 1
	  if (sys_wcstombs (tmpbuf, NT_MAX_PATH, (PWCHAR) (srcbuf + 2))
a1857 3
  else if (io.Information == sizeof (cookie_buf)
	   && memcmp (cookie_buf, SOCKET_COOKIE, sizeof (cookie_buf)) == 0)
    pflags |= PATH_SOCKET;
@


1.561
log
@	* globals.cc (ro_u_volume): New R/O unicode string.
	* path.cc (symlink_info::check_reparse_point): Fix check for volume
	mount points to work on Vista and later as well.
@
text
@d1877 4
a1880 2
	  /* Volume mount point.  Not treated as symlink. */
	  return 0;
d2415 11
a2425 1
	  if (res)
@


1.560
log
@* fhandler_socket.cc (fhandler_socket::send_internal): Just use wmem size if
the length exceeds it.
* net.cc (fdsock): Use 65535 as window size, just like the comment says or we
run into problems with DuplicateHandle.
* path.cc (patch_conv::check): Use set_path to set invalid filename.
* path.h (path_conv::path_conv): Ditto.
@
text
@d1868 8
a1875 1
      if (rp->SymbolicLinkReparseBuffer.PrintNameLength == 0)
d1877 1
a1877 1
	  /* Likely a volume mount point.  Not treated as symlink. */
@


1.559
log
@* cygheap_malloc.h: New file.
* cygheap.h: Remove stuff now included in cygheap_malloc.h and include that
file.  Make cygheap_init a standard c++ function.  Remove unneeded child_info
declaration.
* path.h: Include cygheap_malloc.h.  Remove extra cstrdup declaration.
(path_conv): Reorganize to group variables together.
(path_conv::path): Make const char *.
(path_conv::known_suffix): Ditto.
(path_conv::normalized_path): Ditto.
(path_conv::path_conv): Reorganize initializers to reflect new element
ordering.
(path_conv::get_win32): Change return value to const char *.
(path_conv::set_path): Move back here from spawn.cc.
(parh_conv::modifiable_path): New function.
* path.cc (path_conv::add_ext_from_sym): Accommodate const'ness of
known_suffixes.
(path_conv::set_normalized_path): Ditto for normalized_path.
(path_conv::check): Use modifiable_path whereever we need to modify the path
element.  Use set_path to set the path.
(path_conv::~path_conv): Accommodate new const'ness.
* spawn.cc (perhaps_suffix): Declare ext as const since that's what is being
returned.
(path_conv::set_path): Move back to path.h.
* winf.f (linebuf): Perform minor cleanup.
(linebuf::fromargv): Change second parameter to const.
* winf.cc (linebuf::fromargv): Ditto.
@
text
@d971 1
a971 1
	  this->path = cstrdup ("::ENAMETOOLONG::");
@


1.558
log
@	* path.h (class path_conv): Convert path from char array to char *.
	Initialize to NULL in constructors.  Drop normalized_path_size member.
	(path_conv::size): Remove.
	(path_conv::operator =): Always copy with sizeof path_conv.  Always
	duplicate path on cygheap.
	(path_conv::set_path): Move implementation to spawn.cc.
	* path.cc (path_conv::set_normalized_path): Always allocate
	normalized_path on cygheap.
	(path_conv::check): Don't work on path, rather allocate THIS_path in
	TLS and use it throughout.  When finished, allocate path on cygheap
	and copy over.  Defer tacking on extension after having copied path.
	* spawn.cc (path_conv::set_path): Implement here.
@
text
@d331 1
a331 1
	strcpy (known_suffix, sym.ext_here);
d335 3
a337 1
static void __stdcall mkrelpath (char *dst, bool caseinsensitive) __attribute__ ((regparm (2)));
d384 2
a385 3

      normalized_path = (char *) cmalloc_abort (HEAP_STR, n);
      memcpy (normalized_path, path_copy, n);
d657 4
a660 2
    cfree (path);
  path = NULL;
d664 4
a667 2
    cfree (normalized_path);
  normalized_path = NULL;
d1001 1
a1001 2
  this->path = (char *) cmalloc_abort (HEAP_STR, strlen (THIS_path) + 7);
  stpcpy (this->path, THIS_path);
d1021 1
a1021 1
    strcat (path, "\\"); /* Reattach trailing dirsep in native path. */
d1074 1
a1074 1
	  mkrelpath (this->path, !!caseinsensitive);
d1088 2
a1089 2
	      this->path[n] = '\\';
	      this->path[n + 1] = '\0';
d1119 1
a1119 1
      cfree (normalized_path);
d1124 1
a1124 1
      cfree (path);
@


1.557
log
@	* path.cc (symlink_info::check): Handle STATUS_NOT_SUPPORTED from
	NtCreateFile just like STATUS_EAS_NOT_SUPPORTED.
@
text
@d379 3
a381 4
  char *p = strchr (path_copy, '\0');
  size_t n = 1 + p - path_copy;

  normalized_path = path + sizeof (path) - n;
a382 5
  char *eopath = strchr (path, '\0');
  if (normalized_path > eopath)
    normalized_path_size = n;
  else
    {
d384 1
a384 1
      normalized_path_size = 0;
a385 2

  memcpy (normalized_path, path_copy, n);
d622 1
d626 1
d655 3
d660 1
a660 1
  if (!normalized_path_size && normalized_path)
d729 1
a729 1
	      full_path = this->path;
d747 1
a747 1
		  fileattr = getfileattr (this->path,
d757 1
a757 1
	      fileattr = getfileattr (this->path, sym.pflags & MOUNT_NOPOSIX);
d882 1
a882 1
		add_ext_from_sym (sym);
d903 1
a903 1
		      strcpy (path, sym.contents);
d906 1
a906 1
		  add_ext_from_sym (sym);
d966 1
a966 1
	  strcpy (path, "::ENAMETOOLONG::");
d993 1
a993 1
    add_ext_from_sym (sym);
d996 4
d1093 1
a1093 3
  if (!(opt & PC_POSIX))
    normalized_path_size = 0;
  else
d1113 1
a1113 1
  if (!normalized_path_size && normalized_path)
d1118 5
@


1.556
log
@	* path.cc (symlink_info::check): Fix typo in comment.
@
text
@d2213 1
d2221 2
a2222 1
	  if (status == STATUS_EAS_NOT_SUPPORTED)
@


1.555
log
@	* globals.cc: Improve comment on R/O UNICODE_STRINGs.
	* mount.h (class fs_info): Add is_mvfs bit.
	* mount.cc (fs_info::update): Recognize MVFS remote filesystem.
	(fillout_mntent): Reorder filesystem checks for speed.  Add
	mvfs, unixfs, and sunwnfs filesystem types.
	* path.h (class path_conv): Add fs_is_mvfs method.
	* path.cc (symlink_worker): On MVFS, always create symlinks as
	Windows shortcuts.  Explain why.
@
text
@d2219 1
a2219 1
	     whith suffixes attached.  So we set eabuf/easize to 0 here once. */
@


1.554
log
@	* path.cc (cwdstuff::set): Only fix up UNC path in win32 so as not
	to overwrite incoming path.
@
text
@d1370 1
d1401 5
a1405 1
  if (use_winsym && !win32_newpath.exists ()
d1457 1
a1457 1
  if (use_winsym)
d1642 2
a1643 2
      status = NtSetAttributesFile (fh, use_winsym ? FILE_ATTRIBUTE_READONLY
						   : FILE_ATTRIBUTE_SYSTEM);
d1661 1
a1661 1
		  newpath, use_winsym, isdevice);
@


1.553
log
@	Throughout avoid having to initialize constant UNICODE_STRINGs.
	* globals.cc: Define constant UNICODE_STRINGs and store in .rdata
	section.
	* fhandler_disk_file.cc: Throughout, use readonly UNICODE_STRINGs
	rather then initializing local UNICODE_STRING variable where
	applicable.
	* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
	* flock.cc (inode_t::inode_t): Ditto.
	* mmap.cc: Ditto.
	* syscalls.cc: Ditto.
	* mount.cc (fs_info::update): Ditto.
	* path.cc: Ditto.

	* ntdll.h (RtlEqualUnicodePathPrefix): Redefine to take prefix as
	UNICODE_STRING.
	(RtlEqualUnicodePathSuffix): Redefine to take suffix as UNICODE_STRING.
	* fhandler_disk_file.cc: Accommodate throughout.
	* mount.cc (fs_info::update): Ditto.
	* path.cc (cwdstuff::set): Ditto.
	* syscalls.cc: Ditto.
@
text
@d3198 2
d3207 1
a3207 1
		upath.Buffer[0] = L'\\';
d3223 2
@


1.552
log
@	* path.cc (chdir): Check error conditions first.
@
text
@d451 1
a451 1
	  RtlAppendUnicodeToString (&upath, L"\\??\\");
d465 1
a465 1
      RtlAppendUnicodeToString (&upath, L"\\??\\UNC\\");
d471 1
a471 1
      RtlAppendUnicodeToString (&upath, L"\\??\\");
d3082 1
a3082 1
	  if (RtlEqualUnicodePathPrefix (&upath, L"\\??\\UNC\\", TRUE))
@


1.551
log
@	* path.cc (symlink_info::check): Return with error set to ENOENT if
	STATUS_NO_MEDIA_IN_DEVICE is returned.
@
text
@d2578 5
a2582 1
  if (!isvirtual_dev (devn))
a2593 4
  else if (!path.exists ())
    set_errno (ENOENT);
  else if (!path.isdir ())
    set_errno (ENOTDIR);
@


1.550
log
@	* path.cc (path_conv::check): Don't call set_exec for files on "noacl"
	mount points.
@
text
@d2271 2
a2272 1
	      || status == STATUS_OBJECT_NAME_INVALID)
@


1.549
log
@* path.cc (cwdstuff::set): Rewrite previous change to properly test the end of
the buffer.
@
text
@d1049 4
a1052 1
	  if (fs.has_acls ())
@


1.548
log
@* path.cc (cwdstuff::set): Avoid removing a nonexistent trailing slash.
@
text
@d3183 2
d3187 1
a3187 1
	  if (win32.Length > 3 * sizeof (WCHAR) && win32.Buffer[win32.Length - 1] == L'\\')
d3189 1
d3204 8
a3211 4
	  /* Remove trailing slash if one exists.  FIXME: Is there a better way to
	     do this? */
	  else if (upath.Length > 3 * sizeof (WCHAR) && upath.Buffer[upath.Length] == L'\\')
	    upath.Length -= sizeof (WCHAR);
@


1.547
log
@	* cygheap.h (cwdstuff): Convert to class.  Make posix and dir private.
	(cwdstuff::get_posix): New method.
	(cwdstuff::reset_posix): New method.
	* dcrt0.cc (dll_crt0_1): Call setlocale rather than _setlocale_r.
	* environ.cc (environ_init): Ditto.  Prefer "C" locale over current
	codepage default locale.
	* path.cc (chdir): Use cwdstuff::get_posix method instead of accessing
	cwdstuff::posix directly.
	(cwdstuff::set): Defer creating posix path to first usage.
	(cwdstuff::get_posix): Create posix path if it's empty, and return it.
	(cwdstuff::get): Create posix path if it's empty.
	* strfuncs.cc (sys_cp_wcstombs): Use UTF-8 conversion in the "C"
	locale.
	(sys_cp_mbstowcs): Ditto.
	* syscalls.cc (gen_full_path_at): Fetch CWD posix path locked.
	(setlocale): Implement here.  Reset CWD posix path.
@
text
@d3183 3
a3185 2
	  /* Remove trailing slash. */
	  if (win32.Length > 3 * sizeof (WCHAR))
d3201 4
a3204 2
	  else if (upath.Length > 3 * sizeof (WCHAR))
	    upath.Length -= sizeof (WCHAR); /* Strip trailing backslash */
d3211 1
a3211 1
      /* Make sure it's NUL-termniated. */
@


1.546
log
@	* sec_auth.cc (str2uni_cat): Move from here...
	* path.cc (str2uni_cat): ...to here.  Simplify.  Make static inline.
	(get_nt_native_path): Use RtlAppendUnicodeToString rather than
	str2uni_cat for constant strings for speed.
	* security.h (str2uni_cat): Drop declaration.
@
text
@d2602 1
a2602 1
		  cygheap->cwd.posix, path.get_nt_native_path ());
d3233 2
a3234 2
      posix = (char *) crealloc_abort (posix, strlen (posix_cwd) + 1);
      stpcpy (posix, posix_cwd);
d3244 15
d3283 7
@


1.545
log
@	* path.cc (path_conv::get_wide_win32_path): Allow relative paths.
	(cygwin_conv_path): In case of CCP_POSIX_TO_WIN_W, convert relative
	paths to absolute paths if the relative pathname length exceeds
	MAX_PATH.
@
text
@d431 10
d451 1
a451 1
	  str2uni_cat (upath, "\\??\\");
d465 1
a465 1
      str2uni_cat (upath, "\\??\\UNC\\");
d471 1
a471 1
      str2uni_cat (upath, "\\??\\");
@


1.544
log
@	* path.cc (symlink_worker): Write target filename as UTF-16 string
	with leading BOM marker.
	(symlink_info::check_shortcut): If check for leading BOM marker
	succeeds, read filename as UTF-16 string.
	(symlink_info::check_sysfile): Ditto.
@
text
@d497 1
a497 1
  if (!wide_path || wide_path[1] != L'?') /* Native NT device path */
d499 3
a501 2
  wcscpy (wc, wide_path);
  wc[1] = L'\\';
d2664 3
a2666 3
      p.check ((const char *) from,
	       PC_POSIX | PC_SYM_FOLLOW | PC_NO_ACCESS_CHECK | PC_NOWARN
	       | (relative ? PC_NOFULL : 0));
d2669 10
@


1.543
log
@* path.cc (warn_msdos): Don't warn about MS-DOS filenames encountered during
initialization.
@
text
@d1562 6
a1567 2
      *(unsigned short *)cp = oldpath_len;
      cp = stpcpy (cp += 2, oldpath);
d1571 5
a1575 2
      /* This is the old technique creating a symlink. */
      buf = tp.c_get ();
d1577 1
a1577 1
      cp = stpcpy (stpcpy (buf, SYMLINK_COOKIE), oldpath) + 1;
d1724 9
a1732 1
      if (len > SYMLINK_MAX)
d1734 5
a1738 2
      cp[len] = '\0';
      res = posixify (cp);
d1751 1
d1753 1
a1753 1
  char srcbuf[SYMLINK_MAX + 2];
d1783 1
a1783 1
			   SYMLINK_MAX + 2, NULL, NULL);
d1790 9
@


1.542
log
@	* fhandler_disk_file.cc (path_conv::isgood_inode): Move to be defined
	earlier.
	(get_ino_by_handle): Take additional path_conv argument, accommodate
	throughout.  Only use FileId if isgood_inode check is true.
	(fhandler_base::open_fs): Simplify setting ino due to above change.
	(readdir_get_ino): Make sure to return always a non-zero inode number.
	(fhandler_disk_file::readdir): Always open file in dir with
	FILE_OPEN_REPARSE_POINT so as not to open wrong file.
	Drop call to isgood_inode here.
	* path.cc (symlink_info::check): Call fs.update in case we're fetching
	file information from call to NtQueryDirectoryFile.
@
text
@d507 1
a507 1
  if (user_shared->warned_msdos || !dos_file_warning)
@


1.541
log
@	* fhandler_disk_file.cc (fhandler_disk_file::readdir): Fix inode number
	evaluation for faked "." entry.

	* mount.cc (fs_info::update): Move setting of is_cdrom after checking
	for caseinsensitivity.  Recognize UDF in is_cdrom case and set
	caseinsensitive flag according to UDF brokenness determined by OS.
	Add comment to explain why.
	* mount.h (class fs_info): Add is_udf status flag.
	* path.cc (symlink_info::check): Add workaround for UDF bug in
	terms of casesensitivity on certain OSes.
	* wincap.h (wincaps::has_broken_udf): New element.
	(wincaps::has_broken_udf): New element
@
text
@d2194 1
a2194 1
	  attr.Attributes = ci_flag;
d2268 3
@


1.540
log
@	* errno.cc (errmap): Set errno to ENOENT instead of ENOSHARE throughout.
	* path.cc (path_conv::check): Set to and check for ENOENT instead of
	ENOSHARE.

	* path.cc (symlink_info::check): Fix Samba 3.2.x comment.
@
text
@d2143 1
d2183 24
d2299 2
a2300 1
      fs.update (&upath, h);
@


1.539
log
@	* mount.cc (mount_info::from_fstab_line): Always convert drive
	letter in native path to uppercase.
	* path.cc (normalize_win32_path): Ditto.
	(path_prefix_p): Revert previous patch.

	* path.cc (symlink_info::check): Check for STATUS_INVALID_PARAMETER
	return code to circumvent weird behaviour of Samba 3.2.x shares.
@
text
@d904 1
a904 1
	  else if (sym.error && sym.error != ENOENT && sym.error != ENOSHARE)
d999 1
a999 1
      error = dev.devn == FH_NETDRIVE ? ENOSHARE : ENOENT;
d2165 2
a2166 2
	  /* Or a bug in Samba 3.2.x when accessing a share's root dir which
	     has EAs enabled? */
@


1.538
log
@* include/sys/cygwin.h (CW_SETERRNO): Define.
* external.cc (CW_SETERRNO): Implement.
* include/cygwin/version.h: Bump CYGWIN_VERSION_API_MINOR to 192 to reflect the
above change.
* path.cc (path_prefix_p): Treat X: as equivalent to x:.
* mkglobals_h: Remove unneeded #define.
* spawn.cc (spawn_guts): Avoid overly wordy initialization to zero.
@
text
@d172 2
a173 14
    {
      if (len1 < 2 || (path1[1] != ':') || (path2[1] != ':'))
	/* nothing */;
      else if (tolower (*path1) != tolower(*path2))
	return 0;
      else
	{
	  path1 += 2;
	  path2 += 2;
	  len1 -= 2;
	}
      return caseinsensitive ? strncasematch (path1, path2, len1)
			     : !strncmp (path1, path2, len1);
    }
d1168 1
a1168 1
  if (tail == dst && !isdrive (src) && *src != '/')
d1170 15
a1184 9
      if (beg_src_slash)
	tail += cygheap->cwd.get_drive (dst);
      else if (!cygheap->cwd.get (dst, 0))
	return get_errno ();
      else
	{
	  tail = strchr (tail, '\0');
	  if (tail[-1] != '\\')
	    *tail++ = '\\';
d2164 4
a2167 1
      if (status == STATUS_ACCESS_DENIED || status == STATUS_EAS_NOT_SUPPORTED)
@


1.537
log
@	* fhandler_disk_file.cc (fhandler_disk_file::link): Only add .exe if
	original file has .exe as well.
	* path.cc (path_conv::is_binary): Only recognize Windows 32 and 64 bit
	apps as binaries.
@
text
@d172 14
a185 2
    return caseinsensitive ? strncasematch (path1, path2, len1)
			   : !strncmp (path1, path2, len1);
@


1.536
log
@Remove unneeded header files from source files throughout.  Update copyrights
where appropriate.
* globals.cc: New file for generic global variables.
* mkglobals_h: New file to generate globals.h.
* mkstatic: New Script used to build a (currently non-working) static
libcygwin_s.a.
* Makefile.in: Add unused rule to build a non-working libcygwin_s.a.
(DLL_OFILES): Add globals.o.  Make all objects rely on globals.h.
(globals.h): New target.  Generate globals.h.
* cygtls.h: Honor new CYGTLS_HANDLE define to control when the HANDLE operator
is allowed in _cygtls.
* dcrt0.cc: Move most globals to globals.cc.
* init.cc: Ditto.
* environ.cc (strip_title_path): Remove now-unneeded extern.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* pinfo.cc: Ditto.
(commune_process): Ditto.
* shared.cc: Ditto.
* glob.cc: Ditto.
* strace.cc: Ditto.
* exceptions.cc: Define CYGTLS_HANDLE before including winsup.h.
* path.cc (stat_suffixes): Move here.
* security.h: Add forward class path_conv declaration.
* smallprint.cc (__small_vsprintf): Make a true c++ function.
(__small_sprintf): Ditto.
(small_printf): Ditto.
(console_printf): Ditto.
(__small_vswprintf): Ditto.
(__small_swprintf): Ditto.
* spawn.cc (spawn_guts): Remove _stdcall decoration in favor of regparm.
(hExeced): Move to globals.cc
* strfuncs.cc (current_codepage): Ditto.
(active_codepage): Ditto.
* sync.cc (lock_process::locker): Move here from dcrt0.cc.
* syscalls.cc (stat_suffixes): Move to path.cc.
* tty.cc (tty::create_master): Uncapitalize fatal warning for consistency.
* winsup.h: Include globals.h to declare most of the grab bag list of globals
which were previously defined here.
* mount.h: Move USER_* defines back to shared_info.h.
* speclib: Force temporary directory cleanup.
@
text
@d1119 2
a1120 1
  return GetBinaryTypeW (get_wide_win32_path (bintest), &bin);
@


1.535
log
@* mount.cc: Change comment.
(smb_extended_info): Move here from path.cc.
(fs_info::update): Ditto.
(mount_info::create_root_entry): Delay conversion to slashes and use passed in
buffer to figure out fs type.
* path.cc (smb_extended_info): Move.
(fs_info::update): Ditto.
* mount.h: New file.  Move mount information here.
* path.h: (fs_info::update): Move.
* shared_info.h (mount_item): Ditto.
@
text
@d4 1
a4 1
     2006, 2007, 2008 Red Hat, Inc.
d78 7
@


1.534
log
@* path.cc (symlink_info::check_shortcut): Ensure that symlink handle is closed
on successful return.
@
text
@a355 195
/* Beginning with Samba 3.0.28a, Samba allows to get version information using
   the ExtendedInfo member returned by a FileFsObjectIdInformation request.
   We just store the samba_version information for now.  Older versions than
   3.2 are still guessed at by testing the file system flags. */
#define SAMBA_EXTENDED_INFO_MAGIC 0x536d4261 /* "SmBa" */
#define SAMBA_EXTENDED_INFO_VERSION_STRING_LENGTH 28
#pragma pack(push,4)
struct smb_extended_info {
  DWORD         samba_magic;             /* Always SAMBA_EXTENDED_INFO_MAGIC */
  DWORD         samba_version;           /* Major/Minor/Release/Revision */
  DWORD         samba_subversion;        /* Prerelease/RC/Vendor patch */
  LARGE_INTEGER samba_gitcommitdate;
  char          samba_version_string[SAMBA_EXTENDED_INFO_VERSION_STRING_LENGTH];
};
#pragma pack(pop)

bool
fs_info::update (PUNICODE_STRING upath, HANDLE in_vol)
{
  NTSTATUS status = STATUS_OBJECT_NAME_NOT_FOUND;
  HANDLE vol;
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;
  bool no_media = false;
  FILE_FS_DEVICE_INFORMATION ffdi;
  FILE_FS_OBJECTID_INFORMATION ffoi;
  struct {
    FILE_FS_ATTRIBUTE_INFORMATION ffai;
    WCHAR buf[NAME_MAX + 1];
  } ffai_buf;
  struct {
    FILE_FS_VOLUME_INFORMATION ffvi;
    WCHAR buf[NAME_MAX + 1];
  } ffvi_buf;
  UNICODE_STRING fsname, testname;

  clear ();
  if (in_vol)
    vol = in_vol;
  else
    {
      /* Always caseinsensitive.  We really just need access to the drive. */
      InitializeObjectAttributes (&attr, upath, OBJ_CASE_INSENSITIVE, NULL,
				  NULL);
      status = NtOpenFile (&vol, READ_CONTROL, &attr, &io,
			   FILE_SHARE_VALID_FLAGS, FILE_OPEN_FOR_BACKUP_INTENT);
      while (!NT_SUCCESS (status)
	     && (attr.ObjectName->Length > 7 * sizeof (WCHAR)
		 || status == STATUS_NO_MEDIA_IN_DEVICE))
	{
	  UNICODE_STRING dir;
	  RtlSplitUnicodePath (attr.ObjectName, &dir, NULL);
	  attr.ObjectName = &dir;
	  if (status == STATUS_NO_MEDIA_IN_DEVICE)
	    {
	      no_media = true;
	      dir.Length = 6 * sizeof (WCHAR);
	    }
	  else if (dir.Length > 7 * sizeof (WCHAR))
	    dir.Length -= sizeof (WCHAR);
	  status = NtOpenFile (&vol, READ_CONTROL, &attr, &io,
			       FILE_SHARE_VALID_FLAGS,
			       FILE_OPEN_FOR_BACKUP_INTENT);
	}
      if (!NT_SUCCESS (status))
	{
	  debug_printf ("Cannot access path %S, status %08lx",
			attr.ObjectName, status);
	  NtClose (vol);
	  return false;
	}
    }

  status = NtQueryVolumeInformationFile (vol, &io, &ffvi_buf.ffvi,
					 sizeof ffvi_buf,
					 FileFsVolumeInformation);
  sernum = NT_SUCCESS (status) ? ffvi_buf.ffvi.VolumeSerialNumber : 0;
  status = NtQueryVolumeInformationFile (vol, &io, &ffdi, sizeof ffdi,
					 FileFsDeviceInformation);
  if (!NT_SUCCESS (status))
    ffdi.DeviceType = ffdi.Characteristics = 0;

  if (ffdi.Characteristics & FILE_REMOTE_DEVICE
      || (!ffdi.DeviceType
	  && RtlEqualUnicodePathPrefix (attr.ObjectName, L"\\??\\UNC\\", TRUE)))
    is_remote_drive (true);
  else
    is_remote_drive (false);

  if (!no_media)
    status = NtQueryVolumeInformationFile (vol, &io, &ffai_buf.ffai,
					   sizeof ffai_buf,
					   FileFsAttributeInformation);
  if (no_media || !NT_SUCCESS (status))
    {
      debug_printf ("Cannot get volume attributes (%S), %08lx",
		    attr.ObjectName, status);
      if (!in_vol)
	NtClose (vol);
      return false;
    }
   flags (ffai_buf.ffai.FileSystemAttributes);
   name_len (ffai_buf.ffai.MaximumComponentNameLength);
/* Should be reevaluated for each new OS.  Right now this mask is valid up
   to Vista.  The important point here is to test only flags indicating
   capabilities and to ignore flags indicating a specific state of this
   volume.  At present these flags to ignore are FILE_VOLUME_IS_COMPRESSED
   and FILE_READ_ONLY_VOLUME. */
#define GETVOLINFO_VALID_MASK (0x003701ffUL)
#define TEST_GVI(f,m) (((f) & GETVOLINFO_VALID_MASK) == (m))

/* Volume quotas are potentially supported since Samba 3.0, object ids and
   the unicode on disk flag since Samba 3.2. */
#define SAMBA_IGNORE (FILE_VOLUME_QUOTAS \
		      | FILE_SUPPORTS_OBJECT_IDS \
		      | FILE_UNICODE_ON_DISK)
#define FS_IS_SAMBA TEST_GVI(flags () & ~SAMBA_IGNORE, \
			     FILE_CASE_SENSITIVE_SEARCH \
			     | FILE_CASE_PRESERVED_NAMES \
			     | FILE_PERSISTENT_ACLS)
#define FS_IS_NETAPP_DATAONTAP TEST_GVI(flags (), \
			     FILE_CASE_SENSITIVE_SEARCH \
			     | FILE_CASE_PRESERVED_NAMES \
			     | FILE_UNICODE_ON_DISK \
			     | FILE_PERSISTENT_ACLS \
			     | FILE_NAMED_STREAMS)
  RtlInitCountedUnicodeString (&fsname, ffai_buf.ffai.FileSystemName,
			       ffai_buf.ffai.FileSystemNameLength);
  is_fat (RtlEqualUnicodePathPrefix (&fsname, L"FAT", TRUE));
  RtlInitUnicodeString (&testname, L"NTFS");
  if (is_remote_drive ())
    {
      /* This always fails on NT4. */
      status = NtQueryVolumeInformationFile (vol, &io, &ffoi, sizeof ffoi,
					     FileFsObjectIdInformation);
      if (NT_SUCCESS (status))
	{
	  smb_extended_info *extended_info = (smb_extended_info *)
					     &ffoi.ExtendedInfo;
	  if (extended_info->samba_magic == SAMBA_EXTENDED_INFO_MAGIC)
	    {
	      is_samba (true);
	      samba_version (extended_info->samba_version);
	    }
	}
      /* Test for Samba on NT4 or for older Samba releases not supporting
	 extended info. */
      if (!is_samba ())
	is_samba (RtlEqualUnicodeString (&fsname, &testname, FALSE)
		  && FS_IS_SAMBA);

      if (!is_samba ())
	{
	  is_netapp (RtlEqualUnicodeString (&fsname, &testname, FALSE)
		     && FS_IS_NETAPP_DATAONTAP);

	  RtlInitUnicodeString (&testname, L"NFS");
	  is_nfs (RtlEqualUnicodeString (&fsname, &testname, FALSE));

	  if (!is_nfs ())
	    {
	      /* Known remote file systems which can't handle calls to
		 NtQueryDirectoryFile(FileIdBothDirectoryInformation) */
	      RtlInitUnicodeString (&testname, L"UNIXFS");
	      has_buggy_fileid_dirinfo (RtlEqualUnicodeString (&fsname,
							       &testname,
							       FALSE));

	      /* Known remote file systems with buggy open calls.  Further
		 explanation in fhandler.cc (fhandler_disk_file::open). */
	      RtlInitUnicodeString (&testname, L"SUNWNFS");
	      has_buggy_open (RtlEqualUnicodeString (&fsname, &testname,
						     FALSE));
	    }
	}
    }
  is_ntfs (RtlEqualUnicodeString (&fsname, &testname, FALSE)
	   && !is_samba () && !is_netapp ());
  is_cdrom (ffdi.DeviceType == FILE_DEVICE_CD_ROM);

  has_acls (flags () & FS_PERSISTENT_ACLS);
  hasgood_inode (((flags () & FILE_PERSISTENT_ACLS) && !is_netapp ())
		 || is_nfs ());
  /* Case sensitivity is supported if FILE_CASE_SENSITIVE_SEARCH is set,
     except on Samba which handles Windows clients case insensitive.
     NFS doesn't set the FILE_CASE_SENSITIVE_SEARCH flag but is case
     sensitive. */
  caseinsensitive ((!(flags () & FILE_CASE_SENSITIVE_SEARCH) || is_samba ())
		   && !is_nfs ());

  if (!in_vol)
    NtClose (vol);
  return true;
}

@


1.533
log
@	* path.cc (path_conv::check): Handle incoming DOS paths non-POSIXy,
	always case-insensitive, always ignoring ACLs.
@
text
@a1904 1
  return res;
d1908 1
a1908 1
  return 0;
@


1.532
log
@	* path.cc (symlin_info::check): Set 4th parameter of
	NtQueryDirectoryFile to NULL instead of 0 since it's a pointer.
	Simplify label and break from loop handling in symlink evaluation
	conditional expression.  Drop a now useless break statement.  Fix
	behaviour when searching for `foo' and then finding a `foo.lnk'
	which is no shortcut.
@
text
@d1045 5
a1049 1
	      if (cygwin_shared->obcaseinsensitive || fs.caseinsensitive ())
d1221 4
@


1.531
log
@* fhandler_disk_file.cc (readdir_get_ino): Don't complain about MS-DOS paths
since the function could be fed one by an internal call.
@
text
@d2410 1
a2410 1
		  status = NtQueryDirectoryFile (dir, NULL, NULL, 0, &io,
d2461 11
a2471 2
	      if (!suffix.lnk_match () || !ext_tacked_on)
		goto file_not_symlink;
d2473 7
a2479 7
	      /* in case we're going to tack *another* .lnk on this filename. */
	      fileattr = INVALID_FILE_ATTRIBUTES;
	      continue;
	    }
	  if (contents[0] == ':' && contents[1] == '\\'
	      && parse_device (contents))
	    goto file_not_symlink;
d2490 2
a2491 2
	  if (!res)
	    goto file_not_symlink;
d2501 2
a2502 2
	  if (!res)
	    goto file_not_symlink;
d2511 2
a2512 2
	  if (!res)
	    goto file_not_symlink;
d2515 1
a2515 7
      /* Normal file. */
      else
	goto file_not_symlink;

      break;


@


1.530
log
@Remove unneeded whitespace.
* fhandler_fifo.cc (fhandler_fifo::open): Rework to cause errno to be set to
ENXIO when opening a fifo write/nonblocking.
* environ.cc (ucreqenv): Rename to ucenv.  Move code from old ucenv here and
conditionalize it on create_upcaseenv.
(ucenv): Delete.
(environ_init): Fix compiler warning by moving create_upcaseenv test to ucenv.
Don't bother checking for child_proc_info when calling ucenv since it is
assumed to be NULL at the point where the function is called.
* path.cc (symlink_worker): Turn off MS-DOS path warnings when dealing with
devices since the device handler passes in a translated MS-DOS path.
* sec_auth.cc (lsaprivkeyauth): Avoid variable initialization which causes a
compiler error.
* fhandler_netdrive.cc: Update copyright.
@
text
@d2349 1
a2349 1
			       &attr, &io, FILE_SHARE_VALID_FLAGS, 
@


1.529
log
@	* mount.cc (mount_info::cygdrive_win32_path): Always upper case
	DOS drive letter to accommodate case sensitivity.
	(cygdrive_getmntent): Ditto.
	* path.cc (path_conv::check): Invalidate wide_path after making path
	relative.
@
text
@d1 1
a1 1
  /* path.cc: path support.
d508 1
a508 1
        {
d518 1
a518 1
	         NtQueryDirectoryFile(FileIdBothDirectoryInformation) */
d1528 1
d1555 2
d1558 1
a1558 1
  win32_newpath.check (newpath, PC_SYM_NOFOLLOW | PC_POSIX, stat_suffixes);
d1564 1
a1564 1
      win32_newpath.check (newplnk, PC_SYM_NOFOLLOW | PC_POSIX);
d1627 5
a1631 1
	  if (!isabspath (oldpath))
a1639 2
	  else
	    win32_oldpath.check (oldpath, PC_SYM_NOFOLLOW, stat_suffixes);
d1785 1
a1785 1
    			S_IFLNK | STD_RBITS | STD_WBITS);
@


1.528
log
@* path.cc (normalize_win32_path): Don't add a trailing '\' if the cwd returns a
path with a trailing '\'.
@
text
@d1234 8
a1241 1
	mkrelpath (this->path, !!caseinsensitive);
@


1.527
log
@	* ntdll.h (NtSetAttributesFile): New inline function.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Use
	NtSetAttributesFile.
	* path.cc (symlink_worker): Ditto.
	* syscalls.cc (unlink_nt): Ditto.
	(rename): Omit FILE_SHARE_DELETE when opening files on Samba.  Add
	comment to explain why.
@
text
@d1349 2
a1350 1
	  *tail++ = '\\';
@


1.526
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Check
	for executable suffixes here in case we're on a file system
	not supporting permission.
	* path.cc (path_conv::check): Drop check for executable suffixes.
@
text
@a1518 1
  FILE_BASIC_INFORMATION fbi;
d1743 1
a1743 5
      fbi.CreationTime.QuadPart = fbi.LastAccessTime.QuadPart
      = fbi.LastWriteTime.QuadPart = fbi.ChangeTime.QuadPart = 0LL;
      fbi.FileAttributes = FILE_ATTRIBUTE_NORMAL;
      status = NtSetInformationFile (fh, &io, &fbi, sizeof fbi,
				     FileBasicInformation);
d1776 2
a1777 6
      fbi.CreationTime.QuadPart = fbi.LastAccessTime.QuadPart
      = fbi.LastWriteTime.QuadPart = fbi.ChangeTime.QuadPart = 0LL;
      fbi.FileAttributes = use_winsym ? FILE_ATTRIBUTE_READONLY
				      : FILE_ATTRIBUTE_SYSTEM;
      status = NtSetInformationFile (fh, &io, &fbi, sizeof fbi,
				     FileBasicInformation);
@


1.525
log
@	* path.cc (path_conv::is_binary): Always check for GetBinaryType.
	* syscalls.cc (rename): Fix test for just changing case of name on
	case insensitive filesystems.
@
text
@a1250 11
  if (!error && !isdir () && !(path_flags & PATH_ALL_EXEC)
      && !fs.has_acls () && !fs.is_nfs ())
    {
      const char *p = strchr (path, '\0') - 4;
      if (p >= path &&
	  (ascii_strcasematch (".exe", p) ||
	   ascii_strcasematch (".bat", p) ||
	   ascii_strcasematch (".com", p)))
	path_flags |= PATH_EXEC;
    }

@


1.524
log
@	* path.cc (symlink_info::check_shortcut): Don't check for executability
	here.
	(symlink_info::check_sysfile): Ditto.
@
text
@d1302 2
a1303 5
  /* Do NOT check for .exe suffix, otherwise rename(2) misbehaves
     when renaming files to existing executables with omitted suffix.
     strip(1) is a candidate uncovering wrong behaviour here. */
  return exec_state () == is_executable
	 || GetBinaryTypeW (get_wide_win32_path (bintest), &bin);
@


1.523
log
@	* path.cc (path_conv::path_conv): Only assume executability by suffix
	on file systems not supporting permissions.
@
text
@d1880 1
a1880 1
    goto file_not_symlink;
d1885 1
a1885 1
    goto file_not_symlink;
d1901 1
a1901 1
	goto file_not_symlink;
a1908 5
file_not_symlink:
  /* Not a symlink, see if executable.  */
  if (!(pflags & PATH_ALL_EXEC) && has_exec_chars ((const char *) &file_header, io.Information))
    pflags |= PATH_EXEC;

a1962 10
  else
    {
      /* Not a symlink, see if executable.  */
      if (pflags & PATH_ALL_EXEC)
	/* Nothing to do */;
      else if (has_exec_chars (cookie_buf, io.Information))
	pflags |= PATH_EXEC;
      else
	pflags |= PATH_NOTEXEC;
      }
@


1.522
log
@* cygheap.cc (creturn): Reorganize to avoid a new compiler warning/error.
* dtable.cc (handle_to_fn): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::scroll_screen): Ditto.
(dev_console::set_color): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
* hookapi.cc (find_first_notloaded_dll): Ditto.
* mmap.cc (msync): Ditto.
* pipe.cc (pipesync::pipesync): Ditto.
* sec_acl.cc (getace): Ditto.
* sec_auth.cc (create_token): Ditto.
(lsaauth): Ditto.
* select.cc (peek_pipe): Ditto.
* spawn.cc (av::fixup): Ditto.
* syscalls.cc (popen): Ditto.
* tty.cc (tty::init_session): Ditto.
* uinfo.cc (pwdgrp::load): Ditto.
* fhandler.cc (fhandler_base::setup_overlapped): Ditto.
(fhandler_base::wait_overlapped): Rename second use of res variable to wres or
errors are not returned correctly.
* dcrt0.cc: Remove obsolete variable.
* dll_init.cc (release_upto): Fix typo involving incorrect use of '|'.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Avoid a compiler
warning regarding coercing type-punned variables.
(fhandler_base::fstat_by_name): Ditto.  fhandler_fifo.cc
(fhandler_fifo::open_nonserver): Fix = vs.  == typo.
(fhandler_fifo::wait): Add all conditions to switch statement to avoid a
compiler warning.
* fhandler_process.cc: Avoid unneeded initialization of variables to zero.
(fhandler_socket::listen): Add braces around initializer.
* flock.cc (inode_t::get_all_locks_list): Reorganize to avoid a compiler
warning.  Fix problem with EWOULDBLOCK error return.
* path.cc (GUID_shortcut): Use braces around struct initializer.
(cygwin_conv_path): Reorganize to avoid a compiler warning.
* random.cc (dummy): Mark variable as volatile to avoid a "used uninitialized"
warning.
* libc/getopt.c: Mark some variables as dllexport although gcc doesn't seem to
do the right thing with them.
* libc/minires-os-if.c (get_registry_dns_items): Coerce some function arguments
to avoid a compiler warning.
@
text
@d1251 2
a1252 1
  if (!error && !isdir () && !(path_flags & PATH_ALL_EXEC))
@


1.521
log
@	* path.cc (symlink_info::check_shortcut): If file can't be opened,
	treat it as non-symlink rather than generating an EIO error.
	(symlink_info::check_sysfile): Ditto.
@
text
@d107 1
a107 1
			= { 0x00021401L, 0, 0, 0xc0, 0, 0, 0, 0, 0, 0, 0x46 };
d2778 18
a2795 16
      p.check ((const char *) from,
	       PC_POSIX | PC_SYM_FOLLOW | PC_NO_ACCESS_CHECK | PC_NOWARN
	       | (relative ? PC_NOFULL : 0));
      if (p.error)
	return_with_errno (p.error);
      PUNICODE_STRING up = p.get_nt_native_path ();
      buf = tp.c_get ();
      sys_wcstombs (buf, NT_MAX_PATH, up->Buffer, up->Length / sizeof (WCHAR));
      /* Convert native path to standard DOS path. */
      if (!strncmp (buf, "\\??\\", 4))
        {
	  buf += 4;
	  if (buf[1] != ':') /* native UNC path */
	    *(buf += 2) = '\\';
	}
      lsiz = strlen (buf) + 1;
@


1.520
log
@	* path.cc (symlink_info::check): Don't use eabuf when trying to open
	file a second time.  Call NtOpenFile instead of NtCreateFile in this
	case.
@
text
@d1855 1
a1855 4
    {
      set_error (EIO);
      return 0;
    }
d1936 1
a1936 1
    set_error (EIO);
@


1.519
log
@	* external.cc (cygwin_internal): Call set_security_attribute with
	additional path_conv argument.
	* fhandler.cc (fhandler_base::open): Ditto.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Never set DOS
	R/O attribute when using ACLs.
	(fhandler_disk_file::mkdir): Ditto.  Set
	security descriptor on remote dirs after creating the dir, same as in
	fhandler_base::open.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto for remote AF_LOCAL
	socket files.
	* path.cc (symlink_worker): Ditto. for remote symlinks.
	* security.cc (alloc_sd): Take additional path_conv argument.
	Accommodate throughout.  Drop setting FILE_WRITE_EA/FILE_READ_EA
	flags unconditionally (was only necessary for "ntea"). Don't set
	FILE_READ_ATTRIBUTES and FILE_WRITE_ATTRIBUTES unconditionally on
	Samba.  Add comment to explain.  Drop useless setting of
	STANDARD_RIGHTS_WRITE, it's in FILE_GENERIC_WRITE anyway.
	Remove FILE_READ_ATTRIBUTES bit from FILE_GENERIC_EXECUTE so as not
	to enforce read permissions on Samba.
	(set_security_attribute): Take additional path_conv argument.
	* security.h (set_security_attribute): Change prototype accordingly.
@
text
@d2359 2
a2360 2
			     &attr, &io, NULL, FILE_ATTRIBUTE_NORMAL,
			     FILE_SHARE_VALID_FLAGS, FILE_OPEN,
d2375 4
a2378 6
	  status = NtCreateFile (&h, READ_CONTROL | FILE_READ_ATTRIBUTES,
				 &attr, &io, NULL, FILE_ATTRIBUTE_NORMAL,
				 FILE_SHARE_VALID_FLAGS, FILE_OPEN,
				 FILE_OPEN_REPARSE_POINT
				 | FILE_OPEN_FOR_BACKUP_INTENT,
				 eabuf, easize);
@


1.518
log
@	* path.cc (symlink_info::check): Handle (and explain) a special case
	when accessing files matching DOS device names on SMB shares.
@
text
@d1769 4
a1772 2
  if (win32_newpath.has_acls ())
    set_security_attribute (S_IFLNK | STD_RBITS | STD_WBITS,
d1788 3
@


1.517
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_by_name): Check for
	file systems incapable of handling FileIdBothDirectoryInformation
	correctly.
	(fhandler_disk_file::opendir): Ditto.
	* path.cc (fs_info::update): Always clear at the start.
	Rearrange to make certain tests only on non-Samba, non-NFS remote
	drives.
	Add test for file systems known to be incapable of handling
	FileIdBothDirectoryInformation correctly.  Right now that's just
	"UNIXFS".
	* path.h (struct fs_info): Add has_buggy_fileid_dirinfo flag and
	accessor methods.
	(class path_conv): Add has_buggy_fileid_dirinfo method.
@
text
@d2443 12
@


1.516
log
@	* dcrt0.cc (dll_crt0_0): Call malloc_init and user_shared_initialize_1
	here in case we're dynamically loaded.  Explain why.
	(dll_crt0_1): Call user_shared_initialize_1 from here.
	* mount.cc (is_native_path): New inline function testing for native
	and long Win32 path prefix.
	(is_unc_share): Remove long WIn32 path prefix test.
	(mount_info::create_root_entry): Use PATH_MAX buffer.
	(mount_info::init): Ditto.
	(mount_info::add_item): Test for is_native_path as well.
	* path.cc (normalize_win32_path): Simplify native path prefix code.
	* shared.cc (user_shared_initialize_1): New function taking user
	shared initialization code relying on malloc and cygtls.
	(user_shared_initialize): Move mountinfo initialization to
	user_shared_initialize_1.
	* shared_info.h (user_shared_initialize_1): Declare.
	* syscalls.cc (seteuid32): Call user_shared_initialize_1 after user
	changed.
@
text
@d392 1
a423 1
	  clear ();
a452 2
      has_buggy_open (false);
      flags (0);
d507 24
a530 3
      is_netapp (!is_samba ()
		 && RtlEqualUnicodeString (&fsname, &testname, FALSE)
		 && FS_IS_NETAPP_DATAONTAP);
a533 2
  RtlInitUnicodeString (&testname, L"NFS");
  is_nfs (RtlEqualUnicodeString (&fsname, &testname, FALSE));
a538 4
  /* Known file systems with buggy open calls. Further explanation
     in fhandler.cc (fhandler_disk_file::open). */
  RtlInitUnicodeString (&testname, L"SUNWNFS");
  has_buggy_open (RtlEqualUnicodeString (&fsname, &testname, FALSE));
@


1.515
log
@	* shared.cc (user_shared_initialize): Fetch potentially changed Cygwin
	username from /etc/passwd before loading mount table.
	(shared_info::init_installation_root): New function fetching Cygwin's
	installation root dir and storing as native NT path in global shared
	memory.
	(shared_info::initialize): Call init_installation_root exactly once at
	first startup.
	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add installation_root member.
	(shared_info::init_installation_root): Declare.

	* grp.cc (pwdgrp::read_group): Call pwdgrp::load with native WCHAR path.
	* passwd.cc (pwdgrp::read_passwd): Ditto.  Avoid recursion.
	(etc::init): Take POBJECT_ATTRIBUTES instead of path_conv.
	* path.h (etc::init): Change prototype accordingly.
	* pwdgrp.h (class pwdgrp): Store path as UNICODE_STRING/PWCHAR instead
	of as path_conv.
	(pwdgrp::load): Accommodate prototype.
	* uinfo.cc (pwdgrp::load): Change argument type from char to wchar_t.
	Create native NT path here instead of calling path_conv.

	* mount.cc (find_root_from_cygwin_dll): Drop in favor of global
	initializaion in shared_info.
	(mount_info::init): Fetch native NT root dir from cygwin_shared.
	(mount_info::from_fstab): Expect native NT path and use native NT
	functions to access file.  Convert username part in user fstab path
	according to special char transformation rules.
	* path.cc (tfx_chars): Convert slash to backslash.
	(transform_chars): Implement for path given as PWCHAR.
	(transform_chars): PUNICODE_STRING version calls PWCHAR version.
	Remove useless commented code.
@
text
@d1314 1
a1314 4
	{
	  src += 2; /* Fortunately the first char is not copied... */
	  beg_src_slash = true;
	}
d1316 1
a1316 1
	beg_src_slash = isdirsep (src[0]);
@


1.514
log
@	* path.cc (allow_winsymlinks): Revert default to create system bit
	symlinks for speed.
@
text
@d577 1
a577 1
  '(', ')', 0xf000 | '*', '+', ',', '-', '.', '/',
d590 10
a599 1
static void
d602 2
a603 13
  register PWCHAR buf = upath->Buffer;
  register PWCHAR end = buf + upath->Length / sizeof (WCHAR) - 1;
  for (buf += start_idx; buf <= end; ++buf)
    if (*buf < 128)
      *buf = tfx_chars[*buf];
#if 0
  /* Win32 can't handle trailing dots and spaces.  Transform the last of them
     to the private use area, too, to create a valid Win32 filename. */
  if (*end == L'\\')
    --end;
  if (*end == L'.' || *end == L' ')
    *end |= 0xf000;
#endif
d3392 1
a3392 1
etc::init (int n, path_conv &pc)
d3401 1
a3401 1
  pc.get_object_attr (fn[n], sec_none_nih);
@


1.513
log
@	Add case-sensitivity.
	Unconditionally handle mount points case-sensitive.
	Unconditionally handle virtual paths case-sensitive.
	Unconditionally handle registry paths case-insensitive.
	Otherwise, accommodate case-sensitivity of given path throughout.
	* cygheap.cc (cygheap_root::set): Get additional caseinsensitive
	parameter and store it.
	* cygheap.h (struct cygheap_root_mount_info): Add member
	caseinsensitive.
	* dlfcn.cc (get_full_path_of_dll): Drop PC_NOFULL parameter from call
	to path_conv::check.
	* environ.cc (pcheck_case): Remove.
	(check_case_init): Remove.
	(known): Drop "check_case" option.
	* exceptions.cc (open_stackdumpfile): Add comment.
	* fhandler.cc (fhandler_base::get_default_fmode): Call pathmatch
	instead of strcasematch.
	* fhandler_disk_file.cc: Accommodate case-sensitivity of given path
	throughout.
	(__DIR_mounts::check_mount): Unconditionally check virtual paths
	case-sensitive.
	(fhandler_disk_file::link): Drop case clash handling.
	(fhandler_disk_file::open): Ditto.
	(fhandler_disk_file::readdir_helper): Drop managed mount code.
	* mount.cc: Remove managed mount code and datastructures.
	(struct opt): Remove "managed" option.  Add "posix=0" and "posix=1"
	options.
	(fillout_mntent): Remove "managed" output.  Add "posix" output.
	* path.cc (struct symlink_info): Remove case_clash member and
	case_check method.
	(pcheck_case): Remove.
	(path_prefix_p): Take additional bool parameter "caseinsensitive".
	(pathnmatch): Ditto.
	(pathmatch): Ditto.
	(mkrelpath): Ditto.
	(fs_info::update): Set caseinsensitive flag according to file system
	name and FILE_CASE_SENSITIVE_SEARCH flag.  Add comment.
	(tfx_chars_managed): Remove.
	(transform_chars): Drop "managed" parameter.  Always use tfx_chars.
	(get_nt_native_path): Drop "managed" parameter.  Make sure drive letters
	are always upper case.
	(getfileattr): Change second parameter to denote caseinsensitivity.
	(path_conv::check): Initialize caseinsensitive to OBJ_CASE_INSENSITIVE.
	Set caseinsensitive according to global obcaseinsensitive flag, file
	system case sensitivity and MOUNT_NOPOSIX mount flag.
	Drop case_clash and all the related code.
	(symlink_worker): Drop case clash handling.
	(symlink_info::set): Drop setting case_clash.
	(symlink_info::case_check): Remove.
	(cwdstuff::set): Add comment.
	(etc::init): Take path_conv instead of PUNICODE_STRING as parameter to
	allow case sensitivity.
	* path.h (enum pathconv_arg): Drop PC_SYM_IGNORE.
	(enum case_checking): Remove.
	(enum path_types): Drop PATH_ENC, add PATH_NOPOSIX flag.
	(struct fs_info): Add caseinsensitive flag and accessor methods.
	(class path_conv): Add caseinsensitive member and define
	objcaseinsensitive method.  Drop case_clash member and isencoded method.
	(pathmatch): Change prototype according to above change.
	(pathnmatch): Ditto.
	(path_prefix_p): Ditto.
	(get_nt_native_path): Ditto.
	(class etc): Ditto.
	(fnunmunge): Remove prototype.
	* shared.cc (shared_info::init_obcaseinsensitive): Initialize
	obcaseinsensitive flag from obcaseinsensitive registry value.
	(shared_info::initialize): Call init_obcaseinsensitive here by the
	first process creating the shared memory.
	* shared_info.h (mount_item::fnmunge): Remove.
	(shared_info::obcaseinsensitive): Rename from obcaseinsensitivity.
	(shared_info::init_obcaseinsensitive): Declare.
	* syscalls.cc (try_to_bin): Add comment.
	* include/sys/mount.h (MOUNT_ENC): Remove flag.
	(MOUNT_NOPOSIX): Add flag.
@
text
@d1502 1
a1502 1
bool allow_winsymlinks = true;
@


1.512
log
@	Throughout drop allow_ntsec and allow_smbntsec handling.
	* environ.cc (set_ntsec): Remove.
	(set_smbntsec): Remove.
	(known): Remove ntsec and smbntsec options.
	* external.cc (check_ntsec): Return true if no filename is given.
	* mount.cc (oopts): Add "acl" and "noacl" options.  Set MOUNT_NOACL
	flag accordingly.
	(fillout_mntent): Handle MOUNT_NOACL flag.
	* path.h (enum path_types): Add PATH_NOACL.
	* security.cc (allow_ntsec): Remove.
	(allow_smbntsec): Remove.
	* security.h (allow_ntsec): Drop declaration.
	(allow_smbntsec): Drop declaration.
	* include/sys/mount.h (MOUNT_NOACL): Define.
@
text
@d74 1
a87 1
  bool case_clash;
a95 1
  bool case_check (char *path);
a105 2
int pcheck_case = PCHECK_RELAXED; /* Determines the case check behaviour. */

d154 2
a155 1
path_prefix_p (const char *path1, const char *path2, int len1)
d165 2
a166 1
    return pathnmatch (path1, path2, len1);
d174 1
a174 1
pathnmatch (const char *path1, const char *path2, int len)
d176 2
a177 2
  return pcheck_case == PCHECK_STRICT ? !strncmp (path1, path2, len)
				      : strncasematch (path1, path2, len);
d183 1
a183 1
pathmatch (const char *path1, const char *path2)
d185 2
a186 2
  return pcheck_case == PCHECK_STRICT ? !strcmp (path1, path2)
				      : strcasematch (path1, path2);
d328 1
a328 1
static void __stdcall mkrelpath (char *dst) __attribute__ ((regparm (2)));
d330 1
a330 1
mkrelpath (char *path)
d338 1
a338 1
  if (!path_prefix_p (cwd_win32, path, cwdlen))
d396 1
d526 6
a589 19
WCHAR tfx_chars_managed[] NO_COPY = {
   0,   1,   2,   3,   4,   5,   6,   7,
   8,   9,  10,  11,  12,  13,  14,  15,
  16,  17,  18,  19,  20,  21,  22,  23,
  24,  25,  26,  27,  28,  29,  30,  31,
  32, '!', 0xf000 | '"', '#', '$', '%', '&',  39,
  '(', ')', 0xf000 | '*', '+', ',', '-', '.', '/',
 '0', '1', '2', '3', '4', '5', '6', '7',
 '8', '9', 0xf000 | ':', ';', 0xf000 | '<', '=', 0xf000 | '>', 0xf000 | '?',
 '@@', 0xf000 | 'A', 0xf000 | 'B', 0xf000 | 'C', 0xf000 | 'D', 0xf000 | 'E', 0xf000 | 'F', 0xf000 | 'G',
 0xf000 | 'H', 0xf000 | 'I', 0xf000 | 'J', 0xf000 | 'K', 0xf000 | 'L', 0xf000 | 'M', 0xf000 | 'N', 0xf000 | 'O',
 0xf000 | 'P', 0xf000 | 'Q', 0xf000 | 'R', 0xf000 | 'S', 0xf000 | 'T', 0xf000 | 'U', 0xf000 | 'V', 0xf000 | 'W',
 0xf000 | 'X', 0xf000 | 'Y', 0xf000 | 'Z', '[',  '\\', ']', '^', '_',
 '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',
 'x', 'y', 'z', '{', 0xf000 | '|', '}', '~', 127
};

d591 1
a591 1
transform_chars (PUNICODE_STRING upath, USHORT start_idx, bool managed)
a594 1
  register PWCHAR tfx = managed ? tfx_chars_managed : tfx_chars;
d597 1
a597 1
      *buf = tfx[*buf];
d609 1
a609 1
get_nt_native_path (const char *path, UNICODE_STRING& upath, bool managed)
d617 9
a625 3
	str2uni_cat (upath, "\\??\\");
      str2uni_cat (upath, path);
      transform_chars (&upath, 7, managed);
d634 1
a634 1
      transform_chars (&upath, 8, managed);
d653 1
a653 1
      ::get_nt_native_path (path, uni_path, isencoded ());
d664 1
a664 1
			      OBJ_CASE_INSENSITIVE
d703 1
a703 1
getfileattr (const char *path, bool managed) /* path has to be always absolute. */
d713 4
a716 2
  InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE, NULL, NULL);
  get_nt_native_path (path, upath, managed);
d733 2
a734 1
				  OBJ_CASE_INSENSITIVE, NULL, NULL);
d823 1
a826 1
  case_clash = false;
d916 2
a917 1
		  fileattr = getfileattr (this->path, sym.pflags & MOUNT_ENC);
d926 1
a926 1
	      fileattr = getfileattr (this->path, sym.pflags & MOUNT_ENC);
d1030 1
a1030 1
	  if (sym.case_clash)
d1032 17
a1048 1
	      if (pcheck_case == PCHECK_STRICT)
d1050 1
a1050 2
		  case_clash = true;
		  error = ENOENT;
d1053 1
a1053 6
	      /* If pcheck_case==PCHECK_ADJUST the case_clash is remembered
		 if the last component is concerned. This allows functions
		 which shall create files to avoid overriding already existing
		 files with another case. */
	      if (!component)
		case_clash = true;
d1055 6
a1060 1
	  if (!(opt & PC_SYM_IGNORE))
d1062 2
a1063 10
	      if (!component)
		{
		  fileattr = sym.fileattr;
		  path_flags = sym.pflags;
		}

	      /* If symlink.check found an existing non-symlink file, then
		 it sets the appropriate flag.  It also sets any suffix found
		 into `ext_here'. */
	      if (!sym.issymlink && sym.fileattr != INVALID_FILE_ATTRIBUTES)
d1065 2
a1066 4
		  error = sym.error;
		  if (component == 0)
		    add_ext_from_sym (sym);
		  else if (!(sym.fileattr & FILE_ATTRIBUTE_DIRECTORY))
d1068 1
a1068 1
		      error = ENOTDIR;
d1071 1
a1071 35
		  if (pcheck_case == PCHECK_RELAXED)
		    goto out;	// file found
		  /* Avoid further symlink evaluation. Only case checks are
		     done now. */
		  opt |= PC_SYM_IGNORE;
		}
	      /* Found a symlink if symlen > 0.  If component == 0, then the
		 src path itself was a symlink.  If !follow_mode then
		 we're done.  Otherwise we have to insert the path found
		 into the full path that we are building and perform all of
		 these operations again on the newly derived path. */
	      else if (symlen > 0)
		{
		  saw_symlinks = 1;
		  if (component == 0 && !need_directory && !(opt & PC_SYM_FOLLOW))
		    {
		      set_symlink (symlen); // last component of path is a symlink.
		      if (opt & PC_SYM_CONTENTS)
			{
			  strcpy (path, sym.contents);
			  goto out;
			}
		      add_ext_from_sym (sym);
		      if (pcheck_case == PCHECK_RELAXED)
			goto out;
		      /* Avoid further symlink evaluation. Only case checks are
			 done now. */
		      opt |= PC_SYM_IGNORE;
		    }
		  else
		    break;
		}
	      else if (sym.error && sym.error != ENOENT && sym.error != ENOSHARE)
		{
		  error = sym.error;
d1074 2
a1075 1
	      /* No existing file found. */
d1077 6
d1223 1
a1223 1
	mkrelpath (this->path);
d1564 1
a1564 1
      set_errno (win32_newpath.case_clash ? ECASECLASH : win32_newpath.error);
d2311 2
a2312 1
  case_clash = false;
d2320 1
a2320 1
  InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE, NULL, NULL);
d2333 1
a2333 1
      get_nt_native_path (suffix.path, upath, pflags & MOUNT_ENC);
d2412 2
a2413 2
	      InitializeObjectAttributes (&dattr, &dirname,
					  OBJ_CASE_INSENSITIVE, NULL, NULL);
a2452 4
      if (pcheck_case != PCHECK_RELAXED && !case_check (path)
	  || (opt & PC_SYM_IGNORE))
	goto file_not_symlink;

d2543 1
a2543 1
  ext_tacked_on = case_clash = false;
a2548 42
/* Check the correct case of the last path component (given in DOS style).
   Adjust the case in this->path if pcheck_case == PCHECK_ADJUST or return
   false if pcheck_case == PCHECK_STRICT.
   Dont't call if pcheck_case == PCHECK_RELAXED.
*/

bool
symlink_info::case_check (char *path)
{
  WIN32_FIND_DATA data;
  HANDLE h;
  char *c;

  /* Set a pointer to the beginning of the last component. */
  if (!(c = strrchr (path, '\\')))
    c = path;
  else
    ++c;

  if ((h = FindFirstFile (path, &data))
      != INVALID_HANDLE_VALUE)
    {
      FindClose (h);

      /* If that part of the component exists, check the case. */
      if (strncmp (c, data.cFileName, strlen (data.cFileName)))
	{
	  case_clash = true;

	  /* If check is set to STRICT, a wrong case results
	     in returning a ENOENT. */
	  if (pcheck_case == PCHECK_STRICT)
	    return false;

	  /* PCHECK_ADJUST adjusts the case in the incoming
	     path which points to the path in *this. */
	  strcpy (c, data.cFileName);
	}
    }
  return true;
}

d3199 1
d3394 1
a3394 1
etc::init (int n, PUNICODE_STRING etc_fn)
d3403 1
a3403 1
  InitializeObjectAttributes (&fn[n], etc_fn, OBJ_CASE_INSENSITIVE, NULL, NULL);
@


1.511
log
@	* path.cc (path_conv::is_binary): Fix test.  Add comment.
@
text
@d519 1
a519 2
  has_acls ((flags () & FS_PERSISTENT_ACLS)
	    && (allow_smbntsec || !is_remote_drive ()));
d1233 1
a1233 1
	  if (fs.has_acls () && allow_ntsec)
d1787 1
a1787 1
  if (allow_ntsec && win32_newpath.has_acls ())
@


1.510
log
@	* path.cc (get_nt_native_path): Drop considerations for DOS devices.
	Keep relative paths relative.
	(cygwin_conv_path): Don't try to skip native NT prefixes on relative
	paths.
@
text
@d1317 3
d1321 1
a1321 2
	 && RtlEqualUnicodePathSuffix (get_nt_native_path (), L".exe", TRUE)
	 && GetBinaryTypeW (get_wide_win32_path (bintest), &bin);
@


1.509
log
@	* path.cc (symlink_info::check): Reorder test for nfs symlinks.
@
text
@d629 1
a629 1
  else if (path[0] != '\\')	/* X:\...  or NUL, etc. */
d631 2
a632 1
      str2uni_cat (upath, "\\??\\");
d2836 7
a2842 3
      buf += 4; /* Skip \??\ */
      if (buf[1] != ':') /* native UNC path */
	*(buf += 2) = '\\';
@


1.508
log
@	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Don't try to
	use FileIdBothDirectoryInformation on NFS shares.  Fix comment to
	explain why.
	* path.cc (symlink_info::check): Reinstantiate no_ea.  Use in
	erroneously changed condition.
@
text
@d2530 1
a2530 1
      else if (!no_ea && !(fileattr & FILE_ATTRIBUTE_DIRECTORY) && fs.is_nfs ())
@


1.507
log
@* mount.cc (mount_info::from_fstab): Use cygwin_hmodule rather than trying to
find handle based on cygwin1.dll.
* path.cc (symlink_info::check): Remove unused variable.
@
text
@d2345 1
a2345 1
  void *eabuf = &nfs_aol_ffei;
d2353 1
d2377 1
d2385 1
a2385 2
	  status = NtCreateFile (&h,
				 READ_CONTROL | FILE_READ_ATTRIBUTES,
d2530 1
a2530 1
      else if (!eabuf && !(fileattr & FILE_ATTRIBUTE_DIRECTORY) && fs.is_nfs ())
@


1.506
log
@	* path.cc (symlink_info::check): Define eabuf and easize outside of
	loop.  Set to NULL on first STATUS_EAS_NOT_SUPPORTED.  Align comments.
	Fix formatting.
@
text
@a2352 1
      bool no_ea = false;
a2375 1
	  no_ea = true;
@


1.505
log
@* path.cc (symlink_info::check): Don't pass EaBuffer to NtCreateFile if it has
indicated that it isn't appropriate.
* ntdll.h (STATUS_EAS_NOT_SUPPORTED): Define.
* winsup.h: Remove __builtin* defines.
@
text
@d75 1
a75 1
  bool dos_file_warning = true;
d77 63
a139 26
  struct symlink_info
  {
    char contents[SYMLINK_MAX + 1];
    char *ext_here;
    int extn;
    unsigned pflags;
    DWORD fileattr;
    int issymlink;
    bool ext_tacked_on;
    int error;
    bool case_clash;
    bool isdevice;
    _major_t major;
    _minor_t minor;
    _mode_t mode;
    int check (char *path, const suffix_info *suffixes, unsigned opt,
	       fs_info &fs);
    int set (char *path);
    bool parse_device (const char *);
    bool case_check (char *path);
    int check_sysfile (HANDLE h);
    int check_shortcut (HANDLE h);
    int check_reparse_point (HANDLE h);
    int check_nfs_symlink (HANDLE h);
    int posixify (char *srcbuf);
    bool set_error (int);
d142 87
a228 1
  muto NO_COPY cwdstuff::cwd_lock;
d230 2
a231 1
  int pcheck_case = PCHECK_RELAXED; /* Determines the case check behaviour. */
d233 23
a255 12
  static const GUID GUID_shortcut
			  = { 0x00021401L, 0, 0, 0xc0, 0, 0, 0, 0, 0, 0, 0x46 };

  enum {
    WSH_FLAG_IDLIST = 0x01,	/* Contains an ITEMIDLIST. */
    WSH_FLAG_FILE = 0x02,		/* Contains a file locator element. */
    WSH_FLAG_DESC = 0x04,		/* Contains a description. */
    WSH_FLAG_RELPATH = 0x08,	/* Contains a relative path. */
    WSH_FLAG_WD = 0x10,		/* Contains a working dir. */
    WSH_FLAG_CMDLINE = 0x20,	/* Contains command line args. */
    WSH_FLAG_ICON = 0x40		/* Contains a custom icon. */
  };
d257 1
a257 1
  struct win_shortcut_hdr
d259 11
a269 38
      DWORD size;		/* Header size in bytes.  Must contain 0x4c. */
      GUID magic;		/* GUID of shortcut files. */
      DWORD flags;	/* Content flags.  See above. */

      /* The next fields from attr to icon_no are always set to 0 in Cygwin
	 and U/Win shortcuts. */
      DWORD attr;	/* Target file attributes. */
      FILETIME ctime;	/* These filetime items are never touched by the */
      FILETIME mtime;	/* system, apparently. Values don't matter. */
      FILETIME atime;
      DWORD filesize;	/* Target filesize. */
      DWORD icon_no;	/* Icon number. */

      DWORD run;		/* Values defined in winuser.h. Use SW_NORMAL. */
      DWORD hotkey;	/* Hotkey value. Set to 0.  */
      DWORD dummy[2];	/* Future extension probably. Always 0. */
    };

  /* Return non-zero if PATH1 is a prefix of PATH2.
     Both are assumed to be of the same path style and / vs \ usage.
     Neither may be "".
     LEN1 = strlen (PATH1).  It's passed because often it's already known.

     Examples:
     /foo/ is a prefix of /foo  <-- may seem odd, but desired
     /foo is a prefix of /foo/
     / is a prefix of /foo/bar
     / is not a prefix of foo/bar
     foo/ is a prefix foo/bar
     /foo is not a prefix of /foobar
  */

  int
  path_prefix_p (const char *path1, const char *path2, int len1)
  {
    /* Handle case where PATH1 has trailing '/' and when it doesn't.  */
    if (len1 > 0 && isdirsep (path1[len1 - 1]))
      len1--;
d271 2
a272 2
    if (len1 == 0)
      return isdirsep (path2[0]) && !isdirsep (path2[1]);
d274 20
a293 52
    if (isdirsep (path2[len1]) || path2[len1] == 0 || path1[len1 - 1] == ':')
      return pathnmatch (path1, path2, len1);

    return 0;
  }

  /* Return non-zero if paths match in first len chars.
     Check is dependent of the case sensitivity setting. */
  int
  pathnmatch (const char *path1, const char *path2, int len)
  {
    return pcheck_case == PCHECK_STRICT ? !strncmp (path1, path2, len)
					: strncasematch (path1, path2, len);
  }

  /* Return non-zero if paths match. Check is dependent of the case
     sensitivity setting. */
  int
  pathmatch (const char *path1, const char *path2)
  {
    return pcheck_case == PCHECK_STRICT ? !strcmp (path1, path2)
					: strcasematch (path1, path2);
  }

  /* TODO: This function is used in mkdir and rmdir to generate correct
     error messages in case of paths ending in /. or /.. components.
     Right now, normalize_posix_path will just normalize
     those components away, which changes the semantics.  */
  bool
  has_dot_last_component (const char *dir, bool test_dot_dot)
  {
    /* SUSv3: . and .. are not allowed as last components in various system
       calls.  Don't test for backslash path separator since that's a Win32
       path following Win32 rules. */
    const char *last_comp = strrchr (dir, '/');
    if (!last_comp)
      last_comp = dir;
    else {
      /* Check for trailing slash.  If so, hop back to the previous slash. */
      if (!last_comp[1])
	while (last_comp > dir)
	  if (*--last_comp == '/')
	    break;
      if (*last_comp == '/')
	++last_comp;
    }
    return last_comp[0] == '.'
	   && ((last_comp[1] == '\0' || last_comp[1] == '/')
	       || (test_dot_dot
		   && last_comp[1] == '.'
		   && (last_comp[2] == '\0' || last_comp[2] == '/')));
  }
a294 29
  /* Normalize a POSIX path.
     All duplicate /'s, except for 2 leading /'s, are deleted.
     The result is 0 for success, or an errno error value.  */

  int
  normalize_posix_path (const char *src, char *dst, char *&tail)
  {
    const char *in_src = src;
    char *dst_start = dst;
    syscall_printf ("src %s", src);

    if ((isdrive (src) && isdirsep (src[2])) || *src == '\\')
      goto win32_path;

    tail = dst;
    if (!isslash (src[0]))
      {
	if (!cygheap->cwd.get (dst))
	  return get_errno ();
	tail = strchr (tail, '\0');
	if (isslash (dst[0]) && isslash (dst[1]))
	  ++dst_start;
	if (*src == '.')
	  {
	    if (tail == dst_start + 1 && *dst_start == '/')
	       tail--;
	    goto sawdot;
	  }
	if (tail > dst && !isslash (tail[-1]))
d296 2
a297 16
      }
    /* Two leading /'s?  If so, preserve them.  */
    else if (isslash (src[1]) && !isslash (src[2]))
      {
	*tail++ = *src++;
	++dst_start;
      }

    while (*src)
      {
	if (*src == '\\')
	  goto win32_path;
	/* Strip runs of /'s.  */
	if (!isslash (*src))
	  *tail++ = *src++;
	else
d299 2
a300 30
	    while (*++src)
	      {
		if (isslash (*src))
		  continue;

		if (*src != '.')
		  break;

	      sawdot:
		if (src[1] != '.')
		  {
		    if (!src[1])
		      {
			*tail++ = '/';
			goto done;
		      }
		    if (!isslash (src[1]))
		      break;
		  }
		else if (src[2] && !isslash (src[2]))
		  break;
		else
		  {
		    while (tail > dst_start && !isslash (*--tail))
		      continue;
		    src++;
		  }
	      }

	    *tail++ = '/';
d302 1
a302 6
	  if ((tail - dst) >= NT_MAX_PATH)
	    {
	      debug_printf ("ENAMETOOLONG = normalize_posix_path (%s)", src);
	      return ENAMETOOLONG;
	    }
      }
d304 2
a305 2
  done:
    *tail = '\0';
d307 2
a308 2
    debug_printf ("%s = normalize_posix_path (%s)", dst, in_src);
    return 0;
d310 18
a327 46
  win32_path:
    int err = normalize_win32_path (in_src, dst, tail);
    if (!err)
      for (char *p = dst; (p = strchr (p, '\\')); p++)
	*p = '/';
    return err ?: -1;
  }

  inline void
  path_conv::add_ext_from_sym (symlink_info &sym)
  {
    if (sym.ext_here && *sym.ext_here)
      {
	known_suffix = path + sym.extn;
	if (sym.ext_tacked_on)
	  strcpy (known_suffix, sym.ext_here);
      }
  }

  static void __stdcall mkrelpath (char *dst) __attribute__ ((regparm (2)));
  static void __stdcall
  mkrelpath (char *path)
  {
    tmp_pathbuf tp;
    char *cwd_win32 = tp.c_get ();
    if (!cygheap->cwd.get (cwd_win32, 0))
      return;

    unsigned cwdlen = strlen (cwd_win32);
    if (!path_prefix_p (cwd_win32, path, cwdlen))
      return;

    size_t n = strlen (path);
    if (n < cwdlen)
      return;

    char *tail = path;
    if (n == cwdlen)
      tail += cwdlen;
    else
      tail += isdirsep (cwd_win32[cwdlen - 1]) ? cwdlen : cwdlen + 1;

    memmove (path, tail, strlen (tail) + 1);
    if (!*path)
      strcpy (path, ".");
  }
d329 32
a360 4
  /* Beginning with Samba 3.0.28a, Samba allows to get version information using
     the ExtendedInfo member returned by a FileFsObjectIdInformation request.
     We just store the samba_version information for now.  Older versions than
     3.2 are still guessed at by testing the file system flags. */
d364 7
a370 7
  struct smb_extended_info {
    DWORD         samba_magic;             /* Always SAMBA_EXTENDED_INFO_MAGIC */
    DWORD         samba_version;           /* Major/Minor/Release/Revision */
    DWORD         samba_subversion;        /* Prerelease/RC/Vendor patch */
    LARGE_INTEGER samba_gitcommitdate;
    char          samba_version_string[SAMBA_EXTENDED_INFO_VERSION_STRING_LENGTH];
  };
d373 55
a427 55
  bool
  fs_info::update (PUNICODE_STRING upath, HANDLE in_vol)
  {
    NTSTATUS status = STATUS_OBJECT_NAME_NOT_FOUND;
    HANDLE vol;
    OBJECT_ATTRIBUTES attr;
    IO_STATUS_BLOCK io;
    bool no_media = false;
    FILE_FS_DEVICE_INFORMATION ffdi;
    FILE_FS_OBJECTID_INFORMATION ffoi;
    struct {
      FILE_FS_ATTRIBUTE_INFORMATION ffai;
      WCHAR buf[NAME_MAX + 1];
    } ffai_buf;
    struct {
      FILE_FS_VOLUME_INFORMATION ffvi;
      WCHAR buf[NAME_MAX + 1];
    } ffvi_buf;
    UNICODE_STRING fsname, testname;

    if (in_vol)
      vol = in_vol;
    else
      {
	InitializeObjectAttributes (&attr, upath, OBJ_CASE_INSENSITIVE, NULL,
				    NULL);
	status = NtOpenFile (&vol, READ_CONTROL, &attr, &io,
			     FILE_SHARE_VALID_FLAGS, FILE_OPEN_FOR_BACKUP_INTENT);
	while (!NT_SUCCESS (status)
	       && (attr.ObjectName->Length > 7 * sizeof (WCHAR)
		   || status == STATUS_NO_MEDIA_IN_DEVICE))
	  {
	    UNICODE_STRING dir;
	    RtlSplitUnicodePath (attr.ObjectName, &dir, NULL);
	    attr.ObjectName = &dir;
	    if (status == STATUS_NO_MEDIA_IN_DEVICE)
	      {
		no_media = true;
		dir.Length = 6 * sizeof (WCHAR);
	      }
	    else if (dir.Length > 7 * sizeof (WCHAR))
	      dir.Length -= sizeof (WCHAR);
	    status = NtOpenFile (&vol, READ_CONTROL, &attr, &io,
				 FILE_SHARE_VALID_FLAGS,
				 FILE_OPEN_FOR_BACKUP_INTENT);
	  }
	if (!NT_SUCCESS (status))
	  {
	    debug_printf ("Cannot access path %S, status %08lx",
			  attr.ObjectName, status);
	    clear ();
	    NtClose (vol);
	    return false;
	  }
      }
d429 37
a465 37
    status = NtQueryVolumeInformationFile (vol, &io, &ffvi_buf.ffvi,
					   sizeof ffvi_buf,
					   FileFsVolumeInformation);
    sernum = NT_SUCCESS (status) ? ffvi_buf.ffvi.VolumeSerialNumber : 0;
    status = NtQueryVolumeInformationFile (vol, &io, &ffdi, sizeof ffdi,
					   FileFsDeviceInformation);
    if (!NT_SUCCESS (status))
      ffdi.DeviceType = ffdi.Characteristics = 0;

    if (ffdi.Characteristics & FILE_REMOTE_DEVICE
	|| (!ffdi.DeviceType
	    && RtlEqualUnicodePathPrefix (attr.ObjectName, L"\\??\\UNC\\", TRUE)))
      is_remote_drive (true);
    else
      is_remote_drive (false);

    if (!no_media)
      status = NtQueryVolumeInformationFile (vol, &io, &ffai_buf.ffai,
					     sizeof ffai_buf,
					     FileFsAttributeInformation);
    if (no_media || !NT_SUCCESS (status))
      {
	debug_printf ("Cannot get volume attributes (%S), %08lx",
		      attr.ObjectName, status);
	has_buggy_open (false);
	flags (0);
	if (!in_vol)
	  NtClose (vol);
	return false;
      }
     flags (ffai_buf.ffai.FileSystemAttributes);
     name_len (ffai_buf.ffai.MaximumComponentNameLength);
  /* Should be reevaluated for each new OS.  Right now this mask is valid up
     to Vista.  The important point here is to test only flags indicating
     capabilities and to ignore flags indicating a specific state of this
     volume.  At present these flags to ignore are FILE_VOLUME_IS_COMPRESSED
     and FILE_READ_ONLY_VOLUME. */
d469 2
a470 2
  /* Volume quotas are potentially supported since Samba 3.0, object ids and
     the unicode on disk flag since Samba 3.2. */
d472 2
a473 2
			| FILE_SUPPORTS_OBJECT_IDS \
			| FILE_UNICODE_ON_DISK)
d475 3
a477 3
			       FILE_CASE_SENSITIVE_SEARCH \
			       | FILE_CASE_PRESERVED_NAMES \
			       | FILE_PERSISTENT_ACLS)
d479 66
a544 53
			       FILE_CASE_SENSITIVE_SEARCH \
			       | FILE_CASE_PRESERVED_NAMES \
			       | FILE_UNICODE_ON_DISK \
			       | FILE_PERSISTENT_ACLS \
			       | FILE_NAMED_STREAMS)
    RtlInitCountedUnicodeString (&fsname, ffai_buf.ffai.FileSystemName,
				 ffai_buf.ffai.FileSystemNameLength);
    is_fat (RtlEqualUnicodePathPrefix (&fsname, L"FAT", TRUE));
    RtlInitUnicodeString (&testname, L"NTFS");
    if (is_remote_drive ())
      {
	/* This always fails on NT4. */
	status = NtQueryVolumeInformationFile (vol, &io, &ffoi, sizeof ffoi,
					       FileFsObjectIdInformation);
	if (NT_SUCCESS (status))
	  {
	    smb_extended_info *extended_info = (smb_extended_info *)
					       &ffoi.ExtendedInfo;
	    if (extended_info->samba_magic == SAMBA_EXTENDED_INFO_MAGIC)
	      {
		is_samba (true);
		samba_version (extended_info->samba_version);
	      }
	  }
	/* Test for Samba on NT4 or for older Samba releases not supporting
	   extended info. */
	if (!is_samba ())
	  is_samba (RtlEqualUnicodeString (&fsname, &testname, FALSE)
		    && FS_IS_SAMBA);

	is_netapp (!is_samba ()
		   && RtlEqualUnicodeString (&fsname, &testname, FALSE)
		   && FS_IS_NETAPP_DATAONTAP);
      }
    is_ntfs (RtlEqualUnicodeString (&fsname, &testname, FALSE)
	     && !is_samba () && !is_netapp ());
    RtlInitUnicodeString (&testname, L"NFS");
    is_nfs (RtlEqualUnicodeString (&fsname, &testname, FALSE));
    is_cdrom (ffdi.DeviceType == FILE_DEVICE_CD_ROM);

    has_acls ((flags () & FS_PERSISTENT_ACLS)
	      && (allow_smbntsec || !is_remote_drive ()));
    hasgood_inode (((flags () & FILE_PERSISTENT_ACLS) && !is_netapp ())
		   || is_nfs ());
    /* Known file systems with buggy open calls. Further explanation
       in fhandler.cc (fhandler_disk_file::open). */
    RtlInitUnicodeString (&testname, L"SUNWNFS");
    has_buggy_open (RtlEqualUnicodeString (&fsname, &testname, FALSE));

    if (!in_vol)
      NtClose (vol);
    return true;
  }
d546 16
a561 5
  void
  path_conv::fillin (HANDLE h)
  {
    IO_STATUS_BLOCK io;
    FILE_BASIC_INFORMATION fbi;
d563 2
a564 6
    if (NT_SUCCESS (NtQueryInformationFile (h, &io, &fbi, sizeof fbi,
					    FileBasicInformation)))
      fileattr = fbi.FileAttributes;
    else
      fileattr = INVALID_FILE_ATTRIBUTES;
  }
d566 56
a621 5
  void
  path_conv::set_normalized_path (const char *path_copy)
  {
    char *p = strchr (path_copy, '\0');
    size_t n = 1 + p - path_copy;
d623 28
a650 1
    normalized_path = path + sizeof (path) - n;
d652 13
a664 8
    char *eopath = strchr (path, '\0');
    if (normalized_path > eopath)
      normalized_path_size = n;
    else
      {
	normalized_path = (char *) cmalloc_abort (HEAP_STR, n);
	normalized_path_size = 0;
      }
d666 61
a726 2
    memcpy (normalized_path, path_copy, n);
  }
d728 78
a805 18
  WCHAR tfx_chars[] NO_COPY = {
     0,   1,   2,   3,   4,   5,   6,   7,
     8,   9,  10,  11,  12,  13,  14,  15,
    16,  17,  18,  19,  20,  21,  22,  23,
    24,  25,  26,  27,  28,  29,  30,  31,
    32, '!', 0xf000 | '"', '#', '$', '%', '&',  39,
    '(', ')', 0xf000 | '*', '+', ',', '-', '.', '/',
   '0', '1', '2', '3', '4', '5', '6', '7',
   '8', '9', 0xf000 | ':', ';', 0xf000 | '<', '=', 0xf000 | '>', 0xf000 | '?',
   '@@', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
   'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
   'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
   'X', 'Y', 'Z', '[',  '\\', ']', '^', '_',
   '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
   'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
   'p', 'q', 'r', 's', 't', 'u', 'v', 'w',
   'x', 'y', 'z', '{', 0xf000 | '|', '}', '~', 127
  };
d807 3
a809 18
  WCHAR tfx_chars_managed[] NO_COPY = {
     0,   1,   2,   3,   4,   5,   6,   7,
     8,   9,  10,  11,  12,  13,  14,  15,
    16,  17,  18,  19,  20,  21,  22,  23,
    24,  25,  26,  27,  28,  29,  30,  31,
    32, '!', 0xf000 | '"', '#', '$', '%', '&',  39,
    '(', ')', 0xf000 | '*', '+', ',', '-', '.', '/',
   '0', '1', '2', '3', '4', '5', '6', '7',
   '8', '9', 0xf000 | ':', ';', 0xf000 | '<', '=', 0xf000 | '>', 0xf000 | '?',
   '@@', 0xf000 | 'A', 0xf000 | 'B', 0xf000 | 'C', 0xf000 | 'D', 0xf000 | 'E', 0xf000 | 'F', 0xf000 | 'G',
   0xf000 | 'H', 0xf000 | 'I', 0xf000 | 'J', 0xf000 | 'K', 0xf000 | 'L', 0xf000 | 'M', 0xf000 | 'N', 0xf000 | 'O',
   0xf000 | 'P', 0xf000 | 'Q', 0xf000 | 'R', 0xf000 | 'S', 0xf000 | 'T', 0xf000 | 'U', 0xf000 | 'V', 0xf000 | 'W',
   0xf000 | 'X', 0xf000 | 'Y', 0xf000 | 'Z', '[',  '\\', ']', '^', '_',
   '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
   'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
   'p', 'q', 'r', 's', 't', 'u', 'v', 'w',
   'x', 'y', 'z', '{', 0xf000 | '|', '}', '~', 127
  };
d811 5
a815 16
  static void
  transform_chars (PUNICODE_STRING upath, USHORT start_idx, bool managed)
  {
    register PWCHAR buf = upath->Buffer;
    register PWCHAR end = buf + upath->Length / sizeof (WCHAR) - 1;
    register PWCHAR tfx = managed ? tfx_chars_managed : tfx_chars;
    for (buf += start_idx; buf <= end; ++buf)
      if (*buf < 128)
	*buf = tfx[*buf];
#if 0
    /* Win32 can't handle trailing dots and spaces.  Transform the last of them
       to the private use area, too, to create a valid Win32 filename. */
    if (*end == L'\\')
      --end;
    if (*end == L'.' || *end == L' ')
      *end |= 0xf000;
a816 1
  }
d818 20
a837 28
  PUNICODE_STRING
  get_nt_native_path (const char *path, UNICODE_STRING& upath, bool managed)
  {
    upath.Length = 0;
    if (path[0] == '/')		/* special path w/o NT path representation. */
      str2uni_cat (upath, path);
    else if (path[0] != '\\')	/* X:\...  or NUL, etc. */
      {
	str2uni_cat (upath, "\\??\\");
	str2uni_cat (upath, path);
	transform_chars (&upath, 7, managed);
      }
    else if (path[1] != '\\')	/* \Device\... */
      str2uni_cat (upath, path);
    else if ((path[2] != '.' && path[2] != '?')
	     || path[3] != '\\')	/* \\server\share\... */
      {
	str2uni_cat (upath, "\\??\\UNC\\");
	str2uni_cat (upath, path + 2);
	transform_chars (&upath, 8, managed);
      }
    else				/* \\.\device or \\?\foo */
      {
	str2uni_cat (upath, "\\??\\");
	str2uni_cat (upath, path + 4);
      }
    return &upath;
  }
d839 5
a843 41
  PUNICODE_STRING
  path_conv::get_nt_native_path ()
  {
    if (!wide_path)
      {
	uni_path.Length = 0;
	uni_path.MaximumLength = (strlen (path) + 10) * sizeof (WCHAR);
	wide_path = (PWCHAR) cmalloc_abort (HEAP_STR, uni_path.MaximumLength);
	uni_path.Buffer = wide_path;
	::get_nt_native_path (path, uni_path, isencoded ());
      }
    return &uni_path;
  }

  POBJECT_ATTRIBUTES
  path_conv::get_object_attr (OBJECT_ATTRIBUTES &attr, SECURITY_ATTRIBUTES &sa)
  {
    if (!get_nt_native_path ())
      return NULL;
    InitializeObjectAttributes (&attr, &uni_path,
				OBJ_CASE_INSENSITIVE
				| (sa.bInheritHandle ? OBJ_INHERIT : 0),
				NULL, sa.lpSecurityDescriptor);
    return &attr;
  }

  PWCHAR
  path_conv::get_wide_win32_path (PWCHAR wc)
  {
    get_nt_native_path ();
    if (!wide_path || wide_path[1] != L'?') /* Native NT device path */
      return NULL;
    wcscpy (wc, wide_path);
    wc[1] = L'\\';
    return wc;
  }

  void
  warn_msdos (const char *src)
  {
    if (user_shared->warned_msdos || !dos_file_warning)
d845 1
a845 15
    tmp_pathbuf tp;
    char *posix_path = tp.c_get ();
    small_printf ("cygwin warning:\n");
    if (cygwin_conv_path (CCP_WIN_A_TO_POSIX | CCP_RELATIVE, src,
			  posix_path, NT_MAX_PATH))
      small_printf ("  MS-DOS style path detected: %s\n  POSIX equivalent preferred.\n",
		    src);
    else
      small_printf ("  MS-DOS style path detected: %s\n  Preferred POSIX equivalent is: %s\n",
		    src, posix_path);
    small_printf ("  CYGWIN environment variable option \"nodosfilewarning\" turns off this warning.\n"
		  "  Consult the user's guide for more details about POSIX paths:\n"
		  "    http://cygwin.com/cygwin-ug-net/using.html#using-pathnames\n");
    user_shared->warned_msdos = true;
  }
d847 6
a852 49
  static DWORD
  getfileattr (const char *path, bool managed) /* path has to be always absolute. */
  {
    tmp_pathbuf tp;
    UNICODE_STRING upath;
    OBJECT_ATTRIBUTES attr;
    FILE_BASIC_INFORMATION fbi;
    NTSTATUS status;
    IO_STATUS_BLOCK io;

    tp.u_get (&upath);
    InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE, NULL, NULL);
    get_nt_native_path (path, upath, managed);

    status = NtQueryAttributesFile (&attr, &fbi);
    if (NT_SUCCESS (status))
      return fbi.FileAttributes;

    if (status != STATUS_OBJECT_NAME_NOT_FOUND
	&& status != STATUS_NO_SUCH_FILE) /* File not found on 9x share */
      {
	/* File exists but access denied.  Try to get attribute through
	   directory query. */
	UNICODE_STRING dirname, basename;
	HANDLE dir;
	FILE_DIRECTORY_INFORMATION fdi;

	RtlSplitUnicodePath (&upath, &dirname, &basename);
	InitializeObjectAttributes (&attr, &dirname,
				    OBJ_CASE_INSENSITIVE, NULL, NULL);
	status = NtOpenFile (&dir, SYNCHRONIZE | FILE_LIST_DIRECTORY,
			     &attr, &io, FILE_SHARE_VALID_FLAGS,
			     FILE_SYNCHRONOUS_IO_NONALERT
			     | FILE_OPEN_FOR_BACKUP_INTENT
			     | FILE_DIRECTORY_FILE);
	if (NT_SUCCESS (status))
	  {
	    status = NtQueryDirectoryFile (dir, NULL, NULL, 0, &io,
					   &fdi, sizeof fdi,
					   FileDirectoryInformation,
					   TRUE, &basename, TRUE);
	    NtClose (dir);
	    if (NT_SUCCESS (status) || status == STATUS_BUFFER_OVERFLOW)
	      return fdi.FileAttributes;
	  }
      }
    SetLastError (RtlNtStatusToDosError (status));
    return INVALID_FILE_ATTRIBUTES;
  }
d854 10
a863 2
  /* Convert an arbitrary path SRC to a pure Win32 path, suitable for
     passing to Win32 API routines.
d865 9
a873 2
     If an error occurs, `error' is set to the errno value.
     Otherwise it is set to 0.
d875 30
a904 6
     follow_mode values:
	  SYMLINK_FOLLOW	    - convert to PATH symlink points to
	  SYMLINK_NOFOLLOW    - convert to PATH of symlink itself
	  SYMLINK_IGNORE	    - do not check PATH for symlinks
	  SYMLINK_CONTENTS    - just return symlink contents
  */
d906 3
a908 12
  /* TODO: This implementation is only preliminary.  For internal
     purposes it's necessary to have a path_conv::check function which
     takes a UNICODE_STRING src path, otherwise we waste a lot of time
     for converting back and forth.  The below implementation does
     realy nothing but converting to char *, until path_conv handles
     wide-char paths directly. */
  void
  path_conv::check (const UNICODE_STRING *src, unsigned opt,
		    const suffix_info *suffixes)
  {
    tmp_pathbuf tp;
    char *path = tp.c_get ();
d910 2
a911 4
    user_shared->warned_msdos = true;
    sys_wcstombs (path, NT_MAX_PATH, src->Buffer, src->Length / sizeof (WCHAR));
    path_conv::check (path, opt, suffixes);
  }
d913 1
a913 15
  void
  path_conv::check (const char *src, unsigned opt,
		    const suffix_info *suffixes)
  {
    /* The tmp_buf array is used when expanding symlinks.  It is NT_MAX_PATH * 2
       in length so that we can hold the expanded symlink plus a trailer.  */
    tmp_pathbuf tp;
    char *path_copy = tp.c_get ();
    char *pathbuf = tp.c_get ();
    char *tmp_buf = tp.t_get ();
    symlink_info sym;
    bool need_directory = 0;
    bool saw_symlinks = 0;
    bool is_relpath;
    char *tail, *path_end;
d915 14
d930 6
a935 8
    static path_conv last_path_conv;
    static char last_src[CYG_MAX_PATH];

    if (*last_src && strcmp (last_src, src) == 0)
      {
	*this = last_path_conv;
	return;
      }
d937 60
d998 9
a1006 20
    myfault efault;
    if (efault.faulted ())
      {
	error = EFAULT;
	return;
      }
    int loop = 0;
    path_flags = 0;
    known_suffix = NULL;
    fileattr = INVALID_FILE_ATTRIBUTES;
    if (wide_path)
      cfree (wide_path);
    wide_path = NULL;
    case_clash = false;
    memset (&dev, 0, sizeof (dev));
    fs.clear ();
    if (!normalized_path_size && normalized_path)
      cfree (normalized_path);
    normalized_path = NULL;
    int component = 0;		// Number of translated components
d1008 1
a1008 7
    if (!(opt & PC_NULLEMPTY))
      error = 0;
    else if (!*src)
      {
	error = ENOENT;
	return;
      }
d1010 1
a1010 17
    bool is_msdos = false;
    /* This loop handles symlink expansion.  */
    for (;;)
      {
	MALLOC_CHECK;
	assert (src);

	is_relpath = !isabspath (src);
	error = normalize_posix_path (src, path_copy, tail);
	if (error > 0)
	  return;
	if (error < 0)
	  {
	    if (component == 0)
	      is_msdos = true;
	    error = 0;
	  }
d1012 8
a1019 9
	/* Detect if the user was looking for a directory.  We have to strip the
	   trailing slash initially while trying to add extensions but take it
	   into account during processing */
	if (tail > path_copy + 2 && isslash (tail[-1]))
	  {
	    need_directory = 1;
	    *--tail = '\0';
	  }
	path_end = tail;
d1021 12
a1032 8
	/* Scan path_copy from right to left looking either for a symlink
	   or an actual existing file.  If an existing file is found, just
	   return.  If a symlink is found, exit the for loop.
	   Also: be careful to preserve the errno returned from
	   symlink.check as the caller may need it. */
	/* FIXME: Do we have to worry about multiple \'s here? */
	component = 0;		// Number of translated components
	sym.contents[0] = '\0';
d1034 22
a1055 1
	int symlen = 0;
d1057 34
a1090 88
	for (unsigned pflags_or = opt & PC_NO_ACCESS_CHECK; ; pflags_or = 0)
	  {
	    const suffix_info *suff;
	    char *full_path;

	    /* Don't allow symlink.check to set anything in the path_conv
	       class if we're working on an inner component of the path */
	    if (component)
	      {
		suff = NULL;
		sym.pflags = 0;
		full_path = pathbuf;
	      }
	    else
	      {
		suff = suffixes;
		sym.pflags = path_flags;
		full_path = this->path;
	      }

	    /* Convert to native path spec sans symbolic link info. */
	    error = mount_table->conv_to_win32_path (path_copy, full_path, dev,
						     &sym.pflags);

	    if (error)
	      return;

	    sym.pflags |= pflags_or;

	    if (dev.major == DEV_CYGDRIVE_MAJOR)
	      {
		if (!component)
		  fileattr = FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_READONLY;
		else
		  {
		    fileattr = getfileattr (this->path, sym.pflags & MOUNT_ENC);
		    dev.devn = FH_FS;
		  }
		goto out;
	      }
	    else if (dev == FH_DEV)
	      {
		dev.devn = FH_FS;
#if 0
		fileattr = getfileattr (this->path, sym.pflags & MOUNT_ENC);
		if (!component && fileattr == INVALID_FILE_ATTRIBUTES)
		  {
		    fileattr = FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_READONLY;
		    goto out;
		  }
#endif
	      }
	    else if (isvirtual_dev (dev.devn))
	      {
		/* FIXME: Calling build_fhandler here is not the right way to handle this. */
		fhandler_virtual *fh = (fhandler_virtual *) build_fh_dev (dev, path_copy);
		int file_type = fh->exists ();
		if (file_type == -2)
		  {
		    fh->fill_filebuf ();
		    symlen = sym.set (fh->get_filebuf ());
		  }
		delete fh;
		switch (file_type)
		  {
		    case 1:
		    case 2:
		      if (component == 0)
			fileattr = FILE_ATTRIBUTE_DIRECTORY;
		      break;
		    case -1:
		      if (component == 0)
			fileattr = 0;
		      break;
		    case -2:	/* /proc/self or /proc/<pid>/symlinks */
		      goto is_virtual_symlink;
		    case -3:	/* /proc/<pid>/fd/pipe:[] */
		      if (component == 0)
			{
			  fileattr = 0;
			  dev.parse (FH_PIPE);
			}
		      break;
		    case -4:	/* /proc/<pid>/fd/socket:[] */
		      if (component == 0)
			{
			  fileattr = 0;
			  dev.parse (FH_TCP);
a1091 89
		      break;
		    default:
		      if (component == 0)
			fileattr = INVALID_FILE_ATTRIBUTES;
		      goto virtual_component_retry;
		  }
		if (component == 0 || dev.devn != FH_NETDRIVE)
		  path_flags |= PATH_RO;
		goto out;
	      }
	    /* devn should not be a device.  If it is, then stop parsing now. */
	    else if (dev.devn != FH_FS)
	      {
		fileattr = 0;
		path_flags = sym.pflags;
		if (component)
		  {
		    error = ENOTDIR;
		    return;
		  }
		goto out;		/* Found a device.  Stop parsing. */
	      }

	    /* If path is only a drivename, Windows interprets it as the
	       current working directory on this drive instead of the root
	       dir which is what we want. So we need the trailing backslash
	       in this case. */
	    if (full_path[0] && full_path[1] == ':' && full_path[2] == '\0')
	      {
		full_path[2] = '\\';
		full_path[3] = '\0';
	      }

	    symlen = sym.check (full_path, suff, opt, fs);

  is_virtual_symlink:

	    if (sym.isdevice)
	      {
		dev.parse (sym.major, sym.minor);
		dev.setfs (1);
		dev.mode = sym.mode;
		fileattr = sym.fileattr;
		goto out;
	      }

	    if (sym.pflags & PATH_SOCKET)
	      {
		if (component)
		  {
		    error = ENOTDIR;
		    return;
		  }
		fileattr = sym.fileattr;
		dev.parse (FH_UNIX);
		dev.setfs (1);
		goto out;
	      }

	    if (sym.case_clash)
	      {
		if (pcheck_case == PCHECK_STRICT)
		  {
		    case_clash = true;
		    error = ENOENT;
		    goto out;
		  }
		/* If pcheck_case==PCHECK_ADJUST the case_clash is remembered
		   if the last component is concerned. This allows functions
		   which shall create files to avoid overriding already existing
		   files with another case. */
		if (!component)
		  case_clash = true;
	      }
	    if (!(opt & PC_SYM_IGNORE))
	      {
		if (!component)
		  {
		    fileattr = sym.fileattr;
		    path_flags = sym.pflags;
		  }

		/* If symlink.check found an existing non-symlink file, then
		   it sets the appropriate flag.  It also sets any suffix found
		   into `ext_here'. */
		if (!sym.issymlink && sym.fileattr != INVALID_FILE_ATTRIBUTES)
		  {
		    error = sym.error;
		    if (component == 0)
d1093 1
a1093 3
		    else if (!(sym.fileattr & FILE_ATTRIBUTE_DIRECTORY))
		      {
			error = ENOTDIR;
d1095 14
a1108 40
		      }
		    if (pcheck_case == PCHECK_RELAXED)
		      goto out;	// file found
		    /* Avoid further symlink evaluation. Only case checks are
		       done now. */
		    opt |= PC_SYM_IGNORE;
		  }
		/* Found a symlink if symlen > 0.  If component == 0, then the
		   src path itself was a symlink.  If !follow_mode then
		   we're done.  Otherwise we have to insert the path found
		   into the full path that we are building and perform all of
		   these operations again on the newly derived path. */
		else if (symlen > 0)
		  {
		    saw_symlinks = 1;
		    if (component == 0 && !need_directory && !(opt & PC_SYM_FOLLOW))
		      {
			set_symlink (symlen); // last component of path is a symlink.
			if (opt & PC_SYM_CONTENTS)
			  {
			    strcpy (path, sym.contents);
			    goto out;
			  }
			add_ext_from_sym (sym);
			if (pcheck_case == PCHECK_RELAXED)
			  goto out;
			/* Avoid further symlink evaluation. Only case checks are
			   done now. */
			opt |= PC_SYM_IGNORE;
		      }
		    else
		      break;
		  }
		else if (sym.error && sym.error != ENOENT && sym.error != ENOSHARE)
		  {
		    error = sym.error;
		    goto out;
		  }
		/* No existing file found. */
	      }
d1110 16
a1125 10
  virtual_component_retry:
	    /* Find the new "tail" of the path, e.g. in '/for/bar/baz',
	       /baz is the tail. */
	    if (tail != path_end)
	      *tail = '/';
	    while (--tail > path_copy + 1 && *tail != '/') {}
	    /* Exit loop if there is no tail or we are at the
	       beginning of a UNC path */
	    if (tail <= path_copy + 1)
	      goto out;	// all done
d1127 6
a1132 5
	    /* Haven't found an existing pathname component yet.
	       Pinch off the tail and try again. */
	    *tail = '\0';
	    component++;
	  }
d1134 1
a1134 6
	/* Arrive here if above loop detected a symlink. */
	if (++loop > SYMLOOP_MAX)
	  {
	    error = ELOOP;   // Eep.
	    return;
	  }
a1135 1
	MALLOC_CHECK;
d1137 1
d1139 12
a1150 1
	/* Place the link content, possibly with head and/or tail, in tmp_buf */
d1152 8
a1159 21
	char *headptr;
	if (isabspath (sym.contents))
	  headptr = tmp_buf;	/* absolute path */
	else
	  {
	    /* Copy the first part of the path (with ending /) and point to the end. */
	    char *prevtail = tail;
	    while (--prevtail > path_copy  && *prevtail != '/') {}
	    int headlen = prevtail - path_copy + 1;;
	    memcpy (tmp_buf, path_copy, headlen);
	    headptr = &tmp_buf[headlen];
	  }

	/* Make sure there is enough space */
	if (headptr + symlen >= tmp_buf + (2 * NT_MAX_PATH))
	  {
	  too_long:
	    error = ENAMETOOLONG;
	    strcpy (path, "::ENAMETOOLONG::");
	    return;
	  }
d1161 16
a1176 829
       /* Copy the symlink contents to the end of tmp_buf.
	  Convert slashes. */
	for (char *p = sym.contents; *p; p++)
	  *headptr++ = *p == '\\' ? '/' : *p;
	*headptr = '\0';

	/* Copy any tail component (with the 0) */
	if (tail++ < path_end)
	  {
	    /* Add a slash if needed. There is space. */
	    if (*(headptr - 1) != '/')
	      *headptr++ = '/';
	    int taillen = path_end - tail + 1;
	    if (headptr + taillen > tmp_buf + (2 * NT_MAX_PATH))
	      goto too_long;
	    memcpy (headptr, tail, taillen);
	  }

	/* Evaluate everything all over again. */
	src = tmp_buf;
      }

    if (!(opt & PC_SYM_CONTENTS))
      add_ext_from_sym (sym);

  out:
    if (dev.devn == FH_NETDRIVE && component)
      {
	/* This case indicates a non-existant resp. a non-retrievable
	   share.  This happens for instance if the share is a printer.
	   In this case the path must not be treated like a FH_NETDRIVE,
	   but like a FH_FS instead, so the usual open call for files
	   is used on it. */
	dev.parse (FH_FS);
      }
    else if (isvirtual_dev (dev.devn) && fileattr == INVALID_FILE_ATTRIBUTES)
      {
	error = dev.devn == FH_NETDRIVE ? ENOSHARE : ENOENT;
	return;
      }
    else if (!need_directory || error)
      /* nothing to do */;
    else if (fileattr == INVALID_FILE_ATTRIBUTES)
      strcat (path, "\\"); /* Reattach trailing dirsep in native path. */
    else if (fileattr & FILE_ATTRIBUTE_DIRECTORY)
      path_flags &= ~PATH_SYMLINK;
    else
      {
	debug_printf ("%s is a non-directory", path);
	error = ENOTDIR;
	return;
      }

    if (dev.isfs ())
      {
	if (strncmp (path, "\\\\.\\", 4))
	  {
	    if (!tail || tail == path)
	      /* nothing */;
	    else if (tail[-1] != '\\')
	      *tail = '\0';
	    else
	      {
		error = ENOENT;
		return;
	      }
	  }

	/* FS has been checked already for existing files. */
	if (exists () || fs.update (get_nt_native_path (), NULL))
	  {
	    debug_printf ("this->path(%s), has_acls(%d)", path, fs.has_acls ());
	    if (fs.has_acls () && allow_ntsec)
	      set_exec (0);  /* We really don't know if this is executable or not here
				but set it to not executable since it will be figured out
				later by anything which cares about this. */
	  }
	if (exec_state () != dont_know_if_executable)
	  /* ok */;
	else if (isdir ())
	  set_exec (1);
	else if (issymlink () || issocket ())
	  set_exec (0);
      }

    if (opt & PC_NOFULL)
      {
	if (is_relpath)
	  mkrelpath (this->path);
	if (need_directory)
	  {
	    size_t n = strlen (this->path);
	    /* Do not add trailing \ to UNC device names like \\.\a: */
	    if (this->path[n - 1] != '\\' &&
		(strncmp (this->path, "\\\\.\\", 4) != 0))
	      {
		this->path[n] = '\\';
		this->path[n + 1] = '\0';
	      }
	  }
      }

    if (saw_symlinks)
      set_has_symlinks ();

    if (!error && !isdir () && !(path_flags & PATH_ALL_EXEC))
      {
	const char *p = strchr (path, '\0') - 4;
	if (p >= path &&
	    (ascii_strcasematch (".exe", p) ||
	     ascii_strcasematch (".bat", p) ||
	     ascii_strcasematch (".com", p)))
	  path_flags |= PATH_EXEC;
      }

    if (!(opt & PC_POSIX))
      normalized_path_size = 0;
    else
      {
	if (tail < path_end && tail > path_copy + 1)
	  *tail = '/';
	set_normalized_path (path_copy);
	if (is_msdos && !(opt & PC_NOWARN))
	  warn_msdos (src);
      }

#if 0
    if (!error)
      {
	last_path_conv = *this;
	strcpy (last_src, src);
      }
#endif
  }

  path_conv::~path_conv ()
  {
    if (!normalized_path_size && normalized_path)
      {
	cfree (normalized_path);
	normalized_path = NULL;
      }
    if (wide_path)
      {
	cfree (wide_path);
	wide_path = NULL;
      }
  }

  bool
  path_conv::is_binary ()
  {
    tmp_pathbuf tp;
    PWCHAR bintest = tp.w_get ();
    DWORD bin;
    return exec_state () == is_executable
	   && RtlEqualUnicodePathSuffix (get_nt_native_path (), L".exe", TRUE)
	   && GetBinaryTypeW (get_wide_win32_path (bintest), &bin);
  }

  /* Normalize a Win32 path.
     /'s are converted to \'s in the process.
     All duplicate \'s, except for 2 leading \'s, are deleted.

     The result is 0 for success, or an errno error value.
     FIXME: A lot of this should be mergeable with the POSIX critter.  */
  int
  normalize_win32_path (const char *src, char *dst, char *&tail)
  {
    const char *src_start = src;
    bool beg_src_slash = isdirsep (src[0]);

    tail = dst;
    /* Skip long path name prefixes in Win32 or NT syntax. */
    if (beg_src_slash && (src[1] == '?' || isdirsep (src[1]))
	&& src[2] == '?' && isdirsep (src[3]))
      {
	src += 4;
	if (src[1] != ':') /* native UNC path */
	  {
	    src += 2; /* Fortunately the first char is not copied... */
	    beg_src_slash = true;
	  }
	else
	  beg_src_slash = isdirsep (src[0]);
      }
    if (beg_src_slash && isdirsep (src[1]))
      {
	if (isdirsep (src[2]))
	  {
	    /* More than two slashes are just folded into one. */
	    src += 2;
	    while (isdirsep (src[1]))
	      ++src;
	  }
	else
	  {
	    /* Two slashes start a network or device path. */
	    *tail++ = '\\';
	    src++;
	    if (src[1] == '.' && isdirsep (src[2]))
	      {
		*tail++ = '\\';
		*tail++ = '.';
		src += 2;
	      }
	  }
      }
    if (tail == dst && !isdrive (src) && *src != '/')
      {
	if (beg_src_slash)
	  tail += cygheap->cwd.get_drive (dst);
	else if (!cygheap->cwd.get (dst, 0))
	  return get_errno ();
	else
	  {
	    tail = strchr (tail, '\0');
	    *tail++ = '\\';
	  }
      }

    while (*src)
      {
	/* Strip duplicate /'s.  */
	if (isdirsep (src[0]) && isdirsep (src[1]))
	  src++;
	/* Ignore "./".  */
	else if (src[0] == '.' && isdirsep (src[1])
		 && (src == src_start || isdirsep (src[-1])))
	  src += 2;

	/* Backup if "..".  */
	else if (src[0] == '.' && src[1] == '.'
		 /* dst must be greater than dst_start */
		 && tail[-1] == '\\')
	  {
	    if (!isdirsep (src[2]) && src[2] != '\0')
		*tail++ = *src++;
	    else
	      {
		/* Back up over /, but not if it's the first one.  */
		if (tail > dst + 1)
		  tail--;
		/* Now back up to the next /.  */
		while (tail > dst + 1 && tail[-1] != '\\' && tail[-2] != ':')
		  tail--;
		src += 2;
		if (isdirsep (*src))
		  src++;
	      }
	  }
	/* Otherwise, add char to result.  */
	else
	  {
	    if (*src == '/')
	      *tail++ = '\\';
	    else
	      *tail++ = *src;
	    src++;
	  }
	if ((tail - dst) >= NT_MAX_PATH)
	  return ENAMETOOLONG;
      }
     if (tail > dst + 1 && tail[-1] == '.' && tail[-2] == '\\')
       tail--;
    *tail = '\0';
    debug_printf ("%s = normalize_win32_path (%s)", dst, src_start);
    return 0;
  }

  /* Various utilities.  */

  /* nofinalslash: Remove trailing / and \ from SRC (except for the
     first one).  It is ok for src == dst.  */

  void __stdcall
  nofinalslash (const char *src, char *dst)
  {
    int len = strlen (src);
    if (src != dst)
      memcpy (dst, src, len + 1);
    while (len > 1 && isdirsep (dst[--len]))
      dst[len] = '\0';
  }

  /* conv_path_list: Convert a list of path names to/from Win32/POSIX. */

  static int
  conv_path_list (const char *src, char *dst, size_t size, int to_posix)
  {
    tmp_pathbuf tp;
    char src_delim, dst_delim;
    cygwin_conv_path_t conv_fn;
    size_t len;

    if (to_posix)
      {
	src_delim = ';';
	dst_delim = ':';
	conv_fn = CCP_WIN_A_TO_POSIX | CCP_RELATIVE;
      }
    else
      {
	src_delim = ':';
	dst_delim = ';';
	conv_fn = CCP_POSIX_TO_WIN_A | CCP_RELATIVE;
      }

    char *srcbuf;
    len = strlen (src) + 1;
    if (len <= NT_MAX_PATH * sizeof (WCHAR))
      srcbuf = (char *) tp.w_get ();
    else
      srcbuf = (char *) alloca (len);

    int err = 0;
    char *d = dst - 1;
    bool saw_empty = false;
    do
      {
	char *s = strccpy (srcbuf, &src, src_delim);
	size_t len = s - srcbuf;
	if (len >= NT_MAX_PATH)
	  {
	    err = ENAMETOOLONG;
	    break;
	  }
	if (len)
	  {
	    ++d;
	    err = cygwin_conv_path (conv_fn, srcbuf, d, size - (d - dst));
	  }
	else if (!to_posix)
	  {
	    ++d;
	    err = cygwin_conv_path (conv_fn, ".", d, size - (d - dst));
	  }
	else
	  {
	    if (to_posix == ENV_CVT)
	      saw_empty = true;
	    continue;
	  }
	if (err)
	  break;
	d = strchr (d, '\0');
	*d = dst_delim;
      }
    while (*src++);

    if (saw_empty)
      err = EIDRM;

    if (d < dst)
      d++;
    *d = '\0';
    return err;
  }

  /********************** Symbolic Link Support **************************/

  /* Create a symlink from FROMPATH to TOPATH. */

  /* If TRUE create symlinks as Windows shortcuts, if false create symlinks
     as normal files with magic number and system bit set. */
  bool allow_winsymlinks = true;

  extern "C" int
  symlink (const char *oldpath, const char *newpath)
  {
    return symlink_worker (oldpath, newpath, allow_winsymlinks, false);
  }

  int
  symlink_worker (const char *oldpath, const char *newpath, bool use_winsym,
		  bool isdevice)
  {
    int res = -1;
    size_t len;
    path_conv win32_newpath, win32_oldpath;
    char *buf, *cp;
    SECURITY_ATTRIBUTES sa = sec_none_nih;
    security_descriptor sd;
    OBJECT_ATTRIBUTES attr;
    IO_STATUS_BLOCK io;
    NTSTATUS status;
    HANDLE fh;
    FILE_BASIC_INFORMATION fbi;
    tmp_pathbuf tp;

    /* POSIX says that empty 'newpath' is invalid input while empty
       'oldpath' is valid -- it's symlink resolver job to verify if
       symlink contents point to existing filesystem object */
    myfault efault;
    if (efault.faulted (EFAULT))
      goto done;
    if (!*oldpath || !*newpath)
      {
	set_errno (ENOENT);
	goto done;
      }

    if (strlen (oldpath) > SYMLINK_MAX)
      {
	set_errno (ENAMETOOLONG);
	goto done;
      }

    len = strlen (newpath);
    /* Trailing dirsep is a no-no. */
    if (isdirsep (newpath[len - 1]))
      {
	set_errno (ENOENT);
	goto done;
      }
    /* We need the normalized full path below. */
    win32_newpath.check (newpath, PC_SYM_NOFOLLOW | PC_POSIX, stat_suffixes);
    if (use_winsym && !win32_newpath.exists ()
	&& (isdevice || !win32_newpath.fs_is_nfs ()))
      {
	char *newplnk = tp.c_get ();
	stpcpy (stpcpy (newplnk, newpath), ".lnk");
	win32_newpath.check (newplnk, PC_SYM_NOFOLLOW | PC_POSIX);
      }

    if (win32_newpath.error)
      {
	set_errno (win32_newpath.case_clash ? ECASECLASH : win32_newpath.error);
	goto done;
      }

    syscall_printf ("symlink (%s, %S)", oldpath,
		    win32_newpath.get_nt_native_path ());

    if ((!isdevice && win32_newpath.exists ())
	|| win32_newpath.is_auto_device ())
      {
	set_errno (EEXIST);
	goto done;
      }

    if (!isdevice && win32_newpath.fs_is_nfs ())
      {
	/* On NFS, create symlinks by calling NtCreateFile with an EA of type
	   NfsSymlinkTargetName containing ... the symlink target name. */
	PFILE_FULL_EA_INFORMATION pffei = (PFILE_FULL_EA_INFORMATION) tp.w_get ();
	pffei->NextEntryOffset = 0;
	pffei->Flags = 0;
	pffei->EaNameLength = sizeof (NFS_SYML_TARGET) - 1;
	char *EaValue = stpcpy (pffei->EaName, NFS_SYML_TARGET) + 1;
	pffei->EaValueLength = sizeof (WCHAR) *
	  (sys_mbstowcs ((PWCHAR) EaValue, NT_MAX_PATH, oldpath) - 1);
	status = NtCreateFile (&fh, FILE_WRITE_DATA | FILE_WRITE_EA | SYNCHRONIZE,
			       win32_newpath.get_object_attr (attr, sa),
			       &io, NULL, FILE_ATTRIBUTE_SYSTEM,
			       FILE_SHARE_VALID_FLAGS, FILE_CREATE,
			       FILE_SYNCHRONOUS_IO_NONALERT
			       | FILE_OPEN_FOR_BACKUP_INTENT,
			       pffei, NT_MAX_PATH * sizeof (WCHAR));
	if (!NT_SUCCESS (status))
	  {
	    __seterrno_from_nt_status (status);
	    goto done;
	  }
	NtClose (fh);
	res = 0;
	goto done;
      }

    if (use_winsym)
      {
	ITEMIDLIST *pidl = NULL;
	size_t full_len = 0;
	unsigned short oldpath_len, desc_len, relpath_len, pidl_len = 0;
	char desc[MAX_PATH + 1], *relpath;

	if (!isdevice)
	  {
	    /* First create an IDLIST to learn how big our shortcut is
	       going to be. */
	    IShellFolder *psl;

	    /* The symlink target is relative to the directory in which
	       the symlink gets created, not relative to the cwd.  Therefore
	       we have to mangle the path quite a bit before calling path_conv. */
	    if (!isabspath (oldpath))
	      {
		len = strrchr (win32_newpath.normalized_path, '/')
		      - win32_newpath.normalized_path + 1;
		char *absoldpath = tp.t_get ();
		stpcpy (stpncpy (absoldpath, win32_newpath.normalized_path, len),
			oldpath);
		win32_oldpath.check (absoldpath, PC_SYM_NOFOLLOW, stat_suffixes);
	      }
	    else
	      win32_oldpath.check (oldpath, PC_SYM_NOFOLLOW, stat_suffixes);
	    if (SUCCEEDED (SHGetDesktopFolder (&psl)))
	      {
		WCHAR wc_path[win32_oldpath.get_wide_win32_path_len () + 1];
		win32_oldpath.get_wide_win32_path (wc_path);
		/* Amazing but true:  Even though the ParseDisplayName method
		   takes a wide char path name, it does not understand the
		   Win32 prefix for long pathnames!  So we have to tack off
		   the prefix and convert the path to the "normal" syntax
		   for ParseDisplayName.  */
		WCHAR *wc = wc_path + 4;
		if (wc[1] != L':') /* native UNC path */
		  *(wc += 2) = L'\\';
		HRESULT res;
		if (SUCCEEDED (res = psl->ParseDisplayName (NULL, NULL, wc, NULL,
						      &pidl, NULL)))
		  {
		    ITEMIDLIST *p;

		    for (p = pidl; p->mkid.cb > 0;
			 p = (ITEMIDLIST *)((char *) p + p->mkid.cb))
		      ;
		    pidl_len = (char *) p - (char *) pidl + 2;
		  }
		psl->Release ();
	      }
	  }
	/* Compute size of shortcut file. */
	full_len = sizeof (win_shortcut_hdr);
	if (pidl_len)
	  full_len += sizeof (unsigned short) + pidl_len;
	oldpath_len = strlen (oldpath);
	/* Unfortunately the length of the description is restricted to a
	   length of MAX_PATH up to NT4, and to a length of 2000 bytes
	   since W2K.  We don't want to add considerations for the different
	   lengths and even 2000 bytes is not enough for long path names.
	   So what we do here is to set the description to the POSIX path
	   only if the path is not longer than MAX_PATH characters.  We
	   append the full path name after the regular shortcut data
	   (see below), which works fine with Windows Explorer as well
	   as older Cygwin versions (as long as the whole file isn't bigger
	   than 8K).  The description field is only used for backward
	   compatibility to older Cygwin versions and those versions are
	   not capable of handling long path names anyway. */
	desc_len = stpcpy (desc, oldpath_len > MAX_PATH
				 ? "[path too long]" : oldpath) - desc;
	full_len += sizeof (unsigned short) + desc_len;
	/* Devices get the oldpath string unchanged as relative path. */
	if (isdevice)
	  {
	    relpath_len = oldpath_len;
	    stpcpy (relpath = tp.c_get (), oldpath);
	  }
	else
	  {
	    relpath_len = strlen (win32_oldpath.get_win32 ());
	    stpcpy (relpath = tp.c_get (), win32_oldpath.get_win32 ());
	  }
	full_len += sizeof (unsigned short) + relpath_len;
	full_len += sizeof (unsigned short) + oldpath_len;
	/* 1 byte more for trailing 0 written by stpcpy. */
	if (full_len < NT_MAX_PATH * sizeof (WCHAR))
	  buf = (char *) tp.w_get ();
	else
	  buf = (char *) alloca (full_len + 1);

	/* Create shortcut header */
	win_shortcut_hdr *shortcut_header = (win_shortcut_hdr *) buf;
	memset (shortcut_header, 0, sizeof *shortcut_header);
	shortcut_header->size = sizeof *shortcut_header;
	shortcut_header->magic = GUID_shortcut;
	shortcut_header->flags = (WSH_FLAG_DESC | WSH_FLAG_RELPATH);
	if (pidl)
	  shortcut_header->flags |= WSH_FLAG_IDLIST;
	shortcut_header->run = SW_NORMAL;
	cp = buf + sizeof (win_shortcut_hdr);

	/* Create IDLIST */
	if (pidl)
	  {
	    *(unsigned short *)cp = pidl_len;
	    memcpy (cp += 2, pidl, pidl_len);
	    cp += pidl_len;
	    CoTaskMemFree (pidl);
	  }

	/* Create description */
	*(unsigned short *)cp = desc_len;
	cp = stpcpy (cp += 2, desc);

	/* Create relpath */
	*(unsigned short *)cp = relpath_len;
	cp = stpcpy (cp += 2, relpath);

	/* Append the POSIX path after the regular shortcut data for
	   the long path support. */
	*(unsigned short *)cp = oldpath_len;
	cp = stpcpy (cp += 2, oldpath);
      }
    else
      {
	/* This is the old technique creating a symlink. */
	buf = tp.c_get ();
	/* Note that the terminating nul is written.  */
	cp = stpcpy (stpcpy (buf, SYMLINK_COOKIE), oldpath) + 1;
      }

    if (isdevice && win32_newpath.exists ())
      {
	status = NtOpenFile (&fh, FILE_WRITE_ATTRIBUTES,
			     win32_newpath.get_object_attr (attr, sa),
			     &io, 0, FILE_OPEN_FOR_BACKUP_INTENT);
	if (!NT_SUCCESS (status))
	  {
	    __seterrno_from_nt_status (status);
	    goto done;
	  }
	fbi.CreationTime.QuadPart = fbi.LastAccessTime.QuadPart
	= fbi.LastWriteTime.QuadPart = fbi.ChangeTime.QuadPart = 0LL;
	fbi.FileAttributes = FILE_ATTRIBUTE_NORMAL;
	status = NtSetInformationFile (fh, &io, &fbi, sizeof fbi,
				       FileBasicInformation);
	NtClose (fh);
	if (!NT_SUCCESS (status))
	  {
	    __seterrno_from_nt_status (status);
	    goto done;
	  }
      }
    if (allow_ntsec && win32_newpath.has_acls ())
      set_security_attribute (S_IFLNK | STD_RBITS | STD_WBITS,
			      &sa, sd);
    status = NtCreateFile (&fh, DELETE | FILE_GENERIC_WRITE,
			   win32_newpath.get_object_attr (attr, sa),
			   &io, NULL, FILE_ATTRIBUTE_NORMAL,
			   FILE_SHARE_VALID_FLAGS,
			   isdevice ? FILE_OVERWRITE_IF : FILE_CREATE,
			   FILE_SYNCHRONOUS_IO_NONALERT
			   | FILE_NON_DIRECTORY_FILE
			   | FILE_OPEN_FOR_BACKUP_INTENT,
			   NULL, 0);
    if (!NT_SUCCESS (status))
      {
	__seterrno_from_nt_status (status);
	goto done;
      }
    status = NtWriteFile (fh, NULL, NULL, NULL, &io, buf, cp - buf, NULL, NULL);
    if (NT_SUCCESS (status) && io.Information == (ULONG) (cp - buf))
      {
	fbi.CreationTime.QuadPart = fbi.LastAccessTime.QuadPart
	= fbi.LastWriteTime.QuadPart = fbi.ChangeTime.QuadPart = 0LL;
	fbi.FileAttributes = use_winsym ? FILE_ATTRIBUTE_READONLY
					: FILE_ATTRIBUTE_SYSTEM;
	status = NtSetInformationFile (fh, &io, &fbi, sizeof fbi,
				       FileBasicInformation);
	if (!NT_SUCCESS (status))
	  debug_printf ("Setting attributes failed, status = %p", status);
	res = 0;
      }
    else
      {
	__seterrno_from_nt_status (status);
	FILE_DISPOSITION_INFORMATION fdi = { TRUE };
	status = NtSetInformationFile (fh, &io, &fdi, sizeof fdi,
				       FileDispositionInformation);
	if (!NT_SUCCESS (status))
	  debug_printf ("Setting delete dispostion failed, status = %p", status);
      }
    NtClose (fh);

  done:
    syscall_printf ("%d = symlink_worker (%s, %s, %d, %d)", res, oldpath,
		    newpath, use_winsym, isdevice);
    return res;
  }

  static bool
  cmp_shortcut_header (win_shortcut_hdr *file_header)
  {
    /* A Cygwin or U/Win shortcut only contains a description and a relpath.
       Cygwin shortcuts also might contain an ITEMIDLIST. The run type is
       always set to SW_NORMAL. */
    return file_header->size == sizeof (win_shortcut_hdr)
	&& !memcmp (&file_header->magic, &GUID_shortcut, sizeof GUID_shortcut)
	&& (file_header->flags & ~WSH_FLAG_IDLIST)
	   == (WSH_FLAG_DESC | WSH_FLAG_RELPATH)
	&& file_header->run == SW_NORMAL;
  }

  int
  symlink_info::check_shortcut (HANDLE in_h)
  {
    tmp_pathbuf tp;
    win_shortcut_hdr *file_header;
    char *buf, *cp;
    unsigned short len;
    int res = 0;
    UNICODE_STRING same = { 0, 0, (PWCHAR) L"" };
    OBJECT_ATTRIBUTES attr;
    NTSTATUS status;
    HANDLE h;
    IO_STATUS_BLOCK io;
    FILE_STANDARD_INFORMATION fsi;

    InitializeObjectAttributes (&attr, &same, 0, in_h, NULL);
    status = NtOpenFile (&h, FILE_READ_DATA | SYNCHRONIZE,
			 &attr, &io, FILE_SHARE_VALID_FLAGS,
			 FILE_OPEN_FOR_BACKUP_INTENT
			 | FILE_SYNCHRONOUS_IO_NONALERT);
    if (!NT_SUCCESS (status))
      {
	set_error (EIO);
	return 0;
      }
    status = NtQueryInformationFile (h, &io, &fsi, sizeof fsi,
				     FileStandardInformation);
    if (!NT_SUCCESS (status))
      {
	set_error (EIO);
	goto out;
      }
    if (fsi.EndOfFile.QuadPart <= sizeof (win_shortcut_hdr)
	|| fsi.EndOfFile.QuadPart > 4 * 65536)
      goto out;
    if (fsi.EndOfFile.LowPart < NT_MAX_PATH * sizeof (WCHAR))
      buf = (char *) tp.w_get ();
    else
      buf = (char *) alloca (fsi.EndOfFile.LowPart + 1);
    if (!NT_SUCCESS (NtReadFile (h, NULL, NULL, NULL,
				 &io, buf, fsi.EndOfFile.LowPart, NULL, NULL)))
      {
	set_error (EIO);
	goto out;
      }
    file_header = (win_shortcut_hdr *) buf;
    if (io.Information != fsi.EndOfFile.LowPart
	|| !cmp_shortcut_header (file_header))
      goto file_not_symlink;
    cp = buf + sizeof (win_shortcut_hdr);
    if (file_header->flags & WSH_FLAG_IDLIST) /* Skip ITEMIDLIST */
      cp += *(unsigned short *) cp + 2;
    if (!(len = *(unsigned short *) cp))
      goto file_not_symlink;
    cp += 2;
    /* Check if this is a device file - these start with the sequence :\\ */
    if (strncmp (cp, ":\\", 2) == 0)
      res = strlen (strcpy (contents, cp)); /* Don't mess with device files */
    else
      {
	/* Has appended full path?  If so, use it instead of description. */
	unsigned short relpath_len = *(unsigned short *) (cp + len);
	if (cp + len + 2 + relpath_len < buf + fsi.EndOfFile.LowPart)
	  {
	    cp += len + 2 + relpath_len;
	    len = *(unsigned short *) cp;
	    cp += 2;
	  }
	if (len > SYMLINK_MAX)
	  goto file_not_symlink;
	cp[len] = '\0';
	res = posixify (cp);
      }
    if (res) /* It's a symlink.  */
      pflags = PATH_SYMLINK | PATH_LNK;
    return res;

  file_not_symlink:
    /* Not a symlink, see if executable.  */
    if (!(pflags & PATH_ALL_EXEC) && has_exec_chars ((const char *) &file_header, io.Information))
      pflags |= PATH_EXEC;

  out:
    NtClose (h);
    return 0;
  }

  int
  symlink_info::check_sysfile (HANDLE in_h)
  {
    char cookie_buf[sizeof (SYMLINK_COOKIE) - 1];
    char srcbuf[SYMLINK_MAX + 2];
    int res = 0;
    UNICODE_STRING same = { 0, 0, (PWCHAR) L"" };
    OBJECT_ATTRIBUTES attr;
    NTSTATUS status;
    HANDLE h;
    IO_STATUS_BLOCK io;

    InitializeObjectAttributes (&attr, &same, 0, in_h, NULL);
    status = NtOpenFile (&h, FILE_READ_DATA | SYNCHRONIZE,
			 &attr, &io, FILE_SHARE_VALID_FLAGS,
			 FILE_OPEN_FOR_BACKUP_INTENT
			 | FILE_SYNCHRONOUS_IO_NONALERT);
    if (!NT_SUCCESS (status))
      set_error (EIO);
    else if (!NT_SUCCESS (status = NtReadFile (h, NULL, NULL, NULL, &io,
					       cookie_buf, sizeof (cookie_buf),
					       NULL, NULL)))
      {
	debug_printf ("ReadFile1 failed");
	if (status != STATUS_END_OF_FILE)
	  set_error (EIO);
      }
    else if (io.Information == sizeof (cookie_buf)
	     && memcmp (cookie_buf, SYMLINK_COOKIE, sizeof (cookie_buf)) == 0)
      {
	/* It's a symlink.  */
	pflags = PATH_SYMLINK;

	status = NtReadFile (h, NULL, NULL, NULL, &io, srcbuf,
			     SYMLINK_MAX + 2, NULL, NULL);
	if (!NT_SUCCESS (status))
	  {
	    debug_printf ("ReadFile2 failed");
	    if (status != STATUS_END_OF_FILE)
	      set_error (EIO);
	  }
	else if (io.Information > SYMLINK_MAX + 1)
	  debug_printf ("symlink string too long");
	else
	  res = posixify (srcbuf);
      }
    else if (io.Information == sizeof (cookie_buf)
	     && memcmp (cookie_buf, SOCKET_COOKIE, sizeof (cookie_buf)) == 0)
      pflags |= PATH_SOCKET;
    else
      {
	/* Not a symlink, see if executable.  */
	if (pflags & PATH_ALL_EXEC)
	  /* Nothing to do */;
	else if (has_exec_chars (cookie_buf, io.Information))
	  pflags |= PATH_EXEC;
	else
	  pflags |= PATH_NOTEXEC;
a1177 3
    NtClose (h);
    return res;
  }
d1179 3
a1181 44
  int
  symlink_info::check_reparse_point (HANDLE h)
  {
    tmp_pathbuf tp;
    NTSTATUS status;
    IO_STATUS_BLOCK io;
    PREPARSE_DATA_BUFFER rp = (PREPARSE_DATA_BUFFER) tp.c_get ();
    char srcbuf[SYMLINK_MAX + 7];

    status = NtFsControlFile (h, NULL, NULL, NULL, &io, FSCTL_GET_REPARSE_POINT,
			      NULL, 0, (LPVOID) rp,
			      MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
    if (!NT_SUCCESS (status))
      {
	debug_printf ("NtFsControlFile(FSCTL_GET_REPARSE_POINT) failed, %p",
		      status);
	set_error (EIO);
	return 0;
      }
    if (rp->ReparseTag == IO_REPARSE_TAG_SYMLINK)
      {
	sys_wcstombs (srcbuf, SYMLINK_MAX + 1,
		      (WCHAR *)((char *)rp->SymbolicLinkReparseBuffer.PathBuffer
			    + rp->SymbolicLinkReparseBuffer.SubstituteNameOffset),
		      rp->SymbolicLinkReparseBuffer.SubstituteNameLength / sizeof (WCHAR));
	pflags = PATH_SYMLINK | PATH_REP;
	fileattr &= ~FILE_ATTRIBUTE_DIRECTORY;
      }
    else if (rp->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)
      {
	if (rp->SymbolicLinkReparseBuffer.PrintNameLength == 0)
	  {
	    /* Likely a volume mount point.  Not treated as symlink. */
	    return 0;
	  }
	sys_wcstombs (srcbuf, SYMLINK_MAX + 1,
		      (WCHAR *)((char *)rp->MountPointReparseBuffer.PathBuffer
			      + rp->MountPointReparseBuffer.SubstituteNameOffset),
		      rp->MountPointReparseBuffer.SubstituteNameLength / sizeof (WCHAR));
	pflags = PATH_SYMLINK | PATH_REP;
	fileattr &= ~FILE_ATTRIBUTE_DIRECTORY;
      }
    return posixify (srcbuf);
  }
d1183 2
a1184 31
  int
  symlink_info::check_nfs_symlink (HANDLE h)
  {
    tmp_pathbuf tp;
    NTSTATUS status;
    IO_STATUS_BLOCK io;
    struct {
      FILE_GET_EA_INFORMATION fgei;
      char buf[sizeof (NFS_SYML_TARGET)];
    } fgei_buf;
    PFILE_FULL_EA_INFORMATION pffei;
    int res = 0;

    /* To find out if the file is a symlink and to get the symlink target,
       try to fetch the NfsSymlinkTargetName EA. */
    fgei_buf.fgei.NextEntryOffset = 0;
    fgei_buf.fgei.EaNameLength = sizeof (NFS_SYML_TARGET) - 1;
    stpcpy (fgei_buf.fgei.EaName, NFS_SYML_TARGET);
    pffei = (PFILE_FULL_EA_INFORMATION) tp.w_get ();
    status = NtQueryEaFile (h, &io, pffei, NT_MAX_PATH * sizeof (WCHAR), TRUE,
			    &fgei_buf.fgei, sizeof fgei_buf, NULL, TRUE);
    if (NT_SUCCESS (status) && pffei->EaValueLength > 0)
      {
	PWCHAR spath = (PWCHAR)
		       (pffei->EaName + pffei->EaNameLength + 1);
	res = sys_wcstombs (contents, SYMLINK_MAX + 1,
			spath, pffei->EaValueLength);
	pflags = PATH_SYMLINK;
      }
    return res;
  }
d1186 27
a1212 39
  int
  symlink_info::posixify (char *srcbuf)
  {
    /* The definition for a path in a native symlink is a bit weird.  The Flags
       value seem to contain 0 for absolute paths (stored as NT native path)
       and 1 for relative paths.  Relative paths are paths not starting with a
       drive letter.  These are not converted to NT native, but stored as
       given.  A path starting with a single backslash is relative to the
       current drive thus a "relative" value (Flags == 1).
       Funny enough it's possible to store paths with slashes instead of
       backslashes, but they are evaluated incorrectly by subsequent Windows
       calls like CreateFile (ERROR_INVALID_NAME).  So, what we do here is to
       take paths starting with slashes at face value, evaluating them as
       Cygwin specific POSIX paths.
       A path starting with two slashes(!) or backslashes is converted into an
       NT UNC path.  Unfortunately, in contrast to POSIX rules, paths starting
       with three or more (back)slashes are also converted into UNC paths,
       just incorrectly sticking to one redundant leading backslashe.  We go
       along with this behaviour to avoid scenarios in which native tools access
       other files than Cygwin.
       The above rules are used exactly the same way on Cygwin specific symlinks
       (sysfiles and shortcuts) to eliminate non-POSIX paths in the output. */

    /* Eliminate native NT prefixes. */
    if (srcbuf[0] == '\\' && !strncmp (srcbuf + 1, "??\\", 3))
      {
	srcbuf += 4;
	if (srcbuf[1] != ':') /* native UNC path */
	  *(srcbuf += 2) = '\\';
      }
    if (isdrive (srcbuf))
      mount_table->conv_to_posix_path (srcbuf, contents, 0);
    else if (srcbuf[0] == '\\')
      {
	if (srcbuf[1] == '\\') /* UNC path */
	  slashify (srcbuf, contents, 0);
	else /* Paths starting with \ are current drive relative. */
	  {
	    char cvtbuf[SYMLINK_MAX + 1];
d1214 12
a1225 57
	    stpcpy (cvtbuf + cygheap->cwd.get_drive (cvtbuf), srcbuf);
	    mount_table->conv_to_posix_path (cvtbuf, contents, 0);
	  }
      }
    else /* Everything else is taken as is. */
      slashify (srcbuf, contents, 0);
    return strlen (contents);
  }

  enum
  {
    SCAN_BEG,
    SCAN_LNK,
    SCAN_HASLNK,
    SCAN_JUSTCHECK,
    SCAN_JUSTCHECKTHIS, /* Never try to append a suffix. */
    SCAN_APPENDLNK,
    SCAN_EXTRALNK,
    SCAN_DONE,
  };

  class suffix_scan
  {
    const suffix_info *suffixes, *suffixes_start;
    int nextstate;
    char *eopath;
  public:
    const char *path;
    char *has (const char *, const suffix_info *);
    int next ();
    int lnk_match () {return nextstate >= SCAN_APPENDLNK;}
  };

  char *
  suffix_scan::has (const char *in_path, const suffix_info *in_suffixes)
  {
    nextstate = SCAN_BEG;
    suffixes = suffixes_start = in_suffixes;

    const char *fname = strrchr (in_path, '\\');
    fname = fname ? fname + 1 : in_path;
    char *ext_here = strrchr (fname, '.');
    path = in_path;
    eopath = strchr (path, '\0');

    if (!ext_here)
      goto noext;

    if (suffixes)
      {
	/* Check if the extension matches a known extension */
	for (const suffix_info *ex = in_suffixes; ex->name != NULL; ex++)
	  if (ascii_strcasematch (ext_here, ex->name))
	    {
	      nextstate = SCAN_JUSTCHECK;
	      suffixes = NULL;	/* Has an extension so don't scan for one. */
	      goto done;
d1227 1
a1227 1
      }
d1229 16
a1244 6
    /* Didn't match.  Use last resort -- .lnk. */
    if (ascii_strcasematch (ext_here, ".lnk"))
      {
	nextstate = SCAN_HASLNK;
	suffixes = NULL;
      }
d1246 10
a1255 58
   noext:
    ext_here = eopath;

   done:
    /* Avoid attaching suffixes if the resulting filename would be invalid. */
    if (eopath - fname > NAME_MAX - 4)
      {
	nextstate = SCAN_JUSTCHECKTHIS;
	suffixes = NULL;
      }
    return ext_here;
  }

  int
  suffix_scan::next ()
  {
    for (;;)
      {
	if (!suffixes)
	  switch (nextstate)
	    {
	    case SCAN_BEG:
	      suffixes = suffixes_start;
	      if (!suffixes)
		{
		  nextstate = SCAN_LNK;
		  return 1;
		}
	      nextstate = SCAN_EXTRALNK;
	      /* fall through to suffix checking below */
	      break;
	    case SCAN_HASLNK:
	      nextstate = SCAN_APPENDLNK;	/* Skip SCAN_BEG */
	      return 1;
	    case SCAN_EXTRALNK:
	      nextstate = SCAN_DONE;
	      *eopath = '\0';
	      return 0;
	    case SCAN_JUSTCHECK:
	      nextstate = SCAN_LNK;
	      return 1;
	    case SCAN_JUSTCHECKTHIS:
	      nextstate = SCAN_DONE;
	      return 1;
	    case SCAN_LNK:
	    case SCAN_APPENDLNK:
	      strcat (eopath, ".lnk");
	      nextstate = SCAN_DONE;
	      return 1;
	    default:
	      *eopath = '\0';
	      return 0;
	    }

	while (suffixes && suffixes->name)
	  if (nextstate == SCAN_EXTRALNK && !suffixes->addon)
	    suffixes++;
	  else
d1257 2
a1258 5
	      strcpy (eopath, suffixes->name);
	      if (nextstate == SCAN_EXTRALNK)
		strcat (eopath, ".lnk");
	      suffixes++;
	      return 1;
d1260 2
a1261 3
	suffixes = NULL;
      }
  }
d1263 2
a1264 18
  bool
  symlink_info::set_error (int in_errno)
  {
    bool res;
    if (!(pflags & PATH_NO_ACCESS_CHECK) || in_errno == ENAMETOOLONG || in_errno == EIO)
      {
	error = in_errno;
	res = true;
      }
    else if (in_errno == ENOENT)
      res = true;
    else
      {
	fileattr = FILE_ATTRIBUTE_NORMAL;
	res = false;
      }
    return res;
  }
d1266 9
a1274 27
  bool
  symlink_info::parse_device (const char *contents)
  {
    char *endptr;
    _major_t mymajor;
    _major_t myminor;
    _mode_t mymode;

    mymajor = strtol (contents += 2, &endptr, 16);
    if (endptr == contents)
      return isdevice = false;

    contents = endptr;
    myminor = strtol (++contents, &endptr, 16);
    if (endptr == contents)
      return isdevice = false;

    contents = endptr;
    mymode = strtol (++contents, &endptr, 16);
    if (endptr == contents)
      return isdevice = false;

    if ((mymode & S_IFMT) == S_IFIFO)
      {
	mymajor = _major (FH_FIFO);
	myminor = _minor (FH_FIFO);
      }
d1276 10
a1285 5
    major = mymajor;
    minor = myminor;
    mode = mymode;
    return isdevice = true;
  }
d1287 8
a1294 227
  /* Check if PATH is a symlink.  PATH must be a valid Win32 path name.

     If PATH is a symlink, put the value of the symlink--the file to
     which it points--into BUF.  The value stored in BUF is not
     necessarily null terminated.  BUFLEN is the length of BUF; only up
     to BUFLEN characters will be stored in BUF.  BUF may be NULL, in
     which case nothing will be stored.

     Set *SYML if PATH is a symlink.

     Set *EXEC if PATH appears to be executable.  This is an efficiency
     hack because we sometimes have to open the file anyhow.  *EXEC will
     not be set for every executable file.

     Return -1 on error, 0 if PATH is not a symlink, or the length
     stored into BUF if PATH is a symlink.  */

  int
  symlink_info::check (char *path, const suffix_info *suffixes, unsigned opt,
		       fs_info &fs)
  {
    HANDLE h = NULL;
    int res = 0;
    suffix_scan suffix;
    contents[0] = '\0';

    issymlink = true;
    isdevice = false;
    ext_here = suffix.has (path, suffixes);
    extn = ext_here - path;
    major = 0;
    minor = 0;
    mode = 0;
    pflags &= ~(PATH_SYMLINK | PATH_LNK | PATH_REP);
    case_clash = false;

    /* TODO: Temporarily do all char->UNICODE conversion here.  This should
       already be slightly faster than using Ascii functions. */
    tmp_pathbuf tp;
    UNICODE_STRING upath;
    OBJECT_ATTRIBUTES attr;
    tp.u_get (&upath);
    InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE, NULL, NULL);

    while (suffix.next ())
      {
	FILE_BASIC_INFORMATION fbi;
	NTSTATUS status;
	IO_STATUS_BLOCK io;
	bool no_ea = false;

	error = 0;
	get_nt_native_path (suffix.path, upath, pflags & MOUNT_ENC);
	if (h)
	  {
	    NtClose (h);
	    h = NULL;
	  }
	/* The EA given to NtCreateFile allows to get a handle to a symlink on
	   an NFS share, rather than getting a handle to the target of the
	   symlink (which would spoil the task of this method quite a bit).
	   Fortunately it's ignored on other file systems so we don't have
	   to special case NFS too much. */
	status = NtCreateFile (&h,
			       READ_CONTROL | FILE_READ_ATTRIBUTES | FILE_READ_EA,
			       &attr, &io, NULL, FILE_ATTRIBUTE_NORMAL,
			       FILE_SHARE_VALID_FLAGS, FILE_OPEN,
			       FILE_OPEN_REPARSE_POINT
			       | FILE_OPEN_FOR_BACKUP_INTENT,
			       &nfs_aol_ffei, sizeof nfs_aol_ffei);
	if (status == STATUS_ACCESS_DENIED || status == STATUS_EAS_NOT_SUPPORTED) /* No right to access EAs? */
	  {
	    no_ea = true;
	    void *eabuf;
	    ULONG easize;
	    if (status == STATUS_EAS_NOT_SUPPORTED)
	      {
		eabuf = NULL;
		easize = 0;
	      }
	    else
	      {
		eabuf = (void *) &nfs_aol_ffei;
		easize = sizeof nfs_aol_ffei;
	      }
	    status = NtCreateFile (&h,
				   READ_CONTROL | FILE_READ_ATTRIBUTES,
				   &attr, &io, NULL, FILE_ATTRIBUTE_NORMAL,
				   FILE_SHARE_VALID_FLAGS, FILE_OPEN,
				   FILE_OPEN_REPARSE_POINT
				   | FILE_OPEN_FOR_BACKUP_INTENT,
				   eabuf, easize);
	  }
	if (NT_SUCCESS (status)
	    && NT_SUCCESS (status
			   = NtQueryInformationFile (h, &io, &fbi, sizeof fbi,
						     FileBasicInformation)))
	  fileattr = fbi.FileAttributes;
	else
	  {
	    debug_printf ("%p = NtQueryInformationFile (%S)", status, &upath);
	    h = NULL;
	    fileattr = INVALID_FILE_ATTRIBUTES;

	    /* One of the inner path components is invalid, or the path contains
	       invalid characters.  Bail out with ENOENT.

	       Note that additional STATUS_OBJECT_PATH_INVALID and
	       STATUS_OBJECT_PATH_SYNTAX_BAD status codes exist.  The first one
	       is seemingly not generated by NtQueryAttributesFile, the latter
	       is only generated if the path is no absolute path within the
	       NT name space, which should not happen and would point to an
	       error in get_nt_native_path.  Both status codes are deliberately
	       not tested here unless proved necessary. */
	    if (status == STATUS_OBJECT_PATH_NOT_FOUND
		|| status == STATUS_OBJECT_NAME_INVALID)
	      {
		set_error (ENOENT);
		goto file_not_symlink;
	      }
	    if (status != STATUS_OBJECT_NAME_NOT_FOUND
		&& status != STATUS_NO_SUCH_FILE) /* ENOENT on NFS or 9x share */
	      {
		/* The file exists, but the user can't access it for one reason
		   or the other.  To get the file attributes we try to access the
		   information by opening the parent directory and getting the
		   file attributes using a matching NtQueryDirectoryFile call. */
		UNICODE_STRING dirname, basename;
		OBJECT_ATTRIBUTES dattr;
		HANDLE dir;
		struct {
		  FILE_DIRECTORY_INFORMATION fdi;
		  WCHAR dummy_buf[NAME_MAX + 1];
		} fdi_buf;

		RtlSplitUnicodePath (&upath, &dirname, &basename);
		InitializeObjectAttributes (&dattr, &dirname,
					    OBJ_CASE_INSENSITIVE, NULL, NULL);
		status = NtOpenFile (&dir, SYNCHRONIZE | FILE_LIST_DIRECTORY,
				     &dattr, &io, FILE_SHARE_VALID_FLAGS,
				     FILE_SYNCHRONOUS_IO_NONALERT
				     | FILE_OPEN_FOR_BACKUP_INTENT
				     | FILE_DIRECTORY_FILE);
		if (!NT_SUCCESS (status))
		  {
		    debug_printf ("%p = NtOpenFile(%S)", status, &dirname);
		    fileattr = 0;
		  }
		else
		  {
		    status = NtQueryDirectoryFile (dir, NULL, NULL, 0, &io,
						   &fdi_buf, sizeof fdi_buf,
						   FileDirectoryInformation,
						   TRUE, &basename, TRUE);
		    NtClose (dir);
		    if (!NT_SUCCESS (status))
		      {
			debug_printf ("%p = NtQueryDirectoryFile(%S)",
				      status, &dirname);
			fileattr = 0;
		      }
		    else
		      fileattr = fdi_buf.fdi.FileAttributes;
		  }
		ext_tacked_on = !!*ext_here;
		goto file_not_symlink;
	      }
	    set_error (ENOENT);
	    continue;
	  }

	/* Check file system while we're having the file open anyway.
	   This speeds up path_conv noticably (~10%). */
	fs.update (&upath, h);

	ext_tacked_on = !!*ext_here;

	if (pcheck_case != PCHECK_RELAXED && !case_check (path)
	    || (opt & PC_SYM_IGNORE))
	  goto file_not_symlink;

	res = -1;

	/* Windows shortcuts are potentially treated as symlinks.  Valid Cygwin
	   & U/WIN shortcuts are R/O, but definitely not directories. */
	if ((fileattr & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_DIRECTORY))
	    == FILE_ATTRIBUTE_READONLY && suffix.lnk_match ())
	  {
	    res = check_shortcut (h);
	    if (!res)
	      {
		/* If searching for `foo' and then finding a `foo.lnk' which is
		   no shortcut, return the same as if file not found. */
		if (!suffix.lnk_match () || !ext_tacked_on)
		  goto file_not_symlink;

		/* in case we're going to tack *another* .lnk on this filename. */
		fileattr = INVALID_FILE_ATTRIBUTES;
		continue;
	      }
	    if (contents[0] == ':' && contents[1] == '\\'
		&& parse_device (contents))
	      goto file_not_symlink;
	  }

	/* Reparse points are potentially symlinks.  This check must be
	   performed before checking the SYSTEM attribute for sysfile
	   symlinks, since reparse points can have this flag set, too.
	   For instance, Vista starts to create a couple of reparse points
	   with SYSTEM and HIDDEN flags set. */
	else if (fileattr & FILE_ATTRIBUTE_REPARSE_POINT)
	  {
	    res = check_reparse_point (h);
	    if (!res)
	      goto file_not_symlink;
	  }

	/* This is the old Cygwin method creating symlinks.  A symlink will
	   have the `system' file attribute.  Only files can be symlinks
	   (which can be symlinks to directories). */
	else if ((fileattr & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY))
		 == FILE_ATTRIBUTE_SYSTEM)
	  {
	    res = check_sysfile (h);
	    if (!res)
	      goto file_not_symlink;
	  }
d1296 13
a1308 9
	/* If the file could be opened with FILE_READ_EA, and if it's on a
	   NFS share, check if it's a symlink.  Only files can be symlinks
	   (which can be symlinks to directories). */
	else if (!no_ea && !(fileattr & FILE_ATTRIBUTE_DIRECTORY) && fs.is_nfs ())
	  {
	    res = check_nfs_symlink (h);
	    if (!res)
	      goto file_not_symlink;
	  }
d1310 71
a1380 3
	/* Normal file. */
	else
	  goto file_not_symlink;
d1382 73
a1454 1
	break;
d1456 12
d1469 36
a1504 4
      file_not_symlink:
	issymlink = false;
	syscall_printf ("%s", isdevice ? "is a device" : "not a symlink");
	res = 0;
d1506 4
a1509 1
      }
d1511 2
a1512 2
    if (h)
      NtClose (h);
d1514 48
a1561 4
    syscall_printf ("%d = symlink.check (%s, %p) (%p)",
		    res, suffix.path, contents, pflags);
    return res;
  }
d1563 5
a1567 16
  /* "path" is the path in a virtual symlink.  Set a symlink_info struct from
     that and proceed with further path checking afterwards. */
  int
  symlink_info::set (char *path)
  {
    strcpy (contents, path);
    pflags = PATH_SYMLINK;
    fileattr = FILE_ATTRIBUTE_NORMAL;
    error = 0;
    issymlink = true;
    isdevice = false;
    ext_tacked_on = case_clash = false;
    ext_here = NULL;
    extn = major = minor = mode = 0;
    return strlen (path);
  }
d1569 16
a1584 5
  /* Check the correct case of the last path component (given in DOS style).
     Adjust the case in this->path if pcheck_case == PCHECK_ADJUST or return
     false if pcheck_case == PCHECK_STRICT.
     Dont't call if pcheck_case == PCHECK_RELAXED.
  */
d1586 5
a1590 17
  bool
  symlink_info::case_check (char *path)
  {
    WIN32_FIND_DATA data;
    HANDLE h;
    char *c;

    /* Set a pointer to the beginning of the last component. */
    if (!(c = strrchr (path, '\\')))
      c = path;
    else
      ++c;

    if ((h = FindFirstFile (path, &data))
	!= INVALID_HANDLE_VALUE)
      {
	FindClose (h);
d1592 2
a1593 4
	/* If that part of the component exists, check the case. */
	if (strncmp (c, data.cFileName, strlen (data.cFileName)))
	  {
	    case_clash = true;
d1595 6
a1600 12
	    /* If check is set to STRICT, a wrong case results
	       in returning a ENOENT. */
	    if (pcheck_case == PCHECK_STRICT)
	      return false;

	    /* PCHECK_ADJUST adjusts the case in the incoming
	       path which points to the path in *this. */
	    strcpy (c, data.cFileName);
	  }
      }
    return true;
  }
d1602 27
a1628 1
  /* readlink system call */
d1630 44
a1673 8
  extern "C" ssize_t
  readlink (const char *path, char *buf, size_t buflen)
  {
    if (buflen < 0)
      {
	set_errno (ENAMETOOLONG);
	return -1;
      }
d1675 66
a1740 1
    path_conv pathbuf (path, PC_SYM_CONTENTS, stat_suffixes);
d1742 20
a1761 6
    if (pathbuf.error)
      {
	set_errno (pathbuf.error);
	syscall_printf ("-1 = readlink (%s, %p, %d)", path, buf, buflen);
	return -1;
      }
d1763 62
a1824 5
    if (!pathbuf.exists ())
      {
	set_errno (ENOENT);
	return -1;
      }
d1826 138
a1963 6
    if (!pathbuf.issymlink ())
      {
	if (pathbuf.exists ())
	  set_errno (EINVAL);
	return -1;
      }
d1965 74
a2038 2
    ssize_t len = min (buflen, strlen (pathbuf.get_win32 ()));
    memcpy (buf, pathbuf.get_win32 (), len);
d2040 31
a2070 3
    /* errno set by symlink.check if error */
    return len;
  }
d2072 22
a2093 12
  /* Some programs rely on st_dev/st_ino being unique for each file.
     Hash the path name and hope for the best.  The hash arg is not
     always initialized to zero since readdir needs to compute the
     dirent ino_t based on a combination of the hash of the directory
     done during the opendir call and the hash or the filename within
     the directory.  FIXME: Not bullet-proof. */
  /* Cygwin internal */
  __ino64_t __stdcall
  hash_path_name (__ino64_t hash, PUNICODE_STRING name)
  {
    if (name->Length == 0)
      return hash;
d2095 16
a2110 7
    /* Build up hash. Name is already normalized */
    USHORT len = name->Length / sizeof (WCHAR);
    for (USHORT idx = 0; idx < len; ++idx)
      hash = RtlUpcaseUnicodeChar (name->Buffer[idx])
	     + (hash << 6) + (hash << 16) - hash;
    return hash;
  }
d2112 44
a2155 7
  __ino64_t __stdcall
  hash_path_name (__ino64_t hash, PCWSTR name)
  {
    UNICODE_STRING uname;
    RtlInitUnicodeString (&uname, name);
    return hash_path_name (hash, &uname);
  }
d2157 2
a2158 9
  __ino64_t __stdcall
  hash_path_name (__ino64_t hash, const char *name)
  {
    UNICODE_STRING uname;
    RtlCreateUnicodeStringFromAsciiz (&uname, name);
    __ino64_t ret = hash_path_name (hash, &uname);
    RtlFreeUnicodeString (&uname);
    return ret;
  }
d2160 11
a2170 13
  extern "C" char *
  getcwd (char *buf, size_t ulen)
  {
    char* res = NULL;
    myfault efault;
    if (efault.faulted (EFAULT))
	/* errno set */;
    else if (ulen == 0 && buf)
      set_errno (EINVAL);
    else
      res = cygheap->cwd.get (buf, 1, 1, ulen);
    return res;
  }
d2172 6
a2177 6
  /* getwd: Legacy. */
  extern "C" char *
  getwd (char *buf)
  {
    return getcwd (buf, PATH_MAX + 1);  /*Per SuSv3!*/
  }
d2179 2
a2180 12
  /* chdir: POSIX 5.2.1.1 */
  extern "C" int
  chdir (const char *in_dir)
  {
    myfault efault;
    if (efault.faulted (EFAULT))
      return -1;
    if (!*in_dir)
      {
	set_errno (ENOENT);
	return -1;
      }
d2182 9
a2190 1
    syscall_printf ("dir '%s'", in_dir);
d2192 40
a2231 9
    /* Convert path.  First argument ensures that we don't check for NULL/empty/invalid
       again. */
    path_conv path (PC_NONULLEMPTY, in_dir, PC_SYM_FOLLOW | PC_POSIX);
    if (path.error)
      {
	set_errno (path.error);
	syscall_printf ("-1 = chdir (%s)", in_dir);
	return -1;
      }
d2233 14
a2246 36
    int res = -1;
    bool doit = false;
    const char *posix_cwd = NULL;
    int devn = path.get_devn ();
    if (!isvirtual_dev (devn))
      {
	/* The sequence chdir("xx"); chdir(".."); must be a noop if xx
	   is not a symlink. This is exploited by find.exe.
	   The posix_cwd is just path.normalized_path.
	   In other cases we let cwd.set obtain the Posix path through
	   the mount table. */
	if (!isdrive(path.normalized_path))
	  posix_cwd = path.normalized_path;
	res = 0;
	doit = true;
      }
    else if (!path.exists ())
      set_errno (ENOENT);
    else if (!path.isdir ())
      set_errno (ENOTDIR);
    else
     {
       posix_cwd = path.normalized_path;
       res = 0;
     }

    if (!res)
      res = cygheap->cwd.set (path.get_nt_native_path (), posix_cwd, doit);

    /* Note that we're accessing cwd.posix without a lock here.  I didn't think
       it was worth locking just for strace. */
    syscall_printf ("%d = chdir() cygheap->cwd.posix '%s' native '%S'", res,
		    cygheap->cwd.posix, path.get_nt_native_path ());
    MALLOC_CHECK;
    return res;
  }
d2248 18
a2265 9
  extern "C" int
  fchdir (int fd)
  {
    int res;
    cygheap_fdget cfd (fd);
    if (cfd >= 0)
      res = chdir (cfd->get_name ());
    else
      res = -1;
d2267 21
a2287 3
    syscall_printf ("%d = fchdir (%d)", res, fd);
    return res;
  }
d2289 5
a2293 1
  /******************** Exported Path Routines *********************/
d2295 49
a2343 2
  /* Cover functions to the path conversion routines.
     These are exported to the world as cygwin_foo by cygwin.din.  */
d2345 2
a2346 17
#define return_with_errno(x) \
    do {\
      int err = (x);\
      if (!err)\
       return 0;\
      set_errno (err);\
      return -1;\
    } while (0)

  extern "C" ssize_t
  cygwin_conv_path (cygwin_conv_path_t what, const void *from, void *to,
		    size_t size)
  {
    tmp_pathbuf tp;
    myfault efault;
    if (efault.faulted (EFAULT))
      return -1;
d2348 6
a2353 71
    path_conv p;
    size_t lsiz = 0;
    char *buf = NULL;
    int error = 0;
    bool relative = !!(what & CCP_RELATIVE);
    what &= ~CCP_RELATIVE;

    switch (what)
      {
      case CCP_POSIX_TO_WIN_A:
	p.check ((const char *) from,
		 PC_POSIX | PC_SYM_FOLLOW | PC_NO_ACCESS_CHECK | PC_NOWARN
		 | (relative ? PC_NOFULL : 0));
	if (p.error)
	  return_with_errno (p.error);
	PUNICODE_STRING up = p.get_nt_native_path ();
	buf = tp.c_get ();
	sys_wcstombs (buf, NT_MAX_PATH, up->Buffer, up->Length / sizeof (WCHAR));
	buf += 4; /* Skip \??\ */
	if (buf[1] != ':') /* native UNC path */
	  *(buf += 2) = '\\';
	lsiz = strlen (buf) + 1;
	break;
      case CCP_POSIX_TO_WIN_W:
	p.check ((const char *) from,
		 PC_POSIX | PC_SYM_FOLLOW | PC_NO_ACCESS_CHECK | PC_NOWARN
		 | (relative ? PC_NOFULL : 0));
	if (p.error)
	  return_with_errno (p.error);
	lsiz = (p.get_wide_win32_path_len () + 1) * sizeof (WCHAR);
	break;
      case CCP_WIN_A_TO_POSIX:
	buf = tp.c_get ();
	error = mount_table->conv_to_posix_path ((const char *) from, buf,
						 relative);
	if (error)
	  return_with_errno (error);
	lsiz = strlen (buf) + 1;
	break;
      case CCP_WIN_W_TO_POSIX:
	buf = tp.c_get ();
	error = mount_table->conv_to_posix_path ((const PWCHAR) from, buf,
						 relative);
	if (error)
	  return_with_errno (error);
	lsiz = strlen (buf) + 1;
	break;
      default:
	set_errno (EINVAL);
	return -1;
      }
    if (!size)
      return lsiz;
    if (size < lsiz)
      {
	set_errno (ENOSPC);
	return -1;
      }
    switch (what)
      {
      case CCP_POSIX_TO_WIN_A:
      case CCP_WIN_A_TO_POSIX:
      case CCP_WIN_W_TO_POSIX:
	strcpy ((char *) to, buf);
	break;
      case CCP_POSIX_TO_WIN_W:
	p.get_wide_win32_path ((PWCHAR) to);
	break;
      }
    return 0;
  }
d2355 115
a2469 13
  extern "C" void *
  cygwin_create_path (cygwin_conv_path_t what, const void *from)
  {
    void *to;
    ssize_t size = cygwin_conv_path (what, from, NULL, 0);
    if (size <= 0)
      return NULL;
    if (!(to = malloc (size)))
      return NULL;
    if (cygwin_conv_path (what, from, to, size) == -1)
      return NULL;
    return to;
  }
d2471 9
d2481 1
a2481 6
  extern "C" int
  cygwin_conv_to_win32_path (const char *path, char *win32_path)
  {
    return cygwin_conv_path (CCP_POSIX_TO_WIN_A | CCP_RELATIVE, path, win32_path,
			     MAX_PATH);
  }
d2483 12
a2494 6
  extern "C" int
  cygwin_conv_to_full_win32_path (const char *path, char *win32_path)
  {
    return cygwin_conv_path (CCP_POSIX_TO_WIN_A | CCP_ABSOLUTE, path, win32_path,
			     MAX_PATH);
  }
d2496 8
a2503 1
  /* This is exported to the world as cygwin_foo by cygwin.din.  */
d2505 11
a2515 13
  extern "C" int
  cygwin_conv_to_posix_path (const char *path, char *posix_path)
  {
    return cygwin_conv_path (CCP_WIN_A_TO_POSIX | CCP_RELATIVE, path, posix_path,
			     MAX_PATH);
  }

  extern "C" int
  cygwin_conv_to_full_posix_path (const char *path, char *posix_path)
  {
    return cygwin_conv_path (CCP_WIN_A_TO_POSIX | CCP_ABSOLUTE, path, posix_path,
			     MAX_PATH);
  }
d2517 10
a2526 1
  /* The realpath function is supported on some UNIX systems.  */
d2528 9
a2536 9
  extern "C" char *
  realpath (const char *path, char *resolved)
  {
    /* Make sure the right errno is returned if path is NULL. */
    if (!path)
      {
	set_errno (EINVAL);
	return NULL;
      }
d2538 5
a2542 6
    /* Guard reading from a potentially invalid path and writing to a
       potentially invalid resolved. */
    tmp_pathbuf tp;
    myfault efault;
    if (efault.faulted (EFAULT))
      return NULL;
a2543 8
    char *tpath;
    if (isdrive (path))
      {
	tpath = tp.c_get ();
	mount_table->cygdrive_posix_path (path, tpath, 0);
      }
    else
      tpath = (char *) path;
d2545 6
a2550 1
    path_conv real_path (tpath, PC_SYM_FOLLOW | PC_POSIX, stat_suffixes);
d2552 2
d2555 40
a2594 5
    /* Linux has this funny non-standard extension.  If "resolved" is NULL,
       realpath mallocs the space by itself and returns it to the application.
       The application is responsible for calling free() then.  This extension
       is backed by POSIX, which allows implementation-defined behaviour if
       "resolved" is NULL.  That's good enough for us to do the same here. */
d2596 4
a2599 11
    if (!real_path.error && real_path.exists ())
      {
	if (!resolved)
	  {
	    resolved = (char *) malloc (strlen (real_path.normalized_path) + 1);
	    if (!resolved)
	      return NULL;
	  }
	strcpy (resolved, real_path.normalized_path);
	return resolved;
      }
d2601 9
a2609 7
    /* FIXME: on error, we are supposed to put the name of the path
       component which could not be resolved into RESOLVED.  */
    if (resolved)
      resolved[0] = '\0';
    set_errno (real_path.error ?: ENOENT);
    return NULL;
  }
d2611 7
a2617 2
  /* Return non-zero if path is a POSIX path list.
     This is exported to the world as cygwin_foo by cygwin.din.
d2619 1
a2619 12
  DOCTOOL-START
  <sect1 id="add-func-cygwin-posix-path-list-p">
    <para>Rather than use a mode to say what the "proper" path list
    format is, we allow any, and give apps the tools they need to
    convert between the two.  If a ';' is present in the path list it's
    a Win32 path list.  Otherwise, if the first path begins with
    [letter]: (in which case it can be the only element since if it
    wasn't a ';' would be present) it's a Win32 path list.  Otherwise,
    it's a POSIX path list.</para>
  </sect1>
  DOCTOOL-END
    */
d2621 8
a2628 6
  extern "C" int
  cygwin_posix_path_list_p (const char *path)
  {
    int posix_p = !(strchr (path, ';') || isdrive (path));
    return posix_p;
  }
d2630 1
a2630 4
  /* These are used for apps that need to convert env vars like PATH back and
     forth.  The conversion is a two step process.  First, an upper bound on the
     size of the buffer needed is computed.  Then the conversion is done.  This
     allows the caller to use alloca if it wants.  */
d2632 6
a2637 5
  static int
  conv_path_list_buf_size (const char *path_list, bool to_posix)
  {
    int i, num_elms, max_mount_path_len, size;
    const char *p;
d2639 5
a2643 13
    path_conv pc(".", PC_POSIX);
    /* The theory is that an upper bound is
       current_size + (num_elms * max_mount_path_len)  */
    /* FIXME: This method is questionable in the long run. */

    unsigned nrel;
    char delim = to_posix ? ';' : ':';
    for (p = path_list, num_elms = nrel = 0; p; num_elms++)
      {
	if (!isabspath (p))
	  nrel++;
	p = strchr (++p, delim);
      }
d2645 6
a2650 10
    /* 7: strlen ("//c") + slop, a conservative initial value */
    for (max_mount_path_len = sizeof ("/cygdrive/X"), i = 0;
	 i < mount_table->nmounts; i++)
      {
	int mount_len = (to_posix
			 ? mount_table->mount[i].posix_pathlen
			 : mount_table->mount[i].native_pathlen);
	if (max_mount_path_len < mount_len)
	  max_mount_path_len = mount_len;
      }
d2652 2
a2653 5
    /* 100: slop */
    size = strlen (path_list)
      + (num_elms * max_mount_path_len)
      + (nrel * strlen (to_posix ? pc.normalized_path : pc.get_win32 ()))
      + 100;
d2655 16
a2670 2
    return size;
  }
d2672 59
d2732 1
a2732 5
  extern "C" int
  cygwin_win32_to_posix_path_list_buf_size (const char *path_list)
  {
    return conv_path_list_buf_size (path_list, true);
  }
d2734 9
a2742 5
  extern "C" int
  cygwin_posix_to_win32_path_list_buf_size (const char *path_list)
  {
    return conv_path_list_buf_size (path_list, false);
  }
d2744 50
a2793 6
  extern "C" ssize_t
  env_PATH_to_posix (const void *win32, void *posix, size_t size)
  {
    return_with_errno (conv_path_list ((const char *) win32, (char *) posix,
				       size, ENV_CVT));
  }
d2795 1
a2795 5
  extern "C" int
  cygwin_win32_to_posix_path_list (const char *win32, char *posix)
  {
    return_with_errno (conv_path_list (win32, posix, MAX_PATH, 1));
  }
d2797 2
a2798 5
  extern "C" int
  cygwin_posix_to_win32_path_list (const char *posix, char *win32)
  {
    return_with_errno (conv_path_list (posix, win32, MAX_PATH, 0));
  }
d2800 16
a2815 25
  extern "C" ssize_t
  cygwin_conv_path_list (cygwin_conv_path_t what, const void *from, void *to,
			 size_t size)
  {
    /* FIXME: Path lists are (so far) always retaining relative paths. */
    what &= ~CCP_RELATIVE;
    switch (what)
      {
      case CCP_WIN_W_TO_POSIX:
      case CCP_POSIX_TO_WIN_W:
	/*FIXME*/
	api_fatal ("wide char path lists not yet supported");
	break;
      case CCP_WIN_A_TO_POSIX:
      case CCP_POSIX_TO_WIN_A:
	if (size == 0)
	  return conv_path_list_buf_size ((const char *) from,
					  what == CCP_WIN_A_TO_POSIX);
	return_with_errno (conv_path_list ((const char *) from, (char *) to,
					   size, what == CCP_WIN_A_TO_POSIX));
	break;
      default:
	break;
      }
    set_errno (EINVAL);
a2816 1
  }
d2818 71
a2888 2
  /* cygwin_split_path: Split a path into directory and file name parts.
     Buffers DIR and FILE are assumed to be big enough.
d2890 13
a2902 15
     Examples (path -> `dir' / `file'):
     / -> `/' / `'
     "" -> `.' / `'
     . -> `.' / `.' (FIXME: should this be `.' / `'?)
     .. -> `.' / `..' (FIXME: should this be `..' / `'?)
     foo -> `.' / `foo'
     foo/bar -> `foo' / `bar'
     foo/bar/ -> `foo' / `bar'
     /foo -> `/' / `foo'
     /foo/bar -> `/foo' / `bar'
     c: -> `c:/' / `'
     c:/ -> `c:/' / `'
     c:foo -> `c:/' / `foo'
     c:/foo -> `c:/' / `foo'
   */
a2903 4
  extern "C" void
  cygwin_split_path (const char *path, char *dir, char *file)
  {
    int dir_started_p = 0;
d2905 41
a2945 17
    /* Deal with drives.
       Remember that c:foo <==> c:/foo.  */
    if (isdrive (path))
      {
	*dir++ = *path++;
	*dir++ = *path++;
	*dir++ = '/';
	if (!*path)
	  {
	    *dir = 0;
	    *file = 0;
	    return;
	  }
	if (isdirsep (*path))
	  ++path;
	dir_started_p = 1;
      }
d2947 6
a2952 15
    /* Determine if there are trailing slashes and "delete" them if present.
       We pretend as if they don't exist.  */
    const char *end = path + strlen (path);
    /* path + 1: keep leading slash.  */
    while (end > path + 1 && isdirsep (end[-1]))
      --end;

    /* At this point, END points to one beyond the last character
       (with trailing slashes "deleted").  */

    /* Point LAST_SLASH at the last slash (duh...).  */
    const char *last_slash;
    for (last_slash = end - 1; last_slash >= path; --last_slash)
      if (isdirsep (*last_slash))
	break;
d2954 8
a2961 18
    if (last_slash == path)
      {
	*dir++ = '/';
	*dir = 0;
      }
    else if (last_slash > path)
      {
	memcpy (dir, path, last_slash - path);
	dir[last_slash - path] = 0;
      }
    else
      {
	if (dir_started_p)
	  ; /* nothing to do */
	else
	  *dir++ = '.';
	*dir = 0;
      }
d2963 1
a2963 3
    memcpy (file, last_slash + 1, end - last_slash - 1);
    file[end - last_slash - 1] = 0;
  }
a2964 1
  /*****************************************************************************/
d2966 5
a2970 5
  static inline PRTL_USER_PROCESS_PARAMETERS
  get_user_proc_parms ()
  {
    return NtCurrentTeb ()->Peb->ProcessParameters;
  }
d2972 11
a2982 8
  /* Initialize cygcwd 'muto' for serializing access to cwd info. */
  void
  cwdstuff::init ()
  {
    cwd_lock.init ("cwd_lock");
    /* Initially re-open the cwd to allow POSIX semantics. */
    set (NULL, NULL, true);
  }
d2984 23
a3006 22
  /* Chdir and fill out the elements of a cwdstuff struct. */
  int
  cwdstuff::set (PUNICODE_STRING nat_cwd, const char *posix_cwd, bool doit)
  {
    int res = 0;
    UNICODE_STRING upath;
    size_t len = 0;

    cwd_lock.acquire ();

    if (nat_cwd)
      {
	upath = *nat_cwd;
	if (upath.Buffer[0] == L'/') /* Virtual path.  Never use in PEB. */
	  doit = false;
	else
	  {
	    len = upath.Length / sizeof (WCHAR) - 4;
	    if (RtlEqualUnicodePathPrefix (&upath, L"\\??\\UNC\\", TRUE))
	      len -= 2;
	  }
      }
d3008 31
a3038 54
    if (doit)
      {
	/* We utilize the user parameter block.  The directory is
	   stored manually there.  Why the hassle?

	   - SetCurrentDirectory fails for directories with strict
	     permissions even for processes with the SE_BACKUP_NAME
	     privilege enabled.  The reason is apparently that
	     SetCurrentDirectory calls NtOpenFile without the
	     FILE_OPEN_FOR_BACKUP_INTENT flag set.

	   - Unlinking a cwd fails because SetCurrentDirectory seems to
	     open directories so that deleting the directory is disallowed.
	     The below code opens with *all* sharing flags set. */
	HANDLE h;
	NTSTATUS status;
	IO_STATUS_BLOCK io;
	OBJECT_ATTRIBUTES attr;
	PHANDLE phdl;

	RtlAcquirePebLock ();
	phdl = &get_user_proc_parms ()->CurrentDirectoryHandle;
	if (!nat_cwd) /* On init, just reopen CWD with desired access flags. */
	  RtlInitUnicodeString (&upath, L"");
	InitializeObjectAttributes (&attr, &upath,
				    OBJ_CASE_INSENSITIVE | OBJ_INHERIT,
				    nat_cwd ? NULL : *phdl, NULL);
	status = NtOpenFile (&h, SYNCHRONIZE | FILE_TRAVERSE, &attr, &io,
			     FILE_SHARE_VALID_FLAGS,
			     FILE_DIRECTORY_FILE
			     | FILE_SYNCHRONOUS_IO_NONALERT
			     | FILE_OPEN_FOR_BACKUP_INTENT);
	if (!NT_SUCCESS (status))
	  {
	    RtlReleasePebLock ();
	    __seterrno_from_nt_status (status);
	    res = -1;
	    goto out;
	  }
	/* Workaround a problem in Vista/Longhorn which fails in subsequent
	   calls to CreateFile with ERROR_INVALID_HANDLE if the handle in
	   CurrentDirectoryHandle changes without calling SetCurrentDirectory,
	   and the filename given to CreateFile is a relative path.  It looks
	   like Vista stores a copy of the CWD handle in some other undocumented
	   place.  The NtClose/DuplicateHandle reuses the original handle for
	   the copy of the new handle and the next CreateFile works.
	   Note that this is not thread-safe (yet?) */
	NtClose (*phdl);
	if (DuplicateHandle (GetCurrentProcess (), h, GetCurrentProcess (), phdl,
			     0, TRUE, DUPLICATE_SAME_ACCESS))
	  NtClose (h);
	else
	  *phdl = h;
	dir = *phdl;
d3040 10
a3049 25
	/* No need to set path on init. */
	if (nat_cwd
	    /* TODO:
	       Check the length of the new CWD.  Windows can only handle
	       CWDs of up to MAX_PATH length, including a trailing backslash.
	       If the path is longer, it's not an error condition for Cygwin,
	       so we don't fail.  Windows on the other hand has a problem now.
	       For now, we just don't store the path in the PEB and proceed as
	       usual. */
	    && len <= MAX_PATH - (nat_cwd->Buffer[len - 1] == L'\\' ? 1 : 2))
	  {
	    /* Convert to a Win32 path. */
	    upath.Buffer += upath.Length / sizeof (WCHAR) - len;
	    if (upath.Buffer[1] == L'\\') /* UNC path */
	      upath.Buffer[0] = L'\\';
	    upath.Length = len * sizeof (WCHAR);
	    /* Append backslash if necessary. */
	    if (upath.Buffer[len - 1] != L'\\')
	      {
		upath.Buffer[len] = L'\\';
		upath.Length += sizeof (WCHAR);
	      }
	    RtlCopyUnicodeString (&get_user_proc_parms ()->CurrentDirectoryName,
				  &upath);
	  }
d3051 110
a3160 2
	RtlReleasePebLock ();
      }
d3162 15
a3176 6
    if (nat_cwd || !win32.Buffer)
      {
	/* If there is no win32 path */
	if (!nat_cwd)
	  {
	    PUNICODE_STRING pdir;
d3178 18
a3195 51
	    RtlAcquirePebLock ();
	    pdir = &get_user_proc_parms ()->CurrentDirectoryName;
	    RtlInitEmptyUnicodeString (&win32,
				       (PWCHAR) crealloc_abort (win32.Buffer,
								pdir->Length + 2),
				       pdir->Length + 2);
	    RtlCopyUnicodeString (&win32, pdir);
	    RtlReleasePebLock ();
	    /* Remove trailing slash. */
	    if (win32.Length > 3 * sizeof (WCHAR))
	      win32.Length -= sizeof (WCHAR);
	    posix_cwd = NULL;
	  }
	else
	  {
	    if (upath.Buffer[0] == L'/') /* Virtual path, don't mangle. */
	      ;
	    else if (!doit)
	      {
		/* Convert to a Win32 path. */
		upath.Buffer += upath.Length / sizeof (WCHAR) - len;
		if (upath.Buffer[1] == L'\\') /* UNC path */
		  upath.Buffer[0] = L'\\';
		upath.Length = len * sizeof (WCHAR);
	      }
	    else if (upath.Length > 3 * sizeof (WCHAR))
	      upath.Length -= sizeof (WCHAR); /* Strip trailing backslash */
	    RtlInitEmptyUnicodeString (&win32,
				       (PWCHAR) crealloc_abort (win32.Buffer,
								upath.Length + 2),
				       upath.Length + 2);
	    RtlCopyUnicodeString (&win32, &upath);
	  }
	/* Make sure it's NUL-termniated. */
	win32.Buffer[win32.Length / sizeof (WCHAR)] = L'\0';
	if (!doit)			 /* Virtual path */
	  drive_length = 0;
	else if (win32.Buffer[1] == L':')	 /* X: */
	  drive_length = 2;
	else if (win32.Buffer[1] == L'\\') /* UNC path */
	  {
	    PWCHAR ptr = wcschr (win32.Buffer + 2, L'\\');
	    if (ptr)
	      ptr = wcschr (ptr + 1, L'\\');
	    if (ptr)
	      drive_length = ptr - win32.Buffer;
	    else
	      drive_length = win32.Length / sizeof (WCHAR);
	  }
	else				 /* Shouldn't happen */
	  drive_length = 0;
d3197 28
a3224 9
	tmp_pathbuf tp;
	if (!posix_cwd)
	  {
	    posix_cwd = (const char *) tp.c_get ();
	    mount_table->conv_to_posix_path (win32.Buffer, (char *) posix_cwd, 0);
	  }
	posix = (char *) crealloc_abort (posix, strlen (posix_cwd) + 1);
	stpcpy (posix, posix_cwd);
      }
d3226 1
a3226 4
  out:
    cwd_lock.release ();
    return res;
  }
d3228 12
a3239 5
  /* Copy the value for either the posix or the win32 cwd into a buffer. */
  char *
  cwdstuff::get (char *buf, int need_posix, int with_chroot, unsigned ulen)
  {
    MALLOC_CHECK;
d3241 4
a3244 10
    tmp_pathbuf tp;
    if (ulen)
      /* nothing */;
    else if (buf == NULL)
      ulen = (unsigned) -1;
    else
      {
	set_errno (EINVAL);
	goto out;
      }
d3246 75
a3320 1
    cwd_lock.acquire ();
d3322 2
a3323 9
    char *tocopy;
    if (!need_posix)
      {
	tocopy = tp.c_get ();
	sys_wcstombs (tocopy, NT_MAX_PATH, win32.Buffer,
		      win32.Length / sizeof (WCHAR));
      }
    else
      tocopy = posix;
d3325 58
a3382 14
    debug_printf ("posix %s", posix);
    if (strlen (tocopy) >= ulen)
      {
	set_errno (ERANGE);
	buf = NULL;
      }
    else
      {
	if (!buf)
	  buf = (char *) malloc (strlen (tocopy) + 1);
	strcpy (buf, tocopy);
	if (!buf[0])	/* Should only happen when chroot */
	  strcpy (buf, "/");
      }
d3384 9
a3392 1
    cwd_lock.release ();
d3394 21
a3414 6
  out:
    syscall_printf ("(%s) = cwdstuff::get (%p, %d, %d, %d), errno %d",
		    buf, buf, ulen, need_posix, with_chroot, errno);
    MALLOC_CHECK;
    return buf;
  }
d3416 1
a3416 5
  int etc::curr_ix = 0;
  /* Note that the first elements of the below arrays are unused */
  bool etc::change_possible[MAX_ETC_FILES + 1];
  OBJECT_ATTRIBUTES etc::fn[MAX_ETC_FILES + 1];
  LARGE_INTEGER etc::last_modified[MAX_ETC_FILES + 1];
d3418 9
a3426 16
  int
  etc::init (int n, PUNICODE_STRING etc_fn)
  {
    if (n > 0)
      /* ok */;
    else if (++curr_ix <= MAX_ETC_FILES)
      n = curr_ix;
    else
      api_fatal ("internal error");

    InitializeObjectAttributes (&fn[n], etc_fn, OBJ_CASE_INSENSITIVE, NULL, NULL);
    change_possible[n] = false;
    test_file_change (n);
    paranoid_printf ("fn[%d] %S, curr_ix %d", n, fn[n].ObjectName, curr_ix);
    return n;
  }
d3428 14
a3441 21
  bool
  etc::test_file_change (int n)
  {
    NTSTATUS status;
    FILE_NETWORK_OPEN_INFORMATION fnoi;
    bool res;

    status = NtQueryFullAttributesFile (&fn[n], &fnoi);
    if (!NT_SUCCESS (status))
      {
	res = true;
	memset (last_modified + n, 0, sizeof (last_modified[n]));
	debug_printf ("NtQueryFullAttributesFile (%S) failed, %p",
		      fn[n].ObjectName, status);
      }
    else
      {
	res = CompareFileTime ((FILETIME *) &fnoi.LastWriteTime,
			       (FILETIME *) last_modified + n) > 0;
	last_modified[n].QuadPart = fnoi.LastWriteTime.QuadPart;
      }
d3443 1
a3443 3
    paranoid_printf ("fn[%d] %S res %d", n, fn[n].ObjectName, res);
    return res;
  }
d3445 36
a3480 8
  bool
  etc::dir_changed (int n)
  {
    if (!change_possible[n])
      {
	static HANDLE changed_h NO_COPY;
	NTSTATUS status;
	IO_STATUS_BLOCK io;
d3482 14
a3495 3
	if (!changed_h)
	  {
	    OBJECT_ATTRIBUTES attr;
d3497 23
a3519 6
	    path_conv dir ("/etc");
	    status = NtOpenFile (&changed_h, SYNCHRONIZE | FILE_LIST_DIRECTORY,
				 dir.get_object_attr (attr, sec_none_nih), &io,
				 FILE_SHARE_VALID_FLAGS, FILE_DIRECTORY_FILE);
	    if (!NT_SUCCESS (status))
	      {
d3521 2
a3522 2
		system_printf ("NtOpenFile (%S) failed, %p",
			       dir.get_nt_native_path (), status);
d3524 11
a3534 11
		changed_h = INVALID_HANDLE_VALUE;
	      }
	    else
	      {
		status = NtNotifyChangeDirectoryFile (changed_h, NULL, NULL,
						  NULL, &io, NULL, 0,
						  FILE_NOTIFY_CHANGE_LAST_WRITE
						  | FILE_NOTIFY_CHANGE_FILE_NAME,
						  FALSE);
		if (!NT_SUCCESS (status))
		  {
d3536 2
a3537 2
		    system_printf ("NtNotifyChangeDirectoryFile (1) failed, %p",
				   status);
d3539 6
a3544 6
		    NtClose (changed_h);
		    changed_h = INVALID_HANDLE_VALUE;
		  }
	      }
	    memset (change_possible, true, sizeof (change_possible));
	  }
d3546 11
a3556 11
	if (changed_h == INVALID_HANDLE_VALUE)
	  change_possible[n] = true;
	else if (WaitForSingleObject (changed_h, 0) == WAIT_OBJECT_0)
	  {
	    status = NtNotifyChangeDirectoryFile (changed_h, NULL, NULL,
						  NULL, &io, NULL, 0,
						  FILE_NOTIFY_CHANGE_LAST_WRITE
						  | FILE_NOTIFY_CHANGE_FILE_NAME,
						  FALSE);
	    if (!NT_SUCCESS (status))
	      {
d3558 2
a3559 2
		system_printf ("NtNotifyChangeDirectoryFile (2) failed, %p",
			       status);
d3561 6
a3566 6
		NtClose (changed_h);
		changed_h = INVALID_HANDLE_VALUE;
	      }
	    memset (change_possible, true, sizeof change_possible);
	  }
      }
d3568 56
a3623 4
    paranoid_printf ("fn[%d] %S change_possible %d",
		     n, fn[n].ObjectName, change_possible[n]);
    return change_possible[n];
  }
d3625 48
a3672 100
  bool
  etc::file_changed (int n)
  {
    bool res = false;
    if (dir_changed (n) && test_file_change (n))
      res = true;
    change_possible[n] = false;	/* Change is no longer possible */
    paranoid_printf ("fn[%d] %S res %d", n, fn[n].ObjectName, res);
    return res;
  }

  /* No need to be reentrant or thread-safe according to SUSv3.
     / and \\ are treated equally.  Leading drive specifiers are
     kept intact as far as it makes sense.  Everything else is
     POSIX compatible. */
  extern "C" char *
  basename (char *path)
  {
    static char buf[4];
    char *c, *d, *bs = path;

    if (!path || !*path)
      return strcpy (buf, ".");
    if (isalpha (path[0]) && path[1] == ':')
      bs += 2;
    else if (strspn (path, "/\\") > 1)
      ++bs;
    c = strrchr (bs, '/');
    if ((d = strrchr (c ?: bs, '\\')) > c)
      c = d;
    if (c)
      {
	/* Trailing (back)slashes are eliminated. */
	while (c && c > bs && c[1] == '\0')
	  {
	    *c = '\0';
	    c = strrchr (bs, '/');
	    if ((d = strrchr (c ?: bs, '\\')) > c)
	      c = d;
	  }
	if (c && (c > bs || c[1]))
	  return c + 1;
      }
    else if (!bs[0])
      {
	stpncpy (buf, path, bs - path);
	stpcpy (buf + (bs - path), ".");
	return buf;
      }
    return path;
  }

  /* No need to be reentrant or thread-safe according to SUSv3.
     / and \\ are treated equally.  Leading drive specifiers and
     leading double (back)slashes are kept intact as far as it
     makes sense.  Everything else is POSIX compatible. */
  extern "C" char *
  dirname (char *path)
  {
    static char buf[4];
    char *c, *d, *bs = path;

    if (!path || !*path)
      return strcpy (buf, ".");
    if (isalpha (path[0]) && path[1] == ':')
      bs += 2;
    else if (strspn (path, "/\\") > 1)
      ++bs;
    c = strrchr (bs, '/');
    if ((d = strrchr (c ?: bs, '\\')) > c)
      c = d;
    if (c)
      {
	/* Trailing (back)slashes are eliminated. */
	while (c && c > bs && c[1] == '\0')
	  {
	    *c = '\0';
	    c = strrchr (bs, '/');
	    if ((d = strrchr (c ?: bs, '\\')) > c)
	      c = d;
	  }
	if (!c)
	  strcpy (bs, ".");
	else if (c > bs)
	  {
	    /* More trailing (back)slashes are eliminated. */
	    while (c > bs && (*c == '/' || *c == '\\'))
	      *c-- = '\0';
	  }
	else
	  c[1] = '\0';
      }
    else
      {
	stpncpy (buf, path, bs - path);
	stpcpy (buf + (bs - path), ".");
	return buf;
      }
    return path;
  }
@


1.504
log
@	* path.cc (cygwin_conv_path): Define tp before setting up faul handler.
	* syscalls.cc: Ditto, throughout.
	(gen_full_path_at): Add bool parameter to allow NULL pathname.
	(futimesat): Allow NULL pathname as GLIBC.
@
text
@d1 1
a1 1
/* path.cc: path support.
d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2008 Red Hat, Inc.
d6 1
a6 1
This file is part of Cygwin.
d8 42
a49 42
This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

/* This module's job is to
   - convert between POSIX and Win32 style filenames,
   - support the `mount' functionality,
   - support symlinks for files and directories

   Pathnames are handled as follows:

   - A \ or : in a path denotes a pure windows spec.
   - Paths beginning with // (or \\) are not translated (i.e. looked
     up in the mount table) and are assumed to be UNC path names.

   The goal in the above set of rules is to allow both POSIX and Win32
   flavors of pathnames without either interfering.  The rules are
   intended to be as close to a superset of both as possible.

   Note that you can have more than one path to a file.  The mount
   table is always prefered when translating Win32 paths to POSIX
   paths.  Win32 paths in mount table entries may be UNC paths or
   standard Win32 paths starting with <drive-letter>:

   Text vs Binary issues are not considered here in path style
   decisions, although the appropriate flags are retrieved and
   stored in various structures.

   Removing mounted filesystem support would simplify things greatly,
   but having it gives us a mechanism of treating disk that lives on a
   UNIX machine as having UNIX semantics [it allows one to edit a text
   file on that disk and not have cr's magically appear and perhaps
   break apps running on UNIX boxes].  It also useful to be able to
   layout a hierarchy without changing the underlying directories.

   The semantics of mounting file systems is not intended to precisely
   follow normal UNIX systems.

   Each DOS drive is defined to have a current directory.  Supporting
   this would complicate things so for now things are defined so that
   c: means c:\.
*/
d75 33
a107 1
bool dos_file_warning = true;
d109 11
a119 63
struct symlink_info
{
  char contents[SYMLINK_MAX + 1];
  char *ext_here;
  int extn;
  unsigned pflags;
  DWORD fileattr;
  int issymlink;
  bool ext_tacked_on;
  int error;
  bool case_clash;
  bool isdevice;
  _major_t major;
  _minor_t minor;
  _mode_t mode;
  int check (char *path, const suffix_info *suffixes, unsigned opt,
	     fs_info &fs);
  int set (char *path);
  bool parse_device (const char *);
  bool case_check (char *path);
  int check_sysfile (HANDLE h);
  int check_shortcut (HANDLE h);
  int check_reparse_point (HANDLE h);
  int check_nfs_symlink (HANDLE h);
  int posixify (char *srcbuf);
  bool set_error (int);
};

muto NO_COPY cwdstuff::cwd_lock;

int pcheck_case = PCHECK_RELAXED; /* Determines the case check behaviour. */

static const GUID GUID_shortcut
			= { 0x00021401L, 0, 0, 0xc0, 0, 0, 0, 0, 0, 0, 0x46 };

enum {
  WSH_FLAG_IDLIST = 0x01,	/* Contains an ITEMIDLIST. */
  WSH_FLAG_FILE = 0x02,		/* Contains a file locator element. */
  WSH_FLAG_DESC = 0x04,		/* Contains a description. */
  WSH_FLAG_RELPATH = 0x08,	/* Contains a relative path. */
  WSH_FLAG_WD = 0x10,		/* Contains a working dir. */
  WSH_FLAG_CMDLINE = 0x20,	/* Contains command line args. */
  WSH_FLAG_ICON = 0x40		/* Contains a custom icon. */
};

struct win_shortcut_hdr
  {
    DWORD size;		/* Header size in bytes.  Must contain 0x4c. */
    GUID magic;		/* GUID of shortcut files. */
    DWORD flags;	/* Content flags.  See above. */

    /* The next fields from attr to icon_no are always set to 0 in Cygwin
       and U/Win shortcuts. */
    DWORD attr;	/* Target file attributes. */
    FILETIME ctime;	/* These filetime items are never touched by the */
    FILETIME mtime;	/* system, apparently. Values don't matter. */
    FILETIME atime;
    DWORD filesize;	/* Target filesize. */
    DWORD icon_no;	/* Icon number. */

    DWORD run;		/* Values defined in winuser.h. Use SW_NORMAL. */
    DWORD hotkey;	/* Hotkey value. Set to 0.  */
    DWORD dummy[2];	/* Future extension probably. Always 0. */
d122 57
a178 69
/* Return non-zero if PATH1 is a prefix of PATH2.
   Both are assumed to be of the same path style and / vs \ usage.
   Neither may be "".
   LEN1 = strlen (PATH1).  It's passed because often it's already known.

   Examples:
   /foo/ is a prefix of /foo  <-- may seem odd, but desired
   /foo is a prefix of /foo/
   / is a prefix of /foo/bar
   / is not a prefix of foo/bar
   foo/ is a prefix foo/bar
   /foo is not a prefix of /foobar
*/

int
path_prefix_p (const char *path1, const char *path2, int len1)
{
  /* Handle case where PATH1 has trailing '/' and when it doesn't.  */
  if (len1 > 0 && isdirsep (path1[len1 - 1]))
    len1--;

  if (len1 == 0)
    return isdirsep (path2[0]) && !isdirsep (path2[1]);

  if (isdirsep (path2[len1]) || path2[len1] == 0 || path1[len1 - 1] == ':')
    return pathnmatch (path1, path2, len1);

  return 0;
}

/* Return non-zero if paths match in first len chars.
   Check is dependent of the case sensitivity setting. */
int
pathnmatch (const char *path1, const char *path2, int len)
{
  return pcheck_case == PCHECK_STRICT ? !strncmp (path1, path2, len)
				      : strncasematch (path1, path2, len);
}

/* Return non-zero if paths match. Check is dependent of the case
   sensitivity setting. */
int
pathmatch (const char *path1, const char *path2)
{
  return pcheck_case == PCHECK_STRICT ? !strcmp (path1, path2)
				      : strcasematch (path1, path2);
}

/* TODO: This function is used in mkdir and rmdir to generate correct
   error messages in case of paths ending in /. or /.. components.
   Right now, normalize_posix_path will just normalize
   those components away, which changes the semantics.  */
bool
has_dot_last_component (const char *dir, bool test_dot_dot)
{
  /* SUSv3: . and .. are not allowed as last components in various system
     calls.  Don't test for backslash path separator since that's a Win32
     path following Win32 rules. */
  const char *last_comp = strrchr (dir, '/');
  if (!last_comp)
    last_comp = dir;
  else {
    /* Check for trailing slash.  If so, hop back to the previous slash. */
    if (!last_comp[1])
      while (last_comp > dir)
	if (*--last_comp == '/')
	  break;
    if (*last_comp == '/')
      ++last_comp;
a179 17
  return last_comp[0] == '.'
	 && ((last_comp[1] == '\0' || last_comp[1] == '/')
	     || (test_dot_dot
		 && last_comp[1] == '.'
		 && (last_comp[2] == '\0' || last_comp[2] == '/')));
}

/* Normalize a POSIX path.
   All duplicate /'s, except for 2 leading /'s, are deleted.
   The result is 0 for success, or an errno error value.  */

int
normalize_posix_path (const char *src, char *dst, char *&tail)
{
  const char *in_src = src;
  char *dst_start = dst;
  syscall_printf ("src %s", src);
d181 8
a188 2
  if ((isdrive (src) && isdirsep (src[2])) || *src == '\\')
    goto win32_path;
d190 21
a210 22
  tail = dst;
  if (!isslash (src[0]))
    {
      if (!cygheap->cwd.get (dst))
	return get_errno ();
      tail = strchr (tail, '\0');
      if (isslash (dst[0]) && isslash (dst[1]))
	++dst_start;
      if (*src == '.')
	{
	  if (tail == dst_start + 1 && *dst_start == '/')
	     tail--;
	  goto sawdot;
	}
      if (tail > dst && !isslash (tail[-1]))
	*tail++ = '/';
    }
  /* Two leading /'s?  If so, preserve them.  */
  else if (isslash (src[1]) && !isslash (src[2]))
    {
      *tail++ = *src++;
      ++dst_start;
d212 10
d223 30
a252 6
  while (*src)
    {
      if (*src == '\\')
	goto win32_path;
      /* Strip runs of /'s.  */
      if (!isslash (*src))
d254 44
a297 3
      else
	{
	  while (*++src)
d299 10
a308 2
	      if (isslash (*src))
		continue;
d310 7
a316 2
	      if (*src != '.')
		break;
d318 10
a327 20
	    sawdot:
	      if (src[1] != '.')
		{
		  if (!src[1])
		    {
		      *tail++ = '/';
		      goto done;
		    }
		  if (!isslash (src[1]))
		    break;
		}
	      else if (src[2] && !isslash (src[2]))
		break;
	      else
		{
		  while (tail > dst_start && !isslash (*--tail))
		    continue;
		  src++;
		}
	    }
d329 8
a336 8
	  *tail++ = '/';
	}
	if ((tail - dst) >= NT_MAX_PATH)
	  {
	    debug_printf ("ENAMETOOLONG = normalize_posix_path (%s)", src);
	    return ENAMETOOLONG;
	  }
    }
d338 3
a340 2
done:
  *tail = '\0';
d342 3
a344 2
  debug_printf ("%s = normalize_posix_path (%s)", dst, in_src);
  return 0;
d346 10
a355 18
win32_path:
  int err = normalize_win32_path (in_src, dst, tail);
  if (!err)
    for (char *p = dst; (p = strchr (p, '\\')); p++)
      *p = '/';
  return err ?: -1;
}

inline void
path_conv::add_ext_from_sym (symlink_info &sym)
{
  if (sym.ext_here && *sym.ext_here)
    {
      known_suffix = path + sym.extn;
      if (sym.ext_tacked_on)
	strcpy (known_suffix, sym.ext_here);
    }
}
d357 4
a360 32
static void __stdcall mkrelpath (char *dst) __attribute__ ((regparm (2)));
static void __stdcall
mkrelpath (char *path)
{
  tmp_pathbuf tp;
  char *cwd_win32 = tp.c_get ();
  if (!cygheap->cwd.get (cwd_win32, 0))
    return;

  unsigned cwdlen = strlen (cwd_win32);
  if (!path_prefix_p (cwd_win32, path, cwdlen))
    return;

  size_t n = strlen (path);
  if (n < cwdlen)
    return;

  char *tail = path;
  if (n == cwdlen)
    tail += cwdlen;
  else
    tail += isdirsep (cwd_win32[cwdlen - 1]) ? cwdlen : cwdlen + 1;

  memmove (path, tail, strlen (tail) + 1);
  if (!*path)
    strcpy (path, ".");
}

/* Beginning with Samba 3.0.28a, Samba allows to get version information using
   the ExtendedInfo member returned by a FileFsObjectIdInformation request.
   We just store the samba_version information for now.  Older versions than
   3.2 are still guessed at by testing the file system flags. */
d364 7
a370 7
struct smb_extended_info {
  DWORD         samba_magic;             /* Always SAMBA_EXTENDED_INFO_MAGIC */
  DWORD         samba_version;           /* Major/Minor/Release/Revision */
  DWORD         samba_subversion;        /* Prerelease/RC/Vendor patch */
  LARGE_INTEGER samba_gitcommitdate;
  char          samba_version_string[SAMBA_EXTENDED_INFO_VERSION_STRING_LENGTH];
};
d373 83
a455 51
bool
fs_info::update (PUNICODE_STRING upath, HANDLE in_vol)
{
  NTSTATUS status = STATUS_OBJECT_NAME_NOT_FOUND;
  HANDLE vol;
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;
  bool no_media = false;
  FILE_FS_DEVICE_INFORMATION ffdi;
  FILE_FS_OBJECTID_INFORMATION ffoi;
  struct {
    FILE_FS_ATTRIBUTE_INFORMATION ffai;
    WCHAR buf[NAME_MAX + 1];
  } ffai_buf;
  struct {
    FILE_FS_VOLUME_INFORMATION ffvi;
    WCHAR buf[NAME_MAX + 1];
  } ffvi_buf;
  UNICODE_STRING fsname, testname;

  if (in_vol)
    vol = in_vol;
  else
    {
      InitializeObjectAttributes (&attr, upath, OBJ_CASE_INSENSITIVE, NULL,
      				  NULL);
      status = NtOpenFile (&vol, READ_CONTROL, &attr, &io,
			   FILE_SHARE_VALID_FLAGS, FILE_OPEN_FOR_BACKUP_INTENT);
      while (!NT_SUCCESS (status)
	     && (attr.ObjectName->Length > 7 * sizeof (WCHAR)
		 || status == STATUS_NO_MEDIA_IN_DEVICE))
	{
	  UNICODE_STRING dir;
	  RtlSplitUnicodePath (attr.ObjectName, &dir, NULL);
	  attr.ObjectName = &dir;
	  if (status == STATUS_NO_MEDIA_IN_DEVICE)
	    {
	      no_media = true;
	      dir.Length = 6 * sizeof (WCHAR);
	    }
	  else if (dir.Length > 7 * sizeof (WCHAR))
	    dir.Length -= sizeof (WCHAR);
	  status = NtOpenFile (&vol, READ_CONTROL, &attr, &io,
			       FILE_SHARE_VALID_FLAGS,
			       FILE_OPEN_FOR_BACKUP_INTENT);
	}
      if (!NT_SUCCESS (status))
	{
	  debug_printf ("Cannot access path %S, status %08lx",
	  		attr.ObjectName, status);
	  clear ();
d457 9
a465 41
	  return false;
	}
    }

  status = NtQueryVolumeInformationFile (vol, &io, &ffvi_buf.ffvi,
  					 sizeof ffvi_buf,
					 FileFsVolumeInformation);
  sernum = NT_SUCCESS (status) ? ffvi_buf.ffvi.VolumeSerialNumber : 0;
  status = NtQueryVolumeInformationFile (vol, &io, &ffdi, sizeof ffdi,
					 FileFsDeviceInformation);
  if (!NT_SUCCESS (status))
    ffdi.DeviceType = ffdi.Characteristics = 0;

  if (ffdi.Characteristics & FILE_REMOTE_DEVICE
      || (!ffdi.DeviceType
	  && RtlEqualUnicodePathPrefix (attr.ObjectName, L"\\??\\UNC\\", TRUE)))
    is_remote_drive (true);
  else
    is_remote_drive (false);

  if (!no_media)
    status = NtQueryVolumeInformationFile (vol, &io, &ffai_buf.ffai,
					   sizeof ffai_buf,
					   FileFsAttributeInformation);
  if (no_media || !NT_SUCCESS (status))
    {
      debug_printf ("Cannot get volume attributes (%S), %08lx",
		    attr.ObjectName, status);
      has_buggy_open (false);
      flags (0);
      if (!in_vol)
	NtClose (vol);
      return false;
    }
   flags (ffai_buf.ffai.FileSystemAttributes);
   name_len (ffai_buf.ffai.MaximumComponentNameLength);
/* Should be reevaluated for each new OS.  Right now this mask is valid up
   to Vista.  The important point here is to test only flags indicating
   capabilities and to ignore flags indicating a specific state of this
   volume.  At present these flags to ignore are FILE_VOLUME_IS_COMPRESSED
   and FILE_READ_ONLY_VOLUME. */
d469 2
a470 2
/* Volume quotas are potentially supported since Samba 3.0, object ids and
   the unicode on disk flag since Samba 3.2. */
d472 2
a473 2
		      | FILE_SUPPORTS_OBJECT_IDS \
		      | FILE_UNICODE_ON_DISK)
d475 3
a477 3
			     FILE_CASE_SENSITIVE_SEARCH \
			     | FILE_CASE_PRESERVED_NAMES \
			     | FILE_PERSISTENT_ACLS)
d479 59
a537 66
			     FILE_CASE_SENSITIVE_SEARCH \
			     | FILE_CASE_PRESERVED_NAMES \
			     | FILE_UNICODE_ON_DISK \
			     | FILE_PERSISTENT_ACLS \
			     | FILE_NAMED_STREAMS)
  RtlInitCountedUnicodeString (&fsname, ffai_buf.ffai.FileSystemName,
			       ffai_buf.ffai.FileSystemNameLength);
  is_fat (RtlEqualUnicodePathPrefix (&fsname, L"FAT", TRUE));
  RtlInitUnicodeString (&testname, L"NTFS");
  if (is_remote_drive ())
    {
      /* This always fails on NT4. */
      status = NtQueryVolumeInformationFile (vol, &io, &ffoi, sizeof ffoi,
					     FileFsObjectIdInformation);
      if (NT_SUCCESS (status))
	{
	  smb_extended_info *extended_info = (smb_extended_info *)
					     &ffoi.ExtendedInfo;
	  if (extended_info->samba_magic == SAMBA_EXTENDED_INFO_MAGIC)
	    {
	      is_samba (true);
	      samba_version (extended_info->samba_version);
	    }
	}
      /* Test for Samba on NT4 or for older Samba releases not supporting
	 extended info. */
      if (!is_samba ())
	is_samba (RtlEqualUnicodeString (&fsname, &testname, FALSE)
		  && FS_IS_SAMBA);

      is_netapp (!is_samba ()
		 && RtlEqualUnicodeString (&fsname, &testname, FALSE)
		 && FS_IS_NETAPP_DATAONTAP);
    }
  is_ntfs (RtlEqualUnicodeString (&fsname, &testname, FALSE)
	   && !is_samba () && !is_netapp ());
  RtlInitUnicodeString (&testname, L"NFS");
  is_nfs (RtlEqualUnicodeString (&fsname, &testname, FALSE));
  is_cdrom (ffdi.DeviceType == FILE_DEVICE_CD_ROM);

  has_acls ((flags () & FS_PERSISTENT_ACLS)
	    && (allow_smbntsec || !is_remote_drive ()));
  hasgood_inode (((flags () & FILE_PERSISTENT_ACLS) && !is_netapp ())
		 || is_nfs ());
  /* Known file systems with buggy open calls. Further explanation
     in fhandler.cc (fhandler_disk_file::open). */
  RtlInitUnicodeString (&testname, L"SUNWNFS");
  has_buggy_open (RtlEqualUnicodeString (&fsname, &testname, FALSE));

  if (!in_vol)
    NtClose (vol);
  return true;
}

void
path_conv::fillin (HANDLE h)
{
  IO_STATUS_BLOCK io;
  FILE_BASIC_INFORMATION fbi;

  if (NT_SUCCESS (NtQueryInformationFile (h, &io, &fbi, sizeof fbi,
					  FileBasicInformation)))
    fileattr = fbi.FileAttributes;
  else
    fileattr = INVALID_FILE_ATTRIBUTES;
}
d539 6
a544 16
void
path_conv::set_normalized_path (const char *path_copy)
{
  char *p = strchr (path_copy, '\0');
  size_t n = 1 + p - path_copy;

  normalized_path = path + sizeof (path) - n;

  char *eopath = strchr (path, '\0');
  if (normalized_path > eopath)
    normalized_path_size = n;
  else
    {
      normalized_path = (char *) cmalloc_abort (HEAP_STR, n);
      normalized_path_size = 0;
    }
d546 5
a550 2
  memcpy (normalized_path, path_copy, n);
}
d552 1
a552 56
WCHAR tfx_chars[] NO_COPY = {
   0,   1,   2,   3,   4,   5,   6,   7,
   8,   9,  10,  11,  12,  13,  14,  15,
  16,  17,  18,  19,  20,  21,  22,  23,
  24,  25,  26,  27,  28,  29,  30,  31,
  32, '!', 0xf000 | '"', '#', '$', '%', '&',  39,
  '(', ')', 0xf000 | '*', '+', ',', '-', '.', '/',
 '0', '1', '2', '3', '4', '5', '6', '7',
 '8', '9', 0xf000 | ':', ';', 0xf000 | '<', '=', 0xf000 | '>', 0xf000 | '?',
 '@@', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
 'X', 'Y', 'Z', '[',  '\\', ']', '^', '_',
 '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',
 'x', 'y', 'z', '{', 0xf000 | '|', '}', '~', 127
};

WCHAR tfx_chars_managed[] NO_COPY = {
   0,   1,   2,   3,   4,   5,   6,   7,
   8,   9,  10,  11,  12,  13,  14,  15,
  16,  17,  18,  19,  20,  21,  22,  23,
  24,  25,  26,  27,  28,  29,  30,  31,
  32, '!', 0xf000 | '"', '#', '$', '%', '&',  39,
  '(', ')', 0xf000 | '*', '+', ',', '-', '.', '/',
 '0', '1', '2', '3', '4', '5', '6', '7',
 '8', '9', 0xf000 | ':', ';', 0xf000 | '<', '=', 0xf000 | '>', 0xf000 | '?',
 '@@', 0xf000 | 'A', 0xf000 | 'B', 0xf000 | 'C', 0xf000 | 'D', 0xf000 | 'E', 0xf000 | 'F', 0xf000 | 'G',
 0xf000 | 'H', 0xf000 | 'I', 0xf000 | 'J', 0xf000 | 'K', 0xf000 | 'L', 0xf000 | 'M', 0xf000 | 'N', 0xf000 | 'O',
 0xf000 | 'P', 0xf000 | 'Q', 0xf000 | 'R', 0xf000 | 'S', 0xf000 | 'T', 0xf000 | 'U', 0xf000 | 'V', 0xf000 | 'W',
 0xf000 | 'X', 0xf000 | 'Y', 0xf000 | 'Z', '[',  '\\', ']', '^', '_',
 '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',
 'x', 'y', 'z', '{', 0xf000 | '|', '}', '~', 127
};

static void
transform_chars (PUNICODE_STRING upath, USHORT start_idx, bool managed)
{
  register PWCHAR buf = upath->Buffer;
  register PWCHAR end = buf + upath->Length / sizeof (WCHAR) - 1;
  register PWCHAR tfx = managed ? tfx_chars_managed : tfx_chars;
  for (buf += start_idx; buf <= end; ++buf)
    if (*buf < 128)
      *buf = tfx[*buf];
#if 0
  /* Win32 can't handle trailing dots and spaces.  Transform the last of them
     to the private use area, too, to create a valid Win32 filename. */
  if (*end == L'\\')
    --end;
  if (*end == L'.' || *end == L' ')
    *end |= 0xf000;
#endif
}
d554 8
a561 28
PUNICODE_STRING
get_nt_native_path (const char *path, UNICODE_STRING& upath, bool managed)
{
  upath.Length = 0;
  if (path[0] == '/')		/* special path w/o NT path representation. */
    str2uni_cat (upath, path);
  else if (path[0] != '\\')	/* X:\...  or NUL, etc. */
    {
      str2uni_cat (upath, "\\??\\");
      str2uni_cat (upath, path);
      transform_chars (&upath, 7, managed);
    }
  else if (path[1] != '\\')	/* \Device\... */
    str2uni_cat (upath, path);
  else if ((path[2] != '.' && path[2] != '?')
	   || path[3] != '\\')	/* \\server\share\... */
    {
      str2uni_cat (upath, "\\??\\UNC\\");
      str2uni_cat (upath, path + 2);
      transform_chars (&upath, 8, managed);
    }
  else				/* \\.\device or \\?\foo */
    {
      str2uni_cat (upath, "\\??\\");
      str2uni_cat (upath, path + 4);
    }
  return &upath;
}
d563 2
a564 13
PUNICODE_STRING
path_conv::get_nt_native_path ()
{
  if (!wide_path)
    {
      uni_path.Length = 0;
      uni_path.MaximumLength = (strlen (path) + 10) * sizeof (WCHAR);
      wide_path = (PWCHAR) cmalloc_abort (HEAP_STR, uni_path.MaximumLength);
      uni_path.Buffer = wide_path;
      ::get_nt_native_path (path, uni_path, isencoded ());
    }
  return &uni_path;
}
d566 18
a583 61
POBJECT_ATTRIBUTES
path_conv::get_object_attr (OBJECT_ATTRIBUTES &attr, SECURITY_ATTRIBUTES &sa)
{
  if (!get_nt_native_path ())
    return NULL;
  InitializeObjectAttributes (&attr, &uni_path,
			      OBJ_CASE_INSENSITIVE
			      | (sa.bInheritHandle ? OBJ_INHERIT : 0),
			      NULL, sa.lpSecurityDescriptor);
  return &attr;
}

PWCHAR
path_conv::get_wide_win32_path (PWCHAR wc)
{
  get_nt_native_path ();
  if (!wide_path || wide_path[1] != L'?') /* Native NT device path */
    return NULL;
  wcscpy (wc, wide_path);
  wc[1] = L'\\';
  return wc;
}

void
warn_msdos (const char *src)
{
  if (user_shared->warned_msdos || !dos_file_warning)
    return;
  tmp_pathbuf tp;
  char *posix_path = tp.c_get ();
  small_printf ("cygwin warning:\n");
  if (cygwin_conv_path (CCP_WIN_A_TO_POSIX | CCP_RELATIVE, src,
			posix_path, NT_MAX_PATH))
    small_printf ("  MS-DOS style path detected: %s\n  POSIX equivalent preferred.\n",
		  src);
  else
    small_printf ("  MS-DOS style path detected: %s\n  Preferred POSIX equivalent is: %s\n",
		  src, posix_path);
  small_printf ("  CYGWIN environment variable option \"nodosfilewarning\" turns off this warning.\n"
		"  Consult the user's guide for more details about POSIX paths:\n"
		"    http://cygwin.com/cygwin-ug-net/using.html#using-pathnames\n");
  user_shared->warned_msdos = true;
}

static DWORD
getfileattr (const char *path, bool managed) /* path has to be always absolute. */
{
  tmp_pathbuf tp;
  UNICODE_STRING upath;
  OBJECT_ATTRIBUTES attr;
  FILE_BASIC_INFORMATION fbi;
  NTSTATUS status;
  IO_STATUS_BLOCK io;

  tp.u_get (&upath);
  InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE, NULL, NULL);
  get_nt_native_path (path, upath, managed);

  status = NtQueryAttributesFile (&attr, &fbi);
  if (NT_SUCCESS (status))
    return fbi.FileAttributes;
d585 18
a602 78
  if (status != STATUS_OBJECT_NAME_NOT_FOUND
      && status != STATUS_NO_SUCH_FILE) /* File not found on 9x share */
    {
      /* File exists but access denied.  Try to get attribute through
         directory query. */
      UNICODE_STRING dirname, basename;
      HANDLE dir;
      FILE_DIRECTORY_INFORMATION fdi;

      RtlSplitUnicodePath (&upath, &dirname, &basename);
      InitializeObjectAttributes (&attr, &dirname,
				  OBJ_CASE_INSENSITIVE, NULL, NULL);
      status = NtOpenFile (&dir, SYNCHRONIZE | FILE_LIST_DIRECTORY,
			   &attr, &io, FILE_SHARE_VALID_FLAGS,
			   FILE_SYNCHRONOUS_IO_NONALERT
			   | FILE_OPEN_FOR_BACKUP_INTENT
			   | FILE_DIRECTORY_FILE);
      if (NT_SUCCESS (status))
	{
	  status = NtQueryDirectoryFile (dir, NULL, NULL, 0, &io,
					 &fdi, sizeof fdi,
					 FileDirectoryInformation,
					 TRUE, &basename, TRUE);
	  NtClose (dir);
	  if (NT_SUCCESS (status) || status == STATUS_BUFFER_OVERFLOW)
	    return fdi.FileAttributes;
	}
    }
  SetLastError (RtlNtStatusToDosError (status));
  return INVALID_FILE_ATTRIBUTES;
}

/* Convert an arbitrary path SRC to a pure Win32 path, suitable for
   passing to Win32 API routines.

   If an error occurs, `error' is set to the errno value.
   Otherwise it is set to 0.

   follow_mode values:
	SYMLINK_FOLLOW	    - convert to PATH symlink points to
	SYMLINK_NOFOLLOW    - convert to PATH of symlink itself
	SYMLINK_IGNORE	    - do not check PATH for symlinks
	SYMLINK_CONTENTS    - just return symlink contents
*/

/* TODO: This implementation is only preliminary.  For internal
   purposes it's necessary to have a path_conv::check function which
   takes a UNICODE_STRING src path, otherwise we waste a lot of time
   for converting back and forth.  The below implementation does
   realy nothing but converting to char *, until path_conv handles
   wide-char paths directly. */
void
path_conv::check (const UNICODE_STRING *src, unsigned opt,
		  const suffix_info *suffixes)
{
  tmp_pathbuf tp;
  char *path = tp.c_get ();

  user_shared->warned_msdos = true;
  sys_wcstombs (path, NT_MAX_PATH, src->Buffer, src->Length / sizeof (WCHAR));
  path_conv::check (path, opt, suffixes);
}

void
path_conv::check (const char *src, unsigned opt,
		  const suffix_info *suffixes)
{
  /* The tmp_buf array is used when expanding symlinks.  It is NT_MAX_PATH * 2
     in length so that we can hold the expanded symlink plus a trailer.  */
  tmp_pathbuf tp;
  char *path_copy = tp.c_get ();
  char *pathbuf = tp.c_get ();
  char *tmp_buf = tp.t_get ();
  symlink_info sym;
  bool need_directory = 0;
  bool saw_symlinks = 0;
  bool is_relpath;
  char *tail, *path_end;
d604 9
d614 51
a664 2
  static path_conv last_path_conv;
  static char last_src[CYG_MAX_PATH];
d666 11
a676 6
  if (*last_src && strcmp (last_src, src) == 0)
    {
      *this = last_path_conv;
      return;
    }
#endif
d678 10
a687 20
  myfault efault;
  if (efault.faulted ())
    {
      error = EFAULT;
      return;
    }
  int loop = 0;
  path_flags = 0;
  known_suffix = NULL;
  fileattr = INVALID_FILE_ATTRIBUTES;
  if (wide_path)
    cfree (wide_path);
  wide_path = NULL;
  case_clash = false;
  memset (&dev, 0, sizeof (dev));
  fs.clear ();
  if (!normalized_path_size && normalized_path)
    cfree (normalized_path);
  normalized_path = NULL;
  int component = 0;		// Number of translated components
d689 4
a692 5
  if (!(opt & PC_NULLEMPTY))
    error = 0;
  else if (!*src)
    {
      error = ENOENT;
d694 15
a708 1
    }
d710 49
a758 6
  bool is_msdos = false;
  /* This loop handles symlink expansion.  */
  for (;;)
    {
      MALLOC_CHECK;
      assert (src);
d760 2
a761 10
      is_relpath = !isabspath (src);
      error = normalize_posix_path (src, path_copy, tail);
      if (error > 0)
	return;
      if (error < 0)
	{
	  if (component == 0)
	    is_msdos = true;
	  error = 0;
	}
d763 2
a764 9
      /* Detect if the user was looking for a directory.  We have to strip the
	 trailing slash initially while trying to add extensions but take it
	 into account during processing */
      if (tail > path_copy + 2 && isslash (tail[-1]))
	{
	  need_directory = 1;
	  *--tail = '\0';
	}
      path_end = tail;
d766 6
a771 30
      /* Scan path_copy from right to left looking either for a symlink
	 or an actual existing file.  If an existing file is found, just
	 return.  If a symlink is found, exit the for loop.
	 Also: be careful to preserve the errno returned from
	 symlink.check as the caller may need it. */
      /* FIXME: Do we have to worry about multiple \'s here? */
      component = 0;		// Number of translated components
      sym.contents[0] = '\0';

      int symlen = 0;

      for (unsigned pflags_or = opt & PC_NO_ACCESS_CHECK; ; pflags_or = 0)
	{
	  const suffix_info *suff;
	  char *full_path;

	  /* Don't allow symlink.check to set anything in the path_conv
	     class if we're working on an inner component of the path */
	  if (component)
	    {
	      suff = NULL;
	      sym.pflags = 0;
	      full_path = pathbuf;
	    }
	  else
	    {
	      suff = suffixes;
	      sym.pflags = path_flags;
	      full_path = this->path;
	    }
d773 12
a784 3
	  /* Convert to native path spec sans symbolic link info. */
	  error = mount_table->conv_to_win32_path (path_copy, full_path, dev,
						   &sym.pflags);
d786 4
a789 2
	  if (error)
	    return;
d791 15
a805 1
	  sym.pflags |= pflags_or;
a806 14
	  if (dev.major == DEV_CYGDRIVE_MAJOR)
	    {
	      if (!component)
		fileattr = FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_READONLY;
	      else
		{
		  fileattr = getfileattr (this->path, sym.pflags & MOUNT_ENC);
		  dev.devn = FH_FS;
		}
	      goto out;
	    }
	  else if (dev == FH_DEV)
	    {
	      dev.devn = FH_FS;
d808 8
a815 6
	      fileattr = getfileattr (this->path, sym.pflags & MOUNT_ENC);
	      if (!component && fileattr == INVALID_FILE_ATTRIBUTES)
		{
		  fileattr = FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_READONLY;
		  goto out;
		}
a816 60
	    }
	  else if (isvirtual_dev (dev.devn))
	    {
	      /* FIXME: Calling build_fhandler here is not the right way to handle this. */
	      fhandler_virtual *fh = (fhandler_virtual *) build_fh_dev (dev, path_copy);
	      int file_type = fh->exists ();
	      if (file_type == -2)
		{
		  fh->fill_filebuf ();
		  symlen = sym.set (fh->get_filebuf ());
		}
	      delete fh;
	      switch (file_type)
		{
		  case 1:
		  case 2:
		    if (component == 0)
		      fileattr = FILE_ATTRIBUTE_DIRECTORY;
		    break;
		  case -1:
		    if (component == 0)
		      fileattr = 0;
		    break;
		  case -2:	/* /proc/self or /proc/<pid>/symlinks */
		    goto is_virtual_symlink;
		  case -3:	/* /proc/<pid>/fd/pipe:[] */
		    if (component == 0)
		      {
			fileattr = 0;
			dev.parse (FH_PIPE);
		      }
		    break;
		  case -4:	/* /proc/<pid>/fd/socket:[] */
		    if (component == 0)
		      {
			fileattr = 0;
			dev.parse (FH_TCP);
		      }
		    break;
		  default:
		    if (component == 0)
		      fileattr = INVALID_FILE_ATTRIBUTES;
		    goto virtual_component_retry;
		}
	      if (component == 0 || dev.devn != FH_NETDRIVE)
		path_flags |= PATH_RO;
	      goto out;
	    }
	  /* devn should not be a device.  If it is, then stop parsing now. */
	  else if (dev.devn != FH_FS)
	    {
	      fileattr = 0;
	      path_flags = sym.pflags;
	      if (component)
		{
		  error = ENOTDIR;
		  return;
		}
	      goto out;		/* Found a device.  Stop parsing. */
	    }
d818 28
a845 9
	  /* If path is only a drivename, Windows interprets it as the
	     current working directory on this drive instead of the root
	     dir which is what we want. So we need the trailing backslash
	     in this case. */
	  if (full_path[0] && full_path[1] == ':' && full_path[2] == '\0')
	    {
	      full_path[2] = '\\';
	      full_path[3] = '\0';
	    }
d847 17
a863 1
	  symlen = sym.check (full_path, suff, opt, fs);
d865 9
a873 1
is_virtual_symlink:
d875 8
a882 8
	  if (sym.isdevice)
	    {
	      dev.parse (sym.major, sym.minor);
	      dev.setfs (1);
	      dev.mode = sym.mode;
	      fileattr = sym.fileattr;
	      goto out;
	    }
d884 1
a884 12
	  if (sym.pflags & PATH_SOCKET)
	    {
	      if (component)
		{
		  error = ENOTDIR;
		  return;
		}
	      fileattr = sym.fileattr;
	      dev.parse (FH_UNIX);
	      dev.setfs (1);
	      goto out;
	    }
d886 4
a889 22
	  if (sym.case_clash)
	    {
	      if (pcheck_case == PCHECK_STRICT)
		{
		  case_clash = true;
		  error = ENOENT;
		  goto out;
		}
	      /* If pcheck_case==PCHECK_ADJUST the case_clash is remembered
		 if the last component is concerned. This allows functions
		 which shall create files to avoid overriding already existing
		 files with another case. */
	      if (!component)
		case_clash = true;
	    }
	  if (!(opt & PC_SYM_IGNORE))
	    {
	      if (!component)
		{
		  fileattr = sym.fileattr;
		  path_flags = sym.pflags;
		}
d891 80
a970 31
	      /* If symlink.check found an existing non-symlink file, then
		 it sets the appropriate flag.  It also sets any suffix found
		 into `ext_here'. */
	      if (!sym.issymlink && sym.fileattr != INVALID_FILE_ATTRIBUTES)
		{
		  error = sym.error;
		  if (component == 0)
		    add_ext_from_sym (sym);
		  else if (!(sym.fileattr & FILE_ATTRIBUTE_DIRECTORY))
		    {
		      error = ENOTDIR;
		      goto out;
		    }
		  if (pcheck_case == PCHECK_RELAXED)
		    goto out;	// file found
		  /* Avoid further symlink evaluation. Only case checks are
		     done now. */
		  opt |= PC_SYM_IGNORE;
		}
	      /* Found a symlink if symlen > 0.  If component == 0, then the
		 src path itself was a symlink.  If !follow_mode then
		 we're done.  Otherwise we have to insert the path found
		 into the full path that we are building and perform all of
		 these operations again on the newly derived path. */
	      else if (symlen > 0)
		{
		  saw_symlinks = 1;
		  if (component == 0 && !need_directory && !(opt & PC_SYM_FOLLOW))
		    {
		      set_symlink (symlen); // last component of path is a symlink.
		      if (opt & PC_SYM_CONTENTS)
d972 2
a973 2
			  strcpy (path, sym.contents);
			  goto out;
d975 89
d1065 3
a1067 1
		      if (pcheck_case == PCHECK_RELAXED)
d1069 857
a1925 14
		      /* Avoid further symlink evaluation. Only case checks are
			 done now. */
		      opt |= PC_SYM_IGNORE;
		    }
		  else
		    break;
		}
	      else if (sym.error && sym.error != ENOENT && sym.error != ENOSHARE)
		{
		  error = sym.error;
		  goto out;
		}
	      /* No existing file found. */
	    }
d1927 4
a1930 16
virtual_component_retry:
	  /* Find the new "tail" of the path, e.g. in '/for/bar/baz',
	     /baz is the tail. */
	  if (tail != path_end)
	    *tail = '/';
	  while (--tail > path_copy + 1 && *tail != '/') {}
	  /* Exit loop if there is no tail or we are at the
	     beginning of a UNC path */
	  if (tail <= path_copy + 1)
	    goto out;	// all done

	  /* Haven't found an existing pathname component yet.
	     Pinch off the tail and try again. */
	  *tail = '\0';
	  component++;
	}
d1932 58
a1989 5
      /* Arrive here if above loop detected a symlink. */
      if (++loop > SYMLOOP_MAX)
	{
	  error = ELOOP;   // Eep.
	  return;
d1991 3
d1995 44
a2038 1
      MALLOC_CHECK;
d2040 31
d2072 39
a2110 1
      /* Place the link content, possibly with head and/or tail, in tmp_buf */
d2112 38
a2149 12
      char *headptr;
      if (isabspath (sym.contents))
	headptr = tmp_buf;	/* absolute path */
      else
	{
	  /* Copy the first part of the path (with ending /) and point to the end. */
	  char *prevtail = tail;
	  while (--prevtail > path_copy  && *prevtail != '/') {}
	  int headlen = prevtail - path_copy + 1;;
	  memcpy (tmp_buf, path_copy, headlen);
	  headptr = &tmp_buf[headlen];
	}
d2151 20
a2170 8
      /* Make sure there is enough space */
      if (headptr + symlen >= tmp_buf + (2 * NT_MAX_PATH))
	{
	too_long:
	  error = ENAMETOOLONG;
	  strcpy (path, "::ENAMETOOLONG::");
	  return;
	}
d2172 6
a2177 17
     /* Copy the symlink contents to the end of tmp_buf.
	Convert slashes. */
      for (char *p = sym.contents; *p; p++)
	*headptr++ = *p == '\\' ? '/' : *p;
      *headptr = '\0';

      /* Copy any tail component (with the 0) */
      if (tail++ < path_end)
	{
	  /* Add a slash if needed. There is space. */
	  if (*(headptr - 1) != '/')
	    *headptr++ = '/';
	  int taillen = path_end - tail + 1;
	  if (headptr + taillen > tmp_buf + (2 * NT_MAX_PATH))
	    goto too_long;
	  memcpy (headptr, tail, taillen);
	}
d2179 2
a2180 3
      /* Evaluate everything all over again. */
      src = tmp_buf;
    }
d2182 9
a2190 2
  if (!(opt & PC_SYM_CONTENTS))
    add_ext_from_sym (sym);
d2192 40
a2231 27
out:
  if (dev.devn == FH_NETDRIVE && component)
    {
      /* This case indicates a non-existant resp. a non-retrievable
	 share.  This happens for instance if the share is a printer.
	 In this case the path must not be treated like a FH_NETDRIVE,
	 but like a FH_FS instead, so the usual open call for files
	 is used on it. */
      dev.parse (FH_FS);
    }
  else if (isvirtual_dev (dev.devn) && fileattr == INVALID_FILE_ATTRIBUTES)
    {
      error = dev.devn == FH_NETDRIVE ? ENOSHARE : ENOENT;
      return;
    }
  else if (!need_directory || error)
    /* nothing to do */;
  else if (fileattr == INVALID_FILE_ATTRIBUTES)
    strcat (path, "\\"); /* Reattach trailing dirsep in native path. */
  else if (fileattr & FILE_ATTRIBUTE_DIRECTORY)
    path_flags &= ~PATH_SYMLINK;
  else
    {
      debug_printf ("%s is a non-directory", path);
      error = ENOTDIR;
      return;
    }
d2233 3
a2235 8
  if (dev.isfs ())
    {
      if (strncmp (path, "\\\\.\\", 4))
	{
	  if (!tail || tail == path)
	    /* nothing */;
	  else if (tail[-1] != '\\')
	    *tail = '\0';
d2238 5
a2242 2
	      error = ENOENT;
	      return;
d2244 227
a2470 1
	}
d2472 24
a2495 16
      /* FS has been checked already for existing files. */
      if (exists () || fs.update (get_nt_native_path (), NULL))
	{
	  debug_printf ("this->path(%s), has_acls(%d)", path, fs.has_acls ());
	  if (fs.has_acls () && allow_ntsec)
	    set_exec (0);  /* We really don't know if this is executable or not here
			      but set it to not executable since it will be figured out
			      later by anything which cares about this. */
	}
      if (exec_state () != dont_know_if_executable)
	/* ok */;
      else if (isdir ())
	set_exec (1);
      else if (issymlink () || issocket ())
	set_exec (0);
    }
d2497 8
a2504 16
  if (opt & PC_NOFULL)
    {
      if (is_relpath)
	mkrelpath (this->path);
      if (need_directory)
	{
	  size_t n = strlen (this->path);
	  /* Do not add trailing \ to UNC device names like \\.\a: */
	  if (this->path[n - 1] != '\\' &&
	      (strncmp (this->path, "\\\\.\\", 4) != 0))
	    {
	      this->path[n] = '\\';
	      this->path[n + 1] = '\0';
	    }
	}
    }
d2506 11
a2516 2
  if (saw_symlinks)
    set_has_symlinks ();
d2518 10
a2527 9
  if (!error && !isdir () && !(path_flags & PATH_ALL_EXEC))
    {
      const char *p = strchr (path, '\0') - 4;
      if (p >= path &&
	  (ascii_strcasematch (".exe", p) ||
	   ascii_strcasematch (".bat", p) ||
	   ascii_strcasematch (".com", p)))
	path_flags |= PATH_EXEC;
    }
d2529 9
a2537 10
  if (!(opt & PC_POSIX))
    normalized_path_size = 0;
  else
    {
      if (tail < path_end && tail > path_copy + 1)
	*tail = '/';
      set_normalized_path (path_copy);
      if (is_msdos && !(opt & PC_NOWARN))
	warn_msdos (src);
    }
d2539 3
a2541 8
#if 0
  if (!error)
    {
      last_path_conv = *this;
      strcpy (last_src, src);
    }
#endif
}
d2543 1
a2543 13
path_conv::~path_conv ()
{
  if (!normalized_path_size && normalized_path)
    {
      cfree (normalized_path);
      normalized_path = NULL;
    }
  if (wide_path)
    {
      cfree (wide_path);
      wide_path = NULL;
    }
}
a2544 71
bool
path_conv::is_binary ()
{
  tmp_pathbuf tp;
  PWCHAR bintest = tp.w_get ();
  DWORD bin;
  return exec_state () == is_executable
	 && RtlEqualUnicodePathSuffix (get_nt_native_path (), L".exe", TRUE)
	 && GetBinaryTypeW (get_wide_win32_path (bintest), &bin);
}

/* Normalize a Win32 path.
   /'s are converted to \'s in the process.
   All duplicate \'s, except for 2 leading \'s, are deleted.

   The result is 0 for success, or an errno error value.
   FIXME: A lot of this should be mergeable with the POSIX critter.  */
int
normalize_win32_path (const char *src, char *dst, char *&tail)
{
  const char *src_start = src;
  bool beg_src_slash = isdirsep (src[0]);

  tail = dst;
  /* Skip long path name prefixes in Win32 or NT syntax. */
  if (beg_src_slash && (src[1] == '?' || isdirsep (src[1]))
      && src[2] == '?' && isdirsep (src[3]))
    {
      src += 4;
      if (src[1] != ':') /* native UNC path */
        {
	  src += 2; /* Fortunately the first char is not copied... */
	  beg_src_slash = true;
	}
      else
        beg_src_slash = isdirsep (src[0]);
    }
  if (beg_src_slash && isdirsep (src[1]))
    {
      if (isdirsep (src[2]))
	{
	  /* More than two slashes are just folded into one. */
	  src += 2;
	  while (isdirsep (src[1]))
	    ++src;
	}
      else
	{
	  /* Two slashes start a network or device path. */
	  *tail++ = '\\';
	  src++;
	  if (src[1] == '.' && isdirsep (src[2]))
	    {
	      *tail++ = '\\';
	      *tail++ = '.';
	      src += 2;
	    }
	}
    }
  if (tail == dst && !isdrive (src) && *src != '/')
    {
      if (beg_src_slash)
	tail += cygheap->cwd.get_drive (dst);
      else if (!cygheap->cwd.get (dst, 0))
	return get_errno ();
      else
	{
	  tail = strchr (tail, '\0');
	  *tail++ = '\\';
	}
    }
d2546 6
a2551 73
  while (*src)
    {
      /* Strip duplicate /'s.  */
      if (isdirsep (src[0]) && isdirsep (src[1]))
	src++;
      /* Ignore "./".  */
      else if (src[0] == '.' && isdirsep (src[1])
	       && (src == src_start || isdirsep (src[-1])))
	src += 2;

      /* Backup if "..".  */
      else if (src[0] == '.' && src[1] == '.'
	       /* dst must be greater than dst_start */
	       && tail[-1] == '\\')
	{
	  if (!isdirsep (src[2]) && src[2] != '\0')
	      *tail++ = *src++;
	  else
	    {
	      /* Back up over /, but not if it's the first one.  */
	      if (tail > dst + 1)
		tail--;
	      /* Now back up to the next /.  */
	      while (tail > dst + 1 && tail[-1] != '\\' && tail[-2] != ':')
		tail--;
	      src += 2;
	      if (isdirsep (*src))
		src++;
	    }
	}
      /* Otherwise, add char to result.  */
      else
	{
	  if (*src == '/')
	    *tail++ = '\\';
	  else
	    *tail++ = *src;
	  src++;
	}
      if ((tail - dst) >= NT_MAX_PATH)
	return ENAMETOOLONG;
    }
   if (tail > dst + 1 && tail[-1] == '.' && tail[-2] == '\\')
     tail--;
  *tail = '\0';
  debug_printf ("%s = normalize_win32_path (%s)", dst, src_start);
  return 0;
}

/* Various utilities.  */

/* nofinalslash: Remove trailing / and \ from SRC (except for the
   first one).  It is ok for src == dst.  */

void __stdcall
nofinalslash (const char *src, char *dst)
{
  int len = strlen (src);
  if (src != dst)
    memcpy (dst, src, len + 1);
  while (len > 1 && isdirsep (dst[--len]))
    dst[len] = '\0';
}

/* conv_path_list: Convert a list of path names to/from Win32/POSIX. */

static int
conv_path_list (const char *src, char *dst, size_t size, int to_posix)
{
  tmp_pathbuf tp;
  char src_delim, dst_delim;
  cygwin_conv_path_t conv_fn;
  size_t len;
d2553 2
a2554 12
  if (to_posix)
    {
      src_delim = ';';
      dst_delim = ':';
      conv_fn = CCP_WIN_A_TO_POSIX | CCP_RELATIVE;
    }
  else
    {
      src_delim = ':';
      dst_delim = ';';
      conv_fn = CCP_POSIX_TO_WIN_A | CCP_RELATIVE;
    }
d2556 4
a2559 41
  char *srcbuf;
  len = strlen (src) + 1;
  if (len <= NT_MAX_PATH * sizeof (WCHAR))
    srcbuf = (char *) tp.w_get ();
  else
    srcbuf = (char *) alloca (len);

  int err = 0;
  char *d = dst - 1;
  bool saw_empty = false;
  do
    {
      char *s = strccpy (srcbuf, &src, src_delim);
      size_t len = s - srcbuf;
      if (len >= NT_MAX_PATH)
	{
	  err = ENAMETOOLONG;
	  break;
	}
      if (len)
	{
	  ++d;
	  err = cygwin_conv_path (conv_fn, srcbuf, d, size - (d - dst));
        }
      else if (!to_posix)
	{
	  ++d;
	  err = cygwin_conv_path (conv_fn, ".", d, size - (d - dst));
	}
      else
	{
	  if (to_posix == ENV_CVT)
	    saw_empty = true;
	  continue;
	}
      if (err)
	break;
      d = strchr (d, '\0');
      *d = dst_delim;
    }
  while (*src++);
d2561 16
a2576 2
  if (saw_empty)
    err = EIDRM;
d2578 5
a2582 48
  if (d < dst)
    d++;
  *d = '\0';
  return err;
}

/********************** Symbolic Link Support **************************/

/* Create a symlink from FROMPATH to TOPATH. */

/* If TRUE create symlinks as Windows shortcuts, if false create symlinks
   as normal files with magic number and system bit set. */
bool allow_winsymlinks = true;

extern "C" int
symlink (const char *oldpath, const char *newpath)
{
  return symlink_worker (oldpath, newpath, allow_winsymlinks, false);
}

int
symlink_worker (const char *oldpath, const char *newpath, bool use_winsym,
		bool isdevice)
{
  int res = -1;
  size_t len;
  path_conv win32_newpath, win32_oldpath;
  char *buf, *cp;
  SECURITY_ATTRIBUTES sa = sec_none_nih;
  security_descriptor sd;
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;
  NTSTATUS status;
  HANDLE fh;
  FILE_BASIC_INFORMATION fbi;
  tmp_pathbuf tp;

  /* POSIX says that empty 'newpath' is invalid input while empty
     'oldpath' is valid -- it's symlink resolver job to verify if
     symlink contents point to existing filesystem object */
  myfault efault;
  if (efault.faulted (EFAULT))
    goto done;
  if (!*oldpath || !*newpath)
    {
      set_errno (ENOENT);
      goto done;
    }
d2584 17
a2600 5
  if (strlen (oldpath) > SYMLINK_MAX)
    {
      set_errno (ENAMETOOLONG);
      goto done;
    }
d2602 4
a2605 16
  len = strlen (newpath);
  /* Trailing dirsep is a no-no. */
  if (isdirsep (newpath[len - 1]))
    {
      set_errno (ENOENT);
      goto done;
    }
  /* We need the normalized full path below. */
  win32_newpath.check (newpath, PC_SYM_NOFOLLOW | PC_POSIX, stat_suffixes);
  if (use_winsym && !win32_newpath.exists ()
      && (isdevice || !win32_newpath.fs_is_nfs ()))
    {
      char *newplnk = tp.c_get ();
      stpcpy (stpcpy (newplnk, newpath), ".lnk");
      win32_newpath.check (newplnk, PC_SYM_NOFOLLOW | PC_POSIX);
    }
d2607 12
a2618 5
  if (win32_newpath.error)
    {
      set_errno (win32_newpath.case_clash ? ECASECLASH : win32_newpath.error);
      goto done;
    }
d2620 1
a2620 2
  syscall_printf ("symlink (%s, %S)", oldpath,
		  win32_newpath.get_nt_native_path ());
d2622 8
a2629 6
  if ((!isdevice && win32_newpath.exists ())
      || win32_newpath.is_auto_device ())
    {
      set_errno (EEXIST);
      goto done;
    }
d2631 1
a2631 27
  if (!isdevice && win32_newpath.fs_is_nfs ())
    {
      /* On NFS, create symlinks by calling NtCreateFile with an EA of type
         NfsSymlinkTargetName containing ... the symlink target name. */
      PFILE_FULL_EA_INFORMATION pffei = (PFILE_FULL_EA_INFORMATION) tp.w_get ();
      pffei->NextEntryOffset = 0;
      pffei->Flags = 0;
      pffei->EaNameLength = sizeof (NFS_SYML_TARGET) - 1;
      char *EaValue = stpcpy (pffei->EaName, NFS_SYML_TARGET) + 1;
      pffei->EaValueLength = sizeof (WCHAR) *
        (sys_mbstowcs ((PWCHAR) EaValue, NT_MAX_PATH, oldpath) - 1);
      status = NtCreateFile (&fh, FILE_WRITE_DATA | FILE_WRITE_EA | SYNCHRONIZE,
			     win32_newpath.get_object_attr (attr, sa),
			     &io, NULL, FILE_ATTRIBUTE_SYSTEM,
			     FILE_SHARE_VALID_FLAGS, FILE_CREATE,
			     FILE_SYNCHRONOUS_IO_NONALERT
			     | FILE_OPEN_FOR_BACKUP_INTENT,
			     pffei, NT_MAX_PATH * sizeof (WCHAR));
      if (!NT_SUCCESS (status))
	{
	  __seterrno_from_nt_status (status);
	  goto done;
	}
      NtClose (fh);
      res = 0;
      goto done;
    }
d2633 6
a2638 44
  if (use_winsym)
    {
      ITEMIDLIST *pidl = NULL;
      size_t full_len = 0;
      unsigned short oldpath_len, desc_len, relpath_len, pidl_len = 0;
      char desc[MAX_PATH + 1], *relpath;

      if (!isdevice)
	{
	  /* First create an IDLIST to learn how big our shortcut is
	     going to be. */
	  IShellFolder *psl;

	  /* The symlink target is relative to the directory in which
	     the symlink gets created, not relative to the cwd.  Therefore
	     we have to mangle the path quite a bit before calling path_conv. */
	  if (!isabspath (oldpath))
	    {
	      len = strrchr (win32_newpath.normalized_path, '/')
		    - win32_newpath.normalized_path + 1;
	      char *absoldpath = tp.t_get ();
	      stpcpy (stpncpy (absoldpath, win32_newpath.normalized_path, len),
		      oldpath);
	      win32_oldpath.check (absoldpath, PC_SYM_NOFOLLOW, stat_suffixes);
	    }
	  else
	    win32_oldpath.check (oldpath, PC_SYM_NOFOLLOW, stat_suffixes);
	  if (SUCCEEDED (SHGetDesktopFolder (&psl)))
	    {
	      WCHAR wc_path[win32_oldpath.get_wide_win32_path_len () + 1];
	      win32_oldpath.get_wide_win32_path (wc_path);
	      /* Amazing but true:  Even though the ParseDisplayName method
		 takes a wide char path name, it does not understand the
		 Win32 prefix for long pathnames!  So we have to tack off
		 the prefix and convert the path to the "normal" syntax
		 for ParseDisplayName.  */
	      WCHAR *wc = wc_path + 4;
	      if (wc[1] != L':') /* native UNC path */
		*(wc += 2) = L'\\';
	      HRESULT res;
	      if (SUCCEEDED (res = psl->ParseDisplayName (NULL, NULL, wc, NULL,
						    &pidl, NULL)))
		{
		  ITEMIDLIST *p;
d2640 5
a2644 66
		  for (p = pidl; p->mkid.cb > 0;
		       p = (ITEMIDLIST *)((char *) p + p->mkid.cb))
		    ;
		  pidl_len = (char *) p - (char *) pidl + 2;
		}
	      psl->Release ();
	    }
	}
      /* Compute size of shortcut file. */
      full_len = sizeof (win_shortcut_hdr);
      if (pidl_len)
	full_len += sizeof (unsigned short) + pidl_len;
      oldpath_len = strlen (oldpath);
      /* Unfortunately the length of the description is restricted to a
	 length of MAX_PATH up to NT4, and to a length of 2000 bytes
	 since W2K.  We don't want to add considerations for the different
	 lengths and even 2000 bytes is not enough for long path names.
	 So what we do here is to set the description to the POSIX path
	 only if the path is not longer than MAX_PATH characters.  We
	 append the full path name after the regular shortcut data
	 (see below), which works fine with Windows Explorer as well
	 as older Cygwin versions (as long as the whole file isn't bigger
	 than 8K).  The description field is only used for backward
	 compatibility to older Cygwin versions and those versions are
	 not capable of handling long path names anyway. */
      desc_len = stpcpy (desc, oldpath_len > MAX_PATH
			       ? "[path too long]" : oldpath) - desc;
      full_len += sizeof (unsigned short) + desc_len;
      /* Devices get the oldpath string unchanged as relative path. */
      if (isdevice)
	{
	  relpath_len = oldpath_len;
	  stpcpy (relpath = tp.c_get (), oldpath);
	}
      else
	{
	  relpath_len = strlen (win32_oldpath.get_win32 ());
	  stpcpy (relpath = tp.c_get (), win32_oldpath.get_win32 ());
	}
      full_len += sizeof (unsigned short) + relpath_len;
      full_len += sizeof (unsigned short) + oldpath_len;
      /* 1 byte more for trailing 0 written by stpcpy. */
      if (full_len < NT_MAX_PATH * sizeof (WCHAR))
	buf = (char *) tp.w_get ();
      else
	buf = (char *) alloca (full_len + 1);

      /* Create shortcut header */
      win_shortcut_hdr *shortcut_header = (win_shortcut_hdr *) buf;
      memset (shortcut_header, 0, sizeof *shortcut_header);
      shortcut_header->size = sizeof *shortcut_header;
      shortcut_header->magic = GUID_shortcut;
      shortcut_header->flags = (WSH_FLAG_DESC | WSH_FLAG_RELPATH);
      if (pidl)
	shortcut_header->flags |= WSH_FLAG_IDLIST;
      shortcut_header->run = SW_NORMAL;
      cp = buf + sizeof (win_shortcut_hdr);

      /* Create IDLIST */
      if (pidl)
	{
	  *(unsigned short *)cp = pidl_len;
	  memcpy (cp += 2, pidl, pidl_len);
	  cp += pidl_len;
	  CoTaskMemFree (pidl);
	}
d2646 6
a2651 20
      /* Create description */
      *(unsigned short *)cp = desc_len;
      cp = stpcpy (cp += 2, desc);

      /* Create relpath */
      *(unsigned short *)cp = relpath_len;
      cp = stpcpy (cp += 2, relpath);

      /* Append the POSIX path after the regular shortcut data for
	 the long path support. */
      *(unsigned short *)cp = oldpath_len;
      cp = stpcpy (cp += 2, oldpath);
    }
  else
    {
      /* This is the old technique creating a symlink. */
      buf = tp.c_get ();
      /* Note that the terminating nul is written.  */
      cp = stpcpy (stpcpy (buf, SYMLINK_COOKIE), oldpath) + 1;
    }
d2653 2
a2654 62
  if (isdevice && win32_newpath.exists ())
    {
      status = NtOpenFile (&fh, FILE_WRITE_ATTRIBUTES,
			   win32_newpath.get_object_attr (attr, sa),
			   &io, 0, FILE_OPEN_FOR_BACKUP_INTENT);
      if (!NT_SUCCESS (status))
	{
	  __seterrno_from_nt_status (status);
	  goto done;
	}
      fbi.CreationTime.QuadPart = fbi.LastAccessTime.QuadPart
      = fbi.LastWriteTime.QuadPart = fbi.ChangeTime.QuadPart = 0LL;
      fbi.FileAttributes = FILE_ATTRIBUTE_NORMAL;
      status = NtSetInformationFile (fh, &io, &fbi, sizeof fbi,
				     FileBasicInformation);
      NtClose (fh);
      if (!NT_SUCCESS (status))
	{
	  __seterrno_from_nt_status (status);
	  goto done;
	}
    }
  if (allow_ntsec && win32_newpath.has_acls ())
    set_security_attribute (S_IFLNK | STD_RBITS | STD_WBITS,
			    &sa, sd);
  status = NtCreateFile (&fh, DELETE | FILE_GENERIC_WRITE,
			 win32_newpath.get_object_attr (attr, sa),
			 &io, NULL, FILE_ATTRIBUTE_NORMAL,
			 FILE_SHARE_VALID_FLAGS,
			 isdevice ? FILE_OVERWRITE_IF : FILE_CREATE,
			 FILE_SYNCHRONOUS_IO_NONALERT
			 | FILE_NON_DIRECTORY_FILE
			 | FILE_OPEN_FOR_BACKUP_INTENT,
			 NULL, 0);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      goto done;
    }
  status = NtWriteFile (fh, NULL, NULL, NULL, &io, buf, cp - buf, NULL, NULL);
  if (NT_SUCCESS (status) && io.Information == (ULONG) (cp - buf))
    {
      fbi.CreationTime.QuadPart = fbi.LastAccessTime.QuadPart
      = fbi.LastWriteTime.QuadPart = fbi.ChangeTime.QuadPart = 0LL;
      fbi.FileAttributes = use_winsym ? FILE_ATTRIBUTE_READONLY
				      : FILE_ATTRIBUTE_SYSTEM;
      status = NtSetInformationFile (fh, &io, &fbi, sizeof fbi,
				     FileBasicInformation);
      if (!NT_SUCCESS (status))
	debug_printf ("Setting attributes failed, status = %p", status);
      res = 0;
    }
  else
    {
      __seterrno_from_nt_status (status);
      FILE_DISPOSITION_INFORMATION fdi = { TRUE };
      status = NtSetInformationFile (fh, &io, &fdi, sizeof fdi,
				     FileDispositionInformation);
      if (!NT_SUCCESS (status))
	debug_printf ("Setting delete dispostion failed, status = %p", status);
    }
  NtClose (fh);
d2656 3
a2658 138
done:
  syscall_printf ("%d = symlink_worker (%s, %s, %d, %d)", res, oldpath,
		  newpath, use_winsym, isdevice);
  return res;
}

static bool
cmp_shortcut_header (win_shortcut_hdr *file_header)
{
  /* A Cygwin or U/Win shortcut only contains a description and a relpath.
     Cygwin shortcuts also might contain an ITEMIDLIST. The run type is
     always set to SW_NORMAL. */
  return file_header->size == sizeof (win_shortcut_hdr)
      && !memcmp (&file_header->magic, &GUID_shortcut, sizeof GUID_shortcut)
      && (file_header->flags & ~WSH_FLAG_IDLIST)
	 == (WSH_FLAG_DESC | WSH_FLAG_RELPATH)
      && file_header->run == SW_NORMAL;
}

int
symlink_info::check_shortcut (HANDLE in_h)
{
  tmp_pathbuf tp;
  win_shortcut_hdr *file_header;
  char *buf, *cp;
  unsigned short len;
  int res = 0;
  UNICODE_STRING same = { 0, 0, (PWCHAR) L"" };
  OBJECT_ATTRIBUTES attr;
  NTSTATUS status;
  HANDLE h;
  IO_STATUS_BLOCK io;
  FILE_STANDARD_INFORMATION fsi;

  InitializeObjectAttributes (&attr, &same, 0, in_h, NULL);
  status = NtOpenFile (&h, FILE_READ_DATA | SYNCHRONIZE,
		       &attr, &io, FILE_SHARE_VALID_FLAGS,
		       FILE_OPEN_FOR_BACKUP_INTENT
		       | FILE_SYNCHRONOUS_IO_NONALERT);
  if (!NT_SUCCESS (status))
    {
      set_error (EIO);
      return 0;
    }
  status = NtQueryInformationFile (h, &io, &fsi, sizeof fsi,
				   FileStandardInformation);
  if (!NT_SUCCESS (status))
    {
      set_error (EIO);
      goto out;
    }
  if (fsi.EndOfFile.QuadPart <= sizeof (win_shortcut_hdr)
      || fsi.EndOfFile.QuadPart > 4 * 65536)
    goto out;
  if (fsi.EndOfFile.LowPart < NT_MAX_PATH * sizeof (WCHAR))
    buf = (char *) tp.w_get ();
  else
    buf = (char *) alloca (fsi.EndOfFile.LowPart + 1);
  if (!NT_SUCCESS (NtReadFile (h, NULL, NULL, NULL,
			       &io, buf, fsi.EndOfFile.LowPart, NULL, NULL)))
    {
      set_error (EIO);
      goto out;
    }
  file_header = (win_shortcut_hdr *) buf;
  if (io.Information != fsi.EndOfFile.LowPart
      || !cmp_shortcut_header (file_header))
    goto file_not_symlink;
  cp = buf + sizeof (win_shortcut_hdr);
  if (file_header->flags & WSH_FLAG_IDLIST) /* Skip ITEMIDLIST */
    cp += *(unsigned short *) cp + 2;
  if (!(len = *(unsigned short *) cp))
    goto file_not_symlink;
  cp += 2;
  /* Check if this is a device file - these start with the sequence :\\ */
  if (strncmp (cp, ":\\", 2) == 0)
    res = strlen (strcpy (contents, cp)); /* Don't mess with device files */
  else
    {
      /* Has appended full path?  If so, use it instead of description. */
      unsigned short relpath_len = *(unsigned short *) (cp + len);
      if (cp + len + 2 + relpath_len < buf + fsi.EndOfFile.LowPart)
	{
	  cp += len + 2 + relpath_len;
	  len = *(unsigned short *) cp;
	  cp += 2;
	}
      if (len > SYMLINK_MAX)
	goto file_not_symlink;
      cp[len] = '\0';
      res = posixify (cp);
    }
  if (res) /* It's a symlink.  */
    pflags = PATH_SYMLINK | PATH_LNK;
  return res;

file_not_symlink:
  /* Not a symlink, see if executable.  */
  if (!(pflags & PATH_ALL_EXEC) && has_exec_chars ((const char *) &file_header, io.Information))
    pflags |= PATH_EXEC;

out:
  NtClose (h);
  return 0;
}

int
symlink_info::check_sysfile (HANDLE in_h)
{
  char cookie_buf[sizeof (SYMLINK_COOKIE) - 1];
  char srcbuf[SYMLINK_MAX + 2];
  int res = 0;
  UNICODE_STRING same = { 0, 0, (PWCHAR) L"" };
  OBJECT_ATTRIBUTES attr;
  NTSTATUS status;
  HANDLE h;
  IO_STATUS_BLOCK io;

  InitializeObjectAttributes (&attr, &same, 0, in_h, NULL);
  status = NtOpenFile (&h, FILE_READ_DATA | SYNCHRONIZE,
		       &attr, &io, FILE_SHARE_VALID_FLAGS,
		       FILE_OPEN_FOR_BACKUP_INTENT
		       | FILE_SYNCHRONOUS_IO_NONALERT);
  if (!NT_SUCCESS (status))
    set_error (EIO);
  else if (!NT_SUCCESS (status = NtReadFile (h, NULL, NULL, NULL, &io,
					     cookie_buf, sizeof (cookie_buf),
					     NULL, NULL)))
    {
      debug_printf ("ReadFile1 failed");
      if (status != STATUS_END_OF_FILE)
	set_error (EIO);
    }
  else if (io.Information == sizeof (cookie_buf)
	   && memcmp (cookie_buf, SYMLINK_COOKIE, sizeof (cookie_buf)) == 0)
    {
      /* It's a symlink.  */
      pflags = PATH_SYMLINK;
d2660 12
a2671 74
      status = NtReadFile (h, NULL, NULL, NULL, &io, srcbuf,
			   SYMLINK_MAX + 2, NULL, NULL);
      if (!NT_SUCCESS (status))
	{
	  debug_printf ("ReadFile2 failed");
	  if (status != STATUS_END_OF_FILE)
	    set_error (EIO);
	}
      else if (io.Information > SYMLINK_MAX + 1)
	debug_printf ("symlink string too long");
      else
	res = posixify (srcbuf);
    }
  else if (io.Information == sizeof (cookie_buf)
	   && memcmp (cookie_buf, SOCKET_COOKIE, sizeof (cookie_buf)) == 0)
    pflags |= PATH_SOCKET;
  else
    {
      /* Not a symlink, see if executable.  */
      if (pflags & PATH_ALL_EXEC)
	/* Nothing to do */;
      else if (has_exec_chars (cookie_buf, io.Information))
	pflags |= PATH_EXEC;
      else
	pflags |= PATH_NOTEXEC;
      }
  NtClose (h);
  return res;
}

int
symlink_info::check_reparse_point (HANDLE h)
{
  tmp_pathbuf tp;
  NTSTATUS status;
  IO_STATUS_BLOCK io;
  PREPARSE_DATA_BUFFER rp = (PREPARSE_DATA_BUFFER) tp.c_get ();
  char srcbuf[SYMLINK_MAX + 7];

  status = NtFsControlFile (h, NULL, NULL, NULL, &io, FSCTL_GET_REPARSE_POINT,
			    NULL, 0, (LPVOID) rp,
			    MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
  if (!NT_SUCCESS (status))
    {
      debug_printf ("NtFsControlFile(FSCTL_GET_REPARSE_POINT) failed, %p",
		    status);
      set_error (EIO);
      return 0;
    }
  if (rp->ReparseTag == IO_REPARSE_TAG_SYMLINK)
    {
      sys_wcstombs (srcbuf, SYMLINK_MAX + 1,
		    (WCHAR *)((char *)rp->SymbolicLinkReparseBuffer.PathBuffer
			  + rp->SymbolicLinkReparseBuffer.SubstituteNameOffset),
		    rp->SymbolicLinkReparseBuffer.SubstituteNameLength / sizeof (WCHAR));
      pflags = PATH_SYMLINK | PATH_REP;
      fileattr &= ~FILE_ATTRIBUTE_DIRECTORY;
    }
  else if (rp->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)
    {
      if (rp->SymbolicLinkReparseBuffer.PrintNameLength == 0)
	{
	  /* Likely a volume mount point.  Not treated as symlink. */
	  return 0;
	}
      sys_wcstombs (srcbuf, SYMLINK_MAX + 1,
		    (WCHAR *)((char *)rp->MountPointReparseBuffer.PathBuffer
			    + rp->MountPointReparseBuffer.SubstituteNameOffset),
		    rp->MountPointReparseBuffer.SubstituteNameLength / sizeof (WCHAR));
      pflags = PATH_SYMLINK | PATH_REP;
      fileattr &= ~FILE_ATTRIBUTE_DIRECTORY;
    }
  return posixify (srcbuf);
}
d2673 7
a2679 31
int
symlink_info::check_nfs_symlink (HANDLE h)
{
  tmp_pathbuf tp;
  NTSTATUS status;
  IO_STATUS_BLOCK io;
  struct {
    FILE_GET_EA_INFORMATION fgei;
    char buf[sizeof (NFS_SYML_TARGET)];
  } fgei_buf;
  PFILE_FULL_EA_INFORMATION pffei;
  int res = 0;

  /* To find out if the file is a symlink and to get the symlink target,
     try to fetch the NfsSymlinkTargetName EA. */
  fgei_buf.fgei.NextEntryOffset = 0;
  fgei_buf.fgei.EaNameLength = sizeof (NFS_SYML_TARGET) - 1;
  stpcpy (fgei_buf.fgei.EaName, NFS_SYML_TARGET);
  pffei = (PFILE_FULL_EA_INFORMATION) tp.w_get ();
  status = NtQueryEaFile (h, &io, pffei, NT_MAX_PATH * sizeof (WCHAR), TRUE,
			  &fgei_buf.fgei, sizeof fgei_buf, NULL, TRUE);
  if (NT_SUCCESS (status) && pffei->EaValueLength > 0)
    {
      PWCHAR spath = (PWCHAR)
		     (pffei->EaName + pffei->EaNameLength + 1);
      res = sys_wcstombs (contents, SYMLINK_MAX + 1,
		      spath, pffei->EaValueLength);
      pflags = PATH_SYMLINK;
    }
  return res;
}
d2681 7
a2687 22
int
symlink_info::posixify (char *srcbuf)
{
  /* The definition for a path in a native symlink is a bit weird.  The Flags
     value seem to contain 0 for absolute paths (stored as NT native path)
     and 1 for relative paths.  Relative paths are paths not starting with a
     drive letter.  These are not converted to NT native, but stored as
     given.  A path starting with a single backslash is relative to the
     current drive thus a "relative" value (Flags == 1).
     Funny enough it's possible to store paths with slashes instead of
     backslashes, but they are evaluated incorrectly by subsequent Windows
     calls like CreateFile (ERROR_INVALID_NAME).  So, what we do here is to
     take paths starting with slashes at face value, evaluating them as
     Cygwin specific POSIX paths.
     A path starting with two slashes(!) or backslashes is converted into an
     NT UNC path.  Unfortunately, in contrast to POSIX rules, paths starting
     with three or more (back)slashes are also converted into UNC paths,
     just incorrectly sticking to one redundant leading backslashe.  We go
     along with this behaviour to avoid scenarios in which native tools access
     other files than Cygwin.
     The above rules are used exactly the same way on Cygwin specific symlinks
     (sysfiles and shortcuts) to eliminate non-POSIX paths in the output. */
d2689 9
a2697 16
  /* Eliminate native NT prefixes. */
  if (srcbuf[0] == '\\' && !strncmp (srcbuf + 1, "??\\", 3))
    {
      srcbuf += 4;
      if (srcbuf[1] != ':') /* native UNC path */
	*(srcbuf += 2) = '\\';
    }
  if (isdrive (srcbuf))
    mount_table->conv_to_posix_path (srcbuf, contents, 0);
  else if (srcbuf[0] == '\\')
    {
      if (srcbuf[1] == '\\') /* UNC path */
	slashify (srcbuf, contents, 0);
      else /* Paths starting with \ are current drive relative. */
	{
	  char cvtbuf[SYMLINK_MAX + 1];
d2699 13
a2711 44
	  stpcpy (cvtbuf + cygheap->cwd.get_drive (cvtbuf), srcbuf);
	  mount_table->conv_to_posix_path (cvtbuf, contents, 0);
	}
    }
  else /* Everything else is taken as is. */
    slashify (srcbuf, contents, 0);
  return strlen (contents);
}

enum
{
  SCAN_BEG,
  SCAN_LNK,
  SCAN_HASLNK,
  SCAN_JUSTCHECK,
  SCAN_JUSTCHECKTHIS, /* Never try to append a suffix. */
  SCAN_APPENDLNK,
  SCAN_EXTRALNK,
  SCAN_DONE,
};

class suffix_scan
{
  const suffix_info *suffixes, *suffixes_start;
  int nextstate;
  char *eopath;
public:
  const char *path;
  char *has (const char *, const suffix_info *);
  int next ();
  int lnk_match () {return nextstate >= SCAN_APPENDLNK;}
};

char *
suffix_scan::has (const char *in_path, const suffix_info *in_suffixes)
{
  nextstate = SCAN_BEG;
  suffixes = suffixes_start = in_suffixes;

  const char *fname = strrchr (in_path, '\\');
  fname = fname ? fname + 1 : in_path;
  char *ext_here = strrchr (fname, '.');
  path = in_path;
  eopath = strchr (path, '\0');
d2713 6
a2718 2
  if (!ext_here)
    goto noext;
d2720 12
a2731 11
  if (suffixes)
    {
      /* Check if the extension matches a known extension */
      for (const suffix_info *ex = in_suffixes; ex->name != NULL; ex++)
	if (ascii_strcasematch (ext_here, ex->name))
	  {
	    nextstate = SCAN_JUSTCHECK;
	    suffixes = NULL;	/* Has an extension so don't scan for one. */
	    goto done;
	  }
    }
d2733 1
a2733 6
  /* Didn't match.  Use last resort -- .lnk. */
  if (ascii_strcasematch (ext_here, ".lnk"))
    {
      nextstate = SCAN_HASLNK;
      suffixes = NULL;
    }
d2735 9
a2743 2
 noext:
  ext_here = eopath;
d2745 36
a2780 9
 done:
  /* Avoid attaching suffixes if the resulting filename would be invalid. */
  if (eopath - fname > NAME_MAX - 4)
    {
      nextstate = SCAN_JUSTCHECKTHIS;
      suffixes = NULL;
    }
  return ext_here;
}
d2782 9
a2790 40
int
suffix_scan::next ()
{
  for (;;)
    {
      if (!suffixes)
	switch (nextstate)
	  {
	  case SCAN_BEG:
	    suffixes = suffixes_start;
	    if (!suffixes)
	      {
		nextstate = SCAN_LNK;
		return 1;
	      }
	    nextstate = SCAN_EXTRALNK;
	    /* fall through to suffix checking below */
	    break;
	  case SCAN_HASLNK:
	    nextstate = SCAN_APPENDLNK;	/* Skip SCAN_BEG */
	    return 1;
	  case SCAN_EXTRALNK:
	    nextstate = SCAN_DONE;
	    *eopath = '\0';
	    return 0;
	  case SCAN_JUSTCHECK:
	    nextstate = SCAN_LNK;
	    return 1;
	  case SCAN_JUSTCHECKTHIS:
	    nextstate = SCAN_DONE;
	    return 1;
	  case SCAN_LNK:
	  case SCAN_APPENDLNK:
	    strcat (eopath, ".lnk");
	    nextstate = SCAN_DONE;
	    return 1;
	  default:
	    *eopath = '\0';
	    return 0;
	  }
d2792 3
a2794 14
      while (suffixes && suffixes->name)
	if (nextstate == SCAN_EXTRALNK && !suffixes->addon)
	  suffixes++;
	else
	  {
	    strcpy (eopath, suffixes->name);
	    if (nextstate == SCAN_EXTRALNK)
	      strcat (eopath, ".lnk");
	    suffixes++;
	    return 1;
	  }
      suffixes = NULL;
    }
}
d2796 1
a2796 18
bool
symlink_info::set_error (int in_errno)
{
  bool res;
  if (!(pflags & PATH_NO_ACCESS_CHECK) || in_errno == ENAMETOOLONG || in_errno == EIO)
    {
      error = in_errno;
      res = true;
    }
  else if (in_errno == ENOENT)
    res = true;
  else
    {
      fileattr = FILE_ATTRIBUTE_NORMAL;
      res = false;
    }
  return res;
}
d2798 2
a2799 21
bool
symlink_info::parse_device (const char *contents)
{
  char *endptr;
  _major_t mymajor;
  _major_t myminor;
  _mode_t mymode;

  mymajor = strtol (contents += 2, &endptr, 16);
  if (endptr == contents)
    return isdevice = false;

  contents = endptr;
  myminor = strtol (++contents, &endptr, 16);
  if (endptr == contents)
    return isdevice = false;

  contents = endptr;
  mymode = strtol (++contents, &endptr, 16);
  if (endptr == contents)
    return isdevice = false;
d2801 17
a2817 5
  if ((mymode & S_IFMT) == S_IFIFO)
    {
      mymajor = _major (FH_FIFO);
      myminor = _minor (FH_FIFO);
    }
d2819 71
a2889 49
  major = mymajor;
  minor = myminor;
  mode = mymode;
  return isdevice = true;
}

/* Check if PATH is a symlink.  PATH must be a valid Win32 path name.

   If PATH is a symlink, put the value of the symlink--the file to
   which it points--into BUF.  The value stored in BUF is not
   necessarily null terminated.  BUFLEN is the length of BUF; only up
   to BUFLEN characters will be stored in BUF.  BUF may be NULL, in
   which case nothing will be stored.

   Set *SYML if PATH is a symlink.

   Set *EXEC if PATH appears to be executable.  This is an efficiency
   hack because we sometimes have to open the file anyhow.  *EXEC will
   not be set for every executable file.

   Return -1 on error, 0 if PATH is not a symlink, or the length
   stored into BUF if PATH is a symlink.  */

int
symlink_info::check (char *path, const suffix_info *suffixes, unsigned opt,
		     fs_info &fs)
{
  HANDLE h = NULL;
  int res = 0;
  suffix_scan suffix;
  contents[0] = '\0';

  issymlink = true;
  isdevice = false;
  ext_here = suffix.has (path, suffixes);
  extn = ext_here - path;
  major = 0;
  minor = 0;
  mode = 0;
  pflags &= ~(PATH_SYMLINK | PATH_LNK | PATH_REP);
  case_clash = false;

  /* TODO: Temporarily do all char->UNICODE conversion here.  This should
     already be slightly faster than using Ascii functions. */
  tmp_pathbuf tp;
  UNICODE_STRING upath;
  OBJECT_ATTRIBUTES attr;
  tp.u_get (&upath);
  InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE, NULL, NULL);
d2891 13
a2903 6
  while (suffix.next ())
    {
      FILE_BASIC_INFORMATION fbi;
      NTSTATUS status;
      IO_STATUS_BLOCK io;
      bool no_ea = false;
a2904 107
      error = 0;
      get_nt_native_path (suffix.path, upath, pflags & MOUNT_ENC);
      if (h)
        {
	  NtClose (h);
	  h = NULL;
	}
      /* The EA given to NtCreateFile allows to get a handle to a symlink on
         an NFS share, rather than getting a handle to the target of the
	 symlink (which would spoil the task of this method quite a bit).
	 Fortunately it's ignored on other file systems so we don't have
	 to special case NFS too much. */
      status = NtCreateFile (&h,
			     READ_CONTROL | FILE_READ_ATTRIBUTES | FILE_READ_EA,
			     &attr, &io, NULL, FILE_ATTRIBUTE_NORMAL,
			     FILE_SHARE_VALID_FLAGS, FILE_OPEN,
			     FILE_OPEN_REPARSE_POINT
			     | FILE_OPEN_FOR_BACKUP_INTENT,
			     &nfs_aol_ffei, sizeof nfs_aol_ffei);
      if (status == STATUS_ACCESS_DENIED) /* No right to access EAs? */
	{
	  no_ea = true;
	  status = NtCreateFile (&h,
				 READ_CONTROL | FILE_READ_ATTRIBUTES,
				 &attr, &io, NULL, FILE_ATTRIBUTE_NORMAL,
				 FILE_SHARE_VALID_FLAGS, FILE_OPEN,
				 FILE_OPEN_REPARSE_POINT
				 | FILE_OPEN_FOR_BACKUP_INTENT,
				 &nfs_aol_ffei, sizeof nfs_aol_ffei);
      	}
      if (NT_SUCCESS (status)
	  && NT_SUCCESS (status
			 = NtQueryInformationFile (h, &io, &fbi, sizeof fbi,
						   FileBasicInformation)))
	fileattr = fbi.FileAttributes;
      else
	{
	  debug_printf ("%p = NtQueryInformationFile (%S)", status, &upath);
	  h = NULL;
	  fileattr = INVALID_FILE_ATTRIBUTES;

	  /* One of the inner path components is invalid, or the path contains
	     invalid characters.  Bail out with ENOENT.

	     Note that additional STATUS_OBJECT_PATH_INVALID and
	     STATUS_OBJECT_PATH_SYNTAX_BAD status codes exist.  The first one
	     is seemingly not generated by NtQueryAttributesFile, the latter
	     is only generated if the path is no absolute path within the
	     NT name space, which should not happen and would point to an
	     error in get_nt_native_path.  Both status codes are deliberately
	     not tested here unless proved necessary. */
	  if (status == STATUS_OBJECT_PATH_NOT_FOUND
	      || status == STATUS_OBJECT_NAME_INVALID)
	    {
	      set_error (ENOENT);
	      goto file_not_symlink;
	    }
	  if (status != STATUS_OBJECT_NAME_NOT_FOUND
	      && status != STATUS_NO_SUCH_FILE) /* ENOENT on NFS or 9x share */
	    {
	      /* The file exists, but the user can't access it for one reason
		 or the other.  To get the file attributes we try to access the
		 information by opening the parent directory and getting the
		 file attributes using a matching NtQueryDirectoryFile call. */
	      UNICODE_STRING dirname, basename;
	      OBJECT_ATTRIBUTES dattr;
	      HANDLE dir;
	      struct {
		FILE_DIRECTORY_INFORMATION fdi;
		WCHAR dummy_buf[NAME_MAX + 1];
	      } fdi_buf;

	      RtlSplitUnicodePath (&upath, &dirname, &basename);
	      InitializeObjectAttributes (&dattr, &dirname,
					  OBJ_CASE_INSENSITIVE, NULL, NULL);
	      status = NtOpenFile (&dir, SYNCHRONIZE | FILE_LIST_DIRECTORY,
				   &dattr, &io, FILE_SHARE_VALID_FLAGS,
				   FILE_SYNCHRONOUS_IO_NONALERT
				   | FILE_OPEN_FOR_BACKUP_INTENT
				   | FILE_DIRECTORY_FILE);
	      if (!NT_SUCCESS (status))
		{
		  debug_printf ("%p = NtOpenFile(%S)", status, &dirname);
		  fileattr = 0;
		}
	      else
		{
		  status = NtQueryDirectoryFile (dir, NULL, NULL, 0, &io,
						 &fdi_buf, sizeof fdi_buf,
						 FileDirectoryInformation,
						 TRUE, &basename, TRUE);
		  NtClose (dir);
		  if (!NT_SUCCESS (status))
		    {
		      debug_printf ("%p = NtQueryDirectoryFile(%S)",
				    status, &dirname);
		      fileattr = 0;
		    }
		  else
		    fileattr = fdi_buf.fdi.FileAttributes;
		}
	      ext_tacked_on = !!*ext_here;
	      goto file_not_symlink;
	    }
	  set_error (ENOENT);
	  continue;
	}
d2906 6
a2911 9
      /* Check file system while we're having the file open anyway. 
         This speeds up path_conv noticably (~10%). */
      fs.update (&upath, h);

      ext_tacked_on = !!*ext_here;

      if (pcheck_case != PCHECK_RELAXED && !case_check (path)
	  || (opt & PC_SYM_IGNORE))
	goto file_not_symlink;
d2913 6
a2918 1
      res = -1;
d2920 1
a2920 12
      /* Windows shortcuts are potentially treated as symlinks.  Valid Cygwin
	 & U/WIN shortcuts are R/O, but definitely not directories. */
      if ((fileattr & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_DIRECTORY))
	  == FILE_ATTRIBUTE_READONLY && suffix.lnk_match ())
	{
	  res = check_shortcut (h);
	  if (!res)
	    {
	      /* If searching for `foo' and then finding a `foo.lnk' which is
		 no shortcut, return the same as if file not found. */
	      if (!suffix.lnk_match () || !ext_tacked_on)
		goto file_not_symlink;
d2922 6
a2927 8
	      /* in case we're going to tack *another* .lnk on this filename. */
	      fileattr = INVALID_FILE_ATTRIBUTES;
	      continue;
	    }
	  if (contents[0] == ':' && contents[1] == '\\'
	      && parse_device (contents))
	    goto file_not_symlink;
	}
d2929 6
a2934 11
      /* Reparse points are potentially symlinks.  This check must be
         performed before checking the SYSTEM attribute for sysfile
	 symlinks, since reparse points can have this flag set, too.
	 For instance, Vista starts to create a couple of reparse points
	 with SYSTEM and HIDDEN flags set. */
      else if (fileattr & FILE_ATTRIBUTE_REPARSE_POINT)
	{
	  res = check_reparse_point (h);
	  if (!res)
	    goto file_not_symlink;
	}
d2936 1
a2936 10
      /* This is the old Cygwin method creating symlinks.  A symlink will
         have the `system' file attribute.  Only files can be symlinks
	 (which can be symlinks to directories). */
      else if ((fileattr & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY))
	       == FILE_ATTRIBUTE_SYSTEM)
	{
	  res = check_sysfile (h);
	  if (!res)
	    goto file_not_symlink;
	}
d2938 9
a2946 9
      /* If the file could be opened with FILE_READ_EA, and if it's on a
         NFS share, check if it's a symlink.  Only files can be symlinks
	 (which can be symlinks to directories). */
      else if (!no_ea && !(fileattr & FILE_ATTRIBUTE_DIRECTORY) && fs.is_nfs ())
        {
	  res = check_nfs_symlink (h);
	  if (!res)
	    goto file_not_symlink;
	}
d2948 6
a2953 5
      /* Normal file. */
      else
	goto file_not_symlink;

      break;
d2955 8
d2964 1
a2964 6
    file_not_symlink:
      issymlink = false;
      syscall_printf ("%s", isdevice ? "is a device" : "not a symlink");
      res = 0;
      break;
    }
a2965 2
  if (h)
    NtClose (h);
d2967 5
a2971 40
  syscall_printf ("%d = symlink.check (%s, %p) (%p)",
		  res, suffix.path, contents, pflags);
  return res;
}

/* "path" is the path in a virtual symlink.  Set a symlink_info struct from
   that and proceed with further path checking afterwards. */
int
symlink_info::set (char *path)
{
  strcpy (contents, path);
  pflags = PATH_SYMLINK;
  fileattr = FILE_ATTRIBUTE_NORMAL;
  error = 0;
  issymlink = true;
  isdevice = false;
  ext_tacked_on = case_clash = false;
  ext_here = NULL;
  extn = major = minor = mode = 0;
  return strlen (path);
}

/* Check the correct case of the last path component (given in DOS style).
   Adjust the case in this->path if pcheck_case == PCHECK_ADJUST or return
   false if pcheck_case == PCHECK_STRICT.
   Dont't call if pcheck_case == PCHECK_RELAXED.
*/

bool
symlink_info::case_check (char *path)
{
  WIN32_FIND_DATA data;
  HANDLE h;
  char *c;

  /* Set a pointer to the beginning of the last component. */
  if (!(c = strrchr (path, '\\')))
    c = path;
  else
    ++c;
d2973 11
a2983 4
  if ((h = FindFirstFile (path, &data))
      != INVALID_HANDLE_VALUE)
    {
      FindClose (h);
d2985 7
a2991 9
      /* If that part of the component exists, check the case. */
      if (strncmp (c, data.cFileName, strlen (data.cFileName)))
	{
	  case_clash = true;

	  /* If check is set to STRICT, a wrong case results
	     in returning a ENOENT. */
	  if (pcheck_case == PCHECK_STRICT)
	    return false;
d2993 2
a2994 7
	  /* PCHECK_ADJUST adjusts the case in the incoming
	     path which points to the path in *this. */
	  strcpy (c, data.cFileName);
	}
    }
  return true;
}
d2996 12
a3007 1
/* readlink system call */
d3009 6
a3014 8
extern "C" ssize_t
readlink (const char *path, char *buf, size_t buflen)
{
  if (buflen < 0)
    {
      set_errno (ENAMETOOLONG);
      return -1;
    }
d3016 4
a3019 1
  path_conv pathbuf (path, PC_SYM_CONTENTS, stat_suffixes);
d3021 5
a3025 6
  if (pathbuf.error)
    {
      set_errno (pathbuf.error);
      syscall_printf ("-1 = readlink (%s, %p, %d)", path, buf, buflen);
      return -1;
    }
d3027 13
a3039 5
  if (!pathbuf.exists ())
    {
      set_errno (ENOENT);
      return -1;
    }
d3041 10
a3050 6
  if (!pathbuf.issymlink ())
    {
      if (pathbuf.exists ())
	set_errno (EINVAL);
      return -1;
    }
d3052 5
a3056 2
  ssize_t len = min (buflen, strlen (pathbuf.get_win32 ()));
  memcpy (buf, pathbuf.get_win32 (), len);
d3058 2
a3059 16
  /* errno set by symlink.check if error */
  return len;
}

/* Some programs rely on st_dev/st_ino being unique for each file.
   Hash the path name and hope for the best.  The hash arg is not
   always initialized to zero since readdir needs to compute the
   dirent ino_t based on a combination of the hash of the directory
   done during the opendir call and the hash or the filename within
   the directory.  FIXME: Not bullet-proof. */
/* Cygwin internal */
__ino64_t __stdcall
hash_path_name (__ino64_t hash, PUNICODE_STRING name)
{
  if (name->Length == 0)
    return hash;
a3060 59
  /* Build up hash. Name is already normalized */
  USHORT len = name->Length / sizeof (WCHAR);
  for (USHORT idx = 0; idx < len; ++idx)
    hash = RtlUpcaseUnicodeChar (name->Buffer[idx])
	   + (hash << 6) + (hash << 16) - hash;
  return hash;
}

__ino64_t __stdcall
hash_path_name (__ino64_t hash, PCWSTR name)
{
  UNICODE_STRING uname;
  RtlInitUnicodeString (&uname, name);
  return hash_path_name (hash, &uname);
}

__ino64_t __stdcall
hash_path_name (__ino64_t hash, const char *name)
{
  UNICODE_STRING uname;
  RtlCreateUnicodeStringFromAsciiz (&uname, name);
  __ino64_t ret = hash_path_name (hash, &uname);
  RtlFreeUnicodeString (&uname);
  return ret;
}

extern "C" char *
getcwd (char *buf, size_t ulen)
{
  char* res = NULL;
  myfault efault;
  if (efault.faulted (EFAULT))
      /* errno set */;
  else if (ulen == 0 && buf)
    set_errno (EINVAL);
  else
    res = cygheap->cwd.get (buf, 1, 1, ulen);
  return res;
}

/* getwd: Legacy. */
extern "C" char *
getwd (char *buf)
{
  return getcwd (buf, PATH_MAX + 1);  /*Per SuSv3!*/
}

/* chdir: POSIX 5.2.1.1 */
extern "C" int
chdir (const char *in_dir)
{
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  if (!*in_dir)
    {
      set_errno (ENOENT);
      return -1;
    }
d3062 5
a3066 1
  syscall_printf ("dir '%s'", in_dir);
d3068 5
a3072 9
  /* Convert path.  First argument ensures that we don't check for NULL/empty/invalid
     again. */
  path_conv path (PC_NONULLEMPTY, in_dir, PC_SYM_FOLLOW | PC_POSIX);
  if (path.error)
    {
      set_errno (path.error);
      syscall_printf ("-1 = chdir (%s)", in_dir);
      return -1;
    }
d3074 6
a3079 50
  int res = -1;
  bool doit = false;
  const char *posix_cwd = NULL;
  int devn = path.get_devn ();
  if (!isvirtual_dev (devn))
    {
      /* The sequence chdir("xx"); chdir(".."); must be a noop if xx
	 is not a symlink. This is exploited by find.exe.
	 The posix_cwd is just path.normalized_path.
	 In other cases we let cwd.set obtain the Posix path through
	 the mount table. */
      if (!isdrive(path.normalized_path))
	posix_cwd = path.normalized_path;
      res = 0;
      doit = true;
    }
  else if (!path.exists ())
    set_errno (ENOENT);
  else if (!path.isdir ())
    set_errno (ENOTDIR);
  else
   {
     posix_cwd = path.normalized_path;
     res = 0;
   }

  if (!res)
    res = cygheap->cwd.set (path.get_nt_native_path (), posix_cwd, doit);

  /* Note that we're accessing cwd.posix without a lock here.  I didn't think
     it was worth locking just for strace. */
  syscall_printf ("%d = chdir() cygheap->cwd.posix '%s' native '%S'", res,
		  cygheap->cwd.posix, path.get_nt_native_path ());
  MALLOC_CHECK;
  return res;
}

extern "C" int
fchdir (int fd)
{
  int res;
  cygheap_fdget cfd (fd);
  if (cfd >= 0)
    res = chdir (cfd->get_name ());
  else
    res = -1;

  syscall_printf ("%d = fchdir (%d)", res, fd);
  return res;
}
d3081 5
a3085 1
/******************** Exported Path Routines *********************/
d3087 5
a3091 2
/* Cover functions to the path conversion routines.
   These are exported to the world as cygwin_foo by cygwin.din.  */
d3093 25
a3117 16
#define return_with_errno(x) \
  do {\
    int err = (x);\
    if (!err)\
     return 0;\
    set_errno (err);\
    return -1;\
  } while (0)

extern "C" ssize_t
cygwin_conv_path (cygwin_conv_path_t what, const void *from, void *to,
		  size_t size)
{
  tmp_pathbuf tp;
  myfault efault;
  if (efault.faulted (EFAULT))
d3119 1
d3121 2
a3122 6
  path_conv p;
  size_t lsiz = 0;
  char *buf = NULL;
  int error = 0;
  bool relative = !!(what & CCP_RELATIVE);
  what &= ~CCP_RELATIVE;
d3124 15
a3138 64
  switch (what)
    {
    case CCP_POSIX_TO_WIN_A:
      p.check ((const char *) from,
	       PC_POSIX | PC_SYM_FOLLOW | PC_NO_ACCESS_CHECK | PC_NOWARN
	       | (relative ? PC_NOFULL : 0));
      if (p.error)
	return_with_errno (p.error);
      PUNICODE_STRING up = p.get_nt_native_path ();
      buf = tp.c_get ();
      sys_wcstombs (buf, NT_MAX_PATH, up->Buffer, up->Length / sizeof (WCHAR));
      buf += 4; /* Skip \??\ */
      if (buf[1] != ':') /* native UNC path */
	*(buf += 2) = '\\';
      lsiz = strlen (buf) + 1;
      break;
    case CCP_POSIX_TO_WIN_W:
      p.check ((const char *) from,
	       PC_POSIX | PC_SYM_FOLLOW | PC_NO_ACCESS_CHECK | PC_NOWARN
	       | (relative ? PC_NOFULL : 0));
      if (p.error)
	return_with_errno (p.error);
      lsiz = (p.get_wide_win32_path_len () + 1) * sizeof (WCHAR);
      break;
    case CCP_WIN_A_TO_POSIX:
      buf = tp.c_get ();
      error = mount_table->conv_to_posix_path ((const char *) from, buf,
					       relative);
      if (error)
	return_with_errno (error);
      lsiz = strlen (buf) + 1;
      break;
    case CCP_WIN_W_TO_POSIX:
      buf = tp.c_get ();
      error = mount_table->conv_to_posix_path ((const PWCHAR) from, buf,
					       relative);
      if (error)
	return_with_errno (error);
      lsiz = strlen (buf) + 1;
      break;
    default:
      set_errno (EINVAL);
      return -1;
    }
  if (!size)
    return lsiz;
  if (size < lsiz)
    {
      set_errno (ENOSPC);
      return -1;
    }
  switch (what)
    {
    case CCP_POSIX_TO_WIN_A:
    case CCP_WIN_A_TO_POSIX:
    case CCP_WIN_W_TO_POSIX:
      strcpy ((char *) to, buf);
      break;
    case CCP_POSIX_TO_WIN_W:
      p.get_wide_win32_path ((PWCHAR) to);
      break;
    }
  return 0;
}
d3140 4
a3143 13
extern "C" void *
cygwin_create_path (cygwin_conv_path_t what, const void *from)
{
  void *to;
  ssize_t size = cygwin_conv_path (what, from, NULL, 0);
  if (size <= 0)
    return NULL;
  if (!(to = malloc (size)))
    return NULL;
  if (cygwin_conv_path (what, from, to, size) == -1)
    return NULL;
  return to;
}
d3145 17
d3163 15
a3177 41
extern "C" int
cygwin_conv_to_win32_path (const char *path, char *win32_path)
{
  return cygwin_conv_path (CCP_POSIX_TO_WIN_A | CCP_RELATIVE, path, win32_path,
			   MAX_PATH);
}

extern "C" int
cygwin_conv_to_full_win32_path (const char *path, char *win32_path)
{
  return cygwin_conv_path (CCP_POSIX_TO_WIN_A | CCP_ABSOLUTE, path, win32_path,
			   MAX_PATH);
}

/* This is exported to the world as cygwin_foo by cygwin.din.  */

extern "C" int
cygwin_conv_to_posix_path (const char *path, char *posix_path)
{
  return cygwin_conv_path (CCP_WIN_A_TO_POSIX | CCP_RELATIVE, path, posix_path,
			   MAX_PATH);
}

extern "C" int
cygwin_conv_to_full_posix_path (const char *path, char *posix_path)
{
  return cygwin_conv_path (CCP_WIN_A_TO_POSIX | CCP_ABSOLUTE, path, posix_path,
			   MAX_PATH);
}

/* The realpath function is supported on some UNIX systems.  */

extern "C" char *
realpath (const char *path, char *resolved)
{
  /* Make sure the right errno is returned if path is NULL. */
  if (!path)
    {
      set_errno (EINVAL);
      return NULL;
    }
d3179 18
a3196 6
  /* Guard reading from a potentially invalid path and writing to a
     potentially invalid resolved. */
  tmp_pathbuf tp;
  myfault efault;
  if (efault.faulted (EFAULT))
    return NULL;
d3198 3
a3200 8
  char *tpath;
  if (isdrive (path))
    {
      tpath = tp.c_get ();
      mount_table->cygdrive_posix_path (path, tpath, 0);
    }
  else
    tpath = (char *) path;
d3202 1
a3202 1
  path_conv real_path (tpath, PC_SYM_FOLLOW | PC_POSIX, stat_suffixes);
d3204 5
d3210 8
a3217 5
  /* Linux has this funny non-standard extension.  If "resolved" is NULL,
     realpath mallocs the space by itself and returns it to the application.
     The application is responsible for calling free() then.  This extension
     is backed by POSIX, which allows implementation-defined behaviour if
     "resolved" is NULL.  That's good enough for us to do the same here. */
d3219 22
a3240 11
  if (!real_path.error && real_path.exists ())
    {
      if (!resolved)
	{
	  resolved = (char *) malloc (strlen (real_path.normalized_path) + 1);
	  if (!resolved)
	    return NULL;
	}
      strcpy (resolved, real_path.normalized_path);
      return resolved;
    }
d3242 54
a3295 23
  /* FIXME: on error, we are supposed to put the name of the path
     component which could not be resolved into RESOLVED.  */
  if (resolved)
    resolved[0] = '\0';
  set_errno (real_path.error ?: ENOENT);
  return NULL;
}

/* Return non-zero if path is a POSIX path list.
   This is exported to the world as cygwin_foo by cygwin.din.

DOCTOOL-START
<sect1 id="add-func-cygwin-posix-path-list-p">
  <para>Rather than use a mode to say what the "proper" path list
  format is, we allow any, and give apps the tools they need to
  convert between the two.  If a ';' is present in the path list it's
  a Win32 path list.  Otherwise, if the first path begins with
  [letter]: (in which case it can be the only element since if it
  wasn't a ';' would be present) it's a Win32 path list.  Otherwise,
  it's a POSIX path list.</para>
</sect1>
DOCTOOL-END
  */
d3297 25
a3321 31
extern "C" int
cygwin_posix_path_list_p (const char *path)
{
  int posix_p = !(strchr (path, ';') || isdrive (path));
  return posix_p;
}

/* These are used for apps that need to convert env vars like PATH back and
   forth.  The conversion is a two step process.  First, an upper bound on the
   size of the buffer needed is computed.  Then the conversion is done.  This
   allows the caller to use alloca if it wants.  */

static int
conv_path_list_buf_size (const char *path_list, bool to_posix)
{
  int i, num_elms, max_mount_path_len, size;
  const char *p;

  path_conv pc(".", PC_POSIX);
  /* The theory is that an upper bound is
     current_size + (num_elms * max_mount_path_len)  */
  /* FIXME: This method is questionable in the long run. */

  unsigned nrel;
  char delim = to_posix ? ';' : ':';
  for (p = path_list, num_elms = nrel = 0; p; num_elms++)
    {
      if (!isabspath (p))
	nrel++;
      p = strchr (++p, delim);
    }
d3323 2
a3324 10
  /* 7: strlen ("//c") + slop, a conservative initial value */
  for (max_mount_path_len = sizeof ("/cygdrive/X"), i = 0;
       i < mount_table->nmounts; i++)
    {
      int mount_len = (to_posix
		       ? mount_table->mount[i].posix_pathlen
		       : mount_table->mount[i].native_pathlen);
      if (max_mount_path_len < mount_len)
	max_mount_path_len = mount_len;
    }
d3326 6
a3331 110
  /* 100: slop */
  size = strlen (path_list)
    + (num_elms * max_mount_path_len)
    + (nrel * strlen (to_posix ? pc.normalized_path : pc.get_win32 ()))
    + 100;

  return size;
}


extern "C" int
cygwin_win32_to_posix_path_list_buf_size (const char *path_list)
{
  return conv_path_list_buf_size (path_list, true);
}

extern "C" int
cygwin_posix_to_win32_path_list_buf_size (const char *path_list)
{
  return conv_path_list_buf_size (path_list, false);
}

extern "C" ssize_t
env_PATH_to_posix (const void *win32, void *posix, size_t size)
{
  return_with_errno (conv_path_list ((const char *) win32, (char *) posix,
				     size, ENV_CVT));
}

extern "C" int
cygwin_win32_to_posix_path_list (const char *win32, char *posix)
{
  return_with_errno (conv_path_list (win32, posix, MAX_PATH, 1));
}

extern "C" int
cygwin_posix_to_win32_path_list (const char *posix, char *win32)
{
  return_with_errno (conv_path_list (posix, win32, MAX_PATH, 0));
}

extern "C" ssize_t
cygwin_conv_path_list (cygwin_conv_path_t what, const void *from, void *to,
		       size_t size)
{
  /* FIXME: Path lists are (so far) always retaining relative paths. */
  what &= ~CCP_RELATIVE;
  switch (what)
    {
    case CCP_WIN_W_TO_POSIX:
    case CCP_POSIX_TO_WIN_W:
      /*FIXME*/
      api_fatal ("wide char path lists not yet supported");
      break;
    case CCP_WIN_A_TO_POSIX:
    case CCP_POSIX_TO_WIN_A:
      if (size == 0)
	return conv_path_list_buf_size ((const char *) from,
					what == CCP_WIN_A_TO_POSIX);
      return_with_errno (conv_path_list ((const char *) from, (char *) to,
					 size, what == CCP_WIN_A_TO_POSIX));
      break;
    default:
      break;
    }
  set_errno (EINVAL);
  return -1;
}

/* cygwin_split_path: Split a path into directory and file name parts.
   Buffers DIR and FILE are assumed to be big enough.

   Examples (path -> `dir' / `file'):
   / -> `/' / `'
   "" -> `.' / `'
   . -> `.' / `.' (FIXME: should this be `.' / `'?)
   .. -> `.' / `..' (FIXME: should this be `..' / `'?)
   foo -> `.' / `foo'
   foo/bar -> `foo' / `bar'
   foo/bar/ -> `foo' / `bar'
   /foo -> `/' / `foo'
   /foo/bar -> `/foo' / `bar'
   c: -> `c:/' / `'
   c:/ -> `c:/' / `'
   c:foo -> `c:/' / `foo'
   c:/foo -> `c:/' / `foo'
 */

extern "C" void
cygwin_split_path (const char *path, char *dir, char *file)
{
  int dir_started_p = 0;

  /* Deal with drives.
     Remember that c:foo <==> c:/foo.  */
  if (isdrive (path))
    {
      *dir++ = *path++;
      *dir++ = *path++;
      *dir++ = '/';
      if (!*path)
	{
	  *dir = 0;
	  *file = 0;
	  return;
	}
      if (isdirsep (*path))
	++path;
      dir_started_p = 1;
    }
d3333 51
a3383 15
  /* Determine if there are trailing slashes and "delete" them if present.
     We pretend as if they don't exist.  */
  const char *end = path + strlen (path);
  /* path + 1: keep leading slash.  */
  while (end > path + 1 && isdirsep (end[-1]))
    --end;

  /* At this point, END points to one beyond the last character
     (with trailing slashes "deleted").  */

  /* Point LAST_SLASH at the last slash (duh...).  */
  const char *last_slash;
  for (last_slash = end - 1; last_slash >= path; --last_slash)
    if (isdirsep (*last_slash))
      break;
d3385 9
a3393 18
  if (last_slash == path)
    {
      *dir++ = '/';
      *dir = 0;
    }
  else if (last_slash > path)
    {
      memcpy (dir, path, last_slash - path);
      dir[last_slash - path] = 0;
    }
  else
    {
      if (dir_started_p)
	; /* nothing to do */
      else
	*dir++ = '.';
      *dir = 0;
    }
d3395 4
a3398 28
  memcpy (file, last_slash + 1, end - last_slash - 1);
  file[end - last_slash - 1] = 0;
}

/*****************************************************************************/

static inline PRTL_USER_PROCESS_PARAMETERS
get_user_proc_parms ()
{
  return NtCurrentTeb ()->Peb->ProcessParameters;
}

/* Initialize cygcwd 'muto' for serializing access to cwd info. */
void
cwdstuff::init ()
{
  cwd_lock.init ("cwd_lock");
  /* Initially re-open the cwd to allow POSIX semantics. */
  set (NULL, NULL, true);
}

/* Chdir and fill out the elements of a cwdstuff struct. */
int
cwdstuff::set (PUNICODE_STRING nat_cwd, const char *posix_cwd, bool doit)
{
  int res = 0;
  UNICODE_STRING upath;
  size_t len = 0;
d3400 5
a3404 1
  cwd_lock.acquire ();
d3406 10
a3415 12
  if (nat_cwd)
    {
      upath = *nat_cwd;
      if (upath.Buffer[0] == L'/') /* Virtual path.  Never use in PEB. */
	doit = false;
      else
	{
	  len = upath.Length / sizeof (WCHAR) - 4;
	  if (RtlEqualUnicodePathPrefix (&upath, L"\\??\\UNC\\", TRUE))
	    len -= 2;
	}
    }
d3417 1
a3417 4
  if (doit)
    {
      /* We utilize the user parameter block.  The directory is
	 stored manually there.  Why the hassle?
d3419 9
a3427 75
	 - SetCurrentDirectory fails for directories with strict
	   permissions even for processes with the SE_BACKUP_NAME
	   privilege enabled.  The reason is apparently that
	   SetCurrentDirectory calls NtOpenFile without the
	   FILE_OPEN_FOR_BACKUP_INTENT flag set.

	 - Unlinking a cwd fails because SetCurrentDirectory seems to
	   open directories so that deleting the directory is disallowed.
	   The below code opens with *all* sharing flags set. */
      HANDLE h;
      NTSTATUS status;
      IO_STATUS_BLOCK io;
      OBJECT_ATTRIBUTES attr;
      PHANDLE phdl;

      RtlAcquirePebLock ();
      phdl = &get_user_proc_parms ()->CurrentDirectoryHandle;
      if (!nat_cwd) /* On init, just reopen CWD with desired access flags. */
	RtlInitUnicodeString (&upath, L"");
      InitializeObjectAttributes (&attr, &upath,
				  OBJ_CASE_INSENSITIVE | OBJ_INHERIT,
				  nat_cwd ? NULL : *phdl, NULL);
      status = NtOpenFile (&h, SYNCHRONIZE | FILE_TRAVERSE, &attr, &io,
			   FILE_SHARE_VALID_FLAGS,
			   FILE_DIRECTORY_FILE
			   | FILE_SYNCHRONOUS_IO_NONALERT
			   | FILE_OPEN_FOR_BACKUP_INTENT);
      if (!NT_SUCCESS (status))
	{
	  RtlReleasePebLock ();
	  __seterrno_from_nt_status (status);
	  res = -1;
	  goto out;
	}
      /* Workaround a problem in Vista/Longhorn which fails in subsequent
	 calls to CreateFile with ERROR_INVALID_HANDLE if the handle in
	 CurrentDirectoryHandle changes without calling SetCurrentDirectory,
	 and the filename given to CreateFile is a relative path.  It looks
	 like Vista stores a copy of the CWD handle in some other undocumented
	 place.  The NtClose/DuplicateHandle reuses the original handle for
	 the copy of the new handle and the next CreateFile works.
	 Note that this is not thread-safe (yet?) */
      NtClose (*phdl);
      if (DuplicateHandle (GetCurrentProcess (), h, GetCurrentProcess (), phdl,
			   0, TRUE, DUPLICATE_SAME_ACCESS))
	NtClose (h);
      else
	*phdl = h;
      dir = *phdl;

      /* No need to set path on init. */
      if (nat_cwd
	  /* TODO:
	     Check the length of the new CWD.  Windows can only handle
	     CWDs of up to MAX_PATH length, including a trailing backslash.
	     If the path is longer, it's not an error condition for Cygwin,
	     so we don't fail.  Windows on the other hand has a problem now.
	     For now, we just don't store the path in the PEB and proceed as
	     usual. */
	  && len <= MAX_PATH - (nat_cwd->Buffer[len - 1] == L'\\' ? 1 : 2))
	{
	  /* Convert to a Win32 path. */
	  upath.Buffer += upath.Length / sizeof (WCHAR) - len;
	  if (upath.Buffer[1] == L'\\') /* UNC path */
	    upath.Buffer[0] = L'\\';
	  upath.Length = len * sizeof (WCHAR);
	  /* Append backslash if necessary. */
	  if (upath.Buffer[len - 1] != L'\\')
	    {
	      upath.Buffer[len] = L'\\';
	      upath.Length += sizeof (WCHAR);
	    }
	  RtlCopyUnicodeString (&get_user_proc_parms ()->CurrentDirectoryName,
				&upath);
	}
d3429 14
a3442 2
      RtlReleasePebLock ();
    }
d3444 1
a3444 58
  if (nat_cwd || !win32.Buffer)
    {
      /* If there is no win32 path */
      if (!nat_cwd)
	{
	  PUNICODE_STRING pdir;

	  RtlAcquirePebLock ();
	  pdir = &get_user_proc_parms ()->CurrentDirectoryName;
	  RtlInitEmptyUnicodeString (&win32,
				     (PWCHAR) crealloc_abort (win32.Buffer,
							      pdir->Length + 2),
				     pdir->Length + 2);
	  RtlCopyUnicodeString (&win32, pdir);
	  RtlReleasePebLock ();
	  /* Remove trailing slash. */
	  if (win32.Length > 3 * sizeof (WCHAR))
	    win32.Length -= sizeof (WCHAR);
	  posix_cwd = NULL;
	}
      else
	{
	  if (upath.Buffer[0] == L'/') /* Virtual path, don't mangle. */
	    ;
	  else if (!doit)
	    {
	      /* Convert to a Win32 path. */
	      upath.Buffer += upath.Length / sizeof (WCHAR) - len;
	      if (upath.Buffer[1] == L'\\') /* UNC path */
		upath.Buffer[0] = L'\\';
	      upath.Length = len * sizeof (WCHAR);
	    }
	  else if (upath.Length > 3 * sizeof (WCHAR))
	    upath.Length -= sizeof (WCHAR); /* Strip trailing backslash */
	  RtlInitEmptyUnicodeString (&win32,
				     (PWCHAR) crealloc_abort (win32.Buffer,
							      upath.Length + 2),
				     upath.Length + 2);
	  RtlCopyUnicodeString (&win32, &upath);
	}
      /* Make sure it's NUL-termniated. */
      win32.Buffer[win32.Length / sizeof (WCHAR)] = L'\0';
      if (!doit)			 /* Virtual path */
	drive_length = 0;
      else if (win32.Buffer[1] == L':')	 /* X: */
	drive_length = 2;
      else if (win32.Buffer[1] == L'\\') /* UNC path */
	{
	  PWCHAR ptr = wcschr (win32.Buffer + 2, L'\\');
	  if (ptr)
	    ptr = wcschr (ptr + 1, L'\\');
	  if (ptr)
	    drive_length = ptr - win32.Buffer;
	  else
	    drive_length = win32.Length / sizeof (WCHAR);
	}
      else				 /* Shouldn't happen */
	drive_length = 0;
d3446 6
a3451 9
      tmp_pathbuf tp;
      if (!posix_cwd)
	{
	  posix_cwd = (const char *) tp.c_get ();
	  mount_table->conv_to_posix_path (win32.Buffer, (char *) posix_cwd, 0);
	}
      posix = (char *) crealloc_abort (posix, strlen (posix_cwd) + 1);
      stpcpy (posix, posix_cwd);
    }
d3453 5
a3457 21
out:
  cwd_lock.release ();
  return res;
}

/* Copy the value for either the posix or the win32 cwd into a buffer. */
char *
cwdstuff::get (char *buf, int need_posix, int with_chroot, unsigned ulen)
{
  MALLOC_CHECK;

  tmp_pathbuf tp;
  if (ulen)
    /* nothing */;
  else if (buf == NULL)
    ulen = (unsigned) -1;
  else
    {
      set_errno (EINVAL);
      goto out;
    }
d3459 16
a3474 1
  cwd_lock.acquire ();
d3476 21
a3496 9
  char *tocopy;
  if (!need_posix)
    {
      tocopy = tp.c_get ();
      sys_wcstombs (tocopy, NT_MAX_PATH, win32.Buffer,
		    win32.Length / sizeof (WCHAR));
    }
  else
    tocopy = posix;
d3498 3
a3500 14
  debug_printf ("posix %s", posix);
  if (strlen (tocopy) >= ulen)
    {
      set_errno (ERANGE);
      buf = NULL;
    }
  else
    {
      if (!buf)
	buf = (char *) malloc (strlen (tocopy) + 1);
      strcpy (buf, tocopy);
      if (!buf[0])	/* Should only happen when chroot */
	strcpy (buf, "/");
    }
d3502 8
a3509 1
  cwd_lock.release ();
d3511 3
a3513 36
out:
  syscall_printf ("(%s) = cwdstuff::get (%p, %d, %d, %d), errno %d",
		  buf, buf, ulen, need_posix, with_chroot, errno);
  MALLOC_CHECK;
  return buf;
}

int etc::curr_ix = 0;
/* Note that the first elements of the below arrays are unused */
bool etc::change_possible[MAX_ETC_FILES + 1];
OBJECT_ATTRIBUTES etc::fn[MAX_ETC_FILES + 1];
LARGE_INTEGER etc::last_modified[MAX_ETC_FILES + 1];

int
etc::init (int n, PUNICODE_STRING etc_fn)
{
  if (n > 0)
    /* ok */;
  else if (++curr_ix <= MAX_ETC_FILES)
    n = curr_ix;
  else
    api_fatal ("internal error");

  InitializeObjectAttributes (&fn[n], etc_fn, OBJ_CASE_INSENSITIVE, NULL, NULL);
  change_possible[n] = false;
  test_file_change (n);
  paranoid_printf ("fn[%d] %S, curr_ix %d", n, fn[n].ObjectName, curr_ix);
  return n;
}

bool
etc::test_file_change (int n)
{
  NTSTATUS status;
  FILE_NETWORK_OPEN_INFORMATION fnoi;
  bool res;
d3515 6
a3520 38
  status = NtQueryFullAttributesFile (&fn[n], &fnoi);
  if (!NT_SUCCESS (status))
    {
      res = true;
      memset (last_modified + n, 0, sizeof (last_modified[n]));
      debug_printf ("NtQueryFullAttributesFile (%S) failed, %p",
		    fn[n].ObjectName, status);
    }
  else
    {
      res = CompareFileTime ((FILETIME *) &fnoi.LastWriteTime,
			     (FILETIME *) last_modified + n) > 0;
      last_modified[n].QuadPart = fnoi.LastWriteTime.QuadPart;
    }

  paranoid_printf ("fn[%d] %S res %d", n, fn[n].ObjectName, res);
  return res;
}

bool
etc::dir_changed (int n)
{
  if (!change_possible[n])
    {
      static HANDLE changed_h NO_COPY;
      NTSTATUS status;
      IO_STATUS_BLOCK io;

      if (!changed_h)
	{
	  OBJECT_ATTRIBUTES attr;

	  path_conv dir ("/etc");
	  status = NtOpenFile (&changed_h, SYNCHRONIZE | FILE_LIST_DIRECTORY,
			       dir.get_object_attr (attr, sec_none_nih), &io,
			       FILE_SHARE_VALID_FLAGS, FILE_DIRECTORY_FILE);
	  if (!NT_SUCCESS (status))
	    {
d3522 2
a3523 2
	      system_printf ("NtOpenFile (%S) failed, %p",
			     dir.get_nt_native_path (), status);
d3525 11
a3535 11
	      changed_h = INVALID_HANDLE_VALUE;
	    }
	  else
	    {
	      status = NtNotifyChangeDirectoryFile (changed_h, NULL, NULL,
						NULL, &io, NULL, 0,
						FILE_NOTIFY_CHANGE_LAST_WRITE
						| FILE_NOTIFY_CHANGE_FILE_NAME,
						FALSE);
	      if (!NT_SUCCESS (status))
		{
d3537 2
a3538 2
		  system_printf ("NtNotifyChangeDirectoryFile (1) failed, %p",
				 status);
d3540 6
a3545 6
		  NtClose (changed_h);
		  changed_h = INVALID_HANDLE_VALUE;
		}
	    }
	  memset (change_possible, true, sizeof (change_possible));
	}
d3547 11
a3557 11
      if (changed_h == INVALID_HANDLE_VALUE)
	change_possible[n] = true;
      else if (WaitForSingleObject (changed_h, 0) == WAIT_OBJECT_0)
	{
	  status = NtNotifyChangeDirectoryFile (changed_h, NULL, NULL,
						NULL, &io, NULL, 0,
						FILE_NOTIFY_CHANGE_LAST_WRITE
						| FILE_NOTIFY_CHANGE_FILE_NAME,
						FALSE);
	  if (!NT_SUCCESS (status))
	    {
d3559 2
a3560 2
	      system_printf ("NtNotifyChangeDirectoryFile (2) failed, %p",
			     status);
d3562 63
a3624 6
	      NtClose (changed_h);
	      changed_h = INVALID_HANDLE_VALUE;
	    }
	  memset (change_possible, true, sizeof change_possible);
	}
    }
d3626 9
a3634 56
  paranoid_printf ("fn[%d] %S change_possible %d",
		   n, fn[n].ObjectName, change_possible[n]);
  return change_possible[n];
}

bool
etc::file_changed (int n)
{
  bool res = false;
  if (dir_changed (n) && test_file_change (n))
    res = true;
  change_possible[n] = false;	/* Change is no longer possible */
  paranoid_printf ("fn[%d] %S res %d", n, fn[n].ObjectName, res);
  return res;
}

/* No need to be reentrant or thread-safe according to SUSv3.
   / and \\ are treated equally.  Leading drive specifiers are
   kept intact as far as it makes sense.  Everything else is
   POSIX compatible. */
extern "C" char *
basename (char *path)
{
  static char buf[4];
  char *c, *d, *bs = path;

  if (!path || !*path)
    return strcpy (buf, ".");
  if (isalpha (path[0]) && path[1] == ':')
    bs += 2;
  else if (strspn (path, "/\\") > 1)
    ++bs;
  c = strrchr (bs, '/');
  if ((d = strrchr (c ?: bs, '\\')) > c)
    c = d;
  if (c)
    {
      /* Trailing (back)slashes are eliminated. */
      while (c && c > bs && c[1] == '\0')
	{
	  *c = '\0';
	  c = strrchr (bs, '/');
	  if ((d = strrchr (c ?: bs, '\\')) > c)
	    c = d;
	}
      if (c && (c > bs || c[1]))
	return c + 1;
    }
  else if (!bs[0])
    {
      stpncpy (buf, path, bs - path);
      stpcpy (buf + (bs - path), ".");
      return buf;
    }
  return path;
}
d3636 38
a3673 48
/* No need to be reentrant or thread-safe according to SUSv3.
   / and \\ are treated equally.  Leading drive specifiers and
   leading double (back)slashes are kept intact as far as it
   makes sense.  Everything else is POSIX compatible. */
extern "C" char *
dirname (char *path)
{
  static char buf[4];
  char *c, *d, *bs = path;

  if (!path || !*path)
    return strcpy (buf, ".");
  if (isalpha (path[0]) && path[1] == ':')
    bs += 2;
  else if (strspn (path, "/\\") > 1)
    ++bs;
  c = strrchr (bs, '/');
  if ((d = strrchr (c ?: bs, '\\')) > c)
    c = d;
  if (c)
    {
      /* Trailing (back)slashes are eliminated. */
      while (c && c > bs && c[1] == '\0')
	{
	  *c = '\0';
	  c = strrchr (bs, '/');
	  if ((d = strrchr (c ?: bs, '\\')) > c)
	    c = d;
	}
      if (!c)
	strcpy (bs, ".");
      else if (c > bs)
	{
	  /* More trailing (back)slashes are eliminated. */
	  while (c > bs && (*c == '/' || *c == '\\'))
	    *c-- = '\0';
	}
      else
	c[1] = '\0';
    }
  else
    {
      stpncpy (buf, path, bs - path);
      stpcpy (buf + (bs - path), ".");
      return buf;
    }
  return path;
}
@


1.503
log
@	* fhandler_disk_file.cc (get_ino_by_handle): Rename pfai to fai.
	(fhandler_base::fstat_by_handle): Drop fai_size and pfai in favor of
	static struct fai_buf.  Restructure.
	(fhandler_base::fstat_by_name): Drop fvi_size and pfvi.  Drop fdi_size
	and pfdi in favor of static struct fdi_buf.  Drop redundant test for
	existance.  Use FileDirectoryInformation class instead of
	FileBothDirectoryInformation.  Drop call to NtQueryVolumeInformationFile
	in favor of using pc.fs_serial_number ().  Fix FileId information given
	to fstat_helper.
	(fhandler_disk_file::fstatvfs): Drop fvi_size, pfvi, fai_size and pfai.
	Drop getting FileFsVolumeInformation and FileFsAttributeInformation in
	favor of using the related path_conv info.
	(fhandler_disk_file::opendir): Fix comment.
	(fhandler_disk_file::readdir): Ditto.  Use FileDirectoryInformation
	class instead of FileBothDirectoryInformation.
	* path.cc (fs_info::update): Store MaximumComponentNameLength in new
	member name_len.
	* path.h (struct fs_info): Use ULONG rather than DWORD.  Add member
	name_len to store MaximumComponentNameLength.  Add accessor methods.
	(path_conv::fs_name_len): New method.
@
text
@d2802 1
a2807 1
  tmp_pathbuf tp;
d2938 1
a2942 1
  tmp_pathbuf tp;
@


1.502
log
@	* fhandler.h (dirent_states): Add dirent_nfs_d_ino state and add it to
	dirent_info_mask.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Set
	dirent_nfs_d_ino flag for NFS shares.  Explain why.
	(fhandler_disk_file::readdir): Use FileNamesInformation instead of
	FileBothDirectoryInformation info class on NFS clients not supporting
	the FileIdBothDirectoryInformation info class.  Use local pointers to
	accommodate different offsets.
	* path.cc (symlink_info::check): Don't test directories for symlinks
	on NFS shares.  Enhance comment.
@
text
@d460 1
@


1.501
log
@	* path.cc (symlink_worker): Fix EA buffer size info given to
	NtCreateFile.
	(symlink_info::check_nfs_symlink): Get 64K buffer for EA buffer.
	Change EA buffer size info given to NtQueryEaFile accordingly.
@
text
@d2517 3
a2519 2
         NFS share, check if it's a symlink. */
      else if (!no_ea && fs.is_nfs ())
@


1.500
log
@	* path.cc (symlink_info::check_shortcut): Minimize requested file
	access flags.
	(symlink_info::check_sysfile): Ditto.  Add missing `else'.
	(symlink_info::check): Only retry to open file if first try failed
	with access denied.
@
text
@d1618 1
a1618 1
			     pffei, NT_MAX_PATH);
d2057 3
a2059 4
  pffei = (PFILE_FULL_EA_INFORMATION) tp.c_get ();
  status = NtQueryEaFile (h, &io, pffei, NT_MAX_PATH, TRUE,
			  &fgei_buf.fgei, sizeof fgei_buf,
			  NULL, TRUE);
@


1.499
log
@	* path.cc (fs_info::update): Re-add opening the unsplitted path
	for fillout_mntent's sake.
@
text
@d1860 1
a1860 1
  status = NtOpenFile (&h, FILE_GENERIC_READ,
d1944 1
a1944 1
  status = NtOpenFile (&h, FILE_GENERIC_READ,
d1950 3
a1952 2
  if (!NT_SUCCESS (status = NtReadFile (h, NULL, NULL, NULL, &io, cookie_buf,
		   sizeof (cookie_buf), NULL, NULL)))
d2371 1
a2371 1
      if (!NT_SUCCESS (status))
@


1.498
log
@	* Makefile.in (DLL_OFILES): Add nfs.o.
	* fhandler.cc (fhandler_base::open): Open files on NFS shares with
	correct access flags and EAs.
	* fhandler.h (fhandler_base::fstat_by_nfs_ea): Declare.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): New method.
	(fhandler_base::fstat_by_handle): Call fstat_by_nfs_ea for files on
	NFS shares.
	(fhandler_disk_file::fchmod): Use NFS specific method to set mode for
	files on NFS shares.  Don't overrule errno from call to
	set_file_attribute with errno from NtSetInformationFile call.
	(fhandler_disk_file::fchown): Add comment.
	* mount.cc (fillout_mntent): Accommodate change in second parameter
	to fs_info::update.
	* nfs.cc: New file.
	* nfs.h: New file.
	* path.cc (fs_info::update): Take handle instead of bool as second
	parameter.  Use that handle if it's not NULL.  Only close handle if
	it has been opened here.  Use static defined buffers instead of
	alloca'd buffers.
	(path_conv::check): Call symlink_info::check with reference to fs.
	Don't call fs.update here if file exists.
	(conv_path_list): Prefer tmp_pathbuf buffer over using alloca.
	(symlink_worker): Use NFS specific method to create symlinks on NFS
	shares.  Prefer tmp_pathbuf buffer over using alloca.
	(symlink_info::check_shortcut): Reopen file from incoming handle
	with necessary FILE_GENERIC_READ flag.  Prefer tmp_pathbuf buffer over
	using alloca.
	(symlink_info::check_sysfile): Ditto.
	(symlink_info::check_reparse_point): Use tmp_pathbuf buffer to
	allocate REPARSE_DATA_BUFFER.
	(symlink_info::check_nfs_symlink): New method.
	(enum symlink_t): Remove.
	(symlink_info::check): Don't use NtQueryAttributesFile.  Rather, open
	file with necessary access flags and call NtQueryInformationFile.  Fix
	error handling in case file can't be opened.  For existing files, call
	fs_info::update here.  Restructure symlink checking to accommodate the
	fact that the file is already open.  Add case for NFS symlinks.
	* path.h (fs_info::update): Take handle instead of bool as second
	parameter.
@
text
@d399 2
@


1.497
log
@	* path.cc (path_conv::check): Free wide_path and normalized_path if
	necessary.
	* path.h (path_conv::path_conv): Set wide_path, normalized_path and
	normalized_path_size to 0 in all constructors.
@
text
@d70 1
d92 2
a93 1
  int check (char *path, const suffix_info *suffixes, unsigned opt);
d100 1
d374 1
a374 1
fs_info::update (PUNICODE_STRING upath, bool exists)
d383 8
a390 5
  PFILE_FS_ATTRIBUTE_INFORMATION pffai;
  const DWORD fvi_size = (NAME_MAX + 1) * sizeof (WCHAR)
			   + sizeof (FILE_FS_VOLUME_INFORMATION);
  PFILE_FS_VOLUME_INFORMATION pfvi = (PFILE_FS_VOLUME_INFORMATION)
				     alloca (fvi_size);
d393 3
a395 22
  InitializeObjectAttributes (&attr, upath, OBJ_CASE_INSENSITIVE, NULL, NULL);
  if (exists)
    status = NtOpenFile (&vol, READ_CONTROL, &attr, &io, FILE_SHARE_VALID_FLAGS,
			 FILE_OPEN_FOR_BACKUP_INTENT);
  while (!NT_SUCCESS (status)
	 && (attr.ObjectName->Length > 7 * sizeof (WCHAR)
	     || status == STATUS_NO_MEDIA_IN_DEVICE))
    {
      UNICODE_STRING dir;
      RtlSplitUnicodePath (attr.ObjectName, &dir, NULL);
      attr.ObjectName = &dir;
      if (status == STATUS_NO_MEDIA_IN_DEVICE)
	{
	  no_media = true;
	  dir.Length = 6 * sizeof (WCHAR);
	}
      else if (dir.Length > 7 * sizeof (WCHAR))
	dir.Length -= sizeof (WCHAR);
      status = NtOpenFile (&vol, READ_CONTROL, &attr, &io,
			   FILE_SHARE_VALID_FLAGS, FILE_OPEN_FOR_BACKUP_INTENT);
    }
  if (!NT_SUCCESS (status))
d397 28
a424 5
      debug_printf ("Cannot access path %S, status %08lx", attr.ObjectName,
							   status);
      clear ();
      NtClose (vol);
      return false;
d426 3
a428 1
  status = NtQueryVolumeInformationFile (vol, &io, pfvi, fvi_size,
d430 1
a430 1
  sernum = NT_SUCCESS (status) ? pfvi->VolumeSerialNumber : 0;
d444 3
a446 7
    {
      const ULONG size = sizeof (FILE_FS_ATTRIBUTE_INFORMATION)
			 + NAME_MAX * sizeof (WCHAR);
      pffai = (PFILE_FS_ATTRIBUTE_INFORMATION) alloca (size);
      status = NtQueryVolumeInformationFile (vol, &io, pffai, size,
					     FileFsAttributeInformation);
    }
d453 2
a454 1
      NtClose (vol);
d457 1
a457 1
   flags (pffai->FileSystemAttributes);
d481 2
a482 2
  RtlInitCountedUnicodeString (&fsname, pffai->FileSystemName,
			       pffai->FileSystemNameLength);
d525 2
a526 1
  NtClose (vol);
d1005 1
a1005 1
	  symlen = sym.check (full_path, suff, opt);
d1226 2
a1227 1
      if (fs.update (get_nt_native_path (), exists ()))
d1448 1
d1451 1
d1466 6
a1471 1
  char *srcbuf = (char *) alloca (strlen (src) + 1);
d1575 2
a1576 1
  if (use_winsym && !win32_newpath.exists ())
d1599 28
d1714 4
a1717 1
      buf = (char *) alloca (full_len + 1);
d1755 1
a1755 2
      unsigned short oldpath_len = strlen (oldpath);
      buf = (char *) alloca (sizeof (SYMLINK_COOKIE) + oldpath_len + 1);
d1778 1
a1778 1
	  __seterrno_from_nt_status  (status);
d1843 1
a1843 1
symlink_info::check_shortcut (HANDLE h)
d1845 1
d1850 2
d1853 1
d1857 10
d1872 1
a1872 1
      return 0;
d1876 5
a1880 2
    return 0;
  buf = (char *) alloca (fsi.EndOfFile.LowPart + 1);
d1885 1
a1885 1
      return 0;
d1923 3
d1930 1
a1930 1
symlink_info::check_sysfile (HANDLE h)
d1934 3
d1938 1
a1939 1
  int res = 0;
d1941 5
a1945 2
  status = NtReadFile (h, NULL, NULL, NULL, &io, cookie_buf,
		       sizeof (cookie_buf), NULL, NULL);
d1947 3
d1987 1
d1994 1
d1997 1
a1997 2
  PREPARSE_DATA_BUFFER rp = (PREPARSE_DATA_BUFFER)
			    alloca (MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
d2037 33
a2314 7
enum symlink_t {
  is_no_symlink,
  is_shortcut_symlink,
  is_reparse_symlink,
  is_sysfile_symlink
};

d2316 2
a2317 1
symlink_info::check (char *path, const suffix_info *suffixes, unsigned opt)
d2319 1
a2319 1
  HANDLE h;
d2347 1
d2351 32
a2382 2
      status = NtQueryAttributesFile (&attr, &fbi);
      if (NT_SUCCESS (status))
d2386 2
a2387 1
	  debug_printf ("%p = NtQueryAttributesFile (%S)", status, &upath);
d2407 1
a2407 1
	      && status != STATUS_NO_SUCH_FILE) /* File not found on 9x share */
d2453 2
a2454 3
	  if (set_error (geterrno_from_win_error
				(RtlNtStatusToDosError (status), EACCES)))
	    continue;
d2457 4
d2467 1
a2467 1
      symlink_t sym_check;
d2469 21
a2489 10
      sym_check = is_no_symlink;

      if ((fileattr & (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_REPARSE_POINT))
	  == FILE_ATTRIBUTE_DIRECTORY)
	goto file_not_symlink;

      /* Windows shortcuts are potentially treated as symlinks. */
      /* Valid Cygwin & U/WIN shortcuts are R/O. */
      if ((fileattr & FILE_ATTRIBUTE_READONLY) && suffix.lnk_match ())
	sym_check = is_shortcut_symlink;
a2496 29
	sym_check = is_reparse_symlink;

      /* This is the old Cygwin method creating symlinks: */
      /* A symlink will have the `system' file attribute. */
      /* Only files can be symlinks (which can be symlinks to directories). */
      else if (fileattr & FILE_ATTRIBUTE_SYSTEM)
	sym_check = is_sysfile_symlink;

      if (sym_check == is_no_symlink)
	goto file_not_symlink;

      res = -1;

      /* Open the file.  Opening reparse points must not use GENERIC_READ.
	 The reason is that Vista starts to create a couple of reparse
	 points for backward compatibility, hidden system files, explicitely
	 denying everyone FILE_READ_DATA access. */
      status = NtOpenFile (&h,
			   sym_check == is_reparse_symlink
			   ? READ_CONTROL : FILE_GENERIC_READ,
			   &attr, &io, FILE_SHARE_VALID_FLAGS,
			   FILE_OPEN_FOR_BACKUP_INTENT
			   | (sym_check == is_reparse_symlink
			      ? FILE_OPEN_REPARSE_POINT
			      : FILE_SYNCHRONOUS_IO_NONALERT));
      if (!NT_SUCCESS (status))
	goto file_not_symlink;

      switch (sym_check)
d2498 1
a2498 3
	case is_shortcut_symlink:
	  res = check_shortcut (h);
	  NtClose (h);
a2499 8
	    /* check more below */;
	  else if (contents[0] == ':' && contents[1] == '\\' && parse_device (contents))
	    goto file_not_symlink;
	  else
	    break;
	  /* If searching for `foo' and then finding a `foo.lnk' which is
	     no shortcut, return the same as if file not found. */
	  if (!suffix.lnk_match () || !ext_tacked_on)
d2501 1
d2503 7
a2509 5
	  fileattr = INVALID_FILE_ATTRIBUTES;
	  continue;		/* in case we're going to tack *another* .lnk on this filename. */
	case is_reparse_symlink:
	  res = check_reparse_point (h);
	  NtClose (h);
d2512 7
a2518 4
	  break;
	case is_sysfile_symlink:
	  res = check_sysfile (h);
	  NtClose (h);
a2520 3
	  break;
	default: /* Make gcc happy.  Won't happen. */
	  goto file_not_symlink;
d2522 5
d2529 1
d2537 3
@


1.496
log
@	* path.cc (path_conv::set_normalized_path): Drop strip_tail argument.
	Never strip trailing dots and spaces.
	* (path_conv::check): Accomodate above change.
	* path.h (path_conv::operator=): Ditto
	* dtable.cc (build_fh_dev): Ditto.
	* fhandler.h (fhandler_base::set_name): Ditto.

	* path.cc (transform_chars): Disable converting trailing dots and
	spaces.

	* path.cc (path_conv::check): Remove two disabled code snippets.
@
text
@d815 2
d821 2
@


1.495
log
@	* mount.cc (is_unc_share): Allow \\?\ prefix as well.  Enhance comment.
	(mount_info::from_fstab): Remove patch from 2008-04-29.

	* mount.cc (mount_info::conv_to_posix_path): Simplify test for native
	UNC path.
	* path.cc (normalize_win32_path): Ditto.
	(symlink_worker): Ditto.
	(symlink_info::posixify): Ditto.
	(cygwin_conv_path): Ditto.
@
text
@d534 1
a534 1
path_conv::set_normalized_path (const char *path_copy, bool strip_tail)
a536 8

  if (strip_tail)
    {
      while (*--p == '.' || *p == ' ')
	continue;
      *++p = '\0';
    }

d600 1
d603 2
d607 1
a1169 1
  bool strip_tail = false;
a1200 22
#if 0
	  /* Windows ignores trailing dots and spaces in the last path
	     component, and ignores exactly one trailing dot in inner
	     path components. */
	  char *tail = NULL;
	  for (char *p = path; *p; p++)
	    {
	      if (*p != '.' && *p != ' ')
		tail = NULL;
	      else if (!tail)
		tail = p;
	      if (tail && p[1] == '\\')
		{
		  if (p > tail || *tail != '.')
		    {
		      error = ENOENT;
		      return;
		    }
		  tail = NULL;
		}
	    }
#endif
d1204 1
a1204 4
	    {
	      *tail = '\0';
	      strip_tail = true;
	    }
a1227 5
#if 0
  if (issocket ())
    devn = FH_SOCKET;
#endif

d1264 1
a1264 1
      set_normalized_path (path_copy, strip_tail);
@


1.494
log
@	* path.cc (symlink_info::check): Avoid special handling for
	STATUS_BUFFER_OVERFLOW when calling NtQueryDirectoryFile.
	* strace.cc (strace::vprntf): Use bigger buffer.
@
text
@d1356 1
a1356 1
      if (ascii_strncasematch (src, "UNC", 3))
d1646 1
a1646 2
		 for ParseDisplayName.  I have no idea if it's able to take
		 long path names at all since I can't test it right now. */
d1648 1
a1648 1
	      if (!wcsncmp (wc, L"UNC\\", 4))
d2015 2
a2016 5
      if (!strncmp (srcbuf, "UNC\\", 4))
	{
	  srcbuf += 2;
	  *srcbuf = '\\';
	}
d2728 1
a2728 1
      if (ascii_strncasematch (buf, "UNC\\", 4))
@


1.493
log
@	* cygwin.din: Sort.
	(faccessat): Export.
	(fchmodat): Export.
	(fchownat): Export.
	(fstatat): Export.
	(futimesat): Export.
	(linkat): Export.
	(mkdirat): Export.
	(mkfifoat): Export.
	(mknodat): Export.
	(openat): Export.
	(readlinkat): Export.
	(renameat): Export.
	(symlinkat): Export.
	(unlinkat): Export.
	* path.cc (readlink): Align definition to POSIX.
	* syscalls.cc (gen_full_path_at): New static function.
	(faccessat): Implement.
	(fchmodat): Implement.
	(fchownat): Implement.
	(fstatat): Implement.
	(futimesat): Implement.
	(linkat): Implement.
	(mkdirat): Implement.
	(mkfifoat): Implement.
	(mknodat): Implement.
	(openat): Implement.
	(readlinkat): Implement.
	(renameat): Implement.
	(symlinkat): Implement.
	(unlinkat): Implement.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d2313 4
a2316 1
	      FILE_DIRECTORY_INFORMATION fdi;
d2334 1
a2334 1
						 &fdi, sizeof fdi,
d2338 1
a2338 10
		  /* Per MSDN, ZwQueryDirectoryFile allows to specify a buffer
		     which only fits the static parts of the structure (without
		     filename that is) in the first call.  The buffer actually
		     contains valid data, even though ZwQueryDirectoryFile
		     returned STATUS_BUFFER_OVERFLOW.

		     Please note that this doesn't work for the info class
		     FileIdBothDirectoryInformation, unfortunately, so we don't
		     use this technique in fhandler_base::fstat_by_name, */
		  if (!NT_SUCCESS (status) && status != STATUS_BUFFER_OVERFLOW)
d2345 1
a2345 1
		    fileattr = fdi.FileAttributes;
@


1.492
log
@	* fhandler_disk_file.cc (fhandler_disk_file::readdir_helper): Fix
	thinko in UNC path handling.
	* path.cc (symlink_worker): Fix typo in comment.  Fix UNC path handling.
@
text
@d2522 2
a2523 2
extern "C" int
readlink (const char *path, char *buf, int buflen)
d2553 1
a2553 1
  int len = min (buflen, (int) strlen (pathbuf.get_win32 ()));
@


1.491
log
@	* fhandler_disk_file.cc (fhandler_disk_file::readdir_helper): Simplify
	code which checks for symlinks.  Fix problem with UNC paths.

	* environ.cc (struct parse_thing): Remove transparent_exe option.
	* syscalls.cc (transparent_exe): Remove.
	(unlink): Always add stat_suffixes, drop transparent_exe check.
	(open): Ditto.
	(link): Ditto.
	(pathconf): Ditto.
	* fhandler_disk_file.cc (fhandler_disk_file::link): Ditto.
	* fhandler_process.cc (fhandler_process::fill_filebuf): Always remove
	.exe suffix.
	* path.cc (realpath): Never attach known_suffix.
@
text
@d1645 1
a1645 1
		 the prefix and convert tyhe path to the "normal" syntax
d1649 1
a1649 1
	      if (!wcscmp (wc, L"UNC\\"))
@


1.490
log
@Add miscfuncs.h to files as needed throughout.
* mount.cc: New file.
* path.cc: Move mount-specific stuff into mount.cc.  Move common stuff into
miscfuncs.cc.  Remove unneeded includes.
* miscfuncs.cc: Move some common path functions here.
* miscfuncs.h: New file.
* winsup.h: Move miscelleneous functions to miscfuncs.h.
* dcrt0.cc: Remove unneeded includes.
* Makefile.in (DLL_OFILES): Add mount.o.
* include/cygwin/config.h: Fix a minor typo.
@
text
@a2874 9
      /* Check for the suffix being tacked on. */
      int tack_on = 0;
      if (!transparent_exe && real_path.known_suffix)
	{
	  char *c = strrchr (real_path.normalized_path, '.');
	  if (!c || !ascii_strcasematch (c, real_path.known_suffix))
	    tack_on = strlen (real_path.known_suffix);
	}

d2877 1
a2877 2
	  resolved = (char *) malloc (strlen (real_path.normalized_path)
				      + tack_on + 1);
a2881 2
      if (tack_on)
	strcat (resolved, real_path.known_suffix);
@


1.489
log
@	* path.cc (struct opt): Rename "system" to "nouser".
	* postinsatll: Ditto.
@
text
@d52 1
a52 6
#include <stdio.h>
#include <stdlib.h>
#include <sys/mount.h>
#include <mntent.h>
#include <unistd.h>
#include <libgen.h>
a56 1
#include <winnls.h>
a59 1
#include <cygwin/version.h>
a63 3
#include "sync.h"
#include "sigproc.h"
#include "pinfo.h"
a66 1
#include "registry.h"
a72 1
#include <wctype.h>
a74 3
static int normalize_win32_path (const char *, char *, char *&);
static void slashify (const char *, char *, int);
static void backslashify (const char *, char *, int);
a138 12
/* Determine if path prefix matches current cygdrive */
#define iscygdrive(path) \
  (path_prefix_p (mount_table->cygdrive, (path), mount_table->cygdrive_len))

#define iscygdrive_device(path) \
  (isalpha (path[mount_table->cygdrive_len]) && \
   (path[mount_table->cygdrive_len + 1] == '/' || \
    !path[mount_table->cygdrive_len + 1]))

#define isproc(path) \
  (path_prefix_p (proc, (path), proc_len))

a215 2
#define isslash(c) ((c) == '/')

d220 1
a220 1
static int
d614 1
a614 1
static PUNICODE_STRING
a1337 27
/* Return true if src_path is a valid, internally supported device name.
   In that case, win32_path gets the corresponding NT device name and
   dev is appropriately filled with device information. */

static bool
win32_device_name (const char *src_path, char *win32_path, device& dev)
{
  dev.parse (src_path);
  if (dev == FH_FS || dev == FH_DEV)
    return false;
  strcpy (win32_path, dev.native);
  return true;
}

/* is_unc_share: Return non-zero if PATH begins with //UNC/SHARE */

static bool __stdcall
is_unc_share (const char *path)
{
  const char *p;
  return (isdirsep (path[0])
	 && isdirsep (path[1])
	 && (isalnum (path[2]) || path[2] == '.')
	 && ((p = strpbrk (path + 3, "\\/")) != NULL)
	 && isalnum (p[1]));
}

d1344 1
a1344 1
static int
a1449 48
/* slashify: Convert all back slashes in src path to forward slashes
   in dst path.  Add a trailing slash to dst when trailing_slash_p arg
   is set to 1. */

static void
slashify (const char *src, char *dst, int trailing_slash_p)
{
  const char *start = src;

  while (*src)
    {
      if (*src == '\\')
	*dst++ = '/';
      else
	*dst++ = *src;
      ++src;
    }
  if (trailing_slash_p
      && src > start
      && !isdirsep (src[-1]))
    *dst++ = '/';
  *dst++ = 0;
}

/* backslashify: Convert all forward slashes in src path to back slashes
   in dst path.  Add a trailing slash to dst when trailing_slash_p arg
   is set to 1. */

static void
backslashify (const char *src, char *dst, int trailing_slash_p)
{
  const char *start = src;

  while (*src)
    {
      if (*src == '/')
	*dst++ = '\\';
      else
	*dst++ = *src;
      ++src;
    }
  if (trailing_slash_p
      && src > start
      && !isdirsep (src[-1]))
    *dst++ = '\\';
  *dst++ = 0;
}

d1530 1
a1530 1
/* init: Initialize the mount table.  */
d1532 1
a1532 4
void
mount_info::init ()
{
  nmounts = 0;
d1534 3
a1536 2
  if (from_fstab (false) | from_fstab (true))	/* The single | is correct! */
    return;
d1538 2
a1539 10
  /* FIXME: Remove fetching from registry before releasing 1.7.0. */

  /* Fetch the mount table and cygdrive-related information from
     the registry.  */
  system_printf ("Fallback to fetching mounts from registry");
  from_registry ();
}

static void
set_flags (unsigned *flags, unsigned val)
d1541 1
a1541 11
  *flags = val;
  if (!(*flags & PATH_BINARY))
    {
      *flags |= PATH_TEXT;
      debug_printf ("flags: text (%p)", *flags & (PATH_TEXT | PATH_BINARY));
    }
  else
    {
      *flags |= PATH_BINARY;
      debug_printf ("flags: binary (%p)", *flags & (PATH_TEXT | PATH_BINARY));
    }
d1544 3
a1546 17
static char dot_special_chars[] =
    "."
    "\001" "\002" "\003" "\004" "\005" "\006" "\007" "\010"
    "\011" "\012" "\013" "\014" "\015" "\016" "\017" "\020"
    "\021" "\022" "\023" "\024" "\025" "\026" "\027" "\030"
    "\031" "\032" "\033" "\034" "\035" "\036" "\037" ":"
    "\\"   "*"    "?"    "%"     "\""   "<"    ">"    "|"
    "A"    "B"    "C"    "D"    "E"    "F"    "G"    "H"
    "I"    "J"    "K"    "L"    "M"    "N"    "O"    "P"
    "Q"    "R"    "S"    "T"    "U"    "V"    "W"    "X"
    "Y"    "Z";
static char *special_chars = dot_special_chars + 1;
static char special_introducers[] =
    "anpcl";

static char
special_char (const char *s, const char *valid_chars = special_chars)
d1548 12
a1559 2
  if (*s != '%' || strlen (s) < 3)
    return 0;
d1561 7
a1567 45
  char *p;
  char hex[] = {s[1], s[2], '\0'};
  unsigned char c = strtoul (hex, &p, 16);
  p = strechr (valid_chars, c);
  return *p;
}

/* Determines if name is "special".  Assumes that name is empty or "absolute" */
static int
special_name (const char *s, int inc = 1)
{
  if (!*s)
    return false;

  s += inc;

  if (strcmp (s, ".") == 0 || strcmp (s, "..") == 0)
    return false;

  int n;
  const char *p = NULL;
  if (ascii_strncasematch (s, "conin$", n = 5)
      || ascii_strncasematch (s, "conout$", n = 7)
      || ascii_strncasematch (s, "nul", n = 3)
      || ascii_strncasematch (s, "aux", 3)
      || ascii_strncasematch (s, "prn", 3)
      || ascii_strncasematch (s, "con", 3))
    p = s + n;
  else if (ascii_strncasematch (s, "com", 3)
	   || ascii_strncasematch (s, "lpt", 3))
    strtoul (s + 3, (char **) &p, 10);
  if (p && (*p == '\0' || *p == '.'))
    return -1;

  return (strchr (s, '\0')[-1] == '.')
	 || (strpbrk (s, special_chars) && !ascii_strncasematch (s, "%2f", 3));
}

bool
fnunmunge (char *dst, const char *src)
{
  bool converted = false;
  char c;

  if ((c = special_char (src, special_introducers)))
d1569 2
a1570 6
      __small_sprintf (dst, "%c%s", c, src + 3);
      if (special_name (dst, 0))
	{
	  *dst++ = c;
	  src += 3;
	}
d1573 1
a1573 43
  while (*src)
    if (!(c = special_char (src, dot_special_chars)))
      *dst++ = *src++;
    else
      {
	converted = true;
	*dst++ = c;
	src += 3;
      }

  *dst = *src;
  return converted;
}

static bool
copy1 (char *&d, const char *&src, int& left)
{
  left--;
  if (left || !*src)
    *d++ = *src++;
  else
    return true;
  return false;
}

static bool
copyenc (char *&d, const char *&src, int& left)
{
  char buf[16];
  int n = __small_sprintf (buf, "%%%02x", (unsigned char) *src++);
  left -= n;
  if (left <= 0)
    return true;
  strcpy (d, buf);
  d += n;
  return false;
}

int
mount_item::fnmunge (char *dst, const char *src, int& left)
{
  int name_type;
  if (!(name_type = special_name (src)))
d1575 2
a1576 4
      if ((int) strlen (src) >= left)
	return ENAMETOOLONG;
      else
	strcpy (dst, src);
a1577 7
  else
    {
      char *d = dst;
      if (copy1 (d, src, left))
	  return ENAMETOOLONG;
      if (name_type < 0 && copyenc (d, src, left))
	return ENAMETOOLONG;
d1579 3
a1581 37
      while (*src)
	if (!strchr (special_chars, *src) || (*src == '%' && !special_char (src)))
	  {
	    if (copy1 (d, src, left))
	      return ENAMETOOLONG;
	  }
	else if (copyenc (d, src, left))
	  return ENAMETOOLONG;

      char dot[] = ".";
      const char *p = dot;
      if (*--d != '.')
	d++;
      else if (copyenc (d, p, left))
	return ENAMETOOLONG;

      *d = *src;
    }

  backslashify (dst, dst, 0);
  return 0;
}

int
mount_item::build_win32 (char *dst, const char *src, unsigned *outflags, unsigned chroot_pathlen)
{
  int n, err = 0;
  const char *real_native_path;
  int real_posix_pathlen;
  set_flags (outflags, (unsigned) flags);
  if (!cygheap->root.exists () || posix_pathlen != 1 || posix_path[0] != '/')
    {
      n = native_pathlen;
      real_native_path = native_path;
      real_posix_pathlen = chroot_pathlen ?: posix_pathlen;
    }
  else
d1583 2
a1584 17
      n = cygheap->root.native_length ();
      real_native_path = cygheap->root.native_path ();
      real_posix_pathlen = posix_pathlen;
    }
  memcpy (dst, real_native_path, n + 1);
  const char *p = src + real_posix_pathlen;
  if (*p == '/')
    /* nothing */;
  else if ((!(flags & MOUNT_ENC) && isdrive (dst) && !dst[2]) || *p)
    dst[n++] = '\\';
  //if (!*p || !(flags & MOUNT_ENC))
    //{
      if ((n + strlen (p)) >= NT_MAX_PATH)
	err = ENAMETOOLONG;
      else
	backslashify (p, dst + n, 0);
#if 0
d1586 3
a1588 1
  else
d1590 3
a1592 17
      int left = NT_MAX_PATH - n;
      while (*p)
	{
	  char slash = 0;
	  char *s = strchr (p + 1, '/');
	  if (s)
	    {
	      slash = *s;
	      *s = '\0';
	    }
	  err = fnmunge (dst += n, p, left);
	  if (!s || err)
	    break;
	  n = strlen (dst);
	  *s = slash;
	  p = s;
	}
a1593 3
#endif
  return err;
}
d1595 1
a1595 19
/* conv_to_win32_path: Ensure src_path is a pure Win32 path and store
   the result in win32_path.

   If win32_path != NULL, the relative path, if possible to keep, is
   stored in win32_path.  If the relative path isn't possible to keep,
   the full path is stored.

   If full_win32_path != NULL, the full path is stored there.

   The result is zero for success, or an errno value.

   {,full_}win32_path must have sufficient space (i.e. NT_MAX_PATH bytes).  */

int
mount_info::conv_to_win32_path (const char *src_path, char *dst, device& dev,
				unsigned *flags)
{
  bool chroot_ok = !cygheap->root.exists ();
  while (sys_mount_table_counter < cygwin_shared->sys_mount_table_counter)
d1597 2
a1598 3
      int current = cygwin_shared->sys_mount_table_counter;
      init ();
      sys_mount_table_counter = current;
a1599 1
  MALLOC_CHECK;
d1601 2
a1602 1
  dev.devn = FH_FS;
d1604 2
a1605 23
  *flags = 0;
  debug_printf ("conv_to_win32_path (%s)", src_path);

  int i, rc;
  mount_item *mi = NULL;	/* initialized to avoid compiler warning */

  /* The path is already normalized, without ../../ stuff, we need to have this
     so that we can move from one mounted directory to another with relative
     stuff.

     eg mounting c:/foo /foo
     d:/bar /bar

     cd /bar
     ls ../foo

     should look in c:/foo, not d:/foo.

     converting normalizex UNIX path to a DOS-style path, looking up the
     appropriate drive in the mount table.  */

  /* See if this is a cygwin "device" */
  if (win32_device_name (src_path, dst, dev))
d1607 2
a1608 3
      *flags = MOUNT_BINARY;	/* FIXME: Is this a sensible default for devices? */
      rc = 0;
      goto out_no_chroot_check;
d1611 1
a1611 5
  MALLOC_CHECK;
  /* If the path is on a network drive or a //./ resp.//?/ path prefix,
     bypass the mount table.  If it's // or //MACHINE, use the netdrive
     device. */
  if (src_path[1] == '/')
d1613 4
a1616 25
      if (!strchr (src_path + 2, '/'))
	{
	  dev = *netdrive_dev;
	  set_flags (flags, PATH_BINARY);
	}
      backslashify (src_path, dst, 0);
      /* Go through chroot check */
      goto out;
    }
  if (isproc (src_path))
    {
      dev = *proc_dev;
      dev.devn = fhandler_proc::get_proc_fhandler (src_path);
      if (dev.devn == FH_BAD)
	return ENOENT;
      set_flags (flags, PATH_BINARY);
      strcpy (dst, src_path);
      goto out;
    }
  /* Check if the cygdrive prefix was specified.  If so, just strip
     off the prefix and transform it into an MS-DOS path. */
  else if (iscygdrive (src_path))
    {
      int n = mount_table->cygdrive_len - 1;
      int unit;
d1618 1
a1618 1
      if (!src_path[n])
d1620 3
a1622 13
	  unit = 0;
	  dst[0] = '\0';
	  if (mount_table->cygdrive_len > 1)
	    dev = *cygdrive_dev;
	}
      else if (cygdrive_win32_path (src_path, dst, unit))
	{
	  set_flags (flags, (unsigned) cygdrive_flags);
	  goto out;
	}
      else if (mount_table->cygdrive_len > 1)
	return ENOENT;
    }
d1624 32
a1655 7
  int chroot_pathlen;
  chroot_pathlen = 0;
  /* Check the mount table for prefix matches. */
  for (i = 0; i < nmounts; i++)
    {
      const char *path;
      int len;
d1657 7
a1663 6
      mi = mount + posix_sorted[i];
      if (!cygheap->root.exists ()
	  || (mi->posix_pathlen == 1 && mi->posix_path[0] == '/'))
	{
	  path = mi->posix_path;
	  len = mi->posix_pathlen;
d1665 6
a1670 1314
      else if (cygheap->root.posix_ok (mi->posix_path))
	{
	  path = cygheap->root.unchroot (mi->posix_path);
	  chroot_pathlen = len = strlen (path);
	}
      else
	{
	  chroot_pathlen = 0;
	  continue;
	}

      if (path_prefix_p (path, src_path, len))
	break;
    }

  if (i < nmounts)
    {
      int err = mi->build_win32 (dst, src_path, flags, chroot_pathlen);
      if (err)
	return err;
      chroot_ok = true;
    }
  else
    {
      int offset = 0;
      if (src_path[1] != '/' && src_path[1] != ':')
	offset = cygheap->cwd.get_drive (dst);
      backslashify (src_path, dst + offset, 0);
    }
 out:
  MALLOC_CHECK;
  if (chroot_ok || cygheap->root.ischroot_native (dst))
    rc = 0;
  else
    {
      debug_printf ("attempt to access outside of chroot '%s - %s'",
		    cygheap->root.posix_path (), cygheap->root.native_path ());
      rc = ENOENT;
    }

 out_no_chroot_check:
  debug_printf ("src_path %s, dst %s, flags %p, rc %d", src_path, dst, *flags, rc);
  return rc;
}

int
mount_info::get_mounts_here (const char *parent_dir, int parent_dir_len,
			     PUNICODE_STRING mount_points,
			     PUNICODE_STRING cygd)
{
  int n_mounts = 0;

  for (int i = 0; i < nmounts; i++)
    {
      mount_item *mi = mount + posix_sorted[i];
      char *last_slash = strrchr (mi->posix_path, '/');
      if (!last_slash)
	continue;
      if (last_slash == mi->posix_path)
	{
	  if (parent_dir_len == 1 && mi->posix_pathlen > 1)
	    RtlCreateUnicodeStringFromAsciiz (&mount_points[n_mounts++],
					      last_slash + 1);
	}
      else if (parent_dir_len == last_slash - mi->posix_path
	       && strncasematch (parent_dir, mi->posix_path, parent_dir_len))
	RtlCreateUnicodeStringFromAsciiz (&mount_points[n_mounts++],
					  last_slash + 1);
    }
  RtlCreateUnicodeStringFromAsciiz (cygd, cygdrive + 1);
  cygd->Length -= 2;	// Strip trailing slash
  return n_mounts;
}

/* cygdrive_posix_path: Build POSIX path used as the
   mount point for cygdrives created when there is no other way to
   obtain a POSIX path from a Win32 one. */

void
mount_info::cygdrive_posix_path (const char *src, char *dst, int trailing_slash_p)
{
  int len = cygdrive_len;

  memcpy (dst, cygdrive, len + 1);

  /* Now finish the path off with the drive letter to be used.
     The cygdrive prefix always ends with a trailing slash so
     the drive letter is added after the path. */
  dst[len++] = cyg_tolower (src[0]);
  if (!src[2] || (isdirsep (src[2]) && !src[3]))
    dst[len++] = '\000';
  else
    {
      int n;
      dst[len++] = '/';
      if (isdirsep (src[2]))
	n = 3;
      else
	n = 2;
      strcpy (dst + len, src + n);
    }
  slashify (dst, dst, trailing_slash_p);
}

int
mount_info::cygdrive_win32_path (const char *src, char *dst, int& unit)
{
  int res;
  const char *p = src + cygdrive_len;
  if (!isalpha (*p) || (!isdirsep (p[1]) && p[1]))
    {
      unit = -1; /* FIXME: should be zero, maybe? */
      dst[0] = '\0';
      res = 0;
    }
  else
    {
      dst[0] = cyg_tolower (*p);
      dst[1] = ':';
      strcpy (dst + 2, p + 1);
      backslashify (dst, dst, !dst[2]);
      unit = dst[0];
      res = 1;
    }
  debug_printf ("src '%s', dst '%s'", src, dst);
  return res;
}

/* conv_to_posix_path: Ensure src_path is a POSIX path.

   The result is zero for success, or an errno value.
   posix_path must have sufficient space (i.e. NT_MAX_PATH bytes).
   If keep_rel_p is non-zero, relative paths stay that way.  */

/* TODO: Change conv_to_posix_path to work with native paths. */

/* src_path is a wide Win32 path. */
int
mount_info::conv_to_posix_path (PWCHAR src_path, char *posix_path,
				int keep_rel_p)
{
  bool changed = false;
  if (!wcsncmp (src_path, L"\\\\?\\", 4))
    {
      src_path += 4;
      if (!wcsncmp (src_path, L"UNC\\", 4))
	{
	  src_path += 2;
	  src_path[0] = L'\\';
	  changed = true;
	}
    }
  tmp_pathbuf tp;
  char *buf = tp.c_get ();
  sys_wcstombs (buf, NT_MAX_PATH, src_path);
  int ret = conv_to_posix_path (buf, posix_path, keep_rel_p);
  if (changed)
    src_path[0] = L'C';
  return ret;
}

int
mount_info::conv_to_posix_path (const char *src_path, char *posix_path,
				int keep_rel_p)
{
  int src_path_len = strlen (src_path);
  int relative_path_p = !isabspath (src_path);
  int trailing_slash_p;

  if (src_path_len <= 1)
    trailing_slash_p = 0;
  else
    {
      const char *lastchar = src_path + src_path_len - 1;
      trailing_slash_p = isdirsep (*lastchar) && lastchar[-1] != ':';
    }

  debug_printf ("conv_to_posix_path (%s, %s, %s)", src_path,
		keep_rel_p ? "keep-rel" : "no-keep-rel",
		trailing_slash_p ? "add-slash" : "no-add-slash");
  MALLOC_CHECK;

  if (src_path_len >= NT_MAX_PATH)
    {
      debug_printf ("ENAMETOOLONG");
      return ENAMETOOLONG;
    }

  /* FIXME: For now, if the path is relative and it's supposed to stay
     that way, skip mount table processing. */

  if (keep_rel_p && relative_path_p)
    {
      slashify (src_path, posix_path, 0);
      debug_printf ("%s = conv_to_posix_path (%s)", posix_path, src_path);
      return 0;
    }

  tmp_pathbuf tp;
  char *pathbuf = tp.c_get ();
  char *tail;
  int rc = normalize_win32_path (src_path, pathbuf, tail);
  if (rc != 0)
    {
      debug_printf ("%d = conv_to_posix_path (%s)", rc, src_path);
      return rc;
    }

  int pathbuflen = tail - pathbuf;
  for (int i = 0; i < nmounts; ++i)
    {
      mount_item &mi = mount[native_sorted[i]];
      if (!path_prefix_p (mi.native_path, pathbuf, mi.native_pathlen))
	continue;

      if (cygheap->root.exists () && !cygheap->root.posix_ok (mi.posix_path))
	continue;

      /* SRC_PATH is in the mount table. */
      int nextchar;
      const char *p = pathbuf + mi.native_pathlen;

      if (!*p || !p[1])
	nextchar = 0;
      else if (isdirsep (*p))
	nextchar = -1;
      else
	nextchar = 1;

      int addslash = nextchar > 0 ? 1 : 0;
      if ((mi.posix_pathlen + (pathbuflen - mi.native_pathlen) + addslash) >= NT_MAX_PATH)
	return ENAMETOOLONG;
      strcpy (posix_path, mi.posix_path);
      if (addslash)
	strcat (posix_path, "/");
      if (nextchar)
	slashify (p,
		  posix_path + addslash + (mi.posix_pathlen == 1 ? 0 : mi.posix_pathlen),
		  trailing_slash_p);

      if (cygheap->root.exists ())
	{
	  const char *p = cygheap->root.unchroot (posix_path);
	  memmove (posix_path, p, strlen (p) + 1);
	}
#if 0
      if (mi.flags & MOUNT_ENC)
	{
	  char *tmpbuf = tp.c_get ();
	  if (fnunmunge (tmpbuf, posix_path))
	    strcpy (posix_path, tmpbuf);
	}
#endif
      goto out;
    }

  if (!cygheap->root.exists ())
    /* nothing */;
  else if (!cygheap->root.ischroot_native (pathbuf))
    return ENOENT;
  else
    {
      const char *p = pathbuf + cygheap->root.native_length ();
      if (*p)
	slashify (p, posix_path, trailing_slash_p);
      else
	{
	  posix_path[0] = '/';
	  posix_path[1] = '\0';
	}
      goto out;
    }

  /* Not in the database.  This should [theoretically] only happen if either
     the path begins with //, or / isn't mounted, or the path has a drive
     letter not covered by the mount table.  If it's a relative path then the
     caller must want an absolute path (otherwise we would have returned
     above).  So we always return an absolute path at this point. */
  if (isdrive (pathbuf))
    cygdrive_posix_path (pathbuf, posix_path, trailing_slash_p);
  else
    {
      /* The use of src_path and not pathbuf here is intentional.
	 We couldn't translate the path, so just ensure no \'s are present. */
      slashify (src_path, posix_path, trailing_slash_p);
    }

out:
  debug_printf ("%s = conv_to_posix_path (%s)", posix_path, src_path);
  MALLOC_CHECK;
  return 0;
}

/* Return flags associated with a mount point given the win32 path. */

unsigned
mount_info::set_flags_from_win32_path (const char *p)
{
  for (int i = 0; i < nmounts; i++)
    {
      mount_item &mi = mount[native_sorted[i]];
      if (path_prefix_p (mi.native_path, p, mi.native_pathlen))
	return mi.flags;
    }
  return PATH_BINARY;
}

inline char *
skip_ws (char *in)
{
  while (*in == ' ' || *in == '\t')
    ++in;
  return in;
}

inline char *
find_ws (char *in)
{
  while (*in && *in != ' ' && *in != '\t')
    ++in;
  return in;
}

inline char *
conv_fstab_spaces (char *field)
{
  register char *sp = field;
  while (sp = strstr (sp, "\\040"))
    {
      *sp++ = ' ';
      memmove (sp, sp + 3, strlen (sp + 3) + 1);
    }
  return field;
}

struct opt
{   
  const char *name;
  unsigned val;
  bool clear;
} oopts[] =
{
  {"user", MOUNT_SYSTEM, 1},
  {"nouser", MOUNT_SYSTEM, 0},
  {"binary", MOUNT_BINARY, 0},
  {"text", MOUNT_BINARY, 1},
  {"exec", MOUNT_EXEC, 0},
  {"notexec", MOUNT_NOTEXEC, 0},
  {"cygexec", MOUNT_CYGWIN_EXEC, 0},
  {"nosuid", 0, 0},
  {"managed", MOUNT_ENC, 0}
};

static bool
read_flags (char *options, unsigned &flags)
{
  while (*options)
    {
      char *p = strchr (options, ',');
      if (p)
        *p++ = '\0';
      else
        p = strchr (options, '\0');

      for (opt *o = oopts;
	   o < (oopts + (sizeof (oopts) / sizeof (oopts[0])));
	   o++)
        if (strcmp (options, o->name) == 0)
          {
            if (o->clear)
              flags &= ~o->val;
            else
              flags |= o->val;
            goto gotit;
          }
      system_printf ("invalid fstab option - '%s'", options);
      return false;

    gotit:
      options = p;
    }
  return true;
}

bool
mount_info::from_fstab_line (char *line, bool user)
{
  char *native_path, *posix_path, *fs_type;

  /* First field: Native path. */
  char *c = skip_ws (line);
  if (!*c || *c == '#')
    return true;
  char *cend = find_ws (c);
  *cend = '\0';
  native_path = conv_fstab_spaces (c);
  /* Second field: POSIX path. */
  c = skip_ws (cend + 1);
  if (!*c)
    return true;
  cend = find_ws (c);
  *cend = '\0';
  posix_path = conv_fstab_spaces (c);
  /* Third field: FS type. */
  c = skip_ws (cend + 1);
  if (!*c)
    return true;
  cend = find_ws (c);
  *cend = '\0';
  fs_type = c;
  /* Forth field: Flags. */
  c = skip_ws (cend + 1);
  if (!*c)
    return true;
  cend = find_ws (c);
  *cend = '\0';
  unsigned mount_flags = MOUNT_SYSTEM;
  if (!read_flags (c, mount_flags))
    return true;
  if (user)
    mount_flags &= ~MOUNT_SYSTEM;
  if (!strcmp (fs_type, "cygdrive"))
    {
      cygdrive_flags = mount_flags | MOUNT_CYGDRIVE;
      slashify (posix_path, cygdrive, 1);
      cygdrive_len = strlen (cygdrive);
    }
  else
    {
      int res = mount_table->add_item (native_path, posix_path, mount_flags);
      if (res && get_errno () == EMFILE)
	return false;
    }
  return true;
}

bool
mount_info::from_fstab (bool user)
{
  tmp_pathbuf tp;
  PWCHAR path = tp.w_get ();
  PWCHAR w;
  
  if (!GetModuleFileNameW (GetModuleHandleW (L"cygwin1.dll"),
			   path, NT_MAX_PATH))
    {
      debug_printf ("GetModuleFileNameW, %E");
      return false;
    }
  w = wcsrchr (path, L'\\');
  if (w)
    {
      *w = L'\0';
      w = wcsrchr (path, L'\\');
    }
  if (!w)
    {
      debug_printf ("Invalid DLL path");
      return false;
    }

  if (!user)
    {
      /* Create a default root dir from the path the Cygwin DLL is in. */
      *w = L'\0';
      char *native_root = tp.c_get ();
      sys_wcstombs (native_root, NT_MAX_PATH, path);
      mount_table->add_item (native_root, "/", MOUNT_SYSTEM | MOUNT_BINARY);
      /* Create a default cygdrive entry.  Note that this is a user entry.
         This allows to override it with mount, unless the sysadmin created
	 a cygdrive entry in /etc/fstab. */
      cygdrive_flags = MOUNT_BINARY | MOUNT_CYGDRIVE;
      strcpy (cygdrive, "/cygdrive/");
      cygdrive_len = strlen (cygdrive);
    }

  PWCHAR u = wcpcpy (w, L"\\etc\\fstab");
  if (user)
    sys_mbstowcs (wcpcpy (u, L"."), NT_MAX_PATH - (u - path),
		  cygheap->user.name ());
  debug_printf ("Try to read mounts from %W", path);
  HANDLE h = CreateFileW (path, GENERIC_READ, FILE_SHARE_READ, &sec_none_nih,
			  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
  if (h == INVALID_HANDLE_VALUE)
    {
      debug_printf ("CreateFileW, %E");
      return false;
    }
  char *const buf = reinterpret_cast<char *const> (path);
  char *got = buf;
  DWORD len = 0;
  /* Using NT_MAX_PATH-1 leaves space to append two \0. */
  while (ReadFile (h, got, (NT_MAX_PATH - 1) * sizeof (WCHAR) - (got - buf),
		   &len, NULL))
    {
      char *end;

      /* Set end marker. */
      got[len] = got[len + 1] = '\0';
      /* Set len to the absolute len of bytes in buf. */
      len += got - buf;
      /* Reset got to start reading at the start of the buffer again. */
      got = buf;
      while (got < buf + len && (end = strchr (got, '\n')))
        {
	  end[end[-1] == '\r' ? -1 : 0] = '\0';
	  if (!from_fstab_line (got, user))
	    goto done;
	  got = end + 1;
	}
      if (len < (NT_MAX_PATH - 1) * sizeof (WCHAR))
        break;
      /* We have to read once more.  Move remaining bytes to the start of
         the buffer and reposition got so that it points to the end of
	 the remaining bytes. */
      len = buf + len - got;
      memmove (buf, got, len);
      got = buf + len;
      buf[len] = buf[len + 1] = '\0';
    }
  if (got > buf)
    from_fstab_line (got, user);
done:
  CloseHandle (h);
  return true;
}

/* read_mounts: Given a specific regkey, read mounts from under its
   key. */
/* FIXME: Remove before releasing 1.7.0. */

void
mount_info::read_mounts (reg_key& r)
{
  tmp_pathbuf tp;
  char *native_path = tp.c_get ();
  /* FIXME: The POSIX path is stored as value name right now, which is
     restricted to 256 bytes. */
  char posix_path[CYG_MAX_PATH];
  HKEY key = r.get_key ();
  DWORD i, posix_path_size;
  int res;

  /* Loop through subkeys */
  /* FIXME: we would like to not check MAX_MOUNTS but the heap in the
     shared area is currently statically allocated so we can't have an
     arbitrarily large number of mounts. */
  for (i = 0; ; i++)
    {
      int mount_flags;

      posix_path_size = sizeof (posix_path);
      /* FIXME: if maximum posix_path_size is 256, we're going to
	 run into problems if we ever try to store a mount point that's
	 over 256 but is under CYG_MAX_PATH. */
      res = RegEnumKeyEx (key, i, posix_path, &posix_path_size, NULL,
			  NULL, NULL, NULL);

      if (res == ERROR_NO_MORE_ITEMS)
	break;
      else if (res != ERROR_SUCCESS)
	{
	  debug_printf ("RegEnumKeyEx failed, error %d!", res);
	  break;
	}

      /* Get a reg_key based on i. */
      reg_key subkey = reg_key (key, KEY_READ, posix_path, NULL);

      /* Fetch info from the subkey. */
      subkey.get_string ("native", native_path, NT_MAX_PATH, "");
      mount_flags = subkey.get_int ("flags", 0);

      /* Add mount_item corresponding to registry mount point. */
      res = mount_table->add_item (native_path, posix_path, mount_flags);
      if (res && get_errno () == EMFILE)
	break; /* The number of entries exceeds MAX_MOUNTS */
    }
}

/* from_registry: Build the entire mount table from the registry.  Also,
   read in cygdrive-related information from its registry location. */
/* FIXME: Remove before releasing 1.7.0. */

void
mount_info::from_registry ()
{

  /* Retrieve cygdrive-related information. */
  read_cygdrive_info_from_registry ();

  nmounts = 0;

  /* First read mounts from user's table.
     Then read mounts from system-wide mount table while deimpersonated . */
  for (int i = 0; i < 2; i++)
    {
      if (i)
	cygheap->user.deimpersonate ();
      reg_key r (i, KEY_READ, CYGWIN_INFO_CYGWIN_MOUNT_REGISTRY_NAME, NULL);
      read_mounts (r);
      if (i)
	cygheap->user.reimpersonate ();
    }
}

/* read_cygdrive_info_from_registry: Read the default prefix and flags
   to use when creating cygdrives from the special user registry
   location used to store cygdrive information. */
/* FIXME: Remove before releasing 1.7.0. */

void
mount_info::read_cygdrive_info_from_registry ()
{
  /* First read cygdrive from user's registry.
     If failed, then read cygdrive from system-wide registry
     while deimpersonated. */
  for (int i = 0; i < 2; i++)
    {
      if (i)
	cygheap->user.deimpersonate ();
      reg_key r (i, KEY_READ, CYGWIN_INFO_CYGWIN_MOUNT_REGISTRY_NAME, NULL);
      if (i)
	cygheap->user.reimpersonate ();

      if (r.get_string (CYGWIN_INFO_CYGDRIVE_PREFIX, cygdrive, sizeof (cygdrive),
			CYGWIN_INFO_CYGDRIVE_DEFAULT_PREFIX) != ERROR_SUCCESS && i == 0)
	continue;

      /* Fetch user cygdrive_flags from registry; returns MOUNT_CYGDRIVE on error. */
      cygdrive_flags = r.get_int (CYGWIN_INFO_CYGDRIVE_FLAGS,
				  MOUNT_CYGDRIVE | MOUNT_BINARY);
      /* Sanitize */
      if (i == 0)
	cygdrive_flags &= ~MOUNT_SYSTEM;
      else
	cygdrive_flags |= MOUNT_SYSTEM;
      slashify (cygdrive, cygdrive, 1);
      cygdrive_len = strlen (cygdrive);
      break;
    }
}

/* write_cygdrive_info: Store default prefix and flags
   to use when creating cygdrives to the special user shared mem
   location used to store cygdrive information. */

int
mount_info::write_cygdrive_info (const char *cygdrive_prefix, unsigned flags)
{
  /* Verify cygdrive prefix starts with a forward slash and if there's
     another character, it's not a slash. */
  if ((cygdrive_prefix == NULL) || (*cygdrive_prefix == 0) ||
      (!isslash (cygdrive_prefix[0])) ||
      ((cygdrive_prefix[1] != '\0') && (isslash (cygdrive_prefix[1]))))
    {
      set_errno (EINVAL);
      return -1;
    }
  /* Don't allow to override a system cygdrive prefix. */
  if (cygdrive_flags & MOUNT_SYSTEM)
    {
      set_errno (EPERM);
      return -1;
    }

  slashify (cygdrive_prefix, cygdrive, 1);
  cygdrive_flags = flags & ~MOUNT_SYSTEM;
  cygdrive_len = strlen (cygdrive);

  return 0;
}

int
mount_info::get_cygdrive_info (char *user, char *system, char* user_flags,
			       char* system_flags)
{
  if (user)
    *user = '\0';
  /* Get the user flags, if appropriate */
  if (user_flags)
    *user_flags = '\0';

  if (system)
    strcpy (system, cygdrive);

  if (system_flags)
    strcpy (system_flags,
	    (cygdrive_flags & MOUNT_BINARY) ? "binmode" : "textmode");

  return 0;
}

static mount_item *mounts_for_sort;

/* sort_by_posix_name: qsort callback to sort the mount entries.  Sort
   user mounts ahead of system mounts to the same POSIX path. */
/* FIXME: should the user should be able to choose whether to
   prefer user or system mounts??? */
static int
sort_by_posix_name (const void *a, const void *b)
{
  mount_item *ap = mounts_for_sort + (*((int*) a));
  mount_item *bp = mounts_for_sort + (*((int*) b));

  /* Base weighting on longest posix path first so that the most
     obvious path will be chosen. */
  size_t alen = strlen (ap->posix_path);
  size_t blen = strlen (bp->posix_path);

  int res = blen - alen;

  if (res)
    return res;		/* Path lengths differed */

  /* The two paths were the same length, so just determine normal
     lexical sorted order. */
  res = strcmp (ap->posix_path, bp->posix_path);

  if (res == 0)
   {
     /* need to select between user and system mount to same POSIX path */
     if (!(bp->flags & MOUNT_SYSTEM))	/* user mount */
      return 1;
     else
      return -1;
   }

  return res;
}

/* sort_by_native_name: qsort callback to sort the mount entries.  Sort
   user mounts ahead of system mounts to the same POSIX path. */
/* FIXME: should the user should be able to choose whether to
   prefer user or system mounts??? */
static int
sort_by_native_name (const void *a, const void *b)
{
  mount_item *ap = mounts_for_sort + (*((int*) a));
  mount_item *bp = mounts_for_sort + (*((int*) b));

  /* Base weighting on longest win32 path first so that the most
     obvious path will be chosen. */
  size_t alen = strlen (ap->native_path);
  size_t blen = strlen (bp->native_path);

  int res = blen - alen;

  if (res)
    return res;		/* Path lengths differed */

  /* The two paths were the same length, so just determine normal
     lexical sorted order. */
  res = strcmp (ap->native_path, bp->native_path);

  if (res == 0)
   {
     /* need to select between user and system mount to same POSIX path */
     if (!(bp->flags & MOUNT_SYSTEM))	/* user mount */
      return 1;
     else
      return -1;
   }

  return res;
}

void
mount_info::sort ()
{
  for (int i = 0; i < nmounts; i++)
    native_sorted[i] = posix_sorted[i] = i;
  /* Sort them into reverse length order, otherwise we won't
     be able to look for /foo in /.  */
  mounts_for_sort = mount;	/* ouch. */
  qsort (posix_sorted, nmounts, sizeof (posix_sorted[0]), sort_by_posix_name);
  qsort (native_sorted, nmounts, sizeof (native_sorted[0]), sort_by_native_name);
}

/* Add an entry to the mount table.
   Returns 0 on success, -1 on failure and errno is set.

   This is where all argument validation is done.  It may not make sense to
   do this when called internally, but it's cleaner to keep it all here.  */

int
mount_info::add_item (const char *native, const char *posix,
		      unsigned mountflags)
{
  tmp_pathbuf tp;
  char *nativetmp = tp.c_get ();
  /* FIXME: The POSIX path is stored as value name right now, which is
     restricted to 256 bytes. */
  char posixtmp[CYG_MAX_PATH];
  char *nativetail, *posixtail, error[] = "error";
  int nativeerr, posixerr;

  /* Something's wrong if either path is NULL or empty, or if it's
     not a UNC or absolute path. */

  if (native == NULL || !isabspath (native) ||
      !(is_unc_share (native) || isdrive (native)))
    nativeerr = EINVAL;
  else
    nativeerr = normalize_win32_path (native, nativetmp, nativetail);

  if (posix == NULL || !isabspath (posix) ||
      is_unc_share (posix) || isdrive (posix))
    posixerr = EINVAL;
  else
    posixerr = normalize_posix_path (posix, posixtmp, posixtail);

  debug_printf ("%s[%s], %s[%s], %p",
		native, nativeerr ? error : nativetmp,
		posix, posixerr ? error : posixtmp, mountflags);

  if (nativeerr || posixerr)
    {
      set_errno (nativeerr?:posixerr);
      return -1;
    }

  /* Make sure both paths do not end in /. */
  if (nativetail > nativetmp + 1 && nativetail[-1] == '\\')
    nativetail[-1] = '\0';
  if (posixtail > posixtmp + 1 && posixtail[-1] == '/')
    posixtail[-1] = '\0';

  /* Write over an existing mount item with the same POSIX path if
     it exists and is from the same registry area. */
  int i;
  for (i = 0; i < nmounts; i++)
    {
      if (strcasematch (mount[i].posix_path, posixtmp))
        {
	  /* Don't allow to override a system mount with a user mount. */
	  if ((mount[i].flags & MOUNT_SYSTEM) && !(mountflags & MOUNT_SYSTEM))
	    {
	      set_errno (EPERM);
	      return -1;
	    }
	  if ((mount[i].flags & MOUNT_SYSTEM) == (mountflags & MOUNT_SYSTEM))
	    break;
	}
    }

  if (i == nmounts && nmounts == MAX_MOUNTS)
    {
      set_errno (EMFILE);
      return -1;
    }

  if (i == nmounts)
    nmounts++;
  mount[i].init (nativetmp, posixtmp, mountflags);
  sort ();

  return 0;
}

/* Delete a mount table entry where path is either a Win32 or POSIX
   path. Since the mount table is really just a table of aliases,
   deleting / is ok (although running without a slash mount is
   strongly discouraged because some programs may run erratically
   without one).  If MOUNT_SYSTEM is set in flags, remove from system
   registry, otherwise remove the user registry mount.
*/

int
mount_info::del_item (const char *path, unsigned flags)
{
  tmp_pathbuf tp;
  char *pathtmp = tp.c_get ();
  int posix_path_p = false;

  /* Something's wrong if path is NULL or empty. */
  if (path == NULL || *path == 0 || !isabspath (path))
    {
      set_errno (EINVAL);
      return -1;
    }

  if (is_unc_share (path) || strpbrk (path, ":\\"))
    backslashify (path, pathtmp, 0);
  else
    {
      slashify (path, pathtmp, 0);
      posix_path_p = true;
    }
  nofinalslash (pathtmp, pathtmp);

  for (int i = 0; i < nmounts; i++)
    {
      int ent = native_sorted[i]; /* in the same order as getmntent() */
      if (((posix_path_p)
	   ? strcasematch (mount[ent].posix_path, pathtmp)
	   : strcasematch (mount[ent].native_path, pathtmp)))
	{
	  /* Don't allow to remove a system mount. */
	  if ((mount[ent].flags & MOUNT_SYSTEM))
	    {
	      set_errno (EPERM);
	      return -1;
	    }
	  nmounts--; /* One less mount table entry */
	  /* Fill in the hole if not at the end of the table */
	  if (ent < nmounts)
	    memmove (mount + ent, mount + ent + 1,
		     sizeof (mount[ent]) * (nmounts - ent));
	  sort (); /* Resort the table */
	  return 0;
	}
    }
  set_errno (EINVAL);
  return -1;
}

/************************* mount_item class ****************************/

static mntent *
fillout_mntent (const char *native_path, const char *posix_path, unsigned flags)
{
  struct mntent& ret=_my_tls.locals.mntbuf;
  bool append_bs = false;

  /* Remove drivenum from list if we see a x: style path */
  if (strlen (native_path) == 2 && native_path[1] == ':')
    {
      int drivenum = cyg_tolower (native_path[0]) - 'a';
      if (drivenum >= 0 && drivenum <= 31)
	_my_tls.locals.available_drives &= ~(1 << drivenum);
      append_bs = true;
    }

  /* Pass back pointers to mount_table strings reserved for use by
     getmntent rather than pointers to strings in the internal mount
     table because the mount table might change, causing weird effects
     from the getmntent user's point of view. */

  strcpy (_my_tls.locals.mnt_fsname, native_path);
  ret.mnt_fsname = _my_tls.locals.mnt_fsname;
  strcpy (_my_tls.locals.mnt_dir, posix_path);
  ret.mnt_dir = _my_tls.locals.mnt_dir;

  /* Try to give a filesystem type that matches what a Linux application might
     expect. Naturally, this is a moving target, but we can make some
     reasonable guesses for popular types. */

  fs_info mntinfo;
  tmp_pathbuf tp;
  UNICODE_STRING unat;
  tp.u_get (&unat);
  get_nt_native_path (native_path, unat, flags & MOUNT_ENC);
  if (append_bs)
    RtlAppendUnicodeToString (&unat, L"\\");
  mntinfo.update (&unat, true);  /* this pulls from a cache, usually. */

  if (mntinfo.is_samba())
    strcpy (_my_tls.locals.mnt_type, (char *) "smbfs");
  else if (mntinfo.is_nfs ())
    strcpy (_my_tls.locals.mnt_type, (char *) "nfs");
  else if (mntinfo.is_fat ())
    strcpy (_my_tls.locals.mnt_type, (char *) "vfat");
  else if (mntinfo.is_ntfs ())
    strcpy (_my_tls.locals.mnt_type, (char *) "ntfs");
  else if (mntinfo.is_netapp ())
    strcpy (_my_tls.locals.mnt_type, (char *) "netapp");
  else if (mntinfo.is_cdrom ())
    strcpy (_my_tls.locals.mnt_type, (char *) "iso9660");
  else
    strcpy (_my_tls.locals.mnt_type, (char *) "unknown");

  ret.mnt_type = _my_tls.locals.mnt_type;

  /* mnt_opts is a string that details mount params such as
     binary or textmode, or exec.  We don't print
     `silent' here; it's a magic internal thing. */

  if (!(flags & MOUNT_BINARY))
    strcpy (_my_tls.locals.mnt_opts, (char *) "textmode");
  else
    strcpy (_my_tls.locals.mnt_opts, (char *) "binmode");

  if (flags & MOUNT_CYGWIN_EXEC)
    strcat (_my_tls.locals.mnt_opts, (char *) ",cygexec");
  else if (flags & MOUNT_EXEC)
    strcat (_my_tls.locals.mnt_opts, (char *) ",exec");
  else if (flags & MOUNT_NOTEXEC)
    strcat (_my_tls.locals.mnt_opts, (char *) ",noexec");
  if (flags & MOUNT_ENC)
    strcat (_my_tls.locals.mnt_opts, ",managed");

  if ((flags & MOUNT_CYGDRIVE))		/* cygdrive */
    strcat (_my_tls.locals.mnt_opts, (char *) ",noumount");

  if (!(flags & MOUNT_SYSTEM))		/* user mount */
    strcat (_my_tls.locals.mnt_opts, (char *) ",user");
  else					/* system mount */
    strcat (_my_tls.locals.mnt_opts, (char *) ",system");

  ret.mnt_opts = _my_tls.locals.mnt_opts;

  ret.mnt_freq = 1;
  ret.mnt_passno = 1;
  return &ret;
}

struct mntent *
mount_item::getmntent ()
{
  return fillout_mntent (native_path, posix_path, flags);
}

static struct mntent *
cygdrive_getmntent ()
{
  char native_path[4];
  char posix_path[CYG_MAX_PATH];
  DWORD mask = 1, drive = 'a';
  struct mntent *ret = NULL;

  while (_my_tls.locals.available_drives)
    {
      for (/* nothing */; drive <= 'z'; mask <<= 1, drive++)
	if (_my_tls.locals.available_drives & mask)
	  break;

      __small_sprintf (native_path, "%c:\\", drive);
      if (GetFileAttributes (native_path) == INVALID_FILE_ATTRIBUTES)
	{
	  _my_tls.locals.available_drives &= ~mask;
	  continue;
	}
      native_path[2] = '\0';
      __small_sprintf (posix_path, "%s%c", mount_table->cygdrive, drive);
      ret = fillout_mntent (native_path, posix_path, mount_table->cygdrive_flags);
      break;
    }

  return ret;
}

struct mntent *
mount_info::getmntent (int x)
{
  if (x < 0 || x >= nmounts)
    return cygdrive_getmntent ();

  return mount[native_sorted[x]].getmntent ();
}

/* Fill in the fields of a mount table entry.  */

void
mount_item::init (const char *native, const char *posix, unsigned mountflags)
{
  strcpy ((char *) native_path, native);
  strcpy ((char *) posix_path, posix);

  native_pathlen = strlen (native_path);
  posix_pathlen = strlen (posix_path);

  flags = mountflags;
}

/********************** Mount System Calls **************************/

/* Mount table system calls.
   Note that these are exported to the application.  */

/* mount: Add a mount to the mount table in memory and to the registry
   that will cause paths under win32_path to be translated to paths
   under posix_path. */

extern "C" int
mount (const char *win32_path, const char *posix_path, unsigned flags)
{
  int res = -1;
  flags &= ~MOUNT_SYSTEM;

  myfault efault;
  if (efault.faulted (EFAULT))
    /* errno set */;
  else if (!*posix_path)
    set_errno (EINVAL);
  else if (strpbrk (posix_path, "\\:"))
    set_errno (EINVAL);
  else if (flags & MOUNT_CYGDRIVE) /* normal mount */
    {
      /* When flags include MOUNT_CYGDRIVE, take this to mean that
	we actually want to change the cygdrive prefix and flags
	without actually mounting anything. */
      res = mount_table->write_cygdrive_info (posix_path, flags);
      win32_path = NULL;
    }
  else if (!*win32_path)
    set_errno (EINVAL);
  else
    res = mount_table->add_item (win32_path, posix_path, flags);

  syscall_printf ("%d = mount (%s, %s, %p)", res, win32_path, posix_path, flags);
  return res;
}

/* umount: The standard umount call only has a path parameter.  Since
   it is not possible for this call to specify whether to remove the
   mount from the user or global mount registry table, assume the user
   table. */

extern "C" int
umount (const char *path)
{
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  if (!*path)
    {
      set_errno (EINVAL);
      return -1;
    }
  return cygwin_umount (path, 0);
}

/* cygwin_umount: This is like umount but takes an additional flags
   parameter that specifies whether to umount from the user or system-wide
   registry area. */

extern "C" int
cygwin_umount (const char *path, unsigned flags)
{
  int res = -1;

  if (!(flags & MOUNT_CYGDRIVE))
    res = mount_table->del_item (path, flags & ~MOUNT_SYSTEM);

  syscall_printf ("%d = cygwin_umount (%s, %d)", res,  path, flags);
  return res;
}

bool
is_floppy (const char *dos)
{
  char dev[256];
  if (!QueryDosDevice (dos, dev, 256))
    return false;
  return ascii_strncasematch (dev, "\\Device\\Floppy", 14);
}

extern "C" FILE *
setmntent (const char *filep, const char *)
{
  _my_tls.locals.iteration = 0;
  _my_tls.locals.available_drives = GetLogicalDrives ();
  /* Filter floppy drives on A: and B: */
  if ((_my_tls.locals.available_drives & 1) && is_floppy ("A:"))
    _my_tls.locals.available_drives &= ~1;
  if ((_my_tls.locals.available_drives & 2) && is_floppy ("B:"))
    _my_tls.locals.available_drives &= ~2;
  return (FILE *) filep;
}

extern "C" struct mntent *
getmntent (FILE *)
{
  return mount_table->getmntent (_my_tls.locals.iteration++);
}

extern "C" int
endmntent (FILE *)
{
  return 1;
}

/********************** Symbolic Link Support **************************/

/* Create a symlink from FROMPATH to TOPATH. */

/* If TRUE create symlinks as Windows shortcuts, if false create symlinks
   as normal files with magic number and system bit set. */
bool allow_winsymlinks = true;

extern "C" int
symlink (const char *oldpath, const char *newpath)
{
  return symlink_worker (oldpath, newpath, allow_winsymlinks, false);
}

int
symlink_worker (const char *oldpath, const char *newpath, bool use_winsym,
		bool isdevice)
{
  int res = -1;
  size_t len;
  path_conv win32_newpath, win32_oldpath;
  char *buf, *cp;
  SECURITY_ATTRIBUTES sa = sec_none_nih;
  security_descriptor sd;
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;
  NTSTATUS status;
  HANDLE fh;
  FILE_BASIC_INFORMATION fbi;
  tmp_pathbuf tp;

  /* POSIX says that empty 'newpath' is invalid input while empty
     'oldpath' is valid -- it's symlink resolver job to verify if
     symlink contents point to existing filesystem object */
  myfault efault;
  if (efault.faulted (EFAULT))
    goto done;
  if (!*oldpath || !*newpath)
    {
      set_errno (ENOENT);
      goto done;
    }

  if (strlen (oldpath) > SYMLINK_MAX)
    {
      set_errno (ENAMETOOLONG);
      goto done;
    }

  len = strlen (newpath);
  /* Trailing dirsep is a no-no. */
  if (isdirsep (newpath[len - 1]))
    {
      set_errno (ENOENT);
      goto done;
    }
  /* We need the normalized full path below. */
  win32_newpath.check (newpath, PC_SYM_NOFOLLOW | PC_POSIX, stat_suffixes);
  if (use_winsym && !win32_newpath.exists ())
    {
      char *newplnk = tp.c_get ();
      stpcpy (stpcpy (newplnk, newpath), ".lnk");
      win32_newpath.check (newplnk, PC_SYM_NOFOLLOW | PC_POSIX);
    }

  if (win32_newpath.error)
    {
      set_errno (win32_newpath.case_clash ? ECASECLASH : win32_newpath.error);
      goto done;
    }

  syscall_printf ("symlink (%s, %S)", oldpath,
		  win32_newpath.get_nt_native_path ());

  if ((!isdevice && win32_newpath.exists ())
      || win32_newpath.is_auto_device ())
    {
      set_errno (EEXIST);
      goto done;
    }

  if (use_winsym)
    {
      ITEMIDLIST *pidl = NULL;
      size_t full_len = 0;
      unsigned short oldpath_len, desc_len, relpath_len, pidl_len = 0;
      char desc[MAX_PATH + 1], *relpath;

      if (!isdevice)
	{
	  /* First create an IDLIST to learn how big our shortcut is
	     going to be. */
	  IShellFolder *psl;

	  /* The symlink target is relative to the directory in which
	     the symlink gets created, not relative to the cwd.  Therefore
	     we have to mangle the path quite a bit before calling path_conv. */
	  if (!isabspath (oldpath))
	    {
	      len = strrchr (win32_newpath.normalized_path, '/')
		    - win32_newpath.normalized_path + 1;
	      char *absoldpath = tp.t_get ();
	      stpcpy (stpncpy (absoldpath, win32_newpath.normalized_path, len),
		      oldpath);
	      win32_oldpath.check (absoldpath, PC_SYM_NOFOLLOW, stat_suffixes);
	    }
	  else
	    win32_oldpath.check (oldpath, PC_SYM_NOFOLLOW, stat_suffixes);
	  if (SUCCEEDED (SHGetDesktopFolder (&psl)))
	    {
	      WCHAR wc_path[win32_oldpath.get_wide_win32_path_len () + 1];
	      win32_oldpath.get_wide_win32_path (wc_path);
	      /* Amazing but true:  Even though the ParseDisplayName method
		 takes a wide char path name, it does not understand the
		 Win32 prefix for long pathnames!  So we have to tack off
		 the prefix and convert tyhe path to the "normal" syntax
		 for ParseDisplayName.  I have no idea if it's able to take
		 long path names at all since I can't test it right now. */
	      WCHAR *wc = wc_path + 4;
	      if (!wcscmp (wc, L"UNC\\"))
		*(wc += 2) = L'\\';
	      HRESULT res;
	      if (SUCCEEDED (res = psl->ParseDisplayName (NULL, NULL, wc, NULL,
						    &pidl, NULL)))
		{
		  ITEMIDLIST *p;

		  for (p = pidl; p->mkid.cb > 0;
		       p = (ITEMIDLIST *)((char *) p + p->mkid.cb))
		    ;
		  pidl_len = (char *) p - (char *) pidl + 2;
		}
	      psl->Release ();
	    }
	}
      /* Compute size of shortcut file. */
      full_len = sizeof (win_shortcut_hdr);
      if (pidl_len)
	full_len += sizeof (unsigned short) + pidl_len;
      oldpath_len = strlen (oldpath);
      /* Unfortunately the length of the description is restricted to a
d2599 1
a2599 1
char *
@


1.488
log
@	* postinstall: New script.
	* Makefile.in (sysconfdir): Define.
	(install): Create $(sysconfdir)/postinstall dir.  Install postinstall
	script into it.

	* path.cc: Add temorary comments to note later function removal.
	(conv_fstab_spaces): New inline function to handle \040 to space
	conversion.
	(struct opt): Add "system" and "user" mount options.
	(mount_info::from_fstab_line): Only allow # to start a comment at
	the beginning of the line.  Call conv_fstab_spaces on native_path and
	posix_path fields.  Don't enforce system mounts in /etc/fstab.
	Drop last argument in call to add_item.
	(mount_info::from_fstab): Create a default cygdrive entry.  Load
	user mount points from fstab.<username> instead of fstab.<sid>.
	(mount_info::read_mounts): Drop last argument in call to add_item.
	(mount_info::add_reg_mount): Remove.
	(mount_info::del_reg_mount): Remove.
	(mount_info::write_cygdrive_info): Rename from
	mount_info::write_cygdrive_info_to_registry.  Don't write to registry.
	Disallow to overwrite a system cygdrive prefix.
	(mount_info::remove_cygdrive_info_from_registry): Remove.
	(mount_info::get_cygdrive_info): Just fetch current cygdrive prefix and
	flags.
	(mount_info::add_item): Drop last argument.  Don't write to registry.
	Disallow to overwrite a system mount point.
	(mount_info::del_item): Drop last argument.  Don't write to registry.
	Disallow to remove a system mount point.
	(mount): Enforce user mount.
	(cygwin_umount): Ditto.
	* shared_info.h (mount_info::add_item): Drop last argument.
	(mount_info::del_item): Ditto.
	(mount_info::add_reg_mount): Remove.
	(mount_info::del_reg_mount): Remove.
	(mount_info::write_cygdrive_info): Rename from
	mount_info::write_cygdrive_info_to_registry.
	(mount_info::remove_cygdrive_info_from_registry): Remove.
@
text
@d2343 1
a2343 1
  {"system", MOUNT_SYSTEM, 0},
@


1.487
log
@	* path.cc (mount_info::from_fstab_line): Simplify.
	(mount_info::from_fstab): Create a default root dir.
@
text
@d1643 3
d2323 12
d2342 2
d2395 1
a2395 1
  native_path = c;
d2398 1
a2398 1
  if (!*c || *c == '#')
d2402 1
a2402 1
  posix_path = c;
d2405 1
a2405 1
  if (!*c || *c == '#')
d2412 1
a2412 1
  if (!*c || *c == '#')
d2416 1
a2416 1
  unsigned mount_flags = 0;
a2420 2
  else
    mount_flags |= MOUNT_SYSTEM;
d2423 1
a2423 1
      cygdrive_flags = mount_flags;
d2429 1
a2429 2
      int res = mount_table->add_item (native_path, posix_path, mount_flags,
				     false);
a2460 1
  /* Create a default root dir from the path the Cygwin DLL is in. */
d2463 1
d2467 7
a2473 2
      mount_table->add_item (native_root, "/", MOUNT_SYSTEM | MOUNT_BINARY,
			     false);
d2478 2
a2479 1
    cygheap->user.get_windows_id (wcpcpy (u, L"."));
d2529 1
d2574 1
a2574 1
      res = mount_table->add_item (native_path, posix_path, mount_flags, false);
d2582 1
a2605 68
/* add_reg_mount: Add mount item to registry.  Return zero on success,
   non-zero on failure. */
/* FIXME: Need a mutex to avoid collisions with other tasks. */

int
mount_info::add_reg_mount (const char *native_path, const char *posix_path, unsigned mountflags)
{
  int res;

  /* Add the mount to the right registry location, depending on
     whether MOUNT_SYSTEM is set in the mount flags. */

  reg_key reg (mountflags & MOUNT_SYSTEM,  KEY_ALL_ACCESS,
	       CYGWIN_INFO_CYGWIN_MOUNT_REGISTRY_NAME, NULL);

  /* Start by deleting existing mount if one exists. */
  res = reg.kill (posix_path);
  if (res != ERROR_SUCCESS && res != ERROR_FILE_NOT_FOUND)
    {
 err:
      __seterrno_from_win_error (res);
      return -1;
    }

  /* Create the new mount. */
  reg_key subkey (reg.get_key (), KEY_ALL_ACCESS, posix_path, NULL);

  res = subkey.set_string ("native", native_path);
  if (res != ERROR_SUCCESS)
    goto err;
  res = subkey.set_int ("flags", mountflags);

  if (mountflags & MOUNT_SYSTEM)
    {
      sys_mount_table_counter++;
      cygwin_shared->sys_mount_table_counter++;
    }
  return 0; /* Success */
}

/* del_reg_mount: delete mount item from registry indicated in flags.
   Return zero on success, non-zero on failure.*/
/* FIXME: Need a mutex to avoid collisions with other tasks. */

int
mount_info::del_reg_mount (const char * posix_path, unsigned flags)
{
  int res;

  reg_key reg (flags & MOUNT_SYSTEM, KEY_ALL_ACCESS,
	       CYGWIN_INFO_CYGWIN_MOUNT_REGISTRY_NAME, NULL);
  res = reg.kill (posix_path);

  if (res != ERROR_SUCCESS)
    {
      __seterrno_from_win_error (res);
      return -1;
    }

  if (flags & MOUNT_SYSTEM)
    {
      sys_mount_table_counter++;
      cygwin_shared->sys_mount_table_counter++;
    }

  return 0; /* Success */
}

d2609 1
d2643 2
a2644 2
/* write_cygdrive_info_to_registry: Write the default prefix and flags
   to use when creating cygdrives to the special user registry
d2648 1
a2648 1
mount_info::write_cygdrive_info_to_registry (const char *cygdrive_prefix, unsigned flags)
a2654 14
      {
	set_errno (EINVAL);
	return -1;
      }

  char hold_cygdrive_prefix[strlen (cygdrive_prefix) + 1];
  /* Ensure that there is never a final slash */
  nofinalslash (cygdrive_prefix, hold_cygdrive_prefix);

  reg_key r (flags & MOUNT_SYSTEM, KEY_ALL_ACCESS,
	     CYGWIN_INFO_CYGWIN_MOUNT_REGISTRY_NAME, NULL);
  int res;
  res = r.set_string (CYGWIN_INFO_CYGDRIVE_PREFIX, hold_cygdrive_prefix);
  if (res != ERROR_SUCCESS)
d2656 1
a2656 1
      __seterrno_from_win_error (res);
d2659 2
a2660 10
  r.set_int (CYGWIN_INFO_CYGDRIVE_FLAGS, flags);

  if (flags & MOUNT_SYSTEM)
    sys_mount_table_counter = ++cygwin_shared->sys_mount_table_counter;

  /* This also needs to go in the in-memory copy of "cygdrive", but only if
     appropriate:
       1. setting user path prefix, or
       2. overwriting (a previous) system path prefix */
  if (!(flags & MOUNT_SYSTEM) || (mount_table->cygdrive_flags & MOUNT_SYSTEM))
d2662 2
a2663 3
      slashify (cygdrive_prefix, cygdrive, 1);
      cygdrive_flags = flags;
      cygdrive_len = strlen (cygdrive);
d2666 4
a2673 27
mount_info::remove_cygdrive_info_from_registry (const char *cygdrive_prefix, unsigned flags)
{
  reg_key r (flags & MOUNT_SYSTEM, KEY_ALL_ACCESS,
	     CYGWIN_INFO_CYGWIN_MOUNT_REGISTRY_NAME,
	     NULL);

  /* Delete cygdrive prefix and flags. */
  int res = r.killvalue (CYGWIN_INFO_CYGDRIVE_PREFIX);
  int res2 = r.killvalue (CYGWIN_INFO_CYGDRIVE_FLAGS);

  if (flags & MOUNT_SYSTEM)
    sys_mount_table_counter = ++cygwin_shared->sys_mount_table_counter;

  /* Reinitialize the cygdrive path prefix to reflect to removal from the
     registry. */
  read_cygdrive_info_from_registry ();

  if (res == ERROR_SUCCESS)
    res = res2;
  if (res == ERROR_SUCCESS)
    return 0;

  __seterrno_from_win_error (res);
  return -1;
}

int
d2677 2
a2678 4
  /* Get the user path prefix from HKEY_CURRENT_USER. */
  reg_key r (false,  KEY_READ, CYGWIN_INFO_CYGWIN_MOUNT_REGISTRY_NAME, NULL);
  int res = r.get_string (CYGWIN_INFO_CYGDRIVE_PREFIX, user, CYG_MAX_PATH, "");

d2680 2
a2681 5
  if (user_flags && res == ERROR_SUCCESS)
    {
      int flags = r.get_int (CYGWIN_INFO_CYGDRIVE_FLAGS, MOUNT_CYGDRIVE | MOUNT_BINARY);
      strcpy (user_flags, (flags & MOUNT_BINARY) ? "binmode" : "textmode");
    }
d2683 2
a2684 3
  /* Get the system path prefix from HKEY_LOCAL_MACHINE. */
  reg_key r2 (true,  KEY_READ, CYGWIN_INFO_CYGWIN_MOUNT_REGISTRY_NAME, NULL);
  int res2 = r2.get_string (CYGWIN_INFO_CYGDRIVE_PREFIX, system, CYG_MAX_PATH, "");
d2686 3
a2688 6
  /* Get the system flags, if appropriate */
  if (system_flags && res2 == ERROR_SUCCESS)
    {
      int flags = r2.get_int (CYGWIN_INFO_CYGDRIVE_FLAGS, MOUNT_CYGDRIVE | MOUNT_BINARY);
      strcpy (system_flags, (flags & MOUNT_BINARY) ? "binmode" : "textmode");
    }
d2690 1
a2690 1
  return (res != ERROR_SUCCESS) ? res : res2;
d2786 2
a2787 1
mount_info::add_item (const char *native, const char *posix, unsigned mountflags, int reg_p)
d2833 11
a2843 3
      if (strcasematch (mount[i].posix_path, posixtmp) &&
	  (mount[i].flags & MOUNT_SYSTEM) == (mountflags & MOUNT_SYSTEM))
	break;
a2851 3
  if (reg_p && add_reg_mount (nativetmp, posixtmp, mountflags))
    return -1;

d2869 1
a2869 1
mount_info::del_item (const char *path, unsigned flags, int reg_p)
a2890 5
  if (reg_p && posix_path_p &&
      del_reg_mount (pathtmp, flags) &&
      del_reg_mount (path, flags)) /* for old irregular entries */
    return -1;

d2896 1
a2896 2
	   : strcasematch (mount[ent].native_path, pathtmp)) &&
	  (mount[ent].flags & MOUNT_SYSTEM) == (flags & MOUNT_SYSTEM))
d2898 6
a2903 4
	  if (!posix_path_p &&
	      reg_p && del_reg_mount (mount[ent].posix_path, flags))
	    return -1;

d3078 1
d3092 1
a3092 1
      res = mount_table->write_cygdrive_info_to_registry (posix_path, flags);
d3098 1
a3098 1
    res = mount_table->add_item (win32_path, posix_path, flags, true);
d3132 2
a3133 11
  if (flags & MOUNT_CYGDRIVE)
    {
      /* When flags include MOUNT_CYGDRIVE, take this to mean that we actually want
	 to remove the cygdrive prefix and flags without actually unmounting
	 anything. */
      res = mount_table->remove_cygdrive_info_from_registry (path, flags);
    }
  else
    {
      res = mount_table->del_item (path, flags, true);
    }
@


1.486
log
@	* path.cc (mount_info::from_fstab): Get module path name of the Cygwin
	DLL, not the path of the application.
@
text
@d2370 1
a2370 4
  tmp_pathbuf tp;
  char *native_path = tp.c_get ();
  /* FIXME */
  char posix_path[CYG_MAX_PATH];
d2378 1
a2378 2
  *native_path = '\0';
  strncat (native_path, c, NT_MAX_PATH - 1);
d2385 2
a2386 3
  *posix_path = '\0';
  strncat (posix_path, c, CYG_MAX_PATH - 1);
  /* Third field: FS type.  Ignored. */
d2392 1
d2406 1
a2406 1
  if (!strcmp (native_path, "cygdrive"))
d2415 1
a2415 1
				       false);
d2446 12
a2457 1
  w = wcpcpy (w, L"\\etc\\fstab");
d2459 1
a2459 1
    cygheap->user.get_windows_id (wcpcpy (w, L"."));
@


1.485
log
@	* path.cc (mount_info::init): First try to fetch mount points from
	fstab files.  Fallback to registry if none exists.
	(skip_ws): New inline function.
	(find_ws): Ditto.
	(struct opt): New structure for mount options.
	(read_flags): New static function to convert a mount flags string into
	a flag value.
	(mount_info::from_fstab_line): New method to create a mount table
	entry from a fstab line.
	(mount_info::from_fstab): New method to read fstab file.
	* shared_info.h (mount_info::from_fstab_line): Declare.
	(mount_info::from_fstab): Declare.
@
text
@d2433 2
a2434 1
  if (!GetModuleFileNameW (NULL, path, NT_MAX_PATH))
@


1.484
log
@	* path.cc (enum symlink_t): Rename from shortcut_t.
@
text
@d1641 2
d1645 1
d2304 195
@


1.483
log
@	* path.cc (symlink_info::check_reparse_point): Use NtFsControlFile
	to read reparse points.
	(enum shortcut_t): New type.
	(symlink_info::check): Convert sym_check to shortcut_t.  Use shortcut_t
	enum values throughout.  Check reparse point before checking for
	sysfile shortcut.  Open reparse points with READ_CONTROL only to
	accommodate special Vista reparse points.  Add comments.
@
text
@d3781 1
a3781 1
enum shortcut_t {
d3910 1
a3910 1
      shortcut_t sym_check;
@


1.482
log
@	* smallprint.cc (__small_vswprintf): Fix uninitialized usage of `w'.

	Revamp advisory file locking to avoid cross reference pointers as well
	as to allow BSD flock semantics.  More agressively delete unused nodes
	and sync objects.
	* fhandler.h (fhandler_base::ino): Rename from namehash.  Fix comment.
	(fhandler_base::node): Remove.
	(fhandler_base::unique_id): Add.
	(fhandler_base::del_my_locks): New method.
	(get_ino): Rename from get_namehash.  Change usage throughout Cygwin.
	(get_unique_id): New method.
	* fhandler.cc (fhandler_base::close): Call own del_my_locks method.
	Fix comment.
	(fhandler_base::fhandler_base): Accommodate new and changed members.
	(fhandler_base::fixup_after_fork): Call del_my_locks.
	(fhandler_base::fixup_after_exec): Ditto for files with close-on-exec
	flag set.
	* fhandler_disk_file.cc (get_ino_by_handle): Rename from
	readdir_get_ino_by_handle.  Accommodate throughout.
	(fhandler_base::open_fs): Fill ino with inode number if FS has good
	inodes.  Allocate a LUID and store in unique_id to recognize file
	descriptors referencing the same file object.
	* flock.cc: Drop flock TODO comments.  Use explicit types __dev32_t
	and __ino64_t instead of dev_t and ino_t.
	(LOCK_OBJ_NAME_LEN): Change to reflect longer lf_id length.
	(get_obj_handle_count): New method.
	(lockf_t::lf_id): Change type to long long.
	(inode_t::get_lock_obj_handle_count): Drop in favor of static function
	get_obj_handle_count.
	(inode_t::del_locks): Remove.
	(inode_t::get): Add create_if_missing flag argument.
	(inode_t::del_my_locks): Reimplement to handle POSIX and BSD flock
	locks.  Return if node can be deleted or not.
	(inode_t::~inode_t): Ditto.  Close handles to i_dir and i_mtx.
	(fixup_lockf_after_fork): Remove.
	(fhandler_base::del_my_locks): New method.
	(fixup_lockf_after_exec): Check if node can be deleted.
	(inode_t::get): Only create node if create_if_missing is set.  Lock
	the returned node here before unlocking the node list.
	(inode_t::get_all_locks_list): Accommodate new lf_id length.
	(inode_t::create_lock_obj): Ditto.
	(lockf_t::open_lock_obj): Ditto.  Change return type to bool.  De-const.
	Set lf_obj instead of returning a handle.
	(lockf_t::del_lock_obj): Call SetEvent only if new incoming parameters
	allow it.  Explain how it's supposed to work.
	(fhandler_disk_file::lock): Only fetch file length in SEEK_END case.
	Use NtQueryInformationFile(FileStandardInformation) instead of
	calling fstat_by_handle.  Always unlock node before returning.
	Use fhandler's unique id to create lf_id for BSD flock locks.
	Rely on node lock from inode_t::get.  Call del_lock_obj on removed
	locks here to allow explicit unlocking.  Delete node if no lock exists
	on the file anymore.
	(lf_setlock): Get file handle as additional parameter.  Handle the fact
	that lf_getblock now always opens the attached event object.  Reactivate
	erroneously applied patch which deactivates setting thread priority.
	Additionally handle blocking on BSD flock locks.
	(lf_clearlock): Get file handle as additional parameter.
	(lf_getlock): Close event handle opened by lf_getblock.
	(lf_getblock): Open potentially blocking event object here and check
	its signal state if it's a BSD flock lock.
	(lf_wakelock): Get file handle as additional parameter.
	* fork.cc (frok::child): Drop call to fixup_lockf_after_fork.
	* ntdll.h (struct _EVENT_BASIC_INFORMATION): Define.
	(enum _EVENT_INFORMATION_CLASS): Define.
	(NtQueryEvent): Declare.

	* fhandler.h (fhandler_base::fs_flags): Remove.
	(fhandler_base::set_fs_flags): Remove.
	(fhandler_base::get_fs_flags): Remove.
	* fhandler.cc (fhandler_base::write): Check for sparse file using
	pc.fs_flags().
	* fhandler_disk_file.cc (fhandler_disk_file::ftruncate): Ditto.

	The return of the volume serial number in fs_info.
	* fhandler.h (get_dev): New method.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Drop call to
	NtQueryVolumeInformationFile(FileFsVolumeInformation).  Just use
	get_dev() method.
	* fhandler_fifo.cc (fhandler_fifo::open) Use device ID and inode number
	to generate fifo name.
	* path.h (fs_info::sernum): New member.
	(fs_info::serial_number): New method.
	(path_conv::fs_serial_number): New method.
	* path.cc (fs_info::update): Fetch volume serial number and store in
	sernum.
@
text
@d3490 2
a3493 1
  DWORD size;
d3496 4
a3499 2
  if (!DeviceIoControl (h, FSCTL_GET_REPARSE_POINT, NULL, 0, (LPVOID) rp,
			MAXIMUM_REPARSE_DATA_BUFFER_SIZE, &size, NULL))
d3501 2
a3502 1
      debug_printf ("DeviceIoControl(FSCTL_GET_REPARSE_POINT) failed, %E");
d3781 7
d3910 1
a3910 1
      int sym_check;
d3912 1
a3912 1
      sym_check = 0;
d3921 9
a3929 1
	sym_check = 1;
d3935 1
a3935 1
	sym_check = 2;
d3937 1
a3937 5
      /* Reparse points are potentially symlinks. */
      else if (fileattr & FILE_ATTRIBUTE_REPARSE_POINT)
	sym_check = 3;

      if (!sym_check)
d3942 12
a3953 6
      /* Open the file.  */
      status = NtOpenFile (&h, FILE_GENERIC_READ, &attr, &io,
			   FILE_SHARE_VALID_FLAGS,
			   FILE_SYNCHRONOUS_IO_NONALERT
			   | FILE_OPEN_FOR_BACKUP_INTENT
			   | (sym_check == 3 ? FILE_OPEN_REPARSE_POINT : 0));
d3959 1
a3959 1
	case 1:
d3975 2
a3976 2
	case 2:
	  res = check_sysfile (h);
d3981 2
a3982 2
	case 3:
	  res = check_reparse_point (h);
d3987 2
@


1.481
log
@* dtable.cc: Define various device-related string constants as wide character
constants.
(dtable::init_std_file_from_handle): Reorganize pipe handling to try to catch
special tty case.
(build_fh_name_worker): Declare for common use.
(build_fh_name): Define char version.
(build_fh_name): Define (currently unused) UNICODE_STRING version.
(decode_tty): Detect if pipe is actually a cygwin tty, returning the tty name
in the buffer.
(handle_to_fn): Reorganize to use wide characters.
* dtable.h (build_fh_name): Declare (currently unused) UNICODE_STRING version.
* fhandler_tty.cc (fhandler_pty_master::setup): Use
fhandler_pipe::create_selectable to create a pipe with a given name.
* pipe.cc (pipe_handler): Make returned handle inheritable.
(fhandler_pipe::create_selectable): Take an optional name.  Use a standard
cygwin introducer for the name.
* path.cc (path_conv::check): Make first argument const.
* path.h (path_conv::check): Ditto for declaration.
(path_conv::path_conv): Ditto for UNICODE_STRING version.
@
text
@d410 4
d445 3
@


1.480
log
@	* fcntl.cc (fcntl_worker): Protect with a 'myfault'.

	* path.cc (normalize_posix_path): Treat X:/ as Win32 path, too.

	* smallprint.cc (__wrn): New static function.
	(__small_vswprintf): New function to generate WCHAR strings.
	(__small_swprintf): Ditto.
	* winsup.h (__small_swprintf): Declare.
	(__small_vswprintf): Declare.
@
text
@d1 1
a1 1
  /* path.cc: path support.
d4 1
a4 1
   2006, 2007 Red Hat, Inc.
d793 1
a793 1
path_conv::check (PUNICODE_STRING src, unsigned opt,
@


1.479
log
@	* fhandler_disk_file.cc (fhandler_disk_file::readdir_helper): Disable
	munging.  Convert all chars in the 0xf0xx area to it's ascii equivalent.
	* path.cc (normalize_posix_path): Don't treat "X:foo" as windows path,
	only "a:\foo".
	(tfx_chars): New transformation table for special DOS chars.
	(tfx_chars_managed): Ditto, plus transformation of uppercase ASCII
	chars.
	(transform_chars): New function.
	(get_nt_native_path): Make static.  Call transform_chars for all valid
	FS paths.  Get additional flag if file is managed or not.  Accommodate
	throughout.
	(getfileattr): Get additional flag if file is managed or not.
	Accommodate throughout.
	(path_conv::check): Disable special handling for trailing dots and
	spaces.
	(mount_item::build_win32): Disable code for managed paths.
	(mount_info::conv_to_posix_path): Ditto.
	* path.h (get_nt_native_path): Remove declaration.
@
text
@d256 1
a256 1
  if ((isdrive (src) && src[2] == '\\') || *src == '\\')
@


1.478
log
@	* winsup.h (NT_MAX_PATH): Revert ill-advised change to 32767.
	Accommodate change throughout.

	* cygwin.din (cygwin_conv_path): Export.
	(cygwin_conv_path_list): Export.
	(cygwin_create_path): Export.
	* dcrt0.cc (dll_crt0_1): Use cygwin_conv_path.
	* dtable.cc (handle_to_fn): Ditto.  Don't expect UNICODE_STRING being
	0-terminated.
	* environ.cc (env_plist_to_posix): New helper function.
	(env_plist_to_win32): Ditto.
	(env_path_to_posix): Ditto.
	(env_path_to_win32): Ditto.
	(return_MAX_PATH): Remove.
	(conv_envvars): Use new helper functions.  Drop removed members.
	(win_env::operator =): Accommodate removal of path length functions.
	(win_env::add_cache): Accommodate new env helper function API.
	(posify): Ditto.
	* environ.h (struct win_env): Ditto. Remove path length function
	pointers since they are unused.
	* path.cc (warn_msdos): Use cygwin_conv_path.
	(getfileattr): Use new tmp_pathbuf::u_get method.
	(fillout_mntent): Ditto.
	(symlink_info::check): Ditto.
	(path_conv::check): Use sizeof (WCHAR) instead of constant 2.
	(symlink_info::check_reparse_point): Ditto.
	(conv_path_list): Get max size of target string as argument.  Call
	cygwin_conv_path as helper function.
	(cygwin_conv_path): New function.
	(cygwin_create_path): New function.
	(cygwin_conv_to_win32_path): Just call cygwin_conv_path with size set
	to MAX_PATH.
	(cygwin_conv_to_full_win32_path): Ditto.
	(cygwin_conv_to_posix_path): Ditto.
	(cygwin_conv_to_full_posix_path): Ditto.
	(conv_path_list_buf_size): Add FIXME comment.
	(env_PATH_to_posix): Rename from env_win32_to_posix_path_list.
	Add size argument as required for env helper functions.
	(cygwin_win32_to_posix_path_list): Call conv_path_list with size set to
	MAX_PATH.
	(cygwin_posix_to_win32_path_list): Ditto.
	(cygwin_conv_path_list): New function.
	(cwdstuff::get): Fix length argument in call to sys_wcstombs.
	* spawn.cc (find_exec): Use cygwin_conv_path_list.
	* tls_pbuf.h (tmp_pathbuf::u_get: New method.
	* uinfo.cc (cygheap_user::ontherange): Allocate temporary path buffers
	using tmp_pathbuf.  Use cygwin_conv_path.
	* winf.cc (av::unshift): Use cygwin_conv_path.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/cygwin.h: Comment out old cygwin32_XXX API.
	Mark old path handling API as deprecated.
	(cygwin_conv_path_t): Typedef.  Define values.
	(cygwin_conv_path): Declare.
	(cygwin_create_path): Declare.
	(cygwin_conv_path_list): Declare.
@
text
@d256 1
a256 1
  if (isdrive (src) || *src == '\\')
d583 55
a637 2
PUNICODE_STRING
get_nt_native_path (const char *path, UNICODE_STRING& upath)
d646 1
d655 1
d674 1
a674 1
      ::get_nt_native_path (path, uni_path);
d724 1
a724 1
getfileattr (const char *path) /* path has to be always absolute. */
d735 1
a735 1
  get_nt_native_path (path, upath);
d930 1
a930 1
		  fileattr = getfileattr (this->path);
d939 1
a939 1
	      fileattr = getfileattr (this->path);
d1228 1
d1249 1
a1249 1

d1835 2
a1836 2
  if (!*p || !(flags & MOUNT_ENC))
    {
d1841 1
d1863 1
a2195 1
  char *tmpbuf = tp.c_get ();
d2232 1
d2235 1
d2239 1
d2837 1
a2837 1
  get_nt_native_path (native_path, unat);
d3803 1
a3803 1
      get_nt_native_path (suffix.path, upath);
@


1.477
log
@	* path.cc (cwdstuff::set): Make sure drive_length is 0 for virtual
	paths.  Add comments.
	* spawn.cc (spawn_guts): Don't allow to start a native Win32 application
	from a long path or a virtual path.  Print an error message to stderr.
@
text
@d655 2
a656 1
  if (cygwin_conv_to_full_posix_path (src, posix_path))
a664 1

d678 1
a678 1
  RtlInitEmptyUnicodeString (&upath, tp.w_get (), NT_MAX_PATH * sizeof (WCHAR));
d745 1
a745 1
  sys_wcstombs (path, NT_MAX_PATH, src->Buffer, src->Length / 2);
d1507 1
a1507 1
conv_path_list (const char *src, char *dst, int to_posix)
d1510 1
a1510 1
  int (*conv_fn) (const char *, char *);
d1516 1
a1516 1
      conv_fn = cygwin_conv_to_posix_path;
d1522 1
a1522 1
      conv_fn = cygwin_conv_to_win32_path;
d1533 1
a1533 1
      int len = s - srcbuf;
d1540 4
a1543 1
	err = conv_fn (srcbuf, ++d);
d1545 4
a1548 1
	err = conv_fn (".", ++d);
d2776 1
a2776 1
  RtlInitEmptyUnicodeString (&unat, tp.w_get (), NT_MAX_PATH * sizeof (WCHAR));
d3440 1
a3440 1
		    rp->SymbolicLinkReparseBuffer.SubstituteNameLength / 2);
d3454 1
a3454 1
		    rp->MountPointReparseBuffer.SubstituteNameLength / 2);
d3733 1
a3733 1
  RtlInitEmptyUnicodeString (&upath, tp.w_get (), NT_MAX_PATH * sizeof (WCHAR));
d4163 3
a4165 2
extern "C" int
cygwin_conv_to_win32_path (const char *path, char *win32_path)
d4167 59
a4225 2
  path_conv p (path, PC_SYM_FOLLOW | PC_NO_ACCESS_CHECK | PC_NOFULL | PC_NOWARN);
  if (p.error)
d4227 1
a4227 2
      win32_path[0] = '\0';
      set_errno (p.error);
d4230 27
d4259 5
a4263 3
  strcpy (win32_path,
	  strcmp (p.get_win32 (), ".\\") == 0 ? "." : p.get_win32 ());
  return 0;
d4269 2
a4270 10
  path_conv p (path, PC_SYM_FOLLOW | PC_NO_ACCESS_CHECK | PC_NOWARN);
  if (p.error)
    {
      win32_path[0] = '\0';
      set_errno (p.error);
      return -1;
    }

  strcpy (win32_path, p.get_win32 ());
  return 0;
d4278 2
a4279 9
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  if (!*path)
    {
      set_errno (ENOENT);
      return -1;
    }
  return_with_errno (mount_table->conv_to_posix_path (path, posix_path, 1));
d4285 2
a4286 9
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  if (!*path)
    {
      set_errno (ENOENT);
      return -1;
    }
  return_with_errno (mount_table->conv_to_posix_path (path, posix_path, 0));
d4395 1
d4439 2
a4440 2
extern "C" int
env_win32_to_posix_path_list (const char *win32, char *posix)
d4442 2
a4443 1
  return_with_errno (conv_path_list (win32, posix, ENV_CVT));
d4449 1
a4449 1
  return_with_errno (conv_path_list (win32, posix, 1));
d4455 29
a4483 1
  return_with_errno (conv_path_list (posix, win32, 0));
d4788 2
a4789 1
      sys_wcstombs (tocopy, NT_MAX_PATH, win32.Buffer, win32.Length);
@


1.476
log
@	* fhandler_disk_file.cc (DIR_BUF_SIZE): Define required space for file
	name in terms of sizeof(WCHAR).
	(fhandler_disk_file::readdir_helper): Convert *all* of fname.
	* path.cc (fillout_mntent): Use tmp_pathbuf for path buffer.
	(symlink_worker): Ditto.
	(SCAN_JUSTCHECKTHIS): New state for suffix_scan to define
	that only the actual name gets cheked and a suffix is never attached.
	(suffix_scan::has): If filename + suffix would be > NAME_MAX, start
	in SCAN_JUSTCHECKTHIS state.
	(suffix_scan::next): Add case for SCAN_JUSTCHECKTHIS.
	(symlink_info::check): Use tmp_pathbuf for path buffer.  Goto
	file_not_symlink in case of invalid file name.
	(realpath): Use tmp_pathbuf for path buffer.
@
text
@d4633 3
a4635 1
      if (win32.Buffer[1] == L':')
d4637 1
a4637 1
      else if (win32.Buffer[1] == L'\\')
d4647 1
a4647 1
      else
@


1.475
log
@	* Makefile.in (DLL_OFILES): Add tls_pbuf.o.
	* autoload.cc (CreateDesktopW): Replace CreateDesktopA.
	(CreateWindowStationW): Replace CreateWindowStationA.
	(GetUserObjectInformationW): Replace GetUserObjectInformationA.
	* cygheap.h (cwdstuff::get): Assume default buffer size NT_MAX_PATH.
	* cygtls.cc (_cygtls::remove): Free temporary TLS path buffers.
	* cygtls.h (TP_NUM_C_BUFS): Define.
	(TP_NUM_W_BUFS): Define.
	(class tls_pathbuf): New class to store pointers to thread local
	temporary path buffers.
	(_local_storage::pathbufs): New member.
	* environ.cc (win_env::add_cache): Use temporary TLS path buffer instead
	of stack based buffer.
	(posify): Get temporary outenv buffer from calling function.
	(environ_init): Create temporary TLS path buffer for posify.
	(build_env): Create Windows environment block as WCHAR buffer.
	* environ.h (build_env): Change declaration accordingly.
	* external.cc (sync_winenv): Accommodate build_env change.
	* fhandler_console.cc (fhandler_console::need_invisible): Use
	GetUserObjectInformationW and CreateWindowStationW.
	* fhandler_process.cc (format_process_maps): Use temporary TLS path
	buffer instead of stack based buffer.
	* fork.cc (frok::parent): Convert to use CreateProcessW.
	* path.cc: Throughout use temporary TLS path buffers instead of stack
	based buffer.  Replace checks for CYG_MAX_PATH by checks for
	NT_MAX_PATH.
	(getfileattr): New function to replace GetFileAttributesA.
	(normalize_win32_path): Remove Win32 and NT long path prefixes.
	(getwd): Assume PATH_MAX + 1 buffer per SUSv3.
	* path.h (class path_conv): Set path buffer to size NT_MAX_PATH.
	(iswdrive): Define.
	* pinfo.cc (commune_process): Use temporary TLS path buffer instead of
	stack based buffer.
	* registry.cc (get_registry_hive_path): Ditto.
	(load_registry_hive): Ditto.
	* spawn.cc (spawn_guts): Convert to use CreateProcessW and
	CreateProcessAsUserW.
	(av::fixup): Open/close file using NtOpenFile/NtClose.
	* syscalls.cc (mknod_worker): Allow PATH_MAX file name.
	(mknod32): Ditto.
	(getusershell): Ditto.
	* tls_pbuf.cc: New file implementing tls_pathbuf and tmp_pathbuf
	methods.
	* tls_pbuf.h: New header for files using tmp_pathbuf.
	* tlsoffsets.h: Regenerate.
	* winsup.h (NT_MAX_PATH): Define as 32767 to avoid USHORT overflow.
@
text
@d2768 1
d2770 1
a2770 3
  /* Size must allow prepending the native NT path prefixes. */
  size_t size = (strlen (native_path) + 10) * sizeof (WCHAR);
  RtlInitEmptyUnicodeString (&unat, (PWSTR) alloca (size), size);
d3029 1
d3060 1
a3060 1
      char *newplnk = (char *) alloca (len + 5);
d3101 1
a3101 1
	      char *absoldpath = (char *) alloca (len + strlen (oldpath) + 1);
d3159 1
a3159 1
	  stpcpy (relpath = (char *) alloca (relpath_len + 1), oldpath);
d3164 1
a3164 2
	  stpcpy (relpath = (char *) alloca (relpath_len + 1),
		  win32_oldpath.get_win32 ());
d3513 1
d3537 3
a3539 1
  char *ext_here = strrchr (in_path, '.');
d3569 6
d3606 3
d3724 1
d3727 1
a3727 2
  size_t len = (strlen (path) + 8 + 8 + 1) * sizeof (WCHAR);
  RtlInitEmptyUnicodeString (&upath, (PCWSTR) alloca (len), len);
d3760 1
a3760 1
	      break;
d4237 1
d4241 1
a4241 3
      tpath = (char *) alloca (strlen (path)
			       + strlen (mount_table->cygdrive)
			       + 1);
@


1.474
log
@	* child_info.h (~child_info_spawn): Check moreinfo->myself_pinfo for
	NULL before closing.
	* spawn.cc (spawn_guts): Don't close moreinfo->myself_pinfo explicitely
	in case of failing CloseProcess.

	* fhandler.cc (fhandler_base::open_): Return EISDIR when trying to
	create a directory.
	* path.cc (path_conv::check): If input path had a trailing dir
	separator, tack it on to the native path if directory doesn't exist.
@
text
@d79 1
d323 1
a323 1
	if ((tail - dst) >= CYG_MAX_PATH)
d359 2
a360 1
  char cwd_win32[CYG_MAX_PATH];
d652 2
a653 1
  char posix_path[CYG_MAX_PATH];
d668 50
d741 2
a742 1
  char path[CYG_MAX_PATH];
d745 1
a745 1
  sys_wcstombs (path, CYG_MAX_PATH, src->Buffer, src->Length / 2);
d753 6
a758 5
  /* This array is used when expanding symlinks.  It is CYG_MAX_PATH * 2
     in length so that we can hold the expanded symlink plus a
     trailer.  */
  char path_copy[CYG_MAX_PATH + 3];
  char tmp_buf[2 * CYG_MAX_PATH + 3];
a842 1
	  char pathbuf[CYG_MAX_PATH];
d875 1
a875 1
		  fileattr = GetFileAttributes (this->path);
d884 1
a884 1
	      fileattr = GetFileAttributes (this->path);
d1107 1
a1107 1
      if (headptr + symlen >= tmp_buf + sizeof (tmp_buf))
d1128 1
a1128 1
	  if (headptr + taillen > tmp_buf + sizeof (tmp_buf))
d1296 2
a1298 1
  PBYTE bintest[get_nt_native_path ()->Length + sizeof (WCHAR)];
d1301 1
a1301 1
	 && GetBinaryTypeW (get_wide_win32_path ((PWCHAR) bintest), &bin);
d1344 13
d1431 1
a1431 1
      if ((tail - dst) >= CYG_MAX_PATH)
d1534 1
a1534 1
      if (len >= CYG_MAX_PATH)
d1775 1
a1775 1
      if ((n + strlen (p)) >= CYG_MAX_PATH)
d1782 1
a1782 1
      int left = CYG_MAX_PATH - n;
d1814 1
a1814 1
   {,full_}win32_path must have sufficient space (i.e. CYG_MAX_PATH bytes).  */
d2054 1
a2054 1
   posix_path must have sufficient space (i.e. CYG_MAX_PATH bytes).
d2075 2
a2076 1
  char buf[NT_MAX_PATH];
d2105 1
a2105 1
  if (src_path_len >= CYG_MAX_PATH)
d2121 2
a2122 1
  char pathbuf[CYG_MAX_PATH];
d2132 1
d2154 1
a2154 1
      if ((mi.posix_pathlen + (pathbuflen - mi.native_pathlen) + addslash) >= CYG_MAX_PATH)
a2170 1
	  char tmpbuf[CYG_MAX_PATH];
d2234 4
a2248 1
      char native_path[CYG_MAX_PATH];
d2270 1
a2270 1
      subkey.get_string ("native", native_path, sizeof (native_path), "");
d2609 4
a2612 1
  char nativetmp[CYG_MAX_PATH];
d2686 2
a2687 1
  char pathtmp[CYG_MAX_PATH];
d4049 1
a4049 1
/* getwd: standards? */
d4053 1
a4053 1
  return getcwd (buf, CYG_MAX_PATH);
d4638 1
d4641 1
a4641 1
	  posix_cwd = (const char *) alloca (NT_MAX_PATH);
d4659 1
d4675 1
a4675 1
      tocopy = (char *) alloca (NT_MAX_PATH);
@


1.473
log
@	* path.cc (cwdstuff::set): Revert error handling change in case
	DuplicateHandle fails, because it breaks Vista/Longhorn workaround.
@
text
@d1 1
a1 1
/* path.cc: path support.
d1104 2
@


1.472
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d4432 1
a4432 1
      HANDLE h, h_copy;
d4457 2
a4458 2
      /* Workaround a problem in Vista which fails in subsequent calls to
	 CreateFile with ERROR_INVALID_HANDLE if the handle in
a4464 9
      if (!DuplicateHandle (GetCurrentProcess (), h, GetCurrentProcess (),
			    &h_copy, 0, TRUE, DUPLICATE_SAME_ACCESS))
	{
	  RtlReleasePebLock ();
	  __seterrno ();
	  NtClose (h);
	  res = -1;
	  goto out;
	}
d4466 6
a4471 1
      dir = *phdl = h;
@


1.471
log
@	* cygheap.cc (cwcsdup): New function.
	(cwcsdup1): New function.
	* cygheap.h (cygheap_user::get_windows_id): New method returning PWCHAR.
	(cwcsdup): Declare.
	(cwcsdup1): Declare.
	* registry.cc (get_registry_hive_path): Use WCHAR instead of char
	throughout.
	(load_registry_hive): Ditto.
	* registry.h (get_registry_hive_path): Change declaration accordingly.
	(load_registry_hive): Ditto.
	* sec_helper.cc (cygpsid::string): New method returning PWCHAR.
	* security.h (cygpsid::string): Declare.
	* syscalls.cc (seteuid32): Convert local name var to WCHAR.
	* uinfo.cc (cygheap_user::env_userprofile): Convert local name buffers
	to WCHAR.  Call sys_wcstombs_alloc to generate puserprof buffer.

	* winsup.h: Fix comment.
	(NT_MAX_PATH): New definition for maximum internal path length.
	Use throughout where appropriate.
	* include/limits.h (PATH_MAX): Set to 4096 as on Linux.
@
text
@d422 1
a422 1
        {
d440 1
a440 1
  					 FileFsDeviceInformation);
d1999 1
a1999 1
        {
d2993 1
a2993 1
  		  win32_newpath.get_nt_native_path ());
d3010 1
a3010 1
        {
d3014 1
a3014 1
	  
d3134 1
a3134 1
  
d3184 1
a3184 1
        debug_printf ("Setting attributes failed, status = %p", status);
d3194 1
a3194 1
        debug_printf ("Setting delete dispostion failed, status = %p", status);
d3316 1
a3316 4
        {
	  debug_printf ("symlink string too long");
	  
	}
d3650 1
a3650 1
        fileattr = fbi.FileAttributes;
d3693 1
a3693 1
	        {
d3698 1
a3698 1
	        {
d3726 1
a3726 1
	  			(RtlNtStatusToDosError (status), EACCES)))
d4487 1
a4487 1
        {
d4792 1
a4792 1
  else if (!bs[0]) 
@


1.470
log
@	* string.h: Re-enable inline strcasematch and strncasematch
	implementations and rename to ascii_strcasematch/ascii_strncasematch.
	* dcrt0.cc: Replace str[n]casematch with ascii_str[n]casematch where
	applicable.
	* environ.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* hookapi.cc: Ditto.
	* path.cc: Ditto.
	* spawn.cc: Ditto.
	* strace.cc: Ditto.
	* syscalls.cc: Ditto.
	* uinfo.cc: Ditto.
	* winf.cc: Ditto.
@
text
@d2005 2
a2006 2
  char buf[PATH_MAX];
  sys_wcstombs (buf, PATH_MAX, src_path);
d4568 1
a4568 1
	  posix_cwd = (const char *) alloca (PATH_MAX);
d4601 2
a4602 2
      tocopy = (char *) alloca (PATH_MAX);
      sys_wcstombs (tocopy, PATH_MAX, win32.Buffer, win32.Length);
@


1.469
log
@	* cygheap.h (struct cwdstuff): Add dir member to store cwd handle.
	(cwdstuff::get_handle): New method.
	* path.cc (cwdstuff::set): When doit is true, always try to get
	directory handle.  Fail if duplicating handle fails.  Store handle
	in dir.  Fix potential SEGV when setting drive_length.
@
text
@d1197 3
a1199 3
	  (strcasematch (".exe", p) ||
	   strcasematch (".bat", p) ||
	   strcasematch (".com", p)))
d1565 6
a1570 6
  if (strncasematch (s, "conin$", n = 5)
      || strncasematch (s, "conout$", n = 7)
      || strncasematch (s, "nul", n = 3)
      || strncasematch (s, "aux", 3)
      || strncasematch (s, "prn", 3)
      || strncasematch (s, "con", 3))
d1572 2
a1573 1
  else if (strncasematch (s, "com", 3) || strncasematch (s, "lpt", 3))
d1579 1
a1579 1
	 || (strpbrk (s, special_chars) && !strncasematch (s, "%2f", 3));
d2894 1
a2894 1
  return strncasematch (dev, "\\Device\\Floppy", 14);
d3472 1
a3472 1
	if (strcasematch (ext_here, ex->name))
d3481 1
a3481 1
  if (strcasematch (ext_here, ".lnk"))
d4177 1
a4177 1
	  if (!c || !strcasematch (c, real_path.known_suffix))
@


1.468
log
@	* path.cc: Fix Samba version in comment.
@
text
@d4434 1
a4434 1
      HANDLE h;
a4443 12
      else
	{
	  /* TODO:
	     Check the length of the new CWD.  Windows can only handle
	     CWDs of up to MAX_PATH length, including a trailing backslash.
	     If the path is longer, it's not an error condition for Cygwin,
	     so we don't fail.  Windows on the other hand has a problem now.
	     For now, we just don't store the path in the PEB and proceed as
	     usual. */
	  if (len > MAX_PATH - (nat_cwd->Buffer[len - 1] == L'\\' ? 1 : 2))
	    goto skip_peb_storing;
	}
d4459 19
d4479 10
a4488 1
      if (nat_cwd) /* No need to set path on init. */
a4503 16
      NtClose (*phdl);
      /* Workaround a problem in Vista which fails in subsequent calls to
	 CreateFile with ERROR_INVALID_HANDLE if the handle in
	 CurrentDirectoryHandle changes without calling SetCurrentDirectory,
	 and the filename given to CreateFile is a relative path.  It looks
	 like Vista stores a copy of the CWD handle in some other undocumented
	 place.  The NtClose/DuplicateHandle reuses the original handle for
	 the copy of the new handle and the next CreateFile works.
	 Note that this is not thread-safe (yet?) */
      if (DuplicateHandle (GetCurrentProcess (), h, GetCurrentProcess (), phdl,
			   0, TRUE, DUPLICATE_SAME_ACCESS))
	NtClose (h);
      else
	*phdl = h;

skip_peb_storing:
d4555 1
a4555 1
	  if (*ptr)
@


1.467
log
@	* path.cc (fs_info::update): Fix old-style Samba test to support
	recent as well as upcoming Samba releases.
@
text
@d381 1
a381 1
/* Beginning with Samba 3.2, Samba allows to get version information using
@


1.466
log
@	* ntdll.h (struct _FILE_FS_OBJECTID_INFORMATION): Define.
	* path.cc (struct smb_extended_info): Define.
	(fs_info::update): Request object id info to get Samba information.
	Set flags according to new implementation.
	* path.h (struct fs_info): Add samba_version to status_flags.
	Implement flags() and samba_version() using IMPLEMENT_STATUS_FLAG.
@
text
@d477 6
a482 1
#define FS_IS_SAMBA TEST_GVI(flags (), \
a485 5
#define FS_IS_SAMBA_WITH_QUOTA TEST_GVI(flags (), \
			     FILE_CASE_SENSITIVE_SEARCH \
			     | FILE_CASE_PRESERVED_NAMES \
			     | FILE_PERSISTENT_ACLS \
			     | FILE_VOLUME_QUOTAS)
d511 2
a512 1
      /* Test for older Samba releases not supporting the extended info. */
d515 1
a515 1
		  && (FS_IS_SAMBA || FS_IS_SAMBA_WITH_QUOTA));
@


1.465
log
@	* autoload.cc (GetModuleFileNameExW): Replace definition of
	GetModuleFileNameExA.
	* fhandler_process.cc (format_process_maps): Change modname type to
	WCHAR.  Set buffer sizes to PATH_MAX.  Call GetModuleFileNameExW
	instead of GetModuleFileNameExA.  Call mount_info::conv_to_posix_path
	instead of cygwin_conv_to_full_posix_path.  Set posix_modname to
	modname if that call fails.
	(format_process_stat): Set cmd buffer size to NAME_MAX + 1.  Simplify
	setting cmd to process name.
	(format_process_status): Ditto.
	* path.cc (mount_info::conv_to_posix_path): Call sys_wcstombs
	correctly.
@
text
@d381 16
d406 1
d464 1
a464 1
      flags () = 0;
d468 1
a468 1
   flags () = pffai->FileSystemAttributes;
d496 24
a519 6
  is_samba (RtlEqualUnicodeString (&fsname, &testname, FALSE)
	    && (ffdi.Characteristics & FILE_REMOTE_DEVICE)
	    && (FS_IS_SAMBA || FS_IS_SAMBA_WITH_QUOTA));
  is_netapp (RtlEqualUnicodeString (&fsname, &testname, FALSE)
	     && (ffdi.Characteristics & FILE_REMOTE_DEVICE)
	     && FS_IS_NETAPP_DATAONTAP);
@


1.464
log
@Change many cygheap allocation routines to their *_abort analogs.
* cygheap.cc (cmalloc_abort): New function.
(crealloc_abort): Ditto.
(ccalloc_abort): Ditto.
@
text
@d1969 1
a1969 1
  sys_wcstombs (buf, PATH_MAX, src_path, 0);
@


1.463
log
@revert premature checkin
@
text
@d538 1
a538 1
      normalized_path = (char *) cmalloc (HEAP_STR, n);
d546 1
a546 1
get_nt_native_path (const char *path, UNICODE_STRING &upath)
d579 1
a579 1
      wide_path = (PWCHAR) cmalloc (HEAP_STR, uni_path.MaximumLength);
d4482 2
a4483 2
				     (PWCHAR) crealloc (win32.Buffer,
				     			pdir->Length + 2),
d4507 2
a4508 2
				     (PWCHAR) crealloc (win32.Buffer,
				     			upath.Length + 2),
d4534 1
a4534 1
      posix = (char *) crealloc (posix, strlen (posix_cwd) + 1);
@


1.462
log
@* dllfixdbg: Eliminate extra objcopy step.
@
text
@d546 1
a546 1
get_nt_native_path (const char *path, UNICODE_STRING& upath)
@


1.461
log
@	* external.cc (get_cygdrive_info): Make inline.
	(get_cygdrive_prefixes): Remove.
	(cygwin_internal): Call get_cygdrive_info with NULL flag parameters
	instead of get_cygdrive_prefixes.
	* path.cc (mount_info::get_cygdrive_info): Allow NULL flag parameters.
@
text
@d546 1
a546 1
get_nt_native_path (const char *path, UNICODE_STRING &upath)
@


1.460
log
@	* cygheap.h (struct cwdstuff): Drop hash member.  Drop get_hash,
	get_initial, and fixup_after_exec declarations.
	Convert win32 to UNICODE_STRING.
	(cwdstuff::get_drive): Convert win32 path in current codepage.
	(cwdstuff::set): Take native NT path.
	* ntdll.h (struct _TEB): Typedef.
	* path.cc (mount_info::conv_to_posix_path): Add variant taking
	wide char DOS paths.
	(symlink_info::posixify): Simplify concatenating cwd and relative path.
	(hash_path_name): Drop special relative path handling.
	(chdir): Drop special "drive only" handling.  Call cwdstuff::set with
	native path.
	(cwdstuff::get_hash): Remove.
	(windows_system_directory): Remove.
	(_upp): Remove.
	(get_user_proc_parms): Make inline.  Get PEB pointer by calling
	NtCurrentTeb.
	(cwdstuff::init): Simplify.
	(cwdstuff::set): Rework to handle incoming native NT path.  Workaround
	a Vista problem with CWD handle in the user process parameter block.
	(cwdstuff::get): Simplify locking.  Accommodate type change of win32.
	* shared_info.h (mount_info): Add declaration for new conv_to_posix_path
	method.
	* strfuncs.cc (sys_wcstombs): Return correct length of created
	multi-byte string.
@
text
@d2382 1
a2382 1
  if (res == ERROR_SUCCESS)
d2393 1
a2393 1
  if (res2 == ERROR_SUCCESS)
@


1.459
log
@	* ntdll.h (STATUS_END_OF_FILE): Define.
	* path.cc (symlink_info::check_shortcut): Use NT function to get file
	size.  Reintroduce checking file size before reading it.  Eliminiate
	close_it label.
	(symlink_info::check_sysfile): Check for EOF condition.
@
text
@d1950 26
d3386 1
a3386 2
	  strncpy (cvtbuf, cygheap->cwd.win32, 2);
	  strcpy (cvtbuf + 2, srcbuf);
a3895 12
  /* Fill out the hashed path name with the current working directory if
     this is not an absolute path and there is no pre-specified hash value.
     Otherwise the inodes same will differ depending on whether a file is
     referenced with an absolute value or relatively. */
  if (!hash && !isabspath_u (name))
    {
      hash = cygheap->cwd.get_hash ();
      if (name->Length == sizeof (WCHAR) && name->Buffer[0] == L'.')
	return hash;
      hash = L'\\' + (hash << 6) + (hash << 16) - hash;
    }

d3970 1
a3970 1
  const char *native_dir = path.get_win32 (), *posix_cwd = NULL;
a3973 9
      /* Check to see if path translates to something like C:.
	 If it does, append a \ to the native directory specification to
	 defeat the Windows 95 (i.e. MS-DOS) tendency of returning to
	 the last directory visited on the given drive. */
      if (isdrive (native_dir) && !native_dir[2])
	{
	  path.get_win32 ()[2] = '\\';
	  path.get_win32 ()[3] = '\0';
	}
d3995 1
a3995 1
    res = cygheap->cwd.set (native_dir, posix_cwd, doit);
d3999 2
a4000 2
  syscall_printf ("%d = chdir() cygheap->cwd.posix '%s' native '%s'", res,
		  cygheap->cwd.posix, native_dir);
d4346 1
a4346 17
/* Return the hash value for the current win32 value.
   This is used when constructing inodes. */
DWORD
cwdstuff::get_hash ()
{
  DWORD hashnow;
  cwd_lock.acquire ();
  hashnow = hash;
  cwd_lock.release ();
  return hashnow;
}

extern char windows_system_directory[];

static PRTL_USER_PROCESS_PARAMETERS _upp NO_COPY;

static PRTL_USER_PROCESS_PARAMETERS
d4349 1
a4349 12
  if (!_upp)
    {
      NTSTATUS stat;
      PROCESS_BASIC_INFORMATION pbi;
      stat = NtQueryInformationProcess (GetCurrentProcess (),
					ProcessBasicInformation,
					&pbi, sizeof pbi, NULL);
      if (!NT_SUCCESS (stat))
	api_fatal ("Can't retrieve process parameters, status %p", stat);
      _upp = pbi.PebBaseAddress->ProcessParameters;
    }
  return _upp;
a4356 1
  get_initial ();
d4358 1
a4358 2
  set (win32, posix, true);
  cwd_lock.release ();
d4361 3
a4363 3
/* Get initial cwd.  Should only be called once in a process tree. */
bool
cwdstuff::get_initial ()
d4365 4
d4371 12
a4382 2
  if (win32)
    return 1;
d4384 10
a4393 3
  /* Leaves cwd lock unreleased, if success */
  return !set (NULL, NULL, false);
}
d4395 8
a4402 8
/* Chdir and fill out the elements of a cwdstuff struct.
   It is assumed that the lock for the cwd is acquired if
   win32_cwd == NULL. */
int
cwdstuff::set (const char *win32_cwd, const char *posix_cwd, bool doit)
{
  char pathbuf[2 * CYG_MAX_PATH];
  int res = -1;
d4404 25
a4428 4
  if (win32_cwd)
    {
      cwd_lock.acquire ();
      if (doit)
d4430 5
a4434 2
	  /* We utilize the user parameter block.  The directory is
	     stored manually there.  Why the hassle?
d4436 9
a4444 17
	     - SetCurrentDirectory fails for directories with strict
	       permissions even for processes with the SE_BACKUP_NAME
	       privilege enabled.  The reason is apparently that
	       SetCurrentDirectory calls NtOpenFile without the
	       FILE_OPEN_FOR_BACKUP_INTENT flag set.

	     - Unlinking a cwd fails because SetCurrentDirectory seems to
	       open directories so that deleting the directory is disallowed.
	       The below code opens with *all* sharing flags set. */
	  HANDLE h;
	  DWORD attr = GetFileAttributes (win32_cwd);
	  if (attr == INVALID_FILE_ATTRIBUTES)
	    {
	      set_errno (ENOENT);
	      goto out;
	    }
	  if (!(attr & FILE_ATTRIBUTE_DIRECTORY))
d4446 2
a4447 2
	      set_errno (ENOTDIR);
	      goto out;
d4449 2
a4450 30
	  h = CreateFile (win32_cwd, FILE_TRAVERSE, FILE_SHARE_VALID_FLAGS,
			  &sec_none, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS,
			  NULL);
	  if (h == INVALID_HANDLE_VALUE)
	    {
	      __seterrno ();
	      goto out;
	    }
	  ULONG len = strlen (win32_cwd);
	  ANSI_STRING as = {len, len + 2, (PCHAR) alloca (len + 2)};
	  strcpy (as.Buffer, win32_cwd);
	  if (as.Buffer[len - 1] != '\\')
	    {
	      strcpy (as.Buffer + len, "\\");
	      ++as.Length;
	    }
	  RtlAcquirePebLock ();
	  if (current_codepage == ansi_cp)
	    RtlAnsiStringToUnicodeString (
			&get_user_proc_parms ()->CurrentDirectoryName,
			&as, FALSE);
	  else
	    RtlOemStringToUnicodeString (
			&get_user_proc_parms ()->CurrentDirectoryName,
			&as, FALSE);
	  PHANDLE phdl = &get_user_proc_parms ()->CurrentDirectoryHandle;
	  if (*phdl)
	    CloseHandle (*phdl);
	  *phdl = h;
	  RtlReleasePebLock ();
d4452 18
d4471 2
a4472 2
  /* If there is no win32 path or it has the form c:xxx, get the value */
  if (!win32_cwd || (isdrive (win32_cwd) && win32_cwd[2] != '\\'))
d4474 2
a4475 3
      int i;
      DWORD len, dlen;
      for (i = 0, dlen = CYG_MAX_PATH/3; i < 2; i++, dlen = len)
d4477 14
a4490 3
	  win32 = (char *) crealloc (win32, dlen);
	  if ((len = GetCurrentDirectoryA (dlen, win32)) < dlen)
	    break;
d4492 1
a4492 1
      if (len == 0)
d4494 31
a4524 4
	  __seterrno ();
	  debug_printf ("GetCurrentDirectory, %E");
	  win32_cwd = pathbuf; /* Force lock release */
	  goto out;
d4526 2
a4527 18
      posix_cwd = NULL;
    }
  else
    {
      win32 = (char *) crealloc (win32, strlen (win32_cwd) + 1);
      strcpy (win32, win32_cwd);
    }
  if (win32[1] == ':')
    drive_length = 2;
  else if (win32[1] == '\\')
    {
      char * ptr = strechr (win32 + 2, '\\');
      if (*ptr)
	ptr = strechr (ptr + 1, '\\');
      drive_length = ptr - win32;
    }
  else
    drive_length = 0;
d4529 7
a4535 4
  if (!posix_cwd)
    {
      mount_table->conv_to_posix_path (win32, pathbuf, 0);
      posix_cwd = pathbuf;
a4536 4
  posix = (char *) crealloc (posix, strlen (posix_cwd) + 1);
  strcpy (posix, posix_cwd);

  hash = hash_path_name (0, win32);
a4537 1
  res = 0;
d4539 1
a4539 2
  if (win32_cwd)
    cwd_lock.release ();
d4559 1
a4559 2
  if (!get_initial ())	/* Get initial cwd and set cwd lock */
    return NULL;
d4563 4
a4566 1
    tocopy = win32;
@


1.458
log
@	* path.cc (basename): Return pointer into the path argument itself.
	Shrink buf to 4 bytes.  Use buf only for border cases.
	(dirname): Ditto.
@
text
@d3161 1
a3161 1
  DWORD size;
d3163 1
d3165 11
a3175 2
  size = GetFileSize (h, NULL);
  buf = (char *) alloca (size + 1);
d3177 1
a3177 1
			       &io, buf, size, NULL, NULL)))
d3180 1
a3180 1
      goto close_it;
d3183 2
a3184 1
  if (io.Information != size || !cmp_shortcut_header (file_header))
d3199 1
a3199 1
      if (cp + len + 2 + relpath_len < buf + size)
d3212 1
a3212 1
  goto close_it;
d3218 1
a3218 3

close_it:
  return res;
d3226 1
d3230 3
a3232 2
  if (!NT_SUCCESS (NtReadFile (h, NULL, NULL, NULL, &io,
			       cookie_buf, sizeof (cookie_buf), NULL, NULL)))
d3235 2
a3236 1
      set_error (EIO);
d3244 3
a3246 2
      if (!NT_SUCCESS (NtReadFile (h, NULL, NULL, NULL, &io,
				   srcbuf, SYMLINK_MAX + 2, NULL, NULL)))
d3249 2
a3250 1
	  set_error (EIO);
d3255 1
a3255 1
	  set_error (EIO);
@


1.457
log
@	* path.cc (struct symlink_info): Change size of contents member to
	be able to keep SYMLINK_MAX sized strings.
	(symlink_worker): Rework for long path names.  When writing windows
	shortcuts, store pathname additionally "hidden" after the actual
	shortcut data to workaround size limitations of the description field.
	(symlink_info::check_shortcut): Drop file name parameter.  Drop max
	file size check.  Use NT functions.  Use appended full path if
	available, description otherwise.  Check symlink string length for
	not exceeding SYMLINK_MAX.  Don't close file here.
	(symlink_info::check_sysfile): Drop file name parameter.  Use NT
	functions.  Check symlink string length for not exceeding SYMLINK_MAX.
	Don't close file here.
	(symlink_info::check_reparse_point): Drop file name parameter.  Drop
	useless length checks.  Allow SYMLINK_MAX length symlink strings.
	Don't close file here.
	(symlink_info::posixify): Allow SYMLINK_MAX length symlink strings.
	(symlink_info::check): Turn around checking for symlink file attributes.
	Use NT functions.  Close symlink file here.
	* include/limits.h (PATH_MAX): Define as 32760.  Change comment.
	(SYMLINK_MAX): Define as PATH_MAX - 1.
@
text
@d4697 2
a4698 2
  static char buf[CYG_MAX_PATH];
  char *c, *d, *bs = buf;
d4702 1
a4702 2
  strncpy (buf, path, CYG_MAX_PATH);
  if (isalpha (buf[0]) && buf[1] == ':')
d4704 1
a4704 1
  else if (strspn (buf, "/\\") > 1)
d4722 7
a4728 3
  else if (!bs[0])
    strcpy (bs, ".");
  return buf;
d4738 2
a4739 2
  static char buf[CYG_MAX_PATH];
  char *c, *d, *bs = buf;
d4743 1
a4743 2
  strncpy (buf, path, CYG_MAX_PATH);
  if (isalpha (buf[0]) && buf[1] == ':')
d4745 1
a4745 1
  else if (strspn (buf, "/\\") > 1)
d4772 6
a4777 2
    strcpy (bs, ".");
  return buf;
@


1.456
log
@	* path.cc (symlink_info::check): Check for STATUS_OBJECT_NAME_INVALID.
	Add comment.
@
text
@d92 1
a92 1
  char contents[CYG_MAX_PATH + 4];
d109 3
a111 3
  int check_sysfile (const char *path, HANDLE h);
  int check_shortcut (const char *path, HANDLE h);
  int check_reparse_point (const char *path, HANDLE h);
a2876 1
  HANDLE h;
d2878 3
a2880 6
  path_conv win32_path, win32_oldpath;
  char from[CYG_MAX_PATH + 5];
  char cwd[CYG_MAX_PATH], *cp = NULL, c = 0;
  char w32oldpath[CYG_MAX_PATH];
  char reloldpath[CYG_MAX_PATH] = { 0 };
  DWORD written;
d2883 5
d2901 1
a2901 1
  if (strlen (oldpath) >= CYG_MAX_PATH)
d2907 10
a2916 3
  win32_path.check (newpath, PC_SYM_NOFOLLOW,
		    transparent_exe ? stat_suffixes : NULL);
  if (use_winsym && !win32_path.exists ())
d2918 3
a2920 3
      strcpy (from, newpath);
      strcat (from, ".lnk");
      win32_path.check (from, PC_SYM_NOFOLLOW);
d2923 1
a2923 1
  if (win32_path.error)
d2925 1
a2925 1
      set_errno (win32_path.case_clash ? ECASECLASH : win32_path.error);
d2929 2
a2930 1
  syscall_printf ("symlink (%s, %s)", oldpath, win32_path.get_win32 ());
d2932 2
a2933 2
  if ((!isdevice && win32_path.exists ())
      || win32_path.is_auto_device ())
d2939 1
a2939 4
  DWORD create_how;
  if (!use_winsym)
    create_how = CREATE_NEW;
  else if (isdevice)
d2941 15
a2955 10
      strcpy (w32oldpath, oldpath);
      create_how = CREATE_ALWAYS;
      SetFileAttributes (win32_path.get_win32 (), FILE_ATTRIBUTE_NORMAL);
    }
  else
    {
      if (!isabspath (oldpath))
	{
	  getcwd (cwd, CYG_MAX_PATH);
	  if ((cp = strrchr (from, '/')) || (cp = strrchr (from, '\\')))
d2957 6
a2962 3
	      c = *cp;
	      *cp = '\0';
	      chdir (from);
d2964 3
a2966 6
	  backslashify (oldpath, reloldpath, 0);
	  /* Creating an ITEMIDLIST requires an absolute path.  So if we
	     create a shortcut file, we create relative and absolute Win32
	     paths, the first for the relpath field and the latter for the
	     ITEMIDLIST field. */
	  if (GetFileAttributes (reloldpath) == INVALID_FILE_ATTRIBUTES)
d2968 16
a2983 28
	      win32_oldpath.check (oldpath, PC_SYM_NOFOLLOW,
				   transparent_exe ? stat_suffixes : NULL);
	      if (win32_oldpath.error != ENOENT)
		strcpy (use_winsym ? reloldpath : w32oldpath,
			win32_oldpath.get_win32 ());
	    }
	  else if (!use_winsym)
	    strcpy (w32oldpath, reloldpath);
	  if (use_winsym)
	    {
	      win32_oldpath.check (oldpath, PC_SYM_NOFOLLOW,
				   transparent_exe ? stat_suffixes : NULL);
	      strcpy (w32oldpath, win32_oldpath.get_win32 ());
	    }
	  if (cp)
	    {
	      *cp = c;
	      chdir (cwd);
	    }
	}
      else
	{
	  win32_oldpath.check (oldpath, PC_SYM_NOFOLLOW,
			       transparent_exe ? stat_suffixes : NULL);
	  strcpy (w32oldpath, win32_oldpath.get_win32 ());
	}
      create_how = CREATE_NEW;
    }
a2984 41
  if (allow_ntsec && win32_path.has_acls ())
    set_security_attribute (S_IFLNK | STD_RBITS | STD_WBITS,
			    &sa, sd);

  h = CreateFile (win32_path.get_win32 (), GENERIC_WRITE, 0, &sa, create_how,
		  FILE_ATTRIBUTE_NORMAL, 0);
  if (h == INVALID_HANDLE_VALUE)
    __seterrno ();
  else
    {
      bool success = false;

      if (use_winsym)
	{
	  /* A path of 240 chars with 120 one character directories in it
	     can result in a 6K shortcut. */
	  char *buf = (char *) alloca (8192);
	  win_shortcut_hdr *shortcut_header = (win_shortcut_hdr *) buf;
	  HRESULT hres;
	  IShellFolder *psl;
	  WCHAR wc_path[CYG_MAX_PATH];
	  ITEMIDLIST *pidl = NULL, *p;
	  unsigned short len;

	  memset (shortcut_header, 0, sizeof *shortcut_header);
	  shortcut_header->size = sizeof *shortcut_header;
	  shortcut_header->magic = GUID_shortcut;
	  shortcut_header->flags = (WSH_FLAG_DESC | WSH_FLAG_RELPATH);
	  shortcut_header->run = SW_NORMAL;
	  cp = buf + sizeof (win_shortcut_hdr);
	  /* Creating an IDLIST */
	  hres = SHGetDesktopFolder (&psl);
	  if (SUCCEEDED (hres))
	    {
	      MultiByteToWideChar (CP_ACP, 0, w32oldpath, -1, wc_path,
				   CYG_MAX_PATH);
	      hres = psl->ParseDisplayName (NULL, NULL, wc_path, NULL,
					    &pidl, NULL);
	      if (SUCCEEDED (hres))
		{
		  shortcut_header->flags |= WSH_FLAG_IDLIST;
d2988 1
a2988 5
		  len = (char *) p - (char *) pidl + 2;
		  *(unsigned short *)cp = len;
		  memcpy (cp += 2, pidl, len);
		  cp += len;
		  CoTaskMemFree (pidl);
a2991 18
	  /* Creating a description */
	  *(unsigned short *)cp = len = strlen (oldpath);
	  memcpy (cp += 2, oldpath, len);
	  cp += len;
	  /* Creating a relpath */
	  if (reloldpath[0])
	    {
	      *(unsigned short *)cp = len = strlen (reloldpath);
	      memcpy (cp += 2, reloldpath, len);
	    }
	  else
	    {
	      *(unsigned short *)cp = len = strlen (w32oldpath);
	      memcpy (cp += 2, w32oldpath, len);
	    }
	  cp += len;
	  success = WriteFile (h, buf, cp - buf, &written, NULL)
		    && written == (DWORD) (cp - buf);
d2993 22
a3014 1
      else
d3016 2
a3017 10
	  /* This is the old technique creating a symlink. */
	  char buf[sizeof (SYMLINK_COOKIE) + CYG_MAX_PATH + 10];

	  __small_sprintf (buf, "%s%s", SYMLINK_COOKIE, oldpath);
	  DWORD len = strlen (buf) + 1;

	  /* Note that the terminating nul is written.  */
	  success = WriteFile (h, buf, len, &written, NULL)
		    || written != len;

d3019 1
a3019 1
      if (success)
d3021 68
a3088 8
	  CloseHandle (h);
	  DWORD attr = use_winsym ? FILE_ATTRIBUTE_READONLY
				  : FILE_ATTRIBUTE_SYSTEM;
	  SetFileAttributes (win32_path.get_win32 (), attr);

	  res = 0;
	}
      else
d3090 2
a3091 3
	  __seterrno ();
	  CloseHandle (h);
	  DeleteFileA (win32_path.get_win32 ());
d3094 40
d3155 1
a3155 1
symlink_info::check_shortcut (const char *path, HANDLE h)
d3161 2
a3162 1
  DWORD size, got = 0;
d3164 1
a3164 2
  if ((size = GetFileSize (h, NULL)) > 8192) /* Not a Cygwin symlink. */
    goto file_not_symlink;
d3166 2
a3167 1
  if (!ReadFile (h, buf, size, &got, 0))
d3173 1
a3173 1
  if (got != size || !cmp_shortcut_header (file_header))
d3178 1
a3178 1
  if ((len = *(unsigned short *) cp) == 0 || len >= CYG_MAX_PATH)
a3180 1
  cp[len] = '\0';
d3183 1
a3183 1
    res = strlen (strcpy (contents, cp)); /* Don't try to mess with device files */
d3185 14
a3198 1
    res = posixify (cp);
d3205 1
a3205 1
  if (!(pflags & PATH_ALL_EXEC) && has_exec_chars ((const char *) &file_header, got))
a3208 1
  CloseHandle (h);
d3213 1
a3213 1
symlink_info::check_sysfile (const char *path, HANDLE h)
d3216 2
a3217 2
  char srcbuf[CYG_MAX_PATH];
  DWORD got;
d3220 2
a3221 1
  if (!ReadFile (h, cookie_buf, sizeof (cookie_buf), &got, 0))
d3226 1
a3226 1
  else if (got == sizeof (cookie_buf)
d3232 2
a3233 2
      res = ReadFile (h, srcbuf, CYG_MAX_PATH, &got, 0);
      if (!res)
d3238 5
d3246 1
a3246 1
  else if (got == sizeof (cookie_buf)
d3254 1
a3254 1
      else if (has_exec_chars (cookie_buf, got))
a3258 4
  syscall_printf ("%d = symlink.check_sysfile (%s, %s) (%p)",
		  res, path, contents, pflags);

  CloseHandle (h);
d3263 1
a3263 1
symlink_info::check_reparse_point (const char *path, HANDLE h)
a3264 1
  int res = 0;
d3268 1
a3268 1
  char srcbuf[CYG_MAX_PATH + 6];
d3275 1
a3275 1
      goto close_it;
d3279 1
a3279 8
      if (rp->SymbolicLinkReparseBuffer.SubstituteNameLength
	  > 2 * (CYG_MAX_PATH + 6))
	{
	  debug_printf ("Symlink name too long");
	  set_error (EIO);
	  goto close_it;
	}
      sys_wcstombs (srcbuf, CYG_MAX_PATH,
d3291 1
a3291 1
	  goto close_it;
d3293 1
a3293 8
      if (rp->MountPointReparseBuffer.SubstituteNameLength
	  > 2 * (CYG_MAX_PATH + 6))
	{
	  debug_printf ("Symlink name too long");
	  set_error (EIO);
	  goto close_it;
	}
      sys_wcstombs (srcbuf, CYG_MAX_PATH,
d3300 1
a3300 4
  res = posixify (srcbuf);
close_it:
  CloseHandle (h);
  return res;
d3344 1
a3344 1
	  char cvtbuf[CYG_MAX_PATH + 6];
d3571 1
a3608 1
	      IO_STATUS_BLOCK io;
d3671 4
a3674 3
      /* Reparse points are potentially symlinks. */
      if (fileattr & FILE_ATTRIBUTE_REPARSE_POINT)
	sym_check = 3;
d3682 3
a3684 4
      /* Windows shortcuts are potentially treated as symlinks. */
      /* Valid Cygwin & U/WIN shortcuts are R/O. */
      else if ((fileattr & FILE_ATTRIBUTE_READONLY) && suffix.lnk_match ())
	sym_check = 1;
d3689 2
d3692 6
a3697 8

      h = CreateFile (suffix.path, GENERIC_READ, FILE_SHARE_READ,
		      &sec_none_nih, OPEN_EXISTING,
		      sym_check == 3 ? FILE_FLAG_OPEN_REPARSE_POINT
				       | FILE_FLAG_BACKUP_SEMANTICS
				     : FILE_ATTRIBUTE_NORMAL, 0);
      res = -1;
      if (h == INVALID_HANDLE_VALUE)
d3703 2
a3704 1
	  res = check_shortcut (suffix.path, h);
d3719 2
a3720 1
	  res = check_sysfile (suffix.path, h);
d3725 2
a3726 1
	  res = check_reparse_point (suffix.path, h);
@


1.455
log
@	* ntdll.h (STATUS_NO_SUCH_FILE): Define.
	* path.cc (get_nt_native_path): Reset upath.Length to 0 on each
	invocation.
	(symlink_info::check): Use NT native functions.
@
text
@d3538 12
a3549 2
	  /* One of the inner path components is invalid.  Bail out. */
	  if (status == STATUS_OBJECT_PATH_NOT_FOUND)
@


1.454
log
@	* ntdll.h (NtNotifyChangeDirectoryFile): Declare.
	(NtQueryAttributesFile): Move to maintain alphabetical order of
	declarations.  Add comment to note that timestamp information returned
	by NtQueryAttributesFile is unreliable.
	* path.h (etc::changed_h): Move here.
	(etc::fn): Change type to OBJECT_ATTRIBUTES.
	(etc::last_modified): Change type to LARGE_INTEGER.
	(etc::init): Take PUNICODE_STRING as second argument.
	* path.cc: Accomodate above changes.
	(etc::test_file_change): Use NT native functions.
	(etc::dir_changed): Ditto.
	* uinfo.cc (pwdgrp::load): Call etc::init with NT native path.
@
text
@d548 1
d3515 8
d3525 3
d3529 5
a3533 2
      fileattr = GetFileAttributes (suffix.path);
      if (fileattr == INVALID_FILE_ATTRIBUTES)
d3535 11
a3545 19
	  /* The GetFileAttributes call can fail for reasons that don't
	     matter, so we just return 0.  For example, getting the
	     attributes of \\HOST will typically fail.  */
	  debug_printf ("GetFileAttributes (%s) failed", suffix.path);

	  /* The above comment is not *quite* right.  When calling
	     GetFileAttributes for a non-existant file an a Win9x share,
	     GetLastError returns ERROR_INVALID_FUNCTION.  Go figure!
	     Also, GetFileAttributes fails with ERROR_SHARING_VIOLATION
	     if the file is locked exclusively by another process, or with
	     ERROR_ACCESS_DENIED if the file exists but the user has no right
	     to open the file with FILE_READ_ATTRIBUTES.
	     If we don't special handle this here, the file is accidentally
	     treated as non-existant. */
	  DWORD win_error = GetLastError ();
	  if (win_error == ERROR_INVALID_FUNCTION)
	    win_error = ERROR_FILE_NOT_FOUND;
	  else if (win_error == ERROR_SHARING_VIOLATION
		   || win_error == ERROR_ACCESS_DENIED)
d3547 22
a3568 8
	      /* This is easily converted to NT functions at one point,
	         see fhandler_base::fstat_by_name. */
	      WIN32_FIND_DATA data;
	      HANDLE f = FindFirstFile (suffix.path, &data);
	      if (f != INVALID_HANDLE_VALUE)
		{
		  FindClose (f);
		  fileattr = data.dwFileAttributes;
d3571 24
a3594 1
		fileattr = 0;
d3598 2
a3599 1
	  if (set_error (geterrno_from_win_error (win_error, EACCES)))
@


1.453
log
@	* path.cc (fillout_mntent): Append backslash to drive-only paths before
	calling fs_info::update.
	* path.h (fs_info::clear): Simplify.
	(fs_info::fs_info): Add constructor.
@
text
@d4459 2
a4460 2
const char *etc::fn[MAX_ETC_FILES + 1];
FILETIME etc::last_modified[MAX_ETC_FILES + 1];
d4463 1
a4463 1
etc::init (int n, const char *etc_fn)
d4472 1
a4472 1
  fn[n] = etc_fn;
d4475 1
a4475 1
  paranoid_printf ("fn[%d] %s, curr_ix %d", n, fn[n], curr_ix);
d4482 2
a4483 2
  HANDLE h;
  WIN32_FIND_DATA data;
d4486 2
a4487 1
  if ((h = FindFirstFile (fn[n], &data)) == INVALID_HANDLE_VALUE)
d4491 2
a4492 1
      debug_printf ("FindFirstFile failed, %E");
d4496 3
a4498 4
      FindClose (h);
      res = CompareFileTime (&data.ftLastWriteTime, last_modified + n) > 0;
      last_modified[n] = data.ftLastWriteTime;
      debug_printf ("FindFirstFile succeeded");
d4501 1
a4501 1
  paranoid_printf ("fn[%d] %s res %d", n, fn[n], res);
d4511 2
d4516 23
a4538 4
	  path_conv pwd ("/etc");
	  changed_h = FindFirstChangeNotification (pwd.get_win32 (), FALSE,
						  FILE_NOTIFY_CHANGE_LAST_WRITE
						  | FILE_NOTIFY_CHANGE_FILE_NAME);
d4540 2
a4541 2
	  if (changed_h == INVALID_HANDLE_VALUE)
	    system_printf ("Can't open %s for checking, %E", (char *) pwd);
d4543 4
d4554 14
a4567 1
	  FindNextChangeNotification (changed_h);
d4572 2
a4573 1
  paranoid_printf ("fn[%d] %s change_possible %d", n, fn[n], change_possible[n]);
d4584 1
a4584 1
  paranoid_printf ("fn[%d] %s res %d", n, fn[n], res);
@


1.452
log
@	* path.h (path_conv::operator char *): Delete.
	(path_conv::operator const char *): Delete.
	* dlfcn.cc: Throughout, replace path_conv::operator char * and
	path_conv::operator const char * by call to path_conv::get_win32
	for easier transition to UNICODE_PATHs.
	* fhandler_socket.cc: Ditto.
	* hookapi.cc: Ditto.
	* path.cc: Ditto.
	* spawn.cc: Ditto.
	* syscalls.cc: Ditto.
	* uinfo.cc: Ditto.
@
text
@d2599 1
d2607 1
d2630 2
@


1.451
log
@	* ntdll.h (RtlAcquirePebLock): Declare.
	(RtlReleasePebLock): Declare.
	* path.cc (cwdstuff::set): Change PEB only while it's locked.
@
text
@d2932 1
a2932 1
      SetFileAttributes (win32_path, FILE_ATTRIBUTE_NORMAL);
d2955 2
a2956 1
		strcpy (use_winsym ? reloldpath : w32oldpath, win32_oldpath);
d2964 1
a2964 1
	      strcpy (w32oldpath, win32_oldpath);
d2976 1
a2976 1
	  strcpy (w32oldpath, win32_oldpath);
d2985 1
a2985 1
  h = CreateFile (win32_path, GENERIC_WRITE, 0, &sa, create_how,
d3070 1
a3070 1
	  SetFileAttributes (win32_path, attr);
a3762 1
hashit:
d3837 1
a3837 1
  const char *native_dir = path, *posix_cwd = NULL;
d3921 2
a3922 1
  strcpy (win32_path, strcmp ((char *) p, ".\\") == 0 ? "." : (char *) p);
d3937 1
a3937 1
  strcpy (win32_path, p);
d4510 1
a4510 1
	  changed_h = FindFirstChangeNotification (pwd, FALSE,
@


1.450
log
@	* ntdll.h (RtlCreateUnicodeStringFromAsciiz): Fix declaration.
	(RtlUpcaseUnicodeChar): Declare.
	* path.cc (hash_path_name): Split into three functions, taking
	the path as char *, PWCSTR, or PUNICODE_STRING.  Move implementation
	into PUNICODE_STRING-based function.  Drop old drive-relative path
	consideration.
	* winsup.h (iswdirsep): Like isdirsep but for WCHARs.
	(isabspath_u): Like isabspath, for PUNICODE_STRINGs.
	(iswabspath): Like isabspath, for PWCHARs.
	(hash_path_name): Add new declarations.
@
text
@d4332 1
d4343 3
a4345 5
	    {
	      HANDLE old_h = *phdl;
	      *phdl = h;
	      CloseHandle (old_h);
	    }
@


1.449
log
@	* path.cc (get_nt_native_path): Allow to convert special paths which
	have no native NT path representation for simplified debug output.
	* syscalls.cc: Convert debug output to print native NT path.
	(unlink): Drop redundant debug output.
@
text
@d83 1
a3743 1

d3745 1
a3745 1
hash_path_name (__ino64_t hash, const char *name)
d3747 1
a3747 1
  if (!*name)
d3750 10
a3759 36
  /* Perform some initial permutations on the pathname if this is
     not "seeded" */
  if (!hash)
    {
      /* Simplistic handling of drives.  If there is a drive specified,
	 make sure that the initial letter is upper case.  If there is
	 no \ after the ':' assume access through the root directory
	 of that drive.
	 FIXME:  Should really honor MS-Windows convention of using
	 the environment to track current directory on various drives. */
      if (name[1] == ':')
	{
	  char *nn, *newname = (char *) alloca (strlen (name) + 2);
	  nn = newname;
	  *nn = isupper (*name) ? cyg_tolower (*name) : *name;
	  *++nn = ':';
	  name += 2;
	  if (*name != '\\')
	    *++nn = '\\';
	  strcpy (++nn, name);
	  name = newname;
	  goto hashit;
	}

      /* Fill out the hashed path name with the current working directory if
	 this is not an absolute path and there is no pre-specified hash value.
	 Otherwise the inodes same will differ depending on whether a file is
	 referenced with an absolute value or relatively. */

      if (!hash && !isabspath (name))
	{
	  hash = cygheap->cwd.get_hash ();
	  if (name[0] == '.' && name[1] == '\0')
	    return hash;
	  hash = '\\' + (hash << 6) + (hash << 16) - hash;
	}
d3764 4
a3767 6
  do
    {
      int ch = cyg_tolower (*name);
      hash = ch + (hash << 6) + (hash << 16) - hash;
    }
  while (*++name != '\0');
d3771 18
@


1.448
log
@	* path.cc (symlink_info::check): In case of ERROR_SHARING_VIOLATION and
	ERROR_ACCESS_DENIED, try to get file attributes by using directory
	functions.
@
text
@d547 3
a549 1
  if (path[0] != '\\')			/* X:\...  or NUL, etc. */
d554 1
a554 1
  else if (path[1] != '\\')		/* \Device\... */
d557 1
a557 1
	   || path[3] != '\\')		/* \\server\share\... */
d562 1
a562 1
  else					/* \\.\device or \\?\foo */
@


1.447
log
@	* path.cc (fs_info::update): Correctly handle the volume root directory.
@
text
@d3521 3
a3523 1
	     if the file is locked exclusively by another process.
d3529 2
a3530 1
	  else if (win_error == ERROR_SHARING_VIOLATION)
d3532 11
a3543 1
	      fileattr = 0;
@


1.446
log
@	* fhandler.h (fhandler_base::pc): Make public.
	* fhandler_disk_file.cc (fhandler_disk_file::link): Drop extern
	declaration of stat_suffixes.  Use NT native path in debug output.
	(fhandler_base::utimes_fs): Simplify closeit case.  Use close_fs
	to close newly opened file handle.
	(fhandler_base::open_fs): Use NT native path in debug output.
	* path.cc: Throughout drop extern declaration of stat_suffixes.
	* path.h (stat_suffixes): Declare.
	* sec_acl.cc (acl_worker): Drop extern declaration of stat_suffixes.
	* times.cc (utimes_worker): Take path_conv as parameter instead of
	single-byte pathnam, drop nofollow argument, accommodate throughout.
	Compare UNICODE paths when enumerating file descriptors.  Fix
	formatting.  Use NT native path in debug output.
@
text
@d396 3
a398 1
  while (!NT_SUCCESS (status) && attr.ObjectName->Length > 6 * sizeof (WCHAR))
a401 1
      dir.Length -= sizeof (WCHAR);
d408 2
@


1.445
log
@	* devices.in (dev_storage): Use native NT device name for kmsg mailslot.
	* devices.cc: Regenerate.
	* fhandler.cc (fhandler_base::operator =): Use path_conv assignment
	operator.
	(fhandler_base::set_name): Ditto.
	(fhandler_base::open): Use NT native path in debug output.
	* fhandler_mailslot.cc: Convert to NT native function calls.
	* ntdll.h (struct _FILE_MAILSLOT_SET_INFORMATION): Define.
	(NtCreateMailslotFile): Declare.
	* path.cc (path_conv::set_normalized_path): Don't set wide_path to NULL.
	(path_conv::set_name): Remove unused function.
	* path.h (path_conv::set_name): Drop declaration.
	(path_conv::operator =): Define.
@
text
@a2865 2
  extern suffix_info stat_suffixes[];

a3682 2
  extern suffix_info stat_suffixes[];

a3966 2
  extern suffix_info stat_suffixes[];

@


1.444
log
@	* fhandler.cc (fhandler_base::open): Remove HIDDEN_DOT_FILES code.
	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Ditto.
	* path.cc (symlink_worker): Ditto.
@
text
@a538 1
  wide_path = NULL;
a1179 9
void
path_conv::set_name (const char *win32, const char *posix)
{
  if (!normalized_path_size && normalized_path)
    cfree (normalized_path);
  strcpy (path, win32);
  set_normalized_path (posix, false);
}

@


1.443
log
@	* path.cc (fillout_mntent): Fix calculation of unicode buffer size.
@
text
@a3074 5
#ifdef HIDDEN_DOT_FILES
	  cp = strrchr (win32_path, '\\');
	  if ((cp && cp[1] == '.') || *win32_path == '.')
	    attr |= FILE_ATTRIBUTE_HIDDEN;
#endif
@


1.442
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Drop
	usage of path_conv::volser().
	(fhandler_base::fstat_by_name): Ditto.
	* ntdll.h (STATUS_NO_MEDIA_IN_DEVICE): Define.
	(STATUS_OBJECT_NAME_NOT_FOUND): Define.
	(FILE_REMOVABLE_MEDIA, FILE_READ_ONLY_DEVICE, FILE_FLOPPY_DISKETTE)
	(FILE_WRITE_ONCE_MEDIA, FILE_REMOTE_DEVICE, FILE_DEVICE_IS_MOUNTED)
	(FILE_VIRTUAL_VOLUME, FILE_AUTOGENERATED_DEVICE_NAME)
	FILE_DEVICE_SECURE_OPEN): Define Device Characteristics.
	(struct _FILE_FS_DEVICE_INFORMATION): Define.
	* path.cc (MAX_FS_INFO_CNT): Remove.
	(fsinfo): Remove.
	(fsinfo_cnt): Remove.
	(fs_info::update): Rewrite using native NT functions.  Drop fs_info
	cashing since it's incorrect.
	(path_conv::fillin): Use NtQueryInformationFile.  Drop setting serial
	number.
	(path_conv::check): Accommodate new fs_info::update parameters.
	(fillout_mntent): Ditto.
	* path.h (fs_info): Drop serial, has_ea and drive_type status
	flags.
	(fs_info::update): Declare with new parameters.
	(path_conf::drive_type): Remove.
	(path_conf::fs_has_ea): Remove.
	(path_conf::volser): Remove.
@
text
@d2628 2
a2629 1
  size_t size = (strlen (native_path) + 1) * sizeof (WCHAR);
@


1.441
log
@	* fhandler_disk_file.cc (fhandler_disk_file::link): Revert to checking
	for binary in case of .exe files.
	* ntdll.h (RtlPrefixUnicodeString): Declare.
	* path.cc (path_conv::is_binary): New method.
	* path.h (path_conv::is_binary): Declare.
	* syscalls.cc (rename_append_suffix): New static helper function for
	rename.
	(rename): Rewrite.  New suffix tests.  Use native NT functions.
@
text
@a379 4
#define MAX_FS_INFO_CNT 25
fs_info fsinfo[MAX_FS_INFO_CNT];
LONG fsinfo_cnt;

d381 1
a381 1
fs_info::update (const char *win32_path)
d383 28
a410 5
  char fsname [CYG_MAX_PATH];
  char root_dir [CYG_MAX_PATH];
  bool ret;

  if (!::rootdir (win32_path, root_dir))
d412 2
a413 1
      debug_printf ("Cannot get root component of path %s", win32_path);
d415 1
d418 8
a425 22

  __ino64_t tmp_name_hash = hash_path_name (1, root_dir);
  if (tmp_name_hash == name_hash)
    return true;
  int idx = 0;
  LONG cur_fsinfo_cnt = fsinfo_cnt;
  while (idx < cur_fsinfo_cnt && fsinfo[idx].name_hash)
    {
      if (tmp_name_hash == fsinfo[idx].name_hash)
	{
	  *this = fsinfo[idx];
	  return true;
	}
      ++idx;
    }
  name_hash = tmp_name_hash;
  root_len = strlen (root_dir);

  drive_type (GetDriveType (root_dir));
  if (drive_type () == DRIVE_REMOTE
      || (drive_type () == DRIVE_UNKNOWN
	  && (root_dir[0] == '\\' && root_dir[1] == '\\')))
d430 9
a438 4
  ret = GetVolumeInformation (root_dir, NULL, 0, &status.serial, NULL,
			      &status.flags, fsname, sizeof (fsname));

  if (!ret && !is_remote_drive ())
d440 2
a441 1
      debug_printf ("Cannot get volume information (%s), %E", root_dir);
d443 2
a444 2
      has_ea (false);
      flags () = serial () = 0;
d447 1
a447 1

d471 6
a476 2
  is_fat (strncasematch (fsname, "FAT", 3));
  is_samba (strcmp (fsname, "NTFS") == 0 && is_remote_drive ()
d478 2
a479 1
  is_netapp (strcmp (fsname, "NTFS") == 0 && is_remote_drive ()
d481 5
a485 3
  is_ntfs (strcmp (fsname, "NTFS") == 0 && !is_samba () && !is_netapp ());
  is_nfs (strcmp (fsname, "NFS") == 0);
  is_cdrom (drive_type () == DRIVE_CDROM);
a486 1
  has_ea (is_ntfs ());
d489 1
a489 3
  hasgood_inode (((flags () & FILE_PERSISTENT_ACLS)
		  && drive_type () != DRIVE_UNKNOWN
		  && !is_netapp ())
d493 2
a494 1
  has_buggy_open (!strcmp (fsname, "SUNWNFS"));
d496 1
a496 19
  /* Only append non-removable drives to the global fsinfo storage */
  if (drive_type () != DRIVE_REMOVABLE && !is_cdrom () && idx < MAX_FS_INFO_CNT)
    {
      LONG exc_cnt;
      while ((exc_cnt = InterlockedExchange (&fsinfo_cnt, -1)) == -1)
	low_priority_sleep (0);
      if (exc_cnt < MAX_FS_INFO_CNT)
	{
	  /* Check if another thread has already appended that very drive */
	  while (idx < exc_cnt)
	    {
	      if (fsinfo[idx++].name_hash == name_hash)
		goto done;
	    }
	  fsinfo[exc_cnt++] = *this;
	}
     done:
      InterlockedExchange (&fsinfo_cnt, exc_cnt);
    }
d503 6
a508 6
  BY_HANDLE_FILE_INFORMATION local;
  if (!GetFileInformationByHandle (h, &local))
    {
      fileattr = INVALID_FILE_ATTRIBUTES;
      fs.serial () = 0;
    }
d510 1
a510 5
    {
      fileattr = local.dwFileAttributes;
      fs.serial () = local.dwVolumeSerialNumber;
    }
    fs.drive_type (DRIVE_UNKNOWN);
d1110 1
a1110 1
      if (fs.update (path))
d2627 5
a2631 1
  mntinfo.update (native_path);  /* this pulls from a cache, usually. */
@


1.440
log
@	* dir.cc (readdir_worker): Drop dir parameter from call to
	readdir_get_ino.
	* fhandler.h (fhandler_disk_file::readdir_helper): Switch file name
	parameter to PUNICODE_STRING.
	* fhandler_disk_file.cc: Drop including ntdef.h.
	(class __DIR_mounts): Store mount points in UNICODE.  Additionally
	store cygdrive prefix in unicode here.  Change methods accordingly.
	(__DIR_mounts::eval_ino): Call new stat_worker instead of lstat64.
	(__DIR_mounts::~__DIR_mounts): New destructor to free UNICODE buffers.
	(path_conv::ndisk_links): Rewrite using native NT functions.
	(fhandler_base::fstat_by_handle): Use NAME_MAX instead of CYG_MAX_PATH.
	Always set pfvi->VolumeSerialNumber to non-0.  Remove last resort
	code.
	(fhandler_base::fstat_by_name): Rewrite using native NT functions.
	(fhandler_base::fstat_fs): Always call fstat_by_name if fstat_by_handle
	fails.
	(fhandler_base::fstat_helper): Rely on dwVolumeSerialNumber.
	(fhandler_disk_file::facl): Call fstat_by_name if fstat_by_handle fails.
	(DIR_BUF_SIZE): Define using NAME_MAX instead of CYG_MAX_PATH.
	(__DIR_cache): Remove __name.
	(d_dirname): Remove.
	(fhandler_disk_file::opendir): Drop pathname length check.
	Remove outdated comment.  Use get_name method instead of accessing
	pc.normalized_path directly.
	(readdir_get_ino): Drop unused dir parameter.  Accomodate throughout.
	Allocate fname dynamically.  Call new stat_worker instead of lstat64.
	Call NtOpenFile instead of CreateFile.  Call NtClose instead of
	CloseHandle.
	(fhandler_disk_file::readdir_helper): Use native NT functions.
	Check for volume mount points and use correct inode number.
	(fhandler_disk_file::readdir): Simplify slightly.
	Use get_name instead of pc.normalized_path.
	(fhandler_disk_file::rewinddir): Use RtlInitUnicodeString.
	(fhandler_cygdrive::fstat): Ignore floppy drives.  Set st_nlink
	correctly.
	(fhandler_cygdrive::readdir): Ignore floppy drives.
	* fhandler_netdrive.cc (fhandler_netdrive::readdir): Accommodate
	change to readdir_get_ino.
	* fhandler_proc.cc (PROC_DIR_COUNT): Define.
	(fhandler_proc::fstat): Evaluate correct link count for /proc.
	* ntdll.h (struct _FILE_DIRECTORY_INFORMATION): Define.
	(NtFsControlFile): Declare.
	(RtlAppendUnicodeToString): Declare.
	(RtlAppendUnicodeStringToString): Declare.
	(RtlCompareUnicodeString): Declare.
	(RtlCopyUnicodeString): Declare.
	(RtlCreateUnicodeStringFromAsciiz): Declare.
	(RtlEqualUnicodeString): Declare.
	(RtlFreeUnicodeString): Declare.
	(RtlInitEmptyUnicodeString): Declare.
	(RtlSecondsSince1970ToTime): Declare.
	(RtlInitEmptyUnicodeString): Define as inline function.
	(RtlInitCountedUnicodeString): Define as inline function.
	* path.cc (path_conv::check): New method with PUNICODE_STRING as path,
	preliminary implementation.
	(mount_info::get_mounts_here): Change to create UNICODE_STRINGs.
	Also copy cygpath prefix into UNICODE_STRING.
	(is_floppy): Drop 9x consideration.
	* path.h: Drop including ntdef.h.
	(path_conv::check): Add declaration.
	(path_conv::path_conv): Add constructor for UNICODE_STRING paths.
	* shared_info.h (mount_info::get_mounts_here): Change declaration.
	* syscalls.cc: Drop forward declaration of stat_worker.
	(stat_worke): Take path_conv as parameter.  Drop nofollow flag.
	(stat64): Create matching path_conv and call stat_worker with it.
	(lstat64): Ditto.
	* winsup.h: Include ntdef.h.
	(stat_worker): Declare.
	(readdir_get_ino): Change declaration.
@
text
@d1208 10
@


1.439
log
@	* fhandler.cc (fhandler_base::open): Drop local wpath and upath
	variables.  Call pc.get_object_attr to create object attributes.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Ditto.
	* syscalls.cc (unlink_nt): Ditto.
	* path.cc (path_conv::set_normalized_path): Set wide_path to NULL.
	(path_conv::get_nt_native_path): Drop parameter.  Create path in
	wide_path/uni_path members.
	(path_conv::get_object_attr): New method to create object attributes.
	(path_conv::get_wide_win32_path): New method to create Win32 wide path.
	(path_conv::check): Initialize wide_path to NULL.
	(path_conv::~path_conv): cfree wide_path.
	* path.h (class path_conv): New members wide_path and uni_path.
	Add declarations of get_object_attr and get_wide_win32_path.
	(path_conv::path_conv): Initialize wide_path to NULL.
	(path_conv::get_nt_native_path): Drop parameter.
@
text
@d640 17
d1860 2
a1861 1
			     char **mount_points)
d1874 2
a1875 1
	    mount_points[n_mounts++] = last_slash + 1;
d1879 2
a1880 1
	mount_points[n_mounts++] = last_slash + 1;
d1882 2
d2819 1
a2819 2
  return strncasematch (dev, "\\Device\\Floppy", 14)
	 || strcasematch (dev, "A:");
@


1.438
log
@* path.cc (symlink_info::check_shortcut): Handle device "symlinks" specially -
don't posixify them.
@
text
@d82 1
d543 1
d571 1
a571 1
path_conv::get_nt_native_path (UNICODE_STRING &upath)
d573 32
a604 1
  return ::get_nt_native_path (path, upath);
d676 1
d1184 5
@


1.437
log
@	* path.cc (cwdstuff::set): Revert useless acquire check.
@
text
@d3067 5
a3071 1
  res = posixify (cp);
d4242 1
a4242 1
 
@


1.436
log
@	* path.cc (cwdstuff::set): Avoid double aquiring of cwd_lock.
	Open directory with inheriting enabled.
@
text
@d4227 1
a4227 2
      if (!cwd_lock.acquired ())
	cwd_lock.acquire ();
@


1.435
log
@* path.cc (fs_info::update): Set and use is_cdrom.
* path.cc (fillout_mntent): Set ret.mnt_type to something more Linux-like,
based on data from fs_info.  Move "system" and "user" strings from mnt_type to
mnt_opts.
* path.h (struct fs_info): Add is_cdrom field.
* path.h (fs_info::clear): Initialize is_cdrom.
* path.h (struct fs_info): Add IMPLEMENT_STATUS_FLAG(bool,is_cdrom).
* path.h (class path_conv): Add fs_is_cdrom method.  Add missing fs_is_netapp
method.
@
text
@d4227 2
a4228 1
      cwd_lock.acquire ();
d4256 1
a4256 1
			  NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS,
@


1.434
log
@* Makefile (DLL_OFILES): Remove ntea.o
* environ.cc (set_ntea): Delete.
(parse_thing): Delete "ntea" setting.
* fhandler.cc (fhandler_base::open): Remove allow_ntea considerations.
(check_posix_perm): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Ditto.
(fhandler_base::open_fs): Ditto.
(fhandler_disk_file::mkdir): Ditto.
* path.cc (symlink_worker): Ditto.
* security.cc (get_file_attribute): Ditto.
(set_file_attribute): Ditto.
* security.h: Remove allow_ntea declaration.
@
text
@d464 1
d478 1
a478 2
  if (drive_type () != DRIVE_REMOVABLE && drive_type () != DRIVE_CDROM
      && idx < MAX_FS_INFO_CNT)
d2555 21
a2575 4
  if (!(flags & MOUNT_SYSTEM))		/* user mount */
    strcpy (_my_tls.locals.mnt_type, (char *) "user");
  else					/* system mount */
    strcpy (_my_tls.locals.mnt_type, (char *) "system");
d2599 6
d4232 1
a4232 1
	     
d4238 1
a4238 1
	     
@


1.433
log
@	* path.cc (close_user_proc_parms_cwd_handle): Remove.
	(cwdstuff::init): Don't call close_user_proc_parms_cwd_handle.
	Call set to set cwd with all-sharing handle.
	(cwdstuff::set): Fix comment.  Don't close cwd handle.  Set in
	user parameter block instead and close old cwd handle.
	* syscalls.cc (rename): Call unlink_nt instead of RemoveDirectory or
	DeleteFile to allow deleting shared files/directories.
@
text
@a2978 4
	  if (!allow_ntsec && allow_ntea)
	    set_file_attribute (false, NULL, win32_path.get_win32 (),
				S_IFLNK | S_IRWXU | S_IRWXG | S_IRWXO);

@


1.432
log
@	* cygheap.h (struct cwdstuff): Remove sync member and keep_in_sync
	accessors.
	* external.cc (cygwin_internal): Drop call to cygheap->cwd.keep_in_sync.
	* fhandler_disk_file.cc (fhandler_disk_file::link): Always presume
	ability to create hard links.
	* path.cc (cwdstuff::init): Drop 9x considerations.
	(cwdstuff::keep_in_sync): Remove.
	(cwdstuff::set): Take NT for granted.
	* pinfo.h (cygwin_pid): Just return pid.
	* wincap.cc: Remove has_hard_links, can_open_directories,
	has_negative_pids, has_named_pipes, has_try_enter_critical_section,
	cant_debug_dll_entry and detect_win16_exe throughout.
	* wincap.h: Ditto.
@
text
@a4172 11
static void
close_user_proc_parms_cwd_handle ()
{
  PHANDLE phdl = &get_user_proc_parms ()->CurrentDirectoryHandle;
  if (*phdl)
    {
      NtClose (*phdl);
      *phdl = NULL;
    }
}

d4179 2
a4180 2
  if (!dynamically_loaded)
    close_user_proc_parms_cwd_handle ();
d4212 2
a4213 11
	     stored manually, but the handle to the directory is always
	     closed and set to NULL.  This way the directory isn't blocked
	     even if it's the cwd of a Cygwin process.

	     Why the hassle?

	     - A process has always an open handle to the current working
	       directory which disallows manipulating this directory.
	       POSIX allows to remove a directory if the permissions are ok.
	       The fact that its the cwd of some process doesn't matter.

d4218 5
a4222 1
	       FILE_OPEN_FOR_BACKUP_INTENT flag set. */
d4259 7
a4265 2
	  close_user_proc_parms_cwd_handle ();
	  CloseHandle (h);
@


1.431
log
@	Throughout replace all usage of wincap.shared with the constant
	FILE_SHARE_VALID_FLAGS.
	* fhandler.cc (fhandler_base::open_9x): Drop local variable shared.
	* wincap.cc: Remove shared member throughout.
	* wincap.h: Ditto.
@
text
@d4190 2
a4191 9
  if (!dynamically_loaded && !keep_in_sync ())
    {
      /* Actually chdir into the system dir to avoid cwd problems on 9x.
	 See comment in cwdstuff::set below. */
      if (!wincap.can_open_directories ())
	SetCurrentDirectory (windows_system_directory);
      else
	close_user_proc_parms_cwd_handle ();
    }
a4194 10
void
cwdstuff::keep_in_sync (bool val)
{
  if (!wincap.can_open_directories ())
    {
      sync = val;
      SetCurrentDirectory (val ? win32 : windows_system_directory);
    }
}

d4222 20
a4241 1
	  if (keep_in_sync ())
d4243 2
a4244 9
	      /* If a Cygwin application called cygwin_internal(CW_SYNC_WINENV),
		 then it's about to call native Windows functions.  This also
		 sets the keep_in_sync flag so that we actually chdir into the
		 native directory on 9x to avoid confusion. */
	      if (!SetCurrentDirectory (win32_cwd))
		{
		  __seterrno ();
		  goto out;
		}
d4246 17
a4262 1
	  else
d4264 2
a4265 60
	      /* We don't actually chdir on 9x but stay in the system dir.

		 On NT we utilize the user parameter block.  The directory is
		 stored manually, but the handle to the directory is always
		 closed and set to NULL.  This way the directory isn't blocked
		 even if it's the cwd of a Cygwin process.

		 Why the hassle?

		 - A process has always an open handle to the current working
		   directory which disallows manipulating this directory.
		   POSIX allows to remove a directory if the permissions are ok.
		   The fact that its the cwd of some process doesn't matter.

		 - SetCurrentDirectory fails for directories with strict
		   permissions even for processes with the SE_BACKUP_NAME
		   privilege enabled.  The reason is apparently that
		   SetCurrentDirectory calls NtOpenFile without the
		   FILE_OPEN_FOR_BACKUP_INTENT flag set. */
	      DWORD attr = GetFileAttributes (win32_cwd);
	      if (attr == INVALID_FILE_ATTRIBUTES)
		{
		  set_errno (ENOENT);
		  goto out;
		}
	      if (!(attr & FILE_ATTRIBUTE_DIRECTORY))
		{
		  set_errno (ENOTDIR);
		  goto out;
		}
	      if (wincap.can_open_directories ())
		{
		  HANDLE h = CreateFile (win32_cwd, FILE_TRAVERSE,
					 FILE_SHARE_VALID_FLAGS, NULL,
					 OPEN_EXISTING,
					 FILE_FLAG_BACKUP_SEMANTICS, NULL);
		  if (h == INVALID_HANDLE_VALUE)
		    {
		      __seterrno ();
		      goto out;
		    }
		  ULONG len = strlen (win32_cwd);
		  ANSI_STRING as = {len, len + 2, (PCHAR) alloca (len + 2)};
		  strcpy (as.Buffer, win32_cwd);
		  if (as.Buffer[len - 1] != '\\')
		    {
		      strcpy (as.Buffer + len, "\\");
		      ++as.Length;
		    }
		  if (current_codepage == ansi_cp)
		    RtlAnsiStringToUnicodeString (
				&get_user_proc_parms ()->CurrentDirectoryName,
				&as, FALSE);
		  else
		    RtlOemStringToUnicodeString (
				&get_user_proc_parms ()->CurrentDirectoryName,
				&as, FALSE);
		  close_user_proc_parms_cwd_handle ();
		  CloseHandle (h);
		}
d4267 10
@


1.430
log
@Remove extraneous whitespace.
* pinfo.cc (commune_process): Use default argument to lock_process.
* sigproc.cc: Update copyright.
* select.cc: Ditto.
@
text
@d4286 2
a4287 1
					 wincap.shared (), NULL, OPEN_EXISTING,
@


1.429
log
@	* Makefile.in (DLL_OFILES): Add fhandler_procnet.o.
	* autoload.cc (GetAdaptersAddresses): Define.
	* devices.h (FH_PROCNET): Define new device.
	* devices.in (dev_procnet_storage): Add "/proc/net" entry.
	* devices.cc: Regenerate.
	* dir.cc (readdir_worker): Use isproc_dev macro.
	* dtable.cc (build_fh_pc): Add FH_PROCNET.
	* fhandler.h (class fhandler_procnet): New class.
	* fhandler_proc.cc: Add "net" subdirectory handling.
	* fhandler_procnet.cc: New file handling "/proc/net" directory.
	* path.cc (isvirtual_dev): Move to path.h.
	* path.h (isproc_dev): New macro to identify /proc files by device.
	(isvirtual_dev): Moved here.  Define using isproc_dev.
	* syscalls.cc (unlink): Use isproc_dev macro.
	* wincap.h (wincapc::has_gaa_prefixes): New element.
	(wincapc::has_gaa_on_link_prefix): New element.
	* wincap.cc: Implement above elements throughout.
	(wincapc::init): Check XP for service pack and set has_gaa_prefixes
	appropriately.
	* include/cygwin/in6.h: Include asm/byteorder.h.
@
text
@d3121 1
a3121 1
  			MAXIMUM_REPARSE_DATA_BUFFER_SIZE, &size, NULL))
d3146 1
a3146 1
        {
d3152 1
a3152 1
        {
d3210 1
a3210 1
        {
d3473 1
a3473 1
        sym_check = 3;
d4238 1
a4238 1
        {
d4242 1
a4242 1
	         then it's about to call native Windows functions.  This also
d4246 1
a4246 1
	        {
d4286 1
a4286 1
		  			 wincap.shared (), NULL, OPEN_EXISTING,
d4313 1
a4313 1
        }
@


1.428
log
@	* autoload.cc (RtlAnsiStringToUnicodeString): Define.
	(RtlOemStringToUnicodeString): Define.
	* ntdll.h (struct _RTL_USER_PROCESS_PARAMETERS): Define.
	(struct _PEB): Redefine with a bit of content.
	(RtlAnsiStringToUnicodeString): Declare.
	(RtlOemStringToUnicodeString): Declare.
	* path.cc: Include ntdll.h.
	(_upp): New global variable pointing to user process parameter block.
	(get_user_proc_parms): New static function to retrieve user process
	parameter block.
	(close_user_proc_parms_cwd_handle): New function to close handle to
	current working directory in user process parameter block.
	(cwdstuff::init): Drop redundant declaration of dynamically_loaded.
	Set current dir only on 9x.  Call close_user_proc_parms_cwd_handle
	on NT instead.
	(cwdstuff::keep_in_sync): Only on 9x.
	(cwdstuff::set): Keep behaviour on 9x.  On NT write cwd path into user
	process parameter block and set cwd handle to NULL.  Fix comments to
	reflect new behaviour.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Red Hat, Inc.
a162 4
#define isvirtual_dev(devn) \
  (devn == FH_CYGDRIVE || devn == FH_PROC || devn == FH_REGISTRY \
   || devn == FH_PROCESS || devn == FH_NETDRIVE )

@


1.427
log
@	* environ.cc (set_traverse): Remove.
	(parse_thing): Drop "traverse" option.
	* path.cc (fs_info::update): Don't request SE_CHANGE_NOTIFY_PRIV
	privilege.
	* sec_helper.cc (set_cygwin_privileges): Ditto.
	* security.cc (allow_traverse): Remove.
	(alloc_sd): Drop special allow_traverse code.
	* security.h (allow_traverse): Drop declaration.
	* syscalls.cc (statvfs): Don't request SE_CHANGE_NOTIFY_PRIV privilege.
@
text
@d80 1
d4157 30
a4190 1
  extern int dynamically_loaded;
d4195 6
a4200 3
      /* Actually chdir into the system dir to avoid cwd problems.  See comment
	 in cwdstuff::set below. */
      SetCurrentDirectory (windows_system_directory);
d4208 5
a4212 2
  sync = val;
  SetCurrentDirectory (val ? win32 : windows_system_directory);
d4215 1
a4215 2
/* Get initial cwd.  Should only be called once in a
   process tree. */
d4247 1
a4247 1
		 native directory to avoid confusion. */
d4256 9
a4264 3
	      /* Check if we *could* chdir, if we actually would.
	      
		 Why don't we actually chdir?  For two reasons:
d4267 3
a4269 2
		   POSIX allows to remove a directory if the permissions are
		   ok.  The fact that its the cwd of some process doesn't matter.
d4288 1
a4288 1
		  HANDLE h = CreateFile (win32_cwd, GENERIC_READ,
d4296 17
@


1.426
log
@	* autoload.cc (SHFileOperationA): Drop definition.
	* ntdll.h (struct _FILE_RENAME_INFORMATION): Define.
	* path.cc (fs_info::update): Note length of rootdir prefix in
	root_len.
	(get_nt_native_path): New function, taking over functionality of
	path_conv::get_nt_native_path.
	(path_conv::get_nt_native_path): Just call get_nt_native_path.
	* path.h (get_nt_native_path): Declare.
	(struct fs_info): New member root_len.
	(fs_info::length): New inline method returning root_len.
	(path_conv::rootdir): New inline method returning rootdir prefix.
	* syscalls.cc (try_to_bin): Rewrite using only system calls.
	(unlink_nt): Call try_to_bin with additional handle to open file
	parameter.
	(statvfs): Use path_conv::rootdir method.
	* wincap.h: Define has_recycle_dot_bin throughout.
	* wincap.cc: Ditto.
@
text
@a415 4
  /* I have no idea why, but some machines require SeChangeNotifyPrivilege
     to access volume information. */
  push_thread_privilege (SE_CHANGE_NOTIFY_PRIV, true);

a426 2
  pop_thread_privilege ();

@


1.425
log
@	* cygheap.h (struct cwdstuff): Add "sync" member and accompanying
	"keep_in_sync" methods.
	* external.cc (cygwin_internal): Call above keep_in_sync method when
	CW_SYNC_WINENV is requested.
	* path.cc (cwdstuff::init): Don't change to windows_system_directory
	if keep_in_sync is requested.
	(cwdstuff::keep_in_sync): New method.
	(cwdstuff::set): Take sync flag into account.
@
text
@d392 1
a392 1
  if (!rootdir (win32_path, root_dir))
d414 1
d553 1
a553 1
path_conv::get_nt_native_path (UNICODE_STRING &upath)
d576 6
@


1.424
log
@	* path.cc (cwdstuff::init): Don't change to windows_system_directory
	if Cygwin DLL has been loaded dynamically.
@
text
@d4153 2
d4162 1
a4162 1
  if (!dynamically_loaded)
d4164 1
a4164 1
      /* Actually chdir into the syste dir to avoid cwd problems.  See comment
a4165 1
      extern char windows_system_directory[];
d4171 7
d4206 1
a4206 14
	  /* Check if we *could* chdir, if we actually would.
	  
	     Why don't we actually chdir?  For two reasons:
	     - A process has always an open handle to the current working
	       directory which disallows manipulating this directory.
	       POSIX allows to remove a directory if the permissions are
	       ok.  The fact that its the cwd of some process doesn't matter.
	     - SetCurrentDirectory fails for directories with strict
	       permissions even for processes with the SE_BACKUP_NAME
	       privilege enabled.  The reason is apparently that
	       SetCurrentDirectory calls NtOpenFile without the
	       FILE_OPEN_FOR_BACKUP_INTENT flag set. */
	  DWORD attr = GetFileAttributes (win32_cwd);
	  if (attr == INVALID_FILE_ATTRIBUTES)
d4208 9
a4216 2
	      set_errno (ENOENT);
	      goto out;
d4218 1
a4218 1
	  if (!(attr & FILE_ATTRIBUTE_DIRECTORY))
d4220 19
a4238 9
	      set_errno (ENOTDIR);
	      goto out;
	    }
	  if (wincap.can_open_directories ())
	    {
	      HANDLE h = CreateFile (win32_cwd, GENERIC_READ, wincap.shared (),
				     NULL, OPEN_EXISTING,
				     FILE_FLAG_BACKUP_SEMANTICS, NULL);
	      if (h == INVALID_HANDLE_VALUE)
d4240 1
a4240 1
		  __seterrno ();
d4243 12
a4254 1
	      CloseHandle (h);
@


1.423
log
@	* path.cc (cwdstuff::set): Don't try to open directory on systems not
	supporting that.
@
text
@d4157 1
d4160 7
a4166 4
  /* Actually chdir into the syste dir to avoid cwd problems.  See comment
     in cwdstuff::set below. */
  extern char windows_system_directory[];
  SetCurrentDirectory (windows_system_directory);
@


1.422
log
@	* dir.cc (mkdir): Check last path component for "..".
	(rmdir): Don't check last path component for "..".
	* fhandler_disk_file.cc (fhandler_disk_file::rmdir): Drop kludge
	which tries to allow deleting the current working directory.
	* path.cc (has_dot_last_component): Add parameter to indicate testing
	for "..".  Take trailing slash into account.
	(symlink_info::posixify): Rely on cygheap->cwd.win32 having a
	useful value.
	(cwdstuff::init): Initialize cygheap->cwd with current working
	directory.  Change to windows_system_directory afterwards.
	(cwdstuff::set): Never call SetCurrentDirectory here.  Just check
	if changing into target directory would be allowed.  Add comment to
	explain why.
	* path.h (has_dot_last_component): Declare with second parameter.
	* pinfo.cc (pinfo::zap_cwd): Remove.
	(pinfo::exit): Drop call to zap_cwd.
	* pinfo.h (class pinfo): Remove declaration of zap_cwd.
	* spawn.cc (spawn_guts): Set current working directory for non-Cygwin
	child applications.  Drop call to zap_cwd.
@
text
@d4217 1
a4217 4
	  HANDLE h = CreateFile (win32_cwd, GENERIC_READ, wincap.shared (),
				 NULL, OPEN_EXISTING,
				 FILE_FLAG_BACKUP_SEMANTICS, NULL);
	  if (h == INVALID_HANDLE_VALUE)
d4219 9
a4227 2
	      __seterrno ();
	      goto out;
a4228 1
	  CloseHandle (h);
@


1.421
log
@	* path.cc (fs_info::update): Define GETVOLINFO_VALID_MASK and TEST_GVI.
	Change FS_IS_SAMBA and FS_IS_SAMBA_WITH_QUOTA and their usage
	accordingly.  Define FS_IS_NETAPP_DATAONTAP.  Recognize NetApp device
	and store in is_netapp flag.  Mark NetApp device as having no good
	inodes.
	* path.h (struct fs_info): Add is_netapp flag.  Add matching accessors.
@
text
@d218 1
a218 1
has_dot_last_component (const char *dir)
d224 16
a239 4
  return last_comp
	 && last_comp[1] == '.'
	 && (last_comp[2] == '\0'
	     || (last_comp[2] == '.' && last_comp[3] == '\0'));
d3214 1
a3214 4
	  if (cygheap->cwd.win32)
	    strncpy (cvtbuf, cygheap->cwd.win32, 2);
	  else
	    GetCurrentDirectory (CYG_MAX_PATH, cvtbuf);
d4158 6
d4191 18
a4208 6
       cwd_lock.acquire ();
       if (doit && !SetCurrentDirectory (win32_cwd))
	 {
	    /* When calling SetCurrentDirectory for a non-existant dir on a
	       Win9x share, it returns ERROR_INVALID_FUNCTION. */
	    if (GetLastError () == ERROR_INVALID_FUNCTION)
d4210 12
a4221 1
	    else
d4223 4
a4226 2
	    goto out;
	 }
@


1.420
log
@	* fhandler.cc (check_posix_perm): Moved here from syscalls.cc.
	(fhandler_base::fpathconf): New method implementing (f)pathconf.
	* fhandler.h (class fhandler_base): Declare fpathconf method.
	* path.cc (path_conv::check): Replace MAX_LINK_DEPTH with SYMLOOP_MAX.
	* path.h (MAX_LINK_DEPTH): Delete.
	* syscalls.cc (check_posix_perm): Move to fhandler.cc.
	(fpathconf): Call fhandler's fpathconf method.
	(pathconf): Build fhandler and call fhandler's fpathconf method.
	* sysconf.cc (sysconf): Reorder switch according to order of flags
	in sys/unistd.h.  Add handling for some missing flags.
	* include/limits.h: Reorder according to SUSv3 description.  Add some
	missing definitions.  Add comments.
	* include/sys/syslimits.h: New file overriding newlib's syslimits.h
	file.
@
text
@d429 23
a451 8
#define FS_IS_SAMBA (FILE_CASE_SENSITIVE_SEARCH \
		     | FILE_CASE_PRESERVED_NAMES \
		     | FILE_PERSISTENT_ACLS)
#define FS_IS_SAMBA_WITH_QUOTA \
		    (FILE_CASE_SENSITIVE_SEARCH \
		     | FILE_CASE_PRESERVED_NAMES \
		     | FILE_PERSISTENT_ACLS \
		     | FILE_VOLUME_QUOTAS)
d454 4
a457 2
	    && (flags () == FS_IS_SAMBA || flags () == FS_IS_SAMBA_WITH_QUOTA));
  is_ntfs (strcmp (fsname, "NTFS") == 0 && !is_samba ());
d464 2
a465 1
		  && drive_type () != DRIVE_UNKNOWN)
@


1.419
log
@	* path.cc (symlink_info::posixify): Fix comment.
@
text
@d910 1
a910 1
      if (++loop > MAX_LINK_DEPTH)
@


1.418
log
@	* path.cc (symlink_info::check): Eliminate PATH_REP bit from pflags.
@
text
@d3158 2
a3159 2
     just incorrectly sticking to their redundant backslashes.  We go along
     with this behaviour to avoid scenarios in which native tools access
@


1.417
log
@	* path.cc (symlink_info::posixify): New mothod converting NT and DOS
	paths in symlinks to POSIX.
	(symlink_info::check_shortcut): Allocate buf allowing for a trailing 0.
	Call posixify on the result.
	(symlink_info::check_sysfile): Read from file into local buffer.
	Eliminate old b16 considerations.  Call posixify on the result.
	(symlink_info::check_reparse_point): Don't use PrintName but
	SubstituteName which is relevant for Windows' path handling.
	Call posixify on the result.
@
text
@d3397 1
a3397 1
  pflags &= ~(PATH_SYMLINK | PATH_LNK);
@


1.416
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Drop
	directory attribute for reparse points to avoid mistreating.
	(fhandler_base::fstat_by_name): Ditto.
	* path.cc (symlink_info::check_reparse_point): New method testing
	reparse points for symbolic links.
	(symlink_info::check_shortcut): Move file attribute tesat to calling
	function.
	(symlink_info::check): Add handling for reparse points.
	* path.h (enum path_types): Add PATH_REP to denote reparse point based
	symlinks.
	(path_conv::is_rep_symlink): New method.
	* syscalls.cc (unlink): Handle reparse points.
@
text
@d108 1
d3003 1
a3003 1
  buf = (char *) alloca (size);
d3017 3
a3019 3
  strncpy (contents, cp += 2, len);
  contents[len] = '\0';
  res = len;
d3038 1
d3053 1
a3053 1
      res = ReadFile (h, contents, CYG_MAX_PATH, &got, 0);
d3060 1
a3060 13
	{
	  /* Versions prior to b16 stored several trailing
	     NULs with the path (to fill the path out to 1024
	     chars).  Current versions only store one trailing
	     NUL.  The length returned is the path without
	     *any* trailing NULs.  We also have to handle (or
	     at least not die from) corrupted paths.  */
	  char *end;
	  if ((end = (char *) memchr (contents, 0, got)) != NULL)
	    res = end - contents;
	  else
	    res = got;
	}
d3089 1
d3100 2
a3101 1
      if (rp->SymbolicLinkReparseBuffer.PrintNameLength > 2 * CYG_MAX_PATH)
d3107 1
a3107 1
      res = sys_wcstombs (contents, CYG_MAX_PATH,
d3109 2
a3110 2
			      + rp->SymbolicLinkReparseBuffer.PrintNameOffset),
		    rp->SymbolicLinkReparseBuffer.PrintNameLength / 2);
d3121 2
a3122 1
      if (rp->MountPointReparseBuffer.PrintNameLength > 2 * CYG_MAX_PATH)
d3128 4
a3131 4
      res = sys_wcstombs (contents, CYG_MAX_PATH,
		      (WCHAR *)((char *)rp->MountPointReparseBuffer.PathBuffer
				+ rp->MountPointReparseBuffer.PrintNameOffset),
		      rp->MountPointReparseBuffer.PrintNameLength / 2);
d3135 1
d3141 56
@


1.415
log
@	* path.cc (path_conv::get_nt_native_path): Properly detect \\?\ paths.
	(mount_info::conv_to_win32_path): Update comment.
	* fhandler_disk_file.cc (path_conv::ndisk_links): Use backslashes
	to make NT kernel functions work for \\?\GLOBALROOT paths.
@
text
@d107 1
a2999 4
  /* Valid Cygwin & U/WIN shortcuts are R/O. */
  if (!(fileattr & FILE_ATTRIBUTE_READONLY))
    goto file_not_symlink;

a3032 1

d3092 55
d3391 2
a3392 1
      if (fileattr & FILE_ATTRIBUTE_DIRECTORY)
d3395 3
a3397 3
      /* Windows shortcuts are treated as symlinks. */
      if (suffix.lnk_match ())
	sym_check = 1;
d3402 1
a3402 1
      if (fileattr & FILE_ATTRIBUTE_SYSTEM)
d3405 5
d3416 4
a3419 1
		      &sec_none_nih, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
d3446 5
@


1.414
log
@* environ.cc (env_win32_to_posix_path_list): Declare.
(conv_envvars): Use env_win32_to_posix_path_list rather than
cygwin_win32_to_posix_path_list.
(posify): Translate back to win32 path if errno is EIDRM.
* environ.h: Update copyright.  Define ENV_CVT.
* path.cc (conv_path_list): If converting for the environment and removed an
element set errno to ENV_CVT.
(env_win32_to_posix_path_list): New function.
@
text
@d529 1
a529 1
  else if (path[2] != '.'
d535 1
a535 1
  else					/* \\.\device */
d1664 3
a1666 2
  /* If the path is on a network drive, bypass the mount table.
     If it's // or //MACHINE, use the netdrive device. */
@


1.413
log
@* environ.cc (dos_file_warning): Declare.
(parse_thing): Add "dosfilewarning".  Alphabetize.
* path.cc (normalize_posix_path): Return -1 when MS-DOS path detected.
(warn_msdos): New function.
(path_conv::check): Call if !PC_NOWARN and MS-DOS path detected.
(cygwin_conv_to_win32_path): Set PC_NOWARN when calling path_conv.
(cygwin_conv_to_full_win32_path): Ditto.
* path.h (pathconv_arg::PC_NOWARN): Define.
* shared_info.h (user_info::warned_msdos): New field.
(CURR_USER_MAGIC): Reset.
@
text
@d78 1
d1333 1
d1348 5
a1352 1
	continue;
d1360 3
d3898 6
@


1.412
log
@	* path.cc (symlink_worker): Return EEXIST if newpath exists.
@
text
@d80 1
d212 1
a212 2
   This test should eventually end up in path_conv::check in one way
   or another.  Right now, normalize_posix_path will just normalize
d325 1
a325 1
  return err;
d542 20
d625 1
d634 1
a634 1
      if (error)
d636 6
d1089 2
d3678 1
a3678 1
  path_conv p (path, PC_SYM_FOLLOW | PC_NO_ACCESS_CHECK | PC_NOFULL);
d3694 1
a3694 1
  path_conv p (path, PC_SYM_FOLLOW | PC_NO_ACCESS_CHECK);
@


1.412.2.1
log
@	* path.cc (fs_info::update): Fix Samba test to support recent as well
	as upcoming Samba releases.
@
text
@d426 8
a433 15
/* Test only flags indicating capabilities, ignore flags indicating a specific
   state of the volume.  At present ignore FILE_VOLUME_IS_COMPRESSED and
   FILE_READ_ONLY_VOLUME. */
#define GETVOLINFO_VALID_MASK (0x003701ffUL)
/* Volume quotas are potentially supported since Samba 3.0, object ids and
   the unicode on disk flag since Samba 3.2. */
#define SAMBA_IGNORE (FILE_VOLUME_QUOTAS \
			| FILE_SUPPORTS_OBJECT_IDS \
			| FILE_UNICODE_ON_DISK)
#define SAMBA_REQIURED (FILE_CASE_SENSITIVE_SEARCH \
			| FILE_CASE_PRESERVED_NAMES \
			| FILE_PERSISTENT_ACLS)
#define FS_IS_SAMBA	((flags () & GETVOLINFO_VALID_MASK & ~SAMBA_IGNORE) \
			 ==  SAMBA_REQIURED)

d435 2
a436 1
  is_samba (strcmp (fsname, "NTFS") == 0 && is_remote_drive () && FS_IS_SAMBA);
@


1.412.2.2
log
@2008-03-05  Corinna Vinschen  <corinna@@vinschen.de>

	* child_info.h (~child_info_spawn): Check moreinfo->myself_pinfo for
	NULL before closing.
	* spawn.cc (spawn_guts): Don't close moreinfo->myself_pinfo explicitely
	in case of failing CloseProcess.

	* exceptions.cc (_cygtls::handle_exceptions): Replace top level SEH
	installed by Windows with our own handler.

	* fhandler.cc (fhandler_base::open_): Return EISDIR when trying to
	create a directory.
	(fhandler_base::open_9x): Ditto.
	* ntdll.h (STATUS_OBJECT_NAME_INVALID): Define.
	* path.cc (path_conv::check): If input path had a trailing dir
	separator, tack it on to the native path if directory doesn't exist.

2008-03-05  Christopher Faylor  <me+cygwin@@cgf.cx>

	* exceptions.cc (_cygtls::handle_exceptions): Detect when signal is
	masked and treat as if it was not caught.  Revert to a 'return 0'
	rather than using a goto.
@
text
@a961 2
  else if (fileattr == INVALID_FILE_ATTRIBUTES)
    strcat (path, "\\");
@


1.411
log
@	* path.cc (path_conv::check): Ignore has_ea setting, it's always unset
	at this point anyway.
	(get_symlink_ea): Remove.
	(set_symlink_ea): Remove.
	(symlink_worker): Drop writing symlink into NTFS extended attributes.
	(symlink_info::check): Drop reading symlinks from NTFS extended
	attributes.
@
text
@d2760 2
a2761 1
  if (win32_path.is_auto_device ())
@


1.411.2.1
log
@	* Merge HEAD into cv-branch.
@
text
@d2760 1
a2760 2
  if ((!isdevice && win32_path.exists ())
      || win32_path.is_auto_device ())
@


1.410
log
@	* autoload.cc (NtQueryEaFile): Define.
	(NtSetEaFile): Define.
	* fhandler.cc (fhandler_base::open): Use appropriate open flags
	in query case when allow_ntea is set.
	* ntdll.h (struct _FILE_GET_EA_INFORMATION): Define.
	(struct _FILE_FULL_EA_INFORMATION): Define.
	(NtQueryEaFile): Declare.
	(NtSetEaFile): Declare.
	* ntea.cc (read_ea): Rename from NTReadEA and rewrite using
	NtQueryEaFile.
	(write_ea): Rename from NTWriteEA and rewrite using NtSetEaFile.
	* path.cc (get_symlink_ea): Make static.  Add handle parameter to
	accomodate new read_ea call.
	(set_symlink_ea): Make static.  Add handle parameter to accomodate new
	write_ea call.
	(symlink_worker): Call set_symlink_ea while file is still open.
	(symlink_info::check): Call get_symlink_ea after file has been opened.
	* security.cc (get_file_attribute): Accomodate new read_ea call.
	(set_file_attribute): Accomodate new write_ea call.
	* security.h (read_ea): Change declaration accordingly.
	(write_ea): Ditto.
@
text
@d760 1
a760 1
	  symlen = sym.check (full_path, suff, opt | fs.has_ea ());
a2695 22
/* Read symlink from Extended Attribute */
static int
get_symlink_ea (HANDLE hdl, const char* frompath, char* buf, int buf_size)
{
  int res = read_ea (hdl, frompath, SYMLINK_EA_NAME, buf, buf_size);
  if (res == 0)
    debug_printf ("Cannot read symlink from EA");
  return (res - 1);
}

/* Save symlink to Extended Attribute */
static bool
set_symlink_ea (HANDLE hdl, const char* frompath, const char* topath)
{
  if (!write_ea (hdl, frompath, SYMLINK_EA_NAME, topath, strlen (topath) + 1))
    {
      debug_printf ("Cannot save symlink in EA");
      return false;
    }
  return true;
}

a2906 2
	  if (!isdevice && win32_path.fs_has_ea ())
	    set_symlink_ea (h, win32_path, oldpath);
a3255 1

a3256 2
  unsigned pflags_or = pflags & PATH_NO_ACCESS_CHECK;

a3323 11
      if (sym_check > 0 && opt & PC_CHECK_EA
	  && (res = get_symlink_ea (h, suffix.path, contents,
				    sizeof (contents))) > 0)
	{
	  pflags = PATH_SYMLINK | pflags_or;
	  if (sym_check == 1)
	    pflags |= PATH_LNK;
	  debug_printf ("Got symlink from EA: %s", contents);
	  break;
	}

@


1.409
log
@white space
@
text
@d2697 2
a2698 2
int
get_symlink_ea (const char* frompath, char* buf, int buf_size)
d2700 1
a2700 1
  int res = NTReadEA (frompath, SYMLINK_EA_NAME, buf, buf_size);
d2707 2
a2708 2
bool
set_symlink_ea (const char* frompath, const char* topath)
d2710 1
a2710 1
  if (!NTWriteEA (frompath, SYMLINK_EA_NAME, topath, strlen (topath) + 1))
d2929 2
a2944 2
	  if (!isdevice && win32_path.fs_has_ea ())
	    set_symlink_ea (win32_path, oldpath);
d3343 11
a3353 2
      if (sym_check > 0 && opt & PC_CHECK_EA &&
	  (res = get_symlink_ea (suffix.path, contents, sizeof (contents))) > 0)
a3361 10
      /* Open the file.  */

      h = CreateFile (suffix.path, GENERIC_READ, FILE_SHARE_READ,
		      &sec_none_nih, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
      res = -1;
      if (h == INVALID_HANDLE_VALUE)
	goto file_not_symlink;

      /* FIXME: if symlink isn't present in EA, but EAs are supported,
	 should we write it there?  */
@


1.408
log
@	* fhandler.h (fhandler_base): Change fstat_helper prototype
	to take file size and inode number as 64 bit values.
	* fhandler_disk_file.cc (FS_IS_SAMBA): Move to path.cc
	(FS_IS_SAMBA_WITH_QUOTA): Ditto.
	(path_conv::hasgood_inode): Delete.
	(path_conv::is_samba): Delete.
	(path_conv::isgood_inode): Centralized function to recognize
	a good inode number.
	(fhandler_base::fstat_by_handle): Constify fvi_size and fai_size.
	Accomodate argument change in fstat_helper.
	(fhandler_base::fstat_by_name): Ditto.
	(fhandler_base::fstat_helper): Accomodate argument change.  Call
	path_conv::isgood_inode to recognize good inodes.
	(fhandler_disk_file::opendir): Explain Samba weirdness here.
	Call path_conv::fs_is_samba instead of path_conv::is_samba.
	(fhandler_disk_file::readdir): Add STATUS_INVALID_INFO_CLASS
	as valid return code from NtQueryDirectoryFile to indicate that
	FileIdBothDirectoryInformation is not supported.
	Call path_conv::isgood_inode to recognize good inodes.
	* ntdll.h (STATUS_INVALID_INFO_CLASS): Define.
	* path.cc (fs_info::update): Rework file system recognition
	and set appropriate flags.
	* path.h (struct fs_info): Add is_ntfs, is_samba and is_nfs flags.
	Constify pure read accessors.
@
text
@d222 1
a222 1
  	 && last_comp[1] == '.'
d980 1
a980 1
	        {
d987 1
a987 1
	        }
d1743 1
a1743 1
        continue;
d1745 1
a1745 1
        {
d2816 1
a2816 1
	      			   transparent_exe ? stat_suffixes : NULL);
d2825 1
a2825 1
	      			   transparent_exe ? stat_suffixes : NULL);
d3790 1
a3790 1
        {
@


1.407
log
@	* include/sys/dirent.h (struct __DIR): Rename __d_unused to
	__d_internal.
	* fhandler_disk_file.cc (struct __DIR_cache): Remove useless "typedef".
	(d_dirname): Remove useless "struct".
	(d_cachepos): Ditto.
	(d_cache): Ditto.
	(class __DIR_mounts): New class, implementing mount point tracking
	for readdir.
	(d_mounts): New macro for easy access to __DIR_mounts structure.
	(fhandler_disk_file::opendir): Allocate __DIR_mounts structure and
	let __d_internal element of dir point to it.
	(fhandler_disk_file::readdir_helper): Add mount points in the current
	directory, which don't have a real directory backing them.
	Don't generate an inode number for /dev.  Add comment, why.
	(fhandler_disk_file::readdir): Move filling fname to an earlier point.
	Check if current entry is a mount point and evaluate correct inode
	number for it.
	(fhandler_disk_file::readdir_9x): Ditto.
	(fhandler_disk_file::rewinddir): Set all mount points in this directory
	to "not found" so that they are listed again after calling rewinddir().
	(fhandler_disk_file::closedir): Deallocate __DIR_mounts structure.
	* path.cc (mount_info::get_mounts_here): New method to evaluate a list
	of mount points in a given parent directory.
	* shared_info.h (class mount_info): Declare get_mounts_here.
@
text
@d426 15
a440 6
  /* FIXME: Samba by default returns "NTFS" in file system name, but
   * doesn't support Extended Attributes. If there's some fast way to
   * distinguish between samba and real ntfs, it should be implemented
   * here.
   */
  has_ea (!is_remote_drive () && strcmp (fsname, "NTFS") == 0);
d443 3
a445 1
  is_fat (strncasematch (fsname, "FAT", 3));
@


1.406
log
@* path.cc (conv_path_list): Eat empty paths when converting to POSIX.
(cygwin_conv_to_win32_path): Deal with Cygwin's necessity of adding a '/' to
the end of a path ending in '.'.
@
text
@d1721 24
@


1.405
log
@	* environ.cc (struct parse_thing): Add transparent_exe option.
	* fhandler_disk_file.cc (fhandler_disk_file::link): Accomodate
	transparent_exe option.  Add .exe suffix for links to executable files,
	if transparent_exe is set.
	* fhandler_process.cc (fhandler_process::fill_filebuf): Remove .exe
	suffix if transparent_exe option is set.
	* path.cc (symlink_worker): Accomodate transparent_exe option.
	(realpath): Don't tack on .exe suffix if transparent_exe is set.
	* syscalls.cc (transparent_exe): New global variable.
	(unlink): Accomodate transparent_exe option.
	(open): Ditto.
	(link): Ditto.
	(rename): Ditto. Maybe add .exe suffix when renaming executable files.
	(pathconf): Accomodate transparent_exe option.
	* winsup.h: Declare transparent_exe.
@
text
@d1272 15
a1286 7
  char *s;
  char *d = dst;
  char src_delim = to_posix ? ';' : ':';
  char dst_delim = to_posix ? ':' : ';';
  int (*conv_fn) (const char *, char *) = (to_posix
					   ? cygwin_conv_to_posix_path
					   : cygwin_conv_to_win32_path);
d1290 3
a1292 1
  for (;;)
d1294 1
a1294 1
      s = strccpy (srcbuf, &src, src_delim);
d1297 10
a1306 2
	return ENAMETOOLONG;
      int err = (*conv_fn) (len ? srcbuf : ".", d);
a1307 2
	return err;
      if (!*src++)
d1310 1
a1310 1
      *d++ = dst_delim;
d1312 6
a1317 1
  return 0;
d3660 2
a3661 1
  strcpy (win32_path, p);
@


1.404
log
@	* path.cc (suffix_scan::lnk_match): Return true beginning with
	SCAN_APPENDLNK.
	(suffix_scan::next): Rearrange code to make .lnk append order slightly
	more deterministic.
	* spawn.cc (exe_suffixes): Try no suffix before .exe suffix to align
	evaluation with stat_suffixes.
	(dll_suffixes): Ditto.
@
text
@d2678 2
d2709 2
a2710 1
  win32_path.check (newpath, PC_SYM_NOFOLLOW);
d2759 2
a2760 1
	      win32_oldpath.check (oldpath, PC_SYM_NOFOLLOW);
d2768 2
a2769 1
	      win32_oldpath.check (oldpath, PC_SYM_NOFOLLOW);
d2780 2
a2781 1
	  win32_oldpath.check (oldpath, PC_SYM_NOFOLLOW);
d3732 1
a3732 1
      if (real_path.known_suffix)
@


1.403
log
@	* spawn.cc (find_exec): Only return files with execute permission set
	if ntsec is on.  Don't check execute permission of Windows batch files.
	(av::fixup): Handle empty files gracefully.  Drop execute permission
	test here.
	* path.cc (suffix_scan::next): Don't skip any suffix on first run.
@
text
@d3038 1
a3038 1
  int lnk_match () {return nextstate >= SCAN_EXTRALNK;}
a3094 2
	    if (!*suffixes->name)
	      suffixes++;
d3099 1
a3099 1
	    nextstate = SCAN_EXTRALNK;	/* Skip SCAN_BEG */
a3100 1
	  case SCAN_LNK:
a3101 1
	    strcpy (eopath, ".lnk");
d3103 2
a3104 1
	    return 1;
d3106 1
a3106 1
	    nextstate = SCAN_APPENDLNK;
d3108 1
@


1.402
log
@	* path.cc (cwdstuff::set): Don't set win32 error, only POSIX errno.
@
text
@d3121 1
a3121 1
	if (!suffixes->addon)
@


1.401
log
@	* path.cc (cwdstuff::set): When SetCurrentDirectory returns
	ERROR_INVALID_FUNCTION, bend it over to ERROR_FILE_NOT_FOUND.  Add
	comment to explain why.
@
text
@d3981 3
a3983 2
	      SetLastError (ERROR_FILE_NOT_FOUND);
	    __seterrno ();
@


1.400
log
@	* fhandler_process.cc (fhandler_process::fill_filebuf): Disable
	stripping the .exe suffix from the link target in PROCESS_EXE and
	PROCESS_EXENAME case.
	* path.cc (realpath): Tack on .exe suffix if necessary.
@
text
@d3978 4
@


1.399
log
@* path.cc (dot_special_chars): Add ", <, >, and |.
@
text
@d3726 9
d3737 2
a3738 1
	  resolved = (char *) malloc (strlen (real_path.normalized_path) + 1);
d3742 4
a3745 1
      return strcpy (resolved, real_path.normalized_path);
@


1.398
log
@	* path.cc (path_conv::check): Rework loop removing trailing dots
	and spaces.

	* syslog.cc (vklog): Set facility to LOG_KERN if not set.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Red Hat, Inc.
d1332 2
a1333 2
    "\031" "\032" "\033" "\034" "\035" "\036" "\037"
    ":"    "\\"   "*"    "?"    "%"
@


1.397
log
@whitespace cleanup to force snapshot.
@
text
@d958 3
a960 1
	  /* Windows ignores trailing dots and spaces */
d963 2
a964 5
	    if (*p != '.' && *p != ' ')
	      tail = NULL;
	    else if (p[1] == '\\')
	      {
		memmove (p, p + 1, strlen (p));
d966 12
a977 3
	      }
	    else if (!tail)
	      tail = p;
@


1.396
log
@* devices.h (_minor): Coerce argument to proper type before manipulating.
(_major): Ditto.
(device::is_fs_special): New function.
* fhandler_disk_file.cc (fhandler_base::fstat_helper): Set the size to 0 for
devices rather than reporting the size of the symlink.
(fhandler_disk_file::readdir): Use is_fs_special to determine if .lnk should be
stripped.
* path.cc: Rename symlink_info::is_symlink to symlink_info::issymlink
throughout.
(symlink_info::isdevice): New field.
(path_conv::check): Use 'isdevice' to determine if just-parsed entity is a
device rather than relying on non-zero major/minor.
(symlink_info::parse_device): Set isdevice to true if we've discovered a
device.
(symlink_info::check): Clear isdevice field prior to processing.  Use isdevice
to control debugging output.
(symlink_info::set): Set isdevice to false.
* path.h (path_conv::is_fs_special): New function.
* devices.cc: Regenerate.
@
text
@d250 1
a250 1
        ++dst_start;
d1115 1
a1115 1
        {
d1122 1
a1122 1
        {
d3720 2
a3721 2
          resolved = (char *) malloc (strlen (real_path.normalized_path) + 1);
          if (!resolved)
d3723 1
a3723 1
        }
@


1.395
log
@* dir.cc (mkdir): Abandon use of PC_WRITABLE.
(rmdir): Ditto.
* path.h (PC_WRITABLE): Delete.
* path.cc (path_conv::check): Remove PC_WRITABLE accommodations.  Revisit
later.
@
text
@d91 1
a91 1
  int is_symlink;
d95 1
d753 1
a753 1
	  if (sym.minor || sym.major)
d801 1
a801 1
	      if (!sym.is_symlink && sym.fileattr != INVALID_FILE_ATTRIBUTES)
d3156 1
a3156 1
    return false;
d3161 1
a3161 1
    return false;
d3166 1
a3166 1
    return false;
d3168 1
a3168 1
  switch (mymode & S_IFMT)
a3169 1
    case S_IFIFO:
a3171 7
      break;
    case S_IFBLK:
    case S_IFCHR:
      if (mymajor || myminor)
	break;
    default:
      return false;
d3177 1
a3177 1
  return true;
d3205 2
a3206 1
  is_symlink = true;
d3211 1
d3321 2
a3322 2
      is_symlink = false;
      syscall_printf ("%s", (major || minor) ? "is a device" : "not a symlink");
d3341 2
a3342 1
  is_symlink = true;
@


1.394
log
@* (symlink_info::set_error): Change to return bool if input error should be
ignored.
(symlink_info::check): Treat path as a normal file if set_error returns false.
@
text
@d928 1
a928 8
  /* If the user wants a directory, do not return a symlink */
  if ((opt & PC_WRITABLE) && (path_flags & PATH_RO))
    {
      debug_printf ("%s is on a read-only filesystem", path);
      error = EROFS;
      return;
    }
  else if (dev.devn == FH_NETDRIVE && component)
@


1.393
log
@	* dir.cc (mkdir): Check for trailing /. or /.. component.
	(rmdir): Ditto.
	* path.cc (has_dot_last_component): New function.
	* path.h (has_dot_last_component): Add declaration.
@
text
@d104 1
a104 1
  void set_error (int);
d3133 1
a3133 1
void
d3136 14
a3149 3
  if ((pflags & PATH_NO_ACCESS_CHECK) && in_errno != ENAMETOOLONG)
    return;
  error = in_errno;
d3257 2
a3258 2
	  set_error (geterrno_from_win_error (win_error, EACCES));
	  continue;
@


1.392
log
@	Revert erroneous checkin.
@
text
@d208 18
@


1.391
log
@	* fhandler.h (class fhandler_dev_raw): Delete current_position and
	eof_detected status flag.  Delete is_eom and is_eof methods.
	Move drive_size, bytes_per_sector, eom_detected status flag, as well
	as the methods read_file, write_file, raw_read and raw_write to ...
	(class fhandler_dev_floppy): ... here. Remove is_eom and is_eof
	methods.  Add dup method.
	* fhandler_floppy.cc (IS_EOM): New macro.
	(fhandler_dev_floppy::is_eom): Remove.
	(fhandler_dev_floppy::is_eof): Remove.
	(fhandler_dev_floppy::fhandler_dev_floppy): Initialize status flags.
	(fhandler_dev_floppy::get_drive_info): Only call EX functions on
	systems supporting them and stop suffering strange delays.
	(fhandler_dev_floppy::read_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::write_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::open): Rearrange comment.
	(fhandler_dev_floppy::dup): New method.
	(fhandler_dev_floppy::get_current_position): New inline method.  Use
	instead of former current_position were appropriate.
	(fhandler_dev_floppy::raw_read): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::raw_write): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::lseek): Remove useless conditions.  Convert
	sector_aligned_offset to LARGE_INTEGER to improve SetFilePointer call.
	(fhandler_dev_floppy::ioctl): Move blocksize check in RDSETBLK case
	to here.
	* fhandler_raw.cc (fhandler_dev_raw::is_eom): Remove.
	(fhandler_dev_raw::is_eof): Remove.
	(fhandler_dev_raw::write_file): Remove.
	(fhandler_dev_raw::read_file): Remove.
	(fhandler_dev_raw::raw_read): Remove.
	(fhandler_dev_raw::raw_write): Remove.
	(fhandler_dev_raw::dup): Drop copying removed members.
	(fhandler_dev_raw::ioctl): Drop blocksize testing.
	* wincap.h: Implement has_disk_ex_ioctls throughout.
	* wincap.cc: Ditto.
	(wincap_vista): Preliminary wincaps for Windows Vista/Longhorn.
	(wincapc::init): Add Vista/Longhorn handling.
@
text
@a77 1
#include "ntdll.h"
d491 1
a491 1
  if (path[0] == '\\' && path[1] != '\\')
d493 2
a494 4
      /* This handles all paths already given in NT speak.  On writing this
         comment, these are the raw device paths. */
      if (RtlCreateUnicodeStringFromAsciiz (&upath, path))
	return &upath;
d496 9
a504 1
  else
d506 2
a507 11
      wchar_t wc_path[CYG_MAX_PATH];
      sys_mbstowcs (wc_path, path, CYG_MAX_PATH);
      if (RtlDosPathNameToNtPathName_U (wc_path, &upath, NULL, NULL))
	{
#ifdef DEBUGGING
	  char nt_path[CYG_MAX_PATH + 7];
	  sys_wcstombs (nt_path, upath.Buffer, CYG_MAX_PATH + 7);
	  debug_printf ("DOS: <%s> NT: <%s>", path, nt_path);
#endif
	  return &upath;
	}
d509 1
a509 2
  set_errno (ENOMEM);
  return NULL;
@


1.390
log
@* cygthread.cc (cygthread::cygthread): Add more info to fatal error.
* fhandler_disk_file.cc (fhandler_disk_file::readdir): Temporarily remove
insertion of /dev into root directory.
* path.cc (path_conv::check): Ditto.
@
text
@d78 1
d492 1
a492 1
  if (path[0] != '\\')			/* X:\...  or NUL, etc. */
d494 4
a497 2
      str2uni_cat (upath, "\\??\\");
      str2uni_cat (upath, path);
d499 1
a499 4
  else if (path[1] != '\\')		/* \Device\... */
    str2uni_cat (upath, path);
  else if (path[2] != '.'
	   || path[3] != '\\')		/* \\server\share\... */
d501 11
a511 2
      str2uni_cat (upath, "\\??\\UNC\\");
      str2uni_cat (upath, path + 2);
d513 2
a514 6
  else					/* \\.\device */
    {
      str2uni_cat (upath, "\\??\\");
      str2uni_cat (upath, path + 4);
    }
  return &upath;
@


1.389
log
@	* path.cc (normalize_posix_path): Keep two leading slashes
	intact throughout.
	(normalize_win32_path): Revert to only checking for slash.
	(realpath): Convert drive letters to cygdrive paths before
	doing anything else.
	* shared_info.h (mount_info::cygdrive_posix_path): Make public.
@
text
@d651 1
d658 1
@


1.388
log
@	* path.cc (realpath): Drop call to mount_info::conv_to_posix_path
	in favor of calling path_conv with PC_POSIX flag.  Align error
	handling closer to POSIX.  As on Linux, return user space allocated
	memory if second parameter is NULL.
@
text
@d218 1
d230 2
d234 1
a234 1
	  if (tail == dst + 1 && *dst == '/')
d243 4
a246 1
    *tail++ = *src++;
d280 1
a280 1
		  while (tail > dst && !isslash (*--tail))
d1120 1
a1120 1
  if (tail == dst && !isdrive(src) && isdirsep (*src))
d3670 2
a3671 3
  path_conv real_path (path, PC_SYM_FOLLOW | PC_POSIX, stat_suffixes);

  /* Guard writing to a potentially invalid resolved. */
d3676 14
@


1.387
log
@	* path.cc (normalize_win32_path): Honor network paths.  Fold more
	than two leading dir separators into one.  Check for dir separator
	instead of just slashes to handle incoming Win32 paths correctly.
@
text
@a3655 1
  int err;
d3657 19
a3675 1
  path_conv real_path (path, PC_SYM_FOLLOW, stat_suffixes);
d3677 1
a3677 3
  if (real_path.error)
    err = real_path.error;
  else
d3679 7
a3685 3
      err = mount_table->conv_to_posix_path (real_path.get_win32 (), resolved, 0);
      if (err == 0)
	return resolved;
d3690 3
a3692 3
  resolved[0] = '\0';

  set_errno (err);
@


1.386
log
@* path.cc (path_conv::check): Fill in fileattr for /dev, defaulting to
directory if /dev doesn't actually exist.
(win32_device_name): Don't consider FH_DEV to be a device since it's really a
directory which should go through mount processing.
@
text
@d1092 1
a1092 1
  if (beg_src_slash && isdirsep (src[1]) && src[2])
d1094 10
a1103 4
      *tail++ = '\\';
      src++;
      if (src[1] == '.' && isdirsep (src[2]))
	{
d1105 7
a1111 2
	  *tail++ = '.';
	  src += 2;
d1114 1
a1114 1
  else if (!isdrive(src) && *src != '/')
@


1.385
log
@* cygheap.h (cygheap_types): Add HEAP_COMMUNE.
* fhandler_proc.cc: Use cygheap rather than user heap for allocation of filebuf
throughout.
* fhandler_registry.cc: Ditto.
* fhandler_virtual.cc: Ditto.
* fhandler_process.cc: Ditto.
(get_mem_values): Use malloc/realloc/free rather than new.
* pinfo.cc (_pinfo::commune_send): Allocate on cygwin heap rather than user
heap.  Avoid calling ReadFile when correct number of characters have been read
or suffer buffer corruption.
(_pinfo::fd): Allocate on cygwin heap rather than user heap.
(_pinfo::fds): Ditto.
(_pinfo::root): Ditto.
(_pinfo::cwd): Ditto.
(_pinfo::cmdline): Ditto.
* devices.h (FH_DEV): New define.
* devices.in: Detect lone /dev.
* devices.cc: Regenerate.
* path.cc (path_conv::check): Treat FH_DEV as a special case.
@
text
@a643 1
	      fileattr = FILE_ATTRIBUTE_DIRECTORY;
d645 6
a650 1
	      goto out;
d1060 1
a1060 1
  if (dev.devn == FH_FS)
@


1.384
log
@* path.cc (mount): Only check win32_path when we know we need it.
@
text
@d637 1
a638 1
		  fileattr = GetFileAttributes (this->path);
d642 6
@


1.383
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@d2489 1
a2489 1
  else if (!*posix_path || !*win32_path)
d2501 2
@


1.382
log
@* cygtls.h (_cygtls): Perform minor reformatting.
* winsup.h (close_all_files): Reflect argument change.
* dtable.cc (close_all_files): Ditto.
* dtable.h: Ditto.
* fhandler.h: Ditto.
* spawn.cc (spawn_guts): Move close_all_files back to its original location in
first P_OVERLAY test but use argument denoting that handles are only supposed
to be closed, not released (more work to be done here).
* syscalls.cc (close_all_files): Take an argument denoting whether to release
closed files or not.
* path.cc (symlink): Change argument names to reflect linux man page.
(symlink_worker): Ditto.  Also appropriately set ENOENT for empty strings.
@
text
@d1328 1
a1328 1
    (void) strtoul (s + 3, (char **) &p, 10);
d2685 1
a2685 1
      (void) SetFileAttributes (win32_path, FILE_ATTRIBUTE_NORMAL);
d4001 1
a4001 1
  (void) test_file_change (n);
d4055 1
a4055 1
	  (void) FindNextChangeNotification (changed_h);
@


1.381
log
@Replace valid memory checks with new myfault class "exception handling", almost
everywhere.  Leave some thread.cc stuff alone for now.
* cygtls.h: Kludge some definitions to avoid including a problematic windows
header.
(_cygtls::_myfault): New entry.
(_cygtls::_myfault_errno): Ditto.
(_cygtls::fault_guarded): New function.
(_cygtls::setup_fault): Ditto.
(_cygtls::return_from_fault): Ditto.
(_cygtls::clear_fault): Ditto.
(myfault): New class.
* exceptions.cc (handle_exceptions): Handle case of guarded fault in system
routine.
* gendef: Add another entry point for setjmp that the compiler doesn't know
about and won't complain about.
* gentls_offsets: Just include windows.h rather than kludging a HANDLE def.
* miscfuncs.cc (check_null_str): Delete.
(check_null_empty_str): Ditto.
(check_null_empty_str_errno): Ditto.
(check_null_str_errno): Ditto.
(__check_null_invalid_struct): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
(dummytest): New function.
(check_iovec_for_read): Delete.
(chec_iovec): Rename from check_iovec_for_write.  Take a read/write parameter.
* tlsoffsets.h: Regenerate.
* winsup.h: Remove check_* declarations.
(check_iovec_for_read): Delete declaration.  Turn into a define instead.
(check_iovec_for_write): Ditto.
(check_iovec): New declaration.
* thread.h: Use ifdef guard name consistent with other header files.
@
text
@d2618 1
a2618 1
symlink (const char *topath, const char *frompath)
d2620 1
a2620 1
  return symlink_worker (topath, frompath, allow_winsymlinks, false);
d2624 1
a2624 1
symlink_worker (const char *topath, const char *frompath, bool use_winsym,
d2629 1
a2629 1
  path_conv win32_path, win32_topath;
d2632 2
a2633 2
  char w32topath[CYG_MAX_PATH];
  char reltopath[CYG_MAX_PATH] = { 0 };
d2638 2
a2639 2
  /* POSIX says that empty 'frompath' is invalid input while empty
     'topath' is valid -- it's symlink resolver job to verify if
d2644 1
a2644 1
  if (!*topath || !*frompath)
d2646 1
a2646 1
      set_errno (EINVAL);
d2650 1
a2650 1
  if (strlen (topath) >= CYG_MAX_PATH)
d2656 1
a2656 1
  win32_path.check (frompath, PC_SYM_NOFOLLOW);
d2659 1
a2659 1
      strcpy (from, frompath);
d2670 1
a2670 1
  syscall_printf ("symlink (%s, %s)", topath, win32_path.get_win32 ());
d2683 1
a2683 1
      strcpy (w32topath, topath);
d2689 1
a2689 1
      if (!isabspath (topath))
d2698 1
a2698 1
	  backslashify (topath, reltopath, 0);
d2703 1
a2703 1
	  if (GetFileAttributes (reltopath) == INVALID_FILE_ATTRIBUTES)
d2705 3
a2707 3
	      win32_topath.check (topath, PC_SYM_NOFOLLOW);
	      if (win32_topath.error != ENOENT)
		strcpy (use_winsym ? reltopath : w32topath, win32_topath);
d2710 1
a2710 1
	    strcpy (w32topath, reltopath);
d2713 2
a2714 2
	      win32_topath.check (topath, PC_SYM_NOFOLLOW);
	      strcpy (w32topath, win32_topath);
d2724 2
a2725 2
	  win32_topath.check (topath, PC_SYM_NOFOLLOW);
	  strcpy (w32topath, win32_topath);
d2764 1
a2764 1
	      MultiByteToWideChar (CP_ACP, 0, w32topath, -1, wc_path,
d2783 2
a2784 2
	  *(unsigned short *)cp = len = strlen (topath);
	  memcpy (cp += 2, topath, len);
d2787 1
a2787 1
	  if (reltopath[0])
d2789 2
a2790 2
	      *(unsigned short *)cp = len = strlen (reltopath);
	      memcpy (cp += 2, reltopath, len);
d2794 2
a2795 2
	      *(unsigned short *)cp = len = strlen (w32topath);
	      memcpy (cp += 2, w32topath, len);
d2806 1
a2806 1
	  __small_sprintf (buf, "%s%s", SYMLINK_COOKIE, topath);
d2831 1
a2831 1
	    set_symlink_ea (win32_path, topath);
d2843 2
a2844 2
  syscall_printf ("%d = symlink_worker (%s, %s, %d, %d)", res, topath,
		  frompath, use_winsym, isdevice);
@


1.380
log
@	* path.cc (path_conv::check): Don't strip trailing dots and spaces
	at the start of the path.
@
text
@d545 6
d563 6
a568 2
  else if ((error = check_null_empty_str (src)))
    return;
d2486 2
a2487 1
  if (check_null_empty_str_errno (posix_path))
d2489 2
d2501 1
a2501 1
  else if (!check_null_empty_str_errno (win32_path))
d2516 2
a2517 1
  if (check_null_empty_str_errno (path))
d2519 5
d2641 2
a2642 2
  if (check_null_empty_str_errno (topath) == EFAULT ||
      check_null_empty_str_errno (frompath))
d2644 5
d3451 4
a3454 1
  if (ulen == 0 && buf)
d3456 1
a3456 1
  else if (buf == NULL || !__check_null_invalid_struct_errno (buf, ulen))
d3472 2
a3473 1
  if (check_null_empty_str_errno (in_dir))
d3475 5
d3602 2
a3603 1
  if (check_null_empty_str_errno (path))
d3605 5
d3616 2
a3617 1
  if (check_null_empty_str_errno (path))
d3619 5
@


1.379
log
@* path.cc (path_conv::check): Always reset to FH_FS when component != 0 and
FH_NETDRIVE to fix problems with strict case checking.
@
text
@d931 1
a931 1
	  if (!tail)
@


1.378
log
@	* path.cc (symlink_info::check): If GetFileAttributes returns
	with ERROR_SHARING_VIOLATION, the file exists.
@
text
@d889 9
d900 2
a901 14
      if (dev.devn == FH_NETDRIVE && component)
        {
	  /* This case indicates a non-existant resp. a non-retrievable
	     share.  This happens for instance if the share is a printer.
	     In this case the path must not be treated like a FH_NETDRIVE,
	     but like a FH_FS instead, so the usual open call for files
	     is used on it. */
	  dev.parse (FH_FS);
	}
      else
        {
	  error = dev.devn == FH_NETDRIVE ? ENOSHARE : ENOENT;
	  return;
	}
@


1.377
log
@	* path.cc (path_conv::check): Move component to function scope. Set
	PATH_RO only on *real* FH_NETDRIVEs or on non-FH_NETDRIVE virtual
	paths. Allow non-retrievable shares to be handled as files.
@
text
@d3162 5
a3166 1
	     GetLastError returns ERROR_INVALID_FUNCTION.  Go figure! */
d3170 6
a3179 1

@


1.376
log
@white space
@
text
@d553 1
d586 1
a586 1
      int component = 0;		// Number of translated components
d675 2
a676 1
	      path_flags |= PATH_RO;
d891 14
a904 2
      error = dev.devn == FH_NETDRIVE ? ENOSHARE : ENOENT;
      return;
@


1.375
log
@* path.cc (path_conv::check): Remove embedded dots before slashes.
@
text
@d1526 1
a1526 1
  if (src_path[1] == '/') 
@


1.374
log
@* path.cc (normalize_posix_path): Do normalization on .  and ..  after a '//'.
@
text
@d914 2
a915 2
		error = ENOENT;
		return;
@


1.373
log
@Remove PC_FULL from path_conv usage throughout.
* path.h (enum pathconv_arg): Change PC_FULL to PC_NOUILL.
* path.cc (path_conv::check): Test for PC_NOFULL rather than !PC_FULL.
(cygwin_conv_to_win32_path): Use PC_NOFULL to force non-absolute path.
@
text
@d240 1
a240 5
    {
      *tail++ = '/';
      *tail++ = '/';
      src += 2;
    }
@


1.372
log
@* cygtls.cc (_cygtls::remove): Eliminate compiler warning.
* dir.cc (mkdir): Check path for writability.
(rmdir): Ditto.  Remove check for special directories.
* path.cc (path_conv::check): Set PATH_RO for virtual devices.  Set error if
read-only and asked for writability.
* path.h (pathconv_arg): Add PC_WRITABLE.
(path_types): Add PATH_RO.
(path_conv::isro): Add (currently unused) check for read-only filesystem.
Return "ENOSHARE" when we know a share doesn't exist.
* include/sys/mount.h: Add MOUNT_RO flag.
* autoload.cc (WNetGetResourceInformationA): Import.
* fhandler_netdrive.cc (fhandler_netdrive::exists): Detect actual existence of
remote system rather than always assuming that it exists.
@
text
@d959 1
a959 1
  if (!(opt & PC_FULL))
d2682 1
a2682 1
	      win32_topath.check (topath, PC_FULL | PC_SYM_NOFOLLOW);
d2693 1
a2693 1
	  win32_topath.check (topath, PC_FULL | PC_SYM_NOFOLLOW);
d3436 1
a3436 1
  path_conv path (PC_NONULLEMPTY, in_dir, PC_FULL | PC_SYM_FOLLOW | PC_POSIX);
d3521 1
a3521 1
  path_conv p (path, PC_SYM_FOLLOW | PC_NO_ACCESS_CHECK);
d3536 1
a3536 1
  path_conv p (path, PC_SYM_FOLLOW | PC_FULL | PC_NO_ACCESS_CHECK);
d3574 1
a3574 1
  path_conv real_path (path, PC_SYM_FOLLOW | PC_FULL, stat_suffixes);
d3627 1
a3627 1
  path_conv pc(".", PC_FULL | PC_POSIX);
@


1.371
log
@	* path.cc (path_conv::check): Set correct file attributes for socket
	files.
@
text
@d678 1
d885 6
a890 4
  if (!need_directory || error)
    /* nothing to do */;
  else if (fileattr & FILE_ATTRIBUTE_DIRECTORY)
    path_flags &= ~PATH_SYMLINK;
d893 1
a893 1
      error = ENOENT;
d896 4
@


1.370
log
@2005-05-09  Pierre Humblet <pierre.humblet@@ieee.org>

        * fhandler.h (class fhandler_netdrive): New class.
        * fhandler_netdrive.cc (fhandler_netdrive::fhandler_netdrive): New constructor.
        (fhandler_netdrive::exists): New method.
        (fhandler_netdrive::fstat): Ditto.
        (fhandler_netdrive::readdir): Ditto.
        (fhandler_netdrive::open): Ditto.
        * dtable.cc (build_fh_pc): Handle case FH_NETDRIVE.
        * path.cc (isvirtual_dev): Add FH_NETDRIVE.
        (mount_info::conv_to_win32_path): Detect netdrive device and bypass mount
        search for network paths.
@
text
@d723 1
a723 1
	      fileattr = 0;
@


1.369
log
@* path.cc (normalize_posix_path): Don't treat '//' specially since newer
versions of bash now get this right.
@
text
@d157 2
a158 1
  (devn == FH_CYGDRIVE || devn == FH_PROC || devn == FH_REGISTRY || devn == FH_PROCESS)
d1521 13
@


1.368
log
@move comment
@
text
@d238 1
a238 1
  else if (isslash (src[1]) && src[2] && !isslash (src[2]))
@


1.367
log
@white space and minor comment cleanup.
@
text
@a1518 2
  /* Check if the cygdrive prefix was specified.  If so, just strip
     off the prefix and transform it into an MS-DOS path. */
d1530 2
@


1.366
log
@revert erroneous checkin
@
text
@d592 1
a592 1
      
d640 1
a640 1
	        {
d759 3
a761 3
                  else if (!(sym.fileattr & FILE_ATTRIBUTE_DIRECTORY))
                    {
                      error = ENOTDIR;
d763 1
a763 1
                    }
d2512 1
a2512 1
  	 || strcasematch (dev, "A:");
d2655 1
a2655 1
	        strcpy (use_winsym ? reltopath : w32topath, win32_topath);
d2671 1
a2671 1
        {
d2805 1
a2805 1
         == (WSH_FLAG_DESC | WSH_FLAG_RELPATH)
d4017 1
a4017 1
        {
d4055 1
a4055 1
        {
d4062 1
a4062 1
        strcpy (bs, ".");
d4068 1
a4068 1
        }
d4070 1
a4070 1
        c[1] = '\0';
@


1.365
log
@* sigproc.cc (proc_subproc): Fix handling of waiting for pids with zero value.
* strace.cc (strace::hello): Report parent pid of executing process.
@
text
@a4075 13

muto path_uglification::locker;

path_uglification::~path_uglification ()
{
  if (locker.ismine ())
    locker.release ();
}

win_path::win_path (const char *_path)
{
  path = _path;
}
@


1.364
log
@* path.cc (path_conv::check): Fix problem reading symlinks introduced in below
change by reverting the change and adding an additional test for nonexistent
files in /proc.
@
text
@d4076 13
@


1.363
log
@* path.cc (path_conv::check): Punt when attempting to access a nonexistent
directory or file in /proc.
@
text
@d534 1
a534 1
  int is_relpath;
d649 2
a650 1
		    fileattr = FILE_ATTRIBUTE_DIRECTORY;
d653 2
a654 1
		    fileattr = 0;
d659 5
a663 2
		    fileattr = 0;
		    dev.parse (FH_PIPE);
d666 5
a670 2
		    fileattr = 0;
		    dev.parse (FH_TCP);
d673 3
a675 3
		    fileattr = INVALID_FILE_ATTRIBUTES;
		    error = ENOENT;
		    break;
a804 1

d887 5
@


1.362
log
@	* fhandler_disk_file.cc (fhandler_base::utimes_fs): Ignore
	ERROR_NOT_SUPPORTED to workaround Win9x weirdness.
	* path.cc (symlink_info::check): Remap ERROR_INVALID_FUNTION to
	ERROR_FILE_NOT_FOUND for the same reason.
@
text
@d666 2
a667 1
		    goto virtual_component_retry;
@


1.361
log
@* sync.h (muto::operator int): New operator.
(locker): Remove unused class.
(new_muto): Delete.
(new_muto1): Ditto.
(new_muto_name): Ditto.
* cygheap.cc (cygheap_setup_for_child): Reflect use of static storage for muto
rather than pointer.
(_csbrk): Ditto.
(_cmalloc): Ditto.
(_cmalloc): Ditto.
(_cfree): Ditto.
* cygheap.h (cwdstuff::cwd_lock): Ditto.
(cwdstuff::get_drive): Ditto.
* cygmalloc.h (__malloc_lock): Ditto.
(__malloc_unlock): Ditto.
* cygtls.cc (sentry::lock): Ditto.
(sentry::sentry): Ditto.
(~sentry): Ditto.
(_cygtls::init): Ditto.
* dcrt0.cc: Ditto.
(cygwin_atexit): Ditto.
(cygwin_exit): Ditto.
* debug.cc (lock_debug::locker): Ditto.
(lock_debug::lock_debug): Ditto.
(lock_debug::unlock): Ditto.
(debug_init): Ditto.
* dtable.cc (dtable::init_lock): Ditto.
* dtable.h (dtable::lock_cs): Ditto.
(dtable::lock): Ditto.
(dtable::unlock): Ditto.
* exceptions.cc (mask_sync): Ditto.
(sighold): Ditto.
(set_process_mask_delta): Ditto.
(set_signal_mask): Ditto.
(events_init): Ditto.
* grp.cc (pwdgrp::pwdgrp): Ditto.
* malloc_wrapper.cc (mallock): Ditto.
(malloc_init): Ditto.
* path.cc (cwdstuff::cwd_lock): Ditto.
(cwdstuff::get_hash): Ditto.
(cwdstuff::get_hash): Ditto.
(cwdstuff::init): Ditto.
(cwdstuff::set): Ditto.
(cwdstuff::get): Ditto.
* pwdgrp.h (pwdgrp::pglock): Ditto.
(pwdgrp::refresh): Ditto.
* sigproc.cc (sync_proc_subproc): Ditto.
(get_proc_lock): Ditto.
(proc_subproc): Ditto.
(_cygtls::remove_wq): Ditto.
(proc_terminate): Ditto.
(sigproc_init): Ditto.
* timer.cc (lock_timer_tracker::protect): Ditto.
(lock_timer_tracker::lock_timer_tracker): Ditto.
(lock_timer_tracker::~lock_timer_tracker): Ditto.
* wininfo.cc (wininfo::_lock;): Ditto.
(wininfo::winthread): Ditto.
(operator HWND): Ditto.
(wininfo::lock): Ditto.
(wininfo::release): Ditto.
* wininfo.h (wininfo::_lock;): Ditto.
@
text
@d3115 8
a3122 1
	  set_error (geterrno_from_win_error (GetLastError (), EACCES));
@


1.360
log
@* path.cc (path_conv::check): Only check for PC_NO_ACCESS_CHECK in end
component.
@
text
@d107 2
d3733 1
a3733 1
  cwd_lock->acquire ();
d3735 1
a3735 1
  cwd_lock->release ();
d3743 1
a3743 1
  new_muto (cwd_lock);
d3751 1
a3751 1
  cwd_lock->acquire ();
d3771 1
a3771 1
       cwd_lock->acquire ();
d3828 1
a3828 1
    cwd_lock->release ();
d3872 1
a3872 1
  cwd_lock->release ();
@


1.359
log
@	* cygheap.cc (cygheap_init): Accomodate set_process_privilege change.
	* cygheap.h (cygheap_user::curr_primary_token): New member.
	(cygheap_user::primary_token): New method.
	(cygheap_user::deimpersonate): Always revert to processes'
	impersonation token.
	(cygheap_user::reimpersonate): Set processes' or setuid token as
	necessary.
	(cygheap_user::has_impersonation_tokens): Look for curr_primary_token
	value.
	(cygheap_user::close_impersonation_tokens): Close curr_primary_token
	here if necessary.  Don't reset token values to NO_IMPERSONATION since
	that's done in uinfo_init anyway.
	(init_cygheap::luid): New LUID array keeping privilege LUIDs.
	* cygtls.cc (_cygtls::init_thread): Call cygheap->user.reimpersonate.
	* dcrt0.cc (hProcToken): New global variable to keep process token.
	(hProcImpToken): Ditto for process impersonation token.
	(dll_crt0_0): Open process token here once.  Duplicate to create
	hProcImpToken.
	(dll_crt0_1): Call set_cygwin_privileges.
	* environ.cc (allow_ntea): Drop duplicate declaration.
	(allow_smbntsec): Ditto.
	(set_traverse): Only set allow_traverse here.
	(environ_init): Ditto.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Drop call to
	enable_restore_privilege.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl): Ditto.
	* fork.cc (fork_child): Move call to cygheap->user.reimpersonate after
	syn with parent. Call set_cygwin_privileges.
	* grp.cc (internal_getgroups): Use hProcImpToken instead of opening
	process token.
	* path.cc (fs_info::update): Bypass traverse checking when retrieving
	volume information using push/pop_thread_privileges.
	* registry.cc (load_registry_hive): Drop setting restore privilege
	since it's already set if available.
	* sec_helper.cc: Include cygtls.h.
	(cygpriv): Privilege string array.
	(privilege_luid): New function, evaluate LUID from cygpriv_idx.
	(privilege_luid_by_name): New function, evaluate LUID from privilege
	string.
	(privilege_name): New function, evaluate privilege string from
	cygpriv_idx.
	(set_privilege): New static function called by set_process_privilege
	and set_thread_privilege.  Call privilege_luid to get privilege LUID.
	Fix bug in return value evaluation. Improve debug output.
	(set_cygwin_privileges): New function.
	(set_process_privilege): Remove.
	(enable_restore_privilege): Remove.
	* security.cc (allow_traverse): New global variable.
	(sys_privs): Change type to cygpriv_idx and store privilege indices
	instead of strings.
	(SYSTEM_PRIVILEGES_COUNT): Renamed from SYSTEM_PERMISSION_COUNT.
	(get_system_priv_list): Don't use numerical constant in malloc call.
	Use privilege_luid to get privilege LUIDs.
	(get_priv_list): Call privilege_luid_by_name to get LUIDs. Improve
	inner privilege LUID comparison loop.
	(create_token): Enable create token privilege using
	push/pop_self_privileges. Use hProcToken instead of opening process
	token. Use default DACL when duplicating token.
	(subauth): Enable tcb privilege using push/pop_self_privileges.
	Use sec_none instead of homw made security attributes when duplicating
	token.
	(check_file_access): Don't duplicate access token, use active
	impersonation token as is.
	* security.h (enum cygpriv_idx): New enumeration type enumerating
	possible privileges.
	(privilege_luid): Declare new function.
	(privilege_luid_by_name): Ditto.
	(privilege_name): Ditto.
	(allow_traverse): Declare.
	(set_privilege): Declare function.
	(set_process_privilege): Define as macro.
	(enable_restore_privilege): Remove declaration.
	(_push_thread_privilege): Define macro.
	(push_thread_privilege): Ditto.
	(pop_thread_privilege): Ditto.
	(pop_self_privilege): Ditto.
	* spawn.cc (spawn_guts): Use cygheap->user.primary_token instead of
	cygheap->user.token.
	* syscalls.cc (statvfs): Bypass traverse checking when retrieving
	volume information using push/pop_thread_privileges. Rearrange code
	to simplify push/pop bracketing.
	(seteuid32): Use hProcToken instead of opening process token. Call
	cygheap->user.deimpersonate instead of RevertToSelf.  Create
	impersonation token from primary internal or external token.  Set
	cygheap->user.curr_primary_token and cygheap->user.current_token
	privileges once here.  Drop "failed" and "failed_ptok" labels.
	Drop setting DefaultDacl of process token.
	(setegid32): Use hProcToken and hProcImpToken instead of opening
	process token. Always reimpersonate afterwards.
	* uinfo.cc (cygheap_user::init): Use hProcToken instead of opening
	process token.
	(internal_getlogin): Ditto. Set hProcImpToken, too.
	(uinfo_init): Initialize cygheap->user.curr_primary_token.
	* winsup.h (hProcToken): Declare.
	(hProcImpToken): Declare.
@
text
@a558 1
  unsigned pflags_or = (opt & PC_NO_ACCESS_CHECK);
d590 2
a591 1
      for (;;)
d785 1
a785 1
	      else if (sym.error != ENOENT && sym.error != ENOSHARE)
@


1.358
log
@	Unify usage of CYG_MAX_PATH throughout.  Change buffers from
	size CYG_MAX_PATH + 1 to CYG_MAX_PATH.  Change length tests
	accordingly.
@
text
@d351 1
d376 4
d388 6
a393 3
  if (!GetVolumeInformation (root_dir, NULL, 0, &status.serial, NULL,
			     &status.flags, fsname, sizeof (fsname))
      && !is_remote_drive ())
d401 1
@


1.357
log
@	* path.cc (symlink_info::case_check): Ignore trailing characters
	in paths when comparing case.
@
text
@d528 1
a528 1
  static char last_src[CYG_MAX_PATH + 1];
d1410 1
a1410 1
      if ((n + strlen (p)) > CYG_MAX_PATH)
d1734 1
a1734 1
	  char tmpbuf[CYG_MAX_PATH + 1];
d2560 3
a2562 3
  char cwd[CYG_MAX_PATH + 1], *cp = NULL, c = 0;
  char w32topath[CYG_MAX_PATH + 1];
  char reltopath[CYG_MAX_PATH + 1] = { 0 };
d2615 1
a2615 1
	  getcwd (cwd, CYG_MAX_PATH + 1);
d2674 1
a2674 1
	  WCHAR wc_path[CYG_MAX_PATH + 1];
d2689 1
a2689 1
				   CYG_MAX_PATH + 1);
d2812 1
a2812 1
  if ((len = *(unsigned short *) cp) == 0 || len > CYG_MAX_PATH)
d2850 1
a2850 1
      res = ReadFile (h, contents, CYG_MAX_PATH + 1, &got, 0);
d3969 1
a3969 1
  static char buf[CYG_MAX_PATH + 1];
d4007 1
a4007 1
  static char buf[CYG_MAX_PATH + 1];
@


1.356
log
@	* path.cc (is_floppy): Make externally available.
	* path.h (is_floppy): Declare.
	* syscalls.cc (sync): Check for floppies on A: and B: in guid case.
	Don't call setmntent in non-guid case but evaluate drive bit mask
	locally.
@
text
@d3233 1
a3233 1
      if (strcmp (c, data.cFileName))
@


1.355
log
@* path.h (pathconv_arg): Define PC_NO_ACCESS_CHECK.
(path_types): Define PATH_NO_ACCESS_CHECK == PC_NO_ACCESS_CHECK.
* path.cc (symlink_info::check_sysfile): Move to symlink_info class and
eliminate arguments that are part of class.  Use set_error.
(symlink_info::check_shortcut): Ditto.
(symlink_info::set_error): New function.
(path_conv::check): Pass PC_NO_ACCESS_CHECK to symlink_info::check.
(symlink_info::check): Preserve PC_NO_ACCESS_CHECK in pflags.  Use set_error.
@
text
@d2481 1
a2481 1
static bool
@


1.354
log
@	* path.cc (is_floppy): New function.
	(setmntent): Drop floppy drives on A: and B: from logical drive DWORD.
	* syscalls.cc (sync): Don't sync floppies on A: and B:.
@
text
@d102 3
d550 1
d610 2
d776 1
a776 1
	      else if (sym.error != ENOENT && sym.error != ENOSHARE) /* E. g. EACCES */
d2785 2
a2786 3
static int
check_shortcut (const char *path, DWORD fileattr, HANDLE h,
		char *contents, int *error, unsigned *pflags)
d2803 1
a2803 1
      *error = EIO;
d2818 1
a2818 1
    *pflags = PATH_SYMLINK | PATH_LNK;
d2823 2
a2824 2
  if (!(*pflags & PATH_ALL_EXEC) && has_exec_chars ((const char *) &file_header, got))
    *pflags |= PATH_EXEC;
d2832 2
a2833 3
static int
check_sysfile (const char *path, DWORD fileattr, HANDLE h,
	       char *contents, int *error, unsigned *pflags)
d2842 1
a2842 1
      *error = EIO;
d2848 1
a2848 1
      *pflags = PATH_SYMLINK;
d2854 1
a2854 1
	  *error = EIO;
d2873 1
a2873 1
    *pflags |= PATH_SOCKET;
d2877 1
a2877 1
      if (*pflags & PATH_ALL_EXEC)
d2880 1
a2880 1
	*pflags |= PATH_EXEC;
d2882 1
a2882 1
	*pflags |= PATH_NOTEXEC;
d2885 1
a2885 1
		  res, path, contents, *pflags);
d3008 8
d3090 1
d3104 1
a3104 1
	  error = geterrno_from_win_error (GetLastError (), EACCES);
d3138 1
a3138 1
	  pflags = PATH_SYMLINK;
d3158 1
a3158 1
	  res = check_shortcut (suffix.path, fileattr, h, contents, &error, &pflags);
d3173 1
a3173 1
	  res = check_sysfile (suffix.path, fileattr, h, contents, &error, &pflags);
d3469 1
a3469 1
  path_conv p (path, PC_SYM_FOLLOW);
d3484 1
a3484 1
  path_conv p (path, PC_SYM_FOLLOW | PC_FULL);
@


1.353
log
@* path.cc (path_conv::check): Treat ENOSHARE similarly to ENOENT when
determining if there was a problem with a symlink.
@
text
@d2475 10
d2490 5
@


1.352
log
@* path.cc (mount_info::read_cygdrive_info_from_registry): Use the user prefix
if it exists.
* sync.h (sync::init_lock): Declare new static member.
(sync::init()): Declare new static function.
* sync.cc (sync::init): Define.
(sync::init): Lock attempt to initialize a muto to stop multiple threads from
colliding.
* dcrt0.cc (dll_crt0_0): Initialize muto environment.
@
text
@d381 2
a382 1
			     &status.flags, fsname, sizeof (fsname)))
d770 1
a770 1
	      else if (sym.error != ENOENT) /* E. g. EACCES */
@


1.351
log
@* path.cc (special_name): Reorganize to always detect the use of special names
first, before detecting special characters.
@
text
@d1959 1
@


1.350
log
@* sigproc.cc (_pinfo::set_ctty): Move function
* pinfo.cc (_pinfo::set_ctty): to here.
* fhandler_mem.cc (fhandler_dev_mem::fstat): Don't fill out structure if this
is an on-disk device rather than an "auto" device.
* fhandler_raw.cc (fhandler_dev_raw::fstat): Ditto.
* path.cc (normalize_posix_path): Don't treat a standalone '//' as introducing
a UNC path.
(normalize_win32_path): Ditto.
@
text
@a1257 2
  if (strpbrk (s, special_chars))
    return !strncasematch (s, "%2f", 3);
d1259 1
a1259 1
  if (strcasematch (s, ".") || strcasematch (s, ".."))
a1260 6
  if (s[strlen (s)-1] == '.')
    return true;

  const char *p;
  if (strcasematch (s, "conin$") || strcasematch (s, "conout$"))
    return -1;
d1262 5
a1266 1
  if (strncasematch (s, "nul", 3)
d1270 1
a1270 1
    p = s + 3;
d1273 2
a1274 2
  else
    return false;
d1276 2
a1277 1
  return (*p == '\0' || *p == '.') ? -1 : false;
@


1.349
log
@	* cygwin.din (basename): Export.
	(dirname): Export.
	* path.cc (basename): New function.
	(dirname): New function.
	* include/libgen.h: New file.
	* include/cygwin/version.h: Bump API minor version.
@
text
@d233 1
a233 1
  else if (isslash (src[1]) && !isslash (src[2]))
d1026 1
a1026 1
  if (beg_src_slash && isdirsep (src[1]))
@


1.348
log
@* path.cc (path_conv::check): Set fs flag when a unix-domain socket is
detected.
@
text
@d56 1
d3934 84
@


1.347
log
@white space
@
text
@d696 1
@


1.346
log
@	* path.cc (path_conv::check): Leave symlink expansion loop in case
	a not-ENOENT error happens.

	* cygheap.h (cygheap_fdmanip::fhandler_pipe *): New cast operator.
	* pinfo.cc (_pinfo::commune_recv): Add PICOM_PIPE_FHANDLER handling.
	(_pinfo::commune_send): Ditto.
	(_pinfo::pipe_fhandler): New method.
	* pinfo.h (enum picom): Add PICOM_PIPE_FHANDLER.
	(_pinfo::pipe_fhandler): Declare.
	* pipe.cc (fhandler_pipe::open): Rewrite.  Allow to open foreign
	pipe handles.
@
text
@d734 1
a734 1
                    }	
d1941 1
a1941 1
	cygheap->user.deimpersonate ();	
d1957 1
a1957 1
	cygdrive_flags |= MOUNT_SYSTEM;	
@


1.345
log
@* cygthread.cc (cygthread::terminate_thread): Wait briefly for notification
event in the event that the thread was actually in the process of exiting.
* pipe.cc (fhandler_pipe::dup): read_state is not supposed to be inheritable.
Fix that.
* path.cc (path_conv::check): Set symlen = 0 to avoid a compiler warning.
* devices.h (devices::parsedisk): Declare new function.
* devices.in (devices::parsedisk): Define new function.
* dtable.cc (dtable::init_std_file_from_handle): Use device numbers rather than
name.
* fhandler_proc.cc (format_proc_partitions): Use parsedisk to generate disk
names from numeric codes.  (This was broken on two of my systems previously and
is still broken now)
@
text
@d767 5
@


1.344
log
@	* fhandler.cc (fhandler_base::get_proc_fd_name): Don't generate
	"device:" entry.
	* fhandler.h (fhandler_socket::open): New method.
	(fhandler_pipe::open): New method.
	* fhandler_proc.cc (fhandler_proc::exists): Return -2 in case of
	/proc/self.
	* fhandler_process.cc (fhandler_process::exists): Return -2 in
	case of symlinks, -3 for pipes and -4 for sockets.
	(fhandler_process::fstat): Handle pipes and sockets.
	(fhandler_process::open): Handle opening /proc/<pid>/fd.
	(fhandler_process::fill_filebuf): Generate empty names for
	non exisiting file descriptors.
	* fhandler_socket.cc (fhandler_socket::get_proc_fd_name): Always
	generate "socket:[number]" strings as on Linux.
	(fhandler_socket::open): New method.
	(fhandler_socket::fstat): Always return socket type.
	* path.cc (symlink_info::set): Remove unused second parameter.
	(path_conv::check): Handle pipes and sockets in /proc.
	Set correct device type for AF_LOCAL sockets.
	* pinfo.cc (_pinfo::commune_recv): Generate empty names for
	non exisiting file descriptors.
	(_pinfo::fd): Ditto.
	* pipe.cc (fhandler_pipe::open): New method.
@
text
@d575 1
a575 1
      int symlen;
@


1.343
log
@* path.h (path_conv::set_name): Declare new function.
* path.cc (path_conv::set_name): Define new function.
* fhandler.h (fhandler_dev_null::open): Declare new function.
* fhandler.cc (fhandler_dev_null::open): Define new function.
@
text
@d98 1
a98 1
  int set (char *path, int type);
d620 1
a620 1
	      if (file_type == -2 || file_type == -3)
d623 1
a623 1
		  symlen = sym.set (fh->get_filebuf (), file_type);
d635 1
a635 2
		  case -2:	/* /proc/<pid>/symlinks */
		  case -3:	/* /proc/self */
d637 8
d688 10
a697 1
	    dev.setfs (1);
d3161 1
a3161 1
symlink_info::set (char *path, int type)
@


1.342
log
@	* cygheap.h (class cygheap_fdenum): New class to enumerate used
	fhandlers.
	* dtable.h (class dtable): Add cygheap_fdenum as friend class.
	* fhandler.h (fhandler_base::get_proc_fd_name): New virtual method
	to return a name for /proc/<pid>/fd.
	(fhandler_socket::get_proc_fd_name): Ditto.
	(fhandler_pipe::get_proc_fd_name): Ditto.
	(fhandler_virtual::opendir): Make virtual method.
	(fhandler_process::opendir): New method.
	* fhandler.cc (fhandler_base::get_proc_fd_name): New method.
	* fhandler_process.cc: Include ctype.h.
	(PROCESS_FD): Define.
	(process_listing): Add "fd".
	(fhandler_process::exists): Fix comment.  Return 1 in case of "fd"
	directory. Handle files below "fd".
	(fhandler_process::fstat): Drop "self" handling.  Set correct link
	count for directories.
	(fhandler_process::opendir): New method to handle "fd" directory.
	(fhandler_process::readdir): Add "fd" handling.
	(fhandler_process::open): Drop "self" handling.
	(fhandler_process::fill_filebuf): Ditto.  Add "fd" handling.  Fix
	"maps" output string.
	* fhandler_registry.cc (fhandler_registry::fstat): Set correct link
	count for directories.
	* fhandler_socket.cc (fhandler_socket::get_proc_fd_name): New method.
	* path.cc (symlink_info::set): Fix thinko.
	* pinfo.cc (_pinfo::commune_recv): Rename pathbuf to path throughout.
	Drop local path variable in PICOM_FIFO case.  Fix debug output.
	Close handles as early as possible. Add PICOM_FDS and PICOM_FD
	handling.
	(_pinfo::commune_send): Add PICOM_FDS and PICOM_FD handling.
	(_pinfo::fd): New method.
	(_pinfo::fds): New method.
	* pinfo.h (enum picom): Add PICOM_FDS and PICOM_FD.
	(_pinfo::fd): Declare.
	(_pinfo::fds): Declare.
	* pipe.cc (fhandler_pipe::get_proc_fd_name): New method.
@
text
@d945 9
@


1.341
log
@	* autoload.cc (GetModuleFileNameExA): Add.
	(GetModuleInformation): Add.
	(QueryWorkingSet): Add.
	* fhandler.h (fhandler_virtual::get_filebuf): New method.
	* fhandler_proc.cc (PROC_SELF): Define.
	(proc_fhandlers): Change type of self to FH_PROC.
	(fhandler_proc::exists): Return -3 if self.
	(fhandler_proc::fstat): Handle self as symlink.
	(fhandler_proc::fill_filebuf): Handle self.
	* fhandler_process.cc: Include psapi.h.
	(PROCESS_EXENAME): Remove.
	(PROCESS_MAPS): Define.
	(PROCESS_ROOT): Define.
	(PROCESS_EXE): Define.
	(PROCESS_CWD): Define.
	(process_listing): Remove "exename", add "maps, "root", "exe" and
	"cwd" elements.
	(fhandler_process::exists): Return -2 for symlinks.
	(fhandler_process::fstat): Handle symlinks.
	(fill_filebuf): Evaluate pid if pid is 0.  Use exename handling for
	exe.  Handle maps, root and cwd.
	(format_process_maps): New function evaluating "maps".
	* path.cc (symlink_info::set): New method to fill symlink_info
	with data matching virtual symlinks.
	(path_conv::check): Handle virtual symlinks.
	* pinfo.cc (_pinfo::commune_recv): Add PICOM_CWD and PICOM_ROOT
	handling.
	(_pinfo::commune_send): Ditto.
	(_pinfo::root): New function.
	(_pinfo::cwd): New function.
	* pinfo.h (enum picom): Add PICOM_CWD and PICOM_ROOT.
	(_pinfo::root): Declare.
	(_pinfo::cwd): Declare.
@
text
@a3137 2
  extern suffix_info stat_suffixes[];

d3140 2
a3141 12
  if (type == -3) /* /proc/self */
    {
      fileattr = FILE_ATTRIBUTE_DIRECTORY;
      error = 0;
    }
  else
    {
      /* That's save since a virtual symlink doesn't point to itself. */
      path_conv pc (contents, PC_SYM_NOFOLLOW | PC_FULL, stat_suffixes);
      fileattr = pc;
      error = pc.error;
    }
@


1.340
log
@2005-01-26  Pierre Humblet <pierre.humblet@@ieee.org>

	* path.cc (path_conv::check): Return ENOTDIR rather than ENOENT
	when a component is not a directory. Remove unreachable code.
	(digits): Delete.
@
text
@d98 1
d620 5
d635 3
d640 1
a640 1
		    break;
d669 2
d754 2
d3133 28
@


1.339
log
@	* path.cc (realpath): Allow to expand with .exe suffix.
@
text
@a657 6
	  if ((opt & PC_SYM_IGNORE) && pcheck_case == PCHECK_RELAXED)
	    {
	      fileattr = GetFileAttributes (this->path);
	      goto out;
	    }

d703 5
a940 9
static __inline int
digits (const char *name)
{
  char *p;
  int n = strtol (name, &p, 10);

  return p > name && !*p ? n : -1;
}

@


1.338
log
@	* autoload.cc (CoInitialize): Remove.
	(CoUninitialize): Remove.
	(CoCreateInstance): Remove.
	(CoTaskMemFree): Add.
	(SHGetDesktopFolder): Add.
	* path.cc (shortcut_header): Remove.
	(shortcut_initalized): Remove.
	(GUID_shortcut): New static GUID.
	(struct win_shortcut_hdr): New struct describing Windows shortcut
	header structure.
	(symlink_worker): Rewrite creating Windows shortcuts.  Create
	ITEMIDLIST if target exists.  Only write once.
	(cmp_shortcut_header): Use win_shortcut_hdr structure for comparison.
	(check_shortcut): Rewrite to read only once from file.  Allow skipping
	an ITIMIDLIST in the file.
@
text
@d3441 1
d3444 1
a3444 1
  path_conv real_path (path, PC_SYM_FOLLOW | PC_FULL);
@


1.337
log
@update copyright
@
text
@d62 1
d104 2
a105 2
static char shortcut_header[SHORTCUT_HDR_SIZE];
static bool shortcut_initalized;
d107 29
a135 16
static void
create_shortcut_header (void)
{
  if (!shortcut_initalized)
    {
      shortcut_header[0] = 'L';
      shortcut_header[4] = '\001';
      shortcut_header[5] = '\024';
      shortcut_header[6] = '\002';
      shortcut_header[12] = '\300';
      shortcut_header[19] = 'F';
      shortcut_header[20] = '\f';
      shortcut_header[60] = '\001';
      shortcut_initalized = true;
    }
}
d2507 1
d2512 1
a2512 1
  /* POSIX says that empty 'frompath' is invalid input whlie empty
d2567 23
a2589 1
	  backslashify (topath, w32topath, 0);
d2591 4
a2594 10
      if (!cp || GetFileAttributes (w32topath) == INVALID_FILE_ATTRIBUTES)
	{
	  win32_topath.check (topath, PC_SYM_NOFOLLOW);
	  if (!cp || win32_topath.error != ENOENT)
	    strcpy (w32topath, win32_topath);
	}
      if (cp)
	{
	  *cp = c;
	  chdir (cwd);
d2609 1
a2609 1
      BOOL success;
d2613 56
a2668 16
	  create_shortcut_header ();
	  /* Don't change the datatypes of `len' and `win_len' since
	     their sizeof is used when writing. */
	  unsigned short len = strlen (topath);
	  unsigned short win_len = strlen (w32topath);
	  success = WriteFile (h, shortcut_header, SHORTCUT_HDR_SIZE,
			       &written, NULL)
		    && written == SHORTCUT_HDR_SIZE
		    && WriteFile (h, &len, sizeof len, &written, NULL)
		    && written == sizeof len
		    && WriteFile (h, topath, len, &written, NULL)
		    && written == len
		    && WriteFile (h, &win_len, sizeof win_len, &written, NULL)
		    && written == sizeof win_len
		    && WriteFile (h, w32topath, win_len, &written, NULL)
		    && written == win_len;
d2718 1
a2718 1
cmp_shortcut_header (const char *file_header)
d2720 8
a2727 2
  create_shortcut_header ();
  return memcmp (shortcut_header, file_header, SHORTCUT_HDR_SIZE);
d2734 2
a2735 1
  char file_header[SHORTCUT_HDR_SIZE];
d2738 1
a2738 1
  DWORD got = 0;
d2743 2
a2744 9
  /* Read the files header information. This is used to check for a
     Cygwin or U/WIN shortcut or later to check for executable files. */
  if (!ReadFile (h, file_header, SHORTCUT_HDR_SIZE, &got, 0))
    {
      *error = EIO;
      goto close_it;
    }
  /* Check header if the shortcut is really created by Cygwin or U/WIN. */
  if (got != SHORTCUT_HDR_SIZE || cmp_shortcut_header (file_header))
d2746 2
a2747 2
  /* Next 2 byte are USHORT, containing length of description entry. */
  if (!ReadFile (h, &len, sizeof len, &got, 0))
d2752 2
a2753 1
  if (got != sizeof len || len == 0 || len > CYG_MAX_PATH)
d2755 4
a2758 7
  /* Now read description entry. */
  if (!ReadFile (h, contents, len, &got, 0))
    {
      *error = EIO;
      goto close_it;
    }
  if (got != len)
d2760 1
d2769 1
a2769 1
  if (!(*pflags & PATH_ALL_EXEC) && has_exec_chars (file_header, got))
@


1.336
log
@* fhandler.cc (fhandler_base::fchmod): Do the right thing when changing an "on
disk" device or fifo.
(fhandler_base::fchown): Ditto for changing ownership.
* fhandler_disk_file.cc (fhandler_base::fstat_helper): Accommodate device files
on ntfs partitions.
* path.cc (path_conv::check): Use isfs function to figure out if a path exists
on a filesystem to make sure that device files are caught.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
@


1.335
log
@* path.h (path_conv::set_normalized_path): Add second argument and fill it in
throughout.
* path.cc (path_conv::check): Declare, set and use "strip_tail".
(path_conv::set_normalized_path): Add and use second argument, replacing all
tail stripping tests.
@
text
@d819 1
a819 1
  if (dev.devn == FH_FS)
@


1.334
log
@* path.cc (path_conv::check): Don't strip the trailing slash from a path
consisting only of two slashes.
@
text
@d427 1
a427 1
path_conv::set_normalized_path (const char *path_copy)
d429 1
a429 2
  char *eopath = strchr (path, '\0');
  size_t n;
d431 1
a431 3
  if (dev.devn != FH_FS || !*path_copy || strncmp (path_copy, "//./", 4) == 0)
    n = strlen (path_copy) + 1;
  else
a432 1
      char *p = strchr (path_copy, '\0');
d435 1
a435 2
      p[1] = '\0';
      n = 2 + p - path_copy;
d438 2
d441 2
d806 1
d839 4
a842 1
	    *tail = '\0';
d907 1
a907 1
      set_normalized_path (path_copy);
d1844 1
a1844 1
  
d1849 1
a1849 1
    }  
d1899 1
a1899 1
      if (r.get_string (CYGWIN_INFO_CYGDRIVE_PREFIX, cygdrive, sizeof (cygdrive), 
d1904 1
a1904 1
      cygdrive_flags = r.get_int (CYGWIN_INFO_CYGDRIVE_FLAGS, 
d1937 1
a1937 1
  reg_key r (flags & MOUNT_SYSTEM, KEY_ALL_ACCESS, 
d1968 1
a1968 1
  reg_key r (flags & MOUNT_SYSTEM, KEY_ALL_ACCESS, 
@


1.333
log
@	* path.cc (set_normalized_path): Allow empty pathnames.
@
text
@d545 1
a545 1
      if (tail > path_copy + 1 && isslash (tail[-1]))
@


1.332
log
@* path.cc (normalize_win32_path): Remove unneeded check for dots.
@
text
@d432 1
a432 1
  if (dev.devn != FH_FS || strncmp (path_copy, "//./", 4) == 0)
@


1.331
log
@* path.cc (normalize_posix_path): Remove unneeded check for dots.
(path_conv::set_normalized_path): Strip trailing dots, similarly to what had
previously been done for the win32 path.
@
text
@d1013 3
a1015 1
	  if (isdirsep (src[2]) || src[2] == 0)
a1026 7
	  else
	    {
	      int n = strspn (src, ".");
	      if (!src[n] || isdirsep (src[n])) /* just dots... */
		return ENOENT;
	      *tail++ = *src++;
	    }
@


1.330
log
@* path.cc (normalize_win32_path): Make third arg pass-by reference.  Reorganize
slightly to eliminate extra variables.
(normalize_posix_path): Ditto.
(path_conv::check): Reflect change in arguments.
(mount_info::conv_to_posix_path): Ditto.
(mount_info::add_item): Ditto.
@
text
@d253 1
a253 12
		{
		  if (src[2] == '.')
		    {
		      /* Is this a run of dots? That would be an invalid
			 filename.  A bunch of leading dots would be ok,
			 though. */
		      int n = strspn (src, ".");
		      if (!src[n] || isslash (src[n])) /* just dots... */
			return ENOENT;
		    }
		  break;
		}
d430 12
a441 1
  size_t n = strlen (path_copy) + 1;
d451 1
@


1.329
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Use updated value.
* path.cc (path_conv::check): Check the output Win32 path for trailing spaces
and dots, not the input path.  Disallow all use of foo./bar since consistently
getting this right is time consuming.  Remove strange test for "unc\" since no
one seems to know what it's for.
@
text
@d78 3
a80 3
static int normalize_win32_path (const char *src, char *dst, char ** tail);
static void slashify (const char *src, char *dst, int trailing_slash_p);
static void backslashify (const char *src, char *dst, int trailing_slash_p);
d193 1
a193 1
normalize_posix_path (const char *src, char *dst, char **tail)
d195 1
a195 3
  const char *src_start = src;
  char *dst_start = dst;

a197 3
  const char *in_src = src;
  char *in_dst = dst;

d201 1
d206 1
a206 1
      dst = strchr (dst, '\0');
d209 2
a210 2
	  if (dst == dst_start + 1 && *dst_start == '/')
	     --dst;
d213 2
a214 2
      if (dst > dst_start && !isslash (dst[-1]))
	*dst++ = '/';
d219 2
a220 2
      *dst++ = '/';
      *dst++ = '/';
d230 1
a230 1
	*dst++ = *src++;
d246 1
a246 1
		      *dst++ = '/';
d267 1
a267 1
		  while (dst > dst_start && !isslash (*--dst))
d273 1
a273 1
	  *dst++ = '/';
d275 1
a275 1
	if ((dst - dst_start) >= CYG_MAX_PATH)
d283 1
a283 2
  *dst = '\0';
  *tail = dst;
d285 1
a285 1
  debug_printf ("%s = normalize_posix_path (%s)", dst_start, src_start);
d289 1
a289 1
  int err = normalize_win32_path (in_src, in_dst, tail);
d291 1
a291 1
    for (char *p = in_dst; (p = strchr (p, '\\')); p++)
d537 1
a537 1
      error = normalize_posix_path (src, path_copy, &tail);
d876 1
a876 2
	      (strncmp (this->path, "\\\\.\\", 4) != 0 ||
	       !strncasematch (this->path + 4, "unc\\", 4)))
d967 1
a967 1
normalize_win32_path (const char *src, char *dst, char **tail)
a969 2
  char *dst_start = dst;
  char *dst_root_start = dst;
d972 1
d975 1
a975 1
      *dst++ = '\\';
d979 2
a980 2
	  *dst++ = '\\';
	  *dst++ = '.';
d987 1
a987 1
	dst += cygheap->cwd.get_drive (dst);
d992 2
a993 2
	  dst += strlen (dst);
	  *dst++ = '\\';
d1010 1
a1010 1
	       && dst[-1] == '\\')
d1015 2
a1016 2
	      if (dst > dst_root_start + 1)
		dst--;
d1018 2
a1019 2
	      while (dst > dst_root_start + 1 && dst[-1] != '\\' && dst[-2] != ':')
		dst--;
d1029 1
a1029 1
	      *dst++ = *src++;
d1036 1
a1036 1
	    *dst++ = '\\';
d1038 2
a1039 2
	    *dst++ = *src;
	  ++src;
d1041 1
a1041 1
      if ((dst - dst_start) >= CYG_MAX_PATH)
d1044 4
a1047 5
   if (dst > dst_start + 1 && dst[-1] == '.' && dst[-2] == '\\')
     dst--;
  *dst = '\0';
  *tail = dst;
  debug_printf ("%s = normalize_win32_path (%s)", dst_start, src_start);
d1635 2
a1636 2
  char * tail;
  int rc = normalize_win32_path (src_path, pathbuf, &tail);
d1909 1
a1909 1
        cygdrive_flags &= ~MOUNT_SYSTEM;
d1911 1
a1911 1
        cygdrive_flags |= MOUNT_SYSTEM;	
d2129 1
a2129 1
    nativeerr = normalize_win32_path (native, nativetmp, &nativetail);
d2135 1
a2135 1
    posixerr = normalize_posix_path (posix, posixtmp, &posixtail);
@


1.328
log
@revert erroneous checkin
@
text
@d549 1
a549 1
      if (tail > path_copy + 1)
d551 2
a552 14
	  if (isslash (tail[-1]))
	    {
	       need_directory = 1;
	       tail--;
	    }
	  /* Remove trailing dots and spaces which are ignored by Win32 functions but
	     not by native NT functions. */
	  while (tail[-1] == '.' || tail[-1] == ' ')
	    tail--;
	  if (tail > path_copy + 1 && isslash (tail[-1]))
	    {
	      error = ENOENT;
	      return;
	    }
a554 1
      *tail = '\0';
d825 26
@


1.327
log
@* fhandler_proc.cc (proc_listing): Add entry for "self".
(proc_fhandlers): Add entry for "self".
* fhandler_process.cc (fhandler_process::fstate): Handle "self".
(fhandler_process::open): Handle "self".
@
text
@d78 1
a78 1
static int normalize_win32_path (const char *, charplus&);
d193 1
a193 1
normalize_posix_path (const char *src, charplus& dst)
d196 1
d201 1
a205 1
  dst.tail = dst;
d210 1
a210 1
      dst.tail = strchr (dst.tail, '\0');
d213 2
a214 2
	  if (dst.tail == dst + 1 && *dst == '/')
	     dst.tail--;
d217 2
a218 2
      if (dst.tail > dst && !isslash (dst.tail[-1]))
	*dst.tail++ = '/';
d223 2
a224 2
      *dst.tail++ = '/';
      *dst.tail++ = '/';
d234 1
a234 1
	*dst.tail++ = *src++;
d250 1
a250 1
		      *dst.tail++ = '/';
d271 1
a271 1
		  while (dst.tail > dst && !isslash (*--dst.tail))
d277 1
a277 1
	  *dst.tail++ = '/';
d279 1
a279 1
	if ((dst.tail - dst) >= CYG_MAX_PATH)
d287 2
a288 1
  *dst.tail = '\0';
d290 1
a290 1
  debug_printf ("%s = normalize_posix_path (%s)", (char *) dst, src_start);
d294 1
a294 1
  int err = normalize_win32_path (in_src, dst);
d296 1
a296 1
    for (char *p = dst; (p = strchr (p, '\\')); p++)
d503 1
a503 1
  charplus path_copy;
d509 1
a509 1
  char *path_end;
d540 1
d542 1
a542 1
      error = normalize_posix_path (src, path_copy);
d549 1
a549 1
      if (path_copy.tail > path_copy + 1)
d551 1
a551 1
	  if (isslash (path_copy.tail[-1]))
d554 1
a554 1
	       *--path_copy.tail = '\0';
d558 3
a560 3
	  while (path_copy.tail[-1] == '.' || path_copy.tail[-1] == ' ')
	    path_copy.tail--;
	  if (path_copy.tail > path_copy + 1 && isslash (path_copy.tail[-1]))
d566 2
a567 3
      path_end = path_copy.tail;
      path_copy.tailch = *path_copy.tail;
      *path_copy.tail = '\0';
a603 1
	  path_copy.tailch = '\0';
d750 3
a752 3
	  if (path_copy.tail != path_end)
	    *path_copy.tail = '/';
	  while (--path_copy.tail > path_copy + 1 && *path_copy.tail != '/') {}
d755 1
a755 1
	  if (path_copy.tail <= path_copy + 1)
d760 1
a760 1
	  *path_copy.tail = '\0';
d782 1
a782 1
	  char *prevtail = path_copy.tail;
d805 1
a805 1
      if (path_copy.tail++ < path_end)
d810 1
a810 1
	  int taillen = path_end - path_copy.tail + 1;
d813 1
a813 1
	  memcpy (headptr, path_copy.tail, taillen);
d894 2
a895 2
      if (path_copy.tail < path_end && path_copy.tail > path_copy + 1)
	*path_copy.tail = '/';
d960 1
a960 1
normalize_win32_path (const char *src, charplus& dst)
d963 2
a966 1
  dst.tail = dst;
d969 1
a969 1
      *dst.tail++ = '\\';
d973 2
a974 2
	  *dst.tail++ = '\\';
	  *dst.tail++ = '.';
d981 1
a981 1
	dst.tail += cygheap->cwd.get_drive (dst);
d986 2
a987 2
	  dst.tail = strchr (dst.tail, '\0');
	  *dst.tail++ = '\\';
d1004 1
a1004 1
	       && dst.tail[-1] == '\\')
d1009 2
a1010 2
	      if (dst.tail > dst + 1)
		dst.tail--;
d1012 2
a1013 2
	      while (dst.tail > dst + 1 && dst.tail[-1] != '\\' && dst.tail[-2] != ':')
		dst.tail--;
d1023 1
a1023 1
	      *dst.tail++ = *src++;
d1030 1
a1030 1
	    *dst.tail++ = '\\';
d1032 2
a1033 2
	    *dst.tail++ = *src;
	  src++;
d1035 1
a1035 1
      if ((dst.tail - dst) >= CYG_MAX_PATH)
d1038 5
a1042 4
   if (dst.tail > dst + 1 && dst.tail[-1] == '.' && dst.tail[-2] == '\\')
     dst.tail--;
  *dst.tail = '\0';
  debug_printf ("%s = normalize_win32_path (%s)", (char *) dst, src_start);
d1327 1
a1327 1
mount_item::build_win32 (char *dst, const charplus& src, unsigned *outflags, unsigned chroot_pathlen)
a1359 10
      char buf[CYG_MAX_PATH];
      if (src.tailch)
	{
	  strcpy (buf, p);
	  char *endp = strchr (buf, '\0');
	  *endp = src.tailch;
	  strcpy (endp + 1, src.tail + 1);
	  p = buf;
	}

d1395 2
a1396 2
mount_info::conv_to_win32_path (const charplus& src_path, char *dst,
				device& dev, unsigned *flags)
d1410 1
a1410 1
  debug_printf ("conv_to_win32_path (%s)", (const char *) src_path);
d1528 1
a1528 1
  debug_printf ("src_path %s, dst %s, flags %p, rc %d", (const char *) src_path, dst, *flags, rc);
d1593 1
a1593 1
mount_info::conv_to_posix_path (const charplus& src_path, char *posix_path,
d1608 1
a1608 1
  debug_printf ("conv_to_posix_path (%s, %s, %s)", (const char *) src_path,
d1625 1
a1625 1
      debug_printf ("%s = conv_to_posix_path (%s)", posix_path, (const char *) src_path);
d1629 3
a1631 2
  charplus pathbuf;
  int rc = normalize_win32_path (src_path, pathbuf);
d1634 1
a1634 1
      debug_printf ("%d = conv_to_posix_path (%s)", rc, (const char *) src_path);
d1638 1
a1638 1
  int pathbuflen = pathbuf.tail - pathbuf;
d1716 1
a1716 1
  debug_printf ("%s = conv_to_posix_path (%s)", posix_path, (const char *) src_path);
d2112 3
a2114 3
  charplus nativetmp;
  charplus posixtmp;
  char error[] = "error";
d2124 1
a2124 1
    nativeerr = normalize_win32_path (native, nativetmp);
d2130 1
a2130 1
    posixerr = normalize_posix_path (posix, posixtmp);
d2133 2
a2134 2
		native, nativeerr ? error : (const char *) nativetmp,
		posix, posixerr ? error : (const char *) posixtmp, mountflags);
d2143 4
a2146 4
  if (nativetmp.tail > nativetmp + 1 && nativetmp.tail[-1] == '\\')
    nativetmp.tail[-1] = '\0';
  if (posixtmp.tail > posixtmp + 1 && posixtmp.tail[-1] == '/')
    posixtmp.tail[-1] = '\0';
@


1.326
log
@2004-12-03  Pierre Humblet <pierre.humblet@@ieee.org>

	* registry.h (reg_key::reg_key): Change arguments.
	* shared_info.h (class mount_info): Remove had_to_create_mount_areas.
	* registry.cc (reg_key::reg_key): Change constructors to always handle
	HKLM and to avoid relying on HKCU.
	Do not set mount_table->had_to_create_mount_areas.
	* path.cc (mount_info::conv_to_win32_path): Improve update of
	sys_mount_table_counter.
	(mount_info::read_mounts): Use new reg_key constructor.
	(mount_info::add_reg_mount): Ditto.
	(mount_info::del_reg_mount): Ditto.
	(mount_info::read_cygdrive_info_from_registry): Ditto.
	(mount_info::write_cygdrive_info_to_registry): Ditto.
	Update cygwin_shared->sys_mount_table_counter after registry update.
	(mount_info::get_cygdrive_info): Ditto.
	* shared.cc (shared_info::heap_chunk_size): Use new reg_key constructor.
	* environ.cc (regopt): Ditto.
@
text
@d78 1
a78 1
static int normalize_win32_path (const char *src, char *dst, char ** tail);
d193 1
a193 1
normalize_posix_path (const char *src, char *dst, char **tail)
a195 1
  char *dst_start = dst;
a199 1
  char *in_dst = dst;
d204 1
d209 1
a209 1
      dst = strchr (dst, '\0');
d212 2
a213 2
	  if (dst == dst_start + 1 && *dst_start == '/')
	     --dst;
d216 2
a217 2
      if (dst > dst_start && !isslash (dst[-1]))
	*dst++ = '/';
d222 2
a223 2
      *dst++ = '/';
      *dst++ = '/';
d233 1
a233 1
	*dst++ = *src++;
d249 1
a249 1
		      *dst++ = '/';
d270 1
a270 1
		  while (dst > dst_start && !isslash (*--dst))
d276 1
a276 1
	  *dst++ = '/';
d278 1
a278 1
	if ((dst - dst_start) >= CYG_MAX_PATH)
d286 1
a286 2
  *dst = '\0';
  *tail = dst;
d288 1
a288 1
  debug_printf ("%s = normalize_posix_path (%s)", dst_start, src_start);
d292 1
a292 1
  int err = normalize_win32_path (in_src, in_dst, tail);
d294 1
a294 1
    for (char *p = in_dst; (p = strchr (p, '\\')); p++)
d501 1
a501 1
  char path_copy[CYG_MAX_PATH + 3];
d507 1
a507 1
  char *tail, *path_end;
a537 1

d539 1
a539 1
      error = normalize_posix_path (src, path_copy, &tail);
d546 1
a546 1
      if (tail > path_copy + 1)
d548 1
a548 1
	  if (isslash (tail[-1]))
d551 1
a551 1
	       tail--;
d555 3
a557 3
	  while (tail[-1] == '.' || tail[-1] == ' ')
	    tail--;
	  if (tail > path_copy + 1 && isslash (tail[-1]))
d563 3
a565 2
      path_end = tail;
      *tail = '\0';
d602 1
d749 3
a751 3
	  if (tail != path_end)
	    *tail = '/';
	  while (--tail > path_copy + 1 && *tail != '/') {}
d754 1
a754 1
	  if (tail <= path_copy + 1)
d759 1
a759 1
	  *tail = '\0';
d781 1
a781 1
	  char *prevtail = tail;
d804 1
a804 1
      if (tail++ < path_end)
d809 1
a809 1
	  int taillen = path_end - tail + 1;
d812 1
a812 1
	  memcpy (headptr, tail, taillen);
d893 2
a894 2
      if (tail < path_end && tail > path_copy + 1)
	*tail = '/';
d959 1
a959 1
normalize_win32_path (const char *src, char *dst, char **tail)
a961 2
  char *dst_start = dst;
  char *dst_root_start = dst;
d964 1
d967 1
a967 1
      *dst++ = '\\';
d971 2
a972 2
	  *dst++ = '\\';
	  *dst++ = '.';
d979 1
a979 1
	dst += cygheap->cwd.get_drive (dst);
d984 2
a985 2
	  dst += strlen (dst);
	  *dst++ = '\\';
d1002 1
a1002 1
	       && dst[-1] == '\\')
d1007 2
a1008 2
	      if (dst > dst_root_start + 1)
		dst--;
d1010 2
a1011 2
	      while (dst > dst_root_start + 1 && dst[-1] != '\\' && dst[-2] != ':')
		dst--;
d1021 1
a1021 1
	      *dst++ = *src++;
d1028 1
a1028 1
	    *dst++ = '\\';
d1030 2
a1031 2
	    *dst++ = *src;
	  ++src;
d1033 1
a1033 1
      if ((dst - dst_start) >= CYG_MAX_PATH)
d1036 4
a1039 5
   if (dst > dst_start + 1 && dst[-1] == '.' && dst[-2] == '\\')
     dst--;
  *dst = '\0';
  *tail = dst;
  debug_printf ("%s = normalize_win32_path (%s)", dst_start, src_start);
d1324 1
a1324 1
mount_item::build_win32 (char *dst, const char *src, unsigned *outflags, unsigned chroot_pathlen)
d1357 10
d1402 2
a1403 2
mount_info::conv_to_win32_path (const char *src_path, char *dst, device& dev,
				unsigned *flags)
d1417 1
a1417 1
  debug_printf ("conv_to_win32_path (%s)", src_path);
d1535 1
a1535 1
  debug_printf ("src_path %s, dst %s, flags %p, rc %d", src_path, dst, *flags, rc);
d1600 1
a1600 1
mount_info::conv_to_posix_path (const char *src_path, char *posix_path,
d1615 1
a1615 1
  debug_printf ("conv_to_posix_path (%s, %s, %s)", src_path,
d1632 1
a1632 1
      debug_printf ("%s = conv_to_posix_path (%s)", posix_path, src_path);
d1636 2
a1637 3
  char pathbuf[CYG_MAX_PATH];
  char * tail;
  int rc = normalize_win32_path (src_path, pathbuf, &tail);
d1640 1
a1640 1
      debug_printf ("%d = conv_to_posix_path (%s)", rc, src_path);
d1644 1
a1644 1
  int pathbuflen = tail - pathbuf;
d1722 1
a1722 1
  debug_printf ("%s = conv_to_posix_path (%s)", posix_path, src_path);
d2118 3
a2120 3
  char nativetmp[CYG_MAX_PATH];
  char posixtmp[CYG_MAX_PATH];
  char *nativetail, *posixtail, error[] = "error";
d2130 1
a2130 1
    nativeerr = normalize_win32_path (native, nativetmp, &nativetail);
d2136 1
a2136 1
    posixerr = normalize_posix_path (posix, posixtmp, &posixtail);
d2139 2
a2140 2
		native, nativeerr ? error : nativetmp,
		posix, posixerr ? error : posixtmp, mountflags);
d2149 4
a2152 4
  if (nativetail > nativetmp + 1 && nativetail[-1] == '\\')
    nativetail[-1] = '\0';
  if (posixtail > posixtmp + 1 && posixtail[-1] == '/')
    posixtail[-1] = '\0';
@


1.325
log
@2004-10-28  Pierre Humblet <pierre.humblet@@ieee.org>

        * path.cc (mount_info::from_registry): Deimpersonate while
        accessing HKLM.
        (mount_info::read_cygdrive_info_from_registry): Ditto.
        * cygheap.h: Define NO_IMPERSONATION.
        (cygheap_user::issetuid): Replace INVALID_HANDLE_VALUE by
        NO_IMPERSONATION.
        (cygheap_user::has_impersonation_tokens): Ditto.
        (cygheap_user::close_impersonation_tokens): Ditto.
        * uinfo.cc (uinfo_init): Ditto.
        * syscalls.cc (seteuid32): Ditto.
        * security.cc (set_impersonation_token): Ditto.
@
text
@a122 2
#define CYGWIN_REGNAME (cygheap->cygwin_regname ?: CYGWIN_INFO_CYGWIN_REGISTRY_NAME)

d1401 1
d1403 1
a1403 1
      sys_mount_table_counter++;
d1755 1
a1755 1
      posix_path_size = CYG_MAX_PATH;
a1789 4
  /* Use current mount areas if either user or system mount areas
     already exist.  Otherwise, import old mounts. */

  reg_key r;
d1796 11
a1806 11
  /* First read mounts from user's table. */
  read_mounts (r);

  /* Then read mounts from system-wide mount table. */
  cygheap->user.deimpersonate ();
  reg_key r1 (HKEY_LOCAL_MACHINE, KEY_READ, "SOFTWARE",
	      CYGWIN_INFO_CYGNUS_REGISTRY_NAME, CYGWIN_REGNAME,
	      CYGWIN_INFO_CYGWIN_MOUNT_REGISTRY_NAME,
	      NULL);
  read_mounts (r1);
  cygheap->user.reimpersonate ();
d1816 1
a1816 7
  int res = 0;

  if (strchr (posix_path, '\\'))
    {
      set_errno (EINVAL);
      goto err1;
    }
d1820 7
a1826 1
  if (!(mountflags & MOUNT_SYSTEM)) /* current_user mount */
d1828 4
a1831 2
      /* reg_key for user mounts in HKEY_CURRENT_USER. */
      reg_key reg_user;
d1833 2
a1834 35
      /* Start by deleting existing mount if one exists. */
      res = reg_user.kill (posix_path);
      if (res != ERROR_SUCCESS && res != ERROR_FILE_NOT_FOUND)
	goto err;

      /* Create the new mount. */
      reg_key subkey = reg_key (reg_user.get_key (),
				KEY_ALL_ACCESS,
				posix_path, NULL);
      res = subkey.set_string ("native", native_path);
      if (res != ERROR_SUCCESS)
	goto err;
      res = subkey.set_int ("flags", mountflags);
    }
  else /* local_machine mount */
    {
      /* reg_key for system mounts in HKEY_LOCAL_MACHINE. */
      reg_key reg_sys (HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS, "SOFTWARE",
		       CYGWIN_INFO_CYGNUS_REGISTRY_NAME, CYGWIN_REGNAME,
		       CYGWIN_INFO_CYGWIN_MOUNT_REGISTRY_NAME,
		       NULL);

      /* Start by deleting existing mount if one exists. */
      res = reg_sys.kill (posix_path);
      if (res != ERROR_SUCCESS && res != ERROR_FILE_NOT_FOUND)
	goto err;

      /* Create the new mount. */
      reg_key subkey = reg_key (reg_sys.get_key (),
				KEY_ALL_ACCESS,
				posix_path, NULL);
      res = subkey.set_string ("native", native_path);
      if (res != ERROR_SUCCESS)
	goto err;
      res = subkey.set_int ("flags", mountflags);
d1836 7
d1845 1
a1845 2
    }

a1846 4
 err:
  __seterrno_from_win_error (res);
 err1:
  return -1;
d1858 5
a1862 1
  if (!(flags & MOUNT_SYSTEM))	/* Delete from user registry */
d1864 2
a1865 3
      reg_key reg_user (KEY_ALL_ACCESS,
			CYGWIN_INFO_CYGWIN_MOUNT_REGISTRY_NAME, NULL);
      res = reg_user.kill (posix_path);
d1867 2
a1868 1
  else					/* Delete from system registry */
a1871 11
      reg_key reg_sys (HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS, "SOFTWARE",
		       CYGWIN_INFO_CYGNUS_REGISTRY_NAME, CYGWIN_REGNAME,
		       CYGWIN_INFO_CYGWIN_MOUNT_REGISTRY_NAME,
		       NULL);
      res = reg_sys.kill (posix_path);
    }

  if (res != ERROR_SUCCESS)
    {
      __seterrno_from_win_error (res);
      return -1;
d1884 23
a1906 25
  /* reg_key for user path prefix in HKEY_CURRENT_USER. */
  reg_key r;
  /* First read cygdrive from user's registry. */
  if (r.get_string (CYGWIN_INFO_CYGDRIVE_PREFIX, cygdrive, sizeof (cygdrive), "") != 0)
    {
      /* Then read cygdrive from system-wide registry. */
      cygheap->user.deimpersonate ();
      reg_key r2 (HKEY_LOCAL_MACHINE, KEY_READ, "SOFTWARE",
		 CYGWIN_INFO_CYGNUS_REGISTRY_NAME, CYGWIN_REGNAME,
		 CYGWIN_INFO_CYGWIN_MOUNT_REGISTRY_NAME,
		 NULL);
      cygheap->user.reimpersonate ();

      if (r2.get_string (CYGWIN_INFO_CYGDRIVE_PREFIX, cygdrive,
	  sizeof (cygdrive), ""))
	strcpy (cygdrive, CYGWIN_INFO_CYGDRIVE_DEFAULT_PREFIX);
      cygdrive_flags = r2.get_int (CYGWIN_INFO_CYGDRIVE_FLAGS, MOUNT_CYGDRIVE | MOUNT_BINARY);
      slashify (cygdrive, cygdrive, 1);
      cygdrive_len = strlen (cygdrive);
    }
  else
    {
      /* Fetch user cygdrive_flags from registry; returns MOUNT_CYGDRIVE on
	 error. */
      cygdrive_flags = r.get_int (CYGWIN_INFO_CYGDRIVE_FLAGS, MOUNT_CYGDRIVE | MOUNT_BINARY);
a1918 16
  /* Determine whether to modify user or system cygdrive path prefix. */
  HKEY top = (flags & MOUNT_SYSTEM) ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER;

  if (flags & MOUNT_SYSTEM)
    {
      sys_mount_table_counter++;
      cygwin_shared->sys_mount_table_counter++;
    }

  /* reg_key for user path prefix in HKEY_CURRENT_USER or system path prefix in
     HKEY_LOCAL_MACHINE.  */
  reg_key r (top, KEY_ALL_ACCESS, "SOFTWARE",
	     CYGWIN_INFO_CYGNUS_REGISTRY_NAME, CYGWIN_REGNAME,
	     CYGWIN_INFO_CYGWIN_MOUNT_REGISTRY_NAME,
	     NULL);

d1933 2
d1944 3
d1953 3
a1955 3
      slashify (cygdrive_prefix, mount_table->cygdrive, 1);
      mount_table->cygdrive_flags = flags;
      mount_table->cygdrive_len = strlen (mount_table->cygdrive);
d1964 1
a1964 13
  /* Determine whether to modify user or system cygdrive path prefix. */
  HKEY top = (flags & MOUNT_SYSTEM) ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER;

  if (flags & MOUNT_SYSTEM)
    {
      sys_mount_table_counter++;
      cygwin_shared->sys_mount_table_counter++;
    }

  /* reg_key for user path prefix in HKEY_CURRENT_USER or system path prefix in
     HKEY_LOCAL_MACHINE.  */
  reg_key r (top, KEY_ALL_ACCESS, "SOFTWARE",
	     CYGWIN_INFO_CYGNUS_REGISTRY_NAME, CYGWIN_REGNAME,
d1972 3
d1979 7
a1985 1
  return (res != ERROR_SUCCESS) ? res : res2;
d1993 1
a1993 1
  reg_key r;
d2004 1
a2004 4
  reg_key r2 (HKEY_LOCAL_MACHINE, KEY_READ, "SOFTWARE",
	      CYGWIN_INFO_CYGNUS_REGISTRY_NAME, CYGWIN_REGNAME,
	      CYGWIN_INFO_CYGWIN_MOUNT_REGISTRY_NAME,
	      NULL);
@


1.324
log
@2004-10-05  Pierre Humblet <pierre.humblet@@ieee.org>

	* external.cc (check_ntsec): Do not call wincap.has_security.
	* path.cc (path_conv::check): Ditto.
	* security.cc (get_object_attribute): Ditto.
	(get_file_attribute): Ditto.
@
text
@d1805 1
d1811 1
d1927 1
a1927 1

d1930 2
a1931 3
      /* Didn't find the user path prefix so check the system path prefix. */

      /* reg_key for system path prefix in HKEY_LOCAL_MACHINE.  */
d1936 1
@


1.323
log
@2004-10-02  Pierre Humblet <pierre.humblet@@ieee.org>

	* path.h (enum path_types): Delete PATH_ISDISK.
	(path_conv::isdisk): Delete method.
	(path_conv::set_isdisk): Ditto.
	* path.cc (path_conv::check): Do not call set_isdisk.
	* uinfo.cc(pwdgrp::load): Do not call pc.isdisk.
@
text
@d843 1
a843 1
	  if (fs.has_acls () && allow_ntsec && wincap.has_security ())
@


1.322
log
@Sergey Ivanov <seriv@@parkheights.dyndns.org>
* path.cc (mount_info::read_cygdrive_info_from_registry): Default /cygdrive to
binary mode.
@
text
@a841 1
	  set_isdisk ();
@


1.321
log
@2004-09-22  Pierre Humblet <pierre.humblet@@ieee.org>

	* path.cc (normalize_win32_path): Only look for : in second position.
	Avoid infinite loop with names starting in double dots.
	(mount_info::conv_to_win32_path): Do not worry about a trailing dot.
	(hash_path_name): Ditto.
@
text
@d1940 1
a1940 1
      cygdrive_flags = r2.get_int (CYGWIN_INFO_CYGDRIVE_FLAGS, MOUNT_CYGDRIVE);
d1948 1
a1948 1
      cygdrive_flags = r.get_int (CYGWIN_INFO_CYGDRIVE_FLAGS, MOUNT_CYGDRIVE);
d2055 1
a2055 1
      int flags = r.get_int (CYGWIN_INFO_CYGDRIVE_FLAGS, MOUNT_CYGDRIVE);
d2069 1
a2069 1
      int flags = r2.get_int (CYGWIN_INFO_CYGDRIVE_FLAGS, MOUNT_CYGDRIVE);
@


1.320
log
@* exceptions.cc: (ctrl_c_handler): Do nothing while a Cygwin subprocess is
starting.
* child_info.h (init_child_info): Remove pid argument from declaration.
* cygheap.h (init_cygheap::pid): New element.
* dcrt0.cc (dll_crt0_0): Eliminate handling of now-noexistent cygpid parameter
in child_info struct.  Set forkee to 'true' rather than cygpid since the pid
value was never used.
(dll_crt0_1): Ditto.
(_dll_crt0): Ditto.
* fork.cc (fork_child): Don't wait for sigthread.  This is handled in the fork
call now.
(fork_parent): Remove obsolete pid argument from init_child_info call.  Don't
do anything special with cygpid when DEBUGGING.
(fork): Delay all signals during fork.
(fork_init): Don't do anything special when DEBUGGING.
* pinfo.cc (set_myself): Remove pid parameter.  Use new pid field in cygheap.
(pinfo_init): Don't pass pid argument to set_myself.
* sigproc.cc (sig_send): Wait for dwProcessId to be non-zero as well as
sendsig.
(init_child_info): Eliminate handling of pid.
(wait_sig): Implement method to temporarily hold off sending signals.
* sigproc.h (__SIGHOLD): New enum.
(__SIGNOHOLD): Ditto.
* spawn.cc (spawn_guts): Remove obsolete pid argument from init_child_info
call.
@
text
@d981 1
a981 1
  else if (strchr (src, ':') == NULL && *src != '/')
d1026 1
d1458 1
a1458 2
      if (!src_path[n] ||
	  (src_path[n] == '/' && src_path[n + 1] == '.' && !src_path[n + 2]))
d3252 1
a3252 2
  /* Build up hash.  Ignore single trailing slash or \a\b\ != \a\b or
     \a\b\.  but allow a single \ if that's all there is. */
d3258 1
a3258 2
  while (*++name != '\0' &&
	 !(*name == '\\' && (!name[1] || (name[1] == '.' && !name[2]))));
@


1.319
log
@2004-09-05  Pierre Humblet <pierre.humblet@@ieee.org>

        * cygheap.h (cwdstuff::drive_length): New member.
        (cwdstuff::get_drive): New method.
        * path.cc (normalize_win32_path): Simplify by using cwdstuff::get_drive.
        (mount_info::conv_to_win32_path): Use cwdstuff::get_drive as default for /.
        (cwdstuff::set): Initialize drive_length.
@
text
@d984 1
a984 1
        dst += cygheap->cwd.get_drive (dst);
d988 4
a991 4
        {
          dst += strlen (dst);
          *dst++ = '\\';
        }
d1511 1
a1511 1
  else 
d1515 1
a1515 1
        offset = cygheap->cwd.get_drive (dst);
d2192 1
a2192 1
                native, nativeerr ? error : nativetmp,
@


1.318
log
@Regularize most strace_prints throughout so that %E is always preceded by a
comma and elminate most uses of "foo = %s" to "foo %s".
@
text
@d983 3
a985 1
      if (!cygheap->cwd.get (dst, 0))
d987 5
a991 19
      if (beg_src_slash)
	{
	  if (dst[1] == ':')
	    dst[2] = '\0';
	  else if (is_unc_share (dst))
	    {
	      char *p = strpbrk (dst + 2, "\\/");
	      if (p && (p = strpbrk (p + 1, "\\/")))
		  *p = '\0';
	    }
	}
      if (strlen (dst) + 1 + strlen (src) >= CYG_MAX_PATH)
	{
	  debug_printf ("ENAMETOOLONG = normalize_win32_path (%s)", src);
	  return ENAMETOOLONG;
	}
      dst += strlen (dst);
      if (!beg_src_slash)
	*dst++ = '\\';
d1511 7
a1517 3
  else
    backslashify (src_path, dst, 0);

d3700 11
@


1.317
log
@2004-06-17  Pierre Humblet <pierre.humblet@@ieee.org>

        * fhandler.cc (fhandler_base::open_9x): Do not check for null name.
        Move debug_printf to common code line.
        (fhandler_base::open): Ditto. Initialize upath. Remove second argument
        of pc.get_nt_native_path.
        * path.h (path_conv::get_nt_native_path): Remove second argument.
        * path.cc (path_conv::get_nt_native_path): Ditto. Call str2uni_cat.
        * security.h (str2buf2uni_cat): Delete declaration.
        (str2uni_cat): New declaration.
        * security.cc (str2buf2uni): Get length from sys_mbstowcs call.
        (str2buf2uni_cat): Delete function.
        (str2uni_cat): New function.
        * miscfuncs.cc (sys_mbstowcs): Add debug_printf.
@
text
@d1532 1
a1532 1
      debug_printf ("attempt to access outside of chroot '%s = %s'",
@


1.316
log
@	* path.cc (fchdir): Pass the Posix path to chdir.
@
text
@d462 1
a462 1
path_conv::get_nt_native_path (UNICODE_STRING &upath, WCHAR *wpath)
d466 2
a467 2
      str2buf2uni (upath, wpath, "\\??\\");
      str2buf2uni_cat (upath, path);
d470 1
a470 1
    str2buf2uni (upath, wpath, path);
d474 2
a475 2
      str2buf2uni (upath, wpath, "\\??\\UNC\\");
      str2buf2uni_cat (upath, path + 2);
d479 2
a480 2
      str2buf2uni (upath, wpath, "\\??\\");
      str2buf2uni_cat (upath, path + 4);
@


1.315
log
@* spawn.cc (find_exec): Use has_slash to determine if path has a slash rather
than calculating this twice.
@
text
@d3361 1
a3361 1
    res = chdir (cfd->get_win32_name ());
@


1.314
log
@2004-05-30  Pierre Humblet <pierre.humblet@@ieee.org>

	* path.cc (mount_info::add_item): Make sure native path has drive
	or UNC form. Call normalize_xxx_path instead of [back]slashify.
	Remove test for double slashes. Reorganize to always debug_print.
@
text
@d2200 2
a2201 2
                native, nativeerr?error:nativetmp,
		posix, posixerr?error:posixtmp, mountflags);
d2203 1
a2203 1
  if (nativeerr || posixerr) 
d2206 2
a2207 2
	  return -1;
	}
@


1.313
log
@* path.cc (chdir): Always use the normalized_path as posix_cwd, except if it
starts with a drive.

Also perform whitespace cleanup.
@
text
@d2179 5
d2187 7
a2193 3
  if ((native == NULL) || (*native == 0) ||
      (posix == NULL) || (*posix == 0) ||
      !isabspath (native) || !isabspath (posix) ||
d2195 3
a2197 14
    {
      set_errno (EINVAL);
      return -1;
    }

  /* Make sure both paths do not end in /. */
  char nativetmp[CYG_MAX_PATH];
  char posixtmp[CYG_MAX_PATH];

  backslashify (native, nativetmp, 0);
  nofinalslash (nativetmp, nativetmp);

  slashify (posix, posixtmp, 0);
  nofinalslash (posixtmp, posixtmp);
d2200 2
a2201 1
		native, nativetmp, posix, posixtmp, mountflags);
d2203 1
a2203 2
  /* Duplicate /'s in path are an error. */
  for (char *p = posixtmp + 1; *p; ++p)
d2205 1
a2205 3
      if (p[-1] == '/' && p[0] == '/')
	{
	  set_errno (EINVAL);
d2208 6
a2213 1
    }
@


1.312
log
@* cygheap.h (cwdstuff::set): Modify return value and arguments.
* path.cc (chdir): Specify PC_POSIX.  Do not call SetCurrentDirectory.  Set
posix_cwd in a way that does not break find.exe.  Change call to cwd.set.
(cwdstuff::get_initial): Do not call GetCurrentDirectory here.
(cwdstuff::set): Call SetCurrentDirectory and GetCurrentDirectory as needed.
@
text
@d464 1
a464 1
  if (path[0] != '\\')             /* X:\...  or NUL, etc. */
d469 1
a469 1
  else if (path[1] != '\\')        /* \Device\... */
d471 2
a472 2
  else if (path[2] != '.' 
	   || path[3] != '\\')     /* \\server\share\... */
d476 2
a477 2
    }        
  else                                          /* \\.\device */
d553 2
a554 2
          if (isslash (tail[-1]))
            {
d558 1
a558 1
          /* Remove trailing dots and spaces which are ignored by Win32 functions but
d560 1
a560 1
          while (tail[-1] == '.' || tail[-1] == ' ') 
d562 2
a563 2
          if (tail > path_copy + 1 && isslash (tail[-1]))
            {
d565 1
a565 1
              return;
d567 1
a567 1
        }
d1020 1
a1020 1
        {
d3319 1
a3319 1
        {
d3328 1
a3328 1
      if (!path.has_symlinks () && !isabspath (in_dir))
d3677 4
a3680 4
         {
            __seterrno ();
            goto out;
         }
d3688 1
a3688 1
        {
d3694 1
a3694 1
        {
@


1.311
log
@	* path.cc (path_conv::check): Don't bail out with error if path is "//".
@
text
@d3300 1
a3300 1
  path_conv path (PC_NONULLEMPTY, in_dir, PC_FULL | PC_SYM_FOLLOW);
d3309 2
a3310 1
  const char *native_dir = path;
d3323 9
a3331 4
      if (SetCurrentDirectory (native_dir))
        res = 0;
      else
        __seterrno ();
d3338 4
a3341 1
    res = 0;
d3343 2
a3344 2
  if (res == 0)
    cygheap->cwd.set (native_dir);
d3660 2
a3661 19
  int i;
  DWORD len, dlen;
  for (i = 0, dlen = CYG_MAX_PATH, len = 0; i < 3; dlen *= 2, i++)
    {
      win32 = (char *) crealloc (win32, dlen + 2);
      if ((len = GetCurrentDirectoryA (dlen, win32)) < dlen)
	break;
    }

  if (len == 0)
    {
      __seterrno ();
      cwd_lock->release ();
      debug_printf ("get_initial_cwd failed, %E");
      cwd_lock->release ();
      return 0;
    }
  set (NULL);
  return 1;	/* Leaves cwd lock unreleased */
d3664 1
a3664 1
/* Fill out the elements of a cwdstuff struct.
d3667 2
a3668 2
void
cwdstuff::set (const char *win32_cwd, const char *posix_cwd)
d3670 2
a3671 1
  char pathbuf[CYG_MAX_PATH];
d3675 29
a3703 1
      cwd_lock->acquire ();
d3718 2
d3722 1
a3722 2

  return;
@


1.310
log
@Christopher Faylor <cgf@@timesys.com>
* path.cc (mount_info::conv_to_posix_path): Add return.
@
text
@d562 1
a562 1
          if (isslash (tail[-1]))
@


1.309
log
@2004-05-06  Pierre Humblet <pierre.humblet@@ieee.org>

        * path.cc (path_conv::check): Strip trailing dots and spaces and
        return error if the final component had only dots and spaces.
        (normalize_posix_path): Revert 2004-04-30.
        (chdir): Do not check for trailing spaces. Do not set native_dir
        to c:\ for virtual devices. Pass only native_dir to cwd.set.
        (cwdstuff::set): Assume posix_cwd is already normalized.
@
text
@d1696 3
a1698 1
  else if (cygheap->root.ischroot_native (pathbuf))
d1708 1
a1709 2
  else
    return ENOENT;
@


1.308
log
@* path.cc (normalize_win32_path): Detect components with only dots.  Remove a
final .  if it follows '\\'.
(mount_info::conv_to_win32_path): Only backslashify the path when no mount is
found.
(chdir): Do not look for components with only dots.
@
text
@a288 4
  /* Remove trailing dots and spaces which are ignored by Win32 functions but
     not by native NT functions. */
  while (dst[-1] == '.' || dst[-1] == ' ')
    --dst;
d551 1
a551 1
      if (tail > path_copy + 1 && isslash (*(tail - 1)))
d553 15
a567 3
	  need_directory = 1;
	  *--tail = '\0';
	}
d569 1
a3296 16
  char *s;
  char dir[strlen (in_dir) + 1];
  strcpy (dir, in_dir);
  /* Incredibly. Windows allows you to specify a path with trailing
     whitespace to SetCurrentDirectory.  This doesn't work too well
     with other parts of the API, though, apparently.  So nuke trailing
     white space. */
  for (s = strchr (dir, '\0'); --s >= dir && isspace ((unsigned int) (*s & 0xff)); )
    *s = '\0';

  if (!*s)
    {
      set_errno (ENOENT);
      return -1;
    }

d3299 1
a3299 1
  path_conv path (PC_NONULLEMPTY, dir, PC_FULL | PC_SYM_FOLLOW);
d3303 1
a3303 1
      syscall_printf ("-1 = chdir (%s)", dir);
d3307 1
a3308 11

  /* Check to see if path translates to something like C:.
     If it does, append a \ to the native directory specification to
     defeat the Windows 95 (i.e. MS-DOS) tendency of returning to
     the last directory visited on the given drive. */
  if (isdrive (native_dir) && !native_dir[2])
    {
      path.get_win32 ()[2] = '\\';
      path.get_win32 ()[3] = '\0';
    }
  int res;
a3310 2
    res = SetCurrentDirectory (native_dir) ? 0 : -1;
  else if (!path.exists ())
d3312 13
a3324 2
      set_errno (ENOENT);
      return -1;
d3326 2
d3329 1
a3329 4
    {
      set_errno (ENOTDIR);
      return -1;
    }
d3331 1
a3331 4
    {
      native_dir = "c:\\";
      res = 0;
    }
d3333 2
a3334 17
  /* If res != 0, we didn't change to a new directory.
     Otherwise, set the current windows and posix directory cache from input.
     If the specified directory is a MS-DOS style directory or if the directory
     was symlinked, convert the MS-DOS path back to posix style.  Otherwise just
     store the given directory.  This allows things like "find", which traverse
     directory trees, to work correctly with Cygwin mounted directories.
     FIXME: Is just storing the posixized windows directory the correct thing to
     do when we detect a symlink?  Should we instead rebuild the posix path from
     the input by traversing links?  This would be an expensive operation but
     we'll see if Cygwin mailing list users whine about the current behavior. */
  if (res)
    __seterrno ();
  else if ((!path.has_symlinks () && strpbrk (dir, ":\\") == NULL
	    && pcheck_case == PCHECK_RELAXED) || isvirtual_dev (devn))
    cygheap->cwd.set (native_dir, dir);
  else
    cygheap->cwd.set (native_dir, NULL);
a3686 2
    mount_table->conv_to_posix_path (win32, pathbuf, 0);
  else
d3688 2
a3689 4
      char * tail;
      (void) normalize_posix_path (posix_cwd, pathbuf, &tail);
      if (tail > pathbuf + 1 && *(--tail) == '/')
	*tail = 0;
d3691 2
a3692 2
  posix = (char *) crealloc (posix, strlen (pathbuf) + 1);
  strcpy (posix, pathbuf);
@


1.307
log
@* path.cc (is_unc_share): Remove redundant tests.
@
text
@d792 1
a792 1
	Convert slashes.  FIXME? I think it's fine / Pierre */
d1010 20
a1029 12
	       && dst[-1] == '\\'
	       && (isdirsep (src[2]) || src[2] == 0))
	{
	  /* Back up over /, but not if it's the first one.  */
	  if (dst > dst_root_start + 1)
	    dst--;
	  /* Now back up to the next /.  */
	  while (dst > dst_root_start + 1 && dst[-1] != '\\' && dst[-2] != ':')
	    dst--;
	  src += 2;
	  if (isdirsep (*src))
	    src++;
d1043 2
d1515 1
a1515 5
    {
      if (strchr (src_path, ':') == NULL && !is_unc_share (src_path))
	set_flags (flags, PATH_BINARY);
      backslashify (src_path, dst, 0);
    }
a3310 18
      return -1;
    }


  /* Look for trailing path component consisting entirely of dots.  This
     is needed only in case of chdir since Windows simply ignores count
     of dots > 2 here instead of returning an error code.  Counts of dots
     <= 2 are already eliminated by normalize_posix_path. */
  const char *p = strrchr (dir, '/');
  if (!p)
    p = dir;
  else
    p++;

  size_t len = strlen (p);
  if (len > 2 && strspn (p, ".") == len)
    {
      set_errno (ENOENT);
@


1.306
log
@	* path.cc (check_sysfile): Don't scan string twice.
@
text
@d939 6
a944 8
  char *p = NULL;
  int ret = (isdirsep (path[0])
	     && isdirsep (path[1])
	     && (isalnum (path[2]) || path[2] == '.')
	     && ((p = strpbrk (path + 3, "\\/")) != NULL));
  if (!ret || p == NULL)
    return false;
  return ret && isalnum (p[1]);
@


1.305
log
@	* fhandler.cc (fhandler_base::open): Call path_conv::get_nt_native_path
	for evaluating NT path.
	* path.cc (normalize_posix_path): Remove trailing dots and spaces.
	(path_conv::get_nt_native_path): New function.
	* path.h (class path_conv): Declare get_nt_native_path method.
@
text
@d2789 3
a2791 2
	  if (memchr (contents, 0, got) != NULL)
	    res = strlen (contents);
@


1.304
log
@fix comment
@
text
@d289 4
d463 24
@


1.303
log
@* path.cc (is_unc_share): Rename from slash_unc_prefix_p throughout.
* path.cc (normalize_posix_path): Process all Posix paths and map three or more
initial slashes to a single one.  Simplify processing following two initial
slashes.
(normalize_win32_path): Make last argument non-optional and do not check for
NULL value.
@
text
@d47 1
a47 1
   c: means c:\.  FIXME: Is this still true?
@


1.302
log
@	* autoload.cc (NtCreateFile): Add.
	* dir.cc (mkdir): Change set_file_attribute call to indicate that
	NT security isn't used.
	* fhandler.cc (fhandler_base::open_9x): New method, created from
	fhandler_base::open.
	(fhandler_base::open): Rearrange to use NtCreateFile instead of
	CreateFile.
	* fhandler.h (enum query_state): Redefine query_null_access to
	query_stat_control.  query_null_access isn't allowed in NtCreateFile.
	(fhandler_base::open_9x): Declare.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use
	query_stat_control first, query_read_control if that fails.
	(fhandler_disk_file::fchmod): Call enable_restore_privilege before
	trying to open for query_write_control.  Don't fall back to
	opening for query_read_control.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl):  Only request restore privilege and query
	access necessary for given cmd.
	* fhandler_raw.cc (fhandler_dev_raw::open): Call fhandler_base::open
	instead of opening device here.
	* ntdll.h (NtCreateFile): Declare.
	* path.cc (symlink_worker): Change set_file_attribute call to indicate
	that NT security isn't used.
	* sec_acl.cc (getacl): Fix bracketing.
	* sec_helper.cc (enable_restore_privilege): New function.
	* security.cc (str2buf2uni_cat): New function.
	(write_sd): Don't request restore permission here.
	* security.h (set_process_privileges): Drop stale declaration.
	(str2buf2uni): Declare.
	(str2buf2uni_cat): Declare.
	(enable_restore_privilege): Declare.
	* syscalls.cc (fchown32): Return immediate success on 9x.
@
text
@d78 1
a78 1
static int normalize_win32_path (const char *src, char *dst, char ** tail = 0);
d205 1
a205 1
  if (isdrive (src) || slash_unc_prefix_p (src))
d223 1
a223 1
  else if (isslash (src[1]))
a227 12
      if (isslash (*src))
	{ /* Starts with three or more slashes - reset. */
	  dst = dst_start;
	  *dst++ = '/';
	  src = src_start + 1;
	}
      else if (src[0] == '.' && isslash (src[1]))
	{
	  *dst++ = '.';
	  *dst++ = '/';
	  src += 2;
	}
a228 2
  else
    *dst = '\0';
d383 1
a383 1
  			     &status.flags, fsname, sizeof (fsname)))
d906 15
d954 1
a954 1
	  else if (slash_unc_prefix_p (dst))
d1009 2
a1010 3
  *dst = 0;
  if (tail)
    *tail = dst;
a1077 15
/* slash_unc_prefix_p: Return non-zero if PATH begins with //UNC/SHARE */

int __stdcall
slash_unc_prefix_p (const char *path)
{
  char *p = NULL;
  int ret = (isdirsep (path[0])
	     && isdirsep (path[1])
	     && (isalnum (path[2]) || path[2] == '.')
	     && ((p = strpbrk (path + 3, "\\/")) != NULL));
  if (!ret || p == NULL)
    return ret;
  return ret && isalnum (p[1]);
}

d1480 1
a1480 1
      if (strchr (src_path, ':') == NULL && !slash_unc_prefix_p (src_path))
d2143 1
a2143 1
      slash_unc_prefix_p (posix) || isdrive (posix))
d2220 1
a2220 1
  if (slash_unc_prefix_p (path) || strpbrk (path, ":\\"))
@


1.301
log
@2004-04-14  Pierre Humblet <pierre.humblet@@ieee.org>

        * path.h (path_conv::set_symlink): Add argument.
        (path_conv::get_symlink_length): New method.
        (path_conv::symlink_length): New member.
        * path.cc (path_conv::check): Pass symlen to set_symlink.
        * fhandler_disk_file.cc (fhandler_base::fstat_helper): For symlinks
        set st_size from get_symlink_length.
@
text
@d2651 1
a2651 2
	    set_file_attribute (win32_path.has_acls (), NULL,
				win32_path.get_win32 (),
@


1.300
log
@	* dir.cc (mkdir): Call set_file_attribute with additional handle
	argument.
	* fhandler.cc (fhandler_base::fchmod): New method.
	* fhandler.h: Declare fchmod method in fhandler_base,
	fhandler_disk_file and fhandler_virtual.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): New method.
	(fhandler_base::open_fs): Call set_file_attribute with additional
	handle argument.
	* fhandler_virtual.cc (fhandler_virtual::fchmod): New method.
	* path.cc (symlink_worker): Call set_file_attribute with additional
	handle argument.
	* security.cc (get_nt_object_security): New function.
	(get_nt_object_attribute): Call get_nt_object_security.
	(set_nt_attribute): Add handle argument.  Call get_nt_object_security
	first, read_sd only if that fails.
	(set_file_attribute): Add handle argument.
	* security.h (set_file_attribute): Declare with additional handle
	argument.
	* syscalls.cc (stat_suffixes): Move to beginning of file.
	(chown_worker): Call set_file_attribute with additional handle argument.
	(chmod): Reorganize to call fhandler's fchmod method eventually.
	(fchmod): Ditto.
@
text
@d708 1
a708 1
		      set_symlink (); // last component of path is a symlink.
@


1.299
log
@	* winsup.h (IMPLEMENT_STATUS_FLAG): New macro to define status flag
	accessor methods unambiguously.
	* fhandler.h: Use IMPLEMENT_STATUS_FLAG throughout where possible.
	* fhandler_termios.cc (fhandler_termios::tcinit): Call corrected
	accessor for initialized status flag.
	* mtinfo.h (class mtinfo_drive): Use IMPLEMENT_STATUS_FLAG throughout.
	* path.cc (fs_info::update): Remove duplicate call to flags().
	* path.h (struct fs_info): Use IMPLEMENT_STATUS_FLAG where possible.
	(path_conv::is_auto_device): Fix spacing.
	* tty.h (class tty_min): Use IMPLEMENT_STATUS_FLAG throughout.
@
text
@d2651 1
a2651 1
	    set_file_attribute (win32_path.has_acls (),
@


1.298
log
@2004-04-12  Pierre Humblet <pierre.humblet@@ieee.org>

        * path.cc (path_conv::check): Fix "tail filling" logic.
@
text
@a399 1
      flags () = 0;
@


1.297
log
@	* fhandler.cc (rootdir): Add and use second argument.
	* winsup.h (rootdir): Add second argument in declaration.
	* path.cc (fs_info::update): Modify call to rootdir.
	* syscalls.cc (check_posix_perm): Ditto.
	(statfs): Ditto. Move syscall_printf near top.
@
text
@d502 1
a502 1
  char *tail;
d547 1
a547 1
      char *path_end = tail;
d875 1
a875 1
      if (tail[1] != '\0')
@


1.296
log
@	* Use new unified status_flag accessor methods from classes fhandler_*,
	tty_min, mtinfo and fs_info thoroughout.
	* fhandler.h: Redefine all set_close_on_exec methods to take a bool
	argument.
	(enum conn_state): Rename from connect_state.
	(class fhandler_base): Rename some status flags to align with
	accessor method names.  Drop encoded flag entirely.  Unify status
	accessor methods.  Const'ify all read accessor methods.
	(class fhandler_socket): Ditto.
	(class fhandler_dev_raw): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use fs.fs_is_fat()
	instead of evaluating FATness of file system here.
	(fhandler_disk_file::opendir): Drop call to set_encoded().
	(fhandler_disk_file::readdir): Use pc.isencoded() directly.
	* mtinfo.h (class mtinfo_drive): Const'ify all read accessor methods.
	* path.cc (fsinfo_cnt): Add.
	(fs_info::update): Accomodate class changes. Evaluate file system
	name specific flags right here. Add thread safety for reading and
	writing global fsinfo array.
	* path.h (enum path_types): Drop values for flags kept in fs already.
	(struct fs_info): Move status informatin into private struct type
	status_flags.  Add accessor methods. Remove path and file system
	name string arrays in favor of status bits.
	(class path_conv): Use new fs_info status information where
	appropriate.
	(path_conf::fs_has_ea): Rename from fs_fast_ea.
	(path_conf::fs_has_acls): New method.
	(path_conf::root_dir): Remove.
	(path_conf::volname): Remove.
	* syscalls (statfs): Evaluate root dir locally.
	* tty.h (class tty_min): Unify status accessor methods.  Const'ify
	all read accessor methods.
@
text
@a363 1
  strncpy (root_dir, win32_path, CYG_MAX_PATH);
d365 1
a365 1
  if (!rootdir (root_dir))
@


1.295
log
@* path.cc (path_conv::check): Optimize symlink replacements.
* path.cc (normalize_posix_path): Add "tail" argument and set it.  Always have
a final slash for directories.  Pass 3rd argument to normalize_win32_path.
(path_conv::check): Pass tail to normalize_posix_path.  Set need_directory and
remove final slash after that call.  Remove last argument to
mount_table->conv_to_win32_path().  Remove noop dostail check.  Remove
fs.update() from inner loop.  Improve tail finding search.
(normalize_win32_path): Add and set tail argument.
(mount_item::build_win32): Avoid calling strcpy.
(mount_info::conv_to_win32_path): Remove third argument and simplify because
the source is normalized.  Keep /proc path in Posix form.  Call
win32_device_name() only once.
(mount_info::conv_to_posix_path): Add and use 3rd argument to
normalize_win32_path to avoid calling strlen.
(cwdstuff::set): Add 3rd argument to normalize_posix_path and remove final
slash if any.
* shared_info.h (mount_info::conv_to_win32_path): Remove last argument in
declaration.
@
text
@d357 1
d362 3
a364 2
  char tmp_buf [CYG_MAX_PATH];
  strncpy (tmp_buf, win32_path, CYG_MAX_PATH);
d366 1
a366 1
  if (!rootdir (tmp_buf))
d369 1
a369 2
      name_storage [0] = '\0';
      sym_opt_storage = flags_storage = serial_storage = 0;
d373 1
a373 1
  __ino64_t tmp_name_hash = hash_path_name (1, tmp_buf);
d377 2
a378 1
  while (idx < MAX_FS_INFO_CNT && fsinfo[idx].name_hash)
d389 16
a404 15
  strncpy (root_dir_storage, tmp_buf, CYG_MAX_PATH);
  drive_type_storage = GetDriveType (root_dir_storage);
  if (drive_type_storage == DRIVE_REMOTE
      || (drive_type_storage == DRIVE_UNKNOWN
	  && (root_dir_storage[0] == '\\' && root_dir_storage[1] == '\\')))
    is_remote_drive_storage = 1;
  else
    is_remote_drive_storage = 0;

  if (!GetVolumeInformation (root_dir_storage, NULL, 0, &serial_storage, NULL, &flags_storage,
				 name_storage, sizeof (name_storage)))
    {
      debug_printf ("Cannot get volume information (%s), %E", root_dir_storage);
      name_storage[0] = '\0';
      sym_opt_storage = flags_storage = serial_storage = 0;
d412 28
a439 4
  sym_opt_storage = (!is_remote_drive_storage && strcmp (name_storage, "NTFS") == 0) ? PC_CHECK_EA : 0;

  if (idx < MAX_FS_INFO_CNT && drive_type_storage != DRIVE_REMOVABLE)
    fsinfo[idx] = *this;
d457 1
a457 1
    fs.drive_type () = DRIVE_UNKNOWN;
d522 1
a522 6
  fs.root_dir ()[0] = '\0';
  fs.name ()[0] = '\0';
  fs.flags () = fs.serial () = 0;
  fs.sym_opt () = 0;
  fs.drive_type () = 0;
  fs.is_remote_drive () = 0;
d649 1
a649 1
	  symlen = sym.check (full_path, suff, opt | fs.sym_opt ());
d819 1
a819 7
      if (!fs.update (path))
	{
	  fs.root_dir ()[0] = '\0';
	  set_has_acls (false);		// already implied but...
	  set_has_buggy_open (false);	// ditto
	}
      else
d822 5
a826 15
	  debug_printf ("root_dir(%s), this->path(%s), set_has_acls(%d)",
			fs.root_dir (), this->path, fs.flags () & FS_PERSISTENT_ACLS);
	  if (!(fs.flags () & FS_PERSISTENT_ACLS) || (!allow_smbntsec && fs.is_remote_drive ()))
	    set_has_acls (false);
	  else
	    {
	      set_has_acls (true);
	      if (allow_ntsec && wincap.has_security ())
		set_exec (0);  /* We really don't know if this is executable or not here
				  but set it to not executable since it will be figured out
				  later by anything which cares about this. */
	    }
	  /* Known file systems with buggy open calls. Further explanation
	     in fhandler.cc (fhandler_disk_file::open). */
	  set_has_buggy_open (strcmp (fs.name (), "SUNWNFS") == 0);
d2666 1
a2666 1
	  if (!isdevice && win32_path.fs_fast_ea ())
@


1.294
log
@	* path.cc (fsinfo): Global storage for file system information.
	(fs_info::update): Store file system information also in fsinfo and
	short circuit GetVolumeInformation by using alredy stored file system
	information.
@
text
@d78 1
a78 1
static int normalize_win32_path (const char *src, char *dst);
d195 1
a195 1
normalize_posix_path (const char *src, char *dst)
d266 1
a266 2
		      if (dst == dst_start)
			*dst++ = '/';
d277 1
a277 1
		         filename.  A bunch of leading dots would be ok,
d304 1
a304 2
  if (--dst > dst_start && isslash (*dst))
    *dst = '\0';
d310 1
a310 1
  int err = normalize_win32_path (in_src, in_dst);
d379 1
a379 1
        {
a512 12
      char *p = strchr (src, '\0');
      /* Detect if the user was looking for a directory.  We have to strip the
	 trailing slash initially and add it back on at the end due to Windows
	 brain damage. */
      if (--p > src)
	{
	  if (isdirsep (*p))
	    need_directory = 1;
	  else if (--p  > src && p[1] == '.' && isdirsep (*p))
	    need_directory = 1;
	}

d514 1
a514 1
      error = normalize_posix_path (src, path_copy);
d518 8
a525 1
      tail = strchr (path_copy, '\0');   // Point to end of copy
a526 1
      tail[1] = '\0';
d537 1
d561 1
a561 1
						   &sym.pflags, 1);
a610 6
	  if (!fs.update (full_path))
	    fs.root_dir ()[0] = '\0';

	  /* Eat trailing slashes */
	  char *dostail = strchr (full_path, '\0');

a614 3
	  while (dostail > full_path + 3 && (*--dostail == '\\'))
	    *tail = '\0';

d627 1
a627 1
	  int len = sym.check (full_path, suff, opt | fs.sym_opt ());
d678 1
a678 1
	      /* Found a symlink if len > 0.  If component == 0, then the
d683 1
a683 1
	      else if (len > 0)
d707 1
a707 1
	  /* Find the "tail" of the path, e.g. in '/for/bar/baz',
a708 1
	  char *newtail = strrchr (path_copy, '/');
d711 1
a711 1

d714 1
a714 1
	  if (!newtail || newtail == path_copy || (newtail == path_copy + 1 && newtail[-1] == '/'))
a716 2
	  tail = newtail;

a731 11
      /* The tail is pointing at a null pointer.  Increment it and get the length.
	 If the tail was empty then this increment will end up pointing to the extra
	 \0 added to path_copy above. */
      int taillen = strlen (++tail);
      int buflen = strlen (sym.contents);
      if (buflen + taillen > CYG_MAX_PATH)
	  {
	    error = ENAMETOOLONG;
	    strcpy (path, "::ENAMETOOLONG::");
	    return;
	  }
d733 1
a733 7
      /* Strip off current directory component since this is the part that refers
	 to the symbolic link. */
      if ((p = strrchr (path_copy, '/')) == NULL)
	p = path_copy;
      else if (p == path_copy)
	p++;
      *p = '\0';
d740 6
a745 3
	  /* Copy the first part of the path and point to the end. */
	  strcpy (tmp_buf, path_copy);
	  headptr = strchr (tmp_buf, '\0');
d748 12
a759 7
      /* See if we need to separate first part + symlink contents with a / */
      if (headptr > tmp_buf && headptr[-1] != '/')
	*headptr++ = '/';

      /* Copy the symlink contents to the end of tmp_buf.
	 Convert slashes.  FIXME? */
      for (p = sym.contents; *p; p++)
d761 1
d763 2
a764 4
      /* Copy any tail component */
      if (tail >= path_end)
	*headptr = '\0';
      else
d766 7
a772 2
	  *headptr++ = '/';
	  strcpy (headptr, tail);
d775 1
a775 1
      /* Now evaluate everything all over again. */
d783 1
a783 2
  /* Deal with Windows stupidity which considers filename\. to be valid
     even when "filename" is not a directory. */
d923 1
a923 1
normalize_win32_path (const char *src, char *dst)
d1005 2
d1336 1
a1336 4
	{
	  strcpy (dst + n, p);
	  backslashify (dst, dst, 0);
	}
d1376 1
a1376 1
				unsigned *flags, bool no_normalize)
a1383 1
  int src_path_len = strlen (src_path);
a1384 1
  unsigned dummy_flags;
a1387 3
  if (!flags)
    flags = &dummy_flags;

a1390 6
  if (src_path_len >= CYG_MAX_PATH)
    {
      debug_printf ("ENAMETOOLONG = conv_to_win32_path (%s)", src_path);
      return ENAMETOOLONG;
    }

a1392 4
  char pathbuf[CYG_MAX_PATH];

  if (dst == NULL)
    goto out;		/* Sanity check. */
d1394 1
a1394 1
  /* Normalize the path, taking out ../../ stuff, we need to do this
d1406 2
a1407 16
     We do this by first getting an absolute UNIX-style path and then
     converting it to a DOS-style path, looking up the appropriate drive
     in the mount table.  */

  if (no_normalize)
    strcpy (pathbuf, src_path);
  else
    {
      rc = normalize_posix_path (src_path, pathbuf);

      if (rc)
	{
	  debug_printf ("%d = conv_to_win32_path (%s)", rc, src_path);
	  return rc;
	}
    }
d1410 1
a1410 1
  if (win32_device_name (pathbuf, dst, dev))
d1420 1
a1420 1
  if (isproc (pathbuf))
d1423 1
a1423 1
      dev.devn = fhandler_proc::get_proc_fhandler (pathbuf);
d1426 3
d1430 1
a1430 1
  else if (iscygdrive (pathbuf))
d1435 2
a1436 2
      if (!pathbuf[n] ||
	  (pathbuf[n] == '/' && pathbuf[n + 1] == '.' && !pathbuf[n + 2]))
d1443 1
a1443 1
      else if (cygdrive_win32_path (pathbuf, dst, unit))
d1478 1
a1478 1
      if (path_prefix_p (path, pathbuf, len))
d1484 1
a1484 1
      int err = mi->build_win32 (dst, pathbuf, flags, chroot_pathlen);
d1491 3
a1493 8
      if (strpbrk (src_path, ":\\") != NULL || slash_unc_prefix_p (src_path))
	rc = normalize_win32_path (src_path, dst);
      else
	{
	  backslashify (pathbuf, dst, 0);	/* just convert */
	  set_flags (flags, PATH_BINARY);
	}
      chroot_ok = !cygheap->root.exists ();
a1495 3
  if (!isvirtual_dev (dev.devn))
    win32_device_name (src_path, dst, dev);

d1610 2
a1611 1
  int rc = normalize_win32_path (src_path, pathbuf);
d1618 1
a1618 1
  int pathbuflen = strlen (pathbuf);
d2652 1
a2652 1
	    			  : FILE_ATTRIBUTE_SYSTEM;
d3053 1
a3053 1
         should we write it there?  */
d3713 6
a3718 2
    (void) normalize_posix_path (posix_cwd, pathbuf);

@


1.293
log
@	* path.cc (hash_path_name): Replace hash algorithm with SDBM.
@
text
@d357 3
d374 14
a387 2
  if (strcmp (tmp_buf, root_dir_storage) == 0)
    return 1;
d413 2
@


1.292
log
@* path.cc (path_prefix_p): Optimize test order.
@
text
@d3265 1
a3265 1
	  hash = (hash << 5) - hash + '\\';
d3275 1
a3275 1
      hash = (hash << 5) - hash + ch;
@


1.291
log
@* path.cc (path_conv::check): Use 'strchr' rather than 'strrchr' to find end of
string, for efficiency.
* include/cygwin/_types.h: New file.
* include/sys/lock.h: Ditto.
* include/sys/stdio.h: Ditto.
* thread.cc: Include sys/lock.h
(__cygwin_lock_init): New function.
(__cygwin_lock_init_recursive): Ditto.
(__cygwin_lock_fini): Ditto.
(__cygwin_lock_lock): Ditto.
(__cygwin_lock_trylock): Ditto.
(__cygwin_lock_unlock): Ditto.
(pthread::atforkprepare): Lock file pointer before fork.
(pthread::atforkparent): Unlock file pointer after fork.
(pthread::atforkchild): Ditto.
@
text
@d164 2
a165 2
  if (!pathnmatch (path1, path2, len1))
    return 0;
d167 1
a167 1
  return isdirsep (path2[len1]) || path2[len1] == 0 || path1[len1 - 1] == ':';
@


1.290
log
@* path.cc (normalize_posix_path): Reorganize to short circuit to DOS path
handling whenever a '\' is detected.
* signal.cc (sigaction): Make strace output more informative.
* sigproc.cc (pending_signals::add): Just index directly into signal array
rather than treating the array as a heap.
(pending_signals::del): Ditto.
(wait_sig): Don't send signal if we already have a similar signal queued.
* sigproc.h (call_signal_handler_now): Remove obsolete declaration.
@
text
@d498 1
a498 1
      char *p = strrchr (src, '\0');
@


1.289
log
@update copyright.  Minor reformatting.
@
text
@a190 1
   \'s are converted to /'s in the process.
d202 3
d206 1
a206 7
    {
      int err = normalize_win32_path (src, dst);
      if (!err)
	for (char *p = dst; (p = strchr (p, '\\')); p++)
	  *p = '/';
      return err;
    }
d246 2
d310 7
@


1.288
log
@* path.cc (conv_path_list): Return error condition.
(copy1): New function.
(copyenc): New function.
(mount_item::fnmunge): Return error condition.  Use new functions to copy
strings.
(mount_item::build_win32): Ditto.
(mount_info::conv_to_win32_path): Return error condition.
(cygwin_conv_to_posix_path): Return result of path conversion.
(cygwin_conv_to_full_posix_path): Ditto.
(return_with_errno): New macro.
(cygwin_win32_to_posix_path_list): Use new macro to potentially set errno.
(cygwin_posix_to_win32_path_list): Ditto.
* path.h (mount_item::fnmunge): Add size argument.
(mount_item::build_win32): Ditto.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
d188 2
a194 2
#define isslash(c) ((c) == '/')

d371 3
a373 1
  if (drive_type_storage == DRIVE_REMOTE || (drive_type_storage == DRIVE_UNKNOWN && (root_dir_storage[0] == '\\' && root_dir_storage[1] == '\\')))
@


1.287
log
@* Makefile.in (clean): Clean libserver, too.
* fhandler.cc (fhandler_base::~fhandler_base): Remove path_conv cleanup.
* syscalls.cc (chroot): Ditto.
* path.cc (path_conv::~path_conv): Define new destructor.
(conv_path_list_buf_size): Remove explicit path_conv cleanup.
* path.h (path_conv::~path_conv): Declare new destructor.
@
text
@d1090 1
a1090 1
static void
d1108 4
a1111 2
	srcbuf[CYG_MAX_PATH - 1] = '\0';
      (*conv_fn) (len ? srcbuf : ".", d);
d1117 1
d1239 26
a1264 2
void
mount_item::fnmunge (char *dst, const char *src)
d1268 6
a1273 1
    strcpy (dst, src);
d1277 4
a1280 3
      *d++ = *src++;
      if (name_type < 0)
	d += __small_sprintf (d, "%%%02x", (unsigned char) *src++);
d1284 6
a1289 3
	  *d++ = *src++;
	else
	  d += __small_sprintf (d, "%%%02x", (unsigned char) *src++);
d1291 2
d1295 2
a1296 2
      else
	d += __small_sprintf (d, "%%%02x", (unsigned char) '.');
d1302 1
d1305 1
a1305 1
void
d1308 1
a1308 1
  int n;
d1332 7
a1338 2
      strcpy (dst + n, p);
      backslashify (dst, dst, 0);
d1341 20
a1360 16
    while (*p)
      {
	char slash = 0;
	char *s = strchr (p + 1, '/');
	if (s)
	  {
	    slash = *s;
	    *s = '\0';
	  }
	fnmunge (dst += n, p);
	if (!s)
	  break;
	n = strlen (dst);
	*s = slash;
	p = s;
      }
d1512 3
a1514 1
      mi->build_win32 (dst, pathbuf, flags, chroot_pathlen);
d3422 9
d3468 1
a3468 2
  mount_table->conv_to_posix_path (path, posix_path, 1);
  return 0;
d3476 1
a3476 2
  mount_table->conv_to_posix_path (path, posix_path, 0);
  return 0;
d3572 1
d3588 1
a3588 2
  conv_path_list (win32, posix, 1);
  return 0;
d3594 1
a3594 2
  conv_path_list (posix, win32, 0);
  return 0;
@


1.286
log
@* path.cc (mount_item::build_win32): Backslashify paths in non-managed case.
@
text
@d885 9
a3511 4
  if (!pc.normalized_path_size && pc.normalized_path)
    cfree (pc.normalized_path);		// FIXME - probably should be in a destructor but
  					// it's hard to justify a destructor for the few
   					// places where this is needed
@


1.285
log
@* exceptions.cc (set_signal_mask): Redefine to not pass by address.  Report
calculated mask in debugging output.
* sigproc.h (set_signal_mask): Reflect above change in declaration.
* path.cc (mount_item::build_win32): Take path apart before feeding it to
fnmunge.  Throughout, change use of _reent_winsup()-> to _my_tls.locals.
instead.  Throughout, remove obsolete MT_SAFE/_CYG_THREAD_FAILSAFE
considerations.  Througout, add cygtls.h include.
* Makefile.in (DLL_OFILES): Add cygtls.o.  Add some more objects to the
-fomit-frame-pointer list.
* acconfig.h: Remove obsolete settings.
* config.h.in: Ditto.
* bsdlib.cc: Add cygtls.h include.
* configure.in: Remove --enable-extra-threadsafe-checking.
* configure: Regenerate.
* cygtls.h (_local_storage): New struct renamed from _winsup_t (sic).
(_threadinfo:local_clib): Add new field.
(_threadinfo::locals): Ditto.
(_threadinfo::init_thread): Accept second _reent * argument.
(_threadinfo::call): Define as regparm.
(CYGTLS_PADSIZE): Remove unnecessary slop.
(_getreent): Define as a macro.
* thread.h: Remove _CYG_THREAD_FAILSAFE and MT_SAFE stuff.
(_winsup_t): Move to cygtls.h.
(ResourceLocks::ResourceLocks): Eliminate empty constructor.
(MTinterface::reents): Eliminate.
(MTinterface::thread_self_key): Eliminate.
(MTinterface::MTinterface): Eliminate.
* dcrt0.cc: Include stdio.h for _impure_ptr initialization.
(do_global_ctors): Remove run_ctors_p (sic) considerations.  Don't call atexit
here.
(__main): Initialize destructors for user here.
(dll_crt0_1): Accept a dummy argument.  Don't call init_thread here.  Don't set
_impure_ptr here.  Call do_global_ctors after more things have been
initialized.
(_dll_crt0): Define zeros buffer as max of needed size of CYGTLS_PADSIZE so
that it can be used for two purposes while minimizing stack usage.  Initialize
_impure_ptr specifically, for speed.  Call dll_crt0_1 with buffer argument.
(cygwin_dll_init): Call dll_crt0_1 with dummy argument.
* dtable.cc (dtable::find_unused_handle): Remove call to AssertResourceOwner.
* exceptions.cc: Move _threadinfo stuff to new file.
* cygtls.cc: New file.
* gentls_offsets: Accommodate increasing complexity of cygtls.h.
* hires.h (hires_base::~hires_base): Remove.
* init.cc (dll_entry): Remove setting of reents.
* thread.cc: Remove syslog.h include.
(__getreent): Simplify to use _my_tls.
(_reent_winsup): Delete.
(AssertResourceOwner): Delete.
(MTinterface::Init): Remove setting of _clib and _winsup, with all that
entails.
(MTinterface::fixup_after_fork): Ditto.
(pthread::thread_init_wrapper): Ditto.  Also remove call to
set_tls_self_pointer.
(pthread::set_tls_self_pointer): Eliminate.
(pthread::get_tls_self_pointer): Just return _my_tls.tid;
(__reent_t::init_clib): Eliminate.
* tlsoffsets.h: Regenerate.
@
text
@d1283 4
a1286 1
    strcpy (dst + n, p);
@


1.284
log
@* winsup.h (access_worker): Declare with added fhandler_base parameter.
* syscalls.cc (access_worker): Accommodate extra fhandler_base argument.  Use
it instead of stat_worker to determine stat information, when appropriate.
* fhandler.cc (fhandler_base::device_access_denied): Pass fhandler pointer to
access_worker so that it can use the proper method for determining stat
information.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Ditto.
@
text
@d75 1
a77 8
#ifdef _MT_SAFE
#define iteration _reent_winsup ()->_iteration
#define available_drives _reent_winsup ()->available_drives
#else
static int iteration;
static DWORD available_drives;
#endif

d1231 1
a1231 1
  if (!(flags & MOUNT_ENC) || !(name_type = special_name (src)))
d1282 19
a1300 1
  fnmunge (dst + n, p);
d2248 1
a2248 5
#ifdef _MT_SAFE
  struct mntent &ret=_reent_winsup ()->mntbuf;
#else
  static NO_COPY struct mntent ret;
#endif
d2255 1
a2255 1
	available_drives &= ~(1 << drivenum);
d2263 4
a2266 4
  strcpy (_reent_winsup ()->mnt_fsname, native_path);
  ret.mnt_fsname = _reent_winsup ()->mnt_fsname;
  strcpy (_reent_winsup ()->mnt_dir, posix_path);
  ret.mnt_dir = _reent_winsup ()->mnt_dir;
d2269 1
a2269 1
    strcpy (_reent_winsup ()->mnt_type, (char *) "user");
d2271 1
a2271 1
    strcpy (_reent_winsup ()->mnt_type, (char *) "system");
d2273 1
a2273 1
  ret.mnt_type = _reent_winsup ()->mnt_type;
d2280 1
a2280 1
    strcpy (_reent_winsup ()->mnt_opts, (char *) "textmode");
d2282 1
a2282 1
    strcpy (_reent_winsup ()->mnt_opts, (char *) "binmode");
d2285 1
a2285 1
    strcat (_reent_winsup ()->mnt_opts, (char *) ",cygexec");
d2287 1
a2287 1
    strcat (_reent_winsup ()->mnt_opts, (char *) ",exec");
d2289 1
a2289 1
    strcat (_reent_winsup ()->mnt_opts, (char *) ",noexec");
d2291 1
a2291 1
    strcat (_reent_winsup ()->mnt_opts, ",managed");
d2294 2
a2295 3
    strcat (_reent_winsup ()->mnt_opts, (char *) ",noumount");

  ret.mnt_opts = _reent_winsup ()->mnt_opts;
d2316 1
a2316 1
  while (available_drives)
d2319 1
a2319 1
	if (available_drives & mask)
d2325 1
a2325 1
	  available_drives &= ~mask;
d2434 2
a2435 2
  iteration = 0;
  available_drives = GetLogicalDrives ();
d2442 1
a2442 1
  return mount_table->getmntent (iteration++);
@


1.283
log
@Change use of BOOL, TRUE, FALSE to bool, true, false, as appropriate,
throughout.
* tty.cc (tty::common_init): Remove call to SetKernelObjectSecurity and edit
some comments.
* cygheap.h (init_cygheap::ctty): Add new element.
* devices.in (device::parse): Remove special handling for /dev/tty.
* devices.cc: Regenerate.
* dtable.cc (build_fh_pc): Don't reset /dev/tty device.  Let the device opener
do that.
* fhandler_termios.cc (tty_min::set_ctty): Redefine to _pinfo class.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Avoid setting
noninherit flag for ctty.
* tty.h: Move BOOLs to bools.
(tty_min::set_ctty): Redeclare to _pinfo class.
* pinfo.cc (_pinfo::set_ctty): Define new function based on tty_min::set_ctty.
Change first argument from tty number to tty_min class.
* pinfo.h (_pinfo::set_ctty): Declare.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Reflect move of
set_ctty to _pinfo class.
* fhandler_tty.cc (fhandler_tty_slave::open): Treat FH_TTY specially.  Use
saved cygheap value if it exists.  Otherwise convert to real device and save on
first time open.
(fhandler_tty_common::dup): Potentially set controlling tty if duping a slave
tty.
* syscalls.cc (setsid): Close controlling tty in cygheap.
* tty.cc: Change some BOOLs to bools.
@
text
@d559 1
a559 1
		fileattr = FILE_ATTRIBUTE_DIRECTORY;
@


1.282
log
@* path.cc (slash_unc_prefix_p): Allow '.' as a valid character after '\\' in a
UNC path.
@
text
@d105 1
a105 1
  BOOL case_check (char *path);
d111 1
a111 1
static BOOL shortcut_initalized;
d126 1
a126 1
      shortcut_initalized = TRUE;
d644 1
a644 1
		  case_clash = TRUE;
d653 1
a653 1
		case_clash = TRUE;
d901 1
a901 1
/* Return TRUE if src_path is a valid, internally supported device name.
d2198 1
a2198 1
      posix_path_p = TRUE;
d2381 1
a2381 1
    res = mount_table->add_item (win32_path, posix_path, flags, TRUE);
d2418 1
a2418 1
      res = mount_table->del_item (path, flags, TRUE);
d2458 1
a2458 1
BOOL
d2466 1
a2466 1
  return TRUE;
d2473 1
a2473 1
int allow_winsymlinks = TRUE;
d2645 1
a2645 1
static BOOL
d3064 1
a3064 1
BOOL
d3085 1
a3085 1
	  case_clash = TRUE;
d3097 1
a3097 1
  return TRUE;
@


1.281
log
@Eliminate use of sigframe and sigthread throughout.
* Makefile.in (DLL_OFILES): Add sigfe.o.  Remove reliance on cygwin.def from
cygwin0.dll dependency since dependence on sigfe.o implies that.  Generate def
file on the fly using 'gendef'.
* configure.in: Don't auto-generate cygwin.def.
* configure: Regenerate.
* cygwin.din: Add SIGFE stuff where appropriate.
* dcrt0.cc (dll_crt0_1): Initialize cygwin tls early in process startup.  Set
_main_tls to address of the main thread's cygwin tls.
* debug.h: Remove now unneeded WFSO and WFMO declarations.
* exceptions.cc (_last_thread): Define.
(set_thread_state_for_signals): New function.
(reset_thread_exception_for_signals): Ditto.
(init_thread_for_signals): Ditto.
(delete_thread_for_signals): Ditto.
(capture_thread_for_signals): Ditto.
(handle_exceptions): Set return address explicitly for exceptions prior to
calling sig_send.
(interrupt_on_return): Eliminate.
(setup_handler): Add preliminary implementation for dealing with
thread-specific signals by querying _main_tls.
(signal_exit): Use cygthread::main_thread_id instead of mainthread.id.
(call_signal_handler_now): For now, just handle the main thread.
* fork.cc (vfork): Save and restore main _my_tls.
* gendef: New file.  Generates def file and sigfe.s file.
* gentls_offsets: New file.  Generates offsets for perl to use in sigfe.s.
* how-signals-work.txt: Mention that info is obsolete.
* init.cc (dll_entry): Initialize cygwin tls storage here.
* miscfuncs.cc (low_priority_sleep): Make a C function for easier calling from
asm.
* perthread.h (vfork_save::tls): New element.
* signal.cc (nanosleep): Replace previous use of
sigframe.call_signal_handler_now with straight call to call_signal_handler_now.
(abort): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* sigproc.cc (sig_dispatch_pending): Ditto.
(sig_send): Ditto.
* sigproc.h: Declare call_signal_handler_now.
* thread.cc (pthread::thread_init_wrapper): Initialize cygwin tls.  Remove
obsolete and unworking signal stuff.
* thread.h (verifyable_object::sigs): Eliminate.
(verifyable_object::sigmask): Eliminate.
(verifyable_object::sigtodo): Eliminate.
(verifyable_object::exit): Make attribute noreturn.
(verifyable_object::thread_init_wrapper): Ditto.
(pthread_null::exit): Ditto.
* winbase.h (__stackbase): Always define.
* winsup.h (low_priority_sleep): Declare as a "C" function.
* include/cygwin/version.h: Bump API version to reflect sigwait export.
* include/sys/queue.h: Protect SLIST_ENTRY from previous declaration.
* signal.cc (sigwait): Implement.
* select.cc (fhandler_base::ready_for_read): Add debugging output.
* devices.h: Define more device pointers via their storage.
* devices.in: Don't parse things like /dev/inet/tcp, as they really have no
meaning.
* devices.cc: Regenerate.
* gendevices: Set proper protection for output file.
* cygtls.h: New file.
* gendef: New file.
* gentls_offsets: New file.
* tlsoffsets.h: New file.  Autogenerated.
* config/i386/longjmp.c: Remove.  File subsumed by gendef output.
* config/i386/makefrag: Remove obsolete file.
* fhandler.cc: Remove spurious access_worker declaration.
* spawn.cc (spawnve): Make debugging output more accurate.
* cygwin-gperf: Remove.
* devices.cc: Remove.
@
text
@d1079 1
a1079 1
	     && isalnum (path[2])
@


1.280
log
@	* dir.cc (mkdir): Use local security_descriptor. Call
	set_security_attribute appropriately.
	* external.cc (cygwin_internal): Ditto.
	* fhandler.cc (fhandler_base::open): Ditto.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto.
	* path.cc (symlink_worker): Ditto.
	* sec_acl.cc (setacl): Ditto. Call read_sd appropriately.
	(getace): Ditto.
	* sec_helper.cc (security_descriptor::malloc): New method.
	(security_descriptor::realloc): New method.
	(security_descriptor::free): New method.
	* security.cc (read_sd): Get security_descriptor as parameter instead
	of PSECURITY_DESCRIPTOR and a size. Drop unnecessary parameter check.
	Allocate the security_descriptor buffer according to size returned by
	a call to GetFileSecurity. Return buffer size on success.
	(write_sd): Get security_descriptor as parameter instead of
	PSECURITY_DESCRIPTOR and a size.
	(get_nt_attribute): Use local security_descriptor.
	(get_nt_object_attribute): Ditto in case of type == SE_REGISTRY_KEY.
	Allocate security_descriptor buffer according to size returned by
	a call to RegGetKeySecurity.
	(alloc_sd): Make static. Get security_descriptor as parameter instead
	of PSECURITY_DESCRIPTOR and a size. Drop unnecessary parameter check.
	(set_security_attribute): Get security_descriptor as parameter instead
	of PSECURITY_DESCRIPTOR and a size.
	(set_nt_attribute): Use local security_descriptor.
	(check_file_access): Ditto.
	* security.h: Add class security_descriptor.
	(read_sd): Change declaration to get security_descriptor as parameter
	instead of PSECURITY_DESCRIPTOR and a size.
	(write_sd): Ditto.
	(set_security_attribute): Ditto.
	(alloc_sd): Remove declaration.
	* thread.cc (semaphore::semaphore): Use local security_descriptor. Call
	set_security_attribute appropriately.
@
text
@a461 1
  sigframe thisframe (mainthread);
a3338 2
  sigframe thisframe (mainthread);

@


1.279
log
@2003-11-11  Robert Collins <rbtcollins@@hotmail.com>
	    Ron Parker <rdparker@@butlermfg.com>

	* bsdlib.cc: Update throughout to use CYG_MAX_PATH rather than MAX_PATH.
	* cygheap.h: Ditto.
	* dcrt0.cc: Ditto.
	* delqueue.cc: Ditto.
	* dlfcn.cc: Ditto.
	* dll_init.cc: Ditto.
	* dll_init.h: Ditto.
	* dtable.cc: Ditto.
	* environ.cc: Ditto.
	* environ.h: Ditto.
	* exceptions.cc: Ditto.
	* external.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_raw.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* miscfuncs.cc: Ditto.
	* mmap.cc: Ditto.
	* netdb.cc: Ditto.
	* path.cc: Ditto.
	* path.h: Ditto.
	* pinfo.cc: Ditto.
	* pinfo.h: Ditto.
	* pthread.cc: Ditto.
	* registry.cc: Ditto.
	* shared.cc: Ditto.
	* shared_info.h: Ditto.
	* smallprint.c: Ditto.
	* spawn.cc: Ditto.
	* strace.cc: Ditto.
	* syscalls.cc: Ditto.
	* thread.h: Ditto.
	* uinfo.cc: Ditto.
	* winsup.h: Ditto.
	* include/limits.h: Ditto.
	* include/cygwin/config.h: Ditto.
	* include/sys/param.h: Ditto.
@
text
@d2494 1
d2569 1
a2569 1
			    &sa, alloca (4096), 4096);
@


1.278
log
@* path.cc (dot_special_chars): New global variable.
(special_name): Make files ending in "." special.
(fnunmunge): Allow encoded ".".
(mount_item::fnmunge): Handle trailing ".".
@
text
@d91 1
a91 1
  char contents[MAX_PATH + 4];
d305 1
a305 1
	if ((dst - dst_start) >= MAX_PATH)
d336 1
a336 1
  char cwd_win32[MAX_PATH];
d362 2
a363 2
  char tmp_buf [MAX_PATH];
  strncpy (tmp_buf, win32_path, MAX_PATH);
d376 1
a376 1
  strncpy (root_dir_storage, tmp_buf, MAX_PATH);
d452 1
a452 1
  /* This array is used when expanding symlinks.  It is MAX_PATH * 2
d455 2
a456 2
  char path_copy[MAX_PATH + 3];
  char tmp_buf[2 * MAX_PATH + 3];
d466 1
a466 1
  static char last_src[MAX_PATH + 1];
d532 1
a532 1
	  char pathbuf[MAX_PATH];
d740 1
a740 1
      if (buflen + taillen > MAX_PATH)
d956 1
a956 1
      if (strlen (dst) + 1 + strlen (src) >= MAX_PATH)
d1001 1
a1001 1
      if ((dst - dst_start) >= MAX_PATH)
d1106 2
a1107 2
      if (len >= MAX_PATH)
	srcbuf[MAX_PATH - 1] = '\0';
d1304 1
a1304 1
   {,full_}win32_path must have sufficient space (i.e. MAX_PATH bytes).  */
d1328 1
a1328 1
  if (src_path_len >= MAX_PATH)
d1336 1
a1336 1
  char pathbuf[MAX_PATH];
d1533 1
a1533 1
   posix_path must have sufficient space (i.e. MAX_PATH bytes).
d1557 1
a1557 1
  if (src_path_len >= MAX_PATH)
d1573 1
a1573 1
  char pathbuf[MAX_PATH];
d1603 1
a1603 1
      if ((mi.posix_pathlen + (pathbuflen - mi.native_pathlen) + addslash) >= MAX_PATH)
d1620 1
a1620 1
	  char tmpbuf[MAX_PATH + 1];
d1683 1
a1683 1
  char posix_path[MAX_PATH];
d1694 1
a1694 1
      char native_path[MAX_PATH];
d1697 1
a1697 1
      posix_path_size = MAX_PATH;
d1700 1
a1700 1
	 over 256 but is under MAX_PATH. */
d1990 1
a1990 1
  int res = r.get_string (CYGWIN_INFO_CYGDRIVE_PREFIX, user, MAX_PATH, "");
d2004 1
a2004 1
  int res2 = r2.get_string (CYGWIN_INFO_CYGDRIVE_PREFIX, system, MAX_PATH, "");
d2124 2
a2125 2
  char nativetmp[MAX_PATH];
  char posixtmp[MAX_PATH];
d2184 1
a2184 1
  char pathtmp[MAX_PATH];
d2307 1
a2307 1
  char posix_path[MAX_PATH];
d2489 3
a2491 3
  char from[MAX_PATH + 5];
  char cwd[MAX_PATH + 1], *cp = NULL, c = 0;
  char w32topath[MAX_PATH + 1];
d2502 1
a2502 1
  if (strlen (topath) >= MAX_PATH)
d2543 1
a2543 1
	  getcwd (cwd, MAX_PATH + 1);
d2600 1
a2600 1
	  char buf[sizeof (SYMLINK_COOKIE) + MAX_PATH + 10];
d2680 1
a2680 1
  if (got != sizeof len || len == 0 || len > MAX_PATH)
d2726 1
a2726 1
      res = ReadFile (h, contents, MAX_PATH + 1, &got, 0);
d3222 1
a3222 1
  return getcwd (buf, MAX_PATH);
d3643 1
a3643 1
  for (i = 0, dlen = MAX_PATH, len = 0; i < 3; dlen *= 2, i++)
d3668 1
a3668 1
  char pathbuf[MAX_PATH];
@


1.277
log
@	* path.cc (normalize_posix_path): Test runs of more than two
	dots for being a run of only dots.  Let it pass if not.
@
text
@d1144 2
a1145 1
static char special_chars[] =
d1155 1
d1183 5
d1222 1
a1222 1
    if (!(c = special_char (src)))
d1253 6
@


1.276
log
@	* path.cc (win32_device_name): Fix comment.
@
text
@d285 8
a292 1
		    return ENOENT;
@


1.275
log
@* path.cc (win32_device_name): Only fill out destination buffer when it's
really a device.
@
text
@d895 3
a897 2
/* Return TRUE if src_path is a Win32 device name, filling out the device
   name in win32_path */
@


1.274
log
@* Makefile.in: Add YA method for generating devices.cc.
* child_info.h: YA update of another magic number.
* gendevices: New file.
* devices.in: New file.
* devices.cc: Regenerate.
* devices.shilka: Remove.
* devices.h: Correctly define device pointers.
(device): Remove now obsolete fields.
(device::native): Renamed from device::fmt.
* dtable.cc (build_fh_dev): Simplify in light of new unit parsing scheme.
(build_fh_pc): Ditto.
* path.cc (win32_device_name): Ditto.
* fhandler.h (fhandler_base::get_native_name): Reflect renaming of fmt to
native.
* fhandler_tty.cc (fhandler_tty_mster::init): Initialize slave device prior to
reporting unit.
@
text
@d898 1
a898 1
static BOOL
d902 2
d905 1
a905 1
  return dev.devn != FH_FS;
@


1.273
log
@	* devices.h (enum fh_devices): Remove DEV_RAWDRIVE_MAJOR and
	FH_RAWDRIVE.
	* devices.shilka (dev_rawdrive_storage): Remove.
	(unit_devices): Remove pointer to dev_rawdrive_storage.
	(uniq_devices): Remove rawdrive entry.
	* dtable.cc (build_fh_pc): Remove DEV_RAWDRIVE_MAJOR case.
	* path.cc (win32_device_name): ditto.
@
text
@d902 2
a903 16

  if (dev.devn == FH_FS)
    return false;

  switch (dev.major)
    {
      case DEV_TAPE_MAJOR:
	__small_sprintf (win32_path, dev.fmt, dev.minor % 128);
	break;
      case DEV_SD_MAJOR:
	__small_sprintf (win32_path, dev.fmt, dev.minor / 16, dev.minor % 16);
	break;
      default:
	__small_sprintf (win32_path, dev.fmt, dev.minor);
    }
  return true;
@


1.272
log
@	* devices.h: Move a few device major numbers.  Fix typo of FH_UDP.
	* device.shilka: Remove /dev/hd device entries, rename all device_hd*
	to device_sd*.
	(device::parse): Disallow units outside lower and upper bounds.
	* dtable.cc (build_fh_pc): Fix typo of FH_UDP.
	* path.cc (win32_device_name): Fix win32 name creation to match new
	device handling.
@
text
@a910 3
      case DEV_RAWDRIVE_MAJOR:
	__small_sprintf (win32_path, dev.fmt, dev.minor + 'A');
	break;
@


1.271
log
@* path.cc (symlink_info::check): Use new introducer for mknod'ed files.
(parse_device): Ditto.
* syscalls.cc (mknod_worker): Ditto.
@
text
@d906 1
a906 1
  switch (dev.devn)
d908 1
a908 1
      case FH_TAPE:
d911 5
a915 2
      case FH_RAWDRIVE:
	  __small_sprintf (win32_path, dev.fmt, dev.minor - 224 + 'A');
a918 1
	break;
@


1.270
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d2883 1
a2883 1
  mymajor = strtol (++contents, &endptr, 16);
d3019 1
a3019 1
	  else if (*contents == ':' && parse_device (contents))
@


1.269
log
@* path.cc (normalize_posix_path): Put check for '//' prefix back to denote a
UNC path.
(slash_unc_prefix_p): Remove vestige of old //c method for accessing drives.
@
text
@d66 1
a67 1
#include "path.h"
d100 3
d104 1
d361 2
a362 2
      name [0] = '\0';
      sym_opt = flags = serial = 0;
d366 1
a366 1
  if (strcmp (tmp_buf, root_dir) == 0)
d369 13
a381 13
  strncpy (root_dir, tmp_buf, MAX_PATH);
  drive_type = GetDriveType (root_dir);
  if (drive_type == DRIVE_REMOTE || (drive_type == DRIVE_UNKNOWN && (root_dir[0] == '\\' && root_dir[1] == '\\')))
    is_remote_drive = 1;
  else
    is_remote_drive = 0;

  if (!GetVolumeInformation (root_dir, NULL, 0, &serial, NULL, &flags,
				 name, sizeof (name)))
    {
      debug_printf ("Cannot get volume information (%s), %E", root_dir);
      name [0] = '\0';
      sym_opt = flags = serial = 0;
d389 1
a389 1
  sym_opt = (!is_remote_drive && strcmp (name, "NTFS") == 0) ? PC_CHECK_EA : 0;
a393 8
char *
path_conv::return_and_clear_normalized_path ()
{
  char *s = normalized_path;
  normalized_path = NULL;
  return s;
}

d401 1
a401 1
      fs.serial = 0;
d406 18
a423 1
      fs.serial = local.dwVolumeSerialNumber;
d425 1
a425 1
    fs.drive_type = DRIVE_UNKNOWN;
d473 7
a479 7
  devn = unit = 0;
  fs.root_dir[0] = '\0';
  fs.name[0] = '\0';
  fs.flags = fs.serial = 0;
  fs.sym_opt = 0;
  fs.drive_type = 0;
  fs.is_remote_drive = 0;
d544 2
a545 2
	  error = mount_table->conv_to_win32_path (path_copy, full_path, devn,
						   unit, &sym.pflags, 1);
d550 1
a550 1
	  if (devn == FH_CYGDRIVE)
d556 1
a556 1
		  devn = FH_BAD;
d561 1
a561 1
	  else if (isvirtual_dev (devn))
d564 1
a564 2
	      fhandler_virtual *fh =
		(fhandler_virtual *) cygheap->fdtab.build_fhandler (-1, devn, (const char *) path_copy, NULL, unit);
d566 1
a579 1
	      delete fh;
d583 1
a583 1
	  else if (devn != FH_BAD)
d596 1
a596 1
	    fs.root_dir[0] = '\0';
d620 13
a632 1
	  int len = sym.check (full_path, suff, opt | fs.sym_opt);
a783 6
  if (opt & PC_POSIX)
    {
      if (tail[1] != '\0')
	*tail = '/';
      normalized_path = cstrdup (path_copy);
    }
d797 1
a797 1
  if (devn == FH_BAD)
d801 1
a801 1
	  fs.root_dir[0] = '\0';
d809 2
a810 2
			fs.root_dir, this->path, fs.flags & FS_PERSISTENT_ACLS);
	  if (!(fs.flags & FS_PERSISTENT_ACLS) || (!allow_smbntsec && fs.is_remote_drive))
d822 1
a822 1
	  set_has_buggy_open (strcmp (fs.name, "SUNWNFS") == 0);
d831 2
d835 1
d868 9
a894 241
const char *windows_device_names[] NO_COPY =
{
  NULL,
  "\\dev\\console",
  "conin",
  "conout",
  "\\dev\\ttym",
  "\\dev\\tty%d",
  "\\dev\\ptym",
  "\\\\.\\com%d",
  "\\dev\\pipe",
  "\\dev\\piper",
  "\\dev\\pipew",
  "\\dev\\socket",
  "\\dev\\windows",

  NULL, NULL, NULL,

  "\\dev\\disk",
  "\\dev\\fd%d",
  "\\dev\\st%d",
  "nul",
  "\\dev\\zero",
  "\\dev\\%srandom",
  "\\dev\\mem",
  "\\dev\\clipboard",
  "\\dev\\dsp"
};

#define deveq(s) (strcasematch (name, (s)))
#define deveqn(s, n) (strncasematch (name, (s), (n)))
#define wdeveq(s) (strcasematch (w32_path, (s)))
#define wdeveqn(s, n) (strncasematch (w32_path, (s), (n)))
#define udeveq(s) (strcasematch (unix_path, (s)))
#define udeveqn(s, n) (strncasematch (unix_path, (s), (n)))

static int __stdcall
get_devn (const char *name, int &unit)
{
  int devn = FH_BAD;
  name += 5;
  if (deveq ("tty"))
    {
      if (real_tty_attached (myself))
	{
	  unit = myself->ctty;
	  devn = FH_TTYS;
	}
      else if (myself->ctty > 0)
	devn = FH_CONSOLE;
    }
  else if (deveqn ("tty", 3) && (unit = digits (name + 3)) >= 0)
    devn = FH_TTYS;
  else if (deveq ("ttym"))
    devn = FH_TTYM;
  else if (deveq ("ptmx"))
    devn = FH_PTYM;
  else if (deveq ("windows"))
    devn = FH_WINDOWS;
  else if (deveq ("dsp"))
    devn = FH_OSS_DSP;
  else if (deveq ("conin"))
    devn = FH_CONIN;
  else if (deveq ("conout"))
    devn = FH_CONOUT;
  else if (deveq ("null"))
    devn = FH_NULL;
  else if (deveq ("zero"))
    devn = FH_ZERO;
  else if (deveq ("random") || deveq ("urandom"))
    {
      devn = FH_RANDOM;
      unit = 8 + (deveqn ("u", 1) ? 1 : 0); /* Keep unit Linux conformant */
    }
  else if (deveq ("mem"))
    {
      devn = FH_MEM;
      unit = 1;
    }
  else if (deveq ("clipboard"))
    devn = FH_CLIPBOARD;
  else if (deveq ("port"))
    {
      devn = FH_MEM;
      unit = 4;
    }
  else if (deveqn ("com", 3) && (unit = digits (name + 3)) >= 0 && unit < 100)
    devn = FH_SERIAL;
  else if (deveqn ("ttyS", 4) && (unit = digits (name + 4)) >= 0)
    {
      devn = FH_SERIAL;
      unit++;
    }
  else if (deveq ("pipe"))
    devn = FH_PIPE;
  else if (deveq ("piper"))
    devn = FH_PIPER;
  else if (deveq ("pipew"))
    devn = FH_PIPEW;
  else if (deveq ("tcp") || deveq ("udp") || deveq ("streamsocket")
	   || deveq ("dgsocket"))
    {
      devn = FH_SOCKET;
      unit = tolower (*name) - 'a';
    }

  return devn;
}

/*
    major      minor    POSIX filename	NT filename
    -----      -----	--------------	-------------------------
    FH_TAPE	  0	/dev/st0	\device\tape0
    FH_TAPE	  1	/dev/st1	\device\tape1
    ...
    FH_TAPE	128	/dev/nst0	\device\tape0
    FH_TAPE	129	/dev/nst1	\device\tape1
    ...

    FH_FLOPPY     0	/dev/fd0	\device\floppy0
    FH_FLOPPY	  1	/dev/fd1	\device\floppy1
    ...

    FH_FLOPPY	 16	/dev/scd0	\device\cdrom0
    FH_FLOPPY	 17	/dev/scd0	\device\cdrom1
    ...

    FH_FLOPPY	 32	/dev/sda	\device\harddisk0\partition0
    FH_FLOPPY	 33	/dev/sda1	\device\harddisk0\partition1
    ...
    FH_FLOPPY	 47	/dev/sda15	\device\harddisk0\partition15

    FH_FLOPPY	 48	/dev/sdb	\device\harddisk1\partition0
    FH_FLOPPY    33     /dev/sdb1       \device\harddisk1\partition1
    ...
    FH_FLOPPY	208	/dev/sdl	\device\harddisk11\partition0
    ...
    FH_FLOPPY	223	/dev/sdl15	\device\harddisk11\partition15

    The following are needed to maintain backward compatibility with
    the old Win32 partitioning scheme on W2K/XP.

    FH_FLOPPY	224	from mount tab	\\.\A:
    ...
    FH_FLOPPY	250	from mount tab	\\.\Z:
*/
static int
get_raw_device_number (const char *name, const char *w32_path, int &unit)
{
  DWORD devn = FH_BAD;

  if (!w32_path)  /* New approach using fixed device names. */
    {
      if (deveqn ("st", 2))
	{
	  unit = digits (name + 2);
	  if (unit >= 0 && unit < 128)
	    devn = FH_TAPE;
	}
      else if (deveqn ("nst", 3))
	{
	  unit = digits (name + 3) + 128;
	  if (unit >= 128 && unit < 256)
	    devn = FH_TAPE;
	}
      else if (deveqn ("fd", 2))
	{
	  unit = digits (name + 2);
	  if (unit >= 0 && unit < 16)
	    devn = FH_FLOPPY;
	}
      else if (deveqn ("scd", 3))
	{
	  unit = digits (name + 3) + 16;
	  if (unit >= 16 && unit < 32)
	    devn = FH_FLOPPY;
	}
      else if (deveqn ("sd", 2) && isalpha (name[2]))
	{
	  unit = (cyg_tolower (name[2]) - 'a') * 16 + 32;
	  if (unit >= 32 && unit < 224)
	    if (!name[3])
	      devn = FH_FLOPPY;
	    else
	      {
		int d = digits (name + 3);
		if (d >= 1 && d < 16)
		  {
		    unit += d;
		    devn = FH_FLOPPY;
		  }
	      }
	}
    }
  else /* Backward compatible checking of mount table device mapping. */
    {
      if (wdeveqn ("tape", 4))
	{
	  unit = digits (w32_path + 4);
	  /* Norewind tape devices have leading n in name. */
	  if (deveqn ("n", 1))
	    unit += 128;
	  devn = FH_TAPE;
	}
      else if (wdeveqn ("physicaldrive", 13))
	{
	  unit = digits (w32_path + 13) * 16 + 32;
	  devn = FH_FLOPPY;
	}
      else if (isdrive (w32_path))
	{
	  unit = cyg_tolower (w32_path[0]) - 'a' + 224;
	  devn = FH_FLOPPY;
	}
    }
  return devn;
}

static int __stdcall get_device_number (const char *unix_path,
					const char *w32_path, int &unit)
  __attribute__ ((regparm(3)));
static int __stdcall
get_device_number (const char *unix_path, const char *w32_path, int &unit)
{
  DWORD devn = FH_BAD;
  unit = 0;

  if (*unix_path == '/' && udeveqn ("/dev/", 5))
    {
      devn = get_devn (unix_path, unit);
      if (devn == FH_BAD && *w32_path == '\\' && wdeveqn ("\\dev\\", 5))
	devn = get_devn (w32_path, unit);
      if (devn == FH_BAD && wdeveqn ("\\\\.\\", 4))
	devn = get_raw_device_number (unix_path + 5, w32_path + 4, unit);
      if (devn == FH_BAD)
	devn = get_raw_device_number (unix_path + 5, NULL, unit);
    }

  return devn;
}

d899 1
a899 2
win32_device_name (const char *src_path, char *win32_path,
		   DWORD &devn, int &unit)
d901 1
a901 1
  const char *devfmt;
d903 1
a903 3
  devn = get_device_number (src_path, win32_path, unit);

  if (devn == FH_BAD)
d906 1
a906 3
  if ((devfmt = windows_device_names[FHDEVN (devn)]) == NULL)
    return false;
  switch (devn)
a907 9
      case FH_SOCKET:
	char *c;
	strcpy (win32_path, src_path);
	while ((c = strchr (win32_path, '/')))
	  *c = '\\';
	break;
      case FH_RANDOM:
	__small_sprintf (win32_path, devfmt, unit == 8 ? "" : "u");
	break;
d909 1
a909 1
	__small_sprintf (win32_path, "\\Device\\Tape%d", unit % 128);
d911 2
a912 10
      case FH_FLOPPY:
	if (unit < 16)
	  __small_sprintf (win32_path, "\\Device\\Floppy%d", unit);
	else if (unit < 32)
	  __small_sprintf (win32_path, "\\Device\\CdRom%d", unit - 16);
	else if (unit < 224)
	  __small_sprintf (win32_path, "\\Device\\Harddisk%d\\Partition%d",
				       (unit - 32) / 16, unit % 16);
	else
	  __small_sprintf (win32_path, "\\DosDevices\\%c:", unit - 224 + 'A');
d915 1
a915 1
	__small_sprintf (win32_path, devfmt, unit);
d918 1
a918 1
  return TRUE;
d1299 2
a1300 3
mount_info::conv_to_win32_path (const char *src_path, char *dst,
				DWORD &devn, int &unit, unsigned *flags,
				bool no_normalize)
d1312 1
a1312 2
  devn = FH_BAD;
  unit = 0;
d1363 1
a1363 1
  if (win32_device_name (pathbuf, dst, devn, unit))
d1375 3
a1377 2
      devn = fhandler_proc::get_proc_fhandler (pathbuf);
      if (devn == FH_BAD)
d1383 2
d1391 1
a1391 1
	    devn = FH_CYGDRIVE;
d1449 2
a1450 2
  if (!isvirtual_dev (devn))
    win32_device_name (src_path, dst, devn, unit);
d1505 1
a1505 1
      unit = -1;
d2471 7
d2501 1
a2501 1
  if (allow_winsymlinks && !win32_path.exists ())
d2516 1
a2516 1
  if (win32_path.is_device () || win32_path.exists ())
d2522 10
a2531 1
  if (allow_winsymlinks)
d2555 1
d2562 2
a2563 2
  h = CreateFile (win32_path, GENERIC_WRITE, 0, &sa,
		  CREATE_NEW, FILE_ATTRIBUTE_NORMAL, 0);
d2570 1
a2570 1
      if (allow_winsymlinks)
d2610 2
a2611 2
	  DWORD attr = allow_winsymlinks ? FILE_ATTRIBUTE_READONLY
					 : FILE_ATTRIBUTE_SYSTEM;
d2617 1
a2617 1
	  SetFileAttributes (win32_path.get_win32 (), attr);
d2619 1
a2619 1
	  if (win32_path.fs_fast_ea ())
d2632 2
a2633 1
  syscall_printf ("%d = symlink (%s, %s)", res, topath, frompath);
d2875 42
d2945 2
d3012 1
a3012 2
       * should we write it there?
       */
d3017 5
a3021 1
	  if (res)
d3040 1
a3040 1
      syscall_printf ("not a symlink");
d3488 2
a3489 1
  cfree (pc.normalized_path);		// FIXME - probably should be in a destructor but
@


1.268
log
@* Makefile.in: Add some more -fomit-frame-pointer files.
* path.cc (conv_path_list_buf_size): Free normalized_path or suffer memory
leak.
* syscalls.cc (chroot): Ditto.
@
text
@d206 1
a206 1
  if (isdrive (src))
d209 1
a209 1
      if (!err && isdrive (dst))
d1318 1
a1318 3
	     && isalpha (path[2])
	     && path[3] != 0
	     && !isdirsep (path[3])
@


1.267
log
@* Makefile.in (MALLOC_OFILES): Always fill in with correct malloc object.
* configure.in: Fill in MALLOC_OFILES with either debugging or regular malloc.
* configure: Regenerate.
* dlmalloc.c: Make various fruitless changes to attempt to get to work.
* dlmalloc.h: Ditto.
* malloc.cc (free): Check malloc pool when debugging.
* path.cc (win32_device_name): Eliminate compiler warning.
* sigproc.cc (sig_dispatch_pending): Remove use of was_pending.  Let
thisframe.call_signal_handler decide if handler should be called rather than
using bogus was_pending check.
* exceptions.cc (interrupt_setup): Remove accidentally checked in debugging
code.
* heap.cc (sbrk): Save rounded addess in user_heap_max.
@
text
@d3656 4
@


1.266
log
@* syscalls.cc (mount): Don't check win32_path when doing cygdrive mount.
@
text
@d1127 1
a1127 1
	while (c = strchr (win32_path, '/'))
@


1.265
log
@* path.cc (mount): Add null/empty check for input parameters.
(umount): Add null/empty check for input parameters.
@
text
@d2595 1
a2595 2
  if (check_null_empty_str_errno (win32_path)
      || check_null_empty_str_errno (posix_path))
d2607 1
a2607 1
  else
@


1.264
log
@* path.cc (special_name): Accommodate all special names with extensions.
@
text
@d2595 4
a2598 1
  if (strpbrk (posix_path, "\\:"))
d2623 2
@


1.263
log
@	* path.cc (special_name): Add checks for some specials followed by
	a "." and a FIXME comment.
@
text
@d1421 2
a1422 11
  // FIXME: add com0 and {com,lpt}N.*
  if (strcasematch (s, "nul")
      || strncasematch (s, "nul.", 4)
      || strcasematch (s, "aux")
      || strncasematch (s, "aux.", 4)
      || strcasematch (s, "prn")
      || strncasematch (s, "prn.", 4)
      || strcasematch (s, "con")
      || strncasematch (s, "con.", 4)
      || strcasematch (s, "conin$")
      || strcasematch (s, "conout$"))
d1424 9
a1432 2
  if (!strncasematch (s, "com", 3)
      && !strncasematch (s, "lpt", 3))
d1434 2
a1435 3
  char *p;
  (void) strtoul (s + 3, &p, 10);
  return -(*p == '\0');
@


1.262
log
@* path.cc (cygdrive_getmntent): Do not skip over drives of type
DRIVE_REMOVABLE.
* fhandler.cc (fhandler_base::lseek): Be more paranoid when constructing
offsets from 64 bit value.
* syscalls.cc (logout): Avoid temp buffer memcpy since new scheme does not
require it.
(utmp_data): Rework as a macro which returns a pointer into a buffer.
(getutent): Use new buffer allocation mechanism to grab a utmp buffer.
(getutid): Ditto.
(pututline): Ditto.
@
text
@d1421 1
d1423 1
d1425 1
d1427 1
d1429 1
@


1.261
log
@* exceptions.cc (ctrl_c_handler): Send SIGHUP when events occur only if there
is a tty associated with the process.  Send SIGHUP on CTRL_LOGOFF_EVENT.
* fhandler_tty.cc (fhandler_tty_slave::open): Adjust console open handle
counter regardless of whether this is a pty or tty.
(fhandler_tty_slave::open): Ditto.
(fhandler_tty_slave::dup): Ditto.
(fhandler_tty_common::set_close_on_exec): Ditto.
(fhandler_tty_master::init_console): Decrement console open handle counter
after init since it will now be handled by all tty open.
* syscalls.cc (setsid): Rework debugging output slightly.
@
text
@d2542 1
a2542 2
      if (GetDriveType (native_path) == DRIVE_REMOVABLE ||
	  GetFileAttributes (native_path) == INVALID_FILE_ATTRIBUTES)
@


1.260
log
@* path.cc (get_device_number): Remove special com?  consideration.
(special_chars): Make static.
(special_introducers): New.
(special_char): Allow specified valid_chars args.
(fnunmunge): Handle aux-like filenames correctly.
(special_name): Add con, conin$, conout$.
(mount_item::fnmunge): Use __small_sprintf return value to calculate
increments.
@
text
@d1394 1
a1394 1
static char special_introducers[] = 
d1437 1
a1437 1
fnunmunge (char *dst, const char *src) 
@


1.259
log
@* path.cc (fillout_mntent): Change "posix" to "managed".
@
text
@a1101 9
  else
    {
      char *p = strrchr (unix_path, '/');
      if (p)
	unix_path = p + 1;
      if (udeveqn ("com", 3)
	 && (unit = digits (unix_path + 3)) >= 0 && unit < 100)
	devn = FH_SERIAL;
    }
d1384 1
a1384 1
char special_chars[] =
d1394 2
d1397 2
a1398 2
static inline char
special_char (const char *s)
d1400 7
a1406 7
  char *p = strechr (special_chars, *s);
  if (*p == '%' && strlen (p) >= 3)
    {
      char hex[] = {s[1], s[2], '\0'};
      unsigned char c = strtoul (hex, &p, 16);
      p = strechr (special_chars, c);
    }
d1410 26
d1442 10
d1453 1
a1453 1
    if (*src != '%' || !(c = special_char (src)))
a1465 22
/* Determines if name is "special".  Assumes that name is empty or "absolute" */
static int
special_name (const char *s)
{
  if (!*s)
    return false;

  if (strpbrk (++s, special_chars))
    return !strncasematch (s, "%2f", 3);

  if (strcasematch (s, "nul")
      || strcasematch (s, "aux")
      || strcasematch (s, "prn"))
    return -1;
  if (!strncasematch (s, "com", 3)
      && !strncasematch (s, "lpt", 3))
    return false;
  char *p;
  (void) strtol (s, &p, 10);
  return -(*p == '\0');
}

d1477 1
a1477 4
	{
	  __small_sprintf (d, "%%%02x", (unsigned char) *src++);
	  d += 3;
	}
d1480 1
a1480 1
	if (!special_char (src))
d1483 1
a1483 4
	  {
	    __small_sprintf (d, "%%%02x", (unsigned char) *src++);
	    d += 3;
	  }
@


1.258
log
@* fhandler.h (FH_ENC): New enum.
(fhandler_base::get_encoded): New function.
(fhandler_base::set_encoded): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Set encoded flag in
fhandler, as appropriate.
(fhandler_disk_file::readdir): Unmunge filename as appropriate based on new
encoding flag.
* path.cc (normalize_posix_path): Don't punt on files with colons.
(special_char): New function.
(mount_item::fnmunge): Ditto.
(fnunmunge): Ditto.
(special_name): Ditto.
(mount_item::build_win32): Avoid drive considerations when file is encoded.
(mount_info::conv_to_win32_path): Handle encoded filenames.
(mount_info::conv_to_posix_path): Ditto.
(fillout_mntent): Add posix string when directory is encoded.
* path.h (fnunmunge): Declare.
(path_conv::is_encoded): Declare.
@
text
@d2508 1
a2508 1
    strcat (_reent_winsup ()->mnt_opts, ",posix");
@


1.257
log
@* path.cc (mount): Do more strict checking on posix path arguments.
@
text
@d206 1
a206 1
  if (isdrive (src) || strpbrk (src, "\\:"))
d502 1
a502 1
	 return.  If a symlink is found exit the for loop.
d1393 66
d1462 24
a1485 1
  strcpy (dst, src);
d1512 1
a1512 1
  else if ((isdrive (dst) && !dst[2]) || *p)
a1566 16
  /* An MS-DOS spec has either a : or a \.  If this is found, short
     circuit most of the rest of this function. */
  if (strpbrk (src_path, ":\\") != NULL || slash_unc_prefix_p (src_path))
    {
      debug_printf ("%s already win32", src_path);
      rc = normalize_win32_path (src_path, dst);
      if (rc)
	{
	  debug_printf ("normalize_win32_path failed, rc %d", rc);
	  return rc;
	}

      set_flags (flags, (unsigned) set_flags_from_win32_path (dst));
      goto out;
    }

d1663 1
a1663 1
  if (i >= nmounts)
d1665 2
a1666 3
      backslashify (pathbuf, dst, 0);	/* just convert */
      set_flags (flags, PATH_BINARY);
      chroot_ok = !cygheap->root.exists ();
d1670 8
a1677 2
      mi->build_win32 (dst, pathbuf, flags, chroot_pathlen);
      chroot_ok = true;
d1841 6
d2507 2
d3433 1
a3433 1
  const char *native_dir = path.get_win32 ();
@


1.256
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d1897 1
a1897 1
mount_info::add_reg_mount (const char * native_path, const char * posix_path, unsigned mountflags)
d1901 6
d1957 1
d2507 3
a2509 1
  if (flags & MOUNT_CYGDRIVE) /* normal mount */
@


1.255
log
@* path.cc (conv_path_list): Use correct value when calculating length to avoid
a potential SEGV.
@
text
@a55 1
#include <errno.h>
@


1.254
log
@* path.cc (mount_info::conv_to_win32_path): gcc warning about chroot_ok was
actually valid.  Fix it.
@
text
@d3554 1
a3554 1
    + (nrel * strlen (to_posix ? pc.get_win32 () : pc.normalized_path))
@


1.253
log
@* cygheap.cc (init_cheap): Temporarily remove inline that newer gcc's have
problems with.
* path.cc (path_conv::check): Rework has_acls logic slightly.  Uncouple exec
tests away from filesystem tests.
@
text
@d799 3
a801 1
		set_exec (0);
d1447 1
a1590 2
  bool chroot_ok;
  chroot_ok = false; // sigh.  stop gcc warning
@


1.252
log
@* mkvers.sh: Avoid "-dontuse" tags.
* path.cc (path_conv::check): Set exec state based on known situations.
* path.cc (mount_item::fnmunge): New function.
(mount_item::build_win32): New function.
(mount_info::conv_to_win32_path): Use build_win32 to build windows path.
* path.h (mount_item::fnmunge): Declare new function.
(mount_item::build_win32): Ditto.
* sys/mount.h (MOUNT_ENC): Define.
@
text
@d785 2
a786 2
	  set_has_acls (false);
	  set_has_buggy_open (false);
d793 1
a793 1
	  if (!allow_smbntsec && fs.is_remote_drive)
d797 2
a798 7
	      set_has_acls (fs.flags & FS_PERSISTENT_ACLS);
	      if (exec_state () != dont_know_if_executable)
		/* ok */;
	      else if (isdir ())
		set_exec (1);
	      else if (issymlink () || issocket ()
		       || allow_ntsec && wincap.has_security ())
a799 1

d805 6
@


1.251
log
@	Replace ino_t by __ino64_t throughout.
@
text
@d796 11
a806 1
	    set_has_acls (fs.flags & FS_PERSISTENT_ACLS);
d1392 35
a1452 1
  int chroot_ok = !cygheap->root.exists ();
d1558 2
a1559 2
  int chrooted_path_len;
  chrooted_path_len = 0;
d1576 1
a1576 1
	  chrooted_path_len = len = strlen (path);
d1580 1
a1580 1
	  chrooted_path_len = 0;
d1588 2
d1594 1
d1598 2
a1599 27
      int n;
      const char *native_path;
      int posix_pathlen;
      if (chroot_ok || chrooted_path_len || mi->posix_pathlen != 1
	  || mi->posix_path[0] != '/')
	{
	  n = mi->native_pathlen;
	  native_path = mi->native_path;
	  posix_pathlen = chrooted_path_len ?: mi->posix_pathlen;
	  chroot_ok = 1;
	}
      else
	{
	  n = cygheap->root.native_length ();
	  native_path = cygheap->root.native_path ();
	  posix_pathlen = mi->posix_pathlen;
	  chroot_ok = 1;
	}
      memcpy (dst, native_path, n + 1);
      const char *p = pathbuf + posix_pathlen;
      if (*p == '/')
	/* nothing */;
      else if ((isdrive (dst) && !dst[2]) || *p)
	dst[n++] = '\\';
      strcpy (dst + n, p);
      backslashify (dst, dst, 0);
      set_flags (flags, (unsigned) mi->flags);
@


1.250
log
@* dir.cc (readdir): Fill out new old_d_ino field.
* fhandler.h (fhandler_base::namehash): Define as ino_t.
(fhandler_base::get_namehash): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Accommodate new 64
bit st_ino.
* fhandler_socket.cc (fhandler_socket::fstat): Ditto.
* path.cc (hash_path_name): Return ino_t.
* syscalls.cc (stat64_to_stat32): Convert 64 bit inode to 32 bit.
* winsup.h (hash_path_name): Declare as returning ino_t.
* include/cygwin/stat.h (__stat32): Use 32 bit st_ino.
(__stat64): Use 64 bit st_ino.
* include/cygwin/types.h (__ino64_t): Define.
(__ino32_t): Ditto.
(ino_t): Define appropriately.
@
text
@d3188 2
a3189 2
ino_t __stdcall
hash_path_name (ino_t hash, const char *name)
@


1.249
log
@* errno.cc (_sys_nerr): Fix compile error erroneously checked in on 2003-04-23.
@
text
@d3188 1
a3188 1
unsigned long __stdcall
@


1.248
log
@whitespace cleanup
@
text
@d3189 1
a3189 1
hash_path_name (unsigned long hash, const char *name)
@


1.248.2.1
log
@* cygwin.din: Export btowc, trunc.
* include/cygwin/version.h: Reflect new exports.
* syscalls.cc (_stat): Rename to stat to avoid newlib wrapper.
* syscalls.cc (_fstat): Ditto.
@
text
@d1125 1
a1125 1
	while ((c = strchr (win32_path, '/')))
@


1.247
log
@* path.h (PATH_LNK): New enum val.
(path_conv::is_lnk_symlink): New function.  True if path represents .lnk style
symlink.
* path.cc (check_shortcut): Set PATH_LNK in pflags when appropriate.
(symlink_info::check): Ditto.  Remove PATH_LNK from pflags initially.
* syscalls.cc (unlink): Always remove readonly attribute from a symlink
regardless of type.
(link): (from Corinna Vinschen) Allow links to symlinks.  Reset attributes on a
symlink after successful link creation.
(chmod): Use is_lnk_symlink where appropriate.
(rename): Ditto.
* tty.cc (create_tty_master): Call GetComputerName instead of
cygwin_gethostname.  Set ut_id.
* syscalls.cc (login): Call endutent.
(setutent): Do not seek after a fresh open.
@
text
@d1127 1
a1127 1
        break;
@


1.246
log
@	* dtable.cc (dtable::build_fhandler_from_name): Set some fhandler
	data on sockets to evaluate AF_LOCAL sockets correctly.
	(dtable::build_fhandler): Set unit number on sockets.
	* fhandler.h (fhandler_socket): Add unit number.
	(fhandler_socket::get_unit): New method.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Set unit
	number.
	(fhandler_socket::fstat): Reorganize to return more Linux-like
	values.
	* net.cc: include ctype.h.
	(fdsock): Set unit number when building fhandler.
	* path.cc (path_conv::check): Set device type to FH_SOCKET if file
	is a AF_UNIX socket.
	(get_devn): Evaluate unit for virtual socket devices.
	(win32_device_name): Set windows path for sockets to unix_path with
	just backslashes to keep the different names.
	* syscalls.cc (fstat64): Don't override st_ino, st_dev and st_rdev
	for sockets.
	(stat_worker): Ditto.

From Pierre Humblet:

	* autoload.cc (AccessCheck): Add.
	(DuplicateToken): Add.
	* security.h (check_file_access): Declare.
	* syscalls.cc (access): Convert path to Windows, check existence
	and readonly attribute. Call check_file_access instead of acl_access.
	* security.cc (check_file_access): Create.
	* sec_acl (acl_access): Delete.
@
text
@d2778 1
a2778 1
    *pflags = PATH_SYMLINK;
d2993 1
a2993 1
  is_symlink = TRUE;
d2997 1
a2997 1
  pflags &= ~PATH_SYMLINK;
d3046 2
@


1.245
log
@* path.cc: Change 'to_posix_p' to 'to_posix' throughout.
(conv_path_list_buf_size): Accommodate relative paths.
@
text
@a801 1
#if 0
a803 1
#endif
d955 4
a958 1
    devn = FH_SOCKET;
d1122 6
@


1.244
log
@* path.cc (etc::dir_changed): Fix debug printf.
@
text
@d1321 1
a1321 1
conv_path_list (const char *src, char *dst, int to_posix_p)
d1325 3
a1327 3
  char src_delim = to_posix_p ? ';' : ':';
  char dst_delim = to_posix_p ? ':' : ';';
  int (*conv_fn) (const char *, char *) = (to_posix_p
d3490 1
a3490 1
conv_path_list_buf_size (const char *path_list, int to_posix_p)
d3495 1
d3499 8
a3506 4
  char delim = to_posix_p ? ';' : ':';
  p = path_list;
  for (num_elms = 1; (p = strchr (p, delim)) != NULL; ++num_elms)
    ++p;
d3509 2
a3510 1
  for (max_mount_path_len = 7, i = 0; i < mount_table->nmounts; ++i)
d3512 1
a3512 1
      int mount_len = (to_posix_p
d3520 4
a3523 1
  size = strlen (path_list) + (num_elms * max_mount_path_len) + 100;
d3530 1
a3530 1
  return conv_path_list_buf_size (path_list, 1);
d3536 1
a3536 1
  return conv_path_list_buf_size (path_list, 0);
@


1.243
log
@	* path.cc (symlink): Create security attributes so that only the
	user can modify the symlink.
	* security.cc (set_security_attribute): Remove symlink special
	handling.
@
text
@d3820 1
a3820 2
	    system_printf ("Can't open /etc for checking, %E", (char *) pwd,
			   changed_h);
@


1.242
log
@* pwdrp.h (pwdgrp::refresh): Lock entire test prior to reading.
* grp.cc (pwdgrp::parse_group): Eliminate arg and use class member instead.
Use next_str and next_int to parse arguments.
* passwd.cc (pwdgrp::parse_passwd): Ditto.
(grab_string): Eliminate.
(grab_int): Ditto.
* pwdgrp.h (pwdgrp::parse): Eliminate input arg.
(pwdgrp::parse_passwd): Reflect above change.
(pwdgrp::parse_group): Reflect above change.
(pwdgrp::next_str): New function.
(pwdgrp::next_int): Ditto.
(pwdgrp::gets): Eliminate.
* uinfo.cc (pwdgrp::next_str): New function.
(pwdgrp::next_int): Ditto.
(pwdgrp::add_line): Subsume gets.
(pwdgrp::gets): Eliminate.
(pwdgrp::load): Just call add_line to parse input buffer.
@
text
@d2646 1
a2646 1
    set_security_attribute (S_IFLNK | S_IRWXU | S_IRWXG | S_IRWXO,
@


1.241
log
@* path.h (etc::change_possible): Revert the type to bool.
(etc::set_last_modified): Remove obsolete function.
* path.cc (etc::change_possible): Revert type to bool.
(etc::test_file_change): Do not test for negative values of change_possible and
do not set it to -res.
(etc::dir_changed): When the handle is NULL, call memset instead of
test_file_changed.  When the handle is invalid, return true.
(etc::file_changed): Remove unneeded check for !fn[n].
@
text
@d3816 2
a3817 1
						  FILE_NOTIFY_CHANGE_LAST_WRITE);
@


1.240
log
@* pwdgrp.h (etc): Move to path.h.
(pwdgrp::max_lines): New field.
(pwdgrp::curr_lines): New field.
(pwdgrp::pwdgrp_buf): Ditto.
(pwdgrp_buf_elem_size): Ditto.
(pwdgrp_parse): Ditto.
(pwdgrp::gets): Just declare here.
(pwdgrp::load): Ditto.  Just take one argument.
(pwdgrp::load): Define overloaded function accepting passwd buf.
(pwdgrp::load): Define overloaded function accepting group buf.
* grp.cc: Use pwdgrp elements rather than standalone static variables
throughout.
(curr_lines): Eliminate.
(max_lines): Ditto.
(add_grp_line): Ditto.
(parse_grp): Define as returning boolean.  Accept void * arg and line count.
Coerce first argument into __group32 buf reference.  Increment curr_line as
appropriate.
(read_etc_group): Pass pwdgrp buffer to gr.load.
* passwd.cc: Use pwdgrp elements rather than standalone static variables
throughout.
(curr_lines): Eliminate.
(max_lines): Ditto.
(add_grp_line): Ditto.
(parse_passwd): Define as returning boolean.  Accept void * arg and line count.
Coerce first argument into passwd buf reference.  Increment curr_line as
appropriate.
(read_etc_group): Pass pwdgrp buffer to pr.load.
* path.cc (etc::fn): Extend buffer size to allow index by 1 rather than zero.
(etc::last_modified): Ditto.
(etc::change_possible): Ditto.  Renamed from sawchange.  Change to signed char
since elements are now tri-state.
(etc::init): Assume "handle" is 1 based rather than 0.
(etc::test_file_change): New function.  Sets change_possible based on file date
comparison.
(etc::dir_changed): Check file states immediately after changed_h is
initialized to avoid a race.
(etc::file_changed): Use test_file_change to detect if file needs to be
updated.
* path.h (etc): Move class here from pwdgrp.h.
* uinfo.cc: Move etc:: functions to path.cc.  Move pwdgrp functions here.
(pwdgrp::gets): Eliminate buf checks.  Just check eptr and set lptr.
(pwdgrp::add_line): New function.
(pwdgrp::load): Call generic add_line function which will call correct parser.
@
text
@d3759 1
a3759 1
signed char etc::change_possible[MAX_ETC_FILES + 1];
d3787 1
a3787 6
  if (change_possible[n] < 0)
    {
      res = true;
      paranoid_printf ("fn[%d] %s, already marked changed", n, fn[n]);
    }
  else if ((h = FindFirstFile (fn[n], &data)) == INVALID_HANDLE_VALUE)
a3797 1
      change_possible[n] = -res;
d3822 1
a3822 2
	  for (int i = 1; i <= curr_ix; i++)
	    (void) test_file_change (i);
d3826 1
a3826 1
	(void) test_file_change (n);	/* semi-brute-force way */
d3830 1
a3830 1
	  memset (change_possible, 1, sizeof change_possible);
d3842 1
a3842 3
  if (!fn[n])
    res = true;
  else if (dir_changed (n) && test_file_change (n))
d3844 1
a3844 1
  change_possible[n] = 0;
@


1.239
log
@* path.cc (normalize_posix_path): Convert win32 path separators to slashes when
full path is specified.
@
text
@d3756 101
@


1.238
log
@* path.cc: Unrevert below reversion except for mount_info::conv_to_posix_path
part.
@
text
@d208 7
a214 1
    return normalize_win32_path (src, dst);
@


1.238.2.1
log
@merge from trunk
@
text
@a100 3
  _major_t major;
  _minor_t minor;
  _mode_t mode;
a101 1
  bool parse_device (const char *);
d208 1
a208 7
    {
      int err = normalize_win32_path (src, dst);
      if (!err)
	for (char *p = dst; (p = strchr (p, '\\')); p++)
	  *p = '/';
      return err;
    }
d455 1
a455 1
  memset (&dev, 0, sizeof (dev));
d526 2
a527 2
	  error = mount_table->conv_to_win32_path (path_copy, full_path, dev,
						   &sym.pflags, 1);
d532 1
a532 1
	  if (dev.major == DEV_CYGDRIVE_MAJOR)
d538 1
a538 1
		  dev.devn = FH_BAD;
d543 1
a543 1
	  else if (isvirtual_dev (dev.devn))
d547 1
a547 1
		(fhandler_virtual *) cygheap->fdtab.build_fhandler (-1, dev, (const char *) path_copy, NULL);
d566 1
a566 1
	  else if (dev.devn != FH_BAD)
a604 14
	  if (sym.minor || sym.major)
	    {
	      dev.parse (sym.major, sym.minor);
	      if (!dev)
		error = ENODEV;
	      else
		{
		  dev.setfs (1);
		  dev.mode = sym.mode;
		  fileattr = sym.fileattr;
		}
	      goto out;
	    }

d774 1
a774 1
  if (dev.devn == FH_BAD)
d850 243
d1094 2
d1101 2
a1102 1
win32_device_name (const char *src_path, char *win32_path, device& dev)
d1104 3
a1106 1
  dev.parse (src_path);
d1108 1
a1108 1
  if (dev.devn == FH_BAD)
d1111 3
a1113 1
  switch (dev.devn)
d1115 3
d1119 1
a1119 1
	__small_sprintf (win32_path, dev.fmt, dev.minor % 128);
d1121 10
a1130 2
      case FH_RAWDRIVE:
	  __small_sprintf (win32_path, dev.fmt, dev.minor - 224 + 'A');
d1133 1
a1133 1
	__small_sprintf (win32_path, dev.fmt, dev.minor);
d1136 1
a1136 1
  return true;
a1368 10
/* CGF FIXME device */
static const device dev_proc =
{"/proc", FH_PROC, "/proc", 0, 0, 0, 0};

static const device dev_cygdrive =
{"/cygdrive", FH_CYGDRIVE, "/cygdrive", 0, 0, 0, 0};

static const device dev_fs =
{"", FH_FS, "", 0, 0, 0, 0};

d1383 3
a1385 2
mount_info::conv_to_win32_path (const char *src_path, char *dst, device& dev,
				unsigned *flags, bool no_normalize)
d1397 2
a1398 1
  dev.devn = FH_BAD;
d1465 1
a1465 1
  if (win32_device_name (pathbuf, dst, dev))
d1477 2
a1478 3
      dev = dev_proc;
      dev.devn = fhandler_proc::get_proc_fhandler (pathbuf);
      if (dev.devn == FH_BAD)
a1483 2
      int unit;

d1490 1
a1490 1
	    dev = dev_cygdrive;
d1567 2
a1568 2
  if (!isvirtual_dev (dev.devn))
    win32_device_name (src_path, dst, dev);
d1623 1
a1623 1
      unit = -1; /* FIXME: should be zero, maybe? */
d1707 1
a1707 1
      else if (*p == '/')
a2568 7
  return symlink_worker (topath, frompath, allow_winsymlinks, false);
}

int
symlink_worker (const char *topath, const char *frompath, bool use_winsym,
		bool isdevice)
{
d2592 1
a2592 1
  if (use_winsym && !win32_path.exists ())
d2607 1
a2607 1
  if (win32_path.is_auto_device ())
d2613 1
a2613 10
  DWORD create_how;
  if (!use_winsym)
    create_how = CREATE_NEW;
  else if (isdevice)
    {
      strcpy (w32topath, topath);
      create_how = CREATE_ALWAYS;
      (void) SetFileAttributes (win32_path, FILE_ATTRIBUTE_NORMAL);
    }
  else
a2636 1
      create_how = CREATE_NEW;
d2643 2
a2644 2
  h = CreateFile (win32_path, GENERIC_WRITE, 0, &sa, create_how,
		  FILE_ATTRIBUTE_NORMAL, 0);
d2651 1
a2651 1
      if (use_winsym)
d2691 2
a2692 2
	  DWORD attr = use_winsym ? FILE_ATTRIBUTE_READONLY
	    			  : FILE_ATTRIBUTE_SYSTEM;
d2698 1
a2698 1
	  SetFileAttributes (win32_path, attr);
d2700 1
a2700 1
	  if (!isdevice && win32_path.fs_fast_ea ())
d2713 1
a2713 2
  syscall_printf ("%d = symlink_worker (%s, %s, %d, %d)", res, topath,
		  frompath, use_winsym, isdevice);
a2954 42
bool
symlink_info::parse_device (const char *contents)
{
  char *endptr;
  _major_t mymajor;
  _major_t myminor;
  _mode_t mymode;

  mymajor = strtol (++contents, &endptr, 16);
  if (endptr == contents)
    return false;

  contents = endptr;
  myminor = strtol (++contents, &endptr, 16);
  if (endptr == contents)
    return false;

  contents = endptr;
  mymode = strtol (++contents, &endptr, 16);
  if (endptr == contents)
    return false;

  switch (mymode & S_IFMT)
    {
    case S_IFIFO:
      mymajor = _major (FH_FIFO);
      myminor = _minor (FH_FIFO);
      break;
    case S_IFBLK:
    case S_IFCHR:
      if (mymajor || myminor)
	break;
    default:
      return false;
    }

  major = mymajor;
  minor = myminor;
  mode = mymode;
  return true;
}

a2982 2
  major = 0;
  minor = 0;
d3046 2
a3047 1
         should we write it there?  */
d3052 1
a3052 5
	  if (!res)
	    /* check more below */;
	  else if (*contents == ':' && parse_device (contents))
	    goto file_not_symlink;
	  else
d3071 1
a3071 1
      syscall_printf ("%s", (major || minor) ? "is a device" : "not a symlink");
@


1.238.2.2
log
@* path.cc (normalize_posix_path): Convert win32 path separators to slashes when
full path is specified.
@
text
@d214 1
a214 1
      if (!err && isdrive (dst))
@


1.238.2.3
log
@trunk merge
@
text
@a3588 93

int etc::curr_ix = 0;
/* Note that the first elements of the below arrays are unused */
bool etc::change_possible[MAX_ETC_FILES + 1];
const char *etc::fn[MAX_ETC_FILES + 1];
FILETIME etc::last_modified[MAX_ETC_FILES + 1];

int
etc::init (int n, const char *etc_fn)
{
  if (n > 0)
    /* ok */;
  else if (++curr_ix <= MAX_ETC_FILES)
    n = curr_ix;
  else
    api_fatal ("internal error");

  fn[n] = etc_fn;
  change_possible[n] = false;
  (void) test_file_change (n);
  paranoid_printf ("fn[%d] %s, curr_ix %d", n, fn[n], curr_ix);
  return n;
}

bool
etc::test_file_change (int n)
{
  HANDLE h;
  WIN32_FIND_DATA data;
  bool res;

  if ((h = FindFirstFile (fn[n], &data)) == INVALID_HANDLE_VALUE)
    {
      res = true;
      memset (last_modified + n, 0, sizeof (last_modified[n]));
      debug_printf ("FindFirstFile failed, %E");
    }
  else
    {
      FindClose (h);
      res = CompareFileTime (&data.ftLastWriteTime, last_modified + n) > 0;
      last_modified[n] = data.ftLastWriteTime;
      debug_printf ("FindFirstFile succeeded");
    }

  paranoid_printf ("fn[%d] %s res %d", n, fn[n], res);
  return res;
}

bool
etc::dir_changed (int n)
{
  if (!change_possible[n])
    {
      static HANDLE changed_h NO_COPY;

      if (!changed_h)
	{
	  path_conv pwd ("/etc");
	  changed_h = FindFirstChangeNotification (pwd, FALSE,
						  FILE_NOTIFY_CHANGE_LAST_WRITE
						  | FILE_NOTIFY_CHANGE_FILE_NAME);
#ifdef DEBUGGING
	  if (changed_h == INVALID_HANDLE_VALUE)
	    system_printf ("Can't open /etc for checking, %E", (char *) pwd,
			   changed_h);
#endif
	  memset (change_possible, true, sizeof (change_possible));
	}

      if (changed_h == INVALID_HANDLE_VALUE)
	change_possible[n] = true;
      else if (WaitForSingleObject (changed_h, 0) == WAIT_OBJECT_0)
	{
	  (void) FindNextChangeNotification (changed_h);
	  memset (change_possible, true, sizeof change_possible);
	}
    }

  paranoid_printf ("fn[%d] %s change_possible %d", n, fn[n], change_possible[n]);
  return change_possible[n];
}

bool
etc::file_changed (int n)
{
  bool res = false;
  if (dir_changed (n) && test_file_change (n))
    res = true;
  change_possible[n] = false;	/* Change is no longer possible */
  paranoid_printf ("fn[%d] %s res %d", n, fn[n], res);
  return res;
}
@


1.238.2.4
log
@* Makefile.in (DLL_OFILES): Add fhandler_nodevice.o.
* devices.gperf (device::parse): Just set devn to input if device not found --
nonexistent device will be caught later.
* dtable.cc (dtable::build_fhandler): Build fhandler_nodevice type when unknown
device.
* fhandler.h (fhandler_nodevice): New class.
(fhandler_union): Add fhandler_nodevice.
* path.cc (path_conv::check): Always set device stuff if major/minor are
specified.
@
text
@d618 8
a625 3
	      dev.setfs (1);
	      dev.mode = sym.mode;
	      fileattr = sym.fileattr;
@


1.238.2.5
log
@merge from trunk
@
text
@d2426 1
a2426 1
    set_security_attribute (S_IFLNK | STD_RBITS | STD_WBITS,
@


1.238.2.6
log
@merge from trunk
@
text
@d1073 1
a1073 1
conv_path_list (const char *src, char *dst, int to_posix)
d1077 3
a1079 3
  char src_delim = to_posix ? ';' : ':';
  char dst_delim = to_posix ? ':' : ';';
  int (*conv_fn) (const char *, char *) = (to_posix
d3318 1
a3318 1
conv_path_list_buf_size (const char *path_list, bool to_posix)
a3322 1
  path_conv pc(".", PC_FULL | PC_POSIX);
d3326 4
a3329 8
  unsigned nrel;
  char delim = to_posix ? ';' : ':';
  for (p = path_list, num_elms = nrel = 0; p; num_elms++)
    {
      if (!isabspath (p))
	nrel++;
      p = strchr (++p, delim);
    }
d3332 1
a3332 2
  for (max_mount_path_len = sizeof ("/cygdrive/X"), i = 0;
       i < mount_table->nmounts; i++)
d3334 1
a3334 1
      int mount_len = (to_posix
d3342 1
a3342 4
  size = strlen (path_list)
    + (num_elms * max_mount_path_len)
    + (nrel * strlen (to_posix ? pc.get_win32 () : pc.normalized_path))
    + 100;
d3349 1
a3349 1
  return conv_path_list_buf_size (path_list, true);
d3355 1
a3355 1
  return conv_path_list_buf_size (path_list, false);
d3648 2
a3649 1
	    system_printf ("Can't open %s for checking, %E", (char *) pwd);
@


1.238.2.7
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d67 1
a68 1
#include "fhandler.h"
d556 2
a557 1
	      fhandler_virtual *fh = (fhandler_virtual *) build_fh_dev (dev, path_copy);
a558 1
	      delete fh;
d572 1
@


1.238.2.8
log
@* path.h (path_conv::set_normalized_path): Declare.
(path_conv::normalized_path_size): Declare.
(path_conv::return_and_clear_normalized_path): Delete declaration.
* path.cc (path_conv::set_normalized_path): Define.  Puts normalized path in
path buf if there is room.
(path_conv::check): Call set_normalized_path.
(path_conv::return_and_clear_normalized_path): Delete definition.
* dtable.cc (build_fh_dev): Ditto.
* fhandler.cc (fhandler_base::operator =): Ditto.
(fhandler_base::~fhandler_base): Only free normalized_path when appropriate.
@
text
@d395 8
a419 17
void
path_conv::set_normalized_path (const char *path_copy)
{
  char *eopath = strchr (path, '\0');
  size_t n = strlen (path_copy) + 1;

  normalized_path = path + sizeof (path) - n;
  if (normalized_path > eopath)
    normalized_path_size = n;
  else
    {
      normalized_path = (char *) cmalloc (HEAP_STR, n);
      normalized_path_size = 0;
    }
  memcpy (normalized_path, path_copy, n);
}

d773 6
a847 9
    }

  if (!(opt & PC_POSIX))
    normalized_path_size = 0;
  else
    {
      if (tail[1] != '\0')
	*tail = '/';
      set_normalized_path (path_copy);
@


1.238.2.9
log
@merge from trunk
@
text
@a631 3
	  if (sym.pflags & PATH_SOCKET)
	    dev.setfs (1);

a816 1

@


1.238.2.10
log
@* cygwin-gperf: Fix typo in FH_FS static storage.
* devices.gperf (device::parse): Default to fs "device" when nothing else is
found.
* fhandler.cc (fhandler_base::device_access_denied): Use access_worker rather
than access to avoid reparsing pc.
* fhandler_nodevice.cc (fhandler_nodevice::open): Set errno to ENXIO rather
than ENODEV.
* path.cc (path_conv::check): Default to FH_FS rather than FH_BAD.
(mount_info::conv_to_win32_path): Ditto.
(win32_device_name): Don't do device handling if FH_FS.
* path.h (path_conv::get_devn): Just return raw device number.
* syscalls.cc (access_worker): New function, split from access().  Correctly
deal with special devices in light of recent ntsec changes.
(access): Use access_worker.
@
text
@d557 1
a557 1
		  dev.devn = FH_FS;
d584 1
a584 1
	  else if (dev.devn != FH_FS)
d798 1
a798 1
  if (dev.devn == FH_FS)
d894 1
a894 1
  if (dev.devn == FH_FS)
d1179 1
a1179 1
  dev.devn = FH_FS;
d1491 1
a1491 1
      else if (isdirsep (*p))
@


1.238.2.11
log
@merge from trunk
@
text
@d2567 1
a2567 1
    *pflags = PATH_SYMLINK | PATH_LNK;
d2824 1
a2824 1
  is_symlink = true;
d2830 1
a2830 1
  pflags &= ~(PATH_SYMLINK | PATH_LNK);
a2878 2
	  if (sym_check == 1)
	    pflags |= PATH_LNK;
@


1.238.2.12
log
@Merge from trunk.
* Makefile.in: Explicitly call perl to run cygwin-gperf.
* path.cc: Move some device stuff.
* cygwin-gperf: Define some device stuff.
* devices.h: Declare some device stuff.
@
text
@d1142 10
d1258 1
a1258 1
      dev = *proc_dev;
d1274 1
a1274 1
	    dev = *cygdrive_dev;
@


1.238.2.13
log
@merge from trunk
@
text
@d362 2
a363 2
      name_storage [0] = '\0';
      sym_opt_storage = flags_storage = serial_storage = 0;
d367 1
a367 1
  if (strcmp (tmp_buf, root_dir_storage) == 0)
d370 13
a382 13
  strncpy (root_dir_storage, tmp_buf, MAX_PATH);
  drive_type_storage = GetDriveType (root_dir_storage);
  if (drive_type_storage == DRIVE_REMOTE || (drive_type_storage == DRIVE_UNKNOWN && (root_dir_storage[0] == '\\' && root_dir_storage[1] == '\\')))
    is_remote_drive_storage = 1;
  else
    is_remote_drive_storage = 0;

  if (!GetVolumeInformation (root_dir_storage, NULL, 0, &serial_storage, NULL, &flags_storage,
				 name_storage, sizeof (name_storage)))
    {
      debug_printf ("Cannot get volume information (%s), %E", root_dir_storage);
      name_storage[0] = '\0';
      sym_opt_storage = flags_storage = serial_storage = 0;
d390 1
a390 1
  sym_opt_storage = (!is_remote_drive_storage && strcmp (name_storage, "NTFS") == 0) ? PC_CHECK_EA : 0;
d402 1
a402 1
      fs.serial () = 0;
d407 1
a407 1
      fs.serial () = local.dwVolumeSerialNumber;
d409 1
a409 1
    fs.drive_type () = DRIVE_UNKNOWN;
d475 6
a480 6
  fs.root_dir ()[0] = '\0';
  fs.name ()[0] = '\0';
  fs.flags () = fs.serial () = 0;
  fs.sym_opt () = 0;
  fs.drive_type () = 0;
  fs.is_remote_drive () = 0;
d597 1
a597 1
	    fs.root_dir ()[0] = '\0';
d621 1
a621 1
	  int len = sym.check (full_path, suff, opt | fs.sym_opt ());
d802 1
a802 1
	  fs.root_dir ()[0] = '\0';
d810 2
a811 2
			fs.root_dir (), this->path, fs.flags () & FS_PERSISTENT_ACLS);
	  if (!allow_smbntsec && fs.is_remote_drive ())
d814 1
a814 1
	    set_has_acls (fs.flags () & FS_PERSISTENT_ACLS);
d817 1
a817 1
	  set_has_buggy_open (strcmp (fs.name (), "SUNWNFS") == 0);
d3015 1
a3015 1
hash_path_name (ino_t hash, const char *name)
@


1.238.2.14
log
@merge from trunk
@
text
@d3014 2
a3015 2
__ino64_t __stdcall
hash_path_name (__ino64_t hash, const char *name)
@


1.238.2.15
log
@merge from trunk
@
text
@d803 2
a804 2
	  set_has_acls (false);		// already implied but...
	  set_has_buggy_open (false);	// ditto
d811 1
a811 1
	  if (!(fs.flags () & FS_PERSISTENT_ACLS) || (!allow_smbntsec && fs.is_remote_drive ()))
d814 1
a814 7
	    {
	      set_has_acls (true);
	      if (allow_ntsec && wincap.has_security ())
		set_exec (0);  /* We really don't know if this is executable or not here
				  but set it to not executable since it will be figured out
				  later by anything which cares about this. */
	    }
a818 6
      if (exec_state () != dont_know_if_executable)
	/* ok */;
      else if (isdir ())
	set_exec (1);
      else if (issymlink () || issocket ())
	set_exec (0);
a1141 35
void
mount_item::fnmunge (char *dst, const char *src)
{
  strcpy (dst, src);
  backslashify (dst, dst, 0);
}

void
mount_item::build_win32 (char *dst, const char *src, unsigned *outflags, unsigned chroot_pathlen)
{
  int n;
  const char *real_native_path;
  int real_posix_pathlen;
  set_flags (outflags, (unsigned) flags);
  if (!cygheap->root.exists () || posix_pathlen != 1 || posix_path[0] != '/')
    {
      n = native_pathlen;
      real_native_path = native_path;
      real_posix_pathlen = chroot_pathlen ?: posix_pathlen;
    }
  else
    {
      n = cygheap->root.native_length ();
      real_native_path = cygheap->root.native_path ();
      real_posix_pathlen = posix_pathlen;
    }
  memcpy (dst, real_native_path, n + 1);
  const char *p = src + real_posix_pathlen;
  if (*p == '/')
    /* nothing */;
  else if ((isdrive (dst) && !dst[2]) || *p)
    dst[n++] = '\\';
  fnmunge (dst + n, p);
}

a1158 1
  bool chroot_ok = !cygheap->root.exists ();
d1167 1
d1275 2
a1276 2
  int chroot_pathlen;
  chroot_pathlen = 0;
d1293 1
a1293 1
	  chroot_pathlen = len = strlen (path);
d1297 1
a1297 1
	  chroot_pathlen = 0;
a1308 1
      chroot_ok = !cygheap->root.exists ();
d1312 27
a1338 2
      mi->build_win32 (dst, pathbuf, flags, chroot_pathlen);
      chroot_ok = true;
d3357 1
a3357 1
    + (nrel * strlen (to_posix ? pc.normalized_path : pc.get_win32 ()))
@


1.238.2.16
log
@merge from trunk
@
text
@d56 1
d211 1
a211 1
  if (isdrive (src))
d516 1
a516 1
	 return.  If a symlink is found, exit the for loop.
a1153 66
char special_chars[] =
    "\001" "\002" "\003" "\004" "\005" "\006" "\007" "\010"
    "\011" "\012" "\013" "\014" "\015" "\016" "\017" "\020"
    "\021" "\022" "\023" "\024" "\025" "\026" "\027" "\030"
    "\031" "\032" "\033" "\034" "\035" "\036" "\037"
    ":"    "\\"   "*"    "?"    "%"
    "A"    "B"    "C"    "D"    "E"    "F"    "G"    "H"
    "I"    "J"    "K"    "L"    "M"    "N"    "O"    "P"
    "Q"    "R"    "S"    "T"    "U"    "V"    "W"    "X"
    "Y"    "Z";

static inline char
special_char (const char *s)
{
  char *p = strechr (special_chars, *s);
  if (*p == '%' && strlen (p) >= 3)
    {
      char hex[] = {s[1], s[2], '\0'};
      unsigned char c = strtoul (hex, &p, 16);
      p = strechr (special_chars, c);
    }
  return *p;
}

bool
fnunmunge (char *dst, const char *src) 
{
  bool converted = false;
  char c;

  while (*src)
    if (*src != '%' || !(c = special_char (src)))
      *dst++ = *src++;
    else
      {
	converted = true;
	*dst++ = c;
	src += 3;
      }

  *dst = *src;
  return converted;
}

/* Determines if name is "special".  Assumes that name is empty or "absolute" */
static int
special_name (const char *s)
{
  if (!*s)
    return false;

  if (strpbrk (++s, special_chars))
    return !strncasematch (s, "%2f", 3);

  if (strcasematch (s, "nul")
      || strcasematch (s, "aux")
      || strcasematch (s, "prn"))
    return -1;
  if (!strncasematch (s, "com", 3)
      && !strncasematch (s, "lpt", 3))
    return false;
  char *p;
  (void) strtol (s, &p, 10);
  return -(*p == '\0');
}

d1157 1
a1157 24
  int name_type;
  if (!(flags & MOUNT_ENC) || !(name_type = special_name (src)))
    strcpy (dst, src);
  else
    {
      char *d = dst;
      *d++ = *src++;
      if (name_type < 0)
	{
	  __small_sprintf (d, "%%%02x", (unsigned char) *src++);
	  d += 3;
	}

      while (*src)
	if (!special_char (src))
	  *d++ = *src++;
	else
	  {
	    __small_sprintf (d, "%%%02x", (unsigned char) *src++);
	    d += 3;
	  }
      *d = *src;
    }

d1184 1
a1184 1
  else if ((!(flags & MOUNT_ENC) && isdrive (dst) && !dst[2]) || *p)
d1237 16
d1352 1
a1352 1
  if (i < nmounts)
d1354 3
a1356 2
      mi->build_win32 (dst, pathbuf, flags, chroot_pathlen);
      chroot_ok = true;
d1360 2
a1361 8
      if (strpbrk (src_path, ":\\") != NULL || slash_unc_prefix_p (src_path))
	rc = normalize_win32_path (src_path, dst);
      else
	{
	  backslashify (pathbuf, dst, 0);	/* just convert */
	  set_flags (flags, PATH_BINARY);
	}
      chroot_ok = !cygheap->root.exists ();
a1524 6
      if (mi.flags & MOUNT_ENC)
	{
	  char tmpbuf[MAX_PATH + 1];
	  if (fnunmunge (tmpbuf, posix_path))
	    strcpy (posix_path, tmpbuf);
	}
d1659 1
a1659 1
mount_info::add_reg_mount (const char *native_path, const char *posix_path, unsigned mountflags)
a1662 6
  if (strchr (posix_path, '\\'))
    {
      set_errno (EINVAL);
      goto err1;
    }

a1712 1
 err1:
a2177 2
  if (flags & MOUNT_ENC)
    strcat (_reent_winsup ()->mnt_opts, ",managed");
d2262 1
a2262 3
  if (strpbrk (posix_path, "\\:"))
    set_errno (EINVAL);
  else if (flags & MOUNT_CYGDRIVE) /* normal mount */
d3165 1
a3165 1
  const char *native_dir = path;
@


1.238.2.17
log
@merge from trunk
@
text
@d895 2
d1153 1
a1153 1
static char special_chars[] =
a1162 2
static char special_introducers[] =
    "anpcl";
d1164 2
a1165 2
static char
special_char (const char *s, const char *valid_chars = special_chars)
d1167 9
a1175 2
  if (*s != '%' || strlen (s) < 3)
    return 0;
d1177 18
a1194 5
  char *p;
  char hex[] = {s[1], s[2], '\0'};
  unsigned char c = strtoul (hex, &p, 16);
  p = strechr (valid_chars, c);
  return *p;
d1199 1
a1199 1
special_name (const char *s, int inc = 1)
d1204 1
a1204 2
  s += inc;
  if (strpbrk (s, special_chars))
d1209 1
a1209 4
      || strcasematch (s, "prn")
      || strcasematch (s, "con")
      || strcasematch (s, "conin$")
      || strcasematch (s, "conout$"))
d1215 1
a1215 1
  (void) strtoul (s + 3, &p, 10);
a1218 30
bool
fnunmunge (char *dst, const char *src)
{
  bool converted = false;
  char c;

  if ((c = special_char (src, special_introducers)))
    {
      __small_sprintf (dst, "%c%s", c, src + 3);
      if (special_name (dst, 0))
	{
	  *dst++ = c;
	  src += 3;
	}
    }

  while (*src)
    if (!(c = special_char (src)))
      *dst++ = *src++;
    else
      {
	converted = true;
	*dst++ = c;
	src += 3;
      }

  *dst = *src;
  return converted;
}

d1230 4
a1233 1
	d += __small_sprintf (d, "%%%02x", (unsigned char) *src++);
d1236 1
a1236 1
	if (!strchr (special_chars, *src) || (*src == '%' && !special_char (src)))
d1239 4
a1242 1
	  d += __small_sprintf (d, "%%%02x", (unsigned char) *src++);
d2302 2
a2303 1
      if (GetFileAttributes (native_path) == INVALID_FILE_ATTRIBUTES)
@


1.238.2.18
log
@merge from trunk
@
text
@d1188 6
a1193 2
  const char *p;
  if (strcasematch (s, "conin$") || strcasematch (s, "conout$"))
d1195 2
a1196 9

  if (strncasematch (s, "nul", 3)
      || strncasematch (s, "aux", 3)
      || strncasematch (s, "prn", 3)
      || strncasematch (s, "con", 3))
    p = s + 3;
  else if (strncasematch (s, "com", 3) || strncasematch (s, "lpt", 3))
    (void) strtoul (s + 3, (char **) &p, 10);
  else
d1198 3
a1200 2

  return (*p == '\0' || *p == '.') ? -1 : false;
d2361 1
a2361 4
  if (check_null_empty_str_errno (win32_path)
      || check_null_empty_str_errno (posix_path))
    /* errno set */;
  else if (strpbrk (posix_path, "\\:"))
a2385 2
  if (check_null_empty_str_errno (path))
    return -1;
@


1.238.2.19
log
@merge from trunk
@
text
@d2363 2
a2364 1
  if (check_null_empty_str_errno (posix_path))
d2376 1
a2376 1
  else if (!check_null_empty_str_errno (win32_path))
@


1.238.2.20
log
@merge from trunk
@
text
@a3488 4

  cfree (pc.normalized_path);		// FIXME - probably should be in a destructor but
  					// it's hard to justify a destructor for the few
   					// places where this is needed
@


1.238.2.21
log
@merge from trunk
@
text
@d210 1
a210 1
  if (isdrive (src) || slash_unc_prefix_p (src))
d213 1
a213 1
      if (!err)
d1085 3
a1087 1
	     && isalnum (path[2])
d3490 1
a3490 2
  if (!pc.normalized_path_size && pc.normalized_path)
    cfree (pc.normalized_path);		// FIXME - probably should be in a destructor but
@


1.237
log
@	* path.cc: Revert patch from 2003-01-09 to normalize a windows path
	rather than converting to posix.
@
text
@d208 1
a208 4
    {
      cygwin_conv_to_full_posix_path (src, dst);
      return 0;
    }
@


1.236
log
@	Split ChangeLog, create ChangeLog-2002.
	Fix copyright dates.
@
text
@d208 4
a211 1
    return normalize_win32_path (src, dst);
d1710 1
a1710 1
      else if (*p == '/')
d1761 1
a1761 2
      strcpy (posix_path, src_path);
      // slashify (src_path, posix_path, trailing_slash_p);
@


1.235
log
@Use isdirsep rather than SLASH_P throughout.
* path.cc (iscygdrive): Disallow /cygdrive\x.
(normalize_posix_path): "Normalize" a windows path, if detected, rather than
converting to posix.
* fhandler_serial.cc (fhandler_serial::tcsetattr): Add support and capability
checking for B230400 bitrate.
(fhandler_serial::tcgetattr): Add support for B230400 bitrate.
* include/sys/termios.h: Add B230400 definition for Posix support of 230.4Kbps.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.234
log
@Remove \n from calls to strace class printfs throughout.
@
text
@d135 1
a135 1
   (isdirsep (path[mount_table->cygdrive_len + 1]) || \
d162 1
a162 1
  if (len1 > 0 && SLASH_P (path1[len1 - 1]))
d166 1
a166 1
    return SLASH_P (path2[0]) && !SLASH_P (path2[1]);
d171 1
a171 1
  return SLASH_P (path2[len1]) || path2[len1] == 0 || path1[len1 - 1] == ':';
d206 1
d208 2
a209 4
    {
      cygwin_conv_to_full_posix_path (src, dst);
      return 0;
    }
d1192 1
a1192 1
      if (SLASH_P (src[0]) && SLASH_P (src[1]))
d1195 2
a1196 2
      else if (src[0] == '.' && SLASH_P (src[1])
	       && (src == src_start || SLASH_P (src[-1])))
d1203 1
a1203 1
	       && (SLASH_P (src[2]) || src[2] == 0))
d1212 1
a1212 1
	  if (SLASH_P (*src))
d1291 1
a1291 1
  while (len > 1 && SLASH_P (dst[--len]))
d1601 1
a1601 1
  if (!src[2] || (SLASH_P (src[2]) && !src[3]))
d1607 1
a1607 1
      if (SLASH_P (src[2]))
d1659 1
a1659 1
      trailing_slash_p = SLASH_P (*lastchar) && lastchar[-1] != ':';
d1707 1
a1707 1
      else if (isdirsep (*p))
d1758 2
a1759 1
      slashify (src_path, posix_path, trailing_slash_p);
d3576 1
a3576 1
      if (SLASH_P (*path))
d3585 1
a3585 1
  while (end > path + 1 && SLASH_P (end[-1]))
d3594 1
a3594 1
    if (SLASH_P (*last_slash))
@


1.234.16.1
log
@Introduce device class to cygwin throughout.  Rename FH_DISK to FH_FS
throughout.
* dcrt0.cc (dll_crt0_1): Initialize device globals via device::init.
* dtable.cc (dtable::init_std_file_from_handle): Use device numbers rather than
names when they are known.  Should speed up process startup slightly.
(dtable::build_fhandler_from_name): Pass path_conv device to build_fhandler.
(dtable::build_fhandler): Accept device argument rather than separate
device/unit arguments.
(dtable::build_fhandler): Ditto.  Separate switch statement by devices which
take units and those which don't.  Build unix/win32 names from device if
required.
(dtable::dup_worker): Reflect changes to build_fhandler arguments.
* dtable.h (dtable::build_fhandler): Ditto.
* fhandler.cc (fhandler_base::set_name): Eliminate unit argument.  Use get_unit
to derive unit.
* fhandler.h: Separate FH device defines into devices.h include.  Define
is_slow as appropriate for each fhandler_class.
(fhandler_base::dev): New element.
(fhandler_base::fhandler_base): Eliminate unit argument.
(fhandler_base::get_device): Return device number.
(fhandler_base::get_major): Return device major number.
(fhandler_base::get_minor): Return device minor number.
(fhandler_base::get_unit): Ditto.
(fhandler_base::get_native_name): Return device format field.
(fhandler_fifo): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_cygdrive::fhandler_cygdrive): Remove unit
initialization.
* fhandler_tty.cc (fhandler_tty_master::init_console): Use "console_dev" global
to initialize captive console used by tty master.
* mmap.cc (mmap_record::devtype_): Remove.
(mmap_record::dev): New.
(mmap_record::mmap_record): Use dev.
(mmap_record::get_device): Implement via dev.
* net.cc (fdsock): Use socket_dev global to initialize socket fhandler.
* path.cc (path_conv::check): Accommodate new path_conv::dev element.
(get_devn): Eliminate.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Accept dev argument.  Use it.  Use device::parse to derive
potential device name.
(mount_info::conv_to_win32_path): Accept dev argument.  Use it.
* path.h (path_conv::devn): Eliminate.
(path_conv::unit): Ditto.
(path_conv::dev): Declare.
(path_conv::path_conv): Don't initialize deleted members.
(path_conv::is_device): Implement via dev element.
(path_conv::get_devn): Ditto.
(path_conv::get_unitn): Ditto.
* pipe.cc (make_pipe): Use pipe[rw]_dev in fhandler construction.
* select.cc: Use new device_specific_* select class elements
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(mount_info::conv_to_win32_path): Reflect new arguments.
* syscalls.cc (fstat64): Just use get_device() without interpretation for
st_dev element.
(stat_worker): Ditto.
* tty.cc (create_tty_master): Use ttym_dev in fhandler constructor.
(tty::common_init): Check for tty major device number rather than FH_TTYM.
@
text
@d456 1
a456 1
  memset (&dev, 0, sizeof (dev));
d527 2
a528 2
	  error = mount_table->conv_to_win32_path (path_copy, full_path, dev,
						   &sym.pflags, 1);
d533 1
a533 1
	  if (dev.devn >= FH_CYGDRIVE && dev.devn <= FH_CYGDRIVE_Z)
d539 1
a539 1
		  dev.devn = FH_BAD;
d544 1
a544 1
	  else if (isvirtual_dev (dev.devn))
d548 1
a548 1
		(fhandler_virtual *) cygheap->fdtab.build_fhandler (-1, dev, (const char *) path_copy, NULL);
d567 1
a567 1
	  else if (dev.devn != FH_BAD)
d775 1
a775 1
  if (dev.devn == FH_BAD)
d887 211
d1102 2
a1103 1
win32_device_name (const char *src_path, char *win32_path, device& dev)
d1105 3
a1107 1
  dev.parse (src_path);
d1109 1
a1109 1
  if (dev.devn == FH_BAD)
d1112 3
a1114 1
  switch (dev.devn)
d1116 3
d1120 1
a1120 1
	__small_sprintf (win32_path, dev.fmt, dev.minor % 128);
d1122 10
a1131 2
      case FH_RAWDRIVE:
	  __small_sprintf (win32_path, dev.fmt, dev.minor - 224 + 'A');
a1132 10
      case FH_TTY:
	{
	  if (!real_tty_attached (myself))
	    dev = *console_dev;
	  else
	    {
	      dev = *ttys_dev;
	      dev.setunit (myself->ctty);
	    }
	}
d1134 1
a1134 1
	__small_sprintf (win32_path, dev.fmt, dev.minor);
d1137 1
a1137 1
  return true;
a1369 10
/* CGF FIXME device */
static const device dev_proc =
{"/proc", FH_PROC, "/proc", 0, 0, 0, 0};

static const device dev_cygdrive =
{"/cygdrive", FH_CYGDRIVE, "/cygdrive", 0, 0, 0, 0};

static const device dev_fs =
{"", FH_FS, "", 0, 0, 0, 0};

d1384 3
a1386 2
mount_info::conv_to_win32_path (const char *src_path, char *dst, device& dev,
				unsigned *flags, bool no_normalize)
d1398 2
a1399 1
  dev.devn = FH_BAD;
d1466 1
a1466 1
  if (win32_device_name (pathbuf, dst, dev))
d1478 2
a1479 3
      dev = dev_proc;
      dev.devn = fhandler_proc::get_proc_fhandler (pathbuf);
      if (dev.devn == FH_BAD)
a1484 2
      int unit;

d1491 1
a1491 1
	    dev = dev_cygdrive;
d1568 2
a1569 2
  if (!isvirtual_dev (dev.devn))
    win32_device_name (src_path, dst, dev);
d1624 1
a1624 1
      unit = -1; /* FIXME: should be zero, maybe? */
@


1.234.16.2
log
@Eliminate unit argument and special unit fields from fhandler classes and
constructors throughout.
* fhandler_mem.cc (fhandler_dev_mem::fhandler_dev_mem): Make decisions based on
specific device type rather than unit number.
* fhandler_random.cc (fhandler_dev_random::write): Ditto.
(fhandler_dev_random::read): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Set device type to
"urandom" after construction of entropy_source.
* path.cc (windows_devices_names): Remove.
@
text
@d851 29
@


1.234.16.3
log
@* cygwin-gperf: New file.
* Makefile.in: Use cygwin-gperf script to build devices.cc.
* configure.in: Remove some comments.
* configure: Regenerate.
* devices.gperf: Remove max unit determination from FH_TTY.  Add /dev/kmem.
Add /dev/fifo.  Add /dev/rawdrive.  Remove specific "const device *"
declarations since they are now autogenerated.
(device::parse): Treat FH_TTY specially.  Move logic for determining real tty
device to separate function.
(device::init): Reduce to nothing.
(device::parse): New function taking different arguments.
(device::parse): Ditto.
(device::tty_to_real_device): New function.
* devices.h (struct device): Define above new functions.
(device::dev_on_fs): New element.
(device::setfs): New function.
(device::isfs): Ditto.
* dtable.cc (dtable::build_fhandler): Treat FH_TTY specially.
* fhandler.cc (fhandler_base::set_name): Make special determination for
non-disk-resident devices.
* fhandler.h (fhandler_base::isdevice): Renamed from 'is_device'.
(fhandler_disk_file::isdevice): Ditto.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_device): New function.
(fhandler_tty_slave::get_unit): Declare.
(fhandler_disk_file::readdir): Take special .lnk consideration for devices as
well as symlinks.
* fhandler_tty.cc: Use get_unit () rather than dev.minor throughout.
(fhandler_tty_slave::get_unit): Define new function.
* path.cc (symlink_info::major): New element.
(symlink_info::major): Ditto.
(symlink_info::devtype): Ditto.
(path_conv::check): Handle devices detected by symlink_info::check.
(win32_device_name): Eliminate special FH_TTY handling.
(symlink): Move bulk of procesing to symlink_worker.
(symlink_worker): New function.  Handles devices.
(symlink_info::parse_device): Parse info from potential device file into
symlink_info elements.
(symlink_info::check): If contents of .lnk file begin with a ':' then treat the
file as a device file.
* path.h (isdevice): Renamed from is_device.
(is_auto_device): New function.
(is_fs_device): Ditto.
* syscalls.cc (chown_worker): Allow setting of ownership for on-disk devices.
(chmod): Ditto.
(mknod): Implement.
* winsup.h (symlink_worker): Declare.
@
text
@a100 3
  _major_t major;
  _minor_t minor;
  _devtype_t devtype;
a101 1
  bool parse_device (const char *);
d533 1
a533 1
	  if (dev.major == DEV_CYGDRIVE_MAJOR)
a605 13
	  if (sym.minor || sym.major)
	    {
	      dev.parse (sym.major, sym.minor);
	      if (!dev)
		error = ENODEV;
	      else
		{
		  dev.setfs (1);
		  fileattr = sym.fileattr;
		}
	      goto out;
	    }

d851 6
a856 1

d877 10
a2334 7
  return symlink_worker (topath, frompath, allow_winsymlinks, false);
}

int
symlink_worker (const char *topath, const char *frompath, bool use_winsym,
		bool isdevice)
{
d2358 1
a2358 1
  if (use_winsym && !win32_path.exists ())
d2373 1
a2373 1
  if (win32_path.isdevice () || win32_path.exists ())
d2379 25
a2403 28
  if (use_winsym)
    if (isdevice)
      strcpy (w32topath, topath);
    else
      {
	if (!isabspath (topath))
	  {
	    getcwd (cwd, MAX_PATH + 1);
	    if ((cp = strrchr (from, '/')) || (cp = strrchr (from, '\\')))
	      {
		c = *cp;
		*cp = '\0';
		chdir (from);
	      }
	    backslashify (topath, w32topath, 0);
	  }
	if (!cp || GetFileAttributes (w32topath) == INVALID_FILE_ATTRIBUTES)
	  {
	    win32_topath.check (topath, PC_SYM_NOFOLLOW);
	    if (!cp || win32_topath.error != ENOENT)
	      strcpy (w32topath, win32_topath);
	  }
	if (cp)
	  {
	    *cp = c;
	    chdir (cwd);
	  }
      }
d2417 1
a2417 1
      if (use_winsym)
d2457 2
a2458 2
	  DWORD attr = use_winsym ? FILE_ATTRIBUTE_READONLY
	    			  : FILE_ATTRIBUTE_SYSTEM;
d2466 1
a2466 1
	  if (!isdevice && win32_path.fs_fast_ea ())
d2479 1
a2479 2
  syscall_printf ("%d = symlink_worker (%s, %s, %d, %d)", res, topath,
		  frompath, use_winsym, isdevice);
a2720 32
bool
symlink_info::parse_device (const char *contents)
{
  char *endptr;
  int mymajor, myminor;

  mymajor = strtol (++contents, &endptr, 16);
  if (endptr == contents)
    return false;

  contents = endptr;
  myminor = strtol (++endptr, &endptr, 16);
  if (endptr == contents)
    return false;

  switch (*++endptr)
    {
    case 'b':
    case 'c':
    case 's':
      if (mymajor || myminor)
	break;
    default:
      return false;
    }

  major = mymajor;
  minor = myminor;
  devtype = *endptr;
  return true;
}

a2748 2
  major = 0;
  minor = 0;
d2812 2
a2813 1
         should we write it there?  */
d2818 1
a2818 5
	  if (!res)
	    /* check more below */;
	  else if (*contents == ':' && parse_device (contents))
	    goto file_not_symlink;
	  else
d2837 1
a2837 1
      syscall_printf ("%s", (major || minor) ? "is a device" : "not a symlink");
@


1.234.16.4
log
@* devices.h (_devtype_t): Eliminate.
(_mode_t): New typedef.
(device::mode): Replace type.
* fhandler.h (fhandler_base::device_access_denied): Declare new function.
* fhandler.cc (fhandler_base::device_access_denied): Define new function.
* fhandler_disk_file.cc (fhandler_base::fstat_helper): Just copy mode directly
from dev.mode to st_mode if it is a disk device.
* path.cc (path_conv::check): Set device mode from sym mode.
(symlink_worker): Let "exists" check happen when file is attempted to be
opened, or not, in the case of creating a device.
(symlink_info::parse_device): Change device type argument to device mode
argument.
(mknod_worker): New function.
(chmod_device): Ditto.
(chmod): Use chmod_device to set protection if it is an fs device.
(mknod): Use mknod_worker to actually create the device.  Don't take any
special action with the protection since it is now implicit.
@
text
@d103 1
a103 1
  _mode_t mode;
a617 1
		  dev.mode = sym.mode;
d2382 1
a2382 1
  if (win32_path.is_auto_device ())
d2388 2
a2389 5
  DWORD create_how;
  if (!use_winsym)
    create_how = CREATE_NEW;
  else if (isdevice)
    {
d2391 25
a2415 29
      create_how = CREATE_ALWAYS;
      (void) SetFileAttributes (win32_path, FILE_ATTRIBUTE_NORMAL);
    }
  else
    {
      if (!isabspath (topath))
	{
	  getcwd (cwd, MAX_PATH + 1);
	  if ((cp = strrchr (from, '/')) || (cp = strrchr (from, '\\')))
	    {
	      c = *cp;
	      *cp = '\0';
	      chdir (from);
	    }
	  backslashify (topath, w32topath, 0);
	}
      if (!cp || GetFileAttributes (w32topath) == INVALID_FILE_ATTRIBUTES)
	{
	  win32_topath.check (topath, PC_SYM_NOFOLLOW);
	  if (!cp || win32_topath.error != ENOENT)
	    strcpy (w32topath, win32_topath);
	}
      if (cp)
	{
	  *cp = c;
	  chdir (cwd);
	}
      create_how = CREATE_NEW;
    }
d2421 2
a2422 2
  h = CreateFile (win32_path, GENERIC_WRITE, 0, &sa, create_how,
		  FILE_ATTRIBUTE_NORMAL, 0);
d2476 1
a2476 1
	  SetFileAttributes (win32_path, attr);
d2738 1
a2738 3
  _major_t mymajor;
  _major_t myminor;
  _mode_t mymode;
d2745 1
a2745 6
  myminor = strtol (++contents, &endptr, 16);
  if (endptr == contents)
    return false;

  contents = endptr;
  mymode = strtol (++contents, &endptr, 16);
d2749 1
a2749 1
  switch (mymode & S_IFMT)
d2751 3
a2753 3
    case S_IFBLK:
    case S_IFCHR:
    case S_IFIFO:
d2762 1
a2762 1
  mode = mymode;
@


1.234.16.5
log
@Replace is_fs_device with is_fs_special throughout.
* Makefile.in (DLL_OFILES): Add fhandler_fifo.o.
* devices.h (fh_devices): Renumber some minor numbers to fit in 8 bits.
* dtable.cc (dtable::build_fhandler): Handle FH_FIFO.  Set errno to ENODEV if
device not found.
* dtable::find_fifo: Define new function.
* dtable.h (dtable::find_fifo): Declare new function.
* fhandler.cc (fhandler_base::device_access_denied): Fix O_RDONLY test.
(fhandler_base::write): Use output file handle for writing.
(fhandler_base::fstat): Use is_fs_special rather than is_fs_device.
* fhandler.h (fhandler_base::is_fs_special): Rename from is_fs_device.
(fhandler_pipe): Make private elements protected so that fhandler_fifo can use
them too.
(fhandler_pipe::create): New function derived from make_pipe.
(fhandler_fifo): Add more needed elements.
(fhandler_pty_master::slave): Add to track slave device.
(fhandler_pty_master::get_unit): Define.
* fhandler_tty.cc (fhandler_tty_master::init): Register slave device.
(fhandler_pty_master::open): Ditto.
(symlink_info::parse_device): Handle fifo specially.
* pinfo.cc (_pinfo::commune_recv): Initial fifo implementation.
(_pinfo::commune_send): Ditto.
* pinfo.h (picom): Add PICOM_FIFO.
* pipe.cc (fhandler_pipe::close): Close input handle here specifically.
(fhandler_pipe::create): Rename from make_pipe.  Create fhandlers rather than
fds.
(pipe): Use fhandler_pipe::create to create pipe.
(_pipe): Ditto.
* syscalls.cc (mknod): Accommodate fifos.
@
text
@a2765 4
    case S_IFIFO:
      mymajor = _major (FH_FIFO);
      myminor = _minor (FH_FIFO);
      break;
d2768 1
@


1.234.16.6
log
@.
@
text
@d139 1
a139 1
   (path[mount_table->cygdrive_len + 1] == '/' || \
d166 1
a166 1
  if (len1 > 0 && isdirsep (path1[len1 - 1]))
d170 1
a170 1
    return isdirsep (path2[0]) && !isdirsep (path2[1]);
d175 1
a175 1
  return isdirsep (path2[len1]) || path2[len1] == 0 || path1[len1 - 1] == ':';
a209 1

d211 4
a214 2
    return normalize_win32_path (src, dst);

d950 1
a950 1
      if (isdirsep (src[0]) && isdirsep (src[1]))
d953 2
a954 2
      else if (src[0] == '.' && isdirsep (src[1])
	       && (src == src_start || isdirsep (src[-1])))
d961 1
a961 1
	       && (isdirsep (src[2]) || src[2] == 0))
d970 1
a970 1
	  if (isdirsep (*src))
d1049 1
a1049 1
  while (len > 1 && isdirsep (dst[--len]))
d1370 1
a1370 1
  if (!src[2] || (isdirsep (src[2]) && !src[3]))
d1376 1
a1376 1
      if (isdirsep (src[2]))
d1428 1
a1428 1
      trailing_slash_p = isdirsep (*lastchar) && lastchar[-1] != ':';
d1476 1
a1476 1
      else if (*p == '/')
d3409 1
a3409 1
      if (isdirsep (*path))
d3418 1
a3418 1
  while (end > path + 1 && isdirsep (end[-1]))
d3427 1
a3427 1
    if (isdirsep (*last_slash))
@


1.233
log
@* environ.cc (environ_init): Avoid a compiler warning.
* path.cc (path_conv::check): Ditto.
* path.h (path_conv::operator int): Ditto.
* regex/engine.c: Ditto throughout.
* regex/regcomp.c: Ditto throughout.
* regex/regexec.c: Ditto throughout.
@
text
@d1813 1
a1813 1
	  debug_printf ("RegEnumKeyEx failed, error %d!\n", res);
@


1.232
log
@More GNUify non-GNU formatted functions calls throughout.
@
text
@d808 1
a808 1
	  char n = strlen (this->path);
@


1.231
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@d1307 1
a1307 1
	     && ((p = strpbrk(path + 3, "\\/")) != NULL));
@


1.230
log
@whitespace
@
text
@d134 2
a135 2
  (isalpha(path[mount_table->cygdrive_len]) && \
   (isdirsep(path[mount_table->cygdrive_len + 1]) || \
d846 1
a846 1
  int n = strtol(name, &p, 10);
d1988 1
a1988 1
      cygdrive_len = strlen(cygdrive);
d2046 1
a2046 1
      mount_table->cygdrive_len = strlen(mount_table->cygdrive);
d2337 1
a2337 1
  struct mntent &ret=_reent_winsup()->mntbuf;
d3223 1
a3223 1
      int ch = cyg_tolower(*name);
d3314 1
a3314 1
  int devn = path.get_devn();
d3728 1
a3728 1
  debug_printf("posix %s", posix);
@


1.229
log
@	* Makefile.in (DLL_OFILES): Drop shortcut.o.
	* path.cc: Move all shortcut functions from shortcut.c to here.
	(check_shortcut): Implement without using COM interface.
	* path.h: Move definition of SHORTCUT_HDR_SIZE to here.
	* shortcut.c: Remove.
	* shortcut.h: Ditto.
@
text
@d409 1
a409 1
} 
d2644 1
a2644 1
  h = CreateFileA(win32_path, GENERIC_WRITE, 0, &sa,
d3040 2
a3041 2
      h = CreateFileA (suffix.path, GENERIC_READ, FILE_SHARE_READ, &sec_none_nih, OPEN_EXISTING,
		       FILE_ATTRIBUTE_NORMAL, 0);
@


1.228
log
@* path.cc (path_conv::check): Always set fileattr when component == 0.
(readlink): Use path_conv method rather than field.
* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Ditto, throughout.
* path.h (path_conv): Make fileattr private.
* exceptions.cc (try_to_debug): Default to idle priority when looping.
@
text
@a76 1
#include "shortcut.h"
d107 20
d2717 62
@


1.227
log
@* ntdll.h (_SYSTEM_PROCESSOR_TIMES): Force eight byte alignment.
(_SYSTEM_TIME_OF_DAY_INFORMATION): Ditto.
@
text
@a449 1

d605 4
a608 1
		path_flags = sym.pflags;
d617 1
a617 4
		    {
		      fileattr = sym.fileattr;
		      add_ext_from_sym (sym);
		    }
a634 1
		      fileattr = sym.fileattr;
d3073 1
a3073 1
      if (pathbuf.fileattr != INVALID_FILE_ATTRIBUTES)
@


1.226
log
@* dtable.cc (cygwin_attach_handle_to_fd): Default to implicit bin mode if none
specified.
* fhandler.cc (fhandler_base::init): Make bin argument a guarantee rather than
a suggestion.
* path.cc (path_conv::check): Load flag returned from cygwin_conv_to_win32_path
into path_flags.
@
text
@d2825 1
a2825 1
  if (suffixes)
d2827 35
a2873 33
    }

  switch (nextstate)
    {
    case SCAN_BEG:
      suffixes = suffixes_start;
      if (!suffixes)
	nextstate = SCAN_LNK;
      else
	{
	  if (!*suffixes->name)
	    suffixes++;
	  nextstate = SCAN_EXTRALNK;
	}
      return 1;
    case SCAN_HASLNK:
      nextstate = SCAN_EXTRALNK;	/* Skip SCAN_BEG */
      return 1;
    case SCAN_LNK:
    case SCAN_EXTRALNK:
      strcpy (eopath, ".lnk");
      nextstate = SCAN_DONE;
      return 1;
    case SCAN_JUSTCHECK:
      nextstate = SCAN_APPENDLNK;
      return 1;
    case SCAN_APPENDLNK:
      strcat (eopath, ".lnk");
      nextstate = SCAN_DONE;
      return 1;
    default:
      *eopath = '\0';
      return 0;
@


1.226.2.1
log
@* path.cc (suffix_scan::has): Reorganize to eliminate double scanning for for
.exe (in the typical case).
* fhandler_socket.cc (fhandler_socket::set_sun_path): Don't free memory here.
Allow NULL parameter.
* fhandler_socket.cc (fhandler_socket::dup): Add missing copy operation on
sun_path.
@
text
@d2825 1
a2825 1
  for (;;)
a2826 35
      if (!suffixes)
	switch (nextstate)
	  {
	  case SCAN_BEG:
	    suffixes = suffixes_start;
	    if (!suffixes)
	      {
		nextstate = SCAN_LNK;
		return 1;
	      }
	    if (!*suffixes->name)
	      suffixes++;
	    nextstate = SCAN_EXTRALNK;
	    /* fall through to suffix checking below */
	    break;
	  case SCAN_HASLNK:
	    nextstate = SCAN_EXTRALNK;	/* Skip SCAN_BEG */
	    return 1;
	  case SCAN_LNK:
	  case SCAN_EXTRALNK:
	    strcpy (eopath, ".lnk");
	    nextstate = SCAN_DONE;
	    return 1;
	  case SCAN_JUSTCHECK:
	    nextstate = SCAN_APPENDLNK;
	    return 1;
	  case SCAN_APPENDLNK:
	    strcat (eopath, ".lnk");
	    nextstate = SCAN_DONE;
	    return 1;
	  default:
	    *eopath = '\0';
	    return 0;
	  }

d2839 33
@


1.225
log
@* fhandler_clipboard.c (fhandler_dev_clipboard::open): Force text mode.
* fhandler_console.cc (fhandler_console::open): *Really* force binary mode
rather than make it optional.
* fhandler_proc.cc (fhandler_proc::open): Ditto.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (set_flags): Add more debugging.
@
text
@d552 1
@


1.224
log
@* path.cc (chdir): Minor cleanup.
@
text
@d1341 9
a1349 1
    *flags = PATH_TEXT;
@


1.223
log
@fix comment
@
text
@d3243 1
a3243 1
  /* If res < 0, we didn't change to a new directory.
d3253 1
a3253 1
  if (res == -1)
@


1.222
log
@* path.cc: Change MOUNT_AUTO to MOUNT_CYGDRIVE throughout.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
@
text
@d1295 1
a1295 8
/* conv_path_list: Convert a list of path names to/from Win32/POSIX.

   SRC is not a const char * because we temporarily modify it to ease
   the implementation.

   I believe Win32 always has '.' in $PATH.   POSIX obviously doesn't.
   We certainly don't want to handle that here, but it is something for
   the caller to think about.  */
@


1.221
log
@* external.cc (cygwin_internal): Make v1 mount table access invalid.
* path.cc (mount_info::init): Remove had_to_create_mount_areas initialization.
(mount_info::from_registry): Remove v1 table import.
(mount_info::read_v1_mounts): Eliminate.
(mount_info::import_v1_mounts): Ditto.
* shared_info.h (mount_info): Ditto for both of above.
* sys/mount.h (MOUNT_DEVFS): New enum.
(MOUNT_PROC): Ditto.
@
text
@d1959 1
a1959 1
      cygdrive_flags = r2.get_int (CYGWIN_INFO_CYGDRIVE_FLAGS, MOUNT_AUTO);
d1965 1
a1965 1
      /* Fetch user cygdrive_flags from registry; returns MOUNT_AUTO on
d1967 1
a1967 1
      cygdrive_flags = r.get_int (CYGWIN_INFO_CYGDRIVE_FLAGS, MOUNT_AUTO);
d2074 1
a2074 1
      int flags = r.get_int (CYGWIN_INFO_CYGDRIVE_FLAGS, MOUNT_AUTO);
d2088 1
a2088 1
      int flags = r2.get_int (CYGWIN_INFO_CYGDRIVE_FLAGS, MOUNT_AUTO);
d2364 1
a2364 1
  if ((flags & MOUNT_AUTO))		/* cygdrive */
d2447 1
a2447 1
  if (flags & MOUNT_AUTO) /* normal mount */
d2449 1
a2449 1
      /* When flags include MOUNT_AUTO, take this to mean that
d2482 1
a2482 1
  if (flags & MOUNT_AUTO)
d2484 1
a2484 1
      /* When flags include MOUNT_AUTO, take this to mean that we actually want
@


1.220
log
@* cygwin.din: Eliminate some newlib wrappers.
* path.cc (get_devn): Only consider first 99 potential com devices.
(get_device_number): Ditto.
* times.cc (_times): Eliminate.
(_times): Renamed from times().
@
text
@a1336 1
  had_to_create_mount_areas = 0;
a1836 5

  /* If we had to create both user and system mount areas, import
     old mounts. */
  if (had_to_create_mount_areas == 2)
    import_v1_mounts ();
a2309 75
}

/* read_v1_mounts: Given a reg_key to an old mount table registry area,
   read in the mounts.  The "which" arg contains zero if we're reading
   the user area and MOUNT_SYSTEM if we're reading the system area.
   This way we can store the mounts read in the appropriate place when
   they are written back to the new registry layout. */

void
mount_info::read_v1_mounts (reg_key r, unsigned which)
{
  unsigned mountflags = 0;

  /* MAX_MOUNTS was 30 when we stopped using the v1 layout */
  for (int i = 0; i < 30; i++)
    {
      char key_name[10];
      char win32path[MAX_PATH];
      char unixpath[MAX_PATH];

      __small_sprintf (key_name, "%02x", i);

      reg_key k (r.get_key (), KEY_ALL_ACCESS, key_name, NULL);

      /* The registry names are historical but useful so are left alone.  */
      k.get_string ("native", win32path, sizeof (win32path), "");
      k.get_string ("unix", unixpath, sizeof (unixpath), "");

      /* Does this entry contain something?  */
      if (*win32path != 0)
	{
	  mountflags = 0;

	  if (k.get_int ("fbinary", 0))
	    mountflags |= MOUNT_BINARY;

	  /* Or in zero or MOUNT_SYSTEM depending on which table
	     we're reading. */
	  mountflags |= which;

	  int res = mount_table->add_item (win32path, unixpath, mountflags, TRUE);
	  if (res && get_errno () == EMFILE)
	    break; /* The number of entries exceeds MAX_MOUNTS */
	}
    }
}

/* import_v1_mounts: If v1 mounts are present, load them and write
   the new entries to the new registry area. */

void
mount_info::import_v1_mounts ()
{
  reg_key r (HKEY_CURRENT_USER, KEY_ALL_ACCESS,
	     "SOFTWARE",
	     "Cygnus Solutions",
	     "CYGWIN.DLL setup",
	     "b15.0",
	     "mounts",
	     NULL);

  nmounts = 0;

  /* First read mounts from user's table. */
  read_v1_mounts (r, 0);

  /* Then read mounts from system-wide mount table. */
  reg_key r1 (HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS,
	      "SOFTWARE",
	      "Cygnus Solutions",
	      "CYGWIN.DLL setup",
	      "b15.0",
	      "mounts",
	      NULL);
  read_v1_mounts (r1, MOUNT_SYSTEM);
@


1.219
log
@* dtable.cc (handle_to_fn): Attempt to handle "raw" accesses to remote shares.
* path.cc (mount_info::conv_to_win32_path): Set flags to binary when mount
entry is not found.
(mount_info::set_flags_from_win32_path): Ditto.
@
text
@d919 1
a919 1
  else if (deveqn ("com", 3) && (unit = digits (name + 3)) >= 0)
d1073 1
a1073 1
	 && (unit = digits (unix_path + 3)) >= 0)
@


1.218
log
@Remove fcntl.h includes throughout.
* fhandler.h: Move fcntl.h include here.
(fhandler_base::set_flags): Accept supplied_bin argument.  Make non-inlined.
* dtable.cc (dtable::init_std_file_from_handle): Just use binmode from pc.
(reset_to_open_binmode): Use set_flags.
* cygwin.din (open): Avoid newlib wrapper.
(read): Ditto.
(unlink): Ditto.
(write): Ditto.
* fhandler.cc (fhandler_base::set_flags): Accept supplied_bin argument.  Make
binmode decisions here.
(fhandler_base::open): Avoid using pc if it is NULL.  Eliminate binmode logic.
Just call set_flags with binmode argument.
(fhandler_base::init): Call set_flags with binmode argument.
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::init): Force binary on open.
* fhandler_disk_file.cc (fhandler_disk_file::open): Don't set binmode here.
Let it happen in base class.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Force binmode open.  Set return
value appropriately if unable to open.
* fhandler_proc.cc (fhandler_proc::open): Make sure flags are set before
open_status.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Force O_BINARY by default.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (path_conv::check): Avoid checking for extension when error or
directory.
(set_flags): Set PATH_TEXT explicitly, when appropriate.
(mount_info::conv_to_win32_path): Use set_flags() to set path flags.
* path.h (PATH_TEXT): New enum.
(path_conv::binmode): Return appropriate constant based on binmode.
* pipe.cc (make_pipe): Set binmode to O_TEXT xor O_BINARY.
* syscalls.cc (setmode_helper): Make debugging message a little clearer.
(setmode): Set binmode via set_flags.
@
text
@d1515 4
a1518 1
    backslashify (pathbuf, dst, 0);	/* just convert */
d1761 1
a1761 1
  return 0;
@


1.217
log
@* fhandler.cc (fhandler_base::open): Don't set binmode if already set.  Don't
check for file.  Files should already be set.  Report on binary mode for
debugging.
(fhandler_base::fhandler_base): Don't set default binmode here.  That's for
later.
* fhandler_console.cc (fhandler_console::output_tcsetattr): Don't set binmode,
ever, for console.
* fhandler_disk_file.cc (fhandler_disk_file::open): Always set the binary mode
to the value derived from mount table.
* path.cc (mount_info::conv_to_win32_path): Default to binmode if path does not
translate into anything in the mount table.
@
text
@a54 1
#include <fcntl.h>
d805 1
a805 1
  if (!error && !(path_flags & PATH_ALL_EXEC))
d1344 8
d1414 1
a1414 1
      *flags = set_flags_from_win32_path (dst);
a1442 1
	  *flags = 0;
d1477 1
a1477 1
	  *flags = cygdrive_flags;
d1515 1
a1515 4
    {
      backslashify (pathbuf, dst, 0);	/* just convert */
      *flags = PATH_BINARY;		/* Default to binmode */
    }
d1544 1
a1544 1
      *flags = mi->flags;
@


1.216
log
@* path.cc (chdir): Don't allow cd'ing to a non-directory virtual path.
@
text
@d1511 1
a1511 1
      *flags = 0;
@


1.215
log
@oops
@
text
@d3314 5
@


1.214
log
@* fhandler_console.cc (fhandler_console::open): Reinstate setting of flags.
@
text
@a815 1
  debug_printf ("binary %d", isbinary ());
@


1.213
log
@* path.cc (path_conv::check): Set fileattr to INVALID_FILE_ATTRIBUTES for
nonexistent virtual device path.
(chdir): Set correct errno when attempt is made to cd to nonexistent virtual
device path.
@
text
@a743 1
      debug_printf ("path_copy %s", path_copy);
d816 1
@


1.212
log
@* autoload.cc (LoadFuncEx): Define via new LoadFuncEx2 macro.
(LoadFuncEx2): Adapted from LoadFuncEx.  Provides control of return value for
nonexistent function.
(NtQueryObject): Declare.
(IsDebuggerPresent): Declare via LoadFuncEx2 and always return true if not
available.
* debug.h (being_debugged): Just rely on IsDebuggerPresent return value.
* dtable.cc (handle_to_fn): New function.
(dtable::init_std_file_from_handle): Attempt to derive std handle's name via
handle_to_fn.
(dtable::build_fhandler_from_name): Fill in what we can in path_conv structure
when given a handle and path doesn't exist.
* fhandler.cc (fhandler_base::open): Don't set the file pointer here.  Use
pc->exists () to determine if file exists rather than calling GetFileAttributes
again.
* fhandler.h (fhandler_base::exec_state_isknown): New method.
(fhandler_base::fstat_helper): Add extra arguments to declaration.
(fhandler_base::fstat_by_handle): Declare new method.
(fhandler_base::fstat_by_name): Declare new method.
* fhandler_disk_file (num_entries): Make __stdcall.
(fhandler_base::fstat_by_handle): Define new method.
(fhandler_base::fstat_by_name): Define new method.
(fhandler_base:fstat): Call fstat_by_{handle,name} as appropriate.
(fhandler_disk_file::fstat_helper): Accept extra arguments for filling out stat
structure.  Move handle or name specific stuff to new methods above.
(fhandler_disk_file::open): Use real_path->exists rather than calling
GetFileAttributes again.
* ntdll.h (FILE_NAME_INFORMATION): Define new structure.
(OBJECT_INFORMATION_CLASS): Partially define new enum.
(OBJECT_NAME_INFORMATION): Define new structure.
(NtQueryInformationFile): New declaration.
(NtQueryObject): New declaration.
* path.cc (path_conv::fillin): Define new method.
* path.h (path_conv::fillin): Declare new method.
(path_conv::drive_thpe): Rename from 'get_drive_type'.
(path_conv::volser): Declare new method.
(path_conv::volname): Declare new method.
(path_conv::root_dir): Declare new method.
* syscalls.cc (fstat64): Send real path_conv to fstat as second argument.
@
text
@a538 1
		  default:
d541 4
d3310 5
@


1.211
log
@Remove unneeded sync.h, where appropriate, throughout.  Remove unneeded heap.h,
where appropriate, throughout.  Remove unneeded exceptions.h, where
appropriate, throughout.  Remove unneeded perprocess.h, where appropriate,
throughout.
@
text
@d376 17
d527 2
a528 2
          else if (isvirtual_dev (devn))
            {
d530 8
a537 8
              fhandler_virtual *fh =
                (fhandler_virtual *) cygheap->fdtab.build_fhandler (-1, devn, (const char *) path_copy, NULL, unit);
              int file_type = fh->exists ();
              switch (file_type)
                {
                  case 1:
                  case 2:
                    fileattr = FILE_ATTRIBUTE_DIRECTORY;
d539 5
a543 5
                  default:
                  case -1:
                    fileattr = 0;
                }
              delete fh;
d545 1
a545 1
            }
d1454 1
a1454 1
        return ENOENT;
d2699 1
a2699 1
  		  CREATE_NEW, FILE_ATTRIBUTE_NORMAL, 0);
d2747 1
a2747 1
	  				 : FILE_ATTRIBUTE_SYSTEM;
d3326 1
a3326 1
            && pcheck_case == PCHECK_RELAXED) || isvirtual_dev (devn))
@


1.210
log
@* dtable.cc (dtable::build_fhandler_from_name): Just pass posix path along to
set_name via return_and_clear_normalized_path.
(dtable::build_fhandler): New method with const char * argument.
(dtable::reset_unix_path_name): Eliminate.
(dtable::dup_worker): Use correct build_fhandler method.
* mmap.cc (mmap_record::alloc_fh): Ditto.
* dtable.h (dtable::build_fhandler): New method.
(dtable::reset_unix_path_name): Eliminate.
* fhandler.cc (fhandler_base::set_name): Assume that unix_name has already been
cmalloced.
(fhandler_base::reset_unix_path_name): Eliminate.
(fhandler_base::~fhandler_base): Coercion for cfree.
* fhandler.h (fhandler_base::unix_path_name): Make const char *.
(fhandler_base::win32_path_name): Ditto.
(fhandler_base::reset_unix_path_name): Eliminate.
* fhandler_disk_file.cc (fhandler_cygdrive::set_drives): Accommodate const char
*ness of win32_path_name.
* fhandler_socket.cc (fhandler_socket::fstat): Accommodate new set_name
requirements.
* path.cc (path_conv::return_and_clear_normalized_path): New method.
(path_conv::clear_normalized_path): Eliminate.
(path_conv::~path_conv): Ditto.
(path_conv::check): Accommodate new build_fhandler method.
* path.h (path_conv::~path_conv): Eliminate.
(path_conv::clear_normalized_path): Ditto.
(path_conv::return_and_clear_normalized_path): Declare new method.
@
text
@a66 1
#include "perprocess.h"
@


1.209
log
@* path.cc (path_conv::check): Make sure any trailing path component is part of
potential normalized posix path.
@
text
@d369 2
a370 2
void
path_conv::clear_normalized_path ()
d372 3
a374 11
  // not thread safe
  if (normalized_path)
    {
      cfree (normalized_path);
      normalized_path = NULL;
    }
}

path_conv::~path_conv ()
{
  clear_normalized_path ();
d515 1
a515 1
                (fhandler_virtual *) cygheap->fdtab.build_fhandler (-1, devn, path_copy, NULL, unit);
a725 1
      opt ^= PC_POSIX;
@


1.208
log
@* fhandler.h (fhandler_virtual::exists): Eliminate path argument.
(fhandler_proc::exists): Ditto.
(fhandler_registry::exists): Ditto.
(fhandler_process::exists): Ditto.
* fhandler_proc.cc (fhandler_proc::exists): Ditto.  Use built-in name.
* fhandler_process.cc (fhandler_process::exists): Ditto.
(fstat): Ditto.
* fhandler_registry.cc (fhandler_registry::exists): Ditto.
(fhandler_registry::fstat): Ditto.
* fhandler_virtual.cc (fhandler_virtual::opendir): Ditto.
* path.cc (path_conv::check): Ditto.  Add debugging.
* syscalls.cc (dup): Always call dup2 for error handling.
@
text
@d411 1
d467 1
a467 1
      char *tail = strchr (path_copy, '\0');   // Point to end of copy
d730 2
d734 1
@


1.207
log
@* path.cc (path_conv::check): Always set executable bit for executable
extension.
@
text
@d523 1
a523 1
              int file_type = fh->exists (path_copy);
d728 4
a731 1
    normalized_path = cstrdup (path_copy);
@


1.206
log
@* fhandler.h (executable_states): For now, make dont_care_if_executable
equivalent to not_executable.
* sys/mount.h: Define MOUNT_NOTEXEC.
* path.h (fs_info): New class.
(path_conv): Move fs-specific fields to new 'fs' structure.
(path_conv::update_fs_info): Move to fs_info and rename to just 'update'.
* path.cc (fs_info::update): Ditto.  Return 'true' if successful.
(fillout_mntent): Add ',noexec' to list of reported options.
@
text
@d790 1
a790 1
  if (!error && !(path_flags & (PATH_ALL_EXEC | PATH_NOTEXEC)))
@


1.205
log
@fix comment
@
text
@d327 2
a328 2
void
path_conv::update_fs_info (const char* win32_path)
d336 3
a338 4
      root_dir [0] = fs_name [0] = '\0';
      fs_flags = fs_serial = 0;
      sym_opt = 0;
      return;
d341 12
a352 1
  if (strcmp (tmp_buf, root_dir) != 0)
d354 11
a364 6
      strncpy (root_dir, tmp_buf, MAX_PATH);
      drive_type = GetDriveType (root_dir);
      if (drive_type == DRIVE_REMOTE || (drive_type == DRIVE_UNKNOWN && (root_dir[0] == '\\' && root_dir[1] == '\\')))
	is_remote_drive = 1;
      else
	is_remote_drive = 0;
d366 1
a366 18
      if (!GetVolumeInformation (root_dir, NULL, 0, &fs_serial, NULL, &fs_flags,
				     fs_name, sizeof (fs_name)))
	{
	  debug_printf ("Cannot get volume information (%s), %E", root_dir);
	  fs_name [0] = '\0';
	  fs_flags = fs_serial = 0;
	  sym_opt = 0;
	}
      else
	{
	  /* FIXME: Samba by default returns "NTFS" in file system name, but
	   * doesn't support Extended Attributes. If there's some fast way to
	   * distinguish between samba and real ntfs, it should be implemented
	   * here.
	   */
	  sym_opt = (!is_remote_drive && strcmp (fs_name, "NTFS") == 0) ? PC_CHECK_EA : 0;
	}
    }
d430 6
a435 6
  root_dir[0] = '\0';
  fs_name[0] = '\0';
  fs_flags = fs_serial = 0;
  sym_opt = 0;
  drive_type = 0;
  is_remote_drive = 0;
d549 2
a550 1
	  update_fs_info (full_path);
d574 1
a574 1
	  int len = sym.check (full_path, suff, opt | sym_opt);
d744 1
a744 2
      update_fs_info (path);
      if (!fs_name[0])
d746 1
d754 2
a755 2
			root_dir, this->path, fs_flags & FS_PERSISTENT_ACLS);
	  if (!allow_smbntsec && is_remote_drive)
d758 1
a758 1
	    set_has_acls (fs_flags & FS_PERSISTENT_ACLS);
d761 1
a761 1
	  set_has_buggy_open (strcmp (fs_name, "SUNWNFS") == 0);
d2420 2
@


1.204
log
@* net.cc (getdomainname): Change second argument of getdomainname to size_t.
* fhandler_proc.cc (proc_listing): Add '.' and '..' to directory listing.
(fhandler_proc::open): Change use of mode to flags.  If the file does not exist
already, fail with EROFS if O_CREAT flag is set.  Change EROFS error to EACCES
error when writing to a file.  Use cmalloc to allocate memory for filebuf.
(fhandler_proc::close): Use cfree to free filebuf.
(fhandler_proc::get_proc_fhandler): Properly detect attempts to access unknown
subdir.
* fhandler_process.cc (process_listing): Add '.' and '..' to directory listing.
(fhandler_process::open): Use cmalloc to allocate memory for filebuf.
(fhandler_process::close): Use cfree to free filebuf.
* fhandler_registry.cc (registry_listing): Add .  and '..' to directory
listing.
(fhandler_registry::open): Move check for open for writing before open_key.
Use cmalloc to allocate memory for filebuf.
(fhandler_registry::close): Use cfree to free filebuf.
(fhandler_registry::telldir): Use lower 16 bits of __d_position as position in
directory.
(fhandler_registry::seekdir): Ditto.
* fhandler_virtual.cc (fhandler_virtual::write): Change EROFS error to EACCES
error.
(fhandler_virtual::open): Set the NOHANDLE flag.
(fhandler_virtual::dup): Add call to fhandler_base::dup.  Allocate child's
filebuf using cmalloc.  Copy filebuf from parent to child.
(fhandler_virtual::close): Use cfree to free filebuf.
(fhandler_virtual::~fhandler_virtual): Ditto.
(from Chris Faylor <cgf@@redhat.com>).
(fhandler_registry::readdir): Add support for '.' and '..' files in
subdirectories of /proc/registry.
* path.cc (path_conv::check): Do not return ENOENT if a file is not found in
/proc.
@
text
@d522 1
a522 1
	      /* FIXME: Fix this.  Calling build_fhandler here is not the right way to handle this. */
@


1.203
log
@* fhandler_proc.cc (fhandler_proc::fstat): Use fhandler name rather than
path_conv name.
(fhandler_proc::open): Ditto.
* fhandler_process.cc (fhandler_process::fstat): Use fhandler name rather than
path_conv name.
(fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::fstat): Use fhandler name rather
than path_conv name.
(fhandler_registry::open): Ditto.
* path.cc (path_conv::check): Don't copy posix path when virtual.
(mount_info::conv_to_win32_path): Don't zero string when isproc.  Just derive
normal windows path.
* path.h (path_conv::clear_normalized_path): Declare new method.
* path.cc (path_conv::clear_normalized_path): Define new method.
* dtable.cc (build_fhandler_from_name): Clear normalized path when finished to
conserve space.
@
text
@a527 3
                  case 0:
                    error = ENOENT;
		    break;
d532 1
@


1.202
log
@	* path.cc (hash_path_name): Improve hash function strength.
@
text
@d371 11
d384 1
a384 2
  if (normalized_path)
    cfree (normalized_path);
a538 2
	      if (!error)
		strcpy (path, path_copy);
d1439 7
a1445 1
  if (iscygdrive (pathbuf))
a1462 8
    }
  if (isproc (pathbuf))
    {
      devn = fhandler_proc::get_proc_fhandler (pathbuf);
      dst[0] = '\0';
      if (devn == FH_BAD)
        return ENOENT;
      goto out;
@


1.201
log
@add comment
@
text
@d3185 1
a3185 1
	  hash += hash_path_name (hash, "\\");
d3195 1
a3195 2
      hash += ch + (ch << 17);
      hash ^= hash >> 2;
@


1.200
log
@* path.h (pathconv_arg): Add PC_POSIX.
(path_conv): Add normalized_path field.
* path.cc (path_conv::~path_conv): New destructor.
(path_conv::check): Set normalized_path, where appropriate.
* dtable.cc (build_fhandler_from_name): Use normalized path from path_conv.
* syscalls.cc (chroot): Ditto.
* cygheap.h: Remove path_prefix_p declaration.  Christopher Faylor
<cgf@@redhat.com> (minor fixups)
* Makefile.in: Add fhandler_proc.o, fhandler_registry.o, fhandler_process.o and
fhandler_virtual.o.
* dtable.cc (dtable::build_fhandler): Add entries for FH_PROC, FH_REGISTRY and
FH_PROCESS.  Set unix_name to the normalized posix path.
* fhandler.h: Add constants for FH_PROC, FH_REGISTRY and FH_PROCESS.  Add class
declarations for fhandler_virtual, fhandler_proc, fhandler_registry and
fhandler_virtual.  Update fhandler_union accordingly.
* fhandler_proc.cc: New file.  Add implementation for fhandler_proc.
* fhandler_virtual.cc: New file.  Add implementation for fhandler_virtual.
* fhandler_process.cc: New file.  Add implementation for fhandler_process.
* fhandler_registry.cc: New file.  Add implementation for fhandler_registry.
* path.cc: Add isproc and isvirtual_dev macros.
* path.cc (path_conv::check): Add check for virtual devices.
* path.cc (mount_info::conv_to_win32_path): Convert paths in /proc to empty
Win32 paths.
* path.cc (chdir): Replace check for FH_CYGDRIVE with more generic
isvirtual_dev macro.  Force setting of posix path for virtual fhandlers.
* path.h: Add externally visible path_prefix_p and normalized_posix_path
prototypes.
@
text
@d512 1
@


1.199
log
@* path.cc (normalize_posix_path): Avoid runs of '.'s > 2.
@
text
@d121 6
d182 1
a182 1
int
d371 6
d428 1
d510 22
d721 2
d1449 8
d1524 1
a1524 1
  if (devn != FH_CYGDRIVE)
d3285 2
a3286 1
  if (path.get_devn () != FH_CYGDRIVE)
d3306 2
a3307 2
  else if (!path.has_symlinks () && strpbrk (dir, ":\\") == NULL
	   && pcheck_case == PCHECK_RELAXED)
@


1.198
log
@* sync.h (new_muto): Just accept an argument which denotes the name of the
muto.  Use this argument to construct static storage.
* cygheap.cc (cygheap_init): Reflect above change.
* exceptions.cc (events_init): Ditto.
* malloc.cc (malloc_init): Ditto.
* path.cc (cwdstuff::init): Ditto.
* cygheap.h (cwdstuff): Change name of lock element to make it less generic.
* path.cc (cwdstuff::get_hash): Ditto.
(cwdstuff::get_initial): Ditto.
(cwdstuff::set): Ditto.
(cwdstuff::get): Ditto.
* sigproc.cc (proc_subproc): Ditto.
* debug.cc (lock_debug): Change to method.  Use method rather than macro
throughout.
* tty.h (tty_min::kill_pgrp): Declare new method.
* fhandler_termios.cc (tty_min::kill_pgrp): New method.
(fhandler_termios::line_edit): Use new method for killing process.
* dcrt0.cc (do_exit): Ditto.
* dtable.cc (dtable::get_debugger_info): New method for inheriting dtable info
from a debugger.
* tty.cc (tty_init): Attempt to grab file handle info from parent debugger, if
appropriate.  # dtable.cc (dtable::stdio_init): Make this a method.
(dtable::init_std_file_from_handle): Don't set fd unless it's not open.
(dtable::build_fhandler_from_name): Move name setting to
dtable::build_fhandler.
(dtable::build_fhandler): Add win32 name parameter.
* dcrt0.cc (dll_crt0_1): Change to use dtable stdio_init.
* dtable.h (dtable): Reflect build_fhandler parameter change.
* mmap.cc (mmap_record::alloc_fh): Don't set name parameter in build_fhandler.
* net.cc (fdsock): Remove set_name call since it is now handled by
build_fhandler.
* sigproc.cc (proc_subproc): Release muto as early as possible.
@
text
@d252 5
a256 1
		break;
@


1.197
log
@* times.cc (hires::prime): Restore thread priority on failure condition.
* uinfo.cc (uinfo_init): Use more robust method for determining if process was
invoked from a non-cygwin process.
* sync.h (muto::init): Eliminate "inheritance" parameter.
(new_muto): Reflect removal of parameter.
* sync.cc (muto::init): Ditto.
* cygheap.cc (cygheap_init): Ditto.
* debug.cc (threadname_init): Ditto.
* exceptions.cc (events_init): Ditto.
* malloc.cc (malloc_init): Ditto.
* path.cc (cwdstuff::init): Ditto.
* sigproc.cc (sigproc_init): Ditto.
* grp.cc (group_lock): Use different method for locking with static member.
(read_etc_group): REALLY ensure that read lock mutex is released.
* passwd.cc (passwd_lock): Use different method for locking with static member.
(read_etc_passwd): REALLY ensure that read lock mutex is released.
* shared.cc (sec_user): Correct reversed inheritance test.
@
text
@d3539 1
a3539 1
  lock->acquire ();
d3541 1
a3541 1
  lock->release ();
d3549 1
a3549 1
  lock = new_muto ("cwd");
d3557 1
a3557 1
  lock->acquire ();
d3574 1
a3574 1
      lock->release ();
d3576 1
a3576 1
      lock->release ();
d3593 1
a3593 1
      lock->acquire ();
d3609 1
a3609 1
    lock->release ();
d3654 1
a3654 1
  lock->release ();
@


1.196
log
@	* path.cc (symlink): Fix check for already existing file.
@
text
@d3549 1
a3549 1
  lock = new_muto (false, "cwd");
@


1.195
log
@	* path.cc (fchdir): Call chdir with full windows path.
@
text
@d2578 1
a2578 1
  if (allow_winsymlinks && !win32_path.error)
@


1.194
log
@	* dir.cc: Use INVALID_FILE_ATTRIBUTES instead of "(DWORD) -1"
	for file attributes throughout.
	* fhandler.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* path.cc: Ditto.
	* path.h: Ditto.
	* syscalls.cc: Ditto.
	* times.cc (utimes): Use path_conv::isdir() instead of explicit
	GetFileAttributes() call.
@
text
@d3278 1
a3278 1
    res = chdir (cfd->get_name ());
@


1.193
log
@* path.cc (path_conv::check): Use full path name for determining attributes
when /cygdrive/x/foo.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Red Hat, Inc.
d403 1
a403 1
  fileattr = (DWORD) -1;
d554 1
a554 1
	      if (!sym.is_symlink && sym.fileattr != (DWORD) -1)
d2400 1
a2400 1
	  GetFileAttributes (native_path) == (DWORD) -1)
d2612 1
a2612 1
      if (!cp || GetFileAttributes (w32topath) == (DWORD)-1)
d2914 1
a2914 1
      if (fileattr == (DWORD) -1)
d2981 1
a2981 1
	  fileattr = (DWORD) -1;
d3075 1
a3075 1
      if (pathbuf.fileattr != (DWORD) -1)
@


1.192
log
@* path.cc (path_conv::check): Reset FH_CYGDRIVE if iterating through path.
@
text
@d484 7
a490 4
	      if (component)
		devn = FH_BAD;
	      fileattr = !unit ? FILE_ATTRIBUTE_DIRECTORY
			       : GetFileAttributes (full_path);
d525 1
a525 1
	      fileattr = GetFileAttributes (full_path);
@


1.191
log
@* path.cc (path_conv::check): Don't complain if /dev/x/foo when x doesn't
exist.
(mount_info::conv_to_win32_path): Keep translating when a /cygdrive is found.
Don't attempt to translate to a device name when devn == FH_CYGDRIVE.
(cygwin_conv_to_win32_path): Set buffer to empty on error.
(cygwin_conv_to_full_win32_path): Ditto.
* window.cc: Include unistd.h to verify definitions.
@
text
@d103 1
a103 1
  BOOL case_clash;
d404 1
a404 1
  case_clash = FALSE;
d482 8
d491 1
a491 1
	  if (devn != FH_BAD)
d493 2
a494 1
	      if (devn != FH_CYGDRIVE)
d496 2
a497 6
		  fileattr = 0;
		  if (component)
		    {
		      error = ENOTDIR;
		      return;
		    }
a498 3
	      else if (!component)
		fileattr = !unit ? FILE_ATTRIBUTE_DIRECTORY
				 : GetFileAttributes (full_path);
d507 4
a510 3
	  /* If path is only a drivename, Windows interprets it as the current working
	     directory on this drive instead of the root dir which is what we want. So
	     we need the trailing backslash in this case. */
a542 1

d697 2
a698 2
	  set_has_acls (FALSE);
	  set_has_buggy_open (FALSE);
d706 1
a706 1
	    set_has_acls (FALSE);
d1027 1
a1027 1
    return FALSE;
d1030 1
a1030 1
    return FALSE;
d1729 1
a1729 1
      res = mount_table->add_item (native_path, posix_path, mount_flags, FALSE);
d2192 1
a2192 1
  int posix_path_p = FALSE;
d2538 1
a2538 1
      return FALSE;
d2545 1
a2545 1
/* If TRUE create symlinks as Windows shortcuts, if FALSE create symlinks
d2905 1
a2905 1
  case_clash = FALSE;
d2989 1
a2989 1
      is_symlink = FALSE;
d3002 1
a3002 1
   FALSE if pcheck_case == PCHECK_STRICT.
d3032 1
a3032 1
	    return FALSE;
d3546 1
a3546 1
  lock = new_muto (FALSE, "cwd");
@


1.190
log
@* net.cc (cygwin_getsockopt): Allow NULL optval.
* path.cc (mount_info::read_cygdrive_info_from_registry): Don't write cygdrive
to registry if it doesn't exist.
@
text
@d485 1
a485 1
	      if (component)
d487 6
a492 2
		  error = ENOTDIR;
		  return;
d494 1
a494 3
	      if (devn != FH_CYGDRIVE)
		fileattr = 0;
	      else
a1393 1
	  goto out;
d1470 2
a1471 1
  win32_device_name (src_path, dst, devn, unit);
d3292 1
d3297 1
a3297 1
  strcpy (win32_path, p.get_win32 ());
d3307 1
d3312 1
a3312 1
  strcpy (win32_path, p.get_win32 ());
@


1.189
log
@* path.cc (mount_info::conv_to_win32_path): Avoid returning error if cygdrive
== '/'.
(mount_info::cygdrive_win32_path): Return 0 if invalid cygdrive path.
@
text
@d1870 1
a1870 2
  if (r.get_string (CYGWIN_INFO_CYGDRIVE_PREFIX, cygdrive, sizeof (cygdrive),
      "") != 0)
d1880 6
a1885 16
    if (r2.get_string (CYGWIN_INFO_CYGDRIVE_PREFIX, cygdrive, sizeof (cygdrive),
	"") != 0)
      {
	/* Didn't find either so write the default to the registry and use it.
	   NOTE: We are writing and using the user path prefix.  */
	write_cygdrive_info_to_registry (CYGWIN_INFO_CYGDRIVE_DEFAULT_PREFIX,
					 MOUNT_AUTO);
      }
    else
      {
	/* Fetch system cygdrive_flags from registry; returns MOUNT_AUTO on
	   error. */
	cygdrive_flags = r2.get_int (CYGWIN_INFO_CYGDRIVE_FLAGS, MOUNT_AUTO);
	slashify (cygdrive, cygdrive, 1);
	cygdrive_len = strlen(cygdrive);
      }
@


1.188
log
@* path.cc (path_conv::check): Tighten FH_CYGDRIVE check to avoid matching
trailing component, like other devices.
@
text
@d1392 1
d1394 6
a1399 1
      else if (!cygdrive_win32_path (pathbuf, dst, unit))
a1400 3
      else
	*flags = cygdrive_flags;
      goto out;
d1524 1
a1524 1
      res = unit = -1;
d1526 1
d1535 1
d1538 1
a1538 1
  return 1;
@


1.188.2.1
log
@* net.cc (cygwin_getsockopt): Allow NULL optval.
* path.cc (mount_info::read_cygdrive_info_from_registry): Don't write cygdrive
to registry if it doesn't exist.
* path.cc (mount_info::conv_to_win32_path): Avoid returning error if cygdrive
== '/'.
(mount_info::cygdrive_win32_path): Return 0 if invalid cygdrive path.
@
text
@a1391 1
	  goto out;
d1393 1
a1393 6
      else if (cygdrive_win32_path (pathbuf, dst, unit))
	{
	  *flags = cygdrive_flags;
	  goto out;
	}
      else if (mount_table->cygdrive_len > 1)
d1395 3
d1521 1
a1521 1
      unit = -1;
a1522 1
      res = 0;
a1530 1
      res = 1;
d1533 1
a1533 1
  return res;
d1865 2
a1866 1
  if (r.get_string (CYGWIN_INFO_CYGDRIVE_PREFIX, cygdrive, sizeof (cygdrive), "") != 0)
d1876 16
a1891 6
      if (r2.get_string (CYGWIN_INFO_CYGDRIVE_PREFIX, cygdrive,
	  sizeof (cygdrive), ""))
	strcpy (cygdrive, CYGWIN_INFO_CYGDRIVE_DEFAULT_PREFIX);
      cygdrive_flags = r2.get_int (CYGWIN_INFO_CYGDRIVE_FLAGS, MOUNT_AUTO);
      slashify (cygdrive, cygdrive, 1);
      cygdrive_len = strlen (cygdrive);
@


1.188.2.1.8.1
log
@* path.cc (path_conv::check): Don't complain if /dev/x/foo when x doesn't
exist.
(mount_info::conv_to_win32_path): Keep translating when a /cygdrive is found.
Don't attempt to translate to a device name when devn == FH_CYGDRIVE.
(cygwin_conv_to_win32_path): Set buffer to empty on error.
(cygwin_conv_to_full_win32_path): Ditto.
* window.cc: Include unistd.h to verify definitions.
@
text
@d485 1
a485 1
	      if (devn != FH_CYGDRIVE)
d487 2
a488 6
		  fileattr = 0;
		  if (component)
		    {
		      error = ENOTDIR;
		      return;
		    }
d490 3
a492 1
	      else if (!component)
d1392 1
d1469 1
a1469 2
  if (devn != FH_CYGDRIVE)
    win32_device_name (src_path, dst, devn, unit);
a3289 1
      win32_path[0] = '\0';
d3294 1
a3294 1
  strcpy (win32_path, p);
a3303 1
      win32_path[0] = '\0';
d3308 1
a3308 1
  strcpy (win32_path, p);
@


1.188.2.1.8.2
log
@* path.cc (path_conv::check): Reset FH_CYGDRIVE if iterating through path.
@
text
@d103 1
a103 1
  bool case_clash;
d404 1
a404 1
  case_clash = false;
a481 8
	  if (devn == FH_CYGDRIVE)
	    {
	      if (component)
		devn = FH_BAD;
	      fileattr = !unit ? FILE_ATTRIBUTE_DIRECTORY
			       : GetFileAttributes (full_path);
	      goto out;
	    }
d483 1
a483 1
	  else if (devn != FH_BAD)
d485 1
a485 2
	      fileattr = 0;
	      if (component)
d487 6
a492 2
		  error = ENOTDIR;
		  return;
d494 3
d505 3
a507 4
	  /* If path is only a drivename, Windows interprets it as the
	     current working directory on this drive instead of the root
	     dir which is what we want. So we need the trailing backslash
	     in this case. */
d540 1
d695 2
a696 2
	  set_has_acls (false);
	  set_has_buggy_open (false);
d704 1
a704 1
	    set_has_acls (false);
d1025 1
a1025 1
    return false;
d1028 1
a1028 1
    return false;
d1727 1
a1727 1
      res = mount_table->add_item (native_path, posix_path, mount_flags, false);
d2190 1
a2190 1
  int posix_path_p = false;
d2536 1
a2536 1
      return false;
d2543 1
a2543 1
/* If TRUE create symlinks as Windows shortcuts, if false create symlinks
d2903 1
a2903 1
  case_clash = false;
d2987 1
a2987 1
      is_symlink = false;
d3000 1
a3000 1
   false if pcheck_case == PCHECK_STRICT.
d3030 1
a3030 1
	    return false;
d3544 1
a3544 1
  lock = new_muto (false, "cwd");
@


1.188.2.1.8.2.2.1
log
@* path.cc (path_conv::check): Use full path name for determining attributes
when /cygdrive/x/foo.
@
text
@d484 4
a487 7
	      if (!component)
		fileattr = FILE_ATTRIBUTE_DIRECTORY;
	      else
		{
		  devn = FH_BAD;
		  fileattr = GetFileAttributes (this->path);
		}
d522 1
a522 1
	      fileattr = GetFileAttributes (this->path);
@


1.187
log
@* autoload.cc (IsDebuggerPresent): Make conditional load since it is not
available everywhere.
* path.cc (mount_info::conv_to_win32_path): Only consider /cygdrive to be
FH_CYGDRIVE, not /cygdrive/x.
@
text
@d485 8
a492 1
	      if (devn == FH_CYGDRIVE)
a494 10
	      else
		{
		  if (component)
		    {
		      error = ENOTDIR;
		      return;
		    }
		  fileattr = 0;
		}

@


1.186
log
@* path.cc (chdir): Allow 'cd /cygdrive'.
@
text
@d1393 2
a1399 2
      if (mount_table->cygdrive_len > 1)
	devn = FH_CYGDRIVE;
@


1.185
log
@* dtable.cc (dtable::vfork_parent_restore): Add debugging statement.
* exceptions.cc (try_to_debug): Spin only as long as we don't have a debugger
attached.
* fhandler.h (fhandler_base::set_nohandle): New method.
(fhandler_base::get_nohandle): New method.
* fhandler.cc (fhandler_base::dup): Avoid duplicating handle if there is no
handle.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Set nohandle flag on
dummy fd.
* Makefile.in: Make intermediate library for eventual inclusion in libcygwin.a
* fhandler.h (fhandler_pipe::fhandler_pipe): Remove default argument setting
since it is no longer used.
* miscfuncs.cc (check_null_str): New function.
(+check_null_str_errno): Ditto.
* net.cc: Add defensive buffer checking throughout.
(cygwin_sendto): Protect against invalid fd.
(cygwin_recvfrom): Ditto.
(cygwin_getpeername): Ditto.
(cygwin_recv): Ditto.
(cygwin_send): Ditto.
* winsup.h: Declare a new function.
* select.cc (set_bits): Fix conditional for setting fd in exceptfds.
* dtable.cc (dtable::build_fhandler): Create fhandler_pipe using correct device
type.
* path.cc (get_devn): Set correct pipe device type from device name.
@
text
@d3226 1
a3226 1
  char *native_dir = path.get_win32 ();
d3234 10
a3243 2
      native_dir[2] = '\\';
      native_dir[3] = '\0';
a3244 1
  int res = SetCurrentDirectoryA (native_dir) ? 0 : -1;
d3260 1
a3260 1
    cygheap->cwd.set (path, dir);
d3262 1
a3262 1
    cygheap->cwd.set (path, NULL);
@


1.184
log
@* path.cc (conv_path_list): Fix wild indexing into path due to conflicting
methods for setting src pointer.
* dir.cc (opendir): Only pass path_conv argument to opendir, since name is
already part of the fhandler.
* dtable.cc (dtable::build_fhandler): Accomodate new FH_CYGDRIVE type.
* fhandler.cc (fhandler_base::opendir): Nuke name argument.
* fhandler.h: Add FH_CYGDRIVE to "device" enum.
(fhandler_base::opendir): Nuke name argument.
(fhandler_disk_file::opendir): Ditto.
(fhandler_disk_file::fhandler_disk_file): Declare new method which passes
devtype through.
(fhandler_cygdrive): Add elements for tracking drives.
(fhandler_cygdrive::set_drives): Declare new method.
(fhandler_cygdrive::iscygdrive_root): Declare new method.
(fhandler_cygdrive::opendir): Declare new method.
(fhandler_cygdrive::readdir): Declare new method.
(fhandler_cygdrive::telldir): Declare new method.
(fhandler_cygdrive::seekdir): Declare new method.
(fhandler_cygdrive::rewinddir): Declare new method.
(fhandler_cygdrive::closedir): Declare new method.
(fhandler_cygdrive::fstat): Declare new method.
* fhandler_disk_file.cc (fhandler_disk_file::fhandler_disk_file): Define new
method which passes devtype through.
(fhandler_disk_file::open): Tweak debug output.
(fhandler_disk_file::opendir): Nuke first argument.  Use info from path_conv
and class rather than calling fstat.
(fhandler_cygdrive::set_drives): New method.
(fhandler_cygdrive::iscygdrive_root): New method.
(fhandler_cygdrive::opendir): New method.
(fhandler_cygdrive::readdir): New method.
(fhandler_cygdrive::telldir): New method.
(fhandler_cygdrive::seekdir): New method.
(fhandler_cygdrive::rewinddir): New method.
(fhandler_cygdrive::closedir): New method.
(fhandler_cygdrive::fstat): New method.
* path.cc (iscygdrive_device): Assume cygdriveness is already verified.
(path_conv::check): Treat FH_CYGDRIVE "method" as a special case, setting file
attributes as needed.
(mount_info::conv_to_win32_path): Allow stand-alone /cygdrive, meaning "the
directory which contains all of the drives on the system".
(fillout_mntent): Use cyg_tolower for conversions.
(mount_info::cygdrive_win32_path): Replace unused argument with unit number.
* shared_info.h (mount_info::cygdrive_win32_path): Reflect argument change.
@
text
@d860 1
a860 1
  else if (deveq ("pipe") || deveq ("piper") || deveq ("pipew"))
d862 4
@


1.183
log
@* Makefile.in (DLL_OFILES): Add fhandler_disk_file.o.
* cygheap.h (cygheap_fdnew::operator =): New operator.
* dir.cc: Add invalid struct checking throughout.  Use methods for all
directory manipulation throughout.
* fhandler.cc: Move fhandler_disk_file stuff to own file.
(fhandler_base::opendir): New method.
(fhandler_base::readdir): New method.
(fhandler_base::telldir): New method.
(fhandler_base::seekdir): New method.
(fhandler_base::rewinddir): New method.
(fhandler_base::closedir): New method.
* fhandler_disk_file.cc: New file.
* fhandler.h (fhandler_base): Declare new virtual methods.
(fhandler_disk_file): Ditto.
(fhandler_cygdrive): New class.
* path.cc (conv_path_list): Use strccpy to break apart path.
@
text
@d117 1
a117 1
  (iscygdrive(path) && isalpha(path[mount_table->cygdrive_len]) && \
d485 4
a488 1
	      if (component)
d490 6
a495 2
		  error = ENOTDIR;
		  return;
d497 1
a497 1
	      fileattr = 0;
d520 1
a520 1
	      fileattr = GetFileAttributesA (full_path);
d1247 1
a1247 1
  do
d1254 4
a1257 6
      src += len;
      if (*src)
	{
	  d = strchr (d, '\0');
	  *d++ = dst_delim;
	}
a1258 1
  while (*src++);
d1381 1
a1381 1
  if (iscygdrive_device (pathbuf))
d1383 8
a1390 1
      if (!cygdrive_win32_path (pathbuf, dst, 0))
d1392 4
a1395 1
      *flags = cygdrive_flags;
d1514 1
a1514 1
mount_info::cygdrive_win32_path (const char *src, char *dst, int trailing_slash_p)
d1516 1
d1519 12
a1530 5
    return 0;
  dst[0] = *p;
  dst[1] = ':';
  strcpy (dst + 2, p + 1);
  backslashify (dst, dst, trailing_slash_p || !dst[2]);
d2330 1
a2330 1
      int drivenum = tolower (native_path[0]) - 'a';
d2682 1
a2682 1
	  SetFileAttributesA (win32_path.get_win32 (), attr);
d2911 1
a2911 1
      fileattr = GetFileAttributesA (suffix.path);
d2914 1
a2914 1
	  /* The GetFileAttributesA call can fail for reasons that don't
d2917 1
a2917 1
	  debug_printf ("GetFileAttributesA (%s) failed", suffix.path);
@


1.182
log
@* path.cc (conv_path_list): Copy source paths before modifying them.
@
text
@d1237 2
a1238 2
  char srcbuf[MAX_PATH];
  int len;
d1242 7
a1248 2
      s = strchr (src, src_delim);
      if (s)
d1250 1
a1250 7
	  len = s - src;
	  if (len >= MAX_PATH)
	    len = MAX_PATH - 1;
	  memcpy (srcbuf, src, len);
	  srcbuf[len] = 0;
	  (*conv_fn) (len ? srcbuf : ".", d);
	  d += strlen (d);
a1251 6
	  src = s + 1;
	}
      else
	{
	  /* Last one.  */
	  (*conv_fn) (src[0] != 0 ? src : ".", d);
d1254 1
a1254 1
  while (s != NULL);
@


1.181
log
@	* dir.cc (mkdir): Add HIDDEN file attribute if file has leading dot
	and HIDDEN_DOT_FILES is defined.
	* fhandler.cc (fhandler_base::open): Ditto.
	* path.cc (symlink): Ditto.
	* syscalls.cc (_rename): Ditto and remove HIDDEN file attribute if
	new filename does not begin with a dot.
@
text
@d1237 2
d1245 6
a1250 2
	  *s = 0;
	  (*conv_fn) (src[0] != 0 ? src : ".", d);
a1252 1
	  *s = src_delim;
@


1.180
log
@Eliminate excess whitespace.
@
text
@d2608 1
a2608 1
		  CREATE_NEW, FILE_ATTRIBUTE_NORMAL, 0);
d2610 1
a2610 1
      __seterrno ();
d2654 10
a2663 3
	  SetFileAttributesA (win32_path.get_win32 (),
			      allow_winsymlinks ? FILE_ATTRIBUTE_READONLY
						: FILE_ATTRIBUTE_SYSTEM);
@


1.179
log
@* fhandler.h (fhandler_serial::fhandler_serial): Change to only accept unit
argument.
* fhandler_serial.cc (fhandler_serial::fhandler_serial): Ditto.
(fhandler_serial::open): Avoid else when previous clause is a return().
* path.cc (get_devn): Alias /dev/ttyS0 -> /dev/com1, etc.
(get_device_number): Reallow standalone "com1" as a valid name for /dev/com1.
@
text
@d864 1
a864 1
    -----      -----	--------------	-------------------------	
d950 1
a950 1
        {
d958 1
a958 1
        {
d963 1
a963 1
        {
d972 1
a972 1
    					const char *w32_path, int &unit)
d1023 1
a1023 1
        break;
d1025 2
a1026 2
        __small_sprintf (win32_path, "\\Device\\Tape%d", unit % 128);
        break;
d1028 1
a1028 1
        if (unit < 16)
d1037 1
a1037 1
        break;
d1040 1
a1040 1
        break;
d2544 1
a2544 1
     symlink contents point to existing filesystem object */ 
@


1.178
log
@* Makefile.in: Only build testsuite directory on first 'make check'.
* configure.in: Remove testsuite from SUBDIRS.
* configure: Regenerate.
@
text
@d849 4
a852 1
    devn = FH_SERIAL;
a984 3
      if (devn == FH_BAD && udeveqn ("com", 3)
	  && (unit = digits (unix_path + 3)) >= 0)
	devn = FH_SERIAL;
d990 10
@


1.177
log
@        * path.cc (getcwd): Allow len == 0 when buf == NULL.
@
text
@d110 2
d1716 1
a1716 2
	      CYGWIN_INFO_CYGNUS_REGISTRY_NAME,
	      CYGWIN_INFO_CYGWIN_REGISTRY_NAME,
d1761 1
a1761 2
		       CYGWIN_INFO_CYGNUS_REGISTRY_NAME,
		       CYGWIN_INFO_CYGWIN_REGISTRY_NAME,
d1809 1
a1809 2
		       CYGWIN_INFO_CYGNUS_REGISTRY_NAME,
		       CYGWIN_INFO_CYGWIN_REGISTRY_NAME,
d1841 1
a1841 2
		 CYGWIN_INFO_CYGNUS_REGISTRY_NAME,
		 CYGWIN_INFO_CYGWIN_REGISTRY_NAME,
d1891 1
a1891 2
	     CYGWIN_INFO_CYGNUS_REGISTRY_NAME,
	     CYGWIN_INFO_CYGWIN_REGISTRY_NAME,
d1947 1
a1947 2
	     CYGWIN_INFO_CYGNUS_REGISTRY_NAME,
	     CYGWIN_INFO_CYGWIN_REGISTRY_NAME,
d1979 1
a1979 2
	      CYGWIN_INFO_CYGNUS_REGISTRY_NAME,
	      CYGWIN_INFO_CYGWIN_REGISTRY_NAME,
@


1.176
log
@        * fhandler_raw.cc (fhandler_dev_raw::open): Eliminate compatibility
        code since no Win32 device names are used anymore.
        * fhandler_tape.cc (fhandler_dev_tape::tape_set_blocksize): Allow
        0 as blocksize to indicate variable blocksize.
        * path.cc (win32_device_name): Generate NT internal device names
        using upper/lower case names for readability.
        Generate \DosDevices\<letter>: device name for mount table
        compatibility devices.
@
text
@d3123 1
a3123 1
  if (ulen == 0)
@


1.175
log
@	* autoload.cc: Add load statement for `NtOpenFile'.
	* fhandler.h (fhandler_dev_raw::get_unit): New method.
	(fhandler_dev_tape::norewind): Eliminate.
	(fhandler_dev_tape::is_rewind_device): New method.
	* fhandler_raw.cc (fhandler_dev_raw::open): Open new
	fixed device name devices using NT internal method.
	Keep calling fhandler_base::open() for old mount table
	device mapping compatibility devices.
	(fhandler_dev_raw::fstat): Eliminate.  Settings are done
	by fhandler_base::fstat() already.
	* fhandler_tape.cc: Remove `norewind' usage throughout.
	* ntdll.h: Define FILE_SYNCHRONOUS_IO_NONALERT.
	Define struct _IO_STATUS_BLOCK.
	Declare NtOpenFile().
	* path.cc (get_raw_device_number): Add new approach for
	using fixed device names.
	(win32_device_name): Ditto.
	(get_device_number): Ditto.  Require POSIX path to begin
	with "/dev/".
	(mount_info::conv_to_win32_path): Call win32_device_name()
	instead of get_device_number() after evaluating mount points
	to allow changing the win32 destination path again.
	* security.cc (str2buf2uni): Remove `static' to be able to
	call function from fhandler_dev_raw::open().
	* wincap.cc: Set flag has_raw_devices appropriately.
	* wincap.h: Add flag has_raw_devices.
@
text
@d1013 1
a1013 1
        __small_sprintf (win32_path, "\\device\\tape%d", unit % 128);
d1017 1
a1017 1
	  __small_sprintf (win32_path, "\\device\\floppy%d", unit);
d1019 1
a1019 1
	  __small_sprintf (win32_path, "\\device\\cdrom%d", unit - 16);
d1021 1
a1021 1
	  __small_sprintf (win32_path, "\\device\\harddisk%d\\partition%d",
d1024 1
a1024 1
	  __small_sprintf (win32_path, "\\\\.\\%c:", unit - 224 + 'A');
@


1.174
log
@minor reformat.
@
text
@d857 37
d895 1
a895 1
get_raw_device_number (const char *unix_path, const char *w32_path, int &unit)
d897 3
a899 3
  int devn;
  w32_path += 4;
  if (wdeveqn ("tape", 4))
d901 61
a961 15
      unit = digits (w32_path + 4);
      // norewind tape devices have leading n in name
      if (udeveqn ("/dev/n", 6))
	unit += 128;
      devn = FH_TAPE;
    }
  else if (isdrive (w32_path))
    {
      unit = cyg_tolower (w32_path[0]) - 'a';
      devn = FH_FLOPPY;
    }
  else if (wdeveqn ("physicaldrive", 13))
    {
      unit = digits (w32_path + 13) + 128;
      devn = FH_FLOPPY;
a962 2
  else
    devn = FH_BAD;
d976 12
a987 9
    devn = get_devn (unix_path, unit);
  if (devn == FH_BAD && *w32_path == '\\' && wdeveqn ("\\dev\\", 5))
    devn = get_devn (w32_path, unit);
  if (devn == FH_BAD && udeveqn ("com", 3)
      && (unit = digits (unix_path + 3)) >= 0)
    devn = FH_SERIAL;
  else if (strncmp (w32_path, "\\\\.\\", 4) == 0)
    devn = get_raw_device_number (unix_path, w32_path, unit);

d1000 1
a1000 1
  devn = get_device_number (src_path, "", unit);
d1007 23
a1029 4
  if (devn == FH_RANDOM)
    __small_sprintf (win32_path, devfmt, unit == 8 ? "" : "u");
  else
    __small_sprintf (win32_path, devfmt, unit);
d1441 1
a1441 1
  devn =  get_device_number (src_path, dst, unit);
@


1.173
log
@* fhandler.cc (fhandler_base::fork_fixup): Don't protect handle.
* dlfcn.cc: Fix to confirm to coding standards.  Reorganize includes throughout
to accomodate new cygheap.h usage.
* cygheap.h (cygheap_fdmanip): New class: simplifies locking and retrieval of
fds from cygheap->fdtab.
(cygheap_fdget): Ditto.
(cygheap_fdnew): Ditto.
* fcntl.cc (_fcntl): Use new method to lock fdtab and retrieve info.
* ioctl.cc (ioctl): Ditto.
* mmap.cc (mmap): Ditto.
* net.cc: Ditto, throughout.
* passwd.cc (getpass): Ditto.
* path.cc (fchdir): Ditto.
* pipe.cc (make_pipe): Ditto.
* sec_acl.cc (facl): Ditto.
* syscalls.cc: Ditto, throughout.
* termios.cc: Ditto, throughout.
@
text
@d2316 1
a2316 2
extern "C"
int
d2341 1
a2341 2
extern "C"
int
d2351 1
a2351 2
extern "C"
int
d2372 1
a2372 2
extern "C"
FILE *
d2380 1
a2380 2
extern "C"
struct mntent *
d2386 1
a2386 2
extern "C"
int
d2422 1
a2422 2
extern "C"
int
d2910 1
a2910 2
extern "C"
int
d3028 1
a3028 2
extern "C"
char *
d3126 1
a3126 2
extern "C"
int
d3147 1
a3147 2
extern "C"
int
d3161 1
a3161 2
extern "C"
int
d3177 1
a3177 2
extern "C"
int
d3186 1
a3186 2
extern "C"
int
d3197 1
a3197 2
extern "C"
char *
d3237 1
a3237 2
extern "C"
int
d3278 1
a3278 2
extern "C"
int
d3284 1
a3284 2
extern "C"
int
d3290 1
a3290 2
extern "C"
int
d3297 1
a3297 2
extern "C"
int
d3323 1
a3323 2
extern "C"
void
@


1.172
log
@* dtable.cc (dtable::build_fhandler_from_name): Use PC_FULL to determine path
name.
* fork.cc (fork_parent): Correct the "unable to allocate forker_finished event"
error message.  It named the wrong event before.
@
text
@d3139 1
d3142 8
a3149 11
  if (cygheap->fdtab.not_open (fd))
    {
      syscall_printf ("-1 = fchdir (%d)", fd);
      set_errno (EBADF);
      return -1;
    }
  SetResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "fchdir");
  int ret = chdir (cygheap->fdtab[fd]->get_name ());
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "fchdir");
  syscall_printf ("%d = fchdir (%d)", ret, fd);
  return ret;
@


1.171
log
@* fhandler_dsp.cc (fhandler_dsp::ioctl): Return 0 for successful
SNDCTL_DSP_GETBLKSIZE operation.  Remove obsolete 'name' arg from fhandler_*
constructors throughout.
* winsup.h (winsock_active): New macro.
(winsock2_active): Ditto.
* autoload.cc (wsock_init): Use new macros to decide if winsock or winsock2 is
loaded.
(nonexist_wsock32): Dummy function to force winsock load.
(nonexist_ws2_32): Dummy function to force winsock2 load.
* fhandler.h (fhandler_socket::fstat): Declare new method.  Currently unused.
* fhandler_socket.cc (fhandler_socket::fixup_before_fork_exec): Check that
winsock2 is active before trying WSADuplicateSocketA.
(fhandler_socket::fixup_after_fork): Add extra check for winsock2_active.
Otherwise use iffy procedures for Windows 95.
(fhandler_socket::fixup_after_exec): Add debugging.
(fhandler_socket::dup): Add debugging.
(fhandler_socket::fstat): New method.
(fhandler_socket::set_close_on_exec): Attempt to perform iffy stuff on Windows
95.
* errno.cc (_sys_nerr): Work around compiler strangeness.
* pinfo.cc (winpids::add): Add extra element at end of allocated array for
setting to NULL.
(winpids::enumNT): Ditto.
(winpids::init): Don't modify pidlist if it hasn't been allocated
(possibly due to malloc problem).
@
text
@a3148 16
  if (ret == 0)
    {
      /* The name in the fhandler is explicitely overwritten with the full path.
	 Otherwise fchmod() to a path originally given as a relative path could
	 end up in a completely different directory. Imagine:

	   fd = open ("..");
	   fchmod(fd);
	   fchmod(fd);

	 The 2nd fchmod should chdir to the same dir as the first call, not
	 to it's parent dir. */
      char posix_path[MAX_PATH];
      cygheap->fdtab.reset_unix_path_name (fd, cygheap->cwd.get (posix_path, 1, 1));
    }

@


1.170
log
@* path.cc (normalize_posix_path): Don't eat a '.' after a '\\' since it has
special meaning on NT.
* syscalls.cc (access): Use stat_worker.
@
text
@d704 4
@


1.169
log
@* path.cc (get_raw_device_number): Correct length arguments for wdeveqn.
@
text
@d212 6
d943 7
a949 1
      ++src;
@


1.168
log
@* path.cc (getcwd): Allow NULL first argument.
@
text
@d852 1
a852 1
  if (wdeveqn ("tape", 8))
d865 1
a865 1
  else if (wdeveqn ("physicaldrive", 17))
@


1.167
log
@* path.cc (path_conv::check): Return ENOTDIR when leading device and trailing
component.
@
text
@d3014 1
a3014 1
  else if (!__check_null_invalid_struct_errno (buf, ulen))
@


1.166
log
@* syscalls.cc (stat_worker): Make global.  Accept path_conv parameter for
passing information back to caller.
* winsup.h: Declare stat_worker.
* dir.cc (opendir): Use stat_worker rather than stat and pass path_conv
parameter to stat_worker for later inspection.
* syslog.cc (syslog): Teach syslog about syslog priorities other than LOG_ERR,
LOG_WARNING and LOG_INFO
* path.cc (path_conv::check): Don't perform file system or rootdir checks on
devices.
@
text
@d477 5
@


1.165
log
@* dcrt0.cc (dll_crt0_1): Don't close hexec_proc if it is NULL.
* fork.cc (vfork): Add debugging statements.
* path.cc (get_device_number): Make static.  Rewrite to inspect both unix and
windows paths.
(get_raw_device_number): Just check for parts of raw device that we care about.
(get_devn): New function, pulled from get_device_number.
(win32_device_name): Accomodate arg changes to get_device_number.
(mount_info::get_device_number): Call get_device_number on translated Windows
path.
* spawn.cc (spawn_guts): Don't treat P_VFORK differently from P_NOWAIT.  Add
handle to child's shared region to child so that it will be preserved if the
parent goes away.
* fhandler.h: Throughout, simplify to one open method for all fhandler classes,
requiring a path_conv first element.
* fhandler.cc (fhandler_base::open): Remove obsolete method.  Generalize to
require path_conv * as first argument.
(fhandler_disk_file::open): Remove obsolete method.
(fhandler_disk_file::open): Use path_conv pointer rather than reference.
* fhandler_clipboard.cc (fhandler_dev_clipboard::dup): Use new open method.
(fhandler_dev_clipboard::open): Accomodate new argument for open methods.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::dup): Use new open method.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Accomodate new argument for open
methods.
* fhandler_floppy.cc (fhandler_dev_floppy::open): Ditto.
* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
* fhandler_random (fhandler_dev_random::open): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Ditto.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* fhandler_tape.cc (fhandler_dev_tape::open): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Accomodate new
argument for open methods.
* syscalls.cc (_open): Ditto.
(stat_worker): Ditto.
@
text
@a473 2
	  update_fs_info (full_path);

d481 2
d671 1
a671 2
  update_fs_info (path);
  if (!fs_name[0])
d673 6
a678 10
      set_has_acls (FALSE);
      set_has_buggy_open (FALSE);
    }
  else
    {
      set_isdisk ();
      debug_printf ("root_dir(%s), this->path(%s), set_has_acls(%d)",
		    root_dir, this->path, fs_flags & FS_PERSISTENT_ACLS);
      if (!allow_smbntsec && is_remote_drive)
	set_has_acls (FALSE);
d680 12
a691 4
	set_has_acls (fs_flags & FS_PERSISTENT_ACLS);
      /* Known file systems with buggy open calls. Further explanation
	 in fhandler.cc (fhandler_disk_file::open). */
      set_has_buggy_open (strcmp (fs_name, "SUNWNFS") == 0);
@


1.164
log
@Add "path.h" include throughout, where needed.  Use new path_conv methods and
operators to simplify testing for directory and attributes, throughout.
* path.h (path_conv::exists): New method.
(path_conv::has_attribute): Ditto.
(path_conv::isdir): Ditto.
(path_conv::DWORD &): New operator.
(path_conv::int &): Ditto.
* dir.cc (rmdir): Eliminate a goto.
* dtable.cc (dtable::build_fhandler): Accept opt and suffix info for
path_conv.check.  Return fh == NULL on path_conv error.  Pass unit to set_name
as appropriate.
(dtable::reset_unix_path_name): New method.
* dtable.h (dtable): Declare new method.  Reflect arg changes to
build_fhandler.
* fhandler.cc (fhandler_disk_dummy_name): Eliminate.
(fhandler_base::set_name): Expect paths to be NULL.  Build unix_path_name from
win32_path_name when it is a device.
(fhandler_base::reset_unix_path_name): New method.
(fhandler_base::raw_read): Report EISDIR when ERROR_INVALID_FUNCTION or
ERROR_INVALID_PARAMETER and reading a directory.
(fhandler_disk_file::fstat): Don't call stat_dev since we should now never be
calling fhandler_disk_file methods with devices.
(fhandler_base::fhandler_base): Clear {unix,win32}_path_name.
(fhandler_base::~fhandler_base): Always free {unix,win32}_path_name.
(fhandler_disk_file::fhandler_disk_file): Remove set_no_free_names kludge.
(fhandler_disk_file::open): Ditto.
* fhandler.h (fhandler_base::no_free_names): Eliminate.
(fhandler_base::set_no_free_names): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Don't set
unix_path_name here.
* path.cc (fchdir): Lock fd table throughout.  Use new
dtable::reset_unix_path_name method to reset path.
* syscalls.cc (stat_worker): Reorganize to always call fstat method.  Pass
path_conv method to fhandler_*::open.
(chroot): Elminate a goto.
@
text
@a730 3
#define deveq(s) (strcasematch (name, (s)))
#define deveqn(s, n) (strncasematch (name, (s), (n)))

d769 70
d840 1
a840 1
get_raw_device_number (const char *uxname, const char *w32path, int &unit)
d842 3
a844 3
  DWORD devn = FH_BAD;

  if (strncasematch (w32path, "\\\\.\\tape", 8))
d846 1
a846 2
      devn = FH_TAPE;
      unit = digits (w32path + 8);
d848 1
a848 1
      if (strncasematch (uxname, "/dev/n", 6))
d850 1
d852 1
a852 1
  else if (isdrive (w32path + 4))
d854 1
a855 1
      unit = cyg_tolower (w32path[4]) - 'a';
d857 1
a857 1
  else if (strncasematch (w32path, "\\\\.\\physicaldrive", 17))
d859 1
a860 1
      unit = digits (w32path + 17) + 128;
d862 2
d867 5
a871 2
int __stdcall
get_device_number (const char *name, int &unit, BOOL from_conv)
d876 6
a881 67
  if ((*name == '/' && deveqn ("/dev/", 5)) ||
      (*name == '\\' && deveqn ("\\dev\\", 5)))
    {
      name += 5;
      if (deveq ("tty"))
	{
	  if (real_tty_attached (myself))
	    {
	      unit = myself->ctty;
	      devn = FH_TTYS;
	    }
	  else if (myself->ctty > 0)
	    devn = FH_CONSOLE;
	}
      else if (deveqn ("tty", 3) && (unit = digits (name + 3)) >= 0)
	devn = FH_TTYS;
      else if (deveq ("ttym"))
	devn = FH_TTYM;
      else if (deveq ("ptmx"))
	devn = FH_PTYM;
      else if (deveq ("windows"))
	devn = FH_WINDOWS;
      else if (deveq ("dsp"))
	devn = FH_OSS_DSP;
      else if (deveq ("conin"))
	devn = FH_CONIN;
      else if (deveq ("conout"))
	devn = FH_CONOUT;
      else if (deveq ("null"))
	devn = FH_NULL;
      else if (deveq ("zero"))
	devn = FH_ZERO;
      else if (deveq ("random") || deveq ("urandom"))
	{
	  devn = FH_RANDOM;
	  unit = 8 + (deveqn ("u", 1) ? 1 : 0); /* Keep unit Linux conformant */
	}
      else if (deveq ("mem"))
	{
	  devn = FH_MEM;
	  unit = 1;
	}
      else if (deveq ("clipboard"))
	devn = FH_CLIPBOARD;
      else if (deveq ("port"))
	{
	  devn = FH_MEM;
	  unit = 4;
	}
      else if (deveqn ("com", 3) && (unit = digits (name + 3)) >= 0)
	devn = FH_SERIAL;
      else if (deveqn ("ttyS", 4) && (unit = digits (name + 4)) >= 0)
	devn = FH_SERIAL;
      else if (deveq ("pipe") || deveq ("piper") || deveq ("pipew"))
	devn = FH_PIPE;
      else if (deveq ("tcp") || deveq ("udp") || deveq ("streamsocket")
	       || deveq ("dgsocket"))
	devn = FH_SOCKET;
      else if (!from_conv)
	devn = get_raw_device_number (name - 5,
				      path_conv (name - 5,
						 PC_SYM_IGNORE).get_win32 (),
				      unit);
    }
  else if (deveqn ("com", 3) && (unit = digits (name + 3)) >= 0)
    devn = FH_SERIAL;
  else if (deveqn ("ttyS", 4) && (unit = digits (name + 4)) >= 0)
d883 2
d898 1
a898 1
  devn = get_device_number (src_path, unit, TRUE);
d1313 2
@


1.163
log
@* path.cc (symlink): Check arguments for validity.
(getcwd): Ditto.
* syscalls.cc (ftruncate): Ditto.
* times.cc (times): Ditto.
* uname.cc (uname): Ditto.
@
text
@d2431 1
a2431 2
  if (win32_path.is_device () ||
      win32_path.file_attributes () != (DWORD) -1)
d2899 1
a2899 1
  if (pathbuf.file_attributes () == (DWORD) -1)
d3108 1
d3110 1
a3110 1
  if (!ret)
a3121 1
      char path[MAX_PATH];
d3123 1
a3123 3
      mount_table->conv_to_posix_path (cygheap->cwd.get (path, 0, 1),
				       posix_path, 0);
      cygheap->fdtab[fd]->set_name (path, posix_path);
d3126 1
@


1.163.2.1
log
@Merged changes from HEAD
@
text
@d2431 2
a2432 1
  if (win32_path.is_device () || win32_path.exists ())
d2900 1
a2900 1
  if (!pathbuf.exists ())
a3108 1
  SetResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "fchdir");
d3110 1
a3110 1
  if (ret == 0)
d3122 1
d3124 3
a3126 1
      cygheap->fdtab.reset_unix_path_name (fd, cygheap->cwd.get (posix_path, 1, 1));
a3128 1
  ReleaseResourceLock (LOCK_FD_LIST, WRITE_LOCK | READ_LOCK, "fchdir");
@


1.163.2.2
log
@Merged changes from HEAD
@
text
@d103 1
a103 1
  bool case_clash;
a109 2
#define CYGWIN_REGNAME (cygheap->cygwin_regname ?: CYGWIN_INFO_CYGWIN_REGISTRY_NAME)

d115 1
a115 1
  (isalpha(path[mount_table->cygdrive_len]) && \
a211 6
      else if (src[0] == '.' && isslash (src[1]))
	{
	  *dst++ = '.';
	  *dst++ = '/';
	  src += 2;
	}
d396 1
a396 1
  case_clash = false;
d474 2
a475 11
	  if (devn == FH_CYGDRIVE)
	    {
	      if (!component)
		fileattr = FILE_ATTRIBUTE_DIRECTORY;
	      else
		{
		  devn = FH_BAD;
		  fileattr = GetFileAttributes (this->path);
		}
	      goto out;
	    }
d477 1
a477 1
	  else if (devn != FH_BAD)
a479 5
	      if (component)
		{
		  error = ENOTDIR;
		  return;
		}
a482 2
	  update_fs_info (full_path);

d486 3
a488 4
	  /* If path is only a drivename, Windows interprets it as the
	     current working directory on this drive instead of the root
	     dir which is what we want. So we need the trailing backslash
	     in this case. */
d500 1
a500 1
	      fileattr = GetFileAttributes (this->path);
d521 1
d671 7
a677 1
  if (devn == FH_BAD)
d679 5
a683 6
      update_fs_info (path);
      if (!fs_name[0])
	{
	  set_has_acls (false);
	  set_has_buggy_open (false);
	}
d685 4
a688 12
	{
	  set_isdisk ();
	  debug_printf ("root_dir(%s), this->path(%s), set_has_acls(%d)",
			root_dir, this->path, fs_flags & FS_PERSISTENT_ACLS);
	  if (!allow_smbntsec && is_remote_drive)
	    set_has_acls (false);
	  else
	    set_has_acls (fs_flags & FS_PERSISTENT_ACLS);
	  /* Known file systems with buggy open calls. Further explanation
	     in fhandler.cc (fhandler_disk_file::open). */
	  set_has_buggy_open (strcmp (fs_name, "SUNWNFS") == 0);
	}
a689 4
#if 0
  if (issocket ())
    devn = FH_SOCKET;
#endif
d731 3
a771 114
#define deveq(s) (strcasematch (name, (s)))
#define deveqn(s, n) (strncasematch (name, (s), (n)))
#define wdeveq(s) (strcasematch (w32_path, (s)))
#define wdeveqn(s, n) (strncasematch (w32_path, (s), (n)))
#define udeveq(s) (strcasematch (unix_path, (s)))
#define udeveqn(s, n) (strncasematch (unix_path, (s), (n)))

static int __stdcall
get_devn (const char *name, int &unit)
{
  int devn = FH_BAD;
  name += 5;
  if (deveq ("tty"))
    {
      if (real_tty_attached (myself))
	{
	  unit = myself->ctty;
	  devn = FH_TTYS;
	}
      else if (myself->ctty > 0)
	devn = FH_CONSOLE;
    }
  else if (deveqn ("tty", 3) && (unit = digits (name + 3)) >= 0)
    devn = FH_TTYS;
  else if (deveq ("ttym"))
    devn = FH_TTYM;
  else if (deveq ("ptmx"))
    devn = FH_PTYM;
  else if (deveq ("windows"))
    devn = FH_WINDOWS;
  else if (deveq ("dsp"))
    devn = FH_OSS_DSP;
  else if (deveq ("conin"))
    devn = FH_CONIN;
  else if (deveq ("conout"))
    devn = FH_CONOUT;
  else if (deveq ("null"))
    devn = FH_NULL;
  else if (deveq ("zero"))
    devn = FH_ZERO;
  else if (deveq ("random") || deveq ("urandom"))
    {
      devn = FH_RANDOM;
      unit = 8 + (deveqn ("u", 1) ? 1 : 0); /* Keep unit Linux conformant */
    }
  else if (deveq ("mem"))
    {
      devn = FH_MEM;
      unit = 1;
    }
  else if (deveq ("clipboard"))
    devn = FH_CLIPBOARD;
  else if (deveq ("port"))
    {
      devn = FH_MEM;
      unit = 4;
    }
  else if (deveqn ("com", 3) && (unit = digits (name + 3)) >= 0)
    devn = FH_SERIAL;
  else if (deveqn ("ttyS", 4) && (unit = digits (name + 4)) >= 0)
    {
      devn = FH_SERIAL;
      unit++;
    }
  else if (deveq ("pipe"))
    devn = FH_PIPE;
  else if (deveq ("piper"))
    devn = FH_PIPER;
  else if (deveq ("pipew"))
    devn = FH_PIPEW;
  else if (deveq ("tcp") || deveq ("udp") || deveq ("streamsocket")
	   || deveq ("dgsocket"))
    devn = FH_SOCKET;

  return devn;
}

/*
    major      minor    POSIX filename	NT filename
    -----      -----	--------------	-------------------------
    FH_TAPE	  0	/dev/st0	\device\tape0
    FH_TAPE	  1	/dev/st1	\device\tape1
    ...
    FH_TAPE	128	/dev/nst0	\device\tape0
    FH_TAPE	129	/dev/nst1	\device\tape1
    ...

    FH_FLOPPY     0	/dev/fd0	\device\floppy0
    FH_FLOPPY	  1	/dev/fd1	\device\floppy1
    ...

    FH_FLOPPY	 16	/dev/scd0	\device\cdrom0
    FH_FLOPPY	 17	/dev/scd0	\device\cdrom1
    ...

    FH_FLOPPY	 32	/dev/sda	\device\harddisk0\partition0
    FH_FLOPPY	 33	/dev/sda1	\device\harddisk0\partition1
    ...
    FH_FLOPPY	 47	/dev/sda15	\device\harddisk0\partition15

    FH_FLOPPY	 48	/dev/sdb	\device\harddisk1\partition0
    FH_FLOPPY    33     /dev/sdb1       \device\harddisk1\partition1
    ...
    FH_FLOPPY	208	/dev/sdl	\device\harddisk11\partition0
    ...
    FH_FLOPPY	223	/dev/sdl15	\device\harddisk11\partition15

    The following are needed to maintain backward compatibility with
    the old Win32 partitioning scheme on W2K/XP.

    FH_FLOPPY	224	from mount tab	\\.\A:
    ...
    FH_FLOPPY	250	from mount tab	\\.\Z:
*/
d773 1
a773 1
get_raw_device_number (const char *name, const char *w32_path, int &unit)
d777 1
a777 1
  if (!w32_path)  /* New approach using fixed device names. */
d779 10
a788 40
      if (deveqn ("st", 2))
	{
	  unit = digits (name + 2);
	  if (unit >= 0 && unit < 128)
	    devn = FH_TAPE;
	}
      else if (deveqn ("nst", 3))
	{
	  unit = digits (name + 3) + 128;
	  if (unit >= 128 && unit < 256)
	    devn = FH_TAPE;
	}
      else if (deveqn ("fd", 2))
	{
	  unit = digits (name + 2);
	  if (unit >= 0 && unit < 16)
	    devn = FH_FLOPPY;
	}
      else if (deveqn ("scd", 3))
	{
	  unit = digits (name + 3) + 16;
	  if (unit >= 16 && unit < 32)
	    devn = FH_FLOPPY;
	}
      else if (deveqn ("sd", 2) && isalpha (name[2]))
	{
	  unit = (cyg_tolower (name[2]) - 'a') * 16 + 32;
	  if (unit >= 32 && unit < 224)
	    if (!name[3])
	      devn = FH_FLOPPY;
	    else
	      {
		int d = digits (name + 3);
		if (d >= 1 && d < 16)
		  {
		    unit += d;
		    devn = FH_FLOPPY;
		  }
	      }
	}
d790 1
a790 1
  else /* Backward compatible checking of mount table device mapping. */
d792 2
a793 18
      if (wdeveqn ("tape", 4))
	{
	  unit = digits (w32_path + 4);
	  /* Norewind tape devices have leading n in name. */
	  if (deveqn ("n", 1))
	    unit += 128;
	  devn = FH_TAPE;
	}
      else if (wdeveqn ("physicaldrive", 13))
	{
	  unit = digits (w32_path + 13) * 16 + 32;
	  devn = FH_FLOPPY;
	}
      else if (isdrive (w32_path))
	{
	  unit = cyg_tolower (w32_path[0]) - 'a' + 224;
	  devn = FH_FLOPPY;
	}
d798 2
a799 5
static int __stdcall get_device_number (const char *unix_path,
					const char *w32_path, int &unit)
  __attribute__ ((regparm(3)));
static int __stdcall
get_device_number (const char *unix_path, const char *w32_path, int &unit)
d804 2
a805 1
  if (*unix_path == '/' && udeveqn ("/dev/", 5))
d807 49
a855 15
      devn = get_devn (unix_path, unit);
      if (devn == FH_BAD && *w32_path == '\\' && wdeveqn ("\\dev\\", 5))
	devn = get_devn (w32_path, unit);
      if (devn == FH_BAD && wdeveqn ("\\\\.\\", 4))
	devn = get_raw_device_number (unix_path + 5, w32_path + 4, unit);
      if (devn == FH_BAD)
	devn = get_raw_device_number (unix_path + 5, NULL, unit);
    }
  else
    {
      char *p = strrchr (unix_path, '/');
      if (p)
	unix_path = p + 1;
      if (udeveqn ("com", 3)
	 && (unit = digits (unix_path + 3)) >= 0)
d857 10
d868 4
d885 1
a885 1
  devn = get_device_number (src_path, win32_path, unit);
d888 1
a888 1
    return false;
d891 5
a895 24
    return false;
  switch (devn)
    {
      case FH_RANDOM:
	__small_sprintf (win32_path, devfmt, unit == 8 ? "" : "u");
	break;
      case FH_TAPE:
	__small_sprintf (win32_path, "\\Device\\Tape%d", unit % 128);
	break;
      case FH_FLOPPY:
	if (unit < 16)
	  __small_sprintf (win32_path, "\\Device\\Floppy%d", unit);
	else if (unit < 32)
	  __small_sprintf (win32_path, "\\Device\\CdRom%d", unit - 16);
	else if (unit < 224)
	  __small_sprintf (win32_path, "\\Device\\Harddisk%d\\Partition%d",
				       (unit - 32) / 16, unit % 16);
	else
	  __small_sprintf (win32_path, "\\DosDevices\\%c:", unit - 224 + 'A');
	break;
      default:
	__small_sprintf (win32_path, devfmt, unit);
	break;
    }
d916 1
a916 7
      src++;
      if (src[1] == '.' && isdirsep (src[2]))
	{
	  *dst++ = '\\';
	  *dst++ = '.';
	  src += 2;
	}
d1086 1
a1086 3
  char *srcbuf = (char *) alloca (strlen (src) + 1);

  for (;;)
d1088 15
a1102 9
      s = strccpy (srcbuf, &src, src_delim);
      int len = s - srcbuf;
      if (len >= MAX_PATH)
	srcbuf[MAX_PATH - 1] = '\0';
      (*conv_fn) (len ? srcbuf : ".", d);
      if (!*src++)
	break;
      d = strchr (d, '\0');
      *d++ = dst_delim;
d1104 1
d1227 1
a1227 1
  if (iscygdrive (pathbuf))
d1229 1
a1229 15
      int n = mount_table->cygdrive_len - 1;
      if (!pathbuf[n] ||
	  (pathbuf[n] == '/' && pathbuf[n + 1] == '.' && !pathbuf[n + 2]))
	{
	  unit = 0;
	  dst[0] = '\0';
	  if (mount_table->cygdrive_len > 1)
	    devn = FH_CYGDRIVE;
	}
      else if (cygdrive_win32_path (pathbuf, dst, unit))
	{
	  *flags = cygdrive_flags;
	  goto out;
	}
      else if (mount_table->cygdrive_len > 1)
d1231 2
a1300 3
  if (devn != FH_CYGDRIVE)
    win32_device_name (src_path, dst, devn, unit);

d1348 1
a1348 1
mount_info::cygdrive_win32_path (const char *src, char *dst, int& unit)
a1349 1
  int res;
d1352 5
a1356 14
    {
      unit = -1;
      dst[0] = '\0';
      res = 0;
    }
  else
    {
      dst[0] = cyg_tolower (*p);
      dst[1] = ':';
      strcpy (dst + 2, p + 1);
      backslashify (dst, dst, !dst[2]);
      unit = dst[0];
      res = 1;
    }
d1358 1
a1358 1
  return res;
d1545 1
a1545 1
      res = mount_table->add_item (native_path, posix_path, mount_flags, false);
d1572 2
a1573 1
	      CYGWIN_INFO_CYGNUS_REGISTRY_NAME, CYGWIN_REGNAME,
d1618 2
a1619 1
		       CYGWIN_INFO_CYGNUS_REGISTRY_NAME, CYGWIN_REGNAME,
d1667 2
a1668 1
		       CYGWIN_INFO_CYGNUS_REGISTRY_NAME, CYGWIN_REGNAME,
d1693 2
a1694 1
  if (r.get_string (CYGWIN_INFO_CYGDRIVE_PREFIX, cygdrive, sizeof (cygdrive), "") != 0)
d1700 2
a1701 1
		 CYGWIN_INFO_CYGNUS_REGISTRY_NAME, CYGWIN_REGNAME,
d1705 16
a1720 6
      if (r2.get_string (CYGWIN_INFO_CYGDRIVE_PREFIX, cygdrive,
	  sizeof (cygdrive), ""))
	strcpy (cygdrive, CYGWIN_INFO_CYGDRIVE_DEFAULT_PREFIX);
      cygdrive_flags = r2.get_int (CYGWIN_INFO_CYGDRIVE_FLAGS, MOUNT_AUTO);
      slashify (cygdrive, cygdrive, 1);
      cygdrive_len = strlen (cygdrive);
d1751 2
a1752 1
	     CYGWIN_INFO_CYGNUS_REGISTRY_NAME, CYGWIN_REGNAME,
d1808 2
a1809 1
	     CYGWIN_INFO_CYGNUS_REGISTRY_NAME, CYGWIN_REGNAME,
d1841 2
a1842 1
	      CYGWIN_INFO_CYGNUS_REGISTRY_NAME, CYGWIN_REGNAME,
d2026 1
a2026 1
  int posix_path_p = false;
d2163 1
a2163 1
      int drivenum = cyg_tolower (native_path[0]) - 'a';
d2277 2
a2278 1
extern "C" int
d2303 2
a2304 1
extern "C" int
d2314 2
a2315 1
extern "C" int
d2336 2
a2337 1
extern "C" FILE *
d2345 2
a2346 1
extern "C" struct mntent *
d2352 2
a2353 1
extern "C" int
d2378 1
a2378 1
      return false;
d2385 1
a2385 1
/* If TRUE create symlinks as Windows shortcuts, if false create symlinks
d2389 2
a2390 1
extern "C" int
d2404 1
a2404 1
     symlink contents point to existing filesystem object */
d2468 1
a2468 1
  		  CREATE_NEW, FILE_ATTRIBUTE_NORMAL, 0);
d2470 1
a2470 1
    __seterrno ();
d2514 3
a2516 10

	  DWORD attr = allow_winsymlinks ? FILE_ATTRIBUTE_READONLY
	  				 : FILE_ATTRIBUTE_SYSTEM;
#ifdef HIDDEN_DOT_FILES
	  cp = strrchr (win32_path, '\\');
	  if ((cp && cp[1] == '.') || *win32_path == '.')
	    attr |= FILE_ATTRIBUTE_HIDDEN;
#endif
	  SetFileAttributes (win32_path.get_win32 (), attr);

d2739 1
a2739 1
  case_clash = false;
d2744 1
a2744 1
      fileattr = GetFileAttributes (suffix.path);
d2747 1
a2747 1
	  /* The GetFileAttributes call can fail for reasons that don't
d2750 1
a2750 1
	  debug_printf ("GetFileAttributes (%s) failed", suffix.path);
d2823 1
a2823 1
      is_symlink = false;
d2836 1
a2836 1
   false if pcheck_case == PCHECK_STRICT.
d2866 1
a2866 1
	    return false;
d2878 2
a2879 1
extern "C" int
d2989 1
a2989 1
  if (ulen == 0 && buf)
d2991 1
a2991 1
  else if (buf == NULL || !__check_null_invalid_struct_errno (buf, ulen))
d2997 2
a2998 1
extern "C" char *
d3057 1
a3057 1
  const char *native_dir = path.get_win32 ();
d3065 2
a3066 10
      path.get_win32 ()[2] = '\\';
      path.get_win32 ()[3] = '\0';
    }
  int res;
  if (path.get_devn () != FH_CYGDRIVE)
    res = SetCurrentDirectory (native_dir) ? 0 : -1;
  else
    {
      native_dir = "c:\\";
      res = 0;
d3068 1
d3084 1
a3084 1
    cygheap->cwd.set (native_dir, dir);
d3086 1
a3086 1
    cygheap->cwd.set (native_dir, NULL);
d3096 2
a3097 1
extern "C" int
a3099 1
  int res;
d3102 23
a3124 5
  cygheap_fdget cfd (fd);
  if (cfd >= 0)
    res = chdir (cfd->get_name ());
  else
    res = -1;
d3126 3
a3128 2
  syscall_printf ("%d = fchdir (%d)", res, fd);
  return res;
d3136 2
a3137 1
extern "C" int
a3142 1
      win32_path[0] = '\0';
d3147 1
a3147 1
  strcpy (win32_path, p);
d3151 2
a3152 1
extern "C" int
a3157 1
      win32_path[0] = '\0';
d3162 1
a3162 1
  strcpy (win32_path, p);
d3168 2
a3169 1
extern "C" int
d3178 2
a3179 1
extern "C" int
d3190 2
a3191 1
extern "C" char *
d3231 2
a3232 1
extern "C" int
d3273 2
a3274 1
extern "C" int
d3280 2
a3281 1
extern "C" int
d3287 2
a3288 1
extern "C" int
d3295 2
a3296 1
extern "C" int
d3322 2
a3323 1
extern "C" void
d3403 1
a3403 1
  lock = new_muto (false, "cwd");
@


1.163.2.3
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d403 1
a403 1
  fileattr = INVALID_FILE_ATTRIBUTES;
d554 1
a554 1
	      if (!sym.is_symlink && sym.fileattr != INVALID_FILE_ATTRIBUTES)
d2400 1
a2400 1
	  GetFileAttributes (native_path) == INVALID_FILE_ATTRIBUTES)
d2612 1
a2612 1
      if (!cp || GetFileAttributes (w32topath) == INVALID_FILE_ATTRIBUTES)
d2914 1
a2914 1
      if (fileattr == INVALID_FILE_ATTRIBUTES)
d2981 1
a2981 1
	  fileattr = INVALID_FILE_ATTRIBUTES;
d3075 1
a3075 1
      if (pathbuf.fileattr != INVALID_FILE_ATTRIBUTES)
@


1.163.2.4
log
@Merged changes from HEAD
@
text
@d3278 1
a3278 1
    res = chdir (cfd->get_win32_name ());
@


1.163.2.5
log
@Merged changes from HEAD
@
text
@d2578 1
a2578 1
  if (allow_winsymlinks && !win32_path.exists ())
d3539 1
a3539 1
  cwd_lock->acquire ();
d3541 1
a3541 1
  cwd_lock->release ();
d3549 1
a3549 1
  new_muto (cwd_lock);
d3557 1
a3557 1
  cwd_lock->acquire ();
d3574 1
a3574 1
      cwd_lock->release ();
d3576 1
a3576 1
      cwd_lock->release ();
d3593 1
a3593 1
      cwd_lock->acquire ();
d3609 1
a3609 1
    cwd_lock->release ();
d3654 1
a3654 1
  cwd_lock->release ();
@


1.163.2.6
log
@Merged changes from HEAD
@
text
@d55 1
d67 1
a120 6
#define isproc(path) \
  (path_prefix_p (proc, (path), proc_len))

#define isvirtual_dev(devn) \
  (devn == FH_CYGDRIVE || devn == FH_PROC || devn == FH_REGISTRY || devn == FH_PROCESS)

d176 1
a176 1
static int
d252 1
a252 5
		{
		  if (src[2] == '.')
		    return ENOENT;
		  break;
		}
d317 2
a318 2
bool
fs_info::update (const char *win32_path)
d326 4
a329 3
      name [0] = '\0';
      sym_opt = flags = serial = 0;
      return false;
d332 8
a339 2
  if (strcmp (tmp_buf, root_dir) == 0)
    return 1;
d341 17
a357 14
  strncpy (root_dir, tmp_buf, MAX_PATH);
  drive_type = GetDriveType (root_dir);
  if (drive_type == DRIVE_REMOTE || (drive_type == DRIVE_UNKNOWN && (root_dir[0] == '\\' && root_dir[1] == '\\')))
    is_remote_drive = 1;
  else
    is_remote_drive = 0;

  if (!GetVolumeInformation (root_dir, NULL, 0, &serial, NULL, &flags,
				 name, sizeof (name)))
    {
      debug_printf ("Cannot get volume information (%s), %E", root_dir);
      name [0] = '\0';
      sym_opt = flags = serial = 0;
      return false;
a358 16
  /* FIXME: Samba by default returns "NTFS" in file system name, but
   * doesn't support Extended Attributes. If there's some fast way to
   * distinguish between samba and real ntfs, it should be implemented
   * here.
   */
  sym_opt = (!is_remote_drive && strcmp (name, "NTFS") == 0) ? PC_CHECK_EA : 0;

  return true;
}

char *
path_conv::return_and_clear_normalized_path ()
{
  char *s = normalized_path;
  normalized_path = NULL;
  return s;
a360 17
void
path_conv::fillin (HANDLE h)
{
  BY_HANDLE_FILE_INFORMATION local;
  if (!GetFileInformationByHandle (h, &local))
    {
      fileattr = INVALID_FILE_ATTRIBUTES;
      fs.serial = 0;
    }
  else
    {
      fileattr = local.dwFileAttributes;
      fs.serial = local.dwVolumeSerialNumber;
    }
    fs.drive_type = DRIVE_UNKNOWN;
} 

a386 1
  char *tail;
d406 6
a411 7
  fs.root_dir[0] = '\0';
  fs.name[0] = '\0';
  fs.flags = fs.serial = 0;
  fs.sym_opt = 0;
  fs.drive_type = 0;
  fs.is_remote_drive = 0;
  normalized_path = NULL;
d441 1
a441 1
      tail = strchr (path_copy, '\0');   // Point to end of copy
a492 22
	  else if (isvirtual_dev (devn))
	    {
	      /* FIXME: Calling build_fhandler here is not the right way to handle this. */
	      fhandler_virtual *fh =
		(fhandler_virtual *) cygheap->fdtab.build_fhandler (-1, devn, (const char *) path_copy, NULL, unit);
	      int file_type = fh->exists ();
	      switch (file_type)
		{
		  case 1:
		  case 2:
		    fileattr = FILE_ATTRIBUTE_DIRECTORY;
		    break;
		  case -1:
		    fileattr = 0;
		    break;
		  default:
		    fileattr = INVALID_FILE_ATTRIBUTES;
		    break;
		}
	      delete fh;
	      goto out;
	    }
d505 1
a505 2
	  if (!fs.update (full_path))
	    fs.root_dir[0] = '\0';
d529 1
a529 1
	  int len = sym.check (full_path, suff, opt | fs.sym_opt);
a681 6
  if (opt & PC_POSIX)
    {
      if (tail[1] != '\0')
	*tail = '/';
      normalized_path = cstrdup (path_copy);
    }
d697 2
a698 1
      if (!fs.update (path))
a699 1
	  fs.root_dir[0] = '\0';
d707 2
a708 2
			fs.root_dir, this->path, fs.flags & FS_PERSISTENT_ACLS);
	  if (!allow_smbntsec && fs.is_remote_drive)
d711 1
a711 1
	    set_has_acls (fs.flags & FS_PERSISTENT_ACLS);
d714 1
a714 1
	  set_has_buggy_open (strcmp (fs.name, "SUNWNFS") == 0);
d743 1
a743 1
  if (!error && !isdir () && !(path_flags & PATH_ALL_EXEC))
d857 1
a857 1
  else if (deveqn ("com", 3) && (unit = digits (name + 3)) >= 0 && unit < 100)
d1011 1
a1011 1
	 && (unit = digits (unix_path + 3)) >= 0 && unit < 100)
d1233 8
a1240 1
/* conv_path_list: Convert a list of path names to/from Win32/POSIX. */
d1275 1
a1281 8
static void
set_flags (unsigned *flags, unsigned val)
{
  *flags = val;
  if (!(*flags & PATH_BINARY))
    *flags = PATH_TEXT;
}

d1344 1
a1344 1
      set_flags (flags, (unsigned) set_flags_from_win32_path (dst));
d1373 1
d1389 1
a1389 7
  if (isproc (pathbuf))
    {
      devn = fhandler_proc::get_proc_fhandler (pathbuf);
      if (devn == FH_BAD)
	return ENOENT;
    }
  else if (iscygdrive (pathbuf))
d1402 1
a1402 1
	  set_flags (flags, (unsigned) cygdrive_flags);
d1442 1
a1442 1
      set_flags (flags, PATH_BINARY);
d1472 1
a1472 1
      set_flags (flags, (unsigned) mi->flags);
d1475 1
a1475 1
  if (!isvirtual_dev (devn))
d1686 1
a1686 1
  return PATH_BINARY;
d1763 5
d1890 1
a1890 1
      cygdrive_flags = r2.get_int (CYGWIN_INFO_CYGDRIVE_FLAGS, MOUNT_CYGDRIVE);
d1896 1
a1896 1
      /* Fetch user cygdrive_flags from registry; returns MOUNT_CYGDRIVE on
d1898 1
a1898 1
      cygdrive_flags = r.get_int (CYGWIN_INFO_CYGDRIVE_FLAGS, MOUNT_CYGDRIVE);
d2005 1
a2005 1
      int flags = r.get_int (CYGWIN_INFO_CYGDRIVE_FLAGS, MOUNT_CYGDRIVE);
d2019 1
a2019 1
      int flags = r2.get_int (CYGWIN_INFO_CYGDRIVE_FLAGS, MOUNT_CYGDRIVE);
d2243 75
a2366 2
  else if (flags & MOUNT_NOTEXEC)
    strcat (_reent_winsup ()->mnt_opts, (char *) ",noexec");
d2368 1
a2368 1
  if ((flags & MOUNT_CYGDRIVE))		/* cygdrive */
d2451 1
a2451 1
  if (flags & MOUNT_CYGDRIVE) /* normal mount */
d2453 1
a2453 1
      /* When flags include MOUNT_CYGDRIVE, take this to mean that
d2486 1
a2486 1
  if (flags & MOUNT_CYGDRIVE)
d2488 1
a2488 1
      /* When flags include MOUNT_CYGDRIVE, take this to mean that we actually want
d2630 1
a2630 1
		  CREATE_NEW, FILE_ATTRIBUTE_NORMAL, 0);
d2678 1
a2678 1
					 : FILE_ATTRIBUTE_SYSTEM;
d3135 1
a3135 1
	  hash = (hash << 5) - hash + '\\';
d3145 2
a3146 1
      hash = (hash << 5) - hash + ch;
d3236 1
a3236 2
  int devn = path.get_devn();
  if (!isvirtual_dev (devn))
a3237 10
  else if (!path.exists ())
    {
      set_errno (ENOENT);
      return -1;
    }
  else if (!path.isdir ())
    {
      set_errno (ENOTDIR);
      return -1;
    }
d3244 1
a3244 1
  /* If res != 0, we didn't change to a new directory.
d3254 1
a3254 1
  if (res)
d3256 2
a3257 2
  else if ((!path.has_symlinks () && strpbrk (dir, ":\\") == NULL
	    && pcheck_case == PCHECK_RELAXED) || isvirtual_dev (devn))
@


1.163.2.7
log
@Merged changes from HEAD
@
text
@d1341 1
a1341 9
    {
      *flags |= PATH_TEXT;
      debug_printf ("flags: text (%p)", *flags & (PATH_TEXT | PATH_BINARY));
    }
  else
    {
      *flags |= PATH_BINARY;
      debug_printf ("flags: binary (%p)", *flags & (PATH_TEXT | PATH_BINARY));
    }
@


1.163.2.8
log
@Merged changes from HEAD
@
text
@a551 1
	      path_flags = sym.pflags;
@


1.163.2.9
log
@Merged changes from HEAD
@
text
@d2825 1
a2825 1
  for (;;)
a2826 35
      if (!suffixes)
	switch (nextstate)
	  {
	  case SCAN_BEG:
	    suffixes = suffixes_start;
	    if (!suffixes)
	      {
		nextstate = SCAN_LNK;
		return 1;
	      }
	    if (!*suffixes->name)
	      suffixes++;
	    nextstate = SCAN_EXTRALNK;
	    /* fall through to suffix checking below */
	    break;
	  case SCAN_HASLNK:
	    nextstate = SCAN_EXTRALNK;	/* Skip SCAN_BEG */
	    return 1;
	  case SCAN_LNK:
	  case SCAN_EXTRALNK:
	    strcpy (eopath, ".lnk");
	    nextstate = SCAN_DONE;
	    return 1;
	  case SCAN_JUSTCHECK:
	    nextstate = SCAN_APPENDLNK;
	    return 1;
	  case SCAN_APPENDLNK:
	    strcat (eopath, ".lnk");
	    nextstate = SCAN_DONE;
	    return 1;
	  default:
	    *eopath = '\0';
	    return 0;
	  }

d2839 33
@


1.163.2.10
log
@Merged changes from HEAD
@
text
@d450 1
d606 1
a606 4
		{
		  fileattr = sym.fileattr;
		  path_flags = sym.pflags;
		}
d615 4
a618 1
		    add_ext_from_sym (sym);
d636 1
d3075 1
a3075 1
      if (pathbuf.exists ())
@


1.163.2.11
log
@Merged changes from HEAD
@
text
@d77 1
a107 20
static char shortcut_header[SHORTCUT_HDR_SIZE];
static BOOL shortcut_initalized;

static void
create_shortcut_header (void)
{
  if (!shortcut_initalized)
    {
      shortcut_header[0] = 'L';
      shortcut_header[4] = '\001';
      shortcut_header[5] = '\024';
      shortcut_header[6] = '\002';
      shortcut_header[12] = '\300';
      shortcut_header[19] = 'F';
      shortcut_header[20] = '\f';
      shortcut_header[60] = '\001';
      shortcut_initalized = TRUE;
    }
}

d390 1
a390 1
}
d2625 1
a2625 1
  h = CreateFile (win32_path, GENERIC_WRITE, 0, &sa,
a2698 62
static BOOL
cmp_shortcut_header (const char *file_header)
{
  create_shortcut_header ();
  return memcmp (shortcut_header, file_header, SHORTCUT_HDR_SIZE);
}

static int
check_shortcut (const char *path, DWORD fileattr, HANDLE h,
		char *contents, int *error, unsigned *pflags)
{
  char file_header[SHORTCUT_HDR_SIZE];
  unsigned short len;
  int res = 0;
  DWORD got = 0;

  /* Valid Cygwin & U/WIN shortcuts are R/O. */
  if (!(fileattr & FILE_ATTRIBUTE_READONLY))
    goto file_not_symlink;
  /* Read the files header information. This is used to check for a
     Cygwin or U/WIN shortcut or later to check for executable files. */
  if (!ReadFile (h, file_header, SHORTCUT_HDR_SIZE, &got, 0))
    {
      *error = EIO;
      goto close_it;
    }
  /* Check header if the shortcut is really created by Cygwin or U/WIN. */
  if (got != SHORTCUT_HDR_SIZE || cmp_shortcut_header (file_header))
    goto file_not_symlink;
  /* Next 2 byte are USHORT, containing length of description entry. */
  if (!ReadFile (h, &len, sizeof len, &got, 0))
    {
      *error = EIO;
      goto close_it;
    }
  if (got != sizeof len || len == 0 || len > MAX_PATH)
    goto file_not_symlink;
  /* Now read description entry. */
  if (!ReadFile (h, contents, len, &got, 0))
    {
      *error = EIO;
      goto close_it;
    }
  if (got != len)
    goto file_not_symlink;
  contents[len] = '\0';
  res = len;
  if (res) /* It's a symlink.  */
    *pflags = PATH_SYMLINK;
  goto close_it;

file_not_symlink:
  /* Not a symlink, see if executable.  */
  if (!(*pflags & PATH_ALL_EXEC) && has_exec_chars (file_header, got))
    *pflags |= PATH_EXEC;

close_it:
  CloseHandle (h);
  return res;
}


d2959 2
a2960 2
      h = CreateFile (suffix.path, GENERIC_READ, FILE_SHARE_READ,
		      &sec_none_nih, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
@


1.163.2.12
log
@Merged changes from HEAD
@
text
@d134 2
a135 2
  (isalpha (path[mount_table->cygdrive_len]) && \
   (isdirsep (path[mount_table->cygdrive_len + 1]) || \
d846 1
a846 1
  int n = strtol (name, &p, 10);
d1988 1
a1988 1
      cygdrive_len = strlen (cygdrive);
d2046 1
a2046 1
      mount_table->cygdrive_len = strlen (mount_table->cygdrive);
d2337 1
a2337 1
  struct mntent &ret=_reent_winsup ()->mntbuf;
d3223 1
a3223 1
      int ch = cyg_tolower (*name);
d3314 1
a3314 1
  int devn = path.get_devn ();
d3728 1
a3728 1
  debug_printf ("posix %s", posix);
@


1.162
log
@* cygheap.h (init_cygheap): Move heap pointers here.
* include/sys/cygwin.h (perprocess): Remove heap pointers.
* dcrt0.cc (__cygwin_user_data): Reflect obsolete perprocess stuff.
(_dll_crt0): Don't initialize heap pointers.
(cygwin_dll_init): Ditto.
(release_upto): Use heap pointers from cygheap.
* heap.h: Ditto.
* fork.cc (fork_parent): Ditto.  Don't set heap pointers in ch.
(fork_child): Remove obsolete sigproc_fixup_after_fork.
* shared.cc (memory_init): Reorganize so that cygheap initialization is called
prior to regular heap since regular heap uses cygheap now.
* sigproc.cc (proc_subproc): Eliminate zombies allocation.
(sigproc_init): Move zombies alloation here.  Don't free up array on fork, just
reuse it.
(sigproc_fixup_after_fork): Eliminate.
* sigproc.h: Ditto.
* include/cygwin/version.h: Reflect change to perprocess structure.
@
text
@d2402 13
a2430 11
  if (topath[0] == 0)
    {
      set_errno (EINVAL);
      goto done;
    }
  if (strlen (topath) >= MAX_PATH)
    {
      set_errno (ENAMETOOLONG);
      goto done;
    }

d2989 6
a2994 1
  return cygheap->cwd.get (buf, 1, 1, ulen);
@


1.161
log
@Move appropriate variables to NO_COPY segment, throughout.
@
text
@d3118 1
a3118 1
				       posix_path, 0); 
@


1.160
log
@* cygheap.h (init_cygheap): Move bucket array here from cygheap.cc.
* cygheap.cc: Throughout use bucket array from cygheap.
* sigproc.cc (proc_subproc): Dynamically allocate zombie buffer to save DLL
space.
(sigproc_fixup_after_fork): Free zombie array after a fork.
* sigproc.h (sigproc_fixup_after_fork): Declare.
* dir.cc (mkdir): Expand buffer for security descriptor to 4K to avoid stack
corruption.
* fhandler.cc (fhandler_base::open): Ditto.
* path.cc (symlink): Ditto.
@
text
@d743 1
a743 1
const char *windows_device_names[] =
@


1.159
log
@* path.cc (path_conv::check): Avoid splitting off leading '/' in path component
when building a symlink.
@
text
@d2464 1
a2464 1
			    &sa, alloca (256), 256);
@


1.158
log
@        * dir.cc (mkdir): Set security attributes correctly for
        CreateDirectoryA () call if ntsec is on. Don't call
        set_file_attributes () then.
        * fhandler.cc (fhandler_base::open): Ditto for CreateFileA () call.
        * path.cc (symlink): Ditto.
        * security.cc (set_security_attribute): New function.
        * security.h: Add declaration for `allow_ntea' and
        `set_security_attribute'.
@
text
@d618 2
@


1.157
log
@        * path.cc (fchdir): Set the fhandler's path to absolute value to
        ensure changing to the correct directory even if the fhandler originally
        points to a relative path.
@
text
@d2398 1
d2460 5
a2464 1
  h = CreateFileA(win32_path, GENERIC_WRITE, 0, &sec_none_nih,
d2507 4
a2510 3
	  set_file_attribute (win32_path.has_acls (),
			      win32_path.get_win32 (),
			      S_IFLNK | S_IRWXU | S_IRWXG | S_IRWXO);
@


1.156
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d3095 19
@


1.155
log
@Change check_null_empty_path* to check_null_empty_str* throughout.
* path.cc (path_conv::check): Add signal protection here since retrieving info
about remote shares can take some time.
* path.h (check_null_empty_str_errno): Convert to a function prototype.
* path.cc (check_null_empty_str): Move to miscfuncs.cc.
* miscfuncs.cc (check_null_empty_str_errno): New function.
(__check_null_invalid_struct): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(check_null_empty_str): Change from VirtualQuery to IsBadWritePtr.
* thread.cc (check_valid_pointer): Ditto.
* resource.cc (getrlimit): Use check_null_invalid_struct macro for checking
validity of pointer.
(setrlimit): Ditto.
@
text
@d68 1
a77 1
#include "security.h"
@


1.154
log
@forced commit
@
text
@d379 1
d407 1
a407 1
  else if ((error = check_null_empty_path (src)))
d2994 2
a2995 7
  int dir_error = check_null_empty_path (in_dir);
  if (dir_error)
    {
      syscall_printf ("NULL or invalid input to chdir");
      set_errno (dir_error);
      return -1;
    }
d3140 1
a3140 1
  if (check_null_empty_path_errno (path))
d3150 1
a3150 1
  if (check_null_empty_path_errno (path))
a3350 13
}

int __stdcall
check_null_empty_path (const char *name)
{
  MEMORY_BASIC_INFORMATION m;
  if (!name || !VirtualQuery (name, &m, sizeof (m)) || (m.State != MEM_COMMIT))
    return EFAULT;

  if (!*name)
    return ENOENT;

  return 0;
@


1.153
log
@* exceptions.cc (sig_handle_tty_stop): Reset PID_STOPPED if not actually
stopping.
* fhandler_console.cc (fhandler_console::fixup_after_fork): Don't set
controlling terminal if just inheriting a handle.
(fhandler_console::fixup_after_exec): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::init): Ditto.
* signal.cc (kill_worker): Set appropriate errno if proc_exists determines that
process does not really exist.
@
text
@@


1.152
log
@* path.cc (path_conv::check): Deal more robustly with foo/ behavior.
@
text
@d2990 1
a2990 2
extern "C"
int
@


1.151
log
@* path.cc (chdir): Fix call to path_conv constructor so that it REALLY doesn't
check for the null/non-empty path.
@
text
@d414 2
a415 1
      char *p = strrchr (src, '/');
d419 1
a419 1
      if (p)
d421 3
a423 1
	  if (p[1] == '\0' || strcmp (p, "/.") == 0)
a425 3
      else if ((p = strrchr (src, '\\')) &&
	       (p[1] == '\0' || strcmp (p, "\\.") == 0))
	need_directory = 1;
@


1.150
log
@* path.cc (path_conv::update_fs_info): Don't consider remote drives to be NTFS.
Set root_dir before invoking GetDriveType (from Kazuhiro Fujieda
<fujieda@@jaist.ac.jp>).  Eliminate extra checks for rootdir.
@
text
@d3020 1
a3020 1
  /* Convert path.  Third argument ensures that we don't check for NULL/empty/invalid
d3022 1
a3022 1
  path_conv path (dir, PC_FULL | PC_SYM_FOLLOW, NULL);
@


1.149
log
@* path.cc (chdir): Pre-check path for validity before eating trailing space.
Then, ensure that path_conv doesn't check the path for validity again.
@
text
@d155 1
a155 1
  				      : strncasematch (path1, path2, len);
d164 1
a164 1
  				      : strcasematch (path1, path2);
d245 1
a245 1
              else
d315 1
a315 3
  if (!rootdir (tmp_buf) &&
      (!GetCurrentDirectory (sizeof (tmp_buf), tmp_buf) <= sizeof (tmp_buf) ||
       !rootdir (tmp_buf)))       
d326 1
a332 1
      strncpy (root_dir, tmp_buf, MAX_PATH);
d342 1
a342 1
        {
d348 2
a349 2
	  sym_opt = (strcmp (fs_name, "NTFS") == 0 ? PC_CHECK_EA : 0);
        }
d503 1
a503 1
	  int len = sym.check (full_path, suff, opt | sym_opt );
d632 1
a632 1
      
d755 1
a755 1
  
d2241 1
a2241 1
  
d2505 2
a2506 2
	  		      allow_winsymlinks ? FILE_ATTRIBUTE_READONLY
			      			: FILE_ATTRIBUTE_SYSTEM);
d2508 1
a2508 1
            set_symlink_ea (win32_path, topath);
d2788 1
a2788 1
      /* FIXME: if symlink isn't present in EA, but EAs are supported, 
@


1.148
log
@         * cygwin.din: Add fchdir symbols.
         * path.cc (chdir): Guard against invalid parameter.
         (fchdir): New function.
         * include/cygwin/version.h: Bump API minor version to 40.
         * uinfo.cc (internal_getlogin): Remove unused variable.
@
text
@d2994 1
a2994 1
chdir (const char *dir)
d2996 2
a2997 3
  MALLOC_CHECK;
  path_conv path (dir, PC_FULL | PC_SYM_FOLLOW);
  if (path.error)
d2999 2
a3000 2
      set_errno (path.error);
      syscall_printf ("-1 = chdir (%s)", dir);
d3003 2
a3004 1
  syscall_printf ("dir %s", dir);
d3007 2
d3015 17
@


1.147
log
@* security.h (NTWriteEA): Change prototype.
* ntea.cc (NTReadEA): Don't check for global ntea setting, now
it's caller responsibility.
(NTWriteEA): Ditto.
* security.cc (get_file_attribute): Read attribute from EA only
if 'ntea' is enabled.
(set_file_attribute): Ditto.
* path.h: (class path_conv): Add members to store file system
information.
(path_conv::get_drive_type): New function.
* syscalls.cc (stat_worker): Use it.
* path.cc (path_conv::update_fs_info): New functions.
(path_conv::check): Get file system information from device where
file resides. On NTFS, try to read symlink contents from EA.
(get_symlink_ea): New function.
(set_symlink_ea): Ditto.
(symlink): Store symlink in extended attribute, if possible.
@
text
@d2997 7
a3004 1
  path_conv path (dir, PC_FULL | PC_SYM_FOLLOW);
a3013 7
  if (path.error)
    {
      set_errno (path.error);
      syscall_printf ("-1 = chdir (%s)", dir);
      return -1;
    }

d3068 17
@


1.146
log
@* path.cc (normalize_posix_path): Revert ..  check removed by previous changes.
* cygheap.h: Temporarily declare path_prefix_p here.
@
text
@d309 46
d399 4
a402 1
  vol_flags = 0;
d475 2
d505 1
a505 1
	  int len = sym.check (full_path, suff, opt);
d670 2
a671 7
  char fs_name[16];

  strcpy (tmp_buf, this->path);

  if (!rootdir (tmp_buf) ||
      !GetVolumeInformation (tmp_buf, NULL, 0, &vol_serial, NULL,
			     &vol_flags, fs_name, 16))
a672 2
      debug_printf ("GetVolumeInformation(%s) = ERR, this->path(%s), set_has_acls(FALSE)",
		    tmp_buf, this->path, GetLastError ());
d679 2
a680 5
      debug_printf ("GetVolumeInformation(%s) = OK, this->path(%s), set_has_acls(%d)",
		    tmp_buf, this->path, vol_flags & FS_PERSISTENT_ACLS);
      drive_type = GetDriveType (tmp_buf);
      if (drive_type == DRIVE_REMOTE || (drive_type == DRIVE_UNKNOWN && (tmp_buf[0] == '\\' && tmp_buf[1] == '\\')))
	is_remote_drive = 1;
d684 1
a684 1
	set_has_acls (vol_flags & FS_PERSISTENT_ACLS);
d2360 22
d2507 4
a2510 2
			      allow_winsymlinks ? FILE_ATTRIBUTE_READONLY
						: FILE_ATTRIBUTE_SYSTEM);
d2774 8
d2790 3
@


1.145
log
@* cygheap.cc (cygheap_root::cygheap_rot): Remove constructor.
(cygheap_root::~cygheap_root): Remove destructor.
(cygheap_root::operator =): Remove.
(cygheap_root::set): New method.
* cygheap.h (cygheap_root): Reflect above changes.  Store root info in
mount-like structure.
(cygheap_root:posix_ok): New method.
(cygheap_root::ischroot_native): Ditto.
(cygheap_root::unchroot): Ditto.
(cygheap_root::exists): Ditto.
(cygheap_root::posix_length): Ditto.
(cygheap_root::posix_path): Ditto.
(cygheap_root::native_length): Ditto.
(cygheap_root::native_path): Ditto.
* dir.cc (opendir): Remove special chroot test.
* path.cc (path_prefix_p): Remove front end.
(normalize_posix_path): Reorganize chroot tests to accomodate new convention of
allowing paths using posix chroot prefix.
(path_conv::check): Pass a "already ran normalize" option to
conv_to_win32_path.  Return if there is an error from this function.
(mount_info::conv_to_win32_path): Add extra argument.  Don't call
normalize_posix_path if caller has already done so.  Substitute chroot setting,
if any, for root translation.  Add chroot checking to final output step.
* shared_info (mount_info): Accomodate additional argument to
conv_to_win32_path.
* syscalls.cc (chroot): Store both normalized posix path and native path in
chroot.
@
text
@a91 1
static int path_prefix_p (const char *path1, const char *path2, int len1);
d245 6
d278 1
a278 1
        strcpy (known_suffix, sym.ext_here);
d459 1
a459 1
	        {
d465 1
a465 1
	         if the last component is concerned. This allows functions
d469 1
a469 1
	        case_clash = TRUE;
d507 1
a507 1
		        {
d513 1
a513 1
		        goto out;
d515 1
a515 1
		         done now. */
d625 1
a625 1
      			     &vol_flags, fs_name, 16))
d641 1
a641 1
        set_has_acls (FALSE);
d643 1
a643 1
        set_has_acls (vol_flags & FS_PERSISTENT_ACLS);
d645 1
a645 1
         in fhandler.cc (fhandler_disk_file::open). */
d2190 1
a2190 1
        {
d2193 1
a2193 1
        }
d2413 1
a2413 1
	  		       &written, NULL)
d2434 1
a2434 1
	  	    || written != len;
d2444 2
a2445 2
	  		      allow_winsymlinks ? FILE_ATTRIBUTE_READONLY
			      			: FILE_ATTRIBUTE_SYSTEM);
d2686 2
a2687 2
          || (opt & PC_SYM_IGNORE))
        goto file_not_symlink;
d2694 1
a2694 1
        goto file_not_symlink;
d2982 1
a2982 1
           && pcheck_case == PCHECK_RELAXED)
@


1.144
log
@* path.cc (chdir): Really make sure that isspace gets only an unsigned char.
@
text
@d92 1
a92 1
static int path_prefix_p_ (const char *path1, const char *path2, int len1);
a110 4
#define path_prefix_p(p1, p2, l1) \
       ((cyg_tolower(*(p1))==cyg_tolower(*(p2))) && \
       path_prefix_p_(p1, p2, l1))

a119 6
#define ischrootpath(p) \
	(cygheap->root.length () && \
	 strncasematch (cygheap->root.path (), p, cygheap->root.length ()) && \
	 (p[cygheap->root.length ()] == '/' \
	  || p[cygheap->root.length ()] == '\0'))

d134 2
a135 2
static int
path_prefix_p_ (const char *path1, const char *path2, int len1)
d175 1
a175 1
static int
a203 5
      if (cygheap->root.length ())
	{
	  debug_printf ("ENOENT = normalize_posix_path (%s)", src);
	  return ENOENT;
	}
a213 6
  /* Exactly one leading slash. Absolute path. Check for chroot. */
  else if (cygheap->root.length ())
    {
      strcpy (dst, cygheap->root.path ());
      dst += cygheap->root.length ();
    }
a245 8
	      else
		{
		  if (!ischrootpath (dst_start) ||
		      dst - dst_start != (int) cygheap->root.length ())
		    while (dst > dst_start && !isslash (*--dst))
		      continue;
		  src++;
		}
d416 4
a419 1
						   unit, &sym.pflags);
a867 5
      if (cygheap->root.length ())
	{
	  debug_printf ("ENOENT = normalize_win32_path (%s)", src);
	  return ENOENT;
	}
a870 11
  /* If absolute path, care for chroot. */
  else if (beg_src_slash  && cygheap->root.length ())
    {
      strcpy (dst, cygheap->root.path ());
      char *c;
      while ((c = strchr (dst, '/')) != NULL)
	*c = '\\';
      dst += cygheap->root.length ();
      dst_root_start = dst;
      *dst++ = '\\';
    }
d1088 2
a1089 1
				DWORD &devn, int &unit, unsigned *flags)
d1099 1
a1135 16
      if (cygheap->root.length () && dst[0] && dst[1] == ':')
	{
	  char posix_path[MAX_PATH + 1];

	  rc = mount_table->conv_to_posix_path (dst, posix_path, 0);
	  if (rc)
	    {
	      debug_printf ("conv_to_posix_path failed, rc %d", rc);
	      return rc;
	    }
	  if (!ischrootpath (posix_path))
	    {
	      debug_printf ("ischrootpath failed");
	      return ENOENT;
	    }
	}
d1155 5
a1159 1
  rc = normalize_posix_path (src_path, pathbuf);
d1161 6
a1166 5
  if (rc)
    {
      debug_printf ("%d = conv_to_win32_path (%s)", rc, src_path);
      *flags = 0;
      return rc;
d1173 2
a1174 1
      goto out;
d1188 2
d1193 3
d1197 18
a1214 1
      if (path_prefix_p (mi->posix_path, pathbuf, mi->posix_pathlen))
d1225 20
a1244 3
      int n = mi->native_pathlen;
      memcpy (dst, mi->native_path, n + 1);
      char *p = pathbuf + mi->posix_pathlen;
d1254 1
a1254 1
out:
d1256 12
a1267 2
  debug_printf ("src_path %s, dst %s, flags %p", src_path, dst, *flags);
  return 0;
d1372 3
d1396 6
d1405 16
d3363 1
a3363 2
    tocopy = with_chroot && ischrootpath(posix) ?
	     posix + cygheap->root.length () : posix;
d3365 1
a3365 2
  debug_printf("cygheap->root: %s, posix: %s",
	       (const char *) cygheap->root.path (), posix);
@


1.143
log
@* path.cc (chdir): Always send unsigned chars to isspace since newlib's isspace
doesn't deal well with "negative" chars.
* fhandler.cc (fhandler_disk_file::open): Propagate remote status of file
garnered from path_conv.  Move #! checking to fstat.
(fhandler_disk_file::fstat): Reorganize st_mode setting to eliminate
duplication.  Move check for #! here from fhandler::open.
* fhandler.h (fhandler_base::isremote): New method.
(fhandler_base::set_isremote): Ditto.
(fhandler_base::set_execable_p): Also record "don't care if executable state".
(fhandler_base::dont_care_if_execable): New method.
* path.cc (path_conv::check): Clear new flags.  Appropriately set vol_flags,
drive_type, and is_remote_drive.
* path.h: Add new flags and methods for manipulating them.
* syscalls.cc (_unlink): Use isremote() to determine if a path is remote rather
than calling GetDriveType.
(stat_worker): Ditto.
* security.cc (get_file_attribute): Or attribute with result of NTReadEA to be
consistent with get_nt_attribute.
@
text
@d2900 1
a2900 1
  for (s = strchr (dir, '\0'); --s >= dir && isspace ((unsigned int) *s); )
@


1.142
log
@* path.cc (symlink_info::check): Correctly set 'ext_tacked_on'.  Use this to
determine if user specified 'foo.lnk' explicitly.  Reorganize slightly to get
rid of one goto.
@
text
@d377 3
a639 1
  DWORD serial, volflags;
d645 2
a646 2
      !GetVolumeInformation (tmp_buf, NULL, 0, &serial, NULL,
      			     &volflags, fs_name, 16))
d657 5
a661 4
		    tmp_buf, this->path, volflags & FS_PERSISTENT_ACLS);
      if (!allow_smbntsec
          && ((tmp_buf[0] == '\\' && tmp_buf[1] == '\\')
              || GetDriveType (tmp_buf) == DRIVE_REMOTE))
d664 1
a664 1
        set_has_acls (volflags & FS_PERSISTENT_ACLS);
d2900 1
a2900 1
  for (s = strchr (dir, '\0'); --s >= dir && isspace (*s); )
@


1.141
log
@        * path.cc (symlink_info::check): Add a check to return correctly
        if incoming `*.lnk' file is not a symlink.
@
text
@a2633 2
  ext_tacked_on = !*ext_here;

d2650 3
d2657 3
a2659 1
      int sym_check = 0;
d2690 1
a2690 4
	    {
	      ext_tacked_on = 1;
	      break;
	    }
d2693 1
a2693 1
	  if (!suffix.lnk_match () || pathmatch(path, suffix.path))
d2705 6
a2711 6
  goto out;

file_not_symlink:
  is_symlink = FALSE;
  syscall_printf ("not a symlink");
  res = 0;
a2712 1
out:
@


1.140
log
@* path.cc (slash_drive_prefix_p): Remove.
(mount_info::slash_drive_to_win32_path): Ditto.
(mount_info::conv_to_win32_path): Remove slash drive prefix check.
(mount_info::add_item): Ditto.
(mount_info::del_item): Ditto.
* shared_info.h (mount_info): Remove slash_drive_to_win32_path declaration.
@
text
@d2693 1
a2693 1
	  if (!suffix.lnk_match ())
@


1.139
log
@* path.cc (path_conv::check): Revert allow_ntsec check so that volume info is
always retrieved and isdisk setting is properly set.
@
text
@a1040 12
/* slash_drive_prefix_p: Return non-zero if PATH begins with
   //<letter>.  */

static int
slash_drive_prefix_p (const char *path)
{
  return (isdirsep(path[0])
	  && isdirsep(path[1])
	  && isalpha (path[2])
	  && (path[3] == 0 || path[3] == '/'));
}

d1245 1
a1245 4
      if (slash_drive_prefix_p (pathbuf))
	slash_drive_to_win32_path (pathbuf, dst, 0);
      else
	backslashify (pathbuf, dst, 0);	/* just convert */
a1267 14
/* Convert PATH (for which slash_drive_prefix_p returns 1) to WIN32 form.  */

void
mount_info::slash_drive_to_win32_path (const char *path, char *buf,
				       int trailing_slash_p)
{
  buf[0] = path[2];
  buf[1] = ':';
  if (path[3] == '0')
    strcpy (buf + 2, "\\");
  else
    backslashify (path + 3, buf + 2, trailing_slash_p);
}

d1894 1
a1894 4
  if (slash_drive_prefix_p (native))
    slash_drive_to_win32_path (native, nativetmp, 0);
  else
    backslashify (native, nativetmp, 0);
d1961 2
a1962 4
  if (slash_drive_prefix_p (path))
      slash_drive_to_win32_path (path, pathtmp, 0);
  else if (slash_unc_prefix_p (path) || strpbrk (path, ":\\"))
      backslashify (path, pathtmp, 0);
@


1.138
log
@* external.cc (fillout_pinfo): Use correct pids.
* path.cc (mount_info::conv_to_win32_path): Correct test for whether to include
a slash.
@
text
@d642 1
a642 1
  if (allow_ntsec && (!rootdir (tmp_buf) ||
d644 1
a644 1
      			     &volflags, fs_name, 16)))
@


1.137
log
@* path.cc (mount_info::conv_to_win32_path): Treat UNC paths the same as paths
including `:' or `\'.
@
text
@d1268 3
a1270 1
      if ((isdrive (dst) && !dst[2]) || (*p && *p != '/'))
@


1.136
log
@* cygheap.cc (_cfree): Add regparm attribute.
(_crealloc): Ditto.
* dcrt0.cc (dll_crt0_1): Default to always checking for executable for now.
* dtable.cc (dtable::not_open): Move method.
* dtable.h (dtable): Here.
* exceptions.cc (ctrl_c_handler): Don't expect process group leader to handle a
signal if it doesn't exist.
* fhandler.h (fhandler_base): Make openflags protected.
* localtime.c (tzsetwall): Check for __CYGWIN__ as well as __WIN32__.
* path.cc (path_conv::check): Add some comments.  Change strcat to assignment.
* lib/_cygwin_S_IEXEC.cc (_cygwin_bob__): Eliminate.
* fhandler_tty.cc (fhandler_console::dup): Set controlling terminal if
necessary.
* fhandler_tty.cc (fhandler_tty_slave::dup): Ditto.
@
text
@d1174 1
a1174 1
  if (strpbrk (src_path, ":\\") != NULL)
@


1.135
log
@* exceptions.cc (ctrl_c_handler): Always send signal to process if it has no
tty.
@
text
@d389 3
d440 1
d444 1
d461 4
a464 1
	    strcat (full_path, "\\");
a539 1

d542 2
d548 2
d570 3
d582 2
d590 1
a590 1
	headptr = tmp_buf;
d593 1
d598 1
d602 2
d606 2
d616 1
@


1.134
log
@* path.cc (mount_info::conv_to_win32_path): More path tweaking.
@
text
@d2840 3
a2842 4
	  nn = strncpy (newname, name, 2);
	  if (isupper (*nn))
	    *newname = cyg_tolower (*nn);
	  *(nn += 2) = '\0';
d2845 2
a2846 5
	    {
	      *nn = '\\';
	      *++nn = '\0';
	    }
	  strcpy (nn, name);
@


1.133
log
@* path.cc (mount_info::conv_to_win32_path): Fix debugging output to avoid a
SIGSEGV.  Avoid double backslashes in middle of filename.
@
text
@d1245 1
a1245 1
      if ((isdrive (dst) && !dst[2]) || (*p && dst[n - 1] != '\\'))
@


1.132
log
@* path.cc (mkrelpath): New function.
(mount_info::conv_to_win32_path): Eliminate now-unneeded relative path name arg
and processing.
(path_conv::check): Accomodate relative path names again.  Accomodate one extra
argument in mount_info::conv_to_win32_path.  Tack trailing slash on end of
relative path as a side effect, like before.
* shared_info.h (mount_info::conv_to_win32_path): Reflect new argument
ordering.
@
text
@d1245 1
a1245 1
      if ((isdrive (dst) && !dst[2]) || (p && dst[n - 1] != '\\'))
d1254 1
a1254 1
  debug_printf ("src_path %s, win32 %s, flags %p", dst, *flags, src_path);
@


1.131
log
@* path.cc (path_conv::check): Don't use path_flags when converting to MS-DOS
syntax unless parsing tail of path component.  Stop parsing path when we reach
the 'root' of the path.  Correctly copy tail to path component.
@
text
@d306 27
d358 1
d398 1
d420 1
a420 1
	  char *full_path, *rel_path, *realpath;
d428 1
a428 2
	      rel_path = NULL;
	      realpath = full_path = pathbuf;
d434 1
a434 4
	      if (opt & PC_FULL)
		rel_path = NULL, realpath = full_path = this->path;
	      else
		realpath = rel_path = this->path, full_path = pathbuf;
d437 1
a437 1
	  error = mount_table->conv_to_win32_path (path_copy, rel_path, full_path, devn,
d447 1
a447 1
	  char *dostail = strchr (realpath, '\0');
d452 1
a452 1
	  while (dostail > realpath + 3 && (*--dostail == '\\'))
d455 2
a456 2
	  if (realpath[0] && realpath[1] == ':' && realpath[2] == '\0')
	    strcat (realpath, "\\");
d460 1
a460 1
	      fileattr = GetFileAttributesA (realpath);
d464 1
a464 1
	  int len = sym.check (realpath, suff, opt);
d617 2
a618 4
  if (isabspath (this->path))
    strcpy (tmp_buf, this->path);
  else
    cygheap->cwd.get (tmp_buf, 1, 1, MAX_PATH);
d644 18
d1115 2
a1116 3
mount_info::conv_to_win32_path (const char *src_path, char *win32_path,
				char *full_win32_path, DWORD &devn, int &unit,
				unsigned *flags)
a1123 2
  int trailing_slash_p = (src_path_len > 1
			  && SLASH_P (src_path[src_path_len - 1]));
a1124 1
  int isrelpath;
a1142 1
  char *dst = NULL;
a1145 6
  /* Determine where the destination should be placed. */
  if (full_win32_path != NULL)
    dst = full_win32_path;
  else if (win32_path != NULL)
    dst = win32_path;

d1160 1
a1160 1
      isrelpath = !isabspath (src_path);
d1178 1
a1178 1
      goto fillin;
a1205 2
  isrelpath = !isslash (*src_path);

d1210 1
a1210 1
      goto fillin;
d1218 1
a1218 1
      if (!cygdrive_win32_path (pathbuf, dst, trailing_slash_p))
d1221 1
a1221 1
      goto fillin;
d1235 1
a1235 1
	slash_drive_to_win32_path (pathbuf, dst, trailing_slash_p);
d1237 1
a1237 1
	backslashify (pathbuf, dst, trailing_slash_p);	/* just convert */
d1245 4
a1248 16
      if (!trailing_slash_p && !*p)
	{
	  if (isdrive (dst) && !dst[2])
	    dst[n++] = '\\';
	  dst[n] = '\0';
	}
      else
	{
	  /* Do not add trailing \ to UNC device names like \\.\a: */
	  if (*p != '/' &&  /* FIXME: this test seems wrong. */
	     (strncmp (mi->native_path, "\\\\.\\", 4) != 0 ||
	       strncmp (mi->native_path + 4, "UNC\\", 4) == 0))
	    dst[n++] = '\\';
	  strcpy (dst + n, p);
	}
      backslashify (dst, dst, trailing_slash_p);
a1251 37
fillin:
  /* Compute relative path if asked to and able to.  */
  if (win32_path == NULL)
    /* nothing to do */;
  else if (isrelpath)
    {
      char cwd_win32[MAX_PATH];
      if (!cygheap->cwd.get (cwd_win32, 0))
	return get_errno ();
      unsigned cwdlen = strlen (cwd_win32);
      if (!path_prefix_p (cwd_win32, dst, cwdlen))
	strcpy (win32_path, dst);
      else
	{
	  size_t n = strlen (dst);
	  if (n < cwdlen)
	    strcpy (win32_path, dst);
	  else
	    {
	      if (n == cwdlen)
		dst += cwdlen;
	      else
		dst += isdirsep (cwd_win32[cwdlen - 1]) ? cwdlen : cwdlen + 1;

	      memmove (win32_path, dst, strlen (dst) + 1);
	      if (!*win32_path)
		{
		  strcpy (win32_path, ".");
		  if (trailing_slash_p)
		    strcat (win32_path, "\\");
		}
	    }
	}
    }
  else if (win32_path != dst)
    strcpy (win32_path, dst);

d1254 1
a1254 3
  debug_printf ("%s(rel), %s(abs) %p(flags) = conv_to_win32_path (%s)",
		win32_path, full_win32_path, *flags,
		src_path);
@


1.130
log
@* path.cc (symlink_info::check): Remove extra arguments, move functionality
back to path_conv::check.  Clear symlink bit from pflags argument before
detecting if this is a symlink.
(path_conv::check): Convert posix path here instead of symlink_info::check.
Only grab volflags when using ntsec.
(symlink_info::check_case): Just replace appropriate part of input path.
@
text
@d391 1
a391 1
	  char *full_path;
d399 2
a400 1
	      full_path = pathbuf;
d406 4
a409 1
	      full_path = this->path;
d412 2
a413 2
	  error = mount_table->conv_to_win32_path (path_copy, NULL, full_path, devn,
						   unit, &path_flags);
d422 1
a422 1
	  char *dostail = strchr (full_path, '\0');
d427 1
a427 1
	  while (dostail > full_path + 3 && (*--dostail == '\\'))
d430 2
a431 2
	  if (full_path[0] && full_path[1] == ':' && full_path[2] == '\0')
	    strcat (full_path, "\\");
d435 1
a435 1
	      fileattr = GetFileAttributesA (full_path);
d439 1
a439 1
	  int len = sym.check (full_path, suff, opt);
d514 1
a514 1
	  if (!newtail)
d534 1
a534 1
      int taillen = strlen (tail + 1);
d561 1
a561 1
      if (tail == path_end)
a571 1
/*fillin:*/
d592 4
a595 1
  strcpy (tmp_buf, this->path);
@


1.129
log
@Throughout, change 'tty_attached' to 'real_tty_attached', for clarity.
Throughout, change 'OutputStopped' to 'output_stopped', for consistency.
* dtable.cc (stdio_init): Set controlling tty if not set by stdio opens.
* exceptions.cc (ctrl_c_handler): Avoid special pgid checking if no tty is
associated with the process.
(Suggested by Tim Baker <dbaker@@direct.ca>)
* external.cc (fillout_pinfo): Return actual tty number for ctty.
* fhandler_console.cc (get_tty_stuff): Set ctty when shared memory is
allocated.  Accept flags input from open().
(set_console_ctty): New function.
(fhandler_console::open): Pass flags to get_tty_stuff and rely on this function
to set the ctty, if appropriate.
* fhandler_termios.cc (fhandler_termios::set_ctty): Move to tty_min class.
* fhandler_tty.cc (fhandler_tty_slave::open): Use tc field to access
set_ctty().
* tty.h (TTY_CONSOLE): Move to include/sys/cygwin.h.
(tty_min): Add set_ctty class here.
* include/sys/cygwin.h (TTY_CONSOLE): New home here.
* path.cc (symlink_info): Make contents an actual buffer.  Pass more flags to
case_check.
(path_conv::check): Reorganize to do parsing based on posix path rather than
native path.
(symlink_info::check): Expect posix path as input.  Translate to native path
here.  Accept path_conv flags.  Stop parsing if not a symlink regardless of
whether previous path was a symlink.
@
text
@d105 2
a106 4
  int check (const char *path, const suffix_info *suffixes,
  	     char *orig_path, unsigned opt,
	     DWORD& devn, int& unit, unsigned& path_flags);
  BOOL case_check (const char *path, char *orig_path);
d408 28
a435 2
	  int len = sym.check (path_copy, suff, full_path, opt,
	     		       devn, unit, path_flags);
d590 1
a590 1
  if (!rootdir (tmp_buf) ||
d592 1
a592 1
      			     &volflags, fs_name, 16))
d2647 1
a2647 3
symlink_info::check (const char *path, const suffix_info *suffixes,
		     char *full_path, unsigned opt,
		     DWORD& devn, int& unit, unsigned& path_flags)
a2652 1
  char *tail;
d2654 3
a2656 2
  error = mount_table->conv_to_win32_path (path, NULL, full_path, devn,
					   unit, &path_flags);
d2658 1
a2658 27
  if (devn != FH_BAD)
    {
      fileattr = 0;
      goto out;		/* Found a device.  Stop parsing. */
    }

  /* Eat trailing slashes */
  tail = strchr (full_path, '\0');

  /* If path is only a drivename, Windows interprets it as the current working
     directory on this drive instead of the root dir which is what we want. So
     we need the trailing backslash in this case. */
  while (tail > full_path + 3 && (*--tail == '\\'))
    *tail = '\0';

  if (full_path[0] && full_path[1] == ':' && full_path[2] == '\0')
    strcat (full_path, "\\");

  if ((opt & PC_SYM_IGNORE) && pcheck_case == PCHECK_RELAXED)
    {
      fileattr = GetFileAttributesA (path);
      goto out;
    }

  is_symlink = TRUE;
  ext_here = suffix.has (full_path, suffixes);
  extn = ext_here - full_path;
d2678 1
a2678 1
      if (pcheck_case != PCHECK_RELAXED && !case_check (path, full_path)
d2752 1
a2752 1
symlink_info::case_check (const char *path, char *orig_path)
d2756 1
a2756 1
  const char *c;
d2781 1
a2781 2
	  strncpy (orig_path + (c - path), data.cFileName,
		   strlen (data.cFileName));
@


1.128
log
@* shortcut.c (check_shortcut): Close input file handle before returning.
* path.cc (check_sysfile): Ditto.
(symlink_info::check): Rely on opened file handle being closed by symlink
checking routines.  Set ext_tacked_on when .lnk is detected.
@
text
@d96 1
a96 1
  char buf[3 + MAX_PATH * 3];
a98 1
  char *contents;
a104 1
  symlink_info (): contents (buf + MAX_PATH + 1) {}
d106 2
a107 1
  	     char *orig_path, BOOL sym_ignore);
d180 117
d328 2
a329 3
  char path_buf[MAX_PATH];
  char path_copy[MAX_PATH];
  char tmp_buf[MAX_PATH];
a344 2
  char *rel_path, *full_path;

a356 5
  if (opt & PC_FULL)
    rel_path = path_buf, full_path = this->path;
  else
    rel_path = this->path, full_path = path_buf;

d371 2
a372 4
      /* Must look up path in mount table, etc.  */
      error = mount_table->conv_to_win32_path (src, rel_path, full_path, devn,
					       unit, &path_flags);
      MALLOC_CHECK;
a374 5
      if (devn != FH_BAD)
	{
	  fileattr = 0;
	  return;
	}
d376 3
a378 21
      /* Eat trailing slashes */
      char *tail = strchr (full_path, '\0');
      /* If path is only a drivename, Windows interprets it as
	 the current working directory on this drive instead of
	 the root dir which is what we want. So we need
	 the trailing backslash in this case. */
      while (tail > full_path + 3 && (*--tail == '\\'))
	*tail = '\0';
      if (full_path[0] && full_path[1] == ':' && full_path[2] == '\0')
	strcat (full_path, "\\");

      if ((opt & PC_SYM_IGNORE) && pcheck_case == PCHECK_RELAXED)
	{
	  fileattr = GetFileAttributesA (path);
	  goto out;
	}

      /* Make a copy of the path that we can munge up */
      strcpy (path_copy, full_path);

      tail = path_copy + 1 + (tail - full_path);   // Point to end of copy
d392 2
d401 1
d407 1
d410 2
a411 1
	  int len = sym.check (path_copy, suff, full_path, opt & PC_SYM_IGNORE);
d482 5
a486 2
	  if (!(tail = strrchr (path_copy, '\\')) ||
	      (tail > path_copy && tail[-1] == ':'))
d489 2
d503 1
d506 1
a506 2
      tail = full_path + (tail - path_copy);
      int taillen = strlen (tail);
d515 2
a516 3
      /* Copy tail of full_path to discovered symlink. */
      for (p = sym.contents + buflen; *tail; tail++)
	*p++ = *tail == '\\' ? '/' : *tail;
d519 1
a519 4
      /* If symlink referred to an absolute path, then we
	 just use sym.contents and loop.  Otherwise tack the head of
	 path_copy before sym.contents and translate it back from a
	 Win32-style path to a POSIX-style one. */
d521 14
a534 3
	src = sym.contents;
      else if (!(tail = strrchr (path_copy, '\\')))
	system_printf ("problem parsing %s - '%s'", src, full_path);
d537 2
a538 9
	  int headlen = 1 + tail - path_copy;
	  p = sym.contents - headlen;
	  memcpy (p, path_copy, headlen);
	  MALLOC_CHECK;
	  error = mount_table->conv_to_posix_path (p, tmp_buf, 1);
	  MALLOC_CHECK;
	  if (error)
	    return;
	  src = tmp_buf;
d540 2
d565 1
a565 1
  strcpy (tmp_buf, full_path);
d570 2
a571 2
      debug_printf ("GetVolumeInformation(%s) = ERR, full_path(%s), set_has_acls(FALSE)",
		    tmp_buf, full_path, GetLastError ());
d578 2
a579 2
      debug_printf ("GetVolumeInformation(%s) = OK, full_path(%s), set_has_acls(%d)",
		    tmp_buf, full_path, volflags & FS_PERSISTENT_ACLS);
d692 1
a692 1
	  if (tty_attached (myself))
a780 117
/* Normalize a POSIX path.
   \'s are converted to /'s in the process.
   All duplicate /'s, except for 2 leading /'s, are deleted.
   The result is 0 for success, or an errno error value.  */

#define isslash(c) ((c) == '/')

static int
normalize_posix_path (const char *src, char *dst)
{
  const char *src_start = src;
  char *dst_start = dst;

  syscall_printf ("src %s", src);
  if (isdrive (src) || strpbrk (src, "\\:"))
    {
      cygwin_conv_to_full_posix_path (src, dst);
      return 0;
    }
  if (!isslash (src[0]))
    {
      if (!cygheap->cwd.get (dst))
	return get_errno ();
      dst = strchr (dst, '\0');
      if (*src == '.')
	{
	  if (dst == dst_start + 1 && *dst_start == '/')
	     --dst;
	  goto sawdot;
	}
      if (dst > dst_start && !isslash (dst[-1]))
	*dst++ = '/';
    }
  /* Two leading /'s?  If so, preserve them.  */
  else if (isslash (src[1]))
    {
      if (cygheap->root.length ())
	{
	  debug_printf ("ENOENT = normalize_posix_path (%s)", src);
	  return ENOENT;
	}
      *dst++ = '/';
      *dst++ = '/';
      src += 2;
      if (isslash (*src))
	{ /* Starts with three or more slashes - reset. */
	  dst = dst_start;
	  *dst++ = '/';
	  src = src_start + 1;
	}
    }
  /* Exactly one leading slash. Absolute path. Check for chroot. */
  else if (cygheap->root.length ())
    {
      strcpy (dst, cygheap->root.path ());
      dst += cygheap->root.length ();
    }
  else
    *dst = '\0';

  while (*src)
    {
      /* Strip runs of /'s.  */
      if (!isslash (*src))
	*dst++ = *src++;
      else
	{
	  while (*++src)
	    {
	      if (isslash (*src))
		continue;

	      if (*src != '.')
		break;

	    sawdot:
	      if (src[1] != '.')
		{
		  if (!src[1])
		    {
		      if (dst == dst_start)
			*dst++ = '/';
		      goto done;
		    }
		  if (!isslash (src[1]))
		    break;
		}
	      else if (src[2] && !isslash (src[2]))
		break;
	      else
		{
		  if (!ischrootpath (dst_start) ||
		      dst - dst_start != (int) cygheap->root.length ())
		    while (dst > dst_start && !isslash (*--dst))
		      continue;
		  src++;
		}
	    }

	  *dst++ = '/';
	}
	if ((dst - dst_start) >= MAX_PATH)
	  {
	    debug_printf ("ENAMETOOLONG = normalize_posix_path (%s)", src);
	    return ENAMETOOLONG;
	  }
    }

done:
  *dst = '\0';
  if (--dst > dst_start && isslash (*dst))
    *dst = '\0';

  debug_printf ("%s = normalize_posix_path (%s)", dst_start, src_start);
  return 0;
}

d2624 2
a2625 1
		     char *orig_path, BOOL sym_ignore)
d2630 29
d2661 2
a2662 2
  ext_here = suffix.has (path, suffixes);
  extn = ext_here - path;
d2682 2
a2683 2
      if (pcheck_case != PCHECK_RELAXED && !case_check (path, orig_path)
          || sym_ignore)
d2695 1
a2695 1
      /* The old Cygwin method creating symlinks: */
d2701 1
a2701 1
      if (!sym_check && !(pflags & PATH_SYMLINK))
@


1.127
log
@* path.cc (path_conv::check): Always initialize member variables.
@
text
@d2507 2
d2703 2
a2704 3
      else if (sym_check == 1
               && !(res = check_shortcut (suffix.path, fileattr, h,
	       				  contents, &error, &pflags)))
d2706 7
a2712 1
	  CloseHandle (h);
d2715 10
a2724 6
	  if (suffix.lnk_match ())
	    {
	      fileattr = (DWORD)-1;
	      continue;		/* in case we're going to tack *another* .lnk on this filename. */
	    }
	  goto file_not_symlink;
a2725 9
      else if (sym_check == 2 &&
      	       !(res = check_sysfile (suffix.path, fileattr, h,
	       			      contents, &error, &pflags)))
	{
	  CloseHandle (h);
	  goto file_not_symlink;
	}

      CloseHandle (h);
@


1.126
log
@Throughout, change fdtab references to cygheap->fdtab.
* child_info.h (cygheap_exec_info): Eliminate special fdtab stuff.
* spawn.cc (spawn_guts): Ditto.
* cygheap.cc (cygheap_init): Initialize fdtab, if appropriate.
* cygheap.h (CYGHEAPSIZE): Include size of init_cygheap.
(_cmalloc_entry): Include fdtab here.
* dtable.h (dtable): Declare/define new methods.
* dtable.cc (dtable::vfork_child_fixup): New method.
(dtable::fixup_after_exec): Remove unneeded extra arguments.
* dcrt0.cc (dll_crt0_1): Ditto.
* environ.cc (getwinenv): Use case sensitive comparison.
(winenv): Make a copy of environment cache to avoid realloc problems when
duplicate environment variables exist in the environment.  (From Egor Duda)
* net.cc (cygwin_socket): Revert Apr 14 change.
* include/sys/file.h: Protect against previous X_OK definition.
* passwd.cc: Eliminate passwd_sem throughout.
* security.cc: Ditto.
* cygwin.din: Export New functions.
* passwd.cc (read_etc_passwd): Make race safe.
(getpwuid_r): New function.
(getpwnam_r): New function.
@
text
@d232 7
a249 5
  int loop = 0;
  path_flags = 0;
  known_suffix = NULL;
  fileattr = (DWORD) -1;
  case_clash = FALSE;
@


1.125
log
@* path.h (path_conv::add_ext_from_sym): Declare.
* path.cc (path_conv::add_ext_from_sym): Convert to pure inline method.
@
text
@d73 1
@


1.124
log
@        * path.cc (windows_device_names): Add missing NULL element.
@
text
@a179 3
#define add_ext_from_sym(s) \
		(add_ext_from_sym_ (this->path, this->known_suffix, s))

d181 1
a181 1
add_ext_from_sym_ (char *path, char *known_suffix, symlink_info &sym)
@


1.123
log
@* path.cc (windows_device_names): Move dsp to proper location.
@
text
@d546 1
a546 1
  NULL, NULL,
@


1.122
log
@        * path.cc (path_conv::check): Set case_clash even if pcheck_case
        is set to PCHECK_ADJUST when a case clash is given for the last
        component in path.
        (symlink_info::case_check): Ditto.
        * syscalls.cc (_rename): Avoid overwriting an already existing file
        if a case clash is given even if pcheck_case is set to PCHECK_ADJUST.
@
text
@a544 1
  "\\dev\\dsp",
d556 1
@


1.121
log
@* path.h (cwdstuff): Move class.
* cygheap.h (cwdstuff): To here.
(init_cygheap): Add cwd field.
* child_info.h (cygheap_exec_info): Eliminate cwd stuff.
(child_info_spawn): Ditto.
* dcrt0.cc (dll_crt0_1): Remove cygcwd.fixup_after_exec call.  Convert cygcwd
reference to cygheap->cwd.
* path.cc: Ditto, throughout.
(cwdstuff::copy): Eliminate.
(cwdstuff::fixup_after_exec): Ditto.
* spawn.cc (spawn_guts): Eliminate call to cygcwd.copy.
* fhandler.h (FH_OSS_DSP): Move into "fast" device category.
@
text
@d327 12
a338 3
	      case_clash = TRUE;
	      error = ENOENT;
	      goto out;
d2766 2
d2771 1
a2771 4
	    {
	      case_clash = TRUE;
	      return FALSE;
	    }
@


1.120
log
@* autoload.cc: Add winmm functions needed by fhandler_dsp.cc.
* fhandler_dsp.cc: New file.  Implements OSS like /dev/dsp.
* include/sys/soundcard.h: New file.  User land includes for OSS /dev/dsp.
* fhandler.h: Add new class fhandler_dev_dsp and a FH_OSS_DSP definition.
* dtable.cc (dtable::build_fhandler): Allow creation of the /dev/dsp device.
* path.cc (windows_device_names): Add /dev/dsp into list of device names.
* Makefile.in (DLL_OFILES): Add fhandler_dsp.o.
@
text
@a110 2
cwdstuff cygcwd;	/* The current working directory. */

d698 1
a698 1
      if (!cygcwd.get (dst))
d831 1
a831 1
      if (!cygcwd.get (dst, 0))
d1226 1
a1226 1
      if (!cygcwd.get (cwd_win32, 0))
d2866 1
a2866 1
	  hash = cygcwd.get_hash ();
d2890 1
a2890 1
  return cygcwd.get (buf, 1, 1, ulen);
d2969 1
a2969 1
    cygcwd.set (path, dir);
d2971 1
a2971 1
    cygcwd.set (path, NULL);
d2975 2
a2976 2
  syscall_printf ("%d = chdir() cygcwd.posix '%s' native '%s'", res,
		  cygcwd.posix, native_dir);
a3268 9
/* Called to fill in cwd values after an exec. */
void
cwdstuff::fixup_after_exec (char *win32_cwd, char *posix_cwd, DWORD hash_cwd)
{
  win32 = win32_cwd;
  posix = posix_cwd;
  hash = hash_cwd;
}

a3379 13
}

/* Get copies of all cwdstuff elements.  Used by spawn_guts. */
void
cwdstuff::copy (char * &posix_cwd, char * &win32_cwd, DWORD hash_cwd)
{
  lock->acquire ();
  get_initial (); /* FIXME: Check return someday */
  posix_cwd = cstrdup (posix);
  win32_cwd = cstrdup (win32);
  hash_cwd = hash;
  MALLOC_CHECK;
  lock->release ();
@


1.119
log
@        * path.cc (add_ext_from_sym): Redefine to call `add_ext_from_sym_'.
        (add_ext_from_sym_): New inline function.
@
text
@d538 3
a540 2

  NULL, NULL, NULL,
d606 2
@


1.118
log
@        * path.cc (add_ext_from_sym): New define evaluating `known'suffix'.
        (path_conv::check): Use add_ext_from_sym throughout.
@
text
@d182 13
a194 4
#define add_ext_from_sym(sym) \
  (void)(sym.ext_here && *sym.ext_here && \
  	  ( known_suffix = this->path + sym.extn, \
	    (sym.ext_tacked_on && strcpy (known_suffix, sym.ext_here))))
@


1.117
log
@        * dir.cc (mkdir): Check for case clash.
        * environ.cc: Add extern declaration for `pcheck_case'.
        (check_case_init): New function.
        (struct parse_thing): Add "check_case" option.
        * errno.cc (_sys_nerrlist): Add text for ECASECLASH.
        (strerror): Add case branch for ECASECLASH.
        * fhandler.cc (fhandler_disk_file::open): Check for case clash.
        * path.cc: Add global variable `pcheck_case'.
        (struct symlink_info): Add member `case_clash' and method `case_check'.
        (path_prefix_p_): Call `pathnmatch' instead of `strncasematch'.
        (pathnmatch): New funtion.
        (pathmatch): Ditto.
        (path_conv::check): Add handling for case checking.
        (symlink): Check for case clash.
        (symlink_info::check): Add parameter for case checking.
        Handle case checking.
        (symlink_info::case_check): New method.
        (chdir): Don't use unconverted path if pcheck_case==PCHECK_STRICT.
        * path.h: Add extern declarations for `pathmatch' and
        `pathnmatch'.
        (enum case_checking): New enumeration type describing
        the case checking behaviour of path conversion routines.
        (class path_conv): Add member `case_clash'.
        * syscalls.cc (_link): Check for case clash.
@
text
@d182 5
d339 1
a339 6
		      if (sym.ext_here && *sym.ext_here)
			{
			  known_suffix = this->path + sym.extn;
			  if (sym.ext_tacked_on)
			    strcpy (known_suffix, sym.ext_here);
			}
d364 1
a364 6
		      if (sym.ext_here && *sym.ext_here)
			{
			  known_suffix = this->path + sym.extn;
			  if (sym.ext_tacked_on)
			    strcpy (known_suffix, sym.ext_here);
			}
d434 2
a435 6
  if (sym.ext_here && *sym.ext_here && !(opt & PC_SYM_CONTENTS))
    {
      known_suffix = this->path + sym.extn;
      if (sym.ext_tacked_on)
	strcpy (known_suffix, sym.ext_here);
    }
@


1.116
log
@* path.cc (struct symlink_info): Add extn and ext_tacked_on fields.
(path_conv::check): Only tack on extension if a known one didn't already exist.
(suffix_scan::has): Return pointer to known extension.
(symlink_info::check): Record location of extension, if any.
@
text
@d104 1
d106 3
a108 1
  int check (const char *path, const suffix_info *suffixes);
d113 2
d158 1
a158 1
  if (!strncasematch (path1, path2, len1))
d164 18
d237 1
d274 1
a274 1
      if (opt & PC_SYM_IGNORE)
d311 1
a311 1
	  int len = sym.check (path_copy, suff);
d313 6
a318 2
	  if (!component)
	    path_flags = sym.pflags;
d320 1
a320 4
	  /* If symlink.check found an existing non-symlink file, then
	     it sets the appropriate flag.  It also sets any suffix found
	     into `ext_here'. */
	  if (!sym.is_symlink && sym.fileattr != (DWORD) -1)
d322 7
a328 2
	      error = sym.error;
	      if (component == 0)
d330 16
a345 2
		  fileattr = sym.fileattr;
		  goto fillin;
d347 6
a352 11
	      goto out;	// file found
	    }
	  /* Found a symlink if len > 0.  If component == 0, then the
	     src path itself was a symlink.  If !follow_mode then
	     we're done.  Otherwise we have to insert the path found
	     into the full path that we are building and perform all of
	     these operations again on the newly derived path. */
	  else if (len > 0)
	    {
	      saw_symlinks = 1;
	      if (component == 0 && !need_directory && !(opt & PC_SYM_FOLLOW))
d354 24
a377 5
		  set_symlink (); // last component of path is a symlink.
		  fileattr = sym.fileattr;
		  if (opt & PC_SYM_CONTENTS)
		      strcpy (path, sym.contents);
		  goto fillin;
d379 2
a380 1
	      break;
a382 2
	  /* No existing file found. */

d438 1
a438 1
fillin:
d459 1
d2319 2
a2320 1
  if (allow_winsymlinks)
a2325 2
  else
    win32_path.check (frompath, PC_SYM_NOFOLLOW);
d2329 1
a2329 1
      set_errno (win32_path.error);
d2633 2
a2634 1
symlink_info::check (const char *path, const suffix_info *suffixes)
d2646 2
d2662 4
d2729 44
d2966 2
a2967 1
  else if (!path.has_symlinks () && strpbrk (dir, ":\\") == NULL)
@


1.115
log
@* shared_info.h (mount_info): Remove mnt_ elements.
* thread.h (struct _winsup_t): Add mnt_ elements.
* path.cc (fillout_mntent): Use mnt_ elements from reent_winsup ().
@
text
@d97 1
d102 1
d382 1
a382 1
  if (sym.ext_here && !(opt & PC_SYM_CONTENTS))
d384 3
a386 2
      known_suffix = strchr (this->path, '\0');
      strcpy (known_suffix, sym.ext_here);
d2473 3
d2477 1
a2477 1
    goto done;
d2498 3
d2502 1
a2502 3
  path = in_path;
  eopath = strchr (path, '\0');
  return eopath;
d2584 3
@


1.114
log
@* path.cc (fillout_mntent): Always remove drive root directories from future
consideration by "/cygdrive" reporting.
(cygdrive_getmnt): Avoid reporting removable drives or drives with no media
mounted.
@
text
@d2052 4
a2055 4
  strcpy (mount_table->mnt_fsname, native_path);
  ret.mnt_fsname = mount_table->mnt_fsname;
  strcpy (mount_table->mnt_dir, posix_path);
  ret.mnt_dir = mount_table->mnt_dir;
d2058 1
a2058 1
    strcpy (mount_table->mnt_type, (char *) "user");
d2060 1
a2060 1
    strcpy (mount_table->mnt_type, (char *) "system");
d2062 1
a2062 4
  if ((flags & MOUNT_AUTO))		/* cygdrive */
    strcat (mount_table->mnt_type, (char *) ",noumount");

  ret.mnt_type = mount_table->mnt_type;
d2069 1
a2069 1
    strcpy (mount_table->mnt_opts, (char *) "textmode");
d2071 1
a2071 1
    strcpy (mount_table->mnt_opts, (char *) "binmode");
d2074 1
a2074 1
    strcat (mount_table->mnt_opts, (char *) ",cygexec");
d2076 1
a2076 1
    strcat (mount_table->mnt_opts, (char *) ",exec");
d2078 2
d2081 1
a2081 1
  ret.mnt_opts = mount_table->mnt_opts;
@


1.113
log
@* thread.h (struct _winsup_t): Remove obsolete elements.  Add available_drives
element.
* path.cc (mount_info::getmntent): Report "/cygdrive" drives when mounted
drives are exhausted.
(fillout_mntent): New function.
(mount_item::getmntent): Use fillout_mntent.
(cygdrives_mntent): New function.  Returns next available "/cygdrive".
(setmntent): Initialize available "/cygdrives".
* syscalls.cc: Remove some if 0'ed code.
* times.cc (timezone): Use more descriptive variable name.
@
text
@d2039 8
d2098 4
a2101 2
  if (!available_drives)
    return NULL;
d2103 18
a2120 7
  DWORD mask, drive;
  for (mask = 1, drive = 'a'; drive <= 'z'; mask <<= 1, drive++)
    if (available_drives & mask)
      {
	available_drives &= ~mask;
	break;
      }
d2122 1
a2122 5
  char native_path[3];
  char posix_path[MAX_PATH];
  __small_sprintf (native_path, "%c:", drive);
  __small_sprintf (posix_path, "%s%c", mount_table->cygdrive, drive);
  return fillout_mntent (native_path, posix_path, mount_table->cygdrive_flags);
@


1.112
log
@* path.cc (chdir): Eat trailing whitespace on input path.
@
text
@d80 8
a1730 9
struct mntent *
mount_info::getmntent (int x)
{
  if (x < 0 || x >= nmounts)
    return NULL;

  return mount[native_sorted[x]].getmntent ();
}

d2030 2
a2031 2
struct mntent *
mount_item::getmntent ()
d2034 1
a2034 1
  struct mntent &ret=_reent_winsup()->_ret;
d2055 1
a2055 1
    strcat (mount_table->mnt_type, (char *) ",auto");
d2081 36
a2198 6
#ifdef _MT_SAFE
#define iteration _reent_winsup()->_iteration
#else
static int iteration;
#endif

d2204 1
@


1.111
log
@* path.cc (suffix_scan::next): Avoid searching for foo.lnk twice when input is
"foo".
@
text
@d2745 8
@


1.110
log
@* dir.cc (readdir): Use strcasematch for consistency.
* path.cc (symlink_info): Eliminate known_suffix.
(path_conv::check): Always copy ext_here to end of buffer, if found.
(suffix_scan): Eliminate ext_here, add suffixes_start.
(suffix_scan::has): Eliminate an argument.  Reorganize.  Always return pointer
to end of input path.
(suffix_scan::next): Take a second pass through the suffix list looking for
.lnk.
(symlink_info::check): Eliminate known_suffix usage.
@
text
@d2475 2
a2476 2
      if (suffixes)
	nextstate = SCAN_EXTRALNK;
d2478 5
a2482 1
	nextstate = SCAN_LNK;
@


1.109
log
@* path.cc: Translate scan states from defines to enums.
(suffix_scan): Rename state to nextstate for clarity.
(lnk_match): Change to allow multiple states to indicate that a .lnk has been
matched.
(suffix_scan::has): Eliminate a goto.  Handle .lnk as a special case, since a
.lnk may also need to be tacked on the end of a .lnk.
(suffix_scan::next): Don't increment next state.  Set it specifically.
Recognize new .lnk states.
@
text
@a87 1
  char *known_suffix;
d94 1
a94 1
  symlink_info (): known_suffix (NULL), contents (buf + MAX_PATH + 1) {}
d372 1
a372 3
  if (sym.known_suffix)
    known_suffix = this->path + (sym.known_suffix - path_copy);
  else if (sym.ext_here && !(opt & PC_SYM_CONTENTS))
d2400 2
a2402 2
  SCAN_CHECKEDLNK,
  SCAN_APPENDLNK,
d2407 1
a2407 2
  char *ext_here;
  const suffix_info *suffixes;
d2409 1
a2409 1
  int nullterm;
d2412 1
a2412 1
  char *has (const char *, const suffix_info *, char **);
d2414 1
a2414 1
  int lnk_match () {return nextstate >= SCAN_CHECKEDLNK;}
d2418 1
a2418 1
suffix_scan::has (const char *in_path, const suffix_info *in_suffixes, char **ext_where)
a2419 3
  path = in_path;
  suffixes = in_suffixes;
  nullterm = 0;
d2421 20
a2440 2
  ext_here = *ext_where = strrchr (in_path, '.');
  if (ext_here)
d2442 2
a2443 17
      if (suffixes)
	{
	  /* Check if the extension matches a known extension */
	  for (const suffix_info *ex = in_suffixes; ex->name != NULL; ex++)
	    if (strcasematch (ext_here, ex->name))
	      {
		nextstate = SCAN_JUSTCHECK;
		suffixes = NULL;	/* Has an extension so don't scan for one. */
		return ext_here;
	      }
	}
      /* Didn't match.  Use last resort -- .lnk. */
      if (strcasematch (ext_here, ".lnk"))
	{
	  nextstate = SCAN_HASLNK;
	  suffixes = NULL;
	}
d2446 4
a2449 4
  /* Didn't find a matching suffix. */
  ext_here = *ext_where = strchr (path, '\0');
  nullterm = 1;
  return NULL;
d2462 3
a2464 1
	    strcpy (ext_here, suffixes->name);
d2474 5
a2478 1
      nextstate = SCAN_LNK;
d2481 1
a2481 1
      nextstate = SCAN_APPENDLNK;	/* Skip SCAN_BEG */
d2484 3
a2486 3
    case SCAN_APPENDLNK:
      strcpy (ext_here, ".lnk");
      nextstate = SCAN_CHECKEDLNK;
d2489 4
d2496 1
a2496 2
      if (nullterm && ext_here)
	*ext_here = '\0';
d2526 1
a2526 1
  known_suffix = suffix.has (path, suffixes, &ext_here);
@


1.108
log
@        * path.cc (lnk_suffixes): Remove.
        (class suffix_scan): Add `lnk_state' flag.
        (suffix_scan::lnk_match): Return state of `lnk_state' now.
        (suffix_scan::has): Changed behaviour if file has `.lnk' suffix.
        (suffix_scan::next): Set `lnk_state' where appropriate.
        (symlink_info::check): Fix a wrong `break'.
        * syscalls.cc (chown_worker): Change debug statement to reflect
        lchown fix.
        (lchown): Call chown_worker with `PC_SYM_NOFOLLOW' instead of
        `PC_SYM_IGNORE'.
@
text
@d2397 10
a2406 4
#define SCAN_BEG	0
#define SCAN_LNK	1
#define SCAN_TERM1	2
#define SCAN_JUSTCHECK	3
d2412 1
a2412 2
  int state;
  int lnk_state;
d2418 1
a2418 1
  int lnk_match () {return lnk_state;}
d2427 1
a2427 2
  state = SCAN_BEG;
  lnk_state = 0;
d2437 2
a2438 2
		state = SCAN_JUSTCHECK;
	        suffixes = NULL; /* Has an extension so don't scan for one. */
d2445 1
a2445 1
	  lnk_state = 1;
a2470 1
      state++;
d2473 1
a2473 1
  switch (state++)
d2475 6
d2482 1
a2482 1
      lnk_state = 1;
d2484 2
a2485 2
      /* fall through */
    case SCAN_BEG:
d2487 1
d2572 1
a2572 1
	      continue;
@


1.107
log
@        * path.cc (suffix_scan::has): Change order of conditionals
        to allow checking for .lnk suffixes even if in_suffixes is empty.
@
text
@a98 7
/* These suffixes are the only ones allowed in inner path components. */
suffix_info lnk_suffixes[] =
{
  suffix_info (".lnk", 1),
  suffix_info (NULL)
};

d2407 1
d2413 1
a2413 1
  int lnk_match () {return state == SCAN_LNK + 1;}
d2423 1
d2434 2
a2435 1
		goto known_suffix;
d2441 2
a2442 2
	  state = SCAN_LNK;
	  goto known_suffix;
a2449 4

 known_suffix:
  suffixes = NULL;		/* Has an extension so don't scan for one. */
  return ext_here;
d2473 1
d2562 1
a2562 1
	      break;
@


1.106
log
@* dlopen.c (dlopen): Return NULL when name is NULL (suggested by
chrisiasci@@aol.com).
* cygwin.din: Add a new, internally used export - _check_for_executable.
* dcrt0.cc (dll_crt0_1): Set _check_for_executable for older binaries.  Pass
user_data to premain functions.
* fhandler.cc (fhandler_disk_file::open): Only check for executable if the
linked program is intereested in the executable bit.
(fhandler_disk_file::check_execable_p): Delete.
* fhandler.h (executable_states): New enumeration of various states of
executable bit caring.
(fhandler_base::set_execable_p): New method.
* fhandler_termios.cc (fhandler_termios::line_edit): Flag when a signal has
been sent to the tty.  Return -1 when this is so.
* fhandler_console.cc (fhandler_console::read): Return -1 when signal sending
character encountered.
* path.cc (path_conv::check): Record when path refers to a disk device.  Move
executable extension check here.
(check_sysfile): Accomodate new EXEC path states.
(has_suffix): Remove.
(next_suffix): Remove.
(class suffix_scan): New clas.
(suffix_scan::has): New method.
(suffix_scan:next): New method.
(symlink_info::check): Use suffix_scan method to control for scanning for
suffixes.
* path.h (path_conv::exec_state): New method.
* perprocess.h: Make "C" friendly.
* include/cygwin/version.h: Define CYGWIN_VERSION_CHECK_FOR_S_IEXEC.  Bump
CYGWIN_VERSION_API_MINOR.
* include/sys/cygwin.h: Change premain declarations.
* winsup.h: Move __cplusplus test to after builtin defines.
@
text
@d2429 2
a2430 1
  if (suffixes)
d2432 1
a2432 2
      ext_here = *ext_where = strrchr (in_path, '.');
      if (ext_here)
d2441 6
a2446 6
	  /* Didn't match.  Use last resort -- .lnk. */
	  if (strcasematch (ext_here, ".lnk"))
	    {
	      state = SCAN_LNK;
	      goto known_suffix;
	    }
@


1.105
log
@        * dir.cc (readdir): Fix shortcut==symlink condition.
        * environ.cc: Add extern decl for `allow_winsymlinks'.
        (struct parse_thing): Add entry for `[no]winsymlinks'.
        * path.cc (symlink): Change to be able to create both,
        symlink==shortcut and symlink==systemfile, dependent of
        the setting of `allow_winsymlinks'.
        * security.cc (cygwin_logon_user): Add debug output.
        * shortcut.c: Add defines from path.h.
        (has_exec_chars): Copy from path.h.
        (check_shortcut): Check for executable file condition if not a
        shortcut.
@
text
@d67 1
d416 1
d433 10
d580 1
a580 1
      else if (! from_conv)
a835 1

d1317 1
a1317 1
      if (! path_prefix_p (mi.native_path, pathbuf, mi.native_pathlen))
d1401 1
a1401 1
	 over 256 but is under MAX_PATH! */
d1517 1
a1517 1
  return 0; /* Success! */
d1556 1
a1556 1
  return 0; /* Success! */
d2074 1
a2074 1
  if (! (flags & MOUNT_BINARY))
a2346 30
static __inline char *
has_suffix (const char *path, const suffix_info *suffixes)
{
  assert (path);
  char *ext = strrchr (path, '.');
  if (ext)
    for (const suffix_info *ex = suffixes; ex->name != NULL; ex++)
      if (strcasematch (ext, ex->name))
	return ext;
  return NULL;
}

static __inline__ int
next_suffix (char *ext_here, const suffix_info *&suffixes)
{
  if (!suffixes)
    return 1;

  while (suffixes && suffixes->name)
    if (!suffixes->addon)
      suffixes++;
    else
      {
	strcpy (ext_here, suffixes->name);
	suffixes++;
	return 1;
      }
  return 0;
}

d2355 1
a2355 1
  if (! ReadFile (h, cookie_buf, sizeof (cookie_buf), &got, 0))
d2392 3
a2394 1
      if (!(*pflags & PATH_ALL_EXEC) && has_exec_chars (cookie_buf, got))
d2396 94
a2490 1
  return res;
d2511 1
a2511 1
symlink_info::check (const char *in_path, const suffix_info *suffixes)
d2515 1
a2515 17
  char extbuf[MAX_PATH + 5];
  const char *path = in_path;
  BOOL check_lnk = FALSE;

  if (!suffixes)
    ext_here = NULL;
  else if ((known_suffix = has_suffix (in_path, suffixes)) != NULL)
    {
      suffixes = NULL;
      ext_here = NULL;
    }
  else
    {
restart:
      path = strcpy (extbuf, in_path);
      ext_here = strchr (path, '\0');
    }
d2518 1
d2520 1
a2520 2
  error = 0;
  do
a2521 2
      if (!next_suffix (ext_here, suffixes))
	break;
d2523 1
a2523 1
      fileattr = GetFileAttributesA (path);
d2529 1
a2529 1
	  debug_printf ("GetFileAttributesA (%s) failed", path);
d2540 1
a2540 1
      if (!strcasecmp (path + strlen (path) - 4, ".lnk"))
d2554 1
a2554 1
      h = CreateFileA (path, GENERIC_READ, FILE_SHARE_READ, &sec_none_nih, OPEN_EXISTING,
d2560 1
a2560 1
               && !(res = check_shortcut (path, fileattr, h,
d2566 1
a2566 1
	  if (check_lnk)
d2569 1
a2569 1
	      goto out;
d2574 1
a2574 1
      	       !(res = check_sysfile (path, fileattr, h,
d2582 1
a2582 8
      goto out;
    }
  while (suffixes);
  if (!check_lnk)
    {
      suffixes = lnk_suffixes;
      check_lnk = TRUE;
      goto restart;
d2593 1
a2593 2
		  res, path, contents, pflags);

d2899 1
a2899 1
  int posix_p = ! (strchr (path, ';') || isdrive (path));
d2999 1
a2999 1
      if (! *path)
@


1.104
log
@        * path.cc (symlink): Add a ".lnk" suffix regardless. Add a comment.
@
text
@d2195 4
d2205 1
a2205 4

#if 0
  path_conv win32_path (frompath, PC_SYM_NOFOLLOW);
#else
a2206 4
  strcpy (from, frompath);
  strcat (from, ".lnk");
  path_conv win32_path (from, PC_SYM_NOFOLLOW);
  path_conv win32_topath;
d2209 10
a2218 1
#endif
d2246 26
a2271 1
#if 0
d2278 25
a2302 4
      DWORD written;
      /* This is the old technique creating a symlink.
         Preserved to have a fallback. */
      char buf[sizeof (SYMLINK_COOKIE) + MAX_PATH + 10];
d2304 2
a2305 2
      __small_sprintf (buf, "%s%s", SYMLINK_COOKIE, topath);
      DWORD len = strlen (buf) + 1;
d2307 6
a2312 2
      /* Note that the terminating nul is written.  */
      if (WriteFile (h, buf, len, &written, NULL) || written != len)
d2318 3
a2320 1
	  SetFileAttributesA (win32_path.get_win32 (), FILE_ATTRIBUTE_SYSTEM);
a2322 55
#else
  if (!isabspath (topath))
    {
      getcwd (cwd, MAX_PATH + 1);
      if ((cp = strrchr (from, '/')) || (cp = strrchr (from, '\\')))
	{
	  c = *cp;
	  *cp = '\0';
	  chdir (from);
	}
      backslashify (topath, w32topath, 0);
    }
  if (!cp || GetFileAttributes (w32topath) == (DWORD)-1)
    {
      win32_topath.check (topath, PC_SYM_NOFOLLOW);
      if (!cp || win32_topath.error != ENOENT)
        strcpy (w32topath, win32_topath);
    }
  if (cp)
    {
      *cp = c;
      chdir (cwd);
    }

  h = CreateFileA(win32_path, GENERIC_WRITE, 0, &sec_none_nih,
		  CREATE_NEW, FILE_ATTRIBUTE_NORMAL, 0);
  if (h == INVALID_HANDLE_VALUE)
      __seterrno ();
  else
    {
      DWORD written;
      create_shortcut_header ();
      /* Don't change the datatypes of `len' and `win_len' since
         their sizeof is used later. */
      unsigned short len = strlen (topath);
      unsigned short win_len = strlen (w32topath);
      if (WriteFile (h, shortcut_header, SHORTCUT_HDR_SIZE, &written, NULL)
          && written == SHORTCUT_HDR_SIZE
	  && WriteFile (h, &len, sizeof len, &written, NULL)
	  && written == sizeof len
	  && WriteFile (h, topath, len, &written, NULL)
	  && written == len
	  && WriteFile (h, &win_len, sizeof win_len, &written, NULL)
	  && written == sizeof win_len
	  && WriteFile (h, w32topath, win_len, &written, NULL)
	  && written == win_len)
        {
          CloseHandle (h);
          set_file_attribute (win32_path.has_acls (),
                              win32_path.get_win32 (),
                              S_IFLNK | S_IRWXU | S_IRWXG | S_IRWXO);
          SetFileAttributesA (win32_path.get_win32 (), FILE_ATTRIBUTE_READONLY);
          res = 0;
	}
#endif
@


1.103
log
@        * path.cc (symlink): Keep relative paths relative in the DOS
        path inside of a shortcut. If that's impossible or the target
        path is already absolute save an absolute path.
@
text
@d2205 1
a2205 2
  char from[MAX_PATH];
  unsigned short len = strlen (frompath);
d2207 1
a2207 2
  if (len <= 4 || strcasecmp (from + len - 4, ".lnk"))
    strcpy (from + len, ".lnk");
d2297 3
a2299 1
      len = strlen (topath);
@


1.102
log
@        * path.cc (symlink): Keep relative paths relative in the DOS
        path inside of a shortcut. If that's impossible for some
        reason, save an absolute path.
@
text
@d2212 1
a2212 1
  char cwd[MAX_PATH + 1], *cp, c = 0;
d2268 1
a2268 2
  getcwd (cwd, MAX_PATH + 1);
  if ((cp = strrchr (from, '/')) || (cp = strrchr (from, '\\')))
d2270 8
a2277 3
      c = *cp;
      *cp = '\0';
      chdir (from);
d2279 1
a2279 2
  backslashify (topath, w32topath, 0);
  if (GetFileAttributes (w32topath) == (DWORD)-1)
d2282 1
a2282 1
      if (win32_topath.error != ENOENT)
@


1.101
log
@        * cygerrno.h: Revert previous patch.
        * errno.cc: Ditto.
        * dir.cc: Eliminate `dir_suffixes'.
        (opendir): Remove usage of `dir_suffixes'.
        (rmdir): Ditto.
        * fhandler.cc (fhandler_disk_file::open): Remove usage of
        `inner_suffixes'.
        * path.cc: Rename `inner_suffixes' to `lnk_suffixes'.
        (path_conv::check): Remove usage of `inner_suffixes'.
        (symlink): Ditto.
        (symlink_info::check): Handle checking for `.lnk' in path_conv
        exclusively here.
        (chdir): Remove usage of `dir_suffixes'.
        * shortcut.c: Eliminate debug_printf lines.
        (check_shortcut): Don't set error except on failing ReadFile.
        * spawn.cc: Remove ".lnk" from `std_suffixes'.
        * syscalls.cc (_unlink): Remove usage of `inner_suffixes'.
        Remove ".lnk" from `stat_suffixes'.
        (_rename): Add check for renaming a symlink to keep the ".lnk"
        suffix after renaming.
@
text
@d2211 3
d2242 1
a2249 1
#if 0
d2268 27
a2295 1
      path_conv win32_topath (topath, PC_SYM_NOFOLLOW);
d2297 1
a2297 1
      unsigned short win_len = strlen (win32_topath.get_win32 ());
d2306 1
a2306 1
	  && WriteFile (h, win32_topath.get_win32 (), win_len, &written, NULL)
@


1.100
log
@        * shortcut.c: New file. Provides a C interface to reading of
        Windows shortcuts to avoid compiler flag `-fvtable-thunks'.
        * shortcut.h: Ditto.
        * Makefile.in: Add shortcut.o to DLL_OFILES.
        * cygerrno.h: Provide a C interface to `geterrno_from_win_error' for
        using in shortcut.c.
        * errno.cc (geterrno_from_win_error): Define as extern "C".
        * path.cc (struct symlink_info): Remove methods `check_shortcut' and
        `check_sysfile'.
        (shortcut_header): Move to shortcut.c.
        (shortcut_initalized): Ditto.
        (create_shortcut_header): Ditto.
        (cmp_shortcut_header): Ditto.
        (symlink_info::check_shortcut): Ditto. Reorganize as a plain C function.
        (symlink_info::check_sysfile): Redefine as a global function using the
        same parameter list as `check_shortcut' for clearness.
        (symlink_info::check): Change parameter list for calls to
        `check_shortcut' and `check_sysfile'.
@
text
@d99 1
a99 1
suffix_info inner_suffixes[] =
a100 1
  suffix_info ("", 1),
d275 1
a275 1
	      suff = inner_suffixes;
d2266 1
a2266 1
      path_conv win32_topath (topath, PC_SYM_NOFOLLOW, inner_suffixes);
d2406 1
d2417 1
d2471 7
d2489 1
a2489 1
      break;
d2492 6
a2644 1
  extern suffix_info dir_suffixes[];
d2646 1
a2646 1
  path_conv path (dir, PC_FULL | PC_SYM_FOLLOW, dir_suffixes);
@


1.99
log
@        * fhandler.cc (fhandler_disk_file::open): Use `inner_suffixes' when
        resolving real_path.
        * path.cc (symlink): Ditto for win32_topath.
@
text
@d77 1
a77 3
#include <shlobj.h>
#include <objidl.h>
#include <objbase.h>
a94 2
  int check_shortcut (const char *, DWORD, HANDLE);
  int check_sysfile (const char *, DWORD, HANDLE);
a2193 29
/* The header written to a shortcut by Cygwin or U/WIN. */
#define SHORTCUT_HDR_SIZE	76
static char shortcut_header[SHORTCUT_HDR_SIZE];
static BOOL shortcut_initalized = FALSE;

static void
create_shortcut_header (void)
{
  if (!shortcut_initalized)
    {
      shortcut_header[0] = 'L';
      shortcut_header[4] = '\001';
      shortcut_header[5] = '\024';
      shortcut_header[6] = '\002';
      shortcut_header[12] = '\300';
      shortcut_header[19] = 'F';
      shortcut_header[20] = '\f';
      shortcut_header[60] = '\001';
      shortcut_initalized = TRUE;
    }
}

static BOOL
cmp_shortcut_header (const char *file_header)
{
  create_shortcut_header ();
  return memcmp (shortcut_header, file_header, SHORTCUT_HDR_SIZE);
}

d2332 3
a2334 121
int
symlink_info::check_shortcut (const char *path, DWORD fileattr, HANDLE h)
{
  HRESULT hres;
  IShellLink *psl = NULL;
  IPersistFile *ppf = NULL;
  WCHAR wc_path[MAX_PATH];
  char full_path[MAX_PATH];
  WIN32_FIND_DATA wfd;
  DWORD len = 0;
  int res = 0;

  /* Initialize COM library. */
  CoInitialize (NULL);

  /* Get a pointer to the IShellLink interface. */
  hres = CoCreateInstance (CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
			   IID_IShellLink, (void **)&psl);
  if (FAILED (hres))
    {
      debug_printf ("CoCreateInstance failed");
      goto close_it;
    }
  /* Get a pointer to the IPersistFile interface. */
  hres = psl->QueryInterface (IID_IPersistFile, (void **)&ppf);
  if (FAILED (hres))
    {
      debug_printf ("QueryInterface failed");
      goto close_it;
    }
  /* Load the shortcut. */
  MultiByteToWideChar(CP_ACP, 0, path, -1, wc_path, MAX_PATH);
  hres = ppf->Load (wc_path, STGM_READ);
  if (FAILED (hres))
    {
      debug_printf ("Load failed");
      goto close_it;
    }
  /* Try the description (containing a POSIX path) first. */
  if (fileattr & FILE_ATTRIBUTE_READONLY)
    {
      /* An additional check is needed to prove if it's a shortcut
         really created by Cygwin or U/WIN. */
      char file_header[SHORTCUT_HDR_SIZE];
      DWORD got;

      if (! ReadFile (h, file_header, SHORTCUT_HDR_SIZE, &got, 0))
	{
	  debug_printf ("ReadFile failed");
	  error = EIO;
	  goto close_it_dont_set_error;
	}
      if (got == SHORTCUT_HDR_SIZE && !cmp_shortcut_header (file_header))
        {
	  hres = psl->GetDescription (contents, MAX_PATH);
	  if (FAILED (hres))
	    {
	      debug_printf ("GetDescription failed");
	      goto close_it;
	    }
	  len = strlen (contents);
	}
    }
  /* No description or not R/O: Check the "official" path. */
  if (len == 0)
    {
      /* Convert to full path (easy way) */
      if ((path[0] == '\\' && path[1] == '\\')
	  || (_toupper (path[0]) >= 'A' && _toupper (path[0]) <= 'Z'
	      && path[1] == ':'))
	len = 0;
      else
	{
	  len = GetCurrentDirectory (MAX_PATH, full_path);
	  if (path[0] == '\\')
	    len = 2;
	  else if (full_path[len - 1] != '\\')
	    strcpy (full_path + len++, "\\");
	}
      strcpy (full_path + len, path);
      debug_printf ("full_path = <%s>", full_path);
      /* Set relative path inside of IShellLink interface. */
      hres = psl->SetRelativePath (full_path, 0);
      if (FAILED (hres))
	{
	  debug_printf ("SetRelativePath failed");
	  goto close_it;
	}
      /* Get the path to the shortcut target. */
      hres = psl->GetPath (contents, MAX_PATH, &wfd, 0);
      if (FAILED(hres))
	{
	  debug_printf ("GetPath failed");
	  goto close_it;
	}
    }
  /* It's a symlink.  */
  pflags = PATH_SYMLINK;
  res = strlen (contents);

close_it:
  if (FAILED (hres))
    error = geterrno_from_win_error (HRESULT_CODE (hres), EACCES);

close_it_dont_set_error:
  /* Release the pointer to IPersistFile. */
  if (ppf)
    ppf->Release();
  /* Release the pointer to IShellLink. */
  if (psl)
    psl->Release();
  /* Uninitialize COM library. */
  CoUninitialize ();

  syscall_printf ("%d = symlink.check_shortcut (%s, %s) (%p)",
		  res, path, contents, pflags);
  return res;
}

int
symlink_info::check_sysfile (const char *path, DWORD fileattr, HANDLE h)
d2343 1
a2343 1
      error = EIO;
d2349 1
a2349 1
      pflags = PATH_SYMLINK;
d2355 1
a2355 1
	  error = EIO;
d2373 1
a2373 1
    pflags |= PATH_SOCKET;
d2377 2
a2378 2
      if (!(pflags & PATH_ALL_EXEC) && has_exec_chars (cookie_buf, got))
	pflags |= PATH_EXEC;
a2379 2
  syscall_printf ("%d = symlink.check_sysfile (%s, %s) (%p)",
		  res, path, contents, pflags);
d2465 3
a2467 1
      else if (sym_check == 1 && !(res = check_shortcut (path, fileattr, h)))
d2472 3
a2474 1
      else if (sym_check == 2 && !(res = check_sysfile (path, fileattr, h)))
@


1.98
log
@Add copyright year 2001
@
text
@d2300 1
a2300 1
      path_conv win32_topath (topath, PC_SYM_NOFOLLOW);
@


1.97
log
@        * Makefile.in: Add `-lshell32 -luuid' to link pass for new-cygwin1.dll.
        * autoload.cc: Add LoadDLLinitfunc for ole32.dll.
        Add LoadDLLfuncEx statements for CoInitialize@@4, CoUninitialize@@0
        and CoCreateInstance@@20.
        * dir.cc (dir_suffixes): New datastructure.
        (readdir): Check for R/O *.lnk files to hide the suffix.
        (opendir): Use `dir_suffixes' in path conversion.
        (rmdir): Ditto.
        * fhandler.cc (fhandler_disk_file::fstat): Add S_IFLNK flag
        before calling `get_file_attribute'. Take FILE_ATTRIBUTE_READONLY
        into account only if the file is no symlink.
        * path.cc (inner_suffixes): New datastructure.
        (SYMLINKATTR): Eliminated.
        (path_conv::check): Use `inner_suffixes' on inner path components.
        (shortcut_header): New global static variable.
        (shortcut_initalized): Ditto.
        (create_shortcut_header): New function.
        (cmp_shortcut_header): Ditto.
        (symlink): Create symlinks by creating windows shortcuts. Preserve
        the old code.
        (symlink_info::check_shortcut): New method.
        (symlink_info::check_sysfile): Ditto.
        (symlink_info::check): Check for shortcuts. Move code reading
        old system attribute symlinks into symlink_info::check_sysfile().
        (chdir): Use `dir_suffixes' in path conversion.
        * security.cc (get_file_attribute): Check for S_IFLNK flag.
        Force 0777 permissions then.
        * spawn.cc (std_suffixes): Add ".lnk" suffix.
        * syscalls.cc (_unlink): Use `inner_suffixes' in path conversion.
        Check for shortcut symlinks to eliminate R/O attribute before
        calling DeleteFile().
        (stat_suffixes): Add ".lnk" suffix.
        (stat_worker): Force 0777 permissions if file is a symlink.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Red Hat, Inc.
@


1.96
log
@* cygheap.cc (init_cheap): Move username initialization.
(cygheap_init): Here.
* shared_info.h (mount_info): Add a sys_mount_table_counter field.
(shared_info): Ditto.
* path.cc (mount_info::conv_to_win32_path): Check that our mount table is in
sync with the system mount table and reinitialize it if not.
(mount_info::add_reg_mount): Bump sys_mount_table counters if the system mount
table changes.
(mount_info::del_reg_mount): Ditto.
(mount_info::write_cygdrive_info_to_registry): Ditto.
(mount_info::remove_cygdrive_info_from_registry): Ditto.
@
text
@d60 4
d77 3
d97 2
d102 8
a115 4
#define SYMLINKATTR(x) \
  (((x) & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY)) == \
   FILE_ATTRIBUTE_SYSTEM)

d280 1
a280 1
	      suff = NULL;
d2198 29
d2236 1
d2238 9
d2279 4
d2289 1
a2289 8
      DWORD written;
      if (!WriteFile (h, buf, len, &written, NULL) || written != len)
	{
	  __seterrno ();
	  CloseHandle (h);
	  DeleteFileA (win32_path.get_win32 ());
	}
      else
d2298 30
d2365 171
d2593 10
d2605 4
a2608 1
      if (!(pflags & PATH_SYMLINK) && !SYMLINKATTR (fileattr))
d2618 6
a2623 1
      else
d2625 2
a2626 46
	  char cookie_buf[sizeof (SYMLINK_COOKIE) - 1];
	  DWORD got;

	  if (! ReadFile (h, cookie_buf, sizeof (cookie_buf), &got, 0))
	    error = EIO;
	  else if (got == sizeof (cookie_buf)
		   && memcmp (cookie_buf, SYMLINK_COOKIE,
			      sizeof (cookie_buf)) == 0)
	    {
	      /* It's a symlink.  */
	      pflags = PATH_SYMLINK;

	      res = ReadFile (h, contents, MAX_PATH + 1, &got, 0);
	      if (!res)
		error = EIO;
	      else
		{
		  /* Versions prior to b16 stored several trailing
		     NULs with the path (to fill the path out to 1024
		     chars).  Current versions only store one trailing
		     NUL.  The length returned is the path without
		     *any* trailing NULs.  We also have to handle (or
		     at least not die from) corrupted paths.  */
		  if (memchr (contents, 0, got) != NULL)
		    res = strlen (contents);
		  else
		    res = got;
		}
	    }
	  else if (got == sizeof (cookie_buf)
		   && memcmp (cookie_buf, SOCKET_COOKIE,
			      sizeof (cookie_buf)) == 0)
	    {
	      pflags |= PATH_SOCKET;
	      goto close_and_return;
	    }
	  else
	    {
	      /* Not a symlink, see if executable.  */
	      if (!(pflags & PATH_ALL_EXEC) &&
		  has_exec_chars (cookie_buf, got))
		pflags |= PATH_EXEC;
	    close_and_return:
	      CloseHandle (h);
	      goto file_not_symlink;
	    }
d2780 1
d2782 1
a2782 1
  path_conv path (dir, PC_FULL | PC_SYM_FOLLOW);
@


1.95
log
@Throughout, change 'cygwin_shared.mount' to 'mount_table'.
* child_info.h (child_info): Move shared_h, console_h to cygheap.  Add mount_h.
* cygheap.h (init_cygheap): Add shared_h, console_h.
* cygheap.cc (init_cheap): Initialize heap at a fixed location after the shared
memory regions.  Initialize cygheap->user name here.
* dcrt0.cc (dll_crt0_1): Call getpagesize () to initialize constants.  Remove
cygheap_init since it is done in shared_init now.
(_dll_crt0): Initialize mount_h, remove shared_h and console_h initialization.
* fhandler_console.cc (console_shared_h): Eliminate.
(get_tty_stuff): Use cygheap->console_h rather than console_shared_h.
* heap.cc (heap_init): Use page size constant calculated earlier in
initialization.
* shared.cc: Eliminate cygwin_shared_h.  Add cygwin_mount_h.
(mount_table_init): New function for initializing a user mount table.
(open_shared_file_map): Use constant for shared memory region.  Initialize
cygheap and mount table here.
(open_shared): Improve debugging output.
(shared_info::initialize): Eliminate call to mount.init.
(shared_terminate): Use cygheap->shared_h.  Close cygwin_mount_h.
(open_shared_file_map): Eliminate.
* shared_info.h (mount_info): Add a version field.
(shared_align_past): New macro for calculating location for shared memory
regions.
* sigproc.cc (init_child_info): Eliminate shared_h, console_h.
* spawn.cc (spawn_guts): Pass on cygwin_mount_h iff not a different user.
* syscalls.cc (system_info): New global holding system memory defaults.
(getpagesize): Use system_info.
* uinfo.cc (internal_getlogin): Only fill in user name if nonexistent.
* winsup.h: Declare system_info.
* passwd.cc (read_etc_passwd): Use cygheap->user.name () rather than retrieving
the name again.
@
text
@d982 5
d1493 3
d1513 1
a1513 1
  if ((flags & MOUNT_SYSTEM) == 0)	/* Delete from user registry */
d1521 2
d1599 6
d1640 1
a1640 2
  if ((flags & MOUNT_SYSTEM) == 0 ||
      (mount_table->cygdrive_flags & MOUNT_SYSTEM) != 0)
d1656 6
d1752 1
a1752 1
     if ((bp->flags & MOUNT_SYSTEM) == 0) /* user mount */
d1788 1
a1788 1
     if ((bp->flags & MOUNT_SYSTEM) == 0) /* user mount */
@


1.94
log
@* path.cc (path_conv::check): Detect when path has symlinks.
(symlink_info::check): Remove debugging stuff.
(chdir): Use posix'ized win32 path if cd'ed to a path using symlinks.
@
text
@d105 1
a105 1
  (path_prefix_p (cygwin_shared->mount.cygdrive, (path), cygwin_shared->mount.cygdrive_len))
d108 3
a110 3
  (iscygdrive(path) && isalpha(path[cygwin_shared->mount.cygdrive_len]) && \
   (isdirsep(path[cygwin_shared->mount.cygdrive_len + 1]) || \
    !path[cygwin_shared->mount.cygdrive_len + 1]))
d217 2
a218 3
      error = cygwin_shared->mount.conv_to_win32_path (src, rel_path,
						       full_path,
						       devn, unit, &path_flags);
d362 1
a362 1
	  error = cygwin_shared->mount.conv_to_posix_path (p, tmp_buf, 1);
a950 2
/************************* mount_info class ****************************/

d1035 1
a1035 1
	  rc = cygwin_shared->mount.conv_to_posix_path (dst, posix_path, 0);
d1397 1
a1397 1
      res = cygwin_shared->mount.add_item (native_path, posix_path, mount_flags, FALSE);
d1625 1
a1625 1
      (cygwin_shared->mount.cygdrive_flags & MOUNT_SYSTEM) != 0)
d1627 3
a1629 3
      slashify (cygdrive_prefix, cygwin_shared->mount.cygdrive, 1);
      cygwin_shared->mount.cygdrive_flags = flags;
      cygwin_shared->mount.cygdrive_len = strlen(cygwin_shared->mount.cygdrive);
d1962 1
a1962 1
	  int res = cygwin_shared->mount.add_item (win32path, unixpath, mountflags, TRUE);
d2010 1
a2010 1
  /* Pass back pointers to mount_info strings reserved for use by
d2015 4
a2018 4
  strcpy (cygwin_shared->mount.mnt_fsname, native_path);
  ret.mnt_fsname = cygwin_shared->mount.mnt_fsname;
  strcpy (cygwin_shared->mount.mnt_dir, posix_path);
  ret.mnt_dir = cygwin_shared->mount.mnt_dir;
d2021 1
a2021 1
    strcpy (cygwin_shared->mount.mnt_type, (char *) "user");
d2023 1
a2023 1
    strcpy (cygwin_shared->mount.mnt_type, (char *) "system");
d2026 1
a2026 1
    strcat (cygwin_shared->mount.mnt_type, (char *) ",auto");
d2028 1
a2028 1
  ret.mnt_type = cygwin_shared->mount.mnt_type;
d2035 1
a2035 1
    strcpy (cygwin_shared->mount.mnt_opts, (char *) "textmode");
d2037 1
a2037 1
    strcpy (cygwin_shared->mount.mnt_opts, (char *) "binmode");
d2040 1
a2040 1
    strcat (cygwin_shared->mount.mnt_opts, (char *) ",cygexec");
d2042 1
a2042 1
    strcat (cygwin_shared->mount.mnt_opts, (char *) ",exec");
d2045 1
a2045 1
  ret.mnt_opts = cygwin_shared->mount.mnt_opts;
d2086 1
a2086 1
      res = cygwin_shared->mount.write_cygdrive_info_to_registry (posix_path, flags);
d2090 1
a2090 1
    res = cygwin_shared->mount.add_item (win32_path, posix_path, flags, TRUE);
d2123 1
a2123 1
      res = cygwin_shared->mount.remove_cygdrive_info_from_registry (path, flags);
d2127 1
a2127 1
      res = cygwin_shared->mount.del_item (path, flags, TRUE);
d2152 1
a2152 1
  return cygwin_shared->mount.getmntent (iteration++);
d2643 1
a2643 1
  cygwin_shared->mount.conv_to_posix_path (path, posix_path, 1);
d2653 1
a2653 1
  cygwin_shared->mount.conv_to_posix_path (path, posix_path, 0);
d2671 1
a2671 1
      err = cygwin_shared->mount.conv_to_posix_path (real_path.get_win32 (), resolved, 0);
d2728 1
a2728 1
  for (max_mount_path_len = 7, i = 0; i < cygwin_shared->mount.nmounts; ++i)
d2731 2
a2732 2
		       ? cygwin_shared->mount.mount[i].posix_pathlen
		       : cygwin_shared->mount.mount[i].native_pathlen);
d2944 1
a2944 1
    cygwin_shared->mount.conv_to_posix_path (win32, pathbuf, 0);
@


1.93
log
@* path.h: Add a new constant.
* syscalls.cc (_read): Oscillate errno check.
@
text
@d173 1
d302 1
d320 1
a320 1
	  /* Haven't found a valid pathname component yet.
d421 3
a2379 2
{
debug_printf ("setting exec flag");
a2380 1
}
d2577 11
d2590 2
d2593 1
a2593 1
    cygcwd.set (path, strpbrk (dir, ":\\") != NULL ? NULL : dir);
@


1.92
log
@* include/cygwin/version.h: Bump API to reflect setlogmask.
@
text
@a300 1
	      set_has_symlinks ();
d318 1
a318 1
	  /* Haven't found an existing pathname component yet.
d2375 2
d2378 1
a2574 1

a2576 2
  else if (!path.has_symlinks ())
    cygcwd.set (path, dir);
d2578 1
a2578 29
    {
      char curcwd[MAX_PATH];
      char fulldir[MAX_PATH];
      char *p;
      char **tail[MAX_PATH / 2];
      int len = strlen (dir) + 1;

      if (isabspath (dir))
	p = fulldir;
      else
	{
	  p = strchr (strcpy (fulldir, cygcwd.get (curcwd)), '\0');
	  if (p > fulldir + 1)
	    strcpy (p++, "/");
	 }
      strcpy (p, dir);
      dir = fulldir;
      for (;;)
	{
	  path_conv resolved (dir, PC_SYM_NOFOLLOW | PC_FULL);
	  if (resolved.get_attributes () & FILE_ATTRIBUTE_DIRECTORY)
	    {
	      cygcwd.set (path, dir);
	      break;
	    }
	  char *p = strrchr (dir)
	  tail[i] = 
	}
    }
@


1.91
log
@        * environ.cc (struct parse_thing): Add entry for new CYGWIN option
        `smbntsec'.
        * path.cc (path_conv::check): Check path for being a remote path.
        If so and `allow_smbntsec' is set to FALSE, set has_acls to FALSE.
        * security.cc: Add global definition for `allow_smbntsec'.
        * security.h: Add extern declaration for `allow_smbntsec'.
        * fhandler.cc (fhandler_disk_file::open): Eliminate extern declaration
        of `allow_ntsec'.
        * syscalls.cc: Ditto.
@
text
@d301 1
d319 1
a319 1
	  /* Haven't found a valid pathname component yet.
a2375 2
{
debug_printf ("setting exec flag");
a2376 1
}
d2573 1
d2576 2
d2579 29
a2607 1
    cygcwd.set (path, strpbrk (dir, ":\\") != NULL ? NULL : dir);
@


1.90
log
@* path.cc (normalize_posix_path): Calculate path name length overruns more
dynamically.
(normalize_win32_path): Ditto.
* Makefile.in: Avoid scanning the directory twice for *.d files.
@
text
@d408 6
a413 1
      set_has_acls (volflags & FS_PERSISTENT_ACLS);
@


1.89
log
@* path.cc (normalize_win32_path): Check for explicit use of two slashes at the
beginning of a path.  These should be treated specially regardless of whether
they are UNC paths or old-style //a paths.  Avoid adding cwd to a path if the
path already begins with '/'.
@
text
@a610 5
      if (strlen (dst) + 1 + strlen (src) >= MAX_PATH)
	{
	  debug_printf ("ENAMETOOLONG = normalize_posix_path (%s)", src);
	  return ENAMETOOLONG;
	}
d645 2
d689 5
d773 1
a773 3
	{
	  src += 2;
	}
d800 2
@


1.88
log
@* path.cc (normalize_win32_path): Reorganize logic to accomodate chroot.
Always check for MAX_PATH overrun.  Avoid adding one too many backslashes when
src path begins with a slash.  From Corinna Vinschen.
* winsup.h: Force demangling for dll_crt0 for newer compilers.
@
text
@d715 1
a715 1
  bool beg_src_slash;
d717 1
a717 1
  if (slash_unc_prefix_p (src))
d728 1
a728 1
  else if ((beg_src_slash = SLASH_P (src[0])) && cygheap->root.length ())
d738 1
a738 1
  else if (strchr (src, ':') == NULL)
@


1.87
log
@* path.cc (normalize_win32_path): Handle UNC paths better.
(slash_unc_prefix_p): Allow backslash UNC paths.
@
text
@d715 1
d717 1
a717 25
  if (strchr (src, ':') == NULL && !slash_unc_prefix_p (src))
    {
      if (!cygcwd.get (dst, 0))
	return get_errno ();
      if (SLASH_P (src[0]))
	if (dst[1] == ':')
	  dst[2] = '\0';
	else if (slash_unc_prefix_p (dst))
	  {
	    char *p = strpbrk (dst + 2, "\\/");
	    if (p && (p = strpbrk (p + 1, "\\/")))
		*p = '\0';
	  }
	
      else if (strlen (dst) + 1 + strlen (src) >= MAX_PATH)
	{
	  debug_printf ("ENAMETOOLONG = normalize_win32_path (%s)", src);
	  return ENAMETOOLONG;
	}
      dst += strlen (dst);
      if (!SLASH_P (dst[-1]))
	*dst++ = '\\';
    }
  /* Two leading \'s?  If so, preserve them.  */
  else if (SLASH_P (src[0]) && SLASH_P (src[1]))
d728 1
a728 1
  else if (SLASH_P (src[0]) && !SLASH_P (src[1]) && cygheap->root.length ())
d737 24
@


1.86
log
@* Makefile.in: Use CXX to build the DLL.
* configure.in: Find correct c++ compiler.
* configure: Regenerate.
* path.cc (normalize_posix_path): Put correct drive at beginning of \foo style
paths.
(chdir): Don't send non-posix path to cygcwd.set.
@
text
@d716 1
a716 1
  if (strchr (src, ':') == NULL)
d721 9
a729 1
	dst[2] = '\0';
d892 1
a892 1
	     && ((p = strchr(&path[3], '/')) != NULL));
@


1.85
log
@        * fhandler.cc (fhandler_disk_file::open): Check for buggy CreateFile
        condition.
        * path.cc (path_conv::check): Get file system type in call to
        GetVolumeInformation to check for file systems with buggy CreateFile.
        * path.h (enum path_types): Add PATH_HASBUGGYOPEN.
        (class path_conv): Add methods `has_buggy_open' and
        `set_has_buggy_open'.
@
text
@d716 1
a716 1
  if (!SLASH_P (src[0]) && strchr (src, ':') == NULL)
d720 3
a722 1
      if (strlen (dst) + 1 + strlen (src) >= MAX_PATH)
d2562 1
a2562 1
    cygcwd.set (path, dir);
@


1.84
log
@* path.cc (mount_info::read_cygdrive_info_from_registry): Read system cygdrive
prefix with KEY_READ.
(mount_info::get_cygdrive_info): Ditto.
@
text
@d392 1
d396 2
a397 1
      !GetVolumeInformation (tmp_buf, NULL, 0, &serial, NULL, &volflags, NULL, 0))
d402 1
d409 3
@


1.83
log
@        * path.cc (normalize_posix_path): Special care for root directory
        in case of files beginning with a dot.
@
text
@d525 4
a528 4
        {
          devn = FH_MEM;
          unit = 1;
        }
d530 1
a530 1
        devn = FH_CLIPBOARD;
d532 4
a535 4
        {
          devn = FH_MEM;
          unit = 4;
        }
d612 1
a612 1
        {
d616 1
a616 1
        }
d1520 1
a1520 1
      reg_key r2 (HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS, "SOFTWARE",
d1650 1
a1650 1
  reg_key r2 (HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS, "SOFTWARE",
d2950 1
a2950 1
  	       (const char *) cygheap->root.path (), posix);
@


1.82
log
@        * cygheap.cc (cygheap_root::cygheap_root): New function.
        (cygheap_root::~cygheap_root): Ditto.
        (cygheap_root::operator=): Ditto.
        (cygheap_user::~cygheap_user): Ditto.
        (cygheap_user::set_name): Ditto.
        (cygheap_user::set_logsrv): Ditto.
        (cygheap_user::set_domain): Ditto.
        (cygheap_user::set_sid): Ditto.
        * cygheap.h (cygheap_root): New class.
        (cygheap_user): Ditto.
        (init_cygheap): Change type of `root' member to cygheap_root.
        Add `user' member.
        * dir.cc (opendir): Use new `cygheap_root' class.
        * dcrt0.cc (dll_crt0_1): Use new `cygheap_user' class.
        * fork.cc (fork_parent): Ditto.
        * grp.cc (getgroups): Ditto.
        * passwd.cc (search_for): Ditto.
        * path.cc: Use new `cygheap_root' class throughout.
        * pinfo.h (_pinfo): Remove `use_psid'. Move `username', `psid',
        `logsrv', `domain', `orig_{uid,gid}' and `real_{uid,gid}' to
        cygheap_user class.
        * security.cc: Use new `cygheap_user' class throughout.
        * shared.cc (sec_user): Ditto.
        * sigproc.cc (proc_subproc): Remove copy statements for user
        related information moved to `cygheap_user' class.
        * spawn.cc (spawn_guts): Invalidate current chroot settings
        when creating Windows environment. Use new `cygheap_user' class.
        * syscalls.cc: Use new `cygheap_user' class throughout.
        * uinfo.cc: Ditto.
        * uinfo.cc (internal_getlogin): Change parameters to reflect the
        move of user information to cygheap.
@
text
@d612 5
a616 1
	goto sawdot;
@


1.81
log
@* cygheap.h (init_cygheap): New struct holding values that live in the Cygwin
heap.
* child_info.h (child_info): Change pointer type of cygheap to init_cygheap.
* cygheap.cc (init_cheap): Point cygheap_max after contents of cygheap.  Move
some stuff into cygheap.h.
* dir.cc (opendir): Change to use root and rootlen in cygheap rather than in
myself.
(mkdir): Change to use umask in cygheap rather than in myself.
* path.cc: Ditto, throughout.
* syscalls.cc (_open): Ditto.  Change to use umask in cygheap rather than in
myself.
(chroot): Change to allocate root dir on the cygwin heap.
(umask): Change to use umask in cygheap rather than in myself.
(cygwin_bind): Ditto.
* sigproc.cc (proc_subproc): Don't copy umask or root stuff as this happens
automatically now.
* pinfo.h (_pinfo): Migrate stuff out of here and into init_cheap.
* dcrt0.cc (dll_crt0_1): Call cygheap_init later in startup for first cygwin
process.
@
text
@d112 5
a116 4
#define ischrootpath(path) \
	(cygheap->rootlen && \
	 strncasematch (cygheap->root, path, cygheap->rootlen) && \
	 (path[cygheap->rootlen] == '/' || path[cygheap->rootlen] == '\0'))
d619 1
a619 1
      if (cygheap->rootlen)
d635 1
a635 1
  else if (cygheap->rootlen)
d637 2
a638 2
      strcpy (dst, cygheap->root);
      dst += cygheap->rootlen;
d673 1
a673 1
		      dst - dst_start != (int) cygheap->rootlen)
d722 1
a722 1
      if (cygheap->rootlen)
d731 1
a731 1
  else if (SLASH_P (src[0]) && !SLASH_P (src[1]) && cygheap->rootlen)
d733 1
a733 1
      strcpy (dst, cygheap->root);
d737 1
a737 1
      dst += cygheap->rootlen;
d1001 1
a1001 1
      if (cygheap->rootlen && dst[0] && dst[1] == ':')
d2943 1
a2943 1
	     posix + cygheap->rootlen : posix;
d2945 2
a2946 1
  debug_printf("cygheap->root: %s, posix: %s", cygheap->root, posix);
@


1.80
log
@* path.cc (get_device_number): Allow /dev/ttySn to designate a com port.
@
text
@d113 3
a115 3
	(myself->rootlen && \
	 strncasematch (myself->root, path, myself->rootlen) && \
	 (path[myself->rootlen] == '/' || path[myself->rootlen] == '\0'))
d618 1
a618 1
      if (myself->rootlen)
d634 1
a634 1
  else if (myself->rootlen)
d636 2
a637 2
      strcpy (dst, myself->root);
      dst += myself->rootlen;
d672 1
a672 1
		      dst - dst_start != (int) myself->rootlen)
d721 1
a721 1
      if (myself->rootlen)
d730 1
a730 1
  else if (SLASH_P (src[0]) && !SLASH_P (src[1]) && myself->rootlen)
d732 1
a732 1
      strcpy (dst, myself->root);
d736 1
a736 1
      dst += myself->rootlen;
d1000 1
a1000 1
      if (myself->rootlen && dst[0] && dst[1] == ':')
d2942 1
a2942 1
	     posix + myself->rootlen : posix;
d2944 1
a2944 1
  debug_printf("myself->root: %s, posix: %s", myself->root, posix);
@


1.79
log
@* environ.cc (_addenv): malloc space for setenv if cygwin1.dll is used in
conjunction with older binaries.
(environ_init): Ditto.
* external.cc (get_cygdrive_info): New function.
* external.cc (get_cygdrive_prefixes): Change to use get_cygdrive_info but toss
the user and system flags.
* external.cc (cygwin_internal): Add new CW_GET_CYGDRIVE_INFO case.
* path.cc (mount_info::get_cygdrive_prefixes): Remove method.
* path.cc (mount_info::get_cygdrive_info): New method.  Actually,
get_cygdrive_info is really an enhanced version of get_cygdrive_prefixes
renamed to get_cygdrive_info that also gets the user and system flags.
* shared_info.h (get_cygdrive_prefixes): Remove method.
* shared_info.h (get_cygdrive_info): New method.
* include/cygwin/version.h: Bump minor API version due to adding
CW_GET_CYGDRIVE_INFO to cygwin_internal.
* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_GET_CYGDRIVE_INFO.
@
text
@d537 2
d551 2
@


1.78
log
@* path.cc (mount_info::read_cygdrive_info_from_registry): Use
CYGWIN_INFO_CYGDRIVE_PREFIX, CYGWIN_INFO_CYGDRIVE_DEFAULT_PREFIX, and
CYGWIN_INFO_CYGDRIVE_FLAGS.
* path.cc (mount_info::write_cygdrive_info_to_registry): Use
CYGWIN_INFO_CYGDRIVE_PREFIX and CYGWIN_INFO_CYGDRIVE_FLAGS.
* path.cc (mount_info::remove_cygdrive_info_from_registry): Ditto.
* path.cc (mount_info::get_cygdrive_prefixes): Use CYGWIN_INFO_CYGDRIVE_PREFIX.
* include/cygwin/version.h: Add CYGWIN_INFO_CYGDRIVE_FLAGS,
CYGWIN_INFO_CYGDRIVE_PREFIX, and CYGWIN_INFO_CYGDRIVE_DEFAULT_PREFIX.
@
text
@d1626 2
a1627 1
mount_info::get_cygdrive_prefixes (char *user, char *system)
d1633 7
d1647 7
@


1.77
log
@* exceptions.cc (interruptible): Remove obsolete tests.
(sigreturn): Construct pseudo-frame-pointer so that signal handler can figure
out where to put return address when signals are coming in quickly.
* path.cc (cwdstuff::get): Allow length 0 buffer length when buffer when NULL.
@
text
@d1505 2
a1506 1
  if (r.get_string ("cygdrive prefix", cygdrive, sizeof (cygdrive), "") != 0)
d1517 2
a1518 1
    if (r2.get_string ("cygdrive prefix", cygdrive, sizeof (cygdrive), "") != 0)
d1522 2
a1523 1
	write_cygdrive_info_to_registry ("/cygdrive", MOUNT_AUTO);
d1529 1
a1529 1
	cygdrive_flags = r2.get_int ("cygdrive flags", MOUNT_AUTO);
d1538 1
a1538 1
      cygdrive_flags = r.get_int ("cygdrive flags", MOUNT_AUTO);
d1577 1
a1577 1
  res = r.set_string ("cygdrive prefix", hold_cygdrive_prefix);
d1583 1
a1583 1
  r.set_int ("cygdrive flags", flags);
d1615 2
a1616 2
  int res = r.killvalue ("cygdrive prefix");
  int res2 = r.killvalue ("cygdrive flags");
d1630 1
a1630 1
  int res = r.get_string ("cygdrive prefix", user, MAX_PATH, "");
d1638 1
a1638 1
  int res2 = r2.get_string ("cygdrive prefix", system, MAX_PATH, "");
@


1.76
log
@* path.h (has_exec_chars): Standard function for checking for executable magic
numbers.
* path.cc (symlink_info::check): Use the above function.
* fhandler.cc (fhandler_disk_file::open): Ditto.
@
text
@d2902 5
a2906 1
  if (ulen == 0)
@


1.75
log
@* path.cc (_readlink): Return ENOENT when file does not exist.
@
text
@d2322 4
a2325 4
	      if (!(pflags & PATH_ALL_EXEC) && got >= 2 &&
		  ((cookie_buf[0] == '#' && cookie_buf[1] == '!') ||
		   (cookie_buf[0] == ':' && cookie_buf[1] == '\n') ||
		   (cookie_buf[0] == 'M' && cookie_buf[1] == 'Z')))
d2327 1
@


1.74
log
@* fork.cc (fork): Set sigframe here, since it can pause for a considerable
amount of time.
* environ.cc (_addenv): Add debugging.
* fhandler.cc: Eliminate unneeded include.
* smallprint.c: Ditto.
@
text
@d2374 6
@


1.73
log
@* Makefile.in: add miscfuncs.cc
* miscfuncs.cc: new, miscellaneous functions
* winsup.h: define table-driven tolower/toupper
* environ.cc: use them
* fhandler_console.cc: ditto
* fhandler_termios: ditto
* path.cc: ditto
(strncasematch, strcasematch, strcasestr): move to miscfuncs.cc
@
text
@d173 11
d406 8
@


1.72
log
@* dcrt0.cc (dll_crt0_1): init cygcwd before forkee branch

* environ.cc (conv_start_chars): Cache a table of "first
characters" for environment variables needing conversion.
(getwinenv): Use it.
(environ_init): Create it, also check first chars for TERM and
CYGWIN.

* path.cc: Use lookup table for case insensitive comparisons.
@
text
@d96 1
a96 1
       ((tolower(*(p1))==tolower(*(p2))) && \
d453 1
a453 1
      unit = tolower (w32path[4]) - 'a';
d1154 1
a1154 1
  dst[len++] = tolower (src[0]);
d2398 1
a2398 1
	    *newname = tolower (*nn);
d2430 1
a2430 1
      int ch = tolower(*name);
a2764 94
/********************** String Helper Functions ************************/

static char case_folded[] = {
   0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,
  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,
  32, '!', '"', '#', '$', '%', '&',  39, '(', ')', '*', '+', ',', '-', '.', '/',
 '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?',
 '@@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '[',  92, ']', '^', '_',
 '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', 127,
 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255
};

#define CHXOR ('a' ^ 'A')
#define old_ch_case_eq(ch1, ch2) \
    ({ \
      unsigned char x; \
      !((x = ((unsigned char)ch1 ^ (unsigned char)ch2)) && \
       (x != CHXOR || !isalpha (ch1))); \
    })

// This is about 10% faster than the above logic, on average
#define ch_case_eq(ch1, ch2) (case_folded[(unsigned char)(ch1)] \
				== case_folded[(unsigned char)(ch2)])

/* Return TRUE if two strings match up to length n */
extern "C" int __stdcall
strncasematch (const char *s1, const char *s2, size_t n)
{
  if (s1 == s2)
    return 1;

  n++;
  while (--n && *s1)
    {
      if (!ch_case_eq (*s1, *s2))
	return 0;
      s1++; s2++;
    }
  return !n || *s2 == '\0';
}

/* Return TRUE if two strings match */
extern "C" int __stdcall
strcasematch (const char *s1, const char *s2)
{
  if (s1 == s2)
    return 1;

  while (*s1)
    {
      if (!ch_case_eq (*s1, *s2))
	return 0;
      s1++; s2++;
    }
  return *s2 == '\0';
}

extern "C" char * __stdcall
strcasestr (const char *searchee, const char *lookfor)
{
  if (*searchee == 0)
    {
      if (*lookfor)
	return NULL;
      return (char *) searchee;
    }

  while (*searchee)
    {
      int i = 0;
      while (1)
	{
	  if (lookfor[i] == 0)
	    return (char *) searchee;

	  if (!ch_case_eq (lookfor[i], searchee[i]))
	    break;
	  lookfor++;
	}
      searchee++;
    }

  return NULL;
}

d2777 2
@


1.71
log
@* fhandler_clipboard.cc: new file
* Makefile.in: include fhandler_clipboard.o in DLL_OFILES list.
* fhandler.h: add FH_CLIPBOARD to the devices enum.
(fhandler_dev_clipboard): new
* path.cc (windows_device_names): add "\\dev\\clipboard"
(get_device_number): check for "clipboard"
* dcrt0.cc: declare a few more functions from winuser.h
* dtable.cc (dtable::build_fhandler): check for FH_CLIPBOARD in
switch().
@
text
@d2767 19
d2787 1
a2787 1
#define ch_case_eq(ch1, ch2) \
d2793 4
@


1.70
log
@* Makefile.in: Remove some obsolete stuff.
* dcrt0.cc (dll_crt0_1): Call signal_fixup_after_exec where appropriate.  Set
myself->uid from parent version.  Just use ThreadItem Init method.  Close or
store hexec_proc as appropriate.
(_dll_crt0): Store user_data->forkee here so that proper tests can be made
subsequently.
(do_exit): Remove hExeced stuff.
* environ.cc (environ_init): Accept environ count as well as environ pointer.
* environ.h: Reflect above change.
* pinfo.cc (pinfo_init): Ditto.  Accept environ count.
(fixup_in_spawned_child): Remove.
* spawn.cc (spawn_guts): Move signal code to dll_crt0_1.  Don't suspend execing
process since it is no longer necessary.  Store envc.
* exceptions.cc (signal_fixup_after_exec): New function.
(call_handler): Remove hExeced test.
* child_info.h (cygheap_exec_info): Store envc as well as envp.
(child_info_spawn): Store hexec_proc so that it can be closed in child.
* path.cc (normalize_posix_path): Avoid intermediate use of temporary cwd buf.
(normalize_win32_path): Ditto.
(cwdstuff::get_initial): Always set lock.
* sigproc.h: Remove hExeced.
* strace.cc (strace::vsprntf): Modify to accomodate for lack of hExeced.
* thread.cc (MTinterface::Init): Merge Init1 and ClearReent into this method.
(MTinterface::Init1): Eliminate.
(MTinterface::ClearReent): Eliminate.
* thread.h: Reflect above changes.
* include/sys/strace.h (strace): Make microseconds() public.  Make various
functions 'regparm', throughout.
* pinfo.h (_pinfo): Inline simple signal manipulation functions.  Requires
inclusion of thread.h which was removed from .cc files, where appropriate.
throughout.
* pinfo.cc: Eliminate signal manipulation functions.
(_pinfo::exit): Calculate total rusage for exiting process here.
* cygheap.cc (size2bucket): Eliminate.
(init_buckets): Ditto.
(_cmalloc): Calculate size and bits in a loop rather than going through a
function call.
(_crealloc): Use stored array index to calculate allocated size.
* spawn.cc (spawn_guts): Use _pinfo exit method to exit, calculating cpu usage.
@
text
@d434 1
d509 2
@


1.69
log
@* exceptions.cc (set_console_handler): Don't allocate
console_handler_thread_waiter.  It is obsolete.
(ctrl_c_handler): Don't use console_handler_thread_waiter.
* path.cc (hash_path_name): Fix handling of relative names.  Make case
insensitive.
* path.h (suffix_info): Use initializers.
* pinfo.h (_pinfo): Avoid initializers for null case.
* resource.cc (fill_rusage): Zero rest of rusage structure.
* security.cc (set_process_privileges): Don't reopen parent process.  Just use
hMainProc.
* signal.cc (signal): Track when a signal handler has been used.
(sigaction): Ditto.
* sigproc.cc (pchildren): Use default initializer.
(zombies): Ditto.
(sigproc_terminate): Avoid closing handles that will be closed on exit anyway.
(wait_sig): Send signal to "parent" on EXECing, not FORKing.
(wait_subproc): Send SIGCHLD here rather than in proc_wait to avoid potential
muto conflicts.
* sigproc.h (sigthread): Don't initialize to zero.  It's the default.
* spawn.cc (spawn_guts): Fill in resources from exec parent prior to
termination.
* sync.h (muto): Don't initialize to zero.
* syscalls.cc (close_all_files): Use one lock around entire loop and call
fhandler close/release stuff directly.
(_read): Don't use ready_for_read if there are not signal handlers active.
* dcrt0.cc (dll_crt0_1): Fix display of "title".
(do_exit): Use pinfo exit method to exit.
(__api_fatal): Ditto.
* exceptions.cc (signal_exit): Ditto.
* fork.cc (fork_child): Remove debugging stuff.  Use pinfo_fixup_after fork in
place of exec_fixup_after_fork.
* pinfo.cc (pinfo_fixup_after_fork): New method.
(pinfo_fixup_in_spawned_child): Ditto.
(_pinfo::exit): New method.
(_pinfo::init): Remove recursion.  Detect pathological case where pinfo
structure already exists for new pid.
* pinfo.h (_pinfo): Reorganize slightly.  Add new method and new function
declarations.
* sigproc.cc (proc_exists): Previous simplification was a little to simple.
Try harder to detect if a process exists.
(proc_terminate): Use PID_EXITED setting to determine if process is still
around.
(WFSO): Remove debugging statement.
(WFMO): Ditto.
* spawn.cc (exec_fixup_after_fork): Eliminate.
(spawn_guts): Always set old_title to NULL.  Is it really needed?  Move
hexec_proc to pinfo.cc.  Call pinfo_fixup_in_spawned_child to eliminate handle
link after a spawn.
* include/sys/cygwin.h: Remove PID_NOT_IN_USE.  Add PID_EXITED.
@
text
@a64 1
#include "thread.h"
d576 1
a576 2
      char cwd[MAX_PATH];
      if (!cygcwd.get (cwd))
d578 1
a578 1
      if (strlen (cwd) + 1 + strlen (src) >= MAX_PATH)
a582 1
      strcpy (dst, cwd);
d681 1
a681 2
      char cwd[MAX_PATH];
      if (!cygcwd.get (cwd, 0))
d683 1
a683 1
      if (strlen (cwd) + 1 + strlen (src) >= MAX_PATH)
a687 1
      strcpy (dst, cwd);
d689 1
a689 1
      if (!*cwd || !SLASH_P (dst[-1]))
d2773 1
a2773 1
int __stdcall
d2790 1
a2790 1
int __stdcall
d2805 1
a2805 1
char * __stdcall
d2879 2
a2883 1
  lock->acquire ();
d2898 1
@


1.68
log
@* child_info: Bump child_info "version".
(child_info): Move some fields from child_info_spawn to here.
* cygheap.cc: Make cygheap pointers NOCOPY.
* dcrt0.cc (dll_crt0_1): Copy cygwin heap here regardless of whether we've been
forked or execed.
* dtable.cc (dtable::fixup_after_fork): Just release close-on-exec fds.
* exceptions.cc (stackdump): Respond to C warning.
* fork.cc: Reorganize to minimize stack copying.
(fork_child): New function.
(fork_parent): Ditto.
(sync_with_child): Don't suspend the forkee.
(sync_with_parent): Ditto.  Make into a function.
* heap.cc (heap_init): Add some debugging output.
* path.cc (path_conv::check): Add an assertion.
(has_suffix): Ditto.
* security.cc (get_pw_sid): Defend against NULL.
* sigproc.cc (proc_subproc): Fix debugging output.
(wait_sig): Ditto.
* strace.cc: Make statics NO_COPY throughout.
(strace::vsprntf): Defend against NULL.
@
text
@d2399 2
a2400 2
	  if (islower (*nn))
	    *newname = toupper (*nn);
d2418 1
a2418 1
      if (*name != '\\')
d2423 1
a2423 1
	  hash = hash_path_name (hash, "\\");
d2432 2
a2433 1
      hash += *name + (*name << 17);
@


1.67
log
@* path.cc (cwdstuff::get): Set EINVAL when length is zero.
@
text
@d73 1
d194 1
d2168 1
@


1.66
log
@* path.cc (mount_info::cygdrive_posix_path): Handle e:foo construction
correctly.
@
text
@d2940 7
d2965 1
a2965 1
      if (need_posix && !buf)
d2973 4
a2976 2
  syscall_printf ("(%s) = cwdstuff::get (%p, %d, %d, %d)",
		  buf, buf, ulen, need_posix, with_chroot);
@


1.65
log
@* dtable.cc (set_std_handle): Use std_consts array to control SetStdHandle
settings.
(dtable::fixup_after_fork): Ditto.
* exceptions.cc (set_sig_errno): Remove some debugging output.
* path.cc (path_conv::check): Don't OR need_directory with flags sent to
symlink_info::check.
(symlink_info::check): Use PATH_ALL_EXEC to determine when a file is
executable.
* path.h (path_types): Add PATH_ALL_EXEC.
(isexec): Use PATH_ALL_EXEC so that cygexec types will be considered
executable.
* pinfo.h (_pinfo): Add a process handle that is kept open throughout the life
of a cygwin pid.
* sigproc.cc (proc_exists): Remove hopefully obsolete stuff.
(proc_subproc): Set up process handle that is kept open throughout the life of
a cygwin pid.  Reorganize PROC_WAIT stuff to use common code.
(proc_terminate): Close pid lifetime process handle.
(checkstate): Cleanup.
(stopped_or_terminated): Move zombie cleanup.
(remove_zombie): To here.
* spawn.cc (spawn_guts): Reorganize reparenting code for 1247th time.
@
text
@d1159 1
d1161 5
a1165 1
      strcpy (dst + len, src + 3);
@


1.64
log
@        * fhandler.h (fhandler_dev_mem): Add methods mmap, munmap and msync.
        Add `unit' member.
        * fhandler_mem.cc (fhandler_dev_mem): Initialize `unit' as well.
        (init): Care for differences between /dev/mem, /dev/kmem (not
        implemented yet) and /dev/port.
        (open): Change debug message to reflect the device.
        (mmap): New function.
        (munmap): Ditto.
        (msync): Ditto.
        (fstat): Use unit when setting st_dev in stat structure.
        * mmap.cc (mmap): Handle MAP_ANONYMOUS flag.
        Change error handling slightly.
        * path.cc (get_device_number): Handle /dev/port.
@
text
@d260 1
a260 1
	      sym.pflags = path_flags | need_directory;
d2297 1
a2297 1
	      if (!(pflags & (PATH_EXEC | PATH_CYGWIN_EXEC)) && got >= 2 &&
@


1.63
log
@* net.cc (set_socket_inheritance): Rename from duplicate_socket.  Use NT
specific call when appropriate.
(__set_winsock_errno): Rename from set_winsock_errno.  Accept function and line
as arguments.
* path.cc (path_conv::check): Continue the neverending battle to make cygwin
properly understand that path specs ending in a slash require that the path
refer to a directory.  Windows does not do this by default.
(symlink_info::check): Remove ENOTDIR test.  Move it to path_conv::check.
* path.h: Remove obsolete constant.
* winsup.h (set_winsock_errno): New macro.
@
text
@d503 9
a511 1
        devn = FH_MEM;
@


1.62
log
@* cygheap.cc (cygheap_init): Born again function.
(_cmalloc): Reorganize to accomodate muto locking.
(_cfree): Use muto lock to avoid multi-thread problems.
* cygheap.h (incygheap): Just use cygheap_max to find upper cygwin heap bounds.
* dcrt0.cc (dll_crt0_1): Reinstitute cygheap_init call.
* path.cc (getcwd): Just return cwdstuff::get result, allowing correct handling
of negative length.
(cwdstuff::get): Malloc a buffer if one is not available.
@
text
@d171 1
a192 1
      DWORD need_directory = 0;
d196 2
a197 2
	  if (strcmp (p, "/") == 0 || strcmp (p, "/.") == 0)
	    need_directory = PATH_NEEDDIR;
d200 2
a201 2
	       (strcmp (p, "\\") == 0 || strcmp (p, "\\.") == 0))
	need_directory = PATH_NEEDDIR;
d288 1
a288 1
	      if (component == 0 && !(opt & PC_SYM_FOLLOW))
d366 12
a2201 1
  int needdir;
a2219 7
  if (!(pflags & PATH_NEEDDIR))
    needdir = 0;
  else
    {
      pflags &= ~PATH_NEEDDIR;
      needdir = 1;
    }
a2233 16
	}

      /* Windows allows path\. even when `path' isn't a directory.
	 Detect this scenario and disallow it, since it is non-UNIX like.
	 FIXME: This code actually checks for things like foo/ and foo/..
	 even though those usages have already been (erroneously?) eaten
	 by cygwin_shared->mount.conv_to_win32_path in path_conv::check. */

      char *p = strrchr (path, '\\');
      if (p && !(fileattr & FILE_ATTRIBUTE_DIRECTORY) &&
	  (needdir || *++p == '\0' ||
	   (*p == '.' && (*++p == '\0' || (*p == '.' && p[1] == '\0')))))
	{
	  debug_printf ("%s is a non-directory", path);
	  error = ENOTDIR;
	  goto file_not_symlink;
@


1.61
log
@        * Makefile.in: Add fhandler_mem.o to the dependencies.
        * dtable.cc (dtable::build_fhandler): Add case for FH_MEM.
        * fhandler.h: Add FH_MEM device type.  Add class fhandler_dev_mem.
        * fhandler_mem.cc: New file. Implementation of class fhandler_dev_mem.
        * path.cc: Add /dev/mem to windows_device_names.
        (get_device_number): Add FH_MEM type.
@
text
@d2439 1
a2439 30
  char *res;
  char *usebuf, uselen;

  if (buf != NULL)
    {
      usebuf = buf;
      uselen = TRUE;
    }
  else
    {
      if (ulen >= 0)
	uselen = TRUE;
      else
	{
	  uselen = FALSE;
	  ulen = MAX_PATH + 1;
	}

      usebuf = (char *) malloc (ulen);
      usebuf [ulen - 1] = '\0';
    }

  res = cygcwd.get (usebuf, 1, 1, ulen);

  if (res && !uselen)
    usebuf = (char *) realloc (usebuf, strlen (usebuf) + 1);
  else if (!res && buf == NULL)
    free (usebuf);

  return res;
d2455 1
d2504 1
d2938 1
a2938 2
  size_t len = ulen;

d2957 2
d2966 2
a2967 1
		  buf, buf, len, need_posix, with_chroot);
d2980 1
@


1.60
log
@* path.cc (symlink_info::check): Set executable bit for a file if the first two
characters are 'MZ' to mirror spawn_guts check.
@
text
@d420 1
d490 2
@


1.59
log
@* path.h: Create new input path flag PATH_NEEDDIR.
* path.cc (path::check): Detect trailing slash before converting to windows
path.  Tell symlink_info::check to check for directory if one is found.
(symlink_info::check): Set errno when path is not a directory if pflags &
PATH_NEEDDIR.
@
text
@d2100 1
a2100 1
  h = CreateFileA(win32_path.get_win32 (), GENERIC_WRITE, 0, &sec_none_nih,
d2300 2
a2301 1
		   (cookie_buf[0] == ':' && cookie_buf[1] == '\n')))
@


1.58
log
@* path.cc (mount_info::read_mounts): Don't delete mount entries of which mount
points have the cygdrive prefix.
* (mount_info::add_reg_mount): Properly catch errors on registry operations.
* (mount_info::write_cygdrive_info_to_registry): Ditto.
* (mount_info::del_reg_mount): Cosmetic changes to be consistent with other
methods.
* (mount_info::add_item): Check arguments more precisely.  Increment nmounts
only when registry operations succeed.
@
text
@d192 10
d260 1
a260 1
	      sym.pflags = path_flags;
a329 1
      char *p;
d2187 1
d2206 7
d2237 2
a2238 1
	  (*++p == '\0' || (*p == '.' && (*++p == '\0' || (*p == '.' && p[1] == '\0')))))
@


1.57
log
@* path.cc (normalize_posix_path): Fix more slashdot madness.
@
text
@d1272 1
a1272 1
  int found_cygdrive = FALSE;
d1278 1
a1278 1
  for (DWORD i = 0; ; i++)
d1287 1
a1287 1
      LONG err = RegEnumKeyEx (key, i, posix_path, &posix_path_size, NULL,
d1290 1
a1290 1
      if (err == ERROR_NO_MORE_ITEMS)
d1292 1
a1292 1
      else if (err != ERROR_SUCCESS)
d1294 1
a1294 1
	  debug_printf ("RegEnumKeyEx failed, error %d!\n", err);
a1297 6
      if (iscygdrive (posix_path))
	{
	  found_cygdrive = TRUE;
	  continue;
	}

d1306 1
a1306 1
      int res = cygwin_shared->mount.add_item (native_path, posix_path, mount_flags, FALSE);
a1309 21

  if (!found_cygdrive)
    return;

loop:
  for (i = 0; ;i++)
    {
      posix_path_size = MAX_PATH;
      LONG err = RegEnumKeyEx (key, i, posix_path, &posix_path_size, NULL,
			  NULL, NULL, NULL);

      if (err != ERROR_SUCCESS)
	break;

      if (iscygdrive (posix_path))
	{
	  /* This shouldn't be in the mount table. */
	  (void) r.kill (posix_path);
	  goto loop;
	}
    }
d1352 2
d1362 3
a1364 1
      reg_user.kill (posix_path);
d1370 4
a1373 2
      subkey.set_string ("native", native_path);
      subkey.set_int ("flags", mountflags);
a1383 6
      if (reg_sys.get_key () == INVALID_HANDLE_VALUE)
	{
	  set_errno (EACCES);
	  return -1;
	}

d1385 3
a1387 1
      reg_sys.kill (posix_path);
d1393 4
a1396 2
      subkey.set_string ("native", native_path);
      subkey.set_int ("flags", mountflags);
d1400 3
d1412 1
a1412 1
  int killres;
d1418 1
a1418 1
      killres = reg_user.kill (posix_path);
d1427 1
a1427 8

      if (reg_sys.get_key () == INVALID_HANDLE_VALUE)
	{
	  set_errno (EACCES);
	  return -1;
	}

      killres = reg_sys.kill (posix_path);
d1430 1
a1430 1
  if (killres != ERROR_SUCCESS)
d1432 1
a1432 1
      __seterrno_from_win_error (killres);
d1517 7
a1523 1
  r.set_string ("cygdrive prefix", hold_cygdrive_prefix);
d1693 2
a1694 1
      (!slash_unc_prefix_p (native) && !isabspath (native)))
d1736 1
a1736 1
  if (i == nmounts)
d1738 2
a1739 7
      if (nmounts < MAX_MOUNTS)
	i = nmounts++;
      else
	{
	  set_errno (EMFILE);
	  return -1;
	}
d1745 2
d1981 1
a1981 9
    {
      if (iscygdrive (posix_path))
	{
	  set_errno (EINVAL);
	  return res;	/* Don't try to add cygdrive prefix. */
	}

      res = cygwin_shared->mount.add_item (win32_path, posix_path, flags, TRUE);
    }
@


1.56
log
@* path.cc (normalize_posix_path): Correctly deal with a "." parameter.
@
text
@d554 1
a554 5
	{
	  if (dst == dst_start + 1)
	    dst--;
	  goto sawdot;
	}
d602 5
a606 1
		    goto done;
@


1.55
log
@* dcrt0.cc (dll_crt0_1): Initialize thread and debug stuff before handling
exec/fork.
* dtable.cc (dtable::fixup_after_exec): Always clear out the read ahead buffer
whether closing or adjusting.
* path.cc (chdir): Avoid a compiler warning.
@
text
@d596 2
a597 2
	      while (isslash (*src))
		src++;
d605 3
a607 1
		  if (!src[1] || !isslash (src[1]))
d610 2
a613 2
		  if (src[2] && !isslash (src[2]))
		    break;
d626 1
@


1.54
log
@* path.cc (chdir): Use the full path for cwd_win32.  Consider attempts to chdir
to strings of dots > 2 to be an error.  Pass 'dir' argument to cygcwd.set.
(cwdstuff::set): Need to treat arguments from chdir differently.
* path.h (cwdstuff): Add an argument to set.
@
text
@d2510 1
a2510 1
  int len = strlen (p);
@


1.53
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@d2491 1
a2491 1
  path_conv path (dir);
d2500 17
d2532 1
a2532 1
    cygcwd.set (path);
d2940 1
a2940 1
cwdstuff::set (char *win32_cwd)
d2942 2
d2951 4
a2954 1
  hash = hash_path_name (0, win32);
d2956 2
a2957 3
  /* Turn from Win32 style to our style.  */
  char temp[MAX_PATH];
  cygwin_shared->mount.conv_to_posix_path (win32, temp, 0);
d2959 1
a2959 2
  posix = (char *) crealloc (posix, strlen (temp) + 1);
  strcpy (posix, temp);
@


1.52
log
@Split out tty and shared_info stuff into their own headers and use throughout.
Include sys/termios.h for files which need it.
* tty.h: New file.
* shared_info.h: New file.
* fhandler.h: Move inline methods that rely on tty stuff to
fhandler_console.cc.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Set
output_done_event immediately after reading data to speed up tty output
processing.
(process_output): Set write_error to errno or zero.
(fhandler_tty_slave::write): Check previous write error prior to writing to
slave end of pipe.  This allows tty output to be slightly less synchronous.
* fhandler_console.cc (fhandler_console::tcsetpgrp): Moved here from
fhandler.h.
(fhandler_console::set_input_state): Ditto.
@
text
@d60 2
a69 1
#include "tty.h"
d71 2
@


1.51
log
@* path.cc (cwdstuff::get_initial): Keep caching alive.
(mount_info::conv_to_win32_path): Fill out relative path in failing case.
@
text
@d68 2
@


1.50
log
@* path.cc (normalize_posix_path): Deal with error return from cygcwd.get.
(normalize_win32_path): Ditto.
(mount_info::conv_to_win32_path): Ditto.
(cwdstuff::get): Set buf to NULL on error.
@
text
@d1051 3
a1053 1
      if (path_prefix_p (cwd_win32, dst, cwdlen))
d2890 3
d2894 1
a2895 2

  int i;
@


1.49
log
@* path.cc (readlink): 'max' should be a 'min' or we'll suffer buffer overflow.
@
text
@d539 2
a540 1
      cygcwd.get (cwd);	/* FIXME: check return value */
d643 2
a644 1
      cygcwd.get (cwd, 0);	/* FIXME: check return value */
d1048 2
a1049 1
      cygcwd.get (cwd_win32, 0); /* FIXME: check return value someday */
d2956 4
a2959 1
    set_errno (ERANGE);
@


1.48
log
@* path.cc (cwd_win32): Eliminate.
(cwd_posix): Eliminate.
(cwd_hash): Eliminate.
(cwdstuff::init): Rename from cwd_init.
(cwdstuff::fixup_after_exec): Rename from cwd_fixup_after_exec.
(cwdstuff::get): Rename from get_cwd_inner.
(normalize_posix_path): Eliminate cwd argument.  Just calculate when necessary.
(normalize_win32_path): Ditto.
(mount_info::conv_to_win32_path): Eliminate cwd retrieval here.
(mount_info::conv_to_posix_path): Ditto.
(hash_path_name): Accomodate additional methods in cwdstuff.
(get_cwd_win32): Eliminate.
(getcwd): Use cwdstuff methods.  Properly handle case where buf == NULL and len
< 0.
(cwdstuff::get_hash): New method.
(cwdstuff::get_initial): New method.
(cwdstuff::set): New method.
(cwdstuff::get): New method.
(cwdstuff::copy): New method.
* path.h: Move cwdstuff struct here.  Add a bunch of stuff to cwdstuff.  Make
cygcwd an extern.
* spawn.cc (spawn_guts): Use copy method to get copies of cwd info to pass to
execed process.
* dcrt0.cc (dll_crt0_1): Use cygcwd methods for cwd initialization.
@
text
@d2356 1
a2356 1
  int len = max (buflen, (int) strlen (pathbuf.get_win32 ()));
@


1.47
log
@* path.cc (readlink): Check if buffer length is positive.  Truncate output to
buffer length.  Don't terminate buffer with '\0'.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Cygnus Solutions.
d18 1
a18 1
   - / is equivalent to \
a20 3
   - Paths containing a : are not translated (paths like
   /foo/bar/baz:qux: don't make much sense but having the rule written
   this way allows one to use strchr).
a25 14
   A possible future enhancement would be to allow people to
   disable/enable the mount table handling to support pure Win32
   pathnames.  Hopefully this won't be needed.  The suggested way to
   do this would be an environment variable because
   a) we need something that is inherited from parent to child,
   b) environment variables can be passed from the DOS shell to a
   cygwin app,
   c) it allows disabling the feature on an app by app basis within
   the same session (whereas playing about with the registry wouldn't
   -- without getting too complicated).  Example:
   CYGWIN=pathrules[=@@]{win32,posix}.  If CYGWIN=pathrules=win32,
   mount table handling is disabled.  [The intent is to have CYGWIN be
   a catchall for tweaking various cygwin.dll features].

d32 2
a33 9
   decisions.

   / and \ are treated as equivalent.  One or the other is prefered in
   certain situations (e.g. / is preferred in result of getcwd, \ is
   preferred in arguments to Win32 api calls), but this code will
   translate as necessary.

   Apps wishing to translate to/from pure Win32 and POSIX-like
   pathnames can use cygwin_foo.
d47 1
a47 1
   c: means c:\.
d69 1
a69 2
static int normalize_win32_path (const char *cwd, const char *src, char *dst);
static char *getcwd_inner (char *buf, size_t ulen, int posix_p, int with_chroot);
a72 3
static int get_cwd_win32 ();

static NO_COPY const char escape_char = '^';
d88 1
a88 1
/********************** Path Helper Functions *************************/
d98 14
a125 85
/* Determine if path prefix matches current cygdrive */
#define iscygdrive(path) \
  (path_prefix_p (cygwin_shared->mount.cygdrive, (path), cygwin_shared->mount.cygdrive_len))

#define iscygdrive_device(path) \
  (iscygdrive(path) && isalpha(path[cygwin_shared->mount.cygdrive_len]) && \
   (isdirsep(path[cygwin_shared->mount.cygdrive_len + 1]) || \
    !path[cygwin_shared->mount.cygdrive_len + 1]))

/******************** Directory-related Support **************************/

/* Cache getcwd value.  FIXME: We need a lock for these in order to
   support multiple threads.  */

#define TMPCWD	((char *) alloca (MAX_PATH + 1))

struct cwdstuff
{
  char *posix;
  char *win32;
  DWORD hash;
  muto *lock;
};

cwdstuff cwd;

char * __stdcall
cwd_win32 (char *buf)
{
  char *ret;
  cwd.lock->acquire ();
  if (cwd.win32 == NULL)
    ret = NULL;
  else if (buf == NULL)
    ret = cwd.win32;
  else
    ret = strcpy (buf, cwd.win32);
  cwd.lock->release ();
  return ret;
}

char * __stdcall
cwd_posix (char *buf)
{
  char *ret;
  cwd.lock->acquire ();
  if (cwd.posix == NULL)
    ret = NULL;
  else if (buf == NULL)
    ret = cwd.posix;
  else
    ret = strcpy (buf, cwd.posix);
  cwd.lock->release ();
  return ret;
}

DWORD __stdcall
cwd_hash ()
{
  DWORD hashnow;
  cwd.lock->acquire ();
  hashnow = cwd.hash;
  cwd.lock->release ();
  return hashnow;
}

void __stdcall
cwd_init ()
{
  cwd.lock = new_muto (FALSE, "cwd");
}

void __stdcall
cwd_fixup_after_exec (char *win32, char *posix, DWORD hash)
{
  cwd.win32 = win32;
  cwd.posix = posix;
  cwd.hash = hash;
}

#define ischrootpath(path) \
	(myself->rootlen && \
	 strncasematch (myself->root, path, myself->rootlen) && \
	 (path[myself->rootlen] == '/' || path[myself->rootlen] == '\0'))

d525 1
a525 1
normalize_posix_path (const char *cwd, const char *src, char *dst)
d530 1
a530 1
  syscall_printf ("cwd %s, src %s", cwd, src);
d538 2
d633 1
a633 1
normalize_win32_path (const char *cwd, const char *src, char *dst)
d641 2
a912 3
  char cwd[MAX_PATH];
  getcwd_inner (cwd, MAX_PATH, TRUE, 0); /* FIXME: check rc */

d927 1
a927 1
      rc = normalize_win32_path (cwd_win32 (TMPCWD), src_path, dst);
d970 1
a970 4
  /* No need to fetch cwd if path is absolute.  */
  isrelpath = !isslash (*src_path);

  rc = normalize_posix_path (cwd, src_path, pathbuf);
d979 2
a1040 4
  unsigned cwdlen;
  cwdlen = 0;	/* avoid a (hopefully) bogus compiler warning */
  char *cwd_win32_now;
  cwd_win32_now = cwd_win32 (TMPCWD);
d1043 1
a1043 2
  else if (isrelpath &&
	   path_prefix_p (cwd_win32_now, dst, cwdlen = strlen (cwd_win32_now)))
d1045 8
a1052 7
      size_t n = strlen (dst);
      if (n < cwdlen)
	strcpy (win32_path, dst);
      else
	{
	  if (n == cwdlen)
	    dst += cwdlen;
d1054 5
a1058 1
	    dst += isdirsep (cwd_win32_now[cwdlen - 1]) ? cwdlen : cwdlen + 1;
d1060 7
a1066 6
	  memmove (win32_path, dst, strlen (dst) + 1);
	  if (!*win32_path)
	    {
	      strcpy (win32_path, ".");
	      if (trailing_slash_p)
		strcat (win32_path, "\\");
d1178 1
a1178 9
  char cwd[MAX_PATH];

  /* No need to fetch cwd if path is absolute. */
  if (relative_path_p)
    getcwd_inner (cwd, MAX_PATH, 0, 0); /* FIXME: check rc */
  else
    strcpy (cwd, "/"); /* some innocuous value */

  int rc = normalize_win32_path (cwd, src_path, pathbuf);
d2410 1
a2410 1
      if (*name != '\\' && (cwd_win32 (TMPCWD) == NULL || get_cwd_win32 ()))
d2412 1
a2412 1
	  hash = cwd_hash ();
d2432 2
a2433 2
static int
get_cwd_win32 ()
d2435 2
a2436 1
  DWORD dlen, len;
d2438 1
a2438 2
  cwd.lock->acquire ();
  for (dlen = 256; ; dlen *= 2)
d2440 2
a2441 3
      cwd.win32 = (char *) crealloc (cwd.win32, dlen + 2);
      if ((len = GetCurrentDirectoryA (dlen, cwd.win32)) < dlen)
	break;
a2442 3

  if (len == 0)
    __seterrno ();
a2443 20
    cwd.hash = hash_path_name (0, cwd.win32);

  cwd.lock->release ();
  return len;
}

/* getcwd */

char *
getcwd_inner (char *buf, size_t ulen, int posix_p, int with_chroot)
{
  char *resbuf = NULL;
  size_t len = ulen;

  if (cwd_win32 (TMPCWD) == NULL && !get_cwd_win32 ())
    return NULL;

  char *cwd_win32_now = cwd_win32 (TMPCWD);
  char *cwd_posix_now = cwd_posix (TMPCWD);
  if (!posix_p)
d2445 2
a2446 2
      if (strlen (cwd_win32_now) >= len)
	set_errno (ERANGE);
d2449 2
a2450 2
	  strcpy (buf, cwd_win32_now);
	  resbuf = buf;
d2453 2
a2454 3
      syscall_printf ("%p (%s) = getcwd_inner (%p, %d, win32) (cached)",
		      resbuf, resbuf ? resbuf : "", buf, len);
      return resbuf;
a2455 29
  else if (cwd_posix_now != NULL)
    {
      debug_printf("myself->root: %s, cwd_posix: %s", myself->root, cwd_posix_now);
      if (strlen (cwd_posix_now) >= len)
	set_errno (ERANGE);
      else if (with_chroot && ischrootpath(cwd_posix_now))
	{
	  strcpy (buf, cwd_posix_now + myself->rootlen);
	  if (!buf[0])
	    strcpy (buf, "/");
	  resbuf = buf;
	}
      else
	{
	  strcpy (buf, cwd_posix_now);
	  resbuf = buf;
	}

      syscall_printf ("%p (%s) = getcwd_inner (%p, %d, posix) (cached)",
		      resbuf, resbuf ? resbuf : "", buf, len);
      return resbuf;
    }

  /* posix_p required and cwd_posix == NULL */

  char temp[MAX_PATH];

  /* Turn from Win32 style to our style.  */
  cygwin_shared->mount.conv_to_posix_path (cwd_win32_now, temp, 0);
d2457 1
a2457 1
  size_t tlen = strlen (temp);
d2459 4
a2462 46
  if (with_chroot && ischrootpath (temp))
    tlen -= myself->rootlen;

  cwd.lock->acquire ();
  cwd.posix = (char *) crealloc (cwd.posix, tlen + 1);
  if (cwd.posix != NULL)
    if (with_chroot && ischrootpath (temp))
      {
	strcpy (cwd.posix, temp + myself->rootlen);
	if (!buf[0])
	  strcpy (buf, "/");
      }
    else
      strcpy (cwd.posix, temp);

  cwd.lock->release ();

  if (tlen >= ulen)
    set_errno (ERANGE);	/* len was too small */
  else
    {
      strcpy (buf, temp);
      resbuf = buf;
    }

  syscall_printf ("%p (%s) = getcwd_inner (%p, %d, %s)",
		  resbuf, resbuf ? resbuf : "",
		  buf, len, posix_p ? "posix" : "win32");
  return resbuf;
}

char *
getcwd (char *buf, size_t ulen)
{
  char *res;

  if (buf == NULL || ulen == 0)
    {
      buf = (char *) alloca (MAX_PATH);
      res = getcwd_inner (buf, MAX_PATH, 1, 1);
      res = strdup (buf);
    }
  else
    {
      res = getcwd_inner (buf, ulen, 1, 1);
    }
d2505 1
a2505 19
    {
      cwd.lock->acquire ();
      /* Store new cache information */
      cfree (cwd.win32);
      cwd.win32 = cstrdup (path);

      char pathbuf[MAX_PATH];
      (void) normalize_posix_path (cwd.posix, dir, pathbuf);
      /* Look for trailing path component consisting entirely of dots.  This
	 is needed only in case of chdir since Windows simply ignores count
	 of dots > 2 here instead of returning an error code.  Counts of dots
	 <= 2 are already eliminated by normalize_posix_path. */
      char *last_slash = strrchr (pathbuf, '/');
      if (last_slash > pathbuf && strspn (last_slash + 1, ".") == strlen (last_slash + 1))
	*last_slash = '\0';
      cfree (cwd.posix);
      cwd.posix = cstrdup (pathbuf);
      cwd.lock->release ();
    }
d2507 4
a2510 1
  syscall_printf ("%d = chdir() cwd.posix '%s' native '%s'", res, cwd.posix, native_dir);
d2850 127
@


1.46
log
@* Makefile.in: Add cygheap.o.
* child_info.h: Add specific exec class.
* cygheap.h: New file.  Contains declarations for cygwin heap.
* cygheap.cc: New file.  Implements cygwin heap functions.
* dcrt0.cc (quoted): Simplify due to new method for passing arguments between
cygwin programs.
(alloc_stack_hard_way): Attempt to handle overlapped stack.
(dll_crt0_1): Move child_info processing here.  Accomodate new method for
passing arguments between cygwin programs.  Initialize cygwin heap.  Establish
__argc and __argv variables.
(_dll_crt0): Move most of child_info processing to dll_crt0_1.
(cygwin_dll_init): Remove duplication.
* dtable.cc (dtable::extend): Allocate dtable using cygwin heap.
(dtable::build_fhandler): Ditto for fhandler type being constructed.
(dtable::dup_worker): Free new fhandler from cygwin heap on error.
(dtable::select_*): Don't assume that this == fdtab.
(dtable::linearize_fd_array): Delete.
(dtable::delinearize_fd_array): Delete.
(dtable::fixup_after_exec): New file.
(dtable::vfork_child_dup): Use cygwin heap.
(dtable::vfork_parent_restore): Ditto.
* dtable.h: Remove obsolete methods.  Add new method.
* environ.cc (posify): Eliminate already_posix parameter and logic.
(envsize): New function.
(_addenv): Use envsize.
(environ_init): Accept an argument pointing to an existing environment list.
If supplied, allocate space for this in the the program's heap.
* fhandler.cc (fhandler_base::operator =): Move here from fhandler.h.  Use
cygwin heap to allocate filenames.
(fhandler_base::set_name): Allocate/free names from cygwin heap.
(fhandler_base::linearize): Delete.
(fhandler_base::de_linearize): Delete.
(fhandler_base::operator delete): Free from cygwin heap.
(fhandler_base::~fhandler_base): Ditto.
* fhandler.h: Accomodate elimination of *linearize and other changes above.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Rename from
de_linearize.
* heap.h: New file.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Use cygwin heap for
name.  fhandler_tty::fixup_after_exec): Rename from de_linearize.
* fork.cc (fork): Call cygheap_fixup_in_child.
* heap.cc: Use declarations in heap.h.
* malloc.cc: Sprinkle assertions throughout to catch attempts to free/realloc
something from the cygwin heap.
* path.cc: Throughout, eliminate use of per-thread cache for cwd.  Use cwd_*
functions rather than cwd_* variables to access cwd_win32 and cwd_posix.
(cwd_win32): New function.
(cwd_posix): New function.
(cwd_hash): New function.
(cwd_fixup_after_exec): New function.
* path.h: Accomodate path.cc changes.
* pinfo.cc (pinfo_init): Accept a pointer to an environment table.  Pass this
to environ_init.  Eliminate old 'title' tests.
* pinfo.h: Accomodate above change in argument.
* spawn.cc (struct av): New method for building argv list.
(av::unshift): New method.
(spawn_guts): Allocate everything that the child process needs in the cygwin
heap and pass a pointer to this to the child.  Build argv list using new
method.  Eliminate delinearize stuff.
* thread.h: Eliminate _cwd_win32 and _cwd_posix buffers.
* winsup.h: Eliminate obsolete functions.  Add envsize() declaration.
@
text
@d2439 7
d2462 1
a2462 6
  int len = strlen (pathbuf.get_win32 ());
  if (len > (buflen - 1))
    {
      set_errno (ENAMETOOLONG);
      return -1;
    }
a2463 1
  buf[len] = '\0';
@


1.45
log
@* path.cc (symlink_info::check): Clear error on each iteration of extension
check.
@
text
@d91 1
d154 65
a218 9
#ifdef _MT_SAFE
#define cwd_win32  _reent_winsup()->_cwd_win32
#define cwd_posix _reent_winsup()->_cwd_posix
#define cwd_hash _reent_winsup()->_cwd_hash
#else
static char *cwd_win32;
static char *cwd_posix;
static unsigned long cwd_hash;
#endif
d1025 1
a1025 1
      rc = normalize_win32_path (cwd_win32, src_path, dst);
d1142 2
d1147 1
a1147 1
	   path_prefix_p (cwd_win32, dst, cwdlen = strlen (cwd_win32)))
d1157 1
a1157 1
	    dst += isdirsep (cwd_win32[cwdlen - 1]) ? cwdlen : cwdlen + 1;
d2515 1
a2515 2
      if (*name != '\\' && (cwd_win32 == NULL ||
			    get_cwd_win32 ()))
d2517 1
a2517 1
	  hash = cwd_hash;
d2542 1
d2545 2
a2546 2
      cwd_win32 = (char *) realloc (cwd_win32, dlen + 2);
      if ((len = GetCurrentDirectoryA (dlen, cwd_win32)) < dlen)
d2553 1
a2553 1
    cwd_hash = hash_path_name (0, cwd_win32);
d2555 1
d2567 1
a2567 1
  if (cwd_win32 == NULL && !get_cwd_win32 ())
d2570 2
d2574 1
a2574 1
      if (strlen (cwd_win32) >= len)
d2578 1
a2578 1
	  strcpy (buf, cwd_win32);
d2586 1
a2586 1
  else if (cwd_posix != NULL)
d2588 2
a2589 2
      debug_printf("myself->root: %s, cwd_posix: %s", myself->root, cwd_posix);
      if (strlen (cwd_posix) >= len)
d2591 1
a2591 1
      else if (with_chroot && ischrootpath(cwd_posix))
d2593 1
a2593 1
	  strcpy (buf, cwd_posix + myself->rootlen);
d2600 1
a2600 1
	  strcpy (buf, cwd_posix);
d2614 1
a2614 1
  cygwin_shared->mount.conv_to_posix_path (cwd_win32, temp, 0);
d2621 3
a2623 3
  cwd_posix = (char *) realloc (
				  cwd_posix, tlen + 1);
  if (cwd_posix != NULL)
d2626 1
a2626 1
	strcpy (cwd_posix, temp + myself->rootlen);
d2631 3
a2633 1
      strcpy (cwd_posix, temp);
d2636 1
a2636 4
    {
      /* len was too small */
      set_errno (ERANGE);
    }
d2707 1
d2709 2
a2710 2
      free (cwd_win32);
      cwd_win32 = strdup (path);
d2713 1
a2713 1
      (void) normalize_posix_path (cwd_posix, dir, pathbuf);
d2721 3
a2723 2
      free (cwd_posix);
      cwd_posix = strdup (pathbuf);
d2726 1
a2726 1
  syscall_printf ("%d = chdir() cwd_posix '%s' native '%s'", res, cwd_posix, native_dir);
@


1.44
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@a2244 1
  error = 0;
d2260 1
d2265 1
@


1.43
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d84 6
a90 1
#include "cygerrno.h"
@


1.42
log
@* winsup.h: Split out dtable definitions into separate header file.
* dtable.h: New file.
* sigproc.h: Eliminate pinfo.h usage here.  Use it in source files that need
it.
@
text
@d85 1
d105 1
d159 3
a161 3
        (myself->rootlen && \
         strncasematch (myself->root, path, myself->rootlen) && \
         (path[myself->rootlen] == '/' || path[myself->rootlen] == '\0'))
d229 1
a229 1
      if (error != 0)
a269 1
	  save_errno s (0);
d271 1
a271 1
	  
d291 2
a292 2
	     it returns a length of 0 and sets errno to EINVAL.  It also sets
	     any suffix found into `ext_here'. */
d295 1
a321 1
	  s.reset ();      // remember errno from symlink.check
d325 1
a325 1
	    goto out;        // all done
d396 1
a396 1
                    tmp_buf, full_path, GetLastError ());
d402 1
a402 1
                    tmp_buf, full_path, volflags & FS_PERSISTENT_ACLS);
d508 1
a508 1
        {
d510 2
a511 2
          unit = 8 + (deveqn ("u", 1) ? 1 : 0); /* Keep unit Linux conformant */
        }
d595 1
a595 1
        {
d598 1
a598 1
        }
d634 1
a634 1
		  if ((src[1] && !isslash (src[1])))
d641 3
a643 3
                  if (!ischrootpath (dst_start) ||
                      dst - dst_start != (int) myself->rootlen)
                    while (dst > dst_start && !isslash (*--dst))
d690 1
a690 1
        {
d693 1
a693 1
        }
d703 1
a703 1
        *c = '\\';
d917 1
a917 1
                                unsigned *flags)
d972 2
a973 2
        {
          char posix_path[MAX_PATH + 1];
d975 12
a986 12
          rc = cygwin_shared->mount.conv_to_posix_path (dst, posix_path, 0);
          if (rc)
            {
              debug_printf ("conv_to_posix_path failed, rc %d", rc);
              return rc;
            }
          if (!ischrootpath (posix_path))
            {
              debug_printf ("ischrootpath failed");
              return ENOENT;
            }
        }
d1189 1
a1189 1
    
d1463 1
a1463 1
  if ((flags & MOUNT_SYSTEM) == 0)    /* Delete from user registry */
d1469 1
a1469 1
  else                                /* Delete from system registry */
d1518 1
a1518 1
        /* Didn't find either so write the default to the registry and use it.
d1520 1
a1520 1
        write_cygdrive_info_to_registry ("/cygdrive", MOUNT_AUTO);
d1524 1
a1524 1
        /* Fetch system cygdrive_flags from registry; returns MOUNT_AUTO on
d1526 3
a1528 3
        cygdrive_flags = r2.get_int ("cygdrive flags", MOUNT_AUTO);
        slashify (cygdrive, cygdrive, 1);
        cygdrive_len = strlen(cygdrive);
d1534 1
a1534 1
         error. */
d1963 1
a1963 1
  if (!(flags & MOUNT_SYSTEM))       /* user mount */
d1965 1
a1965 1
  else                                   /* system mount */
d1968 1
a1968 1
  if ((flags & MOUNT_AUTO))         /* cygdrive */
d2072 1
a2072 1
         to remove the cygdrive prefix and flags without actually unmounting
d2173 4
a2176 4
          set_file_attribute (win32_path.has_acls (),
                              win32_path.get_win32 (),
                              S_IFLNK | S_IRWXU | S_IRWXG | S_IRWXO);
          SetFileAttributesA (win32_path.get_win32 (), FILE_ATTRIBUTE_SYSTEM);
d2240 1
d2267 1
a2267 1
	  __seterrno ();
d2272 12
a2283 8
	 Detect this scenario and disallow it, since it is non-UNIX like. */
      char *p = strchr (path, '\0');
      if (p > path + 1 && p[-1] == '.' && SLASH_P (p[-2]) &&
	  !(fileattr & FILE_ATTRIBUTE_DIRECTORY))
	{
	  debug_printf ("\\. specified on non-directory");
	  set_errno (ENOTDIR);
	  return 0;
d2304 1
a2304 1
	    set_errno (EIO);
d2314 1
a2314 1
		set_errno (EIO);
a2355 1
  set_errno (EINVAL);
d2524 6
a2529 6
        {
          strcpy (buf, cwd_posix + myself->rootlen);
          if (!buf[0])
            strcpy (buf, "/");
          resbuf = buf;
        }
d2558 3
a2560 3
        strcpy (cwd_posix, temp + myself->rootlen);
        if (!buf[0])
          strcpy (buf, "/");
d2647 3
a2649 3
         is needed only in case of chdir since Windows simply ignores count
         of dots > 2 here instead of returning an error code.  Counts of dots
         <= 2 are already eliminated by normalize_posix_path. */
d2652 1
a2652 1
        *last_slash = '\0';
@


1.41
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d84 1
@


1.40
log
@* path.cc (chdir): Avoid trailing dot calculation when chdir == '/' or we end
up with an empty string.
@
text
@d74 1
a81 1
#include "winsup.h"
@


1.39
log
@* dcrt0.cc (dummy_autoload): Add load statement for RegDeleteValueA.
* external.cc (get_cygdrive_prefixes): New function.
(cygwin_internal): Add CW_GET_CYGDRIVE_PREFIXES case.
* path.cc (mount_info::read_cygdrive_info_from_registry): Read system cygdrive
prefix if user one is undefined.
(mount_info::write_cygdrive_info_to_registry): Write cygdrive prefix to the
appropriate registry hive.  Overwrite in-memory copy of cygdrive, if
appropriate.
(mount_info::remove_cygdrive_info_from_registry): New method.
(mount_info::get_cygdrive_prefixes): New method.
(cygwin_umount): Remove cygdrive prefix, if appropriate.
* registry.cc (reg_key::killvalue): New method.
* shared.h (class reg_key): Add killvalue, remove_cygdrive_info_to_registry,
and get_cygdrive_prefixes declarations.
* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_GET_CYGDRIVE_PREFIXES.
@
text
@d2645 1
a2645 1
      if (last_slash && strspn (last_slash + 1, ".") == strlen (last_slash + 1))
@


1.39.2.1
log
@* path.cc (chdir): Avoid trailing dot calculation when chdir == '/' or we end
up with an empty string.
@
text
@d2604 2
a2605 1
extern "C" int
d2645 1
a2645 1
      if (last_slash > pathbuf && strspn (last_slash + 1, ".") == strlen (last_slash + 1))
@


1.38
log
@        * shared.h (class pinfo): New members `root' and `rootlen'.
        * syscalls.cc (chroot): Set new root for process.
        * path.cc (getcwd_inner): Add parameter to force use of
        new root from chroot() call.
        (ischrootpath): New macro.
        (normalize_posix_path): Care for changed root dir.
        (normalize_win32_path): Ditto.
        (getcwd_inner): Ditto.
        (chdir): Eliminate trailing path component consisting
        entirely of dots.
        * fork.cc (fork): Copy pinfo members regarding chroot().
        * spawn.cc (_spawnve): Ditto.
        * dir.cc (opendir): Don't use computed win32 path if
        chroot() took place.
@
text
@d1500 1
a1500 1
  /* reg_key for user mounts in HKEY_CURRENT_USER. */
d1505 23
a1527 2
      /* Didn't find it so write the default to the registry and use it. */
      write_cygdrive_info_to_registry ("/cygdrive", MOUNT_AUTO);
d1531 2
a1532 1
      /* Fetch cygdrive_flags from registry; returns MOUNT_AUTO on error. */
d1546 10
a1555 2
  /* reg_key for user mounts in HKEY_CURRENT_USER. */
  reg_key r;
d1574 11
a1584 4
  /* This also needs to go in the in-memory copy of "cygdrive" */
  slashify (cygdrive_prefix, cygwin_shared->mount.cygdrive, 1);
  cygwin_shared->mount.cygdrive_flags = flags;
  cygwin_shared->mount.cygdrive_len = strlen(cygwin_shared->mount.cygdrive);
d1589 43
d2065 13
a2077 1
  int res = cygwin_shared->mount.del_item (path, flags, TRUE);
@


1.37
log
@Throughout, eliminate third argument to path_conv and use new PC_* constants
for second argument.
* path.h: Generalize SYMLINK_* constants to PC_*.
(path_conv): Create a new method.  Fold third argument into second.
* dll_init.cc (dll_list::alloc): Try harder to find space to allocate dll
struct.
(dll_dllcrt0): Don't check sanity if we've already called dll_crt0.
* path.cc (path_conv::check): Don't check for a null or empty path unless
specifically told with a flag setting.
(check_null_empty_path): New function, adapted from macro.
* syscalls.cc (_rename): Use already-determined file attributes rather than
checking again.
* lib/cygwin/cygwin_attach.dll.c (cygwin_attach_dll): Use a static per_process
structure since this is apparently supposed to be zeroed.
* lib/cygwin_crt0.c (cygwin_crt0): Zero per_process structure sent to older
DLLs.
@
text
@d86 1
a86 1
static char *getcwd_inner (char *buf, size_t ulen, int posix_p);
d155 5
d592 5
d607 6
d639 4
a642 2
		  while (dst > dst_start && !isslash (*--dst))
		    continue;
a664 1

d670 1
d687 5
d695 11
d726 1
a726 1
	  if (dst > dst_start + 1)
d729 1
a729 1
	  while (dst > dst_start + 1 && dst[-1] != '\\' && dst[-2] != ':')
d945 1
a945 1
  getcwd_inner (cwd, MAX_PATH, TRUE); /* FIXME: check rc */
d969 16
d1214 1
a1214 1
    getcwd_inner (cwd, MAX_PATH, 0); /* FIXME: check rc */
d2398 1
a2398 1
getcwd_inner (char *buf, size_t ulen, int posix_p)
d2422 1
d2425 7
d2452 3
d2458 8
a2465 1
    strcpy (cwd_posix, temp);
d2492 1
a2492 1
      res = getcwd_inner (buf, MAX_PATH, 1);
d2497 1
a2497 1
      res = getcwd_inner (buf, ulen, 1);
d2548 7
@


1.36
log
@Add some comments.
@
text
@d185 2
a186 2
path_conv::check (const char *src, symlink_follow follow_mode,
		  int use_full_path, const suffix_info *suffixes)
d198 3
a200 1
  if ((error = check_null_empty_path (src)))
d203 1
a203 1
  if (use_full_path)
d240 1
a240 1
      if (follow_mode == SYMLINK_IGNORE)
d302 1
a302 1
	      if (component == 0 && follow_mode != SYMLINK_FOLLOW)
d306 1
a306 1
		  if (follow_mode == SYMLINK_CONTENTS)
d375 1
a375 1
  else if (sym.ext_here && follow_mode != SYMLINK_CONTENTS)
d515 1
a515 1
						 SYMLINK_IGNORE).get_win32 (),
d1980 1
a1980 1
  path_conv win32_path (frompath, SYMLINK_NOFOLLOW);
d2226 1
a2226 1
  path_conv pathbuf (path, SYMLINK_CONTENTS, 0, stat_suffixes);
d2497 1
a2497 1
  path_conv p (path, SYMLINK_FOLLOW, 0);
d2512 1
a2512 1
  path_conv p (path, SYMLINK_FOLLOW, 1);
d2553 1
a2553 1
  path_conv real_path (path, SYMLINK_FOLLOW, 1);
d2811 13
@


1.35
log
@Changes by  Kazuhiro Fujieda  <fujieda@@jaist.ac.jp>
        * assert.cc (__assert): Reduce dependency on newlib.
        * exec.cc: Eliminate unnecessary inclusion of ctype.h.
        * glob.c: Ditto.
        * hinfo.cc: Ditto.
        * init.cc: Ditto.
        * strace.cc: Ditto.
        * tty.cc: Ditto.
        * grp.cc (parse_grp): Eliminate atoi.
        * passwd.cc (grab_int): Ditto.
        * grp.cc (getgroups): Eliminate str{n,}casecmp.
        * path.cc (get_raw_device_number): Ditto.
        * path.cc (sort_by_native_name): Ditto.
        * spawn.cc (iscmd): Ditto.
        * uinfo.cc (internal_getlogin): Ditto.
@
text
@d2750 1
d2767 1
@


1.34
log
@* Makefile.in: Just use library files from this tree when building cygrun.exe.
* path.cc (chdir): Don't set cache to offending chdir.  Change comment to
reflect current reality.
@
text
@d441 1
a441 1
  if (strncasecmp (w32path, "\\\\.\\tape", 8) == 0)
d446 1
a446 1
      if (! strncasecmp (uxname, "/dev/n", 6))
d454 1
a454 1
  else if (strncasecmp (w32path, "\\\\.\\physicaldrive", 17) == 0)
d1569 1
a1569 1
  res = strcasecmp (ap->posix_path, bp->posix_path);
@


1.33
log
@* path.cc (chdir): Don't set cache to offending chdir.  Change comment to
reflect current reality.
@
text
@d2474 1
a2474 1
      cwd_win32 = strdup (path);;
d2482 1
a2482 1
  syscall_printf ("%d = chdir (%s <dos %s>)", res, cwd_posix, cwd_win32);
@


1.32
log
@Fix typo.
@
text
@d2470 5
d2476 5
a2480 8
  /* Clear the cache until we need to retrieve the directory again.  */
  free (cwd_win32);
  cwd_win32 = strdup (path);;

  char pathbuf[MAX_PATH];
  (void) normalize_posix_path (cwd_posix, dir, pathbuf);
  free (cwd_posix);
  cwd_posix = strdup (pathbuf);
@


1.31
log
@* path.cc (normalize_posix_path): Convert path to POSIX if it seems to be a
Windows path.
@
text
@d559 1
a559 1
  if (isdrive (src) || strpbrk (src, "\\:/"))
@


1.30
log
@* path.cc (mount_info::add_item): The previous patch can't handle the case of
overwriting a mount entry.
@
text
@d559 5
d1622 2
a1623 4
    {
      backslashify (native, nativetmp, 0);
      nofinalslash (nativetmp, nativetmp);
    }
d1683 1
d1686 1
a1686 1
  if (path == NULL || *path == 0)
d1692 9
a1700 1
  slashify (path, pathtmp, 0);
d1703 3
a1705 4
  debug_printf ("%s[%s]", path, pathtmp);

  if (reg_p && del_reg_mount (pathtmp, flags)
      && del_reg_mount (path, flags)) /* for old irregular entries */
d1710 11
a1720 6
      /* Delete if paths and mount locations match. */
      if ((strcasematch (mount[i].posix_path, pathtmp)
	   || strcasematch (mount[i].native_path, pathtmp)) &&
	  (mount[i].flags & MOUNT_SYSTEM) == (flags & MOUNT_SYSTEM))
	{
	  nmounts--;		/* One less mount table entry */
d1722 4
a1725 4
	  if (i < nmounts)
	    memmove (mount + i, mount + i + 1,
		     sizeof (mount[i]) * (nmounts - i));
	  sort ();		/* Resort the table */
@


1.29
log
@* thread.h: Shorten "current_directory" variables to "cwd_*" throughout.
* path.cc: Ditto.
(normalize_posix_path): Add some extra debugging info.
(chdir): Ditto.  Store chdir'ed posix and MS-DOS directory names in "cache"
here rather than trying to derive them later.
@
text
@d1648 1
a1648 4
  /* Can't add more than MAX_MOUNTS. */
  if (i == nmounts && nmounts < MAX_MOUNTS)
    i = nmounts++;
  else
d1650 7
a1656 2
      set_errno (EMFILE);
      return -1;
@


1.28
log
@        * path.cc (path_conv::check): Erase two lines checked in
        by mistake.
@
text
@d90 1
a90 1
static int get_current_directory_name ();
d146 3
a148 3
#define current_directory_name  _reent_winsup()->_current_directory_name
#define current_directory_posix_name _reent_winsup()->_current_directory_posix_name
#define current_directory_hash _reent_winsup()->_current_directory_hash
d150 3
a152 3
static char *current_directory_name;
static char *current_directory_posix_name;
static unsigned long current_directory_hash;
d558 1
d877 1
a877 1
  int trailing_slash_p = (src_path_len > 0
d920 1
a920 1
      rc = normalize_win32_path (current_directory_name, src_path, dst);
d1024 1
a1024 2
	   path_prefix_p (current_directory_name, dst,
			  cwdlen = strlen (current_directory_name)))
d1034 1
a1034 1
	    dst += isdirsep (current_directory_name[cwdlen - 1]) ? cwdlen : cwdlen + 1;
d2282 2
a2283 2
      if (*name != '\\' && (current_directory_name == NULL ||
			    get_current_directory_name ()))
d2285 1
a2285 1
	  hash = current_directory_hash;
d2306 1
a2306 1
get_current_directory_name ()
d2312 2
a2313 2
      current_directory_name = (char *) realloc (current_directory_name, dlen + 2);
      if ((len = GetCurrentDirectoryA (dlen, current_directory_name)) < dlen)
d2320 1
a2320 1
    current_directory_hash = hash_path_name (0, current_directory_name);
d2333 1
a2333 1
  if (current_directory_name == NULL && !get_current_directory_name ())
d2338 1
a2338 1
      if (strlen (current_directory_name) >= len)
d2342 1
a2342 1
	  strcpy (buf, current_directory_name);
d2350 1
a2350 1
  else if (current_directory_posix_name != NULL)
d2352 1
a2352 1
      if (strlen (current_directory_posix_name) >= len)
d2356 1
a2356 1
	  strcpy (buf, current_directory_posix_name);
d2365 1
a2365 1
  /* posix_p required and current_directory_posix_name == NULL */
d2370 1
a2370 1
  cygwin_shared->mount.conv_to_posix_path (current_directory_name, temp, 0);
d2374 4
a2377 4
  current_directory_posix_name = (char *) realloc (
				  current_directory_posix_name, tlen + 1);
  if (current_directory_posix_name != NULL)
    strcpy (current_directory_posix_name, temp);
d2428 1
d2454 7
a2460 10
  if (current_directory_name != NULL)
    {
      free (current_directory_name);
      current_directory_name = NULL;
    }
  if (current_directory_posix_name != NULL)
    {
      free (current_directory_posix_name);
      current_directory_posix_name = NULL;
    }
d2462 1
a2462 1
  syscall_printf ("%d = chdir (%s) (dos %s)", res, dir, native_dir);
@


1.27
log
@        path.cc (mount_info::init): Eliminate the mount_slash feature.
        (mount_slash): Eliminated.
        (mount_info::read_mounts): Eliminate looking up existing entries. The
        loop for deleting cygpath entries is done only when such entries exist.
        (mount_info::from_registry): Eliminate sorting.
        (mount_info::add_item): Call add_reg_mount if necessary. Check nmounts
        more precisely. Use strcasematch in looking up existing entries.
        (mount_info::del_item): Call del_reg_mount if necessary. Use
        strcasematch. Use memmove instead of memcpy.
        (mount_info::import_v1_registry): Everything is done in this method.
        (mount_info::to_registry): Eliminated.
        (mount_info::from_v1_registry): Eliminated.
        (cygwin_umount): Simply call del_item.
        shared.h: Modify the declaration of add_item and del_item. Remove the
        declaration of from_v1_registry.
@
text
@a388 1
      set_has_reparse_points (FALSE);
a394 1
      set_has_reparse_points (volflags & FILE_SUPPORTS_REPARSE_POINTS);
@


1.26
log
@* cygwin.din: add cygwin_dll_init
* dcrt0.cc (cygwin_dll_init): new
(dll_crt0_1): short circuit if manually loaded
* path.cc (mount_info::init): don't init if manually loaded
@
text
@d83 1
d389 1
d396 1
a850 2
  int found_slash = 0;

a856 30

  if (dynamically_loaded)
    return;

  /* If slash isn't already mounted, mount system directory as slash. */
  if (nmounts != 0)
    for (int i = 0; i < nmounts; i++)
      {
	if (strcmp (mount[i].posix_path, "/") == 0)
	  {
	    found_slash = 1;
	    break;
	  }
      }

  if (!found_slash)
    mount_slash ();
}

/* mount_slash: mount the system partition as slash. */

void
mount_info::mount_slash ()
{
  char drivestring[MAX_PATH];
  GetSystemDirectory (drivestring, MAX_PATH);
  drivestring[2] = 0;   /* truncate path to "<drive>:" */

  if (add_reg_mount (drivestring, "/", 0) == 0)
    add_item (drivestring, "/", 0);
d1244 1
a1244 18

loop:
  for (i = 0; ;i++)
    {
      posix_path_size = MAX_PATH;
      LONG err = RegEnumKeyEx (key, i, posix_path, &posix_path_size, NULL,
			  NULL, NULL, NULL);

      if (err != ERROR_SUCCESS)
	break;

      if (iscygdrive (posix_path))
	{
	  /* This shouldn't be in the mount table. */
	  (void) r.kill (posix_path);
	  goto loop;
	}
    }
d1250 1
a1250 1
  for (DWORD i = 0; i < MAX_MOUNTS; i++)
d1272 1
a1272 2
	  /* This shouldn't be in the mount table. */
	  // (void) r.kill (posix_path);
a1278 5
      /* Check the mount table for prefix matches. */
      for (int j = 0; j < nmounts; j++)
	if (strcasematch (mount[j].posix_path, posix_path))
	  goto next;	/* Can't have more than one */

d1284 24
a1307 3
      cygwin_shared->mount.add_item (native_path, posix_path, mount_flags);
    next:
      continue;
a1341 2

  sort ();
d1592 1
a1592 1
/* Add an entry to the in-memory mount table.
d1599 1
a1599 1
mount_info::add_item (const char *native, const char *posix, unsigned mountflags)
a1600 7
  /* Can't add more than MAX_MOUNTS. */
  if (nmounts == MAX_MOUNTS)
    {
      set_errno (EMFILE);
      return -1;
    }

d1642 12
a1653 1
  for (int i = 0; i < nmounts; i++)
d1655 2
a1656 7
      if ((strcmp (mount[i].posix_path, posixtmp) == 0) &&
	  ((mount[i].flags & MOUNT_SYSTEM) == (mountflags & MOUNT_SYSTEM)))
	{
	  /* replace existing mount item */
	  mount[i].init (nativetmp, posixtmp, mountflags);
	  goto sortit;
	}
d1659 2
a1660 1
  mount[nmounts++].init (nativetmp, posixtmp, mountflags);
d1662 1
a1662 1
sortit:
d1677 1
a1677 1
mount_info::del_item (const char *path, unsigned flags)
d1682 1
a1682 1
  if ((path == NULL) || (*path == 0))
d1693 4
d1700 3
a1702 3
      if (((strcmp (mount[i].posix_path, pathtmp) == 0
	    || strcmp (mount[i].native_path, pathtmp) == 0)) &&
	  ((mount[i].flags & MOUNT_SYSTEM) == (flags & MOUNT_SYSTEM)))
d1707 2
a1708 2
	    memcpy (mount + i, mount + i + 1,
		    sizeof (mount[i]) * (nmounts - i));
d1755 3
a1757 1
	  cygwin_shared->mount.add_item (win32path, unixpath, mountflags);
d1762 2
a1763 2
/* from_v1_registry: Build the entire mount table from the old v1 registry
   mount area.  */
d1766 1
a1766 1
mount_info::from_v1_registry ()
a1789 37

  /* Note: we don't need to sort internal table here since it is
     done in main from_registry call after this function would be
     run. */
}

/* import_v1_mounts: If v1 mounts are present, load them and write
   the new entries to the new registry area. */

void
mount_info::import_v1_mounts ()
{
  /* Read in old mounts into memory. */
  from_v1_registry ();

  /* Write all mounts to the new registry. */
  to_registry ();
}

/* to_registry: For every mount point in memory, add a corresponding
   registry mount point. */

void
mount_info::to_registry ()
{
  for (int i = 0; i < MAX_MOUNTS; i++)
    {
      if (i < nmounts)
	{
	  mount_item *p = mount + i;

	  add_reg_mount (p->native_path, p->posix_path, p->flags);

	  debug_printf ("%02x: %s, %s, %d",
			i, p->native_path, p->posix_path, p->flags);
	}
    }
d1890 1
a1890 4
      res = cygwin_shared->mount.add_reg_mount (win32_path, posix_path, flags);

      if (res == 0)
	cygwin_shared->mount.add_item (win32_path, posix_path, flags);
d1917 1
a1917 4
  int res = cygwin_shared->mount.del_reg_mount (path, flags);

  if (res == 0)
    cygwin_shared->mount.del_item (path, flags);
@


1.25
log
@* path.cc (mount_info::conv_to_win32_path): Previous patch was too aggressive
in adding a trailing slash.
@
text
@d857 3
@


1.24
log
@* Makefile.in: Remove libadvapi32.a.
* autoload.h: Add additional field to autoload block for handling unimplemented
functions.
(LoadDLLfuncEx): New function which accepts additional parameter for
controlling unimplemented function behavior.
(LoadDLLfunc): Use LoadDLLfuncEx.
* dcrt0.cc: Use new arguments for LoadDLLfunc.  Add advapi32 routines.
(noload): Rewrite in assembler.  Handle new unimplemented function type.
* exceptions.cc: Eliminate another vestige of StackWalk stuff.
* net.cc: Use new arguments for LoadDLLfunc.
* uinfo.cc: Ditto.

* config.h.in: Remove obsolete define.
* path.h (isdrive): New macro.
* dcrt0.cc (globify): Use new macro to determine if a string refers to an
MS-DOS drive.
* environ.cc (winenv): Ditto.
* spawn.cc (find_exec): Ditto.
* path.cc (get_raw_device_number): Ditto.
(mount_info::conv_to_posix_path): Ditto.
(chdir): Ditto.
(cygwin_posix_path_list_p): Ditto.
(cygwin_split_path): Ditto.
(path_conv::check): Move tmp_buf to beginning of function since it can be used
earlier in the loop.  Use tmp_buf rather than 'root' to hold root information.
(mount_info::conv_to_win32_path): Add trailing slash to end of mount path when
it translates to a drive.  Add defensive code to avoid writing beyond the end
of 'dst'.
@
text
@d1023 1
a1023 1
      memcpy (dst, mi->native_path, n);
a1024 2
      if (!trailing_slash_p && isdrive (mi->native_path) && !mi->native_path[2])
	trailing_slash_p = 1;
d1026 5
a1030 1
	dst[n] = '\0';
@


1.23
log
@* path.cc (mount_info::conv_to_posix_path): Avoid putting a trailing slash on a
directory name when the ms-dos path spec is a root directory of a device.
* registry.cc (reg_key::build_reg): Set 'key_is_invalid' flag rather than using
an INVALID_HANDLE_KEY.
(reg_key::get_int): Test for key validity before performing registry
operations.
(reg_key::set_int): Ditto.
(reg_key::get_string): Ditto.
(reg_key::set_string): Ditto.
(reg_key::kill): Ditto.
(reg_key::~reg_key): Ditto.
@
text
@d192 1
a356 1
	  char tmp_buf[MAX_PATH];
d381 3
a383 4
  char root[strlen(full_path) + 10];
  strcpy (root, full_path);
  if (!rootdir (root) ||
      !GetVolumeInformation (root, NULL, 0, &serial, NULL, &volflags, NULL, 0))
d386 1
a386 1
                    root, full_path, GetLastError ());
d392 1
a392 1
                    root, full_path, volflags & FS_PERSISTENT_ACLS);
d448 1
a448 1
  else if (isalpha (w32path[4]) && w32path[5] == ':')
d1025 2
d1052 3
a1054 2
      if (strlen (dst) == cwdlen)
	dst += cwdlen;
d1056 5
a1060 1
	dst += isdirsep (current_directory_name[cwdlen - 1]) ? cwdlen : cwdlen + 1;
d1062 7
a1068 6
      memmove (win32_path, dst, strlen (dst) + 1);
      if (!*win32_path)
	{
	  strcpy (win32_path, ".");
	  if (trailing_slash_p)
	    strcat (win32_path, "\\");
d1230 1
a1230 1
  if ((isalpha (pathbuf[0])) && (pathbuf[1] == ':'))
d2510 1
a2510 1
  if (isalpha (native_dir[0]) && native_dir[1] == ':' && !native_dir[2])
d2515 2
a2516 2
  int res = SetCurrentDirectoryA (native_dir);
  if (!res)
d2531 2
a2532 2
  syscall_printf ("%d = chdir (%s) (dos %s)", res ? 0 : -1, dir, native_dir);
  return res ? 0 : -1;
d2639 1
a2639 2
  int posix_p = ! (strchr (path, ';')
		   || (isalpha (path[0]) && path[1] == ':'));
d2734 1
a2734 1
  if (isalpha (path[0]) && path[1] == ':')
@


1.22
log
@* path.cc (mount_info::cygdrive_posix_path): Don't add trailing slash if
referring to something like c:\.
* dcrt0.cc (dll_crt0_1): Move uinfo initialization prior to sig_send
initialization to give signal thread a chance to finish.
* debug.cc (WFSO): Move to sigproc.cc
(WFMO): Ditto.
* exceptions.cc (interruptible): Allocate slightly more space for directory
just for paranoia's sake.
(call_handler): Eliminate nonmain argument.  Determine if main thread has set a
frame pointer and use it if so.
(sig_handle): Eliminate nonmain argument.
* net.cc: Record frame information in appropriate routines throughout.
* select.cc (select): Ditto.
* sigproc.cc: Use sigthread structure to record mainthread id throughout.
(sig_send): Record frame information for signal handler.
(wait_sig): Reflect argument change in sig_handle.
(WFSO): Move here and record frame information for signal handler.
(WFMO): Ditto.
* sigproc.h: Implement new "sigthread" class.  Implement "sigframe" class for
manipulating signal frame info.
* thread.cc (__pthread_kill): Use standard _kill() function rather than calling
sig_send directly.
* winsup.h: Eliminate ebp element from signal_dispatch class.
@
text
@d1150 3
a1152 2
  debug_printf ("conv_to_posix_path (%s, %s)", src_path,
		keep_rel_p ? "keep-rel" : "no-keep-rel");
d1196 3
a1198 1
      if (!pathbuf[mi.native_pathlen])
d1200 1
a1200 1
      else if (isdirsep (pathbuf[mi.native_pathlen]))
d1212 1
a1212 1
	slashify (pathbuf + mi.native_pathlen,
d1214 1
a1214 1
		trailing_slash_p);
@


1.21
log
@        * path.cc (symlink::info): Treat non readable files
        as normal non symlink files.
@
text
@d1104 1
a1104 1
  if (!src[2])
d1139 2
a1140 4
  int trailing_slash_p = (src_path_len > 0
			  && SLASH_P (src_path[src_path_len - 1]));
  int relative_path_p = (! SLASH_P (*src_path)
			 && strchr (src_path, ':') == NULL);
d1142 8
d1221 1
a1221 2
    cygdrive_posix_path (pathbuf, posix_path, trailing_slash_p &&
					      pathbuflen > 3);
@


1.20
log
@* configure.in: Use -gstabs+ as compile debug option.  This seems to promote
better handling of symbols.
* configure: Regenerate.
* delqueue.cc (delqueue_list::process_queue): Allow ERROR_ACCESS_DENIED to
indicate that a file is being shared under Windows 95.
* syscalls.cc (_unlink): Use full path name.  Take special action for Windows
95.  Assume that an ERROR_ACCESS_DENIED indicates a sharing violation unless
it's on a remote drive.  Punt if there is an ERROR_ACCESS_DENIED on a remote
drive.
@
text
@d2180 1
a2180 1
	__seterrno ();
@


1.19
log
@        * Makefile.in: Add dependencies for fhandler_random.o
        * fhandler.h: Add device type FH_RANDOM. Add class
        fhandler_dev_random.
        * fhandler_random.cc: New file. Implementation of
        fhandler_dev_random.
        * hinfo.cc (build_fhandler): Add case for FH_RANDOM.
        * path.cc: Add device names for random devices to
        windows_device_names.
        (get_device_number): Add if branch for random devices.
        (win32_device_name): Add device name generation for
        random devices.
        winsup.h: Include <wincrypt.h>.
@
text
@a47 6
   In converting from a Win32 to a POSIX pathname, if there is no
   mount point that will allow the conversion to take place, a user
   mount point will be automatically created under
   cygdrive/<drive> and the translation will be redone, this
   time successfully.

@


1.18
log
@* path.cc (mount_info::conv_to_win32_path): Previous patch
failed to set flags on a win32 path.
@
text
@d439 1
d504 5
d544 4
a547 1
  __small_sprintf (win32_path, devfmt, unit);
@


1.17
log
@* path.cc (normalize_win32_path): Don't add a trailing slash when one already
exists.
(mount_info::conv_to_win32_path): Use existing code for dealing with relative
path names when input is already a win32 path.
@
text
@d952 1
a952 1
      *flags = set_flags_from_win32_path (pathbuf);
@


1.16
log
@* exceptions.cc (interruptible): Allocate slightly more space for directory
name check.  Windows 95 seems to null-terminate the directory otherwise.
(interrupt_on_return): Issue a fatal error if we can't find the caller's stack.
* spawn.cc (find_exec): Accept a path_conv argument rather than a buffer so
that the caller can find things out about a translated path.
(perhaps_suffix): Ditto.
(spawn_guts): Allocate path_conv stuff here so that we can find out stuff about
the translated path (this is work in progress).
* environ.cc (environ_init): Accept an as-yet unused argument indicating
whether we were invoked from a cygwin parent or not.
(winenv): Ditto.
(posify): Accept an argument indicating whether the path has already been
translated.
* dlfcn.cc (check_access): Provide a path_conv buffer to find_exec.
* exec.cc (sexecvpe): Ditto.
* path.cc (path_conv::check): Rename from path_conv::path_conv.
(mount_item::getmntent): Recognize "Cygwin executable" bit.
(symlink_info::check): Remove debugging statements.
* path.h (class path_conv): Add iscygexec method.  Rewrite constructor to call
"check" method to allow multiple operations on a path_conv variable.
* pinfo.cc (pinfo_init): Pass argument to environ_init.
* shared.h: Bump PROC_MAGIC.
* winsup.h: Reflect above changes to function arguments.
* include/sys/mount.h: Add MOUNT_CYGWIN_EXEC type.
@
text
@d643 1
a643 2
  if (!SLASH_P (src[0])
      && strchr (src, ':') == NULL)
d652 2
a653 1
      *dst++ = '\\';
d928 15
a942 6
  /* The rule is :'s can't appear in [our] POSIX path names so this is a safe
     test; if ':' is present it already be in Win32 form.  */
  /* Additional test: If the path has \'s in it, we assume that it's a Win32
     path, either. */
  if (strchr (src_path, ':') != NULL
      || (strchr (src_path, '\\')/* && !strchr (src_path, '/')*/))
d945 1
a945 1
      rc = normalize_win32_path ("", src_path, pathbuf);
d947 5
a951 22
	return rc;
      /* FIXME: Do we have to worry about trailing_slash_p here? */
      if (win32_path != NULL)
        {
          /* If src_path is a relativ win32 path, normalize_win32_path
             adds a leading slash, nevertheless. So we have to test
             that here */
	  strcpy (win32_path, strchr("/\\", src_path[0]) || src_path[1] == ':'
                              ? pathbuf : pathbuf + 1);
        }
      if (full_win32_path != NULL)
        {
          *full_win32_path = '\0';
          /* Add drive if it's a local relative Win32 path */
          if (! strchr(src_path, ':') && strncmp (src_path, "\\\\", 2))
            {
              GetCurrentDirectory (MAX_PATH, full_win32_path);
              if (src_path[0] == '\\')     // drive relative absolute path
                full_win32_path[2] = '\0';
            }
	  strcat (full_win32_path, pathbuf);
        }
d953 1
a953 1
      goto out;
a971 2
  char cwd[MAX_PATH];

d973 1
a973 4
  if ((isrelpath = !isslash (*src_path)))
    getcwd_inner (cwd, MAX_PATH, TRUE); /* FIXME: check rc */
  else
    strcpy (cwd, "/"); /* some innocuous value */
a982 9

  /* Determine where the destination should be placed. */
  if (full_win32_path != NULL)
    dst = full_win32_path;
  else if (win32_path != NULL)
    dst = win32_path;

  if (dst == NULL)
    goto out;		/* Sanity check. */
@


1.15
log
@        * fhandler.cc (fhandler_disk_file::open): Check for allow_ntsec
        when determining exec flag.
        * path.cc (symlink_info::check): Remove call to get_file_attribute().
        * security.cc (read_sd): Rename, ditto for variables to conform
        to common naming convention. Use GetFileSecurity() instead of
        BackupRead() to avoid permission problems when reading ACLs.
        (write_sd): Same renaming as for read_sd().
        (alloc_sd): Change default permissions according to Linux permissions
        for group and world when write permission is set.
        * syscalls.cc (stat_worker): Avoid different permission problems
        when requesting file informations.
@
text
@d189 3
a191 2
path_conv::path_conv (const char *src, symlink_follow follow_mode,
		      int use_full_path, const suffix_info *suffixes)
d1895 3
a1897 1
  if (flags & MOUNT_EXEC)
d1900 1
a2196 3

syscall_printf ("opened '%s'(%p)", path, h);

a2204 1
syscall_printf ("ReadFile");
d2241 1
a2241 1
	      if (!(pflags & PATH_EXEC) && got >= 2 &&
a2245 1
syscall_printf ("close_and_return");
a2250 1
syscall_printf ("breaking from loop");
@


1.14
log
@Fix handling of /.filename
@
text
@a2188 11
      /* Check the file's extended attributes, if it has any.  */
      int unixattr = 0;
      if (fileattr & FILE_ATTRIBUTE_DIRECTORY)
        unixattr |= S_IFDIR;

      if (!get_file_attribute (TRUE, path, &unixattr))
	{
	  if (unixattr & STD_XBITS)
	    pflags |= PATH_EXEC;
	}

@


1.13
log
@* path.cc (normalize_posix_path): Previous two patches were still incorrect so
rewrite this function to deal with trailing dots.
(mount_info::conv_to_win32_path): Just check for '/' where appropriate.
Eliminate nofinalslash call since it is handled in normalize_posix_path now.
@
text
@d564 5
a568 1
	goto sawdot;
@


1.12
log
@	* path.cc (normalize_posix_path): Previous change failed to take root
	access into account.
@
text
@d546 3
a548 1
static __inline int
d554 1
a554 1
  if (!SLASH_P (src[0]))
d563 3
a565 1
      if (dst > dst_start && !isdirsep(dst[-1]))
d569 1
a569 1
  else if (SLASH_P (src[1]))
d574 1
a574 1
      if (SLASH_P(*src))
d585 3
a587 1
      if (SLASH_P (*src))
d589 24
a613 36
	  src++;
	  while (SLASH_P(*src))
	    src++;
	}
      /* Ignore "./".  */
      else if (src[0] == '.' && SLASH_P (src[1])
	       && (src == src_start || SLASH_P (src[-1])))
	{
	  src += 2;
	  while(SLASH_P(src[0]))
	    src++;
	}
      /* Backup if "..".  */
      else if (src[0] == '.' && src[1] == '.'
	       /* dst must be greater than dst_start */
	       && isdirsep (dst[-1])
	       && (SLASH_P (src[2]) || src[2] == 0))
	{
	  /* Back up over /, but not if it's the first one.  */
	  if (dst > dst_start + 1)
	    dst--;
	  /* Now back up to the next /.  */
	  while (dst > dst_start + 1 && !isdirsep (dst[-1]))
	    dst--;
	  src += 2;
	  while (SLASH_P (*src))
	    src++;
	}
      /* Otherwise, add char to result.  */
      else
	{
	  if (*src == '\\')
	    *dst++ = '/';
	  else
	    *dst++ = *src;
	  ++src;
d616 5
a620 3
  if (dst > (dst_start + 1) && dst[-1] == '.' && SLASH_P (dst[-2]))
    dst -= dst[2] ? 2 : 1;
  *dst = 0;
d638 1
a638 1
  if (! SLASH_P (src[0])
d978 1
a978 1
  if ((isrelpath = ! SLASH_P (*src_path)))
d984 2
a985 2
  MALLOC_CHECK;
  if (rc != 0)
a990 1
  nofinalslash (pathbuf, pathbuf);
d1170 1
a1170 1
  MALLOC_CHECK;
d1186 1
a1186 1
  MALLOC_CHECK;
a1187 1
  MALLOC_CHECK;
a1192 2
  nofinalslash (pathbuf, pathbuf);
  MALLOC_CHECK;
d1502 2
a1503 2
      (cygdrive_prefix[0] != '/') ||
      ((cygdrive_prefix[1] != '\0') && (SLASH_P (cygdrive_prefix[1]))))
@


1.11
log
@* fhandler.h (fhandler_base::hclose): New virtual method.
(fhandler_base::set_inheritance): Make this a method so that we can use the
appropriate close methods.
* fhandler.cc (fhandler_base::set_inheritance): Ditto.
* path.cc (normalize_posix_path): Eliminate /.  trailing path component.
@
text
@d623 1
a623 1
    dst -= 2;
@


1.10
log
@* dcrt0.cc (insert_file): Avoid freeing previously allocated argument list.
* path.cc (symlink_info::check): Rename from symlink_check_one.  Use new
symlink_info struct for communication.
(path_conv::path_conv): Use symlink_info structure for communication with
symlink_info::check.  Fix typo which resulted in symbolic links always being
resolved.
(readlink): Use stat_suffixes array when resolving a link.
* syscalls.cc (stat_suffixes): Make global.
@
text
@d552 1
a552 1
  if (! SLASH_P (src[0]))
d622 2
@


1.9
log
@	* path.cc (conv_to_win32_path): Detect a win32 path
	if path contains backslashes.
@
text
@a89 4
static int symlink_check_one (const char *path, char *buf, int buflen,
			      DWORD& fileattr, unsigned *pflags,
			      const suffix_info *suffixes,
			      char *&found_suffix);
d99 13
a194 1
  char work_buf[MAX_PATH * 3 + 3];
d197 1
a208 1
  char *sym_buf = work_buf + MAX_PATH + 1;
a251 2
      *sym_buf = '\0';			// Paranoid

d256 1
a256 1
	 symlink_check_one as the caller may need it. */
d259 2
a260 1
      DWORD attr;
a263 1
	  unsigned dummy_flags, *fp;
d265 2
a266 2

	  /* Don't allow symlink_check_one to set anything in the path_conv
a269 1
	      fp = &dummy_flags;
d271 1
a274 1
	      fp = &path_flags;
d276 1
a277 4
	  MALLOC_CHECK;
	  int len = symlink_check_one (path_copy, sym_buf, MAX_PATH, attr,
				       fp, suff, known_suffix);
	  MALLOC_CHECK;
d279 6
a284 1
	  /* If symlink_check_one found an existing non-symlink file, then
d286 2
a287 2
	     any suffix found into `sym_buf'. */
	  if (!len && get_errno () == EINVAL)
d291 1
a291 1
		  fileattr = attr;
d303 1
a303 1
	      if (component != 0 && follow_mode != SYMLINK_FOLLOW)
d306 1
a306 1
		  fileattr = attr;
d308 1
a308 1
		      strcpy (path, sym_buf);
d314 2
a315 1
	  s.reset ();      // remember errno from symlink_check_one
d337 1
a337 1
      int buflen = strlen (sym_buf);
d347 1
a347 1
      for (p = sym_buf + buflen; *tail; tail++)
d352 2
a353 2
	 just use sym_buf and loop.  Otherwise tack the head of
	 path_copy before sym_buf and translate it back from a
d355 2
a356 2
      if (isabspath (sym_buf))
	src = sym_buf;
d363 1
a363 1
	  p = sym_buf - headlen;
d375 3
a377 1
  if (*sym_buf)
d380 1
a380 1
      strcpy (known_suffix, sym_buf);
a381 2
  else if (known_suffix)
    known_suffix = this->path + (known_suffix - path_copy);
d2137 2
a2138 3
static int
symlink_check_one (const char *in_path, char *buf, int buflen, DWORD& fileattr,
		   unsigned *pflags, const suffix_info *suffixes, char *&known_suffix)
d2142 1
a2142 2
  char extbuf[buflen + 5];
  char *ext_here;
d2158 2
a2159 1
  *buf = '\0';
d2188 1
a2188 1
      if (!(*pflags & PATH_SYMLINK) && !SYMLINKATTR (fileattr))
d2199 1
a2199 1
	    *pflags |= PATH_EXEC;
d2225 1
a2225 1
	      *pflags = PATH_SYMLINK;
d2227 1
a2227 1
	      res = ReadFile (h, buf, buflen, &got, 0);
d2238 2
a2239 2
		  if (memchr (buf, 0, got) != NULL)
		    res = strlen (buf);
d2248 1
a2248 1
	      *pflags |= PATH_SOCKET;
d2254 1
a2254 1
	      if (!(*pflags & PATH_EXEC) && got >= 2 &&
d2257 1
a2257 1
		*pflags |= PATH_EXEC;
d2274 1
a2275 2
  if (ext_here)
    strcpy (buf, ext_here);
d2279 2
a2280 2
  syscall_printf ("%d = symlink_check_one (%s, %p, %d) (%p)",
		  res, path, buf, buflen, *pflags);
d2291 3
a2293 1
  path_conv pathbuf (path, SYMLINK_CONTENTS);
d2317 1
a2317 1
  /* errno set by symlink_check_one if error */
@


1.8
log
@Fix typo.
@
text
@d887 2
a888 1
				char *full_win32_path, DWORD &devn, int &unit, unsigned *flags)
d919 4
a922 1
  if (strchr (src_path, ':') != NULL)
d930 7
a936 1
	strcpy (win32_path, pathbuf);
d938 11
a948 1
	strcpy (full_win32_path, pathbuf);
@


1.7
log
@* path.cc (path_conv::path_conv): Ensure that suffix is correctly copied to
path when we've found a symlink but aren't following symlinks.
@
text
@d285 1
a285 2
		  if (follow_mode == SYMLINK_CONTENTS)
		    goto out;
d302 1
a302 1
		  goto found_symlink;
d366 1
a366 1
found_symlink:
@


1.6
log
@        * newlib/libc/include/sys/unistd.h: Add prototypes for
        fchmod, fchown, lchown.
        * winsup/cygwin/syscalls.cc (chown_worker): Use previous
        uid/gid if new uid/gid is -1.
        New static function with chown functionality.
        (chown): Call chown_worker with SYMLINK_FOLLOW.
        (fchown): New function. Call chown_worker with SYMLINK_FOLLOW.
        (lchown): New function. Call chown_worker with SYMLINK_IGNORE.
        * cygwin.din: Add symbols for fchown, lchown.
        * path.cc (symlink): Call `set_file_attribute()' and
        `SetFileAttributeA()' instead of `chmod()' to set
        uid/gid correct.
@
text
@a186 1
  char tmp_buf[MAX_PATH];
d188 1
a239 1
      char path_copy[strlen (full_path) + 2];
a286 7
		  else if (*sym_buf)
		    {
		      known_suffix = strchr (this->path, '\0');
		      strcpy (known_suffix, sym_buf);
		    }
		  else if (known_suffix)
		    known_suffix = this->path + (known_suffix - path_copy);
d297 1
a297 1
	      if (component == 0)
d299 5
a303 8
		  if (follow_mode != SYMLINK_FOLLOW)
		    {
		      set_symlink (); // last component of path's a symlink.
		      fileattr = attr;
		      if (follow_mode == SYMLINK_CONTENTS)
			  strcpy (path, sym_buf);
		      goto out;
		    }
d354 1
d366 10
@


1.5
log
@* Makefile.in: Use default rules when compiling cygrun.o.
* dcrt0.cc (host_dependent_constants::init): Limit non-NT platforms to 32K
chunks when copying regions during a fork.
* path.cc (symlink_check_one): Add temporary debugging output.  Simplify
PATH_EXEC test.
* syscalls.cc (stat_suffixes): Null terminate this list.
@
text
@d2051 4
a2054 1
	  chmod (frompath, S_IFLNK | S_IRWXU | S_IRWXG | S_IRWXO);
@


1.4
log
@* path.cc (symlink_check_one): Recognize symlink settings from the mount table.
* path.h: Make PATH_SYMLINK an alias for MOUNT_SYMLINK.
* syscalls.cc (stat_worker): Use extension search mechanism in path_conv to
look for .exe rather than trying to special case it here.
* mount.h: Make MOUNT_SYMLINK a real option.
@
text
@d2167 1
a2167 1
      if (! get_file_attribute (TRUE, path, &unixattr))
a2170 2
	  if (! S_ISLNK (unixattr))
	    ;
d2178 2
d2188 1
a2218 1
	      res = 0;
d2222 1
a2222 3
	  else if (*pflags & PATH_EXEC)
	    goto close_and_return;
	  else if (!(*pflags & PATH_EXEC))
d2225 1
a2225 1
	      if (got >= 2 &&
d2229 2
a2230 1
	  close_and_return:
d2235 2
d2245 1
@


1.3
log
@        * security.cc (set_process_privileges): Removed `static'.
        (get_nt_attribute): Returns uid and gid additionally. Removed call
        to set_process_privileges().
        (get_file_attribute): Returns uid and gid additionally. Don't
        call ntea if ntsec is ON.
        (set_nt_attribute): Removed call to set_process_privileges().
        Don't call ntea if ntsec is ON.
        (acl): Removed call to set_process_privileges().
        * dcrt0.cc (dll_crt0_1): Calls set_process_privileges() now.
        * winsup.h: New prototype for set_process_privileges(),
        changed prototype for get_file_attribute().
        * fhandler.cc (get_file_owner): Discarded.
        (get_file_group): Ditto.
        (fhandler_disk_file::fstat): Discard calls to get_file_owner() and
        get_file_group().
        * path.cc (path_conv::path_conv): Added debugging output for result
        of GetVolumeInformation().
        (mount_info::conv_to_win32_path): Call backslashify() with pathbuf
        instead of src_path.
        * syscalls.cc (chown): Reformatted.
        (chmod): Replace get_file_owner() and get_file_group() calls
        by a call to get_file_attribute(). Discard local variable has_acls.
        Slightly reformatted.
        (stat_worker): Replaced idiot's (it's me) root dir check by call
        to rootdir(). Don't call num_entries() on remote drives.
        Discard local variable has_acls.
@
text
@d2159 1
a2159 1
      if (!SYMLINKATTR (fileattr))
@


1.2
log
@Respond to a multitude of g++ warnings.
@
text
@d383 5
a387 1
    set_has_acls (FALSE);
d389 5
a393 1
    set_has_acls (volflags & FS_PERSISTENT_ACLS);
d1008 1
a1008 1
	backslashify (src_path, dst, trailing_slash_p);	/* just convert */
d2381 1
a2381 1
static char *
@


1.1
log
@Initial revision
@
text
@d2064 1
a2064 1
static int __inline
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
