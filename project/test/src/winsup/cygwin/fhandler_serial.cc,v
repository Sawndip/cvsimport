head	1.95;
access;
symbols
	cygwin-1_7_35-release:1.95
	cygwin-1_7_34-release:1.95
	cygwin-1_7_33-release:1.93
	cygwin-1_7_32-release:1.93
	cygwin-1_7_31-release:1.93
	cygwin-1_7_30-release:1.93
	cygwin-1_7_29-release:1.93
	cygwin-1_7_29-release-branchpoint:1.93.0.2
	cygwin-pre-user-db:1.93
	cygwin-1_7_28-release:1.93
	cygwin-1_7_27-release:1.93
	cygwin-1_7_26-release:1.93
	cygwin-1_7_25-release:1.93
	cygwin-1_7_24-release:1.93
	cygwin-1_7_23-release:1.93
	cygwin-1_7_22-release:1.93
	cygwin-1_7_21-release:1.93
	cygwin-1_7_20-release:1.93
	cygwin-1_7_19-release:1.93
	cygwin-64bit-postmerge:1.92
	cygwin-64bit-premerge-branch:1.91.0.2
	cygwin-64bit-premerge:1.91
	cygwin-1_7_18-release:1.91
	post-ptmalloc3:1.89.2.4
	pre-ptmalloc3:1.89.2.4
	cygwin-1_7_17-release:1.89
	cygwin-64bit-branch:1.89.0.2
	cygwin-1_7_16-release:1.89
	cygwin-1_7_15-release:1.85
	cygwin-1_7_14_2-release:1.85
	cygwin-1_7_14-release:1.85
	cygwin-1_7_12-release:1.85
	cygwin-1_7_11-release:1.83
	cygwin-1_7_10-release:1.83
	signal-rewrite:1.78.0.2
	pre-notty:1.75
	cygwin-1_7_9-release:1.73
	cv-post-1_7_9:1.73.0.4
	cygwin-1_7_8-release:1.73
	cygwin-1_7_7-release:1.73
	cygwin-1_7_5-release:1.73
	cygwin-1_7_4-release:1.73
	cygwin-1_7_3-release:1.73
	cygwin-1_7_2-release:1.73
	fifo_doover3:1.73.0.2
	cygwin-1_7_1-release:1.73
	prefifo:1.72
	cv-branch-2:1.71.0.2
	pre-ripout-set_console_state_for_spawn:1.70
	EOL_registry_mounts:1.69
	preoverlapped:1.69
	drop_9x_support_start:1.68
	cr-0x5f1:1.66.0.8
	cv-branch:1.66.0.6
	pre-ptymaster-archetype:1.66
	cr-0x3b58:1.66.0.4
	cr-0x5ef:1.66.0.2
	after-mmap-privanon-noreserve:1.66
	after-mmap-revamp:1.66
	before-mmap-revamp:1.66
	cgf-more-exit-sync:1.65
	post_wait_sig_exit:1.63
	pre_wait_sig_exit:1.62
	reparent-point:1.53
	noreparent:1.53.0.2
	cr-0x5e6:1.52.0.2
	cr-0x9e:1.47.0.6
	cr-0x9d:1.47.0.4
	cgf-deleteme:1.47.0.2
	pre-sigrewrite:1.45
	corinna-01:1.45
	cr-0x9c:1.44.0.6
	cr-0x9b:1.44.0.4
	cr-0x99:1.44
	Z-emcb-cygwin_daemon:1.44.0.2
	w32api-2_2:1.42
	mingw-runtime-2_4:1.42
	pre-cgf-merge:1.44
	cgf-dev-branch:1.40.0.2
	predaemon:1.22
	cygwin_daemon_merge_HEAD:1.22
	pregp02r1:1.22.0.10
	cygnus_cvs_20020108_pre:1.22
	Z-cygwin_daemon_merge-new_HEAD:1.30
	Z-cygwin_daemon_merge_HEAD:1.30
	cygwin_daemon:1.17.0.4;
locks; strict;
comment	@// @;
expand	@o@;


1.95
date	2014.10.20.14.30.35;	author corinna;	state Exp;
branches;
next	1.94;

1.94
date	2014.08.18.11.09.56;	author corinna;	state Exp;
branches;
next	1.93;

1.93
date	2013.05.01.01.20.37;	author yselkowitz;	state Exp;
branches;
next	1.92;

1.92
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.91;

1.91
date	2013.01.21.04.38.27;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2012.11.26.13.28.52;	author corinna;	state Exp;
branches;
next	1.89;

1.89
date	2012.06.28.19.25.22;	author corinna;	state Exp;
branches
	1.89.2.1;
next	1.88;

1.88
date	2012.06.17.20.50.24;	author cgf;	state Exp;
branches;
next	1.87;

1.87
date	2012.05.25.11.08.10;	author corinna;	state Exp;
branches;
next	1.86;

1.86
date	2012.05.25.09.29.17;	author corinna;	state Exp;
branches;
next	1.85;

1.85
date	2012.03.08.09.36.11;	author corinna;	state Exp;
branches;
next	1.84;

1.84
date	2012.02.26.14.01.32;	author corinna;	state Exp;
branches;
next	1.83;

1.83
date	2011.12.13.04.11.45;	author cgf;	state Exp;
branches;
next	1.82;

1.82
date	2011.12.09.16.02.56;	author cgf;	state Exp;
branches;
next	1.81;

1.81
date	2011.12.04.18.32.00;	author cgf;	state Exp;
branches;
next	1.80;

1.80
date	2011.12.03.21.43.25;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2011.10.15.22.37.29;	author cgf;	state Exp;
branches;
next	1.78;

1.78
date	2011.07.31.12.37.52;	author corinna;	state Exp;
branches;
next	1.77;

1.77
date	2011.07.21.20.21.46;	author cgf;	state Exp;
branches;
next	1.76;

1.76
date	2011.07.13.18.59.41;	author corinna;	state Exp;
branches;
next	1.75;

1.75
date	2011.05.04.13.06.10;	author corinna;	state Exp;
branches;
next	1.74;

1.74
date	2011.05.02.10.20.35;	author corinna;	state Exp;
branches;
next	1.73;

1.73
date	2009.07.24.20.54.33;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2009.07.03.18.05.51;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2009.01.03.05.12.20;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2007.02.23.10.51.59;	author corinna;	state Exp;
branches;
next	1.68;

1.68
date	2007.02.05.12.32.23;	author corinna;	state Exp;
branches;
next	1.67;

1.67
date	2006.08.17.14.51.48;	author corinna;	state Exp;
branches;
next	1.66;

1.66
date	2005.11.14.04.28.44;	author cgf;	state Exp;
branches
	1.66.8.1;
next	1.65;

1.65
date	2005.09.28.19.22.22;	author corinna;	state Exp;
branches;
next	1.64;

1.64
date	2005.09.28.19.02.50;	author corinna;	state Exp;
branches;
next	1.63;

1.63
date	2005.09.14.14.27.54;	author cgf;	state Exp;
branches;
next	1.62;

1.62
date	2005.09.09.03.00.34;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2005.09.09.02.53.40;	author cgf;	state Exp;
branches;
next	1.60;

1.60
date	2005.08.12.02.39.12;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2005.08.11.17.03.18;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2005.08.02.09.17.09;	author corinna;	state Exp;
branches;
next	1.57;

1.57
date	2005.07.06.20.05.00;	author cgf;	state Exp;
branches;
next	1.56;

1.56
date	2005.07.05.03.16.44;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2005.03.27.01.57.37;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2005.01.13.20.10.04;	author corinna;	state Exp;
branches;
next	1.53;

1.53
date	2004.05.28.19.50.05;	author cgf;	state Exp;
branches;
next	1.52;

1.52
date	2004.04.10.13.45.09;	author corinna;	state Exp;
branches;
next	1.51;

1.51
date	2004.03.09.02.51.25;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2004.02.09.04.04.23;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2004.02.02.21.00.07;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2004.01.23.15.22.48;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2003.12.11.18.07.42;	author corinna;	state Exp;
branches
	1.47.6.1;
next	1.46;

1.46
date	2003.12.07.22.37.11;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2003.09.25.00.37.16;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2003.06.16.03.24.10;	author cgf;	state Exp;
branches;
next	1.43;

1.43
date	2003.03.09.20.31.07;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2003.02.04.03.01.17;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2003.02.01.04.48.03;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2003.01.10.12.32.46;	author corinna;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2003.01.09.08.22.04;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2002.12.14.04.01.32;	author cgf;	state Exp;
branches
	1.38.4.1;
next	1.37;

1.37
date	2002.11.15.02.12.36;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2002.11.13.19.36.12;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2002.11.07.18.47.21;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2002.11.06.01.50.32;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2002.11.05.23.15.04;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2002.11.04.04.09.14;	author cgf;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2002.09.30.04.35.17;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2002.07.24.11.01.37;	author corinna;	state Exp;
branches;
next	1.29;

1.29
date	2002.07.23.14.47.17;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.22.14.30.30;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.22.09.11.44;	author corinna;	state Exp;
branches;
next	1.26;

1.26
date	2002.07.19.14.17.11;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.05.04.01.42;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.05.01.42.28;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.25.02.22.50;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.11.00.24.46;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2001.10.29.05.28.24;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2001.10.22.18.39.22;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2001.10.13.17.23.35;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2001.10.04.02.34.19;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.26.19.22.23;	author cgf;	state Exp;
branches
	1.17.4.1;
next	1.16;

1.16
date	2001.06.26.14.47.48;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.24.22.26.51;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2001.04.24.02.07.58;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.31.22.13.02;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.18.03.34.05;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.30.01.52.29;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.20.05.57.59;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.08.02.56.54;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.07.16.23.50;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.09.03.04.16.35;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.12.05.35.42;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.08.20.46.47;	author dj;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.02.16.28.17;	author dj;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.89.2.1
date	2012.11.07.09.40.14;	author corinna;	state Exp;
branches;
next	1.89.2.2;

1.89.2.2
date	2012.11.26.13.29.09;	author corinna;	state Exp;
branches;
next	1.89.2.3;

1.89.2.3
date	2012.12.10.11.45.48;	author corinna;	state Exp;
branches;
next	1.89.2.4;

1.89.2.4
date	2013.01.21.13.52.05;	author corinna;	state Exp;
branches;
next	;

1.66.8.1
date	2006.08.17.14.51.58;	author corinna;	state Exp;
branches;
next	1.66.8.2;

1.66.8.2
date	2007.11.12.15.30.19;	author corinna;	state Exp;
branches;
next	;

1.47.6.1
date	2004.01.23.15.23.41;	author cgf;	state Exp;
branches;
next	;

1.40.2.1
date	2003.01.16.01.27.30;	author cgf;	state Exp;
branches;
next	1.40.2.2;

1.40.2.2
date	2003.02.01.04.48.22;	author cgf;	state Exp;
branches;
next	1.40.2.3;

1.40.2.3
date	2003.02.05.14.25.08;	author cgf;	state Exp;
branches;
next	1.40.2.4;

1.40.2.4
date	2003.02.14.03.03.28;	author cgf;	state Exp;
branches;
next	1.40.2.5;

1.40.2.5
date	2003.03.09.20.53.45;	author cgf;	state Exp;
branches;
next	1.40.2.6;

1.40.2.6
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	;

1.38.4.1
date	2002.12.28.16.56.16;	author cgf;	state Exp;
branches;
next	1.38.4.2;

1.38.4.2
date	2002.12.28.17.39.47;	author cgf;	state Exp;
branches;
next	1.38.4.3;

1.38.4.3
date	2003.01.09.08.22.51;	author cgf;	state Exp;
branches;
next	;

1.32.2.1
date	2002.11.07.03.47.46;	author cgf;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2002.11.07.18.50.07;	author cgf;	state Exp;
branches;
next	;

1.17.4.1
date	2002.01.04.03.56.08;	author rbcollins;	state Exp;
branches;
next	1.17.4.2;

1.17.4.2
date	2002.06.13.14.34.05;	author rbcollins;	state Exp;
branches;
next	1.17.4.3;

1.17.4.3
date	2002.07.23.03.19.13;	author scottc;	state Exp;
branches;
next	1.17.4.4;

1.17.4.4
date	2002.07.26.19.03.36;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.95
log
@	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.
@
text
@/* fhandler_serial.cc

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2011, 2012 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <unistd.h>
#include <sys/param.h>
#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "sigproc.h"
#include "pinfo.h"
#include <asm/socket.h>
#include <devioctl.h>
#include <ntddser.h>
#include "cygwait.h"

/**********************************************************************/
/* fhandler_serial */

fhandler_serial::fhandler_serial ()
  : fhandler_base (), vmin_ (0), vtime_ (0), pgrp_ (myself->pgid)
{
  need_fork_fixup (true);
}

void
fhandler_serial::overlapped_setup ()
{
  memset (&io_status, 0, sizeof (io_status));
  io_status.hEvent = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
  ProtectHandle (io_status.hEvent);
  overlapped_armed = 0;
}

void __reg3
fhandler_serial::raw_read (void *ptr, size_t& ulen)
{
  int tot;
  DWORD n;

  size_t minchars = vmin_ ? MIN (vmin_, ulen) : ulen;

  debug_printf ("ulen %ld, vmin_ %ld, vtime_ %u, hEvent %p",
		ulen, vmin_, vtime_, io_status.hEvent);
  if (!overlapped_armed)
    {
      SetCommMask (get_handle (), EV_RXCHAR);
      ResetEvent (io_status.hEvent);
    }

  for (n = 0, tot = 0; ulen; ulen -= n, ptr = (char *) ptr + n)
    {
      COMSTAT st;
      DWORD inq = vmin_ ? minchars : vtime_ ? ulen : 1;

      n = 0;

      if (vtime_) // non-interruptible -- have to use kernel timeouts
	overlapped_armed = -1;

      if (!ClearCommError (get_handle (), &ev, &st))
	goto err;
      else if (ev)
	termios_printf ("error detected %x", ev);
      else if (st.cbInQue && !vtime_)
	inq = st.cbInQue;
      else if (!is_nonblocking () && !overlapped_armed)
	{
	  if ((size_t) tot >= minchars)
	    break;
	  else if (WaitCommEvent (get_handle (), &ev, &io_status))
	    {
	      debug_printf ("WaitCommEvent succeeded: ev %x", ev);
	      if (!ev)
		continue;
	    }
	  else if (GetLastError () != ERROR_IO_PENDING)
	    goto err;
	  else
	    {
	      overlapped_armed = 1;
	      switch (cygwait (io_status.hEvent))
		{
		case WAIT_OBJECT_0:
		  if (!GetOverlappedResult (get_handle (), &io_status, &n,
					    FALSE))
		    goto err;
		  debug_printf ("n %u, ev %x", n, ev);
		  break;
		case WAIT_SIGNALED:
		  tot = -1;
		  PurgeComm (get_handle (), PURGE_RXABORT);
		  overlapped_armed = 0;
		  set_sig_errno (EINTR);
		  goto out;
		case WAIT_CANCELED:
		  PurgeComm (get_handle (), PURGE_RXABORT);
		  overlapped_armed = 0;
		  pthread::static_cancel_self ();
		  /*NOTREACHED*/
		default:
		  goto err;
		}
	    }
	}

      overlapped_armed = 0;
      ResetEvent (io_status.hEvent);
      if (inq > ulen)
	inq = ulen;
      debug_printf ("inq %u", inq);
      if (ReadFile (get_handle (), ptr, inq, &n, &io_status))
	/* Got something */;
      else if (GetLastError () != ERROR_IO_PENDING)
	goto err;
      else if (is_nonblocking ())
	{
	  /* Use CancelIo rather than PurgeComm (PURGE_RXABORT) since
	     PurgeComm apparently discards in-flight bytes while CancelIo
	     only stops the overlapped IO routine. */
	  CancelIo (get_handle ());
	  if (GetOverlappedResult (get_handle (), &io_status, &n, FALSE))
	    tot = n;
	  else if (GetLastError () != ERROR_OPERATION_ABORTED)
	    goto err;
	  if (tot == 0)
	    {
	      tot = -1;
	      set_errno (EAGAIN);
	    }
	  goto out;
	}
      else if (!GetOverlappedResult (get_handle (), &io_status, &n, TRUE))
	goto err;

      tot += n;
      debug_printf ("vtime_ %u, vmin_ %lu, n %u, tot %d", vtime_, vmin_, n, tot);
      if (vtime_ || !vmin_ || !n)
	break;
      continue;

    err:
      debug_printf ("err %E");
      if (GetLastError () != ERROR_OPERATION_ABORTED)
	{
	  PurgeComm (get_handle (), PURGE_RXABORT);
	  tot = -1;
	  __seterrno ();
	  break;
	}

      n = 0;
    }

out:
  ulen = tot;
}

/* Cover function to WriteFile to provide Posix interface and semantics
   (as much as possible).  */
ssize_t __reg3
fhandler_serial::raw_write (const void *ptr, size_t len)
{
  DWORD bytes_written;
  OVERLAPPED write_status;

  memset (&write_status, 0, sizeof (write_status));
  write_status.hEvent = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
  ProtectHandle (write_status.hEvent);

  for (;;)
    {
      if (WriteFile (get_handle (), ptr, len, &bytes_written, &write_status))
	break;

      switch (GetLastError ())
	{
	case ERROR_OPERATION_ABORTED:
	  DWORD ev;
	  if (!ClearCommError (get_handle (), &ev, NULL))
	    goto err;
	  if (ev)
	    termios_printf ("error detected %x", ev);
	  continue;
	case ERROR_IO_PENDING:
	  break;
	default:
	  goto err;
	}

      if (!is_nonblocking ())
	{
	  switch (cygwait (write_status.hEvent))
	    {
	    case WAIT_OBJECT_0:
	      break;
	    case WAIT_SIGNALED:
	      PurgeComm (get_handle (), PURGE_TXABORT);
	      set_sig_errno (EINTR);
	      ForceCloseHandle (write_status.hEvent);
	      return -1;
	    case WAIT_CANCELED:
	      PurgeComm (get_handle (), PURGE_TXABORT);
	      pthread::static_cancel_self ();
	      /*NOTREACHED*/
	    default:
	      goto err;
	    }
	}
      if (!GetOverlappedResult (get_handle (), &write_status, &bytes_written, TRUE))
	goto err;

      break;
    }

  ForceCloseHandle (write_status.hEvent);

  return bytes_written;

err:
  __seterrno ();
  ForceCloseHandle (write_status.hEvent);
  return -1;
}

int
fhandler_serial::init (HANDLE f, DWORD flags, mode_t bin)
{
  return open (flags, bin & (O_BINARY | O_TEXT));
}

int
fhandler_serial::open (int flags, mode_t mode)
{
  int res;
  COMMTIMEOUTS to;

  syscall_printf ("fhandler_serial::open (%s, %y, 0%o)",
		  get_name (), flags, mode);

  if (!fhandler_base::open (flags, mode))
    return 0;

  res = 1;

  SetCommMask (get_handle (), EV_RXCHAR);

  overlapped_setup ();

  memset (&to, 0, sizeof (to));
  SetCommTimeouts (get_handle (), &to);

  /* Reset serial port to known state of 9600-8-1-no flow control
     on open for better behavior under Win 95.

     FIXME:  This should only be done when explicitly opening the com
     port.  It should not be reset if an fd is inherited.
     Using __progname in this way, to determine how far along in the
     initialization we are, is really a terrible kludge and should
     be fixed ASAP.
  */
  if (reset_com && __progname)
    {
      DCB state;
      GetCommState (get_handle (), &state);
      syscall_printf ("setting initial state on %s (reset_com %d)",
		      get_name (), reset_com);
      state.BaudRate = CBR_9600;
      state.ByteSize = 8;
      state.StopBits = ONESTOPBIT;
      state.Parity = NOPARITY; /* FIXME: correct default? */
      state.fBinary = TRUE; /* binary xfer */
      state.EofChar = 0; /* no end-of-data in binary mode */
      state.fNull = FALSE; /* don't discard nulls in binary mode */
      state.fParity = FALSE; /* ignore parity errors */
      state.fErrorChar = FALSE;
      state.fTXContinueOnXoff = TRUE; /* separate TX and RX flow control */
      state.fOutX = FALSE; /* disable transmission flow control */
      state.fInX = FALSE; /* disable reception flow control */
      state.XonChar = 0x11;
      state.XoffChar = 0x13;
      state.fOutxDsrFlow = FALSE; /* disable DSR flow control */
      state.fRtsControl = RTS_CONTROL_ENABLE; /* ignore lead control except
						  DTR */
      state.fOutxCtsFlow = FALSE; /* disable output flow control */
      state.fDtrControl = DTR_CONTROL_ENABLE; /* assert DTR */
      state.fDsrSensitivity = FALSE; /* don't assert DSR */
      state.fAbortOnError = TRUE;
      if (!SetCommState (get_handle (), &state))
	system_printf ("couldn't set initial state for %s, %E", get_name ());
    }

  SetCommMask (get_handle (), EV_RXCHAR);
  set_open_status ();
  syscall_printf ("%p = fhandler_serial::open (%s, %y, 0%o)",
		  res, get_name (), flags, mode);
  return res;
}

int
fhandler_serial::close ()
{
  ForceCloseHandle (io_status.hEvent);
  return fhandler_base::close ();
}

/* tcsendbreak: POSIX 7.2.2.1 */
/* Break for 250-500 milliseconds if duration == 0 */
/* Otherwise, units for duration are undefined */
int
fhandler_serial::tcsendbreak (int duration)
{
  unsigned int sleeptime = 300000;

  if (duration > 0)
    sleeptime *= duration;

  if (SetCommBreak (get_handle ()) == 0)
    return -1;

  /* FIXME: need to send zero bits during duration */
  usleep (sleeptime);

  if (ClearCommBreak (get_handle ()) == 0)
    return -1;

  syscall_printf ("0 = fhandler_serial:tcsendbreak (%d)", duration);

  return 0;
}

/* tcdrain: POSIX 7.2.2.1 */
int
fhandler_serial::tcdrain ()
{
  if (FlushFileBuffers (get_handle ()) == 0)
    return -1;

  return 0;
}

/* tcflow: POSIX 7.2.2.1 */
int
fhandler_serial::tcflow (int action)
{
  DWORD win32action = 0;
  DCB dcb;
  char xchar;

  termios_printf ("action %d", action);

  switch (action)
    {
    case TCOOFF:
      win32action = SETXOFF;
      break;
    case TCOON:
      win32action = SETXON;
      break;
    case TCION:
    case TCIOFF:
      if (GetCommState (get_handle (), &dcb) == 0)
	return -1;
      if (action == TCION)
	xchar = (dcb.XonChar ? dcb.XonChar : 0x11);
      else
	xchar = (dcb.XoffChar ? dcb.XoffChar : 0x13);
      if (TransmitCommChar (get_handle (), xchar) == 0)
	return -1;
      return 0;
      break;
    default:
      return -1;
      break;
    }

  if (EscapeCommFunction (get_handle (), win32action) == 0)
    return -1;

  return 0;
}


/* switch_modem_lines: set or clear RTS and/or DTR */
int
fhandler_serial::switch_modem_lines (int set, int clr)
{
  int res = 0;

  if (set & TIOCM_RTS)
    {
      if (EscapeCommFunction (get_handle (), SETRTS))
	rts = TIOCM_RTS;
      else
	{
	  __seterrno ();
	  res = -1;
	}
    }
  else if (clr & TIOCM_RTS)
    {
      if (EscapeCommFunction (get_handle (), CLRRTS))
	rts = 0;
      else
	{
	  __seterrno ();
	  res = -1;
	}
    }
  if (set & TIOCM_DTR)
    {
      if (EscapeCommFunction (get_handle (), SETDTR))
	rts = TIOCM_DTR;
      else
	{
	  __seterrno ();
	  res = -1;
	}
    }
  else if (clr & TIOCM_DTR)
    {
      if (EscapeCommFunction (get_handle (), CLRDTR))
	rts = 0;
      else
	{
	  __seterrno ();
	  res = -1;
	}
    }

  return res;
}

/* ioctl: */
int
fhandler_serial::ioctl (unsigned int cmd, void *buf)
{
  int res = 0;

# define ibuf ((int) (intptr_t) buf)
# define ipbuf (*(int *) buf)

  DWORD ev;
  COMSTAT st;
  if (!ClearCommError (get_handle (), &ev, &st))
    {
      __seterrno ();
      res = -1;
    }
  else
    switch (cmd)
      {
      case TCFLSH:
	res = tcflush (ibuf);
	break;
      case TIOCMGET:
	DWORD modem_lines;
	if (!GetCommModemStatus (get_handle (), &modem_lines))
	  {
	    __seterrno ();
	    res = -1;
	  }
	else
	  {
	    ipbuf = 0;
	    if (modem_lines & MS_CTS_ON)
	      ipbuf |= TIOCM_CTS;
	    if (modem_lines & MS_DSR_ON)
	      ipbuf |= TIOCM_DSR;
	    if (modem_lines & MS_RING_ON)
	      ipbuf |= TIOCM_RI;
	    if (modem_lines & MS_RLSD_ON)
	      ipbuf |= TIOCM_CD;

	    DWORD cb;
	    DWORD mcr;
	    if (!DeviceIoControl (get_handle (), IOCTL_SERIAL_GET_DTRRTS,
				  NULL, 0, &mcr, 4, &cb, 0) || cb != 4)
	      ipbuf |= rts | dtr;
	    else
	      {
		if (mcr & 2)
		  ipbuf |= TIOCM_RTS;
		if (mcr & 1)
		  ipbuf |= TIOCM_DTR;
	      }
	  }
	break;
      case TIOCMSET:
	if (switch_modem_lines (ipbuf, ~ipbuf))
	  res = -1;
	break;
      case TIOCMBIS:
	if (switch_modem_lines (ipbuf, 0))
	  res = -1;
	break;
      case TIOCMBIC:
	if (switch_modem_lines (0, ipbuf))
	  res = -1;
	break;
      case TIOCCBRK:
	if (ClearCommBreak (get_handle ()) == 0)
	  {
	    __seterrno ();
	    res = -1;
	  }
	break;
      case TIOCSBRK:
	if (SetCommBreak (get_handle ()) == 0)
	  {
	    __seterrno ();
	    res = -1;
	  }
	break;
     case TIOCINQ:
       if (ev & CE_FRAME || ev & CE_IOE || ev & CE_OVERRUN || ev & CE_RXOVER
	   || ev & CE_RXPARITY)
	 {
	   set_errno (EINVAL);	/* FIXME: Use correct errno */
	   res = -1;
	 }
       else
	 ipbuf = st.cbInQue;
       break;
     case TIOCGWINSZ:
       ((struct winsize *) buf)->ws_row = 0;
       ((struct winsize *) buf)->ws_col = 0;
       break;
     case FIONREAD:
       set_errno (ENOTSUP);
       res = -1;
       break;
     default:
       res = fhandler_base::ioctl (cmd, buf);
       break;
     }

  termios_printf ("%d = ioctl(%x, %p)", res, cmd, buf);
# undef ibuf
# undef ipbuf
  return res;
}

/* tcflush: POSIX 7.2.2.1 */
int
fhandler_serial::tcflush (int queue)
{
  DWORD flags;

  switch (queue)
    {
    case TCOFLUSH:
      flags = PURGE_TXABORT | PURGE_TXCLEAR;
      break;
    case TCIFLUSH:
      flags = PURGE_RXABORT | PURGE_RXCLEAR;
      break;
    case TCIOFLUSH:
      flags = PURGE_TXABORT | PURGE_TXCLEAR | PURGE_RXABORT | PURGE_RXCLEAR;
      break;
    default:
      termios_printf ("Invalid tcflush queue %d", queue);
      set_errno (EINVAL);
      return -1;
    }

  if (!PurgeComm (get_handle (), flags))
    {
      __seterrno ();
      return -1;
    }

  return 0;
}

/* tcsetattr: POSIX 7.2.1.1 */
int
fhandler_serial::tcsetattr (int action, const struct termios *t)
{
  /* Possible actions:
    TCSANOW:   immediately change attributes.
    TCSADRAIN: flush output, then change attributes.
    TCSAFLUSH: flush output and discard input, then change attributes.
  */

  bool dropDTR = false;
  COMMTIMEOUTS to;
  DCB ostate, state;
  unsigned int ovtime = vtime_, ovmin = vmin_;
  int tmpDtr, tmpRts, res;
  res = tmpDtr = tmpRts = 0;

  termios_printf ("action %d", action);
  if ((action == TCSADRAIN) || (action == TCSAFLUSH))
    {
      FlushFileBuffers (get_handle ());
      termios_printf ("flushed file buffers");
    }
  if (action == TCSAFLUSH)
    PurgeComm (get_handle (), (PURGE_RXABORT | PURGE_RXCLEAR));

  /* get default/last comm state */
  if (!GetCommState (get_handle (), &ostate))
    return -1;

  state = ostate;

  /* -------------- Set baud rate ------------------ */
  /* FIXME: WIN32 also has 14400, 56000, 128000, and 256000.
     Unix also has 230400. */

  switch (t->c_ospeed)
    {
    case B0:
      /* Drop DTR - but leave DCB-resident bitrate as-is since
	 0 is an invalid bitrate in Win32 */
      dropDTR = true;
      break;
    case B110:
      state.BaudRate = CBR_110;
      break;
    case B300:
      state.BaudRate = CBR_300;
      break;
    case B600:
      state.BaudRate = CBR_600;
      break;
    case B1200:
      state.BaudRate = CBR_1200;
      break;
    case B2400:
      state.BaudRate = CBR_2400;
      break;
    case B4800:
      state.BaudRate = CBR_4800;
      break;
    case B9600:
      state.BaudRate = CBR_9600;
      break;
    case B19200:
      state.BaudRate = CBR_19200;
      break;
    case B38400:
      state.BaudRate = CBR_38400;
      break;
    case B57600:
      state.BaudRate = CBR_57600;
      break;
    case B115200:
      state.BaudRate = CBR_115200;
      break;
    case B128000:
      state.BaudRate = CBR_128000;
      break;
    case B230400:
      state.BaudRate = 230400 /* CBR_230400 - not defined */;
      break;
    case B256000:
      state.BaudRate = CBR_256000;
      break;
    case B460800:
      state.BaudRate = 460800 /* CBR_460800 - not defined */;
      break;
    case B500000:
      state.BaudRate = 500000 /* CBR_500000 - not defined */;
      break;
    case B576000:
      state.BaudRate = 576000 /* CBR_576000 - not defined */;
      break;
    case B921600:
      state.BaudRate = 921600 /* CBR_921600 - not defined */;
      break;
    case B1000000:
      state.BaudRate = 1000000 /* CBR_1000000 - not defined */;
      break;
    case B1152000:
      state.BaudRate = 1152000 /* CBR_1152000 - not defined */;
      break;
    case B1500000:
      state.BaudRate = 1500000 /* CBR_1500000 - not defined */;
      break;
    case B2000000:
      state.BaudRate = 2000000 /* CBR_2000000 - not defined */;
      break;
    case B2500000:
      state.BaudRate = 2500000 /* CBR_2500000 - not defined */;
      break;
    case B3000000:
      state.BaudRate = 3000000 /* CBR_3000000 - not defined */;
      break;
    default:
      /* Unsupported baud rate! */
      termios_printf ("Invalid t->c_ospeed %u", t->c_ospeed);
      set_errno (EINVAL);
      return -1;
    }

  /* -------------- Set byte size ------------------ */

  switch (t->c_cflag & CSIZE)
    {
    case CS5:
      state.ByteSize = 5;
      break;
    case CS6:
      state.ByteSize = 6;
      break;
    case CS7:
      state.ByteSize = 7;
      break;
    case CS8:
      state.ByteSize = 8;
      break;
    default:
      /* Unsupported byte size! */
      termios_printf ("Invalid t->c_cflag byte size %u",
		      t->c_cflag & CSIZE);
      set_errno (EINVAL);
      return -1;
    }

  /* -------------- Set stop bits ------------------ */

  if (t->c_cflag & CSTOPB)
    state.StopBits = TWOSTOPBITS;
  else
    state.StopBits = ONESTOPBIT;

  /* -------------- Set parity ------------------ */

  if (t->c_cflag & PARENB)
    state.Parity = (t->c_cflag & PARODD) ? ODDPARITY : EVENPARITY;
  else
    state.Parity = NOPARITY;

  state.fBinary = TRUE;     /* Binary transfer */
  state.EofChar = 0;	    /* No end-of-data in binary mode */
  state.fNull = FALSE;      /* Don't discard nulls in binary mode */

  /* -------------- Parity errors ------------------ */
  /* fParity combines the function of INPCK and NOT IGNPAR */

  if ((t->c_iflag & INPCK) && !(t->c_iflag & IGNPAR))
    state.fParity = TRUE;   /* detect parity errors */
  else
    state.fParity = FALSE;  /* ignore parity errors */

  /* Only present in Win32, Unix has no equivalent */
  state.fErrorChar = FALSE;
  state.ErrorChar = 0;

  /* -------------- Set software flow control ------------------ */
  /* Set fTXContinueOnXoff to FALSE.  This prevents the triggering of a
     premature XON when the remote device interprets a received character
     as XON (same as IXANY on the remote side).  Otherwise, a TRUE
     value separates the TX and RX functions. */

  state.fTXContinueOnXoff = TRUE;     /* separate TX and RX flow control */

  /* Transmission flow control */
  if (t->c_iflag & IXON)
    state.fOutX = TRUE;   /* enable */
  else
    state.fOutX = FALSE;  /* disable */

  /* Reception flow control */
  if (t->c_iflag & IXOFF)
    state.fInX = TRUE;    /* enable */
  else
    state.fInX = FALSE;   /* disable */

  /* XoffLim and XonLim are left at default values */

  state.XonChar = (t->c_cc[VSTART] ? t->c_cc[VSTART] : 0x11);
  state.XoffChar = (t->c_cc[VSTOP] ? t->c_cc[VSTOP] : 0x13);

  /* -------------- Set hardware flow control ------------------ */

  /* Disable DSR flow control */
  state.fOutxDsrFlow = FALSE;

  /* Some old flavors of Unix automatically enabled hardware flow
     control when software flow control was not enabled.  Since newer
     Unices tend to require explicit setting of hardware flow-control,
     this is what we do. */

  /* RTS/CTS flow control */
  if (t->c_cflag & CRTSCTS)
    {							/* enable */
      state.fOutxCtsFlow = TRUE;
      state.fRtsControl = RTS_CONTROL_HANDSHAKE;
    }
  else
    {							/* disable */
      state.fRtsControl = RTS_CONTROL_ENABLE;
      state.fOutxCtsFlow = FALSE;
      tmpRts = TIOCM_RTS;
    }

  if (t->c_cflag & CRTSXOFF)
    state.fRtsControl = RTS_CONTROL_HANDSHAKE;

  /* -------------- DTR ------------------ */
  /* Assert DTR on device open */

  state.fDtrControl = DTR_CONTROL_ENABLE;

  /* -------------- DSR ------------------ */
  /* Assert DSR at the device? */

  if (t->c_cflag & CLOCAL)
    state.fDsrSensitivity = FALSE;  /* no */
  else
    state.fDsrSensitivity = TRUE;   /* yes */

  /* -------------- Error handling ------------------ */
  /* Since read/write operations terminate upon error, we
     will use ClearCommError() to resume. */

  state.fAbortOnError = TRUE;

  if ((memcmp (&ostate, &state, sizeof (state)) != 0)
      && !SetCommState (get_handle (), &state))
    {
      /* SetCommState() failed, usually due to invalid DCB param.
	 Keep track of this so we can set errno to EINVAL later
	 and return failure */
      termios_printf ("SetCommState() failed, %E");
      __seterrno ();
      res = -1;
    }

  rbinary ((t->c_iflag & IGNCR) ? false : true);
  wbinary ((t->c_oflag & ONLCR) ? false : true);

  if (dropDTR)
    {
      EscapeCommFunction (get_handle (), CLRDTR);
      tmpDtr = 0;
    }
  else
    {
      /* FIXME: Sometimes when CLRDTR is set, setting
      state.fDtrControl = DTR_CONTROL_ENABLE will fail.  This
      is a problem since a program might want to change some
      parameters while DTR is still down. */

      EscapeCommFunction (get_handle (), SETDTR);
      tmpDtr = TIOCM_DTR;
    }

  rts = tmpRts;
  dtr = tmpDtr;

  /* The following documentation on was taken from "Linux Serial Programming
  HOWTO".  It explains how MIN (t->c_cc[VMIN] || vmin_) and TIME
  (t->c_cc[VTIME] || vtime_) is to be used.

  In non-canonical input processing mode, input is not assembled into
  lines and input processing (erase, kill, delete, etc.) does not
  occur. Two parameters control the behavior of this mode: c_cc[VTIME]
  sets the character timer, and c_cc[VMIN] sets the minimum number of
  characters to receive before satisfying the read.

  If MIN > 0 and TIME = 0, MIN sets the number of characters to receive
  before the read is satisfied. As TIME is zero, the timer is not used.

  If MIN = 0 and TIME > 0, TIME serves as a timeout value. The read will
  be satisfied if a single character is read, or TIME is exceeded (t =
  TIME *0.1 s). If TIME is exceeded, no character will be returned.

  If MIN > 0 and TIME > 0, TIME serves as an inter-character timer. The
  read will be satisfied if MIN characters are received, or the time
  between two characters exceeds TIME. The timer is restarted every time
  a character is received and only becomes active after the first
  character has been received.

  If MIN = 0 and TIME = 0, read will be satisfied immediately. The
  number of characters currently available, or the number of characters
  requested will be returned. According to Antonino (see contributions),
  you could issue a fcntl(fd, F_SETFL, FNDELAY); before reading to get
  the same result.
  */

  if (t->c_lflag & ICANON)
    {
      vmin_ = 0;
      vtime_ = 0;
    }
  else
    {
      vtime_ = t->c_cc[VTIME] * 100;
      vmin_ = t->c_cc[VMIN];
    }

  debug_printf ("vtime %d, vmin %ld", vtime_, vmin_);

  if (ovmin != vmin_ || ovtime != vtime_)
  {
    memset (&to, 0, sizeof (to));

    if ((vmin_ > 0) && (vtime_ == 0))
      {
	/* Returns immediately with whatever is in buffer on a ReadFile();
	   or blocks if nothing found.  We will keep calling ReadFile(); until
	   vmin_ characters are read */
	to.ReadIntervalTimeout = to.ReadTotalTimeoutMultiplier = MAXDWORD;
	to.ReadTotalTimeoutConstant = MAXDWORD - 1;
      }
    else if ((vmin_ == 0) && (vtime_ > 0))
      {
	/* set timeoout constant appropriately and we will only try to
	   read one character in ReadFile() */
	to.ReadTotalTimeoutConstant = vtime_;
	to.ReadIntervalTimeout = to.ReadTotalTimeoutMultiplier = MAXDWORD;
      }
    else if ((vmin_ > 0) && (vtime_ > 0))
      {
	/* time applies to the interval time for this case */
	to.ReadIntervalTimeout = vtime_;
      }
    else if ((vmin_ == 0) && (vtime_ == 0))
      {
	/* returns immediately with whatever is in buffer as per
	   Time-Outs docs in Win32 SDK API docs */
	to.ReadIntervalTimeout = MAXDWORD;
      }

    debug_printf ("ReadTotalTimeoutConstant %u, ReadIntervalTimeout %u, ReadTotalTimeoutMultiplier %u",
		  to.ReadTotalTimeoutConstant, to.ReadIntervalTimeout, to.ReadTotalTimeoutMultiplier);

    if (!SetCommTimeouts(get_handle (), &to))
      {
	/* SetCommTimeouts() failed. Keep track of this so we
	   can set errno to EINVAL later and return failure */
	termios_printf ("SetCommTimeouts() failed, %E");
	__seterrno ();
	res = -1;
      }
  }

  return res;
}

/* tcgetattr: POSIX 7.2.1.1 */
int
fhandler_serial::tcgetattr (struct termios *t)
{
  DCB state;

  /* Get current Win32 comm state */
  if (GetCommState (get_handle (), &state) == 0)
    return -1;

  /* for safety */
  memset (t, 0, sizeof (*t));

  t->c_cflag = 0;
  /* -------------- Baud rate ------------------ */
  switch (state.BaudRate)
    {
    case CBR_110:
	t->c_ospeed = t->c_ispeed = B110;
	break;
    case CBR_300:
	t->c_ospeed = t->c_ispeed = B300;
	break;
    case CBR_600:
	t->c_ospeed = t->c_ispeed = B600;
	break;
    case CBR_1200:
	t->c_ospeed = t->c_ispeed = B1200;
	break;
    case CBR_2400:
	t->c_ospeed = t->c_ispeed = B2400;
	break;
    case CBR_4800:
	t->c_ospeed = t->c_ispeed = B4800;
	break;
    case CBR_9600:
	t->c_ospeed = t->c_ispeed = B9600;
	break;
    case CBR_19200:
	t->c_ospeed = t->c_ispeed = B19200;
	break;
    case CBR_38400:
	t->c_ospeed = t->c_ispeed = B38400;
	break;
    case CBR_57600:
	t->c_ospeed = t->c_ispeed = B57600;
	break;
    case CBR_115200:
	t->c_ospeed = t->c_ispeed = B115200;
	break;
    case CBR_128000:
	t->c_ospeed = t->c_ispeed = B128000;
	break;
    case 230400: /* CBR_230400 - not defined */
	t->c_ospeed = t->c_ispeed = B230400;
	break;
    case CBR_256000:
	t->c_ospeed = t->c_ispeed = B256000;
	break;
    case 460800: /* CBR_460000 - not defined */
	t->c_ospeed = t->c_ispeed = B460800;
	break;
    case 500000: /* CBR_500000 - not defined */
	t->c_ospeed = t->c_ispeed = B500000;
	break;
    case 576000: /* CBR_576000 - not defined */
	t->c_ospeed = t->c_ispeed = B576000;
	break;
    case 921600: /* CBR_921600 - not defined */
	t->c_ospeed = t->c_ispeed = B921600;
	break;
    case 1000000: /* CBR_1000000 - not defined */
	t->c_ospeed = t->c_ispeed = B1000000;
	break;
    case 1152000: /* CBR_1152000 - not defined */
	t->c_ospeed = t->c_ispeed = B1152000;
	break;
    case 1500000: /* CBR_1500000 - not defined */
	t->c_ospeed = t->c_ispeed = B1500000;
	break;
    case 2000000: /* CBR_2000000 - not defined */
	t->c_ospeed = t->c_ispeed = B2000000;
	break;
    case 2500000: /* CBR_2500000 - not defined */
	t->c_ospeed = t->c_ispeed = B2500000;
	break;
    case 3000000: /* CBR_3000000 - not defined */
	t->c_ospeed = t->c_ispeed = B3000000;
	break;
    default:
	/* Unsupported baud rate! */
	termios_printf ("Invalid baud rate %u", state.BaudRate);
	set_errno (EINVAL);
	return -1;
    }

  /* -------------- Byte size ------------------ */

  switch (state.ByteSize)
    {
    case 5:
      t->c_cflag |= CS5;
      break;
    case 6:
      t->c_cflag |= CS6;
      break;
    case 7:
      t->c_cflag |= CS7;
      break;
    case 8:
      t->c_cflag |= CS8;
      break;
    default:
      /* Unsupported byte size! */
      termios_printf ("Invalid byte size %u", state.ByteSize);
      set_errno (EINVAL);
      return -1;
    }

  /* -------------- Stop bits ------------------ */

  if (state.StopBits == TWOSTOPBITS)
    t->c_cflag |= CSTOPB;

  /* -------------- Parity ------------------ */

  if (state.Parity == ODDPARITY)
    t->c_cflag |= (PARENB | PARODD);
  if (state.Parity == EVENPARITY)
    t->c_cflag |= PARENB;

  /* -------------- Parity errors ------------------ */

  /* fParity combines the function of INPCK and NOT IGNPAR */
  if (state.fParity)
    t->c_iflag |= INPCK;
  else
    t->c_iflag |= IGNPAR;	/* not necessarily! */

  /* -------------- Software flow control ------------------ */

  /* transmission flow control */
  if (state.fOutX)
    t->c_iflag |= IXON;

  /* reception flow control */
  if (state.fInX)
    t->c_iflag |= IXOFF;

  t->c_cc[VSTART] = (state.XonChar ? state.XonChar : 0x11);
  t->c_cc[VSTOP] = (state.XoffChar ? state.XoffChar : 0x13);

  /* -------------- Hardware flow control ------------------ */
  /* Some old flavors of Unix automatically enabled hardware flow
     control when software flow control was not enabled.  Since newer
     Unices tend to require explicit setting of hardware flow-control,
     this is what we do. */

  /* Input flow-control */
  if ((state.fRtsControl == RTS_CONTROL_HANDSHAKE) && state.fOutxCtsFlow)
    t->c_cflag |= CRTSCTS;
  if (state.fRtsControl == RTS_CONTROL_HANDSHAKE)
    t->c_cflag |= CRTSXOFF;

  /* -------------- CLOCAL --------------- */
  /* DSR is only lead toggled only by CLOCAL.  Check it to see if
     CLOCAL was called. */
  /* FIXME: If tcsetattr() hasn't been called previously, this may
     give a false CLOCAL. */

  if (!state.fDsrSensitivity)
    t->c_cflag |= CLOCAL;

  /* FIXME: need to handle IGNCR */
#if 0
  if (!rbinary ())
    t->c_iflag |= IGNCR;
#endif

  if (!wbinary ())
    t->c_oflag |= ONLCR;

  t->c_cc[VTIME] = vtime_ / 100;
  t->c_cc[VMIN] = vmin_;

  debug_printf ("vmin_ %lu, vtime_ %u", vmin_, vtime_);

  return 0;
}

void
fhandler_serial::fixup_after_fork (HANDLE parent)
{
  if (close_on_exec ())
    fhandler_base::fixup_after_fork (parent);
  overlapped_setup ();
  debug_printf ("io_status.hEvent %p", io_status.hEvent);
}

void
fhandler_serial::fixup_after_exec ()
{
  if (!close_on_exec ())
    overlapped_setup ();
  debug_printf ("io_status.hEvent %p, close_on_exec %d", io_status.hEvent, close_on_exec ());
}

int
fhandler_serial::dup (fhandler_base *child, int flags)
{
  fhandler_serial *fhc = (fhandler_serial *) child;
  fhc->overlapped_setup ();
  return fhandler_base::dup (child, flags);
}
@


1.94
log
@	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::recv_internal): Explicitely check if the socket is
	connected if it's a stream socket.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.
@
text
@d56 1
a56 1
      SetCommMask (get_handle (), EV_RXCHAR| EV_ERR | EV_BREAK | EV_CTS | EV_DSR | EV_RING | EV_RLSD | EV_RXFLAG);
@


1.93
log
@Throughout, (mainly in fhandler*) fix remaining gcc 4.7 mismatch
warnings between regparm definitions and declarations.
* smallprint.cc (__small_vswprintf): Conditionalize declaration and
setting of l_opt for only x86_64.
* spawn.cc (child_info_spawn::worker): Remove unused 'pid' variable.
* thread.cc (verifyable_object_isvalid): Temporarily define as
non-inline with gcc 4.7+, regardless of target.
@
text
@d56 1
a56 1
      SetCommMask (get_handle (), EV_RXCHAR);
@


1.92
log
@	* Merge in cygwin-64bit-branch.
@
text
@d44 1
a44 1
void __stdcall
d170 1
a170 1
ssize_t __stdcall
@


1.91
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d52 2
a53 2
  debug_printf ("ulen %d, vmin_ %d, vtime_ %d, hEvent %p", ulen, vmin_, vtime_,
		io_status.hEvent);
d97 1
a97 1
		  debug_printf ("n %d, ev %x", n, ev);
d120 1
a120 1
      debug_printf ("inq %d", inq);
d146 1
a146 1
      debug_printf ("vtime_ %d, vmin_ %d, n %d, tot %d", vtime_, vmin_, n, tot);
d247 2
a248 2
  syscall_printf ("fhandler_serial::open (%s, %p, %p)",
			get_name (), flags, mode);
d304 2
a305 2
  syscall_printf ("%p = fhandler_serial::open (%s, %p, %p)",
			res, get_name (), flags, mode);
d449 1
a449 1
# define ibuf ((int) buf)
d547 1
a547 1
  termios_printf ("%d = ioctl(%p, %p)", res, cmd, buf);
d702 1
a702 1
      termios_printf ("Invalid t->c_ospeed %d", t->c_ospeed);
d725 1
a725 1
      termios_printf ("Invalid t->c_cflag byte size %d",
d905 1
a905 1
  debug_printf ("vtime %d, vmin %d", vtime_, vmin_);
d938 1
a938 1
    debug_printf ("ReadTotalTimeoutConstant %d, ReadIntervalTimeout %d, ReadTotalTimeoutMultiplier %d",
d1045 1
a1045 1
	termios_printf ("Invalid baud rate %d", state.BaudRate);
d1068 1
a1068 1
      termios_printf ("Invalid byte size %d", state.ByteSize);
d1139 1
a1139 1
  debug_printf ("vmin_ %d, vtime_ %d", vmin_, vtime_);
@


1.90
log
@	* fhandler_registry.cc: Drop Mingw.org considerations.
	* fhandler_serial.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_tty.cc: Ditto.
	* net.cc: Ditto.
	* ntdll.h: Ditto.
	* sched.cc: Ditto.
	* sec_helper.cc: Ditto.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2008, 2009, 2011, 2012 Red Hat, Inc.
@


1.89
log
@	* fhandler_serial.cc: Fix includes for IOCTL codes to support Mingw64.
	* fhandler_tape.cc: Ditto.
	* flock.cc (allow_others_to_sync): Use PISECURITY_DESCRIPTOR since
	PSECURITY_DESCRIPTOR is supposed to be the opaque type.
	* ntdll.h: Remove CreateDisposition flags again, now that they are
	defined in Mingw64's ntdef.h.  Ditto for Create/Open flags.
@
text
@a21 1
#ifdef __MINGW64_VERSION_MAJOR
a23 3
#else
#include <ddk/ntddser.h>
#endif
@


1.89.2.1
log
@	* fhandler_procsysvipc.cc (format_procsysvipc_msg): Fix printf format
	string for 64 bit.
	* fhandler_registry.cc (fhandler_registry::readdir): Fix cast.
	* fhandler_serial.cc (ibuf): Avoid compiler warning.
	* include/cygwin/ipc.h: Include stdint.h.
	* include/cygwin/msg.h (msgqnum_t): Define as uint32_t.
	(msglen_t): Ditto.
	(struct msginfo): Convert all long members to int32_t.
	(struct msg_info): Ditto.
	* include/cygwin/sem.h (struct seminfo): Ditto.
	* include/cygwin/shm.h (shmatt_t): Define as uint32_t.
	(struct shmid_ds): Define shm_segsz as uint32_t.
	(struct shminfo): Convert all long members to int32_t.
@
text
@d453 1
a453 1
# define ibuf ((int) (intptr_t) buf)
@


1.89.2.2
log
@Pull in changes from HEAD
@
text
@d22 1
d25 3
@


1.89.2.3
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d52 2
a53 2
  debug_printf ("ulen %ld, vmin_ %ld, vtime_ %u, hEvent %p",
		ulen, vmin_, vtime_, io_status.hEvent);
d97 1
a97 1
		  debug_printf ("n %u, ev %x", n, ev);
d120 1
a120 1
      debug_printf ("inq %u", inq);
d146 1
a146 1
      debug_printf ("vtime_ %u, vmin_ %lu, n %u, tot %d", vtime_, vmin_, n, tot);
d247 2
a248 2
  syscall_printf ("fhandler_serial::open (%s, %y, 0%o)",
		  get_name (), flags, mode);
d304 2
a305 2
  syscall_printf ("%p = fhandler_serial::open (%s, %y, 0%o)",
		  res, get_name (), flags, mode);
d547 1
a547 1
  termios_printf ("%d = ioctl(%x, %p)", res, cmd, buf);
d702 1
a702 1
      termios_printf ("Invalid t->c_ospeed %u", t->c_ospeed);
d725 1
a725 1
      termios_printf ("Invalid t->c_cflag byte size %u",
d905 1
a905 1
  debug_printf ("vtime %d, vmin %ld", vtime_, vmin_);
d938 1
a938 1
    debug_printf ("ReadTotalTimeoutConstant %u, ReadIntervalTimeout %u, ReadTotalTimeoutMultiplier %u",
d1045 1
a1045 1
	termios_printf ("Invalid baud rate %u", state.BaudRate);
d1068 1
a1068 1
      termios_printf ("Invalid byte size %u", state.ByteSize);
d1139 1
a1139 1
  debug_printf ("vmin_ %lu, vtime_ %u", vmin_, vtime_);
@


1.89.2.4
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2011, 2012 Red Hat, Inc.
@


1.88
log
@Add '#include "cygwait.h"' throughout, where appropriate.
* DevNotes: Add entry cgf-000012.
* Makefile.in (DLL_OFILES): Add cygwait.o.
* sigproc.h: Remove cygwait definitions.
* cygwait.h: New file.  Define/declare Cygwin waitfor functions.
* cygwait.cc: Ditto.
* exceptions.cc: Include cygwait.h.
(handle_sigsuspend): Accommodate change in cancelable_wait arguments.
(sigpacket::process): Display thread tls in debugging output.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use symbolic names
for signal and cancel return.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_dev_dsp::Audio_out::waitforspace): Ditto.
fhandler_dev_dsp::Audio_in::waitfordata): Ditto.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::read): Ditto.
* select.cc (cygwin_select): Ditto.
* wait.cc (wait4): Ditto.
* thread.cc (cancelable_wait): Move definition to cygwait.h.
(pthread_cond::wait): Accommodate change in cancelable_wait arguments.
(pthread_mutex::lock): Ditto.
(pthread_spinlock::lock): Ditto.
(pthread::join): Ditto.
(pthread::thread_init_wrapper): Display tls in debugging output.
(semaphore::_timedwait): Ditto.
* thread.h (cw_sig_wait): Move to cygwait.h.
(cw_cancel_action): Delete.
(cancelable_wait): Move declaration to cygwait.h.
@
text
@d22 4
d27 1
@


1.87
log
@	* fhandler_serial.cc (fhandler_serial::raw_read): Check for
	ERROR_OPERATION_ABORTED rather than ERROR_IO_INCOMPLETE after CancelIo.
@
text
@d23 1
d98 1
a98 1
		case WAIT_OBJECT_0 + 1:
d104 1
a104 1
		case WAIT_OBJECT_0 + 2:
d205 1
a205 1
	    case WAIT_OBJECT_0 + 1:
d210 1
a210 1
	    case WAIT_OBJECT_0 + 2:
@


1.86
log
@	* fhandler_serial.cc (fhandler_serial::raw_read): Just call ReadFile
	directly in case of non-blocking I/O and handle result gracefully.
@
text
@d131 1
a131 1
	  else if (GetLastError () != ERROR_IO_INCOMPLETE)
@


1.85
log
@	* Throughout, replace usage of w32api's min with MIN from sys/param.h.
@
text
@d74 1
a74 1
      else if (!overlapped_armed)
a85 10
	  else if (is_nonblocking ())
	    {
	      PurgeComm (get_handle (), PURGE_RXABORT);
	      if (tot == 0)
		{
		  tot = -1;
		  set_errno (EAGAIN);
		}
	      goto out;
	    }
d125 8
a132 1
	  PurgeComm (get_handle (), PURGE_RXABORT);
@


1.84
log
@	* environ.cc (dos_file_warning): Drop declaration.
	(ignore_case_with_glob): Ditto.
	(allow_winsymlinks): Ditto.
	(reset_com): Move definition to globals.cc.
	(struct parse_thing): Add "detect_bloda" option.
	* fhandler_serial.cc (fhandler_serial::open): Drop (incorrect)
	declaration of reset_com.
	* globals.cc (ignore_case_with_glob): Move definition into C++-only
	block.
	(dos_file_warning): Define.
	(allow_winsymlinks): Define.
	(reset_com): Define.
	(detect_bloda): Define.
	* path.cc (dos_file_warning): Drop definition here.
	(allow_winsymlinks): Drop definition here.
@
text
@d14 1
d48 1
a48 1
  size_t minchars = vmin_ ? min (vmin_, ulen) : ulen;
@


1.83
log
@* cygthread.h (cygthread::name): Very minor formatting tweak.
* exceptions.cc (_cygtls::call_signal_handler): Add paranoid debugging output.
* sigproc.h (cygwait): Call signal handler when signal is detected and loop as
appropriate.
* fhandler.h (fhandler_base_overlapped::wait_return): Remove overlapped_signal.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Remove restartable
signal accommodations in light of cygwait improvements.
(fhandler_base_overlapped::raw_read): Remove now-obsolete signal loop behavior.
(fhandler_base_overlapped::raw_write): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
(fhandler_serial::raw_write): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::read): Ditto.
* ioctl.cc (ioctl): Add standard syscall introducer and leaver debug output.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2011 Red Hat, Inc.
a245 1
  extern BOOL reset_com;
@


1.82
log
@Rename cygWFMO to cygwait throughout and use the magic of polymorphism to "wait
for stuff".
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use simplified arg
form of cygwait.
* fhandler_console.cc (fhandler_console::read): Ditto.
* fhandler_audio.cc (fhandler_dev_dsp::Audio_out::waitforspac): Ditto.
(fhandler_dev_dsp::Audio_in::waitfordata): Ditto.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
(fhandler_serial::raw_write): Ditto.
* select.cc (cygwin_select): Ditto.
* sigproc.h (cygwait): Rename from cygWFMO.  Define two argument and single
argument forms of this function.
* fhandler_tty.cc (fhandler_pty_slave::open): Use method to query if tty is
open.
(fhandler_pty_slave::read): Send SIGHUP when master is detected as closed.
(fhandler_pty_common::close): Close input_available_event in callers since
master may need to signal it first.
(fhandler_pty_master::close): Lie and set input_available_event when closing,
then close input_available_event.
(fhandler_pty_slave::close): Close input_available_event explicitly here.
* tty.h (tty::is_master_closed): Declare new method.
@
text
@a97 1
restart:
a106 2
		  if (_my_tls.call_signal_handler ())
		    goto restart;
a201 1
    restart:
a206 2
	      if (_my_tls.call_signal_handler ())
		goto restart;
@


1.81
log
@* sigproc.cc (cygWFMO): Don't assume that cancellable event is always
available.
* fhandler_dsp.cc (fhandler_dev_dsp::Audio_out::waitforspace): Use cygWFMO
instead of WaitForMultipleObjects.
(fhandler_dev_dsp::Audio_in::waitfordata): Ditto.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
(fhandler_serial::raw_write): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::read): Ditto.
* select.cc (cygwin_select): Ditto for degenerate case.
@
text
@d99 1
a99 1
	      switch (cygWFMO (1, INFINITE, io_status.hEvent))
d206 1
a206 1
	  switch (cygWFMO (1, INFINITE, write_status.hEvent))
@


1.80
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@a96 3
	      HANDLE w4[3] = { io_status.hEvent, signal_arrived,
			       pthread::get_cancel_event () };
	      DWORD cnt = w4[2] ? 3 : 2;
d99 1
a99 1
	      switch (WaitForMultipleObjects (cnt, w4, FALSE, INFINITE))
a204 3
	  HANDLE w4[3] = { write_status.hEvent, signal_arrived,
			   pthread::get_cancel_event () };
	  DWORD cnt = w4[2] ? 3 : 2;
d206 1
a206 1
	  switch (WaitForMultipleObjects (cnt, w4, FALSE, INFINITE))
@


1.79
log
@* cygerrno.h (__set_errno): Modify debugging output to make searching strace
logs easier.  Throughout, change /dev/tty* to /dev/pty*.  Throughout, add flags
argument to fhandler_*::dup methods.
* devices.in: Rename (temporarily?) /dev/ttyN to /dev/ptyN.  Add /dev/ptymN
devices for pty masters.
* devices.cc: Regenerate.
* devices.h (MAX_CONSOLES): Set to max number supported by devices.in.
(fh_devices::FH_PTMX): Rename from FH_PTYM.
(device::operator int): Return by reference.
* dtable.cc (fh_alloc): Take pc as an argument rather than just the device.
This makes debugging easier since more information is available.  Actually
implement handling for already-allocated pty master devices.  Make different
decisions when generating fhandler for not-opened devices.  Add kludge to deal
with opening /dev/tty.
(cnew_no_ctor): New macro.
(build_fh_pc): Make debugging output more verbose.  Use new clone() fhandler
interface to duplicate archetypes.  Reset last term opened.
(dtable::dup_worker): Use Use new clone() fhandler interface to duplicate
archetypes.  Pass flags to child dup handler.
(dtable::dup3): Set O_NOCTTY flag if newfd is not stdin/stdout/stderr.
* fhandler.cc (fhandler_base::reset): Rename from operator =() and reduce
functionality and sense of copy direction.
(fhandler_base::open_with_arch): Use published interface to query io_handle().
Use new copyto() fhandler method to copy from/to found archetype.
* fhandler.h: Throughout, delete size(), add copyout, clone, and fhandler_*
(void *) methods.
(fhandler_base::reset): Rename from operator =().
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): change "protected" region to "private".
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): Rearrange protected/public.
(fhandler_termios::fhandler_termios): Remember last fhandler_termios "opened".
(fhandler_termios::~fhandler_termios): Forget last fhandler_termios opened.
(ioctl): Rename from ioctl_termios.  Take a void * argument.  Reflect argument
change in pinfo::set_ctty.
(fhandler_console::dup): Declare new function.  Set ctty here if appropriate.
(fhandler_pty_master::from_master): Privatize.
(fhandler_pty_master::to_master): Ditto.
(fhandler_pty_master::dwProcessId): Ditto.
(fhandler_pty_master::fhandler_pty_master): Add an `int' argument.
(fhandler_pty_master::open_setup): Declare new function.
(fhandler_pty_master::~fhandler_pty_master): Declare new method.
(fhandler_nodevice): Remove commented out function declaration.
* fhandler_console.cc: Use get_ttyp() instead of tc() throughout.
(fhandler_console::dup): Define new function to set controlling ctty on dup, as
appropriate.
(fhandler_console::ioctl): Reflect ioctl_termios name change.
(fhandler_console::setup): Rename from get_tty_stuff.
(fhandler_console::open_setup): Reflect argument change in pinfo::set_ctty.
(fhandler_console::fhandler_console): Set _tc here.
* fhandler_termios.cc (handler_termios::ioctl): Rename.  Take a void * arg like
other ioctl functions.
* fhandler_tty.cc (fhandler_pty_slave::dup): Call myself->set_ctty to
potentially reset the controlling terminal.
(fhandler_pty_slave::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_slave::fhandler_pty_slave): Take a "unit" argument.  Call setup()
here so that we will know the unit number of this fhandler as soon as possible.
Set the unit as appropriate.
(handler_pty_master::open): Move most stuff to constructor and open_setup.
(handler_pty_slave::open_setup): Reflect argument change in pinfo::set_ctty.
(handler_pty_master::open_setup): Define new function.
(fhandler_pty_master::cleanup): Clear handles as a flag that the destructor
does not have to do "close" operations.
(fhandler_pty_master::close): Ditto.
(fhandler_pty_master::~fhandler_pty_master): Define new method.
(fhandler_pty_master::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_master::setup): Allocate tty here.  Rely on handles being
returned from allocated test rather than opening them here.  Avoid setting
_need_nl here since it is already zeroed in the constructor.  Set up device
information with DEV_TTYM_MAJOR.
* path.h (path_conv &operator =): Take a const argument.
(path_conv::dup): Ditto.
(pathconv_arg::PC_OPEN): New enum.
(pathconv_arg::PC_CTTY): Ditto.
(path_types::PATH_CTTY): Ditto.
(path_types::PATH_OPEN): Ditto.
(path_conv::isopen): New method.
(path_conv::isctty_capable): Ditto.
* path.cc (path_conv::check): Set PATH_OPEN and PATH_CTTY as appropriate.
* pipe.cc (fhandler_pipe::open): Use copyto to copy pipe handle.
* syscall.cc (open): Reinstate fd > 2 check to disallow resetting ctty on
non-std* handles.
* tty.cc (tty_list::allocate): Pass out handles for allocated tty.  use
`not_allocated' to find unallocated ttys.  Avoid keeping the lock since the
allocation of the tty should be sufficient to prevent multiple access.
(tty::not_allocated): Clarify comment.  Rename.  Return handles when an unused
tty is found.  Simply test for existing tty.
(tty::exists): Rewrite to use `not_allocated'.
* tty.h (NTTYS): Reset down to actual number supported by devices.in.
(tty::not_allocated): Declare new function.
(tty_list::allocate): Pass out read/write tty handles.  Zero them when not
found.
* fhandler_proc.cc: Reflect name change from FH_PTYM -> FH_PTMX.
* pinfo.h (pinfo::set_ctty): Reduce/reorder arguments passed in.
* pinfo.cc (pinfo::set_ctty): Ditto.  Just use tc() built into the passed-in
fhandler_termios pointer.  Return true if ctty is assigned.
* syscalls.cc (open): Call build_fh_pc with PC_OPEN flag.  Set PC_CTTY if
appropriate.
(stat_worker): Remove is_dev_tty () stuff.
@
text
@d560 1
a560 1
  termios_printf ("%d = ioctl (%p, %p)", res, cmd, buf);
@


1.78
log
@	* fhandler.h (class fhandler_dev_mem): Remove dup method declaration.
	* fhandler_clipboard.cc (fhandler_dev_clipboard::dup): Accommodate the
	fact that the entire fhandler gets copied over to the child in
	operator =.
	* fhandler_floppy.cc (fhandler_dev_floppy::dup): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::dup): Ditto.
	* fhandler_serial.cc (fhandler_serial::dup): Ditto.
	* fhandler_socket.cc (fhandler_socket::dup): Ditto.
	* fhandler_virtual.cc (fhandler_virtual::dup): Ditto.
	* fhandler_mem.cc (fhandler_dev_mem::dup): Ditto.  Remove entirely.
@
text
@d1175 1
a1175 1
fhandler_serial::dup (fhandler_base *child)
d1179 1
a1179 1
  return fhandler_base::dup (child);
@


1.77
log
@Corinna Vinschen <corinna@@vinschen.de>
* fhandler.cc: Add #include for asm/socket.h for dealing with FIONREAD.
(fhandler_base::ioctl): Special-case errno for FIONREAD.
* fhandler_dsp.cc (fhandler_dev_dsp::ioctl): Rename parameter for consistency.
Call fhandler_base::ioctl to decode default condition.
* fhandler_serial.cc (fhandler_serial::ioctl): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::ioctl): Call fhandler_base::ioctl to
decode default condition.
* fhandler_windows.cc (fhandler_windows::ioctl): Ditto.
@
text
@a1178 2
  fhc->vmin_ = vmin_;
  fhc->vtime_ = vtime_;
@


1.76
log
@	* fhandler_serial.cc (fhandler_serial::raw_read): Handle non-blocking
	case more thoroughly.
@
text
@d20 1
d458 1
a458 1
fhandler_serial::ioctl (unsigned int cmd, void *buffer)
d462 2
a463 2
# define ibuffer ((int) buffer)
# define ipbuffer (*(int *) buffer)
d476 1
a476 1
	res = tcflush (ibuffer);
d487 1
a487 1
	    ipbuffer = 0;
d489 1
a489 1
	      ipbuffer |= TIOCM_CTS;
d491 1
a491 1
	      ipbuffer |= TIOCM_DSR;
d493 1
a493 1
	      ipbuffer |= TIOCM_RI;
d495 1
a495 1
	      ipbuffer |= TIOCM_CD;
d501 1
a501 1
	      ipbuffer |= rts | dtr;
d505 1
a505 1
		  ipbuffer |= TIOCM_RTS;
d507 1
a507 1
		  ipbuffer |= TIOCM_DTR;
d512 1
a512 1
	if (switch_modem_lines (ipbuffer, ~ipbuffer))
d516 1
a516 1
	if (switch_modem_lines (ipbuffer, 0))
d520 1
a520 1
	if (switch_modem_lines (0, ipbuffer))
d545 1
a545 1
	 ipbuffer = st.cbInQue;
d548 6
a553 2
       ((struct winsize *) buffer)->ws_row = 0;
       ((struct winsize *) buffer)->ws_col = 0;
d556 1
a556 2
       set_errno (ENOSYS);
       res = -1;
d560 3
a562 3
  termios_printf ("%d = ioctl (%p, %p)", res, cmd, buffer);
# undef ibuffer
# undef ipbuffer
@


1.75
log
@	* fhandler.h (class fhandler_base): Remove uninterruptible_io status
	flag.
	(fhandler_base::ready_for_read): Remove declaration.
	(fhandler_socket::ready_for_read): Ditto.
	(fhandler_pipe::ready_for_read): Ditto.
	(fhandler_tty_master::is_slow): Remove.
	* fhandler_console.cc (fhandler_console::open): Drop setting
	uninterruptible_io.
	* fhandler_serial.cc (fhandler_serial::open): Ditto.
	* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Ditto.
	(fhandler_tty_master::init_console): Ditto.
	* pipe.cc (fhandler_pipe::fhandler_pipe): Ditto.
	(fhandler_pipe::open): Ditto.
	(_pipe): Ditto.
	* select.cc (fhandler_pipe::ready_for_read): Remove.
	(fhandler_base::ready_for_read): Remove.
	* syscalls.cc (readv): Drop unneeded wait variable.  Remove entire test
	which might lead to calling ready_for_read.  Remove now unused label
	out.
@
text
@d84 11
a94 1
	  else if (!is_nonblocking ())
d137 10
@


1.74
log
@	* fhandler_serial.cc (fhandler_serial::raw_read): Add restartability
	after a signal.  Add cancelability.
	(fhandler_serial::raw_write): Wait for write to succeed if O_NONBLOCK
	is not set.  Add signal handling and cancelability.
@
text
@a248 2
  uninterruptible_io (true);	// Handled explicitly in read code

@


1.73
log
@* sigproc.h (wait_for_sigthread): Eliminate parameter.
* sigproc.cc (wait_for_sigthread): Ditto.  Don't synchronize with wait_sig
after receiving an event that it is ready to go.
(init_sig_pipe): New function.
(wait_sig): Call init_sig_pipe to create pipes for communicating signals to
this process.  Don't send sigCONT signal when initializing.
* fork.cc (frok::child): Accommodate wait_for_sigpipe parameter change.
* fhandler.h (fhandler_*::write): Make ssize_t/__stdcall.
(fhandler_*::write_overlapped): Ditto.
(fhandler_*::raw_write): Ditto.
(fhandler_*::readv): Ditto.
(fhandler_*::writev): Ditto.
(fhandler_*::raw_read): Make __stdcall.
* fhandler: Accommodate changes to read/write functions throughout.
* fhandler_clipboard.cc: Ditto.
* fhandler_console.cc: Ditto.
* fhandler_dsp.cc: Ditto.
* fhandler_fifo.cc: Ditto.
* fhandler_mailslot.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_random.cc: Ditto.
* fhandler_tape.cc: Ditto.
* fhandler_tty.cc: Ditto.
* fhandler_virtual.cc: Ditto.
* fhandler_windows.cc: Ditto.
* fhandler_zero.cc: Ditto.
* syscalls.cc (readv): Use ssize_t as temp variable.
* fhandler.cc (fhandler_base::read): Coerce returned len to signed or it will
never be treated as < 0.
(fhandler_base::wait_overlapped): Minimize calls to GetLastError.  Remove
duplicate debugging test.  Fix error return.
* fhandler.h (fhandler_fifo::fifo_name): Declare new function.
(fhandler_fifo::close): Ditto.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
* fhandler.cc (fhandler_fifo::fifo_name): Define new function.
(FIFO_BUF_SIZE): New define.
(cnp): Ditto.
(fhandler_fifo::open): Rework.  Use cnp to open named pipe.  Always open write
side as a client.  Open dummy client when writing and can't connect.
(wait): Rework.  Implement fifo_wait_for_next_client.  Handle signals during
connect better.  Add new fifo_wait_for_server code which polls
(sigh) waiting for server.
(fhandler_fifo::raw_read): Handle transition states when one client closes and
another is available.
(fhandler_fifo::close): Define.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009 Red Hat, Inc.
d45 1
a45 1
  HANDLE w4[2];
a47 3
  w4[0] = io_status.hEvent;
  w4[1] = signal_arrived;

d84 1
a84 1
	  else
d86 3
d90 2
a91 1
	      switch (WaitForMultipleObjects (2, w4, FALSE, INFINITE))
d100 2
d107 5
d185 25
@


1.72
log
@* dcrt0.cc (jit_debug): New global.
(initial_env): Set jit_debug when we are automatically starting a gdb process.
* dtable.cc (dtable::get_debugger_info): Don't tty tricks when we are being
debugged by our own captive gdb, as determined by jit_debug == true.
(dtable::init_std_file_from_handle): Detect errors when initializing a tty
early rather than at random points later.
* fhandler.h (fhandler_*::init): Return int to indicate success/failure.
* fhandler.cc (fhandler_base::init): Reflect change in return value.
* pipe.cc (fhandler_pipe::init): Ditto.
(fhandler_pipe::create_selectable): Don't say we're retrying when we aren't.
* fhandler_console.cc (fhandler_console::init): Ditto.  Return success/failure.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::init): Ditto.
(fhandler_tty_slave::open): Make debugging output more detailed.
* tty.cc (tty_list::terminate): Don't close I/O handles before all slaves have
checked in.
(tty::slave_alive): Make a non-inlined function.  Check if tty pipe handles can
be created as an additional exists check.
* tty.h (tty::slave_alive): Just define here.
@
text
@d40 1
a40 1
void
d147 1
a147 1
int
@


1.71
log
@Remove unneeded header files from source files throughout.  Update copyrights
where appropriate.
* globals.cc: New file for generic global variables.
* mkglobals_h: New file to generate globals.h.
* mkstatic: New Script used to build a (currently non-working) static
libcygwin_s.a.
* Makefile.in: Add unused rule to build a non-working libcygwin_s.a.
(DLL_OFILES): Add globals.o.  Make all objects rely on globals.h.
(globals.h): New target.  Generate globals.h.
* cygtls.h: Honor new CYGTLS_HANDLE define to control when the HANDLE operator
is allowed in _cygtls.
* dcrt0.cc: Move most globals to globals.cc.
* init.cc: Ditto.
* environ.cc (strip_title_path): Remove now-unneeded extern.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* pinfo.cc: Ditto.
(commune_process): Ditto.
* shared.cc: Ditto.
* glob.cc: Ditto.
* strace.cc: Ditto.
* exceptions.cc: Define CYGTLS_HANDLE before including winsup.h.
* path.cc (stat_suffixes): Move here.
* security.h: Add forward class path_conv declaration.
* smallprint.cc (__small_vsprintf): Make a true c++ function.
(__small_sprintf): Ditto.
(small_printf): Ditto.
(console_printf): Ditto.
(__small_vswprintf): Ditto.
(__small_swprintf): Ditto.
* spawn.cc (spawn_guts): Remove _stdcall decoration in favor of regparm.
(hExeced): Move to globals.cc
* strfuncs.cc (current_codepage): Ditto.
(active_codepage): Ditto.
* sync.cc (lock_process::locker): Move here from dcrt0.cc.
* syscalls.cc (stat_suffixes): Move to path.cc.
* tty.cc (tty::create_master): Uncapitalize fatal warning for consistency.
* winsup.h: Include globals.h to declare most of the grab bag list of globals
which were previously defined here.
* mount.h: Move USER_* defines back to shared_info.h.
* speclib: Force temporary directory cleanup.
@
text
@d193 1
a193 1
void
d196 1
a196 1
  open (flags, bin & (O_BINARY | O_TEXT));
@


1.70
log
@Remove unneeded header files from source files throughout.
@
text
@d4 1
a4 1
   2006, 2007 Red Hat, Inc.
a231 1
  extern char *__progname;
@


1.69
log
@	* exceptions.cc (dummy_ctrl_c_handler): Remove.
	(init_console_handler): Drop has_null_console_handler_routine checks.
	* fhandler_raw.cc (fhandler_dev_raw::open): Drop has_raw_devices check.
	* fhandler_serial.cc (fhandler_serial::open): Drop
	.supports_reading_modem_output_lines check.
	* miscfuncs.cc (low_priority_sleep): Drop has_switch_to_thread check.
	* shared.cc (open_shared): Drop needs_memory_protection checks.
	* spawn.cc (spawn_guts): Drop start_proc_suspended check.
	* uname.cc (uname): Drop has_valid_processorlevel check.
	* wincap.cc: Remove has_raw_devices, has_valid_processorlevel,
	supports_reading_modem_output_lines, needs_memory_protection,
	has_switch_to_thread, start_proc_suspended and
	has_null_console_handler_routine throughout.
	* wincap.h: Ditto.
@
text
@a13 1
#include <stdlib.h>
a19 1
#include <sys/termios.h>
@


1.68
log
@	* fhandler_serial.cc (fhandler_serial::tcsetattr): Add support for
	baud rates up to 3000000 baud.  Add missing 128K and 256K cases.
	(fhandler_serial::tcgetattr): Ditto.
	* include/sys/termios.h: Add baud rate definitions from B460800 up to
	B3000000.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Red Hat, Inc.
a265 17
  /* setting rts and dtr to known state so that ioctl() function with
  request TIOCMGET could return correct value of RTS and DTR lines.
  Important only for Win 9x systems */

  if (!wincap.supports_reading_modem_output_lines ())
    {
      if (EscapeCommFunction (get_handle (), SETDTR) == 0)
	system_printf ("couldn't set initial state of DTR for %s, %E", get_name ());
      if (EscapeCommFunction (get_handle (), SETRTS) == 0)
	system_printf ("couldn't set initial state of RTS for %s, %E", get_name ());

      /* even though one of above functions fail I have to set rts and dtr
      variables to initial value. */
      rts = TIOCM_RTS;
      dtr = TIOCM_DTR;
    }

@


1.67
log
@	* fhandler_serial.cc (raw_read): Evaluate minchars taking the
	vmin_ > ulen case into account.  Simplify evaluating the bytes to read.
	Don't use bytes in Queue value from ClearCommError call in case vtime_
	is > 0.  Reformat GetOverlappedResult call.  Simplify call to ReadFile.
@
text
@d638 3
d644 33
d981 3
d987 33
@


1.66
log
@* cygheap.h (init_cygheap::manage_console_count): Declare new function.
(init_cygheap::console_count): Renamed from open_fhs.  Make private.
* cygheap.cc (init_cygheap::manage_console_count): Define new function.
* dtable.cc (dtable::fixup_after_exec): Always call fixup_after_exec on
elements of fd even when they are about to be closed.
* fhandler.h (report_tty_counts): Remove open_fhs from debugging output.
* fhandler_console.cc (fhandler_console::open): Use manage_console_count rather
than manipulating count directly.
(fhandler_console::close): Ditto.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.  Don't close handles if
close_on_exec.
* fhandler_tty.cc (fhandler_tty_slave::open): Use manage_console_count() rather
than manipulating count directly.  Reflect change in arguments to
report_tty_counts().
(fhandler_tty_slave::close): Ditto for both.
(fhandler_tty_slave::dup): Ditto for both.
(fhandler_tty_slave::ioctl): Use myctty() rather than raw ctty #.
(fhandler_tty_slave::fixup_after_fork): Reflect change in arguments to
report_tty_counts().
(fhandler_tty_master::init_console): Use manage_console_count() rather than
manipulating count directly.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fixup_after_exec): Don't
perform any operations if close_on_exec.
* fhandler_dsp.cc (fhandler_dev_dsp::fixup_after_exec): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::fixup_after_exec): Ditto.
* fhandler_serial.cc (fhandler_serial::fixup_after_exec): Ditto.
* pinfo.h (_pinfo::_ctty): Declare new function.
(myctty): Declare new macro.
(__ctty): Declare new macro.
* pinfo.cc (_pinfo::_ctty): Define new function.
(_pinfo::set_ctty): Use manage_console_count() rather than manipulating count
directly.
* signal.cc (kill_pgrp): Use myctty() and __ctty() macros rather than raw ctty
#.
* syscalls.cc (setsid): Ditto.  Use manage_console_count() rather than
manipulating count directly.
@
text
@d47 1
a47 1
  size_t minchars = vmin_ ?: ulen;
d63 1
a63 1
      DWORD inq = 1;
d67 2
a68 9
      if (!vtime_ && !vmin_)
	inq = ulen;
      else if (vtime_)
	{
	  inq = ulen;	// non-interruptible -- have to use kernel timeouts
			// also note that this is not strictly correct.
			// if vmin > ulen then things won't work right.
	  overlapped_armed = -1;
	}
d74 1
a74 1
      else if (st.cbInQue)
d94 2
a95 1
		  if (!GetOverlappedResult (get_handle (), &io_status, &n, FALSE))
d116 1
a116 1
      if (ReadFile (get_handle (), ptr, min (inq, ulen), &n, &io_status))
@


1.66.8.1
log
@	* fhandler_serial.cc (raw_read): Evaluate minchars taking the
	vmin_ > ulen case into account.  Simplify evaluating the bytes to read.
	Don't use bytes in Queue value from ClearCommError call in case vtime_
	is > 0.  Reformat GetOverlappedResult call.  Simplify call to ReadFile.
@
text
@d47 1
a47 1
  size_t minchars = vmin_ ? min (vmin_, ulen) : ulen;
d63 1
a63 1
      DWORD inq = vmin_ ? minchars : vtime_ ? ulen : 1;
d67 9
a75 2
      if (vtime_) // non-interruptible -- have to use kernel timeouts
	overlapped_armed = -1;
d81 1
a81 1
      else if (st.cbInQue && !vtime_)
d101 1
a101 2
		  if (!GetOverlappedResult (get_handle (), &io_status, &n,
					    FALSE))
d122 1
a122 1
      if (ReadFile (get_handle (), ptr, inq, &n, &io_status))
@


1.66.8.2
log
@2007-11-08  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dllfixdbg: Eliminate extra objcopy step.

2007-11-07  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* dllfixdbg: Pass --only-keep-debug to objcopy, instead of
	selecting the sections manually.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread_key_create): Drop check for incoming valid object.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc: Include sync.h
	(struct shm_shmid_list): Add ref_count member.
	(struct shm_attached_list): Remove hdl and size members.  Add a parent
	member pointing to referenced shm_shmid_list entry.
	(shm_guard): New muto.
	(SLIST_LOCK): Define.
	(SLIST_UNLOCK): Define.
	(fixup_shms_after_fork): Use hdl and size members of parent
	shm_shmid_list entry.
	(shmat): Access sequential bookkeeping lists in a thread safe way.
	Accommodate change in list element layout.  Align comments.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID don't unmap views and don't close handle
	if the map is still referenced to emulate Linux and BSD behaviour.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID also unmap all views on shared mem
	as well as connected shm_attached_list entry.

2007-10-30  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Don't remove
	write bits for directories with R/O attribute.
	(fhandler_base::fhaccess): Don't shortcircuit R/O attribute with W_OK
	scenarios for directories.

2007-09-26  Corinna Vinschen  <corinna@@vinschen.de>

	* termios.cc (setspeed): Support new baud rates introduced 2007-02-05.

2007-09-18  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (fh_disk_file): Delete as global static variable and...
	(mmap64): ...define as local pointer to make mmap thread-safe.
	Accommodate throughout.  Only initialize fh_disk_file after file could
	be opened with GENERIC_EXECUTE access.

2007-09-06  Brian Dessent  <brian@@dessent.net>

	* include/sys/stdio.h (_flockfile): Don't try to lock a FILE
	that has the __SSTR flag set.
	(_ftrylockfile): Likewise.
	(_funlockfile): Likewise.

2007-08-24  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (open): Don't follow symlinks if O_EXCL is given.

2007-08-09  Ernie Coskrey  <Ernie.Coskrey@@steeleye.com>

	* gendef (sigbe): Reset "incyg" while the stack lock is active to avoid
	a potential race.

2007-08-01  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzsetwall): Don't set TZ.

2007-07-17  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fhaccess): Add check for R/O file system.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Delete.
	(dll_entry): Remove assignment to deleted variable.
	* winsup.h (in_dllentry): Delete declaration.
	* exceptions.cc (inside_kernel): Use another method to see if we are in
	dll_entry phase.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Make NO_COPY to avoid spurious false positives.

2007-07-09  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dlfcn.cc (dlclose): Don't close handle returned from
	GetModuleHandle(NULL).

2007-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc (gettimeofday): Align definition to POSIX.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc: Define __timezonefunc__ before including time.h to protect
	definition of timezone function.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/time.h: Switch to timezone variable by default.  Add
	comment.

2007-06-27  Corinna Vinschen  <corinna@@vinschen.de>

	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add heap_slop_inited member.
	* shared.cc (shared_info::heap_slop_size): Use heap_slop_inited to
	track initializing heap_slop since 0 is a valid value for heap_slop.
	Drop useless < 0 consideration.

2007-06-12  Christopher Faylor  <me+cygwin@@cgf.cx>

	* signal.cc (usleep): Use useconds_t for the type as per POSIX.

2007-06-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set pipe permission bits more
	correctly.

2007-05-29  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::set_file_pointers_for_exec): Call SetFilePointer
	correctly for 64 bit file access.  Comment out functionality.
	* fhandler.cc (fhandler_base::open): Don't set append_mode.
	(fhandler_base::write): Check for O_APPEND instead of append_mode.
	Call SetFilePointer correctly for 64 bit file access.  Handle
	errors from SetFilePointer.
	* fhandler.h (class fhandler_base): Drop append_mode status flag.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Handle
	seeking correctly for 64 bit file access.

2007-05-21  Christian Franke <franke@@computer.org>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Don't invalidate
	devbuf if new position is within buffered range.

2007-05-21  Eric Blake  <ebb9@@byu.net>

	* include/search.h (hsearch_r): Provide declaration.

2007-05-21  Christian Franke <franke@@computer.org>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Set buf size to
	sector size.  Simplify non-sector aligned case.  Handle errors from
	raw_read.

2007-05-15  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (adjust_socket_file_mode): New inline function.
	(fhandler_socket::fchmod): Squeeze mode through adjust_socket_file_mode
	before using it.
	(fhandler_socket::bind): Ditto.

2007-04-18  Brian Dessent  <brian@@dessent.net>

	* cygwin.sc: Remove duplicated .debug_macinfo section.
	* dllfixdbg: Also copy DWARF-2 sections into .dbg file.

2007-04-06  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN): Fix sign.

2007-04-04  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN, WINT_MAX): Fix definition.

2007-03-28  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Start pure-windows processes in a suspended
	state to avoid potential DuplicateHandle problems.

2007-03-07  Christopher Faylor  <me@@cgf.cx>

	* signal.cc (handle_sigprocmask): Remove extraneous
	sig_dispatch_pending.

2007-02-26  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set all file times to arbitrary
	fixed value.

2007-02-20  Christopher Faylor  <me@@cgf.cx>

	* exceptions.cc (_cygtls::signal_exit): Only call myself.exit when when
	exit_state indicates that we've visited do_exit.
	* sync.h (lock_process::lock_process): Use renamed exit_state -
	ES_PROCESS_LOCKED.
	* winsup.h: Rename ES_MUTO_SET to ES_PROCESS_LOCKED.

2007-02-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::bind): Remove printing wrong
	errno in debug output.

2007-02-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc (fhandler_serial::tcsetattr): Add support for
	baud rates up to 3000000 baud.  Add missing 128K and 256K cases.
	(fhandler_serial::tcgetattr): Ditto.
	* include/sys/termios.h: Add baud rate definitions from B460800 up to
	B3000000.

2007-01-04  Brian Ford  <Brian.Ford@@FlightSafety.com>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (PREFERRED_IO_BLKSIZE): Define as 64K.
	* fhandler.cc (fhandler_base::fstat): Set st_blksize to
	PREFERRED_IO_BLKSIZE.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::fstat): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): Ditto.

2006-11-08  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the local
	group to the token.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Create logon_id group SID by copying it from
	incoming group list.
@
text
@a637 3
    case B128000:
      state.BaudRate = CBR_128000;
      break;
a640 33
    case B256000:
      state.BaudRate = CBR_256000;
      break;
    case B460800:
      state.BaudRate = 460800 /* CBR_460800 - not defined */;
      break;
    case B500000:
      state.BaudRate = 500000 /* CBR_500000 - not defined */;
      break;
    case B576000:
      state.BaudRate = 576000 /* CBR_576000 - not defined */;
      break;
    case B921600:
      state.BaudRate = 921600 /* CBR_921600 - not defined */;
      break;
    case B1000000:
      state.BaudRate = 1000000 /* CBR_1000000 - not defined */;
      break;
    case B1152000:
      state.BaudRate = 1152000 /* CBR_1152000 - not defined */;
      break;
    case B1500000:
      state.BaudRate = 1500000 /* CBR_1500000 - not defined */;
      break;
    case B2000000:
      state.BaudRate = 2000000 /* CBR_2000000 - not defined */;
      break;
    case B2500000:
      state.BaudRate = 2500000 /* CBR_2500000 - not defined */;
      break;
    case B3000000:
      state.BaudRate = 3000000 /* CBR_3000000 - not defined */;
      break;
a944 3
    case CBR_128000:
	t->c_ospeed = t->c_ispeed = B128000;
	break;
a947 33
    case CBR_256000:
	t->c_ospeed = t->c_ispeed = B256000;
	break;
    case 460800: /* CBR_460000 - not defined */
	t->c_ospeed = t->c_ispeed = B460800;
	break;
    case 500000: /* CBR_500000 - not defined */
	t->c_ospeed = t->c_ispeed = B500000;
	break;
    case 576000: /* CBR_576000 - not defined */
	t->c_ospeed = t->c_ispeed = B576000;
	break;
    case 921600: /* CBR_921600 - not defined */
	t->c_ospeed = t->c_ispeed = B921600;
	break;
    case 1000000: /* CBR_1000000 - not defined */
	t->c_ospeed = t->c_ispeed = B1000000;
	break;
    case 1152000: /* CBR_1152000 - not defined */
	t->c_ospeed = t->c_ispeed = B1152000;
	break;
    case 1500000: /* CBR_1500000 - not defined */
	t->c_ospeed = t->c_ispeed = B1500000;
	break;
    case 2000000: /* CBR_2000000 - not defined */
	t->c_ospeed = t->c_ispeed = B2000000;
	break;
    case 2500000: /* CBR_2500000 - not defined */
	t->c_ospeed = t->c_ispeed = B2500000;
	break;
    case 3000000: /* CBR_3000000 - not defined */
	t->c_ospeed = t->c_ispeed = B3000000;
	break;
@


1.65
log
@	Revert erroneous checkin.
@
text
@d1067 3
a1069 2
  overlapped_setup ();
  debug_printf ("io_status.hEvent %p", io_status.hEvent);
@


1.64
log
@	* fhandler.h (class fhandler_dev_raw): Delete current_position and
	eof_detected status flag.  Delete is_eom and is_eof methods.
	Move drive_size, bytes_per_sector, eom_detected status flag, as well
	as the methods read_file, write_file, raw_read and raw_write to ...
	(class fhandler_dev_floppy): ... here. Remove is_eom and is_eof
	methods.  Add dup method.
	* fhandler_floppy.cc (IS_EOM): New macro.
	(fhandler_dev_floppy::is_eom): Remove.
	(fhandler_dev_floppy::is_eof): Remove.
	(fhandler_dev_floppy::fhandler_dev_floppy): Initialize status flags.
	(fhandler_dev_floppy::get_drive_info): Only call EX functions on
	systems supporting them and stop suffering strange delays.
	(fhandler_dev_floppy::read_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::write_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::open): Rearrange comment.
	(fhandler_dev_floppy::dup): New method.
	(fhandler_dev_floppy::get_current_position): New inline method.  Use
	instead of former current_position were appropriate.
	(fhandler_dev_floppy::raw_read): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::raw_write): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::lseek): Remove useless conditions.  Convert
	sector_aligned_offset to LARGE_INTEGER to improve SetFilePointer call.
	(fhandler_dev_floppy::ioctl): Move blocksize check in RDSETBLK case
	to here.
	* fhandler_raw.cc (fhandler_dev_raw::is_eom): Remove.
	(fhandler_dev_raw::is_eof): Remove.
	(fhandler_dev_raw::write_file): Remove.
	(fhandler_dev_raw::read_file): Remove.
	(fhandler_dev_raw::raw_read): Remove.
	(fhandler_dev_raw::raw_write): Remove.
	(fhandler_dev_raw::dup): Drop copying removed members.
	(fhandler_dev_raw::ioctl): Drop blocksize testing.
	* wincap.h: Implement has_disk_ex_ioctls throughout.
	* wincap.cc: Ditto.
	(wincap_vista): Preliminary wincaps for Windows Vista/Longhorn.
	(wincapc::init): Add Vista/Longhorn handling.
@
text
@d1072 1
a1072 1
fhandler_serial::dup (fhandler_base *child, HANDLE from_proc)
d1078 1
a1078 1
  return fhandler_base::dup (child, from_proc);
@


1.63
log
@Remove some more unneeded 'return;'s throughout.
@
text
@d1072 1
a1072 1
fhandler_serial::dup (fhandler_base *child)
d1078 1
a1078 1
  return fhandler_base::dup (child);
@


1.62
log
@* fhandler_serial.cc (fhandler_serial::tcgetattr): Just zero c_cflag here
rather than clearing CBAUD after the fact.
@
text
@a1068 1
  return;
@


1.61
log
@* fhandler_serial.cc (fhandler_serial::ioctl): Always return 0 for window size.
* termios.cc (tcgetattr): Clear out baud part of c_cflag since it is always
ignored.
@
text
@d914 1
d919 1
a919 1
	t->c_cflag = t->c_ospeed = t->c_ispeed = B110;
d922 1
a922 1
	t->c_cflag = t->c_ospeed = t->c_ispeed = B300;
d925 1
a925 1
	t->c_cflag = t->c_ospeed = t->c_ispeed = B600;
d928 1
a928 1
	t->c_cflag = t->c_ospeed = t->c_ispeed = B1200;
d931 1
a931 1
	t->c_cflag = t->c_ospeed = t->c_ispeed = B2400;
d934 1
a934 1
	t->c_cflag = t->c_ospeed = t->c_ispeed = B4800;
d937 1
a937 1
	t->c_cflag = t->c_ospeed = t->c_ispeed = B9600;
d940 1
a940 1
	t->c_cflag = t->c_ospeed = t->c_ispeed = B19200;
d943 1
a943 1
	t->c_cflag = t->c_ospeed = t->c_ispeed = B38400;
d946 1
a946 1
	t->c_cflag = t->c_ospeed = t->c_ispeed = B57600;
d949 1
a949 1
	t->c_cflag = t->c_ospeed = t->c_ispeed = B115200;
d952 1
a952 1
	t->c_cflag = t->c_ospeed = t->c_ispeed = B230400;
@


1.60
log
@white space
@
text
@d520 4
@


1.59
log
@* fhandler_serial.cc (fhandler_serial::tcgetattr): Return current baud rate
regardless of current DTR state.
@
text
@d388 1
a388 1
        rts = TIOCM_RTS;
d390 4
a393 4
        {
          __seterrno ();
          res = -1;
        }
d398 1
a398 1
        rts = 0;
d400 4
a403 4
        {
          __seterrno ();
          res = -1;
        }
d408 1
a408 1
        rts = TIOCM_DTR;
d410 4
a413 4
        {
          __seterrno ();
          res = -1;
        }
d418 1
a418 1
        rts = 0;
d420 4
a423 4
        {
          __seterrno ();
          res = -1;
        }
d485 2
a486 2
        if (switch_modem_lines (ipbuffer, ~ipbuffer))
          res = -1;
d490 2
a491 2
          res = -1;
        break;
d494 2
a495 2
          res = -1;
        break;
@


1.58
log
@	* include/sys/termios.h: Define TIOCMBIS and TIOCMBIC.
	* fhandler.h (class fhandler_serial): Declare switch_modem_lines.
	* fhandler_serial.cc (fhandler_serial::switch_modem_lines): New
	static function to set or clear DTR and/or RTS.
	(fhandler_serial::ioctl): Use switch_modem_lines for TIOCMSET
	and new TIOCMBIS and TIOCMBIC.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d911 3
a913 8

  /* If DTR is NOT set, return B0 as our speed */
  if (dtr != TIOCM_DTR)
    t->c_cflag = t->c_ospeed = t->c_ispeed = B0;
  else
    switch (state.BaudRate)
      {
      case CBR_110:
d916 1
a916 1
      case CBR_300:
d919 1
a919 1
      case CBR_600:
d922 1
a922 1
      case CBR_1200:
d925 1
a925 1
      case CBR_2400:
d928 1
a928 1
      case CBR_4800:
d931 1
a931 1
      case CBR_9600:
d934 1
a934 1
      case CBR_19200:
d937 1
a937 1
      case CBR_38400:
d940 1
a940 1
      case CBR_57600:
d943 1
a943 1
      case CBR_115200:
d946 1
a946 1
      case 230400: /* CBR_230400 - not defined */
d949 1
a949 1
      default:
d954 1
a954 1
      }
@


1.57
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@d379 50
d485 2
a486 37
	if (ipbuffer & TIOCM_RTS)
	  {
	    if (EscapeCommFunction (get_handle (), SETRTS))
	      rts = TIOCM_RTS;
	    else
	      {
		__seterrno ();
		res = -1;
	      }
	  }
	else
	  {
	    if (EscapeCommFunction (get_handle (), CLRRTS))
	      rts = 0;
	    else
	      {
		__seterrno ();
		res = -1;
	      }
	  }
	if (ipbuffer & TIOCM_DTR)
	  {
	    if (EscapeCommFunction (get_handle (), SETDTR))
	      dtr = TIOCM_DTR;
	    else
	      {
		__seterrno ();
		res = -1;
	      }
	  }
	else if (EscapeCommFunction (get_handle (), CLRDTR))
	  dtr = 0;
	else
	  {
	    __seterrno ();
	    res = -1;
	  }
d488 8
@


1.56
log
@Change foo (void) to foo () for all c++ functions throughout.  Remove all
fhandler_*::dump functions throughout.
* fhandler.h (fhandler_dev_mem::close): Remove pass-through function in favor
of virtual method.
(handler_dev_raw::close): Ditto.
(fhandler_dev_clipboard::fixup_after_exec): New method.
* fhandler_dev_mem.cc (fhandler_dev_mem::close): Eliminate pass through
* fhandler_dev_raw.cc (fhandler_dev_raw::close): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::close): Don't go to extra
effort when execing.
(fhandler_dev_clipboard::fixup_after_exec): New function.
* fhandler_console.cc (fhandler_console::close): Don't do "extra stuff" when we
know we're execing.
* fhandler_disk_file.cc (fhandler_disk_file::close): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::close): Ditto.
* fhandler_fifo.cc (fhandler_fifo.cc::close): Ditto.  function in favor of base
function.
* fhandler_random.cc (fhandler_dev_random::close): Ditto.
* fhandler_registry.cc (fhandler_registry::close): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::close): Ditto.
* fhandler_virtual.cc (fhandler_virtual::close): Ditto.
* pinfo.cc (proc_waiter): Remove unneeded hExeced declaration.
* sigproc.cc: Ditto.
* winsup.h (hExeced): Define here.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Just call close()
to reinitialize things to known state.
@
text
@d56 1
a56 1
      (void) SetCommMask (get_handle (), EV_RXCHAR);
d203 1
a203 1
  (void) open (flags, bin & (O_BINARY | O_TEXT));
d221 1
a221 1
  (void) SetCommMask (get_handle (), EV_RXCHAR);
d228 1
a228 1
  (void) SetCommTimeouts (get_handle (), &to);
d298 1
a298 1
  (void) ForceCloseHandle (io_status.hEvent);
@


1.55
log
@* wininfo.h (wininfo::timer_active): Delete.
(wininfo::itv): Ditto.
(wininfo::start_time): Ditto.
(wininfo::window_started): Ditto.
(wininfo::getitimer): Ditto.
(wininfo::setitimer): Ditto.
(wininfo::wininfo): Ditto.
(wininfo::lock): New method.
(wininfo::release): Ditto.
* window.cc: Use new lock/acquire wininfo methods throughout.
(wininfo::wininfo): Delete
(wininfo::getitimer): Ditto.
(wininfo::setitimer): Ditto.
(getitimer): Ditto.
(setitimer): Ditto.
(ualarm): Ditto.
(alarm): Ditto.
(wininfo::lock): Define new function.
(wininfo::release): Ditto.
(wininfo::process): Delete WM_TIMER handling.
* timer.cc (struct timetracker): Delete it, flags.  Add it_interval,
interval_us, sleepto_us, running, init_muto(), syncthread, and gettime().
(ttstart): Make NO_COPY.
(lock_timer_tracker): New class.
(timer_tracker::timer_tracker): Distinguish ttstart case.
(timer_tracker::~timer_tracker): New destructor.  Clean out events, and reset
magic.
(timer_tracker::init_muto): New method.
(to_us): Round up as per POSIX.
(timer_thread): Reorganize to match timer_tracker::settime and
timer_tracker::gettime.  Call sig_send without wait.  Call auto_release.
(timer_tracker::settime): Reorganize logic to avoid race.  Call gettime to
recover old value.
(timer_tracker::gettime): New method.
(timer_create): Properly set errno on invalid timerid.  Use new
lock_timer_tracker method.
(timer_delete): Ditto.  Simplify code slightly.
(timer_gettime): New function.
(fixup_timers_after_fork): Reinit ttstart.
(getitimer): New implementation.
(setitimer): Ditto.
(ualarm): Ditto.
(alarm): Ditto.
* cygwin.din: Export timer_gettime.
* winsup.h: Remove has has_visible_window_station declaration.
* Makefile.in (DLL_OFILES): Add lsearch.o.
* cygthread.h (cygthread::notify_detached): New element.
(cygthread::cygthread): Take optional fourth argument signifying event to
signal on thread completion.
* cygthread.cc (cygthread::stub): Signal notify_detached event, if it exists.
(cygthread::cygthread): Initialize notify_detached from fourth argument.
(cygthread::detach): Wait for notify_detached field is present.
* lsearch.cc: New file.
* search.h: Ditto.
* include/cygwin/version.h: Bump API minor number to 126.
* cygwin.din: Export lsearch, lfind.
@
text
@a200 6
fhandler_serial::dump (void)
{
  paranoid_printf ("here");
}

void
d329 1
a329 1
fhandler_serial::tcdrain (void)
@


1.54
log
@	* fhandler_serial.cc (fhandler_serial::dup): Call overlapped_setup
	for child, not for parent.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
@


1.53
log
@* path.cc (chdir): Always use the normalized_path as posix_cwd, except if it
starts with a drive.

Also perform whitespace cleanup.
@
text
@d1059 1
a1059 1
  overlapped_setup ();
@


1.52
log
@	* Use new unified status_flag accessor methods from classes fhandler_*,
	tty_min, mtinfo and fs_info thoroughout.
	* fhandler.h: Redefine all set_close_on_exec methods to take a bool
	argument.
	(enum conn_state): Rename from connect_state.
	(class fhandler_base): Rename some status flags to align with
	accessor method names.  Drop encoded flag entirely.  Unify status
	accessor methods.  Const'ify all read accessor methods.
	(class fhandler_socket): Ditto.
	(class fhandler_dev_raw): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use fs.fs_is_fat()
	instead of evaluating FATness of file system here.
	(fhandler_disk_file::opendir): Drop call to set_encoded().
	(fhandler_disk_file::readdir): Use pc.isencoded() directly.
	* mtinfo.h (class mtinfo_drive): Const'ify all read accessor methods.
	* path.cc (fsinfo_cnt): Add.
	(fs_info::update): Accomodate class changes. Evaluate file system
	name specific flags right here. Add thread safety for reading and
	writing global fsinfo array.
	* path.h (enum path_types): Drop values for flags kept in fs already.
	(struct fs_info): Move status informatin into private struct type
	status_flags.  Add accessor methods. Remove path and file system
	name string arrays in favor of status bits.
	(class path_conv): Use new fs_info status information where
	appropriate.
	(path_conf::fs_has_ea): Rename from fs_fast_ea.
	(path_conf::fs_has_acls): New method.
	(path_conf::root_dir): Remove.
	(path_conf::volname): Remove.
	* syscalls (statfs): Evaluate root dir locally.
	* tty.h (class tty_min): Unify status accessor methods.  Const'ify
	all read accessor methods.
@
text
@d537 1
a537 1
	
@


1.51
log
@* fhandler_serial.cc (fhandler_serial::ioctl): Implement TIOCSBRK and TIOCCBRK.
* include/sys/termios.h: Define TIOCSBRK and TIOCCBRK.
@
text
@d29 1
a29 1
  set_need_fork_fixup ();
d229 1
a229 1
  set_r_no_interrupt (1);	// Handled explicitly in read code
d768 2
a769 2
  set_r_binary ((t->c_iflag & IGNCR) ? 0 : 1);
  set_w_binary ((t->c_oflag & ONLCR) ? 0 : 1);
d1023 1
a1023 1
  if (!get_r_binary ())
d1027 1
a1027 1
  if (!get_w_binary ())
d1041 1
a1041 1
  if (get_close_on_exec ())
@


1.50
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d479 14
@


1.49
log
@* fhandler.h (*::fixup_after_exec): Eliminate unused handle argument.
* fhandler.h (dtable::fixup_after_exec): Eliminate unused handle argument.
* dcrt0.cc (dll_crt0_1): Reflect elimination of unused handle argument to
fixup_after_exec.
* dtable.cc (dtable::fixup_after_exec): Ditto.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dsp::fixup_after_exec): Ditto.
* fhandler_raw.cc (fhandler_raw::fixup_after_exec): Ditto.
* fhandler_socket.cc (fhandler_socket::fixup_after_exec): Ditto.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Ditto.
* pipe.cc (fhandler_pipe::fixup_after_exec): Ditto.
* spawn.cc (spawn_guts): Do not set ciresrv.parent.
* child_info.h (child_info_spawn::~child_info_spawn): Do not close parent.
Update CURR_CHILD_INFO_MAGIC.
* dcrt0.cc (dll_crt0_0): Do not close spawn_info->parent.  Pass NULL to
cygheap->fdtab.fixup_after_exec().
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
@


1.48
log
@* fhandler_serial.cc (fhandler_serial::raw_write): Prevent a deadlock when the
input buffer overflows.
(fhandler_serial::raw_read): Correct to print the actual error and only call
PurgeComm when necessary.
@
text
@d1034 1
a1034 1
fhandler_serial::fixup_after_exec (HANDLE)
@


1.47
log
@	* fhandler_serial.cc (fhandler_serial::tcflush): Simplify.  Remove
	read polling loop to avoid a hang with streaming devices.
@
text
@a135 1
      PurgeComm (get_handle (), PURGE_RXABORT);
d137 1
a137 3
      if (GetLastError () == ERROR_OPERATION_ABORTED)
	n = 0;
      else
d139 1
d144 2
d172 5
@


1.47.6.1
log
@* fhandler_serial.cc (fhandler_serial::raw_write): Prevent a deadlock when the
input buffer overflows.
(fhandler_serial::raw_read): Correct to print the actual error and only call
PurgeComm when necessary.
@
text
@d136 1
d138 3
a140 1
      if (GetLastError () != ERROR_OPERATION_ABORTED)
a141 1
	  PurgeComm (get_handle (), PURGE_RXABORT);
a145 2

      n = 0;
a171 5
	  DWORD ev;
	  if (!ClearCommError (get_handle (), &ev, NULL))
	    goto err;
	  if (ev)
	    termios_printf ("error detected %x", ev);
@


1.46
log
@Change use of BOOL, TRUE, FALSE to bool, true, false, as appropriate,
throughout.
* tty.cc (tty::common_init): Remove call to SetKernelObjectSecurity and edit
some comments.
* cygheap.h (init_cygheap::ctty): Add new element.
* devices.in (device::parse): Remove special handling for /dev/tty.
* devices.cc: Regenerate.
* dtable.cc (build_fh_pc): Don't reset /dev/tty device.  Let the device opener
do that.
* fhandler_termios.cc (tty_min::set_ctty): Redefine to _pinfo class.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Avoid setting
noninherit flag for ctty.
* tty.h: Move BOOLs to bools.
(tty_min::set_ctty): Redeclare to _pinfo class.
* pinfo.cc (_pinfo::set_ctty): Define new function based on tty_min::set_ctty.
Change first argument from tty number to tty_min class.
* pinfo.h (_pinfo::set_ctty): Declare.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Reflect move of
set_ctty to _pinfo class.
* fhandler_tty.cc (fhandler_tty_slave::open): Treat FH_TTY specially.  Use
saved cygheap value if it exists.  Otherwise convert to real device and save on
first time open.
(fhandler_tty_common::dup): Potentially set controlling tty if duping a slave
tty.
* syscalls.cc (setsid): Close controlling tty in cygheap.
* tty.cc: Change some BOOLs to bools.
@
text
@d500 1
a500 2
  if (queue == TCOFLUSH || queue == TCIOFLUSH)
    PurgeComm (get_handle (), PURGE_TXABORT | PURGE_TXCLEAR);
d502 22
a523 12
  if (queue == TCIFLUSH || queue == TCIOFLUSH)
    /* Input flushing by polling until nothing turns up
       (we stop after 1000 chars anyway) */
    for (int max = 1000; max > 0; max--)
      {
	COMSTAT st;
	if (!PurgeComm (get_handle (), PURGE_RXABORT | PURGE_RXCLEAR))
	  break;
	low_priority_sleep (100);
	if (!ClearCommError (get_handle (), &ev, &st) || !st.cbInQue)
	  break;
      }
@


1.45
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d529 1
a529 1
  BOOL dropDTR = FALSE;
d560 1
a560 1
      dropDTR = TRUE;
d743 1
a743 1
  if (dropDTR == TRUE)
d954 1
a954 1
  if (state.fParity == TRUE)
d979 1
a979 2
  if ((state.fRtsControl == RTS_CONTROL_HANDSHAKE) &&
      (state.fOutxCtsFlow == TRUE))
d990 1
a990 1
  if (state.fDsrSensitivity == FALSE)
@


1.44
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d16 1
d26 2
a27 2
fhandler_serial::fhandler_serial (int unit)
  : fhandler_base (FH_SERIAL, unit), vmin_ (0), vtime_ (0), pgrp_ (myself->pgid)
d204 1
a204 1
  (void) open (NULL, flags, bin & (O_BINARY | O_TEXT));
d208 1
a208 1
fhandler_serial::open (path_conv *, int flags, mode_t mode)
d217 1
a217 1
  if (!fhandler_base::open (NULL, flags, mode))
@


1.43
log
@whitespace cleanup
@
text
@a11 1
#include <errno.h>
@


1.42
log
@Eliminate most unneeded this-> pointers throughout.
@
text
@d837 1
a837 1
                  to.ReadTotalTimeoutConstant, to.ReadIntervalTimeout, to.ReadTotalTimeoutMultiplier);
@


1.41
log
@* fhandler_serial.cc (fhandler_serial::open): Avoid extraneous setting of res.
* termios.cc (tcsetattr): Correctly record errno after tcsetattr call.
* fhandler_serial.cc (fhandler_serial::tcsetattr): Add error-checking so that
if any Win32 SetComm*() calls fail, errno gets set to EINVAL and tcsetattr()
returns -1.  Catch invalid bitrates, mostly.  If baud rate setting is B0, just
drop DTR and leave Win32 DCB bitrate as-is since 0 is not a valid Win32
setting.
(fhandler_serial::tcgetattr): If DTR is low, populate the bitrate as B0,
otherwise get it from the DCB.
@
text
@d217 1
a217 1
  if (!this->fhandler_base::open (NULL, flags, mode))
d1015 1
a1015 1
    this->fhandler_base::fixup_after_fork (parent);
@


1.40
log
@	Split ChangeLog, create ChangeLog-2002.
	Fix copyright dates.
@
text
@d171 6
a176 6
	  case ERROR_OPERATION_ABORTED:
	    continue;
	  case ERROR_IO_PENDING:
	    break;
	  default:
	    goto err;
d217 1
a217 1
  if (!(res = this->fhandler_base::open (NULL, flags, mode)))
d350 15
a364 19
      case TCOOFF:
	win32action = SETXOFF;
	break;
      case TCOON:
	win32action = SETXON;
	break;
      case TCION:
      case TCIOFF:
	if (GetCommState (get_handle (), &dcb) == 0)
	  return -1;
	if (action == TCION)
	  xchar = (dcb.XonChar ? dcb.XonChar : 0x11);
	else
	  xchar = (dcb.XoffChar ? dcb.XoffChar : 0x13);
	if (TransmitCommChar (get_handle (), xchar) == 0)
	  return -1;
	return 0;
	break;
      default:
d366 5
a370 1
	break;
d533 2
a534 2
  int tmpDtr, tmpRts;
  tmpDtr = tmpRts = 0;
d557 46
a602 45
      case B0:	/* drop DTR */
	dropDTR = TRUE;
	state.BaudRate = 0;
	break;
      case B110:
	state.BaudRate = CBR_110;
	break;
      case B300:
	state.BaudRate = CBR_300;
	break;
      case B600:
	state.BaudRate = CBR_600;
	break;
      case B1200:
	state.BaudRate = CBR_1200;
	break;
      case B2400:
	state.BaudRate = CBR_2400;
	break;
      case B4800:
	state.BaudRate = CBR_4800;
	break;
      case B9600:
	state.BaudRate = CBR_9600;
	break;
      case B19200:
	state.BaudRate = CBR_19200;
	break;
      case B38400:
	state.BaudRate = CBR_38400;
	break;
      case B57600:
	state.BaudRate = CBR_57600;
	break;
      case B115200:
	state.BaudRate = CBR_115200;
	break;
      case B230400:
	state.BaudRate = 230400 /* CBR_230400 - not defined */;
	break;
      default:
	/* Unsupported baud rate! */
	termios_printf ("Invalid t->c_ospeed %d", t->c_ospeed);
	set_errno (EINVAL);
	return -1;
d609 18
a626 18
      case CS5:
	state.ByteSize = 5;
	break;
      case CS6:
	state.ByteSize = 6;
	break;
      case CS7:
	state.ByteSize = 7;
	break;
      case CS8:
	state.ByteSize = 8;
	break;
      default:
	/* Unsupported byte size! */
	termios_printf ("Invalid t->c_cflag byte size %d",
			t->c_cflag & CSIZE);
	set_errno (EINVAL);
	return -1;
d729 10
a738 2
  if (memcmp (&ostate, &state, sizeof (state)) != 0)
    SetCommState (get_handle (), &state);
d762 1
a762 2
  /*
  The following documentation on was taken from "Linux Serial Programming
d805 3
a807 2
  if (ovmin == vmin_ && ovtime == vtime_)
    return 0;
d809 26
a834 1
  memset (&to, 0, sizeof (to));
d836 2
a837 26
  if ((vmin_ > 0) && (vtime_ == 0))
    {
      /* Returns immediately with whatever is in buffer on a ReadFile();
	 or blocks if nothing found.  We will keep calling ReadFile(); until
	 vmin_ characters are read */
      to.ReadIntervalTimeout = to.ReadTotalTimeoutMultiplier = MAXDWORD;
      to.ReadTotalTimeoutConstant = MAXDWORD - 1;
    }
  else if ((vmin_ == 0) && (vtime_ > 0))
    {
      /* set timeoout constant appropriately and we will only try to
	 read one character in ReadFile() */
      to.ReadTotalTimeoutConstant = vtime_;
      to.ReadIntervalTimeout = to.ReadTotalTimeoutMultiplier = MAXDWORD;
    }
  else if ((vmin_ > 0) && (vtime_ > 0))
    {
      /* time applies to the interval time for this case */
      to.ReadIntervalTimeout = vtime_;
    }
  else if ((vmin_ == 0) && (vtime_ == 0))
    {
      /* returns immediately with whatever is in buffer as per
	 Time-Outs docs in Win32 SDK API docs */
      to.ReadIntervalTimeout = MAXDWORD;
    }
d839 9
a847 9
  debug_printf ("ReadTotalTimeoutConstant %d, ReadIntervalTimeout %d, ReadTotalTimeoutMultiplier %d",
		to.ReadTotalTimeoutConstant, to.ReadIntervalTimeout, to.ReadTotalTimeoutMultiplier);
  int res = SetCommTimeouts (get_handle (), &to);
  if (!res)
    {
      system_printf ("SetCommTimeout failed, %E");
      __seterrno ();
      return -1;
    }
d849 1
a849 1
  return 0;
d867 6
a872 6
  switch (state.BaudRate)
    {
      case 0:
	/* FIXME: need to drop DTR */
	t->c_cflag = t->c_ospeed = t->c_ispeed = B0;
	break;
d914 1
a914 1
    }
d920 17
a936 17
      case 5:
	t->c_cflag |= CS5;
	break;
      case 6:
	t->c_cflag |= CS6;
	break;
      case 7:
	t->c_cflag |= CS7;
	break;
      case 8:
	t->c_cflag |= CS8;
	break;
      default:
	/* Unsupported byte size! */
	termios_printf ("Invalid byte size %d", state.ByteSize);
	set_errno (EINVAL);
	return -1;
@


1.40.2.1
log
@merge from trunk
@
text
@d26 2
a27 2
fhandler_serial::fhandler_serial ()
  : fhandler_base (), vmin_ (0), vtime_ (0), pgrp_ (myself->pgid)
@


1.40.2.2
log
@merge from trunk
@
text
@d171 6
a176 6
	case ERROR_OPERATION_ABORTED:
	  continue;
	case ERROR_IO_PENDING:
	  break;
	default:
	  goto err;
d217 1
a217 1
  if (!this->fhandler_base::open (NULL, flags, mode))
d350 19
a368 9
    case TCOOFF:
      win32action = SETXOFF;
      break;
    case TCOON:
      win32action = SETXON;
      break;
    case TCION:
    case TCIOFF:
      if (GetCommState (get_handle (), &dcb) == 0)
d370 1
a370 11
      if (action == TCION)
	xchar = (dcb.XonChar ? dcb.XonChar : 0x11);
      else
	xchar = (dcb.XoffChar ? dcb.XoffChar : 0x13);
      if (TransmitCommChar (get_handle (), xchar) == 0)
	return -1;
      return 0;
      break;
    default:
      return -1;
      break;
d533 2
a534 2
  int tmpDtr, tmpRts, res;
  res = tmpDtr = tmpRts = 0;
d557 45
a601 46
    case B0:
      /* Drop DTR - but leave DCB-resident bitrate as-is since
	 0 is an invalid bitrate in Win32 */
      dropDTR = TRUE;
      break;
    case B110:
      state.BaudRate = CBR_110;
      break;
    case B300:
      state.BaudRate = CBR_300;
      break;
    case B600:
      state.BaudRate = CBR_600;
      break;
    case B1200:
      state.BaudRate = CBR_1200;
      break;
    case B2400:
      state.BaudRate = CBR_2400;
      break;
    case B4800:
      state.BaudRate = CBR_4800;
      break;
    case B9600:
      state.BaudRate = CBR_9600;
      break;
    case B19200:
      state.BaudRate = CBR_19200;
      break;
    case B38400:
      state.BaudRate = CBR_38400;
      break;
    case B57600:
      state.BaudRate = CBR_57600;
      break;
    case B115200:
      state.BaudRate = CBR_115200;
      break;
    case B230400:
      state.BaudRate = 230400 /* CBR_230400 - not defined */;
      break;
    default:
      /* Unsupported baud rate! */
      termios_printf ("Invalid t->c_ospeed %d", t->c_ospeed);
      set_errno (EINVAL);
      return -1;
d608 18
a625 18
    case CS5:
      state.ByteSize = 5;
      break;
    case CS6:
      state.ByteSize = 6;
      break;
    case CS7:
      state.ByteSize = 7;
      break;
    case CS8:
      state.ByteSize = 8;
      break;
    default:
      /* Unsupported byte size! */
      termios_printf ("Invalid t->c_cflag byte size %d",
		      t->c_cflag & CSIZE);
      set_errno (EINVAL);
      return -1;
d728 2
a729 10
  if ((memcmp (&ostate, &state, sizeof (state)) != 0)
      && !SetCommState (get_handle (), &state))
    {
      /* SetCommState() failed, usually due to invalid DCB param.
	 Keep track of this so we can set errno to EINVAL later
	 and return failure */
      termios_printf ("SetCommState() failed, %E");
      __seterrno ();
      res = -1;
    }
d753 2
a754 1
  /* The following documentation on was taken from "Linux Serial Programming
d797 2
a798 3
  if (ovmin != vmin_ || ovtime != vtime_)
  {
    memset (&to, 0, sizeof (to));
d800 1
a800 26
    if ((vmin_ > 0) && (vtime_ == 0))
      {
	/* Returns immediately with whatever is in buffer on a ReadFile();
	   or blocks if nothing found.  We will keep calling ReadFile(); until
	   vmin_ characters are read */
	to.ReadIntervalTimeout = to.ReadTotalTimeoutMultiplier = MAXDWORD;
	to.ReadTotalTimeoutConstant = MAXDWORD - 1;
      }
    else if ((vmin_ == 0) && (vtime_ > 0))
      {
	/* set timeoout constant appropriately and we will only try to
	   read one character in ReadFile() */
	to.ReadTotalTimeoutConstant = vtime_;
	to.ReadIntervalTimeout = to.ReadTotalTimeoutMultiplier = MAXDWORD;
      }
    else if ((vmin_ > 0) && (vtime_ > 0))
      {
	/* time applies to the interval time for this case */
	to.ReadIntervalTimeout = vtime_;
      }
    else if ((vmin_ == 0) && (vtime_ == 0))
      {
	/* returns immediately with whatever is in buffer as per
	   Time-Outs docs in Win32 SDK API docs */
	to.ReadIntervalTimeout = MAXDWORD;
      }
d802 26
a827 2
    debug_printf ("ReadTotalTimeoutConstant %d, ReadIntervalTimeout %d, ReadTotalTimeoutMultiplier %d",
                  to.ReadTotalTimeoutConstant, to.ReadIntervalTimeout, to.ReadTotalTimeoutMultiplier);
d829 9
a837 9
    if (!SetCommTimeouts(get_handle (), &to))
      {
	/* SetCommTimeouts() failed. Keep track of this so we
	   can set errno to EINVAL later and return failure */
	termios_printf ("SetCommTimeouts() failed, %E");
	__seterrno ();
	res = -1;
      }
  }
d839 1
a839 1
  return res;
d857 6
a862 6
  /* If DTR is NOT set, return B0 as our speed */
  if (dtr != TIOCM_DTR)
    t->c_cflag = t->c_ospeed = t->c_ispeed = B0;
  else
    switch (state.BaudRate)
      {
d904 1
a904 1
      }
d910 17
a926 17
    case 5:
      t->c_cflag |= CS5;
      break;
    case 6:
      t->c_cflag |= CS6;
      break;
    case 7:
      t->c_cflag |= CS7;
      break;
    case 8:
      t->c_cflag |= CS8;
      break;
    default:
      /* Unsupported byte size! */
      termios_printf ("Invalid byte size %d", state.ByteSize);
      set_errno (EINVAL);
      return -1;
@


1.40.2.3
log
@merge from trunk
@
text
@d217 1
a217 1
  if (!fhandler_base::open (NULL, flags, mode))
d1015 1
a1015 1
    fhandler_base::fixup_after_fork (parent);
@


1.40.2.4
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@a16 1
#include "path.h"
d204 1
a204 1
  (void) open (flags, bin & (O_BINARY | O_TEXT));
d208 1
a208 1
fhandler_serial::open (int flags, mode_t mode)
d217 1
a217 1
  if (!fhandler_base::open (flags, mode))
@


1.40.2.5
log
@merge from trunk
@
text
@d838 1
a838 1
		  to.ReadTotalTimeoutConstant, to.ReadIntervalTimeout, to.ReadTotalTimeoutMultiplier);
@


1.40.2.6
log
@merge from trunk
@
text
@d12 1
@


1.39
log
@Use isdirsep rather than SLASH_P throughout.
* path.cc (iscygdrive): Disallow /cygdrive\x.
(normalize_posix_path): "Normalize" a windows path, if detected, rather than
converting to posix.
* fhandler_serial.cc (fhandler_serial::tcsetattr): Add support and capability
checking for B230400 bitrate.
(fhandler_serial::tcgetattr): Add support for B230400 bitrate.
* include/sys/termios.h: Add B230400 definition for Posix support of 230.4Kbps.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.38
log
@Throughout, change fhandler_*::read and fhandler_*::raw_read to void functions
whose second arguments are both the lenght and the return value.
* fhandler.cc (fhandler_base::read): Rework slightly to use second argument as
input/output.  Tweak CRLF stuff.
(fhandler_base::readv): Accommodate fhandler_*::read changes.
* cygthread.h (cygthread::detach): Declare as taking optional handle argument.
(cygthread::detach): When given a handle argument, wait for the handle to be
signalled before waiting for thread to detach.  Return true when signal
detected.
@
text
@d594 3
a727 1
  /* -------------- Set state and exit ------------------ */
d895 3
@


1.38.4.1
log
@Eliminate unit argument and special unit fields from fhandler classes and
constructors throughout.
* fhandler_mem.cc (fhandler_dev_mem::fhandler_dev_mem): Make decisions based on
specific device type rather than unit number.
* fhandler_random.cc (fhandler_dev_random::write): Ditto.
(fhandler_dev_random::read): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Set device type to
"urandom" after construction of entropy_source.
* path.cc (windows_devices_names): Remove.
@
text
@d26 2
a27 2
fhandler_serial::fhandler_serial ()
  : fhandler_base (FH_SERIAL), vmin_ (0), vtime_ (0), pgrp_ (myself->pgid)
@


1.38.4.2
log
@Eliminate device number argument from fhandler constructors throughout.
@
text
@d27 1
a27 1
  : fhandler_base (), vmin_ (0), vtime_ (0), pgrp_ (myself->pgid)
@


1.38.4.3
log
@.
@
text
@a593 3
      case B230400:
	state.BaudRate = 230400 /* CBR_230400 - not defined */;
	break;
d725 1
a892 3
	break;
      case 230400: /* CBR_230400 - not defined */
	t->c_cflag = t->c_ospeed = t->c_ispeed = B230400;
@


1.37
log
@* fhandler_serial.cc (fhandler_serial::tcgetattr): Don't take any special
action when vmin_ == 0.
@
text
@d41 2
a42 2
int
fhandler_serial::raw_read (void *ptr, size_t ulen)
d149 1
a149 1
  return tot;
@


1.36
log
@* miscfuncs.cc (low_priority_sleep): New function.  Use throughout where code
is supposed to be giving up time slice.
* fhandler_console.cc (fhandler_console::read): Switch button 2/3 output escape
sequences to be consistent with xterm.
@
text
@d988 3
a991 10
  if (vmin_ == 0)
    {
      t->c_lflag |= ICANON;
      t->c_cc[VTIME] = t->c_cc[VMIN] = 0;
    }
  else
    {
      t->c_cc[VTIME] = vtime_ / 100;
      t->c_cc[VMIN] = vmin_;
    }
@


1.35
log
@* fhandler_serial.cc (fhandler_serial::ioctl): Fix typo.
@
text
@d511 1
a511 1
	Sleep (100);
@


1.34
log
@* fhandler_serial.cc (fhandler_serial::ioctl): Don't try to figure out if OS
has the capability to retrieve RTS/CTS.  Just set default values if
DeviceIoControl fails.  (suggested by Sergey Okhapkin)
@
text
@d391 1
a391 1
  if (ClearCommError (get_handle (), &ev, &st))
@


1.33
log
@* fhandler_serial.cc (fhandler_serial::raw_read): Use correct type for
minchars.
(fhandler_serial::ioctl): Set errno if the ClearCommError fails.
(fhandler_serial::tcsetattr): Use correct value for vmin_.
(fhandler_serial::tcgetattr): Ditto.
@
text
@d21 1
d60 1
a60 1
  for (n = 0, tot = 0; ulen; ulen -= n, ptr = (char *)ptr + n)
d411 1
a411 1
	    unsigned modem_status = 0;
d413 1
a413 1
	      modem_status |= TIOCM_CTS;
d415 1
a415 1
	      modem_status |= TIOCM_DSR;
d417 1
a417 1
	      modem_status |= TIOCM_RI;
d419 7
a425 3
	      modem_status |= TIOCM_CD;
	    if (!wincap.supports_reading_modem_output_lines ())
	      modem_status |= rts | dtr;
a427 16
		DWORD cb;
		DWORD mcr;
		BOOL result = DeviceIoControl (get_handle (), 0x001B0078, NULL,
					       0, &mcr, 4, &cb, 0);
		if (!result)
		  {
		    __seterrno ();
		    res = -1;
		    goto out;
		  }
		if (cb != 4)
		  {
		    set_errno (EINVAL);	/* FIXME: right errno? */
		    res = -1;
		    goto out;
		  }
d429 1
a429 1
		  modem_status |= TIOCM_RTS;
d431 1
a431 1
		  modem_status |= TIOCM_DTR;
a432 1
	    ipbuffer = modem_status;
d466 2
d470 2
a471 7
	    if (EscapeCommFunction (get_handle (), CLRDTR))
	      dtr = 0;
	    else
	      {
		__seterrno ();
		res = -1;
	      }
a489 1
out:
@


1.32
log
@* fhandler_serial.cc (fhandler_serial::ioctl): Reformat.  Set errno
appropriately.  Exit from the bottom.  Correctly deal with third argument for
TCFLSH.  (Suggested by Sergey Okhapkin)
@
text
@d46 1
a46 1
  DWORD minchars = vmin_ ?: ulen;
d84 1
a84 1
	  if ((size_t)tot >= minchars)
d391 4
a394 1
    res = -1;
d403 1
a403 1
	if (GetCommModemStatus (get_handle (), &modem_lines) == 0)
d800 1
a800 1
      vmin_ = MAXDWORD;
d1005 1
a1005 1
  if (vmin_ == MAXDWORD)
@


1.32.2.1
log
@* include/cygwin/version.h: Bump API minor number for below export.
* cygwin.din (pututline): New exported function.
* syscalls.cc (login): Use pututiline().
(setutent): Open utmp as read/write.
(endutent): Check if utmp file is open.
(utmpname): call endutent() to close current utmp file.
(getutid): Enable all cases, use strncmp() to compare ut_id fields.
(pututline): New.
* tty.cc (create_tty_master): Set ut_pid to current pid.
* fhandler.h (fhandler_serial::vmin_): Declare as size_t.
* fhandler_serial.cc (fhandler_serial::raw_read): Use correct type for
minchars.
(fhandler_serial::ioctl): Set errno if the ClearCommError fails.
(fhandler_serial::tcsetattr): Use correct value for vmin_.
(fhandler_serial::tcgetattr): Ditto.
* fhandler_socket.cc (fhandler_socket::recvmsg): Call if from == NULL
WSARecvFrom with fromlen = NULL.
@
text
@a20 1
#include <ddk/ntddser.h>
d46 1
a46 1
  size_t minchars = vmin_ ?: ulen;
d59 1
a59 1
  for (n = 0, tot = 0; ulen; ulen -= n, ptr = (char *) ptr + n)
d84 1
a84 1
	  if ((size_t) tot >= minchars)
d391 1
a391 4
    {
      __seterrno ();
      res = -1;
    }
d400 1
a400 1
	if (!GetCommModemStatus (get_handle (), &modem_lines))
d407 1
a407 1
	    ipbuffer = 0;
d409 1
a409 1
	      ipbuffer |= TIOCM_CTS;
d411 1
a411 1
	      ipbuffer |= TIOCM_DSR;
d413 1
a413 1
	      ipbuffer |= TIOCM_RI;
d415 3
a417 7
	      ipbuffer |= TIOCM_CD;

	    DWORD cb;
	    DWORD mcr;
	    if (!DeviceIoControl (get_handle (), IOCTL_SERIAL_GET_DTRRTS,
				  NULL, 0, &mcr, 4, &cb, 0) || cb != 4)
	      ipbuffer |= rts | dtr;
d420 16
d437 1
a437 1
		  ipbuffer |= TIOCM_RTS;
d439 1
a439 1
		  ipbuffer |= TIOCM_DTR;
d441 1
a474 2
	else if (EscapeCommFunction (get_handle (), CLRDTR))
	  dtr = 0;
d477 7
a483 2
	    __seterrno ();
	    res = -1;
d502 1
d797 1
a797 1
      vmin_ = 0;
d1002 1
a1002 1
  if (vmin_ == 0)
@


1.32.2.2
log
@* fhandler_serial.cc (fhandler_serial::ioctl): Fix typo.
@
text
@d391 1
a391 1
  if (!ClearCommError (get_handle (), &ev, &st))
@


1.31
log
@Remove \n from calls to strace class printfs throughout.
@
text
@d383 4
d390 111
a500 7
  DWORD action;
  DWORD modemLines;
  DWORD mcr;
  DWORD cbReturned;
  bool result;
  int modemStatus;
  int request;
d502 5
a506 75
  request = *(int *) buffer;
  action = 0;
  modemStatus = 0;
  if (!ClearCommError (get_handle (), &ev, &st))
    return -1;
  switch (cmd)
    {
    case TIOCMGET:
      if (GetCommModemStatus (get_handle (), &modemLines) == 0)
	return -1;
      if (modemLines & MS_CTS_ON)
	modemStatus |= TIOCM_CTS;
      if (modemLines & MS_DSR_ON)
	modemStatus |= TIOCM_DSR;
      if (modemLines & MS_RING_ON)
	modemStatus |= TIOCM_RI;
      if (modemLines & MS_RLSD_ON)
	modemStatus |= TIOCM_CD;
      if (!wincap.supports_reading_modem_output_lines ())
	modemStatus |= rts | dtr;
      else
	{
	  result = DeviceIoControl (get_handle (),
				    0x001B0078,
				    NULL, 0, &mcr, 4, &cbReturned, 0);
	  if (!result)
	    return -1;
	  if (cbReturned != 4)
	    return -1;
	  if (mcr & 2)
	    modemStatus |= TIOCM_RTS;
	  if (mcr & 1)
	    modemStatus |= TIOCM_DTR;
	}
      *(int *) buffer = modemStatus;
      return 0;
    case TIOCMSET:
      if (request & TIOCM_RTS)
	{
	  if (EscapeCommFunction (get_handle (), SETRTS) == 0)
	    return -1;
	  else
	    rts = TIOCM_RTS;
	}
      else
	{
	  if (EscapeCommFunction (get_handle (), CLRRTS) == 0)
	    return -1;
	  else
	    rts = 0;
	}
      if (request & TIOCM_DTR)
	{
	  if (EscapeCommFunction (get_handle (), SETDTR) == 0)
	    return -1;
	  else
	    dtr = TIOCM_DTR;
	}
      else
	{
	  if (EscapeCommFunction (get_handle (), CLRDTR) == 0)
	    return -1;
	  else
	    dtr = 0;
	}
      return 0;
   case TIOCINQ:
     if (ev & CE_FRAME | ev & CE_IOE | ev & CE_OVERRUN |
	 ev & CE_RXOVER | ev & CE_RXPARITY)
       return -1;
     *(int *) buffer = st.cbInQue;
     return 0;
   default:
     return -1;
   }
@


1.30
log
@	* fhandler_serial.cc: Change 'must_init_serial_line capability'
	to 'supports_reading_modem_output_lines' throughout (negated meaning).
	* wincap.cc: Ditto.
	* wincap.h: Ditto.
@
text
@d768 1
a768 1
  debug_printf ("vtime %d, vmin %d\n", vtime_, vmin_);
@


1.29
log
@	* fhandler_serial.cc: Use must_init_serial_line capability throughout.
	* wincap.cc: Set flag must_init_serial_line appropriately.
	* wincap.h: Add flag must_init_serial_line.
@
text
@d275 1
a275 1
  if (wincap.must_init_serial_line ())
d412 1
a412 1
      if (wincap.must_init_serial_line ())
@


1.28
log
@* fhandler_serial.cc: Fix formatting problems introduced by below changes.
@
text
@d275 1
a275 1
  if (!wincap.is_winnt ())
d412 1
a412 1
      if (!wincap.is_winnt ())
@


1.27
log
@	* fhandler.h (class fhandler_serial): Add new members of
	the class - rts,dtr and method ioctl(). Variables rts and dtr
	important for Win 9x only.
	* fhandler_serial.cc (fhandler_serial::open): Add initial setting
	of dtr and rts. Important for Win 9x only.
	(fhandler_serial::ioctl): New function. Implements commands TIOCMGET,
	TIOCMSET and TIOCINQ.
	(fhandler_serial::tcflush): Fixed found error.
	(fhandler_serial::tcsetattr): Add settings of rts and dtr. Important
	for Win 9x only.
	* termios.h: Add new defines as a support for ioctl() function
	on serial device.
@
text
@d121 1
a121 1
      if (ReadFile (get_handle(), ptr, min (inq, ulen), &n, &io_status))
d165 1
a165 1
      if (WriteFile (get_handle(), ptr, len, &bytes_written, &write_status))
d184 1
a184 1
  ForceCloseHandle(write_status.hEvent);
d190 1
a190 1
  ForceCloseHandle(write_status.hEvent);
d272 1
a272 1
  request TIOCMGET could return correct value of RTS and DTR lines. 
d274 14
a287 14
  
  if (wincap.is_winnt() == false)
  {
    if (EscapeCommFunction (get_handle (), SETDTR) == 0)
      system_printf ("couldn't set initial state of DTR for %s, %E", get_name ());
    if (EscapeCommFunction (get_handle (), SETRTS) == 0)
      system_printf ("couldn't set initial state of RTS for %s, %E", get_name ());
      
    /* even though one of above functions fail I have to set rts and dtr
    variables to initial value. */
    rts = TIOCM_RTS;
    dtr = TIOCM_DTR;
  }
  
d344 1
a344 1
      
d393 1
a393 1
  
d403 1
a403 1
        return -1;
d405 1
a405 1
        modemStatus |= TIOCM_CTS;
d407 1
a407 1
        modemStatus |= TIOCM_DSR;
d409 1
a409 1
        modemStatus |= TIOCM_RI;
d411 5
a415 5
        modemStatus |= TIOCM_CD;
      if (wincap.is_winnt() == true)
        {
	
	  /* here is Windows NT or Windows 2000 part */
d417 1
a417 1
                                    0x001B0078,
d419 1
a419 1
          if (!result)
d421 1
a421 1
          if (cbReturned != 4)
d423 1
a423 1
          if (mcr & 2)
d425 1
a425 1
          if (mcr & 1)
a426 8
	    
	}
      else
        {
	
	  /* here is Windows 9x part */
	  modemStatus |= rts | dtr;
	  
d432 1
a432 1
        {
d435 1
a435 1
          else
d439 1
a439 1
        {
d442 1
a442 1
          else
d446 1
a446 1
        {
d449 1
a449 1
          else
d453 1
a453 1
        {
d456 1
a456 1
          else
d462 1
a462 1
         ev & CE_RXOVER | ev & CE_RXPARITY)
d469 1
a469 1
}    
d722 1
a722 1
    
@


1.26
log
@* fhandler_serial.cc (fhandler_serial::tcflush): Fix typo.
@
text
@d271 17
d344 1
a344 1

d378 101
d516 2
d683 1
d716 4
a719 1
    EscapeCommFunction (get_handle (), CLRDTR);
d728 1
d730 3
@


1.25
log
@* dtable.cc (handle_to_fn): Attempt to handle "raw" accesses to remote shares.
* path.cc (mount_info::conv_to_win32_path): Set flags to binary when mount
entry is not found.
(mount_info::set_flags_from_win32_path): Ditto.
@
text
@d368 1
a368 1
  if (queue == TCIFLUSH | queue == TCIOFLUSH)
@


1.24
log
@Remove fcntl.h includes throughout.
* fhandler.h: Move fcntl.h include here.
(fhandler_base::set_flags): Accept supplied_bin argument.  Make non-inlined.
* dtable.cc (dtable::init_std_file_from_handle): Just use binmode from pc.
(reset_to_open_binmode): Use set_flags.
* cygwin.din (open): Avoid newlib wrapper.
(read): Ditto.
(unlink): Ditto.
(write): Ditto.
* fhandler.cc (fhandler_base::set_flags): Accept supplied_bin argument.  Make
binmode decisions here.
(fhandler_base::open): Avoid using pc if it is NULL.  Eliminate binmode logic.
Just call set_flags with binmode argument.
(fhandler_base::init): Call set_flags with binmode argument.
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::init): Force binary on open.
* fhandler_disk_file.cc (fhandler_disk_file::open): Don't set binmode here.
Let it happen in base class.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Force binmode open.  Set return
value appropriately if unable to open.
* fhandler_proc.cc (fhandler_proc::open): Make sure flags are set before
open_status.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Force O_BINARY by default.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (path_conv::check): Avoid checking for extension when error or
directory.
(set_flags): Set PATH_TEXT explicitly, when appropriate.
(mount_info::conv_to_win32_path): Use set_flags() to set path flags.
* path.h (PATH_TEXT): New enum.
(path_conv::binmode): Return appropriate constant based on binmode.
* pipe.cc (make_pipe): Set binmode to O_TEXT xor O_BINARY.
* syscalls.cc (setmode_helper): Make debugging message a little clearer.
(setmode): Set binmode via set_flags.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Red Hat, Inc.
@


1.23
log
@Remove unneeded sync.h, where appropriate, throughout.  Remove unneeded heap.h,
where appropriate, throughout.  Remove unneeded exceptions.h, where
appropriate, throughout.  Remove unneeded perprocess.h, where appropriate,
throughout.
@
text
@a11 1
#include <fcntl.h>
d203 1
a203 2
  fhandler_base::init (f, flags, bin);
  (void) open (NULL, flags, bin ? O_BINARY : 0);
@


1.22
log
@* fhandler.h (fhandler_serial::ev): New class member.
* fhandler_serial.cc (fhandler_serial::raw_read): Use class member for event
status.
* select.cc (peek_serial): Ditto.
@
text
@a18 1
#include "sync.h"
@


1.21
log
@* fhandler.h (fhandler_serial::fhandler_serial): Change to only accept unit
argument.
* fhandler_serial.cc (fhandler_serial::fhandler_serial): Ditto.
(fhandler_serial::open): Avoid else when previous clause is a return().
* path.cc (get_devn): Alias /dev/ttyS0 -> /dev/com1, etc.
(get_device_number): Reallow standalone "com1" as a valid name for /dev/com1.
@
text
@a62 1
      DWORD ev;
a375 1
	DWORD ev;
@


1.20
log
@Remove 'cb' parameter and modify fhandler_* constructors throughout.
* dtable.cc (dtable::build_fhandler): Remove debugging output which uses 'cb'.
* exec.cc (execvp): New function.
(execvpe): Ditto.
* fhandler.cc (fhandler_base::fhandler_base): Use constructor initialization.
* fhandler.h (fhandler_tty_common::fhandler_tty_common): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fhandler_dev_clipboard):
Ditto.
* fhandler_console.cc (fhandler_console::fhandler_console): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::fhandler_dev_raw): Ditto.
* fhandler_serial.cc (fhandler_serial::fhandler_serial): Ditto.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Ditto.
(fhandler_tty_slave::fhandler_tty_slave): Ditto.
(fhandler_pty_master::fhandler_pty_master): Ditto.
* fhandler_windows.cc (fhandler_windows::fhandler_windows): Ditto.
@
text
@d27 2
a28 2
fhandler_serial::fhandler_serial (DWORD devtype, int unit)
  : fhandler_base (devtype, unit), vmin_ (0), vtime_ (0), pgrp_ (myself->pgid)
d222 2
a223 2
  else
    res = 1;
@


1.19
log
@* fhandler_dsp.cc (fhandler_dsp::ioctl): Return 0 for successful
SNDCTL_DSP_GETBLKSIZE operation.  Remove obsolete 'name' arg from fhandler_*
constructors throughout.
* winsup.h (winsock_active): New macro.
(winsock2_active): Ditto.
* autoload.cc (wsock_init): Use new macros to decide if winsock or winsock2 is
loaded.
(nonexist_wsock32): Dummy function to force winsock load.
(nonexist_ws2_32): Dummy function to force winsock2 load.
* fhandler.h (fhandler_socket::fstat): Declare new method.  Currently unused.
* fhandler_socket.cc (fhandler_socket::fixup_before_fork_exec): Check that
winsock2 is active before trying WSADuplicateSocketA.
(fhandler_socket::fixup_after_fork): Add extra check for winsock2_active.
Otherwise use iffy procedures for Windows 95.
(fhandler_socket::fixup_after_exec): Add debugging.
(fhandler_socket::dup): Add debugging.
(fhandler_socket::fstat): New method.
(fhandler_socket::set_close_on_exec): Attempt to perform iffy stuff on Windows
95.
* errno.cc (_sys_nerr): Work around compiler strangeness.
* pinfo.cc (winpids::add): Add extra element at end of allocated array for
setting to NULL.
(winpids::enumNT): Ditto.
(winpids::init): Don't modify pidlist if it hasn't been allocated
(possibly due to malloc problem).
@
text
@d27 2
a28 2
fhandler_serial::fhandler_serial (DWORD devtype, int unit) :
	fhandler_base (devtype, unit)
a29 4
  set_cb (sizeof *this);
  vmin_ = 0;
  vtime_ = 0;
  pgrp_ = myself->pgid;
@


1.18
log
@* dcrt0.cc (dll_crt0_1): Don't close hexec_proc if it is NULL.
* fork.cc (vfork): Add debugging statements.
* path.cc (get_device_number): Make static.  Rewrite to inspect both unix and
windows paths.
(get_raw_device_number): Just check for parts of raw device that we care about.
(get_devn): New function, pulled from get_device_number.
(win32_device_name): Accomodate arg changes to get_device_number.
(mount_info::get_device_number): Call get_device_number on translated Windows
path.
* spawn.cc (spawn_guts): Don't treat P_VFORK differently from P_NOWAIT.  Add
handle to child's shared region to child so that it will be preserved if the
parent goes away.
* fhandler.h: Throughout, simplify to one open method for all fhandler classes,
requiring a path_conv first element.
* fhandler.cc (fhandler_base::open): Remove obsolete method.  Generalize to
require path_conv * as first argument.
(fhandler_disk_file::open): Remove obsolete method.
(fhandler_disk_file::open): Use path_conv pointer rather than reference.
* fhandler_clipboard.cc (fhandler_dev_clipboard::dup): Use new open method.
(fhandler_dev_clipboard::open): Accomodate new argument for open methods.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::dup): Use new open method.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Accomodate new argument for open
methods.
* fhandler_floppy.cc (fhandler_dev_floppy::open): Ditto.
* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
* fhandler_random (fhandler_dev_random::open): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Ditto.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* fhandler_tape.cc (fhandler_dev_tape::open): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Accomodate new
argument for open methods.
* syscalls.cc (_open): Ditto.
(stat_worker): Ditto.
@
text
@d27 2
a28 2
fhandler_serial::fhandler_serial (const char *name, DWORD devtype, int unit) :
	fhandler_base (devtype, name, unit)
@


1.17
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d215 1
a215 1
fhandler_serial::open (const char *name, int flags, mode_t mode)
d224 1
a224 1
  if (name && !(res = this->fhandler_base::open (flags, mode)))
@


1.17.4.1
log
@Merged changes from HEAD
@
text
@d27 2
a28 2
fhandler_serial::fhandler_serial (int unit)
  : fhandler_base (FH_SERIAL, unit), vmin_ (0), vtime_ (0), pgrp_ (myself->pgid)
d30 4
d67 1
d215 1
a215 1
fhandler_serial::open (path_conv *, int flags, mode_t mode)
d224 1
a224 1
  if (!(res = this->fhandler_base::open (NULL, flags, mode)))
d226 2
a227 2

  res = 1;
d381 1
@


1.17.4.2
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d12 1
d19 1
d205 2
a206 1
  (void) open (NULL, flags, bin & (O_BINARY | O_TEXT));
@


1.17.4.3
log
@Merged changes from HEAD
@
text
@d121 1
a121 1
      if (ReadFile (get_handle (), ptr, min (inq, ulen), &n, &io_status))
d165 1
a165 1
      if (WriteFile (get_handle (), ptr, len, &bytes_written, &write_status))
d184 1
a184 1
  ForceCloseHandle (write_status.hEvent);
d190 1
a190 1
  ForceCloseHandle (write_status.hEvent);
a270 17
  /* setting rts and dtr to known state so that ioctl() function with
  request TIOCMGET could return correct value of RTS and DTR lines.
  Important only for Win 9x systems */

  if (!wincap.is_winnt ())
    {
      if (EscapeCommFunction (get_handle (), SETDTR) == 0)
	system_printf ("couldn't set initial state of DTR for %s, %E", get_name ());
      if (EscapeCommFunction (get_handle (), SETRTS) == 0)
	system_printf ("couldn't set initial state of RTS for %s, %E", get_name ());

      /* even though one of above functions fail I have to set rts and dtr
      variables to initial value. */
      rts = TIOCM_RTS;
      dtr = TIOCM_DTR;
    }

a360 93

/* ioctl: */
int
fhandler_serial::ioctl (unsigned int cmd, void *buffer)
{

  DWORD ev;
  COMSTAT st;
  DWORD action;
  DWORD modemLines;
  DWORD mcr;
  DWORD cbReturned;
  bool result;
  int modemStatus;
  int request;

  request = *(int *) buffer;
  action = 0;
  modemStatus = 0;
  if (!ClearCommError (get_handle (), &ev, &st))
    return -1;
  switch (cmd)
    {
    case TIOCMGET:
      if (GetCommModemStatus (get_handle (), &modemLines) == 0)
	return -1;
      if (modemLines & MS_CTS_ON)
	modemStatus |= TIOCM_CTS;
      if (modemLines & MS_DSR_ON)
	modemStatus |= TIOCM_DSR;
      if (modemLines & MS_RING_ON)
	modemStatus |= TIOCM_RI;
      if (modemLines & MS_RLSD_ON)
	modemStatus |= TIOCM_CD;
      if (!wincap.is_winnt ())
	modemStatus |= rts | dtr;
      else
	{
	  result = DeviceIoControl (get_handle (),
				    0x001B0078,
				    NULL, 0, &mcr, 4, &cbReturned, 0);
	  if (!result)
	    return -1;
	  if (cbReturned != 4)
	    return -1;
	  if (mcr & 2)
	    modemStatus |= TIOCM_RTS;
	  if (mcr & 1)
	    modemStatus |= TIOCM_DTR;
	}
      *(int *) buffer = modemStatus;
      return 0;
    case TIOCMSET:
      if (request & TIOCM_RTS)
	{
	  if (EscapeCommFunction (get_handle (), SETRTS) == 0)
	    return -1;
	  else
	    rts = TIOCM_RTS;
	}
      else
	{
	  if (EscapeCommFunction (get_handle (), CLRRTS) == 0)
	    return -1;
	  else
	    rts = 0;
	}
      if (request & TIOCM_DTR)
	{
	  if (EscapeCommFunction (get_handle (), SETDTR) == 0)
	    return -1;
	  else
	    dtr = TIOCM_DTR;
	}
      else
	{
	  if (EscapeCommFunction (get_handle (), CLRDTR) == 0)
	    return -1;
	  else
	    dtr = 0;
	}
      return 0;
   case TIOCINQ:
     if (ev & CE_FRAME | ev & CE_IOE | ev & CE_OVERRUN |
	 ev & CE_RXOVER | ev & CE_RXPARITY)
       return -1;
     *(int *) buffer = st.cbInQue;
     return 0;
   default:
     return -1;
   }
}

d368 1
a368 1
  if (queue == TCIFLUSH || queue == TCIOFLUSH)
a397 2
  int tmpDtr, tmpRts;
  tmpDtr = tmpRts = 0;
a562 1
      tmpRts = TIOCM_RTS;
d595 1
a595 4
    {
      EscapeCommFunction (get_handle (), CLRDTR);
      tmpDtr = 0;
    }
a603 1
      tmpDtr = TIOCM_DTR;
a604 3

  rts = tmpRts;
  dtr = tmpDtr;
@


1.17.4.4
log
@Merged changes from HEAD
@
text
@d275 1
a275 1
  if (!wincap.supports_reading_modem_output_lines ())
d412 1
a412 1
      if (!wincap.supports_reading_modem_output_lines ())
@


1.16
log
@* mmap.cc: Clean up *ResourceLock calls throughout.
* thread.cc (pthread_cond::TimedWait): Check for WAIT_TIMEOUT as well as
WAIT_ABANDONED.
(__pthread_cond_timedwait): Calculate a relative wait from the abstime
parameter.
@
text
@d17 1
a21 1
#include "security.h"
@


1.15
log
@forced commit
@
text
@d192 1
a192 1
 
@


1.14
log
@Remove trailing underscore from fhandler_base and friends, throughout.
* fhandler.h (fhandler_base::set_open_status): New method.  Stores original
open status.
(fhandler_base::get_open_status): New method.  Retrieves original open status.
(fhandler_base::reset_to_open_binmode): New method.
* fhandler.cc (fhandler_base::open): Save open status.
(fhandler_base::init): Ditto.
* fhandler_clipboard.cc (fhandler_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
* fhandler_dsp.cc (fhandler_dsp::open): Ditto.
* fhandler_dev_mem.cc (fhandler_dev_mem::open): Ditto.
* fhandler_dev_random.cc (fhandler_dev_random::open): Ditto.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* fhandler_tty_slave.cc (fhandler_tty_slave::open): Ditto.
* fhandler_tty_master.cc (fhandler_tty_master::open): Ditto.
* fhandler_dev_zero.cc (fhandler_dev_zero::open): Ditto.
* syscalls.cc (setmode): Rework so that 0 mode value causes reversion to open
state.
* fhandler_tty_slave.cc (fhandler_tty_slave::read): Use correct multiplier when
converting from deciseconds to milliseconds.
@
text
@@


1.13
log
@* fhandler_serial.cc (fhandler_serial::raw_write): Close protected handles with
ForceCloseHandle or suffer spurious warnings.
@
text
@d280 1
@


1.12
log
@Update copyrights.
@
text
@d191 1
a191 1
  CloseHandle(write_status.hEvent);
d197 1
a197 1
  CloseHandle(write_status.hEvent);
@


1.11
log
@* fhandler_serial.cc (raw_write): Use local copy of OVERLAPPED structure
instead of shared structure to fix a race condition between read/write.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Cygnus Solutions.
@


1.10
log
@* fhandler_serial.cc (fhandler_serial::raw_read): Always find number of bytes
ready to be read whether overlapped_armed or not.
@
text
@d164 1
d166 3
a168 3
  if (overlapped_armed)
    PurgeComm (get_handle (), PURGE_TXABORT | PURGE_RXABORT);
  ResetEvent (io_status.hEvent);
d172 1
a172 2
      overlapped_armed = TRUE;
      if (WriteFile (get_handle(), ptr, len, &bytes_written, &io_status))
d185 1
a185 1
      if (!GetOverlappedResult (get_handle (), &io_status, &bytes_written, TRUE))
d191 2
a192 1
  overlapped_armed = FALSE;
d197 1
@


1.9
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@d82 8
a89 1
      if (!overlapped_armed)
d91 1
a91 7
	  if (!ClearCommError (get_handle (), &ev, &st))
	    goto err;
	  else if (ev)
	    termios_printf ("error detected %x", ev);
	  else if (st.cbInQue)
	    inq = st.cbInQue;
	  else if ((size_t)tot >= minchars)
@


1.8
log
@Split out tty and shared_info stuff into their own headers and use throughout.
Include sys/termios.h for files which need it.
* tty.h: New file.
* shared_info.h: New file.
* fhandler.h: Move inline methods that rely on tty stuff to
fhandler_console.cc.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Set
output_done_event immediately after reading data to speed up tty output
processing.
(process_output): Set write_error to errno or zero.
(fhandler_tty_slave::write): Check previous write error prior to writing to
slave end of pipe.  This allows tty output to be slightly less synchronous.
* fhandler_console.cc (fhandler_console::tcsetpgrp): Moved here from
fhandler.h.
(fhandler_console::set_input_state): Ditto.
@
text
@d21 1
@


1.7
log
@* Makefile.in: Add cygheap.o.
* child_info.h: Add specific exec class.
* cygheap.h: New file.  Contains declarations for cygwin heap.
* cygheap.cc: New file.  Implements cygwin heap functions.
* dcrt0.cc (quoted): Simplify due to new method for passing arguments between
cygwin programs.
(alloc_stack_hard_way): Attempt to handle overlapped stack.
(dll_crt0_1): Move child_info processing here.  Accomodate new method for
passing arguments between cygwin programs.  Initialize cygwin heap.  Establish
__argc and __argv variables.
(_dll_crt0): Move most of child_info processing to dll_crt0_1.
(cygwin_dll_init): Remove duplication.
* dtable.cc (dtable::extend): Allocate dtable using cygwin heap.
(dtable::build_fhandler): Ditto for fhandler type being constructed.
(dtable::dup_worker): Free new fhandler from cygwin heap on error.
(dtable::select_*): Don't assume that this == fdtab.
(dtable::linearize_fd_array): Delete.
(dtable::delinearize_fd_array): Delete.
(dtable::fixup_after_exec): New file.
(dtable::vfork_child_dup): Use cygwin heap.
(dtable::vfork_parent_restore): Ditto.
* dtable.h: Remove obsolete methods.  Add new method.
* environ.cc (posify): Eliminate already_posix parameter and logic.
(envsize): New function.
(_addenv): Use envsize.
(environ_init): Accept an argument pointing to an existing environment list.
If supplied, allocate space for this in the the program's heap.
* fhandler.cc (fhandler_base::operator =): Move here from fhandler.h.  Use
cygwin heap to allocate filenames.
(fhandler_base::set_name): Allocate/free names from cygwin heap.
(fhandler_base::linearize): Delete.
(fhandler_base::de_linearize): Delete.
(fhandler_base::operator delete): Free from cygwin heap.
(fhandler_base::~fhandler_base): Ditto.
* fhandler.h: Accomodate elimination of *linearize and other changes above.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Rename from
de_linearize.
* heap.h: New file.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Use cygwin heap for
name.  fhandler_tty::fixup_after_exec): Rename from de_linearize.
* fork.cc (fork): Call cygheap_fixup_in_child.
* heap.cc: Use declarations in heap.h.
* malloc.cc: Sprinkle assertions throughout to catch attempts to free/realloc
something from the cygwin heap.
* path.cc: Throughout, eliminate use of per-thread cache for cwd.  Use cwd_*
functions rather than cwd_* variables to access cwd_win32 and cwd_posix.
(cwd_win32): New function.
(cwd_posix): New function.
(cwd_hash): New function.
(cwd_fixup_after_exec): New function.
* path.h: Accomodate path.cc changes.
* pinfo.cc (pinfo_init): Accept a pointer to an environment table.  Pass this
to environ_init.  Eliminate old 'title' tests.
* pinfo.h: Accomodate above change in argument.
* spawn.cc (struct av): New method for building argv list.
(av::unshift): New method.
(spawn_guts): Allocate everything that the child process needs in the cygwin
heap and pass a pointer to this to the child.  Build argv list using new
method.  Eliminate delinearize stuff.
* thread.h: Eliminate _cwd_win32 and _cwd_posix buffers.
* winsup.h: Eliminate obsolete functions.  Add envsize() declaration.
@
text
@d21 1
@


1.6
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@d506 1
a506 1
  state.EofChar = 0;        /* No end-of-data in binary mode */
d870 2
a871 3
int
fhandler_serial::de_linearize (const char *buf, const char *unix_name,
			       const char *win32_name)
a872 1
  int res = fhandler_base::de_linearize (buf, unix_name, win32_name);
d875 1
a875 1
  return res;
@


1.5
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d16 4
a20 1
#include "cygerrno.h"
@


1.4
log
@* winsup.h: Split out dtable definitions into separate header file.
* dtable.h: New file.
* sigproc.h: Eliminate pinfo.h usage here.  Use it in source files that need
it.
@
text
@d17 1
@


1.3
log
@* fhandler_serial.cc (tcsendbreak): "sleeptime" argument to usleep()
must be in units of microseconds, not milliseconds.
@
text
@d16 1
@


1.2
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d288 1
a288 1
  unsigned int sleeptime = 300;
@


1.1
log
@Initial revision
@
text
@d11 1
a15 1
#include "winsup.h"
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
