head	1.10;
access;
symbols
	cygwin-64bit-postmerge:1.9
	cygwin-64bit-premerge-branch:1.9.0.6
	cygwin-64bit-premerge:1.9
	cygwin-1_7_18-release:1.9
	cygwin-1_7_17-release:1.9
	cygwin-64bit-branch:1.9.0.4
	cygwin-1_7_16-release:1.9
	cygwin-1_7_15-release:1.9
	cygwin-1_7_14_2-release:1.9
	cygwin-1_7_14-release:1.9
	cygwin-1_7_12-release:1.9
	cygwin-1_7_11-release:1.9
	cygwin-1_7_10-release:1.9
	cygwin-1_7_9-release:1.9
	cygwin-1_7_8-release:1.9
	cygwin-1_7_7-release:1.9
	cygwin-1_7_5-release:1.9
	cygwin-1_7_4-release:1.9
	cygwin-1_7_3-release:1.9
	cygwin-1_7_2-release:1.9
	cygwin-1_7_1-release:1.9
	cv-branch-2:1.9.0.2
	cr-0x5f1:1.8.0.6
	cv-branch:1.8.0.4
	cr-0x3b58:1.8.0.2
	cr-0x9e:1.6.0.4
	cr-0x9d:1.6.0.2
	corinna-01:1.5
	cr-0x9c:1.5.0.6
	cr-0x9b:1.5.0.4
	cr-0x99:1.5
	Z-emcb-cygwin_daemon:1.5.0.2
	w32api-2_2:1.5
	mingw-runtime-2_4:1.5
	cygnus_cvs_20020108_pre:1.1.1.1
	Z-cygwin_daemon_merge-new_HEAD:1.1.1.1
	Z-cygwin_daemon_merge_HEAD:1.1.1.1
	cygwin_daemon:1.1.1.1.0.10;
locks; strict;
comment	@# @;
expand	@o@;


1.10
date	2013.05.01.23.30.21;	author tangent;	state dead;
branches;
next	1.9;

1.9
date	2007.08.24.14.52.39;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.24.21.58.38;	author joshuadfranklin;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.24.08.08.13;	author joshuadfranklin;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.11.08.32.09;	author joshuadfranklin;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.03.00.30.45;	author joshuadfranklin;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.23.03.55.34;	author joshuadfranklin;	state Exp;
branches;
next	1.3;

1.3
date	2002.08.21.16.02.17;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2002.08.21.15.45.04;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Modernized user guide, API reference, and FAQ generation.  Overall
effect is to move away from DocBook SGML and DJ Delorie's doctool and
toward pure DocBook XSL.  (There remains just one use of doctool, and
we have plans for replacing it, too.)  See ChangeLog for details.
@
text
@<sect1 id="dll"><title>Building and Using DLLs</title>

<para>DLLs are Dynamic Link Libraries, which means that they're linked
into your program at run time instead of build time.  There are three
parts to a DLL:</para>

<itemizedlist spacing="compact">
<listitem><para> the exports </para></listitem>
<listitem><para> the code and data </para></listitem>
<listitem><para> the import library </para></listitem>
</itemizedlist>

<para>The code and data are the parts you write - functions,
variables, etc.  All these are merged together, like if you were
building one big object files, and put into the dll.  They are not
put into your .exe at all.</para>

<para>The exports contains a list of functions and variables that the
dll makes available to other programs.  Think of this as the list of
"global" symbols, the rest being hidden.  Normally, you'd create this
list by hand with a text editor, but it's possible to do it
automatically from the list of functions in your code.  The
<filename>dlltool</filename> program creates the exports section of
the dll from your text file of exported symbols.</para>

<para>The import library is a regular UNIX-like
<filename>.a</filename> library, but it only contains the tiny bit of
information needed to tell the OS how your program interacts with
("imports") the dll.  This information is linked into your
<filename>.exe</filename>.  This is also generated by
<filename>dlltool</filename>.</para>

<sect2 id="dll-build"><title>Building DLLs</title>

<para>This page gives only a few simple examples of gcc's DLL-building 
capabilities. To begin an exploration of the many additional options,
see the gcc documentation and website, currently at 
<ulink url="http://gcc.gnu.org/">http://gcc.gnu.org/</ulink>
</para>

<para>Let's go through a simple example of how to build a dll.
For this example, we'll use a single file
<filename>myprog.c</filename> for the program
(<filename>myprog.exe</filename>) and a single file
<filename>mydll.c</filename> for the contents of the dll
(<filename>mydll.dll</filename>).</para>

<para>Fortunately, with the latest gcc and binutils the process for building a dll
is now pretty simple. Say you want to build this minimal function in mydll.c:</para>

<screen>
#include &lt;stdio.h&gt;

int
hello()
{
  printf ("Hello World!\n");
}  
</screen>

<para>First compile mydll.c to object code:</para>

<screen>gcc -c mydll.c</screen>

<para>Then, tell gcc that it is building a shared library:</para>

<screen>gcc -shared -o mydll.dll mydll.o</screen>

<para>
That's it! To finish up the example, you can now link to the
dll with a simple program:
</para>

<screen>
int 
main ()
{
  hello ();
}  
</screen>

<para>
Then link to your dll with a command like:
</para>

<screen>gcc -o myprog myprog.c -L./ -lmydll</screen>

<para>However, if you are building a dll as an export library,
you will probably want to use the complete syntax:</para>

<screen>gcc -shared -o cyg${module}.dll \
    -Wl,--out-implib=lib${module}.dll.a \
    -Wl,--export-all-symbols \
    -Wl,--enable-auto-import \
    -Wl,--whole-archive ${old_libs} \
    -Wl,--no-whole-archive ${dependency_libs}</screen>

<para>
The name of your library is <literal>${module}</literal>, prefixed with
<literal>cyg</literal> for the DLL and <literal>lib</literal> for the
import library. Cygwin DLLs use the <literal>cyg</literal> prefix to 
differentiate them from native-Windows MinGW DLLs, see 
<ulink url="http://mingw.org">the MinGW website</ulink> for more details.
<literal>${old_libs}</literal> are all
your object files, bundled together in static libs or single object
files and the <literal>${dependency_libs}</literal> are import libs you 
need to link against, e.g 
<userinput>'-lpng -lz -L/usr/local/special -lmyspeciallib'</userinput>.
</para>
</sect2>

<sect2 id="dll-link"><title>Linking Against DLLs</title>

<para>If you have an existing DLL already, you need to build a
Cygwin-compatible import library.  If you have the source to compile
the DLL, see <xref linkend="dll-build"></xref> for details on having 
<filename>gcc</filename> build one for you.  If you do not have the
source or a supplied working import library, you can get most of
the way by creating a .def file with these commands (you might need to
do this in <filename>bash</filename> for the quoting to work
correctly):</para>

<screen>
echo EXPORTS > foo.def
nm foo.dll | grep ' T _' | sed 's/.* T _//' >> foo.def
</screen>

<para>Note that this will only work if the DLL is not stripped.
Otherwise you will get an error message: "No symbols in
foo.dll".</para>

<para>Once you have the <filename>.def</filename> file, you can create
an import library from it like this:</para>

<screen>
dlltool --def foo.def --dllname foo.dll --output-lib foo.a
</screen>

</sect2>

</sect1>
@


1.9
log
@* dll.sgml: myprog.ca -> myprog.c
@
text
@@


1.8
log
@	* .sgml: Cleanup markup for XML validity.
@
text
@d86 1
a86 1
<screen>gcc -o myprog myprog.ca -L./ -lmydll</screen>
@


1.7
log
@
2004-01-24  Joshua Daniel Franklin  <joshuadfranklin@@yahoo.com>
	* cygwinenv.sgml: Cleanup minor markup problems.
	* dll.sgml: Cleanup minor markup problems.
	* effectively.sgml: Cleanup minor markup problems.
	* gcc.sgml: Cleanup minor markup problems.
	* ntsec.sgml: Cleanup minor markup problems.
	* pathnames.sgml: Cleanup minor markup problems.
	* setup-net.sgml: Cleanup minor markup problems.
	* textbinary.sgml: Cleanup minor markup problems.
	* windres.sgml: Cleanup minor markup problems.
@
text
@d38 1
a38 1
<ulink URL="http://gcc.gnu.org/">http://gcc.gnu.org/</ulink>
d103 1
a103 1
<ulink URL="http://mingw.org">the MinGW website</ulink> for more details.
d116 1
a116 1
the DLL, see <Xref Linkend="dll-build"> for details on having 
@


1.6
log
@2004-01-11  Joshua Daniel Franklin <joshuadfranklin@@yahoo.com>

        * Makefile.in: Add new target for single-file User's Guide, use new
        cygwin.dsl for output.
        * cygwin.dsl: New file, DSSSL stylesheet for custom Cygwin output.
        * cygwin-api.in.sgml: Update to DocBook SGML 4.2 DTD.
        * cygwin-ug-net.in.sgml: Update to DocBook SGML 4.2 DTD.
        * cygwin-ug.in.sgml: Update to DocBook SGML 4.2 DTD.
        * cygwinenv.sgml: Correct some tags. Add description of default values
        to ntsec, export, and error_start items.
        * dll.sgml: Add explanation of cyg prefix for DLLs.
        * effectively.sgml: Use systemitem tag for names of Cygwin packages.
        * how-programming.texinfo: Add example to FAQ entry.
        * pathnames.sgml: Add discussion of /proc filesystem.
	* setup-net.sgml: Correct some typos and grammar.
@
text
@d39 1
@


1.5
log
@* cygwinenv.sgml: Add section for 'CYGWIN codepage:[ansi|oem]'
@
text
@d94 1
a94 1
    -Wl,--whole-archive ${old_lib} \
d97 7
a103 1
<para>Where ${module} is the name of your DLL, ${old_lib} are all
d105 4
a108 2
files and the ${dependency_libs} are import libs you need to
link against, e.g '-lpng -lz -L/usr/local/special -lmyspeciallib'.</para>
@


1.4
log
@* dll.sgml: Simplify dll build instructions.
@
text
@d35 6
a40 1
<para>OK, let's go through a simple example of how to build a dll.
@


1.3
log
@* dll.sgml: Remove indirect reference to older gccs.
@
text
@a41 5
<para>Now compile everything to objects:</para>

<screen>gcc -c myprog.c
gcc -c mydll.c</screen>

d45 5
a49 2
<screen>int WINAPI
mydll_init(HANDLE h, DWORD reason, void *foo)
d51 3
a53 2
  return 1;
}</screen>
d63 20
a82 1
<para>That's it! However, if you are building a dll as an export library,
d101 4
a104 3
Cygwin-compatible import library (The supplied ones should work, but
you might not have them) to link against.  Unfortunately, there is not
yet any tool to do this automatically.  However, you can get most of
@


1.2
log
@* dll.sgml: Refine dll build instructions.
* ntsec.html: Correct some typos.
@
text
@d48 1
a48 1
is now much simpler. Say you want to build this minimal function in mydll.c:</para>
@


1.1
log
@Initial revision
@
text
@d44 2
a45 35
<screen>
gcc -c myprog.c
gcc -c mydll.c
</screen>

<para>Unfortunately, the process for building a dll is, well, convoluted.
You have to run five commands, like this:</para>

<screen>
gcc -s -Wl,--base-file,mydll.base -o mydll.dll mydll.o -Wl,-e,_mydll_init@@12 
dlltool --base-file mydll.base --def mydll.def --output-exp mydll.exp --dllname mydll.dll
gcc -s -Wl,--base-file,mydll.base,mydll.exp -o mydll.dll mydll.o -Wl,-e,_mydll_init@@12
dlltool --base-file mydll.base --def mydll.def --output-exp mydll.exp --dllname mydll.dll
gcc -Wl,mydll.exp -o mydll.dll mydll.o -Wl,-e,_mydll_init@@12
</screen>

<para>The extra steps give <filename>dlltool</filename> the
opportunity to generate the extra sections (exports and relocation)
that a dll needs.  After this, you build the import library:</para>

<screen>
dlltool --def mydll.def --dllname mydll.dll --output-lib mydll.a
</screen>

<para>Now, when you build your program, you link against the import
library:</para>

<screen>
gcc -o myprog myprog.o mydll.a
</screen>

<para>Note that we linked with <command>-e _mydll_init@@12</command>.
This tells the OS what the DLL's "entry point" is, and this is a
special function that coordinates bringing the dll to life withing the
OS.  The minimum function looks like this:</para>
d47 2
a48 2
<screen>
#include &lt;windows.h&gt;
d50 1
a50 1
int WINAPI
d54 1
a54 2
}  
</screen>
d56 22
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
