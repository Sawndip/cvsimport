head	1.29;
access;
symbols
	cygwin-64bit-postmerge:1.27
	cygwin-64bit-premerge-branch:1.27.0.4
	cygwin-64bit-premerge:1.27
	cygwin-1_7_18-release:1.27
	cygwin-1_7_17-release:1.27
	cygwin-64bit-branch:1.27.0.2
	cygwin-1_7_16-release:1.27
	cygwin-1_7_15-release:1.27
	cygwin-1_7_14_2-release:1.27
	cygwin-1_7_14-release:1.27
	cygwin-1_7_12-release:1.27
	cygwin-1_7_11-release:1.27
	cygwin-1_7_10-release:1.27
	cygwin-1_7_9-release:1.25
	cygwin-1_7_8-release:1.25
	cygwin-1_7_7-release:1.24
	cygwin-1_7_5-release:1.24
	cygwin-1_7_4-release:1.24
	cygwin-1_7_3-release:1.24
	cygwin-1_7_2-release:1.24
	cygwin-1_7_1-release:1.24
	cv-branch-2:1.24.0.2
	cr-0x5f1:1.15.0.6
	cv-branch:1.15.0.4
	cr-0x3b58:1.15.0.2
	cr-0x9e:1.11.0.10
	cr-0x9d:1.11.0.8
	corinna-01:1.11
	cr-0x9c:1.11.0.6
	cr-0x9b:1.11.0.4
	cr-0x99:1.11
	Z-emcb-cygwin_daemon:1.11.0.2
	w32api-2_2:1.10
	mingw-runtime-2_4:1.10
	cygnus_cvs_20020108_pre:1.5
	Z-cygwin_daemon_merge-new_HEAD:1.5
	Z-cygwin_daemon_merge_HEAD:1.5
	cygwin_daemon:1.5.0.8;
locks; strict;
comment	@# @;
expand	@o@;


1.29
date	2013.05.01.23.30.22;	author tangent;	state dead;
branches;
next	1.28;

1.28
date	2013.04.23.15.59.21;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2012.02.04.11.40.44;	author corinna;	state Exp;
branches;
next	1.26;

1.26
date	2011.05.02.11.56.36;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2010.09.27.16.37.57;	author corinna;	state Exp;
branches;
next	1.24;

1.24
date	2009.05.27.02.30.42;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2009.04.03.11.51.31;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2009.01.21.17.14.37;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2008.12.04.10.07.54;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2008.12.03.11.47.27;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2008.12.02.19.29.37;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2008.12.02.17.07.40;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2008.12.01.18.34.44;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2008.07.17.11.49.45;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2005.01.29.22.35.17;	author joshuadfranklin;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.24.21.58.38;	author joshuadfranklin;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.30.19.20.42;	author joshuadfranklin;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.24.08.08.13;	author joshuadfranklin;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.04.01.58.24;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.07.20.59.19;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2002.10.23.04.29.46;	author joshuadfranklin;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.11.08.39.04;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2002.08.21.15.45.04;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.24.09.30.02;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.26.08.01.39;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.26.07.37.26;	author corinna;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.20.11.04.33;	author corinna;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.02.22.26.41;	author corinna;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Modernized user guide, API reference, and FAQ generation.  Overall
effect is to move away from DocBook SGML and DJ Delorie's doctool and
toward pure DocBook XSL.  (There remains just one use of doctool, and
we have plans for replacing it, too.)  See ChangeLog for details.
@
text
@<sect1 id="ntsec"><title>Using Windows security in Cygwin</title>

<para>This section discusses how the Windows security model is
utilized in Cygwin to implement POSIX-like permissions, as well as how
the Windows authentication model is used to allow cygwin applications
to switch users in a POSIX-like fashion.</para>

<para>The setting of POSIX-like file and directory permissions is
controlled by the <link linkend="mount-table">mount</link> option
<literal>(no)acl</literal> which is set to <literal>acl</literal> by
default.</para>

<para>We start with a short overview.  Note that this overview must
be necessarily short.  If you want to learn more about the Windows security
model, see the <ulink url="http://msdn.microsoft.com/en-us/library/aa374860(VS.85).aspx">Access Control</ulink> article in MSDN documentation.</para>

<para>POSIX concepts and in particular the POSIX security model are not
discussed here, but assumed to be understood by the reader.  If you
don't know the POSIX security model, search the web for beginner
documentation.</para>

<sect2 id="ntsec-common"><title>Overview</title>

<para>In the Windows security model, almost any "object" is securable.
"Objects" are files, processes, threads, semaphores, etc.</para>

<para>Every object has a data structure attached, called a "security
descriptor" (SD).  The SD contains all information necessary to control
who can access an object, and to determine what they are allowed to do
to or with it.  The SD of an object consists of five parts:</para>

<itemizedlist spacing="compact">
<listitem><para>Flags which control several aspects of this SD. This is
not discussed here.</para></listitem>
<listitem><para>The SID of the object owner.</para></listitem>
<listitem><para>The SID of the object owner group.</para></listitem>
<listitem><para>A list of "Access Control Entries" (ACE), called the
"Discretionary Access Control List" (DACL).</para></listitem>
<listitem><para>Another list of ACEs, called the "Security Access Control List"
(SACL), which doesn't matter for our purpose.  We ignore it here.</para></listitem>
</itemizedlist>

<para>Every ACE contains a so-called "Security IDentifier" (SID) and
other stuff which is explained a bit later.  Let's talk about the SID first.
</para>

<para>A SID is a unique identifier for users, groups, computers and
Active Directory (AD) domains.  SIDs are basically comparable to POSIX
user ids (UIDs) and group ids (GIDs), but are more complicated because
they are unique across multiple machines or domains.  A SID is a
structure of multiple numerical values.  There's a convenient convention
to type SIDs, as a string of numerical fields separated by hyphen
characters.  Here's an example:</para>

<para>SID of a machine "foo":</para>

<screen>
  S-1-5-21-165875785-1005667432-441284377
</screen>

<para>SID of a user "johndoe" of the system "foo":</para>

<screen>
  S-1-5-21-165875785-1005667432-441284377-1023
</screen>

<para>The first field is always "S", which is just a notational convention
to show that this is a SID.  The second field is the version number of
the SID structure, So far there exists only one version of SIDs, so this
field is always 1.  The third and fourth fields represent the "authority"
which can be thought of as a type or category of SIDs.  There are a
couple of builtin accounts and accounts with very special meaning which
have certain well known values in these third and fourth fields.
However, computer and domain SIDs always start with "S-1-5-21".  The
next three fields, all 32 bit values, represent the unique 96 bit
identifier of the computer system.  This is a hopefully unique value all
over the world, but in practice it's sufficient if the computer SIDs are
unique within a single Windows network.</para>

<para>As you can see in the above example, SIDs of users (and groups)
are identical to the computer SID, except for an additional part, the
so-called "relative identifier" (RID).  So the SID of a user is always 
uniquely attached to the system on which the account has been generated.</para>

<para>It's a bit different in domains.  The domain has its own SID, and
that SID is identical to the SID of the first domain controller, on
which the domain is created.  Domain user SIDs look exactly like the
computer user SIDs, the leading part is just the domain SID and the RID
is created when the user is created.</para>

<para>Ok, consider you created a new domain "bar" on some new domain
controller and you would like to create a domain account "johndoe":</para>

<para>SID of a domain "bar.local":</para>

<screen>
  S-1-5-21-186985262-1144665072-740312968
</screen>

<para>SID of a user "johndoe" in the domain "bar.local":</para>

<screen>
  S-1-5-21-186985262-1144665072-740312968-1207
</screen>

<para>So you now have two accounts called johndoe, one account
created on the machine "foo", one created in the domain "bar.local".
Both have different SIDs and not even the RID is the same.  How do
the systems know it's the same account?  After all, the name is
the same, right?  The answer is, these accounts are <emphasis
role='bold'>not</emphasis> identical.  All machines on the network will
treat these SIDs as identifying two separate accounts.  One is
"FOO\johndoe", the other one is "BAR\johndoe" or "johndoe@@bar.local".
Different SID, different account.  Full stop.  </para>

<para>The last part of the SID, the so called "Relative IDentifier" (RID),
is by default used as UID and/or GID under Cygwin when you create the
<filename>/etc/passwd</filename> and <filename>/etc/group</filename>
files using the <command><link linkend="mkpasswd">mkpasswd</link></command> and <command><link linkend="mkgroup">mkgroup</link></command>
tools.  Domain account UIDs and GIDs are offset by 10000 by default
which might be a bit low for very big organizations.  Fortunately there's
an option in both tools to change the offset...</para>

<para>Do you still remember the SIDs with special meaning?  In offical
notation they are called "well-known SIDs".  For example, POSIX has no GID
for the group of "all users" or "world" or "others".  The last three rwx
bits in a unix-style permission value just represent the permissions for
"everyone who is not the owner or is member of the owning group".
Windows has a SID for these poor souls, the "Everyone" SID.  Other
well-known SIDs represent circumstances under which a process is
running, rather than actual users or groups.  Here are a few examples
for well-known SIDs:</para>

<screen>
Everyone                        S-1-1-0    Simply everyone...
Batch                           S-1-5-3    Processes started via the task
					   scheduler are member of this group.
Interactive			S-1-5-4    Only processes of users which are
					   logged in via an interactive
					   session are members here.
Authenticated Users             S-1-5-11   Users which have gone through
                                           the authentication process and
					   survived.  Anonymously accessing
					   users are not incuded here.
SYSTEM                          S-1-5-18   A special account which has all
					   kinds of dangerous rights, sort of
					   an uber-root account.
</screen>

<para>For a full list please refer to the MSDN document <ulink
url="http://msdn.microsoft.com/en-us/library/aa379649.aspx">Well-known
SIDs</ulink>.  The Cygwin package called "csih" provides a tool,
/usr/lib/csih/getAccountName.exe, which can be used to print the
(possibly localized) name for the various well-known SIDS.</para>

<para>Naturally, well-known SIDs are the same on each machine, so they are
not unique to a machine or domain.  They have the same meaning across
the Windows network.</para>

<para>Additionally, there are a couple of well-known builtin groups,
which have the same SID on every machine and which have certain user
rights by default:</para>

<screen>
administrators                  S-1-5-32-544
users                           S-1-5-32-545
guests                          S-1-5-32-546
...
</screen>

<para>For instance, every account is usually member in the "Users"
group.  All administrator accounts are member of the "Administrators"
group.  That's all about it as far as single machines are involved.  In
a domain environment it's a bit more tricky.  Since these SIDs are not
unique to a machine, every domain user and every domain group can be a
member of these well known groups.  Consider the domain group "Domain
Admins".  This group is by default in the "Administrators" group.  Let's
assume the above computer called "foo" is a member machine of the domain
"bar.local".  If you stick the user "BAR\johndoe" into the group "Domain
Admins", this guy will automatically be a member of the administrators
group on "foo" when logging on to "foo".  Neat, isn't it?</para>

<para>Back to ACE and ACL.  POSIX is able to create three different
permissions, the permissions for the owner, for the group and for the
world.  In contrast the Windows ACL has a potentially infinite number of
members... as long as they fit into 64K.  Every member is an ACE.
ACE consist of three parts:</para>

<itemizedlist spacing="compact">
<listitem><para>The type of the ACE (allow ACE or deny ACE).</para></listitem>
<listitem><para>Permission bits, 32 of them.</para></listitem>
<listitem><para>The SID for which the permissions are allowed or denied.</para></listitem>
</itemizedlist>

<para>The two (for us) important types of ACEs are the "access allowed
ACE" and the "access denied ACE".  As the names imply, the allow ACE
tells the system to allow the given permissions to the SID, the deny ACE
results in denying the specific permission bits.</para>

<para>The possible permissions on objects are more detailed than in
POSIX.  For example, the permission to delete an object is different
from the permission to change object data, and even changing object data
can be separated into different permission bits for different kind of
data.  But there's a problem with the definition of a "correct" ACL
which disallows mapping of certain POSIX permissions cleanly.  See
<xref linkend="ntsec-mapping"></xref>.</para>

<para>POSIX is able to create only three different permissions?  Not quite.
Newer operating systems and file systems on POSIX systems also provide
access control lists.  Two different APIs exist for accessing these
ACLs, the Solaris API and the POSIX API.  Cygwin implements the Solaris
API to access Windows ACLs in a Unixy way.  At the time of writing this
document, the Cygwin implementation of the Solaris API isn't quite up
to speed.  For instance, it doesn't handle access denied ACEs gracefully.
So, use with care.  Online man pages for the Solaris ACL API can be
found on <ulink url="http://docs.sun.com">http://docs.sun.com</ulink>.</para>

</sect2>

<sect2 id="ntsec-files"><title id="ntsec-files.title">File permissions</title>

<para>On NTFS and if the <literal>noacl</literal> mount option is not
specified for a mount point, Cygwin sets file permissions as in POSIX.
Basically this is done by defining a SD with the matching owner and group
SIDs, and a DACL which contains ACEs for the owner, the group and for
"Everyone", which represents what POSIX calls "others".</para>

<para>To use Windows security correctly, Cygwin depends on the files
<filename>/etc/passwd</filename> and <filename>/etc/group</filename>.
These files define the translation between the Cygwin uid/gid and the
Windows SID.  The SID is stored in the pw_gecos field in
<filename>/etc/passwd</filename>, and in the gr_passwd field in
<filename>/etc/group</filename>. Since the pw_gecos field can contain
more information than just a SID, there are some rules for the layout.
It's required that the SID is the last entry of the pw_gecos field,
assuming that the entries in pw_gecos are comma-separated.  The
commands <command>mkpasswd</command> and <command>mkgroup</command>
usually do this for you.</para>

<para>Another interesting entry in the pw_gecos field (which is also
usually created by running <command>mkpasswd</command>) is the Windows user
name entry.  It takes the form "U-domain\username" and is sometimes used
by services to authenticate a user.  Logging in through
<command>telnet</command> is a common scenario.</para>

<para>A typical snippet from <filename>/etc/passwd</filename>:</para>

<example id="ntsec-passwd">
<title>/etc/passwd:</title>
<screen>
SYSTEM:*:18:544:,S-1-5-18::
Administrators:*:544:544:,S-1-5-32-544::
Administrator:unused:500:513:U-FOO\Administrator,S-1-5-21-790525478-115176313-839522115-500:/home/Administrator:/bin/bash
corinna:unused:11001:11125:U-BAR\corinna,S-1-5-21-2913048732-1697188782-3448811101-1001:/home/corinna:/bin/tcsh
</screen>
</example>

<para>The SYSTEM entry is usually needed by services.  The Administrators
entry (Huh?  A group in /etc/passwd?) is only here to allow
<command>ls</command> and similar commands to print some file ownerships
correctly.  Windows doesn't care if the owner of a file is a user or a
group.  In older versions of Windows NT the default ownership for files
created by an administrator account was set to the group Administrators
instead of to the creating user account.  This has changed, but you can
still switch to this setting on newer systems.  So it's convenient to
have the Administrators group in
<filename>/etc/passwd</filename>.</para>

<para>The really interesting entries are the next two.  The Administrator
entry is for the local administrator, the corinna entry matches the corinna
account in the domain BAR.  The information given in the pw_gecos field
are all we need to exactly identify an account, and to have a two way
translation, from Windows account name/SID to Cygwin account name uid and
vice versa.  Having this complete information allows us to choose a Cygwin
user name and uid which doesn't have to match the Windows account at all.  As
long as the pw_gecos information is available, we're on the safe side:</para>

<example id="ntsec-passwd-tweaked">
<title>/etc/passwd, tweaked:</title>
<screen>
root:unused:0:513:U-FOO\Administrator,S-1-5-21-790525478-115176313-839522115-500:/home/Administrator:/bin/bash
thursday_next:unused:11001:11125:U-BAR\corinna,S-1-5-21-2913048732-1697188782-3448811101-1001:/home/corinna:/bin/tcsh
</screen>
</example>

<para>  The above <filename>/etc/passwd</filename> will still work fine.
You can now login via <command>ssh</command> as the user "root", and
Cygwin dutifully translates "root" into the Windows user
"FOO\Administrator" and files owned by FOO\Administrator are shown to
have the uid 0 when calling <command>ls -ln</command>.  All you do you're
actually doing as Administrator.  Files created as root will be owned by
FOO\Administrator.  And the domain user BAR\corinna can now happily
pretend to be Thursday Next, but will wake up sooner or later finding
out she's still actually the domain user BAR\corinna...</para>

<para>Do I have to mention that you can also rename groups in
<filename>/etc/group</filename>?  As long as the SID is present and correct,
all is well.  This allows you to, for instance, rename the "Administrators"
group to "root" as well:</para>

<example id="ntsec-group-tweaked">
<title>/etc/group, tweaked:</title>
<screen>
root:S-1-5-32-544:544:
</screen>
</example>

<para>Last but not least, you can also change the primary group of a user
in <filename>/etc/passwd</filename>.  The only requirement is that the user
is actually a member of the new primary group in Windows.  For instance,
normal users in a domain environment are members in the group "Domain Users",
which in turn belongs to the well-known group "Users".  So, if it's
more convenient in your environment for the user's primary group to be
"Users", just set the user's primary group in <filename>/etc/passwd</filename>
to the Cygwin uid of "Users" (see in <filename>/etc/group</filename>,
default 545) and let the user create files with a default group ownership
of "Users".</para>

<note><para>
If you wish to make these kind of changes to /etc/passwd and /etc/group,
do so only if you feel comfortable with the concepts.  Otherwise, do not
be surprised if things break in either subtle or surprising ways!  If you
do screw things up, revert to copies of <filename>/etc/passwd</filename>
and <filename>/etc/group</filename> files created by
<command>mkpasswd</command> and <command>mkgroup</command>.  (Make
backup copies of these files before modifying them.)  Especially, don't
change the UID or the name of the user SYSTEM.  It may mostly work, but
some Cygwin applications running as a local service under that account
could suddenly start behaving strangely.
</para></note>

</sect2>

<sect2 id="ntsec-ids"><title id="ntsec-ids.title">Special values of user and group ids</title>

<para>If the current user is not present in
<filename>/etc/passwd</filename>, that user's uid is set to a
special value of 400.  The user name for the current user will always be
shown correctly.  If another user (or a Windows group, treated as a
user) is not present in <filename>/etc/passwd</filename>, the uid of
that user will have a special value of -1 (which would be shown by
<command>ls</command> as 65535).  The user name shown in this case will
be '????????'.</para>

<para>If the current user is not present in
<filename>/etc/passwd</filename>, that user's login gid is set to a
special value of 401.  The gid 401 is shown as 'mkpasswd',
indicating the command that should be run to alleviate the
situation.</para>

<para>If another user is not present in
<filename>/etc/passwd</filename>, that user's login gid is set to a
special value of -1.  If the user is present in
<filename>/etc/passwd</filename>, but that user's group is not in
<filename>/etc/group</filename> and is not the login group of that user,
the gid is set to a special value of -1.  The name of this group
(id -1) will be shown as '????????'.</para>

<para>If the current user is present in
<filename>/etc/passwd</filename>, but that user's login group is not
present in <filename>/etc/group</filename>, the group name will be shown
as 'mkgroup', again indicating the appropriate command.</para>

<para>A special case is if the current user's primary group SID is noted
in the user's <filename>/etc/passwd</filename> entry using another group
id than the group entry of the same group SID in
<filename>/etc/group</filename>.  This should be noted and corrected.
The group name printed in this case is
'passwd/group_GID_clash(PPP/GGG)', with PPP being the gid as noted
in <filename>/etc/passwd</filename> and GGG the gid as noted in
<filename>/etc/group</filename>.</para>

<para>To summarize:</para>
<itemizedlist spacing="compact">

<listitem><para>If the current user doesn't show up in
<filename>/etc/passwd</filename>, it's <emphasis>group</emphasis> will
be named 'mkpasswd'.</para></listitem>

<listitem><para>Otherwise, if the login group of the current user isn't
in <filename>/etc/group</filename>, it will be named 'mkgroup'.</para>
</listitem>

<listitem><para>Otherwise a group not in <filename>/etc/group</filename>
will be shown as '????????' and a user not in
<filename>/etc/passwd</filename> will be shown as "????????".</para>
</listitem>

<listitem><para>If different group ids are used for a group with the same
SID, the group name is shown as 'passwd/group_GID_clash(PPP/GGG)' with
PPP and GGG being the different group ids.</para></listitem>

</itemizedlist>

<para>
Note that, since the special user and group names are just indicators,
nothing prevents you from actually having a user named `mkpasswd' in
<filename>/etc/passwd</filename> (or a group named `mkgroup' in
<filename>/etc/group</filename>).  If you do that, however, be aware of
the possible confusion.
</para>

</sect2>


<sect2 id="ntsec-mapping"><title id="ntsec-mapping.title">The POSIX permission mapping leak</title>

<para>As promised earlier, here's the problem when trying to map the
POSIX permission model onto the Windows permission model.</para>

<para>There's a leak in the definition of a "correct" ACL which
disallows a certain POSIX permission setting.  The official
documentation explains in short the following:</para>

<itemizedlist spacing="compact">
<listitem><para>The requested permissions are checked against all
ACEs of the user as well as all groups the user is member of.  The
permissions given in these user and groups access allowed ACEs are
accumulated and the resulting set is the set of permissions of that
user given for that object.</para></listitem>

<listitem><para>The order of ACEs is important. The system reads them in
sequence until either any single requested permission is denied or all
requested permissions are granted.  Reading stops when this condition is
met.  Later ACEs are not taken into account.</para></listitem>

<listitem><para>All access denied ACEs <emphasis
role='bold'>should</emphasis> precede any access allowed ACE.  ACLs
following this rule are called "canonical"</para></listitem>
</itemizedlist>

<para>Note that the last rule is a preference or a definition of
correctness.  It's not an absolute requirement.  All Windows kernels
will correctly deal with the ACL regardless of the order of allow and
deny ACEs.  The second rule is not modified to get the ACEs in the
preferred order.</para>

<para>Unfortunately the security tab in the file properties dialog of
the Windows Explorer insists to rearrange the order of the ACEs to
canonical order before you can read them. Thank God, the sort order
remains unchanged if one presses the Cancel button.  But don't even
<emphasis role='bold'>think</emphasis> of pressing OK...</para>

<para>Canonical ACLs are unable to reflect each possible combination
of POSIX permissions. Example:</para>

<screen>
rw-r-xrw-
</screen>

<para>Ok, so here's the first try to create a matching ACL, assuming
the Windows permissions only have three bits, as their POSIX counterpart:
</para>

<screen>
UserAllow:   110
GroupAllow:  101
OthersAllow: 110
</screen>

<para>Hmm, because of the accumulation of allow rights the user may
execute because the group may execute.</para>

<para>Second try:</para>

<screen>
UserDeny:    001
GroupAllow:  101
OthersAllow: 110
</screen>

<para>Now the user may read and write but not execute. Better? No!
Unfortunately the group may write now because others may write.</para>

<para>Third try:</para>

<screen>
UserDeny:    001
GroupDeny:   010
GroupAllow:  001
OthersAllow: 110
</screen>

<para>Now the group may not write as intended but unfortunately the user may
not write anymore, either. How should this problem be solved? According to
the canonical order a UserAllow has to follow the GroupDeny but it's
easy to see that this can never be solved that way.</para>

<para>The only chance:</para>

<screen>
UserDeny:    001
UserAllow:   010
GroupDeny:   010
GroupAllow:  001
OthersAllow: 110
</screen>

<para>Again: This works on all existing versions of Windows NT, at the
time of writing from at least Windows XP up to Server 2012.  Only
the GUIs aren't able (or willing) to deal with that order.</para>

</sect2>

<sect2 id="ntsec-setuid-overview"><title id="ntsec-setuid-overview.title">Switching the user context</title>

<para>Since Windows XP, Windows users have been accustomed to the
"Switch User" feature, which switches the entire desktop to another user
while leaving the original user's desktop "suspended".  Another Windows
feature is the "Run as..." context menu entry, which allows you to start
an application using another user account when right-clicking on applications
and shortcuts.</para>

<para>On POSIX systems, this operation can be performed by processes
running under the privileged user accounts (usually the "root" user
account) on a per-process basis.  This is called "switching the user
context" for that process, and is performed using the POSIX
<command>setuid</command> and <command>seteuid</command> system
calls.</para>

<para>While this sort of feature is available on Windows as well,
Windows does not support the concept of these calls in a simple fashion.
Switching the user context in Windows is generally a tricky process with
lots of "behind the scenes" magic involved.</para>

<para>Windows uses so-called `access tokens' to identify a user and its
permissions.  Usually the access token is created at logon time and then
it's attached to the starting process.  Every new process within a session
inherits the access token from its parent process.  Every thread can
get its own access token, which allows, for instance, to define threads
with restricted permissions.</para>

</sect2>

<sect2 id="ntsec-logonuser"><title id="ntsec-logonuser.title">Switching the user context with password authentication</title>

<para>To switch the user context, the process has to request such an access
token for the new user.  This is typically done by calling the Win32 API
function <command>LogonUser</command> with the user name and the user's
cleartext password as arguments.  If the user exists and the password was
specified correctly, the access token is returned and either used in
<command>ImpersonateLoggedOnUser</command> to change the user context of
the current thread, or in <command>CreateProcessAsUser</command> to
change the user context of a spawned child process.</para>

<para>Later versions of Windows define new functions in this context and
there are also functions to manipulate existing access tokens (usually
only to restrict them).  Windows Vista also adds subtokens which are
attached to other access tokens which plays an important role in the UAC
(User Access Control) facility of Vista and later.  However, none of
these extensions to the original concept are important for this
documentation.</para>

<para>Back to this logon with password, how can this be used to
implement <command>set(e)uid</command>?  Well, it requires modification
of the calling application.  Two Cygwin functions have been introduced
to support porting <command>setuid</command> applications which only
require login with passwords.  You only give Cygwin the right access
token and then you can call <command>seteuid</command> or
<command>setuid</command> as usual in POSIX applications.  Porting such
a <command>setuid</command> application is illustrated by a short
example:</para>

<screen>
<![CDATA[
/* First include all needed cygwin stuff. */
#ifdef __CYGWIN__
#include <windows.h>
#include <sys/cygwin.h>
#endif

[...]

  struct passwd *user_pwd_entry = getpwnam (username);
  char *cleartext_password = getpass ("Password:");

[...]

#ifdef __CYGWIN__
  /* Patch the typical password test. */
  {
    HANDLE token;

    /* Try to get the access token from Windows. */
    token = cygwin_logon_user (user_pwd_entry, cleartext_password);
    if (token == INVALID_HANDLE_VALUE)
       error_exit;
    /* Inform Cygwin about the new impersonation token. */
    cygwin_set_impersonation_token (token);
    /* Cygwin is now able, to switch to that user context by setuid or seteuid calls. */
  }
#else
    /* Use standard method on non-Cygwin systems. */
    hashed_password = crypt (cleartext_password, salt);
    if (!user_pwd_entry ||
        strcmp (hashed_password, user_pwd_entry->pw_password))
      error_exit;
#endif /* CYGWIN */

[...]

  /* Everything else remains the same! */

  setegid (user_pwd_entry->pw_gid);
  seteuid (user_pwd_entry->pw_uid);
  execl ("/bin/sh", ...);
]]>

</screen>

</sect2>

<sect2 id="ntsec-nopasswd1"><title id="ntsec-nopasswd1.title">Switching the user context without password, Method 1: Create a token from scratch</title>

<para>An unfortunate aspect of the implementation of
<command>set(e)uid</command> is the fact that the calling process
requires the password of the user to which to switch.  Applications such as
<command>sshd</command> wishing to switch the user context after a
successful public key authentication, or the <command>cron</command>
application which, again, wants to switch the user without any authentication
are stuck here.  But there are other ways to get new user tokens.</para>

<para>One way is just to create a user token from scratch.  This is
accomplished by using an (officially undocumented) function on the NT
function level.  The NT function level is used to implement the Win32
level, and, as such is closer to the kernel than the Win32 level.  The
function of interest, <command>NtCreateToken</command>, allows you to
specify user, groups, permissions and almost everything you need to
create a user token, without the need to specify the user password.  The
only restriction for using this function is that the calling process
needs the "Create a token object" user right, which only the SYSTEM user
account has by default, and which is considered the most dangerous right
a user can have on Windows systems.</para>

<para>That sounds good.  We just start the servers which have to switch
the user context (<command>sshd</command>, <command>inetd</command>,
<command>cron</command>, ...) as Windows services under the SYSTEM
(or LocalSystem in the GUI) account and everything just works.
Unfortunately that's too simple.  Using <command>NtCreateToken</command>
has a few drawbacks.</para>

<para>First of all, beginning with Windows Server 2003,
the permission "Create a token object" gets explicitly removed from
the SYSTEM user's access token, when starting services under that
account.  That requires us to create a new account with this specific
permission just to run this kind of services.  But that's a minor
problem.</para>

<para>A more important problem is that using <command>NtCreateToken</command>
is not sufficient to create a new logon session for the new user.  What
does that mean?  Every logon usually creates a new logon session.
A logon session has a couple of attributes which are unique to the
session.  One of these attributes is the fact, that Windows functions
identify the user domain and user name not by the SID of the access
token owner, but only by the logon session the process is running under.</para>

<para>This has the following unfortunate consequence.  Consider a
service started under the SYSTEM account (up to Windows XP) switches the
user context to DOMAIN\my_user using a token created directly by calling
the <command>NtCreateToken</command> function.  A process running under
this new access token might want to know under which user account it's
running.  The corresponding SID is returned correctly, for instance
S-1-5-21-1234-5678-9012-77777.  However, if the same process asks the OS
for the user name of this SID something wierd happens.  For instance,
the <command>LookupAccountSid</command> function will not return
"DOMAIN\my_user", but "NT AUTHORITY\SYSTEM" as the user name.</para>

<para>You might ask "So what?"  After all, this only <emphasis
role='bold'>looks</emphasis> bad, but functionality and permission-wise
everything should be ok.  And Cygwin knows about this shortcoming so it
will return the correct Cygwin username when asked.  Unfortunately this
is more complicated.  Some native, non-Cygwin Windows applications will
misbehave badly in this situation.  A well-known example are certain versions
of Visual-C++.</para>

<para>Last but not least, you don't have the usual comfortable access
to network shares.  The reason is that the token has been created
without knowing the password.  The password are your credentials
necessary for network access.  Thus, if you logon with a password, the
password is stored hidden as "token credentials" within the access token
and used as default logon to access network resources.  Since these
credentials are missing from the token created with
<command>NtCreateToken</command>, you only can access network shares
from the new user's process tree by using explicit authentication, on
the command line for instance:</para>

<screen>
bash$ net use '\\server\share' /user:DOMAIN\my_user my_users_password
</screen>

<para>Note that, on some systems, you can't even define a drive letter
to access the share, and under some circumstances the drive letter you
choose collides with a drive letter already used in another session.
Therefore it's better to get used to accessing these shares using the UNC
path as in</para>

<screen>
bash$ grep foo //server/share/foofile
</screen>

</sect2>

<sect2 id="ntsec-nopasswd2"><title id="ntsec-nopasswd2.title">Switching the user context without password, Method 2: LSA authentication package</title>

<para>We're looking for another way to switch the user context without
having to provide the password.  Another technique is to create an
LSA authentication package.  LSA is an acronym for "Local Security Authority"
which is a protected part of the operating system which only allows changes
to become active when rebooting the system after the change.  Also, as soon as
the LSA encounters serious problems (for instance, one of the protected
LSA processes died), it triggers a system reboot.  LSA is the part of
the OS which cares for the user logons and which also creates logon
sessions.</para>

<para>An LSA authentication package is a DLL which has to be installed
as part of the LSA.  This is done by tweaking a special registry key.
Cygwin provides such an authentication package.  It has to be installed
and the machine has to be rebooted to activate it.  This is the job of the
shell script <filename>/usr/bin/cyglsa-config</filename> which is part of
the Cygwin package.</para>

<para>After running <filename>/usr/bin/cyglsa-config</filename> and
rebooting the system, the LSA authentication package is used by Cygwin
when <command>set(e)uid</command> is called by an application.  The
created access token using this method has its own logon session.</para>

<para>This method has two advantages over the <command>NtCreateToken</command>
method.</para>

<para>The very special and very dangerous "Create a token object" user
right is not required by a user using this method.  Other privileged
user rights are still necessary, especially the "Act as part of the
operating system" right, but that's just business as usual.</para>

<para>The user is correctly identified, even by delicate native applications
which choke on that using the <command>NtCreateToken</command> method.</para>

<para>Disadvantages?  Yes, sure, this is Windows.  The access token
created using LSA authentication still lacks the credentials for network
access.  After all, there still hasn't been any password authentication
involved.  The requirement to reboot after every installation or
deinstallation of the cygwin LSA authentication DLL is just a minor
inconvenience compared to that...</para>

<para>Nevertheless, this is already a lot better than what we get by
using <command>NtCreateToken</command>, isn't it?</para>

</sect2>

<sect2 id="ntsec-nopasswd3"><title id="ntsec-nopasswd3.title">Switching the user context without password, Method 3: With password</title>

<para>Ok, so we have solved almost any problem, except for the network
access problem.  Not being able to access network shares without
having to specify a cleartext password on the command line or in a 
script is a harsh problem for automated logons for testing purposes
and similar stuff.</para>

<para>Fortunately there is a solution, but it has its own drawbacks.
But, first things first, how does it work?  The title of this section
says it all.  Instead of trying to logon without password, we just logon
with password.  The password gets stored two-way encrypted in a hidden,
obfuscated area of the registry, the LSA private registry area.  This
part of the registry contains, for instance, the passwords of the Windows
services which run under some non-default user account.</para>

<para>So what we do is to utilize this registry area for the purpose of
<command>set(e)uid</command>.  The Cygwin command <command><link
linkend="passwd">passwd</link> -R</command> allows a user to specify
his/her password for storage in this registry area.  When this user
tries to login using ssh with public key authentication, Cygwin's
<command>set(e)uid</command> examines the LSA private registry area and
searches for a Cygwin specific key which contains the password.  If it
finds it, it calls <command>LogonUser</command> under the hood, using
this password.  If that works, <command>LogonUser</command> returns an
access token with all credentials necessary for network access.</para>

<para>For good measure, and since this way to implement
<command>set(e)uid</command> is not only used by Cygwin but also by
Microsoft's SFU (Services for Unix), we also look for a key stored by
SFU (using the SFU command <command>regpwd</command>) and use that if it's
available.</para>

<para>We got it.  A full access token with its own logon session, with
all network credentials.  Hmm, that's heaven...</para>

<para>Back on earth, what about the drawbacks?</para>

<para>First, adding a password to the LSA private registry area
requires administrative access.  So calling <command>passwd -R</command>
as a normal user will fail!  Cygwin provides a workaround for
this.  If <command>cygserver</command> is started as a service running
under the SYSTEM account (which is the default way to run
<command>cygserver</command>) you can use <command>passwd -R</command>
as normal, non-privileged user as well.</para>

<para>Second, as aforementioned, the password is two-way encrypted in a
hidden, obfuscated registry area.  Only SYSTEM has access to this area
for listing purposes, so, even as an administrator, you can't examine
this area with regedit.  Right?  No.  Every administrator can start
regedit as SYSTEM user:</para>

<screen>
bash$ date
Tue Dec  2 16:28:03 CET 2008
bash$ at 16:29 /interactive regedit.exe
</screen>

<para>Additionally, if an administrator knows under which name
the private key is stored (which is well-known since the algorithms
used to create the Cygwin and SFU keys are no secret), every administrator
can access the password of all keys stored this way in the registry.</para>

<para>Conclusion: If your system is used exclusively by you, and if
you're also the only administrator of your system, and if your system is
adequately locked down to prevent malicious access, you can safely use
this method.  If your machine is part of a network which has
dedicated administrators, and you're not one of these administrators,
but you (think you) can trust your administrators, you can probably
safely use this method.</para>

<para>In all other cases, don't use this method.  You have been warned.</para>

</sect2>

<sect2 id="ntsec-setuid-impl"><title id="ntsec-setuid-impl.title">Switching the user context, how does it all fit together?</title>

<para>Now we learned about four different ways to switch the user
context using the <command>set(e)uid</command> system call, but
how does <command>set(e)uid</command> really work?  Which method does it
use now?</para>

<para>The answer is, all four of them.  So here's a brief overview
what <command>set(e)uid</command> does under the hood:</para>

<itemizedlist>
<listitem>
<para>When <command>set(e)uid</command> is called, it tests if the
user context had been switched by an earlier call already, and if the
new user account is the privileged user account under which the process
had been started originally.  If so, it just switches to the original
access token of the process it had been started with.</para>
</listitem>

<listitem>
<para>
Next, it tests if an access token has been stored by an earlier call
to <command>cygwin_set_impersonation_token</command>.  If so, it tests
if that token matches the requested user account.  If so, the stored
token is used for the user context switch.</para>

<para>
If not, there's no predefined token which can just be used for
the user context switch, so we have to create a new token.  The order
is as follows.</para>
</listitem>

<listitem>
<para>Check if the user has stored the logon password in the LSA
private registry area, either under a Cygwin key, or under a SFU key.
If so, use this to call <command>LogonUser</command>.  If this
succeeds, we use the resulting token for the user context switch.</para>
</listitem>

<listitem>
<para>Otherwise, check if the Cygwin-specifc LSA authentication package
has been installed and is functional.  If so, use the appropriate LSA
calls to communicate with the Cygwin LSA authentication package and
use the returned token.</para>
</listitem>

<listitem>
<para>Last chance, try to use the <command>NtCreateToken</command> call
to create a token.  If that works, use this token.</para>
</listitem>

<listitem>
<para>If all of the above fails, our process has insufficient privileges
to switch the user context at all, so <command>set(e)uid</command>
fails and returns -1, setting errno to EPERM.</para>
</listitem>
</itemizedlist>

</sect2>

</sect1>
@


1.28
log
@	* Throughout, eliminate Windows 2000 from the documentation.
	* overview.sgml (brief-history): Mention native AMD64 support.
@
text
@@


1.27
log
@	* faq-using.xml: Fix typos.
	* ntsec.sgml: Ditto.
	* pathnames.sgml: Ditto.
	* setup2.sgml: Ditto.
	* setup-net.sgml: Ditto.
	(setup-dir): Drop paragraph on Unix/DOS file mode.
@
text
@d500 1
a500 1
time of writing from at least Windows 2000 up to Server 2008 R2.  Only
d510 3
a512 3
feature (since Windows 2000) is the "Run as..." context menu entry,
which allows you to start an application using another user account when
right-clicking on applications and shortcuts.</para>
@


1.26
log
@	Throughout remove NT4 from documentation.

	* new-features.sgml (ov-new1.7.10): Document change in passwd command.
@
text
@d17 1
a17 1
<para>POSIX concepts and specificially the POSIX security model are not
@


1.25
log
@	* new-features.sgml (ov-new1.7.8): Document dropped NT4 pre-SP4 support.
	* faq-what.xml (faq.what.supported): Change accordingly.
	* ntsec.sgml (ntsec-mapping): Add 2008 R2.
@
text
@d439 4
a442 5
the Windows NT4 explorer is completely unable to deal with access denied ACEs
while the Windows 2000 and later properties dialog rearranges the order of the
ACEs to canonical order before you can read them. Thank God, the sort
order remains unchanged if one presses the Cancel button.  But don't
even <emphasis role='bold'>think</emphasis> of pressing OK...</para>
d500 2
a501 2
time of writing from at least NT4 up to Server 2008 R2.  Only the GUIs
aren't able (or willing) to deal with that order.</para>
a704 4
<para>Caveat: The method described in this chapter only works starting
with Windows 2000.  Windows NT4 users have to use one of the other
methods described in this document.</para>

@


1.24
log
@Change explicitely to explicitly throughout.
@
text
@d501 1
a501 1
time of writing from at least NT4 up to Server 2008.  Only the GUIs
@


1.23
log
@	* Various syntactical and semantical fixes throughout.
@
text
@d644 1
a644 1
the permission "Create a token object" gets explicitely removed from
@


1.22
log
@ChangeLog:

	* configure.in: Remove --enable-server option.  Allways add the
	cygserver directory to $SUBDIRS.
	* configure: Regenerate.

cygwin/ChangeLog:

	Remove USE_SERVER define.  Accommodate throughout.
	* configure.in: Remove --enable-server option.
	* configure: Regenerate.
	* environ.cc: Remove CYGWIN=server setting.

cygserver/ChangeLog:

	* client.cc (allow_server): Remove variable.
	(client_request_get_version::client_request_get_version): Drop checking
	allow_server.

utils/ChangeLog:

	* passwd.c: Remove CYGWIN=server requirement from usage text.

doc/ChangeLog:

	* cygserver.sgml: Remove the "How to use the Cygserver services"
	section.
	* cygwinenv.sgml: Move "(no)server" to the removed options section.
	* faq-programming.xml: Remove CYGWIN=server requirement for running
	the Cygwin testsuite.
	* ntsec.sgml: Ditto for using `passwd -R'.
@
text
@d156 1
a156 1
<para>Naturally well-known SIDs are the same on each machine, so they are
d160 1
a160 1
<para>Additionally there are a couple of well-known builtin groups,
d205 1
a205 1
which disallows to map certain POSIX permissions cleanly.  See
d298 2
a299 2
all is well.  This allows for instance to rename the "Administrators" group
to "root" as well:</para>
d308 1
a308 1
<para>Last but not least you can also change the primary group of a user
d312 2
a313 2
which in turn is member of the well-known group "Users".  So, if it's
more feasible in your environment that the user's primary group is
d319 12
a330 9
<para>However, here's a WARNING: If you want to do similar changes to
your files, please do that only if you're feeling comfortable with the
concepts.  Otherwise don't be surprised if some stuff doesn't work
anymore.  If you screwed up things, revert to <filename>/etc/passwd</filename>
and <filename>/etc/group</filename> files created by mkpasswd
and mkgroup.  Especially don't change the UID or the name of user
SYSTEM.  Even if that works mostly, some Cygwin applications running as
local service under that account could suddenly start behaving
strangely.</para>
d409 1
a409 1
POSIX permission model on the Windows permission model.</para>
d453 2
a454 1
the Windows permissions only have three bits, as their POSIX pendants:</para>
d512 1
a512 1
which allows to start an application using another user account when
d538 1
a538 1
<para>To switch the user context the process has to request such an access
d556 8
a563 7
implement <command>set(e)uid</command>?  Well, it requires to patch the
calling application.  Two Cygwin functions have been introduced to support
porting <command>setuid</command> applications which only require login
with passwords.  You only give Cygwin the right access token and then
you can call <command>seteuid</command> or <command>setuid</command> as
usual in POSIX applications.  Porting such a <command>setuid</command>
application is illustrated by a short example:</para>
d616 3
a618 3
<para>So far unfortunate for the implementation of a
<command>set(e)uid</command> call is the fact that the calling process
needs the password of the user it wants to switch to.  Applications like
d620 3
a622 3
successful public key authentication, or <command>cron</command> which
has to switch the user without any authentication are stuck here.  But
there are other ways to get new user tokens.</para>
d626 5
a630 6
function level.  The NT function level is closer to the actual kernel
than the Win32 level.  Actually the Win32 functions are implemented
using the NT functions.  The function we're interested in is
<command>NtCreateToken</command>.  This function allows to specify
user, groups, permissions and almost everything you need to create
a user token, without the need to specify the user password.  The
d632 3
a634 3
needs the "Create a token object" user right, which only the
SYSTEM user account has by default, and which is considered the most
dangerous right a user can have on Windows systems.</para>
d646 1
a646 1
account.  That requires to create a new account with this specific
d652 1
a652 1
does that mean?  Every logon usually creates also a new logon session.
d658 5
a662 5
<para>What that means is this.  Consider a service started under the
SYSTEM account (up to Windows XP) switches the user context to
DOMAIN\my_user using a token created directly by calling the
<command>NtCreateToken</command> function.  A process running under this
new access token might want to know under which user account it's
d710 1
a710 1
<para>So we're looking for another way to switch the user context without
a754 2
<!-- TODO: The rest of the file... -->

d764 1
a764 1
But first thing first, how does it work?  The title of this section
d768 1
a768 1
part of the registry contains for instance the passwords of the Windows
d830 1
a830 1
<sect2 id="ntsec-setuid-impl"><title id="ntsec-setuid-impl.title">Switching the user context, how does that all fit together?</title>
@


1.21
log
@	* ntsec.sgml: Fix typo.
@
text
@d793 1
a793 1
as a normal user will fail.  Cygwin provides a workaround for
d797 1
a797 12
as normal, non-privileged user as well.  Just keep in mind that this
requires to set the environment variable CYGWIN to contain the word
"server" before running <command>passwd -R</command>, if it's not
already set anyway.  See <xref linkend="using-cygwinenv"></xref>.
Example:</para>

<screen>
bash$ echo $CYGWIN
tty
bash$ export CYGWIN="tty server"
bash$ passwd -R
</screen>
@


1.20
log
@	* ntsec.sgml: Revamp parts of the doc for clearness.
@
text
@d829 1
a829 1
adequately locked down to prevent malicious access, you can savely use
d833 1
a833 1
savely use this method.</para>
@


1.19
log
@	* ntsec.sgml: Fix a few typos.
@
text
@d3 1
a3 1
<para>This paragraph discusses how the Windows security model is
d5 2
a6 2
the authentication model is used to allow to switch the user context in
a POSIX-like fashion.</para>
d8 1
a8 1
<para>The setting of POSIX like file and directory permissions is
d17 4
a20 3
<para>The POSIX security model is not discussed here, but assumed to be
understood by the reader.  If you don't know the POSIX security model,
search the web for beginner documentation.</para>
d29 2
a30 2
who can how access an object.  The SD of an object consists of five
parts:</para>
d47 7
a53 5
<para>A SID is a unique identifier for users, groups, computers and AD
domains.  SIDs are basically comparable to POSIX UIDs and GIDs, but are
more complicated because they are unique across multiple machines or
domains.  A SID is a structure of multiple numerical values.  There's
a convenient convention to type SIDs.  Here's an example:</para>
d67 12
a78 9
<para>The leading "S" has no further meaning except to show that this is
a SID.  The next number is a version number which is always 1 so far.
The next two numbers are the authority which shows the initiated what
kind of SID this is.  There are a couple of builtin accounts and
accounts with very special meaning. However, computer and domain SIDs
always start with "S-1-5-21".  The next three numbers, all 32 bit values,
are the unique 96 bit identifier of the computer system.  This is
hopefully unique all over the world, but in practice it's sufficient if
the computer SIDs are unique within a single Windows network.</para>
d110 3
a112 2
the same, right?  The answer is, these accounts are NOT identical.
For all the machines know there are two different accounts, one is
d114 1
a114 2
Different SID, different account.  Full stop.
</para>
d127 6
a132 6
bits in a permission value just represent the permissions for "everyone
who is not the owner or is member of the owning group".  Windows has a
SID for these poor souls, the "Everyone" SID.  Other well-known SIDs
represent circumstances under which a process is running, rather than
actual users or groups.  Here are a few examples for well-known
SIDs:</para>
d150 7
a156 3
<para>For a full list please refer to the MSDN document
<ulink url="http://msdn.microsoft.com/en-us/library/aa379649.aspx">Well-known SIDs</ulink>.
Naturally well-known SIDs are the same on each machine, so they are
a501 1

d504 18
a521 5
<para>POSIX applications which have to switch the user context are using
the <command>setuid</command> and <command>seteuid</command> calls.
Windows doesn't support the concept of these calls in a simple
fashion and switching the user context in Windows is generally a tricky
process with lots of "behind the scenes" magic involved.</para>
d527 2
a528 3
get its own access token, which allows to define threads with restricted
permissions.  To switch the user context the process has to request such
an access token for the new user.</para>
d536 14
a549 11
function <command>LogonUser</command>. The access token is returned and
either used in <command>ImpersonateLoggedOnUser</command> to change the
user context of the current thread, or in
<command>CreateProcessAsUser</command> to change the user context of a
spawned child process.  Later versions of Windows define new functions
in this context and there are also functions to manipulate existing
access tokens (usually only to restrict them).  Windows Vista also adds
subtokens which are attached to other access tokens which plays an
important role in the UAC (User Access Control) facility of Vista and
later.  However, none of these extensions are really important for
this documentation.</para>
a565 2
/* Use the following define to determine the Windows version */
#define is_winnt        (GetVersion() < 0x80000000)
d584 1
a584 3
    /* Inform Cygwin about the new impersonation token.
       Cygwin is able now, to switch to that user context by
       setuid or seteuid calls. */
d586 1
@


1.18
log
@	* ntsec.sgml: Finishing up changes for 1.7.
@
text
@d278 2
a279 2
Cygwin dutyfully translates "root" into the Windows user
"FOO\Administrators" and files owned by FOO\Administrators are shown to
@


1.17
log
@	* ntsec.sgml: Further changes for 1.7.  Switch from "NT" to "Windows".
	Add preliminary text.  Try to be more clear in description.  Remove
	useless chapters.  Finish the permission related chapters.
@
text
@d9 1
a9 1
controlled by the <link linkend="mount-table">mount option</link>
d70 1
a70 1
are the unique 96 bit identifier of the comupter system.  This is
d72 1
a72 1
the comuter SIDs are unique within a single Windows network.</para>
d100 1
a100 1
<para>Ok, so you now have two accounts called johndoe, one account
d113 1
a113 1
files using the <command>mkpasswd</command> and <command>mkgroup</command>
d124 3
a126 2
represent more circumstances instead of actual users or groups.  Here
are a few examples for well-known SIDs:</para>
d144 1
a144 1
<para>For a full list please refer to
d170 2
a171 2
Admins", this guy will automatically be a mamber of the administrators
group on "foo", when logging in on "foo".  Neat, isn't it?</para>
d198 10
d220 1
a220 1
These files define the traslation between the Cygwin uid/gid and the
d232 3
a234 4
name entry.  It takes the form "U-domain\username" and is typically used
by services to authenticate a user.  Logging in through <command>ssh</command>
or <command>telnet</command> are two typical scenarios.
</para>
d250 7
a256 6
<command>ls</command> to print some file ownerships correctly.  Windows
doesn't care if the owner of a file is a user or a group.  In older
versions of Windows NT the default ownership for files created by an
administrator account was set to the group Administrators instead of to
the creating user account.  This has changed, but for those older
systems it's convenient to have the Administrators group in
d265 1
a265 1
name and uid which doesn't have to match the Windows account at all.  As
d306 2
a307 1
default 545).</para>
d310 1
a310 1
your files, please do that only if you're feeling comfortably with the
d321 72
d407 1
a407 1
user.</para></listitem>
d414 3
a416 3
<listitem><para>All access denied ACEs _should_ precede any access
allowed ACE.  ACLs following this rule are called "canonical"</para></listitem>

d430 1
a430 1
even _think_ of pressing OK...</para>
d492 2
a493 1
<sect2 id="ntsec-setuid"><title id="ntsec-setuid.title">Switching the user context</title>
d496 2
a497 3
the <command>setuid</command> and <command>seteuid</command> calls.</para>

<para>Windows doesn't support the concept of these calls in a simple
d501 11
a511 1
<!-- TODO: The rest of the file... -->
d513 2
a514 3
<para>Windows uses so-called `access tokens' to identify a user and it's
permissions. To switch the user context the application has to request
such an `access token'. This is typically done by calling the Win32 API
d516 19
a534 22
either used in <command>ImpersonateLoggedOnUser</command> to change user
context of the current process or in <command>CreateProcessAsUser</command>
to change user context of a spawned child process. An important restriction
is that the application using <command>LogonUser</command> must have special
permissions:</para>

<screen>
"Act as part of the operating system"
"Replace process level token"
"Increase quotas"
</screen>

<para>Note that administrators do not have all these user rights set 
by default.</para>

<para>Two new Cygwin calls are introduced to support porting
<command>setuid</command> applications with a minimum of effort. You only
give Cygwin the right access token and then you can call
<command>seteuid</command> or <command>setuid</command> as usual in POSIX
applications. The call to <command>sexec</command> is not needed
anymore. Porting a <command>setuid</command> application is illustrated by
a short example:</para>
d555 14
a568 16
  if (is_winnt)
    {
      HANDLE token;

      /* Try to get the access token from NT. */
      token = cygwin_logon_user (user_pwd_entry, cleartext_password);
      if (token == INVALID_HANDLE_VALUE)
         error_exit;
      /* Inform Cygwin about the new impersonation token.
         Cygwin is able now, to switch to that user context by
         setuid or seteuid calls. */
      cygwin_set_impersonation_token (token);
    }
  else
#endif /* CYGWIN */
    /* Use standard method for W9X as well. */
d573 1
d586 1
a586 5
<para>The new Cygwin call to retrieve an access token is defined as follows:</para>

<screen>
#include &lt;windows.h&gt;
#include &lt;sys/cygwin.h&gt;
d588 1
a588 3
HANDLE
cygwin_logon_user (struct passwd *pw, const char *cleartext_password)
</screen>
d590 82
a671 2
<para>You can call that function as often as you want for different user
logons and remember the access tokens for further calls to the second function.</para>
d674 1
a674 5
#include &lt;windows.h&gt;
#include &lt;sys/cygwin.h&gt;

void
cygwin_set_impersonation_token (HANDLE hToken);
d677 1
a677 6
<para> is the call to inform Cygwin about the user context to which further
calls to <command>setuid</command>/<command>seteuid</command> should switch to.
While you always need the correct access token to do a
<command>setuid</command>/<command>seteuid</command> to another user's context,
you are always able to use <command>setuid</command>/<command>seteuid</command>
to return to your own user context by giving your own uid as parameter.</para>
d679 1
a679 3
<para>If you have remembered several access tokens from calls to
<command>cygwin_logon_user</command> you can switch to different user
contexts by observing the following order:</para>
d681 43
a723 1
<screen>
d725 2
a726 2
  cygwin_set_impersonation_token (user1_token);
  seteuid (user1_uid);
d728 1
a728 1
[...]
d730 1
a730 5
  seteuid (own_uid);
  cygwin_set_impersonation_token (user2_token);
  seteuid (user2_uid);

[...]
d732 1
a732 3
  seteuid (own_uid);
  cygwin_set_impersonation_token (user1_token);
  seteuid (user1_uid);
d734 79
a812 1
etc.
d814 1
a814 1
</screen>
d818 1
a818 2
<sect2 id="ntsec-switch"><title id="ntsec-switch.title">Switching User
Context</title>
d820 16
a835 34
<para>
Since Cygwin release 1.3.3, applications that are members of the
Administrators group and have the <command>Create a token
object</command>, <command>Replace a process level token</command> and
<command>Increase Quota</command> user rights can switch user
context without giving a password by just calling the usual
<command>setuid</command>, <command>seteuid</command>,
<command>setgid</command> and <command>setegid</command> functions.  
</para>
<para>
Up to Windows XP the <systemitem
class="username">SYSTEM</systemitem> user has these privileges and can
run services such as <command>sshd</command>. However, startung with Windows 2003
<systemitem class="username">SYSTEM</systemitem> lacks the
<command>Create a token object</command> right, so it is necessary to
create a special user with all the necessary rights, as
well as <command>Logon as a service</command>, to run such services.
For security reasons this user should be denied the rights to logon
interactively or over the network. All this is done by configuration
scripts such as <command>ssh-host-config</command>.
</para>
<para>
An important restriction of this method is that a process started
without a password cannot access network shares which require
authentication.  This also applies to subprocesses which switched user
context without a password.  Therefore, when using
<command>ssh</command> or <command>rsh</command> without a password, it
is typically not possible to access network drives.
</para>

</sect2>

<sect2 id="ntsec-ids"><title id="ntsec-ids.title">Special values of user and group
ids</title>
d837 1
d839 4
a842 8
If the current user is not present in <filename>/etc/passwd</filename>,
that user's user id is set to a special value of 400.  The user name for
the current user will always be shown correctly.  If another user
(or a Windows group, treated as a user) is not present in
<filename>/etc/passwd</filename>, the user id of that user will have a
special value of -1 (which would be shown by <command>ls</command> as
65535).  The user name shown in this case will be '????????'.
</para>
d845 4
a848 13
If the current user is not present in <filename>/etc/passwd</filename>,
that user's login group id is set to a special value of 401.  If another
user is not present in <filename>/etc/passwd</filename>, that user's login
group id is set to a special value of -1.  If the user is present in
<filename>/etc/passwd</filename>, but that user's group is not in
<filename>/etc/group</filename> and is not the login group of that user,
the group id is set to a special value of -1.  The name of this group
(id -1) will be shown as '????????'.
In releases of Cygwin before 1.3.20, the group id 401 had a group name
'None'.  Since Cygwin release 1.3.20, the group id 401 is shown as
'mkpasswd', indicating the command that should be run to alleviate the
situation.
</para>
d850 6
a855 6
<para>
Also, since Cygwin release 1.3.20, if the current user is present in
<filename>/etc/passwd</filename>, but that user's login group is not
present in <filename>/etc/group</filename>, the group name will be shown
as 'mkgroup', again indicating the appropriate command.
</para>
d857 6
a862 6
<para>To summarize:</para>
<itemizedlist spacing="compact">

<listitem><para>If the current user doesn't show up in
<filename>/etc/passwd</filename>, it's <emphasis>group</emphasis> will
be named 'mkpasswd'.</para></listitem>
d864 3
a866 2
<listitem><para>Otherwise, if the login group of the current user isn't
in <filename>/etc/group</filename>, it will be named 'mkgroup'.</para>
d869 4
a872 3
<listitem><para>Otherwise a group not in <filename>/etc/group</filename>
will be shown as '????????' and a user not in
<filename>/etc/passwd</filename> will be shown as "????????".</para>
a873 1

a875 8
<para>
Note that, since the special user and group names are just indicators,
nothing prevents you from actually having a user named `mkpasswd' in
<filename>/etc/passwd</filename> (or a group named `mkgroup' in
<filename>/etc/group</filename>).  If you do that, however, be aware of
the possible confusion.
</para>

@


1.16
log
@	* Revamp documentation for Cygwin 1.7, part 1.
@
text
@d1 1
a1 1
<sect1 id="ntsec"><title>NT security</title>
d3 9
a11 5
<para>The setting of POSIX like object permissions is controlled by the 
<link linkend="mount-table">mount option</link> <literal>(no)acl</literal>
which is set to <literal>acl</literal> by default.  The design goal
is to utilize the Windows access control API to implement real POSIX
permissions.</para>
d17 3
a19 1
<sect2 id="ntsec-common"><title>NT security</title>
d21 3
a23 1
<para>In the NT security model, almost any "object" is securable.
d26 4
a29 3
<para>Every object has a data structure called "security descriptor" (SD)
attached.  The SD contains all information necessary to control who can
how access an object.  The SD of an object consists of five parts:</para>
d38 2
a39 3
<listitem><para>Another list of ACEs, called the
"Security Access Control List" (SACL), which doesn't matter for our
purpose.</para></listitem>
d193 3
a195 1
data.</para>
d207 1
a207 1
<para>To use NT security correctly, Cygwin depends on the files
d291 15
a305 3
which in turn is member of the well-known group "Users".  Additionally let's
assume the user is also a member of the newly created group .  The default
primary group for users is 
d307 1
a307 17
<!-- TODO: The rest of the file... -->

</para>

<para>As you can see, I changed my primary group membership from 513 (None)
to 547 (powerusers).  So all files I created inside of Cygwin were now owned
by the powerusers group instead of None.  This is the way I liked it.</para>

<para>Groups may be mentioned in the passwd file, too. This has two
advantages:</para>

<itemizedlist spacing="compact">
<listitem><para>Because NT assigns them to files as owners, a
<command>ls -l</command> is often more readable.</para></listitem>
<listitem><para>Moreover it's possible to assigned them to files as
owners with Cygwin's <command>chown</command>.</para></listitem>
</itemizedlist>
d309 1
a309 4
<para>The group `system' is the aforementioned synonym for the operating system
itself and is normally the owner of processes that are started through
service manager. The same is true for files that are created by
processes, which are started through service manager.</para>
d311 2
a312 1
</sect2>
d314 3
a316 1
<sect2 id="ntsec-sids"><title id="ntsec-sids.title">NT SIDs in Cygwin</title>
a317 1
<para>This has the following advantages:</para>
d319 10
a328 12
<listitem><para>ntsec works better in domain environments.</para></listitem>
<listitem><para>Accounts (users and groups) may get another name in
Cygwin than their NT account name. The name in <filename>/etc/passwd</filename>
or <filename>/etc/group</filename> is transparently used by Cygwin
applications (e.g. <command>chown</command>, <command>chmod</command>,
<command>ls</command>):</para>

<screen>
root::500:513::/home/root:/bin/sh
</screen>

<para>instead of</para>
d330 2
a331 10
<screen>
adminstrator::500:513::/home/root:/bin/sh
</screen>

<para>Caution: If you like to use the account as login account via
<command>telnet</command> etc. you have to remain the name unchanged or
you have to use the special version of <command>login</command> which is
part of the standard Cygwin distribution since 1.1.</para></listitem>
<listitem><para>Cygwin UIDs and GIDs are now not necessarily the RID
part of the NT SID:</para>
a332 28
<screen>
root::0:513:S-1-5-21-54355234-56236534-345635656-500:/home/root:/bin/sh
</screen>

<para>instead of</para>

<screen>
root::500:513::/home/root:/bin/sh
</screen>

</listitem>
<listitem><para>As in U*X systems UIDs and GIDs numbering scheme now
don't influence each other. So it's possible to have same Id's for a
user and a group:</para>
<example id="ntsec-passwd-root">
<title>/etc/passwd:</title>
<screen>
root::0:0:S-1-5-21-54355234-56236534-345635656-500:/home/root:/bin/sh
</screen>
</example>

<example id="ntsec-group-root">
<title>/etc/group:</title>
<screen>
root:S-1-5-32-544:0:
</screen>
</example>
</listitem>
d335 12
a346 11
<para>The tools <command>mkpasswd</command> and <command>mkgroup</command>
create the needed entries by default. If you don't want that you can use
the options <literal>-s</literal> or <literal>--no-sids</literal>. I suggest
not to do this since ntsec works better when having the SIDs available.</para>

<para>Please note that the pw_gecos field in <filename>/etc/passwd</filename>
is defined as a comma separated list. The SID has to be the last field!</para>

<screen>
the_king::1:1:Elvis Presley,U-STILLHERE\elvis,S-1-5-21-1234-5678-9012-1000:/bin/sh
</screen>
d348 2
a349 81
<para>For a local user just drop the domain:</para>

<screen>
the_king::1:1:Elvis Presley,U-elvis,S-1-5-21-1234-5678-9012-1000:/bin/sh
</screen>

<para>In either case the password of the user is taken from the NT user
database, NOT from the passwd file!</para>

<para>As in the previous chapter I give my personal
<filename>/etc/passwd</filename> and <filename>/etc/group</filename> as
examples.  Please note that I've changed these files heavily!  There's no
need to change them that way, it's just for testing purposes and...
for fun.</para>

<example id="ntsec-passwd-ex-2">
<title>/etc/passwd</title>
<screen>
root:*:0:0:Administrators group,S-1-5-32-544::
SYSTEM:*:18:18:,S-1-5-18:/home/system:/bin/bash
admin:*:500:513:,S-1-5-21-1844237615-436374069-1060284298-500:/home/Administrator:/bin/bash
corinna:*:100:0:Corinna Vinschen,S-1-5-21-1844237615-436374069-1060284298-1003:/home/corinna:/bin/tcsh
Guest:*:501:546:,S-1-5-21-1844237615-436374069-1060284298-501:/home/Guest:/bin/bash
</screen>
</example>

<example id="ntsec-group-ex-2">
<title>/etc/group</title>
<screen>
root:S-1-5-32-544:0:
local:S-1-2-0:2:
network:S-1-5-2:3:
interactive:S-1-5-4:4:
authenticatedusers:S-1-5-11:5:
SYSTEM:S-1-5-18:18:
local_svc:S-1-5-19:19:
netwrk_svc:S-1-5-20:20:
none:S-1-5-21-1844237615-436374069-1060284298-513:513:
bckup_op:S-1-5-32-551:551:
guests:S-1-5-32-546:546:
pwrusers:S-1-5-32-547:547:
replicator:S-1-5-32-552:552:
users:S-1-5-32-545:545:
</screen>
</example>

<para>If you want to do similar changes to your files, please do that only
if you're feeling comfortably with the concepts.  Otherwise don't be surprised
if some stuff doesn't work anymore.  If you screwed up things, revert to files
created by mkpasswd and mkgroup.  Especially don't change the UID or the name
of user SYSTEM.  Even if that works mostly, some Cygwin applications running
as local service under that account could suddenly start behaving strangely.
</para>

</sect2>

<sect2 id="ntsec-mapping"><title id="ntsec-mapping.title">The mapping leak</title>

<para>Now its time to point out the leak in the NT permissions.
The official documentation explains in short the following:</para>
<itemizedlist spacing="compact">
<listitem><para>access allow ACEs are accumulated regarding to the
group membership of the caller.</para></listitem>
<listitem><para>The order of ACEs is important. The system reads them
in sequence until either any needed right is denied or all needed rights
are granted. Later ACEs are then not taken into account.</para></listitem>
<listitem><para>All access denied ACEs _should_ precede any
access allowed ACE.</para></listitem>
</itemizedlist>

<para>Note that the last rule is a preference, not a law. NT will correctly
deal with the ACL regardless of the sequence order. The second rule is
not modified to get the ACEs in the preferred order.</para>

<para>Unfortunately the security tab of the NT4 explorer is completely
unable to deal with access denied ACEs while the explorer of W2K rearranges
the order of the ACEs before you can read them. Thank God, the sort order
remains unchanged if one presses the Cancel button.</para>

<para>You still ask "Where is the leak?" NT ACLs are unable to reflect each
possible combination of POSIX permissions. Example:</para>
d355 2
a356 1
<para>1st try:</para>
d367 1
a367 1
<para>2st try:</para>
d378 1
a378 1
<para>3rd try:</para>
d389 1
a389 1
the official rules a UserAllow has to follow the GroupDeny but it's
d402 3
a404 2
<para>Again: This works for both, NT4 and W2K. Only the GUIs aren't
able to deal with that order.</para>
d408 1
a408 1
<sect2 id="ntsec-aclfuncs"><title id="ntsec-aclfuncs.title">The ACL API</title>
d410 2
a411 4
<para>For dealing with ACLs Cygwin now has the ACL API as it's
implemented in newer versions of Solaris. The new data structure
for a single ACL entry (ACE in NT terminology) is defined in
<filename>sys/acl.h</filename> as:</para>
d413 3
a415 7
<screen>
typedef struct acl {
  int     a_type;  /* entry type */
  uid_t   a_id;    /* UID | GID */
  mode_t  a_perm;  /* permissions */
} aclent_t;
</screen>
d417 1
a417 33
<para>The a_perm member of the aclent_t type contains only the bits
for read, write and execute as in the file mode. If e.g. read permission
is granted, all read bits (S_IRUSR, S_IRGRP, S_IROTH) are set.
CLASS_OBJ or MASK ACL entries are not fully implemented yet.</para>

<para>The new API calls are</para>

<screen>
acl(2), facl(2)
aclcheck(3),
aclsort(3),
acltomode(3), aclfrommode(3),
acltopbits(3), aclfrompbits(3),
acltotext(3), aclfromtext(3)
</screen>

<para>Like in Solaris, Cygwin has two new commands for working with
ACLs on the command line: <command>getfacl</command> and
<command>setfacl</command>.</para>

<para>Online man pages for the aforementioned commands and API calls can be
found on <ulink url="http://docs.sun.com">http://docs.sun.com</ulink> </para>

</sect2>

<sect2 id="ntsec-setuid"><title id="ntsec-setuid.title">New setuid concept</title>

<para>POSIX applications which have to switch the user context are using
the <command>setuid</command> and <command>seteuid</command> calls which
are not part of the Windows API.
Nevertheless these calls are supported under Windows NT/W2K since Cygwin
release 1.1.3.  Because of the nature of NT security an application which
needs the ability has to be patched, though.</para>
d419 1
a419 1
<para>NT uses so-called `access tokens' to identify a user and it's
d421 1
a421 1
such an `access token'. This is typically done by calling the NT API
d565 1
a565 1
On NT and Windows 2000 the <systemitem
d567 1
a567 1
run services such as <command>sshd</command>. However, on Windows 2003
@


1.15
log
@
* ntsec.sgml: Add Pierre's Windows 2003 text.
@
text
@d1 1
a1 1
<sect1 id="ntsec"><title>NT security and usage of <literal>ntsec</literal></title>
d3 9
a11 4
<para>The setting of UNIX like object permissions is controlled by the 
<link linkend="using-cygwinenv"><envar>CYGWIN</envar> environment
variable</link> setting <literal>(no)ntsec</literal> which is set to
<literal>ntsec</literal> by default.</para>
d13 1
a13 7
<para>The design goal of <literal>ntsec</literal> is to get a more UNIX-like
permission structure based upon the security features of Windows NT.
To describe the changes, I will first give a short overview in
<xref linkend="ntsec-common"></xref>.
</para>
<para><link linkend="ntsec-processes" endterm="ntsec-processes.title"></link>
discusses the changes in ntsec related to privileges on processes.</para>
d15 2
a16 2
<para><link linkend="ntsec-files" endterm="ntsec-files.title"></link> shows
the basics of UNIX-like setting of file permissions.</para>
d18 3
a20 3
<para><link linkend="ntsec-sids" endterm="ntsec-sids.title"></link>
talks about using SIDs in <filename>/etc/passwd</filename> and
<filename>/etc/group</filename>.</para>
d22 11
a32 13
<para><link linkend="ntsec-mapping" endterm="ntsec-mapping.title"></link>
illustrates the permission mapping leak of Windows NT.</para>

<para><link linkend="ntsec-aclfuncs" endterm="ntsec-aclfuncs.title"></link>
describes in short the ACL API since release 1.1.</para>

<para><link linkend="ntsec-setuid" endterm="ntsec-setuid.title"></link>
describes the new support of a setuid concept introduced with release
1.1.3.</para>

<para><link linkend="ntsec-switch" endterm="ntsec-switch.title"></link>
gives the basics of using the SYSTEM user to switch user context.
</para>
d34 2
a35 3
<para><link linkend="ntsec-ids" endterm="ntsec-ids.title"></link>
explains the way Cygwin shows users and groups that are not in 
<filename>/etc/passwd</filename> or <filename>/etc/group</filename>.
d38 5
a42 14
<sect2 id="ntsec-common"><title>NT security</title>

<para>The NT security allows a process to allow or deny access of
different kind to `objects'. `Objects' are files, processes,
threads, semaphores, etc.</para>

<para>The main data structure of NT security is the `security descriptor'
(SD) structure. It explains the permissions, that are granted (or denied)
to an object and contains information, that is related to so called
`security identifiers' (SID).</para>

<para>A SID is a unique identifier for users, groups and domains. 
SIDs are comparable to UNIX UIDs and GIDs, but are more complicated
because they are unique across networks. Example:</para>
d44 1
a44 1
<para>SID of a system `foo':</para>
d50 1
a50 1
<para>SID of a user `johndoe' of the system `foo':</para>
d56 23
a78 11
<para>The above example shows the convention for printing SIDs. The leading
`S' should show that it is a SID. The next number is a version number which
is always 1. The next number is the so called `top-level authority' that
identifies the source that issued the SID.</para>

<para>While each system in a NT network has it's own SID, the situation
is modified in NT domains: The SID of the domain controller is the
base SID for each domain user. If an NT user has one account as domain
user and another account on his local machine, these accounts are under
any circumstances DIFFERENT, regardless of the usage of the same user
name and password!</para>
d80 1
a80 1
<para>SID of a domain `bar':</para>
d86 1
a86 1
<para>SID of a user `johndoe' in the domain `bar':</para>
d92 52
a143 28
<para>The last part of the SID, the so called `relative identifier' (RID),
is by default used as UID and/or GID under Cygwin. As the name and the
above example implies, this id is unique only relative to one system or
domain.</para>

<para>Note, that it's possible that a user has the same RID on two
different systems. The resulting SIDs are nevertheless different, so
the SIDs are representing different users in an NT network.</para>

<para>There is a big difference between UNIX IDs and NT SIDs: the existence of
the so called `well known groups'. For example UNIX has no GID for the
group of `all users'. NT has an SID for them, called `Everyone' in the
English versions. The SIDs of well-known groups are not unique across
an NT network but their meanings are unmistakable.
Examples of well-known groups:</para>

<screen>
everyone                        S-1-1-0
creator/owner                   S-1-3-0
batch process (via `at')        S-1-5-3
authenticated users             S-1-5-11
system                          S-1-5-18
</screen>

<para>The last important group of SIDs are the `predefined groups'. This
groups are used mainly on systems outside of domains to simplify the 
administration of user permissions. The corresponding SIDs are not unique
across the network so they are interpreted only locally:</para>
d152 17
a168 2
<para>Now, how are permissions given to objects? A process may assign an SD
to the object. The SD of an object consists of three parts:</para>
d171 3
a173 4
<listitem><para>the SID of the owner </para></listitem>
<listitem><para>the SID of the group </para></listitem>
<listitem><para>a list of SIDs with their permissions, called
`access control list' (ACL) </para></listitem>
d176 4
a179 17
<para>UNIX is able to create three different permissions, the permissions
for the owner, for the group and for the world. In contrast the ACL
has a potentially infinite number of members. Every member is a so called
`access control element' (ACE). An ACE contains three parts:</para>

<itemizedlist spacing="compact">
<listitem><para>the type of the ACE </para></listitem>
<listitem><para>permissions, described with a DWORD </para></listitem>
<listitem><para>the SID, for which the above mentioned permissions are
set </para></listitem>
</itemizedlist>

<!-- Is the historical note really important here? we're at version 1.5.9, after all.. -->
<para>The two important types of ACEs are the `access allowed ACE' and the
`access denied ACE'. The ntsec functionality only used `access allowed ACEs' up
to Cygwin version 1.1.0. Later versions also use `access denied ACEs' 
to reflect the UNIX permissions as well as possible.</para>
d182 4
a185 55
UNIX. For example, the permission to delete an object is different
from the write permission.</para>

<para>With the aforementioned method NT is able to grant or revoke permissions
to objects in a far more specific way. But what about cygwin? In a POSIX
environment it would be fine to have the security behavior of a POSIX
system. The NT security model is MOSTLY able to reproduce the POSIX model.
The ntsec method tries to do this in cygwin.</para>

<para>You ask "Mostly? Why mostly???" Because there's a leak in the NT model.
I will describe that in detail in chapter 5.</para>

<para>Creating  explicit object security is not that easy so you will often
see only two simple variations in use:</para>

<itemizedlist spacing="compact">
<listitem><para>default permissions, computed by the operating system </para></listitem>
<listitem><para>each permission to everyone </para></listitem>
</itemizedlist>

<para>For parameters to functions that create or open securable objects another
data structure is used, the `security attributes' (SA). This structure
contains an SD and a flag that specifies whether the returned handle
to the object is inherited to child processes or not.
This property is not important for ntsec so in
this document the difference between SDs and SAs is ignored.</para>

</sect2>

<sect2 id="ntsec-processes"><title id="ntsec-processes.title">Process privileges</title>

<para>Any process started under control of Cygwin has a semaphore attached
to it, that is used for signaling purposes. The creation of this semaphore
can be found in sigproc.cc, function `getsem'. The first parameter to the
function call `CreateSemaphore' is an SA. Without ntsec this SA 
assigns default security to the semaphore. There is a simple disadvantage:
Only the owner of the process may send signals to it. Or, in other words,
if the owner of the process is not a member of the administrators' group,
no administrator may kill the process! This is especially annoying, if
processes are started via service manager.</para>

<para>Ntsec now assigns an SA to the process control semaphore, that
has each permission set for the user of the process, for the
administrators' group and for `system', which is a synonym for the
operating system itself. The creation of this SA is done by the function
`sec_user', that can be found in `shared.cc'. Each member of the
administrators' group is now allowed to send signals to any process
created in Cygwin, regardless of the process owner.</para>

<para>Moreover, each process now has the appropriate security settings, when
it is started via `CreateProcess'. You will find this in function
`spawn_guts' in module `spawn.cc'. The security settings for starting a
process in another user context have to add the SID of the new user, too.
In the case of the `CreateProcessAsUser' call, sec_user creates an SA with
an additional entry for the sid of the new user.</para>
d191 5
a195 3
<para>If ntsec is turned on, file permissions are set as in UNIX. An SD is
assigned to the file containing the owner and group and ACEs for the
owner, the group and `Everyone'.</para>
d197 18
a214 6
<para>The complete settings of UNIX like permissions can be found in the file
`security.cc'. The two functions `get_nt_attribute' and `set_nt_attribute'
are the main code. The reading and writing of the SDs is done by the
functions `read_sd' and `write_sd'. `write_sd' uses the function `BackupRead'
instead of the simpler function `SetFileSecurity' because the latter is
unable to set owners different from the caller.</para>
d216 1
a216 2
<para>If you are creating a file `foo' outside of Cygwin, you will see something
like the following on <command>ls -ln</command>:</para>
d218 2
a219 1
<para>If your login is member of the administrators' group:</para>
d221 4
a224 5
  rwxrwxrwx 1  544  513  ... foo
</screen>
<para>if not:</para>
<screen>
  rwxrwxrwx 1  1000  513  ... foo
d226 1
d228 18
a245 23
<para>Note the user and group IDs. 544 is the UID of the administrators' group.
This is a `feature' <literal>:-P</literal> of WinNT. If you are a member of
the administrators' group, every file that you create is owned by the
administrators' group, instead of by you.</para>

<para>The second example shows the UID of the first user, that has been
created with NT's the user administration tool. The users and groups are
sequentially numbered, starting with 1000. Users and groups are using the
same numbering scheme, so a user and a group don't share the same ID.</para>

<para>In both examples the GID 513 is of special interest. This GID is a
well known group with different naming in local systems and domains.
Outside of domains the group is named 'None' (`Kein' in German, `Aucun'
in French, etc.), in domains it is named 'Domain Users'.  Unfortunately,
the group `None' is never shown in the user admin tool outside of domains!
This is very confusing but this seems to have no negative consequences.</para>

<para>To work correctly, ntsec depends on the files
<filename>/etc/passwd</filename> and <filename>/etc/group</filename>.
In Cygwin release 1.0 the names and the IDs must correspond to the
appropriate NT IDs! The IDs used in Cygwin are the RID of the NT SID, as
mentioned earlier.
A SID of e.g. the user `corinna' on my NT workstation:</para>
d247 2
d250 2
a251 1
  S-1-5-21-165875785-1005667432-441284377-1000
d253 1
d255 14
a268 10
<para>Note the last number: It's the RID 1000, Cygwin's UID.</para>

<para>Unfortunately, workstations and servers outside of domains are not
able to set primary groups! In these cases, where there is no correlation
of users to primary groups, NT returns 513 (None) as primary group,
regardless of the membership to existing local groups.</para>

<para>When using <command>mkpasswd  -l -g</command> on such systems, you
have to change the primary group by hand if `None' as primary group is
not what you want (and I'm sure, it's not what you want!)</para>
d270 2
a271 7
<para>Look at the following examples, which were parts of my files before
storing SIDs in /etc/passwd and /etc/group had been introduced (See next
chapter for details).  With the exception of my personal user entry, all
entries are well known entries.</para> 

<example>
<title>/etc/passwd</title>
d273 1
a273 6
everyone:*:0:0:::
system:*:18:18:::
administrator::500:544::/home/root:/bin/bash
guest:*:501:546:::
administrators:*:544:544::/home/root:
corinna::1000:547:Corinna Vinschen:/home/corinna:/bin/tcsh
d277 11
a287 12
<example>
<title>/etc/group</title>
<screen>
everyone::0:
system::18:
none::513:
administrators::544:
users::545:
guests::546:
powerusers::547:
</screen>
</example>
a311 8
<para>In Cygwin release 1.1 a new technique of using the 
<filename>/etc/passwd</filename> and <filename>/etc/group</filename>
 was introduced.</para>

<para>Both files may now contain SIDs of users and groups. They
are saved in the last field of pw_gecos in <filename>/etc/passwd</filename>
and in the gr_passwd field in <filename>/etc/group</filename>.</para>

d352 1
a352 1
<example>
d359 1
a359 1
<example>
a375 8
<para>As aforementioned you are able to use Cygwin account names different
from the NT account names. If you want to login through `telnet' or something
else you have to use the special <command>login</command>. You may then
add another field to pw_gecos which contains the NT user name including
it's domain. So you are able to login as each domain user. The syntax
is easy: Just add an entry of the form U-ntdomain\ntusername to the pw_gecos
field. Note that the SID must still remain the last field in pw_gecos!</para>

d395 1
a395 1
<example>
d406 1
a406 1
<example>
d559 1
a559 1
<para>UNIX applications which have to switch the user context are using
@


1.14
log
@	* .sgml: Cleanup markup for XML validity.
@
text
@d740 4
a743 2
Since Cygwin release 1.3.3, applications having the
<command>Create a process level token</command> user right can switch user
d746 1
a746 4
<command>setgid</command> and <command>setegid</command> functions.  This is
typically only given to the SYSTEM user. However, this now allows to switch
the user context using e. g. rhosts authentication or (when running sshd
under SYSTEM account as service) public key authentication.
d749 18
a766 5
An important restriction of this method is that a process started under
SYSTEM account can't access network shares which require authentication.
This also applies to the subprocesses which switched the user context 
without a password.  People using network home drives are typically not
able to access it when trying to login using ssh or rsh without password.
@


1.13
log
@
2004-03-30  Joshua Daniel Franklin  <joshuadfranklin@@yahoo.com>

        * ntsec.sgml: Replace chapter numbers with <link>s,
        replace release-numbers in <title>s with descriptions.

2004-03-30  Ronald Landheer-Cieslak <ronald@@landheer.com>

        * ntsec.sgml: Fix typos, correct chapter numbers.
@
text
@d4 1
a4 1
<link linkend="using-cygwinenv"><EnVar>CYGWIN</EnVar> environment
d11 1
a11 1
<xref linkend="ntsec-common">.
@


1.12
log
@
2004-01-24  Joshua Daniel Franklin  <joshuadfranklin@@yahoo.com>
	* cygwinenv.sgml: Cleanup minor markup problems.
	* dll.sgml: Cleanup minor markup problems.
	* effectively.sgml: Cleanup minor markup problems.
	* gcc.sgml: Cleanup minor markup problems.
	* ntsec.sgml: Cleanup minor markup problems.
	* pathnames.sgml: Cleanup minor markup problems.
	* setup-net.sgml: Cleanup minor markup problems.
	* textbinary.sgml: Cleanup minor markup problems.
	* windres.sgml: Cleanup minor markup problems.
@
text
@d1 1
a1 1
<sect1 id="ntsec"><title>NT security and the <literal>ntsec</literal> usage</title>
d3 6
a8 1
<para>The design goal of ntsec is to get a more UNIX like
d10 8
a17 11
To describe the changes, I will give a short overview of NT security
in chapter one.</para>
<para>Chapter two discusses the changes in ntsec related to privileges on
processes.</para>
<para>Chapter three shows the basics of UNIX like setting of
file permissions.</para>
<para>Chapter four talks about the advanced settings introduced in
release 1.1</para>
<para>Chapter five illustrates the permission mapping leak of Windows NT.</para>
<para>Chapter six describes the new support of a setuid concept introduced
with release 1.1.3.</para>
d19 3
a21 1
<para>Chapter six describes in short the new acl API since release 1.1</para>
d23 18
a40 2
<para>The setting of UNIX like object permissions is controlled by the new
<EnVar>CYGWIN</EnVar> variable setting <literal>(no)ntsec</literal>.</para>
d77 1
a77 1
user and another account on his local machine, this accounts are under
d94 1
a94 1
is by default used as UID and/or GID under cygwin. As the name and the
d98 1
a98 1
<para>Note, that it's possible, that an user has the same RID on two
d102 1
a102 1
<para>There is a big difference between UNIX IDs and NT SIDs, the existence of
d151 1
d168 1
a168 1
I will describe that in detail in chapter 4.</para>
d187 1
a187 1
<sect2 id="ntsec-processes"><title>Process privileges</title>
d189 1
a189 1
<para>Any process started under control of cygwin has a semaphore attached
d205 1
a205 1
created in cygwin, regardless of the process owner.</para>
d210 1
a210 1
process in another user context have to add the sid of the new user, too.
d216 1
a216 1
<sect2 id="ntsec-files"><title>File permissions</title>
d229 1
a229 1
<para>If you are creating a file `foo' outside of cygwin, you will see something
d242 3
a244 3
This is a `feature' <literal>:-P</literal> of WinNT. If one is a member of
the administrators' group, every file, that he has created is owned by the
administrators' group, instead by him.</para>
d259 3
a261 3
<filename>/etc/passwd/</filename> and <filename>/etc/group</filename>.
In cygwin release 1.0 the names and the IDs must correspond to the
appropriate NT IDs! The IDs used in cygwin are the RID of the NT SID, as
d263 1
a263 1
An SID of e.g. the user `corinna' on my NT workstation:</para>
d269 1
a269 1
<para>Note the last number: It's the RID 1000, the cygwin's UID.</para>
d316 1
d321 1
a321 1
owners with cygwin's <command>chown</command>.</para></listitem>
d325 2
a326 2
itself and is normally the owner of processes, that are started through
service manager. The same is true for files, that are created by
d331 1
a331 1
<sect2 id="ntsec-release1.1"><title>New since Cygwin release 1.1</title>
d335 1
a335 1
 is introduced.</para>
d345 3
a347 3
cygwin than their NT account name. The name in <filename>/etc/passwd</filename>
or <filename>/etc/group</filename> is transparently used by cygwin
applications (eg. <command>chown</command>, <command>chmod</command>,
d403 1
a403 1
is defined as a comma seperated list. The SID has to be the last field!</para>
d405 2
a406 2
<para>As aforementioned you are able to use cygwin account names different
from the NT account names. If you want to login thru `telnet' or something
d466 1
a466 1
created by mkpasswd and mkgroup.  Especially don't change the uid or the name
d468 2
a469 1
as local service under that account could behave strangly suddenly.</para>
d473 1
a473 1
<sect2 id="ntsec-mapping"><title>The mapping leak</title>
d489 1
a489 1
not modified to get the ACEs in the prefered order.</para>
d535 1
a535 1
not write anymore, too. How should this problem be solved? According to
d554 1
a554 1
<sect2 id="ntsec-aclfuncs"><title>New acl API</title>
d556 1
a556 1
<para>For dealing with ACLs Cygwin now has the acl API as it's
d570 1
a570 1
for read, write and execute as in the file mode. If eg. read permission
d589 2
a590 2
<para>Online man pages for the aforementioned commands and API calls
can be found on eg. http://docs.sun.com</para>
d594 1
a594 1
<sect2 id="ntsec-setuid"><title>New setuid concept</title>
d603 1
a603 1
<para>NT uses so called `access tokens' to identify a user and it's
d681 1
a681 1
<para>The new Cygwin call to retrive an access token is defined as follows:</para>
d692 1
a692 1
logons and remeber the access tokens for further calls to the second function.</para>
d704 2
a705 2
While you need always the correct access token to do a
<command>setuid</command>/<command>seteuid</command> to another users context,
d736 2
a737 1
<sect2 id="ntsec-release1.3.3"><title>New since Cygwin release 1.3.3</title>
d750 1
a750 1
An important restriction of this method is, that a process started under
d759 1
a759 1
<sect2 id="ntsec-release1.3.20"><title>Special values of user and group
@


1.11
log
@ntsec patch
@
text
@d608 1
a608 1

d611 2
a612 2
#include &lt;windows.h&gt;
#include &lt;sys/cygwin.h&gt;
d644 1
a644 1
        strcmp (hashed_password, user_pwd_entry-&gt;pw_password))
d651 2
a652 2
  setegid (user_pwd_entry-&gt;pw_gid);
  seteuid (user_pwd_entry-&gt;pw_uid);
d654 1
@


1.10
log
@	* ntsec.sgml: Add note on special names for missing user/group.
@
text
@d3 1
a3 1
<para>The design goal of the ntsec patch was to get a more UNIX like
d132 1
a132 1
`access denied ACE'. The ntsec patch only used `access allowed ACEs' up
d144 1
a144 1
The ntsec patch tries to do this in cygwin.</para>
d161 1
a161 1
This property is not important for the ntsec patch description so in
d171 1
a171 1
function call `CreateSemaphore' is an SA. Without ntsec patch this SA 
d178 1
a178 1
<para>The ntsec patch now assigns an SA to the process control semaphore, that
d237 1
a237 1
<para>To work correctly the ntsec patch depends on the files
@


1.9
log
@* ntsec.sgml: Correct some minor grammatical errors.
@
text
@d734 63
@


1.8
log
@	* ntsec.html: Add chapter for switching user context w/o password.
@
text
@d133 2
a134 2
to Cygwin version 1.1.0. Later versions use `access denied ACEs' as well
to reflect the UNIX permissions as good as possible.</para>
d235 1
a235 1
This is very confusing but it seems that this has no negativ influences.</para>
d237 1
a237 1
<para>To work correctly the ntsec patch depends on reasoned files
d260 1
a260 1
storing SIDs in /etc/passwd and /etc/group has been introduced (See next
d289 2
a290 2
<para>As you can see, I've changed my primary group membership from 513 (None)
to 547 (powerusers).  So all file I created inside of Cygwin were now owned
d297 1
a297 1
<command>ls -l</command> is often better readable.</para></listitem>
d596 2
a597 1
<para>Note that administrators do not have all that user rights set by default.</para>
d601 1
a601 1
have to care to give Cygwin the right access token and then you can call
@


1.7
log
@* dll.sgml: Refine dll build instructions.
* ntsec.html: Correct some typos.
@
text
@a413 1
Everyone:*:1:1:,S-1-1-0::
a424 1
everyone:S-1-1-0:1:
d708 22
@


1.6
log
@	* ntsec.sgml: Clean up text for examples of /etc/passwd and /etc/group.
	Add examples with SIDs.  Warn about changing them crudely.
@
text
@d289 1
a289 1
<para>As you can see I've changed my primary group membership from 513 (None)
d291 1
a291 1
by the powerusers group instead of None.  This is the way I liked it.<para>
@


1.5
log
@        * ntsec.sgml: Slight changes. Fix some errors.
@
text
@d255 1
a255 1
<para>when using <command>mkpasswd  -l -g</command> on such systems, you
d259 5
a263 5
<para>To get help in creating correct passwd and group files, look at
the following examples, that are part of my files. With the exception
of my personal user entry, all entries are well known entries. For a
better understanding, the names are translated to the equivalents of the
English NT version.</para> 
d289 4
d377 2
a378 2
the options <literal>-s</literal> or <literal>--no-sids</literal>. In this
case ntsec behaves like the previous version.</para>
d401 1
a401 1
<para>In each case the password of the user is taken from the NT user
d403 46
@


1.4
log
@        * ntsec.sgml: Changed the (now incorrect) hint that ntsec only
	uses access allowed ACEs.
@
text
@d136 1
a136 1
<para>The possible permissions on objects are more complicated than in
d148 3
a150 2
<para>The creation of explicit object security is a bit complicated, so
typically only two simple variations are used:</para>
d159 4
a162 4
contains an SD and a flag, that specifies whether the returned handle
to the created or opened object is inherited to child processes or not.
This property is not important for the ntsec patch description, so in
this document SDs and SAs are more or less identical.</para>
d319 1
a319 1
cygwin that their NT account name. The name in <filename>/etc/passwd</filename>
d336 2
a337 2
you have to use a special version of <command>login</command> which will
be part of the release 1.1 soon.</para></listitem>
d412 1
a412 1
<listitem><para>ALl access denied ACEs _should_ precede any
@


1.3
log
@        * ntsec.sgml: Add description for the new setuid ability
        of Cygwin since release 1.1.3.
        * overview2.sgml: Add description for new chroot functionality.
        * calls.texinfo: Add missing calls. Change comments for
        setuid, setgid, seteuid, setegid, chroot.
@
text
@d132 3
a134 1
`access denied ACE'. The ntsec patch only uses `access allowed ACEs'.</para>
@


1.2
log
@        * ntsec.sgml: Revisited description of `ntsec' according to
        the changes in release 1.1.
        * setup.sgml: Include ntsec.
        * setup-net.sgml: Ditto.
@
text
@d14 2
d20 1
a20 2
<EnVar>CYGWIN</EnVar> variable setting <literal>(no)ntsec</literal>.
On NT ntsec is now turned on by default.</para>
d517 140
@


1.1
log
@Initial revision
@
text
@d1 1
a1 2

<sect1 id="ntsec"><title>NTSEC Documentation</title>
d9 7
a15 1
<para>Chapter three shows the UNIX like setting of file permissions.</para>
d18 2
a19 3
<EnVar>CYGWIN</EnVar> variable setting <literal>(no)ntsec</literal>.</para>

<para>On NT ntsec is now turned on by default.</para>
d32 1
a32 1
<para>An SID is a unique identifier for users, groups and domains. 
d36 2
a37 1
<example>
a38 2
SID of a system `foo':

d40 1
d42 1
a42 1
SID of a user `johndoe' of the system `foo':
d44 1
a46 1
</example>
d60 2
a61 1
<example>
a62 2
SID of a domain `bar':

d64 1
d66 1
a66 1
SID of a user `johndoe' in the domain `bar':
d68 1
a70 1
</example>
d73 3
a75 2
is used as UID and/or GID under cygwin. As the name and the above example
implies, this id is unique only relative to one system or domain.</para>
a88 1
<example>
a94 1
</example>
a101 1
<example>
a106 1
</example>
d112 3
a114 3
<listitem><para>- the SID of the owner </para></listitem>
<listitem><para>- the SID of the group </para></listitem>
<listitem><para>- a list of SIDs with their permissions, called
d124 3
a126 3
<listitem><para>- the type of the ACE </para></listitem>
<listitem><para>- permissions, described with a DWORD </para></listitem>
<listitem><para>- the SID, for which the above mentioned permissions are
d140 1
a140 1
system. The NT security model is able to reproduce the POSIX model.
d143 2
d149 2
a150 2
<listitem><para>- default permissions, computed by the operating system </para></listitem>
<listitem><para>- each permission to everyone </para></listitem>
d195 1
a195 12
owner, the group and `Everyone'. If the group of the file is not the
administrators' group, the administrators' group gets the permissions
to read the permissions (yes, this is an own permission flag
<literal>:-)</literal>) and to take the ownership on this file.
If the file's group is the administrators group itself, this behaviour
is modified to support the typical behaviour of NT better:
As you know, if one is member of admin group, all her files are owned
by the group instead of by her. This is not the case with ntsec but the
other admins should have easier access to the administrative files.
So in this case the admin group gets additionally the permissions to
write permissions and to write extended attributes, also in the case
where group permissions are set to 0.</para>
d200 3
a202 8
functions `ReadSD' and `WriteSD'. They are using the Backup API functions
`BackupRead' and `BackupWrite', that have the advantage not to crash,
if they are used on non NTFS file systems! These crashes are the default
behavior of the security API, if it's used on, e.g., FAT or SAMBA
file systems <literal>:-(</literal></para>

<para>Unfortunately, the settings of NT file security are only available
on NTFS. SAMBA doesn't support them.</para>
d235 3
a237 2
The names and the IDs must correspond to the appropriate
NT IDs! The IDs used in cygwin are the RID of the NT SID, as aforementioned.
a239 1
<example>
a242 1
</example>
d249 1
a249 1
regardless of the membership to regular groups of these users.</para>
d259 1
a259 2
English NT version:</para>

d261 1
a261 1
<title>/etc/passwd:</title>
d273 1
a273 1
<title>/etc/group:</title>
d288 4
a291 4
<listitem><para>- Because NT assigns them to files as owners, a
<command>ls -l</command> is often better readable. </para></listitem>
<listitem><para>- Moreover it's possible to assigned them to files as
owners with cygwin's <command>chown</command>. </para></listitem>
d298 218
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
