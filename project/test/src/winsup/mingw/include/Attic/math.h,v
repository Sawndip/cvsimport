head	1.38;
access;
symbols
	cygwin-1_7_17-release:1.37
	cygwin-64bit-branch:1.37.0.2
	cygwin-1_7_16-release:1.37
	cygwin-1_7_15-release:1.37
	cygwin-1_7_14_2-release:1.37
	cygwin-1_7_14-release:1.37
	cygwin-1_7_12-release:1.37
	cygwin-1_7_11-release:1.37
	cygwin-1_7_10-release:1.37
	cygwin-1_7_9-release:1.37
	cygwin-1_7_8-release:1.37
	cygwin-1_7_7-release:1.37
	cygwin-1_7_5-release:1.37
	cygwin-1_7_4-release:1.37
	cygwin-1_7_3-release:1.37
	cygwin-1_7_2-release:1.37
	cygwin-1_7_1-release:1.37
	cv-branch-2:1.35.0.2
	cr-0x5f1:1.32.0.4
	cv-branch:1.32.0.2
	cr-0x3b58:1.30.0.2
	cr-0x9e:1.17.0.4
	cr-0x9d:1.17.0.2
	corinna-01:1.17
	cr-0x9c:1.14.0.6
	cr-0x9b:1.14.0.4
	cr-0x99:1.14
	Z-emcb-cygwin_daemon:1.14.0.2
	w32api-2_2:1.11
	mingw-runtime-2_4:1.11
	mingw-std-ns-branch:1.6.0.2
	mingw-runtime-2_0:1.4
	mingwex:1.2.0.10
	cygnus_cvs_20020108_pre:1.2
	Z-cygwin_daemon_merge-new_HEAD:1.1.1.1
	Z-cygwin_daemon_merge_HEAD:1.1.1.1
	cygwin_daemon:1.1.1.1.0.10;
locks; strict;
comment	@ * @;
expand	@o@;


1.38
date	2012.11.07.16.52.16;	author cgf;	state dead;
branches;
next	1.37;

1.37
date	2009.08.08.13.26.11;	author ironhead;	state Exp;
branches;
next	1.36;

1.36
date	2009.07.18.15.19.03;	author ironhead;	state Exp;
branches;
next	1.35;

1.35
date	2008.10.13.22.47.58;	author keithmarshall;	state Exp;
branches;
next	1.34;

1.34
date	2008.03.21.12.48.22;	author ironhead;	state Exp;
branches;
next	1.33;

1.33
date	2007.10.03.18.55.56;	author ironhead;	state Exp;
branches;
next	1.32;

1.32
date	2006.07.06.07.36.58;	author dannysmith;	state Exp;
branches;
next	1.31;

1.31
date	2006.06.12.22.22.18;	author dannysmith;	state Exp;
branches;
next	1.30;

1.30
date	2005.09.24.01.26.24;	author dannysmith;	state Exp;
branches;
next	1.29;

1.29
date	2005.06.16.11.41.49;	author dannysmith;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.10.08.39.05;	author dannysmith;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.09.09.36.08;	author dannysmith;	state Exp;
branches;
next	1.26;

1.26
date	2005.05.08.08.07.18;	author dannysmith;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.03.08.39.18;	author dannysmith;	state Exp;
branches;
next	1.24;

1.24
date	2005.02.11.04.15.16;	author dannysmith;	state Exp;
branches;
next	1.23;

1.23
date	2004.10.06.20.31.32;	author dannysmith;	state Exp;
branches;
next	1.22;

1.22
date	2004.07.15.11.39.15;	author dannysmith;	state Exp;
branches;
next	1.21;

1.21
date	2004.07.02.10.01.51;	author dannysmith;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.20.22.49.32;	author earnie;	state Exp;
branches;
next	1.19;

1.19
date	2004.03.29.13.57.04;	author infidel;	state Exp;
branches;
next	1.18;

1.18
date	2004.03.26.11.30.23;	author dannysmith;	state Exp;
branches;
next	1.17;

1.17
date	2003.10.27.23.51.37;	author dannysmith;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.21.09.14.45;	author dannysmith;	state Exp;
branches;
next	1.15;

1.15
date	2003.09.24.00.41.01;	author dannysmith;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.14.01.03.20;	author dannysmith;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.10.23.56.03;	author dannysmith;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.10.21.13.34;	author dannysmith;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.26.07.04.04;	author dannysmith;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.08.01.46.41;	author dannysmith;	state Exp;
branches;
next	1.9;

1.9
date	2002.12.07.08.58.49;	author dannysmith;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.27.03.41.25;	author dannysmith;	state Exp;
branches;
next	1.7;

1.7
date	2002.11.09.10.44.01;	author dannysmith;	state Exp;
branches;
next	1.6;

1.6
date	2002.08.20.23.26.11;	author dannysmith;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2002.07.29.03.00.08;	author dannysmith;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.13.10.20.43;	author dannysmith;	state Exp;
branches;
next	1.3;

1.3
date	2002.04.04.08.54.50;	author dannysmith;	state Exp;
branches;
next	1.2;

1.2
date	2001.12.05.15.01.05;	author earnie;	state Exp;
branches
	1.2.10.1;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;

1.2.10.1
date	2002.03.22.22.35.38;	author dannysmith;	state Exp;
branches;
next	1.2.10.2;

1.2.10.2
date	2002.04.04.09.24.39;	author dannysmith;	state Exp;
branches;
next	1.2.10.3;

1.2.10.3
date	2002.04.16.09.02.27;	author dannysmith;	state Exp;
branches;
next	1.2.10.4;

1.2.10.4
date	2002.04.24.04.14.01;	author dannysmith;	state Exp;
branches;
next	1.2.10.5;

1.2.10.5
date	2002.04.25.21.47.49;	author dannysmith;	state Exp;
branches;
next	1.2.10.6;

1.2.10.6
date	2002.04.26.01.32.09;	author dannysmith;	state Exp;
branches;
next	1.2.10.7;

1.2.10.7
date	2002.06.10.23.26.56;	author dannysmith;	state Exp;
branches;
next	;

1.6.2.1
date	2002.09.20.06.26.37;	author dannysmith;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2002.10.02.04.38.37;	author dannysmith;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2002.10.03.20.43.38;	author dannysmith;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2002.12.10.10.48.19;	author dannysmith;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2003.01.26.22.37.50;	author dannysmith;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2003.03.31.22.32.19;	author dannysmith;	state Exp;
branches;
next	;


desc
@@


1.38
log
@* mingw: Delete obsolete directory.
* w32api: Ditto.
@
text
@/* 
 * math.h
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is a part of the mingw-runtime package.
 * No warranty is given; refer to the file DISCLAIMER within the package.
 *
 * Mathematical functions.
 *
 */


#ifndef _MATH_H_
#define _MATH_H_

#if __GNUC__ >= 3
#pragma GCC system_header
#endif

/* All the headers include this file. */
#include <_mingw.h>

/*
 * Types for the _exception structure.
 */

#define	_DOMAIN		1	/* domain error in argument */
#define	_SING		2	/* singularity */
#define	_OVERFLOW	3	/* range overflow */
#define	_UNDERFLOW	4	/* range underflow */
#define	_TLOSS		5	/* total loss of precision */
#define	_PLOSS		6	/* partial loss of precision */

/*
 * Exception types with non-ANSI names for compatibility.
 */

#ifndef	__STRICT_ANSI__
#ifndef	_NO_OLDNAMES

#define	DOMAIN		_DOMAIN
#define	SING		_SING
#define	OVERFLOW	_OVERFLOW
#define	UNDERFLOW	_UNDERFLOW
#define	TLOSS		_TLOSS
#define	PLOSS		_PLOSS

#endif	/* Not _NO_OLDNAMES */
#endif	/* Not __STRICT_ANSI__ */


/* Traditional/XOPEN math constants (double precison) */
#ifndef __STRICT_ANSI__
#define M_E		2.7182818284590452354
#define M_LOG2E		1.4426950408889634074
#define M_LOG10E	0.43429448190325182765
#define M_LN2		0.69314718055994530942
#define M_LN10		2.30258509299404568402
#define M_PI		3.14159265358979323846
#define M_PI_2		1.57079632679489661923
#define M_PI_4		0.78539816339744830962
#define M_1_PI		0.31830988618379067154
#define M_2_PI		0.63661977236758134308
#define M_2_SQRTPI	1.12837916709551257390
#define M_SQRT2		1.41421356237309504880
#define M_SQRT1_2	0.70710678118654752440
#endif

/* These are also defined in Mingw float.h; needed here as well to work 
   around GCC build issues.  */
#ifndef	__STRICT_ANSI__
#ifndef __MINGW_FPCLASS_DEFINED
#define __MINGW_FPCLASS_DEFINED 1
/* IEEE 754 classication */
#define	_FPCLASS_SNAN	0x0001	/* Signaling "Not a Number" */
#define	_FPCLASS_QNAN	0x0002	/* Quiet "Not a Number" */
#define	_FPCLASS_NINF	0x0004	/* Negative Infinity */
#define	_FPCLASS_NN	0x0008	/* Negative Normal */
#define	_FPCLASS_ND	0x0010	/* Negative Denormal */
#define	_FPCLASS_NZ	0x0020	/* Negative Zero */
#define	_FPCLASS_PZ	0x0040	/* Positive Zero */
#define	_FPCLASS_PD	0x0080	/* Positive Denormal */
#define	_FPCLASS_PN	0x0100	/* Positive Normal */
#define	_FPCLASS_PINF	0x0200	/* Positive Infinity */
#endif /* __MINGW_FPCLASS_DEFINED */
#endif	/* Not __STRICT_ANSI__ */

#ifndef RC_INVOKED

#ifdef __cplusplus
extern "C" {
#endif

/*
 * HUGE_VAL is returned by strtod when the value would overflow the
 * representation of 'double'. There are other uses as well.
 *
 * __imp__HUGE is a pointer to the actual variable _HUGE in
 * MSVCRT.DLL. If we used _HUGE directly we would get a pointer
 * to a thunk function.
 *
 * NOTE: The CRTDLL version uses _HUGE_dll instead.
 */

#if __MINGW_GNUC_PREREQ(3, 3)
#define	HUGE_VAL __builtin_huge_val()
#else

#ifndef __DECLSPEC_SUPPORTED

#ifdef __MSVCRT__
extern double*	_imp___HUGE;
#define	HUGE_VAL	(*_imp___HUGE)
#else
/* CRTDLL */
extern double*	_imp___HUGE_dll;
#define	HUGE_VAL	(*_imp___HUGE_dll)
#endif

#else /* __DECLSPEC_SUPPORTED */

#ifdef __MSVCRT__
__MINGW_IMPORT double	_HUGE;
#define	HUGE_VAL	_HUGE
#else
/* CRTDLL */
__MINGW_IMPORT double	_HUGE_dll;
#define	HUGE_VAL	_HUGE_dll
#endif

#endif /* __DECLSPEC_SUPPORTED */
#endif /* __MINGW_GNUC_PREREQ(3, 3) */


struct _exception
{
	int	type;
	char	*name;
	double	arg1;
	double	arg2;
	double	retval;
};

_CRTIMP double __cdecl sin (double);
_CRTIMP double __cdecl cos (double);
_CRTIMP double __cdecl tan (double);
_CRTIMP double __cdecl sinh (double);
_CRTIMP double __cdecl cosh (double);
_CRTIMP double __cdecl tanh (double);
_CRTIMP double __cdecl asin (double);
_CRTIMP double __cdecl acos (double);
_CRTIMP double __cdecl atan (double);
_CRTIMP double __cdecl atan2 (double, double);
_CRTIMP double __cdecl exp (double);
_CRTIMP double __cdecl log (double);
_CRTIMP double __cdecl log10 (double);
_CRTIMP	double __cdecl pow (double, double);
_CRTIMP double __cdecl sqrt (double);
_CRTIMP double __cdecl ceil (double);
_CRTIMP double __cdecl floor (double);
_CRTIMP double __cdecl fabs (double);
_CRTIMP double __cdecl ldexp (double, int);
_CRTIMP double __cdecl frexp (double, int*);
_CRTIMP double __cdecl modf (double, double*);
_CRTIMP double __cdecl fmod (double, double);

/* Excess precision when using a 64-bit mantissa for FPU math ops can
   cause unexpected results with some of the MSVCRT math functions.  For
   example, unless the function return value is stored (truncating to
   53-bit mantissa), calls to pow with both x and y as integral values
   sometimes produce a non-integral result.
   One workaround is to reset the FPU env to 53-bit mantissa
   by a call to fesetenv (FE_PC53_ENV).  Amother is to force storage
   of the return value of individual math functions using wrappers.
   NB, using these wrappers will disable builtin math functions and
   hence disable the folding of function results at compile time when
   arguments are constant.  */

#if 0
#define __DEFINE_FLOAT_STORE_MATHFN_D1(fn1)	\
static __inline__ double			\
__float_store_ ## fn1 (double x)		\
{						\
   __volatile__ double res = (fn1) (x);		\
  return res;					\
}

#define __DEFINE_FLOAT_STORE_MATHFN_D2(fn2)	\
static __inline__ double			\
__float_store_ ## fn2 (double x, double y)	\
{						\
  __volatile__ double res = (fn2) (x, y);	\
  return res;					\
}
#endif

/* For example, here is how to force the result of the pow function
   to be stored:   */
#if 0
#undef pow
/* Define the ___float_store_pow function and use it instead of pow().  */
__DEFINE_FLOAT_STORE_MATHFN_D2 (pow)
#define pow __float_store_pow
#endif

#ifndef __STRICT_ANSI__

/* Complex number (for _cabs). This is the MS version. The ISO
   C99 counterpart _Complex is an intrinsic type in GCC and
   'complex' is defined as a macro.  See complex.h  */
struct _complex
{
	double	x;	/* Real part */
	double	y;	/* Imaginary part */
};

_CRTIMP double __cdecl _cabs (struct _complex);

_CRTIMP double __cdecl _hypot (double, double);
_CRTIMP double __cdecl _j0 (double);
_CRTIMP double __cdecl _j1 (double);
_CRTIMP double __cdecl _jn (int, double);
_CRTIMP double __cdecl _y0 (double);
_CRTIMP double __cdecl _y1 (double);
_CRTIMP double __cdecl _yn (int, double);
_CRTIMP int __cdecl _matherr (struct _exception *);

/* These are also declared in Mingw float.h; needed here as well to work 
   around GCC build issues.  */
/* BEGIN FLOAT.H COPY */
/*
 * IEEE recommended functions
 */

_CRTIMP double __cdecl _chgsign (double);
_CRTIMP double __cdecl _copysign (double, double);
_CRTIMP double __cdecl _logb (double);
_CRTIMP double __cdecl _nextafter (double, double);
_CRTIMP double __cdecl _scalb (double, long);

_CRTIMP int __cdecl _finite (double);
_CRTIMP int __cdecl _fpclass (double);
_CRTIMP int __cdecl _isnan (double);

/* END FLOAT.H COPY */


/*
 * Non-underscored versions of non-ANSI functions.
 * These reside in liboldnames.a.
 */

#if !defined (_NO_OLDNAMES)

_CRTIMP double __cdecl j0 (double);
_CRTIMP double __cdecl j1 (double);
_CRTIMP double __cdecl jn (int, double);
_CRTIMP double __cdecl y0 (double);
_CRTIMP double __cdecl y1 (double);
_CRTIMP double __cdecl yn (int, double);

_CRTIMP double __cdecl chgsign (double);
/*
 * scalb() is a GCC built-in.
 * Exclude this _scalb() stub; the semantics are incompatible
 * with the built-in implementation.
 *
_CRTIMP double __cdecl scalb (double, long);
 *
 */
_CRTIMP int __cdecl finite (double);
_CRTIMP int __cdecl fpclass (double);

#define FP_SNAN    _FPCLASS_SNAN
#define FP_QNAN    _FPCLASS_QNAN
#define FP_NINF    _FPCLASS_NINF
#define FP_PINF    _FPCLASS_PINF
#define FP_NDENORM _FPCLASS_ND
#define FP_PDENORM _FPCLASS_PD
#define FP_NZERO   _FPCLASS_NZ
#define FP_PZERO   _FPCLASS_PZ
#define FP_NNORM   _FPCLASS_NN
#define FP_PNORM   _FPCLASS_PN

#endif /* Not _NO_OLDNAMES */

/* This require msvcr70.dll or higher. */ 
#if __MSVCRT_VERSION__ >= 0x0700
_CRTIMP int __cdecl _set_SSE2_enable (int);
#endif /* __MSVCRT_VERSION__ >= 0x0700 */


#endif /* __STRICT_ANSI__ */


#ifndef __NO_ISOCEXT
#if (defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) \
	|| !defined __STRICT_ANSI__ || defined __cplusplus

#if __MINGW_GNUC_PREREQ(3, 3)
#define HUGE_VALF	__builtin_huge_valf()
#define HUGE_VALL	__builtin_huge_vall()
#define INFINITY	__builtin_inf()
#define NAN		__builtin_nan("")
#else
extern const float __INFF;
#define HUGE_VALF __INFF
extern const long double  __INFL;
#define HUGE_VALL __INFL
#define INFINITY HUGE_VALF
extern const double __QNAN;
#define NAN __QNAN
#endif /* __MINGW_GNUC_PREREQ(3, 3) */

/* Use the compiler's builtin define for FLT_EVAL_METHOD to
   set float_t and double_t.  */
#if defined(__FLT_EVAL_METHOD__)  
# if ( __FLT_EVAL_METHOD__== 0)
typedef float float_t;
typedef double double_t;
# elif (__FLT_EVAL_METHOD__ == 1)
typedef double float_t;
typedef double double_t;
# elif (__FLT_EVAL_METHOD__ == 2)
typedef long double float_t;
typedef long double double_t;
#endif
#else /* ix87 FPU default */
typedef long double float_t;
typedef long double double_t;
#endif

/* 7.12.3.1 */
/*
   Return values for fpclassify.
   These are based on Intel x87 fpu condition codes
   in the high byte of status word and differ from
   the return values for MS IEEE 754 extension _fpclass()
*/
#define FP_NAN		0x0100
#define FP_NORMAL	0x0400
#define FP_INFINITE	(FP_NAN | FP_NORMAL)
#define FP_ZERO		0x4000
#define FP_SUBNORMAL	(FP_NORMAL | FP_ZERO)
/* 0x0200 is signbit mask */


/*
  We can't inline float or double, because we want to ensure truncation
  to semantic type before classification. 
  (A normal long double value might become subnormal when 
  converted to double, and zero when converted to float.)
*/

extern int __cdecl __fpclassifyf (float);
extern int __cdecl __fpclassify (double);
extern int __cdecl __fpclassifyl (long double);

#ifndef __NO_INLINE__
__CRT_INLINE int __cdecl __fpclassifyl (long double x){
  unsigned short sw;
  __asm__ ("fxam; fstsw %%ax;" : "=a" (sw): "t" (x));
  return sw & (FP_NAN | FP_NORMAL | FP_ZERO );
}
#endif

#define fpclassify(x) (sizeof (x) == sizeof (float) ? __fpclassifyf (x)	  \
		       : sizeof (x) == sizeof (double) ? __fpclassify (x) \
		       : __fpclassifyl (x))

/* 7.12.3.2 */
#define isfinite(x) ((fpclassify(x) & FP_NAN) == 0)

/* 7.12.3.3 */
#define isinf(x) (fpclassify(x) == FP_INFINITE)

/* 7.12.3.4 */
/* We don't need to worry about truncation here:
   A NaN stays a NaN. */
extern int __cdecl __isnan (double);
extern int __cdecl __isnanf (float);
extern int __cdecl __isnanl (long double);
#ifndef __NO_INLINE__
__CRT_INLINE int __cdecl __isnan (double _x)
{
  unsigned short sw;
  __asm__ ("fxam;"
	   "fstsw %%ax": "=a" (sw) : "t" (_x));
  return (sw & (FP_NAN | FP_NORMAL | FP_INFINITE | FP_ZERO | FP_SUBNORMAL))
    == FP_NAN;
}

__CRT_INLINE int __cdecl __isnanf (float _x)
{
  unsigned short sw;
  __asm__ ("fxam;"
	    "fstsw %%ax": "=a" (sw) : "t" (_x));
  return (sw & (FP_NAN | FP_NORMAL | FP_INFINITE | FP_ZERO | FP_SUBNORMAL))
    == FP_NAN;
}

__CRT_INLINE int __cdecl __isnanl (long double _x)
{
  unsigned short sw;
  __asm__ ("fxam;"
	    "fstsw %%ax": "=a" (sw) : "t" (_x));
  return (sw & (FP_NAN | FP_NORMAL | FP_INFINITE | FP_ZERO | FP_SUBNORMAL))
    == FP_NAN;
}
#endif

#define isnan(x) (sizeof (x) == sizeof (float) ? __isnanf (x)	\
		  : sizeof (x) == sizeof (double) ? __isnan (x)	\
		  : __isnanl (x))

/* 7.12.3.5 */
#define isnormal(x) (fpclassify(x) == FP_NORMAL)

/* 7.12.3.6 The signbit macro */
extern int __cdecl __signbit (double);
extern int __cdecl __signbitf (float);
extern int __cdecl __signbitl (long double);
#ifndef __NO_INLINE__
__CRT_INLINE int __cdecl __signbit (double x) {
  unsigned short stw;
  __asm__ ( "fxam; fstsw %%ax;": "=a" (stw) : "t" (x));
  return (stw & 0x0200) != 0;
}

__CRT_INLINE int __cdecl __signbitf (float x) {
  unsigned short stw;
  __asm__ ("fxam; fstsw %%ax;": "=a" (stw) : "t" (x));
  return (stw & 0x0200) != 0;
}

__CRT_INLINE int __cdecl __signbitl (long double x) {
  unsigned short stw;
  __asm__ ("fxam; fstsw %%ax;": "=a" (stw) : "t" (x));
  return (stw & 0x0200) != 0;
}
#endif

#define signbit(x) (sizeof (x) == sizeof (float) ? __signbitf (x)	\
		    : sizeof (x) == sizeof (double) ? __signbit (x)	\
		    : __signbitl (x))

/* 7.12.4 Trigonometric functions: Double in C89 */
extern float __cdecl sinf (float);
extern long double __cdecl sinl (long double);

extern float __cdecl cosf (float);
extern long double __cdecl cosl (long double);

extern float __cdecl tanf (float);
extern long double __cdecl tanl (long double);

extern float __cdecl asinf (float);
extern long double __cdecl asinl (long double);

extern float __cdecl acosf (float);
extern long double __cdecl acosl (long double);

extern float __cdecl atanf (float);
extern long double __cdecl atanl (long double);

extern float __cdecl atan2f (float, float);
extern long double __cdecl atan2l (long double, long double);

/* 7.12.5 Hyperbolic functions: Double in C89  */
extern float __cdecl sinhf (float);
#ifndef __NO_INLINE__
__CRT_INLINE float __cdecl sinhf (float x)
  {return (float) sinh (x);}
#endif
extern long double __cdecl sinhl (long double);

extern float __cdecl coshf (float);
#ifndef __NO_INLINE__
__CRT_INLINE float __cdecl coshf (float x)
  {return (float) cosh (x);}
#endif
extern long double __cdecl coshl (long double);

extern float __cdecl tanhf (float);
#ifndef __NO_INLINE__
__CRT_INLINE float __cdecl tanhf (float x)
  {return (float) tanh (x);}
#endif
extern long double __cdecl tanhl (long double);

/* Inverse hyperbolic trig functions  */ 
/* 7.12.5.1 */
extern double __cdecl acosh (double);
extern float __cdecl acoshf (float);
extern long double __cdecl acoshl (long double);

/* 7.12.5.2 */
extern double __cdecl asinh (double);
extern float __cdecl asinhf (float);
extern long double __cdecl asinhl (long double);

/* 7.12.5.3 */
extern double __cdecl atanh (double);
extern float __cdecl atanhf  (float);
extern long double __cdecl atanhl (long double);

/* Exponentials and logarithms  */
/* 7.12.6.1 Double in C89 */
extern float __cdecl expf (float);
#ifndef __NO_INLINE__
__CRT_INLINE float __cdecl expf (float x)
  {return (float) exp (x);}
#endif
extern long double __cdecl expl (long double);

/* 7.12.6.2 */
extern double __cdecl exp2(double);
extern float __cdecl exp2f(float);
extern long double __cdecl exp2l(long double);

/* 7.12.6.3 The expm1 functions */
/* TODO: These could be inlined */
extern double __cdecl expm1(double);
extern float __cdecl expm1f(float);
extern long double __cdecl expm1l(long double);

/* 7.12.6.4 Double in C89 */
extern float __cdecl frexpf (float, int*);
#ifndef __NO_INLINE__
__CRT_INLINE float __cdecl frexpf (float x, int* expn)
  {return (float) frexp (x, expn);}
#endif
extern long double __cdecl frexpl (long double, int*);

/* 7.12.6.5 */
#define FP_ILOGB0 ((int)0x80000000)
#define FP_ILOGBNAN ((int)0x80000000)
extern int __cdecl ilogb (double);
extern int __cdecl ilogbf (float);
extern int __cdecl ilogbl (long double);

/* 7.12.6.6  Double in C89 */
extern float __cdecl ldexpf (float, int);
#ifndef __NO_INLINE__
__CRT_INLINE float __cdecl ldexpf (float x, int expn)
  {return (float) ldexp (x, expn);}
#endif
extern long double __cdecl ldexpl (long double, int);

/* 7.12.6.7 Double in C89 */
extern float __cdecl logf (float);
extern long double __cdecl logl (long double);

/* 7.12.6.8 Double in C89 */
extern float __cdecl log10f (float);
extern long double __cdecl log10l (long double);

/* 7.12.6.9 */
extern double __cdecl log1p(double);
extern float __cdecl log1pf(float);
extern long double __cdecl log1pl(long double);

/* 7.12.6.10 */
extern double __cdecl log2 (double);
extern float __cdecl log2f (float);
extern long double __cdecl log2l (long double);

/* 7.12.6.11 */
extern double __cdecl logb (double);
extern float __cdecl logbf (float);
extern long double __cdecl logbl (long double);

/* Inline versions.  GCC-4.0+ can do a better fast-math optimization
   with __builtins. */ 
#ifndef __NO_INLINE__
#if !(__MINGW_GNUC_PREREQ (4, 0) && defined __FAST_MATH__ )
__CRT_INLINE double __cdecl logb (double x)
{
  double res;
  __asm__ ("fxtract\n\t"
       "fstp	%%st" : "=t" (res) : "0" (x));
  return res;
}

__CRT_INLINE float __cdecl logbf (float x)
{
  float res;
  __asm__ ("fxtract\n\t"
       "fstp	%%st" : "=t" (res) : "0" (x));
  return res;
}

__CRT_INLINE long double __cdecl logbl (long double x)
{
  long double res;
  __asm__ ("fxtract\n\t"
       "fstp	%%st" : "=t" (res) : "0" (x));
  return res;
}
#endif /* !defined __FAST_MATH__ || !__MINGW_GNUC_PREREQ (4, 0) */
#endif /* !defined __NO_INLINE__ */

/* 7.12.6.12  Double in C89 */
extern float __cdecl modff (float, float*);
extern long double __cdecl modfl (long double, long double*);

/* 7.12.6.13 */
extern double __cdecl scalbn (double, int);
extern float __cdecl scalbnf (float, int);
extern long double __cdecl scalbnl (long double, int);

extern double __cdecl scalbln (double, long);
extern float __cdecl scalblnf (float, long);
extern long double __cdecl scalblnl (long double, long);

/* 7.12.7.1 */
/* Implementations adapted from Cephes versions */ 
extern double __cdecl cbrt (double);
extern float __cdecl cbrtf (float);
extern long double __cdecl cbrtl (long double);

/* 7.12.7.2 The fabs functions: Double in C89 */
extern  float __cdecl fabsf (float x);
extern long double __cdecl fabsl (long double x);

/* 7.12.7.3  */
extern double __cdecl hypot (double, double); /* in libmoldname.a */
extern float __cdecl hypotf (float, float);
#ifndef __NO_INLINE__
__CRT_INLINE float __cdecl hypotf (float x, float y)
  { return (float) hypot (x, y);}
#endif
extern long double __cdecl hypotl (long double, long double);

/* 7.12.7.4 The pow functions. Double in C89 */
extern float __cdecl powf (float, float);
#ifndef __NO_INLINE__
__CRT_INLINE float __cdecl powf (float x, float y)
  {return (float) pow (x, y);}
#endif
extern long double __cdecl powl (long double, long double);

/* 7.12.7.5 The sqrt functions. Double in C89. */
extern float __cdecl sqrtf (float);
extern long double __cdecl sqrtl (long double);

/* 7.12.8.1 The erf functions  */
extern double __cdecl erf (double);
extern float __cdecl erff (float);
extern long double __cdecl erfl (long double);

/* 7.12.8.2 The erfc functions  */
extern double __cdecl erfc (double);
extern float __cdecl erfcf (float);
extern long double __cdecl erfcl (long double);

/* 7.12.8.3 The lgamma functions */
extern double __cdecl lgamma (double);
extern float __cdecl lgammaf (float);
extern long double __cdecl lgammal (long double);

/* 7.12.8.4 The tgamma functions */
extern double __cdecl tgamma (double);
extern float __cdecl tgammaf (float);
extern long double __cdecl tgammal (long double);

/* 7.12.9.1 Double in C89 */
extern float __cdecl ceilf (float);
extern long double __cdecl ceill (long double);

/* 7.12.9.2 Double in C89 */
extern float __cdecl floorf (float);
extern long double __cdecl floorl (long double);

/* 7.12.9.3 */
extern double __cdecl nearbyint ( double);
extern float __cdecl nearbyintf (float);
extern long double __cdecl nearbyintl (long double);

/* 7.12.9.4 */
/* round, using fpu control word settings */
extern double __cdecl rint (double);
extern float __cdecl rintf (float);
extern long double __cdecl rintl (long double);

/* 7.12.9.5 */
extern long __cdecl lrint (double);
extern long __cdecl lrintf (float);
extern long __cdecl lrintl (long double);

extern long long __cdecl llrint (double);
extern long long __cdecl llrintf (float);
extern long long __cdecl llrintl (long double);

/* Inline versions of above. 
   GCC 4.0+ can do a better fast-math job with __builtins. */
#ifndef __NO_INLINE__
#if !(__MINGW_GNUC_PREREQ (4, 0) && defined __FAST_MATH__ )
__CRT_INLINE double __cdecl rint (double x)
{
  double retval;
  __asm__ ("frndint;": "=t" (retval) : "0" (x));
  return retval;
}

__CRT_INLINE float __cdecl rintf (float x)
{
  float retval;
  __asm__ ("frndint;" : "=t" (retval) : "0" (x) );
  return retval;
}

__CRT_INLINE long double __cdecl rintl (long double x)
{
  long double retval;
  __asm__ ("frndint;" : "=t" (retval) : "0" (x) );
  return retval;
}

__CRT_INLINE long __cdecl lrint (double x) 
{
  long retval;  
  __asm__ __volatile__
    ("fistpl %0"  : "=m" (retval) : "t" (x) : "st");
  return retval;
}

__CRT_INLINE long __cdecl lrintf (float x) 
{
  long retval;
  __asm__ __volatile__
    ("fistpl %0"  : "=m" (retval) : "t" (x) : "st");
  return retval;
}

__CRT_INLINE long __cdecl lrintl (long double x) 
{
  long retval;
  __asm__ __volatile__
    ("fistpl %0"  : "=m" (retval) : "t" (x) : "st");
  return retval;
}

__CRT_INLINE long long __cdecl llrint (double x)
{
  long long retval;
  __asm__ __volatile__
    ("fistpll %0"  : "=m" (retval) : "t" (x) : "st");
  return retval;
}

__CRT_INLINE long long __cdecl llrintf (float x)
{
  long long retval;
  __asm__ __volatile__
    ("fistpll %0"  : "=m" (retval) : "t" (x) : "st");
  return retval;
}

__CRT_INLINE long long __cdecl llrintl (long double x) 
{
  long long retval;
  __asm__ __volatile__
    ("fistpll %0"  : "=m" (retval) : "t" (x) : "st");
  return retval;
}
#endif /* !__FAST_MATH__ || !__MINGW_GNUC_PREREQ (4,0)  */
#endif /* !defined __NO_INLINE */

/* 7.12.9.6 */
/* round away from zero, regardless of fpu control word settings */
extern double __cdecl round (double);
extern float __cdecl roundf (float);
extern long double __cdecl roundl (long double);

/* 7.12.9.7  */
extern long __cdecl lround (double);
extern long __cdecl lroundf (float);
extern long __cdecl lroundl (long double);

extern long long __cdecl llround (double);
extern long long __cdecl llroundf (float);
extern long long __cdecl llroundl (long double);

/* 7.12.9.8 */
/* round towards zero, regardless of fpu control word settings */
extern double __cdecl trunc (double);
extern float __cdecl truncf (float);
extern long double __cdecl truncl (long double);

/* 7.12.10.1 Double in C89 */
extern float __cdecl fmodf (float, float);
extern long double __cdecl fmodl (long double, long double);

/* 7.12.10.2 */ 
extern double __cdecl remainder (double, double);
extern float __cdecl remainderf (float, float);
extern long double __cdecl remainderl (long double, long double);

/* 7.12.10.3 */
extern double __cdecl remquo(double, double, int *);
extern float __cdecl remquof(float, float, int *);
extern long double __cdecl remquol(long double, long double, int *);

/* 7.12.11.1 */
extern double __cdecl copysign (double, double); /* in libmoldname.a */
extern float __cdecl copysignf (float, float);
extern long double __cdecl copysignl (long double, long double);

/* 7.12.11.2 Return a NaN */
extern double __cdecl nan(const char *tagp);
extern float __cdecl nanf(const char *tagp);
extern long double __cdecl nanl(const char *tagp);

#ifndef __STRICT_ANSI__
#define _nan() nan("")
#define _nanf() nanf("")
#define _nanl() nanl("")
#endif

/* 7.12.11.3 */
extern double __cdecl nextafter (double, double); /* in libmoldname.a */
extern float __cdecl nextafterf (float, float);
extern long double __cdecl nextafterl (long double, long double);

/* 7.12.11.4 The nexttoward functions */
extern double __cdecl nexttoward (double,  long double);
extern float __cdecl nexttowardf (float,  long double);
extern long double __cdecl nexttowardl (long double, long double);

/* 7.12.12.1 */
/*  x > y ? (x - y) : 0.0  */
extern double __cdecl fdim (double x, double y);
extern float __cdecl fdimf (float x, float y);
extern long double __cdecl fdiml (long double x, long double y);

/* fmax and fmin.
   NaN arguments are treated as missing data: if one argument is a NaN
   and the other numeric, then these functions choose the numeric
   value. */

/* 7.12.12.2 */
extern double __cdecl fmax  (double, double);
extern float __cdecl fmaxf (float, float);
extern long double __cdecl fmaxl (long double, long double);

/* 7.12.12.3 */
extern double __cdecl fmin (double, double);
extern float __cdecl fminf (float, float);
extern long double __cdecl fminl (long double, long double);

/* 7.12.13.1 */
/* return x * y + z as a ternary op */ 
extern double __cdecl fma (double, double, double);
extern float __cdecl fmaf (float, float, float);
extern long double __cdecl fmal (long double, long double, long double);


/* 7.12.14 */
/* 
 *  With these functions, comparisons involving quiet NaNs set the FP
 *  condition code to "unordered".  The IEEE floating-point spec
 *  dictates that the result of floating-point comparisons should be
 *  false whenever a NaN is involved, with the exception of the != op, 
 *  which always returns true: yes, (NaN != NaN) is true).
 */

#if __GNUC__ >= 3

#define isgreater(x, y) __builtin_isgreater(x, y)
#define isgreaterequal(x, y) __builtin_isgreaterequal(x, y)
#define isless(x, y) __builtin_isless(x, y)
#define islessequal(x, y) __builtin_islessequal(x, y)
#define islessgreater(x, y) __builtin_islessgreater(x, y)
#define isunordered(x, y) __builtin_isunordered(x, y)

#else
/*  helper  */
extern int  __cdecl __fp_unordered_compare (long double, long double);
#ifndef __NO_INLINE__
__CRT_INLINE int  __cdecl
__fp_unordered_compare (long double x, long double y){
  unsigned short retval;
  __asm__ ("fucom %%st(1);"
	   "fnstsw;": "=a" (retval) : "t" (x), "u" (y));
  return retval;
}
#endif

#define isgreater(x, y) ((__fp_unordered_compare(x, y) \
			   & 0x4500) == 0)
#define isless(x, y) ((__fp_unordered_compare (y, x) \
                       & 0x4500) == 0)
#define isgreaterequal(x, y) ((__fp_unordered_compare (x, y) \
                               & FP_INFINITE) == 0)
#define islessequal(x, y) ((__fp_unordered_compare(y, x) \
			    & FP_INFINITE) == 0)
#define islessgreater(x, y) ((__fp_unordered_compare(x, y) \
			      & FP_SUBNORMAL) == 0)
#define isunordered(x, y) ((__fp_unordered_compare(x, y) \
			    & 0x4500) == 0x4500)

#endif


#endif /* __STDC_VERSION__ >= 199901L */
#endif /* __NO_ISOCEXT */


#ifdef __cplusplus
}
#endif
#endif	/* Not RC_INVOKED */


#endif	/* Not _MATH_H_ */
@


1.37
log
@2009-08-08  Danny Smith  <dannysmith@@users.sourceforge.net>

        * include/math.h (__fpclassifyl, __isnan, __isnanf, isnanl, __signbit,
        __signbitf, __signbitl, sinhf, tanhf, expf, frexpf, ldexpf, hypotf, powf,
        __fp_unordered_compare): Add prototypes.
        * include/stdio.h (vsnwprintf): Add prototype.
        * include/wchar.h (vsnwprintf): Add prototype.
        * include/unistd.h (ftruncate): Move prototype out of __NO_INLINE__ guard.
@
text
@@


1.36
log
@2009-07-18  Gregory McGarry  <gregorymcgarry@@users.sourceforge.net>

        * include/inttypes.h include/math.h include/stdio.h include/stdlib.h
        include/string.h include/unistd.h include/wchar.h: Add __NO_INLINE__ guard
        to all inline functions.
@
text
@d356 1
d379 3
d419 3
d469 1
d476 1
d483 1
d508 1
d527 1
d542 1
d627 1
d635 1
d878 1
@


1.35
log
@Fix MinGW-Bug [2160227]: Eliminate conflicting declarations and implementations of scalb().
@
text
@d357 1
d363 1
d378 1
a378 1

d405 1
a405 1

d415 1
d433 1
d462 1
d465 1
d468 1
d471 1
d474 1
d477 1
d498 1
d501 1
d516 1
d519 1
d530 1
d533 1
d561 1
d587 1
d614 1
d617 1
d621 1
d624 1
d681 1
d752 1
d863 1
d871 1
@


1.34
log
@2008-03-21  Danny Smith  <dannysmith@@users.sourceforge.net>

        * include/math.h (float_t, double_t): Define.
@
text
@d262 5
d268 2
@


1.33
log
@2007-10-03  Bernd Becker <hugin@@users.sourceforge.net>

        * include/io.h (__finddata64_t, __wfinddata64_t): changed member 'size'
        from '_fsize_t' to '__int64' to be consistent with the other ...64
        structures and the value set there is 8 bytes not 4.  Add guard for both
        as the are only used by functions available from 6.1 on.

        * include/malloc.h (_HEAP_MAXREQ): Define.
        (_aligned_offset_recalloc): Define.
        (_aligned_recalloc()): Define.

        * include/math.h: fixed a typo in a comment.
        (atanhf): Fixed declaration.

        * include/wchar.h (__wfinddata64_t): changed member 'size' from '_fsize_t'
        to '__int64' to be consistent with the other ...64 structures and the value
        set there is 8 bytes not 4.  Added guard as this function is only used by
        functions available from 6.1 on.

        * include/sys/stat.h: some members of 'stat' were declared with types with
        a prefixed underscore, while the ones without the underscore should have
        been used.  Added guard to '__stat64' as it is only used by functions
        available from 6.1 on.  Added the wide character versions of the
        exec()/spawn() family for completion
        (_stati64): changed the type of the 'st_mode' member from 'unsigned int' to
        '_mode_t'

        * include/sys/timeb.h (timeb, _timb): changed the type of the 'time' member
        from 'long' to 'time_t'
        (__timeb64): moved declaration of structure directly before the declaration
        of the function '_ftime64()', so it is guarded as well

        * include/sys/utime.h (__utimbuf64): moved declaration of structure directly
        before the declaration of the functions using it, so it is guarded as well
@
text
@d307 18
@


1.32
log
@* include/math.h (__INFF,__INFL): Remove '#'.
@
text
@d349 1
a349 1
/* We don't need to worry about trucation here:
d458 1
a458 1
extern float __cdecl atanf  (float);
@


1.31
log
@	* include/math.h (HUGE_VAL): Define as builtin if __GNUC__ >= 3.3,
	else global library variable.
        (HUGEVALF): Likewise;
	(HUGEVALL): Likewise.
	(INFINITY): Likewise.
	(NAN): LiKewise.
@
text
@d298 1
a298 1
#extern const float __INFF;
d300 1
a300 1
#extern const long double  __INFL;
d302 1
a302 1
#define INFINITY	HUGE_VALF
@


1.30
log
@	* include/math.h (HUGE_VALF, HUGE_VALL, INFINITY, NAN)
	Avoid raising FP exceptions.
@
text
@d104 4
d131 2
d292 10
a301 2
#define HUGE_VALF	0x1.0p255f
#define HUGE_VALL	0x1.0p32767L
d303 3
a305 1
#define NAN (HUGE_VALF - HUGE_VALF)
@


1.29
log
@	* include/_mingw.h (__MINGW_GNUC_PREREQ): Define. Use to
	guard __MINGW_ATTRIB macro definitions.
	* include/math.h (logb[fl]):  Don't define inlines for
	GCC-4.0+ && __FAST_MATH__.
	(rint[fl], lrint[fl], llrint[fl]); Likewise.  Clean up
	line-continuation backslashes.
@
text
@d286 4
a289 5
#define NAN (0.0F/0.0F)
#define HUGE_VALF (1.0F/0.0F)
#define HUGE_VALL (1.0L/0.0L)
#define INFINITY (1.0F/0.0F)

@


1.28
log
@	* mingwex/math/nexttoward.c: New file.
	* mingwex/math/nexttowardf.c: New file.
	* mingwex/math/nextafterl.c: Add nexttowardl aliaa.
	* mingwex/Makefile.in (MATH_DISTFILES): Add nexttoward.c,
	mexttowardf.c,
	(MATH_OBJS):  Add nexttoward.o,	mexttowardf.o,
	* include/math.h (nexttoward, nextowardf, nexttowardl): Add
	prototypes.
@
text
@d503 3
d529 1
d604 16
a640 1
/* 7.12.9.5 */
d644 2
a645 2
  __asm__ __volatile__							      \
    ("fistpl %0"  : "=m" (retval) : "t" (x) : "st");				      \
d652 2
a653 2
  __asm__ __volatile__							      \
    ("fistpl %0"  : "=m" (retval) : "t" (x) : "st");				      \
d660 2
a661 2
  __asm__ __volatile__							      \
    ("fistpl %0"  : "=m" (retval) : "t" (x) : "st");				      \
d665 1
a665 1
__CRT_INLINE long long __cdecl llrint (double x) 
d668 2
a669 2
  __asm__ __volatile__							      \
    ("fistpll %0"  : "=m" (retval) : "t" (x) : "st");				      \
d673 1
a673 1
__CRT_INLINE long long __cdecl llrintf (float x) 
d676 2
a677 2
  __asm__ __volatile__							      \
    ("fistpll %0"  : "=m" (retval) : "t" (x) : "st");				      \
d684 2
a685 2
  __asm__ __volatile__							      \
    ("fistpll %0"  : "=m" (retval) : "t" (x) : "st");				      \
d688 1
@


1.27
log
@	* mingwex/math/nextafterf.c (nextafterf): Correct
	handling of -0.0.
	* mingwex/math/nextafterl.c: New file.
	* mingwex/Makefile.in (MATH_DISTFILES): Add nextafterl.c.
	(MATH_OBJS): Add nextafterl.o.
	* include/math.h (nextafterl): Uncomment prototype.
@
text
@d726 4
a729 1
/* 7.12.11.4 The nexttoward functions: TODO */
@


1.26
log
@	* mingwex/math/erfl.c: New file.
	* mingwex/Makefile.i (MATH_DISTFILES): Add erfl.c.
	(MATH_OBJS): Add erfl.o.
	* include/math.h (erfl, erfcl): Uncomment prototypes.
@
text
@d724 1
a724 2
/* TODO: Not yet implemented */
/* extern long double __cdecl nextafterl (long double, long double); */
@


1.25
log
@	* mingwex/math/signbit.c (__signbit):  Make return value
	consistent with GCC's __builtin_signbit.
	* mingwex/math/signbitf.c (__signbitf):  Likewise.
	* mingwex/math/signbitf.c (__signbitl):  Likewise.
	* include/math.h (__signbit, __signbitf, __signbitl): Likewise
	for inlines.
@
text
@a567 1
/* TODO
a568 1
*/ 
a572 1
/* TODO
a573 1
*/ 
@


1.24
log
@2005-02-11  Gregory W. Chicares  <chicares at cox dot net>
            Danny Smith  <dannysmith@@users at sourceforge dot net>

	* include/math.h (expm1, expm1f, expmll): Add prototypes.
	* mingwex/Makefile.in (MATH_DISTFILES): Add expm1.c,
	expm1f.c, expm1l.c.
	(MATH_OBJS): Add expm1.o, expm1f.o, expm1l.o.
	* mingwex/math/expm1.c: New file.
	* mingwex/math/expm1f.c: New file.
	* mingwex/math/expm1l.c: New file.
@
text
@d376 1
a376 1
  return stw & 0x0200;
d382 1
a382 1
  return stw & 0x0200;
d388 1
a388 1
  return stw & 0x0200;
@


1.23
log
@	* include/math.h (ashinh, asinhf, asinhl, acosh, acoshf, acoshl,
	atanh, atanhf, atanhl): Add prototypes.
	* mingwex/Makefile.in (MATH_OBJS): Add objects for above to list.
	(MATH_DISTFILES): Add sources for above and fastmath.h to list.
	Specify dependency on fastmath.h for new objects.
	* mingwex/math/fastmath.h: New file.
	* mingwex/math/ashinh.c: New file.
	* mingwex/math/asinhf.c: New file.
	* mingwex/math/asinhl.c: New file.
	* mingwex/math/acosh.c: New file.
	* mingwex/math/acoshf.c: New file.
	* mingwex/math/acoshl.c: New file.
	* mingwex/math/atanh.c: New file.
	* mingwex/math/atanhf.c: New file.
	* mingwex/math/atanhl.c: New file.
@
text
@d457 5
a461 1
/* 7.12.6.3 The expm1 functions: TODO */
@


1.22
log
@	* include/math.h: Add pragma GCC system_header.
@
text
@d430 15
a444 3
/*
 * TODO: asinh, acosh, atanh
 */ 
d446 1
@


1.21
log
@2	* mingwex/Makefile.in (MATH_DISTFILES): Remove pow.c,
	(MATH_OBJS): Remove pow,o.
	* include/math.h (pow): Declare with _CRTIMP.
	Add comment on how to avoid excess precision problems.
@
text
@d11 1
d15 4
@


1.20
log
@
	* CONTRIBUTORS: New file.
	* DISCLAIMER: Ditto.
	* CRT_noglob.c: Reword copyright and disclaimer.  Move Contributors
	section CONTRIBUTORS file.  Remove RCS tags.
	* CRTFmode.c: Ditto.
	* CRTglob.c: Ditto.
	* CRTinit.c: Ditto.
	* crt1.c: Ditto.
	* crtdll.dev: Ditto.
	* dllcrt1.c: Ditto.
	* dllmain.c: Ditto.
	* gccmain.c: Ditto.
	* init.c: Ditto.
	* isascii.c: Ditto.
	* iscsym.c: Ditto.
	* iscsymf.c: Ditto.
	* jamfile: Ditto.
	* main.c: Ditto.
	* msvcrt.def.in: Ditto.
	* strcasecmp.c: Ditto.
	* toascii.c: Ditto.
	* wcscmpi.c: Ditto.
	* include/assert.h: Ditto.
	* include/conio.h: Ditto.
	* include/ctype.h: Ditto.
	* include/direct.h: Ditto.
	* include/dirent.h: Ditto.
	* include/dos.h: Ditto.
	* include/errno.h: Ditto.
	* include/excpt.h: Ditto.
	* include/fcntl.h: Ditto.
	* include/float.h: Ditto.
	* include/io.h: Ditto.
	* include/locale.h: Ditto.
	* include/malloc.h: Ditto.
	* include/math.h: Ditto.
	* include/process.h: Ditto.
	* include/setjmp.h: Ditto.
	* include/share.h: Ditto.
	* include/signal.h: Ditto.
	* include/stdio.h: Ditto.
	* include/stdlib.h: Ditto.
	* include/string.h: Ditto.
	* include/tchar.h: Ditto.
	* include/time.h: Ditto.
	* include/wchar.h: Ditto.
	* include/sys/locking.h: Ditto.
	* include/sys/param.h: Ditto.
	* include/sys/stat.h: Ditto.
	* include/sys/timeb.h: Ditto.
	* include/sys/types.h: Ditto.
	* include/sys/utime.h: Ditto.
	* mingwex/dirent.c: Ditto.
@
text
@a131 1

d145 1
a145 4
#ifdef __NO_ISOCEXT
_CRTIMP
#endif
	double __cdecl pow (double, double);
d155 38
@


1.19
log
@2004-03-28  Hans Leidekker  <hans@@it.vu.nl>

	* include/math.h (FP_*): Add defines.
@
text
@d3 3
a7 19
 *
 * This file is part of the Mingw32 package.
 *
 * Contributors:
 *  Created by Colin Peters <colin@@bird.fu.is.saga-u.ac.jp>
 *
 *  THIS SOFTWARE IS NOT COPYRIGHTED
 *
 *  This source code is offered for use in the public domain. You may
 *  use, modify or distribute it freely.
 *
 *  This code is distributed in the hope that it will be useful but
 *  WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 *  DISCLAIMED. This includes but is not limited to warranties of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 * $Revision: 1.6 $
 * $Author: cgf $
 * $Date: 2000/02/05 04:04:55 $
@


1.18
log
@	Add prototypes for new msvcrt.dll versions

	* include/_mingw.h (__MSVCRT_VERSION__): Define default as 0x0600.

	* include/time.h (__time64_t): Add typedef.
	(_mktime64): Add prototype for __MSVCRT_VERSION__ >= 0x0601.
	(_ctime64): Likewise.
	(_wctime64): Likewise.
	(_gmtime64): Likewise.
	(_localtime64): Likewise.
	(wcsftime): Move into _WTIME_DEFINED block.
	Regroup non-ANSI prototypes.

	* include/io.h: Include <stdint.h>.
	(__finddata64_t): Add struct definition.
	(__wfinddata64_t): Likewise.
	(_findfirst64): Add prototype for __MSVCRT_VERSION__ >= 0x0601.
	(_findnext64): Likewise.
	(_wfindfirst64): Likewise.
	(_wfindnext64): Likewise.

	* include/sys/timeb.h (__timeb64): Add struct definition.
	(_ftime64): Add prototype for __MSVCRT_VERSION__ >= 0x0601.

	* include/sys/utime.h (__utimbuf64): Add struct definition.
	(_utime64): Add prototype for __MSVCRT_VERSION__ >= 0x0601.
	(_futime64): Likewise.
	(_wutime64): Likewise.

	* include/sys/stat.h (__stat64):  Add struct definition.
	(_fstat64): Add prototype for __MSVCRT_VERSION__ >= 0x0601.
	(_stat64): Likewise.
	(_wstat64): Likwise.

	* include/sys/types.h (__time64_t):  Add typedef.

	* include/wchar.h (__wfinddata64_t): Add structure definition.
	(__stat64): Likewise.
	(_wctime64): Add prototype for __MSVCRT_VERSION__ >= 0x0601.
	(_wfindfirst64): Likewise.
	(_wfindnext64): Likewise.
	(_wutime64): Likewise.
	(_wstat64): Likwise.

	* include/malloc.h (_aligned_free): Add prototype for
	__MSVCRT_VERSION__ >= 0x0700.
	(_aligned_malloc): Likewise.
	(_aligned_offset_malloc): Likewise.
	(_aligned_offset_realloc): Likewise.
	(_aligned_realloc): Likewise.

	* include/string.h (_wcserror): Add prototype for
	__MSVCRT_VERSION__ >= 0x0700.
	(__wcserror): Likewise.

	* include/math.h (_set_SSE2_enable): Add prototype for
	__MSVCRT_VERSION__ >= 0x0701.
@
text
@d237 11
@


1.17
log
@	* include/math.h: Guard ISO C99 additions with __cplusplus
	not __GLIBCPP__.
@
text
@d239 6
@


1.16
log
@	* include/math.h (cabs): Remove non-ISO prototype.
@
text
@d244 1
a244 1
	|| !defined __STRICT_ANSI__ || defined __GLIBCPP__
@


1.15
log
@	* include/_mingw.h (__CRT_INLINE): Define.
	* include/ctype.h: Replace 'extern inline' with __CRT_INLINE,
	throughout
	* include/inttypes.h: Likewise.
	* include/math.h: Likewise.
	* include/stdio.h: Likewise.
	* include/stdlib.h: Likewise.
	* include/string.h: Likewise.
	* include/wchar.h: Likewise.
	* include/wctype.h: Likewise.
@
text
@d178 3
a180 1
/* Complex number (for cabs). This really belongs in complex.h */
a224 1
_CRTIMP double __cdecl cabs (struct _complex);
@


1.14
log
@	* include/math.h (fabs) : Remove inline definition.
	(fabsf): Likewise.
	(fabsl): Likewise.
@
text
@d276 1
a276 1
extern __inline__ int __cdecl __fpclassifyl (long double x){
d296 1
a296 1
extern __inline__ int __cdecl __isnan (double _x)
d305 1
a305 1
extern __inline__ int __cdecl __isnanf (float _x)
d314 1
a314 1
extern __inline__ int __cdecl __isnanl (long double _x)
d332 1
a332 1
extern __inline__ int __cdecl __signbit (double x) {
d338 1
a338 1
extern  __inline__ int __cdecl __signbitf (float x) {
d344 1
a344 1
extern  __inline__ int __cdecl __signbitl (long double x) {
d377 1
a377 1
extern __inline__ float __cdecl sinhf (float x)
d381 1
a381 1
extern __inline__ float __cdecl coshf (float x)
d385 1
a385 1
extern __inline__ float __cdecl tanhf (float x)
d394 1
a394 1
extern __inline__ float __cdecl expf (float x)
d406 1
a406 1
extern __inline__ float __cdecl frexpf (float x, int* expn)
d418 1
a418 1
extern __inline__ float __cdecl ldexpf (float x, int expn)
d445 1
a445 1
extern __inline__ double __cdecl logb (double x)
d453 1
a453 1
extern __inline__ float __cdecl logbf (float x)
d461 1
a461 1
extern __inline__ long double __cdecl logbl (long double x)
d494 1
a494 1
extern __inline__ float __cdecl hypotf (float x, float y)
d499 1
a499 1
extern __inline__ float __cdecl powf (float x, float y)
d546 1
a546 1
extern __inline__ double __cdecl rint (double x)
d553 1
a553 1
extern __inline__ float __cdecl rintf (float x)
d560 1
a560 1
extern __inline__ long double __cdecl rintl (long double x)
d568 1
a568 1
extern __inline__ long __cdecl lrint (double x) 
d576 1
a576 1
extern __inline__ long __cdecl lrintf (float x) 
d584 1
a584 1
extern __inline__ long __cdecl lrintl (long double x) 
d592 1
a592 1
extern __inline__ long long __cdecl llrint (double x) 
d600 1
a600 1
extern __inline__ long long __cdecl llrintf (float x) 
d608 1
a608 1
extern __inline__ long long __cdecl llrintl (long double x) 
d723 1
a723 1
extern  __inline__ int  __cdecl
@


1.13
log
@	* include/math.h: Remove _CRTIMP from pow() prototype,
	unless __NO_ISOCEXT.
@
text
@a169 8
#if !defined (__NO_INLINES__)
extern __inline__ __cdecl double fabs (double x)
{
  double res;
  __asm__ ("fabs;" : "=t" (res) : "0" (x));
  return res;
}
#endif
d489 2
a490 13
extern __inline__ float __cdecl fabsf (float x)
{
  float res;
  __asm__ ("fabs;" : "=t" (res) : "0" (x));
  return res;
}

extern __inline__ long double __cdecl fabsl (long double x)
{
  long double res;
  __asm__ ("fabs;" : "=t" (res) : "0" (x));
  return res;
}
@


1.12
log
@	* include/_mingw.h (_CRTIMP): Define for __GNUC__ if
	__declspec(dllimport)  supported.
	(__cdecl): Define if not already defined.
	(__stdcall): Likewise.
	* include/dirent.h: Qualify fuctions with __cdecl.
	* include/fenv.h: Likewise.
	* include/inttypes.h: Likewise.
	* include/assert.h: Qualify fuctions with __cdecl. Qualify
	CRT dll imports with _CRTIMP.
	* include/conio.h: Likewise.
	* include/ctype.h: Likewise.
	* include/direct.h: Likewise.
	* include/dos.h: Likewise.
	* include/errno.h: Likewise.
	* include/float.h: Likewise.
	* include/io.h: Likewise.
	* include/locale.h: Likewise.
	* include/malloc.h: Likewise.
	* include/math.h: Likewise.
	* include/mbctype.h: Likewise.
	* include/mbstring.h: Likewise.
	* include/process.h: Likewise.
	* include/setjmp.h: Likewise.
	* include/signal.h: Likewise.
	* include/stdio.h: Likewise.
	* include/stdlib.h: Likewise.
	* include/string.h: Likewise.
	* include/time.h: Likewise.
	* include/wchar.h: Likewise.
	* include/wctype.h: Likewise.
	* include/sys/stat.h: Likewise.
	* include/sys/timeb.h: Likewise.
	* include/sys/utime.h: Likewise.

	* include/ctype.h: Guard ctype inlines with __NO_INLINE__.
	* include/wctype.h: Guard wctype inlines with __NO_INLINE__.

	* include/stdio.h (__VALIST): Guard against prior definition.
@
text
@d162 4
a165 1
_CRTIMP double __cdecl pow (double, double);
@


1.11
log
@	* include/math.h (tgamma): Correct typo in comment.
@
text
@d149 20
a168 19
double	sin (double);
double	cos (double);
double	tan (double);
double	sinh (double);
double	cosh (double);
double	tanh (double);
double	asin (double);
double	acos (double);
double	atan (double);
double	atan2 (double, double);
double	exp (double);
double	log (double);
double	log10 (double);
double	pow (double, double);
double	sqrt (double);
double	ceil (double);
double	floor (double);
double	fabs (double);
extern __inline__  double fabs (double x)
d174 5
a178 4
double	ldexp (double, int);
double	frexp (double, int*);
double	modf (double, double*);
double	fmod (double, double);
d181 1
a181 1
#ifndef	__STRICT_ANSI__
d190 1
a190 1
double	_cabs (struct _complex);
d192 8
a199 8
double	_hypot (double, double);
double	_j0 (double);
double	_j1 (double);
double	_jn (int, double);
double	_y0 (double);
double	_y1 (double);
double	_yn (int, double);
int	_matherr (struct _exception *);
d208 9
a216 9
double	_chgsign	(double);
double	_copysign	(double, double);
double	_logb		(double);
double	_nextafter	(double, double);
double	_scalb		(double, long);

int	_finite		(double);
int	_fpclass	(double);
int	_isnan		(double);
d228 12
a239 12
double cabs (struct _complex);
double j0 (double);
double j1 (double);
double jn (int, double);
double y0 (double);
double y1 (double);
double yn (int, double);

double chgsign	(double);
double scalb (double, long);
int finite (double);
int fpclass (double);
d241 1
a241 1
#endif	/* Not _NO_OLDNAMES */
d248 1
a248 1
	|| !defined  __STRICT_ANSI__  || defined __GLIBCPP__
d278 2
a279 2
extern int __fpclassifyf (float);
extern int __fpclassify (double);
d281 1
a281 1
extern __inline__ int __fpclassifyl (long double x){
d301 1
a301 1
extern __inline__ int __isnan (double _x)
d310 1
a310 1
extern __inline__ int __isnanf (float _x)
d319 1
a319 1
extern __inline__ int __isnanl (long double _x)
d337 1
a337 1
extern __inline__ int __signbit (double x) {
d343 1
a343 1
extern  __inline__ int __signbitf (float x) {
d348 2
a349 1
extern  __inline__ int __signbitl (long double x) {
a354 1

d360 2
a361 2
extern float sinf (float);
extern long double sinl (long double);
d363 2
a364 2
extern float cosf (float);
extern long double cosl (long double);
d366 2
a367 2
extern float tanf (float);
extern long double tanl (long double);
d369 2
a370 2
extern float asinf (float);
extern long double asinl (long double);
d372 2
a373 2
extern float acosf (float);
extern long double acosl (long double);
d375 2
a376 2
extern float atanf (float);
extern long double atanl (long double);
d378 2
a379 2
extern float atan2f (float, float);
extern long double atan2l (long double, long double);
d382 1
a382 1
extern __inline__ float sinhf (float x)
d384 1
a384 1
extern long double sinhl (long double);
d386 1
a386 1
extern __inline__ float coshf (float x)
d388 1
a388 1
extern long double coshl (long double);
d390 1
a390 1
extern __inline__ float tanhf (float x)
d392 1
a392 1
extern long double tanhl (long double);
d399 1
a399 1
extern __inline__ float expf (float x)
d401 1
a401 1
extern long double expl (long double);
d404 3
a406 3
extern double exp2(double);
extern float exp2f(float);
extern long double exp2l(long double);
d411 1
a411 1
extern __inline__ float frexpf (float x, int* expn)
d413 1
a413 1
extern long double frexpl (long double, int*);
d418 3
a420 3
extern int ilogb (double);
extern int ilogbf (float);
extern int ilogbl (long double);
d423 1
a423 1
extern __inline__ float ldexpf (float x, int expn)
d425 1
a425 1
extern long double ldexpl (long double, int);
d428 2
a429 2
extern float logf (float);
extern long double logl (long double);
d432 2
a433 2
extern float log10f (float);
extern long double log10l (long double);
d436 3
a438 3
extern double log1p(double);
extern float log1pf(float);
extern long double log1pl(long double);
d441 3
a443 3
extern double log2 (double);
extern float log2f (float);
extern long double log2l (long double);
d446 3
a448 3
extern double logb (double);
extern float logbf (float);
extern long double logbl (long double);
d450 1
a450 1
extern __inline__ double logb (double x)
d458 1
a458 1
extern __inline__ float logbf (float x)
d466 1
a466 1
extern __inline__ long double logbl (long double x)
d475 2
a476 2
extern float modff (float, float*);
extern long double modfl (long double, long double*);
d479 7
a485 7
extern double scalbn (double, int);
extern float scalbnf (float, int);
extern long double scalbnl (long double, int);

extern double scalbln (double, long);
extern float scalblnf (float, long);
extern long double scalblnl (long double, long);
d489 3
a491 3
extern double cbrt (double);
extern float cbrtf (float);
extern long double cbrtl (long double);
d494 1
a494 1
extern __inline__ float fabsf (float x)
d501 1
a501 1
extern __inline__ long double fabsl (long double x)
d509 2
a510 2
extern double hypot (double, double); /* in libmoldname.a */
extern __inline__ float hypotf (float x, float y)
d512 1
a512 1
extern long double hypotl (long double, long double);
d515 1
a515 1
extern __inline__ float powf (float x, float y)
d517 1
a517 1
extern long double powl (long double, long double);
d520 2
a521 2
extern float sqrtf (float);
extern long double sqrtl (long double);
d524 2
a525 2
extern double erf (double);
extern float erff (float);
d527 1
a527 1
extern long double erfl (long double);
d531 2
a532 2
extern double erfc (double);
extern float erfcf (float);
d534 1
a534 1
extern long double erfcl (long double);
d538 3
a540 3
extern double lgamma (double);
extern float lgammaf (float);
extern long double lgammal (long double);
d543 3
a545 3
extern double tgamma (double);
extern float tgammaf (float);
extern long double tgammal (long double);
d548 2
a549 2
extern float ceilf (float);
extern long double ceill (long double);
d552 2
a553 2
extern float floorf (float);
extern long double floorl (long double);
d556 3
a558 3
extern double nearbyint ( double);
extern float nearbyintf (float);
extern long double nearbyintl (long double);
d562 1
a562 1
extern __inline__ double rint (double x)
d569 1
a569 1
extern __inline__ float rintf (float x)
d576 1
a576 1
extern __inline__ long double rintl (long double x)
d584 1
a584 1
extern __inline__ long lrint (double x) 
d592 1
a592 1
extern __inline__ long lrintf (float x) 
d600 1
a600 1
extern __inline__ long lrintl (long double x) 
d608 1
a608 1
extern __inline__ long long llrint (double x) 
d616 1
a616 1
extern __inline__ long long llrintf (float x) 
d624 1
a624 1
extern __inline__ long long llrintl (long double x) 
d634 3
a636 3
extern double round (double);
extern float roundf (float);
extern long double roundl (long double);
d639 7
a645 7
extern long lround (double);
extern long lroundf (float);
extern long lroundl (long double);

extern long long llround (double);
extern long long llroundf (float);
extern long long llroundl (long double);
d649 3
a651 3
extern double trunc (double);
extern float truncf (float);
extern long double truncl (long double);
d654 2
a655 2
extern float fmodf (float, float);
extern long double fmodl (long double, long double);
d658 3
a660 3
extern double remainder (double, double);
extern float remainderf (float, float);
extern long double remainderl (long double, long double);
d663 3
a665 3
extern double remquo(double, double, int *);
extern float remquof(float, float, int *);
extern long double remquol(long double, long double, int *);
d668 3
a670 3
extern double copysign (double, double); /* in libmoldname.a */
extern float copysignf (float, float);
extern long double copysignl (long double, long double);
d673 3
a675 3
extern double nan(const char *tagp);
extern float nanf(const char *tagp);
extern long double nanl(const char *tagp);
d684 2
a685 2
extern double nextafter (double, double); /* in libmoldname.a */
extern float nextafterf (float, float);
d687 1
a687 1
/* extern long double nextafterl (long double, long double); */
d693 3
a695 3
extern double fdim (double x, double y);
extern float fdimf (float x, float y);
extern long double fdiml (long double x, long double y);
d703 3
a705 3
extern double fmax  (double, double);
extern float fmaxf (float, float);
extern long double fmaxl (long double, long double);
d708 3
a710 3
extern double fmin (double, double);
extern float fminf (float, float);
extern long double fminl (long double, long double);
d714 3
a716 3
extern double fma (double, double, double);
extern float fmaf (float, float, float);
extern long double fmal (long double, long double, long double);
d739 1
a739 1
extern  __inline__ int
@


1.10
log
@	* mingwex/math/s_erf.c: New file.
	* mingwex/math/sf_erf.c: New file.
	* mingwex/Makefile.in (MATH_DISTFILES): Add new files.
	(MATH_OBJS): Add new objects.
	* include/math.h (erf[f]): Add prototypes.
	(erfc[f]): Add prototypes.
@
text
@a535 1

d540 1
a540 2
/* 77.12.8.4 The tgamma functions */

@


1.9
log
@	* include/math.h: Add traditional/XOPEN math constants.

	Add missing ChangeLog entry for 2002-11-27
@
text
@a520 1
/* TODO */ 
d522 6
d529 5
@


1.8
log
@	* mingwex/math/lgamma.c: New file.
	* mingwex/math/lgammaf.c: New file.
	* mingwex/math/lgammal.c: New file.
	* mingwex/math/tgamma.c: New file.
	* mingwex/math/tgammaf.c: New file.
	* mingwex/math/tgammal.c: New file.
	* mingwex/math/cephes_mconf (polevlf): Add float version.
	(p1evlf): Likewise.
	Define _CEPHES_USE_ERRNO.
	* mingwex/Makefile.in (MATH_DISTFILES): Add new files.
	(MATH_OBJS): Add new objects.
	* include/math.h (lgamma[fl]): Add prototypes.
	(tgamma[fl]): Add prototypes.
@
text
@d62 17
@


1.7
log
@	* include/math.h (sqrt): Remove inline definition.
	(sqrtf): Replace inline definition with prototype.
	(sqrtl): Likewise.
	* mingwex/math/sqrtf.c (sqrtf): Set domain error if
	argument less than zero.
	* mingwex/math/sqrtf.c (sqrtl): Likewise.

	Correct typo in 2002-10-30 ChangeLog entry.
@
text
@d504 15
a518 1
/* 7.12.8 Error and gamma functions: TODO */
@


1.6
log
@	* include/math.h (asm): Change to __asm__ throughout.
	Expose ISO C99 functions if __GLIBCPP__.
	(hypotf): Use hypot, not _hypot in stub..
@
text
@a146 6
extern __inline__  double sqrt (double x)
{
  double res;
  __asm__ ("fsqrt;" : "=t" (res) : "0" (x));
  return res;
}
d501 2
a502 13
extern __inline__ float sqrtf (float x)
{
  float res;
  __asm__ ("fsqrt" : "=t" (res) : "0" (x));
  return res;
}

extern __inline__ long double sqrtl (long double x)
{
  long double res;
  __asm__ ("fsqrt" : "=t" (res) : "0" (x));
  return res;
}
@


1.6.2.1
log
@	* include/math.h: Use C++ c-header compatability defines.

	* mingwex.math/fpclassify.c: Add non-underscored alias.
	* mingwex.math/fpclassifyf.c: Likewise.
	* mingwex.math/fpclassifyl.c: Likewise.
@
text
@d83 4
a86 1
__BEGIN_CGLOBAL_NAMESPACE
a130 2
__END_CGLOBAL_NAMESPACE
__BEGIN_CSTD_NAMESPACE
a166 3
__END_CSTD_NAMESPACE
__BEGIN_CGLOBAL_NAMESPACE

a231 1
/* FIXME: Should 99 math functions go into namespace std? */
d370 1
a370 1
  {return (float) __CSTD sinh (x);}
d374 1
a374 1
  {return (float) __CSTD cosh (x);}
d378 1
a378 1
  {return (float) __CSTD tanh (x);}
d387 1
a387 1
  {return (float) __CSTD exp (x);}
d399 1
a399 1
  {return (float) __CSTD frexp (x, expn);}
d411 1
a411 1
  {return (float) __CSTD ldexp (x, expn);}
d503 1
a503 1
  {return (float) __CSTD pow (x, y);}
a741 1
__END_CGLOBAL_NAMESPACE
d743 3
@


1.6.2.2
log
@	* include/cytpe.h: Prefix identifiers used as args of inlines
	with '__', throughout.
	* include/inttypes.h: Likewise.
	* include/math.h: Likewise.
	* include/stdio.h: Likewise.
	* include/stdlib.h: Likewise.
	* include/wchar.h: Likewise.
	* include/wctype.h: Likewise.
@
text
@d146 1
a146 1
extern __inline__  double sqrt (double __x)
d149 1
a149 1
  __asm__ ("fsqrt;" : "=t" (res) : "0" (__x));
d155 1
a155 1
extern __inline__  double fabs (double __x)
d158 1
a158 1
  __asm__ ("fabs;" : "=t" (res) : "0" (__x));
d169 1
d245 1
d260 1
d271 1
a271 1
extern __inline__ int __fpclassifyl (long double __x){
d273 1
a273 1
  __asm__ ("fxam; fstsw %%ax;" : "=a" (sw): "t" (__x));
d277 3
a279 3
#define fpclassify(__x) (sizeof (__x) == sizeof (float) ? __fpclassifyf (__x)	  \
		       : sizeof (__x) == sizeof (double) ? __fpclassify (__x) \
		       : __fpclassifyl (__x))
d282 1
a282 1
#define isfinite(__x) ((fpclassify(__x) & FP_NAN) == 0)
d285 1
a285 1
#define isinf(__x) (fpclassify(__x) == FP_INFINITE)
d291 1
a291 1
extern __inline__ int __isnan (double __x)
d295 1
a295 1
	   "fstsw %%ax": "=a" (sw) : "t" (__x));
d300 1
a300 1
extern __inline__ int __isnanf (float __x)
d304 1
a304 1
	    "fstsw %%ax": "=a" (sw) : "t" (__x));
d309 1
a309 1
extern __inline__ int __isnanl (long double __x)
d313 1
a313 1
	    "fstsw %%ax": "=a" (sw) : "t" (__x));
d319 3
a321 3
#define isnan(__x) (sizeof (__x) == sizeof (float) ? __isnanf (__x)	\
		  : sizeof (__x) == sizeof (double) ? __isnan (__x)	\
		  : __isnanl (__x))
d324 1
a324 1
#define isnormal(__x) (fpclassify(__x) == FP_NORMAL)
d327 1
a327 1
extern __inline__ int __signbit (double __x) {
d329 1
a329 1
  __asm__ ( "fxam; fstsw %%a__x;": "=a" (stw) : "t" (__x));
d333 1
a333 1
extern  __inline__ int __signbitf (float __x) {
d335 1
a335 1
  __asm__ ("fxam; fstsw %%a__x;": "=a" (stw) : "t" (__x));
d338 1
a338 1
extern  __inline__ int __signbitl (long double __x) {
d340 1
a340 1
  __asm__ ("fxam; fstsw %%a__x;": "=a" (stw) : "t" (__x));
d345 3
a347 3
#define signbit(__x) (sizeof (__x) == sizeof (float) ? __signbitf (__x)	\
		    : sizeof (__x) == sizeof (double) ? __signbit (__x)	\
		    : __signbitl (__x))
d372 2
a373 2
extern __inline__ float sinhf (float __x)
  {return (float) __CSTD sinh (__x);}
d376 2
a377 2
extern __inline__ float coshf (float __x)
  {return (float) __CSTD cosh (__x);}
d380 2
a381 2
extern __inline__ float tanhf (float __x)
  {return (float) __CSTD tanh (__x);}
d389 2
a390 2
extern __inline__ float expf (float __x)
  {return (float) __CSTD exp (__x);}
d401 2
a402 2
extern __inline__ float frexpf (float __x, int* __expn)
  {return (float) __CSTD frexp (__x, __expn);}
d413 2
a414 2
extern __inline__ float ldexpf (float __x, int __expn)
  {return (float) __CSTD ldexp (__x, __expn);}
d440 1
a440 1
extern __inline__ double logb (double __x)
d444 1
a444 1
       "fstp	%%st" : "=t" (res) : "0" (__x));
d448 1
a448 1
extern __inline__ float logbf (float __x)
d452 1
a452 1
       "fstp	%%st" : "=t" (res) : "0" (__x));
d456 1
a456 1
extern __inline__ long double logbl (long double __x)
d460 1
a460 1
       "fstp	%%st" : "=t" (res) : "0" (__x));
d484 1
a484 1
extern __inline__ float fabsf (float __x)
d487 1
a487 1
  __asm__ ("fabs;" : "=t" (res) : "0" (__x));
d491 1
a491 1
extern __inline__ long double fabsl (long double __x)
d494 1
a494 1
  __asm__ ("fabs;" : "=t" (res) : "0" (__x));
d500 2
a501 2
extern __inline__ float hypotf (float __x, float __y)
  { return (float) hypot (__x, __y);}
d505 2
a506 2
extern __inline__ float powf (float __x, float __y)
  {return (float) __CSTD pow (__x, __y);}
d510 1
a510 1
extern __inline__ float sqrtf (float __x)
d513 1
a513 1
  __asm__ ("fsqrt" : "=t" (res) : "0" (__x));
d517 1
a517 1
extern __inline__ long double sqrtl (long double __x)
d520 1
a520 1
  __asm__ ("fsqrt" : "=t" (res) : "0" (__x));
d541 1
a541 1
extern __inline__ double rint (double __x)
d544 1
a544 1
  __asm__ ("frndint;": "=t" (retval) : "0" (__x));
d548 1
a548 1
extern __inline__ float rintf (float __x)
d551 1
a551 1
  __asm__ ("frndint;" : "=t" (retval) : "0" (__x) );
d555 1
a555 1
extern __inline__ long double rintl (long double __x)
d558 1
a558 1
  __asm__ ("frndint;" : "=t" (retval) : "0" (__x) );
d563 1
a563 1
extern __inline__ long lrint (double __x) 
d567 1
a567 1
    ("fistpl %0"  : "=m" (retval) : "t" (__x) : "st");				      \
d571 1
a571 1
extern __inline__ long lrintf (float __x) 
d575 1
a575 1
    ("fistpl %0"  : "=m" (retval) : "t" (__x) : "st");				      \
d579 1
a579 1
extern __inline__ long lrintl (long double __x) 
d583 1
a583 1
    ("fistpl %0"  : "=m" (retval) : "t" (__x) : "st");				      \
d587 1
a587 1
extern __inline__ long long llrint (double __x) 
d591 1
a591 1
    ("fistpll %0"  : "=m" (retval) : "t" (__x) : "st");				      \
d595 1
a595 1
extern __inline__ long long llrintf (float __x) 
d599 1
a599 1
    ("fistpll %0"  : "=m" (retval) : "t" (__x) : "st");				      \
d603 1
a603 1
extern __inline__ long long llrintl (long double __x) 
d607 1
a607 1
    ("fistpll %0"  : "=m" (retval) : "t" (__x) : "st");				      \
d672 3
a674 3
extern double fdim (double __x, double __y);
extern float fdimf (float __x, float __y);
extern long double fdiml (long double __x, long double __y);
d697 1
d709 6
a714 6
#define isgreater(__x, __y) __builtin_isgreater(__x, __y)
#define isgreaterequal(__x, __y) __builtin_isgreaterequal(__x, __y)
#define isless(__x, __y) __builtin_isless(__x, __y)
#define islessequal(__x, __y) __builtin_islessequal(__x, __y)
#define islessgreater(__x, __y) __builtin_islessgreater(__x, __y)
#define isunordered(__x, __y) __builtin_isunordered(__x, __y)
d719 1
a719 1
__fp_unordered_compare (long double __x, long double __y){
d722 1
a722 1
	   "fnstsw;": "=a" (retval) : "t" (__x), "u" (__y));
d726 1
a726 1
#define isgreater(__x, __y) ((__fp_unordered_compare(__x, __y) \
d728 1
a728 1
#define isless(__x, __y) ((__fp_unordered_compare (__y, __x) \
d730 1
a730 1
#define isgreaterequal(__x, __y) ((__fp_unordered_compare (__x, __y) \
d732 1
a732 1
#define islessequal(__x, __y) ((__fp_unordered_compare(__y, __x) \
d734 1
a734 1
#define islessgreater(__x, __y) ((__fp_unordered_compare(__x, __y) \
d736 1
a736 1
#define isunordered(__x, __y) ((__fp_unordered_compare(__x, __y) \
a745 1

@


1.6.2.3
log
@	* include/math.h (__signbit); Remove errant '__' added in last
	patch.
 	* include/wctype.h: Add missing space before __wc, throughout.
	(is_wctype): Move into non-ANSI space.
@
text
@d326 1
a326 1
  __asm__ ( "fxam; fstsw %%ax;": "=a" (stw) : "t" (__x));
d332 1
a332 1
  __asm__ ("fxam; fstsw %%ax;": "=a" (stw) : "t" (__x));
d337 1
a337 1
  __asm__ ("fxam; fstsw %%ax;": "=a" (stw) : "t" (__x));
@


1.6.2.4
log
@	Merge from mingw trunk (changes since 2002-11-19).
@
text
@a60 16
/* Traditional/XOPEN math constants (double precison) */
#ifndef __STRICT_ANSI__
#define M_E		2.7182818284590452354
#define M_LOG2E		1.4426950408889634074
#define M_LOG10E	0.43429448190325182765
#define M_LN2		0.69314718055994530942
#define M_LN10		2.30258509299404568402
#define M_PI		3.14159265358979323846
#define M_PI_2		1.57079632679489661923
#define M_PI_4		0.78539816339744830962
#define M_1_PI		0.31830988618379067154
#define M_2_PI		0.63661977236758134308
#define M_2_SQRTPI	1.12837916709551257390
#define M_SQRT2		1.41421356237309504880
#define M_SQRT1_2	0.70710678118654752440
#endif
d146 6
d507 13
a519 2
extern float sqrtf (float);
extern long double sqrtl (long double);
d521 1
a521 23
/* 7.12.8.1 The erf functions  */
extern double erf (double);
extern float erff (float);
/* TODO
extern long double erfl (long double);
*/ 

/* 7.12.8.2 The erfc functions  */
extern double erfc (double);
extern float erfcf (float);
/* TODO
extern long double erfcl (long double);
*/ 

/* 7.12.8.3 The lgamma functions */
extern double lgamma (double);
extern float lgammaf (float);
extern long double lgammal (long double);

/* 77.12.8.4 The tgamma functions */
extern double tgamma (double);
extern float tgammaf (float);
extern long double tgammal (long double);
@


1.6.2.5
log
@	Merge from mingw trunk (changes since 2002-12-10).
@
text
@d539 1
a539 1
/* 7.12.8.4 The tgamma functions */
@


1.6.2.6
log
@	Merge from mingw trunk (changes since 2003-01-27).
@
text
@d147 19
a165 19
_CRTIMP double __cdecl sin (double);
_CRTIMP double __cdecl cos (double);
_CRTIMP double __cdecl tan (double);
_CRTIMP double __cdecl sinh (double);
_CRTIMP double __cdecl cosh (double);
_CRTIMP double __cdecl tanh (double);
_CRTIMP double __cdecl asin (double);
_CRTIMP double __cdecl acos (double);
_CRTIMP double __cdecl atan (double);
_CRTIMP double __cdecl atan2 (double, double);
_CRTIMP double __cdecl exp (double);
_CRTIMP double __cdecl log (double);
_CRTIMP double __cdecl log10 (double);
	double __cdecl pow (double, double);
_CRTIMP double __cdecl sqrt (double);
_CRTIMP double __cdecl ceil (double);
_CRTIMP double __cdecl floor (double);
_CRTIMP double __cdecl fabs (double);
extern __inline__ __cdecl double fabs (double __x)
d171 4
a174 4
_CRTIMP double __cdecl ldexp (double, int);
_CRTIMP double __cdecl frexp (double, int*);
_CRTIMP double __cdecl modf (double, double*);
_CRTIMP double __cdecl fmod (double, double);
d188 1
a188 1
_CRTIMP double __cdecl _cabs (struct _complex);
d190 8
a197 8
_CRTIMP double __cdecl _hypot (double, double);
_CRTIMP double __cdecl _j0 (double);
_CRTIMP double __cdecl _j1 (double);
_CRTIMP double __cdecl _jn (int, double);
_CRTIMP double __cdecl _y0 (double);
_CRTIMP double __cdecl _y1 (double);
_CRTIMP double __cdecl _yn (int, double);
_CRTIMP int __cdecl _matherr (struct _exception *);
d206 9
a214 9
_CRTIMP double __cdecl _chgsign (double);
_CRTIMP double __cdecl _copysign (double, double);
_CRTIMP double __cdecl _logb (double);
_CRTIMP double __cdecl _nextafter (double, double);
_CRTIMP double __cdecl _scalb (double, long);

_CRTIMP int __cdecl _finite (double);
_CRTIMP int __cdecl _fpclass (double);
_CRTIMP int __cdecl _isnan (double);
d226 12
a237 12
_CRTIMP double __cdecl cabs (struct _complex);
_CRTIMP double __cdecl j0 (double);
_CRTIMP double __cdecl j1 (double);
_CRTIMP double __cdecl jn (int, double);
_CRTIMP double __cdecl y0 (double);
_CRTIMP double __cdecl y1 (double);
_CRTIMP double __cdecl yn (int, double);

_CRTIMP double __cdecl chgsign	(double);
_CRTIMP double __cdecl scalb (double, long);
_CRTIMP int __cdecl finite (double);
_CRTIMP int __cdecl fpclass (double);
d247 1
a247 1
	|| !defined __STRICT_ANSI__ || defined __GLIBCPP__
d275 2
a276 2
extern int __cdecl __fpclassifyf (float);
extern int __cdecl __fpclassify (double);
d278 1
a278 1
extern __inline__ __cdecl int __fpclassifyl (long double __x){
d284 3
a286 3
#define fpclassify(__x) (sizeof (__x) == sizeof (float) ? __fpclassifyf (__x)	 \
		        : sizeof (__x) == sizeof (double) ? __fpclassify (__x) \
		        : __fpclassifyl (__x))
d298 1
a298 1
extern __inline__ __cdecl int __isnan (double __x)
d307 1
a307 1
extern __inline__ __cdecl int __isnanf (float __x)
d316 1
a316 1
extern __inline__ __cdecl int __isnanl (long double __x)
d334 1
a334 1
extern __inline__ int __cdecl __signbit (double __x) {
d340 1
a340 1
extern __inline__ int __cdecl __signbitf (float __x) {
d345 1
a345 1
extern __inline__ int __cdecl __signbitl (long double __x) {
d357 2
a358 2
extern float __cdecl sinf (float);
extern long __cdecl double sinl (long double);
d360 2
a361 2
extern float __cdecl cosf (float);
extern long double __cdecl cosl (long double);
d363 2
a364 2
extern float __cdecl tanf (float);
extern long double __cdecl tanl (long double);
d366 2
a367 2
extern float __cdecl asinf (float);
extern long double __cdecl asinl (long double);
d369 1
a369 1
extern float __cdecl acosf (float);
d372 1
a372 1
extern float __cdecl atanf (float);
d375 2
a376 2
extern float __cdecl atan2f (float, float);
extern long double __cdecl atan2l (long double, long double);
d379 1
a379 1
extern __inline__ float __cdecl sinhf (float __x)
d381 1
a381 1
extern long double __cdecl sinhl (long double);
d383 1
a383 1
extern __inline__ float __cdecl coshf (float __x)
d385 1
a385 1
extern long double __cdecl coshl (long double);
d387 1
a387 1
extern __inline__  float __cdecl tanhf (float __x)
d389 1
a389 1
extern long double __cdecl tanhl (long double);
d396 1
a396 1
extern __inline__  float __cdecl expf (float __x)
d398 1
a398 1
extern long double  __cdecl expl (long double);
d401 3
a403 3
extern double __cdecl exp2(double);
extern float __cdecl  exp2f(float);
extern long double  __cdecl exp2l(long double);
d408 1
a408 1
extern __inline__ float __cdecl frexpf (float __x, int* __expn)
d410 1
a410 1
extern long double  __cdecl frexpl (long double, int*);
d415 3
a417 3
extern int __cdecl ilogb (double);
extern int __cdecl ilogbf (float);
extern int __cdecl ilogbl (long double);
d420 1
a420 1
extern __inline__  float __cdecl ldexpf (float __x, int __expn)
d422 1
a422 1
extern long double  __cdecl ldexpl (long double, int);
d425 2
a426 2
extern float __cdecl  logf (float);
extern long double  __cdecl logl (long double);
d429 2
a430 2
extern float __cdecl  log10f (float);
extern long double  __cdecl log10l (long double);
d433 3
a435 3
extern double __cdecl log1p(double);
extern float __cdecl  log1pf(float);
extern long double  __cdecl log1pl(long double);
d438 3
a440 3
extern double __cdecl log2 (double);
extern float __cdecl  log2f (float);
extern long double  __cdecl log2l (long double);
d443 3
a445 3
extern double __cdecl logb (double);
extern float __cdecl  logbf (float);
extern long double  __cdecl logbl (long double);
d447 1
a447 1
extern __inline__ double __cdecl logb (double __x)
d455 1
a455 1
extern __inline__  float __cdecl logbf (float __x)
d463 1
a463 1
extern __inline__ long double __cdecl logbl (long double __x)
d472 2
a473 2
extern float __cdecl  modff (float, float*);
extern long double  __cdecl modfl (long double, long double*);
d476 7
a482 7
extern double __cdecl scalbn (double, int);
extern float __cdecl  scalbnf (float, int);
extern long double  __cdecl scalbnl (long double, int);

extern double __cdecl scalbln (double, long);
extern float __cdecl  scalblnf (float, long);
extern long double __cdecl scalblnl (long double, long);
d486 3
a488 3
extern double __cdecl cbrt (double);
extern float __cdecl  cbrtf (float);
extern long double  __cdecl cbrtl (long double);
d491 1
a491 1
extern __inline__  float __cdecl fabsf (float __x)
d498 1
a498 1
extern __inline__  long double __cdecl fabsl (long double __x)
d506 2
a507 2
extern double __cdecl hypot (double, double); /* in libmoldname.a */
extern __inline__  float __cdecl hypotf (float __x, float __y)
d509 1
a509 1
extern long double  __cdecl hypotl (long double, long double);
d512 1
a512 1
extern __inline__  float __cdecl powf (float __x, float __y)
d514 1
a514 1
extern long double  __cdecl powl (long double, long double);
d517 2
a518 2
extern float __cdecl  sqrtf (float);
extern long double  __cdecl sqrtl (long double);
d521 2
a522 2
extern double __cdecl erf (double);
extern float __cdecl  erff (float);
d524 1
a524 1
extern long double  __cdecl erfl (long double);
d528 2
a529 2
extern double __cdecl erfc (double);
extern float __cdecl  erfcf (float);
d531 1
a531 1
extern long double  __cdecl erfcl (long double);
d535 3
a537 3
extern double __cdecl lgamma (double);
extern float __cdecl  lgammaf (float);
extern long double  __cdecl lgammal (long double);
d540 3
a542 3
extern double __cdecl tgamma (double);
extern float __cdecl  tgammaf (float);
extern long double  __cdecl tgammal (long double);
d545 2
a546 2
extern float __cdecl  ceilf (float);
extern long double  __cdecl ceill (long double);
d549 2
a550 2
extern float __cdecl  floorf (float);
extern long double  __cdecl floorl (long double);
d553 3
a555 3
extern double __cdecl nearbyint ( double);
extern float __cdecl  nearbyintf (float);
extern long double  __cdecl nearbyintl (long double);
d559 1
a559 1
extern __inline__  double __cdecl rint (double __x)
d566 1
a566 1
extern __inline__  float __cdecl rintf (float __x)
d573 1
a573 1
extern __inline__  long double __cdecl rintl (long double __x)
d581 1
a581 1
extern __inline__  long  __cdecl lrint (double __x) 
d589 1
a589 1
extern __inline__  long  __cdecl lrintf (float __x) 
d597 1
a597 1
extern __inline__  long __cdecl lrintl (long double __x) 
d605 1
a605 1
extern __inline__  long  long __cdecl llrint (double __x) 
d613 1
a613 1
extern __inline__  long  long __cdecl llrintf (float __x) 
d621 1
a621 1
extern __inline__  long  long __cdecl llrintl (long double __x) 
d631 3
a633 3
extern double __cdecl round (double);
extern float __cdecl roundf (float);
extern long double __cdecl roundl (long double);
d636 7
a642 7
extern long __cdecl lround (double);
extern long __cdecl lroundf (float);
extern long __cdecl lroundl (long double);

extern long long __cdecl llround (double);
extern long long __cdecl llroundf (float);
extern long long __cdecl llroundl (long double);
d646 3
a648 3
extern double __cdecl trunc (double);
extern float __cdecl truncf (float);
extern long double __cdecl truncl (long double);
d651 2
a652 2
extern float __cdecl fmodf (float, float);
extern long double __cdecl fmodl (long double, long double);
d655 3
a657 3
extern double __cdecl remainder (double, double);
extern float __cdecl remainderf (float, float);
extern long double __cdecl remainderl (long double, long double);
d660 3
a662 3
extern double __cdecl remquo(double, double, int *);
extern float __cdecl remquof(float, float, int *);
extern long double __cdecl remquol(long double, long double, int *);
d665 3
a667 3
extern double __cdecl copysign (double, double); /* in libmoldname.a */
extern float __cdecl copysignf (float, float);
extern long double __cdecl copysignl (long double, long double);
d670 3
a672 3
extern double __cdecl nan(const char *tagp);
extern float __cdecl nanf(const char *tagp);
extern long double __cdecl nanl(const char *tagp);
d681 2
a682 2
extern double __cdecl nextafter (double, double); /* in libmoldname.a */
extern float __cdecl nextafterf (float, float);
d690 3
a692 3
extern double __cdecl fdim (double __x, double __y);
extern float __cdecl fdimf (float __x, float __y);
extern long double __cdecl fdiml (long double __x, long double __y);
d700 3
a702 3
extern double __cdecl fmax (double, double);
extern float __cdecl fmaxf (float, float);
extern long double __cdecl fmaxl (long double, long double);
d705 3
a707 3
extern double __cdecl fmin (double, double);
extern float __cdecl fminf (float, float);
extern long double __cdecl fminl (long double, long double);
d711 3
a713 3
extern double __cdecl fma (double, double, double);
extern float __cdecl fmaf (float, float, float);
extern long double __cdecl fmal (long double, long double, long double);
d735 1
a735 1
extern __inline__ int __cdecl
@


1.5
log
@Add incomplet long double math support to libmingwex.a
@
text
@d150 1
a150 1
  asm ("fsqrt" : "=t" (res) : "0" (x));
d159 1
a159 1
  asm ("fabs;" : "=t" (res) : "0" (x));
d235 1
a235 1
	|| !defined  __STRICT_ANSI__
d440 1
a440 1
  asm ("fxtract\n\t"
d448 1
a448 1
  asm ("fxtract\n\t"
d456 1
a456 1
  asm ("fxtract\n\t"
d484 1
a484 1
  asm ("fabs;" : "=t" (res) : "0" (x));
d491 1
a491 1
  asm ("fabs;" : "=t" (res) : "0" (x));
d498 1
a498 1
  { return (float) _hypot (x, y);}
d510 1
a510 1
  asm ("fsqrt" : "=t" (res) : "0" (x));
d517 1
a517 1
  asm ("fsqrt" : "=t" (res) : "0" (x));
@


1.4
log
@	* include/_mingw.h: Increment version to 2.0.
	* Makefile.in: Ditto.
	Merge in mingwex branch.
@
text
@d147 6
d156 6
d167 1
d170 1
a170 1
/* Complex number (for cabs) */
d178 1
a206 2
#if !defined (_NO_OLDNAMES)  \
   || (defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L )
d209 2
a210 3
 * Non-underscored versions of non-ANSI functions. These reside in
 * liboldnames.a. They are now also ISO C99 standand names.
 * Provided for extra portability.
d213 2
a215 1
double hypot (double, double);
d223 5
d230 1
a230 6
#endif	/* Not __STRICT_ANSI__ */

#ifdef __cplusplus
}
#endif
#endif	/* Not RC_INVOKED */
a233 5
#ifndef RC_INVOKED
#ifdef __cplusplus
extern "C" {
#endif

a236 1
#define INFINITY HUGE_VAL
d238 3
d242 2
a257 11
/* Return a  NaN */
double nan(const char *tagp);
float nanf(const char *tagp);
long double nanl(const char *tagp);

#ifndef __STRICT_ANSI__
#define nan() nan("")
#define nanf() nanf("")
#define nanl() nanl("")
#endif

d278 7
d287 1
d315 1
d320 1
a320 2
#define isfinite(x) ((fpclassify(x) & FP_NAN) == 0)
#define isinf(x) (fpclassify(x) == FP_INFINITE)
d323 1
a323 1

d346 141
a486 7
/* 
 *  With these functions, comparisons involving quiet NaNs set the FP
 *  condition code to "unordered".  The IEEE floating-point spec
 *  dictates that the result of floating-point comparisons should be
 *  false whenever a NaN is involved, with the exception of the !=, 
 *  which always returns true: yes, (NaN != NaN) is true).
 */
d488 17
a504 1
#if __GNUC__ >= 3
d506 7
a512 6
#define isgreater(x, y) __builtin_isgreater(x, y)
#define isgreaterequal(x, y) __builtin_isgreaterequal(x, y)
#define isless(x, y) __builtin_isless(x, y)
#define islessequal(x, y) __builtin_islessequal(x, y)
#define islessgreater(x, y) __builtin_islessgreater(x, y)
#define isunordered(x, y) __builtin_isunordered(x, y)
d514 5
a518 8
#else
/*  helper  */
extern  __inline__ int
__fp_unordered_compare (long double x, long double y){
  unsigned short retval;
  __asm__ ("fucom %%st(1);"
	   "fnstsw;": "=a" (retval) : "t" (x), "u" (y));
  return retval;
d521 9
a529 12
#define isgreater(x, y) ((__fp_unordered_compare(x, y) \
			   & 0x4500) == 0)
#define isless(x, y) ((__fp_unordered_compare (y, x) \
                       & 0x4500) == 0)
#define isgreaterequal(x, y) ((__fp_unordered_compare (x, y) \
                               & FP_INFINITE) == 0)
#define islessequal(x, y) ((__fp_unordered_compare(y, x) \
			    & FP_INFINITE) == 0)
#define islessgreater(x, y) ((__fp_unordered_compare(x, y) \
			      & FP_SUBNORMAL) == 0)
#define isunordered(x, y) ((__fp_unordered_compare(x, y) \
			    & 0x4500) == 0x4500)
d531 4
a534 1
#endif
d536 1
d538 1
a538 1
extern  __inline__ double rint (double x)
d545 1
a545 1
extern  __inline__ float rintf (float x)
d552 1
a552 1
extern  __inline__ long double rintl (long double x)
d559 50
d614 8
d623 1
d629 43
d678 1
d683 1
d688 1
a693 10
/*  x > y ? (x - y) : 0.0  */
extern double fdim (double, double);
extern float fdimf (float, float);
extern long double fdiml (long double, long double);

/* one lonely transcendental */
extern double log2 (double _x);
extern float log2f (float _x);
extern long double log2l (long double _x);
#endif /* __STDC_VERSION__ >= 199901L */
d695 42
a737 2
/* The underscored versions for double are in MSVCRT.dll.
   The stubs for float and double versions are in libmingwex.a */
d739 2
a740 10
double copysign (double, double);
float copysignf (float, float);
long double copysignl (long double, long double);

double logb (double);
float logbf (float);
double nextafter (double, double);
float nextafterf (float, float);
double scalb (double, long);
float scalbf (float, long);
a741 18
#if !defined (__STRICT_ANSI__)  /* inline using non-ANSI functions */
extern  __inline__ double copysign (double x, double y)
	{ return _copysign(x, y); }
extern  __inline__ float copysignf (float x, float y)
	{ return  _copysign(x, y); } 
extern  __inline__ double logb (double x)
	{ return _logb(x); }
extern  __inline__ float logbf (float x)
	{ return  _logb(x); }
extern  __inline__ double nextafter(double x, double y)
	{ return _nextafter(x, y); }
extern  __inline__ float nextafterf(float x, float y)
	{ return _nextafter(x, y); }
extern  __inline__ double scalb (double x, long i)
	{ return _scalb (x, i); }
extern  __inline__ float scalbf (float x, long i)
	{ return _scalb(x, i); }
#endif /* (__STRICT_ANSI__)  */
a747 1
#endif /* __NO_ISOCEXT */
a749 1

@


1.3
log
@	* include/math.h (DOMAIN, SING, OVERFLOW, UNDERFLOW,
	TLOSS, PLOSS): Move oldname defines back, following
	the underscored names.
@
text
@d67 1
d101 2
a102 2
extern double*	__imp__HUGE;
#define	HUGE_VAL	(*__imp__HUGE)
d105 2
a106 2
extern double*	__imp__HUGE_dll;
#define	HUGE_VAL	(*__imp__HUGE_dll)
a154 1

d193 2
a194 1
#ifndef	_NO_OLDNAMES
d198 2
a199 1
 * liboldnames.a. Provided for extra portability.
d201 1
d218 161
d380 100
d481 2
@


1.2
log
@Merge MinGW CVS differences
@
text
@d49 12
d64 1
a77 11

#ifndef	_NO_OLDNAMES

#define	DOMAIN		_DOMAIN
#define	SING		_SING
#define	OVERFLOW	_OVERFLOW
#define	UNDERFLOW	_UNDERFLOW
#define	TLOSS		_TLOSS
#define	PLOSS		_PLOSS

#endif	/* Not _NO_OLDNAMES */
a78 1

@


1.2.10.1
log
@Added fenv.h inttypes.h
@
text
@a53 1
/* IEEE 754 classication */
a175 20

/* Set the FPU control word as cw = (cw & ~unMask) | (unNew & unMask),
 * i.e. change the bits in unMask to have the values they have in unNew,
 * leaving other bits unchanged. */
unsigned int	_controlfp (unsigned int unNew, unsigned int unMask);
unsigned int	_control87 (unsigned int unNew, unsigned int unMask);


unsigned int	_clearfp ();	/* Clear the FPU status word */
unsigned int	_statusfp ();	/* Report the FPU status word */
#define		_clear87	_clearfp
#define		_status87	_statusfp

void		_fpreset ();	/* Reset the FPU */
void		fpreset ();

/* Global 'variable' for the current floating point error code. */
int *	__fpecode();
#define	_fpecode	(*(__fpecode()))

d192 1
a192 2
#if !defined (_NO_OLDNAMES)  \
   || (defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L )
d196 1
a196 2
 * liboldnames.a. They are now also ISO C99 standand names.
 * Provided for extra portability.
a197 1

a213 137
#endif	/* Not RC_INVOKED */


#ifndef __NO_ISOCEXT

#define INFINITY HUGE_VAL

double nan(const char *tagp);
float nanf(const char *tagp);

#ifndef __STRICT_ANSI__
#define nan() nan("")
#define nanf() nanf("")
#endif

#define NAN (0.0F/0.0F)

/*
   Return values for fpclassify.
   These are based on Intel x87 fpu condition codes
   in the high byte of status word and differ from
   the return values for MS IEEE 754 extension _fpclass()
*/
#define FP_NAN		0x0100
#define FP_NORMAL	0x0400
#define FP_INFINITE	(FP_NAN | FP_NORMAL)
#define FP_ZERO		0x4000
#define FP_SUBNORMAL	(FP_NORMAL | FP_ZERO)
/* 0x0200 is signbit mask */

#ifndef RC_INVOKED
#ifdef __cplusplus
extern "C" {
#endif

/*
  We can't inline float, because we want to ensure truncation
  to semantic type before classification.  If we extend to long
  double, we will also need to make double extern only.
  (A normal long double value might become subnormal when 
  converted to double, and zero when converted to float.)
*/
extern __inline__ int __fpclassify (double x){
  unsigned short sw;
  __asm__ ("fxam; fstsw %%ax;" : "=a" (sw): "t" (x));
  return sw & (FP_NAN | FP_NORMAL | FP_ZERO );
}

extern int __fpclassifyf (float);

#define fpclassify(x) ((sizeof(x) == sizeof(float)) ? __fpclassifyf(x) \
		       :  __fpclassify(x))

/* We don't need to worry about trucation here:
   A NaN stays a NaN. */

extern __inline__ int __isnan (double _x)
{
  unsigned short sw;
  __asm__ ("fxam;"
	   "fstsw %%ax": "=a" (sw) : "t" (_x));
  return (sw & (FP_NAN | FP_NORMAL | FP_INFINITE | FP_ZERO | FP_SUBNORMAL))
    == FP_NAN;
}

extern __inline__ int __isnanf (float _x)
{
  unsigned short sw;
  __asm__ ("fxam;"
	    "fstsw %%ax": "=a" (sw) : "t" (_x));
  return (sw & (FP_NAN | FP_NORMAL | FP_INFINITE | FP_ZERO | FP_SUBNORMAL))
    == FP_NAN;
}

#define isnan(x) ((sizeof(x) == sizeof(float)) ? __isnanf(x) \
		       :  __isnan(x))


#define isfinite(x) ((fpclassify(x) & FP_NAN) == 0)
#define isinf(x) (fpclassify(x) == FP_INFINITE)
#define isnormal(x) (fpclassify(x) == FP_NORMAL)


extern __inline__ int __signbit (double x) {
  unsigned short stw;
  __asm__ ( "fxam; fstsw %%ax;": "=a" (stw) : "t" (x));
  return stw & 0x0200;
}

extern  __inline__ int __signbitf (float x) {
  unsigned short stw;
  __asm__ ("fxam; fstsw %%ax;": "=a" (stw) : "t" (x));
  return stw & 0x0200;
}

#define signbit(x) ((sizeof(x) == sizeof(float)) ? __signbitf(x) \
		    : __signbit(x))
/* 
 *  With these functions, comparisons involving quiet NaNs set the FP
 *  condition code to "unordered".  The IEEE floating-point spec
 *  dictates that the result of floating-point comparisons should be
 *  false whenever a NaN is involved, with the exception of the !=, 
 *  which always returns true.
 */

#if __GNUC__ >= 3

#define isgreater(x, y) __builtin_isgreater(x, y)
#define isgreaterequal(x, y) __builtin_isgreaterequal(x, y)
#define isless(x, y) __builtin_isless(x, y)
#define islessequal(x, y) __builtin_islessequal(x, y)
#define islessgreater(x, y) __builtin_islessgreater(x, y)
#define isunordered(x, y) __builtin_isunordered(x, y)

#else
/*  helper  */
extern  __inline__ int __fp_unordered_compare (double x,  double y){
  unsigned short retval;
  __asm__ ("fucom %%st(1);"
	   "fnstsw;": "=a" (retval) : "t" (x), "u" (y));
  return retval;
}

#define isgreater(x, y) ((__fp_unordered_compare(x, y) \
			   & 0x4500) == 0)
#define isless(x, y) ((__fp_unordered_compare (y, x) \
                       & 0x4500) == 0)
#define isgreaterequal(x, y) ((__fp_unordered_compare (x, y) \
                               & FP_INFINITE) == 0)
#define islessequal(x, y) ((__fp_unordered_compare(y, x) \
			    & FP_INFINITE) == 0)
#define islessgreater(x, y) ((__fp_unordered_compare(x, y) \
			      & FP_SUBNORMAL) == 0)
#define isunordered(x, y) ((__fp_unordered_compare(x, y) \
			    & 0x4500) == 0x4500)

#endif
a214 76
/* round, using fpu control word settings */
extern  __inline__ double rint (double x)
{
  double retval;
  __asm__ ("frndint;": "=t" (retval) : "0" (x));
  return retval;
}

extern  __inline__ float rintf (float x)
{
  float retval;
  __asm__ ("frndint;" : "=t" (retval) : "0" (x) );
  return retval;
}

/* round away from zero, regardless of fpu control word settings */
extern double round (double);
extern float roundf (float);

/* round towards zero, regardless of fpu control word settings */
extern double trunc (double);
extern float truncf (float);


/* fmax and fmin.
   NaN arguments are treated as missing data: if one argument is a NaN and the other numeric, then the
   these functions choose the numeric value.
*/

extern double fmax  (double, double);
extern double fmin (double, double);
extern float fmaxf (float, float);
float fminf (float, float);

/* return x * y + z as a ternary op */ 
extern double fma (double, double, double);
extern float fmaf (float, float, float);

/* one lonely transcendental */
extern double log2 (double _x);
extern float log2f (float _x);

/* The underscored versions are in MSVCRT.dll.
   The stubs for these are in libmingwex.a */

double copysign (double, double);
float copysignf (float, float);
double logb (double);
float logbf (float);
double nextafter (double, double);
float nextafterf (float, float);
double scalb (double, long);
float scalbf (float, long);

#if !defined (__STRICT_ANSI__)  /* inline using non-ANSI functions */
extern  __inline__ double copysign (double x, double y)
	{ return _copysign(x, y); }
extern  __inline__ float copysignf (float x, float y)
	{ return  _copysign(x, y); } 
extern  __inline__ double logb (double x)
	{ return _logb(x); }
extern  __inline__ float logbf (float x)
	{ return  _logb(x); }
extern  __inline__ double nextafter(double x, double y)
	{ return _nextafter(x, y); }
extern  __inline__ float nextafterf(float x, float y)
	{ return _nextafter(x, y); }
extern  __inline__ double scalb (double x, long i)
	{ return _scalb (x, i); }
extern  __inline__ float scalbf (float x, long i)
	{ return _scalb(x, i); }
#endif /* (__STRICT_ANSI__)  */

#ifdef __cplusplus
}
#endif
a215 2

#endif /* __NO_ISOCEXT */
@


1.2.10.2
log
@	* include/math.h (DOMAIN, SING, OVERFLOW, UNDERFLOW,
	TLOSS, PLOSS): Move oldname defines back, following
	the underscored names.
	(_controlfp, _control87, _clearfp, _statusfp, _fpreset,
	_fpecode): Remove prototypes copied from float.h.
	(nan, nanf): Move into block protected against RC_INVOKED
	and __cplusplus.
	* include/stdlib.h (_Exit): Change from static inline to
	extern inline.
	* mingwex/_Exit.c : New file.
	* mingwex/Makefile.in: Add _Exit.o to libmingwex.a.
@
text
@a48 12
#ifndef	_NO_OLDNAMES

#define	DOMAIN		_DOMAIN
#define	SING		_SING
#define	OVERFLOW	_OVERFLOW
#define	UNDERFLOW	_UNDERFLOW
#define	TLOSS		_TLOSS
#define	PLOSS		_PLOSS

#endif	/* Not _NO_OLDNAMES */
#endif	/* Not __STRICT_ANSI__ */

a51 1
#ifndef	__STRICT_ANSI__
d66 11
d79 1
d177 20
d244 9
a271 9

double nan(const char *tagp);
float nanf(const char *tagp);

#ifndef __STRICT_ANSI__
#define nan() nan("")
#define nanf() nanf("")
#endif

@


1.2.10.3
log
@	* CRT_fp8.c: New file.
	* CRT_fp10.c: New file.
	* crt1.c (__CRT_PC) Declare.
	(__CRT_fesetenv): New static function, using _CRT_PC.
	(__mingw_CRTStartup):Use __CRT_fesetenv instead of _fpreset.
	(_gnu_exception_handler): Likewise.
	* Makefile.in (CRT0S): Add CRT_fp10.o.
	(MINGW_OBJS): Add  CRT_fp8.o.
	(SRCDIST_FILES): Add CRT_fp8.c, CRT_fp10.c.
	Add CRT_fp8.o, CRT_fp10.o dependancies.
	* include/float.h (_fpreset): Expand comment.
	* include/fenv.h (FE_PC64_ENV): New define for Intel x87
	(extended precison) environmemt.
	(FE_PC53_ENV): New define for MSVCRT default environmemt.
	(FE_DFL_ENV): Define as FE_PC53_ENV.
	* mingwex/fesetenv.c: Use FE_PC53_ENV, FE_PC64_ENV to determine
	precision control for default environment.

	* include/math.h: Fix long comment line.
	* profile/configure.in (CRT0S): Set to both gcrt1.o and gcrt2.o
	for mingw.
	* profile/configure: Regenerate.
@
text
@d155 1
d382 2
a383 3
   NaN arguments are treated as missing data: if one argument is a NaN
   and the other numeric, then the these functions choose the numeric
   value.
@


1.2.10.4
log
@	* include/math.h (nanl, __fpcassifyl, fminl, fmaxl, rintl,
	roundl, truncl, fmal, log2l): Declare.
	Protect C99 declarations with _STDC_VERSION__ >= 199901L)
	|| !defined  __STRICT_ANSI__.
 	* mingwex/fmax.c (fmax): Call __isnan, not _isnan.
	* mingwex/fmin.c (fmin): Likewise.
	* mingwex/fmaxf.c (fmaxf): Call __isnanf, not _isnan.
	* mingwex/fminf.c (fminf): Likewise.
	* mingwex/fmaxl.c: New file.
	* mingwex/fminl.c: New file.
	* mingwex/fpclassify.c (__fpclassifyf): Split out to ...
	* mingwex/fpclassifyf.c: New file.
	* mingwex/fpclassifyl.c: New file.
	* mingwex/rint.c (rintf): Split out to...
	* mingwex/rintf.c: New file.
	* mingwex/rintl.c: New file.
	* mingwex/round.c (roundf): Split out to...
	* mingwex/roundf.c: New file.
	* mingwex/roundl.c: New file.
	* mingwex/trunc.c (truncf): Split out to...
	* mingwex/truncf.c: New file.
	* mingwex/truncl.c: New file.
	* mingwex/signbit.c (signbitf): Split out to...
	* mingwex/signbitf.c: New file.
	* mingwex/signbitl.c: New file.
	* mingwex/fmal.c: New file.
	* mingwex/copysignl.S: New file.
	* mingwex/log2l.c: New file.
	* mingwex/fp_consts.c: Add nanl definition.
	Comment out unused constants.
	* mingwex/Makefile.in (DISTFILES): Add fmaxl.c, fminl.c,
	fpclassifyf.c, fpclassifyl.c, rintf.c, rintl.c, roundf.c,
	roundl.c, truncf.c truncl.c, signbitf.c signbitl.c,
	fmal.c, copysignl.S, log2l.c
	(MATHOBJS): Add fmaxl.o, fminl.o, fpclassifyf.o,
	fpclassifyl.o, rintf.o, rintl.o, roundf.o, roundl.o,
	truncf.o truncl.o, signbitf.o signbitl.o, fmal.o,
	copysignl.o, log2l.o.
@
text
@a221 7
#ifndef RC_INVOKED
#ifdef __cplusplus
extern "C" {
#endif

#if (defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) \
	|| !defined  __STRICT_ANSI__
d239 4
a243 1
/* Return a  NaN */
a245 1
long double nanl(const char *tagp);
a249 1
#define nanl() nanl("")
d252 1
d254 3
a256 2
  We can't inline float or double, because we want to ensure truncation
  to semantic type before classification. 
d260 1
a260 5

extern int __fpclassifyf (float);
extern int __fpclassify (double);

extern __inline__ int __fpclassifyl (long double x){
d266 4
a269 3
#define fpclassify(x) (sizeof (x) == sizeof (float) ? __fpclassifyf (x)	  \
		       : sizeof (x) == sizeof (double) ? __fpclassify (x) \
		       : __fpclassifyl (x))
d273 1
d292 2
a293 8
extern __inline__ int __isnanl (long double _x)
{
  unsigned short sw;
  __asm__ ("fxam;"
	    "fstsw %%ax": "=a" (sw) : "t" (_x));
  return (sw & (FP_NAN | FP_NORMAL | FP_INFINITE | FP_ZERO | FP_SUBNORMAL))
    == FP_NAN;
}
a294 3
#define isnan(x) (sizeof (x) == sizeof (float) ? __isnanf (x)	\
		  : sizeof (x) == sizeof (double) ? __isnan (x)	\
		  : __isnanl (x))
a311 10
extern  __inline__ int __signbitl (long double x) {
  unsigned short stw;
  __asm__ ("fxam; fstsw %%ax;": "=a" (stw) : "t" (x));
  return stw & 0x0200;
}


#define signbit(x) (sizeof (x) == sizeof (float) ? __signbitf (x)	\
		    : sizeof (x) == sizeof (double) ? __signbit (x)	\
		    : __signbitl (x))
d313 2
d320 1
a320 1
 *  which always returns true: yes, (NaN != NaN) is true).
d334 1
a334 2
extern  __inline__ int
__fp_unordered_compare (long double x, long double y){
a370 7
extern  __inline__ long double rintl (long double x)
{
  long double retval;
  __asm__ ("frndint;" : "=t" (retval) : "0" (x) );
  return retval;
}

a373 2
extern long double roundl (long double);

a377 1
extern long double truncl (long double);
d382 3
a384 2
   and the other numeric, then these functions choose the numeric
   value. */
d387 1
d389 1
a389 5
extern long double fmaxl (long double, long double);

extern double fmin (double, double);
extern float fminf (float, float);
extern long double fminl (long double, long double);
a393 1
extern long double fmal (long double, long double, long double);
a397 3
extern long double log2l (long double _x);
#endif /* __STDC_VERSION__ >= 199901L */

@


1.2.10.5
log
@	Inadverantly left out in 2002-04-26 patch
	* include/math.h (copysignl): Declare.
	* mingwex/Makefile.in (DISTFILES): Add copysignl.S.
	(MATHOBJS):Add copysignl.o.
@
text
@d439 2
a440 2
/* The underscored versions for double are in MSVCRT.dll.
   The stubs for float and double versions are in libmingwex.a */
a443 2
long double copysignl (long double, long double);

@


1.2.10.6
log
@	* include/dos.h: Change  prefix "__imp_"  to "_imp__" for
	__GNUC__ without __DECLSPEC_SUPPORTED.
	* include/fnctl.h: Likewise.
	* include/math.h: Likewise.
	* include/stdio.h: Likewise.
	* include/stdlib.h: Likewise.
	* include/time.h: Likewise.
	* include/wctype.h: Likewise.
	* include/ctype.h: Likewise.
@
text
@d101 2
a102 2
extern double*	_imp___HUGE;
#define	HUGE_VAL	(*_imp___HUGE)
d105 2
a106 2
extern double*	_imp___HUGE_dll;
#define	HUGE_VAL	(*_imp___HUGE_dll)
@


1.2.10.7
log
@	* include/math.h (fdim, fdimf, fdiml): Add prototypes.
	* mingwex/fdim.c: New file.
	* mingwex/fdimf.c: New file.
	* mingwex/fdiml.c: New file.
	* mingwex/Makefile.in (DISTFILES): Add fdim.c, fdimf.c,
	fdiml.c.
	(MATHOBJS):Add fdim.o, fdimf.o. fdiml.o.
@
text
@a431 5
/*  x > y ? (x - y) : 0.0  */
extern double fdim (double, double);
extern float fdimf (float, float);
extern long double fdiml (long double, long double);

@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
 *  DISCLAMED. This includes but is not limited to warranties of
d49 17
d172 19
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
