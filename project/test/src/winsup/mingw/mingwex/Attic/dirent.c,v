head	1.14;
access;
symbols
	cygwin-1_7_17-release:1.13
	cygwin-64bit-branch:1.13.0.2
	cygwin-1_7_16-release:1.13
	cygwin-1_7_15-release:1.13
	cygwin-1_7_14_2-release:1.13
	cygwin-1_7_14-release:1.13
	cygwin-1_7_12-release:1.13
	cygwin-1_7_11-release:1.13
	cygwin-1_7_10-release:1.13
	cygwin-1_7_9-release:1.9
	cygwin-1_7_8-release:1.9
	cygwin-1_7_7-release:1.9
	cygwin-1_7_5-release:1.9
	cygwin-1_7_4-release:1.9
	cygwin-1_7_3-release:1.9
	cygwin-1_7_2-release:1.9
	cygwin-1_7_1-release:1.9
	cv-branch-2:1.9.0.6
	cr-0x5f1:1.9.0.4
	cv-branch:1.9.0.2
	cr-0x3b58:1.8.0.2
	cr-0x9e:1.6.0.4
	cr-0x9d:1.6.0.2
	corinna-01:1.6
	cr-0x9c:1.4.0.6
	cr-0x9b:1.4.0.4
	cr-0x99:1.4
	Z-emcb-cygwin_daemon:1.4.0.2
	w32api-2_2:1.2
	mingw-runtime-2_4:1.2
	mingw-std-ns-branch:1.2.0.6
	mingw-runtime-2_0:1.2
	mingwex:1.1.0.2;
locks; strict;
comment	@ * @;


1.14
date	2012.11.07.16.52.19;	author cgf;	state dead;
branches;
next	1.13;

1.13
date	2012.02.01.21.26.39;	author keithmarshall;	state Exp;
branches;
next	1.12;

1.12
date	2011.11.26.22.12.51;	author keithmarshall;	state Exp;
branches;
next	1.11;

1.11
date	2011.10.01.20.18.10;	author keithmarshall;	state Exp;
branches;
next	1.10;

1.10
date	2011.08.27.20.16.47;	author keithmarshall;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.18.08.43.34;	author dannysmith;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.24.10.26.37;	author dannysmith;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.20.22.49.32;	author earnie;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.02.21.29.51;	author dannysmith;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.22.21.32.52;	author dannysmith;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.18.13.54.47;	author earnie;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.17.01.03.43;	author dannysmith;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.13.10.20.44;	author dannysmith;	state Exp;
branches
	1.2.6.1;
next	1.1;

1.1
date	2002.03.22.22.43.17;	author dannysmith;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2002.03.22.22.43.17;	author dannysmith;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.04.18.10.35.41;	author dannysmith;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.04.23.01.59.05;	author dannysmith;	state Exp;
branches;
next	;

1.2.6.1
date	2003.03.31.22.32.19;	author dannysmith;	state Exp;
branches;
next	;


desc
@@


1.14
log
@* mingw: Delete obsolete directory.
* w32api: Ditto.
@
text
@/*
 * dirent.c
 *
 * This file has no copyright assigned and is placed in the Public Domain.
 *
 * This file is a part of the mingw-runtime package.
 * No warranty is given; refer to the file DISCLAIMER within the package.
 *
 * Derived from DIRLIB.C by Matt J. Weinstein 
 * This note appears in the DIRLIB.H
 * DIRLIB.H by M. J. Weinstein   Released to public domain 1-Jan-89
 *
 * Updated by Jeremy Bettis <jeremy@@hksys.com>
 * Significantly revised and rewinddir, seekdir and telldir added
 * by Colin Peters <colin@@fu.is.saga-u.ac.jp>
 * Further significantly revised for improved memory utilisation,
 * efficiency in operation, and better POSIX standards compliance
 * by Keith Marshall <keithmarshall@@users.sourceforge.net>
 *	
 */
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <io.h>
#include <dirent.h>

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <tchar.h>

#define DIRENT_RETURN_NOTHING
#define DIRENT_REJECT( chk, err, rtn )	\
  do { if( chk ){ errno = (err); return rtn; }} while(0)

union __dirstream_t
{
  /* Actual (private) declaration for opaque data type "DIR". */

  /* dirent struct to return from dir (NOTE: this makes this thread
   * safe as long as only one thread uses a particular DIR struct at
   * a time) */
  struct dirent	dd_dir;

  struct __dirstream_private_t
  {
    /* Three padding fields, matching the head of dd_dir...
     */
    long		dd_ino;		/* Always zero. */
    unsigned short	dd_reclen;	/* Always zero. */
    unsigned short	dd_namlen;	/* Length of name in d_name. */

    /* ...to keep the start of this disk transfer area for this dir
     * aligned at the offset of the dd_dir.d_type field
     */
    struct _finddata_t	dd_dta;

    /* _findnext handle */
    intptr_t		dd_handle;

    /* Status of search:
     *   (type is now int -- was short in older versions).
     *   0 = not started yet (next entry to read is first entry)
     *  -1 = off the end
     *   positive = 0 based index of next entry
     */
    int			dd_stat;

    /* given path for dir with search pattern (struct is extended) */
    char		dd_name[1];

  } dd_private;
};

union __wdirstream_t
{
  /* Actual (private) declaration for opaque data type "_WDIR". */

  /* dirent struct to return from dir (NOTE: this makes this thread
   * safe as long as only one thread uses a particular DIR struct at
   * a time) */
  struct _wdirent	dd_dir;

  struct __wdirstream_private_t
  {
    /* Three padding fields, matching the head of dd_dir...
     */
    long		dd_ino;		/* Always zero. */
    unsigned short	dd_reclen;	/* Always zero. */
    unsigned short	dd_namlen;	/* Length of name in d_name. */

    /* ...to keep the start of this disk transfer area for this dir
     * aligned at the offset of the dd_dir.d_type field
     */
    struct _wfinddata_t	dd_dta;

    /* _findnext handle */
    intptr_t		dd_handle;

    /* Status of search:
     *   0 = not started yet (next entry to read is first entry)
     *  -1 = off the end
     *   positive = 0 based index of next entry
     */
    int			dd_stat;

    /* given path for dir with search pattern (struct is extended) */
    wchar_t		dd_name[1];

  } dd_private;
};

/* We map the BSD d_type field in the returned dirent structure
 * from the Microsoft _finddata_t dd_dta.attrib bits, which are:
 *
 *   _A_NORMAL	(0x0000)	normal file: best fit for DT_REG
 *   _A_RDONLY	(0x0001)	read-only: no BSD d_type equivalent
 *   _A_HIDDEN	(0x0002)	hidden entity: no BSD equivalent
 *   _A_SYSTEM	(0x0004)	system entity: no BSD equivalent
 *   _A_VOLID	(0x0008)	volume label: no BSD equivalent
 *   _A_SUBDIR	(0x0010)	directory: best fit for DT_DIR
 *   _A_ARCH	(0x0020)	"dirty": no BSD equivalent
 *
 * Of these, _A_RDONLY, _A_HIDDEN, _A_SYSTEM, and _A_ARCH are
 * modifier bits, rather than true entity type specifiers; we
 * will ignore them in the mapping, by applying this mask:
 */
#define DT_IGNORED	(_A_RDONLY | _A_HIDDEN | _A_SYSTEM | _A_ARCH)

#define DIRENT_OPEN(D)	\
    ((D).dd_handle = _tfindfirst((D).dd_name, &((D).dd_dta)))

#define DIRENT_UPDATE(D)  \
    _tfindnext( (D).dd_handle, &(D).dd_dta )


/*****
 *
 * opendir()
 *
 * Returns a pointer to a DIR structure appropriately filled in
 * to begin searching a directory.
 *
 */
_TDIR * 
_topendir( const _TCHAR *path_name )
{
  _TDIR *nd;
  _TCHAR abs_path[MAX_PATH];
	
  /* Reject any request which passes a NULL or an empty path name;
   * note that POSIX doesn't specify the handling for the NULL case,
   * and some implementations may simply fail with a segmentation
   * fault.  We will fail more gracefully.  Previous versions used
   * EFAULT here, but EINVAL seems more appropriate; however, POSIX
   * specifies neither of these for any opendir() failure.
   */
  DIRENT_REJECT( (path_name == NULL), EINVAL, (_TDIR *)(NULL) );
  /*
   * Conversely, POSIX *does* specify ENOENT for the empty path
   * name case, where we previously had ENOTDIR; here, we correct
   * this previous anomaly.
   */
  DIRENT_REJECT( (*path_name == _T('\0')), ENOENT, (_TDIR *)(NULL) );

  /* Identify the absolute path name corresponding to the (maybe
   * relative) path name we are to process; (this ensures that we
   * may always refer back to this same path name, e.g. to rewind
   * the "directory stream", even after an intervening change of
   * current working directory).
   */
  _tfullpath( abs_path, path_name, MAX_PATH );

  /* Ensure that the generated absolute path name ends with a
   * directory separator (backslash) character, so that we may
   * correctly append a wild-card matching pattern which will
   * cause _findfirst() and _findnext() to return every entry
   * in the specified directory; (note that, for now we may
   * simply assume that abs_path refers to a directory;
   * we will verify that when we call _findfirst() on it).
   */
  if( *abs_path != _T('\0') )
    {
      size_t offset = _tcslen( abs_path ) - 1;
      if( (abs_path[offset] != _T('/')) && (abs_path[offset] != _T('\\')) )
	_tcscat( abs_path, _T("\\") );
    }

  /* Now append the "match everything" wild-card pattern.
   */
  _tcscat( abs_path, _T("*") );

  /* Allocate space to store DIR structure.  The size MUST be
   * adjusted to accommodate the complete absolute path name for
   * the specified directory, extended to include the wild-card
   * matching pattern, as above; (note that we DO NOT need any
   * special provision for the terminating NUL on the path name,
   * since the base size of the DIR structure includes it).
   */
  nd = (_TDIR *)(malloc(
	 sizeof( _TDIR ) + (_tcslen( abs_path ) * sizeof( _TCHAR ))
       ));

  /* Bail out, if insufficient memory.
   */ 
  DIRENT_REJECT( (nd == NULL), ENOMEM, (_TDIR *)(NULL) );

  /* Copy the extended absolute path name string into place
   * within the allocated space for the DIR structure.
   */
  _tcscpy( nd->dd_private.dd_name, abs_path );

  /* Initialize the "directory stream", by calling _findfirst() on it;
   * this leaves the data for the first directory entry in the internal
   * dirent buffer, ready to be retrieved by readdir().
   */
  if( DIRENT_OPEN( nd->dd_private ) == (intptr_t)(-1) )
    {
      /* The _findfirst() call, (implied by DIRENT_OPEN), failed;
       * _findfirst() sets EINVAL where POSIX mandates ENOTDIR...
       */
      if( errno == EINVAL )
	errno = ENOTDIR;

      /* ...otherwise, while it may not be strictly POSIX conformant,
       * just accept whatever value _findfirst() assigned to errno.  In
       * any event, prepare to return the NULL "directory stream"; since
       * this implies that we will lose our reference pointer to the
       * block of memory we allocated for the stream, free that
       * before we bail out.
       */
      free( nd );
      return (_TDIR *)(NULL);
    }

  /* Initialize the status, (i.e. the location index), so that
   * readdir() will simply return the first directory entry, which
   * has already been fetched by _findfirst(), without performing
   * an intervening _findnext() call.
   */
  nd->dd_private.dd_stat = 0;

  /* The d_ino and d_reclen fields have no relevance in MS-Windows;
   * initialize them to zero, as a one-time assignment for this DIR
   * instance, and henceforth forget them; (users should simply
   * ignore them).
   */
  nd->dd_dir.d_ino = 0;
  nd->dd_dir.d_reclen = 0;

  /* We've now completely initialized an instance of a DIR structure,
   * representing the requested "directory stream"; return a pointer
   * via which the caller may access it.
   */
  return nd;
}


/*****
 *
 * readdir()
 *
 * Return a pointer to a dirent structure filled in with information
 * on the next available entry, (if any), in the "directory stream".
 */
struct _tdirent *
_treaddir( _TDIR *dirp )
{
  /* Check for a valid DIR stream reference; (we can't really
   * be certain until we try to read from it, except in the case
   * of a NULL pointer reference).  Where we lack a valid reference,
   * POSIX mandates reporting EBADF; we previously had EFAULT, so
   * this version corrects the former anomaly.
   */ 
  DIRENT_REJECT( (dirp == NULL), EBADF, (struct _tdirent *)(NULL) );

  /* Okay to proceed.  If this is the first readdir() request
   * following an opendir(), or a rewinddir(), then we already
   * have the requisite return information...
   */
  if( dirp->dd_private.dd_stat++ > 0 )
    {
      /* Otherwise...
       *
       * Get the next search entry.  POSIX mandates that this must
       * return NULL after the last entry has been read, but that it
       * MUST NOT change errno in this case.  MS-Windows _findnext()
       * DOES change errno (to ENOENT) after the last entry has been
       * read, so we must be prepared to restore it to its previous
       * value, when no actual error has occurred.
       */
      int prev_errno = errno;
      if( DIRENT_UPDATE( dirp->dd_private ) != 0 )
	{
	  /* May be an error, or just the case described above...
	   */
	  if( GetLastError() == ERROR_NO_MORE_FILES )
	    /*
	     * ...which requires us to reset errno.
	     */
	    errno = prev_errno;	

	  /* In either case, there is no valid data to return.
	   */
	  return (struct _tdirent *)(NULL);
	}
    }

  /* Successfully got an entry.  Everything about the file is
   * already appropriately filled in, except for the length of
   * the file name in the d_namlen field...
   */
  dirp->dd_dir.d_namlen = _tcslen( dirp->dd_dir.d_name );
  /*
   * ...and the attributes returned in the dd_dta.attrib field;
   * these require adjustment to their BSD equivalents, which are
   * returned via the union with the dd_dir.d_type field:
   */
  switch( dirp->dd_dir.d_type &= ~DT_IGNORED )
    {
      case DT_REG:
      case DT_DIR:
	/* After stripping out the modifier bits in DT_IGNORED,
	 * (which we ALWAYS ignore), this pair require no further
	 * adjustment...
	 */
	break;

      default:
	/* ...while nothing else has an appropriate equivalent
	 * in the BSD d_type identification model.
	 */
	dirp->dd_dir.d_type = DT_UNKNOWN;
    }
  return &dirp->dd_dir;
}


/*****
 *
 * closedir()
 *
 * Frees up resources allocated by opendir().
 *
 */
int
_tclosedir( _TDIR * dirp )
{
  /* Attempting to reference a directory stream via a NULL pointer
   * would cause a segmentation fault; evade this.  Since NULL can
   * never represent an open directory stream, set the EBADF errno
   * status, as mandated by POSIX, once again correcting previous
   * anomalous use of EFAULT in this context.
   */
  DIRENT_REJECT(
      ((dirp == NULL) || (_findclose( dirp->dd_private.dd_handle ) != 0)),
	EBADF, -1
    );

  /* If we didn't bail out above, we have a valid DIR structure
   * with which we have finished; release the memory allocated
   * to it, before returning "success".
   */
  free( dirp );
  return 0;
}


/*****
 *
 * rewinddir()
 *
 * Return to the beginning of the directory "stream".  We simply call
 * _findclose(), to clear prior context, then _findfirst() to restart
 * the directory search, resetting the location index appropriately,
 * as it would be left by opendir().
 *
 */
void
_trewinddir( _TDIR * dirp )
{
  /* This is an XSI extension to POSIX, which specifies no formal
   * error conditions; we will continue to check for and evade the
   * potential segmentation fault which would result from passing a
   * NULL reference pointer.  For consistency with the core functions
   * implemented above, we will again report this as EBADF, rather
   * than the EFAULT of previous versions.
   */
  DIRENT_REJECT(
      ((dirp == NULL) || (_findclose( dirp->dd_private.dd_handle ) != 0)),
	EBADF, DIRENT_RETURN_NOTHING
    );
  
  /* We successfully closed the prior search context; reopen...
   */
  if( DIRENT_OPEN( dirp->dd_private ) != (intptr_t)(-1) )
    /*
     * ...and, on success, reset the location index.
     */
    dirp->dd_private.dd_stat = 0;
}


/*****
 *
 * telldir()
 *
 * Returns the "position" in the "directory stream" which can then
 * be passed to seekdir(), to return back to a previous entry.  We
 * simply return the current location index from the dd_stat field.
 *
 */
long
_ttelldir( _TDIR * dirp )
{
  /* This too is a POSIX-XSI extension, with no mandatory error
   * conditions.  Once again, evade a potential segmentation fault
   * on passing a NULL reference pointer, again reporting it as
   * EBADF in preference to the EFAULT of previous versions.
   */
  DIRENT_REJECT( (dirp == NULL), EBADF, -1 );

  /* We didn't bail out; just assume dirp is valid, and return
   * the location index from the dd_stat field.
   */
  return dirp->dd_private.dd_stat;
}


/*****
 *
 * seekdir()
 *
 * Seek to an entry previously returned by telldir().  We rewind
 * the "directory stream", then repeatedly call _findnext() while
 * incrementing its internal location index until it matches the
 * position requested, or we reach the end of the stream.  This is
 * not perfect, in that the directory may have changed while we
 * weren't looking, but it is the best we can achieve, and may
 * likely reproduce the behaviour of other implementations.
 *
 */
void
_tseekdir( _TDIR * dirp, long loc )
{
  /* Another POSIX-XSI extension, with no specified mandatory
   * error conditions; we require a seek location of zero or
   * greater, and will reject less than zero as EINVAL...
   */
  DIRENT_REJECT( (loc < 0L), EINVAL, DIRENT_RETURN_NOTHING );

  /* Other than this, we simply accept any error condition
   * which arises as we "rewind" the "directory stream"...
   */
  _trewinddir( dirp );

  /* ...and, if this is successful...
   */
  if( (loc > 0) && (dirp->dd_private.dd_handle != (intptr_t)(-1)) )
    /*
     * ...seek forward until the location index within
     * the DIR structure matches the requested location.
     */
    while( (++dirp->dd_private.dd_stat < loc)
      &&   (DIRENT_UPDATE( dirp->dd_private ) == 0)  )
      ;
}

/* $RCSfile: dirent.c,v $: end of file */
@


1.13
log
@More performance enhancements and POSIX compliance corrections.
@
text
@d468 1
a468 1
/* $RCSfile$: end of file */
@


1.12
log
@Clean up DIRENT errno handling; make it more POSIX conformant.
@
text
@d5 1
d16 3
a20 1

a24 1
#include <direct.h>
d28 1
a28 2
#include <windows.h> /* for GetFileAttributes */

a29 2
#define SUFFIX	_T("*")
#define SLASH	_T("\\")
d129 6
a134 17
/* Helper for opendir().  */
static inline unsigned _tGetFileAttributes (const _TCHAR * tPath)
{
#ifdef _UNICODE
  /* GetFileAttributesW does not work on W9x, so convert to ANSI */
  if (_osver & 0x8000)
    {
      char aPath [MAX_PATH];
      WideCharToMultiByte (CP_ACP, 0, tPath, -1, aPath, MAX_PATH, NULL,
			   NULL);
      return GetFileAttributesA (aPath);
    }
  return GetFileAttributesW (tPath);
#else
  return GetFileAttributesA (tPath);
#endif
}
d136 6
a141 2
/*
 * opendir
a142 2
 * Returns a pointer to a DIR structure appropriately filled in to begin
 * searching a directory.
d145 1
a145 1
_topendir (const _TCHAR *szPath)
d148 1
a148 2
  unsigned int rc;
  _TCHAR szFullPath[MAX_PATH];
d153 3
a155 2
   * fault.  We will fail more gracefully; however, the choice of
   * EFAULT is not specified by POSIX, for any opendir failure.
d157 1
a157 1
  DIRENT_REJECT( (!szPath), EFAULT, (_TDIR *)(0) );
d163 1
a163 1
  DIRENT_REJECT( (*szPath == _T('\0')), ENOENT, (_TDIR *)(0) );
d165 5
a169 2
  /* Attempt to determine if the given path really is a directory.
   * On error, user may call GetLastError() for more error info
d171 1
a171 3
  DIRENT_REJECT( ((rc = _tGetFileAttributes (szPath)) == (unsigned int)(-1)),
      ENOENT, (_TDIR *)(0)
    );
d173 7
a179 1
  /* Error, entry exists but not a directory.
d181 6
a186 1
  DIRENT_REJECT( (!(rc & FILE_ATTRIBUTE_DIRECTORY)), ENOTDIR, (_TDIR *)(0) );
d188 3
a190 2
  /* Make an absolute pathname.  */
  _tfullpath (szFullPath, szPath, MAX_PATH);
d192 9
a200 5
  /* Allocate enough space to store DIR structure and the complete
   * directory path given. */
  nd = (_TDIR *)(malloc( sizeof( _TDIR )
	+ (_tcslen( szFullPath ) + _tcslen( SLASH ) + _tcslen( SUFFIX ) + 1)
	    * sizeof( _TCHAR )
d203 1
a203 1
  /* Error, out of memory.
d205 1
a205 1
  DIRENT_REJECT( (!nd), ENOMEM, (_TDIR *)(0) );
d207 4
a210 2
  /* Create the search expression. */
  _tcscpy (nd->dd_private.dd_name, szFullPath);
d212 5
a216 6
  /* Add on a slash if the path does not end with one. */
  if (nd->dd_private.dd_name[0] != _T('\0')
      && _tcsrchr (nd->dd_private.dd_name, _T('/')) != nd->dd_private.dd_name
					    + _tcslen (nd->dd_private.dd_name) - 1
      && _tcsrchr (nd->dd_private.dd_name, _T('\\')) != nd->dd_private.dd_name
      					     + _tcslen (nd->dd_private.dd_name) - 1)
d218 15
a232 1
      _tcscat (nd->dd_private.dd_name, SLASH);
d235 5
a239 8
  /* Add on the search pattern */
  _tcscat (nd->dd_private.dd_name, SUFFIX);

  /* Initialize handle to -1 so that a premature closedir doesn't try
   * to call _findclose on it. */
  nd->dd_private.dd_handle = -1;

  /* Initialize the status. */
d242 5
a246 3
  /* Initialize the dirent structure. ino and reclen are invalid under
   * Win32, and name simply points at the appropriate part of the
   * findfirst_t structure. */
a248 2
  nd->dd_dir.d_namlen = 0;
  memset (nd->dd_dir.d_name, 0, FILENAME_MAX);
d250 4
d258 3
a260 2
/*
 * readdir
d262 2
a263 2
 * Return a pointer to a dirent structure filled with the information on the
 * next entry in the directory.
d266 1
a266 1
_treaddir (_TDIR *dirp)
d274 1
a274 1
  DIRENT_REJECT( (!dirp), EBADF, (struct _tdirent *)(0) );
d276 5
a280 24
  if (dirp->dd_private.dd_stat < 0)
    {
      /* We have already returned all files in the directory
       * (or the structure has an invalid dd_stat). */
      return (struct _tdirent *) 0;
    }
  else if (dirp->dd_private.dd_stat == 0)
    {
      /* We haven't started the search yet. */
      /* Start the search */
      dirp->dd_private.dd_handle = _tfindfirst (dirp->dd_private.dd_name, &(dirp->dd_private.dd_dta));

      if (dirp->dd_private.dd_handle == -1)
	{
	  /* Oops! Seems there are no files in that
	   * directory. */
	  dirp->dd_private.dd_stat = -1;
	}
      else
	{
	  dirp->dd_private.dd_stat = 1;
	}
    }
  else
d282 3
a284 1
      /* Get the next search entry.  POSIX mandates that this must
d292 1
a292 1
      if (_tfindnext (dirp->dd_private.dd_handle, &(dirp->dd_private.dd_dta)))
d302 1
a302 2
	  /* FIXME: this is just wrong: we should NOT close the DIR
	   * handle here; it is the responsibility of closedir().
d304 1
a304 9
	  _findclose (dirp->dd_private.dd_handle);
	  dirp->dd_private.dd_handle = -1;
	  dirp->dd_private.dd_stat = -1;
	}
      else
	{
	  /* Update the status to indicate the correct
	   * number. */
	  dirp->dd_private.dd_stat++;
d308 11
a318 1
  if (dirp->dd_private.dd_stat > 0)
d320 13
a332 27
      /* Successfully got an entry. Everything about the file is
       * already appropriately filled in except the length of the
       * file name...
       */
      dirp->dd_dir.d_namlen = _tcslen (dirp->dd_dir.d_name);
      /*
       * ...and the attributes returned in the dd_dta.attrib field;
       * these require adjustment to their BSD equivalents, which are
       * returned via the union with the dd_dir.d_type field:
       */
      switch( dirp->dd_dir.d_type &= ~DT_IGNORED )
	{
	  case DT_REG:
	  case DT_DIR:
	    /* After stripping out the modifier bits in DT_IGNORED,
	     * (which we ALWAYS ignore), this pair require no further
	     * adjustment...
	     */
	    break;

	  default:
	    /* ...while nothing else has an appropriate equivalent
	     * in the BSD d_type identification model.
	     */
	    dirp->dd_dir.d_type = DT_UNKNOWN;
	}
      return &dirp->dd_dir;
d334 1
a334 2

  return (struct _tdirent *) 0;
d338 5
a342 2
/*
 * closedir
a343 1
 * Frees up resources allocated by opendir.
d346 1
a346 1
_tclosedir (_TDIR * dirp)
a347 2
  int rc = 0;

d354 4
a357 1
  DIRENT_REJECT( (!dirp), EBADF, -1 );
d359 7
a365 4
  if (dirp->dd_private.dd_handle != -1)
    {
      rc = _findclose (dirp->dd_private.dd_handle);
    }
a366 2
  /* Delete the dir structure. */
  free (dirp);
d368 8
a375 5
  return rc;
}

/*
 * rewinddir
a376 2
 * Return to the beginning of the directory "stream". We simply call findclose
 * and then reset things like an opendir.
d379 1
a379 1
_trewinddir (_TDIR * dirp)
d381 13
a393 3
  /* Once again, evade a potential segmentation fault on passing
   * a NULL reference pointer, and again correct previous anomalous
   * use of EFAULT, where POSIX mandates EBADF for errno reporting.
d395 6
a400 1
  DIRENT_REJECT( (!dirp), EBADF, DIRENT_RETURN_NOTHING );
a401 4
  if (dirp->dd_private.dd_handle != -1)
    {
      _findclose (dirp->dd_private.dd_handle);
    }
d403 7
a409 6
  dirp->dd_private.dd_handle = -1;
  dirp->dd_private.dd_stat = 0;
}

/*
 * telldir
a410 2
 * Returns the "position" in the "directory stream" which can be used with
 * seekdir to go back to an old entry. We simply return the value in stat.
d413 1
a413 1
_ttelldir (_TDIR * dirp)
d415 9
a423 3
  /* Once again, evade a potential segmentation fault on passing
   * a NULL reference pointer, and again correct previous anomalous
   * use of EFAULT, where POSIX mandates EBADF for errno reporting.
a424 1
  DIRENT_REJECT( (!dirp), EBADF, -1 );
d428 12
a439 2
/*
 * seekdir
a440 5
 * Seek to an entry previously returned by telldir. We rewind the directory
 * and call readdir repeatedly until either dd_stat is the position number
 * or -1 (off the end). This is not perfect, in that the directory may
 * have changed while we weren't looking. But that is probably the case with
 * any such system.
d443 1
a443 1
_tseekdir (_TDIR * dirp, long lPos)
d445 3
a447 3
  /* Once again, evade a potential segmentation fault on passing
   * a NULL reference pointer, and again correct previous anomalous
   * use of EFAULT, where POSIX mandates EBADF for errno reporting.
d449 1
a449 1
  DIRENT_REJECT( (!dirp), EBADF, DIRENT_RETURN_NOTHING );
d451 2
a452 1
  /* Seeking to an invalid position.
d454 1
a454 1
  DIRENT_REJECT( (lPos < -1), EINVAL, DIRENT_RETURN_NOTHING );
d456 11
a466 14
  if (lPos == -1)
    {
      /* Seek past end. */
      if (dirp->dd_private.dd_handle != -1)
	{
	  _findclose (dirp->dd_private.dd_handle);
	}
      dirp->dd_private.dd_handle = -1;
      dirp->dd_private.dd_stat = -1;
    }
  else
    {
      /* Rewind and read forward to the appropriate index. */
      _trewinddir (dirp);
d468 1
a468 4
      while ((dirp->dd_private.dd_stat < lPos) && _treaddir (dirp))
	;
    }
}
@


1.11
log
@Rationalise structure layout; add dirent.d_type field.
@
text
@d3 1
d13 2
a14 2
 * Significantly revised and rewinddir, seekdir and telldir added by Colin
 * Peters <colin@@fu.is.saga-u.ac.jp>
d30 5
a34 1
#define	SLASH	_T("\\")
d161 24
a184 28
  errno = 0;

  if (!szPath)
    {
      errno = EFAULT;
      return (_TDIR *) 0;
    }

  if (szPath[0] == _T('\0'))
    {
      errno = ENOTDIR;
      return (_TDIR *) 0;
    }

  /* Attempt to determine if the given path really is a directory. */
  rc = _tGetFileAttributes (szPath);
  if (rc == (unsigned int)-1)
    {
      /* call GetLastError for more error info */
      errno = ENOENT;
      return (_TDIR *) 0;
    }
  if (!(rc & FILE_ATTRIBUTE_DIRECTORY))
    {
      /* Error, entry exists but not a directory. */
      errno = ENOTDIR;
      return (_TDIR *) 0;
    }
d191 8
a198 11
  nd = (_TDIR *) malloc (sizeof (_TDIR) + (_tcslen (szFullPath)
					   + _tcslen (SLASH)
					   + _tcslen (SUFFIX) + 1)
					  * sizeof (_TCHAR));

  if (!nd)
    {
      /* Error, out of memory. */
      errno = ENOMEM;
      return (_TDIR *) 0;
    }
d242 1
a242 1
_treaddir (_TDIR * dirp)
d244 7
a250 8
  errno = 0;

  /* Check for valid DIR struct. */
  if (!dirp)
    {
      errno = EFAULT;
      return (struct _tdirent *) 0;
    }
d266 1
a266 1
	  /* Whoops! Seems there are no files in that
d277 8
a284 1
      /* Get the next search entry. */
d287 11
a297 6
	  /* We are off the end or otherwise error.	
	     _findnext sets errno to ENOENT if no more file
	     Undo this. */ 
	  DWORD winerr = GetLastError ();
	  if (winerr == ERROR_NO_MORE_FILES)
	    errno = 0;	
d353 1
a353 1
  int rc;
d355 7
a361 8
  errno = 0;
  rc = 0;

  if (!dirp)
    {
      errno = EFAULT;
      return -1;
    }
d383 5
a387 7
  errno = 0;

  if (!dirp)
    {
      errno = EFAULT;
      return;
    }
d407 5
a411 7
  errno = 0;

  if (!dirp)
    {
      errno = EFAULT;
      return -1;
    }
d427 9
a435 1
  errno = 0;
d437 1
a437 13
  if (!dirp)
    {
      errno = EFAULT;
      return;
    }

  if (lPos < -1)
    {
      /* Seeking to an invalid position. */
      errno = EINVAL;
      return;
    }
  else if (lPos == -1)
@


1.10
log
@Don't expose implementation detail for opaque DIRENT structures.
@
text
@d31 1
a31 1
struct __dirstream_t
d35 16
a50 1
    /* disk transfer area for this dir */
a52 5
    /* dirent struct to return from dir (NOTE: this makes this thread
     * safe as long as only one thread uses a particular DIR struct at
     * a time) */
    struct dirent	dd_dir;

d56 1
a56 2
    /*
     * Status of search:
d66 2
d70 1
a70 1
struct __wdirstream_t
d74 16
a89 1
    /* disk transfer area for this dir */
a91 5
    /* dirent struct to return from dir (NOTE: this makes this thread
     * safe as long as only one thread uses a particular DIR struct at
     * a time) */
    struct _wdirent	dd_dir;

d95 1
a95 2
    /*
     * Status of search:
d104 2
d108 17
d203 1
a203 1
  _tcscpy (nd->dd_name, szFullPath);
d206 5
a210 5
  if (nd->dd_name[0] != _T('\0')
      && _tcsrchr (nd->dd_name, _T('/')) != nd->dd_name
					    + _tcslen (nd->dd_name) - 1
      && _tcsrchr (nd->dd_name, _T('\\')) != nd->dd_name
      					     + _tcslen (nd->dd_name) - 1)
d212 1
a212 1
      _tcscat (nd->dd_name, SLASH);
d216 1
a216 1
  _tcscat (nd->dd_name, SUFFIX);
d220 1
a220 1
  nd->dd_handle = -1;
d223 1
a223 1
  nd->dd_stat = 0;
d255 1
a255 1
  if (dirp->dd_stat < 0)
d261 1
a261 1
  else if (dirp->dd_stat == 0)
d265 1
a265 1
      dirp->dd_handle = _tfindfirst (dirp->dd_name, &(dirp->dd_dta));
d267 1
a267 1
      if (dirp->dd_handle == -1)
d271 1
a271 1
	  dirp->dd_stat = -1;
d275 1
a275 1
	  dirp->dd_stat = 1;
d281 1
a281 1
      if (_tfindnext (dirp->dd_handle, &(dirp->dd_dta)))
d289 3
a291 3
	  _findclose (dirp->dd_handle);
	  dirp->dd_handle = -1;
	  dirp->dd_stat = -1;
d297 1
a297 1
	  dirp->dd_stat++;
d301 1
a301 1
  if (dirp->dd_stat > 0)
d305 24
a328 3
       * file name. */
      dirp->dd_dir.d_namlen = _tcslen (dirp->dd_dta.name);
      _tcscpy (dirp->dd_dir.d_name, dirp->dd_dta.name);
d355 1
a355 1
  if (dirp->dd_handle != -1)
d357 1
a357 1
      rc = _findclose (dirp->dd_handle);
d383 1
a383 1
  if (dirp->dd_handle != -1)
d385 1
a385 1
      _findclose (dirp->dd_handle);
d388 2
a389 2
  dirp->dd_handle = -1;
  dirp->dd_stat = 0;
d408 1
a408 1
  return dirp->dd_stat;
d440 1
a440 1
      if (dirp->dd_handle != -1)
d442 1
a442 1
	  _findclose (dirp->dd_handle);
d444 2
a445 2
      dirp->dd_handle = -1;
      dirp->dd_stat = -1;
d452 1
a452 1
      while ((dirp->dd_stat < lPos) && _treaddir (dirp))
@


1.9
log
@	* mingwex/dirent.c (_tGetFileAttributes): New helper function.
	(_topendir): Use it.
@
text
@d31 54
@


1.8
log
@2005-04-23  Wu Yongwei  <adah@@sh163.net>

	mingwex/dirent.c: Formatting changes.

	mingwex/dirent.c (_topendir): Make the end-of-path slash check
	MBCS-safe.
@
text
@d31 19
d78 1
a78 1
  rc = GetFileAttributes (szPath);
@


1.7
log
@
	* CONTRIBUTORS: New file.
	* DISCLAIMER: Ditto.
	* CRT_noglob.c: Reword copyright and disclaimer.  Move Contributors
	section CONTRIBUTORS file.  Remove RCS tags.
	* CRTFmode.c: Ditto.
	* CRTglob.c: Ditto.
	* CRTinit.c: Ditto.
	* crt1.c: Ditto.
	* crtdll.dev: Ditto.
	* dllcrt1.c: Ditto.
	* dllmain.c: Ditto.
	* gccmain.c: Ditto.
	* init.c: Ditto.
	* isascii.c: Ditto.
	* iscsym.c: Ditto.
	* iscsymf.c: Ditto.
	* jamfile: Ditto.
	* main.c: Ditto.
	* msvcrt.def.in: Ditto.
	* strcasecmp.c: Ditto.
	* toascii.c: Ditto.
	* wcscmpi.c: Ditto.
	* include/assert.h: Ditto.
	* include/conio.h: Ditto.
	* include/ctype.h: Ditto.
	* include/direct.h: Ditto.
	* include/dirent.h: Ditto.
	* include/dos.h: Ditto.
	* include/errno.h: Ditto.
	* include/excpt.h: Ditto.
	* include/fcntl.h: Ditto.
	* include/float.h: Ditto.
	* include/io.h: Ditto.
	* include/locale.h: Ditto.
	* include/malloc.h: Ditto.
	* include/math.h: Ditto.
	* include/process.h: Ditto.
	* include/setjmp.h: Ditto.
	* include/share.h: Ditto.
	* include/signal.h: Ditto.
	* include/stdio.h: Ditto.
	* include/stdlib.h: Ditto.
	* include/string.h: Ditto.
	* include/tchar.h: Ditto.
	* include/time.h: Ditto.
	* include/wchar.h: Ditto.
	* include/sys/locking.h: Ditto.
	* include/sys/param.h: Ditto.
	* include/sys/stat.h: Ditto.
	* include/sys/timeb.h: Ditto.
	* include/sys/types.h: Ditto.
	* include/sys/utime.h: Ditto.
	* mingwex/dirent.c: Ditto.
@
text
@d78 4
a81 2
  nd = (_TDIR *) malloc (sizeof (_TDIR) + (_tcslen(szFullPath) + _tcslen (SLASH) +
			 _tcslen(SUFFIX) + 1) * sizeof(_TCHAR));
d94 5
a98 3
  if (nd->dd_name[0] != _T('\0') &&
      nd->dd_name[_tcslen (nd->dd_name) - 1] != _T('/') &&
      nd->dd_name[_tcslen (nd->dd_name) - 1] != _T('\\'))
d155 1
a155 1
  	  if (dirp->dd_handle == -1)
d174 1
a174 1
	  DWORD winerr = GetLastError();
@


1.6
log
@	* mingwex/dirent.c (_treaddir): Reset errno to 0 if end
	of directory.
@
text
@d3 3
a14 4
 * $Revision: 1.5 $
 * $Author: dannysmith $
 * $Date: 2003/09/22 21:32:52 $
 *
@


1.5
log
@2003-09-22  Roland Schwingel  <rolandschwingel@@users.sourceforge.net>

	* mingwex/dirent.c (_topendir): Allocate enough memory for
	DIR struct in UNICODE case too.
@
text
@d12 3
a14 3
 * $Revision: 1.4 $
 * $Author: earnie $
 * $Date: 2003/06/18 13:54:47 $
d168 6
a173 1
	  /* We are off the end or otherwise error. */
@


1.4
log
@
	* include/dirent.h (dirent): Make d_name and array instead of a pointer.
	* mingwex/dirent.c: Modifications througout to fill d_name array.
        * Makefile.in (LIBS): Add new MSVCRT libraries libmsvcr70 and
        libmsvcr71, including debug versions.
        (msvcr70.def, msvcr70d.def, msvcr71.def, msvcr71.def): New targets.
@
text
@d12 3
a14 3
 * $Revision: 1.3 $
 * $Author: dannysmith $
 * $Date: 2003/03/17 01:03:43 $
d79 2
a80 2
  nd = (_TDIR *) malloc (sizeof (_TDIR) + _tcslen (szFullPath) + _tcslen (SLASH) +
		       _tcslen (SUFFIX));
@


1.3
log
@	Get rid of some warnings
	* mingwex/dirent.c (_topendir): Eliminate signed/unsigned warning.
	* mingwex/strtoimax.c (strtoimax): Likewise.
	* mingwex/wcstoimax.c (wcstoimax): Likewise.
	* mingwex/wtoll.c (wtoll): Remove unnecessary ';'
	* mingwex/fesentenv.c: Include float.h.
	* mingwex/math/powl.c: Eliminate type punning/strict aliasing 
	warning.
	* mingwex/math/tanhl.c: Eliminate signed/unsigned warning in
	constants.
	* mingwex/math/tgammal.c: Likewise.
@
text
@d12 1
a12 1
 * $Revision: 1.2 $
d14 1
a14 1
 * $Date: 2002/06/13 10:20:44 $
d116 1
a116 1
  nd->dd_dir.d_name = nd->dd_dta.name;
a139 7
  if (dirp->dd_dir.d_name != dirp->dd_dta.name)
    {
      /* The structure does not seem to be set up correctly. */
      errno = EINVAL;
      return (struct _tdirent *) 0;
    }

d186 2
a187 1
      dirp->dd_dir.d_namlen = _tcslen (dirp->dd_dir.d_name);
@


1.2
log
@	* include/_mingw.h: Increment version to 2.0.
	* Makefile.in: Ditto.
	Merge in mingwex branch.
@
text
@d12 1
a12 1
 * $Revision: 1.1.2.3 $
d14 1
a14 1
 * $Date: 2002/04/23 01:59:05 $
d61 1
a61 1
  if (rc == -1)
@


1.2.6.1
log
@	Merge from mingw trunk (changes since 2003-01-27).
@
text
@d12 1
a12 1
 * $Revision: 1.3 $
d14 1
a14 1
 * $Date: 2003/03/17 01:03:43 $
d61 1
a61 1
  if (rc == (unsigned int)-1)
@


1.1
log
@file dirent.c was initially added on branch mingwex.
@
text
@d1 320
@


1.1.2.1
log
@	* configure.in: Add mingwex as SUBDIRS and configdirs.
	* configure: Regenerate.
	* Makefile.in (MINGW_OBJS): Remove dirent.o.
	(SRC_DIST_FILES): Remove dirent.c.
	* dirent.c: Remove.
	* include/stdlib.h (_Exit): Add static inline
	function.
	(struct lldiv_t): Define.
	(lldiv): Add prototype.
	(llabs): Add extern inline function.
	(strtoll,strtoull): Add prototypes.
	(wcstol, wcstoul, wcstod): Group together.
	(strtof, wcstof): Add extern inline definitions.
	(atoll,lltoa,ulltoa, wtoll, lltow ulltow): Add prototypes
	and extern inline definitions.
	* include/wchar.h (fwide, wcstoll,wcstoull, wmemchr
	wmemcmp, wmemcpy, wmemmove, wmemset. mbsinit): Add
	prototypes.
	(wcstol, wcstoul,wcstod): Copy prototypes from stdlib.h.
	(wcstof): Add extern inline definition.
	* include/math.h (nan, nanf): Add prototypes.
	(NAN, INFINITE): Define constants.
	(fpclassify, isnan ,signbit): Add macros and supporting float
	and double functions.
	(isfinite, isinf, isnormal): Add macros.
	(isgreater, isless, isgreaterequal, islessequal,islessgreater):
	Add macros.
	(rint, rintf, round, roundf, trunc. truncf, fmax, fmaxf,
	fmin, fminf, fma, fmaf, log2, log2f): Add prototypes.
	(copysign, logb, nextafter, scalb): Add prototypes and
	inline stubs for underscored versions in msvcrt.dll.
	* include/inttypes.h: New file.
	* include/fenv.h: New file

	Add new mingwex subdir and files.
	* mingwex: New directory.
	* mingwex/Makefile.in: New file.
	* mingwex/configure.in: New file.
	* mingwex/configure: Generate.
	* mingwex/dirent.c: Moved here from parent dir.
	* mingwex/atoll.c: New file.
	* mingwex/feclearexcept.c: New file.
	* mingwex/fegetenv.c: New file.
	* mingwex/fegetexceptflag.c: New file.
	* mingwex/fegetround.c: New file.
	* mingwex/feholdexcept.c: New file.
	* mingwex/feraiseexcept.c: New file.
	* mingwex/fesetenv.c: New file.
	* mingwex/fesetexceptflag.c: New file.
	* mingwex/fesetround.o: New file.
	* mingwex/fetestexcept.c: New file.
	* mingwex/feupdateenv.c: New file.
	* mingwex/fma.S: New file.
	* mingwex/fmaf.S: New file.
	* mingwex/fmax.c: New file.
	* mingwex/fmaxf.c: New file.
	* mingwex/fmin.c: New file.
	* mingwex/fminf.c: New file.
	* mingwex/fp_consts.c: New file.
	* mingwex/fpclassify.c: New file.
	* mingwex/fucom.c: New file.
	* mingwex/fwide.c: New file.
	* mingwex/imaxabs.c: New file.
	* mingwex/imaxdiv.c: New file.
	* mingwex/isnan.c: New file.
	* mingwex/isnanf.c: New file.
	* mingwex/lltoa.c: New file.
	* mingwex/lltow.c: New file.
	* mingwex/log2.c: New file.
	* mingwex/log2f.c: New file.
	* mingwex/math_stubs.c: New file.
	* mingwex/mbsinit.c: New file.
	* mingwex/rint.c: New file.
	* mingwex/round.c: New file.
	* mingwex/signbit.c: New file.
	* mingwex/sitest.c: New file.
	* mingwex/strtof.c: New file.
	* mingwex/strtoimax.c: New file.
	* mingwex/strtoumax.c: New file.
	* mingwex/testwmem.c: New file.
	* mingwex/trunc.c: New file.
	* mingwex/ulltoa.c: New file.
	* mingwex/ulltow.c: New file.
	* mingwex/wcstof.c: New file.
	* mingwex/wcstoimax.c: New file.
	* mingwex/wcstoumax.c: New file.
	* mingwex/wmemchr.c: New file.
	* mingwex/wmemcmp.c: New file.
	* mingwex/wmemcpy.c: New file.
	* mingwex/wmemmove.c: New file.
	* mingwex/wmemset.c: New file.
	* mingwex/wtoll.c: New file.
@
text
@a0 316
/*
 * dirent.c
 *
 * Derived from DIRLIB.C by Matt J. Weinstein 
 * This note appears in the DIRLIB.H
 * DIRLIB.H by M. J. Weinstein   Released to public domain 1-Jan-89
 *
 * Updated by Jeremy Bettis <jeremy@@hksys.com>
 * Significantly revised and rewinddir, seekdir and telldir added by Colin
 * Peters <colin@@fu.is.saga-u.ac.jp>
 *	
 * $Revision: 1.3 $
 * $Author: dannysmith $
 * $Date: 2001/09/09 21:20:07 $
 *
 */

#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <io.h>
#include <direct.h>

#include <dirent.h>

#define WIN32_LEAN_AND_MEAN
#include <windows.h> /* for GetFileAttributes */

#define SUFFIX	"*"
#define	SLASH	"\\"

/*
 * opendir
 *
 * Returns a pointer to a DIR structure appropriately filled in to begin
 * searching a directory.
 */
DIR * 
opendir (const char *szPath)
{
  DIR *nd;
  unsigned int rc;
	
  errno = 0;

  if (!szPath)
    {
      errno = EFAULT;
      return (DIR *) 0;
    }

  if (szPath[0] == '\0')
    {
      errno = ENOTDIR;
      return (DIR *) 0;
    }

  /* Attempt to determine if the given path really is a directory. */
  rc = GetFileAttributes(szPath);
  if (rc == -1)
    {
      /* call GetLastError for more error info */
      errno = ENOENT;
      return (DIR *) 0;
    }
  if (!(rc & FILE_ATTRIBUTE_DIRECTORY))
    {
      /* Error, entry exists but not a directory. */
      errno = ENOTDIR;
      return (DIR *) 0;
    }

  /* Allocate enough space to store DIR structure and the complete
   * directory path given. */
  nd = (DIR *) malloc (sizeof (DIR) + strlen (szPath) + strlen (SLASH) +
		       strlen (SUFFIX));

  if (!nd)
    {
      /* Error, out of memory. */
      errno = ENOMEM;
      return (DIR *) 0;
    }

  /* Create the search expression. */
  strcpy (nd->dd_name, szPath);

  /* Add on a slash if the path does not end with one. */
  if (nd->dd_name[0] != '\0' &&
      nd->dd_name[strlen (nd->dd_name) - 1] != '/' &&
      nd->dd_name[strlen (nd->dd_name) - 1] != '\\')
    {
      strcat (nd->dd_name, SLASH);
    }

  /* Add on the search pattern */
  strcat (nd->dd_name, SUFFIX);

  /* Initialize handle to -1 so that a premature closedir doesn't try
   * to call _findclose on it. */
  nd->dd_handle = -1;

  /* Initialize the status. */
  nd->dd_stat = 0;

  /* Initialize the dirent structure. ino and reclen are invalid under
   * Win32, and name simply points at the appropriate part of the
   * findfirst_t structure. */
  nd->dd_dir.d_ino = 0;
  nd->dd_dir.d_reclen = 0;
  nd->dd_dir.d_namlen = 0;
  nd->dd_dir.d_name = nd->dd_dta.name;

  return nd;
}


/*
 * readdir
 *
 * Return a pointer to a dirent structure filled with the information on the
 * next entry in the directory.
 */
struct dirent *
readdir (DIR * dirp)
{
  errno = 0;

  /* Check for valid DIR struct. */
  if (!dirp)
    {
      errno = EFAULT;
      return (struct dirent *) 0;
    }

  if (dirp->dd_dir.d_name != dirp->dd_dta.name)
    {
      /* The structure does not seem to be set up correctly. */
      errno = EINVAL;
      return (struct dirent *) 0;
    }

  if (dirp->dd_stat < 0)
    {
      /* We have already returned all files in the directory
       * (or the structure has an invalid dd_stat). */
      return (struct dirent *) 0;
    }
  else if (dirp->dd_stat == 0)
    {
      /* We haven't started the search yet. */
      /* Start the search */
      dirp->dd_handle = _findfirst (dirp->dd_name, &(dirp->dd_dta));

  	  if (dirp->dd_handle == -1)
	{
	  /* Whoops! Seems there are no files in that
	   * directory. */
	  dirp->dd_stat = -1;
	}
      else
	{
	  dirp->dd_stat = 1;
	}
    }
  else
    {
      /* Get the next search entry. */
      if (_findnext (dirp->dd_handle, &(dirp->dd_dta)))
	{
	  /* We are off the end or otherwise error. */
	  _findclose (dirp->dd_handle);
	  dirp->dd_handle = -1;
	  dirp->dd_stat = -1;
	}
      else
	{
	  /* Update the status to indicate the correct
	   * number. */
	  dirp->dd_stat++;
	}
    }

  if (dirp->dd_stat > 0)
    {
      /* Successfully got an entry. Everything about the file is
       * already appropriately filled in except the length of the
       * file name. */
      dirp->dd_dir.d_namlen = strlen (dirp->dd_dir.d_name);
      return &dirp->dd_dir;
    }

  return (struct dirent *) 0;
}


/*
 * closedir
 *
 * Frees up resources allocated by opendir.
 */
int
closedir (DIR * dirp)
{
  int rc;

  errno = 0;
  rc = 0;

  if (!dirp)
    {
      errno = EFAULT;
      return -1;
    }

  if (dirp->dd_handle != -1)
    {
      rc = _findclose (dirp->dd_handle);
    }

  /* Delete the dir structure. */
  free (dirp);

  return rc;
}

/*
 * rewinddir
 *
 * Return to the beginning of the directory "stream". We simply call findclose
 * and then reset things like an opendir.
 */
void
rewinddir (DIR * dirp)
{
  errno = 0;

  if (!dirp)
    {
      errno = EFAULT;
      return;
    }

  if (dirp->dd_handle != -1)
    {
      _findclose (dirp->dd_handle);
    }

  dirp->dd_handle = -1;
  dirp->dd_stat = 0;
}

/*
 * telldir
 *
 * Returns the "position" in the "directory stream" which can be used with
 * seekdir to go back to an old entry. We simply return the value in stat.
 */
long
telldir (DIR * dirp)
{
  errno = 0;

  if (!dirp)
    {
      errno = EFAULT;
      return -1;
    }
  return dirp->dd_stat;
}

/*
 * seekdir
 *
 * Seek to an entry previously returned by telldir. We rewind the directory
 * and call readdir repeatedly until either dd_stat is the position number
 * or -1 (off the end). This is not perfect, in that the directory may
 * have changed while we weren't looking. But that is probably the case with
 * any such system.
 */
void
seekdir (DIR * dirp, long lPos)
{
  errno = 0;

  if (!dirp)
    {
      errno = EFAULT;
      return;
    }

  if (lPos < -1)
    {
      /* Seeking to an invalid position. */
      errno = EINVAL;
      return;
    }
  else if (lPos == -1)
    {
      /* Seek past end. */
      if (dirp->dd_handle != -1)
	{
	  _findclose (dirp->dd_handle);
	}
      dirp->dd_handle = -1;
      dirp->dd_stat = -1;
    }
  else
    {
      /* Rewind and read forward to the appropriate index. */
      rewinddir (dirp);

      while ((dirp->dd_stat < lPos) && readdir (dirp))
	;
    }
}
@


1.1.2.2
log
@	* mingwex/dirent.c (opendir): Convert given pathname to
	absolute pathname.
@
text
@d12 1
a12 1
 * $Revision: 1.1.2.1 $
d14 1
a14 1
 * $Date: 2002/03/22 22:43:17 $
a42 1
  char szFullPath[MAX_PATH];
d59 1
a59 1
  rc = GetFileAttributes (szPath);
a72 3
  /* Make an absolute pathname.  */
  _fullpath (szFullPath, szPath, MAX_PATH);

d75 1
a75 1
  nd = (DIR *) malloc (sizeof (DIR) + strlen (szFullPath) + strlen (SLASH) +
d86 1
a86 1
  strcpy (nd->dd_name, szFullPath);
@


1.1.2.3
log
@	Make wide char versions of opendir and friends.
	* include/dirent.h (_wdirent, _WDIR): Define wide versions of
	struct dirent, DIR.
	(_wopendir,_wreaddir,_wclosedir,_wrewinddir,_wtelldir,
	_wseekdir): Add prototypes for wide versions of corresponding
	standard functions.
	* include/tchar.h; Add _UNICODE mappings for dirent.h
	structures and functions.
	* mingwex/dirent.c: Make _UNICODE neutral.
	* mingwex/wdirent.c: New file to define _UNICODE before
	including dirent.c.
	* mingwex/Makefile.in (DISTFILES): Add wdirent.c/
	(POSIX_OBJS): Add wdirent.o.
	(wdirent.o): Specify dependency on dirent.c as well as
	wdirent.c.
	* samples/dirent/wtest.c: New file, wide version of test.c.
@
text
@d12 1
a12 1
 * $Revision: 1.1.2.2 $
d14 1
a14 1
 * $Date: 2002/04/18 10:35:41 $
d23 1
d29 2
a30 3
#include <tchar.h>
#define SUFFIX	_T("*")
#define	SLASH	_T("\\")
d38 2
a39 2
_TDIR * 
_topendir (const _TCHAR *szPath)
d41 1
a41 1
  _TDIR *nd;
d43 1
a43 1
  _TCHAR szFullPath[MAX_PATH];
d50 1
a50 1
      return (_TDIR *) 0;
d53 1
a53 1
  if (szPath[0] == _T('\0'))
d56 1
a56 1
      return (_TDIR *) 0;
d65 1
a65 1
      return (_TDIR *) 0;
d71 1
a71 1
      return (_TDIR *) 0;
d75 1
a75 1
  _tfullpath (szFullPath, szPath, MAX_PATH);
d79 2
a80 2
  nd = (_TDIR *) malloc (sizeof (_TDIR) + _tcslen (szFullPath) + _tcslen (SLASH) +
		       _tcslen (SUFFIX));
d86 1
a86 1
      return (_TDIR *) 0;
d90 1
a90 1
  _tcscpy (nd->dd_name, szFullPath);
d93 3
a95 3
  if (nd->dd_name[0] != _T('\0') &&
      nd->dd_name[_tcslen (nd->dd_name) - 1] != _T('/') &&
      nd->dd_name[_tcslen (nd->dd_name) - 1] != _T('\\'))
d97 1
a97 1
      _tcscat (nd->dd_name, SLASH);
d101 1
a101 1
  _tcscat (nd->dd_name, SUFFIX);
d128 2
a129 2
struct _tdirent *
_treaddir (_TDIR * dirp)
d137 1
a137 1
      return (struct _tdirent *) 0;
d144 1
a144 1
      return (struct _tdirent *) 0;
d151 1
a151 1
      return (struct _tdirent *) 0;
d157 1
a157 1
      dirp->dd_handle = _tfindfirst (dirp->dd_name, &(dirp->dd_dta));
d173 1
a173 1
      if (_tfindnext (dirp->dd_handle, &(dirp->dd_dta)))
d193 1
a193 1
      dirp->dd_dir.d_namlen = _tcslen (dirp->dd_dir.d_name);
d197 1
a197 1
  return (struct _tdirent *) 0;
d207 1
a207 1
_tclosedir (_TDIR * dirp)
d238 1
a238 1
_trewinddir (_TDIR * dirp)
d264 1
a264 1
_ttelldir (_TDIR * dirp)
d286 1
a286 1
_tseekdir (_TDIR * dirp, long lPos)
d315 1
a315 1
      _trewinddir (dirp);
d317 1
a317 1
      while ((dirp->dd_stat < lPos) && _treaddir (dirp))
@


