head	1.3;
access;
symbols
	cygwin-1_7_35-release:1.3
	cygwin-1_7_34-release:1.3
	cygwin-1_7_33-release:1.3
	cygwin-1_7_32-release:1.3
	cygwin-1_7_31-release:1.3
	cygwin-1_7_30-release:1.3
	cygwin-1_7_29-release:1.3
	cygwin-1_7_29-release-branchpoint:1.3.0.26
	cygwin-1_7_28-release:1.3
	cygwin-1_7_27-release:1.3
	cygwin-1_7_26-release:1.3
	cygwin-1_7_25-release:1.3
	cygwin-1_7_24-release:1.3
	cygwin-1_7_23-release:1.3
	cygwin-1_7_22-release:1.3
	cygwin-1_7_21-release:1.3
	cygwin-1_7_20-release:1.3
	cygwin-1_7_19-release:1.3
	cygwin-64bit-postmerge:1.3
	cygwin-64bit-premerge-branch:1.3.0.24
	cygwin-64bit-premerge:1.3
	cygwin-1_7_18-release:1.3
	cygwin-1_7_17-release:1.3
	cygwin-64bit-branch:1.3.0.22
	cygwin-1_7_16-release:1.3
	cygwin-1_7_15-release:1.3
	cygwin-1_7_14_2-release:1.3
	cygwin-1_7_14-release:1.3
	cygwin-1_7_12-release:1.3
	cygwin-1_7_11-release:1.3
	cygwin-1_7_10-release:1.3
	cygwin-1_7_9-release:1.3
	cygwin-1_7_8-release:1.3
	cygwin-1_7_7-release:1.3
	cygwin-1_7_5-release:1.3
	cygwin-1_7_4-release:1.3
	cygwin-1_7_3-release:1.3
	cygwin-1_7_2-release:1.3
	cygwin-1_7_1-release:1.3
	cv-branch-2:1.3.0.20
	cr-0x5f1:1.3.0.18
	cv-branch:1.3.0.16
	cr-0x3b58:1.3.0.14
	cr-0x9e:1.3.0.12
	cr-0x9d:1.3.0.10
	corinna-01:1.3
	cr-0x9c:1.3.0.8
	cr-0x9b:1.3.0.6
	cr-0x99:1.3
	Z-emcb-cygwin_daemon:1.3.0.4
	w32api-2_2:1.3
	mingw-runtime-2_4:1.3
	cygnus_cvs_20020108_pre:1.3
	Z-cygwin_daemon_merge-new_HEAD:1.3
	Z-cygwin_daemon_merge_HEAD:1.3
	cygwin_daemon:1.3.0.2;
locks; strict;
comment	@ * @;


1.3
date	2001.09.13.17.30.22;	author duda;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.06.14.21.53;	author duda;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.03.03.52.30;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.3
log
@* libltp/lib/tst_sig.c: Pass SIGSEGV to application to consider
whether it's expected or not.
* winsup.api/known_bugs.tcl: lseek10 is known to fail because mknod
is not implemented.
* winsup.api/ltp/rename02.c: Fix formatting.
* libltp/lib/libtestsuite.c: New file.
* winsup.api/signal-into-win32-api.c: New test.
* winsup.api/ltp/access04.c: Ditto.
* winsup.api/ltp/access05.c: Ditto.
* winsup.api/ltp/alarm07.c: Ditto.
* winsup.api/ltp/chdir04.c: Ditto.
* winsup.api/ltp/chmod01.c: Ditto.
* winsup.api/ltp/close01.c: Ditto.
* winsup.api/ltp/close02.c: Ditto.
* winsup.api/ltp/creat01.c: Ditto.
* winsup.api/ltp/creat03.c: Ditto.
* winsup.api/ltp/exit01.c: Ditto.
* winsup.api/ltp/exit02.c: Ditto.
* winsup.api/ltp/fchdir01.c: Ditto.
* winsup.api/ltp/fchdir02.c: Ditto.
* winsup.api/ltp/fork02.c: Ditto.
* winsup.api/ltp/fork03.c: Ditto.
* winsup.api/ltp/fork06.c: Ditto.
* winsup.api/ltp/fork07.c: Ditto.
* winsup.api/ltp/fork09.c: Ditto.
* winsup.api/ltp/fork10.c: Ditto.
* winsup.api/ltp/fork11.c: Ditto.
* winsup.api/ltp/fstat02.c: Ditto.
* winsup.api/ltp/fstat03.c: Ditto.
* winsup.api/ltp/fstat04.c: Ditto.
* winsup.api/ltp/ftruncate01.c: Ditto.
* winsup.api/ltp/ftruncate02.c: Ditto.
* winsup.api/ltp/ftruncate03.c: Ditto.
* winsup.api/ltp/getgid02.c: Ditto.
* winsup.api/ltp/getgid03.c: Ditto.
* winsup.api/ltp/getpgid01.c: Ditto.
* winsup.api/ltp/getpgid02.c: Ditto.
* winsup.api/ltp/getpid02.c: Ditto.
* winsup.api/ltp/getppid02.c: Ditto.
* winsup.api/ltp/getuid02.c: Ditto.
* winsup.api/ltp/getuid03.c: Ditto.
* winsup.api/ltp/kill01.c: Ditto.
* winsup.api/ltp/kill02.c: Ditto.
* winsup.api/ltp/kill03.c: Ditto.
* winsup.api/ltp/kill04.c: Ditto.
* winsup.api/ltp/lseek06.c: Ditto.
* winsup.api/ltp/lseek07.c: Ditto.
* winsup.api/ltp/lseek08.c: Ditto.
* winsup.api/ltp/lseek09.c: Ditto.
* winsup.api/ltp/lseek10.c: Ditto.
* winsup.api/ltp/mmap02.c: Ditto.
* winsup.api/ltp/mmap03.c: Ditto.
* winsup.api/ltp/mmap04.c: Ditto.
* winsup.api/ltp/mmap05.c: Ditto.
* winsup.api/ltp/mmap06.c: Ditto.
* winsup.api/ltp/mmap07.c: Ditto.
* winsup.api/ltp/mmap08.c: Ditto.
* winsup.api/ltp/munmap01.c: Ditto.
* winsup.api/ltp/munmap02.c: Ditto.
* winsup.api/ltp/open02.c: Ditto.
* winsup.api/ltp/pipe01.c: Ditto.
* winsup.api/ltp/pipe08.c: Ditto.
* winsup.api/ltp/pipe09.c: Ditto.
* winsup.api/ltp/pipe10.c: Ditto.
* winsup.api/ltp/pipe11.c: Ditto.
* winsup.api/ltp/poll01.c: Ditto.
* winsup.api/ltp/read04.c: Ditto.
* winsup.api/ltp/readlink01.c: Ditto.
* winsup.api/ltp/readlink03.c: Ditto.
* winsup.api/ltp/rename01.c: Ditto.
* winsup.api/ltp/rename08.c: Ditto.
* winsup.api/ltp/rename10.c: Ditto.
* winsup.api/ltp/rmdir01.c: Ditto.
* winsup.api/ltp/stat01.c: Ditto.
* winsup.api/ltp/stat02.c: Ditto.
* winsup.api/ltp/stat03.c: Ditto.
* winsup.api/ltp/symlink03.c: Ditto.
* winsup.api/ltp/symlink04.c: Ditto.
* winsup.api/ltp/symlink05.c: Ditto.
* winsup.api/ltp/sync02.c: Ditto.
* winsup.api/ltp/time02.c: Ditto.
* winsup.api/ltp/times02.c: Ditto.
* winsup.api/ltp/times03.c: Ditto.
* winsup.api/ltp/truncate01.c: Ditto.
* winsup.api/ltp/truncate02.c: Ditto.
* winsup.api/ltp/umask02.c: Ditto.
* winsup.api/ltp/umask03.c: Ditto.
* winsup.api/ltp/wait401.c: Ditto.
* winsup.api/ltp/wait402.c: Ditto.
* winsup.api/ltp/write02.c: Ditto.
* winsup.api/ltp/write03.c: Ditto.
@
text
@/*
 * Copyright (c) 2000 Silicon Graphics, Inc.  All Rights Reserved.
 * 
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 * 
 * This program is distributed in the hope that it would be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * 
 * Further, this software is distributed without any warranty that it is
 * free of the rightful claim of any third person regarding infringement
 * or the like.  Any license provided herein, whether implied or
 * otherwise, applies only to this software file.  Patent licenses, if
 * any, provided herein do not apply to combinations of this program with
 * other software, or any other product whatsoever.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write the Free Software Foundation, Inc., 59
 * Temple Place - Suite 330, Boston MA 02111-1307, USA.
 * 
 * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
 * Mountain View, CA  94043, or:
 * 
 * http://www.sgi.com 
 * 
 * For further information regarding this notice, see: 
 * 
 * http://oss.sgi.com/projects/GenInfo/NoticeExplan/
 */

/* $Id: tst_sig.c,v 1.2 2000/09/06 14:21:53 duda Exp $ */

/*****************************************************************************
	OS Testing  - Silicon Graphics, Inc.

	FUNCTION IDENTIFIER : tst_sig  Set up for unexpected signals.

	AUTHOR          : David D. Fenner

	CO-PILOT        : Bill Roske

	DATE STARTED    : 06/06/90

	This module may be linked with c-modules requiring unexpected
	signal handling.  The parameters to tst_sig are as follows:

		fork_flag - set to FORK or NOFORK depending upon whether the
			calling program executes a fork() system call.  It
			is normally the case that the calling program treats
			SIGCLD as an expected signal if fork() is being used.

		handler - a pointer to the unexpected signal handler to
			be executed after an unexpected signal has been
			detected.  If handler is set to DEF_HANDLER, a 
			default handler is used.  This routine should be
			declared as function returning an int.

		cleanup - a pointer to a cleanup routine to be executed
			by the unexpected signal handler before tst_exit is
			called.  This parameter is set to NULL if no cleanup
			routine is required.  An external variable, T_cleanup
			is set so that other user-defined handlers have 
			access to the cleanup routine.  This routine should be
			declared as returning type void.

***************************************************************************/

#ifndef CRAY
#define _BSD_SIGNALS	1	/* Specify that we are using BSD signal interface */
#endif

#include <errno.h>
#include <string.h>
#include <signal.h>
#include "test.h"

#define MAXMESG 150		/* size of mesg string sent to tst_res */

void (*T_cleanup)();		/* pointer to cleanup function */

extern int errno;
static void def_handler();		/* default signal handler */

/****************************************************************************
 * tst_sig() : set-up to catch unexpected signals.  fork_flag is set to NOFORK
 *    if SIGCLD is to be an "unexpected signal", otherwise it is set to
 *    FORK.  cleanup points to a cleanup routine to be executed before
 *    tst_exit is called (cleanup is set to NULL if no cleanup is desired).
 *    handler is a pointer to the signal handling routine (if handler is
 *    set to NULL, a default handler is used).
 ***************************************************************************/

void
tst_sig(int fork_flag, void (*handler)(), void (*cleanup)())
{
	char mesg[MAXMESG];		/* message buffer for tst_res */
	int sig;

	/*
	 * save T_cleanup and handler function pointers
	 */
	T_cleanup = cleanup;		/* used by default handler */

	if (handler == DEF_HANDLER) {
		/* use default handler */
		handler = def_handler;
	}

	/*
	 * now loop through all signals and set the handlers
	 */

	for (sig = 1; sig < NSIG; sig++) {
	    /*
	     * SIGKILL is never unexpected.
	     * SIGCLD is only unexpected when
	     *    no forking is being done.
	     * SIGINFO is used for file quotas and should be expected
	     */

	    switch (sig) {
	        case SIGKILL:
	        case SIGSTOP:
	        case SIGCONT:
#ifdef CRAY
	        case SIGINFO:
	        case SIGRECOVERY:	/* allow chkpnt/restart */
#endif  /* CRAY */

#ifdef SIGSWAP
  case SIGSWAP:
#endif /* SIGSWAP */

#ifdef SIGCKPT
	        case SIGCKPT:
#endif
#ifdef SIGRESTART
	        case SIGRESTART:
#endif
                /*
                 * pthread-private signals SIGPTINTR and SIGPTRESCHED.
                 * Setting a handler for these signals is disallowed when
                 * the binary is linked against libpthread.
                 */
#ifdef SIGPTINTR
                case SIGPTINTR:
#endif /* SIGPTINTR */
#ifdef SIGPTRESCHED
                case SIGPTRESCHED:
#endif /* SIGPTRESCHED */
#ifdef __CYGWIN__
		case SIGILL:
		case SIGTRAP:
		case SIGABRT:
		case SIGEMT:
		case SIGFPE:
		case SIGBUS:
#endif
	            break;

	        case SIGCLD:
	            if ( fork_flag == FORK )
		        continue;

	        default:
		    if (signal(sig, handler) == SIG_ERR) {
		        (void) sprintf(mesg,
			    "signal() failed for signal %d. error:%d %s.",
			    sig, errno, strerror(errno));
		        tst_resm(TWARN, mesg);
		    }
		break;
            }
#ifdef __sgi
	    /* On irix  (07/96), signal() fails when signo is 33 or higher */
	    if ( sig+1 >= 33 )
		break;
#endif  /*  __sgi */

	} /* endfor */
}



/****************************************************************************
 * def_handler() : default signal handler that is invoked when
 *      an unexpected signal is caught.
 ***************************************************************************/

static void
def_handler(int sig)
{
	char mesg[MAXMESG];		/* holds tst_res message */

	/* first reset trap for this signal (except SIGCLD - its weird) */
	if ((sig != SIGCLD) && (sig != SIGSTOP) && (sig != SIGCONT)) {
		if (signal(sig, def_handler) == SIG_ERR) {
			(void) sprintf(mesg,
				"def_handler: signal() failed for signal %d. error:%d %s.",
				sig, errno, strerror(errno));
			tst_resm(TWARN, mesg);
		}
	}

	(void) sprintf(mesg, "Unexpected signal %d received.", sig);

	/*
         * Break remaining test cases, do any cleanup, then exit
	 */
	tst_brkm(TBROK, 0, mesg);

	/* now cleanup and exit */
	if (T_cleanup) {
		(*T_cleanup)();
	}

	tst_exit();
}
@


1.2
log
@Add 'const' qualifiers where needed to avoid compiler warnings.
* libltp/lib/tst_sig.c (tst_sig): Don't attempt to cleanup on
fatal errors.
* libltp/lib/parse_opts.c (parse_opts): Initialize allocated
string to prevent heap corruption.
@
text
@d33 1
a33 1
/* $Id: tst_sig.c,v 1.1 2000/09/03 03:52:30 cgf Exp $ */
a153 1
		case SIGSEGV:
@


1.1
log
@Importing Egor's testsuite.
@
text
@d33 1
a33 1
/* $Id: tst_sig.c,v 1.2 2000/08/30 18:43:38 nstraz Exp $ */
d153 9
a161 1

@

