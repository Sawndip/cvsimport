head	1.69;
access;
symbols
	cygwin-1_7_35-release:1.69
	cygwin-1_7_34-release:1.68
	cygwin-1_7_33-release:1.62
	cygwin-1_7_32-release:1.62
	cygwin-1_7_31-release:1.62
	cygwin-1_7_30-release:1.62
	cygwin-1_7_29-release:1.62
	cygwin-1_7_29-release-branchpoint:1.62.0.2
	cygwin-1_7_28-release:1.62
	cygwin-1_7_27-release:1.62
	cygwin-1_7_26-release:1.62
	cygwin-1_7_25-release:1.62
	cygwin-1_7_24-release:1.62
	cygwin-1_7_23-release:1.62
	cygwin-1_7_22-release:1.62
	cygwin-1_7_21-release:1.62
	cygwin-1_7_20-release:1.62
	cygwin-1_7_19-release:1.62
	cygwin-64bit-postmerge:1.62
	cygwin-64bit-premerge-branch:1.61.0.2
	cygwin-64bit-premerge:1.61
	cygwin-1_7_18-release:1.61
	cygwin-1_7_17-release:1.60
	cygwin-64bit-branch:1.60.0.2
	cygwin-1_7_16-release:1.60
	cygwin-1_7_15-release:1.60
	cygwin-1_7_14_2-release:1.59
	cygwin-1_7_14-release:1.59
	cygwin-1_7_12-release:1.58
	cygwin-1_7_11-release:1.58
	cygwin-1_7_10-release:1.58
	cygwin-1_7_9-release:1.55
	cygwin-1_7_8-release:1.55
	cygwin-1_7_7-release:1.55
	cygwin-1_7_5-release:1.54
	cygwin-1_7_4-release:1.54
	cygwin-1_7_3-release:1.54
	cygwin-1_7_2-release:1.54
	cygwin-1_7_1-release:1.54
	cv-branch-2:1.52.0.2
	cr-0x5f1:1.36.0.6
	cv-branch:1.36.0.4
	cr-0x3b58:1.36.0.2
	cr-0x9e:1.33.0.4
	cr-0x9d:1.33.0.2
	corinna-01:1.32
	cr-0x9c:1.32.0.4
	cr-0x9b:1.32.0.6
	cr-0x99:1.32
	Z-emcb-cygwin_daemon:1.32.0.2
	w32api-2_2:1.28
	mingw-runtime-2_4:1.28
	cygnus_cvs_20020108_pre:1.18
	Z-cygwin_daemon_merge-new_HEAD:1.12
	Z-cygwin_daemon_merge_HEAD:1.12
	cygwin_daemon:1.12.0.4;
locks; strict;
comment	@ * @;
expand	@o@;


1.69
date	2015.02.25.20.18.29;	author corinna;	state Exp;
branches;
next	1.68;

1.68
date	2014.11.27.19.55.37;	author corinna;	state Exp;
branches;
next	1.67;

1.67
date	2014.11.12.14.22.05;	author corinna;	state Exp;
branches;
next	1.66;

1.66
date	2014.11.12.14.13.56;	author corinna;	state Exp;
branches;
next	1.65;

1.65
date	2014.11.10.16.21.52;	author corinna;	state Exp;
branches;
next	1.64;

1.64
date	2014.07.29.13.29.54;	author corinna;	state Exp;
branches;
next	1.63;

1.63
date	2014.02.24.10.51.42;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2013.04.23.09.44.36;	author corinna;	state Exp;
branches;
next	1.61;

1.61
date	2013.01.21.16.28.27;	author cgf;	state Exp;
branches;
next	1.60;

1.60
date	2012.05.05.08.55.17;	author corinna;	state Exp;
branches
	1.60.2.1;
next	1.59;

1.59
date	2012.04.05.13.37.32;	author corinna;	state Exp;
branches;
next	1.58;

1.58
date	2011.12.17.23.39.47;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2011.12.01.13.06.13;	author corinna;	state Exp;
branches;
next	1.56;

1.56
date	2011.10.10.14.57.47;	author corinna;	state Exp;
branches;
next	1.55;

1.55
date	2010.08.28.11.22.37;	author corinna;	state Exp;
branches;
next	1.54;

1.54
date	2009.10.02.13.49.39;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2009.08.11.08.59.50;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2009.05.15.11.30.18;	author corinna;	state Exp;
branches;
next	1.51;

1.51
date	2009.05.06.11.54.24;	author corinna;	state Exp;
branches;
next	1.50;

1.50
date	2008.08.25.09.38.14;	author corinna;	state Exp;
branches;
next	1.49;

1.49
date	2008.08.18.08.52.49;	author corinna;	state Exp;
branches;
next	1.48;

1.48
date	2008.08.18.08.33.48;	author corinna;	state Exp;
branches;
next	1.47;

1.47
date	2008.08.17.17.00.50;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2008.08.17.16.45.44;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2008.08.15.13.08.47;	author corinna;	state Exp;
branches;
next	1.44;

1.44
date	2008.07.23.20.12.12;	author corinna;	state Exp;
branches;
next	1.43;

1.43
date	2008.07.23.18.09.50;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2008.07.23.11.41.10;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2008.07.22.20.47.14;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2008.07.22.14.40.05;	author corinna;	state Exp;
branches;
next	1.39;

1.39
date	2008.07.09.14.32.29;	author corinna;	state Exp;
branches;
next	1.38;

1.38
date	2008.03.12.12.47.09;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2008.02.28.11.11.12;	author corinna;	state Exp;
branches;
next	1.36;

1.36
date	2006.01.18.15.57.56;	author cgf;	state Exp;
branches
	1.36.6.1;
next	1.35;

1.35
date	2005.09.21.22.26.08;	author corinna;	state Exp;
branches;
next	1.34;

1.34
date	2005.01.11.23.03.24;	author phumblet;	state Exp;
branches;
next	1.33;

1.33
date	2003.11.14.19.14.43;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2003.04.26.22.33.00;	author joshuadfranklin;	state Exp;
branches;
next	1.31;

1.31
date	2003.04.26.21.52.03;	author joshuadfranklin;	state Exp;
branches;
next	1.30;

1.30
date	2003.04.10.01.14.18;	author phumblet;	state Exp;
branches;
next	1.29;

1.29
date	2003.03.01.16.38.26;	author phumblet;	state Exp;
branches;
next	1.28;

1.28
date	2003.01.15.10.08.37;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2003.01.08.17.38.11;	author corinna;	state Exp;
branches;
next	1.26;

1.26
date	2002.11.25.15.12.50;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2002.09.30.03.01.17;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2002.09.15.19.24.36;	author joshuadfranklin;	state Exp;
branches;
next	1.23;

1.23
date	2002.08.02.11.14.35;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.30.19.35.51;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2002.04.29.10.21.54;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.31.12.43.29;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.15.13.10.45;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.14.20.01.53;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.14.17.15.37;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.21.10.39.43;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.21.04.21.36;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2001.10.20.13.56.09;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2001.10.15.15.44.37;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.06.02.38.22;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.15.04.50.57;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.01.14.50.54;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.15.14.09.33;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.11.09.38.55;	author duda;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.07.10.31.01;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.07.03.20.21;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.08.15.00.02;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.28.05.00.00;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.18.18.39.11;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.15.22.30.49;	author corinna;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.60.2.1
date	2013.01.29.21.54.42;	author corinna;	state Exp;
branches;
next	1.60.2.2;

1.60.2.2
date	2013.02.06.17.03.49;	author corinna;	state Exp;
branches;
next	1.60.2.3;

1.60.2.3
date	2013.03.22.13.55.08;	author corinna;	state Exp;
branches;
next	;

1.36.6.1
date	2008.02.28.11.11.17;	author corinna;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.69
log
@	* mkgroup.c (MAX_SID_LEN): Remove.  Instead, use SECURITY_MAX_SID_SIZE
	throughout.
	(enum_unix_groups): Introduce numeric_psid and rearrange code to avoid
	potential heap corruption.
	* mkpasswd.c: Ditto.
@
text
@/* mkpasswd.c:

   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006, 2008, 2009,
   2010, 2011, 2012, 2013, 2014, 2015 Red Hat, Inc.

   This file is part of Cygwin.

   This software is a copyrighted work licensed under the terms of the
   Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
   details. */

#define _WIN32_WINNT 0x0600
#include <errno.h>
#include <ctype.h>
#include <stdlib.h>
#include <wchar.h>
#include <wctype.h>
#include <locale.h>
#include <stdio.h>
#include <unistd.h>
#include <inttypes.h>
#include <getopt.h>
#include <io.h>
#include <pwd.h>
#include <sys/fcntl.h>
#include <sys/cygwin.h>
#include <cygwin/version.h>
#include <windows.h>
#include <lm.h>
#include <iptypes.h>
#include <wininet.h>
#include <ntsecapi.h>
#include <dsgetdc.h>
#include <ntdef.h>

#define print_win_error(x) _print_win_error(x, __LINE__)

SID_IDENTIFIER_AUTHORITY sid_world_auth = {SECURITY_WORLD_SID_AUTHORITY};
SID_IDENTIFIER_AUTHORITY sid_nt_auth = {SECURITY_NT_AUTHORITY};

#ifndef min
#define min(a,b) (((a)<(b))?(a):(b))
#endif

typedef struct
{
  char *str;
  BOOL domain;
  BOOL with_dom;
} domlist_t;

static void
_print_win_error(DWORD code, int line)
{
  char buf[4096];

  if (FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM
      | FORMAT_MESSAGE_IGNORE_INSERTS,
      NULL,
      code,
      MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),
      (LPTSTR) buf, sizeof (buf), NULL))
    fprintf (stderr, "mkpasswd (%d): [%" PRIu32 "] %s",
	     line, (unsigned int) code, buf);
  else
    fprintf (stderr, "mkpasswd (%d): error %" PRIu32,
	     line, (unsigned int) code);
}

static char *
put_sid (PSID sid)
{
  static char s[512];
  char t[32];
  DWORD i;

  strcpy (s, "S-1-");
  sprintf(t, "%u", GetSidIdentifierAuthority (sid)->Value[5]);
  strcat (s, t);
  for (i = 0; i < *GetSidSubAuthorityCount (sid); ++i)
    {
      sprintf(t, "-%" PRIu32, (unsigned int) *GetSidSubAuthority (sid, i));
      strcat (s, t);
    }
  return s;
}

static void
uni2ansi (LPWSTR wcs, char *mbs, int size)
{
  if (wcs)
    wcstombs (mbs, wcs, size);
  else
    *mbs = '\0';
}

typedef struct {
  PSID psid;
  int buffer[10];
} sidbuf;

static sidbuf curr_user;
static sidbuf curr_pgrp;
static BOOL got_curr_user = FALSE;

static void
fetch_current_user_sid ()
{
  DWORD len;
  HANDLE ptok;

  if (!OpenProcessToken (GetCurrentProcess (), TOKEN_QUERY, &ptok)
      || !GetTokenInformation (ptok, TokenUser, &curr_user, sizeof curr_user,
			       &len)
      || !GetTokenInformation (ptok, TokenPrimaryGroup, &curr_pgrp,
			       sizeof curr_pgrp, &len)
      || !CloseHandle (ptok))
    {
      print_win_error (GetLastError ());
      return;
    }
}

static void
enum_unix_users (domlist_t *mach, const char *sep, DWORD id_offset,
		 char *unix_user_list)
{
  WCHAR machine[INTERNET_MAX_HOST_NAME_LENGTH + 1];
  SID_IDENTIFIER_AUTHORITY auth = { { 0, 0, 0, 0, 0, 22 } };
  char *ustr, *user_list;
  WCHAR user[UNLEN + sizeof ("Unix User\\") + 1];
  WCHAR dom[MAX_DOMAIN_NAME_LEN + 1];
  DWORD ulen, dlen, sidlen;
  PSID psid;
  PSID numeric_psid;
  char psid_buffer[SECURITY_MAX_SID_SIZE];
  SID_NAME_USE acc_type;

  int ret = mbstowcs (machine, mach->str, INTERNET_MAX_HOST_NAME_LENGTH + 1);
  if (ret < 1 || ret >= INTERNET_MAX_HOST_NAME_LENGTH + 1)
    {
      fprintf (stderr, "%s: Invalid machine name '%s'.  Skipping...\n",
	       program_invocation_short_name, mach->str);
      return;
    }

  if (!AllocateAndInitializeSid (&auth, 2, 1, 0, 0, 0, 0, 0, 0, 0,
				 &numeric_psid))
    return;

  if (!(user_list = strdup (unix_user_list)))
    {
      FreeSid (numeric_psid);
      return;
    }

  for (ustr = strtok (user_list, ","); ustr; ustr = strtok (NULL, ","))
    {
      if (!isdigit ((unsigned char) ustr[0]) && ustr[0] != '-')
	{
	  PWCHAR p = wcpcpy (user, L"Unix User\\");
	  ret = mbstowcs (p, ustr, UNLEN + 1);
	  if (ret < 1 || ret >= UNLEN + 1)
	    {
	      fprintf (stderr, "%s: Invalid user name '%s'.  Skipping...\n",
		       program_invocation_short_name, ustr);
	      continue;
	    }
	  psid = (PSID) psid_buffer;
	  sidlen = SECURITY_MAX_SID_SIZE;
	  dlen = MAX_DOMAIN_NAME_LEN + 1;
	  if (LookupAccountNameW (machine, user, psid, &sidlen,
				  dom, &dlen, &acc_type))
	    printf ("%s%s%ls:*:%" PRIu32 ":99999:,%s::\n",
		    "Unix_User",
		    sep,
		    user + 10,
		    (unsigned int) (id_offset +
		    *GetSidSubAuthority (psid,
					 *GetSidSubAuthorityCount(psid) - 1)),
		    put_sid (psid));
	}
      else
	{
	  DWORD start, stop;
	  char *p = ustr;
	  if (*p == '-')
	    start = 0;
	  else
	    start = strtol (p, &p, 10);
	  if (!*p)
	    stop = start;
	  else if (*p++ != '-' || !isdigit ((unsigned char) *p)
		   || (stop = strtol (p, &p, 10)) < start || *p)
	    {
	      fprintf (stderr, "%s: Malformed unix user list entry '%s'.  "
			       "Skipping...\n",
			       program_invocation_short_name, ustr);
	      continue;
	    }
	  for (; start <= stop; ++ start)
	    {
	      psid = numeric_psid;
	      *GetSidSubAuthority (psid, *GetSidSubAuthorityCount(psid) - 1)
	      = start;
	      ulen = GNLEN + 1;
	      dlen = MAX_DOMAIN_NAME_LEN + 1;
	      if (LookupAccountSidW (machine, psid, user, &ulen,
				     dom, &dlen, &acc_type)
		  && !iswdigit (user[0]))
		printf ("%s%s%ls:*:%" PRIu32 ":99999:,%s::\n",
			"Unix_User",
			sep,
			user,
			(unsigned int) (id_offset + start),
			put_sid (psid));
	    }
	}
    }

  free (user_list);
  FreeSid (numeric_psid);
}

static int
enum_users (domlist_t *mach, const char *sep, const char *passed_home_path,
	    DWORD id_offset, char *disp_username, int print_current)
{
  WCHAR machine[INTERNET_MAX_HOST_NAME_LENGTH + 1];
  USER_INFO_3 *buffer;
  DWORD entriesread = 0;
  DWORD totalentries = 0;
  DWORD resume_handle = 0;
  DWORD rc;
  WCHAR uni_name[UNLEN + 1];

  int ret = mbstowcs (machine, mach->str, INTERNET_MAX_HOST_NAME_LENGTH + 1);
  if (ret < 1 || ret >= INTERNET_MAX_HOST_NAME_LENGTH + 1)
    {
      fprintf (stderr, "%s: Invalid machine name '%s'.  Skipping...\n",
	       program_invocation_short_name, mach->str);
      return 1;
    }

  do
    {
      DWORD i;

      if (disp_username != NULL)
	{
	  mbstowcs (uni_name, disp_username, UNLEN + 1);
	  rc = NetUserGetInfo (machine, (LPWSTR) &uni_name, 3,
			       (void *) &buffer);
	  entriesread = 1;
	  /* Avoid annoying error messages just because the user hasn't been
	     found. */
	  if (rc == NERR_UserNotFound)
	    return 0;
	}
      else
	rc = NetUserEnum (machine, 3, FILTER_NORMAL_ACCOUNT,
			  (void *) &buffer, MAX_PREFERRED_LENGTH,
			  &entriesread, &totalentries, &resume_handle);
      switch (rc)
	{
	case ERROR_ACCESS_DENIED:
	  print_win_error(rc);
	  return 1;

	case ERROR_MORE_DATA:
	case ERROR_SUCCESS:
	  break;

	default:
	  print_win_error(rc);
	  return 1;
	}

      for (i = 0; i < entriesread; i++)
	{
	  char homedir_psx[PATH_MAX];
	  WCHAR domain_name[MAX_DOMAIN_NAME_LEN + 1];
	  DWORD domname_len = MAX_DOMAIN_NAME_LEN + 1;
	  char psid_buffer[SECURITY_MAX_SID_SIZE];
	  PSID psid = (PSID) psid_buffer;
	  DWORD sid_length = SECURITY_MAX_SID_SIZE;
	  SID_NAME_USE acc_type;

	  int uid = buffer[i].usri3_user_id;
	  int gid = buffer[i].usri3_primary_group_id;
	  homedir_psx[0] = '\0';
	  if (passed_home_path[0] == '\0')
	    {
	      if (buffer[i].usri3_home_dir[0] != L'\0')
		cygwin_conv_path (CCP_WIN_W_TO_POSIX | CCP_ABSOLUTE,
				  buffer[i].usri3_home_dir, homedir_psx,
				  PATH_MAX);
	      else
		uni2ansi (buffer[i].usri3_name,
			  stpcpy (homedir_psx, "/home/"), PATH_MAX - 6);
	    }
	  else
	    uni2ansi (buffer[i].usri3_name,
		      stpcpy (homedir_psx, passed_home_path),
		      PATH_MAX - strlen (passed_home_path));

	  if (!LookupAccountNameW (machine, buffer[i].usri3_name,
				   psid, &sid_length, domain_name,
				   &domname_len, &acc_type))
	    {
	      print_win_error(GetLastError ());
	      fprintf(stderr, " (%ls)\n", buffer[i].usri3_name);
	      continue;
	    }
	  else if (acc_type == SidTypeDomain)
	    {
	      WCHAR domname[MAX_DOMAIN_NAME_LEN + UNLEN + 2];

	      wcscpy (domname, machine);
	      wcscat (domname, L"\\");
	      wcscat (domname, buffer[i].usri3_name);
	      sid_length = SECURITY_MAX_SID_SIZE;
	      domname_len = sizeof (domname);
	      if (!LookupAccountNameW (machine, domname, psid,
				       &sid_length, domain_name,
				       &domname_len, &acc_type))
		{
		  print_win_error(GetLastError ());
		  fprintf(stderr, " (%ls)\n", domname);
		  continue;
		}
	    }
	  if (!print_current)
	    /* fall through */;
	  else if (EqualSid (curr_user.psid, psid))
	    got_curr_user = TRUE;

	  printf ("%ls%s%ls:*:%" PRIu32 ":%" PRIu32
		  ":%ls%sU-%ls\\%ls,%s:%s:/bin/bash\n",
		  mach->with_dom ? domain_name : L"",
		  mach->with_dom ? sep : "",
		  buffer[i].usri3_name,
		  (unsigned int) (id_offset + uid),
		  (unsigned int) (id_offset + gid),
		  buffer[i].usri3_full_name ?: L"",
		  buffer[i].usri3_full_name
		  && buffer[i].usri3_full_name[0] ? "," : "",
		  domain_name,
		  buffer[i].usri3_name,
		  put_sid (psid),
		  homedir_psx);
	}

      NetApiBufferFree (buffer);

    }
  while (rc == ERROR_MORE_DATA);

  return 0;
}

static int
usage (FILE * stream)
{
  fprintf (stream,
"Usage: %s [OPTIONS]...\n"
"\n"
"Write /etc/passwd-like output to stdout\n"
"\n"
"Don't use this command to generate a local /etc/passwd file, unless you\n"
"really need one.  See the Cygwin User's Guide for more information.\n"
"\n"
"Options:\n"
"\n"
"   -l,--local [machine]    Print local user accounts of \"machine\",\n"
"                           from local machine if no machine specified.\n"
"                           Automatically adding machine prefix for local\n"
"                           machine depends on settings in /etc/nsswitch.conf.\n"
"   -L,--Local machine      Ditto, but generate username with machine prefix.\n"
"   -d,--domain [domain]    Print domain accounts,\n"
"                           from current domain if no domain specified.\n"
"   -c,--current            Print current user.\n"
"   -S,--separator char     For -L use character char as domain\\user\n"
"                           separator in username instead of the default '%s'.\n"
"   -o,--id-offset offset   Change the default offset (0x10000) added to uids\n"
"                           of foreign local machine accounts.  Use with -l/-L.\n"
"   -u,--username username  Only return information for the specified user.\n"
"                           One of -l, -d must be specified, too\n"
"   -b,--no-builtin         Don't print BUILTIN users.\n"
"   -p,--path-to-home path  Use specified path instead of user account home dir\n"
"                           or /home prefix.\n"
"   -U,--unix userlist      Print UNIX users when using -l on a UNIX Samba\n"
"                           server.  Userlist is a comma-separated list of\n"
"                           usernames or uid ranges (root,-25,50-100).\n"
"                           Enumerating large ranges can take a long time!\n"
"   -h,--help               Displays this message.\n"
"   -V,--version            Version information and exit.\n"
"\n"
"Default is to print local accounts on stand-alone machines, domain accounts\n"
"on domain controllers and domain member machines.\n"
"\n", program_invocation_short_name,
      (const char *) cygwin_internal (CW_GETNSSSEP));
  return 1;
}

static struct option longopts[] = {
  {"no-builtin", no_argument, NULL, 'b'},
  {"current", no_argument, NULL, 'c'},
  {"Current", no_argument, NULL, 'C'},
  {"domain", optional_argument, NULL, 'd'},
  {"Domain", optional_argument, NULL, 'D'},
  {"local-groups", no_argument, NULL, 'g'},
  {"help", no_argument, NULL, 'h'},
  {"local", optional_argument, NULL, 'l'},
  {"Local", optional_argument, NULL, 'L'},
  {"no-mount", no_argument, NULL, 'm'},
  {"id-offset", required_argument, NULL, 'o'},
  {"path-to-home", required_argument, NULL, 'p'},
  {"no-sids", no_argument, NULL, 's'},
  {"separator", required_argument, NULL, 'S'},
  {"username", required_argument, NULL, 'u'},
  {"unix", required_argument, NULL, 'U'},
  {"version", no_argument, NULL, 'V'},
  {0, no_argument, NULL, 0}
};

static char opts[] = "bcCd::D::ghl::L::mo:sS:p:u:U:V";

static void
print_version ()
{
  printf ("mkpasswd (cygwin) %d.%d.%d\n"
	  "Passwd File Generator\n"
	  "Copyright (C) 1997 - %s Red Hat, Inc.\n"
	  "This is free software; see the source for copying conditions.  There is NO\n"
	  "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n",
	  CYGWIN_VERSION_DLL_MAJOR / 1000,
	  CYGWIN_VERSION_DLL_MAJOR % 1000,
	  CYGWIN_VERSION_DLL_MINOR,
	  strrchr (__DATE__, ' ') + 1);
}

int
main (int argc, char **argv)
{
  int print_domlist = 0;
  domlist_t domlist[32];
  char cname[1024];
  char *opt, *p, *ep;
  int print_current = 0;
  int print_builtin = 1;
  char *print_unix = NULL;
  const char *nss_sep = (const char *) cygwin_internal (CW_GETNSSSEP);
  const char *sep_char = nss_sep;
  DWORD id_offset = 0x10000, off;
  int c, i;
  char *disp_username = NULL;
  char passed_home_path[PATH_MAX];
  int optional_args = 0;
  uintptr_t nss_src = cygwin_internal (CW_GETNSS_PWD_SRC);

  passed_home_path[0] = '\0';
  if (!isatty (1))
    setmode (1, O_BINARY);

  /* Use locale from environment.  If not set or set to "C", use UTF-8. */
  setlocale (LC_CTYPE, "");
  if (!strcmp (setlocale (LC_CTYPE, NULL), "C"))
    setlocale (LC_CTYPE, "en_US.UTF-8");
  fetch_current_user_sid ();

  if (argc == 1)
    {
      int enums = ENUM_PRIMARY | ENUM_LOCAL | ENUM_BUILTIN;
      uintptr_t ticket = cygwin_internal (CW_SETENT, FALSE, enums, NULL);
      if (ticket)
	{
	  struct passwd *pwd;

	  while ((pwd = (struct passwd *) cygwin_internal (CW_GETENT, FALSE,
							   ticket)))
	    printf ("%s:%s:%u:%u:%s:%s:%s\n", pwd->pw_name, pwd->pw_passwd,
		    pwd->pw_uid, pwd->pw_gid, pwd->pw_gecos, pwd->pw_dir,
		    pwd->pw_shell);
	  cygwin_internal (CW_ENDENT, FALSE, ticket);
	}
      return 0;
    }

  unsetenv ("POSIXLY_CORRECT"); /* To get optional arg processing right. */
  while ((c = getopt_long (argc, argv, opts, longopts, NULL)) != EOF)
    switch (c)
      {
      case 'd':
      case 'D':
      case 'l':
      case 'L':
	if (print_domlist >= 32)
	  {
	    fprintf (stderr, "%s: Can not enumerate from more than 32 "
			     "domains and machines.\n",
			     program_invocation_short_name);
	    return 1;
	  }
	domlist[print_domlist].domain = (c == 'd' || c == 'D');
	opt = optarg ?:
	      argv[optind] && argv[optind][0] != '-' ? argv[optind] : NULL;
	if (argv[optind] && opt == argv[optind])
	  ++optional_args;
	for (i = 0; i < print_domlist; ++i)
	  if (domlist[i].domain == domlist[print_domlist].domain
	      && ((!domlist[i].str && !opt)
		  || (domlist[i].str && opt
		      && (off = strlen (domlist[i].str))
		      && !strncmp (domlist[i].str, opt, off)
		      && (!opt[off] || opt[off] == ','))))
	    {
	      fprintf (stderr, "%s: Duplicate %s '%s'.  Skipping...\n",
		       program_invocation_short_name,
		       domlist[i].domain ? "domain" : "machine",
		       domlist[i].str);
	      break;
	    }
	domlist[print_domlist].str = opt;
	if (opt && (p = strchr (opt, ',')))
	  {
	    if (p == opt)
	      {
		fprintf (stderr, "%s: Malformed domain string '%s'.  "
			 "Skipping...\n", program_invocation_short_name, opt);
		break;
	      }
	    *p = '\0';
	  }
	if (c == 'l' || c == 'L')
	  {
	    DWORD csize = sizeof cname;

	    domlist[print_domlist].with_dom = (c == 'L');
	    if (!opt)
	      {
		/* If the system uses /etc/passwd exclusively as account DB,
		   create local group names the old fashioned way. */
		if (nss_src == NSS_SRC_FILES)
		  {
		    GetComputerNameExA (ComputerNameNetBIOS, cname, &csize);
		    domlist[print_domlist].str = cname;
		  }
	      }
	    else if (nss_src != NSS_SRC_FILES)
	      {
		/* If the system uses Windows account DBs, check if machine
		   name is local machine.  If so, remove the domain name to
		   enforce system naming convention. */
		if (GetComputerNameExA (strchr (opt, '.')
					? ComputerNameDnsFullyQualified
					: ComputerNameNetBIOS,
					cname, &csize)
		    && strcasecmp (opt, cname) == 0)
		  domlist[print_domlist].str = NULL;
	      }
	  }
	++print_domlist;
	break;
      case 'S':
	sep_char = optarg;
	if (strlen (sep_char) > 1)
	  {
	    fprintf (stderr, "%s: Only one ASCII character allowed as "
			     "domain\\user separator character.\n",
			     program_invocation_short_name);
	    return 1;
	  }
	if (*sep_char == ':')
	  {
	    fprintf (stderr, "%s: Colon not allowed as domain\\user separator "
			     "character.\n", program_invocation_short_name);
	    return 1;
	  }
	break;
      case 'U':
	print_unix = optarg;
	break;
      case 'c':
      case 'C':
	print_current = 1;
	break;
      case 'o':
	id_offset = strtoul (optarg, &ep, 10);
	break;
      case 'b':
	print_builtin = 0;
	break;
      case 'p':
	if (optarg[0] != '/')
	{
	  fprintf (stderr, "%s: '%s' is not a fully qualified path.\n",
		   program_invocation_short_name, optarg);
	  return 1;
	}
	strcpy (passed_home_path, optarg);
	if (optarg[strlen (optarg)-1] != '/')
	  strcat (passed_home_path, "/");
	break;
      case 'u':
	disp_username = optarg;
	break;
      case 'h':
	usage (stdout);
	return 0;
      case 'V':
	print_version ();
	return 0;
      case 'g':		/* deprecated */
      case 's':		/* deprecated */
      case 'm':		/* deprecated */
	break;
      default:
	fprintf (stderr, "Try `%s --help' for more information.\n",
		 program_invocation_short_name);
	return 1;
      }

  optind += optional_args;
  if (argv[optind])
    {
      fprintf (stderr,
	       "mkpasswd: non-option command line argument `%s' is not allowed.\n"
	       "Try `mkpasswd --help' for more information.\n", argv[optind]);
      exit (1);
    }

  struct passwd *ppwd = NULL;
  const char *ppwd_sid = NULL;
  if (print_current)
    {
      ppwd = (struct passwd *) cygwin_internal (CW_GETPWSID, TRUE,
						curr_user.psid);
      if (ppwd)
	ppwd_sid = strrchr (ppwd->pw_gecos, ',');
    }

  int enums = ENUM_NONE;
  WCHAR tdoms[print_domlist * 258];
  PWCHAR t = tdoms;
  if (!disp_username && print_builtin && print_domlist)
    enums |= ENUM_BUILTIN;
  for (i = 0; i < print_domlist; ++i)
    {
      if (domlist[i].domain)
        {
          if (domlist[i].str)
            {
              enums |= ENUM_TDOMS;
              t += mbstowcs (t, domlist[i].str, 257);
              *t++ = L'\0';
            }
          else
            enums |= ENUM_PRIMARY;
        }
      else if (!domlist[i].str)
        enums |= ENUM_LOCAL;
    }
  if (t > tdoms)
    *t++ = L'\0';
  if (enums)
    {
      uintptr_t ticket = cygwin_internal (CW_SETENT, FALSE, enums,
                                          t > tdoms ? tdoms : NULL);
      if (ticket)
        {
          struct passwd *pwd;

          while ((pwd = (struct passwd *)
                        cygwin_internal (CW_GETENT, FALSE, ticket)))
            {
	      p = NULL;
              if (disp_username
                  && strcasecmp (disp_username, pwd->pw_name) != 0
                  && (!(p = strchr (pwd->pw_name, nss_sep[0]))
                      || strcasecmp (disp_username, p + 1) != 0))
                continue;
	      printf ("%s:%s:%u:%u:%s:%s%s:%s\n", pwd->pw_name, pwd->pw_passwd,
		      pwd->pw_uid, pwd->pw_gid, pwd->pw_gecos,
		      passed_home_path[0] ? passed_home_path : "",
		      passed_home_path[0] ? (p ? p + 1 : pwd->pw_name)
					  : pwd->pw_dir,
		      pwd->pw_shell);
	      const char *pwd_sid = strrchr (pwd->pw_gecos, ',');
              if (ppwd && ppwd_sid && pwd_sid && !strcmp (pwd_sid, ppwd_sid))
                got_curr_user = TRUE;
            }
          cygwin_internal (CW_ENDENT, FALSE, ticket);
        }
    }

  if (print_current && !got_curr_user)
    {
      p = strchr (ppwd->pw_name, nss_sep[0]);
      printf ("%s:%s:%u:%u:%s:%s%s:%s\n", ppwd->pw_name, ppwd->pw_passwd,
	      ppwd->pw_uid, ppwd->pw_gid, ppwd->pw_gecos,
	      passed_home_path[0] ? passed_home_path : "",
	      passed_home_path[0] ? (p ? p + 1 : ppwd->pw_name) : ppwd->pw_dir,
	      ppwd->pw_shell);
    }

  off = 0xfd000000;
  for (i = 0; i < print_domlist; ++i)
    {
      if (domlist[i].domain || !domlist[i].str)
	continue;
      enum_users (domlist + i, sep_char, passed_home_path,
		  (nss_src == NSS_SRC_FILES) ? 0x30000 : off,
		  disp_username, print_current);
      if (!domlist[i].domain && domlist[i].str && print_unix)
	enum_unix_users (domlist + i, sep_char, 0xff000000, print_unix);
      off += id_offset;
    }

  return 0;
}
@


1.68
log
@	* mkgroup.c (main): Call enum_groups with offset 0x30000 for local
	machine, same as from DB.
	* mkpasswd.c (enum_unix_users): Set pw_passwd field to '*'.
	(enum_users): Ditto.
	(main): Call enum_users with offset of 0x30000 for local machine,
	same as from DB.
@
text
@d4 1
a4 1
   2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
a37 2
#define MAX_SID_LEN 40

d135 2
a136 1
  char psid_buffer[MAX_SID_LEN];
d147 2
a148 1
  if (!AllocateAndInitializeSid (&auth, 2, 1, 0, 0, 0, 0, 0, 0, 0, &psid))
d153 1
a153 1
      FreeSid (psid);
d164 10
a173 8
	    fprintf (stderr, "%s: Invalid user name '%s'.  Skipping...\n",
		     program_invocation_short_name, ustr);
	  else if (LookupAccountNameW (machine, user,
				       psid = (PSID) psid_buffer,
				       (sidlen = MAX_SID_LEN, &sidlen),
				       dom,
				       (dlen = MAX_DOMAIN_NAME_LEN + 1, &dlen),
				       &acc_type))
d203 1
d206 4
a209 5
	      if (LookupAccountSidW (machine, psid,
				     user, (ulen = GNLEN + 1, &ulen),
				     dom,
				     (dlen = MAX_DOMAIN_NAME_LEN + 1, &dlen),
				     &acc_type)
d222 1
a222 1
  FreeSid (psid);
d284 1
a284 1
	  char psid_buffer[MAX_SID_LEN];
d286 1
a286 1
	  DWORD sid_length = MAX_SID_LEN;
d322 1
a322 1
	      sid_length = MAX_SID_LEN;
@


1.67
log
@	* mkgroup.c (usage): Fix language.
	* mkpasswd.c (usage): Ditto.
@
text
@d172 1
a172 1
	    printf ("%s%s%ls:unused:%" PRIu32 ":99999:,%s::\n",
d209 1
a209 1
		printf ("%s%s%ls:unused:%" PRIu32 ":99999:,%s::\n",
d336 1
a336 1
	  printf ("%ls%s%ls:unused:%" PRIu32 ":%" PRIu32
d458 1
d542 1
a542 1
		if (cygwin_internal (CW_GETNSS_PWD_SRC) == NSS_SRC_FILES)
d548 1
a548 1
	    else if (cygwin_internal (CW_GETNSS_PWD_SRC) != NSS_SRC_FILES)
d710 3
a712 2
      enum_users (domlist + i, sep_char, passed_home_path, off, disp_username,
		  print_current);
@


1.66
log
@	* mkgroup.c (enum_unix_groups): Always print groupname with machine
	prefix.
	(usage): Extend help output for -l option.
	(main): Drop superfluous goto and label.  Make machine prefixing for
	local machine when using -l option dependend on options in
	/etc/nsswitch.conf.
	* mkpasswd.c: Ditto.
@
text
@d373 1
a373 1
"   -l,--local [machine]    print local user accounts of \"machine\",\n"
d375 17
a391 17
"                           automatically adding machine prefix for local\n"
"                           machine depends on settings in /etc/nsswitch.conf)\n"
"   -L,--Local machine      ditto, but generate username with machine prefix\n"
"   -d,--domain [domain]    print domain accounts\n"
"                           (from current domain if no domain specified)\n"
"   -c,--current            print current user\n"
"   -S,--separator char     for -l use character char as domain\\user\n"
"                           separator in username instead of the default '%s'\n"
"   -o,--id-offset offset   change the default offset (0x10000) added to uids\n"
"                           of foreign local machine accounts.  Use with -l.\n"
"   -u,--username username  only return information for the specified user\n"
"                           one of -l, -d must be specified, too\n"
"   -b,--no-builtin         don't print BUILTIN users\n"
"   -p,--path-to-home path  use specified path instead of user account home dir\n"
"                           or /home prefix\n"
"   -U,--unix userlist      print UNIX users when using -l on a UNIX Samba\n"
"                           server.  userlist is a comma-separated list of\n"
d393 3
a395 3
"                           (enumerating large ranges can take a long time!)\n"
"   -h,--help               displays this message\n"
"   -V,--version            version information and exit\n"
@


1.65
log
@	* cygcheck.cc (dump_sysinfo): Handle Windows 10/Server 2014(?).
@
text
@d51 1
d338 2
a339 2
		  domain_name,
		  sep,
d373 5
a377 2
"   -l,--local [machine]    print local user accounts of \"machine\"\n"
"                           (from local machine if no machine specified)\n"
d446 1
d532 1
a532 1
	if ((c == 'l' || c == 'L') && opt)
a533 1
	    char cname[1024];
d536 23
a558 7
	    /* Check if machine name is local machine.  Keep it simple. */
	    if (GetComputerNameExA (strchr (opt, '.')
				    ? ComputerNameDnsFullyQualified
				    : ComputerNameNetBIOS,
				    cname, &csize)
		&& strcasecmp (opt, cname) == 0)
	      domlist[print_domlist].str = NULL;
@


1.64
log
@	* mkgroup.c (usage): Move info message that this /etc/group isn't really
	required anymore more to the top of the usage output.
	* mkpasswd.c (usage): Ditto for /etc/passwd.  Drop old text from output.
@
text
@a50 1
  BOOL with_dom;
d172 2
a173 2
		    mach->with_dom ? "Unix_User" : "",
		    mach->with_dom ? sep : "",
d209 2
a210 2
			mach->with_dom ? "Unix_User" : "",
			mach->with_dom ? sep : "",
d337 2
a338 2
		  mach->with_dom ? domain_name : L"",
		  mach->with_dom ? sep : "",
d372 1
a372 1
"   -l,--local [machine]    print local user accounts\n"
a373 1
"   -L,--Local machine      ditto, but generate username with machine prefix\n"
d380 1
a380 1
"                           in domain or foreign server accounts.\n"
d514 1
a514 1
	      goto skip;
d521 1
a521 1
		fprintf (stderr, "%s: Malformed domain,offset string '%s'.  "
d527 14
a540 2
	domlist[print_domlist++].with_dom = (c == 'L');
skip:
@


1.63
log
@	* mkgroup.c (domlist_t): Drop id_offset.
	(get_dcname): Remove.
	(current_group): Remove.
	(enum_unix_groups): Simplify.  Change space to underscore in domain
	name.
	(enum_local_groups): Simplify to accommodate the fact that it's only
	called for foreign machines.
	(enum_groups): Ditto.
	(print_special_by_sid): Remove.
	(print_special_by_name): Remove.
	(usage): Align to new code.
	(fetch_primary_domain): Remove.
	(main): Use cygwin_internal CW_SETENT, CW_GETENT and CW_ENDENT method.
	Call enum_local_groups, enum_groups, and enum_unix_groups only for
	foreign machines.
	* mkpasswd.c (get_dcname): Remove.
	(current_user): Remove.
	(enum_unix_users): Simplify.  Change space to underscore in domain name.
	(enum_users): Simplify to accommodate the fact that it's only
	called for foreign machines.
	(print_special_by_sid): Remove.
	(usage): Align to new code.
	(longopts): Add -b/--no-builtin option.
	(opts): Add -b option.
	(print_special_by_name): Remove.
	(enum_std_accounts): Remove.
	(fetch_primary_domain): Remove.
	(main): Use cygwin_internal CW_SETENT, CW_GETENT and CW_ENDENT method.
	Call enum_users and enum_unix_users only for foreign machines.
	* utils.xml (mkgroup): Align documentation to new usage.
	(mkpasswd): Ditto.
@
text
@d368 3
d373 1
a373 1
"   -l,--local [machine]    print local user accounts with uid offset offset\n"
d376 1
a376 1
"   -d,--domain [domain]    print domain accounts with uid offset offset\n"
d396 1
a396 3
"on domain controllers and domain member machines.\n\n"
"Don't use this command to generate a local /etc/passwd file, unless you\n"
"really need one.  See the Cygwin User's Guide for more information.\n"
@


1.62
log
@	* Merge in cygwin-64bit-branch.
@
text
@d4 1
a4 1
   2010, 2011, 2012, 2013 Red Hat, Inc.
d24 1
a34 1
#include "loadlib.h"
a49 1
  DWORD id_offset;
a71 25
static PWCHAR
get_dcname (char *domain)
{
  static WCHAR server[INTERNET_MAX_HOST_NAME_LENGTH + 1];
  DWORD rc;
  WCHAR domain_name[MAX_DOMAIN_NAME_LEN + 1];
  PDOMAIN_CONTROLLER_INFOW pdci = NULL;

  if (domain)
    {
      mbstowcs (domain_name, domain, strlen (domain) + 1);
      rc = DsGetDcNameW (NULL, domain_name, NULL, NULL, 0, &pdci);
    }
  else
    rc = DsGetDcNameW (NULL, NULL, NULL, NULL, 0, &pdci);
  if (rc != ERROR_SUCCESS)
    {
      print_win_error (rc);
      return (PWCHAR) -1;
    }
  wcscpy (server, pdci->DomainControllerName);
  NetApiBufferFree (pdci);
  return server;
}

d127 1
a127 60
current_user (const char *sep, const char *passed_home_path, DWORD id_offset,
	      const char *disp_username)
{
  WCHAR user[UNLEN + 1];
  WCHAR dom[MAX_DOMAIN_NAME_LEN + 1];
  DWORD ulen = UNLEN + 1;
  DWORD dlen = MAX_DOMAIN_NAME_LEN + 1;
  SID_NAME_USE acc_type;
  int uid, gid;
  char homedir_psx[PATH_MAX] = {0};

  if (!curr_user.psid || !curr_pgrp.psid
      || !LookupAccountSidW (NULL, curr_user.psid, user, &ulen, dom, &dlen,
			     &acc_type))
    {
      print_win_error (GetLastError ());
      return;
    }

  uid = *GetSidSubAuthority (curr_user.psid,
			     *GetSidSubAuthorityCount(curr_user.psid) - 1);
  gid = *GetSidSubAuthority (curr_pgrp.psid,
			     *GetSidSubAuthorityCount(curr_pgrp.psid) - 1);
  if (passed_home_path[0] == '\0')
    {
      char *envhome = getenv ("HOME");

      /* If $HOME exists and is non-empty, just copy it over to homedir_psx.
	 Otherwise, generate a new path of the form "/home/$USER". */
      if (envhome && envhome[0] != '\0')
	strncat (homedir_psx, envhome, sizeof (homedir_psx) - 1);
      else
	{
	  wcstombs (stpncpy (homedir_psx, "/home/", sizeof (homedir_psx)),
		    user, sizeof (homedir_psx) - 6);
	  homedir_psx[PATH_MAX - 1] = '\0';
	}
    }
  else
    {
      char *p = stpncpy (homedir_psx, passed_home_path, sizeof (homedir_psx));
      wcstombs (p, user, sizeof (homedir_psx) - (p - homedir_psx));
      homedir_psx[PATH_MAX - 1] = '\0';
    }

  printf ("%ls%s%ls:unused:%" PRIu32 ":%" PRIu32
	  ":U-%ls\\%ls,%s:%s:/bin/bash\n",
	  sep ? dom : L"",
	  sep ?: "",
	  user,
	  (unsigned int) (id_offset + uid),
	  (unsigned int) (id_offset + gid),
	  dom,
	  user,
	  put_sid (curr_user.psid),
	  homedir_psx);
}

static void
enum_unix_users (domlist_t *dom_or_machine, const char *sep, DWORD id_offset,
a130 3
  PWCHAR servername = NULL;
  char *d_or_m = dom_or_machine ? dom_or_machine->str : NULL;
  BOOL with_dom = dom_or_machine ? dom_or_machine->with_dom : FALSE;
d140 1
a140 4
  if (!d_or_m)
    return;

  int ret = mbstowcs (machine, d_or_m, INTERNET_MAX_HOST_NAME_LENGTH + 1);
d144 1
a144 1
	       program_invocation_short_name, d_or_m);
a146 1
  servername = machine;
d166 1
a166 1
	  else if (LookupAccountNameW (servername, user,
d173 2
a174 2
		    with_dom ? "Unix User" : "",
		    with_dom ? sep : "",
d203 1
a203 1
	      if (LookupAccountSidW (servername, psid,
d210 2
a211 2
			with_dom ? "Unix User" : "",
			with_dom ? sep : "",
d224 2
a225 3
enum_users (BOOL domain, domlist_t *dom_or_machine, const char *sep,
	    const char *passed_home_path, DWORD id_offset, char *disp_username,
	    int print_current)
a227 3
  PWCHAR servername = NULL;
  char *d_or_m = dom_or_machine ? dom_or_machine->str : NULL;
  BOOL with_dom = dom_or_machine ? dom_or_machine->with_dom : FALSE;
d234 3
a236 1
  if (domain)
d238 3
a240 14
      servername = get_dcname (d_or_m);
      if (servername == (PWCHAR) -1)
	return 1;
    }
  else if (d_or_m)
    {
      int ret = mbstowcs (machine, d_or_m, INTERNET_MAX_HOST_NAME_LENGTH + 1);
      if (ret < 1 || ret >= INTERNET_MAX_HOST_NAME_LENGTH + 1)
	{
	  fprintf (stderr, "%s: Invalid machine name '%s'.  Skipping...\n",
		   program_invocation_short_name, d_or_m);
	  return 1;
	}
      servername = machine;
d250 1
a250 1
	  rc = NetUserGetInfo (servername, (LPWSTR) &uni_name, 3,
d259 1
a259 1
	rc = NetUserEnum (servername, 3, FILTER_NORMAL_ACCOUNT,
d305 1
a305 1
	  if (!LookupAccountNameW (servername, buffer[i].usri3_name,
d317 1
a317 2
	      wcscpy (domname, domain || !servername
			       ? domain_name : servername);
d322 1
a322 1
	      if (!LookupAccountNameW (servername, domname, psid,
d338 2
a339 2
		  with_dom ? domain_name : L"",
		  with_dom ? sep : "",
a359 43
static void
print_special_by_sid (PSID_IDENTIFIER_AUTHORITY auth, BYTE cnt,
		      DWORD sub1, DWORD sub2, DWORD sub3, DWORD sub4,
		      DWORD sub5, DWORD sub6, DWORD sub7, DWORD sub8)
{
  WCHAR user[UNLEN + 1], dom[MAX_DOMAIN_NAME_LEN + 1];
  DWORD len, len2, rid;
  PSID sid;
  SID_NAME_USE acc_type;

  if (AllocateAndInitializeSid (auth, cnt, sub1, sub2, sub3, sub4,
				sub5, sub6, sub7, sub8, &sid))
    {
      if (LookupAccountSidW (NULL, sid,
			     user, (len = UNLEN + 1, &len),
			     dom, (len2 = MAX_DOMAIN_NAME_LEN + 1, &len2),
			     &acc_type))
	{
	  if (sub8)
	    rid = sub8;
	  else if (sub7)
	    rid = sub7;
	  else if (sub6)
	    rid = sub6;
	  else if (sub5)
	    rid = sub5;
	  else if (sub4)
	    rid = sub4;
	  else if (sub3)
	    rid = sub3;
	  else if (sub2)
	    rid = sub2;
	  else
	    rid = sub1;
	  printf ("%ls:*:%" PRIu32 ":%" PRIu32 ":,%s::\n",
		  user, (unsigned int) rid,
		  (unsigned int) (rid == 18 ? 544 : rid), /* SYSTEM hack */
		  put_sid (sid));
	}
      FreeSid (sid);
    }
}

d366 1
a366 1
"Print /etc/passwd file to stdout\n"
d370 1
a370 2
"   -l,--local [machine[,offset]]\n"
"                           print local user accounts with uid offset offset\n"
d372 2
a373 4
"   -L,--Local [machine[,offset]]\n"
"                           ditto, but generate username with machine prefix\n"
"   -d,--domain [domain[,offset]]\n"
"                           print domain accounts with uid offset offset\n"
a374 2
"   -D,--Domain [domain[,offset]]\n"
"                           ditto, but generate username with domain prefix\n"
d376 3
a378 5
"   -C,--Current            ditto, but generate username with machine or\n"
"                           domain prefix\n"
"   -S,--separator char     for -L, -D, -C use character char as domain\\user\n"
"                           separator in username instead of the default '\\'\n"
"   -o,--id-offset offset   change the default offset (10000) added to uids\n"
d381 2
a382 1
"                           one of -l, -L, -d, -D must be specified, too\n"
d385 3
a387 4
"   -U,--unix userlist      additionally print UNIX users when using -l or -L\n"
"                           on a UNIX Samba server\n"
"                           userlist is a comma-separated list of usernames\n"
"                           or uid ranges (root,-25,50-100).\n"
a388 3
"   -s,--no-sids            (ignored)\n"
"   -m,--no-mount           (ignored)\n"
"   -g,--local-groups       (ignored)\n"
d393 5
a397 2
"on domain controllers and domain member machines.\n"
"\n", program_invocation_short_name);
d402 1
d422 1
a422 1
static char opts[] = "cCd::D::ghl::L::mo:sS:p:u:U:V";
a437 60
static void
print_special_by_name (PCWSTR name, uid_t uid, gid_t gid)
{
  DWORD size = 256, dom_size = 256;
  PSID sid = (PSID) alloca (size);
  WCHAR dom[dom_size];
  SID_NAME_USE use;

  PWCHAR name_only = wcschr (name, L'\\');
  if (name_only)
    ++name_only;

  if (LookupAccountNameW (NULL, name, sid, &size, dom, &dom_size, &use))
    printf ("%ls:*:%lu:%lu:U-%ls%s%ls,%s::\n",
	    name_only ?: name,
	    (unsigned long) uid,
	    (unsigned long) gid,
	    name_only ? dom : L"",
	    name_only ? "\\" : "",
	    name_only ?: name,
	    put_sid (sid));
}

static void
enum_std_accounts ()
{
  /* Generate service starter account entries. */
  printf ("SYSTEM:*:18:544:,S-1-5-18::\n");
  printf ("LocalService:*:19:544:U-NT AUTHORITY\\LocalService,S-1-5-19::\n");
  printf ("NetworkService:*:20:544:U-NT AUTHORITY\\NetworkService,S-1-5-20::\n");
  /* Get 'administrators' group (has localized name). */
  print_special_by_sid (&sid_nt_auth, 2, SECURITY_BUILTIN_DOMAIN_RID,
			DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0);
  /* Fetch "TrustedInstaller" account starting with Vista. */
  print_special_by_name (L"NT SERVICE\\TrustedInstaller", -2, -2);
}

static PPOLICY_PRIMARY_DOMAIN_INFO p_dom;

static BOOL
fetch_primary_domain ()
{
  NTSTATUS status;
  LSA_OBJECT_ATTRIBUTES oa = { 0, 0, 0, 0, 0, 0 };
  LSA_HANDLE lsa;

  if (!p_dom)
    {
      status = LsaOpenPolicy (NULL, &oa, POLICY_VIEW_LOCAL_INFORMATION, &lsa);
      if (!NT_SUCCESS (status))
	return FALSE;
      status = LsaQueryInformationPolicy (lsa, PolicyPrimaryDomainInformation,
					  (PVOID *) ((void *) &p_dom));
      LsaClose (lsa);
      if (!NT_SUCCESS (status))
	return FALSE;
    }
  return !!p_dom->Sid;
}

d445 1
d447 3
a449 2
  const char *sep_char = "\\";
  DWORD id_offset = 10000, off;
a452 1
  BOOL in_domain;
a462 1
  in_domain = fetch_primary_domain ();
d467 13
a479 7
      enum_std_accounts ();
      if (in_domain)
	enum_users (TRUE, NULL, sep_char, passed_home_path, 10000,
		    disp_username, 0);
      else
	enum_users (FALSE, NULL, sep_char, passed_home_path, 0,
		    disp_username, 0);
a517 1
	domlist[print_domlist].id_offset = UINT32_MAX;
d520 1
a520 4
	    if (p == opt
		|| !isdigit ((unsigned char) p[1])
		|| (domlist[print_domlist].id_offset = strtol (p + 1, &ep, 10)
		    , *ep))
d528 1
a528 1
	domlist[print_domlist++].with_dom = (c == 'D' || c == 'L');
d535 2
a536 2
	    fprintf (stderr, "%s: Only one character allowed as domain\\user "
			     "separator character.\n",
a550 2
	sep_char = NULL;
	/*FALLTHRU*/
d556 3
a558 6
	if (*ep)
	  {
	    fprintf (stderr, "%s: Malformed offset '%s'.  "
		     "Skipping...\n", program_invocation_short_name, optarg);
	    return 1;
	  }
d599 15
a613 1
  off = id_offset;
d616 45
a660 11
      DWORD my_off = (domlist[i].domain || domlist[i].str)
		     ? domlist[i].id_offset != UINT_MAX
		       ? domlist[i].id_offset : off : 0;
      if (!domlist[i].domain && domlist[i].str && print_unix)
	enum_unix_users (domlist + i, sep_char, my_off, print_unix);
      if (!my_off && !disp_username)
	enum_std_accounts ();
      enum_users (domlist[i].domain, domlist + i, sep_char, passed_home_path,
		  my_off, disp_username, print_current);
      if (my_off)
	off += id_offset;
d664 20
a683 1
    current_user (sep_char, passed_home_path, off, disp_username);
@


1.61
log
@Update copyrights
@
text
@d4 1
a4 1
   2010, 2011, 2012 Red Hat, Inc.
d21 1
d66 2
a67 1
    fprintf (stderr, "mkpasswd (%d): [%lu] %s", line, code, buf);
d69 2
a70 1
    fprintf (stderr, "mkpasswd (%d): error %lu", line, code);
d110 1
a110 1
      sprintf(t, "-%lu", *GetSidSubAuthority (sid, i));
d198 2
a199 1
  printf ("%ls%s%ls:unused:%lu:%lu:U-%ls\\%ls,%s:%s:/bin/bash\n",
d203 2
a204 2
	  id_offset + uid,
	  id_offset + gid,
d264 1
a264 1
	    printf ("%s%s%ls:unused:%lu:99999:,%s::\n",
d268 1
a268 1
		    id_offset +
d270 1
a270 1
					 *GetSidSubAuthorityCount(psid) - 1),
d301 1
a301 1
		printf ("%s%s%ls:unused:%lu:99999:,%s::\n",
d305 1
a305 1
			id_offset + start,
d442 2
a443 1
	  printf ("%ls%s%ls:unused:%lu:%lu:%ls%sU-%ls\\%ls,%s:%s:/bin/bash\n",
d447 2
a448 2
		  id_offset + uid,
		  id_offset + gid,
d481 1
a481 1
			     dom, (len2 = MAX_DOMAIN_NAME_LEN + 1, &len),
d500 3
a502 2
	  printf ("%ls:*:%lu:%lu:,%s::\n",
		  user, rid, rid == 18 ? 544 : rid, /* SYSTEM hack */
d727 1
a727 1
	domlist[print_domlist].id_offset = ULONG_MAX;
d821 1
a821 1
		     ? domlist[i].id_offset != ULONG_MAX
@


1.60
log
@	* mkpasswd.c (current_user): Actually *use* $HOME if it's available.
	Add comment to explain what we're doing here.
@
text
@d3 2
a4 2
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006,
   2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.60.2.1
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006, 2008, 2009,
   2010, 2011, 2012 Red Hat, Inc.
@


1.60.2.2
log
@	Throughout, fix type problems on 32 and 64 bit.  Except:
	* ssp.c: Disable entire functionality on x86_64 for now.
@
text
@d4 1
a4 1
   2010, 2011, 2012, 2013 Red Hat, Inc.
a20 1
#include <inttypes.h>
d65 1
a65 2
    fprintf (stderr, "mkpasswd (%d): [%" PRIu32 "] %s",
	     line, (unsigned int) code, buf);
d67 1
a67 2
    fprintf (stderr, "mkpasswd (%d): error %" PRIu32,
	     line, (unsigned int) code);
d107 1
a107 1
      sprintf(t, "-%" PRIu32, (unsigned int) *GetSidSubAuthority (sid, i));
d195 1
a195 2
  printf ("%ls%s%ls:unused:%" PRIu32 ":%" PRIu32
	  ":U-%ls\\%ls,%s:%s:/bin/bash\n",
d199 2
a200 2
	  (unsigned int) (id_offset + uid),
	  (unsigned int) (id_offset + gid),
d260 1
a260 1
	    printf ("%s%s%ls:unused:%" PRIu32 ":99999:,%s::\n",
d264 1
a264 1
		    (unsigned int) (id_offset +
d266 1
a266 1
					 *GetSidSubAuthorityCount(psid) - 1)),
d297 1
a297 1
		printf ("%s%s%ls:unused:%" PRIu32 ":99999:,%s::\n",
d301 1
a301 1
			(unsigned int) (id_offset + start),
d438 1
a438 2
	  printf ("%ls%s%ls:unused:%" PRIu32 ":%" PRIu32
		  ":%ls%sU-%ls\\%ls,%s:%s:/bin/bash\n",
d442 2
a443 2
		  (unsigned int) (id_offset + uid),
		  (unsigned int) (id_offset + gid),
d476 1
a476 1
			     dom, (len2 = MAX_DOMAIN_NAME_LEN + 1, &len2),
d495 2
a496 3
	  printf ("%ls:*:%" PRIu32 ":%" PRIu32 ":,%s::\n",
		  user, (unsigned int) rid,
		  (unsigned int) (rid == 18 ? 544 : rid), /* SYSTEM hack */
d721 1
a721 1
	domlist[print_domlist].id_offset = UINT32_MAX;
@


1.60.2.3
log
@	* kill.cc (main): Chack pid against INT_MIN and (U)INT_MAX since pid_t
	is 4 byte on all platforms.
	* mkgroup.c (main): Check domlist[i].id_offset against UINT_MAX since
	DWORD is 4 byte on all platforms.
	* mkpasswd.c (main): Ditto.
@
text
@d821 1
a821 1
		     ? domlist[i].id_offset != UINT_MAX
@


1.59
log
@	* mkgroup.c (print_special_by_sid): Rename from print_special.  Change
	calls throughout.
	(print_special_by_name): New function.
	(main): Call print_special_by_name for TrustedInstaller account.
	* mkpasswd.c (print_special_by_sid): Rename from print_special.  Change
	calls throughout.
	(print_special_by_name): New function.
	(enum_std_accounts): Call print_special_by_name for TrustedInstaller
	account.
@
text
@d175 1
a175 1
      char *envhome = getenv ("HOME");	/* POSIX! */
d177 5
a181 1
      if (!envhome || envhome[0] == '\0')
@


1.58
log
@Clean up whitespace.
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011 Red Hat, Inc.
d458 3
a460 3
print_special (PSID_IDENTIFIER_AUTHORITY auth, BYTE cnt,
	       DWORD sub1, DWORD sub2, DWORD sub3, DWORD sub4,
	       DWORD sub5, DWORD sub6, DWORD sub7, DWORD sub8)
d584 23
d614 4
a617 2
  print_special (&sid_nt_auth, 2, SECURITY_BUILTIN_DOMAIN_RID,
		 DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0);
@


1.57
log
@	* mkgroup.c: Drop support for NT4 domains.
	* mkpasswd.c: Ditto.
	(psx_dir): Remove.
	(current_user): Drop support for -m option.  Use $HOME as is since it's
	a POSIX path anyway.
	(enum_users): Drop support for -m option.
	(usage): Mention -m option as ignored.
	(main): Drop support for -m option.  Mark ignored options as deprecated.
	* utils.sgml (mkpasswd): Remove description of -m option.
@
text
@d573 3
a575 3
          "Passwd File Generator\n"
          "Copyright (C) 1997 - %s Red Hat, Inc.\n"
          "This is free software; see the source for copying conditions.  There is NO\n"
d577 4
a580 4
          CYGWIN_VERSION_DLL_MAJOR / 1000,
          CYGWIN_VERSION_DLL_MAJOR % 1000,
          CYGWIN_VERSION_DLL_MINOR,
          strrchr (__DATE__, ' ') + 1);
@


1.56
log
@	* Align usage output, version output, as well as usage and version
	option handling to use the same style throughout all Cygwin utils.
	Throughout use program_invocation_short_name to refer to current
	process name in Cygwin executables.
	* utils.sgml: Align documentation to above change.  Add missing
	sections for getconf, ldd, and setmetamode.
	* strace.cc (proc_child): Avoid compiler warning.
@
text
@a41 2
NET_API_STATUS WINAPI (*dsgetdcname)(LPWSTR,LPWSTR,GUID*,LPWSTR,ULONG,PDOMAIN_CONTROLLER_INFOW*);

a69 9
static void
load_dsgetdcname ()
{
  HANDLE h = LoadLibrary ("netapi32.dll");

  if (h)
    dsgetdcname = (void *) GetProcAddress (h, "DsGetDcNameW");
}

a74 1
  PWCHAR servername;
d78 1
a78 1
  if (dsgetdcname)
d80 2
a81 14
      if (domain)
	{
	  mbstowcs (domain_name, domain, strlen (domain) + 1);
	  rc = dsgetdcname (NULL, domain_name, NULL, NULL, 0, &pdci);
	}
      else
	rc = dsgetdcname (NULL, NULL, NULL, NULL, 0, &pdci);
      if (rc != ERROR_SUCCESS)
	{
	  print_win_error(rc);
	  return (PWCHAR) -1;
	}
      wcscpy (server, pdci->DomainControllerName);
      NetApiBufferFree (pdci);
d84 2
d87 2
a88 15
      rc = NetGetDCName (NULL, NULL, (void *) &servername);
      if (rc == ERROR_SUCCESS && domain)
	{
	  LPWSTR server = servername;
	  mbstowcs (domain_name, domain, strlen (domain) + 1);
	  rc = NetGetDCName (server, domain_name, (void *) &servername);
	  NetApiBufferFree (server);
	}
      if (rc != ERROR_SUCCESS)
	{
	  print_win_error(rc);
	  return (PWCHAR) -1;
	}
      wcscpy (server, servername);
      NetApiBufferFree ((PVOID) servername);
d90 2
a113 23
psx_dir (char *in, char *out)
{
  if (isalpha ((unsigned char) in[0]) && in[1] == ':')
    {
      sprintf (out, "/cygdrive/%c", in[0]);
      in += 2;
      out += strlen (out);
    }

  while (*in)
    {
      if (*in == '\\')
	*out = '/';
      else
	*out = *in;
      in++;
      out++;
    }

  *out = '\0';
}

static void
d150 2
a151 2
current_user (int print_cygpath, const char *sep, const char *passed_home_path,
	      DWORD id_offset, const char *disp_username)
d175 1
a175 1
      char *envhome = getenv ("HOME");
d177 1
a177 9
      if (envhome && envhome[0])
	{
	  if (print_cygpath)
	    cygwin_conv_path (CCP_WIN_A_TO_POSIX | CCP_ABSOLUTE, envhome,
			      homedir_psx, PATH_MAX);
	  else
	    psx_dir (envhome, homedir_psx);
	}
      else
d309 2
a310 2
	    int print_cygpath, const char *passed_home_path, DWORD id_offset,
	    char *disp_username, int print_current)
a376 1
	  char homedir_w32[MAX_PATH];
d386 1
a386 1
	  homedir_w32[0] = homedir_psx[0] = '\0';
d389 4
a392 10
	      uni2ansi (buffer[i].usri3_home_dir, homedir_w32,
			sizeof (homedir_w32));
	      if (homedir_w32[0] != '\0')
		{
		  if (print_cygpath)
		    cygwin_conv_path (CCP_WIN_A_TO_POSIX | CCP_ABSOLUTE,
				      homedir_w32, homedir_psx, PATH_MAX);
		  else
		    psx_dir (homedir_w32, homedir_psx);
		}
a529 1
"   -m,--no-mount           don't use mount points for home dir\n"
d536 1
a623 1
  int print_cygpath = 1;
a641 1
  load_dsgetdcname ();
d649 2
a650 2
	enum_users (TRUE, NULL, sep_char, print_cygpath, passed_home_path,
		    10000, disp_username, 0);
d652 1
a652 1
	enum_users (FALSE, NULL, sep_char, print_cygpath, passed_home_path, 0,
a742 7
      case 'g':
	break;
      case 's':
	break;
      case 'm':
	print_cygpath = 0;
	break;
d763 4
d792 2
a793 2
      enum_users (domlist[i].domain, domlist + i, sep_char, print_cygpath,
		  passed_home_path, my_off, disp_username, print_current);
d799 1
a799 2
    current_user (print_cygpath, sep_char, passed_home_path, off,
		  disp_username);
@


1.55
log
@	* loadlib.h: New header implementing safe LoadLibrary calls.
	Include throughout files using LoadLibrary function.
	* cygcheck.cc (dump_sysinfo): Retrieve kernel32.dll handle via
	GetModuleHandle, rather than using LoadLibrary.
	* cygpath.cc (get_long_name): Ditto.
	(do_sysfolders): Append .dll suffix in LoadLibrary call.
	* ldh.cc (WinMain): Use LoadLibraryExW with DONT_RESOLVE_DLL_REFERENCES
	to avoid loading malicious library code.
	* locale.cc (print_locale_with_codeset): Change way to retrieve
	kernel32.dll path.
@
text
@d4 1
a4 1
   2008, 2009, 2010 Red Hat, Inc.
d13 1
d25 1
a38 4
static const char version[] = "$Revision: 1.20 $";

extern char *__progname __declspec(dllimport);

d291 1
a291 1
	       __progname, d_or_m);
d313 1
a313 1
		     __progname, ustr);
d343 2
a344 1
			       "Skipping...\n", __progname, ustr);
d398 1
a398 1
		   __progname, d_or_m);
d574 2
a575 1
"Usage: mkpasswd [OPTIONS]...\n"
d579 1
d610 1
a610 1
"   -v,--version            version information and exit\n"
d613 2
a614 1
"on domain controllers and domain member machines.\n");
d634 1
a634 1
  {"version", no_argument, NULL, 'v'},
d638 1
a638 1
static char opts[] = "cCd::D::ghl::L::mo:sS:p:u:U:v";
d643 9
a651 18
  const char *v = strchr (version, ':');
  int len;
  if (!v)
    {
      v = "?";
      len = 1;
    }
  else
    {
      v += 2;
      len = strchr (v, ' ') - v;
    }
  printf ("\
mkpasswd (cygwin) %.*s\n\
passwd File Generator\n\
Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006, 2008 Red Hat, Inc.\n\
Compiled on %s\n\
", len, v, __DATE__);
d741 2
a742 1
			     "domains and machines.\n", __progname);
d759 2
a760 1
		       __progname, domlist[i].domain ? "domain" : "machine",
d774 1
a774 1
			 "Skipping...\n", __progname, opt);
d787 2
a788 1
			     "separator character.\n", __progname);
d794 1
a794 1
			     "character.\n", __progname);
d812 1
a812 1
		     "Skipping...\n", __progname, optarg);
d827 1
a827 1
		   __progname, optarg);
d840 1
a840 1
      case 'v':
d844 2
a845 1
	fprintf (stderr, "Try '%s --help' for more information.\n", __progname);
@


1.54
log
@* mkpasswd.c: Properly define __progname as __declspec(dllimport).
* mkgroup.c: Ditto.
@
text
@d4 1
a4 1
   2008, 2009 Red Hat, Inc.
d31 1
@


1.53
log
@	* mkgroup.c (enum_local_groups): Avoid error message if given group
	name isn't found and return 0 to allow searching to proceed.  Always
	return 0 or 1, not -1.
	(enum_groups): Avoid error message if given group name isn't found.
	* mkpasswd.c (enum_users): Ditto.
@
text
@d38 1
a38 1
extern char *__progname;
@


1.52
log
@	* cygpath.cc (main): Only setlocale for LC_CTYPE category.  Fallback
	to UTF-8 if locale is "C".
	* ldd.cc (main): Ditto.
	* mkgroup.c (main): Ditto.
	* mkpasswd.c (main): Ditto.
	* passwd.c (main): Ditto.
@
text
@d414 4
@


1.51
log
@	* mkpasswd.c (current_user): Don't use HOMEDRIVE/HOMEPATH to generate
	user's homedir.

	* mkgroup.c: Accommodate ctype changes.
	* mkpasswd.c: Ditto.
	* setfacl.c: Ditto.
	* ssp.c: Ditto.
@
text
@d17 1
d712 4
@


1.50
log
@	* mkgroup.c (enum_local_groups): Don't skip printing groups when
	print_current is set and group SID is not curr_pgrp.
	(enum_groups): Ditto.
	(main): Fix condition when SYSTEM group gets printed.
	* mkpasswd.c (enum_users): Don't skip printing users when print_current
	is set and user SID is not curr_user.
	(main): Allow printing standard accounts even when print_current is set.
@
text
@d4 1
a4 1
   2008 Red Hat, Inc.
d149 1
a149 1
  if (isalpha (in[0]) && in[1] == ':')
d215 1
a215 1
  char homedir_psx[PATH_MAX] = {0}, homedir_w32[MAX_PATH] = {0};
a231 2
      char *envhomedrive = getenv ("HOMEDRIVE");
      char *envhomepath = getenv ("HOMEPATH");
a240 13
      else if (envhomepath && envhomepath[0])
	{
	  if (envhomedrive)
	    strlcpy (homedir_w32, envhomedrive, sizeof (homedir_w32));
	  if (envhomepath[0] != '\\')
	    strlcat (homedir_w32, "\\", sizeof (homedir_w32));
	  strlcat (homedir_w32, envhomepath, sizeof (homedir_w32));
	  if (print_cygpath)
	    cygwin_conv_path (CCP_WIN_A_TO_POSIX | CCP_ABSOLUTE, homedir_w32,
			      homedir_psx, PATH_MAX);
	  else
	    psx_dir (homedir_w32, homedir_psx);
	}
d307 1
a307 1
      if (!isdigit (ustr[0]) && ustr[0] != '-')
d339 1
a339 1
	  else if (*p++ != '-' || !isdigit (*p)
d764 1
a764 1
		|| !isdigit (p[1])
@


1.49
log
@	* mkgroup.c (main): Keep correctly track of optional arguments.
	* mkpasswd.c (main): Ditto.
@
text
@a513 2
	  else
	    continue;
d874 1
a874 1
      if (!my_off && !print_current && !disp_username)
@


1.48
log
@	* mkgroup.c (main): Always unset environment variable POSIXLY_CORRECT.
	Keep track of optional argumnts and fix up optind afterwards.
	* mkpasswd.c (main): Ditto.
@
text
@d761 1
a761 1
	if (opt == argv[optind])
@


1.47
log
@* mkpasswd.c (main): Avoid printing system accounts when a single user name has
been requested.
@
text
@d722 1
d744 1
d761 2
d859 1
@


1.46
log
@* Makefile.in (ALL_LDFLAGS): Add --enable-auto-import option to quiet ld
warnings.
* mkgroup.c: Change all global variables and most functions to static.
(enum_local_groups): Add a print_current parameter to control whether entries
for everything should be printed or just the current user.
(enum_groups): Ditto.
(main): Move call fetch_current_pgrp_sid earlier to avoid a NULL deference when
no command line arguments are specified.  Accommodate argument changes to above
functions.  Avoid printing SYSTEM account when print_current is specified.
Issue error when extra stuff is found on the command line.
* mkpasswd.c: Change all global variables and most functions to static.
(enum_users): Add a print_current parameter to control whether entries for
everything should be printed or just the current user.
(main): Move call fetch_current_user_sid earlier to avoid a NULL deference when
no command line arguments are specified.  Accommodate argument change to above
function.  Avoid printing standard accounts when print_current is specified.
Issue error when extra stuff is found on the command line.
@
text
@d871 1
a871 1
      if (!my_off && !print_current)
@


1.45
log
@	* mkgroup.c (fetch_current_pgrp_sid): New function to fetch primary
	group SID from user token.
	(current_group): Move up in file.  Move fetching primary group SID to
	fetch_current_pgrp_sid.
	(enum_local_groups): Check if current SID is the same as current user's
	primary group SID.
	(enum_groups): Ditto.
	(main): Call fetch_current_pgrp_sid before enumerating groups.  Call
	current_group only if current group hasn't been enumerated already.
	* mkpasswd.c (fetch_current_user_sid): New function to fetch current
	user SID from user token.
	(current_user): Move fetching current user SID to
	fetch_current_user_sid.
	(enum_users): Check if current SID is the same as current user's SID.
	(main): Call fetch_current_user_sid before enumerating users.  Call
	current_user only if current user hasn't been enumerated already.
@
text
@d48 1
a48 1
typedef struct 
d56 1
a56 1
void
d72 1
a72 1
void
d128 1
a128 1
char *
d146 1
a146 1
void
d169 1
a169 1
void
d183 3
a185 3
sidbuf curr_user;
sidbuf curr_pgrp;
BOOL got_curr_user = FALSE;
d187 1
a187 1
void
d205 1
a205 1
void
d236 1
a236 1
        {
d244 1
a244 1
        {
d257 1
a257 1
        {
d282 1
a282 1
void
d306 1
a306 1
               __progname, d_or_m);
d323 1
a323 1
      	{
d335 4
a338 4
            printf ("%s%s%ls:unused:%lu:99999:,%s::\n",
                    with_dom ? "Unix User" : "",
                    with_dom ? sep : "",
                    user + 10,
d342 1
a342 1
                    put_sid (psid));
d385 1
a385 1
int
d388 1
a388 1
	    char *disp_username)
a399 1
  
d404 1
a404 1
      	return 1;
d429 1
a429 1
      else 
d510 3
a512 1
	  if (EqualSid (curr_user.psid, psid))
d514 3
d520 1
a520 1
	  	  buffer[i].usri3_name,
d524 1
a524 1
		  buffer[i].usri3_full_name 
d540 1
a540 1
void
d551 1
a551 1
  				sub5, sub6, sub7, sub8, &sid))
d577 1
a577 1
        }
d582 1
a582 1
int
d612 1
a612 1
"   -U,--unix userlist      additionally print UNIX users when using -l or -L\n" 
d627 1
a627 1
struct option longopts[] = {
d647 1
a647 1
char opts[] = "cCd::D::ghl::L::mo:sS:p:u:U:v";
d699 1
a699 1
					  (PVOID *) &p_dom);
d729 2
d736 1
a736 1
		    10000, disp_username);
d739 1
a739 1
		    disp_username);
d777 2
a778 2
	    	|| !isdigit (p[1])
	    	|| (domlist[print_domlist].id_offset = strtol (p + 1, &ep, 10)
d783 1
a783 1
	      	break;
d804 1
a804 1
        break;
d806 1
a806 1
        print_unix = optarg;
d855 7
a861 1
  fetch_current_user_sid ();
d871 2
a872 2
      if (!my_off)
      	enum_std_accounts ();
d874 1
a874 1
		  passed_home_path, my_off, disp_username);
d876 1
a876 1
      	off += id_offset;
@


1.44
log
@	* mkgroup.c (main): Fix test for duplicate domain/machine request.
	* mkpasswd.c (main): Ditto.
@
text
@d178 27
a208 6
  DWORD len;
  HANDLE ptok;
  struct {
    PSID psid;
    int buffer[10];
  } tu, tg;
d217 3
a219 5
  if (!OpenProcessToken (GetCurrentProcess (), TOKEN_QUERY, &ptok)
      || !GetTokenInformation (ptok, TokenUser, &tu, sizeof tu, &len)
      || !GetTokenInformation (ptok, TokenPrimaryGroup, &tg, sizeof tg, &len)
      || !CloseHandle (ptok)
      || !LookupAccountSidW (NULL, tu.psid, user, &ulen, dom, &dlen, &acc_type))
d225 4
a228 2
  uid = *GetSidSubAuthority (tu.psid, *GetSidSubAuthorityCount(tu.psid) - 1);
  gid = *GetSidSubAuthority (tg.psid, *GetSidSubAuthorityCount(tg.psid) - 1);
d278 1
a278 1
	  put_sid (tu.psid),
d511 2
a512 1

d849 2
d867 1
a867 1
  if (print_current)
@


1.43
log
@	* mkgroup.c: Rework to allow per-domain/per-machine id_offset.
	Add -b option to skip builtin groups.
	(main): Simplify code.
	* mkpasswd.c: Rework to allow per-domain/per-machine id_offset.
	(main): Simplify code.
	* utils.sgml: Explain changed mkgroup/mkpasswd -d/-D/-l/-L options.
	Add mkgroup -b option.
@
text
@d728 1
d732 12
a743 3
	  if ((!domlist[i].str && !opt)
	      || (domlist[i].str && opt && !strcmp (domlist[i].str, opt)))
	    goto skip;
a758 1
	domlist[print_domlist].domain = (c == 'd' || c == 'D');
@


1.42
log
@	* mkgroup.c: Consolidate variable names.
	(enum_unix_groups): New function.
	(print_special): Use LookupAccountSidW instead of LookupAccountSidA.
	(current_group): Ditto.
	(usage): Add -U option.
	(longopts): Add --unix option.
	(opts): Add -U option.
	(main): Handle -U option.  Call enum_unix_groups if set.
	* mkpasswd.c: Consolidate variable names.
	(current_user): Use LookupAccountSidW instead of LookupAccountSidA.
	(enum_unix_users): New function.
	(usage): Add -U option.
	(longopts): Add --unix option.
	(opts): Add -U option.
	(main): Handle -U option.  Call enum_unix_groups if set.
	* utils.sgml: Add -U option text to mkgroup and mkpasswd description.
@
text
@d51 2
d180 1
a180 1
	      int id_offset, const char *disp_username)
d249 1
a249 1
  printf ("%ls%s%ls:unused:%u:%u:U-%ls\\%ls,%s:%s:/bin/bash\n",
d253 2
a254 2
	  uid + id_offset,
	  gid + id_offset,
d262 1
a262 1
enum_unix_users (domlist_t *dom_or_machine, const char *sep, int id_offset,
d366 1
a366 1
	    int print_cygpath, const char *passed_home_path, int id_offset,
d491 1
a491 1
	  printf ("%ls%s%ls:unused:%u:%u:%ls%sU-%ls\\%ls,%s:%s:/bin/bash\n",
d495 2
a496 2
		  uid + id_offset,
		  gid + id_offset,
d564 10
a573 6
"   -l,--local [machine]    print local user accounts (from local machine\n"
"                           if no machine specified)\n"
"   -L,--Local [machine]    ditto, but generate username with machine prefix\n"
"   -d,--domain [domain]    print domain accounts (from current domain\n"
"                           if no domain specified)\n"
"   -D,--Domain [domain]    ditto, but generate username with domain prefix\n"
d684 3
a686 5
  int print_local = 0;
  domlist_t locals[16];
  int print_domain = 0;
  domlist_t domains[16];
  char *opt;
d691 2
a692 2
  int id_offset = 10000;
  int c, i, off;
d718 2
d722 1
a722 1
	if (print_local >= 16)
d724 2
a725 2
	    fprintf (stderr, "%s: Can not enumerate from more than 16 "
			     "servers.\n", __progname);
d730 7
a736 11
	for (i = 0; i < print_local; ++i)
	  if ((!locals[i].str && !opt)
	      || (locals[i].str && opt && !strcmp (locals[i].str, opt)))
	    goto skip_local;
	locals[print_local].str = opt;
	locals[print_local++].with_dom = c == 'L';
skip_local:
	break;
      case 'd':
      case 'D':
	if (print_domain >= 16)
d738 10
a747 3
	    fprintf (stderr, "%s: Can not enumerate from more than 16 "
			     "domains.\n", __progname);
	    return 1;
d749 3
a751 9
	opt = optarg ?:
	      argv[optind] && argv[optind][0] != '-' ? argv[optind] : NULL;
	for (i = 0; i < print_domain; ++i)
	  if ((!domains[i].str && !opt)
	      || (domains[i].str && opt && !strcmp (domains[i].str, opt)))
	    goto skip_domain;
	domains[print_domain].str = opt;
	domains[print_domain++].with_dom = c == 'D';
skip_domain:
d778 7
a784 1
	id_offset = strtol (optarg, NULL, 10);
d818 2
a819 5
  if (optind < argc - 1)
    usage (stdout);

  off = 1;
  for (i = 0; i < print_local; ++i)
d821 11
a831 13
      if (locals[i].str)
	{
	  if (print_unix)
	    enum_unix_users (locals + i, sep_char, id_offset * off, print_unix);
	  enum_users (FALSE, locals + i, sep_char, print_cygpath,
		      passed_home_path, id_offset * off++, disp_username);
      	}
      else
	{
	  enum_std_accounts ();
	  enum_users (FALSE, locals + i, sep_char, print_cygpath,
		      passed_home_path, 0, disp_username);
	}
a833 4
  for (i = 0; i < print_domain; ++i)
    enum_users (TRUE, domains + i, sep_char, print_cygpath, passed_home_path,
		id_offset * off++, disp_username);

d835 2
a836 1
    current_user (print_cygpath, sep_char, passed_home_path, id_offset, disp_username);
@


1.41
log
@	* mkgroup.c (enum_groups): Create full qualified groupname using
	domain or servername, depending on printing domain or machine accounts.
	* mkpasswd.c (enum_users): Ditto for users.
@
text
@d16 1
d186 2
a187 2
  char user[UNLEN + 1];
  char dom[MAX_DOMAIN_NAME_LEN + 1];
d198 1
a198 1
      || !LookupAccountSidA (NULL, tu.psid, user, &ulen, dom, &dlen, &acc_type))
d235 3
a237 2
	  strlcpy (homedir_psx, "/home/", sizeof (homedir_psx));
	  strlcat (homedir_psx, user, sizeof (homedir_psx));
d242 3
a244 2
      strlcpy (homedir_psx, passed_home_path, sizeof (homedir_psx));
      strlcat (homedir_psx, user, sizeof (homedir_psx));
d247 2
a248 2
  printf ("%s%s%s:unused:%u:%u:U-%s\\%s,%s:%s:/bin/bash\n",
	  sep ? dom : "",
d259 103
d517 1
a517 1
  char name[UNLEN + 1], dom[MAX_DOMAIN_NAME_LEN + 1];
d520 1
a520 1
  SID_NAME_USE use;
d525 4
a528 4
      if (LookupAccountSid (NULL, sid,
			    name, (len = UNLEN + 1, &len),
			    dom, (len2 = MAX_DOMAIN_NAME_LEN + 1, &len),
			    &use))
d546 2
a547 2
	  printf ("%s:*:%lu:%lu:,%s::\n",
		  name, rid, rid == 18 ? 544 : rid, /* SYSTEM hack */
d580 5
d610 1
d615 1
a615 1
char opts[] = "cCd::D::ghl::L::mo:sS:p:u:v";
d685 1
d765 3
d816 6
a821 2
	enum_users (FALSE, locals + i, sep_char, print_cygpath,
		    passed_home_path, id_offset * off++, disp_username);
@


1.40
log
@	* Makefile.in (cygcheck.exe): Link against ntdll.
	* bloda.cc: Use statically linked functions throughout.
	* cygpath.cc: Drop 9x considerations.
	* mkgroup.c: Revamp.  Redefine -l and -d options to take optional
	machine and domain parameters.  Redefine -c to work always, using
	token information.  Add -L, -D, -C to create unique groupnames in
	domain\group syntax.  Add -S option to define domain\group separator
	char.  Ignore -u and -s options.
	* mkpasswd.c: Revamp.  Redefine -l and -d options to take optional
	machine and domain parameters.  Redefine -c to work always, using
	token information.  Add -L, -D, -C to create unique usernames in
	domain\user syntax.  Add -S option to define domain\user separator
	char.  Ignore -g and -s options.  Prefer to take homedir from $HOME
	over $HOMEDRIVE/$HOMEPATH.
	* path.cc (oopts): Add "acl", "noacl", "posix=0" and "posix=1" options.
	(getmntent): Accomodate throughout.
	* ps.cc: Fix copyright dates.
	* utils.sgml: Fix text for mkgroup and mkpasswd.
@
text
@d367 2
a368 1
	      wcscpy (domname, domain_name);
@


1.39
log
@	* mkgroup.c: Use statically linked functions throughout, except for
	DsGetDcNameW.  Reformat.  Convert to use WCHAR for names throughout.
	Use defines instead of constants throughout.
	(MAX_SID_LEN): Define.
	(load_netapi): Just load DsGetDcNameW pointer.
	(psx_dir): Remove.
	(uni2ansi): Remove.
	(enum_local_users): Take server name and use in Net... call.
	(DBGSID): Define datastructure.
	(MAX_BUILTIN_SIDS): Define.
	(builtin_sid_list): Define global sid list.
	(builtin_sid_cnt): Define counter for global sid list.
	(enum_local_groups): Take server name and use in Net... and Lookup...
	calls.  Take offset argument.  Use MAX_PREFERRED_LENGTH in call to
	NetLocalGroupEnum.  Check for duplicate builtin groups.
	(enum_users): Take server name and use in Net... call.
	(usage): Change text slightly.
	(print_version): Fix copyright.
	(main): Call enum_local_groups for domains as well.
	* mkpasswd.c: Use statically linked functions throughout, except for
	DsGetDcNameW.  Reformat.  Convert to use WCHAR for names throughout.
	Use defines instead of constants throughout.
	(MAX_SID_LEN): Define.
	(load_netapi): Just load DsGetDcNameW pointer.
	(uni2ansi): Use wcstombs.
	(current_user): Replace "unused_by_nt/2000/xp" by
	just "unused".
	(enum_users): Ditto.
	(print_version): Fix copyright.
@
text
@d12 1
a16 2
#include <windows.h>
#include <io.h>
a17 1
#include <sys/cygwin.h>
d19 1
a19 2
#include <lmaccess.h>
#include <lmapibuf.h>
d21 3
a23 2
#include <lmerr.h>
#include <lmcons.h>
d25 4
d36 2
a40 12
typedef struct {
  LPWSTR DomainControllerName;
  LPWSTR DomainControllerAddress;
  ULONG  DomainControllerAddressType;
  GUID   DomainGuid;
  LPWSTR DomainName;
  LPWSTR DnsForestName;
  ULONG  Flags;
  LPWSTR DcSiteName;
  LPWSTR ClientSiteName;
} *PDOMAIN_CONTROLLER_INFOW;

d47 22
d70 1
a70 1
load_netapi ()
d78 47
d176 2
a177 18
_print_win_error(DWORD code, int line)
{
  char buf[4096];

  if (FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM
      | FORMAT_MESSAGE_IGNORE_INSERTS,
      NULL,
      code,
      MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),
      (LPTSTR) buf, sizeof (buf), NULL))
    fprintf (stderr, "mkpasswd (%d): [%lu] %s", line, code, buf);
  else
    fprintf (stderr, "mkpasswd (%d): error %lu", line, code);
}

void
current_user (int print_sids, int print_cygpath,
	      const char * passed_home_path, int id_offset, const char * disp_username)
a178 1
  char name[UNLEN + 1], *envname, *envdomain;
a180 1
  int errpos = 0;
d185 13
a197 19


  if ((!GetUserName (name, (len = sizeof (name), &len)) && (errpos = __LINE__))
      || !name[0]
      || !(envname = getenv("USERNAME"))
      || strcasecmp (envname, name)
      || (disp_username && strcasecmp(envname, disp_username))
      || (!GetComputerName (name, (len = sizeof (name), &len))
	  && (errpos = __LINE__))
      || !(envdomain = getenv("USERDOMAIN"))
      || !envdomain[0]
      || !strcasecmp (envdomain, name)
      || (!OpenProcessToken (GetCurrentProcess (), TOKEN_QUERY, &ptok)
	  && (errpos = __LINE__))
      || (!GetTokenInformation (ptok, TokenUser, &tu, sizeof tu, &len)
	  && (errpos = __LINE__))
      || (!GetTokenInformation (ptok, TokenPrimaryGroup, &tg, sizeof tg, &len)
	  && (errpos = __LINE__))
      || (!CloseHandle (ptok) && (errpos = __LINE__)))
d199 1
a199 2
      if (errpos)
	_print_win_error (GetLastError (), errpos);
d203 2
a204 7
  int uid = *GetSidSubAuthority (tu.psid, *GetSidSubAuthorityCount(tu.psid) - 1);
  int gid = *GetSidSubAuthority (tg.psid, *GetSidSubAuthorityCount(tg.psid) - 1);
  char homedir_psx[MAX_PATH] = {0}, homedir_w32[MAX_PATH] = {0};

  char *envhomedrive = getenv ("HOMEDRIVE");
  char *envhomepath = getenv ("HOMEPATH");

d207 13
a219 1
      if (envhomepath && envhomepath[0])
d228 1
a228 1
			      homedir_psx, MAX_PATH);
d235 1
a235 1
	  strlcat (homedir_psx, envname, sizeof (homedir_psx));
d241 1
a241 1
      strlcat (homedir_psx, envname, sizeof (homedir_psx));
d244 4
a247 2
  printf ("%s:unused:%u:%u:%s%s%s%s%s%s%s%s:%s:/bin/bash\n",
	  envname,
d250 3
a252 8
	  envname,
	  print_sids ? "," : "",
	  print_sids ? "U-" : "",
	  print_sids ? envdomain : "",
	  print_sids ? "\\" : "",
	  print_sids ? envname : "",
	  print_sids ? "," : "",
	  print_sids ? put_sid (tu.psid) : "",
d257 8
a264 3
enum_users (LPWSTR servername, int print_sids, int print_cygpath,
	    const char * passed_home_path, int id_offset, char *disp_username)
{
d271 18
d309 1
a309 1
	  exit (1);
d317 1
a317 1
	  exit (1);
d355 3
a357 96
	  if (print_sids)
	    {
	      if (!LookupAccountNameW (servername, buffer[i].usri3_name,
				       psid, &sid_length, domain_name,
				       &domname_len, &acc_type))
		{
	  	  print_win_error(GetLastError ());
		  fprintf(stderr, " (%ls)\n", buffer[i].usri3_name);
		  continue;
		}
	      else if (acc_type == SidTypeDomain)
		{
		  WCHAR domname[MAX_DOMAIN_NAME_LEN + UNLEN + 2];

		  wcscpy (domname, domain_name);
		  wcscat (domname, L"\\");
		  wcscat (domname, buffer[i].usri3_name);
		  sid_length = MAX_SID_LEN;
		  domname_len = sizeof (domname);
		  if (!LookupAccountNameW (servername, domname, psid,
					   &sid_length, domain_name,
					   &domname_len, &acc_type))
		    {
		      print_win_error(GetLastError ());
		      fprintf(stderr, " (%ls)\n", domname);
		      continue;
		    }
		}
	    }
	  printf ("%ls:unused:%u:%u:%ls%s%s%ls%s%ls%s%s:%s:/bin/bash\n",
	  	  buffer[i].usri3_name,
		  uid + id_offset,
		  gid + id_offset,
		  buffer[i].usri3_full_name ?: L"",
		  print_sids && buffer[i].usri3_full_name 
		  && buffer[i].usri3_full_name[0] ? "," : "",
		  print_sids ? "U-" : "",
		  print_sids ? domain_name : L"",
		  print_sids && domain_name[0] ? "\\" : "",
		  print_sids ? buffer[i].usri3_full_name : L"",
		  print_sids ? "," : "",
		  print_sids ? put_sid (psid) : "",
		  homedir_psx);
	}

      NetApiBufferFree (buffer);

    }
  while (rc == ERROR_MORE_DATA);

  return 0;
}

int
enum_local_groups (int print_sids)
{
  LOCALGROUP_INFO_0 *buffer;
  DWORD entriesread = 0;
  DWORD totalentries = 0;
  DWORD resume_handle = 0;
  DWORD rc ;

  do
    {
      DWORD i;

      rc = NetLocalGroupEnum (NULL, 0, (void *) &buffer, 1024,
			      &entriesread, &totalentries, &resume_handle);
      switch (rc)
	{
	case ERROR_ACCESS_DENIED:
	  print_win_error(rc);
	  exit (1);

	case ERROR_MORE_DATA:
	case ERROR_SUCCESS:
	  break;

	default:
	  print_win_error(rc);
	  exit (1);
	}

      for (i = 0; i < entriesread; i++)
	{
	  WCHAR domain_name[MAX_DOMAIN_NAME_LEN + 1];
	  DWORD domname_len = MAX_DOMAIN_NAME_LEN + 1;
	  char psid_buffer[MAX_SID_LEN];
	  PSID psid = (PSID) psid_buffer;
	  DWORD sid_length = MAX_SID_LEN;
	  DWORD gid;
	  SID_NAME_USE acc_type;

	  if (!LookupAccountNameW (NULL, buffer[i].lgrpi0_name, psid,
				   &sid_length, domain_name, &domname_len,
				   &acc_type))
d360 1
a360 1
	      fprintf(stderr, " (%ls)\n", buffer[i].lgrpi0_name);
d365 1
a365 1
	      WCHAR domname[MAX_DOMAIN_NAME_LEN + GNLEN + 2];
d369 1
a369 1
	      wcscat (domname, buffer[i].lgrpi0_name);
d371 4
a374 3
	      domname_len = MAX_DOMAIN_NAME_LEN + 1;
	      if (!LookupAccountNameW (NULL, domname, psid, &sid_length,
				       domain_name, &domname_len, &acc_type))
d382 13
a394 5
	  gid = *GetSidSubAuthority (psid, *GetSidSubAuthorityCount(psid) - 1);

	  printf ("%ls:*:%ld:%ld:%s%s::\n", buffer[i].lgrpi0_name, gid, gid,
		  print_sids ? "," : "",
		  print_sids ? put_sid (psid) : "");
d406 1
a406 2
print_special (int print_sids,
	       PSID_IDENTIFIER_AUTHORITY auth, BYTE cnt,
d439 1
a439 1
	  printf ("%s:*:%lu:%lu:%s%s::\n",
d441 1
a441 2
		  print_sids ? "," : "",
		  print_sids ? put_sid (sid) : "");
d448 1
a448 1
usage (FILE * stream, int isNT)
d450 30
a479 21
  fprintf (stream, "Usage: mkpasswd [OPTION]... [domain]...\n"
	           "Print /etc/passwd file to stdout\n\n"
	           "Options:\n");
  if (isNT)
    fprintf (stream, "   -l,--local              print local user accounts\n"
	             "   -c,--current            print current account, if a domain account\n"
                     "   -d,--domain             print domain accounts (from current domain\n"
                     "                           if no domains specified)\n"
                     "   -o,--id-offset offset   change the default offset (10000) added to uids\n"
                     "                           in domain accounts.\n"
                     "   -g,--local-groups       print local group information too\n"
                     "                           if no domain specified\n"
                     "   -m,--no-mount           don't use mount points for home dir\n"
                     "   -s,--no-sids            don't print SIDs in GCOS field\n"
	             "                           (this affects ntsec)\n");
  fprintf (stream, "   -p,--path-to-home path  use specified path and not user account home dir or /home\n"
                   "   -u,--username username  only return information for the specified user\n"
                   "   -h,--help               displays this message\n"
	           "   -v,--version            version information and exit\n\n");
  if (isNT)
    fprintf (stream, "One of '-l', '-d' or '-g' must be given.\n");
a483 1
  {"local", no_argument, NULL, 'l'},
d485 3
a487 2
  {"domain", no_argument, NULL, 'd'},
  {"id-offset", required_argument, NULL, 'o'},
d489 3
d493 2
d496 1
a496 1
  {"path-to-home", required_argument, NULL, 'p'},
a497 1
  {"help", no_argument, NULL, 'h'},
d502 1
a502 1
char opts[] = "lcdo:gsmhp:u:v";
d527 35
a564 3
  LPWSTR servername = NULL;
  DWORD rc = ERROR_SUCCESS;
  WCHAR domain_name[MAX_DOMAIN_NAME_LEN + 1];
d566 1
a566 1
  int print_current = 0;
d568 2
a569 3
  int print_local_groups = 0;
  int domain_specified = 0;
  int print_sids = 1;
d571 2
d574 1
a574 2
  int i;
  int isNT;
d576 2
a577 2
  char name[256], passed_home_path[MAX_PATH];
  DWORD len;
a578 1
  isNT = (GetVersion () < 0x80000000);
d583 62
a644 6
  if (isNT && argc == 1)
    return usage (stderr, isNT);
  else
    {
      while ((i = getopt_long (argc, argv, opts, longopts, NULL)) != EOF)
	switch (i)
d646 2
a647 43
	  case 'l':
	    print_local = 1;
	    break;
	  case 'c':
	    print_current = 1;
	    break;
	  case 'd':
	    print_domain = 1;
	    break;
	  case 'o':
	    id_offset = strtol (optarg, NULL, 10);
	    break;
	  case 'g':
	    print_local_groups = 1;
	    break;
	  case 's':
	    print_sids = 0;
	    break;
	  case 'm':
	    print_cygpath = 0;
	    break;
	  case 'p':
	    if (optarg[0] != '/')
	    {
	      fprintf (stderr, "%s: '%s' is not a fully qualified path.\n",
		       argv[0], optarg);
	      return 1;
	    }
	    strcpy (passed_home_path, optarg);
	    if (optarg[strlen (optarg)-1] != '/')
	      strcat (passed_home_path, "/");
	    break;
	  case 'u':
	    disp_username = optarg;
	    break;
	  case 'h':
	    usage (stdout, isNT);
	    return 0;
	  case 'v':
	    print_version ();
	    return 0;
	  default:
	    fprintf (stderr, "Try '%s --help' for more information.\n", argv[0]);
d650 23
a672 14
    }
  if (!isNT)
    {
      /* This takes Windows 9x/ME into account. */
      if (passed_home_path[0] == '\0')
	strcpy (passed_home_path, "/home/");
      if (!disp_username)
        {
	  printf ("admin:use_crypt:%lu:%lu:Administrator:%sadmin:/bin/bash\n", 
		  DOMAIN_USER_RID_ADMIN,
		  DOMAIN_ALIAS_RID_ADMINS,
		  passed_home_path);
	  if (GetUserName (name, (len = 256, &len)))
	    disp_username = name;
d674 23
a696 20
      if (disp_username && disp_username[0])
        {
	  /* Create a pseudo random uid */
	  unsigned long uid = 0, i;
	  for (i = 0; disp_username[i]; i++)
	    uid += toupper (disp_username[i]) << ((6 * i) % 25);
	  uid = (uid % (1000 - DOMAIN_USER_RID_ADMIN - 1)) 
	    + DOMAIN_USER_RID_ADMIN + 1;
    	  
	  printf ("%s:use_crypt:%lu:%lu:%s:%s%s:/bin/bash\n", 
		  disp_username,
		  uid,
		  DOMAIN_ALIAS_RID_ADMINS,
		  disp_username,
		  passed_home_path,
		  disp_username);
	}
      return 0;
    }
  if (!print_local && !print_domain && !print_local_groups)
d698 8
a705 10
      fprintf (stderr, "%s: Specify one of '-l', '-d' or '-g'\n", argv[0]);
      return 1;
    }
  if (optind < argc)
    {
      if (!print_domain)
        {
	  fprintf (stderr, "%s: A domain name is only accepted "
		   "when '-d' is given.\n", argv[0]);
	  return 1;
a706 1
      domain_specified = 1;
a707 28
  load_netapi ();

  if (disp_username == NULL)
    {
      if (print_local)
        {
	  /* Generate service starter account entries. */
	  printf ("SYSTEM:*:18:544:,S-1-5-18::\n");
	  printf ("LocalService:*:19:544:U-NT AUTHORITY\\LocalService,S-1-5-19::\n");
	  printf ("NetworkService:*:20:544:U-NT AUTHORITY\\NetworkService,S-1-5-20::\n");
	  /* Get 'administrators' group (has localized name). */
	  if (!print_local_groups)
	    print_special (print_sids, &sid_nt_auth, 2, SECURITY_BUILTIN_DOMAIN_RID,
			   DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0);
	}
      if (print_local_groups)
	enum_local_groups (print_sids);
    }

  if (print_local)
    enum_users (NULL, print_sids, print_cygpath, passed_home_path, 0,
    		disp_username);

  i = 1;
  if (print_domain) 
    do 
      {
	PDOMAIN_CONTROLLER_INFOW pdci = NULL;
d709 3
a711 37
	if (dsgetdcname)
	  {
	    if (domain_specified)
	      {
		mbstowcs (domain_name, argv[optind], strlen (argv[optind]) + 1);
		rc = dsgetdcname (NULL, domain_name, NULL, NULL, 0, &pdci);
	      }
	    else
	      rc = dsgetdcname (NULL, NULL, NULL, NULL, 0, &pdci);
	    if (rc != ERROR_SUCCESS)
	      {
		print_win_error(rc);
		return 1;
	      }
	    servername = pdci->DomainControllerName;
	  }
	else
	  {
	    rc = NetGetDCName (NULL, NULL, (void *) &servername);
	    if (rc == ERROR_SUCCESS && domain_specified)
	      {
		LPWSTR server = servername;
		mbstowcs (domain_name, argv[optind], strlen (argv[optind]) + 1);
		rc = NetGetDCName (server, domain_name, (void *) &servername);
		NetApiBufferFree (server);
	      }
	    if (rc != ERROR_SUCCESS)
	      {
		print_win_error(rc);
		return 1;
	      }
          }
	enum_users (servername, print_sids, print_cygpath, passed_home_path,
		    id_offset * i++, disp_username);
	NetApiBufferFree (pdci ? (PVOID) pdci : (PVOID) servername);
      }
    while (++optind < argc);
d713 2
a714 3
  if (print_current && !print_domain)
    current_user(print_sids, print_cygpath, passed_home_path,
		 id_offset, disp_username);
@


1.38
log
@	* cygpath.cc (do_sysfolders): Use cygwin_conv_path.
	(do_pathconv): Use cygwin_conv_path and cygwin_conv_path_list.
	* dumper.cc (main): Use cygwin_conv_path.  Allocate target path
	dynamically.
	* mkpasswd.c (current_user): Use cygwin_conv_path.
	(enum_users): Ditto.
	* ps.cc (NT_MAX_PATH): Define.
	(main): Use cygwin_conv_path.
	* regtool.cc (find_key): Ditto. Allocate target path dynamically.
	(cmd_save): Ditto.
@
text
@d3 2
a4 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
d26 1
d30 2
a48 5
NET_API_STATUS WINAPI (*netapibufferfree)(PVOID);
NET_API_STATUS WINAPI (*netuserenum)(LPWSTR,DWORD,DWORD,PBYTE*,DWORD,PDWORD,PDWORD,PDWORD);
NET_API_STATUS WINAPI (*netlocalgroupenum)(LPWSTR,DWORD,PBYTE*,DWORD,PDWORD,PDWORD,PDWORD);
NET_API_STATUS WINAPI (*netgetdcname)(LPWSTR,LPWSTR,PBYTE*);
NET_API_STATUS WINAPI (*netusergetinfo)(LPWSTR,LPWSTR,DWORD,PBYTE*);
d55 1
a55 1
BOOL
d60 2
a61 17
  if (!h)
    return FALSE;

  if (!(netapibufferfree = (void *) GetProcAddress (h, "NetApiBufferFree")))
    return FALSE;
  if (!(netuserenum = (void *) GetProcAddress (h, "NetUserEnum")))
    return FALSE;
  if (!(netlocalgroupenum = (void *) GetProcAddress (h, "NetLocalGroupEnum")))
    return FALSE;
  if (!(netgetdcname = (void *) GetProcAddress (h, "NetGetDCName")))
    return FALSE;
  if (!(netusergetinfo = (void *) GetProcAddress (h, "NetUserGetInfo")))
    return FALSE;

  dsgetdcname = (void *) GetProcAddress (h, "DsGetDcNameW");

  return TRUE;
d109 1
a109 1
    WideCharToMultiByte (CP_ACP, 0, wcs, -1, mbs, size, NULL, NULL);
d201 1
a201 1
  printf ("%s:unused_by_nt/2000/xp:%u:%u:%s%s%s%s%s%s%s%s:%s:/bin/bash\n",
d225 1
a225 5
  char ansi_srvname[256];
  WCHAR uni_name[512];

  if (servername)
    uni2ansi (servername, ansi_srvname, sizeof (ansi_srvname));
d231 11
a241 11
    if (disp_username != NULL)
      {
	MultiByteToWideChar (CP_ACP, 0, disp_username, -1, uni_name, 512 );
	rc = netusergetinfo(servername, (LPWSTR) & uni_name, 3,
			    (void *) &buffer );
	entriesread=1;
      }
    else 
      rc = netuserenum (servername, 3, FILTER_NORMAL_ACCOUNT,
			(void *) &buffer, 1024,
			&entriesread, &totalentries, &resume_handle);
d259 1
a259 3
	  char username[100];
	  char fullname[100];
	  char homedir_psx[MAX_PATH];
d261 3
a263 3
	  char domain_name[100];
	  DWORD domname_len = 100;
	  char psid_buffer[1024];
d265 1
a265 1
	  DWORD sid_length = 1024;
a269 2
	  uni2ansi (buffer[i].usri3_name, username, sizeof (username));
	  uni2ansi (buffer[i].usri3_full_name, fullname, sizeof (fullname));
d279 1
a279 1
				      homedir_w32, homedir_psx, MAX_PATH);
d284 2
a285 4
		{
		  strcpy (homedir_psx, "/home/");
		  strcat (homedir_psx, username);
		}
d288 3
a290 4
	    {
	      strcpy (homedir_psx, passed_home_path);
	      strcat (homedir_psx, username);
	    }
d294 3
a296 5
	      if (!LookupAccountName (servername ? ansi_srvname : NULL,
				      username,
				      psid, &sid_length,
				      domain_name, &domname_len,
				      &acc_type))
d299 1
a299 1
		  fprintf(stderr, " (%s)\n", username);
d304 1
a304 1
		  char domname[356];
d306 8
a313 10
		  strcpy (domname, domain_name);
		  strcat (domname, "\\");
		  strcat (domname, username);
		  sid_length = 1024;
		  domname_len = 100;
		  if (!LookupAccountName (servername ? ansi_srvname : NULL,
					  domname,
					  psid, &sid_length,
					  domain_name, &domname_len,
					  &acc_type))
d316 1
a316 1
		      fprintf(stderr, " (%s)\n", domname);
d321 2
a322 2
	  printf ("%s:unused_by_nt/2000/xp:%u:%u:%s%s%s%s%s%s%s%s:%s:/bin/bash\n",
	  	  username,
d325 3
a327 2
		  fullname,
		  print_sids && fullname[0] ? "," : "",
d329 1
a329 1
		  print_sids ? domain_name : "",
d331 1
a331 1
		  print_sids ? username : "",
d337 1
a337 1
      netapibufferfree (buffer);
d358 1
a358 1
      rc = netlocalgroupenum (NULL, 0, (void *) &buffer, 1024,
d377 3
a379 4
	  char localgroup_name[100];
	  char domain_name[100];
	  DWORD domname_len = 100;
	  char psid_buffer[1024];
d381 1
a381 1
	  DWORD sid_length = 1024;
a383 1
	  uni2ansi (buffer[i].lgrpi0_name, localgroup_name, sizeof (localgroup_name));
d385 3
a387 3
	  if (!LookupAccountName (NULL, localgroup_name, psid,
				  &sid_length, domain_name, &domname_len,
				  &acc_type))
d390 1
a390 1
	      fprintf(stderr, " (%s)\n", localgroup_name);
d395 1
a395 1
	      char domname[356];
d397 7
a403 9
	      strcpy (domname, domain_name);
	      strcat (domname, "\\");
	      strcat (domname, localgroup_name);
	      sid_length = 1024;
	      domname_len = 100;
	      if (!LookupAccountName (NULL, domname,
				      psid, &sid_length,
				      domain_name, &domname_len,
				      &acc_type))
d406 1
a406 1
		  fprintf(stderr, " (%s)\n", domname);
d413 1
a413 1
	  printf ("%s:*:%ld:%ld:%s%s::\n", localgroup_name, gid, gid,
d418 1
a418 1
      netapibufferfree (buffer);
d432 1
a432 1
  char name[256], dom[256];
d441 2
a442 2
			    name, (len = 256, &len),
			    dom, (len2 = 256, &len),
d532 1
a532 1
Copyright 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.\n\
d542 1
a542 1
  WCHAR domain_name[200];
d663 1
a663 5
  if (!load_netapi ())
    {
      print_win_error(GetLastError ());
      return 1;
    }
d710 1
a710 1
	    rc = netgetdcname (NULL, NULL, (void *) &servername);
d715 2
a716 2
		rc = netgetdcname (server, domain_name, (void *) &servername);
		netapibufferfree (server);
d726 1
a726 1
	netapibufferfree (pdci ? (PVOID) pdci : (PVOID) servername);
@


1.37
log
@	* mkpasswd.c (main): Simplify generating SYSTEM entry.  Add entries
	for LocalService and NetworkService accounts.  Change comments.
@
text
@d200 2
a201 1
	    cygwin_conv_to_posix_path (homedir_w32, homedir_psx);
d302 2
a303 1
		    cygwin_conv_to_posix_path (homedir_w32, homedir_psx);
@


1.36
log
@bad_keywords
@
text
@d705 5
a709 15
#if 0
	  /*
	   * Get 'Everyone' group
	   */
	  print_special (print_sids, &sid_world_auth, 1, SECURITY_WORLD_RID,
			 0, 0, 0, 0, 0, 0, 0);
#endif
	  /*
	   * Get 'system' group
	   */
	  print_special (print_sids, &sid_nt_auth, 1, SECURITY_LOCAL_SYSTEM_RID,
			 0, 0, 0, 0, 0, 0, 0);
	  /*
	   * Get 'administrators' group
	   */
@


1.36.6.1
log
@	* mkpasswd.c (main): Simplify generating SYSTEM entry.  Add entries
	for LocalService and NetworkService accounts.  Change comments.
@
text
@d705 15
a719 5
	  /* Generate service starter account entries. */
	  printf ("SYSTEM:*:18:544:,S-1-5-18::\n");
	  printf ("LocalService:*:19:544:U-NT AUTHORITY\\LocalService,S-1-5-19::\n");
	  printf ("NetworkService:*:20:544:U-NT AUTHORITY\\NetworkService,S-1-5-20::\n");
	  /* Get 'administrators' group (has localized name). */
@


1.35
log
@	Align error message handling to mkpasswd's error messages throughout.
	* mkgroup.c (print_win_error): Create macro calling ...
	(_print_win_error): ... this function created from former
	print_win_error.  Move up in source.
	(PDOMAIN_CONTROLLER_INFOW): Define return type of DcGetDcNameW.
	(dsgetdcname): New function pointer for DcGetDcNameW.
	(load_netapi): Get DcGetDcNameW address.
	(main): If DcGetDcNameW is available, use it.
	* mkpasswd.c (PDOMAIN_CONTROLLER_INFOW): Define return type of
	DcGetDcNameW.
	(dsgetdcname): New function pointer for DcGetDcNameW.
	(load_netapi): Get DcGetDcNameW address.
	(main): If DcGetDcNameW is available, use it.  Rename local variable
	domain_name_specified to domain_specified as in mkgroup.c.
@
text
@d525 1
a525 1
    fprintf (stream, "One of `-l', `-d' or `-g' must be given.\n");
d625 1
a625 1
	      fprintf (stderr, "%s: `%s' is not a fully qualified path.\n",
d643 1
a643 1
	    fprintf (stderr, "Try `%s --help' for more information.\n", argv[0]);
d682 1
a682 1
      fprintf (stderr, "%s: Specify one of `-l', `-d' or `-g'\n", argv[0]);
d690 1
a690 1
		   "when `-d' is given.\n", argv[0]);
d707 1
a707 1
	   * Get `Everyone' group
d713 1
a713 1
	   * Get `system' group
d718 1
a718 1
	   * Get `administrators' group
@


1.34
log
@2005-01-11  Pierre Humblet <pierre.humblet@@ieee.org>

        * mkpasswd.c (print_win_error): Transform into macro.
        (_print_win_error): Upgrade former print_win_error by
        printing the line.
        (current_user): Call _print_win_error.
        (enum_users): Print name in case of lookup failure.
        (enum_local_groups): Ditto.
@
text
@d33 12
d50 1
d75 2
d579 1
a579 1
  int domain_name_specified = 0;
d693 1
a693 1
      domain_name_specified = 1;
d736 3
a738 1
	if (domain_name_specified)
d740 13
a752 2
	    mbstowcs (domain_name, argv[optind], (strlen (argv[optind]) + 1));
	    rc = netgetdcname (NULL, domain_name, (void *) &servername);
a754 3
	  rc = netgetdcname (NULL, NULL, (void *) &servername);
	
	if (rc != ERROR_SUCCESS)
d756 14
a769 4
	    print_win_error(rc);
	    return 1;
	  }

d772 1
a772 1
	netapibufferfree (servername);
@


1.33
log
@	* mkgroup.c: Avoid compiler warnings throughout.
	* mkpasswd.c: Ditto.
	* passwd.c: Ditto.
@
text
@d26 2
d116 1
a116 1
print_win_error(DWORD code)
d126 1
a126 1
    fprintf (stderr, "mkpasswd: [%lu] %s", code, buf);
d128 1
a128 1
    fprintf (stderr, "mkpasswd: error %lu", code);
d164 1
a164 4
	{
	  print_win_error (GetLastError ());
	  fprintf(stderr, " on line %d\n", errpos);
	}
d311 1
d330 1
d405 1
d423 1
@


1.32
log
@* mkpasswd.c (usage) Remove extra newline from description output.
@
text
@d240 1
a240 1
			    (LPBYTE *) &buffer );
d245 1
a245 1
			(LPBYTE *) & buffer, 1024,
d370 1
a370 1
      rc = netlocalgroupenum (NULL, 0, (LPBYTE *) & buffer, 1024,
d721 1
a721 1
	    rc = netgetdcname (NULL, domain_name, (LPBYTE *) & servername);
d724 1
a724 1
	  rc = netgetdcname (NULL, NULL, (LPBYTE *) & servername);
@


1.31
log
@* cygcheck.cc (usage) Add description output.
@
text
@d487 1
a487 1
  fprintf (stream, "Usage: mkpasswd [OPTION]... [domain]...\n\n"
@


1.30
log
@
2003-04-10  Pierre Humblet  <pierre.humblet@@ieee.org>

        * mkpasswd.c (current_user): print uid and gid as unsigned.
        (enum_users): Ditto. Do not free servername.
        (usage): Update to allow several domains and improve -p.
        (main): On Win9x limit uids to 1000. Only print specials
        when -l is specified. Add a loop to allow several domains
        and free servername in the loop.
        * mkgroup.c (enum_groups): Do not free servername.
        (usage): Update to allow several domains. Change uid to gid.
        (main): Only print specials when -l is specified. Add a
        loop to allow several domains and free servername in the loop.
@
text
@d488 1
a488 1
	           "This program prints a /etc/passwd file to stdout\n\n"
@


1.29
log
@
2003-03-01  Pierre Humblet  <pierre.humblet@@ieee.org>

       * mkpasswd.cc (main): On Win95, output both a default line and a
       line for the current user (if known) with a pseudorandom uid. If
       the -u switch is given, produce a line for the specified user.
       * mkgroup.cc (main): On Win95 change the group name from "unknown" to
       "all".
@
text
@d202 1
a202 1
  printf ("%s:unused_by_nt/2000/xp:%d:%d:%s%s%s%s%s%s%s%s:%s:/bin/bash\n",
d334 1
a334 1
	  printf ("%s:unused_by_nt/2000/xp:%d:%d:%s%s%s%s%s%s%s%s:%s:/bin/bash\n",
a353 3
  if (servername)
    netapibufferfree (servername);

d487 1
a487 1
  fprintf (stream, "Usage: mkpasswd [OPTION]... [domain]\n\n"
d494 1
a494 1
                     "                           if no domain specified)\n"
d502 1
a502 1
  fprintf (stream, "   -p,--path-to-home path  use specified path instead of user account home dir\n"
d649 1
a649 1
	  uid = (uid % (65535 - DOMAIN_USER_RID_ADMIN - 1)) 
a674 1
      mbstowcs (domain_name, argv[optind], (strlen (argv[optind]) + 1));
d685 2
d688 5
a692 5
      /*
       * Get `Everyone' group
      */
      print_special (print_sids, &sid_world_auth, 1, SECURITY_WORLD_RID,
		     0, 0, 0, 0, 0, 0, 0);
d694 12
a705 12
      /*
       * Get `system' group
      */
      print_special (print_sids, &sid_nt_auth, 1, SECURITY_LOCAL_SYSTEM_RID,
		     0, 0, 0, 0, 0, 0, 0);
      /*
       * Get `administrators' group
      */
      if (!print_local_groups)
	print_special (print_sids, &sid_nt_auth, 2, SECURITY_BUILTIN_DOMAIN_RID,
		       DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0);

a709 18
  if (print_domain)
    {
      if (domain_name_specified)
	rc = netgetdcname (NULL, domain_name, (LPBYTE *) & servername);

      else
	rc = netgetdcname (NULL, NULL, (LPBYTE *) & servername);

      if (rc != ERROR_SUCCESS)
	{
	  print_win_error(rc);
	  return 1;
	}

      enum_users (servername, print_sids, print_cygpath, passed_home_path,
		  id_offset, disp_username);
    }

d714 24
a740 3

  if (servername)
    netapibufferfree (servername);
@


1.28
log
@	* mkgroup.c: Fix copyright date.
	* mkpasswd.c: Ditto.
	* setfacl.c: Ditto.

	Fix ChangeLog typos.
@
text
@d635 2
d639 4
a644 3
	  else
	    /* Same behaviour as in cygwin/shared.cc (memory_init). */
	    disp_username = (char *) "unknown";
d646 17
a662 10

      if (passed_home_path[0] == '\0')
	strcpy (passed_home_path, "/home/");

      printf ("%s:*:%ld:%ld:%s:%s%s:/bin/bash\n", disp_username,
					        DOMAIN_USER_RID_ADMIN,
					        DOMAIN_ALIAS_RID_ADMINS,
	                                        disp_username,
					        passed_home_path,
					        disp_username);
@


1.27
log
@	* mkpasswd.cc (current_user): Create.
	(usage): Reorganize to support Win95/98/ME.
	(main): Add option for -c. Reorganize to parse options for
	Win95/98/ME and to call current_user. Add username in gecos field
	on Win95/98/ME.
	* mkgroup.cc (enum_groups): Print gid with %u.
	(print_win_error): Create from passwd.cc.
	(current_group): Create.
	(usage): Reorganize to support Win95/98/ME.
	(main): Add option for -c. Reorganize to parse options for
	Win95/98/ME and to call current_group.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.26
log
@	* mkpasswd.c (main): Set pw_passwd field to '*' on 9x/Me.
@
text
@d24 1
d129 88
d488 1
a488 1
usage (FILE * stream, int status)
d491 15
a505 13
                   "This program prints a /etc/passwd file to stdout\n\n"
                   "Options:\n"
                   "   -l,--local              print local user accounts\n"
                   "   -d,--domain             print domain accounts (from current domain\n"
                   "                           if no domain specified)\n"
                   "   -o,--id-offset offset   change the default offset (10000) added to uids\n"
                   "                           in domain accounts.\n"
                   "   -g,--local-groups       print local group information too\n"
                   "                           if no domain specified\n"
                   "   -m,--no-mount           don't use mount points for home dir\n"
                   "   -s,--no-sids            don't print SIDs in GCOS field\n"
                   "                           (this affects ntsec)\n"
                   "   -p,--path-to-home path  use specified path instead of user account home dir\n"
d508 4
a511 3
                   "   -v,--version            version information and exit\n\n"
                   "One of `-l', `-d' or `-g' must be given on NT/W2K.\n");
  return status;
d516 1
d529 1
a529 1
char opts[] = "ldo:gsmhp:u:v";
d561 1
d569 1
a570 1

d574 1
d579 3
a581 1
  if (GetVersion () < 0x80000000)
d583 26
a608 49
      if (argc == 1)
	return usage (stderr, 1);
      else
	{
	  while ((i = getopt_long (argc, argv, opts, longopts, NULL)) != EOF)
	    switch (i)
	      {
	      case 'l':
		print_local = 1;
		break;
	      case 'd':
		print_domain = 1;
		break;
	      case 'o':
		id_offset = strtol (optarg, NULL, 10);
		break;
	      case 'g':
		print_local_groups = 1;
		break;
	      case 's':
		print_sids = 0;
		break;
	      case 'm':
		print_cygpath = 0;
		break;
	      case 'p':
		if (optarg[0] != '/')
		  {
		    fprintf (stderr, "%s: `%s' is not a fully qualified path.\n",
			     argv[0], optarg);
		    return 1;
		  }
		strcpy (passed_home_path, optarg);
		if (optarg[strlen (optarg)-1] != '/')
		  strcat (passed_home_path, "/");
		break;
	      case 'u':
		disp_username = optarg;
		break;
	      case 'h':
		return usage (stdout, 0);
	      case 'v':
               print_version ();
		return 0;
	      default:
		fprintf (stderr, "Try `%s --help' for more information.\n", argv[0]);
		return 1;
	      }
	  if (!print_local && !print_domain && !print_local_groups)
d610 2
a611 1
	      fprintf (stderr, "%s: Specify one of `-l', `-d' or `-g'\n", argv[0]);
d614 28
a641 11
	  if (optind < argc)
	    {
	      if (!print_domain)
		{
		  fprintf (stderr, "%s: A domain name is only accepted "
				   "when `-d' is given.\n", argv[0]);
		  return 1;
		}
	      mbstowcs (domain_name, argv[optind], (strlen (argv[optind]) + 1));
	      domain_name_specified = 1;
	    }
a642 8
    }

  /* This takes Windows 9x/ME into account. */
  if (GetVersion () >= 0x80000000)
    {
      /* Same behaviour as in cygwin/uinfo.cc (internal_getlogin). */
      if (!GetUserName (name, (len = 256, &len)))
	strcpy (name, "unknown");
d647 1
a647 1
      printf ("%s:*:%ld:%ld::%s%s:/bin/bash\n", name,
d650 1
d652 1
a652 2
					        name);

d655 16
a670 1

d723 4
@


1.25
log
@* cygpath.cc (close_arg): Remove unused static.
* mkgroup.c (enum_local_users): Avoid compiler warning.
(enum_users): Ditto.
* mkpasswd.c: Ditto throughout.
* ssp.c: Ditto throughout.
@
text
@d563 5
a567 5
      printf ("%s::%ld:%ld::%s%s:/bin/bash\n", name,
					     DOMAIN_USER_RID_ADMIN,
					     DOMAIN_ALIAS_RID_ADMINS,
					     passed_home_path,
					     name);
@


1.24
log
@Add final newlines to utils
@
text
@d17 1
@


1.23
log
@	* mkgroup.c (main): Don't print an entry for "Everyone".
	* mkpasswd.c (print_special): Set pw_gid to 544 for SYSTEM user.
	(main): Don't print an entry for "Everyone".
@
text
@d456 2
a457 1
Compiled on %s", len, v, __DATE__);
@


1.22
log
@* mkpasswd.cc (main): Don't reset to binmode if stdout is a terminal.
@
text
@d389 1
a389 1
		  name, rid, rid,
a575 3
  /*
   * Get `Everyone' group
  */
d578 4
d584 1
@


1.21
log
@	* mkgroup.c (main): Change call to exit() to a return statement.
	* mkpasswd.c (main): Ditto.

	* mkpasswd.c (usage): Simplify usage output.  Generalize to allow use
	for help. Correct '?' typo to 'h'.
	(longopts): Add version option.
	(opts): Add 'v' version option.
	(print_version): New function.
	(main): Accommodate new version option.  Accommodate usage parameter
	changes.
@
text
@d479 2
a480 1
  setmode (1, O_BINARY);
@


1.20
log
@	* mkpasswd.c (main): Set default home path for 9x/Me if --path-to-home
	isn't given.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 1999, 2000, 2001 Red Hat, Inc.
d24 2
d398 1
a398 1
usage ()
d400 19
a418 18
  fprintf (stderr, "Usage: mkpasswd [OPTION]... [domain]\n\n");
  fprintf (stderr, "This program prints a /etc/passwd file to stdout\n\n");
  fprintf (stderr, "Options:\n");
  fprintf (stderr, "   -l,--local              print local user accounts\n");
  fprintf (stderr, "   -d,--domain             print domain accounts (from current domain\n");
  fprintf (stderr, "                           if no domain specified)\n");
  fprintf (stderr, "   -o,--id-offset offset   change the default offset (10000) added to uids\n");
  fprintf (stderr, "                           in domain accounts.\n");
  fprintf (stderr, "   -g,--local-groups       print local group information too\n");
  fprintf (stderr, "                           if no domain specified\n");
  fprintf (stderr, "   -m,--no-mount           don't use mount points for home dir\n");
  fprintf (stderr, "   -s,--no-sids            don't print SIDs in GCOS field\n");
  fprintf (stderr, "                           (this affects ntsec)\n");
  fprintf (stderr, "   -p,--path-to-home path  use specified path instead of user account home dir\n");
  fprintf (stderr, "   -u,--username username  only return information for the specified user\n");
  fprintf (stderr, "   -?,--help               displays this message\n\n");
  fprintf (stderr, "One of `-l', `-d' or `-g' must be given on NT/W2K.\n");
  return 1;
d431 1
d435 23
a457 1
char opts[] = "ldo:gsmhp:u:";
d484 1
a484 1
	return usage ();
d523 4
a526 1
		return usage ();
d609 1
a609 1
	  exit (1);
@


1.19
log
@	* mkpasswd.c (print_win_error): Add a new function.
	(enum_users): Use print_win_error.
	(enum_local_groups): Ditto.
	(main): Ditto.
@
text
@d528 3
@


1.18
log
@	* mkpasswd.c (enum_users): Change to unconditionally use
	the --path-to-home option, if supplied by the user.  Use default
	--path-to-home option value, if appropriate.
	(usage): Change usage statement to reflect new semantics.
	(main): Remove defaulting of the --path-to-home option.
@
text
@d109 16
d158 1
a158 1
	  fprintf (stderr, "Access denied\n");
d166 1
a166 3
	  fprintf (stderr, "NetUserEnum() failed with error %ld.\n", rc);
	  if (rc == NERR_UserNotFound) 
	    fprintf (stderr, "That user doesn't exist.\n");
d219 1
a219 5
		  fprintf (stderr,
			   "LookupAccountName(%s,%s) failed with error %ld\n",
			   servername ? ansi_srvname : "NULL",
			   username,
			   GetLastError ());
d237 1
a237 5
		      fprintf (stderr,
			       "LookupAccountName(%s,%s) failed with error %ld\n",
			       servername ? ansi_srvname : "NULL",
			       domname,
			       GetLastError ());
d286 1
a286 1
	  fprintf (stderr, "Access denied\n");
d294 1
a294 1
	  fprintf (stderr, "NetLocalGroupEnum() failed with %ld\n", rc);
d314 1
a314 2
	      fprintf (stderr, "LookupAccountName(%s) failed with %ld\n",
		       localgroup_name, GetLastError ());
d331 1
a331 3
		  fprintf (stderr,
			   "LookupAccountName(%s) failed with error %ld\n",
			   localgroup_name, GetLastError ());
d539 1
a539 2
      fprintf (stderr, "Failed loading symbols from netapi32.dll "
		       "with error %lu\n", GetLastError ());
d576 1
a576 1
	  fprintf (stderr, "Cannot get DC, code = %ld\n", rc);
@


1.17
log
@* mkpasswd.c (opts): Add indication that '-p' option requires an argument.
@
text
@d174 17
a190 3
	  uni2ansi (buffer[i].usri3_home_dir, homedir_w32, sizeof (homedir_w32));
	  if (print_cygpath)
	    cygwin_conv_to_posix_path (homedir_w32, homedir_psx);
a191 3
	    psx_dir (homedir_w32, homedir_psx);

	  if (homedir_psx[0] == '\0')
d193 1
a193 1
	      strcat (homedir_psx, passed_home_path);
d408 1
a408 2
  fprintf (stderr, "   -p,--path-to-home path  if user account has no home dir, use\n");
  fprintf (stderr, "                           path instead of /home/\n");
a516 3

  if (passed_home_path[0] == '\0')
      strcpy (passed_home_path, "/home/");
@


1.16
log
@	Patch by Mark Bradshaw <bradshaw@@staff.crosswalk.com>:
	* mkpasswd.c: include lmerr.h
	(main): New -u option to allow specifying a
	specific user.  If specified, groups aren't displayed and
	output is limited to only the specified user.
	(enum_users): If specific user is specified, via -u option,
	display only that user's record.  With -u use NetUserGetInfo
	instead of NetUserEnum.
	(load_netapi): Added netusergetinfo.
@
text
@d418 1
a418 1
char opts[] = "ldo:gsmhpu:";
@


1.15
log
@Change copyright.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 1999, 2000 Red Hat, Inc.
d22 1
d31 1
d53 2
d111 1
a111 1
	    const char * passed_home_path, int id_offset)
d119 1
d128 8
d150 3
a152 1
	  fprintf (stderr, "NetUserEnum() failed with %ld\n", rc);
d399 1
d412 2
a413 1
  {"path-to-home",required_argument, NULL, 'p'},
d418 1
a418 1
char opts[] = "ldo:gsmhp:";
d434 1
d480 3
d537 15
a551 10
  print_special (print_sids, &sid_world_auth, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0);
  /*
   * Get `system' group
  */
  print_special (print_sids, &sid_nt_auth, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0);
  /*
   * Get `administrators' group
  */
  if (!print_local_groups)
    print_special (print_sids, &sid_nt_auth, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0);
d553 3
a555 2
  if (print_local_groups)
    enum_local_groups (print_sids);
d571 2
a572 1
      enum_users (servername, print_sids, print_cygpath, passed_home_path, id_offset);
d576 2
a577 1
    enum_users (NULL, print_sids, print_cygpath, passed_home_path, 0);
@


1.14
log
@        * mkgroup.c: Avoid compiler warnings.
        (print_special): New function.
        (main): Print special accounts by calling print_special().
        * mkpasswd.c: Avoid compiler warnings.
        (enum_users): Print additional U-domain\username info in gecos
        field when SIDs are printed.
        (print_special): New function.
        (main): Print special accounts by calling print_special().
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 1999, 2000 Cygnus Solutions.
@


1.13
log
@* mkpasswd.cc (enum_users): Shorten "unused" passwd field.
@
text
@d16 1
d43 1
a43 1
  if (!(netapibufferfree = GetProcAddress (h, "NetApiBufferFree")))
d45 1
a45 1
  if (!(netuserenum = GetProcAddress (h, "NetUserEnum")))
d47 1
a47 1
  if (!(netlocalgroupenum = GetProcAddress (h, "NetLocalGroupEnum")))
d49 1
a49 1
  if (!(netgetdcname = GetProcAddress (h, "NetGetDCName")))
d210 2
a211 1
	  printf ("%s:unused_by_nt/2000/xp:%d:%d:%s%s%s:%s:/bin/bash\n", username,
d215 5
d322 44
d418 2
a419 4
  char name[256], dom[256], passed_home_path[MAX_PATH];
  DWORD len, len2;
  PSID sid;
  SID_NAME_USE use;
d425 44
a468 6
    if (argc == 1)
      return usage ();
    else
      {
	while ((i = getopt_long (argc, argv, opts, longopts, NULL)) != EOF)
	  switch (i)
d470 1
a470 33
	    case 'l':
	      print_local = 1;
	      break;
	    case 'd':
	      print_domain = 1;
	      break;
	    case 'o':
	      id_offset = strtol (optarg, NULL, 10);
	      break;
	    case 'g':
	      print_local_groups = 1;
	      break;
	    case 's':
	      print_sids = 0;
	      break;
	    case 'm':
	      print_cygpath = 0;
	      break;
            case 'p':
              if (optarg[0] != '/')
	        {
                  fprintf (stderr, "%s: `%s' is not a fully qualified path.\n",
                           argv[0], optarg);
                  return 1;
                }
              strcpy (passed_home_path, optarg);
              if (optarg[strlen (optarg)-1] != '/')
                strcat (passed_home_path, "/");
              break;
	    case 'h':
	      return usage ();
	    default:
	      fprintf (stderr, "Try `%s --help' for more information.\n", argv[0]);
d473 13
a485 17
	if (!print_local && !print_domain && !print_local_groups)
	  {
	    fprintf (stderr, "%s: Specify one of `-l', `-d' or `-g'\n", argv[0]);
	    return 1;
	  }
	if (optind < argc)
	  {
	    if (!print_domain)
	      {
		fprintf (stderr, "%s: A domain name is only accepted "
				 "when `-d' is given.\n", argv[0]);
		return 1;
	      }
	    mbstowcs (domain_name, argv[optind], (strlen (argv[optind]) + 1));
	    domain_name_specified = 1;
	  }
      }
d516 1
a516 15
  if (AllocateAndInitializeSid (&sid_world_auth, 1, SECURITY_WORLD_RID,
				0, 0, 0, 0, 0, 0, 0, &sid))
    {
      if (LookupAccountSid (NULL, sid,
			    name, (len = 256, &len),
			    dom, (len2 = 256, &len),
			    &use))
	printf ("%s:*:%d:%d:%s%s::\n", name,
					 SECURITY_WORLD_RID,
					 SECURITY_WORLD_RID,
					 print_sids ? "," : "",
					 print_sids ? put_sid (sid) : "");
      FreeSid (sid);
    }

d520 1
a520 15
  if (AllocateAndInitializeSid (&sid_nt_auth, 1, SECURITY_LOCAL_SYSTEM_RID,
				0, 0, 0, 0, 0, 0, 0, &sid))
    {
      if (LookupAccountSid (NULL, sid,
			    name, (len = 256, &len),
			    dom, (len2 = 256, &len),
			    &use))
	printf ("%s:*:%d:%d:%s%s::\n", name,
					 SECURITY_LOCAL_SYSTEM_RID,
					 SECURITY_LOCAL_SYSTEM_RID,
					 print_sids ? "," : "",
					 print_sids ? put_sid (sid) : "");
      FreeSid (sid);
    }

d524 2
a525 17
  if (!print_local_groups
      && AllocateAndInitializeSid (&sid_nt_auth, 2,
				   SECURITY_BUILTIN_DOMAIN_RID,
				   DOMAIN_ALIAS_RID_ADMINS,
				   0, 0, 0, 0, 0, 0, &sid))
    {
      if (LookupAccountSid (NULL, sid,
			    name, (len = 256, &len),
			    dom, (len2 = 256, &len),
			    &use))
	printf ("%s:*:%ld:%ld:%s%s::\n", name,
					 DOMAIN_ALIAS_RID_ADMINS,
					 DOMAIN_ALIAS_RID_ADMINS,
					 print_sids ? "," : "",
					 print_sids ? put_sid (sid) : "");
      FreeSid (sid);
    }
@


1.12
log
@* Makefile.in (dumper): Change logic for libbfd and libintl so that they will
be found either in the build tree or the installed directory.
* mkpasswd.c (enum_users): Add a comment as a password for NT.
@
text
@d209 1
a209 1
	  printf ("%s:This_field_is_not_used_by_cygwin_on_nt/2000/xp:%d:%d:%s%s%s:%s:/bin/bash\n", username,
@


1.11
log
@* mkpasswd.c (main): Output passwd file in binary mode so that there are no CRs
in the file.
* umount.cc (remove_all_user_mounts): Don't try to remove /cygdrive mounts.
@
text
@d209 1
a209 1
	  printf ("%s::%d:%d:%s%s%s:%s:/bin/bash\n", username,
@


1.10
log
@* mkpasswd.c (enum_users): Use /bin/bash as the default shell.
(main): Ditto.
@
text
@d20 1
d373 1
@


1.9
log
@Patch by Kazuhiro Fujieda  <fujieda@@jaist.ac.jp>:
        * mkgroup.c (enum_groups): Use RID + offset specified an additional
        argument as ID.
        (usage): Add description of -o option.
        (longopts, opts): Add specifications of -o/--id-offset option.
        (main): Add -o option. Invoke enum_groups with specified offset.
        * mkpasswd.c (enum_users): Just like mkgroup.c.
        (usage, longopts, opts): Ditto.
        (main): Add -o option. Invoke enum_users with specified offset
        only against domain accounts.
@
text
@d208 1
a208 1
	  printf ("%s::%d:%d:%s%s%s:%s:/bin/sh\n", username,
d444 1
a444 1
      printf ("%s::%ld:%ld::%s%s:/bin/sh\n", name,
@


1.8
log
@* mkgroup.c (uni2ansi): Use native method to convert from Unicode
to multi-byte strings.
* mkpasswd.c (uni2ansi): Ditto.
(enum_users): Pass buffer size when converting string.
(enum_local_groups): Ditto.
* mkgroup.c (enum_groups): Ditto.
(enum_local_groups): Ditto.
@
text
@d105 1
a105 1
	    const char * passed_home_path)
d208 3
a210 1
	  printf ("%s::%d:%d:%s%s%s:%s:/bin/sh\n", username, uid, gid,
d323 2
d340 1
d349 1
a349 1
char opts[] = "ldgsmhp:";
d363 1
d387 3
d534 1
a534 1
      enum_users (servername, print_sids, print_cygpath, passed_home_path);
d538 1
a538 1
    enum_users (NULL, print_sids, print_cygpath, passed_home_path);
@


1.7
log
@        * mkpasswd.c: make default home directory /home/$user if one
        can't be found in user registry. Allow user to override
        that with command line arg.
        (longopts): Fix typo in `local-groups' option.
        (main): Initialize `passed_home_path' before first usage.
@
text
@d95 1
a95 1
uni2ansi (LPWSTR wcs, char *mbs)
d98 1
a98 2
    wcstombs (mbs, wcs, (wcslen (wcs) + 1) * sizeof (WCHAR));

d115 1
a115 1
    uni2ansi (servername, ansi_srvname);
d154 2
a155 2
	  uni2ansi (buffer[i].usri3_name, username);
	  uni2ansi (buffer[i].usri3_full_name, fullname);
d157 1
a157 1
	  uni2ansi (buffer[i].usri3_home_dir, homedir_w32);
d266 1
a266 1
	  uni2ansi (buffer[i].lgrpi0_name, localgroup_name);
@


1.6
log
@Make initial tabbing consistent.
@
text
@d105 2
a106 1
enum_users (LPWSTR servername, int print_sids, int print_cygpath)
d164 6
d319 11
a329 9
  fprintf (stderr, "   -l,--local           print local user accounts\n");
  fprintf (stderr, "   -d,--domain          print domain accounts (from current domain\n");
  fprintf (stderr, "                        if no domain specified)\n");
  fprintf (stderr, "   -g,--local-groups    print local group information too\n");
  fprintf (stderr, "                        if no domain specified\n");
  fprintf (stderr, "   -m,--no-mount        don't use mount points for home dir\n");
  fprintf (stderr, "   -s,--no-sids         don't print SIDs in GCOS field\n");
  fprintf (stderr, "                        (this affects ntsec)\n");
  fprintf (stderr, "   -?,--help            displays this message\n\n");
d337 1
a337 1
  {"loca-groups", no_argument, NULL, 'g'},
d340 1
d345 1
a345 1
char opts[] = "ldgsmh";
d361 1
a361 1
  char name[256], dom[256];
d366 2
d391 11
d426 3
d436 5
a440 4
      printf ("%s::%ld:%ld::/home/%s:/bin/sh\n", name,
						 DOMAIN_USER_RID_ADMIN,
						 DOMAIN_ALIAS_RID_ADMINS,
						 name);
d526 1
a526 1
      enum_users (servername, print_sids, print_cygpath);
d530 1
a530 1
    enum_users (NULL, print_sids, print_cygpath);
@


1.5
log
@        * mkgroup.c (load_netapi): New function to load netapi32.dll functions
        dynamically so that mkgroup works on 9x/ME as well.
        Use corresponding function pointers throughout.
        (usage): Change to `int'. Change text to be conformant to mkpasswd.
        (main): Use `getlongopt' to process options.
        Special handling to create a group entry on 9x/ME.
        * mkpasswd.c (load_netapi): New function to load netapi32.dll functions
        dynamically so that mkpasswd works on 9x/ME as well.
        Use corresponding function pointers throughout.
        (usage): Change to `int'. Change text to be conformant to mkgroup.
        (main): Use `getlongopt' to process options.
        Special handling to create a passwd entry on 9x/ME.
        Change conditional to create an entry for the local administrators
        group when appropriate.
@
text
@d158 3
a160 3
          if (print_cygpath)
            cygwin_conv_to_posix_path (homedir_w32, homedir_psx);
          else
d163 39
a201 39
          if (print_sids)
            {
              if (!LookupAccountName (servername ? ansi_srvname : NULL,
                                      username,
                                      psid, &sid_length,
                                      domain_name, &domname_len,
			              &acc_type))
                {
                  fprintf (stderr,
                           "LookupAccountName(%s,%s) failed with error %ld\n",
                           servername ? ansi_srvname : "NULL",
                           username,
                           GetLastError ());
                  continue;
                }
              else if (acc_type == SidTypeDomain)
                {
                  char domname[356];

                  strcpy (domname, domain_name);
                  strcat (domname, "\\");
                  strcat (domname, username);
                  sid_length = 1024;
                  domname_len = 100;
                  if (!LookupAccountName (servername ? ansi_srvname : NULL,
                                          domname,
                                          psid, &sid_length,
                                          domain_name, &domname_len,
			                  &acc_type))
                    {
                      fprintf (stderr,
                               "LookupAccountName(%s,%s) failed with error %ld\n",
                               servername ? ansi_srvname : "NULL",
                               domname,
                               GetLastError ());
                      continue;
                    }
                }
            }
d204 3
a206 3
                  print_sids ? "," : "",
                  print_sids ? put_sid (psid) : "",
                  homedir_psx);
d270 20
a289 20
          else if (acc_type == SidTypeDomain)
            {
              char domname[356];

              strcpy (domname, domain_name);
              strcat (domname, "\\");
              strcat (domname, localgroup_name);
              sid_length = 1024;
              domname_len = 100;
              if (!LookupAccountName (NULL, domname,
                                      psid, &sid_length,
                                      domain_name, &domname_len,
                                      &acc_type))
                {
                  fprintf (stderr,
                           "LookupAccountName(%s) failed with error %ld\n",
                           localgroup_name, GetLastError ());
                  continue;
                }
            }
d294 2
a295 2
                  print_sids ? "," : "",
                  print_sids ? put_sid (psid) : "");
d361 2
a362 2
        while ((i = getopt_long (argc, argv, opts, longopts, NULL)) != EOF)
          switch (i)
d385 2
a386 2
        if (!print_local && !print_domain && !print_local_groups)
          {
d390 2
a391 2
        if (optind < argc)
          {
d394 3
a396 3
	        fprintf (stderr, "%s: A domain name is only accepted "
	      		         "when `-d' is given.\n", argv[0]);
	        return 1;
d408 1
a408 1
        strcpy (name, "unknown");
d411 2
a412 2
                                                 DOMAIN_USER_RID_ADMIN,
                                                 DOMAIN_ALIAS_RID_ADMINS,
d421 1
a421 1
      		       "with error %lu\n", GetLastError ());
d429 1
a429 1
                                0, 0, 0, 0, 0, 0, 0, &sid))
d432 8
a439 8
                            name, (len = 256, &len),
                            dom, (len2 = 256, &len),
                            &use))
        printf ("%s:*:%d:%d:%s%s::\n", name,
                                         SECURITY_WORLD_RID,
                                         SECURITY_WORLD_RID,
                                         print_sids ? "," : "",
                                         print_sids ? put_sid (sid) : "");
d447 1
a447 1
                                0, 0, 0, 0, 0, 0, 0, &sid))
d450 8
a457 8
                            name, (len = 256, &len),
                            dom, (len2 = 256, &len),
                            &use))
        printf ("%s:*:%d:%d:%s%s::\n", name,
                                         SECURITY_LOCAL_SYSTEM_RID,
                                         SECURITY_LOCAL_SYSTEM_RID,
                                         print_sids ? "," : "",
                                         print_sids ? put_sid (sid) : "");
d466 3
a468 3
                                   SECURITY_BUILTIN_DOMAIN_RID,
                                   DOMAIN_ALIAS_RID_ADMINS,
                                   0, 0, 0, 0, 0, 0, &sid))
d471 8
a478 8
                            name, (len = 256, &len),
                            dom, (len2 = 256, &len),
                            &use))
        printf ("%s:*:%ld:%ld:%s%s::\n", name,
                                         DOMAIN_ALIAS_RID_ADMINS,
                                         DOMAIN_ALIAS_RID_ADMINS,
                                         print_sids ? "," : "",
                                         print_sids ? put_sid (sid) : "");
@


1.4
log
@Cleanup formatting on some files.  Remove excessive whitespace.
@
text
@d17 1
d24 5
d33 20
d121 1
a121 1
      rc = NetUserEnum (servername, 3, FILTER_NORMAL_ACCOUNT,
d209 1
a209 1
      NetApiBufferFree (buffer);
d215 1
a215 1
    NetApiBufferFree (servername);
d233 1
a233 1
      rc = NetLocalGroupEnum (NULL, 0, (LPBYTE *) & buffer, 1024,
d246 1
a246 1
	  fprintf (stderr, "NetUserEnum() failed with %ld\n", rc);
d298 1
a298 1
      NetApiBufferFree (buffer);
d306 1
a306 1
void
d309 1
a309 2
  fprintf (stderr, "\n");
  fprintf (stderr, "usage: mkpasswd [options] [domain]\n\n");
d311 12
a322 11
  fprintf (stderr, "Options are\n");
  fprintf (stderr, "   -l,--local              print local accounts\n");
  fprintf (stderr, "   -d,--domain             print domain accounts (from current domain\n");
  fprintf (stderr, "                           if no domain specified\n");
  fprintf (stderr, "   -g,--local-groups       print local group information too\n");
  fprintf (stderr, "   -m,--no-mount           don't use mount points for home dir\n");
  fprintf (stderr, "   -s,--no-sids            don't print SIDs in GCOS field\n");
  fprintf (stderr, "                           (this affects ntsec)\n");
  fprintf (stderr, "   -?,--help               displays this message\n\n");
  fprintf (stderr, "This program does only work on Windows NT\n\n");
  exit (1);
d325 12
d356 46
a401 2
  if (argc == 1)
    usage ();
d403 2
a404 1
  else
d406 3
a408 16
      for (i = 1; i < argc; i++)
	{
	  if (!strcmp (argv[i], "-l") || !strcmp (argv[i], "--local"))
	    print_local = 1;

	  else if (!strcmp (argv[i], "-d") || !strcmp (argv[i], "--domain"))
	    print_domain = 1;

	  else if (!strcmp (argv[i], "-g") || !strcmp (argv[i], "--local-groups"))
	    print_local_groups = 1;

	  else if (!strcmp (argv[i], "-s") || !strcmp (argv[i], "--no-sids"))
	    print_sids = 0;

	  else if (!strcmp (argv[i], "-m") || !strcmp (argv[i], "--no-mount"))
	    print_cygpath = 0;
d410 4
a413 2
	  else if (!strcmp (argv[i], "-?") || !strcmp (argv[i], "--help"))
	    usage ();
d415 1
a415 6
	  else
	    {
	      mbstowcs (domain_name, argv[i], (strlen (argv[i]) + 1));
	      domain_name_specified = 1;
	    }
	}
d418 1
a418 2
  /* FIXME: this needs to take Windows 98 into account. */
  if (GetVersion () >= 0x80000000)
d420 3
a422 2
      fprintf (stderr, "The required functionality is not supported by Windows 95. Sorry.\n");
      exit (1);
d435 1
a435 1
        printf ("%s:*:%ld:%ld:%s%s::\n", name,
d453 1
a453 1
        printf ("%s:*:%ld:%ld:%s%s::\n", name,
d464 1
a464 1
  if (!print_local
d488 1
a488 1
	rc = NetGetDCName (NULL, domain_name, (LPBYTE *) & servername);
d491 1
a491 1
	rc = NetGetDCName (NULL, NULL, (LPBYTE *) & servername);
d506 1
a506 1
    NetApiBufferFree (servername);
@


1.3
log
@* Makefile.in: Eliminate WINSUP_DEPS.
* cygpath.cc: Reorganize includes to accomodate sys/cygwin.h changes.
* mkgroup.c: Ditto.
* mkpasswd.c: Ditto.
* mount.cc: Ditto.  Eliminate use of cygwin source specific includes.
* ps.cc: Ditto.
* cygwin.cc: Eliminate obsolete file.
@
text
@d45 1
a45 1
void 
d68 1
a68 1
void 
d78 1
a78 1
int 
d194 1
a194 1
int 
d280 1
a280 1
void 
d299 1
a299 1
int 
@


1.2
log
@        * mkpasswd.c (main): Use GetDCName instead of GetAnyDCName.
        Don't create extra passwd entry for administrators group
        if local_groups is set.
        (usage): Change usage text slightly.
        (enum_users): Loop while ERROR_MORE_DATA is returned.
        (enum_local_groups): Ditto.
        * mkgroup.c (enum_local_groups): Ditto.
        (enum_groups) Ditto.
        (usage): Change usage text slightly.
@
text
@d15 1
a16 1
#include <windows.h>
@


1.1
log
@Initial revision
@
text
@d85 1
a93 3
      DWORD rc = NetUserEnum (servername, 3, FILTER_NORMAL_ACCOUNT,
			      (LPBYTE *) & buffer, 1024,
			      &entriesread, &totalentries, &resume_handle);
d95 3
d186 1
a186 1
  while (entriesread < totalentries);
d201 1
a205 2
      DWORD rc = NetLocalGroupEnum (NULL, 0, (LPBYTE *) & buffer, 1024,
			       &entriesread, &totalentries, &resume_handle);
d207 2
d275 1
a275 1
  while (entriesread < totalentries);
d293 1
a293 1
  fprintf (stderr, "                           (this affects NT security)\n");
d397 5
a401 3
  if (AllocateAndInitializeSid (&sid_nt_auth, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                DOMAIN_ALIAS_RID_ADMINS,
                                0, 0, 0, 0, 0, 0, &sid))
d421 1
a421 1
	rc = NetGetAnyDCName (NULL, domain_name, (LPBYTE *) & servername);
d424 1
a424 1
	rc = NetGetAnyDCName (NULL, NULL, (LPBYTE *) & servername);
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
