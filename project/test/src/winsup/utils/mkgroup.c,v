head	1.63;
access;
symbols
	cygwin-1_7_35-release:1.63
	cygwin-1_7_34-release:1.62
	cygwin-1_7_33-release:1.54
	cygwin-1_7_32-release:1.54
	cygwin-1_7_31-release:1.54
	cygwin-1_7_30-release:1.54
	cygwin-1_7_29-release:1.54
	cygwin-1_7_29-release-branchpoint:1.54.0.2
	cygwin-1_7_28-release:1.54
	cygwin-1_7_27-release:1.54
	cygwin-1_7_26-release:1.54
	cygwin-1_7_25-release:1.54
	cygwin-1_7_24-release:1.54
	cygwin-1_7_23-release:1.54
	cygwin-1_7_22-release:1.54
	cygwin-1_7_21-release:1.54
	cygwin-1_7_20-release:1.54
	cygwin-1_7_19-release:1.54
	cygwin-64bit-postmerge:1.54
	cygwin-64bit-premerge-branch:1.53.0.2
	cygwin-64bit-premerge:1.53
	cygwin-1_7_18-release:1.53
	cygwin-1_7_17-release:1.52
	cygwin-64bit-branch:1.52.0.2
	cygwin-1_7_16-release:1.52
	cygwin-1_7_15-release:1.52
	cygwin-1_7_14_2-release:1.52
	cygwin-1_7_14-release:1.52
	cygwin-1_7_12-release:1.51
	cygwin-1_7_11-release:1.51
	cygwin-1_7_10-release:1.51
	cygwin-1_7_9-release:1.48
	cygwin-1_7_8-release:1.48
	cygwin-1_7_7-release:1.48
	cygwin-1_7_5-release:1.47
	cygwin-1_7_4-release:1.47
	cygwin-1_7_3-release:1.47
	cygwin-1_7_2-release:1.47
	cygwin-1_7_1-release:1.47
	cv-branch-2:1.45.0.2
	cr-0x5f1:1.27.0.6
	cv-branch:1.27.0.4
	cr-0x3b58:1.27.0.2
	cr-0x9e:1.24.0.4
	cr-0x9d:1.24.0.2
	corinna-01:1.22
	cr-0x9c:1.22.0.4
	cr-0x9b:1.22.0.6
	cr-0x99:1.22
	Z-emcb-cygwin_daemon:1.22.0.2
	w32api-2_2:1.19
	mingw-runtime-2_4:1.19
	cygnus_cvs_20020108_pre:1.8
	Z-cygwin_daemon_merge-new_HEAD:1.7
	Z-cygwin_daemon_merge_HEAD:1.7
	cygwin_daemon:1.7.0.8;
locks; strict;
comment	@ * @;
expand	@o@;


1.63
date	2015.02.25.20.18.29;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2014.11.28.08.44.39;	author corinna;	state Exp;
branches;
next	1.61;

1.61
date	2014.11.27.19.55.37;	author corinna;	state Exp;
branches;
next	1.60;

1.60
date	2014.11.12.14.22.05;	author corinna;	state Exp;
branches;
next	1.59;

1.59
date	2014.11.12.14.13.56;	author corinna;	state Exp;
branches;
next	1.58;

1.58
date	2014.11.10.16.21.52;	author corinna;	state Exp;
branches;
next	1.57;

1.57
date	2014.11.03.16.29.03;	author corinna;	state Exp;
branches;
next	1.56;

1.56
date	2014.07.29.13.29.53;	author corinna;	state Exp;
branches;
next	1.55;

1.55
date	2014.02.24.10.51.42;	author corinna;	state Exp;
branches;
next	1.54;

1.54
date	2013.04.23.09.44.36;	author corinna;	state Exp;
branches;
next	1.53;

1.53
date	2013.01.21.16.28.27;	author cgf;	state Exp;
branches;
next	1.52;

1.52
date	2012.04.05.13.37.32;	author corinna;	state Exp;
branches
	1.52.2.1;
next	1.51;

1.51
date	2011.12.17.23.39.47;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2011.12.01.13.06.13;	author corinna;	state Exp;
branches;
next	1.49;

1.49
date	2011.10.10.14.57.47;	author corinna;	state Exp;
branches;
next	1.48;

1.48
date	2010.08.28.11.22.37;	author corinna;	state Exp;
branches;
next	1.47;

1.47
date	2009.10.02.13.49.39;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2009.08.11.08.59.50;	author corinna;	state Exp;
branches;
next	1.45;

1.45
date	2009.05.15.11.30.18;	author corinna;	state Exp;
branches;
next	1.44;

1.44
date	2009.05.06.11.54.24;	author corinna;	state Exp;
branches;
next	1.43;

1.43
date	2008.08.25.09.38.14;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2008.08.18.12.56.59;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2008.08.18.12.42.44;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2008.08.18.08.58.21;	author corinna;	state Exp;
branches;
next	1.39;

1.39
date	2008.08.18.08.52.49;	author corinna;	state Exp;
branches;
next	1.38;

1.38
date	2008.08.18.08.33.48;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2008.08.17.16.45.44;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2008.08.15.13.08.47;	author corinna;	state Exp;
branches;
next	1.35;

1.35
date	2008.07.23.20.12.12;	author corinna;	state Exp;
branches;
next	1.34;

1.34
date	2008.07.23.18.09.50;	author corinna;	state Exp;
branches;
next	1.33;

1.33
date	2008.07.23.11.41.10;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2008.07.22.20.47.14;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2008.07.22.20.12.02;	author corinna;	state Exp;
branches;
next	1.30;

1.30
date	2008.07.22.14.40.05;	author corinna;	state Exp;
branches;
next	1.29;

1.29
date	2008.07.09.14.32.29;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2007.08.31.00.39.41;	author davek;	state Exp;
branches;
next	1.27;

1.27
date	2006.01.18.15.57.56;	author cgf;	state Exp;
branches
	1.27.6.1;
next	1.26;

1.26
date	2005.09.21.22.26.08;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2004.07.12.16.52.16;	author corinna;	state Exp;
branches;
next	1.24;

1.24
date	2003.11.26.15.47.44;	author corinna;	state Exp;
branches;
next	1.23;

1.23
date	2003.11.14.19.14.43;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2003.04.26.21.52.03;	author joshuadfranklin;	state Exp;
branches;
next	1.21;

1.21
date	2003.04.10.01.14.18;	author phumblet;	state Exp;
branches;
next	1.20;

1.20
date	2003.03.01.16.38.26;	author phumblet;	state Exp;
branches;
next	1.19;

1.19
date	2003.01.15.10.08.37;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.08.17.38.11;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2002.09.30.03.01.17;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.15.19.24.36;	author joshuadfranklin;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.02.11.14.35;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.02.12.59.43;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2002.04.29.10.21.54;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.19.15.48.40;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.19.15.28.13;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.15.14.53.55;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.29.03.08.42;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.20.13.56.09;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2001.04.16.13.19.27;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2001.04.15.14.09.33;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.11.09.38.55;	author duda;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.08.15.00.02;	author corinna;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.18.18.39.11;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.15.22.30.49;	author corinna;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.52.2.1
date	2013.01.29.21.54.42;	author corinna;	state Exp;
branches;
next	1.52.2.2;

1.52.2.2
date	2013.02.06.17.03.49;	author corinna;	state Exp;
branches;
next	1.52.2.3;

1.52.2.3
date	2013.03.22.13.55.08;	author corinna;	state Exp;
branches;
next	;

1.27.6.1
date	2007.11.12.15.31.45;	author corinna;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.63
log
@	* mkgroup.c (MAX_SID_LEN): Remove.  Instead, use SECURITY_MAX_SID_SIZE
	throughout.
	(enum_unix_groups): Introduce numeric_psid and rearrange code to avoid
	potential heap corruption.
	* mkpasswd.c: Ditto.
@
text
@/* mkgroup.c:

   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015 Red Hat, Inc.

   This file is part of Cygwin.

   This software is a copyrighted work licensed under the terms of the
   Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
   details. */

#define _WIN32_WINNT 0x0600
#include <errno.h>
#include <ctype.h>
#include <stdlib.h>
#include <wchar.h>
#include <wctype.h>
#include <locale.h>
#include <stdio.h>
#include <unistd.h>
#include <inttypes.h>
#include <getopt.h>
#include <io.h>
#include <grp.h>
#include <sys/fcntl.h>
#include <sys/cygwin.h>
#include <cygwin/version.h>
#include <windows.h>
#include <lm.h>
#include <wininet.h>
#include <iptypes.h>
#include <ntsecapi.h>
#include <ntdef.h>

#define print_win_error(x) _print_win_error(x, __LINE__)

SID_IDENTIFIER_AUTHORITY sid_world_auth = {SECURITY_WORLD_SID_AUTHORITY};
SID_IDENTIFIER_AUTHORITY sid_nt_auth = {SECURITY_NT_AUTHORITY};

#ifndef min
#define min(a,b) (((a)<(b))?(a):(b))
#endif

typedef struct
{
  char *str;
  BOOL domain;
  BOOL with_dom;
} domlist_t;

static void
_print_win_error (DWORD code, int line)
{
  char buf[4096];

  if (FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM
      | FORMAT_MESSAGE_IGNORE_INSERTS,
      NULL,
      code,
      MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),
      (LPTSTR) buf, sizeof (buf), NULL))
    fprintf (stderr, "mkgroup (%d): [%" PRIu32 "] %s",
	     line, (unsigned int) code, buf);
  else
    fprintf (stderr, "mkgroup (%d): error %" PRIu32 ,
	     line, (unsigned int) code);
}

static char *
put_sid (PSID psid)
{
  static char s[512];
  char t[32];
  DWORD i;

  strcpy (s, "S-1-");
  sprintf(t, "%u", GetSidIdentifierAuthority (psid)->Value[5]);
  strcat (s, t);
  for (i = 0; i < *GetSidSubAuthorityCount (psid); ++i)
    {
      sprintf(t, "-%" PRIu32 , (unsigned int) *GetSidSubAuthority (psid, i));
      strcat (s, t);
    }
  return s;
}

typedef struct {
  BYTE  Revision;
  BYTE  SubAuthorityCount;
  SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
  DWORD SubAuthority[8];
} DBGSID, *PDBGSID;

#define MAX_BUILTIN_SIDS 100	/* Should be enough for the forseable future. */
DBGSID builtin_sid_list[MAX_BUILTIN_SIDS];
DWORD builtin_sid_cnt;

typedef struct {
  PSID psid;
  int buffer[10];
} sidbuf;

static sidbuf curr_pgrp;
static BOOL got_curr_pgrp = FALSE;

static void
fetch_current_pgrp_sid ()
{
  DWORD len;
  HANDLE ptok;

  if (!OpenProcessToken (GetCurrentProcess (), TOKEN_QUERY, &ptok)
      || !GetTokenInformation (ptok, TokenPrimaryGroup, &curr_pgrp,
			       sizeof curr_pgrp, &len)
      || !CloseHandle (ptok))
    {
      print_win_error (GetLastError ());
      return;
    }
}

static void
enum_unix_groups (domlist_t *mach, const char *sep, DWORD id_offset,
		  char *unix_grp_list)
{
  WCHAR machine[INTERNET_MAX_HOST_NAME_LENGTH + 1];
  SID_IDENTIFIER_AUTHORITY auth = { { 0, 0, 0, 0, 0, 22 } };
  char *gstr, *grp_list;
  WCHAR grp[GNLEN + sizeof ("Unix Group\\") + 1];
  WCHAR dom[MAX_DOMAIN_NAME_LEN + 1];
  DWORD glen, dlen, sidlen;
  PSID psid;
  PSID numeric_psid;
  char psid_buffer[SECURITY_MAX_SID_SIZE];
  SID_NAME_USE acc_type;

  int ret = mbstowcs (machine, mach->str, INTERNET_MAX_HOST_NAME_LENGTH + 1);
  if (ret < 1 || ret >= INTERNET_MAX_HOST_NAME_LENGTH + 1)
    {
      fprintf (stderr, "%s: Invalid machine name '%s'.  Skipping...\n",
	       program_invocation_short_name, mach->str);
      return;
    }

  if (!AllocateAndInitializeSid (&auth, 2, 2, 0, 0, 0, 0, 0, 0, 0,
				 &numeric_psid))
    return;

  if (!(grp_list = strdup (unix_grp_list)))
    {
      FreeSid (numeric_psid);
      return;
    }

  for (gstr = strtok (grp_list, ","); gstr; gstr = strtok (NULL, ","))
    {
      if (!isdigit ((unsigned char) gstr[0]) && gstr[0] != '-')
	{
	  PWCHAR p = wcpcpy (grp, L"Unix Group\\");
	  ret = mbstowcs (p, gstr, GNLEN + 1);
	  if (ret < 1 || ret >= GNLEN + 1)
	    {
	      fprintf (stderr, "%s: Invalid group name '%s'.  Skipping...\n",
		       program_invocation_short_name, gstr);
	      continue;
	    }
	  psid = (PSID) psid_buffer;
	  sidlen = SECURITY_MAX_SID_SIZE;
	  dlen = MAX_DOMAIN_NAME_LEN + 1;
	  if (LookupAccountNameW (machine, grp, psid, &sidlen,
				  dom, &dlen, &acc_type))
	    printf ("%s%s%ls:%s:%" PRIu32 ":\n",
		    "Unix_Group",
		    sep,
		    p,
		    put_sid (psid),
		    (unsigned int) (id_offset +
		    *GetSidSubAuthority (psid,
					 *GetSidSubAuthorityCount(psid) - 1)));
	}
      else
	{
	  DWORD start, stop;
	  char *p = gstr;
	  if (*p == '-')
	    start = 0;
	  else
	    start = strtol (p, &p, 10);
	  if (!*p)
	    stop = start;
	  else if (*p++ != '-' || !isdigit ((unsigned char) *p)
		   || (stop = strtol (p, &p, 10)) < start || *p)
	    {
	      fprintf (stderr, "%s: Malformed unix group list entry '%s'.  "
			       "Skipping...\n",
			       program_invocation_short_name, gstr);
	      continue;
	    }
	  for (; start <= stop; ++ start)
	    {
	      psid = numeric_psid;
	      *GetSidSubAuthority (psid, *GetSidSubAuthorityCount(psid) - 1)
	      = start;
	      glen = GNLEN + 1;
	      dlen = MAX_DOMAIN_NAME_LEN + 1;
	      if (LookupAccountSidW (machine, psid, grp, &glen,
				     dom, &dlen, &acc_type)
		  && !iswdigit (grp[0]))
		printf ("%s%s%ls:%s:%" PRIu32 ":\n",
			"Unix_Group",
			sep,
			grp,
			put_sid (psid),
			(unsigned int) (id_offset + start));
	    }
	}
    }

  free (grp_list);
  FreeSid (numeric_psid);
}

static int
enum_local_groups (domlist_t *mach, const char *sep,
		   DWORD id_offset, char *disp_groupname, int print_builtin,
		   int print_current)
{
  WCHAR machine[INTERNET_MAX_HOST_NAME_LENGTH + 1];
  LOCALGROUP_INFO_0 *buffer;
  DWORD entriesread = 0;
  DWORD totalentries = 0;
  DWORD_PTR resume_handle = 0;
  WCHAR gname[GNLEN + 1];
  DWORD rc;

  int ret = mbstowcs (machine, mach->str, INTERNET_MAX_HOST_NAME_LENGTH + 1);
  if (ret < 1 || ret >= INTERNET_MAX_HOST_NAME_LENGTH + 1)
    {
      fprintf (stderr, "%s: Invalid machine name '%s'.  Skipping...\n",
	       program_invocation_short_name, mach->str);
      return 1;
    }

  do
    {
      DWORD i;

      if (disp_groupname)
	{
	  mbstowcs (gname, disp_groupname, GNLEN + 1);
	  rc = NetLocalGroupGetInfo (machine, gname, 0, (void *) &buffer);
	  if (rc == ERROR_SUCCESS)
	    entriesread = 1;
	  /* Allow further searching for the group and avoid annoying
	     error messages just because the group is not a local group or
	     the group hasn't been found. */
	  else if (rc == ERROR_NO_SUCH_ALIAS || rc == NERR_GroupNotFound)
	    return 0;
	}
      else
	rc = NetLocalGroupEnum (machine, 0, (void *) &buffer,
				MAX_PREFERRED_LENGTH, &entriesread,
				&totalentries, &resume_handle);
      switch (rc)
	{
	case ERROR_ACCESS_DENIED:
	  print_win_error (rc);
	  return 1;

	case ERROR_MORE_DATA:
	case ERROR_SUCCESS:
	  break;

	default:
	  print_win_error (rc);
	  return 1;
	}

      for (i = 0; i < entriesread; i++)
	{
	  WCHAR domain_name[MAX_DOMAIN_NAME_LEN + 1];
	  DWORD domname_len = MAX_DOMAIN_NAME_LEN + 1;
	  char psid_buffer[SECURITY_MAX_SID_SIZE];
	  PSID psid = (PSID) psid_buffer;
	  DWORD sid_length = SECURITY_MAX_SID_SIZE;
	  DWORD gid;
	  SID_NAME_USE acc_type;
	  PDBGSID pdsid;
	  BOOL is_builtin = FALSE;

	  if (!LookupAccountNameW (machine, buffer[i].lgrpi0_name, psid,
				   &sid_length, domain_name, &domname_len,
				   &acc_type))
	    {
	      print_win_error (GetLastError ());
	      fprintf (stderr, " (%ls)\n", buffer[i].lgrpi0_name);
	      continue;
	    }
	  else if (acc_type == SidTypeDomain)
	    {
	      WCHAR domname[MAX_DOMAIN_NAME_LEN + GNLEN + 2];

	      wcscpy (domname, domain_name);
	      wcscat (domname, L"\\");
	      wcscat (domname, buffer[i].lgrpi0_name);
	      sid_length = SECURITY_MAX_SID_SIZE;
	      domname_len = MAX_DOMAIN_NAME_LEN + 1;
	      if (!LookupAccountNameW (machine, domname,
				       psid, &sid_length,
				       domain_name, &domname_len,
				       &acc_type))
		{
		  print_win_error (GetLastError ());
		  fprintf(stderr, " (%ls)\n", domname);
		  continue;
		}
	    }

	  /* Store all local SIDs with prefix "S-1-5-32-" and check if it
	     has been printed already.  This allows to get all builtin
	     groups exactly once and not once per domain. */
	  pdsid = (PDBGSID) psid;
	  if (pdsid->IdentifierAuthority.Value[5] == sid_nt_auth.Value[5]
	      && pdsid->SubAuthority[0] == SECURITY_BUILTIN_DOMAIN_RID)
	    {
	      int b;

	      if (!print_builtin)
		goto skip_group;
	      is_builtin = TRUE;
	      if (builtin_sid_cnt)
		for (b = 0; b < builtin_sid_cnt; b++)
		  if (EqualSid (&builtin_sid_list[b], psid))
		    goto skip_group;
	      if (builtin_sid_cnt < MAX_BUILTIN_SIDS)
		CopySid (sizeof (DBGSID), &builtin_sid_list[builtin_sid_cnt++],
			 psid);
	    }
	  if (!print_current)
	    /* fall through */;
	  else if (EqualSid (curr_pgrp.psid, psid))
	    got_curr_pgrp = TRUE;

	  gid = *GetSidSubAuthority (psid, *GetSidSubAuthorityCount(psid) - 1);
	  printf ("%ls%s%ls:%s:%" PRIu32 ":\n",
		  mach->with_dom && !is_builtin ? domain_name : L"",
		  mach->with_dom && !is_builtin ? sep : "",
		  buffer[i].lgrpi0_name,
		  put_sid (psid),
		  (unsigned int) (gid + (is_builtin ? 0 : id_offset)));
skip_group:
	  ;
	}

      NetApiBufferFree (buffer);

    }
  while (rc == ERROR_MORE_DATA);

  /* Return 1 if the single group we're looking for has been found here to
     avoid calling enum_groups for the same group, thus avoiding a spurious
     error message "group name could not be found" in enum_groups. */
  return disp_groupname && entriesread ? 1 : 0;
}

static void
enum_groups (domlist_t *mach, const char *sep, DWORD id_offset,
	     char *disp_groupname, int print_current)
{
  WCHAR machine[INTERNET_MAX_HOST_NAME_LENGTH + 1];
  GROUP_INFO_2 *buffer;
  DWORD entriesread = 0;
  DWORD totalentries = 0;
  DWORD_PTR resume_handle = 0;
  WCHAR gname[GNLEN + 1];
  DWORD rc;

  int ret = mbstowcs (machine, mach->str, INTERNET_MAX_HOST_NAME_LENGTH + 1);
  if (ret < 1 || ret >= INTERNET_MAX_HOST_NAME_LENGTH + 1)
    {
      fprintf (stderr, "%s: Invalid machine name '%s'.  Skipping...\n",
	       program_invocation_short_name, mach->str);
      return;
    }

  do
    {
      DWORD i;

      if (disp_groupname != NULL)
	{
	  mbstowcs (gname, disp_groupname, GNLEN + 1);
	  rc = NetGroupGetInfo (machine, (LPWSTR) & gname, 2, (void *) &buffer);
	  entriesread=1;
	  /* Avoid annoying error messages just because the group hasn't been
	     found. */
	  if (rc == NERR_GroupNotFound)
	    return;
	}
      else
	rc = NetGroupEnum (machine, 2, (void *) & buffer, MAX_PREFERRED_LENGTH,
			   &entriesread, &totalentries, &resume_handle);
      switch (rc)
	{
	case ERROR_ACCESS_DENIED:
	  print_win_error (rc);
	  return;

	case ERROR_MORE_DATA:
	case ERROR_SUCCESS:
	  break;

	default:
	  print_win_error (rc);
	  return;
	}

      for (i = 0; i < entriesread; i++)
	{
	  WCHAR domain_name[MAX_DOMAIN_NAME_LEN + 1];
	  DWORD domname_len = MAX_DOMAIN_NAME_LEN + 1;
	  char psid_buffer[SECURITY_MAX_SID_SIZE];
	  PSID psid = (PSID) psid_buffer;
	  DWORD sid_length = SECURITY_MAX_SID_SIZE;
	  SID_NAME_USE acc_type;

	  int gid = buffer[i].grpi2_group_id;
	  if (!LookupAccountNameW (machine, buffer[i].grpi2_name,
				   psid, &sid_length,
				   domain_name, &domname_len,
				   &acc_type))
	    {
	      print_win_error (GetLastError ());
	      fprintf(stderr, " (%ls)\n", buffer[i].grpi2_name);
	      continue;
	    }
	  else if (acc_type == SidTypeDomain)
	    {
	      WCHAR domname[MAX_DOMAIN_NAME_LEN + GNLEN + 2];

	      wcscpy (domname, machine);
	      wcscat (domname, L"\\");
	      wcscat (domname, buffer[i].grpi2_name);
	      sid_length = SECURITY_MAX_SID_SIZE;
	      domname_len = MAX_DOMAIN_NAME_LEN + 1;
	      if (!LookupAccountNameW (machine, domname, psid, &sid_length,
				       domain_name, &domname_len, &acc_type))
		{
		  print_win_error (GetLastError ());
		  fprintf(stderr, " (%ls)\n", domname);
		  continue;
		}
	    }
	  if (!print_current)
	    /* fall through */;
	  else if (EqualSid (curr_pgrp.psid, psid))
	    got_curr_pgrp = TRUE;

	  printf ("%ls%s%ls:%s:%" PRIu32 ":\n",
		  mach->with_dom ? domain_name : L"",
		  mach->with_dom ? sep : "",
		  buffer[i].grpi2_name,
		  put_sid (psid),
		  (unsigned int) (id_offset + gid));
	}

      NetApiBufferFree (buffer);

    }
  while (rc == ERROR_MORE_DATA);
}

static int
usage (FILE * stream)
{
  fprintf (stream,
"Usage: %s [OPTION]...\n"
"\n"
"Write /etc/group-like output to stdout\n"
"\n"
"Don't use this command to generate a local /etc/group file, unless you\n"
"really need one.  See the Cygwin User's Guide for more information.\n"
"\n"
"Options:\n"
"\n"
"   -l,--local [machine]    Print local group accounts of \"machine\",\n"
"                           from local machine if no machine specified.\n"
"                           Automatically adding machine prefix for local\n"
"                           machine depends on settings in /etc/nsswitch.conf.\n"
"   -L,--Local machine      Ditto, but generate groupname with machine prefix.\n"
"   -d,--domain [domain]    Print domain groups,\n"
"                           from current domain if no domain specified.\n"
"   -c,--current            Print current group.\n"
"   -S,--separator char     For -L use character char as domain\\group\n"
"                           separator in groupname instead of default '%s'.\n"
"   -o,--id-offset offset   Change the default offset (0x10000) added to gids\n"
"                           of foreign local machine accounts.  Use with -l/-L.\n"
"   -g,--group groupname    Only return information for the specified group.\n"
"                           One of -l, -d must be specified, too.\n"
"   -b,--no-builtin         Don't print BUILTIN groups.\n"
"   -U,--unix grouplist     Print UNIX groups when using -l on a UNIX Samba\n"
"                           server.  Grouplist is a comma-separated list of\n"
"                           groupnames or gid ranges (root,-25,50-100).\n"
"                           Enumerating large ranges can take a long time!\n"
"   -h,--help               Print this message.\n"
"   -v,--version            Print version information and exit.\n"
"\n"
"Default is to print local groups on stand-alone machines, plus domain\n"
"groups on domain controllers and domain member machines.\n"
"\n", program_invocation_short_name,
      (const char *) cygwin_internal (CW_GETNSSSEP));
  return 1;
}

struct option longopts[] = {
  {"no-builtin", no_argument, NULL, 'b'},
  {"current", no_argument, NULL, 'c'},
  {"Current", no_argument, NULL, 'C'},
  {"domain", optional_argument, NULL, 'd'},
  {"Domain", optional_argument, NULL, 'D'},
  {"group", required_argument, NULL, 'g'},
  {"help", no_argument, NULL, 'h'},
  {"local", optional_argument, NULL, 'l'},
  {"Local", optional_argument, NULL, 'L'},
  {"id-offset", required_argument, NULL, 'o'},
  {"no-sids", no_argument, NULL, 's'},
  {"separator", required_argument, NULL, 'S'},
  {"users", no_argument, NULL, 'u'},
  {"unix", required_argument, NULL, 'U'},
  {"version", no_argument, NULL, 'V'},
  {0, no_argument, NULL, 0}
};

static char opts[] = "bcCd::D::g:hl::L::o:sS:uU:V";

static void
print_version ()
{
  printf ("mkgroup (cygwin) %d.%d.%d\n"
	  "Group File Generator\n"
	  "Copyright (C) 1997 - %s Red Hat, Inc.\n"
	  "This is free software; see the source for copying conditions.  There is NO\n"
	  "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n",
	  CYGWIN_VERSION_DLL_MAJOR / 1000,
	  CYGWIN_VERSION_DLL_MAJOR % 1000,
	  CYGWIN_VERSION_DLL_MINOR,
	  strrchr (__DATE__, ' ') + 1);
}

int
main (int argc, char **argv)
{
  int print_domlist = 0;
  domlist_t domlist[32];
  char cname[1024];
  char *opt, *p;
  int print_current = 0;
  int print_builtin = 1;
  char *print_unix = NULL;
  const char *sep_char = (const char *) cygwin_internal (CW_GETNSSSEP);
  DWORD id_offset = 0x10000, off;
  int c, i;
  char *disp_groupname = NULL;
  int optional_args = 0;
  uintptr_t nss_src = cygwin_internal (CW_GETNSS_GRP_SRC);

  if (!isatty (1))
    setmode (1, O_BINARY);

  /* Use locale from environment.  If not set or set to "C", use UTF-8. */
  setlocale (LC_CTYPE, "");
  if (!strcmp (setlocale (LC_CTYPE, NULL), "C"))
    setlocale (LC_CTYPE, "en_US.UTF-8");
  fetch_current_pgrp_sid ();

  if (argc == 1)
    {
      int enums = ENUM_PRIMARY | ENUM_LOCAL | ENUM_BUILTIN;
      uintptr_t ticket = cygwin_internal (CW_SETENT, TRUE, enums, NULL);
      if (ticket)
	{
	  struct group *grp;

	  while ((grp = (struct group *) cygwin_internal (CW_GETENT, TRUE,
							  ticket)))
	    printf ("%s:%s:%u:\n", grp->gr_name, grp->gr_passwd, grp->gr_gid);
	  cygwin_internal (CW_ENDENT, TRUE, ticket);
	}
      return 0;
    }

  unsetenv ("POSIXLY_CORRECT"); /* To get optional arg processing right. */
  while ((c = getopt_long (argc, argv, opts, longopts, NULL)) != EOF)
    switch (c)
      {
      case 'd':
      case 'D':
      case 'l':
      case 'L':
	if (print_domlist >= 32)
	  {
	    fprintf (stderr, "%s: Can not enumerate from more than 32 "
			     "domains and machines.\n",
			     program_invocation_short_name);
	    return 1;
	  }
	domlist[print_domlist].domain = (c == 'd' || c == 'D');
	opt = optarg ?:
	      argv[optind] && argv[optind][0] != '-' ? argv[optind] : NULL;
	if (argv[optind] && opt == argv[optind])
	  ++optional_args;
	for (i = 0; i < print_domlist; ++i)
	  if (domlist[i].domain == domlist[print_domlist].domain
	      && ((!domlist[i].str && !opt)
		  || (domlist[i].str && opt
		      && (off = strlen (domlist[i].str))
		      && !strncmp (domlist[i].str, opt, off)
		      && (!opt[off] || opt[off] == ','))))
	    {
	      fprintf (stderr, "%s: Duplicate %s '%s'.  Skipping...\n",
		       program_invocation_short_name,
		       domlist[i].domain ? "domain" : "machine",
		       domlist[i].str);
	      break;
	    }
	domlist[print_domlist].str = opt;
	if (opt && (p = strchr (opt, ',')))
	  {
	    if (p == opt)
	      {
		fprintf (stderr, "%s: Malformed machine string '%s'.  "
			 "Skipping...\n", program_invocation_short_name, opt);
		break;
	      }
	    *p = '\0';
	  }
	if (c == 'l' || c == 'L')
	  {
	    DWORD csize = sizeof cname;

	    domlist[print_domlist].with_dom = (c == 'L');
	    if (!opt)
	      {
		/* If the system uses /etc/group exclusively as account DB,
		   create local group names the old fashioned way. */
		if (nss_src == NSS_SRC_FILES)
		  {
		    GetComputerNameExA (ComputerNameNetBIOS, cname, &csize);
		    domlist[print_domlist].str = cname;
		  }
	      }
	    else if (nss_src != NSS_SRC_FILES)
	      {
		/* If the system uses Windows account DBs, check if machine
		   name is local machine.  If so, remove the domain name to
		   enforce system naming convention. */
		if (GetComputerNameExA (strchr (opt, '.')
					? ComputerNameDnsFullyQualified
					: ComputerNameNetBIOS,
					cname, &csize)
		    && strcasecmp (opt, cname) == 0)
		  domlist[print_domlist].str = NULL;
	      }
	  }
	++print_domlist;
	break;
      case 'S':
	sep_char = optarg;
	if (strlen (sep_char) > 1)
	  {
	    fprintf (stderr, "%s: Only one ASCII character allowed as "
			     "domain\\user separator character.\n",
			     program_invocation_short_name);
	    return 1;
	  }
	if (*sep_char == ':')
	  {
	    fprintf (stderr, "%s: Colon not allowed as domain\\user separator "
			     "character.\n", program_invocation_short_name);
	    return 1;
	  }
	break;
      case 'U':
	print_unix = optarg;
	break;
      case 'c':
      case 'C':
	print_current = 1;
	break;
      case 'o':
	id_offset = strtol (optarg, NULL, 10);
	break;
      case 'b':
	print_builtin = 0;
	break;
      case 's':
	break;
      case 'u':
	break;
      case 'g':
	disp_groupname = optarg;
	break;
      case 'h':
	usage (stdout);
	return 0;
      case 'V':
	print_version ();
	return 0;
      default:
	fprintf (stderr, "Try `%s --help' for more information.\n", argv[0]);
	return 1;
      }

  optind += optional_args;
  if (argv[optind])
    {
      fprintf (stderr,
	       "mkgroup: non-option command line argument `%s' is not allowed.\n"
	       "Try `mkgroup --help' for more information.\n", argv[optind]);
      exit (1);
    }

  struct group *pgrp = NULL;
  if (print_current)
    pgrp = (struct group *) cygwin_internal (CW_GETGRSID, TRUE, curr_pgrp.psid);

  int enums = ENUM_NONE;
  WCHAR tdoms[print_domlist * 258];
  PWCHAR t = tdoms;
  if (!disp_groupname && print_builtin && print_domlist)
    enums |= ENUM_BUILTIN;
  for (i = 0; i < print_domlist; ++i)
    {
      if (domlist[i].domain)
	{
	  if (domlist[i].str)
	    {
	      enums |= ENUM_TDOMS;
	      t += mbstowcs (t, domlist[i].str, 257);
	      *t++ = L'\0';
	    }
	  else
	    enums |= ENUM_PRIMARY;
	}
      else if (!domlist[i].str)
	enums |= ENUM_LOCAL;
    }
  if (t > tdoms)
    *t++ = L'\0';
  if (enums)
    {
      uintptr_t ticket = cygwin_internal (CW_SETENT, TRUE, enums,
					  t > tdoms ? tdoms : NULL);
      if (ticket)
	{
	  struct group *grp;
	  const char *nss_sep = (const char *) cygwin_internal (CW_GETNSSSEP);

	  while ((grp = (struct group *)
			cygwin_internal (CW_GETENT, TRUE, ticket)))
	    {
	      if (disp_groupname
		  && strcasecmp (disp_groupname, grp->gr_name) != 0
		  && (!(p = strchr (grp->gr_name, nss_sep[0]))
		      || strcasecmp (disp_groupname, p + 1) != 0))
		continue;
	      printf ("%s:%s:%u:\n", grp->gr_name, grp->gr_passwd,
				     grp->gr_gid);
	      if (pgrp && !strcmp (grp->gr_passwd, pgrp->gr_passwd))
		got_curr_pgrp = TRUE;
	    }
	  cygwin_internal (CW_ENDENT, TRUE, ticket);
	}
    }

  if (print_current && !got_curr_pgrp)
    printf ("%s:%s:%u:\n", pgrp->gr_name, pgrp->gr_passwd, pgrp->gr_gid);

  off = 0xfd000000;
  for (i = 0; i < print_domlist; ++i)
    {
      if (domlist[i].domain || !domlist[i].str)
	continue;
      if (!enum_local_groups (domlist + i, sep_char,
			      (nss_src == NSS_SRC_FILES) ? 0x30000 : off,
			      disp_groupname, print_builtin, print_current))
	{
	  enum_groups (domlist + i, sep_char,
		       (nss_src == NSS_SRC_FILES) ? 0x30000 : off,
		       disp_groupname, print_current);
	  if (!domlist[i].domain && domlist[i].str && print_unix)
	    enum_unix_groups (domlist + i, sep_char, 0xff000000, print_unix);
	  off += id_offset;
	}
    }

  return 0;
}
@


1.62
log
@	* mkgroup.c (main): Call enum_local_groups with offset 0x30000 for local
	machine, too.
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
a36 2
#define MAX_SID_LEN 40

d133 2
a134 1
  char psid_buffer[MAX_SID_LEN];
d145 2
a146 1
  if (!AllocateAndInitializeSid (&auth, 2, 2, 0, 0, 0, 0, 0, 0, 0, &psid))
d151 1
a151 1
      FreeSid (psid);
d162 10
a171 8
	    fprintf (stderr, "%s: Invalid group name '%s'.  Skipping...\n",
		     program_invocation_short_name, gstr);
	  else if (LookupAccountNameW (machine, grp,
				       psid = (PSID) psid_buffer,
				       (sidlen = MAX_SID_LEN, &sidlen),
				       dom,
				       (dlen = MAX_DOMAIN_NAME_LEN + 1, &dlen),
				       &acc_type))
d201 1
d204 4
a207 5
	      if (LookupAccountSidW (machine, psid,
				     grp, (glen = GNLEN + 1, &glen),
				     dom,
				     (dlen = MAX_DOMAIN_NAME_LEN + 1, &dlen),
				     &acc_type)
d220 1
a220 1
  FreeSid (psid);
d283 1
a283 1
	  char psid_buffer[MAX_SID_LEN];
d285 1
a285 1
	  DWORD sid_length = MAX_SID_LEN;
d306 1
a306 1
	      sid_length = MAX_SID_LEN;
d422 1
a422 1
	  char psid_buffer[MAX_SID_LEN];
d424 1
a424 1
	  DWORD sid_length = MAX_SID_LEN;
d444 1
a444 1
	      sid_length = MAX_SID_LEN;
@


1.61
log
@	* mkgroup.c (main): Call enum_groups with offset 0x30000 for local
	machine, same as from DB.
	* mkpasswd.c (enum_unix_users): Set pw_passwd field to '*'.
	(enum_users): Ditto.
	(main): Call enum_users with offset of 0x30000 for local machine,
	same as from DB.
@
text
@d782 3
a784 2
      if (!enum_local_groups (domlist + i, sep_char, off, disp_groupname,
			      print_builtin, print_current))
@


1.60
log
@	* mkgroup.c (usage): Fix language.
	* mkpasswd.c (usage): Ditto.
@
text
@a561 1
  //BOOL in_domain;
d563 1
d644 1
a644 1
		if (cygwin_internal (CW_GETNSS_GRP_SRC) == NSS_SRC_FILES)
d650 1
a650 1
	    else if (cygwin_internal (CW_GETNSS_GRP_SRC) != NSS_SRC_FILES)
d785 3
a787 2
	  enum_groups (domlist + i, sep_char, off, disp_groupname,
		       print_current);
@


1.59
log
@	* mkgroup.c (enum_unix_groups): Always print groupname with machine
	prefix.
	(usage): Extend help output for -l option.
	(main): Drop superfluous goto and label.  Make machine prefixing for
	local machine when using -l option dependend on options in
	/etc/nsswitch.conf.
	* mkpasswd.c: Ditto.
@
text
@d484 1
a484 1
"   -l,--local [machine]    print local groups of \"machine\",\n"
d486 15
a500 15
"                           automatically adding machine prefix for local\n"
"                           machine depends on settings in /etc/nsswitch.conf)\n"
"   -L,--Local machine      ditto, but generate groupname with machine prefix\n"
"   -d,--domain [domain]    print domain groups\n"
"                           (from current domain if no domain specified)\n"
"   -c,--current            print current group\n"
"   -S,--separator char     for -l use character char as domain\\group\n"
"                           separator in groupname instead of default '%s'\n"
"   -o,--id-offset offset   change the default offset (0x10000) added to\n"
"                           gids of foreign machine accounts.\n"
"   -g,--group groupname    only return information for the specified group\n"
"                           one of -l, -d must be specified, too\n"
"   -b,--no-builtin         don't print BUILTIN groups\n"
"   -U,--unix grouplist     print UNIX groups when using -l on a UNIX Samba\n"
"                           server.  grouplist is a comma-separated list of\n"
d502 3
a504 3
"                           (enumerating large ranges can take a long time!)\n"
"   -h,--help               print this message\n"
"   -v,--version            print version information and exit\n"
@


1.58
log
@	* cygcheck.cc (dump_sysinfo): Handle Windows 10/Server 2014(?).
@
text
@d50 1
d344 2
a345 2
		  !is_builtin ? domain_name : L"",
		  !is_builtin ? sep : "",
d458 2
a459 2
		  domain_name,
		  sep,
d484 5
a488 2
"   -l,--local [machine]    print local groups of \"machine\"\n"
"                           (from local machine if no machine specified)\n"
d553 1
d629 1
a629 1
		fprintf (stderr, "%s: Malformed machine,offset string '%s'.  "
d635 1
a635 1
	if ((c == 'l' || c == 'L') && opt)
a636 1
	    char cname[1024];
d639 23
a661 7
	    /* Check if machine name is local machine.  Keep it simple. */
	    if (GetComputerNameExA (strchr (opt, '.')
				    ? ComputerNameDnsFullyQualified
				    : ComputerNameNetBIOS,
				    cname, &csize)
		&& strcasecmp (opt, cname) == 0)
	      domlist[print_domlist].str = NULL;
@


1.57
log
@Add accidentally missing patch
@
text
@a49 1
  BOOL with_dom;
d170 2
a171 2
		    mach->with_dom ? "Unix_Group" : "",
		    mach->with_dom ? sep : "",
d207 2
a208 2
			mach->with_dom ? "Unix_Group" : "",
			mach->with_dom ? sep : "",
d343 2
a344 2
		  mach->with_dom && !is_builtin ? domain_name : L"",
		  mach->with_dom && !is_builtin ? sep : "",
d457 2
a458 2
		  mach->with_dom ? domain_name : L"",
		  mach->with_dom ? sep : "",
d483 1
a483 1
"   -l,--local [machine]    print local groups\n"
a484 1
"   -L,--Local machine      ditto, but generate groupname with machine prefix\n"
d617 1
a617 1
	      goto skip;
d630 14
a643 2
	domlist[print_domlist++].with_dom = (c == 'L');
skip:
@


1.56
log
@	* mkgroup.c (usage): Move info message that this /etc/group isn't really
	required anymore more to the top of the usage output.
	* mkpasswd.c (usage): Ditto for /etc/passwd.  Drop old text from output.
@
text
@d345 1
a345 1
		  mach->with_dom || is_builtin ? sep : "",
@


1.55
log
@	* mkgroup.c (domlist_t): Drop id_offset.
	(get_dcname): Remove.
	(current_group): Remove.
	(enum_unix_groups): Simplify.  Change space to underscore in domain
	name.
	(enum_local_groups): Simplify to accommodate the fact that it's only
	called for foreign machines.
	(enum_groups): Ditto.
	(print_special_by_sid): Remove.
	(print_special_by_name): Remove.
	(usage): Align to new code.
	(fetch_primary_domain): Remove.
	(main): Use cygwin_internal CW_SETENT, CW_GETENT and CW_ENDENT method.
	Call enum_local_groups, enum_groups, and enum_unix_groups only for
	foreign machines.
	* mkpasswd.c (get_dcname): Remove.
	(current_user): Remove.
	(enum_unix_users): Simplify.  Change space to underscore in domain name.
	(enum_users): Simplify to accommodate the fact that it's only
	called for foreign machines.
	(print_special_by_sid): Remove.
	(usage): Align to new code.
	(longopts): Add -b/--no-builtin option.
	(opts): Add -b option.
	(print_special_by_name): Remove.
	(enum_std_accounts): Remove.
	(fetch_primary_domain): Remove.
	(main): Use cygwin_internal CW_SETENT, CW_GETENT and CW_ENDENT method.
	Call enum_users and enum_unix_users only for foreign machines.
	* utils.xml (mkgroup): Align documentation to new usage.
	(mkpasswd): Ditto.
@
text
@d479 3
d505 1
a505 3
"groups on domain controllers and domain member machines.\n\n"
"Don't use this command to generate a local /etc/group file, unless you\n"
"really need one.  See the Cygwin User's Guide for more information.\n"
@


1.54
log
@	* Merge in cygwin-64bit-branch.
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d24 1
a32 1
#include <dsgetdc.h>
a33 1
#include "loadlib.h"
a48 1
  DWORD id_offset;
a70 25
static PWCHAR
get_dcname (char *domain)
{
  static WCHAR server[INTERNET_MAX_HOST_NAME_LENGTH + 1];
  DWORD rc;
  WCHAR domain_name[MAX_DOMAIN_NAME_LEN + 1];
  PDOMAIN_CONTROLLER_INFOW pdci = NULL;

  if (domain)
    {
      mbstowcs (domain_name, domain, strlen (domain) + 1);
      rc = DsGetDcNameW (NULL, domain_name, NULL, NULL, 0, &pdci);
    }
  else
    rc = DsGetDcNameW (NULL, NULL, NULL, NULL, 0, &pdci);
  if (rc != ERROR_SUCCESS)
    {
      print_win_error (rc);
      return (PWCHAR) -1;
    }
  wcscpy (server, pdci->DomainControllerName);
  NetApiBufferFree (pdci);
  return server;
}

d125 1
a125 28
current_group (const char *sep, DWORD id_offset)
{
  WCHAR grp[GNLEN + 1];
  WCHAR dom[MAX_DOMAIN_NAME_LEN + 1];
  DWORD glen = GNLEN + 1;
  DWORD dlen = MAX_DOMAIN_NAME_LEN + 1;
  int gid;
  SID_NAME_USE acc_type;

  if (!curr_pgrp.psid
      || !LookupAccountSidW (NULL, curr_pgrp.psid, grp, &glen, dom, &dlen,
			     &acc_type))
    {
      print_win_error (GetLastError ());
      return;
    }
  gid = *GetSidSubAuthority (curr_pgrp.psid,
			     *GetSidSubAuthorityCount(curr_pgrp.psid) - 1);
  printf ("%ls%s%ls:%s:%" PRIu32 ":\n",
	  sep ? dom : L"",
	  sep ?: "",
	  grp,
	  put_sid (curr_pgrp.psid),
	  (unsigned int) (id_offset + gid));
}

static void
enum_unix_groups (domlist_t *dom_or_machine, const char *sep, DWORD id_offset,
a128 3
  PWCHAR servername = NULL;
  char *d_or_m = dom_or_machine ? dom_or_machine->str : NULL;
  BOOL with_dom = dom_or_machine ? dom_or_machine->with_dom : FALSE;
d138 1
a138 4
  if (!d_or_m)
    return;

  int ret = mbstowcs (machine, d_or_m, INTERNET_MAX_HOST_NAME_LENGTH + 1);
d142 1
a142 1
	       program_invocation_short_name, d_or_m);
a144 1
  servername = machine;
d164 1
a164 1
	  else if (LookupAccountNameW (servername, grp,
d171 2
a172 2
		    with_dom ? "Unix Group" : "",
		    with_dom ? sep : "",
d201 1
a201 1
	      if (LookupAccountSidW (servername, psid,
d208 2
a209 2
			with_dom ? "Unix Group" : "",
			with_dom ? sep : "",
d222 1
a222 1
enum_local_groups (BOOL domain, domlist_t *dom_or_machine, const char *sep,
a226 3
  PWCHAR servername = NULL;
  char *d_or_m = dom_or_machine ? dom_or_machine->str : NULL;
  BOOL with_dom = dom_or_machine ? dom_or_machine->with_dom : FALSE;
d234 2
a235 1
  if (domain)
d237 3
a239 14
      servername = get_dcname (d_or_m);
      if (servername == (PWCHAR) -1)
	return 1;
    }
  else if (d_or_m)
    {
      int ret = mbstowcs (machine, d_or_m, INTERNET_MAX_HOST_NAME_LENGTH + 1);
      if (ret < 1 || ret >= INTERNET_MAX_HOST_NAME_LENGTH + 1)
	{
	  fprintf (stderr, "%s: Invalid machine name '%s'.  Skipping...\n",
		   program_invocation_short_name, d_or_m);
	  return 1;
	}
      servername = machine;
d249 1
a249 1
	  rc = NetLocalGroupGetInfo (servername, gname, 0, (void *) &buffer);
d259 1
a259 1
	rc = NetLocalGroupEnum (servername, 0, (void *) &buffer,
d289 1
a289 1
	  if (!LookupAccountNameW (servername, buffer[i].lgrpi0_name, psid,
d306 1
a306 1
	      if (!LookupAccountNameW (servername, domname,
d344 2
a345 2
		  with_dom && !is_builtin ? domain_name : L"",
		  with_dom && !is_builtin ? sep : "",
d365 2
a366 2
enum_groups (BOOL domain, domlist_t *dom_or_machine, const char *sep,
	     DWORD id_offset, char *disp_groupname, int print_current)
a368 3
  PWCHAR servername = NULL;
  char *d_or_m = dom_or_machine ? dom_or_machine->str : NULL;
  BOOL with_dom = dom_or_machine ? dom_or_machine->with_dom : FALSE;
d376 2
a377 1
  if (domain)
d379 3
a381 14
      servername = get_dcname (d_or_m);
      if (servername == (PWCHAR) -1)
	return;
    }
  else if (d_or_m)
    {
      int ret = mbstowcs (machine, d_or_m, INTERNET_MAX_HOST_NAME_LENGTH + 1);
      if (ret < 1 || ret >= INTERNET_MAX_HOST_NAME_LENGTH + 1)
	{
	  fprintf (stderr, "%s: Invalid machine name '%s'.  Skipping...\n",
		   program_invocation_short_name, d_or_m);
	  return;
	}
      servername = machine;
d391 1
a391 2
	  rc = NetGroupGetInfo (servername, (LPWSTR) & gname, 2,
				(void *) &buffer);
d399 2
a400 3
	rc = NetGroupEnum (servername, 2, (void *) & buffer,
			   MAX_PREFERRED_LENGTH, &entriesread, &totalentries,
			   &resume_handle);
d426 1
a426 1
	  if (!LookupAccountNameW (servername, buffer[i].grpi2_name,
d439 1
a439 2
	      wcscpy (domname, domain || !servername
			       ? domain_name : servername);
d444 2
a445 4
	      if (!LookupAccountNameW (servername, domname,
				       psid, &sid_length,
				       domain_name, &domname_len,
				       &acc_type))
d458 2
a459 2
		  with_dom ? domain_name : L"",
		  with_dom ? sep : "",
a470 58
static void
print_special_by_sid (PSID_IDENTIFIER_AUTHORITY auth, BYTE cnt,
		      DWORD sub1, DWORD sub2, DWORD sub3, DWORD sub4,
		      DWORD sub5, DWORD sub6, DWORD sub7, DWORD sub8)
{
  WCHAR grp[GNLEN + 1], dom[MAX_DOMAIN_NAME_LEN + 1];
  DWORD glen, dlen, rid;
  PSID psid;
  SID_NAME_USE acc_type;

  if (AllocateAndInitializeSid (auth, cnt, sub1, sub2, sub3, sub4,
				sub5, sub6, sub7, sub8, &psid))
    {
      if (LookupAccountSidW (NULL, psid,
			    grp, (glen = GNLEN + 1, &glen),
			    dom, (dlen = MAX_DOMAIN_NAME_LEN + 1, &dlen),
			    &acc_type))
	{
	  if (sub8)
	    rid = sub8;
	  else if (sub7)
	    rid = sub7;
	  else if (sub6)
	    rid = sub6;
	  else if (sub5)
	    rid = sub5;
	  else if (sub4)
	    rid = sub4;
	  else if (sub3)
	    rid = sub3;
	  else if (sub2)
	    rid = sub2;
	  else
	    rid = sub1;
	  printf ("%ls:%s:%" PRIu32 ":\n", grp, put_sid (psid),
	  	  (unsigned int) rid);
	}
      FreeSid (psid);
    }
}

static void
print_special_by_name (PCWSTR name, gid_t gid)
{
  DWORD size = 256, dom_size = 256;
  PSID sid = (PSID) alloca (size);
  WCHAR dom[dom_size];
  SID_NAME_USE use;

  PWCHAR name_only = wcschr (name, L'\\');
  if (name_only)
    ++name_only;

  if (LookupAccountNameW (NULL, name, sid, &size, dom, &dom_size, &use))
    printf ("%ls:%s:%lu:\n",
	    name_only ?: name, put_sid (sid), (unsigned long) gid);
}

d477 1
a477 1
"Print /etc/group file to stdout\n"
d481 1
a481 2
"   -l,--local [machine[,offset]]\n"
"                           print local groups with gid offset offset\n"
d483 2
a484 4
"   -L,--Local [machine[,offset]]\n"
"                           ditto, but generate groupname with machine prefix\n"
"   -d,--domain [domain[,offset]]\n"
"                           print domain groups with gid offset offset\n"
a485 2
"   -D,--Domain [domain[,offset]]\n"
"                           ditto, but generate groupname with machine prefix\n"
d487 4
a490 6
"   -C,--Current            ditto, but generate groupname with machine or\n"
"                           domain prefix\n"
"   -S,--separator char     for -L, -D, -C use character char as domain\\group\n"
"                           separator in groupname instead of the default '\\'\n"
"   -o,--id-offset offset   change the default offset (10000) added to gids\n"
"                           in domain or foreign server accounts.\n"
d492 1
a492 1
"                           one of -l, -L, -d, -D must be specified, too\n"
d494 3
a496 4
"   -U,--unix grouplist     additionally print UNIX groups when using -l or -L\n"
"                           on a UNIX Samba server\n"
"                           grouplist is a comma-separated list of groupnames\n"
"                           or gid ranges (root,-25,50-100).\n"
a497 2
"   -s,--no-sids            (ignored)\n"
"   -u,--users              (ignored)\n"
d502 5
a506 2
"groups on domain controllers and domain member machines.\n"
"\n", program_invocation_short_name);
a544 23
static PPOLICY_PRIMARY_DOMAIN_INFO p_dom;

static BOOL
fetch_primary_domain ()
{
  NTSTATUS status;
  LSA_OBJECT_ATTRIBUTES oa = { 0, 0, 0, 0, 0, 0 };
  LSA_HANDLE lsa;

  if (!p_dom)
    {
      status = LsaOpenPolicy (NULL, &oa, POLICY_EXECUTE, &lsa);
      if (!NT_SUCCESS (status))
	return FALSE;
      status = LsaQueryInformationPolicy (lsa, PolicyPrimaryDomainInformation,
					  (PVOID *) ((void *) &p_dom));
      LsaClose (lsa);
      if (!NT_SUCCESS (status))
	return FALSE;
    }
  return !!p_dom->Sid;
}

d550 1
a550 1
  char *opt, *p, *ep;
a551 1
  int print_system = 0;
d554 2
a555 2
  const char *sep_char = "\\";
  DWORD id_offset = 10000, off;
d558 1
a558 1
  BOOL in_domain;
a567 1
  in_domain = fetch_primary_domain ();
d572 11
a582 11
      print_special_by_sid (&sid_nt_auth, 1, SECURITY_LOCAL_SYSTEM_RID,
			    0, 0, 0, 0, 0, 0, 0);
      if (in_domain)
	{
	  if (!enum_local_groups (TRUE, NULL, sep_char, id_offset,
				  disp_groupname, print_builtin, 0))
	    enum_groups (TRUE, NULL, sep_char, id_offset, disp_groupname, 0);
	}
      else if (!enum_local_groups (FALSE, NULL, sep_char, 0, disp_groupname,
				   print_builtin, 0))
	enum_groups (FALSE, NULL, sep_char, 0, disp_groupname, 0);
d620 1
a620 3
	if (!(domlist[print_domlist].str = opt))
	  print_system = 1;
	domlist[print_domlist].id_offset = UINT32_MAX;
d623 1
a623 4
	    if (p == opt
		|| !isdigit ((unsigned char) p[1])
		|| (domlist[print_domlist].id_offset = strtol (p + 1, &ep, 10)
		    , *ep))
d631 1
a631 1
	domlist[print_domlist++].with_dom = (c == 'D' || c == 'L');
d638 2
a639 2
	    fprintf (stderr, "%s: Only one character allowed as domain\\user "
			     "separator character.\n",
a653 2
	sep_char = NULL;
	/*FALLTHRU*/
d690 28
a717 2
  /* Get 'system' group */
  if (!disp_groupname && print_system && print_builtin && print_domlist)
d719 22
a740 3
      print_special_by_sid (&sid_nt_auth, 1, SECURITY_LOCAL_SYSTEM_RID,
			    0, 0, 0, 0, 0, 0, 0);
      print_special_by_name (L"NT SERVICE\\TrustedInstaller", -2);
d743 4
a746 1
  off = id_offset;
d749 4
a752 5
      DWORD my_off = (domlist[i].domain || domlist[i].str)
		     ? domlist[i].id_offset != UINT_MAX
		       ? domlist[i].id_offset : off : 0;
      if (!enum_local_groups (domlist[i].domain, domlist + i, sep_char,
			      my_off, disp_groupname, print_builtin, print_current))
d754 2
d757 2
a758 5
	    enum_unix_groups (domlist + i, sep_char, my_off, print_unix);
	  enum_groups (domlist[i].domain, domlist + i, sep_char, my_off,
		       disp_groupname, print_current);
	  if (my_off)
	    off += id_offset;
a761 3
  if (print_current && !got_curr_pgrp)
    current_group (sep_char, off);

@


1.53
log
@Update copyrights
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d21 1
d66 2
a67 1
    fprintf (stderr, "mkgroup (%d): [%lu] %s", line, code, buf);
d69 2
a70 1
    fprintf (stderr, "mkgroup (%d): error %lu", line, code);
d110 1
a110 1
      sprintf(t, "-%lu", *GetSidSubAuthority (psid, i));
d170 1
a170 1
  printf ("%ls%s%ls:%s:%lu:\n",
d175 1
a175 1
	  id_offset + gid);
d231 1
a231 1
	    printf ("%s%s%ls:%s:%lu:\n",
d236 1
a236 1
		    id_offset +
d238 1
a238 1
					 *GetSidSubAuthorityCount(psid) - 1));
d268 1
a268 1
		printf ("%s%s%ls:%s:%lu:\n",
d273 1
a273 1
			id_offset + start);
d294 1
a294 1
  DWORD resume_handle = 0;
d417 1
a417 1
	  printf ("%ls%s%ls:%s:%ld:\n",
d422 1
a422 1
		  gid + (is_builtin ? 0 : id_offset));
d449 1
a449 1
  DWORD resume_handle = 0;
d549 1
a549 1
	  printf ("%ls%s%ls:%s:%lu:\n",
d554 1
a554 1
		  id_offset + gid);
d597 2
a598 1
	  printf ("%ls:%s:%lu:\n", grp, put_sid (psid), rid);
d804 1
a804 1
	domlist[print_domlist].id_offset = ULONG_MAX;
d891 1
a891 1
		     ? domlist[i].id_offset != ULONG_MAX
@


1.52
log
@	* mkgroup.c (print_special_by_sid): Rename from print_special.  Change
	calls throughout.
	(print_special_by_name): New function.
	(main): Call print_special_by_name for TrustedInstaller account.
	* mkpasswd.c (print_special_by_sid): Rename from print_special.  Change
	calls throughout.
	(print_special_by_name): New function.
	(enum_std_accounts): Call print_special_by_name for TrustedInstaller
	account.
@
text
@d3 2
a4 2
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.52.2.1
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.52.2.2
log
@	Throughout, fix type problems on 32 and 64 bit.  Except:
	* ssp.c: Disable entire functionality on x86_64 for now.
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
a20 1
#include <inttypes.h>
d65 1
a65 2
    fprintf (stderr, "mkgroup (%d): [%" PRIu32 "] %s",
	     line, (unsigned int) code, buf);
d67 1
a67 2
    fprintf (stderr, "mkgroup (%d): error %" PRIu32 ,
	     line, (unsigned int) code);
d107 1
a107 1
      sprintf(t, "-%" PRIu32 , (unsigned int) *GetSidSubAuthority (psid, i));
d167 1
a167 1
  printf ("%ls%s%ls:%s:%" PRIu32 ":\n",
d172 1
a172 1
	  (unsigned int) (id_offset + gid));
d228 1
a228 1
	    printf ("%s%s%ls:%s:%" PRIu32 ":\n",
d233 1
a233 1
		    (unsigned int) (id_offset +
d235 1
a235 1
					 *GetSidSubAuthorityCount(psid) - 1)));
d265 1
a265 1
		printf ("%s%s%ls:%s:%" PRIu32 ":\n",
d270 1
a270 1
			(unsigned int) (id_offset + start));
d291 1
a291 1
  DWORD_PTR resume_handle = 0;
d414 1
a414 1
	  printf ("%ls%s%ls:%s:%" PRIu32 ":\n",
d419 1
a419 1
		  (unsigned int) (gid + (is_builtin ? 0 : id_offset)));
d446 1
a446 1
  DWORD_PTR resume_handle = 0;
d546 1
a546 1
	  printf ("%ls%s%ls:%s:%" PRIu32 ":\n",
d551 1
a551 1
		  (unsigned int) (id_offset + gid));
d594 1
a594 2
	  printf ("%ls:%s:%" PRIu32 ":\n", grp, put_sid (psid),
	  	  (unsigned int) rid);
d800 1
a800 1
	domlist[print_domlist].id_offset = UINT32_MAX;
@


1.52.2.3
log
@	* kill.cc (main): Chack pid against INT_MIN and (U)INT_MAX since pid_t
	is 4 byte on all platforms.
	* mkgroup.c (main): Check domlist[i].id_offset against UINT_MAX since
	DWORD is 4 byte on all platforms.
	* mkpasswd.c (main): Ditto.
@
text
@d891 1
a891 1
		     ? domlist[i].id_offset != UINT_MAX
@


1.51
log
@Clean up whitespace.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
d561 3
a563 3
print_special (PSID_IDENTIFIER_AUTHORITY auth, BYTE cnt,
	       DWORD sub1, DWORD sub2, DWORD sub3, DWORD sub4,
	       DWORD sub5, DWORD sub6, DWORD sub7, DWORD sub8)
d600 17
d750 2
a751 2
      print_special (&sid_nt_auth, 1, SECURITY_LOCAL_SYSTEM_RID,
		     0, 0, 0, 0, 0, 0, 0);
d877 5
a881 2
    print_special (&sid_nt_auth, 1, SECURITY_LOCAL_SYSTEM_RID,
		   0, 0, 0, 0, 0, 0, 0);
@


1.50
log
@	* mkgroup.c: Drop support for NT4 domains.
	* mkpasswd.c: Ditto.
	(psx_dir): Remove.
	(current_user): Drop support for -m option.  Use $HOME as is since it's
	a POSIX path anyway.
	(enum_users): Drop support for -m option.
	(usage): Mention -m option as ignored.
	(main): Drop support for -m option.  Mark ignored options as deprecated.
	* utils.sgml (mkpasswd): Remove description of -m option.
@
text
@d671 3
a673 3
          "Group File Generator\n"
          "Copyright (C) 1997 - %s Red Hat, Inc.\n"
          "This is free software; see the source for copying conditions.  There is NO\n"
d675 4
a678 4
          CYGWIN_VERSION_DLL_MAJOR / 1000,
          CYGWIN_VERSION_DLL_MAJOR % 1000,
          CYGWIN_VERSION_DLL_MINOR,
          strrchr (__DATE__, ' ') + 1);
@


1.49
log
@	* Align usage output, version output, as well as usage and version
	option handling to use the same style throughout all Cygwin utils.
	Throughout use program_invocation_short_name to refer to current
	process name in Cygwin executables.
	* utils.sgml: Align documentation to above change.  Add missing
	sections for getconf, ldd, and setmetamode.
	* strace.cc (proc_child): Avoid compiler warning.
@
text
@a41 2
NET_API_STATUS WINAPI (*dsgetdcname)(LPWSTR,LPWSTR,GUID*,LPWSTR,ULONG,PDOMAIN_CONTROLLER_INFOW*);

a69 8
static void
load_dsgetdcname ()
{
  HANDLE h = LoadLibrary ("netapi32.dll");
  if (h)
    dsgetdcname = (void *) GetProcAddress (h, "DsGetDcNameW");
}

a74 1
  PWCHAR servername;
d78 1
a78 1
  if (dsgetdcname)
d80 2
a81 14
      if (domain)
	{
	  mbstowcs (domain_name, domain, strlen (domain) + 1);
	  rc = dsgetdcname (NULL, domain_name, NULL, NULL, 0, &pdci);
	}
      else
	rc = dsgetdcname (NULL, NULL, NULL, NULL, 0, &pdci);
      if (rc != ERROR_SUCCESS)
	{
	  print_win_error (rc);
	  return (PWCHAR) -1;
	}
      wcscpy (server, pdci->DomainControllerName);
      NetApiBufferFree (pdci);
d84 2
d87 2
a88 15
      rc = NetGetDCName (NULL, NULL, (void *) &servername);
      if (rc == ERROR_SUCCESS && domain)
	{
	  LPWSTR server = servername;
	  mbstowcs (domain_name, domain, strlen (domain) + 1);
	  rc = NetGetDCName (server, domain_name, (void *) &servername);
	  NetApiBufferFree (server);
	}
      if (rc != ERROR_SUCCESS)
	{
	  print_win_error(rc);
	  return (PWCHAR) -1;
	}
      wcscpy (server, servername);
      NetApiBufferFree ((PVOID) servername);
d90 2
a727 1
  load_dsgetdcname ();
@


1.48
log
@	* loadlib.h: New header implementing safe LoadLibrary calls.
	Include throughout files using LoadLibrary function.
	* cygcheck.cc (dump_sysinfo): Retrieve kernel32.dll handle via
	GetModuleHandle, rather than using LoadLibrary.
	* cygpath.cc (get_long_name): Ditto.
	(do_sysfolders): Append .dll suffix in LoadLibrary call.
	* ldh.cc (WinMain): Use LoadLibraryExW with DONT_RESOLVE_DLL_REFERENCES
	to avoid loading malicious library code.
	* locale.cc (print_locale_with_codeset): Change way to retrieve
	kernel32.dll path.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010 Red Hat, Inc.
d13 1
d25 1
a38 4
static const char version[] = "$Revision: 1.10 $";

extern char *__progname __declspec(dllimport);

d231 1
a231 1
	       __progname, d_or_m);
d253 1
a253 1
		     __progname, gstr);
d283 2
a284 1
			       "Skipping...\n", __progname, gstr);
d339 1
a339 1
		   __progname, d_or_m);
d494 1
a494 1
		   __progname, d_or_m);
d636 2
a637 1
"Usage: mkgroup [OPTION]...\n"
d641 1
d673 2
a674 1
"groups on domain controllers and domain member machines.\n");
d693 1
a693 1
  {"version", no_argument, NULL, 'v'},
d697 1
a697 1
static char opts[] = "bcCd::D::g:hl::L::o:sS:uU:v";
d702 9
a710 18
  const char *v = strchr (version, ':');
  int len;
  if (!v)
    {
      v = "?";
      len = 1;
    }
  else
    {
      v += 2;
      len = strchr (v, ' ') - v;
    }
  printf ("\
mkgroup (cygwin) %.*s\n\
group File Generator\n\
Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 Red Hat, Inc.\n\
Compiled on %s\n\
", len, v, __DATE__);
d791 2
a792 1
			     "domains and machines.\n", __progname);
d809 2
a810 1
		       __progname, domlist[i].domain ? "domain" : "machine",
d825 1
a825 1
			 "Skipping...\n", __progname, opt);
d838 2
a839 1
			     "separator character.\n", __progname);
d845 1
a845 1
			     "character.\n", __progname);
d874 1
a874 1
      case 'v':
d878 1
a878 1
	fprintf (stderr, "Try '%s --help' for more information.\n", argv[0]);
@


1.47
log
@* mkpasswd.c: Properly define __progname as __declspec(dllimport).
* mkgroup.c: Ditto.
@
text
@d4 1
a4 1
   2007, 2008, 2009 Red Hat, Inc.
d31 1
@


1.46
log
@	* mkgroup.c (enum_local_groups): Avoid error message if given group
	name isn't found and return 0 to allow searching to proceed.  Always
	return 0 or 1, not -1.
	(enum_groups): Avoid error message if given group name isn't found.
	* mkpasswd.c (enum_users): Ditto.
@
text
@d38 1
a38 1
extern char *__progname;
@


1.45
log
@	* cygpath.cc (main): Only setlocale for LC_CTYPE category.  Fallback
	to UTF-8 if locale is "C".
	* ldd.cc (main): Ditto.
	* mkgroup.c (main): Ditto.
	* mkpasswd.c (main): Ditto.
	* passwd.c (main): Ditto.
@
text
@d349 1
a349 1
      if (disp_groupname != NULL)
d355 5
d461 1
a461 1
  /* Return -1 if the single group we're looking for has been found here to
d464 1
a464 1
  return disp_groupname && entriesread ? -1 : 0;
d510 4
@


1.44
log
@	* mkpasswd.c (current_user): Don't use HOMEDRIVE/HOMEPATH to generate
	user's homedir.

	* mkgroup.c: Accommodate ctype changes.
	* mkpasswd.c: Ditto.
	* setfacl.c: Ditto.
	* ssp.c: Ditto.
@
text
@d17 1
d753 4
@


1.43
log
@	* mkgroup.c (enum_local_groups): Don't skip printing groups when
	print_current is set and group SID is not curr_pgrp.
	(enum_groups): Ditto.
	(main): Fix condition when SYSTEM group gets printed.
	* mkpasswd.c (enum_users): Don't skip printing users when print_current
	is set and user SID is not curr_user.
	(main): Allow printing standard accounts even when print_current is set.
@
text
@d4 1
a4 1
   2007, 2008 Red Hat, Inc.
d247 1
a247 1
      if (!isdigit (gstr[0]) && gstr[0] != '-')
d279 1
a279 1
	  else if (*p++ != '-' || !isdigit (*p)
d810 1
a810 1
		|| !isdigit (p[1])
@


1.42
log
@	* mkgroup.c (enum_local_groups): Use NetLocalGroupGetInfo to find out
	if a group exists, rather than just allocating a buffer and going ahead.
@
text
@d438 1
a438 2
	  else
	    continue;
d567 1
a567 2
	  else
	    continue;
d881 1
a881 1
  if (!disp_groupname && print_system && print_builtin && !print_current)
@


1.41
log
@	* mkgroup.c (enum_local_groups): Call print_win_error with GetLastError
	as argument when LookupAccountXXX failed.
	(enum_groups): Ditto.
@
text
@d351 3
a353 4
	  rc = NetApiBufferAllocate (sizeof (LOCALGROUP_INFO_0),
				     (void *) &buffer);
	  buffer[0].lgrpi0_name = gname;
	  entriesread = 1;
@


1.40
log
@	* mkgroup.c (enum_local_groups): Return failure if looking for a single
	group succeeded.  Add comment.
@
text
@d391 1
a391 1
	      print_win_error (rc);
d409 1
a409 1
		  print_win_error (rc);
d541 1
a541 1
	      print_win_error (rc);
d560 1
a560 1
		  print_win_error (rc);
@


1.39
log
@	* mkgroup.c (main): Keep correctly track of optional arguments.
	* mkpasswd.c (main): Ditto.
@
text
@d457 4
a460 1
  return 0;
@


1.38
log
@	* mkgroup.c (main): Always unset environment variable POSIXLY_CORRECT.
	Keep track of optional argumnts and fix up optind afterwards.
	* mkpasswd.c (main): Ditto.
@
text
@d789 1
a789 1
	if (opt == argv[optind])
@


1.37
log
@* Makefile.in (ALL_LDFLAGS): Add --enable-auto-import option to quiet ld
warnings.
* mkgroup.c: Change all global variables and most functions to static.
(enum_local_groups): Add a print_current parameter to control whether entries
for everything should be printed or just the current user.
(enum_groups): Ditto.
(main): Move call fetch_current_pgrp_sid earlier to avoid a NULL deference when
no command line arguments are specified.  Accommodate argument changes to above
functions.  Avoid printing SYSTEM account when print_current is specified.
Issue error when extra stuff is found on the command line.
* mkpasswd.c: Change all global variables and most functions to static.
(enum_users): Add a print_current parameter to control whether entries for
everything should be printed or just the current user.
(main): Move call fetch_current_user_sid earlier to avoid a NULL deference when
no command line arguments are specified.  Accommodate argument change to above
function.  Avoid printing standard accounts when print_current is specified.
Issue error when extra stuff is found on the command line.
@
text
@d747 1
d772 1
d789 2
d871 1
@


1.36
log
@	* mkgroup.c (fetch_current_pgrp_sid): New function to fetch primary
	group SID from user token.
	(current_group): Move up in file.  Move fetching primary group SID to
	fetch_current_pgrp_sid.
	(enum_local_groups): Check if current SID is the same as current user's
	primary group SID.
	(enum_groups): Ditto.
	(main): Call fetch_current_pgrp_sid before enumerating groups.  Call
	current_group only if current group hasn't been enumerated already.
	* mkpasswd.c (fetch_current_user_sid): New function to fetch current
	user SID from user token.
	(current_user): Move fetching current user SID to
	fetch_current_user_sid.
	(enum_users): Check if current SID is the same as current user's SID.
	(main): Call fetch_current_user_sid before enumerating users.  Call
	current_user only if current user hasn't been enumerated already.
@
text
@d56 1
a56 1
void
d72 1
a72 1
void
d127 1
a127 1
char *
d161 2
a162 2
sidbuf curr_pgrp;
BOOL got_curr_pgrp = FALSE;
d164 1
a164 1
void
d180 1
a180 1
void
d207 1
a207 1
void
d310 1
a310 1
int
d312 2
a313 1
		   DWORD id_offset, char *disp_groupname, int print_builtin)
d336 1
a336 1
      	{
d356 1
a356 1
      else 
d395 15
a409 15
          else if (acc_type == SidTypeDomain)
            {
              WCHAR domname[MAX_DOMAIN_NAME_LEN + GNLEN + 2];

              wcscpy (domname, domain_name);
              wcscat (domname, L"\\");
              wcscat (domname, buffer[i].lgrpi0_name);
              sid_length = MAX_SID_LEN;
              domname_len = MAX_DOMAIN_NAME_LEN + 1;
              if (!LookupAccountNameW (servername, domname,
                                       psid, &sid_length,
                                       domain_name, &domname_len,
                                       &acc_type))
                {
                  print_win_error (rc);
d411 3
a413 3
                  continue;
                }
            }
d425 1
a425 1
	        goto skip_group;
d435 3
a437 1
	  if (EqualSid (curr_pgrp.psid, psid))
d439 2
d460 1
a460 1
void
d462 1
a462 1
	     DWORD id_offset, char *disp_groupname)
d485 1
a485 1
      	{
d504 1
a504 1
      else 
d562 3
a564 1
	  if (EqualSid (curr_pgrp.psid, psid))
d566 2
d582 1
a582 1
void
d593 1
a593 1
  				sub5, sub6, sub7, sub8, &psid))
d617 1
a617 1
        }
d622 1
a622 1
int
d684 1
a684 1
char opts[] = "bcCd::D::g:hl::L::o:sS:uU:v";
d686 1
a686 1
void
d724 1
a724 1
					  (PVOID *) &p_dom);
d753 2
d762 2
a763 2
				  disp_groupname, print_builtin))
	    enum_groups (TRUE, NULL, sep_char, id_offset, disp_groupname);
d766 2
a767 2
				   print_builtin))
	enum_groups (FALSE, NULL, sep_char, 0, disp_groupname);
d806 2
a807 2
	    	|| !isdigit (p[1])
	    	|| (domlist[print_domlist].id_offset = strtol (p + 1, &ep, 10)
d812 1
a812 1
	      	break;
d833 1
a833 1
        break;
d835 1
a835 1
      	print_unix = optarg;
d838 1
a838 1
      	sep_char = NULL;
d847 1
a847 1
      	print_builtin = 0;
d867 8
d876 1
a876 1
  if (!disp_groupname && print_system && print_builtin)
a879 2
  fetch_current_pgrp_sid ();

d887 1
a887 1
			      my_off, disp_groupname, print_builtin))
d892 1
a892 1
		       disp_groupname);
@


1.35
log
@	* mkgroup.c (main): Fix test for duplicate domain/machine request.
	* mkpasswd.c (main): Ditto.
@
text
@d156 51
d434 2
a435 1

a436 1

d557 2
a612 33
void
current_group (const char *sep, DWORD id_offset)
{
  DWORD len;
  HANDLE ptok;
  struct {
    PSID psid;
    char buffer[MAX_SID_LEN];
  } tg;
  WCHAR grp[GNLEN + 1];
  WCHAR dom[MAX_DOMAIN_NAME_LEN + 1];
  DWORD glen = GNLEN + 1;
  DWORD dlen = MAX_DOMAIN_NAME_LEN + 1;
  int gid;
  SID_NAME_USE acc_type;

  if (!OpenProcessToken (GetCurrentProcess (), TOKEN_QUERY, &ptok)
      || !GetTokenInformation (ptok, TokenPrimaryGroup, &tg, sizeof tg, &len)
      || !CloseHandle (ptok)
      || !LookupAccountSidW (NULL, tg.psid, grp, &glen, dom, &dlen, &acc_type))
    {
      print_win_error (GetLastError ());
      return;
    }
  gid = *GetSidSubAuthority (tg.psid, *GetSidSubAuthorityCount(tg.psid) - 1);
  printf ("%ls%s%ls:%s:%lu:\n",
	  sep ? dom : L"",
	  sep ?: "",
	  grp,
	  put_sid (tg.psid),
	  id_offset + gid);
}

d861 2
d881 1
a881 1
  if (print_current)
@


1.34
log
@	* mkgroup.c: Rework to allow per-domain/per-machine id_offset.
	Add -b option to skip builtin groups.
	(main): Simplify code.
	* mkpasswd.c: Rework to allow per-domain/per-machine id_offset.
	(main): Simplify code.
	* utils.sgml: Explain changed mkgroup/mkpasswd -d/-D/-l/-L options.
	Add mkgroup -b option.
@
text
@d753 1
d757 12
a768 3
	  if ((!domlist[i].str && !opt)
	      || (domlist[i].str && opt && !strcmp (domlist[i].str, opt)))
	    goto skip;
a784 1
	domlist[print_domlist].domain = (c == 'd' || c == 'D');
d786 1
a786 1
  skip:
@


1.33
log
@	* mkgroup.c: Consolidate variable names.
	(enum_unix_groups): New function.
	(print_special): Use LookupAccountSidW instead of LookupAccountSidA.
	(current_group): Ditto.
	(usage): Add -U option.
	(longopts): Add --unix option.
	(opts): Add -U option.
	(main): Handle -U option.  Call enum_unix_groups if set.
	* mkpasswd.c: Consolidate variable names.
	(current_user): Use LookupAccountSidW instead of LookupAccountSidA.
	(enum_unix_users): New function.
	(usage): Add -U option.
	(longopts): Add --unix option.
	(opts): Add -U option.
	(main): Handle -U option.  Call enum_unix_groups if set.
	* utils.sgml: Add -U option text to mkgroup and mkpasswd description.
@
text
@d51 2
d157 1
a157 1
enum_unix_groups (domlist_t *dom_or_machine, const char *sep, int id_offset,
d261 1
a261 1
		   int id_offset, char *disp_groupname)
d372 2
d375 1
a375 1
	      if (servername && builtin_sid_cnt)
d387 2
a388 2
		  with_dom ? domain_name : L"",
		  with_dom ? sep : "",
d406 1
a406 1
	     int id_offset, char *disp_groupname)
d506 1
a506 1
	  printf ("%ls%s%ls:%s:%u:\n",
d511 1
a511 1
		  gid + id_offset);
d561 1
a561 1
current_group (const char *sep, int id_offset)
d585 1
a585 1
  printf ("%ls%s%ls:%s:%u:\n",
d590 1
a590 1
	  gid + id_offset);
d601 10
a610 6
"   -l,--local [machine]    print local groups (from local machine if no\n"
"                           machine specified)\n"
"   -L,--Local [machine]    ditto, but generate groupname with machine prefix\n"
"   -d,--domain [domain]    print domain groups (from current domain if no\n"
"                           domain specified)\n"
"   -D,--Domain [domain]    ditto, but generate groupname with machine prefix\n"
d620 1
d637 1
d655 1
a655 1
char opts[] = "cCd::D::g:hl::L::o:sS:uU:v";
d706 3
a708 5
  int print_local = 0;
  domlist_t locals[16];
  int print_domain = 0;
  domlist_t domains[16];
  char *opt;
d711 1
d714 2
a715 2
  int id_offset = 10000;
  int c, i, off;
d731 1
a731 1
				  disp_groupname))
d734 2
a735 1
      else if (!enum_local_groups (FALSE, NULL, sep_char, 0, disp_groupname))
d743 2
d747 1
a747 1
	if (print_local >= 16)
d749 2
a750 2
	    fprintf (stderr, "%s: Can not enumerate from more than 16 "
			     "servers.\n", __progname);
d755 5
a759 5
	for (i = 0; i < print_local; ++i)
	  if ((!locals[i].str && !opt)
	      || (locals[i].str && opt && !strcmp (locals[i].str, opt)))
	    goto skip_local;
	if (!(locals[print_local].str = opt))
d761 2
a762 6
	locals[print_local++].with_dom = c == 'L';
  skip_local:
	break;
      case 'd':
      case 'D':
	if (print_domain >= 16)
d764 10
a773 3
	    fprintf (stderr, "%s: Can not enumerate from more than 16 "
			     "domains.\n", __progname);
	    return 1;
d775 3
a777 10
	opt = optarg ?:
	      argv[optind] && argv[optind][0] != '-' ? argv[optind] : NULL;
	for (i = 0; i < print_domain; ++i)
	  if ((!domains[i].str && !opt)
	      || (domains[i].str && opt && !strcmp (domains[i].str, opt)))
	    goto skip_domain;
	if (!(domains[print_domain].str = opt))
	  print_system = 1;
	domains[print_domain++].with_dom = c == 'D';
  skip_domain:
d806 3
a826 3
  if (optind < argc - 1)
    usage (stdout);

d828 1
a828 1
  if (!disp_groupname && print_system)
d832 2
a833 2
  off = 1;
  for (i = 0; i < print_local; ++i)
d835 12
a846 11
      if (locals[i].str)
	{
	  if (!enum_local_groups (FALSE, locals + i, sep_char,
				  id_offset * off, disp_groupname))
	    {
	      if (print_unix)
	      	enum_unix_groups (locals + i, sep_char, id_offset * off,
				  print_unix);
	      enum_groups (FALSE, locals + i, sep_char, id_offset * off++,
			   disp_groupname);
	    }
a847 11
      else if (!enum_local_groups (FALSE, locals + i, sep_char, 0,
				   disp_groupname))
	enum_groups (FALSE, locals + i, sep_char, 0, disp_groupname);
    }

  for (i = 0; i < print_domain; ++i)
    {
      if (!enum_local_groups (TRUE, domains + i, sep_char, id_offset * off,
			      disp_groupname))
	enum_groups (TRUE, domains + i, sep_char, id_offset * off++,
		     disp_groupname);
d851 1
a851 1
    current_group (sep_char, id_offset);
@


1.32
log
@	* mkgroup.c (enum_groups): Create full qualified groupname using
	domain or servername, depending on printing domain or machine accounts.
	* mkpasswd.c (enum_users): Ditto for users.
@
text
@d16 1
d126 1
a126 1
put_sid (PSID sid)
d133 1
a133 1
  sprintf(t, "%u", GetSidIdentifierAuthority (sid)->Value[5]);
d135 1
a135 1
  for (i = 0; i < *GetSidSubAuthorityCount (sid); ++i)
d137 1
a137 1
      sprintf(t, "-%lu", *GetSidSubAuthority (sid, i));
d154 103
d521 4
a524 4
  char name[UNLEN + 1], dom[MAX_DOMAIN_NAME_LEN + 1];
  DWORD len, len2, rid;
  PSID sid;
  SID_NAME_USE use;
d527 1
a527 1
  				sub5, sub6, sub7, sub8, &sid))
d529 4
a532 4
      if (LookupAccountSid (NULL, sid,
			    name, (len = UNLEN + 1, &len),
			    dom, (len2 = MAX_DOMAIN_NAME_LEN + 1, &len),
			    &use))
d550 1
a550 1
	  printf ("%s:%s:%lu:\n", name, put_sid (sid), rid);
d552 1
a552 1
      FreeSid (sid);
d565 2
a566 2
  char grp[GNLEN + 1];
  char dom[MAX_DOMAIN_NAME_LEN + 1];
d575 1
a575 1
      || !LookupAccountSidA (NULL, tg.psid, grp, &glen, dom, &dlen, &acc_type))
d581 2
a582 2
  printf ("%s%s%s:%s:%u:\n",
	  sep ? dom : "",
d612 5
d640 1
d645 1
a645 1
char opts[] = "cCd::D::g:hl::L::o:sS:uv";
d703 1
d786 3
d831 7
a837 2
	    enum_groups (FALSE, locals + i, sep_char, id_offset * off++,
			 disp_groupname);
@


1.31
log
@	* mkgroup.c (main): Remove special root group code.  Only print
	SYSTEM group in case of printing local machine or local domain groups.
@
text
@d382 2
a383 1
	      wcscpy (domname, domain_name);
@


1.30
log
@	* Makefile.in (cygcheck.exe): Link against ntdll.
	* bloda.cc: Use statically linked functions throughout.
	* cygpath.cc: Drop 9x considerations.
	* mkgroup.c: Revamp.  Redefine -l and -d options to take optional
	machine and domain parameters.  Redefine -c to work always, using
	token information.  Add -L, -D, -C to create unique groupnames in
	domain\group syntax.  Add -S option to define domain\group separator
	char.  Ignore -u and -s options.
	* mkpasswd.c: Revamp.  Redefine -l and -d options to take optional
	machine and domain parameters.  Redefine -c to work always, using
	token information.  Add -L, -D, -C to create unique usernames in
	domain\user syntax.  Add -S option to define domain\user separator
	char.  Ignore -g and -s options.  Prefer to take homedir from $HOME
	over $HOMEDRIVE/$HOMEPATH.
	* path.cc (oopts): Add "acl", "noacl", "posix=0" and "posix=1" options.
	(getmntent): Accomodate throughout.
	* ps.cc: Fix copyright dates.
	* utils.sgml: Fix text for mkgroup and mkpasswd.
@
text
@d591 1
a595 1
  int isRoot = 0;
d635 2
a636 1
	locals[print_local].str = opt;
d654 2
a655 1
	domains[print_domain].str = opt;
a688 1
	isRoot = !strcmp(disp_groupname, "root");
d705 1
a705 1
  if (!disp_groupname && (print_local > 0 || print_domain > 0))
d710 1
a710 1
  if (isRoot)
d712 10
a721 4
      /* Very special feature for the oncoming future:
	 Create a "root" group being actually the local Administrators group.
         Printing root disables printing any other "real" local group. */
      printf ("root:S-1-5-32-544:0:\n");
a722 14
  else
    for (i = 0; i < print_local; ++i)
      {
	if (locals[i].str)
	  {
	    if (!enum_local_groups (FALSE, locals + i, sep_char,
				    id_offset * off, disp_groupname))
	      enum_groups (FALSE, locals + i, sep_char, id_offset * off++,
			   disp_groupname);
	  }
	else if (!enum_local_groups (FALSE, locals + i, sep_char, 0,
				     disp_groupname))
	  enum_groups (FALSE, locals + i, sep_char, 0, disp_groupname);
      }
@


1.29
log
@	* mkgroup.c: Use statically linked functions throughout, except for
	DsGetDcNameW.  Reformat.  Convert to use WCHAR for names throughout.
	Use defines instead of constants throughout.
	(MAX_SID_LEN): Define.
	(load_netapi): Just load DsGetDcNameW pointer.
	(psx_dir): Remove.
	(uni2ansi): Remove.
	(enum_local_users): Take server name and use in Net... call.
	(DBGSID): Define datastructure.
	(MAX_BUILTIN_SIDS): Define.
	(builtin_sid_list): Define global sid list.
	(builtin_sid_cnt): Define counter for global sid list.
	(enum_local_groups): Take server name and use in Net... and Lookup...
	calls.  Take offset argument.  Use MAX_PREFERRED_LENGTH in call to
	NetLocalGroupEnum.  Check for duplicate builtin groups.
	(enum_users): Take server name and use in Net... call.
	(usage): Change text slightly.
	(print_version): Fix copyright.
	(main): Call enum_local_groups for domains as well.
	* mkpasswd.c: Use statically linked functions throughout, except for
	DsGetDcNameW.  Reformat.  Convert to use WCHAR for names throughout.
	Use defines instead of constants throughout.
	(MAX_SID_LEN): Define.
	(load_netapi): Just load DsGetDcNameW pointer.
	(uni2ansi): Use wcstombs.
	(current_user): Replace "unused_by_nt/2000/xp" by
	just "unused".
	(enum_users): Ditto.
	(print_version): Fix copyright.
@
text
@d12 1
d17 5
d23 1
a23 4
#include <sys/cygwin.h>
#include <getopt.h>
#include <lmaccess.h>
#include <lmapibuf.h>
d27 1
d32 2
d36 1
a36 13
#define MAX_SID_LEN 40

typedef struct {
  LPWSTR DomainControllerName;
  LPWSTR DomainControllerAddress;
  ULONG  DomainControllerAddressType;
  GUID   DomainGuid;
  LPWSTR DomainName;
  LPWSTR DnsForestName;
  ULONG  Flags;
  LPWSTR DcSiteName;
  LPWSTR ClientSiteName;
} *PDOMAIN_CONTROLLER_INFOW;
d47 22
d70 1
a70 1
load_netapi ()
d77 47
a141 42
void
_print_win_error(DWORD code, int line)
{
  char buf[4096];

  if (FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM
      | FORMAT_MESSAGE_IGNORE_INSERTS,
      NULL,
      code,
      MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),
      (LPTSTR) buf, sizeof (buf), NULL))
    fprintf (stderr, "mkgroup (%d): [%lu] %s", line, code, buf);
  else
    fprintf (stderr, "mkgroup (%d): error %lu", line, code);
}

void
enum_local_users (LPWSTR servername, LPWSTR groupname)
{
  LOCALGROUP_MEMBERS_INFO_1 *buf1;
  DWORD entries = 0;
  DWORD total = 0;
  DWORD reshdl = 0;

  if (!NetLocalGroupGetMembers (servername, groupname, 1, (void *) &buf1,
				MAX_PREFERRED_LENGTH,
				&entries, &total, &reshdl))
    {
      unsigned i, first = 1;

      for (i = 0; i < entries; ++i)
	if (buf1[i].lgrmi1_sidusage == SidTypeUser)
	  {
	    if (!first)
	      printf (",");
	    first = 0;
	    printf ("%ls", buf1[i].lgrmi1_name);
	  }
      NetApiBufferFree (buf1);
    }
}

d154 1
a154 1
enum_local_groups (LPWSTR servername, int print_sids, int print_users,
d157 4
d165 1
a165 1
  WCHAR uni_name[GNLEN + 1];
d168 18
d192 1
a192 1
	  mbstowcs (uni_name, disp_groupname, GNLEN + 1);
d195 1
a195 1
	  buffer[0].lgrpi0_name = uni_name;
d205 2
a206 2
	  print_win_error(rc);
	  exit (1);
d213 2
a214 2
	  print_win_error(rc);
	  exit (1);
d233 1
a233 1
	      print_win_error(rc);
d251 1
a251 1
                  print_win_error(rc);
d278 6
a283 6
	  printf ("%ls:%s:%ld:", buffer[i].lgrpi0_name,
                                print_sids ? put_sid (psid) : "",
                                gid + (is_builtin ? 0 : id_offset));
	  if (print_users)
	    enum_local_users (servername, buffer[i].lgrpi0_name);
	  printf ("\n");
d297 2
a298 26
enum_users (LPWSTR servername, LPWSTR groupname)
{
  GROUP_USERS_INFO_0 *buf1;
  DWORD entries = 0;
  DWORD total = 0;
  DWORD reshdl = 0;

  if (!NetGroupGetUsers (servername, groupname, 0, (void *) &buf1,
			 MAX_PREFERRED_LENGTH, &entries, &total, &reshdl))
    {
      unsigned i, first = 1;

      for (i = 0; i < entries; ++i)
	{
	  if (!first)
	    printf (",");
	  first = 0;
	  printf ("%ls", buf1[i].grui0_name);
	}
      NetApiBufferFree (buf1);
    }
}

void
enum_groups (LPWSTR servername, int print_sids, int print_users, int id_offset,
	     char *disp_groupname)
d300 4
d308 1
a308 1
  WCHAR uni_name[GNLEN + 1];
d311 18
d335 2
a336 2
	  mbstowcs (uni_name, disp_groupname, GNLEN + 1);
	  rc = NetGroupGetInfo (servername, (LPWSTR) & uni_name, 2,
d347 2
a348 2
	  print_win_error(rc);
	  exit (1);
d355 2
a356 2
	  print_win_error(rc);
	  exit (1);
d369 12
a380 14
          if (print_sids)
            {
              if (!LookupAccountNameW (servername, buffer[i].grpi2_name,
                                       psid, &sid_length,
                                       domain_name, &domname_len,
			               &acc_type))
                {
                  print_win_error(rc);
		  fprintf(stderr, " (%ls)\n", buffer[i].grpi2_name);
                  continue;
                }
              else if (acc_type == SidTypeDomain)
                {
                  WCHAR domname[MAX_DOMAIN_NAME_LEN + GNLEN + 2];
d382 21
a402 22
                  wcscpy (domname, domain_name);
                  wcscat (domname, L"\\");
                  wcscat (domname, buffer[i].grpi2_name);
                  sid_length = MAX_SID_LEN;
                  domname_len = MAX_DOMAIN_NAME_LEN + 1;
                  if (!LookupAccountNameW (servername, domname,
					   psid, &sid_length,
					   domain_name, &domname_len,
					   &acc_type))
                    {
                      print_win_error(rc);
		      fprintf(stderr, " (%ls)\n", domname);
                      continue;
                    }
                }
            }
	  printf ("%ls:%s:%u:", buffer[i].grpi2_name,
                               print_sids ? put_sid (psid) : "",
                               gid + id_offset);
	  if (print_users)
	    enum_users (servername, buffer[i].grpi2_name);
	  printf ("\n");
d412 1
a412 2
print_special (int print_sids,
	       PSID_IDENTIFIER_AUTHORITY auth, BYTE cnt,
d445 1
a445 3
	  printf ("%s:%s:%lu:\n", name,
				 print_sids ? put_sid (sid) : "",
				 rid);
d452 1
a452 1
current_group (int print_sids, int print_users, int id_offset)
a453 1
  char name[UNLEN + 1], *envname, *envdomain;
a455 1
  int errpos = 0;
d460 11
a470 16


  if ((!GetUserName (name, (len = sizeof (name), &len)) && (errpos = __LINE__))
      || !name[0]
      || !(envname = getenv("USERNAME"))
      || strcasecmp (envname, name)
      || (!GetComputerName (name, (len = sizeof (name), &len))
	  && (errpos = __LINE__))
      || !(envdomain = getenv("USERDOMAIN"))
      || !envdomain[0]
      || !strcasecmp (envdomain, name)
      || (!OpenProcessToken (GetCurrentProcess (), TOKEN_QUERY, &ptok)
	  && (errpos = __LINE__))
      || (!GetTokenInformation (ptok, TokenPrimaryGroup, &tg, sizeof tg, &len)
	  && (errpos = __LINE__))
      || (!CloseHandle (ptok) && (errpos = __LINE__)))
d472 1
a472 4
      if (errpos)
	{
	  print_win_error (GetLastError ());
	}
d475 7
a481 8

  int gid = *GetSidSubAuthority (tg.psid, *GetSidSubAuthorityCount(tg.psid) - 1);

  printf ("mkgroup_l_d:%s:%u:", print_sids ? put_sid (tg.psid) : "",
                                gid + id_offset);
  if (print_users)
    printf("%s", envname);
  printf ("\n");
d485 1
a485 1
usage (FILE * stream, int isNT)
d487 27
a513 19
  fprintf (stream, "Usage: mkgroup [OPTION]... [domain]...\n"
	           "Print /etc/group file to stdout\n\n"
	           "Options:\n");
  if (isNT)
    fprintf (stream, "   -l,--local             print machine local group information\n"
	             "   -c,--current           print current group, if a domain account\n"
		     "   -d,--domain            print domain group information (from current\n"
	             "                          domain if no domains specified)\n"
		     "   -o,--id-offset offset  change the default offset (10000) added to gids\n"
		     "                          in domain accounts.\n"
		     "   -s,--no-sids           don't print SIDs in pwd field\n"
		     "                          (this affects ntsec)\n"
	             "   -u,--users             print user list in gr_mem field\n"
                     "   -g,--group groupname   only return information for the specified group\n");
  fprintf (stream, "   -h,--help              print this message\n"
	           "   -v,--version           print version information and exit\n\n");
  if (isNT)
    fprintf (stream, "One of '-l' or '-d' must be given.\n");

a517 1
  {"local", no_argument, NULL, 'l'},
d519 7
a525 1
  {"domain", no_argument, NULL, 'd'},
d528 1
a529 2
  {"group", required_argument, NULL, 'g'},
  {"help", no_argument, NULL, 'h'},
d534 1
a534 1
char opts[] = "lcdo:sug:hv";
d559 23
a584 3
  LPWSTR servername;
  DWORD rc = ERROR_SUCCESS;
  WCHAR domain_name[MAX_DOMAIN_NAME_LEN + 1];
d586 4
d591 1
a591 4
  int print_domain = 0;
  int print_sids = 1;
  int print_users = 0;
  int domain_specified = 0;
d593 1
d596 1
a596 2
  int isNT;
  int i;
d598 2
a599 11
  char dom[MAX_DOMAIN_NAME_LEN + 1];
  DWORD len, len2;
  PSID psid = NULL;
  SID_NAME_USE use;

  LSA_OBJECT_ATTRIBUTES oa = { 0, 0, 0, 0, 0, 0 };
  LSA_HANDLE lsa = INVALID_HANDLE_VALUE;
  NTSTATUS ret;
  PPOLICY_PRIMARY_DOMAIN_INFO pdi;

  isNT = (GetVersion () < 0x80000000);
d601 3
a603 3
  if (isNT && argc == 1)
    return usage(stderr, isNT);
  else
d605 3
a607 2
      while ((i = getopt_long (argc, argv, opts, longopts, NULL)) != EOF)
	switch (i)
d609 3
a611 31
	case 'l':
	  print_local = 1;
	  break;
	case 'c':
	  print_current = 1;
	  break;
	case 'd':
	  print_domain = 1;
	  break;
	case 'o':
	  id_offset = strtol (optarg, NULL, 10);
	  break;
	case 's':
	  print_sids = 0;
	  break;
	case 'u':
	  print_users = 1;
	  break;
	case 'g':
	  disp_groupname = optarg;
	  isRoot = !strcmp(disp_groupname, "root");
	  break;
	case 'h':
	  usage (stdout, isNT);
	  return 0;
	case 'v':
	  print_version ();
	  return 0;
	default:
	  fprintf (stderr, "Try '%s --help' for more information.\n", argv[0]);
	  return 1;
d613 2
a614 6
    }

  /* This takes Windows 9x/ME into account. */
  if (!isNT)
    {
      printf ("all::%ld:\n", DOMAIN_ALIAS_RID_ADMINS);
d618 2
a619 90
  if (!print_local && !print_domain)
    {
      fprintf (stderr, "%s: Specify one of '-l' or '-d'\n", argv[0]);
      return 1;
    }
  if (optind < argc)
    {
      if (!print_domain)
        {
	  fprintf (stderr, "%s: A domain name is only accepted "
		   "when '-d' is given.\n", argv[0]);
	  return 1;
	}
      domain_specified = 1;
    }
  load_netapi ();

  if (print_local)
    {
      char machine[INTERNET_MAX_HOST_NAME_LENGTH + 1];
      char sid[MAX_SID_LEN];

      if (isRoot)
        {
	  /*
	   * Very special feature for the oncoming future:
	   * Create a "root" group account, being actually the local
	   * Administrators group.  Since user name, sid and gid are
	   * fixed, there's no need to call print_special() for this.
	   */
	  printf ("root:S-1-5-32-544:0:\n");
	}

      if (disp_groupname == NULL)
        {
      /*
       * Get 'system' group
       */
      print_special (print_sids, &sid_nt_auth, 1, SECURITY_LOCAL_SYSTEM_RID,
		     0, 0, 0, 0, 0, 0, 0);
      /*
       * Get 'None' group
      */
      len = INTERNET_MAX_HOST_NAME_LENGTH + 1;
      GetComputerName (machine, &len);
      len = MAX_SID_LEN;
      len2 = MAX_DOMAIN_NAME_LEN + 1;
      if (LookupAccountName (NULL, machine, (PSID) sid, &len, dom, &len2, &use))
	psid = (PSID) sid;
      else
        {
	  ret = LsaOpenPolicy (NULL, &oa, POLICY_VIEW_LOCAL_INFORMATION, &lsa);
	  if (ret == STATUS_SUCCESS && lsa != INVALID_HANDLE_VALUE)
	    {
	      ret = LsaQueryInformationPolicy (lsa,
					       PolicyPrimaryDomainInformation,
					       (void *) &pdi);
	      if (ret == STATUS_SUCCESS)
	        {
		  if (pdi->Sid)
		    {
		      CopySid (MAX_SID_LEN, (PSID) sid, pdi->Sid);
		      psid = (PSID) sid;
		    }
		  LsaFreeMemory (pdi);
		}
	      LsaClose (lsa);
	    }
	}
      if (!psid)
        fprintf (stderr,
	        "WARNING: Machine local group 513 couldn't get retrieved.  Try mkgroup -d\n");
      else
	print_special (print_sids, GetSidIdentifierAuthority (psid), 5,
				   *GetSidSubAuthority (psid, 0),
				   *GetSidSubAuthority (psid, 1),
				   *GetSidSubAuthority (psid, 2),
				   *GetSidSubAuthority (psid, 3),
				   513,
				   0,
				   0,
				   0);
	}

      if (!isRoot)
	enum_local_groups (NULL, print_sids, print_users, 0, disp_groupname);
    }
  i = 1;
  if (print_domain) 
    do
d621 39
a659 3
	PDOMAIN_CONTROLLER_INFOW pdci = NULL;

	if (dsgetdcname)
d661 3
a663 13
	    if (domain_specified)
	      {
	        mbstowcs (domain_name, argv[optind], strlen (argv[optind]) + 1);
		rc = dsgetdcname (NULL, domain_name, NULL, NULL, 0, &pdci);
	      }
	    else
	      rc = dsgetdcname (NULL, NULL, NULL, NULL, 0, &pdci);
	    if (rc != ERROR_SUCCESS)
	      {
	        print_win_error(rc);
		return 1;
	      }
	    servername = pdci->DomainControllerName;
d665 1
a665 1
	else
d667 3
a669 13
	    rc = NetGetDCName (NULL, NULL, (void *) &servername);
	    if (rc == ERROR_SUCCESS && domain_specified)
	      {
		LPWSTR server = servername;
		mbstowcs (domain_name, argv[optind], strlen (argv[optind]) + 1);
		rc = NetGetDCName (NULL, domain_name, (void *) &servername);
		NetApiBufferFree (server);
	      }
	    if (rc != ERROR_SUCCESS)
	      {
		print_win_error(rc);
		return 1;
	      }
d671 53
a723 3
	enum_groups (servername, print_sids, print_users, id_offset * i,
		     disp_groupname);
	enum_local_groups (servername, print_sids, print_users, id_offset * i++,
d725 4
a728 1
	NetApiBufferFree (pdci ? (PVOID) pdci : (PVOID) servername);
a729 1
    while (++optind < argc);
d731 10
a740 2
  if (print_current && !print_domain)
    current_group (print_sids, print_users, id_offset);
@


1.28
log
@2007-08-31  Dave Korn  <dave.korn@@artimi.com>

	* mkgroup.c (enum_groups):  Use MAX_PREFERRED_LENGTH in netgroupenum
	call so that it will automatically size returned buffer sufficiently.
@
text
@d3 2
a4 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
d21 2
d30 2
a46 14
NET_API_STATUS WINAPI (*netapibufferallocate)(DWORD,PVOID*);
NET_API_STATUS WINAPI (*netapibufferfree)(PVOID);
NET_API_STATUS WINAPI (*netgroupenum)(LPWSTR,DWORD,PBYTE*,DWORD,PDWORD,PDWORD,PDWORD);
NET_API_STATUS WINAPI (*netgroupgetinfo)(LPWSTR,LPWSTR,DWORD,PBYTE*);
NET_API_STATUS WINAPI (*netlocalgroupenum)(LPWSTR,DWORD,PBYTE*,DWORD,PDWORD,PDWORD,PDWORD);
NET_API_STATUS WINAPI (*netlocalgroupgetmembers)(LPWSTR,LPWSTR,DWORD,PBYTE*,DWORD,PDWORD,PDWORD,PDWORD);
NET_API_STATUS WINAPI (*netgetdcname)(LPWSTR,LPWSTR,PBYTE*);
NET_API_STATUS WINAPI (*netgroupgetusers)(LPWSTR,LPWSTR,DWORD,PBYTE*,DWORD,PDWORD,PDWORD,PDWORD);

NTSTATUS NTAPI (*lsaclose)(LSA_HANDLE);
NTSTATUS NTAPI (*lsaopenpolicy)(PLSA_UNICODE_STRING,PLSA_OBJECT_ATTRIBUTES,ACCESS_MASK,PLSA_HANDLE);
NTSTATUS NTAPI (*lsaqueryinformationpolicy)(LSA_HANDLE,POLICY_INFORMATION_CLASS,PVOID*);
NTSTATUS NTAPI (*lsafreememory)(PVOID);

d53 1
a53 1
BOOL
d57 2
a58 36

  if (!h)
    return FALSE;

  if (!(netapibufferallocate = (void *) GetProcAddress (h, "NetApiBufferAllocate")))
    return FALSE;
  if (!(netapibufferfree = (void *) GetProcAddress (h, "NetApiBufferFree")))
    return FALSE;
  if (!(netgroupenum = (void *) GetProcAddress (h, "NetGroupEnum")))
    return FALSE;
  if (!(netgroupgetinfo = (void *) GetProcAddress (h, "NetGroupGetInfo")))
    return FALSE;
  if (!(netgroupgetusers = (void *) GetProcAddress (h, "NetGroupGetUsers")))
    return FALSE;
  if (!(netlocalgroupenum = (void *) GetProcAddress (h, "NetLocalGroupEnum")))
    return FALSE;
  if (!(netlocalgroupgetmembers = (void *) GetProcAddress (h, "NetLocalGroupGetMembers")))
    return FALSE;
  if (!(netgetdcname = (void *) GetProcAddress (h, "NetGetDCName")))
    return FALSE;

  dsgetdcname = (void *) GetProcAddress (h, "DsGetDcNameW");

  if (!(h = LoadLibrary ("advapi32.dll")))
    return FALSE;

  if (!(lsaclose = (void *) GetProcAddress (h, "LsaClose")))
    return FALSE;
  if (!(lsaopenpolicy = (void *) GetProcAddress (h, "LsaOpenPolicy")))
    return FALSE;
  if (!(lsaqueryinformationpolicy = (void *) GetProcAddress (h, "LsaQueryInformationPolicy")))
    return FALSE;
  if (!(lsafreememory = (void *) GetProcAddress (h, "LsaFreeMemory")))
    return FALSE;

  return TRUE;
a79 32
psx_dir (char *in, char *out)
{
  if (isalpha (in[0]) && in[1] == ':')
    {
      sprintf (out, "/cygdrive/%c", in[0]);
      in += 2;
      out += strlen (out);
    }

  while (*in)
    {
      if (*in == '\\')
	*out = '/';
      else
	*out = *in;
      in++;
      out++;
    }

  *out = '\0';
}

void
uni2ansi (LPWSTR wcs, char *mbs, int size)
{
  if (wcs)
    WideCharToMultiByte (CP_ACP, 0, wcs, -1, mbs, size, NULL, NULL);
  else
    *mbs = '\0';
}

void
d96 1
a96 1
enum_local_users (LPWSTR groupname)
d103 1
a103 2
  if (!netlocalgroupgetmembers (NULL, groupname,
				1, (void *) &buf1,
a111 2
	    char user[256];

d115 1
a115 2
	    uni2ansi (buf1[i].lgrmi1_name, user, sizeof (user));
	    printf ("%s", user);
d117 1
a117 1
      netapibufferfree (buf1);
d121 11
d133 2
a134 1
enum_local_groups (int print_sids, int print_users, char *disp_groupname)
d140 1
a140 1
  WCHAR uni_name[512];
d149 5
a153 4
	  MultiByteToWideChar (CP_ACP, 0, disp_groupname, -1, uni_name, 512 );
	  rc = netapibufferallocate(sizeof(LOCALGROUP_INFO_0), (void *) &buffer );
	  buffer[0].lgrpi0_name = (LPWSTR) & uni_name;
	  entriesread=1;
d156 3
a158 2
	rc = netlocalgroupenum (NULL, 0, (void *) &buffer, 1024,
				&entriesread, &totalentries, &resume_handle);
d176 3
a178 4
	  char localgroup_name[100];
	  char domain_name[100];
	  DWORD domname_len = 100;
	  char psid_buffer[1024];
d180 1
a180 1
	  DWORD sid_length = 1024;
d183 2
a184 1
	  uni2ansi (buffer[i].lgrpi0_name, localgroup_name, sizeof (localgroup_name));
d186 3
a188 3
	  if (!LookupAccountName (NULL, localgroup_name, psid,
				  &sid_length, domain_name, &domname_len,
				  &acc_type))
d191 1
a191 1
	      fprintf(stderr, " (%s)\n", localgroup_name);
d196 1
a196 1
              char domname[356];
d198 9
a206 9
              strcpy (domname, domain_name);
              strcat (domname, "\\");
              strcat (domname, localgroup_name);
              sid_length = 1024;
              domname_len = 100;
              if (!LookupAccountName (NULL, domname,
                                      psid, &sid_length,
                                      domain_name, &domname_len,
                                      &acc_type))
d209 1
a209 1
		  fprintf(stderr, " (%s)\n", domname);
d214 19
d235 1
a235 1
	  printf ("%s:%s:%ld:", localgroup_name,
d237 1
a237 1
                                gid);
d239 1
a239 1
	    enum_local_users (buffer[i].lgrpi0_name);
d241 2
d245 1
a245 1
      netapibufferfree (buffer);
d261 2
a262 4
  if (!netgroupgetusers (servername, groupname,
			 0, (void *) &buf1,
			 MAX_PREFERRED_LENGTH,
			 &entries, &total, &reshdl))
a267 2
	  char user[256];

d271 1
a271 2
	  uni2ansi (buf1[i].grui0_name, user, sizeof (user));
	  printf ("%s", user);
d273 1
a273 1
      netapibufferfree (buf1);
d285 1
a285 1
  WCHAR uni_name[512];
a286 4
  char ansi_srvname[256];

  if (servername)
    uni2ansi (servername, ansi_srvname, sizeof (ansi_srvname));
d294 3
a296 3
	  MultiByteToWideChar (CP_ACP, 0, disp_groupname, -1, uni_name, 512 );
	  rc = netgroupgetinfo(servername, (LPWSTR) & uni_name, 2,
			       (void *) &buffer );
d300 3
a302 2
	rc = netgroupenum (servername, 2, (void *) & buffer, MAX_PREFERRED_LENGTH,
			   &entriesread, &totalentries, &resume_handle);
d320 3
a322 4
	  char groupname[100];
	  char domain_name[100];
	  DWORD domname_len = 100;
	  char psid_buffer[1024];
d324 1
a324 1
	  DWORD sid_length = 1024;
a327 1
	  uni2ansi (buffer[i].grpi2_name, groupname, sizeof (groupname));
d330 4
a333 5
              if (!LookupAccountName (servername ? ansi_srvname : NULL,
                                      groupname,
                                      psid, &sid_length,
                                      domain_name, &domname_len,
			              &acc_type))
d336 1
a336 1
		  fprintf(stderr, " (%s)\n", groupname);
d341 1
a341 1
                  char domname[356];
d343 9
a351 10
                  strcpy (domname, domain_name);
                  strcat (domname, "\\");
                  strcat (domname, groupname);
                  sid_length = 1024;
                  domname_len = 100;
                  if (!LookupAccountName (servername ? ansi_srvname : NULL,
                                          domname,
                                          psid, &sid_length,
                                          domain_name, &domname_len,
			                  &acc_type))
d354 1
a354 1
		      fprintf(stderr, " (%s)\n", domname);
d359 1
a359 1
	  printf ("%s:%s:%u:", groupname,
d367 1
a367 1
      netapibufferfree (buffer);
d379 1
a379 1
  char name[256], dom[256];
d388 2
a389 2
			    name, (len = 256, &len),
			    dom, (len2 = 256, &len),
d425 1
a425 1
    int buffer[10];
d467 1
a467 1
    fprintf (stream, "   -l,--local             print local group information\n"
d469 1
a469 1
		     "   -d,--domain            print global group information (from current\n"
d518 1
a518 1
Copyright 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.\n\
d528 1
a528 1
  WCHAR domain_name[100];
d541 1
a541 1
  char name[256], dom[256];
a542 1
  char buf[1024];
d616 1
a616 5
  if (!load_netapi ())
    {
      print_win_error(GetLastError ());
      return 1;
    }
d620 3
d625 7
a631 7
      /*
       * Very special feature for the oncoming future:
       * Create a "root" group account, being actually the local
       * Administrators group.  Since user name, sid and gid are
       * fixed, there's no need to call print_special() for this.
       */
      printf ("root:S-1-5-32-544:0:\n");
d644 6
a649 6
      len = 256;
      GetComputerName (name, &len);
      len = 1024;
      len2 = 256;
      if (LookupAccountName (NULL, name, (PSID) buf, &len, dom, &len, &use))
	psid = (PSID) buf;
d652 1
a652 1
	  ret = lsaopenpolicy (NULL, &oa, POLICY_VIEW_LOCAL_INFORMATION, &lsa);
d655 1
a655 1
	      ret = lsaqueryinformationpolicy (lsa,
d662 2
a663 2
		      CopySid (1024, (PSID) buf, pdi->Sid);
		      psid = (PSID) buf;
d665 1
a665 1
		  lsafreememory (pdi);
d667 1
a667 1
	      lsaclose (lsa);
d672 1
a672 1
	        "WARNING: Group 513 couldn't get retrieved.  Try mkgroup -d\n");
d686 1
a686 3
	{
      enum_local_groups (print_sids, print_users, disp_groupname);
	}
a687 1

d712 1
a712 1
	    rc = netgetdcname (NULL, NULL, (void *) &servername);
d717 2
a718 2
		rc = netgetdcname (NULL, domain_name, (void *) &servername);
		netapibufferfree (server);
d726 1
a726 1
	enum_groups (servername, print_sids, print_users, id_offset * i++,
d728 3
a730 1
	netapibufferfree (pdci ? (PVOID) pdci : (PVOID) servername);
@


1.27
log
@bad_keywords
@
text
@d353 1
a353 1
	rc = netgroupenum (servername, 2, (void *) & buffer, 1024,
@


1.27.6.1
log
@2007-08-31  Dave Korn  <dave.korn@@artimi.com>

	* mkgroup.c (enum_groups):  Use MAX_PREFERRED_LENGTH in netgroupenum
	call so that it will automatically size returned buffer sufficiently.

2007-08-03  Dave Korn  <dave.korn@@artimi.com>

	* Makefile.in (cygcheck.exe):  Add bloda.o as prerequisite, adjusting
	dependency-filtering $(wordlist ...) call appropriately.  Link ntdll.
	(bloda.o):  New rule to build bloda.o
	* cygcheck.cc (dump_sysinfo):  Call bloda function dump_dodgy_apps().
	* bloda.cc:  New file implements detection of applications from the
	Big List Of Dodgy Apps.

2007-07-24  Corinna Vinschen  <corinna@@vinschen.de>

	* COPYING.dumper: New file.
	* dumper.cc: Change license to plain GPLv2 + later.
	* dumper.h: Ditto.
	* parse_pe.cc: Ditto.

2007-07-23  Christopher Faylor  <me+cygwin@@cgf.cx>

	* strace.cc (create_child): Don't convert a path from cygwin format
	unless it has a slash.

2007-07-09  Christopher Faylor  <me+cygwin@@cgf.cx>

	* strace.cc (usage): Add missing description for -q.

2007-05-29  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* dumper.cc (dumper::prepare_core_dump): Record a phdr for each section.

2007-03-30  Mark Mitchell  <mark@@codesourcery.com>

	* utils/cygpath.cc (get_long_path_name_w32impl): Close handles returned
	by FindFirstFile.

2006-09-11  Eric Blake  <ebb9@@byu.net>

	* cygcheck.cc (main): Restore POSIXLY_CORRECT before displaying user's
	environment.

2006-08-03  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (vconcat): Don't convert backslahes to slashes.
	(cygpath): Return native path with all backslashes.

2006-07-30  Ilya Bobir  <ilya@@po4ta.com>

	* cygpath.cc (get_long_name): Fallback to get_long_path_name_w32impl.

2006-07-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygpath.c (get_long_name): Cover the case that GetLongPathName
	doesn't return valid information for non-existant files.  Just return
	incoming filename in that case.
@
text
@d353 1
a353 1
	rc = netgroupenum (servername, 2, (void *) & buffer, MAX_PREFERRED_LENGTH,
@


1.26
log
@	Align error message handling to mkpasswd's error messages throughout.
	* mkgroup.c (print_win_error): Create macro calling ...
	(_print_win_error): ... this function created from former
	print_win_error.  Move up in source.
	(PDOMAIN_CONTROLLER_INFOW): Define return type of DcGetDcNameW.
	(dsgetdcname): New function pointer for DcGetDcNameW.
	(load_netapi): Get DcGetDcNameW address.
	(main): If DcGetDcNameW is available, use it.
	* mkpasswd.c (PDOMAIN_CONTROLLER_INFOW): Define return type of
	DcGetDcNameW.
	(dsgetdcname): New function pointer for DcGetDcNameW.
	(load_netapi): Get DcGetDcNameW address.
	(main): If DcGetDcNameW is available, use it.  Rename local variable
	domain_name_specified to domain_specified as in mkgroup.c.
@
text
@d536 1
a536 1
    fprintf (stream, "One of `-l' or `-d' must be given.\n");
d646 1
a646 1
	  fprintf (stderr, "Try `%s --help' for more information.\n", argv[0]);
d660 1
a660 1
      fprintf (stderr, "%s: Specify one of `-l' or `-d'\n", argv[0]);
d668 1
a668 1
		   "when `-d' is given.\n", argv[0]);
d695 1
a695 1
       * Get `system' group
d700 1
a700 1
       * Get `None' group
@


1.25
log
@	* mkgroup.cc (netapibufferallocate,netgroupgetinfo): New function
	pointers.
	(load_netapi): Load NetApiBufferAllocate and NetGroupGetInfo.
	(enum_local_groups,enum_groups): Add disp_groupname parameter.
	Load info for disp_groupname if specified.
	(usage): Add description of "-g/--group" option.
	(longopts,opts): Add "-g/--group" option.
	(main): Process "-g/--group" option.
	* utils.sgml (mkgroup): Add description of "-g/--group" option
@
text
@d23 2
d27 12
d56 2
d87 2
d155 16
d227 1
a227 1
	  fprintf (stderr, "Access denied\n");
d235 1
a235 1
	  fprintf (stderr, "NetLocalGroupEnum() failed with %ld\n", rc);
d255 2
a256 2
	      fprintf (stderr, "LookupAccountName(%s) failed with %ld\n",
		       localgroup_name, GetLastError ());
d273 2
a274 3
                  fprintf (stderr,
                           "LookupAccountName(%s) failed with error %ld\n",
                           localgroup_name, GetLastError ());
d358 1
a358 1
	  fprintf (stderr, "Access denied\n");
d366 1
a366 1
	  fprintf (stderr, "NetGroupEnum() failed with %ld\n", rc);
d390 2
a391 5
                  fprintf (stderr,
                           "LookupAccountName (%s, %s) failed with error %ld\n",
                           servername ? ansi_srvname : "NULL",
                           groupname,
                           GetLastError ());
d409 2
a410 5
                      fprintf (stderr,
                               "LookupAccountName(%s,%s) failed with error %ld\n",
                               servername ? ansi_srvname : "NULL",
                               domname,
                               GetLastError ());
a472 16
print_win_error(DWORD code)
{
  char buf[4096];

  if (FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM
      | FORMAT_MESSAGE_IGNORE_INSERTS,
      NULL,
      code,
      MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),
      (LPTSTR) buf, sizeof (buf), NULL))
    fprintf (stderr, "mkgroup: [%lu] %s", code, buf);
  else
    fprintf (stderr, "mkgroup: error %lu", code);
}

void
a502 1
	  fprintf(stderr, " on line %d\n", errpos);
d675 1
a675 2
      fprintf (stderr, "Failed loading symbols from netapi32.dll "
      		       "with error %lu\n", GetLastError ());
d753 17
a769 4
	if (domain_specified)
          {
	    mbstowcs (domain_name, argv[optind], (strlen (argv[optind]) + 1));
	    rc = netgetdcname (NULL, domain_name, (void *) &servername);
a771 3
	  rc = netgetdcname (NULL, NULL, (void *) &servername);
	
	if (rc != ERROR_SUCCESS)
d773 13
a785 2
	    fprintf (stderr, "Cannot get PDC, code = %ld\n", rc);
	    return 1;
d787 3
a789 3

	enum_groups (servername, print_sids, print_users, id_offset * i++, disp_groupname);
	netapibufferfree (servername);	
@


1.24
log
@	* mkgroup.c (main): Print "root" group with local admins group sid
	and gid 0.
@
text
@d28 1
d31 1
d54 2
d60 2
d167 1
a167 1
enum_local_groups (int print_sids, int print_users)
d173 1
d180 10
a189 2
      rc = netlocalgroupenum (NULL, 0, (void *) &buffer, 1024,
			      &entriesread, &totalentries, &resume_handle);
d294 2
a295 1
enum_groups (LPWSTR servername, int print_sids, int print_users, int id_offset)
d301 1
d312 10
a321 2
      rc = netgroupenum (servername, 2, (void *) & buffer, 1024,
		         &entriesread, &totalentries, &resume_handle);
d521 2
a522 1
	             "   -u,--users             print user list in gr_mem field\n");
d538 1
d544 1
a544 1
char opts[] = "lcdo:suhv";
d582 2
d625 4
d672 2
d681 1
d683 2
d732 1
d734 4
a737 1
      enum_local_groups (print_sids, print_users);
d758 1
a758 1
	enum_groups (servername, print_sids, print_users, id_offset * i++);
@


1.23
log
@	* mkgroup.c: Avoid compiler warnings throughout.
	* mkpasswd.c: Ditto.
	* passwd.c: Ditto.
@
text
@d640 8
@


1.22
log
@* cygcheck.cc (usage) Add description output.
@
text
@d139 1
a139 1
				1, (LPBYTE *) &buf1,
d173 1
a173 1
      rc = netlocalgroupenum (NULL, 0, (LPBYTE *) &buffer, 1024,
d258 1
a258 1
			 0, (LPBYTE *) &buf1,
d295 1
a295 1
      rc = netgroupenum (servername, 2, (LPBYTE *) & buffer, 1024,
d660 1
a660 1
					       (PVOID *) &pdi);
d697 1
a697 1
	    rc = netgetdcname (NULL, domain_name, (LPBYTE *) & servername);
d700 1
a700 1
	  rc = netgetdcname (NULL, NULL, (LPBYTE *) & servername);
@


1.21
log
@
2003-04-10  Pierre Humblet  <pierre.humblet@@ieee.org>

        * mkpasswd.c (current_user): print uid and gid as unsigned.
        (enum_users): Ditto. Do not free servername.
        (usage): Update to allow several domains and improve -p.
        (main): On Win9x limit uids to 1000. Only print specials
        when -l is specified. Add a loop to allow several domains
        and free servername in the loop.
        * mkgroup.c (enum_groups): Do not free servername.
        (usage): Update to allow several domains. Change uid to gid.
        (main): Only print specials when -l is specified. Add a
        loop to allow several domains and free servername in the loop.
@
text
@d484 2
a485 2
  fprintf (stream, "Usage: mkgroup [OPTION]... [domain]...\n\n"
	           "This program prints a /etc/group file to stdout\n\n"
@


1.20
log
@
2003-03-01  Pierre Humblet  <pierre.humblet@@ieee.org>

       * mkpasswd.cc (main): On Win95, output both a default line and a
       line for the current user (if known) with a pseudorandom uid. If
       the -u switch is given, produce a line for the specified user.
       * mkgroup.cc (main): On Win95 change the group name from "unknown" to
       "all".
@
text
@a374 3

  if (servername)
    netapibufferfree (servername);
d484 1
a484 1
  fprintf (stream, "Usage: mkgroup [OPTION]... [domain]\n\n"
d490 3
a492 4
		     "   -d,--domain            print global group information from the domain\n"
		     "                          specified (or from the current domain if there is\n"
		     "                          no domain specified)\n"
		     "   -o,--id-offset offset  change the default offset (10000) added to uids\n"
a627 1
      mbstowcs (domain_name, argv[optind], (strlen (argv[optind]) + 1));
a636 13
#if 0
  /*
   * Get `Everyone' group
  */
  print_special (print_sids, &sid_world_auth, 1, SECURITY_WORLD_RID,
			     0, 0, 0, 0, 0, 0, 0);
#endif

  /*
   * Get `system' group
  */
  print_special (print_sids, &sid_nt_auth, 1, SECURITY_LOCAL_SYSTEM_RID,
			     0, 0, 0, 0, 0, 0, 0);
d640 5
a685 15
    }

  if (print_domain)
    {
      if (domain_specified)
	rc = netgetdcname (NULL, domain_name, (LPBYTE *) & servername);

      else
	rc = netgetdcname (NULL, NULL, (LPBYTE *) & servername);

      if (rc != ERROR_SUCCESS)
	{
	  fprintf (stderr, "Cannot get PDC, code = %ld\n", rc);
	  return 1;
	}
d687 1
a687 1
      enum_groups (servername, print_sids, print_users, id_offset);
d690 22
a711 2
  if (print_local)
    enum_local_groups (print_sids, print_users);
@


1.19
log
@	* mkgroup.c: Fix copyright date.
	* mkpasswd.c: Ditto.
	* setfacl.c: Ditto.

	Fix ChangeLog typos.
@
text
@d615 1
a615 1
      printf ("unknown::%ld:\n", DOMAIN_ALIAS_RID_ADMINS);
@


1.18
log
@	* mkpasswd.cc (current_user): Create.
	(usage): Reorganize to support Win95/98/ME.
	(main): Add option for -c. Reorganize to parse options for
	Win95/98/ME and to call current_user. Add username in gecos field
	on Win95/98/ME.
	* mkgroup.cc (enum_groups): Print gid with %u.
	(print_win_error): Create from passwd.cc.
	(current_group): Create.
	(usage): Reorganize to support Win95/98/ME.
	(main): Add option for -c. Reorganize to parse options for
	Win95/98/ME and to call current_group.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.17
log
@* cygpath.cc (close_arg): Remove unused static.
* mkgroup.c (enum_local_users): Avoid compiler warning.
(enum_users): Ditto.
* mkpasswd.c: Ditto throughout.
* ssp.c: Ditto throughout.
@
text
@d363 1
a363 1
	  printf ("%s:%s:%d:", groupname,
d423 61
d485 1
a485 1
usage (FILE * stream, int status)
d488 19
a506 15
		   "This program prints a /etc/group file to stdout\n\n"
		   "Options:\n"
		   "   -l,--local             print local group information\n"
		   "   -d,--domain            print global group information from the domain\n"
		   "                          specified (or from the current domain if there is\n"
		   "                          no domain specified)\n"
		   "   -o,--id-offset offset  change the default offset (10000) added to uids\n"
		   "                          in domain accounts.\n"
		   "   -s,--no-sids           don't print SIDs in pwd field\n"
		   "                          (this affects ntsec)\n"
		   "   -u,--users             print user list in gr_mem field\n"
		   "   -h,--help              print this message\n\n"
		   "   -v,--version           print version information and exit\n\n"
		   "One of `-l' or `-d' must be given on NT/W2K.\n");
  return status;
d511 1
d521 1
a521 1
char opts[] = "ldo:suhv";
d553 1
d559 1
d573 5
a577 1
  if (GetVersion () < 0x80000000)
d579 2
a580 3
      if (argc == 1)
	return usage(stderr, 1);
      else
d582 27
a608 43
	  while ((i = getopt_long (argc, argv, opts, longopts, NULL)) != EOF)
	    switch (i)
	      {
	      case 'l':
		print_local = 1;
		break;
	      case 'd':
		print_domain = 1;
		break;
	      case 'o':
		id_offset = strtol (optarg, NULL, 10);
		break;
	      case 's':
		print_sids = 0;
		break;
	      case 'u':
		print_users = 1;
		break;
	      case 'h':
		return usage (stdout, 0);
	      case 'v':
		print_version ();
		return 0;
	      default:
		fprintf (stderr, "Try `%s --help' for more information.\n", argv[0]);
		return 1;
	      }
	  if (!print_local && !print_domain)
	    {
	      fprintf (stderr, "%s: Specify one of `-l' or `-d'\n", argv[0]);
	      return 1;
	    }
	  if (optind < argc)
	    {
	      if (!print_domain)
		{
		  fprintf (stderr, "%s: A domain name is only accepted "
				   "when `-d' is given.\n", argv[0]);
		  return 1;
		}
	      mbstowcs (domain_name, argv[optind], (strlen (argv[optind]) + 1));
	      domain_specified = 1;
	    }
d613 1
a613 1
  if (GetVersion () >= 0x80000000)
d618 17
a634 1
  
d720 3
@


1.16
log
@Add final newlines to utils
@
text
@d143 1
a143 1
      int i, first = 1;
d262 1
a262 1
      int i, first = 1;
@


1.15
log
@	* mkgroup.c (main): Don't print an entry for "Everyone".
	* mkpasswd.c (print_special): Set pw_gid to 544 for SYSTEM user.
	(main): Don't print an entry for "Everyone".
@
text
@d476 2
a477 1
Compiled on %s", len, v, __DATE__);
@


1.14
log
@	* mkgroup.c: Add function pointers for functions from advapi32.dll.
	(load_netapi): Load used functions from advapi32.dll.
	(main): Use function pointers instead of statically linked functions
	from advapi32.dll.
@
text
@d570 1
d576 2
@


1.13
log
@	* mkgroup.c (main): Change call to exit() to a return statement.
	* mkpasswd.c (main): Ditto.

	* mkpasswd.c (usage): Simplify usage output.  Generalize to allow use
	for help. Correct '?' typo to 'h'.
	(longopts): Add version option.
	(opts): Add 'v' version option.
	(print_version): New function.
	(main): Accommodate new version option.  Accommodate usage parameter
	changes.
@
text
@d35 5
d65 12
d593 1
a593 1
	  ret = LsaOpenPolicy(NULL, &oa, POLICY_VIEW_LOCAL_INFORMATION, &lsa);
d596 1
a596 1
	      ret = LsaQueryInformationPolicy (lsa,
d606 1
a606 1
		  LsaFreeMemory (pdi);
d608 1
a608 1
	      LsaClose (lsa);
@


1.12
log
@* mkgroup.c (usage): Use one just fprintf + string concatenation for output
message.
(print_version): Add void to function type and update copyright.
@
text
@d515 1
a515 1
		exit (0);
d620 1
a620 1
	  exit (1);
@


1.11
log
@	* mkgroup.c (usage): Simplify usage output.  Generalize to allow use
	for help. Correct '?' typo to 'h'.
	(longopts): Add version option.
	(opts): Add 'v' version option.
	(print_version): New function.
	(main): Accommodate new version option.  Accommodate usage parameter
	changes.  Use usage to output help message.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 2002 Cygnus Solutions.
d409 15
a423 15
  fprintf (stream, "Usage: mkgroup [OPTION]... [domain]\n\n");
  fprintf (stream, "This program prints a /etc/group file to stdout\n\n");
  fprintf (stream, "Options:\n");
  fprintf (stream, "   -l,--local             print local group information\n");
  fprintf (stream, "   -d,--domain            print global group information from the domain\n");
  fprintf (stream, "                          specified (or from the current domain if there is\n");
  fprintf (stream, "                          no domain specified)\n");
  fprintf (stream, "   -o,--id-offset offset  change the default offset (10000) added to uids\n");
  fprintf (stream, "                          in domain accounts.\n");
  fprintf (stream, "   -s,--no-sids           don't print SIDs in pwd field\n");
  fprintf (stream, "                          (this affects ntsec)\n");
  fprintf (stream, "   -u,--users             print user list in gr_mem field\n");
  fprintf (stream, "   -h,--help              print this message\n\n");
  fprintf (stream, "   -v,--version           print version information and exit\n\n");
  fprintf (stream, "One of `-l' or `-d' must be given on NT/W2K.\n");
d440 1
d458 1
a458 1
Copyright 1997, 1998, 2002 Red Hat, Inc.\n\
@


1.10
log
@2002-03-15  Corinna Vinschen  <corinna@@vinschen.de>

	* mkgroup.c (main): When generating group 513, check for computer's
	primary domain instead of current user's domain.

2002-03-14  Corinna Vinschen  <corinna@@vinschen.de>

	* mkgroup.c (main): When generating group 513, check for domain SID
	if computer name isn't mapped to a SID.
@
text
@d3 1
a3 1
   Copyright 1997, 1998 Cygnus Solutions.
d23 2
d407 1
a407 1
usage ()
d409 16
a424 15
  fprintf (stderr, "Usage: mkgroup [OPTION]... [domain]\n\n");
  fprintf (stderr, "This program prints a /etc/group file to stdout\n\n");
  fprintf (stderr, "Options:\n");
  fprintf (stderr, "   -l,--local             print local group information\n");
  fprintf (stderr, "   -d,--domain            print global group information from the domain\n");
  fprintf (stderr, "                          specified (or from the current domain if there is\n");
  fprintf (stderr, "                          no domain specified)\n");
  fprintf (stderr, "   -o,--id-offset offset  change the default offset (10000) added to uids\n");
  fprintf (stderr, "                          in domain accounts.\n");
  fprintf (stderr, "   -s,--no-sids           don't print SIDs in pwd field\n");
  fprintf (stderr, "                          (this affects ntsec)\n");
  fprintf (stderr, "   -u,--users             print user list in gr_mem field\n");
  fprintf (stderr, "   -?,--help              print this message\n\n");
  fprintf (stderr, "One of `-l' or `-d' must be given on NT/W2K.\n");
  return 1;
d434 1
d438 22
a459 1
char opts[] = "ldo:suh";
d489 1
a489 1
	return usage ();
d511 4
a514 1
		return usage ();
@


1.9
log
@* cygcheck.cc: Fix typo.  Remove uid_t kludge.  Rely on kludge in sys/cygwin.h
instead.
* getfacl.c: Add include to remove warning.
* mkgroup.c (main): Assign variables outside of parameter passing.  This seems
to eliminate some compiler warnings.
@
text
@d20 2
d452 2
a453 1
  PSID csid;
d456 5
a540 1
      csid = (PSID) malloc (1024);
d543 35
a577 14
      LookupAccountName (NULL, name,
			 csid, &len,
			 dom, &len,
			 &use);
      print_special (print_sids, GetSidIdentifierAuthority (csid), 5,
				 *GetSidSubAuthority (csid, 0),
				 *GetSidSubAuthority (csid, 1),
				 *GetSidSubAuthority (csid, 2),
				 *GetSidSubAuthority (csid, 3),
				 513,
				 0,
				 0,
				 0);
      free (csid);
@


1.8
log
@        * mkgroup.c: Avoid compiler warnings.
        (print_special): New function.
        (main): Print special accounts by calling print_special().
        * mkpasswd.c: Avoid compiler warnings.
        (enum_users): Print additional U-domain\username info in gecos
        field when SIDs are printed.
        (print_special): New function.
        (main): Print special accounts by calling print_special().
@
text
@d531 2
a532 1
      GetComputerName (name, (len = 256, &len));
d534 2
d537 2
a538 2
			 csid, (len = 1024, &len),
			 dom, (len2 = 256, &len),
@


1.7
log
@        * mkgroup.c: Add function pointers `netlocalgroupgetmembers' and
        `netgroupgetusers'.
        (load_netapi): Load function pointers `netlocalgroupgetmembers'
        and `netgroupgetusers'.
        (enum_local_users): New function.
        (enum_local_groups): Call `enum_local_users' for each group if
        `print_users' is set.
        (enum_users): New function.
        (enum_groups): Call `enum_users' for each group if `print_users' is set.
        (usage): Add usage text for `-u/--users'.
        (longopts): Add option `--users'.
        (opts): Add option character `u'.
        (main): Set `print_users' according to option `-u/--users'.
        Call `enum_local_groups' and `enum_groups' with additional parameter
        `print_users'.
@
text
@d43 1
a43 1
  if (!(netapibufferfree = GetProcAddress (h, "NetApiBufferFree")))
d45 1
a45 1
  if (!(netgroupenum = GetProcAddress (h, "NetGroupEnum")))
d47 1
a47 1
  if (!(netgroupgetusers = GetProcAddress (h, "NetGroupGetUsers")))
d49 1
a49 1
  if (!(netlocalgroupenum = GetProcAddress (h, "NetLocalGroupEnum")))
d51 1
a51 1
  if (!(netlocalgroupgetmembers = GetProcAddress (h, "NetLocalGroupGetMembers")))
d53 1
a53 1
  if (!(netgetdcname = GetProcAddress (h, "NetGetDCName")))
d359 43
d450 1
a450 1
  PSID sid, csid;
d454 30
a483 6
    if (argc == 1)
      return usage ();
    else
      {
        while ((i = getopt_long (argc, argv, opts, longopts, NULL)) != EOF)
          switch (i)
d485 1
a485 19
	    case 'l':
	      print_local = 1;
	      break;
	    case 'd':
	      print_domain = 1;
	      break;
	    case 'o':
	      id_offset = strtol (optarg, NULL, 10);
	      break;
	    case 's':
	      print_sids = 0;
	      break;
	    case 'u':
	      print_users = 1;
	      break;
	    case 'h':
	      return usage ();
	    default:
	      fprintf (stderr, "Try `%s --help' for more information.\n", argv[0]);
d488 13
a500 17
        if (!print_local && !print_domain)
          {
	    fprintf (stderr, "%s: Specify one of `-l' or `-d'\n", argv[0]);
	    return 1;
	  }
        if (optind < argc)
          {
	    if (!print_domain)
	      {
	        fprintf (stderr, "%s: A domain name is only accepted "
	      		         "when `-d' is given.\n", argv[0]);
	        return 1;
	      }
	    mbstowcs (domain_name, argv[optind], (strlen (argv[optind]) + 1));
	    domain_specified = 1;
	  }
      }
d519 2
a520 13
  if (AllocateAndInitializeSid (&sid_world_auth, 1, SECURITY_WORLD_RID,
				0, 0, 0, 0, 0, 0, 0, &sid))
    {
      if (LookupAccountSid (NULL, sid,
			    name, (len = 256, &len),
			    dom, (len2 = 256, &len),
			    &use))
	printf ("%s:%s:%d:\n", name,
                               print_sids ? put_sid (sid) : "",
                               SECURITY_WORLD_RID);
      FreeSid (sid);
    }

d524 2
a525 13
  if (AllocateAndInitializeSid (&sid_nt_auth, 1, SECURITY_LOCAL_SYSTEM_RID,
				0, 0, 0, 0, 0, 0, 0, &sid))
    {
      if (LookupAccountSid (NULL, sid,
			    name, (len = 256, &len),
			    dom, (len2 = 256, &len),
			    &use))
	printf ("%s:%s:%d:\n", name,
                               print_sids ? put_sid (sid) : "",
                               SECURITY_LOCAL_SYSTEM_RID);
      FreeSid (sid);
    }

d537 9
a545 20
      if (AllocateAndInitializeSid (GetSidIdentifierAuthority (csid),
				    5,
				    *GetSidSubAuthority (csid, 0),
				    *GetSidSubAuthority (csid, 1),
				    *GetSidSubAuthority (csid, 2),
				    *GetSidSubAuthority (csid, 3),
				    513,
				    0,
				    0,
				    0,
				    &sid))
	{
	  if (LookupAccountSid (NULL, sid,
				name, (len = 256, &len),
				dom, (len2 = 256, &len),
				&use))
            printf ("%s:%s:513:\n", name,
                                   print_sids ? put_sid (sid) : "");
	  FreeSid (sid);
	}
@


1.6
log
@Patch by Kazuhiro Fujieda  <fujieda@@jaist.ac.jp>:
        * mkgroup.c (enum_groups): Use RID + offset specified an additional
        argument as ID.
        (usage): Add description of -o option.
        (longopts, opts): Add specifications of -o/--id-offset option.
        (main): Add -o option. Invoke enum_groups with specified offset.
        * mkpasswd.c (enum_users): Just like mkgroup.c.
        (usage, longopts, opts): Ditto.
        (main): Add -o option. Invoke enum_users with specified offset
        only against domain accounts.
@
text
@d27 1
d29 1
d47 2
d51 2
d109 30
d140 1
a140 1
enum_local_groups (int print_sids)
d152 1
a152 1
      rc = netlocalgroupenum (NULL, 0, (LPBYTE *) & buffer, 1024,
d212 6
a217 3
	  printf ("%s:%s:%ld:\n", localgroup_name,
                                  print_sids ? put_sid (psid) : "",
                                  gid);
d229 30
a258 1
enum_groups (LPWSTR servername, int print_sids, int id_offset)
d342 6
a347 3
	  printf ("%s:%s:%d:\n", groupname,
                                 print_sids ? put_sid (psid) : "",
                                 gid + id_offset);
d373 1
d384 1
d389 1
a389 1
char opts[] = "ldo:sh";
d400 1
d430 3
d551 1
a551 1
      enum_groups (servername, print_sids, id_offset);
d555 1
a555 1
    enum_local_groups (print_sids);
@


1.5
log
@* mkgroup.c (uni2ansi): Use native method to convert from Unicode
to multi-byte strings.
* mkpasswd.c (uni2ansi): Ditto.
(enum_users): Pass buffer size when converting string.
(enum_local_groups): Ditto.
* mkgroup.c (enum_groups): Ditto.
(enum_local_groups): Ditto.
@
text
@d190 1
a190 1
enum_groups (LPWSTR servername, int print_sids)
d276 1
a276 1
                                 gid);
d294 9
a302 7
  fprintf (stderr, "   -l,--local           print local group information\n");
  fprintf (stderr, "   -d,--domain          print global group information from the domain\n");
  fprintf (stderr, "                        specified (or from the current domain if there is\n");
  fprintf (stderr, "                        no domain specified)\n");
  fprintf (stderr, "   -s,--no-sids         don't print SIDs in pwd field\n");
  fprintf (stderr, "                         (this affects ntsec)\n");
  fprintf (stderr, "   -?,--help            print this message\n\n");
d310 1
d316 1
a316 1
char opts[] = "ldsh";
d328 1
d350 3
d474 1
a474 1
      enum_groups (servername, print_sids);
@


1.4
log
@        * mkgroup.c (load_netapi): New function to load netapi32.dll functions
        dynamically so that mkgroup works on 9x/ME as well.
        Use corresponding function pointers throughout.
        (usage): Change to `int'. Change text to be conformant to mkpasswd.
        (main): Use `getlongopt' to process options.
        Special handling to create a group entry on 9x/ME.
        * mkpasswd.c (load_netapi): New function to load netapi32.dll functions
        dynamically so that mkpasswd works on 9x/ME as well.
        Use corresponding function pointers throughout.
        (usage): Change to `int'. Change text to be conformant to mkgroup.
        (main): Use `getlongopt' to process options.
        Special handling to create a passwd entry on 9x/ME.
        Change conditional to create an entry for the local administrators
        group when appropriate.
@
text
@d95 1
a95 1
uni2ansi (LPWSTR wcs, char *mbs)
d98 1
a98 2
    wcstombs (mbs, wcs, (wcslen (wcs) + 1) * sizeof (WCHAR));

d143 1
a143 1
	  uni2ansi (buffer[i].lgrpi0_name, localgroup_name);
d200 1
a200 1
    uni2ansi (servername, ansi_srvname);
d234 1
a234 1
	  uni2ansi (buffer[i].grpi2_name, groupname);
@


1.3
log
@* Makefile.in: Eliminate WINSUP_DEPS.
* cygpath.cc: Reorganize includes to accomodate sys/cygwin.h changes.
* mkgroup.c: Ditto.
* mkpasswd.c: Ditto.
* mount.cc: Ditto.  Eliminate use of cygwin source specific includes.
* ps.cc: Ditto.
* cygwin.cc: Eliminate obsolete file.
@
text
@d17 1
d24 5
d33 20
d117 1
a117 1
      rc = NetLocalGroupEnum (NULL, 0, (LPBYTE *) & buffer, 1024,
d130 1
a130 1
	  fprintf (stderr, "NetUserEnum() failed with %ld\n", rc);
d182 1
a182 1
      NetApiBufferFree (buffer);
d207 1
a207 1
      rc = NetGroupEnum (servername, 2, (LPBYTE *) & buffer, 1024,
d220 1
a220 1
	  fprintf (stderr, "NetUserEnum() failed with %ld\n", rc);
d280 1
a280 1
      NetApiBufferFree (buffer);
d286 1
a286 1
    NetApiBufferFree (servername);
d289 1
a289 1
void
d292 2
a293 3
  fprintf (stderr, "\n");
  fprintf (stderr, "usage: mkgroup <options> [domain]\n\n");
  fprintf (stderr, "This program prints group information to stdout\n\n");
d295 5
a299 6
  fprintf (stderr, "    -l,--local           print pseudo group information if there is\n");
  fprintf (stderr, "                         no domain\n");
  fprintf (stderr, "    -d,--domain          print global group information from the domain\n");
  fprintf (stderr, "                         specified (or from the current domain if there is\n");
  fprintf (stderr, "                         no domain specified)\n");
  fprintf (stderr, "    -s,--no-sids         don't print SIDs in pwd field\n");
d301 3
a303 2
  fprintf (stderr, "    -?,--help            print this message\n\n");
  exit (1);
d306 10
d333 40
a372 2
  if (argc == 1)
    usage ();
d374 8
a381 1
  else
d383 3
a385 20
      for (i = 1; i < argc; i++)
	{
	  if (!strcmp (argv[i], "-l") || !strcmp (argv[i], "--local"))
	    print_local = 1;

	  else if (!strcmp (argv[i], "-d") || !strcmp (argv[i], "--domain"))
	    print_domain = 1;

	  else if (!strcmp (argv[i], "-s") || !strcmp (argv[i], "--no-sids"))
	    print_sids = 0;

	  else if (!strcmp (argv[i], "-?") || !strcmp (argv[i], "--help"))
	    usage ();

	  else
	    {
	      mbstowcs (domain_name, argv[i], strlen (argv[i]) + 1);
	      domain_specified = 1;
	    }
	}
d398 1
a398 1
	printf ("%s:%s:%ld:\n", name,
d414 1
a414 1
	printf ("%s:%s:%ld:\n", name,
d457 1
a457 1
	rc = NetGetDCName (NULL, domain_name, (LPBYTE *) & servername);
d460 1
a460 1
	rc = NetGetDCName (NULL, NULL, (LPBYTE *) & servername);
@


1.2
log
@        * mkpasswd.c (main): Use GetDCName instead of GetAnyDCName.
        Don't create extra passwd entry for administrators group
        if local_groups is set.
        (usage): Change usage text slightly.
        (enum_users): Loop while ERROR_MORE_DATA is returned.
        (enum_local_groups): Ditto.
        * mkgroup.c (enum_local_groups): Ditto.
        (enum_groups) Ditto.
        (usage): Change usage text slightly.
@
text
@d15 1
a16 1
#include <windows.h>
@


1.1
log
@Initial revision
@
text
@d85 1
a89 2
      DWORD rc = NetLocalGroupEnum (NULL, 0, (LPBYTE *) & buffer, 1024,
			       &entriesread, &totalentries, &resume_handle);
d91 2
d159 1
a159 1
  while (entriesread < totalentries);
d171 1
a179 2
      DWORD rc = NetGroupEnum (servername, 2, (LPBYTE *) & buffer, 1024,
			       &entriesread, &totalentries, &resume_handle);
d181 2
d257 1
a257 1
  while (entriesread < totalentries);
d276 1
a276 1
  fprintf (stderr, "                         (this affects NT security)\n");
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
