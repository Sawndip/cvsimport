head	1.36;
access;
symbols
	cygwin-1_7_35-release:1.36
	cygwin-1_7_34-release:1.36
	cygwin-1_7_33-release:1.36
	cygwin-1_7_32-release:1.36
	cygwin-1_7_31-release:1.36
	cygwin-1_7_30-release:1.36
	cygwin-1_7_29-release:1.36
	cygwin-1_7_29-release-branchpoint:1.36.0.2
	cygwin-1_7_28-release:1.36
	cygwin-1_7_27-release:1.36
	cygwin-1_7_26-release:1.36
	cygwin-1_7_25-release:1.36
	cygwin-1_7_24-release:1.36
	cygwin-1_7_23-release:1.36
	cygwin-1_7_22-release:1.36
	cygwin-1_7_21-release:1.36
	cygwin-1_7_20-release:1.35
	cygwin-1_7_19-release:1.35
	cygwin-64bit-postmerge:1.35
	cygwin-64bit-premerge-branch:1.34.0.2
	cygwin-64bit-premerge:1.34
	cygwin-1_7_18-release:1.34
	cygwin-1_7_17-release:1.31
	cygwin-64bit-branch:1.31.0.2
	cygwin-1_7_16-release:1.31
	cygwin-1_7_15-release:1.31
	cygwin-1_7_14_2-release:1.31
	cygwin-1_7_14-release:1.31
	cygwin-1_7_12-release:1.31
	cygwin-1_7_11-release:1.31
	cygwin-1_7_10-release:1.31
	cygwin-1_7_9-release:1.29
	cygwin-1_7_8-release:1.29
	cygwin-1_7_7-release:1.29
	cygwin-1_7_5-release:1.27
	cygwin-1_7_4-release:1.27
	cygwin-1_7_3-release:1.27
	cygwin-1_7_2-release:1.27
	cygwin-1_7_1-release:1.27
	cv-branch-2:1.22.0.2
	cr-0x5f1:1.9.0.6
	cv-branch:1.9.0.4
	cr-0x3b58:1.9.0.2
	cr-0x9e:1.8.0.8
	cr-0x9d:1.8.0.6
	corinna-01:1.8
	cr-0x9c:1.8.0.2
	cr-0x9b:1.8.0.4
	cr-0x99:1.7
	Z-emcb-cygwin_daemon:1.7.0.2
	w32api-2_2:1.6
	mingw-runtime-2_4:1.6
	cygnus_cvs_20020108_pre:1.4;
locks; strict;
comment	@// @;


1.36
date	2013.07.07.16.57.11;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2013.04.23.09.44.36;	author corinna;	state Exp;
branches;
next	1.34;

1.34
date	2013.01.21.16.28.27;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2012.11.09.08.53.01;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2012.10.24.10.15.27;	author yselkowitz;	state Exp;
branches;
next	1.31;

1.31
date	2011.12.17.23.39.47;	author cgf;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2011.03.29.11.02.58;	author corinna;	state Exp;
branches;
next	1.29;

1.29
date	2010.08.28.11.22.37;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2010.04.29.10.39.35;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2009.11.04.17.09.32;	author corinna;	state Exp;
branches;
next	1.26;

1.26
date	2009.11.04.17.00.45;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.04.15.47.29;	author corinna;	state Exp;
branches;
next	1.24;

1.24
date	2009.07.22.16.24.17;	author corinna;	state Exp;
branches;
next	1.23;

1.23
date	2009.07.22.10.20.26;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2009.06.10.10.42.22;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2009.04.07.16.24.50;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2009.03.14.14.58.05;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2008.09.12.22.43.10;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2008.07.22.14.40.05;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2008.07.17.15.07.48;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2008.04.22.14.42.05;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2008.03.16.17.04.02;	author briand;	state Exp;
branches;
next	1.14;

1.14
date	2008.03.11.17.20.02;	author briand;	state Exp;
branches;
next	1.13;

1.13
date	2008.03.09.04.10.10;	author briand;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.04.01.57.16;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2006.10.05.17.24.13;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2006.08.03.15.29.30;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.29.16.39.34;	author davek;	state Exp;
branches
	1.9.6.1;
next	1.8;

1.8
date	2003.09.11.02.00.42;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.04.05.30.50;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.07.04.51.26;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.09.05.08.44;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.22.00.29.04;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.12.00.10.12;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.11.06.07.36;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2001.11.11.03.06.59;	author cgf;	state Exp;
branches;
next	;

1.31.2.1
date	2012.08.16.16.26.01;	author corinna;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2012.10.24.13.01.59;	author corinna;	state Exp;
branches;
next	1.31.2.3;

1.31.2.3
date	2012.11.09.08.53.24;	author corinna;	state Exp;
branches;
next	1.31.2.4;

1.31.2.4
date	2013.01.29.21.54.42;	author corinna;	state Exp;
branches;
next	1.31.2.5;

1.31.2.5
date	2013.02.06.17.03.49;	author corinna;	state Exp;
branches;
next	;

1.9.6.1
date	2007.11.12.15.31.45;	author corinna;	state Exp;
branches;
next	;


desc
@@


1.36
log
@* cygcheck.cc (dll_info): Detect and report on symlinks.  Output wrong
architecture message inline with stdout for clarity.
* path.cc (is_symlink): Always reset file pointer to beginning on exit.
(readlink): Assume that file pointer is set to the beginning.
@
text
@/* path.cc

   Copyright 2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012,
   2013 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

/* The purpose of this file is to hide all the details about accessing
   Cygwin's mount table, shortcuts, etc.  If the format or location of
   the mount table, or the shortcut format changes, this is the file to
   change to match it. */

#define str(a) #a
#define scat(a,b) str(a##b)
#include <windows.h>
#include <lmcons.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <wchar.h>
#include "path.h"
#include "../cygwin/include/cygwin/version.h"
#include "../cygwin/include/sys/mount.h"
#define _NOMNTENT_MACROS
#include "../cygwin/include/mntent.h"
#include "testsuite.h"
#ifdef FSTAB_ONLY
#include <sys/cygwin.h>
#endif
#include "loadlib.h"

#ifndef FSTAB_ONLY
/* Used when treating / and \ as equivalent. */
#define isslash(ch) \
  ({ \
      char __c = (ch); \
      ((__c) == '/' || (__c) == '\\'); \
   })


static const GUID GUID_shortcut =
  {0x00021401L, 0, 0, {0xc0, 0, 0, 0, 0, 0, 0, 0x46}};

enum {
  WSH_FLAG_IDLIST = 0x01,	/* Contains an ITEMIDLIST. */
  WSH_FLAG_FILE = 0x02,		/* Contains a file locator element. */
  WSH_FLAG_DESC = 0x04,		/* Contains a description. */
  WSH_FLAG_RELPATH = 0x08,	/* Contains a relative path. */
  WSH_FLAG_WD = 0x10,		/* Contains a working dir. */
  WSH_FLAG_CMDLINE = 0x20,	/* Contains command line args. */
  WSH_FLAG_ICON = 0x40		/* Contains a custom icon. */
};

struct win_shortcut_hdr
  {
    DWORD size;		/* Header size in bytes.  Must contain 0x4c. */
    GUID magic;		/* GUID of shortcut files. */
    DWORD flags;	/* Content flags.  See above. */

    /* The next fields from attr to icon_no are always set to 0 in Cygwin
       and U/Win shortcuts. */
    DWORD attr;	/* Target file attributes. */
    FILETIME ctime;	/* These filetime items are never touched by the */
    FILETIME mtime;	/* system, apparently. Values don't matter. */
    FILETIME atime;
    DWORD filesize;	/* Target filesize. */
    DWORD icon_no;	/* Icon number. */

    DWORD run;		/* Values defined in winuser.h. Use SW_NORMAL. */
    DWORD hotkey;	/* Hotkey value. Set to 0.  */
    DWORD dummy[2];	/* Future extension probably. Always 0. */
  };

static bool
cmp_shortcut_header (win_shortcut_hdr *file_header)
{
  /* A Cygwin or U/Win shortcut only contains a description and a relpath.
     Cygwin shortcuts also might contain an ITEMIDLIST. The run type is
     always set to SW_NORMAL. */
  return file_header->size == sizeof (win_shortcut_hdr)
      && !memcmp (&file_header->magic, &GUID_shortcut, sizeof GUID_shortcut)
      && (file_header->flags & ~WSH_FLAG_IDLIST)
	 == (WSH_FLAG_DESC | WSH_FLAG_RELPATH)
      && file_header->run == SW_NORMAL;
}

int
get_word (HANDLE fh, int offset)
{
  unsigned short rv;
  unsigned r;

  SetLastError(NO_ERROR);
  if (SetFilePointer (fh, offset, 0, FILE_BEGIN) == INVALID_SET_FILE_POINTER
      && GetLastError () != NO_ERROR)
    return -1;

  if (!ReadFile (fh, &rv, 2, (DWORD *) &r, 0))
    return -1;

  return rv;
}

/*
 * Check the value of GetLastError() to find out whether there was an error.
 */
int
get_dword (HANDLE fh, int offset)
{
  int rv;
  unsigned r;

  SetLastError(NO_ERROR);
  if (SetFilePointer (fh, offset, 0, FILE_BEGIN) == INVALID_SET_FILE_POINTER
      && GetLastError () != NO_ERROR)
    return -1;

  if (!ReadFile (fh, &rv, 4, (DWORD *) &r, 0))
    return -1;

  return rv;
}

#define EXE_MAGIC ((int)*(unsigned short *)"MZ")
#define SHORTCUT_MAGIC ((int)*(unsigned short *)"L\0")
#define SYMLINK_COOKIE "!<symlink>"
#define SYMLINK_MAGIC ((int)*(unsigned short *)SYMLINK_COOKIE)

bool
is_exe (HANDLE fh)
{
  int magic = get_word (fh, 0x0);
  return magic == EXE_MAGIC;
}

bool
is_symlink (HANDLE fh)
{
  bool ret = false;
  int magic = get_word (fh, 0x0);
  if (magic != SHORTCUT_MAGIC && magic != SYMLINK_MAGIC)
    goto out;
  DWORD got;
  BY_HANDLE_FILE_INFORMATION local;
  if (!GetFileInformationByHandle (fh, &local))
    return false;
  if (magic == SHORTCUT_MAGIC)
    {
      DWORD size;
      if (!local.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
	goto out; /* Not a Cygwin symlink. */
      if ((size = GetFileSize (fh, NULL)) > 8192)
	goto out; /* Not a Cygwin symlink. */
      char buf[size];
      SetFilePointer (fh, 0, 0, FILE_BEGIN);
      if (!ReadFile (fh, buf, size, &got, 0))
	goto out;
      if (got != size || !cmp_shortcut_header ((win_shortcut_hdr *) buf))
	goto out; /* Not a Cygwin symlink. */
      /* TODO: check for invalid path contents
	 (see symlink_info::check() in ../cygwin/path.cc) */
    }
  else /* magic == SYMLINK_MAGIC */
    {
      if (!local.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)
	goto out; /* Not a Cygwin symlink. */
      char buf[sizeof (SYMLINK_COOKIE) - 1];
      SetFilePointer (fh, 0, 0, FILE_BEGIN);
      if (!ReadFile (fh, buf, sizeof (buf), &got, 0))
	goto out;
      if (got != sizeof (buf) ||
	  memcmp (buf, SYMLINK_COOKIE, sizeof (buf)) != 0)
	goto out; /* Not a Cygwin symlink. */
    }
  ret = true;
out:
  SetFilePointer (fh, 0, 0, FILE_BEGIN);
  return ret;
}

/* Assumes is_symlink(fh) is true */
bool
readlink (HANDLE fh, char *path, int maxlen)
{
  DWORD rv;
  char *buf, *cp;
  unsigned short len;
  win_shortcut_hdr *file_header;
  BY_HANDLE_FILE_INFORMATION fi;

  if (!GetFileInformationByHandle (fh, &fi)
      || fi.nFileSizeHigh != 0
      || fi.nFileSizeLow > 4 * 65536)
    return false;

  buf = (char *) alloca (fi.nFileSizeLow + 1);
  file_header = (win_shortcut_hdr *) buf;

  if (!ReadFile (fh, buf, fi.nFileSizeLow, &rv, NULL)
      || rv != fi.nFileSizeLow)
    return false;

  if (fi.nFileSizeLow > sizeof (file_header)
      && cmp_shortcut_header (file_header))
    {
      cp = buf + sizeof (win_shortcut_hdr);
      if (file_header->flags & WSH_FLAG_IDLIST) /* Skip ITEMIDLIST */
	cp += *(unsigned short *) cp + 2;
      if (!(len = *(unsigned short *) cp))
	return false;
      cp += 2;
      /* Has appended full path?  If so, use it instead of description. */
      unsigned short relpath_len = *(unsigned short *) (cp + len);
      if (cp + len + 2 + relpath_len < buf + fi.nFileSizeLow)
	{
	  cp += len + 2 + relpath_len;
	  len = *(unsigned short *) cp;
	  cp += 2;
	}
      if (*(PWCHAR) cp == 0xfeff)	/* BOM */
	{
	  len = wcstombs (NULL, (wchar_t *) (cp + 2), 0);
	  if (len == (size_t) -1 || len + 1 > maxlen)
	    return false;
	  wcstombs (path, (wchar_t *) (cp + 2), len + 1);
	}
      else if (len + 1 > maxlen)
	return false;
      else
	memcpy (path, cp, len);
      path[len] = '\0';
      return true;
    }
  else if (strncmp (buf, SYMLINK_COOKIE, strlen (SYMLINK_COOKIE)) == 0
	   && buf[fi.nFileSizeLow - 1] == '\0')
    {
      cp = buf + strlen (SYMLINK_COOKIE);
      if (*(PWCHAR) cp == 0xfeff)	/* BOM */
	{
	  len = wcstombs (NULL, (wchar_t *) (cp + 2), 0);
	  if (len == (size_t) -1 || len + 1 > maxlen)
	    return false;
	  wcstombs (path, (wchar_t *) (cp + 2), len + 1);
	}
      else if (fi.nFileSizeLow - strlen (SYMLINK_COOKIE) > (unsigned) maxlen)
	return false;
      else
	strcpy (path, cp);
      return true;
    }
  else
    return false;
}
#endif /* !FSTAB_ONLY */

#ifndef TESTSUITE
mnt_t mount_table[255];
int max_mount_entry;
#else
#  define TESTSUITE_MOUNT_TABLE
#  include "testsuite.h"
#  undef TESTSUITE_MOUNT_TABLE
#endif

inline void
unconvert_slashes (char* name)
{
  while ((name = strchr (name, '/')) != NULL)
    *name++ = '\\';
}

/* These functions aren't called when defined(TESTSUITE) which results
   in a compiler warning.  */
#ifndef TESTSUITE
inline char *
skip_ws (char *in)
{
  while (*in == ' ' || *in == '\t')
    ++in;
  return in;
}

inline char *
find_ws (char *in)
{
  while (*in && *in != ' ' && *in != '\t')
    ++in;
  return in;
}

inline char *
conv_fstab_spaces (char *field)
{
  register char *sp = field;
  while ((sp = strstr (sp, "\\040")) != NULL)
    {
      *sp++ = ' ';
      memmove (sp, sp + 3, strlen (sp + 3) + 1);
    }
  return field;
}

#ifndef FSTAB_ONLY
static struct opt
{
  const char *name;
  unsigned val;
  bool clear;
} oopts[] =
{
  {"acl", MOUNT_NOACL, 1},
  {"auto", 0, 0},
  {"binary", MOUNT_BINARY, 0},
  {"cygexec", MOUNT_CYGWIN_EXEC, 0},
  {"dos", MOUNT_DOS, 0},
  {"exec", MOUNT_EXEC, 0},
  {"ihash", MOUNT_IHASH, 0},
  {"noacl", MOUNT_NOACL, 0},
  {"nosuid", 0, 0},
  {"notexec", MOUNT_NOTEXEC, 0},
  {"nouser", MOUNT_SYSTEM, 0},
  {"override", MOUNT_OVERRIDE, 0},
  {"posix=0", MOUNT_NOPOSIX, 0},
  {"posix=1", MOUNT_NOPOSIX, 1},
  {"text", MOUNT_BINARY, 1},
  {"user", MOUNT_SYSTEM, 1}
};

static bool
read_flags (char *options, unsigned &flags)
{
  while (*options)
    {
      char *p = strchr (options, ',');
      if (p)
	*p++ = '\0';
      else
	p = strchr (options, '\0');

      for (opt *o = oopts;
	   o < (oopts + (sizeof (oopts) / sizeof (oopts[0])));
	   o++)
	if (strcmp (options, o->name) == 0)
	  {
	    if (o->clear)
	      flags &= ~o->val;
	    else
	      flags |= o->val;
	    goto gotit;
	  }
      return false;

    gotit:
      options = p;
    }
  return true;
}
#endif

bool
from_fstab_line (mnt_t *m, char *line, bool user)
{
  char *native_path, *posix_path, *fs_type;

  /* First field: Native path. */
  char *c = skip_ws (line);
  if (!*c || *c == '#')
    return false;
  char *cend = find_ws (c);
  *cend = '\0';
  native_path = conv_fstab_spaces (c);
  /* Second field: POSIX path. */
  c = skip_ws (cend + 1);
  if (!*c)
    return false;
  cend = find_ws (c);
  *cend = '\0';
  posix_path = conv_fstab_spaces (c);
  /* Third field: FS type. */
  c = skip_ws (cend + 1);
  if (!*c)
    return false;
  cend = find_ws (c);
  *cend = '\0';
  fs_type = c;
  /* Forth field: Flags. */
  c = skip_ws (cend + 1);
  if (!*c)
    return false;
  cend = find_ws (c);
  *cend = '\0';
  unsigned mount_flags = MOUNT_SYSTEM;
#ifndef FSTAB_ONLY
  if (!read_flags (c, mount_flags))
#else
  if (cygwin_internal (CW_CVT_MNT_OPTS, &c, &mount_flags))
#endif
    return false;
  if (user)
    mount_flags &= ~MOUNT_SYSTEM;
  if (!strcmp (fs_type, "cygdrive"))
    {
      for (mnt_t *sm = mount_table; sm < m; ++sm)
	if (sm->flags & MOUNT_CYGDRIVE)
	  {
	    if ((mount_flags & MOUNT_SYSTEM) || !(sm->flags & MOUNT_SYSTEM))
	      {
		if (sm->posix)
		  free (sm->posix);
		sm->posix = strdup (posix_path);
		sm->flags = mount_flags | MOUNT_CYGDRIVE;
	      }
	    return false;
	  }
      m->posix = strdup (posix_path);
      m->native = strdup ("cygdrive prefix");
      m->flags = mount_flags | MOUNT_CYGDRIVE;
    }
  else
    {
      for (mnt_t *sm = mount_table; sm < m; ++sm)
	if (!strcmp (sm->posix, posix_path))
	  {
	    /* Don't allow overriding of a system mount with a user mount. */
	    if ((sm->flags & MOUNT_SYSTEM) && !(mount_flags & MOUNT_SYSTEM))
	      return false;
	    if ((sm->flags & MOUNT_SYSTEM) != (mount_flags & MOUNT_SYSTEM))
	      continue;
	    /* Changing immutable mount points require the override flag. */
	    if ((sm->flags & MOUNT_IMMUTABLE)
		&& !(mount_flags & MOUNT_OVERRIDE))
	      return false;
	    if (mount_flags & MOUNT_OVERRIDE)
	      mount_flags |= MOUNT_IMMUTABLE;
	    if (sm->native)
	      free (sm->native);
	    sm->native = strdup (native_path);
	    sm->flags = mount_flags;
	    return false;
	  }
      m->posix = strdup (posix_path);
      unconvert_slashes (native_path);
      m->native = strdup (native_path);
      m->flags = mount_flags;
    }
  return true;
}

#ifndef FSTAB_ONLY

#define BUFSIZE 65536

static char *
get_user ()
{
  static char user[UNLEN + 1];
  char *userenv;

  user[0] = '\0';
  if ((userenv = getenv ("USER")) || (userenv = getenv ("USERNAME")))
    strncat (user, userenv, UNLEN);
  return user;
}

void
from_fstab (bool user, PWCHAR path, PWCHAR path_end)
{
  mnt_t *m = mount_table + max_mount_entry;
  char buf[BUFSIZE];

  if (!user)
    {
      /* Create a default root dir from path. */
      wcstombs (buf, path, BUFSIZE);
      unconvert_slashes (buf);
      char *native_path = buf;
      if (!strncmp (native_path, "\\\\?\\", 4))
	native_path += 4;
      if (!strncmp (native_path, "UNC\\", 4))
	*(native_path += 2) = '\\';
      m->posix = strdup ("/");
      m->native = strdup (native_path);
      m->flags = MOUNT_SYSTEM | MOUNT_BINARY | MOUNT_IMMUTABLE
		 | MOUNT_AUTOMATIC;
      ++m;
      /* Create default /usr/bin and /usr/lib entries. */
      char *trail = strchr (native_path, '\0');
      strcpy (trail, "\\bin");
      m->posix = strdup ("/usr/bin");
      m->native = strdup (native_path);
      m->flags = MOUNT_SYSTEM | MOUNT_BINARY | MOUNT_AUTOMATIC;
      ++m;
      strcpy (trail, "\\lib");
      m->posix = strdup ("/usr/lib");
      m->native = strdup (native_path);
      m->flags = MOUNT_SYSTEM | MOUNT_BINARY | MOUNT_AUTOMATIC;
      ++m;
      /* Create a default cygdrive entry.  Note that this is a user entry.
	 This allows to override it with mount, unless the sysadmin created
	 a cygdrive entry in /etc/fstab. */
      m->posix = strdup (CYGWIN_INFO_CYGDRIVE_DEFAULT_PREFIX);
      m->native = strdup ("cygdrive prefix");
      m->flags = MOUNT_BINARY | MOUNT_CYGDRIVE;
      ++m;
      max_mount_entry = m - mount_table;
    }

  PWCHAR u = wcscpy (path_end, L"\\etc\\fstab") + 10;
  if (user)
    mbstowcs (wcscpy (u, L".d\\") + 3, get_user (), BUFSIZE - (u - path));
  HANDLE h = CreateFileW (path, GENERIC_READ, FILE_SHARE_READ, NULL,
			  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
  if (h == INVALID_HANDLE_VALUE)
    return;
  char *got = buf;
  DWORD len = 0;
  /* Using BUFSIZE-1 leaves space to append two \0. */
  while (ReadFile (h, got, BUFSIZE - 1 - (got - buf),
		   &len, NULL))
    {
      char *end;

      /* Set end marker. */
      got[len] = got[len + 1] = '\0';
      /* Set len to the absolute len of bytes in buf. */
      len += got - buf;
      /* Reset got to start reading at the start of the buffer again. */
      got = buf;
      while (got < buf + len && (end = strchr (got, '\n')))
	{
	  end[end[-1] == '\r' ? -1 : 0] = '\0';
	  if (from_fstab_line (m, got, user))
	    ++m;
	  got = end + 1;
	}
      if (len < BUFSIZE - 1)
	break;
      /* We have to read once more.  Move remaining bytes to the start of
	 the buffer and reposition got so that it points to the end of
	 the remaining bytes. */
      len = buf + len - got;
      memmove (buf, got, len);
      got = buf + len;
      buf[len] = buf[len + 1] = '\0';
    }
  if (got > buf && from_fstab_line (m, got, user))
    ++m;
  max_mount_entry = m - mount_table;
  CloseHandle (h);
}
#endif /* !FSTAB_ONLY */
#endif /* !TESTSUITE */

#ifndef FSTAB_ONLY

static int
mnt_sort (const void *a, const void *b)
{
  const mnt_t *ma = (const mnt_t *) a;
  const mnt_t *mb = (const mnt_t *) b;
  int ret;

  ret = (ma->flags & MOUNT_CYGDRIVE) - (mb->flags & MOUNT_CYGDRIVE);
  if (ret)
    return ret;
  ret = (ma->flags & MOUNT_SYSTEM) - (mb->flags & MOUNT_SYSTEM);
  if (ret)
    return ret;
  return strcmp (ma->posix, mb->posix);
}

extern "C" WCHAR cygwin_dll_path[];

static void
read_mounts ()
{
/* If TESTSUITE is defined, bypass this whole function as a harness
   mount table will be provided.  */
#ifndef TESTSUITE
  HKEY setup_key;
  LONG ret;
  DWORD len;
  WCHAR path[32768];
  PWCHAR path_end;

  for (mnt_t *m1 = mount_table; m1->posix; m1++)
    {
      free (m1->posix);
      if (m1->native)
	free ((char *) m1->native);
      m1->posix = NULL;
    }
  max_mount_entry = 0;

  /* First fetch the cygwin1.dll path from the LoadLibrary call in load_cygwin.
     This utilizes the DLL search order to find a matching cygwin1.dll and to
     compute the installation path from that DLL's path. */
  if (cygwin_dll_path[0])
    wcscpy (path, cygwin_dll_path);
  /* If we can't load cygwin1.dll, check where cygcheck is living itself and
     try to fetch installation path from here.  Does cygwin1.dll exist in the
     same path?  This should only kick in if the cygwin1.dll in the same path
     has been made non-executable for the current user accidentally. */
  else if (!GetModuleFileNameW (NULL, path, 32768))
    return;
  path_end = wcsrchr (path, L'\\');
  if (path_end)
    {
      if (!cygwin_dll_path[0])
	{
	  wcscpy (path_end, L"\\cygwin1.dll");
	  DWORD attr = GetFileAttributesW (path);
	  if (attr == (DWORD) -1
	      || (attr & (FILE_ATTRIBUTE_DIRECTORY
			  | FILE_ATTRIBUTE_REPARSE_POINT)))
	    path_end = NULL;
	}
      if (path_end)
	{
	  *path_end = L'\0';
	  path_end = wcsrchr (path, L'\\');
	}
    }
  /* If we can't create a valid installation dir from that, try to fetch
     the installation dir from the setup registry key. */
  if (!path_end)
    {
      for (int i = 0; i < 2; ++i)
	if ((ret = RegOpenKeyExW (i ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER,
				  L"Software\\Cygwin\\setup", 0,
				  KEY_READ, &setup_key)) == ERROR_SUCCESS)
	  {
	    len = 32768 * sizeof (WCHAR);
	    ret = RegQueryValueExW (setup_key, L"rootdir", NULL, NULL,
				    (PBYTE) path, &len);
	    RegCloseKey (setup_key);
	    if (ret == ERROR_SUCCESS)
	      break;
	  }
      if (ret == ERROR_SUCCESS)
	path_end = wcschr (path, L'\0');
    }
  /* If we can't fetch an installation dir, bail out. */
  if (!path_end)
    return;
  *path_end = L'\0';

  from_fstab (false, path, path_end);
  from_fstab (true, path, path_end);
  qsort (mount_table, max_mount_entry, sizeof (mnt_t), mnt_sort);
#endif /* !defined(TESTSUITE) */
}

/* Return non-zero if PATH1 is a prefix of PATH2.
   Both are assumed to be of the same path style and / vs \ usage.
   Neither may be "".
   LEN1 = strlen (PATH1).  It's passed because often it's already known.

   Examples:
   /foo/ is a prefix of /foo  <-- may seem odd, but desired
   /foo is a prefix of /foo/
   / is a prefix of /foo/bar
   / is not a prefix of foo/bar
   foo/ is a prefix foo/bar
   /foo is not a prefix of /foobar
*/

static int
path_prefix_p (const char *path1, const char *path2, int len1)
{
  /* Handle case where PATH1 has trailing '/' and when it doesn't.  */
  if (len1 > 0 && isslash (path1[len1 - 1]))
    len1--;

  if (len1 == 0)
    return isslash (path2[0]) && !isslash (path2[1]);

  if (strncasecmp (path1, path2, len1) != 0)
    return 0;

  return isslash (path2[len1]) || path2[len1] == 0 || path1[len1 - 1] == ':';
}

static char *
vconcat (const char *s, va_list v)
{
  int len;
  char *rv, *arg;
  va_list save_v = v;
  int unc;

  if (!s)
    return 0;

  len = strlen (s);

  unc = isslash (*s) && isslash (s[1]);

  while (1)
    {
      arg = va_arg (v, char *);
      if (arg == 0)
	break;
      len += strlen (arg);
    }
  va_end (v);

  rv = (char *) malloc (len + 1);
  strcpy (rv, s);
  v = save_v;
  while (1)
  {
    arg = va_arg (v, char *);
    if (arg == 0)
      break;
    strcat (rv, arg);
  }
  va_end (v);

  char *d, *p;

  /* concat is only used for urls and files, so we can safely
     canonicalize the results */
  for (p = d = rv; *p; p++)
    {
      *d++ = *p;
      /* special case for URLs */
      if (*p == ':' && p[1] == '/' && p[2] == '/' && p > rv + 1)
	{
	  *d++ = *++p;
	  *d++ = *++p;
	}
      else if (isslash (*p))
	{
	  if (p == rv && unc)
	    *d++ = *p++;
	  while (p[1] == '/')
	    p++;
	}
    }
  *d = 0;

  return rv;
}

static char *
concat (const char *s, ...)
{
  va_list v;

  va_start (v, s);

  return vconcat (s, v);
}

/* This is a helper function for when vcygpath is passed what appears
   to be a relative POSIX path.  We take a Win32 CWD (either as specified
   in 'cwd' or as retrieved with GetCurrentDirectory() if 'cwd' is NULL)
   and find the mount table entry with the longest match.  We replace the
   matching portion with the corresponding POSIX prefix, and to that append
   's' and anything in 'v'.  The returned result is a mostly-POSIX
   absolute path -- 'mostly' because the portions of CWD that didn't
   match the mount prefix will still have '\\' separators.  */
static char *
rel_vconcat (const char *cwd, const char *s, va_list v)
{
  char pathbuf[MAX_PATH];
  if (!cwd || *cwd == '\0')
    {
      if (!GetCurrentDirectory (MAX_PATH, pathbuf))
	return NULL;
      cwd = pathbuf;
    }

  int max_len = -1;
  mnt_t *m, *match = NULL;

  for (m = mount_table; m->posix; m++)
    {
      if (m->flags & MOUNT_CYGDRIVE)
	continue;

      int n = strlen (m->native);
      if (n < max_len || !path_prefix_p (m->native, cwd, n))
	continue;
      max_len = n;
      match = m;
    }

  char *temppath;
  if (!match)
    // No prefix matched - best effort to return meaningful value.
    temppath = concat (cwd, "/", s, NULL);
  else if (strcmp (match->posix, "/") != 0)
    // Matched on non-root.  Copy matching prefix + remaining 'path'.
    temppath = concat (match->posix, cwd + max_len, "/", s, NULL);
  else if (cwd[max_len] == '\0')
    // Matched on root and there's no remaining 'path'.
    temppath = concat ("/", s, NULL);
  else if (isslash (cwd[max_len]))
    // Matched on root but remaining 'path' starts with a slash anyway.
    temppath = concat (cwd + max_len, "/", s, NULL);
  else
    temppath = concat ("/", cwd + max_len, "/", s, NULL);

  char *res = vconcat (temppath, v);
  free (temppath);
  return res;
}

/* Convert a POSIX path in 's' to an absolute Win32 path, and append
   anything in 'v' to the end, returning the result.  If 's' is a
   relative path then 'cwd' is used as the working directory to make
   it absolute.  Pass NULL in 'cwd' to use GetCurrentDirectory.  */
static char *
vcygpath (const char *cwd, const char *s, va_list v)
{
  int max_len = -1;
  mnt_t *m, *match = NULL;

  if (!max_mount_entry)
    read_mounts ();
  char *path;
  if (s[0] == '.' && isslash (s[1]))
    s += 2;

  if (s[0] == '/' || s[1] == ':')	/* FIXME: too crude? */
    path = vconcat (s, v);
  else
    path = rel_vconcat (cwd, s, v);

  if (!path)
    return NULL;

  if (strncmp (path, "/./", 3) == 0)
    memmove (path + 1, path + 3, strlen (path + 3) + 1);

  for (m = mount_table; m->posix; m++)
    {
      int n = strlen (m->posix);
      if (n < max_len || !path_prefix_p (m->posix, path, n))
	continue;
      if ((m->flags & MOUNT_CYGDRIVE)
	  && ((int) strlen (path) < n + 2
	      || path[n] != '/'
	      || !isalpha (path[n + 1])
	      || path[n + 2] != '/'))
	continue;
      max_len = n;
      match = m;
    }

  char *native;
  if (match == NULL)
    native = strdup (path);
  else if (max_len == (int) strlen (path))
    native = strdup (match->native);
  else if (match->flags & MOUNT_CYGDRIVE)
    {
      char drive[3] = { path[max_len + 1], ':', '\0' };
      native = concat (drive, path + max_len + 2, NULL);
    }
  else if (isslash (path[max_len]))
    native = concat (match->native, path + max_len, NULL);
  else
    native = concat (match->native, "\\", path + max_len, NULL);
  free (path);

  unconvert_slashes (native);
  for (char *s = strstr (native + 1, "\\.\\"); s && *s; s = strstr (s, "\\.\\"))
    memmove (s + 1, s + 3, strlen (s + 3) + 1);
  return native;
}

char *
cygpath_rel (const char *cwd, const char *s, ...)
{
  va_list v;

  va_start (v, s);

  return vcygpath (cwd, s, v);
}

char *
cygpath (const char *s, ...)
{
  va_list v;

  va_start (v, s);

  return vcygpath (NULL, s, v);
}

static mnt_t *m = NULL;

extern "C" FILE *
setmntent (const char *, const char *)
{
  m = mount_table;
  if (!max_mount_entry)
    read_mounts ();
  return NULL;
}

extern "C" struct mntent *
getmntent (FILE *)
{
  static mntent mnt;
  if (!m->posix)
    return NULL;

  mnt.mnt_fsname = (char *) m->native;
  mnt.mnt_dir = (char *) m->posix;
  if (!mnt.mnt_type)
    mnt.mnt_type = (char *) malloc (16);
  if (!mnt.mnt_opts)
    mnt.mnt_opts = (char *) malloc (64);

  strcpy (mnt.mnt_type,
	  (char *) ((m->flags & MOUNT_SYSTEM) ? "system" : "user"));

  if (!(m->flags & MOUNT_BINARY))
    strcpy (mnt.mnt_opts, (char *) "text");
  else
    strcpy (mnt.mnt_opts, (char *) "binary");

  if (m->flags & MOUNT_CYGWIN_EXEC)
    strcat (mnt.mnt_opts, (char *) ",cygexec");
  else if (m->flags & MOUNT_EXEC)
    strcat (mnt.mnt_opts, (char *) ",exec");
  else if (m->flags & MOUNT_NOTEXEC)
    strcat (mnt.mnt_opts, (char *) ",notexec");

  if (m->flags & MOUNT_NOACL)
    strcat (mnt.mnt_opts, (char *) ",noacl");

  if (m->flags & MOUNT_NOPOSIX)
    strcat (mnt.mnt_opts, (char *) ",posix=0");

  if (m->flags & (MOUNT_AUTOMATIC | MOUNT_CYGDRIVE))
    strcat (mnt.mnt_opts, (char *) ",auto");

  mnt.mnt_freq = 1;
  mnt.mnt_passno = 1;
  m++;
  return &mnt;
}

#endif /* !FSTAB_ONLY */
@


1.35
log
@	* Merge in cygwin-64bit-branch.
@
text
@d143 1
d146 1
a146 1
    return false;
d155 1
a155 1
	return false; /* Not a Cygwin symlink. */
d157 1
a157 1
	return false; /* Not a Cygwin symlink. */
d161 1
a161 1
	return false;
d163 1
a163 1
	return false; /* Not a Cygwin symlink. */
d170 1
a170 1
	return false; /* Not a Cygwin symlink. */
d174 1
a174 1
	return false;
d177 1
a177 1
	return false; /* Not a Cygwin symlink. */
d179 4
a182 1
  return true;
d203 1
a203 2
  if (SetFilePointer (fh, 0L, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER
      || !ReadFile (fh, buf, fi.nFileSizeLow, &rv, NULL)
@


1.34
log
@Update copyrights
@
text
@d3 2
a4 2
   Copyright 2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
   Red Hat, Inc.
d28 1
d845 1
a845 1
	  && (strlen (path) < n + 2
d921 2
a922 1
  strcpy (mnt.mnt_type, (char *) (m->flags & MOUNT_SYSTEM) ? "system" : "user");
@


1.33
log
@	* path.cc (vcygpath): Handle cygdrive prefix.
@
text
@d3 2
a4 2
   Copyright 2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009, 2010,
   2011, 2012 Red Hat, Inc.
@


1.32
log
@	* configure.in: Add check for MINGW_CXX.  Remove libiconv check.
	* configure: Regenerate.
	* Makefile.in: Remove references to mingw and w32api directories.
	Use MINGW_CXX instead of mingw script to build MINGW_BINS.
	Check for libiconv with $CC --print-file-name.
	* cygcheck.cc: Use relative include paths for Cygwin headers.
	* path.cc: Ditto.
	* strace.cc: Ditto
	* mingw: Remove.
@
text
@d4 1
a4 1
   2011 Red Hat, Inc.
a839 3
      if (m->flags & MOUNT_CYGDRIVE)
	continue;

d843 6
d858 5
@


1.31
log
@Clean up whitespace.
@
text
@d26 3
a28 3
#include "cygwin/include/cygwin/version.h"
#include "cygwin/include/sys/mount.h"
#include "cygwin/include/mntent.h"
@


1.31.2.1
log
@	* cygcheck.cc: Change include path to not depend on installed
	cygwin/version.h.
	(_NOMNTENT_MACROS): Define before including mntent.h.
	* path.cc (_NOMNTENT_MACROS): Ditto.
	* dump_setup.cc: Add temporary workaround to handle older Mingw header
	files on Fedora 17.
	* strace.cc: Ditto.
@
text
@a27 1
#define _NOMNTENT_MACROS
@


1.31.2.2
log
@Pull in changes from HEAD
@
text
@d26 2
a27 2
#include "../cygwin/include/cygwin/version.h"
#include "../cygwin/include/sys/mount.h"
d29 1
a29 1
#include "../cygwin/include/mntent.h"
@


1.31.2.3
log
@Pull in change from HEAD
@
text
@d4 1
a4 1
   2011, 2012 Red Hat, Inc.
d841 3
a846 6
      if ((m->flags & MOUNT_CYGDRIVE)
	  && (strlen (path) < n + 2
	      || path[n] != '/'
	      || !isalpha (path[n + 1])
	      || path[n + 2] != '/'))
	continue;
a855 5
  else if (match->flags & MOUNT_CYGDRIVE)
    {
      char drive[3] = { path[max_len + 1], ':', '\0' };
      native = concat (drive, path + max_len + 2, NULL);
    }
@


1.31.2.4
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
   Red Hat, Inc.
@


1.31.2.5
log
@	Throughout, fix type problems on 32 and 64 bit.  Except:
	* ssp.c: Disable entire functionality on x86_64 for now.
@
text
@d3 2
a4 2
   Copyright 2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012,
   2013 Red Hat, Inc.
d845 1
a845 1
	  && ((int) strlen (path) < n + 2
d921 1
a921 2
  strcpy (mnt.mnt_type,
	  (char *) ((m->flags & MOUNT_SYSTEM) ? "system" : "user"));
@


1.30
log
@	* cygcheck.cc (handle_unique_object_name): Avoid a compiler warning.
	(dump_sysinfo): Ditto.
	* loadlib.h (_load_sys_library): Mark as used, to avoid a compiler
	warning.
	* path.cc (oopt): Gurad with !FSTAB_ONLY to avoid a compiler warning.
	(read_flags): Ditto.
@
text
@d202 1
a202 1
  
d208 1
a208 1
        cp += *(unsigned short *) cp + 2;
d210 1
a210 1
        return false;
d215 5
a219 5
        {
          cp += len + 2 + relpath_len;
          len = *(unsigned short *) cp;
          cp += 2;
        }
d228 1
a228 1
        return false;
d235 1
a235 1
           && buf[fi.nFileSizeLow - 1] == '\0')
d250 1
a250 1
    }      
d336 1
a336 1
        *p++ = '\0';
d338 1
a338 1
        p = strchr (options, '\0');
d341 10
a350 10
           o < (oopts + (sizeof (oopts) / sizeof (oopts[0])));
           o++)
        if (strcmp (options, o->name) == 0)
          {
            if (o->clear)
              flags &= ~o->val;
            else
              flags |= o->val;
            goto gotit;
          }
d408 1
a408 1
	      	if (sm->posix)
d431 1
a431 1
	    	&& !(mount_flags & MOUNT_OVERRIDE))
d478 1
a478 1
        native_path += 4;
d480 1
a480 1
        *(native_path += 2) = '\\';
d499 2
a500 2
         This allows to override it with mount, unless the sysadmin created
         a cygdrive entry in /etc/fstab. */
d512 1
a512 1
                          OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
d519 1
a519 1
                   &len, NULL))
d530 6
a535 6
        {
          end[end[-1] == '\r' ? -1 : 0] = '\0';
          if (from_fstab_line (m, got, user))
            ++m;
          got = end + 1;
        }
d537 1
a537 1
        break;
d539 2
a540 2
         the buffer and reposition got so that it points to the end of
         the remaining bytes. */
d562 1
a562 1
  
d771 1
a771 1
        return NULL;
d881 1
a881 1
  
d883 1
a883 1
  
@


1.29
log
@	* loadlib.h: New header implementing safe LoadLibrary calls.
	Include throughout files using LoadLibrary function.
	* cygcheck.cc (dump_sysinfo): Retrieve kernel32.dll handle via
	GetModuleHandle, rather than using LoadLibrary.
	* cygpath.cc (get_long_name): Ditto.
	(do_sysfolders): Append .dll suffix in LoadLibrary call.
	* ldh.cc (WinMain): Use LoadLibraryExW with DONT_RESOLVE_DLL_REFERENCES
	to avoid loading malicious library code.
	* locale.cc (print_locale_with_codeset): Change way to retrieve
	kernel32.dll path.
@
text
@d3 2
a4 1
   Copyright 2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009, 2010 Red Hat, Inc.
d303 1
d358 1
a584 1
  HMODULE h;
@


1.28
log
@	* path.cc: Include sys/cygwin.h if built for mount(1).
	(struct opt): Add "dos" and "ihash" options.
	(from_fstab_line): Call cygwin_internal rather than read_flags if
	built for mount(1).
@
text
@d32 1
@


1.27
log
@	* path.cc (read_mounts): Skip unnecessary test if path has been
	fetched from loaded cygwin1.dll.
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009 Red Hat, Inc.
d29 3
d312 1
d314 1
d389 1
d391 3
@


1.26
log
@	* cygcheck.cc (cygwin_dll_path): New global variable.
	(load_cygwin): Fetch cygwin DLL path and store in cygwin_dll_path.
	* strace.cc: Full ditto.
	* path.cc (read_mounts): First use the path stored in cygwin_dll_path,
	if available.  Then fall back to fetching own path.  Add comment.
	Drop printing warnings since they look funny in strace output.
@
text
@d597 10
a606 6
      wcscpy (path_end, L"\\cygwin1.dll");
      DWORD attr = GetFileAttributesW (path);
      if (attr == (DWORD) -1
	  || (attr & (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_REPARSE_POINT)))
	path_end = NULL;
      else
@


1.25
log
@	* path.cc (read_mounts): First get installation path from own path.
	Check if cygwin1.dll exists in same directory.  Only if not, try to
	get installation path from setup registry key.  Add ample warnings.
@
text
@d559 2
d572 1
d583 10
a592 3
  /* First check where cygcheck is living itself and try to fetch installation
     path from here.  Does cygwin1.dll exist in the same path? */
  if (!GetModuleFileNameW (NULL, path, 32768))
d625 1
a625 6
	{
	  printf ("\n"
"Warning!  Computing mount points from setup registry key. Mount points might\n"
"be wrong if you have multiple Cygwin installations on this machine.\n");
	  path_end = wcschr (path, L'\0');
	}
d629 1
a629 6
    {
      printf ("\n"
"Warning!  Could not generate mount table since no valid installation path\n"
"could be found.\n");
      return;
    }
@


1.24
log
@	* mount.cc (do_mount): Replace --no-executable flag with notexec
	mount option in hint for remote filesystems.
	* path.cc (getmntent): Fix typo (noexec -> notexec).
@
text
@d580 6
a585 15
  for (int i = 0; i < 2; ++i)
    if ((ret = RegOpenKeyExW (i ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER,
			      L"Software\\Cygwin\\setup", 0,
			      KEY_READ, &setup_key)) == ERROR_SUCCESS)
      {
	len = 32768 * sizeof (WCHAR);
	ret = RegQueryValueExW (setup_key, L"rootdir", NULL, NULL,
				(PBYTE) path, &len);
	RegCloseKey (setup_key);
	if (ret == ERROR_SUCCESS)
	  break;
      }
  if (ret == ERROR_SUCCESS)
    path_end = wcschr (path, L'\0');
  else
d587 6
a592 4
      if (!GetModuleFileNameW (NULL, path, 32768))
	return;
      path_end = wcsrchr (path, L'\\');
      if (path_end)
d598 25
d624 6
a629 1
    return;
@


1.23
log
@	* Makefile.in (path-mount.o): Add a rule to build stripped down version
	of path.cc for usage in mount.
	(mount.exe): Add dependency to path-mount.o.
	* mount.cc (force): Convert to bool value.  Accommodate throughout.
	(from_fstab): New function.
	(do_mount_from_fstab): New function.
	(longopts): Add --all option.
	(opts): Add -a option.
	(usage): Document -a/--all option.
	(main): Handle -a option as well as single parameter.
	* path.cc: Add FSTAB_ONLY conditional to allow building path-mount.o.
	(mount_table): Remove static storage class.
	(max_mount_entry): Ditto.
	(root_here): Unused.  Remove.
	(from_fstab_line): Remove static.
	* path.h (struct mnt_t): Define here rather than in path.cc.
	(from_fstab_line): Declare.
	(mount_table): Declare.
	(max_mount_entry): Declare.
	* utils.sgml (mount): Document -a/--all option and mounting of single
	path from fstab files.
@
text
@d885 1
a885 1
    strcat (mnt.mnt_opts, (char *) ",noexec");
@


1.22
log
@	* path.cc (oopts): Sort alphabetically, add missing "auto" and
	"override" entries.
	(from_fstab_line): Handle mount points same as Cygwin itself.  Use
	"cygdrive prefix" as posix name of cygdrive prefix.
	(from_fstab): Add auto entries for /usr/bin and /usr/lib.  Add
	MOUNT_AUTOMATIC and MOUNT_IMMUTABLE flags to default root dir entry.
	Use "cygdrive prefix" as posix name of default cygdrive prefix.
	(getmntent): Allocate smaller buffers.  Align output closer to output
	of mount(1).
@
text
@d30 1
d249 1
a249 7

struct mnt_t
{
  char *native;
  char *posix;
  unsigned flags;
};
d252 2
a253 2
static mnt_t mount_table[255];
static int max_mount_entry;
a259 2
mnt_t *root_here = NULL;

d351 1
a351 1
static bool
d436 2
d538 4
a541 1
#endif
d901 2
@


1.21
log
@	* path.cc (readlink): Accommodate new UTF-16 symlinks.
@
text
@d312 2
a313 2
  {"user", MOUNT_SYSTEM, 1},
  {"nouser", MOUNT_SYSTEM, 0},
d315 1
a315 1
  {"text", MOUNT_BINARY, 1},
d317 2
d320 3
a322 4
  {"cygexec", MOUNT_CYGWIN_EXEC, 0},
  {"nosuid", 0, 0},
  {"acl", MOUNT_NOACL, 1},
  {"noacl", MOUNT_NOACL, 0},
d324 2
a325 1
  {"posix=0", MOUNT_NOPOSIX, 0}
d410 1
a410 1
      m->native = strdup (".");
d416 1
a416 1
	if (!strcasecmp (sm->posix, posix_path))
d418 15
a432 7
	    if ((mount_flags & MOUNT_SYSTEM) || !(sm->flags & MOUNT_SYSTEM))
	      {
	      	if (sm->native)
		  free (sm->native);
		sm->native = strdup (native_path);
		sm->flags = mount_flags;
	      }
d475 14
a488 1
      m->flags = MOUNT_SYSTEM | MOUNT_BINARY;
d494 1
a494 1
      m->native = strdup (".");
d871 1
a871 1
    mnt.mnt_type = (char *) malloc (1024);
d873 4
a876 5
    mnt.mnt_opts = (char *) malloc (1024);
  if (m->flags & MOUNT_SYSTEM)
    strcpy (mnt.mnt_type, (char *) "system");
  else
    strcpy (mnt.mnt_type, (char *) "user");
d878 1
a878 1
    strcpy (mnt.mnt_opts, (char *) "textmode");
d880 2
a881 1
    strcpy (mnt.mnt_opts, (char *) "binmode");
d888 2
a889 3
  if ((m->flags & MOUNT_CYGDRIVE))	/* cygdrive */
    strcat (mnt.mnt_opts, (char *) ",cygdrive");
  if ((m->flags & MOUNT_NOACL))
d891 2
a892 1
  if ((m->flags & MOUNT_NOPOSIX))
d894 4
@


1.20
log
@	* path.cc (from_fstab): Use wcstombs/mbstowcs instead of
	WideCharToMultiByte/MultiByteToWideChar to accommodate current locale.
@
text
@d186 1
a186 1
      || fi.nFileSizeLow > 8192)
d214 8
a221 1
      if (len + 1 > maxlen)
d223 2
a224 1
      memcpy (path, cp, len);
a228 1
           && fi.nFileSizeLow - strlen (SYMLINK_COOKIE) <= (unsigned) maxlen
d231 12
a242 1
      strcpy (path, &buf[strlen (SYMLINK_COOKIE)]);
@


1.19
log
@* cygcheck.cc (pathlike::check_existence): Remove class name from declaration.
(display_internet_error): Use proper format specifier for DWORD.
(environ): Remove unneeded declaration.
(main): Use brace around nested if to avoid an overly-helpful compiler warning.
* dump_setup.cc (parse_filename): Reorganize nested if to avoid an
overly-helpful compiler warning.
* path.cc (GUID_shortcut): Use braces around part of initializer which needs
them.
(conv_fstab_spaces): Parenthesize assignment in while loop to avoid a compiler
warning.
(struct opt): Make static.
* ps.cc (main): Reorganize nested if to avoid an overly-helpful compiler
warning.
* regtool.cc: Make some anonymous structs static to avoid a compiler warning.
* ssp.c (lookup_thread_id): Initialize *tix to zero to avoid potential
uninitialized use.
* strace.cc (add_child): Use proper format specifier for DWORD.
(remove_child): Ditto.
(proc_child): Ditto.
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003, 2005, 2006, 2007, 2008 Red Hat, Inc.
d438 1
a438 2
      WideCharToMultiByte (GetACP (), 0, path, -1, buf, BUFSIZE,
			   NULL, NULL);
d461 1
a461 2
    MultiByteToWideChar (GetACP (), 0, get_user (), -1,
    			 wcscpy (u, L".d\\") + 3, BUFSIZE - (u - path));
@


1.18
log
@	* Makefile.in (cygcheck.exe): Link against ntdll.
	* bloda.cc: Use statically linked functions throughout.
	* cygpath.cc: Drop 9x considerations.
	* mkgroup.c: Revamp.  Redefine -l and -d options to take optional
	machine and domain parameters.  Redefine -c to work always, using
	token information.  Add -L, -D, -C to create unique groupnames in
	domain\group syntax.  Add -S option to define domain\group separator
	char.  Ignore -u and -s options.
	* mkpasswd.c: Revamp.  Redefine -l and -d options to take optional
	machine and domain parameters.  Redefine -c to work always, using
	token information.  Add -L, -D, -C to create unique usernames in
	domain\user syntax.  Add -S option to define domain\user separator
	char.  Ignore -g and -s options.  Prefer to take homedir from $HOME
	over $HOMEDRIVE/$HOMEPATH.
	* path.cc (oopts): Add "acl", "noacl", "posix=0" and "posix=1" options.
	(getmntent): Accomodate throughout.
	* ps.cc: Fix copyright dates.
	* utils.sgml: Fix text for mkgroup and mkpasswd.
@
text
@d38 2
a39 2
static const GUID GUID_shortcut
			= { 0x00021401L, 0, 0, 0xc0, 0, 0, 0, 0, 0, 0, 0x46 };
d279 1
a279 1
  while (sp = strstr (sp, "\\040"))
d287 1
a287 1
struct opt
d506 1
a506 1
int
@


1.17
log
@	* mount.cc (do_mount): Remove MOUNT_ENC code.
	(oopts): Remove "managed" option.
	(mount_commands): Drop "managed" handling.
	* path.cc (oopts): Remove "managed" option.
	(getmntent): Remove MOUNT_ENC code.
@
text
@d301 5
a305 1
  {"nosuid", 0, 0}
d851 4
@


1.16
log
@	* cygcheck.cc (dump_sysinfo): Fix multiple Cygwin DLL test.
	* path.cc: Fetch mount points from fstab files instead of from
	registry.  Use adapted functions copied from Cygwin DLL.
	(mnt_t): Drop issys member.  Define as "mnt_t" instead of "struct mnt_t"
	subsequently.
	(max_mount_entry): New variable.
	(unconvert_slashes): Move to earlier location in file.  Make inline.
	(find2): Remove.
	(get_cygdrive0): Remove.
	(get_cygdrive): Remove.
	(skip_ws): New function.
	(find_ws): Ditto.
	(conv_fstab_spaces): Ditto.
	(read_flags): Ditto.
	(from_fstab_line): Ditto.
	(get_user): Ditto.
	(from_fstab): Ditto.
	(mnt_sort): Ditto.
	(read_mounts): Drop old registry code.  Fetch
	"Software\Cygwin\Setup\rootdir" value from HKCU or HKLM key.  Use
	rootdir extracted from module path as fallback.  Call from_fstab for
	nouser and user mount points.
	(setmntent): Check max_mount_entry to test if read_mounts must be
	called.
	(getmntent): Use MOUNT_SYSTEM flag instead of mnt_t's issys member.
@
text
@d301 1
a301 2
  {"nosuid", 0, 0},
  {"managed", MOUNT_ENC, 0}
a844 2
  if (m->flags & MOUNT_ENC)
    strcat (mnt.mnt_opts, ",managed");
@


1.15
log
@	* path.cc: Include malloc.h for alloca.
	(is_symlink): Rewrite.  Just read the whole file in memory rather
	than by parts.  Account for an ITEMIDLIST if present, as well as
	the new style of Cygwin shortcut supporting targets > MAX_PATH.
@
text
@d19 1
d23 1
d231 6
a236 7
typedef struct mnt
  {
    const char *native;
    char *posix;
    unsigned flags;
    int issys;
  } mnt_t;
d240 1
d247 8
a254 1
struct mnt *root_here = NULL;
d259 2
a260 2
static char *
find2 (HKEY rkey, unsigned *flags, char *what)
d262 4
a265 4
  char *retval = 0;
  DWORD retvallen = 0;
  DWORD type;
  HKEY key;
d267 7
a273 2
  if (RegOpenKeyEx (rkey, what, 0, KEY_READ, &key) != ERROR_SUCCESS)
    return 0;
d275 5
a279 2
  if (RegQueryValueEx (key, "native", 0, &type, 0, &retvallen)
      == ERROR_SUCCESS)
d281 2
a282 7
      retval = (char *) malloc (MAX_PATH + 1);
      if (RegQueryValueEx (key, "native", 0, &type, (BYTE *) retval, &retvallen)
	  != ERROR_SUCCESS)
	{
	  free (retval);
	  retval = 0;
	}
d284 2
d287 17
a303 2
  retvallen = sizeof (flags);
  RegQueryValueEx (key, "flags", 0, &type, (BYTE *)flags, &retvallen);
d305 23
a327 1
  RegCloseKey (key);
d329 4
a332 1
  return retval;
d335 2
a336 2
static LONG
get_cygdrive0 (HKEY key, const char *what, void *val, DWORD len)
d338 72
a409 2
  LONG status = RegQueryValueEx (key, what, 0, 0, (BYTE *)val, &len);
  return status;
d412 4
a415 2
static mnt *
get_cygdrive (HKEY key, mnt *m, int issystem)
d417 83
a499 9
  if (get_cygdrive0 (key, CYGWIN_INFO_CYGDRIVE_FLAGS, &m->flags,
		     sizeof (m->flags)) != ERROR_SUCCESS) {
    free (m->posix);
    return m;
  }
  get_cygdrive0 (key, CYGWIN_INFO_CYGDRIVE_PREFIX, m->posix, MAX_PATH);
  m->native = strdup (".");
  m->issys = issystem;
  return m + 1;
d503 16
d525 5
a529 5
  DWORD posix_path_size;
  int res;
  struct mnt *m = mount_table;
  DWORD disposition;
  char buf[10000];
d531 1
a531 2
  root_here = NULL;
  for (mnt *m1 = mount_table; m1->posix; m1++)
d538 1
d540 20
a559 16
  /* Loop through subkeys */
  /* FIXME: we would like to not check MAX_MOUNTS but the heap in the
     shared area is currently statically allocated so we can't have an
     arbitrarily large number of mounts. */
  for (int issystem = 0; issystem <= 1; issystem++)
    {
      sprintf (buf, "Software\\%s\\%s\\%s",
	       CYGWIN_INFO_CYGNUS_REGISTRY_NAME,
	       CYGWIN_INFO_CYGWIN_REGISTRY_NAME,
	       CYGWIN_INFO_CYGWIN_MOUNT_REGISTRY_NAME);

      HKEY key = issystem ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER;
      if (RegCreateKeyEx (key, buf, 0, (LPTSTR) "Cygwin", 0, KEY_READ,
			  0, &key, &disposition) != ERROR_SUCCESS)
	break;
      for (int i = 0; ;i++, m++)
d561 2
a562 31
	  m->posix = (char *) malloc (MAX_PATH + 1);
	  posix_path_size = MAX_PATH;
	  /* FIXME: if maximum posix_path_size is 256, we're going to
	     run into problems if we ever try to store a mount point that's
	     over 256 but is under MAX_PATH. */
	  res = RegEnumKeyEx (key, i, m->posix, &posix_path_size, NULL,
			      NULL, NULL, NULL);

	  if (res == ERROR_NO_MORE_ITEMS)
	    {
	      m = get_cygdrive (key, m, issystem);
	      m->posix = NULL;
	      break;
	    }

	  if (!*m->posix)
	    goto no_go;
	  else if (res != ERROR_SUCCESS)
	    break;
	  else
	    {
	      m->native = find2 (key, &m->flags, m->posix);
	      m->issys = issystem;
	      if (!m->native)
		goto no_go;
	    }
	  continue;
	no_go:
	  free (m->posix);
	  m->posix = NULL;
	  m--;
a563 1
      RegCloseKey (key);
d565 7
a676 7
static void
unconvert_slashes (char* name)
{
  while ((name = strchr (name, '/')) != NULL)
    *name++ = '\\';
}

d697 1
a697 1
  struct mnt *m, *match = NULL;
d740 1
a740 1
  struct mnt *m, *match = NULL;
d742 1
a742 1
  if (!mount_table[0].posix)
d808 1
a808 1
static mnt *m = NULL;
d814 1
a814 1
  if (!m->posix)
d832 3
a834 1
  if (!m->issys)
a835 2
  else
    strcpy (mnt.mnt_type, (char *) "system");
@


1.14
log
@	* cygcheck.cc (dirname): New static function.
	(find_app_on_path): Use SYMLINK_MAX.  Resolve symlink relative
	to link's location.  Adjust to the fact that cygpath already
	normalizes its return value.
	* path.cc (rel_vconcat): Add cwd parameter, and use it instead
	of calling GetCurrentDirectory() if possible.  Rename throughout.
	(vcygpath): Rename from cygpath and accept cwd and va_list.  Pass
	cwd on to rel_vconcat().
	(cygpath_rel): New front end for vcygpath.
	(cygpath): Ditto.
	* path.h (cygpath_rel): Declare.
	(SYMLINK_MAX): Define to 4095.
@
text
@d21 1
d176 10
a185 2
  int got;
  int magic = get_word (fh, 0x0);
d187 2
a188 12
  if (magic == SHORTCUT_MAGIC)
    {
      int offset = get_word (fh, 0x4c);
      int slen = get_word (fh, 0x4c + offset + 2);
      if (slen >= maxlen)
	{
	  SetLastError (ERROR_FILENAME_EXCED_RANGE);
	  return false;
	}
      if (SetFilePointer (fh, 0x4c + offset + 4, 0, FILE_BEGIN) ==
	  INVALID_SET_FILE_POINTER && GetLastError () != NO_ERROR)
	return false;
d190 7
a196 11
      if (!ReadFile (fh, path, slen, (DWORD *) &got, 0))
	return false;
      else if (got < slen)
	{
	  SetLastError (ERROR_READ_FAULT);
	  return false;
	}
      else
	path[got] = '\0';
    }
  else if (magic == SYMLINK_MAGIC)
d198 27
a224 23
      char cookie_buf[sizeof (SYMLINK_COOKIE) - 1];

      if (SetFilePointer (fh, 0, 0, FILE_BEGIN) == INVALID_SET_FILE_POINTER
	  && GetLastError () != NO_ERROR)
	return false;

      if (!ReadFile (fh, cookie_buf, sizeof (cookie_buf), (DWORD *) &got, 0))
	return false;
      else if (got == sizeof (cookie_buf)
	       && memcmp (cookie_buf, SYMLINK_COOKIE, sizeof (cookie_buf)) == 0)
	{
	  if (!ReadFile (fh, path, maxlen, (DWORD *) &got, 0))
	    return false;
	  else if (got >= maxlen)
	    {
	      SetLastError (ERROR_FILENAME_EXCED_RANGE);
	      path[0] = '\0';
	      return false;
	    }
	  else
	    path[got] = '\0';
	}
    }
a226 1
  return true;
@


1.13
log
@	* Makefile.in: Add a 'check' target that builds and runs
	testsuite.exe from path-testsuite.o and testsuite.o.
	* path.cc: Include testsuite.h.
	(struct mnt): Change to a mnt_t typedef and don't define
	mount_table when TESTSUITE is defined.
	(find2): Don't include when TESTSUITE is defined to avoid warning.
	(get_cygdrive0): Ditto.
	(get_cygdrive): Ditto.
	(read_mounts): Provide empty implementation when TESTSUITE is
	defined.
	(vconcat): Use the isslash macro.
	(unconvert_slashes): New helper to convert to backslashses.
	(rel_vconcat): Handle relative paths more gracefully.
	(cygpath): Skip a leading "./" sequence.  Avoid double-slashes.
	Normalize final output to backslashes and remove redundant path
	sequences.
	* testsuite.cc: New file implementing testsuite driver.
	* testsuite.h: New header implementing harness mount table and
	series of tests.
@
text
@d489 8
d498 1
a498 1
rel_vconcat (const char *s, va_list v)
d500 7
a506 3
  char path[MAX_PATH + 1];
  if (!GetCurrentDirectory (MAX_PATH, path))
    return NULL;
d511 1
a511 4
  if (s[0] == '.' && isslash (s[1]))
    s += 2;

  for (m = mount_table; m->posix ; m++)
d517 1
a517 1
      if (n < max_len || !path_prefix_p (m->native, path, n))
d526 1
a526 1
    temppath = concat (path, "/", s, NULL);
d529 2
a530 2
    temppath = concat (match->posix, path + max_len, "/", s, NULL);
  else if (path[max_len] == '\0')
d533 1
a533 1
  else if (isslash (path[max_len]))
d535 1
a535 1
    temppath = concat (path + max_len, "/", s, NULL);
d537 1
a537 1
    temppath = concat ("/", path + max_len, "/", s, NULL);
d544 6
a549 2
char *
cygpath (const char *s, ...)
a550 1
  va_list v;
a555 1
  va_start (v, s);
d563 1
a563 1
    path = rel_vconcat (s, v);
d571 1
a571 1
  for (m = mount_table; m->posix ; m++)
d600 20
@


1.12
log
@* cygcheck.cc (pathlike): New class.
(paths): Redefine as type pathlike.
(display_error): Declare a few different ways to allow more flexible usage
throughout.
(display_error_fmt): New function for those cases where C++ just isn't enough.
(add_path): Rewrite to allocate pathlike paths.  Always tack on a trailing
slash since that's what everyone who uses it wants.  NULL terminate the path
list.  Register "it's a system path" field.
(init_path): Call add_path with info regarding whether path is a system path or
not.
(pathlike::check_existence): Move into pathlike class.  Accept file and
extension arguments to build up path on the fly.  Modify other arguments.
(find_on_path): Constify return value and appropriate arguments.  Eliminate
short-circuit for fully-qualified paths.  Simplify loop which iterates over
path.
(already_did): Constify argument.
(track_down): Ditto.  Regularize some error messages.
(find_app_on_path): Ditto.
(cygcheck): Constify argument.  Use 20th century string handling functions.
(dump_sysinfo): Remove odd inclusion of '\\bin' "Just in case".  Accommodate
change of paths to pathlike.
* path.cc (isslash): Rename from SLASH_P and use throughout.
(rel_vconcat): Front-end to vconcat which prepends cwd to path before passing
along for conversion to native windows.
(cygpath): Remove "./" test.  Call rel_vconcat if filename appears to be
relative.
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003, 2005, 2006, 2007 Red Hat, Inc.
d25 1
d231 1
a231 1
static struct mnt
d237 9
a245 1
  } mount_table[255];
d249 3
d303 1
d308 3
d377 1
d459 1
a459 1
      else if (*p == '/' || *p == '\\')
d482 7
d514 15
a528 5
  if (match)
    strcpy (path, match->posix);

  if (!isslash (strchr (path, '\0')[-1]))
    strcat (path, "/");
a529 1
  char *temppath = concat (path, s, NULL);
d546 3
d577 2
d583 3
@


1.11
log
@	* cygcheck.cc (get_word, get_dword): Move to path.cc.
	(LINK_EXTENSION): New macro.
	(check_existence): New static function.
	(find_on_path): Check for symbolic links if asked.
	(dll_info): New error handling.
	(track_down): Only call dll_info() for executables, display
	an error for symlinks, and print magic number for others.
	(find_app_on_path): New static function.
	(cygcheck, dump_sysinfo): Call find_app_on_path() instead of
	find_on_path().
	* path.cc (cmp_shortcut_header): New static function.
	(get_word, get_dword): Moved from cygcheck.cc.
	(EXE_MAGIC, SHORTCUT_MAGIC, SYMLINK_COOKIE, SYMLINK_MAGIC): New
	macros.
	(is_exe, is_symlink, readlink): New functions.
	* path.h (is_exe, is_symlink, readlink): Declare.
	(get_word, get_dword): Ditto.
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003, 2005 Red Hat, Inc.
d27 1
a27 1
#define SLASH_P(ch) \
d153 1
a153 1
         (see symlink_info::check() in ../cygwin/path.cc) */
d164 1
a164 1
          memcmp (buf, SYMLINK_COOKIE, sizeof (buf)) != 0)
d187 2
a188 2
          INVALID_SET_FILE_POINTER && GetLastError () != NO_ERROR)
        return false;
d191 1
a191 1
        return false;
d206 1
a206 1
        return false;
d209 1
a209 1
        return false;
d214 1
a214 1
            return false;
d381 1
a381 1
  if (len1 > 0 && SLASH_P (path1[len1 - 1]))
d385 1
a385 1
    return SLASH_P (path2[0]) && !SLASH_P (path2[1]);
d390 1
a390 1
  return SLASH_P (path2[len1]) || path2[len1] == 0 || path1[len1 - 1] == ':';
d406 1
a406 1
  unc = SLASH_P (*s) && SLASH_P (s[1]);
d465 37
d512 9
a520 3
  char *path = vconcat (s, v);
  if (strncmp (path, "./", 2) == 0)
    memmove (path, path + 2, strlen (path + 2) + 1);
d588 1
a588 1
  if ((m->flags & MOUNT_CYGDRIVE))             /* cygdrive */
@


1.10
log
@	* path.cc (vconcat): Don't convert backslahes to slashes.
	(cygpath): Return native path with all backslashes.
@
text
@d12 3
a14 2
   Cygwin's mount table.  If the format or location of the mount table
   changes, this is the file to change to match it. */
d21 1
d34 196
@


1.9
log
@* path.cc (getmntent): Add previously-omitted 'noexec' and 'managed'flags to
mnt_opts string if present in mount flags.
@
text
@a231 3
  for (p = rv; *p; p++)
    if (*p == '\\')
      *p = '/';
d301 1
a301 1
    native = concat (match->native, "/", path + max_len, NULL);
@


1.9.6.1
log
@2007-08-31  Dave Korn  <dave.korn@@artimi.com>

	* mkgroup.c (enum_groups):  Use MAX_PREFERRED_LENGTH in netgroupenum
	call so that it will automatically size returned buffer sufficiently.

2007-08-03  Dave Korn  <dave.korn@@artimi.com>

	* Makefile.in (cygcheck.exe):  Add bloda.o as prerequisite, adjusting
	dependency-filtering $(wordlist ...) call appropriately.  Link ntdll.
	(bloda.o):  New rule to build bloda.o
	* cygcheck.cc (dump_sysinfo):  Call bloda function dump_dodgy_apps().
	* bloda.cc:  New file implements detection of applications from the
	Big List Of Dodgy Apps.

2007-07-24  Corinna Vinschen  <corinna@@vinschen.de>

	* COPYING.dumper: New file.
	* dumper.cc: Change license to plain GPLv2 + later.
	* dumper.h: Ditto.
	* parse_pe.cc: Ditto.

2007-07-23  Christopher Faylor  <me+cygwin@@cgf.cx>

	* strace.cc (create_child): Don't convert a path from cygwin format
	unless it has a slash.

2007-07-09  Christopher Faylor  <me+cygwin@@cgf.cx>

	* strace.cc (usage): Add missing description for -q.

2007-05-29  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* dumper.cc (dumper::prepare_core_dump): Record a phdr for each section.

2007-03-30  Mark Mitchell  <mark@@codesourcery.com>

	* utils/cygpath.cc (get_long_path_name_w32impl): Close handles returned
	by FindFirstFile.

2006-09-11  Eric Blake  <ebb9@@byu.net>

	* cygcheck.cc (main): Restore POSIXLY_CORRECT before displaying user's
	environment.

2006-08-03  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (vconcat): Don't convert backslahes to slashes.
	(cygpath): Return native path with all backslashes.

2006-07-30  Ilya Bobir  <ilya@@po4ta.com>

	* cygpath.cc (get_long_name): Fallback to get_long_path_name_w32impl.

2006-07-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygpath.c (get_long_name): Cover the case that GetLongPathName
	doesn't return valid information for non-existant files.  Just return
	incoming filename in that case.
@
text
@d232 3
d304 1
a304 1
    native = concat (match->native, "\\", path + max_len, NULL);
@


1.8
log
@* Makefile.in (MINGW_CXX): Define and use for mingw-compiled files.
* path.cc: Include more path info in cygwin-specific includes since the cygwin
directory is no longer included by default.
@
text
@d3 1
a3 1
   Copyright 2001 Red Hat, Inc.
d346 4
@


1.7
log
@* Makefile.in (strace.exe): Include mingw_getopt.o in link line.
* cygcheck.cc (print_version): Update copyright.
* strace.cc (print_version): Ditto.
(main): Allow cygwin paths for -o option.
(create_child): Allow cygwin path as argv[0].
* path.cc (path.cc): Allow UNC paths.
@
text
@d15 2
d20 3
a22 3
#include <cygwin/version.h>
#include <sys/mount.h>
#include <mntent.h>
@


1.6
log
@* cygcheck.cc (common_apps): Add some more apps.
* path.cc (get_cygdrive): Correctly set system flag.
@
text
@d248 1
a248 1
	    p++;
@


1.5
log
@* path.cc (cygpath): Change MOUNT_AUTO to MOUNT_CYGDRIVE.
(getmntent): Ditto.
@
text
@a80 1

d88 1
@


1.4
log
@* path.cc (cygpath): Don't consider cygpath stuff when trying to derive native
paths.
@
text
@d286 1
a286 1
      if (m->flags & MOUNT_AUTO)
d344 2
a345 2
  if ((m->flags & MOUNT_AUTO))             /* cygdrive */
    strcat (mnt.mnt_opts, (char *) ",noumount");
@


1.3
log
@* cygcheck.cc (scan_registry): Open registry with read-only access.
(main): Reflect argument change for dump_setup.
* dump_setup.cc (dump_setup): Add preliminary extra argument for future use.
* path.cc (read_mounts): Open registry with read-only access.
@
text
@d286 3
@


1.2
log
@* dump_setup.cc: New file.
* Makefile.in: Add info for dump_setup.o.
* cygcheck.cc (main): Recognize '-c' option for checking setup installed base.
* path.cc (cygpath): Read mount table if not loaded.
@
text
@d122 1
a122 1
      if (RegCreateKeyEx (key, buf, 0, (LPTSTR) "Cygwin", 0, KEY_ALL_ACCESS,
@


1.1
log
@* Makefile.in (cygcheck.exe): Compile as -mno-cygwin executable.
* path.cc: New file.
* cygcheck.cc (init_paths): Use MS-DOS path syntax.
(cygwin_info): Properly display cygwin version numbers.  Prettify some output.
(dump_sysinfo): Calculate max names of posix and ms-dos paths for prettier
output.
@
text
@d1 9
a9 14
/*
 * Copyright (c) 2000, Red Hat, Inc.
 *
 *     This program is free software; you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation; either version 2 of the License, or
 *     (at your option) any later version.
 *
 *     A copy of the GNU General Public License can be found at
 *     http://www.gnu.org/
 *
 * Written by DJ Delorie <dj@@cygnus.com>
 *
 */
d92 1
a92 1
void
d275 2
@

