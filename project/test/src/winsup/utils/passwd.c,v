head	1.29;
access;
symbols
	cygwin-1_7_35-release:1.29
	cygwin-1_7_34-release:1.29
	cygwin-1_7_33-release:1.26.2.1
	cygwin-1_7_32-release:1.26.2.1
	cygwin-1_7_31-release:1.26.2.1
	cygwin-1_7_30-release:1.26
	cygwin-1_7_29-release:1.26
	cygwin-1_7_29-release-branchpoint:1.26.0.2
	cygwin-1_7_28-release:1.26
	cygwin-1_7_27-release:1.26
	cygwin-1_7_26-release:1.26
	cygwin-1_7_25-release:1.26
	cygwin-1_7_24-release:1.26
	cygwin-1_7_23-release:1.26
	cygwin-1_7_22-release:1.26
	cygwin-1_7_21-release:1.26
	cygwin-1_7_20-release:1.26
	cygwin-1_7_19-release:1.26
	cygwin-64bit-postmerge:1.26
	cygwin-64bit-premerge-branch:1.25.0.2
	cygwin-64bit-premerge:1.25
	cygwin-1_7_18-release:1.25
	cygwin-1_7_17-release:1.24
	cygwin-64bit-branch:1.24.0.2
	cygwin-1_7_16-release:1.24
	cygwin-1_7_15-release:1.24
	cygwin-1_7_14_2-release:1.24
	cygwin-1_7_14-release:1.24
	cygwin-1_7_12-release:1.24
	cygwin-1_7_11-release:1.24
	cygwin-1_7_10-release:1.23
	cygwin-1_7_9-release:1.20
	cygwin-1_7_8-release:1.20
	cygwin-1_7_7-release:1.20
	cygwin-1_7_5-release:1.20
	cygwin-1_7_4-release:1.20
	cygwin-1_7_3-release:1.20
	cygwin-1_7_2-release:1.20
	cygwin-1_7_1-release:1.20
	cv-branch-2:1.20.0.2
	cr-0x5f1:1.12.0.6
	cv-branch:1.12.0.4
	cr-0x3b58:1.12.0.2
	cr-0x9e:1.11.0.4
	cr-0x9d:1.11.0.2
	corinna-01:1.10
	cr-0x9c:1.8.0.4
	cr-0x9b:1.8.0.6
	cr-0x99:1.8
	Z-emcb-cygwin_daemon:1.8.0.2
	w32api-2_2:1.7
	mingw-runtime-2_4:1.7
	cygnus_cvs_20020108_pre:1.2
	Z-cygwin_daemon_merge-new_HEAD:1.2
	Z-cygwin_daemon_merge_HEAD:1.2
	cygwin_daemon:1.2.0.8;
locks; strict;
comment	@ * @;
expand	@o@;


1.29
date	2014.11.24.11.07.32;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2014.08.06.19.24.57;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2014.06.16.13.27.08;	author corinna;	state Exp;
branches;
next	1.26;

1.26
date	2013.04.23.09.44.36;	author corinna;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2013.01.21.16.28.27;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2012.02.09.10.11.26;	author corinna;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2011.12.17.23.39.47;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2011.10.10.14.57.47;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2011.04.04.09.09.43;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2009.05.15.11.30.18;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.23.20.40.17;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2009.03.23.16.37.49;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2009.03.22.19.18.26;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2009.03.22.10.09.01;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.21.17.14.39;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.15.17.33.08;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.26.10.19.09;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.18.20.25.43;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.14.19.14.43;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.04.10.54.47;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.04.10.30.35;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.26.21.52.03;	author joshuadfranklin;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.15.19.24.36;	author joshuadfranklin;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.14.11.31.33;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.29.07.13.09;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.19.15.48.40;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.30.11.57.16;	author corinna;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.31.13.35.39;	author corinna;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.26.2.1
date	2014.06.16.13.27.33;	author corinna;	state Exp;
branches;
next	;

1.24.2.1
date	2013.01.29.21.54.42;	author corinna;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2013.02.06.17.03.49;	author corinna;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	2000.07.31.13.34.50;	author corinna;	state Exp;
branches;
next	;


desc
@@


1.29
log
@	* passwd.c (GetPW): If server is NULL, and the user is not a local
	user, try to fetch the DC to use as server.
	(ChangePW): Get Windows username via extra parameter.
	(usage): Reduce -d help text to reflect above change.
	(main): Fix typo in comment.  Call GetPW and ChangePW as per the
	changes above.
@
text
@/* passwd.c: Changing passwords and managing account information

   Copyright 1999, 2000, 2001, 2002, 2003, 2005, 2008, 2009, 2011, 2012,
   2013, 2014 Red Hat, Inc.

   Written by Corinna Vinschen <corinna.vinschen@@cityweb.de>

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include <windows.h>
#include <wininet.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <dsgetdc.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <inttypes.h>
#include <getopt.h>
#include <pwd.h>
#include <sys/cygwin.h>
#include <cygwin/version.h>
#include <sys/types.h>
#include <time.h>
#include <errno.h>
#include <locale.h>
#include <wchar.h>

#define USER_PRIV_ADMIN		 2

static char *prog_name;

static struct option longopts[] =
{
  {"cannot-change", no_argument, NULL, 'c'},
  {"can-change", no_argument, NULL, 'C'},
  {"logonserver", required_argument, NULL, 'd'},
  {"never-expires", no_argument, NULL, 'e'},
  {"expires", no_argument, NULL, 'E'},
  {"help", no_argument, NULL, 'h' },
  {"inactive", required_argument, NULL, 'i'},
  {"lock", no_argument, NULL, 'l'},
  {"minage", required_argument, NULL, 'n'},
  {"pwd-not-required", no_argument, NULL, 'p'},
  {"pwd-required", no_argument, NULL, 'P'},
  {"unlock", no_argument, NULL, 'u'},
  {"version", no_argument, NULL, 'V'},
  {"maxage", required_argument, NULL, 'x'},
  {"length", required_argument, NULL, 'L'},
  {"status", no_argument, NULL, 'S'},
  { "reg-store-pwd", no_argument, NULL, 'R'},
  {NULL, 0, NULL, 0}
};

static char opts[] = "cCd:eEhi:ln:pPuvVx:L:SR";

int
eprint (int with_name, const char *fmt, ...)
{
  va_list ap;

  if (with_name)
    fprintf(stderr, "%s: ", prog_name);
  va_start (ap, fmt);
  vfprintf (stderr, fmt, ap);
  va_end (ap);
  fprintf(stderr, "\n");
  return 1;
}

int
EvalRet (int ret, const char *user)
{
  switch (ret)
    {
    case NERR_Success:
      return 0;

    case ERROR_ACCESS_DENIED:
      if (!user)
	eprint (0, "You may not change password expiry information.");
      else
	eprint (0, "You may not change the password for %s.", user);
      break;

      eprint (0, "Bad password: Invalid.");
      break;

    case NERR_PasswordTooShort:
      eprint (0, "Bad password: Too short.");
      break;

    case NERR_UserNotFound:
      eprint (1, "unknown user %s", user);
      break;

    case ERROR_INVALID_PASSWORD:
    case NERR_BadPassword:
      eprint (0, "Incorrect password for %s.", user);
      eprint (0, "The password for %s is unchanged.", user);
      break;

    default:
      eprint (1, "unrecoverable error %d", ret);
      break;
    }
  return 1;
}

PUSER_INFO_3
GetPW (char *user, int print_win_name, LPWSTR *server)
{
  char usr_buf[UNLEN + 1];
  WCHAR name[UNLEN + 1];
  DWORD ret;
  PUSER_INFO_3 ui;
  struct passwd *pw;
  char *domain = (char *) alloca (INTERNET_MAX_HOST_NAME_LENGTH + 1);

  /* Get the Win32 username and a suitable server. */
  if ((pw = getpwnam (user)))
    {
      cygwin_internal (CW_EXTRACT_DOMAIN_AND_USER, pw, domain, usr_buf);
      if (strcasecmp (pw->pw_name, usr_buf))
	{
	  /* Hack to avoid problem with LookupAccountSid after impersonation */
	  if (strcasecmp (usr_buf, "SYSTEM"))
	    {
	      user = usr_buf;
	      if (print_win_name)
		printf ("Windows username : %s\n", user);
	    }
	}
      if (!*server)
	{
	  PDOMAIN_CONTROLLER_INFOW dci;
	  char machine[INTERNET_MAX_HOST_NAME_LENGTH + 1];
	  DWORD mlen = sizeof machine;
	  WCHAR wdom[INTERNET_MAX_HOST_NAME_LENGTH + 1];

	  /* If we can't fetch the local machine name, or if the machine name
	     is not the same as the user's domain name, try to fetch the DC via
	     DsGetDcName.  Otherwise, just stick to a NULL servername, since
	     that's the same as using the local machine. */
	  if (!GetComputerNameExA (ComputerNameNetBIOS, machine, &mlen)
	      || strcasecmp (domain, machine) != 0)
	    {
	      mbstowcs (wdom, domain, INTERNET_MAX_HOST_NAME_LENGTH + 1);
	      if (!DsGetDcNameW (NULL, wdom, NULL, NULL, DS_IS_FLAT_NAME, &dci))
		*server = dci->DomainControllerName;
	    }
	}
    }
  mbstowcs (name, user, UNLEN + 1);
  ret = NetUserGetInfo (*server, name, 3, (void *) &ui);
  return EvalRet (ret, user) ? NULL : ui;
}

int
ChangePW (const char *user, PCWSTR name, const char *oldpwd, const char *pwd,
	  int justcheck, LPCWSTR server)
{
  WCHAR oldpass[512], pass[512];
  DWORD ret;

  mbstowcs (pass, pwd, 512);
  if (!oldpwd)
    {
      USER_INFO_1003 ui;

      ui.usri1003_password = pass;
      ret = NetUserSetInfo (server, name, 1003, (LPBYTE) &ui, NULL);
    }
  else
    {
      mbstowcs (oldpass, oldpwd, 512);
      ret = NetUserChangePassword (server, name, oldpass, pass);
    }
  if (justcheck && ret != ERROR_INVALID_PASSWORD)
    return 0;
  if (!EvalRet (ret, user) && !justcheck)
    eprint (0, "Password changed.");
  return ret;
}

void
PrintPW (PUSER_INFO_3 ui, LPCWSTR server)
{
  time_t t = time (NULL) - ui->usri3_password_age;
  int ret;
  PUSER_MODALS_INFO_0 mi;

  printf ("Account disabled           : %s",
	(ui->usri3_flags & UF_ACCOUNTDISABLE) ? "yes\n" : "no\n");
  printf ("Password not required      : %s",
	(ui->usri3_flags & UF_PASSWD_NOTREQD) ? "yes\n" : "no\n");
  printf ("User can't change password : %s",
	(ui->usri3_flags & UF_PASSWD_CANT_CHANGE) ? "yes\n" : "no\n");
  printf ("Password never expires     : %s",
	(ui->usri3_flags & UF_DONT_EXPIRE_PASSWD) ? "yes\n" : "no\n");
  printf ("Password expired           : %s",
	(ui->usri3_password_expired) ? "yes\n" : "no\n");
  printf ("Latest password change     : %s", ctime(&t));
  ret = NetUserModalsGet (server, 0, (void *) &mi);
  if (!ret)
    {
      if (mi->usrmod0_max_passwd_age == TIMEQ_FOREVER)
	mi->usrmod0_max_passwd_age = 0;
      if (mi->usrmod0_min_passwd_age == TIMEQ_FOREVER)
	mi->usrmod0_min_passwd_age = 0;
      if (mi->usrmod0_force_logoff == TIMEQ_FOREVER)
	mi->usrmod0_force_logoff = 0;
      if (ui->usri3_priv == USER_PRIV_ADMIN)
	mi->usrmod0_min_passwd_len = 0;
      printf ("\nSystem password settings:\n");
      printf ("Max. password age %" PRIu32 " days\n",
	      (unsigned int) (mi->usrmod0_max_passwd_age / ONE_DAY));
      printf ("Min. password age %" PRIu32 " days\n",
	      (unsigned int) (mi->usrmod0_min_passwd_age / ONE_DAY));
      printf ("Force logout after %" PRIu32 " days\n",
	      (unsigned int) (mi->usrmod0_force_logoff / ONE_DAY));
      printf ("Min. password length: %" PRIu32 "\n",
	      (unsigned int) mi->usrmod0_min_passwd_len);
    }
}

int
SetModals (int xarg, int narg, int iarg, int Larg, LPCWSTR server)
{
  int ret;
  PUSER_MODALS_INFO_0 mi;

  ret = NetUserModalsGet (server, 0, (void *) &mi);
  if (!ret)
    {
      if (xarg == 0)
	mi->usrmod0_max_passwd_age = TIMEQ_FOREVER;
      else if (xarg > 0)
	mi->usrmod0_max_passwd_age = xarg * ONE_DAY;

      if (narg == 0)
	{
	  mi->usrmod0_min_passwd_age = TIMEQ_FOREVER;
	  mi->usrmod0_password_hist_len = 0;
	}
      else if (narg > 0)
	mi->usrmod0_min_passwd_age = narg * ONE_DAY;

      if (iarg == 0)
	mi->usrmod0_force_logoff = TIMEQ_FOREVER;
      else if (iarg > 0)
	mi->usrmod0_force_logoff = iarg * ONE_DAY;

      if (Larg >= 0)
	mi->usrmod0_min_passwd_len = Larg;

      ret = NetUserModalsSet (server, 0, (LPBYTE) mi, NULL);
      NetApiBufferFree (mi);
    }
  return EvalRet (ret, NULL);
}

static void usage (FILE * stream, int status) __attribute__ ((noreturn));
static void
usage (FILE * stream, int status)
{
  fprintf (stream, ""
  "Usage: %s [OPTION] [USER]\n"
  "\n"
  "Change USER's password or password attributes.\n"
  "\n"
  "User operations:\n"
  "  -l, --lock               lock USER's account.\n"
  "  -u, --unlock             unlock USER's account.\n"
  "  -c, --cannot-change      USER can't change password.\n"
  "  -C, --can-change         USER can change password.\n"
  "  -e, --never-expires      USER's password never expires.\n"
  "  -E, --expires            USER's password expires according to system's\n"
  "                           password aging rule.\n"
  "  -p, --pwd-not-required   no password required for USER.\n"
  "  -P, --pwd-required       password is required for USER.\n"
  "  -R, --reg-store-pwd      enter password to store it in the registry for\n"
  "                           later usage by services to be able to switch\n"
  "                           to this user context with network credentials.\n"
  "\n"
  "System operations:\n"
  "  -i, --inactive NUM       set NUM of days before inactive accounts are disabled\n"
  "                           (inactive accounts are those with expired passwords).\n"
  "  -n, --minage MINDAYS     set system minimum password age to MINDAYS days.\n"
  "  -x, --maxage MAXDAYS     set system maximum password age to MAXDAYS days.\n"
  "  -L, --length LEN         set system minimum password length to LEN.\n"
  "\n"
  "Other options:\n"
  "  -d, --logonserver SERVER connect to SERVER (e.g. domain controller).\n"
  "                           Usually not required.\n"
  "  -S, --status             display password status for USER (locked, expired,\n"
  "                           etc.) plus global system password settings.\n"
  "  -h, --help               output usage information and exit.\n"
  "  -V, --version            output version information and exit.\n"
  "\n"
  "If no option is given, change USER's password.  If no user name is given,\n"
  "operate on current user.  System operations must not be mixed with user\n"
  "operations.  Don't specify a USER when triggering a system operation.\n"
  "\n"
  "Don't specify a user or any other option together with the -R option.\n"
  "Non-Admin users can only store their password if cygserver is running\n"
  "as service under the SYSTEM account.\n"
  "Note that storing even obfuscated passwords in the registry is not overly\n"
  "secure.  Use this feature only if the machine is adequately locked down.\n"
  "Don't use this feature if you don't need network access within a remote\n"
  "session.  You can delete your stored password by using `passwd -R' and\n"
  "specifying an empty password.\n\n", prog_name);
  exit (status);
}

static int
caller_is_admin ()
{
  static int is_admin = -1;
  HANDLE token;
  DWORD size;
  PTOKEN_GROUPS grps;
  SID_IDENTIFIER_AUTHORITY nt_auth = {SECURITY_NT_AUTHORITY};
  PSID admin_grp;
  DWORD i;

  if (is_admin == -1)
    {
      is_admin = 0;
      if (OpenProcessToken (GetCurrentProcess (), TOKEN_READ, &token))
	{
	  GetTokenInformation (token, TokenGroups, NULL, 0, &size);
	  grps = (PTOKEN_GROUPS) alloca (size);
	  if (!GetTokenInformation(token, TokenGroups, grps, size, &size)
	      || !AllocateAndInitializeSid (&nt_auth, 2,
					    SECURITY_BUILTIN_DOMAIN_RID,
					    DOMAIN_ALIAS_RID_ADMINS,
					    0, 0, 0, 0, 0, 0, &admin_grp))
	    is_admin = 0;
	  else
	    {
	      for (i = 0; i < grps->GroupCount; ++i)
		if (EqualSid (admin_grp, grps->Groups[i].Sid)
		    && (grps->Groups[i].Attributes
			& (SE_GROUP_ENABLED | SE_GROUP_USE_FOR_DENY_ONLY))
		       == SE_GROUP_ENABLED)
		  {
		    is_admin = 1;
		    break;
		  }
	      FreeSid (admin_grp);
	    }
	  CloseHandle (token);
	}
    }
  return is_admin;
}

static void
print_version ()
{
  printf ("passwd (cygwin) %d.%d.%d\n"
	  "Password Utility\n"
	  "Copyright (C) 1999 - %s Red Hat, Inc.\n"
	  "This is free software; see the source for copying conditions.  There is NO\n"
	  "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n",
	  CYGWIN_VERSION_DLL_MAJOR / 1000,
	  CYGWIN_VERSION_DLL_MAJOR % 1000,
	  CYGWIN_VERSION_DLL_MINOR,
	  strrchr (__DATE__, ' ') + 1);
}

int
main (int argc, char **argv)
{
  char *logonserver;
  char user[UNLEN + 1], oldpwd[_PASSWORD_LEN + 1], newpwd[_PASSWORD_LEN + 1];
  int ret = 0;
  int cnt = 0;
  int opt;
  int Larg = -1;
  int xarg = -1;
  int narg = -1;
  int iarg = -1;
  int lopt = 0;
  int uopt = 0;
  int copt = 0;
  int Copt = 0;
  int eopt = 0;
  int Eopt = 0;
  int popt = 0;
  int Popt = 0;
  int Sopt = 0;
  int Ropt = 0;
  PUSER_INFO_3 ui;
  int myself = 0;
  LPWSTR server = NULL;

  prog_name = program_invocation_short_name;

  /* Use locale from environment.  If not set or set to "C", use UTF-8. */
  setlocale (LC_CTYPE, "");
  if (!strcmp (setlocale (LC_CTYPE, NULL), "C"))
    setlocale (LC_CTYPE, "en_US.UTF-8");
  while ((opt = getopt_long (argc, argv, opts, longopts, NULL)) != EOF)
    switch (opt)
      {
      case 'h':
	usage (stdout, 0);
	break;

      case 'i':
	if (lopt || uopt || copt || Copt || eopt || Eopt || popt || Popt || Sopt || Ropt)
	  usage (stderr, 1);
	if ((iarg = atoi (optarg)) < 0 || iarg > 999)
	  return eprint (1, "Force logout time must be between 0 and 999.");
	break;

      case 'l':
	if (xarg >= 0 || narg >= 0 || iarg >= 0 || Larg >= 0 || uopt || Sopt || Ropt)
	  usage (stderr, 1);
	lopt = 1;
	break;

      case 'n':
	if (lopt || uopt || copt || Copt || eopt || Eopt || popt || Popt || Sopt || Ropt)
	  usage (stderr, 1);
	if ((narg = atoi (optarg)) < 0 || narg > 999)
	  return eprint (1, "Minimum password age must be between 0 and 999.");
	if (xarg >= 0 && narg > xarg)
	  return eprint (1, "Minimum password age must be less than "
			    "maximum password age.");
	break;

      case 'u':
	if (xarg >= 0 || narg >= 0 || iarg >= 0 || Larg >= 0 || lopt || Sopt || Ropt)
	  usage (stderr, 1);
	uopt = 1;
	break;

      case 'c':
	if (xarg >= 0 || narg >= 0 || iarg >= 0 || Larg >= 0 || Sopt || Ropt)
	  usage (stderr, 1);
	copt = 1;
	break;

      case 'C':
	if (xarg >= 0 || narg >= 0 || iarg >= 0 || Larg >= 0 || Sopt || Ropt)
	  usage (stderr, 1);
	Copt = 1;
	break;

      case 'd':
	{
	  if (Ropt)
	    usage (stderr, 1);
	  char *tmpbuf = alloca (strlen (optarg) + 3);
	  tmpbuf[0] = '\0';
	  if (*optarg != '\\')
	    strcpy (tmpbuf, "\\\\");
	  strcat (tmpbuf, optarg);
	  size_t len = mbstowcs (NULL, tmpbuf, 0);
	  if (len > 0 && len != (size_t) -1)
	    mbstowcs (server = alloca ((len + 1) * sizeof (wchar_t)),
		      tmpbuf, len + 1);
	}
	break;

      case 'e':
	if (xarg >= 0 || narg >= 0 || iarg >= 0 || Larg >= 0 || Sopt || Ropt)
	  usage (stderr, 1);
	eopt = 1;
	break;

      case 'E':
	if (xarg >= 0 || narg >= 0 || iarg >= 0 || Larg >= 0 || Sopt || Ropt)
	  usage (stderr, 1);
	Eopt = 1;
	break;

      case 'p':
	if (xarg >= 0 || narg >= 0 || iarg >= 0 || Larg >= 0 || Sopt || Ropt)
	  usage (stderr, 1);
	popt = 1;
	break;

      case 'P':
	if (xarg >= 0 || narg >= 0 || iarg >= 0 || Larg >= 0 || Sopt || Ropt)
	  usage (stderr, 1);
	Popt = 1;
	break;

      case 'V':
      case 'v':		/* Keep this option for historical reasons,
			   but don't advertize it. */
	print_version ();
	exit (0);
	break;

      case 'x':
	if (lopt || uopt || copt || Copt || eopt || Eopt || popt || Popt || Sopt || Ropt)
	  usage (stderr, 1);
	if ((xarg = atoi (optarg)) < 0 || xarg > 999)
	  return eprint (1, "Maximum password age must be between 0 and 999.");
	if (narg >= 0 && xarg < narg)
	  return eprint (1, "Maximum password age must be greater than "
			    "minimum password age.");
	break;

      case 'L':
	if (lopt || uopt || copt || Copt || eopt || Eopt || popt || Popt || Sopt || Ropt)
	  usage (stderr, 1);
	if ((Larg = atoi (optarg)) < 0 || Larg > LM20_PWLEN)
	  return eprint (1, "Minimum password length must be between "
			    "0 and %d.", LM20_PWLEN);
	break;

      case 'S':
	if (xarg >= 0 || narg >= 0 || iarg >= 0 || Larg >= 0 || lopt || uopt
	    || copt || Copt || eopt || Eopt || popt || Popt || Ropt)
	  usage (stderr, 1);
	Sopt = 1;
	break;

      case 'R':
	if (xarg >= 0 || narg >= 0 || iarg >= 0 || Larg >= 0 || lopt || uopt
	    || copt || Copt || eopt || Eopt || popt || Popt || Sopt
	    || server)
	  usage (stderr, 1);
	Ropt = 1;
	break;

      default:
	fprintf (stderr, "Try `%s --help' for more information.\n", prog_name);
	return 1;
      }

  if (Ropt)
    {
      const char *username = NULL;
      if (optind < argc)
	{
	  username = argv[optind++];
	  if (!strcmp (username, getlogin ()))
	    username = NULL;
	  else if (!caller_is_admin ())
	    return eprint (0, "You may not change the password for %s.",
			   username);

	  if (optind < argc)
	    usage (stderr, 1);
	}
      char *text1 = (char *) alloca ((username ? strlen (username) + 2 : 4)
				     + sizeof ("Enter  current password: "));
      char *text2 = (char *) alloca ((username ? strlen (username) + 2 : 4)
				     + sizeof ("Re-enter  current password: "));
      sprintf (text1, "Enter %s%s current password: ",
	       username ?: "your", username ? "'s" : "");
      sprintf (text2, "Re-enter %s%s current password: ",
	       username ?: "your", username ? "'s" : "");
      printf (
"This functionality stores a password in the registry for usage by services\n"
"which need to change the user context and require network access.  Typical\n"
"applications are interactive remote logons using sshd, cron task, etc.\n"
"This password will always tried first when any privileged application is\n"
"about to switch the user context.\n\n"
"Note that storing even obfuscated passwords in the registry is not overly\n"
"secure.  Use this feature only if the machine is adequately locked down.\n"
"Don't use this feature if you don't need network access within a remote\n"
"session.\n\n"
"You can delete the stored password by specifying an empty password.\n\n");
      strcpy (newpwd, getpass (text1));
      if (strcmp (newpwd, getpass (text2)))
	eprint (0, "Password is not identical.");
      else if (cygwin_internal (CW_SET_PRIV_KEY, newpwd, username))
	return eprint (0, "Storing password failed: %s", strerror (errno));
      return 0;
    }

  if (Larg >= 0 || xarg >= 0 || narg >= 0 || iarg >= 0)
    {
      if (optind < argc)
	usage (stderr, 1);
      return SetModals (xarg, narg, iarg, Larg, server);
    }

  strcpy (user, optind >= argc ? getlogin () : argv[optind]);

  /* Changing password for calling user?  Use logonserver for user as well. */
  if (!server && optind >= argc)
    {
      myself = 1;
      if ((logonserver = getenv ("LOGONSERVER")))
	{
	  size_t len = mbstowcs (NULL, logonserver, 0);
	  if (len > 0 && len != (size_t) -1)
	    mbstowcs (server = alloca ((len + 1) * sizeof (wchar_t)),
		      logonserver, len + 1);
	}
    }

  ui = GetPW (user, 1, &server);
  if (!ui)
    return 1;

  if (lopt || uopt || copt || Copt || eopt || Eopt || popt || Popt || Sopt)
    {
      USER_INFO_1008 uif;

      uif.usri1008_flags = ui->usri3_flags;
      if (lopt)
	{
	  if (ui->usri3_priv == USER_PRIV_ADMIN)
	    return eprint (0, "Locking an admin account is disallowed.");
	  uif.usri1008_flags |= UF_ACCOUNTDISABLE;
	}
      if (uopt)
	uif.usri1008_flags &= ~UF_ACCOUNTDISABLE;
      if (copt)
	uif.usri1008_flags |= UF_PASSWD_CANT_CHANGE;
      if (Copt)
	uif.usri1008_flags &= ~UF_PASSWD_CANT_CHANGE;
      if (eopt)
	uif.usri1008_flags |= UF_DONT_EXPIRE_PASSWD;
      if (Eopt)
	uif.usri1008_flags &= ~UF_DONT_EXPIRE_PASSWD;
      if (popt)
	uif.usri1008_flags |= UF_PASSWD_NOTREQD;
      if (Popt)
	uif.usri1008_flags &= ~UF_PASSWD_NOTREQD;

      if (lopt || uopt || copt || Copt || eopt || Eopt || popt || Popt)
	{
	  ret = NetUserSetInfo (server, ui->usri3_name, 1008, (LPBYTE) &uif,
				NULL);
	  return EvalRet (ret, NULL);
	}
      // Sopt
      PrintPW (ui, server);
      return 0;
    }

  if (!caller_is_admin () && !myself)
    return eprint (0, "You may not change the password for %s.", user);

  oldpwd[0] = '\0';
  if (!caller_is_admin ())
    {
      strcpy (oldpwd, getpass ("Old password: "));
      if (ChangePW (user, ui->usri3_name, oldpwd, oldpwd, 1, server))
	return 1;
    }

  do
    {
      strcpy (newpwd, getpass ("New password: "));
      if (strcmp (newpwd, getpass ("Re-enter new password: ")))
	eprint (0, "Password is not identical.");
      else if (!ChangePW (user, ui->usri3_name, *oldpwd ? oldpwd : NULL,
      			  newpwd, 0, server))
	ret = 1;
      if (!ret && cnt < 2)
	eprint (0, "Try again.");
    }
  while (!ret && ++cnt < 3);
  return !ret;
}
@


1.28
log
@	* passwd.c (usage): Rename DAYS to MINDAYS and MAXDAYS.
	* utils.xml (passwd): Ditto.
@
text
@d20 1
d119 1
a119 1
GetPW (char *user, int print_win_name, LPCWSTR server)
d128 1
a128 1
  /* Try getting a Win32 username in case the user edited /etc/passwd */
d142 19
d163 1
a163 1
  ret = NetUserGetInfo (server, name, 3, (void *) &ui);
d168 2
a169 2
ChangePW (const char *user, const char *oldpwd, const char *pwd, int justcheck,
	  LPCWSTR server)
d171 1
a171 1
  WCHAR name[UNLEN + 1], oldpass[512], pass[512];
a173 1
  mbstowcs (name, user, UNLEN + 1);
d303 1
a303 3
  "                           Default server is the local system, unless\n"
  "                           changing the current user, in which case the\n"
  "                           default is the content of $LOGONSERVER.\n"
d502 1
a502 1
      case 'v':		/* Keep this option for historrical reasons,
d610 1
a610 1
  ui = GetPW (user, 1, server);
d658 1
a658 1
      if (ChangePW (user, oldpwd, oldpwd, 1, server))
d667 2
a668 1
      else if (!ChangePW (user, *oldpwd ? oldpwd : NULL, newpwd, 0, server))
@


1.27
log
@* passwd.c (main): Fix typo in error output.
@
text
@d4 1
a4 1
   2013 Red Hat, Inc.
d87 1
a87 1
      if (! user)
d156 1
a156 1
  if (! oldpwd)
d170 2
a171 4
  if (! EvalRet (ret, user) && ! justcheck)
    {
      eprint (0, "Password changed.");
    }
d194 1
a194 1
  if (! ret)
d223 1
a223 1
  if (! ret)
d278 2
a279 2
  "  -n, --minage DAYS        set system minimum password age to DAYS days.\n"
  "  -x, --maxage DAYS        set system maximum password age to DAYS days.\n"
d594 1
a594 1
  if (! ui)
a636 3
  eprint (0, "Enter the new password (minimum of 5, maximum of 8 characters).");
  eprint (0, "Please use a combination of upper and lower case letters and numbers.");

d650 1
a650 1
      else if (! ChangePW (user, *oldpwd ? oldpwd : NULL, newpwd, 0, server))
d652 1
a652 1
      if (! ret && cnt < 2)
d655 2
a656 2
  while (! ret && ++cnt < 3);
  return ! ret;
@


1.26
log
@	* Merge in cygwin-64bit-branch.
@
text
@d540 2
a541 1
	    return eprint (0, "You may not change the password for %s.", user);
@


1.26.2.1
log
@* passwd.c (main): Fix typo in error output.
@
text
@d540 1
a540 2
	    return eprint (0, "You may not change the password for %s.",
			   username);
@


1.25
log
@Update copyrights
@
text
@d3 2
a4 2
   Copyright 1999, 2000, 2001, 2002, 2003, 2005, 2008, 2009, 2011, 2012 Red
   Hat, Inc.
d25 1
d207 8
a214 8
      printf ("Max. password age %ld days\n",
	      mi->usrmod0_max_passwd_age / ONE_DAY);
      printf ("Min. password age %ld days\n",
	      mi->usrmod0_min_passwd_age / ONE_DAY);
      printf ("Force logout after %ld days\n",
	      mi->usrmod0_force_logoff / ONE_DAY);
      printf ("Min. password length: %ld\n",
	      mi->usrmod0_min_passwd_len);
@


1.24
log
@	* passwd.cc: Add -v option to print version information as well, since
	it's used in older csih.
@
text
@d3 2
a4 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2008, 2009, 2011, 2012 Red Hat, Inc.
@


1.24.2.1
log
@Pull in changes from HEAD
@
text
@d3 1
a3 2
   Copyright 1999, 2000, 2001, 2002, 2003, 2005, 2008, 2009, 2011, 2012 Red
   Hat, Inc.
@


1.24.2.2
log
@	Throughout, fix type problems on 32 and 64 bit.  Except:
	* ssp.c: Disable entire functionality on x86_64 for now.
@
text
@d3 2
a4 2
   Copyright 1999, 2000, 2001, 2002, 2003, 2005, 2008, 2009, 2011, 2012,
   2013 Red Hat, Inc.
a24 1
#include <inttypes.h>
d206 8
a213 8
      printf ("Max. password age %" PRIu32 " days\n",
	      (unsigned int) (mi->usrmod0_max_passwd_age / ONE_DAY));
      printf ("Min. password age %" PRIu32 " days\n",
	      (unsigned int) (mi->usrmod0_min_passwd_age / ONE_DAY));
      printf ("Force logout after %" PRIu32 " days\n",
	      (unsigned int) (mi->usrmod0_force_logoff / ONE_DAY));
      printf ("Min. password length: %" PRIu32 "\n",
	      (unsigned int) mi->usrmod0_min_passwd_len);
@


1.23
log
@Clean up whitespace.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2008, 2009, 2011 Red Hat, Inc.
d60 1
a60 1
static char opts[] = "cCd:eEhi:ln:pPuVx:L:SR";
d485 2
@


1.22
log
@	* Align usage output, version output, as well as usage and version
	option handling to use the same style throughout all Cygwin utils.
	Throughout use program_invocation_short_name to refer to current
	process name in Cygwin executables.
	* utils.sgml: Align documentation to above change.  Add missing
	sections for getconf, ldd, and setmetamode.
	* strace.cc (proc_child): Avoid compiler warning.
@
text
@d86 1
a86 1
        eprint (0, "You may not change password expiry information.");
d88 1
a88 1
        eprint (0, "You may not change the password for %s.", user);
d124 1
a124 1
     
d183 1
a183 1
  	(ui->usri3_flags & UF_ACCOUNTDISABLE) ? "yes\n" : "no\n");
d185 1
a185 1
  	(ui->usri3_flags & UF_PASSWD_NOTREQD) ? "yes\n" : "no\n");
d187 1
a187 1
  	(ui->usri3_flags & UF_PASSWD_CANT_CHANGE) ? "yes\n" : "no\n");
d189 1
a189 1
  	(ui->usri3_flags & UF_DONT_EXPIRE_PASSWD) ? "yes\n" : "no\n");
d197 1
a197 1
        mi->usrmod0_max_passwd_age = 0;
d199 1
a199 1
        mi->usrmod0_min_passwd_age = 0;
d201 1
a201 1
        mi->usrmod0_force_logoff = 0;
d203 1
a203 1
        mi->usrmod0_min_passwd_len = 0;
d206 1
a206 1
              mi->usrmod0_max_passwd_age / ONE_DAY);
d208 1
a208 1
              mi->usrmod0_min_passwd_age / ONE_DAY);
d210 1
a210 1
              mi->usrmod0_force_logoff / ONE_DAY);
d212 1
a212 1
              mi->usrmod0_min_passwd_len);
d315 1
a315 1
  PSID admin_grp; 
d354 3
a356 3
          "Password Utility\n"
          "Copyright (C) 1999 - %s Red Hat, Inc.\n"
          "This is free software; see the source for copying conditions.  There is NO\n"
d358 4
a361 4
          CYGWIN_VERSION_DLL_MAJOR / 1000,
          CYGWIN_VERSION_DLL_MAJOR % 1000,
          CYGWIN_VERSION_DLL_MINOR,
          strrchr (__DATE__, ' ') + 1);
d401 1
a401 1
        break;
d408 1
a408 1
        break;
d414 1
a414 1
        break;
d423 2
a424 2
	                    "maximum password age.");
        break;
d430 1
a430 1
        break;
d436 1
a436 1
        break;
d442 1
a442 1
        break;
d445 1
a445 1
        {
d464 1
a464 1
        break;
d470 1
a470 1
        break;
d476 1
a476 1
        break;
d482 1
a482 1
        break;
d486 2
a487 2
        exit (0);
        break;
d496 2
a497 2
	                    "minimum password age.");
        break;
d504 2
a505 2
	                    "0 and %d.", LM20_PWLEN);
        break;
d512 1
a512 1
        break;
d520 1
a520 1
      	break;
d523 1
a523 1
        fprintf (stderr, "Try `%s --help' for more information.\n", prog_name);
d562 1
a562 1
        eprint (0, "Password is not identical.");
d571 1
a571 1
        usage (stderr, 1);
d600 1
a600 1
        {
d603 2
a604 2
          uif.usri1008_flags |= UF_ACCOUNTDISABLE;
        }
d606 1
a606 1
        uif.usri1008_flags &= ~UF_ACCOUNTDISABLE;
d608 1
a608 1
        uif.usri1008_flags |= UF_PASSWD_CANT_CHANGE;
d610 1
a610 1
        uif.usri1008_flags &= ~UF_PASSWD_CANT_CHANGE;
d612 1
a612 1
        uif.usri1008_flags |= UF_DONT_EXPIRE_PASSWD;
d614 1
a614 1
        uif.usri1008_flags &= ~UF_DONT_EXPIRE_PASSWD;
d616 1
a616 1
        uif.usri1008_flags |= UF_PASSWD_NOTREQD;
d618 1
a618 1
        uif.usri1008_flags &= ~UF_PASSWD_NOTREQD;
d622 3
a624 3
          ret = NetUserSetInfo (server, ui->usri3_name, 1008, (LPBYTE) &uif,
	  			NULL);
          return EvalRet (ret, NULL);
d642 1
a642 1
        return 1;
d649 1
a649 1
        eprint (0, "Password is not identical.");
d651 1
a651 1
        ret = 1;
d653 1
a653 1
        eprint (0, "Try again.");
@


1.21
log
@	* passwd.c (main): Add the ability to specify a username for the -R
	command.
	* utils.sgml: Document the aforementioned change.
@
text
@d27 1
a35 1
static const char version[] = "$Revision: 1.5 $";
d52 1
a52 1
  {"version", no_argument, NULL, 'v'},
d60 1
a60 1
static char opts[] = "cCd:eEhi:ln:pPuvx:L:SR";
d258 1
d290 1
a290 1
  "  -v, --version            output version information and exit.\n"
d303 1
a303 3
  "specifying an empty password.\n"
  "\n"
  "Report bugs to <cygwin@@cygwin.com>\n", prog_name);
d353 9
a361 18
  const char *v = strchr (version, ':');
  int len;
  if (!v)
    {
      v = "?";
      len = 1;
    }
  else
    {
      v += 2;
      len = strchr (v, ' ') - v;
    }
  printf ("\
%s (cygwin) %.*s\n\
Password Utility\n\
Copyright 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.\n\
Compiled on %s\n\
", prog_name, len, v, __DATE__);
d367 1
a367 1
  char *c, *logonserver;
d390 1
a390 10
  prog_name = strrchr (argv[0], '/');
  if (prog_name == NULL)
    prog_name = strrchr (argv[0], '\\');
  if (prog_name == NULL)
    prog_name = argv[0];
  else
    prog_name++;
  c = strrchr (prog_name, '.');
  if (c)
    *c = '\0';
d484 1
a484 1
      case 'v':
d523 2
a524 1
        usage (stderr, 1);
@


1.20
log
@	* cygpath.cc (main): Only setlocale for LC_CTYPE category.  Fallback
	to UTF-8 if locale is "C".
	* ldd.cc (main): Ditto.
	* mkgroup.c (main): Ditto.
	* mkpasswd.c (main): Ditto.
	* passwd.c (main): Ditto.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2008, 2009 Red Hat, Inc.
d547 1
d549 18
a566 1
        usage (stderr, 1);
d577 3
a579 3
"You can delete your stored password by specifying an empty password.\n\n");
      strcpy (newpwd, getpass ("Enter your current password: "));
      if (strcmp (newpwd, getpass ("Re-enter your current password: ")))
d581 1
a581 1
      else if (cygwin_internal (CW_SET_PRIV_KEY, newpwd))
@


1.19
log
@	* passwd.c (usage): Change description for -d option according to
	previous change.
	(main): Fix typo.
	* utils.sgml: Add missing description for passwd -d option.
@
text
@d411 4
a414 2
  setlocale (LC_ALL, "");

@


1.18
log
@	* passwd.c (caller_is_admin): New function to test if calling user
	is an administrator by inspecting user token.
	(main): Drop fetching caller info from logonserver.  Only fetch
	server from environment when trying to change password for own
	account.  Drop admin check entirely in case of doing account
	maintainance.  Otherwise replace check for admin by result of
	caller_is_admin call.
@
text
@d283 3
a285 1
  "                           default server is the content of $LOGONSERVER.\n"
d576 1
a576 1
  if (!server && optind < argc)
@


1.17
log
@	* passwd.c (main): Always get logonserver from environment and
	use when fetching user info for caller.
@
text
@d306 43
d394 2
a395 2
  PUSER_INFO_3 ui, li;
  LPWSTR my_server = NULL;
a563 10
  if ((logonserver = getenv ("LOGONSERVER")))
    {
      size_t len = mbstowcs (NULL, logonserver, 0);
      if (len > 0 && len != (size_t) -1)
	mbstowcs (my_server = alloca ((len + 1) * sizeof (wchar_t)),
		  logonserver, len + 1);
      if (!server)
	server = my_server;
    }

d573 12
a584 3
  li = GetPW (getlogin (), 0, my_server);
  if (! li)
    return 1;
a593 2
      if (li->usri3_priv != USER_PRIV_ADMIN)
        return eprint (0, "You have no maintenance privileges.");
d627 1
a627 1
  if (li->usri3_priv != USER_PRIV_ADMIN && strcmp (getlogin (), user))
d634 1
a634 1
  if (li->usri3_priv != USER_PRIV_ADMIN)
@


1.16
log
@	* ldd.cc: Fix compiler warning.

	* passwd.c: Use mbstowcs instead of MultiByteToWideChar throughout.
	(main): Call setlocale.  Fix a bug in fetching the logon server from
	the environment.
@
text
@d352 1
d521 1
a521 1
  if (!server && (logonserver = getenv ("LOGONSERVER")))
d525 1
a525 1
	mbstowcs (server = alloca ((len + 1) * sizeof (wchar_t)),
d527 2
d540 1
a540 1
  li = GetPW (getlogin (), 0, server);
@


1.15
log
@ChangeLog:

	* configure.in: Remove --enable-server option.  Allways add the
	cygserver directory to $SUBDIRS.
	* configure: Regenerate.

cygwin/ChangeLog:

	Remove USE_SERVER define.  Accommodate throughout.
	* configure.in: Remove --enable-server option.
	* configure: Regenerate.
	* environ.cc: Remove CYGWIN=server setting.

cygserver/ChangeLog:

	* client.cc (allow_server): Remove variable.
	(client_request_get_version::client_request_get_version): Drop checking
	allow_server.

utils/ChangeLog:

	* passwd.c: Remove CYGWIN=server requirement from usage text.

doc/ChangeLog:

	* cygserver.sgml: Remove the "How to use the Cygserver services"
	section.
	* cygwinenv.sgml: Move "(no)server" to the removed options section.
	* faq-programming.xml: Remove CYGWIN=server requirement for running
	the Cygwin testsuite.
	* ntsec.sgml: Ditto for using `passwd -R'.
@
text
@d30 2
d119 1
a119 1
  WCHAR name[2 * (UNLEN + 1)];
d140 1
a140 1
  MultiByteToWideChar (CP_ACP, 0, user, -1, name, 2 * (UNLEN + 1));
d149 1
a149 1
  WCHAR name[2 * (UNLEN + 1)], oldpass[512], pass[512];
d152 2
a153 2
  MultiByteToWideChar (CP_ACP, 0, user, -1, name, 2 * (UNLEN + 1));
  MultiByteToWideChar (CP_ACP, 0, pwd, -1, pass, 512);
d163 1
a163 1
      MultiByteToWideChar (CP_ACP, 0, oldpwd, -1, oldpass, 512);
d332 1
a332 1
  char *c;
d336 1
a336 1
  int opt, len;
d365 2
d424 4
a427 4
	  server = alloca ((strlen (tmpbuf) + 1) * sizeof (WCHAR));
	  if (MultiByteToWideChar (CP_ACP, 0, tmpbuf, -1, server,
				   strlen (tmpbuf) + 1) <= 0)
	    server = NULL;
d520 1
a520 1
  if (!server)
d522 4
a525 7
      len = GetEnvironmentVariableW (L"LOGONSERVER", NULL, 0);
      if (len > 0)
	{
	  server = alloca (len * sizeof (WCHAR));
	  if (GetEnvironmentVariableW (L"LOGONSERVER", server, len) <= 0)
	    server = NULL;
	}
@


1.14
log
@	* passwd.c (main): Put how to delete the registry password on its own
	line in passwd -R output.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2008 Red Hat, Inc.
d292 2
a293 2
  "Non-Admin users can only store their password if cygserver is running and\n"
  "the CYGWIN environment variable is set to contain the word 'server'.\n"
@


1.13
log
@	* passwd.c (longopts): Add --reg-store-pwd option.
	(opts): Add -R option.
	(usage): Add text for -R/--reg-store-pwd option.
	(main): Fix size of local user and password string arrays.
	Handle -R option.
	* utils.sgml: Add text for passwd -R/--reg-store-pwd option.
@
text
@d506 2
a507 1
"session.  You can delete your stored password by specifying an empty password.\n\n");
@


1.12
log
@	* passwd.c (longopts): Add --logonserver option.
	(opts): Add -d option.
	(GetPW): Add server parameter which is given to Net functions.
	(ChangePW): Ditto.
	(PrintPW): Ditto.
	(SetModals): Ditto.
	(usage): Add description for -d/--logonserver option.
	(main): Add option handling for -d/--logonserver.  Use LOGONSERVER
	environment variable content for server to contact, unless
	-d/--logonserver option is given.  If both is missing, use NULL.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
d29 1
d54 1
d58 1
a58 1
static char opts[] = "cCd:eEhi:ln:pPuvx:L:S";
d268 3
d289 10
a298 1
  "operations.  Don't specify a USER when triggering a system operation. \n"
d331 1
a331 1
  char user[64], oldpwd[64], newpwd[64];
d348 1
d371 1
a371 1
	if (lopt || uopt || copt || Copt || eopt || Eopt || popt || Popt || Sopt)
d378 1
a378 1
	if (xarg >= 0 || narg >= 0 || iarg >= 0 || Larg >= 0 || uopt || Sopt)
d384 1
a384 1
	if (lopt || uopt || copt || Copt || eopt || Eopt || popt || Popt || Sopt)
d394 1
a394 1
	if (xarg >= 0 || narg >= 0 || iarg >= 0 || Larg >= 0 || lopt || Sopt)
d400 1
a400 1
	if (xarg >= 0 || narg >= 0 || iarg >= 0 || Larg >= 0 || Sopt)
d406 1
a406 1
	if (xarg >= 0 || narg >= 0 || iarg >= 0 || Larg >= 0 || Sopt)
d413 2
d428 1
a428 1
	if (xarg >= 0 || narg >= 0 || iarg >= 0 || Larg >= 0 || Sopt)
d434 1
a434 1
	if (xarg >= 0 || narg >= 0 || iarg >= 0 || Larg >= 0 || Sopt)
d440 1
a440 1
	if (xarg >= 0 || narg >= 0 || iarg >= 0 || Larg >= 0 || Sopt)
d446 1
a446 1
	if (xarg >= 0 || narg >= 0 || iarg >= 0 || Larg >= 0 || Sopt)
d457 1
a457 1
	if (lopt || uopt || copt || Copt || eopt || Eopt || popt || Popt || Sopt)
d467 1
a467 1
	if (lopt || uopt || copt || Copt || eopt || Eopt || popt || Popt || Sopt)
d476 1
a476 1
	    || copt || Copt || eopt || Eopt || popt || Popt)
d481 8
d493 22
@


1.11
log
@	* mkgroup.c: Avoid compiler warnings throughout.
	* mkpasswd.c: Ditto.
	* passwd.c: Ditto.
@
text
@d39 1
d56 1
a56 1
static char opts[] = "cCeEhi:ln:pPuvx:L:S";
d112 1
a112 1
GetPW (char *user, int print_win_name)
d137 1
a137 1
  ret = NetUserGetInfo (NULL, name, 3, (void *) &ui);
d142 2
a143 1
ChangePW (const char *user, const char *oldpwd, const char *pwd, int justcheck)
d155 1
a155 1
      ret = NetUserSetInfo (NULL, name, 1003, (LPBYTE) &ui, NULL);
d160 1
a160 1
      ret = NetUserChangePassword (NULL, name, oldpass, pass);
d172 1
a172 1
PrintPW (PUSER_INFO_3 ui)
d189 1
a189 1
  ret = NetUserModalsGet (NULL, 0, (void *) &mi);
d213 1
a213 1
SetModals (int xarg, int narg, int iarg, int Larg)
d218 1
a218 1
  ret = NetUserModalsGet (NULL, 0, (void *) &mi);
d242 1
a242 1
      ret = NetUserModalsSet (NULL, 0, (LPBYTE) mi, NULL);
d275 2
d320 1
a320 1
  int opt;
d335 1
d396 14
d467 12
d483 1
a483 1
      return SetModals (xarg, narg, iarg, Larg);
d488 1
a488 1
  li = GetPW (getlogin (), 0);
d492 1
a492 1
  ui = GetPW (user, 1);
d526 1
a526 1
          ret = NetUserSetInfo (NULL, ui->usri3_name, 1008, (LPBYTE) &uif,
d531 1
a531 1
      PrintPW (ui);
d545 1
a545 1
      if (ChangePW (user, oldpwd, oldpwd, 1))
d554 1
a554 1
      else if (! ChangePW (user, *oldpwd ? oldpwd : NULL, newpwd, 0))
@


1.10
log
@	* passwd.c (PrintPW): Turn around meaning printed for "Password not
	required" option to be in line with Windows meaning.
	(main): Use more appropriate 1008 option when calling
	NetUserSetInfo to change flag values.
@
text
@d136 1
a136 1
  ret = NetUserGetInfo (NULL, name, 3, (LPBYTE *) &ui);
d187 1
a187 1
  ret = NetUserModalsGet (NULL, 0, (LPBYTE *) &mi);
d216 1
a216 1
  ret = NetUserModalsGet (NULL, 0, (LPBYTE *) &mi);
@


1.9
log
@	* passwd.c (UF_LOCKOUT): Remove (defined in lmaccess.h).
	(version): Bump version number to 1.5.
	(longopts): Add -c, -C, -e, -E, -p, -P options.
	(opts): Ditto.
	(PrintPW): Print values of UF_PASSWD_CANT_CHANGE and
	UF_DONT_EXPIRE_PASSWD flags. Slightly reformat output. Don't suppress
	correct system password settings just because the account has admin
	privileges.
	(usage): Define as "noreturn" function. Restructure and rephrase
	output. Accomodate new options.
	(print_version): Fix copyright dates.
	(main): Accomodate new options for setting UF_PASSWD_CANT_CHANGE,
	UF_DONT_EXPIRE_PASSWD and UF_PASSWD_NOTREQD settings.
@
text
@d178 2
a179 2
  printf ("Password required          : %s",
  	(ui->usri3_flags & UF_PASSWD_NOTREQD) ? "no\n" : "yes\n");
d467 2
d471 1
d476 1
a476 1
          ui->usri3_flags |= UF_ACCOUNTDISABLE;
d479 1
a479 1
        ui->usri3_flags &= ~UF_ACCOUNTDISABLE;
d481 1
a481 1
        ui->usri3_flags |= UF_PASSWD_CANT_CHANGE;
d483 1
a483 1
        ui->usri3_flags &= ~UF_PASSWD_CANT_CHANGE;
d485 1
a485 1
        ui->usri3_flags |= UF_DONT_EXPIRE_PASSWD;
d487 1
a487 1
        ui->usri3_flags &= ~UF_DONT_EXPIRE_PASSWD;
d489 1
a489 1
        ui->usri3_flags |= UF_PASSWD_NOTREQD;
d491 1
a491 1
        ui->usri3_flags &= ~UF_PASSWD_NOTREQD;
d495 2
a496 1
          ret = NetUserSetInfo (NULL, ui->usri3_name, 3, (LPBYTE) ui, NULL);
@


1.8
log
@* cygcheck.cc (usage) Add description output.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002 Red Hat, Inc.
d32 1
a32 3
#define UF_LOCKOUT            0x00010

static const char version[] = "$Revision: 1.4 $";
d37 4
d45 2
d55 1
a55 1
static char opts[] = "L:x:n:i:luShv";
d176 11
a186 7
  printf ("Account disabled : %s", (ui->usri3_flags & UF_ACCOUNTDISABLE)
                                ? "yes\n" : "no\n");
  printf ("Password required: %s", (ui->usri3_flags & UF_PASSWD_NOTREQD)
                                ? "no\n" : "yes\n");
  printf ("Password expired : %s", (ui->usri3_password_expired)
                                ? "yes\n" : "no\n");
  printf ("Password changed : %s", ctime(&t));
d190 1
a190 2
      if (mi->usrmod0_max_passwd_age == TIMEQ_FOREVER
          || ui->usri3_priv == USER_PRIV_ADMIN)
d192 1
a192 2
      if (mi->usrmod0_min_passwd_age == TIMEQ_FOREVER
          || ui->usri3_priv == USER_PRIV_ADMIN)
d194 1
a194 2
      if (mi->usrmod0_force_logoff == TIMEQ_FOREVER
          || ui->usri3_priv == USER_PRIV_ADMIN)
d198 1
d246 1
d251 2
a252 3
  "Usage: %s (-l|-u|-S) [USER]\n"
  "       %s [-i NUM] [-n MINDAYS] [-x MAXDAYS] [-L LEN]\n"
  "Change USER's password or password attributes\n"
d255 9
a263 3
  " -l, --lock      lock USER's account\n"
  " -u, --unlock    unlock USER's account\n"
  " -S, --status    display password status for USER (locked, expired, etc.)\n"
d266 5
a270 5
  " -i, --inactive  set NUM of days before inactive accounts are disabled\n"
  "                 (inactive accounts are those with expired passwords)\n"
  " -n, --minage    set system minimum password age to MINDAYS\n"
  " -x, --maxage    set system maximum password age to MAXDAYS\n"
  " -L, --length    set system minimum password length to LEN\n"
d273 10
a282 3
  " -h, --help      output usage information and exit\n"
  " -v, --version   output version information and exit\n"
  "", prog_name, prog_name);
d304 1
a304 1
Copyright 1999, 2000, 2001, 2002 Red Hat, Inc.\n\
d323 6
d351 2
d364 2
d379 36
d421 2
d431 2
d439 2
a440 1
	if (xarg >= 0 || narg >= 0 || iarg >= 0 || Larg >= 0 || lopt || uopt)
d465 1
a465 1
  if (lopt || uopt || Sopt)
d477 14
a490 1
      if (lopt || uopt)
@


1.7
log
@Add final newlines to utils
@
text
@d246 1
@


1.6
log
@	* passwd.c: Rearrange includes to avoid unnecessary warnings.
	(GetPW): Add parameter to (dis)allow printing of Windows username.
	Use defines instead of numerical constants where possible.
	Try avoiding impersonation problem.  Rearrange to print Windows
	username only if it's different from Cygwin username.
	(ChangePW): Use defines instead of numerical constants where possible.
	(main): Call GetPW with additional parameter.  Change error text.

	* passwd.c (GetPW): Handle case of user-edited /etc/passwd
	with cygwin_internal (CW_EXTRACT_DOMAIN_AND_USER, ...).
@
text
@d285 2
a286 1
Compiled on %s", prog_name, len, v, __DATE__);
@


1.5
log
@	* passwd.c (prog_name): New global variable.
	(longopts): Ditto.
	(opts): Ditto.
	(usage): Standardize output. Accomodate new options.
	(print_version): New function.
	(main): Accomodate longopts and new --help, --version options.
@
text
@d13 7
d26 1
a29 6
#include <windows.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <lmcons.h>
#include <lmapibuf.h>

d107 1
a107 1
GetPW (const char *user)
d109 2
a110 1
  WCHAR name[512];
d113 19
a131 2

  MultiByteToWideChar (CP_ACP, 0, user, -1, name, 512);
d139 1
a139 1
  WCHAR name[512], oldpass[512], pass[512];
d142 1
a142 1
  MultiByteToWideChar (CP_ACP, 0, user, -1, name, 512);
d385 1
a385 1
  li = GetPW (getlogin ());
d389 1
a389 1
  ui = GetPW (user);
d400 1
a400 1
	    return eprint (0, "You may not lock an administrators account.");
@


1.4
log
@* mkgroup.c (usage): Use one just fprintf + string concatenation for output
message.
(print_version): Add void to function type and update copyright.
@
text
@d32 18
a49 1
char *myname;
d57 1
a57 1
    fprintf(stderr, "%s: ", myname);
d220 28
a247 2
int
usage ()
d249 17
a265 5
  fprintf (stderr, "usage: %s [name]\n", myname);
  fprintf (stderr, "       %s [-L maxlen] [-x max] [-n min] [-i inact]\n",
           myname);
  fprintf (stderr, "       %s {-l|-u|-S} name\n", myname);
  return 2;
d285 5
a289 3
 if ((myname = strrchr (argv[0], '/'))
      || (myname = strrchr (argv[0], '\\')))
    ++myname;
d291 2
a292 2
    myname = argv[0];
  c = strrchr (myname, '.');
d296 1
a296 1
  while ((opt = getopt (argc, argv, "L:x:n:i:luS")) != EOF)
d299 13
a311 6
      case 'x':
	if ((xarg = atoi (optarg)) < 0 || xarg > 999)
	  return eprint (1, "Maximum password age must be between 0 and 999.");
	if (narg >= 0 && xarg < narg)
	  return eprint (1, "Maximum password age must be greater than "
	                    "minimum password age.");
d322 17
a338 3
      case 'i':
	if ((iarg = atoi (optarg)) < 0 || iarg > 999)
	  return eprint (1, "Force logout time must be between 0 and 999.");
a346 12
      case 'l':
	if (xarg >= 0 || narg >= 0 || iarg >= 0 || Larg >= 0 || uopt || Sopt)
	  return usage ();
	lopt = 1;
        break;

      case 'u':
	if (xarg >= 0 || narg >= 0 || iarg >= 0 || Larg >= 0 || lopt || Sopt)
	  return usage ();
	uopt = 1;
        break;

d349 1
a349 1
	  return usage ();
d354 1
a354 1
        return usage ();
d359 1
a359 1
        return usage ();
@


1.3
log
@	* passwd.cc (ChangePW): Add parameter to differ between called for
	checking old password and called for changing password.  If called
	for checking old password, return non-zero only if password is surely
	incorrect.
	(main): Call ChangePW() with additional parameter.
@
text
@d3 1
a3 1
   Copyright 1999 Cygnus Solutions.
@


1.2
log
@* passwd.c (main): Initialize oldpwd before beeing used.
@
text
@d100 1
a100 1
ChangePW (const char *user, const char *oldpwd, const char *pwd)
d119 3
a121 1
  if (! EvalRet (ret, user))
d339 1
a339 1
      if (ChangePW (user, oldpwd, oldpwd))
d348 1
a348 1
      else if (! ChangePW (user, *oldpwd ? oldpwd : NULL, newpwd))
@


1.1
log
@Initial revision
@
text
@d333 1
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@


1.1.1.1.2.1
log
@* passwd.c (main): Initialize oldpwd before beeing used.
@
text
@a332 1
  oldpwd[0] = '\0';
@

