head	1.71;
access;
symbols
	cygwin-1_7_35-release:1.71
	cygwin-1_7_34-release:1.71
	cygwin-1_7_33-release:1.71
	cygwin-1_7_32-release:1.71
	cygwin-1_7_31-release:1.71
	cygwin-1_7_30-release:1.71
	cygwin-1_7_29-release:1.71
	cygwin-1_7_29-release-branchpoint:1.71.0.2
	cygwin-1_7_28-release:1.71
	cygwin-1_7_27-release:1.71
	cygwin-1_7_26-release:1.71
	cygwin-1_7_25-release:1.71
	cygwin-1_7_24-release:1.71
	cygwin-1_7_23-release:1.71
	cygwin-1_7_22-release:1.71
	cygwin-1_7_21-release:1.71
	cygwin-1_7_20-release:1.70
	cygwin-1_7_19-release:1.70
	cygwin-64bit-postmerge:1.70
	cygwin-64bit-premerge-branch:1.70.0.2
	cygwin-64bit-premerge:1.70
	cygwin-1_7_18-release:1.70
	cygwin-1_7_17-release:1.69
	cygwin-64bit-branch:1.69.0.2
	cygwin-1_7_16-release:1.69
	cygwin-1_7_15-release:1.68
	cygwin-1_7_14_2-release:1.68
	cygwin-1_7_14-release:1.68
	cygwin-1_7_12-release:1.68
	cygwin-1_7_11-release:1.68
	cygwin-1_7_10-release:1.68
	cygwin-1_7_9-release:1.65
	cygwin-1_7_8-release:1.65
	cygwin-1_7_7-release:1.63
	cygwin-1_7_5-release:1.61
	cygwin-1_7_4-release:1.61
	cygwin-1_7_3-release:1.61
	cygwin-1_7_2-release:1.61
	cygwin-1_7_1-release:1.56
	cv-branch-2:1.55.0.2
	cr-0x5f1:1.42.0.4
	cv-branch:1.42.0.2
	cr-0x3b58:1.41.0.2
	cr-0x9e:1.33.0.2
	cr-0x9d:1.32.0.2
	corinna-01:1.32
	cr-0x9c:1.29.0.2
	cr-0x9b:1.29.0.4
	cr-0x99:1.28
	Z-emcb-cygwin_daemon:1.28.0.2
	w32api-2_2:1.25
	mingw-runtime-2_4:1.25
	cygnus_cvs_20020108_pre:1.11
	Z-cygwin_daemon_merge-new_HEAD:1.8
	Z-cygwin_daemon_merge_HEAD:1.8
	cygwin_daemon:1.8.0.4;
locks; strict;
comment	@// @;


1.71
date	2013.06.26.13.10.35;	author corinna;	state Exp;
branches;
next	1.70;

1.70
date	2013.01.21.16.28.27;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2012.07.06.14.52.33;	author corinna;	state Exp;
branches
	1.69.2.1;
next	1.68;

1.68
date	2011.12.17.23.39.47;	author cgf;	state Exp;
branches;
next	1.67;

1.67
date	2011.12.02.16.15.26;	author corinna;	state Exp;
branches;
next	1.66;

1.66
date	2011.10.10.14.57.47;	author corinna;	state Exp;
branches;
next	1.65;

1.65
date	2010.12.06.13.40.24;	author corinna;	state Exp;
branches;
next	1.64;

1.64
date	2010.09.06.09.48.55;	author corinna;	state Exp;
branches;
next	1.63;

1.63
date	2010.08.28.11.22.37;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2010.08.26.12.06.27;	author corinna;	state Exp;
branches;
next	1.61;

1.61
date	2010.02.22.17.40.46;	author corinna;	state Exp;
branches;
next	1.60;

1.60
date	2010.02.13.11.41.53;	author corinna;	state Exp;
branches;
next	1.59;

1.59
date	2010.01.16.10.25.58;	author corinna;	state Exp;
branches;
next	1.58;

1.58
date	2010.01.07.17.19.12;	author corinna;	state Exp;
branches;
next	1.57;

1.57
date	2010.01.07.12.08.11;	author corinna;	state Exp;
branches;
next	1.56;

1.56
date	2009.10.15.11.40.02;	author corinna;	state Exp;
branches;
next	1.55;

1.55
date	2009.05.17.11.16.12;	author corinna;	state Exp;
branches;
next	1.54;

1.54
date	2009.05.15.11.30.18;	author corinna;	state Exp;
branches;
next	1.53;

1.53
date	2009.04.15.10.00.40;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2009.03.14.14.56.20;	author corinna;	state Exp;
branches;
next	1.51;

1.51
date	2008.07.22.14.40.05;	author corinna;	state Exp;
branches;
next	1.50;

1.50
date	2008.03.12.12.47.09;	author corinna;	state Exp;
branches;
next	1.49;

1.49
date	2007.05.29.07.54.45;	author corinna;	state Exp;
branches;
next	1.48;

1.48
date	2007.05.23.16.45.03;	author corinna;	state Exp;
branches;
next	1.47;

1.47
date	2007.03.31.00.03.25;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2007.01.09.12.17.05;	author corinna;	state Exp;
branches;
next	1.45;

1.45
date	2006.08.02.09.48.18;	author corinna;	state Exp;
branches;
next	1.44;

1.44
date	2006.07.31.07.31.56;	author corinna;	state Exp;
branches;
next	1.43;

1.43
date	2006.07.27.21.07.33;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2006.02.17.12.17.47;	author corinna;	state Exp;
branches
	1.42.4.1;
next	1.41;

1.41
date	2006.01.18.12.34.59;	author davek;	state Exp;
branches;
next	1.40;

1.40
date	2005.11.22.17.19.17;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2005.05.17.01.26.16;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2005.03.06.18.00.03;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2005.02.24.04.32.45;	author joshuadfranklin;	state Exp;
branches;
next	1.36;

1.36
date	2004.03.15.21.34.12;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2004.02.25.01.23.20;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2004.02.21.04.51.15;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2004.01.22.09.21.56;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2003.11.07.18.30.35;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2003.10.17.17.20.06;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2003.10.17.17.19.31;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2003.09.11.02.56.40;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.12.20.40.58;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2003.04.26.21.52.03;	author joshuadfranklin;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.12.22.48.13;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2002.10.31.02.40.26;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2002.09.30.03.01.17;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2002.09.15.15.19.49;	author joshuadfranklin;	state Exp;
branches;
next	1.22;

1.22
date	2002.08.23.15.46.00;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.01.20.54.35;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.19.02.09.41;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.07.19.25.26;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.22.10.05.41;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.15.11.36.00;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.14.16.07.26;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.07.03.00.14;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.27.21.20.09;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.17.16.54.01;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.15.14.07.42;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.26.17.46.12;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.11.22.51.01;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.04.04.12.39;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.15.03.24.18;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.28.05.00.00;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.19.01.26.45;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.19.17.06.28;	author dj;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.18.18.39.11;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.13.05.23.30;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.11.02.57.25;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.69.2.1
date	2013.01.29.21.54.42;	author corinna;	state Exp;
branches;
next	;

1.42.4.1
date	2007.11.12.15.31.45;	author corinna;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.71
log
@	* cygpath.cc (do_pathconv): when -p option is given, generate wide
	path without long path prefixing.
	* wide_path.h (wide_path::wide_path): Allow extra bool parameter to
	specify whether or not performing Windows long path prefixing.
@
text
@/* cygpath.cc -- convert pathnames between Windows and Unix format
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
   2009, 2010, 2011, 2012, 2013 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include <stdio.h>
#include <string.h>
#include <wchar.h>
#include <locale.h>
#include <stdlib.h>
#include <limits.h>
#include <getopt.h>
#include <io.h>
#include <sys/fcntl.h>
#include <sys/cygwin.h>
#include <cygwin/version.h>
#include <ctype.h>
#include <errno.h>

#define _WIN32_WINNT 0x0602
#define WINVER 0x0602
#define NOCOMATTRIBUTE
#include <windows.h>
#include <userenv.h>
#include <shlobj.h>
#include <ntdef.h>
#include <ntdll.h>

#include "wide_path.h"
#include "loadlib.h"

static char *prog_name;
static char *file_arg, *output_arg;
static int path_flag, unix_flag, windows_flag, absolute_flag;
static int shortname_flag, longname_flag;
static int ignore_flag, allusers_flag, output_flag;
static int mixed_flag, options_from_file_flag, mode_flag;
static UINT codepage;

static const char *format_type_arg;

static struct option long_options[] = {
  {(char *) "absolute", no_argument, NULL, 'a'},
  {(char *) "close", required_argument, NULL, 'c'},
  {(char *) "dos", no_argument, NULL, 'd'},
  {(char *) "file", required_argument, NULL, 'f'},
  {(char *) "help", no_argument, NULL, 'h'},
  {(char *) "ignore", no_argument, NULL, 'i'},
  {(char *) "long-name", no_argument, NULL, 'l'},
  {(char *) "mixed", no_argument, NULL, 'm'},
  {(char *) "mode", no_argument, NULL, 'M'},
  {(char *) "option", no_argument, NULL, 'o'},
  {(char *) "path", no_argument, NULL, 'p'},
  {(char *) "short-name", no_argument, NULL, 's'},
  {(char *) "type", required_argument, NULL, 't'},
  {(char *) "unix", no_argument, NULL, 'u'},
  {(char *) "version", no_argument, NULL, 'V'},
  {(char *) "windows", no_argument, NULL, 'w'},
  {(char *) "allusers", no_argument, NULL, 'A'},
  {(char *) "desktop", no_argument, NULL, 'D'},
  {(char *) "homeroot", no_argument, NULL, 'H'},
  {(char *) "mydocs", no_argument, NULL, 'O'},
  {(char *) "smprograms", no_argument, NULL, 'P'},
  {(char *) "sysdir", no_argument, NULL, 'S'},
  {(char *) "windir", no_argument, NULL, 'W'},
  {(char *) "folder", required_argument, NULL, 'F'},
  {(char *) "codepage", required_argument, NULL, 'C'},
  {0, no_argument, 0, 0}
};

static char options[] = "ac:df:hilmMopst:uVwAC:DHOPSWF:";

static void
usage (FILE * stream, int status)
{
  if (!ignore_flag || !status)
    fprintf (stream, "\
Usage: %1$s (-d|-m|-u|-w|-t TYPE) [-f FILE] [OPTION]... NAME...\n\
       %1$s [-c HANDLE] \n\
       %1$s [-ADHOPSW] \n\
       %1$s [-F ID] \n\
\n\
Convert Unix and Windows format paths, or output system path information\n\
\n\
Output type options:\n\
\n\
  -d, --dos             print DOS (short) form of NAMEs (C:\\PROGRA~1\\)\n\
  -m, --mixed           like --windows, but with regular slashes (C:/WINNT)\n\
  -M, --mode            report on mode of file (binmode or textmode)\n\
  -u, --unix            (default) print Unix form of NAMEs (/cygdrive/c/winnt)\n\
  -w, --windows         print Windows form of NAMEs (C:\\WINNT)\n\
  -t, --type TYPE       print TYPE form: 'dos', 'mixed', 'unix', or 'windows'\n\
\n\
Path conversion options:\n\
\n\
  -a, --absolute        output absolute path\n\
  -l, --long-name       print Windows long form of NAMEs (with -w, -m only)\n\
  -p, --path            NAME is a PATH list (i.e., '/bin:/usr/bin')\n\
  -s, --short-name      print DOS (short) form of NAMEs (with -w, -m only)\n\
  -C, --codepage CP     print DOS, Windows, or mixed pathname in Windows\n\
                        codepage CP.  CP can be a numeric codepage identifier,\n\
                        or one of the reserved words ANSI, OEM, or UTF8.\n\
                        If this option is missing, %1$s defaults to the\n\
                        character set defined by the current locale.\n\
\n\
System information:\n\
\n\
  -A, --allusers        use `All Users' instead of current user for -D, -O, -P\n\
  -D, --desktop         output `Desktop' directory and exit\n\
  -H, --homeroot        output `Profiles' directory (home root) and exit\n\
  -O, --mydocs          output `My Documents' directory and exit\n\
  -P, --smprograms      output Start Menu `Programs' directory and exit\n\
  -S, --sysdir          output system directory and exit\n\
  -W, --windir          output `Windows' directory and exit\n\
  -F, --folder ID       output special folder with numeric ID and exit\n\
", prog_name);
  if (ignore_flag)
    /* nothing to do */;
  else if (stream != stdout)
    fprintf(stream, "Try `%s --help' for more information.\n", prog_name);
  else
    {
      fprintf (stream, "\
\n\
Other options:\n\
\n\
  -f, --file FILE       read FILE for input; use - to read from STDIN\n\
  -o, --option          read options from FILE as well (for use with --file)\n\
  -c, --close HANDLE    close HANDLE (for use in captured process)\n\
  -i, --ignore          ignore missing argument\n\
  -h, --help            output usage information and exit\n\
  -V, --version         output version information and exit\n\
\n");
    }
  exit (ignore_flag ? 0 : status);
}

static inline BOOLEAN
RtlAllocateUnicodeString (PUNICODE_STRING uni, ULONG size)
{
  uni->Length = 0;
  uni->MaximumLength = size / sizeof (WCHAR);
  uni->Buffer = (WCHAR *) malloc (size);
  return uni->Buffer != NULL;
}

static size_t
my_wcstombs (char *dest, const wchar_t *src, size_t n)
{
  if (codepage)
    return WideCharToMultiByte (codepage, 0, src, -1, dest, n, NULL, NULL);
  else
    return wcstombs (dest, src, n);
}

#define	HARDDISK_PREFIX		L"\\Device\\Harddisk"
#define	GLOBALROOT_PREFIX	"\\\\.\\GLOBALROOT"

static char *
get_device_name (char *path)
{
  UNICODE_STRING ntdev, tgtdev, ntdevdir;
  ANSI_STRING ans;
  OBJECT_ATTRIBUTES ntobj;
  NTSTATUS status;
  HANDLE lnk, dir;
  bool got_one = false;
  char *ret = strdup (path);
  PDIRECTORY_BASIC_INFORMATION odi = (PDIRECTORY_BASIC_INFORMATION)
				     alloca (4096);
  BOOLEAN restart;
  ULONG cont;

  if (!strncasecmp (path, GLOBALROOT_PREFIX "\\", sizeof (GLOBALROOT_PREFIX)))
    path += sizeof (GLOBALROOT_PREFIX) - 1;
  if (strncasecmp (path, "\\Device\\", 8))
    return ret;

  if (!RtlAllocateUnicodeString (&ntdev, 65534))
    return ret;
  if (!RtlAllocateUnicodeString (&tgtdev, 65534))
    return ret;
  RtlInitAnsiString (&ans, path);
  RtlAnsiStringToUnicodeString (&ntdev, &ans, FALSE);

  /* First check if the given device name is a symbolic link itself.  If so,
     query it and use the new name as actual device name to search for in the
     DOS device name directory.  If not, just use the incoming device name. */
  InitializeObjectAttributes (&ntobj, &ntdev, OBJ_CASE_INSENSITIVE, NULL, NULL);
  status = NtOpenSymbolicLinkObject (&lnk, SYMBOLIC_LINK_QUERY, &ntobj);
  if (NT_SUCCESS (status))
    {
      status = NtQuerySymbolicLinkObject (lnk, &tgtdev, NULL);
      NtClose (lnk);
      if (!NT_SUCCESS (status))
	goto out;
      RtlCopyUnicodeString (&ntdev, &tgtdev);
    }
  else if (status != STATUS_OBJECT_TYPE_MISMATCH
	   && status != STATUS_OBJECT_PATH_SYNTAX_BAD)
    goto out;

  for (int i = 0; i < 2; ++i)
    {
      /* There are two DOS device directories, the local and the global dir.
	 Try both, local first. */
      RtlInitUnicodeString (&ntdevdir, i ? L"\\GLOBAL??" : L"\\??");

      /* Open the directory... */
      InitializeObjectAttributes (&ntobj, &ntdevdir, OBJ_CASE_INSENSITIVE,
				  NULL, NULL);
      status = NtOpenDirectoryObject (&dir, DIRECTORY_QUERY, &ntobj);
      if (!NT_SUCCESS (status))
	break;

      /* ...and scan it. */
      for (restart = TRUE, cont = 0;
	   NT_SUCCESS (NtQueryDirectoryObject (dir, odi, 4096, TRUE,
					       restart, &cont, NULL));
	   restart = FALSE)
	{
	  /* For each entry check if it's a symbolic link. */
	  InitializeObjectAttributes (&ntobj, &odi->ObjectName,
				      OBJ_CASE_INSENSITIVE, dir, NULL);
	  status = NtOpenSymbolicLinkObject (&lnk, SYMBOLIC_LINK_QUERY, &ntobj);
	  if (!NT_SUCCESS (status))
	    continue;
	  tgtdev.Length = 0;
	  tgtdev.MaximumLength = 512;
	  /* If so, query it and compare the target of the symlink with the
	     incoming device name. */
	  status = NtQuerySymbolicLinkObject (lnk, &tgtdev, NULL);
	  NtClose (lnk);
	  if (!NT_SUCCESS (status))
	    continue;
	  if (tgtdev.Length /* There's actually a symlink pointing to an
			       empty string: \??\GLOBALROOT -> "" */
	      && RtlEqualUnicodePathPrefix (&ntdev, &tgtdev, TRUE))
	    {
	      /* If the comparison succeeds, the name of the directory entry is
		 a valid DOS device name, if prepended with "\\.\".  Return that
		 valid DOS path. */
	      wchar_t *trailing = NULL;
	      if (ntdev.Length > tgtdev.Length)
		trailing = ntdev.Buffer + tgtdev.Length / sizeof (WCHAR);
	      ULONG len = RtlUnicodeStringToAnsiSize (&odi->ObjectName);
	      if (trailing)
		len += my_wcstombs (NULL, trailing, 0);
	      free (ret);
	      ret = (char *) malloc (len + 4);
	      strcpy (ret, "\\\\.\\");
	      ans.Length = 0;
	      ans.MaximumLength = len;
	      ans.Buffer = ret + 4;
	      RtlUnicodeStringToAnsiString (&ans, &odi->ObjectName, FALSE);
	      if (trailing)
		my_wcstombs (ans.Buffer + ans.Length, trailing,
			     ans.MaximumLength - ans.Length);
	      ans.Buffer[ans.MaximumLength - 1] = '\0';
	      got_one = true;
	      /* Special case for local disks:  It's most feasible if the
		 DOS device name reflects the DOS drive, so we check for this
		 explicitly and only return prematurely if so. */
	      if (ntdev.Length < wcslen (HARDDISK_PREFIX)
		  || wcsncasecmp (ntdev.Buffer, HARDDISK_PREFIX, 8) != 0
		  || (odi->ObjectName.Length == 2 * sizeof (WCHAR)
		      && odi->ObjectName.Buffer[1] == L':'))
		{
		  if (trailing)
		    {
		      /* If there's a trailing path, it's a perfectly valid
			 DOS pathname without the \\.\ prefix.  Unless it's
			 longer than MAX_PATH - 1 in which case it needs
			 the \\?\ prefix. */
		      if ((len = strlen (ret + 4)) >= MAX_PATH)
			ret[2] = '?';
		      else
			memmove (ret, ret + 4, strlen (ret + 4) + 1);
		    }
		  NtClose (dir);
		  goto out;
		}
	    }
	}
      NtClose (dir);
    }

out:
  free (tgtdev.Buffer);
  free (ntdev.Buffer);
  if (!got_one)
    {
      free (ret);
      ret = (char *) malloc (sizeof (GLOBALROOT_PREFIX) + strlen (path));
      if (ret)
      	stpcpy (stpcpy (ret, GLOBALROOT_PREFIX), path);
    }
  return ret;
}

static char *
get_device_paths (char *path)
{
  char *sbuf;
  char *ptr;
  int n = 1;

  ptr = path;
  while ((ptr = strchr (ptr, ';')))
    {
      ptr++;
      n++;
    }

  char *paths[n];
  DWORD acc = 0;
  int i;
  if (!n)
    return strdup ("");

  for (i = 0, ptr = path; ptr; i++)
    {
      char *next = ptr;
      ptr = strchr (ptr, ';');
      if (ptr)
	*ptr++ = 0;
      paths[i] = get_device_name (next);
      acc += strlen (paths[i]) + 1;
    }

  sbuf = (char *) malloc (acc + 1);
  if (sbuf == NULL)
    {
      fprintf (stderr, "%s: out of memory\n", prog_name);
      exit (1);
    }

  sbuf[0] = '\0';
  for (i = 0; i < n; i++)
    {
      strcat (strcat (sbuf, paths[i]), ";");
      free (paths[i]);
    }

  strchr (sbuf, '\0')[-1] = '\0';
  return sbuf;
}

static char *
get_short_paths (char *path)
{
  wchar_t *sbuf;
  wchar_t *sptr;
  char *next;
  char *ptr = path;
  char *end = strrchr (path, 0);
  DWORD acc = 0;
  DWORD len;

  while (ptr != NULL)
    {
      next = ptr;
      ptr = strchr (ptr, ';');
      if (ptr)
	*ptr++ = 0;
      wide_path wpath (next);
      len = GetShortPathNameW (wpath, NULL, 0);
      if (!len)
	{
	  fprintf (stderr, "%s: cannot create short name of %s\n",
		   prog_name, next);
	  exit (2);
	}
      acc += len + 1;
    }
  sptr = sbuf = (wchar_t *) malloc ((acc + 1) * sizeof (wchar_t));
  if (sbuf == NULL)
    {
      fprintf (stderr, "%s: out of memory\n", prog_name);
      exit (1);
    }
  ptr = path;
  for (;;)
    {
      wide_path wpath (ptr);
      len = GetShortPathNameW (wpath, sptr, acc);
      if (!len)
	{
	  fprintf (stderr, "%s: cannot create short name of %s\n",
		   prog_name, ptr);
	  exit (2);
	}

      ptr = strrchr (ptr, 0);
      sptr = wcsrchr (sptr, 0);
      if (ptr == end)
	break;
      *sptr = L';';
      ++ptr, ++sptr;
      acc -= len + 1;
    }
  len = my_wcstombs (NULL, sbuf, 0) + 1;
  ptr = (char *) malloc (len);
  if (ptr == NULL)
    {
      fprintf (stderr, "%s: out of memory\n", prog_name);
      exit (1);
    }
  my_wcstombs (ptr, sbuf, len);
  return ptr;
}

static char *
get_short_name (const char *filename)
{
  wchar_t buf[32768];
  char *sbuf;
  wide_path wpath (filename);
  DWORD len = GetShortPathNameW (wpath, buf, 32768);
  if (!len)
    {
      fprintf (stderr, "%s: cannot create short name of %s\n",
	       prog_name, filename);
      exit (2);
    }
  len = my_wcstombs (NULL, buf, 0) + 1;
  sbuf = (char *) malloc (len);
  if (sbuf == NULL)
    {
      fprintf (stderr, "%s: out of memory\n", prog_name);
      exit (1);
    }
  my_wcstombs (sbuf, buf, len);
  return sbuf;
}

static char *
get_long_name (const char *filename, DWORD& len)
{
  char *sbuf;
  wchar_t buf[32768];
  wide_path wpath (filename);

  if (!GetLongPathNameW (wpath, buf, 32768))
    wcscpy (buf, wpath);
  len = my_wcstombs (NULL, buf, 0);
  sbuf = (char *) malloc (len + 1);
  if (!sbuf)
    {
      fprintf (stderr, "%s: out of memory\n", prog_name);
      exit (1);
    }
  my_wcstombs (sbuf, buf, len + 1);
  return sbuf;
}

static char *
get_long_paths (char *path)
{
  char *sbuf;
  char *ptr;
  int n = 1;

  ptr = path;
  while ((ptr = strchr (ptr, ';')))
    {
      ptr++;
      n++;
    }

  char *paths[n];
  DWORD acc = 0;
  int i;
  if (!n)
    return strdup ("");

  for (i = 0, ptr = path; ptr; i++)
    {
      DWORD len;
      char *next = ptr;
      ptr = strchr (ptr, ';');
      if (ptr)
	*ptr++ = 0;
      paths[i] = get_long_name (next, len);
      acc += len + 1;
    }

  sbuf = (char *) malloc (acc + 1);
  if (sbuf == NULL)
    {
      fprintf (stderr, "%s: out of memory\n", prog_name);
      exit (1);
    }

  sbuf[0] = '\0';
  for (i = 0; i < n; i++)
    {
      strcat (strcat (sbuf, paths[i]), ";");
      free (paths[i]);
    }

  strchr (sbuf, '\0')[-1] = '\0';
  return sbuf;
}

static void
convert_slashes (char* name)
{
  while ((name = strchr (name, '\\')) != NULL)
    {
      if (*name == '\\')
	*name = '/';
       name++;
   }
}

static bool
get_special_folder (PWCHAR wpath, int id)
{
  LPITEMIDLIST pidl = 0;
  if (SHGetSpecialFolderLocation (NULL, id, &pidl) != S_OK)
    return false;
  if (!SHGetPathFromIDListW (pidl, wpath) || !wpath[0])
    return false;
  return true;
}

static void
do_sysfolders (char option)
{
  WCHAR wbuf[MAX_PATH];
  char buf[PATH_MAX];

  wbuf[0] = L'\0';
  switch (option)
    {
    case 'D':
      get_special_folder (wbuf, allusers_flag ? CSIDL_COMMON_DESKTOPDIRECTORY
					     : CSIDL_DESKTOPDIRECTORY);
      break;

    case 'P':
      get_special_folder (wbuf, allusers_flag ? CSIDL_COMMON_PROGRAMS
					     : CSIDL_PROGRAMS);
      break;

    case 'O':
      get_special_folder (wbuf, allusers_flag ? CSIDL_COMMON_DOCUMENTS
					     : CSIDL_PERSONAL);
      break;

    case 'F':
      {
	int val = -1, len = -1;
	if (!(sscanf (output_arg, "%i%n", &val, &len) == 1
	      && len == (int) strlen (output_arg) && val >= 0))
	  {
	    fprintf (stderr, "%s: syntax error in special folder ID %s\n",
		     prog_name, output_arg);
	    exit (1);
	  }
	get_special_folder (wbuf, val);
      }
      break;

    case 'H':
      {
	DWORD len = MAX_PATH;
	GetProfilesDirectoryW (wbuf, &len);
      }
      break;

    case 'S':
      {
	HANDLE fh;
	WIN32_FIND_DATAW w32_fd;

	GetSystemDirectoryW (wbuf, MAX_PATH);
	/* The path returned by GetSystemDirectoryW is not case preserving.
	   The below code is a trick to get the correct case of the system
	   directory from Windows. */
	if ((fh = FindFirstFileW (wbuf, &w32_fd)) != INVALID_HANDLE_VALUE)
	  {
	    FindClose (fh);
	    wcscpy (wcsrchr (wbuf, L'\\') + 1, w32_fd.cFileName);
	  }
      }
      break;

    case 'W':
      GetSystemWindowsDirectoryW (wbuf, MAX_PATH);
      break;

    default:
      usage (stderr, 1);
    }

  if (!wbuf[0])
    {
      fprintf (stderr, "%s: failed to retrieve special folder path\n",
	       prog_name);
    }
  else if (!windows_flag)
    {
      if (cygwin_conv_path (CCP_WIN_W_TO_POSIX, wbuf, buf, PATH_MAX))
	fprintf (stderr, "%s: error converting \"%ls\" - %s\n",
		 prog_name, wbuf, strerror (errno));
    }
  else
    {
      if (shortname_flag)
	/* System paths are never longer than MAX_PATH.  The buffer pointers
	   in a call to GetShortPathNameW may point to the same buffer. */
	GetShortPathNameW (wbuf, wbuf, MAX_PATH);
      my_wcstombs (buf, wbuf, MAX_PATH);
      if (mixed_flag)
	convert_slashes (buf);
    }
  printf ("%s\n", buf);
}

static void
report_mode (char *filename)
{
  switch (cygwin_internal (CW_GET_BINMODE, filename))
    {
    case O_BINARY:
      printf ("%s: binary\n", filename);
      break;
    case O_TEXT:
      printf ("%s: text\n", filename);
      break;
    default:
      fprintf (stderr, "%s: file '%s' - %s\n", prog_name,
	       filename, strerror (errno));
      break;
    }
}

static void
do_pathconv (char *filename)
{
  char *buf = NULL, *tmp;
  wchar_t *buf2 = NULL;
  DWORD len = 32768;
  ssize_t err;
  bool print_tmp = false;
  cygwin_conv_path_t conv_func =
		      (unix_flag ? CCP_WIN_W_TO_POSIX : CCP_POSIX_TO_WIN_W)
		      | (absolute_flag ? CCP_ABSOLUTE : CCP_RELATIVE);

  if (!filename || !filename[0])
    {
      if (ignore_flag)
	return;
      fprintf (stderr, "%s: can't convert empty path\n", prog_name);
      exit (1);
    }

  buf = (char *) malloc (len);
  if (!unix_flag)
    buf2 = (wchar_t *) malloc (len * sizeof (wchar_t));
  if (buf == NULL)
    {
      fprintf (stderr, "%s: out of memory\n", prog_name);
      exit (1);
    }

  if (path_flag)
    {
      if (unix_flag)
	{
	  wide_path wpath (filename, false);
	  err = cygwin_conv_path_list (conv_func, wpath, buf, len);
	}
      else
	err = cygwin_conv_path_list (conv_func, filename, buf2, len);
      if (err)
	{
	  fprintf (stderr, "%s: error converting \"%s\" - %s\n",
		   prog_name, filename, strerror (errno));
	  exit (1);
	}
      if (!unix_flag)
	{
	  my_wcstombs (buf, buf2, 32768);
	  buf = get_device_paths (tmp = buf);
	  free (tmp);
	  if (shortname_flag)
	    {
	      buf = get_short_paths (tmp = buf);
	      free (tmp);
	    }
	  if (longname_flag)
	    {
	      buf = get_long_paths (tmp = buf);
	      free (tmp);
	    }
	  if (mixed_flag)
	    convert_slashes (buf);
	}
    }
  else
    {
      if (unix_flag)
	{
	  wide_path wpath (filename);
	  err = cygwin_conv_path (conv_func, wpath, (void *) buf, len);
	}
      else
	err = cygwin_conv_path (conv_func, filename, (void *) buf2, len);
      if (err)
	{
	  fprintf (stderr, "%s: error converting \"%s\" - %s\n",
		   prog_name, filename, strerror (errno));
	  exit (1);
	}
      if (!unix_flag)
	{
	  my_wcstombs (buf, buf2, 32768);
	  buf = get_device_name (tmp = buf);
	  free (tmp);
	  if (shortname_flag)
	    {
	      buf = get_short_name (tmp = buf);
	      free (tmp);
	    }
	  if (longname_flag)
	    {
	      buf = get_long_name (tmp = buf, len);
	      free (tmp);
	    }
	  tmp = buf;
	  if (strncmp (buf, "\\\\?\\", 4) == 0)
	    {
	      len = 0;
	      if (buf[5] == ':')
		len = 4;
	      else if (!strncmp (buf + 4, "UNC\\", 4))
		len = 6;
	      if (len && strlen (buf) < MAX_PATH + len)
		{
		  tmp += len;
		  if (len == 6)
		    *tmp = '\\';
		  print_tmp = true;
		}
	    }
	  if (mixed_flag)
	    convert_slashes (tmp);
	}
    }

  puts (print_tmp ? tmp : buf);
  if (buf2)
    free (buf2);
  if (buf)
    free (buf);
}

static void
print_version ()
{
  printf ("cygpath (cygwin) %d.%d.%d\n"
	  "Path Conversion Utility\n"
	  "Copyright (C) 1998 - %s Red Hat, Inc.\n"
	  "This is free software; see the source for copying conditions.  There is NO\n"
	  "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n",
	  CYGWIN_VERSION_DLL_MAJOR / 1000,
	  CYGWIN_VERSION_DLL_MAJOR % 1000,
	  CYGWIN_VERSION_DLL_MINOR,
	  strrchr (__DATE__, ' ') + 1);
}

static int
do_options (int argc, char **argv, int from_file)
{
  int c, o = 0;
  path_flag = 0;
  unix_flag = 0;
  windows_flag = 0;
  shortname_flag = 0;
  longname_flag = 0;
  mixed_flag = 0;
  ignore_flag = 0;
  allusers_flag = 0;
  output_flag = 0;
  mode_flag = 0;
  codepage = 0;
  if (!from_file)
    options_from_file_flag = 0;
  optind = 0;
  while ((c = getopt_long (argc, argv, options,
			   long_options, (int *) NULL)) != EOF)
    {
      switch (c)
	{
	case 'a':
	  absolute_flag = 1;
	  break;

	case 'c':
	  if (!optarg)
	    usage (stderr, 1);
	  CloseHandle ((HANDLE) strtoul (optarg, NULL, 16));
	  break;

	case 'd':
	  windows_flag = 1;
	  shortname_flag = 1;
	  break;

	case 'f':
	  if (from_file || !optarg)
	    usage (stderr, 1);
	  file_arg = optarg;
	  break;

	case 'M':
	  mode_flag = 1;
	  break;

	case 'o':
	  if (from_file)
	    usage (stderr, 1);
	  options_from_file_flag = 1;
	  break;

	case 'p':
	  path_flag = 1;
	  break;

	case 'u':
	  unix_flag = 1;
	  break;

	case 'w':
	  windows_flag = 1;
	  break;

	 case 'm':
	  windows_flag = 1;
	  mixed_flag = 1;
	  break;

	case 'l':
	  longname_flag = 1;
	  break;

	case 's':
	  shortname_flag = 1;
	  break;

	case 't':
	  if (!optarg)
	    usage (stderr, 1);

	  format_type_arg = (*optarg == '=') ? (optarg + 1) : (optarg);
	  if (strcasecmp (format_type_arg, "dos") == 0)
	    {
	      windows_flag = 1;
	      shortname_flag = 1;
	    }
	  else if (!strcasecmp (format_type_arg, "mixed"))
	    {
	      windows_flag = 1;
	      mixed_flag = 1;
	    }
	  else if (!strcasecmp (format_type_arg, "unix"))
	    unix_flag = 1;
	  else if (!strcasecmp (format_type_arg, "windows"))
	    windows_flag = 1;
	  else
	    usage (stderr, 1);
	  break;

	case 'A':
	  allusers_flag = 1;
	  break;

	case 'C':
	  if (!optarg)
	    usage (stderr, 1);
	  if (!strcasecmp (optarg, "ANSI"))
	    codepage = GetACP ();
	  else if (!strcasecmp (optarg, "OEM"))
	    codepage = GetOEMCP ();
	  else if (!strcasecmp (optarg, "UTF8")
		   || !strcasecmp (optarg, "UTF-8"))
	    codepage = CP_UTF8;
	  else
	    {
	      char *c;
	      codepage = (UINT) strtoul (optarg, &c, 10);
	      if (*c)
		usage (stderr, 1);
	    }
	  break;

	case 'D':
	case 'H':
	case 'O':
	case 'P':
	case 'S':
	case 'W':
	  ++output_flag;
	  o = c;
	  break;

	case 'F':
	  if (!optarg)
	    usage (stderr, 1);
	  ++output_flag;
	  output_arg = optarg;
	  o = c;
	  break;

	case 'i':
	  ignore_flag = 1;
	  break;

	case 'h':
	  usage (stdout, 0);
	  break;

	case 'V':
	  print_version ();
	  exit (0);

	default:
	  fprintf (stderr, "Try `%s --help' for more information.\n",
		   prog_name);
	  exit (1);
	}
    }

  /* If none of the "important" flags are set, -u is default. */
  if (!unix_flag && !windows_flag && !mode_flag
      && (!from_file ? !options_from_file_flag : 1))
    unix_flag = 1;

  /* Only one of ... */
  if (unix_flag + windows_flag + mode_flag > 1
      + (!from_file ? options_from_file_flag : 0))
    usage (stderr, 1);

  /* options_from_file_flag requires a file. */
  if (!from_file && options_from_file_flag && !file_arg)
    usage (stderr, 1);

  /* longname and shortname don't play well together. */
  if (longname_flag && shortname_flag)
    usage (stderr, 1);

  /* longname and shortname only make sense with Windows paths. */
  if ((longname_flag || shortname_flag) && !windows_flag)
    usage (stderr, 1);

  return o;
}

static void
action (int argc, char **argv, int opt)
{
  if (output_flag)
    {
      if (argv[optind])
	usage (stderr, 1);

      do_sysfolders (opt);
    }
  else
    {
      if (optind > argc - 1)
	usage (stderr, 1);

      for (int i = optind; argv[i]; i++)
	if (mode_flag)
	  report_mode (argv[i]);
	else
	  do_pathconv (argv[i]);
    }
}

int
main (int argc, char **argv)
{
  int o;

  setlocale (LC_CTYPE, "");
  prog_name = program_invocation_short_name;

  o = do_options (argc, argv, 0);

  if (!file_arg)
    action (argc, argv, o);
  else
    {
      FILE *fp;
      char buf[PATH_MAX * 2 + 1];

      if (argv[optind])
	usage (stderr, 1);

      if (strcmp (file_arg, "-"))
	{
	  if (!(fp = fopen (file_arg, "rt")))
	    {
	      perror ("cygpath");
	      exit (1);
	    }
	}
      else
	{
	  fp = stdin;
	  setmode (0, O_TEXT);
	}
      setbuf (stdout, NULL);

      while (fgets (buf, sizeof (buf), fp))
	{
	  int ac = 0;
	  char *av[4] = { NULL, NULL, NULL, NULL };
	  char *p = strchr (buf, '\n');
	  if (p)
	    *p = '\0';
	  p = buf;
	  av[ac++] = prog_name;
	  av[ac++] = p;
	  if (options_from_file_flag && *p == '-')
	    {
	      while (*p && !isspace (*p))
		++p;
	      if (*p)
		{
		  *p++ = '\0';
		  while (*p && isspace (*p))
		    ++p;
		  av[ac++] = p;
		}
	      o = do_options (ac, av, 1);
	    }
	  else
	    {
	      output_flag = 0;
	      optind = 1;
	    }
	  action (ac, av, o);
	}
    }
  exit (0);
}
@


1.70
log
@Update copyrights
@
text
@d3 1
a3 1
   2009, 2010, 2011, 2012 Red Hat, Inc.
d678 1
a678 1
	  wide_path wpath (filename);
@


1.69
log
@	* cygpath.cc: Change including headers to allow building against
	Mingw64 headers. Include ntdef.h and ntdll.h rather than ddk headers.
	Define _WIN32_WINNT and WINVER as 0x0602.
	(RtlEqualUnicodePathPrefix): Drop definition.  Pulled in from ntdll.h
	now.
	(get_device_name): s/Zw/Nt.
	* dumper.cc: Include sys/param.h
	(dumper::dump_memory_region): Use MIN rather than min.
	* locale.cc: Include stdlib.h.  Define _WIN32_WINNT and WINVER as
	0x0602.
	* ps.cc: Include ntdef.h and ntdll.h rather than ddk headers.
	* regtool.cc (regDeleteKeyEx): Drop WINADVAPI qualifier.
@
text
@d3 1
a3 1
   2009, 2010, 2011 Red Hat, Inc.
@


1.69.2.1
log
@Pull in changes from HEAD
@
text
@d3 1
a3 1
   2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.68
log
@Clean up whitespace.
@
text
@a10 4
#define NOCOMATTRIBUTE

#define WINVER 0x0600
#include <shlobj.h>
a17 2
#include <windows.h>
#include <userenv.h>
d24 10
a33 3
#include <ddk/ntddk.h>
#include <ddk/winddk.h>
#include <ddk/ntifs.h>
a151 12
static inline BOOLEAN
RtlEqualUnicodePathPrefix (PUNICODE_STRING path, PUNICODE_STRING prefix,
			   BOOLEAN caseinsensitive)
  {
    UNICODE_STRING p;

    p.Length = p.MaximumLength = prefix->Length < path->Length
				 ? prefix->Length : path->Length;
    p.Buffer = path->Buffer;
    return RtlEqualUnicodeString (&p, prefix, caseinsensitive);
  }

d195 1
a195 1
  status = ZwOpenSymbolicLinkObject (&lnk, SYMBOLIC_LINK_QUERY, &ntobj);
d198 2
a199 2
      status = ZwQuerySymbolicLinkObject (lnk, &tgtdev, NULL);
      ZwClose (lnk);
d217 1
a217 1
      status = ZwOpenDirectoryObject (&dir, DIRECTORY_QUERY, &ntobj);
d223 1
a223 1
	   NT_SUCCESS (ZwQueryDirectoryObject (dir, odi, 4096, TRUE,
d230 1
a230 1
	  status = ZwOpenSymbolicLinkObject (&lnk, SYMBOLIC_LINK_QUERY, &ntobj);
d237 2
a238 2
	  status = ZwQuerySymbolicLinkObject (lnk, &tgtdev, NULL);
	  ZwClose (lnk);
d285 1
a285 1
		  ZwClose (dir);
d290 1
a290 1
      ZwClose (dir);
@


1.67
log
@	* Makefile.in (cygpath.exe): Add -luserenv to ALL_LDFLAGS.
	* cygpath.cc: Throughout, use cygwin_conv_path WIN_W rather than WIN_A
	conversion.
	(get_long_path_name_w32impl): Remove.
	(get_long_name): Drop pre-Windows 2000 accommodations.  Just call
	GetLongPathNameW here directly.
	(get_special_folder): Convert first parameter to WCHAR buffer pointer.
	Drop conversion of result from WCHAR * to char *.
	(do_sysfolders): Accommodate change to get_special_folder and only
	convert result to char * last.  Drop pre-Windows 2000 accommodations
	and just call GetProfilesDirectoryW directly.  Replace call to
	GetWindowsDirectoryW with call to GetSystemWindowsDirectoryW.
	Just call GetShortPathNameW directly.
	(do_pathconv): Simplify buffer handling.
@
text
@d289 1
a289 1
			 longer than MAX_PATH - 1 in which case it needs 
@


1.66
log
@	* Align usage output, version output, as well as usage and version
	option handling to use the same style throughout all Cygwin utils.
	Throughout use program_invocation_short_name to refer to current
	process name in Cygwin executables.
	* utils.sgml: Align documentation to above change.  Add missing
	sections for getconf, ldd, and setmetamode.
	* strace.cc (proc_child): Avoid compiler warning.
@
text
@d2 2
a3 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2008, 2009, 2010 Red Hat, Inc.
d13 1
d23 1
a452 55
static DWORD WINAPI
get_long_path_name_w32impl (LPCWSTR src, LPWSTR sbuf, DWORD)
{
  wchar_t *buf1 = (wchar_t *) malloc (32768);
  wchar_t *buf2 = (wchar_t *) malloc (32768);
  wchar_t *ptr;
  const wchar_t *pelem, *next;
  WIN32_FIND_DATAW w32_fd;
  DWORD len;

  wcscpy (buf1, src);
  *buf2 = L'\0';
  pelem = src;
  ptr = buf2;
  while (pelem)
    {
      next = pelem;
      if (*next == L'\\')
	{
	  wcscat (ptr++, L"\\");
	  pelem++;
	  if (!*pelem)
	    break;
	  continue;
	}
      pelem = wcschr (next, L'\\');
      len = pelem ? (pelem++ - next) : wcslen (next);
      wcsncpy (ptr, next, len);
      ptr[len] = L'\0';
      if (next[1] != L':' && wcscmp(next, L".") && wcscmp(next, L".."))
	{
	  HANDLE h;
	  h = FindFirstFileW (buf2, &w32_fd);
	  if (h != INVALID_HANDLE_VALUE)
	    {
	      wcscpy (ptr, w32_fd.cFileName);
	      FindClose (h);
	    }
	}
      ptr += wcslen (ptr);
      if (pelem)
	{
	  *ptr++ = '\\';
	  *ptr = 0;
	}
    }
  if (sbuf)
    wcscpy (sbuf, buf2);
  SetLastError (0);
  len = wcslen (buf2) + (sbuf ? 0 : 1);
  free (buf1);
  free (buf2);
  return len;
}

a457 6
  static HINSTANCE k32 = GetModuleHandleW (L"kernel32.dll");
  static DWORD (WINAPI *GetLongPathName) (LPCWSTR, LPWSTR, DWORD) =
    (DWORD (WINAPI *) (LPCWSTR, LPWSTR, DWORD)) GetProcAddress (k32, "GetLongPathNameW");
  if (!GetLongPathName)
    GetLongPathName = get_long_path_name_w32impl;

a458 4
  len = GetLongPathName (wpath, buf, 32768);
  if (len == 0)
    {
      DWORD err = GetLastError ();
d460 2
a461 14
      if (err == ERROR_INVALID_PARAMETER)
	{
	  fprintf (stderr, "%s: cannot create long name of %s\n",
		   prog_name, filename);
	  exit (2);
	}
      else if (err == ERROR_FILE_NOT_FOUND)
	get_long_path_name_w32impl (wpath, buf, 32768);
      else
	{
	  buf[0] = L'\0';
	  wcsncat (buf, wpath, 32767);
	}
    }
d534 1
a534 1
get_special_folder (char* path, int id)
a535 4
  WCHAR wpath[MAX_PATH];

  path[0] = '\0';
  wpath[0] = L'\0';
a540 1
  my_wcstombs (path, wpath, PATH_MAX);
a546 2
  char *buf, buf1[PATH_MAX], buf2[PATH_MAX];
  char *tmp = NULL;
d548 1
a548 4
  DWORD len = MAX_PATH;
  WIN32_FIND_DATAW w32_fd;
  HINSTANCE k32;
  BOOL (*GetProfilesDirectoryAPtrW) (LPWSTR, LPDWORD) = 0;
d550 1
a550 2
  buf = buf1;
  buf[0] = 0;
d554 1
a554 1
      get_special_folder (buf, allusers_flag ? CSIDL_COMMON_DESKTOPDIRECTORY
d559 1
a559 1
      get_special_folder (buf, allusers_flag ? CSIDL_COMMON_PROGRAMS
d564 1
a564 1
      get_special_folder (buf, allusers_flag ? CSIDL_COMMON_DOCUMENTS
d578 1
a578 1
	get_special_folder (buf, val);
d583 4
a586 12
      k32 = LoadLibrary ("userenv.dll");
      if (k32)
	GetProfilesDirectoryAPtrW = (BOOL (*) (LPWSTR, LPDWORD))
	  GetProcAddress (k32, "GetProfilesDirectoryW");
      if (GetProfilesDirectoryAPtrW)
	(*GetProfilesDirectoryAPtrW) (wbuf, &len);
      else
	{
	  GetWindowsDirectoryW (wbuf, MAX_PATH);
	  wcscat (wbuf, L"\\Profiles");
	}
      my_wcstombs (buf, wbuf, PATH_MAX);
d592 1
d595 3
a602 1
	my_wcstombs (buf, wbuf, PATH_MAX);
d607 1
a607 2
      GetWindowsDirectoryW (wbuf, MAX_PATH);
      my_wcstombs (buf, wbuf, PATH_MAX);
d614 1
a614 1
  if (!buf[0])
d621 3
a623 6
      if (cygwin_conv_path (CCP_WIN_A_TO_POSIX | CCP_RELATIVE, buf, buf2,
	  PATH_MAX))
	fprintf (stderr, "%s: error converting \"%s\" - %s\n",
		 prog_name, buf, strerror (errno));
      else
	buf = buf2;
d628 4
a631 1
	  tmp = buf = get_short_name (buf);
a635 2
  if (tmp)
    free (tmp);
d661 1
a661 1
  DWORD len;
d665 9
a673 18
		      (unix_flag ? CCP_WIN_A_TO_POSIX
		      		 : (path_flag ? CCP_POSIX_TO_WIN_A
					      : CCP_POSIX_TO_WIN_W))
		    | (absolute_flag ? CCP_ABSOLUTE : CCP_RELATIVE);

  if (!path_flag)
    {
      len = strlen (filename);
      if (len)
	len = 32768;
      else if (ignore_flag)
	exit (0);
      else
	{
	  fprintf (stderr, "%s: can't convert empty path\n",
		   prog_name);
	  exit (1);
	}
a674 2
  else
    len = cygwin_conv_path_list (conv_func, filename, NULL, 0);
d677 1
a677 1
  if (!unix_flag && !path_flag)
d687 13
a699 1
      err = cygwin_conv_path_list (conv_func, filename, buf, len);
d702 1
a702 2
	  if (err)
	    /* oops */;
a717 6
      if (err)
	{
	  fprintf (stderr, "%s: error converting \"%s\" - %s\n",
		   prog_name, filename, strerror (errno));
	  exit (1);
	}
d721 7
a727 2
      err = cygwin_conv_path (conv_func, filename,
			      unix_flag ? (void *) buf : (void *) buf2, len);
@


1.65
log
@	* cygpath.cc (get_device_name): Fix path length test.
@
text
@d25 1
a33 2
static const char version[] = "$Revision: 1.64 $";

d59 1
a59 1
  {(char *) "version", no_argument, NULL, 'v'},
d73 1
a73 1
static char options[] = "ac:df:hilmMopst:uvwAC:DHOPSWF:";
d80 5
a84 4
Usage: %s (-d|-m|-u|-w|-t TYPE) [-f FILE] [OPTION]... NAME...\n\
       %s [-c HANDLE] \n\
       %s [-ADHOPSW] \n\
       %s [-F ID] \n\
d88 1
d95 1
d97 1
d105 1
a105 1
                        If this option is missing, %s defaults to the\n\
d107 1
d109 1
d118 1
a118 1
", prog_name, prog_name, prog_name, prog_name, prog_name);
d126 1
d128 1
d134 2
a135 2
  -v, --version         output version information and exit\n\
");
d384 2
a385 2
	  fprintf (stderr, "%s: cannot create short name of %s\n", prog_name,
		   next);
d403 2
a404 2
	  fprintf (stderr, "%s: cannot create short name of %s\n", prog_name,
		   ptr);
d436 2
a437 2
      fprintf (stderr, "%s: cannot create short name of %s\n", prog_name,
	       filename);
d525 2
a526 2
	  fprintf (stderr, "%s: cannot create long name of %s\n", prog_name,
		   filename);
d708 2
a709 1
      fprintf (stderr, "%s: failed to retrieve special folder path\n", prog_name);
d744 2
a745 2
      fprintf (stderr, "%s: file '%s' - %s\n", prog_name, filename,
	       strerror (errno));
d773 2
a774 1
	  fprintf (stderr, "%s: can't convert empty path\n", prog_name);
d875 9
a883 19
  const char *v = strchr (version, ':');
  int len;
  if (!v)
    {
      v = "?";
      len = 1;
    }
  else
    {
      v += 2;
      len = strchr (v, ' ') - v;
    }
  printf ("\
cygpath (cygwin) %.*s\n\
Path Conversion Utility\n\
Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, \n\
          2007, 2008, 2009, 2010 Red Hat, Inc.\n\
Compiled on %s\n\
", len, v, __DATE__);
d1037 1
a1037 1
	case 'v':
d1042 3
a1044 2
	  usage (stderr, 1);
	  break;
d1102 1
a1102 7
  prog_name = strrchr (argv[0], '/');
  if (!prog_name)
    prog_name = strrchr (argv[0], '\\');
  if (!prog_name)
    prog_name = argv[0];
  else
    prog_name++;
@


1.64
log
@	* cygpath.cc (RtlEqualUnicodePathPrefix): New helper function.
	(HARDDISK_PREFIX): Move.
	(GLOBALROOT_PREFIX): Define.
	(get_device_name): Take GLOBALROOT_PREFIX into account.
	Improve check for path to allow filesystem access via block devices.
	Potentially drop \\.\ prefix if resulting path is a valid DOS
	pathname.
	(do_pathconv): Make sure to drop \\?\ prefix only if path is
	actually a filesystem based path.
	(print_version): Fix copyright.
@
text
@d33 1
a33 1
static const char version[] = "$Revision: 1.63 $";
d282 1
a282 1
		      if (len = strlen (ret + 4) >= MAX_PATH)
@


1.63
log
@	* loadlib.h: New header implementing safe LoadLibrary calls.
	Include throughout files using LoadLibrary function.
	* cygcheck.cc (dump_sysinfo): Retrieve kernel32.dll handle via
	GetModuleHandle, rather than using LoadLibrary.
	* cygpath.cc (get_long_name): Ditto.
	(do_sysfolders): Append .dll suffix in LoadLibrary call.
	* ldh.cc (WinMain): Use LoadLibraryExW with DONT_RESOLVE_DLL_REFERENCES
	to avoid loading malicious library code.
	* locale.cc (print_locale_with_codeset): Change way to retrieve
	kernel32.dll path.
@
text
@d33 1
a33 1
static const char version[] = "$Revision: 1.62 $";
d137 1
a137 1
  uni->MaximumLength = 512;
d142 12
d163 3
d174 1
d181 2
d186 1
a186 1
  if (!RtlAllocateUnicodeString (&ntdev, 65536))
d188 1
a188 1
  if (!RtlAllocateUnicodeString (&tgtdev, 65536))
d206 2
a207 1
  else if (status != STATUS_OBJECT_TYPE_MISMATCH)
d243 3
a245 1
	  if (RtlEqualUnicodeString (&ntdev, &tgtdev, TRUE))
d250 3
d254 2
d263 5
a270 1
#define	      HARDDISK_PREFIX	L"\\Device\\Harddisk"
d276 11
d298 7
d838 4
a841 2
	      len = 4;
	      if (strncmp (buf + 4, "UNC\\", 4) == 0)
d843 1
a843 1
	      if (strlen (buf) < MAX_PATH + len)
d882 1
a882 1
          2007, 2008 Red Hat, Inc.\n\
@


1.62
log
@	* cygpath.cc (get_device_name): Prefer the \\.\X: DOS device for
	harddisks, if available.
@
text
@d31 1
d33 1
a33 1
static const char version[] = "$Revision: 1.61 $";
d456 1
a456 1
  static HINSTANCE k32 = LoadLibrary ("kernel32.dll");
d614 1
a614 1
      k32 = LoadLibrary ("userenv");
@


1.61
log
@	* cygpath.cc (do_pathconv): Fix erroneously printing native NT path
	prefix introduced by previous patch.
@
text
@d32 1
a32 1
static const char version[] = "$Revision: 1.60 $";
d236 12
a247 2
	      ZwClose (dir);
	      goto out;
@


1.60
log
@	* cygpath.cc (do_pathconv): Fix potential crash.
@
text
@d32 1
a32 1
static const char version[] = "$Revision: 1.59 $";
d690 1
d787 1
d795 1
a795 1
  puts (buf);
@


1.59
log
@	* cygpath.cc (get_mixed_name): Drop function.  Replace with call to
	convert_slashes throughout.
	(do_sysfolders): Free allocated buffer.
	(do_pathconv): Fix freeing last buffer.
@
text
@d32 1
a32 1
static const char version[] = "$Revision: 1.58 $";
a774 2
	  /* buf gets moved into the array so we have to set tmp for later
	     freeing beforehand. */
d783 1
a783 1
		  buf += len;
d785 1
a785 1
		    *buf = '\\';
d789 1
a789 1
	    convert_slashes (buf);
d797 1
a797 1
    free (tmp);
@


1.58
log
@	* cygpath.cc: Throughout, free obsolete path buffers.
@
text
@d32 1
a32 1
static const char version[] = "$Revision: 1.57 $";
a541 16
static char *
get_mixed_name (const char* filename)
{
  char* mixed_buf = strdup (filename);

  if (mixed_buf == NULL)
    {
      fprintf (stderr, "%s: out of memory\n", prog_name);
      exit (1);
    }

  convert_slashes (mixed_buf);

  return mixed_buf;
}

d562 1
a654 2
      char *tmp;

d656 1
a656 4
	{
	  buf = get_short_name (tmp = buf);
	  free (tmp);
	}
d658 1
a658 4
	{
	  buf = get_mixed_name (tmp = buf);
	  free (tmp);
	}
d661 2
d741 1
a741 4
	    {
	      buf = get_mixed_name (tmp = buf);
	      free (tmp);
	    }
d791 1
a791 4
	    {
	      buf = get_mixed_name (buf);
	      free (tmp);
	    }
d799 1
a799 1
    free (buf);
@


1.57
log
@	* cygpath.cc (main): Remove enforcing "en_US.UTF-8" locale.
	Revert usage of argz functions when reading input from file and
	simplify option usage.  Allow only one option argument and use
	the rest as filename argument to allow spaces in filenames.  Restrict
	processing special folder type options to one line.
@
text
@d32 1
a32 1
static const char version[] = "$Revision: 1.56 $";
d229 1
d670 2
d673 4
a676 1
	buf = get_short_name (buf);
d678 4
a681 1
	buf = get_mixed_name (buf);
d707 2
a708 2
  char *buf;
  wchar_t *buf2;
d749 2
a750 1
	  buf = get_device_paths (buf);
d752 4
a755 1
	    buf = get_short_paths (buf);
d757 4
a760 1
	    buf = get_long_paths (buf);
d762 4
a765 1
	    buf = get_mixed_name (buf);
d787 2
a788 1
	  buf = get_device_name (buf);
d790 4
a793 1
	    buf = get_short_name (buf);
d795 7
a801 1
	    buf = get_long_name (buf, len);
d815 4
a818 1
	    buf = get_mixed_name (buf);
d823 4
@


1.56
log
@	* cygpath.cc (get_special_folder): Fetch path as WCHAR and convert
	using my_wcstombs.
	(get_user_folder): Remove.
	(do_sysfolders): Use get_special_folder instead of get_user_folder.
	Fetch system paths as WCHAR and convert using my_wcstombs.
@
text
@d3 1
a3 1
   2006, 2007, 2008, 2009 Red Hat, Inc.
a18 1
#include <argz.h>
d32 1
a32 1
static const char version[] = "$Revision: 1.55 $";
a1030 1
  /* Use locale from environment.  If not set or set to "C", use UTF-8. */
a1031 2
  if (!strcmp (setlocale (LC_CTYPE, NULL), "C"))
    setlocale (LC_CTYPE, "en_US.UTF-8");
d1069 2
a1070 3
	  size_t azl = 0;
	  int ac;
	  char *az, **av;
d1074 4
a1077 1
	  if (argz_create_sep (buf, ' ', &az, &azl))
d1079 10
a1088 2
	      perror ("cygpath");
	      exit (1);
d1090 1
a1090 5
	  if (!az)
	    continue;
	  ac = argz_count (az, azl) + 1;
	  av = (char **) malloc ((ac + 1) * sizeof (char *));
	  if (!av)
d1092 2
a1093 2
	      perror ("cygpath");
	      exit (1);
a1094 6
	  av[0] = prog_name;
	  argz_extract (az, azl, av + 1);
	  if (options_from_file_flag)
	    o = do_options (ac, av, 1);
	  else
	    optind = 1;
a1095 2
	  free (az);
	  free (av);
@


1.55
log
@	* cygpath.cc (codepage): New variable.
	(long_options): Add --codepage option.
	(options): Add -C option.
	(usage): Add -C/--codepage description.
	(my_wcstombs): New function.  Use througout instead of wcstombs.
	(do_options): Handle -C/--codepage option.
	* utils.sgml (cygpath): Add description for new -C/--codepage option.
@
text
@d33 1
a33 1
static const char version[] = "$Revision: 1.54 $";
d561 4
a564 1
  path[0] = 0;
d568 1
a568 1
  if (!SHGetPathFromIDList (pidl, path) || !path[0])
d570 1
a574 6
get_user_folder (char* path, int id, int allid)
{
  get_special_folder (path, allusers_flag ? allid : id);
}

static void
d577 2
a578 1
  char *buf, buf1[MAX_PATH], buf2[PATH_MAX];
d580 1
a580 1
  WIN32_FIND_DATA w32_fd;
d582 1
a582 1
  BOOL (*GetProfilesDirectoryAPtr) (LPSTR, LPDWORD) = 0;
d589 2
a590 2
      get_user_folder (buf, CSIDL_DESKTOPDIRECTORY,
			    CSIDL_COMMON_DESKTOPDIRECTORY);
d594 2
a595 1
      get_user_folder (buf, CSIDL_PROGRAMS, CSIDL_COMMON_PROGRAMS);
d599 2
a600 1
      get_user_folder (buf, CSIDL_PERSONAL, CSIDL_COMMON_DOCUMENTS);
d620 4
a623 4
	GetProfilesDirectoryAPtr = (BOOL (*) (LPSTR, LPDWORD))
	  GetProcAddress (k32, "GetProfilesDirectoryA");
      if (GetProfilesDirectoryAPtr)
	(*GetProfilesDirectoryAPtr) (buf, &len);
d626 2
a627 2
	  GetWindowsDirectory (buf, MAX_PATH);
	  strcat (buf, "\\Profiles");
d629 1
d633 11
a643 3
      GetSystemDirectory (buf, MAX_PATH);
      FindFirstFile (buf, &w32_fd);
      strcpy (strrchr (buf, '\\') + 1, w32_fd.cFileName);
d647 2
a648 1
      GetWindowsDirectory (buf, MAX_PATH);
@


1.54
log
@	* cygpath.cc (main): Only setlocale for LC_CTYPE category.  Fallback
	to UTF-8 if locale is "C".
	* ldd.cc (main): Ditto.
	* mkgroup.c (main): Ditto.
	* mkpasswd.c (main): Ditto.
	* passwd.c (main): Ditto.
@
text
@d33 1
a33 1
static const char version[] = "$Revision: 1.53 $";
d41 1
d70 1
d74 1
a74 1
static char options[] = "ac:df:hilmMopst:uvwADHOPSWF:";
d99 5
d113 1
a113 1
", prog_name, prog_name, prog_name, prog_name);
d142 9
d350 1
a350 1
  len = wcstombs (NULL, sbuf, 0) + 1;
d357 1
a357 1
  wcstombs (ptr, sbuf, len);
d374 1
a374 1
  len = wcstombs (NULL, buf, 0) + 1;
d381 1
a381 1
  wcstombs (sbuf, buf, len);
d471 1
a471 1
  len = wcstombs (NULL, buf, 0);
d478 1
a478 1
  wcstombs (sbuf, buf, len + 1);
d757 1
a757 1
	  wcstombs (buf, buf2, 32768);
d821 1
d913 19
@


1.53
log
@	* cygpath.cc (do_pathconv): Only skip \\?\ prefix if it's really
	given.  Do backslash to slash conversion for mixed paths after
	handling \\?\ prefix.
@
text
@d33 1
a33 1
static const char version[] = "$Revision: 1.52 $";
d985 4
a988 1
  setlocale (LC_ALL, "");
@


1.52
log
@	* wide_path.h (class wide_path): New class to convert Windows path
	to WCHAR win32 path, including long path conversion if necessary.
	* cygcheck.cc: Use class wide_path throughout to call Win32 functions
	taking potentially long filenames.
	(display_error): Use snprintf rather than sprintf.
	(display_error_fmt): Ditto.
	(dump_sysinfo): Use FindFirstFileW/FindNextFileW.
	* cygpath.cc: Use class wide_path throughout to call Win32 functions
	taking potentially long filenames.
	(get_device_name): Raise buffer size to take long pathnames.
	(get_short_paths): Convert to using GetShortPathNameW.
	(get_short_name): Ditto.
	(get_long_path_name_w32impl): Convert to equivalent of GetLongPathNameW.
	(get_long_name): Convert to using GetLongPathNameW.
	(do_sysfolders): Raise buffer size for POSIX pathname to PATH_MAX.
	(do_pathconv): In case of POSIX->Win32 conversion, convert to wchar_t
	Win32 path name and drop long pathname prefix if possible.
	(main): Call setlocale to accommodate wide char/multibyte conversions.
@
text
@d33 1
a33 1
static const char version[] = "$Revision: 1.51 $";
d747 12
a760 9
	  len = 4;
	  if (strncmp (buf, "\\\\?\\UNC\\", 8) == 0)
	    len = 6;
	  if (strlen (buf) < MAX_PATH + len)
	    {
	      buf += len;
	      if (len == 6)
	        *buf = '\\';
	    }
@


1.51
log
@	* Makefile.in (cygcheck.exe): Link against ntdll.
	* bloda.cc: Use statically linked functions throughout.
	* cygpath.cc: Drop 9x considerations.
	* mkgroup.c: Revamp.  Redefine -l and -d options to take optional
	machine and domain parameters.  Redefine -c to work always, using
	token information.  Add -L, -D, -C to create unique groupnames in
	domain\group syntax.  Add -S option to define domain\group separator
	char.  Ignore -u and -s options.
	* mkpasswd.c: Revamp.  Redefine -l and -d options to take optional
	machine and domain parameters.  Redefine -c to work always, using
	token information.  Add -L, -D, -C to create unique usernames in
	domain\user syntax.  Add -S option to define domain\user separator
	char.  Ignore -g and -s options.  Prefer to take homedir from $HOME
	over $HOMEDRIVE/$HOMEPATH.
	* path.cc (oopts): Add "acl", "noacl", "posix=0" and "posix=1" options.
	(getmntent): Accomodate throughout.
	* ps.cc: Fix copyright dates.
	* utils.sgml: Fix text for mkgroup and mkpasswd.
@
text
@d3 1
a3 1
   2006, 2007, 2008 Red Hat, Inc.
d16 2
d31 1
d33 1
a33 1
static const char version[] = "$Revision: 1.50 $";
d152 1
a152 1
  if (!RtlAllocateUnicodeString (&ntdev, MAX_PATH * 2))
d154 1
a154 1
  if (!RtlAllocateUnicodeString (&tgtdev, MAX_PATH * 2))
d284 2
a285 2
  char *sbuf;
  char *sptr;
d298 2
a299 1
      len = GetShortPathName (next, NULL, 0);
d308 1
a308 1
  sptr = sbuf = (char *) malloc (acc + 1);
d317 2
a318 1
      len = GetShortPathName (ptr, sptr, acc);
d327 1
a327 1
      sptr = strrchr (sptr, 0);
d330 1
a330 1
      *sptr = ';';
d334 9
a342 1
  return sbuf;
d348 4
a351 2
  char *sbuf, buf[MAX_PATH];
  DWORD len = GetShortPathName (filename, buf, MAX_PATH);
d358 2
a359 1
  sbuf = (char *) malloc (++len);
d365 2
a366 1
  return strcpy (sbuf, buf);
d370 1
a370 1
get_long_path_name_w32impl (LPCSTR src, LPSTR sbuf, DWORD)
d372 6
a377 4
  char buf1[MAX_PATH], buf2[MAX_PATH], *ptr;
  const char *pelem, *next;
  WIN32_FIND_DATA w32_fd;
  int len;
d379 2
a380 2
  strcpy (buf1, src);
  *buf2 = 0;
d386 1
a386 1
      if (*next == '\\')
d388 1
a388 1
	  strcat (ptr++, "\\");
d394 5
a398 5
      pelem = strchr (next, '\\');
      len = pelem ? (pelem++ - next) : strlen (next);
      strncpy (ptr, next, len);
      ptr[len] = 0;
      if (next[1] != ':' && strcmp(next, ".") && strcmp(next, ".."))
d401 1
a401 1
	  h = FindFirstFile (buf2, &w32_fd);
d404 1
a404 1
	    strcpy (ptr, w32_fd.cFileName);
d408 1
a408 1
      ptr += strlen (ptr);
d416 1
a416 1
    strcpy (sbuf, buf2);
d418 4
a421 1
  return strlen (buf2) + (sbuf ? 0 : 1);
d427 2
a428 1
  char *sbuf, buf[MAX_PATH];
d430 2
a431 2
  static DWORD (WINAPI *GetLongPathName) (LPCSTR, LPSTR, DWORD) =
    (DWORD (WINAPI *) (LPCSTR, LPSTR, DWORD)) GetProcAddress (k32, "GetLongPathNameA");
d435 2
a436 1
  len = GetLongPathName (filename, buf, MAX_PATH);
d448 1
a448 1
	len = get_long_path_name_w32impl (filename, buf, MAX_PATH);
d451 2
a452 3
	  buf[0] = '\0';
	  strncat (buf, filename, MAX_PATH - 1);
	  len = strlen (buf);
d455 1
d462 2
a463 1
  return strcpy (sbuf, buf);
d563 1
a563 1
  char *buf, buf1[MAX_PATH], buf2[MAX_PATH];
d635 1
a635 1
	  MAX_PATH))
d673 1
d677 3
a679 1
		      (unix_flag ? CCP_WIN_A_TO_POSIX : CCP_POSIX_TO_WIN_A)
d686 1
a686 1
	len += MAX_PATH + 1001;
d699 2
d731 2
a732 1
      err = cygwin_conv_path (conv_func, filename, buf, len);
d741 1
d749 9
d982 1
@


1.50
log
@	* cygpath.cc (do_sysfolders): Use cygwin_conv_path.
	(do_pathconv): Use cygwin_conv_path and cygwin_conv_path_list.
	* dumper.cc (main): Use cygwin_conv_path.  Allocate target path
	dynamically.
	* mkpasswd.c (current_user): Use cygwin_conv_path.
	(enum_users): Ditto.
	* ps.cc (NT_MAX_PATH): Define.
	(main): Use cygwin_conv_path.
	* regtool.cc (find_key): Ditto. Allocate target path dynamically.
	(cmd_save): Ditto.
@
text
@d3 1
a3 1
   2006, 2007 Red Hat, Inc.
d30 1
a30 1
static const char version[] = "$Revision: 1.49 $";
d532 1
a532 2
  if (!get_special_folder (path, allusers_flag ? allid : id) && allusers_flag)
    get_special_folder (path, id); // Fix for Win9x without any "All Users"
d742 1
a742 1
          2007 Red Hat, Inc.\n\
@


1.49
log
@	* cygpath.cc (do_options): Allow outputflag combined with other
	basic flags.  Only check options_from_file_flag if reading options
	from command line.
	(main): Check for NULL argz vector.  Don't free argz vector prematurely.
	Don't force flag combination in !options_from_file_flag case.
@
text
@d30 1
a30 1
static const char version[] = "$Revision: 1.46 $";
d610 2
a611 1
      if (cygwin_conv_to_posix_path (buf, buf2))
d650 4
a653 2
  int err;
  int (*conv_func) (const char *, char *);
a667 2
  else if (unix_flag)
    len = cygwin_win32_to_posix_path_list_buf_size (filename);
d669 1
a669 1
    len = cygwin_posix_to_win32_path_list_buf_size (filename);
d680 2
a681 3
      if (unix_flag)
	err = cygwin_win32_to_posix_path_list (filename, buf);
      else
a682 1
	  err = cygwin_posix_to_win32_path_list (filename, buf);
d702 1
a702 7
      if (unix_flag)
	conv_func = (absolute_flag ? cygwin_conv_to_full_posix_path :
		     cygwin_conv_to_posix_path);
      else
	conv_func = (absolute_flag ? cygwin_conv_to_full_win32_path :
		     cygwin_conv_to_win32_path);
      err = conv_func (filename, buf);
@


1.48
log
@	* cygpath.cc: Include argz.h.
	(options_from_file_flag): Move from main to global static variable.
	(mode_flag): Ditto.
	(do_sysfolders): Rename from dowin and accommodate throughout.
	Don't exit from here.
	(do_pathconv): Rename from doit and accommodate throughout.
	(print_version): Change copyright.
	(do_options): New function, centralizing option processing.
	Rework checking options for correctness.
	(action): New function, centralizing calling worker functions.
	(main): Simplify.  Move option processing to do_options.  Move calling
	worker functions to action.  Rework getting arguments from files.
@
text
@d897 2
a898 2
  if (!unix_flag && !windows_flag && !options_from_file_flag && !output_flag
      && !mode_flag)
d902 1
a902 1
  if (unix_flag + windows_flag + output_flag + mode_flag > 1
d997 2
a1007 1
	  free (az);
d1011 1
a1011 5
	    {
	      optind = 1;
	      unix_flag = 1;
	      output_flag = mode_flag = windows_flag = 0;
	    }
d1013 1
@


1.47
log
@* utils/cygpath.cc (get_long_path_name_w32impl): Close handles returned by
FindFirstFile.
@
text
@d17 1
d37 2
a38 1
static int mixed_flag;
d537 1
a537 1
dowin (char option)
a623 1
  exit (0);
d645 1
a645 1
doit (char *filename)
d749 2
a750 1
Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Red Hat, Inc.\n\
d755 2
a756 2
int
main (int argc, char **argv)
a758 11
  int options_from_file_flag;
  int mode_flag;

  prog_name = strrchr (argv[0], '/');
  if (prog_name == NULL)
    prog_name = strrchr (argv[0], '\\');
  if (prog_name == NULL)
    prog_name = argv[0];
  else
    prog_name++;

d760 1
a760 1
  unix_flag = 1;
a765 1
  options_from_file_flag = 0;
d769 3
d782 2
a787 3
	  if (windows_flag)
	    usage (stderr, 1);
	  unix_flag = 0;
d793 2
d803 2
a812 2
	  if (windows_flag || mixed_flag)
	    usage (stderr, 1);
a816 3
	  if (windows_flag || mixed_flag)
	    usage (stderr, 1);
	  unix_flag = 0;
a820 1
	  unix_flag = 0;
d833 2
a834 2
	 case 't':
	  if (optarg == NULL)
d840 2
a841 5
	    if (windows_flag || longname_flag)
	      usage (stderr, 1);
	    unix_flag = 0;
	    windows_flag = 1;
	    shortname_flag = 1;
d843 1
a843 1
	  else if (strcasecmp (format_type_arg, "mixed") == 0)
d845 2
a846 2
	    unix_flag = 0;
	    mixed_flag = 1;
d848 1
a848 4
	  else if (strcasecmp (format_type_arg, "unix") == 0)
	    {
	    if (windows_flag)
	      usage (stderr, 1);
d850 1
a850 6
	    }
	  else if (strcasecmp (format_type_arg, "windows") == 0)
	    {
	    if (mixed_flag)
	      usage (stderr, 1);
	    unix_flag = 0;
a851 1
	    }
d866 1
a866 3
	  if (output_flag)
	    usage (stderr, 1);
	  output_flag = 1;
d871 1
a871 1
	  if (output_flag || !optarg)
d873 1
a873 1
	  output_flag = 1;
d896 8
a903 1
  if (options_from_file_flag && !file_arg)
d906 2
a907 1
  if (longname_flag && !windows_flag)
d910 2
a911 1
  if (shortname_flag && !windows_flag)
d914 2
a915 1
  if (!unix_flag && !windows_flag && !mixed_flag && !options_from_file_flag)
d918 7
a924 1
  if (!file_arg)
d926 2
a927 2
      if (output_flag)
	dowin (o);
d929 4
d940 1
a940 1
	  doit (argv[i]);
d942 19
d969 8
a976 2
      if (strcmp (file_arg, "-") != 0)
	fp = fopen (file_arg, "rt");
d982 1
a982 5
      if (fp == NULL)
	{
	  perror ("cygpath");
	  exit (1);
	}
d984 1
a984 2
      setbuf (stdout, NULL);
      while (fgets (buf, sizeof (buf), fp) != NULL)
d986 4
a989 2
	  char *s = buf;
	  char *p = strchr (s, '\n');
d992 8
a999 1
	  if (options_from_file_flag && *s == '-')
d1001 2
a1002 47
	      char c;
	      for (c = *++s; c && !isspace (c); c = *++s)
		switch (c)
		  {
		  case 'a':
		    absolute_flag = 1;
		    break;
		  case 'i':
		    ignore_flag = 1;
		    break;
		  case 's':
		    shortname_flag = 1;
		    longname_flag = 0;
		    break;
		  case 'l':
		    shortname_flag = 0;
		    longname_flag = 1;
		    break;
		  case 'm':
		    unix_flag = 0;
		    windows_flag = 1;
		    mixed_flag = 1;
		  case 'w':
		    unix_flag = 0;
		    windows_flag = 1;
		    break;
		  case 'u':
		    windows_flag = 0;
		    unix_flag = 1;
		    break;
		  case 'p':
		    path_flag = 1;
		    break;
		  case 'D':
		  case 'H':
		  case 'O':
		  case 'P':
		  case 'S':
		  case 'W':
		    output_flag = 1;
		    o = c;
		    break;
		  }
	      if (*s)
		do
		  s++;
		while (*s && isspace (*s));
d1004 13
a1016 4
	  if (*s && !output_flag)
	    doit (s);
	  if (!*s && output_flag)
	    dowin (o);
a1018 1

@


1.46
log
@	* cygpath.cc (usage): Add -O and -F, remove tabs.
	(get_special_folder): New function.
	(get_user_folder): New function.
	(dowin): Add -O and -F, better -D, -P error handling.
	(main): Add -O and -F.
	* utils.sgml (cygpath): Document -O and -F.
@
text
@d2 2
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Red Hat, Inc.
d29 1
a29 1
static const char version[] = "$Revision: 1.41 $";
d379 4
a382 1
	  if (FindFirstFile (buf2, &w32_fd) != INVALID_HANDLE_VALUE)
d384 2
d424 1
a424 1
        {
d570 1
a570 1
        get_special_folder (buf, val);
@


1.45
log
@	* Makefile.in (cygpath.exe): Add rule to link cygpath against ntdll.dll.
	* cygpath.cc: Include DDK headers.
	(RtlAllocateUnicodeString): New static inline function.
	(get_device_name): New static function to evaluate DOS path from
	native NT path.
	(get_device_paths): New function to do the same for path lists.
	(doit): Call get_device_paths/get_device_name where appropriate.
@
text
@d31 1
a31 1
static char *file_arg;
d58 1
d62 1
d66 1
a66 1
static char options[] = "ac:df:hilmMopst:uvwADHPSW";
d75 2
a76 1
       %s [-ADHPSW] \n\
d80 1
a80 1
  -d, --dos	        print DOS (short) form of NAMEs (C:\\PROGRA~1\\)\n\
d82 2
a83 2
  -M, --mode		report on mode of file (binmode or textmode)\n\
  -u, --unix	        (default) print Unix form of NAMEs (/cygdrive/c/winnt)\n\
d88 3
a90 3
  -l, --long-name	print Windows long form of NAMEs (with -w, -m only)\n\
  -p, --path	        NAME is a PATH list (i.e., '/bin:/usr/bin')\n\
  -s, --short-name	print DOS (short) form of NAMEs (with -w, -m only)\n\
d92 2
a93 2
  -A, --allusers        use `All Users' instead of current user for -D, -P\n\
  -D, --desktop		output `Desktop' directory and exit\n\
d95 6
a100 4
  -P, --smprograms	output Start Menu `Programs' directory and exit\n\
  -S, --sysdir		output system directory and exit\n\
  -W, --windir		output `Windows' directory and exit\n\
", prog_name, prog_name, prog_name);
d112 1
a112 1
  -i, --ignore		ignore missing argument\n\
d114 1
a114 1
  -v, --version		output version information and exit\n\
d509 19
a533 1
  LPITEMIDLIST id;
d538 1
d542 2
a543 9
      SHGetSpecialFolderLocation (NULL, allusers_flag ?
	CSIDL_COMMON_DESKTOPDIRECTORY : CSIDL_DESKTOPDIRECTORY, &id);
      SHGetPathFromIDList (id, buf);
      /* This if clause is a Fix for Win95 without any "All Users" */
      if (strlen (buf) == 0)
	{
	  SHGetSpecialFolderLocation (NULL, CSIDL_DESKTOPDIRECTORY, &id);
	  SHGetPathFromIDList (id, buf);
	}
d547 19
a565 9
      SHGetSpecialFolderLocation (NULL, allusers_flag ?
	CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS, &id);
      SHGetPathFromIDList (id, buf);
      /* This if clause is a Fix for Win95 without any "All Users" */
      if (strlen (buf) == 0)
	{
	  SHGetSpecialFolderLocation (NULL, CSIDL_PROGRAMS, &id);
	  SHGetPathFromIDList (id, buf);
	}
d596 5
a600 1
  if (!windows_flag)
d878 1
d888 8
d1005 1
@


1.44
log
@	* cygpath.cc (get_long_name): Fallback to get_long_path_name_w32impl.
@
text
@d24 3
d115 155
d648 1
d680 1
@


1.43
log
@	* cygpath.c (get_long_name): Cover the case that GetLongPathName
	doesn't return valid information for non-existant files.  Just return
	incoming filename in that case.
@
text
@d244 3
a246 1
      if (GetLastError () == ERROR_INVALID_PARAMETER)
d252 8
a259 3
      buf[0] = '\0';
      strncat (buf, filename, MAX_PATH - 1);
      len = strlen (buf);
@


1.42
log
@	* cygpath.cc (get_long_name): Load GetLongPathNameA instead of incorrect
	GetLongPathName.
	(doit): Create mixed filename after converting to short or long pathname
	respectively.
@
text
@d242 1
a242 1
  if (len == 0 && GetLastError () == ERROR_INVALID_PARAMETER)
d244 9
a252 3
      fprintf (stderr, "%s: cannot create long name of %s\n", prog_name,
	       filename);
      exit (2);
@


1.42.4.1
log
@2007-08-31  Dave Korn  <dave.korn@@artimi.com>

	* mkgroup.c (enum_groups):  Use MAX_PREFERRED_LENGTH in netgroupenum
	call so that it will automatically size returned buffer sufficiently.

2007-08-03  Dave Korn  <dave.korn@@artimi.com>

	* Makefile.in (cygcheck.exe):  Add bloda.o as prerequisite, adjusting
	dependency-filtering $(wordlist ...) call appropriately.  Link ntdll.
	(bloda.o):  New rule to build bloda.o
	* cygcheck.cc (dump_sysinfo):  Call bloda function dump_dodgy_apps().
	* bloda.cc:  New file implements detection of applications from the
	Big List Of Dodgy Apps.

2007-07-24  Corinna Vinschen  <corinna@@vinschen.de>

	* COPYING.dumper: New file.
	* dumper.cc: Change license to plain GPLv2 + later.
	* dumper.h: Ditto.
	* parse_pe.cc: Ditto.

2007-07-23  Christopher Faylor  <me+cygwin@@cgf.cx>

	* strace.cc (create_child): Don't convert a path from cygwin format
	unless it has a slash.

2007-07-09  Christopher Faylor  <me+cygwin@@cgf.cx>

	* strace.cc (usage): Add missing description for -q.

2007-05-29  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* dumper.cc (dumper::prepare_core_dump): Record a phdr for each section.

2007-03-30  Mark Mitchell  <mark@@codesourcery.com>

	* utils/cygpath.cc (get_long_path_name_w32impl): Close handles returned
	by FindFirstFile.

2006-09-11  Eric Blake  <ebb9@@byu.net>

	* cygcheck.cc (main): Restore POSIXLY_CORRECT before displaying user's
	environment.

2006-08-03  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (vconcat): Don't convert backslahes to slashes.
	(cygpath): Return native path with all backslashes.

2006-07-30  Ilya Bobir  <ilya@@po4ta.com>

	* cygpath.cc (get_long_name): Fallback to get_long_path_name_w32impl.

2006-07-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygpath.c (get_long_name): Cover the case that GetLongPathName
	doesn't return valid information for non-existant files.  Just return
	incoming filename in that case.
@
text
@d2 1
a2 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007 Red Hat, Inc.
d25 1
a25 1
static const char version[] = "$Revision: 1.44 $";
d215 1
a215 4
	  HANDLE h;
	  h = FindFirstFile (buf2, &w32_fd);
	  if (h != INVALID_HANDLE_VALUE)
	    {
a216 2
	      FindClose (h);
	    }
d242 1
a242 1
  if (len == 0)
d244 3
a246 16
      DWORD err = GetLastError ();

      if (err == ERROR_INVALID_PARAMETER)
	{
	  fprintf (stderr, "%s: cannot create long name of %s\n", prog_name,
		   filename);
	  exit (2);
	}
      else if (err == ERROR_FILE_NOT_FOUND)
	len = get_long_path_name_w32impl (filename, buf, MAX_PATH);
      else
	{
	  buf[0] = '\0';
	  strncat (buf, filename, MAX_PATH - 1);
	  len = strlen (buf);
	}
@


1.41
log
@* cygpath.cc (dowin):  Remove stray debugging printf statement.
@
text
@d25 1
a25 1
static const char version[] = "$Revision: 1.40 $";
d237 1
a237 1
    (DWORD (WINAPI *) (LPCSTR, LPSTR, DWORD)) GetProcAddress (k32, "GetLongPathName");
a499 2
      if (mixed_flag)
	buf = get_mixed_name (buf);
d512 2
@


1.40
log
@* Makefile.in: Link cygcheck with libwininet.a.
* cygcheck.cc: Add includes.
(grep_packages): New global variable.
(display_internet_error): New function.
(safe_chars): New global variable.
(base_url): Ditto.
(package_grep): New function.
(usage): Reword --help output for clarity.  Document new argument.
(longopts): Add 'package-query' option.
(opts): Add 'p' option, reorder to be consistent with 'longopts'.
(main): Accommodate new option.
* utils.sgml (cygcheck): Update --help output.  Document new -p option.
@
text
@d25 1
a25 1
static const char version[] = "$Revision: 1.39 $";
a381 1
fprintf (stderr, "************** buf %s\n", buf);
@


1.39
log
@* cygcheck.cc (cygwin_internal): Define as a "C" function.
* strace.cc (cygwin_internal): Ditto.
* cygpath.cc (print_version): Update copyright.
@
text
@d25 1
a25 1
static const char version[] = "$Revision: 1.38 $";
d382 1
@


1.38
log
@* cygpath.cc (usage): Pass in one more copy of program_name to printf to avoid
a SEGV.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
d25 1
a25 1
static const char version[] = "$Revision: 1.37 $";
d538 1
a538 1
Copyright 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.\n\
@


1.37
log
@
* cygpath.cc (usage): Clarify help output to indicate acceptance
of multiple file names as arguments.
@
text
@d25 1
a25 1
static const char version[] = "$Revision: 1.36 $";
d92 1
a92 1
", prog_name, prog_name);
@


1.36
log
@* cygpath.cc (usage): Don't issue helpful message if -i is used.
(from Igor Pechtchanski)
@
text
@d25 1
a25 1
static const char version[] = "$Revision: 1.35 $";
d68 2
a69 1
Usage: %s (-d|-m|-u|-w|-t TYPE) [-c HANDLE] [-f FILE] [options] NAME\n\
d74 1
a74 1
  -d, --dos	        print DOS (short) form of NAME (C:\\PROGRA~1\\)\n\
d77 2
a78 2
  -u, --unix	        (default) print Unix form of NAME (/cygdrive/c/winnt)\n\
  -w, --windows         print Windows form of NAME (C:\\WINNT)\n\
d82 1
a82 1
  -l, --long-name	print Windows long form of NAME (with -w, -m only)\n\
d84 1
a84 1
  -s, --short-name	print DOS (short) form of NAME (with -w, -m only)\n\
@


1.35
log
@* cygpath.cc (long_options): Add "mode" option.
(options): Ditto.
(usage): Report on new option.
(report_mode): New function.
(main): Implement -M option.
@
text
@d25 1
a25 1
static const char version[] = "$Revision: 1.34 $";
d92 5
a96 1
  if (stream == stdout)
d98 1
a98 1
    fprintf (stream, "\
a107 2
  else
    fprintf(stream, "Try `%s --help' for more information.\n", prog_name);
@


1.34
log
@* Makefile.in (build_dumper): Detect missing iconv library.
* cygpath.cc (dowin): Report on filename conversion errors.
(doit): Ditto.
* strace.cc (main): Use symbolic constant for _STRACE_ALL when setting mask.
@
text
@d25 1
a25 1
static const char version[] = "$Revision: 1.33 $";
d44 1
d61 1
a61 1
static char options[] = "ac:df:hilmopst:uvwADHPSW";
d75 1
d415 18
d545 1
a545 1
  char *filename;
d565 1
d591 4
d718 5
a722 4
      for (int i=optind; argv[i]; i++) {
	filename = argv[i];
	doit (filename);
      }
@


1.33
log
@	* cygpath.cc (dowin): Revert accidental checkin from November.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d23 1
d25 1
a25 1
static const char version[] = "$Revision: 1.32 $";
d395 5
a399 2
      cygwin_conv_to_posix_path (buf, buf2);
      buf = buf2;
d417 1
a417 1
  int retval;
d448 1
a448 1
	cygwin_win32_to_posix_path_list (filename, buf);
d451 3
a453 1
	  cygwin_posix_to_win32_path_list (filename, buf);
d461 6
d476 1
a476 1
      retval = conv_func (filename, buf);
d479 1
a479 1
      if (retval < 0)
d481 2
a482 2
	  fprintf (stderr, "%s: error converting \"%s\"\n",
		   prog_name, filename);
@


1.32
log
@	* cygpath.cc (main): Allow multiple pathnames on command line.
@
text
@a11 2
#define _WIN32_IE 0x0400

d24 1
a24 1
static const char version[] = "$Revision: 1.31 $";
d333 1
d341 9
a349 3
      if (!SHGetSpecialFolderPath (NULL, buf, allusers_flag ?
	      CSIDL_COMMON_DESKTOPDIRECTORY : CSIDL_DESKTOPDIRECTORY, FALSE))
	SHGetSpecialFolderPath (NULL, buf, CSIDL_DESKTOPDIRECTORY, FALSE);
d353 9
a361 3
      if (!SHGetSpecialFolderPath (NULL, buf, allusers_flag ?
			    CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS, FALSE))
	SHGetSpecialFolderPath (NULL, buf, CSIDL_PROGRAMS, FALSE);
@


1.31
log
@revert accidental checkin
@
text
@d12 2
d26 1
a26 1
static const char version[] = "$Revision: 1.29 $";
a334 1
  LPITEMIDLIST id;
d342 3
a344 9
      SHGetSpecialFolderLocation (NULL, allusers_flag ?
	CSIDL_COMMON_DESKTOPDIRECTORY : CSIDL_DESKTOPDIRECTORY, &id);
      SHGetPathFromIDList (id, buf);
      /* This if clause is a Fix for Win95 without any "All Users" */
      if (strlen (buf) == 0)
	{
	  SHGetSpecialFolderLocation (NULL, CSIDL_DESKTOPDIRECTORY, &id);
	  SHGetPathFromIDList (id, buf);
	}
d348 3
a350 9
      SHGetSpecialFolderLocation (NULL, allusers_flag ?
	CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS, &id);
      SHGetPathFromIDList (id, buf);
      /* This if clause is a Fix for Win95 without any "All Users" */
      if (strlen (buf) == 0)
	{
	  SHGetSpecialFolderLocation (NULL, CSIDL_PROGRAMS, &id);
	  SHGetPathFromIDList (id, buf);
	}
d667 1
a667 1
      if (optind != argc - 1)
d670 4
a673 2
      filename = argv[optind];
      doit (filename);
@


1.30
log
@* cygcheck.cc (pretty_id): Don't exec if `id' program is not found.
@
text
@a11 2
#define _WIN32_IE 0x0400

d333 1
d341 9
a349 3
      if (!SHGetSpecialFolderPath (NULL, buf, allusers_flag ?
	      CSIDL_COMMON_DESKTOPDIRECTORY : CSIDL_DESKTOPDIRECTORY, FALSE))
	SHGetSpecialFolderPath (NULL, buf, CSIDL_DESKTOPDIRECTORY, FALSE);
d353 9
a361 3
      if (!SHGetSpecialFolderPath (NULL, buf, allusers_flag ?
			    CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS, FALSE))
	SHGetSpecialFolderPath (NULL, buf, CSIDL_PROGRAMS, FALSE);
@


1.29
log
@* Makefile.in (cygcheck.o): Use MINGW_CXX for compilation.
* cygcheck.cc: Just include <getopt.h> rather than cygwin version.
(pretty_id): Avoid compiler warnings.
* cygpath.cc (usage): Ditto.
@
text
@d12 2
d26 1
a26 1
static const char version[] = "$Revision: 1.28 $";
a334 1
  LPITEMIDLIST id;
d342 3
a344 9
      SHGetSpecialFolderLocation (NULL, allusers_flag ?
	CSIDL_COMMON_DESKTOPDIRECTORY : CSIDL_DESKTOPDIRECTORY, &id);
      SHGetPathFromIDList (id, buf);
      /* This if clause is a Fix for Win95 without any "All Users" */
      if (strlen (buf) == 0)
	{
	  SHGetSpecialFolderLocation (NULL, CSIDL_DESKTOPDIRECTORY, &id);
	  SHGetPathFromIDList (id, buf);
	}
d348 3
a350 9
      SHGetSpecialFolderLocation (NULL, allusers_flag ?
	CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS, &id);
      SHGetPathFromIDList (id, buf);
      /* This if clause is a Fix for Win95 without any "All Users" */
      if (strlen (buf) == 0)
	{
	  SHGetSpecialFolderLocation (NULL, CSIDL_PROGRAMS, &id);
	  SHGetPathFromIDList (id, buf);
	}
@


1.28
log
@Throughout, always return error when GetShortPathName returns 0.
@
text
@d24 1
a24 1
static const char version[] = "$Revision: 1.27 $";
d69 1
a69 1
\n\ 
@


1.27
log
@* cygcheck.cc (usage) Add description output.
@
text
@d24 1
a24 1
static const char version[] = "$Revision: 1.26 $";
d124 1
a124 1
      if (len == 0 && GetLastError () == ERROR_INVALID_PARAMETER)
d142 1
a142 1
      if (len == 0 && GetLastError () == ERROR_INVALID_PARAMETER)
d165 1
a165 1
  if (len == 0 && GetLastError () == ERROR_INVALID_PARAMETER)
@


1.26
log
@* cygpath.cc (doit): Allocate more space for non-path filename.
@
text
@d24 1
a24 1
static const char version[] = "$Revision: 1.25 $";
d68 2
@


1.25
log
@* cygpath.cc (get_long_path_name_w32impl): Define similarly to GetLongPathName.
(get_long_name): Correctly prototype GetLongPathName.
(get_long_paths): Implement using get_long_name to cut down on code
duplication.
(doit): Do various things to make path output work predictably.
@
text
@d24 1
a24 1
static const char version[] = "$Revision: 1.24 $";
d418 1
a418 1
	len += 100;
d473 4
a476 4
	if (shortname_flag)
	  buf = get_short_name (buf);
	if (longname_flag)
	  buf = get_long_name (buf, len);
@


1.24
log
@* cygpath.cc (close_arg): Remove unused static.
* mkgroup.c (enum_local_users): Avoid compiler warning.
(enum_users): Ditto.
* mkpasswd.c: Ditto throughout.
* ssp.c: Ditto throughout.
@
text
@d24 1
a24 1
static const char version[] = "$Revision: 1.23 $";
d178 1
a178 1
static DWORD
d185 1
a185 1
  
d224 26
d253 11
a263 4
  char *sptr;
  char *next;
  char *ptr = path;
  char *end = strrchr (path, 0);
d265 3
a267 1
  DWORD len;
d269 1
a269 11
  HINSTANCE hinst;
  DWORD (*GetLongPathNameAPtr) (LPCSTR, LPSTR, DWORD) = 0;
  hinst = LoadLibrary ("kernel32");
  if (hinst)
    GetLongPathNameAPtr = (DWORD (*) (LPCSTR, LPSTR, DWORD))
      GetProcAddress (hinst, "GetLongPathNameA");
  /* subsequent calls of kernel function with NULL cause SegFault in W2K!! */
  if (1 || !GetLongPathNameAPtr)
    GetLongPathNameAPtr = get_long_path_name_w32impl;

  while (ptr != NULL)
d271 2
a272 1
      next = ptr;
d276 1
a276 7
      len = (*GetLongPathNameAPtr) (next, NULL, 0);
      if (len == 0 && GetLastError () == ERROR_INVALID_PARAMETER)
	{
	  fprintf (stderr, "%s: cannot create long name of %s\n", prog_name,
		   next);
	  exit (2);
	}
d279 2
a280 1
  sptr = sbuf = (char *) malloc (acc + 1);
d286 3
a288 2
  ptr = path;
  for (;;)
d290 3
a292 7
      len = (*GetLongPathNameAPtr) (ptr, sptr, acc);
      if (len == 0 && GetLastError () == ERROR_INVALID_PARAMETER)
	{
	  fprintf (stderr, "%s: cannot create long name of %s\n", prog_name,
		   ptr);
	  exit (2);
	}
d294 1
a294 8
      ptr = strrchr (ptr, 0);
      sptr = strrchr (sptr, 0);
      if (ptr == end)
	break;
      *ptr = *sptr = ';';
      ++ptr, ++sptr;
      acc -= len + 1;
    }
a297 30
static char *
get_long_name (const char *filename)
{
  char *sbuf, buf[MAX_PATH];
  DWORD len;
  HINSTANCE hinst;
  DWORD (*GetLongPathNameAPtr) (LPCSTR, LPSTR, DWORD) = 0;
  hinst = LoadLibrary ("kernel32");
  if (hinst)
    GetLongPathNameAPtr = (DWORD (*) (LPCSTR, LPSTR, DWORD))
      GetProcAddress (hinst, "GetLongPathNameA");
  if (!GetLongPathNameAPtr)
    GetLongPathNameAPtr = get_long_path_name_w32impl;
  
  len = (*GetLongPathNameAPtr) (filename, buf, MAX_PATH);
  if (len == 0 && GetLastError () == ERROR_INVALID_PARAMETER)
    {
      fprintf (stderr, "%s: cannot create long name of %s\n", prog_name,
	       filename);
      exit (2);
    }
  sbuf = (char *) malloc (++len);
  if (sbuf == NULL)
    {
      fprintf (stderr, "%s: out of memory\n", prog_name);
      exit (1);
    }
  return strcpy (sbuf, buf);
}

d332 1
a332 1
  HINSTANCE hinst;
d334 1
a334 1
      
d339 1
a339 1
      SHGetSpecialFolderLocation (NULL, allusers_flag ? 
d351 1
a351 1
      SHGetSpecialFolderLocation (NULL, allusers_flag ? 
d363 2
a364 2
      hinst = LoadLibrary ("userenv");
      if (hinst)
d366 1
a366 1
	  GetProcAddress (hinst, "GetProfilesDirectoryA");
d410 1
a410 1
  size_t len;
a413 10
  if (path_flag)
    {
      if (cygwin_posix_path_list_p (filename) ? unix_flag : windows_flag)
	{
	  /* The path is already in the right format.  */
	  puts (filename);
	  exit (0);
	}
    }

d416 6
a421 2
      len = strlen (filename) + 100;
      if (len == 100)
d423 2
a424 7
	  if (!ignore_flag)
	    {
	      fprintf (stderr, "%s: can't convert empty path\n", prog_name);
	      exit (1);
	    }
	  else
	    exit (0);
d427 2
d430 1
a430 9
    {
      if (unix_flag)
	len = cygwin_win32_to_posix_path_list_buf_size (filename);
      else
	len = cygwin_posix_to_win32_path_list_buf_size (filename);
    }

  if (len < PATH_MAX)
    len = PATH_MAX;
d476 1
a476 1
	  buf = get_long_name (buf);
d545 1
a545 1
	  if (windows_flag) 
d597 7
a603 7
            {
            if (windows_flag || longname_flag)
              usage (stderr, 1);
            unix_flag = 0;
            windows_flag = 1;
            shortname_flag = 1;
            }
d605 2
a606 2
            {
            unix_flag = 0;
d608 1
a608 1
            }
d610 3
a612 3
            {
            if (windows_flag)
              usage (stderr, 1);
d614 1
a614 1
            }
d616 6
a621 6
            {
            if (mixed_flag)
              usage (stderr, 1);
            unix_flag = 0;
            windows_flag = 1;
            }
@


1.23
log
@2002-09-12  Igor Pechtchanski <pechtcha@@cs.nyu.edu>
	* cygpath.cc (options) New global variable.
	(main) Make short options global for easier change.
	(print_version) Add a missing newline.
@
text
@d24 1
a24 1
static const char version[] = "$Revision: 1.22 $";
a27 1
static char *close_arg;
@


1.22
log
@output some newlines.
@
text
@d24 1
a24 1
static const char version[] = "$Revision: 1.21 $";
d60 2
d539 2
a540 1
Compiled on %s", len, v, __DATE__);
d568 1
a568 1
  while ((c = getopt_long (argc, argv, (char *) "ac:df:hilmopst:uvwADHPSW",
@


1.21
log
@* mount.cc (main): Ensure that mount_already_exists() also gets default flag
that is passed to do_mount.
* cygpath.cc (long_options): Add "dos" and "mixed", correct "close", "file" and
"type" to use NULL flag.
(usage): Clean up usage output (more), accomodate new options.
(main): Add --dos and --mixed options; accomodate all output forms in --type.
Make UNIXy output default.
@
text
@d24 1
a24 1
static const char version[] = "$Revision: 1.20 $";
d95 1
a95 1
  -v, --version		output version information and exit\
d99 1
a99 1
    fprintf(stream, "Try `%s --help' for more information.", prog_name);
@


1.20
log
@* cygpath.cc (usage): Clean up usage output.
(dowin): Correct output of -t mixed for -ADHPSW options.
@
text
@d24 1
a24 1
static const char version[] = "$Revision: 1.19 $";
d33 1
a33 1
static const char *windows_format_arg;
d36 4
d41 3
a43 1
  {(char *) "absolute", no_argument, NULL, 'a'},
d46 2
a47 1
  {(char *) "close", required_argument, (int *) &close_arg, 'c'},
a48 1
  {(char *) "file", required_argument, (int *) &file_arg, 'f'},
a50 5
  {(char *) "short-name", no_argument, NULL, 's'},
  {(char *) "long-name", no_argument, NULL, 'l'},
  {(char *) "windir", no_argument, NULL, 'W'},
  {(char *) "sysdir", no_argument, NULL, 'S'},
  {(char *) "ignore", no_argument, NULL, 'i'},
d53 1
d55 2
a56 2
  {(char *) "type", required_argument, (int *) &windows_format_arg, 't'},
  {(char *) "homeroot", no_argument, NULL, 'H'},
d65 8
a72 8
Usage: %s (-u|-w|-t TYPE) [-c HANDLE] [-f FILE] [options] NAME\n\n\
       %s [-ADHPSW] \n\n\
Output type options (required):\n\
  -u|--unix		print Unix form of NAME (default)\n\
  -w|--windows		print Windows form of NAME \n\n\
  -t|--type             print Windows form of NAME with TYPE one of\n\
     dos                drive letter with backslashes (C:\\WINNT)\n\
     mixed              drive letter with regular slashes (C:/WINNT)\n\
d74 15
a88 14
  -a|--absolute		output absolute path\n\
  -c|--close HANDLE     close HANDLE (for use in captured process)\n\
  -f|--file FILE        read FILE for input; use - to read from STDIN\n\
  -i|--ignore		ignore missing argument\n\
  -l|--long-name	print Windows long form of NAME (with -w only)\n\
  -p|--path		NAME is a PATH list (i.e., '/bin:/usr/bin')\n\
  -s|--short-name	print Windows short form of NAME (with -w only)\n\
System information output:\n\
  -A|--allusers		use `All Users' instead of current user for -D, -P\n\
  -D|--desktop		output `Desktop' directory and exit\n\
  -H|--homeroot		output `Profiles' directory (home root) and exit\n\
  -P|--smprograms	output Start Menu `Programs' directory and exit\n\
  -S|--sysdir		output system directory and exit\n\
  -W|--windir		output `Windows' directory and exit\n\n\
d90 10
a99 3
  -h|--help             output usage information and exit\n\
  -v|--version		output version information and exit\n\
  ", prog_name, prog_name);
d556 1
a556 1
  unix_flag = 0;
d565 1
a565 1
  while ((c = getopt_long (argc, argv, (char *) "hac:f:opslSuvwt:WiDPAH",
d578 8
d599 1
a599 1
	  if (unix_flag || windows_flag)
d605 1
a605 1
	  if (unix_flag || windows_flag)
d607 6
d614 1
a617 2
	  if (unix_flag || shortname_flag)
	    usage (stderr, 1);
a621 2
	  if (unix_flag || longname_flag)
	    usage (stderr, 1);
d626 1
a626 1
	  if (unix_flag || (optarg == NULL))
d629 12
a640 4
	  windows_flag = 1;
	  windows_format_arg = (*optarg == '=') ? (optarg + 1) : (optarg);

	  if (strcasecmp (windows_format_arg, "mixed") == 0)
d642 14
a655 2
	  else if (strcasecmp (windows_format_arg, "dos") == 0)
	    /* nothing */;
d696 7
a702 1
  if (!output_flag && !unix_flag && !windows_flag && !options_from_file_flag)
d764 4
@


1.19
log
@* cygpath.cc: Add option to output windows paths in different formats: "dos"
and "mixed".
(main): Process options.
(doit): Check new options flags.
@
text
@d24 1
a24 1
static const char version[] = "$Revision: 1.18 $";
d63 9
a71 4
Usage: %s (-u|--unix)|(-w|--windows) [options] filename\n\n\
  -u|--unix		print Unix form of filename\n\
  -w|--windows		print Windows form of filename\n\n\
Other options:\n\
d73 2
a74 2
  -c|--close handle	close handle (for use in captured process)\n\
  -f|--file file	read file for input path information\n\
d76 4
a79 6
  -l|--long-name	print Windows long form of filename (with -w only)\n\
  -p|--path		filename argument is a path\n\
  -s|--short-name	print Windows short form of filename (with -w only)\n\
  -t|--type             print Windows form of filename with specified\n\
     dos                drive letter with backslashes (C:\\WINNT)\n\
     mixed              drive letter with regular slashes (C:/WINNT)\n\
d86 4
a89 3
Informative output:\n\
  -h|--help             print this help, then exit\n\
  -v|--version		output version information and exit\n", prog_name);
d307 27
d376 1
a376 1
        (*GetProfilesDirectoryAPtr) (buf, &len);
d406 3
a408 1
        buf = get_short_name (buf);
a414 27
convert_slashes (char* name)
{
  while ((name = strchr (name, '\\')) != NULL)
    {
      if (*name == '\\')
	*name = '/';
       name++;
   }
}

static char *
get_mixed_name (const char* filename)
{
  char* mixed_buf = strdup (filename);

  if (mixed_buf == NULL)
    {
      fprintf (stderr, "%s: out of memory\n", prog_name);
      exit (1);
    }

  convert_slashes (mixed_buf);

  return mixed_buf;
}

static void
a649 1

@


1.18
log
@	* cygpath.cc (usage): Change usage output slightly.

	* cygpath.cc (main): Add option l to support conversion to
	Windows long file names.  Refactured code for capital options.
	Support of options from file for capital options.
	(dowin): New function.  Refactured from main.
	(doit): Call long path conversion.
	(get_long_name): New function.
	(get_long_paths): New function.
	(get_long_path_name_w32impl): New function.  Reimplementation
	of Windows API function GetLongPathName (only 98/Me/2000/XP or
	higher).
	(get_short_name): Call GetShortPathName only once.
	(get_short_paths): Fix calculating buffer size.
	* utils.sgml: Update cygpath section for l option.
@
text
@d24 1
a24 1
static const char version[] = "$Revision: 1.13 $";
d32 2
d53 1
d74 3
d382 27
d469 2
d482 2
d544 1
d549 2
a550 3
  while ((c =
	  getopt_long (argc, argv, (char *) "hac:f:opslSuvwWiDPAH",
		       long_options, (int *) NULL)) != EOF)
d598 15
d728 1
a728 1
	  	    output_flag = 1;
d730 1
a730 1
	  	    break;
@


1.17
log
@	* cygpath.cc (get_short_paths): Fix more error checking.
	(get_short_name): Ditto.

	* cygpath.cc (main): Add option H to show the Windows' profiles
	directory.  Support short names for options DPSW.  Clean up
	copied code lines.
	* utils.sgml: Update cygpath section for H option and s support.
@
text
@d30 2
a31 1
static int shortname_flag, ignore_flag, allusers_flag, output_flag;
d44 1
d60 4
a63 1
Usage: %s [-p|--path] (-u|--unix)|(-w|--windows [-s|--short-name]) filename\n\
d68 1
d70 1
a70 4
  -s|--short-name	print Windows short form of filename\n\
  -u|--unix		print Unix form of filename\n\
  -v|--version		output version information and exit\n\
  -w|--windows		print Windows form of filename\n\
d76 4
a79 1
  -W|--windir		output `Windows' directory and exit\n", prog_name);
d132 1
d140 2
a141 2
  char *sbuf;
  DWORD len = GetShortPathName (filename, NULL, 0);
d154 127
a280 1
  len = GetShortPathName (filename, sbuf, len);
d283 1
a283 1
      fprintf (stderr, "%s: cannot create short name of %s\n", prog_name,
d287 86
a372 1
  return sbuf;
d434 2
d453 7
a459 2
      if (!unix_flag && shortname_flag)
	buf = get_short_name (buf);
d506 1
d512 1
a512 1
	  getopt_long (argc, argv, (char *) "hac:f:opsSuvwWiDPAH",
d549 6
d556 1
a556 1
	  if (unix_flag)
a594 83
  if (output_flag)
    {
      char *buf, buf1[MAX_PATH], buf2[MAX_PATH];
      DWORD len = MAX_PATH;
      WIN32_FIND_DATA w32_fd;
      LPITEMIDLIST id;
      HINSTANCE hinst;
      BOOL (*GetProfilesDirectoryAPtr) (LPSTR, LPDWORD) = 0;
      
      buf = buf1;
      switch (o)
	{
	case 'D':
	  if (!allusers_flag)
	    SHGetSpecialFolderLocation (NULL, CSIDL_DESKTOPDIRECTORY, &id);
	  else
	    SHGetSpecialFolderLocation (NULL, CSIDL_COMMON_DESKTOPDIRECTORY,
					&id);
	  SHGetPathFromIDList (id, buf);
	  /* This if clause is a Fix for Win95 without any "All Users" */
	  if (strlen (buf) == 0)
	    {
	      SHGetSpecialFolderLocation (NULL, CSIDL_DESKTOPDIRECTORY, &id);
	      SHGetPathFromIDList (id, buf);
	    }
	  break;

	case 'P':
	  if (!allusers_flag)
	    SHGetSpecialFolderLocation (NULL, CSIDL_PROGRAMS, &id);
	  else
	    SHGetSpecialFolderLocation (NULL, CSIDL_COMMON_PROGRAMS, &id);
	  SHGetPathFromIDList (id, buf);
	  /* This if clause is a Fix for Win95 without any "All Users" */
	  if (strlen (buf) == 0)
	    {
	      SHGetSpecialFolderLocation (NULL, CSIDL_PROGRAMS, &id);
	      SHGetPathFromIDList (id, buf);
	    }
	  break;

	case 'H':
	  hinst = LoadLibrary ("userenv");
	  if (hinst)
	    GetProfilesDirectoryAPtr = (BOOL (*) (LPSTR, LPDWORD))
	      GetProcAddress (hinst, "GetProfilesDirectoryA");
	  if (GetProfilesDirectoryAPtr)
	    (*GetProfilesDirectoryAPtr) (buf, &len);
	  else
	    {
	      GetWindowsDirectory (buf, MAX_PATH);
	      strcat (buf, "\\Profiles");
	    }
	  break;

	case 'S':
	  GetSystemDirectory (buf, MAX_PATH);
	  FindFirstFile (buf, &w32_fd);
	  strcpy (strrchr (buf, '\\') + 1, w32_fd.cFileName);
	  break;

	case 'W':
	  GetWindowsDirectory (buf, MAX_PATH);
	  break;

	default:
    	  usage (stderr, 1);
	}

	if (!windows_flag)
	  {
	    cygwin_conv_to_posix_path (buf, buf2);
	    buf = buf2;
	  }
	else
	  {
	    if (shortname_flag)
	      buf = get_short_name (buf);
	  }
	printf ("%s\n", buf);
	exit (0);
    }

d598 1
a598 1
  if (!unix_flag && !windows_flag && !options_from_file_flag)
d603 3
d654 5
d670 9
d685 1
a685 1
	  if (*s)
d687 2
@


1.16
log
@	* cygpath.cc (get_short_name): Fix error checking.
@
text
@d49 1
d70 1
d95 1
a95 1
      if (len ==0 && GetLastError () == ERROR_INVALID_PARAMETER)
d112 2
a113 1
      if (GetShortPathName (ptr, sptr, acc) == ERROR_INVALID_PARAMETER)
d135 1
a135 1
  if (len == ERROR_INVALID_PARAMETER)
d147 2
a148 1
  if (GetShortPathName (filename, sbuf, len) == ERROR_INVALID_PARAMETER)
a267 3
  char buf[MAX_PATH], buf2[MAX_PATH];
  WIN32_FIND_DATA w32_fd;
  LPITEMIDLIST id;
d286 1
a286 1
	  getopt_long (argc, argv, (char *) "hac:f:opsSuvwWiDPA",
d334 1
a334 6
	  if (output_flag)
	    usage (stderr, 1);
	  output_flag = 1;
	  o = 'D';
	  break;

a335 6
	  if (output_flag)
	    usage (stderr, 1);
	  output_flag = 1;
	  o = 'P';
	  break;

a336 6
	  if (output_flag)
	    usage (stderr, 1);
	  output_flag = 1;
	  o = 'S';
	  break;

d341 1
a341 1
	  o = 'W';
d365 8
d388 1
a388 6
	  if (!windows_flag)
	    cygwin_conv_to_posix_path (buf, buf2);
	  else
	    strcpy (buf2, buf);
	  printf ("%s\n", buf2);
	  exit (0);
d402 9
a410 2
	  if (!windows_flag)
	    cygwin_conv_to_posix_path (buf, buf2);
d412 5
a416 3
	    strcpy (buf2, buf);
	  printf ("%s\n", buf2);
	  exit (0);
d422 1
a422 6
	  if (!windows_flag)
	    cygwin_conv_to_posix_path (buf, buf2);
	  else
	    strcpy (buf2, buf);
	  printf ("%s\n", buf2);
	  exit (0);
d426 1
a426 6
	  if (!windows_flag)
	    cygwin_conv_to_posix_path (buf, buf2);
	  else
	    strcpy (buf2, buf);
	  printf ("%s\n", buf2);
	  exit (0);
d429 1
a429 1
	  fprintf (stderr, "ERROR: main: switch (o)!\n");
d431 13
@


1.15
log
@* cygpath.cc: Reformat.
* cygpath.cc (print_version): New function.
(main): Accommodate new version function.  Initialize 'o' to prevent warning.
* cygcheck.cc (main): Eliminate non-GNU formatting glitch.
@
text
@d93 1
a93 1
      if (len == ERROR_INVALID_PARAMETER)
@


1.14
log
@Change copyright format.
@
text
@d24 2
d32 18
a49 19
static struct option long_options[] =
{
  { (char *) "help", no_argument, NULL, 'h' },
  { (char *) "absolute", no_argument, NULL, 'a'},
  { (char *) "option", no_argument, NULL, 'o'},
  { (char *) "path", no_argument, NULL, 'p' },
  { (char *) "close", required_argument, (int *) &close_arg, 'c'},
  { (char *) "unix", no_argument, NULL, 'u' },
  { (char *) "file", required_argument, (int *) &file_arg, 'f'},
  { (char *) "version", no_argument, NULL, 'v' },
  { (char *) "windows", no_argument, NULL, 'w' },
  { (char *) "short-name", no_argument, NULL, 's' },
  { (char *) "windir", no_argument, NULL, 'W' },
  { (char *) "sysdir", no_argument, NULL, 'S' },
  { (char *) "ignore", no_argument, NULL, 'i' },
  { (char *) "allusers", no_argument, NULL, 'A' },
  { (char *) "desktop", no_argument, NULL, 'D' },
  { (char *) "smprograms", no_argument, NULL, 'P' },
  { 0, no_argument, 0, 0 }
d53 1
a53 1
usage (FILE *stream, int status)
d71 1
a71 2
  -W|--windir		output `Windows' directory and exit\n",
	   prog_name);
a86 7
  {
    next = ptr;
    ptr = strchr (ptr, ';');
    if (ptr)
      *ptr++ = 0;
    len = GetShortPathName (next, NULL, 0);
    if (len == ERROR_INVALID_PARAMETER)
d88 12
a99 2
      fprintf (stderr, "%s: cannot create short name of %s\n", prog_name, next);
      exit (2);
d101 1
a101 3
    acc += len+1;
  }
  sptr = sbuf = (char *) malloc(acc+1);
d103 4
a106 4
  {
    fprintf (stderr, "%s: out of memory\n", prog_name);
    exit (1);
  }
d108 1
a108 3
  for(;;)
  {
    if (GetShortPathName (ptr, sptr, acc) == ERROR_INVALID_PARAMETER)
d110 13
a122 2
      fprintf (stderr, "%s: cannot create short name of %s\n", prog_name, ptr);
      exit (2);
a123 8

    ptr = strrchr (ptr, 0);
    sptr = strrchr (sptr, 0);
    if (ptr == end)
      break;
    *sptr = ';';
    ++ptr, ++sptr;
  }
d133 6
a138 5
  {
    fprintf (stderr, "%s: cannot create short name of %s\n", prog_name, filename);
    exit (2);
  }
  sbuf = (char *) malloc(++len);
d140 4
a143 4
  {
    fprintf (stderr, "%s: out of memory\n", prog_name);
    exit (1);
  }
d145 5
a149 4
  {
    fprintf (stderr, "%s: cannot create short name of %s\n", prog_name, filename);
    exit (2);
  }
d159 1
a159 1
  int (*conv_func)(const char *, char *);
d163 1
a163 3
      if (cygwin_posix_path_list_p (filename)
	  ? unix_flag
	  : windows_flag)
d171 1
a171 1
  if (! path_flag)
d175 9
a183 9
        {
          if (!ignore_flag)
            {
              fprintf(stderr, "%s: can't convert empty path\n", prog_name);
              exit (1);
            }
          else
            exit (0);
        }
d208 5
a212 5
      {
	cygwin_posix_to_win32_path_list (filename, buf);
	if (shortname_flag)
	  buf = get_short_paths (buf);
      }
d217 2
a218 2
	conv_func = (absolute_flag ? cygwin_conv_to_full_posix_path : 
                     cygwin_conv_to_posix_path);
d220 2
a221 2
        conv_func = (absolute_flag ? cygwin_conv_to_full_win32_path :
                     cygwin_conv_to_win32_path);
d224 5
a228 5
        {
          fprintf (stderr, "%s: error converting \"%s\"\n",
                   prog_name, filename);
          exit (1);
        }
d230 1
a230 1
        buf = get_short_name (buf);
d236 22
d261 1
a261 1
  int c, o;
d284 3
a286 2
  while ((c = getopt_long (argc, argv, (char *) "hac:f:opsSuvwWiDPA", long_options, (int *) NULL))
	 != EOF)
d344 1
a344 1
          break;
d351 1
a351 1
          break;
d369 1
a369 2
	  printf ("Cygwin path conversion version 1.2\n");
	  printf ("Copyright 1998-2002 Red Hat, Inc.\n");
d379 1
a379 1
  if (output_flag) 
d381 2
a382 1
      switch(o) {
d385 1
a385 1
            SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOPDIRECTORY,&id);
d387 9
a395 7
            SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_DESKTOPDIRECTORY,&id);
          SHGetPathFromIDList(id, buf);
          /* This if clause is a Fix for Win95 without any "All Users" */
          if ( strlen(buf) == 0 ) {
            SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOPDIRECTORY,&id);
            SHGetPathFromIDList(id, buf);
          }
d397 1
a397 1
	    cygwin_conv_to_posix_path(buf, buf2);
d399 3
a401 3
	    strcpy(buf2, buf);
          printf("%s\n", buf2);
          exit(0);
d405 1
a405 1
            SHGetSpecialFolderLocation(NULL, CSIDL_PROGRAMS, &id);
d407 8
a414 7
            SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_PROGRAMS, &id);
          SHGetPathFromIDList(id, buf);
          /* This if clause is a Fix for Win95 without any "All Users" */
          if ( strlen(buf) == 0 ) {
            SHGetSpecialFolderLocation(NULL, CSIDL_PROGRAMS, &id);
            SHGetPathFromIDList(id, buf);
          }
d416 1
a416 1
	    cygwin_conv_to_posix_path(buf, buf2);
d418 4
a421 4
	    strcpy(buf2, buf);
          printf("%s\n", buf2);
          exit(0);
 
d423 3
a425 3
	  GetSystemDirectory(buf, MAX_PATH);
	  FindFirstFile(buf, &w32_fd);
	  strcpy(strrchr(buf, '\\')+1, w32_fd.cFileName);
d427 1
a427 1
	    cygwin_conv_to_posix_path(buf, buf2);
d429 3
a431 3
	    strcpy(buf2, buf);
          printf("%s\n", buf2);
          exit(0);
d434 1
a434 1
	  GetWindowsDirectory(buf, MAX_PATH);
d436 1
a436 1
	    cygwin_conv_to_posix_path(buf, buf2);
d438 4
a441 4
	    strcpy(buf2, buf);
          printf("%s\n", buf2);
          exit(0);
 
d443 3
a445 3
	  fprintf(stderr, "ERROR: main: switch(o)!\n");
      }
  }
d450 1
a450 1
  if (! unix_flag && ! windows_flag && !options_from_file_flag)
@


1.13
log
@	* cygpath.cc (main): Add options to show Desktop and Start
	Menu's Programs directory for current user or all users.
	Move bulk of DPWS options outside the getopt case statement.
	* utils.sgml: Update cygpath section for ADPWS options.
@
text
@d2 1
a2 1
   Copyright 1998-2002 Red Hat, Inc.
@


1.12
log
@	* cygpath.cc (doit): Empty file ignored using option -i.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001 Red Hat, Inc.
d10 3
d28 1
a28 1
static int shortname_flag, ignore_flag;
d45 3
d59 1
a59 1
  -f|--file file	read file for path information\n\
a62 1
  -S|--sysdir		print `system' directory\n\
d64 1
d66 5
a70 1
  -W|--windir		print `Windows' directory\n",
d237 1
a237 1
  int c;
d242 1
d258 3
a260 1
  while ((c = getopt_long (argc, argv, (char *) "hac:f:opsSuvwWi", long_options, (int *) NULL))
d303 17
a319 8
	case 'W':
	  GetWindowsDirectory(buf, MAX_PATH);
	  if (!windows_flag)
	    cygwin_conv_to_posix_path(buf, buf2);
	  else
	    strcpy(buf2, buf);
	  printf("%s\n", buf2);
	  exit(0);
d322 12
a333 9
	  GetSystemDirectory(buf, MAX_PATH);
	  FindFirstFile(buf, &w32_fd);
	  strcpy(strrchr(buf, '\\')+1, w32_fd.cFileName);
	  if (!windows_flag)
	    cygwin_conv_to_posix_path(buf, buf2);
	  else
	    strcpy(buf2, buf);
	  printf("%s\n", buf2);
	  exit(0);
d344 2
a345 2
	  printf ("Cygwin path conversion version 1.1\n");
	  printf ("Copyright 1998,1999,2000,2001 Red Hat, Inc.\n");
d352 1
d354 64
@


1.11
log
@* cygpath.cc (doit): Detect and warn about an empty path.  Detect and warn
about errors converting a path.
(main): Set prog_name correctly -- don't leave an extra slash or backslash at
the beginning of it.
@
text
@d164 7
a170 2
          fprintf(stderr, "%s: can't convert empty path\n", prog_name);
          exit (1);
@


1.10
log
@* Makefile.in: Add define to CXXFLAGS.
@
text
@d144 2
d160 8
a167 1
    len = strlen (filename) + 100;
d200 2
a201 1
	(absolute_flag ? cygwin_conv_to_full_posix_path : cygwin_conv_to_posix_path) (filename, buf);
d203 11
a213 5
	{
	  (absolute_flag ? cygwin_conv_to_full_win32_path : cygwin_conv_to_win32_path) (filename, buf);
	  if (shortname_flag)
	    buf = get_short_name (buf);
	}
d233 2
@


1.9
log
@* cygcheck.cc (usage): Add -c description.
* cygpath.cc (usage): Alphabetize options.
* strace.cc (usage): Ditto.
@
text
@d1 2
a2 3
/* pathconv.cc -- convert pathnames between Windows and Unix format
   Copyright 1998, 1999, 2000 Cygnus Solutions.
   Written by Ian Lance Taylor <ian@@cygnus.com>.
d296 2
a297 2
	  printf ("Cygwin pathconv version 1.0\n");
	  printf ("Copyright 1998,1999,2000 Cygnus Solutions\n");
@


1.8
log
@* cygpath.cc (main): Support -w for Windows (System) directories and return
physical correct orthography for the Windows System dir.
@
text
@d55 4
d61 1
a61 5
  -s|--short-name	print Windows short form of filename\n\
  -W|--windir		print `Windows' directory\n\
  -S|--sysdir		print `system' directory\n\
  -p|--path		filename argument is a path\n\
  -i|--ignore		ignore missing argument\n",
@


1.7
log
@Cleanup formatting on some files.  Remove excessive whitespace.
@
text
@d211 1
d270 4
a273 1
	  cygwin_conv_to_posix_path(buf, buf2);
d279 6
a284 1
	  cygwin_conv_to_posix_path(buf, buf2);
@


1.6
log
@* cygpath.cc: Add new options: -s and -i.
* utils.sgml: Document the new options.
@
text
@d55 2
a56 2
  -u|--unix     	print Unix form of filename\n\
  -w|--windows  	print Windows form of filename\n\
d58 4
a61 4
  -W|--windir 	 	print `Windows' directory\n\
  -S|--sysdir 	 	print `system' directory\n\
  -p|--path     	filename argument is a path\n\
  -i|--ignore     	ignore missing argument\n",
@


1.5
log
@* cygpath.cc: add --windir/--sysdir options
* utils.sgml: and document them
@
text
@d26 1
d39 1
d42 1
d49 3
a51 2
  fprintf (stream, "\
Usage: %s [-p|--path] (-u|--unix)|(-w|--windows) filename\n\
d57 1
d60 2
a61 1
  -p|--path     	filename argument is a path\n",
d63 75
a137 1
  exit (status);
d183 1
d185 3
d194 5
a198 1
	(absolute_flag ? cygwin_conv_to_full_win32_path : cygwin_conv_to_win32_path) (filename, buf);
d221 2
d224 1
a224 1
  while ((c = getopt_long (argc, argv, (char *) "hac:f:opSuvwW", long_options, (int *) NULL))
d261 6
d279 4
d348 6
@


1.4
log
@* Makefile.in: Eliminate WINSUP_DEPS.
* cygpath.cc: Reorganize includes to accomodate sys/cygwin.h changes.
* mkgroup.c: Ditto.
* mkpasswd.c: Ditto.
* mount.cc: Ditto.  Eliminate use of cygwin source specific includes.
* ps.cc: Ditto.
* cygwin.cc: Eliminate obsolete file.
@
text
@d38 2
d53 2
d122 1
d134 1
a134 1
  while ((c = getopt_long (argc, argv, (char *) "hac:f:opuvw", long_options, (int *) NULL))
d171 12
d189 1
a189 1
	  printf ("Copyright 1998 Cygnus Solutions\n");
@


1.3
log
@* cygpath.cc (main): Add -a -o and -c options.
(doit): Ditto.
@
text
@d16 1
a20 1
#include <windows.h>
@


1.2
log
@* cygpath.cc (main): Add -f option for processing a group of paths from a file.
(doit): New function.
@
text
@d19 2
d24 2
d30 2
d33 1
d46 6
a51 4
  -f|--file	read file for path information\n\
  -u|--unix     print Unix form of filename\n\
  -w|--windows  print Windows form of filename\n\
  -p|--path     filename argument is a path\n",
d57 1
a57 1
doit (char *filename, int path_flag, int unix_flag, int windows_flag)
d104 1
a104 1
	cygwin_conv_to_posix_path (filename, buf);
d106 1
a106 1
	cygwin_conv_to_win32_path (filename, buf);
a114 1
  int path_flag, unix_flag, windows_flag;
d116 1
d128 2
a129 1
  while ((c = getopt_long (argc, argv, (char *) "hf:puvw", long_options, (int *) NULL))
d134 8
d146 4
d181 4
a184 1
  if (! unix_flag && ! windows_flag)
d193 1
a193 1
      doit (filename, path_flag, unix_flag, windows_flag);
d216 1
d219 2
a220 1
	  char *p = strchr (buf, '\n');
d223 27
a249 1
	  doit (buf, path_flag, unix_flag, windows_flag);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1998 Cygnus Solutions.
d16 2
d21 1
d28 1
d39 1
d47 56
a108 2
  size_t len;
  char *buf;
d119 1
a119 1
  while ((c = getopt_long (argc, argv, (char *) "hpuvw", long_options, (int *) NULL))
d124 4
a158 3
  if (optind != argc - 1)
    usage (stderr, 1);

d162 4
a165 1
  filename = argv[optind];
d167 2
a168 10
  if (path_flag)
    {
      if (cygwin_posix_path_list_p (filename)
	  ? unix_flag
	  : windows_flag)
	{
	  /* The path is already in the right format.  */
	  puts (filename);
	  exit (0);
	}
a169 3

  if (! path_flag)
    len = strlen (filename) + 100;
d172 2
a173 5
      if (unix_flag)
	len = cygwin_win32_to_posix_path_list_buf_size (filename);
      else
	len = cygwin_posix_to_win32_path_list_buf_size (filename);
    }
d175 2
a176 2
  if (len < PATH_MAX)
    len = PATH_MAX;
d178 12
a189 6
  buf = (char *) malloc (len);
  if (buf == NULL)
    {
      fprintf (stderr, "%s: out of memory\n", prog_name);
      exit (1);
    }
d191 7
a197 6
  if (path_flag)
    {
      if (unix_flag)
	cygwin_win32_to_posix_path_list (filename, buf);
      else
	cygwin_posix_to_win32_path_list (filename, buf);
a198 9
  else
    {
      if (unix_flag)
	cygwin_conv_to_posix_path (filename, buf);
      else
	cygwin_conv_to_win32_path (filename, buf);
    }

  puts (buf);
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
