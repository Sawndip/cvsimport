head	1.37;
access;
symbols
	cygwin-1_7_35-release:1.37
	cygwin-1_7_34-release:1.37
	cygwin-1_7_33-release:1.36
	cygwin-1_7_32-release:1.36
	cygwin-1_7_31-release:1.36
	cygwin-1_7_30-release:1.36
	cygwin-1_7_29-release:1.36
	cygwin-1_7_29-release-branchpoint:1.36.0.2
	cygwin-1_7_28-release:1.36
	cygwin-1_7_27-release:1.36
	cygwin-1_7_26-release:1.36
	cygwin-1_7_25-release:1.36
	cygwin-1_7_24-release:1.36
	cygwin-1_7_23-release:1.36
	cygwin-1_7_22-release:1.36
	cygwin-1_7_21-release:1.36
	cygwin-1_7_20-release:1.36
	cygwin-1_7_19-release:1.36
	cygwin-64bit-postmerge:1.36
	cygwin-64bit-premerge-branch:1.35.0.4
	cygwin-64bit-premerge:1.35
	cygwin-1_7_18-release:1.35
	cygwin-1_7_17-release:1.35
	cygwin-64bit-branch:1.35.0.2
	cygwin-1_7_16-release:1.35
	cygwin-1_7_15-release:1.34
	cygwin-1_7_14_2-release:1.34
	cygwin-1_7_14-release:1.34
	cygwin-1_7_12-release:1.34
	cygwin-1_7_11-release:1.34
	cygwin-1_7_10-release:1.34
	cygwin-1_7_9-release:1.31
	cygwin-1_7_8-release:1.31
	cygwin-1_7_7-release:1.30
	cygwin-1_7_5-release:1.29
	cygwin-1_7_4-release:1.29
	cygwin-1_7_3-release:1.29
	cygwin-1_7_2-release:1.29
	cygwin-1_7_1-release:1.27
	cv-branch-2:1.27.0.2
	cr-0x5f1:1.20.0.4
	cv-branch:1.20.0.2
	cr-0x3b58:1.18.0.2
	cr-0x9e:1.14.0.10
	cr-0x9d:1.14.0.8
	corinna-01:1.14
	cr-0x9c:1.14.0.4
	cr-0x9b:1.14.0.6
	cr-0x99:1.14
	Z-emcb-cygwin_daemon:1.14.0.2
	w32api-2_2:1.12
	mingw-runtime-2_4:1.12
	cygnus_cvs_20020108_pre:1.8
	Z-cygwin_daemon_merge-new_HEAD:1.8
	Z-cygwin_daemon_merge_HEAD:1.8
	cygwin_daemon:1.8.0.4;
locks; strict;
comment	@// @;
expand	@o@;


1.37
date	2015.02.03.15.14.57;	author corinna;	state Exp;
branches;
next	1.36;

1.36
date	2013.04.23.09.44.36;	author corinna;	state Exp;
branches;
next	1.35;

1.35
date	2012.07.06.14.52.33;	author corinna;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2011.12.17.23.39.47;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2011.10.10.14.57.47;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2011.03.30.08.22.59;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2010.10.31.01.41.19;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2010.08.28.11.22.37;	author corinna;	state Exp;
branches;
next	1.29;

1.29
date	2010.03.24.19.52.00;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2009.12.16.14.02.57;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2008.09.12.22.43.10;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2008.03.12.12.47.09;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2007.12.07.09.37.46;	author corinna;	state Exp;
branches;
next	1.24;

1.24
date	2006.10.21.17.19.29;	author corinna;	state Exp;
branches;
next	1.23;

1.23
date	2006.10.19.09.08.44;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2006.10.16.19.34.27;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2006.10.16.18.00.06;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.03.09.43.35;	author corinna;	state Exp;
branches
	1.20.4.1;
next	1.19;

1.19
date	2006.02.15.10.57.17;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2005.09.08.09.24.41;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2005.02.27.17.55.54;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.27.06.10.58;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2004.10.25.15.49.36;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.15.08.58.54;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.26.21.52.03;	author joshuadfranklin;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.15.19.24.36;	author joshuadfranklin;	state Exp;
branches;
next	1.11;

1.11
date	2002.08.13.15.37.32;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.07.11.12.16;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.03.02.57.55;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.15.11.27.23;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.28.02.46.11;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.27.17.38.40;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.10.22.34.02;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.10.15.22.40;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.10.14.20.16;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.19.22.02.23;	author corinna;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.35.2.1
date	2013.02.13.15.06.58;	author corinna;	state Exp;
branches;
next	;

1.20.4.1
date	2007.12.07.09.40.33;	author corinna;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.37
log
@	* regtool.cc (longopts): Add --force option.
	(opts): Add -f option.
	(restore_flags): New variable.
	(usage): Clarify working of save action.  Add restore action.  Add
	description for -f/--force option.
	(set_privilege): Drop function.  The Cygwin DLL is doing that anyway.
	(cmd_save): Drop call to set_privilege.
	(cmd_restore): New function.
	(main): Handle -f/--force option.
@
text
@/* regtool.cc

   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
   2009, 2010, 2011, 2015 Red Hat Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <ctype.h>
#include <wchar.h>
#include <getopt.h>
#include <locale.h>
#define WINVER 0x0502
#include <windows.h>
#include <sys/cygwin.h>
#include <cygwin/version.h>
#include "loadlib.h"

#define DEFAULT_KEY_SEPARATOR '\\'

#define REG_AUTO -1

int value_type = REG_AUTO;

char key_sep = DEFAULT_KEY_SEPARATOR;

#define LIST_KEYS	0x01
#define LIST_VALS	0x02
#define LIST_ALL	(LIST_KEYS | LIST_VALS)

static char *prog_name;

static struct option longopts[] =
{
  {"binary", no_argument, NULL, 'b' },
  {"dword", no_argument, NULL, 'd' },
  {"dword-be", no_argument, NULL, 'D' },
  {"expand-string", no_argument, NULL, 'e' },
  {"force", no_argument, NULL, 'f' },
  {"help", no_argument, NULL, 'h' },
  {"integer", no_argument, NULL, 'i' },
  {"keys", no_argument, NULL, 'k'},
  {"list", no_argument, NULL, 'l'},
  {"multi-string", no_argument, NULL, 'm'},
  {"none", no_argument, NULL, 'n' },
  {"postfix", no_argument, NULL, 'p'},
  {"quiet", no_argument, NULL, 'q'},
  {"qword", no_argument, NULL, 'Q' },
  {"string", no_argument, NULL, 's'},
  {"verbose", no_argument, NULL, 'v'},
  {"version", no_argument, NULL, 'V'},
  {"wow64", no_argument, NULL, 'w'},
  {"wow32", no_argument, NULL, 'W'},
  {"hex", no_argument, NULL, 'x'},
  {"key-separator", required_argument, NULL, 'K'},
  {NULL, 0, NULL, 0}
};

static char opts[] = "bdDefhiklmnpqQsvVwWxK:";

const char *types[] =
{
  "REG_NONE",
  "REG_SZ",
  "REG_EXPAND_SZ",
  "REG_BINARY",
  "REG_DWORD",
  "REG_DWORD_BIG_ENDIAN",
  "REG_LINK",
  "REG_MULTI_SZ",
  "REG_RESOURCE_LIST",
  "REG_FULL_RESOURCE_DESCRIPTOR",
  "REG_RESOURCE_REQUIREMENTS_LIST",
  "REG_QWORD",
};

int listwhat = 0;
int postfix = 0;
int verbose = 0;
int quiet = 0;
int hex = 0;
DWORD wow64 = 0;
DWORD restore_flags = 0;
char **argv;

HKEY key;
wchar_t *value;

static void
usage (FILE *where = stderr)
{
  fprintf (where, ""
  "Usage: %s [OPTION] ACTION KEY [data...]\n"
  "\n"
  "View or edit the Win32 registry\n"
  "\n", prog_name);
  if (where == stdout)
    {
      fprintf (where, ""
      "Actions:\n"
      "\n"
      " add KEY\\SUBKEY             add new SUBKEY\n"
      " check KEY                  exit 0 if KEY exists, 1 if not\n"
      " get KEY\\VALUE              prints VALUE to stdout\n"
      " list KEY                   list SUBKEYs and VALUEs\n"
      " remove KEY                 remove KEY\n"
      " set KEY\\VALUE [data ...]   set VALUE\n"
      " unset KEY\\VALUE            removes VALUE from KEY\n"
      " load KEY\\SUBKEY PATH       load hive from PATH into new SUBKEY\n"
      " unload KEY\\SUBKEY          unload hive and remove SUBKEY\n"
      " save KEY\\SUBKEY PATH       save SUBKEY into new file PATH\n"
      " restore KEY\\SUBKEY PATH    restore SUBKEY from file PATH\n"
      "\n");
      fprintf (where, ""
      "Options for 'list' action:\n"
      "\n"
      " -k, --keys           print only KEYs\n"
      " -l, --list           print only VALUEs\n"
      " -p, --postfix        like ls -p, appends '\\' postfix to KEY names\n"
      "\n"
      "Options for 'get' action:\n"
      "\n"
      " -b, --binary         print data as printable hex bytes\n"
      " -n, --none           print data as stream of bytes as stored in registry\n"
      " -x, --hex            print numerical data as hex numbers\n"
      "\n"
      "Options for 'set' action:\n"
      "\n"
      " -b, --binary         set type to REG_BINARY (hex args or '-')\n"
      " -d, --dword          set type to REG_DWORD\n"
      " -D, --dword-be       set type to REG_DWORD_BIG_ENDIAN\n"
      " -e, --expand-string  set type to REG_EXPAND_SZ\n"
      " -i, --integer        set type to REG_DWORD\n"
      " -m, --multi-string   set type to REG_MULTI_SZ\n"
      " -n, --none           set type to REG_NONE\n"
      " -Q, --qword          set type to REG_QWORD\n"
      " -s, --string         set type to REG_SZ\n"
      "\n"
      "Options for 'set' and 'unset' Actions:\n"
      "\n"
      " -K<c>, --key-separator[=]<c>  set key-value separator to <c> instead of '\\'\n"
      "\n"
      "Options for 'restore' action:\n"
      "\n"
      " -f, --force    restore even if open handles exist at or beneath the location\n"
      "                in the registry hierarchy to which KEY\\SUBKEY points\n"
      "\n"
      "Other Options:\n"
      "\n"
      " -h, --help     output usage information and exit\n"
      " -q, --quiet    no error output, just nonzero return if KEY/VALUE missing\n"
      " -v, --verbose  verbose output, including VALUE contents when applicable\n"
      " -w, --wow64    access 64 bit registry view (ignored on 32 bit Windows)\n"
      " -W, --wow32    access 32 bit registry view (ignored on 32 bit Windows)\n"
      " -V, --version  output version information and exit\n"
      "\n");
      fprintf (where, ""
      "KEY is in the format [host]\\prefix\\KEY\\KEY\\VALUE, where host is optional\n"
      "remote host in either \\\\hostname or hostname: format and prefix is any of:\n"
      "  root     HKCR  HKEY_CLASSES_ROOT (local only)\n"
      "  config   HKCC  HKEY_CURRENT_CONFIG (local only)\n"
      "  user     HKCU  HKEY_CURRENT_USER (local only)\n"
      "  machine  HKLM  HKEY_LOCAL_MACHINE\n"
      "  users    HKU   HKEY_USERS\n"
      "\n"
      "If the keyname starts with a forward slash ('/'), the forward slash is used\n"
      "as separator and the backslash can be used as escape character.\n");
      fprintf (where, ""
      "Example:\n"
      "%s list '/machine/SOFTWARE/Classes/MIME/Database/Content Type/audio\\/wav'\n\n", prog_name);
    }
  if (where == stderr)
    fprintf (where,
    "ACTION is one of add, check, get, list, remove, set, unset, load, unload, save\n"
    "\n"
    "Try `%s --help' for more information.\n", prog_name);
  exit (where == stderr ? 1 : 0);
}

static void
print_version ()
{
  printf ("regtool (cygwin) %d.%d.%d\n"
	  "Registry tool\n"
	  "Copyright (C) 2000 - %s Red Hat, Inc.\n"
	  "This is free software; see the source for copying conditions.  There is NO\n"
	  "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n",
	  CYGWIN_VERSION_DLL_MAJOR / 1000,
	  CYGWIN_VERSION_DLL_MAJOR % 1000,
	  CYGWIN_VERSION_DLL_MINOR,
	  strrchr (__DATE__, ' ') + 1);
}

void
Fail (unsigned int rv)
{
  char *buf;
  if (!quiet)
    {
      FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER
		     | FORMAT_MESSAGE_FROM_SYSTEM,
		     0, rv, 0, (CHAR *) & buf, 0, 0);
      fprintf (stderr, "Error (%d): %s\n", rv, buf);
      LocalFree (buf);
    }
  exit (1);
}

static struct
{
  const char *string;
  HKEY key;
} wkprefixes[] =
{
  {"root", HKEY_CLASSES_ROOT},
  {"HKCR", HKEY_CLASSES_ROOT},
  {"HKEY_CLASSES_ROOT", HKEY_CLASSES_ROOT},
  {"config", HKEY_CURRENT_CONFIG},
  {"HKCC", HKEY_CURRENT_CONFIG},
  {"HKEY_CURRENT_CONFIG", HKEY_CURRENT_CONFIG},
  {"user", HKEY_CURRENT_USER},
  {"HKCU", HKEY_CURRENT_USER},
  {"HKEY_CURRENT_USER", HKEY_CURRENT_USER},
  {"machine", HKEY_LOCAL_MACHINE},
  {"HKLM", HKEY_LOCAL_MACHINE},
  {"HKEY_LOCAL_MACHINE", HKEY_LOCAL_MACHINE},
  {"users", HKEY_USERS},
  {"HKU", HKEY_USERS},
  {"HKEY_USERS", HKEY_USERS},
  {0, 0}
};

void
translate (char *key)
{
#define isodigit(c) (strchr("01234567", c))
#define tooct(c)    ((c)-'0')
#define tohex(c)    (strchr(_hs,tolower(c))-_hs)
  static char _hs[] = "0123456789abcdef";

  char *d = key;
  char *s = key;
  char c;

  while (*s)
    {
      if (*s == '\\')
	switch (*++s)
	  {
	  case 'a':
	    *d++ = '\007';
	    break;
	  case 'b':
	    *d++ = '\b';
	    break;
	  case 'e':
	    *d++ = '\033';
	    break;
	  case 'f':
	    *d++ = '\f';
	    break;
	  case 'n':
	    *d++ = '\n';
	    break;
	  case 'r':
	    *d++ = '\r';
	    break;
	  case 't':
	    *d++ = '\t';
	    break;
	  case 'v':
	    *d++ = '\v';
	    break;
	  case '0':
	  case '1':
	  case '2':
	  case '3':
	  case '4':
	  case '5':
	  case '6':
	  case '7':
	    c = tooct (*s);
	    if (isodigit (s[1]))
	      {
		c = (c << 3) | tooct (*++s);
		if (isodigit (s[1]))
		  c = (c << 3) | tooct (*++s);
	      }
	    *d++ = c;
	    break;
	  case 'x':
	    if (!isxdigit (s[1]))
	      c = '0';
	    else
	      {
		c = tohex (*++s);
		if (isxdigit (s[1]))
		  c = (c << 4) | tohex (*++s);
	      }
	    *d++ = c;
	    break;
	  default:		/* before non-special char: just add the char */
	    *d++ = *s;
	    break;
	  }
      else if (*s == '/')
	*d++ = '\\';
      else
	*d++ = *s;
      ++s;
    }
  *d = '\0';
}

void
find_key (int howmanyparts, REGSAM access, int option = 0)
{
  HKEY base;
  int rv;
  char *n = argv[0], *e, *h, c;
  char* host = NULL;
  int i;
  size_t len;

  if (*n == '/')
    translate (n);
  if (*n != '\\')
    {
      /* expect host:/key/value format */
      host = (char*) malloc (strlen (n) + 1);
      host[0] = host [1] = '\\';
      for (e = n, h = host + 2; *e && *e != ':'; e++, h++)
	*h = *e;
      *h = 0;
      n = e + 1;
      if (*n == '/')
	translate (n);
    }
  else if (n[0] == '\\' && n[1] == '\\')
    {
      /* expect //host/key/value format */
      host = (char*) malloc (strlen (n) + 1);
      host[0] = host[1] = '\\';
      for (e = n + 2, h = host + 2; *e && *e != '\\'; e++, h++)
	*h = *e;
      *h = 0;
      n = e;
    }
  while (*n != '\\')
    n++;
  *n++ = 0;
  for (e = n; *e && *e != '\\'; e++);
  c = *e;
  *e = 0;
  for (i = 0; wkprefixes[i].string; i++)
    if (strcmp (wkprefixes[i].string, n) == 0)
      break;
  if (!wkprefixes[i].string)
    {
      fprintf (stderr, "Unknown key prefix.  Valid prefixes are:\n");
      for (i = 0; wkprefixes[i].string; i++)
	fprintf (stderr, "\t%s\n", wkprefixes[i].string);
      exit (1);
    }

  n = e;
  *e = c;
  while (*n && *n == '\\')
    n++;
  e = n + strlen (n);
  if (howmanyparts > 1)
    {
      while (n < e && *e != key_sep)
	e--;
      if (*e != key_sep)
	{
	  key = wkprefixes[i].key;
	  if (value)
	    free (value);
	  len = mbstowcs (NULL, n, 0) + 1;
	  value = (wchar_t *) malloc (len * sizeof (wchar_t));
	  mbstowcs (value, n, len);
	  return;
	}
      else
	{
	  *e = 0;
	  if (value)
	    free (value);
	  len = mbstowcs (NULL, e + 1, 0) + 1;
	  value = (wchar_t *) malloc (len * sizeof (wchar_t));
	  mbstowcs (value, e + 1, len);
	}
    }
  if (host)
    {
      rv = RegConnectRegistry (host, wkprefixes[i].key, &base);
      if (rv != ERROR_SUCCESS)
	Fail (rv);
      free (host);
    }
  else
    base = wkprefixes[i].key;

  if (n[0] == 0)
    key = base;
  else
    {
      len = mbstowcs (NULL, n, 0) + 1;
      wchar_t name[len];
      mbstowcs (name, n, len);
      if (access)
	{
	  rv = RegOpenKeyExW (base, name, 0, access | wow64, &key);
	  if (option && (rv == ERROR_SUCCESS || rv == ERROR_ACCESS_DENIED))
	    {
	      /* reopen with desired option due to missing option support in
		 RegOpenKeyE */
	      /* FIXME: may create the key in rare cases (e.g. access denied
		 in parent) */
	      HKEY key2;
	      if (RegCreateKeyExW (base, name, 0, NULL, option, access | wow64,
				  NULL, &key2, NULL)
		  == ERROR_SUCCESS)
		{
		  if (rv == ERROR_SUCCESS)
		    RegCloseKey (key);
		  key = key2;
		  rv = ERROR_SUCCESS;
		}
	    }
	  if (rv != ERROR_SUCCESS)
	    Fail (rv);
	}
      else if (argv[1])
	{
	  ssize_t len = cygwin_conv_path (CCP_POSIX_TO_WIN_W, argv[1], NULL, 0);
	  wchar_t win32_path[len];
	  cygwin_conv_path (CCP_POSIX_TO_WIN_W, argv[1], win32_path, len);
	  rv = RegLoadKeyW (base, name, win32_path);
	  if (rv != ERROR_SUCCESS)
	    Fail (rv);
	  if (verbose)
	    printf ("key %ls loaded from file %ls\n", name, win32_path);
	}
      else
	{
	  rv = RegUnLoadKeyW (base, name);
	  if (rv != ERROR_SUCCESS)
	    Fail (rv);
	  if (verbose)
	    printf ("key %ls unloaded\n", name);
	}
    }
}


int
cmd_list ()
{
  DWORD num_subkeys, maxsubkeylen, num_values, maxvalnamelen, maxvaluelen;
  DWORD maxclasslen;
  wchar_t *subkey_name, *value_name, *class_name, *vd;
  unsigned char *value_data;
  DWORD i, j, m, n, t;
  int v;

  find_key (1, KEY_READ);
  RegQueryInfoKeyW (key, 0, 0, 0, &num_subkeys, &maxsubkeylen, &maxclasslen,
		    &num_values, &maxvalnamelen, &maxvaluelen, 0, 0);

  subkey_name = (wchar_t *) malloc ((maxsubkeylen + 1) * sizeof (wchar_t));
  class_name = (wchar_t *) malloc ((maxclasslen + 1) * sizeof (wchar_t));
  value_name = (wchar_t *) malloc ((maxvalnamelen + 1) * sizeof (wchar_t));
  value_data = (unsigned char *) malloc (maxvaluelen + 1);

  if (!listwhat)
    listwhat = LIST_ALL;

  if (listwhat & LIST_KEYS)
    for (i = 0; i < num_subkeys; i++)
      {
	m = (maxsubkeylen + 1) * sizeof (wchar_t);
	n = (maxclasslen + 1) * sizeof (wchar_t);
	RegEnumKeyExW (key, i, subkey_name, &m, 0, class_name, &n, 0);
	printf ("%ls", subkey_name);
	if (postfix || verbose)
	  fputc (key_sep, stdout);

	if (verbose)
	  printf (" (%ls)", class_name);

	puts ("");
      }

  if (listwhat & LIST_VALS)
    for (i = 0; i < num_values; i++)
      {
	m = (maxvalnamelen + 1) * sizeof (wchar_t);
	n = maxvaluelen + 1;
	RegEnumValueW (key, i, value_name, &m, 0, &t, (BYTE *) value_data, &n);
	value_data[n] = 0;
	if (!verbose)
	  printf ("%ls\n", value_name);
	else
	  {
	    printf ("%ls (%s) = ", value_name, types[t]);
	    switch (t)
	      {
	      case REG_NONE:
	      case REG_BINARY:
		for (j = 0; j < 8 && j < n; j++)
		  printf ("%02x ", value_data[j]);
		printf ("\n");
		break;
	      case REG_DWORD:
		printf ("0x%08x (%u)\n", *(unsigned int *) value_data,
			*(unsigned int *) value_data);
		break;
	      case REG_DWORD_BIG_ENDIAN:
		v = ((value_data[0] << 24)
		     | (value_data[1] << 16)
		     | (value_data[2] << 8)
		     | (value_data[3]));
		printf ("0x%08x (%d)\n", v, v);
		break;
	      case REG_QWORD:
		printf ("0x%016llx (%llu)\n",
			*(unsigned long long *) value_data,
			*(unsigned long long *) value_data);
		break;
	      case REG_EXPAND_SZ:
	      case REG_SZ:
	      case REG_LINK:
		printf ("\"%ls\"\n", (wchar_t *) value_data);
		break;
	      case REG_MULTI_SZ:
		vd = (wchar_t *) value_data;
		while (vd && *vd)
		  {
		    printf ("\"%ls\"", vd);
		    vd = vd + wcslen (vd) + 1;
		    if (*vd)
		      printf (", ");
		  }
		printf ("\n");
		break;
	      default:
		printf ("?\n");
		break;
	      }
	  }
      }
  return 0;
}

int
cmd_add ()
{
  find_key (2, KEY_ALL_ACCESS);
  HKEY newkey;
  DWORD newtype;
  int rv = RegCreateKeyExW (key, value, 0, NULL, REG_OPTION_NON_VOLATILE,
			    KEY_ALL_ACCESS | wow64, 0, &newkey, &newtype);
  if (rv != ERROR_SUCCESS)
    Fail (rv);

  if (verbose)
    {
      if (newtype == REG_OPENED_EXISTING_KEY)
	printf ("Key %ls already exists\n", value);
      else
	printf ("Key %ls created\n", value);
    }
  return 0;
}

extern "C" {
  LONG WINAPI (*regDeleteKeyEx)(HKEY, LPCWSTR, REGSAM, DWORD);
}

int
cmd_remove ()
{
  DWORD rv;

  find_key (2, KEY_ALL_ACCESS);
  if (wow64)
    {
      HMODULE mod = LoadLibrary ("advapi32.dll");
      if (mod)
	regDeleteKeyEx = (LONG WINAPI (*)(HKEY, LPCWSTR, REGSAM, DWORD)) GetProcAddress (mod, "RegDeleteKeyExW");
    }
  if (regDeleteKeyEx)
    rv = (*regDeleteKeyEx) (key, value, wow64, 0);
  else
    rv = RegDeleteKeyW (key, value);
  if (rv != ERROR_SUCCESS)
    Fail (rv);
  if (verbose)
    printf ("subkey %ls deleted\n", value);
  return 0;
}

int
cmd_check ()
{
  find_key (1, KEY_READ);
  if (verbose)
    printf ("key %s exists\n", argv[0]);
  return 0;
}

int
cmd_set ()
{
  int i, n, max_n;
  DWORD v, rv;
  unsigned long long llval;
  char *a = argv[1], *data = 0;
  find_key (2, KEY_ALL_ACCESS);

  if (!a)
    usage ();
  if (value_type == REG_AUTO)
    {
      char *e;
      llval = strtoull (a, &e, 0);
      if (a[0] == '%')
	value_type = REG_EXPAND_SZ;
      else if (a[0] && !*e)
	value_type = llval > 0xffffffffULL ? REG_QWORD : REG_DWORD;
      else if (argv[2])
	value_type = REG_MULTI_SZ;
      else
	value_type = REG_SZ;
    }

  switch (value_type)
    {
    case REG_NONE:
    case REG_BINARY:
      for (n = 0; argv[n+1]; n++)
	;
      if (n == 1 && strcmp (argv[1], "-") == 0)
	{ /* read from stdin */
	  i = n = 0;
	  for (;;)
	    {
	      if (i <= n)
		{
		  i = n + BUFSIZ;
		  data = (char *) realloc (data, i);
		}
	      int r = fread (data+n, 1, i-n, stdin);
	      if (r <= 0)
		break;
	      n += r;
	    }
	}
      else if (n > 0)
	{ /* parse hex from argv */
	  data = (char *) malloc (n);
	  for (i = 0; i < n; i++)
	    {
	      char *e;
	      errno = 0;
	      v = strtoul (argv[i+1], &e, 16);
	      if (errno || v > 0xff || *e)
		{
		  fprintf (stderr, "Invalid hex constant `%s'\n", argv[i+1]);
		  exit (1);
		}
	      data[i] = (char) v;
	    }
	}
      rv = RegSetValueExW (key, value, 0, value_type, (const BYTE *) data, n);
      break;
    case REG_DWORD:
      v = strtoul (a, 0, 0);
      rv = RegSetValueExW (key, value, 0, REG_DWORD, (const BYTE *) &v,
			  sizeof (v));
      break;
    case REG_DWORD_BIG_ENDIAN:
      v = strtoul (a, 0, 0);
      v = (((v & 0xff) << 24)
	   | ((v & 0xff00) << 8)
	   | ((v & 0xff0000) >> 8)
	   | ((v & 0xff000000) >> 24));
      rv = RegSetValueExW (key, value, 0, REG_DWORD_BIG_ENDIAN,
			  (const BYTE *) &v, sizeof (v));
      break;
    case REG_QWORD:
      llval = strtoul (a, 0, 0);
      rv = RegSetValueExW (key, value, 0, REG_QWORD, (const BYTE *) &llval,
			  sizeof (llval));
      break;
    case REG_SZ:
    case REG_EXPAND_SZ:
      {
	n = mbstowcs (NULL, a, 0);
	wchar_t w[n + 1];
	mbstowcs (w, a, n + 1);
	rv = RegSetValueExW (key, value, 0, value_type,
			     (const BYTE *) w, (n + 1) * sizeof (wchar_t));
      }
      break;
    case REG_MULTI_SZ:
      for (i = 1, max_n = 1; argv[i]; i++)
	max_n += mbstowcs (NULL, argv[i], 0) + 1;
      data = (char *) malloc (max_n * sizeof (wchar_t));
      for (i = 1, n = 0; argv[i]; i++)
	n += mbstowcs ((wchar_t *) data + n, argv[i], max_n - n) + 1;
      ((wchar_t *)data)[n] = L'\0';
      rv = RegSetValueExW (key, value, 0, REG_MULTI_SZ, (const BYTE *) data,
			   (n + 1) * sizeof (wchar_t));
      break;
    case REG_AUTO:
      rv = ERROR_SUCCESS;
      break;
    default:
      rv = ERROR_INVALID_CATEGORY;
      break;
    }

  if (data)
    free(data);

  if (rv != ERROR_SUCCESS)
    Fail (rv);

  return 0;
}

int
cmd_unset ()
{
  find_key (2, KEY_ALL_ACCESS);
  DWORD rv = RegDeleteValueW (key, value);
  if (rv != ERROR_SUCCESS)
    Fail (rv);
  if (verbose)
    printf ("value %ls deleted\n", value);
  return 0;
}

int
cmd_get ()
{
  find_key (2, KEY_READ);
  DWORD vtype, dsize, rv;
  PBYTE data;
  wchar_t *vd;

  rv = RegQueryValueExW (key, value, 0, &vtype, 0, &dsize);
  if (rv != ERROR_SUCCESS)
    Fail (rv);
  data = (PBYTE) malloc (dsize + 1);
  rv = RegQueryValueExW (key, value, 0, &vtype, data, &dsize);
  if (rv != ERROR_SUCCESS)
    Fail (rv);
  if (value_type == REG_BINARY)
    {
      for (unsigned i = 0; i < dsize; i++)
	printf ("%02x%c", (unsigned char)data[i],
	  (i < dsize-1 ? ' ' : '\n'));
    }
  else if (value_type == REG_NONE)
    fwrite (data, dsize, 1, stdout);
  else
    switch (vtype)
      {
      case REG_NONE:
      case REG_BINARY:
	fwrite (data, dsize, 1, stdout);
	break;
      case REG_DWORD:
	printf (hex ? "0x%08x\n" : "%u\n", *(unsigned int *) data);
	break;
      case REG_DWORD_BIG_ENDIAN:
	rv = ((data[0] << 24)
	      | (data[1] << 16)
	      | (data[2] << 8)
	      | (data[3]));
	printf (hex ? "0x%08x\n" : "%u\n", (unsigned int) rv);
	break;
      case REG_QWORD:
	printf (hex ? "0x%016llx\n" : "%llu\n", *(unsigned long long *) data);
	break;
      case REG_SZ:
      case REG_LINK:
	printf ("%ls\n", (wchar_t *) data);
	break;
      case REG_EXPAND_SZ:
	if (value_type == REG_EXPAND_SZ)	// hack
	  {
	    wchar_t *buf;
	    DWORD bufsize;
	    bufsize = ExpandEnvironmentStringsW ((wchar_t *) data, 0, 0);
	    buf = (wchar_t *) malloc (bufsize + 1);
	    ExpandEnvironmentStringsW ((wchar_t *) data, buf, bufsize + 1);
	    free (data);
	    data = (PBYTE) buf;
	  }
	printf ("%ls\n", (wchar_t *) data);
	break;
      case REG_MULTI_SZ:
	vd = (wchar_t *) data;
	while (vd && *vd)
	  {
	    printf ("%ls\n", vd);
	    vd = vd + wcslen (vd) + 1;
	  }
	break;
      }
  return 0;
}

int
cmd_load ()
{
  if (!argv[1])
    {
      usage ();
      return 1;
    }
  find_key (1, 0);
  return 0;
}

int
cmd_unload ()
{
  if (argv[1])
    {
      usage ();
      return 1;
    }
  find_key (1, 0);
  return 0;
}

int
cmd_save ()
{
  if (!argv[1])
    {
      usage ();
      return 1;
    }
  /* REG_OPTION_BACKUP_RESTORE is necessary to save /HKLM/SECURITY */
  find_key (1, KEY_QUERY_VALUE, REG_OPTION_BACKUP_RESTORE);
  ssize_t len = cygwin_conv_path (CCP_POSIX_TO_WIN_W, argv[1], NULL, 0);
  wchar_t win32_path[len];
  cygwin_conv_path (CCP_POSIX_TO_WIN_W, argv[1], win32_path, len);
  DWORD rv = RegSaveKeyW (key, win32_path, NULL);
  if (rv != ERROR_SUCCESS)
    Fail (rv);
  if (verbose)
    printf ("key saved to %ls\n", win32_path);
  return 0;
}

int
cmd_restore ()
{
  if (!argv[1])
    {
      usage ();
      return 1;
    }
  /* REG_OPTION_BACKUP_RESTORE is necessary to restore /HKLM/SECURITY */
  find_key (1, KEY_ALL_ACCESS, REG_OPTION_BACKUP_RESTORE);
  ssize_t len = cygwin_conv_path (CCP_POSIX_TO_WIN_W, argv[1], NULL, 0);
  wchar_t win32_path[len];
  cygwin_conv_path (CCP_POSIX_TO_WIN_W, argv[1], win32_path, len);
  DWORD rv = RegRestoreKeyW (key, win32_path, restore_flags);
  if (rv != ERROR_SUCCESS)
    Fail (rv);
  if (verbose)
    printf ("key saved to %ls\n", win32_path);
  return 0;
}

static struct
{
  const char *name;
  int (*func) ();
} commands[] =
{
  {"list", cmd_list},
  {"add", cmd_add},
  {"remove", cmd_remove},
  {"check", cmd_check},
  {"set", cmd_set},
  {"unset", cmd_unset},
  {"get", cmd_get},
  {"load", cmd_load},
  {"unload", cmd_unload},
  {"save", cmd_save},
  {"restore", cmd_restore},
  {0, 0}
};

int
main (int argc, char **_argv)
{
  int g;

  setlocale (LC_ALL, "");

  prog_name = program_invocation_short_name;

  while ((g = getopt_long (argc, _argv, opts, longopts, NULL)) != EOF)
    switch (g)
	{
	case 'b':
	  value_type = REG_BINARY;
	  break;
	case 'd':
	  value_type = REG_DWORD;
	  break;
	case 'D':
	  value_type = REG_DWORD_BIG_ENDIAN;
	  break;
	case 'e':
	  value_type = REG_EXPAND_SZ;
	  break;
	case 'f':
	  restore_flags = REG_FORCE_RESTORE;
	  break;
	case 'k':
	  listwhat |= LIST_KEYS;
	  break;
	case 'h':
	  usage (stdout);
	case 'i':
	  value_type = REG_DWORD;
	  break;
	case 'l':
	  listwhat |= LIST_VALS;
	  break;
	case 'm':
	  value_type = REG_MULTI_SZ;
	  break;
	case 'n':
	  value_type = REG_NONE;
	  break;
	case 'p':
	  postfix++;
	  break;
	case 'q':
	  quiet++;
	  break;
	case 'Q':
	  value_type = REG_QWORD;
	  break;
	case 's':
	  value_type = REG_SZ;
	  break;
	case 'v':
	  verbose++;
	  break;
	case 'V':
	  print_version ();
	  exit (0);
	case 'w':
	  wow64 = KEY_WOW64_64KEY;
	  break;
	case 'W':
	  wow64 = KEY_WOW64_32KEY;
	  break;
	case 'x':
	  hex++;
	  break;
	case 'K':
	  key_sep = *optarg;
	  break;
	default :
	  fprintf (stderr, "Try `%s --help' for more information.\n",
		   prog_name);
	  return 1;
	}

  if ((_argv[optind] == NULL) || (_argv[optind+1] == NULL))
    usage ();

  argv = _argv + optind;
  int i;
  for (i = 0; commands[i].name; i++)
    if (strcmp (commands[i].name, argv[0]) == 0)
      {
	argv++;
	return commands[i].func ();
      }
  usage ();

  return 0;
}
@


1.36
log
@	* Merge in cygwin-64bit-branch.
@
text
@d4 1
a4 1
   2009, 2010, 2011 Red Hat Inc.
d45 1
d65 1
a65 1
static char opts[] = "bdDehiklmnpqQsvVwWxK:";
d89 1
d117 2
a118 1
      " save KEY\\SUBKEY PATH       save SUBKEY into new hive PATH\n"
d121 1
a121 1
      "Options for 'list' Action:\n"
d127 1
a127 1
      "Options for 'get' Action:\n"
d133 1
a133 1
      "Options for 'set' Action:\n"
d149 5
a848 19
DWORD
set_privilege (const char *name)
{
  TOKEN_PRIVILEGES tp;
  if (!LookupPrivilegeValue (NULL, name, &tp.Privileges[0].Luid))
    return GetLastError ();
  tp.PrivilegeCount = 1;
  tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
  HANDLE t;
  /* OpenProcessToken does not work here, because main thread has its own
     impersonation token */
  if (!OpenThreadToken (GetCurrentThread (), TOKEN_ADJUST_PRIVILEGES, FALSE, &t))
    return GetLastError ();
  AdjustTokenPrivileges (t, FALSE, &tp, 0, NULL, NULL);
  DWORD rv = GetLastError ();
  CloseHandle (t);
  return rv;
}

a856 2
  /* try to set SeBackupPrivilege, let RegSaveKey report the error */
  set_privilege (SE_BACKUP_NAME);
d870 21
d907 1
d935 3
@


1.35
log
@	* cygpath.cc: Change including headers to allow building against
	Mingw64 headers. Include ntdef.h and ntdll.h rather than ddk headers.
	Define _WIN32_WINNT and WINVER as 0x0602.
	(RtlEqualUnicodePathPrefix): Drop definition.  Pulled in from ntdll.h
	now.
	(get_device_name): s/Zw/Nt.
	* dumper.cc: Include sys/param.h
	(dumper::dump_memory_region): Use MIN rather than min.
	* locale.cc: Include stdlib.h.  Define _WIN32_WINNT and WINVER as
	0x0602.
	* ps.cc: Include ntdef.h and ntdll.h rather than ddk headers.
	* regtool.cc (regDeleteKeyEx): Drop WINADVAPI qualifier.
@
text
@d193 1
a193 1
Fail (DWORD rv)
d201 1
a201 1
      fprintf (stderr, "Error (%ld): %s\n", rv, buf);
d515 2
a516 2
		printf ("0x%08lx (%lu)\n", *(DWORD *) value_data,
			*(DWORD *) value_data);
d776 1
a776 1
	printf (hex ? "0x%08lx\n" : "%lu\n", *(DWORD *) data);
d783 1
a783 1
	printf (hex ? "0x%08lx\n" : "%lu\n", rv);
@


1.35.2.1
log
@	* kill.cc (forcekill): Use unsigned int printf format specifier and
	cast to avoid compiler warnings where DWORD value is used.
	* regtool.cc: Ditto, throughout.
@
text
@d193 1
a193 1
Fail (unsigned int rv)
d201 1
a201 1
      fprintf (stderr, "Error (%d): %s\n", rv, buf);
d515 2
a516 2
		printf ("0x%08x (%u)\n", *(unsigned int *) value_data,
			*(unsigned int *) value_data);
d776 1
a776 1
	printf (hex ? "0x%08x\n" : "%u\n", *(unsigned int *) data);
d783 1
a783 1
	printf (hex ? "0x%08x\n" : "%u\n", (unsigned int) rv);
@


1.34
log
@Clean up whitespace.
@
text
@d577 1
a577 1
WINADVAPI LONG WINAPI (*regDeleteKeyEx)(HKEY, LPCWSTR, REGSAM, DWORD);
d590 1
a590 1
	regDeleteKeyEx = (WINADVAPI LONG WINAPI (*)(HKEY, LPCWSTR, REGSAM, DWORD)) GetProcAddress (mod, "RegDeleteKeyExW");
@


1.33
log
@	* Align usage output, version output, as well as usage and version
	option handling to use the same style throughout all Cygwin utils.
	Throughout use program_invocation_short_name to refer to current
	process name in Cygwin executables.
	* utils.sgml: Align documentation to above change.  Add missing
	sections for getconf, ldd, and setmetamode.
	* strace.cc (proc_child): Avoid compiler warning.
@
text
@d182 3
a184 3
          "Registry tool\n"
          "Copyright (C) 2000 - %s Red Hat, Inc.\n"
          "This is free software; see the source for copying conditions.  There is NO\n"
d186 4
a189 4
          CYGWIN_VERSION_DLL_MAJOR / 1000,
          CYGWIN_VERSION_DLL_MAJOR % 1000,
          CYGWIN_VERSION_DLL_MINOR,
          strrchr (__DATE__, ' ') + 1);
d423 1
a423 1
	        {
d428 1
a428 1
	        }
d434 1
a434 1
	{ 
d445 1
a445 1
	{ 
d590 1
a590 1
        regDeleteKeyEx = (WINADVAPI LONG WINAPI (*)(HKEY, LPCWSTR, REGSAM, DWORD)) GetProcAddress (mod, "RegDeleteKeyExW");
d642 1
a642 1
        ;
d723 1
a723 1
 
@


1.32
log
@	* regtool.cc (cmd_set): Avoid a compiler warning.
@
text
@d4 1
a4 1
   2009, 2010 Red Hat Inc.
d22 1
a36 1
static const char version[] = "$Revision: 1.8 $";
d98 1
d105 1
d119 1
d125 1
d131 1
d143 1
d147 1
d168 1
a168 1
      "%s list '/machine/SOFTWARE/Classes/MIME/Database/Content Type/audio\\/wav'\n", prog_name);
d174 1
a174 1
    "Try '%s --help' for more information.\n", prog_name);
d181 9
a189 18
  const char *v = strchr (version, ':');
  int len;
  if (!v)
    {
      v = "?";
      len = 1;
    }
  else
    {
      v += 2;
      len = strchr (v, ' ') - v;
    }
  printf ("\
%s (cygwin) %.*s\n\
Registry Tool\n\
Copyright 2000-2009 Red Hat, Inc.\n\
Compiled on %s\n\
", prog_name, len, v, __DATE__);
d908 2
a909 7
  prog_name = strrchr (_argv[0], '/');
  if (prog_name == NULL)
    prog_name = strrchr (_argv[0], '\\');
  if (prog_name == NULL)
    prog_name = _argv[0];
  else
    prog_name++;
d974 3
a976 1
	  usage ();
@


1.31
log
@* regtool.c (cmd_set): Write correct number of bytes for REG_MULTI_SZ case.
@
text
@d700 7
a706 5
      n = mbstowcs (NULL, a, 0);
      wchar_t w[n + 1];
      mbstowcs (w, a, n + 1);
      rv = RegSetValueExW (key, value, 0, value_type,
			   (const BYTE *) w, (n + 1) * sizeof (wchar_t));
@


1.30
log
@	* loadlib.h: New header implementing safe LoadLibrary calls.
	Include throughout files using LoadLibrary function.
	* cygcheck.cc (dump_sysinfo): Retrieve kernel32.dll handle via
	GetModuleHandle, rather than using LoadLibrary.
	* cygpath.cc (get_long_name): Ditto.
	(do_sysfolders): Append .dll suffix in LoadLibrary call.
	* ldh.cc (WinMain): Use LoadLibraryExW with DONT_RESOLVE_DLL_REFERENCES
	to avoid loading malicious library code.
	* locale.cc (print_locale_with_codeset): Change way to retrieve
	kernel32.dll path.
@
text
@d714 1
a714 1
			   (max_n + 1) * sizeof (wchar_t));
@


1.29
log
@	* regtool.cc (find_key): Fix allocation size of "value".
@
text
@d4 1
a4 1
   2009 Red Hat Inc.
d22 1
@


1.28
log
@	* regtool.cc: Throughout, convert all registry calls to wide char
	calls and use string conversion according to current locale.
	(longopts): Change "dword-le" to "dword-be", as was originally
	intended.
	(usage): Change usage accordingly.
	(print_version): Simplify copyright dates in output.
	(cmd_list): Handle REG_LINK like REG_SZ.
	(cmd_get): Ditto.
	(main): Call setlocale.
	* utils.sgml (regtool): Fix options and add missing descriptions for
	new features.
@
text
@d380 1
a380 1
	  value = (wchar_t *) malloc (len);
d390 1
a390 1
	  value = (wchar_t *) malloc (len);
@


1.27
log
@* cygcheck.cc (pathlike::check_existence): Remove class name from declaration.
(display_internet_error): Use proper format specifier for DWORD.
(environ): Remove unneeded declaration.
(main): Use brace around nested if to avoid an overly-helpful compiler warning.
* dump_setup.cc (parse_filename): Reorganize nested if to avoid an
overly-helpful compiler warning.
* path.cc (GUID_shortcut): Use braces around part of initializer which needs
them.
(conv_fstab_spaces): Parenthesize assignment in while loop to avoid a compiler
warning.
(struct opt): Make static.
* ps.cc (main): Reorganize nested if to avoid an overly-helpful compiler
warning.
* regtool.cc: Make some anonymous structs static to avoid a compiler warning.
* ssp.c (lookup_thread_id): Initialize *tix to zero to avoid potential
uninitialized use.
* strace.cc (add_child): Use proper format specifier for DWORD.
(remove_child): Ditto.
(proc_child): Ditto.
@
text
@d3 2
a4 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006 Red Hat Inc.
d16 1
d18 1
d42 1
a42 1
  {"dword-le", no_argument, NULL, 'D' },
d90 1
a90 1
char *value;
d128 1
a128 1
      " -D, --dword-le       set type to REG_DWORD_LITTLE_ENDIAN\n"
d188 1
a188 1
Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006 Red Hat, Inc.\n\
d322 2
d377 5
a381 1
	  value = n;
d387 5
a391 1
	  value = e + 1;
d408 3
d413 1
a413 1
	  rv = RegOpenKeyEx (base, n, 0, access | wow64, &key);
d416 4
a419 2
	      /* reopen with desired option due to missing option support in RegOpenKeyE */
	      /* FIXME: may create the key in rare cases (e.g. access denied in parent) */
d421 2
a422 1
	      if (RegCreateKeyEx (base, n, 0, NULL, option, access | wow64, NULL, &key2, NULL)
d436 4
a439 6
	  ssize_t len = cygwin_conv_path (CCP_POSIX_TO_WIN_A | CCP_RELATIVE,
					  argv[1], NULL, 0);
	  char win32_path[len];
	  cygwin_conv_path (CCP_POSIX_TO_WIN_A | CCP_RELATIVE, argv[1],
			    win32_path, len);
	  rv = RegLoadKey (base, n, win32_path);
d443 1
a443 1
	    printf ("key %s loaded from file %s\n", n, win32_path);
d447 1
a447 1
	  rv = RegUnLoadKey (base, n);
d451 1
a451 1
	    printf ("key %s unloaded\n", n);
a453 1
  //printf("key `%s' value `%s'\n", n, value);
d462 2
a463 2
  char *subkey_name, *value_name, *class_name;
  unsigned char *value_data, *vd;
d468 2
a469 2
  RegQueryInfoKey (key, 0, 0, 0, &num_subkeys, &maxsubkeylen, &maxclasslen,
		   &num_values, &maxvalnamelen, &maxvaluelen, 0, 0);
d471 3
a473 3
  subkey_name = (char *) malloc (maxsubkeylen + 1);
  class_name = (char *) malloc (maxclasslen + 1);
  value_name = (char *) malloc (maxvalnamelen + 1);
d482 4
a485 4
	m = maxsubkeylen + 1;
	n = maxclasslen + 1;
	RegEnumKeyEx (key, i, subkey_name, &m, 0, class_name, &n, 0);
	fputs (subkey_name, stdout);
d490 1
a490 1
	  printf (" (%s)", class_name);
d498 1
a498 1
	m = maxvalnamelen + 1;
d500 1
a500 1
	RegEnumValue (key, i, value_name, &m, 0, &t, (BYTE *) value_data, &n);
d503 1
a503 1
	  printf ("%s\n", value_name);
d506 1
a506 1
	    printf ("%s (%s) = ", value_name, types[t]);
a509 1
	      case REG_LINK:
d533 2
a534 1
		printf ("\"%s\"\n", value_data);
d537 1
a537 1
		vd = value_data;
d540 2
a541 2
		    printf ("\"%s\"", vd);
		    vd = vd + strlen ((const char *) vd) + 1;
d562 2
a563 2
  int rv = RegCreateKeyEx (key, value, 0, (char *) "", REG_OPTION_NON_VOLATILE,
			   KEY_ALL_ACCESS | wow64, 0, &newkey, &newtype);
d570 1
a570 1
	printf ("Key %s already exists\n", value);
d572 1
a572 1
	printf ("Key %s created\n", value);
d578 1
a578 1
WINADVAPI LONG WINAPI (*regDeleteKeyEx)(HKEY, LPCSTR, REGSAM, DWORD);
d591 1
a591 1
        regDeleteKeyEx = (WINADVAPI LONG WINAPI (*)(HKEY, LPCSTR, REGSAM, DWORD)) GetProcAddress (mod, "RegDeleteKeyExA");
d596 1
a596 1
    rv = RegDeleteKey (key, value);
d600 1
a600 1
    printf ("subkey %s deleted\n", value);
d616 1
a616 1
  int i, n;
d676 1
a676 1
      rv = RegSetValueEx (key, value, 0, value_type, (const BYTE *) data, n);
d680 1
a680 1
      rv = RegSetValueEx (key, value, 0, REG_DWORD, (const BYTE *) &v,
d689 1
a689 1
      rv = RegSetValueEx (key, value, 0, REG_DWORD_BIG_ENDIAN,
d694 1
a694 1
      rv = RegSetValueEx (key, value, 0, REG_QWORD, (const BYTE *) &llval,
a697 2
      rv = RegSetValueEx (key, value, 0, REG_SZ, (const BYTE *) a, strlen (a) + 1);
      break;
d699 5
a703 2
      rv = RegSetValueEx (key, value, 0, REG_EXPAND_SZ, (const BYTE *) a,
			  strlen (a) + 1);
d706 3
a708 3
      for (i = 1, n = 1; argv[i]; i++)
	n += strlen (argv[i]) + 1;
      data = (char *) malloc (n);
d710 4
a713 7
	{
	  strcpy (data + n, argv[i]);
	  n += strlen (argv[i]) + 1;
	}
      data[n] = 0;
      rv = RegSetValueEx (key, value, 0, REG_MULTI_SZ, (const BYTE *) data,
			  n + 1);
d736 1
a736 1
  DWORD rv = RegDeleteValue (key, value);
d740 1
a740 1
    printf ("value %s deleted\n", value);
d749 4
a752 2
  char *data, *vd;
  rv = RegQueryValueEx (key, value, 0, &vtype, 0, &dsize);
d755 2
a756 2
  data = (char *) malloc (dsize + 1);
  rv = RegQueryValueEx (key, value, 0, &vtype, (BYTE *) data, &dsize);
a771 1
      case REG_LINK:
d788 2
a789 1
	printf ("%s\n", data);
d794 1
a794 1
	    char *buf;
d796 3
a798 3
	    bufsize = ExpandEnvironmentStrings (data, 0, 0);
	    buf = (char *) malloc (bufsize + 1);
	    ExpandEnvironmentStrings (data, buf, bufsize + 1);
d800 1
a800 1
	    data = buf;
d802 1
a802 1
	printf ("%s\n", data);
d805 1
a805 1
	vd = data;
d808 2
a809 2
	    printf ("%s\n", vd);
	    vd = vd + strlen ((const char *) vd) + 1;
d841 1
a841 1
set_privilege (const char * name)
d871 4
a874 6
  ssize_t len = cygwin_conv_path (CCP_POSIX_TO_WIN_A | CCP_RELATIVE,
				  argv[1], NULL, 0);
  char win32_path[len];
  cygwin_conv_path (CCP_POSIX_TO_WIN_A | CCP_RELATIVE, argv[1],
		    win32_path, len);
  DWORD rv = RegSaveKey (key, win32_path, NULL);
d878 1
a878 1
    printf ("key saved to %s\n", win32_path);
d906 1
@


1.26
log
@	* cygpath.cc (do_sysfolders): Use cygwin_conv_path.
	(do_pathconv): Use cygwin_conv_path and cygwin_conv_path_list.
	* dumper.cc (main): Use cygwin_conv_path.  Allocate target path
	dynamically.
	* mkpasswd.c (current_user): Use cygwin_conv_path.
	(enum_users): Ditto.
	* ps.cc (NT_MAX_PATH): Define.
	(main): Use cygwin_conv_path.
	* regtool.cc (find_key): Ditto. Allocate target path dynamically.
	(cmd_save): Ditto.
@
text
@d205 1
a205 1
struct
d868 1
a868 2

struct
@


1.25
log
@	* regtool.cc (opts): Add missing 'W'.
@
text
@d417 5
a421 2
	  char win32_path[MAX_PATH];
	  cygwin_conv_to_win32_path (argv[1], win32_path);
d855 5
a859 2
  char win32_path[MAX_PATH];
  cygwin_conv_to_win32_path (argv[1], win32_path);
@


1.24
log
@	* regtool.cc (key_type): Drop.
	(REG_AUTO): Define.
	(value_type): Replace key_type.  Use REG_xxx values directly.
	Accomodate change throughout.
	(longopts): Add --dword, --dword-le, --none, --qword and --hex options.
	(opts): Add -d, -D, -n, -Q and -x options.
	(types): Array to convert REG_xxx into strings.
	(hex): New variable to keep value of --hex option.
	(usage): Accomodate new options.  Print only the necessary by default.
	Only be verbose in case of -h/--help option.
	(cmd_list): Use key separator from -K option when printing.
	Print value type when verbose option is given.  Handle so far not
	handled REG_xxx types.
	(cmd_set): Avoid SEGV due to missing argument.  Handle so far not
	handled REG_xxx types.
	(cmd_get): Handle --binary option type agnostic.  Handle so far not
	handled REG_xxx types.
	(main): Handle new options.
@
text
@d60 1
a60 1
static char opts[] = "bdDehiklmnpqQsvVwxK:";
@


1.23
log
@	* regtool.cc (longopts): Add --wow32 option.
	(opts): Add -W option.
	(usage): Add text for --wow32/-W option.
	(main): Handle --wow32/-W option.
	* utils.sgml: Document the new -W option.
@
text
@d22 3
a24 4
enum
{
  KT_AUTO, KT_BINARY, KT_INT, KT_STRING, KT_EXPAND, KT_MULTI
} key_type = KT_AUTO;
d38 2
d46 1
d49 1
d55 1
d60 17
a76 1
static char opts[] = "behiklmpqsvVwK:";
d82 1
d93 1
a93 1
  "Usage: %s [OPTION] (add|check|get|list|remove|unset|load|unload|save) KEY\n"
d95 1
a95 43
  "\n"
  "", prog_name);
  if (where == stdout)
    fprintf (where, ""
    "Actions:\n"
    " add KEY\\SUBKEY             add new SUBKEY\n"
    " check KEY                  exit 0 if KEY exists, 1 if not\n"
    " get KEY\\VALUE              prints VALUE to stdout\n"
    " list KEY                   list SUBKEYs and VALUEs\n"
    " remove KEY                 remove KEY\n"
    " set KEY\\VALUE [data ...]   set VALUE\n"
    " unset KEY\\VALUE            removes VALUE from KEY\n"
    " load KEY\\SUBKEY PATH       load hive from PATH into new SUBKEY\n"
    " unload KEY\\SUBKEY          unload hive and remove SUBKEY\n"
    " save KEY\\SUBKEY PATH       save SUBKEY into new hive PATH\n"
    "\n");
  fprintf (where, ""
  "Options for 'list' Action:\n"
  " -k, --keys           print only KEYs\n"
  " -l, --list           print only VALUEs\n"
  " -p, --postfix        like ls -p, appends '\\' postfix to KEY names\n"
  "\n"
  "Options for 'get' Action:\n"
  " -b, --binary         print REG_BINARY data as hex bytes\n"
  "\n"
  "Options for 'set' Action:\n"
  " -b, --binary         set type to REG_BINARY (hex args or '-')\n"
  " -e, --expand-string  set type to REG_EXPAND_SZ\n"
  " -i, --integer        set type to REG_DWORD\n"
  " -m, --multi-string   set type to REG_MULTI_SZ\n"
  " -s, --string         set type to REG_SZ\n"
  "\n"
  "Options for 'set' and 'unset' Actions:\n"
  " -K<c>, --key-separator[=]<c>  set key-value separator to <c> instead of '\\'\n"
  "\n"
  "Other Options:\n"
  " -h, --help     output usage information and exit\n"
  " -q, --quiet    no error output, just nonzero return if KEY/VALUE missing\n"
  " -v, --verbose  verbose output, including VALUE contents when applicable\n"
  " -w, --wow64    access 64 bit registry view (ignored on 32 bit Windows)\n"
  " -W, --wow32    access 32 bit registry view (ignored on 32 bit Windows)\n"
  " -V, --version  output version information and exit\n"
  "\n");
d99 46
d160 4
a163 1
    fprintf (where, "Try '%s --help' for more information.\n", prog_name);
d466 3
a468 1
	printf ("%s%s", subkey_name, (postfix || verbose) ? "\\" : "");
d487 1
a487 1
	    printf ("%s = ", value_name);
d490 2
d504 2
a505 1
		     | (value_data[2] << 8) | (value_data[3]));
d508 5
d529 2
a530 1
		printf ("? (type %d)\n", (int) t);
d599 1
d603 3
a605 1
  if (key_type == KT_AUTO)
d608 1
a608 1
      strtoul (a, &e, 0);
d610 1
a610 1
	key_type = KT_EXPAND;
d612 1
a612 1
	key_type = KT_INT;
d614 1
a614 1
	key_type = KT_MULTI;
d616 1
a616 1
	key_type = KT_STRING;
d619 1
a619 1
  switch (key_type)
d621 2
a622 1
    case KT_BINARY:
d657 1
a657 1
      rv = RegSetValueEx (key, value, 0, REG_BINARY, (const BYTE *) data, n);
d659 1
a659 1
    case KT_INT:
d664 15
a678 1
    case KT_STRING:
d681 1
a681 1
    case KT_EXPAND:
d685 1
a685 1
    case KT_MULTI:
d698 1
a698 1
    case KT_AUTO:
d740 1
a740 1
  switch (vtype)
d742 3
a744 37
    case REG_BINARY:
      if (key_type == KT_BINARY)
	{
	  for (unsigned i = 0; i < dsize; i++)
	    printf ("%02x%c", (unsigned char)data[i],
	      (i < dsize-1 ? ' ' : '\n'));
	}
      else
 	fwrite (data, dsize, 1, stdout);
      break;
    case REG_DWORD:
      printf ("%lu\n", *(DWORD *) data);
      break;
    case REG_SZ:
      printf ("%s\n", data);
      break;
    case REG_EXPAND_SZ:
      if (key_type == KT_EXPAND)	// hack
	{
	  char *buf;
	  DWORD bufsize;
	  bufsize = ExpandEnvironmentStrings (data, 0, 0);
	  buf = (char *) malloc (bufsize + 1);
	  ExpandEnvironmentStrings (data, buf, bufsize + 1);
	  free (data);
	  data = buf;
	}
      printf ("%s\n", data);
      break;
    case REG_MULTI_SZ:
      vd = data;
      while (vd && *vd)
	{
	  printf ("%s\n", vd);
	  vd = vd + strlen ((const char *) vd) + 1;
	}
      break;
d746 48
d899 7
a905 1
	  key_type = KT_BINARY;
d908 1
a908 1
	  key_type = KT_EXPAND;
d916 1
a916 1
	  key_type = KT_INT;
d922 4
a925 1
	  key_type = KT_MULTI;
d933 3
d937 1
a937 1
	  key_type = KT_STRING;
d951 3
@


1.22
log
@	* regtool.cc (KEY_WOW64_64KEY): Drop definition.  Instead define
	WINVER to 0x0502 before including windows.h.
@
text
@d51 1
d114 1
d865 3
@


1.21
log
@	* regtool.cc (KEY_WOW64_64KEY): Define.
	(longopts): Add --wow64 option.
	(opts): Add -w option.
	(wow64): New variable to control usage of KEY_WOW64_64KEY access flag.
	(usage): Add text for --wow64/-w option.
	(print_version): Fix copyright.
	(find_key): Use wow64 value in calls to RegOpenKeyEx and RegCreateKeyEx.
	(cmd_add): Use wow64 value in call to RegCreateKeyEx.
	(regDeleteKeyEx): New function pointer to load RegDeleteKeyEx function
	dynamically.
	(cmd_remove): Load and use regDeleteKeyEx when wow64 is set.
	(main): Handle --wow64/-w option.
	* utils.sgml: Document the new -w option.
@
text
@d16 1
a21 4
#ifndef KEY_WOW64_64KEY
#define KEY_WOW64_64KEY 0x100
#endif

@


1.20
log
@	* regtool.cc (options): Add 'binary'.
	(usage): Document 'load|unload|save' and '-b'.
	(find_key): Add 'options' parameter, add load/unload.
	(cmd_set): Add KT_BINARY case.
	(cmd_get): Add hex output in KT_BINARY case.
	(cmd_load): New function.
	(cmd_unload): New function.
	(set_privilege): New function.
	(cmd_save): New function.
	(commands): Add load, unload and save.
	(main): Add '-b'
	* utils.sgml (regtool): Document it.
@
text
@d21 4
d53 1
d58 1
a58 1
static char opts[] = "behiklmpqsvVK:";
d64 1
d115 1
d158 1
a158 1
Copyright 2000, 2001, 2002, 2003, 2004, 2005 Red Hat, Inc.\n\
d370 1
a370 1
	  rv = RegOpenKeyEx (base, n, 0, access, &key);
d376 1
a376 1
	      if (RegCreateKeyEx (base, n, 0, NULL, option, access, NULL, &key2, NULL)
d506 1
a506 1
			   KEY_ALL_ACCESS, 0, &newkey, &newtype);
d520 4
d527 2
d530 10
a539 1
  DWORD rv = RegDeleteKey (key, value);
d863 3
@


1.20.4.1
log
@	* regtool.cc (KEY_WOW64_64KEY): Define conditionally.
	(KEY_WOW64_32KEY): Ditto.
	(opts): Add missing 'W'.

	* regtool.cc (key_type): Drop.
	(REG_AUTO): Define.
	(value_type): Replace key_type.  Use REG_xxx values directly.
	Accomodate change throughout.
	(longopts): Add --dword, --dword-le, --none, --qword and --hex options.
	(opts): Add -d, -D, -n, -Q and -x options.
	(types): Array to convert REG_xxx into strings.
	(hex): New variable to keep value of --hex option.
	(usage): Accomodate new options.  Print only the necessary by default.
	Only be verbose in case of -h/--help option.
	(cmd_list): Use key separator from -K option when printing.
	Print value type when verbose option is given.  Handle so far not
	handled REG_xxx types.
	(cmd_set): Avoid SEGV due to missing argument.  Handle so far not
	handled REG_xxx types.
	(cmd_get): Handle --binary option type agnostic.  Handle so far not
	handled REG_xxx types.
	(main): Handle new options.

	* regtool.cc (longopts): Add --wow32 option.
	(opts): Add -W option.
	(usage): Add text for --wow32/-W option.
	(main): Handle --wow32/-W option.
	* utils.sgml: Document the new -W option.

	* regtool.cc (KEY_WOW64_64KEY): Drop definition.  Instead define
	WINVER to 0x0502 before including windows.h.

	* regtool.cc (KEY_WOW64_64KEY): Define.
	(longopts): Add --wow64 option.
	(opts): Add -w option.
	(wow64): New variable to control usage of KEY_WOW64_64KEY access flag.
	(usage): Add text for --wow64/-w option.
	(print_version): Fix copyright.
	(find_key): Use wow64 value in calls to RegOpenKeyEx and RegCreateKeyEx.
	(cmd_add): Use wow64 value in call to RegCreateKeyEx.
	(regDeleteKeyEx): New function pointer to load RegDeleteKeyEx function
	dynamically.
	(cmd_remove): Load and use regDeleteKeyEx when wow64 is set.
	(main): Handle --wow64/-w option.
	* utils.sgml: Document the new -w option.
@
text
@a15 1
#define WINVER 0x0502
d21 4
a24 10
#ifndef KEY_WOW64_32KEY
#define KEY_WOW64_32KEY 0x0200
#endif
#ifndef KEY_WOW64_64KEY
#define KEY_WOW64_64KEY 0x0100
#endif

#define REG_AUTO -1

int value_type = REG_AUTO;
a37 2
  {"dword", no_argument, NULL, 'd' },
  {"dword-le", no_argument, NULL, 'D' },
a43 1
  {"none", no_argument, NULL, 'n' },
a45 1
  {"qword", no_argument, NULL, 'Q' },
a48 3
  {"wow64", no_argument, NULL, 'w'},
  {"wow32", no_argument, NULL, 'W'},
  {"hex", no_argument, NULL, 'x'},
d53 1
a53 17
static char opts[] = "bdDehiklmnpqQsvVwWxK:";

const char *types[] =
{
  "REG_NONE",
  "REG_SZ",
  "REG_EXPAND_SZ",
  "REG_BINARY",
  "REG_DWORD",
  "REG_DWORD_BIG_ENDIAN",
  "REG_LINK",
  "REG_MULTI_SZ",
  "REG_RESOURCE_LIST",
  "REG_FULL_RESOURCE_DESCRIPTOR",
  "REG_RESOURCE_REQUIREMENTS_LIST",
  "REG_QWORD",
};
a58 2
int hex = 0;
DWORD wow64 = 0;
d68 1
a68 1
  "Usage: %s [OPTION] ACTION KEY [data...]\n"
d70 41
a110 1
  "\n", prog_name);
a113 46
      "Actions:\n"
      " add KEY\\SUBKEY             add new SUBKEY\n"
      " check KEY                  exit 0 if KEY exists, 1 if not\n"
      " get KEY\\VALUE              prints VALUE to stdout\n"
      " list KEY                   list SUBKEYs and VALUEs\n"
      " remove KEY                 remove KEY\n"
      " set KEY\\VALUE [data ...]   set VALUE\n"
      " unset KEY\\VALUE            removes VALUE from KEY\n"
      " load KEY\\SUBKEY PATH       load hive from PATH into new SUBKEY\n"
      " unload KEY\\SUBKEY          unload hive and remove SUBKEY\n"
      " save KEY\\SUBKEY PATH       save SUBKEY into new hive PATH\n"
      "\n");
      fprintf (where, ""
      "Options for 'list' Action:\n"
      " -k, --keys           print only KEYs\n"
      " -l, --list           print only VALUEs\n"
      " -p, --postfix        like ls -p, appends '\\' postfix to KEY names\n"
      "\n"
      "Options for 'get' Action:\n"
      " -b, --binary         print data as printable hex bytes\n"
      " -n, --none           print data as stream of bytes as stored in registry\n"
      " -x, --hex            print numerical data as hex numbers\n"
      "\n"
      "Options for 'set' Action:\n"
      " -b, --binary         set type to REG_BINARY (hex args or '-')\n"
      " -d, --dword          set type to REG_DWORD\n"
      " -D, --dword-le       set type to REG_DWORD_LITTLE_ENDIAN\n"
      " -e, --expand-string  set type to REG_EXPAND_SZ\n"
      " -i, --integer        set type to REG_DWORD\n"
      " -m, --multi-string   set type to REG_MULTI_SZ\n"
      " -n, --none           set type to REG_NONE\n"
      " -Q, --qword          set type to REG_QWORD\n"
      " -s, --string         set type to REG_SZ\n"
      "\n"
      "Options for 'set' and 'unset' Actions:\n"
      " -K<c>, --key-separator[=]<c>  set key-value separator to <c> instead of '\\'\n"
      "\n"
      "Other Options:\n"
      " -h, --help     output usage information and exit\n"
      " -q, --quiet    no error output, just nonzero return if KEY/VALUE missing\n"
      " -v, --verbose  verbose output, including VALUE contents when applicable\n"
      " -w, --wow64    access 64 bit registry view (ignored on 32 bit Windows)\n"
      " -W, --wow32    access 32 bit registry view (ignored on 32 bit Windows)\n"
      " -V, --version  output version information and exit\n"
      "\n");
      fprintf (where, ""
d129 1
a129 4
    fprintf (where,
    "ACTION is one of add, check, get, list, remove, set, unset, load, unload, save\n"
    "\n"
    "Try '%s --help' for more information.\n", prog_name);
d151 1
a151 1
Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006 Red Hat, Inc.\n\
d363 1
a363 1
	  rv = RegOpenKeyEx (base, n, 0, access | wow64, &key);
d369 1
a369 1
	      if (RegCreateKeyEx (base, n, 0, NULL, option, access | wow64, NULL, &key2, NULL)
d432 1
a432 3
	fputs (subkey_name, stdout);
	if (postfix || verbose)
	  fputc (key_sep, stdout);
d451 1
a451 1
	    printf ("%s (%s) = ", value_name, types[t]);
a453 2
	      case REG_NONE:
	      case REG_LINK:
d466 1
a466 2
		     | (value_data[2] << 8)
		     | (value_data[3]));
a468 5
	      case REG_QWORD:
		printf ("0x%016llx (%llu)\n",
			*(unsigned long long *) value_data,
			*(unsigned long long *) value_data);
		break;
d485 1
a485 2
		printf ("?\n");
		break;
d499 1
a499 1
			   KEY_ALL_ACCESS | wow64, 0, &newkey, &newtype);
a512 4
extern "C" {
WINADVAPI LONG WINAPI (*regDeleteKeyEx)(HKEY, LPCSTR, REGSAM, DWORD);
}

a515 2
  DWORD rv;

d517 1
a517 10
  if (wow64)
    {
      HMODULE mod = LoadLibrary ("advapi32.dll");
      if (mod)
        regDeleteKeyEx = (WINADVAPI LONG WINAPI (*)(HKEY, LPCSTR, REGSAM, DWORD)) GetProcAddress (mod, "RegDeleteKeyExA");
    }
  if (regDeleteKeyEx)
    rv = (*regDeleteKeyEx) (key, value, wow64, 0);
  else
    rv = RegDeleteKey (key, value);
a538 1
  unsigned long long llval;
d542 1
a542 3
  if (!a)
    usage ();
  if (value_type == REG_AUTO)
d545 1
a545 1
      llval = strtoull (a, &e, 0);
d547 1
a547 1
	value_type = REG_EXPAND_SZ;
d549 1
a549 1
	value_type = llval > 0xffffffffULL ? REG_QWORD : REG_DWORD;
d551 1
a551 1
	value_type = REG_MULTI_SZ;
d553 1
a553 1
	value_type = REG_SZ;
d556 1
a556 1
  switch (value_type)
d558 1
a558 2
    case REG_NONE:
    case REG_BINARY:
d593 1
a593 1
      rv = RegSetValueEx (key, value, 0, value_type, (const BYTE *) data, n);
d595 1
a595 1
    case REG_DWORD:
d600 1
a600 15
    case REG_DWORD_BIG_ENDIAN:
      v = strtoul (a, 0, 0);
      v = (((v & 0xff) << 24)
	   | ((v & 0xff00) << 8)
	   | ((v & 0xff0000) >> 8)
	   | ((v & 0xff000000) >> 24));
      rv = RegSetValueEx (key, value, 0, REG_DWORD_BIG_ENDIAN,
			  (const BYTE *) &v, sizeof (v));
      break;
    case REG_QWORD:
      llval = strtoul (a, 0, 0);
      rv = RegSetValueEx (key, value, 0, REG_QWORD, (const BYTE *) &llval,
			  sizeof (llval));
      break;
    case REG_SZ:
d603 1
a603 1
    case REG_EXPAND_SZ:
d607 1
a607 1
    case REG_MULTI_SZ:
d620 1
a620 1
    case REG_AUTO:
d662 1
a662 1
  if (value_type == REG_BINARY)
d664 37
a700 3
      for (unsigned i = 0; i < dsize; i++)
	printf ("%02x%c", (unsigned char)data[i],
	  (i < dsize-1 ? ' ' : '\n'));
a701 48
  else if (value_type == REG_NONE)
    fwrite (data, dsize, 1, stdout);
  else
    switch (vtype)
      {
      case REG_NONE:
      case REG_BINARY:
      case REG_LINK:
	fwrite (data, dsize, 1, stdout);
	break;
      case REG_DWORD:
	printf (hex ? "0x%08lx\n" : "%lu\n", *(DWORD *) data);
	break;
      case REG_DWORD_BIG_ENDIAN:
	rv = ((data[0] << 24)
	      | (data[1] << 16)
	      | (data[2] << 8)
	      | (data[3]));
	printf (hex ? "0x%08lx\n" : "%lu\n", rv);
	break;
      case REG_QWORD:
	printf (hex ? "0x%016llx\n" : "%llu\n", *(unsigned long long *) data);
	break;
      case REG_SZ:
	printf ("%s\n", data);
	break;
      case REG_EXPAND_SZ:
	if (value_type == REG_EXPAND_SZ)	// hack
	  {
	    char *buf;
	    DWORD bufsize;
	    bufsize = ExpandEnvironmentStrings (data, 0, 0);
	    buf = (char *) malloc (bufsize + 1);
	    ExpandEnvironmentStrings (data, buf, bufsize + 1);
	    free (data);
	    data = buf;
	  }
	printf ("%s\n", data);
	break;
      case REG_MULTI_SZ:
	vd = data;
	while (vd && *vd)
	  {
	    printf ("%s\n", vd);
	    vd = vd + strlen ((const char *) vd) + 1;
	  }
	break;
      }
d807 1
a807 7
	  value_type = REG_BINARY;
	  break;
	case 'd':
	  value_type = REG_DWORD;
	  break;
	case 'D':
	  value_type = REG_DWORD_BIG_ENDIAN;
d810 1
a810 1
	  value_type = REG_EXPAND_SZ;
d818 1
a818 1
	  value_type = REG_DWORD;
d824 1
a824 4
	  value_type = REG_MULTI_SZ;
	  break;
	case 'n':
	  value_type = REG_NONE;
a831 3
	case 'Q':
	  value_type = REG_QWORD;
	  break;
d833 1
a833 1
	  value_type = REG_SZ;
a840 9
	case 'w':
	  wow64 = KEY_WOW64_64KEY;
	  break;
	case 'W':
	  wow64 = KEY_WOW64_32KEY;
	  break;
	case 'x':
	  hex++;
	  break;
@


1.19
log
@	* regtool.cc (usage): Clarify help for "-K".
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005 Red Hat Inc.
d13 1
d17 1
d23 1
a23 1
  KT_AUTO, KT_INT, KT_STRING, KT_EXPAND, KT_MULTI
d37 1
d53 1
a53 1
static char opts[] = "ehiklmpqsvVK:";
d68 1
a68 1
  "Usage: %s [OPTION] (add | check | get | list | remove | unset) KEY\n"
d82 3
d92 3
d96 1
d278 1
a278 1
find_key (int howmanyparts, REGSAM access)
d361 38
a398 3
      rv = RegOpenKeyEx (base, n, 0, access, &key);
      if (rv != ERROR_SUCCESS)
	Fail (rv);
d539 1
a539 1
  char *a = argv[1], *data;
d558 37
d627 3
d665 8
a672 1
      fwrite (data, dsize, 1, stdout);
d705 66
d784 3
d806 3
@


1.18
log
@	* regtool.cc: Extend copyright-years.
	(print_version): Ditto.
	(cmd_list): Don't depend on terminating '\0' being present on
	string-values.
	(cmd_get): Don't attempt to read more than present, but keep
	extra space for terminating '\0'. Really output REG_BINARY.
	Don't leak memory.
	(cmd_set): Include trailing '\0' in string's length.
@
text
@d93 1
a93 1
  " -K<c>, --key-separator[=]<c>  set key separator to <c> instead of '\\'\n"
@


1.17
log
@* regtool.cc (opts): The argument to 'K' is not optional.
(main): Revert previous change.  Just let getopt deal with missing argument.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002, 2003, 2004 Red Hat Inc.
d141 1
a141 1
Copyright 2000, 2001, 2002 Red Hat, Inc.\n\
d401 1
d519 1
a519 1
      rv = RegSetValueEx (key, value, 0, REG_SZ, (const BYTE *) a, strlen (a));
d523 1
a523 1
			  strlen (a));
d573 1
a573 2
  dsize++;
  data = (char *) malloc (dsize);
d580 1
a580 1
      fwrite (data, dsize, 0, stdout);
d596 1
@


1.16
log
@* regtool.cc (main): Avoid a SEGV when nothing follows -K.
@
text
@d50 1
a50 1
static char opts[] = "ehiklmpqsvVK::";
d677 1
a677 4
	  if (!optarg)
	    usage ();
	  else
	    key_sep = *optarg;
@


1.15
log
@fix whitespace, update some copyrights
@
text
@d677 4
a680 1
	  key_sep = *optarg;
@


1.14
log
@	* regtool.cc (usage): Add missing linefeed.  Move example to --help
	text.  Fix forward slash description.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002 Red Hat Inc.
d281 1
a281 1
      host[0] = host [1] = '\\'; 
d283 1
a283 1
        *h = *e;
d287 1
a287 1
        translate (n);
d293 1
a293 1
      host[0] = host[1] = '\\'; 
d295 1
a295 1
        *h = *e;
d332 1
a332 1
        {
@


1.13
log
@* cygcheck.cc (usage) Add description output.
@
text
@d102 16
a117 14
    fprintf (where, ""
    "KEY is in the format [host]\\prefix\\KEY\\KEY\\VALUE, where host is optional\n"
    "remote host in either \\\\hostname or hostname: format and prefix is any of:\n"
    "  root     HKCR  HKEY_CLASSES_ROOT (local only)\n"
    "  config   HKCC  HKEY_CURRENT_CONFIG (local only)\n"
    "  user     HKCU  HKEY_CURRENT_USER (local only)\n"
    "  machine  HKLM  HKEY_LOCAL_MACHINE\n"
    "  users    HKU   HKEY_USERS\n"
    "\n"
    "You can use forward slash ('/') as a separator instead of backslash, in\n"
    "that case backslash is treated as escape character\n"
    "");
  fprintf (where, ""
  "Example: %s get '\\user\\software\\Microsoft\\Clock\\iFormat'\n", prog_name);
d119 1
a119 1
    fprintf (where, "Try '%s --help' for more information.", prog_name);
@


1.12
log
@Add final newlines to utils
@
text
@d66 1
@


1.11
log
@* regtool.cc (find_key): Add support for custom key separator.
(usage): Document it.
@
text
@d139 2
a140 1
Compiled on %s", prog_name, len, v, __DATE__);
@


1.10
log
@	* regtool.cc (Fail): Be more verbose.
	(find_key): Add support for remote registry access.
	(usage): Document it.
	* utils.sgml: Document it.
@
text
@d17 2
d24 2
d46 1
d50 1
a50 1
static char opts[] = "ehiklmpqsvV";
d91 3
d319 1
a319 1
      while (n < e && *e != '\\')
d321 1
a321 1
      if (*e != '\\')
d672 3
@


1.9
log
@* regtool.cc (prog_name): New global variable.
(longopts): Ditto.
(opts): Ditto.
(usage): Standardize usage output.  Rearrange/add descriptions.
(print_version): New function.
(main): Accomodate longopts and new --help, --version options.  Add check for
(_argv[optind+1] == NULL).
@
text
@d94 10
a103 6
    "KEY is in the format \\prefix\\KEY\\KEY\\VALUE, where prefix is any of:\n"
    "  \\root     HKCR  HKEY_CLASSES_ROOT\n"
    "  \\config   HKCC  HKEY_CURRENT_CONFIG\n"
    "  \\user     HKCU  HKEY_CURRENT_USER\n"
    "  \\machine  HKLM  HKEY_LOCAL_MACHINE\n"
    "  \\users    HKU   HKEY_USERS\n"
d143 1
a143 1
      fprintf (stderr, "Error: %s\n", buf);
d258 4
a261 1
  char *n = argv[0], *e, c;
d265 23
a287 1
  while (*n == '\\')
d289 1
d325 10
d336 2
d339 3
a341 2
      key = wkprefixes[i].key;
      return;
a342 3
  int rv = RegOpenKeyEx (wkprefixes[i].key, n, 0, access, &key);
  if (rv != ERROR_SUCCESS)
    Fail (rv);
@


1.8
log
@        * regtool.cc (find_key): Handle keys with only one subkey.
@
text
@d3 1
a3 1
   Copyright 2000 Red Hat Inc.
d26 21
d56 2
a57 27
const char *usage_msg[] = {
  "Regtool Copyright (c) 2000 Red Hat Inc",
  " regtool -h  - print this message",
  " regtool [-v|-p|-k|-l] list [key]  - list subkeys and values",
  "     -p=postfix, like ls -p, appends \\ postfix to key names",
  "     -k=keys, lists only keys",
  "     -l=values, lists only values",
  " regtool [-v] add [key\\subkey]  - add new subkey",
  " regtool [-v] remove [key]  - remove key",
  " regtool [-v|-q] check [key]  - exit 0 if key exists, 1 if not",
  " regtool [-i|-s|-e|-m] set [key\\value] [data ...]  - set value",
  "     -i=integer -s=string -e=expand-string -m=multi-string",
  " regtool [-v] unset [key\\value]  - removes value from key",
  " regtool [-q] get [key\\value]  - prints value to stdout",
  "     -q=quiet, no error msg, just return nonzero exit if key/value missing",
  " keys are like \\prefix\\key\\key\\key\\value, where prefix is any of:",
  "   root     HKCR  HKEY_CLASSES_ROOT",
  "   config   HKCC  HKEY_CURRENT_CONFIG",
  "   user     HKCU  HKEY_CURRENT_USER",
  "   machine  HKLM  HKEY_LOCAL_MACHINE",
  "   users    HKU   HKEY_USERS",
  " example: \\user\\software\\Microsoft\\Clock\\iFormat",
  0
};

void
usage (void)
d59 69
a127 4
  int i;
  for (i = 0; usage_msg[i]; i++)
    fprintf (stderr, "%s\n", usage_msg[i]);
  exit (1);
d579 12
a590 6
  while (1)
    {
      int g = getopt (argc, _argv, "hvqisempkl");
      if (g == -1)
	break;
      switch (g)
d592 2
a593 8
	case 'v':
	  verbose++;
	  break;
	case 'q':
	  quiet++;
	  break;
	case 'p':
	  postfix++;
d598 5
d606 8
a613 3

	case 'i':
	  key_type = KT_INT;
d618 2
a619 2
	case 'e':
	  key_type = KT_EXPAND;
d621 4
a624 6
	case 'm':
	  key_type = KT_MULTI;
	  break;

	case '?':
	case 'h':
d627 2
a628 2
    }
  if (_argv[optind] == NULL)
@


1.7
log
@* regtool.cc (find_key): Revert previous change.
@
text
@d224 8
a231 2
	  fprintf (stderr, "Invalid key\n");
	  exit (1);
a232 2
      *e = 0;
      value = e + 1;
@


1.6
log
@* regtool.cc (find_key): Allow '/' as a synonym for '\\'.
@
text
@d39 1
a39 1
  "     -p=postfix, like ls -p, appends / postfix to key names",
d197 1
a197 1
  while ((*n == '\\') || (*n == '/'))
d199 2
a200 5
  for (e = n; *e && *e != '\\' && *e != '/'; e++);
  if (*e == '/')
    c = '\\';
  else
    c = *e;
@


1.5
log
@* regtool.cc (cmd_list): Add new registry display options.
(cmd_list): Add code to implement -p, -k, and -l options.
* regtool.cc (Fail): Add call to LocalFree to free memory allocated by
FormatMessage.
@
text
@d197 1
a197 1
  while (*n == '\\')
d199 5
a203 2
  for (e = n; *e && *e != '\\'; e++);
  c = *e;
@


1.4
log
@more formatting changes.
@
text
@d22 6
d38 4
a41 1
  " regtool [-v] list [key]  - list subkeys and values",
d79 1
d261 2
a262 10
  for (i = 0; i < num_subkeys; i++)
    {
      m = maxsubkeylen + 1;
      n = maxclasslen + 1;
      RegEnumKeyEx (key, i, subkey_name, &m, 0, class_name, &n, 0);
      if (verbose)
	printf ("%s\\ (%s)\n", subkey_name, class_name);
      else
	printf ("%s\n", subkey_name);
    }
d264 62
a325 47
  for (i = 0; i < num_values; i++)
    {
      m = maxvalnamelen + 1;
      n = maxvaluelen + 1;
      RegEnumValue (key, i, value_name, &m, 0, &t, (BYTE *) value_data, &n);
      if (!verbose)
	printf ("%s\n", value_name);
      else
	{
	  printf ("%s = ", value_name);
	  switch (t)
	    {
	    case REG_BINARY:
	      for (j = 0; j < 8 && j < n; j++)
		printf ("%02x ", value_data[j]);
	      printf ("\n");
	      break;
	    case REG_DWORD:
	      printf ("0x%08lx (%lu)\n", *(DWORD *) value_data,
		      *(DWORD *) value_data);
	      break;
	    case REG_DWORD_BIG_ENDIAN:
	      v = ((value_data[0] << 24)
		   | (value_data[1] << 16)
		   | (value_data[2] << 8) | (value_data[3]));
	      printf ("0x%08x (%d)\n", v, v);
	      break;
	    case REG_EXPAND_SZ:
	    case REG_SZ:
	      printf ("\"%s\"\n", value_data);
	      break;
	    case REG_MULTI_SZ:
	      vd = value_data;
	      while (vd && *vd)
		{
		  printf ("\"%s\"", vd);
		  vd = vd + strlen ((const char *) vd) + 1;
		  if (*vd)
		    printf (", ");
		}
	      printf ("\n");
	      break;
	    default:
	      printf ("? (type %d)\n", (int) t);
	    }
	}
    }
d516 1
a516 1
      int g = getopt (argc, _argv, "hvqisem");
d526 9
@


1.3
log
@* regtool.cc (translate): Ensure that 'c' is initialized.
(cmd_set): Ditto for rv.
@
text
@d158 1
a158 1
	      c = 0;
d404 2
d407 1
a407 1
      rv = ERROR_SUCCESS;
@


1.2
log
@        * regtool.cc (find_key): Add parameter `access'.
        Call `RegOpenKeyEx' with that desired access.
        (cmd_add, cmd_remove, cmd_set, cmd_unset): Call
        `find_key' with KEY_ALL_ACCESS access.
        (cmd_list, cmd_check, cmd_get): Call `find_key'
        with KEY_READ access.
@
text
@d17 2
a18 1
enum {
d29 1
a29 2
const char *usage_msg[] =
{
d52 1
a52 1
usage(void)
d55 3
a57 3
  for (i=0; usage_msg[i]; i++)
    fprintf(stderr, "%s\n", usage_msg[i]);
  exit(1);
d61 1
a61 1
Fail(DWORD rv)
d66 4
a69 4
      FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
		    | FORMAT_MESSAGE_FROM_SYSTEM,
		    0, rv, 0, (CHAR *)&buf, 0, 0);
      fprintf(stderr, "Error: %s\n", buf);
d71 1
a71 1
  exit(1);
d74 2
a75 1
struct {
d78 18
a95 17
} wkprefixes[] = {
  { "root", HKEY_CLASSES_ROOT },
  { "HKCR", HKEY_CLASSES_ROOT },
  { "HKEY_CLASSES_ROOT", HKEY_CLASSES_ROOT },
  { "config", HKEY_CURRENT_CONFIG },
  { "HKCC", HKEY_CURRENT_CONFIG },
  { "HKEY_CURRENT_CONFIG", HKEY_CURRENT_CONFIG },
  { "user", HKEY_CURRENT_USER },
  { "HKCU", HKEY_CURRENT_USER },
  { "HKEY_CURRENT_USER", HKEY_CURRENT_USER },
  { "machine", HKEY_LOCAL_MACHINE },
  { "HKLM", HKEY_LOCAL_MACHINE },
  { "HKEY_LOCAL_MACHINE", HKEY_LOCAL_MACHINE },
  { "users", HKEY_USERS },
  { "HKU", HKEY_USERS },
  { "HKEY_USERS", HKEY_USERS },
  { 0, 0 }
d98 2
a99 1
void translate(char *key)
d113 58
a170 50
        switch (*++s)
          {
          case 'a':
            *d++ = '\007';
            break;
          case 'b':
            *d++ = '\b';
            break;
          case 'e':
            *d++ = '\033';
            break;
          case 'f':
            *d++ = '\f';
            break;
          case 'n':
            *d++ = '\n';
            break;
          case 'r':
            *d++ = '\r';
            break;
          case 't':
            *d++ = '\t';
            break;
          case 'v':
            *d++ = '\v';
            break;
          case '0': case '1': case '2': case '3':
          case '4': case '5': case '6': case '7':
            c = tooct(*s);
            if (isodigit(s[1]))
              {
                c = (c << 3) | tooct(*++s);
                if (isodigit(s[1]))
                  c = (c << 3) | tooct(*++s);
              }
            *d++ = c;
            break;
          case 'x':
            if (isxdigit(s[1]))
              {
                c = tohex(*++s);
                if (isxdigit(s[1]))
                  c = (c << 4) | tohex(*++s);
              }
            *d++ = c;
            break;
          default:     /* before non-special char: just add the char */
            *d++ = *s;
            break;
          }
d172 1
a172 1
        *d++ = '\\';
d174 1
a174 1
        *d++ = *s;
d181 1
a181 1
find_key(int howmanyparts, REGSAM access)
d186 1
a186 1
    translate(n);
d189 1
a189 1
  for (e=n; *e && *e != '\\'; e++);
d192 2
a193 2
  for (i=0; wkprefixes[i].string; i++)
    if (strcmp(wkprefixes[i].string, n) == 0)
d197 4
a200 4
      fprintf(stderr, "Unknown key prefix.  Valid prefixes are:\n");
      for (i=0; wkprefixes[i].string; i++)
	fprintf(stderr, "\t%s\n", wkprefixes[i].string);
      exit(1);
d207 1
a207 1
  e = n+strlen(n);
d214 2
a215 2
	  fprintf(stderr, "Invalid key\n");
	  exit(1);
d218 1
a218 1
      value = e+1;
d225 1
a225 1
  int rv = RegOpenKeyEx(wkprefixes[i].key, n, 0, access, &key);
d227 1
a227 1
    Fail(rv);
d233 1
a233 1
cmd_list()
d242 14
a255 14
  find_key(1, KEY_READ);
  RegQueryInfoKey(key, 0, 0, 0, &num_subkeys, &maxsubkeylen, &maxclasslen,
		  &num_values, &maxvalnamelen, &maxvaluelen, 0, 0);

  subkey_name = (char *)malloc(maxsubkeylen+1);
  class_name = (char *)malloc(maxclasslen+1);
  value_name = (char *)malloc(maxvalnamelen+1);
  value_data = (unsigned char *)malloc(maxvaluelen+1);

  for (i=0; i<num_subkeys; i++)
    {
      m = maxsubkeylen+1;
      n = maxclasslen+1;
      RegEnumKeyEx(key, i, subkey_name, &m, 0, class_name, &n, 0);
d257 1
a257 1
	printf("%s\\ (%s)\n", subkey_name, class_name);
d259 1
a259 1
	printf("%s\n", subkey_name);
d262 1
a262 1
  for (i=0; i<num_values; i++)
d264 3
a266 3
      m = maxvalnamelen+1;
      n = maxvaluelen+1;
      RegEnumValue(key, i, value_name, &m, 0, &t, (BYTE *)value_data, &n);
d268 1
a268 1
	printf("%s\n", value_name);
d271 1
a271 1
	  printf("%s = ", value_name);
d275 3
a277 3
	      for (j=0; j<8 && j<n; j++)
		printf("%02x ", value_data[j]);
	      printf("\n");
d280 2
a281 2
	      printf("0x%08lx (%lu)\n", *(DWORD *)value_data,
		     *(DWORD *)value_data);
d286 2
a287 3
		   | (value_data[2] << 8)
		   | (value_data[3]));
	      printf("0x%08x (%d)\n", v, v);
d291 1
a291 1
	      printf("\"%s\"\n", value_data);
d297 2
a298 2
		  printf("\"%s\"", vd);
		  vd = vd+strlen((const char *)vd) + 1;
d300 1
a300 1
		    printf(", ");
d302 1
a302 1
	      printf("\n");
d305 1
a305 1
	      printf("? (type %d)\n", (int)t);
d313 1
a313 1
cmd_add()
d315 1
a315 1
  find_key(2, KEY_ALL_ACCESS);
d318 2
a319 2
  int rv = RegCreateKeyEx(key, value, 0, (char *)"", REG_OPTION_NON_VOLATILE,
			  KEY_ALL_ACCESS, 0, &newkey, &newtype);
d321 1
a321 1
    Fail(rv);
d326 1
a326 1
	printf("Key %s already exists\n", value);
d328 1
a328 1
	printf("Key %s created\n", value);
d334 1
a334 1
cmd_remove()
d336 2
a337 2
  find_key(2, KEY_ALL_ACCESS);
  DWORD rv = RegDeleteKey(key, value);
d339 1
a339 1
    Fail(rv);
d341 1
a341 1
    printf("subkey %s deleted\n", value);
d346 1
a346 1
cmd_check()
d348 1
a348 1
  find_key(1, KEY_READ);
d350 1
a350 1
    printf("key %s exists\n", argv[0]);
d355 1
a355 1
cmd_set()
d360 1
a360 1
  find_key(2, KEY_ALL_ACCESS);
d365 1
a365 1
      strtoul(a, &e, 0);
d379 3
a381 2
      v = strtoul(a, 0, 0);
      rv = RegSetValueEx(key, value, 0, REG_DWORD, (const BYTE *)&v, sizeof(v));
d384 1
a384 1
      rv = RegSetValueEx(key, value, 0, REG_SZ, (const BYTE *)a, strlen(a));
d387 2
a388 1
      rv = RegSetValueEx(key, value, 0, REG_EXPAND_SZ, (const BYTE *)a, strlen(a));
d391 4
a394 4
      for (i=1, n=1; argv[i]; i++)
	n += strlen(argv[i])+1;
      data = (char *)malloc(n);
      for (i=1, n=0; argv[i]; i++)
d396 2
a397 2
	  strcpy(data+n, argv[i]);
	  n += strlen(argv[i])+1;
d400 2
a401 1
      rv = RegSetValueEx(key, value, 0, REG_MULTI_SZ, (const BYTE *)data, n+1);
d404 2
d410 1
a410 1
    Fail(rv);
d416 1
a416 1
cmd_unset()
d418 2
a419 2
  find_key(2, KEY_ALL_ACCESS);
  DWORD rv = RegDeleteValue(key, value);
d421 1
a421 1
    Fail(rv);
d423 1
a423 1
    printf("value %s deleted\n", value);
d428 1
a428 1
cmd_get()
d430 1
a430 1
  find_key(2, KEY_READ);
d433 1
a433 1
  rv = RegQueryValueEx(key, value, 0, &vtype, 0, &dsize);
d435 1
a435 1
    Fail(rv);
d437 2
a438 2
  data = (char *)malloc(dsize);
  rv = RegQueryValueEx(key, value, 0, &vtype, (BYTE *)data, &dsize);
d440 1
a440 1
    Fail(rv);
d444 1
a444 1
      fwrite(data, dsize, 0, stdout);
d447 1
a447 1
      printf("%lu\n", *(DWORD *)data);
d450 1
a450 1
      printf("%s\n", data);
d453 1
a453 1
      if (key_type == KT_EXPAND) // hack
d457 3
a459 3
	  bufsize = ExpandEnvironmentStrings(data, 0, 0);
	  buf = (char *)malloc(bufsize+1);
	  ExpandEnvironmentStrings(data, buf, bufsize+1);
d462 1
a462 1
      printf("%s\n", data);
d468 2
a469 2
	  printf("%s\n", vd);
	  vd = vd+strlen((const char *)vd) + 1;
d476 2
a477 1
struct {
d479 11
a489 10
  int (*func)();
} commands[] = {
  { "list", cmd_list },
  { "add", cmd_add },
  { "remove", cmd_remove },
  { "check", cmd_check },
  { "set", cmd_set },
  { "unset", cmd_unset },
  { "get", cmd_get },
  { 0, 0 }
d493 1
a493 1
main(int argc, char **_argv)
d501 25
a525 25
      {
      case 'v':
	verbose ++;
	break;
      case 'q':
	quiet ++;
	break;

      case 'i':
	key_type = KT_INT;
	break;
      case 's':
	key_type = KT_STRING;
	break;
      case 'e':
	key_type = KT_EXPAND;
	break;
      case 'm':
	key_type = KT_MULTI;
	break;

      case '?':
      case 'h':
	usage();
      }
d528 1
a528 1
    usage();
d530 1
a530 1
  argv = _argv+optind;
d532 2
a533 2
  for (i=0; commands[i].name; i++)
    if (strcmp(commands[i].name, argv[0]) == 0)
d536 1
a536 1
	return commands[i].func();
d538 1
a538 1
  usage();
@


1.1
log
@Initial revision
@
text
@d170 1
a170 1
find_key(int howmanyparts)
d214 1
a214 1
  int rv = RegOpenKeyEx(wkprefixes[i].key, n, 0, KEY_ALL_ACCESS, &key);
d231 1
a231 1
  find_key(1);
d305 1
a305 1
  find_key(2);
d326 1
a326 1
  find_key(2);
d338 1
a338 1
  find_key(1);
d350 1
a350 1
  find_key(2);
d403 1
a403 1
  find_key(2);
d415 1
a415 1
  find_key(2);
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
