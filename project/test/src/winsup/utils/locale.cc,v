head	1.17;
access;
symbols
	cygwin-1_7_35-release:1.17
	cygwin-1_7_34-release:1.17
	cygwin-1_7_33-release:1.17
	cygwin-1_7_32-release:1.17
	cygwin-1_7_31-release:1.17
	cygwin-1_7_30-release:1.17
	cygwin-1_7_29-release:1.17
	cygwin-1_7_29-release-branchpoint:1.17.0.2
	cygwin-1_7_28-release:1.17
	cygwin-1_7_27-release:1.17
	cygwin-1_7_26-release:1.17
	cygwin-1_7_25-release:1.17
	cygwin-1_7_24-release:1.17
	cygwin-1_7_23-release:1.17
	cygwin-1_7_22-release:1.17
	cygwin-1_7_21-release:1.17
	cygwin-1_7_20-release:1.17
	cygwin-1_7_19-release:1.17
	cygwin-64bit-postmerge:1.17
	cygwin-64bit-premerge-branch:1.16.0.4
	cygwin-64bit-premerge:1.16
	cygwin-1_7_18-release:1.16
	cygwin-1_7_17-release:1.16
	cygwin-64bit-branch:1.16.0.2
	cygwin-1_7_16-release:1.16
	cygwin-1_7_15-release:1.15
	cygwin-1_7_14_2-release:1.15
	cygwin-1_7_14-release:1.15
	cygwin-1_7_12-release:1.15
	cygwin-1_7_11-release:1.15
	cygwin-1_7_10-release:1.15
	cygwin-1_7_9-release:1.10
	cygwin-1_7_8-release:1.10
	cygwin-1_7_7-release:1.10
	cygwin-1_7_5-release:1.8
	cygwin-1_7_4-release:1.8
	cygwin-1_7_3-release:1.8
	cygwin-1_7_2-release:1.7;
locks; strict;
comment	@// @;


1.17
date	2013.04.23.09.44.36;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2012.07.06.14.52.33;	author corinna;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2011.12.17.23.39.47;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2011.11.28.17.58.48;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2011.10.10.14.57.47;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2011.10.10.09.50.43;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2011.05.03.10.34.25;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2010.08.28.11.22.37;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2010.04.28.10.00.40;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2010.03.27.21.08.02;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2010.03.23.21.26.03;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2010.03.23.21.20.31;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2010.03.23.21.01.01;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2010.02.23.14.07.08;	author corinna;	state Exp;
branches;
next	1.3;

1.3
date	2010.02.22.10.56.00;	author corinna;	state Exp;
branches;
next	1.2;

1.2
date	2010.02.19.17.27.05;	author corinna;	state Exp;
branches;
next	1.1;

1.1
date	2010.02.17.15.01.56;	author corinna;	state Exp;
branches;
next	;

1.16.2.1
date	2013.02.06.17.03.49;	author corinna;	state Exp;
branches;
next	;


desc
@@


1.17
log
@	* Merge in cygwin-64bit-branch.
@
text
@/*
 * Copyright (c) 2010, 2011, 2012, 2013 Corinna Vinschen
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <getopt.h>
#include <string.h>
#include <wchar.h>
#include <locale.h>
#include <langinfo.h>
#include <limits.h>
#include <sys/cygwin.h>
#include <cygwin/version.h>
#define _WIN32_WINNT 0x0602
#define WINVER 0x0602
#include <windows.h>

#define LOCALE_ALIAS		"/usr/share/locale/locale.alias"
#define LOCALE_ALIAS_LINE_LEN	255

void
usage ()
{
  printf (
"Usage: %1$s [-amvhV]\n"
"   or: %1$s [-ck] NAME\n"
"   or: %1$s [-usfnU]\n"
"\n"
"Get locale-specific information.\n"
"\n"
"System information:\n"
"\n"
"  -a, --all-locales    List all available supported locales\n"
"  -m, --charmaps       List all available character maps\n"
"  -v, --verbose        More verbose output\n"
"\n"
"Modify output format:\n"
"\n"
"  -c, --category-name  List information about given category NAME\n"
"  -k, --keyword-name   Print information about given keyword NAME\n"
"\n"
"Default locale information:\n"
"\n"
"  -u, --user           Print locale of user's default UI language\n"
"  -s, --system         Print locale of system default UI language\n"
"  -f, --format         Print locale of user's regional format settings\n"
"                       (time, numeric & monetary)\n"
"  -n, --no-unicode     Print system default locale for non-Unicode programs\n"
"  -U, --utf            Attach \".UTF-8\" to the result\n"
"\n"
"Other options:\n"
"\n"
"  -h, --help           This text\n"
"  -V, --version        Print program version and exit\n\n",
  program_invocation_short_name);
}

void
print_version ()
{
  printf ("locale (cygwin) %d.%d.%d\n"
	  "Get locale-specific information\n"
	  "Copyright (C) 2010 - %s Red Hat, Inc.\n"
	  "This is free software; see the source for copying conditions.  There is NO\n"
	  "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n",
	  CYGWIN_VERSION_DLL_MAJOR / 1000,
	  CYGWIN_VERSION_DLL_MAJOR % 1000,
	  CYGWIN_VERSION_DLL_MINOR,
	  strrchr (__DATE__, ' ') + 1);
}

struct option longopts[] = {
  {"all-locales", no_argument, NULL, 'a'},
  {"category-name", no_argument, NULL, 'c'},
  {"format", no_argument, NULL, 'f'},
  {"help", no_argument, NULL, 'h'},
  {"keyword-name", no_argument, NULL, 'k'},
  {"charmaps", no_argument, NULL, 'm'},
  {"no-unicode", no_argument, NULL, 'n'},
  {"system", no_argument, NULL, 's'},
  {"user", no_argument, NULL, 'u'},
  {"utf", no_argument, NULL, 'U'},
  {"verbose", no_argument, NULL, 'v'},
  {"version", no_argument, NULL, 'V'},
  {0, no_argument, NULL, 0}
};
const char *opts = "acfhkmnsuUvV";

int
getlocale (LCID lcid, char *name)
{
  char iso639[10];
  char iso3166[10];

  iso3166[0] = '\0';
  if (!GetLocaleInfo (lcid, LOCALE_SISO639LANGNAME, iso639, 10))
    return 0;
  GetLocaleInfo (lcid, LOCALE_SISO3166CTRYNAME, iso3166, 10);
  sprintf (name, "%s%s%s", iso639, lcid > 0x3ff ? "_" : "",
			   lcid > 0x3ff ? iso3166 : "");
  return 1;
}

typedef struct {
  const char *name;
  const wchar_t *language;
  const wchar_t *territory;
  const char *codeset;
  bool alias;
} loc_t;
loc_t *locale;
size_t loc_max;
size_t loc_num;

void
print_codeset (const char *codeset)
{
  for (; *codeset; ++codeset)
    if (*codeset != '-')
      putc (tolower ((int)(unsigned char) *codeset), stdout);
}

void
print_locale_with_codeset (int verbose, loc_t *locale, bool utf8,
			   const char *modifier)
{
  static const char *sysroot;
  char locname[32];

  if (verbose
      && (!strcmp (locale->name, "C") || !strcmp (locale->name, "POSIX")))
    return;
  if (!sysroot)
    {
      WCHAR sysbuf[PATH_MAX];
      HMODULE k32 = GetModuleHandleW (L"kernel32.dll");
      if (GetModuleFileNameW (k32, sysbuf, PATH_MAX))
	sysroot = (const char *) cygwin_create_path (CCP_WIN_W_TO_POSIX,
						     sysbuf);
      if (!sysroot)
      	sysroot = "kernel32.dll";
    }
  snprintf (locname, 32, "%s%s%s%s", locale->name, utf8 ? ".utf8" : "",
				     modifier ? "@@" : "", modifier ?: "");
  if (verbose)
    fputs ("locale: ", stdout);
  if (verbose)
    {
      printf ("%-15s ", locname);
      printf ("archive: %s\n",
      locale->alias ? LOCALE_ALIAS : sysroot);
      puts ("-------------------------------------------------------------------------------");
      printf (" language | %ls\n", locale->language);
      printf ("territory | %ls\n", locale->territory);
      printf ("  codeset | %s\n\n", utf8 ? "UTF-8" : locale->codeset);
    }
  else
    printf ("%s\n", locname);
}

void
print_locale (int verbose, loc_t *locale)
{
  print_locale_with_codeset (verbose, locale, false, NULL);
  char *modifier = strchr (locale->name, '@@');
  if (!locale->alias)
    {
      if (!modifier)
	print_locale_with_codeset (verbose, locale, true, NULL);
      else if (!strcmp (modifier, "@@cjknarrow"))
	{
	  *modifier++ = '\0';
	  print_locale_with_codeset (verbose, locale, true, modifier);
	}
    }
}

int
compare_locales (const void *a, const void *b)
{
  const loc_t *la = (const loc_t *) a;
  const loc_t *lb = (const loc_t *) b;
  return strcmp (la->name, lb->name);
}

void
add_locale (const char *name, const wchar_t *language, const wchar_t *territory,
	    bool alias = false)
{
  char orig_locale[32];

  if (loc_num >= loc_max)
    {
      loc_t *tmp = (loc_t *) realloc (locale, (loc_max + 32) * sizeof (loc_t));
      if (!tmp)
      	{
	  fprintf (stderr, "Out of memory!\n");
	  exit (1);
	}
      locale = tmp;
      loc_max += 32;
    }
  locale[loc_num].name = strdup (name);
  locale[loc_num].language = wcsdup (language);
  locale[loc_num].territory = wcsdup (territory);
  strcpy (orig_locale, setlocale (LC_CTYPE, NULL));
  setlocale (LC_CTYPE, name);
  locale[loc_num].codeset = strdup (nl_langinfo (CODESET));
  setlocale (LC_CTYPE, orig_locale);
  locale[loc_num].alias = alias;
  ++loc_num;
}

void
add_locale_alias_locales ()
{
  char alias_buf[LOCALE_ALIAS_LINE_LEN + 1], *c;
  const char *alias, *replace;
  char orig_locale[32];
  loc_t search, *loc;
  size_t orig_loc_num = loc_num;

  FILE *fp = fopen (LOCALE_ALIAS, "rt");
  if (!fp)
    return;
  strcpy (orig_locale, setlocale (LC_CTYPE, NULL));
  while (fgets (alias_buf, LOCALE_ALIAS_LINE_LEN + 1, fp))
    {
      alias_buf[LOCALE_ALIAS_LINE_LEN] = '\0';
      c = strrchr (alias_buf, '\n');
      if (c)
	*c = '\0';
      c = alias_buf;
      c += strspn (c, " \t");
      if (!*c || *c == '#')
	continue;
      alias = c;
      c += strcspn (c, " \t");
      *c++ = '\0';
      c += strspn (c, " \t");
      if (*c == '#')
	continue;
      replace = c;
      c += strcspn (c, " \t");
      *c++ = '\0';
      c = strchr (replace, '.');
      if (c)
	*c = '\0';
      search.name = replace;
      loc = (loc_t *) bsearch (&search, locale, orig_loc_num, sizeof (loc_t),
			       compare_locales);
      add_locale (alias, loc ? loc->language : L"", loc ? loc->territory : L"",
		  true);
    }
  fclose (fp);
}

void
print_all_locales (int verbose)
{
  LCID lcid = 0;
  char name[32];
  DWORD cp;

  unsigned lang, sublang;

  add_locale ("C", L"C", L"POSIX");
  add_locale ("POSIX", L"C", L"POSIX", true);
  for (lang = 1; lang <= 0xff; ++lang)
    {
      struct {
	wchar_t language[256];
	wchar_t country[256];
	char loc[32];
      } loc_list[32];
      int lcnt = 0;

      for (sublang = 1; sublang <= 0x3f; ++sublang)
	{
	  lcid = (sublang << 10) | lang;
	  if (getlocale (lcid, name))
	    {
	      wchar_t language[256];
	      wchar_t country[256];
	      int i;
	      char *c, loc[32];
	      wchar_t wbuf[9];

	      /* Go figure.  Even the English name of a language or
		 locale might contain native characters. */
	      GetLocaleInfoW (lcid, LOCALE_SENGLANGUAGE, language, 256);
	      GetLocaleInfoW (lcid, LOCALE_SENGCOUNTRY, country, 256);
	      /* Avoid dups */
	      for (i = 0; i < lcnt; ++ i)
		if (!wcscmp (loc_list[i].language, language)
		    && !wcscmp (loc_list[i].country, country))
		  break;
	      if (i < lcnt)
		continue;
	      if (lcnt < 32)
		{
		  wcscpy (loc_list[lcnt].language, language);
		  wcscpy (loc_list[lcnt].country, country);
		}
	      c = stpcpy (loc, name);
	      /* Convert old sr_SP silently to sr_CS on old systems.
		 Make sure sr_CS country is in recent shape. */
	      if (lang == LANG_SERBIAN
		  && (sublang == SUBLANG_SERBIAN_LATIN
		      || sublang == SUBLANG_SERBIAN_CYRILLIC))
		{
		  c = stpcpy (loc, "sr_CS");
		  wcscpy (country, L"Serbia and Montenegro (Former)");
		}
	      /* Now check certain conditions to figure out if that
		 locale requires a modifier. */
	      if (lang == LANG_SERBIAN && !strncmp (loc, "sr_", 3)
		  && wcsstr (language, L"(Latin)"))
		stpcpy (c, "@@latin");
	      else if (lang == LANG_UZBEK
		       && sublang == SUBLANG_UZBEK_CYRILLIC)
		stpcpy (c, "@@cyrillic");
	      /* Avoid more dups */
	      for (i = 0; i < lcnt; ++ i)
		if (!strcmp (loc_list[i].loc, loc))
		  {
		    lcnt++;
		    break;
		  }
	      if (i < lcnt)
		continue;
	      if (lcnt < 32)
		strcpy (loc_list[lcnt++].loc, loc);
	      /* Print */
	      add_locale (loc, language, country);
	      /* Check for locales which sport a modifier for
		 changing the codeset and other stuff. */
	      if (lang == LANG_BELARUSIAN
		  && sublang == SUBLANG_BELARUSIAN_BELARUS)
		stpcpy (c, "@@latin");
	      else if (lang == LANG_TATAR
		       && sublang == SUBLANG_TATAR_RUSSIA)
		stpcpy (c, "@@iqtelif");
	      else if (GetLocaleInfoW (lcid,
				       LOCALE_IDEFAULTANSICODEPAGE
				       | LOCALE_RETURN_NUMBER,
				       (PWCHAR) &cp, sizeof cp)
		       && cp == 1252 /* Latin1*/
		       && GetLocaleInfoW (lcid, LOCALE_SINTLSYMBOL, wbuf, 9)
		       && !wcsncmp (wbuf, L"EUR", 3))
		stpcpy (c, "@@euro");
	      else if (lang == LANG_JAPANESE
		       || lang == LANG_KOREAN
		       || lang == LANG_CHINESE)
		stpcpy (c, "@@cjknarrow");
	      else
		continue;
	      add_locale (loc, language, country);
	    }
	}
      /* Check Serbian language for the available territories.  Up to
	 Server 2003 we only had sr_SP (silently converted to sr_CS
	 above), in Vista we had only sr_CS.  First starting with W7 we
	 have the actual sr_RS and sr_ME.  However, all of them are
	 supported on all systems in Cygwin.  So we fake them here, if
	 they are missing. */
      if (lang == LANG_SERBIAN)
	{
	  int sr_CS_idx = -1;
	  int sr_RS_idx = -1;
	  int i;

	  for (i = 0; i < lcnt; ++ i)
	    if (!strcmp (loc_list[i].loc, "sr_CS"))
	      sr_CS_idx = i;
	    else if (!strcmp (loc_list[i].loc, "sr_RS"))
	      sr_RS_idx = i;
	  if (sr_CS_idx > 0 && sr_RS_idx == -1)
	    {
	      add_locale ("sr_RS@@latin", L"Serbian (Latin)", L"Serbia");
	      add_locale ("sr_RS", L"Serbian (Cyrillic)", L"Serbia");
	      add_locale ("sr_ME@@latin", L"Serbian (Latin)", L"Montenegro");
	      add_locale ("sr_ME", L"Serbian (Cyrillic)", L"Montenegro");
	    }
	}
    }
  /* First sort allows add_locale_alias_locales to bsearch in locales. */
  qsort (locale, loc_num, sizeof (loc_t), compare_locales);
  add_locale_alias_locales ();
  qsort (locale, loc_num, sizeof (loc_t), compare_locales);
  for (size_t i = 0; i < loc_num; ++i)
    print_locale (verbose, &locale[i]);
}

void
print_charmaps ()
{
  /* FIXME: We need a method to fetch the available charsets from Cygwin, */
  const char *charmaps[] =
  {
    "ASCII",
    "BIG5",
    "CP1125",
    "CP1250",
    "CP1251",
    "CP1252",
    "CP1253",
    "CP1254",
    "CP1255",
    "CP1256",
    "CP1257",
    "CP1258",
    "CP437",
    "CP720",
    "CP737",
    "CP775",
    "CP850",
    "CP852",
    "CP855",
    "CP857",
    "CP858",
    "CP862",
    "CP866",
    "CP874",
    "CP932",
    "EUC-CN",
    "EUC-JP",
    "EUC-KR",
    "GB2312",
    "GBK",
    "GEORGIAN-PS",
    "ISO-8859-1",
    "ISO-8859-10",
    "ISO-8859-11",
    "ISO-8859-13",
    "ISO-8859-14",
    "ISO-8859-15",
    "ISO-8859-16",
    "ISO-8859-2",
    "ISO-8859-3",
    "ISO-8859-4",
    "ISO-8859-5",
    "ISO-8859-6",
    "ISO-8859-7",
    "ISO-8859-8",
    "ISO-8859-9",
    "KOI8-R",
    "KOI8-U",
    "PT154",
    "SJIS",
    "TIS-620",
    "UTF-8",
    NULL
  };
  const char **charmap = charmaps;
  while (*charmap)
    printf ("%s\n", *charmap++);
}

void
print_lc_ivalue (int key, const char *name, int value)
{
  if (key)
    printf ("%s=", name);
  printf ("%d", value == CHAR_MAX ? -1 : value);
  fputc ('\n', stdout);
}

void
print_lc_svalue (int key, const char *name, const char *value)
{
  if (key)
    printf ("%s=\"", name);
  fputs (value, stdout);
  if (key)
    fputc ('"', stdout);
  fputc ('\n', stdout);
}

void
print_lc_sepstrings (int key, const char *name, const char *value)
{
  char *c;

  if (key)
    printf ("%s=", name);
  while (value && *value)
    {
      if (key)
	fputc ('"', stdout);
      c = strchr (value, ';');
      if (!c)
	{
	  fputs (value, stdout);
	  value = NULL;
	}
      else
	{
	  printf ("%.*s", (int) (c - value), value);
	  value = c + 1;
	}
      if (key)
	fputc ('"', stdout);
      if (value && *value)
	fputc (';', stdout);
    }
  fputc ('\n', stdout);
}

void
print_lc_strings (int key, const char *name, int from, int to)
{
  if (key)
    printf ("%s=\"", name);
  for (int i = from; i <= to; ++i)
    printf ("%s%s", i > from ? ";" : "", nl_langinfo (i));
  if (key)
    fputc ('"', stdout);
  fputc ('\n', stdout);
}

void
print_lc_grouping (int key, const char *name, const char *grouping)
{
  if (key)
    printf ("%s=", name);
  for (const char *g = grouping; *g; ++g)
    printf ("%s%d", g > grouping ? ";" : "", *g == CHAR_MAX ? -1 : *g);
  fputc ('\n', stdout);
}

enum type_t
{
  is_string_fake,
  is_grouping,
  is_string,
  is_mstrings,
  is_sepstrings,
  is_int,
  is_wchar,
  is_end
};

struct lc_names_t
{
  const char *name;
  type_t      type;
  size_t      fromval;
  size_t      toval;
};

const char *fake_string[] = {
 "upper;lower;alpha;digit;xdigit;space;print;graph;blank;cntrl;punct;alnum",
 "upper\";\"lower\";\"alpha\";\"digit\";\"xdigit\";\"space\";\"print\";\"graph\";\"blank\";\"cntrl\";\"punct\";\"alnum",
 "toupper;tolower",
 "toupper\";\"tolower"
};

lc_names_t lc_ctype_names[] =
{
  { "ctype-class-names", 	 is_string_fake, 0,			 0 },
  { "ctype-map-names",   	 is_string_fake, 2,			 0 },
  { "ctype-outdigit0_mb",	 is_string,	_NL_CTYPE_OUTDIGITS0_MB, 0 },
  { "ctype-outdigit1_mb",	 is_string,	_NL_CTYPE_OUTDIGITS1_MB, 0 },
  { "ctype-outdigit2_mb",	 is_string,	_NL_CTYPE_OUTDIGITS2_MB, 0 },
  { "ctype-outdigit3_mb",	 is_string,	_NL_CTYPE_OUTDIGITS3_MB, 0 },
  { "ctype-outdigit4_mb",	 is_string,	_NL_CTYPE_OUTDIGITS4_MB, 0 },
  { "ctype-outdigit5_mb",	 is_string,	_NL_CTYPE_OUTDIGITS5_MB, 0 },
  { "ctype-outdigit6_mb",	 is_string,	_NL_CTYPE_OUTDIGITS6_MB, 0 },
  { "ctype-outdigit7_mb",	 is_string,	_NL_CTYPE_OUTDIGITS7_MB, 0 },
  { "ctype-outdigit8_mb",	 is_string,	_NL_CTYPE_OUTDIGITS8_MB, 0 },
  { "ctype-outdigit9_mb",	 is_string,	_NL_CTYPE_OUTDIGITS9_MB, 0 },
  { "ctype-outdigit0_wc",	 is_wchar, 	_NL_CTYPE_OUTDIGITS0_WC, 0 },
  { "ctype-outdigit1_wc",	 is_wchar, 	_NL_CTYPE_OUTDIGITS1_WC, 0 },
  { "ctype-outdigit2_wc",	 is_wchar, 	_NL_CTYPE_OUTDIGITS2_WC, 0 },
  { "ctype-outdigit3_wc",	 is_wchar, 	_NL_CTYPE_OUTDIGITS3_WC, 0 },
  { "ctype-outdigit4_wc",	 is_wchar, 	_NL_CTYPE_OUTDIGITS4_WC, 0 },
  { "ctype-outdigit5_wc",	 is_wchar, 	_NL_CTYPE_OUTDIGITS5_WC, 0 },
  { "ctype-outdigit6_wc",	 is_wchar, 	_NL_CTYPE_OUTDIGITS6_WC, 0 },
  { "ctype-outdigit7_wc",	 is_wchar, 	_NL_CTYPE_OUTDIGITS7_WC, 0 },
  { "ctype-outdigit8_wc",	 is_wchar, 	_NL_CTYPE_OUTDIGITS8_WC, 0 },
  { "ctype-outdigit9_wc",	 is_wchar, 	_NL_CTYPE_OUTDIGITS9_WC, 0 },
  { "charmap",			 is_string,	CODESET,		 0 },
  { "ctype-mb-cur-max",		 is_int,	_NL_CTYPE_MB_CUR_MAX,	 0 },
  { NULL, 			 is_end,	0,		 	 0 }
};

lc_names_t lc_numeric_names[] =
{
  { "decimal_point",		 is_string,	RADIXCHAR,		 0 },
  { "thousands_sep",		 is_string,	THOUSEP, 		 0 },
  { "grouping",			 is_grouping,	_NL_NUMERIC_GROUPING,	 0 },
  { "numeric-decimal-point-wc",	 is_wchar,	_NL_NUMERIC_DECIMAL_POINT_WC, 0 },
  { "numeric-thousands-sep-wc",	 is_wchar,	_NL_NUMERIC_THOUSANDS_SEP_WC, 0 },
  { "numeric-codeset",		 is_string,	_NL_NUMERIC_CODESET,	 0 },
  { NULL, 			 is_end,	0,			 0 }
};

lc_names_t lc_time_names[] =
{
  { "abday",			 is_mstrings,	ABDAY_1,	 ABDAY_7  },
  { "day",			 is_mstrings,	DAY_1,		 DAY_7    },
  { "abmon",			 is_mstrings,	ABMON_1,	 ABMON_12 },
  { "mon",			 is_mstrings,	MON_1,		 MON_12   },
  { "am_pm",			 is_mstrings,	AM_STR,		 PM_STR   },
  { "d_t_fmt",			 is_string,	D_T_FMT,		0 },
  { "d_fmt",			 is_string,	D_FMT,			0 },
  { "t_fmt",			 is_string,	T_FMT,			0 },
  { "t_fmt_ampm",		 is_string,	T_FMT_AMPM,		0 },
  { "era",			 is_sepstrings,	ERA,			0 },
  { "era_d_fmt",		 is_string,	ERA_D_FMT,		0 },
  { "alt_digits",		 is_sepstrings,ALT_DIGITS,		0 },
  { "era_d_t_fmt",		 is_string,	ERA_D_T_FMT,		0 },
  { "era_t_fmt",		 is_string,	ERA_T_FMT,		0 },
  { "date_fmt",			 is_string,	_DATE_FMT,		0 },
  { "time-codeset",		 is_string,	_NL_TIME_CODESET,	0 },
  { NULL, 			 is_end,	0,			0 }
};

lc_names_t lc_collate_names[] =
{
  { "collate-codeset",		 is_string,	_NL_COLLATE_CODESET,	0 },
  { NULL, 			 is_end,	0,			0 }
};

lc_names_t lc_monetary_names[] =
{
  { "int_curr_symbol",		 is_string,	_NL_MONETARY_INT_CURR_SYMBOL, 0 },
  { "currency_symbol",		 is_string,	_NL_MONETARY_CURRENCY_SYMBOL, 0 },
  { "mon_decimal_point",	 is_string,	_NL_MONETARY_MON_DECIMAL_POINT, 0 },
  { "mon_thousands_sep",	 is_string,	_NL_MONETARY_MON_THOUSANDS_SEP, 0 },
  { "mon_grouping",		 is_grouping,	_NL_MONETARY_MON_GROUPING, 0 },
  { "positive_sign",		 is_string,	_NL_MONETARY_POSITIVE_SIGN, 0 },
  { "negative_sign",		 is_string,	_NL_MONETARY_NEGATIVE_SIGN, 0 },
  { "int_frac_digits",		 is_int,	_NL_MONETARY_INT_FRAC_DIGITS, 0 },
  { "frac_digits",		 is_int,	_NL_MONETARY_FRAC_DIGITS,   0 },
  { "p_cs_precedes",		 is_int,	_NL_MONETARY_P_CS_PRECEDES, 0 },
  { "p_sep_by_space",		 is_int,	_NL_MONETARY_P_SEP_BY_SPACE, 0 },
  { "n_cs_precedes",		 is_int,	_NL_MONETARY_N_CS_PRECEDES, 0 },
  { "n_sep_by_space",		 is_int,	_NL_MONETARY_N_SEP_BY_SPACE, 0 },
  { "p_sign_posn",		 is_int,	_NL_MONETARY_P_SIGN_POSN,   0 },
  { "n_sign_posn",		 is_int,	_NL_MONETARY_N_SIGN_POSN,   0 },
  { "int_p_cs_precedes",	 is_int,	_NL_MONETARY_INT_P_CS_PRECEDES, 0 },
  { "int_p_sep_by_space",	 is_int,	_NL_MONETARY_INT_P_SEP_BY_SPACE,0 },
  { "int_n_cs_precedes",	 is_int,	_NL_MONETARY_INT_N_CS_PRECEDES, 0 },
  { "int_n_sep_by_space",	 is_int,	_NL_MONETARY_INT_N_SEP_BY_SPACE,0 },
  { "int_p_sign_posn",		 is_int,	_NL_MONETARY_INT_P_SIGN_POSN, 0 },
  { "int_n_sign_posn",		 is_int,	_NL_MONETARY_INT_N_SIGN_POSN, 0 },
  { "monetary-decimal-point-wc", is_wchar,	_NL_MONETARY_WMON_DECIMAL_POINT, 0 },
  { "monetary-thousands-sep-wc", is_wchar,	_NL_MONETARY_WMON_THOUSANDS_SEP, 0 },
  { "monetary-codeset",		 is_string,	_NL_MONETARY_CODESET,	   0 },
  { NULL, 			 is_end,	0,			   0 }
};

lc_names_t lc_messages_names[] =
{
  { "yesexpr",			 is_string,	YESEXPR,		0 },
  { "noexpr",			 is_string,	NOEXPR,			0 },
  { "yesstr",			 is_string,	YESSTR,			0 },
  { "nostr",			 is_string,	NOSTR,			0 },
  { "messages-codeset",		 is_string,	_NL_MESSAGES_CODESET,	0 },
  { NULL, 			 is_end,	0,			0 }
};

void
print_lc (int cat, int key, const char *category, const char *name,
	  lc_names_t *lc_name)
{
  if (cat)
    printf ("%s\n", category);
  for (lc_names_t *lc = lc_name; lc->type != is_end; ++lc)
    if (!name || !strcmp (name, lc->name))
      switch (lc->type)
	{
	case is_string_fake:
	  print_lc_svalue (key, lc->name, fake_string[lc->fromval + key]);
	  break;
	case is_grouping:
	  print_lc_grouping (key, lc->name, nl_langinfo (lc->fromval));
	  break;
	case is_string:
	  print_lc_svalue (key, lc->name, nl_langinfo (lc->fromval));
	  break;
	case is_sepstrings:
	  print_lc_sepstrings (key, lc->name, nl_langinfo (lc->fromval));
	  break;
	case is_mstrings:
	  print_lc_strings (key, lc->name, lc->fromval, lc->toval);
	  break;
	case is_int:
	  print_lc_ivalue (key, lc->name, (int) *nl_langinfo (lc->fromval));
	  break;
	case is_wchar:
	  print_lc_ivalue (key, lc->name,
			   *(wchar_t *) nl_langinfo (lc->fromval));
	  break;
	default:
	  break;
	}
}

struct cat_t
{
  const char *category;
  int lc_cat;
  lc_names_t *lc_names;
} categories[] =
{
  { "LC_CTYPE",    LC_CTYPE,    lc_ctype_names    },
  { "LC_NUMERIC",  LC_NUMERIC,  lc_numeric_names  },
  { "LC_TIME",     LC_TIME,     lc_time_names     },
  { "LC_COLLATE",  LC_COLLATE,  lc_collate_names  },
  { "LC_MONETARY", LC_MONETARY, lc_monetary_names },
  { "LC_MESSAGES", LC_MESSAGES, lc_messages_names },
  { NULL,	   0,		NULL		  }
};

void
print_names (int cat, int key, const char *name)
{
  struct cat_t *c;
  lc_names_t *lc;

  for (c = categories; c->category; ++c)
    if (!strcmp (name, c->category))
      {
	print_lc (cat, key, c->category, NULL, c->lc_names);
	return;
      }
  for (c = categories; c->category; ++c)
    for (lc = c->lc_names; lc->type != is_end; ++lc)
      if (!strcmp (name, lc->name))
      {
	print_lc (cat, key, c->category, lc->name, lc);
	return;
      }
}

void
print_lc ()
{
  printf ("LANG=%s\n", getenv ("LANG") ?: "");
  printf ("LC_CTYPE=\"%s\"\n", setlocale (LC_CTYPE, NULL));
  printf ("LC_NUMERIC=\"%s\"\n", setlocale (LC_NUMERIC, NULL));
  printf ("LC_TIME=\"%s\"\n", setlocale (LC_TIME, NULL));
  printf ("LC_COLLATE=\"%s\"\n", setlocale (LC_COLLATE, NULL));
  printf ("LC_MONETARY=\"%s\"\n", setlocale (LC_MONETARY, NULL));
  printf ("LC_MESSAGES=\"%s\"\n", setlocale (LC_MESSAGES, NULL));
  printf ("LC_ALL=%s\n", getenv ("LC_ALL") ?: "");
}

int
main (int argc, char **argv)
{
  int opt;
  LCID lcid = 0;
  int all = 0;
  int cat = 0;
  int key = 0;
  int maps = 0;
  int verbose = 0;
  const char *utf = "";
  char name[32];

  setlocale (LC_ALL, "");
  while ((opt = getopt_long (argc, argv, opts, longopts, NULL)) != -1)
    switch (opt)
      {
      case 'a':
	all = 1;
	break;
      case 'c':
	cat = 1;
	break;
      case 'k':
	key = 1;
	break;
      case 'm':
	maps = 1;
	break;
      case 's':
	lcid = GetSystemDefaultUILanguage ();
	break;
      case 'u':
	lcid = GetUserDefaultUILanguage ();
	break;
      case 'f':
	lcid = GetUserDefaultLCID ();
	break;
      case 'n':
	lcid = GetSystemDefaultLCID ();
	break;
      case 'U':
	utf = ".UTF-8";
	break;
      case 'v':
	verbose = 1;
	break;
      case 'h':
	usage ();
	return 0;
      case 'V':
	print_version ();
	return 0;
      default:
	fprintf (stderr, "Try `%s --help' for more information.\n",
		 program_invocation_short_name);
	return 1;
      }
  if (all)
    print_all_locales (verbose);
  else if (maps)
    print_charmaps ();
  else if (lcid)
    {
      if (getlocale (lcid, name))
	printf ("%s%s\n", name, utf);
    }
  else if (optind < argc)
    while (optind < argc)
      print_names (cat, key, argv[optind++]);
  else
    print_lc ();
  return 0;
}
@


1.16
log
@	* cygpath.cc: Change including headers to allow building against
	Mingw64 headers. Include ntdef.h and ntdll.h rather than ddk headers.
	Define _WIN32_WINNT and WINVER as 0x0602.
	(RtlEqualUnicodePathPrefix): Drop definition.  Pulled in from ntdll.h
	now.
	(get_device_name): s/Zw/Nt.
	* dumper.cc: Include sys/param.h
	(dumper::dump_memory_region): Use MIN rather than min.
	* locale.cc: Include stdlib.h.  Define _WIN32_WINNT and WINVER as
	0x0602.
	* ps.cc: Include ntdef.h and ntdll.h rather than ddk headers.
	* regtool.cc (regDeleteKeyEx): Drop WINADVAPI qualifier.
@
text
@d2 1
a2 1
 * Copyright (c) 2010, 2011 Corinna Vinschen
d523 1
a523 1
	  printf ("%.*s", c - value, value);
@


1.16.2.1
log
@	Throughout, fix type problems on 32 and 64 bit.  Except:
	* ssp.c: Disable entire functionality on x86_64 for now.
@
text
@d2 1
a2 1
 * Copyright (c) 2010, 2011, 2012, 2013 Corinna Vinschen
d523 1
a523 1
	  printf ("%.*s", (int) (c - value), value);
@


1.15
log
@Clean up whitespace.
@
text
@d28 1
d38 2
a39 1
#define WINVER 0x0601
@


1.14
log
@	* locale.cc (print_locale_with_codeset): Fetch Windows path as UNICODE
	path and convert that to POSIX.
@
text
@d254 1
a254 1
        *c = '\0';
d258 1
a258 1
        continue;
d264 1
a264 1
        continue;
d527 1
a527 1
      	fputc (';', stdout);
d696 1
a696 1
      	{
d749 1
a749 1
      	print_lc (cat, key, c->category, NULL, c->lc_names);
d756 1
a756 1
      	print_lc (cat, key, c->category, lc->name, lc);
d792 1
a792 1
        all = 1;
d795 1
a795 1
        cat = 1;
d798 1
a798 1
        key = 1;
d804 1
a804 1
      	lcid = GetSystemDefaultUILanguage ();
d807 1
a807 1
      	lcid = GetUserDefaultUILanguage ();
d810 1
a810 1
      	lcid = GetUserDefaultLCID ();
d813 1
a813 1
      	lcid = GetSystemDefaultLCID ();
d816 1
a816 1
      	utf = ".UTF-8";
@


1.13
log
@	* Align usage output, version output, as well as usage and version
	option handling to use the same style throughout all Cygwin utils.
	Throughout use program_invocation_short_name to refer to current
	process name in Cygwin executables.
	* utils.sgml: Align documentation to above change.  Add missing
	sections for getconf, ldd, and setmetamode.
	* strace.cc (proc_child): Avoid compiler warning.
@
text
@d157 1
a157 1
      char sysbuf[PATH_MAX];
d159 2
a160 2
      if (GetModuleFileName (k32, sysbuf, PATH_MAX))
	sysroot = (const char *) cygwin_create_path (CCP_WIN_A_TO_POSIX,
@


1.12
log
@	* locale.cc (usage): Restructure, rephrase, add new options.  Drop
	arguments, don't exit.
	(print_version): New function.
	(longopts): Add -f, -n, and -V options.  Reorder.
	(opts): Add -f, -n, and -V options.
	(main): Call GetSystemDefaultUILanguage for -s option.  Call
	GetUserDefaultUILanguage for -u option.  Add -f and -n options and
	call GetUserDefaultLCID and GetSystemDefaultLCID respectively.  Return
	0 after calling usage in -h case.  Add -V option and call print_version.
	Don't print full usage in default case, rather just a short help message
	similar to GNU tools.
	* utils.sgml (locale): Align to above changes.  Rephrase description.
@
text
@d26 1
a42 2
extern char *__progname;

d50 1
d77 1
a77 1
  __progname);
d83 5
a87 5
  printf ("%s (cygwin) %d.%d.%d\n"
	  "Get locale-specific information.\n"
	  "Copyright 2011 Red Hat, Inc.\n"
	  "Compiled on %s\n",
	  __progname,
d91 1
a91 1
	  __DATE__);
d788 1
a788 1
  while ((opt = getopt_long (argc, argv, opts, longopts, NULL)) != EOF)
d828 2
a829 3
	fprintf (stderr,
		 "Try `%1$s --help' or `%1$s -h' for more information.\n",
		 __progname);
@


1.11
log
@	* locale.cc (print_locale_with_codeset): Align printing of locale names
	to POSIX.
@
text
@d35 1
d44 35
a78 1
void usage (FILE *, int) __attribute__ ((noreturn));
d81 11
a91 20
usage (FILE * stream, int status)
{
  fprintf (stream,
	   "Usage: %s [-amsuUvh]\n"
	   "   or: %s [-ck] NAME\n"
	   "Get locale-specific information.\n"
	   "\n"
	   "Options:\n"
	   "\n"
	   "  -a, --all-locales    List all available supported locales\n"
	   "  -c, --category-name  List information about given category NAME\n"
	   "  -k, --keyword-name   Print information about given keyword NAME\n"
	   "  -m, --charmaps       List all available character maps\n"
	   "  -s, --system         Print system default locale\n"
	   "  -u, --user           Print user's default locale\n"
	   "  -U, --utf            Attach \".UTF-8\" to the result\n"
	   "  -v, --verbose        More verbose output\n"
	   "  -h, --help           This text\n",
	   __progname, __progname);
  exit (status);
d97 2
d101 1
d106 1
a106 1
  {"help", no_argument, NULL, 'h'},
d109 1
a109 1
const char *opts = "achkmsuUv";
d804 1
a804 1
      	lcid = LOCALE_SYSTEM_DEFAULT;
d807 7
a813 1
      	lcid = LOCALE_USER_DEFAULT;
d822 5
a826 2
	usage (stdout, 0);
	break;
d828 4
a831 2
	usage (stderr, 1);
	break;
@


1.10
log
@	* loadlib.h: New header implementing safe LoadLibrary calls.
	Include throughout files using LoadLibrary function.
	* cygcheck.cc (dump_sysinfo): Retrieve kernel32.dll handle via
	GetModuleHandle, rather than using LoadLibrary.
	* cygpath.cc (get_long_name): Ditto.
	(do_sysfolders): Append .dll suffix in LoadLibrary call.
	* ldh.cc (WinMain): Use LoadLibraryExW with DONT_RESOLVE_DLL_REFERENCES
	to avoid loading malicious library code.
	* locale.cc (print_locale_with_codeset): Change way to retrieve
	kernel32.dll path.
@
text
@d2 1
a2 1
 * Copyright (c) 2010, Corinna Vinschen
a139 1
  printf ("%-15s ", locname);
d142 1
d148 1
a148 1
      printf ("  codeset | %s\n", utf8 ? "UTF-8" : locale->codeset);
d150 2
a151 1
  putc ('\n', stdout);
@


1.9
log
@	* locale.cc (print_lc_xxx_charset): Remove.
	(enum type_t): Change according to the fact that nl_langinfo now returns
	all locale category values.
	(lc_ctype_names): Add new category members.  Redefine for exclusive
	nl_langinfo usage.
	(lc_numeric_names): Ditto.
	(lc_time_names): Ditto.
	(lc_collate_names): Ditto.
	(lc_monetary_names): Ditto.
	(lc_messages_names): Ditto.
	(print_lc): Change switch according to new type_t values.
@
text
@d129 4
a132 3
      stpcpy (stpcpy (sysbuf, getenv ("SYSTEMROOT")),
	      "\\system32\\kernel32.dll");
      sysroot = (const char *) cygwin_create_path (CCP_WIN_A_TO_POSIX, sysbuf);
@


1.8
log
@	* locale.cc (print_charmaps): Add EUC-CN and GB2312.
@
text
@a513 13
print_lc_xxx_charset (int key, int lc_cat, const char *name)
{
  char lc_ctype_locale[32];
  char lc_xxx_locale[32];

  strcpy (lc_ctype_locale, setlocale (LC_CTYPE, NULL));
  strcpy (lc_xxx_locale, setlocale (lc_cat, NULL));
  setlocale (LC_CTYPE, lc_xxx_locale);
  print_lc_svalue (key, name, nl_langinfo (CODESET));
  setlocale (LC_CTYPE, lc_ctype_locale);
}

void
d526 6
a531 8
  is_string_lconv,
  is_int_lconv,
  is_grouping_lconv,
  is_string_linf,
  is_mstrings_linf,
  is_sepstrings_linf,
  is_mb_cur_max,
  is_codeset,
a542 4
#define _O(M)		__builtin_offsetof (struct lconv, M)
#define _MS(l,lc)	(*(const char **)(((const char *)(l))+(lc)->fromval))
#define _MI(l,lc)	((int)*(((const char *)(l))+(lc)->fromval))

d552 25
a576 5
  { "ctype-class-names",is_string_fake,	   0,			0 },
  { "ctype-map-names",	is_string_fake,	   2,			0 },
  { "charmap",		is_string_linf,	   CODESET,		0 },
  { "ctype-mb-cur-max", is_mb_cur_max,	   0,			0 },
  { NULL, 		is_end,		   0,			0 }
d581 7
a587 5
  { "decimal_point",	is_string_lconv,   _O(decimal_point),	0 },
  { "thousands_sep",	is_string_lconv,   _O(thousands_sep), 	0 },
  { "grouping",		is_grouping_lconv, _O(grouping),	0 },
  { "numeric-codeset",	is_codeset,	   LC_NUMERIC,		0 },
  { NULL, 		is_end,		   0,			0 }
d592 17
a608 17
  { "abday",		is_mstrings_linf,  ABDAY_1,		ABDAY_7  },
  { "day",		is_mstrings_linf,  DAY_1,		DAY_7    },
  { "abmon",		is_mstrings_linf,  ABMON_1,		ABMON_12 },
  { "mon",		is_mstrings_linf,  MON_1,		MON_12   },
  { "am_pm",		is_mstrings_linf,  AM_STR,		PM_STR   },
  { "d_t_fmt",		is_string_linf,    D_T_FMT,		0        },
  { "d_fmt",		is_string_linf,    D_FMT,		0        },
  { "t_fmt",		is_string_linf,    T_FMT,		0        },
  { "t_fmt_ampm",	is_string_linf,    T_FMT_AMPM,		0	 },
  { "era",		is_sepstrings_linf,ERA,			0	 },
  { "era_d_fmt",	is_string_linf,    ERA_D_FMT,		0	 },
  { "alt_digits",	is_sepstrings_linf,ALT_DIGITS,		0	 },
  { "era_d_t_fmt",	is_string_linf,    ERA_D_T_FMT,		0	 },
  { "era_t_fmt",	is_string_linf,    ERA_T_FMT,		0	 },
  { "date_fmt",		is_string_linf,    _DATE_FMT,		0	 },
  { "time-codeset",	is_codeset,	   LC_TIME,		0	 },
  { NULL, 		is_end,		   0,			0	 }
d613 2
a614 2
  { "collate-codeset",	is_codeset,	   LC_COLLATE,		0	 },
  { NULL, 		is_end,		   0,			0	 }
d619 25
a643 23
  { "int_curr_symbol",	is_string_lconv,   _O(int_curr_symbol),		0 },
  { "currency_symbol",	is_string_lconv,   _O(currency_symbol),		0 },
  { "mon_decimal_point",is_string_lconv,   _O(mon_decimal_point), 	0 },
  { "mon_thousands_sep",is_string_lconv,   _O(mon_thousands_sep),	0 },
  { "mon_grouping",	is_grouping_lconv, _O(mon_grouping),		0 },
  { "positive_sign",	is_string_lconv,   _O(positive_sign),		0 },
  { "negative_sign",	is_string_lconv,   _O(negative_sign),		0 },
  { "int_frac_digits",	is_int_lconv,      _O(int_frac_digits),		0 },
  { "frac_digits",	is_int_lconv,	   _O(frac_digits),		0 },
  { "p_cs_precedes",	is_int_lconv,	   _O(p_cs_precedes),		0 },
  { "p_sep_by_space",	is_int_lconv,	   _O(p_sep_by_space),		0 },
  { "n_cs_precedes",	is_int_lconv,	   _O(n_cs_precedes),		0 },
  { "n_sep_by_space",	is_int_lconv,	   _O(n_sep_by_space),		0 },
  { "p_sign_posn",	is_int_lconv,	   _O(p_sign_posn),		0 },
  { "n_sign_posn",	is_int_lconv,	   _O(n_sign_posn),		0 },
  { "int_p_cs_precedes",is_int_lconv,	   _O(int_p_cs_precedes),	0 },
  { "int_p_sep_by_space",is_int_lconv,	   _O(int_p_sep_by_space),	0 },
  { "int_n_cs_precedes",is_int_lconv,	   _O(int_n_cs_precedes),	0 },
  { "int_n_sep_by_space",is_int_lconv,	   _O(int_n_sep_by_space),	0 },
  { "int_p_sign_posn",	is_int_lconv,	   _O(int_p_sign_posn),		0 },
  { "int_n_sign_posn",	is_int_lconv,	   _O(int_n_sign_posn),		0 },
  { "monetary-codeset",	is_codeset,	   LC_MONETARY,			0 },
  { NULL, 		is_end,		   0,				0 }
d648 6
a653 6
  { "yesexpr",		is_string_linf,	   YESEXPR,			0 },
  { "noexpr",		is_string_linf,	   NOEXPR,			0 },
  { "yesstr",		is_string_linf,	   YESSTR,			0 },
  { "nostr",		is_string_linf,	   NOSTR,			0 },
  { "messages-codeset",	is_codeset,	   LC_MESSAGES,			0 },
  { NULL, 		is_end,		   0,				0 }
a659 2
  struct lconv *l = localeconv ();

d669 2
a670 8
	case is_string_lconv:
	  print_lc_svalue (key, lc->name, _MS (l, lc));
	  break;
	case is_int_lconv:
	  print_lc_ivalue (key, lc->name, _MI (l, lc));
	  break;
	case is_grouping_lconv:
	  print_lc_grouping (key, lc->name, _MS (l, lc));
d672 1
a672 1
	case is_string_linf:
d675 1
a675 1
	case is_sepstrings_linf:
d678 1
a678 1
	case is_mstrings_linf:
d681 2
a682 2
	case is_mb_cur_max:
	  print_lc_ivalue (key, lc->name, MB_CUR_MAX);
d684 3
a686 2
	case is_codeset:
	  print_lc_xxx_charset (key, lc->fromval, lc->name);
@


1.7
log
@	* locale.cc (add_locale_alias_locales): Always use loc_num at function
	start to avoid confusing bsearch.
@
text
@d417 1
d420 1
@


1.6
log
@	* locale.cc: Revert accidental checkin of unfinished changes.
@
text
@d212 1
d241 1
a241 1
      loc = (loc_t *) bsearch (&search, locale, loc_num, sizeof (loc_t),
@


1.5
log
@	* locale.cc (print_locale_with_codeset): Drop redundant name parameter.
	Simplify creating locale string.  Add "@@" in case of a modifier.
	(print_locale): Drop name parameter in calls to
	print_locale_with_codeset.
@
text
@d511 13
d536 8
a543 6
  is_grouping,
  is_string,
  is_mstrings,
  is_sepstrings,
  is_int,
  is_wchar,
d555 4
d568 5
a572 25
  { "ctype-class-names", 	 is_string_fake, 0,			 0 },
  { "ctype-map-names",   	 is_string_fake, 2,			 0 },
  { "ctype-outdigit0_mb",	 is_string,	_NL_CTYPE_OUTDIGITS0_MB, 0 },
  { "ctype-outdigit1_mb",	 is_string,	_NL_CTYPE_OUTDIGITS1_MB, 0 },
  { "ctype-outdigit2_mb",	 is_string,	_NL_CTYPE_OUTDIGITS2_MB, 0 },
  { "ctype-outdigit3_mb",	 is_string,	_NL_CTYPE_OUTDIGITS3_MB, 0 },
  { "ctype-outdigit4_mb",	 is_string,	_NL_CTYPE_OUTDIGITS4_MB, 0 },
  { "ctype-outdigit5_mb",	 is_string,	_NL_CTYPE_OUTDIGITS5_MB, 0 },
  { "ctype-outdigit6_mb",	 is_string,	_NL_CTYPE_OUTDIGITS6_MB, 0 },
  { "ctype-outdigit7_mb",	 is_string,	_NL_CTYPE_OUTDIGITS7_MB, 0 },
  { "ctype-outdigit8_mb",	 is_string,	_NL_CTYPE_OUTDIGITS8_MB, 0 },
  { "ctype-outdigit9_mb",	 is_string,	_NL_CTYPE_OUTDIGITS9_MB, 0 },
  { "ctype-outdigit0_wc",	 is_wchar, 	_NL_CTYPE_OUTDIGITS0_WC, 0 },
  { "ctype-outdigit1_wc",	 is_wchar, 	_NL_CTYPE_OUTDIGITS1_WC, 0 },
  { "ctype-outdigit2_wc",	 is_wchar, 	_NL_CTYPE_OUTDIGITS2_WC, 0 },
  { "ctype-outdigit3_wc",	 is_wchar, 	_NL_CTYPE_OUTDIGITS3_WC, 0 },
  { "ctype-outdigit4_wc",	 is_wchar, 	_NL_CTYPE_OUTDIGITS4_WC, 0 },
  { "ctype-outdigit5_wc",	 is_wchar, 	_NL_CTYPE_OUTDIGITS5_WC, 0 },
  { "ctype-outdigit6_wc",	 is_wchar, 	_NL_CTYPE_OUTDIGITS6_WC, 0 },
  { "ctype-outdigit7_wc",	 is_wchar, 	_NL_CTYPE_OUTDIGITS7_WC, 0 },
  { "ctype-outdigit8_wc",	 is_wchar, 	_NL_CTYPE_OUTDIGITS8_WC, 0 },
  { "ctype-outdigit9_wc",	 is_wchar, 	_NL_CTYPE_OUTDIGITS9_WC, 0 },
  { "charmap",			 is_string,	CODESET,		 0 },
  { "ctype-mb-cur-max",		 is_int,	_NL_CTYPE_MB_CUR_MAX,	 0 },
  { NULL, 			 is_end,	0,		 	 0 }
d577 5
a581 7
  { "decimal_point",		 is_string,	RADIXCHAR,		 0 },
  { "thousands_sep",		 is_string,	THOUSEP, 		 0 },
  { "grouping",			 is_grouping,	_NL_NUMERIC_GROUPING,	 0 },
  { "numeric-decimal-point-wc",	 is_wchar,	_NL_NUMERIC_DECIMAL_POINT_WC, 0 },
  { "numeric-thousands-sep-wc",	 is_wchar,	_NL_NUMERIC_THOUSANDS_SEP_WC, 0 },
  { "numeric-codeset",		 is_string,	_NL_NUMERIC_CODESET,	 0 },
  { NULL, 			 is_end,	0,			 0 }
d586 17
a602 17
  { "abday",			 is_mstrings,	ABDAY_1,	 ABDAY_7  },
  { "day",			 is_mstrings,	DAY_1,		 DAY_7    },
  { "abmon",			 is_mstrings,	ABMON_1,	 ABMON_12 },
  { "mon",			 is_mstrings,	MON_1,		 MON_12   },
  { "am_pm",			 is_mstrings,	AM_STR,		 PM_STR   },
  { "d_t_fmt",			 is_string,	D_T_FMT,		0 },
  { "d_fmt",			 is_string,	D_FMT,			0 },
  { "t_fmt",			 is_string,	T_FMT,			0 },
  { "t_fmt_ampm",		 is_string,	T_FMT_AMPM,		0 },
  { "era",			 is_sepstrings,	ERA,			0 },
  { "era_d_fmt",		 is_string,	ERA_D_FMT,		0 },
  { "alt_digits",		 is_sepstrings,ALT_DIGITS,		0 },
  { "era_d_t_fmt",		 is_string,	ERA_D_T_FMT,		0 },
  { "era_t_fmt",		 is_string,	ERA_T_FMT,		0 },
  { "date_fmt",			 is_string,	_DATE_FMT,		0 },
  { "time-codeset",		 is_string,	_NL_TIME_CODESET,	0 },
  { NULL, 			 is_end,	0,			0 }
d607 2
a608 2
  { "collate-codeset",		 is_string,	_NL_COLLATE_CODESET,	0 },
  { NULL, 			 is_end,	0,			0 }
d613 23
a635 25
  { "int_curr_symbol",		 is_string,	_NL_MONETARY_INT_CURR_SYMBOL, 0 },
  { "currency_symbol",		 is_string,	_NL_MONETARY_CURRENCY_SYMBOL, 0 },
  { "mon_decimal_point",	 is_string,	_NL_MONETARY_MON_DECIMAL_POINT, 0 },
  { "mon_thousands_sep",	 is_string,	_NL_MONETARY_MON_THOUSANDS_SEP, 0 },
  { "mon_grouping",		 is_grouping,	_NL_MONETARY_MON_GROUPING, 0 },
  { "positive_sign",		 is_string,	_NL_MONETARY_POSITIVE_SIGN, 0 },
  { "negative_sign",		 is_string,	_NL_MONETARY_NEGATIVE_SIGN, 0 },
  { "int_frac_digits",		 is_int,	_NL_MONETARY_INT_FRAC_DIGITS, 0 },
  { "frac_digits",		 is_int,	_NL_MONETARY_FRAC_DIGITS,   0 },
  { "p_cs_precedes",		 is_int,	_NL_MONETARY_P_CS_PRECEDES, 0 },
  { "p_sep_by_space",		 is_int,	_NL_MONETARY_P_SEP_BY_SPACE, 0 },
  { "n_cs_precedes",		 is_int,	_NL_MONETARY_N_CS_PRECEDES, 0 },
  { "n_sep_by_space",		 is_int,	_NL_MONETARY_N_SEP_BY_SPACE, 0 },
  { "p_sign_posn",		 is_int,	_NL_MONETARY_P_SIGN_POSN,   0 },
  { "n_sign_posn",		 is_int,	_NL_MONETARY_N_SIGN_POSN,   0 },
  { "int_p_cs_precedes",	 is_int,	_NL_MONETARY_INT_P_CS_PRECEDES, 0 },
  { "int_p_sep_by_space",	 is_int,	_NL_MONETARY_INT_P_SEP_BY_SPACE,0 },
  { "int_n_cs_precedes",	 is_int,	_NL_MONETARY_INT_N_CS_PRECEDES, 0 },
  { "int_n_sep_by_space",	 is_int,	_NL_MONETARY_INT_N_SEP_BY_SPACE,0 },
  { "int_p_sign_posn",		 is_int,	_NL_MONETARY_INT_P_SIGN_POSN, 0 },
  { "int_n_sign_posn",		 is_int,	_NL_MONETARY_INT_N_SIGN_POSN, 0 },
  { "monetary-decimal-point-wc", is_wchar,	_NL_MONETARY_WMON_DECIMAL_POINT, 0 },
  { "monetary-thousands-sep-wc", is_wchar,	_NL_MONETARY_WMON_THOUSANDS_SEP, 0 },
  { "monetary-codeset",		 is_string,	_NL_MONETARY_CODESET,	   0 },
  { NULL, 			 is_end,	0,			   0 }
d640 6
a645 6
  { "yesexpr",			 is_string,	YESEXPR,		0 },
  { "noexpr",			 is_string,	NOEXPR,			0 },
  { "yesstr",			 is_string,	YESSTR,			0 },
  { "nostr",			 is_string,	NOSTR,			0 },
  { "messages-codeset",		 is_string,	_NL_MESSAGES_CODESET,	0 },
  { NULL, 			 is_end,	0,			0 }
d652 2
d663 8
a670 2
	case is_grouping:
	  print_lc_grouping (key, lc->name, nl_langinfo (lc->fromval));
d672 1
a672 1
	case is_string:
d675 1
a675 1
	case is_sepstrings:
d678 1
a678 1
	case is_mstrings:
d681 2
a682 2
	case is_int:
	  print_lc_ivalue (key, lc->name, (int) *nl_langinfo (lc->fromval));
d684 2
a685 3
	case is_wchar:
	  print_lc_ivalue (key, lc->name,
			   *(wchar_t *) nl_langinfo (lc->fromval));
@


1.4
log
@	* locale.cc (printlocale): Remove.
	(loc_t): New type to keep locale information for printing.
	(print_codeset): New function to print codeset as on Linux.
	(print_locale_with_codeset): New function to print single locale.
	Print verbose style as the Linux locale(1) tool.
	(print_locale): New function to print single locale plus its UTF-8
	variation, if available.
	(compare_locales): New helper function for bsearch and qsort on loc_t.
	(add_locale): New function to store locale in loc_t array.
	(add_locale_alias_locales): New function to store locales from
	locale.alias file in loc_t.
	(print_all_locales): Call add_locale instead of printlocale.
	Call add_locale_alias_locales, sort locales alphabetically and print
	them.
@
text
@d117 2
a118 2
print_locale_with_codeset (int verbose, loc_t *locale, const char *name,
			   bool utf8, const char *modifier)
d135 2
a136 1
  stpcpy (stpcpy (stpcpy (locname, name), utf8 ? ".utf8" : ""), modifier ?: "");
d155 1
a155 1
  print_locale_with_codeset (verbose, locale, locale->name, false, NULL);
d160 1
a160 1
	print_locale_with_codeset (verbose, locale, locale->name, true, NULL);
d164 1
a164 2
	  print_locale_with_codeset (verbose, locale, locale->name, true,
				     modifier);
a510 13
print_lc_xxx_charset (int key, int lc_cat, const char *name)
{
  char lc_ctype_locale[32];
  char lc_xxx_locale[32];

  strcpy (lc_ctype_locale, setlocale (LC_CTYPE, NULL));
  strcpy (lc_xxx_locale, setlocale (lc_cat, NULL));
  setlocale (LC_CTYPE, lc_xxx_locale);
  print_lc_svalue (key, name, nl_langinfo (CODESET));
  setlocale (LC_CTYPE, lc_ctype_locale);
}

void
d523 6
a528 8
  is_string_lconv,
  is_int_lconv,
  is_grouping_lconv,
  is_string_linf,
  is_mstrings_linf,
  is_sepstrings_linf,
  is_mb_cur_max,
  is_codeset,
a539 4
#define _O(M)		__builtin_offsetof (struct lconv, M)
#define _MS(l,lc)	(*(const char **)(((const char *)(l))+(lc)->fromval))
#define _MI(l,lc)	((int)*(((const char *)(l))+(lc)->fromval))

d549 25
a573 5
  { "ctype-class-names",is_string_fake,	   0,			0 },
  { "ctype-map-names",	is_string_fake,	   2,			0 },
  { "charmap",		is_string_linf,	   CODESET,		0 },
  { "ctype-mb-cur-max", is_mb_cur_max,	   0,			0 },
  { NULL, 		is_end,		   0,			0 }
d578 7
a584 5
  { "decimal_point",	is_string_lconv,   _O(decimal_point),	0 },
  { "thousands_sep",	is_string_lconv,   _O(thousands_sep), 	0 },
  { "grouping",		is_grouping_lconv, _O(grouping),	0 },
  { "numeric-codeset",	is_codeset,	   LC_NUMERIC,		0 },
  { NULL, 		is_end,		   0,			0 }
d589 17
a605 17
  { "abday",		is_mstrings_linf,  ABDAY_1,		ABDAY_7  },
  { "day",		is_mstrings_linf,  DAY_1,		DAY_7    },
  { "abmon",		is_mstrings_linf,  ABMON_1,		ABMON_12 },
  { "mon",		is_mstrings_linf,  MON_1,		MON_12   },
  { "am_pm",		is_mstrings_linf,  AM_STR,		PM_STR   },
  { "d_t_fmt",		is_string_linf,    D_T_FMT,		0        },
  { "d_fmt",		is_string_linf,    D_FMT,		0        },
  { "t_fmt",		is_string_linf,    T_FMT,		0        },
  { "t_fmt_ampm",	is_string_linf,    T_FMT_AMPM,		0	 },
  { "era",		is_sepstrings_linf,ERA,			0	 },
  { "era_d_fmt",	is_string_linf,    ERA_D_FMT,		0	 },
  { "alt_digits",	is_sepstrings_linf,ALT_DIGITS,		0	 },
  { "era_d_t_fmt",	is_string_linf,    ERA_D_T_FMT,		0	 },
  { "era_t_fmt",	is_string_linf,    ERA_T_FMT,		0	 },
  { "date_fmt",		is_string_linf,    _DATE_FMT,		0	 },
  { "time-codeset",	is_codeset,	   LC_TIME,		0	 },
  { NULL, 		is_end,		   0,			0	 }
d610 2
a611 2
  { "collate-codeset",	is_codeset,	   LC_COLLATE,		0	 },
  { NULL, 		is_end,		   0,			0	 }
d616 25
a640 23
  { "int_curr_symbol",	is_string_lconv,   _O(int_curr_symbol),		0 },
  { "currency_symbol",	is_string_lconv,   _O(currency_symbol),		0 },
  { "mon_decimal_point",is_string_lconv,   _O(mon_decimal_point), 	0 },
  { "mon_thousands_sep",is_string_lconv,   _O(mon_thousands_sep),	0 },
  { "mon_grouping",	is_grouping_lconv, _O(mon_grouping),		0 },
  { "positive_sign",	is_string_lconv,   _O(positive_sign),		0 },
  { "negative_sign",	is_string_lconv,   _O(negative_sign),		0 },
  { "int_frac_digits",	is_int_lconv,      _O(int_frac_digits),		0 },
  { "frac_digits",	is_int_lconv,	   _O(frac_digits),		0 },
  { "p_cs_precedes",	is_int_lconv,	   _O(p_cs_precedes),		0 },
  { "p_sep_by_space",	is_int_lconv,	   _O(p_sep_by_space),		0 },
  { "n_cs_precedes",	is_int_lconv,	   _O(n_cs_precedes),		0 },
  { "n_sep_by_space",	is_int_lconv,	   _O(n_sep_by_space),		0 },
  { "p_sign_posn",	is_int_lconv,	   _O(p_sign_posn),		0 },
  { "n_sign_posn",	is_int_lconv,	   _O(n_sign_posn),		0 },
  { "int_p_cs_precedes",is_int_lconv,	   _O(int_p_cs_precedes),	0 },
  { "int_p_sep_by_space",is_int_lconv,	   _O(int_p_sep_by_space),	0 },
  { "int_n_cs_precedes",is_int_lconv,	   _O(int_n_cs_precedes),	0 },
  { "int_n_sep_by_space",is_int_lconv,	   _O(int_n_sep_by_space),	0 },
  { "int_p_sign_posn",	is_int_lconv,	   _O(int_p_sign_posn),		0 },
  { "int_n_sign_posn",	is_int_lconv,	   _O(int_n_sign_posn),		0 },
  { "monetary-codeset",	is_codeset,	   LC_MONETARY,			0 },
  { NULL, 		is_end,		   0,				0 }
d645 6
a650 6
  { "yesexpr",		is_string_linf,	   YESEXPR,			0 },
  { "noexpr",		is_string_linf,	   NOEXPR,			0 },
  { "yesstr",		is_string_linf,	   YESSTR,			0 },
  { "nostr",		is_string_linf,	   NOSTR,			0 },
  { "messages-codeset",	is_codeset,	   LC_MESSAGES,			0 },
  { NULL, 		is_end,		   0,				0 }
a656 2
  struct lconv *l = localeconv ();

d666 2
a667 8
	case is_string_lconv:
	  print_lc_svalue (key, lc->name, _MS (l, lc));
	  break;
	case is_int_lconv:
	  print_lc_ivalue (key, lc->name, _MI (l, lc));
	  break;
	case is_grouping_lconv:
	  print_lc_grouping (key, lc->name, _MS (l, lc));
d669 1
a669 1
	case is_string_linf:
d672 1
a672 1
	case is_sepstrings_linf:
d675 1
a675 1
	case is_mstrings_linf:
d678 2
a679 2
	case is_mb_cur_max:
	  print_lc_ivalue (key, lc->name, MB_CUR_MAX);
d681 3
a683 2
	case is_codeset:
	  print_lc_xxx_charset (key, lc->fromval, lc->name);
@


1.3
log
@	* locale.cc (lc_time_names): Add "date_fmt" entry.
@
text
@d27 1
d34 1
d38 3
d97 19
d117 2
a118 2
printlocale (int verbose, const char *loc,
	     const wchar_t *lang, const wchar_t *ctry)
d120 16
a135 1
  printf ("%-16s", loc);
d137 109
a245 2
    printf ("%ls (%ls)", lang, ctry);
  fputc ('\n', stdout);
d257 2
a258 2
  printlocale (verbose, "C", L"C", L"POSIX");
  printlocale (verbose, "POSIX", L"C", L"POSIX");
d325 1
a325 1
	      printlocale (verbose, loc, language, country);
d348 1
a348 1
	      printlocale (verbose, loc, language, country);
d370 4
a373 8
	      printlocale (verbose, "sr_RS@@latin",
			   L"Serbian (Latin)", L"Serbia");
	      printlocale (verbose, "sr_RS",
			   L"Serbian (Cyrillic)", L"Serbia");
	      printlocale (verbose, "sr_ME@@latin",
			   L"Serbian (Latin)", L"Montenegro");
	      printlocale (verbose, "sr_ME",
			   L"Serbian (Cyrillic)", L"Montenegro");
d377 6
@


1.2
log
@	* locale.cc (print_lc_mstrings): New function to print
	semicolon-separated strings.
	(enum type_t): New type is_sepstrings_linf.
	(lc_time_names): Change type of era and alt_digits entry to
	is_sepstrings_linf.
	(print_lc): Add case for is_sepstrings_linf and call print_lc_mstrings
	in that case.
@
text
@d452 1
@


1.1
log
@	* Makefile.in (CYGWIN_BINS): Rename getlocale to locale.
	* getlocale.c: Rename to ...
	* locale.cc: Revamp to add full functionality of POSIX locale(1) tool,
	as far as Cygwin supports it.
	* utils.sgml (getlocale): Move and rename to ...
	(locale): Accommodate new functionality.
@
text
@d321 30
d393 1
d447 1
a447 1
  { "era",		is_string_linf,    ERA,			0	 },
d449 1
a449 1
  { "alt_digits",	is_string_linf,    ALT_DIGITS,		0	 },
d526 3
@

