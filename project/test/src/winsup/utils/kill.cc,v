head	1.33;
access;
symbols
	cygwin-1_7_35-release:1.33
	cygwin-1_7_34-release:1.33
	cygwin-1_7_33-release:1.33
	cygwin-1_7_32-release:1.33
	cygwin-1_7_31-release:1.33
	cygwin-1_7_30-release:1.33
	cygwin-1_7_29-release:1.33
	cygwin-1_7_29-release-branchpoint:1.33.0.2
	cygwin-1_7_28-release:1.33
	cygwin-1_7_27-release:1.33
	cygwin-1_7_26-release:1.33
	cygwin-1_7_25-release:1.33
	cygwin-1_7_24-release:1.33
	cygwin-1_7_23-release:1.33
	cygwin-1_7_22-release:1.33
	cygwin-1_7_21-release:1.33
	cygwin-1_7_20-release:1.33
	cygwin-1_7_19-release:1.33
	cygwin-64bit-postmerge:1.33
	cygwin-64bit-premerge-branch:1.32.0.2
	cygwin-64bit-premerge:1.32
	cygwin-1_7_18-release:1.32
	cygwin-1_7_17-release:1.31
	cygwin-64bit-branch:1.31.0.2
	cygwin-1_7_16-release:1.31
	cygwin-1_7_15-release:1.31
	cygwin-1_7_14_2-release:1.31
	cygwin-1_7_14-release:1.31
	cygwin-1_7_12-release:1.31
	cygwin-1_7_11-release:1.31
	cygwin-1_7_10-release:1.31
	cygwin-1_7_9-release:1.29
	cygwin-1_7_8-release:1.29
	cygwin-1_7_7-release:1.29
	cygwin-1_7_5-release:1.29
	cygwin-1_7_4-release:1.29
	cygwin-1_7_3-release:1.29
	cygwin-1_7_2-release:1.29
	cygwin-1_7_1-release:1.29
	cv-branch-2:1.28.0.2
	cr-0x5f1:1.27.0.6
	cv-branch:1.27.0.4
	cr-0x3b58:1.27.0.2
	cr-0x9e:1.22.0.4
	cr-0x9d:1.22.0.2
	corinna-01:1.22
	cr-0x9c:1.21.2.1.0.2
	cr-0x9b:1.21.0.2
	cr-0x99:1.19
	Z-emcb-cygwin_daemon:1.17.0.2
	w32api-2_2:1.16
	mingw-runtime-2_4:1.16
	cygnus_cvs_20020108_pre:1.10
	Z-cygwin_daemon_merge-new_HEAD:1.9
	Z-cygwin_daemon_merge_HEAD:1.9
	cygwin_daemon:1.9.0.8;
locks; strict;
comment	@// @;
expand	@o@;


1.33
date	2013.04.23.09.44.36;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2013.01.21.16.28.27;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2011.12.17.23.39.47;	author cgf;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2011.10.10.14.57.47;	author corinna;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.12.16.01.44;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2007.07.10.00.12.54;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.08.04.06.26;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2005.02.27.03.03.19;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2004.11.13.16.30.19;	author phumblet;	state Exp;
branches;
next	1.24;

1.24
date	2004.05.27.15.15.51;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2004.03.13.18.11.13;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2003.09.20.20.24.33;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.18.01.46.18;	author cgf;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2003.09.13.18.20.52;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2003.09.01.02.40.16;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2003.09.01.01.57.44;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.26.21.52.03;	author joshuadfranklin;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.15.19.24.36;	author joshuadfranklin;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.13.23.42.32;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.13.05.35.44;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.13.05.23.37;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.13.05.13.58;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.11.18.33.02;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.08.03.06.25;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.18.03.25.00;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.18.02.47.39;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.02.01.03.00;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.09.03.31.10;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.13.02.48.39;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.29.01.58.00;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.24.19.03.12;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.29.16.26.37;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.31.2.1
date	2013.01.29.21.54.42;	author corinna;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2013.02.13.15.06.58;	author corinna;	state Exp;
branches;
next	1.31.2.3;

1.31.2.3
date	2013.03.22.13.55.08;	author corinna;	state Exp;
branches;
next	;

1.21.2.1
date	2003.09.20.20.27.10;	author cgf;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.33
log
@	* Merge in cygwin-64bit-branch.
@
text
@/* kill.cc

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007,
   2009, 2011 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <windows.h>
#include <sys/cygwin.h>
#include <cygwin/version.h>
#include <getopt.h>
#include <limits.h>

static char *prog_name;

static struct option longopts[] =
{
  {"help", no_argument, NULL, 'h' },
  {"list", optional_argument, NULL, 'l'},
  {"force", no_argument, NULL, 'f'},
  {"signal", required_argument, NULL, 's'},
  {"version", no_argument, NULL, 'V'},
  {NULL, 0, NULL, 0}
};

static char opts[] = "hl::fs:V";

static void
usage (FILE *where = stderr)
{
  fprintf (where , ""
	"Usage: %1$s [-f] [-signal] [-s signal] pid1 [pid2 ...]\n"
	"       %1$s -l [signal]\n"
	"\n"
	"Send signals to processes\n"
	"\n"
	" -f, --force     force, using win32 interface if necessary\n"
	" -l, --list      print a list of signal names\n"
	" -s, --signal    send signal (use %1$s --list for a list)\n"
	" -h, --help      output usage information and exit\n"
	" -V, --version   output version information and exit\n"
	"\n", prog_name);
  exit (where == stderr ? 1 : 0);
}

static void
print_version ()
{
  printf ("kill (cygwin) %d.%d.%d\n"
	  "Process Signaller\n"
	  "Copyright (C) 1996 - %s Red Hat, Inc.\n"
	  "This is free software; see the source for copying conditions.  There is NO\n"
	  "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n",
	  CYGWIN_VERSION_DLL_MAJOR / 1000,
	  CYGWIN_VERSION_DLL_MAJOR % 1000,
	  CYGWIN_VERSION_DLL_MINOR,
	  strrchr (__DATE__, ' ') + 1);
}

static const char *
strsigno (int signo)
{
  if (signo >= 0 && signo < NSIG)
    return sys_sigabbrev[signo];
  static char buf[sizeof ("Unknown signal") + 32];
  sprintf (buf, "Unknown signal %d", signo);
  return buf;
}

static int
getsig (const char *in_sig)
{
  const char *sig;
  char buf[80];
  int intsig;

  if (strncmp (in_sig, "SIG", 3) == 0)
    sig = in_sig;
  else
    {
      sprintf (buf, "SIG%-.20s", in_sig);
      sig = buf;
    }
  intsig = strtosigno (sig) ?: atoi (in_sig);
  char *p;
  if (!intsig && (strcmp (buf, "SIG0") != 0 && (strtol (in_sig, &p, 10) != 0 || *p)))
    intsig = -1;
  return intsig;
}

static void
test_for_unknown_sig (int sig, const char *sigstr)
{
  if (sig < 0 || sig > NSIG)
    {
      fprintf (stderr, "%1$s: unknown signal: %2$s\n"
		       "Try `%1$s --help' for more information.\n",
	       prog_name, sigstr);
      exit (1);
    }
}

static void
listsig (const char *in_sig)
{
  int sig;
  if (!in_sig)
    for (sig = 1; sig < NSIG - 1; sig++)
      printf ("%s%c", strsigno (sig) + 3, (sig < NSIG - 1) ? ' ' : '\n');
  else
    {
      sig = getsig (in_sig);
      test_for_unknown_sig (sig, in_sig);
      if (atoi (in_sig) == sig)
	puts (strsigno (sig) + 3);
      else
	printf ("%d\n", sig);
    }
}

static void
get_debug_priv (void)
{
  HANDLE tok;
  LUID luid;
  TOKEN_PRIVILEGES tkp;

  if (!OpenProcessToken (GetCurrentProcess (),
			 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &tok))
    return;

  if (!LookupPrivilegeValue (NULL, SE_DEBUG_NAME, &luid))
    {
      CloseHandle (tok);
      return;
    }

  tkp.PrivilegeCount = 1;
  tkp.Privileges[0].Luid = luid;
  tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

  AdjustTokenPrivileges (tok, FALSE, &tkp, sizeof tkp, NULL, NULL);

  CloseHandle (tok);
}

static void __stdcall
forcekill (int pid, int sig, int wait)
{
  // try to acquire SeDebugPrivilege
  get_debug_priv();

  external_pinfo *p = NULL;
  /* cygwin_internal misinterprets negative pids (Win9x pids) */
  if (pid > 0)
    p = (external_pinfo *) cygwin_internal (CW_GETPINFO_FULL, pid);
  DWORD dwpid = p ? p->dwProcessId : (DWORD) pid;
  HANDLE h = OpenProcess (PROCESS_TERMINATE, FALSE, (DWORD) dwpid);
  if (!h)
    {
      if (!wait || GetLastError () != ERROR_INVALID_PARAMETER)
	fprintf (stderr, "%s: couldn't open pid %u\n",
		 prog_name, (unsigned) dwpid);
      return;
    }
  if (!wait || WaitForSingleObject (h, 200) != WAIT_OBJECT_0)
    if (sig && !TerminateProcess (h, sig << 8)
	&& WaitForSingleObject (h, 200) != WAIT_OBJECT_0)
      fprintf (stderr, "%s: couldn't kill pid %u, %u\n",
	       prog_name, (unsigned) dwpid, (unsigned int) GetLastError ());
  CloseHandle (h);
}

int
main (int argc, char **argv)
{
  int sig = SIGTERM;
  int force = 0;
  int ret = 0;
  char *gotasig = NULL;

  prog_name = program_invocation_short_name;

  if (argc == 1)
    usage ();

  opterr = 0;

  char *p;
  long long int pid = 0;

  for (;;)
    {
      int ch;
      char **av = argv + optind;
      if ((ch = getopt_long (argc, argv, opts, longopts, NULL)) == EOF)
	break;
      switch (ch)
	{
	case 's':
	  gotasig = optarg;
	  sig = getsig (gotasig);
	  break;
	case 'l':
	  if (!optarg)
	    {
	      optarg = argv[optind];
	      if (optarg)
		{
		  optind++;
		  optreset = 1;
		}
	    }
	  if (argv[optind])
	    usage ();
	  listsig (optarg);
	  break;
	case 'f':
	  force = 1;
	  break;
	case 'h':
	  usage (stdout);
	  break;
	case 'V':
	  print_version ();
	  break;
	case '?':
	  if (gotasig)
	    {
	      --optind;
	      goto out;
	    }
	  optreset = 1;
	  optind = 1 + av - argv;
	  gotasig = *av + 1;
	  sig = getsig (gotasig);
	  break;
	default:
	  usage ();
	  break;
	}
    }

out:
  test_for_unknown_sig (sig, gotasig);

  argv += optind;
  while (*argv != NULL)
    {
      if (!pid)
	pid = strtoll (*argv, &p, 10);
      if (*p != '\0'
	  || (!force && (pid < INT_MIN || pid > INT_MAX))
	  || (force && (pid <= 0 || pid > UINT_MAX)))
	{
	  fprintf (stderr, "%s: illegal pid: %s\n", prog_name, *argv);
	  ret = 1;
	}
      else if (pid <= INT_MAX && kill ((pid_t) pid, sig) == 0)
	{
	  if (force)
	    forcekill ((pid_t) pid, sig, 1);
	}
      else if (force)
	forcekill ((pid_t) pid, sig, 0);
      else
	{
	  char buf[1000];
	  sprintf (buf, "%s: %lld", prog_name, pid);
	  perror (buf);
	  ret = 1;
	}
      argv++;
      pid = 0;
    }
  return ret;
}

@


1.32
log
@Update copyrights
@
text
@d179 2
a180 2
      fprintf (stderr, "%s: couldn't kill pid %u, %lu\n",
	       prog_name, (unsigned) dwpid, GetLastError ());
d263 2
a264 2
	  || (!force && (pid < LONG_MIN || pid > LONG_MAX))
	  || (force && (pid <= 0 || pid > ULONG_MAX)))
d269 1
a269 1
      else if (pid <= LONG_MAX && kill ((pid_t) pid, sig) == 0)
@


1.31
log
@Clean up whitespace.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2011 Red Hat, Inc.
@


1.31.2.1
log
@Pull in changes from HEAD
@
text
@d3 1
a3 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007,
   2009, 2011 Red Hat, Inc.
@


1.31.2.2
log
@	* kill.cc (forcekill): Use unsigned int printf format specifier and
	cast to avoid compiler warnings where DWORD value is used.
	* regtool.cc: Ditto, throughout.
@
text
@d179 2
a180 2
      fprintf (stderr, "%s: couldn't kill pid %u, %u\n",
	       prog_name, (unsigned) dwpid, (unsigned int) GetLastError ());
@


1.31.2.3
log
@	* kill.cc (main): Chack pid against INT_MIN and (U)INT_MAX since pid_t
	is 4 byte on all platforms.
	* mkgroup.c (main): Check domlist[i].id_offset against UINT_MAX since
	DWORD is 4 byte on all platforms.
	* mkpasswd.c (main): Ditto.
@
text
@d263 2
a264 2
	  || (!force && (pid < INT_MIN || pid > INT_MAX))
	  || (force && (pid <= 0 || pid > UINT_MAX)))
d269 1
a269 1
      else if (pid <= INT_MAX && kill ((pid_t) pid, sig) == 0)
@


1.30
log
@	* Align usage output, version output, as well as usage and version
	option handling to use the same style throughout all Cygwin utils.
	Throughout use program_invocation_short_name to refer to current
	process name in Cygwin executables.
	* utils.sgml: Align documentation to above change.  Add missing
	sections for getconf, ldd, and setmetamode.
	* strace.cc (proc_child): Avoid compiler warning.
@
text
@d59 3
a61 3
          "Process Signaller\n"
          "Copyright (C) 1996 - %s Red Hat, Inc.\n"
          "This is free software; see the source for copying conditions.  There is NO\n"
d63 4
a66 4
          CYGWIN_VERSION_DLL_MAJOR / 1000,
          CYGWIN_VERSION_DLL_MAJOR % 1000,
          CYGWIN_VERSION_DLL_MINOR,
          strrchr (__DATE__, ' ') + 1);
d138 1
a138 1
  			 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &tok))
d170 3
a172 3
      if (!wait || GetLastError () != ERROR_INVALID_PARAMETER) 
        fprintf (stderr, "%s: couldn't open pid %u\n", 
	         prog_name, (unsigned) dwpid);
d178 1
a178 1
      fprintf (stderr, "%s: couldn't kill pid %u, %lu\n", 
d262 2
a263 2
          || (!force && (pid < LONG_MIN || pid > LONG_MAX))
          || (force && (pid <= 0 || pid > ULONG_MAX))) 
@


1.29
log
@	* kill.cc (main): Skip to PID loop on invalid option to handle
	negative pids there.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d19 1
a22 1
static const char version[] = "$Revision: 1.14 $";
d31 1
a31 1
  {"version", no_argument, NULL, 'v'},
d35 1
a35 1
static char opts[] = "hl::fs:v";
d41 3
a43 2
	"Usage: %s [-f] [-signal] [-s signal] pid1 [pid2 ...]\n"
	"       %s -l [signal]\n"
d48 1
a48 1
	" -s, --signal    send signal (use %s --list for a list)\n"
d50 2
a51 2
	" -v, --version   output version information and exit\n"
	"", prog_name, prog_name, prog_name);
d58 9
a66 18
  const char *v = strchr (version, ':');
  int len;
  if (!v)
    {
      v = "?";
      len = 1;
    }
  else
    {
      v += 2;
      len = strchr (v, ' ') - v;
    }
  printf ("\
%s (cygwin) %.*s\n\
Process Signaller\n\
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.\n\
Compiled on %s\n\
", prog_name, len, v, __DATE__);
d105 3
a107 2
      fprintf (stderr, "%s: unknown signal: %s\n", prog_name, sigstr);
      usage ();
d191 1
a191 7
  prog_name = strrchr (argv[0], '/');
  if (prog_name == NULL)
    prog_name = strrchr (argv[0], '\\');
  if (prog_name == NULL)
    prog_name = argv[0];
  else
    prog_name++;
d233 1
a233 1
	case 'v':
@


1.28
log
@* cygwin/strsig.cc (__signals): New macro.
(sys_sigabbrev): New array of signal strings, patterned after linux.
(siglist): Use __signals.
* cygwin/include/cygwin/signal.h (sys_sigabbrev): Define.
* cygwin/include/cygwin/version.h: Bump API minor version to 177.

* utils/Makefile.in (kill.exe): Remove reliance on libiberty.
* utils/kill.cc (strsigno): New function patterned after libiberty but using
newly exported cygwin array.
@
text
@d252 2
a253 4
	      pid = strtoll (argv[optind], &p, 10);
	      if (pid < 0)
		goto out;
	      usage ();
@


1.27
log
@* kill.cc (getsig): Rectify bug introduced by 2005-02-26 change.  Don't pad
signal name with spaces.
@
text
@a36 2
extern "C" const char *strsigno (int);

d77 10
@


1.26
log
@* kill (getsig): Avoid buffer overflow when generating a signal name.
* strace.cc (handle_output_debug_string): Make error a little more specific.
@
text
@d90 1
a90 1
      sprintf (buf, "SIG%-20.20s", in_sig);
@


1.25
log
@2004-11-13  Pierre Humblet <pierre.humblet@@ieee.org>

	* kill.cc (forcekill): Do not pass negative pids to
	cygwin_internal. Check if sig == 0. Improve error messages.
	(main): Make pid a long long and distinguish between pids, gpids
	(i.e. negative pids) and Win9x pids.
@
text
@d90 1
a90 1
      sprintf (buf, "SIG%s", in_sig);
@


1.24
log
@* kill.cc (listsig): NSIG includes Signal 0, so we need to avoid calling
strtosigno with NSIG - 1.
@
text
@d20 1
d161 4
a164 1
  external_pinfo *p = (external_pinfo *) cygwin_internal (CW_GETPINFO_FULL, pid);
d169 3
a171 1
      fprintf (stderr, "couldn't open pid %u\n", (unsigned) dwpid);
d175 1
a175 1
    if (!TerminateProcess (h, sig << 8)
d177 2
a178 2
      fprintf (stderr, "couldn't kill pid %u, %u\n", (unsigned) dwpid,
	       (unsigned) GetLastError ());
d204 1
a204 1
  int pid = 0;
d244 1
a244 1
	      pid = strtol (argv[optind], &p, 10);
d267 4
a270 2
	pid = strtol (*argv, &p, 10);
      if (*p != '\0')
d275 1
a275 1
      else if (kill (pid, sig) == 0)
d278 1
a278 1
	    forcekill (pid, sig, 1);
d280 2
a281 2
      else if (force && sig != 0)
	forcekill (pid, sig, 0);
d285 1
a285 1
	  sprintf (buf, "%s %d", prog_name, pid);
@


1.23
log
@	* kill.cc (get_debug_priv): New function.
	(forcekill): Call get_debug_priv before trying to kill process.
@
text
@d115 1
a115 1
    for (sig = 1; sig < NSIG; sig++)
@


1.22
log
@* kill.cc (main): Allow negative pids (indicates process groups).
@
text
@d128 26
d157 3
d286 1
@


1.21
log
@* parse_pe.cc (exclusion::sort_and_check): Make error message a little more
explicit and ignore (hopefully) harmless region overlap.
@
text
@d167 4
d208 6
a213 1
	    usage ();
d225 1
d231 2
a232 2
      char *p;
      int pid = strtol (*argv, &p, 10);
d253 1
@


1.21.2.1
log
@* kill.cc (main): Allow negative pids (indicates process groups).
@
text
@a166 4

  char *p;
  int pid = 0;

d204 1
a204 6
	    {
	      pid = strtol (argv[optind], &p, 10);
	      if (pid < 0)
		goto out;
	      usage ();
	    }
a215 1
out:
d221 2
a222 2
      if (!pid)
	pid = strtol (*argv, &p, 10);
a242 1
      pid = 0;
@


1.20
log
@* kill.c (forcekill): Wait for process to terminate even if TerminateProcess
says it failed.
@
text
@a151 1
  char *gotsig = NULL;
d153 1
d176 2
a177 2
	  gotsig = optarg;
	  sig = getsig (gotsig);
d203 1
a203 1
	  if (gotsig)
d207 2
a208 2
	  gotsig = *av + 1;
	  sig = getsig (gotsig);
d216 1
a216 1
  test_for_unknown_sig (sig, gotsig);
@


1.19
log
@* kill.cc (forcekill): Silence some compiler warnings.
@
text
@d136 2
a137 2
    fprintf (stderr, "couldn't open pid %u\n", (unsigned) dwpid);
    return;
d140 2
a141 1
    if (!TerminateProcess (h, sig << 8))
@


1.18
log
@* Makefile.in: Display "..." when not-verbose.
* kill.cc (forcekill): Default to entered pid when pinfo fails.  Issue some
warnings when things don't work.
@
text
@d136 1
a136 1
    fprintf (stderr, "couldn't open pid %u\n", dwpid);
d141 2
a142 1
      fprintf (stderr, "couldn't kill pid %u, %d\n", dwpid, GetLastError ());
@


1.17
log
@* cygcheck.cc (usage) Add description output.
@
text
@d132 2
a133 3
  if (!p)
    return;
  HANDLE h = OpenProcess (PROCESS_TERMINATE, FALSE, (DWORD) p->dwProcessId);
d135 2
d138 1
d140 2
a141 1
    TerminateProcess (h, sig << 8);
@


1.16
log
@Add final newlines to utils
@
text
@d44 2
@


1.15
log
@* kill.cc (prog_name) New global variable.
(usage) Standardize usage output.  Add descriptions.
(print_version) New function.
(longopts) Accomodate new version option.
(opts) Ditto.
(main) Ditto.
@
text
@d72 2
a73 1
Compiled on %s", prog_name, len, v, __DATE__);
@


1.14
log
@* kill.cc (listsig): Display numeric id when given symbolic input.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Red Hat, Inc.
d21 3
d30 1
d34 1
a34 1
static char opts[] = "hl::fs:";
d41 9
a49 2
  fputs ("usage: kill [-signal] [-s signal] pid1 [pid2 ...]\n"
	 "       kill -l [signal]\n", where);
d53 22
d101 1
a101 1
      fprintf (stderr, "kill: unknown signal: %s\n", sigstr);
d147 8
d191 3
d217 1
a217 1
	  fprintf (stderr, "kill: illegal pid: %s\n", *argv);
d230 1
a230 1
	  sprintf (buf, "kill %d", pid);
@


1.13
log
@* kill.cc (usage): Show new options.  Allow specification of output stream.
(main): Implement 'h' option.
@
text
@d85 4
a88 1
      puts (strsigno (sig) + 3);
@


1.12
log
@* Makefile.in (kill.exe): Add as a specific target.
* kill.cc (longopts): New.
(opts): Ditto.
(get_sig): Accept const char * parameter.  Return -1 on unknown signal.
(test_for_unknown_sig): New function.
(listsig): New function.
(main): Use getopt_long for option parsing.  Implement -l, and -s options.  Use
test_for_unknown_sig() to test for signal validity.
@
text
@d35 1
a35 1
usage (void)
d37 3
a39 2
  fprintf (stderr, "Usage: kill [-sigN] pid1 [pid2 ...]\n");
  exit (1);
d143 3
@


1.11
log
@* kill.cc (usage): Move to top of file.
(getsig): Ditto.
(forcekill): Ditto.
@
text
@d19 14
d42 1
a42 1
getsig (char *in_sig)
d44 1
a44 1
  char *sig;
d46 1
d55 31
a85 1
  return (strtosigno (sig) ?: atoi (in_sig));
d107 1
a107 1
  int gotsig = 0;
d113 2
a114 18
  while (*++argv && **argv == '-')
    if (strcmp (*argv + 1, "f") == 0)
      force = 1;
    else if (gotsig)
      break;
    else if (strcmp(*argv + 1, "0") != 0)
      {
	sig = getsig (*argv + 1);
	gotsig = 1;
      }
    else
      {
	argv++;
	sig = 0;
	goto sig0;
      }

  if (sig <= 0 || sig > NSIG)
d116 39
a154 2
      fprintf (stderr, "kill: unknown signal: %s\n", argv[-1]);
      exit (1);
d157 3
a159 1
sig0:
@


1.10
log
@* kill.cc (main): Set exit value to 1 on invalid pid.  Perform minor cleanup.
@
text
@d20 36
a55 3
static void usage (void);
static int __stdcall getsig (char *);
static void __stdcall forcekill (int, int, int);
a117 37
}

static void
usage (void)
{
  fprintf (stderr, "Usage: kill [-sigN] pid1 [pid2 ...]\n");
  exit (1);
}

static int
getsig (char *in_sig)
{
  char *sig;
  char buf[80];

  if (strncmp (in_sig, "SIG", 3) == 0)
    sig = in_sig;
  else
    {
      sprintf (buf, "SIG%s", in_sig);
      sig = buf;
    }
  return (strtosigno (sig) ?: atoi (in_sig));
}

static void __stdcall
forcekill (int pid, int sig, int wait)
{
  external_pinfo *p = (external_pinfo *) cygwin_internal (CW_GETPINFO_FULL, pid);
  if (!p)
    return;
  HANDLE h = OpenProcess (PROCESS_TERMINATE, FALSE, (DWORD) p->dwProcessId);
  if (!h)
    return;
  if (!wait || WaitForSingleObject (h, 200) != WAIT_OBJECT_0)
    TerminateProcess (h, sig << 8);
  CloseHandle (h);
@


1.9
log
@Update copyright.
@
text
@d64 11
a74 1
	fprintf (stderr, "kill: illegal pid: %s\n", *argv);
d77 4
a80 21
#if 0
	  printf ("Sending %s(%d) signal to pid %d\n",
		  strsignal (sig), sig, pid);
#endif
	  if (kill (pid, sig) == 0)
	    {
	      if (force)
		forcekill (pid, sig, 1);
	    }
	  else
	    {
	      if (force && sig != 0)
		forcekill (pid, sig, 0);
	      else
		{
		  char buf[1000];
		  sprintf (buf, "kill %d", pid);
		  perror (buf);
		  ret = 1;
		}
	    }
@


1.8
log
@* kill.cc (forcekill): Use dwProcessId when opening a process, not the Cygwin
pid.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Red Hat, Inc.
@


1.7
log
@        * kill.cc (main): Return 1 in case of errors.
@
text
@d123 1
a123 1
  HANDLE h = OpenProcess (PROCESS_TERMINATE, FALSE, (DWORD) p->pid);
@


1.6
log
@* ps.cc (main): Change order of reporting slightly so that windows pids are
more obvious.
* strace.cc (add_child): Just add child's pid directly.
(remove_child): No need to close the child process pid since ContinueDebugEvent
does that automatically.
(proc_child): Ditto for child thread.
@
text
@d30 1
d85 1
d91 1
a91 1
  return 0;
@


1.5
log
@* kill.cc (main): Change behavior of -f so that it will force the killing of a
cygwin process after waiting 2 tenths of a second for it to terminate.
(forcekill): Add an extra argument determining whether to wait for the process
to exit.
@
text
@d77 1
a77 1
	      if (errno == ESRCH && force && sig != 0)
@


1.4
log
@* kill.c (main): Avoid skipping next argument when a signal number is
specified.
* Makefile.in: Always clean dumper.exe.
@
text
@d18 1
d22 1
a22 1
static void __stdcall forcekill (int, int);
d70 6
a75 1
	  if (kill (pid, sig))
d78 1
a78 1
		forcekill (pid, sig);
d116 1
a116 1
forcekill (int pid, int sig)
d118 4
a121 1
  HANDLE h = OpenProcess (PROCESS_TERMINATE, FALSE, (DWORD) pid);
d124 2
a125 1
  TerminateProcess (h, sig << 8);
@


1.3
log
@* Makefile.in: Add dumper.exe target and associated mechanisms for building it.
* dumper.cc: New file.
* dumper.h: New file.
* module_info.cc: New file.
* parse_pe.cc: New file.
@
text
@d40 1
a40 1
	sig = getsig (*argv++ + 1);
@


1.2
log
@* kill.cc (main): Add '-f' option to force termination of a process.
(forcekill): New function.
* ps.cc (main): Add '-W' option to list Windows pids as well as Cygwin pids.
(dummyprocessmodules): New function.
(GetModuleFileNameEx95): New function.
(init_win): New function.
(to_time_t): New function.
@
text
@d33 1
a33 1
  while (*(++argv)[0] == '-')
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998 Cygnus Solutions.
d16 2
d20 2
a21 2
static int getsig (char *);
int a = _timezone;
d24 1
a24 1
main (int ac, char **av)
d27 2
d30 1
a30 1
  if (ac == 1)
d33 10
a42 3
  if (*(++av)[0] == '-')
    if (strcmp(*av + 1, "0") != 0)
      sig = getsig (*av++ + 1);
d45 1
a45 1
	av++;
d52 1
a52 1
      fprintf (stderr, "kill: unknown signal: %s\n", av[-1]);
d57 1
a57 1
  while (*av != NULL)
d60 1
a60 1
      int pid = strtol (*av, &p, 10);
d62 1
a62 1
	fprintf (stderr, "kill: illegal pid: %s\n", *av);
d65 1
d68 1
d70 10
a79 1
	    perror ("kill");
d81 1
a81 1
      av++;
d107 10
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
