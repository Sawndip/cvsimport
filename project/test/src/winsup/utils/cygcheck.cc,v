head	1.147;
access;
symbols
	cygwin-1_7_35-release:1.147
	cygwin-1_7_34-release:1.147
	cygwin-1_7_33-release:1.145.2.1
	cygwin-1_7_32-release:1.145
	cygwin-1_7_31-release:1.145
	cygwin-1_7_30-release:1.145
	cygwin-1_7_29-release:1.145
	cygwin-1_7_29-release-branchpoint:1.145.0.2
	cygwin-1_7_28-release:1.145
	cygwin-1_7_27-release:1.145
	cygwin-1_7_26-release:1.145
	cygwin-1_7_25-release:1.140
	cygwin-1_7_24-release:1.139
	cygwin-1_7_23-release:1.139
	cygwin-1_7_22-release:1.139
	cygwin-1_7_21-release:1.139
	cygwin-1_7_20-release:1.138
	cygwin-1_7_19-release:1.138
	cygwin-64bit-postmerge:1.138
	cygwin-64bit-premerge-branch:1.137.0.2
	cygwin-64bit-premerge:1.137
	cygwin-1_7_18-release:1.137
	cygwin-1_7_17-release:1.135
	cygwin-64bit-branch:1.133.0.2
	cygwin-1_7_16-release:1.133
	cygwin-1_7_15-release:1.131
	cygwin-1_7_14_2-release:1.131
	cygwin-1_7_14-release:1.131
	cygwin-1_7_12-release:1.131
	cygwin-1_7_11-release:1.131
	cygwin-1_7_10-release:1.131
	cygwin-1_7_9-release:1.126
	cygwin-1_7_8-release:1.126
	cygwin-1_7_7-release:1.124
	cygwin-1_7_5-release:1.123
	cygwin-1_7_4-release:1.123
	cygwin-1_7_3-release:1.123
	cygwin-1_7_2-release:1.123
	cygwin-1_7_1-release:1.123
	cv-branch-2:1.116.0.2
	cr-0x5f1:1.90.0.4
	cv-branch:1.90.0.2
	cr-0x3b58:1.86.0.2
	cr-0x9e:1.40.0.2
	cr-0x9d:1.39.0.2
	corinna-01:1.39
	cr-0x9c:1.38.0.2
	cr-0x9b:1.38.0.4
	cr-0x99:1.36
	Z-emcb-cygwin_daemon:1.36.0.2
	w32api-2_2:1.30
	mingw-runtime-2_4:1.30
	cygnus_cvs_20020108_pre:1.18
	Z-cygwin_daemon_merge-new_HEAD:1.7
	Z-cygwin_daemon_merge_HEAD:1.7
	cygwin_daemon:1.7.0.8;
locks; strict;
comment	@// @;


1.147
date	2014.11.10.16.21.52;	author corinna;	state Exp;
branches;
next	1.146;

1.146
date	2014.10.21.10.59.40;	author corinna;	state Exp;
branches;
next	1.145;

1.145
date	2013.11.19.22.26.37;	author corinna;	state Exp;
branches
	1.145.2.1;
next	1.144;

1.144
date	2013.11.19.20.43.04;	author corinna;	state Exp;
branches;
next	1.143;

1.143
date	2013.11.19.17.44.33;	author corinna;	state Exp;
branches;
next	1.142;

1.142
date	2013.11.19.11.14.36;	author corinna;	state Exp;
branches;
next	1.141;

1.141
date	2013.11.19.10.43.10;	author corinna;	state Exp;
branches;
next	1.140;

1.140
date	2013.08.23.19.56.26;	author cgf;	state Exp;
branches;
next	1.139;

1.139
date	2013.07.07.16.57.11;	author cgf;	state Exp;
branches;
next	1.138;

1.138
date	2013.04.23.09.44.36;	author corinna;	state Exp;
branches;
next	1.137;

1.137
date	2013.01.21.16.28.27;	author cgf;	state Exp;
branches;
next	1.136;

1.136
date	2012.10.24.10.15.27;	author yselkowitz;	state Exp;
branches;
next	1.135;

1.135
date	2012.10.09.12.47.40;	author corinna;	state Exp;
branches;
next	1.134;

1.134
date	2012.09.02.10.06.12;	author corinna;	state Exp;
branches;
next	1.133;

1.133
date	2012.07.11.16.41.51;	author corinna;	state Exp;
branches
	1.133.2.1;
next	1.132;

1.132
date	2012.06.03.16.45.27;	author corinna;	state Exp;
branches;
next	1.131;

1.131
date	2011.12.17.23.39.47;	author cgf;	state Exp;
branches;
next	1.130;

1.130
date	2011.10.13.17.50.48;	author corinna;	state Exp;
branches;
next	1.129;

1.129
date	2011.10.10.14.57.47;	author corinna;	state Exp;
branches;
next	1.128;

1.128
date	2011.10.10.09.42.00;	author corinna;	state Exp;
branches;
next	1.127;

1.127
date	2011.03.29.11.02.58;	author corinna;	state Exp;
branches;
next	1.126;

1.126
date	2011.02.15.15.57.35;	author corinna;	state Exp;
branches;
next	1.125;

1.125
date	2011.01.10.12.51.02;	author corinna;	state Exp;
branches;
next	1.124;

1.124
date	2010.08.28.11.22.37;	author corinna;	state Exp;
branches;
next	1.123;

1.123
date	2009.11.27.10.01.50;	author corinna;	state Exp;
branches;
next	1.122;

1.122
date	2009.11.04.17.00.45;	author corinna;	state Exp;
branches;
next	1.121;

1.121
date	2009.10.31.13.26.37;	author corinna;	state Exp;
branches;
next	1.120;

1.120
date	2009.10.28.11.41.27;	author corinna;	state Exp;
branches;
next	1.119;

1.119
date	2009.10.20.15.26.33;	author corinna;	state Exp;
branches;
next	1.118;

1.118
date	2009.07.23.09.12.18;	author corinna;	state Exp;
branches;
next	1.117;

1.117
date	2009.07.13.10.40.42;	author corinna;	state Exp;
branches;
next	1.116;

1.116
date	2009.05.04.18.51.08;	author cgf;	state Exp;
branches;
next	1.115;

1.115
date	2009.05.04.10.15.48;	author corinna;	state Exp;
branches;
next	1.114;

1.114
date	2009.04.03.11.50.26;	author corinna;	state Exp;
branches;
next	1.113;

1.113
date	2009.03.24.13.35.08;	author corinna;	state Exp;
branches;
next	1.112;

1.112
date	2009.03.14.14.56.20;	author corinna;	state Exp;
branches;
next	1.111;

1.111
date	2009.03.08.21.13.26;	author cgf;	state Exp;
branches;
next	1.110;

1.110
date	2009.01.29.19.31.04;	author corinna;	state Exp;
branches;
next	1.109;

1.109
date	2009.01.17.11.59.16;	author corinna;	state Exp;
branches;
next	1.108;

1.108
date	2009.01.16.12.10.02;	author corinna;	state Exp;
branches;
next	1.107;

1.107
date	2009.01.06.04.11.23;	author phumblet;	state Exp;
branches;
next	1.106;

1.106
date	2008.12.31.01.44.36;	author phumblet;	state Exp;
branches;
next	1.105;

1.105
date	2008.09.12.22.43.10;	author cgf;	state Exp;
branches;
next	1.104;

1.104
date	2008.08.27.20.11.11;	author cgf;	state Exp;
branches;
next	1.103;

1.103
date	2008.08.17.17.15.41;	author cgf;	state Exp;
branches;
next	1.102;

1.102
date	2008.08.04.15.30.06;	author cgf;	state Exp;
branches;
next	1.101;

1.101
date	2008.07.27.14.53.42;	author cgf;	state Exp;
branches;
next	1.100;

1.100
date	2008.04.22.14.42.05;	author corinna;	state Exp;
branches;
next	1.99;

1.99
date	2008.03.11.18.43.11;	author briand;	state Exp;
branches;
next	1.98;

1.98
date	2008.03.11.17.20.02;	author briand;	state Exp;
branches;
next	1.97;

1.97
date	2008.01.13.13.41.45;	author corinna;	state Exp;
branches;
next	1.96;

1.96
date	2007.08.03.19.41.48;	author davek;	state Exp;
branches;
next	1.95;

1.95
date	2007.06.04.01.57.16;	author cgf;	state Exp;
branches;
next	1.94;

1.94
date	2007.02.20.16.41.54;	author corinna;	state Exp;
branches;
next	1.93;

1.93
date	2006.10.05.17.24.13;	author corinna;	state Exp;
branches;
next	1.92;

1.92
date	2006.09.13.15.33.37;	author cgf;	state Exp;
branches;
next	1.91;

1.91
date	2006.09.13.15.32.04;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2006.02.08.14.19.40;	author corinna;	state Exp;
branches
	1.90.4.1;
next	1.89;

1.89
date	2006.02.08.14.13.28;	author corinna;	state Exp;
branches;
next	1.88;

1.88
date	2006.01.19.21.16.38;	author cgf;	state Exp;
branches;
next	1.87;

1.87
date	2006.01.19.20.17.11;	author cgf;	state Exp;
branches;
next	1.86;

1.86
date	2006.01.17.15.37.13;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2006.01.15.09.29.02;	author corinna;	state Exp;
branches;
next	1.84;

1.84
date	2006.01.13.15.36.29;	author corinna;	state Exp;
branches;
next	1.83;

1.83
date	2006.01.13.13.39.05;	author corinna;	state Exp;
branches;
next	1.82;

1.82
date	2006.01.12.17.43.53;	author cgf;	state Exp;
branches;
next	1.81;

1.81
date	2006.01.05.18.31.26;	author cgf;	state Exp;
branches;
next	1.80;

1.80
date	2005.12.29.19.23.46;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2005.12.15.03.36.14;	author cgf;	state Exp;
branches;
next	1.78;

1.78
date	2005.11.22.17.19.17;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2005.08.17.00.52.43;	author briand;	state Exp;
branches;
next	1.76;

1.76
date	2005.07.19.21.00.34;	author cgf;	state Exp;
branches;
next	1.75;

1.75
date	2005.07.05.21.41.37;	author cgf;	state Exp;
branches;
next	1.74;

1.74
date	2005.05.30.15.49.31;	author corinna;	state Exp;
branches;
next	1.73;

1.73
date	2005.05.27.15.45.53;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2005.05.23.09.54.44;	author corinna;	state Exp;
branches;
next	1.71;

1.71
date	2005.05.20.16.50.39;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2005.05.20.16.38.42;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2005.05.17.01.26.16;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2005.05.16.03.18.29;	author cgf;	state Exp;
branches;
next	1.67;

1.67
date	2005.05.15.12.29.47;	author corinna;	state Exp;
branches;
next	1.66;

1.66
date	2005.05.09.01.56.34;	author cgf;	state Exp;
branches;
next	1.65;

1.65
date	2005.03.24.14.48.15;	author corinna;	state Exp;
branches;
next	1.64;

1.64
date	2004.11.18.05.20.23;	author bavag;	state Exp;
branches;
next	1.63;

1.63
date	2004.11.16.05.16.59;	author bavag;	state Exp;
branches;
next	1.62;

1.62
date	2004.11.11.01.56.02;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2004.11.11.01.52.33;	author cgf;	state Exp;
branches;
next	1.60;

1.60
date	2004.11.11.01.17.29;	author bavag;	state Exp;
branches;
next	1.59;

1.59
date	2004.10.31.18.46.31;	author bavag;	state Exp;
branches;
next	1.58;

1.58
date	2004.10.27.01.28.07;	author bavag;	state Exp;
branches;
next	1.57;

1.57
date	2004.10.25.16.11.41;	author bavag;	state Exp;
branches;
next	1.56;

1.56
date	2004.10.25.15.49.36;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2004.10.22.01.29.10;	author bavag;	state Exp;
branches;
next	1.54;

1.54
date	2004.10.21.00.06.37;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2004.10.18.10.25.38;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2004.10.18.01.44.55;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2004.10.17.23.31.23;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2004.10.15.13.57.56;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2004.10.14.17.35.46;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2004.10.10.17.07.23;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2004.10.09.23.19.38;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2004.10.09.23.15.36;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2004.10.06.09.46.40;	author corinna;	state Exp;
branches;
next	1.44;

1.44
date	2004.10.04.09.42.08;	author corinna;	state Exp;
branches;
next	1.43;

1.43
date	2004.03.21.17.58.14;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2004.02.10.16.15.52;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2004.02.10.16.01.31;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2004.01.23.23.04.27;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2003.10.17.17.19.31;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2003.09.11.16.24.26;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2003.09.11.02.56.40;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2003.08.15.20.26.11;	author corinna;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.13.02.36.12;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2003.04.26.21.52.03;	author joshuadfranklin;	state Exp;
branches;
next	1.33;

1.33
date	2003.03.25.01.20.04;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2003.03.04.05.30.50;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2003.03.01.03.38.19;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2003.02.07.04.51.26;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2002.09.19.03.48.19;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2002.09.17.17.13.21;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2002.09.15.19.24.36;	author joshuadfranklin;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.07.03.13.17;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.07.03.06.28;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2002.02.27.16.25.30;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.27.16.10.17;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.29.03.08.42;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.29.02.28.44;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.22.03.17.59;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.18.02.57.10;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.11.22.51.01;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.04.04.12.39;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.12.21.55.39;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.12.21.28.32;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.12.20.21.43;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.12.17.55.52;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.12.00.10.12;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.11.06.16.18;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.11.06.07.36;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.11.03.06.59;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.09.17.18.36;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.16.04.53.30;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.28.05.39.38;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.28.05.00.00;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.16.23.12.58;	author corinna;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.29.11.20.53;	author corinna;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.25.03.18.54;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.145.2.1
date	2014.11.13.12.53.12;	author corinna;	state Exp;
branches;
next	;

1.133.2.1
date	2012.08.16.16.26.01;	author corinna;	state Exp;
branches;
next	1.133.2.2;

1.133.2.2
date	2012.10.16.14.53.22;	author corinna;	state Exp;
branches;
next	1.133.2.3;

1.133.2.3
date	2012.10.24.13.01.59;	author corinna;	state Exp;
branches;
next	1.133.2.4;

1.133.2.4
date	2013.01.29.21.54.42;	author corinna;	state Exp;
branches;
next	1.133.2.5;

1.133.2.5
date	2013.02.06.17.03.49;	author corinna;	state Exp;
branches;
next	1.133.2.6;

1.133.2.6
date	2013.02.06.17.54.25;	author corinna;	state Exp;
branches;
next	1.133.2.7;

1.133.2.7
date	2013.02.19.14.27.36;	author corinna;	state Exp;
branches;
next	1.133.2.8;

1.133.2.8
date	2013.03.28.17.20.09;	author corinna;	state Exp;
branches;
next	;

1.90.4.1
date	2007.11.12.15.31.45;	author corinna;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.147
log
@	* cygcheck.cc (dump_sysinfo): Handle Windows 10/Server 2014(?).
@
text
@/* cygcheck.cc

   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
   2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.

   This file is part of Cygwin.

   This software is a copyrighted work licensed under the terms of the
   Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
   details. */

#define _WIN32_WINNT 0x0602
#define cygwin_internal cygwin_internal_dontuse
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <sys/time.h>
#include <ctype.h>
#include <io.h>
#include <windows.h>
#include <wininet.h>
#include "path.h"
#include "wide_path.h"
#include <getopt.h>
#include "../cygwin/include/cygwin/version.h"
#include "../cygwin/include/sys/cygwin.h"
#define _NOMNTENT_MACROS
#include "../cygwin/include/mntent.h"
#include "../cygwin/cygprops.h"
#undef cygwin_internal
#include "loadlib.h"

#ifndef max
#define max __max
#endif

#ifndef alloca
#define alloca __builtin_alloca
#endif

int verbose = 0;
int registry = 0;
int sysinfo = 0;
int givehelp = 0;
int keycheck = 0;
int check_setup = 0;
int dump_only = 0;
int find_package = 0;
int list_package = 0;
int grep_packages = 0;
int del_orphaned_reg = 0;
int unique_object_name_opt = 0;

static char emptystr[] = "";

#ifdef __GNUC__
typedef long long longlong;
#else
typedef __int64 longlong;
#endif

/* In dump_setup.cc  */
void dump_setup (int, char **, bool);
void package_find (int, char **);
void package_list (int, char **);
/* In bloda.cc  */
void dump_dodgy_apps (int verbose);
/* Forward declaration */
static void usage (FILE *, int);

static const char *known_env_vars[] = {
  "c_include_path",
  "compiler_path",
  "cxx_include_path",
  "cygwin",
  "cygwin32",
  "dejagnu",
  "expect",
  "gcc_default_options",
  "gcc_exec_prefix",
  "home",
  "ld_library_path",
  "library_path",
  "login",
  "lpath",
  "make_mode",
  "makeflags",
  "path",
  "pwd",
  "strace",
  "tcl_library",
  "user",
  0
};

struct
{
  const char *name;
  int missing_is_good;
}
static common_apps[] = {
  {"awk", 0},
  {"bash", 0},
  {"cat", 0},
  {"cp", 0},
  {"cpp", 1},
  {"crontab", 0},
  {"find", 0},
  {"gcc", 0},
  {"gdb", 0},
  {"grep", 0},
  {"kill", 0},
  {"ld", 0},
  {"ls", 0},
  {"make", 0},
  {"mv", 0},
  {"patch", 0},
  {"perl", 0},
  {"rm", 0},
  {"sed", 0},
  {"ssh", 0},
  {"sh", 0},
  {"tar", 0},
  {"test", 0},
  {"vi", 0},
  {"vim", 0},
  {0, 0}
};

/* Options without ASCII single char representation. */
enum
{
  CO_DELETE_KEYS = 0x100,
  CO_ENABLE_UON = 0x101,
  CO_DISABLE_UON = 0x102,
  CO_SHOW_UON = 0x103
};

static int num_paths, max_paths;
struct pathlike
{
  char *dir;
  bool issys;
  void check_existence (const char *fn, int showall, int verbose,
			char* first, const char *ext1 = "",
			const char *ext2 = "");
};

pathlike *paths;
int first_nonsys_path;

void
eprintf (const char *format, ...)
{
  va_list ap;
  va_start (ap, format);
  vfprintf (stderr, format, ap);
  va_end (ap);
}

/*
 * display_error() is used to report failure modes
 */
static int
display_error (const char *name, bool show_error, bool print_failed)
{
  fprintf (stderr, "cygcheck: %s", name);
  if (show_error)
    fprintf (stderr, "%s: %lu\n",
	print_failed ? " failed" : "", GetLastError ());
  else
    fprintf (stderr, "%s\n",
	print_failed ? " failed" : "");
  return 1;
}

static int
display_error (const char *name)
{
  return display_error (name, true, true);
}

static int
display_error (const char *fmt, const char *x)
{
  char buf[4000];
  snprintf (buf, sizeof buf, fmt, x);
  return display_error (buf, false, false);
}

static int
display_error_fmt (const char *fmt, ...)
{
  char buf[4000];
  va_list va;

  va_start (va, fmt);
  vsnprintf (buf, sizeof buf, fmt, va);
  return display_error (buf, false, false);
}

/* Display a WinInet error message, and close a variable number of handles.
   (Passed a list of handles terminated by NULL.)  */
static int
display_internet_error (const char *message, ...)
{
  DWORD err = GetLastError ();
  TCHAR err_buf[256];
  va_list hptr;
  HINTERNET h;

  /* in the case of a successful connection but 404 response, there is no
     win32 error message, but we still get passed a message to display.  */
  if (err)
    {
      if (FormatMessage (FORMAT_MESSAGE_FROM_HMODULE,
	  GetModuleHandle ("wininet.dll"), err, 0, err_buf,
	  sizeof (err_buf), NULL) == 0)
	strcpy (err_buf, "(Unknown error)");

      fprintf (stderr, "cygcheck: %s: %s (win32 error %lu)\n", message,
	       err_buf, err);
    }
  else
    fprintf (stderr, "cygcheck: %s\n", message);

  va_start (hptr, message);
  while ((h = va_arg (hptr, HINTERNET)) != 0)
    InternetCloseHandle (h);
  va_end (hptr);

  return 1;
}

static void
add_path (char *s, int maxlen, bool issys)
{
  if (num_paths >= max_paths)
    {
      max_paths += 10;
      /* Extend path array */
      paths = (pathlike *) realloc (paths, (1 + max_paths) * sizeof (paths[0]));
    }

  pathlike *pth = paths + num_paths;

  /* Allocate space for directory in path list */
  char *dir = (char *) calloc (maxlen + 2, sizeof (char));
  if (dir == NULL)
    {
      display_error ("add_path: calloc() failed");
      return;
    }

  /* Copy input directory to path list */
  memcpy (dir, s, maxlen);

  /* Add a trailing slash by default */
  char *e = strchr (dir, '\0');
  if (e != dir && e[-1] != '\\')
    strcpy (e, "\\");

  /* Fill out this element */
  pth->dir = dir;
  pth->issys = issys;
  pth[1].dir = NULL;
  num_paths++;
}

static void
init_paths ()
{
  char tmp[4000], *sl;
  add_path ((char *) ".", 1, true);	/* to be replaced later */

  if (GetCurrentDirectory (4000, tmp))
    add_path (tmp, strlen (tmp), true);
  else
    display_error ("init_paths: GetCurrentDirectory()");

  if (GetSystemDirectory (tmp, 4000))
    add_path (tmp, strlen (tmp), true);
  else
    display_error ("init_paths: GetSystemDirectory()");
  sl = strrchr (tmp, '\\');
  if (sl)
    {
      strcpy (sl, "\\SYSTEM");
      add_path (tmp, strlen (tmp), true);
    }
  GetWindowsDirectory (tmp, 4000);
  add_path (tmp, strlen (tmp), true);

  char *wpath = getenv ("PATH");
  if (!wpath)
    display_error ("WARNING: PATH is not set\n", "");
  else
    {
      char *b, *e;
      b = wpath;
      while (1)
	{
	  for (e = b; *e && *e != ';'; e++)
	    continue;	/* loop terminates at first ';' or EOS */
	  if (strncmp(b, ".\\", 2) != 0)
	    add_path (b, e - b, false);
	  if (!*e)
	    break;
	  b = e + 1;
	}
    }
}

#define LINK_EXTENSION ".lnk"

void
pathlike::check_existence (const char *fn, int showall, int verbose,
			   char* first, const char *ext1, const char *ext2)
{
  char file[4000];
  strcpy (file, dir);
  strcat (file, fn);
  strcat (file, ext1);
  strcat (file, ext2);

  wide_path wpath (file);
  if (GetFileAttributesW (wpath) != (DWORD) - 1)
    {
      char *lastdot = strrchr (file, '.');
      bool is_link = lastdot && !strcmp (lastdot, LINK_EXTENSION);
      // If file is a link, fix up the extension before printing
      if (is_link)
	*lastdot = '\0';
      if (showall)
	printf ("Found: %s\n", file);
      if (verbose && *first != '\0' && strcasecmp (first, file) != 0)
	{
	  char *flastdot = strrchr (first, '.');
	  bool f_is_link = flastdot && !strcmp (flastdot, LINK_EXTENSION);
	  // if first is a link, fix up the extension before printing
	  if (f_is_link)
	    *flastdot = '\0';
	  printf ("Warning: %s hides %s\n", first, file);
	  if (f_is_link)
	    *flastdot = '.';
	}
      if (is_link)
	*lastdot = '.';
      if (!*first)
	strcpy (first, file);
    }
}

static const char *
find_on_path (const char *in_file, const char *ext, bool showall = false,
	      bool search_sys = false, bool checklinks = false)
{
  static char rv[4000];

  /* Sort of a kludge but we've already tested this once, so don't try it again */
  if (in_file == rv)
    return in_file;

  static pathlike abspath[2] =
  {
    {emptystr, 0},
    {NULL, 0}
  };

  *rv = '\0';
  if (!in_file)
    {
      display_error ("internal error find_on_path: NULL pointer for file", false, false);
      return 0;
    }

  if (!ext)
    {
      display_error ("internal error find_on_path: NULL pointer for default_extension", false, false);
      return 0;
    }

  const char *file;
  pathlike *search_paths;
  if (!strpbrk (in_file, ":/\\"))
    {
      file = in_file;
      search_paths = paths;
    }
  else
    {
      file = cygpath (in_file, NULL);
      search_paths = abspath;
      showall = false;
    }

  if (!file)
    {
      display_error ("internal error find_on_path: cygpath conversion failed for %s\n", in_file);
      return 0;
    }

  char *hasext = strrchr (file, '.');
  if (hasext && !strpbrk (hasext, "/\\"))
    ext = "";

  for (pathlike *pth = search_paths; pth->dir; pth++)
    if (!pth->issys || search_sys)
      {
	pth->check_existence (file, showall, verbose, rv, ext);

	if (checklinks)
	  pth->check_existence (file, showall, verbose, rv, ext, LINK_EXTENSION);

	if (!*ext)
	  continue;

	pth->check_existence (file, showall, verbose, rv);
	if (checklinks)
	  pth->check_existence (file, showall, verbose, rv, LINK_EXTENSION);
      }

  return *rv ? rv : NULL;
}

#define DID_NEW		1
#define DID_ACTIVE	2
#define DID_INACTIVE	3

struct Did
{
  Did *next;
  char *file;
  int state;
};
static Did *did = 0;

static Did *
already_did (const char *file)
{
  Did *d;
  for (d = did; d; d = d->next)
    if (strcasecmp (d->file, file) == 0)
      return d;
  d = (Did *) malloc (sizeof (Did));
  d->file = strdup (file);
  d->next = did;
  d->state = DID_NEW;
  did = d;
  return d;
}

struct Section
{
  char name[8];
  int virtual_size;
  int virtual_address;
  int size_of_raw_data;
  int pointer_to_raw_data;
};

static int
rva_to_offset (int rva, char *sections, int nsections, int *sz)
{
  int i;

  if (sections == NULL)
    {
      display_error ("rva_to_offset: NULL passed for sections", true, false);
      return 0;
    }

  for (i = 0; i < nsections; i++)
    {
      Section *s = (Section *) (sections + i * 40);
#if 0
      printf ("%08x < %08x < %08x ? %08x\n",
	      s->virtual_address, rva,
	      s->virtual_address + s->virtual_size, s->pointer_to_raw_data);
#endif
      if (rva >= s->virtual_address
	  && rva < s->virtual_address + s->virtual_size)
	{
	  if (sz)
	    *sz = s->virtual_address + s->virtual_size - rva;
	  return rva - s->virtual_address + s->pointer_to_raw_data;
	}
    }
  return 0;			/* punt */
}

struct ExpDirectory
{
  int flags;
  int timestamp;
  short major_ver;
  short minor_ver;
  int name_rva;
};

struct ImpDirectory
{
  unsigned characteristics;
  unsigned timestamp;
  unsigned forwarder_chain;
  unsigned name_rva;
  unsigned iat_rva;
};

static bool track_down (const char *file, const char *suffix, int lvl);

#define CYGPREFIX (sizeof ("%%% Cygwin ") - 1)
static void
cygwin_info (HANDLE h)
{
  char *buf, *bufend, *buf_start = NULL;
  const char *hello = "    Cygwin DLL version info:\n";
  DWORD size = GetFileSize (h, NULL);
  DWORD n;

  if (size == 0xffffffff)
    return;

  buf_start = buf = (char *) calloc (1, size + 1);
  if (buf == NULL)
    {
      display_error ("cygwin_info: calloc()");
      return;
    }

  (void) SetFilePointer (h, 0, NULL, FILE_BEGIN);
  if (!ReadFile (h, buf, size, &n, NULL))
    {
      free (buf_start);
      return;
    }

  static char dummy[] = "\0\0\0\0\0\0\0";
  char *dll_major = dummy;
  bufend = buf + size;
  while (buf < bufend)
    if ((buf = (char *) memchr (buf, '%', bufend - buf)) == NULL)
      break;
    else if (strncmp ("%%% Cygwin ", buf, CYGPREFIX) != 0)
      buf++;
    else
      {
	char *p = strchr (buf += CYGPREFIX, '\n');
	if (!p)
	  break;
	if (strncasecmp (buf, "dll major:", 10) == 0)
	  {
	    dll_major = buf + 11;
	    continue;
	  }
	char *s, pbuf[80];
	int len;
	len = 1 + p - buf;
	if (strncasecmp (buf, "dll minor:", 10) != 0)
	  s = buf;
	else
	  {
	    char c = dll_major[1];
	    dll_major[1] = '\0';
	    int maj = atoi (dll_major);
	    dll_major[1] = c;
	    int min = atoi (dll_major + 1);
	    sprintf (pbuf, "DLL version: %d.%d.%.*s", maj, min, len - 11,
		     buf + 11);
	    len = strlen (s = pbuf);
	  }
	if (strncmp (s, "dll", 3) == 0)
	  memcpy (s, "DLL", 3);
	else if (strncmp (s, "api", 3) == 0)
	  memcpy (s, "API", 3);
	else if (islower (*s))
	  *s = toupper (*s);
	fprintf (stdout, "%s        %.*s", hello, len, s);
	hello = "";
      }

  if (!*hello)
    puts ("");

  free (buf_start);
  return;
}

static void
dll_info (const char *path, HANDLE fh, int lvl, int recurse)
{
  DWORD junk;
  int i;
  if (is_symlink (fh))
    {
      if (!verbose)
	puts ("");
      else
	{
	  char buf[PATH_MAX + 1] = "";
	  readlink (fh, buf, sizeof(buf) - 1);
	  printf (" (symlink to %s)\n", buf);
	}
      return;
    }
  int pe_header_offset = get_dword (fh, 0x3c);
  if (GetLastError () != NO_ERROR)
    display_error ("get_dword");
  WORD arch = get_word (fh, pe_header_offset + 4);
  if (GetLastError () != NO_ERROR)
    display_error ("get_word");
#ifdef __x86_64__
  if (arch != IMAGE_FILE_MACHINE_AMD64)
    {
      puts (verbose ? " (not x86_64 dll)" : "\n");
      return;
    }
  int base_off = 108;
#else
  if (arch != IMAGE_FILE_MACHINE_I386)
    {
      puts (verbose ? " (not x86 dll)" : "\n");
      return;
    }
  int base_off = 92;
#endif
  int opthdr_ofs = pe_header_offset + 4 + 20;
  unsigned short v[6];

  if (path == NULL)
    {
      display_error ("dll_info: NULL passed for path", true, false);
      return;
    }

  if (SetFilePointer (fh, opthdr_ofs + 40, 0, FILE_BEGIN) ==
      INVALID_SET_FILE_POINTER && GetLastError () != NO_ERROR)
    display_error ("dll_info: SetFilePointer()");

  if (!ReadFile (fh, &v, sizeof (v), &junk, 0))
    display_error ("dll_info: Readfile()");

  if (verbose)
    printf (" - os=%d.%d img=%d.%d sys=%d.%d\n",
	    v[0], v[1], v[2], v[3], v[4], v[5]);
  else
    printf ("\n");

  int num_entries = get_dword (fh, opthdr_ofs + base_off + 0);
  if (GetLastError () != NO_ERROR)
    display_error ("get_dword");
  int export_rva = get_dword (fh, opthdr_ofs + base_off + 4);
  if (GetLastError () != NO_ERROR)
    display_error ("get_dword");
  int export_size = get_dword (fh, opthdr_ofs + base_off + 8);
  if (GetLastError () != NO_ERROR)
    display_error ("get_dword");
  int import_rva = get_dword (fh, opthdr_ofs + base_off + 12);
  if (GetLastError () != NO_ERROR)
    display_error ("get_dword");
  int import_size = get_dword (fh, opthdr_ofs + base_off + 16);
  if (GetLastError () != NO_ERROR)
    display_error ("get_dword");

  int nsections = get_word (fh, pe_header_offset + 4 + 2);
  if (nsections == -1)
    display_error ("get_word");
  char *sections = (char *) malloc (nsections * 40);

  if (SetFilePointer (fh, pe_header_offset + 4 + 20 +
		      get_word (fh, pe_header_offset + 4 + 16), 0,
		      FILE_BEGIN) == INVALID_SET_FILE_POINTER
      && GetLastError () != NO_ERROR)
    display_error ("dll_info: SetFilePointer()");

  if (!ReadFile (fh, sections, nsections * 40, &junk, 0))
    display_error ("dll_info: Readfile()");

  if (verbose && num_entries >= 1 && export_size > 0)
    {
      int expsz;
      int expbase = rva_to_offset (export_rva, sections, nsections, &expsz);

      if (expbase)
	{
	  if (SetFilePointer (fh, expbase, 0, FILE_BEGIN) ==
	      INVALID_SET_FILE_POINTER && GetLastError () != NO_ERROR)
	    display_error ("dll_info: SetFilePointer()");

	  unsigned char *exp = (unsigned char *) malloc (expsz);

	  if (!ReadFile (fh, exp, expsz, &junk, 0))
	    display_error ("dll_info: Readfile()");

	  ExpDirectory *ed = (ExpDirectory *) exp;
	  int ofs = ed->name_rva - export_rva;
	  time_t ts = ed->timestamp;	/* timestamp is only 4 bytes! */
	  struct tm *tm = localtime (&ts);
	  if (tm && tm->tm_year < 60)
	    tm->tm_year += 2000;
	  if (tm && tm->tm_year < 200)
	    tm->tm_year += 1900;
	  printf ("%*c", lvl + 2, ' ');
	  printf ("\"%s\" v%d.%d", exp + ofs,
		  ed->major_ver, ed->minor_ver);
	  if (tm)
	    printf (" ts=%04d-%02d-%02d %02d:%02d",
		    tm->tm_year, tm->tm_mon + 1, tm->tm_mday,
		    tm->tm_hour, tm->tm_min);
	  putchar ('\n');
	}
    }

  if (num_entries >= 2 && import_size > 0 && recurse)
    {
      int impsz;
      int impbase = rva_to_offset (import_rva, sections, nsections, &impsz);
      if (impbase)
	{
	  if (SetFilePointer (fh, impbase, 0, FILE_BEGIN) ==
	      INVALID_SET_FILE_POINTER && GetLastError () != NO_ERROR)
	    display_error ("dll_info: SetFilePointer()");

	  unsigned char *imp = (unsigned char *) malloc (impsz);
	  if (imp == NULL)
	    {
	      display_error ("dll_info: malloc()");
	      return;
	    }

	  if (!ReadFile (fh, imp, impsz, &junk, 0))
	    display_error ("dll_info: Readfile()");

	  ImpDirectory *id = (ImpDirectory *) imp;
	  for (i = 0; id[i].name_rva; i++)
	    {
	      /* int ofs = id[i].name_rva - import_rva; */
	      track_down ((char *) imp + id[i].name_rva - import_rva,
			  (char *) ".dll", lvl + 2);
	    }
	}
    }
  if (strstr (path, "\\cygwin1.dll"))
    cygwin_info (fh);
}

// Return true on success, false if error printed
static bool
track_down (const char *file, const char *suffix, int lvl)
{
  if (file == NULL)
    {
      display_error ("track_down: NULL passed for file", true, false);
      return false;
    }

  if (suffix == NULL)
    {
      display_error ("track_down: NULL passed for suffix", false, false);
      return false;
    }

  const char *path = find_on_path (file, suffix, false, true);
  if (!path)
    {
      display_error ("track_down: could not find %s\n", file);
      return false;
    }

  Did *d = already_did (file);
  switch (d->state)
    {
    case DID_NEW:
      break;
    case DID_ACTIVE:
      if (verbose)
	{
	  if (lvl)
	    printf ("%*c", lvl, ' ');
	  printf ("%s", path);
	  printf (" (recursive)\n");
	}
      return true;
    case DID_INACTIVE:
      if (verbose)
	{
	  if (lvl)
	    printf ("%*c", lvl, ' ');
	  printf ("%s", path);
	  printf (" (already done)\n");
	}
      return true;
    default:
      break;
    }

  if (lvl)
    printf ("%*c", lvl, ' ');

  if (!path)
    {
      display_error ("file not found - '%s'\n", file);
      return false;
    }

  printf ("%s", path);

  wide_path wpath (path);
  HANDLE fh =
    CreateFileW (wpath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
		 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
  if (fh == INVALID_HANDLE_VALUE)
    {
      display_error ("cannot open - '%s'\n", path);
      return false;
    }

  d->state = DID_ACTIVE;

  if (is_exe (fh))
    dll_info (path, fh, lvl, 1);
  else if (is_symlink (fh))
    display_error ("%s is a symlink instead of a DLL\n", path);
  else
    {
      int magic = get_word (fh, 0x0);
      if (magic == -1)
	display_error ("get_word");
      magic &= 0x00FFFFFF;
      display_error_fmt ("%s is not a DLL: magic number %x (%d) '%s'\n",
			 path, magic, magic, (char *)&magic);
    }

  d->state = DID_INACTIVE;
  if (!CloseHandle (fh))
    display_error ("track_down: CloseHandle()");
  return true;
}

static void
ls (char *f)
{
  wide_path wpath (f);
  HANDLE h = CreateFileW (wpath, GENERIC_READ,
			  FILE_SHARE_READ | FILE_SHARE_WRITE,
			  0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
  BY_HANDLE_FILE_INFORMATION info;

  if (!GetFileInformationByHandle (h, &info))
    display_error ("ls: GetFileInformationByHandle()");

  SYSTEMTIME systime;

  if (!FileTimeToSystemTime (&info.ftLastWriteTime, &systime))
    display_error ("ls: FileTimeToSystemTime()");
  printf ("%5dk %04d/%02d/%02d %s",
	  (((int) info.nFileSizeLow) + 512) / 1024,
	  systime.wYear, systime.wMonth, systime.wDay, f);
  dll_info (f, h, 16, 0);
  if (!CloseHandle (h))
    display_error ("ls: CloseHandle()");
}

/* Remove filename from 's' and return directory name without trailing
   backslash, or NULL if 's' doesn't seem to have a dirname.  */
static char *
dirname (const char *s)
{
  static char buf[PATH_MAX];

  if (!s)
    return NULL;

  strncpy (buf, s, PATH_MAX);
  buf[PATH_MAX - 1] = '\0';   // in case strlen(s) > PATH_MAX
  char *lastsep = strrchr (buf, '\\');
  if (!lastsep)
    return NULL;          // no backslash -> no dirname
  else if (lastsep - buf <= 2 && buf[1] == ':')
    lastsep[1] = '\0';    // can't remove backslash of "x:\"
  else
    *lastsep = '\0';
  return buf;
}

// Find a real application on the path (possibly following symlinks)
static const char *
find_app_on_path (const char *app, bool showall = false)
{
  const char *papp = find_on_path (app, ".exe", showall, false, true);

  if (!papp)
    return NULL;

  wide_path wpath (papp);
  HANDLE fh =
    CreateFileW (wpath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
		 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
  if (fh == INVALID_HANDLE_VALUE)
    return NULL;

  if (is_symlink (fh))
    {
      static char tmp[SYMLINK_MAX + 1];
      if (!readlink (fh, tmp, SYMLINK_MAX))
	display_error("readlink failed");

      /* Resolve the linkname relative to the directory of the link.  */
      char *ptr = cygpath_rel (dirname (papp), tmp, NULL);
      printf (" -> %s\n", ptr);
      if (!strchr (ptr, '\\'))
	{
	  char *lastsep;
	  strncpy (tmp, cygpath (papp, NULL), SYMLINK_MAX);
	  lastsep = strrchr (tmp, '\\');
	  strncpy (lastsep+1, ptr, SYMLINK_MAX - (lastsep-tmp));
	  ptr = tmp;
	}
      if (!CloseHandle (fh))
	display_error ("find_app_on_path: CloseHandle()");
      /* FIXME: We leak the ptr returned by cygpath() here which is a
	 malloc()d string.  */
      return find_app_on_path (ptr, showall);
    }

  if (!CloseHandle (fh))
    display_error ("find_app_on_path: CloseHandle()");
  return papp;
}

// Return true on success, false if error printed
static bool
cygcheck (const char *app)
{
  const char *papp = find_app_on_path (app, 1);
  if (!papp)
    {
      display_error ("could not find '%s'\n", app);
      return false;
    }

  char *s;
  char *sep = strpbrk (papp, ":/\\");
  if (!sep)
    {
      static char dot[] = ".";
      s = dot;
    }
  else
    {
      int n = sep - papp;
      s = (char *) malloc (n + 2);
      memcpy ((char *) s, papp, n);
      strcpy (s + n, "\\");
    }

  paths[0].dir = s;
  did = NULL;
  return track_down (papp, ".exe", 0);
}

struct RegInfo
{
  RegInfo *prev;
  char *name;
  HKEY key;
};

static void
show_reg (RegInfo * ri, int nest)
{
  if (!ri)
    return;
  show_reg (ri->prev, 1);
  if (nest)
    printf ("%s\\", ri->name);
  else
    printf ("%s\n", ri->name);
}

static void
scan_registry (RegInfo * prev, HKEY hKey, char *name, int cygwin, bool wow64)
{
  RegInfo ri;
  ri.prev = prev;
  ri.name = name;
  ri.key = hKey;

  char *cp;
  for (cp = name; *cp; cp++)
    if (strncasecmp (cp, "Cygwin", 6) == 0)
      cygwin = 1;

  DWORD num_subkeys, max_subkey_len, num_values;
  DWORD max_value_len, max_valdata_len, i;
  if (RegQueryInfoKey (hKey, 0, 0, 0, &num_subkeys, &max_subkey_len, 0,
		       &num_values, &max_value_len, &max_valdata_len, 0, 0)
      != ERROR_SUCCESS)
    {
#if 0
      char tmp[400];
      FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM, 0, GetLastError (),
		     MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), tmp, 400, 0);
      printf ("RegQueryInfoKey: %s\n", tmp);
#endif
      return;
    }

  if (cygwin)
    {
      show_reg (&ri, 0);

      char *value_name = (char *) malloc (max_value_len + 1);
      if (value_name == NULL)
	{
	  display_error ("scan_registry: malloc()");
	  return;
	}

      char *value_data = (char *) malloc (max_valdata_len + 1);
      if (value_data == NULL)
	{
	  display_error ("scan_registry: malloc()");
	  return;
	}

      for (i = 0; i < num_values; i++)
	{
	  DWORD dlen = max_valdata_len + 1;
	  DWORD nlen = max_value_len + 1;
	  DWORD type;
	  RegEnumValue (hKey, i, value_name, &nlen, 0,
			&type, (BYTE *) value_data, &dlen);
	  {
	    printf ("  %s = ", i ? value_name : "(default)");
	    switch (type)
	      {
	      case REG_DWORD:
		printf ("0x%08x\n", *(unsigned *) value_data);
		break;
	      case REG_EXPAND_SZ:
	      case REG_SZ:
		printf ("'%s'\n", value_data);
		break;
	      default:
		printf ("(unsupported type)\n");
		break;
	      }
	  }
	}
      free (value_name);
      free (value_data);
    }

  char *subkey_name = (char *) malloc (max_subkey_len + 1);
  for (i = 0; i < num_subkeys; i++)
    {
      if (RegEnumKey (hKey, i, subkey_name, max_subkey_len + 1) ==
	  ERROR_SUCCESS)
	{
	  HKEY sKey;
	  /* Don't recurse more than one level into the WOW64 subkey since
	     that would lead to an endless recursion. */
	  if (!strcasecmp (subkey_name, "Wow6432Node"))
	    {
	      if (wow64)
		continue;
	      wow64 = true;
	    }
	  if (RegOpenKeyEx (hKey, subkey_name, 0, KEY_READ, &sKey)
	      == ERROR_SUCCESS)
	    {
	      scan_registry (&ri, sKey, subkey_name, cygwin, wow64);
	      if (RegCloseKey (sKey) != ERROR_SUCCESS)
		display_error ("scan_registry: RegCloseKey()");
	    }
	}
    }
  free (subkey_name);
}

void
pretty_id ()
{
  char *groups[16384];

  char *id = cygpath ("/bin/id.exe", NULL);
  for (char *p = id; (p = strchr (p, '/')); p++)
    *p = '\\';

  if (access (id, X_OK))
    {
      fprintf (stderr, "'id' program not found\n");
      return;
    }

  char buf[16384];
  snprintf (buf, sizeof (buf), "\"%s\"", id);
  FILE *f = popen (buf, "rt");

  buf[0] = '\0';
  fgets (buf, sizeof (buf), f);
  pclose (f);
  char *uid = strtok (buf, ")");
  if (uid)
    uid += strlen ("uid=");
  else
    {
      fprintf (stderr, "garbled output from 'id' command - no uid= found\n");
      return;
    }
  char *gid = strtok (NULL, ")");
  if (gid)
    gid += strlen ("gid=") + 1;
  else
    {
      fprintf (stderr, "garbled output from 'id' command - no gid= found\n");
      return;
    }

  char **ng = groups - 1;
  size_t len_uid = strlen ("UID: )") + strlen (uid);
  size_t len_gid = strlen ("GID: )") + strlen (gid);
  *++ng = groups[0] = (char *) alloca (len_uid + 1);
  *++ng = groups[1] = (char *) alloca (len_gid + 1);
  sprintf (groups[0], "UID: %s)", uid);
  sprintf (groups[1], "GID: %s)", gid);
  size_t sz = max (len_uid, len_gid);
  while ((*++ng = strtok (NULL, ",")))
    {
      char *p = strchr (*ng, '\n');
      if (p)
	*p = '\0';
      if (ng == groups + 2)
	*ng += strlen (" groups=");
      size_t len = strlen (*ng);
      if (sz < len)
	sz = len;
    }
  ng--;

  printf ("\nOutput from %s\n", id);
  int n = 80 / (int) ++sz;
  int i = n > 2 ? n - 2 : 0;
  sz = -sz;
  for (char **g = groups; g <= ng; g++)
    if ((g != ng) && (++i < n))
      printf ("%*s", (int) sz, *g);
    else
      {
	puts (*g);
	i = 0;
      }
}

/* This dumps information about each installed cygwin service, if cygrunsrv
   is available.  */
void
dump_sysinfo_services ()
{
  char buf[1024];
  char buf2[1024];
  FILE *f;
  bool no_services = false;

  if (givehelp)
    printf ("\nChecking for any Cygwin services... %s\n\n",
		  verbose ? "" : "(use -v for more detail)");
  else
    fputc ('\n', stdout);

  /* find the location of cygrunsrv.exe */
  char *cygrunsrv = cygpath ("/bin/cygrunsrv.exe", NULL);
  for (char *p = cygrunsrv; (p = strchr (p, '/')); p++)
    *p = '\\';

  if (access (cygrunsrv, X_OK))
    {
      puts ("Can't find the cygrunsrv utility, skipping services check.\n");
      return;
    }

  /* check for a recent cygrunsrv */
  snprintf (buf, sizeof (buf), "\"%s\" --version", cygrunsrv);
  if ((f = popen (buf, "rt")) == NULL)
    {
      printf ("Failed to execute '%s', skipping services check.\n", buf);
      return;
    }
  int maj, min;
  int ret = fscanf (f, "cygrunsrv V%u.%u", &maj, &min);
  if (ferror (f) || feof (f) || ret == EOF || maj < 1 || min < 10)
    {
      puts ("The version of cygrunsrv installed is too old to dump service info.\n");
      return;
    }
  fclose (f);

  /* For verbose mode, just run cygrunsrv --list --verbose and copy output
     verbatim; otherwise run cygrunsrv --list and then cygrunsrv --query for
     each service.  */
  snprintf (buf, sizeof (buf), (verbose ? "\"%s\" --list --verbose" : "\"%s\" --list"),
	    cygrunsrv);
  if ((f = popen (buf, "rt")) == NULL)
    {
      printf ("Failed to execute '%s', skipping services check.\n", buf);
      return;
    }

  if (verbose)
    {
      /* copy output to stdout */
      size_t nchars = 0;
      while (!feof (f) && !ferror (f))
	  nchars += fwrite ((void *) buf, 1,
			    fread ((void *) buf, 1, sizeof (buf), f), stdout);

      /* cygrunsrv outputs nothing if there are no cygwin services found */
      if (nchars < 1)
	no_services = true;
      pclose (f);
    }
  else
    {
      /* read the output of --list, and then run --query for each service */
      size_t nchars = fread ((void *) buf, 1, sizeof (buf) - 1, f);
      buf[nchars] = 0;
      pclose (f);

      if (nchars > 0)
	for (char *srv = strtok (buf, "\n"); srv; srv = strtok (NULL, "\n"))
	  {
	    snprintf (buf2, sizeof (buf2), "\"%s\" --query %s", cygrunsrv, srv);
	    if ((f = popen (buf2, "rt")) == NULL)
	      {
		printf ("Failed to execute '%s', skipping services check.\n", buf2);
		return;
	      }

	    /* copy output to stdout */
	    while (!feof (f) && !ferror (f))
	      fwrite ((void *) buf2, 1,
		      fread ((void *) buf2, 1, sizeof (buf2), f), stdout);
	    pclose (f);
	  }
      else
	no_services = true;
    }

  /* inform the user if nothing found */
  if (no_services)
    puts ("No Cygwin services found.\n");
}

enum handle_reg_t
{
  PRINT_KEY,
  DELETE_KEY
};

void
handle_reg_installation (handle_reg_t what)
{
  HKEY key;

  if (what == PRINT_KEY)
    printf ("Cygwin installations found in the registry:\n");
  for (int i = 0; i < 2; ++i)
    if (RegOpenKeyEx (i ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE,
		      "SOFTWARE\\Cygwin\\Installations", 0,
		      what == DELETE_KEY ? KEY_READ | KEY_WRITE : KEY_READ,
		      &key)
	== ERROR_SUCCESS)
      {
	char name[32], data[PATH_MAX];
	DWORD nsize, dsize, type;
	LONG ret;

	for (DWORD index = 0;
	     (ret = RegEnumValue (key, index, name, (nsize = 32, &nsize), 0,
				  &type, (PBYTE) data,
				  (dsize = PATH_MAX, &dsize)))
	     != ERROR_NO_MORE_ITEMS; ++index)
	  if (ret == ERROR_SUCCESS && dsize > 5)
	    {
	      char *path = data + 4;
	      if (path[1] != ':')
		*(path += 2) = '\\';
	      if (what == PRINT_KEY)
		printf ("  %s Key: %s Path: %s", i ? "User:  " : "System:",
			name, path);
	      strcat (path, "\\bin\\cygwin1.dll");
	      if (what == PRINT_KEY)
		printf ("%s\n", access (path, F_OK) ? " (ORPHANED)" : "");
	      else if (access (path, F_OK))
		{
		  RegDeleteValue (key, name);
		  /* Start over since index is not reliable anymore. */
		  --i;
		  break;
		}
	    }
	RegCloseKey (key);
      }
  if (what == PRINT_KEY)
    printf ("\n");
}

void
print_reg_installations ()
{
  handle_reg_installation (PRINT_KEY);
}

void
del_orphaned_reg_installations ()
{
  handle_reg_installation (DELETE_KEY);
}

/* Unfortunately neither mingw nor Windows know this function. */
char *
memmem (char *haystack, size_t haystacklen,
	const char *needle, size_t needlelen)
{
  if (needlelen == 0)
    return haystack;
  while (needlelen <= haystacklen)
    {
      if (!memcmp (haystack, needle, needlelen))
	return haystack;
      haystack++;
      haystacklen--;
    }
  return NULL;
}

int
handle_unique_object_name (int opt, char *path)
{
  HANDLE fh, fm;
  void *haystack = NULL;

  if (!path || !*path)
    usage (stderr, 1);

  DWORD access, share, protect, mapping;

  if (opt == CO_SHOW_UON)
    {
      access = GENERIC_READ;
      share = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
      protect = PAGE_READONLY;
      mapping = FILE_MAP_READ;
    }
  else
    {
      access = GENERIC_READ | GENERIC_WRITE;
      share = 0;
      protect = PAGE_READWRITE;
      mapping = FILE_MAP_WRITE;
    }

  fh = CreateFile (path, access, share, NULL, OPEN_EXISTING,
		   FILE_FLAG_BACKUP_SEMANTICS, NULL);
  if (fh == INVALID_HANDLE_VALUE)
    {
      DWORD err = GetLastError ();
      switch (err)
	{
	case ERROR_SHARING_VIOLATION:
	  display_error ("%s still used by other Cygwin processes.\n"
			 "Please stop all of them and retry.", path);
	  break;
	case ERROR_ACCESS_DENIED:
	  display_error (
	    "Your permissions are not sufficient to change the file \"%s\"",
	    path);
	  break;
	case ERROR_FILE_NOT_FOUND:
	  display_error ("%s: No such file.", path);
	  break;
	default:
	  display_error (path, true, false);
	  break;
	}
      return 1;
    }
  if (!(fm = CreateFileMapping (fh, NULL, protect, 0, 0, NULL)))
    display_error ("CreateFileMapping");
  else if (!(haystack = MapViewOfFile (fm, mapping, 0, 0, 0)))
    display_error ("MapViewOfFile");
  else
    {
      size_t haystacklen = GetFileSize (fh, NULL);
      cygwin_props_t *cygwin_props = (cygwin_props_t *)
	       memmem ((char *) haystack, haystacklen,
		       CYGWIN_PROPS_MAGIC, sizeof (CYGWIN_PROPS_MAGIC));
      if (!cygwin_props)
	display_error ("Can't find Cygwin properties in %s", path);
      else
	{
	  if (opt != CO_SHOW_UON)
	    cygwin_props->disable_key = opt - CO_ENABLE_UON;
	  printf ("Unique object names are %s\n",
		  cygwin_props->disable_key ? "disabled" : "enabled");
	  UnmapViewOfFile (haystack);
	  CloseHandle (fm);
	  CloseHandle (fh);
	  return 0;
	}
    }
  if (haystack)
    UnmapViewOfFile (haystack);
  if (fm)
    CloseHandle (fm);
  CloseHandle (fh);
  return 1;
}

extern "C" NTSTATUS NTAPI RtlGetVersion (PRTL_OSVERSIONINFOEXW);

static void
dump_sysinfo ()
{
  int i, j;
  char tmp[4000];
  time_t now;
  char *found_cygwin_dll;
  bool is_nt = false;
  char osname[128];
  DWORD obcaseinsensitive = 1;
  HKEY key;

  /* MSVCRT popen (called by pretty_id and dump_sysinfo_services) SEGVs if
     COMSPEC isn't set correctly.  Simply enforce it here.  Using
     Get/SetEnvironmentVariable to set the dir does *not* help, btw.
     Apparently MSVCRT keeps its own copy of the environment and changing
     that requires to use _wputenv. */
  if (!_wgetenv (L"COMSPEC"))
    {
      WCHAR comspec[MAX_PATH + 17];
      wcscpy (comspec, L"COMSPEC=");
      GetSystemDirectoryW (comspec + 8, MAX_PATH);
      wcsncat (comspec, L"\\cmd.exe", sizeof comspec);
      _wputenv (comspec);
    }

  printf ("\nCygwin Configuration Diagnostics\n");
  time (&now);
  printf ("Current System Time: %s\n", ctime (&now));

  RTL_OSVERSIONINFOEXW osversion;
  osversion.dwOSVersionInfoSize = sizeof (RTL_OSVERSIONINFOEXW);
  RtlGetVersion (&osversion);

  switch (osversion.dwPlatformId)
    {
    case VER_PLATFORM_WIN32_NT:
      is_nt = true;
      if (osversion.dwMajorVersion == 6)
	{
	  HMODULE k32 = GetModuleHandleW (L"kernel32.dll");
	  BOOL (WINAPI *GetProductInfo) (DWORD, DWORD, DWORD, DWORD, PDWORD) =
		  (BOOL (WINAPI *)(DWORD, DWORD, DWORD, DWORD, PDWORD))
		  GetProcAddress (k32, "GetProductInfo");
	  switch (osversion.dwMinorVersion)
	    {
	    case 0:
	      strcpy (osname, osversion.wProductType == VER_NT_WORKSTATION
			      ? "Vista" : "2008");
	      break;
	    case 1:
	      strcpy (osname, osversion.wProductType == VER_NT_WORKSTATION
			      ? "7" : "2008 R2");
	      break;
	    case 2:
	      strcpy (osname, osversion.wProductType == VER_NT_WORKSTATION
			      ? "8" : "2012");
	      break;
	    case 3:
	      strcpy (osname, osversion.wProductType == VER_NT_WORKSTATION
			      ? "8.1" : "2012 R2");
	      break;
	    case 4:
	    default:
	      strcpy (osname, osversion.wProductType == VER_NT_WORKSTATION
			      ? "10" : "2014");
	      break;
	    }
	  DWORD prod;
	  if (GetProductInfo (osversion.dwMajorVersion,
			      osversion.dwMinorVersion,
			      osversion.wServicePackMajor,
			      osversion.wServicePackMinor,
			      &prod))
	    {
	      const char *products[] =
		{
 /* 0x00000000 */ "",
 /* 0x00000001 */ " Ultimate",
 /* 0x00000002 */ " Home Basic",
 /* 0x00000003 */ " Home Premium",
 /* 0x00000004 */ " Enterprise",
 /* 0x00000005 */ " Home Basic N",
 /* 0x00000006 */ " Business",
 /* 0x00000007 */ " Server Standard",
 /* 0x00000008 */ " Server Datacenter",
 /* 0x00000009 */ " Small Business Server",
 /* 0x0000000a */ " Server Enterprise",
 /* 0x0000000b */ " Starter",
 /* 0x0000000c */ " Server Datacenter Core",
 /* 0x0000000d */ " Server Standard Core",
 /* 0x0000000e */ " Server Enterprise Core",
 /* 0x0000000f */ " Server Enterprise for Itanium-based Systems",
 /* 0x00000010 */ " Business N",
 /* 0x00000011 */ " Web Server",
 /* 0x00000012 */ " HPC Edition",
 /* 0x00000013 */ " Home Server",
 /* 0x00000014 */ " Storage Server Express",
 /* 0x00000015 */ " Storage Server Standard",
 /* 0x00000016 */ " Storage Server Workgroup",
 /* 0x00000017 */ " Storage Server Enterprise",
 /* 0x00000018 */ " for Windows Essential Server Solutions",
 /* 0x00000019 */ " Small Business Server Premium",
 /* 0x0000001a */ " Home Premium N",
 /* 0x0000001b */ " Enterprise N",
 /* 0x0000001c */ " Ultimate N",
 /* 0x0000001d */ " Web Server Core",
 /* 0x0000001e */ " Essential Business Server Management Server",
 /* 0x0000001f */ " Essential Business Server Security Server",
 /* 0x00000020 */ " Essential Business Server Messaging Server",
 /* 0x00000021 */ " Server Foundation",
 /* 0x00000022 */ " Home Server 2011",
 /* 0x00000023 */ " without Hyper-V for Windows Essential Server Solutions",
 /* 0x00000024 */ " Server Standard without Hyper-V",
 /* 0x00000025 */ " Server Datacenter without Hyper-V",
 /* 0x00000026 */ " Server Enterprise without Hyper-V",
 /* 0x00000027 */ " Server Datacenter Core without Hyper-V",
 /* 0x00000028 */ " Server Standard Core without Hyper-V",
 /* 0x00000029 */ " Server Enterprise Core without Hyper-V",
 /* 0x0000002a */ " Hyper-V Server",
 /* 0x0000002b */ " Storage Server Express Core",
 /* 0x0000002c */ " Storage Server Standard Core",
 /* 0x0000002d */ " Storage Server Workgroup Core",
 /* 0x0000002e */ " Storage Server Enterprise Core",
 /* 0x0000002f */ " Starter N",
 /* 0x00000030 */ " Professional",
 /* 0x00000031 */ " Professional N",
 /* 0x00000032 */ " Small Business Server 2011 Essentials",
 /* 0x00000033 */ " Server For SB Solutions",
 /* 0x00000034 */ " Server Solutions Premium",
 /* 0x00000035 */ " Server Solutions Premium Core",
 /* 0x00000036 */ " Server For SB Solutions EM", /* per MSDN, 2012-09-01 */
 /* 0x00000037 */ " Server For SB Solutions EM", /* per MSDN, 2012-09-01 */
 /* 0x00000038 */ " Multipoint Server",
 /* 0x00000039 */ "",
 /* 0x0000003a */ "",
 /* 0x0000003b */ " Essential Server Solution Management",
 /* 0x0000003c */ " Essential Server Solution Additional",
 /* 0x0000003d */ " Essential Server Solution Management SVC",
 /* 0x0000003e */ " Essential Server Solution Additional SVC",
 /* 0x0000003f */ " Small Business Server Premium Core",
 /* 0x00000040 */ " Server Hyper Core V",
 /* 0x00000041 */ "",
 /* 0x00000042 */ " Starter E",
 /* 0x00000043 */ " Home Basic E",
 /* 0x00000044 */ " Home Premium E",
 /* 0x00000045 */ " Professional E",
 /* 0x00000046 */ " Enterprise E",
 /* 0x00000047 */ " Ultimate E",
 /* 0x00000048 */ " Server Enterprise (Evaluation inst.)",
 /* 0x00000049 */ "",
 /* 0x0000004a */ "",
 /* 0x0000004b */ "",
 /* 0x0000004c */ " MultiPoint Server Standard",
 /* 0x0000004d */ " MultiPoint Server Premium",
 /* 0x0000004e */ "",
 /* 0x0000004f */ " Server Standard (Evaluation inst.)",
 /* 0x00000050 */ " Server Datacenter (Evaluation inst.)",
 /* 0x00000051 */ "",
 /* 0x00000052 */ "",
 /* 0x00000053 */ "",
 /* 0x00000054 */ " Enterprise N (Evaluation inst.)",
 /* 0x00000055 */ "",
 /* 0x00000056 */ "",
 /* 0x00000057 */ "",
 /* 0x00000058 */ "",
 /* 0x00000059 */ "",
 /* 0x0000005a */ "",
 /* 0x0000005b */ "",
 /* 0x0000005c */ "",
 /* 0x0000005d */ "",
 /* 0x0000005e */ "",
 /* 0x0000005f */ " Storage Server Workgroup (Evaluation inst.)",
 /* 0x00000060 */ " Storage Server Standard (Evaluation inst.)",
 /* 0x00000061 */ "",
 /* 0x00000062 */ " N",			/* "8 N" */
 /* 0x00000063 */ " China",		/* "8 China" */
 /* 0x00000064 */ " Single Language",	/* "8 Single Language" */
 /* 0x00000065 */ "",			/* "8" */
 /* 0x00000066 */ "",
 /* 0x00000067 */ " Professional with Media Center"
		};
	      if (prod == PRODUCT_UNLICENSED)
		strcat (osname, "Unlicensed");
	      else if (prod > PRODUCT_PROFESSIONAL_WMC)
		strcat (osname, "");
	      else
		strcat (osname, products[prod]);
	    }
	  else
	    {
	    }
	}
      else if (osversion.dwMajorVersion == 5)
	{
	  /* cygcheck won't run on Windows 200 or earlier. */
	  if (osversion.dwMinorVersion == 1)
	    {
	      strcpy (osname, "XP");
	      if (GetSystemMetrics (SM_MEDIACENTER))
		strcat (osname, " Media Center Edition");
	      else if (GetSystemMetrics (SM_TABLETPC))
		strcat (osname, " Tablet PC Edition");
	      else if (GetSystemMetrics (SM_STARTER))
		strcat (osname, " Starter Edition");
	      else if (osversion.wSuiteMask & VER_SUITE_PERSONAL)
		strcat (osname, " Home Edition");
	      else
		strcat (osname, " Professional");
	    }
	  else if (osversion.dwMinorVersion == 2)
	    {
	      strcpy (osname, "2003 Server");
	      if (GetSystemMetrics (SM_SERVERR2))
		strcat (osname, " R2");
	      if (osversion.wSuiteMask & VER_SUITE_BLADE)
		strcat (osname, " Web Edition");
	      else if (osversion.wSuiteMask & VER_SUITE_DATACENTER)
		strcat (osname, " Datacenter Edition");
	      else if (osversion.wSuiteMask & VER_SUITE_ENTERPRISE)
		strcat (osname, " Enterprise Edition");
	      else if (osversion.wSuiteMask & VER_SUITE_COMPUTE_SERVER)
		strcat (osname, " Compute Cluster Edition");
	    }
	}
      else
	strcpy (osname, "NT");
      break;
    default:
      strcpy (osname, "??");
      break;
    }
  printf ("Windows %s Ver %lu.%lu Build %lu %ls\n", osname,
	  osversion.dwMajorVersion, osversion.dwMinorVersion,
	  osversion.dwPlatformId == VER_PLATFORM_WIN32_NT ?
	  osversion.dwBuildNumber : (osversion.dwBuildNumber & 0xffff),
	  osversion.dwPlatformId == VER_PLATFORM_WIN32_NT ?
	  osversion.szCSDVersion : L"");

  if (osversion.dwPlatformId == VER_PLATFORM_WIN32s
      || osversion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    exit (EXIT_FAILURE);

  BOOL is_wow64 = FALSE;
  if (IsWow64Process (GetCurrentProcess (), &is_wow64) && is_wow64)
    {
      SYSTEM_INFO natinfo;
      GetNativeSystemInfo (&natinfo);
      fputs ("\nRunning under WOW64 on ", stdout);
      switch (natinfo.wProcessorArchitecture)
	{
	  case PROCESSOR_ARCHITECTURE_IA64:
	    puts ("IA64");
	    break;
	  case PROCESSOR_ARCHITECTURE_AMD64:
	    puts ("AMD64");
	    break;
	  default:
	    puts("??");
	    break;
	}
    }

  if (GetSystemMetrics (SM_REMOTESESSION))
    printf ("\nRunning in Terminal Service session\n");

  printf ("\nPath:");
  char *s = getenv ("PATH"), *e;
  if (!s)
    puts ("");
  else
    {
      char sep = strchr (s, ';') ? ';' : ':';
      int count_path_items = 0;
      while (1)
	{
	  for (e = s; *e && *e != sep; e++);
	  if (e-s)
	    printf ("\t%.*s\n", (int) (e - s), s);
	  else
	    puts ("\t.");
	  count_path_items++;
	  if (!*e)
	    break;
	  s = e + 1;
	}
    }

  fflush (stdout);

  pretty_id ();

  if (!GetSystemDirectory (tmp, 4000))
    display_error ("dump_sysinfo: GetSystemDirectory()");
  printf ("\nSysDir: %s\n", tmp);

  GetWindowsDirectory (tmp, 4000);
  printf ("WinDir: %s\n\n", tmp);


  if (givehelp)
    printf ("Here's some environment variables that may affect cygwin:\n");
  for (i = 0; environ[i]; i++)
    {
      char *eq = strchr (environ[i], '=');
      if (!eq)
	continue;
      /* int len = eq - environ[i]; */
      for (j = 0; known_env_vars[j]; j++)
	{
	  *eq = 0;
	  if (strcmp (environ[i], "PATH") == 0)
	    continue;		/* we handle this one specially */
	  if (strcasecmp (environ[i], known_env_vars[j]) == 0)
	    printf ("%s = '%s'\n", environ[i], eq + 1);
	  *eq = '=';
	}
    }
  printf ("\n");

  if (verbose)
    {
      if (givehelp)
	printf ("Here's the rest of your environment variables:\n");
      for (i = 0; environ[i]; i++)
	{
	  int found = 0;
	  char *eq = strchr (environ[i], '=');
	  if (!eq)
	    continue;
	  /* int len = eq - environ[i]; */
	  for (j = 0; known_env_vars[j]; j++)
	    {
	      *eq = 0;
	      if (strcasecmp (environ[i], known_env_vars[j]) == 0)
		found = 1;
	      *eq = '=';
	    }
	  if (!found)
	    {
	      *eq = 0;
	      printf ("%s = '%s'\n", environ[i], eq + 1);
	      *eq = '=';
	    }
	}
      printf ("\n");
    }

  if (registry)
    {
      if (givehelp)
	printf ("Scanning registry for keys with 'Cygwin' in them...\n");
      scan_registry (0, HKEY_CURRENT_USER,
		     (char *) "HKEY_CURRENT_USER", 0, false);
      scan_registry (0, HKEY_LOCAL_MACHINE,
		     (char *) "HKEY_LOCAL_MACHINE", 0, false);
      printf ("\n");
    }
  else
    printf ("Use '-r' to scan registry\n\n");

  if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
		  "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\kernel",
		  0, KEY_READ, &key) == ERROR_SUCCESS)
    {
      DWORD size;
      RegQueryValueEx (key, "obcaseinsensitive", NULL, NULL,
		       (LPBYTE) &obcaseinsensitive, &size);
      RegCloseKey (key);
    }
  printf ("obcaseinsensitive set to %lu\n\n", obcaseinsensitive);

  print_reg_installations ();

  if (givehelp)
    {
      printf ("Listing available drives...\n");
      printf ("Drv Type          Size   Used Flags              Name\n");
    }
  int prev_mode =
    SetErrorMode (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);
  int drivemask = GetLogicalDrives ();

  for (i = 0; i < 26; i++)
    {
      if (!(drivemask & (1 << i)))
	continue;
      char drive[4], name[200], fsname[200];
      DWORD serno = 0, maxnamelen = 0, flags = 0;
      name[0] = fsname[0] = 0;
      sprintf (drive, "%c:\\", i + 'a');
      /* Report all errors, except if the Volume is ERROR_NOT_READY.
	 ERROR_NOT_READY is returned when removeable media drives are empty
	 (CD, floppy, etc.) */
      if (!GetVolumeInformation (drive, name, sizeof (name), &serno,
				 &maxnamelen, &flags, fsname,
				 sizeof (fsname))
	  && GetLastError () != ERROR_NOT_READY)
	{
#	  define FMT "dump_sysinfo: GetVolumeInformation() for drive %c:"
	  char buf[sizeof (FMT)];
	  sprintf (buf, FMT, 'A' + i);
	  display_error (buf);
#	  undef FMT
	}

      int dtype = GetDriveType (drive);
      char drive_type[4] = "unk";
      switch (dtype)
	{
	case DRIVE_REMOVABLE:
	  strcpy (drive_type, "fd ");
	  break;
	case DRIVE_FIXED:
	  strcpy (drive_type, "hd ");
	  break;
	case DRIVE_REMOTE:
	  strcpy (drive_type, "net");
	  break;
	case DRIVE_CDROM:
	  strcpy (drive_type, "cd ");
	  break;
	case DRIVE_RAMDISK:
	  strcpy (drive_type, "ram");
	  break;
	default:
	  strcpy (drive_type, "unk");
	}

      long capacity_mb = -1;
      int percent_full = -1;

      ULARGE_INTEGER free_me, free_bytes, total_bytes;
      free_me.QuadPart = free_bytes.QuadPart = 0ULL;
      total_bytes.QuadPart = 1ULL;
      if (GetDiskFreeSpaceEx (drive, &free_me, &total_bytes, &free_bytes))
	{
	  capacity_mb = total_bytes.QuadPart / (1024L * 1024L);
	  percent_full = 100 - (int) ((100.0 * free_me.QuadPart)
				      / total_bytes.QuadPart);
	}
      else
	{
	  DWORD spc = 0, bps = 0, fc = 0, tc = 1;
	  if (GetDiskFreeSpace (drive, &spc, &bps, &fc, &tc))
	    {
	      capacity_mb = (spc * bps * tc) / (1024 * 1024);
	      percent_full = 100 - (int) ((100.0 * fc) / tc);
	    }
	}

      printf ("%.2s  %s %-6s ", drive, drive_type, fsname);
      if (capacity_mb >= 0)
	printf ("%7dMb %3d%% ", (int) capacity_mb, (int) percent_full);
      else
	printf ("    N/A    N/A ");
      printf ("%s %s %s %s %s %s  %s\n",
	      flags & FS_CASE_IS_PRESERVED ? "CP" : "  ",
	      flags & FS_CASE_SENSITIVE ? "CS" : "  ",
	      flags & FS_UNICODE_STORED_ON_DISK ? "UN" : "  ",
	      flags & FS_PERSISTENT_ACLS ? "PA" : "  ",
	      flags & FS_FILE_COMPRESSION ? "FC" : "  ",
	      flags & FS_VOL_IS_COMPRESSED ? "VC" : "  ",
#if 0
	      flags & FILE_SUPPORTS_ENCRYPTION ? "EN" : "  ",
	      flags & FILE_SUPPORTS_OBJECT_IDS ? "OI" : "  ",
	      flags & FILE_SUPPORTS_REPARSE_POINTS ? "RP" : "  ",
	      flags & FILE_SUPPORTS_SPARSE_FILES ? "SP" : "  ",
	      flags & FILE_VOLUME_QUOTAS ? "QU" : "  ",
#endif
	      name);
    }

  SetErrorMode (prev_mode);
  if (givehelp)
    {
      puts ("\n"
	  "fd = floppy,          hd = hard drive,       cd = CD-ROM\n"
	  "net= Network Share,   ram= RAM drive,        unk= Unknown\n"
	  "CP = Case Preserving, CS = Case Sensitive,   UN = Unicode\n"
	  "PA = Persistent ACLS, FC = File Compression, VC = Volume Compression");
    }
  printf ("\n");

  unsigned ml_fsname = 4, ml_dir = 7, ml_type = 6;
  bool ml_trailing = false;

  struct mntent *mnt;
  setmntent (0, 0);
  while ((mnt = getmntent (0)))
    {
      unsigned n = (int) strlen (mnt->mnt_fsname);
      ml_trailing |= (n > 1 && strchr ("\\/", mnt->mnt_fsname[n - 1]));
      if (ml_fsname < n)
	ml_fsname = n;
      n = (int) strlen (mnt->mnt_dir);
      ml_trailing |= (n > 1 && strchr ("\\/", mnt->mnt_dir[n - 1]));
      if (ml_dir < n)
	ml_dir = n;
    }

  if (ml_trailing)
    puts ("Warning: Mount entries should not have a trailing (back)slash\n");

  if (givehelp)
    {
      printf
	("Mount entries: these map POSIX directories to your NT drives.\n");
      printf ("%-*s  %-*s  %-*s  %s\n", ml_fsname, "-NT-", ml_dir, "-POSIX-",
	      ml_type, "-Type-", "-Flags-");
    }

  setmntent (0, 0);
  while ((mnt = getmntent (0)))
    {
      printf ("%-*s  %-*s  %-*s  %s\n",
	      ml_fsname, mnt->mnt_fsname,
	      ml_dir, mnt->mnt_dir, ml_type, mnt->mnt_type, mnt->mnt_opts);
    }
  printf ("\n");

  if (givehelp)
    printf
      ("Looking to see where common programs can be found, if at all...\n");
  for (i = 0; common_apps[i].name; i++)
    if (!find_app_on_path ((char *) common_apps[i].name, 1))
      {
	if (common_apps[i].missing_is_good)
	  printf ("Not Found: %s (good!)\n", common_apps[i].name);
	else
	  printf ("Not Found: %s\n", common_apps[i].name);
      }
  printf ("\n");

  if (givehelp)
    printf ("Looking for various Cygwin DLLs...  (-v gives version info)\n");
  int cygwin_dll_count = 0;
  char cygdll_path[32768];
  for (pathlike *pth = paths; pth->dir; pth++)
    {
      WIN32_FIND_DATAW ffinfo;
      sprintf (tmp, "%s*.*", pth->dir);
      wide_path wpath (tmp);
      HANDLE ff = FindFirstFileW (wpath, &ffinfo);
      int found = (ff != INVALID_HANDLE_VALUE);
      found_cygwin_dll = NULL;
      while (found)
	{
	  char f[FILENAME_MAX + 1];
	  wcstombs (f, ffinfo.cFileName, sizeof f);
	  if (strcasecmp (f + strlen (f) - 4, ".dll") == 0)
	    {
	      if (strncasecmp (f, "cyg", 3) == 0)
		{
		  sprintf (tmp, "%s%s", pth->dir, f);
		  if (strcasecmp (f, "cygwin1.dll") == 0)
		    {
		      if (!cygwin_dll_count)
			strcpy (cygdll_path, pth->dir);
		      if (!cygwin_dll_count
			  || strcasecmp (cygdll_path, pth->dir) != 0)
			cygwin_dll_count++;
		      found_cygwin_dll = strdup (tmp);
		    }
		  else
		    ls (tmp);
		}
	    }
	  found = FindNextFileW (ff, &ffinfo);
	}
      if (found_cygwin_dll)
	{
	  ls (found_cygwin_dll);
	  free (found_cygwin_dll);
	}

      FindClose (ff);
    }
  if (cygwin_dll_count > 1)
    puts ("Warning: There are multiple cygwin1.dlls on your path");
  if (!cygwin_dll_count)
    puts ("Warning: cygwin1.dll not found on your path");

  dump_dodgy_apps (verbose);

  if (is_nt)
    dump_sysinfo_services ();
}

static int
check_keys ()
{
  HANDLE h = CreateFileW (L"CONIN$", GENERIC_READ | GENERIC_WRITE,
			  FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
			  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

  if (h == INVALID_HANDLE_VALUE || h == NULL)
    return (display_error ("check_keys: Opening CONIN$"));

  DWORD mode;

  if (!GetConsoleMode (h, &mode))
    display_error ("check_keys: GetConsoleMode()");
  else
    {
      mode &= ~ENABLE_PROCESSED_INPUT;
      if (!SetConsoleMode (h, mode))
	display_error ("check_keys: SetConsoleMode()");
    }

  fputs ("\nThis key check works only in a console window,", stderr);
  fputs (" _NOT_ in a terminal session!\n", stderr);
  fputs ("Abort with Ctrl+C if in a terminal session.\n\n", stderr);
  fputs ("Press 'q' to exit.\n", stderr);

  INPUT_RECORD in, prev_in;

  // Drop first <RETURN> key
  ReadConsoleInputW (h, &in, 1, &mode);

  memset (&in, 0, sizeof in);

  do
    {
      prev_in = in;
      if (!ReadConsoleInputW (h, &in, 1, &mode))
	display_error ("check_keys: ReadConsoleInput()");

      if (!memcmp (&in, &prev_in, sizeof in))
	continue;

      switch (in.EventType)
	{
	case KEY_EVENT:
	  printf ("%s %ux VK: 0x%04x VS: 0x%04x C: 0x%04x CTRL: ",
		  in.Event.KeyEvent.bKeyDown ? "Pressed " : "Released",
		  in.Event.KeyEvent.wRepeatCount,
		  in.Event.KeyEvent.wVirtualKeyCode,
		  in.Event.KeyEvent.wVirtualScanCode,
		  (unsigned char) in.Event.KeyEvent.uChar.UnicodeChar);
	  fputs (in.Event.KeyEvent.dwControlKeyState & CAPSLOCK_ON ?
		 "CL " : "-- ", stdout);
	  fputs (in.Event.KeyEvent.dwControlKeyState & ENHANCED_KEY ?
		 "EK " : "-- ", stdout);
	  fputs (in.Event.KeyEvent.dwControlKeyState & LEFT_ALT_PRESSED ?
		 "LA " : "-- ", stdout);
	  fputs (in.Event.KeyEvent.dwControlKeyState & LEFT_CTRL_PRESSED ?
		 "LC " : "-- ", stdout);
	  fputs (in.Event.KeyEvent.dwControlKeyState & NUMLOCK_ON ?
		 "NL " : "-- ", stdout);
	  fputs (in.Event.KeyEvent.dwControlKeyState & RIGHT_ALT_PRESSED ?
		 "RA " : "-- ", stdout);
	  fputs (in.Event.KeyEvent.dwControlKeyState & RIGHT_CTRL_PRESSED ?
		 "RC " : "-- ", stdout);
	  fputs (in.Event.KeyEvent.dwControlKeyState & SCROLLLOCK_ON ?
		 "SL " : "-- ", stdout);
	  fputs (in.Event.KeyEvent.dwControlKeyState & SHIFT_PRESSED ?
		 "SH " : "-- ", stdout);
	  fputc ('\n', stdout);
	  break;

	default:
	  break;
	}
    }
  while (in.EventType != KEY_EVENT ||
	 in.Event.KeyEvent.bKeyDown != FALSE ||
	 in.Event.KeyEvent.uChar.UnicodeChar != L'q');

  CloseHandle (h);
  return 0;
}

/* RFC1738 says that these do not need to be escaped.  */
static const char safe_chars[] = "$-_.+!*'(),";

/* the URL to query.  */
static const char base_url[] =
	"http://cygwin.com/cgi-bin2/package-grep.cgi?text=1&grep=";

/* Queries Cygwin web site for packages containing files matching a regexp.
   Return value is 1 if there was a problem, otherwise 0.  */
static int
package_grep (char *search)
{
  char buf[1024];

  /* construct the actual URL by escaping  */
  char *url = (char *) alloca (sizeof (base_url) + strlen ("&arch=x86_64") + strlen (search) * 3);
  strcpy (url, base_url);

  char *dest;
  for (dest = &url[sizeof (base_url) - 1]; *search; search++)
    {
      if (isalnum (*search)
	  || memchr (safe_chars, *search, sizeof (safe_chars) - 1))
	{
	  *dest++ = *search;
	}
      else
	{
	  *dest++ = '%';
	  sprintf (dest, "%02x", (unsigned char) *search);
	  dest += 2;
	}
    }
#ifdef __x86_64__
  strcpy (dest, "&arch=x86_64");
#else
  strcpy (dest, "&arch=x86");
#endif

  /* Connect to the net and open the URL.  */
  if (InternetAttemptConnect (0) != ERROR_SUCCESS)
    {
      fputs ("An internet connection is required for this function.\n", stderr);
      return 1;
    }

  /* Initialize WinInet and attempt to fetch our URL.  */
  HINTERNET hi = NULL, hurl = NULL;
  if (!(hi = InternetOpenA ("cygcheck", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0)))
    return display_internet_error ("InternetOpen() failed", NULL);

  if (!(hurl = InternetOpenUrlA (hi, url, NULL, 0, 0, 0)))
    return display_internet_error ("unable to contact cygwin.com site, "
				   "InternetOpenUrl() failed", hi, NULL);

  /* Check the HTTP response code.  */
  DWORD rc = 0, rc_s = sizeof (DWORD);
  if (!HttpQueryInfoA (hurl, HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
		      (void *) &rc, &rc_s, NULL))
    return display_internet_error ("HttpQueryInfo() failed", hurl, hi, NULL);

  if (rc != HTTP_STATUS_OK)
    {
      sprintf (buf, "error retrieving results from cygwin.com site, "
		    "HTTP status code %lu", rc);
      return display_internet_error (buf, hurl, hi, NULL);
    }

  /* Fetch result and print to stdout.  */
  DWORD numread;
  do
    {
      if (!InternetReadFile (hurl, (void *) buf, sizeof (buf), &numread))
	return display_internet_error ("InternetReadFile failed", hurl, hi, NULL);
      if (numread)
	fwrite ((void *) buf, (size_t) numread, 1, stdout);
    }
  while (numread);

  InternetCloseHandle (hurl);
  InternetCloseHandle (hi);
  return 0;
}

static void
usage (FILE * stream, int status)
{
  fprintf (stream, "\
Usage: cygcheck [-v] [-h] PROGRAM\n\
       cygcheck -c [-d] [PACKAGE]\n\
       cygcheck -s [-r] [-v] [-h]\n\
       cygcheck -k\n\
       cygcheck -f FILE [FILE]...\n\
       cygcheck -l [PACKAGE]...\n\
       cygcheck -p REGEXP\n\
       cygcheck --delete-orphaned-installation-keys\n\
       cygcheck --enable-unique-object-names Cygwin-DLL\n\
       cygcheck --disable-unique-object-names Cygwin-DLL\n\
       cygcheck --show-unique-object-names Cygwin-DLL\n\
       cygcheck -h\n\n\
List system information, check installed packages, or query package database.\n\
\n\
At least one command option or a PROGRAM is required, as shown above.\n\
\n\
  PROGRAM              list library (DLL) dependencies of PROGRAM\n\
  -c, --check-setup    show installed version of PACKAGE and verify integrity\n\
		       (or for all installed packages if none specified)\n\
  -d, --dump-only      just list packages, do not verify (with -c)\n\
  -s, --sysinfo        produce diagnostic system information (implies -c)\n\
  -r, --registry       also scan registry for Cygwin settings (with -s)\n\
  -k, --keycheck       perform a keyboard check session (must be run from a\n\
		       plain console only, not from a pty/rxvt/xterm)\n\
  -f, --find-package   find the package to which FILE belongs\n\
  -l, --list-package   list contents of PACKAGE (or all packages if none given)\n\
  -p, --package-query  search for REGEXP in the entire cygwin.com package\n\
		       repository (requires internet connectivity)\n\
  --delete-orphaned-installation-keys\n\
		       Delete installation keys of old, now unused\n\
		       installations from the registry.  Requires the right\n\
		       to change the registry.\n\
  --enable-unique-object-names Cygwin-DLL\n\
  --disable-unique-object-names Cygwin-DLL\n\
  --show-unique-object-names Cygwin-DLL\n\
		       Enable, disable, or show the setting of the\n\
		       \"unique object names\" setting in the Cygwin DLL\n\
		       given as argument to this option.  The DLL path must\n\
		       be given as valid Windows(!) path.\n\
		       See the users guide for more information.\n\
		       If you don't know what this means, don't change it.\n\
  -v, --verbose        produce more verbose output\n\
  -h, --help           annotate output with explanatory comments when given\n\
		       with another command, otherwise print this help\n\
  -V, --version        print the version of cygcheck and exit\n\
\n\
Note: -c, -f, and -l only report on packages that are currently installed. To\n\
  search all official Cygwin packages use -p instead.  The -p REGEXP matches\n\
  package names, descriptions, and names of files/paths within all packages.\n\
\n");
  exit (status);
}

struct option longopts[] = {
  {"check-setup", no_argument, NULL, 'c'},
  {"dump-only", no_argument, NULL, 'd'},
  {"sysinfo", no_argument, NULL, 's'},
  {"registry", no_argument, NULL, 'r'},
  {"verbose", no_argument, NULL, 'v'},
  {"keycheck", no_argument, NULL, 'k'},
  {"find-package", no_argument, NULL, 'f'},
  {"list-package", no_argument, NULL, 'l'},
  {"package-query", no_argument, NULL, 'p'},
  {"delete-orphaned-installation-keys", no_argument, NULL, CO_DELETE_KEYS},
  {"enable-unique-object-names", no_argument, NULL, CO_ENABLE_UON},
  {"disable-unique-object-names", no_argument, NULL, CO_DISABLE_UON},
  {"show-unique-object-names", no_argument, NULL, CO_SHOW_UON},
  {"help", no_argument, NULL, 'h'},
  {"version", no_argument, 0, 'V'},
  {0, no_argument, NULL, 0}
};

static char opts[] = "cdsrvkflphV";

static void
print_version ()
{
  printf ("cygcheck (cygwin) %d.%d.%d\n"
	  "System Checker for Cygwin\n"
	  "Copyright (C) 1998 - %s Red Hat, Inc.\n"
	  "This is free software; see the source for copying conditions.  There is NO\n"
	  "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n",
	  CYGWIN_VERSION_DLL_MAJOR / 1000,
	  CYGWIN_VERSION_DLL_MAJOR % 1000,
	  CYGWIN_VERSION_DLL_MINOR,
	  strrchr (__DATE__, ' ') + 1);
}

void
nuke (char *ev)
{
  int n = 1 + strchr (ev, '=') - ev;
  char *s = (char *) malloc (n + 1);
  memcpy (s, ev, n);
  s[n] = '\0';
  putenv (s);
}

extern "C" {
uintptr_t (*cygwin_internal) (int, ...);
WCHAR cygwin_dll_path[32768];
};

static void
load_cygwin (int& argc, char **&argv)
{
  HMODULE h;

  if (!(h = LoadLibrary ("cygwin1.dll")))
    return;
  GetModuleFileNameW (h, cygwin_dll_path, 32768);
  if ((cygwin_internal = (uintptr_t (*) (int, ...))
  			 GetProcAddress (h, "cygwin_internal")))
    {
      char **av = (char **) cygwin_internal (CW_ARGV);
      if (av && ((uintptr_t) av != (uintptr_t) -1))
	{
	  /* Copy cygwin's idea of the argument list into this Window application. */
	  for (argc = 0; av[argc]; argc++)
	    continue;
	  argv = (char **) calloc (argc + 1, sizeof (char *));
	  for (char **argvp = argv; *av; av++)
	    *argvp++ = strdup (*av);
	}


      char **envp = (char **) cygwin_internal (CW_ENVP);
      if (envp && ((uintptr_t) envp != (uintptr_t) -1))
	{
	  /* Store path and revert to this value, otherwise path gets overwritten
	     by the POSIXy Cygwin variation, which breaks cygcheck.
	     Another approach would be to use the Cygwin PATH and convert it to
	     Win32 again. */
	  char *path = NULL;
	  char **env;
	  while (*(env = _environ))
	    {
	      if (strncmp (*env, "PATH=", 5) == 0)
		path = strdup (*env);
	      nuke (*env);
	    }
	  for (char **ev = envp; *ev; ev++)
	    if (strncmp (*ev, "PATH=", 5) != 0)
	      putenv (strdup (*ev));
	  if (path)
	    putenv (path);
	}
    }
  FreeLibrary (h);
}

int
main (int argc, char **argv)
{
  int i;
  bool ok = true;
  load_cygwin (argc, argv);

  /* Need POSIX sorting while parsing args, but don't forget the
     user's original environment.  */
  char *posixly = getenv ("POSIXLY_CORRECT");
  if (posixly == NULL)
    (void) putenv ("POSIXLY_CORRECT=1");
  while ((i = getopt_long (argc, argv, opts, longopts, NULL)) != EOF)
    switch (i)
      {
      case 's':
	sysinfo = 1;
	break;
      case 'c':
	check_setup = 1;
	break;
      case 'd':
	dump_only = 1;
	break;
      case 'r':
	registry = 1;
	break;
      case 'v':
	verbose = 1;
	break;
      case 'k':
	keycheck = 1;
	break;
      case 'f':
	find_package = 1;
	break;
      case 'l':
	list_package = 1;
	break;
      case 'p':
	grep_packages = 1;
	break;
      case 'h':
	givehelp = 1;
	break;
      case CO_DELETE_KEYS:
	del_orphaned_reg = 1;
	break;
      case CO_ENABLE_UON:
      case CO_DISABLE_UON:
      case CO_SHOW_UON:
	unique_object_name_opt = i;
	break;
      case 'V':
	print_version ();
	exit (0);
      default:
	fprintf (stderr, "Try `cygcheck --help' for more information.\n");
	exit (1);
       /*NOTREACHED*/
    }
  argc -= optind;
  argv += optind;
  if (posixly == NULL)
    putenv ("POSIXLY_CORRECT=");

  if ((argc == 0) && !sysinfo && !keycheck && !check_setup && !list_package
      && !del_orphaned_reg)
    {
      if (givehelp)
	usage (stdout, 0);
      else
	usage (stderr, 1);
    }

  if ((check_setup || sysinfo || find_package || list_package || grep_packages
       || del_orphaned_reg || unique_object_name_opt)
      && keycheck)
    usage (stderr, 1);

  if ((find_package || list_package || grep_packages)
      && (check_setup || del_orphaned_reg))
    usage (stderr, 1);

  if ((check_setup || sysinfo || find_package || list_package || grep_packages
       || del_orphaned_reg)
      && unique_object_name_opt)
    usage (stderr, 1);

  if (dump_only && !check_setup && !sysinfo)
    usage (stderr, 1);

  if (find_package + list_package + grep_packages > 1)
    usage (stderr, 1);

  if (keycheck)
    return check_keys ();
  if (unique_object_name_opt)
    return handle_unique_object_name (unique_object_name_opt, *argv);
  if (del_orphaned_reg)
    del_orphaned_reg_installations ();
  if (grep_packages)
    return package_grep (*argv);

  init_paths ();

  /* FIXME: Add help for check_setup and {list,find}_package */
  if (argc >= 1 && givehelp && !check_setup && !find_package && !list_package)
    {
      printf("Here is where the OS will find your program%s, and which dlls\n",
	     argc > 1 ? "s" : "");
      printf ("will be used for it.  Use -v to see DLL version info\n");

      if (!sysinfo)
	printf ("\n");
    }

  if (check_setup)
    dump_setup (verbose, argv, !dump_only);
  else if (find_package)
    package_find (verbose, argv);
  else if (list_package)
    package_list (verbose, argv);
  else
    for (i = 0; i < argc; i++)
      {
	if (i)
	  puts ("");
       ok &= cygcheck (argv[i]);
      }

  if (sysinfo)
    {
      dump_sysinfo ();
      if (!check_setup)
	{
	  puts ("");
	  dump_setup (verbose, NULL, !dump_only);
	}

      if (!givehelp)
	puts ("Use -h to see help about each section");
    }

  return ok ? EXIT_SUCCESS : EXIT_FAILURE;
}
@


1.146
log
@	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d1483 4
a1487 1
	      osversion.dwMinorVersion = 3;
d1489 1
a1489 1
			      ? "8.1" : "2012 R2");
@


1.145
log
@	* cygcheck.cc (RtlGetVersion): Declare.
	(dump_sysinfo): Call RtlGetVersion rather than GetVersionEx to get
	correct OS info even on Windows 8.1.  Don't check return value since
	RtlGetVersion never fails per MSDN.  Move fetching kernel32 module
	handle where it's really needed.  Drop temporary comment added by
	previous checkin.
@
text
@d4 1
a4 1
   2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
a589 3
/* Special case.  Don't complain about this one.  */
#define CYGLSA64_DLL "\\cyglsa64.dll"

d1436 14
@


1.145.2.1
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d4 1
a4 1
   2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d590 3
a1438 14
  /* MSVCRT popen (called by pretty_id and dump_sysinfo_services) SEGVs if
     COMSPEC isn't set correctly.  Simply enforce it here.  Using
     Get/SetEnvironmentVariable to set the dir does *not* help, btw.
     Apparently MSVCRT keeps its own copy of the environment and changing
     that requires to use _wputenv. */
  if (!_wgetenv (L"COMSPEC"))
    {
      WCHAR comspec[MAX_PATH + 17];
      wcscpy (comspec, L"COMSPEC=");
      GetSystemDirectoryW (comspec + 8, MAX_PATH);
      wcsncat (comspec, L"\\cmd.exe", sizeof comspec);
      _wputenv (comspec);
    }

@


1.144
log
@	* cygcheck.cc (dump_sysinfo): Revert Windows 8.1 hack.  It's not
	working.  Add a (hopefully temporary) comment.
@
text
@d1425 2
d1443 3
a1445 6
  OSVERSIONINFOEX osversion;
  osversion.dwOSVersionInfoSize = sizeof (OSVERSIONINFOEX);
  if (!GetVersionEx (reinterpret_cast<LPOSVERSIONINFO>(&osversion)))
    display_error ("dump_sysinfo: GetVersionEx()");

  HMODULE k32 = GetModuleHandleW (L"kernel32.dll");
d1453 1
d1471 1
a1471 1
	    case 3:	/* Unreached due to mainfest nonsense. */
d1642 1
a1642 1
  printf ("Windows %s Ver %lu.%lu Build %lu %s\n", osname,
d1647 1
a1647 1
	  osversion.szCSDVersion : "");
@


1.143
log
@	* cygcheck.cc (dump_sysinfo): Drop code trying to fetch OSVERSIONINFO
	if fetching OSVERSIONINFOEX failed.  Drop code handling unsupported
	platform IDs.  Add code to tweak dwMinorVersion on Windows 8.1 if no
	manifest is present.
@
text
@d1468 4
a1471 11
	      /* No way to distinguish W8 and W8.1 by OS version numbers
		 alone, unless the executables have a matching manifest.
		 What a big, fat mess. */
	      if (osversion.dwBuildNumber < 9200)
		{
		  strcpy (osname, osversion.wProductType == VER_NT_WORKSTATION
				  ? "8" : "2012");
		  break;
		}
	      /*FALLTHRU*/
	    case 3:
@


1.142
log
@	* Makefile.in (cygcheck.exe): Link against wininet.dll.
	(dumper.exe): Link against psapi.dll.
	* cygcheck.cc (_WIN32_WINNT): Define as 0x0602.
	(pInternetCloseHandle): Drop pointer.
	(PRODUCT_UNLICENSED): Drop definition.
	(PRODUCT_PROFESSIONAL_WMC): Ditto.
	(package_grep): Delete code loading wininet functions dynamically, just
	call functions directly.
@
text
@a1432 1
  bool more_info = true;
d1444 1
a1444 6
    {
      more_info = false;
      osversion.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
      if (!GetVersionEx (reinterpret_cast<LPOSVERSIONINFO>(&osversion)))
	display_error ("dump_sysinfo: GetVersionEx()");
    }
a1449 6
    case VER_PLATFORM_WIN32s:
      strcpy (osname, "32s (not supported)");
      break;
    case VER_PLATFORM_WIN32_WINDOWS:
      strcpy (osname, "95/98/Me (not supported)");
      break;
d1468 11
d1480 3
a1482 8
	      /* No way to distinguish W8 and W8.1 by OS version numbers
		 alone. */
	      if (osversion.dwBuildNumber >= 9200)
		strcpy (osname, osversion.wProductType == VER_NT_WORKSTATION
				? "8.1" : "2012 R2");
	      else
		strcpy (osname, osversion.wProductType == VER_NT_WORKSTATION
				? "8" : "2012");
@


1.141
log
@	* cygcheck.cc (dump_sysinfo): Distinguish Windows 8 and 8.1, as well
	as Windows Server 2012 and 2012 R2.  Add missing commas in products
	array to avoid crashes.  Drop Windows NT4 and 2000 printouts.  Just
	call IsWow64Process, GetNativeSystemInfo, and GetDiskFreeSpaceEx
	directly, rather than loading them dynamically, since they are exported
	by all supported OS versions.  Fix questionable type usage in call to
	GetDiskFreeSpaceEx.
@
text
@d12 1
a56 4
/* This is global because it's used in both internet_display_error as well
   as package_grep.  */
BOOL (WINAPI *pInternetCloseHandle) (HINTERNET);

d230 1
a230 1
    pInternetCloseHandle (h);
a1497 4
#define       PRODUCT_UNLICENSED 0xabcdabcd
#ifndef PRODUCT_PROFESSIONAL_WMC
#define       PRODUCT_PROFESSIONAL_WMC 0x00000067
#endif
a2109 37
  /* Attempt to dynamically load the necessary WinInet API functions so that
     cygcheck can still function on older systems without IE.  */
  HMODULE hWinInet;
  if (!(hWinInet = LoadLibrary ("wininet.dll")))
    {
      fputs ("Unable to locate WININET.DLL.  This feature requires Microsoft "
	     "Internet Explorer v3 or later to function.\n", stderr);
      return 1;
    }

  /* InternetCloseHandle is used outside this function so it is declared
     global.  The rest of these functions are only used here, so declare them
     and call GetProcAddress for each of them with the following macro.  */

  pInternetCloseHandle = (BOOL (WINAPI *) (HINTERNET))
			    GetProcAddress (hWinInet, "InternetCloseHandle");
#define make_func_pointer(name, ret, args) ret (WINAPI * p##name) args = \
	    (ret (WINAPI *) args) GetProcAddress (hWinInet, #name);
  make_func_pointer (InternetAttemptConnect, DWORD, (DWORD));
  make_func_pointer (InternetOpenA, HINTERNET, (LPCSTR, DWORD, LPCSTR, LPCSTR,
						DWORD));
  make_func_pointer (InternetOpenUrlA, HINTERNET, (HINTERNET, LPCSTR, LPCSTR,
						   DWORD, DWORD, DWORD));
  make_func_pointer (InternetReadFile, BOOL, (HINTERNET, PVOID, DWORD, PDWORD));
  make_func_pointer (HttpQueryInfoA, BOOL, (HINTERNET, DWORD, PVOID, PDWORD,
					    PDWORD));
#undef make_func_pointer

  if(!pInternetCloseHandle || !pInternetAttemptConnect || !pInternetOpenA
     || !pInternetOpenUrlA || !pInternetReadFile || !pHttpQueryInfoA)
    {
      fputs ("Unable to load one or more functions from WININET.DLL.  This "
	     "feature requires Microsoft Internet Explorer v3 or later to "
	     "function.\n", stderr);
      return 1;
    }

d2136 1
a2136 1
  if (pInternetAttemptConnect (0) != ERROR_SUCCESS)
d2144 1
a2144 1
  if (!(hi = pInternetOpenA ("cygcheck", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0)))
d2147 1
a2147 1
  if (!(hurl = pInternetOpenUrlA (hi, url, NULL, 0, 0, 0)))
d2153 1
a2153 1
  if (!pHttpQueryInfoA (hurl, HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
d2168 1
a2168 1
      if (!pInternetReadFile (hurl, (void *) buf, sizeof (buf), &numread))
d2175 2
a2176 2
  pInternetCloseHandle (hurl);
  pInternetCloseHandle (hi);
@


1.140
log
@* cygcheck.cc (package_grep): Accommodate arch-specific package layout.
@
text
@d1482 1
d1484 8
a1491 2
	      strcpy (osname, osversion.wProductType == VER_NT_WORKSTATION
			      ? "8" : "2012");
d1538 1
a1538 1
 /* 0x0000001f */ " Essential Business Server Security Server"
d1557 1
a1557 1
 /* 0x00000032 */ " Small Business Server 2011 Essentials"
d1578 1
a1578 1
 /* 0x00000047 */ " Ultimate E"
d1625 2
a1626 13
	  if (osversion.dwMinorVersion == 0)
	    {
	      strcpy (osname, "2000");
	      if (osversion.wProductType == VER_NT_WORKSTATION)
		strcat (osname, " Professional");
	      else if (osversion.wSuiteMask & VER_SUITE_DATACENTER)
		strcat (osname, " Datacenter Server");
	      else if (osversion.wSuiteMask & VER_SUITE_ENTERPRISE)
		strcat (osname, " Advanced Server");
	      else
		strcat (osname, " Server");
	    }
	  else if (osversion.dwMinorVersion == 1)
a1654 15
      else if (osversion.dwMajorVersion == 4)
	{
	  strcpy (osname, "NT 4");
	  if (more_info)
	    {
	      if (osversion.wProductType == VER_NT_WORKSTATION)
		strcat (osname, " Workstation");
	      else
		{
		  strcat (osname, " Server");
		  if (osversion.wSuiteMask & VER_SUITE_ENTERPRISE)
		    strcat (osname, " Enterprise Edition");
		}
	    }
	}
a1672 2
  BOOL (WINAPI *wow64_func) (HANDLE, PBOOL) = (BOOL (WINAPI *) (HANDLE, PBOOL))
    GetProcAddress (k32, "IsWow64Process");
d1674 1
a1674 1
  if (wow64_func && wow64_func (GetCurrentProcess (), &is_wow64) && is_wow64)
a1675 2
      void (WINAPI *nativinfo) (LPSYSTEM_INFO) = (void (WINAPI *)
	(LPSYSTEM_INFO)) GetProcAddress (k32, "GetNativeSystemInfo");
d1677 1
a1677 1
      nativinfo (&natinfo);
a1812 4
  BOOL (WINAPI * gdfse) (LPCSTR, long long *, long long *, long long *) =
    (BOOL (WINAPI *) (LPCSTR, long long *, long long *, long long *))
    GetProcAddress (k32, "GetDiskFreeSpaceExA");

d1862 4
a1865 2
      long long free_me = 0ULL, free_bytes = 0ULL, total_bytes = 1ULL;
      if (gdfse != NULL && gdfse (drive, &free_me, &total_bytes, &free_bytes))
d1867 3
a1869 2
	  capacity_mb = total_bytes / (1024L * 1024L);
	  percent_full = 100 - (int) ((100.0 * free_me) / total_bytes);
@


1.139
log
@* cygcheck.cc (dll_info): Detect and report on symlinks.  Output wrong
architecture message inline with stdout for clarity.
* path.cc (is_symlink): Always reset file pointer to beginning on exit.
(readlink): Assume that file pointer is set to the beginning.
@
text
@d2179 1
a2179 1
  char *url = (char *) alloca (sizeof (base_url) + strlen (search) * 3);
d2197 5
a2201 1
  *dest = 0;
@


1.138
log
@	* Merge in cygwin-64bit-branch.
@
text
@d593 3
d601 12
d622 1
a622 3
      fputc ('\n', stderr);
      display_error ("Wrong architecture. Only x86_64 executables supported.",
		     false, false);
d629 1
a629 3
      fputc ('\n', stderr);
      display_error ("Wrong architecture. Only ix86 executables supported.",
		     false, false);
@


1.137
log
@Update copyrights
@
text
@d4 1
a4 1
   2009, 2010, 2011, 2012 Red Hat, Inc.
d27 1
d601 22
d645 1
a645 1
  int num_entries = get_dword (fh, opthdr_ofs + 92);
d648 1
a648 1
  int export_rva = get_dword (fh, opthdr_ofs + 96);
d651 1
a651 1
  int export_size = get_dword (fh, opthdr_ofs + 100);
d654 1
a654 1
  int import_rva = get_dword (fh, opthdr_ofs + 104);
d657 1
a657 1
  int import_size = get_dword (fh, opthdr_ofs + 108);
d693 3
a695 2
	  struct tm *tm = localtime ((const time_t *) &(ed->timestamp));
	  if (tm->tm_year < 60)
d697 1
a697 1
	  if (tm->tm_year < 200)
d700 1
a700 1
	  printf ("\"%s\" v%d.%d ts=", exp + ofs,
d702 5
a706 3
	  printf ("%d/%d/%d %d:%02d\n",
		  tm->tm_year, tm->tm_mon + 1, tm->tm_mday,
		  tm->tm_hour, tm->tm_min);
d1144 1
a1144 1
      printf ("%*s", sz, *g);
d1720 1
a1720 1
	    printf ("\t%.*s\n", e - s, s);
d2336 1
a2336 1
unsigned long (*cygwin_internal) (int, ...);
d2348 2
a2349 1
  if ((cygwin_internal = (DWORD (*) (int, ...)) GetProcAddress (h, "cygwin_internal")))
d2352 1
a2352 1
      if (av && ((DWORD) av != (DWORD) -1))
d2364 1
a2364 1
      if (envp && ((DWORD) envp != (DWORD) -1))
@


1.136
log
@	* configure.in: Add check for MINGW_CXX.  Remove libiconv check.
	* configure: Regenerate.
	* Makefile.in: Remove references to mingw and w32api directories.
	Use MINGW_CXX instead of mingw script to build MINGW_BINS.
	Check for libiconv with $CC --print-file-name.
	* cygcheck.cc: Use relative include paths for Cygwin headers.
	* path.cc: Ditto.
	* strace.cc: Ditto
	* mingw: Remove.
@
text
@d3 2
a4 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.135
log
@	* cygcheck.cc (dump_sysinfo): Convert "if/else if" chain to a switch
	statement.  Drop "not yet supported" and "Server" from Windows 2012
	output string.
@
text
@d25 4
a28 5
#include "cygwin/include/cygwin/version.h"
#include "cygwin/include/sys/cygwin.h"
#include "cygwin/include/mntent.h"
#include "cygwin/cygprops.h"
#include "cygwin/version.h"
@


1.134
log
@	* cygcheck.cc (dump_sysinfo): Drop "not yet supported" text from
	Windows 8.  Update products array.
@
text
@d1436 15
a1450 9
	  if (osversion.dwMinorVersion == 0)
	    strcpy (osname, osversion.wProductType == VER_NT_WORKSTATION
			    ? "Vista" : "2008");
	  else if (osversion.dwMinorVersion == 1)
	    strcpy (osname, osversion.wProductType == VER_NT_WORKSTATION
			    ? "7" : "2008 R2");
	  else if (osversion.dwMinorVersion == 2)
	    strcpy (osname, osversion.wProductType == VER_NT_WORKSTATION
			    ? "8" : "Server 2012 (not yet supported!)");
@


1.133
log
@	* Makefile.in (cygcheck.exe): Link against psapi.dll.
	* bloda.cc: Change include section to work with Mingw64 headers.
	Include psapi.h.  Use SystemProcessInformation instead of
	SystemProcessesAndThreadsInformation throughout and add define for
	w32api headers.  Ditto for PSYSTEM_PROCESS_INFORMATION vs.
	PSYSTEM_PROCESSES.
	(system_module_list): New type to replace SYSTEM_MODULE_INFORMATION.
	Change usage throughout accordingly.
	(get_module_list): Fetch module list using PSAPI functions
	EnumDeviceDrivers and GetDeviceDriverBaseNameA.
	* cygcheck.cc (max): Define as __max if not defined already.
	(alloca): Only define if not defined already.
	(handle_unique_object_name): Use explicit sharing flags rather than
	FILE_SHARE_VALID_FLAGS which officially is only available in DDK
	headers.
	(PRODUCT_ULTIMATE_E): Only define if not defined already.
	* dump_setup.cc: Change include section to work with Mingw64 headers.
	(NtQueryAttributesFile): Drop NTOSAPI aka DECLSPEC_IMPORT.
	* strace.cc: Change include section to work with Mingw64 headers.
	(alloca): Only define if not defined already.
@
text
@d1443 2
a1444 5
	    {
	      strcpy (osname, osversion.wProductType == VER_NT_WORKSTATION
			      ? "8" : "Server 2012");
	      strcat (osname, " (not yet supported!)");
	    }
d1453 2
a1454 2
#ifndef PRODUCT_ULTIMATE_E
#define       PRODUCT_ULTIMATE_E 0x00000047
d1483 1
a1483 1
 /* 0x00000019 */ "",
d1501 4
a1504 4
 /* 0x0000002b */ "",
 /* 0x0000002c */ "",
 /* 0x0000002d */ "",
 /* 0x0000002e */ "",
d1508 6
a1513 6
 /* 0x00000032 */ " Home Server 2011",
 /* 0x00000033 */ "",
 /* 0x00000034 */ "",
 /* 0x00000035 */ "",
 /* 0x00000036 */ "",
 /* 0x00000037 */ "",
d1517 6
a1522 6
 /* 0x0000003b */ "",
 /* 0x0000003c */ "",
 /* 0x0000003d */ "",
 /* 0x0000003e */ "",
 /* 0x0000003f */ "",
 /* 0x00000040 */ "",
d1530 32
d1565 1
a1565 1
	      else if (prod > PRODUCT_ULTIMATE_E)
@


1.133.2.1
log
@	* cygcheck.cc: Change include path to not depend on installed
	cygwin/version.h.
	(_NOMNTENT_MACROS): Define before including mntent.h.
	* path.cc (_NOMNTENT_MACROS): Ditto.
	* dump_setup.cc: Add temporary workaround to handle older Mingw header
	files on Fedora 17.
	* strace.cc: Ditto.
@
text
@a26 1
#define _NOMNTENT_MACROS
d29 1
a29 1
#include "cygwin/include/cygwin/version.h"
@


1.133.2.2
log
@Pull in changes from HEAD
@
text
@d1437 7
a1443 1
	  switch (osversion.dwMinorVersion)
a1444 9
	    case 0:
	      strcpy (osname, osversion.wProductType == VER_NT_WORKSTATION
			      ? "Vista" : "2008");
	      break;
	    case 1:
	      strcpy (osname, osversion.wProductType == VER_NT_WORKSTATION
			      ? "7" : "2008 R2");
	      break;
	    default:
d1446 2
a1447 2
			      ? "8" : "2012");
	      break;
d1457 2
a1458 2
#ifndef PRODUCT_PROFESSIONAL_WMC
#define       PRODUCT_PROFESSIONAL_WMC 0x00000067
d1487 1
a1487 1
 /* 0x00000019 */ " Small Business Server Premium",
d1505 4
a1508 4
 /* 0x0000002b */ " Storage Server Express Core",
 /* 0x0000002c */ " Storage Server Standard Core",
 /* 0x0000002d */ " Storage Server Workgroup Core",
 /* 0x0000002e */ " Storage Server Enterprise Core",
d1512 6
a1517 6
 /* 0x00000032 */ " Small Business Server 2011 Essentials"
 /* 0x00000033 */ " Server For SB Solutions",
 /* 0x00000034 */ " Server Solutions Premium",
 /* 0x00000035 */ " Server Solutions Premium Core",
 /* 0x00000036 */ " Server For SB Solutions EM", /* per MSDN, 2012-09-01 */
 /* 0x00000037 */ " Server For SB Solutions EM", /* per MSDN, 2012-09-01 */
d1521 6
a1526 6
 /* 0x0000003b */ " Essential Server Solution Management",
 /* 0x0000003c */ " Essential Server Solution Additional",
 /* 0x0000003d */ " Essential Server Solution Management SVC",
 /* 0x0000003e */ " Essential Server Solution Additional SVC",
 /* 0x0000003f */ " Small Business Server Premium Core",
 /* 0x00000040 */ " Server Hyper Core V",
a1533 32
 /* 0x00000048 */ " Server Enterprise (Evaluation inst.)",
 /* 0x00000049 */ "",
 /* 0x0000004a */ "",
 /* 0x0000004b */ "",
 /* 0x0000004c */ " MultiPoint Server Standard",
 /* 0x0000004d */ " MultiPoint Server Premium",
 /* 0x0000004e */ "",
 /* 0x0000004f */ " Server Standard (Evaluation inst.)",
 /* 0x00000050 */ " Server Datacenter (Evaluation inst.)",
 /* 0x00000051 */ "",
 /* 0x00000052 */ "",
 /* 0x00000053 */ "",
 /* 0x00000054 */ " Enterprise N (Evaluation inst.)",
 /* 0x00000055 */ "",
 /* 0x00000056 */ "",
 /* 0x00000057 */ "",
 /* 0x00000058 */ "",
 /* 0x00000059 */ "",
 /* 0x0000005a */ "",
 /* 0x0000005b */ "",
 /* 0x0000005c */ "",
 /* 0x0000005d */ "",
 /* 0x0000005e */ "",
 /* 0x0000005f */ " Storage Server Workgroup (Evaluation inst.)",
 /* 0x00000060 */ " Storage Server Standard (Evaluation inst.)",
 /* 0x00000061 */ "",
 /* 0x00000062 */ " N",			/* "8 N" */
 /* 0x00000063 */ " China",		/* "8 China" */
 /* 0x00000064 */ " Single Language",	/* "8 Single Language" */
 /* 0x00000065 */ "",			/* "8" */
 /* 0x00000066 */ "",
 /* 0x00000067 */ " Professional with Media Center"
d1537 1
a1537 1
	      else if (prod > PRODUCT_PROFESSIONAL_WMC)
@


1.133.2.3
log
@Pull in changes from HEAD
@
text
@d25 2
a26 2
#include "../cygwin/include/cygwin/version.h"
#include "../cygwin/include/sys/cygwin.h"
d28 3
a30 2
#include "../cygwin/include/mntent.h"
#include "../cygwin/cygprops.h"
@


1.133.2.4
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
   2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.133.2.5
log
@	Throughout, fix type problems on 32 and 64 bit.  Except:
	* ssp.c: Disable entire functionality on x86_64 for now.
@
text
@d4 1
a4 1
   2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d2311 1
a2311 1
uintptr_t (*cygwin_internal) (int, ...);
d2323 1
a2323 2
  if ((cygwin_internal = (uintptr_t (*) (int, ...))
  			 GetProcAddress (h, "cygwin_internal")))
d2326 1
a2326 1
      if (av && ((uintptr_t) av != (uintptr_t) -1))
d2338 1
a2338 1
      if (envp && ((uintptr_t) envp != (uintptr_t) -1))
@


1.133.2.6
log
@	* ldd.cc: Drop including inttypes.h.  Use %u rather than PRIu32.
	* mount.cc: Fix type problem with %* expression.
	* cygcheck.cc: Ditto.
@
text
@d1119 1
a1119 1
      printf ("%*s", (int) sz, *g);
d1695 1
a1695 1
	    printf ("\t%.*s\n", (int) (e - s), s);
@


1.133.2.7
log
@	* cygcheck.cc (dll_info): Handle x86_64 binaries.  Make sure to print
	only architecture matching cygcheck build, otherwise suffer path
	evaluation problems.
@
text
@a600 22
  WORD arch = get_word (fh, pe_header_offset + 4);
  if (GetLastError () != NO_ERROR)
    display_error ("get_word");
#ifdef __x86_64__
  if (arch != IMAGE_FILE_MACHINE_AMD64)
    {
      fputc ('\n', stderr);
      display_error ("Wrong architecture. Only x86_64 executables supported.",
		     false, false);
      return;
    }
  int base_off = 108;
#else
  if (arch != IMAGE_FILE_MACHINE_I386)
    {
      fputc ('\n', stderr);
      display_error ("Wrong architecture. Only ix86 executables supported.",
		     false, false);
      return;
    }
  int base_off = 92;
#endif
d623 1
a623 1
  int num_entries = get_dword (fh, opthdr_ofs + base_off + 0);
d626 1
a626 1
  int export_rva = get_dword (fh, opthdr_ofs + base_off + 4);
d629 1
a629 1
  int export_size = get_dword (fh, opthdr_ofs + base_off + 8);
d632 1
a632 1
  int import_rva = get_dword (fh, opthdr_ofs + base_off + 12);
d635 1
a635 1
  int import_size = get_dword (fh, opthdr_ofs + base_off + 16);
@


1.133.2.8
log
@	* cygcheck.cc (dll_info): Fix crash due to sizeof(time_t) being not
	equal to sizeof(int).  Output timestamp RFC 3339 compatible.
@
text
@d693 2
a694 3
	  time_t ts = ed->timestamp;	/* timestamp is only 4 bytes! */
	  struct tm *tm = localtime (&ts);
	  if (tm && tm->tm_year < 60)
d696 1
a696 1
	  if (tm && tm->tm_year < 200)
d699 1
a699 1
	  printf ("\"%s\" v%d.%d", exp + ofs,
d701 3
a703 5
	  if (tm)
	    printf (" ts=%04d-%02d-%02d %02d:%02d",
		    tm->tm_year, tm->tm_mon + 1, tm->tm_mday,
		    tm->tm_hour, tm->tm_min);
	  putchar ('\n');
@


1.132
log
@	* cygcheck.cc (dump_sysinfo): Change "Server 8" to official
	"Server 2012".
@
text
@d33 5
d39 1
d1323 1
a1323 1
      share = FILE_SHARE_VALID_FLAGS;
d1456 1
d1458 1
@


1.131
log
@Clean up whitespace.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
d1439 1
a1439 1
			      ? "8" : "Server 8");
@


1.130
log
@	* cygcheck.cc (dump_sysinfo): Add Windows 8 recognition.  Note as
	unsupported.  Update products array.
@
text
@d872 1
a872 1
      
d887 1
a887 1
         malloc()d string.  */
d1253 1
a1253 1
	      	*(path += 2) = '\\';
d1289 1
a1289 1
        const char *needle, size_t needlelen)
d1296 1
a1296 1
        return haystack;
d1302 1
a1302 1
 
d1361 1
a1361 1
      cygwin_props_t *cygwin_props = (cygwin_props_t *) 
d1452 1
a1452 1
	        {
d1527 1
a1527 1
	        strcat (osname, "Unlicensed");
d1529 1
a1529 1
	        strcat (osname, "");
d1531 1
a1531 1
	        strcat (osname, products[prod]);
d1543 1
a1543 1
	        strcat (osname, " Professional");
d1569 1
a1569 1
	        strcat (osname, " R2");
d1577 1
a1577 1
	        strcat (osname, " Compute Cluster Edition");
d1581 1
a1581 1
        {
d1586 1
a1586 1
	        strcat (osname, " Workstation");
d1588 1
a1588 1
	      	{
d1736 2
a1737 2
                  "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\kernel",
                  0, KEY_READ, &key) == ERROR_SUCCESS)
d1741 1
a1741 1
                       (LPBYTE) &obcaseinsensitive, &size);
d1933 1
a1933 1
		        strcpy (cygdll_path, pth->dir);
d2187 1
a2187 1
                       (or for all installed packages if none specified)\n\
d2192 1
a2192 1
                       plain console only, not from a pty/rxvt/xterm)\n\
d2196 1
a2196 1
                       repository (requires internet connectivity)\n\
d2198 3
a2200 3
                       Delete installation keys of old, now unused\n\
                       installations from the registry.  Requires the right\n\
                       to change the registry.\n\
d2204 6
a2209 6
                       Enable, disable, or show the setting of the\n\
                       \"unique object names\" setting in the Cygwin DLL\n\
                       given as argument to this option.  The DLL path must\n\
                       be given as valid Windows(!) path.\n\
                       See the users guide for more information.\n\
                       If you don't know what this means, don't change it.\n\
d2212 1
a2212 1
                       with another command, otherwise print this help\n\
d2365 1
a2365 1
      	del_orphaned_reg = 1;
d2370 1
a2370 1
      	unique_object_name_opt = i;
@


1.129
log
@	* Align usage output, version output, as well as usage and version
	option handling to use the same style throughout all Cygwin utils.
	Throughout use program_invocation_short_name to refer to current
	process name in Cygwin executables.
	* utils.sgml: Align documentation to above change.  Add missing
	sections for getconf, ldd, and setmetamode.
	* strace.cc (proc_child): Avoid compiler warning.
@
text
@d1436 6
d1469 1
a1469 1
 /* 0x00000000 */ " Business N",
d1487 1
a1487 1
 /* 0x00000022 */ "",
d1503 1
a1503 1
 /* 0x00000032 */ "",
d1509 1
a1509 1
 /* 0x00000038 */ "",
@


1.128
log
@	* cygcheck.cc (check_keys): Use UNICODE Win32 functions.
@
text
@d25 1
d29 1
a68 2
static const char version[] = "$Revision: 1.127 $";

d2240 9
a2248 18
  const char *v = strchr (version, ':');
  int len;
  if (!v)
    {
      v = "?";
      len = 1;
    }
  else
    {
      v += 2;
      len = strchr (v, ' ') - v;
    }
  printf ("\
cygcheck version %.*s\n\
System Checker for Cygwin\n\
Copyright (C) 1998 - 2008 Red Hat, Inc.\n\
Compiled on %s\n\
", len, v, __DATE__);
d2370 4
a2373 2
	usage (stderr, 1);
       /*NOTREACHED*/}
@


1.127
log
@	* cygcheck.cc (handle_unique_object_name): Avoid a compiler warning.
	(dump_sysinfo): Ditto.
	* loadlib.h (_load_sys_library): Mark as used, to avoid a compiler
	warning.
	* path.cc (oopt): Gurad with !FSTAB_ONLY to avoid a compiler warning.
	(read_flags): Ditto.
@
text
@d67 1
a67 1
static const char version[] = "$Revision: 1.126 $";
d1961 1
a1961 1
  HANDLE h = CreateFileA ("CONIN$", GENERIC_READ | GENERIC_WRITE,
d1987 1
a1987 1
  ReadConsoleInput (h, &in, 1, &mode);
d1994 1
a1994 1
      if (!ReadConsoleInput (h, &in, 1, &mode))
d2003 1
a2003 1
	  printf ("%s %ux VK: 0x%02x VS: 0x%02x A: 0x%02x CTRL: ",
d2008 1
a2008 1
		  (unsigned char) in.Event.KeyEvent.uChar.AsciiChar);
d2036 1
a2036 1
	 in.Event.KeyEvent.uChar.AsciiChar != 'q');
@


1.126
log
@	* cygcheck.cc: Fix copyright dates.
@
text
@d67 1
a67 1
static const char version[] = "$Revision: 1.125 $";
d1307 1
a1307 1
  void *haystack;
d1761 1
a1761 1
      name[0] = name[0] = fsname[0] = 0;
@


1.125
log
@	* cygcheck.cc (main): don't imply -d from -s option to cygcheck
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010 Red Hat, Inc.
d67 1
a67 1
static const char version[] = "$Revision: 1.124 $";
@


1.124
log
@	* loadlib.h: New header implementing safe LoadLibrary calls.
	Include throughout files using LoadLibrary function.
	* cygcheck.cc (dump_sysinfo): Retrieve kernel32.dll handle via
	GetModuleHandle, rather than using LoadLibrary.
	* cygpath.cc (get_long_name): Ditto.
	(do_sysfolders): Append .dll suffix in LoadLibrary call.
	* ldh.cc (WinMain): Use LoadLibraryExW with DONT_RESOLVE_DLL_REFERENCES
	to avoid loading malicious library code.
	* locale.cc (print_locale_with_codeset): Change way to retrieve
	kernel32.dll path.
@
text
@d67 1
a67 1
static const char version[] = "$Revision: 1.123 $";
d2183 1
a2183 1
  -s, --sysinfo        produce diagnostic system information (implies -c -d)\n\
d2409 1
a2409 1
  if (dump_only && !check_setup)
d2457 1
a2457 1
	  dump_setup (verbose, NULL, false);
@


1.123
log
@	* cygcheck.cc (dump_sysinfo): Fix typo in products.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009 Red Hat, Inc.
d29 1
d67 1
a67 1
static const char version[] = "$Revision: 1.122 $";
d1413 1
a1413 1
  HMODULE k32 = LoadLibrary ("kernel32.dll");
a1841 2
  if (!FreeLibrary (k32))
    display_error ("dump_sysinfo: FreeLibrary()");
@


1.122
log
@	* cygcheck.cc (cygwin_dll_path): New global variable.
	(load_cygwin): Fetch cygwin DLL path and store in cygwin_dll_path.
	* strace.cc: Full ditto.
	* path.cc (read_mounts): First use the path stored in cygwin_dll_path,
	if available.  Then fall back to fetching own path.  Add comment.
	Drop printing warnings since they look funny in strace output.
@
text
@d66 1
a66 1
static const char version[] = "$Revision: 1.121 $";
d1495 1
a1495 1
 /* 0x00000031 */ " Proffesional N",
@


1.121
log
@	* cygcheck.cc: Include cygprops.h.
	(del_orphaned_reg): New option variable.
	(unique_object_name_opt): Ditto.
	(handle_reg_installation): New function.
	(print_reg_installations): Ditto.
	(del_orphaned_reg_installations): Ditto.
	(memmem): Ditto.
	(handle_unique_object_name): Ditto.
	(dump_sysinfo): Call print_reg_installations from here.
	(usage): Add usage for new options --delete-orphaned-installation-keys,
	--enable-unique-object-names, --disable-unique-object-names, and
	--show-unique-object-names.
	(longopts): Add new options --delete-orphaned-installation-keys,
	--enable-unique-object-names, --disable-unique-object-names, and
	--show-unique-object-names.
	(main): Handle new options.
	* utils.sgml (cygcheck): Change documentaion accordingly.
@
text
@d66 1
a66 1
static const char version[] = "$Revision: 1.120 $";
d2273 1
d2283 1
@


1.120
log
@	* cygcheck.cc (pretty_id): Drop arguments.  Don't change CYGWIN
	environment variable.
	(dump_sysinfo): Don't tweak CYGWIN environment variable, just call
	pretty_id once.
@
text
@d27 1
d42 2
d63 2
d66 1
a66 2

static const char version[] = "$Revision: 1.119 $";
d127 9
d1219 166
d1739 2
d2171 4
d2192 13
d2227 4
d2332 1
a2332 1
    (void) putenv("POSIXLY_CORRECT=1");
d2366 8
d2385 2
a2386 1
  if ((argc == 0) && !sysinfo && !keycheck && !check_setup && !list_package)
d2394 2
a2395 1
  if ((check_setup || sysinfo || find_package || list_package || grep_packages)
d2399 7
a2405 1
  if ((find_package || list_package || grep_packages) && check_setup)
d2416 4
@


1.119
log
@	* cygcheck.cc (dump_sysinfo): Update with latest NT 6.1 versions.
@
text
@d62 1
a62 1
static const char version[] = "$Revision: 1.118 $";
d1034 1
a1034 1
pretty_id (const char *s, char *cygwin, size_t cyglen)
a1037 4
  strcpy (cygwin + cyglen++, " ");
  strcpy (cygwin + cyglen, s);
  putenv (cygwin);

d1093 1
a1093 1
  printf ("\nOutput from %s (%s)\n", id, s);
d1478 1
a1478 11
  char *cygwin = getenv ("CYGWIN");
  if (cygwin)
    cygwin -= strlen ("CYGWIN=");
  else
    cygwin = const_cast <char *> ("CYGWIN=");
  size_t cyglen = strlen (cygwin);
  cygwin = strcpy ((char *) malloc (cyglen + sizeof (" nontsec")), cygwin);
  pretty_id ("nontsec", cygwin, cyglen);
  pretty_id ("ntsec", cygwin, cyglen);
  cygwin[cyglen] = 0;
  putenv (cygwin);
@


1.118
log
@	* cygcheck.cc (dump_sysinfo): Add missing "Server Foundation" to
	products array.
@
text
@d62 1
a62 1
static const char version[] = "$Revision: 1.117 $";
d1268 1
a1268 1
#define       PRODUCT_HYPERV 0x2a
d1271 72
a1342 43
		  "",
		  " Ultimate",
		  " Home Basic",
		  " Home Premium",
		  " Enterprise",
		  " Home Basic N",
		  " Business",
		  " Server Standard",
		  " Server Datacenter",
		  " Small Business Server",
		  " Server Enterprise",
		  " Starter",
		  " Server Datacenter Core",
		  " Server Standard Core",
		  " Server Enterprise Core",
		  " Server Enterprise for Itanium-based Systems",
		  " Business N",
		  " Web Server",
		  " HPC Edition",
		  " Home Server",
		  " Storage Server Express",
		  " Storage Server Standard",
		  " Storage Server Workgroup",
		  " Storage Server Enterprise",
		  " for Windows Essential Server Solutions",
		  " Small Business Server Premium",
		  " Home Premium N",
		  " Enterprise N",
		  " Ultimate N",
		  " Web Server Core",
		  " Essential Business Server Management Server",
		  " Essential Business Server Security Server"
		  " Essential Business Server Messaging Server",
		  " Server Foundation",
		  "",
		  " without Hyper-V for Windows Essential Server Solutions",
		  " Server Standard without Hyper-V",
		  " Server Datacenter without Hyper-V",
		  " Server Enterprise without Hyper-V",
		  " Server Datacenter Core without Hyper-V",
		  " Server Standard Core without Hyper-V",
		  " Server Enterprise Core without Hyper-V",
		  " Hyper-V Server"
d1346 1
a1346 1
	      else if (prod > PRODUCT_HYPERV)
@


1.117
log
@	* cygcheck.cc (dump_sysinfo): Remove "not yet supported" text.
@
text
@d62 1
a62 1
static const char version[] = "$Revision: 1.116 $";
d1304 1
a1304 1
		  "",
@


1.116
log
@* cygcheck.cc (find_app_on_path): Avoid using NULL pointer if find_on_path
doesn't find the app on the path.
@
text
@d62 1
a62 1
static const char version[] = "$Revision: 1.115 $";
d1258 2
a1259 5
	    {
	      strcpy (osname, osversion.wProductType == VER_NT_WORKSTATION
			      ? "7" : "2008 R2");
	      strcat (osname, " (Not yet supported!)");
	    }
@


1.115
log
@	* cygcheck.cc (usage): Fix option order and print.
@
text
@d62 1
a62 1
static const char version[] = "$Revision: 1.114 $";
d843 3
@


1.114
log
@	* utils.sgml: Various syntactical and semantical fixes.
	* cygcheck.cc (usage): Fix --find-package explanation.
@
text
@d62 1
a62 1
static const char version[] = "$Revision: 1.113 $";
d1968 3
a1970 3
Usage: cygcheck PROGRAM [ -v ] [ -h ]\n\
       cygcheck -c [ PACKAGE ] [ -d ]\n\
       cygcheck -s [ -r ] [ -v ] [ -h ]\n\
d1972 2
a1973 2
       cygcheck -f FILE [ FILE ... ]\n\
       cygcheck -l [ PACKAGE ] [ PACKAGE ... ]\n\
d1975 1
@


1.113
log
@	* cygcheck.cc (dump_sysinfo): Fix compiler warning in printf.
	* strace.cc (proc_child): Ditto.
	* ldd.cc: Remove now useless undef wcscasecmp.
@
text
@d62 1
a62 1
static const char version[] = "$Revision: 1.112 $";
d1987 1
a1987 1
  -f, --find-package   find the package that FILE belongs to\n\
@


1.112
log
@	* wide_path.h (class wide_path): New class to convert Windows path
	to WCHAR win32 path, including long path conversion if necessary.
	* cygcheck.cc: Use class wide_path throughout to call Win32 functions
	taking potentially long filenames.
	(display_error): Use snprintf rather than sprintf.
	(display_error_fmt): Ditto.
	(dump_sysinfo): Use FindFirstFileW/FindNextFileW.
	* cygpath.cc: Use class wide_path throughout to call Win32 functions
	taking potentially long filenames.
	(get_device_name): Raise buffer size to take long pathnames.
	(get_short_paths): Convert to using GetShortPathNameW.
	(get_short_name): Ditto.
	(get_long_path_name_w32impl): Convert to equivalent of GetLongPathNameW.
	(get_long_name): Convert to using GetLongPathNameW.
	(do_sysfolders): Raise buffer size for POSIX pathname to PATH_MAX.
	(do_pathconv): In case of POSIX->Win32 conversion, convert to wchar_t
	Win32 path name and drop long pathname prefix if possible.
	(main): Call setlocale to accommodate wide char/multibyte conversions.
@
text
@d62 1
a62 1
static const char version[] = "$Revision: 1.111 $";
d1543 1
a1543 1
  printf ("obcaseinsensitive set to %d\n\n", obcaseinsensitive);
@


1.111
log
@* cygcheck.cc (usage): Fix typo.
@
text
@d23 1
d62 1
a62 1
static const char version[] = "$Revision: 1.110 $";
d171 1
a171 1
  sprintf (buf, fmt, x);
d182 1
a182 1
  vsprintf (buf, fmt, va);
d310 2
a311 1
  if (GetFileAttributes (file) != (DWORD) - 1)
d759 1
d761 2
a762 2
    CreateFile (path, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
d794 4
a797 2
  HANDLE h = CreateFile (f, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
			 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
d820 1
a820 1
  static char buf[MAX_PATH];
d825 2
a826 2
  strncpy (buf, s, MAX_PATH);
  buf[MAX_PATH - 1] = '\0';   // in case strlen(s) > MAX_PATH
d843 1
d845 2
a846 2
    CreateFile (papp, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
d1714 1
a1714 1
      WIN32_FIND_DATA ffinfo;
d1716 2
a1717 1
      HANDLE ff = FindFirstFile (tmp, &ffinfo);
d1722 2
a1723 1
	  char *f = ffinfo.cFileName;
d1742 1
a1742 1
	  found = FindNextFile (ff, &ffinfo);
@


1.110
log
@	* cygcheck.cc (dump_sysinfo): Evaluate and print state of
	obcaseinsensitive kernel flag.
@
text
@d61 1
a61 1
static const char version[] = "$Revision: 1.109 $";
d1982 1
a1982 1
                       repository (requies internet connectivity)\n\
@


1.109
log
@	* Makefile.in: Fix copyright date.
	* cygcheck.cc (scan_registry): Take additional parameter and add code
	to avoid recursion in Wow6432Node subkey.  Rename variable cygnus to
	cygwin.  Scan for "Cygwin" instead of for "cygnus" substring.
	(dump_sysinfo): Drop unused calls to scan_registry.  Drop scanning
	HKEY_CURRENT_CONFIG.
@
text
@d61 1
a61 1
static const char version[] = "$Revision: 1.108 $";
d1211 2
d1528 11
@


1.108
log
@	* cygcheck.cc (dump_sysinfo): Raise size of osname.  Add Windows 7
	and Windows 2008 R2 as recognized OSes.  Update products array to
	the latest documented list.
@
text
@d61 1
a61 1
static const char version[] = "$Revision: 1.107 $";
d924 1
a924 1
scan_registry (RegInfo * prev, HKEY hKey, char *name, int cygnus)
d933 2
a934 2
    if (strncasecmp (cp, "cygnus", 6) == 0)
      cygnus = 1;
d951 1
a951 1
  if (cygnus)
d1004 8
d1015 1
a1015 1
	      scan_registry (&ri, sKey, subkey_name, cygnus);
d1516 5
a1520 13
	printf ("Scanning registry for keys with 'Cygnus' in them...\n");
#if 0
      /* big and not generally useful */
      scan_registry (0, HKEY_CLASSES_ROOT, (char *) "HKEY_CLASSES_ROOT", 0);
#endif
      scan_registry (0, HKEY_CURRENT_CONFIG,
		     (char *) "HKEY_CURRENT_CONFIG", 0);
      scan_registry (0, HKEY_CURRENT_USER, (char *) "HKEY_CURRENT_USER", 0);
      scan_registry (0, HKEY_LOCAL_MACHINE, (char *) "HKEY_LOCAL_MACHINE", 0);
#if 0
      /* the parts we need are duplicated in HKEY_CURRENT_USER anyway */
      scan_registry (0, HKEY_USERS, (char *) "HKEY_USERS", 0);
#endif
@


1.107
log
@        * cygcheck.cc (dump_sysinfo_services): Quote the path for popen.
@
text
@d4 1
a4 1
   2006, 2007, 2008 Red Hat, Inc.
d61 1
a61 1
static const char version[] = "$Revision: 1.106 $";
d1202 1
a1202 1
  char osname[80];
d1235 9
a1243 4
	  if (osversion.wProductType == VER_NT_WORKSTATION)
	    strcpy (osname, "Vista");
	  else
	    strcpy (osname, "2008");
d1252 1
a1252 1
#define       PRODUCT_SMALLBUSINESS_SERVER_PREMIUM 0x19
d1256 8
a1263 8
		  " Ultimate Edition",
		  " Home Basic Edition",
		  " Home Premium Edition",
		  " Enterprise Edition",
		  " Home Basic N Edition",
		  " Business Edition",
		  " Server Standard Edition",
		  " Server Datacenter Edition",
d1265 33
a1297 16
		  " Server Enterprise Edition",
		  " Starter Edition",
		  " Server Datacenter Edition Core",
		  " Server Standard Edition Core",
		  " Server Enterprise Edition Core",
		  " Server Enterprise Edition for Itanium-based Systems",
		  " Business N Edition",
		  " Web Server Edition",
		  " Cluster Server Edition",
		  " Home Server Edition",
		  " Storage Server Express Edition",
		  " Storage Server Standard Edition",
		  " Storage Server Workgroup Edition",
		  " Storage Server Enterprise Edition",
		  " Server for Small Business Edition",
		  " Small Business Server Premium Edition"
d1301 1
a1301 1
	      else if (prod > PRODUCT_SMALLBUSINESS_SERVER_PREMIUM)
@


1.106
log
@        * cygcheck.cc (pretty_id): Quote the path for popen.
        (dump_sysinfo_services): Ditto.
@
text
@d61 1
a61 1
static const char version[] = "$Revision: 1.105 $";
d1140 1
a1140 1
  snprintf (buf, sizeof (buf), (verbose ? "\"%s\" --list --verbose" : "%s --list"),
@


1.105
log
@* cygcheck.cc (pathlike::check_existence): Remove class name from declaration.
(display_internet_error): Use proper format specifier for DWORD.
(environ): Remove unneeded declaration.
(main): Use brace around nested if to avoid an overly-helpful compiler warning.
* dump_setup.cc (parse_filename): Reorganize nested if to avoid an
overly-helpful compiler warning.
* path.cc (GUID_shortcut): Use braces around part of initializer which needs
them.
(conv_fstab_spaces): Parenthesize assignment in while loop to avoid a compiler
warning.
(struct opt): Make static.
* ps.cc (main): Reorganize nested if to avoid an overly-helpful compiler
warning.
* regtool.cc: Make some anonymous structs static to avoid a compiler warning.
* ssp.c (lookup_thread_id): Initialize *tix to zero to avoid potential
uninitialized use.
* strace.cc (add_child): Use proper format specifier for DWORD.
(remove_child): Ditto.
(proc_child): Ditto.
@
text
@d61 1
a61 1
static const char version[] = "$Revision: 1.104 $";
d1035 3
a1037 1
  FILE *f = popen (id, "rt");
a1038 1
  char buf[16384];
d1122 1
a1122 1
  snprintf (buf, sizeof (buf), "%s --version", cygrunsrv);
d1140 1
a1140 1
  snprintf (buf, sizeof (buf), (verbose ? "%s --list --verbose" : "%s --list"),
d1171 1
a1171 1
	    snprintf (buf2, sizeof (buf2), "%s --query %s", cygrunsrv, srv);
@


1.104
log
@* cygcheck.cc (nuke): Use malloc rather than alloca for environment variables.
(load_cygwin): Ditto.
* dump_setup.cc (parse_filename): Cosmetic changes.
(get_packages): Ditto.
@
text
@d61 1
a61 1
static const char version[] = "$Revision: 1.103 $";
d127 3
a129 3
  void pathlike::check_existence (const char *fn, int showall, int verbose,
				  char* first, const char *ext1 = "",
				  const char *ext2 = "");
d204 1
a204 1
      fprintf (stderr, "cygcheck: %s: %s (win32 error %d)\n", message,
a903 3

extern char **environ;

d2115 7
a2121 5
  if (argc == 0 && !sysinfo && !keycheck && !check_setup && !list_package)
    if (givehelp)
      usage (stdout, 0);
    else
      usage (stderr, 1);
@


1.103
log
@* cygcheck.cc (print_version): Update copyright dates.
@
text
@d61 1
a61 1
static const char version[] = "$Revision: 1.102 $";
d2006 1
a2006 1
  char *s = (char *) alloca (n + 1);
d2054 1
a2054 1
	     putenv (*ev);
@


1.102
log
@* cygcheck.cc (load_cygwin): Duplicate argv list since it disappears when
cygwin1.dll is unloaded.
@
text
@d61 1
a61 1
static const char version[] = "$Revision: 1.101 $";
d1997 1
a1997 1
Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Red Hat, Inc.\n\
@


1.101
log
@* cygcheck.cc (load_cygwin): Free the cygwin dll after we're done with it.
@
text
@d61 1
a61 1
static const char version[] = "$Revision: 1.100 $";
d2027 9
a2035 2
	for (argc = 0, argv = av; *av; av++)
	  argc++;
@


1.100
log
@	* cygcheck.cc (dump_sysinfo): Fix multiple Cygwin DLL test.
	* path.cc: Fetch mount points from fstab files instead of from
	registry.  Use adapted functions copied from Cygwin DLL.
	(mnt_t): Drop issys member.  Define as "mnt_t" instead of "struct mnt_t"
	subsequently.
	(max_mount_entry): New variable.
	(unconvert_slashes): Move to earlier location in file.  Make inline.
	(find2): Remove.
	(get_cygdrive0): Remove.
	(get_cygdrive): Remove.
	(skip_ws): New function.
	(find_ws): Ditto.
	(conv_fstab_spaces): Ditto.
	(read_flags): Ditto.
	(from_fstab_line): Ditto.
	(get_user): Ditto.
	(from_fstab): Ditto.
	(mnt_sort): Ditto.
	(read_mounts): Drop old registry code.  Fetch
	"Software\Cygwin\Setup\rootdir" value from HKCU or HKLM key.  Use
	rootdir extracted from module path as fallback.  Call from_fstab for
	nouser and user mount points.
	(setmntent): Check max_mount_entry to test if read_mounts must be
	called.
	(getmntent): Use MOUNT_SYSTEM flag instead of mnt_t's issys member.
@
text
@d4 1
a4 1
   2006, 2007 Red Hat, Inc.
d61 1
a61 1
static const char version[] = "$Revision: 1.99 $";
d2023 28
a2050 28
  if (!(cygwin_internal = (DWORD (*) (int, ...)) GetProcAddress (h, "cygwin_internal")))
    return;

  char **av = (char **) cygwin_internal (CW_ARGV);
  if (av && ((DWORD) av != (DWORD) -1))
    for (argc = 0, argv = av; *av; av++)
      argc++;

  char **envp = (char **) cygwin_internal (CW_ENVP);
  if (envp && ((DWORD) envp != (DWORD) -1))
    {
      /* Store path and revert to this value, otherwise path gets overwritten
	 by the POSIXy Cygwin variation, which breaks cygcheck.
	 Another approach would be to use the Cygwin PATH and convert it to
	 Win32 again. */
      char *path = NULL;
      char **env;
      while (*(env = _environ))
	{
	  if (strncmp (*env, "PATH=", 5) == 0)
	    path = strdup (*env);
	  nuke (*env);
	}
      for (char **ev = envp; *ev; ev++)
	if (strncmp (*ev, "PATH=", 5) != 0)
	 putenv (*ev);
      if (path)
	putenv (path);
d2052 1
@


1.99
log
@	* cygcheck.cc (find_app_on_path): Make buffer SYMLINK_MAX + 1
	chars.
@
text
@d61 1
a61 1
static const char version[] = "$Revision: 1.98 $";
d1672 1
d1690 5
a1694 1
		      cygwin_dll_count++;
@


1.98
log
@	* cygcheck.cc (dirname): New static function.
	(find_app_on_path): Use SYMLINK_MAX.  Resolve symlink relative
	to link's location.  Adjust to the fact that cygpath already
	normalizes its return value.
	* path.cc (rel_vconcat): Add cwd parameter, and use it instead
	of calling GetCurrentDirectory() if possible.  Rename throughout.
	(vcygpath): Rename from cygpath and accept cwd and va_list.  Pass
	cwd on to rel_vconcat().
	(cygpath_rel): New front end for vcygpath.
	(cygpath): Ditto.
	* path.h (cygpath_rel): Declare.
	(SYMLINK_MAX): Define to 4095.
@
text
@d61 1
a61 1
static const char version[] = "$Revision: 1.97 $";
d846 1
a846 1
      static char tmp[SYMLINK_MAX];
d856 1
a856 1
	  strncpy (tmp, cygpath (papp, NULL), SYMLINK_MAX - 1);
d858 1
a858 1
	  strncpy (lastsep+1, ptr, SYMLINK_MAX - 1 - (lastsep-tmp));
@


1.97
log
@	* cygcheck.cc (dump_sysinfo): Always try to get a OSVERSIONINFOEX
	first.  Load kernel32.dll earlier.  Make osname a buffer.  Simplify
	Non-NT code.  Use GetProductInfo in Vista/2008 case.  Clean up
	non-Vista version info.  Exit early if not on NT.
@
text
@d61 1
a61 1
static const char version[] = "$Revision: 1.96 $";
d810 22
d846 2
a847 3
      static char tmp[4000] = "";
      char *ptr;
      if (!readlink (fh, tmp, 3999))
d849 3
a851 3
      ptr = cygpath (tmp, NULL);
      for (char *p = ptr; (p = strchr (p, '/')); p++)
	*p = '\\';
d856 1
a856 3
	  strncpy (tmp, cygpath (papp, NULL), 3999);
	  for (char *p = tmp; (p = strchr (p, '/')); p++)
	    *p = '\\';
d858 1
a858 1
	  strncpy (lastsep+1, ptr, 3999-(lastsep-tmp));
d863 2
@


1.96
log
@	* Makefile.in (cygcheck.exe):  Add bloda.o as prerequisite, adjusting
	dependency-filtering $(wordlist ...) call appropriately.  Link ntdll.
	(bloda.o):  New rule to build bloda.o
	* cygcheck.cc (dump_sysinfo):  Call bloda function dump_dodgy_apps().
	* bloda.cc:  New file implements detection of applications from the
	Big List Of Dodgy Apps.
@
text
@d61 1
a61 1
static const char version[] = "$Revision: 1.95 $";
d1182 2
d1189 12
a1200 5
  OSVERSIONINFO osversion;
  osversion.dwOSVersionInfoSize = sizeof (osversion);
  if (!GetVersionEx (&osversion))
    display_error ("dump_sysinfo: GetVersionEx()");
  const char *osname = "unknown OS";
d1204 1
a1204 1
      osname = "32s";
d1207 1
a1207 15
      switch (osversion.dwMinorVersion)
	{
	case 0:
	  osname = "95 (not supported)";
	  break;
	case 10:
	  osname = "98 (not supported)";
	  break;
	case 90:
	  osname = "ME (not supported)";
	  break;
	default:
	  osname = "9X (not supported)";
	  break;
	}
d1212 57
a1268 1
	osname = "Vista";
a1270 5
	  BOOL more_info = FALSE;
	  OSVERSIONINFOEX osversionex;
	  osversionex.dwOSVersionInfoSize = sizeof (osversionex);
	  if (GetVersionEx ((OSVERSIONINFO *) &osversionex))
	    more_info = TRUE;
d1273 7
a1279 12
	      if (!more_info)
		osname = "2000";
	      else if (osversionex.wProductType == VER_NT_SERVER
		       || osversionex.wProductType == VER_NT_DOMAIN_CONTROLLER)
		{
		  if (osversionex.wSuiteMask & VER_SUITE_DATACENTER)
		    osname = "2000 Datacenter Server";
		  else if (osversionex.wSuiteMask & VER_SUITE_ENTERPRISE)
		    osname = "2000 Advanced Server";
		  else
		    osname = "2000 Server";
		}
d1281 1
a1281 1
		osname = "2000 Professional";
d1285 1
d1287 1
a1287 1
		osname = "XP Media Center Edition";
d1289 5
a1293 5
		osname = "XP Tablet PC Edition";
	      else if (!more_info)
		osname = "XP";
	      else if (osversionex.wSuiteMask & VER_SUITE_PERSONAL)
		osname = "XP Home Edition";
d1295 1
a1295 1
		osname = "XP Professional";
d1299 20
a1318 8
	      if (!more_info)
		osname = "2003 Server";
	      else if (osversionex.wSuiteMask & VER_SUITE_BLADE)
		osname = "2003 Web Server";
	      else if (osversionex.wSuiteMask & VER_SUITE_DATACENTER)
		osname = "2003 Datacenter Server";
	      else if (osversionex.wSuiteMask & VER_SUITE_ENTERPRISE)
		osname = "2003 Enterprise Server";
d1320 5
a1324 1
		osname = "2003 Server";
d1328 1
a1328 1
	osname = "NT";
d1331 1
a1331 1
      osname = "??";
d1341 3
a1343 1
  HMODULE k32 = LoadLibrary ("kernel32.dll");
@


1.95
log
@* cygcheck.cc (pathlike): New class.
(paths): Redefine as type pathlike.
(display_error): Declare a few different ways to allow more flexible usage
throughout.
(display_error_fmt): New function for those cases where C++ just isn't enough.
(add_path): Rewrite to allocate pathlike paths.  Always tack on a trailing
slash since that's what everyone who uses it wants.  NULL terminate the path
list.  Register "it's a system path" field.
(init_path): Call add_path with info regarding whether path is a system path or
not.
(pathlike::check_existence): Move into pathlike class.  Accept file and
extension arguments to build up path on the fly.  Modify other arguments.
(find_on_path): Constify return value and appropriate arguments.  Eliminate
short-circuit for fully-qualified paths.  Simplify loop which iterates over
path.
(already_did): Constify argument.
(track_down): Ditto.  Regularize some error messages.
(find_app_on_path): Ditto.
(cygcheck): Constify argument.  Use 20th century string handling functions.
(dump_sysinfo): Remove odd inclusion of '\\bin' "Just in case".  Accommodate
change of paths to pathlike.
* path.cc (isslash): Rename from SLASH_P and use throughout.
(rel_vconcat): Front-end to vconcat which prepends cwd to path before passing
along for conversion to native windows.
(cygpath): Remove "./" test.  Call rel_vconcat if filename appears to be
relative.
@
text
@d53 1
d57 2
d60 2
a61 1
static const char version[] = "$Revision: 1.94 $";
d1630 2
@


1.94
log
@	* cygcheck.cc (dump_sysinfo): Add "not supported" to osname on 9x
	machines.  Drop "not supported" for Vista.  Drop "Longhorn" text
	for now.
@
text
@d41 2
d57 1
a57 1
static const char version[] = "$Revision: 1.91 $";
d119 10
a128 1
static char **paths;
d144 1
a144 1
display_error (const char *name, bool show_error = true, bool print_failed = true)
d146 1
d148 1
a148 1
    fprintf (stderr, "cygcheck: %s%s: %lu\n", name,
d151 1
a151 1
    fprintf (stderr, "cygcheck: %s%s\n", name,
d156 25
d196 3
a198 3
          GetModuleHandle ("wininet.dll"), err, 0, err_buf,
          sizeof (err_buf), NULL) == 0)
        strcpy (err_buf, "(Unknown error)");
d201 1
a201 1
               err_buf, err);
d215 1
a215 1
add_path (char *s, int maxlen)
d220 2
a221 4
      if (paths)
	paths = (char **) realloc (paths, max_paths * sizeof (char *));
      else
	paths = (char **) malloc (max_paths * sizeof (char *));
d223 6
a228 2
  paths[num_paths] = (char *) malloc (maxlen + 1);
  if (paths[num_paths] == NULL)
d230 1
a230 1
      display_error ("add_path: malloc()");
d233 13
a245 11
  memcpy (paths[num_paths], s, maxlen);
  paths[num_paths][maxlen] = 0;
  char *e = paths[num_paths] + strlen (paths[num_paths]);
  if (e[-1] == '\\' && e[-2] != ':')
    *--e = 0;
  for (int i = 1; i < num_paths; i++)
    if (strcasecmp (paths[num_paths], paths[i]) == 0)
      {
	free (paths[num_paths]);
	return;
      }
d253 1
a253 1
  add_path ((char *) ".", 1);	/* to be replaced later */
d256 1
a256 1
    add_path (tmp, strlen (tmp));
d261 1
a261 1
    add_path (tmp, strlen (tmp));
d268 1
a268 1
      add_path (tmp, strlen (tmp));
d271 1
a271 2
  add_path (tmp, strlen (tmp));
  first_nonsys_path = num_paths;
d275 1
a275 1
    fprintf (stderr, "WARNING: PATH is not set at all!\n");
d282 4
a285 3
	  for (e = b; *e && *e != ';'; e++);
	  if (strncmp(b, ".", 1) && strncmp(b, ".\\", 2))
	    add_path (b, e - b);
d295 3
a297 2
static bool
check_existence (char *file, int showall, int foundone, char *first)
d299 6
d314 1
a314 1
      if (foundone)
d327 2
a328 1
      return true;
a329 1
  return false;
d332 3
a334 3
static char *
find_on_path (char *file, char *default_extension,
	      int showall = 0, int search_sysdirs = 0, int checklinks = 0)
a336 1
  char tmp[4000], *ptr = rv;
d338 12
a349 1
  if (!file)
d351 1
a351 1
      display_error ("find_on_path: NULL pointer for file", false, false);
d355 1
a355 1
  if (default_extension == NULL)
d357 1
a357 1
      display_error ("find_on_path: NULL pointer for default_extension", false, false);
d361 3
a363 1
  if (strchr (file, ':') || strchr (file, '\\') || strchr (file, '/'))
d365 9
a373 28
      // FIXME: this will find "foo" before "foo.exe" -- contrary to Windows
      char *fn = cygpath (file, NULL);
      if (access (fn, F_OK) == 0)
	return fn;
      strcpy (rv, fn);
      strcat (rv, default_extension);
      if (access (rv, F_OK) == 0)
	return rv;
      if (!checklinks)
	return fn;
      strcat (rv, LINK_EXTENSION);
      if (access (rv, F_OK) == 0)
	return rv;
      strcpy (rv, fn);
      strcat (rv, LINK_EXTENSION);
      return access (rv, F_OK) == 0 ? strdup (rv) : fn;
    }

  if (strchr (file, '.'))
    default_extension = (char *) "";

  for (int i = search_sysdirs ? 0 : first_nonsys_path; i < num_paths; i++)
    {
      if (i == 0 || !search_sysdirs || strcasecmp (paths[i], paths[0]))
	{
	  sprintf (ptr, "%s\\%s%s", paths[i], file, default_extension);
	  if (check_existence (ptr, showall, ptr == tmp && verbose, rv))
	    ptr = tmp;
d375 9
a383 2
	  if (!checklinks)
	    continue;
d385 4
a388 3
	  sprintf (ptr, "%s\\%s%s%s", paths[i], file, default_extension, LINK_EXTENSION);
	  if (check_existence (ptr, showall, ptr == tmp && verbose, rv))
	    ptr = tmp;
d390 2
a391 2
	  if (!*default_extension)
	    continue;
d393 2
a394 8
	  sprintf (ptr, "%s\\%s", paths[i], file);
	  if (check_existence (ptr, showall, ptr == tmp && verbose, rv))
	    ptr = tmp;
	  sprintf (ptr, "%s\\%s%s", paths[i], file, LINK_EXTENSION);
	  if (check_existence (ptr, showall, ptr == tmp && verbose, rv))
	    ptr = tmp;
	}
    }
d396 4
a399 2
  if (ptr == tmp)
    return rv;
d401 1
a401 1
  return 0;
d417 1
a417 1
already_did (char *file)
d488 1
a488 2

static bool track_down (char *file, char *suffix, int lvl);
d694 1
a694 1
track_down (char *file, char *suffix, int lvl)
d708 1
a708 1
  char *path = find_on_path (file, suffix, 0, 1);
d711 1
a711 1
      printf ("Error: could not find %s\n", file);
d747 1
a747 1
      printf ("%s not found\n", file);
d758 1
a758 1
      printf (" - Cannot open\n");
d767 1
a767 1
    printf (" - Found a symlink instead of a DLL\n");
d772 1
a772 1
        display_error ("get_word");
d774 2
a775 2
      printf (" - Not a DLL: magic number %x (%d) '%s'\n",
              magic, magic, (char *)&magic);
d807 2
a808 2
static char *
find_app_on_path (char *app, int showall = 0)
d810 1
a810 1
  char *papp = find_on_path (app, (char *) ".exe", showall, 0, 1);
d816 1
a816 4
    {
      printf (" - Cannot open\n");
      return NULL;
    }
d850 1
a850 1
cygcheck (char *app)
d852 1
a852 1
  char *papp = find_app_on_path (app, 1);
d855 1
a855 1
      printf ("Error: could not find %s\n", app);
d858 8
a865 7
  char *s = strdup (papp);
  char *sl = 0, *t;
  for (t = s; *t; t++)
    if (*t == '/' || *t == '\\' || *t == ':')
      sl = t;
  if (sl == 0)
    paths[0] = (char *) ".";
d868 4
a871 2
      *sl = 0;
      paths[0] = s;
d873 4
a876 2
  did = 0;
  return track_down (papp, (char *) ".exe", 0);
d1241 1
a1241 1
	        osname = "XP Media Center Edition";
d1243 1
a1243 1
	        osname = "XP Tablet PC Edition";
d1247 1
a1247 1
	        osname = "XP Home Edition";
d1249 1
a1249 1
	        osname = "XP Professional";
d1287 1
a1287 1
        (LPSYSTEM_INFO)) GetProcAddress (k32, "GetNativeSystemInfo");
d1292 1
a1292 1
        {
a1570 2
  add_path ((char *) "\\bin", 4);	/* just in case */

d1587 1
a1587 1
  for (i = 1; i < num_paths; i++)
d1590 1
a1590 1
      sprintf (tmp, "%s/*.*", paths[i]);
d1601 1
a1601 1
		  sprintf (tmp, "%s\\%s", paths[i], f);
d1719 1
a1719 1
        "http://cygwin.com/cgi-bin2/package-grep.cgi?text=1&grep=";
d1734 1
a1734 1
             "Internet Explorer v3 or later to function.\n", stderr);
d1743 1
a1743 1
                            GetProcAddress (hWinInet, "InternetCloseHandle");
d1745 1
a1745 1
            (ret (WINAPI *) args) GetProcAddress (hWinInet, #name);
d1747 4
a1750 4
  make_func_pointer (InternetOpenA, HINTERNET, (LPCSTR, DWORD, LPCSTR, LPCSTR, 
                                                DWORD));
  make_func_pointer (InternetOpenUrlA, HINTERNET, (HINTERNET, LPCSTR, LPCSTR, 
                                                   DWORD, DWORD, DWORD));
d1753 1
a1753 1
                                            PDWORD));
d1760 2
a1761 2
             "feature requires Microsoft Internet Explorer v3 or later to "
             "function.\n", stderr);
d1773 4
a1776 4
          || memchr (safe_chars, *search, sizeof (safe_chars) - 1))
        {
          *dest++ = *search;
        }
d1778 5
a1782 5
        {
          *dest++ = '%';
          sprintf (dest, "%02x", (unsigned char) *search);
          dest += 2;
        }
d1800 1
a1800 1
                                   "InternetOpenUrl() failed", hi, NULL);
d1805 1
a1805 1
                      (void *) &rc, &rc_s, NULL))
d1811 1
a1811 1
                    "HTTP status code %lu", rc);
d1820 1
a1820 1
        return display_internet_error ("InternetReadFile failed", hurl, hi, NULL);
d1822 1
a1822 1
        fwrite ((void *) buf, (size_t) numread, 1, stdout);
d2002 2
a2003 2
        grep_packages = 1;
        break;
@


1.93
log
@	* cygcheck.cc (get_word, get_dword): Move to path.cc.
	(LINK_EXTENSION): New macro.
	(check_existence): New static function.
	(find_on_path): Check for symbolic links if asked.
	(dll_info): New error handling.
	(track_down): Only call dll_info() for executables, display
	an error for symlinks, and print magic number for others.
	(find_app_on_path): New static function.
	(cygcheck, dump_sysinfo): Call find_app_on_path() instead of
	find_on_path().
	* path.cc (cmp_shortcut_header): New static function.
	(get_word, get_dword): Moved from cygcheck.cc.
	(EXE_MAGIC, SHORTCUT_MAGIC, SYMLINK_COOKIE, SYMLINK_MAGIC): New
	macros.
	(is_exe, is_symlink, readlink): New functions.
	* path.h (is_exe, is_symlink, readlink): Declare.
	(get_word, get_dword): Ditto.
@
text
@d4 1
a4 1
   2006 Red Hat, Inc.
d1151 1
a1151 4
	  if (strchr (osversion.szCSDVersion, 'C'))
	    osname = "95 OSR2";
	  else
	    osname = "95";
d1154 1
a1154 4
	  if (strchr (osversion.szCSDVersion, 'A'))
	    osname = "98 SE";
	  else
	    osname = "98";
d1157 1
a1157 1
	  osname = "ME";
d1160 1
a1160 1
	  osname = "9X";
d1167 1
a1167 1
	osname = "Longhorn/Vista (not yet supported!)";
@


1.92
log
@white space
@
text
@d252 32
d286 1
a286 1
	      int showall = 0, int search_sysdirs = 0)
d305 1
d311 9
d331 19
a349 8
	  if (GetFileAttributes (ptr) != (DWORD) - 1)
	    {
	      if (showall)
		printf ("Found: %s\n", ptr);
	      if (ptr == tmp && verbose)
		printf ("Warning: %s hides %s\n", rv, ptr);
	      ptr = tmp;
	    }
a385 32
static int
get_word (HANDLE fh, int offset)
{
  short rv;
  unsigned r;

  if (SetFilePointer (fh, offset, 0, FILE_BEGIN) == INVALID_SET_FILE_POINTER
      && GetLastError () != NO_ERROR)
    display_error ("get_word: SetFilePointer()");

  if (!ReadFile (fh, &rv, 2, (DWORD *) &r, 0))
    display_error ("get_word: Readfile()");

  return rv;
}

static int
get_dword (HANDLE fh, int offset)
{
  int rv;
  unsigned r;

  if (SetFilePointer (fh, offset, 0, FILE_BEGIN) == INVALID_SET_FILE_POINTER
      && GetLastError () != NO_ERROR)
    display_error ("get_dword: SetFilePointer()");

  if (!ReadFile (fh, &rv, 4, (DWORD *) &r, 0))
    display_error ("get_dword: Readfile()");

  return rv;
}

d529 2
d554 2
d557 2
d560 2
d563 2
d566 2
d570 2
d720 14
a733 1
  dll_info (path, fh, lvl, 1);
d762 45
d811 1
a811 1
  char *papp = find_on_path (app, (char *) ".exe", 1, 0);
d1537 1
a1537 1
    if (!find_on_path ((char *) common_apps[i].name, (char *) ".exe", 1, 0))
@


1.91
log
@Check in previously mentioned change to cygcheck.cc
@
text
@d55 1
a55 1
static const char version[] = "$Revision: 1.90 $";
d1842 1
a1842 1
  (void) putenv("POSIXLY_CORRECT=1");
@


1.90
log
@	* cygcheck.cc (find_on_path): Update copyright text.
@
text
@d55 1
a55 1
static const char version[] = "$Revision: 1.89 $";
d1838 4
d1884 2
@


1.90.4.1
log
@2007-08-31  Dave Korn  <dave.korn@@artimi.com>

	* mkgroup.c (enum_groups):  Use MAX_PREFERRED_LENGTH in netgroupenum
	call so that it will automatically size returned buffer sufficiently.

2007-08-03  Dave Korn  <dave.korn@@artimi.com>

	* Makefile.in (cygcheck.exe):  Add bloda.o as prerequisite, adjusting
	dependency-filtering $(wordlist ...) call appropriately.  Link ntdll.
	(bloda.o):  New rule to build bloda.o
	* cygcheck.cc (dump_sysinfo):  Call bloda function dump_dodgy_apps().
	* bloda.cc:  New file implements detection of applications from the
	Big List Of Dodgy Apps.

2007-07-24  Corinna Vinschen  <corinna@@vinschen.de>

	* COPYING.dumper: New file.
	* dumper.cc: Change license to plain GPLv2 + later.
	* dumper.h: Ditto.
	* parse_pe.cc: Ditto.

2007-07-23  Christopher Faylor  <me+cygwin@@cgf.cx>

	* strace.cc (create_child): Don't convert a path from cygwin format
	unless it has a slash.

2007-07-09  Christopher Faylor  <me+cygwin@@cgf.cx>

	* strace.cc (usage): Add missing description for -q.

2007-05-29  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* dumper.cc (dumper::prepare_core_dump): Record a phdr for each section.

2007-03-30  Mark Mitchell  <mark@@codesourcery.com>

	* utils/cygpath.cc (get_long_path_name_w32impl): Close handles returned
	by FindFirstFile.

2006-09-11  Eric Blake  <ebb9@@byu.net>

	* cygcheck.cc (main): Restore POSIXLY_CORRECT before displaying user's
	environment.

2006-08-03  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (vconcat): Don't convert backslahes to slashes.
	(cygpath): Return native path with all backslashes.

2006-07-30  Ilya Bobir  <ilya@@po4ta.com>

	* cygpath.cc (get_long_name): Fallback to get_long_path_name_w32impl.

2006-07-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygpath.c (get_long_name): Cover the case that GetLongPathName
	doesn't return valid information for non-existant files.  Just return
	incoming filename in that case.
@
text
@a50 1
/* In dump_setup.cc  */
a53 2
/* In bloda.cc  */
void dump_dodgy_apps (int verbose);
d55 1
a55 2

static const char version[] = "$Revision: 1.96 $";
a1494 2
  dump_dodgy_apps (verbose);

d1838 1
a1838 5
  /* Need POSIX sorting while parsing args, but don't forget the
     user's original environment.  */
  char *posixly = getenv ("POSIXLY_CORRECT");
  if (posixly == NULL)
    (void) putenv("POSIXLY_CORRECT=1");
a1879 2
  if (posixly == NULL)
    putenv ("POSIXLY_CORRECT=");
@


1.89
log
@	* cygcheck.cc (find_on_path): Create copy of rv on successful access
	check, since rv can be reused in subsequent calls.
@
text
@d55 1
a55 1
static const char version[] = "$Revision: 1.88 $";
d1774 1
a1774 1
Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Red Hat, Inc.\n\
@


1.88
log
@* cygcheck.cc (common_paths): Add "patch".
@
text
@d55 1
a55 1
static const char version[] = "$Revision: 1.87 $";
d278 1
a278 1
      return access (rv, F_OK) == 0 ? rv : fn;
@


1.87
log
@* cygcheck.cc (init_paths): Record first_nonsys_path.
(find_on_path): Start on first nonsys path when !search_sysdirs.
@
text
@d55 1
a55 1
static const char version[] = "$Revision: 1.86 $";
d103 1
@


1.86
log
@copyright
@
text
@d55 1
a55 1
static const char version[] = "$Revision: 1.85 $";
d115 3
a117 2
static int num_paths = 0, max_paths = 0;
static char **paths = 0;
d230 1
d233 3
a235 1
  if (wpath)
a248 2
  else
    printf ("WARNING: PATH is not set at all!\n");
d283 1
a283 1
  for (int i = 0; i < num_paths; i++)
a284 2
      if (!search_sysdirs && (i == 0 || i == 2 || i == 3))
	continue;
@


1.85
log
@	* Makefile.in (cygcheck.exe): Do not link against libwininet.a.
	* cygcheck.cc (pInternetCloseHandle): Define global function pointer.
	(display_internet_error): Use it.
	(package_grep): Attempt to load wininet.dll at runtime.  Call WinInet
	API through function pointers throughout.
@
text
@d3 2
a4 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Red Hat, Inc.
d55 1
a55 1
static const char version[] = "$Revision: 1.84 $";
@


1.84
log
@	* cygcheck.cc (dump_sysinfo): Convert k32 to HMODULE.
@
text
@d40 4
d54 1
a54 1
static const char version[] = "$Revision: 1.83 $";
d168 1
a168 1
    InternetCloseHandle (h);
d1595 37
d1654 1
a1654 1
  if (InternetAttemptConnect (0) != ERROR_SUCCESS)
d1662 1
a1662 1
  if (!(hi = InternetOpen ("cygcheck", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0)))
d1665 1
a1665 1
  if (!(hurl = InternetOpenUrl (hi, url, NULL, 0, 0, 0)))
d1671 1
a1671 1
  if (!HttpQueryInfo (hurl, HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
d1686 1
a1686 1
      if (!InternetReadFile (hurl, (void *) buf, sizeof (buf), &numread))
d1693 2
a1694 2
  InternetCloseHandle (hurl);
  InternetCloseHandle (hi);
@


1.83
log
@	* cygcheck.cc (dump_sysinfo): Convert osname to const and remove casts
	in subsequent assignments.  Recognize Longhorn/Vista and report as not
	yet supported.  Recognize when running under WOW64 and report native
	CPU type.  Slightly rearrange \n printing.
@
text
@d50 1
a50 1
static const char version[] = "$Revision: 1.82 $";
d1140 1
a1140 1
  HINSTANCE k32 = LoadLibrary ("kernel32.dll");
@


1.82
log
@* cygcheck.cc: Replace ` with ' throughout.
@
text
@d50 1
a50 1
static const char version[] = "$Revision: 1.81 $";
d1042 1
a1042 1
  char *osname = (char *) "unknown OS";
d1046 1
a1046 1
      osname = (char *) "32s";
d1053 1
a1053 1
	    osname = (char *) "95 OSR2";
d1055 1
a1055 1
	    osname = (char *) "95";
d1059 1
a1059 1
	    osname = (char *) "98 SE";
d1061 1
a1061 1
	    osname = (char *) "98";
d1064 1
a1064 1
	  osname = (char *) "ME";
d1067 1
a1067 1
	  osname = (char *) "9X";
d1073 3
a1075 1
      if (osversion.dwMajorVersion == 5)
d1085 1
a1085 1
		osname = (char *) "2000";
d1090 1
a1090 1
		    osname = (char *) "2000 Datacenter Server";
d1092 1
a1092 1
		    osname = (char *) "2000 Advanced Server";
d1094 1
a1094 1
		    osname = (char *) "2000 Server";
d1097 1
a1097 1
		osname = (char *) "2000 Professional";
d1102 1
a1102 1
	        osname = (char *) "XP Media Center Edition";
d1104 1
a1104 1
	        osname = (char *) "XP Tablet PC Edition";
d1106 1
a1106 1
		osname = (char *) "XP";
d1108 1
a1108 1
	        osname = (char *) "XP Home Edition";
d1110 1
a1110 1
	        osname = (char *) "XP Professional";
d1115 1
a1115 1
		osname = (char *) "2003 Server";
d1117 1
a1117 1
		osname = (char *) "2003 Web Server";
d1119 1
a1119 1
		osname = (char *) "2003 Datacenter Server";
d1121 1
a1121 1
		osname = (char *) "2003 Enterprise Server";
d1123 1
a1123 1
		osname = (char *) "2003 Server";
d1127 1
a1127 1
	osname = (char *) "NT";
d1130 1
a1130 1
      osname = (char *) "??";
d1133 1
a1133 1
  printf ("Windows %s Ver %lu.%lu Build %lu %s\n\n", osname,
d1139 27
d1167 1
a1167 1
    printf ("Running in Terminal Service session\n\n");
d1169 1
a1169 1
  printf ("Path:");
a1290 1
  HINSTANCE k32 = LoadLibrary ("kernel32.dll");
@


1.81
log
@* cygcheck.cc (dump_sysinfo): Report the failing drive to prevent having to
guess.
@
text
@d50 1
a50 1
static const char version[] = "$Revision: 1.80 $";
d818 1
a818 1
		printf ("`%s'\n", value_data);
d864 1
a864 1
      fprintf (stderr, "`id' program not found\n");
d879 1
a879 1
      fprintf (stderr, "garbled output from `id' command - no uid= found\n");
d887 1
a887 1
      fprintf (stderr, "garbled output from `id' command - no gid= found\n");
d1198 1
a1198 1
	    printf ("%s = `%s'\n", environ[i], eq + 1);
d1225 1
a1225 1
	      printf ("%s = `%s'\n", environ[i], eq + 1);
d1235 1
a1235 1
	printf ("Scanning registry for keys with `Cygnus' in them...\n");
d1251 1
a1251 1
    printf ("Use `-r' to scan registry\n\n");
d1489 1
a1489 1
  fputs ("Press `q' to exit.\n", stderr);
@


1.80
log
@* cygcheck.cc (common_apps): Add crontab, vi, vim.
@
text
@d50 1
a50 1
static const char version[] = "$Revision: 1.79 $";
d1278 11
a1288 4
      if (!GetVolumeInformation
	  (drive, name, sizeof (name), &serno, &maxnamelen, &flags, fsname,
	   sizeof (fsname)) && GetLastError () != ERROR_NOT_READY)
	display_error ("dump_sysinfo: GetVolumeInformation()");
@


1.79
log
@* cygcheck.cc (common_apps): Add a few more binaries to look for.
@
text
@d50 1
a50 1
static const char version[] = "$Revision: 1.78 $";
d88 1
d105 2
@


1.78
log
@* Makefile.in: Link cygcheck with libwininet.a.
* cygcheck.cc: Add includes.
(grep_packages): New global variable.
(display_internet_error): New function.
(safe_chars): New global variable.
(base_url): Ditto.
(package_grep): New function.
(usage): Reword --help output for clarity.  Document new argument.
(longopts): Add 'package-query' option.
(opts): Add 'p' option, reorder to be consistent with 'longopts'.
(main): Accommodate new option.
* utils.sgml (cygcheck): Update --help output.  Document new -p option.
@
text
@d50 1
a50 1
static const char version[] = "$Revision: 1.77 $";
d92 1
d97 1
d100 1
d103 1
@


1.77
log
@        * cygcheck.cc (dump_sysinfo_services): Properly null-terminate 'buf'.
        Avoid extraneous cygrunsrv invocation if 'verbose' is true.
@
text
@d14 1
d20 1
d38 1
d50 1
a50 1
static const char version[] = "$Revision: 1.76 $";
d130 33
d1535 80
d1619 27
a1645 2
Usage: cygcheck [OPTIONS] [PROGRAM...]\n\
Check system information or PROGRAM library dependencies\n\
d1647 4
a1650 11
 -c, --check-setup   check packages installed via setup.exe\n\
 -d, --dump-only     no integrity checking of package contents (requires -c)\n\
 -s, --sysinfo       system information (not with -k)\n\
 -v, --verbose       verbose output (indented) (for -[cfls] or programs)\n\
 -r, --registry      registry search (requires -s)\n\
 -k, --keycheck      perform a keyboard check session (not with -[scfl])\n\
 -f, --find-package  find installed packages containing files (not with -[cl])\n\
 -l, --list-package  list the contents of installed packages (not with -[cf])\n\
 -h, --help          give help about the info (not with -[cfl])\n\
 -V, --version       output version information and exit\n\
You must at least give either -s or -k or a program name\n");
d1663 1
d1669 1
a1669 1
static char opts[] = "cdfhklrsvV";
d1781 3
d1802 2
a1803 1
  if ((check_setup || sysinfo || find_package || list_package) && keycheck)
d1806 1
a1806 1
  if ((find_package || list_package) && check_setup)
d1812 1
a1812 1
  if (find_package && list_package)
d1817 2
@


1.76
log
@* cygcheck.cc (find_on_path): Perform .exe magic on non-PATH search.
@
text
@d47 1
a47 1
static const char version[] = "$Revision: 1.75 $";
d891 1
d926 5
a930 2
  /* run cygrunsrv --list */
  snprintf (buf, sizeof (buf), "%s --list", cygrunsrv);
a935 2
  size_t nchars = fread ((void *) buf, 1, sizeof (buf), f);
  pclose (f);
d937 1
a937 2
  /* were any services found?  */
  if (nchars < 1)
d939 10
a948 2
      puts ("No Cygwin services found.\n");
      return;
d950 1
a950 4

  /* In verbose mode, just run 'cygrunsrv --list --verbose' and copy the
     entire output.  Otherwise run 'cygrunsrv --query' for each service.  */
  for (char *srv = strtok (buf, "\n"); srv; srv = strtok (NULL, "\n"))
d952 4
a955 9
      if (verbose)
	snprintf (buf2, sizeof (buf2), "%s --list --verbose", cygrunsrv);
      else
	snprintf (buf2, sizeof (buf2), "%s --query %s", cygrunsrv, srv);
      if ((f = popen (buf2, "rt")) == NULL)
	{
	  printf ("Failed to execute '%s', skipping services check.\n", buf2);
	  return;
	}
d957 9
a965 8
      /* copy output to stdout */
      do
	{
	  nchars = fread ((void *)buf2, 1, sizeof (buf2), f);
	  fwrite ((void *)buf2, 1, nchars, stdout);
	}
      while (!feof (f) && !ferror (f));
      pclose (f);
d967 8
a974 2
      if (verbose)
	break;
d976 4
@


1.75
log
@* cygcheck.cc (track_down, cygcheck): Return true on success.
(main): Reflect cygcheck failures in exit status.
@
text
@d47 1
a47 1
static const char version[] = "$Revision: 1.74 $";
d221 8
a228 1
    return cygpath (file, NULL);
@


1.74
log
@	* cygcheck.cc (dump_sysinfo): Recognize XP Media Center and Tablet PC
	Editions. Change .NET to 2003 throughout.  Recognize 2003 Web Server
	and Datacenter Server. Report when running in terminal server session.
@
text
@d47 1
a47 1
static const char version[] = "$Revision: 1.73 $";
d367 1
a367 1
static void track_down (char *file, char *suffix, int lvl);
d557 2
a558 1
static void
d564 1
a564 1
      return;
d570 1
a570 1
      return;
d577 1
a577 1
      return;
d593 1
a593 1
      return;
d602 1
a602 1
      return;
d613 1
a613 1
      return;
d624 1
a624 1
      return;
d633 1
d658 2
a659 1
static void
d666 1
a666 1
      return;
d681 1
a681 1
  track_down (papp, (char *) ".exe", 0);
d1596 1
d1684 1
a1684 1
	cygcheck (argv[i]);
d1700 1
a1700 1
  return 0;
@


1.73
log
@* cygcheck.cc (load_cygwin): Make half-hearted attempt to work with older DLLs.
* strace.cc (load_cygwin): Ditto.
@
text
@d47 1
a47 1
static const char version[] = "$Revision: 1.72 $";
d1020 1
a1020 2
		       || osversionex.wProductType ==
		       VER_NT_DOMAIN_CONTROLLER)
d1022 1
a1022 1
		  if (osversionex.wSuiteMask &VER_SUITE_DATACENTER)
d1032 1
a1032 1
	  else
d1034 5
a1038 1
	      if (!more_info)
a1039 9
	      else if (osversionex.wProductType == VER_NT_SERVER
		       || osversionex.wProductType ==
		       VER_NT_DOMAIN_CONTROLLER)
		{
		  if (osversionex.wSuiteMask & VER_SUITE_ENTERPRISE)
		    osname = (char *) ".NET Enterprise Server";
		  else
		    osname = (char *) ".NET Server";
		}
d1041 1
a1041 1
		osname = (char *) "XP Home Edition";
d1043 14
a1056 2
		osname = (char *) "XP Professional";

d1072 2
@


1.72
log
@	* cygcheck.cc (dump_sysinfo_services): Add new function that uses
	new cygrunsrv options to dump service info.
	(dump_sysinfo): Call dump_sysinfo_services if running under NT.
	Change 'Cygnus' to 'Cygwin' in output.
@
text
@d47 1
a47 1
static const char version[] = "$Revision: 1.71 $";
d163 1
a163 1
  
d167 2
a168 2
    display_error ("init_paths: GetCurrentDirectory()");  
  
d881 1
a881 1
  
d883 2
a884 2
    printf ("\nChecking for any Cygwin services... %s\n\n", 
                  verbose ? "" : "(use -v for more detail)");
d887 1
a887 1
  
d889 1
a889 1
  char *cygrunsrv = cygpath ("/bin/cygrunsrv.exe", NULL);  
d898 1
a898 1
  
d901 1
a901 1
  if ((f = popen (buf, "rt")) == NULL)    
d914 1
a914 1
  
d924 1
a924 1
  
d931 2
a932 3
  
  
  /* In verbose mode, just run 'cygrunsrv --list --verbose' and copy the 
d937 1
a937 1
        snprintf (buf2, sizeof (buf2), "%s --list --verbose", cygrunsrv);
d939 1
a939 1
        snprintf (buf2, sizeof (buf2), "%s --query %s", cygrunsrv, srv);
d941 5
a945 5
        {
          printf ("Failed to execute '%s', skipping services check.\n", buf2);
          return;
        }
        
d948 4
a951 4
        {
          nchars = fread ((void *)buf2, 1, sizeof (buf2), f);
          fwrite ((void *)buf2, 1, nchars, stdout);
        }
d954 1
a954 1
      
d956 1
a956 1
        break;
d1554 1
a1554 1
  if (av)
d1557 1
a1557 1
	      
d1559 1
a1559 1
  if (envp)
d1562 1
a1562 1
         by the POSIXy Cygwin variation, which breaks cygcheck.
d1572 1
a1572 1
        }
@


1.71
log
@* cygcheck.cc (load_cygwin): Remove debugging statement.
@
text
@d47 1
a47 1
static const char version[] = "$Revision: 1.70 $";
d873 88
d968 1
d1008 1
d1341 1
a1341 1
    printf ("Looking for various Cygnus DLLs...  (-v gives version info)\n");
d1381 3
@


1.70
log
@* cygcheck.cc (dump_sysinfo): Don't attempt to use path if it is not set.
(nuke): Fix off by one error in allocation of environment variable.
(load_cygwin): Always set PATH even if cygwin environment is empty.
@
text
@d47 1
a47 1
static const char version[] = "$Revision: 1.69 $";
a1468 1
      cygwin_internal (CW_DEBUG_SELF, "d:\\cygwin\\bin\\gdb.exe");
@


1.69
log
@* cygcheck.cc (cygwin_internal): Define as a "C" function.
* strace.cc (cygwin_internal): Ditto.
* cygpath.cc (print_version): Update copyright.
@
text
@d47 1
a47 1
static const char version[] = "$Revision: 1.68 $";
d980 18
a997 13
  char sep = strchr (s, ';') ? ';' : ':';
  int count_path_items = 0;
  while (1)
    {
      for (e = s; *e && *e != sep; e++);
      if (e-s)
	printf ("\t%.*s\n", e - s, s);
      else
	puts ("\t.");
      count_path_items++;
      if (!*e)
	break;
      s = e + 1;
d1440 2
a1441 2
  int n = 1 + strchr (*_environ, '=') - ev;
  char *s = (char *) alloca (n);
d1469 1
d1475 2
a1476 1
      while (*_environ)
d1478 3
a1480 3
	  if (strncmp (*_environ, "PATH=", 5) == 0)
	    path = strdup (*_environ);
	  nuke (*_environ);
d1485 2
a1486 2
	else if (path)
	  putenv (path);
@


1.68
log
@* cygcheck.cc (load_cygwin): Avoid calling putenv with a NULL path.
@
text
@d47 1
a47 1
static const char version[] = "$Revision: 1.67 $";
d1442 3
a1444 1
DWORD (*cygwin_internal) (int, ...);
@


1.67
log
@	* cygcheck.cc (load_cygwin): Don't touch $PATH for now.
	(print_version): Fix copyright.
	* strace.cc (print_version): Ditto.
@
text
@d47 1
a47 1
static const char version[] = "$Revision: 1.66 $";
d1469 1
a1469 1
	  if (!strncmp (*_environ, "PATH=", 5))
d1474 4
a1477 1
	putenv (!strncmp (*ev, "PATH=", 5) ? path : *ev);
@


1.66
log
@* cygcheck.cc (nuke): New function.
(load_cygwin): New function.
(main): Use load_cygwin to load argv/envp from cygwin environment, if
appropriate.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
d47 1
a47 1
static const char version[] = "$Revision: 1.65 $";
d1427 1
a1427 1
Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.\n\
d1462 5
d1468 5
a1472 1
	nuke (*_environ);
d1474 1
a1474 1
	putenv (*ev);
@


1.65
log
@	* cygcheck.cc (init_paths): Use full path instead of "." for the
	current directory.  Do not add "." if present in $PATH.
	(dump_sysinfo): Skip placeholder first value of paths[].
@
text
@d11 1
d23 1
d47 1
a47 1
static const char version[] = "$Revision: 1.64 $";
d1432 37
d1473 1
@


1.64
log
@* cygcheck.cc (eprintf): New function.
@
text
@d45 1
a45 1
static const char version[] = "$Revision: 1.63 $";
d161 6
a166 1
  add_path ((char *) ".", 1);	/* the current directory */
d188 2
a189 1
	  add_path (b, e - b);
d1246 1
a1246 1
  for (i = 0; i < num_paths; i++)
@


1.63
log
@* cygcheck.cc (find_on_path): Clear show_error and/or print_failed
parameters to display_error.
(rva_to_offset): Ditto.
(dll_info): Ditto.
(track_down): Ditto.
@
text
@d45 1
a45 1
static const char version[] = "$Revision: 1.62 $";
d101 9
@


1.62
log
@* cygcheck.cc: Change "keyeprint" to "display_error" throughout.
@
text
@d45 1
a45 1
static const char version[] = "$Revision: 1.61 $";
d193 1
a193 1
      display_error ("find_on_path: NULL pointer for file");
d199 1
a199 1
      display_error ("find_on_path: NULL pointer for default_extension");
d308 1
a308 1
      display_error ("rva_to_offset: NULL passed for sections");
d440 1
a440 1
      display_error ("dll_info: NULL passed for path");
d545 1
a545 1
      display_error ("track_down: NULL passed for file");
d551 1
a551 1
      display_error ("track_down: NULL passed for suffix");
@


1.61
log
@* cygcheck.cc (main): Allow a '-l' without an additional argument.
@
text
@d45 1
a45 1
static const char version[] = "$Revision: 1.60 $";
d102 1
a102 1
 * keyeprint() is used to report failure modes
d105 1
a105 1
keyeprint (const char *name, bool show_error = true, bool print_failed = true)
d130 1
a130 1
      keyeprint ("add_path: malloc()");
d156 1
a156 1
    keyeprint ("init_paths: GetSystemDirectory()");
d193 1
a193 1
      keyeprint ("find_on_path: NULL pointer for file");
d199 1
a199 1
      keyeprint ("find_on_path: NULL pointer for default_extension");
d268 1
a268 1
    keyeprint ("get_word: SetFilePointer()");
d271 1
a271 1
    keyeprint ("get_word: Readfile()");
d284 1
a284 1
    keyeprint ("get_dword: SetFilePointer()");
d287 1
a287 1
    keyeprint ("get_dword: Readfile()");
d308 1
a308 1
      keyeprint ("rva_to_offset: NULL passed for sections");
d367 1
a367 1
      keyeprint ("cygwin_info: calloc()");
d440 1
a440 1
      keyeprint ("dll_info: NULL passed for path");
d446 1
a446 1
    keyeprint ("dll_info: SetFilePointer()");
d449 1
a449 1
    keyeprint ("dll_info: Readfile()");
d470 1
a470 1
    keyeprint ("dll_info: SetFilePointer()");
d473 1
a473 1
    keyeprint ("dll_info: Readfile()");
d484 1
a484 1
	    keyeprint ("dll_info: SetFilePointer()");
d489 1
a489 1
	    keyeprint ("dll_info: Readfile()");
d515 1
a515 1
	    keyeprint ("dll_info: SetFilePointer()");
d520 1
a520 1
	      keyeprint ("dll_info: malloc()");
d525 1
a525 1
	    keyeprint ("dll_info: Readfile()");
d545 1
a545 1
      keyeprint ("track_down: NULL passed for file");
d551 1
a551 1
      keyeprint ("track_down: NULL passed for suffix");
d614 1
a614 1
    keyeprint ("track_down: CloseHandle()");
d625 1
a625 1
    keyeprint ("ls: GetFileInformationByHandle()");
d630 1
a630 1
    keyeprint ("ls: FileTimeToSystemTime()");
d636 1
a636 1
    keyeprint ("ls: CloseHandle()");
d721 1
a721 1
	  keyeprint ("scan_registry: malloc()");
d728 1
a728 1
	  keyeprint ("scan_registry: malloc()");
d772 1
a772 1
		keyeprint ("scan_registry: RegCloseKey()");
d871 1
a871 1
    keyeprint ("dump_sysinfo: GetVersionEx()");
d993 1
a993 1
    keyeprint ("dump_sysinfo: GetSystemDirectory()");
d1097 1
a1097 1
	keyeprint ("dump_sysinfo: GetVolumeInformation()");
d1164 1
a1164 1
    keyeprint ("dump_sysinfo: FreeLibrary()");
d1279 1
a1279 1
    return (keyeprint ("check_keys: Opening CONIN$"));
d1284 1
a1284 1
    keyeprint ("check_keys: GetConsoleMode()");
d1289 1
a1289 1
	keyeprint ("check_keys: SetConsoleMode()");
d1308 1
a1308 1
	keyeprint ("check_keys: ReadConsoleInput()");
@


1.60
log
@* cygcheck.cc (keyeprint): New optional parameters: show_error and
print_failed.
@
text
@d45 1
a45 1
static const char version[] = "$Revision: 1.59 $";
d1460 1
a1460 1
  if (argc == 0 && !sysinfo && !keycheck && !check_setup)
d1495 1
a1495 3
    {
      dump_setup (verbose, argv, !dump_only);
    }
d1497 1
a1497 3
    {
      package_find (verbose, argv);
    }
d1499 1
a1499 3
    {
      package_list (verbose, argv);
    }
@


1.59
log
@* cygcheck.cc (get_dword): Fix errormessage.
(cygwin_info): Ditto.
(track_down): Ditto.
(check_keys): Ditto.
@
text
@d45 1
a45 1
static const char version[] = "$Revision: 1.58 $";
d105 1
a105 1
keyeprint (const char *name)
d107 6
a112 1
  fprintf (stderr, "cygcheck: %s failed: %lu\n", name, GetLastError ());
@


1.58
log
@* cygcheck.cc (dump_sysinfo): Warn about missing or multiple cygwin1
dlls.
@
text
@d45 1
a45 1
static const char version[] = "$Revision: 1.57 $";
d279 1
a279 1
    keyeprint ("get_word: SetFilePointer()");
d362 1
a362 1
      keyeprint ("cygwin_info: malloc()");
d540 1
a540 1
      keyeprint ("track_down: malloc()");
d546 1
a546 1
      keyeprint ("track_down: malloc()");
d1274 1
a1274 1
    return (keyeprint ("check_key: Opening CONIN$"));
d1284 1
a1284 1
	keyeprint ("check_keys: GetConsoleMode()");
d1303 1
a1303 1
	keyeprint ("ReadConsoleInput");
@


1.57
log
@* cygcheck.cc (dump_sysinfo): Add leading newline before legend for
drive-list.
@
text
@d45 1
a45 1
static const char version[] = "$Revision: 1.56 $";
d1225 1
d1242 4
a1245 1
		    found_cygwin_dll = strdup (tmp);
d1260 4
@


1.56
log
@fix whitespace, update some copyrights
@
text
@d45 1
a45 1
static const char version[] = "$Revision: 1.55 $";
d1163 1
a1163 1
      puts (
@


1.55
log
@* cygcheck.cc (dump_sysinfo): In legend for drive-list: Add ``ram'' and
``unk''. Use single puts. Add leading newline. Line up equal-signs.
@
text
@d45 1
a45 1
static const char version[] = "$Revision: 1.54 $";
d1086 3
a1088 3
      /* Report all errors, except if the Volume is ERROR_NOT_READY. 
         ERROR_NOT_READY is returned when removeable media drives are empty
         (CD, floppy, etc.) */
@


1.54
log
@* cygcheck.cc (dump_sysinfo): Allow for larger drives in drive-list.  Change
``Used'' to ``Free'' in helptext-title for drive-list.
@
text
@d45 1
a45 1
static const char version[] = "$Revision: 1.53 $";
d1163 5
a1167 4
      printf ("fd=floppy, hd=hard drive, cd=CD-ROM, net=Network Share\n");
      printf ("CP=Case Preserving, CS=Case Sensitive, UN=Unicode\n");
      printf
	("PA=Persistent ACLS, FC=File Compression, VC=Volume Compression\n");
@


1.53
log
@	* cygcheck.cc (pretty_id): Don't let i become negative. Fix
	printf-format.
@
text
@d45 1
a45 1
static const char version[] = "$Revision: 1.52 $";
d1067 1
a1067 1
      printf ("Drv Type        Size   Free Flags              Name\n");
d1138 1
a1138 1
	printf ("%5dMb %3d%% ", (int) capacity_mb, (int) percent_full);
d1140 1
a1140 1
	printf ("  N/A    N/A ");
@


1.52
log
@* cygcheck.cc (pretty_id): Allocate space for ')' in uid and guid.
@
text
@d45 1
a45 1
static const char version[] = "$Revision: 1.51 $";
d839 1
a839 1
  int i = n ? n - 2 : 0;
d843 1
a843 1
      printf ("%*s ", sz, *g);
@


1.51
log
@* cygcheck.cc (pretty_id): Allocate space for trailing '\0' on uid and guid.
@
text
@d45 1
a45 1
static const char version[] = "$Revision: 1.50 $";
d817 2
a818 2
  size_t len_uid = strlen ("UID: ") + strlen (uid);
  size_t len_gid = strlen ("GID: ") + strlen (gid);
@


1.50
log
@* cygcheck.cc (pretty_id): Don't exit on id error.  Fix size calculations.
@
text
@d45 1
a45 1
static const char version[] = "$Revision: 1.49 $";
d817 4
a820 4
  size_t len_uid = strlen (uid);
  size_t len_gid = strlen (gid);
  *++ng = groups[0] = (char *) alloca (len_uid += sizeof ("UID: )") - 1);
  *++ng = groups[1] = (char *) alloca (len_gid += sizeof ("GID: )") - 1);
@


1.49
log
@* cygcheck.cc (pretty_id): Correct column calculations.  Abort if id is acting
funny.
@
text
@d45 1
a45 1
static const char version[] = "$Revision: 1.48 $";
d805 1
a805 1
      exit (1);
d813 1
a813 1
      exit (1);
d819 2
a820 2
  *++ng = groups[0] = (char *) alloca (len_uid += sizeof ("UID: )"));
  *++ng = groups[1] = (char *) alloca (len_uid += sizeof ("GID: )"));
d835 1
d838 5
a842 5
  int n = 80 / (int) sz;
  sz = -(sz + 1);
  int i = n - 2;
  for (char **g = groups; g < ng; g++)
    if ((g != ng - 1) && (++i < n))
@


1.48
log
@* cygcheck.cc (add_path): Don't leak memory when path is already in ``paths''.
@
text
@d23 2
d45 1
a45 1
static const char version[] = "$Revision: 1.47 $";
a795 1
  static char empty[] = "";
d803 4
a806 1
    uid = empty;
d811 14
a824 4
    gid = empty;
  char **ng;
  size_t sz = 0;
  for (ng = groups; (*ng = strtok (NULL, ",")); ng++)
d829 1
a829 1
      if (ng == groups)
a836 4
  size_t szmaybe = strlen ("UID: ") + strlen (uid);
  if (sz < szmaybe)
    sz = szmaybe;
  sz += 1;
d838 2
a839 4
  sz = -sz;
  ng[0] += strlen ("groups=");
  printf ("UID: %.*s) GID: %s)\n", sz + (sizeof ("UID: ") - 1), uid, gid);
  int i = 0;
d841 7
a847 16
    {
      if (i < n)
	i++;
      else
	{
	  i = 0;
	  puts ("");
	}
      if (++i <= n && g != (ng - 1))
	printf ("%*s ", sz, *g);
      else
	{
	  printf ("%s\n", *g);
	  i = 0;
	}
    }
@


1.47
log
@* cygcheck.cc (dump_sysinfo): Warn about trailing (back)slash on mount entries.
@
text
@d43 1
a43 1
static const char version[] = "$Revision: 1.46 $";
d133 4
a136 1
      return;
@


1.46
log
@* cygcheck.cc (dump_sysinfo): Don't warn about empty path components, just
display ``.''.
@
text
@d43 1
a43 1
static const char version[] = "$Revision: 1.45 $";
d1168 1
d1175 1
d1179 1
d1184 3
@


1.45
log
@	* cygcheck.cc (dump_sysinfo): Warn about empty path-components.
@
text
@d43 1
a43 1
static const char version[] = "$Revision: 1.44 $";
d961 1
a961 1
        printf ("\t%.*s\n", e - s, s);
d963 1
a963 1
        puts ("\tWarning: Empty path-component");
@


1.44
log
@	* cygcheck.cc (pretty_id): Close pipe.
@
text
@d43 1
a43 1
static const char version[] = "$Revision: 1.43 $";
d960 4
a963 1
      printf ("\t%.*s\n", e - s, s);
@


1.43
log
@* cygcheck.cc (dump_sysinfo): Remove "Win95/NT" from output.
@
text
@d43 1
a43 1
static const char version[] = "$Revision: 1.42 $";
d794 1
@


1.42
log
@* strace.cc: Update copyrights.
* cygcheck.cc: Update copyrights.
@
text
@d43 1
a43 1
static const char version[] = "$Revision: 1.41 $";
d855 1
a855 1
  printf ("\nCygwin Win95/NT Configuration Diagnostics\n");
@


1.41
log
@* strace.cc (main): Ensure POSIXLY_CORRECT argument ordering.
* cygcheck.cc (main): Ditto.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
d43 1
a43 1
static const char version[] = "$Revision: 1.40 $";
d1383 1
a1383 1
Copyright 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.\n\
@


1.40
log
@* cygcheck.cc (pretty_id): Make more robust in absence of id.exe.
@
text
@d43 1
a43 1
static const char version[] = "$Revision: 1.39 $";
d1393 1
@


1.39
log
@* cygcheck.cc (pretty_id): Don't exec if `id' program is not found.
@
text
@d43 1
a43 1
static const char version[] = "$Revision: 1.38 $";
d783 4
a786 1
    fprintf (stderr, "`id' program not found\n");
d791 2
d794 10
a803 2
  char *uid = strtok (buf, ")") + strlen ("uid=");
  char *gid = strtok (NULL, ")") + strlen ("gid=") + 1;
@


1.38
log
@	* cygcheck.cc (dump_only): New global variable.
	(usage): Add "--dump-only" option, fix "--verbose" line.
	(longopts, opts): Add "--dump-only" option.
	(main): Process the "--dump-only" flag.  Add new semantic check.
	Pass dump_only information to dump_setup().
@
text
@d43 1
a43 1
static const char version[] = "$Revision: 1.37 $";
d783 1
a783 4
    {
      fprintf (stderr, "`id' program not found\n");
      exit (1);
    }
@


1.37
log
@* Makefile.in (cygcheck.o): Use MINGW_CXX for compilation.
* cygcheck.cc: Just include <getopt.h> rather than cygwin version.
(pretty_id): Avoid compiler warnings.
* cygpath.cc (usage): Ditto.
@
text
@d29 1
d43 1
a43 1
static const char version[] = "$Revision: 1.36 $";
d1326 1
d1328 1
a1328 1
 -v, --verbose       verbose output (indented) (for -s or programs)\n\
d1341 1
d1353 1
a1353 1
static char opts[] = "cfhklrsvV";
d1392 3
d1434 3
d1458 1
a1458 1
      dump_setup (verbose, argv, true);
@


1.36
log
@	* cygcheck.cc (main): Fix some formatting and help text printing.

	* cygcheck.cc (find_package,list_package): New global
	variables.
	(usage): Add "--find-package" and "--list-package" options,
	reformat output.
	(longopts, opts): Add "--find-package" and "--list-package"
	options.
	(main): Process the "--find-package" and "--list-package"
	flags.  Add new semantic checks.  Add calls to find_package()
	and list_package().
	* dump_setup.cc: Fix header comment.
	(match_argv): Change return type to int to distinguish
	between real matches and default ones.
	(open_package_list): New static function.
	(check_package_files): Factor out opening the package list
	file into open_package_list().
	(get_packages): New static function.
	(dump_setup): Factor out getting a list of packages into
	get_packages().
	(package_list, package_find): New global functions.
@
text
@d19 1
a21 1
#include "cygwin/include/getopt.h"
d42 1
a42 1
static const char version[] = "$Revision: 1.35 $";
d778 1
a778 1
  for (char *p = id; p = strchr (p, '/'); p++)
d808 1
a808 1
  int szmaybe = strlen ("UID: ") + strlen (uid);
@


1.35
log
@* cygcheck.cc (pretty_id): Rework slightly to not rely on spaces.
@
text
@d29 2
d39 2
d42 1
a42 1
static const char version[] = "$Revision: 1.34 $";
d1324 9
a1332 7
 -c, --check-setup  check packages installed via setup.exe\n\
 -s, --sysinfo      system information (not with -k)\n\
 -v, --verbose      verbose output (indented) (for -s or programs)\n\
 -r, --registry     registry search (requires -s)\n\
 -k, --keycheck     perform a keyboard check session (not with -s)\n\
 -h, --help         give help about the info (not with -c)\n\
 -V, --version      output version information and exit\n\
d1343 2
d1350 1
a1350 1
static char opts[] = "chkrsvV";
d1398 6
d1422 7
a1428 1
  if ((check_setup || sysinfo) && keycheck)
d1436 2
a1437 2
  /* FIXME: Add help for check_setup */
  if (argc >= 1 && givehelp && !check_setup)
d1439 3
a1441 12
      if (argc == 1)
	{
	  printf
	    ("Here is where the OS will find your program, and which dlls\n");
	  printf ("will be used for it.  Use -v to see DLL version info\n");
	}
      else
	{
	  printf
	    ("Here is where the OS will find your programs, and which dlls\n");
	  printf ("will be used for them.  Use -v to see DLL version info\n");
	}
d1450 8
a1457 1
      puts ("");
d1462 2
a1464 1
	puts ("");
a1473 1
	  puts ("");
d1475 3
a1478 3

  if (!givehelp)
    puts ("Use -h to see help about each section");
@


1.34
log
@* cygcheck.cc (usage) Add description output.
@
text
@d38 1
a38 1
static const char version[] = "$Revision: 1.33 $";
d787 2
a788 2
  char *uid = strtok (buf, " ") + sizeof ("uid=") - 1;
  char *gid = strtok (NULL, " ") + sizeof ("gid=") - 1;
d797 1
a797 1
	*ng += sizeof ("groups=") - 1;
d803 2
a804 2
  printf ("\n%s output (%s)\n", id, s);
  int szmaybe = sizeof ("UID: ") + strlen (uid) - 1;
d810 2
a811 2
  ng[0] += sizeof ("groups=") - 1;
  printf ("UID: %*s GID: %s\n", sz + (sizeof ("UID: ") - 1), uid, gid);
@


1.33
log
@* cygcheck.cc (dump_sysinfo): Ensure that CYGWIN environment variable is
correctly set.
@
text
@d38 1
a38 1
static const char version[] = "$Revision: 1.32 $";
d1317 3
a1319 1
Usage: cygcheck [OPTIONS] [program ...]\n\
@


1.32
log
@* Makefile.in (strace.exe): Include mingw_getopt.o in link line.
* cygcheck.cc (print_version): Update copyright.
* strace.cc (print_version): Ditto.
(main): Allow cygwin paths for -o option.
(create_child): Allow cygwin path as argv[0].
* path.cc (path.cc): Allow UNC paths.
@
text
@d38 1
a38 1
static const char version[] = "$Revision: 1.31 $";
d953 5
a957 1
  char *cygwin = getenv ("CYGWIN") ?: const_cast <char *> ("CYGWIN=");
@


1.31
log
@* Makefile.in (cygcheck.o): Fix so that actual mingw include files are used.
* cygcheck.cc (find_on_path): Translate from cygwin path when qualified path
name found.
(pretty_id): New function.  Dump output of id command.
(dump_sysinfo): Call pretty_id for CYGWIN=ntsec and CYGWIN=nontsec cases.
@
text
@d38 1
a38 1
static const char version[] = "$Revision: 1.30 $";
d1356 1
a1356 1
Copyright 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.\n\
@


1.30
log
@* cygcheck.cc (common_apps): Add some more apps.
* path.cc (get_cygdrive): Correctly set system flag.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d16 1
d18 1
d38 1
a38 1
static const char version[] = "$Revision: 1.29 $";
d176 1
a176 1
  if (file == NULL)
d189 1
a189 1
    return file;
d764 68
d950 10
@


1.29
log
@* cygcheck.cc: Include sys/time.h rather than time.h to avoid a compiler error.
@
text
@d36 1
a36 1
static const char version[] = "$Revision: 1.28 $";
d69 1
d72 1
d77 1
d81 3
d85 1
@


1.28
log
@* cygcheck.cc: Reorder includes to avoid compiler error.
@
text
@d14 1
a14 1
#include <time.h>
d36 1
a36 1
static const char version[] = "$Revision: 1.27 $";
@


1.27
log
@Add final newlines to utils
@
text
@d14 2
a19 2
#include "time.h"
#include "ctype.h"
d36 1
a36 1
static const char version[] = "$Revision: 1.26 $";
@


1.26
log
@* cygcheck.cc: Reformat.
@
text
@d36 1
a36 1
static const char version[] = "$Revision: 1.25 $";
d1270 2
a1271 1
Compiled on %s", len, v, __DATE__);
@


1.25
log
@* cygcheck.cc (longopts): Use correct short option for --version.
@
text
@d36 1
a36 1
static const char version[] = "$Revision: 1.24 $";
d68 1
a68 2
static common_apps[] =
{
d246 1
a246 1
  if (!ReadFile (fh, &rv, 2, (DWORD *) & r, 0))
d262 1
a262 1
  if (!ReadFile (fh, &rv, 4, (DWORD *) & r, 0))
d384 2
a385 1
	    sprintf (pbuf, "DLL version: %d.%d.%.*s", maj, min, len - 11, buf + 11);
d420 2
a421 2
  if (SetFilePointer (fh, opthdr_ofs + 40, 0, FILE_BEGIN) == INVALID_SET_FILE_POINTER
      && GetLastError () != NO_ERROR)
d458 2
a459 2
	  if (SetFilePointer (fh, expbase, 0, FILE_BEGIN) == INVALID_SET_FILE_POINTER
	      && GetLastError () != NO_ERROR)
d489 2
a490 2
	  if (SetFilePointer (fh, impbase, 0, FILE_BEGIN) == INVALID_SET_FILE_POINTER
	      && GetLastError () != NO_ERROR)
d781 1
a781 1
	  if (strchr(osversion.szCSDVersion, 'C'))
d787 1
a787 1
	  if (strchr(osversion.szCSDVersion, 'A'))
d806 1
a806 1
	  if (GetVersionEx ((OSVERSIONINFO *)&osversionex))
d813 4
a816 3
		       || osversionex.wProductType == VER_NT_DOMAIN_CONTROLLER)
	        {
		  if (osversionex.wSuiteMask & VER_SUITE_DATACENTER)
d822 1
a822 1
	        }
d824 1
a824 1
	        osname = (char *) "2000 Professional";
d831 3
a833 2
		       || osversionex.wProductType == VER_NT_DOMAIN_CONTROLLER)
	        {
d840 1
a840 1
	        osname = (char *) "XP Home Edition";
d842 2
a843 2
	        osname = (char *) "XP Professional";
		
d845 1
a845 1
        }
d856 1
a856 1
	    osversion.dwBuildNumber : (osversion.dwBuildNumber & 0xffff),
d858 1
a858 1
	    osversion.szCSDVersion : "");
d975 4
a978 4
	 (CD, floppy, etc.) */
      if (!GetVolumeInformation (drive, name, sizeof (name), &serno, &maxnamelen, &flags,
				 fsname, sizeof (fsname))
	  && GetLastError () != ERROR_NOT_READY)
d1223 1
a1223 1
usage (FILE *stream, int status)
d1301 1
a1301 1
        exit (0);
d1309 4
a1312 4
     if (givehelp)
	usage (stdout, 0);
     else
	usage (stderr, 1);
@


1.24
log
@* cygcheck.cc (main): Eliminate non-GNU formatting glitch.
@
text
@d36 1
a36 1
static const char version[] = "$Revision: 1.23 $";
d1243 1
a1243 1
  {"version", no_argument, 0, 'z'},
@


1.23
log
@* ssp.c (help_desk): Fix compiler warning.  Christopher Faylor <cgf@@redhat.com>
Change appropriate globals to statics throughout.
* cygcheck.cc (usage): Simplify usage output.  Generalize to allow use for
help.
(longopts): Add version option.
(opts): Add 'V" version option.
(print_version): New function.
(main): Accommodate new version option.  Accommodate usage parameter changes.
Use usage to output help message.
* Makefile.in (CXXFLAGS): Add override so that HAVE_DECL_GETOPT is defined.
(libbfd): Use -B rather than -L so that bfd from build directory is correctly
found.
(libintl): Ditto.
@
text
@d36 1
a36 1
static const char version[] = "$Revision$";
d1306 1
a1306 1
  if (argc == 0 && !sysinfo && !keycheck && !check_setup) {
a1310 1
     }
@


1.22
log
@* cygcheck.cc: Fix typo.  Remove uid_t kludge.  Rely on kludge in sys/cygwin.h
instead.
* getfacl.c: Add include to remove warning.
* mkgroup.c (main): Assign variables outside of parameter passing.  This seems
to eliminate some compiler warnings.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001 Red Hat, Inc.
d36 3
a38 1
const char *known_env_vars[] = {
d68 1
a68 1
common_apps[] =
d83 2
a84 2
int num_paths = 0, max_paths = 0;
char **paths = 0;
d89 1
a89 1
int
d96 1
a96 1
void
d124 1
a124 1
void
d161 1
a161 1
char *
d220 1
a220 1
Did *did = 0;
d222 1
a222 1
Did *
d237 1
a237 1
int
d253 1
a253 1
int
d278 1
a278 1
int
d327 1
a327 1
void track_down (char *file, char *suffix, int lvl);
d405 1
a405 1
void
d516 1
a516 1
void
d593 1
a593 1
void
d615 1
a615 1
void
d650 1
a650 1
void
d662 1
a662 1
void
d755 1
a755 1
void
d1136 1
a1136 1
int
d1220 2
a1221 2
void
usage ()
d1223 11
a1233 9
  fprintf (stderr, "Usage: cygcheck [OPTIONS] [program ...]\n");
  fprintf (stderr, "  -c, --check-setup = check packages installed via setup.exe\n");
  fprintf (stderr, "  -s, --sysinfo     = system information (not with -k)\n");
  fprintf (stderr, "  -v, --verbose     = verbose output (indented) (for -s or programs)\n");
  fprintf (stderr, "  -r, --registry    = registry search (requires -s)\n");
  fprintf (stderr, "  -k, --keycheck    = perform a keyboard check session (not with -s)\n");
  fprintf (stderr, "  -h, --help        = give help about the info (not with -c)\n");
  fprintf (stderr, "You must at least give either -s or -k or a program name\n");
  exit (1);
d1243 1
d1247 23
a1269 1
char opts[] = "srvkhc";
d1297 3
d1301 1
a1301 1
	usage ();
d1306 6
a1311 2
  if (argc == 0 && !sysinfo && !keycheck && !check_setup)
    usage ();
d1314 1
a1314 1
    usage ();
@


1.21
log
@* cygcheck.cc: Use specific cygwin includes, as required.
@
text
@a10 2
typedef unsigned short uid_t;
typedef unsigned short gid_t;
d15 1
a15 1
#include "cygwin/include/sys/cygwin.h>
a16 1
#include "cygwin/include/time.h"
d18 2
a19 1
#include "cygwin/include/ctype.h"
@


1.20
log
@* Makefile.in: Build intermediate cygcheck.o to force use of MINGW_CXXFLAGS.
* cygcheck.cc (cygwin_info): Intitialize variable to quiet g++ warning.
(dump_sysinfo): Make variables unsigned to quiet g++ warnings.
* strace.cc (version_string): Rename from SCCSid.
(add_child): Remove unused variable.
(version): Use version_string.  Avoid use of fprintf.
@
text
@d17 5
a21 5
#include <sys/cygwin.h>
#include <mntent.h>
#include <time.h>
#include <getopt.h>
#include <ctype.h>
@


1.19
log
@* cygcheck.cc (already_did): Avoid default constructors, which may require
exception support.
@
text
@d355 2
a356 1
  char *dll_major;
d1055 1
a1055 1
  unsigned int ml_fsname = 4, ml_dir = 7, ml_type = 6;
d1061 1
a1061 1
      int n = (int) strlen (mnt->mnt_fsname);
@


1.18
log
@* Makefile.in: Add define to CXXFLAGS.
@
text
@d229 1
a229 1
  d = new Did;
@


1.17
log
@* cygcheck.cc (usage): Add -c description.
* cygpath.cc (usage): Alphabetize options.
* strace.cc (usage): Ditto.
@
text
@d762 1
a762 1
  printf ("\nCygnus Win95/NT Configuration Diagnostics\n");
@


1.16
log
@        * cygcheck.cc (dump_sysinfo): Redefine output format slightly.
@
text
@d1223 7
a1229 9
  fprintf (stderr, "  -s, --sysinfo  = system information (not with -k)\n");
  fprintf (stderr,
	   "  -v, --verbose  = verbose output (indented) (for -s or programs)\n");
  fprintf (stderr, "  -r, --registry = registry search (requires -s)\n");
  fprintf (stderr,
	   "  -k, --keycheck = perform a keyboard check session (not with -s)\n");
  fprintf (stderr, "  -h, --help     = give help about the info\n");
  fprintf (stderr,
	   "You must at least give either -s or -k or a program name\n");
@


1.15
log
@* cygcheck.cc (main): Slight formatting tweak.
@
text
@d850 6
a855 3
  printf ("Windows %s Ver %d.%d build %d %s\n\n", osname,
	  (int) osversion.dwMajorVersion, (int) osversion.dwMinorVersion,
	  (int) osversion.dwBuildNumber, osversion.szCSDVersion);
@


1.14
log
@        * cygcheck.cc (dump_sysinfo): Add some more details.
@
text
@d3 1
a3 1
   Copyright 1998 Cygnus Solutions.
d1324 1
@


1.13
log
@	* cygcheck.cc (dump_sysinfo): Print more detailed OS information string
	using OSVERSIONINFOEX information.
@
text
@d811 10
a820 2
	      else if (osversionex.wProductType == VER_NT_SERVER)
	        osname = (char *) "2000 Server";
d828 8
a835 2
	      else if (osversionex.wProductType == VER_NT_SERVER)
		osname = (char *) ".NET Server";
@


1.12
log
@* cygcheck.cc (scan_registry): Open registry with read-only access.
(main): Reflect argument change for dump_setup.
* dump_setup.cc (dump_setup): Add preliminary extra argument for future use.
* path.cc (read_mounts): Open registry with read-only access.
@
text
@d774 1
a774 1
      osname = (char *) "win32s";
d781 1
a781 1
	    osname = (char *) "Win95OSR2";
d783 1
a783 1
	    osname = (char *) "Win95";
d787 1
a787 1
	    osname = (char *) "Win98SE";
d789 1
a789 1
	    osname = (char *) "Win98";
d792 1
a792 1
	  osname = (char *) "WinME";
d795 1
a795 1
	  osname = (char *) "Win9X";
d802 5
d808 8
a815 1
	    osname = (char *) "Win2000";
d817 11
a827 1
	    osname = (char *) "WinXP";
d830 1
a830 1
	osname = (char *) "WinNT";
d833 1
a833 1
      osname = (char *) "uknown-os";
d836 1
a836 1
  printf ("%s Ver %d.%d build %d %s\n\n", osname,
@


1.11
log
@* cygcheck.cc (main): Display package info when '-s' is specified.
* dump_setup.cc (dump_setup): Change header.  Remove typo.  Always sort
packages output.
@
text
@d36 1
a36 1
void dump_setup (int, char **);
d742 1
a742 1
	  if (RegOpenKeyEx (hKey, subkey_name, 0, KEY_ALL_ACCESS, &sKey)
d1273 1
a1273 1
      dump_setup (verbose, argv);
d1288 1
a1288 1
	  dump_setup (verbose, NULL);
d1294 1
a1294 1
    printf ("Use -h to see help about each section\n");
@


1.10
log
@* dump_setup.cc: New file.
* Makefile.in: Add info for dump_setup.o.
* cygcheck.cc (main): Recognize '-c' option for checking setup installed base.
* path.cc (cygpath): Read mount table if not loaded.
@
text
@d1284 8
a1291 1
    dump_sysinfo ();
@


1.9
log
@* Makefile.in (cygcheck.exe): Compile as -mno-cygwin executable.
* path.cc: New file.
* cygcheck.cc (init_paths): Use MS-DOS path syntax.
(cygwin_info): Properly display cygwin version numbers.  Prettify some output.
(dump_sysinfo): Calculate max names of posix and ms-dos paths for prettier
output.
@
text
@d28 1
d36 2
d1197 1
d1206 1
a1206 1
char opts[] = "srvkh";
d1219 3
d1240 1
a1240 1
  if (argc == 0 && !sysinfo && !keycheck)
d1243 1
a1243 1
  if (sysinfo && keycheck)
d1251 2
a1252 1
  if (argc >= 1 && givehelp)
d1271 1
a1271 1
  for (i = 0; i < argc; i++)
d1273 2
a1274 2
      cygcheck (argv[i]);
      printf ("\n");
d1276 6
@


1.8
log
@	* cygcheck.cc (dump_sysinfo): Print more detailed OS information string.
@
text
@d11 2
d21 1
d140 2
a141 2
  char *path = getenv ("PATH");
  if (path)
d143 1
a143 5
      char wpath[4000];
      cygwin_posix_to_win32_path_list (path, wpath);
      char *b, *e, sep = ':';
      if (strchr (wpath, ';'))
	sep = ';';
d147 1
a147 1
	  for (e = b; *e && *e != sep; e++);
d352 1
d364 27
a390 3
	fputs (hello, stdout);
	fputs ("        ", stdout);
	fwrite (buf, 1 + p - buf, 1, stdout);
d1014 12
a1033 1
  struct mntent *mnt;
a1034 1

@


1.7
log
@* cygcheck.cc (cygwin_info): Add some more bounds checking.  From Matt Harget
<matt@@use.net>:
* utils/cygcheck.cc (keyeprint): Move declaration before other functions so it
could be used by all functions to report error messages.  Add comment.
(add_path): Check for NULL return from malloc.
(find_on_path): Check initial uses of pointers for NULL.
(rva_to_offset): Ditto.
(init_paths): Add checking for return values of Win32 calls.
(get_dword): Ditto.
(get_word): Ditto.
(dll_info): Ditto, also add NULL pointer checks.
(scan_registry): Ditto.
(check_keys): Ditto.
(dump_sysinfo): Ditto.  Add default case to switch.  Add error reporting if
GetVolumeInformation fails, except when it returns ERROR_NOT_READY.
(track_down): Add checking for NULL pointers and return values of Win32 calls.
(cygwin_info): Ditto.  Correct small memory leak.
@
text
@d753 4
a756 1
	  osname = (char *) "Win95";
d758 8
a765 2
	case 1:
	  osname = (char *) "Win98";
d773 9
a781 1
      osname = (char *) "WinNT";
@


1.6
log
@* Makefile.in: Accomodate newer gcc's which require linking of c++ programs
with g++.  Fixup output for some compilations.
* cygcheck.cc: Respond to compiler warnings.
* dumper.cc (main): Ditto.
* parse_pe.cc (exclusion::sort_and_check): Ditto.
* setfacl.cc (getaclentry): Ditto.
@
text
@d80 10
d102 5
d124 4
a127 2
  GetSystemDirectory (tmp, 4000);
  add_path (tmp, strlen (tmp));
d166 12
d191 1
a191 1
	  if (GetFileAttributes (ptr) != (DWORD) -1)
d240 8
a247 2
  SetFilePointer (fh, offset, 0, FILE_BEGIN);
  ReadFile (fh, &rv, 2, (DWORD *) &r, 0);
d256 8
a263 2
  SetFilePointer (fh, offset, 0, FILE_BEGIN);
  ReadFile (fh, &rv, 4, (DWORD *) &r, 0);
d280 7
d331 1
a331 2
  char *buf, *bufend;
  char *major, *minor;
d339 6
a344 3
  buf = (char *) malloc (size);
  if (!buf)
    return;
d348 4
a351 1
    return;
a353 1
  major = minor = NULL;
d362 2
d372 2
d385 14
a398 2
  SetFilePointer (fh, opthdr_ofs + 40, 0, FILE_BEGIN);
  ReadFile (fh, &v, sizeof (v), &junk, 0);
d404 1
d413 9
a421 5
  SetFilePointer (fh,
		  pe_header_offset + 4 + 20 + get_word (fh,
							pe_header_offset + 4 +
							16), 0, FILE_BEGIN);
  ReadFile (fh, sections, nsections * 40, &junk, 0);
d427 1
d430 4
a433 1
	  SetFilePointer (fh, expbase, 0, FILE_BEGIN);
d435 4
a438 1
	  ReadFile (fh, exp, expsz, &junk, 0);
d461 4
a464 1
	  SetFilePointer (fh, impbase, 0, FILE_BEGIN);
d466 9
a474 1
	  ReadFile (fh, imp, impsz, &junk, 0);
d491 12
d533 2
d561 2
a562 1
  CloseHandle (fh);
d571 4
a574 1
  GetFileInformationByHandle (h, &info);
d576 3
a578 1
  FileTimeToSystemTime (&info.ftLastWriteTime, &systime);
d583 2
a584 2
  CloseHandle (h);

d665 1
d667 6
d674 5
d719 2
a720 1
	      RegCloseKey (sKey);
d741 2
a742 1
  GetVersionEx (&osversion);
d788 2
a789 1
  GetSystemDirectory (tmp, 4000);
d791 1
d887 7
a893 2
      GetVolumeInformation (drive, name, sizeof (name), &serno, &maxnamelen,
			    &flags, fsname, sizeof (fsname));
d914 2
d959 2
a960 1
  FreeLibrary (k32);
a1042 7
keyeprint (const char *name)
{
  fprintf (stderr, "cygcheck: %s failed: %lu\n", name, GetLastError ());
  return 1;
}

int
d1050 1
a1050 1
    return keyeprint ("Opening CONIN$");
d1055 1
a1055 1
    keyeprint ("GetConsoleMode");
d1060 1
a1060 1
	keyeprint ("GetConsoleMode");
d1114 2
@


1.5
log
@Cleanup formatting on some files.  Remove excessive whitespace.
@
text
@d64 11
a74 32
  {
  "bash", 0}
  ,
  {
  "cat", 0}
  ,
  {
  "cpp", 1}
  ,
  {
  "find", 0}
  ,
  {
  "gcc", 0}
  ,
  {
  "gdb", 0}
  ,
  {
  "ld", 0}
  ,
  {
  "ls", 0}
  ,
  {
  "make", 0}
  ,
  {
  "sh", 0}
  ,
  {
  0, 0}
d1020 2
a1021 1
char *opts = "srvkh";
@


1.4
log
@        * cygcheck.cc (main): Fix argument counting.
@
text
@d32 1
a32 2
const char *known_env_vars[] =
{
d57 2
a58 1
struct {
d61 35
a95 12
} common_apps[] = {
  { "bash", 0 },
  { "cat", 0 },
  { "cpp", 1 },
  { "find", 0 },
  { "gcc", 0 },
  { "gdb", 0 },
  { "ld", 0 },
  { "ls", 0 },
  { "make", 0 },
  { "sh", 0 },
  { 0, 0 }
d128 2
a129 2
  add_path ((char *) ".", 1);		/* to be replaced later */
  add_path ((char *) ".", 1);		/* the current directory */
d174 1
a174 1
    default_extension = (char *)"";
d289 7
a295 7
  {
    unsigned characteristics;
    unsigned timestamp;
    unsigned forwarder_chain;
    unsigned name_rva;
    unsigned iat_rva;
  };
d325 1
a325 1
	break;
d327 1
a327 1
	buf++;
d365 4
a368 2
  SetFilePointer (fh, pe_header_offset + 4 + 20 + get_word (fh, pe_header_offset + 4 + 16),
		  0, FILE_BEGIN);
d464 3
a466 2
  HANDLE fh = CreateFile (path, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
			  NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
d491 1
a491 2
	  systime.wYear, systime.wMonth, systime.wDay,
	  f);
d526 5
a530 5
  {
    RegInfo *prev;
    char *name;
    HKEY key;
  };
d566 1
a566 2
		     MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), tmp,
		     400, 0);
a600 10
#if 0
        else
          {
	    char tmp[400];
	    FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM, 0, GetLastError (),
			   MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), tmp,
			   400, 0);
	    printf ("RegEnumValue: %s\n", tmp);
	  }
#endif
d609 2
a610 1
      if (RegEnumKey (hKey, i, subkey_name, max_subkey_len + 1) == ERROR_SUCCESS)
d764 2
a765 1
  int prev_mode = SetErrorMode (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);
d769 1
a769 1
  BOOL (WINAPI *gdfse) (LPCSTR, long long *, long long *, long long *) =
d771 1
a771 1
      GetProcAddress (k32, "GetDiskFreeSpaceExA");
d809 1
a809 2
      if (gdfse != NULL
	  && gdfse (drive, & free_me, & total_bytes, & free_bytes))
d852 2
a853 1
      printf ("PA=Persistent ACLS, FC=File Compression, VC=Volume Compression\n");
d861 3
a863 4
      printf ("Mount entries: these map POSIX directories to your NT drives.\n");
      printf ("%-*s  %-*s  %-*s  %s\n",
	      ml_fsname, "-NT-",
	      ml_dir, "-POSIX-",
d874 1
a874 3
	      ml_dir, mnt->mnt_dir,
	      ml_type, mnt->mnt_type,
	      mnt->mnt_opts);
d881 2
a882 1
    printf ("Looking to see where common programs can be found, if at all...\n");
d885 6
a890 6
    {
      if (common_apps[i].missing_is_good)
        printf ("Not Found: %s (good!)\n", common_apps[i].name);
      else
        printf ("Not Found: %s\n", common_apps[i].name);
    }
d939 2
a940 2
                          FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                          OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
d953 1
a953 1
        keyeprint ("GetConsoleMode");
d972 1
a972 1
        keyeprint ("ReadConsoleInput");
d975 1
a975 1
        continue;
d978 28
a1005 28
        {
        case KEY_EVENT:
          printf ("%s %ux VK: 0x%02x VS: 0x%02x A: 0x%02x CTRL: ",
                  in.Event.KeyEvent.bKeyDown ? "Pressed " : "Released",
                  in.Event.KeyEvent.wRepeatCount,
                  in.Event.KeyEvent.wVirtualKeyCode,
                  in.Event.KeyEvent.wVirtualScanCode,
                  (unsigned char) in.Event.KeyEvent.uChar.AsciiChar);
          fputs (in.Event.KeyEvent.dwControlKeyState & CAPSLOCK_ON ?
                 "CL " : "-- ", stdout);
          fputs (in.Event.KeyEvent.dwControlKeyState & ENHANCED_KEY ?
                 "EK " : "-- ", stdout);
          fputs (in.Event.KeyEvent.dwControlKeyState & LEFT_ALT_PRESSED ?
                 "LA " : "-- ", stdout);
          fputs (in.Event.KeyEvent.dwControlKeyState & LEFT_CTRL_PRESSED ?
                 "LC " : "-- ", stdout);
          fputs (in.Event.KeyEvent.dwControlKeyState & NUMLOCK_ON ?
                 "NL " : "-- ", stdout);
          fputs (in.Event.KeyEvent.dwControlKeyState & RIGHT_ALT_PRESSED ?
                 "RA " : "-- ", stdout);
          fputs (in.Event.KeyEvent.dwControlKeyState & RIGHT_CTRL_PRESSED ?
                 "RC " : "-- ", stdout);
          fputs (in.Event.KeyEvent.dwControlKeyState & SCROLLLOCK_ON ?
                 "SL " : "-- ", stdout);
          fputs (in.Event.KeyEvent.dwControlKeyState & SHIFT_PRESSED ?
                 "SH " : "-- ", stdout);
          fputc ('\n', stdout);
          break;
d1007 1
a1007 1
        }
d1010 2
a1011 2
         in.Event.KeyEvent.bKeyDown != FALSE ||
         in.Event.KeyEvent.uChar.AsciiChar != 'q');
d1016 1
d1022 2
a1023 1
  fprintf (stderr, "  -v, --verbose  = verbose output (indented) (for -s or programs)\n");
d1025 2
a1026 1
  fprintf (stderr, "  -k, --keycheck = perform a keyboard check session (not with -s)\n");
d1028 2
a1029 1
  fprintf (stderr, "You must at least give either -s or -k or a program name\n");
d1034 6
a1039 6
  { "sysinfo", no_argument, NULL, 's' },
  { "registry", no_argument, NULL, 'r' },
  { "verbose", no_argument, NULL, 'v' },
  { "keycheck", no_argument, NULL, 'k' },
  { "help", no_argument, NULL, 'h' },
  { 0, no_argument, NULL, 0 }
d1052 2
a1053 2
        sysinfo = 1;
        break;
d1055 2
a1056 2
        registry = 1;
        break;
d1058 2
a1059 2
        verbose = 1;
        break;
d1061 2
a1062 2
        keycheck = 1;
        break;
d1064 2
a1065 2
        givehelp = 1;
        break;
d1067 2
a1068 3
        usage ();
        /*NOTREACHED*/
      }
d1079 1
a1079 1
    return check_keys();
d1087 2
a1088 1
	  printf ("Here is where the OS will find your program, and which dlls\n");
d1093 2
a1094 1
	  printf ("Here is where the OS will find your programs, and which dlls\n");
@


1.3
log
@        * cygcheck.cc (keyeprint): New function.
        (check_keys): New function. Perform checking keycodes.
        (main): Add option `-k' for invoking check_keys.
        Change option processing to use long options and getopt_long.
        * cygkeycheck.cc: Removed. Functionality moved to `cygcheck.cc'.
        * Makefile.in: Remove cygkeycheck from the dependencies.
@
text
@d1066 1
a1066 1
  if (argc > 1 && givehelp)
d1068 1
a1068 1
      if (argc == 2)
d1083 1
a1083 1
  for (i = 1; i < argc; i++)
@


1.2
log
@* cygcheck.cc (cygwin_info): New function.  Scans DLL for Cygwin version info.
(dll_info): Add path parameter for checking "cygwin1.dll".
(track_down): Accomodate additional parameter for dll_info.
(ls): Ditto.
(dump_sys_info): Always print cygwin1.dll last.
@
text
@d18 1
d24 1
d914 88
d1005 7
a1011 6
  fprintf (stderr, "Usage: cygcheck [-s] [-v] [-r] [-h] [program ...]\n");
  fprintf (stderr, "  -s = system information\n");
  fprintf (stderr, "  -v = verbose output (indented) (for -s or programs)\n");
  fprintf (stderr, "  -r = registry search (requires -s)\n");
  fprintf (stderr, "  -h = give help about the info\n");
  fprintf (stderr, "You must at least give either -s or a program name\n");
d1015 10
a1028 13
  while (argc > 1 && argv[1][0] == '-')
    {
      if (strcmp (argv[1], "-v") == 0)
	verbose = 1;
      if (strcmp (argv[1], "-r") == 0)
	registry = 1;
      if (strcmp (argv[1], "-s") == 0)
	sysinfo = 1;
      if (strcmp (argv[1], "-h") == 0)
	givehelp = 1;
      argc--;
      argv++;
    }
d1030 29
a1058 1
  if (argc == 1 && !sysinfo)
d1060 3
@


1.1
log
@Initial revision
@
text
@d275 42
d318 1
a318 1
dll_info (HANDLE fh, int lvl, int recurse)
d387 2
d447 1
a447 1
  dll_info (fh, lvl, 1);
d465 1
a465 1
  dll_info (h, 16, 0);
d613 1
d885 1
d894 4
a897 1
		  ls (tmp);
d902 6
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
