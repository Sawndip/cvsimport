head	1.68;
access;
symbols
	cygwin-1_7_35-release:1.68
	cygwin-1_7_34-release:1.68
	cygwin-1_7_33-release:1.68
	cygwin-1_7_32-release:1.68
	cygwin-1_7_31-release:1.68
	cygwin-1_7_30-release:1.68
	cygwin-1_7_29-release:1.68
	cygwin-1_7_29-release-branchpoint:1.68.0.2
	cygwin-1_7_28-release:1.68
	cygwin-1_7_27-release:1.68
	cygwin-1_7_26-release:1.68
	cygwin-1_7_25-release:1.68
	cygwin-1_7_24-release:1.68
	cygwin-1_7_23-release:1.68
	cygwin-1_7_22-release:1.68
	cygwin-1_7_21-release:1.68
	cygwin-1_7_20-release:1.68
	cygwin-1_7_19-release:1.68
	cygwin-64bit-postmerge:1.68
	cygwin-64bit-premerge-branch:1.67.0.2
	cygwin-64bit-premerge:1.67
	cygwin-1_7_18-release:1.67
	cygwin-1_7_17-release:1.64
	cygwin-64bit-branch:1.64.0.2
	cygwin-1_7_16-release:1.64
	cygwin-1_7_15-release:1.63
	cygwin-1_7_14_2-release:1.63
	cygwin-1_7_14-release:1.63
	cygwin-1_7_12-release:1.63
	cygwin-1_7_11-release:1.63
	cygwin-1_7_10-release:1.63
	cygwin-1_7_9-release:1.57
	cygwin-1_7_8-release:1.57
	cygwin-1_7_7-release:1.57
	cygwin-1_7_5-release:1.56
	cygwin-1_7_4-release:1.56
	cygwin-1_7_3-release:1.56
	cygwin-1_7_2-release:1.56
	cygwin-1_7_1-release:1.53
	cv-branch-2:1.51.0.2
	cr-0x5f1:1.46.0.4
	cv-branch:1.46.0.2
	cr-0x3b58:1.45.0.2
	cr-0x9e:1.28.0.10
	cr-0x9d:1.28.0.8
	corinna-01:1.28
	cr-0x9c:1.28.0.4
	cr-0x9b:1.28.0.6
	cr-0x99:1.28
	Z-emcb-cygwin_daemon:1.28.0.2
	w32api-2_2:1.26
	mingw-runtime-2_4:1.26
	cygnus_cvs_20020108_pre:1.14
	Z-cygwin_daemon_merge-new_HEAD:1.11
	Z-cygwin_daemon_merge_HEAD:1.11
	cygwin_daemon:1.11.0.8;
locks; strict;
comment	@// @;
expand	@o@;


1.68
date	2013.04.23.09.44.36;	author corinna;	state Exp;
branches;
next	1.67;

1.67
date	2012.11.26.13.13.25;	author corinna;	state Exp;
branches;
next	1.66;

1.66
date	2012.11.23.13.22.47;	author cgf;	state Exp;
branches;
next	1.65;

1.65
date	2012.10.24.10.15.27;	author yselkowitz;	state Exp;
branches;
next	1.64;

1.64
date	2012.07.11.16.41.51;	author corinna;	state Exp;
branches
	1.64.2.1;
next	1.63;

1.63
date	2012.01.31.18.06.51;	author cgf;	state Exp;
branches;
next	1.62;

1.62
date	2011.12.17.23.39.47;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2011.11.24.21.54.41;	author cgf;	state Exp;
branches;
next	1.60;

1.60
date	2011.11.14.17.31.20;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2011.10.10.14.57.47;	author corinna;	state Exp;
branches;
next	1.58;

1.58
date	2011.09.15.16.49.51;	author jturney;	state Exp;
branches;
next	1.57;

1.57
date	2010.08.28.11.22.37;	author corinna;	state Exp;
branches;
next	1.56;

1.56
date	2010.02.22.20.39.18;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2010.02.19.20.01.49;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2010.02.19.17.55.27;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2009.11.04.17.00.45;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2009.07.15.15.18.51;	author corinna;	state Exp;
branches;
next	1.51;

1.51
date	2009.04.22.19.08.53;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2009.03.24.13.35.08;	author corinna;	state Exp;
branches;
next	1.49;

1.49
date	2008.09.12.22.43.10;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2007.07.23.21.03.59;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2007.07.10.00.57.30;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.24.16.50.50;	author cgf;	state Exp;
branches
	1.46.4.1;
next	1.45;

1.45
date	2005.12.29.20.46.34;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2005.12.05.16.39.06;	author cgf;	state Exp;
branches;
next	1.43;

1.43
date	2005.10.11.18.39.02;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2005.10.11.18.17.59;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2005.05.27.15.45.53;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2005.05.17.01.26.16;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2005.05.15.12.29.47;	author corinna;	state Exp;
branches;
next	1.38;

1.38
date	2005.05.09.01.21.43;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2005.03.07.10.24.23;	author corinna;	state Exp;
branches;
next	1.36;

1.36
date	2005.02.27.03.03.19;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2005.01.16.17.13.51;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2004.10.06.09.51.11;	author corinna;	state Exp;
branches;
next	1.33;

1.33
date	2004.02.21.04.51.15;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2004.02.11.13.30.02;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2004.02.11.00.29.42;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2004.02.10.16.15.53;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2004.02.10.16.01.31;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2003.04.26.21.52.03;	author joshuadfranklin;	state Exp;
branches;
next	1.27;

1.27
date	2003.03.04.05.30.50;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2002.10.19.11.41.31;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2002.09.15.19.24.37;	author joshuadfranklin;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.07.01.37.20;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.07.01.36.17;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.06.02.55.10;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.02.17.46.38;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.27.01.49.08;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.18.21.05.10;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.25.05.27.18;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.14.21.51.32;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.29.02.03.32;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.22.03.17.59;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.04.04.12.39;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.17.09.48.09;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.04.12.57.55;	author duda;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.05.17.55.23;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.28.05.00.00;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.28.00.21.41;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.15.03.43.48;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.12.06.22.30;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.09.03.31.10;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.05.18.43.54;	author dj;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.19.03.53.18;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.13.02.23.47;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.28.05.08.05;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.64.2.1
date	2012.08.16.16.26.01;	author corinna;	state Exp;
branches;
next	1.64.2.2;

1.64.2.2
date	2012.10.24.13.01.59;	author corinna;	state Exp;
branches;
next	1.64.2.3;

1.64.2.3
date	2012.11.22.12.11.07;	author corinna;	state Exp;
branches;
next	1.64.2.4;

1.64.2.4
date	2012.11.23.15.14.40;	author corinna;	state Exp;
branches;
next	1.64.2.5;

1.64.2.5
date	2012.11.26.13.13.28;	author corinna;	state Exp;
branches;
next	1.64.2.6;

1.64.2.6
date	2013.02.06.17.03.49;	author corinna;	state Exp;
branches;
next	;

1.46.4.1
date	2007.11.12.15.31.45;	author corinna;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.68
log
@	* Merge in cygwin-64bit-branch.
@
text
@/* strace.cc

   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
   2009, 2010, 2011, 2012, 2013 Red Hat Inc.

   Written by Chris Faylor <cgf@@redhat.com>

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include <windows.h>
#include <winternl.h>
#define cygwin_internal cygwin_internal_dontuse
#include <stdio.h>
#include <fcntl.h>
#include <getopt.h>
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <signal.h>
#include <errno.h>
#include "../cygwin/include/sys/strace.h"
#include "../cygwin/include/sys/cygwin.h"
#include "../cygwin/include/cygwin/version.h"
#include "path.h"
#undef cygwin_internal
#include "loadlib.h"

/* we *know* we're being built with GCC */
#ifndef alloca
#define alloca __builtin_alloca
#endif

static const char *pgm;
static int forkdebug = 1;
static int numerror = 1;
static int show_usecs = 1;
static int delta = 1;
static int hhmmss;
static int bufsize;
static int new_window;
static long flush_period;
static int include_hex;
static int quiet = -1;

static unsigned char strace_active = 1;
static int processes;

static BOOL close_handle (HANDLE h, DWORD ok);

#define CloseHandle(h) close_handle(h, 0)

struct child_list
{
  DWORD id;
  HANDLE hproc;
  int saw_stars;
  char nfields;
  long long start_time;
  DWORD last_usecs;
  struct child_list *next;
    child_list ():id (0), hproc (NULL), saw_stars (0), nfields (0),
    start_time (0), last_usecs (0), next (NULL)
  {
  }
};

child_list children;

static void
warn (int geterrno, const char *fmt, ...)
{
  va_list args;
  char buf[4096];

  va_start (args, fmt);
  sprintf (buf, "%s: ", pgm);
  vsprintf (strchr (buf, '\0'), fmt, args);
  if (geterrno)
    perror (buf);
  else
    {
      fputs (buf, stderr);
      fputs ("\n", stderr);
    }
}

static void __attribute__ ((noreturn))
error (int geterrno, const char *fmt, ...)
{
  va_list args;
  char buf[4096];

  va_start (args, fmt);
  sprintf (buf, "%s: ", pgm);
  vsprintf (strchr (buf, '\0'), fmt, args);
  if (geterrno)
    perror (buf);
  else
    {
      fputs (buf, stderr);
      fputs ("\n", stderr);
    }
  exit (1);
}

DWORD lastid = 0;
HANDLE lasth;

static child_list *
get_child (DWORD id)
{
  child_list *c;
  for (c = &children; (c = c->next) != NULL;)
    if (c->id == id)
      return c;

  return NULL;
}

static void
add_child (DWORD id, HANDLE hproc)
{
  if (!get_child (id))
    {
      child_list *c = children.next;
      children.next = (child_list *) calloc (1, sizeof (child_list));
      children.next->next = c;
      lastid = children.next->id = id;
      lasth = children.next->hproc = hproc;
      processes++;
      if (!quiet)
	fprintf (stderr, "Windows process %lu attached\n", id);
    }
}

static void
remove_child (DWORD id)
{
  child_list *c;
  if (id == lastid)
    lastid = 0;
  for (c = &children; c->next != NULL; c = c->next)
    if (c->next->id == id)
      {
	child_list *c1 = c->next;
	c->next = c1->next;
	free (c1);
	if (!quiet)
	  fprintf (stderr, "Windows process %lu detached\n", id);
	processes--;
	return;
      }

  error (0, "no process id %d found", id);
}

#define LINE_BUF_CHUNK 128

class linebuf
{
  size_t alloc;
public:
    size_t ix;
  char *buf;
  linebuf ()
  {
    ix = 0;
    alloc = 0;
    buf = NULL;
  }
 ~linebuf ()
  {
    if (buf)
      free (buf);
  }
  void add (const char *what, int len);
  void add (const char *what)
  {
    add (what, strlen (what));
  }
  void prepend (const char *what, int len);
};

void
linebuf::add (const char *what, int len)
{
  size_t newix;
  if ((newix = ix + len) >= alloc)
    {
      alloc += LINE_BUF_CHUNK + len;
      buf = (char *) realloc (buf, alloc + 1);
    }
  memcpy (buf + ix, what, len);
  ix = newix;
  buf[ix] = '\0';
}

void
linebuf::prepend (const char *what, int len)
{
  int buflen;
  size_t newix;
  if ((newix = ix + len) >= alloc)
    {
      alloc += LINE_BUF_CHUNK + len;
      buf = (char *) realloc (buf, alloc + 1);
      buf[ix] = '\0';
    }
  if ((buflen = strlen (buf)))
    memmove (buf + len, buf, buflen + 1);
  else
    buf[newix] = '\0';
  memcpy (buf, what, len);
  ix = newix;
}

static void
make_command_line (linebuf & one_line, char **argv)
{
  for (; *argv; argv++)
    {
      char *p = NULL;
      const char *a = *argv;

      int len = strlen (a);
      if (len != 0 && !(p = strpbrk (a, " \t\n\r\"")))
	one_line.add (a, len);
      else
	{
	  one_line.add ("\"", 1);
	  for (; p; a = p, p = strchr (p, '"'))
	    {
	      one_line.add (a, ++p - a);
	      if (p[-1] == '"')
		one_line.add ("\"", 1);
	    }
	  if (*a)
	    one_line.add (a);
	  one_line.add ("\"", 1);
	}
      one_line.add (" ", 1);
    }

  if (one_line.ix)
    one_line.buf[one_line.ix - 1] = '\0';
  else
    one_line.add ("", 1);
}

static DWORD child_pid;

static BOOL WINAPI
ctrl_c (DWORD)
{
  static int tic = 1;
  if ((tic ^= 1) && !GenerateConsoleCtrlEvent (CTRL_C_EVENT, 0))
    error (0, "couldn't send CTRL-C to child, win32 error %d\n",
	   GetLastError ());
  return TRUE;
}

extern "C" {
uintptr_t (*cygwin_internal) (int, ...);
WCHAR cygwin_dll_path[32768];
};

static int
load_cygwin ()
{
  static HMODULE h;

  if (cygwin_internal)
    return 1;

  if (h)
    return 0;

  if (!(h = LoadLibrary ("cygwin1.dll")))
    {
      errno = ENOENT;
      return 0;
    }
  GetModuleFileNameW (h, cygwin_dll_path, 32768);
  if (!(cygwin_internal = (uintptr_t (*) (int, ...)) GetProcAddress (h, "cygwin_internal")))
    {
      errno = ENOSYS;
      return 0;
    }
  return 1;
}

#define DEBUG_PROCESS_DETACH_ON_EXIT    0x00000001
#define DEBUG_PROCESS_ONLY_THIS_PROCESS 0x00000002

static void
attach_process (pid_t pid)
{
  child_pid = (DWORD) cygwin_internal (CW_CYGWIN_PID_TO_WINPID, pid);
  if (!child_pid)
    child_pid = pid;

  if (!DebugActiveProcess (child_pid))
    error (0, "couldn't attach to pid %d for debugging", child_pid);

  if (forkdebug)
    {
      HANDLE h = OpenProcess(PROCESS_ALL_ACCESS, FALSE, child_pid);

      if (h)
	{
	  /* Try to turn off DEBUG_ONLY_THIS_PROCESS so we can follow forks */
	  /* This is only supported on XP and later */
	  ULONG DebugFlags = DEBUG_PROCESS_DETACH_ON_EXIT;
	  NTSTATUS status = NtSetInformationProcess (h, ProcessDebugFlags, &DebugFlags, sizeof (DebugFlags));
	  if (!NT_SUCCESS (status))
	    warn (0, "Could not clear DEBUG_ONLY_THIS_PROCESS (%x), will not trace child processes", status);

	  CloseHandle(h);
	}
    }

  return;
}


static void
create_child (char **argv)
{
  linebuf one_line;

  STARTUPINFO si;
  PROCESS_INFORMATION pi;
  BOOL ret;
  DWORD flags;

  if (strchr (*argv, '/'))
      *argv = cygpath (*argv, NULL);
  memset (&si, 0, sizeof (si));
  si.cb = sizeof (si);

  flags = CREATE_DEFAULT_ERROR_MODE
	  | (forkdebug ? DEBUG_PROCESS : DEBUG_ONLY_THIS_PROCESS);
  if (new_window)
    flags |= CREATE_NEW_CONSOLE | CREATE_NEW_PROCESS_GROUP;

  make_command_line (one_line, argv);

  SetConsoleCtrlHandler (NULL, 0);
  const char *cygwin_env = getenv ("CYGWIN");
  const char *space;
  if (cygwin_env)
    space = " ";
  else
    space = cygwin_env = "";
  char *newenv = (char *) malloc (sizeof ("CYGWIN=noglob") + strlen (space) + strlen (cygwin_env));
  sprintf (newenv, "CYGWIN=noglob%s%s", space, cygwin_env);
  _putenv (newenv);
  ret = CreateProcess (0, one_line.buf,	/* command line */
		       NULL,	/* Security */
		       NULL,	/* thread */
		       TRUE,	/* inherit handles */
		       flags,	/* start flags */
		       NULL,	/* default environment */
		       NULL,	/* current directory */
		       &si, &pi);
  if (!ret)
    error (0, "error creating process %s, (error %d)", *argv,
	   GetLastError ());

  CloseHandle (pi.hThread);
  CloseHandle (pi.hProcess);
  child_pid = pi.dwProcessId;
  SetConsoleCtrlHandler (ctrl_c, 1);
}

static int
output_winerror (FILE *ofile, char *s)
{
  char *winerr = strstr (s, "Win32 error ");
  if (!winerr)
    return 0;

  DWORD errnum = atoi (winerr + sizeof ("Win32 error ") - 1);
  if (!errnum)
    return 0;

  /*
   * NOTE: Currently there is no policy for how long the
   * the buffers are, and looks like 256 is a smallest one
   * (dlfcn.cc). Other than error 1395 (length 213) and
   * error 1015 (length 249), the rest are all under 188
   * characters, and so I'll use 189 as the buffer length.
   * For those longer error messages, FormatMessage will
   * return FALSE, and we'll get the old behaviour such as
   * ``Win32 error 1395'' etc.
   */
  char buf[4096];
  if (!FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM
		      | FORMAT_MESSAGE_IGNORE_INSERTS,
		      NULL,
		      errnum,
		      MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),
		      (LPTSTR) buf, sizeof (buf), NULL))
    return 0;

  /* Get rid the trailing CR/NL pair. */
  char *p = strchr (buf, '\0');
  p[-2] = '\n';
  p[-1] = '\0';

  *winerr = '\0';
  fputs (s, ofile);
  fputs (buf, ofile);
  return 1;
}

static SYSTEMTIME *
syst (long long t)
{
  FILETIME n;
  static SYSTEMTIME st;
  long long now = t /*+ ((long long) usecs * 10)*/;
  n.dwHighDateTime = now >> 32;
  n.dwLowDateTime = now & 0xffffffff;
  FileTimeToSystemTime (&n, &st);
  return &st;
}

static void __stdcall
handle_output_debug_string (DWORD id, LPVOID p, unsigned mask, FILE *ofile)
{
  int len;
  int special;
  char alen[3 + 8 + 1];
  SIZE_T nbytes;
  child_list *child = get_child (id);
  if (!child)
    error (0, "no process id %d found", id);
  HANDLE hchild = child->hproc;
#define INTROLEN (sizeof (alen) - 1)

  if (id == lastid && hchild != lasth)
    warn (0, "%p != %p", hchild, lasth);

  alen[INTROLEN] = '\0';
  if (!ReadProcessMemory (hchild, p, alen, INTROLEN, &nbytes))
#ifndef DEBUGGING
    return;
#else
    error (0,
	   "couldn't get message length from subprocess %d<%p>, windows error %d",
	   id, hchild, GetLastError ());
#endif

  if (strncmp (alen, "cYg", 3))
    return;
  len = (int) strtoul (alen + 3, NULL, 16);
  if (!len)
    return;

  if (len > 0)
    special = 0;
  else
    {
      special = len;
      if (special == _STRACE_INTERFACE_ACTIVATE_ADDR || special == _STRACE_CHILD_PID)
	len = 17;
    }

  char *buf;
  buf = (char *) alloca (len + 85) + 20;

  if (!ReadProcessMemory (hchild, ((char *) p) + INTROLEN, buf, len, &nbytes))
    error (0, "couldn't get message from subprocess, windows error %d",
	   GetLastError ());

  buf[len] = '\0';
  char *s = strtok (buf, " ");

#ifdef __x86_64__
  unsigned long long n = strtoull (s, NULL, 16);
#else
  unsigned long n = strtoul (s, NULL, 16);
#endif

  s = strchr (s, '\0') + 1;

  if (special == _STRACE_CHILD_PID)
    {
      DebugActiveProcess (n);
      return;
    }

  if (special == _STRACE_INTERFACE_ACTIVATE_ADDR)
    {
      s = strtok (NULL, " ");
      if (*s && *s == '1' && !forkdebug)
	/* don't activate since we are not following forks */;
      else if (!WriteProcessMemory (hchild, (LPVOID) n, &strace_active,
			       sizeof (strace_active), &nbytes))
	error (0, "couldn't write strace flag to subprocess at %p, "
	       "windows error %d", n, GetLastError ());
      return;
    }

  char *origs = s;

  if (mask & n)
    /* got it */ ;
  else if (!(mask & _STRACE_ALL) || (n & _STRACE_NOTALL))
    return;			/* This should not be included in "all" output */

  DWORD dusecs, usecs;
  char *ptusec, *ptrest;

  dusecs = strtoul (s, &ptusec, 10);
  char *q = ptusec;
  while (*q == ' ')
    q++;
  if (*q != '[')
    {
      usecs = strtoul (q, &ptrest, 10);
      while (*ptrest == ' ')
	ptrest++;
    }
  else
    {
      ptrest = q;
      ptusec = show_usecs ? s : ptrest;
      usecs = dusecs;
    }

#if 1
  child->saw_stars = 2;
#else
  if (child->saw_stars == 0)
    {
      FILETIME st;
      char *news;

      GetSystemTimeAsFileTime (&st);
      FileTimeToLocalFileTime (&st, &st);
      child->start_time = st.dwHighDateTime;
      child->start_time <<= 32;
      child->start_time |= st.dwLowDateTime;
      if (*(news = ptrest) != '[')
	child->saw_stars = 2;
      else
	{
	  child->saw_stars++;
	  while ((news = strchr (news, ' ')) != NULL && *++news != '*')
	    child->nfields++;
	  if (news == NULL)
	    child->saw_stars++;
	  else
	    {
	      s = news;
	      child->nfields++;
	    }
	}
    }
  else if (child->saw_stars < 2)
    {
      int i;
      char *news;
      if (*(news = ptrest) != '[')
	child->saw_stars = 2;
      else
	{
	  for (i = 0; i < child->nfields; i++)
	    if ((news = strchr (news, ' ')) == NULL)
	      break;		// Should never happen
	    else
	      news++;

	  if (news == NULL)
	    child->saw_stars = 2;
	  else
	    {
	      s = news;
	      if (*s == '*')
		{
		  SYSTEMTIME *st = syst (child->start_time);
		  fprintf (ofile,
			   "Date/Time:    %d-%02d-%02d %02d:%02d:%02d\n",
			   st->wYear, st->wMonth, st->wDay, st->wHour,
			   st->wMinute, st->wSecond);
		  child->saw_stars++;
		}
	    }
	}
    }
#endif

  long long d = usecs - child->last_usecs;
  char intbuf[40];

  if (child->saw_stars < 2 || s != origs)
    /* Nothing */ ;
  else if (hhmmss)
    {
      s = ptrest - 9;
      SYSTEMTIME *st = syst (child->start_time + (long long) usecs * 10);
      sprintf (s, "%02d:%02d:%02d", st->wHour, st->wMinute, st->wSecond);
      *strchr (s, '\0') = ' ';
    }
  else if (!delta)
    s = ptusec;
  else
    {
      s = ptusec;
      sprintf (intbuf, "%5d ", (int) d);
      int len = strlen (intbuf);

      memcpy ((s -= len), intbuf, len);
    }

  if (include_hex)
    {
      s -= 8;
#ifdef __x86_64__
      sprintf (s, "%012I64x", n);
#else
      sprintf (s, "%08lx", n);
#endif
      strchr (s, '\0')[0] = ' ';
    }
  child->last_usecs = usecs;
  if (numerror || !output_winerror (ofile, s))
    fputs (s, ofile);
  if (!bufsize)
    fflush (ofile);
}

static DWORD
proc_child (unsigned mask, FILE *ofile, pid_t pid)
{
  DWORD res = 0;
  DEBUG_EVENT ev;
  time_t cur_time, last_time;

  SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_HIGHEST);
  last_time = time (NULL);
  while (1)
    {
      BOOL debug_event = WaitForDebugEvent (&ev, 1000);
      DWORD status = DBG_CONTINUE;

      if (bufsize && flush_period > 0 &&
	  (cur_time = time (NULL)) >= last_time + flush_period)
	{
	  last_time = cur_time;
	  fflush (ofile);
	}

      if (!debug_event)
	continue;

      if (pid)
	{
	  (void) cygwin_internal (CW_STRACE_TOGGLE, pid);
	  pid = 0;
	}

      switch (ev.dwDebugEventCode)
	{
	case CREATE_PROCESS_DEBUG_EVENT:
	  if (ev.u.CreateProcessInfo.hFile)
	    CloseHandle (ev.u.CreateProcessInfo.hFile);
	  add_child (ev.dwProcessId, ev.u.CreateProcessInfo.hProcess);
	  break;

	case CREATE_THREAD_DEBUG_EVENT:
	  break;

	case LOAD_DLL_DEBUG_EVENT:
	  if (ev.u.LoadDll.hFile)
	    CloseHandle (ev.u.LoadDll.hFile);
	  break;

	case OUTPUT_DEBUG_STRING_EVENT:
	  handle_output_debug_string (ev.dwProcessId,
				      ev.u.DebugString.lpDebugStringData,
				      mask, ofile);
	  break;

	case EXIT_PROCESS_DEBUG_EVENT:
	  res = ev.u.ExitProcess.dwExitCode;
	  remove_child (ev.dwProcessId);
	  break;
	case EXCEPTION_DEBUG_EVENT:
	  if (ev.u.Exception.ExceptionRecord.ExceptionCode
	      != (DWORD) STATUS_BREAKPOINT)
	    {
	      status = DBG_EXCEPTION_NOT_HANDLED;
	      if (ev.u.Exception.dwFirstChance)
		fprintf (ofile, "--- Process %lu, exception %08lx at %p\n",
			 ev.dwProcessId,
			 ev.u.Exception.ExceptionRecord.ExceptionCode,
			 ev.u.Exception.ExceptionRecord.ExceptionAddress);
	    }
	  break;
	}
      if (!ContinueDebugEvent (ev.dwProcessId, ev.dwThreadId, status))
	error (0, "couldn't continue debug event, windows error %d",
	       GetLastError ());
      if (!processes)
	break;
    }

  return res;
}

static void
dotoggle (pid_t pid)
{
  child_pid = (DWORD) cygwin_internal (CW_CYGWIN_PID_TO_WINPID, pid);
  if (!child_pid)
    {
      warn (0, "no such cygwin pid - %d", pid);
      child_pid = pid;
    }
  if (cygwin_internal (CW_STRACE_TOGGLE, child_pid))
    error (0, "failed to toggle tracing for process %d<%d>", pid, child_pid);

  return;
}

static DWORD
dostrace (unsigned mask, FILE *ofile, pid_t pid, char **argv)
{
  if (!pid)
    create_child (argv);
  else
    attach_process (pid);

  return proc_child (mask, ofile, pid);
}

typedef struct tag_mask_mnemonic
{
  unsigned long val;
  const char *text;
}
mask_mnemonic;

static const mask_mnemonic mnemonic_table[] = {
  {_STRACE_ALL, "all"},
  {_STRACE_FLUSH, "flush"},
  {_STRACE_INHERIT, "inherit"},
  {_STRACE_UHOH, "uhoh"},
  {_STRACE_SYSCALL, "syscall"},
  {_STRACE_STARTUP, "startup"},
  {_STRACE_DEBUG, "debug"},
  {_STRACE_PARANOID, "paranoid"},
  {_STRACE_TERMIOS, "termios"},
  {_STRACE_SELECT, "select"},
  {_STRACE_WM, "wm"},
  {_STRACE_SIGP, "sigp"},
  {_STRACE_MINIMAL, "minimal"},
  {_STRACE_EXITDUMP, "exitdump"},
  {_STRACE_SYSTEM, "system"},
  {_STRACE_NOMUTEX, "nomutex"},
  {_STRACE_MALLOC, "malloc"},
  {_STRACE_THREAD, "thread"},
  {_STRACE_PTHREAD, "pthread"},
  {_STRACE_SPECIAL, "special"},
  {0, NULL}
};

static unsigned long
mnemonic2ul (const char *nptr, char **endptr)
{
  // Look up mnemonic in table, return value.
  // *endptr = ptr to char that breaks match.
  const mask_mnemonic *mnp = mnemonic_table;

  while (mnp->text != NULL)
    {
      if (strcmp (mnp->text, nptr) == 0)
	{
	  // Found a match.
	  if (endptr != NULL)
	    {
	      *endptr = ((char *) nptr) + strlen (mnp->text);
	    }
	  return mnp->val;
	}
      mnp++;
    }

  // Didn't find it.
  if (endptr != NULL)
    {
      *endptr = (char *) nptr;
    }
  return 0;
}

static unsigned long
parse_mask (const char *ms, char **endptr)
{
  const char *p = ms;
  char *newp;
  unsigned long retval = 0, thisval;
  const size_t bufsize = 16;
  char buffer[bufsize];
  size_t len;

  while (*p != '\0')
    {
      // First extract the term, terminate it, and lowercase it.
      strncpy (buffer, p, bufsize);
      buffer[bufsize - 1] = '\0';
      len = strcspn (buffer, "+,\0");
      buffer[len] = '\0';
      strlwr (buffer);

      // Check if this is a mnemonic.  We have to do this first or strtoul()
      // will false-trigger on anything starting with "a" through "f".
      thisval = mnemonic2ul (buffer, &newp);
      if (buffer == newp)
	{
	  // This term isn't mnemonic, check if it's hex.
	  thisval = strtoul (buffer, &newp, 16);
	  if (newp != buffer + len)
	    {
	      // Not hex either, syntax error.
	      *endptr = (char *) p;
	      return 0;
	    }
	}

      p += len;
      retval += thisval;

      // Handle operators
      if (*p == '\0')
	break;
      if ((*p == '+') || (*p == ','))
	{
	  // For now these both equate to addition/ORing.  Until we get
	  // fancy and add things like "all-<something>", all we need do is
	  // continue the looping.
	  p++;
	  continue;
	}
      else
	{
	  // Syntax error
	  *endptr = (char *) p;
	  return 0;
	}
    }

  *endptr = (char *) p;
  return retval;
}

static void
usage (FILE *where = stderr)
{
  fprintf (where, "\
Usage: %s [OPTIONS] <command-line>\n\
Usage: %s [OPTIONS] -p <pid>\n\
\n\
Trace system calls and signals\n\
\n\
  -b, --buffer-size=SIZE       set size of output file buffer\n\
  -d, --no-delta               don't display the delta-t microsecond timestamp\n\
  -f, --trace-children         trace child processes (toggle - default true)\n\
  -h, --help                   output usage information and exit\n\
  -m, --mask=MASK              set message filter mask\n\
  -n, --crack-error-numbers    output descriptive text instead of error\n\
			       numbers for Windows errors\n\
  -o, --output=FILENAME        set output file to FILENAME\n\
  -p, --pid=n                  attach to executing program with cygwin pid n\n\
  -q, --quiet                  suppress messages about attaching, detaching, etc.\n\
  -S, --flush-period=PERIOD    flush buffered strace output every PERIOD secs\n\
  -t, --timestamp              use an absolute hh:mm:ss timestamp insted of \n\
			       the default microsecond timestamp.  Implies -d\n\
  -T, --toggle                 toggle tracing in a process already being\n\
			       traced. Requires -p <pid>\n\
  -u, --usecs                  toggle printing of microseconds timestamp\n\
  -V, --version                output version information and exit\n\
  -w, --new-window             spawn program under test in a new window\n\
\n", pgm, pgm);
  if ( where == stdout)
    fprintf (stdout, "\
    MASK can be any combination of the following mnemonics and/or hex values\n\
    (0x is optional).  Combine masks with '+' or ',' like so:\n\
\n\
		      --mask=wm+system,malloc+0x00800\n\
\n\
    Mnemonic Hex     Corresponding Def  Description\n\
    =========================================================================\n\
    all      0x000001 (_STRACE_ALL)      All strace messages.\n\
    flush    0x000002 (_STRACE_FLUSH)    Flush output buffer after each message.\n\
    inherit  0x000004 (_STRACE_INHERIT)  Children inherit mask from parent.\n\
    uhoh     0x000008 (_STRACE_UHOH)     Unusual or weird phenomenon.\n\
    syscall  0x000010 (_STRACE_SYSCALL)  System calls.\n\
    startup  0x000020 (_STRACE_STARTUP)  argc/envp printout at startup.\n\
    debug    0x000040 (_STRACE_DEBUG)    Info to help debugging. \n\
    paranoid 0x000080 (_STRACE_PARANOID) Paranoid info.\n\
    termios  0x000100 (_STRACE_TERMIOS)  Info for debugging termios stuff.\n\
    select   0x000200 (_STRACE_SELECT)   Info on ugly select internals.\n\
    wm       0x000400 (_STRACE_WM)       Trace Windows msgs (enable _strace_wm).\n\
    sigp     0x000800 (_STRACE_SIGP)     Trace signal and process handling.\n\
    minimal  0x001000 (_STRACE_MINIMAL)  Very minimal strace output.\n\
    pthread  0x002000 (_STRACE_PTHREAD)	Pthread calls.\n\
    exitdump 0x004000 (_STRACE_EXITDUMP) Dump strace cache on exit.\n\
    system   0x008000 (_STRACE_SYSTEM)   Serious error; goes to console and log.\n\
    nomutex  0x010000 (_STRACE_NOMUTEX)  Don't use mutex for synchronization.\n\
    malloc   0x020000 (_STRACE_MALLOC)   Trace malloc calls.\n\
    thread   0x040000 (_STRACE_THREAD)   Thread-locking calls.\n\
    special  0x100000 (_STRACE_SPECIAL)  Special debugging printfs for\n\
					 non-checked-in code\n\
");
  if (where == stderr)
    fprintf (stderr, "Try `%s --help' for more information.\n", pgm);
  exit (where == stderr ? 1 : 0 );
}

struct option longopts[] = {
  {"buffer-size", required_argument, NULL, 'b'},
  {"help", no_argument, NULL, 'h'},
  {"flush-period", required_argument, NULL, 'S'},
  {"hex", no_argument, NULL, 'H'},
  {"mask", required_argument, NULL, 'm'},
  {"new-window", no_argument, NULL, 'w'},
  {"output", required_argument, NULL, 'o'},
  {"no-delta", no_argument, NULL, 'd'},
  {"pid", required_argument, NULL, 'p'},
  {"quiet", no_argument, NULL, 'q'},
  {"timestamp", no_argument, NULL, 't'},
  {"toggle", no_argument, NULL, 'T'},
  {"trace-children", no_argument, NULL, 'f'},
  {"translate-error-numbers", no_argument, NULL, 'n'},
  {"usecs", no_argument, NULL, 'u'},
  {"version", no_argument, NULL, 'V'},
  {NULL, 0, NULL, 0}
};

static const char *const opts = "+b:dhHfm:no:p:qS:tTuVw";

static void
print_version ()
{
  printf ("strace (cygwin) %d.%d.%d\n"
	  "System Trace\n"
	  "Copyright (C) 2000 - %s Red Hat, Inc.\n"
	  "This is free software; see the source for copying conditions.  There is NO\n"
	  "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n",
	  CYGWIN_VERSION_DLL_MAJOR / 1000,
	  CYGWIN_VERSION_DLL_MAJOR % 1000,
	  CYGWIN_VERSION_DLL_MINOR,
	  strrchr (__DATE__, ' ') + 1);
}

int
main (int argc, char **argv)
{
  unsigned mask = 0;
  FILE *ofile = NULL;
  pid_t pid = 0;
  int opt;
  int toggle = 0;
  int sawquiet = -1;

  if (load_cygwin ())
    {
      char **av = (char **) cygwin_internal (CW_ARGV);
      if (av && (uintptr_t) av != (uintptr_t) -1)
	for (argc = 0, argv = av; *av; av++)
	  argc++;
    }

  if (!(pgm = strrchr (*argv, '\\')) && !(pgm = strrchr (*argv, '/')))
    pgm = *argv;
  else
    pgm++;

  while ((opt = getopt_long (argc, argv, opts, longopts, NULL)) != EOF)
    switch (opt)
      {
      case 'b':
	bufsize = atoi (optarg);
	break;
      case 'd':
	delta ^= 1;
	break;
      case 'f':
	forkdebug ^= 1;
	break;
      case 'h':
	// Print help and exit
	usage (stdout);
	break;
      case 'H':
	include_hex ^= 1;
	break;
      case 'm':
	{
	  char *endptr;
	  mask = parse_mask (optarg, &endptr);
	  if (*endptr != '\0')
	    {
	      // Bad mask expression.
	      error (0, "syntax error in mask expression \"%s\" near \
character #%d.\n", optarg, (int) (endptr - optarg), endptr);
	    }
	  break;
	}
      case 'n':
	numerror ^= 1;
	break;
      case 'o':
	if ((ofile = fopen (cygpath (optarg, NULL), "wb")) == NULL)
	  error (1, "can't open %s", optarg);
#ifdef F_SETFD
	(void) fcntl (fileno (ofile), F_SETFD, 0);
#endif
	break;
      case 'p':
	pid = strtoul (optarg, NULL, 10);
	strace_active |= 2;
	break;
      case 'q':
	if (sawquiet < 0)
	  sawquiet = 1;
	else
	  sawquiet ^= 1;
	break;
      case 'S':
	flush_period = strtoul (optarg, NULL, 10);
	break;
      case 't':
	hhmmss ^= 1;
	break;
      case 'T':
	toggle ^= 1;
	break;
      case 'u':
	// FIXME: currently unimplemented
	show_usecs ^= 1;
	delta ^= 1;
	break;
      case 'V':
	// Print version info and exit
	print_version ();
	return 0;
      case 'w':
	new_window ^= 1;
	break;
      default:
	fprintf (stderr, "Try `%s --help' for more information.\n", pgm);
	exit (1);
      }

  if (pid && argv[optind])
    error (0, "cannot provide both a command line and a process id");

  if (!pid && !argv[optind])
    error (0, "must provide either a command line or a process id");

  if (toggle && !pid)
    error (0, "must provide a process id to toggle tracing");

  if (!pid)
    quiet = sawquiet < 0 || !sawquiet;
  else if (sawquiet < 0)
    quiet = 0;
  else
    quiet = sawquiet;

  if (!mask)
    mask = _STRACE_ALL;

  if (bufsize)
    setvbuf (ofile, (char *) alloca (bufsize), _IOFBF, bufsize);

  if (!ofile)
    ofile = stdout;

  if (toggle)
    dotoggle (pid);
  else
    ExitProcess (dostrace (mask, ofile, pid, argv + optind));
  return 0;
}

#undef CloseHandle

static BOOL
close_handle (HANDLE h, DWORD ok)
{
  child_list *c;
  for (c = &children; (c = c->next) != NULL;)
    if (c->hproc == h && c->id != ok)
      error (0, "Closing child handle %p", h);
  return CloseHandle (h);
}
@


1.67
log
@	* bloda.cc: Drop Mingw.org considerations.
	* dump_setup.cc: Ditto.
	* strace.cc: Ditto.
@
text
@d4 1
a4 1
   2009, 2010, 2011 Red Hat Inc.
d268 1
a268 1
unsigned long (*cygwin_internal) (int, ...);
d289 1
a289 1
  if (!(cygwin_internal = (DWORD (*) (int, ...)) GetProcAddress (h, "cygwin_internal")))
d440 1
a440 1
  DWORD nbytes;
d485 3
d489 1
d626 5
a630 1
      sprintf (s, "%p", (void *) n);
d702 3
a704 2
		fprintf (ofile, "--- Process %lu, exception %p at %p\n", ev.dwProcessId,
			 (void *) ev.u.Exception.ExceptionRecord.ExceptionCode,
d978 1
a978 1
      if (av && (DWORD) av != (DWORD) -1)
@


1.66
log
@ChangeLog:
2012-11-12  Christopher Faylor  <me.cygwin2012@@cgf.cx>

	* Makefile.common: Revamp for new configury.  Add default compilation
	targets, include .E processing.  Add magic for allowing "CFLAGS" to
	control optimization options in "CXXFLAGS".
	* configure.cygwin: New include for Cygwin configure.in's.
	* acinclude.m4: Delete old definitions.  Implement AC_WINDOWS_HEADERS,
	AC_WINDOWS_LIBS, AC_CYGWIN_INCLUDES, target_builddir, winsup_srcdir.
	* aclocal.m4: Regenerate.
	* autogen.sh: New file.
	* ccwrap: New script.
	* c++wrap: New script.
	* config.guess: New script.
	* config.sub: New script.
	* configure: Regenerate.
	* configure.in: Eliminate LIB_AC_PROG_* calls in favor of standard.
	Delete ancient target test.
	* install-sh: New script.

cygserver/ChangeLog:
2012-11-12  Christopher Faylor  <me.cygwin2012@@cgf.cx>

	* Makefile.in: Revamp for new configury.
	* configure.in: Revamp for new configury.
	* aclocal.m4: Regenerate.
	* configure: Ditto.
	* autogen.sh: New script.

cygwin/ChangeLog:
2012-11-22  Christopher Faylor  <me.cygwin2012@@cgf.cx>

	* select.cc (select): Don't return -1 when we've timed out after
	looping.

2012-11-22  Christopher Faylor  <me.cygwin2012@@cgf.cx>

	* Makefile.in: Revamp for new configury.
	(datarootdir): Add variable setting.
	(winver_stamp): Accommodate changes to mkvers.sh setting.
	(libc.a): Fix race when libm.a might not have been built yet.
	* configure.in: Revamp for new configury.
	* aclocal.m4: Regenerate.
	* configure: Ditto.
	* autogen.sh: New script.
	* mkvers.sh: Find include directives via CFLAGS and friends rather than
	assuming that w32api lives nearby.

utils/ChangeLog:
2012-11-12  Christopher Faylor  <me.cygwin2012@@cgf.cx>

	* aclocal.m4: Regenerate.
	* configure: Ditto.
	* autogen.sh: New script.
	* configure.in: Revamp for new configury.
	* Makefile.in: Revamp for new configury.  Rename ALL_* to just *.
	Always use "VERBOSE" setting.
	(MINGW_CXX): Don't include CFLAGS in definition.
	(all): Define target first, before everything else so that it is the
	default.
	(ps.exe): Don't add useless -lcygwin.
	(ldh.exe): For consistency, add to existing MINGW_LDFLAGS rather than
	redefining them.
	(cygcheck.exe): Always include -lz for MINGW_LDFLAGS.  Don't try to
	figure out where to find it.
	(dumper.exe): Simplify check.  Assume libraries are installed rather
	than trying to retrieve from source tree.
	(install): Just use /bin/mkdir to create directories.
	(Makefile): Regenerate when standard dependencies change.
	* dump_setup.cc: Always include zlib.h.  Remove accommodations for it
	possibly not existing.
	* parse_pe.cc: Add define which allows building with installed
	binutils package.
	* dumper.cc: Ditto.
@
text
@d15 1
a15 5
#ifndef __MINGW64_VERSION_MAJOR
# include "ddk/ntapi.h"
#else
# include <winternl.h>
#endif
@


1.65
log
@	* configure.in: Add check for MINGW_CXX.  Remove libiconv check.
	* configure: Regenerate.
	* Makefile.in: Remove references to mingw and w32api directories.
	Use MINGW_CXX instead of mingw script to build MINGW_BINS.
	Check for libiconv with $CC --print-file-name.
	* cygcheck.cc: Use relative include paths for Cygwin headers.
	* path.cc: Ditto.
	* strace.cc: Ditto
	* mingw: Remove.
@
text
@d16 1
a16 1
#include "ddk/ntapi.h"
d18 1
a18 1
#include <winternl.h>
@


1.64
log
@	* Makefile.in (cygcheck.exe): Link against psapi.dll.
	* bloda.cc: Change include section to work with Mingw64 headers.
	Include psapi.h.  Use SystemProcessInformation instead of
	SystemProcessesAndThreadsInformation throughout and add define for
	w32api headers.  Ditto for PSYSTEM_PROCESS_INFORMATION vs.
	PSYSTEM_PROCESSES.
	(system_module_list): New type to replace SYSTEM_MODULE_INFORMATION.
	Change usage throughout accordingly.
	(get_module_list): Fetch module list using PSAPI functions
	EnumDeviceDrivers and GetDeviceDriverBaseNameA.
	* cygcheck.cc (max): Define as __max if not defined already.
	(alloca): Only define if not defined already.
	(handle_unique_object_name): Use explicit sharing flags rather than
	FILE_SHARE_VALID_FLAGS which officially is only available in DDK
	headers.
	(PRODUCT_ULTIMATE_E): Only define if not defined already.
	* dump_setup.cc: Change include section to work with Mingw64 headers.
	(NtQueryAttributesFile): Drop NTOSAPI aka DECLSPEC_IMPORT.
	* strace.cc: Change include section to work with Mingw64 headers.
	(alloca): Only define if not defined already.
@
text
@d30 3
a32 3
#include "cygwin/include/sys/strace.h"
#include "cygwin/include/sys/cygwin.h"
#include "cygwin/include/cygwin/version.h"
@


1.64.2.1
log
@	* cygcheck.cc: Change include path to not depend on installed
	cygwin/version.h.
	(_NOMNTENT_MACROS): Define before including mntent.h.
	* path.cc (_NOMNTENT_MACROS): Ditto.
	* dump_setup.cc: Add temporary workaround to handle older Mingw header
	files on Fedora 17.
	* strace.cc: Ditto.
@
text
@d4 1
a4 1
   2009, 2010, 2011, 2012 Red Hat Inc.
a41 7
/* Temporary workaround for older Mingw header files on Fedora 17. */
#ifndef NT_SUCCESS
#define NT_SUCCESS(status) ((NTSTATUS) (status) >= 0)
#define ProcessDebugFlags ((PROCESSINFOCLASS) 31)
extern "C" NTSTATUS NTAPI NtSetInformationProcess(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength);
#endif

@


1.64.2.2
log
@Pull in changes from HEAD
@
text
@d30 3
a32 3
#include "../cygwin/include/sys/strace.h"
#include "../cygwin/include/sys/cygwin.h"
#include "../cygwin/include/cygwin/version.h"
@


1.64.2.3
log
@	* dump_setup.cc: Drop temporary workaround to handle older Mingw header
	files on Fedora 17.
	* strace.cc: Ditto.
@
text
@d42 7
@


1.64.2.4
log
@Pull in changes from HEAD
@
text
@d16 1
a16 1
# include "ddk/ntapi.h"
d18 1
a18 1
# include <winternl.h>
@


1.64.2.5
log
@Pull in changes from HEAD
@
text
@d15 5
a19 1
#include <winternl.h>
@


1.64.2.6
log
@	Throughout, fix type problems on 32 and 64 bit.  Except:
	* ssp.c: Disable entire functionality on x86_64 for now.
@
text
@d4 1
a4 1
   2009, 2010, 2011, 2012, 2013 Red Hat Inc.
d268 1
a268 1
uintptr_t (*cygwin_internal) (int, ...);
d289 1
a289 1
  if (!(cygwin_internal = (uintptr_t (*) (int, ...)) GetProcAddress (h, "cygwin_internal")))
d440 1
a440 1
  SIZE_T nbytes;
a484 3
#ifdef __x86_64__
  unsigned long long n = strtoull (s, NULL, 16);
#else
a485 1
#endif
d622 1
a622 5
#ifdef __x86_64__
      sprintf (s, "%012I64x", n);
#else
      sprintf (s, "%08lx", n);
#endif
d694 2
a695 3
		fprintf (ofile, "--- Process %lu, exception %08lx at %p\n",
			 ev.dwProcessId,
			 ev.u.Exception.ExceptionRecord.ExceptionCode,
d969 1
a969 1
      if (av && (uintptr_t) av != (uintptr_t) -1)
@


1.63
log
@* strace.cc (proc_child): Don't right-shift exit value.
(main): Call ExitProcess() to exit exactly the same way as any straced child.
@
text
@d14 6
a27 1
#include <windows.h>
a35 1
#include "ddk/ntapi.h"
d38 1
d40 1
@


1.62
log
@Clean up whitespace.
@
text
@d683 1
a683 1
	  res = ev.u.ExitProcess.dwExitCode >> 8;
a1078 1
  DWORD res = 0;
d1082 2
a1083 2
    res = dostrace (mask, ofile, pid, argv + optind);
  return res;
@


1.61
log
@* strace.cc (attach_process): Use NT_SUCCESS to figure out if
NtSetInformationProcess succeeded.
(handle_output_debug_string): Put back DebugActiveProcess since it seems to
still be needed (on my system at least).  Detect new format
_STRACE_INTERFACE_ACTIVATE_ADDR which informs whether this is a forked process
or not.  Use that to decide if forkdebug should be handled.
@
text
@d313 7
a319 7
        {
          /* Try to turn off DEBUG_ONLY_THIS_PROCESS so we can follow forks */
          /* This is only supported on XP and later */
          ULONG DebugFlags = DEBUG_PROCESS_DETACH_ON_EXIT;
          NTSTATUS status = NtSetInformationProcess (h, ProcessDebugFlags, &DebugFlags, sizeof (DebugFlags));
          if (!NT_SUCCESS (status))
            warn (0, "Could not clear DEBUG_ONLY_THIS_PROCESS (%x), will not trace child processes", status);
d321 2
a322 2
          CloseHandle(h);
        }
d869 1
a869 1
                               numbers for Windows errors\n\
d875 1
a875 1
                               the default microsecond timestamp.  Implies -d\n\
d877 1
a877 1
                               traced. Requires -p <pid>\n\
d887 1
a887 1
                      --mask=wm+system,malloc+0x00800\n\
d911 1
a911 1
                                         non-checked-in code\n\
d944 3
a946 3
          "System Trace\n"
          "Copyright (C) 2000 - %s Red Hat, Inc.\n"
          "This is free software; see the source for copying conditions.  There is NO\n"
d948 4
a951 4
          CYGWIN_VERSION_DLL_MAJOR / 1000,
          CYGWIN_VERSION_DLL_MAJOR % 1000,
          CYGWIN_VERSION_DLL_MINOR,
          strrchr (__DATE__, ' ') + 1);
@


1.60
log
@* strace.cc (handle_output_debug_string): Disable code which attempted to add
stuff in between '****' blocks since they no longer are the first thing output
by an straced process.
@
text
@d317 2
a318 2
          NTSTATUS status = NtSetInformationProcess(h, ProcessDebugFlags, &DebugFlags, sizeof(DebugFlags));
          if (status)
d489 1
d495 4
a498 1
      if (!WriteProcessMemory (hchild, (LPVOID) n, &strace_active,
@


1.59
log
@	* Align usage output, version output, as well as usage and version
	option handling to use the same style throughout all Cygwin utils.
	Throughout use program_invocation_short_name to refer to current
	process name in Cygwin executables.
	* utils.sgml: Align documentation to above change.  Add missing
	sections for getconf, ldd, and setmetamode.
	* strace.cc (proc_child): Avoid compiler warning.
@
text
@d528 3
d588 1
@


1.58
log
@	* strace.cc (attach_process): Try to turn off DEBUG_ONLY_THIS_PROCESS
	if Attaching to a process with the trace-children flag set.
	(handle_output_debug_string): Apparently we don't need to explicitly
	attach for debugging when a child process starts
	* Makefile.in (strace.exe): Link with ntdll
@
text
@d4 1
a4 1
   2009, 2010 Red Hat Inc.
d27 1
a35 3
// Version string.
static const char version[] = "$Revision: 1.21 $";

d679 2
a680 1
	  if (ev.u.Exception.ExceptionRecord.ExceptionCode != STATUS_BREAKPOINT)
d852 1
d871 1
a871 1
  -v, --version                output version information and exit\n\
d906 1
a906 1
    fprintf (stderr, "Try '%s --help' for more information.\n", pgm);
d926 1
a926 1
  {"version", no_argument, NULL, 'v'},
d930 1
a930 1
static const char *const opts = "+b:dhHfm:no:p:qS:tTuvw";
d935 9
a943 18
  const char *v = strchr (version, ':');
  int len;
  if (!v)
    {
      v = "?";
      len = 1;
    }
  else
    {
      v += 2;
      len = strchr (v, ' ') - v;
    }
  printf ("\
%s (cygwin) %.*s\n\
System Trace\n\
Copyright 2000, 2001, 2002, 2003, 2004, 2005 Red Hat, Inc.\n\
Compiled on %s\n\
", pgm, len, v, __DATE__);
d1034 1
a1034 1
      case 'v':
d1041 2
a1042 2
      case '?':
	fprintf (stderr, "Try '%s --help' for more information.\n", pgm);
@


1.57
log
@	* loadlib.h: New header implementing safe LoadLibrary calls.
	Include throughout files using LoadLibrary function.
	* cygcheck.cc (dump_sysinfo): Retrieve kernel32.dll handle via
	GetModuleHandle, rather than using LoadLibrary.
	* cygpath.cc (get_long_name): Ditto.
	(do_sysfolders): Append .dll suffix in LoadLibrary call.
	* ldh.cc (WinMain): Use LoadLibraryExW with DONT_RESOLVE_DLL_REFERENCES
	to avoid loading malicious library code.
	* locale.cc (print_locale_with_codeset): Change way to retrieve
	kernel32.dll path.
@
text
@d30 1
d297 3
d310 17
a490 3
      if (!DebugActiveProcess (n))
	error (0, "couldn't attach to subprocess %d for debugging, "
	       "windows error %d", n, GetLastError ());
@


1.56
log
@* strace.cc (mnemonic_table): Add "special" mask option.
(usage): Document it.
* utils.sgml: Ditto.
@
text
@d29 1
@


1.55
log
@Update copyright
@
text
@d735 1
d864 21
a884 19
    all      0x00001 (_STRACE_ALL)      All strace messages.\n\
    flush    0x00002 (_STRACE_FLUSH)    Flush output buffer after each message.\n\
    inherit  0x00004 (_STRACE_INHERIT)  Children inherit mask from parent.\n\
    uhoh     0x00008 (_STRACE_UHOH)     Unusual or weird phenomenon.\n\
    syscall  0x00010 (_STRACE_SYSCALL)  System calls.\n\
    startup  0x00020 (_STRACE_STARTUP)  argc/envp printout at startup.\n\
    debug    0x00040 (_STRACE_DEBUG)    Info to help debugging. \n\
    paranoid 0x00080 (_STRACE_PARANOID) Paranoid info.\n\
    termios  0x00100 (_STRACE_TERMIOS)  Info for debugging termios stuff.\n\
    select   0x00200 (_STRACE_SELECT)   Info on ugly select internals.\n\
    wm       0x00400 (_STRACE_WM)       Trace Windows msgs (enable _strace_wm).\n\
    sigp     0x00800 (_STRACE_SIGP)     Trace signal and process handling.\n\
    minimal  0x01000 (_STRACE_MINIMAL)  Very minimal strace output.\n\
    pthread  0x02000 (_STRACE_PTHREAD)	Pthread calls.\n\
    exitdump 0x04000 (_STRACE_EXITDUMP) Dump strace cache on exit.\n\
    system   0x08000 (_STRACE_SYSTEM)   Serious error; goes to console and log.\n\
    nomutex  0x10000 (_STRACE_NOMUTEX)  Don't use mutex for synchronization.\n\
    malloc   0x20000 (_STRACE_MALLOC)   Trace malloc calls.\n\
    thread   0x40000 (_STRACE_THREAD)   Thread-locking calls.\n\
@


1.54
log
@utils/ChangeLog:
* strace.cc (mnemonic_table): Add pthread mask option.
(usage): Document strace pthread mask option.
* utils.sgml: Ditto.

cygwin/ChangeLog:
* include/sys/strace.h: Remove old code.  Add support for ptrace
tracing.
@
text
@d4 1
a4 1
   2009 Red Hat Inc.
@


1.53
log
@	* cygcheck.cc (cygwin_dll_path): New global variable.
	(load_cygwin): Fetch cygwin DLL path and store in cygwin_dll_path.
	* strace.cc: Full ditto.
	* path.cc (read_mounts): First use the path stored in cygwin_dll_path,
	if available.  Then fall back to fetching own path.  Add comment.
	Drop printing warnings since they look funny in strace output.
@
text
@d734 1
d876 1
@


1.52
log
@	* strace.cc (main): Open trace output file in UNIX mode.
@
text
@d267 1
d286 1
@


1.51
log
@* strace.cc (create_child): Set CYGWIN=noglob when starting new process so that
Cygwin will leave already-parsed the command line alonw.
@
text
@d3 2
a4 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 Red Hat Inc.
d987 1
a987 1
	if ((ofile = fopen (cygpath (optarg, NULL), "w")) == NULL)
@


1.50
log
@	* cygcheck.cc (dump_sysinfo): Fix compiler warning in printf.
	* strace.cc (proc_child): Ditto.
	* ldd.cc: Remove now useless undef wcscasecmp.
@
text
@d329 9
d343 2
a344 1
		       NULL, NULL,	/* current directory */
@


1.49
log
@* cygcheck.cc (pathlike::check_existence): Remove class name from declaration.
(display_internet_error): Use proper format specifier for DWORD.
(environ): Remove unneeded declaration.
(main): Use brace around nested if to avoid an overly-helpful compiler warning.
* dump_setup.cc (parse_filename): Reorganize nested if to avoid an
overly-helpful compiler warning.
* path.cc (GUID_shortcut): Use braces around part of initializer which needs
them.
(conv_fstab_spaces): Parenthesize assignment in while loop to avoid a compiler
warning.
(struct opt): Make static.
* ps.cc (main): Reorganize nested if to avoid an overly-helpful compiler
warning.
* regtool.cc: Make some anonymous structs static to avoid a compiler warning.
* ssp.c (lookup_thread_id): Initialize *tix to zero to avoid potential
uninitialized use.
* strace.cc (add_child): Use proper format specifier for DWORD.
(remove_child): Ditto.
(proc_child): Ditto.
@
text
@d654 1
a654 1
			 ev.u.Exception.ExceptionRecord.ExceptionCode,
@


1.48
log
@* strace.cc (create_child): Don't convert a path from cygwin format unless it
has a slash.
@
text
@d134 1
a134 1
	fprintf (stderr, "Windows process %d attached\n", id);
d151 1
a151 1
	  fprintf (stderr, "Windows process %d detached\n", id);
d653 1
a653 1
		fprintf (ofile, "--- Process %u, exception %p at %p\n", ev.dwProcessId,
@


1.47
log
@* strace.cc (usage): Add missing description for -q.
@
text
@d316 2
a317 1
  *argv = cygpath (*argv, NULL);
@


1.46
log
@* strace.cc (proc_child): Propagate return code from child process.
(dostrace): Ditto.
(main): Ditto.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005 Red Hat Inc.
d829 1
@


1.46.4.1
log
@2007-08-31  Dave Korn  <dave.korn@@artimi.com>

	* mkgroup.c (enum_groups):  Use MAX_PREFERRED_LENGTH in netgroupenum
	call so that it will automatically size returned buffer sufficiently.

2007-08-03  Dave Korn  <dave.korn@@artimi.com>

	* Makefile.in (cygcheck.exe):  Add bloda.o as prerequisite, adjusting
	dependency-filtering $(wordlist ...) call appropriately.  Link ntdll.
	(bloda.o):  New rule to build bloda.o
	* cygcheck.cc (dump_sysinfo):  Call bloda function dump_dodgy_apps().
	* bloda.cc:  New file implements detection of applications from the
	Big List Of Dodgy Apps.

2007-07-24  Corinna Vinschen  <corinna@@vinschen.de>

	* COPYING.dumper: New file.
	* dumper.cc: Change license to plain GPLv2 + later.
	* dumper.h: Ditto.
	* parse_pe.cc: Ditto.

2007-07-23  Christopher Faylor  <me+cygwin@@cgf.cx>

	* strace.cc (create_child): Don't convert a path from cygwin format
	unless it has a slash.

2007-07-09  Christopher Faylor  <me+cygwin@@cgf.cx>

	* strace.cc (usage): Add missing description for -q.

2007-05-29  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* dumper.cc (dumper::prepare_core_dump): Record a phdr for each section.

2007-03-30  Mark Mitchell  <mark@@codesourcery.com>

	* utils/cygpath.cc (get_long_path_name_w32impl): Close handles returned
	by FindFirstFile.

2006-09-11  Eric Blake  <ebb9@@byu.net>

	* cygcheck.cc (main): Restore POSIXLY_CORRECT before displaying user's
	environment.

2006-08-03  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (vconcat): Don't convert backslahes to slashes.
	(cygpath): Return native path with all backslashes.

2006-07-30  Ilya Bobir  <ilya@@po4ta.com>

	* cygpath.cc (get_long_name): Fallback to get_long_path_name_w32impl.

2006-07-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygpath.c (get_long_name): Cover the case that GetLongPathName
	doesn't return valid information for non-existant files.  Just return
	incoming filename in that case.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 Red Hat Inc.
d316 1
a316 2
  if (strchr (*argv, '/'))
      *argv = cygpath (*argv, NULL);
a828 1
  -q, --quiet                  suppress messages about attaching, detaching, etc.\n\
@


1.45
log
@*** cygwin DLL Changes:
* child_info.h (CURR_CHILD_INFO_MAGIC): Reset.
(child_info::dwProcessId): Delete.
(child_info::straced): New variable.
(child_info::handle_fork): New member function.
* dcrt0.cc (in_forkee): New global variable.
(__cygwin_user_data::forkee): Mark as obsolete.
(do_global_ctors): Use in_forkee rather than user_data->forkee.
(get_cygwin_startup_info): Ditto.  Deal with new straced field to allow strace
to deal with children of attached processes.
(initial_env): Accommodate changes to strace::hello.
(child_info_fork::handle_fork): Rename from plain old 'handle_fork'.  Move
alloc_stack() call elsewhere.
(dll_crt0_0): Fill out more of user_data.  Reference handle_fork via fork_info.
Add some debugging output.
(_dll_crt0): Don't wait for sync thread if sync_startup is invalid.  Zero
sync_startup here.  Call alloc_stack() here, if appropriate.
(dll_crt0_1): Use in_forkee rather than user_data->forkee.
(dll_crt0): Ditto.
* malloc_wrapper.cc (malloc_init): Ditto.
* dll_init.cc (in_forkee): Remove local static version of this variable.
(dll_list::load_after_fork): Don't set in_forkee here.
* external.cc (cygwin_internal): Use strace method rather than accessing field
directly.
* fhandler.cc (fhandler_base::read): Ditto.
* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Ditto.
* fork.cc (frok::parent): Invoke strace write_childpid to communicate with
potential strace.
(child_copy): Add more detail to debugging output.
* init.cc (calibration_id): New static variable.
(prime_threads): Set sync_startup to invalid handle if we already know about
thread_func_ix.  Use static calibration_id to hold calibration thread id.
* munge_threadfunc (munge_threadfunc): Don't try to debug if we don't find
threadfunc_ix.
(dll_entry): Avoid calling munge_threadfunc and _cygtls::remove on non-cygwin
threads invoked during process startup.
* pinfo.cc (set_myself): Always call strace.hello here regardless of DEBUGGING.
* sigproc.cc (child_info::child_info): Remove spurious handling of dwProcessId.
Set straced as appropriate.
* spawn.cc (spawn_guts): Rename ciresrv to ch.  Invoke strace write_childpid to
communicate with potential strace.
* strace.cc: Include child_info.h.
(strace::hello): Remove inited test.  Use active() method to test if strace has
been activated.  Handle case where we are started before
(mypid): New function.
(strace::vsprntf): Try to deal more intelligently with case where progname may
not be filled out.  Put pid in parentheses if it is a windows pid rather than a
cygwin pid.  myself has been filled out.
(strace::write_childpid): New function for notifying strace about the creation
of children.
(strace::vprntf): Use strace method rather than accessing field directly.
(strace_printf): Ditto.
(strace::wm): Ditto.
* winsup.h (in_forkee): Declare.
* include/sys/strace.h (strace::write_childpid): Declare new function.
(strace::attached): Define new function.
(strace::active): Ditto.
(strace::active_val): Ditto.
(_STRACE_ON): Delete.
(_STRACE_OFF): Ditto.
(define_strace0): Use strace method rather than accessing field directly.
(strace_printf_wrap): Ditto.
(strace_printf_wrap1): Ditto.

*** cygwin utils changes:
* strace.cc (nprocesses): Make static global.
(quiet): New variable.
(strace_active): Ditto.
(add_child): Increment nprocesses here.  Don't add a child if it is already
added (windows bug?).  Report on child if not quiet.
(get_child): Just return NULL if child not found.
(remove_child): Report on child if not quiet.
(attach_process): Don't complain if given a windows process.  Use windows pid
in error.
(handle_output_debug_string): Issue error if trying to manipulate a process
that we don't know about.  Handle _STRACE_CHILD_PID - attach to reported child
when we get this.
(proc_child): Move nprocesses to file scope.  Report on exceptions.
(longopts): Implement "--quiet".
(opts): Implement "-q".
(main): Manipulate quiet flag.
* utils.sgml (strace): Add words describing '-q'.
@
text
@d591 1
a591 1
static void
d594 1
d644 1
d664 2
d683 1
a683 1
static void
a689 1
  proc_child (mask, ofile, pid);
d691 1
a691 1
  return;
d1041 1
d1045 2
a1046 1
    dostrace (mask, ofile, pid, argv + optind);
@


1.44
log
@* strace.cc (show_usecs): Renamed from 'usecs'.
(main): Use show_usecs rather than usecs.  Toggle delta if '-u' is specified.
(handle_output_debug_string): Avoid printing microsecond timestamp if
show_usecs == 0.
* utils.sgml (strace): Add words to describe '-u'.
@
text
@d40 9
a48 5
static int hhmmss = 0;
static int bufsize = 0;
static int new_window = 0;
static long flush_period = 0;
static int include_hex = 0;
a110 12
#define PROCFLAGS \
 PROCESS_ALL_ACCESS		/*(PROCESS_DUP_HANDLE | PROCESS_TERMINATE | PROCESS_VM_READ | PROCESS_VM_WRITE) */
static void
add_child (DWORD id, HANDLE hproc)
{
  child_list *c = children.next;
  children.next = (child_list *) calloc (1, sizeof (child_list));
  children.next->next = c;
  lastid = children.next->id = id;
  lasth = children.next->hproc = hproc;
}

d119 17
a135 1
  error (0, "no process id %d found", id);
d150 3
d297 1
a297 4
    {
      warn (0, "no such cygwin pid - %d", pid);
      child_pid = pid;
    }
d300 1
a300 1
    error (0, "couldn't attach to pid %d<%d> for debugging", pid, child_pid);
a301 1
  printf ("Attached to pid %d (windows pid %u)\n", pid, (unsigned) child_pid);
d406 2
d435 1
a435 1
      if (special == _STRACE_INTERFACE_ACTIVATE_ADDR)
d453 8
d463 4
a466 6
      DWORD new_flag = 1;
      if (!WriteProcessMemory (hchild, (LPVOID) n, &new_flag,
			       sizeof (new_flag), &nbytes))
	error (0,
	       "couldn't write strace flag to subprocess at %p, windows error %d",
	       n, GetLastError ());
a594 1
  int processes = 0;
a625 1
	  processes++;
d646 1
a646 2
	  if (ev.u.Exception.ExceptionRecord.ExceptionCode !=
	      STATUS_BREAKPOINT)
d649 4
a652 5
#if 0
	      fprintf (stderr, "exception %p at %p\n",
		       ev.u.Exception.ExceptionRecord.ExceptionCode,
		       ev.u.Exception.ExceptionRecord.ExceptionAddress);
#endif
d659 1
a659 1
      if (ev.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT && --processes == 0)
d878 1
d888 1
a888 1
static const char *const opts = "+b:dhHfm:no:p:S:tTuvw";
d921 1
d979 7
d1022 7
@


1.43
log
@revert erroneous checkin
@
text
@d38 1
a38 1
static int usecs = 1;
d384 1
a384 1
  long long now = t + ((long long) usecs * 10);
d478 1
a478 1
      ptusec = s;
d820 1
d978 2
a979 1
	usecs ^= 1;
@


1.42
log
@* Makefile.common (CFLAGS_COMMON): Add -Wstrict-aliasing.
@
text
@d131 1
a131 1
remove_child (FILE *ofile, DWORD id)
a140 3
	DWORD n = 0xdeadbeef;
	GetExitCodeProcess (c1->hproc, &n);
	fprintf (ofile, "process %u exited with status %p\n", id, n);
d630 1
a630 1
	  remove_child (ofile, ev.dwProcessId);
@


1.41
log
@* cygcheck.cc (load_cygwin): Make half-hearted attempt to work with older DLLs.
* strace.cc (load_cygwin): Ditto.
@
text
@d131 1
a131 1
remove_child (DWORD id)
d141 3
d633 1
a633 1
	  remove_child (ev.dwProcessId);
@


1.40
log
@* cygcheck.cc (cygwin_internal): Define as a "C" function.
* strace.cc (cygwin_internal): Ditto.
* cygpath.cc (print_version): Update copyright.
@
text
@d912 1
a912 1
      if (av)
@


1.39
log
@	* cygcheck.cc (load_cygwin): Don't touch $PATH for now.
	(print_version): Fix copyright.
	* strace.cc (print_version): Ditto.
@
text
@d253 3
a255 1
DWORD (*cygwin_internal) (int, ...);
@


1.38
log
@* strace.cc (attach_process): Don't call load_cygwin().  Assume that it's
already happened.
(dotoggle): Ditto.
(main): Set argv from cygwin environment, if it exists.
@
text
@d893 1
a893 1
Copyright 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.\n\
@


1.37
log
@	* strace.cc (handle_output_debug_string): Fix compiler warning.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002, 2003, 2004 Red Hat Inc.
a281 1
  load_cygwin ();
a653 1
  load_cygwin ();
d907 8
@


1.36
log
@* kill (getsig): Avoid buffer overflow when generating a signal name.
* strace.cc (handle_output_debug_string): Make error a little more specific.
@
text
@d439 1
a439 1
  unsigned n = strtoul (s, NULL, 16);
d565 1
a565 1
      sprintf (s, "%p", n);
@


1.35
log
@* ps.cc (main): Eliminate use of PID_ZOMBIE.
* strace.cc (main): Recognize new option for displaying hex value of strace
type.
(handle_output_debug_string): Prepend output with hex value of strace message
if -H is specified.
@
text
@d449 2
a450 2
	       "couldn't write strace flag to subprocess, windows error %d",
	       GetLastError ());
@


1.34
log
@	* strace.cc (_impure_ptr): Remove.
@
text
@d44 1
d430 1
a430 1
  buf = (char *) alloca (len + 65) + 10;
d562 6
d860 1
d875 1
a875 1
static const char *const opts = "+b:dhfm:no:p:S:tTuvw";
d930 3
@


1.33
log
@* Makefile.in (build_dumper): Detect missing iconv library.
* cygpath.cc (dowin): Report on filename conversion errors.
(doit): Ditto.
* strace.cc (main): Use symbolic constant for _STRACE_ALL when setting mask.
@
text
@a28 6
/*  GCC runtime library's C++ EH code unfortunately pulls in stdio, and we
   get undefine references to __impure_ptr, and hence the following
   hack. It should be reasonably safe however as long as this file
   is built using -mno-cygwin as is intended.  */
int _impure_ptr;

@


1.32
log
@	* strace.cc (opts): Add leading '+' to force posixly correct
	behaviour.
	(main): Revert POSIXLY_CORRECT manipulations.
@
text
@d988 1
a988 1
    mask = 1;
@


1.31
log
@* strace.cc (main): Guard against previous setting of POSIXLY_CORRECT.
@
text
@d873 1
a873 1
static const char *const opts = "b:dhfm:no:p:S:tTuvw";
a905 1
  int posixly_correct_set = getenv ("POSIXLY_CORRECT") != NULL;
a911 2
  if (!posixly_correct_set)
    (void) putenv("POSIXLY_CORRECT=1");
a995 2
  if (!posixly_correct_set)
    putenv ("POSIXLY_CORRECT=");
@


1.30
log
@* strace.cc: Update copyrights.
* cygcheck.cc: Update copyrights.
@
text
@d906 1
d913 2
a914 1
  (void) putenv("POSIXLY_CORRECT=1");
d999 2
@


1.29
log
@* strace.cc (main): Ensure POSIXLY_CORRECT argument ordering.
* cygcheck.cc (main): Ditto.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002, 2003 Red Hat Inc.
d893 1
a893 1
Copyright 2000, 2001, 2002, 2003 Red Hat, Inc.\n\
@


1.28
log
@* cygcheck.cc (usage) Add description output.
@
text
@d912 1
@


1.27
log
@* Makefile.in (strace.exe): Include mingw_getopt.o in link line.
* cygcheck.cc (print_version): Update copyright.
* strace.cc (print_version): Ditto.
(main): Allow cygwin paths for -o option.
(create_child): Allow cygwin path as argv[0].
* path.cc (path.cc): Allow UNC paths.
@
text
@d803 2
@


1.26
log
@* mount.cc (usage): Correctly report default mode.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002 Red Hat Inc.
d26 1
d313 1
d891 1
a891 1
Copyright 2000, 2001, 2002 Red Hat, Inc.\n\
d942 1
a942 1
	if ((ofile = fopen (optarg, "w")) == NULL)
@


1.25
log
@Add final newlines to utils
@
text
@d947 1
a947 1
	pid = strtol (optarg, NULL, 10);
d950 1
a950 1
	flush_period = strtol (optarg, NULL, 10);
@


1.24
log
@* strace.cc (main): Make toggle a local variable.
@
text
@d890 2
a891 1
Compiled on %s", pgm, len, v, __DATE__);
@


1.23
log
@* strace.cc (toggle): New global variable.
(error): Use exit instead of ExitProcess so that stdio buffers get flushed.
(create_child): Remove command line error checking.
(dostrace): Ditto.
(dotoggle): New function.
(usage): Add entry for new option -T|--toggle.  Alphabetize.
(longopts): Add new option -T|--toggle.
(opts): Ditto.
(main): Handle new -T|--toggle option.  Move all command line checking here
from other functions.
* utils.sgml: Update section for strace.
@
text
@a45 1
static int toggle = 0;
d900 1
@


1.22
log
@* strace.cc (version): New global variable.
(usage): Accomodate stdout output.
(print_version): New function.
@
text
@d46 1
d106 1
a106 1
  ExitProcess (1);
a312 3
  if (!*argv)
    error (0, "no program argument specified");

d317 1
a317 1
          | (forkdebug ? DEBUG_PROCESS : DEBUG_ONLY_THIS_PROCESS);
d651 16
a668 2
  if (*argv && pid)
    error (0, "can't use -p with program argument");
d801 1
d807 2
a810 2
  -n, --crack-error-numbers    output descriptive text instead of error\n\
                               numbers for Windows errors\n\
d814 2
d818 1
a818 1
\n", pgm);
d862 1
d870 1
a870 1
static const char *const opts = "b:dhfm:no:p:S:tuvw";
d899 1
a899 1
  pid_t attach_pid = 0;
d933 1
a933 1
	break;
d946 1
a946 1
	attach_pid = strtol (optarg, NULL, 10);
d954 3
a964 1
	break;
d968 3
d973 8
a980 2
  if ( argv[optind] == NULL)
    usage ();
d991 4
a994 1
  dostrace (mask, ofile, attach_pid, argv + optind);
@


1.21
log
@* strace.cc (forkdebug): Make true by default.
(attach_process): Use window pid if cygwin pid isn't available (yet).
(create_child): Use either DEBUG_ONLY_THIS_PROCESS or DEBUG_PROCESS,
exclusively.  (Suggested by Conrad.Scott@@dsl.pipex.com)
@
text
@d38 1
a38 1
static const char *version_string = "@@(#)strace V1.0, Copyright (C) 2001, 2002 Red Hat Inc., " __DATE__ "\n";
d785 1
a785 1
usage ()
d787 2
a788 2
  fprintf (stderr, "\
Usage: strace [OPTIONS] <command-line>\n\
d792 1
a792 1
  -h, --help                   display this help info\n\
d799 3
a801 3
  -t, --timestamp              use an absolute hh:mm:ss timestamp insted of the\n\
                               default microsecond timestamp.  Implies -d\n\
  -v, --version                display version info\n\
d803 3
a805 1
\n\
d827 1
a827 1
    system   0x08000 (_STRACE_SYSTEM)   Serious error which goes to console and log.\n\
d832 3
a834 6
}

static void
version ()
{
  fputs (version_string + 4, stderr);
d856 22
d905 1
a905 2
	usage ();
	return 1;
d944 2
a945 2
	version ();
	return 1;
d951 3
@


1.20
log
@* strace.cc (attach_process): Don't tell process to start stracing here.
(proc_child): Do it here, instead, after first debug event.  This should work
around inexplicable races with DebugActiveProcess.
(dostrace): Pass any pid argument to proc_child.
@
text
@d41 1
a41 1
static int forkdebug = 0;
d289 4
a292 1
    error (0, "no such pid - %d", pid);
d318 4
a321 5
  /* cygwin32_conv_to_win32_path (exec_file, real_path); */

  flags = forkdebug ? 0 : DEBUG_ONLY_THIS_PROCESS;
  flags |= CREATE_DEFAULT_ERROR_MODE | DEBUG_PROCESS;
  flags |= (new_window ? CREATE_NEW_CONSOLE | CREATE_NEW_PROCESS_GROUP : 0);
d791 1
a791 1
  -f, --trace-children         also trace forked child processes\n\
@


1.19
log
@* strace.cc (add_child): Use calloc since new requires working libstdc++.a.
(fhandler_disk_file::fstat): Ditto for delete/free.
@
text
@a293 1
  (void) cygwin_internal (CW_STRACE_TOGGLE, pid);
d574 1
a574 1
proc_child (unsigned mask, FILE *ofile)
d597 6
d659 1
a659 1
  proc_child (mask, ofile);
@


1.18
log
@update copyright
@
text
@d117 1
a117 1
  children.next = new (child_list);
d145 1
a145 1
	delete c1;
@


1.17
log
@* strace.cc (attach_process): Change CW_STRACE_ON to CW_STRACE_TOGGLE.
@
text
@d3 1
a3 1
   Copyright 2000, 2001 Red Hat Inc.
d38 1
a38 1
static const char *version_string = "@@(#)strace V1.0, Copyright (C) 2001 Red Hat Inc., " __DATE__ "\n";
@


1.16
log
@* Makefile.in (MINGW_INCLUDES): Change cygwin include.
* strace.cc: Use specific cygwin includes, as required.
(load_cygwin): New function.  Loads cygwin DLL, if necessary.
(attach_process): Attaches strace to a running process.
(dostrace): Accept pid argument.  Attach to pid if supplied.
(usage): Describe -p option.  Correct system description.
(longopts): Alphabetize.
(opts): Ditto.
(main): Ditto.  Handle -p option.
* Makefile.in (CXXFLAGS): Ensure that important settings are preserved even
when overriden by command line.
@
text
@d294 1
a294 1
  (void) cygwin_internal (CW_STRACE_ON, pid);
@


1.15
log
@* Makefile.in: Build intermediate cygcheck.o to force use of MINGW_CXXFLAGS.
* cygcheck.cc (cygwin_info): Intitialize variable to quiet g++ warning.
(dump_sysinfo): Make variables unsigned to quiet g++ warnings.
* strace.cc (version_string): Rename from SCCSid.
(add_child): Remove unused variable.
(version): Use version_string.  Avoid use of fprintf.
@
text
@d13 1
d23 4
a26 1
#include "sys/strace.h"
d257 43
d646 1
a646 1
dostrace (unsigned mask, FILE *ofile, char **argv)
d648 6
a653 1
  create_child (argv);
d788 1
d818 1
a818 1
    system   0x08000 (_STRACE_SYSTEM)   Cache strace messages.\n\
d832 1
d834 1
a834 2
  {"version", no_argument, NULL, 'v'},
  {"buffer-size", required_argument, NULL, 'b'},
d836 1
d838 3
d842 1
a842 2
  {"crack-error-numbers", no_argument, NULL, 'n'},
  {"no-delta", no_argument, NULL, 'd'},
d844 1
a844 3
  {"timestamp", no_argument, NULL, 't'},
  {"new-window", no_argument, NULL, 'w'},
  {"flush-period", required_argument, NULL, 'S'},
d848 1
a848 1
static const char *const opts = "hvb:m:o:fndutwS:";
d855 1
d866 2
a867 4
      case 'h':
	// Print help and exit
	usage ();
	return 1;
d869 2
a870 4
      case 'v':
	// Print version info and exit
	version ();
	return 1;
d875 4
a878 2
      case 'b':
	bufsize = atoi (optarg);
d892 3
d902 5
a906 2
      case 'n':
	numerror ^= 1;
a910 3
      case 'd':
	delta ^= 1;
	break;
d912 1
a912 3
    // FIXME: This option isn't handled properly/at all by the
    // program's logic.  It seems to be the default, does it
    // need to just be removed?
d915 5
a922 3
      case 'S':
	flush_period = strtol (optarg, NULL, 10);
	break;
d934 1
a934 1
  dostrace (mask, ofile, argv + optind);
@


1.14
log
@* cygcheck.cc (usage): Add -c description.
* cygpath.cc (usage): Alphabetize options.
* strace.cc (usage): Ditto.
@
text
@d34 1
a34 1
static char *SCCSid = "@@(#)strace V1.0, Copyright (C) 2001 Red Hat Inc., " __DATE__ "\n";
a115 1
  HANDLE me = GetCurrentProcess ();
d775 1
a775 1
  fprintf (stderr, SCCSid+4);
@


1.13
log
@	* strace.cc (main): Change getopt() to getopt_long().
	Add support for help and version info.
	Use new parse_mask() function for -m/--mask option.
	(longopts): Add long options structure.
	(opts): Move options string from getopts call to static var.
	(usage): Print usage information.
	(SCCSid): Version info.
	(version): New function for displaying version info.
	(parse_mask): New function supporting parsing of mnemonics,
	hex, and basic expressions in masks.
	(mnemonic2ul): New mnemonic parsing function.
	(tag_mask_mnemonic): New type.
	(mnemonic_table): New table of mnemonics for mnemonic2ul() to
	search through.
@
text
@d731 13
a743 2
  -b, --buffer-size=SIZE       Set size of output file buffer.\n\
  -m, --mask=MASK              Set message filter mask.\n\
a769 12
\n\
  -o, --output=FILENAME        Set output file to FILENAME.\n\
  -f, --trace-children         Also trace forked child processes.\n\
  -n, --crack-error-numbers    Output descriptive text instead of error\n\
                                 numbers for Windows errors.\n\
  -d, --no-delta               Don't display the delta-t microsecond timestamp.\n\
  -t, --timestamp              Use an absolute hh:mm:ss timestamp insted of the\n\
                                 default microsecond timestamp.  Implies -d.\n\
  -w, --new-window             Spawn program under test in a new window.\n\
  -S, --flush-period=PERIOD    Flush buffered strace output every PERIOD secs.\n\
  -v, --version                Display version info.\n\
  -h, --help                   Display this help info.\n\
@


1.12
log
@* strace.cc (main): New option '-w'. Start traced process in separate
window. New option '-S x'. Flush buffered output every x seconds.
(create_child): Start child process in new window, when requested.
When requested, periodically flush debugging output.
@
text
@d33 3
d608 190
d810 1
a810 1
  while ((opt = getopt (argc, argv, "b:m:o:fndutwS:")) != EOF)
d813 10
d830 9
a838 1
	mask = strtoul (optarg, NULL, 16);
d840 1
d858 3
@


1.11
log
@        * getfacl.c: Add copyright hint.
        * setfacl.c: Ditto.
        * strace.cc: Ditto.
@
text
@d19 1
d40 2
d270 2
a271 2
  flags |=
    /*CREATE_NEW_PROCESS_GROUP | */ CREATE_DEFAULT_ERROR_MODE | DEBUG_PROCESS;
d530 2
d533 1
d538 8
d617 1
a617 1
  while ((opt = getopt (argc, argv, "b:m:o:fndut")) != EOF)
d647 7
@


1.10
log
@Cleanup formatting on some files.  Remove excessive whitespace.
@
text
@d1 12
@


1.9
log
@* strace.cc (main): Add a '-b' option.
@
text
@d33 10
d44 2
a45 10
    DWORD id;
    HANDLE hproc;
    int saw_stars;
    char nfields;
    long long start_time;
    DWORD last_usecs;
    struct child_list *next;
    child_list () : id (0), hproc (NULL), saw_stars (0), nfields (0),
		    start_time (0), last_usecs (0), next (NULL) {}
  };
d90 1
a90 1
 PROCESS_ALL_ACCESS /*(PROCESS_DUP_HANDLE | PROCESS_TERMINATE | PROCESS_VM_READ | PROCESS_VM_WRITE)*/
d106 1
a106 1
  for (c = &children; (c = c->next) != NULL; )
d137 1
a137 1
  size_t ix;
d145 5
a149 1
  ~linebuf () {if (buf) free (buf);}
d151 4
a154 1
  void add (const char *what) {add (what, strlen (what));}
d184 1
a184 1
      memmove (buf + len, buf, buflen + 1);
d186 1
a186 1
      buf[newix] = '\0';
d192 1
a192 1
make_command_line (linebuf& one_line, char **argv)
d252 1
a252 1
  /* cygwin32_conv_to_win32_path (exec_file, real_path);*/
d255 2
a256 1
  flags |= /*CREATE_NEW_PROCESS_GROUP | */CREATE_DEFAULT_ERROR_MODE | DEBUG_PROCESS;
d261 1
a261 2
  ret = CreateProcess (0,
		       one_line.buf,/* command line */
d266 2
a267 4
		       NULL,
		       NULL,	/* current directory */
		       &si,
		       &pi);
d269 2
a270 1
    error (0, "error creating process %s, (error %d)", *argv, GetLastError());
d305 1
a305 3
		      (LPTSTR) buf,
		      sizeof (buf),
		      NULL))
d340 1
a340 1
  #define INTROLEN (sizeof (alen) - 1)
d350 2
a351 1
    error (0, "couldn't get message length from subprocess %d<%p>, windows error %d",
d388 3
a390 2
			      sizeof (new_flag), &nbytes))
	error (0, "couldn't write strace flag to subprocess, windows error %d",
d398 1
a398 1
    /* got it */;
d400 1
a400 1
    return;		/* This should not be included in "all" output */
d458 1
a458 1
	      break; 	// Should never happen
d470 4
a473 2
		  fprintf (ofile, "Date/Time:    %d-%02d-%02d %02d:%02d:%02d\n",
			   st->wYear, st->wMonth, st->wDay, st->wHour, st->wMinute, st->wSecond);
d484 1
a484 1
    /* Nothing */;
d550 2
a551 1
	  if (ev.u.Exception.ExceptionRecord.ExceptionCode != STATUS_BREAKPOINT)
d580 1
a580 1
main(int argc, char **argv)
d641 1
a641 1
  for (c = &children; (c = c->next) != NULL; )
@


1.8
log
@* ps.cc (main): Accomodate new PID_ constant.
@
text
@d26 1
d496 2
a497 1
  fflush (ofile);
d580 1
a580 1
  while ((opt = getopt (argc, argv, "m:o:fndut")) != EOF)
d586 3
d614 3
@


1.7
log
@* strace.cc (proc_child): Handle exceptions correctly.
@
text
@d539 8
a546 1
	    status = DBG_EXCEPTION_NOT_HANDLED;
@


1.6
log
@* ps.cc (main): Change order of reporting slightly so that windows pids are
more obvious.
* strace.cc (add_child): Just add child's pid directly.
(remove_child): No need to close the child process pid since ContinueDebugEvent
does that automatically.
(proc_child): Ditto for child thread.
@
text
@d507 1
d537 4
d542 1
a542 2
      if (!ContinueDebugEvent (ev.dwProcessId, ev.dwThreadId,
				DBG_CONTINUE))
@


1.5
log
@* mount.cc: add stdlib.h for exit
* umount.cc: ditto
* strace.cc: add #define for alloca
@
text
@d96 1
a96 4
  if (!DuplicateHandle (me, hproc, me, &children.next->hproc, PROCFLAGS,
			FALSE, DUPLICATE_CLOSE_SOURCE))
    error (0, "couldn't duplicate %p,%p", me, hproc);
  lasth = children.next->hproc;
a119 1
	close_handle (c1->hproc, id);
a514 2
	  if (ev.u.CreateProcessInfo.hThread)
	    CloseHandle (ev.u.CreateProcessInfo.hThread);
a519 2
	  if (ev.u.CreateThread.hThread)
	    CloseHandle (ev.u.CreateThread.hThread);
@


1.4
log
@Patch suggested by Mumit Khan <khan@@xraylith.wisc.edu>:
* strace.cc (_impure_ptr): New global variable to make strace build under
Cygwin gcc.
@
text
@d17 3
@


1.3
log
@* strace.cc: Throughout, track information like start_time, etc.  on a
per-process basis.
@
text
@d11 6
@


1.2
log
@* strace.cc (handle_output_debug_string): Parse strace output to allow various
types of time output.
@
text
@d26 4
d31 2
d35 1
a35 1
child_list children = {0, NULL, NULL};
d93 2
a94 2
static HANDLE
get_child_handle (DWORD id)
d99 1
a99 1
      return c->hproc;
d326 2
a327 1
  HANDLE hchild = get_child_handle (id);
a328 4
  static int saw_stars = 0;
  static char nfields = 0;
  static long long start_time;
  static DWORD last_usecs;
d408 1
a408 1
  if (saw_stars == 0)
d415 3
a417 3
      start_time = st.dwHighDateTime;
      start_time <<= 32;
      start_time |= st.dwLowDateTime;
d419 1
a419 1
	saw_stars = 2;
d422 1
a422 1
	  saw_stars++;
d424 1
a424 1
	    nfields++;
d426 1
a426 1
	    saw_stars++;
d430 1
a430 1
	      nfields++;
d434 1
a434 1
  else if (saw_stars < 2)
d439 1
a439 1
	saw_stars = 2;
d442 1
a442 1
	  for (i = 0; i < nfields; i++)
d449 1
a449 1
	    saw_stars = 2;
d455 1
a455 1
		  SYSTEMTIME *st = syst (start_time);
d458 1
a458 1
		  saw_stars++;
d464 1
a464 1
  long long d = usecs - last_usecs;
d467 1
a467 1
  if (saw_stars < 2 || s != origs)
d472 1
a472 1
      SYSTEMTIME *st = syst (start_time + (long long) usecs * 10);
d487 1
a487 1
  last_usecs = usecs;
@


1.1
log
@Initial revision
@
text
@d13 4
a16 1
static int texterror = 0;
d29 1
a29 1
child_list children = {0};
d206 1
a206 1
ctrl_c (DWORD type)
d301 12
d322 4
d353 3
a355 2
    
  char *buf = (char *) alloca (len + 1);
d378 2
d385 101
a485 1
  if (!texterror || !output_winerror (ofile, s))
d563 1
a563 1
  while ((opt = getopt (argc, argv, "m:o:ft")) != EOF)
d579 3
d583 4
a586 1
	texterror ^= 1;
d588 2
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
