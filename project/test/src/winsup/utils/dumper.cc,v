head	1.22;
access;
symbols
	cygwin-1_7_35-release:1.22
	cygwin-1_7_34-release:1.22
	cygwin-1_7_33-release:1.22
	cygwin-1_7_32-release:1.22
	cygwin-1_7_31-release:1.22
	cygwin-1_7_30-release:1.22
	cygwin-1_7_29-release:1.22
	cygwin-1_7_29-release-branchpoint:1.22.0.2
	cygwin-1_7_28-release:1.22
	cygwin-1_7_27-release:1.22
	cygwin-1_7_26-release:1.22
	cygwin-1_7_25-release:1.22
	cygwin-1_7_24-release:1.22
	cygwin-1_7_23-release:1.22
	cygwin-1_7_22-release:1.22
	cygwin-1_7_21-release:1.22
	cygwin-1_7_20-release:1.22
	cygwin-1_7_19-release:1.22
	cygwin-64bit-postmerge:1.22
	cygwin-64bit-premerge-branch:1.21.0.2
	cygwin-64bit-premerge:1.21
	cygwin-1_7_18-release:1.21
	cygwin-1_7_17-release:1.20
	cygwin-64bit-branch:1.20.0.2
	cygwin-1_7_16-release:1.20
	cygwin-1_7_15-release:1.19
	cygwin-1_7_14_2-release:1.19
	cygwin-1_7_14-release:1.19
	cygwin-1_7_12-release:1.19
	cygwin-1_7_11-release:1.19
	cygwin-1_7_10-release:1.19
	cygwin-1_7_9-release:1.17
	cygwin-1_7_8-release:1.17
	cygwin-1_7_7-release:1.17
	cygwin-1_7_5-release:1.17
	cygwin-1_7_4-release:1.17
	cygwin-1_7_3-release:1.17
	cygwin-1_7_2-release:1.17
	cygwin-1_7_1-release:1.17
	cv-branch-2:1.17.0.2
	cr-0x5f1:1.12.0.6
	cv-branch:1.12.0.4
	cr-0x3b58:1.12.0.2
	cr-0x9e:1.10.0.10
	cr-0x9d:1.10.0.8
	corinna-01:1.10
	cr-0x9c:1.10.0.4
	cr-0x9b:1.10.0.6
	cr-0x99:1.10
	Z-emcb-cygwin_daemon:1.10.0.2
	w32api-2_2:1.9
	mingw-runtime-2_4:1.9
	cygnus_cvs_20020108_pre:1.8
	Z-cygwin_daemon_merge-new_HEAD:1.8
	Z-cygwin_daemon_merge_HEAD:1.8
	cygwin_daemon:1.8.0.2;
locks; strict;
comment	@// @;


1.22
date	2013.04.23.09.44.36;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2012.11.23.13.22.47;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2012.07.06.14.52.33;	author corinna;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2011.12.17.23.39.47;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2011.10.10.14.57.47;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2008.03.12.12.47.09;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2007.07.24.19.08.23;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2007.05.29.08.08.06;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.21.09.59.04;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.11.19.17.17;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2004.10.25.15.49.36;	author cgf;	state Exp;
branches
	1.12.6.1;
next	1.11;

1.11
date	2004.06.15.02.18.51;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.26.21.52.03;	author joshuadfranklin;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.08.01.55.56;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.14.15.07.31;	author duda;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.13.15.06.25;	author duda;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.09.13.18.51;	author duda;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.30.16.47.51;	author duda;	state Exp;
branches;
next	1.4;

1.4
date	2001.04.19.14.22.30;	author duda;	state Exp;
branches;
next	1.3;

1.3
date	2000.10.28.05.39.38;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.28.05.00.00;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.08.24.19.03.12;	author cgf;	state Exp;
branches;
next	;

1.20.2.1
date	2012.11.23.15.14.40;	author corinna;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2013.02.17.12.07.34;	author yselkowitz;	state Exp;
branches;
next	;

1.12.6.1
date	2007.11.12.15.31.45;	author corinna;	state Exp;
branches;
next	;


desc
@@


1.22
log
@	* Merge in cygwin-64bit-branch.
@
text
@/* dumper.cc

   Copyright 1999, 2001, 2002, 2004, 2006, 2007, 2011, 2013 Red Hat Inc.

   Written by Egor Duda <deo@@logos-m.ru>

   This file is part of Cygwin.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License (file COPYING.dumper) for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */

#include <ansidecl.h>
#define PACKAGE
#include <bfd.h>
#include <elf/common.h>
#include <elf/external.h>
#include <sys/procfs.h>
#include <sys/cygwin.h>
#include <cygwin/version.h>
#include <getopt.h>
#include <stdarg.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/param.h>
#include <windows.h>

#include "dumper.h"

#define NOTE_NAME_SIZE 16

typedef struct _note_header
  {
    Elf_External_Note elf_note_header;
    char name[NOTE_NAME_SIZE - 1];	/* external note contains first byte of data */
  }
#ifdef __GNUC__
__attribute__ ((packed))
#endif
  note_header;

BOOL verbose = FALSE;

int deb_printf (const char *format,...)
{
  if (!verbose)
    return 0;
  va_list va;
  va_start (va, format);
  int ret_val = vprintf (format, va);
  va_end (va);
  return ret_val;
}

dumper::dumper (DWORD pid, DWORD tid, const char *file_name)
{
  this->file_name = strdup (file_name);

  this->pid = pid;
  this->tid = tid;
  core_bfd = NULL;
  excl_list = new exclusion (20);

  list = last = NULL;

  status_section = NULL;

  memory_num = module_num = thread_num = 0;

  hProcess = OpenProcess (PROCESS_ALL_ACCESS,
			  FALSE,	/* no inheritance */
			  pid);
  if (!hProcess)
    {
      fprintf (stderr, "Failed to open process #%u, error %ld\n",
	       (unsigned int) pid, (long) GetLastError ());
      return;
    }

  init_core_dump ();

  if (!sane ())
    dumper_abort ();
}

dumper::~dumper ()
{
  close ();
  free (file_name);
}

void
dumper::dumper_abort ()
{
  close ();
  unlink (file_name);
}

void
dumper::close ()
{
  if (core_bfd)
    bfd_close (core_bfd);
  if (excl_list)
    delete excl_list;
  if (hProcess)
    CloseHandle (hProcess);
  core_bfd = NULL;
  hProcess = NULL;
  excl_list = NULL;
}

int
dumper::sane ()
{
  if (hProcess == NULL || core_bfd == NULL || excl_list == NULL)
    return 0;
  return 1;
}

void
print_section_name (bfd* abfd, asection* sect, PTR obj)
{
  deb_printf (" %s", bfd_get_section_name (abfd, sect));
}

void
dumper::print_core_section_list ()
{
  deb_printf ("current sections:");
  bfd_map_over_sections (core_bfd, &print_section_name, NULL);
  deb_printf ("\n");
}

process_entity *
dumper::add_process_entity_to_list (process_entity_type type)
{
  if (!sane ())
    return NULL;

  process_entity *new_entity = (process_entity *) malloc (sizeof (process_entity));
  if (new_entity == NULL)
    return NULL;
  new_entity->next = NULL;
  new_entity->section = NULL;
  if (last == NULL)
    list = new_entity;
  else
    last->next = new_entity;
  last = new_entity;
  return new_entity;
}

int
dumper::add_thread (DWORD tid, HANDLE hThread)
{
  if (!sane ())
    return 0;

  CONTEXT *pcontext;

  process_entity *new_entity = add_process_entity_to_list (pr_ent_thread);
  if (new_entity == NULL)
    return 0;
  new_entity->type = pr_ent_thread;
  thread_num++;

  new_entity->u.thread.tid = tid;
  new_entity->u.thread.hThread = hThread;

  pcontext = &(new_entity->u.thread.context);
  pcontext->ContextFlags = CONTEXT_FULL | CONTEXT_FLOATING_POINT;
  if (!GetThreadContext (hThread, pcontext))
    {
      deb_printf ("Failed to read thread context (tid=%x), error %ld\n", tid, GetLastError ());
      return 0;
    }

  deb_printf ("added thread %u\n", tid);
  return 1;
}

int
dumper::add_mem_region (LPBYTE base, SIZE_T size)
{
  if (!sane ())
    return 0;

  if (base == NULL || size == 0)
    return 1;			// just ignore empty regions

  process_entity *new_entity = add_process_entity_to_list (pr_ent_memory);
  if (new_entity == NULL)
    return 0;
  new_entity->type = pr_ent_memory;
  memory_num++;

  new_entity->u.memory.base = base;
  new_entity->u.memory.size = size;

  deb_printf ("added memory region %p-%p\n", base, base + size);
  return 1;
}

/* split_add_mem_region scans list of regions to be excluded from dumping process
   (excl_list) and removes all "excluded" parts from given region. */
int
dumper::split_add_mem_region (LPBYTE base, SIZE_T size)
{
  if (!sane ())
    return 0;

  if (base == NULL || size == 0)
    return 1;			// just ignore empty regions

  LPBYTE last_base = base;

  for (process_mem_region * p = excl_list->region;
       p < excl_list->region + excl_list->last;
       p++)
    {
      if (p->base >= base + size || p->base + p->size <= base)
	continue;

      if (p->base <= base)
	{
	  last_base = p->base + p->size;
	  continue;
	}

      add_mem_region (last_base, p->base - last_base);
      last_base = p->base + p->size;
    }

  if (last_base < base + size)
    add_mem_region (last_base, base + size - last_base);

  return 1;
}

int
dumper::add_module (LPVOID base_address)
{
  if (!sane ())
    return 0;

  char *module_name = psapi_get_module_name (hProcess, base_address);
  if (module_name == NULL)
    return 1;

  process_entity *new_entity = add_process_entity_to_list (pr_ent_module);
  if (new_entity == NULL)
    return 0;
  new_entity->type = pr_ent_module;
  module_num++;

  new_entity->u.module.base_address = base_address;
  new_entity->u.module.name = module_name;

  parse_pe (module_name, excl_list);

  deb_printf ("added module %p %s\n", base_address, module_name);
  return 1;
}

#define PAGE_BUFFER_SIZE 4096

int
dumper::collect_memory_sections ()
{
  if (!sane ())
    return 0;

  LPBYTE current_page_address;
  LPBYTE last_base = (LPBYTE) 0xFFFFFFFF;
  SIZE_T last_size = (SIZE_T) 0;
  SIZE_T done;

  char mem_buf[PAGE_BUFFER_SIZE];

  MEMORY_BASIC_INFORMATION mbi;

  if (hProcess == NULL)
    return 0;

  for (current_page_address = 0; current_page_address < (LPBYTE) 0xFFFF0000;)
    {
      if (!VirtualQueryEx (hProcess, current_page_address, &mbi, sizeof (mbi)))
	break;

      int skip_region_p = 0;

      if (mbi.Protect & (PAGE_NOACCESS | PAGE_GUARD) ||
	  mbi.State != MEM_COMMIT)
	skip_region_p = 1;

      if (!skip_region_p)
	{
	  /* just to make sure that later we'll be able to read it.
	     According to MS docs either region is all-readable or
	     all-nonreadable */
	  if (!ReadProcessMemory (hProcess, current_page_address, mem_buf, sizeof (mem_buf), &done))
	    {
	      DWORD err = GetLastError ();
	      const char *pt[10];
	      pt[0] = (mbi.Protect & PAGE_READONLY) ? "RO " : "";
	      pt[1] = (mbi.Protect & PAGE_READWRITE) ? "RW " : "";
	      pt[2] = (mbi.Protect & PAGE_WRITECOPY) ? "WC " : "";
	      pt[3] = (mbi.Protect & PAGE_EXECUTE) ? "EX " : "";
	      pt[4] = (mbi.Protect & PAGE_EXECUTE_READ) ? "EXRO " : "";
	      pt[5] = (mbi.Protect & PAGE_EXECUTE_READWRITE) ? "EXRW " : "";
	      pt[6] = (mbi.Protect & PAGE_EXECUTE_WRITECOPY) ? "EXWC " : "";
	      pt[7] = (mbi.Protect & PAGE_GUARD) ? "GRD " : "";
	      pt[8] = (mbi.Protect & PAGE_NOACCESS) ? "NA " : "";
	      pt[9] = (mbi.Protect & PAGE_NOCACHE) ? "NC " : "";
	      char buf[10 * 6];
	      buf[0] = '\0';
	      for (int i = 0; i < 10; i++)
		strcat (buf, pt[i]);

	      deb_printf ("warning: failed to read memory at %p-%p (protect = %s), error %ld.\n",
			  current_page_address,
			  current_page_address + mbi.RegionSize,
			  buf, err);
	      skip_region_p = 1;
	    }
	}

      if (!skip_region_p)
	{
	  if (last_base + last_size == current_page_address)
	    last_size += mbi.RegionSize;
	  else
	    {
	      split_add_mem_region (last_base, last_size);
	      last_base = (LPBYTE) mbi.BaseAddress;
	      last_size = mbi.RegionSize;
	    }
	}
      else
	{
	  split_add_mem_region (last_base, last_size);
	  last_base = NULL;
	  last_size = 0;
	}

      current_page_address += mbi.RegionSize;
    }

  /* dump last sections, if any */
  split_add_mem_region (last_base, last_size);
  return 1;
};

int
dumper::dump_memory_region (asection * to, process_mem_region * memory)
{
  if (!sane ())
    return 0;

  SIZE_T size = memory->size;
  SIZE_T todo;
  SIZE_T done;
  LPBYTE pos = memory->base;
  DWORD sect_pos = 0;

  if (to == NULL || memory == NULL)
    return 0;

  char mem_buf[PAGE_BUFFER_SIZE];

  while (size > 0)
    {
      todo = MIN (size, PAGE_BUFFER_SIZE);
      if (!ReadProcessMemory (hProcess, pos, mem_buf, todo, &done))
	{
	  deb_printf ("Failed to read process memory at %x(%x), error %ld\n", pos, todo, GetLastError ());
	  return 0;
	}
      size -= done;
      pos += done;
      if (!bfd_set_section_contents (core_bfd, to, mem_buf, sect_pos, done))
	{
	  bfd_perror ("writing memory region to bfd");
	  dumper_abort ();
	  return 0;
	};
      sect_pos += done;
    }
  return 1;
}

int
dumper::dump_thread (asection * to, process_thread * thread)
{
  if (!sane ())
    return 0;

  if (to == NULL || thread == NULL)
    return 0;

  win32_pstatus thread_pstatus;

  note_header header;
  bfd_putl32 (NOTE_NAME_SIZE, header.elf_note_header.namesz);
  bfd_putl32 (sizeof (thread_pstatus), header.elf_note_header.descsz);
  bfd_putl32 (NT_WIN32PSTATUS, header.elf_note_header.type);
  strncpy ((char *) &header.elf_note_header.name, "win32thread", NOTE_NAME_SIZE);

  thread_pstatus.data_type = NOTE_INFO_THREAD;
  thread_pstatus.data.thread_info.tid = thread->tid;

  if (tid == 0)
    {
      /* this is a special case. we don't know, which thread
	 was active when exception occured, so let's blame
	 the first one */
      thread_pstatus.data.thread_info.is_active_thread = TRUE;
      tid = (DWORD) - 1;
    }
  else if (tid > 0 && thread->tid == tid)
    thread_pstatus.data.thread_info.is_active_thread = TRUE;
  else
    thread_pstatus.data.thread_info.is_active_thread = FALSE;

  memcpy (&(thread_pstatus.data.thread_info.thread_context),
	  &(thread->context),
	  sizeof (thread->context));

  if (!bfd_set_section_contents (core_bfd, to, &header,
				 0,
				 sizeof (header)) ||
      !bfd_set_section_contents (core_bfd, to, &thread_pstatus,
				 sizeof (header),
				 sizeof (thread_pstatus)))
    {
      bfd_perror ("writing thread info to bfd");
      dumper_abort ();
      return 0;
    };
  return 1;
}

int
dumper::dump_module (asection * to, process_module * module)
{
  if (!sane ())
    return 0;

  if (to == NULL || module == NULL)
    return 0;

  struct win32_pstatus *module_pstatus_ptr;

  int note_length = sizeof (struct win32_pstatus) + strlen (module->name);

  char *buf = (char *) malloc (note_length);

  if (!buf)
    {
      fprintf (stderr, "Error alloating memory. Dumping aborted.\n");
      goto out;
    };

  module_pstatus_ptr = (struct win32_pstatus *) buf;

  note_header header;
  bfd_putl32 (NOTE_NAME_SIZE, header.elf_note_header.namesz);
  bfd_putl32 (note_length, header.elf_note_header.descsz);
  bfd_putl32 (NT_WIN32PSTATUS, header.elf_note_header.type);
  strncpy ((char *) &header.elf_note_header.name, "win32module", NOTE_NAME_SIZE);

  module_pstatus_ptr->data_type = NOTE_INFO_MODULE;
  module_pstatus_ptr->data.module_info.base_address = module->base_address;
  module_pstatus_ptr->data.module_info.module_name_size = strlen (module->name) + 1;
  strcpy (module_pstatus_ptr->data.module_info.module_name, module->name);

  if (!bfd_set_section_contents (core_bfd, to, &header,
				 0,
				 sizeof (header)) ||
      !bfd_set_section_contents (core_bfd, to, module_pstatus_ptr,
				 sizeof (header),
				 note_length))
    {
      bfd_perror ("writing module info to bfd");
      goto out;
    };
  return 1;

out:
  if (buf)
    free (buf);
  dumper_abort ();
  return 0;

}

int
dumper::collect_process_information ()
{
  int exception_level = 0;

  if (!sane ())
    return 0;

  if (!DebugActiveProcess (pid))
    {
      fprintf (stderr, "Cannot attach to process #%u, error %ld",
	       (unsigned int) pid, (long) GetLastError ());
      return 0;
    }

  char event_name[sizeof ("cygwin_error_start_event") + 20];
  sprintf (event_name, "cygwin_error_start_event%16x", (unsigned int) pid);
  HANDLE sync_with_debugee = OpenEvent (EVENT_MODIFY_STATE, FALSE, event_name);

  DEBUG_EVENT current_event;

  while (1)
    {
      if (!WaitForDebugEvent (&current_event, 20000))
	return 0;

      deb_printf ("got debug event %d\n", current_event.dwDebugEventCode);

      switch (current_event.dwDebugEventCode)
	{
	case CREATE_THREAD_DEBUG_EVENT:

	  if (!add_thread (current_event.dwThreadId,
			   current_event.u.CreateThread.hThread))
	    goto failed;

	  break;

	case CREATE_PROCESS_DEBUG_EVENT:

	  if (!add_module (current_event.u.CreateProcessInfo.lpBaseOfImage) ||
	      !add_thread (current_event.dwThreadId,
			   current_event.u.CreateProcessInfo.hThread))
	    goto failed;

	  break;

	case EXIT_PROCESS_DEBUG_EVENT:

	  deb_printf ("debugee quits");
	  ContinueDebugEvent (current_event.dwProcessId,
			      current_event.dwThreadId,
			      DBG_CONTINUE);

	  return 1;

	  break;

	case LOAD_DLL_DEBUG_EVENT:

	  if (!add_module (current_event.u.LoadDll.lpBaseOfDll))
	    goto failed;

	  break;

	case EXCEPTION_DEBUG_EVENT:

	  exception_level++;
	  if (exception_level == 2)
	    break;
	  else if (exception_level > 2)
	    return 0;

	  collect_memory_sections ();

	  /* got all info. time to dump */

	  if (!prepare_core_dump ())
	    {
	      fprintf (stderr, "Failed to prepare core dump\n");
	      goto failed;
	    };

	  if (!write_core_dump ())
	    {
	      fprintf (stderr, "Failed to write core dump\n");
	      goto failed;
	    };

	  /* signal a debugee that we've finished */
	  if (sync_with_debugee)
	    SetEvent (sync_with_debugee);

	  break;

	default:

	  break;

	}

      ContinueDebugEvent (current_event.dwProcessId,
			  current_event.dwThreadId,
			  DBG_CONTINUE);
    }
failed:
  /* set debugee free */
  if (sync_with_debugee)
    SetEvent (sync_with_debugee);

  return 0;
}

int
dumper::init_core_dump ()
{
  bfd_init ();

  core_bfd = bfd_openw (file_name, "elf32-i386");
  if (core_bfd == NULL)
    {
      bfd_perror ("opening bfd");
      goto failed;
    }

  if (!bfd_set_format (core_bfd, bfd_core))
    {
      bfd_perror ("setting bfd format");
      goto failed;
    }

  if (!bfd_set_arch_mach (core_bfd, bfd_arch_i386, 0))
    {
      bfd_perror ("setting bfd architecture");
      goto failed;
    }

  return 1;

failed:
  dumper_abort ();
  return 0;

}

int
dumper::prepare_core_dump ()
{
  if (!sane ())
    return 0;

  int sect_no = 0;
  char sect_name[50];

  flagword sect_flags;
  SIZE_T sect_size;
  bfd_vma sect_vma;

  asection *new_section;

  for (process_entity * p = list; p != NULL; p = p->next)
    {
      sect_no++;

      unsigned long phdr_type = PT_LOAD;

      switch (p->type)
	{
	case pr_ent_memory:
	  sprintf (sect_name, ".mem/%u", sect_no);
	  sect_flags = SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD;
	  sect_size = p->u.memory.size;
	  sect_vma = (bfd_vma) (p->u.memory.base);
	  phdr_type = PT_LOAD;
	  break;

	case pr_ent_thread:
	  sprintf (sect_name, ".note/%u", sect_no);
	  sect_flags = SEC_HAS_CONTENTS | SEC_LOAD;
	  sect_size = sizeof (note_header) + sizeof (struct win32_pstatus);
	  sect_vma = 0;
	  phdr_type = PT_NOTE;
	  break;

	case pr_ent_module:
	  sprintf (sect_name, ".note/%u", sect_no);
	  sect_flags = SEC_HAS_CONTENTS | SEC_LOAD;
	  sect_size = sizeof (note_header) + sizeof (struct win32_pstatus) +
	    (bfd_size_type) (strlen (p->u.module.name));
	  sect_vma = 0;
	  phdr_type = PT_NOTE;
	  break;

	default:
	  continue;
	}

      if (p->type == pr_ent_module && status_section != NULL)
	{
	  if (!bfd_set_section_size (core_bfd,
				     status_section,
				     (bfd_get_section_size (status_section)
				      + sect_size)))
	    {
	      bfd_perror ("resizing status section");
	      goto failed;
	    };
	  continue;
	}

      deb_printf ("creating section (type%u) %s(%u), flags=%08x\n",
		  p->type, sect_name, sect_size, sect_flags);

      bfd_set_error (bfd_error_no_error);
      char *buf = strdup (sect_name);
      new_section = bfd_make_section (core_bfd, buf);
      if (new_section == NULL)
	{
	  if (bfd_get_error () == bfd_error_no_error)
	    fprintf (stderr, "error creating new section (%s), section already exists.\n", buf);
	  else
	    bfd_perror ("creating section");
	  goto failed;
	}

      if (!bfd_set_section_flags (core_bfd, new_section, sect_flags) ||
	  !bfd_set_section_size (core_bfd, new_section, sect_size))
	{
	  bfd_perror ("setting section attributes");
	  goto failed;
	};

      new_section->vma = sect_vma;
      new_section->lma = 0;
      new_section->output_section = new_section;
      new_section->output_offset = 0;
      p->section = new_section;
      int section_count = 1;

      bfd_boolean filehdr = 0;
      bfd_boolean phdrs = 0;

      bfd_vma at = 0;
      bfd_boolean valid_at = 0;

      flagword flags = 0;
      bfd_boolean valid_flags = 1;

      if (p->type == pr_ent_memory)
	{
	  MEMORY_BASIC_INFORMATION mbi;
	  if (!VirtualQueryEx (hProcess, (LPVOID)sect_vma, &mbi, sizeof (mbi)))
	    {
	      bfd_perror ("getting mem region flags");
	      goto failed;
	    }

	  static const struct
	  {
	    DWORD protect;
	    flagword flags;
	  } mappings[] =
	    {
	      { PAGE_READONLY, PF_R },
	      { PAGE_READWRITE, PF_R | PF_W },
	      { PAGE_WRITECOPY, PF_W },
	      { PAGE_EXECUTE, PF_X },
	      { PAGE_EXECUTE_READ, PF_X | PF_R },
	      { PAGE_EXECUTE_READWRITE, PF_X | PF_R | PF_W },
	      { PAGE_EXECUTE_WRITECOPY, PF_X | PF_W }
	    };

	  for (size_t i = 0;
	       i < sizeof (mappings) / sizeof (mappings[0]);
	       i++)
	    if ((mbi.Protect & mappings[i].protect) != 0)
	      flags |= mappings[i].flags;
	}

      if (!bfd_record_phdr (core_bfd, phdr_type,
			    valid_flags, flags,
			    valid_at, at,
			    filehdr, phdrs,
			    section_count, &new_section))
	{
	  bfd_perror ("recording program headers");
	  goto failed;
	}
    }
  return 1;

failed:
  dumper_abort ();
  return 0;
}

int
dumper::write_core_dump ()
{
  if (!sane ())
    return 0;

  for (process_entity * p = list; p != NULL; p = p->next)
    {
      if (p->section == NULL)
	continue;

      deb_printf ("writing section type=%u base=%p size=%p flags=%08x\n",
		  p->type,
		  p->section->vma,
		  bfd_get_section_size (p->section),
		  p->section->flags);

      switch (p->type)
	{
	case pr_ent_memory:
	  dump_memory_region (p->section, &(p->u.memory));
	  break;

	case pr_ent_thread:
	  dump_thread (p->section, &(p->u.thread));
	  break;

	case pr_ent_module:
	  dump_module (p->section, &(p->u.module));
	  break;

	default:
	  continue;

	}
    }
  return 1;
}

static void
usage (FILE *stream, int status)
{
  fprintf (stream, "\
Usage: %s [OPTION] FILENAME WIN32PID\n\
\n\
Dump core from WIN32PID to FILENAME.core\n\
\n\
 -d, --verbose  be verbose while dumping\n\
 -h, --help     output help information and exit\n\
 -q, --quiet    be quiet while dumping (default)\n\
 -V, --version  output version information and exit\n\
\n", program_invocation_short_name);
  exit (status);
}

struct option longopts[] = {
  {"verbose", no_argument, NULL, 'd'},
  {"help", no_argument, NULL, 'h'},
  {"quiet", no_argument, NULL, 'q'},
  {"version", no_argument, 0, 'V'},
  {0, no_argument, NULL, 0}
};
const char *opts = "dhqV";

static void
print_version ()
{
  printf ("dumper (cygwin) %d.%d.%d\n"
	  "Core Dumper for Cygwin\n"
	  "Copyright (C) 1999 - %s Red Hat, Inc.\n"
	  "This is free software; see the source for copying conditions.  There is NO\n"
	  "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n",
	  CYGWIN_VERSION_DLL_MAJOR / 1000,
	  CYGWIN_VERSION_DLL_MAJOR % 1000,
	  CYGWIN_VERSION_DLL_MINOR,
	  strrchr (__DATE__, ' ') + 1);
}

int
main (int argc, char **argv)
{
  int opt;
  const char *p = "";
  DWORD pid;

  while ((opt = getopt_long (argc, argv, opts, longopts, NULL) ) != EOF)
    switch (opt)
      {
      case 'd':
	verbose = TRUE;
	break;
      case 'q':
	verbose = FALSE;
	break;
      case 'h':
	usage (stdout, 0);
      case 'V':
	print_version ();
	exit (0);
      default:
	fprintf (stderr, "Try `%s --help' for more information.\n",
		 program_invocation_short_name);
	exit (1);
      }

  if (argv && *(argv + optind) && *(argv + optind +1))
    {
      ssize_t len = cygwin_conv_path (CCP_POSIX_TO_WIN_A | CCP_RELATIVE,
				      *(argv + optind), NULL, 0);
      char *win32_name = (char *) alloca (len);
      cygwin_conv_path (CCP_POSIX_TO_WIN_A | CCP_RELATIVE,  *(argv + optind),
			win32_name, len);
      if ((p = strrchr (win32_name, '\\')))
	p++;
      else
	p = win32_name;
      pid = strtoul (*(argv + optind + 1), NULL, 10);
    }
  else
    {
      usage (stderr, 1);
      return -1;
    }

  char *core_file = (char *) malloc (strlen (p) + sizeof (".core"));
  if (!core_file)
    {
      fprintf (stderr, "error allocating memory\n");
      return -1;
    }
  sprintf (core_file, "%s.core", p);

  DWORD tid = 0;

  if (verbose)
    printf ("dumping process #%u to %s\n", (unsigned int) pid, core_file);

  dumper d (pid, tid, core_file);
  if (!d.sane ())
    return -1;
  d.collect_process_information ();
  free (core_file);

  return 0;
};
@


1.21
log
@ChangeLog:
2012-11-12  Christopher Faylor  <me.cygwin2012@@cgf.cx>

	* Makefile.common: Revamp for new configury.  Add default compilation
	targets, include .E processing.  Add magic for allowing "CFLAGS" to
	control optimization options in "CXXFLAGS".
	* configure.cygwin: New include for Cygwin configure.in's.
	* acinclude.m4: Delete old definitions.  Implement AC_WINDOWS_HEADERS,
	AC_WINDOWS_LIBS, AC_CYGWIN_INCLUDES, target_builddir, winsup_srcdir.
	* aclocal.m4: Regenerate.
	* autogen.sh: New file.
	* ccwrap: New script.
	* c++wrap: New script.
	* config.guess: New script.
	* config.sub: New script.
	* configure: Regenerate.
	* configure.in: Eliminate LIB_AC_PROG_* calls in favor of standard.
	Delete ancient target test.
	* install-sh: New script.

cygserver/ChangeLog:
2012-11-12  Christopher Faylor  <me.cygwin2012@@cgf.cx>

	* Makefile.in: Revamp for new configury.
	* configure.in: Revamp for new configury.
	* aclocal.m4: Regenerate.
	* configure: Ditto.
	* autogen.sh: New script.

cygwin/ChangeLog:
2012-11-22  Christopher Faylor  <me.cygwin2012@@cgf.cx>

	* select.cc (select): Don't return -1 when we've timed out after
	looping.

2012-11-22  Christopher Faylor  <me.cygwin2012@@cgf.cx>

	* Makefile.in: Revamp for new configury.
	(datarootdir): Add variable setting.
	(winver_stamp): Accommodate changes to mkvers.sh setting.
	(libc.a): Fix race when libm.a might not have been built yet.
	* configure.in: Revamp for new configury.
	* aclocal.m4: Regenerate.
	* configure: Ditto.
	* autogen.sh: New script.
	* mkvers.sh: Find include directives via CFLAGS and friends rather than
	assuming that w32api lives nearby.

utils/ChangeLog:
2012-11-12  Christopher Faylor  <me.cygwin2012@@cgf.cx>

	* aclocal.m4: Regenerate.
	* configure: Ditto.
	* autogen.sh: New script.
	* configure.in: Revamp for new configury.
	* Makefile.in: Revamp for new configury.  Rename ALL_* to just *.
	Always use "VERBOSE" setting.
	(MINGW_CXX): Don't include CFLAGS in definition.
	(all): Define target first, before everything else so that it is the
	default.
	(ps.exe): Don't add useless -lcygwin.
	(ldh.exe): For consistency, add to existing MINGW_LDFLAGS rather than
	redefining them.
	(cygcheck.exe): Always include -lz for MINGW_LDFLAGS.  Don't try to
	figure out where to find it.
	(dumper.exe): Simplify check.  Assume libraries are installed rather
	than trying to retrieve from source tree.
	(install): Just use /bin/mkdir to create directories.
	(Makefile): Regenerate when standard dependencies change.
	* dump_setup.cc: Always include zlib.h.  Remove accommodations for it
	possibly not existing.
	* parse_pe.cc: Add define which allows building with installed
	binutils package.
	* dumper.cc: Ditto.
@
text
@d3 1
a3 1
   Copyright 1999, 2001, 2002, 2004, 2006, 2007, 2011 Red Hat Inc.
d87 2
a88 1
      fprintf (stderr, "Failed to open process #%lu, error %ld\n", pid, GetLastError ());
d196 1
a196 1
dumper::add_mem_region (LPBYTE base, DWORD size)
d213 1
a213 1
  deb_printf ("added memory region %08x-%08x\n", (DWORD) base, (DWORD) base + size);
d220 1
a220 1
dumper::split_add_mem_region (LPBYTE base, DWORD size)
d259 1
a259 1
  char *module_name = psapi_get_module_name (hProcess, (DWORD) base_address);
d274 1
a274 1
  deb_printf ("added module %08x %s\n", base_address, module_name);
d288 2
a289 2
  DWORD last_size = 0;
  DWORD done;
d333 3
a335 3
	      deb_printf ("warning: failed to read memory at %08x-%08x (protect = %s), error %ld.\n",
			  (DWORD) current_page_address,
			  (DWORD) current_page_address + mbi.RegionSize,
d373 3
a375 3
  DWORD size = memory->size;
  DWORD todo;
  DWORD done;
d520 2
a521 1
      fprintf (stderr, "Cannot attach to process #%lu, error %ld", pid, GetLastError ());
d526 1
a526 1
  sprintf (event_name, "cygwin_error_start_event%16lx", pid);
d665 1
a665 1
  DWORD sect_size;
d817 1
a817 1
      deb_printf ("writing section type=%u base=%08x size=%08x flags=%08x\n",
d941 1
a941 1
    printf ("dumping process #%lu to %s\n", pid, core_file);
@


1.20
log
@	* cygpath.cc: Change including headers to allow building against
	Mingw64 headers. Include ntdef.h and ntdll.h rather than ddk headers.
	Define _WIN32_WINNT and WINVER as 0x0602.
	(RtlEqualUnicodePathPrefix): Drop definition.  Pulled in from ntdll.h
	now.
	(get_device_name): s/Zw/Nt.
	* dumper.cc: Include sys/param.h
	(dumper::dump_memory_region): Use MIN rather than min.
	* locale.cc: Include stdlib.h.  Define _WIN32_WINNT and WINVER as
	0x0602.
	* ps.cc: Include ntdef.h and ntdll.h rather than ddk headers.
	* regtool.cc (regDeleteKeyEx): Drop WINADVAPI qualifier.
@
text
@d24 1
@


1.20.2.1
log
@Pull in changes from HEAD
@
text
@a23 1
#define PACKAGE
@


1.20.2.2
log
@Fix 64-bit type problems in dumper.exe
* dumper.cc: Througout, cast pid to unsigned int, change addresses
and sizes from DWORD to SIZE_T, and use %p for pointer addresses.
(dumper::add_mem_region): Change size type to SIZE_T.
(dumper::split_add_mem_region): Ditto.
* dumper.h (struct process_mem_region): Change size type to SIZE_T.
(class exclusion): Change last, size, and step types to size_t.
(exclusion::exclusion): Change argument type to size_t.
(exclusion::add): Change mem_size type to SIZE_T.
(dumper::add_mem_region): Change size type to SIZE_T.
(dumper::split_add_mem_region): Ditto.
(psapi_get_module_name): Change BaseAddress type to LPVOID.
* module_info.cc (psapi_get_module_name): Ditto.
* parse_pe.cc: Througout, change addresses and sizes from DWORD to
SIZE_T, and use %p for pointer addresses.
(exclusion::add): Change mem_size type to SIZE_T.
@
text
@d3 1
a3 1
   Copyright 1999, 2001, 2002, 2004, 2006, 2007, 2011, 2013 Red Hat Inc.
d87 1
a87 2
      fprintf (stderr, "Failed to open process #%u, error %ld\n",
	       (unsigned int) pid, (long) GetLastError ());
d195 1
a195 1
dumper::add_mem_region (LPBYTE base, SIZE_T size)
d212 1
a212 1
  deb_printf ("added memory region %p-%p\n", base, base + size);
d219 1
a219 1
dumper::split_add_mem_region (LPBYTE base, SIZE_T size)
d258 1
a258 1
  char *module_name = psapi_get_module_name (hProcess, base_address);
d273 1
a273 1
  deb_printf ("added module %p %s\n", base_address, module_name);
d287 2
a288 2
  SIZE_T last_size = (SIZE_T) 0;
  SIZE_T done;
d332 3
a334 3
	      deb_printf ("warning: failed to read memory at %p-%p (protect = %s), error %ld.\n",
			  current_page_address,
			  current_page_address + mbi.RegionSize,
d372 3
a374 3
  SIZE_T size = memory->size;
  SIZE_T todo;
  SIZE_T done;
d519 1
a519 2
      fprintf (stderr, "Cannot attach to process #%u, error %ld",
	       (unsigned int) pid, (long) GetLastError ());
d524 1
a524 1
  sprintf (event_name, "cygwin_error_start_event%16x", (unsigned int) pid);
d663 1
a663 1
  SIZE_T sect_size;
d815 1
a815 1
      deb_printf ("writing section type=%u base=%p size=%p flags=%08x\n",
d939 1
a939 1
    printf ("dumping process #%u to %s\n", (unsigned int) pid, core_file);
@


1.19
log
@Clean up whitespace.
@
text
@d36 1
d384 1
a384 1
      todo = min (size, PAGE_BUFFER_SIZE);
@


1.18
log
@	* Align usage output, version output, as well as usage and version
	option handling to use the same style throughout all Cygwin utils.
	Throughout use program_invocation_short_name to refer to current
	process name in Cygwin executables.
	* utils.sgml: Align documentation to above change.  Add missing
	sections for getconf, ldd, and setmetamode.
	* strace.cc (proc_child): Avoid compiler warning.
@
text
@d870 3
a872 3
          "Core Dumper for Cygwin\n"
          "Copyright (C) 1999 - %s Red Hat, Inc.\n"
          "This is free software; see the source for copying conditions.  There is NO\n"
d874 4
a877 4
          CYGWIN_VERSION_DLL_MAJOR / 1000,
          CYGWIN_VERSION_DLL_MAJOR % 1000,
          CYGWIN_VERSION_DLL_MINOR,
          strrchr (__DATE__, ' ') + 1);
@


1.17
log
@	* cygpath.cc (do_sysfolders): Use cygwin_conv_path.
	(do_pathconv): Use cygwin_conv_path and cygwin_conv_path_list.
	* dumper.cc (main): Use cygwin_conv_path.  Allocate target path
	dynamically.
	* mkpasswd.c (current_user): Use cygwin_conv_path.
	(enum_users): Ditto.
	* ps.cc (NT_MAX_PATH): Define.
	(main): Use cygwin_conv_path.
	* regtool.cc (find_key): Ditto. Allocate target path dynamically.
	(cmd_save): Ditto.
@
text
@d3 1
a3 1
   Copyright 1999, 2001, 2002, 2004, 2006, 2007 Red Hat Inc.
d29 1
d32 1
a51 2
static const char version[] = "$Revision: 1.16 $";

d845 2
a846 1
Usage: dumper [OPTION] FILENAME WIN32PID\n\
d852 2
a853 2
 -v, --version  output version information and exit\n\
");
d861 1
a861 1
  {"version", no_argument, 0, 'v'},
d864 1
d869 9
a877 16
  const char *v = strchr (version, ':');
  int len;
  if (!v)
    {
      v = "?";
      len = 1;
    }
  else
    {
      v += 2;
      len = strchr (v, ' ') - v;
    }
  printf ("\
dumper (cygwin) %.*s\n\
Core Dumper for Cygwin\n\
Copyright 1999, 2001, 2002 Red Hat, Inc.\n", len, v);
d887 1
a887 1
  while ((opt = getopt_long (argc, argv, "dqhv", longopts, NULL) ) != EOF)
d898 3
a900 3
      case 'v':
       print_version ();
       exit (0);
d902 3
a904 2
	usage (stderr, 1);
	break;
@


1.16
log
@	* dumper.cc: Change license to plain GPLv2 + later.
	* dumper.h: Ditto.
	* parse_pe.cc: Ditto.
@
text
@d50 1
a50 1
static const char version[] = "$Revision: 1.15 $";
a890 1
  char win32_name [MAX_PATH];
d913 5
a917 2
      *win32_name = '\0';
      cygwin_conv_to_win32_path (*(argv + optind), win32_name);
@


1.15
log
@	* dumper.cc (dumper::prepare_core_dump): Record a phdr for each section.
@
text
@d9 13
a21 3
   This software is a copyrighted work licensed under the terms of the
   Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
   details. */
@


1.14
log
@	* dumper.cc: Include ansidecl.h before including bfd.h to woraround
	a problem with the order in which system include files are included.
@
text
@d3 1
a3 1
   Copyright 1999, 2001, 2002, 2004, 2006 Red Hat Inc.
d40 1
a40 1
static const char version[] = "$Revision: 1.12 $";
d660 2
d669 1
a669 1

d677 1
d686 1
d729 1
d733 51
a784 1

@


1.13
log
@* dumper.cc: Add an include to accommodate new include/elf usage.
@
text
@d3 1
a3 1
   Copyright 1999, 2001, 2002, 2004 Red Hat Inc.
d13 1
a14 1
#include <ansidecl.h>
@


1.12
log
@fix whitespace, update some copyrights
@
text
@d14 1
d40 1
a40 1
static const char version[] = "$Revision: 1.11 $";
@


1.12.6.1
log
@2007-08-31  Dave Korn  <dave.korn@@artimi.com>

	* mkgroup.c (enum_groups):  Use MAX_PREFERRED_LENGTH in netgroupenum
	call so that it will automatically size returned buffer sufficiently.

2007-08-03  Dave Korn  <dave.korn@@artimi.com>

	* Makefile.in (cygcheck.exe):  Add bloda.o as prerequisite, adjusting
	dependency-filtering $(wordlist ...) call appropriately.  Link ntdll.
	(bloda.o):  New rule to build bloda.o
	* cygcheck.cc (dump_sysinfo):  Call bloda function dump_dodgy_apps().
	* bloda.cc:  New file implements detection of applications from the
	Big List Of Dodgy Apps.

2007-07-24  Corinna Vinschen  <corinna@@vinschen.de>

	* COPYING.dumper: New file.
	* dumper.cc: Change license to plain GPLv2 + later.
	* dumper.h: Ditto.
	* parse_pe.cc: Ditto.

2007-07-23  Christopher Faylor  <me+cygwin@@cgf.cx>

	* strace.cc (create_child): Don't convert a path from cygwin format
	unless it has a slash.

2007-07-09  Christopher Faylor  <me+cygwin@@cgf.cx>

	* strace.cc (usage): Add missing description for -q.

2007-05-29  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* dumper.cc (dumper::prepare_core_dump): Record a phdr for each section.

2007-03-30  Mark Mitchell  <mark@@codesourcery.com>

	* utils/cygpath.cc (get_long_path_name_w32impl): Close handles returned
	by FindFirstFile.

2006-09-11  Eric Blake  <ebb9@@byu.net>

	* cygcheck.cc (main): Restore POSIXLY_CORRECT before displaying user's
	environment.

2006-08-03  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (vconcat): Don't convert backslahes to slashes.
	(cygpath): Return native path with all backslashes.

2006-07-30  Ilya Bobir  <ilya@@po4ta.com>

	* cygpath.cc (get_long_name): Fallback to get_long_path_name_w32impl.

2006-07-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygpath.c (get_long_name): Cover the case that GetLongPathName
	doesn't return valid information for non-existant files.  Just return
	incoming filename in that case.
@
text
@d3 1
a3 1
   Copyright 1999, 2001, 2002, 2004, 2006, 2007 Hat Inc.
d9 3
a11 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License (file COPYING.dumper) for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
a13 1
#include <ansidecl.h>
d26 1
d39 1
a39 1
static const char version[] = "$Revision: 1.12 $";
a658 2
      unsigned long phdr_type = PT_LOAD;

d666 1
a666 1
	  phdr_type = PT_LOAD;
a673 1
	  phdr_type = PT_NOTE;
a681 1
	  phdr_type = PT_NOTE;
a723 1
      new_section->lma = 0;
d727 1
a727 7
      int section_count = 1;

      bfd_boolean filehdr = 0;
      bfd_boolean phdrs = 0;

      bfd_vma at = 0;
      bfd_boolean valid_at = 0;
a728 44
      flagword flags = 0;
      bfd_boolean valid_flags = 1;

      if (p->type == pr_ent_memory)
	{
	  MEMORY_BASIC_INFORMATION mbi;
	  if (!VirtualQueryEx (hProcess, (LPVOID)sect_vma, &mbi, sizeof (mbi)))
	    {
	      bfd_perror ("getting mem region flags");
	      goto failed;
	    }

	  static const struct
	  {
	    DWORD protect;
	    flagword flags;
	  } mappings[] =
	    {
	      { PAGE_READONLY, PF_R },
	      { PAGE_READWRITE, PF_R | PF_W },
	      { PAGE_WRITECOPY, PF_W },
	      { PAGE_EXECUTE, PF_X },
	      { PAGE_EXECUTE_READ, PF_X | PF_R },
	      { PAGE_EXECUTE_READWRITE, PF_X | PF_R | PF_W },
	      { PAGE_EXECUTE_WRITECOPY, PF_X | PF_W }
	    };

	  for (size_t i = 0;
	       i < sizeof (mappings) / sizeof (mappings[0]);
	       i++)
	    if ((mbi.Protect & mappings[i].protect) != 0)
	      flags |= mappings[i].flags;
	}

      if (!bfd_record_phdr (core_bfd, phdr_type,
			    valid_flags, flags,
			    valid_at, at,
			    filehdr, phdrs,
			    section_count, &new_section))
	{
	  bfd_perror ("recording program headers");
	  goto failed;
	}
    }
@


1.11
log
@	* dumper.cc (dumper::prepare_core_dump): Use bfd_get_section_size
	instead of _raw_size.
	(dumper::write_core_dump): Likewise.
	* parse_pe.cc (select_data_section): Likewise.
@
text
@d39 1
a39 1
static const char version[] = "$Revision: 1.9 $";
d414 2
a415 2
         was active when exception occured, so let's blame
         the first one */
d798 1
a798 1
static void 
@


1.10
log
@* cygcheck.cc (usage) Add description output.
@
text
@d3 1
a3 1
   Copyright 1999, 2001, 2002 Red Hat Inc.
d692 2
a693 1
				     status_section->_raw_size + sect_size))
d750 1
a750 1
		  p->section->_raw_size,
@


1.9
log
@* dumper.cc (usage) Standardize usage output.  Generalize to allow use for
help.
(longopts) New struct.  Added longopts for all options.
(print_version) New function.
(main) Change getopt to getopt_long.  Accommodate new help and version options.
@
text
@d39 1
a39 1
static const char version[] = "$Revision: 1.8 $";
d780 1
@


1.8
log
@* dumper.cc (dumper::dumper): Print error code in case of error.
(dumper::add_thread): Ditto.
(dumper::collect_memory_sections): Ditto.
(dumper::dump_memory_region): Ditto.
(dumper::collect_process_information): Ditto.
(print_section_name): Fix formatting.
@
text
@d3 1
a3 1
   Copyright 1999,2001 Red Hat Inc.
d39 2
d775 1
a775 1
usage ()
d777 38
a814 6
  fprintf (stderr, "Usage: dumper [options] filename pid\n");
  fprintf (stderr, "filename -- dump core to filename.core\n");
  fprintf (stderr, "pid      -- win32-pid of process to dump\n\n");
  fprintf (stderr, "Possible options are:\n");
  fprintf (stderr, "-d       -- be verbose while dumping\n");
  fprintf (stderr, "-q       -- be quite while dumping (default)\n");
d825 1
a825 1
  while ((opt = getopt (argc, argv, "dq")) != EOF)
d834 5
d840 1
a840 1
	usage ();
d856 1
a856 1
      usage ();
@


1.7
log
@* dumper.cc (main): Properly recognize negative pids (used by w9x).
@
text
@d72 1
a72 1
      fprintf (stderr, "Failed to open process #%lu\n", pid);
d120 1
a120 1
  deb_printf ( " %s", bfd_get_section_name (abfd, sect));
d170 4
a173 1
    return 0;
d300 1
d317 1
a317 1
	      deb_printf ("warning: failed to read memory at %08x-%08x. protect = %s\n",
d320 1
a320 1
			  buf);
d373 1
a373 1
	  deb_printf ("Error reading process memory at %x(%x) %u\n", pos, todo, GetLastError ());
d504 1
a504 1
      fprintf (stderr, "Cannot attach to process #%lu", pid);
@


1.6
log
@* dumper.cc (main): Change command-line arguments format to be
similar to gdb. Allow adding error_start=x:\path\to\dumper.exe to
CYGWIN environment variable to perform core dumping in case of
program crash.
(usage): Ditto.
@
text
@d809 1
a809 1
      pid = atoi (*(argv + optind + 1));
@


1.5
log
@* dumper.h: Update copyright notice.
* dumper.cc: Ditto.
* dumper.cc: (dumper::print_core_section_list): New function.
* dumper.h: (dumper::print_core_section_list): Declare it.
* dumper.cc (print_section_name): New function.
(dumper::collect_process_information): Augment debugging output.
Stop debugee processing if it posts double exception.
(usage): Fix typo in option name.
@
text
@d39 1
a39 1
     BOOL verbose = FALSE;
d41 1
a41 1
     int deb_printf (const char *format,...)
d771 6
a776 4
  fprintf (stderr, "Usage: dumper [-d] [-c filename] pid\n");
  fprintf (stderr, "-c filename -- dump core to filename.core\n");
  fprintf (stderr, "-d          -- print some debugging info while dumping\n");
  fprintf (stderr, "pid         -- win32-pid of process to dump\n");
d785 1
d787 1
a787 1
  while ((opt = getopt (argc, argv, "dc:")) != EOF)
d793 5
a797 7
      case 'c':
	char win32_name[MAX_PATH];
	cygwin_conv_to_win32_path (optarg, win32_name);
	if ((p = strrchr (win32_name, '\\')))
	  p++;
	else
	  p = win32_name;
d801 16
a823 8

  if (argv && *(argv + optind))
    pid = atoi (*(argv + optind));
  else
    {
      usage ();
      return -1;
    }
@


1.4
log
@* dumper.cc (dumper::init_core_dump): Set architecture field in dump
header.
@
text
@d3 1
a3 1
   Copyright 1999 Cygnus Solutions.
d117 14
d493 2
d515 2
d556 6
d697 1
d700 8
d709 1
a709 2
      if (new_section == NULL ||
	  !bfd_set_section_flags (core_bfd, new_section, sect_flags) ||
d712 1
a712 1
	  bfd_perror ("creating section");
d771 1
a771 1
  fprintf (stderr, "Usage: dumper [-v] [-c filename] pid\n");
@


1.3
log
@* Makefile.in: Accomodate newer gcc's which require linking of c++ programs
with g++.  Fixup output for some compilations.
* cygcheck.cc: Respond to compiler warnings.
* dumper.cc (main): Ditto.
* parse_pe.cc (exclusion::sort_and_check): Ditto.
* setfacl.cc (getaclentry): Ditto.
@
text
@d596 6
@


1.2
log
@Cleanup formatting on some files.  Remove excessive whitespace.
@
text
@d82 1
a82 1
dumper: :~dumper ()
d743 1
a743 1
  char *p = "";
@


1.1
log
@* Makefile.in: Add dumper.exe target and associated mechanisms for building it.
* dumper.cc: New file.
* dumper.h: New file.
* module_info.cc: New file.
* parse_pe.cc: New file.
@
text
@d7 1
a7 1
This file is part of Cygwin.
d9 3
a11 3
This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */
d30 4
a33 4
{
  Elf_External_Note elf_note_header;
  char name [ NOTE_NAME_SIZE - 1 ]; /* external note contains first byte of data */
}
d35 1
a35 1
  __attribute__ ((packed))
d37 1
a37 1
note_header ;
d39 1
a39 1
BOOL verbose = FALSE;
d41 1
a41 1
int deb_printf ( const char* format, ... )
d43 2
a44 1
  if ( !verbose ) return 0;
d46 3
a48 3
  va_start ( va, format );
  int ret_val = vprintf ( format, va );
  va_end ( va );
d52 1
a52 1
dumper::dumper ( DWORD pid, DWORD tid, const char* file_name )
d54 1
a54 1
  this->file_name = strdup ( file_name );
d59 1
a59 1
  excl_list = new exclusion ( 20 );
d67 4
a70 4
  hProcess = OpenProcess ( PROCESS_ALL_ACCESS,
			   FALSE, /* no inheritance */
			   pid );
  if ( !hProcess )
d72 1
a72 1
      fprintf ( stderr, "Failed to open process #%lu\n", pid );
d78 2
a79 1
  if ( ! sane () ) dumper_abort ();
d82 1
a82 1
dumper::~dumper ()
d85 1
a85 1
  free ( file_name );
d92 1
a92 1
  unlink ( file_name );
d98 6
a103 3
  if ( core_bfd ) bfd_close ( core_bfd );
  if ( excl_list ) delete excl_list;
  if ( hProcess ) CloseHandle ( hProcess );
d112 2
a113 1
  if ( hProcess == NULL || core_bfd == NULL || excl_list == NULL ) return 0;
d117 2
a118 2
process_entity*
dumper::add_process_entity_to_list ( process_entity_type type )
d120 2
a121 1
  if ( ! sane () ) return NULL;
d123 3
a125 2
  process_entity* new_entity = ( process_entity* ) malloc ( sizeof ( process_entity ) );
  if ( new_entity == NULL ) return NULL;
d128 1
a128 1
  if ( last == NULL )
d137 1
a137 1
dumper::add_thread ( DWORD tid, HANDLE hThread )
d139 2
a140 1
  if ( ! sane () ) return 0 ;
d142 1
a142 1
  CONTEXT* pcontext;
d144 3
a146 2
  process_entity* new_entity = add_process_entity_to_list ( pr_ent_thread );
  if ( new_entity == NULL ) return 0;
d153 1
a153 1
  pcontext = &( new_entity->u.thread.context );
d155 2
a156 1
  if ( ! GetThreadContext ( hThread, pcontext ) ) return 0;
d158 1
a158 1
  deb_printf ( "added thread %u\n", tid );
d163 1
a163 1
dumper::add_mem_region ( LPBYTE base, DWORD size )
d165 2
a166 1
  if ( ! sane () ) return 0;
d168 2
a169 1
  if ( base == NULL || size == 0 ) return 1; // just ignore empty regions
d171 3
a173 2
  process_entity* new_entity = add_process_entity_to_list ( pr_ent_memory );
  if ( new_entity == NULL ) return 0;
d180 1
a180 1
  deb_printf ( "added memory region %08x-%08x\n", (DWORD)base, (DWORD)base + size );
d184 2
a185 4
/*
 * split_add_mem_region scans list of regions to be excluded from dumping process
 * (excl_list) and removes all "excluded" parts from given region
 */
d187 1
a187 1
dumper::split_add_mem_region ( LPBYTE base, DWORD size )
d189 2
a190 1
  if ( ! sane () ) return 0;
d192 2
a193 1
  if ( base == NULL || size == 0 ) return 1; // just ignore empty regions
d197 12
a208 11
  for ( process_mem_region* p = excl_list->region;
        p < excl_list->region + excl_list->last;
        p++ )
    {
      if ( p->base >= base + size || p->base + p->size <= base ) continue;

      if ( p->base <= base )
        {
          last_base = p->base + p->size;
          continue ;
        }
d210 1
a210 1
      add_mem_region ( last_base, p->base - last_base );
d214 2
a215 2
  if ( last_base < base + size )
    add_mem_region ( last_base, base + size - last_base );
d221 1
a221 1
dumper::add_module ( LPVOID base_address )
d223 2
a224 1
  if ( ! sane () ) return 0;
d226 3
a228 2
  char* module_name = psapi_get_module_name ( hProcess, (DWORD) base_address );
  if ( module_name == NULL ) return 1;
d230 3
a232 2
  process_entity* new_entity = add_process_entity_to_list ( pr_ent_module );
  if ( new_entity == NULL ) return 0;
d239 1
a239 1
  parse_pe ( module_name, excl_list );
d241 1
a241 1
  deb_printf ( "added module %08x %s\n", base_address, module_name );
d250 2
a251 1
  if ( ! sane () ) return 0;
d258 1
a258 1
  char mem_buf [ PAGE_BUFFER_SIZE ];
d262 2
a263 1
  if ( hProcess == NULL ) return 0;
d265 1
a265 1
  for ( current_page_address = 0; current_page_address < (LPBYTE) 0xFFFF0000; )
d267 2
a268 2
      if ( ! VirtualQueryEx ( hProcess, current_page_address, &mbi, sizeof ( mbi ) ) )
        break ;
d272 3
a274 2
      if ( mbi.Protect & ( PAGE_NOACCESS | PAGE_GUARD ) ||
           mbi.State != MEM_COMMIT ) skip_region_p = 1;
d276 27
a302 26
      if ( ! skip_region_p )
        {
          /* just to make sure that later we'll be able to read it.
             According to MS docs either region is all-readable or
             all-nonreadable */
	  if ( ! ReadProcessMemory ( hProcess, current_page_address, mem_buf, sizeof ( mem_buf ), &done ) )
            {
              const char* pt[10] ;
              pt[0] = ( mbi.Protect & PAGE_READONLY          ) ? "RO "   : "";
              pt[1] = ( mbi.Protect & PAGE_READWRITE         ) ? "RW "   : "";
              pt[2] = ( mbi.Protect & PAGE_WRITECOPY         ) ? "WC "   : "";
              pt[3] = ( mbi.Protect & PAGE_EXECUTE           ) ? "EX "   : "";
              pt[4] = ( mbi.Protect & PAGE_EXECUTE_READ      ) ? "EXRO " : "";
              pt[5] = ( mbi.Protect & PAGE_EXECUTE_READWRITE ) ? "EXRW " : "";
              pt[6] = ( mbi.Protect & PAGE_EXECUTE_WRITECOPY ) ? "EXWC " : "";
              pt[7] = ( mbi.Protect & PAGE_GUARD             ) ? "GRD "  : "";
              pt[8] = ( mbi.Protect & PAGE_NOACCESS          ) ? "NA " : "";
              pt[9] = ( mbi.Protect & PAGE_NOCACHE           ) ? "NC " : "";
              char buf [ 10*6 ] ;
              buf [ 0 ] = '\0';
              for ( int i = 0 ; i < 10 ; i++ ) strcat ( buf, pt[i] );

              deb_printf ( "warning: failed to read memory at %08x-%08x. protect = %s\n",
              		   (DWORD)current_page_address,
                           (DWORD)current_page_address + mbi.RegionSize,
                           buf );
d304 2
a305 2
            }
        }
d307 11
a317 11
      if ( ! skip_region_p )
        {
          if ( last_base + last_size == current_page_address )
            last_size += mbi.RegionSize;
          else
            {
              split_add_mem_region ( last_base, last_size );
              last_base = (LPBYTE) mbi.BaseAddress;
              last_size = mbi.RegionSize;
            }
        }
d319 2
a320 2
        {
	  split_add_mem_region ( last_base, last_size );
d322 2
a323 2
          last_size = 0;
        }
d329 1
a329 1
  split_add_mem_region ( last_base, last_size );
d334 1
a334 1
dumper::dump_memory_region ( asection* to, process_mem_region* memory )
d336 2
a337 1
  if ( ! sane () ) return 0;
d345 2
a346 1
  if ( to == NULL || memory == NULL ) return 0;
d348 1
a348 1
  char mem_buf [ PAGE_BUFFER_SIZE ];
d350 1
a350 1
  while ( size > 0 )
d352 2
a353 2
      todo = min ( size, PAGE_BUFFER_SIZE );
      if ( ! ReadProcessMemory ( hProcess, pos, mem_buf, todo, &done ) )
d355 1
a355 1
          deb_printf ( "Error reading process memory at %x(%x) %u\n", pos, todo, GetLastError () );
d360 6
a365 6
      if ( ! bfd_set_section_contents ( core_bfd, to, mem_buf, sect_pos, done ) )
        {
          bfd_perror ( "writing memory region to bfd" );
          dumper_abort ();
          return 0;
        } ;
d372 1
a372 1
dumper::dump_thread ( asection* to, process_thread* thread )
d374 2
a375 1
  if ( ! sane () ) return 0;
d377 2
a378 1
  if ( to == NULL || thread == NULL ) return 0;
d383 4
a386 4
  bfd_putl32 ( NOTE_NAME_SIZE, header.elf_note_header.namesz );
  bfd_putl32 ( sizeof ( thread_pstatus ), header.elf_note_header.descsz );
  bfd_putl32 ( NT_WIN32PSTATUS, header.elf_note_header.type );
  strncpy ( (char*) & header.elf_note_header.name, "win32thread", NOTE_NAME_SIZE );
d391 1
a391 1
  if ( tid == 0 )
d394 1
a394 1
         was active when exception occured, so let's blame 
d396 2
a397 2
      thread_pstatus.data.thread_info.is_active_thread = TRUE ;
      tid = (DWORD) -1 ;
d399 1
a399 1
  else if ( tid > 0 && thread->tid == tid )
d404 10
a413 10
  memcpy ( &(thread_pstatus.data.thread_info.thread_context),
  	   &(thread->context),
           sizeof ( thread->context ) );

  if ( ! bfd_set_section_contents ( core_bfd, to, &header,
						  0,
                                                  sizeof ( header ) ) ||
       ! bfd_set_section_contents ( core_bfd, to, &thread_pstatus,
						  sizeof ( header ),
						  sizeof ( thread_pstatus ) ) )
d415 1
a415 1
      bfd_perror ( "writing thread info to bfd" );
d418 1
a418 1
    } ;
d423 1
a423 1
dumper::dump_module ( asection* to, process_module* module )
d425 2
a426 1
  if ( ! sane () ) return 0;
d428 2
a429 1
  if ( to == NULL || module == NULL ) return 0;
d431 1
a431 1
  struct win32_pstatus* module_pstatus_ptr;
d433 1
a433 1
  int note_length = sizeof ( struct win32_pstatus ) + strlen ( module->name );
d435 1
a435 1
  char* buf = (char*) malloc ( note_length );
d437 1
a437 1
  if ( ! buf ) 
d439 1
a439 1
      fprintf ( stderr, "Error alloating memory. Dumping aborted.\n" );
d441 1
a441 1
    } ;
d443 1
a443 1
  module_pstatus_ptr = (struct win32_pstatus*) buf;
d446 4
a449 4
  bfd_putl32 ( NOTE_NAME_SIZE, header.elf_note_header.namesz );
  bfd_putl32 ( note_length, header.elf_note_header.descsz );
  bfd_putl32 ( NT_WIN32PSTATUS, header.elf_note_header.type );
  strncpy ( (char*) & header.elf_note_header.name, "win32module", NOTE_NAME_SIZE );
d453 2
a454 2
  module_pstatus_ptr->data.module_info.module_name_size = strlen ( module->name ) + 1;
  strcpy ( module_pstatus_ptr->data.module_info.module_name, module->name );
d456 6
a461 6
  if ( ! bfd_set_section_contents ( core_bfd, to, &header,
						  0,
                                                  sizeof ( header ) ) ||
       ! bfd_set_section_contents ( core_bfd, to, module_pstatus_ptr,
						  sizeof ( header ),
						  note_length ) )
d463 1
a463 1
      bfd_perror ( "writing module info to bfd" );
d469 2
a470 1
  if ( buf ) free ( buf );
d479 2
a480 1
  if ( ! sane () ) return 0;
d482 1
a482 1
  if ( ! DebugActiveProcess ( pid ) )
d484 1
a484 1
      fprintf ( stderr, "Cannot attach to process #%lu", pid );
d488 3
a490 3
  char event_name [ sizeof ( "cygwin_error_start_event" ) + 20 ];
  sprintf ( event_name, "cygwin_error_start_event%16lx", pid );
  HANDLE sync_with_debugee = OpenEvent ( EVENT_MODIFY_STATE, FALSE, event_name  );
d496 2
a497 1
      if ( ! WaitForDebugEvent ( &current_event, 20000 ) ) return 0;
d503 2
a504 2
	  if ( ! add_thread ( current_event.dwThreadId,
			      current_event.u.CreateThread.hThread ) )
d511 4
a514 4
	  if ( ! add_module ( current_event.u.CreateProcessInfo.lpBaseOfImage ) ||
	       ! add_thread ( current_event.dwThreadId,
			      current_event.u.CreateProcessInfo.hThread ) )
  	    goto failed;
d520 4
a523 4
          deb_printf ( "debugee quits" );
          ContinueDebugEvent ( current_event.dwProcessId,
			       current_event.dwThreadId,
                               DBG_CONTINUE );
d531 2
a532 2
          if ( ! add_module ( current_event.u.LoadDll.lpBaseOfDll ) )
     	    goto failed;
d538 1
a538 1
          collect_memory_sections ();
d540 1
a540 1
          /* got all info. time to dump */
d542 1
a542 1
	  if ( ! prepare_core_dump () )
d544 1
a544 1
	      fprintf ( stderr, "Failed to prepare core dump\n" );
d548 1
a548 1
	  if ( ! write_core_dump () )
d550 1
a550 1
	      fprintf ( stderr, "Failed to write core dump\n" );
d554 3
a556 2
          /* signal a debugee that we've finished */
          if ( sync_with_debugee ) SetEvent ( sync_with_debugee );
d566 3
a568 3
      ContinueDebugEvent ( current_event.dwProcessId,
			   current_event.dwThreadId,
                           DBG_CONTINUE );
d572 2
a573 1
  if ( sync_with_debugee ) SetEvent ( sync_with_debugee );
d583 2
a584 2
  core_bfd = bfd_openw ( file_name, "elf32-i386" );
  if ( core_bfd == NULL )
d586 1
a586 1
      bfd_perror ( "opening bfd" );
d590 1
a590 1
  if ( ! bfd_set_format ( core_bfd, bfd_core ) )
d592 1
a592 1
      bfd_perror ( "setting bfd format" );
d607 2
a608 1
  if ( ! sane () ) return 0;
d611 1
a611 1
  char sect_name [ 50 ];
d617 1
a617 1
  asection* new_section;
d619 1
a619 1
  for ( process_entity* p = list; p != NULL; p = p->next )
d623 24
a646 24
      switch ( p->type )
        {
        case pr_ent_memory:
          sprintf ( sect_name, ".mem/%u", sect_no );
          sect_flags = SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD;
          sect_size = p->u.memory.size;
          sect_vma = (bfd_vma)(p->u.memory.base);

          break;

        case pr_ent_thread:
          sprintf ( sect_name, ".note/%u", sect_no );
          sect_flags = SEC_HAS_CONTENTS | SEC_LOAD;
          sect_size = sizeof ( note_header ) +  sizeof ( struct win32_pstatus );
          sect_vma = 0;
	  break;

        case pr_ent_module:
          sprintf ( sect_name, ".note/%u", sect_no );
          sect_flags = SEC_HAS_CONTENTS | SEC_LOAD;
          sect_size = sizeof ( note_header ) + sizeof ( struct win32_pstatus ) +
			     (bfd_size_type)( strlen (p->u.module.name) );
          sect_vma = 0;
          break;
d648 1
a648 1
        default:
d650 1
a650 1
        }
d652 5
a656 5
      if ( p->type == pr_ent_module && status_section != NULL )
        {
	  if ( ! bfd_set_section_size  ( core_bfd,
					 status_section,
                                         status_section->_raw_size + sect_size ) )
d658 1
a658 1
	      bfd_perror ( "resizing status section" );
d661 2
a662 2
          continue;
        }
d664 2
a665 2
      deb_printf ( "creating section (type%u) %s(%u), flags=%08x\n",
		    p->type, sect_name, sect_size, sect_flags );
d667 2
a668 2
      char* buf = strdup ( sect_name );
      new_section = bfd_make_section ( core_bfd, buf );
d670 3
a672 3
      if ( new_section == NULL ||
	   ! bfd_set_section_flags ( core_bfd, new_section, sect_flags ) ||
	   ! bfd_set_section_size  ( core_bfd, new_section, sect_size  ) )
d674 1
a674 1
	  bfd_perror ( "creating section" );
d694 2
a695 1
  if ( ! sane () ) return 0;
d697 1
a697 1
  for ( process_entity* p = list; p != NULL; p = p->next )
d699 2
a700 1
      if ( p->section == NULL ) continue;
d702 5
a706 5
      deb_printf ( "writing section type=%u base=%08x size=%08x flags=%08x\n",
		   p->type,
                   p->section->vma,
                   p->section->_raw_size,
                   p->section->flags );
d708 5
a712 5
      switch ( p->type )
        {
        case pr_ent_memory:
	  dump_memory_region ( p->section, &(p->u.memory) );
          break;
d714 2
a715 2
        case pr_ent_thread:
	  dump_thread ( p->section, &(p->u.thread) );
d718 3
a720 3
        case pr_ent_module:
          dump_module ( p->section, &(p->u.module) );
          break;
d722 1
a722 1
        default:
d725 1
a725 1
        }
d733 4
a736 4
  fprintf ( stderr, "Usage: dumper [-v] [-c filename] pid\n" );
  fprintf ( stderr, "-c filename -- dump core to filename.core\n" );
  fprintf ( stderr, "-d          -- print some debugging info while dumping\n" );
  fprintf ( stderr, "pid         -- win32-pid of process to dump\n" );
d740 1
a740 1
main( int argc, char** argv )
d743 1
a743 1
  char* p = "";
d753 3
a755 3
	char win32_name [ MAX_PATH ];
	cygwin_conv_to_win32_path ( optarg, win32_name );
	if ( ( p = strrchr ( win32_name, '\\' ) ) )
d762 2
a763 2
  char* core_file = (char*) malloc ( strlen ( p ) + sizeof ( ".core" ) );
  if ( ! core_file )
d765 1
a765 1
      fprintf ( stderr, "error allocating memory\n" );
d768 1
a768 1
  sprintf ( core_file, "%s.core", p );
d770 2
a771 2
  if ( argv && *(argv+optind) )
    pid = atoi ( *(argv+optind) );
d780 2
a781 2
  if ( verbose )
    printf ( "dumping process #%lu to %s\n", pid, core_file );
d783 2
a784 2
  dumper d ( pid, tid, core_file );
  if ( ! d.sane () )
d787 1
a787 1
  free ( core_file );
@

