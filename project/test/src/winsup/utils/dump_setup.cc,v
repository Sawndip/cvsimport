head	1.29;
access;
symbols
	cygwin-1_7_35-release:1.29
	cygwin-1_7_34-release:1.28
	cygwin-1_7_33-release:1.28
	cygwin-1_7_32-release:1.28
	cygwin-1_7_31-release:1.28
	cygwin-1_7_30-release:1.28
	cygwin-1_7_29-release:1.28
	cygwin-1_7_29-release-branchpoint:1.28.0.2
	cygwin-1_7_28-release:1.28
	cygwin-1_7_27-release:1.28
	cygwin-1_7_26-release:1.28
	cygwin-1_7_25-release:1.27
	cygwin-1_7_24-release:1.27
	cygwin-1_7_23-release:1.27
	cygwin-1_7_22-release:1.27
	cygwin-1_7_21-release:1.27
	cygwin-1_7_20-release:1.27
	cygwin-1_7_19-release:1.27
	cygwin-64bit-postmerge:1.27
	cygwin-64bit-premerge-branch:1.27.0.2
	cygwin-64bit-premerge:1.27
	cygwin-1_7_18-release:1.27
	cygwin-1_7_17-release:1.24
	cygwin-64bit-branch:1.24.0.2
	cygwin-1_7_16-release:1.24
	cygwin-1_7_15-release:1.23
	cygwin-1_7_14_2-release:1.23
	cygwin-1_7_14-release:1.23
	cygwin-1_7_12-release:1.23
	cygwin-1_7_11-release:1.23
	cygwin-1_7_10-release:1.23
	cygwin-1_7_9-release:1.22
	cygwin-1_7_8-release:1.22
	cygwin-1_7_7-release:1.22
	cygwin-1_7_5-release:1.20
	cygwin-1_7_4-release:1.20
	cygwin-1_7_3-release:1.20
	cygwin-1_7_2-release:1.20
	cygwin-1_7_1-release:1.20
	cv-branch-2:1.20.0.2
	cr-0x5f1:1.18.0.6
	cv-branch:1.18.0.4
	cr-0x3b58:1.18.0.2
	cr-0x9e:1.14.0.8
	cr-0x9d:1.14.0.6
	corinna-01:1.14
	cr-0x9c:1.14.0.2
	cr-0x9b:1.14.0.4
	cr-0x99:1.12
	Z-emcb-cygwin_daemon:1.12.0.2
	w32api-2_2:1.6
	mingw-runtime-2_4:1.6
	cygnus_cvs_20020108_pre:1.3;
locks; strict;
comment	@// @;


1.29
date	2015.02.17.23.36.23;	author kbrown;	state Exp;
branches;
next	1.28;

1.28
date	2013.09.16.17.01.58;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2013.01.21.16.28.27;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2012.11.26.13.13.25;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2012.11.23.13.22.47;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2012.07.11.16.41.51;	author corinna;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2011.12.17.23.39.47;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2010.07.21.10.30.53;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2010.07.05.12.28.48;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2008.09.12.22.43.10;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2008.08.27.20.11.11;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2005.12.19.16.58.33;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2004.10.25.15.49.36;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2004.09.23.10.32.20;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2004.09.22.11.50.51;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2003.09.08.02.50.02;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.06.02.02.30;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2003.08.17.17.26.08;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2003.08.16.09.09.09;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2003.08.15.20.26.11;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2003.08.13.19.37.40;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2003.08.10.01.07.04;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.09.16.32.22;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.07.21.34.34;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.07.21.11.44;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.29.18.37.00;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.12.00.14.27;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.11.06.16.18;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2001.11.11.06.07.36;	author cgf;	state Exp;
branches;
next	;

1.24.2.1
date	2012.08.16.16.26.01;	author corinna;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2012.11.22.12.11.07;	author corinna;	state Exp;
branches;
next	1.24.2.3;

1.24.2.3
date	2012.11.23.15.14.40;	author corinna;	state Exp;
branches;
next	1.24.2.4;

1.24.2.4
date	2012.11.26.13.13.28;	author corinna;	state Exp;
branches;
next	1.24.2.5;

1.24.2.5
date	2013.01.29.21.54.42;	author corinna;	state Exp;
branches;
next	;


desc
@@


1.29
log
@* dump_setup.cc (check_package_files): Accommodate postinstall
files in any directory whose name contains "/postinstall/", not
just /etc/postinstall.
@
text
@/* dump_setup.cc

   Copyright 2001, 2002, 2003, 2004, 2005, 2008, 2010, 2011, 2012 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <io.h>
#include <sys/stat.h>
#include <errno.h>
#define WIN32_NO_STATUS	/* Disable status codes in winnt.h since we include
			   ntstatus.h for extended status codes below. */
#include <windows.h>
#undef WIN32_NO_STATUS
#include <winternl.h>
#include <ntstatus.h>
#include "path.h"
#include <zlib.h>

static int package_len = 20;
static unsigned int version_len = 10;


typedef struct
{
  char pkgtar[MAX_PATH + 1];
  char pkg[MAX_PATH + 1];
  char ver[MAX_PATH + 1];
  char tail[MAX_PATH + 1];
  char what[16];
} fileparse;

static int
find_tar_ext (const char *path)
{
  char *p = strchr (path, '\0') - 9;
  if (p <= path)
    return 0;
  if ((p = strstr (p, ".tar")) != NULL)
    return p - path;
  else
    return 0;
}

static char *
base (const char *s)
{
  if (!s)
    return 0;
  const char *rv = s;
  while (*s)
    {
      if ((*s == '/' || *s == ':' || *s == '\\') && s[1])
	rv = s + 1;
      s++;
    }
  return (char *) rv;
}

/* Parse a filename into package, version, and extension components. */
int
parse_filename (const char *in_fn, fileparse& f)
{
  char *p, *ver;
  char fn[strlen (in_fn) + 1];

  strcpy (fn, in_fn);
  int n = find_tar_ext (fn);

  if (!n)
    return 0;

  strcpy (f.tail, fn + n);
  fn[n] = '\0';
  f.pkg[0] = f.what[0] = '\0';
  p = base (fn);
  for (ver = p; *ver; ver++)
    if (*ver != '-')
      continue;
    else if (isdigit (ver[1]))
      {
	*ver++ = '\0';
	strcpy (f.pkg, p);
	break;
      }
    else if (strcasecmp (ver, "-src") == 0 ||
	     strcasecmp (ver, "-patch") == 0)
      {
	*ver++ = '\0';
	strcpy (f.pkg, p);
	strcpy (f.what, strlwr (ver));
	strcpy (f.pkgtar, p);
	strcat (f.pkgtar, f.tail);
	ver = strchr (ver, '\0');
	break;
      }

  if (!f.pkg[0])
    strcpy (f.pkg, p);

  if (!f.what[0])
    {
      int n;
      p = strchr (ver, '\0');
      strcpy (f.pkgtar, in_fn);
      if ((p -= 4) >= ver && strcasecmp (p, "-src") == 0)
	n = 4;
      else if ((p -= 2) >= ver && strcasecmp (p, "-patch") == 0)
	n = 6;
      else
	n = 0;
      if (n)
	{
	  strcpy (f.what, p + 1);
	  *p = '\0';
	  p = f.pkgtar + (p - fn) + n;
	  memmove (p - 4, p, strlen (p));
	}
    }

  strcpy (f.ver, *ver ? ver : "0.0");
  return 1;
}

static bool
dump_file (const char *msg, const char *fn)
{
  char buf[4096];
  bool printed = false;
  bool found = false;
  size_t len = strlen (fn);
  char *path = cygpath ("/etc/setup/setup.rc", NULL);
  FILE *fp = fopen (path, "rt");

  if (fp)
    {
      while (fgets (buf, 4096, fp))
      	{
	  if (found)
	    {
	      char *bufp = buf;

	      if (*bufp == '\t')
	      	++bufp;
	      char *p = strchr (bufp, '\0');
	      printf ("%s%s%s", msg, bufp,
				(p == bufp) || p[-1] != '\n' ? "\n" : "");
	      printed = true;
	      break;
	    }
	  if (!strncmp (buf, fn, len) && buf[len] == '\n')
	    found = true;
	}
      fclose (fp);
    }
  return printed;
}

struct pkgver
{
  char *name;
  char *ver;
};

extern "C" {
int
compar (const void *a, const void *b)
{
  const pkgver *pa = (const pkgver *) a;
  const pkgver *pb = (const pkgver *) b;
  return strcasecmp (pa->name, pb->name);
}
}

int
match_argv (char **argv, const char *name)
{
  if (!argv || !*argv)
    return -1;
  for (char **a = argv; *a; a++)
    if (strcasecmp (*a, name) == 0)
      return a - argv + 1;
  return 0;
}

static bool
could_not_access (int verbose, char *filename, char *package, const char *type)
{
  switch (errno)
    {
      case ENOTDIR:
	break;
      case ENOENT:
	if (verbose)
	  printf ("Missing %s: /%s from package %s\n",
		  type, filename, package);
	return true;
      case EACCES:
	if (verbose)
	  printf ("Unable to access %s /%s from package %s\n",
		  type, filename, package);
	return true;
    }
  return false;
}

static const WCHAR tfx_chars[] = {
	    0, 0xf000 |   1, 0xf000 |   2, 0xf000 |   3,
 0xf000 |   4, 0xf000 |   5, 0xf000 |   6, 0xf000 |   7,
 0xf000 |   8, 0xf000 |   9, 0xf000 |  10, 0xf000 |  11,
 0xf000 |  12, 0xf000 |  13, 0xf000 |  14, 0xf000 |  15,
 0xf000 |  16, 0xf000 |  17, 0xf000 |  18, 0xf000 |  19,
 0xf000 |  20, 0xf000 |  21, 0xf000 |  22, 0xf000 |  23,
 0xf000 |  24, 0xf000 |  25, 0xf000 |  26, 0xf000 |  27,
 0xf000 |  28, 0xf000 |  29, 0xf000 |  30, 0xf000 |  31,
	  ' ',          '!', 0xf000 | '"',          '#',
	  '$',          '%',          '&',           39,
	  '(',          ')', 0xf000 | '*',          '+',
	  ',',          '-',          '.',          '\\',
	  '0',          '1',          '2',          '3',
	  '4',          '5',          '6',          '7',
	  '8',          '9', 0xf000 | ':',          ';',
 0xf000 | '<',          '=', 0xf000 | '>', 0xf000 | '?',
	  '@@',          'A',          'B',          'C',
	  'D',          'E',          'F',          'G',
	  'H',          'I',          'J',          'K',
	  'L',          'M',          'N',          'O',
	  'P',          'Q',          'R',          'S',
	  'T',          'U',          'V',          'W',
	  'X',          'Y',          'Z',          '[',
	  '\\',          ']',          '^',          '_',
	  '`',          'a',          'b',          'c',
	  'd',          'e',          'f',          'g',
	  'h',          'i',          'j',          'k',
	  'l',          'm',          'n',          'o',
	  'p',          'q',          'r',          's',
	  't',          'u',          'v',          'w',
	  'x',          'y',          'z',          '{',
 0xf000 | '|',          '}',          '~',          127
};

static void
transform_chars (PWCHAR path, PWCHAR path_end)
{
  for (; path <= path_end; ++path)
    if (*path < 128)
      *path = tfx_chars[*path];
}

extern "C" NTAPI NTSTATUS NtQueryAttributesFile (POBJECT_ATTRIBUTES,
						 PFILE_BASIC_INFORMATION);

/* This function checks for file existance and fills the stat structure
   with only the required mode info.  We're using a native NT function
   here, otherwise we wouldn't be able to check for files with special
   characters not valid in Win32, and espacially not valid using the
   ANSI API. */
static int
simple_nt_stat (const char *filename, struct stat *st)
{
  size_t len = mbstowcs (NULL, filename, 0) + 1;
  WCHAR path[len + 8];	/* Enough space for the NT prefix */
  PWCHAR p = path;
  UNICODE_STRING upath;
  OBJECT_ATTRIBUTES attr;
  FILE_BASIC_INFORMATION fbi;
  NTSTATUS status;

  wcscpy (p, L"\\??\\");
  p += 4;
  if (filename[0] == '\\' && filename[1] == '\\')
    {
      wcscpy (p, L"UNC");
      p += 3;
      p += mbstowcs (p, filename + 1, len);
    }
  else
    p += mbstowcs (p, filename, len);
  /* Remove trailing backslashes.  NT functions don't like them. */
  if (p[-1] == L'\\')
    *--p = L'\0';
  /* Skip prefix and drive, otherwise question marks and colons are converted
     as well. */
  transform_chars (path + 7, p);
  RtlInitUnicodeString (&upath, path);
  InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE, NULL, NULL);
  status = NtQueryAttributesFile (&attr, &fbi);
  if (NT_SUCCESS (status))
    {
      st->st_mode = (fbi.FileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		    ? S_IFDIR : S_IFREG;
      return 0;
    }
  if (status == STATUS_OBJECT_PATH_NOT_FOUND
      || status == STATUS_OBJECT_NAME_INVALID
      || status == STATUS_BAD_NETWORK_PATH
      || status == STATUS_BAD_NETWORK_NAME
      || status == STATUS_NO_MEDIA_IN_DEVICE
      || status == STATUS_OBJECT_NAME_NOT_FOUND
      || status == STATUS_NO_SUCH_FILE)
    errno = ENOENT;
  else
    errno = EACCES;
  return -1;
}

static bool
directory_exists (int verbose, char *filename, char *package)
{
  struct stat status;
  if (simple_nt_stat(cygpath("/", filename, NULL), &status))
    {
      if (could_not_access (verbose, filename, package, "directory"))
	return false;
    }
  else if (!S_ISDIR(status.st_mode))
    {
      if (verbose)
	printf ("Directory/file mismatch: /%s from package %s\n", filename, package);
      return false;
    }
  return true;
}

static bool
file_exists (int verbose, char *filename, const char *alt, char *package)
{
  struct stat status;
  if (simple_nt_stat(cygpath("/", filename, NULL), &status) &&
      (!alt || simple_nt_stat(cygpath("/", filename, alt, NULL), &status)))
    {
      if (could_not_access (verbose, filename, package, "file"))
	return false;
    }
  else if (!S_ISREG(status.st_mode))
    {
      if (verbose)
	printf ("File type mismatch: /%s from package %s\n", filename, package);
      return false;
    }
  return true;
}

static gzFile
open_package_list (char *package)
{
  char filelist[MAX_PATH + 1] = "/etc/setup/";
  strcat (strcat (filelist, package), ".lst.gz");
  if (!file_exists (false, filelist + 1, NULL, NULL))
    return NULL;

  gzFile fp;
#ifndef ZLIB_VERSION
  fp = NULL;
#else
  char *fn = cygpath (filelist, NULL);
  fp = gzopen (fn, "rb9");
  free (fn);
#endif

  return fp;
}

static bool
check_package_files (int verbose, char *package)
{
  gzFile fp = open_package_list (package);
  if (!fp)
    {
      if (verbose)
	printf ("Empty package %s\n", package);
      return true;
    }

  bool result = true;
  char buf[MAX_PATH + 1];
  while (gzgets (fp, buf, MAX_PATH))
    {
      char *filename = strtok(buf, "\n");

      if (*filename == '/')
	++filename;
      else if (!strncmp (filename, "./", 2))
	filename += 2;

      if (filename[strlen (filename) - 1] == '/')
	{
	  if (!directory_exists (verbose, filename, package))
	    result = false;
	}
      else if (strstr (filename, "/postinstall/"))
	{
	  if (!file_exists (verbose, filename, ".done", package))
	    result = false;
	}
      else
	{
	  if (!file_exists (verbose, filename, ".lnk", package))
	    result = false;
	}
    }

  gzclose (fp);
  return result;
}

/**
 * Returns a calloc'd sorted list of packages or NULL if no info.
 * The last entry in the list is {NULL,NULL}.
 */
static pkgver *
get_packages (char **argv)
{
  char *setup = cygpath ("/etc/setup/installed.db", NULL);
  FILE *fp = fopen (setup, "rt");

  if (fp == NULL)
    return NULL;

  int nlines;
  nlines = 0;
  char buf[4096];
  while (fgets (buf, 4096, fp))
    nlines += 2;	/* potentially binary + source */
  if (!nlines)
    {
      fclose (fp);
      return NULL;
    }
  rewind (fp);

  pkgver *packages;

  packages = (pkgver *) calloc (nlines + 1, sizeof(packages[0]));
  int n;
  for (n = 0; fgets (buf, 4096, fp) && n < nlines;)
    {
      char *package = strtok (buf, " ");
      if (!package || !*package || !match_argv (argv, package))
	continue;
      for (int i = 0; i < 2; i++)
	{
	  fileparse f;
	  char *tar = strtok (NULL, " ");
	  if (!tar || !*tar || !parse_filename (tar, f))
	    break;

	  int len = strlen (package);
	  if (f.what[0])
	    len += strlen (f.what) + 1;
	  if (len > package_len)
	    package_len = len;
	  packages[n].name = (char *) malloc (len + 1);
	  strcpy (packages[n].name, package);
	  if (f.what[0])
	    strcat (strcat (packages[n].name, "-"), f.what);
	  packages[n].ver = strdup (f.ver);
	  if (strlen(f.ver) > version_len)
	    version_len = strlen(f.ver);
	  n++;
	  if (strtok (NULL, " ") == NULL)
	    break;
	}
    }

  packages[n].name = packages[n].ver = NULL;

  qsort (packages, n, sizeof (packages[0]), compar);

  fclose (fp);

  return packages;
}

void
dump_setup (int verbose, char **argv, bool check_files)
{
  pkgver *packages = get_packages(argv);

  puts ("Cygwin Package Information");
  if (packages == NULL)
    {
      puts ("No setup information found");
      return;
    }

  if (verbose)
    {
      bool need_nl = dump_file ("Last downloaded files to: ", "last-cache");
      if (dump_file ("Last downloaded files from: ", "last-mirror") || need_nl)
	puts ("");
    }

  printf ("%-*s %-*s%s\n", package_len, "Package",
			   check_files ? version_len : 7, "Version",
			   check_files ? "     Status" : "");
  for (int i = 0; packages[i].name; i++)
    {
      if (check_files)
	printf ("%-*s %-*s%s\n", package_len, packages[i].name,
		version_len, packages[i].ver,
		check_package_files (verbose, packages[i].name)
		  ? "     OK" : "     Incomplete");
      else
	printf ("%-*s %s\n", package_len, packages[i].name, packages[i].ver);
      fflush(stdout);
    }

  free (packages);

  return;
}

void
package_list (int verbose, char **argv)
{
  pkgver *packages = get_packages(argv);
  if (packages == NULL)
    {
      puts ("No setup information found");
      return;
    }

  for (int i = 0; packages[i].name; i++)
    {
      gzFile fp = open_package_list (packages[i].name);
      if (!fp)
	{
	  if (verbose)
	    printf ("Can't open file list /etc/setup/%s.lst.gz for package %s\n",
		packages[i].name, packages[i].name);
	  continue;
	}

      if (verbose)
	printf ("Package: %s-%s\n", packages[i].name, packages[i].ver);

      char buf[MAX_PATH + 1];
      while (gzgets (fp, buf, MAX_PATH))
	{
	  char *lastchar = strchr(buf, '\n');
	  if (lastchar[-1] != '/')
	    printf ("%s/%s", (verbose?"    ":""), buf);
	}

      gzclose (fp);
    }

  free (packages);

  return;
}

void
package_find (int verbose, char **argv)
{
  pkgver *packages = get_packages(NULL);
  if (packages == NULL)
    {
      puts ("No setup information found");
      return;
    }

  for (int i = 0; packages[i].name; i++)
    {
      gzFile fp = open_package_list (packages[i].name);
      if (!fp)
	continue;

      char buf[MAX_PATH + 2];
      buf[0] = '/';
      while (gzgets (fp, buf + 1, MAX_PATH))
	{
	  char *filename = strtok(buf, "\n");
	  int flen = strlen (filename);
	  if (filename[flen - 1] != '/')
	    {
	      // FIXME: verify that /bin is mounted on /usr/bin; ditto for /lib
	      bool is_alias = !strncmp(filename, "/usr/bin/", 9) ||
			      !strncmp(filename, "/usr/lib/", 9);
	      int a = match_argv (argv, filename);
	      if (!a && is_alias)
		a = match_argv (argv, filename + 4);
	      if (!a && !strcmp(filename + flen - 4, ".exe"))
		{
		  filename[flen - 4] = '\0';
		  a = match_argv (argv, filename);
		}
	      if (!a && is_alias)
		a = match_argv (argv, filename + 4);
	      if (a > 0)
		{
		  if (verbose)
		    printf ("%s: found in package ", filename);
		  printf ("%s-%s\n", packages[i].name, packages[i].ver);
		}
	    }
	}

      gzclose (fp);
    }

  free (packages);

  return;
}

@


1.28
log
@* dump_setup.cc (find_tar_ext): Generalize search for .tar extension, avoiding
looking for specific compression types.
@
text
@d399 1
a399 1
      else if (!strncmp (filename, "etc/postinstall/", 16))
@


1.27
log
@Update copyrights
@
text
@d44 1
a44 1
  char *p = strchr (path, '\0') - 7;
d47 3
a49 6
  if (*p == '.')
    {
      if (strcmp (p, ".tar.gz") != 0)
	return 0;
    }
  else if (--p <= path || strcmp (p, ".tar.bz2") != 0)
a50 2

  return p - path;
@


1.26
log
@	* bloda.cc: Drop Mingw.org considerations.
	* dump_setup.cc: Ditto.
	* strace.cc: Ditto.
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003, 2004, 2005, 2008, 2010, 2012 Red Hat, Inc.
@


1.25
log
@ChangeLog:
2012-11-12  Christopher Faylor  <me.cygwin2012@@cgf.cx>

	* Makefile.common: Revamp for new configury.  Add default compilation
	targets, include .E processing.  Add magic for allowing "CFLAGS" to
	control optimization options in "CXXFLAGS".
	* configure.cygwin: New include for Cygwin configure.in's.
	* acinclude.m4: Delete old definitions.  Implement AC_WINDOWS_HEADERS,
	AC_WINDOWS_LIBS, AC_CYGWIN_INCLUDES, target_builddir, winsup_srcdir.
	* aclocal.m4: Regenerate.
	* autogen.sh: New file.
	* ccwrap: New script.
	* c++wrap: New script.
	* config.guess: New script.
	* config.sub: New script.
	* configure: Regenerate.
	* configure.in: Eliminate LIB_AC_PROG_* calls in favor of standard.
	Delete ancient target test.
	* install-sh: New script.

cygserver/ChangeLog:
2012-11-12  Christopher Faylor  <me.cygwin2012@@cgf.cx>

	* Makefile.in: Revamp for new configury.
	* configure.in: Revamp for new configury.
	* aclocal.m4: Regenerate.
	* configure: Ditto.
	* autogen.sh: New script.

cygwin/ChangeLog:
2012-11-22  Christopher Faylor  <me.cygwin2012@@cgf.cx>

	* select.cc (select): Don't return -1 when we've timed out after
	looping.

2012-11-22  Christopher Faylor  <me.cygwin2012@@cgf.cx>

	* Makefile.in: Revamp for new configury.
	(datarootdir): Add variable setting.
	(winver_stamp): Accommodate changes to mkvers.sh setting.
	(libc.a): Fix race when libm.a might not have been built yet.
	* configure.in: Revamp for new configury.
	* aclocal.m4: Regenerate.
	* configure: Ditto.
	* autogen.sh: New script.
	* mkvers.sh: Find include directives via CFLAGS and friends rather than
	assuming that w32api lives nearby.

utils/ChangeLog:
2012-11-12  Christopher Faylor  <me.cygwin2012@@cgf.cx>

	* aclocal.m4: Regenerate.
	* configure: Ditto.
	* autogen.sh: New script.
	* configure.in: Revamp for new configury.
	* Makefile.in: Revamp for new configury.  Rename ALL_* to just *.
	Always use "VERBOSE" setting.
	(MINGW_CXX): Don't include CFLAGS in definition.
	(all): Define target first, before everything else so that it is the
	default.
	(ps.exe): Don't add useless -lcygwin.
	(ldh.exe): For consistency, add to existing MINGW_LDFLAGS rather than
	redefining them.
	(cygcheck.exe): Always include -lz for MINGW_LDFLAGS.  Don't try to
	figure out where to find it.
	(dumper.exe): Simplify check.  Assume libraries are installed rather
	than trying to retrieve from source tree.
	(install): Just use /bin/mkdir to create directories.
	(Makefile): Regenerate when standard dependencies change.
	* dump_setup.cc: Always include zlib.h.  Remove accommodations for it
	possibly not existing.
	* parse_pe.cc: Add define which allows building with installed
	binutils package.
	* dumper.cc: Ditto.
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003, 2004, 2005, 2008, 2010 Red Hat, Inc.
d23 2
a24 7
#ifndef __MINGW64_VERSION_MAJOR
# include <ddk/ntapi.h>
# include <ddk/winddk.h>
#else
# include <winternl.h>
# include <ntstatus.h>
#endif
@


1.24
log
@	* Makefile.in (cygcheck.exe): Link against psapi.dll.
	* bloda.cc: Change include section to work with Mingw64 headers.
	Include psapi.h.  Use SystemProcessInformation instead of
	SystemProcessesAndThreadsInformation throughout and add define for
	w32api headers.  Ditto for PSYSTEM_PROCESS_INFORMATION vs.
	PSYSTEM_PROCESSES.
	(system_module_list): New type to replace SYSTEM_MODULE_INFORMATION.
	Change usage throughout accordingly.
	(get_module_list): Fetch module list using PSAPI functions
	EnumDeviceDrivers and GetDeviceDriverBaseNameA.
	* cygcheck.cc (max): Define as __max if not defined already.
	(alloca): Only define if not defined already.
	(handle_unique_object_name): Use explicit sharing flags rather than
	FILE_SHARE_VALID_FLAGS which officially is only available in DDK
	headers.
	(PRODUCT_ULTIMATE_E): Only define if not defined already.
	* dump_setup.cc: Change include section to work with Mingw64 headers.
	(NtQueryAttributesFile): Drop NTOSAPI aka DECLSPEC_IMPORT.
	* strace.cc: Change include section to work with Mingw64 headers.
	(alloca): Only define if not defined already.
@
text
@d31 1
a31 9
#if 0
#include "zlib.h"
#endif

#ifndef ZLIB_VERSION
typedef void * gzFile;
#define gzgets(fp, buf, size) ({0;})
#define gzclose(fp) ({0;})
#endif
@


1.24.2.1
log
@	* cygcheck.cc: Change include path to not depend on installed
	cygwin/version.h.
	(_NOMNTENT_MACROS): Define before including mntent.h.
	* path.cc (_NOMNTENT_MACROS): Ditto.
	* dump_setup.cc: Add temporary workaround to handle older Mingw header
	files on Fedora 17.
	* strace.cc: Ditto.
@
text
@a34 5
/* Temporary workaround for older Mingw header files on Fedora 17. */
#ifndef NT_SUCCESS
#define NT_SUCCESS(status) ((NTSTATUS) (status) >= 0)
#endif

@


1.24.2.2
log
@	* dump_setup.cc: Drop temporary workaround to handle older Mingw header
	files on Fedora 17.
	* strace.cc: Ditto.
@
text
@d35 5
@


1.24.2.3
log
@Pull in changes from HEAD
@
text
@d31 9
a39 1
#include <zlib.h>
@


1.24.2.4
log
@Pull in changes from HEAD
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003, 2004, 2005, 2008, 2010, 2012 Red Hat, Inc.
d23 7
a29 2
#include <winternl.h>
#include <ntstatus.h>
@


1.24.2.5
log
@Pull in changes from HEAD
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003, 2004, 2005, 2008, 2010, 2011, 2012 Red Hat, Inc.
@


1.23
log
@Clean up whitespace.
@
text
@a10 1
#include <windows.h>
d19 11
a30 2
#include <ddk/ntapi.h>
#include <ddk/winddk.h>
d276 2
a277 2
extern "C" NTOSAPI NTAPI NTSTATUS NtQueryAttributesFile(
			      POBJECT_ATTRIBUTES, PFILE_BASIC_INFORMATION);
@


1.22
log
@	* dump_setup.cc (tfx_chars): New WCHAR array, copied from Cygwin.
	(transform_chars): New function, copied from Cygwin.
	(simple_nt_stat): New function to check file existance using native
	NT function.  Explain why.
	(directory_exists): Call simple_nt_stat.
	(file_exists): Ditto.
@
text
@d226 1
a226 1
            0, 0xf000 |   1, 0xf000 |   2, 0xf000 |   3,
d234 7
a240 7
          ' ',          '!', 0xf000 | '"',          '#',
          '$',          '%',          '&',           39,
          '(',          ')', 0xf000 | '*',          '+',
          ',',          '-',          '.',          '\\',
          '0',          '1',          '2',          '3',
          '4',          '5',          '6',          '7',
          '8',          '9', 0xf000 | ':',          ';',
d242 15
a256 15
          '@@',          'A',          'B',          'C',
          'D',          'E',          'F',          'G',
          'H',          'I',          'J',          'K',
          'L',          'M',          'N',          'O',
          'P',          'Q',          'R',          'S',
          'T',          'U',          'V',          'W',
          'X',          'Y',          'Z',          '[',
          '\\',          ']',          '^',          '_',
          '`',          'a',          'b',          'c',
          'd',          'e',          'f',          'g',
          'h',          'i',          'j',          'k',
          'l',          'm',          'n',          'o',
          'p',          'q',          'r',          's',
          't',          'u',          'v',          'w',
          'x',          'y',          'z',          '{',
@


1.21
log
@	* dump_setup.cc (dump_file): Read requested content from setup.rc
	file created by newer setup.exe.
@
text
@d21 2
d225 100
d329 1
a329 1
  if (stat(cygpath("/", filename, ".", NULL), &status))
d347 2
a348 2
  if (stat(cygpath("/", filename, NULL), &status) &&
      (!alt || stat(cygpath("/", filename, alt, NULL), &status)))
@


1.20
log
@* cygcheck.cc (pathlike::check_existence): Remove class name from declaration.
(display_internet_error): Use proper format specifier for DWORD.
(environ): Remove unneeded declaration.
(main): Use brace around nested if to avoid an overly-helpful compiler warning.
* dump_setup.cc (parse_filename): Reorganize nested if to avoid an
overly-helpful compiler warning.
* path.cc (GUID_shortcut): Use braces around part of initializer which needs
them.
(conv_fstab_spaces): Parenthesize assignment in while loop to avoid a compiler
warning.
(struct opt): Make static.
* ps.cc (main): Reorganize nested if to avoid an overly-helpful compiler
warning.
* regtool.cc: Make some anonymous structs static to avoid a compiler warning.
* ssp.c (lookup_thread_id): Initialize *tix to zero to avoid potential
uninitialized use.
* strace.cc (add_child): Use proper format specifier for DWORD.
(remove_child): Ditto.
(proc_child): Ditto.
@
text
@d3 1
a3 1
   Copyright 2001 Red Hat, Inc.
d144 5
a148 1
  char *path = cygpath ("/etc/setup/", fn, NULL);
d150 21
a170 10
  bool printed;
  char buf[4096];
  if (!fp)
    printed = false;
  else if (!fgets (buf, 4096, fp))
    printed = false;
    {
      char *p = strchr (buf, '\0');
      printf ("%s%s%s", msg, buf, (p == buf) || p[-1] != '\n' ? "\n" : "");
      printed = true;
a171 2
  if (fp)
    fclose (fp);
@


1.19
log
@* cygcheck.cc (nuke): Use malloc rather than alloca for environment variables.
(load_cygwin): Ditto.
* dump_setup.cc (parse_filename): Cosmetic changes.
(get_packages): Ditto.
@
text
@d94 19
a112 18
    if (*ver == '-')
      if (isdigit (ver[1]))
	{
	  *ver++ = '\0';
	  strcpy (f.pkg, p);
	  break;
	}
      else if (strcasecmp (ver, "-src") == 0 ||
	       strcasecmp (ver, "-patch") == 0)
	{
	  *ver++ = '\0';
	  strcpy (f.pkg, p);
	  strcpy (f.what, strlwr (ver));
	  strcpy (f.pkgtar, p);
	  strcat (f.pkgtar, f.tail);
	  ver = strchr (ver, '\0');
	  break;
	}
@


1.18
log
@	* dump_setup.cc (package_find): Fix is_alias computation for "/usr/lib".
@
text
@d97 1
a97 1
	  *ver++ = 0;
d104 1
a104 1
	  *ver++ = 0;
d314 2
a315 1
get_packages (char **argv) {
d356 1
a356 1
	  strcpy (packages[n].name , package);
@


1.17
log
@fix whitespace, update some copyrights
@
text
@d481 1
a481 1
			      !strncmp(filename, "/usr/lib", 9);
@


1.16
log
@	* dump_setup.cc (dump_setup): Remove unneeded strlen when check_files
	is not set.
@
text
@d194 1
a194 1
        break;
d196 4
a199 4
        if (verbose)
          printf ("Missing %s: /%s from package %s\n",
                  type, filename, package);
        return true;
d201 4
a204 4
        if (verbose)
          printf ("Unable to access %s /%s from package %s\n",
                  type, filename, package);
        return true;
d216 1
a216 1
        return false;
d221 1
a221 1
        printf ("Directory/file mismatch: /%s from package %s\n", filename, package);
d235 1
a235 1
        return false;
d240 1
a240 1
        printf ("File type mismatch: /%s from package %s\n", filename, package);
d289 4
a292 4
        {
          if (!directory_exists (verbose, filename, package))
            result = false;
        }
d294 4
a297 4
        {
          if (!file_exists (verbose, filename, ".done", package))
            result = false;
        }
d299 4
a302 4
        {
          if (!file_exists (verbose, filename, ".lnk", package))
            result = false;
        }
@


1.15
log
@	* dump_setup.cc (dump_setup): Avoid trailing spaces on package-list.
@
text
@d406 1
a406 2
	printf ("%-*s %-*s\n", package_len, packages[i].name,
	      strlen(packages[i].ver), packages[i].ver);
@


1.14
log
@* Makefile.in: Detect existence of mingw zlib headers and libraries.  Build
cygcheck wihtout package checking if they are unavailable.
* dump_setup.cc: Generate dummy zlib macros when zlib is not available.
(open_package_list): Use zlib functions to uncompress package lists.  Return
gzFile rather than FILE *.
(check_package_files): Change fp to gzFile to accommodate zlib functions.  Use
gzgets to read from package file.  Use gzclose to close the handle.
(package_list): Ditto.
(package_find): Ditto.
@
text
@d395 3
a397 1
  printf ("%-*s %-*s     %s\n", package_len, "Package", version_len, "Version", check_files?"Status":"");
d400 8
a407 3
      printf ("%-*s %-*s     %s\n", package_len, packages[i].name, version_len,
	      packages[i].ver, check_files ?
	      (check_package_files (verbose, packages[i].name) ? "OK" : "Incomplete") : "");
@


1.13
log
@* dump_setup.cc (check_package_files): Don't fail on empty package.
@
text
@d21 9
d246 1
a246 1
static FILE *
d249 1
a249 1
  char filelist[MAX_PATH + 1] = "etc/setup/";
d251 1
a251 1
  if (!file_exists (false, filelist, NULL, NULL))
d254 8
a261 13
  static char *zcat;
  static char *zcat_end;
  if (!zcat)
    {
      zcat = cygpath ("/bin/gzip.exe", NULL);
      while (char *p = strchr (zcat, '/'))
	*p = '\\';
      zcat = (char *) realloc (zcat, strlen (zcat) + sizeof (" -dc /") + MAX_PATH);
      zcat_end = strchr (strcat (zcat, " -dc /"), '\0');
    }

  strcpy (zcat_end, filelist);
  FILE *fp = popen (zcat, "rt");
d269 1
a269 1
  FILE *fp = open_package_list (package);
d279 1
a279 1
  while (fgets (buf, MAX_PATH, fp))
d305 1
a305 1
  fclose (fp);
d421 1
a421 1
      FILE *fp = open_package_list (packages[i].name);
d434 1
a434 1
      while (fgets (buf, MAX_PATH, fp))
d441 1
a441 1
      fclose (fp);
d461 1
a461 1
      FILE *fp = open_package_list (packages[i].name);
d467 1
a467 1
      while (fgets (buf + 1, MAX_PATH, fp))
d495 1
a495 1
      fclose (fp);
@


1.12
log
@	* dump_setup.cc (check_package_files): Strip leading / and ./ from
	package file names.
@
text
@d269 2
a270 3
	printf ("Can't open file list /etc/setup/%s.lst.gz for package %s\n",
                package, package);
      return false;
@


1.11
log
@	* dump_setup.cc (package_find): Don't stop searching on missing
	file list.
	(package_list): Ditto.

	* dump_setup.cc: (package_list): Make output terse unless
	verbose requested.  Fix formatting.
	(package_find): Ditto.
@
text
@d279 6
@


1.10
log
@	* cygcheck.cc (main): Fix some formatting and help text printing.

	* cygcheck.cc (find_package,list_package): New global
	variables.
	(usage): Add "--find-package" and "--list-package" options,
	reformat output.
	(longopts, opts): Add "--find-package" and "--list-package"
	options.
	(main): Process the "--find-package" and "--list-package"
	flags.  Add new semantic checks.  Add calls to find_package()
	and list_package().
	* dump_setup.cc: Fix header comment.
	(match_argv): Change return type to int to distinguish
	between real matches and default ones.
	(open_package_list): New static function.
	(check_package_files): Factor out opening the package list
	file into open_package_list().
	(get_packages): New static function.
	(dump_setup): Factor out getting a list of packages into
	get_packages().
	(package_list, package_find): New global functions.
@
text
@d414 6
a419 6
      {
	if (verbose)
	  printf ("Can't open file list /etc/setup/%s.lst.gz for package %s\n",
	      packages[i].name, packages[i].name);
	return;
      }
d421 2
a422 1
      printf ("Package: %s-%s\n", packages[i].name, packages[i].ver);
d429 1
a429 1
	    printf ("    /%s", buf);
d454 1
a454 6
      {
	if (verbose)
	  printf ("Can't open file list /etc/setup/%s.lst.gz for package %s\n",
	      packages[i].name, packages[i].name);
	return;
      }
d478 5
a482 1
		printf ("%s-%s\n", packages[i].name, packages[i].ver);
@


1.9
log
@	* dump_setup.cc (check_package_files): Fix extra '/' in filename.
	Resize command buffer.  Fix buffer overflow bug.
@
text
@d1 1
a1 1
/* path.cc
d168 1
a168 1
bool
d172 1
a172 1
    return true;
d175 2
a176 2
      return true;
  return false;
d237 2
a238 2
static bool
check_package_files (int verbose, char *package)
d243 1
a243 5
    {
      if (verbose)
	printf ("Missing file list /%s for package %s\n", filelist, package);
      return false;
    }
d259 15
d300 6
a305 3
void
dump_setup (int verbose, char **argv, bool check_files)
{
a308 1
  puts ("Cygwin Package Information");
d310 1
a310 11
    {
      puts ("No package information found");
      goto err;
    }

  if (verbose)
    {
      bool need_nl = dump_file ("Last downloaded files to: ", "last-cache");
      if (dump_file ("Last downloaded files from: ", "last-mirror") || need_nl)
	puts ("");
    }
d318 4
a321 1
    goto err;
d326 1
a326 1
  packages = (pkgver *) calloc (nlines, sizeof(packages[0]));
d358 2
d362 24
d387 1
a387 1
  for (int i = 0; i < n; i++)
d394 41
a434 1
  fclose (fp);
d437 53
a490 4
err:
  puts ("No setup information found");
  if (fp)
    fclose (fp);
d493 1
@


1.8
log
@* dump_setup.cc (dump_setup): Check for the existence of the package list file.
Rework slightly to use static buffer for popen commands.
@
text
@d240 1
a240 1
  char filelist[MAX_PATH + 1] = "/etc/setup/";
d256 2
a257 2
      zcat = (char *) realloc (zcat, strlen (zcat) + sizeof (" -dc ") + 4096);
      zcat_end = strchr (strcat (zcat, " -dc "), '\0');
d265 1
a265 1
  while (fgets (buf, 4096, fp))
@


1.7
log
@* dump_setup.cc (version_len): New static variable.
(could_not_access,directory_exists): New static function.
(file_exists): Ditto.
(check_package_files): Ditto.
(dump_setup): Check the contents of each package if check_files is true and
output the result in the "Status" column.  Flush output after each package.
* dump_setup.cc (dump_setup): Remove redundant null check.  Add informative
message if package info not found.
@
text
@d240 23
d264 1
a264 9
  char filelist[4096] = " -dc /etc/setup/";
  strcat(strcat(filelist, package), ".lst.gz");
  char *zcat = cygpath("/bin/gzip.exe", NULL);
  char command[4096];
  while (char *p = strchr (zcat, '/'))
    *p = '\\';
  strcat(strcpy(command, zcat), filelist);
  FILE *fp = popen (command, "rt");
  char buf[4096];
d268 1
a268 1
      if (filename[strlen(filename)-1] == '/')
d270 1
a270 1
          if (!directory_exists(verbose, filename, package))
d273 1
a273 1
      else if (!strncmp(filename, "etc/postinstall/", 16))
d275 1
a275 1
          if (!file_exists(verbose, filename, ".done", package))
d280 1
a280 1
          if (!file_exists(verbose, filename, ".lnk", package))
d284 2
a285 1
  fclose(fp);
@


1.6
log
@* dump_setup.cc (compar): Use case insensitive comparisons.
(dump_setup): Calculate package_len based on already used "len".  Don't bother
with version_len.
@
text
@d18 2
d23 1
d179 94
d274 1
a274 1
dump_setup (int verbose, char **argv, bool /*check_files*/)
d278 1
d281 5
a285 1
    goto err;
a292 3
  if (!fp)
    goto err;

d328 2
d338 1
a338 1
  printf ("%-*s %s\n", package_len, "Package", "Version");
d340 6
a345 1
    printf ("%-*s %s\n", package_len, packages[i].name, packages[i].ver);
@


1.5
log
@	* dump_setup.cc (dump_setup): Compute the longest package name
	and align columns properly.
@
text
@a20 1
static int version_len = 20;
d161 1
a161 1
  return strcmp (pa->name, pb->name);
d222 2
a227 3
	  int pkg_len = strlen(packages[n].name);
	  if (package_len < pkg_len+1)
	    package_len = pkg_len+1;
a228 3
	  int ver_len = strlen(packages[n].ver);
	  if (version_len < ver_len+1)
	    version_len = ver_len+1;
d237 1
a237 1
  printf ("%-*s%-*s\n", package_len, "Package", version_len, "Version");
d239 1
a239 2
    printf ("%-*s%-*s\n", package_len, packages[i].name,
			  version_len, packages[i].ver);
@


1.4
log
@* dump_setup.cc (parse_filename): Don't consider '_' part of the version.
@
text
@a206 1
  printf ("%-*s%-*s\n", package_len, "Package", version_len, "Version");
d227 3
d231 3
d242 1
@


1.3
log
@* cygcheck.cc (scan_registry): Open registry with read-only access.
(main): Reflect argument change for dump_setup.
* dump_setup.cc (dump_setup): Add preliminary extra argument for future use.
* path.cc (read_mounts): Open registry with read-only access.
@
text
@d83 1
a83 1
    if (*ver == '-' || *ver == '_')
@


1.2
log
@* cygcheck.cc (main): Display package info when '-s' is specified.
* dump_setup.cc (dump_setup): Change header.  Remove typo.  Always sort
packages output.
@
text
@d178 1
a178 1
dump_setup (int verbose, char **argv)
@


1.1
log
@* dump_setup.cc: New file.
* Makefile.in: Add info for dump_setup.o.
* cygcheck.cc (main): Recognize '-c' option for checking setup installed base.
* path.cc (cygpath): Read mount table if not loaded.
@
text
@d169 1
a169 1
  if (!*argv)
d182 1
a182 1
  puts ("Cygwin Setup information");
a190 1
  if (!*argv)
d235 1
a235 2
  if (!argv)
    qsort (packages, n, sizeof (packages[0]), compar);
@

