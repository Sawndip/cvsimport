head	1.30;
access;
symbols
	cygwin-1_7_35-release:1.30
	cygwin-1_7_34-release:1.30
	cygwin-1_7_33-release:1.22
	cygwin-1_7_32-release:1.22
	cygwin-1_7_31-release:1.22
	cygwin-1_7_30-release:1.22
	cygwin-1_7_29-release:1.22
	cygwin-1_7_29-release-branchpoint:1.22.0.6
	cygwin-1_7_28-release:1.22
	cygwin-1_7_27-release:1.22
	cygwin-1_7_26-release:1.22
	cygwin-1_7_25-release:1.22
	cygwin-1_7_24-release:1.22
	cygwin-1_7_23-release:1.22
	cygwin-1_7_22-release:1.22
	cygwin-1_7_21-release:1.22
	cygwin-1_7_20-release:1.22
	cygwin-1_7_19-release:1.22
	cygwin-64bit-postmerge:1.22
	cygwin-64bit-premerge-branch:1.22.0.4
	cygwin-64bit-premerge:1.22
	cygwin-1_7_18-release:1.22
	cygwin-1_7_17-release:1.22
	cygwin-64bit-branch:1.22.0.2
	cygwin-1_7_16-release:1.22
	cygwin-1_7_15-release:1.22
	cygwin-1_7_14_2-release:1.22
	cygwin-1_7_14-release:1.22
	cygwin-1_7_12-release:1.22
	cygwin-1_7_11-release:1.22
	cygwin-1_7_10-release:1.22
	cygwin-1_7_9-release:1.19
	cygwin-1_7_8-release:1.18
	cygwin-1_7_7-release:1.17
	cygwin-1_7_5-release:1.17
	cygwin-1_7_4-release:1.17
	cygwin-1_7_3-release:1.17
	cygwin-1_7_2-release:1.17
	cygwin-1_7_1-release:1.17
	cv-branch-2:1.16.0.2
	cr-0x5f1:1.14.0.6
	cv-branch:1.14.0.4
	cr-0x3b58:1.14.0.2
	cr-0x9e:1.13.0.8
	cr-0x9d:1.13.0.6
	corinna-01:1.13
	cr-0x9c:1.13.0.2
	cr-0x9b:1.13.0.4
	cr-0x99:1.12
	Z-emcb-cygwin_daemon:1.12.0.2
	w32api-2_2:1.11
	mingw-runtime-2_4:1.11
	cygnus_cvs_20020108_pre:1.4
	Z-cygwin_daemon_merge-new_HEAD:1.3
	Z-cygwin_daemon_merge_HEAD:1.3
	cygwin_daemon:1.3.0.8;
locks; strict;
comment	@ * @;
expand	@o@;


1.30
date	2014.12.15.20.29.43;	author corinna;	state Exp;
branches;
next	1.29;

1.29
date	2014.10.29.10.24.49;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2014.10.27.10.28.13;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2014.10.27.10.25.02;	author corinna;	state Exp;
branches;
next	1.26;

1.26
date	2014.09.03.12.44.05;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2014.09.03.09.32.53;	author corinna;	state Exp;
branches;
next	1.24;

1.24
date	2014.09.03.08.57.20;	author corinna;	state Exp;
branches;
next	1.23;

1.23
date	2014.08.31.19.20.04;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2011.12.17.23.39.47;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2011.10.10.14.57.47;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2011.04.18.10.23.21;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2011.03.28.21.21.03;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2010.12.11.20.47.01;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2009.11.29.14.28.29;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2009.05.06.11.54.24;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2008.05.22.18.56.26;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.18.15.57.56;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.11.07.55.51;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.26.21.52.03;	author joshuadfranklin;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.15.10.08.37;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.10.11.39.19;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2002.12.15.10.09.35;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.24.18.07.30;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2002.11.08.10.22.58;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.15.19.24.37;	author joshuadfranklin;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.24.14.40.14;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.04.17.24.24;	author corinna;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.05.17.55.23;	author corinna;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.28.05.39.38;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.30
log
@	* setfacl.c (action_t): Add DeleteDef value.
	(delacl): Take new parameter to differe between DeleteAll and DeleteDef.
	Extend conditional to handle DefaultDef.  Change comment accordingly.
	(setfacl): Call delacl in DefaultDef case as well.
	(usage): Add and describe -k option.  Add -k to require options.
	(longopts): Add --remove-default option.
	(opts): Add -k option.
	(main): Handle -k option.
@
text
@/* setfacl.c

   Copyright 2000, 2001, 2002, 2003, 2006, 2008, 2009, 2010, 2011, 2014
   Red Hat Inc.

   Written by Corinna Vinschen <vinschen@@redhat.com>

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include <errno.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <getopt.h>
#include <pwd.h>
#include <grp.h>
#include <sys/types.h>
#include <sys/acl.h>
#include <cygwin/version.h>

#ifndef BOOL
#define BOOL int
#endif

#ifndef TRUE
#define TRUE (1)
#endif

#ifndef FALSE
#define FALSE (0)
#endif

#ifndef ILLEGAL_MODE
#define ILLEGAL_MODE ((mode_t)0xffffffff)
#endif

static char *prog_name;

typedef enum {
  NoAction,
  Set,
  Modify,
  Delete,
  ModNDel,
  DeleteAll,
  DeleteDef,
  SetFromFile
} action_t;

mode_t getperm (char *in)
{
  if (isdigit ((unsigned char) *in) && !in[1])
    {
      int i = atoi (in);
      if (i < 0 || i > 7)
	return ILLEGAL_MODE;
      return i << 6 | i << 3 | i;
    }
  if (strlen (in) > 3 && strchr (" \t\n\r#", in[3]))
    in[3] = '\0';
  if (strlen (in) != 3)
    return ILLEGAL_MODE;
  if (!strchr ("r-", in[0])
      || !strchr ("w-", in[1])
      || !strchr ("x-", in[2]))
    return ILLEGAL_MODE;
  return (in[0] == 'r' ? S_IROTH : 0)
	 | (in[1] == 'w' ? S_IWOTH : 0)
	 | (in[2] == 'x' ? S_IXOTH : 0);
}

BOOL
getaclentry (action_t action, char *c, aclent_t *ace)
{
  char *c2;

  ace->a_type = 0;
  ace->a_id = (uid_t) -1;
  ace->a_perm = 0;

  /* First, check if we're handling a default entry. */
  if (!strncmp (c, "default:", 8) || !strncmp (c, "d:", 2))
    {
      ace->a_type = ACL_DEFAULT;
      c = strchr (c, ':') + 1;
    }
  /* c now points to the type.  Check for next colon.  If we find a colon,
     NUL it.  Otherwise the string is invalid, except when deleting. */
  c2 = strchrnul (c, ':');
  if (*c2 == ':')
    *c2++ = '\0';
  else if (action != Delete)
    return FALSE;
  /* Fetch the type. */
  if (!strcmp (c, "u") || !strcmp (c, "user"))
      ace->a_type |= USER_OBJ;
  else if (!strcmp (c, "g") || !strcmp (c, "group"))
      ace->a_type |= GROUP_OBJ;
  else if (!strcmp (c, "m") || !strcmp (c, "mask"))
      ace->a_type |= CLASS_OBJ;
  else if (!strcmp (c, "o") || !strcmp (c, "other"))
      ace->a_type |= OTHER_OBJ;
  else
    return FALSE;
  /* Skip to next field. */
  c = c2;
  if (!*c)
    {
      /* Nothing follows.  This is only valid if action is Delete and the
	 type is CLASS_OBJ, or if ACL_DEFAULT is set. */
      if (action != Delete
	  || (!(ace->a_type & (CLASS_OBJ | ACL_DEFAULT))))
	return FALSE;
    }
  else if (!(ace->a_type & (USER_OBJ | GROUP_OBJ)))
    {
      /* Mask and other entries may contain an extra colon. */
      if (*c == ':')
	++c;
    }
  /* If this is a user or group entry, check if next char is a colon char.
     If so, skip it, otherwise it's the name of a user or group. */
  else if (*c == ':')
    ++c;
  else if (*c)
    {
      /* c now points to the id.  Check for next colon.  If we find a colon,
	 NUL it.  Otherwise the string is invalid, except when deleting.
	 If we delete, it must be a default entry since standard ugo entries
	 can't be deleted. */
      c2 = strchrnul (c + 1, ':');
      if (*c2 == ':')
	*c2++ = '\0';
      else if (action != Delete)
	return FALSE;
      /* Fetch user/group id. */
      if (isdigit ((unsigned char) *c))
	{
	  char *c3;

	  ace->a_id = strtol (c, &c3, 10);
	  if (*c3)
	    return FALSE;
	}
      else if (ace->a_type & USER_OBJ)
	{
	  struct passwd *pw = getpwnam (c);
	  if (!pw)
	    return FALSE;
	  ace->a_id = pw->pw_uid;
	}
      else
	{
	  struct group *gr = getgrnam (c);
	  if (!gr)
	    return FALSE;
	  ace->a_id = gr->gr_gid;
	}
      if (ace->a_type & USER_OBJ)
	{
	  ace->a_type &= ~USER_OBJ;
	  ace->a_type |= USER;
	}
      else
	{
	  ace->a_type &= ~GROUP_OBJ;
	  ace->a_type |= GROUP;
	}
      /* Skip to next field. */
      c = c2;
    }
  if (action == Delete)
    {
      /* Trailing garbage? */
      if (*c)
	return FALSE;
      /* No, we're good. */
      ace->a_perm = ILLEGAL_MODE;
      return TRUE;
    }
  /* Check perms. */
  if ((ace->a_perm = getperm (c)) == ILLEGAL_MODE)
    return FALSE;
  return TRUE;
}

BOOL
getaclentries (action_t action, char *buf, aclent_t *acls, int *idx)
{
  char *c;

  if (action == SetFromFile)
    {
      FILE *fp;
      char fbuf[256], *fb;

      if (!strcmp (buf, "-"))
	fp = stdin;
      else if (! (fp = fopen (buf, "r")))
	return FALSE;
      while ((fb = fgets (fbuf, 256, fp)))
	{
	  while (strchr (" \t", *fb))
	    ++fb;
	  if (strchr ("\n\r#", *fb))
	    continue;
	  if (!getaclentry (action, fb, acls + (*idx)++))
	    {
	      fclose (fp);
	      return FALSE;
	    }
	}
      if (fp != stdin)
	fclose (fp);
    }
  else
    for (c = strtok (buf, ","); c; c = strtok (NULL, ","))
      if (!getaclentry (action, c, acls + (*idx)++))
	return FALSE;
  return TRUE;
}

int
searchace (aclent_t *aclp, int nentries, int type, int id)
{
  int i;

  for (i = 0; i < nentries; ++i)
    if ((aclp[i].a_type == type && (id < 0 || aclp[i].a_id == id))
	|| !aclp[i].a_type)
      return i;
  return -1;
}

int
modacl (aclent_t *tgt, int tcnt, aclent_t *src, int scnt)
{
  int t, s, i;

  for (s = 0; s < scnt; ++s)
    {
      t = searchace (tgt, MAX_ACL_ENTRIES, src[s].a_type,
		     (src[s].a_type & (USER | GROUP)) ? src[s].a_id : -1);
      if (t < 0)
	return -1;
      if (src[s].a_perm == ILLEGAL_MODE)
	{
	  if (t < tcnt)
	    {
	      for (i = t + 1; i < tcnt; ++i)
		tgt[i - 1] = tgt[i];
	      --tcnt;
	    }
	}
      else
	{
	  tgt[t] = src[s];
	  if (t >= tcnt)
	    ++tcnt;
	}
    }
  return tcnt;
}

int
addmissing (aclent_t *tgt, int tcnt)
{
  int t;
  int types = 0, def_types = 0;
  int perm = 0, def_perm = 0;

  /* Check if we have all the required entries now. */
  for (t = 0; t < tcnt; ++t)
    if (tgt[t].a_type & ACL_DEFAULT)
      {
	def_types |= tgt[t].a_type;
	if (tgt[t].a_type & (USER | GROUP | GROUP_OBJ))
	  def_perm |= tgt[t].a_perm;
      }
    else
      {
	types |= tgt[t].a_type;
	if (tgt[t].a_type & (USER | GROUP | GROUP_OBJ))
	  perm |= tgt[t].a_perm;
      }
  /* Add missing CLASS_OBJ */
  if ((types & (USER | GROUP)) && !(types & CLASS_OBJ))
    {
      tgt[tcnt].a_type = CLASS_OBJ;
      tgt[tcnt].a_id = (uid_t) -1;
      tgt[tcnt++].a_perm = perm;
    }
  if (def_types)
    {
      /* Add missing default entries. */
      if (!(def_types & USER_OBJ) && tcnt < MAX_ACL_ENTRIES)
	{
	  t = searchace (tgt, tcnt, USER_OBJ, -1);
	  tgt[tcnt].a_type = DEF_USER_OBJ;
	  tgt[tcnt].a_id = (uid_t) -1;
	  tgt[tcnt++].a_perm = t >= 0 ? tgt[t].a_perm : S_IRWXO;
	}
      if (!(def_types & GROUP_OBJ) && tcnt < MAX_ACL_ENTRIES)
	{
	  t = searchace (tgt, tcnt, GROUP_OBJ, -1);
	  tgt[tcnt].a_type = DEF_GROUP_OBJ;
	  tgt[tcnt].a_id = (uid_t) -1;
	  tgt[tcnt].a_perm = t >= 0 ? tgt[t].a_perm : (S_IROTH | S_IXOTH);
	  def_perm |= tgt[tcnt++].a_perm;
	}
      if (!(def_types & OTHER_OBJ) && tcnt < MAX_ACL_ENTRIES)
	{
	  t = searchace (tgt, tcnt, OTHER_OBJ, -1);
	  tgt[tcnt].a_type = DEF_OTHER_OBJ;
	  tgt[tcnt].a_id = (uid_t) -1;
	  tgt[tcnt++].a_perm = t >= 0 ? tgt[t].a_perm : (S_IROTH | S_IXOTH);
	}
      /* Add missing DEF_CLASS_OBJ */
      if ((def_types & (USER | GROUP)) && !(def_types & CLASS_OBJ))
	{
	  tgt[tcnt].a_type = DEF_CLASS_OBJ;
	  tgt[tcnt].a_id = (uid_t) -1;
	  tgt[tcnt++].a_perm = def_perm;
	}
    }
  return tcnt;
}

int
delacl (aclent_t *tgt, int tcnt, action_t action)
{
  int t;

  for (t = 0; t < tcnt; ++t)
    /* -b (DeleteAll): Remove all extended ACL entries.
       -k (DeleteDef): Remove all default ACL entries. */
    if ((action == DeleteAll && (tgt[t].a_type & (USER | GROUP | CLASS_OBJ)))
	|| (action == DeleteDef && (tgt[t].a_type & ACL_DEFAULT)))
      {
	--tcnt;
	if (t < tcnt)
	  memmove (&tgt[t], &tgt[t + 1], (tcnt - t) * sizeof (aclent_t));
	--t;
      }
  return tcnt;
}

int
setfacl (action_t action, const char *path, aclent_t *acls, int cnt)
{
  aclent_t lacl[MAX_ACL_ENTRIES];
  int lcnt;

  memset (lacl, 0, sizeof lacl);
  switch (action)
    {
    case Set:
      if (acl (path, SETACL, cnt, acls))
	{
	  perror (prog_name);
	  return 2;
	}
      break;
    case Delete:
      if ((lcnt = acl (path, GETACL, MAX_ACL_ENTRIES, lacl)) < 0
	  || (lcnt = modacl (lacl, lcnt, acls, cnt)) < 0
	  || (lcnt = acl (path, SETACL, lcnt, lacl)) < 0)
	{
	  perror (prog_name);
	  return 2;
	}
      break;
    case DeleteAll:
    case DeleteDef:
      if ((lcnt = acl (path, GETACL, MAX_ACL_ENTRIES, lacl)) < 0
	  || (lcnt = delacl (lacl, lcnt, action)) < 0
	  || (lcnt = acl (path, SETACL, lcnt, lacl)) < 0)
	{
	  perror (prog_name);
	  return 2;
	}
      break;
    default:
      if ((lcnt = acl (path, GETACL, MAX_ACL_ENTRIES, lacl)) < 0
	  || (lcnt = modacl (lacl, lcnt, acls, cnt)) < 0
	  || (lcnt = addmissing (lacl, lcnt)) < 0
	  || (lcnt = acl (path, SETACL, lcnt, lacl)) < 0)
	{
	  perror (prog_name);
	  return 2;
	}
      break;
    }
  return 0;
}

static void
usage (FILE *stream)
{
  fprintf (stream, ""
	    "Usage: %s [-r] {-f ACL_FILE | -s acl_entries} FILE...\n"
	    "       %s [-r] {-b|[-d acl_entries] [-m acl_entries]} FILE...\n"
	    "\n"
	    "Modify file and directory access control lists (ACLs)\n"
	    "\n"
	    "  -b, --remove-all remove all extended ACL entries\n"
	    "  -d, --delete     delete one or more specified ACL entries\n"
	    "  -f, --file       set ACL entries for FILE to ACL entries read\n"
	    "                   from a ACL_FILE\n"
	    "  -k, --remove-default\n"
	    "                   remove all default ACL entries\n"
	    "  -m, --modify     modify one or more specified ACL entries\n"
	    "  -r, --replace    replace mask entry with maximum permissions\n"
	    "                   needed for the file group class\n"
	    "  -s, --substitute substitute specified ACL entries for the\n"
	    "                   ACL of FILE\n"
	    "  -h, --help       output usage information and exit\n"
	    "  -V, --version    output version information and exit\n"
	    "\n"
	    "At least one of (-b, -d, -f, -k, -m, -s) must be specified\n"
	    "\n", prog_name, prog_name);
  if (stream == stdout)
  {
    printf(""
	    "     Acl_entries are one or more comma-separated ACL entries \n"
	    "     from the following list:\n"
	    "\n"
	    "         u[ser]::perm\n"
	    "         u[ser]:uid:perm\n"
	    "         g[roup]::perm\n"
	    "         g[roup]:gid:perm\n"
	    "         m[ask]:perm\n"
	    "         o[ther]:perm\n"
	    "\n"
	    "     Default entries are like the above with the additional\n"
	    "     default identifier. For example: \n"
	    "\n"
	    "         d[efault]:u[ser]:uid:perm\n"
	    "\n"
	    "     'perm' is either a 3-char permissions string in the form\n"
	    "     \"rwx\" with the character - for no permission\n"
	    "     or it is the octal representation of the permissions, a\n"
	    "     value from 0 (equivalent to \"---\") to 7 (\"rwx\").\n"
	    "     'uid' is a user name or a numerical uid.\n"
	    "     'gid' is a group name or a numerical gid.\n"
	    "\n"
	    "\n"
	    "For each file given as parameter, %s will either replace its\n"
	    "complete ACL (-s, -f), or it will add, modify, or delete ACL\n"
	    "entries.\n"
	    "\n"
	    "The following options are supported:\n"
	    "\n"
	    "-b   Remove all extended ACL entries.  The base ACL entries of the\n"
	    "     owner, group and others are retained.\n"
	    "\n"
	    "-d   Delete one or more specified entries from the file's ACL.\n"
	    "     The owner, group and others entries must not be deleted.\n"
	    "     Acl_entries to be deleted should be specified without\n"
	    "     permissions, as in the following list:\n"
	    "\n"
	    "         u[ser]:uid[:]\n"
	    "         g[roup]:gid[:]\n"
	    "         m[ask][:]\n"
	    "         d[efault]:u[ser][:uid]\n"
	    "         d[efault]:g[roup][:gid]\n"
	    "         d[efault]:m[ask][:]\n"
	    "         d[efault]:o[ther][:]\n"
	    "\n"
	    "-f   Take the Acl_entries from ACL_FILE one per line. Whitespace\n"
	    "     characters are ignored, and the character \"#\" may be used\n"
	    "     to start a comment.  The special filename \"-\" indicates\n"
	    "     reading from stdin.\n"
	    "     Required entries are\n"
	    "     - One user entry for the owner of the file.\n"
	    "     - One group entry for the group of the file.\n"
	    "     - One other entry.\n"
	    "     If additional user and group entries are given:\n"
	    "     - A mask entry for the file group class of the file.\n"
	    "     - No duplicate user or group entries with the same uid/gid.\n"
	    "     If it is a directory:\n"
	    "     - One default user entry for the owner of the file.\n"
	    "     - One default group entry for the group of the file.\n"
	    "     - One default mask entry for the file group class.\n"
	    "     - One default other entry.\n"
	    "\n"
	    "-k   Remove all default ACL entries. If no default ACL entries\n"
	    "     exist, no warnings are issued.\n"
	    "\n"
	    "-m   Add or modify one or more specified ACL entries.\n"
	    "     Acl_entries is a comma-separated list of entries from the \n"
	    "     same list as above.\n"
	    "\n"
	    "-r   Causes the permissions specified in the mask entry to be\n"
	    "     ignored and replaced by the maximum permissions needed for\n"
	    "     the file group class.\n"
	    "\n"
	    "-s   Like -f, but substitute the file's ACL with Acl_entries\n"
	    "     specified in a comma-separated list on the command line.\n"
	    "\n"
	    "While the -d and -m options may be used in the same command, the\n"
	    "-f and -s options may be used only exclusively.\n"
	    "\n"
	    "Directories may contain default ACL entries.  Files created\n"
	    "in a directory that contains default ACL entries will have\n"
	    "permissions according to the combination of the current umask,\n"
	    "the explicit permissions requested and the default ACL entries\n"
	    "\n", prog_name);
  }
  else
    fprintf(stream, "Try '%s --help' for more information.\n", prog_name);
}

struct option longopts[] = {
  {"remove-all", no_argument, NULL, 'b'},
  {"delete", required_argument, NULL, 'd'},
  {"file", required_argument, NULL, 'f'},
  {"remove-default", no_argument, NULL, 'k'},
  {"modify", required_argument, NULL, 'm'},
  {"replace", no_argument, NULL, 'r'},
  {"substitute", required_argument, NULL, 's'},
  {"help", no_argument, NULL, 'h'},
  {"version", no_argument, NULL, 'V'},
  {0, no_argument, NULL, 0}
};
const char *opts = "bd:f:hkm:rs:V";

static void
print_version ()
{
  printf ("setfacl (cygwin) %d.%d.%d\n"
	  "POSIX ACL modification utility\n"
	  "Copyright (C) 2000 - %s Red Hat, Inc.\n"
	  "This is free software; see the source for copying conditions.  There is NO\n"
	  "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n",
	  CYGWIN_VERSION_DLL_MAJOR / 1000,
	  CYGWIN_VERSION_DLL_MAJOR % 1000,
	  CYGWIN_VERSION_DLL_MINOR,
	  strrchr (__DATE__, ' ') + 1);
}

int
main (int argc, char **argv)
{
  int c;
  action_t action = NoAction;
  int ropt = 0;
  aclent_t acls[MAX_ACL_ENTRIES];
  int aclidx = 0;
  int ret = 0;

  prog_name = program_invocation_short_name;

  memset (acls, 0, sizeof acls);
  while ((c = getopt_long (argc, argv, opts, longopts, NULL)) != EOF)
    switch (c)
      {
      case 'b':
	if (action == NoAction)
	  action = DeleteAll;
	else
	  {
	    usage (stderr);
	    return 1;
	  }
	break;
      case 'd':
	if (action == NoAction)
	  action = Delete;
	else if (action == Modify)
	  action = ModNDel;
	else
	  {
	    usage (stderr);
	    return 1;
	  }
	if (! getaclentries (Delete, optarg, acls, &aclidx))
	  {
	    fprintf (stderr, "%s: illegal acl entries\n", prog_name);
	    return 2;
	  }
	break;
      case 'f':
	if (action == NoAction)
	  action = Set;
	else
	  {
	    usage (stderr);
	    return 1;
	  }
	if (! getaclentries (SetFromFile, optarg, acls, &aclidx))
	  {
	    fprintf (stderr, "%s: illegal acl entries\n", prog_name);
	    return 2;
	  }
	break;
      case 'h':
	usage (stdout);
	return 0;
      case 'k':
	if (action == NoAction)
	  action = DeleteDef;
	else
	  {
	    usage (stderr);
	    return 1;
	  }
	break;
      case 'm':
	if (action == NoAction)
	  action = Modify;
	else if (action == Delete)
	  action = ModNDel;
	else
	  {
	    usage (stderr);
	    return 1;
	  }
	if (! getaclentries (Modify, optarg, acls, &aclidx))
	  {
	    fprintf (stderr, "%s: illegal acl entries\n", prog_name);
	    return 2;
	  }
	break;
      case 'r':
	if (!ropt)
	  ropt = 1;
	else
	  {
	    usage (stderr);
	    return 1;
	  }
	break;
      case 's':
	if (action == NoAction)
	  action = Set;
	else
	  {
	    usage (stderr);
	    return 1;
	  }
	if (! getaclentries (Set, optarg, acls, &aclidx))
	  {
	    fprintf (stderr, "%s: illegal acl entries\n", prog_name);
	    return 2;
	  }
	break;
      case 'V':
	print_version ();
	return 0;
      default:
	fprintf (stderr, "Try `%s --help' for more information.\n", prog_name);
	return 1;
      }
  if (action == NoAction)
    {
      usage (stderr);
      return 1;
    }
  if (optind > argc - 1)
    {
      usage (stderr);
      return 1;
    }
  if (action == Set)
    switch (aclcheck (acls, aclidx, NULL))
      {
      case GRP_ERROR:
	fprintf (stderr, "%s: more than one group entry.\n", prog_name);
	return 2;
      case USER_ERROR:
	fprintf (stderr, "%s: more than one user entry.\n", prog_name);
	return 2;
      case CLASS_ERROR:
	fprintf (stderr, "%s: more than one mask entry.\n", prog_name);
	return 2;
      case OTHER_ERROR:
	fprintf (stderr, "%s: more than one other entry.\n", prog_name);
	return 2;
      case DUPLICATE_ERROR:
	fprintf (stderr, "%s: duplicate additional user or group.\n", prog_name);
	return 2;
      case ENTRY_ERROR:
	fprintf (stderr, "%s: invalid entry type.\n", prog_name);
	return 2;
      case MISS_ERROR:
	fprintf (stderr, "%s: missing entries.\n", prog_name);
	return 2;
      case MEM_ERROR:
	fprintf (stderr, "%s: out of memory.\n", prog_name);
	return 2;
      default:
	break;
      }
  for (c = optind; c < argc; ++c)
    ret |= setfacl (action, argv[c], acls, aclidx);
  return ret;
}
@


1.29
log
@	* setfacl.c (setfacl): Fix bracketing in expression.
@
text
@d52 1
d336 1
a336 1
delacl (aclent_t *tgt, int tcnt)
a339 1
  /* Remove all extended ACL entries. */
d341 4
a344 1
    if (tgt[t].a_type & (USER | GROUP | CLASS_OBJ))
d380 1
d382 1
a382 1
	  || (lcnt = delacl (lacl, lcnt)) < 0
d404 1
a404 1
usage (FILE * stream)
d416 2
d426 1
a426 1
	    "At least one of (-b, -d, -f, -m, -s) must be specified\n"
d493 3
d524 1
d532 1
a532 1
const char *opts = "bd:f:hm:rs:V";
d606 9
@


1.28
log
@	* setfacl.c (usage): Add -b to require options.
@
text
@d388 1
a388 1
	  || (lcnt = addmissing (lacl, lcnt) < 0)
@


1.27
log
@	* setfacl.c (action_t): Add DeleteAll value.
	(delacl): New function to remove all ACL entries not representing POSIX
	permissions.
	(setfacl): Rearrange conditional expression into switch statement.
	Add DeleteAll case.
	(usage): Add and describe -b option.
	(longopts): Add --remove-all option.
	(opts): Add -b option.
	(main): Handle -b option.
@
text
@d420 1
a420 1
	    "At least one of (-d, -f, -m, -s) must be specified\n"
@


1.26
log
@	* setfacl.c (addmissing): New function to add missing acl entries to
	a modified acl per the rules set by aclcheck.
	(setfacl): Call addmissing unless action is Delete.
@
text
@d51 1
d335 18
a352 1
setfacl (action_t action, char *path, aclent_t *acls, int cnt)
d358 1
a358 1
  if (action == Set)
d360 1
d366 29
a394 8
    }
  else if ((lcnt = acl (path, GETACL, MAX_ACL_ENTRIES, lacl)) < 0
      || (lcnt = modacl (lacl, lcnt, acls, cnt)) < 0
      || (action != Delete && (lcnt = addmissing (lacl, lcnt)) < 0)
      || (lcnt = acl (path, SETACL, lcnt, lacl)) < 0)
    {
      perror (prog_name);
      return 2;
d403 2
a404 2
	    "Usage: %s [-r] (-f ACL_FILE | -s acl_entries) FILE...\n"
	    "       %s [-r] ([-d acl_entries] [-m acl_entries]) FILE...\n"
d408 1
d454 3
d512 1
d522 1
a522 1
const char *opts = "d:f:hm:rs:V";
d554 9
@


1.25
log
@	* setfacl.c (getaclentry): Fix previous fix again.  Allow lone 'm' as
	well as any lone default entry if action is Delete.  Fix comments.
	(usage): Align usage text.
@
text
@d270 64
d350 1
@


1.24
log
@	* setfacl.c (getaclentry): Fix return value in case of a lone 'm' if
	action is Delete.  Drop requirement for a trailing colon if action is
	Delete.
@
text
@d112 8
a119 4
    return action == Delete && (ace->a_type & CLASS_OBJ);
  /* If this is a user or group entry, check if next char is a colon char.
     If so, skip it, otherwise it's the name of a user or group. */
  if (!(ace->a_type & (USER_OBJ | GROUP_OBJ)))
d125 2
d353 7
a359 6
	    "         u[ser]:uid\n"
	    "         g[roup]:gid\n"
	    "         d[efault]:u[ser]:uid\n"
	    "         d[efault]:g[roup]:gid\n"
	    "         d[efault]:m[ask]:\n"
	    "         d[efault]:o[ther]:\n"
@


1.23
log
@	* setfacl.c (usage): Drop outdated note that default ACEs are not
	taken into account.
@
text
@d111 2
a112 2
  if (!*c && action != Delete)
    return FALSE;
a133 2
      else if (!(ace->a_type & ACL_DEFAULT))
	return FALSE;
@


1.22
log
@Clean up whitespace.
@
text
@d3 2
a4 1
   Copyright 2000, 2001, 2002, 2003, 2006, 2008, 2009, 2010, 2011 Red Hat Inc.
d391 1
a391 2
	    "Note: Under Cygwin, the default ACL entries are not taken into\n"
	    "account currently.\n\n", prog_name);
@


1.21
log
@	* Align usage output, version output, as well as usage and version
	option handling to use the same style throughout all Cygwin utils.
	Throughout use program_invocation_short_name to refer to current
	process name in Cygwin executables.
	* utils.sgml: Align documentation to above change.  Add missing
	sections for getconf, ldd, and setmetamode.
	* strace.cc (proc_child): Avoid compiler warning.
@
text
@d59 1
a59 1
        return ILLEGAL_MODE;
d71 2
a72 2
         | (in[1] == 'w' ? S_IWOTH : 0)
         | (in[2] == 'x' ? S_IXOTH : 0);
d130 1
a130 1
      	*c2++ = '\0';
d137 2
a138 2
        {
          char *c3;
d140 4
a143 4
          ace->a_id = strtol (c, &c3, 10);
          if (*c3)
            return FALSE;
        }
d145 6
a150 6
        {
          struct passwd *pw = getpwnam (c);
          if (!pw)
            return FALSE;
          ace->a_id = pw->pw_uid;
        }
d152 6
a157 6
        {
          struct group *gr = getgrnam (c);
          if (!gr)
            return FALSE;
          ace->a_id = gr->gr_gid;
        }
d197 1
a197 1
        fp = stdin;
d199 1
a199 1
        return FALSE;
d201 1
a201 1
        {
d206 6
a211 6
          if (!getaclentry (action, fb, acls + (*idx)++))
            {
              fclose (fp);
              return FALSE;
            }
        }
d218 1
a218 1
        return FALSE;
d229 1
a229 1
        || !aclp[i].a_type)
d242 1
a242 1
                     (src[s].a_type & (USER | GROUP)) ? src[s].a_id : -1);
d244 1
a244 1
        return -1;
d246 8
a253 8
        {
          if (t < tcnt)
            {
              for (i = t + 1; i < tcnt; ++i)
                tgt[i - 1] = tgt[i];
              --tcnt;
            }
        }
d255 5
a259 5
        {
          tgt[t] = src[s];
          if (t >= tcnt)
            ++tcnt;
        }
d293 19
a311 19
            "Usage: %s [-r] (-f ACL_FILE | -s acl_entries) FILE...\n"
            "       %s [-r] ([-d acl_entries] [-m acl_entries]) FILE...\n"
            "\n"
            "Modify file and directory access control lists (ACLs)\n"
            "\n"
            "  -d, --delete     delete one or more specified ACL entries\n"
            "  -f, --file       set ACL entries for FILE to ACL entries read\n"
            "                   from a ACL_FILE\n"
            "  -m, --modify     modify one or more specified ACL entries\n"
            "  -r, --replace    replace mask entry with maximum permissions\n"
            "                   needed for the file group class\n"
            "  -s, --substitute substitute specified ACL entries for the\n"
            "                   ACL of FILE\n"
            "  -h, --help       output usage information and exit\n"
            "  -V, --version    output version information and exit\n"
            "\n"
            "At least one of (-d, -f, -m, -s) must be specified\n"
            "\n", prog_name, prog_name);
  if (stream == stdout) 
d314 78
a391 78
            "     Acl_entries are one or more comma-separated ACL entries \n"
            "     from the following list:\n"
            "\n"
            "         u[ser]::perm\n"
            "         u[ser]:uid:perm\n"
            "         g[roup]::perm\n"
            "         g[roup]:gid:perm\n"
            "         m[ask]:perm\n"
            "         o[ther]:perm\n"
            "\n"
            "     Default entries are like the above with the additional\n"
            "     default identifier. For example: \n"
            "\n"
            "         d[efault]:u[ser]:uid:perm\n"
            "\n"
            "     'perm' is either a 3-char permissions string in the form\n"
            "     \"rwx\" with the character - for no permission\n"
            "     or it is the octal representation of the permissions, a\n"
            "     value from 0 (equivalent to \"---\") to 7 (\"rwx\").\n"
            "     'uid' is a user name or a numerical uid.\n"
            "     'gid' is a group name or a numerical gid.\n"
            "\n"
            "\n"
            "For each file given as parameter, %s will either replace its\n"
            "complete ACL (-s, -f), or it will add, modify, or delete ACL\n"
            "entries.\n"
            "\n"
            "The following options are supported:\n"
            "\n"
            "-d   Delete one or more specified entries from the file's ACL.\n"
            "     The owner, group and others entries must not be deleted.\n"
            "     Acl_entries to be deleted should be specified without\n"
            "     permissions, as in the following list:\n"
            "\n"
            "         u[ser]:uid\n"
            "         g[roup]:gid\n"
            "         d[efault]:u[ser]:uid\n"
            "         d[efault]:g[roup]:gid\n"
            "         d[efault]:m[ask]:\n"
            "         d[efault]:o[ther]:\n"
            "\n"
            "-f   Take the Acl_entries from ACL_FILE one per line. Whitespace\n"
            "     characters are ignored, and the character \"#\" may be used\n"
            "     to start a comment.  The special filename \"-\" indicates\n"
            "     reading from stdin.\n"
            "     Required entries are\n"
            "     - One user entry for the owner of the file.\n"
            "     - One group entry for the group of the file.\n"
            "     - One other entry.\n"
            "     If additional user and group entries are given:\n"
            "     - A mask entry for the file group class of the file.\n"
            "     - No duplicate user or group entries with the same uid/gid.\n"
            "     If it is a directory:\n"
            "     - One default user entry for the owner of the file.\n"
            "     - One default group entry for the group of the file.\n"
            "     - One default mask entry for the file group class.\n"
            "     - One default other entry.\n"
            "\n"
            "-m   Add or modify one or more specified ACL entries.\n"
            "     Acl_entries is a comma-separated list of entries from the \n"
            "     same list as above.\n"
            "\n"
            "-r   Causes the permissions specified in the mask entry to be\n"
            "     ignored and replaced by the maximum permissions needed for\n"
            "     the file group class.\n"
            "\n"
            "-s   Like -f, but substitute the file's ACL with Acl_entries\n" 
            "     specified in a comma-separated list on the command line.\n"
            "\n"
            "While the -d and -m options may be used in the same command, the\n"
            "-f and -s options may be used only exclusively.\n"
            "\n"
            "Directories may contain default ACL entries.  Files created\n"
            "in a directory that contains default ACL entries will have\n"
            "permissions according to the combination of the current umask,\n"
            "the explicit permissions requested and the default ACL entries\n"
            "Note: Under Cygwin, the default ACL entries are not taken into\n"
            "account currently.\n\n", prog_name);
d413 3
a415 3
          "POSIX ACL modification utility\n"
          "Copyright (C) 2000 - %s Red Hat, Inc.\n"
          "This is free software; see the source for copying conditions.  There is NO\n"
d417 4
a420 4
          CYGWIN_VERSION_DLL_MAJOR / 1000,
          CYGWIN_VERSION_DLL_MAJOR % 1000,
          CYGWIN_VERSION_DLL_MINOR,
          strrchr (__DATE__, ' ') + 1);
d440 8
a447 8
        if (action == NoAction)
          action = Delete;
        else if (action == Modify)
          action = ModNDel;
        else
          {
            usage (stderr);
            return 1;
d449 6
a454 6
        if (! getaclentries (Delete, optarg, acls, &aclidx))
          {
            fprintf (stderr, "%s: illegal acl entries\n", prog_name);
            return 2;
          }
        break;
d456 11
a466 6
        if (action == NoAction)
          action = Set;
        else
          {
            usage (stderr);
            return 1;
d468 1
a468 6
        if (! getaclentries (SetFromFile, optarg, acls, &aclidx))
          {
            fprintf (stderr, "%s: illegal acl entries\n", prog_name);
            return 2;
          }
        break;
d470 2
a471 2
        usage (stdout);
        return 0;
d473 8
a480 8
        if (action == NoAction)
          action = Modify;
        else if (action == Delete)
          action = ModNDel;
        else
          {
            usage (stderr);
            return 1;
d482 6
a487 6
        if (! getaclentries (Modify, optarg, acls, &aclidx))
          {
            fprintf (stderr, "%s: illegal acl entries\n", prog_name);
            return 2;
          }
        break;
d489 6
a494 6
        if (!ropt)
          ropt = 1;
        else
          {
            usage (stderr);
            return 1;
d496 1
a496 1
        break;
d498 11
a508 6
        if (action == NoAction)
          action = Set;
        else
          {
            usage (stderr);
            return 1;
d510 1
a510 6
        if (! getaclentries (Set, optarg, acls, &aclidx))
          {
            fprintf (stderr, "%s: illegal acl entries\n", prog_name);
            return 2;
          }
        break;
d512 2
a513 2
        print_version ();
        return 0;
d515 2
a516 2
        fprintf (stderr, "Try `%s --help' for more information.\n", prog_name);
        return 1;
d532 2
a533 2
        fprintf (stderr, "%s: more than one group entry.\n", prog_name);
        return 2;
d535 2
a536 2
        fprintf (stderr, "%s: more than one user entry.\n", prog_name);
        return 2;
d538 2
a539 2
        fprintf (stderr, "%s: more than one mask entry.\n", prog_name);
        return 2;
d541 2
a542 2
        fprintf (stderr, "%s: more than one other entry.\n", prog_name);
        return 2;
d544 2
a545 2
        fprintf (stderr, "%s: duplicate additional user or group.\n", prog_name);
        return 2;
d547 2
a548 2
        fprintf (stderr, "%s: invalid entry type.\n", prog_name);
        return 2;
d550 2
a551 2
        fprintf (stderr, "%s: missing entries.\n", prog_name);
        return 2;
d553 2
a554 2
        fprintf (stderr, "%s: out of memory.\n", prog_name);
        return 2;
d556 1
a556 1
        break;
@


1.20
log
@	* setfacl.c (getaclentry): Allow extra colon in mask and other entries.
@
text
@d13 1
d24 1
a41 1
static const char version[] = "$Revision: 1.13 $";
d295 1
d307 1
a307 1
            "  -v, --version    output version information and exit\n"
d310 1
a310 2
            "\n"
            "", prog_name, prog_name);
d391 1
a391 1
            "account currently.\n", prog_name);
d404 1
a404 1
  {"version", no_argument, NULL, 'v'},
d407 1
d412 9
a420 18
  const char *v = strchr (version, ':');
  int len;
  if (!v)
    {
      v = "?";
      len = 1;
    }
  else
    {
      v += 2;
      len = strchr (v, ' ') - v;
    }
  printf ("\
setfacl (cygwin) %.*s\n\
ACL Modification Utility\n\
Copyright 2000, 2001, 2002 Red Hat, Inc.\n\
Compiled on %s\n\
", len, v, __DATE__);
d433 1
a433 7
  prog_name = strrchr (argv[0], '/');
  if (prog_name == NULL)
    prog_name = strrchr (argv[0], '\\');
  if (prog_name == NULL)
    prog_name = argv[0];
  else
    prog_name++;
d436 1
a436 1
  while ((c = getopt_long (argc, argv, "d:f:hm:rs:v", longopts, NULL)) != EOF)
d511 1
a511 1
      case 'v':
d515 1
a515 1
        usage (stderr);
@


1.19
log
@	* setfacl.c (strchrnul): Drop local implementation.
@
text
@d114 5
a118 1
    ;
@


1.18
log
@	* setfacl.c (strchrnul): New function.
	(getaclentry): Rewrite.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002, 2003, 2006, 2008, 2009, 2010 Red Hat Inc.
a73 10
/* GNU extension.  Like strchr except that if c is not found, return pointer
   to the trailing \0, rather than NULL. */
static char *
strchrnul (const char *s, int c)
{
  while (*s && *s != c)
    ++s;
  return (char *) s;
}

@


1.17
log
@	* setfacl.c (getaclentry): Allow to delete default entries for the
	owner and owner group.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002, 2003, 2006, 2008, 2009 Red Hat Inc.
d74 10
d90 1
a90 1
  ace->a_id = -1;
d93 2
a94 2
  if (!strncmp (c, "default:", 8)
      || !strncmp (c, "d:", 2))
d99 9
a107 3
  if (!strncmp (c, "user:", 5)
      || !strncmp (c, "u:", 2))
    {
d109 1
a109 5
      c = strchr (c, ':') + 1;
    }
  else if (!strncmp (c, "group:", 6)
           || !strncmp (c, "g:", 2))
    {
d111 1
a111 5
      c = strchr (c, ':') + 1;
    }
  else if (!strncmp (c, "mask:", 5)
           || !strncmp (c, "m:", 2))
    {
d113 1
a113 5
      c = strchr (c, ':') + 1;
    }
  else if (!strncmp (c, "other:", 6)
           || !strncmp (c, "o:", 2))
    {
a114 2
      c = strchr (c, ':') + 1;
    }
d117 11
a127 1
  if (ace->a_type & (USER_OBJ | GROUP_OBJ))
d129 13
a141 23
      if ((c2 = strchr (c, ':')))
        {
          if (action == Delete)
            return FALSE;
          *c2 = '\0';
        }
      else if (action == Delete)
	{
	  /* Only default ugo entries are allowed to be removed, not the 
	     standard ugo entries. */
	  if (!(ace->a_type & ACL_DEFAULT))
	    return FALSE;
	}
      else
        return FALSE;
      if (!c2 && !*c) /* Deleting a default ug entry is allowed. */
	;
      else if (c2 == c)
        {
          if (action == Delete)
            return FALSE;
        }
      else if (isdigit ((unsigned char) *c))
d163 9
a171 12
      if (c2 && c2 != c)
        {
	  if (ace->a_type & USER_OBJ)
	    {
	      ace->a_type &= ~USER_OBJ;
	      ace->a_type |= USER;
	    }
	  else
	    {
	      ace->a_type &= ~GROUP_OBJ;
	      ace->a_type |= GROUP;
	    }
d173 2
a174 2
      if (c2)
        c = c2 + 1;
a175 3
  /* FIXME: currently allow both :: and : */
  else if (*c == ':')
    c++;
d178 4
a181 3
      if ((ace->a_type & (CLASS_OBJ | OTHER_OBJ))
          && *c)
        return FALSE;
d185 1
@


1.16
log
@	* mkpasswd.c (current_user): Don't use HOMEDRIVE/HOMEPATH to generate
	user's homedir.

	* mkgroup.c: Accommodate ctype changes.
	* mkpasswd.c: Ditto.
	* setfacl.c: Ditto.
	* ssp.c: Ditto.
@
text
@d123 8
a130 1
      else if (action != Delete)
d132 3
a134 1
      if (c2 == c)
d161 1
a161 1
      if (c2 != c)
@


1.15
log
@	* setfacl.c (setfacl): Change from void to int.  Return 2 in case of
	error.
	(main): Return with error code from setfacl.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002, 2003 Red Hat Inc.
d54 1
a54 1
  if (isdigit (*in) && !in[1])
d130 1
a130 1
      else if (isdigit (*c))
@


1.14
log
@bad_keywords
@
text
@d262 1
a262 1
void
d272 4
a275 2
        perror (prog_name);
      return;
d277 1
a277 1
  if ((lcnt = acl (path, GETACL, MAX_ACL_ENTRIES, lacl)) < 0
d280 5
a284 1
    perror (prog_name);
d437 1
d571 2
a572 2
    setfacl (action, argv[c], acls, aclidx);
  return 0;
@


1.13
log
@	* getfacl (main): Remove extern declaration of optind.
	* setfacl (main): Remove extern declaration of optarg and optind.
@
text
@d321 1
a321 1
            "     `perm' is either a 3-char permissions string in the form\n"
d325 2
a326 2
            "     `uid' is a user name or a numerical uid.\n"
            "     `gid' is a group name or a numerical gid.\n"
d386 1
a386 1
    fprintf(stream, "Try `%s --help' for more information.\n", prog_name);
@


1.12
log
@* cygcheck.cc (usage) Add description output.
@
text
@a425 2
  extern char *optarg;
  extern int optind;
@


1.11
log
@	* mkgroup.c: Fix copyright date.
	* mkpasswd.c: Ditto.
	* setfacl.c: Ditto.

	Fix ChangeLog typos.
@
text
@a286 1
            "\n"
@


1.10
log
@	* setfacl (usage): Remove double ":" for mask and other.
@
text
@d3 1
a3 1
   Copyright 2000, 2001 Red Hat Inc.
@


1.9
log
@	* setfacl.c (main): Place a single : after other and mask.
	* getfacl.c (getaclentry): Allow both : and :: for other and mask.
	(main): Remove extraneous break.
@
text
@d314 2
a315 2
            "         m[ask]::perm\n"
            "         o[ther]::perm\n"
@


1.8
log
@	* setfacl.c (getperm): Set only `other' permission bits.
	(getaclentry): Set a_id to -1 by default.
@
text
@d168 3
a170 2
  else if (*c++ != ':')
    return FALSE;
a512 1
        break;
@


1.7
log
@	* setfacl.c (usage): Add missing LF.
@
text
@d69 3
a71 3
  return (in[0] == 'r' ? S_IRUSR | S_IRGRP | S_IROTH : 0)
         | (in[1] == 'w' ? S_IWUSR | S_IWGRP | S_IWOTH : 0)
         | (in[2] == 'x' ? S_IXUSR | S_IXGRP | S_IXOTH : 0);
d80 1
a80 1
  ace->a_id = 0;
@


1.6
log
@Add final newlines to utils
@
text
@d386 1
a386 1
    fprintf(stream, "Try `%s --help' for more information.", prog_name);
@


1.5
log
@        * setfacl.c (usage): Standardize usage output. Change return type to
        static void.
        (print_version): New function.
        (longopts): Added longopts for all options.
        (main): Accommodate changes in usage function and new version option.
@
text
@d419 2
a420 1
Compiled on %s", len, v, __DATE__);
@


1.4
log
@	* getfacl.c (username): New function.
	(groupname): Ditto.
	(usage): Ditto.  Add more user friendly help text.
	(main): Add -n and --help option.  Print names instead of IDs
	unless -n option is given.
	* setfacl.c (getperm): Tolerate whitespace and comment chars in input.
	(getaclentry): Fix several input string misdetections.
	(getaclentries): Allow - as input file name to read from stdin.
	Tolerate whitespace and comment chars in input.
	(usage): Add more user friendly help text.
	(main): Add --help option.
@
text
@d40 3
a51 2
char *myname;

d271 1
a271 1
        perror (myname);
d277 1
a277 1
    perror (myname);
d280 2
a281 5
#define pn(txt)	fprintf (fp, txt "\n", myname)
#define p(txt)	fprintf (fp, txt "\n")

int
usage (int help)
d283 102
a384 7
  FILE *fp = help ? stdout : stderr;

  pn ("usage: %s [-r] -s acl_entries file...");
  pn ("       %s [-r] -md acl_entries file...");
  pn ("       %s [-r] -f acl_file file...");
  if (!help)
    pn ("Try `%s --help' for more information.");
d386 1
a386 82
    {
      p ("");
      p ("Modify file and directory access control lists (ACLs)");
      p ("");
      pn ("For each file given as parameter, %s will either replace its");
      p ("complete ACL (-s, -f)), or it will add, modify, or delete ACL");
      p ("entries.");
      p ("");
      p ("The following options are supported:");
      p ("");
      p ("-s   Substitute the ACL of the file by the entries specified on");
      p ("     the command line.  Required entries are");
      p ("     - One user entry for the owner of the file.");
      p ("     - One group entry for the group of the file.");
      p ("     - One other entry.");
      p ("     If additional user and group entries are given:");
      p ("     - A mask entry for the file group class of the file.");
      p ("     - No duplicate user or group entries with the same uid/gid.");
      p ("     If it is a directory:");
      p ("     - One default user entry for the owner of the file.");
      p ("     - One default group entry for the group of the file.");
      p ("     - One default mask entry for the file group class of the file.");
      p ("     - One default other entry.");
      p ("");
      p ("     Acl_entries are one or more comma-separated ACL entries from");
      p ("     the following list:");
      p ("");
      p ("         u[ser]::perm");
      p ("         u[ser]:uid:perm");
      p ("         g[roup]::perm");
      p ("         g[roup]:gid:perm");
      p ("         m[ask]::perm");
      p ("         o[ther]::perm");
      p ("");
      p ("     Default entries are like the above with the trailing default");
      p ("     identifier.  E.g.");
      p ("");
      p ("         d[efault]:u[ser]:uid:perm");
      p ("");
      p ("     `perm' is either a 3-char permissions string in the form");
      p ("     \"rwx\" with the character - for not setting a permission");
      p ("     or it is the octal representation of the permissions, a");
      p ("     value from 0 (equivalent to \"---\") to 7 (\"rwx\").");
      p ("     `uid' is a user name or a numerical uid.");
      p ("     `gid' is a group name or a numerical gid.");
      p ("");
      p ("-f   Like -s but take the ACL entries from `acl_file'.  Acl_entries");
      p ("     are given one per line.  Whitespace characters are ignored,");
      p ("     the character \"#\" may be used to start a comment.  The");
      p ("     special filename \"-\" indicates reading from stdin.");
      p ("");
      p ("-m   Add or modify one or more specified ACL entries.  Acl_entries");
      p ("     is a comma-separated list of entries from the same list as");
      p ("     above.");
      p ("");
      p ("-d   Delete one or more specified entries from the file's ACL.");
      p ("     The owner, group and others entries must not be deleted");
      p ("     Acl_entries are one or more comma-separated ACL entries");
      p ("     without permissions, taken from the following list:");
      p ("");
      p ("         u[ser]:uid");
      p ("         g[roup]:gid");
      p ("         d[efault]:u[ser]:uid");
      p ("         d[efault]:g[roup]:gid");
      p ("         d[efault]:m[ask]:");
      p ("         d[efault]:o[ther]:");
      p ("");
      p ("-r   Causes the permissions specified in the mask entry to be");
      p ("     ignored and replaced by the maximum permissions needed for");
      p ("     the file group class.");
      p ("");
      p ("While the -m and -d options may be used in the same command, the");
      p ("-s and -f options may be used only exclusively.");
      p ("");
      p ("Directories may contain default ACL entries.  Files created");
      p ("in a directory that contains default ACL entries will have");
      p ("permissions according to the combination of the current umask,");
      p ("the explicit permissions requested and the default ACL entries");
      p ("Note: Under Cygwin, the default ACL entries are not taken into");
      p ("account currently.");
    }
  return 1;
d390 5
d396 1
d400 22
d433 8
a440 1
  myname = argv[0];
d442 1
a442 1
  while ((c = getopt_long (argc, argv, "d:f:m:rs:", longopts, NULL)) != EOF)
d451 4
a454 1
          return usage (0);
d457 1
a457 1
            fprintf (stderr, "%s: illegal acl entries\n", myname);
d465 4
a468 1
          return usage (0);
d471 1
a471 1
            fprintf (stderr, "%s: illegal acl entries\n", myname);
d475 3
d484 4
a487 1
          return usage (0);
d490 1
a490 1
            fprintf (stderr, "%s: illegal acl entries\n", myname);
d498 4
a501 1
          return usage (0);
d507 4
a510 1
          return usage (0);
d514 1
a514 1
            fprintf (stderr, "%s: illegal acl entries\n", myname);
d518 3
a520 2
      case 'h':
        return usage (1);
d522 2
a523 1
        return usage (0);
d526 4
a529 1
    return usage (0);
d531 4
a534 1
    return usage (0);
d539 1
a539 1
        fprintf (stderr, "%s: more than one group entry.\n", myname);
d542 1
a542 1
        fprintf (stderr, "%s: more than one user entry.\n", myname);
d545 1
a545 1
        fprintf (stderr, "%s: more than one mask entry.\n", myname);
d548 1
a548 1
        fprintf (stderr, "%s: more than one other entry.\n", myname);
d551 1
a551 1
        fprintf (stderr, "%s: duplicate additional user or group.\n", myname);
d554 1
a554 1
        fprintf (stderr, "%s: invalid entry type.\n", myname);
d557 1
a557 1
        fprintf (stderr, "%s: missing entries.\n", myname);
d560 1
a560 1
        fprintf (stderr, "%s: out of memory.\n", myname);
@


1.3
log
@        * getfacl.c: Add copyright hint.
        * setfacl.c: Ditto.
        * strace.cc: Ditto.
@
text
@a50 8
int usage ()
{
  fprintf(stderr, "usage: %s [-r] -s acl_entries file...\n", myname);
  fprintf(stderr, "       %s [-r] -md acl_entries file...\n", myname);
  fprintf(stderr, "       %s [-r] -f acl_file file...\n", myname);
  return 1;
}

d60 2
a102 2
      if (!(ace->a_type & ACL_DEFAULT))
        return FALSE;
a108 2
      if (!(ace->a_type & ACL_DEFAULT))
        return FALSE;
d151 1
a151 1
      if (ace->a_type & USER_OBJ)
d153 11
a163 8
          ace->a_type &= ~USER_OBJ;
          ace->a_type |= USER;
        }
      else
        {
          ace->a_type &= ~GROUP_OBJ;
          ace->a_type |= GROUP;
        }
d167 2
d190 1
a190 1
      char fbuf[256];
d192 3
a194 1
      if (! (fp = fopen (buf, "r")))
d196 1
a196 1
      while (fgets (fbuf, 256, fp))
d198 5
a202 1
          if (!getaclentry (action, fbuf, acls + (*idx)++))
d208 2
a209 1
      fclose (fp);
d279 103
d395 1
a395 1
  while ((c = getopt (argc, argv, "d:f:m:rs:")) != EOF)
d404 1
a404 1
          return usage ();
d415 1
a415 1
          return usage ();
d428 1
a428 1
          return usage ();
d439 1
a439 1
          return usage ();
d445 1
a445 1
          return usage ();
d452 3
d456 1
a456 1
        return usage ();
d459 1
a459 1
    return usage ();
d461 1
a461 1
    return usage ();
a495 1

@


1.2
log
@* Makefile.in: Accomodate newer gcc's which require linking of c++ programs
with g++.  Fixup output for some compilations.
* cygcheck.cc: Respond to compiler warnings.
* dumper.cc (main): Ditto.
* parse_pe.cc (exclusion::sort_and_check): Ditto.
* setfacl.cc (getaclentry): Ditto.
@
text
@d1 11
@


1.1
log
@Initial revision
@
text
@d115 1
a115 1
      if (c2 = strchr (c, ':'))
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
