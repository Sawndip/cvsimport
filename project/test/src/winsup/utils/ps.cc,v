head	1.38;
access;
symbols
	cygwin-1_7_35-release:1.38
	cygwin-1_7_34-release:1.38
	cygwin-1_7_33-release:1.38
	cygwin-1_7_32-release:1.38
	cygwin-1_7_31-release:1.38
	cygwin-1_7_30-release:1.38
	cygwin-1_7_29-release:1.38
	cygwin-1_7_29-release-branchpoint:1.38.0.2
	cygwin-1_7_28-release:1.38
	cygwin-1_7_27-release:1.38
	cygwin-1_7_26-release:1.38
	cygwin-1_7_25-release:1.38
	cygwin-1_7_24-release:1.38
	cygwin-1_7_23-release:1.38
	cygwin-1_7_22-release:1.38
	cygwin-1_7_21-release:1.38
	cygwin-1_7_20-release:1.38
	cygwin-1_7_19-release:1.38
	cygwin-64bit-postmerge:1.38
	cygwin-64bit-premerge-branch:1.37.0.2
	cygwin-64bit-premerge:1.37
	cygwin-1_7_18-release:1.37
	cygwin-1_7_17-release:1.36
	cygwin-64bit-branch:1.36.0.2
	cygwin-1_7_16-release:1.36
	cygwin-1_7_15-release:1.35
	cygwin-1_7_14_2-release:1.35
	cygwin-1_7_14-release:1.35
	cygwin-1_7_12-release:1.35
	cygwin-1_7_11-release:1.35
	cygwin-1_7_10-release:1.35
	cygwin-1_7_9-release:1.28
	cygwin-1_7_8-release:1.28
	cygwin-1_7_7-release:1.28
	cygwin-1_7_5-release:1.27
	cygwin-1_7_4-release:1.27
	cygwin-1_7_3-release:1.27
	cygwin-1_7_2-release:1.27
	cygwin-1_7_1-release:1.26
	cv-branch-2:1.26.0.2
	cr-0x5f1:1.21.0.4
	cv-branch:1.21.0.2
	cr-0x3b58:1.19.0.2
	cr-0x9e:1.17.0.10
	cr-0x9d:1.17.0.8
	corinna-01:1.17
	cr-0x9c:1.17.0.4
	cr-0x9b:1.17.0.6
	cr-0x99:1.17
	Z-emcb-cygwin_daemon:1.17.0.2
	w32api-2_2:1.16
	mingw-runtime-2_4:1.16
	cygnus_cvs_20020108_pre:1.11
	Z-cygwin_daemon_merge-new_HEAD:1.10
	Z-cygwin_daemon_merge_HEAD:1.10
	cygwin_daemon:1.10.0.6;
locks; strict;
comment	@// @;
expand	@o@;


1.38
date	2013.04.23.09.44.36;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2013.01.21.16.28.27;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2012.07.06.14.52.33;	author corinna;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2011.12.22.13.48.05;	author corinna;	state Exp;
branches;
next	1.34;

1.34
date	2011.12.22.12.40.26;	author corinna;	state Exp;
branches;
next	1.33;

1.33
date	2011.12.17.23.39.47;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2011.11.28.17.49.56;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2011.10.10.14.57.47;	author corinna;	state Exp;
branches;
next	1.30;

1.30
date	2011.08.10.19.52.41;	author corinna;	state Exp;
branches;
next	1.29;

1.29
date	2011.05.29.15.20.10;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2010.08.28.11.22.37;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2009.12.18.03.34.59;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2009.05.11.14.01.17;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2008.09.12.22.43.10;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2008.07.22.14.40.05;	author corinna;	state Exp;
branches;
next	1.23;

1.23
date	2008.03.12.12.47.09;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2007.12.06.18.26.18;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2006.02.17.11.16.23;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2006.02.16.11.17.19;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2005.01.16.17.13.51;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2004.10.25.15.49.36;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.26.21.52.03;	author joshuadfranklin;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.15.19.24.36;	author joshuadfranklin;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.29.20.10.27;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.29.15.07.14;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.28.14.59.36;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.28.03.38.36;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.11.22.51.01;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.29.02.32.18;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.18.22.58.34;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.18.04.55.01;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.15.03.43.48;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.09.03.31.10;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.25.02.25.52;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.24.19.03.12;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.29.16.26.37;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.18.18.39.11;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.36.2.1
date	2012.08.13.20.05.40;	author corinna;	state Exp;
branches;
next	1.36.2.2;

1.36.2.2
date	2012.08.16.16.27.41;	author corinna;	state Exp;
branches;
next	1.36.2.3;

1.36.2.3
date	2013.01.29.21.54.42;	author corinna;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.38
log
@	* Merge in cygwin-64bit-branch.
@
text
@/* ps.cc

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include <errno.h>
#include <stdio.h>
#include <locale.h>
#include <wchar.h>
#include <windows.h>
#include <time.h>
#include <getopt.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>
#include <limits.h>
#include <sys/cygwin.h>
#include <cygwin/version.h>
#include <psapi.h>
#include <ntdef.h>
#include <ntdll.h>
#include "loadlib.h"

/* Maximum possible path length under NT.  There's no official define
   for that value.  Note that PATH_MAX is only 4K. */
#define NT_MAX_PATH 32768

static char *prog_name;

static struct option longopts[] =
{
  {"all", no_argument, NULL, 'a' },
  {"everyone", no_argument, NULL, 'e' },
  {"full", no_argument, NULL, 'f' },
  {"help", no_argument, NULL, 'h' },
  {"long", no_argument, NULL, 'l' },
  {"process", required_argument, NULL, 'p'},
  {"summary", no_argument, NULL, 's' },
  {"user", required_argument, NULL, 'u'},
  {"version", no_argument, NULL, 'V'},
  {"windows", no_argument, NULL, 'W'},
  {NULL, 0, NULL, 0}
};

static char opts[] = "aefhlp:su:VW";

static char *
start_time (external_pinfo *child)
{
  time_t st = child->start_time;
  time_t t = time (NULL);
  static char stime[40] = {'\0'};
  char now[40];

  strncpy (stime, ctime (&st) + 4, 15);
  strcpy (now, ctime (&t) + 4);

  if ((t - st) < (24 * 3600))
    return (stime + 7);

  stime[6] = '\0';

  return stime;
}

#define FACTOR (0x19db1ded53ea710LL)
#define NSPERSEC 10000000LL

/* Convert a Win32 time to "UNIX" format. */
long __stdcall
to_time_t (FILETIME *ptr)
{
  /* A file time is the number of 100ns since jan 1 1601
     stuffed into two long words.
     A time_t is the number of seconds since jan 1 1970.  */

  long rem;
  long long x = ((long long) ptr->dwHighDateTime << 32) + ((unsigned)ptr->dwLowDateTime);
  x -= FACTOR;                  /* number of 100ns between 1601 and 1970 */
  rem = x % ((long long)NSPERSEC);
  rem += (NSPERSEC / 2);
  x /= (long long) NSPERSEC;            /* number of 100ns in a second */
  x += (long long) (rem / NSPERSEC);
  return x;
}

static const char *
ttynam (int ntty)
{
  static char buf[9];
  char buf0[9];
  if (ntty < 0)
    strcpy (buf0, "?");
  else if (ntty & 0xffff0000)
    sprintf (buf0, "cons%d", ntty & 0xff);
  else
    sprintf (buf0, "pty%d", ntty);
  sprintf (buf, " %-7s", buf0);
  return buf;
}

static void
usage (FILE * stream, int status)
{
  fprintf (stream, "\
Usage: %1$s [-aefls] [-u UID] [-p PID]\n\
\n\
Report process status\n\
\n\
 -a, --all       show processes of all users\n\
 -e, --everyone  show processes of all users\n\
 -f, --full      show process uids, ppids\n\
 -h, --help      output usage information and exit\n\
 -l, --long      show process uids, ppids, pgids, winpids\n\
 -p, --process   show information for specified PID\n\
 -s, --summary   show process summary\n\
 -u, --user      list processes owned by UID\n\
 -V, --version   output version information and exit\n\
 -W, --windows   show windows as well as cygwin processes\n\
\n\
With no options, %1$s outputs the long format by default\n\n",
	   prog_name);
  exit (status);
}

static void
print_version ()
{
  printf ("ps (cygwin) %d.%d.%d\n"
	  "Show process statistics\n"
	  "Copyright (C) 1996 - %s Red Hat, Inc.\n"
	  "This is free software; see the source for copying conditions.  There is NO\n"
	  "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n",
	  CYGWIN_VERSION_DLL_MAJOR / 1000,
	  CYGWIN_VERSION_DLL_MAJOR % 1000,
	  CYGWIN_VERSION_DLL_MINOR,
	  strrchr (__DATE__, ' ') + 1);
}

char unicode_buf[sizeof (UNICODE_STRING) + NT_MAX_PATH];

int
main (int argc, char *argv[])
{
  external_pinfo *p;
  int aflag, lflag, fflag, sflag, proc_id;
  uid_t uid;
  bool found_proc_id = true;
  DWORD proc_access = PROCESS_QUERY_LIMITED_INFORMATION;
  cygwin_getinfo_types query = CW_GETPINFO;
  const char *dtitle = "    PID  TTY        STIME COMMAND\n";
  const char *dfmt   = "%7d%4s%10s %s\n";
  const char *ftitle = "     UID     PID    PPID  TTY        STIME COMMAND\n";
  const char *ffmt   = "%8.8s%8d%8d%4s%10s %s\n";
  const char *ltitle = "      PID    PPID    PGID     WINPID   TTY     UID    STIME COMMAND\n";
  const char *lfmt   = "%c %7d %7d %7d %10u %4s %4u %8s %s\n";
  char ch;
  PUNICODE_STRING uni = (PUNICODE_STRING) unicode_buf;
  void *drive_map = NULL;

  aflag = lflag = fflag = sflag = 0;
  uid = getuid ();
  proc_id = -1;
  lflag = 1;

  setlocale (LC_ALL, "");

  prog_name = program_invocation_short_name;

  while ((ch = getopt_long (argc, argv, opts, longopts, NULL)) != EOF)
    switch (ch)
      {
      case 'a':
      case 'e':
	aflag = 1;
	break;
      case 'f':
	fflag = 1;
	break;
      case 'h':
	usage (stdout, 0);
      case 'l':
	lflag = 1;
	break;
      case 'p':
	proc_id = atoi (optarg);
	aflag = 1;
	found_proc_id = false;
	break;
      case 's':
	sflag = 1;
	break;
      case 'u':
	uid = atoi (optarg);
	if (uid == 0)
	  {
	    struct passwd *pw;

	    if ((pw = getpwnam (optarg)))
	      uid = pw->pw_uid;
	    else
	      {
		fprintf (stderr, "%s: user %s unknown\n", prog_name, optarg);
		exit (1);
	      }
	  }
	break;
      case 'V':
	print_version ();
	exit (0);
	break;
      case 'W':
	query = CW_GETPINFO_FULL;
	aflag = 1;
	break;

      default:
	fprintf (stderr, "Try `%s --help' for more information.\n", prog_name);
	exit (1);
      }

  if (sflag)
    printf (dtitle);
  else if (fflag)
    printf (ftitle);
  else if (lflag)
    printf (ltitle);

  (void) cygwin_internal (CW_LOCK_PINFO, 1000);

  if (query == CW_GETPINFO_FULL)
    {
      /* Enable debug privilege to allow to enumerate all processes,
	 not only processes in current session. */
      HANDLE tok;
      if (OpenProcessToken (GetCurrentProcess (),
			    TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
			    &tok))
	{
	  TOKEN_PRIVILEGES priv;

	  priv.PrivilegeCount = 1;
	  if (LookupPrivilegeValue (NULL, SE_DEBUG_NAME,
				    &priv.Privileges[0].Luid))
	    {
	      priv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
	      AdjustTokenPrivileges (tok, FALSE, &priv, 0, NULL, NULL);
	    }
	}

      /* Check process query capabilities. */
      OSVERSIONINFO version;
      version.dwOSVersionInfoSize = sizeof version;
      GetVersionEx (&version);
      if (version.dwMajorVersion <= 5)	/* pre-Vista */
	{
	  proc_access = PROCESS_QUERY_INFORMATION;
	  if (version.dwMinorVersion < 1)	/* Windows 2000 */
	    proc_access |= PROCESS_VM_READ;
	  else
	    {
	    }
	}

      /* Except on Windows 2000, fetch an opaque drive mapping object from the
	 Cygwin DLL.  This is used to map NT device paths to Win32 paths. */
      if (!(proc_access & PROCESS_VM_READ))
	{
	  drive_map = (void *) cygwin_internal (CW_ALLOC_DRIVE_MAP);
	  /* Check old Cygwin version. */
	  if (drive_map == (void *) -1)
	    drive_map = NULL;
	  /* Allow fallback to GetModuleFileNameEx for post-W2K. */
	  if (!drive_map)
	    proc_access = PROCESS_QUERY_INFORMATION | PROCESS_VM_READ;
	}
    }

  for (int pid = 0;
       (p = (external_pinfo *) cygwin_internal (query, pid | CW_NEXTPID));
       pid = p->pid)
    {
      if ((proc_id > 0) && (p->pid != proc_id))
	continue;
      else
	found_proc_id = true;

      if (aflag)
	/* nothing to do */;
      else if (p->version >= EXTERNAL_PINFO_VERSION_32_BIT)
	{
	  if (p->uid32 != uid)
	    continue;
	}
      else if (p->uid != uid)
	continue;
      char status = ' ';
      if (p->process_state & PID_STOPPED)
	status = 'S';
      else if (p->process_state & PID_TTYIN)
	status = 'I';
      else if (p->process_state & PID_TTYOU)
	status = 'O';

      /* Maximum possible path length under NT.  There's no official define
	 for that value. */
      char pname[NT_MAX_PATH + sizeof (" <defunct>")];
      if (p->ppid)
	{
	  char *s;
	  pname[0] = '\0';
	  strncat (pname, p->progname_long, NT_MAX_PATH);
	  s = strchr (pname, '\0') - 4;
	  if (s > pname && strcasecmp (s, ".exe") == 0)
	    *s = '\0';
	  if (p->process_state & PID_EXITED || (p->exitcode & ~0xffff))
	    strcat (pname, " <defunct>");
	}
      else if (query == CW_GETPINFO_FULL)
	{
	  HANDLE h;
	  NTSTATUS status;
	  wchar_t *win32path = NULL;

	  h = OpenProcess (proc_access, FALSE, p->dwProcessId);
	  if (!h)
	    continue;
	  /* We use NtQueryInformationProcess in the first place, because
	     GetModuleFileNameEx does not work on 64 bit systems when trying
	     to fetch module names of 64 bit processes. */
	  if (!(proc_access & PROCESS_VM_READ))	/* Windows 2000 */
	    {
	      status = NtQueryInformationProcess (h, ProcessImageFileName, uni,
						  sizeof unicode_buf, NULL);
	      if (NT_SUCCESS (status))
		{
		  /* NtQueryInformationProcess returns a native NT device path.
		     Call CW_MAP_DRIVE_MAP to convert the path to an ordinary
		     Win32 path.  The returned pointer is a pointer into the
		     incoming buffer given as third argument.  It's expected
		     to be big enough, which we made sure by defining
		     unicode_buf to have enough space for a maximum sized
		     UNICODE_STRING. */
		  if (uni->Length == 0)	/* System process */
		    win32path = (wchar_t *) L"System";
		  else
		    {
		      uni->Buffer[uni->Length / sizeof (WCHAR)] = L'\0';
		      win32path = (wchar_t *) cygwin_internal (CW_MAP_DRIVE_MAP,
							       drive_map,
							       uni->Buffer);
		    }
		}
	    }
	  else
	    {
	      if (GetModuleFileNameExW (h, NULL, (PWCHAR) unicode_buf,
					NT_MAX_PATH))
		win32path = (wchar_t *) unicode_buf;
	    }
	  if (win32path)
	    wcstombs (pname, win32path, sizeof pname);
	  else
	    strcpy (pname, "*** unknown ***");
	  FILETIME ct, et, kt, ut;
	  if (GetProcessTimes (h, &ct, &et, &kt, &ut))
	    p->start_time = to_time_t (&ct);
	  CloseHandle (h);
	}

      char uname[128];

      if (fflag)
	{
	  struct passwd *pw;

	  if ((pw = getpwuid (p->version >= EXTERNAL_PINFO_VERSION_32_BIT ?
			      p->uid32 : p->uid)))
	    strcpy (uname, pw->pw_name);
	  else
	    sprintf (uname, "%u", (unsigned)
		     (p->version >= EXTERNAL_PINFO_VERSION_32_BIT ?
		      p->uid32 : p->uid));
	}

      if (sflag)
	printf (dfmt, p->pid, ttynam (p->ctty), start_time (p), pname);
      else if (fflag)
	printf (ffmt, uname, p->pid, p->ppid, ttynam (p->ctty), start_time (p),
		pname);
      else if (lflag)
	printf (lfmt, status, p->pid, p->ppid, p->pgid,
		p->dwProcessId, ttynam (p->ctty),
		p->version >= EXTERNAL_PINFO_VERSION_32_BIT ? p->uid32 : p->uid,
		start_time (p), pname);

    }
  if (drive_map)
    cygwin_internal (CW_FREE_DRIVE_MAP, drive_map);
  (void) cygwin_internal (CW_UNLOCK_PINFO);

  return found_proc_id ? 0 : 1;
}
@


1.37
log
@Update copyrights
@
text
@d152 2
a153 1
  int aflag, lflag, fflag, sflag, uid, proc_id;
d298 1
a298 1
	  if (p->uid32 != (__uid32_t) uid)
@


1.36
log
@	* cygpath.cc: Change including headers to allow building against
	Mingw64 headers. Include ntdef.h and ntdll.h rather than ddk headers.
	Define _WIN32_WINNT and WINVER as 0x0602.
	(RtlEqualUnicodePathPrefix): Drop definition.  Pulled in from ntdll.h
	now.
	(get_device_name): s/Zw/Nt.
	* dumper.cc: Include sys/param.h
	(dumper::dump_memory_region): Use MIN rather than min.
	* locale.cc: Include stdlib.h.  Define _WIN32_WINNT and WINVER as
	0x0602.
	* ps.cc: Include ntdef.h and ntdll.h rather than ddk headers.
	* regtool.cc (regDeleteKeyEx): Drop WINADVAPI qualifier.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2008, 2009, 2010, 2011 Red Hat, Inc.
@


1.36.2.1
log
@	* ps.cc (main): Drop unneeded cast.
@
text
@d297 1
a297 1
	  if (p->uid32 != uid)
@


1.36.2.2
log
@	* ps.cc (main): Define uid correctly as uid_t.
@
text
@d152 1
a152 2
  int aflag, lflag, fflag, sflag, proc_id;
  uid_t uid;
@


1.36.2.3
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.35
log
@	Don't leave Windows 2000 behind.

	* Makefile.in (ps.exe): Revert previous change.
	* ps.cc: Include psapi.h again.
	(main): In CW_GETPINFO_FULL case.  Evaluate minimal process access mask
	required per OS and use that in OpenProcess call.  Use
	GetModuleFileNameExW on Windows 2000 or if fetching the drive mapping
	failed.  Handle empty process name.
@
text
@d26 2
a27 2
#include <ddk/ntapi.h>
#include <ddk/winddk.h>
d350 1
a350 1
		    win32path = L"System";
@


1.34
log
@	* Makefile.in (ps.exe): Drop -lpsapi from ALL_LDFLAGS.
	* ps.cc: Don't include psapi.h.
	(dosdevs): Drop.
	(unicode_buf): Define.
	(main): Simplify path evaluation in CW_GETPINFO_FULL case. Fetch drive
	map from Cygwin DLL.  Use it to convert NT device paths to Win32 paths.
@
text
@d25 1
d154 1
d255 27
a281 6
      /* Fetch an opaque drive mapping object from the Cygwin DLL.
	 This is used to map NT device paths to Win32 paths. */
      drive_map = (void *) cygwin_internal (CW_ALLOC_DRIVE_MAP);
      /* Check old Cygwin version. */
      if (drive_map == (void *) -1)
	drive_map = NULL;
d324 1
a324 1
      else if (query == CW_GETPINFO_FULL && drive_map)
d330 1
a330 2
	  h = OpenProcess (PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
			   FALSE, p->dwProcessId);
d333 28
a360 3
	  status = NtQueryInformationProcess (h, ProcessImageFileName, uni,
					      sizeof unicode_buf, NULL);
	  if (NT_SUCCESS (status))
d362 3
a364 9
	      /* NtQueryInformationProcess returns a native NT device path.
		 Call CW_MAP_DRIVE_MAP to convert the path to an ordinary
		 Win32 path.  The returned pointer is a pointer into the
		 incoming buffer given as third argument.  It's expected
		 to be big enough, which we made sure by defining unicode_buf
		 to have enough space for a maximum sized UNICODE_STRING. */
	      uni->Buffer[uni->Length / sizeof (WCHAR)] = L'\0';
	      win32path = (wchar_t *) cygwin_internal (CW_MAP_DRIVE_MAP,
						       drive_map, uni->Buffer);
@


1.33
log
@Clean up whitespace.
@
text
@a24 1
#include <psapi.h>
d145 1
a145 1
char dosdevs[32000];
d161 2
a162 1
  PUNICODE_STRING uni = NULL;
d253 6
d301 1
a301 1
      else if (query == CW_GETPINFO_FULL)
d303 6
a308 2
	  HANDLE h = OpenProcess (PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
				  FALSE, p->dwProcessId);
d311 3
a313 9
	  HMODULE hm[1000];
	  DWORD n = p->dwProcessId;
	  if (!EnumProcessModules (h, hm, sizeof (hm), &n))
	    n = 0;
	  /* This occurs when trying to enum modules of a 64 bit process.
	     GetModuleFileNameEx with a NULL module will return the same error.
	     Only NtQueryInformationProcess allows to fetch the process image
	     name in that case. */
	  if (!n && GetLastError () == ERROR_PARTIAL_COPY)
d315 9
a323 39
	      NTSTATUS status;
	      char pbuf[PATH_MAX];
	      char dev[256];
	      size_t len = sizeof (UNICODE_STRING) + PATH_MAX * sizeof (WCHAR);

	      if (!uni)
		{
		  uni = (PUNICODE_STRING) alloca (len);
		  QueryDosDevice (NULL, dosdevs, 32000);
		}
	      status = NtQueryInformationProcess (h, ProcessImageFileName, uni,
						  len, NULL);
	      if (NT_SUCCESS (status)
		  && (len = wcsnrtombs (pbuf, (const wchar_t **) &uni->Buffer,
					uni->Length / sizeof (WCHAR), PATH_MAX,
					NULL)) > 0)
		{
		  pbuf[len] = '\0';
		  if (!strncmp (pbuf, "\\Device\\Mup\\", 12))
		    {
		      strcpy (pname, "\\\\");
		      strcpy (pname + 2, pbuf + 12);
		    }
		  else
		    {
		      strcpy (pname, pbuf);
		      for (char *d = dosdevs; *d; d = strchr (d, '\0') + 1)
			if (QueryDosDevice (d, dev, 256)
			    && strlen (d) < 3
			    && !strncmp (dev, pbuf, strlen (dev)))
			  {
			    strcpy (pname, d);
			    strcat (pname, pbuf + strlen (dev));
			    break;
			  }
		    }
		}
	      else
		strcpy (pname, "*** unknown ***");
d325 2
d328 1
a328 8
	    {
	      wchar_t pwname[NT_MAX_PATH];

	      if (!n || !GetModuleFileNameExW (h, hm[0], pwname, NT_MAX_PATH))
		strcpy (pname, "*** unknown ***");
	      else
		wcstombs (pname, pwname, NT_MAX_PATH);
	    }
d362 2
@


1.32
log
@	* ps.cc: Remove all Win 9x considerations.  Use psapi functions
	directly.  Drop support for older Cygwin DLLs.  Just use progname_long
	as is since it's already a POSIX path now.  Rename "tty" to "pty" as in
	the Cygwin DLL.  Call setlocale to make sure wcstombs does the right
	thing according to the current locale.
	* Makefile.in (ps.exe): Link against psapi.dll.
@
text
@d136 3
a138 3
          "Show process statistics\n"
          "Copyright (C) 1996 - %s Red Hat, Inc.\n"
          "This is free software; see the source for copying conditions.  There is NO\n"
d140 4
a143 4
          CYGWIN_VERSION_DLL_MAJOR / 1000,
          CYGWIN_VERSION_DLL_MAJOR % 1000,
          CYGWIN_VERSION_DLL_MINOR,
          strrchr (__DATE__, ' ') + 1);
d282 1
a282 1
         for that value. */
d358 1
a358 1
	      	wcstombs (pname, pwname, NT_MAX_PATH);
@


1.31
log
@	* Align usage output, version output, as well as usage and version
	option handling to use the same style throughout all Cygwin utils.
	Throughout use program_invocation_short_name to refer to current
	process name in Cygwin executables.
	* utils.sgml: Align documentation to above change.  Add missing
	sections for getconf, ldd, and setmetamode.
	* strace.cc (proc_child): Avoid compiler warning.
@
text
@d14 1
a24 1
#include <tlhelp32.h>
a52 106
typedef BOOL (WINAPI *ENUMPROCESSMODULES)(
  HANDLE hProcess,      // handle to the process
  HMODULE * lphModule,  // array to receive the module handles
  DWORD cb,             // size of the array
  LPDWORD lpcbNeeded    // receives the number of bytes returned
);

typedef DWORD (WINAPI *GETMODULEFILENAME)(
  HANDLE hProcess,
  HMODULE hModule,
  LPTSTR lpstrFileName,
  DWORD nSize
);

typedef HANDLE (WINAPI *CREATESNAPSHOT)(
    DWORD dwFlags,
    DWORD th32ProcessID
);

// Win95 functions
typedef BOOL (WINAPI *PROCESSWALK)(
    HANDLE hSnapshot,
    LPPROCESSENTRY32 lppe
);

ENUMPROCESSMODULES myEnumProcessModules;
GETMODULEFILENAME myGetModuleFileNameEx;
CREATESNAPSHOT myCreateToolhelp32Snapshot;
PROCESSWALK myProcess32First;
PROCESSWALK myProcess32Next;

static BOOL WINAPI dummyprocessmodules (
  HANDLE hProcess,      // handle to the process
  HMODULE * lphModule,  // array to receive the module handles
  DWORD cb,             // size of the array
  LPDWORD lpcbNeeded    // receives the number of bytes returned
)
{
  lphModule[0] = (HMODULE) *lpcbNeeded;
  *lpcbNeeded = 1;
  return 1;
}

static DWORD WINAPI GetModuleFileNameEx95 (
  HANDLE hProcess,
  HMODULE hModule,
  LPTSTR lpstrFileName,
  DWORD n
)
{
  HANDLE h;
  DWORD pid = (DWORD) hModule;

  h = myCreateToolhelp32Snapshot (TH32CS_SNAPPROCESS, 0);
  if (!h)
    return 0;

  PROCESSENTRY32 proc;
  proc.dwSize = sizeof (proc);
  if (myProcess32First(h, &proc))
    do
      if (proc.th32ProcessID == pid)
	{
	  CloseHandle (h);
	  strcpy (lpstrFileName, proc.szExeFile);
	  return 1;
	}
    while (myProcess32Next (h, &proc));
  CloseHandle (h);
  return 0;
}

int
init_win ()
{
  OSVERSIONINFO os_version_info;

  memset (&os_version_info, 0, sizeof os_version_info);
  os_version_info.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
  GetVersionEx (&os_version_info);

  HMODULE h;
  if (os_version_info.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
      h = LoadLibrary ("psapi.dll");
      if (!h)
	return 0;
      myEnumProcessModules = (ENUMPROCESSMODULES) GetProcAddress (h, "EnumProcessModules");
      myGetModuleFileNameEx = (GETMODULEFILENAME) GetProcAddress (h, "GetModuleFileNameExA");
      if (!myEnumProcessModules || !myGetModuleFileNameEx)
	return 0;
      return 1;
    }

  h = GetModuleHandle("KERNEL32.DLL");
  myCreateToolhelp32Snapshot = (CREATESNAPSHOT)GetProcAddress (h, "CreateToolhelp32Snapshot");
  myProcess32First = (PROCESSWALK)GetProcAddress (h, "Process32First");
  myProcess32Next  = (PROCESSWALK)GetProcAddress (h, "Process32Next");
  if (!myCreateToolhelp32Snapshot || !myProcess32First || !myProcess32Next)
    return 0;

  myEnumProcessModules = dummyprocessmodules;
  myGetModuleFileNameEx = GetModuleFileNameEx95;
  return 1;
}

d103 1
a103 1
    sprintf (buf0, "tty%d", ntty);
d169 2
a233 2
  if (query == CW_GETPINFO_FULL && !init_win ())
    query = CW_GETPINFO;
d288 1
a288 6
	  if (p->version >= EXTERNAL_PINFO_VERSION_32_LP)
	    cygwin_conv_path (CCP_WIN_A_TO_POSIX | CCP_ABSOLUTE,
			      p->progname_long, pname, NT_MAX_PATH);
	  else
	    cygwin_conv_path (CCP_WIN_A_TO_POSIX | CCP_ABSOLUTE,
			      p->progname, pname, NT_MAX_PATH);
d303 1
a303 1
	  if (!myEnumProcessModules (h, hm, sizeof (hm), &n))
d351 9
a359 2
	  else if (!n || !myGetModuleFileNameEx (h, hm[0], pname, PATH_MAX))
	    strcpy (pname, "*** unknown ***");
@


1.30
log
@	* ps.cc (main): Don't overwrite process name, just attach <defunct>
	to it for zombie processes.
@
text
@d12 1
d23 1
a33 1
static const char version[] = "$Revision: 1.11 $";
d46 1
a46 1
  {"version", no_argument, NULL, 'v'},
d51 1
a51 1
static char opts[] = "aefhlp:su:vW";
d218 2
a219 1
Usage: %s [-aefls] [-u UID] [-p PID]\n\
d230 1
a230 1
 -v, --version   output version information and exit\n\
d232 3
a234 2
With no options, %s outputs the long format by default\n",
	   prog_name, prog_name);
d241 9
a249 18
  const char *v = strchr (version, ':');
  int len;
  if (!v)
    {
      v = "?";
      len = 1;
    }
  else
    {
      v += 2;
      len = strchr (v, ' ') - v;
    }
  printf ("\
%s (cygwin) %.*s\n\
Process Statistics\n\
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.\n\
Compiled on %s\n\
", prog_name, len, v, __DATE__);
d275 1
a275 7
  prog_name = strrchr (argv[0], '/');
  if (prog_name == NULL)
    prog_name = strrchr (argv[0], '\\');
  if (prog_name == NULL)
    prog_name = argv[0];
  else
    prog_name++;
d315 1
a315 1
      case 'v':
d325 2
a326 1
	usage (stderr, 1);
@


1.29
log
@* ps.cc (ttynam): Accommodate new console numbering.
(main): Ditto.
@
text
@d4 1
a4 1
   2008, 2009, 2010 Red Hat, Inc.
d400 2
a401 4
      char pname[NT_MAX_PATH];
      if (p->process_state & PID_EXITED || (p->exitcode & ~0xffff))
	strcpy (pname, "<defunct>");
      else if (p->ppid)
d414 2
@


1.28
log
@	* loadlib.h: New header implementing safe LoadLibrary calls.
	Include throughout files using LoadLibrary function.
	* cygcheck.cc (dump_sysinfo): Retrieve kernel32.dll handle via
	GetModuleHandle, rather than using LoadLibrary.
	* cygpath.cc (get_long_name): Ditto.
	(do_sysfolders): Append .dll suffix in LoadLibrary call.
	* ldh.cc (WinMain): Use LoadLibraryExW with DONT_RESOLVE_DLL_REFERENCES
	to avoid loading malicious library code.
	* locale.cc (print_locale_with_codeset): Change way to retrieve
	kernel32.dll path.
@
text
@d201 2
a202 1
  static char buf[5];
d204 6
a209 4
    return "   ?";
  if (ntty == TTY_CONSOLE)
    return " con";
  sprintf (buf, "%4d", ntty);
d267 1
a267 1
  const char *dtitle = "    PID TTY     STIME COMMAND\n";
d269 1
a269 1
  const char *ftitle = "     UID     PID    PPID TTY     STIME COMMAND\n";
d271 1
a271 1
  const char *ltitle = "      PID    PPID    PGID     WINPID  TTY  UID    STIME COMMAND\n";
@


1.27
log
@* ps.cc (main): Return 0 if pid found.
@
text
@d4 1
a4 1
   2008, 2009 Red Hat, Inc.
d26 1
@


1.26
log
@	* Makefile.in: Link ps.exe agains ntdll.dll.
	* ps.cc (main): Enable SE_DEBUG_NAME privilege if Windows processes
	have to be enumerated.  Workaround EnumProcessModules problem when
	running under WOW64 and use NtQueryInformationProcess to fetch
	process image name.
@
text
@d261 1
d303 1
d374 2
d506 1
a506 1
  return 0;
a507 1

@


1.25
log
@* cygcheck.cc (pathlike::check_existence): Remove class name from declaration.
(display_internet_error): Use proper format specifier for DWORD.
(environ): Remove unneeded declaration.
(main): Use brace around nested if to avoid an overly-helpful compiler warning.
* dump_setup.cc (parse_filename): Reorganize nested if to avoid an
overly-helpful compiler warning.
* path.cc (GUID_shortcut): Use braces around part of initializer which needs
them.
(conv_fstab_spaces): Parenthesize assignment in while loop to avoid a compiler
warning.
(struct opt): Make static.
* ps.cc (main): Reorganize nested if to avoid an overly-helpful compiler
warning.
* regtool.cc: Make some anonymous structs static to avoid a compiler warning.
* ssp.c (lookup_thread_id): Initialize *tix to zero to avoid potential
uninitialized use.
* strace.cc (add_child): Use proper format specifier for DWORD.
(remove_child): Ditto.
(proc_child): Ditto.
@
text
@d4 1
a4 1
   2008 Red Hat, Inc.
d13 1
d24 2
d254 2
d269 1
d345 20
d419 47
a465 1
	  if (!n || !myGetModuleFileNameEx (h, hm[0], pname, PATH_MAX))
@


1.24
log
@	* Makefile.in (cygcheck.exe): Link against ntdll.
	* bloda.cc: Use statically linked functions throughout.
	* cygpath.cc: Drop 9x considerations.
	* mkgroup.c: Revamp.  Redefine -l and -d options to take optional
	machine and domain parameters.  Redefine -c to work always, using
	token information.  Add -L, -D, -C to create unique groupnames in
	domain\group syntax.  Add -S option to define domain\group separator
	char.  Ignore -u and -s options.
	* mkpasswd.c: Revamp.  Redefine -l and -d options to take optional
	machine and domain parameters.  Redefine -c to work always, using
	token information.  Add -L, -D, -C to create unique usernames in
	domain\user syntax.  Add -S option to define domain\user separator
	char.  Ignore -g and -s options.  Prefer to take homedir from $HOME
	over $HOMEDRIVE/$HOMEPATH.
	* path.cc (oopts): Add "acl", "noacl", "posix=0" and "posix=1" options.
	(getmntent): Accomodate throughout.
	* ps.cc: Fix copyright dates.
	* utils.sgml: Fix text for mkgroup and mkpasswd.
@
text
@d347 9
a355 8
      if (!aflag)
	if (p->version >= EXTERNAL_PINFO_VERSION_32_BIT)
	  {
	    if (p->uid32 != (__uid32_t) uid)
	      continue;
	  }
	else if (p->uid != uid)
	  continue;
@


1.23
log
@	* cygpath.cc (do_sysfolders): Use cygwin_conv_path.
	(do_pathconv): Use cygwin_conv_path and cygwin_conv_path_list.
	* dumper.cc (main): Use cygwin_conv_path.  Allocate target path
	dynamically.
	* mkpasswd.c (current_user): Use cygwin_conv_path.
	(enum_users): Ditto.
	* ps.cc (NT_MAX_PATH): Define.
	(main): Use cygwin_conv_path.
	* regtool.cc (find_key): Ditto. Allocate target path dynamically.
	(cmd_save): Ditto.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
@


1.22
log
@	* ps.cc: Include limits.h.
	(main): Set file name buffer size to PATH_MAX.  Use progname or
	progname_long member of struct external_pinfo dependent of the value of
	the struct's version member.
@
text
@d23 4
d362 3
a364 1
      char pname[PATH_MAX];
d372 2
a373 1
	    cygwin_conv_to_posix_path (p->progname_long, pname);
d375 2
a376 1
	    cygwin_conv_to_posix_path (p->progname, pname);
@


1.21
log
@	* ps.cc (main): Set aflag if -p option is given.
@
text
@d18 1
d358 1
a358 1
      char pname[MAX_PATH];
d365 4
a368 1
	  cygwin_conv_to_posix_path (p->progname, pname);
d383 1
a383 1
	  if (!n || !myGetModuleFileNameEx (h, hm[0], pname, MAX_PATH))
@


1.20
log
@	* ps.cc (longopts): Add --process option.
	(opts): Add -p option.
	(usage): Mention -p/--process option.
	(main): Handle -p option.
	* utils.sgml: Describe -p/--process option.
@
text
@d289 1
@


1.19
log
@* ps.cc (main): Eliminate use of PID_ZOMBIE.
* strace.cc (main): Recognize new option for displaying hex value of strace
type.
(handle_output_debug_string): Prepend output with hex value of strace message
if -H is specified.
@
text
@d32 1
d40 1
a40 1
static char opts[] = "aefhlsu:vW";
d204 1
a204 1
Usage: %s [-aefls] [-u UID]\n\
d212 1
d249 1
a249 1
  int aflag, lflag, fflag, sflag, uid;
d261 1
d287 3
d337 3
@


1.18
log
@fix whitespace, update some copyrights
@
text
@d348 1
a348 1
      if (p->process_state & (PID_ZOMBIE | PID_EXITED))
@


1.17
log
@* cygcheck.cc (usage) Add description output.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d274 2
a275 2
        aflag = 1;
        break;
d277 2
a278 2
        fflag = 1;
        break;
d280 1
a280 1
        usage (stdout, 0);
d282 2
a283 2
        lflag = 1;
        break;
d288 14
a301 14
        uid = atoi (optarg);
        if (uid == 0)
          {
            struct passwd *pw;

            if ((pw = getpwnam (optarg)))
              uid = pw->pw_uid;
            else
              {
                fprintf (stderr, "%s: user %s unknown\n", prog_name, optarg);
                exit (1);
              }
          }
        break;
d303 3
a305 3
        print_version ();
        exit (0);
        break;
d312 1
a312 1
        usage (stderr, 1);
d332 1
a332 1
        if (p->version >= EXTERNAL_PINFO_VERSION_32_BIT)
d336 1
a336 1
          }
d341 1
a341 1
        status = 'S';
d343 1
a343 1
        status = 'I';
d345 1
a345 1
        status = 'O';
d349 1
a349 1
        strcpy (pname, "<defunct>");
d362 1
a362 1
	  			  FALSE, p->dwProcessId);
d380 2
a381 2
        {
          struct passwd *pw;
d383 6
a388 6
          if ((pw = getpwuid (p->version >= EXTERNAL_PINFO_VERSION_32_BIT ?
	                      p->uid32 : p->uid)))
            strcpy (uname, pw->pw_name);
          else
            sprintf (uname, "%u", (unsigned)
	             (p->version >= EXTERNAL_PINFO_VERSION_32_BIT ?
d390 1
a390 1
        }
d393 1
a393 1
        printf (dfmt, p->pid, ttynam (p->ctty), start_time (p), pname);
d395 2
a396 2
        printf (ffmt, uname, p->pid, p->ppid, ttynam (p->ctty), start_time (p),
	        pname);
d398 2
a399 2
        printf (lfmt, status, p->pid, p->ppid, p->pgid,
                p->dwProcessId, ttynam (p->ctty),
@


1.16
log
@Add final newlines to utils
@
text
@d204 2
@


1.15
log
@	* ps.cc (main): Use uid or uid32 member of struct external_pinfo
	dependent of the value of the struct's version member.
@
text
@d237 2
a238 1
Compiled on %s", prog_name, len, v, __DATE__);
@


1.14
log
@	* ps.cc (main): Change print format for uid to unsigned.  Use uid32
	member of struct external_pinfo instead of uid.
@
text
@d328 8
a335 2
      if (!aflag && p->uid32 != (__uid32_t) uid)
        continue;
d358 2
a359 1
	  HANDLE h = OpenProcess (PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, p->dwProcessId);
d380 2
a381 1
          if ((pw = getpwuid (p->uid32)))
d384 3
a386 1
            sprintf (uname, "%u", (unsigned) p->uid32);
d392 2
a393 1
        printf (ffmt, uname, p->pid, p->ppid, ttynam (p->ctty), start_time (p), pname);
d396 3
a398 1
                p->dwProcessId, ttynam (p->ctty), p->uid32, start_time (p), pname);
@


1.13
log
@	* ps.cc (usage): Fix typo.
@
text
@d251 1
a251 1
  const char *lfmt   = "%c %7d %7d %7d %10u %4s %4d %8s %s\n";
d328 1
a328 1
      if (!aflag && p->uid != uid)
d373 1
a373 1
          if ((pw = getpwuid (p->uid)))
d376 1
a376 1
            sprintf (uname, "%d", p->uid);
d385 1
a385 1
                p->dwProcessId, ttynam (p->ctty), p->uid, start_time (p), pname);
@


1.12
log
@* ps.cc (prog_name): New global variable.
(longopts): Ditto.
(opts): Ditto.
(usage): New function.
(print_version): New function.
(main): Accomodate longopts and new --help, --version options.
@
text
@d213 2
a214 1
With options, %s outputs the long format by default\n", prog_name, prog_name);
@


1.11
log
@* Makefile.in: Add define to CXXFLAGS.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Red Hat, Inc.
d22 19
d199 40
d257 9
a265 1
  while ((ch = getopt (argc, argv, "aelfsu:W")) != -1)
d275 2
d293 1
a293 1
                fprintf (stderr, "user %s unknown\n", optarg);
d298 4
d308 1
a308 8
        fprintf (stderr, "Usage %s [-aefl] [-u uid]\n", argv[0]);
        fprintf (stderr, "-f = show process uids, ppids\n");
        fprintf (stderr, "-l = show process uids, ppids, pgids, winpids\n");
        fprintf (stderr, "-u uid = list processes owned by uid\n");
        fprintf (stderr, "-a, -e = show processes of all users\n");
	fprintf (stderr, "-s = show process summary\n");
	fprintf (stderr, "-W = show windows as well as cygwin processes\n");
        exit (1);
@


1.10
log
@* passwd.cc (ttymnam): New function.
(main): Use ttynam() to report name of tty.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Cygnus Solutions.
@


1.9
log
@* ps.cc (main): Add some extra space to Windows pid output for Windows 95.
@
text
@d168 12
d187 1
a187 1
  const char *dfmt   = "%7d%4d%10s %s\n";
d189 3
a191 3
  const char *ffmt   = "%8.8s%8d%8d%4d%10s %s\n";
  const char *ltitle = "      PID    PPID    PGID     WINPID TTY  UID    STIME COMMAND\n";
  const char *lfmt   = "%c %7d %7d %7d %10u %3d %4d %8s %s\n";
d313 1
a313 1
        printf (dfmt, p->pid, p->ctty, start_time (p), pname);
d315 1
a315 1
        printf (ffmt, uname, p->pid, p->ppid, p->ctty, start_time (p), pname);
d318 1
a318 1
                p->dwProcessId, p->ctty, p->uid, start_time (p), pname);
@


1.8
log
@* ps.cc (main): Add some extra space to pid output for Windows 95.
@
text
@d178 2
a179 2
  const char *ltitle = "      PID    PPID    PGID   WINPID TTY  UID    STIME COMMAND\n";
  const char *lfmt   = "%c %7d %7d %7d %8u %3d %4d %8s %s\n";
@


1.7
log
@* ps.cc (main): Accomodate new PID_ constant.
@
text
@d174 6
a179 6
  const char *dtitle = "  PID TTY     STIME COMMAND\n";
  const char *dfmt   = "%5d%4d%10s %s\n";
  const char *ftitle = "     UID   PID  PPID TTY     STIME COMMAND\n";
  const char *ffmt   = "%8.8s%6d%6d%4d%10s %s\n";
  const char *ltitle = "    PID  PPID  PGID   WINPID TTY  UID    STIME COMMAND\n";
  const char *lfmt   = "%c %5d %5d %5d %8u %3d %4d %8s %s\n";
@


1.6
log
@* ps.cc (main): Change order of reporting slightly so that windows pids are
more obvious.
* strace.cc (add_child): Just add child's pid directly.
(remove_child): No need to close the child process pid since ContinueDebugEvent
does that automatically.
(proc_child): Ditto for child thread.
@
text
@a248 2
      if (p->process_state == PID_NOT_IN_USE)
        continue;
d260 1
a260 1
      if (p->process_state & PID_ZOMBIE)
@


1.5
log
@* ps.cc (main): Always print a cygwin process using cygwin paths.
@
text
@d178 2
a179 2
  const char *ltitle = "    PID  PPID  PGID   WINPID  UID TTY    STIME COMMAND\n";
  const char *lfmt   = "%c %5d %5d %5d %8u %4d %3d %8s %s\n";
d308 1
a308 1
              p->dwProcessId, p->uid, p->ctty, start_time (p), pname);
@


1.4
log
@* Makefile.in: Add dumper.exe target and associated mechanisms for building it.
* dumper.cc: New file.
* dumper.h: New file.
* module_info.cc: New file.
* parse_pe.cc: New file.
@
text
@d264 1
a264 1
      else if (query != CW_GETPINFO_FULL)
d273 1
a273 1
      else
@


1.3
log
@* kill.cc (main): Add '-f' option to force termination of a process.
(forcekill): New function.
* ps.cc (main): Add '-W' option to list Windows pids as well as Cygwin pids.
(dummyprocessmodules): New function.
(GetModuleFileNameEx95): New function.
(init_win): New function.
(to_time_t): New function.
@
text
@d264 1
a264 1
      else if (p->progname[0])
d267 1
@


1.2
log
@* Makefile.in: Eliminate WINSUP_DEPS.
* cygpath.cc: Reorganize includes to accomodate sys/cygwin.h changes.
* mkgroup.c: Ditto.
* mkpasswd.c: Ditto.
* mount.cc: Ditto.  Eliminate use of cygwin source specific includes.
* ps.cc: Ditto.
* cygwin.cc: Eliminate obsolete file.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998 Cygnus Solutions.
d19 108
d147 21
d172 2
a173 1
  int aflag, lflag, fflag, uid;
d182 1
a182 1
  aflag = lflag = fflag = 0;
d184 1
d186 1
a186 1
  while ((ch = getopt (argc, argv, "aelfu:")) != -1)
d199 3
d217 5
d228 2
d233 2
a234 2
  if (lflag)
    printf (ltitle);
d237 2
a238 2
  else
    printf (dtitle);
d242 3
d246 1
a246 2
       (p = (external_pinfo *) cygwin_internal (CW_GETPINFO,
						  pid | CW_NEXTPID));
d264 8
d273 15
a287 1
        cygwin_conv_to_posix_path (p->progname, pname);
d301 5
a305 1
      if (lflag)
a307 4
      else if (fflag)
        printf (ffmt, uname, p->pid, p->ppid, p->ctty, start_time (p), pname);
      else
        printf (dfmt, p->pid, p->ctty, start_time (p), pname);
@


1.1
log
@Initial revision
@
text
@d12 1
a18 2
#include "winsup.h"
#include "external.h"
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
