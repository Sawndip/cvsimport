head	1.7;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.7
	gdb_7_6-2013-04-26-release:1.7
	gdb_7_6-branch:1.7.0.6
	gdb_7_6-2013-03-12-branchpoint:1.7
	gdb_7_5_1-2012-11-29-release:1.7
	gdb_7_5-2012-08-17-release:1.7
	gdb_7_5-branch:1.7.0.4
	gdb_7_5-2012-07-18-branchpoint:1.7
	gdb_7_4_1-2012-04-26-release:1.7
	gdb_7_4-2012-01-24-release:1.7
	gdb_7_4-branch:1.7.0.2
	gdb_7_4-2011-12-13-branchpoint:1.7
	gdb_7_3_1-2011-09-04-release:1.6
	gdb_7_3-2011-07-26-release:1.6
	gdb_7_3-branch:1.6.0.36
	gdb_7_3-2011-04-01-branchpoint:1.6
	gdb_7_2-2010-09-02-release:1.6
	gdb_7_2-branch:1.6.0.34
	gdb_7_2-2010-07-07-branchpoint:1.6
	gdb_7_1-2010-03-18-release:1.6
	gdb_7_1-branch:1.6.0.32
	gdb_7_1-2010-02-18-branchpoint:1.6
	gdb_7_0_1-2009-12-22-release:1.6
	gdb_7_0-2009-10-06-release:1.6
	gdb_7_0-branch:1.6.0.30
	gdb_7_0-2009-09-16-branchpoint:1.6
	arc-sim-20090309:1.6
	msnyder-checkpoint-072509-branch:1.6.0.28
	msnyder-checkpoint-072509-branchpoint:1.6
	arc-insight_6_8-branch:1.6.0.26
	arc-insight_6_8-branchpoint:1.6
	insight_6_8-branch:1.6.0.24
	insight_6_8-branchpoint:1.6
	reverse-20081226-branch:1.6.0.22
	reverse-20081226-branchpoint:1.6
	multiprocess-20081120-branch:1.6.0.20
	multiprocess-20081120-branchpoint:1.6
	reverse-20080930-branch:1.6.0.18
	reverse-20080930-branchpoint:1.6
	reverse-20080717-branch:1.6.0.16
	reverse-20080717-branchpoint:1.6
	msnyder-reverse-20080609-branch:1.6.0.14
	msnyder-reverse-20080609-branchpoint:1.6
	drow-reverse-20070409-branch:1.6.0.12
	drow-reverse-20070409-branchpoint:1.6
	gdb_6_8-2008-03-27-release:1.6
	gdb_6_8-branch:1.6.0.10
	gdb_6_8-2008-02-26-branchpoint:1.6
	gdb_6_7_1-2007-10-29-release:1.6
	gdb_6_7-2007-10-10-release:1.6
	gdb_6_7-branch:1.6.0.8
	gdb_6_7-2007-09-07-branchpoint:1.6
	insight_6_6-20070208-release:1.6
	gdb_6_6-2006-12-18-release:1.6
	gdb_6_6-branch:1.6.0.6
	gdb_6_6-2006-11-15-branchpoint:1.6
	insight_6_5-20061003-release:1.6
	gdb-csl-symbian-6_4_50_20060226-12:1.4
	gdb-csl-sourcerygxx-3_4_4-25:1.4
	nickrob-async-20060828-mergepoint:1.6
	gdb-csl-symbian-6_4_50_20060226-11:1.4
	gdb-csl-sourcerygxx-4_1-17:1.4
	gdb-csl-20060226-branch-local-2:1.4
	gdb-csl-sourcerygxx-4_1-14:1.4
	gdb-csl-sourcerygxx-4_1-13:1.4
	gdb-csl-sourcerygxx-4_1-12:1.4
	gdb-csl-sourcerygxx-3_4_4-21:1.4
	gdb_6_5-20060621-release:1.6
	gdb-csl-sourcerygxx-4_1-9:1.4
	gdb-csl-sourcerygxx-4_1-8:1.4
	gdb-csl-sourcerygxx-4_1-7:1.4
	gdb-csl-arm-2006q1-6:1.4
	gdb-csl-sourcerygxx-4_1-6:1.4
	gdb-csl-symbian-6_4_50_20060226-10:1.4
	gdb-csl-symbian-6_4_50_20060226-9:1.4
	gdb-csl-symbian-6_4_50_20060226-8:1.4
	gdb-csl-coldfire-4_1-11:1.4
	gdb-csl-sourcerygxx-3_4_4-19:1.4
	gdb-csl-coldfire-4_1-10:1.4
	gdb_6_5-branch:1.6.0.4
	gdb_6_5-2006-05-14-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-5:1.4
	nickrob-async-20060513-branch:1.6.0.2
	nickrob-async-20060513-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-4:1.4
	msnyder-reverse-20060502-branch:1.5.0.4
	msnyder-reverse-20060502-branchpoint:1.5
	gdb-csl-morpho-4_1-4:1.4
	gdb-csl-sourcerygxx-3_4_4-17:1.4
	readline_5_1-import-branch:1.5.0.2
	readline_5_1-import-branchpoint:1.5
	readline-pre-51-import:1.5
	readline_5_1:1.1.1.5
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.4
	gdb-csl-symbian-20060226-branch:1.4.0.78
	gdb-csl-symbian-20060226-branchpoint:1.4
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.4
	msnyder-reverse-20060331-branch:1.4.0.76
	msnyder-reverse-20060331-branchpoint:1.4
	gdb-csl-available-20060303-branch:1.4.0.74
	gdb-csl-available-20060303-branchpoint:1.4
	gdb-csl-20060226-branch:1.4.0.72
	gdb-csl-20060226-branchpoint:1.4
	gdb_6_4-20051202-release:1.4
	msnyder-fork-checkpoint-branch:1.4.0.70
	msnyder-fork-checkpoint-branchpoint:1.4
	gdb-csl-gxxpro-6_3-branch:1.4.0.68
	gdb-csl-gxxpro-6_3-branchpoint:1.4
	gdb_6_4-branch:1.4.0.66
	gdb_6_4-2005-11-01-branchpoint:1.4
	gdb-csl-arm-20051020-branch:1.4.0.64
	gdb-csl-arm-20051020-branchpoint:1.4
	msnyder-tracepoint-checkpoint-branch:1.4.0.62
	msnyder-tracepoint-checkpoint-branchpoint:1.4
	gdb-csl-arm-20050325-2005-q1b:1.4
	gdb-csl-arm-20050325-2005-q1a:1.4
	csl-arm-20050325-branch:1.4.0.60
	csl-arm-20050325-branchpoint:1.4
	gdb_6_3-20041109-release:1.4
	gdb_6_3-branch:1.4.0.56
	gdb_6_3-20041019-branchpoint:1.4
	drow_intercu-merge-20040921:1.4
	drow_intercu-merge-20040915:1.4
	jimb-gdb_6_2-e500-branch:1.4.0.58
	jimb-gdb_6_2-e500-branchpoint:1.4
	gdb_6_2-20040730-release:1.4
	gdb_6_2-branch:1.4.0.54
	gdb_6_2-2004-07-10-gmt-branchpoint:1.4
	gdb_6_1_1-20040616-release:1.4
	gdb_6_1-2004-04-05-release:1.4
	drow_intercu-merge-20040402:1.4
	drow_intercu-merge-20040327:1.4
	ezannoni_pie-20040323-branch:1.4.0.52
	ezannoni_pie-20040323-branchpoint:1.4
	cagney_tramp-20040321-mergepoint:1.4
	cagney_tramp-20040309-branch:1.4.0.50
	cagney_tramp-20040309-branchpoint:1.4
	gdb_6_1-branch:1.4.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.4
	drow_intercu-20040221-branch:1.4.0.46
	drow_intercu-20040221-branchpoint:1.4
	cagney_bfdfile-20040213-branch:1.4.0.44
	cagney_bfdfile-20040213-branchpoint:1.4
	drow-cplus-merge-20040208:1.4
	carlton_dictionary-20040126-merge:1.4
	cagney_bigcore-20040122-branch:1.4.0.42
	cagney_bigcore-20040122-branchpoint:1.4
	drow-cplus-merge-20040113:1.4
	drow-cplus-merge-20031224:1.4
	drow-cplus-merge-20031220:1.4
	carlton_dictionary-20031215-merge:1.4
	drow-cplus-merge-20031214:1.4
	carlton-dictionary-20031111-merge:1.4
	gdb_6_0-2003-10-04-release:1.4
	kettenis_sparc-20030918-branch:1.4.0.40
	kettenis_sparc-20030918-branchpoint:1.4
	carlton_dictionary-20030917-merge:1.4
	ezannoni_pie-20030916-branchpoint:1.4
	ezannoni_pie-20030916-branch:1.4.0.38
	cagney_x86i386-20030821-branch:1.4.0.36
	cagney_x86i386-20030821-branchpoint:1.4
	carlton_dictionary-20030805-merge:1.4
	carlton_dictionary-20030627-merge:1.4
	gdb_6_0-branch:1.4.0.34
	gdb_6_0-2003-06-23-branchpoint:1.4
	jimb-ppc64-linux-20030613-branch:1.4.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.4
	cagney_convert-20030606-branch:1.4.0.30
	cagney_convert-20030606-branchpoint:1.4
	cagney_writestrings-20030508-branch:1.4.0.28
	cagney_writestrings-20030508-branchpoint:1.4
	jimb-ppc64-linux-20030528-branch:1.4.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.4
	carlton_dictionary-20030523-merge:1.4
	cagney_fileio-20030521-branch:1.4.0.24
	cagney_fileio-20030521-branchpoint:1.4
	kettenis_i386newframe-20030517-mergepoint:1.4
	jimb-ppc64-linux-20030509-branch:1.4.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.4
	kettenis_i386newframe-20030504-mergepoint:1.4
	carlton_dictionary-20030430-merge:1.4
	kettenis_i386newframe-20030419-branch:1.4.0.20
	kettenis_i386newframe-20030419-branchpoint:1.4
	carlton_dictionary-20030416-merge:1.4
	cagney_frameaddr-20030409-mergepoint:1.4
	kettenis_i386newframe-20030406-branch:1.4.0.18
	kettenis_i386newframe-20030406-branchpoint:1.4
	cagney_frameaddr-20030403-branchpoint:1.4
	cagney_frameaddr-20030403-branch:1.4.0.16
	cagney_framebase-20030330-mergepoint:1.4
	cagney_framebase-20030326-branch:1.4.0.14
	cagney_framebase-20030326-branchpoint:1.4
	cagney_lazyid-20030317-branch:1.4.0.12
	cagney_lazyid-20030317-branchpoint:1.4
	kettenis-i386newframe-20030316-mergepoint:1.4
	offbyone-20030313-branch:1.4.0.10
	offbyone-20030313-branchpoint:1.4
	kettenis-i386newframe-20030308-branch:1.4.0.8
	kettenis-i386newframe-20030308-branchpoint:1.4
	carlton_dictionary-20030305-merge:1.4
	cagney_offbyone-20030303-branch:1.4.0.6
	cagney_offbyone-20030303-branchpoint:1.4
	carlton_dictionary-20030207-merge:1.4
	interps-20030202-branch:1.4.0.4
	interps-20030202-branchpoint:1.4
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.3
	readline-pre-43-import:1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.24
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	carlton_dictionary-branch:1.3.0.22
	carlton_dictionary-20020920-branchpoint:1.3
	gdb_5_3-branch:1.3.0.20
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.3
	cagney_sysregs-20020825-branch:1.3.0.18
	cagney_sysregs-20020825-branchpoint:1.3
	readline_4_3-import-branch:1.3.0.16
	readline_4_3-import-branchpoint:1.3
	readline_4_3:1.1.1.4
	gdb_5_2_1-2002-07-23-release:1.3
	kseitz_interps-20020528-branch:1.3.0.14
	kseitz_interps-20020528-branchpoint:1.3
	cagney_regbuf-20020515-branch:1.3.0.12
	cagney_regbuf-20020515-branchpoint:1.3
	jimb-macro-020506-branch:1.3.0.10
	jimb-macro-020506-branchpoint:1.3
	gdb_5_2-2002-04-29-release:1.3
	gdb_5_2-branch:1.3.0.8
	gdb_5_2-2002-03-03-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	cygnus_cvs_20020108_pre:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.4
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.2
	gdb_5_1-2001-07-29-branchpoint:1.3
	insight-precleanup-2001-01-01:1.3
	readline_4_1:1.1.1.3
	readline_4_0:1.1.1.2
	FSF:1.1.1
	readline-pre-41-import:1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.7
date	2011.05.11.23.38.39;	author jkratoch;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.05.18.26.12;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.20.20.13.20;	author ezannoni;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2002.12.08.22.31.37;	author ezannoni;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.09.17.19.56;	author ezannoni;	state Exp;
branches
	1.3.16.1
	1.3.22.1
	1.3.24.1;
next	1.2;

1.2
date	2000.07.07.17.15.45;	author ezannoni;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.53;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.5.2.1
date	2006.04.24.22.00.25;	author drow;	state Exp;
branches;
next	;

1.3.16.1
date	2002.08.25.23.41.16;	author ezannoni;	state Exp;
branches;
next	;

1.3.22.1
date	2002.12.23.19.39.43;	author carlton;	state Exp;
branches;
next	;

1.3.24.1
date	2003.12.14.20.28.13;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.53;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.08.02.23.47.57;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.07.09.16.21.21;	author ezannoni;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.08.23.22.02.28;	author ezannoni;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.20.20.05.38;	author ezannoni;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Imported readline 6.2, and upstream patch 001.

[patch 0/3] readline-6.2 rebase
http://sourceware.org/ml/gdb-patches/2011-05/msg00003.html
[patch 1/3] readline-6.2: Merge of already posted patches
http://sourceware.org/ml/gdb-patches/2011-05/msg00004.html
	=
	[Bug-readline] [RFC/readline] bind.c, rl_function_dumper, Free allocated
	http://lists.gnu.org/archive/html/bug-readline/2011-03/msg00000.html
	[Bug-readline] [patch] Fix underquotation in readline/examples/rlfe/conf
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00001.html
	[Bug-readline] [patch] Makefile.in htm<->html
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00002.html
	Re: [Bug-readline] [patch] Makefile.in dependency: callback.o: xmalloc.h
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00004.html
	[Bug-readline] [patch] Remove . from the VPATH directive
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00005.html
	Eli Zaretskii's __MSDOS__ / __GO32__ / __MINGW32__ / __DJGPP__ stuff:
	http://sourceware.org/ml/gdb/2011-04/msg00002.html
	Jan Kratochvil's patch for FSF GDB tree local-specific changes:
	http://sourceware.org/ml/gdb/2011-04/msg00006.html
	Preservation of existing ChangeLog.gdb files, their updates.
[patch 2/3] readline-6.2: Workaround "ask" regression
http://sourceware.org/ml/gdb-patches/2011-05/msg00005.html
[patch 3/3] readline-6.2: Revert 5.x compat., apply 6.x compat.
http://sourceware.org/ml/gdb-patches/2011-05/msg00006.html
[patch 4/3] readline-6.2: Substitute inc-hist.texinfo
http://sourceware.org/ml/gdb-patches/2011-05/msg00010.html

readline/
	Workaround gdb.base/completion.exp regression on readline-6.2.
	* complete.c (get_y_or_n): Disable the return on RL_STATE_CALLBACK.

	Imported readline 6.2, and upstream patch 001.
	* configure: Regenerate.

readline/doc/
	* hsuser.texi (Using History Interactively): Disable !BashFeatures
	@@defcodeindex.  Make the `Programming with GNU History' reference
	external.
	* inc-hist.texinfo: Remove.

	Imported readline 6.2, and upstream patch 001.

readline/examples/
	Imported readline 6.2, and upstream patch 001.

readline/examples/rlfe/
	Imported readline 6.2, and upstream patch 001.

gdb/
	* config.in: Regenerate.
	* configure: Regenerate.
	* configure.ac <--with-system-readline> (for readline_echoing_p):
	Remove the test.
	* tui/tui-io.c (tui_old_readline_echoing_p): Rename to ...
	(tui_old_rl_echoing_p): ... here.
	(tui_setup_io): Rename extern declaration readline_echoing_p to
	_rl_echoing_p.  Adjust assignments for the both renames.

gdb/doc/
	* Makefile.in (GDB_DOC_SOURCE_INCLUDES): Rename inc-hist.texinfo to
	hsuser.texi.
	* gdb.texinfo <!SYSTEM_READLINE>: Rename inc-hist.texinfo inclusion and
	comment to hsuser.texi.  Change rluser.texi name in the comment.
@
text
@/* histexpand.c -- history expansion. */

/* Copyright (C) 1989-2010 Free Software Foundation, Inc.

   This file contains the GNU History Library (History), a set of
   routines for managing the text of previously typed lines.

   History is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   History is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with History.  If not, see <http://www.gnu.org/licenses/>.
*/

#define READLINE_LIBRARY

#if defined (HAVE_CONFIG_H)
#  include <config.h>
#endif

#include <stdio.h>

#if defined (HAVE_STDLIB_H)
#  include <stdlib.h>
#else
#  include "ansi_stdlib.h"
#endif /* HAVE_STDLIB_H */

#if defined (HAVE_UNISTD_H)
#  ifndef _MINIX
#    include <sys/types.h>
#  endif
#  include <unistd.h>
#endif

#include "rlmbutil.h"

#include "history.h"
#include "histlib.h"

#include "rlshell.h"
#include "xmalloc.h"

#define HISTORY_WORD_DELIMITERS		" \t\n;&()|<>"
#define HISTORY_QUOTE_CHARACTERS	"\"'`"

#define slashify_in_quotes "\\`\"$"

typedef int _hist_search_func_t PARAMS((const char *, int));

static char error_pointer;

static char *subst_lhs;
static char *subst_rhs;
static int subst_lhs_len;
static int subst_rhs_len;

static char *get_history_word_specifier PARAMS((char *, char *, int *));
static int history_tokenize_word PARAMS((const char *, int));
static char **history_tokenize_internal PARAMS((const char *, int, int *));
static char *history_substring PARAMS((const char *, int, int));
static void freewords PARAMS((char **, int));
static char *history_find_word PARAMS((char *, int));

static char *quote_breaks PARAMS((char *));

/* Variables exported by this file. */
/* The character that represents the start of a history expansion
   request.  This is usually `!'. */
char history_expansion_char = '!';

/* The character that invokes word substitution if found at the start of
   a line.  This is usually `^'. */
char history_subst_char = '^';

/* During tokenization, if this character is seen as the first character
   of a word, then it, and all subsequent characters upto a newline are
   ignored.  For a Bourne shell, this should be '#'.  Bash special cases
   the interactive comment character to not be a comment delimiter. */
char history_comment_char = '\0';

/* The list of characters which inhibit the expansion of text if found
   immediately following history_expansion_char. */
char *history_no_expand_chars = " \t\n\r=";

/* If set to a non-zero value, single quotes inhibit history expansion.
   The default is 0. */
int history_quotes_inhibit_expansion = 0;

/* Used to split words by history_tokenize_internal. */
char *history_word_delimiters = HISTORY_WORD_DELIMITERS;

/* If set, this points to a function that is called to verify that a
   particular history expansion should be performed. */
rl_linebuf_func_t *history_inhibit_expansion_function;

/* **************************************************************** */
/*								    */
/*			History Expansion			    */
/*								    */
/* **************************************************************** */

/* Hairy history expansion on text, not tokens.  This is of general
   use, and thus belongs in this library. */

/* The last string searched for by a !?string? search. */
static char *search_string;

/* The last string matched by a !?string? search. */
static char *search_match;

/* Return the event specified at TEXT + OFFSET modifying OFFSET to
   point to after the event specifier.  Just a pointer to the history
   line is returned; NULL is returned in the event of a bad specifier.
   You pass STRING with *INDEX equal to the history_expansion_char that
   begins this specification.
   DELIMITING_QUOTE is a character that is allowed to end the string
   specification for what to search for in addition to the normal
   characters `:', ` ', `\t', `\n', and sometimes `?'.
   So you might call this function like:
   line = get_history_event ("!echo:p", &index, 0);  */
char *
get_history_event (string, caller_index, delimiting_quote)
     const char *string;
     int *caller_index;
     int delimiting_quote;
{
  register int i;
  register char c;
  HIST_ENTRY *entry;
  int which, sign, local_index, substring_okay;
  _hist_search_func_t *search_func;
  char *temp;

  /* The event can be specified in a number of ways.

     !!   the previous command
     !n   command line N
     !-n  current command-line minus N
     !str the most recent command starting with STR
     !?str[?]
	  the most recent command containing STR

     All values N are determined via HISTORY_BASE. */

  i = *caller_index;

  if (string[i] != history_expansion_char)
    return ((char *)NULL);

  /* Move on to the specification. */
  i++;

  sign = 1;
  substring_okay = 0;

#define RETURN_ENTRY(e, w) \
	return ((e = history_get (w)) ? e->line : (char *)NULL)

  /* Handle !! case. */
  if (string[i] == history_expansion_char)
    {
      i++;
      which = history_base + (history_length - 1);
      *caller_index = i;
      RETURN_ENTRY (entry, which);
    }

  /* Hack case of numeric line specification. */
  if (string[i] == '-')
    {
      sign = -1;
      i++;
    }

  if (_rl_digit_p (string[i]))
    {
      /* Get the extent of the digits and compute the value. */
      for (which = 0; _rl_digit_p (string[i]); i++)
	which = (which * 10) + _rl_digit_value (string[i]);

      *caller_index = i;

      if (sign < 0)
	which = (history_length + history_base) - which;

      RETURN_ENTRY (entry, which);
    }

  /* This must be something to search for.  If the spec begins with
     a '?', then the string may be anywhere on the line.  Otherwise,
     the string must be found at the start of a line. */
  if (string[i] == '?')
    {
      substring_okay++;
      i++;
    }

  /* Only a closing `?' or a newline delimit a substring search string. */
  for (local_index = i; c = string[i]; i++)
    {
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  int v;
	  mbstate_t ps;

	  memset (&ps, 0, sizeof (mbstate_t));
	  /* These produce warnings because we're passing a const string to a
	     function that takes a non-const string. */
	  _rl_adjust_point ((char *)string, i, &ps);
	  if ((v = _rl_get_char_len ((char *)string + i, &ps)) > 1)
	    {
	      i += v - 1;
	      continue;
	    }
        }

#endif /* HANDLE_MULTIBYTE */
      if ((!substring_okay && (whitespace (c) || c == ':' ||
	  (history_search_delimiter_chars && member (c, history_search_delimiter_chars)) ||
	  string[i] == delimiting_quote)) ||
	  string[i] == '\n' ||
	  (substring_okay && string[i] == '?'))
	break;
    }

  which = i - local_index;
  temp = (char *)xmalloc (1 + which);
  if (which)
    strncpy (temp, string + local_index, which);
  temp[which] = '\0';

  if (substring_okay && string[i] == '?')
    i++;

  *caller_index = i;

#define FAIL_SEARCH() \
  do { \
    history_offset = history_length; xfree (temp) ; return (char *)NULL; \
  } while (0)

  /* If there is no search string, try to use the previous search string,
     if one exists.  If not, fail immediately. */
  if (*temp == '\0' && substring_okay)
    {
      if (search_string)
        {
          xfree (temp);
          temp = savestring (search_string);
        }
      else
        FAIL_SEARCH ();
    }

  search_func = substring_okay ? history_search : history_search_prefix;
  while (1)
    {
      local_index = (*search_func) (temp, -1);

      if (local_index < 0)
	FAIL_SEARCH ();

      if (local_index == 0 || substring_okay)
	{
	  entry = current_history ();
	  history_offset = history_length;
	
	  /* If this was a substring search, then remember the
	     string that we matched for word substitution. */
	  if (substring_okay)
	    {
	      FREE (search_string);
	      search_string = temp;

	      FREE (search_match);
	      search_match = history_find_word (entry->line, local_index);
	    }
	  else
	    xfree (temp);

	  return (entry->line);
	}

      if (history_offset)
	history_offset--;
      else
	FAIL_SEARCH ();
    }
#undef FAIL_SEARCH
#undef RETURN_ENTRY
}

/* Function for extracting single-quoted strings.  Used for inhibiting
   history expansion within single quotes. */

/* Extract the contents of STRING as if it is enclosed in single quotes.
   SINDEX, when passed in, is the offset of the character immediately
   following the opening single quote; on exit, SINDEX is left pointing
   to the closing single quote.  FLAGS currently used to allow backslash
   to escape a single quote (e.g., for bash $'...'). */
static void
hist_string_extract_single_quoted (string, sindex, flags)
     char *string;
     int *sindex, flags;
{
  register int i;

  for (i = *sindex; string[i] && string[i] != '\''; i++)
    {
      if ((flags & 1) && string[i] == '\\' && string[i+1])
        i++;
    }

  *sindex = i;
}

static char *
quote_breaks (s)
     char *s;
{
  register char *p, *r;
  char *ret;
  int len = 3;

  for (p = s; p && *p; p++, len++)
    {
      if (*p == '\'')
	len += 3;
      else if (whitespace (*p) || *p == '\n')
	len += 2;
    }

  r = ret = (char *)xmalloc (len);
  *r++ = '\'';
  for (p = s; p && *p; )
    {
      if (*p == '\'')
	{
	  *r++ = '\'';
	  *r++ = '\\';
	  *r++ = '\'';
	  *r++ = '\'';
	  p++;
	}
      else if (whitespace (*p) || *p == '\n')
	{
	  *r++ = '\'';
	  *r++ = *p++;
	  *r++ = '\'';
	}
      else
	*r++ = *p++;
    }
  *r++ = '\'';
  *r = '\0';
  return ret;
}

static char *
hist_error(s, start, current, errtype)
      char *s;
      int start, current, errtype;
{
  char *temp;
  const char *emsg;
  int ll, elen;

  ll = current - start;

  switch (errtype)
    {
    case EVENT_NOT_FOUND:
      emsg = "event not found";
      elen = 15;
      break;
    case BAD_WORD_SPEC:
      emsg = "bad word specifier";
      elen = 18;
      break;
    case SUBST_FAILED:
      emsg = "substitution failed";
      elen = 19;
      break;
    case BAD_MODIFIER:
      emsg = "unrecognized history modifier";
      elen = 29;
      break;
    case NO_PREV_SUBST:
      emsg = "no previous substitution";
      elen = 24;
      break;
    default:
      emsg = "unknown expansion error";
      elen = 23;
      break;
    }

  temp = (char *)xmalloc (ll + elen + 3);
  strncpy (temp, s + start, ll);
  temp[ll] = ':';
  temp[ll + 1] = ' ';
  strcpy (temp + ll + 2, emsg);
  return (temp);
}

/* Get a history substitution string from STR starting at *IPTR
   and return it.  The length is returned in LENPTR.

   A backslash can quote the delimiter.  If the string is the
   empty string, the previous pattern is used.  If there is
   no previous pattern for the lhs, the last history search
   string is used.

   If IS_RHS is 1, we ignore empty strings and set the pattern
   to "" anyway.  subst_lhs is not changed if the lhs is empty;
   subst_rhs is allowed to be set to the empty string. */

static char *
get_subst_pattern (str, iptr, delimiter, is_rhs, lenptr)
     char *str;
     int *iptr, delimiter, is_rhs, *lenptr;
{
  register int si, i, j, k;
  char *s;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
#endif

  s = (char *)NULL;
  i = *iptr;

#if defined (HANDLE_MULTIBYTE)
  memset (&ps, 0, sizeof (mbstate_t));
  _rl_adjust_point (str, i, &ps);
#endif

  for (si = i; str[si] && str[si] != delimiter; si++)
#if defined (HANDLE_MULTIBYTE)
    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
      {
	int v;
	if ((v = _rl_get_char_len (str + si, &ps)) > 1)
	  si += v - 1;
	else if (str[si] == '\\' && str[si + 1] == delimiter)
	  si++;
      }
    else
#endif /* HANDLE_MULTIBYTE */
      if (str[si] == '\\' && str[si + 1] == delimiter)
	si++;

  if (si > i || is_rhs)
    {
      s = (char *)xmalloc (si - i + 1);
      for (j = 0, k = i; k < si; j++, k++)
	{
	  /* Remove a backslash quoting the search string delimiter. */
	  if (str[k] == '\\' && str[k + 1] == delimiter)
	    k++;
	  s[j] = str[k];
	}
      s[j] = '\0';
      if (lenptr)
	*lenptr = j;
    }

  i = si;
  if (str[i])
    i++;
  *iptr = i;

  return s;
}

static void
postproc_subst_rhs ()
{
  char *new;
  int i, j, new_size;

  new = (char *)xmalloc (new_size = subst_rhs_len + subst_lhs_len);
  for (i = j = 0; i < subst_rhs_len; i++)
    {
      if (subst_rhs[i] == '&')
	{
	  if (j + subst_lhs_len >= new_size)
	    new = (char *)xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));
	  strcpy (new + j, subst_lhs);
	  j += subst_lhs_len;
	}
      else
	{
	  /* a single backslash protects the `&' from lhs interpolation */
	  if (subst_rhs[i] == '\\' && subst_rhs[i + 1] == '&')
	    i++;
	  if (j >= new_size)
	    new = (char *)xrealloc (new, new_size *= 2);
	  new[j++] = subst_rhs[i];
	}
    }
  new[j] = '\0';
  xfree (subst_rhs);
  subst_rhs = new;
  subst_rhs_len = j;
}

/* Expand the bulk of a history specifier starting at STRING[START].
   Returns 0 if everything is OK, -1 if an error occurred, and 1
   if the `p' modifier was supplied and the caller should just print
   the returned string.  Returns the new index into string in
   *END_INDEX_PTR, and the expanded specifier in *RET_STRING. */
static int
history_expand_internal (string, start, end_index_ptr, ret_string, current_line)
     char *string;
     int start, *end_index_ptr;
     char **ret_string;
     char *current_line;	/* for !# */
{
  int i, n, starting_index;
  int substitute_globally, subst_bywords, want_quotes, print_only;
  char *event, *temp, *result, *tstr, *t, c, *word_spec;
  int result_len;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;

  memset (&ps, 0, sizeof (mbstate_t));
#endif

  result = (char *)xmalloc (result_len = 128);

  i = start;

  /* If it is followed by something that starts a word specifier,
     then !! is implied as the event specifier. */

  if (member (string[i + 1], ":$*%^"))
    {
      char fake_s[3];
      int fake_i = 0;
      i++;
      fake_s[0] = fake_s[1] = history_expansion_char;
      fake_s[2] = '\0';
      event = get_history_event (fake_s, &fake_i, 0);
    }
  else if (string[i + 1] == '#')
    {
      i += 2;
      event = current_line;
    }
  else
    {
      int quoted_search_delimiter = 0;

      /* If the character before this `!' is a double or single
	 quote, then this expansion takes place inside of the
	 quoted string.  If we have to search for some text ("!foo"),
	 allow the delimiter to end the search string. */
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  int ch, l;
	  l = _rl_find_prev_mbchar (string, i, MB_FIND_ANY);
	  ch = string[l];
	  /* XXX - original patch had i - 1 ???  If i == 0 it would fail. */
	  if (i && (ch == '\'' || ch == '"'))
	    quoted_search_delimiter = ch;
	}
      else
#endif /* HANDLE_MULTIBYTE */	  
	if (i && (string[i - 1] == '\'' || string[i - 1] == '"'))
	  quoted_search_delimiter = string[i - 1];

      event = get_history_event (string, &i, quoted_search_delimiter);
    }
	  
  if (event == 0)
    {
      *ret_string = hist_error (string, start, i, EVENT_NOT_FOUND);
      xfree (result);
      return (-1);
    }

  /* If a word specifier is found, then do what that requires. */
  starting_index = i;
  word_spec = get_history_word_specifier (string, event, &i);

  /* There is no such thing as a `malformed word specifier'.  However,
     it is possible for a specifier that has no match.  In that case,
     we complain. */
  if (word_spec == (char *)&error_pointer)
    {
      *ret_string = hist_error (string, starting_index, i, BAD_WORD_SPEC);
      xfree (result);
      return (-1);
    }

  /* If no word specifier, than the thing of interest was the event. */
  temp = word_spec ? savestring (word_spec) : savestring (event);
  FREE (word_spec);

  /* Perhaps there are other modifiers involved.  Do what they say. */
  want_quotes = substitute_globally = subst_bywords = print_only = 0;
  starting_index = i;

  while (string[i] == ':')
    {
      c = string[i + 1];

      if (c == 'g' || c == 'a')
	{
	  substitute_globally = 1;
	  i++;
	  c = string[i + 1];
	}
      else if (c == 'G')
	{
	  subst_bywords = 1;
	  i++;
	  c = string[i + 1];
	}

      switch (c)
	{
	default:
	  *ret_string = hist_error (string, i+1, i+2, BAD_MODIFIER);
	  xfree (result);
	  xfree (temp);
	  return -1;

	case 'q':
	  want_quotes = 'q';
	  break;

	case 'x':
	  want_quotes = 'x';
	  break;

	  /* :p means make this the last executed line.  So we
	     return an error state after adding this line to the
	     history. */
	case 'p':
	  print_only++;
	  break;

	  /* :t discards all but the last part of the pathname. */
	case 't':
	  tstr = strrchr (temp, '/');
	  if (tstr)
	    {
	      tstr++;
	      t = savestring (tstr);
	      xfree (temp);
	      temp = t;
	    }
	  break;

	  /* :h discards the last part of a pathname. */
	case 'h':
	  tstr = strrchr (temp, '/');
	  if (tstr)
	    *tstr = '\0';
	  break;

	  /* :r discards the suffix. */
	case 'r':
	  tstr = strrchr (temp, '.');
	  if (tstr)
	    *tstr = '\0';
	  break;

	  /* :e discards everything but the suffix. */
	case 'e':
	  tstr = strrchr (temp, '.');
	  if (tstr)
	    {
	      t = savestring (tstr);
	      xfree (temp);
	      temp = t;
	    }
	  break;

	/* :s/this/that substitutes `that' for the first
	   occurrence of `this'.  :gs/this/that substitutes `that'
	   for each occurrence of `this'.  :& repeats the last
	   substitution.  :g& repeats the last substitution
	   globally. */

	case '&':
	case 's':
	  {
	    char *new_event;
	    int delimiter, failed, si, l_temp, ws, we;

	    if (c == 's')
	      {
		if (i + 2 < (int)strlen (string))
		  {
#if defined (HANDLE_MULTIBYTE)
		    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		      {
			_rl_adjust_point (string, i + 2, &ps);
			if (_rl_get_char_len (string + i + 2, &ps) > 1)
			  delimiter = 0;
			else
			  delimiter = string[i + 2];
		      }
		    else
#endif /* HANDLE_MULTIBYTE */
		      delimiter = string[i + 2];
		  }
		else
		  break;	/* no search delimiter */

		i += 3;

		t = get_subst_pattern (string, &i, delimiter, 0, &subst_lhs_len);
		/* An empty substitution lhs with no previous substitution
		   uses the last search string as the lhs. */
		if (t)
		  {
		    FREE (subst_lhs);
		    subst_lhs = t;
		  }
		else if (!subst_lhs)
		  {
		    if (search_string && *search_string)
		      {
			subst_lhs = savestring (search_string);
			subst_lhs_len = strlen (subst_lhs);
		      }
		    else
		      {
			subst_lhs = (char *) NULL;
			subst_lhs_len = 0;
		      }
		  }

		FREE (subst_rhs);
		subst_rhs = get_subst_pattern (string, &i, delimiter, 1, &subst_rhs_len);

		/* If `&' appears in the rhs, it's supposed to be replaced
		   with the lhs. */
		if (member ('&', subst_rhs))
		  postproc_subst_rhs ();
	      }
	    else
	      i += 2;

	    /* If there is no lhs, the substitution can't succeed. */
	    if (subst_lhs_len == 0)
	      {
		*ret_string = hist_error (string, starting_index, i, NO_PREV_SUBST);
		xfree (result);
		xfree (temp);
		return -1;
	      }

	    l_temp = strlen (temp);
	    /* Ignore impossible cases. */
	    if (subst_lhs_len > l_temp)
	      {
		*ret_string = hist_error (string, starting_index, i, SUBST_FAILED);
		xfree (result);
		xfree (temp);
		return (-1);
	      }

	    /* Find the first occurrence of THIS in TEMP. */
	    /* Substitute SUBST_RHS for SUBST_LHS in TEMP.  There are three
	       cases to consider:

		 1.  substitute_globally == subst_bywords == 0
		 2.  substitute_globally == 1 && subst_bywords == 0
		 3.  substitute_globally == 0 && subst_bywords == 1

	       In the first case, we substitute for the first occurrence only.
	       In the second case, we substitute for every occurrence.
	       In the third case, we tokenize into words and substitute the
	       first occurrence of each word. */

	    si = we = 0;
	    for (failed = 1; (si + subst_lhs_len) <= l_temp; si++)
	      {
		/* First skip whitespace and find word boundaries if
		   we're past the end of the word boundary we found
		   the last time. */
		if (subst_bywords && si > we)
		  {
		    for (; temp[si] && whitespace (temp[si]); si++)
		      ;
		    ws = si;
		    we = history_tokenize_word (temp, si);
		  }

		if (STREQN (temp+si, subst_lhs, subst_lhs_len))
		  {
		    int len = subst_rhs_len - subst_lhs_len + l_temp;
		    new_event = (char *)xmalloc (1 + len);
		    strncpy (new_event, temp, si);
		    strncpy (new_event + si, subst_rhs, subst_rhs_len);
		    strncpy (new_event + si + subst_rhs_len,
			     temp + si + subst_lhs_len,
			     l_temp - (si + subst_lhs_len));
		    new_event[len] = '\0';
		    xfree (temp);
		    temp = new_event;

		    failed = 0;

		    if (substitute_globally)
		      {
			/* Reported to fix a bug that causes it to skip every
			   other match when matching a single character.  Was
			   si += subst_rhs_len previously. */
			si += subst_rhs_len - 1;
			l_temp = strlen (temp);
			substitute_globally++;
			continue;
		      }
		    else if (subst_bywords)
		      {
			si = we;
			l_temp = strlen (temp);
			continue;
		      }
		    else
		      break;
		  }
	      }

	    if (substitute_globally > 1)
	      {
		substitute_globally = 0;
		continue;	/* don't want to increment i */
	      }

	    if (failed == 0)
	      continue;		/* don't want to increment i */

	    *ret_string = hist_error (string, starting_index, i, SUBST_FAILED);
	    xfree (result);
	    xfree (temp);
	    return (-1);
	  }
	}
      i += 2;
    }
  /* Done with modfiers. */
  /* Believe it or not, we have to back the pointer up by one. */
  --i;

  if (want_quotes)
    {
      char *x;

      if (want_quotes == 'q')
	x = sh_single_quote (temp);
      else if (want_quotes == 'x')
	x = quote_breaks (temp);
      else
	x = savestring (temp);

      xfree (temp);
      temp = x;
    }

  n = strlen (temp);
  if (n >= result_len)
    result = (char *)xrealloc (result, n + 2);
  strcpy (result, temp);
  xfree (temp);

  *end_index_ptr = i;
  *ret_string = result;
  return (print_only);
}

/* Expand the string STRING, placing the result into OUTPUT, a pointer
   to a string.  Returns:

  -1) If there was an error in expansion.
   0) If no expansions took place (or, if the only change in
      the text was the de-slashifying of the history expansion
      character)
   1) If expansions did take place
   2) If the `p' modifier was given and the caller should print the result

  If an error ocurred in expansion, then OUTPUT contains a descriptive
  error message. */

#define ADD_STRING(s) \
	do \
	  { \
	    int sl = strlen (s); \
	    j += sl; \
	    if (j >= result_len) \
	      { \
		while (j >= result_len) \
		  result_len += 128; \
		result = (char *)xrealloc (result, result_len); \
	      } \
	    strcpy (result + j - sl, s); \
	  } \
	while (0)

#define ADD_CHAR(c) \
	do \
	  { \
	    if (j >= result_len - 1) \
	      result = (char *)xrealloc (result, result_len += 64); \
	    result[j++] = c; \
	    result[j] = '\0'; \
	  } \
	while (0)

int
history_expand (hstring, output)
     char *hstring;
     char **output;
{
  register int j;
  int i, r, l, passc, cc, modified, eindex, only_printing, dquote, flag;
  char *string;

  /* The output string, and its length. */
  int result_len;
  char *result;

#if defined (HANDLE_MULTIBYTE)
  char mb[MB_LEN_MAX];
  mbstate_t ps;
#endif

  /* Used when adding the string. */
  char *temp;

  if (output == 0)
    return 0;

  /* Setting the history expansion character to 0 inhibits all
     history expansion. */
  if (history_expansion_char == 0)
    {
      *output = savestring (hstring);
      return (0);
    }
    
  /* Prepare the buffer for printing error messages. */
  result = (char *)xmalloc (result_len = 256);
  result[0] = '\0';

  only_printing = modified = 0;
  l = strlen (hstring);

  /* Grovel the string.  Only backslash and single quotes can quote the
     history escape character.  We also handle arg specifiers. */

  /* Before we grovel forever, see if the history_expansion_char appears
     anywhere within the text. */

  /* The quick substitution character is a history expansion all right.  That
     is to say, "^this^that^" is equivalent to "!!:s^this^that^", and in fact,
     that is the substitution that we do. */
  if (hstring[0] == history_subst_char)
    {
      string = (char *)xmalloc (l + 5);

      string[0] = string[1] = history_expansion_char;
      string[2] = ':';
      string[3] = 's';
      strcpy (string + 4, hstring);
      l += 4;
    }
  else
    {
#if defined (HANDLE_MULTIBYTE)
      memset (&ps, 0, sizeof (mbstate_t));
#endif

      string = hstring;
      /* If not quick substitution, still maybe have to do expansion. */

      /* `!' followed by one of the characters in history_no_expand_chars
	 is NOT an expansion. */
      for (i = dquote = 0; string[i]; i++)
	{
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      int v;
	      v = _rl_get_char_len (string + i, &ps);
	      if (v > 1)
		{
		  i += v - 1;
		  continue;
		}
	    }
#endif /* HANDLE_MULTIBYTE */

	  cc = string[i + 1];
	  /* The history_comment_char, if set, appearing at the beginning
	     of a word signifies that the rest of the line should not have
	     history expansion performed on it.
	     Skip the rest of the line and break out of the loop. */
	  if (history_comment_char && string[i] == history_comment_char &&
	      (i == 0 || member (string[i - 1], history_word_delimiters)))
	    {
	      while (string[i])
		i++;
	      break;
	    }
	  else if (string[i] == history_expansion_char)
	    {
	      if (cc == 0 || member (cc, history_no_expand_chars))
		continue;
	      /* If the calling application has set
		 history_inhibit_expansion_function to a function that checks
		 for special cases that should not be history expanded,
		 call the function and skip the expansion if it returns a
		 non-zero value. */
	      else if (history_inhibit_expansion_function &&
			(*history_inhibit_expansion_function) (string, i))
		continue;
	      else
		break;
	    }
	  /* Shell-like quoting: allow backslashes to quote double quotes
	     inside a double-quoted string. */
	  else if (dquote && string[i] == '\\' && cc == '"')
	    i++;
	  /* More shell-like quoting:  if we're paying attention to single
	     quotes and letting them quote the history expansion character,
	     then we need to pay attention to double quotes, because single
	     quotes are not special inside double-quoted strings. */
	  else if (history_quotes_inhibit_expansion && string[i] == '"')
	    {
	      dquote = 1 - dquote;
	    }
	  else if (dquote == 0 && history_quotes_inhibit_expansion && string[i] == '\'')
	    {
	      /* If this is bash, single quotes inhibit history expansion. */
	      flag = (i > 0 && string[i - 1] == '$');
	      i++;
	      hist_string_extract_single_quoted (string, &i, flag);
	    }
	  else if (history_quotes_inhibit_expansion && string[i] == '\\')
	    {
	      /* If this is bash, allow backslashes to quote single
		 quotes and the history expansion character. */
	      if (cc == '\'' || cc == history_expansion_char)
		i++;
	    }
	  
	}
	  
      if (string[i] != history_expansion_char)
	{
	  xfree (result);
	  *output = savestring (string);
	  return (0);
	}
    }

  /* Extract and perform the substitution. */
  for (passc = dquote = i = j = 0; i < l; i++)
    {
      int tchar = string[i];

      if (passc)
	{
	  passc = 0;
	  ADD_CHAR (tchar);
	  continue;
	}

#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  int k, c;

	  c = tchar;
	  memset (mb, 0, sizeof (mb));
	  for (k = 0; k < MB_LEN_MAX; k++)
	    {
	      mb[k] = (char)c;
	      memset (&ps, 0, sizeof (mbstate_t));
	      if (_rl_get_char_len (mb, &ps) == -2)
		c = string[++i];
	      else
		break;
	    }
	  if (strlen (mb) > 1)
	    {
	      ADD_STRING (mb);
	      continue;
	    }
	}
#endif /* HANDLE_MULTIBYTE */

      if (tchar == history_expansion_char)
	tchar = -3;
      else if (tchar == history_comment_char)
	tchar = -2;

      switch (tchar)
	{
	default:
	  ADD_CHAR (string[i]);
	  break;

	case '\\':
	  passc++;
	  ADD_CHAR (tchar);
	  break;

	case '"':
	  dquote = 1 - dquote;
	  ADD_CHAR (tchar);
	  break;
	  
	case '\'':
	  {
	    /* If history_quotes_inhibit_expansion is set, single quotes
	       inhibit history expansion. */
	    if (dquote == 0 && history_quotes_inhibit_expansion)
	      {
		int quote, slen;

		flag = (i > 0 && string[i - 1] == '$');
		quote = i++;
		hist_string_extract_single_quoted (string, &i, flag);

		slen = i - quote + 2;
		temp = (char *)xmalloc (slen);
		strncpy (temp, string + quote, slen);
		temp[slen - 1] = '\0';
		ADD_STRING (temp);
		xfree (temp);
	      }
	    else
	      ADD_CHAR (string[i]);
	    break;
	  }

	case -2:		/* history_comment_char */
	  if (i == 0 || member (string[i - 1], history_word_delimiters))
	    {
	      temp = (char *)xmalloc (l - i + 1);
	      strcpy (temp, string + i);
	      ADD_STRING (temp);
	      xfree (temp);
	      i = l;
	    }
	  else
	    ADD_CHAR (string[i]);
	  break;

	case -3:		/* history_expansion_char */
	  cc = string[i + 1];

	  /* If the history_expansion_char is followed by one of the
	     characters in history_no_expand_chars, then it is not a
	     candidate for expansion of any kind. */
	  if (cc == 0 || member (cc, history_no_expand_chars) ||
	  		 (history_inhibit_expansion_function && (*history_inhibit_expansion_function) (string, i)))
	    {
	      ADD_CHAR (string[i]);
	      break;
	    }

#if defined (NO_BANG_HASH_MODIFIERS)
	  /* There is something that is listed as a `word specifier' in csh
	     documentation which means `the expanded text to this point'.
	     That is not a word specifier, it is an event specifier.  If we
	     don't want to allow modifiers with `!#', just stick the current
	     output line in again. */
	  if (cc == '#')
	    {
	      if (result)
		{
		  temp = (char *)xmalloc (1 + strlen (result));
		  strcpy (temp, result);
		  ADD_STRING (temp);
		  xfree (temp);
		}
	      i++;
	      break;
	    }
#endif

	  r = history_expand_internal (string, i, &eindex, &temp, result);
	  if (r < 0)
	    {
	      *output = temp;
	      xfree (result);
	      if (string != hstring)
		xfree (string);
	      return -1;
	    }
	  else
	    {
	      if (temp)
		{
		  modified++;
		  if (*temp)
		    ADD_STRING (temp);
		  xfree (temp);
		}
	      only_printing = r == 1;
	      i = eindex;
	    }
	  break;
	}
    }

  *output = result;
  if (string != hstring)
    xfree (string);

  if (only_printing)
    {
#if 0
      add_history (result);
#endif
      return (2);
    }

  return (modified != 0);
}

/* Return a consed string which is the word specified in SPEC, and found
   in FROM.  NULL is returned if there is no spec.  The address of
   ERROR_POINTER is returned if the word specified cannot be found.
   CALLER_INDEX is the offset in SPEC to start looking; it is updated
   to point to just after the last character parsed. */
static char *
get_history_word_specifier (spec, from, caller_index)
     char *spec, *from;
     int *caller_index;
{
  register int i = *caller_index;
  int first, last;
  int expecting_word_spec = 0;
  char *result;

  /* The range of words to return doesn't exist yet. */
  first = last = 0;
  result = (char *)NULL;

  /* If we found a colon, then this *must* be a word specification.  If
     it isn't, then it is an error. */
  if (spec[i] == ':')
    {
      i++;
      expecting_word_spec++;
    }

  /* Handle special cases first. */

  /* `%' is the word last searched for. */
  if (spec[i] == '%')
    {
      *caller_index = i + 1;
      return (search_match ? savestring (search_match) : savestring (""));
    }

  /* `*' matches all of the arguments, but not the command. */
  if (spec[i] == '*')
    {
      *caller_index = i + 1;
      result = history_arg_extract (1, '$', from);
      return (result ? result : savestring (""));
    }

  /* `$' is last arg. */
  if (spec[i] == '$')
    {
      *caller_index = i + 1;
      return (history_arg_extract ('$', '$', from));
    }

  /* Try to get FIRST and LAST figured out. */

  if (spec[i] == '-')
    first = 0;
  else if (spec[i] == '^')
    {
      first = 1;
      i++;
    }
  else if (_rl_digit_p (spec[i]) && expecting_word_spec)
    {
      for (first = 0; _rl_digit_p (spec[i]); i++)
	first = (first * 10) + _rl_digit_value (spec[i]);
    }
  else
    return ((char *)NULL);	/* no valid `first' for word specifier */

  if (spec[i] == '^' || spec[i] == '*')
    {
      last = (spec[i] == '^') ? 1 : '$';	/* x* abbreviates x-$ */
      i++;
    }
  else if (spec[i] != '-')
    last = first;
  else
    {
      i++;

      if (_rl_digit_p (spec[i]))
	{
	  for (last = 0; _rl_digit_p (spec[i]); i++)
	    last = (last * 10) + _rl_digit_value (spec[i]);
	}
      else if (spec[i] == '$')
	{
	  i++;
	  last = '$';
	}
#if 0
      else if (!spec[i] || spec[i] == ':')
	/* check against `:' because there could be a modifier separator */
#else
      else
	/* csh seems to allow anything to terminate the word spec here,
	   leaving it as an abbreviation. */
#endif
	last = -1;		/* x- abbreviates x-$ omitting word `$' */
    }

  *caller_index = i;

  if (last >= first || last == '$' || last < 0)
    result = history_arg_extract (first, last, from);

  return (result ? result : (char *)&error_pointer);
}

/* Extract the args specified, starting at FIRST, and ending at LAST.
   The args are taken from STRING.  If either FIRST or LAST is < 0,
   then make that arg count from the right (subtract from the number of
   tokens, so that FIRST = -1 means the next to last token on the line).
   If LAST is `$' the last arg from STRING is used. */
char *
history_arg_extract (first, last, string)
     int first, last;
     const char *string;
{
  register int i, len;
  char *result;
  int size, offset;
  char **list;

  /* XXX - think about making history_tokenize return a struct array,
     each struct in array being a string and a length to avoid the
     calls to strlen below. */
  if ((list = history_tokenize (string)) == NULL)
    return ((char *)NULL);

  for (len = 0; list[len]; len++)
    ;

  if (last < 0)
    last = len + last - 1;

  if (first < 0)
    first = len + first - 1;

  if (last == '$')
    last = len - 1;

  if (first == '$')
    first = len - 1;

  last++;

  if (first >= len || last > len || first < 0 || last < 0 || first > last)
    result = ((char *)NULL);
  else
    {
      for (size = 0, i = first; i < last; i++)
	size += strlen (list[i]) + 1;
      result = (char *)xmalloc (size + 1);
      result[0] = '\0';

      for (i = first, offset = 0; i < last; i++)
	{
	  strcpy (result + offset, list[i]);
	  offset += strlen (list[i]);
	  if (i + 1 < last)
	    {
      	      result[offset++] = ' ';
	      result[offset] = 0;
	    }
	}
    }

  for (i = 0; i < len; i++)
    xfree (list[i]);
  xfree (list);

  return (result);
}

static int
history_tokenize_word (string, ind)
     const char *string;
     int ind;
{
  register int i;
  int delimiter, nestdelim, delimopen;

  i = ind;
  delimiter = nestdelim = 0;

  if (member (string[i], "()\n"))
    {
      i++;
      return i;
    }

  if (member (string[i], "<>;&|$"))
    {
      int peek = string[i + 1];

      if (peek == string[i] && peek != '$')
	{
	  if (peek == '<' && string[i + 2] == '-')
	    i++;
	  else if (peek == '<' && string[i + 2] == '<')
	    i++;
	  i += 2;
	  return i;
	}
      else if ((peek == '&' && (string[i] == '>' || string[i] == '<')) ||
		(peek == '>' && string[i] == '&'))
	{
	  i += 2;
	  return i;
	}
      /* XXX - separated out for later -- bash-4.2 */
      else if ((peek == '(' && (string[i] == '>' || string[i] == '<')) || /* ) */
	       (peek == '(' && string[i] == '$')) /*)*/
	{
	  i += 2;
	  delimopen = '(';
	  delimiter = ')';
	  nestdelim = 1;
	  goto get_word;
	}
#if 0
      else if (peek == '\'' && string[i] == '$')
        {
	  i += 2;	/* XXX */
	  return i;
        }
#endif

      if (string[i] != '$')
	{
	  i++;
	  return i;
	}
    }

  /* same code also used for $(...)/<(...)/>(...) above */
  if (member (string[i], "!@@?+*"))
    {
      int peek = string[i + 1];

      if (peek == '(')		/*)*/
	{
	  /* Shell extended globbing patterns */
	  i += 2;
	  delimopen = '(';
	  delimiter = ')';	/* XXX - not perfect */
	  nestdelim = 1;
	}
    }

get_word:
  /* Get word from string + i; */

  if (delimiter == 0 && member (string[i], HISTORY_QUOTE_CHARACTERS))
    delimiter = string[i++];

  for (; string[i]; i++)
    {
      if (string[i] == '\\' && string[i + 1] == '\n')
	{
	  i++;
	  continue;
	}

      if (string[i] == '\\' && delimiter != '\'' &&
	  (delimiter != '"' || member (string[i], slashify_in_quotes)))
	{
	  i++;
	  continue;
	}

      /* delimiter must be set and set to something other than a quote if
	 nestdelim is set, so these tests are safe. */
      if (nestdelim && string[i] == delimopen)
	{
	  nestdelim++;
	  continue;
	}
      if (nestdelim && string[i] == delimiter)
	{
	  nestdelim--;
	  if (nestdelim == 0)
	    delimiter = 0;
	  continue;
	}
      
      if (delimiter && string[i] == delimiter)
	{
	  delimiter = 0;
	  continue;
	}

      if (delimiter == 0 && (member (string[i], history_word_delimiters)))
	break;

      if (delimiter == 0 && member (string[i], HISTORY_QUOTE_CHARACTERS))
	delimiter = string[i];
    }

  return i;
}

static char *
history_substring (string, start, end)
     const char *string;
     int start, end;
{
  register int len;
  register char *result;

  len = end - start;
  result = (char *)xmalloc (len + 1);
  strncpy (result, string + start, len);
  result[len] = '\0';
  return result;
}

/* Parse STRING into tokens and return an array of strings.  If WIND is
   not -1 and INDP is not null, we also want the word surrounding index
   WIND.  The position in the returned array of strings is returned in
   *INDP. */
static char **
history_tokenize_internal (string, wind, indp)
     const char *string;
     int wind, *indp;
{
  char **result;
  register int i, start, result_index, size;

  /* If we're searching for a string that's not part of a word (e.g., " "),
     make sure we set *INDP to a reasonable value. */
  if (indp && wind != -1)
    *indp = -1;

  /* Get a token, and stuff it into RESULT.  The tokens are split
     exactly where the shell would split them. */
  for (i = result_index = size = 0, result = (char **)NULL; string[i]; )
    {
      /* Skip leading whitespace. */
      for (; string[i] && whitespace (string[i]); i++)
	;
      if (string[i] == 0 || string[i] == history_comment_char)
	return (result);

      start = i;

      i = history_tokenize_word (string, start);

      /* If we have a non-whitespace delimiter character (which would not be
	 skipped by the loop above), use it and any adjacent delimiters to
	 make a separate field.  Any adjacent white space will be skipped the
	 next time through the loop. */
      if (i == start && history_word_delimiters)
	{
	  i++;
	  while (string[i] && member (string[i], history_word_delimiters))
	    i++;
	}

      /* If we are looking for the word in which the character at a
	 particular index falls, remember it. */
      if (indp && wind != -1 && wind >= start && wind < i)
        *indp = result_index;

      if (result_index + 2 >= size)
	result = (char **)xrealloc (result, ((size += 10) * sizeof (char *)));

      result[result_index++] = history_substring (string, start, i);
      result[result_index] = (char *)NULL;
    }

  return (result);
}

/* Return an array of tokens, much as the shell might.  The tokens are
   parsed out of STRING. */
char **
history_tokenize (string)
     const char *string;
{
  return (history_tokenize_internal (string, -1, (int *)NULL));
}

/* Free members of WORDS from START to an empty string */
static void
freewords (words, start)
     char **words;
     int start;
{
  register int i;

  for (i = start; words[i]; i++)
    xfree (words[i]);
}

/* Find and return the word which contains the character at index IND
   in the history line LINE.  Used to save the word matched by the
   last history !?string? search. */
static char *
history_find_word (line, ind)
     char *line;
     int ind;
{
  char **words, *s;
  int i, wind;

  words = history_tokenize_internal (line, ind, &wind);
  if (wind == -1 || words == 0)
    {
      if (words)
	freewords (words, 0);
      FREE (words);
      return ((char *)NULL);
    }
  s = words[wind];
  for (i = 0; i < wind; i++)
    xfree (words[i]);
  freewords (words, wind + 1);
  xfree (words);
  return s;
}
@


1.6
log
@Readline 5.1 import for HEAD.
@
text
@d3 1
a3 1
/* Copyright (C) 1989-2004 Free Software Foundation, Inc.
d5 1
a5 1
   This file contains the GNU History Library (the Library), a set of
d8 1
a8 1
   The Library is free software; you can redistribute it and/or modify
d10 2
a11 2
   the Free Software Foundation; either version 2, or (at your option)
   any later version.
d13 8
a20 9
   The Library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   The GNU General Public License is often shipped with GNU software, and
   is generally kept in a file called COPYING or LICENSE.  If you do not
   have a copy of the license, write to the Free Software Foundation,
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
a57 2
extern int rl_byte_oriented;	/* declared in mbutil.c */

a65 1
static char *history_find_word PARAMS((char *, int));
d67 1
d69 2
d248 1
a248 1
    history_offset = history_length; free (temp) ; return (char *)NULL; \
d257 1
a257 1
          free (temp);
d288 1
a288 1
	    free (temp);
d308 2
a309 1
   to the closing single quote. */
d311 1
a311 1
hist_string_extract_single_quoted (string, sindex)
d313 1
a313 1
     int *sindex;
d318 4
a321 1
    ;
d511 1
a511 1
  free (subst_rhs);
d570 1
a570 1
	  int c, l;
d572 1
a572 1
	  c = string[l];
d574 2
a575 2
	  if (i && (c == '\'' || c == '"'))
	    quoted_search_delimiter = c;
d588 1
a588 1
      free (result);
d602 1
a602 1
      free (result);
d635 2
a636 2
	  free (result);
	  free (temp);
d661 1
a661 1
	      free (temp);
d686 1
a686 1
	      free (temp);
d762 2
a763 2
		free (result);
		free (temp);
d772 2
a773 2
		free (result);
		free (temp);
d814 1
a814 1
		    free (temp);
d850 2
a851 2
	    free (result);
	    free (temp);
d872 1
a872 1
      free (temp);
d880 1
a880 1
  free (temp);
d931 1
a931 1
  int i, r, l, passc, cc, modified, eindex, only_printing, dquote;
d1023 1
a1023 1
	      if (!cc || member (cc, history_no_expand_chars))
d1051 1
d1053 1
a1053 1
	      hist_string_extract_single_quoted (string, &i);
d1067 1
a1067 1
	  free (result);
d1104 1
a1104 1
	      break;
d1138 1
d1140 1
a1140 1
		hist_string_extract_single_quoted (string, &i);
d1147 1
a1147 1
		free (temp);
d1160 1
a1160 1
	      free (temp);
d1173 2
a1174 1
	  if (member (cc, history_no_expand_chars))
d1193 1
a1193 1
		  free (temp);
d1204 1
a1204 1
	      free (result);
d1206 1
a1206 1
		free (string);
d1216 1
a1216 1
		  free (temp);
d1227 1
a1227 1
    free (string);
d1408 2
a1409 2
    free (list[i]);
  free (list);
d1420 1
a1420 1
  int delimiter;
d1423 1
a1423 1
  delimiter = 0;
d1439 2
d1444 9
a1452 1
      else
d1454 5
a1458 8
	  if ((peek == '&' && (string[i] == '>' || string[i] == '<')) ||
	      (peek == '>' && string[i] == '&') ||
	      (peek == '(' && (string[i] == '>' || string[i] == '<')) || /* ) */
	      (peek == '(' && string[i] == '$')) /* ) */
	    {
	      i += 2;
	      return i;
	    }
d1460 7
d1475 16
d1493 1
a1493 1
  if (member (string[i], HISTORY_QUOTE_CHARACTERS))
d1511 15
d1532 1
a1532 1
      if (!delimiter && (member (string[i], history_word_delimiters)))
d1535 1
a1535 1
      if (!delimiter && member (string[i], HISTORY_QUOTE_CHARACTERS))
d1623 12
d1648 6
a1653 1
    return ((char *)NULL);
d1656 3
a1658 4
    free (words[i]);
  for (i = wind + 1; words[i]; i++)
    free (words[i]);
  free (words);
@


1.5
log
@touched all sources to ease import of readline-5.1
@
text
@d3 1
a3 1
/* Copyright (C) 1989, 1992 Free Software Foundation, Inc.
d55 2
d70 2
d209 1
d211 15
a225 4
    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
      {
	int v;
	mbstate_t ps;
a226 11
	memset (&ps, 0, sizeof (mbstate_t));
	/* These produce warnings because we're passing a const string to a
	   function that takes a non-const string. */
	_rl_adjust_point (string, i, &ps);
	if ((v = _rl_get_char_len (string + i, &ps)) > 1)
	  {
	    i += v - 1;
	    continue;
	  }
      }
    else
d234 1
d526 1
a526 1
  int substitute_globally, want_quotes, print_only;
d608 1
a608 1
  want_quotes = substitute_globally = print_only = 0;
d615 1
a615 1
      if (c == 'g')
d621 6
d698 1
a698 1
	    int delimiter, failed, si, l_temp;
d775 13
a787 1
	    si = 0;
d789 24
a812 12
	      if (STREQN (temp+si, subst_lhs, subst_lhs_len))
		{
		  int len = subst_rhs_len - subst_lhs_len + l_temp;
		  new_event = (char *)xmalloc (1 + len);
		  strncpy (new_event, temp, si);
		  strncpy (new_event + si, subst_rhs, subst_rhs_len);
		  strncpy (new_event + si + subst_rhs_len,
			   temp + si + subst_lhs_len,
			   l_temp - (si + subst_lhs_len));
		  new_event[len] = '\0';
		  free (temp);
		  temp = new_event;
d814 1
a814 1
		  failed = 0;
d816 20
a835 10
		  if (substitute_globally)
		    {
		      si += subst_rhs_len;
		      l_temp = strlen (temp);
		      substitute_globally++;
		      continue;
		    }
		  else
		    break;
		}
d928 1
a928 1
  int i, r, l, passc, cc, modified, eindex, only_printing;
d991 1
a991 1
      for (i = 0; string[i]; i++)
d1033 13
a1045 3
	  /* XXX - at some point, might want to extend this to handle
		   double quotes as well. */
	  else if (history_quotes_inhibit_expansion && string[i] == '\'')
d1058 1
d1070 1
a1070 1
  for (passc = i = j = 0; i < l; i++)
d1121 5
d1130 1
a1130 1
	    if (history_quotes_inhibit_expansion)
d1225 1
d1227 1
d1290 4
a1293 1
    first = 1;
d1408 97
a1504 1
#define slashify_in_quotes "\\`\"$"
a1516 1
  int len, delimiter;
a1526 2
      delimiter = 0;

a1533 6
      
      if (member (string[i], "()\n"))
	{
	  i++;
	  goto got_token;
	}
d1535 1
a1535 3
      if (member (string[i], "<>;&|$"))
	{
	  int peek = string[i + 1];
d1537 5
a1541 30
	  if (peek == string[i] && peek != '$')
	    {
	      if (peek == '<' && string[i + 2] == '-')
		i++;
	      i += 2;
	      goto got_token;
	    }
	  else
	    {
	      if ((peek == '&' && (string[i] == '>' || string[i] == '<')) ||
		  ((peek == '>') && (string[i] == '&')) ||
		  ((peek == '(') && (string[i] == '$')))
		{
		  i += 2;
		  goto got_token;
		}
	    }
	  if (string[i] != '$')
	    {
	      i++;
	      goto got_token;
	    }
	}

      /* Get word from string + i; */

      if (member (string[i], HISTORY_QUOTE_CHARACTERS))
	delimiter = string[i++];

      for (; string[i]; i++)
d1543 3
a1545 24
	  if (string[i] == '\\' && string[i + 1] == '\n')
	    {
	      i++;
	      continue;
	    }

	  if (string[i] == '\\' && delimiter != '\'' &&
	      (delimiter != '"' || member (string[i], slashify_in_quotes)))
	    {
	      i++;
	      continue;
	    }

	  if (delimiter && string[i] == delimiter)
	    {
	      delimiter = 0;
	      continue;
	    }

	  if (!delimiter && (member (string[i], history_word_delimiters)))
	    break;

	  if (!delimiter && member (string[i], HISTORY_QUOTE_CHARACTERS))
	    delimiter = string[i];
a1547 2
    got_token:

a1552 1
      len = i - start;
d1555 3
a1557 4
      result[result_index] = (char *)xmalloc (1 + len);
      strncpy (result[result_index], string + start, len);
      result[result_index][len] = '\0';
      result[++result_index] = (char *)NULL;
@


1.5.2.1
log
@Import readline 5.1 on the branch.
@
text
@d3 1
a3 1
/* Copyright (C) 1989-2004 Free Software Foundation, Inc.
a54 2
#define slashify_in_quotes "\\`\"$"

a67 2
static int history_tokenize_word PARAMS((const char *, int));
static char *history_substring PARAMS((const char *, int, int));
a204 1
    {
d206 4
a209 15
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  int v;
	  mbstate_t ps;

	  memset (&ps, 0, sizeof (mbstate_t));
	  /* These produce warnings because we're passing a const string to a
	     function that takes a non-const string. */
	  _rl_adjust_point ((char *)string, i, &ps);
	  if ((v = _rl_get_char_len ((char *)string + i, &ps)) > 1)
	    {
	      i += v - 1;
	      continue;
	    }
        }
d211 11
a228 1
    }
d520 1
a520 1
  int substitute_globally, subst_bywords, want_quotes, print_only;
d602 1
a602 1
  want_quotes = substitute_globally = subst_bywords = print_only = 0;
d609 1
a609 1
      if (c == 'g' || c == 'a')
a614 6
      else if (c == 'G')
	{
	  subst_bywords = 1;
	  i++;
	  c = string[i + 1];
	}
d686 1
a686 1
	    int delimiter, failed, si, l_temp, ws, we;
d763 1
a763 13
	    /* Substitute SUBST_RHS for SUBST_LHS in TEMP.  There are three
	       cases to consider:

		 1.  substitute_globally == subst_bywords == 0
		 2.  substitute_globally == 1 && subst_bywords == 0
		 3.  substitute_globally == 0 && subst_bywords == 1

	       In the first case, we substitute for the first occurrence only.
	       In the second case, we substitute for every occurrence.
	       In the third case, we tokenize into words and substitute the
	       first occurrence of each word. */

	    si = we = 0;
d765 12
a776 11
	      {
		/* First skip whitespace and find word boundaries if
		   we're past the end of the word boundary we found
		   the last time. */
		if (subst_bywords && si > we)
		  {
		    for (; temp[si] && whitespace (temp[si]); si++)
		      ;
		    ws = si;
		    we = history_tokenize_word (temp, si);
		  }
d778 1
a778 12
		if (STREQN (temp+si, subst_lhs, subst_lhs_len))
		  {
		    int len = subst_rhs_len - subst_lhs_len + l_temp;
		    new_event = (char *)xmalloc (1 + len);
		    strncpy (new_event, temp, si);
		    strncpy (new_event + si, subst_rhs, subst_rhs_len);
		    strncpy (new_event + si + subst_rhs_len,
			     temp + si + subst_lhs_len,
			     l_temp - (si + subst_lhs_len));
		    new_event[len] = '\0';
		    free (temp);
		    temp = new_event;
d780 10
a789 22
		    failed = 0;

		    if (substitute_globally)
		      {
			/* Reported to fix a bug that causes it to skip every
			   other match when matching a single character.  Was
			   si += subst_rhs_len previously. */
			si += subst_rhs_len - 1;
			l_temp = strlen (temp);
			substitute_globally++;
			continue;
		      }
		    else if (subst_bywords)
		      {
			si = we;
			l_temp = strlen (temp);
			continue;
		      }
		    else
		      break;
		  }
	      }
d882 1
a882 1
  int i, r, l, passc, cc, modified, eindex, only_printing, dquote;
d945 1
a945 1
      for (i = dquote = 0; string[i]; i++)
d987 3
a989 13
	  /* Shell-like quoting: allow backslashes to quote double quotes
	     inside a double-quoted string. */
	  else if (dquote && string[i] == '\\' && cc == '"')
	    i++;
	  /* More shell-like quoting:  if we're paying attention to single
	     quotes and letting them quote the history expansion character,
	     then we need to pay attention to double quotes, because single
	     quotes are not special inside double-quoted strings. */
	  else if (history_quotes_inhibit_expansion && string[i] == '"')
	    {
	      dquote = 1 - dquote;
	    }
	  else if (dquote == 0 && history_quotes_inhibit_expansion && string[i] == '\'')
a1001 1
	  
d1013 1
a1013 1
  for (passc = dquote = i = j = 0; i < l; i++)
a1063 5
	case '"':
	  dquote = 1 - dquote;
	  ADD_CHAR (tchar);
	  break;
	  
d1068 1
a1068 1
	    if (dquote == 0 && history_quotes_inhibit_expansion)
a1162 1
#if 0
a1163 1
#endif
d1226 1
a1226 4
    {
      first = 1;
      i++;
    }
d1341 1
a1341 97
static int
history_tokenize_word (string, ind)
     const char *string;
     int ind;
{
  register int i;
  int delimiter;

  i = ind;
  delimiter = 0;

  if (member (string[i], "()\n"))
    {
      i++;
      return i;
    }

  if (member (string[i], "<>;&|$"))
    {
      int peek = string[i + 1];

      if (peek == string[i] && peek != '$')
	{
	  if (peek == '<' && string[i + 2] == '-')
	    i++;
	  i += 2;
	  return i;
	}
      else
	{
	  if ((peek == '&' && (string[i] == '>' || string[i] == '<')) ||
	      (peek == '>' && string[i] == '&') ||
	      (peek == '(' && (string[i] == '>' || string[i] == '<')) || /* ) */
	      (peek == '(' && string[i] == '$')) /* ) */
	    {
	      i += 2;
	      return i;
	    }
	}

      if (string[i] != '$')
	{
	  i++;
	  return i;
	}
    }

  /* Get word from string + i; */

  if (member (string[i], HISTORY_QUOTE_CHARACTERS))
    delimiter = string[i++];

  for (; string[i]; i++)
    {
      if (string[i] == '\\' && string[i + 1] == '\n')
	{
	  i++;
	  continue;
	}

      if (string[i] == '\\' && delimiter != '\'' &&
	  (delimiter != '"' || member (string[i], slashify_in_quotes)))
	{
	  i++;
	  continue;
	}

      if (delimiter && string[i] == delimiter)
	{
	  delimiter = 0;
	  continue;
	}

      if (!delimiter && (member (string[i], history_word_delimiters)))
	break;

      if (!delimiter && member (string[i], HISTORY_QUOTE_CHARACTERS))
	delimiter = string[i];
    }

  return i;
}

static char *
history_substring (string, start, end)
     const char *string;
     int start, end;
{
  register int len;
  register char *result;

  len = end - start;
  result = (char *)xmalloc (len + 1);
  strncpy (result, string + start, len);
  result[len] = '\0';
  return result;
}
d1354 1
d1365 2
d1374 6
d1381 3
a1383 1
      i = history_tokenize_word (string, start);
d1385 30
a1414 5
      /* If we have a non-whitespace delimiter character (which would not be
	 skipped by the loop above), use it and any adjacent delimiters to
	 make a separate field.  Any adjacent white space will be skipped the
	 next time through the loop. */
      if (i == start && history_word_delimiters)
d1416 24
a1439 3
	  i++;
	  while (string[i] && member (string[i], history_word_delimiters))
	    i++;
d1442 2
d1449 1
d1452 4
a1455 3

      result[result_index++] = history_substring (string, start, i);
      result[result_index] = (char *)NULL;
@


1.4
log
@Import of readline 4.3.
Non-readline modified files:

src/gdb/ChangeLog src/gdb/defs.h src/gdb/cli/cli-cmds.c
src/gdb/cli/cli-setshow.c src/gdb/tui/ChangeLog
src/gdb/tui/tuiWin.c

In readline directory:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@@


1.3
log
@readline:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Locally modified files: Makefile.in, configure.in, configure
        (regenerated), config.h.in (regenerated), readline.h, rltty.c,
 	shell.c signals.c.

        Locally added files: acconfig.h, config/*, config.h.bot,
        cross-build/*, doc/inc-hit.texinfo.

        New files: USAGE, rlprivate.h, rlshell.h, xmalloc.h.
examples:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        New files: excallback.c, rlfe.c.
doc:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Regenerated inc-hist.texinfo as copy of hsuser.texinfo, for
        inclusion in the gdb manual.

        New file: rluserman.texinfo
@
text
@d44 1
a44 5
#if defined (HAVE_STRING_H)
#  include <string.h>
#else
#  include <strings.h>
#endif /* !HAVE_STRING_H */
d55 4
d66 2
a67 2
static char *get_history_word_specifier __P((char *, char *, int *));
static char *history_find_word __P((char *, int));
d69 1
a69 1
static char *quote_breaks __P((char *));
d94 3
d99 1
a99 1
Function *history_inhibit_expansion_function;
d128 1
a128 1
     char *string;
d136 1
a136 1
  Function *search_func;
d205 24
a228 6
    if ((!substring_okay && (whitespace (c) || c == ':' ||
	(history_search_delimiter_chars && member (c, history_search_delimiter_chars)) ||
	string[i] == delimiting_quote)) ||
	string[i] == '\n' ||
	(substring_okay && string[i] == '?'))
      break;
d231 1
a231 1
  temp = xmalloc (1 + which);
d333 1
a333 1
  r = ret = xmalloc (len);
d364 2
a365 1
  char *temp, *emsg;
d398 1
a398 1
  temp = xmalloc (ll + elen + 3);
d424 4
a427 1
  char *s = (char *) NULL;
d429 1
d432 5
d438 13
a450 2
    if (str[si] == '\\' && str[si + 1] == delimiter)
      si++;
d454 1
a454 1
      s = xmalloc (si - i + 1);
d481 1
a481 1
  new = xmalloc (new_size = subst_rhs_len + subst_lhs_len);
d487 1
a487 1
	    new = xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));
d497 1
a497 1
	    new = xrealloc (new, new_size *= 2);
d523 5
d529 1
a529 1
  result = xmalloc (result_len = 128);
d558 15
a572 2
      if (i && (string[i - 1] == '\'' || string[i - 1] == '"'))
	quoted_search_delimiter = string[i - 1];
d685 1
a685 1
	    char *new_event, *t;
d691 14
a704 1
		  delimiter = string[i + 2];
d768 1
a768 1
		  new_event = xmalloc (1 + len);
d817 1
a817 1
	x = single_quote (temp);
d829 1
a829 1
    result = xrealloc (result, n + 2);
d860 1
a860 1
		result = xrealloc (result, result_len); \
d870 1
a870 1
	      result = xrealloc (result, result_len += 64); \
d889 5
d897 3
d909 1
a909 1
  result = xmalloc (result_len = 256);
d926 1
a926 1
      string = xmalloc (l + 5);
d936 4
d947 13
d961 1
a961 1
	  /* The history_comment_char, if set, appearing that the beginning
d966 1
a966 1
	      (i == 0 || member (string[i - 1], HISTORY_WORD_DELIMITERS)))
d1024 24
d1076 1
a1076 1
		temp = xmalloc (slen);
d1088 1
a1088 1
	  if (i == 0 || member (string[i - 1], HISTORY_WORD_DELIMITERS))
d1090 1
a1090 1
	      temp = xmalloc (l - i + 1);
d1122 1
a1122 1
		  temp = xmalloc (1 + strlen (result));
d1256 8
a1263 1
      else if (!spec[i] || spec[i] == ':')  /* could be modifier separator */
d1283 1
a1283 1
     char *string;
d1319 1
a1319 1
      result = xmalloc (size + 1);
d1349 1
a1349 1
     char *string;
d1356 5
d1435 1
a1435 1
	  if (!delimiter && (member (string[i], HISTORY_WORD_DELIMITERS)))
d1452 1
a1452 1
      result[result_index] = xmalloc (1 + len);
d1465 1
a1465 1
     char *string;
d1482 1
a1482 1
  if (wind == -1)
@


1.3.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d44 5
a48 1
#include "rlmbutil.h"
a58 4
typedef int _hist_search_func_t PARAMS((const char *, int));

extern int rl_byte_oriented;	/* declared in mbutil.c */

d66 2
a67 2
static char *get_history_word_specifier PARAMS((char *, char *, int *));
static char *history_find_word PARAMS((char *, int));
d69 1
a69 1
static char *quote_breaks PARAMS((char *));
a93 3
/* Used to split words by history_tokenize_internal. */
char *history_word_delimiters = HISTORY_WORD_DELIMITERS;

d96 1
a96 1
rl_linebuf_func_t *history_inhibit_expansion_function;
d125 1
a125 1
     const char *string;
d133 1
a133 1
  _hist_search_func_t *search_func;
d202 6
a207 24
#if defined (HANDLE_MULTIBYTE)
    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
      {
	int v;
	mbstate_t ps;

	memset (&ps, 0, sizeof (mbstate_t));
	/* These produce warnings because we're passing a const string to a
	   function that takes a non-const string. */
	_rl_adjust_point (string, i, &ps);
	if ((v = _rl_get_char_len (string + i, &ps)) > 1)
	  {
	    i += v - 1;
	    continue;
	  }
      }
    else
#endif /* HANDLE_MULTIBYTE */
      if ((!substring_okay && (whitespace (c) || c == ':' ||
	  (history_search_delimiter_chars && member (c, history_search_delimiter_chars)) ||
	  string[i] == delimiting_quote)) ||
	  string[i] == '\n' ||
	  (substring_okay && string[i] == '?'))
	break;
d210 1
a210 1
  temp = (char *)xmalloc (1 + which);
d312 1
a312 1
  r = ret = (char *)xmalloc (len);
d343 1
a343 2
  char *temp;
  const char *emsg;
d376 1
a376 1
  temp = (char *)xmalloc (ll + elen + 3);
d402 1
a402 4
  char *s;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
#endif
a403 1
  s = (char *)NULL;
a405 5
#if defined (HANDLE_MULTIBYTE)
  memset (&ps, 0, sizeof (mbstate_t));
  _rl_adjust_point (str, i, &ps);
#endif

d407 2
a408 13
#if defined (HANDLE_MULTIBYTE)
    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
      {
	int v;
	if ((v = _rl_get_char_len (str + si, &ps)) > 1)
	  si += v - 1;
	else if (str[si] == '\\' && str[si + 1] == delimiter)
	  si++;
      }
    else
#endif /* HANDLE_MULTIBYTE */
      if (str[si] == '\\' && str[si + 1] == delimiter)
	si++;
d412 1
a412 1
      s = (char *)xmalloc (si - i + 1);
d439 1
a439 1
  new = (char *)xmalloc (new_size = subst_rhs_len + subst_lhs_len);
d445 1
a445 1
	    new = (char *)xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));
d455 1
a455 1
	    new = (char *)xrealloc (new, new_size *= 2);
a480 5
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;

  memset (&ps, 0, sizeof (mbstate_t));
#endif
d482 1
a482 1
  result = (char *)xmalloc (result_len = 128);
d511 2
a512 15
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  int c, l;
	  l = _rl_find_prev_mbchar (string, i, MB_FIND_ANY);
	  c = string[l];
	  /* XXX - original patch had i - 1 ???  If i == 0 it would fail. */
	  if (i && (c == '\'' || c == '"'))
	    quoted_search_delimiter = c;
	}
      else
#endif /* HANDLE_MULTIBYTE */	  
	if (i && (string[i - 1] == '\'' || string[i - 1] == '"'))
	  quoted_search_delimiter = string[i - 1];

d625 1
a625 1
	    char *new_event;
d631 1
a631 14
		  {
#if defined (HANDLE_MULTIBYTE)
		    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		      {
			_rl_adjust_point (string, i + 2, &ps);
			if (_rl_get_char_len (string + i + 2, &ps) > 1)
			  delimiter = 0;
			else
			  delimiter = string[i + 2];
		      }
		    else
#endif /* HANDLE_MULTIBYTE */
		      delimiter = string[i + 2];
		  }
d695 1
a695 1
		  new_event = (char *)xmalloc (1 + len);
d744 1
a744 1
	x = sh_single_quote (temp);
d756 1
a756 1
    result = (char *)xrealloc (result, n + 2);
d787 1
a787 1
		result = (char *)xrealloc (result, result_len); \
d797 1
a797 1
	      result = (char *)xrealloc (result, result_len += 64); \
a815 5
#if defined (HANDLE_MULTIBYTE)
  char mb[MB_LEN_MAX];
  mbstate_t ps;
#endif

a818 3
  if (output == 0)
    return 0;

d828 1
a828 1
  result = (char *)xmalloc (result_len = 256);
d845 1
a845 1
      string = (char *)xmalloc (l + 5);
a854 4
#if defined (HANDLE_MULTIBYTE)
      memset (&ps, 0, sizeof (mbstate_t));
#endif

a861 13
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      int v;
	      v = _rl_get_char_len (string + i, &ps);
	      if (v > 1)
		{
		  i += v - 1;
		  continue;
		}
	    }
#endif /* HANDLE_MULTIBYTE */

d863 1
a863 1
	  /* The history_comment_char, if set, appearing at the beginning
d868 1
a868 1
	      (i == 0 || member (string[i - 1], history_word_delimiters)))
a925 24
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  int k, c;

	  c = tchar;
	  memset (mb, 0, sizeof (mb));
	  for (k = 0; k < MB_LEN_MAX; k++)
	    {
	      mb[k] = (char)c;
	      memset (&ps, 0, sizeof (mbstate_t));
	      if (_rl_get_char_len (mb, &ps) == -2)
		c = string[++i];
	      else
		break;
	    }
	  if (strlen (mb) > 1)
	    {
	      ADD_STRING (mb);
	      break;
	    }
	}
#endif /* HANDLE_MULTIBYTE */

d954 1
a954 1
		temp = (char *)xmalloc (slen);
d966 1
a966 1
	  if (i == 0 || member (string[i - 1], history_word_delimiters))
d968 1
a968 1
	      temp = (char *)xmalloc (l - i + 1);
d1000 1
a1000 1
		  temp = (char *)xmalloc (1 + strlen (result));
d1134 1
a1134 8
#if 0
      else if (!spec[i] || spec[i] == ':')
	/* check against `:' because there could be a modifier separator */
#else
      else
	/* csh seems to allow anything to terminate the word spec here,
	   leaving it as an abbreviation. */
#endif
d1154 1
a1154 1
     const char *string;
d1190 1
a1190 1
      result = (char *)xmalloc (size + 1);
d1220 1
a1220 1
     const char *string;
a1226 5
  /* If we're searching for a string that's not part of a word (e.g., " "),
     make sure we set *INDP to a reasonable value. */
  if (indp && wind != -1)
    *indp = -1;

d1301 1
a1301 1
	  if (!delimiter && (member (string[i], history_word_delimiters)))
d1318 1
a1318 1
      result[result_index] = (char *)xmalloc (1 + len);
d1331 1
a1331 1
     const char *string;
d1348 1
a1348 1
  if (wind == -1 || words == 0)
@


1.3.22.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d44 5
a48 1
#include "rlmbutil.h"
a58 4
typedef int _hist_search_func_t PARAMS((const char *, int));

extern int rl_byte_oriented;	/* declared in mbutil.c */

d66 2
a67 2
static char *get_history_word_specifier PARAMS((char *, char *, int *));
static char *history_find_word PARAMS((char *, int));
d69 1
a69 1
static char *quote_breaks PARAMS((char *));
a93 3
/* Used to split words by history_tokenize_internal. */
char *history_word_delimiters = HISTORY_WORD_DELIMITERS;

d96 1
a96 1
rl_linebuf_func_t *history_inhibit_expansion_function;
d125 1
a125 1
     const char *string;
d133 1
a133 1
  _hist_search_func_t *search_func;
d202 6
a207 24
#if defined (HANDLE_MULTIBYTE)
    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
      {
	int v;
	mbstate_t ps;

	memset (&ps, 0, sizeof (mbstate_t));
	/* These produce warnings because we're passing a const string to a
	   function that takes a non-const string. */
	_rl_adjust_point (string, i, &ps);
	if ((v = _rl_get_char_len (string + i, &ps)) > 1)
	  {
	    i += v - 1;
	    continue;
	  }
      }
    else
#endif /* HANDLE_MULTIBYTE */
      if ((!substring_okay && (whitespace (c) || c == ':' ||
	  (history_search_delimiter_chars && member (c, history_search_delimiter_chars)) ||
	  string[i] == delimiting_quote)) ||
	  string[i] == '\n' ||
	  (substring_okay && string[i] == '?'))
	break;
d210 1
a210 1
  temp = (char *)xmalloc (1 + which);
d312 1
a312 1
  r = ret = (char *)xmalloc (len);
d343 1
a343 2
  char *temp;
  const char *emsg;
d376 1
a376 1
  temp = (char *)xmalloc (ll + elen + 3);
d402 1
a402 4
  char *s;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
#endif
a403 1
  s = (char *)NULL;
a405 5
#if defined (HANDLE_MULTIBYTE)
  memset (&ps, 0, sizeof (mbstate_t));
  _rl_adjust_point (str, i, &ps);
#endif

d407 2
a408 13
#if defined (HANDLE_MULTIBYTE)
    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
      {
	int v;
	if ((v = _rl_get_char_len (str + si, &ps)) > 1)
	  si += v - 1;
	else if (str[si] == '\\' && str[si + 1] == delimiter)
	  si++;
      }
    else
#endif /* HANDLE_MULTIBYTE */
      if (str[si] == '\\' && str[si + 1] == delimiter)
	si++;
d412 1
a412 1
      s = (char *)xmalloc (si - i + 1);
d439 1
a439 1
  new = (char *)xmalloc (new_size = subst_rhs_len + subst_lhs_len);
d445 1
a445 1
	    new = (char *)xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));
d455 1
a455 1
	    new = (char *)xrealloc (new, new_size *= 2);
a480 5
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;

  memset (&ps, 0, sizeof (mbstate_t));
#endif
d482 1
a482 1
  result = (char *)xmalloc (result_len = 128);
d511 2
a512 15
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  int c, l;
	  l = _rl_find_prev_mbchar (string, i, MB_FIND_ANY);
	  c = string[l];
	  /* XXX - original patch had i - 1 ???  If i == 0 it would fail. */
	  if (i && (c == '\'' || c == '"'))
	    quoted_search_delimiter = c;
	}
      else
#endif /* HANDLE_MULTIBYTE */	  
	if (i && (string[i - 1] == '\'' || string[i - 1] == '"'))
	  quoted_search_delimiter = string[i - 1];

d625 1
a625 1
	    char *new_event;
d631 1
a631 14
		  {
#if defined (HANDLE_MULTIBYTE)
		    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		      {
			_rl_adjust_point (string, i + 2, &ps);
			if (_rl_get_char_len (string + i + 2, &ps) > 1)
			  delimiter = 0;
			else
			  delimiter = string[i + 2];
		      }
		    else
#endif /* HANDLE_MULTIBYTE */
		      delimiter = string[i + 2];
		  }
d695 1
a695 1
		  new_event = (char *)xmalloc (1 + len);
d744 1
a744 1
	x = sh_single_quote (temp);
d756 1
a756 1
    result = (char *)xrealloc (result, n + 2);
d787 1
a787 1
		result = (char *)xrealloc (result, result_len); \
d797 1
a797 1
	      result = (char *)xrealloc (result, result_len += 64); \
a815 5
#if defined (HANDLE_MULTIBYTE)
  char mb[MB_LEN_MAX];
  mbstate_t ps;
#endif

a818 3
  if (output == 0)
    return 0;

d828 1
a828 1
  result = (char *)xmalloc (result_len = 256);
d845 1
a845 1
      string = (char *)xmalloc (l + 5);
a854 4
#if defined (HANDLE_MULTIBYTE)
      memset (&ps, 0, sizeof (mbstate_t));
#endif

a861 13
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      int v;
	      v = _rl_get_char_len (string + i, &ps);
	      if (v > 1)
		{
		  i += v - 1;
		  continue;
		}
	    }
#endif /* HANDLE_MULTIBYTE */

d863 1
a863 1
	  /* The history_comment_char, if set, appearing at the beginning
d868 1
a868 1
	      (i == 0 || member (string[i - 1], history_word_delimiters)))
a925 24
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  int k, c;

	  c = tchar;
	  memset (mb, 0, sizeof (mb));
	  for (k = 0; k < MB_LEN_MAX; k++)
	    {
	      mb[k] = (char)c;
	      memset (&ps, 0, sizeof (mbstate_t));
	      if (_rl_get_char_len (mb, &ps) == -2)
		c = string[++i];
	      else
		break;
	    }
	  if (strlen (mb) > 1)
	    {
	      ADD_STRING (mb);
	      break;
	    }
	}
#endif /* HANDLE_MULTIBYTE */

d954 1
a954 1
		temp = (char *)xmalloc (slen);
d966 1
a966 1
	  if (i == 0 || member (string[i - 1], history_word_delimiters))
d968 1
a968 1
	      temp = (char *)xmalloc (l - i + 1);
d1000 1
a1000 1
		  temp = (char *)xmalloc (1 + strlen (result));
d1134 1
a1134 8
#if 0
      else if (!spec[i] || spec[i] == ':')
	/* check against `:' because there could be a modifier separator */
#else
      else
	/* csh seems to allow anything to terminate the word spec here,
	   leaving it as an abbreviation. */
#endif
d1154 1
a1154 1
     const char *string;
d1190 1
a1190 1
      result = (char *)xmalloc (size + 1);
d1220 1
a1220 1
     const char *string;
a1226 5
  /* If we're searching for a string that's not part of a word (e.g., " "),
     make sure we set *INDP to a reasonable value. */
  if (indp && wind != -1)
    *indp = -1;

d1301 1
a1301 1
	  if (!delimiter && (member (string[i], history_word_delimiters)))
d1318 1
a1318 1
      result[result_index] = (char *)xmalloc (1 + len);
d1331 1
a1331 1
     const char *string;
d1348 1
a1348 1
  if (wind == -1 || words == 0)
@


1.3.16.1
log
@2002-08-24  Elena Zannoni  <ezannoni@@redhat.com>

        Import of readline 4.3:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@d44 5
a48 1
#include "rlmbutil.h"
a58 4
typedef int _hist_search_func_t PARAMS((const char *, int));

extern int rl_byte_oriented;	/* declared in mbutil.c */

d66 2
a67 2
static char *get_history_word_specifier PARAMS((char *, char *, int *));
static char *history_find_word PARAMS((char *, int));
d69 1
a69 1
static char *quote_breaks PARAMS((char *));
a93 3
/* Used to split words by history_tokenize_internal. */
char *history_word_delimiters = HISTORY_WORD_DELIMITERS;

d96 1
a96 1
rl_linebuf_func_t *history_inhibit_expansion_function;
d125 1
a125 1
     const char *string;
d133 1
a133 1
  _hist_search_func_t *search_func;
d202 6
a207 24
#if defined (HANDLE_MULTIBYTE)
    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
      {
	int v;
	mbstate_t ps;

	memset (&ps, 0, sizeof (mbstate_t));
	/* These produce warnings because we're passing a const string to a
	   function that takes a non-const string. */
	_rl_adjust_point (string, i, &ps);
	if ((v = _rl_get_char_len (string + i, &ps)) > 1)
	  {
	    i += v - 1;
	    continue;
	  }
      }
    else
#endif /* HANDLE_MULTIBYTE */
      if ((!substring_okay && (whitespace (c) || c == ':' ||
	  (history_search_delimiter_chars && member (c, history_search_delimiter_chars)) ||
	  string[i] == delimiting_quote)) ||
	  string[i] == '\n' ||
	  (substring_okay && string[i] == '?'))
	break;
d210 1
a210 1
  temp = (char *)xmalloc (1 + which);
d312 1
a312 1
  r = ret = (char *)xmalloc (len);
d343 1
a343 2
  char *temp;
  const char *emsg;
d376 1
a376 1
  temp = (char *)xmalloc (ll + elen + 3);
d402 1
a402 4
  char *s;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
#endif
a403 1
  s = (char *)NULL;
a405 5
#if defined (HANDLE_MULTIBYTE)
  memset (&ps, 0, sizeof (mbstate_t));
  _rl_adjust_point (str, i, &ps);
#endif

d407 2
a408 13
#if defined (HANDLE_MULTIBYTE)
    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
      {
	int v;
	if ((v = _rl_get_char_len (str + si, &ps)) > 1)
	  si += v - 1;
	else if (str[si] == '\\' && str[si + 1] == delimiter)
	  si++;
      }
    else
#endif /* HANDLE_MULTIBYTE */
      if (str[si] == '\\' && str[si + 1] == delimiter)
	si++;
d412 1
a412 1
      s = (char *)xmalloc (si - i + 1);
d439 1
a439 1
  new = (char *)xmalloc (new_size = subst_rhs_len + subst_lhs_len);
d445 1
a445 1
	    new = (char *)xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));
d455 1
a455 1
	    new = (char *)xrealloc (new, new_size *= 2);
a480 5
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;

  memset (&ps, 0, sizeof (mbstate_t));
#endif
d482 1
a482 1
  result = (char *)xmalloc (result_len = 128);
d511 2
a512 15
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  int c, l;
	  l = _rl_find_prev_mbchar (string, i, MB_FIND_ANY);
	  c = string[l];
	  /* XXX - original patch had i - 1 ???  If i == 0 it would fail. */
	  if (i && (c == '\'' || c == '"'))
	    quoted_search_delimiter = c;
	}
      else
#endif /* HANDLE_MULTIBYTE */	  
	if (i && (string[i - 1] == '\'' || string[i - 1] == '"'))
	  quoted_search_delimiter = string[i - 1];

d625 1
a625 1
	    char *new_event;
d631 1
a631 14
		  {
#if defined (HANDLE_MULTIBYTE)
		    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		      {
			_rl_adjust_point (string, i + 2, &ps);
			if (_rl_get_char_len (string + i + 2, &ps) > 1)
			  delimiter = 0;
			else
			  delimiter = string[i + 2];
		      }
		    else
#endif /* HANDLE_MULTIBYTE */
		      delimiter = string[i + 2];
		  }
d695 1
a695 1
		  new_event = (char *)xmalloc (1 + len);
d744 1
a744 1
	x = sh_single_quote (temp);
d756 1
a756 1
    result = (char *)xrealloc (result, n + 2);
d787 1
a787 1
		result = (char *)xrealloc (result, result_len); \
d797 1
a797 1
	      result = (char *)xrealloc (result, result_len += 64); \
a815 5
#if defined (HANDLE_MULTIBYTE)
  char mb[MB_LEN_MAX];
  mbstate_t ps;
#endif

a818 3
  if (output == 0)
    return 0;

d828 1
a828 1
  result = (char *)xmalloc (result_len = 256);
d845 1
a845 1
      string = (char *)xmalloc (l + 5);
a854 4
#if defined (HANDLE_MULTIBYTE)
      memset (&ps, 0, sizeof (mbstate_t));
#endif

a861 13
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      int v;
	      v = _rl_get_char_len (string + i, &ps);
	      if (v > 1)
		{
		  i += v - 1;
		  continue;
		}
	    }
#endif /* HANDLE_MULTIBYTE */

d863 1
a863 1
	  /* The history_comment_char, if set, appearing at the beginning
d868 1
a868 1
	      (i == 0 || member (string[i - 1], history_word_delimiters)))
a925 24
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  int k, c;

	  c = tchar;
	  memset (mb, 0, sizeof (mb));
	  for (k = 0; k < MB_LEN_MAX; k++)
	    {
	      mb[k] = (char)c;
	      memset (&ps, 0, sizeof (mbstate_t));
	      if (_rl_get_char_len (mb, &ps) == -2)
		c = string[++i];
	      else
		break;
	    }
	  if (strlen (mb) > 1)
	    {
	      ADD_STRING (mb);
	      break;
	    }
	}
#endif /* HANDLE_MULTIBYTE */

d954 1
a954 1
		temp = (char *)xmalloc (slen);
d966 1
a966 1
	  if (i == 0 || member (string[i - 1], history_word_delimiters))
d968 1
a968 1
	      temp = (char *)xmalloc (l - i + 1);
d1000 1
a1000 1
		  temp = (char *)xmalloc (1 + strlen (result));
d1134 1
a1134 8
#if 0
      else if (!spec[i] || spec[i] == ':')
	/* check against `:' because there could be a modifier separator */
#else
      else
	/* csh seems to allow anything to terminate the word spec here,
	   leaving it as an abbreviation. */
#endif
d1154 1
a1154 1
     const char *string;
d1190 1
a1190 1
      result = (char *)xmalloc (size + 1);
d1220 1
a1220 1
     const char *string;
a1226 5
  /* If we're searching for a string that's not part of a word (e.g., " "),
     make sure we set *INDP to a reasonable value. */
  if (indp && wind != -1)
    *indp = -1;

d1301 1
a1301 1
	  if (!delimiter && (member (string[i], history_word_delimiters)))
d1318 1
a1318 1
      result[result_index] = (char *)xmalloc (1 + len);
d1331 1
a1331 1
     const char *string;
d1348 1
a1348 1
  if (wind == -1 || words == 0)
@


1.2
log
@Dummy commit before importof 4.1 version
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 1, or (at your option)
d21 1
a21 1
   675 Mass Ave, Cambridge, MA 02139, USA. */
d53 3
d66 2
a67 7
static char *get_history_word_specifier ();
static char *history_find_word ();

extern int history_offset;

extern char *single_quote ();
static char *quote_breaks ();
d69 1
a69 1
extern char *xmalloc (), *xrealloc ();
@


1.1
log
@Initial revision
@
text
@d368 4
a660 9
		/* If there is no lhs, the substitution can't succeed. */
		if (subst_lhs_len == 0)
		  {
		    *ret_string = hist_error (string, starting_index, i, SUBST_FAILED);
		    free (result);
		    free (temp);
		    return -1;
		  }

d671 9
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-08-02 snapshot
@
text
@a367 4
    case NO_PREV_SUBST:
      emsg = "no previous substitution";
      elen = 24;
      break;
d657 9
a675 9

	    /* If there is no lhs, the substitution can't succeed. */
	    if (subst_lhs_len == 0)
	      {
		*ret_string = hist_error (string, starting_index, i, NO_PREV_SUBST);
		free (result);
		free (temp);
		return -1;
	      }
@


1.1.1.3
log
@Import of readline 4.1
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
d21 1
a21 1
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
a52 3
#include "rlshell.h"
#include "xmalloc.h"

d63 7
a69 2
static char *get_history_word_specifier __P((char *, char *, int *));
static char *history_find_word __P((char *, int));
d71 1
a71 1
static char *quote_breaks __P((char *));
@


1.1.1.4
log
@import of readline-4.3
@
text
@d44 5
a48 1
#include "rlmbutil.h"
a58 4
typedef int _hist_search_func_t PARAMS((const char *, int));

extern int rl_byte_oriented;	/* declared in mbutil.c */

d66 2
a67 2
static char *get_history_word_specifier PARAMS((char *, char *, int *));
static char *history_find_word PARAMS((char *, int));
d69 1
a69 1
static char *quote_breaks PARAMS((char *));
a93 3
/* Used to split words by history_tokenize_internal. */
char *history_word_delimiters = HISTORY_WORD_DELIMITERS;

d96 1
a96 1
rl_linebuf_func_t *history_inhibit_expansion_function;
d125 1
a125 1
     const char *string;
d133 1
a133 1
  _hist_search_func_t *search_func;
d202 6
a207 24
#if defined (HANDLE_MULTIBYTE)
    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
      {
	int v;
	mbstate_t ps;

	memset (&ps, 0, sizeof (mbstate_t));
	/* These produce warnings because we're passing a const string to a
	   function that takes a non-const string. */
	_rl_adjust_point (string, i, &ps);
	if ((v = _rl_get_char_len (string + i, &ps)) > 1)
	  {
	    i += v - 1;
	    continue;
	  }
      }
    else
#endif /* HANDLE_MULTIBYTE */
      if ((!substring_okay && (whitespace (c) || c == ':' ||
	  (history_search_delimiter_chars && member (c, history_search_delimiter_chars)) ||
	  string[i] == delimiting_quote)) ||
	  string[i] == '\n' ||
	  (substring_okay && string[i] == '?'))
	break;
d210 1
a210 1
  temp = (char *)xmalloc (1 + which);
d312 1
a312 1
  r = ret = (char *)xmalloc (len);
d343 1
a343 2
  char *temp;
  const char *emsg;
d376 1
a376 1
  temp = (char *)xmalloc (ll + elen + 3);
d402 1
a402 4
  char *s;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
#endif
a403 1
  s = (char *)NULL;
a405 5
#if defined (HANDLE_MULTIBYTE)
  memset (&ps, 0, sizeof (mbstate_t));
  _rl_adjust_point (str, i, &ps);
#endif

d407 2
a408 13
#if defined (HANDLE_MULTIBYTE)
    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
      {
	int v;
	if ((v = _rl_get_char_len (str + si, &ps)) > 1)
	  si += v - 1;
	else if (str[si] == '\\' && str[si + 1] == delimiter)
	  si++;
      }
    else
#endif /* HANDLE_MULTIBYTE */
      if (str[si] == '\\' && str[si + 1] == delimiter)
	si++;
d412 1
a412 1
      s = (char *)xmalloc (si - i + 1);
d439 1
a439 1
  new = (char *)xmalloc (new_size = subst_rhs_len + subst_lhs_len);
d445 1
a445 1
	    new = (char *)xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));
d455 1
a455 1
	    new = (char *)xrealloc (new, new_size *= 2);
a480 5
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;

  memset (&ps, 0, sizeof (mbstate_t));
#endif
d482 1
a482 1
  result = (char *)xmalloc (result_len = 128);
d511 2
a512 15
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  int c, l;
	  l = _rl_find_prev_mbchar (string, i, MB_FIND_ANY);
	  c = string[l];
	  /* XXX - original patch had i - 1 ???  If i == 0 it would fail. */
	  if (i && (c == '\'' || c == '"'))
	    quoted_search_delimiter = c;
	}
      else
#endif /* HANDLE_MULTIBYTE */	  
	if (i && (string[i - 1] == '\'' || string[i - 1] == '"'))
	  quoted_search_delimiter = string[i - 1];

d625 1
a625 1
	    char *new_event;
d631 1
a631 14
		  {
#if defined (HANDLE_MULTIBYTE)
		    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		      {
			_rl_adjust_point (string, i + 2, &ps);
			if (_rl_get_char_len (string + i + 2, &ps) > 1)
			  delimiter = 0;
			else
			  delimiter = string[i + 2];
		      }
		    else
#endif /* HANDLE_MULTIBYTE */
		      delimiter = string[i + 2];
		  }
d695 1
a695 1
		  new_event = (char *)xmalloc (1 + len);
d744 1
a744 1
	x = sh_single_quote (temp);
d756 1
a756 1
    result = (char *)xrealloc (result, n + 2);
d787 1
a787 1
		result = (char *)xrealloc (result, result_len); \
d797 1
a797 1
	      result = (char *)xrealloc (result, result_len += 64); \
a815 5
#if defined (HANDLE_MULTIBYTE)
  char mb[MB_LEN_MAX];
  mbstate_t ps;
#endif

a818 3
  if (output == 0)
    return 0;

d828 1
a828 1
  result = (char *)xmalloc (result_len = 256);
d845 1
a845 1
      string = (char *)xmalloc (l + 5);
a854 4
#if defined (HANDLE_MULTIBYTE)
      memset (&ps, 0, sizeof (mbstate_t));
#endif

a861 13
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      int v;
	      v = _rl_get_char_len (string + i, &ps);
	      if (v > 1)
		{
		  i += v - 1;
		  continue;
		}
	    }
#endif /* HANDLE_MULTIBYTE */

d863 1
a863 1
	  /* The history_comment_char, if set, appearing at the beginning
d868 1
a868 1
	      (i == 0 || member (string[i - 1], history_word_delimiters)))
a925 24
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  int k, c;

	  c = tchar;
	  memset (mb, 0, sizeof (mb));
	  for (k = 0; k < MB_LEN_MAX; k++)
	    {
	      mb[k] = (char)c;
	      memset (&ps, 0, sizeof (mbstate_t));
	      if (_rl_get_char_len (mb, &ps) == -2)
		c = string[++i];
	      else
		break;
	    }
	  if (strlen (mb) > 1)
	    {
	      ADD_STRING (mb);
	      break;
	    }
	}
#endif /* HANDLE_MULTIBYTE */

d954 1
a954 1
		temp = (char *)xmalloc (slen);
d966 1
a966 1
	  if (i == 0 || member (string[i - 1], history_word_delimiters))
d968 1
a968 1
	      temp = (char *)xmalloc (l - i + 1);
d1000 1
a1000 1
		  temp = (char *)xmalloc (1 + strlen (result));
d1134 1
a1134 8
#if 0
      else if (!spec[i] || spec[i] == ':')
	/* check against `:' because there could be a modifier separator */
#else
      else
	/* csh seems to allow anything to terminate the word spec here,
	   leaving it as an abbreviation. */
#endif
d1154 1
a1154 1
     const char *string;
d1190 1
a1190 1
      result = (char *)xmalloc (size + 1);
d1220 1
a1220 1
     const char *string;
a1226 5
  /* If we're searching for a string that's not part of a word (e.g., " "),
     make sure we set *INDP to a reasonable value. */
  if (indp && wind != -1)
    *indp = -1;

d1301 1
a1301 1
	  if (!delimiter && (member (string[i], history_word_delimiters)))
d1318 1
a1318 1
      result[result_index] = (char *)xmalloc (1 + len);
d1331 1
a1331 1
     const char *string;
d1348 1
a1348 1
  if (wind == -1 || words == 0)
@


1.1.1.5
log
@import of readlilne 5.1
@
text
@d3 1
a3 1
/* Copyright (C) 1989-2004 Free Software Foundation, Inc.
a54 2
#define slashify_in_quotes "\\`\"$"

a67 2
static int history_tokenize_word PARAMS((const char *, int));
static char *history_substring PARAMS((const char *, int, int));
a204 1
    {
d206 4
a209 15
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  int v;
	  mbstate_t ps;

	  memset (&ps, 0, sizeof (mbstate_t));
	  /* These produce warnings because we're passing a const string to a
	     function that takes a non-const string. */
	  _rl_adjust_point ((char *)string, i, &ps);
	  if ((v = _rl_get_char_len ((char *)string + i, &ps)) > 1)
	    {
	      i += v - 1;
	      continue;
	    }
        }
d211 11
a228 1
    }
d520 1
a520 1
  int substitute_globally, subst_bywords, want_quotes, print_only;
d602 1
a602 1
  want_quotes = substitute_globally = subst_bywords = print_only = 0;
d609 1
a609 1
      if (c == 'g' || c == 'a')
a614 6
      else if (c == 'G')
	{
	  subst_bywords = 1;
	  i++;
	  c = string[i + 1];
	}
d686 1
a686 1
	    int delimiter, failed, si, l_temp, ws, we;
d763 1
a763 13
	    /* Substitute SUBST_RHS for SUBST_LHS in TEMP.  There are three
	       cases to consider:

		 1.  substitute_globally == subst_bywords == 0
		 2.  substitute_globally == 1 && subst_bywords == 0
		 3.  substitute_globally == 0 && subst_bywords == 1

	       In the first case, we substitute for the first occurrence only.
	       In the second case, we substitute for every occurrence.
	       In the third case, we tokenize into words and substitute the
	       first occurrence of each word. */

	    si = we = 0;
d765 12
a776 11
	      {
		/* First skip whitespace and find word boundaries if
		   we're past the end of the word boundary we found
		   the last time. */
		if (subst_bywords && si > we)
		  {
		    for (; temp[si] && whitespace (temp[si]); si++)
		      ;
		    ws = si;
		    we = history_tokenize_word (temp, si);
		  }
d778 1
a778 12
		if (STREQN (temp+si, subst_lhs, subst_lhs_len))
		  {
		    int len = subst_rhs_len - subst_lhs_len + l_temp;
		    new_event = (char *)xmalloc (1 + len);
		    strncpy (new_event, temp, si);
		    strncpy (new_event + si, subst_rhs, subst_rhs_len);
		    strncpy (new_event + si + subst_rhs_len,
			     temp + si + subst_lhs_len,
			     l_temp - (si + subst_lhs_len));
		    new_event[len] = '\0';
		    free (temp);
		    temp = new_event;
d780 10
a789 22
		    failed = 0;

		    if (substitute_globally)
		      {
			/* Reported to fix a bug that causes it to skip every
			   other match when matching a single character.  Was
			   si += subst_rhs_len previously. */
			si += subst_rhs_len - 1;
			l_temp = strlen (temp);
			substitute_globally++;
			continue;
		      }
		    else if (subst_bywords)
		      {
			si = we;
			l_temp = strlen (temp);
			continue;
		      }
		    else
		      break;
		  }
	      }
d882 1
a882 1
  int i, r, l, passc, cc, modified, eindex, only_printing, dquote;
d945 1
a945 1
      for (i = dquote = 0; string[i]; i++)
d987 3
a989 13
	  /* Shell-like quoting: allow backslashes to quote double quotes
	     inside a double-quoted string. */
	  else if (dquote && string[i] == '\\' && cc == '"')
	    i++;
	  /* More shell-like quoting:  if we're paying attention to single
	     quotes and letting them quote the history expansion character,
	     then we need to pay attention to double quotes, because single
	     quotes are not special inside double-quoted strings. */
	  else if (history_quotes_inhibit_expansion && string[i] == '"')
	    {
	      dquote = 1 - dquote;
	    }
	  else if (dquote == 0 && history_quotes_inhibit_expansion && string[i] == '\'')
a1001 1
	  
d1013 1
a1013 1
  for (passc = dquote = i = j = 0; i < l; i++)
a1063 5
	case '"':
	  dquote = 1 - dquote;
	  ADD_CHAR (tchar);
	  break;
	  
d1068 1
a1068 1
	    if (dquote == 0 && history_quotes_inhibit_expansion)
a1162 1
#if 0
a1163 1
#endif
d1226 1
a1226 4
    {
      first = 1;
      i++;
    }
d1341 1
a1341 97
static int
history_tokenize_word (string, ind)
     const char *string;
     int ind;
{
  register int i;
  int delimiter;

  i = ind;
  delimiter = 0;

  if (member (string[i], "()\n"))
    {
      i++;
      return i;
    }

  if (member (string[i], "<>;&|$"))
    {
      int peek = string[i + 1];

      if (peek == string[i] && peek != '$')
	{
	  if (peek == '<' && string[i + 2] == '-')
	    i++;
	  i += 2;
	  return i;
	}
      else
	{
	  if ((peek == '&' && (string[i] == '>' || string[i] == '<')) ||
	      (peek == '>' && string[i] == '&') ||
	      (peek == '(' && (string[i] == '>' || string[i] == '<')) || /* ) */
	      (peek == '(' && string[i] == '$')) /* ) */
	    {
	      i += 2;
	      return i;
	    }
	}

      if (string[i] != '$')
	{
	  i++;
	  return i;
	}
    }

  /* Get word from string + i; */

  if (member (string[i], HISTORY_QUOTE_CHARACTERS))
    delimiter = string[i++];

  for (; string[i]; i++)
    {
      if (string[i] == '\\' && string[i + 1] == '\n')
	{
	  i++;
	  continue;
	}

      if (string[i] == '\\' && delimiter != '\'' &&
	  (delimiter != '"' || member (string[i], slashify_in_quotes)))
	{
	  i++;
	  continue;
	}

      if (delimiter && string[i] == delimiter)
	{
	  delimiter = 0;
	  continue;
	}

      if (!delimiter && (member (string[i], history_word_delimiters)))
	break;

      if (!delimiter && member (string[i], HISTORY_QUOTE_CHARACTERS))
	delimiter = string[i];
    }

  return i;
}

static char *
history_substring (string, start, end)
     const char *string;
     int start, end;
{
  register int len;
  register char *result;

  len = end - start;
  result = (char *)xmalloc (len + 1);
  strncpy (result, string + start, len);
  result[len] = '\0';
  return result;
}
d1354 1
d1365 2
d1374 6
d1381 3
a1383 1
      i = history_tokenize_word (string, start);
d1385 30
a1414 5
      /* If we have a non-whitespace delimiter character (which would not be
	 skipped by the loop above), use it and any adjacent delimiters to
	 make a separate field.  Any adjacent white space will be skipped the
	 next time through the loop. */
      if (i == start && history_word_delimiters)
d1416 24
a1439 3
	  i++;
	  while (string[i] && member (string[i], history_word_delimiters))
	    i++;
d1442 2
d1449 1
d1452 4
a1455 3

      result[result_index++] = history_substring (string, start, i);
      result[result_index] = (char *)NULL;
@


