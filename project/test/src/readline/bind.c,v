head	1.10;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.10
	gdb_7_6-2013-04-26-release:1.10
	gdb_7_6-branch:1.10.0.6
	gdb_7_6-2013-03-12-branchpoint:1.10
	gdb_7_5_1-2012-11-29-release:1.10
	gdb_7_5-2012-08-17-release:1.10
	gdb_7_5-branch:1.10.0.4
	gdb_7_5-2012-07-18-branchpoint:1.10
	gdb_7_4_1-2012-04-26-release:1.10
	gdb_7_4-2012-01-24-release:1.10
	gdb_7_4-branch:1.10.0.2
	gdb_7_4-2011-12-13-branchpoint:1.10
	gdb_7_3_1-2011-09-04-release:1.9
	gdb_7_3-2011-07-26-release:1.9
	gdb_7_3-branch:1.9.0.2
	gdb_7_3-2011-04-01-branchpoint:1.9
	gdb_7_2-2010-09-02-release:1.8
	gdb_7_2-branch:1.8.0.34
	gdb_7_2-2010-07-07-branchpoint:1.8
	gdb_7_1-2010-03-18-release:1.8
	gdb_7_1-branch:1.8.0.32
	gdb_7_1-2010-02-18-branchpoint:1.8
	gdb_7_0_1-2009-12-22-release:1.8
	gdb_7_0-2009-10-06-release:1.8
	gdb_7_0-branch:1.8.0.30
	gdb_7_0-2009-09-16-branchpoint:1.8
	arc-sim-20090309:1.8
	msnyder-checkpoint-072509-branch:1.8.0.28
	msnyder-checkpoint-072509-branchpoint:1.8
	arc-insight_6_8-branch:1.8.0.26
	arc-insight_6_8-branchpoint:1.8
	insight_6_8-branch:1.8.0.24
	insight_6_8-branchpoint:1.8
	reverse-20081226-branch:1.8.0.22
	reverse-20081226-branchpoint:1.8
	multiprocess-20081120-branch:1.8.0.20
	multiprocess-20081120-branchpoint:1.8
	reverse-20080930-branch:1.8.0.18
	reverse-20080930-branchpoint:1.8
	reverse-20080717-branch:1.8.0.16
	reverse-20080717-branchpoint:1.8
	msnyder-reverse-20080609-branch:1.8.0.14
	msnyder-reverse-20080609-branchpoint:1.8
	drow-reverse-20070409-branch:1.8.0.12
	drow-reverse-20070409-branchpoint:1.8
	gdb_6_8-2008-03-27-release:1.8
	gdb_6_8-branch:1.8.0.10
	gdb_6_8-2008-02-26-branchpoint:1.8
	gdb_6_7_1-2007-10-29-release:1.8
	gdb_6_7-2007-10-10-release:1.8
	gdb_6_7-branch:1.8.0.8
	gdb_6_7-2007-09-07-branchpoint:1.8
	insight_6_6-20070208-release:1.8
	gdb_6_6-2006-12-18-release:1.8
	gdb_6_6-branch:1.8.0.6
	gdb_6_6-2006-11-15-branchpoint:1.8
	insight_6_5-20061003-release:1.8
	gdb-csl-symbian-6_4_50_20060226-12:1.6
	gdb-csl-sourcerygxx-3_4_4-25:1.6
	nickrob-async-20060828-mergepoint:1.8
	gdb-csl-symbian-6_4_50_20060226-11:1.6
	gdb-csl-sourcerygxx-4_1-17:1.6
	gdb-csl-20060226-branch-local-2:1.6
	gdb-csl-sourcerygxx-4_1-14:1.6
	gdb-csl-sourcerygxx-4_1-13:1.6
	gdb-csl-sourcerygxx-4_1-12:1.6
	gdb-csl-sourcerygxx-3_4_4-21:1.6
	gdb_6_5-20060621-release:1.8
	gdb-csl-sourcerygxx-4_1-9:1.6
	gdb-csl-sourcerygxx-4_1-8:1.6
	gdb-csl-sourcerygxx-4_1-7:1.6
	gdb-csl-arm-2006q1-6:1.6
	gdb-csl-sourcerygxx-4_1-6:1.6
	gdb-csl-symbian-6_4_50_20060226-10:1.6
	gdb-csl-symbian-6_4_50_20060226-9:1.6
	gdb-csl-symbian-6_4_50_20060226-8:1.6
	gdb-csl-coldfire-4_1-11:1.6
	gdb-csl-sourcerygxx-3_4_4-19:1.6
	gdb-csl-coldfire-4_1-10:1.6
	gdb_6_5-branch:1.8.0.4
	gdb_6_5-2006-05-14-branchpoint:1.8
	gdb-csl-sourcerygxx-4_1-5:1.6
	nickrob-async-20060513-branch:1.8.0.2
	nickrob-async-20060513-branchpoint:1.8
	gdb-csl-sourcerygxx-4_1-4:1.6
	msnyder-reverse-20060502-branch:1.7.0.4
	msnyder-reverse-20060502-branchpoint:1.7
	gdb-csl-morpho-4_1-4:1.6
	gdb-csl-sourcerygxx-3_4_4-17:1.6
	readline_5_1-import-branch:1.7.0.2
	readline_5_1-import-branchpoint:1.7
	readline-pre-51-import:1.7
	readline_5_1:1.1.1.5
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.6
	gdb-csl-symbian-20060226-branch:1.6.0.36
	gdb-csl-symbian-20060226-branchpoint:1.6
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.6
	msnyder-reverse-20060331-branch:1.6.0.34
	msnyder-reverse-20060331-branchpoint:1.6
	gdb-csl-available-20060303-branch:1.6.0.32
	gdb-csl-available-20060303-branchpoint:1.6
	gdb-csl-20060226-branch:1.6.0.30
	gdb-csl-20060226-branchpoint:1.6
	gdb_6_4-20051202-release:1.6
	msnyder-fork-checkpoint-branch:1.6.0.28
	msnyder-fork-checkpoint-branchpoint:1.6
	gdb-csl-gxxpro-6_3-branch:1.6.0.26
	gdb-csl-gxxpro-6_3-branchpoint:1.6
	gdb_6_4-branch:1.6.0.24
	gdb_6_4-2005-11-01-branchpoint:1.6
	gdb-csl-arm-20051020-branch:1.6.0.22
	gdb-csl-arm-20051020-branchpoint:1.6
	msnyder-tracepoint-checkpoint-branch:1.6.0.20
	msnyder-tracepoint-checkpoint-branchpoint:1.6
	gdb-csl-arm-20050325-2005-q1b:1.6
	gdb-csl-arm-20050325-2005-q1a:1.6
	csl-arm-20050325-branch:1.6.0.18
	csl-arm-20050325-branchpoint:1.6
	gdb_6_3-20041109-release:1.6
	gdb_6_3-branch:1.6.0.14
	gdb_6_3-20041019-branchpoint:1.6
	drow_intercu-merge-20040921:1.6
	drow_intercu-merge-20040915:1.6
	jimb-gdb_6_2-e500-branch:1.6.0.16
	jimb-gdb_6_2-e500-branchpoint:1.6
	gdb_6_2-20040730-release:1.6
	gdb_6_2-branch:1.6.0.12
	gdb_6_2-2004-07-10-gmt-branchpoint:1.6
	gdb_6_1_1-20040616-release:1.6
	gdb_6_1-2004-04-05-release:1.6
	drow_intercu-merge-20040402:1.6
	drow_intercu-merge-20040327:1.6
	ezannoni_pie-20040323-branch:1.6.0.10
	ezannoni_pie-20040323-branchpoint:1.6
	cagney_tramp-20040321-mergepoint:1.6
	cagney_tramp-20040309-branch:1.6.0.8
	cagney_tramp-20040309-branchpoint:1.6
	gdb_6_1-branch:1.6.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	drow_intercu-20040221-branch:1.6.0.4
	drow_intercu-20040221-branchpoint:1.6
	cagney_bfdfile-20040213-branch:1.6.0.2
	cagney_bfdfile-20040213-branchpoint:1.6
	drow-cplus-merge-20040208:1.6
	carlton_dictionary-20040126-merge:1.5
	cagney_bigcore-20040122-branch:1.5.0.42
	cagney_bigcore-20040122-branchpoint:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	kettenis_sparc-20030918-branch:1.5.0.40
	kettenis_sparc-20030918-branchpoint:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.38
	cagney_x86i386-20030821-branch:1.5.0.36
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.34
	gdb_6_0-2003-06-23-branchpoint:1.5
	jimb-ppc64-linux-20030613-branch:1.5.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.30
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.28
	cagney_writestrings-20030508-branchpoint:1.5
	jimb-ppc64-linux-20030528-branch:1.5.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.24
	cagney_fileio-20030521-branchpoint:1.5
	kettenis_i386newframe-20030517-mergepoint:1.5
	jimb-ppc64-linux-20030509-branch:1.5.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.5
	kettenis_i386newframe-20030504-mergepoint:1.5
	carlton_dictionary-20030430-merge:1.5
	kettenis_i386newframe-20030419-branch:1.5.0.20
	kettenis_i386newframe-20030419-branchpoint:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	kettenis_i386newframe-20030406-branch:1.5.0.18
	kettenis_i386newframe-20030406-branchpoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.16
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.14
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.12
	cagney_lazyid-20030317-branchpoint:1.5
	kettenis-i386newframe-20030316-mergepoint:1.5
	offbyone-20030313-branch:1.5.0.10
	offbyone-20030313-branchpoint:1.5
	kettenis-i386newframe-20030308-branch:1.5.0.8
	kettenis-i386newframe-20030308-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.6
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.4
	interps-20030202-branchpoint:1.5
	cagney-unwind-20030108-branch:1.5.0.2
	cagney-unwind-20030108-branchpoint:1.5
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.4
	readline-pre-43-import:1.4
	carlton_dictionary-20021115-merge:1.4
	kseitz_interps-20021105-merge:1.4
	kseitz_interps-20021103-merge:1.4
	drow-cplus-merge-20021020:1.4
	drow-cplus-merge-20021025:1.4
	carlton_dictionary-20021025-merge:1.4
	carlton_dictionary-20021011-merge:1.4
	drow-cplus-branch:1.4.0.24
	drow-cplus-branchpoint:1.4
	kseitz_interps-20020930-merge:1.4
	carlton_dictionary-20020927-merge:1.4
	carlton_dictionary-branch:1.4.0.22
	carlton_dictionary-20020920-branchpoint:1.4
	gdb_5_3-branch:1.4.0.20
	gdb_5_3-2002-09-04-branchpoint:1.4
	kseitz_interps-20020829-merge:1.4
	cagney_sysregs-20020825-branch:1.4.0.18
	cagney_sysregs-20020825-branchpoint:1.4
	readline_4_3-import-branch:1.4.0.16
	readline_4_3-import-branchpoint:1.4
	readline_4_3:1.1.1.4
	gdb_5_2_1-2002-07-23-release:1.4
	kseitz_interps-20020528-branch:1.4.0.14
	kseitz_interps-20020528-branchpoint:1.4
	cagney_regbuf-20020515-branch:1.4.0.12
	cagney_regbuf-20020515-branchpoint:1.4
	jimb-macro-020506-branch:1.4.0.10
	jimb-macro-020506-branchpoint:1.4
	gdb_5_2-2002-04-29-release:1.4
	gdb_5_2-branch:1.4.0.8
	gdb_5_2-2002-03-03-branchpoint:1.4
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	insight-precleanup-2001-01-01:1.4
	readline_4_1:1.1.1.3
	readline_4_0:1.1.1.2
	FSF:1.1.1
	readline-pre-41-import:1.3
	gdb-premipsmulti-2000-06-06-branch:1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.10
date	2011.05.11.23.38.39;	author jkratoch;	state Exp;
branches;
next	1.9;

1.9
date	2011.03.04.18.12.47;	author msnyder;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.05.18.26.12;	author drow;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.20.20.13.20;	author ezannoni;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2004.01.27.22.25.15;	author ezannoni;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.08.22.31.37;	author ezannoni;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.09.17.19.55;	author ezannoni;	state Exp;
branches
	1.4.16.1
	1.4.22.1
	1.4.24.1;
next	1.3;

1.3
date	2000.07.07.17.15.45;	author ezannoni;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.15.11.32.18;	author eliz;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.52;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.7.2.1
date	2006.04.24.22.00.25;	author drow;	state Exp;
branches;
next	;

1.4.16.1
date	2002.08.25.23.41.16;	author ezannoni;	state Exp;
branches;
next	;

1.4.22.1
date	2002.12.23.19.39.41;	author carlton;	state Exp;
branches;
next	;

1.4.24.1
date	2003.12.14.20.28.11;	author drow;	state Exp;
branches;
next	1.4.24.2;

1.4.24.2
date	2004.02.09.19.44.02;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.52;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.08.02.23.47.57;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.07.09.16.21.20;	author ezannoni;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.08.23.22.02.27;	author ezannoni;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.20.20.05.35;	author ezannoni;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Imported readline 6.2, and upstream patch 001.

[patch 0/3] readline-6.2 rebase
http://sourceware.org/ml/gdb-patches/2011-05/msg00003.html
[patch 1/3] readline-6.2: Merge of already posted patches
http://sourceware.org/ml/gdb-patches/2011-05/msg00004.html
	=
	[Bug-readline] [RFC/readline] bind.c, rl_function_dumper, Free allocated
	http://lists.gnu.org/archive/html/bug-readline/2011-03/msg00000.html
	[Bug-readline] [patch] Fix underquotation in readline/examples/rlfe/conf
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00001.html
	[Bug-readline] [patch] Makefile.in htm<->html
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00002.html
	Re: [Bug-readline] [patch] Makefile.in dependency: callback.o: xmalloc.h
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00004.html
	[Bug-readline] [patch] Remove . from the VPATH directive
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00005.html
	Eli Zaretskii's __MSDOS__ / __GO32__ / __MINGW32__ / __DJGPP__ stuff:
	http://sourceware.org/ml/gdb/2011-04/msg00002.html
	Jan Kratochvil's patch for FSF GDB tree local-specific changes:
	http://sourceware.org/ml/gdb/2011-04/msg00006.html
	Preservation of existing ChangeLog.gdb files, their updates.
[patch 2/3] readline-6.2: Workaround "ask" regression
http://sourceware.org/ml/gdb-patches/2011-05/msg00005.html
[patch 3/3] readline-6.2: Revert 5.x compat., apply 6.x compat.
http://sourceware.org/ml/gdb-patches/2011-05/msg00006.html
[patch 4/3] readline-6.2: Substitute inc-hist.texinfo
http://sourceware.org/ml/gdb-patches/2011-05/msg00010.html

readline/
	Workaround gdb.base/completion.exp regression on readline-6.2.
	* complete.c (get_y_or_n): Disable the return on RL_STATE_CALLBACK.

	Imported readline 6.2, and upstream patch 001.
	* configure: Regenerate.

readline/doc/
	* hsuser.texi (Using History Interactively): Disable !BashFeatures
	@@defcodeindex.  Make the `Programming with GNU History' reference
	external.
	* inc-hist.texinfo: Remove.

	Imported readline 6.2, and upstream patch 001.

readline/examples/
	Imported readline 6.2, and upstream patch 001.

readline/examples/rlfe/
	Imported readline 6.2, and upstream patch 001.

gdb/
	* config.in: Regenerate.
	* configure: Regenerate.
	* configure.ac <--with-system-readline> (for readline_echoing_p):
	Remove the test.
	* tui/tui-io.c (tui_old_readline_echoing_p): Rename to ...
	(tui_old_rl_echoing_p): ... here.
	(tui_setup_io): Rename extern declaration readline_echoing_p to
	_rl_echoing_p.  Adjust assignments for the both renames.

gdb/doc/
	* Makefile.in (GDB_DOC_SOURCE_INCLUDES): Rename inc-hist.texinfo to
	hsuser.texi.
	* gdb.texinfo <!SYSTEM_READLINE>: Rename inc-hist.texinfo inclusion and
	comment to hsuser.texi.  Change rluser.texi name in the comment.
@
text
@/* bind.c -- key binding and startup file support for the readline library. */

/* Copyright (C) 1987-2010 Free Software Foundation, Inc.

   This file is part of the GNU Readline Library (Readline), a library
   for reading lines of text with interactive input and history editing.

   Readline is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Readline is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Readline.  If not, see <http://www.gnu.org/licenses/>.
*/

#define READLINE_LIBRARY

#if defined (__TANDEM)
#  include <floss.h>
#endif

#if defined (HAVE_CONFIG_H)
#  include <config.h>
#endif

#include <stdio.h>
#include <sys/types.h>
#include <fcntl.h>
#if defined (HAVE_SYS_FILE_H)
#  include <sys/file.h>
#endif /* HAVE_SYS_FILE_H */

#if defined (HAVE_UNISTD_H)
#  include <unistd.h>
#endif /* HAVE_UNISTD_H */

#if defined (HAVE_STDLIB_H)
#  include <stdlib.h>
#else
#  include "ansi_stdlib.h"
#endif /* HAVE_STDLIB_H */

#include <errno.h>

#if !defined (errno)
extern int errno;
#endif /* !errno */

#include "posixstat.h"

/* System-specific feature definitions and include files. */
#include "rldefs.h"

/* Some standard library routines. */
#include "readline.h"
#include "history.h"

#include "rlprivate.h"
#include "rlshell.h"
#include "xmalloc.h"

#if !defined (strchr) && !defined (__STDC__)
extern char *strchr (), *strrchr ();
#endif /* !strchr && !__STDC__ */

/* Variables exported by this file. */
Keymap rl_binding_keymap;

static char *_rl_read_file PARAMS((char *, size_t *));
static void _rl_init_file_error PARAMS((const char *));
static int _rl_read_init_file PARAMS((const char *, int));
static int glean_key_from_name PARAMS((char *));
static int find_boolean_var PARAMS((const char *));

static char *_rl_get_string_variable_value PARAMS((const char *));
static int substring_member_of_array PARAMS((const char *, const char * const *));

static int currently_reading_init_file;

/* used only in this file */
static int _rl_prefer_visible_bell = 1;

/* **************************************************************** */
/*								    */
/*			Binding keys				    */
/*								    */
/* **************************************************************** */

/* rl_add_defun (char *name, rl_command_func_t *function, int key)
   Add NAME to the list of named functions.  Make FUNCTION be the function
   that gets called.  If KEY is not -1, then bind it. */
int
rl_add_defun (name, function, key)
     const char *name;
     rl_command_func_t *function;
     int key;
{
  if (key != -1)
    rl_bind_key (key, function);
  rl_add_funmap_entry (name, function);
  return 0;
}

/* Bind KEY to FUNCTION.  Returns non-zero if KEY is out of range. */
int
rl_bind_key (key, function)
     int key;
     rl_command_func_t *function;
{
  if (key < 0)
    return (key);

  if (META_CHAR (key) && _rl_convert_meta_chars_to_ascii)
    {
      if (_rl_keymap[ESC].type == ISKMAP)
	{
	  Keymap escmap;

	  escmap = FUNCTION_TO_KEYMAP (_rl_keymap, ESC);
	  key = UNMETA (key);
	  escmap[key].type = ISFUNC;
	  escmap[key].function = function;
	  return (0);
	}
      return (key);
    }

  _rl_keymap[key].type = ISFUNC;
  _rl_keymap[key].function = function;
  rl_binding_keymap = _rl_keymap;
  return (0);
}

/* Bind KEY to FUNCTION in MAP.  Returns non-zero in case of invalid
   KEY. */
int
rl_bind_key_in_map (key, function, map)
     int key;
     rl_command_func_t *function;
     Keymap map;
{
  int result;
  Keymap oldmap;

  oldmap = _rl_keymap;
  _rl_keymap = map;
  result = rl_bind_key (key, function);
  _rl_keymap = oldmap;
  return (result);
}

/* Bind key sequence KEYSEQ to DEFAULT_FUNC if KEYSEQ is unbound.  Right
   now, this is always used to attempt to bind the arrow keys, hence the
   check for rl_vi_movement_mode. */
int
rl_bind_key_if_unbound_in_map (key, default_func, kmap)
     int key;
     rl_command_func_t *default_func;
     Keymap kmap;
{
  char keyseq[2];

  keyseq[0] = (unsigned char)key;
  keyseq[1] = '\0';
  return (rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, kmap));
}

int
rl_bind_key_if_unbound (key, default_func)
     int key;
     rl_command_func_t *default_func;
{
  char keyseq[2];

  keyseq[0] = (unsigned char)key;
  keyseq[1] = '\0';
  return (rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, _rl_keymap));
}

/* Make KEY do nothing in the currently selected keymap.
   Returns non-zero in case of error. */
int
rl_unbind_key (key)
     int key;
{
  return (rl_bind_key (key, (rl_command_func_t *)NULL));
}

/* Make KEY do nothing in MAP.
   Returns non-zero in case of error. */
int
rl_unbind_key_in_map (key, map)
     int key;
     Keymap map;
{
  return (rl_bind_key_in_map (key, (rl_command_func_t *)NULL, map));
}

/* Unbind all keys bound to FUNCTION in MAP. */
int
rl_unbind_function_in_map (func, map)
     rl_command_func_t *func;
     Keymap map;
{
  register int i, rval;

  for (i = rval = 0; i < KEYMAP_SIZE; i++)
    {
      if (map[i].type == ISFUNC && map[i].function == func)
	{
	  map[i].function = (rl_command_func_t *)NULL;
	  rval = 1;
	}
    }
  return rval;
}

int
rl_unbind_command_in_map (command, map)
     const char *command;
     Keymap map;
{
  rl_command_func_t *func;

  func = rl_named_function (command);
  if (func == 0)
    return 0;
  return (rl_unbind_function_in_map (func, map));
}

/* Bind the key sequence represented by the string KEYSEQ to
   FUNCTION, starting in the current keymap.  This makes new
   keymaps as necessary. */
int
rl_bind_keyseq (keyseq, function)
     const char *keyseq;
     rl_command_func_t *function;
{
  return (rl_generic_bind (ISFUNC, keyseq, (char *)function, _rl_keymap));
}

/* Bind the key sequence represented by the string KEYSEQ to
   FUNCTION.  This makes new keymaps as necessary.  The initial
   place to do bindings is in MAP. */
int
rl_bind_keyseq_in_map (keyseq, function, map)
     const char *keyseq;
     rl_command_func_t *function;
     Keymap map;
{
  return (rl_generic_bind (ISFUNC, keyseq, (char *)function, map));
}

/* Backwards compatibility; equivalent to rl_bind_keyseq_in_map() */
int
rl_set_key (keyseq, function, map)
     const char *keyseq;
     rl_command_func_t *function;
     Keymap map;
{
  return (rl_generic_bind (ISFUNC, keyseq, (char *)function, map));
}

/* Bind key sequence KEYSEQ to DEFAULT_FUNC if KEYSEQ is unbound.  Right
   now, this is always used to attempt to bind the arrow keys, hence the
   check for rl_vi_movement_mode. */
int
rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, kmap)
     const char *keyseq;
     rl_command_func_t *default_func;
     Keymap kmap;
{
  rl_command_func_t *func;

  if (keyseq)
    {
      func = rl_function_of_keyseq (keyseq, kmap, (int *)NULL);
#if defined (VI_MODE)
      if (!func || func == rl_do_lowercase_version || func == rl_vi_movement_mode)
#else
      if (!func || func == rl_do_lowercase_version)
#endif
	return (rl_bind_keyseq_in_map (keyseq, default_func, kmap));
      else
	return 1;
    }
  return 0;
}

int
rl_bind_keyseq_if_unbound (keyseq, default_func)
     const char *keyseq;
     rl_command_func_t *default_func;
{
  return (rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, _rl_keymap));
}

/* Bind the key sequence represented by the string KEYSEQ to
   the string of characters MACRO.  This makes new keymaps as
   necessary.  The initial place to do bindings is in MAP. */
int
rl_macro_bind (keyseq, macro, map)
     const char *keyseq, *macro;
     Keymap map;
{
  char *macro_keys;
  int macro_keys_len;

  macro_keys = (char *)xmalloc ((2 * strlen (macro)) + 1);

  if (rl_translate_keyseq (macro, macro_keys, &macro_keys_len))
    {
      xfree (macro_keys);
      return -1;
    }
  rl_generic_bind (ISMACR, keyseq, macro_keys, map);
  return 0;
}

/* Bind the key sequence represented by the string KEYSEQ to
   the arbitrary pointer DATA.  TYPE says what kind of data is
   pointed to by DATA, right now this can be a function (ISFUNC),
   a macro (ISMACR), or a keymap (ISKMAP).  This makes new keymaps
   as necessary.  The initial place to do bindings is in MAP. */
int
rl_generic_bind (type, keyseq, data, map)
     int type;
     const char *keyseq;
     char *data;
     Keymap map;
{
  char *keys;
  int keys_len;
  register int i;
  KEYMAP_ENTRY k;

  k.function = 0;

  /* If no keys to bind to, exit right away. */
  if (keyseq == 0 || *keyseq == 0)
    {
      if (type == ISMACR)
	xfree (data);
      return -1;
    }

  keys = (char *)xmalloc (1 + (2 * strlen (keyseq)));

  /* Translate the ASCII representation of KEYSEQ into an array of
     characters.  Stuff the characters into KEYS, and the length of
     KEYS into KEYS_LEN. */
  if (rl_translate_keyseq (keyseq, keys, &keys_len))
    {
      xfree (keys);
      return -1;
    }

  /* Bind keys, making new keymaps as necessary. */
  for (i = 0; i < keys_len; i++)
    {
      unsigned char uc = keys[i];
      int ic;

      ic = uc;
      if (ic < 0 || ic >= KEYMAP_SIZE)
        {
          xfree (keys);
	  return -1;
        }

      if (META_CHAR (ic) && _rl_convert_meta_chars_to_ascii)
	{
	  ic = UNMETA (ic);
	  if (map[ESC].type == ISKMAP)
	    map = FUNCTION_TO_KEYMAP (map, ESC);
	}

      if ((i + 1) < keys_len)
	{
	  if (map[ic].type != ISKMAP)
	    {
	      /* We allow subsequences of keys.  If a keymap is being
		 created that will `shadow' an existing function or macro
		 key binding, we save that keybinding into the ANYOTHERKEY
		 index in the new map.  The dispatch code will look there
		 to find the function to execute if the subsequence is not
		 matched.  ANYOTHERKEY was chosen to be greater than
		 UCHAR_MAX. */
	      k = map[ic];

	      map[ic].type = ISKMAP;
	      map[ic].function = KEYMAP_TO_FUNCTION (rl_make_bare_keymap());
	    }
	  map = FUNCTION_TO_KEYMAP (map, ic);
	  /* The dispatch code will return this function if no matching
	     key sequence is found in the keymap.  This (with a little
	     help from the dispatch code in readline.c) allows `a' to be
	     mapped to something, `abc' to be mapped to something else,
	     and the function bound  to `a' to be executed when the user
	     types `abx', leaving `bx' in the input queue. */
	  if (k.function && ((k.type == ISFUNC && k.function != rl_do_lowercase_version) || k.type == ISMACR))
	    {
	      map[ANYOTHERKEY] = k;
	      k.function = 0;
	    }
	}
      else
	{
	  if (map[ic].type == ISMACR)
	    xfree ((char *)map[ic].function);
	  else if (map[ic].type == ISKMAP)
	    {
	      map = FUNCTION_TO_KEYMAP (map, ic);
	      ic = ANYOTHERKEY;
	      /* If we're trying to override a keymap with a null function
		 (e.g., trying to unbind it), we can't use a null pointer
		 here because that's indistinguishable from having not been
		 overridden.  We use a special bindable function that does
		 nothing. */
	      if (type == ISFUNC && data == 0)
		data = (char *)_rl_null_function;
	    }

	  map[ic].function = KEYMAP_TO_FUNCTION (data);
	  map[ic].type = type;
	}

      rl_binding_keymap = map;
    }
  xfree (keys);
  return 0;
}

/* Translate the ASCII representation of SEQ, stuffing the values into ARRAY,
   an array of characters.  LEN gets the final length of ARRAY.  Return
   non-zero if there was an error parsing SEQ. */
int
rl_translate_keyseq (seq, array, len)
     const char *seq;
     char *array;
     int *len;
{
  register int i, c, l, temp;

  for (i = l = 0; c = seq[i]; i++)
    {
      if (c == '\\')
	{
	  c = seq[++i];

	  if (c == 0)
	    break;

	  /* Handle \C- and \M- prefixes. */
	  if ((c == 'C' || c == 'M') && seq[i + 1] == '-')
	    {
	      /* Handle special case of backwards define. */
	      if (strncmp (&seq[i], "C-\\M-", 5) == 0)
		{
		  array[l++] = ESC;	/* ESC is meta-prefix */
		  i += 5;
		  array[l++] = CTRL (_rl_to_upper (seq[i]));
		  if (seq[i] == '\0')
		    i--;
		}
	      else if (c == 'M')
		{
		  i++;		/* seq[i] == '-' */
		  /* XXX - obey convert-meta setting */
		  if (_rl_convert_meta_chars_to_ascii && _rl_keymap[ESC].type == ISKMAP)
		    array[l++] = ESC;	/* ESC is meta-prefix */
		  else if (seq[i+1] == '\\' && seq[i+2] == 'C' && seq[i+3] == '-')
		    {
		      i += 4;
		      temp = (seq[i] == '?') ? RUBOUT : CTRL (_rl_to_upper (seq[i]));
		      array[l++] = META (temp);
		    }
		  else
		    {
		      /* This doesn't yet handle things like \M-\a, which may
			 or may not have any reasonable meaning.  You're
			 probably better off using straight octal or hex. */
		      i++;
		      array[l++] = META (seq[i]);
		    }
		}
	      else if (c == 'C')
		{
		  i += 2;
		  /* Special hack for C-?... */
		  array[l++] = (seq[i] == '?') ? RUBOUT : CTRL (_rl_to_upper (seq[i]));
		}
	      continue;
	    }	      

	  /* Translate other backslash-escaped characters.  These are the
	     same escape sequences that bash's `echo' and `printf' builtins
	     handle, with the addition of \d -> RUBOUT.  A backslash
	     preceding a character that is not special is stripped. */
	  switch (c)
	    {
	    case 'a':
	      array[l++] = '\007';
	      break;
	    case 'b':
	      array[l++] = '\b';
	      break;
	    case 'd':
	      array[l++] = RUBOUT;	/* readline-specific */
	      break;
	    case 'e':
	      array[l++] = ESC;
	      break;
	    case 'f':
	      array[l++] = '\f';
	      break;
	    case 'n':
	      array[l++] = NEWLINE;
	      break;
	    case 'r':
	      array[l++] = RETURN;
	      break;
	    case 't':
	      array[l++] = TAB;
	      break;
	    case 'v':
	      array[l++] = 0x0B;
	      break;
	    case '\\':
	      array[l++] = '\\';
	      break;
	    case '0': case '1': case '2': case '3':
	    case '4': case '5': case '6': case '7':
	      i++;
	      for (temp = 2, c -= '0'; ISOCTAL (seq[i]) && temp--; i++)
	        c = (c * 8) + OCTVALUE (seq[i]);
	      i--;	/* auto-increment in for loop */
	      array[l++] = c & largest_char;
	      break;
	    case 'x':
	      i++;
	      for (temp = 2, c = 0; ISXDIGIT ((unsigned char)seq[i]) && temp--; i++)
	        c = (c * 16) + HEXVALUE (seq[i]);
	      if (temp == 2)
	        c = 'x';
	      i--;	/* auto-increment in for loop */
	      array[l++] = c & largest_char;
	      break;
	    default:	/* backslashes before non-special chars just add the char */
	      array[l++] = c;
	      break;	/* the backslash is stripped */
	    }
	  continue;
	}

      array[l++] = c;
    }

  *len = l;
  array[l] = '\0';
  return (0);
}

char *
rl_untranslate_keyseq (seq)
     int seq;
{
  static char kseq[16];
  int i, c;

  i = 0;
  c = seq;
  if (META_CHAR (c))
    {
      kseq[i++] = '\\';
      kseq[i++] = 'M';
      kseq[i++] = '-';
      c = UNMETA (c);
    }
  else if (c == ESC)
    {
      kseq[i++] = '\\';
      c = 'e';
    }
  else if (CTRL_CHAR (c))
    {
      kseq[i++] = '\\';
      kseq[i++] = 'C';
      kseq[i++] = '-';
      c = _rl_to_lower (UNCTRL (c));
    }
  else if (c == RUBOUT)
    {
      kseq[i++] = '\\';
      kseq[i++] = 'C';
      kseq[i++] = '-';
      c = '?';
    }

  if (c == ESC)
    {
      kseq[i++] = '\\';
      c = 'e';
    }
  else if (c == '\\' || c == '"')
    {
      kseq[i++] = '\\';
    }

  kseq[i++] = (unsigned char) c;
  kseq[i] = '\0';
  return kseq;
}

static char *
_rl_untranslate_macro_value (seq)
     char *seq;
{
  char *ret, *r, *s;
  int c;

  r = ret = (char *)xmalloc (7 * strlen (seq) + 1);
  for (s = seq; *s; s++)
    {
      c = *s;
      if (META_CHAR (c))
	{
	  *r++ = '\\';
	  *r++ = 'M';
	  *r++ = '-';
	  c = UNMETA (c);
	}
      else if (c == ESC)
	{
	  *r++ = '\\';
	  c = 'e';
	}
      else if (CTRL_CHAR (c))
	{
	  *r++ = '\\';
	  *r++ = 'C';
	  *r++ = '-';
	  c = _rl_to_lower (UNCTRL (c));
	}
      else if (c == RUBOUT)
 	{
 	  *r++ = '\\';
 	  *r++ = 'C';
 	  *r++ = '-';
 	  c = '?';
 	}

      if (c == ESC)
	{
	  *r++ = '\\';
	  c = 'e';
	}
      else if (c == '\\' || c == '"')
	*r++ = '\\';

      *r++ = (unsigned char)c;
    }
  *r = '\0';
  return ret;
}

/* Return a pointer to the function that STRING represents.
   If STRING doesn't have a matching function, then a NULL pointer
   is returned. */
rl_command_func_t *
rl_named_function (string)
     const char *string;
{
  register int i;

  rl_initialize_funmap ();

  for (i = 0; funmap[i]; i++)
    if (_rl_stricmp (funmap[i]->name, string) == 0)
      return (funmap[i]->function);
  return ((rl_command_func_t *)NULL);
}

/* Return the function (or macro) definition which would be invoked via
   KEYSEQ if executed in MAP.  If MAP is NULL, then the current keymap is
   used.  TYPE, if non-NULL, is a pointer to an int which will receive the
   type of the object pointed to.  One of ISFUNC (function), ISKMAP (keymap),
   or ISMACR (macro). */
rl_command_func_t *
rl_function_of_keyseq (keyseq, map, type)
     const char *keyseq;
     Keymap map;
     int *type;
{
  register int i;

  if (map == 0)
    map = _rl_keymap;

  for (i = 0; keyseq && keyseq[i]; i++)
    {
      unsigned char ic = keyseq[i];

      if (META_CHAR (ic) && _rl_convert_meta_chars_to_ascii)
	{
	  if (map[ESC].type == ISKMAP)
	    {
	      map = FUNCTION_TO_KEYMAP (map, ESC);
	      ic = UNMETA (ic);
	    }
	  /* XXX - should we just return NULL here, since this obviously
	     doesn't match? */
	  else
	    {
	      if (type)
		*type = map[ESC].type;

	      return (map[ESC].function);
	    }
	}

      if (map[ic].type == ISKMAP)
	{
	  /* If this is the last key in the key sequence, return the
	     map. */
	  if (keyseq[i + 1] == '\0')
	    {
	      if (type)
		*type = ISKMAP;

	      return (map[ic].function);
	    }
	  else
	    map = FUNCTION_TO_KEYMAP (map, ic);
	}
      /* If we're not at the end of the key sequence, and the current key
	 is bound to something other than a keymap, then the entire key
	 sequence is not bound. */
      else if (map[ic].type != ISKMAP && keyseq[i+1])
	return ((rl_command_func_t *)NULL);
      else	/* map[ic].type != ISKMAP && keyseq[i+1] == 0 */
	{
	  if (type)
	    *type = map[ic].type;

	  return (map[ic].function);
	}
    }
  return ((rl_command_func_t *) NULL);
}

/* The last key bindings file read. */
static char *last_readline_init_file = (char *)NULL;

/* The file we're currently reading key bindings from. */
static const char *current_readline_init_file;
static int current_readline_init_include_level;
static int current_readline_init_lineno;

/* Read FILENAME into a locally-allocated buffer and return the buffer.
   The size of the buffer is returned in *SIZEP.  Returns NULL if any
   errors were encountered. */
static char *
_rl_read_file (filename, sizep)
     char *filename;
     size_t *sizep;
{
  struct stat finfo;
  size_t file_size;
  char *buffer;
  int i, file;

  if ((stat (filename, &finfo) < 0) || (file = open (filename, O_RDONLY, 0666)) < 0)
    return ((char *)NULL);

  file_size = (size_t)finfo.st_size;

  /* check for overflow on very large files */
  if (file_size != finfo.st_size || file_size + 1 < file_size)
    {
      if (file >= 0)
	close (file);
#if defined (EFBIG)
      errno = EFBIG;
#endif
      return ((char *)NULL);
    }

  /* Read the file into BUFFER. */
  buffer = (char *)xmalloc (file_size + 1);
  i = read (file, buffer, file_size);
  close (file);

  if (i < 0)
    {
      xfree (buffer);
      return ((char *)NULL);
    }

  RL_CHECK_SIGNALS ();

  buffer[i] = '\0';
  if (sizep)
    *sizep = i;

  return (buffer);
}

/* Re-read the current keybindings file. */
int
rl_re_read_init_file (count, ignore)
     int count, ignore;
{
  int r;
  r = rl_read_init_file ((const char *)NULL);
  rl_set_keymap_from_edit_mode ();
  return r;
}

/* Do key bindings from a file.  If FILENAME is NULL it defaults
   to the first non-null filename from this list:
     1. the filename used for the previous call
     2. the value of the shell variable `INPUTRC'
     3. ~/.inputrc
     4. /etc/inputrc
   If the file existed and could be opened and read, 0 is returned,
   otherwise errno is returned. */
int
rl_read_init_file (filename)
     const char *filename;
{
  /* Default the filename. */
  if (filename == 0)
    filename = last_readline_init_file;
  if (filename == 0)
    filename = sh_get_env_value ("INPUTRC");
  if (filename == 0 || *filename == 0)
    {
      filename = DEFAULT_INPUTRC;
      /* Try to read DEFAULT_INPUTRC; fall back to SYS_INPUTRC on failure */
      if (_rl_read_init_file (filename, 0) == 0)
	return 0;
      filename = SYS_INPUTRC;
    }

#if defined (__MSDOS__)
  if (_rl_read_init_file (filename, 0) == 0)
    return 0;
  filename = "~/_inputrc";
#endif
  return (_rl_read_init_file (filename, 0));
}

static int
_rl_read_init_file (filename, include_level)
     const char *filename;
     int include_level;
{
  register int i;
  char *buffer, *openname, *line, *end;
  size_t file_size;

  current_readline_init_file = filename;
  current_readline_init_include_level = include_level;

  openname = tilde_expand (filename);
  buffer = _rl_read_file (openname, &file_size);
  xfree (openname);

  RL_CHECK_SIGNALS ();
  if (buffer == 0)
    return (errno);
  
  if (include_level == 0 && filename != last_readline_init_file)
    {
      FREE (last_readline_init_file);
      last_readline_init_file = savestring (filename);
    }

  currently_reading_init_file = 1;

  /* Loop over the lines in the file.  Lines that start with `#' are
     comments; all other lines are commands for readline initialization. */
  current_readline_init_lineno = 1;
  line = buffer;
  end = buffer + file_size;
  while (line < end)
    {
      /* Find the end of this line. */
      for (i = 0; line + i != end && line[i] != '\n'; i++);

#if defined (__CYGWIN__)
      /* ``Be liberal in what you accept.'' */
      if (line[i] == '\n' && line[i-1] == '\r')
	line[i - 1] = '\0';
#endif

      /* Mark end of line. */
      line[i] = '\0';

      /* Skip leading whitespace. */
      while (*line && whitespace (*line))
        {
	  line++;
	  i--;
        }

      /* If the line is not a comment, then parse it. */
      if (*line && *line != '#')
	rl_parse_and_bind (line);

      /* Move to the next line. */
      line += i + 1;
      current_readline_init_lineno++;
    }

  xfree (buffer);
  currently_reading_init_file = 0;
  return (0);
}

static void
_rl_init_file_error (msg)
     const char *msg;
{
  if (currently_reading_init_file)
    _rl_errmsg ("%s: line %d: %s\n", current_readline_init_file,
		     current_readline_init_lineno, msg);
  else
    _rl_errmsg ("%s", msg);
}

/* **************************************************************** */
/*								    */
/*			Parser Directives       		    */
/*								    */
/* **************************************************************** */

typedef int _rl_parser_func_t PARAMS((char *));

/* Things that mean `Control'. */
const char * const _rl_possible_control_prefixes[] = {
  "Control-", "C-", "CTRL-", (const char *)NULL
};

const char * const _rl_possible_meta_prefixes[] = {
  "Meta", "M-", (const char *)NULL
};

/* Conditionals. */

/* Calling programs set this to have their argv[0]. */
const char *rl_readline_name = "other";

/* Stack of previous values of parsing_conditionalized_out. */
static unsigned char *if_stack = (unsigned char *)NULL;
static int if_stack_depth;
static int if_stack_size;

/* Push _rl_parsing_conditionalized_out, and set parser state based
   on ARGS. */
static int
parser_if (args)
     char *args;
{
  register int i;

  /* Push parser state. */
  if (if_stack_depth + 1 >= if_stack_size)
    {
      if (!if_stack)
	if_stack = (unsigned char *)xmalloc (if_stack_size = 20);
      else
	if_stack = (unsigned char *)xrealloc (if_stack, if_stack_size += 20);
    }
  if_stack[if_stack_depth++] = _rl_parsing_conditionalized_out;

  /* If parsing is turned off, then nothing can turn it back on except
     for finding the matching endif.  In that case, return right now. */
  if (_rl_parsing_conditionalized_out)
    return 0;

  /* Isolate first argument. */
  for (i = 0; args[i] && !whitespace (args[i]); i++);

  if (args[i])
    args[i++] = '\0';

  /* Handle "$if term=foo" and "$if mode=emacs" constructs.  If this
     isn't term=foo, or mode=emacs, then check to see if the first
     word in ARGS is the same as the value stored in rl_readline_name. */
  if (rl_terminal_name && _rl_strnicmp (args, "term=", 5) == 0)
    {
      char *tem, *tname;

      /* Terminals like "aaa-60" are equivalent to "aaa". */
      tname = savestring (rl_terminal_name);
      tem = strchr (tname, '-');
      if (tem)
	*tem = '\0';

      /* Test the `long' and `short' forms of the terminal name so that
	 if someone has a `sun-cmd' and does not want to have bindings
	 that will be executed if the terminal is a `sun', they can put
	 `$if term=sun-cmd' into their .inputrc. */
      _rl_parsing_conditionalized_out = _rl_stricmp (args + 5, tname) &&
					_rl_stricmp (args + 5, rl_terminal_name);
      xfree (tname);
    }
#if defined (VI_MODE)
  else if (_rl_strnicmp (args, "mode=", 5) == 0)
    {
      int mode;

      if (_rl_stricmp (args + 5, "emacs") == 0)
	mode = emacs_mode;
      else if (_rl_stricmp (args + 5, "vi") == 0)
	mode = vi_mode;
      else
	mode = no_mode;

      _rl_parsing_conditionalized_out = mode != rl_editing_mode;
    }
#endif /* VI_MODE */
  /* Check to see if the first word in ARGS is the same as the
     value stored in rl_readline_name. */
  else if (_rl_stricmp (args, rl_readline_name) == 0)
    _rl_parsing_conditionalized_out = 0;
  else
    _rl_parsing_conditionalized_out = 1;
  return 0;
}

/* Invert the current parser state if there is anything on the stack. */
static int
parser_else (args)
     char *args;
{
  register int i;

  if (if_stack_depth == 0)
    {
      _rl_init_file_error ("$else found without matching $if");
      return 0;
    }

#if 0
  /* Check the previous (n - 1) levels of the stack to make sure that
     we haven't previously turned off parsing. */
  for (i = 0; i < if_stack_depth - 1; i++)
#else
  /* Check the previous (n) levels of the stack to make sure that
     we haven't previously turned off parsing. */
  for (i = 0; i < if_stack_depth; i++)
#endif
    if (if_stack[i] == 1)
      return 0;

  /* Invert the state of parsing if at top level. */
  _rl_parsing_conditionalized_out = !_rl_parsing_conditionalized_out;
  return 0;
}

/* Terminate a conditional, popping the value of
   _rl_parsing_conditionalized_out from the stack. */
static int
parser_endif (args)
     char *args;
{
  if (if_stack_depth)
    _rl_parsing_conditionalized_out = if_stack[--if_stack_depth];
  else
    _rl_init_file_error ("$endif without matching $if");
  return 0;
}

static int
parser_include (args)
     char *args;
{
  const char *old_init_file;
  char *e;
  int old_line_number, old_include_level, r;

  if (_rl_parsing_conditionalized_out)
    return (0);

  old_init_file = current_readline_init_file;
  old_line_number = current_readline_init_lineno;
  old_include_level = current_readline_init_include_level;

  e = strchr (args, '\n');
  if (e)
    *e = '\0';
  r = _rl_read_init_file ((const char *)args, old_include_level + 1);

  current_readline_init_file = old_init_file;
  current_readline_init_lineno = old_line_number;
  current_readline_init_include_level = old_include_level;

  return r;
}
  
/* Associate textual names with actual functions. */
static const struct {
  const char * const name;
  _rl_parser_func_t *function;
} parser_directives [] = {
  { "if", parser_if },
  { "endif", parser_endif },
  { "else", parser_else },
  { "include", parser_include },
  { (char *)0x0, (_rl_parser_func_t *)0x0 }
};

/* Handle a parser directive.  STATEMENT is the line of the directive
   without any leading `$'. */
static int
handle_parser_directive (statement)
     char *statement;
{
  register int i;
  char *directive, *args;

  /* Isolate the actual directive. */

  /* Skip whitespace. */
  for (i = 0; whitespace (statement[i]); i++);

  directive = &statement[i];

  for (; statement[i] && !whitespace (statement[i]); i++);

  if (statement[i])
    statement[i++] = '\0';

  for (; statement[i] && whitespace (statement[i]); i++);

  args = &statement[i];

  /* Lookup the command, and act on it. */
  for (i = 0; parser_directives[i].name; i++)
    if (_rl_stricmp (directive, parser_directives[i].name) == 0)
      {
	(*parser_directives[i].function) (args);
	return (0);
      }

  /* display an error message about the unknown parser directive */
  _rl_init_file_error ("unknown parser directive");
  return (1);
}

/* Read the binding command from STRING and perform it.
   A key binding command looks like: Keyname: function-name\0,
   a variable binding command looks like: set variable value.
   A new-style keybinding looks like "\C-x\C-x": exchange-point-and-mark. */
int
rl_parse_and_bind (string)
     char *string;
{
  char *funname, *kname;
  register int c, i;
  int key, equivalency;

  while (string && whitespace (*string))
    string++;

  if (!string || !*string || *string == '#')
    return 0;

  /* If this is a parser directive, act on it. */
  if (*string == '$')
    {
      handle_parser_directive (&string[1]);
      return 0;
    }

  /* If we aren't supposed to be parsing right now, then we're done. */
  if (_rl_parsing_conditionalized_out)
    return 0;

  i = 0;
  /* If this keyname is a complex key expression surrounded by quotes,
     advance to after the matching close quote.  This code allows the
     backslash to quote characters in the key expression. */
  if (*string == '"')
    {
      int passc = 0;

      for (i = 1; c = string[i]; i++)
	{
	  if (passc)
	    {
	      passc = 0;
	      continue;
	    }

	  if (c == '\\')
	    {
	      passc++;
	      continue;
	    }

	  if (c == '"')
	    break;
	}
      /* If we didn't find a closing quote, abort the line. */
      if (string[i] == '\0')
        {
          _rl_init_file_error ("no closing `\"' in key binding");
          return 1;
        }
    }

  /* Advance to the colon (:) or whitespace which separates the two objects. */
  for (; (c = string[i]) && c != ':' && c != ' ' && c != '\t'; i++ );

  equivalency = (c == ':' && string[i + 1] == '=');

  /* Mark the end of the command (or keyname). */
  if (string[i])
    string[i++] = '\0';

  /* If doing assignment, skip the '=' sign as well. */
  if (equivalency)
    string[i++] = '\0';

  /* If this is a command to set a variable, then do that. */
  if (_rl_stricmp (string, "set") == 0)
    {
      char *var, *value, *e;

      var = string + i;
      /* Make VAR point to start of variable name. */
      while (*var && whitespace (*var)) var++;

      /* Make VALUE point to start of value string. */
      value = var;
      while (*value && !whitespace (*value)) value++;
      if (*value)
	*value++ = '\0';
      while (*value && whitespace (*value)) value++;

      /* Strip trailing whitespace from values to boolean variables.  Temp
	 fix until I get a real quoted-string parser here. */
      i = find_boolean_var (var);
      if (i >= 0)
	{
	  /* remove trailing whitespace */
	  e = value + strlen (value) - 1;
	  while (e >= value && whitespace (*e))
	    e--;
	  e++;		/* skip back to whitespace or EOS */
	  if (*e && e >= value)
	    *e = '\0';
	}

      rl_variable_bind (var, value);
      return 0;
    }

  /* Skip any whitespace between keyname and funname. */
  for (; string[i] && whitespace (string[i]); i++);
  funname = &string[i];

  /* Now isolate funname.
     For straight function names just look for whitespace, since
     that will signify the end of the string.  But this could be a
     macro definition.  In that case, the string is quoted, so skip
     to the matching delimiter.  We allow the backslash to quote the
     delimiter characters in the macro body. */
  /* This code exists to allow whitespace in macro expansions, which
     would otherwise be gobbled up by the next `for' loop.*/
  /* XXX - it may be desirable to allow backslash quoting only if " is
     the quoted string delimiter, like the shell. */
  if (*funname == '\'' || *funname == '"')
    {
      int delimiter, passc;

      delimiter = string[i++];
      for (passc = 0; c = string[i]; i++)
	{
	  if (passc)
	    {
	      passc = 0;
	      continue;
	    }

	  if (c == '\\')
	    {
	      passc = 1;
	      continue;
	    }

	  if (c == delimiter)
	    break;
	}
      if (c)
	i++;
    }

  /* Advance to the end of the string.  */
  for (; string[i] && !whitespace (string[i]); i++);

  /* No extra whitespace at the end of the string. */
  string[i] = '\0';

  /* Handle equivalency bindings here.  Make the left-hand side be exactly
     whatever the right-hand evaluates to, including keymaps. */
  if (equivalency)
    {
      return 0;
    }

  /* If this is a new-style key-binding, then do the binding with
     rl_bind_keyseq ().  Otherwise, let the older code deal with it. */
  if (*string == '"')
    {
      char *seq;
      register int j, k, passc;

      seq = (char *)xmalloc (1 + strlen (string));
      for (j = 1, k = passc = 0; string[j]; j++)
	{
	  /* Allow backslash to quote characters, but leave them in place.
	     This allows a string to end with a backslash quoting another
	     backslash, or with a backslash quoting a double quote.  The
	     backslashes are left in place for rl_translate_keyseq (). */
	  if (passc || (string[j] == '\\'))
	    {
	      seq[k++] = string[j];
	      passc = !passc;
	      continue;
	    }

	  if (string[j] == '"')
	    break;

	  seq[k++] = string[j];
	}
      seq[k] = '\0';

      /* Binding macro? */
      if (*funname == '\'' || *funname == '"')
	{
	  j = strlen (funname);

	  /* Remove the delimiting quotes from each end of FUNNAME. */
	  if (j && funname[j - 1] == *funname)
	    funname[j - 1] = '\0';

	  rl_macro_bind (seq, &funname[1], _rl_keymap);
	}
      else
	rl_bind_keyseq (seq, rl_named_function (funname));

      xfree (seq);
      return 0;
    }

  /* Get the actual character we want to deal with. */
  kname = strrchr (string, '-');
  if (!kname)
    kname = string;
  else
    kname++;

  key = glean_key_from_name (kname);

  /* Add in control and meta bits. */
  if (substring_member_of_array (string, _rl_possible_control_prefixes))
    key = CTRL (_rl_to_upper (key));

  if (substring_member_of_array (string, _rl_possible_meta_prefixes))
    key = META (key);

  /* Temporary.  Handle old-style keyname with macro-binding. */
  if (*funname == '\'' || *funname == '"')
    {
      char useq[2];
      int fl = strlen (funname);

      useq[0] = key; useq[1] = '\0';
      if (fl && funname[fl - 1] == *funname)
	funname[fl - 1] = '\0';

      rl_macro_bind (useq, &funname[1], _rl_keymap);
    }
#if defined (PREFIX_META_HACK)
  /* Ugly, but working hack to keep prefix-meta around. */
  else if (_rl_stricmp (funname, "prefix-meta") == 0)
    {
      char seq[2];

      seq[0] = key;
      seq[1] = '\0';
      rl_generic_bind (ISKMAP, seq, (char *)emacs_meta_keymap, _rl_keymap);
    }
#endif /* PREFIX_META_HACK */
  else
    rl_bind_key (key, rl_named_function (funname));
  return 0;
}

/* Simple structure for boolean readline variables (i.e., those that can
   have one of two values; either "On" or 1 for truth, or "Off" or 0 for
   false. */

#define V_SPECIAL	0x1

static const struct {
  const char * const name;
  int *value;
  int flags;
} boolean_varlist [] = {
  { "bind-tty-special-chars",	&_rl_bind_stty_chars,		0 },
  { "blink-matching-paren",	&rl_blink_matching_paren,	V_SPECIAL },
  { "byte-oriented",		&rl_byte_oriented,		0 },
  { "completion-ignore-case",	&_rl_completion_case_fold,	0 },
  { "completion-map-case",	&_rl_completion_case_map,	0 },
  { "convert-meta",		&_rl_convert_meta_chars_to_ascii, 0 },
  { "disable-completion",	&rl_inhibit_completion,		0 },
  { "echo-control-characters",	&_rl_echo_control_chars,	0 },
  { "enable-keypad",		&_rl_enable_keypad,		0 },
  { "enable-meta-key",		&_rl_enable_meta,		0 },
  { "expand-tilde",		&rl_complete_with_tilde_expansion, 0 },
  { "history-preserve-point",	&_rl_history_preserve_point,	0 },
  { "horizontal-scroll-mode",	&_rl_horizontal_scroll_mode,	0 },
  { "input-meta",		&_rl_meta_flag,			0 },
  { "mark-directories",		&_rl_complete_mark_directories,	0 },
  { "mark-modified-lines",	&_rl_mark_modified_lines,	0 },
  { "mark-symlinked-directories", &_rl_complete_mark_symlink_dirs, 0 },
  { "match-hidden-files",	&_rl_match_hidden_files,	0 },
  { "menu-complete-display-prefix", &_rl_menu_complete_prefix_first, 0 },
  { "meta-flag",		&_rl_meta_flag,			0 },
  { "output-meta",		&_rl_output_meta_chars,		0 },
  { "page-completions",		&_rl_page_completions,		0 },
  { "prefer-visible-bell",	&_rl_prefer_visible_bell,	V_SPECIAL },
  { "print-completions-horizontally", &_rl_print_completions_horizontally, 0 },
  { "revert-all-at-newline",	&_rl_revert_all_at_newline,	0 },
  { "show-all-if-ambiguous",	&_rl_complete_show_all,		0 },
  { "show-all-if-unmodified",	&_rl_complete_show_unmodified,	0 },
  { "skip-completed-text",	&_rl_skip_completed_text,	0 },
#if defined (VISIBLE_STATS)
  { "visible-stats",		&rl_visible_stats,		0 },
#endif /* VISIBLE_STATS */
  { (char *)NULL, (int *)NULL, 0 }
};

static int
find_boolean_var (name)
     const char *name;
{
  register int i;

  for (i = 0; boolean_varlist[i].name; i++)
    if (_rl_stricmp (name, boolean_varlist[i].name) == 0)
      return i;
  return -1;
}

/* Hooks for handling special boolean variables, where a
   function needs to be called or another variable needs
   to be changed when they're changed. */
static void
hack_special_boolean_var (i)
     int i;
{
  const char *name;

  name = boolean_varlist[i].name;

  if (_rl_stricmp (name, "blink-matching-paren") == 0)
    _rl_enable_paren_matching (rl_blink_matching_paren);
  else if (_rl_stricmp (name, "prefer-visible-bell") == 0)
    {
      if (_rl_prefer_visible_bell)
	_rl_bell_preference = VISIBLE_BELL;
      else
	_rl_bell_preference = AUDIBLE_BELL;
    }
}

typedef int _rl_sv_func_t PARAMS((const char *));

/* These *must* correspond to the array indices for the appropriate
   string variable.  (Though they're not used right now.) */
#define V_BELLSTYLE	0
#define V_COMBEGIN	1
#define V_EDITMODE	2
#define V_ISRCHTERM	3
#define V_KEYMAP	4

#define	V_STRING	1
#define V_INT		2

/* Forward declarations */
static int sv_bell_style PARAMS((const char *));
static int sv_combegin PARAMS((const char *));
static int sv_dispprefix PARAMS((const char *));
static int sv_compquery PARAMS((const char *));
static int sv_compwidth PARAMS((const char *));
static int sv_editmode PARAMS((const char *));
static int sv_histsize PARAMS((const char *));
static int sv_isrchterm PARAMS((const char *));
static int sv_keymap PARAMS((const char *));

static const struct {
  const char * const name;
  int flags;
  _rl_sv_func_t *set_func;
} string_varlist[] = {
  { "bell-style",	V_STRING,	sv_bell_style },
  { "comment-begin",	V_STRING,	sv_combegin },
  { "completion-display-width", V_INT,	sv_compwidth },
  { "completion-prefix-display-length", V_INT,	sv_dispprefix },
  { "completion-query-items", V_INT,	sv_compquery },
  { "editing-mode",	V_STRING,	sv_editmode },
  { "history-size",	V_INT,		sv_histsize },
  { "isearch-terminators", V_STRING,	sv_isrchterm },
  { "keymap",		V_STRING,	sv_keymap },
  { (char *)NULL,	0, (_rl_sv_func_t *)0 }
};

static int
find_string_var (name)
     const char *name;
{
  register int i;

  for (i = 0; string_varlist[i].name; i++)
    if (_rl_stricmp (name, string_varlist[i].name) == 0)
      return i;
  return -1;
}

/* A boolean value that can appear in a `set variable' command is true if
   the value is null or empty, `on' (case-insenstive), or "1".  Any other
   values result in 0 (false). */
static int
bool_to_int (value)
     const char *value;
{
  return (value == 0 || *value == '\0' ||
		(_rl_stricmp (value, "on") == 0) ||
		(value[0] == '1' && value[1] == '\0'));
}

char *
rl_variable_value (name)
     const char *name;
{
  register int i;

  /* Check for simple variables first. */
  i = find_boolean_var (name);
  if (i >= 0)
    return (*boolean_varlist[i].value ? "on" : "off");

  i = find_string_var (name);
  if (i >= 0)
    return (_rl_get_string_variable_value (string_varlist[i].name));

  /* Unknown variable names return NULL. */
  return 0;
}

int
rl_variable_bind (name, value)
     const char *name, *value;
{
  register int i;
  int	v;

  /* Check for simple variables first. */
  i = find_boolean_var (name);
  if (i >= 0)
    {
      *boolean_varlist[i].value = bool_to_int (value);
      if (boolean_varlist[i].flags & V_SPECIAL)
	hack_special_boolean_var (i);
      return 0;
    }

  i = find_string_var (name);

  /* For the time being, unknown variable names or string names without a
     handler function are simply ignored. */
  if (i < 0 || string_varlist[i].set_func == 0)
    return 0;

  v = (*string_varlist[i].set_func) (value);
  return v;
}

static int
sv_editmode (value)
     const char *value;
{
  if (_rl_strnicmp (value, "vi", 2) == 0)
    {
#if defined (VI_MODE)
      _rl_keymap = vi_insertion_keymap;
      rl_editing_mode = vi_mode;
#endif /* VI_MODE */
      return 0;
    }
  else if (_rl_strnicmp (value, "emacs", 5) == 0)
    {
      _rl_keymap = emacs_standard_keymap;
      rl_editing_mode = emacs_mode;
      return 0;
    }
  return 1;
}

static int
sv_combegin (value)
     const char *value;
{
  if (value && *value)
    {
      FREE (_rl_comment_begin);
      _rl_comment_begin = savestring (value);
      return 0;
    }
  return 1;
}

static int
sv_dispprefix (value)
     const char *value;
{
  int nval = 0;

  if (value && *value)
    {
      nval = atoi (value);
      if (nval < 0)
	nval = 0;
    }
  _rl_completion_prefix_display_length = nval;
  return 0;
}

static int
sv_compquery (value)
     const char *value;
{
  int nval = 100;

  if (value && *value)
    {
      nval = atoi (value);
      if (nval < 0)
	nval = 0;
    }
  rl_completion_query_items = nval;
  return 0;
}

static int
sv_compwidth (value)
     const char *value;
{
  int nval = -1;

  if (value && *value)
    nval = atoi (value);

  _rl_completion_columns = nval;
  return 0;
}

static int
sv_histsize (value)
     const char *value;
{
  int nval = 500;

  if (value && *value)
    {
      nval = atoi (value);
      if (nval < 0)
	return 1;
    }
  stifle_history (nval);
  return 0;
}

static int
sv_keymap (value)
     const char *value;
{
  Keymap kmap;

  kmap = rl_get_keymap_by_name (value);
  if (kmap)
    {
      rl_set_keymap (kmap);
      return 0;
    }
  return 1;
}

static int
sv_bell_style (value)
     const char *value;
{
  if (value == 0 || *value == '\0')
    _rl_bell_preference = AUDIBLE_BELL;
  else if (_rl_stricmp (value, "none") == 0 || _rl_stricmp (value, "off") == 0)
    _rl_bell_preference = NO_BELL;
  else if (_rl_stricmp (value, "audible") == 0 || _rl_stricmp (value, "on") == 0)
    _rl_bell_preference = AUDIBLE_BELL;
  else if (_rl_stricmp (value, "visible") == 0)
    _rl_bell_preference = VISIBLE_BELL;
  else
    return 1;
  return 0;
}

static int
sv_isrchterm (value)
     const char *value;
{
  int beg, end, delim;
  char *v;

  if (value == 0)
    return 1;

  /* Isolate the value and translate it into a character string. */
  v = savestring (value);
  FREE (_rl_isearch_terminators);
  if (v[0] == '"' || v[0] == '\'')
    {
      delim = v[0];
      for (beg = end = 1; v[end] && v[end] != delim; end++)
	;
    }
  else
    {
      for (beg = end = 0; whitespace (v[end]) == 0; end++)
	;
    }

  v[end] = '\0';

  /* The value starts at v + beg.  Translate it into a character string. */
  _rl_isearch_terminators = (char *)xmalloc (2 * strlen (v) + 1);
  rl_translate_keyseq (v + beg, _rl_isearch_terminators, &end);
  _rl_isearch_terminators[end] = '\0';

  xfree (v);
  return 0;
}
      
/* Return the character which matches NAME.
   For example, `Space' returns ' '. */

typedef struct {
  const char * const name;
  int value;
} assoc_list;

static const assoc_list name_key_alist[] = {
  { "DEL", 0x7f },
  { "ESC", '\033' },
  { "Escape", '\033' },
  { "LFD", '\n' },
  { "Newline", '\n' },
  { "RET", '\r' },
  { "Return", '\r' },
  { "Rubout", 0x7f },
  { "SPC", ' ' },
  { "Space", ' ' },
  { "Tab", 0x09 },
  { (char *)0x0, 0 }
};

static int
glean_key_from_name (name)
     char *name;
{
  register int i;

  for (i = 0; name_key_alist[i].name; i++)
    if (_rl_stricmp (name, name_key_alist[i].name) == 0)
      return (name_key_alist[i].value);

  return (*(unsigned char *)name);	/* XXX was return (*name) */
}

/* Auxiliary functions to manage keymaps. */
static const struct {
  const char * const name;
  Keymap map;
} keymap_names[] = {
  { "emacs", emacs_standard_keymap },
  { "emacs-standard", emacs_standard_keymap },
  { "emacs-meta", emacs_meta_keymap },
  { "emacs-ctlx", emacs_ctlx_keymap },
#if defined (VI_MODE)
  { "vi", vi_movement_keymap },
  { "vi-move", vi_movement_keymap },
  { "vi-command", vi_movement_keymap },
  { "vi-insert", vi_insertion_keymap },
#endif /* VI_MODE */
  { (char *)0x0, (Keymap)0x0 }
};

Keymap
rl_get_keymap_by_name (name)
     const char *name;
{
  register int i;

  for (i = 0; keymap_names[i].name; i++)
    if (_rl_stricmp (name, keymap_names[i].name) == 0)
      return (keymap_names[i].map);
  return ((Keymap) NULL);
}

char *
rl_get_keymap_name (map)
     Keymap map;
{
  register int i;
  for (i = 0; keymap_names[i].name; i++)
    if (map == keymap_names[i].map)
      return ((char *)keymap_names[i].name);
  return ((char *)NULL);
}
  
void
rl_set_keymap (map)
     Keymap map;
{
  if (map)
    _rl_keymap = map;
}

Keymap
rl_get_keymap ()
{
  return (_rl_keymap);
}

void
rl_set_keymap_from_edit_mode ()
{
  if (rl_editing_mode == emacs_mode)
    _rl_keymap = emacs_standard_keymap;
#if defined (VI_MODE)
  else if (rl_editing_mode == vi_mode)
    _rl_keymap = vi_insertion_keymap;
#endif /* VI_MODE */
}

char *
rl_get_keymap_name_from_edit_mode ()
{
  if (rl_editing_mode == emacs_mode)
    return "emacs";
#if defined (VI_MODE)
  else if (rl_editing_mode == vi_mode)
    return "vi";
#endif /* VI_MODE */
  else
    return "none";
}

/* **************************************************************** */
/*								    */
/*		  Key Binding and Function Information		    */
/*								    */
/* **************************************************************** */

/* Each of the following functions produces information about the
   state of keybindings and functions known to Readline.  The info
   is always printed to rl_outstream, and in such a way that it can
   be read back in (i.e., passed to rl_parse_and_bind ()). */

/* Print the names of functions known to Readline. */
void
rl_list_funmap_names ()
{
  register int i;
  const char **funmap_names;

  funmap_names = rl_funmap_names ();

  if (!funmap_names)
    return;

  for (i = 0; funmap_names[i]; i++)
    fprintf (rl_outstream, "%s\n", funmap_names[i]);

  xfree (funmap_names);
}

static char *
_rl_get_keyname (key)
     int key;
{
  char *keyname;
  int i, c;

  keyname = (char *)xmalloc (8);

  c = key;
  /* Since this is going to be used to write out keysequence-function
     pairs for possible inclusion in an inputrc file, we don't want to
     do any special meta processing on KEY. */

#if 1
  /* XXX - Experimental */
  /* We might want to do this, but the old version of the code did not. */

  /* If this is an escape character, we don't want to do any more processing.
     Just add the special ESC key sequence and return. */
  if (c == ESC)
    {
      keyname[0] = '\\';
      keyname[1] = 'e';
      keyname[2] = '\0';
      return keyname;
    }
#endif

  /* RUBOUT is translated directly into \C-? */
  if (key == RUBOUT)
    {
      keyname[0] = '\\';
      keyname[1] = 'C';
      keyname[2] = '-';
      keyname[3] = '?';
      keyname[4] = '\0';
      return keyname;
    }

  i = 0;
  /* Now add special prefixes needed for control characters.  This can
     potentially change C. */
  if (CTRL_CHAR (c))
    {
      keyname[i++] = '\\';
      keyname[i++] = 'C';
      keyname[i++] = '-';
      c = _rl_to_lower (UNCTRL (c));
    }

  /* XXX experimental code.  Turn the characters that are not ASCII or
     ISO Latin 1 (128 - 159) into octal escape sequences (\200 - \237).
     This changes C. */
  if (c >= 128 && c <= 159)
    {
      keyname[i++] = '\\';
      keyname[i++] = '2';
      c -= 128;
      keyname[i++] = (c / 8) + '0';
      c = (c % 8) + '0';
    }

  /* Now, if the character needs to be quoted with a backslash, do that. */
  if (c == '\\' || c == '"')
    keyname[i++] = '\\';

  /* Now add the key, terminate the string, and return it. */
  keyname[i++] = (char) c;
  keyname[i] = '\0';

  return keyname;
}

/* Return a NULL terminated array of strings which represent the key
   sequences that are used to invoke FUNCTION in MAP. */
char **
rl_invoking_keyseqs_in_map (function, map)
     rl_command_func_t *function;
     Keymap map;
{
  register int key;
  char **result;
  int result_index, result_size;

  result = (char **)NULL;
  result_index = result_size = 0;

  for (key = 0; key < KEYMAP_SIZE; key++)
    {
      switch (map[key].type)
	{
	case ISMACR:
	  /* Macros match, if, and only if, the pointers are identical.
	     Thus, they are treated exactly like functions in here. */
	case ISFUNC:
	  /* If the function in the keymap is the one we are looking for,
	     then add the current KEY to the list of invoking keys. */
	  if (map[key].function == function)
	    {
	      char *keyname;

	      keyname = _rl_get_keyname (key);

	      if (result_index + 2 > result_size)
	        {
	          result_size += 10;
		  result = (char **)xrealloc (result, result_size * sizeof (char *));
	        }

	      result[result_index++] = keyname;
	      result[result_index] = (char *)NULL;
	    }
	  break;

	case ISKMAP:
	  {
	    char **seqs;
	    register int i;

	    /* Find the list of keyseqs in this map which have FUNCTION as
	       their target.  Add the key sequences found to RESULT. */
	    if (map[key].function)
	      seqs =
	        rl_invoking_keyseqs_in_map (function, FUNCTION_TO_KEYMAP (map, key));
	    else
	      break;

	    if (seqs == 0)
	      break;

	    for (i = 0; seqs[i]; i++)
	      {
		char *keyname = (char *)xmalloc (6 + strlen (seqs[i]));

		if (key == ESC)
		  {
		    /* If ESC is the meta prefix and we're converting chars
		       with the eighth bit set to ESC-prefixed sequences, then
		       we can use \M-.  Otherwise we need to use the sequence
		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, "\\M-");
		    else
		      sprintf (keyname, "\\e");
		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, "\\C-%c", _rl_to_lower (UNCTRL (key)));
		else if (key == RUBOUT)
		  sprintf (keyname, "\\C-?");
		else if (key == '\\' || key == '"')
		  {
		    keyname[0] = '\\';
		    keyname[1] = (char) key;
		    keyname[2] = '\0';
		  }
		else
		  {
		    keyname[0] = (char) key;
		    keyname[1] = '\0';
		  }
		
		strcat (keyname, seqs[i]);
		xfree (seqs[i]);

		if (result_index + 2 > result_size)
		  {
		    result_size += 10;
		    result = (char **)xrealloc (result, result_size * sizeof (char *));
		  }

		result[result_index++] = keyname;
		result[result_index] = (char *)NULL;
	      }

	    xfree (seqs);
	  }
	  break;
	}
    }
  return (result);
}

/* Return a NULL terminated array of strings which represent the key
   sequences that can be used to invoke FUNCTION using the current keymap. */
char **
rl_invoking_keyseqs (function)
     rl_command_func_t *function;
{
  return (rl_invoking_keyseqs_in_map (function, _rl_keymap));
}

/* Print all of the functions and their bindings to rl_outstream.  If
   PRINT_READABLY is non-zero, then print the output in such a way
   that it can be read back in. */
void
rl_function_dumper (print_readably)
     int print_readably;
{
  register int i;
  const char **names;
  const char *name;

  names = rl_funmap_names ();

  fprintf (rl_outstream, "\n");

  for (i = 0; name = names[i]; i++)
    {
      rl_command_func_t *function;
      char **invokers;

      function = rl_named_function (name);
      invokers = rl_invoking_keyseqs_in_map (function, _rl_keymap);

      if (print_readably)
	{
	  if (!invokers)
	    fprintf (rl_outstream, "# %s (not bound)\n", name);
	  else
	    {
	      register int j;

	      for (j = 0; invokers[j]; j++)
		{
		  fprintf (rl_outstream, "\"%s\": %s\n",
			   invokers[j], name);
		  xfree (invokers[j]);
		}

	      xfree (invokers);
	    }
	}
      else
	{
	  if (!invokers)
	    fprintf (rl_outstream, "%s is not bound to any keys\n",
		     name);
	  else
	    {
	      register int j;

	      fprintf (rl_outstream, "%s can be found on ", name);

	      for (j = 0; invokers[j] && j < 5; j++)
		{
		  fprintf (rl_outstream, "\"%s\"%s", invokers[j],
			   invokers[j + 1] ? ", " : ".\n");
		}

	      if (j == 5 && invokers[j])
		fprintf (rl_outstream, "...\n");

	      for (j = 0; invokers[j]; j++)
		xfree (invokers[j]);

	      xfree (invokers);
	    }
	}
    }
  free (names);
}

/* Print all of the current functions and their bindings to
   rl_outstream.  If an explicit argument is given, then print
   the output in such a way that it can be read back in. */
int
rl_dump_functions (count, key)
     int count, key;
{
  if (rl_dispatching)
    fprintf (rl_outstream, "\r\n");
  rl_function_dumper (rl_explicit_arg);
  rl_on_new_line ();
  return (0);
}

static void
_rl_macro_dumper_internal (print_readably, map, prefix)
     int print_readably;
     Keymap map;
     char *prefix;
{
  register int key;
  char *keyname, *out;
  int prefix_len;

  for (key = 0; key < KEYMAP_SIZE; key++)
    {
      switch (map[key].type)
	{
	case ISMACR:
	  keyname = _rl_get_keyname (key);
	  out = _rl_untranslate_macro_value ((char *)map[key].function);

	  if (print_readably)
	    fprintf (rl_outstream, "\"%s%s\": \"%s\"\n", prefix ? prefix : "",
						         keyname,
						         out ? out : "");
	  else
	    fprintf (rl_outstream, "%s%s outputs %s\n", prefix ? prefix : "",
							keyname,
							out ? out : "");
	  xfree (keyname);
	  xfree (out);
	  break;
	case ISFUNC:
	  break;
	case ISKMAP:
	  prefix_len = prefix ? strlen (prefix) : 0;
	  if (key == ESC)
	    {
	      keyname = (char *)xmalloc (3 + prefix_len);
	      if (prefix)
		strcpy (keyname, prefix);
	      keyname[prefix_len] = '\\';
	      keyname[prefix_len + 1] = 'e';
	      keyname[prefix_len + 2] = '\0';
	    }
	  else
	    {
	      keyname = _rl_get_keyname (key);
	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
		  strcpy (out + prefix_len, keyname);
		  xfree (keyname);
		  keyname = out;
		}
	    }

	  _rl_macro_dumper_internal (print_readably, FUNCTION_TO_KEYMAP (map, key), keyname);
	  xfree (keyname);
	  break;
	}
    }
}

void
rl_macro_dumper (print_readably)
     int print_readably;
{
  _rl_macro_dumper_internal (print_readably, _rl_keymap, (char *)NULL);
}

int
rl_dump_macros (count, key)
     int count, key;
{
  if (rl_dispatching)
    fprintf (rl_outstream, "\r\n");
  rl_macro_dumper (rl_explicit_arg);
  rl_on_new_line ();
  return (0);
}

static char *
_rl_get_string_variable_value (name)
     const char *name;
{
  static char numbuf[32];
  char *ret;

  if (_rl_stricmp (name, "bell-style") == 0)
    {
      switch (_rl_bell_preference)
	{
	  case NO_BELL:
	    return "none";
	  case VISIBLE_BELL:
	    return "visible";
	  case AUDIBLE_BELL:
	  default:
	    return "audible";
	}
    }
  else if (_rl_stricmp (name, "comment-begin") == 0)
    return (_rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);
  else if (_rl_stricmp (name, "completion-display-width") == 0)
    {
      sprintf (numbuf, "%d", _rl_completion_columns);
      return (numbuf);
    }
  else if (_rl_stricmp (name, "completion-prefix-display-length") == 0)
    {
      sprintf (numbuf, "%d", _rl_completion_prefix_display_length);
      return (numbuf);
    }
  else if (_rl_stricmp (name, "completion-query-items") == 0)
    {
      sprintf (numbuf, "%d", rl_completion_query_items);
      return (numbuf);
    }
  else if (_rl_stricmp (name, "editing-mode") == 0)
    return (rl_get_keymap_name_from_edit_mode ());
  else if (_rl_stricmp (name, "history-size") == 0)
    {
      sprintf (numbuf, "%d", history_is_stifled() ? history_max_entries : 0);
      return (numbuf);
    }
  else if (_rl_stricmp (name, "isearch-terminators") == 0)
    {
      if (_rl_isearch_terminators == 0)
	return 0;
      ret = _rl_untranslate_macro_value (_rl_isearch_terminators);
      if (ret)
	{
	  strncpy (numbuf, ret, sizeof (numbuf) - 1);
	  xfree (ret);
	  numbuf[sizeof(numbuf) - 1] = '\0';
	}
      else
	numbuf[0] = '\0';
      return numbuf;
    }
  else if (_rl_stricmp (name, "keymap") == 0)
    {
      ret = rl_get_keymap_name (_rl_keymap);
      if (ret == 0)
	ret = rl_get_keymap_name_from_edit_mode ();
      return (ret ? ret : "none");
    }
  else
    return (0);
}

void
rl_variable_dumper (print_readably)
     int print_readably;
{
  int i;
  char *v;

  for (i = 0; boolean_varlist[i].name; i++)
    {
      if (print_readably)
        fprintf (rl_outstream, "set %s %s\n", boolean_varlist[i].name,
			       *boolean_varlist[i].value ? "on" : "off");
      else
        fprintf (rl_outstream, "%s is set to `%s'\n", boolean_varlist[i].name,
			       *boolean_varlist[i].value ? "on" : "off");
    }

  for (i = 0; string_varlist[i].name; i++)
    {
      v = _rl_get_string_variable_value (string_varlist[i].name);
      if (v == 0)	/* _rl_isearch_terminators can be NULL */
	continue;
      if (print_readably)
        fprintf (rl_outstream, "set %s %s\n", string_varlist[i].name, v);
      else
        fprintf (rl_outstream, "%s is set to `%s'\n", string_varlist[i].name, v);
    }
}

/* Print all of the current variables and their values to
   rl_outstream.  If an explicit argument is given, then print
   the output in such a way that it can be read back in. */
int
rl_dump_variables (count, key)
     int count, key;
{
  if (rl_dispatching)
    fprintf (rl_outstream, "\r\n");
  rl_variable_dumper (rl_explicit_arg);
  rl_on_new_line ();
  return (0);
}

/* Return non-zero if any members of ARRAY are a substring in STRING. */
static int
substring_member_of_array (string, array)
     const char *string;
     const char * const *array;
{
  while (*array)
    {
      if (_rl_strindex (string, *array))
	return (1);
      array++;
    }
  return (0);
}
@


1.9
log
@2011-03-04  Michael Snyder  <msnyder@@vmware.com>

	* bind.c (rl_function_dumper): Free allocated memory.
@
text
@d3 1
a3 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
d5 2
a6 2
   This file is part of the GNU Readline Library, a library for
   reading lines of text with interactive input and history editing.
d8 3
a10 3
   The GNU Readline Library is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2, or
d13 3
a15 3
   The GNU Readline Library is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
d18 3
a20 4
   The GNU General Public License is often shipped with GNU software, and
   is generally kept in a file called COPYING or LICENSE.  If you do not
   have a copy of the license, write to the Free Software Foundation,
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
d82 1
a82 1
static int substring_member_of_array PARAMS((char *, const char **));
d319 1
a319 1
      free (macro_keys);
d349 1
a349 1
	free (data);
d360 1
a360 1
      free (keys);
d372 4
a375 1
	return -1;
d416 1
a416 1
	    free ((char *)map[ic].function);
d421 7
d436 1
a436 1
  free (keys);
d474 2
a475 2
		  i++;
		  /* XXX - should obey convert-meta setting? */
d478 6
d486 3
d586 5
d639 6
a644 1
      else if (CTRL_CHAR (c) && c != ESC)
d703 1
a703 1
  if (!map)
d712 8
a719 1
	  if (map[ESC].type != ISKMAP)
a725 5
	  else
	    {
	      map = FUNCTION_TO_KEYMAP (map, ESC);
	      ic = UNMETA (ic);
	    }
d732 1
a732 1
	  if (!keyseq[i + 1])
d742 6
a747 1
      else
d802 1
a802 1
      free (buffer);
d806 2
d831 1
d840 4
d845 5
a849 5
      filename = last_readline_init_file;
      if (filename == 0)
        filename = sh_get_env_value ("INPUTRC");
      if (filename == 0)
	filename = DEFAULT_INPUTRC;
a851 3
  if (*filename == 0)
    filename = DEFAULT_INPUTRC;

d874 1
a874 1
  free (openname);
d876 1
d923 1
a923 1
  free (buffer);
d933 1
a933 1
    fprintf (stderr, "readline: %s: line %d: %s\n", current_readline_init_file,
d936 1
a936 1
    fprintf (stderr, "readline: %s\n", msg);
d948 1
a948 1
const char *_rl_possible_control_prefixes[] = {
d952 1
a952 1
const char *_rl_possible_meta_prefixes[] = {
d1014 1
a1014 1
      free (tname);
d1111 2
a1112 2
static struct {
  const char *name;
d1364 1
a1364 1
      free (seq);
d1418 2
a1419 2
static struct {
  const char *name;
d1427 1
d1430 1
d1432 1
d1441 1
d1447 1
d1450 1
d1454 1
a1454 1
  { (char *)NULL, (int *)NULL }
d1507 1
d1509 1
d1511 1
d1515 2
a1516 2
static struct {
  const char *name;
d1522 2
d1526 1
d1529 1
a1529 1
  { (char *)NULL,	0 }
a1560 2
  int	v;
  char *ret;
d1638 16
d1670 29
d1762 1
a1762 1
  free (v);
d1770 1
a1770 1
  const char *name;
d1774 1
a1774 1
static assoc_list name_key_alist[] = {
d1803 2
a1804 2
static struct {
  const char *name;
d1907 1
a1907 1
  free (funmap_names);
d2046 10
a2055 6
#if 0
		  sprintf (keyname, "\\e");
#else
		/* XXX - experimental */
		  sprintf (keyname, "\\M-");
#endif
d2073 1
a2073 1
		free (seqs[i]);
d2085 1
a2085 1
	    free (seqs);
d2137 1
a2137 1
		  free (invokers[j]);
d2140 1
a2140 1
	      free (invokers);
d2164 1
a2164 1
		free (invokers[j]);
d2166 1
a2166 1
	      free (invokers);
d2213 2
a2214 2
	  free (keyname);
	  free (out);
d2237 1
a2237 1
		  free (keyname);
d2243 1
a2243 1
	  free (keyname);
a2272 1
  int n;
d2289 10
d2306 5
d2319 1
a2319 1
	  free (ret);
d2383 2
a2384 2
     char *string;
     const char **array;
@


1.8
log
@Readline 5.1 import for HEAD.
@
text
@d2071 1
@


1.7
log
@touched all sources to ease import of readline-5.1
@
text
@d3 1
a3 1
/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
d22 1
d25 4
d80 3
d159 28
d239 11
d253 10
d271 34
d347 1
a347 1
  if (!keyseq || !*keyseq)
d375 1
a375 1
      if (_rl_convert_meta_chars_to_ascii && META_CHAR (ic))
d466 8
a473 1
		  array[l++] = ESC;	/* ESC is meta-prefix */
d1013 1
d1017 5
d1198 1
a1198 2
      char *var = string + i;
      char *value;
d1200 1
d1211 14
d1245 1
a1245 1
      int delimiter = string[i++], passc;
d1247 1
d1283 1
a1283 1
     rl_set_key ().  Otherwise, let the older code deal with it. */
d1322 1
a1322 1
	rl_set_key (seq, rl_named_function (funname), _rl_keymap);
d1383 1
d1404 1
d1497 1
a1497 1
     char *value;
d1504 21
d1795 1
a1795 1
   be read back in (i.e., passed to rl_parse_and_bind (). */
d2167 56
d2228 1
a2228 1
  const char *kname;
d2240 1
a2240 36
  /* bell-style */
  switch (_rl_bell_preference)
    {
    case NO_BELL:
      kname = "none"; break;
    case VISIBLE_BELL:
      kname = "visible"; break;
    case AUDIBLE_BELL:
    default:
      kname = "audible"; break;
    }
  if (print_readably)
    fprintf (rl_outstream, "set bell-style %s\n", kname);
  else
    fprintf (rl_outstream, "bell-style is set to `%s'\n", kname);

  /* comment-begin */
  if (print_readably)
    fprintf (rl_outstream, "set comment-begin %s\n", _rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);
  else
    fprintf (rl_outstream, "comment-begin is set to `%s'\n", _rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);

  /* completion-query-items */
  if (print_readably)
    fprintf (rl_outstream, "set completion-query-items %d\n", rl_completion_query_items);
  else
    fprintf (rl_outstream, "completion-query-items is set to `%d'\n", rl_completion_query_items);

  /* editing-mode */
  if (print_readably)
    fprintf (rl_outstream, "set editing-mode %s\n", (rl_editing_mode == emacs_mode) ? "emacs" : "vi");
  else
    fprintf (rl_outstream, "editing-mode is set to `%s'\n", (rl_editing_mode == emacs_mode) ? "emacs" : "vi");

  /* isearch-terminators */
  if (_rl_isearch_terminators)
d2242 3
a2244 4
      char *disp;

      disp = _rl_untranslate_macro_value (_rl_isearch_terminators);

d2246 1
a2246 1
	fprintf (rl_outstream, "set isearch-terminators \"%s\"\n", disp);
d2248 1
a2248 3
	fprintf (rl_outstream, "isearch-terminators is set to \"%s\"\n", disp);

      free (disp);
a2249 9

  /* keymap */
  kname = rl_get_keymap_name (_rl_keymap);
  if (kname == 0)
    kname = rl_get_keymap_name_from_edit_mode ();
  if (print_readably)
    fprintf (rl_outstream, "set keymap %s\n", kname ? kname : "none");
  else
    fprintf (rl_outstream, "keymap is set to `%s'\n", kname ? kname : "none");
a2265 22
/* Bind key sequence KEYSEQ to DEFAULT_FUNC if KEYSEQ is unbound.  Right
   now, this is always used to attempt to bind the arrow keys, hence the
   check for rl_vi_movement_mode. */
void
_rl_bind_if_unbound (keyseq, default_func)
     const char *keyseq;
     rl_command_func_t *default_func;
{
  rl_command_func_t *func;

  if (keyseq)
    {
      func = rl_function_of_keyseq (keyseq, _rl_keymap, (int *)NULL);
#if defined (VI_MODE)
      if (!func || func == rl_do_lowercase_version || func == rl_vi_movement_mode)
#else
      if (!func || func == rl_do_lowercase_version)
#endif
	rl_set_key (keyseq, default_func, _rl_keymap);
    }
}

@


1.7.2.1
log
@Import readline 5.1 on the branch.
@
text
@d3 1
a3 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
a21 1

a23 4
#if defined (__TANDEM)
#  include <floss.h>
#endif

a74 3
static int find_boolean_var PARAMS((const char *));

static char *_rl_get_string_variable_value PARAMS((const char *));
a150 28
/* Bind key sequence KEYSEQ to DEFAULT_FUNC if KEYSEQ is unbound.  Right
   now, this is always used to attempt to bind the arrow keys, hence the
   check for rl_vi_movement_mode. */
int
rl_bind_key_if_unbound_in_map (key, default_func, kmap)
     int key;
     rl_command_func_t *default_func;
     Keymap kmap;
{
  char keyseq[2];

  keyseq[0] = (unsigned char)key;
  keyseq[1] = '\0';
  return (rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, kmap));
}

int
rl_bind_key_if_unbound (key, default_func)
     int key;
     rl_command_func_t *default_func;
{
  char keyseq[2];

  keyseq[0] = (unsigned char)key;
  keyseq[1] = '\0';
  return (rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, _rl_keymap));
}

a202 11
   FUNCTION, starting in the current keymap.  This makes new
   keymaps as necessary. */
int
rl_bind_keyseq (keyseq, function)
     const char *keyseq;
     rl_command_func_t *function;
{
  return (rl_generic_bind (ISFUNC, keyseq, (char *)function, _rl_keymap));
}

/* Bind the key sequence represented by the string KEYSEQ to
a205 10
rl_bind_keyseq_in_map (keyseq, function, map)
     const char *keyseq;
     rl_command_func_t *function;
     Keymap map;
{
  return (rl_generic_bind (ISFUNC, keyseq, (char *)function, map));
}

/* Backwards compatibility; equivalent to rl_bind_keyseq_in_map() */
int
a213 34
/* Bind key sequence KEYSEQ to DEFAULT_FUNC if KEYSEQ is unbound.  Right
   now, this is always used to attempt to bind the arrow keys, hence the
   check for rl_vi_movement_mode. */
int
rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, kmap)
     const char *keyseq;
     rl_command_func_t *default_func;
     Keymap kmap;
{
  rl_command_func_t *func;

  if (keyseq)
    {
      func = rl_function_of_keyseq (keyseq, kmap, (int *)NULL);
#if defined (VI_MODE)
      if (!func || func == rl_do_lowercase_version || func == rl_vi_movement_mode)
#else
      if (!func || func == rl_do_lowercase_version)
#endif
	return (rl_bind_keyseq_in_map (keyseq, default_func, kmap));
      else
	return 1;
    }
  return 0;
}

int
rl_bind_keyseq_if_unbound (keyseq, default_func)
     const char *keyseq;
     rl_command_func_t *default_func;
{
  return (rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, _rl_keymap));
}

d256 1
a256 1
  if (keyseq == 0 || *keyseq == 0)
d284 1
a284 1
      if (META_CHAR (ic) && _rl_convert_meta_chars_to_ascii)
d375 1
a375 8
		  /* XXX - should obey convert-meta setting? */
		  if (_rl_convert_meta_chars_to_ascii && _rl_keymap[ESC].type == ISKMAP)
		    array[l++] = ESC;	/* ESC is meta-prefix */
		  else
		    {
		      i++;
		      array[l++] = META (seq[i]);
		    }
a914 1
#if 0
a917 5
#else
  /* Check the previous (n) levels of the stack to make sure that
     we haven't previously turned off parsing. */
  for (i = 0; i < if_stack_depth; i++)
#endif
d1094 2
a1095 1
      char *var, *value, *e;
a1096 1
      var = string + i;
a1106 14
      /* Strip trailing whitespace from values to boolean variables.  Temp
	 fix until I get a real quoted-string parser here. */
      i = find_boolean_var (var);
      if (i >= 0)
	{
	  /* remove trailing whitespace */
	  e = value + strlen (value) - 1;
	  while (e >= value && whitespace (*e))
	    e--;
	  e++;		/* skip back to whitespace or EOS */
	  if (*e && e >= value)
	    *e = '\0';
	}

d1127 1
a1127 1
      int delimiter, passc;
a1128 1
      delimiter = string[i++];
d1164 1
a1164 1
     rl_bind_keyseq ().  Otherwise, let the older code deal with it. */
d1203 1
a1203 1
	rl_bind_keyseq (seq, rl_named_function (funname));
a1263 1
  { "bind-tty-special-chars",	&_rl_bind_stty_chars,		0 },
a1283 1
  { "show-all-if-unmodified",	&_rl_complete_show_unmodified,	0 },
d1376 1
a1376 1
     const char *value;
a1382 21
char *
rl_variable_value (name)
     const char *name;
{
  register int i;
  int	v;
  char *ret;

  /* Check for simple variables first. */
  i = find_boolean_var (name);
  if (i >= 0)
    return (*boolean_varlist[i].value ? "on" : "off");

  i = find_string_var (name);
  if (i >= 0)
    return (_rl_get_string_variable_value (string_varlist[i].name));

  /* Unknown variable names return NULL. */
  return 0;
}

d1653 1
a1653 1
   be read back in (i.e., passed to rl_parse_and_bind ()). */
a2024 56
static char *
_rl_get_string_variable_value (name)
     const char *name;
{
  static char numbuf[32];
  char *ret;
  int n;

  if (_rl_stricmp (name, "bell-style") == 0)
    {
      switch (_rl_bell_preference)
	{
	  case NO_BELL:
	    return "none";
	  case VISIBLE_BELL:
	    return "visible";
	  case AUDIBLE_BELL:
	  default:
	    return "audible";
	}
    }
  else if (_rl_stricmp (name, "comment-begin") == 0)
    return (_rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);
  else if (_rl_stricmp (name, "completion-query-items") == 0)
    {
      sprintf (numbuf, "%d", rl_completion_query_items);
      return (numbuf);
    }
  else if (_rl_stricmp (name, "editing-mode") == 0)
    return (rl_get_keymap_name_from_edit_mode ());
  else if (_rl_stricmp (name, "isearch-terminators") == 0)
    {
      if (_rl_isearch_terminators == 0)
	return 0;
      ret = _rl_untranslate_macro_value (_rl_isearch_terminators);
      if (ret)
	{
	  strncpy (numbuf, ret, sizeof (numbuf) - 1);
	  free (ret);
	  numbuf[sizeof(numbuf) - 1] = '\0';
	}
      else
	numbuf[0] = '\0';
      return numbuf;
    }
  else if (_rl_stricmp (name, "keymap") == 0)
    {
      ret = rl_get_keymap_name (_rl_keymap);
      if (ret == 0)
	ret = rl_get_keymap_name_from_edit_mode ();
      return (ret ? ret : "none");
    }
  else
    return (0);
}

d2030 1
a2030 1
  char *v;
d2042 36
a2077 1
  for (i = 0; string_varlist[i].name; i++)
d2079 4
a2082 3
      v = _rl_get_string_variable_value (string_varlist[i].name);
      if (v == 0)	/* _rl_isearch_terminators can be NULL */
	continue;
d2084 1
a2084 1
        fprintf (rl_outstream, "set %s %s\n", string_varlist[i].name, v);
d2086 3
a2088 1
        fprintf (rl_outstream, "%s is set to `%s'\n", string_varlist[i].name, v);
d2090 9
d2115 22
@


1.6
log
@2004-01-27  Elena Zannoni  <ezannoni@@redhat.com>

        Merge in official patches to readline-4.3 from
	ftp://ftp.cwru.edu/pub/bash/readline-4.3-patches:
	NOTE: Patch-ID readline-43-004 was already applied (see below).

	* bind.c (rl_generic_bind): Pressing certain key sequences
	causes an infinite loop in _rl_dispatch_subseq with the `key' argument
	set to 256.  This eventually causes bash to exceed the stack size
	limit and crash with a segmentation violation.
	Patch-ID: readline43-001.

	* readline.c (_rl_dispatch_subseq): Repeating an edit in
	vi-mode with `.' does not work.
	Patch-ID: readline43-002.

	* mbutil.c (_rl_get_char_len, _rl_compare_chars,
	_rl_adjust_point): When in a locale with multibyte characters, the
	readline display updater will occasionally cause a
	segmentation fault when attempting to compute the length of the first
	multibyte character on the line.
	Patch-ID: readline43-003.

	* vi_mode.c (_rl_vi_change_mbchar_case): Using the vi editing
	mode's case-changing commands in a locale with multibyte characters
	will cause garbage characters to be inserted into the editing buffer.
	Patch-ID: readline43-005.
@
text
@@


1.5
log
@Import of readline 4.3.
Non-readline modified files:

src/gdb/ChangeLog src/gdb/defs.h src/gdb/cli/cli-cmds.c
src/gdb/cli/cli-setshow.c src/gdb/tui/ChangeLog
src/gdb/tui/tuiWin.c

In readline directory:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@d314 1
a314 1
	  if (k.function /* && k.type == ISFUNC */)
@


1.4
log
@readline:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Locally modified files: Makefile.in, configure.in, configure
        (regenerated), config.h.in (regenerated), readline.h, rltty.c,
 	shell.c signals.c.

        Locally added files: acconfig.h, config/*, config.h.bot,
        cross-build/*, doc/inc-hit.texinfo.

        New files: USAGE, rlprivate.h, rlshell.h, xmalloc.h.
examples:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        New files: excallback.c, rlfe.c.
doc:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Regenerated inc-hist.texinfo as copy of hsuser.texinfo, for
        inclusion in the gdb manual.

        New file: rluserman.texinfo
@
text
@d71 5
a75 3
static int _rl_read_init_file __P((char *, int));
static int glean_key_from_name __P((char *));
static int substring_member_of_array __P((char *, char **));
d88 1
a88 1
/* rl_add_defun (char *name, Function *function, int key)
d93 2
a94 2
     char *name;
     Function *function;
d107 1
a107 1
     Function *function;
d138 1
a138 1
     Function *function;
d157 1
a157 1
  return (rl_bind_key (key, (Function *)NULL));
d167 1
a167 1
  return (rl_bind_key_in_map (key, (Function *)NULL, map));
d173 1
a173 1
     Function *func;
d182 1
a182 1
	  map[i].function = (Function *)NULL;
d191 1
a191 1
     char *command;
d194 1
a194 1
  Function *func;
d207 2
a208 2
     char *keyseq;
     Function *function;
d219 1
a219 1
     char *keyseq, *macro;
d244 2
a245 1
     char *keyseq, *data;
d251 3
d263 1
a263 1
  keys = xmalloc (1 + (2 * strlen (keyseq)));
d277 6
a282 1
      int ic = (int) ((unsigned char)keys[i]);
d295 8
a302 2
	      if (map[ic].type == ISMACR)
		free ((char *)map[ic].function);
d308 11
d324 5
d345 2
a346 1
     char *seq, *array;
d366 1
a366 1
		  array[l++] = ESC;
d375 1
a375 1
		  array[l++] = ESC;	/* XXX */
d428 1
a428 1
	      array[l++] = c % (largest_char + 1);
d432 1
a432 1
	      for (temp = 3, c = 0; isxdigit (seq[i]) && temp--; i++)
d434 1
a434 1
	      if (temp == 3)
d437 1
a437 1
	      array[l++] = c % (largest_char + 1);
d507 1
a507 1
  r = ret = xmalloc (7 * strlen (seq) + 1);
d550 1
a550 1
Function *
d552 1
a552 1
     char *string;
d561 1
a561 1
  return ((Function *)NULL);
d569 1
a569 1
Function *
d571 1
a571 1
     char *keyseq;
d582 1
a582 1
      int ic = keyseq[i];
d622 1
a622 1
  return ((Function *) NULL);
d629 1
a629 1
static char *current_readline_init_file;
a666 3
#if 0
  if (i < file_size)
#else
a667 1
#endif
a672 5
#if 0
  buffer[file_size] = '\0';
  if (sizep)
    *sizep = file_size;
#else
a675 1
#endif
d686 1
a686 1
  r = rl_read_init_file ((char *)NULL);
d700 1
a700 1
     char *filename;
d707 1
a707 1
        filename = get_env_value ("INPUTRC");
d725 1
a725 1
     char *filename;
d760 1
a760 1
#if defined (__CYGWIN32__)
d792 1
a792 1
     char *msg;
d807 11
d821 1
a821 1
char *rl_readline_name = "other";
d943 2
a944 1
  char *old_init_file, *e;
d957 1
a957 1
  r = _rl_read_init_file (args, old_include_level + 1);
d968 2
a969 2
  char *name;
  Function *function;
d975 1
a975 1
  { (char *)0x0, (Function *)0x0 }
d1100 1
a1100 1
      /* Make value point to start of value string. */
d1170 1
a1170 1
      seq = xmalloc (1 + strlen (string));
d1219 1
a1219 1
  if (substring_member_of_array (string, possible_control_prefixes))
d1222 1
a1222 1
  if (substring_member_of_array (string, possible_meta_prefixes))
d1228 1
a1228 1
      unsigned char useq[2];
d1260 1
a1260 1
  char *name;
d1265 1
d1271 1
d1276 2
d1280 1
d1292 1
a1292 1
     char *name;
d1309 1
a1309 1
  char *name;
d1324 2
d1338 6
a1343 6
static int sv_bell_style __P((char *));
static int sv_combegin __P((char *));
static int sv_compquery __P((char *));
static int sv_editmode __P((char *));
static int sv_isrchterm __P((char *));
static int sv_keymap __P((char *));
d1346 1
a1346 1
  char *name;
d1348 1
a1348 1
  Function *set_func;
d1361 1
a1361 1
     char *name;
d1385 1
a1385 1
     char *name, *value;
d1413 1
a1413 1
     char *value;
d1434 1
a1434 1
     char *value;
d1447 1
a1447 1
     char *value;
d1463 1
a1463 1
     char *value;
a1475 2
#define _SET_BELL(v)	do { _rl_bell_preference = v; return 0; } while (0)

d1478 1
a1478 1
     char *value;
d1481 1
a1481 1
    _SET_BELL (AUDIBLE_BELL);
d1483 1
a1483 1
    _SET_BELL (NO_BELL);
d1485 1
a1485 1
    _SET_BELL (AUDIBLE_BELL);
d1487 1
a1487 1
    _SET_BELL (VISIBLE_BELL);
d1490 1
a1491 1
#undef _SET_BELL
d1495 1
a1495 1
     char *value;
d1521 1
a1521 1
  _rl_isearch_terminators = (unsigned char *)xmalloc (2 * strlen (v) + 1);
d1533 1
a1533 1
  char *name;
d1567 1
a1567 1
  char *name;
d1585 1
a1585 1
     char *name;
d1590 1
a1590 1
    if (strcmp (name, keymap_names[i].name) == 0)
d1602 1
a1602 1
      return (keymap_names[i].name);
d1660 1
a1660 1
  char **funmap_names;
d1687 2
a1688 1
#if 0
d1695 4
a1698 4
      keyseq[0] = '\\';
      keyseq[1] = 'e';
      keyseq[2] = '\0';
      return keyseq;
d1751 1
a1751 1
     Function *function;
d1780 1
a1780 1
		  result = (char **) xrealloc (result, result_size * sizeof (char *));
d1809 1
d1811 4
d1837 1
a1837 1
		    result = (char **) xrealloc (result, result_size * sizeof (char *));
d1856 1
a1856 1
     Function *function;
d1869 2
a1870 2
  char **names;
  char *name;
d1878 1
a1878 1
      Function *function;
a1960 3
#if 0
	  out = (char *)map[key].function;
#else
d1962 1
a1962 1
#endif
a1971 1
#if 1
a1972 1
#endif
d1980 1
a1980 1
	      keyname = xmalloc (3 + prefix_len);
d1992 1
a1992 1
		  out = xmalloc (strlen (keyname) + prefix_len + 1);
d2030 1
a2030 1
  char *kname;
d2062 1
a2062 1
    fprintf (rl_outstream, "comment-begin is set to `%s'\n", _rl_comment_begin ? _rl_comment_begin : "");
a2075 9
  /* keymap */
  kname = rl_get_keymap_name (_rl_keymap);
  if (kname == 0)
    kname = rl_get_keymap_name_from_edit_mode ();
  if (print_readably)
    fprintf (rl_outstream, "set keymap %s\n", kname ? kname : "none");
  else
    fprintf (rl_outstream, "keymap is set to `%s'\n", kname ? kname : "none");

d2090 9
d2115 3
a2117 1
/* Bind key sequence KEYSEQ to DEFAULT_FUNC if KEYSEQ is unbound. */
d2120 2
a2121 2
     char *keyseq;
     Function *default_func;
d2123 1
a2123 1
  Function *func;
d2128 3
d2132 1
d2140 2
a2141 1
     char *string, **array;
@


1.4.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d71 3
a73 5
static char *_rl_read_file PARAMS((char *, size_t *));
static void _rl_init_file_error PARAMS((const char *));
static int _rl_read_init_file PARAMS((const char *, int));
static int glean_key_from_name PARAMS((char *));
static int substring_member_of_array PARAMS((char *, const char **));
d86 1
a86 1
/* rl_add_defun (char *name, rl_command_func_t *function, int key)
d91 2
a92 2
     const char *name;
     rl_command_func_t *function;
d105 1
a105 1
     rl_command_func_t *function;
d136 1
a136 1
     rl_command_func_t *function;
d155 1
a155 1
  return (rl_bind_key (key, (rl_command_func_t *)NULL));
d165 1
a165 1
  return (rl_bind_key_in_map (key, (rl_command_func_t *)NULL, map));
d171 1
a171 1
     rl_command_func_t *func;
d180 1
a180 1
	  map[i].function = (rl_command_func_t *)NULL;
d189 1
a189 1
     const char *command;
d192 1
a192 1
  rl_command_func_t *func;
d205 2
a206 2
     const char *keyseq;
     rl_command_func_t *function;
d217 1
a217 1
     const char *keyseq, *macro;
d242 1
a242 2
     const char *keyseq;
     char *data;
a247 3
  KEYMAP_ENTRY k;

  k.function = 0;
d257 1
a257 1
  keys = (char *)xmalloc (1 + (2 * strlen (keyseq)));
d271 1
a271 6
      unsigned char uc = keys[i];
      int ic;

      ic = uc;
      if (ic < 0 || ic >= KEYMAP_SIZE)
	return -1;
d284 2
a285 8
	      /* We allow subsequences of keys.  If a keymap is being
		 created that will `shadow' an existing function or macro
		 key binding, we save that keybinding into the ANYOTHERKEY
		 index in the new map.  The dispatch code will look there
		 to find the function to execute if the subsequence is not
		 matched.  ANYOTHERKEY was chosen to be greater than
		 UCHAR_MAX. */
	      k = map[ic];
a290 11
	  /* The dispatch code will return this function if no matching
	     key sequence is found in the keymap.  This (with a little
	     help from the dispatch code in readline.c) allows `a' to be
	     mapped to something, `abc' to be mapped to something else,
	     and the function bound  to `a' to be executed when the user
	     types `abx', leaving `bx' in the input queue. */
	  if (k.function /* && k.type == ISFUNC */)
	    {
	      map[ANYOTHERKEY] = k;
	      k.function = 0;
	    }
a295 5
	  else if (map[ic].type == ISKMAP)
	    {
	      map = FUNCTION_TO_KEYMAP (map, ic);
	      ic = ANYOTHERKEY;
	    }
d312 1
a312 2
     const char *seq;
     char *array;
d332 1
a332 1
		  array[l++] = ESC;	/* ESC is meta-prefix */
d341 1
a341 1
		  array[l++] = ESC;	/* ESC is meta-prefix */
d394 1
a394 1
	      array[l++] = c & largest_char;
d398 1
a398 1
	      for (temp = 2, c = 0; ISXDIGIT ((unsigned char)seq[i]) && temp--; i++)
d400 1
a400 1
	      if (temp == 2)
d403 1
a403 1
	      array[l++] = c & largest_char;
d473 1
a473 1
  r = ret = (char *)xmalloc (7 * strlen (seq) + 1);
d516 1
a516 1
rl_command_func_t *
d518 1
a518 1
     const char *string;
d527 1
a527 1
  return ((rl_command_func_t *)NULL);
d535 1
a535 1
rl_command_func_t *
d537 1
a537 1
     const char *keyseq;
d548 1
a548 1
      unsigned char ic = keyseq[i];
d588 1
a588 1
  return ((rl_command_func_t *) NULL);
d595 1
a595 1
static const char *current_readline_init_file;
d633 3
d637 1
d643 5
d651 1
d662 1
a662 1
  r = rl_read_init_file ((const char *)NULL);
d676 1
a676 1
     const char *filename;
d683 1
a683 1
        filename = sh_get_env_value ("INPUTRC");
d701 1
a701 1
     const char *filename;
d736 1
a736 1
#if defined (__CYGWIN__)
d768 1
a768 1
     const char *msg;
a782 11
typedef int _rl_parser_func_t PARAMS((char *));

/* Things that mean `Control'. */
const char *_rl_possible_control_prefixes[] = {
  "Control-", "C-", "CTRL-", (const char *)NULL
};

const char *_rl_possible_meta_prefixes[] = {
  "Meta", "M-", (const char *)NULL
};

d786 1
a786 1
const char *rl_readline_name = "other";
d908 1
a908 2
  const char *old_init_file;
  char *e;
d921 1
a921 1
  r = _rl_read_init_file ((const char *)args, old_include_level + 1);
d932 2
a933 2
  const char *name;
  _rl_parser_func_t *function;
d939 1
a939 1
  { (char *)0x0, (_rl_parser_func_t *)0x0 }
d1064 1
a1064 1
      /* Make VALUE point to start of value string. */
d1134 1
a1134 1
      seq = (char *)xmalloc (1 + strlen (string));
d1183 1
a1183 1
  if (substring_member_of_array (string, _rl_possible_control_prefixes))
d1186 1
a1186 1
  if (substring_member_of_array (string, _rl_possible_meta_prefixes))
d1192 1
a1192 1
      char useq[2];
d1224 1
a1224 1
  const char *name;
a1228 1
  { "byte-oriented",		&rl_byte_oriented,		0 },
a1233 1
  { "history-preserve-point",	&_rl_history_preserve_point,	0 },
a1237 2
  { "mark-symlinked-directories", &_rl_complete_mark_symlink_dirs, 0 },
  { "match-hidden-files",	&_rl_match_hidden_files,	0 },
a1239 1
  { "page-completions",		&_rl_page_completions,		0 },
d1251 1
a1251 1
     const char *name;
d1268 1
a1268 1
  const char *name;
a1282 2
typedef int _rl_sv_func_t PARAMS((const char *));

d1295 6
a1300 6
static int sv_bell_style PARAMS((const char *));
static int sv_combegin PARAMS((const char *));
static int sv_compquery PARAMS((const char *));
static int sv_editmode PARAMS((const char *));
static int sv_isrchterm PARAMS((const char *));
static int sv_keymap PARAMS((const char *));
d1303 1
a1303 1
  const char *name;
d1305 1
a1305 1
  _rl_sv_func_t *set_func;
d1318 1
a1318 1
     const char *name;
d1342 1
a1342 1
     const char *name, *value;
d1370 1
a1370 1
     const char *value;
d1391 1
a1391 1
     const char *value;
d1404 1
a1404 1
     const char *value;
d1420 1
a1420 1
     const char *value;
d1433 2
d1437 1
a1437 1
     const char *value;
d1440 1
a1440 1
    _rl_bell_preference = AUDIBLE_BELL;
d1442 1
a1442 1
    _rl_bell_preference = NO_BELL;
d1444 1
a1444 1
    _rl_bell_preference = AUDIBLE_BELL;
d1446 1
a1446 1
    _rl_bell_preference = VISIBLE_BELL;
a1448 1
  return 0;
d1450 1
d1454 1
a1454 1
     const char *value;
d1480 1
a1480 1
  _rl_isearch_terminators = (char *)xmalloc (2 * strlen (v) + 1);
d1492 1
a1492 1
  const char *name;
d1526 1
a1526 1
  const char *name;
d1544 1
a1544 1
     const char *name;
d1549 1
a1549 1
    if (_rl_stricmp (name, keymap_names[i].name) == 0)
d1561 1
a1561 1
      return ((char *)keymap_names[i].name);
d1619 1
a1619 1
  const char **funmap_names;
d1646 1
a1646 2
#if 1
  /* XXX - Experimental */
d1653 4
a1656 4
      keyname[0] = '\\';
      keyname[1] = 'e';
      keyname[2] = '\0';
      return keyname;
d1709 1
a1709 1
     rl_command_func_t *function;
d1738 1
a1738 1
		  result = (char **)xrealloc (result, result_size * sizeof (char *));
a1766 1
#if 0
a1767 4
#else
		/* XXX - experimental */
		  sprintf (keyname, "\\M-");
#endif
d1790 1
a1790 1
		    result = (char **)xrealloc (result, result_size * sizeof (char *));
d1809 1
a1809 1
     rl_command_func_t *function;
d1822 2
a1823 2
  const char **names;
  const char *name;
d1831 1
a1831 1
      rl_command_func_t *function;
d1914 3
d1918 1
a1918 1

d1928 1
d1930 1
d1938 1
a1938 1
	      keyname = (char *)xmalloc (3 + prefix_len);
d1950 1
a1950 1
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
d1988 1
a1988 1
  const char *kname;
d2020 1
a2020 1
    fprintf (rl_outstream, "comment-begin is set to `%s'\n", _rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);
d2034 9
a2056 9

  /* keymap */
  kname = rl_get_keymap_name (_rl_keymap);
  if (kname == 0)
    kname = rl_get_keymap_name_from_edit_mode ();
  if (print_readably)
    fprintf (rl_outstream, "set keymap %s\n", kname ? kname : "none");
  else
    fprintf (rl_outstream, "keymap is set to `%s'\n", kname ? kname : "none");
d2073 1
a2073 3
/* Bind key sequence KEYSEQ to DEFAULT_FUNC if KEYSEQ is unbound.  Right
   now, this is always used to attempt to bind the arrow keys, hence the
   check for rl_vi_movement_mode. */
d2076 2
a2077 2
     const char *keyseq;
     rl_command_func_t *default_func;
d2079 1
a2079 1
  rl_command_func_t *func;
a2083 3
#if defined (VI_MODE)
      if (!func || func == rl_do_lowercase_version || func == rl_vi_movement_mode)
#else
a2084 1
#endif
d2092 1
a2092 2
     char *string;
     const char **array;
@


1.4.24.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d314 1
a314 1
	  if (k.function && ((k.type == ISFUNC && k.function != rl_do_lowercase_version) || k.type == ISMACR))
@


1.4.22.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d71 3
a73 5
static char *_rl_read_file PARAMS((char *, size_t *));
static void _rl_init_file_error PARAMS((const char *));
static int _rl_read_init_file PARAMS((const char *, int));
static int glean_key_from_name PARAMS((char *));
static int substring_member_of_array PARAMS((char *, const char **));
d86 1
a86 1
/* rl_add_defun (char *name, rl_command_func_t *function, int key)
d91 2
a92 2
     const char *name;
     rl_command_func_t *function;
d105 1
a105 1
     rl_command_func_t *function;
d136 1
a136 1
     rl_command_func_t *function;
d155 1
a155 1
  return (rl_bind_key (key, (rl_command_func_t *)NULL));
d165 1
a165 1
  return (rl_bind_key_in_map (key, (rl_command_func_t *)NULL, map));
d171 1
a171 1
     rl_command_func_t *func;
d180 1
a180 1
	  map[i].function = (rl_command_func_t *)NULL;
d189 1
a189 1
     const char *command;
d192 1
a192 1
  rl_command_func_t *func;
d205 2
a206 2
     const char *keyseq;
     rl_command_func_t *function;
d217 1
a217 1
     const char *keyseq, *macro;
d242 1
a242 2
     const char *keyseq;
     char *data;
a247 3
  KEYMAP_ENTRY k;

  k.function = 0;
d257 1
a257 1
  keys = (char *)xmalloc (1 + (2 * strlen (keyseq)));
d271 1
a271 6
      unsigned char uc = keys[i];
      int ic;

      ic = uc;
      if (ic < 0 || ic >= KEYMAP_SIZE)
	return -1;
d284 2
a285 8
	      /* We allow subsequences of keys.  If a keymap is being
		 created that will `shadow' an existing function or macro
		 key binding, we save that keybinding into the ANYOTHERKEY
		 index in the new map.  The dispatch code will look there
		 to find the function to execute if the subsequence is not
		 matched.  ANYOTHERKEY was chosen to be greater than
		 UCHAR_MAX. */
	      k = map[ic];
a290 11
	  /* The dispatch code will return this function if no matching
	     key sequence is found in the keymap.  This (with a little
	     help from the dispatch code in readline.c) allows `a' to be
	     mapped to something, `abc' to be mapped to something else,
	     and the function bound  to `a' to be executed when the user
	     types `abx', leaving `bx' in the input queue. */
	  if (k.function /* && k.type == ISFUNC */)
	    {
	      map[ANYOTHERKEY] = k;
	      k.function = 0;
	    }
a295 5
	  else if (map[ic].type == ISKMAP)
	    {
	      map = FUNCTION_TO_KEYMAP (map, ic);
	      ic = ANYOTHERKEY;
	    }
d312 1
a312 2
     const char *seq;
     char *array;
d332 1
a332 1
		  array[l++] = ESC;	/* ESC is meta-prefix */
d341 1
a341 1
		  array[l++] = ESC;	/* ESC is meta-prefix */
d394 1
a394 1
	      array[l++] = c & largest_char;
d398 1
a398 1
	      for (temp = 2, c = 0; ISXDIGIT ((unsigned char)seq[i]) && temp--; i++)
d400 1
a400 1
	      if (temp == 2)
d403 1
a403 1
	      array[l++] = c & largest_char;
d473 1
a473 1
  r = ret = (char *)xmalloc (7 * strlen (seq) + 1);
d516 1
a516 1
rl_command_func_t *
d518 1
a518 1
     const char *string;
d527 1
a527 1
  return ((rl_command_func_t *)NULL);
d535 1
a535 1
rl_command_func_t *
d537 1
a537 1
     const char *keyseq;
d548 1
a548 1
      unsigned char ic = keyseq[i];
d588 1
a588 1
  return ((rl_command_func_t *) NULL);
d595 1
a595 1
static const char *current_readline_init_file;
d633 3
d637 1
d643 5
d651 1
d662 1
a662 1
  r = rl_read_init_file ((const char *)NULL);
d676 1
a676 1
     const char *filename;
d683 1
a683 1
        filename = sh_get_env_value ("INPUTRC");
d701 1
a701 1
     const char *filename;
d736 1
a736 1
#if defined (__CYGWIN__)
d768 1
a768 1
     const char *msg;
a782 11
typedef int _rl_parser_func_t PARAMS((char *));

/* Things that mean `Control'. */
const char *_rl_possible_control_prefixes[] = {
  "Control-", "C-", "CTRL-", (const char *)NULL
};

const char *_rl_possible_meta_prefixes[] = {
  "Meta", "M-", (const char *)NULL
};

d786 1
a786 1
const char *rl_readline_name = "other";
d908 1
a908 2
  const char *old_init_file;
  char *e;
d921 1
a921 1
  r = _rl_read_init_file ((const char *)args, old_include_level + 1);
d932 2
a933 2
  const char *name;
  _rl_parser_func_t *function;
d939 1
a939 1
  { (char *)0x0, (_rl_parser_func_t *)0x0 }
d1064 1
a1064 1
      /* Make VALUE point to start of value string. */
d1134 1
a1134 1
      seq = (char *)xmalloc (1 + strlen (string));
d1183 1
a1183 1
  if (substring_member_of_array (string, _rl_possible_control_prefixes))
d1186 1
a1186 1
  if (substring_member_of_array (string, _rl_possible_meta_prefixes))
d1192 1
a1192 1
      char useq[2];
d1224 1
a1224 1
  const char *name;
a1228 1
  { "byte-oriented",		&rl_byte_oriented,		0 },
a1233 1
  { "history-preserve-point",	&_rl_history_preserve_point,	0 },
a1237 2
  { "mark-symlinked-directories", &_rl_complete_mark_symlink_dirs, 0 },
  { "match-hidden-files",	&_rl_match_hidden_files,	0 },
a1239 1
  { "page-completions",		&_rl_page_completions,		0 },
d1251 1
a1251 1
     const char *name;
d1268 1
a1268 1
  const char *name;
a1282 2
typedef int _rl_sv_func_t PARAMS((const char *));

d1295 6
a1300 6
static int sv_bell_style PARAMS((const char *));
static int sv_combegin PARAMS((const char *));
static int sv_compquery PARAMS((const char *));
static int sv_editmode PARAMS((const char *));
static int sv_isrchterm PARAMS((const char *));
static int sv_keymap PARAMS((const char *));
d1303 1
a1303 1
  const char *name;
d1305 1
a1305 1
  _rl_sv_func_t *set_func;
d1318 1
a1318 1
     const char *name;
d1342 1
a1342 1
     const char *name, *value;
d1370 1
a1370 1
     const char *value;
d1391 1
a1391 1
     const char *value;
d1404 1
a1404 1
     const char *value;
d1420 1
a1420 1
     const char *value;
d1433 2
d1437 1
a1437 1
     const char *value;
d1440 1
a1440 1
    _rl_bell_preference = AUDIBLE_BELL;
d1442 1
a1442 1
    _rl_bell_preference = NO_BELL;
d1444 1
a1444 1
    _rl_bell_preference = AUDIBLE_BELL;
d1446 1
a1446 1
    _rl_bell_preference = VISIBLE_BELL;
a1448 1
  return 0;
d1450 1
d1454 1
a1454 1
     const char *value;
d1480 1
a1480 1
  _rl_isearch_terminators = (char *)xmalloc (2 * strlen (v) + 1);
d1492 1
a1492 1
  const char *name;
d1526 1
a1526 1
  const char *name;
d1544 1
a1544 1
     const char *name;
d1549 1
a1549 1
    if (_rl_stricmp (name, keymap_names[i].name) == 0)
d1561 1
a1561 1
      return ((char *)keymap_names[i].name);
d1619 1
a1619 1
  const char **funmap_names;
d1646 1
a1646 2
#if 1
  /* XXX - Experimental */
d1653 4
a1656 4
      keyname[0] = '\\';
      keyname[1] = 'e';
      keyname[2] = '\0';
      return keyname;
d1709 1
a1709 1
     rl_command_func_t *function;
d1738 1
a1738 1
		  result = (char **)xrealloc (result, result_size * sizeof (char *));
a1766 1
#if 0
a1767 4
#else
		/* XXX - experimental */
		  sprintf (keyname, "\\M-");
#endif
d1790 1
a1790 1
		    result = (char **)xrealloc (result, result_size * sizeof (char *));
d1809 1
a1809 1
     rl_command_func_t *function;
d1822 2
a1823 2
  const char **names;
  const char *name;
d1831 1
a1831 1
      rl_command_func_t *function;
d1914 3
d1918 1
a1918 1

d1928 1
d1930 1
d1938 1
a1938 1
	      keyname = (char *)xmalloc (3 + prefix_len);
d1950 1
a1950 1
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
d1988 1
a1988 1
  const char *kname;
d2020 1
a2020 1
    fprintf (rl_outstream, "comment-begin is set to `%s'\n", _rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);
d2034 9
a2056 9

  /* keymap */
  kname = rl_get_keymap_name (_rl_keymap);
  if (kname == 0)
    kname = rl_get_keymap_name_from_edit_mode ();
  if (print_readably)
    fprintf (rl_outstream, "set keymap %s\n", kname ? kname : "none");
  else
    fprintf (rl_outstream, "keymap is set to `%s'\n", kname ? kname : "none");
d2073 1
a2073 3
/* Bind key sequence KEYSEQ to DEFAULT_FUNC if KEYSEQ is unbound.  Right
   now, this is always used to attempt to bind the arrow keys, hence the
   check for rl_vi_movement_mode. */
d2076 2
a2077 2
     const char *keyseq;
     rl_command_func_t *default_func;
d2079 1
a2079 1
  rl_command_func_t *func;
a2083 3
#if defined (VI_MODE)
      if (!func || func == rl_do_lowercase_version || func == rl_vi_movement_mode)
#else
a2084 1
#endif
d2092 1
a2092 2
     char *string;
     const char **array;
@


1.4.16.1
log
@2002-08-24  Elena Zannoni  <ezannoni@@redhat.com>

        Import of readline 4.3:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@d71 3
a73 5
static char *_rl_read_file PARAMS((char *, size_t *));
static void _rl_init_file_error PARAMS((const char *));
static int _rl_read_init_file PARAMS((const char *, int));
static int glean_key_from_name PARAMS((char *));
static int substring_member_of_array PARAMS((char *, const char **));
d86 1
a86 1
/* rl_add_defun (char *name, rl_command_func_t *function, int key)
d91 2
a92 2
     const char *name;
     rl_command_func_t *function;
d105 1
a105 1
     rl_command_func_t *function;
d136 1
a136 1
     rl_command_func_t *function;
d155 1
a155 1
  return (rl_bind_key (key, (rl_command_func_t *)NULL));
d165 1
a165 1
  return (rl_bind_key_in_map (key, (rl_command_func_t *)NULL, map));
d171 1
a171 1
     rl_command_func_t *func;
d180 1
a180 1
	  map[i].function = (rl_command_func_t *)NULL;
d189 1
a189 1
     const char *command;
d192 1
a192 1
  rl_command_func_t *func;
d205 2
a206 2
     const char *keyseq;
     rl_command_func_t *function;
d217 1
a217 1
     const char *keyseq, *macro;
d242 1
a242 2
     const char *keyseq;
     char *data;
a247 3
  KEYMAP_ENTRY k;

  k.function = 0;
d257 1
a257 1
  keys = (char *)xmalloc (1 + (2 * strlen (keyseq)));
d271 1
a271 6
      unsigned char uc = keys[i];
      int ic;

      ic = uc;
      if (ic < 0 || ic >= KEYMAP_SIZE)
	return -1;
d284 2
a285 8
	      /* We allow subsequences of keys.  If a keymap is being
		 created that will `shadow' an existing function or macro
		 key binding, we save that keybinding into the ANYOTHERKEY
		 index in the new map.  The dispatch code will look there
		 to find the function to execute if the subsequence is not
		 matched.  ANYOTHERKEY was chosen to be greater than
		 UCHAR_MAX. */
	      k = map[ic];
a290 11
	  /* The dispatch code will return this function if no matching
	     key sequence is found in the keymap.  This (with a little
	     help from the dispatch code in readline.c) allows `a' to be
	     mapped to something, `abc' to be mapped to something else,
	     and the function bound  to `a' to be executed when the user
	     types `abx', leaving `bx' in the input queue. */
	  if (k.function /* && k.type == ISFUNC */)
	    {
	      map[ANYOTHERKEY] = k;
	      k.function = 0;
	    }
a295 5
	  else if (map[ic].type == ISKMAP)
	    {
	      map = FUNCTION_TO_KEYMAP (map, ic);
	      ic = ANYOTHERKEY;
	    }
d312 1
a312 2
     const char *seq;
     char *array;
d332 1
a332 1
		  array[l++] = ESC;	/* ESC is meta-prefix */
d341 1
a341 1
		  array[l++] = ESC;	/* ESC is meta-prefix */
d394 1
a394 1
	      array[l++] = c & largest_char;
d398 1
a398 1
	      for (temp = 2, c = 0; ISXDIGIT ((unsigned char)seq[i]) && temp--; i++)
d400 1
a400 1
	      if (temp == 2)
d403 1
a403 1
	      array[l++] = c & largest_char;
d473 1
a473 1
  r = ret = (char *)xmalloc (7 * strlen (seq) + 1);
d516 1
a516 1
rl_command_func_t *
d518 1
a518 1
     const char *string;
d527 1
a527 1
  return ((rl_command_func_t *)NULL);
d535 1
a535 1
rl_command_func_t *
d537 1
a537 1
     const char *keyseq;
d548 1
a548 1
      unsigned char ic = keyseq[i];
d588 1
a588 1
  return ((rl_command_func_t *) NULL);
d595 1
a595 1
static const char *current_readline_init_file;
d633 3
d637 1
d643 5
d651 1
d662 1
a662 1
  r = rl_read_init_file ((const char *)NULL);
d676 1
a676 1
     const char *filename;
d683 1
a683 1
        filename = sh_get_env_value ("INPUTRC");
d701 1
a701 1
     const char *filename;
d736 1
a736 1
#if defined (__CYGWIN__)
d768 1
a768 1
     const char *msg;
a782 11
typedef int _rl_parser_func_t PARAMS((char *));

/* Things that mean `Control'. */
const char *_rl_possible_control_prefixes[] = {
  "Control-", "C-", "CTRL-", (const char *)NULL
};

const char *_rl_possible_meta_prefixes[] = {
  "Meta", "M-", (const char *)NULL
};

d786 1
a786 1
const char *rl_readline_name = "other";
d908 1
a908 2
  const char *old_init_file;
  char *e;
d921 1
a921 1
  r = _rl_read_init_file ((const char *)args, old_include_level + 1);
d932 2
a933 2
  const char *name;
  _rl_parser_func_t *function;
d939 1
a939 1
  { (char *)0x0, (_rl_parser_func_t *)0x0 }
d1064 1
a1064 1
      /* Make VALUE point to start of value string. */
d1134 1
a1134 1
      seq = (char *)xmalloc (1 + strlen (string));
d1183 1
a1183 1
  if (substring_member_of_array (string, _rl_possible_control_prefixes))
d1186 1
a1186 1
  if (substring_member_of_array (string, _rl_possible_meta_prefixes))
d1192 1
a1192 1
      char useq[2];
d1224 1
a1224 1
  const char *name;
a1228 1
  { "byte-oriented",		&rl_byte_oriented,		0 },
a1233 1
  { "history-preserve-point",	&_rl_history_preserve_point,	0 },
a1237 2
  { "mark-symlinked-directories", &_rl_complete_mark_symlink_dirs, 0 },
  { "match-hidden-files",	&_rl_match_hidden_files,	0 },
a1239 1
  { "page-completions",		&_rl_page_completions,		0 },
d1251 1
a1251 1
     const char *name;
d1268 1
a1268 1
  const char *name;
a1282 2
typedef int _rl_sv_func_t PARAMS((const char *));

d1295 6
a1300 6
static int sv_bell_style PARAMS((const char *));
static int sv_combegin PARAMS((const char *));
static int sv_compquery PARAMS((const char *));
static int sv_editmode PARAMS((const char *));
static int sv_isrchterm PARAMS((const char *));
static int sv_keymap PARAMS((const char *));
d1303 1
a1303 1
  const char *name;
d1305 1
a1305 1
  _rl_sv_func_t *set_func;
d1318 1
a1318 1
     const char *name;
d1342 1
a1342 1
     const char *name, *value;
d1370 1
a1370 1
     const char *value;
d1391 1
a1391 1
     const char *value;
d1404 1
a1404 1
     const char *value;
d1420 1
a1420 1
     const char *value;
d1433 2
d1437 1
a1437 1
     const char *value;
d1440 1
a1440 1
    _rl_bell_preference = AUDIBLE_BELL;
d1442 1
a1442 1
    _rl_bell_preference = NO_BELL;
d1444 1
a1444 1
    _rl_bell_preference = AUDIBLE_BELL;
d1446 1
a1446 1
    _rl_bell_preference = VISIBLE_BELL;
a1448 1
  return 0;
d1450 1
d1454 1
a1454 1
     const char *value;
d1480 1
a1480 1
  _rl_isearch_terminators = (char *)xmalloc (2 * strlen (v) + 1);
d1492 1
a1492 1
  const char *name;
d1526 1
a1526 1
  const char *name;
d1544 1
a1544 1
     const char *name;
d1549 1
a1549 1
    if (_rl_stricmp (name, keymap_names[i].name) == 0)
d1561 1
a1561 1
      return ((char *)keymap_names[i].name);
d1619 1
a1619 1
  const char **funmap_names;
d1646 1
a1646 2
#if 1
  /* XXX - Experimental */
d1653 4
a1656 4
      keyname[0] = '\\';
      keyname[1] = 'e';
      keyname[2] = '\0';
      return keyname;
d1709 1
a1709 1
     rl_command_func_t *function;
d1738 1
a1738 1
		  result = (char **)xrealloc (result, result_size * sizeof (char *));
a1766 1
#if 0
a1767 4
#else
		/* XXX - experimental */
		  sprintf (keyname, "\\M-");
#endif
d1790 1
a1790 1
		    result = (char **)xrealloc (result, result_size * sizeof (char *));
d1809 1
a1809 1
     rl_command_func_t *function;
d1822 2
a1823 2
  const char **names;
  const char *name;
d1831 1
a1831 1
      rl_command_func_t *function;
d1914 3
d1918 1
a1918 1

d1928 1
d1930 1
d1938 1
a1938 1
	      keyname = (char *)xmalloc (3 + prefix_len);
d1950 1
a1950 1
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
d1988 1
a1988 1
  const char *kname;
d2020 1
a2020 1
    fprintf (rl_outstream, "comment-begin is set to `%s'\n", _rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);
d2034 9
a2056 9

  /* keymap */
  kname = rl_get_keymap_name (_rl_keymap);
  if (kname == 0)
    kname = rl_get_keymap_name_from_edit_mode ();
  if (print_readably)
    fprintf (rl_outstream, "set keymap %s\n", kname ? kname : "none");
  else
    fprintf (rl_outstream, "keymap is set to `%s'\n", kname ? kname : "none");
d2073 1
a2073 3
/* Bind key sequence KEYSEQ to DEFAULT_FUNC if KEYSEQ is unbound.  Right
   now, this is always used to attempt to bind the arrow keys, hence the
   check for rl_vi_movement_mode. */
d2076 2
a2077 2
     const char *keyseq;
     rl_command_func_t *default_func;
d2079 1
a2079 1
  rl_command_func_t *func;
a2083 3
#if defined (VI_MODE)
      if (!func || func == rl_do_lowercase_version || func == rl_vi_movement_mode)
#else
a2084 1
#endif
d2092 1
a2092 2
     char *string;
     const char **array;
@


1.3
log
@Dummy commit before importof 4.1 version
@
text
@d10 1
a10 1
   as published by the Free Software Foundation; either version 1, or
d21 1
a21 1
   675 Mass Ave, Cambridge, MA 02139, USA. */
a44 1
#include <signal.h>
d60 4
a67 44
#ifndef O_BINARY
# define O_BINARY 0
#endif

extern int _rl_horizontal_scroll_mode;
extern int _rl_mark_modified_lines;
extern int _rl_bell_preference;
extern int _rl_meta_flag;
extern int _rl_convert_meta_chars_to_ascii;
extern int _rl_output_meta_chars;
extern int _rl_complete_show_all;
extern int _rl_complete_mark_directories;
extern int _rl_print_completions_horizontally;
extern int _rl_completion_case_fold;
extern int _rl_enable_keypad;
#if defined (PAREN_MATCHING)
extern int rl_blink_matching_paren;
#endif /* PAREN_MATCHING */
#if defined (VISIBLE_STATS)
extern int rl_visible_stats;
#endif /* VISIBLE_STATS */
extern int rl_complete_with_tilde_expansion;
extern int rl_completion_query_items;
extern int rl_inhibit_completion;
extern char *_rl_comment_begin;
extern unsigned char *_rl_isearch_terminators;

extern int rl_explicit_arg;
extern int rl_editing_mode;
extern unsigned char _rl_parsing_conditionalized_out;
extern Keymap _rl_keymap;

extern char *possible_control_prefixes[], *possible_meta_prefixes[];

/* Functions imported from funmap.c */
extern char **rl_funmap_names ();
extern int rl_add_funmap_entry ();

/* Functions imported from util.c */
extern char *_rl_strindex ();

/* Functions imported from shell.c */
extern char *get_env_value ();

d71 3
a73 2
/* Forward declarations */
void rl_set_keymap_from_edit_mode ();
d75 1
a75 3
static int _rl_read_init_file ();
static int glean_key_from_name ();
static int substring_member_of_array ();
d77 2
a78 1
extern char *xmalloc (), *xrealloc ();
d612 1
a612 1
  if ((stat (filename, &finfo) < 0) || (file = open (filename, O_RDONLY | O_BINARY, 0666)) < 0)
d633 1
a633 1
#if 1
d643 1
d645 6
a650 22

#if O_BINARY
  {
    /* Systems which distinguish between text and binary files need
       to strip the CR characters before each Newline, otherwise the
       parsing functions won't work.  */
    char *s, *d;
    size_t removed = 0;

    for (s = buffer, d = buffer; s < buffer + file_size; s++)
      {
	if (removed)
	  *d = *s;
	if (*s != '\r' || s[1] != '\n')
	  d++;
	else
	  removed++;
      }

    file_size -= removed;
    buffer[file_size] = '\0';
  }
a652 2
  if (sizep)
    *sizep = file_size;
a671 1
     4. (for __MSDOS__ only) ~/_inputrc
d691 4
a694 12
#ifdef __MSDOS__
  {
    /* DOS doesn't allow leading dots in file names.  If the original
       name fails (it could work if we are on Windows), fall back to
       ~/_inputrc.  */
    int retval = _rl_read_init_file (filename, 0);

    if (retval == 0)
      return retval;
    else if (strcmp (filename, "~/.inputrc") == 0)
      filename = "~/_inputrc";
  }
a695 1

d724 2
d736 6
d762 1
d770 5
a774 3
  fprintf (stderr, "readline: %s: line %d: %s\n", current_readline_init_file,
 		   current_readline_init_lineno,
 		   msg);
d1221 2
d1226 1
d1228 15
a1242 16
#if defined (PAREN_MATCHING)
  { "blink-matching-paren",	&rl_blink_matching_paren },
#endif
  { "completion-ignore-case",	&_rl_completion_case_fold },
  { "convert-meta",		&_rl_convert_meta_chars_to_ascii },
  { "disable-completion",	&rl_inhibit_completion },
  { "enable-keypad",		&_rl_enable_keypad },
  { "expand-tilde",		&rl_complete_with_tilde_expansion },
  { "horizontal-scroll-mode",	&_rl_horizontal_scroll_mode },
  { "input-meta",		&_rl_meta_flag },
  { "mark-directories",		&_rl_complete_mark_directories },
  { "mark-modified-lines",	&_rl_mark_modified_lines },
  { "meta-flag",		&_rl_meta_flag },
  { "output-meta",		&_rl_output_meta_chars },
  { "print-completions-horizontally", &_rl_print_completions_horizontally },
  { "show-all-if-ambiguous",	&_rl_complete_show_all },
d1244 1
a1244 1
  { "visible-stats",		&rl_visible_stats },
d1249 91
d1345 1
d1348 2
a1349 1
  for (i = 0; boolean_varlist[i].name; i++)
d1351 4
a1354 8
      if (_rl_stricmp (name, boolean_varlist[i].name) == 0)
	{
	  /* A variable is TRUE if the "value" is "on", "1" or "". */
	  *boolean_varlist[i].value = *value == 0 ||
	  			      _rl_stricmp (value, "on") == 0 ||
				      (value[0] == '1' && value[1] == '\0');
	  return 0;
	}
d1357 10
a1366 1
  /* Not a boolean variable, so check for specials. */
d1368 5
a1372 2
  /* Editing mode change? */
  if (_rl_stricmp (name, "editing-mode") == 0)
a1373 2
      if (_rl_strnicmp (value, "vi", 2) == 0)
	{
d1375 2
a1376 2
	  _rl_keymap = vi_insertion_keymap;
	  rl_editing_mode = vi_mode;
d1378 7
a1384 6
	}
      else if (_rl_strnicmp (value, "emacs", 5) == 0)
	{
	  _rl_keymap = emacs_standard_keymap;
	  rl_editing_mode = emacs_mode;
	}
d1386 2
d1389 5
a1393 2
  /* Comment string change? */
  else if (_rl_stricmp (name, "comment-begin") == 0)
d1395 12
a1406 4
      if (*value)
	{
	  if (_rl_comment_begin)
	    free (_rl_comment_begin);
d1408 1
a1408 4
	  _rl_comment_begin = savestring (value);
	}
    }
  else if (_rl_stricmp (name, "completion-query-items") == 0)
d1410 3
a1412 8
      int nval = 100;
      if (*value)
	{
	  nval = atoi (value);
	  if (nval < 0)
	    nval = 0;
	}
      rl_completion_query_items = nval;
d1414 12
a1425 1
  else if (_rl_stricmp (name, "keymap") == 0)
d1427 2
a1428 4
      Keymap kmap;
      kmap = rl_get_keymap_by_name (value);
      if (kmap)
        rl_set_keymap (kmap);
d1430 40
a1469 13
  else if (_rl_stricmp (name, "bell-style") == 0)
    {
      if (!*value)
        _rl_bell_preference = AUDIBLE_BELL;
      else
        {
          if (_rl_stricmp (value, "none") == 0 || _rl_stricmp (value, "off") == 0)
            _rl_bell_preference = NO_BELL;
          else if (_rl_stricmp (value, "audible") == 0 || _rl_stricmp (value, "on") == 0)
            _rl_bell_preference = AUDIBLE_BELL;
          else if (_rl_stricmp (value, "visible") == 0)
            _rl_bell_preference = VISIBLE_BELL;
        }
d1471 1
a1471 1
  else if (_rl_stricmp (name, "prefer-visible-bell") == 0)
d1473 2
a1474 6
      /* Backwards compatibility. */
      if (*value && (_rl_stricmp (value, "on") == 0 ||
		     (*value == '1' && !value[1])))
        _rl_bell_preference = VISIBLE_BELL;
      else
        _rl_bell_preference = AUDIBLE_BELL;
a1475 5
  else if (_rl_stricmp (name, "isearch-terminators") == 0)
    {
      /* Isolate the value and translate it into a character string. */
      int beg, end;
      char *v;
d1477 6
a1482 13
      v = savestring (value);
      FREE (_rl_isearch_terminators);
      if (v[0] == '"' || v[0] == '\'')
	{
	  int delim = v[0];
	  for (beg = end = 1; v[end] && v[end] != delim; end++)
	    ;
	}
      else
	{
	  for (beg = end = 0; whitespace (v[end]) == 0; end++)
	    ;
	}
d1484 1
a1484 9
      v[end] = '\0';
      /* The value starts at v + beg.  Translate it into a character string. */
      _rl_isearch_terminators = (unsigned char *)xmalloc (2 * strlen (v) + 1);
      rl_translate_keyseq (v + beg, _rl_isearch_terminators, &end);
      _rl_isearch_terminators[end] = '\0';
      free (v);
    }
      
  /* For the time being, unknown variable names are simply ignored. */
d1487 1
a1487 1

@


1.2
log
@(_rl_read_file): Use O_BINARY in open.  Enable the test for incomplete
read.  Strip the CR characters by hand after readin the file.
(rl_read_init_file): Allow for ~/_intputrc on 8+3 filesystems.
@
text
@@


1.1
log
@Initial revision
@
text
@d65 4
d90 1
d215 1
a215 1
  register int i;
d217 1
a217 1
  for (i = 0; i < KEYMAP_SIZE; i++)
d220 4
a223 1
	map[i].function = (Function *)NULL;
d225 1
a233 1
  register int i;
d653 1
a653 1
  if ((stat (filename, &finfo) < 0) || (file = open (filename, O_RDONLY, 0666)) < 0)
d674 1
d676 3
d685 24
d730 1
d750 14
d781 2
d1394 19
d1414 8
d1575 1
a1575 1
  int i, c, v;
d1980 15
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-08-02 snapshot
@
text
@a85 1
extern unsigned char *_rl_isearch_terminators;
d210 1
a210 1
  register int i, rval;
d212 1
a212 1
  for (i = rval = 0; i < KEYMAP_SIZE; i++)
d215 1
a215 4
	{
	  map[i].function = (Function *)NULL;
	  rval = 1;
	}
a216 1
  return rval;
d225 1
a665 1
#if 0
a666 3
#else
  if (i < 0)
#endif
a729 2
  free (openname);

a1340 19
  else if (_rl_stricmp (name, "isearch-terminators") == 0)
    {
      /* Isolate the value and translate it into a character string. */
      int beg, end;
      char *v;

      v = savestring (value);
      FREE (_rl_isearch_terminators);
      if (v[0] == '"' || v[0] == '\'')
	{
	  int delim = v[0];
	  for (beg = end = 1; v[end] && v[end] != delim; end++)
	    ;
	}
      else
	{
	  for (beg = end = 0; whitespace (v[end]) == 0; end++)
	    ;
	}
a1341 8
      v[end] = '\0';
      /* The value starts at v + beg.  Translate it into a character string. */
      _rl_isearch_terminators = (unsigned char *)xmalloc (2 * strlen (v) + 1);
      rl_translate_keyseq (v + beg, _rl_isearch_terminators, &end);
      _rl_isearch_terminators[end] = '\0';
      free (v);
    }
      
d1495 1
a1495 1
  int i, c;
a1899 15

  /* isearch-terminators */
  if (_rl_isearch_terminators)
    {
      char *disp;

      disp = _rl_untranslate_macro_value (_rl_isearch_terminators);

      if (print_readably)
	fprintf (rl_outstream, "set isearch-terminators \"%s\"\n", disp);
      else
	fprintf (rl_outstream, "isearch-terminators is set to \"%s\"\n", disp);

      free (disp);
    }
@


1.1.1.3
log
@Import of readline 4.1
@
text
@d10 1
a10 1
   as published by the Free Software Foundation; either version 2, or
d21 1
a21 1
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
d45 1
a60 4
#include "rlprivate.h"
#include "rlshell.h"
#include "xmalloc.h"

d65 40
d108 2
a109 3
static int _rl_read_init_file __P((char *, int));
static int glean_key_from_name __P((char *));
static int substring_member_of_array __P((char *, char **));
d111 3
a113 1
static int currently_reading_init_file;
d115 1
a115 2
/* used only in this file */
static int _rl_prefer_visible_bell = 1;
a679 1
#if 0
a682 6
#else
  buffer[i] = '\0';
  if (sizep)
    *sizep = i;
#endif

a720 5
#if defined (__MSDOS__)
  if (_rl_read_init_file (filename, 0) == 0)
    return 0;
  filename = "~/_inputrc";
#endif
a748 2
  currently_reading_init_file = 1;

a758 6
#if defined (__CYGWIN32__)
      /* ``Be liberal in what you accept.'' */
      if (line[i] == '\n' && line[i-1] == '\r')
	line[i - 1] = '\0';
#endif

a778 1
  currently_reading_init_file = 0;
d786 3
a788 5
  if (currently_reading_init_file)
    fprintf (stderr, "readline: %s: line %d: %s\n", current_readline_init_file,
		     current_readline_init_lineno, msg);
  else
    fprintf (stderr, "readline: %s\n", msg);
a1234 2
#define V_SPECIAL	0x1

a1237 1
  int flags;
d1239 16
a1254 15
  { "blink-matching-paren",	&rl_blink_matching_paren,	V_SPECIAL },
  { "completion-ignore-case",	&_rl_completion_case_fold,	0 },
  { "convert-meta",		&_rl_convert_meta_chars_to_ascii, 0 },
  { "disable-completion",	&rl_inhibit_completion,		0 },
  { "enable-keypad",		&_rl_enable_keypad,		0 },
  { "expand-tilde",		&rl_complete_with_tilde_expansion, 0 },
  { "horizontal-scroll-mode",	&_rl_horizontal_scroll_mode,	0 },
  { "input-meta",		&_rl_meta_flag,			0 },
  { "mark-directories",		&_rl_complete_mark_directories,	0 },
  { "mark-modified-lines",	&_rl_mark_modified_lines,	0 },
  { "meta-flag",		&_rl_meta_flag,			0 },
  { "output-meta",		&_rl_output_meta_chars,		0 },
  { "prefer-visible-bell",	&_rl_prefer_visible_bell,	V_SPECIAL },
  { "print-completions-horizontally", &_rl_print_completions_horizontally, 0 },
  { "show-all-if-ambiguous",	&_rl_complete_show_all,		0 },
d1256 1
a1256 1
  { "visible-stats",		&rl_visible_stats,		0 },
a1260 91
static int
find_boolean_var (name)
     char *name;
{
  register int i;

  for (i = 0; boolean_varlist[i].name; i++)
    if (_rl_stricmp (name, boolean_varlist[i].name) == 0)
      return i;
  return -1;
}

/* Hooks for handling special boolean variables, where a
   function needs to be called or another variable needs
   to be changed when they're changed. */
static void
hack_special_boolean_var (i)
     int i;
{
  char *name;

  name = boolean_varlist[i].name;

  if (_rl_stricmp (name, "blink-matching-paren") == 0)
    _rl_enable_paren_matching (rl_blink_matching_paren);
  else if (_rl_stricmp (name, "prefer-visible-bell") == 0)
    {
      if (_rl_prefer_visible_bell)
	_rl_bell_preference = VISIBLE_BELL;
      else
	_rl_bell_preference = AUDIBLE_BELL;
    }
}

/* These *must* correspond to the array indices for the appropriate
   string variable.  (Though they're not used right now.) */
#define V_BELLSTYLE	0
#define V_COMBEGIN	1
#define V_EDITMODE	2
#define V_ISRCHTERM	3
#define V_KEYMAP	4

#define	V_STRING	1
#define V_INT		2

/* Forward declarations */
static int sv_bell_style __P((char *));
static int sv_combegin __P((char *));
static int sv_compquery __P((char *));
static int sv_editmode __P((char *));
static int sv_isrchterm __P((char *));
static int sv_keymap __P((char *));

static struct {
  char *name;
  int flags;
  Function *set_func;
} string_varlist[] = {
  { "bell-style",	V_STRING,	sv_bell_style },
  { "comment-begin",	V_STRING,	sv_combegin },
  { "completion-query-items", V_INT,	sv_compquery },
  { "editing-mode",	V_STRING,	sv_editmode },
  { "isearch-terminators", V_STRING,	sv_isrchterm },
  { "keymap",		V_STRING,	sv_keymap },
  { (char *)NULL,	0 }
};

static int
find_string_var (name)
     char *name;
{
  register int i;

  for (i = 0; string_varlist[i].name; i++)
    if (_rl_stricmp (name, string_varlist[i].name) == 0)
      return i;
  return -1;
}

/* A boolean value that can appear in a `set variable' command is true if
   the value is null or empty, `on' (case-insenstive), or "1".  Any other
   values result in 0 (false). */
static int
bool_to_int (value)
     char *value;
{
  return (value == 0 || *value == '\0' ||
		(_rl_stricmp (value, "on") == 0) ||
		(value[0] == '1' && value[1] == '\0'));
}

a1265 1
  int	v;
d1268 1
a1268 2
  i = find_boolean_var (name);
  if (i >= 0)
d1270 8
a1277 4
      *boolean_varlist[i].value = bool_to_int (value);
      if (boolean_varlist[i].flags & V_SPECIAL)
	hack_special_boolean_var (i);
      return 0;
d1280 1
a1280 6
  i = find_string_var (name);

  /* For the time being, unknown variable names or string names without a
     handler function are simply ignored. */
  if (i < 0 || string_varlist[i].set_func == 0)
    return 0;
d1282 2
a1283 9
  v = (*string_varlist[i].set_func) (value);
  return v;
}

static int
sv_editmode (value)
     char *value;
{
  if (_rl_strnicmp (value, "vi", 2) == 0)
d1285 2
d1288 2
a1289 2
      _rl_keymap = vi_insertion_keymap;
      rl_editing_mode = vi_mode;
d1291 6
a1296 1
      return 0;
d1298 3
a1300 1
  else if (_rl_strnicmp (value, "emacs", 5) == 0)
d1302 7
a1308 3
      _rl_keymap = emacs_standard_keymap;
      rl_editing_mode = emacs_mode;
      return 0;
d1310 1
a1310 8
  return 1;
}

static int
sv_combegin (value)
     char *value;
{
  if (value && *value)
d1312 8
a1319 3
      FREE (_rl_comment_begin);
      _rl_comment_begin = savestring (value);
      return 0;
d1321 1
a1321 10
  return 1;
}

static int
sv_compquery (value)
     char *value;
{
  int nval = 100;

  if (value && *value)
d1323 4
a1326 3
      nval = atoi (value);
      if (nval < 0)
	nval = 0;
d1328 1
a1328 12
  rl_completion_query_items = nval;
  return 0;
}

static int
sv_keymap (value)
     char *value;
{
  Keymap kmap;

  kmap = rl_get_keymap_by_name (value);
  if (kmap)
d1330 11
a1340 2
      rl_set_keymap (kmap);
      return 0;
d1342 8
a1349 40
  return 1;
}

#define _SET_BELL(v)	do { _rl_bell_preference = v; return 0; } while (0)

static int
sv_bell_style (value)
     char *value;
{
  if (value == 0 || *value == '\0')
    _SET_BELL (AUDIBLE_BELL);
  else if (_rl_stricmp (value, "none") == 0 || _rl_stricmp (value, "off") == 0)
    _SET_BELL (NO_BELL);
  else if (_rl_stricmp (value, "audible") == 0 || _rl_stricmp (value, "on") == 0)
    _SET_BELL (AUDIBLE_BELL);
  else if (_rl_stricmp (value, "visible") == 0)
    _SET_BELL (VISIBLE_BELL);
  else
    return 1;
}
#undef _SET_BELL

static int
sv_isrchterm (value)
     char *value;
{
  int beg, end, delim;
  char *v;

  if (value == 0)
    return 1;

  /* Isolate the value and translate it into a character string. */
  v = savestring (value);
  FREE (_rl_isearch_terminators);
  if (v[0] == '"' || v[0] == '\'')
    {
      delim = v[0];
      for (beg = end = 1; v[end] && v[end] != delim; end++)
	;
d1351 1
a1351 1
  else
d1353 3
a1355 3
      for (beg = end = 0; whitespace (v[end]) == 0; end++)
	;
    }
d1357 13
a1369 1
  v[end] = '\0';
d1371 9
a1379 6
  /* The value starts at v + beg.  Translate it into a character string. */
  _rl_isearch_terminators = (unsigned char *)xmalloc (2 * strlen (v) + 1);
  rl_translate_keyseq (v + beg, _rl_isearch_terminators, &end);
  _rl_isearch_terminators[end] = '\0';

  free (v);
d1382 1
a1382 1
      
@


1.1.1.4
log
@import of readline-4.3
@
text
@d71 3
a73 5
static char *_rl_read_file PARAMS((char *, size_t *));
static void _rl_init_file_error PARAMS((const char *));
static int _rl_read_init_file PARAMS((const char *, int));
static int glean_key_from_name PARAMS((char *));
static int substring_member_of_array PARAMS((char *, const char **));
d86 1
a86 1
/* rl_add_defun (char *name, rl_command_func_t *function, int key)
d91 2
a92 2
     const char *name;
     rl_command_func_t *function;
d105 1
a105 1
     rl_command_func_t *function;
d136 1
a136 1
     rl_command_func_t *function;
d155 1
a155 1
  return (rl_bind_key (key, (rl_command_func_t *)NULL));
d165 1
a165 1
  return (rl_bind_key_in_map (key, (rl_command_func_t *)NULL, map));
d171 1
a171 1
     rl_command_func_t *func;
d180 1
a180 1
	  map[i].function = (rl_command_func_t *)NULL;
d189 1
a189 1
     const char *command;
d192 1
a192 1
  rl_command_func_t *func;
d205 2
a206 2
     const char *keyseq;
     rl_command_func_t *function;
d217 1
a217 1
     const char *keyseq, *macro;
d242 1
a242 2
     const char *keyseq;
     char *data;
a247 3
  KEYMAP_ENTRY k;

  k.function = 0;
d257 1
a257 1
  keys = (char *)xmalloc (1 + (2 * strlen (keyseq)));
d271 1
a271 6
      unsigned char uc = keys[i];
      int ic;

      ic = uc;
      if (ic < 0 || ic >= KEYMAP_SIZE)
	return -1;
d284 2
a285 8
	      /* We allow subsequences of keys.  If a keymap is being
		 created that will `shadow' an existing function or macro
		 key binding, we save that keybinding into the ANYOTHERKEY
		 index in the new map.  The dispatch code will look there
		 to find the function to execute if the subsequence is not
		 matched.  ANYOTHERKEY was chosen to be greater than
		 UCHAR_MAX. */
	      k = map[ic];
a290 11
	  /* The dispatch code will return this function if no matching
	     key sequence is found in the keymap.  This (with a little
	     help from the dispatch code in readline.c) allows `a' to be
	     mapped to something, `abc' to be mapped to something else,
	     and the function bound  to `a' to be executed when the user
	     types `abx', leaving `bx' in the input queue. */
	  if (k.function /* && k.type == ISFUNC */)
	    {
	      map[ANYOTHERKEY] = k;
	      k.function = 0;
	    }
a295 5
	  else if (map[ic].type == ISKMAP)
	    {
	      map = FUNCTION_TO_KEYMAP (map, ic);
	      ic = ANYOTHERKEY;
	    }
d312 1
a312 2
     const char *seq;
     char *array;
d332 1
a332 1
		  array[l++] = ESC;	/* ESC is meta-prefix */
d341 1
a341 1
		  array[l++] = ESC;	/* ESC is meta-prefix */
d394 1
a394 1
	      array[l++] = c & largest_char;
d398 1
a398 1
	      for (temp = 2, c = 0; ISXDIGIT ((unsigned char)seq[i]) && temp--; i++)
d400 1
a400 1
	      if (temp == 2)
d403 1
a403 1
	      array[l++] = c & largest_char;
d473 1
a473 1
  r = ret = (char *)xmalloc (7 * strlen (seq) + 1);
d516 1
a516 1
rl_command_func_t *
d518 1
a518 1
     const char *string;
d527 1
a527 1
  return ((rl_command_func_t *)NULL);
d535 1
a535 1
rl_command_func_t *
d537 1
a537 1
     const char *keyseq;
d548 1
a548 1
      unsigned char ic = keyseq[i];
d588 1
a588 1
  return ((rl_command_func_t *) NULL);
d595 1
a595 1
static const char *current_readline_init_file;
d633 3
d637 1
d643 5
d651 1
d662 1
a662 1
  r = rl_read_init_file ((const char *)NULL);
d676 1
a676 1
     const char *filename;
d683 1
a683 1
        filename = sh_get_env_value ("INPUTRC");
d701 1
a701 1
     const char *filename;
d736 1
a736 1
#if defined (__CYGWIN__)
d768 1
a768 1
     const char *msg;
a782 11
typedef int _rl_parser_func_t PARAMS((char *));

/* Things that mean `Control'. */
const char *_rl_possible_control_prefixes[] = {
  "Control-", "C-", "CTRL-", (const char *)NULL
};

const char *_rl_possible_meta_prefixes[] = {
  "Meta", "M-", (const char *)NULL
};

d786 1
a786 1
const char *rl_readline_name = "other";
d908 1
a908 2
  const char *old_init_file;
  char *e;
d921 1
a921 1
  r = _rl_read_init_file ((const char *)args, old_include_level + 1);
d932 2
a933 2
  const char *name;
  _rl_parser_func_t *function;
d939 1
a939 1
  { (char *)0x0, (_rl_parser_func_t *)0x0 }
d1064 1
a1064 1
      /* Make VALUE point to start of value string. */
d1134 1
a1134 1
      seq = (char *)xmalloc (1 + strlen (string));
d1183 1
a1183 1
  if (substring_member_of_array (string, _rl_possible_control_prefixes))
d1186 1
a1186 1
  if (substring_member_of_array (string, _rl_possible_meta_prefixes))
d1192 1
a1192 1
      char useq[2];
d1224 1
a1224 1
  const char *name;
a1228 1
  { "byte-oriented",		&rl_byte_oriented,		0 },
a1233 1
  { "history-preserve-point",	&_rl_history_preserve_point,	0 },
a1237 2
  { "mark-symlinked-directories", &_rl_complete_mark_symlink_dirs, 0 },
  { "match-hidden-files",	&_rl_match_hidden_files,	0 },
a1239 1
  { "page-completions",		&_rl_page_completions,		0 },
d1251 1
a1251 1
     const char *name;
d1268 1
a1268 1
  const char *name;
a1282 2
typedef int _rl_sv_func_t PARAMS((const char *));

d1295 6
a1300 6
static int sv_bell_style PARAMS((const char *));
static int sv_combegin PARAMS((const char *));
static int sv_compquery PARAMS((const char *));
static int sv_editmode PARAMS((const char *));
static int sv_isrchterm PARAMS((const char *));
static int sv_keymap PARAMS((const char *));
d1303 1
a1303 1
  const char *name;
d1305 1
a1305 1
  _rl_sv_func_t *set_func;
d1318 1
a1318 1
     const char *name;
d1342 1
a1342 1
     const char *name, *value;
d1370 1
a1370 1
     const char *value;
d1391 1
a1391 1
     const char *value;
d1404 1
a1404 1
     const char *value;
d1420 1
a1420 1
     const char *value;
d1433 2
d1437 1
a1437 1
     const char *value;
d1440 1
a1440 1
    _rl_bell_preference = AUDIBLE_BELL;
d1442 1
a1442 1
    _rl_bell_preference = NO_BELL;
d1444 1
a1444 1
    _rl_bell_preference = AUDIBLE_BELL;
d1446 1
a1446 1
    _rl_bell_preference = VISIBLE_BELL;
a1448 1
  return 0;
d1450 1
d1454 1
a1454 1
     const char *value;
d1480 1
a1480 1
  _rl_isearch_terminators = (char *)xmalloc (2 * strlen (v) + 1);
d1492 1
a1492 1
  const char *name;
d1526 1
a1526 1
  const char *name;
d1544 1
a1544 1
     const char *name;
d1549 1
a1549 1
    if (_rl_stricmp (name, keymap_names[i].name) == 0)
d1561 1
a1561 1
      return ((char *)keymap_names[i].name);
d1619 1
a1619 1
  const char **funmap_names;
d1646 1
a1646 2
#if 1
  /* XXX - Experimental */
d1653 4
a1656 4
      keyname[0] = '\\';
      keyname[1] = 'e';
      keyname[2] = '\0';
      return keyname;
d1709 1
a1709 1
     rl_command_func_t *function;
d1738 1
a1738 1
		  result = (char **)xrealloc (result, result_size * sizeof (char *));
a1766 1
#if 0
a1767 4
#else
		/* XXX - experimental */
		  sprintf (keyname, "\\M-");
#endif
d1790 1
a1790 1
		    result = (char **)xrealloc (result, result_size * sizeof (char *));
d1809 1
a1809 1
     rl_command_func_t *function;
d1822 2
a1823 2
  const char **names;
  const char *name;
d1831 1
a1831 1
      rl_command_func_t *function;
d1914 3
d1918 1
a1918 1

d1928 1
d1930 1
d1938 1
a1938 1
	      keyname = (char *)xmalloc (3 + prefix_len);
d1950 1
a1950 1
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
d1988 1
a1988 1
  const char *kname;
d2020 1
a2020 1
    fprintf (rl_outstream, "comment-begin is set to `%s'\n", _rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);
d2034 9
a2056 9

  /* keymap */
  kname = rl_get_keymap_name (_rl_keymap);
  if (kname == 0)
    kname = rl_get_keymap_name_from_edit_mode ();
  if (print_readably)
    fprintf (rl_outstream, "set keymap %s\n", kname ? kname : "none");
  else
    fprintf (rl_outstream, "keymap is set to `%s'\n", kname ? kname : "none");
d2073 1
a2073 3
/* Bind key sequence KEYSEQ to DEFAULT_FUNC if KEYSEQ is unbound.  Right
   now, this is always used to attempt to bind the arrow keys, hence the
   check for rl_vi_movement_mode. */
d2076 2
a2077 2
     const char *keyseq;
     rl_command_func_t *default_func;
d2079 1
a2079 1
  rl_command_func_t *func;
a2083 3
#if defined (VI_MODE)
      if (!func || func == rl_do_lowercase_version || func == rl_vi_movement_mode)
#else
a2084 1
#endif
d2092 1
a2092 2
     char *string;
     const char **array;
@


1.1.1.5
log
@import of readlilne 5.1
@
text
@d3 1
a3 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
a21 1

a23 4
#if defined (__TANDEM)
#  include <floss.h>
#endif

a74 3
static int find_boolean_var PARAMS((const char *));

static char *_rl_get_string_variable_value PARAMS((const char *));
a150 28
/* Bind key sequence KEYSEQ to DEFAULT_FUNC if KEYSEQ is unbound.  Right
   now, this is always used to attempt to bind the arrow keys, hence the
   check for rl_vi_movement_mode. */
int
rl_bind_key_if_unbound_in_map (key, default_func, kmap)
     int key;
     rl_command_func_t *default_func;
     Keymap kmap;
{
  char keyseq[2];

  keyseq[0] = (unsigned char)key;
  keyseq[1] = '\0';
  return (rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, kmap));
}

int
rl_bind_key_if_unbound (key, default_func)
     int key;
     rl_command_func_t *default_func;
{
  char keyseq[2];

  keyseq[0] = (unsigned char)key;
  keyseq[1] = '\0';
  return (rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, _rl_keymap));
}

a202 11
   FUNCTION, starting in the current keymap.  This makes new
   keymaps as necessary. */
int
rl_bind_keyseq (keyseq, function)
     const char *keyseq;
     rl_command_func_t *function;
{
  return (rl_generic_bind (ISFUNC, keyseq, (char *)function, _rl_keymap));
}

/* Bind the key sequence represented by the string KEYSEQ to
a205 10
rl_bind_keyseq_in_map (keyseq, function, map)
     const char *keyseq;
     rl_command_func_t *function;
     Keymap map;
{
  return (rl_generic_bind (ISFUNC, keyseq, (char *)function, map));
}

/* Backwards compatibility; equivalent to rl_bind_keyseq_in_map() */
int
a213 34
/* Bind key sequence KEYSEQ to DEFAULT_FUNC if KEYSEQ is unbound.  Right
   now, this is always used to attempt to bind the arrow keys, hence the
   check for rl_vi_movement_mode. */
int
rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, kmap)
     const char *keyseq;
     rl_command_func_t *default_func;
     Keymap kmap;
{
  rl_command_func_t *func;

  if (keyseq)
    {
      func = rl_function_of_keyseq (keyseq, kmap, (int *)NULL);
#if defined (VI_MODE)
      if (!func || func == rl_do_lowercase_version || func == rl_vi_movement_mode)
#else
      if (!func || func == rl_do_lowercase_version)
#endif
	return (rl_bind_keyseq_in_map (keyseq, default_func, kmap));
      else
	return 1;
    }
  return 0;
}

int
rl_bind_keyseq_if_unbound (keyseq, default_func)
     const char *keyseq;
     rl_command_func_t *default_func;
{
  return (rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, _rl_keymap));
}

d256 1
a256 1
  if (keyseq == 0 || *keyseq == 0)
d284 1
a284 1
      if (META_CHAR (ic) && _rl_convert_meta_chars_to_ascii)
d314 1
a314 1
	  if (k.function && ((k.type == ISFUNC && k.function != rl_do_lowercase_version) || k.type == ISMACR))
d375 1
a375 8
		  /* XXX - should obey convert-meta setting? */
		  if (_rl_convert_meta_chars_to_ascii && _rl_keymap[ESC].type == ISKMAP)
		    array[l++] = ESC;	/* ESC is meta-prefix */
		  else
		    {
		      i++;
		      array[l++] = META (seq[i]);
		    }
a914 1
#if 0
a917 5
#else
  /* Check the previous (n) levels of the stack to make sure that
     we haven't previously turned off parsing. */
  for (i = 0; i < if_stack_depth; i++)
#endif
d1094 2
a1095 1
      char *var, *value, *e;
a1096 1
      var = string + i;
a1106 14
      /* Strip trailing whitespace from values to boolean variables.  Temp
	 fix until I get a real quoted-string parser here. */
      i = find_boolean_var (var);
      if (i >= 0)
	{
	  /* remove trailing whitespace */
	  e = value + strlen (value) - 1;
	  while (e >= value && whitespace (*e))
	    e--;
	  e++;		/* skip back to whitespace or EOS */
	  if (*e && e >= value)
	    *e = '\0';
	}

d1127 1
a1127 1
      int delimiter, passc;
a1128 1
      delimiter = string[i++];
d1164 1
a1164 1
     rl_bind_keyseq ().  Otherwise, let the older code deal with it. */
d1203 1
a1203 1
	rl_bind_keyseq (seq, rl_named_function (funname));
a1263 1
  { "bind-tty-special-chars",	&_rl_bind_stty_chars,		0 },
a1283 1
  { "show-all-if-unmodified",	&_rl_complete_show_unmodified,	0 },
d1376 1
a1376 1
     const char *value;
a1382 21
char *
rl_variable_value (name)
     const char *name;
{
  register int i;
  int	v;
  char *ret;

  /* Check for simple variables first. */
  i = find_boolean_var (name);
  if (i >= 0)
    return (*boolean_varlist[i].value ? "on" : "off");

  i = find_string_var (name);
  if (i >= 0)
    return (_rl_get_string_variable_value (string_varlist[i].name));

  /* Unknown variable names return NULL. */
  return 0;
}

d1653 1
a1653 1
   be read back in (i.e., passed to rl_parse_and_bind ()). */
a2024 56
static char *
_rl_get_string_variable_value (name)
     const char *name;
{
  static char numbuf[32];
  char *ret;
  int n;

  if (_rl_stricmp (name, "bell-style") == 0)
    {
      switch (_rl_bell_preference)
	{
	  case NO_BELL:
	    return "none";
	  case VISIBLE_BELL:
	    return "visible";
	  case AUDIBLE_BELL:
	  default:
	    return "audible";
	}
    }
  else if (_rl_stricmp (name, "comment-begin") == 0)
    return (_rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);
  else if (_rl_stricmp (name, "completion-query-items") == 0)
    {
      sprintf (numbuf, "%d", rl_completion_query_items);
      return (numbuf);
    }
  else if (_rl_stricmp (name, "editing-mode") == 0)
    return (rl_get_keymap_name_from_edit_mode ());
  else if (_rl_stricmp (name, "isearch-terminators") == 0)
    {
      if (_rl_isearch_terminators == 0)
	return 0;
      ret = _rl_untranslate_macro_value (_rl_isearch_terminators);
      if (ret)
	{
	  strncpy (numbuf, ret, sizeof (numbuf) - 1);
	  free (ret);
	  numbuf[sizeof(numbuf) - 1] = '\0';
	}
      else
	numbuf[0] = '\0';
      return numbuf;
    }
  else if (_rl_stricmp (name, "keymap") == 0)
    {
      ret = rl_get_keymap_name (_rl_keymap);
      if (ret == 0)
	ret = rl_get_keymap_name_from_edit_mode ();
      return (ret ? ret : "none");
    }
  else
    return (0);
}

d2030 1
a2030 1
  char *v;
d2042 36
a2077 1
  for (i = 0; string_varlist[i].name; i++)
d2079 4
a2082 3
      v = _rl_get_string_variable_value (string_varlist[i].name);
      if (v == 0)	/* _rl_isearch_terminators can be NULL */
	continue;
d2084 1
a2084 1
        fprintf (rl_outstream, "set %s %s\n", string_varlist[i].name, v);
d2086 3
a2088 1
        fprintf (rl_outstream, "%s is set to `%s'\n", string_varlist[i].name, v);
d2090 9
d2115 22
@


