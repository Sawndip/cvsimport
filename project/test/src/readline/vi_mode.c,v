head	1.8;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.8
	gdb_7_6-2013-04-26-release:1.8
	gdb_7_6-branch:1.8.0.6
	gdb_7_6-2013-03-12-branchpoint:1.8
	gdb_7_5_1-2012-11-29-release:1.8
	gdb_7_5-2012-08-17-release:1.8
	gdb_7_5-branch:1.8.0.4
	gdb_7_5-2012-07-18-branchpoint:1.8
	gdb_7_4_1-2012-04-26-release:1.8
	gdb_7_4-2012-01-24-release:1.8
	gdb_7_4-branch:1.8.0.2
	gdb_7_4-2011-12-13-branchpoint:1.8
	gdb_7_3_1-2011-09-04-release:1.7
	gdb_7_3-2011-07-26-release:1.7
	gdb_7_3-branch:1.7.0.36
	gdb_7_3-2011-04-01-branchpoint:1.7
	gdb_7_2-2010-09-02-release:1.7
	gdb_7_2-branch:1.7.0.34
	gdb_7_2-2010-07-07-branchpoint:1.7
	gdb_7_1-2010-03-18-release:1.7
	gdb_7_1-branch:1.7.0.32
	gdb_7_1-2010-02-18-branchpoint:1.7
	gdb_7_0_1-2009-12-22-release:1.7
	gdb_7_0-2009-10-06-release:1.7
	gdb_7_0-branch:1.7.0.30
	gdb_7_0-2009-09-16-branchpoint:1.7
	arc-sim-20090309:1.7
	msnyder-checkpoint-072509-branch:1.7.0.28
	msnyder-checkpoint-072509-branchpoint:1.7
	arc-insight_6_8-branch:1.7.0.26
	arc-insight_6_8-branchpoint:1.7
	insight_6_8-branch:1.7.0.24
	insight_6_8-branchpoint:1.7
	reverse-20081226-branch:1.7.0.22
	reverse-20081226-branchpoint:1.7
	multiprocess-20081120-branch:1.7.0.20
	multiprocess-20081120-branchpoint:1.7
	reverse-20080930-branch:1.7.0.18
	reverse-20080930-branchpoint:1.7
	reverse-20080717-branch:1.7.0.16
	reverse-20080717-branchpoint:1.7
	msnyder-reverse-20080609-branch:1.7.0.14
	msnyder-reverse-20080609-branchpoint:1.7
	drow-reverse-20070409-branch:1.7.0.12
	drow-reverse-20070409-branchpoint:1.7
	gdb_6_8-2008-03-27-release:1.7
	gdb_6_8-branch:1.7.0.10
	gdb_6_8-2008-02-26-branchpoint:1.7
	gdb_6_7_1-2007-10-29-release:1.7
	gdb_6_7-2007-10-10-release:1.7
	gdb_6_7-branch:1.7.0.8
	gdb_6_7-2007-09-07-branchpoint:1.7
	insight_6_6-20070208-release:1.7
	gdb_6_6-2006-12-18-release:1.7
	gdb_6_6-branch:1.7.0.6
	gdb_6_6-2006-11-15-branchpoint:1.7
	insight_6_5-20061003-release:1.7
	gdb-csl-symbian-6_4_50_20060226-12:1.5
	gdb-csl-sourcerygxx-3_4_4-25:1.5
	nickrob-async-20060828-mergepoint:1.7
	gdb-csl-symbian-6_4_50_20060226-11:1.5
	gdb-csl-sourcerygxx-4_1-17:1.5
	gdb-csl-20060226-branch-local-2:1.5
	gdb-csl-sourcerygxx-4_1-14:1.5
	gdb-csl-sourcerygxx-4_1-13:1.5
	gdb-csl-sourcerygxx-4_1-12:1.5
	gdb-csl-sourcerygxx-3_4_4-21:1.5
	gdb_6_5-20060621-release:1.7
	gdb-csl-sourcerygxx-4_1-9:1.5
	gdb-csl-sourcerygxx-4_1-8:1.5
	gdb-csl-sourcerygxx-4_1-7:1.5
	gdb-csl-arm-2006q1-6:1.5
	gdb-csl-sourcerygxx-4_1-6:1.5
	gdb-csl-symbian-6_4_50_20060226-10:1.5
	gdb-csl-symbian-6_4_50_20060226-9:1.5
	gdb-csl-symbian-6_4_50_20060226-8:1.5
	gdb-csl-coldfire-4_1-11:1.5
	gdb-csl-sourcerygxx-3_4_4-19:1.5
	gdb-csl-coldfire-4_1-10:1.5
	gdb_6_5-branch:1.7.0.4
	gdb_6_5-2006-05-14-branchpoint:1.7
	gdb-csl-sourcerygxx-4_1-5:1.5
	nickrob-async-20060513-branch:1.7.0.2
	nickrob-async-20060513-branchpoint:1.7
	gdb-csl-sourcerygxx-4_1-4:1.5
	msnyder-reverse-20060502-branch:1.6.0.4
	msnyder-reverse-20060502-branchpoint:1.6
	gdb-csl-morpho-4_1-4:1.5
	gdb-csl-sourcerygxx-3_4_4-17:1.5
	readline_5_1-import-branch:1.6.0.2
	readline_5_1-import-branchpoint:1.6
	readline-pre-51-import:1.6
	readline_5_1:1.1.1.5
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.5
	gdb-csl-symbian-20060226-branch:1.5.0.36
	gdb-csl-symbian-20060226-branchpoint:1.5
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.5
	msnyder-reverse-20060331-branch:1.5.0.34
	msnyder-reverse-20060331-branchpoint:1.5
	gdb-csl-available-20060303-branch:1.5.0.32
	gdb-csl-available-20060303-branchpoint:1.5
	gdb-csl-20060226-branch:1.5.0.30
	gdb-csl-20060226-branchpoint:1.5
	gdb_6_4-20051202-release:1.5
	msnyder-fork-checkpoint-branch:1.5.0.28
	msnyder-fork-checkpoint-branchpoint:1.5
	gdb-csl-gxxpro-6_3-branch:1.5.0.26
	gdb-csl-gxxpro-6_3-branchpoint:1.5
	gdb_6_4-branch:1.5.0.24
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb-csl-arm-20051020-branch:1.5.0.22
	gdb-csl-arm-20051020-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.20
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb-csl-arm-20050325-2005-q1b:1.5
	gdb-csl-arm-20050325-2005-q1a:1.5
	csl-arm-20050325-branch:1.5.0.18
	csl-arm-20050325-branchpoint:1.5
	gdb_6_3-20041109-release:1.5
	gdb_6_3-branch:1.5.0.14
	gdb_6_3-20041019-branchpoint:1.5
	drow_intercu-merge-20040921:1.5
	drow_intercu-merge-20040915:1.5
	jimb-gdb_6_2-e500-branch:1.5.0.16
	jimb-gdb_6_2-e500-branchpoint:1.5
	gdb_6_2-20040730-release:1.5
	gdb_6_2-branch:1.5.0.12
	gdb_6_2-2004-07-10-gmt-branchpoint:1.5
	gdb_6_1_1-20040616-release:1.5
	gdb_6_1-2004-04-05-release:1.5
	drow_intercu-merge-20040402:1.5
	drow_intercu-merge-20040327:1.5
	ezannoni_pie-20040323-branch:1.5.0.10
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.8
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow_intercu-20040221-branch:1.5.0.4
	drow_intercu-20040221-branchpoint:1.5
	cagney_bfdfile-20040213-branch:1.5.0.2
	cagney_bfdfile-20040213-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.4
	cagney_bigcore-20040122-branch:1.4.0.42
	cagney_bigcore-20040122-branchpoint:1.4
	drow-cplus-merge-20040113:1.4
	drow-cplus-merge-20031224:1.4
	drow-cplus-merge-20031220:1.4
	carlton_dictionary-20031215-merge:1.4
	drow-cplus-merge-20031214:1.4
	carlton-dictionary-20031111-merge:1.4
	gdb_6_0-2003-10-04-release:1.4
	kettenis_sparc-20030918-branch:1.4.0.40
	kettenis_sparc-20030918-branchpoint:1.4
	carlton_dictionary-20030917-merge:1.4
	ezannoni_pie-20030916-branchpoint:1.4
	ezannoni_pie-20030916-branch:1.4.0.38
	cagney_x86i386-20030821-branch:1.4.0.36
	cagney_x86i386-20030821-branchpoint:1.4
	carlton_dictionary-20030805-merge:1.4
	carlton_dictionary-20030627-merge:1.4
	gdb_6_0-branch:1.4.0.34
	gdb_6_0-2003-06-23-branchpoint:1.4
	jimb-ppc64-linux-20030613-branch:1.4.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.4
	cagney_convert-20030606-branch:1.4.0.30
	cagney_convert-20030606-branchpoint:1.4
	cagney_writestrings-20030508-branch:1.4.0.28
	cagney_writestrings-20030508-branchpoint:1.4
	jimb-ppc64-linux-20030528-branch:1.4.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.4
	carlton_dictionary-20030523-merge:1.4
	cagney_fileio-20030521-branch:1.4.0.24
	cagney_fileio-20030521-branchpoint:1.4
	kettenis_i386newframe-20030517-mergepoint:1.4
	jimb-ppc64-linux-20030509-branch:1.4.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.4
	kettenis_i386newframe-20030504-mergepoint:1.4
	carlton_dictionary-20030430-merge:1.4
	kettenis_i386newframe-20030419-branch:1.4.0.20
	kettenis_i386newframe-20030419-branchpoint:1.4
	carlton_dictionary-20030416-merge:1.4
	cagney_frameaddr-20030409-mergepoint:1.4
	kettenis_i386newframe-20030406-branch:1.4.0.18
	kettenis_i386newframe-20030406-branchpoint:1.4
	cagney_frameaddr-20030403-branchpoint:1.4
	cagney_frameaddr-20030403-branch:1.4.0.16
	cagney_framebase-20030330-mergepoint:1.4
	cagney_framebase-20030326-branch:1.4.0.14
	cagney_framebase-20030326-branchpoint:1.4
	cagney_lazyid-20030317-branch:1.4.0.12
	cagney_lazyid-20030317-branchpoint:1.4
	kettenis-i386newframe-20030316-mergepoint:1.4
	offbyone-20030313-branch:1.4.0.10
	offbyone-20030313-branchpoint:1.4
	kettenis-i386newframe-20030308-branch:1.4.0.8
	kettenis-i386newframe-20030308-branchpoint:1.4
	carlton_dictionary-20030305-merge:1.4
	cagney_offbyone-20030303-branch:1.4.0.6
	cagney_offbyone-20030303-branchpoint:1.4
	carlton_dictionary-20030207-merge:1.4
	interps-20030202-branch:1.4.0.4
	interps-20030202-branchpoint:1.4
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.3
	readline-pre-43-import:1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.24
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	carlton_dictionary-branch:1.3.0.22
	carlton_dictionary-20020920-branchpoint:1.3
	gdb_5_3-branch:1.3.0.20
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.3
	cagney_sysregs-20020825-branch:1.3.0.18
	cagney_sysregs-20020825-branchpoint:1.3
	readline_4_3-import-branch:1.3.0.16
	readline_4_3-import-branchpoint:1.3
	readline_4_3:1.1.1.4
	gdb_5_2_1-2002-07-23-release:1.3
	kseitz_interps-20020528-branch:1.3.0.14
	kseitz_interps-20020528-branchpoint:1.3
	cagney_regbuf-20020515-branch:1.3.0.12
	cagney_regbuf-20020515-branchpoint:1.3
	jimb-macro-020506-branch:1.3.0.10
	jimb-macro-020506-branchpoint:1.3
	gdb_5_2-2002-04-29-release:1.3
	gdb_5_2-branch:1.3.0.8
	gdb_5_2-2002-03-03-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	cygnus_cvs_20020108_pre:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.4
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.2
	gdb_5_1-2001-07-29-branchpoint:1.3
	insight-precleanup-2001-01-01:1.3
	readline_4_1:1.1.1.3
	readline_4_0:1.1.1.2
	FSF:1.1.1
	readline-pre-41-import:1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.8
date	2011.05.11.23.38.39;	author jkratoch;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.05.18.26.12;	author drow;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.20.20.13.20;	author ezannoni;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2004.01.27.22.25.15;	author ezannoni;	state Exp;
branches;
next	1.4;

1.4
date	2002.12.08.22.31.37;	author ezannoni;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.09.17.19.56;	author ezannoni;	state Exp;
branches
	1.3.16.1
	1.3.22.1
	1.3.24.1;
next	1.2;

1.2
date	2000.07.07.17.15.45;	author ezannoni;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.54;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.6.2.1
date	2006.04.24.22.00.25;	author drow;	state Exp;
branches;
next	;

1.3.16.1
date	2002.08.25.23.41.17;	author ezannoni;	state Exp;
branches;
next	;

1.3.22.1
date	2002.12.23.19.39.45;	author carlton;	state Exp;
branches;
next	;

1.3.24.1
date	2003.12.14.20.28.14;	author drow;	state Exp;
branches;
next	1.3.24.2;

1.3.24.2
date	2004.02.09.19.44.03;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.54;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.08.02.23.47.59;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.07.09.16.21.21;	author ezannoni;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.08.23.22.02.28;	author ezannoni;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.20.20.05.38;	author ezannoni;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Imported readline 6.2, and upstream patch 001.

[patch 0/3] readline-6.2 rebase
http://sourceware.org/ml/gdb-patches/2011-05/msg00003.html
[patch 1/3] readline-6.2: Merge of already posted patches
http://sourceware.org/ml/gdb-patches/2011-05/msg00004.html
	=
	[Bug-readline] [RFC/readline] bind.c, rl_function_dumper, Free allocated
	http://lists.gnu.org/archive/html/bug-readline/2011-03/msg00000.html
	[Bug-readline] [patch] Fix underquotation in readline/examples/rlfe/conf
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00001.html
	[Bug-readline] [patch] Makefile.in htm<->html
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00002.html
	Re: [Bug-readline] [patch] Makefile.in dependency: callback.o: xmalloc.h
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00004.html
	[Bug-readline] [patch] Remove . from the VPATH directive
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00005.html
	Eli Zaretskii's __MSDOS__ / __GO32__ / __MINGW32__ / __DJGPP__ stuff:
	http://sourceware.org/ml/gdb/2011-04/msg00002.html
	Jan Kratochvil's patch for FSF GDB tree local-specific changes:
	http://sourceware.org/ml/gdb/2011-04/msg00006.html
	Preservation of existing ChangeLog.gdb files, their updates.
[patch 2/3] readline-6.2: Workaround "ask" regression
http://sourceware.org/ml/gdb-patches/2011-05/msg00005.html
[patch 3/3] readline-6.2: Revert 5.x compat., apply 6.x compat.
http://sourceware.org/ml/gdb-patches/2011-05/msg00006.html
[patch 4/3] readline-6.2: Substitute inc-hist.texinfo
http://sourceware.org/ml/gdb-patches/2011-05/msg00010.html

readline/
	Workaround gdb.base/completion.exp regression on readline-6.2.
	* complete.c (get_y_or_n): Disable the return on RL_STATE_CALLBACK.

	Imported readline 6.2, and upstream patch 001.
	* configure: Regenerate.

readline/doc/
	* hsuser.texi (Using History Interactively): Disable !BashFeatures
	@@defcodeindex.  Make the `Programming with GNU History' reference
	external.
	* inc-hist.texinfo: Remove.

	Imported readline 6.2, and upstream patch 001.

readline/examples/
	Imported readline 6.2, and upstream patch 001.

readline/examples/rlfe/
	Imported readline 6.2, and upstream patch 001.

gdb/
	* config.in: Regenerate.
	* configure: Regenerate.
	* configure.ac <--with-system-readline> (for readline_echoing_p):
	Remove the test.
	* tui/tui-io.c (tui_old_readline_echoing_p): Rename to ...
	(tui_old_rl_echoing_p): ... here.
	(tui_setup_io): Rename extern declaration readline_echoing_p to
	_rl_echoing_p.  Adjust assignments for the both renames.

gdb/doc/
	* Makefile.in (GDB_DOC_SOURCE_INCLUDES): Rename inc-hist.texinfo to
	hsuser.texi.
	* gdb.texinfo <!SYSTEM_READLINE>: Rename inc-hist.texinfo inclusion and
	comment to hsuser.texi.  Change rluser.texi name in the comment.
@
text
@/* vi_mode.c -- A vi emulation mode for Bash.
   Derived from code written by Jeff Sparkes (jsparkes@@bnr.ca).  */

/* Copyright (C) 1987-2010 Free Software Foundation, Inc.

   This file is part of the GNU Readline Library (Readline), a library
   for reading lines of text with interactive input and history editing.      

   Readline is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Readline is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Readline.  If not, see <http://www.gnu.org/licenses/>.
*/

#define READLINE_LIBRARY

/* **************************************************************** */
/*								    */
/*			VI Emulation Mode			    */
/*								    */
/* **************************************************************** */
#include "rlconf.h"

#if defined (VI_MODE)

#if defined (HAVE_CONFIG_H)
#  include <config.h>
#endif

#include <sys/types.h>

#if defined (HAVE_STDLIB_H)
#  include <stdlib.h>
#else
#  include "ansi_stdlib.h"
#endif /* HAVE_STDLIB_H */

#if defined (HAVE_UNISTD_H)
#  include <unistd.h>
#endif

#include <stdio.h>

/* Some standard library routines. */
#include "rldefs.h"
#include "rlmbutil.h"

#include "readline.h"
#include "history.h"

#include "rlprivate.h"
#include "xmalloc.h"

#ifndef member
#define member(c, s) ((c) ? (char *)strchr ((s), (c)) != (char *)NULL : 0)
#endif

int _rl_vi_last_command = 'i';	/* default `.' puts you in insert mode */

_rl_vimotion_cxt *_rl_vimvcxt = 0;

/* Non-zero means enter insertion mode. */
static int _rl_vi_doing_insert;

/* Command keys which do movement for xxx_to commands. */
static const char * const vi_motion = " hl^$0ftFT;,%wbeWBE|`";

/* Keymap used for vi replace characters.  Created dynamically since
   rarely used. */
static Keymap vi_replace_map;

/* The number of characters inserted in the last replace operation. */
static int vi_replace_count;

/* If non-zero, we have text inserted after a c[motion] command that put
   us implicitly into insert mode.  Some people want this text to be
   attached to the command so that it is `redoable' with `.'. */
static int vi_continued_command;
static char *vi_insert_buffer;
static int vi_insert_buffer_size;

static int _rl_vi_last_repeat = 1;
static int _rl_vi_last_arg_sign = 1;
static int _rl_vi_last_motion;
#if defined (HANDLE_MULTIBYTE)
static char _rl_vi_last_search_mbchar[MB_LEN_MAX];
static int _rl_vi_last_search_mblen;
#else
static int _rl_vi_last_search_char;
#endif
static int _rl_vi_last_replacement;

static int _rl_vi_last_key_before_insert;

static int vi_redoing;

/* Text modification commands.  These are the `redoable' commands. */
static const char * const vi_textmod = "_*\\AaIiCcDdPpYyRrSsXx~";

/* Arrays for the saved marks. */
static int vi_mark_chars['z' - 'a' + 1];

static void _rl_vi_stuff_insert PARAMS((int));
static void _rl_vi_save_insert PARAMS((UNDO_LIST *));

static void _rl_vi_backup PARAMS((void));

static int _rl_vi_arg_dispatch PARAMS((int));
static int rl_digit_loop1 PARAMS((void));

static int _rl_vi_set_mark PARAMS((void));
static int _rl_vi_goto_mark PARAMS((void));

static void _rl_vi_append_forward PARAMS((int));

static int _rl_vi_callback_getchar PARAMS((char *, int));

#if defined (READLINE_CALLBACKS)
static int _rl_vi_callback_set_mark PARAMS((_rl_callback_generic_arg *));
static int _rl_vi_callback_goto_mark PARAMS((_rl_callback_generic_arg *));
static int _rl_vi_callback_change_char PARAMS((_rl_callback_generic_arg *));
static int _rl_vi_callback_char_search PARAMS((_rl_callback_generic_arg *));
#endif

static int rl_domove_read_callback PARAMS((_rl_vimotion_cxt *));
static int rl_domove_motion_callback PARAMS((_rl_vimotion_cxt *));
static int rl_vi_domove_getchar PARAMS((_rl_vimotion_cxt *));

static int vi_change_dispatch PARAMS((_rl_vimotion_cxt *));
static int vi_delete_dispatch PARAMS((_rl_vimotion_cxt *));
static int vi_yank_dispatch PARAMS((_rl_vimotion_cxt *));

static int vidomove_dispatch PARAMS((_rl_vimotion_cxt *));

void
_rl_vi_initialize_line ()
{
  register int i, n;

  n = sizeof (vi_mark_chars) / sizeof (vi_mark_chars[0]);
  for (i = 0; i < n; i++)
    vi_mark_chars[i] = -1;

  RL_UNSETSTATE(RL_STATE_VICMDONCE);
}

void
_rl_vi_reset_last ()
{
  _rl_vi_last_command = 'i';
  _rl_vi_last_repeat = 1;
  _rl_vi_last_arg_sign = 1;
  _rl_vi_last_motion = 0;
}

void
_rl_vi_set_last (key, repeat, sign)
     int key, repeat, sign;
{
  _rl_vi_last_command = key;
  _rl_vi_last_repeat = repeat;
  _rl_vi_last_arg_sign = sign;
}

/* A convenience function that calls _rl_vi_set_last to save the last command
   information and enters insertion mode. */
void
rl_vi_start_inserting (key, repeat, sign)
     int key, repeat, sign;
{
  _rl_vi_set_last (key, repeat, sign);
  rl_vi_insertion_mode (1, key);
}

/* Is the command C a VI mode text modification command? */
int
_rl_vi_textmod_command (c)
     int c;
{
  return (member (c, vi_textmod));
}

static void
_rl_vi_stuff_insert (count)
     int count;
{
  rl_begin_undo_group ();
  while (count--)
    rl_insert_text (vi_insert_buffer);
  rl_end_undo_group ();
}

/* Bound to `.'.  Called from command mode, so we know that we have to
   redo a text modification command.  The default for _rl_vi_last_command
   puts you back into insert mode. */
int
rl_vi_redo (count, c)
     int count, c;
{
  int r;

  if (!rl_explicit_arg)
    {
      rl_numeric_arg = _rl_vi_last_repeat;
      rl_arg_sign = _rl_vi_last_arg_sign;
    }

  r = 0;
  vi_redoing = 1;
  /* If we're redoing an insert with `i', stuff in the inserted text
     and do not go into insertion mode. */
  if (_rl_vi_last_command == 'i' && vi_insert_buffer && *vi_insert_buffer)
    {
      _rl_vi_stuff_insert (count);
      /* And back up point over the last character inserted. */
      if (rl_point > 0)
	_rl_vi_backup ();
    }
  /* Ditto for redoing an insert with `I', but move to the beginning of the
     line like the `I' command does. */
  else if (_rl_vi_last_command == 'I' && vi_insert_buffer && *vi_insert_buffer)
    {
      rl_beg_of_line (1, 'I');
      _rl_vi_stuff_insert (count);
      if (rl_point > 0)
	_rl_vi_backup ();
    }
  /* Ditto for redoing an insert with `a', but move forward a character first
     like the `a' command does. */
  else if (_rl_vi_last_command == 'a' && vi_insert_buffer && *vi_insert_buffer)
    {
      _rl_vi_append_forward ('a');
      _rl_vi_stuff_insert (count);
      if (rl_point > 0)
	_rl_vi_backup ();
    }
  /* Ditto for redoing an insert with `A', but move to the end of the line
     like the `A' command does. */
  else if (_rl_vi_last_command == 'A' && vi_insert_buffer && *vi_insert_buffer)
    {
      rl_end_of_line (1, 'A');
      _rl_vi_stuff_insert (count);
      if (rl_point > 0)
	_rl_vi_backup ();
    }
  else
    r = _rl_dispatch (_rl_vi_last_command, _rl_keymap);
  vi_redoing = 0;

  return (r);
}

/* A placeholder for further expansion. */
int
rl_vi_undo (count, key)
     int count, key;
{
  return (rl_undo_command (count, key));
}
    
/* Yank the nth arg from the previous line into this line at point. */
int
rl_vi_yank_arg (count, key)
     int count, key;
{
  /* Readline thinks that the first word on a line is the 0th, while vi
     thinks the first word on a line is the 1st.  Compensate. */
  if (rl_explicit_arg)
    rl_yank_nth_arg (count - 1, 0);
  else
    rl_yank_nth_arg ('$', 0);

  return (0);
}

/* With an argument, move back that many history lines, else move to the
   beginning of history. */
int
rl_vi_fetch_history (count, c)
     int count, c;
{
  int wanted;

  /* Giving an argument of n means we want the nth command in the history
     file.  The command number is interpreted the same way that the bash
     `history' command does it -- that is, giving an argument count of 450
     to this command would get the command listed as number 450 in the
     output of `history'. */
  if (rl_explicit_arg)
    {
      wanted = history_base + where_history () - count;
      if (wanted <= 0)
        rl_beginning_of_history (0, 0);
      else
        rl_get_previous_history (wanted, c);
    }
  else
    rl_beginning_of_history (count, 0);
  return (0);
}

/* Search again for the last thing searched for. */
int
rl_vi_search_again (count, key)
     int count, key;
{
  switch (key)
    {
    case 'n':
      rl_noninc_reverse_search_again (count, key);
      break;

    case 'N':
      rl_noninc_forward_search_again (count, key);
      break;
    }
  return (0);
}

/* Do a vi style search. */
int
rl_vi_search (count, key)
     int count, key;
{
  switch (key)
    {
    case '?':
      _rl_free_saved_history_line ();
      rl_noninc_forward_search (count, key);
      break;

    case '/':
      _rl_free_saved_history_line ();
      rl_noninc_reverse_search (count, key);
      break;

    default:
      rl_ding ();
      break;
    }
  return (0);
}

/* Completion, from vi's point of view. */
int
rl_vi_complete (ignore, key)
     int ignore, key;
{
  if ((rl_point < rl_end) && (!whitespace (rl_line_buffer[rl_point])))
    {
      if (!whitespace (rl_line_buffer[rl_point + 1]))
	rl_vi_end_word (1, 'E');
      rl_point++;
    }

  if (key == '*')
    rl_complete_internal ('*');	/* Expansion and replacement. */
  else if (key == '=')
    rl_complete_internal ('?');	/* List possible completions. */
  else if (key == '\\')
    rl_complete_internal (TAB);	/* Standard Readline completion. */
  else
    rl_complete (0, key);

  if (key == '*' || key == '\\')
    rl_vi_start_inserting (key, 1, rl_arg_sign);

  return (0);
}

/* Tilde expansion for vi mode. */
int
rl_vi_tilde_expand (ignore, key)
     int ignore, key;
{
  rl_tilde_expand (0, key);
  rl_vi_start_inserting (key, 1, rl_arg_sign);
  return (0);
}

/* Previous word in vi mode. */
int
rl_vi_prev_word (count, key)
     int count, key;
{
  if (count < 0)
    return (rl_vi_next_word (-count, key));

  if (rl_point == 0)
    {
      rl_ding ();
      return (0);
    }

  if (_rl_uppercase_p (key))
    rl_vi_bWord (count, key);
  else
    rl_vi_bword (count, key);

  return (0);
}

/* Next word in vi mode. */
int
rl_vi_next_word (count, key)
     int count, key;
{
  if (count < 0)
    return (rl_vi_prev_word (-count, key));

  if (rl_point >= (rl_end - 1))
    {
      rl_ding ();
      return (0);
    }

  if (_rl_uppercase_p (key))
    rl_vi_fWord (count, key);
  else
    rl_vi_fword (count, key);
  return (0);
}

/* Move to the end of the ?next? word. */
int
rl_vi_end_word (count, key)
     int count, key;
{
  if (count < 0)
    {
      rl_ding ();
      return -1;
    }

  if (_rl_uppercase_p (key))
    rl_vi_eWord (count, key);
  else
    rl_vi_eword (count, key);
  return (0);
}

/* Move forward a word the way that 'W' does. */
int
rl_vi_fWord (count, ignore)
     int count, ignore;
{
  while (count-- && rl_point < (rl_end - 1))
    {
      /* Skip until whitespace. */
      while (!whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)
	rl_point++;

      /* Now skip whitespace. */
      while (whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)
	rl_point++;
    }
  return (0);
}

int
rl_vi_bWord (count, ignore)
     int count, ignore;
{
  while (count-- && rl_point > 0)
    {
      /* If we are at the start of a word, move back to whitespace so
	 we will go back to the start of the previous word. */
      if (!whitespace (rl_line_buffer[rl_point]) &&
	  whitespace (rl_line_buffer[rl_point - 1]))
	rl_point--;

      while (rl_point > 0 && whitespace (rl_line_buffer[rl_point]))
	rl_point--;

      if (rl_point > 0)
	{
	  while (--rl_point >= 0 && !whitespace (rl_line_buffer[rl_point]));
	  rl_point++;
	}
    }
  return (0);
}

int
rl_vi_eWord (count, ignore)
     int count, ignore;
{
  while (count-- && rl_point < (rl_end - 1))
    {
      if (!whitespace (rl_line_buffer[rl_point]))
	rl_point++;

      /* Move to the next non-whitespace character (to the start of the
	 next word). */
      while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))
	rl_point++;

      if (rl_point && rl_point < rl_end)
	{
	  /* Skip whitespace. */
	  while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))
	    rl_point++;

	  /* Skip until whitespace. */
	  while (rl_point < rl_end && !whitespace (rl_line_buffer[rl_point]))
	    rl_point++;

	  /* Move back to the last character of the word. */
	  rl_point--;
	}
    }
  return (0);
}

int
rl_vi_fword (count, ignore)
     int count, ignore;
{
  while (count-- && rl_point < (rl_end - 1))
    {
      /* Move to white space (really non-identifer). */
      if (_rl_isident (rl_line_buffer[rl_point]))
	{
	  while (_rl_isident (rl_line_buffer[rl_point]) && rl_point < rl_end)
	    rl_point++;
	}
      else /* if (!whitespace (rl_line_buffer[rl_point])) */
	{
	  while (!_rl_isident (rl_line_buffer[rl_point]) &&
		 !whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)
	    rl_point++;
	}

      /* Move past whitespace. */
      while (whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)
	rl_point++;
    }
  return (0);
}

int
rl_vi_bword (count, ignore)
     int count, ignore;
{
  while (count-- && rl_point > 0)
    {
      int last_is_ident;

      /* If we are at the start of a word, move back to whitespace
	 so we will go back to the start of the previous word. */
      if (!whitespace (rl_line_buffer[rl_point]) &&
	  whitespace (rl_line_buffer[rl_point - 1]))
	rl_point--;

      /* If this character and the previous character are `opposite', move
	 back so we don't get messed up by the rl_point++ down there in
	 the while loop.  Without this code, words like `l;' screw up the
	 function. */
      last_is_ident = _rl_isident (rl_line_buffer[rl_point - 1]);
      if ((_rl_isident (rl_line_buffer[rl_point]) && !last_is_ident) ||
	  (!_rl_isident (rl_line_buffer[rl_point]) && last_is_ident))
	rl_point--;

      while (rl_point > 0 && whitespace (rl_line_buffer[rl_point]))
	rl_point--;

      if (rl_point > 0)
	{
	  if (_rl_isident (rl_line_buffer[rl_point]))
	    while (--rl_point >= 0 && _rl_isident (rl_line_buffer[rl_point]));
	  else
	    while (--rl_point >= 0 && !_rl_isident (rl_line_buffer[rl_point]) &&
		   !whitespace (rl_line_buffer[rl_point]));
	  rl_point++;
	}
    }
  return (0);
}

int
rl_vi_eword (count, ignore)
     int count, ignore;
{
  while (count-- && rl_point < rl_end - 1)
    {
      if (!whitespace (rl_line_buffer[rl_point]))
	rl_point++;

      while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))
	rl_point++;

      if (rl_point < rl_end)
	{
	  if (_rl_isident (rl_line_buffer[rl_point]))
	    while (++rl_point < rl_end && _rl_isident (rl_line_buffer[rl_point]));
	  else
	    while (++rl_point < rl_end && !_rl_isident (rl_line_buffer[rl_point])
		   && !whitespace (rl_line_buffer[rl_point]));
	}
      rl_point--;
    }
  return (0);
}

int
rl_vi_insert_beg (count, key)
     int count, key;
{
  rl_beg_of_line (1, key);
  rl_vi_insert_mode (1, key);
  return (0);
}

static void
_rl_vi_append_forward (key)
     int key;
{
  int point;

  if (rl_point < rl_end)
    {
      if (MB_CUR_MAX == 1 || rl_byte_oriented)
	rl_point++;
      else
	{
	  point = rl_point;
#if 0
	  rl_forward_char (1, key);
#else
	  rl_point = _rl_forward_char_internal (1);
#endif
	  if (point == rl_point)
	    rl_point = rl_end;
	}
    }
}

int
rl_vi_append_mode (count, key)
     int count, key;
{
  _rl_vi_append_forward (key);
  rl_vi_start_inserting (key, 1, rl_arg_sign);
  return (0);
}

int
rl_vi_append_eol (count, key)
     int count, key;
{
  rl_end_of_line (1, key);
  rl_vi_append_mode (1, key);
  return (0);
}

/* What to do in the case of C-d. */
int
rl_vi_eof_maybe (count, c)
     int count, c;
{
  return (rl_newline (1, '\n'));
}

/* Insertion mode stuff. */

/* Switching from one mode to the other really just involves
   switching keymaps. */
int
rl_vi_insertion_mode (count, key)
     int count, key;
{
  _rl_keymap = vi_insertion_keymap;
  _rl_vi_last_key_before_insert = key;
  return (0);
}

int
rl_vi_insert_mode (count, key)
     int count, key;
{
  rl_vi_start_inserting (key, 1, rl_arg_sign);
  return (0);
}

static void
_rl_vi_save_insert (up)
      UNDO_LIST *up;
{
  int len, start, end;

  if (up == 0 || up->what != UNDO_INSERT)
    {
      if (vi_insert_buffer_size >= 1)
	vi_insert_buffer[0] = '\0';
      return;
    }

  start = up->start;
  end = up->end;
  len = end - start + 1;
  if (len >= vi_insert_buffer_size)
    {
      vi_insert_buffer_size += (len + 32) - (len % 32);
      vi_insert_buffer = (char *)xrealloc (vi_insert_buffer, vi_insert_buffer_size);
    }
  strncpy (vi_insert_buffer, rl_line_buffer + start, len - 1);
  vi_insert_buffer[len-1] = '\0';
}
    
void
_rl_vi_done_inserting ()
{
  if (_rl_vi_doing_insert)
    {
      /* The `C', `s', and `S' commands set this. */
      rl_end_undo_group ();
      /* Now, the text between rl_undo_list->next->start and
	 rl_undo_list->next->end is what was inserted while in insert
	 mode.  It gets copied to VI_INSERT_BUFFER because it depends
	 on absolute indices into the line which may change (though they
	 probably will not). */
      _rl_vi_doing_insert = 0;
      _rl_vi_save_insert (rl_undo_list->next);
      vi_continued_command = 1;
    }
  else
    {
      if (rl_undo_list && (_rl_vi_last_key_before_insert == 'i' ||
			   _rl_vi_last_key_before_insert == 'a' ||
			   _rl_vi_last_key_before_insert == 'I' ||
			   _rl_vi_last_key_before_insert == 'A'))
	_rl_vi_save_insert (rl_undo_list);
      /* XXX - Other keys probably need to be checked. */
      else if (_rl_vi_last_key_before_insert == 'C')
	rl_end_undo_group ();
      while (_rl_undo_group_level > 0)
	rl_end_undo_group ();
      vi_continued_command = 0;
    }
}

int
rl_vi_movement_mode (count, key)
     int count, key;
{
  if (rl_point > 0)
    rl_backward_char (1, key);

  _rl_keymap = vi_movement_keymap;
  _rl_vi_done_inserting ();

  /* This is how POSIX.2 says `U' should behave -- everything up until the
     first time you go into command mode should not be undone. */
  if (RL_ISSTATE (RL_STATE_VICMDONCE) == 0)
    rl_free_undo_list ();

  RL_SETSTATE (RL_STATE_VICMDONCE);
  return (0);
}

int
rl_vi_arg_digit (count, c)
     int count, c;
{
  if (c == '0' && rl_numeric_arg == 1 && !rl_explicit_arg)
    return (rl_beg_of_line (1, c));
  else
    return (rl_digit_argument (count, c));
}

/* Change the case of the next COUNT characters. */
#if defined (HANDLE_MULTIBYTE)
static int
_rl_vi_change_mbchar_case (count)
     int count;
{
  wchar_t wc;
  char mb[MB_LEN_MAX+1];
  int mlen, p;
  size_t m;
  mbstate_t ps;

  memset (&ps, 0, sizeof (mbstate_t));
  if (_rl_adjust_point (rl_line_buffer, rl_point, &ps) > 0)
    count--;
  while (count-- && rl_point < rl_end)
    {
      m = mbrtowc (&wc, rl_line_buffer + rl_point, rl_end - rl_point, &ps);
      if (MB_INVALIDCH (m))
	wc = (wchar_t)rl_line_buffer[rl_point];
      else if (MB_NULLWCH (m))
	wc = L'\0';
      if (iswupper (wc))
	wc = towlower (wc);
      else if (iswlower (wc))
	wc = towupper (wc);
      else
	{
	  /* Just skip over chars neither upper nor lower case */
	  rl_forward_char (1, 0);
	  continue;
	}

      /* Vi is kind of strange here. */
      if (wc)
	{
	  p = rl_point;
	  mlen = wcrtomb (mb, wc, &ps);
	  if (mlen >= 0)
	    mb[mlen] = '\0';
	  rl_begin_undo_group ();
	  rl_vi_delete (1, 0);
	  if (rl_point < p)	/* Did we retreat at EOL? */
	    rl_point++;	/* XXX - should we advance more than 1 for mbchar? */
	  rl_insert_text (mb);
	  rl_end_undo_group ();
	  rl_vi_check ();
	}
      else
	rl_forward_char (1, 0);
    }

  return 0;
}
#endif

int
rl_vi_change_case (count, ignore)
     int count, ignore;
{
  int c, p;

  /* Don't try this on an empty line. */
  if (rl_point >= rl_end)
    return (0);

  c = 0;
#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    return (_rl_vi_change_mbchar_case (count));
#endif

  while (count-- && rl_point < rl_end)
    {
      if (_rl_uppercase_p (rl_line_buffer[rl_point]))
	c = _rl_to_lower (rl_line_buffer[rl_point]);
      else if (_rl_lowercase_p (rl_line_buffer[rl_point]))
	c = _rl_to_upper (rl_line_buffer[rl_point]);
      else
	{
	  /* Just skip over characters neither upper nor lower case. */
	  rl_forward_char (1, c);
	  continue;
	}

      /* Vi is kind of strange here. */
      if (c)
	{
	  p = rl_point;
	  rl_begin_undo_group ();
	  rl_vi_delete (1, c);
	  if (rl_point < p)	/* Did we retreat at EOL? */
	    rl_point++;
	  _rl_insert_char (1, c);
	  rl_end_undo_group ();
	  rl_vi_check ();
	}
      else
	rl_forward_char (1, c);
    }
  return (0);
}

int
rl_vi_put (count, key)
     int count, key;
{
  if (!_rl_uppercase_p (key) && (rl_point + 1 <= rl_end))
    rl_point = _rl_find_next_mbchar (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);

  while (count--)
    rl_yank (1, key);

  rl_backward_char (1, key);
  return (0);
}

static void
_rl_vi_backup ()
{
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);
  else
    rl_point--;
}

int
rl_vi_check ()
{
  if (rl_point && rl_point == rl_end)
    {
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);
      else
	rl_point--;
    }
  return (0);
}

int
rl_vi_column (count, key)
     int count, key;
{
  if (count > rl_end)
    rl_end_of_line (1, key);
  else
    rl_point = count - 1;
  return (0);
}

/* Process C as part of the current numeric argument.  Return -1 if the
   argument should be aborted, 0 if we should not read any more chars, and
   1 if we should continue to read chars. */
static int
_rl_vi_arg_dispatch (c)
     int c;
{
  int key;

  key = c;
  if (c >= 0 && _rl_keymap[c].type == ISFUNC && _rl_keymap[c].function == rl_universal_argument)
    {
      rl_numeric_arg *= 4;
      return 1;
    }

  c = UNMETA (c);

  if (_rl_digit_p (c))
    {
      if (rl_explicit_arg)
	rl_numeric_arg = (rl_numeric_arg * 10) + _rl_digit_value (c);
      else
	rl_numeric_arg = _rl_digit_value (c);
      rl_explicit_arg = 1;
      return 1;		/* keep going */
    }
  else
    {
      rl_clear_message ();
      rl_stuff_char (key);
      return 0;		/* done */
    }
}

/* A simplified loop for vi. Don't dispatch key at end.
   Don't recognize minus sign?
   Should this do rl_save_prompt/rl_restore_prompt? */
static int
rl_digit_loop1 ()
{
  int c, r;

  while (1)
    {
      if (_rl_arg_overflow ())
	return 1;

      c = _rl_arg_getchar ();

      r = _rl_vi_arg_dispatch (c);
      if (r <= 0)
	break;
    }

  RL_UNSETSTATE(RL_STATE_NUMERICARG);
  return (0);
}

static void
_rl_mvcxt_init (m, op, key)
     _rl_vimotion_cxt *m;
     int op, key;
{
  m->op = op;
  m->state = m->flags = 0;
  m->ncxt = 0;
  m->numeric_arg = -1;
  m->start = rl_point;
  m->end = rl_end;
  m->key = key;
  m->motion = -1;
}

static _rl_vimotion_cxt *
_rl_mvcxt_alloc (op, key)
     int op, key;
{
  _rl_vimotion_cxt *m;

  m = xmalloc (sizeof (_rl_vimotion_cxt));
  _rl_mvcxt_init (m, op, key);
  return m;
}

static void
_rl_mvcxt_dispose (m)
     _rl_vimotion_cxt *m;
{
  xfree (m);
}

static int
rl_domove_motion_callback (m)
     _rl_vimotion_cxt *m;
{
  int c, save, r;
  int old_end;

  _rl_vi_last_motion = c = m->motion;

  /* Append a blank character temporarily so that the motion routines
     work right at the end of the line. */
  old_end = rl_end;
  rl_line_buffer[rl_end++] = ' ';
  rl_line_buffer[rl_end] = '\0';

  _rl_dispatch (c, _rl_keymap);

  /* Remove the blank that we added. */
  rl_end = old_end;
  rl_line_buffer[rl_end] = '\0';
  if (rl_point > rl_end)
    rl_point = rl_end;

  /* No change in position means the command failed. */
  if (rl_mark == rl_point)
    return (-1);

  /* rl_vi_f[wW]ord () leaves the cursor on the first character of the next
     word.  If we are not at the end of the line, and we are on a
     non-whitespace character, move back one (presumably to whitespace). */
  if ((_rl_to_upper (c) == 'W') && rl_point < rl_end && rl_point > rl_mark &&
      !whitespace (rl_line_buffer[rl_point]))
    rl_point--;

  /* If cw or cW, back up to the end of a word, so the behaviour of ce
     or cE is the actual result.  Brute-force, no subtlety. */
  if (m->key == 'c' && rl_point >= rl_mark && (_rl_to_upper (c) == 'W'))
    {
      /* Don't move farther back than where we started. */
      while (rl_point > rl_mark && whitespace (rl_line_buffer[rl_point]))
	rl_point--;

      /* Posix.2 says that if cw or cW moves the cursor towards the end of
	 the line, the character under the cursor should be deleted. */
      if (rl_point == rl_mark)
	rl_point++;
      else
	{
	  /* Move past the end of the word so that the kill doesn't
	     remove the last letter of the previous word.  Only do this
	     if we are not at the end of the line. */
	  if (rl_point >= 0 && rl_point < (rl_end - 1) && !whitespace (rl_line_buffer[rl_point]))
	    rl_point++;
	}
    }

  if (rl_mark < rl_point)
    SWAP (rl_point, rl_mark);

#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    (*rl_redisplay_function)();		/* make sure motion is displayed */
#endif

  r = vidomove_dispatch (m);

  return (r);
}

#define RL_VIMOVENUMARG()	(RL_ISSTATE (RL_STATE_VIMOTION) && RL_ISSTATE (RL_STATE_NUMERICARG))

static int
rl_domove_read_callback (m)
     _rl_vimotion_cxt *m;
{
  int c, save;

  c = m->motion;

  if (member (c, vi_motion))
    {
#if defined (READLINE_CALLBACKS)
      /* If we just read a vi-mode motion command numeric argument, turn off
	 the `reading numeric arg' state */
      if (RL_ISSTATE (RL_STATE_CALLBACK) && RL_VIMOVENUMARG())
	RL_UNSETSTATE (RL_STATE_NUMERICARG);
#endif
      /* Should do everything, including turning off RL_STATE_VIMOTION */
      return (rl_domove_motion_callback (m));
    }
  else if (m->key == c && (m->key == 'd' || m->key == 'y' || m->key == 'c'))
    {
      rl_mark = rl_end;
      rl_beg_of_line (1, c);
      _rl_vi_last_motion = c;
      RL_UNSETSTATE (RL_STATE_VIMOTION);
      return (vidomove_dispatch (m));
    }
#if defined (READLINE_CALLBACKS)
  /* XXX - these need to handle rl_universal_argument bindings */
  /* Reading vi motion char continuing numeric argument */
  else if (_rl_digit_p (c) && RL_ISSTATE (RL_STATE_CALLBACK) && RL_VIMOVENUMARG())
    {
      return (_rl_vi_arg_dispatch (c));
    }
  /* Readine vi motion char starting numeric argument */
  else if (_rl_digit_p (c) && RL_ISSTATE (RL_STATE_CALLBACK) && RL_ISSTATE (RL_STATE_VIMOTION) && (RL_ISSTATE (RL_STATE_NUMERICARG) == 0))
    {
      RL_SETSTATE (RL_STATE_NUMERICARG);
      return (_rl_vi_arg_dispatch (c));
    }
#endif
  else if (_rl_digit_p (c))
    {
      /* This code path taken when not in callback mode */
      save = rl_numeric_arg;
      rl_numeric_arg = _rl_digit_value (c);
      rl_explicit_arg = 1;
      RL_SETSTATE (RL_STATE_NUMERICARG);
      rl_digit_loop1 ();
      rl_numeric_arg *= save;
      c = rl_vi_domove_getchar (m);
      if (c < 0)
	{
	  m->motion = 0;
	  return -1;
	}
      m->motion = c;
      return (rl_domove_motion_callback (m));
    }
  else
    {
      RL_UNSETSTATE (RL_STATE_VIMOTION);
      RL_UNSETSTATE (RL_STATE_NUMERICARG);
      return (1);
    }
}

static int
rl_vi_domove_getchar (m)
     _rl_vimotion_cxt *m;
{
  int c;

  RL_SETSTATE(RL_STATE_MOREINPUT);
  c = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

  return c;
}

#if defined (READLINE_CALLBACKS)
int
_rl_vi_domove_callback (m)
     _rl_vimotion_cxt *m;
{
  int c, r;

  m->motion = c = rl_vi_domove_getchar (m);
  /* XXX - what to do if this returns -1?  Should we return 1 for eof to
     callback code? */
  r = rl_domove_read_callback (m);

  return ((r == 0) ? r : 1);	/* normalize return values */
}
#endif

/* This code path taken when not in callback mode. */
int
rl_vi_domove (x, ignore)
     int x, *ignore;
{
  int r;
  _rl_vimotion_cxt *m;

  m = _rl_vimvcxt;
  *ignore = m->motion = rl_vi_domove_getchar (m);

  if (m->motion < 0)
    {
      m->motion = 0;
      return -1;
    }

  return (rl_domove_read_callback (m));
}

static int
vi_delete_dispatch (m)
     _rl_vimotion_cxt *m;
{
  /* These are the motion commands that do not require adjusting the
     mark. */
  if (((strchr (" l|h^0bBFT`", m->motion) == 0) && (rl_point >= m->start)) &&
      (rl_mark < rl_end))
    rl_mark++;

  rl_kill_text (rl_point, rl_mark);
  return (0);
}

int
rl_vi_delete_to (count, key)
     int count, key;
{
  int c, r;

  _rl_vimvcxt = _rl_mvcxt_alloc (VIM_DELETE, key);
  _rl_vimvcxt->start = rl_point;

  rl_mark = rl_point;
  if (_rl_uppercase_p (key))
    {
      _rl_vimvcxt->motion = '$';
      r = rl_domove_motion_callback (_rl_vimvcxt);
    }
  else if (vi_redoing)
    {
      _rl_vimvcxt->motion = _rl_vi_last_motion;
      r = rl_domove_motion_callback (_rl_vimvcxt);
    }
#if defined (READLINE_CALLBACKS)
  else if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      RL_SETSTATE (RL_STATE_VIMOTION);
      return (0);
    }
#endif
  else
    r = rl_vi_domove (key, &c);

  if (r < 0)
    {
      rl_ding ();
      r = -1;
    }

  _rl_mvcxt_dispose (_rl_vimvcxt);
  _rl_vimvcxt = 0;

  return r;
}

static int
vi_change_dispatch (m)
     _rl_vimotion_cxt *m;
{
  /* These are the motion commands that do not require adjusting the
     mark.  c[wW] are handled by special-case code in rl_vi_domove(),
     and already leave the mark at the correct location. */
  if (((strchr (" l|hwW^0bBFT`", m->motion) == 0) && (rl_point >= m->start)) &&
      (rl_mark < rl_end))
    rl_mark++;

  /* The cursor never moves with c[wW]. */
  if ((_rl_to_upper (m->motion) == 'W') && rl_point < m->start)
    rl_point = m->start;

  if (vi_redoing)
    {
      if (vi_insert_buffer && *vi_insert_buffer)
	rl_begin_undo_group ();
      rl_delete_text (rl_point, rl_mark);
      if (vi_insert_buffer && *vi_insert_buffer)
	{
	  rl_insert_text (vi_insert_buffer);
	  rl_end_undo_group ();
	}
    }
  else
    {
      rl_begin_undo_group ();		/* to make the `u' command work */
      rl_kill_text (rl_point, rl_mark);
      /* `C' does not save the text inserted for undoing or redoing. */
      if (_rl_uppercase_p (m->key) == 0)
	_rl_vi_doing_insert = 1;
      /* XXX -- TODO -- use m->numericarg? */
      rl_vi_start_inserting (m->key, rl_numeric_arg, rl_arg_sign);
    }

  return (0);
}

int
rl_vi_change_to (count, key)
     int count, key;
{
  int c, r;

  _rl_vimvcxt = _rl_mvcxt_alloc (VIM_CHANGE, key);
  _rl_vimvcxt->start = rl_point;

  rl_mark = rl_point;
  if (_rl_uppercase_p (key))
    {
      _rl_vimvcxt->motion = '$';
      r = rl_domove_motion_callback (_rl_vimvcxt);
    }
  else if (vi_redoing)
    {
      _rl_vimvcxt->motion = _rl_vi_last_motion;
      r = rl_domove_motion_callback (_rl_vimvcxt);
    }
#if defined (READLINE_CALLBACKS)
  else if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      RL_SETSTATE (RL_STATE_VIMOTION);
      return (0);
    }
#endif
  else
    r = rl_vi_domove (key, &c);

  if (r < 0)
    {
      rl_ding ();
      r = -1;	/* normalize return value */
    }

  _rl_mvcxt_dispose (_rl_vimvcxt);
  _rl_vimvcxt = 0;

  return r;
}

static int
vi_yank_dispatch (m)
     _rl_vimotion_cxt *m;
{
  /* These are the motion commands that do not require adjusting the
     mark. */
  if (((strchr (" l|h^0%bBFT`", m->motion) == 0) && (rl_point >= m->start)) &&
      (rl_mark < rl_end))
    rl_mark++;

  rl_begin_undo_group ();
  rl_kill_text (rl_point, rl_mark);
  rl_end_undo_group ();
  rl_do_undo ();
  rl_point = m->start;

  return (0);
}

int
rl_vi_yank_to (count, key)
     int count, key;
{
  int c, r;

  _rl_vimvcxt = _rl_mvcxt_alloc (VIM_YANK, key);
  _rl_vimvcxt->start = rl_point;

  rl_mark = rl_point;
  if (_rl_uppercase_p (key))
    {
      _rl_vimvcxt->motion = '$';
      r = rl_domove_motion_callback (_rl_vimvcxt);
    }
#if defined (READLINE_CALLBACKS)
  else if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      RL_SETSTATE (RL_STATE_VIMOTION);
      return (0);
    }
#endif
  else
    r = rl_vi_domove (key, &c);

  if (r < 0)
    {
      rl_ding ();
      r = -1;
    }

  _rl_mvcxt_dispose (_rl_vimvcxt);
  _rl_vimvcxt = 0;

  return r;
}

static int
vidomove_dispatch (m)
     _rl_vimotion_cxt *m;
{
  int r;

  switch (m->op)
    {
    case VIM_DELETE:
      r = vi_delete_dispatch (m);
      break;
    case VIM_CHANGE:
      r = vi_change_dispatch (m);
      break;
    case VIM_YANK:
      r = vi_yank_dispatch (m);
      break;
    default:
      _rl_errmsg ("vidomove_dispatch: unknown operator %d", m->op);
      r = 1;
      break;
    }

  RL_UNSETSTATE (RL_STATE_VIMOTION);
  return r;
}

int
rl_vi_rubout (count, key)
     int count, key;
{
  int opoint;

  if (count < 0)
    return (rl_vi_delete (-count, key));

  if (rl_point == 0)
    {
      rl_ding ();
      return -1;
    }

  opoint = rl_point;
  if (count > 1 && MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    rl_backward_char (count, key);
  else if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);
  else
    rl_point -= count;

  if (rl_point < 0)
    rl_point = 0;

  rl_kill_text (rl_point, opoint);
  
  return (0);
}

int
rl_vi_delete (count, key)
     int count, key;
{
  int end;

  if (count < 0)
    return (rl_vi_rubout (-count, key));

  if (rl_end == 0)
    {
      rl_ding ();
      return -1;
    }

  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    end = _rl_find_next_mbchar (rl_line_buffer, rl_point, count, MB_FIND_NONZERO);
  else
    end = rl_point + count;

  if (end >= rl_end)
    end = rl_end;

  rl_kill_text (rl_point, end);
  
  if (rl_point > 0 && rl_point == rl_end)
    rl_backward_char (1, key);

  return (0);
}

int
rl_vi_back_to_indent (count, key)
     int count, key;
{
  rl_beg_of_line (1, key);
  while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))
    rl_point++;
  return (0);
}

int
rl_vi_first_print (count, key)
     int count, key;
{
  return (rl_vi_back_to_indent (1, key));
}

static int _rl_cs_dir, _rl_cs_orig_dir;

#if defined (READLINE_CALLBACKS)
static int
_rl_vi_callback_char_search (data)
     _rl_callback_generic_arg *data;
{
  int c;
#if defined (HANDLE_MULTIBYTE)
  c = _rl_vi_last_search_mblen = _rl_read_mbchar (_rl_vi_last_search_mbchar, MB_LEN_MAX);
#else
  RL_SETSTATE(RL_STATE_MOREINPUT);
  c = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);
#endif

  if (c <= 0)
    return -1;

#if !defined (HANDLE_MULTIBYTE)
  _rl_vi_last_search_char = c;
#endif

  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

#if defined (HANDLE_MULTIBYTE)
  return (_rl_char_search_internal (data->count, _rl_cs_dir, _rl_vi_last_search_mbchar, _rl_vi_last_search_mblen));
#else
  return (_rl_char_search_internal (data->count, _rl_cs_dir, _rl_vi_last_search_char));
#endif  
}
#endif

int
rl_vi_char_search (count, key)
     int count, key;
{
  int c;
#if defined (HANDLE_MULTIBYTE)
  static char *target;
  static int tlen;
#else
  static char target;
#endif

  if (key == ';' || key == ',')
    {
      if (_rl_cs_orig_dir == 0)
	return -1;
#if defined (HANDLE_MULTIBYTE)
      if (_rl_vi_last_search_mblen == 0)
	return -1;
#else
      if (_rl_vi_last_search_char == 0)
	return -1;
#endif
      _rl_cs_dir = (key == ';') ? _rl_cs_orig_dir : -_rl_cs_orig_dir;
    }
  else
    {
      switch (key)
	{
	case 't':
	  _rl_cs_orig_dir = _rl_cs_dir = FTO;
	  break;

	case 'T':
	  _rl_cs_orig_dir = _rl_cs_dir = BTO;
	  break;

	case 'f':
	  _rl_cs_orig_dir = _rl_cs_dir = FFIND;
	  break;

	case 'F':
	  _rl_cs_orig_dir = _rl_cs_dir = BFIND;
	  break;
	}

      if (vi_redoing)
	{
	  /* set target and tlen below */
	}
#if defined (READLINE_CALLBACKS)
      else if (RL_ISSTATE (RL_STATE_CALLBACK))
	{
	  _rl_callback_data = _rl_callback_data_alloc (count);
	  _rl_callback_data->i1 = _rl_cs_dir;
	  _rl_callback_func = _rl_vi_callback_char_search;
	  return (0);
	}
#endif
      else
	{
#if defined (HANDLE_MULTIBYTE)
	  c = _rl_read_mbchar (_rl_vi_last_search_mbchar, MB_LEN_MAX);
	  if (c <= 0)
	    return -1;
	  _rl_vi_last_search_mblen = c;
#else
	  RL_SETSTATE(RL_STATE_MOREINPUT);
	  c = rl_read_key ();
	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
	  if (c < 0)
	    return -1;
	  _rl_vi_last_search_char = c;
#endif
	}
    }

#if defined (HANDLE_MULTIBYTE)
  target = _rl_vi_last_search_mbchar;
  tlen = _rl_vi_last_search_mblen;
#else
  target = _rl_vi_last_search_char;
#endif

#if defined (HANDLE_MULTIBYTE)
  return (_rl_char_search_internal (count, _rl_cs_dir, target, tlen));
#else
  return (_rl_char_search_internal (count, _rl_cs_dir, target));
#endif
}

/* Match brackets */
int
rl_vi_match (ignore, key)
     int ignore, key;
{
  int count = 1, brack, pos, tmp, pre;

  pos = rl_point;
  if ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0)
    {
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  while ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0)
	    {
	      pre = rl_point;
	      rl_forward_char (1, key);
	      if (pre == rl_point)
		break;
	    }
	}
      else
	while ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0 &&
		rl_point < rl_end - 1)
	  rl_forward_char (1, key);

      if (brack <= 0)
	{
	  rl_point = pos;
	  rl_ding ();
	  return -1;
	}
    }

  pos = rl_point;

  if (brack < 0)
    {
      while (count)
	{
	  tmp = pos;
	  if (MB_CUR_MAX == 1 || rl_byte_oriented)
	    pos--;
	  else
	    {
	      pos = _rl_find_prev_mbchar (rl_line_buffer, pos, MB_FIND_ANY);
	      if (tmp == pos)
		pos--;
	    }
	  if (pos >= 0)
	    {
	      int b = rl_vi_bracktype (rl_line_buffer[pos]);
	      if (b == -brack)
		count--;
	      else if (b == brack)
		count++;
	    }
	  else
	    {
	      rl_ding ();
	      return -1;
	    }
	}
    }
  else
    {			/* brack > 0 */
      while (count)
	{
	  if (MB_CUR_MAX == 1 || rl_byte_oriented)
	    pos++;
	  else
	    pos = _rl_find_next_mbchar (rl_line_buffer, pos, 1, MB_FIND_ANY);

	  if (pos < rl_end)
	    {
	      int b = rl_vi_bracktype (rl_line_buffer[pos]);
	      if (b == -brack)
		count--;
	      else if (b == brack)
		count++;
	    }
	  else
	    {
	      rl_ding ();
	      return -1;
	    }
	}
    }
  rl_point = pos;
  return (0);
}

int
rl_vi_bracktype (c)
     int c;
{
  switch (c)
    {
    case '(': return  1;
    case ')': return -1;
    case '[': return  2;
    case ']': return -2;
    case '{': return  3;
    case '}': return -3;
    default:  return  0;
    }
}

static int
_rl_vi_change_char (count, c, mb)
     int count, c;
     char *mb;
{
  int p;

  if (c == '\033' || c == CTRL ('C'))
    return -1;

  rl_begin_undo_group ();
  while (count-- && rl_point < rl_end)
    {
      p = rl_point;
      rl_vi_delete (1, c);
      if (rl_point < p)		/* Did we retreat at EOL? */
	rl_point++;
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_insert_text (mb);
      else
#endif
	_rl_insert_char (1, c);
    }

  /* The cursor shall be left on the last character changed. */
  rl_backward_char (1, c);

  rl_end_undo_group ();

  return (0);
}

static int
_rl_vi_callback_getchar (mb, mlen)
     char *mb;
     int mlen;
{
  int c;

  RL_SETSTATE(RL_STATE_MOREINPUT);
  c = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

  if (c < 0)
    return -1;

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    c = _rl_read_mbstring (c, mb, mlen);
#endif

  return c;
}

#if defined (READLINE_CALLBACKS)
static int
_rl_vi_callback_change_char (data)
     _rl_callback_generic_arg *data;
{
  int c;
  char mb[MB_LEN_MAX];

  _rl_vi_last_replacement = c = _rl_vi_callback_getchar (mb, MB_LEN_MAX);

  if (c < 0)
    return -1;

  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

  return (_rl_vi_change_char (data->count, c, mb));
}
#endif

int
rl_vi_change_char (count, key)
     int count, key;
{
  int c;
  char mb[MB_LEN_MAX];

  if (vi_redoing)
    {
      c = _rl_vi_last_replacement;
      mb[0] = c;
      mb[1] = '\0';
    }
#if defined (READLINE_CALLBACKS)
  else if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = _rl_callback_data_alloc (count);
      _rl_callback_func = _rl_vi_callback_change_char;
      return (0);
    }
#endif
  else
    _rl_vi_last_replacement = c = _rl_vi_callback_getchar (mb, MB_LEN_MAX);

  if (c < 0)
    return -1;

  return (_rl_vi_change_char (count, c, mb));
}

int
rl_vi_subst (count, key)
     int count, key;
{
  /* If we are redoing, rl_vi_change_to will stuff the last motion char */
  if (vi_redoing == 0)
    rl_stuff_char ((key == 'S') ? 'c' : 'l');	/* `S' == `cc', `s' == `cl' */

  return (rl_vi_change_to (count, 'c'));
}

int
rl_vi_overstrike (count, key)
     int count, key;
{
  if (_rl_vi_doing_insert == 0)
    {
      _rl_vi_doing_insert = 1;
      rl_begin_undo_group ();
    }

  if (count > 0)
    {
      _rl_overwrite_char (count, key);
      vi_replace_count += count;
    }

  return (0);
}

int
rl_vi_overstrike_delete (count, key)
     int count, key;
{
  int i, s;

  for (i = 0; i < count; i++)
    {
      if (vi_replace_count == 0)
	{
	  rl_ding ();
	  break;
	}
      s = rl_point;

      if (rl_do_undo ())
	vi_replace_count--;

      if (rl_point == s)
	rl_backward_char (1, key);
    }

  if (vi_replace_count == 0 && _rl_vi_doing_insert)
    {
      rl_end_undo_group ();
      rl_do_undo ();
      _rl_vi_doing_insert = 0;
    }
  return (0);
}

int
rl_vi_replace (count, key)
     int count, key;
{
  int i;

  vi_replace_count = 0;

  if (!vi_replace_map)
    {
      vi_replace_map = rl_make_bare_keymap ();

      for (i = ' '; i < KEYMAP_SIZE; i++)
	vi_replace_map[i].function = rl_vi_overstrike;

      vi_replace_map[RUBOUT].function = rl_vi_overstrike_delete;
      vi_replace_map[ESC].function = rl_vi_movement_mode;
      vi_replace_map[RETURN].function = rl_newline;
      vi_replace_map[NEWLINE].function = rl_newline;

      /* If the normal vi insertion keymap has ^H bound to erase, do the
	 same here.  Probably should remove the assignment to RUBOUT up
	 there, but I don't think it will make a difference in real life. */
      if (vi_insertion_keymap[CTRL ('H')].type == ISFUNC &&
	  vi_insertion_keymap[CTRL ('H')].function == rl_rubout)
	vi_replace_map[CTRL ('H')].function = rl_vi_overstrike_delete;

    }
  _rl_keymap = vi_replace_map;
  return (0);
}

#if 0
/* Try to complete the word we are standing on or the word that ends with
   the previous character.  A space matches everything.  Word delimiters are
   space and ;. */
int
rl_vi_possible_completions()
{
  int save_pos = rl_point;

  if (rl_line_buffer[rl_point] != ' ' && rl_line_buffer[rl_point] != ';')
    {
      while (rl_point < rl_end && rl_line_buffer[rl_point] != ' ' &&
	     rl_line_buffer[rl_point] != ';')
	rl_point++;
    }
  else if (rl_line_buffer[rl_point - 1] == ';')
    {
      rl_ding ();
      return (0);
    }

  rl_possible_completions ();
  rl_point = save_pos;

  return (0);
}
#endif

/* Functions to save and restore marks. */
static int
_rl_vi_set_mark ()
{
  int ch;

  RL_SETSTATE(RL_STATE_MOREINPUT);
  ch = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

  if (ch < 0 || ch < 'a' || ch > 'z')	/* make test against 0 explicit */
    {
      rl_ding ();
      return -1;
    }
  ch -= 'a';
  vi_mark_chars[ch] = rl_point;
  return 0;
}

#if defined (READLINE_CALLBACKS)
static int
_rl_vi_callback_set_mark (data)
     _rl_callback_generic_arg *data;
{
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

  return (_rl_vi_set_mark ());
}
#endif

int
rl_vi_set_mark (count, key)
     int count, key;
{
#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = 0;
      _rl_callback_func = _rl_vi_callback_set_mark;
      return (0);
    }
#endif

  return (_rl_vi_set_mark ());
}

static int
_rl_vi_goto_mark ()
{
  int ch;

  RL_SETSTATE(RL_STATE_MOREINPUT);
  ch = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

  if (ch == '`')
    {
      rl_point = rl_mark;
      return 0;
    }
  else if (ch < 0 || ch < 'a' || ch > 'z')	/* make test against 0 explicit */
    {
      rl_ding ();
      return -1;
    }

  ch -= 'a';
  if (vi_mark_chars[ch] == -1)
    {
      rl_ding ();
      return -1;
    }
  rl_point = vi_mark_chars[ch];
  return 0;
}

#if defined (READLINE_CALLBACKS)
static int
_rl_vi_callback_goto_mark (data)
     _rl_callback_generic_arg *data;
{
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

  return (_rl_vi_goto_mark ());
}
#endif

int
rl_vi_goto_mark (count, key)
     int count, key;
{
#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = 0;
      _rl_callback_func = _rl_vi_callback_goto_mark;
      return (0);
    }
#endif

  return (_rl_vi_goto_mark ());
}
#endif /* VI_MODE */
@


1.7
log
@Readline 5.1 import for HEAD.
@
text
@d4 1
a4 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
d6 2
a7 2
   This file is part of the GNU Readline Library, a library for
   reading lines of text with interactive input and history editing.
d9 3
a11 3
   The GNU Readline Library is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2, or
d14 3
a16 3
   The GNU Readline Library is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
d19 4
a22 4
   The GNU General Public License is often shipped with GNU software, and
   is generally kept in a file called COPYING or LICENSE.  If you do not
   have a copy of the license, write to the Free Software Foundation,
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
d68 2
d74 1
a74 1
static const char *vi_motion = " hl^$0ftFT;,%wbeWBE|";
d106 1
a106 1
static const char *vi_textmod = "_*\\AaIiCcDdPpYyRrSsXx~";
d114 2
d122 2
d133 10
d146 1
a146 1
  register int i;
d148 2
a149 1
  for (i = 0; i < sizeof (vi_mark_chars) / sizeof (int); i++)
d225 28
a252 1
	rl_point--;
d618 1
a618 1
  rl_vi_insertion_mode (1, key);
d622 3
a624 3
int
rl_vi_append_mode (count, key)
     int count, key;
d626 2
d633 10
a642 6
        {
          int point = rl_point;
          rl_forward_char (1, key);
          if (point == rl_point)
            rl_point = rl_end;
        }
d644 8
a651 1
  rl_vi_insertion_mode (1, key);
d685 8
d699 1
a699 1
  if (up == 0)
d736 5
a740 2
      if ((_rl_vi_last_key_before_insert == 'i' || _rl_vi_last_key_before_insert == 'a') && rl_undo_list)
        _rl_vi_save_insert (rl_undo_list);
d787 2
a788 1
  int mblen, p;
d796 5
a800 1
      mbrtowc (&wc, rl_line_buffer + rl_point, rl_end - rl_point, &ps);
d816 3
a818 3
	  mblen = wcrtomb (mb, wc, &ps);
	  if (mblen >= 0)
	    mb[mblen] = '\0';
d828 1
a828 1
        rl_forward_char (1, 0);
d875 1
a875 1
        }
d896 9
d913 1
a913 1
        rl_point--;
d929 6
a934 3
int
rl_vi_domove (key, nextkey)
     int key, *nextkey;
d936 8
a943 2
  int c, save;
  int old_end;
d945 1
a945 5
  rl_mark = rl_point;
  RL_SETSTATE(RL_STATE_MOREINPUT);
  c = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);
  *nextkey = c;
d947 1
a947 1
  if (!member (c, vi_motion))
d949 2
a950 21
      if (_rl_digit_p (c))
	{
	  save = rl_numeric_arg;
	  rl_numeric_arg = _rl_digit_value (c);
	  rl_explicit_arg = 1;
	  RL_SETSTATE (RL_STATE_NUMERICARG|RL_STATE_VIMOTION);
	  rl_digit_loop1 ();
	  RL_UNSETSTATE (RL_STATE_VIMOTION);
	  rl_numeric_arg *= save;
	  RL_SETSTATE(RL_STATE_MOREINPUT);
	  c = rl_read_key ();	/* real command */
	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
	  *nextkey = c;
	}
      else if (key == c && (key == 'd' || key == 'y' || key == 'c'))
	{
	  rl_mark = rl_end;
	  rl_beg_of_line (1, c);
	  _rl_vi_last_motion = c;
	  return (0);
	}
d952 3
a954 1
	return (-1);
d956 64
d1021 8
a1028 1
  _rl_vi_last_motion = c;
d1057 1
a1057 1
  if (key == 'c' && rl_point >= rl_mark && (_rl_to_upper (c) == 'W'))
d1066 1
a1066 1
        rl_point++;
d1080 8
a1087 1
  return (0);
d1090 2
a1091 3
/* Process C as part of the current numeric argument.  Return -1 if the
   argument should be aborted, 0 if we should not read any more chars, and
   1 if we should continue to read chars. */
d1093 2
a1094 2
_rl_vi_arg_dispatch (c)
     int c;
d1096 3
a1098 1
  int key;
d1100 28
a1127 2
  key = c;
  if (c >= 0 && _rl_keymap[c].type == ISFUNC && _rl_keymap[c].function == rl_universal_argument)
d1129 2
a1130 2
      rl_numeric_arg *= 4;
      return 1;
d1132 2
a1133 4

  c = UNMETA (c);

  if (_rl_digit_p (c))
d1135 3
a1137 4
      if (rl_explicit_arg)
	rl_numeric_arg = (rl_numeric_arg * 10) + _rl_digit_value (c);
      else
	rl_numeric_arg = _rl_digit_value (c);
d1139 11
a1149 1
      return 1;
d1153 3
a1155 3
      rl_clear_message ();
      rl_stuff_char (key);
      return 0;
a1158 3
/* A simplified loop for vi. Don't dispatch key at end.
   Don't recognize minus sign?
   Should this do rl_save_prompt/rl_restore_prompt? */
d1160 2
a1161 1
rl_digit_loop1 ()
d1163 5
a1167 1
  int c, r;
d1169 2
a1170 4
  while (1)
    {
      if (_rl_arg_overflow ())
	return 1;
d1172 6
a1177 1
      c = _rl_arg_getchar ();
d1179 4
a1182 4
      r = _rl_vi_arg_dispatch (c);
      if (r <= 0)
	break;
    }
d1184 1
a1184 2
  RL_UNSETSTATE(RL_STATE_NUMERICARG);
  return (0);
d1186 1
d1188 1
d1190 2
a1191 2
rl_vi_delete_to (count, key)
     int count, key;
d1193 2
a1194 1
  int c;
d1196 2
a1197 4
  if (_rl_uppercase_p (key))
    rl_stuff_char ('$');
  else if (vi_redoing)
    rl_stuff_char (_rl_vi_last_motion);
d1199 1
a1199 1
  if (rl_vi_domove (key, &c))
d1201 1
a1201 1
      rl_ding ();
d1205 7
d1214 2
a1215 1
  if ((strchr (" l|h^0bB", c) == 0) && (rl_mark < rl_end))
d1223 1
a1223 1
rl_vi_change_to (count, key)
d1226 1
a1226 1
  int c, start_pos;
d1228 4
d1233 4
a1236 1
    rl_stuff_char ('$');
d1238 13
a1250 3
    rl_stuff_char (_rl_vi_last_motion);

  start_pos = rl_point;
d1252 1
a1252 1
  if (rl_vi_domove (key, &c))
d1255 1
a1255 1
      return -1;
d1258 10
d1271 2
a1272 1
  if ((strchr (" l|hwW^0bB", c) == 0) && (rl_mark < rl_end))
d1276 2
a1277 2
  if ((_rl_to_upper (c) == 'W') && rl_point < start_pos)
    rl_point = start_pos;
d1295 4
a1298 3
      if (_rl_uppercase_p (key) == 0)
        _rl_vi_doing_insert = 1;
      rl_vi_start_inserting (key, rl_numeric_arg, rl_arg_sign);
d1305 1
a1305 1
rl_vi_yank_to (count, key)
d1308 4
a1311 1
  int c, save;
d1313 1
a1313 1
  save = rl_point;
d1315 18
a1332 1
    rl_stuff_char ('$');
d1334 1
a1334 1
  if (rl_vi_domove (key, &c))
d1337 1
a1337 1
      return -1;
d1340 10
d1352 2
a1353 1
  if ((strchr (" l|h^0%bB", c) == 0) && (rl_mark < rl_end))
d1360 1
a1360 1
  rl_point = save;
d1366 64
d1433 1
a1433 1
  int p, opoint;
d1515 1
d1517 1
a1517 1
  _rl_vi_last_search_mblen = _rl_read_mbchar (_rl_vi_last_search_mbchar, MB_LEN_MAX);
d1520 1
a1520 1
  _rl_vi_last_search_char = rl_read_key ();
d1524 7
d1546 1
d1555 12
a1566 1
    _rl_cs_dir = (key == ';') ? _rl_cs_orig_dir : -_rl_cs_orig_dir;
d1570 17
a1586 17
        {
        case 't':
          _rl_cs_orig_dir = _rl_cs_dir = FTO;
          break;

        case 'T':
          _rl_cs_orig_dir = _rl_cs_dir = BTO;
          break;

        case 'f':
          _rl_cs_orig_dir = _rl_cs_dir = FFIND;
          break;

        case 'F':
          _rl_cs_orig_dir = _rl_cs_dir = BFIND;
          break;
        }
d1594 6
a1599 6
        {
          _rl_callback_data = _rl_callback_data_alloc (count);
          _rl_callback_data->i1 = _rl_cs_dir;
          _rl_callback_func = _rl_vi_callback_char_search;
          return (0);
        }
d1604 4
a1607 1
	  _rl_vi_last_search_mblen = _rl_read_mbchar (_rl_vi_last_search_mbchar, MB_LEN_MAX);
d1610 1
a1610 1
	  _rl_vi_last_search_char = rl_read_key ();
d1612 3
d1650 1
a1650 1
	        break;
d1679 1
a1679 1
	        pos--;
d1774 1
a1774 1
_rl_vi_callback_getchar (mb, mblen)
d1776 1
a1776 1
     int mblen;
d1784 3
d1789 1
a1789 1
    c = _rl_read_mbstring (c, mb, mblen);
d1805 3
d1839 3
d1927 2
a1928 2
         same here.  Probably should remove the assignment to RUBOUT up
         there, but I don't think it will make a difference in real life. */
d1976 1
a1976 1
  if (ch < 'a' || ch > 'z')
d2028 1
a2028 1
  else if (ch < 'a' || ch > 'z')
@


1.6
log
@touched all sources to ease import of readline-5.1
@
text
@d4 1
a4 1
/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
d66 2
a87 1
static int _rl_vi_last_command = 'i';	/* default `.' puts you in insert mode */
d93 1
d111 2
d115 12
d134 2
d156 10
d292 1
d297 1
d330 2
a331 4
    {
      _rl_vi_set_last (key, 1, rl_arg_sign);
      rl_vi_insertion_mode (1, key);
    }
d341 1
a341 2
  _rl_vi_set_last (key, 1, rl_arg_sign);	/* XXX */
  rl_vi_insertion_mode (1, key);
d459 2
a460 1
      while (++rl_point < rl_end && whitespace (rl_line_buffer[rl_point]));
d671 1
a671 1
      if (_rl_vi_last_key_before_insert == 'i' && rl_undo_list)
d691 7
d719 1
a719 1
  int mblen;
d742 2
a743 1
	  mblen = wctomb (mb, wc);
d747 3
a749 1
	  rl_delete (1, 0);
d766 1
a766 1
  char c = 0;
d772 1
d794 1
d796 3
a798 1
	  rl_delete (1, c);
d816 3
a818 1
  rl_yank (1, key);
d866 2
d869 1
d942 35
d983 1
a983 1
  int key, c;
a984 1
  RL_SETSTATE(RL_STATE_NUMERICARG);
d987 2
a988 12
      if (rl_numeric_arg > 1000000)
	{
	  rl_explicit_arg = rl_numeric_arg = 0;
	  rl_ding ();
	  rl_clear_message ();
	  RL_UNSETSTATE(RL_STATE_NUMERICARG);
	  return 1;
	}
      rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg);
      RL_SETSTATE(RL_STATE_MOREINPUT);
      key = c = rl_read_key ();
      RL_UNSETSTATE(RL_STATE_MOREINPUT);
d990 1
a990 6
      if (c >= 0 && _rl_keymap[c].type == ISFUNC &&
	  _rl_keymap[c].function == rl_universal_argument)
	{
	  rl_numeric_arg *= 4;
	  continue;
	}
d992 3
a994 15
      c = UNMETA (c);
      if (_rl_digit_p (c))
	{
	  if (rl_explicit_arg)
	    rl_numeric_arg = (rl_numeric_arg * 10) + _rl_digit_value (c);
	  else
	    rl_numeric_arg = _rl_digit_value (c);
	  rl_explicit_arg = 1;
	}
      else
	{
	  rl_clear_message ();
	  rl_stuff_char (key);
	  break;
	}
d1074 1
a1074 2
      _rl_vi_set_last (key, count, rl_arg_sign);
      rl_vi_insertion_mode (1, key);
d1084 1
a1084 1
  int c, save = rl_point;
d1086 1
d1111 31
d1147 3
d1168 1
d1189 26
d1221 1
a1221 1
  static int mb_len;
a1224 1
  static int orig_dir, dir;
d1227 1
a1227 1
    dir = key == ';' ? orig_dir : -orig_dir;
a1229 18
      if (vi_redoing)
#if defined (HANDLE_MULTIBYTE)
	target = _rl_vi_last_search_mbchar;
#else
	target = _rl_vi_last_search_char;
#endif
      else
	{
#if defined (HANDLE_MULTIBYTE)
	  mb_len = _rl_read_mbchar (_rl_vi_last_search_mbchar, MB_LEN_MAX);
	  target = _rl_vi_last_search_mbchar;
#else
	  RL_SETSTATE(RL_STATE_MOREINPUT);
	  _rl_vi_last_search_char = target = rl_read_key ();
	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
#endif
	}

d1233 1
a1233 1
          orig_dir = dir = FTO;
d1237 1
a1237 1
          orig_dir = dir = BTO;
d1241 1
a1241 1
          orig_dir = dir = FFIND;
d1245 1
a1245 1
          orig_dir = dir = BFIND;
d1248 24
d1275 8
a1282 1
   return (_rl_char_search_internal (count, dir, target, mb_len));
d1284 1
a1284 1
  return (_rl_char_search_internal (count, dir, target));
d1395 4
a1398 8
/* XXX - think about reading an entire mbchar with _rl_read_mbchar and
   inserting it in one bunch instead of the loop below (like in
   rl_vi_char_search or _rl_vi_change_mbchar_case.  Set c to mbchar[0]
   for test against 033 or ^C.  Make sure that _rl_read_mbchar does
   this right. */
int
rl_vi_change_char (count, key)
     int count, key;
d1400 1
a1400 10
  int c;

  if (vi_redoing)
    c = _rl_vi_last_replacement;
  else
    {
      RL_SETSTATE(RL_STATE_MOREINPUT);
      _rl_vi_last_replacement = c = rl_read_key ();
      RL_UNSETSTATE(RL_STATE_MOREINPUT);
    }
d1405 1
d1408 4
a1411 3
      rl_begin_undo_group ();

      rl_delete (1, c);
d1414 1
a1414 6
	while (_rl_insert_char (1, c))
	  {
	    RL_SETSTATE (RL_STATE_MOREINPUT);
	    c = rl_read_key ();
	    RL_UNSETSTATE (RL_STATE_MOREINPUT);
	  }
d1418 41
a1458 2
      if (count == 0)
	rl_backward_char (1, c);
d1460 23
a1482 1
      rl_end_undo_group ();
d1484 5
a1488 1
  return (0);
d1497 1
a1497 1
    rl_stuff_char ((key == 'S') ? 'c' : ' ');	/* `S' == `cc', `s' == `c ' */
d1613 2
a1614 3
int
rl_vi_set_mark (count, key)
     int count, key;
d1632 12
d1645 1
a1645 1
rl_vi_goto_mark (count, key)
d1648 15
d1690 27
@


1.6.2.1
log
@Import readline 5.1 on the branch.
@
text
@d4 1
a4 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
a65 2
int _rl_vi_last_command = 'i';	/* default `.' puts you in insert mode */

d86 1
a91 1
static int _rl_vi_last_search_mblen;
a108 2

static int _rl_vi_arg_dispatch PARAMS((int));
a110 12
static int _rl_vi_set_mark PARAMS((void));
static int _rl_vi_goto_mark PARAMS((void));

static int _rl_vi_callback_getchar PARAMS((char *, int));

#if defined (READLINE_CALLBACKS)
static int _rl_vi_callback_set_mark PARAMS((_rl_callback_generic_arg *));
static int _rl_vi_callback_goto_mark PARAMS((_rl_callback_generic_arg *));
static int _rl_vi_callback_change_char PARAMS((_rl_callback_generic_arg *));
static int _rl_vi_callback_char_search PARAMS((_rl_callback_generic_arg *));
#endif

a117 2

  RL_UNSETSTATE(RL_STATE_VICMDONCE);
a137 10
/* A convenience function that calls _rl_vi_set_last to save the last command
   information and enters insertion mode. */
void
rl_vi_start_inserting (key, repeat, sign)
     int key, repeat, sign;
{
  _rl_vi_set_last (key, repeat, sign);
  rl_vi_insertion_mode (1, key);
}

a263 1
      _rl_free_saved_history_line ();
a267 1
      _rl_free_saved_history_line ();
d300 4
a303 2
    rl_vi_start_inserting (key, 1, rl_arg_sign);

d313 2
a314 1
  rl_vi_start_inserting (key, 1, rl_arg_sign);
d432 1
a432 2
      while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))
	rl_point++;
d643 1
a643 1
      if ((_rl_vi_last_key_before_insert == 'i' || _rl_vi_last_key_before_insert == 'a') && rl_undo_list)
a662 7

  /* This is how POSIX.2 says `U' should behave -- everything up until the
     first time you go into command mode should not be undone. */
  if (RL_ISSTATE (RL_STATE_VICMDONCE) == 0)
    rl_free_undo_list ();

  RL_SETSTATE (RL_STATE_VICMDONCE);
d684 1
a684 1
  int mblen, p;
d707 1
a707 2
	  p = rl_point;
	  mblen = wcrtomb (mb, wc, &ps);
d711 1
a711 3
	  rl_vi_delete (1, 0);
	  if (rl_point < p)	/* Did we retreat at EOL? */
	    rl_point++;	/* XXX - should we advance more than 1 for mbchar? */
d728 1
a728 1
  int c, p;
a733 1
  c = 0;
a754 1
	  p = rl_point;
d756 1
a756 3
	  rl_vi_delete (1, c);
	  if (rl_point < p)	/* Did we retreat at EOL? */
	    rl_point++;
d774 1
a774 3
  while (count--)
    rl_yank (1, key);

a821 2
	  rl_explicit_arg = 1;
	  RL_SETSTATE (RL_STATE_NUMERICARG|RL_STATE_VIMOTION);
a822 1
	  RL_UNSETSTATE (RL_STATE_VIMOTION);
a894 35
/* Process C as part of the current numeric argument.  Return -1 if the
   argument should be aborted, 0 if we should not read any more chars, and
   1 if we should continue to read chars. */
static int
_rl_vi_arg_dispatch (c)
     int c;
{
  int key;

  key = c;
  if (c >= 0 && _rl_keymap[c].type == ISFUNC && _rl_keymap[c].function == rl_universal_argument)
    {
      rl_numeric_arg *= 4;
      return 1;
    }

  c = UNMETA (c);

  if (_rl_digit_p (c))
    {
      if (rl_explicit_arg)
	rl_numeric_arg = (rl_numeric_arg * 10) + _rl_digit_value (c);
      else
	rl_numeric_arg = _rl_digit_value (c);
      rl_explicit_arg = 1;
      return 1;
    }
  else
    {
      rl_clear_message ();
      rl_stuff_char (key);
      return 0;
    }
}

d901 1
a901 1
  int c, r;
d903 1
d906 12
a917 2
      if (_rl_arg_overflow ())
	return 1;
d919 6
a924 1
      c = _rl_arg_getchar ();
d926 15
a940 3
      r = _rl_vi_arg_dispatch (c);
      if (r <= 0)
	break;
d1020 2
a1021 1
      rl_vi_start_inserting (key, rl_numeric_arg, rl_arg_sign);
d1031 1
a1031 1
  int c, save;
a1032 1
  save = rl_point;
a1056 31
rl_vi_rubout (count, key)
     int count, key;
{
  int p, opoint;

  if (count < 0)
    return (rl_vi_delete (-count, key));

  if (rl_point == 0)
    {
      rl_ding ();
      return -1;
    }

  opoint = rl_point;
  if (count > 1 && MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    rl_backward_char (count, key);
  else if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);
  else
    rl_point -= count;

  if (rl_point < 0)
    rl_point = 0;

  rl_kill_text (rl_point, opoint);
  
  return (0);
}

int
a1061 3
  if (count < 0)
    return (rl_vi_rubout (-count, key));

a1079 1

a1099 26
static int _rl_cs_dir, _rl_cs_orig_dir;

#if defined (READLINE_CALLBACKS)
static int
_rl_vi_callback_char_search (data)
     _rl_callback_generic_arg *data;
{
#if defined (HANDLE_MULTIBYTE)
  _rl_vi_last_search_mblen = _rl_read_mbchar (_rl_vi_last_search_mbchar, MB_LEN_MAX);
#else
  RL_SETSTATE(RL_STATE_MOREINPUT);
  _rl_vi_last_search_char = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);
#endif

  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

#if defined (HANDLE_MULTIBYTE)
  return (_rl_char_search_internal (data->count, _rl_cs_dir, _rl_vi_last_search_mbchar, _rl_vi_last_search_mblen));
#else
  return (_rl_char_search_internal (data->count, _rl_cs_dir, _rl_vi_last_search_char));
#endif  
}
#endif

d1106 1
a1106 1
  static int tlen;
d1110 1
d1113 1
a1113 1
    _rl_cs_dir = (key == ';') ? _rl_cs_orig_dir : -_rl_cs_orig_dir;
d1116 18
d1137 1
a1137 1
          _rl_cs_orig_dir = _rl_cs_dir = FTO;
d1141 1
a1141 1
          _rl_cs_orig_dir = _rl_cs_dir = BTO;
d1145 1
a1145 1
          _rl_cs_orig_dir = _rl_cs_dir = FFIND;
d1149 1
a1149 1
          _rl_cs_orig_dir = _rl_cs_dir = BFIND;
a1151 24

      if (vi_redoing)
	{
	  /* set target and tlen below */
	}
#if defined (READLINE_CALLBACKS)
      else if (RL_ISSTATE (RL_STATE_CALLBACK))
        {
          _rl_callback_data = _rl_callback_data_alloc (count);
          _rl_callback_data->i1 = _rl_cs_dir;
          _rl_callback_func = _rl_vi_callback_char_search;
          return (0);
        }
#endif
      else
	{
#if defined (HANDLE_MULTIBYTE)
	  _rl_vi_last_search_mblen = _rl_read_mbchar (_rl_vi_last_search_mbchar, MB_LEN_MAX);
#else
	  RL_SETSTATE(RL_STATE_MOREINPUT);
	  _rl_vi_last_search_char = rl_read_key ();
	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
#endif
	}
d1155 1
a1155 8
  target = _rl_vi_last_search_mbchar;
  tlen = _rl_vi_last_search_mblen;
#else
  target = _rl_vi_last_search_char;
#endif

#if defined (HANDLE_MULTIBYTE)
  return (_rl_char_search_internal (count, _rl_cs_dir, target, tlen));
d1157 1
a1157 1
  return (_rl_char_search_internal (count, _rl_cs_dir, target));
d1268 8
a1275 4
static int
_rl_vi_change_char (count, c, mb)
     int count, c;
     char *mb;
d1277 10
a1286 1
  int p;
a1290 1
  rl_begin_undo_group ();
d1293 3
a1295 4
      p = rl_point;
      rl_vi_delete (1, c);
      if (rl_point < p)		/* Did we retreat at EOL? */
	rl_point++;
d1298 6
a1303 1
	rl_insert_text (mb);
d1307 4
a1311 6

  /* The cursor shall be left on the last character changed. */
  rl_backward_char (1, c);

  rl_end_undo_group ();

a1314 63
static int
_rl_vi_callback_getchar (mb, mblen)
     char *mb;
     int mblen;
{
  int c;

  RL_SETSTATE(RL_STATE_MOREINPUT);
  c = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    c = _rl_read_mbstring (c, mb, mblen);
#endif

  return c;
}

#if defined (READLINE_CALLBACKS)
static int
_rl_vi_callback_change_char (data)
     _rl_callback_generic_arg *data;
{
  int c;
  char mb[MB_LEN_MAX];

  _rl_vi_last_replacement = c = _rl_vi_callback_getchar (mb, MB_LEN_MAX);

  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

  return (_rl_vi_change_char (data->count, c, mb));
}
#endif

int
rl_vi_change_char (count, key)
     int count, key;
{
  int c;
  char mb[MB_LEN_MAX];

  if (vi_redoing)
    {
      c = _rl_vi_last_replacement;
      mb[0] = c;
      mb[1] = '\0';
    }
#if defined (READLINE_CALLBACKS)
  else if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = _rl_callback_data_alloc (count);
      _rl_callback_func = _rl_vi_callback_change_char;
      return (0);
    }
#endif
  else
    _rl_vi_last_replacement = c = _rl_vi_callback_getchar (mb, MB_LEN_MAX);

  return (_rl_vi_change_char (count, c, mb));
}

d1321 1
a1321 1
    rl_stuff_char ((key == 'S') ? 'c' : 'l');	/* `S' == `cc', `s' == `cl' */
d1437 3
a1439 2
static int
_rl_vi_set_mark ()
a1456 12
#if defined (READLINE_CALLBACKS)
static int
_rl_vi_callback_set_mark (data)
     _rl_callback_generic_arg *data;
{
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

  return (_rl_vi_set_mark ());
}
#endif

d1458 1
a1458 1
rl_vi_set_mark (count, key)
a1460 15
#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = 0;
      _rl_callback_func = _rl_vi_callback_set_mark;
      return (0);
    }
#endif

  return (_rl_vi_set_mark ());
}

static int
_rl_vi_goto_mark ()
{
a1487 27
#if defined (READLINE_CALLBACKS)
static int
_rl_vi_callback_goto_mark (data)
     _rl_callback_generic_arg *data;
{
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

  return (_rl_vi_goto_mark ());
}
#endif

int
rl_vi_goto_mark (count, key)
     int count, key;
{
#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = 0;
      _rl_callback_func = _rl_vi_callback_goto_mark;
      return (0);
    }
#endif

  return (_rl_vi_goto_mark ());
}
@


1.5
log
@2004-01-27  Elena Zannoni  <ezannoni@@redhat.com>

        Merge in official patches to readline-4.3 from
	ftp://ftp.cwru.edu/pub/bash/readline-4.3-patches:
	NOTE: Patch-ID readline-43-004 was already applied (see below).

	* bind.c (rl_generic_bind): Pressing certain key sequences
	causes an infinite loop in _rl_dispatch_subseq with the `key' argument
	set to 256.  This eventually causes bash to exceed the stack size
	limit and crash with a segmentation violation.
	Patch-ID: readline43-001.

	* readline.c (_rl_dispatch_subseq): Repeating an edit in
	vi-mode with `.' does not work.
	Patch-ID: readline43-002.

	* mbutil.c (_rl_get_char_len, _rl_compare_chars,
	_rl_adjust_point): When in a locale with multibyte characters, the
	readline display updater will occasionally cause a
	segmentation fault when attempting to compute the length of the first
	multibyte character on the line.
	Patch-ID: readline43-003.

	* vi_mode.c (_rl_vi_change_mbchar_case): Using the vi editing
	mode's case-changing commands in a locale with multibyte characters
	will cause garbage characters to be inserted into the editing buffer.
	Patch-ID: readline43-005.
@
text
@@


1.4
log
@Import of readline 4.3.
Non-readline modified files:

src/gdb/ChangeLog src/gdb/defs.h src/gdb/cli/cli-cmds.c
src/gdb/cli/cli-setshow.c src/gdb/tui/ChangeLog
src/gdb/tui/tuiWin.c

In readline directory:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@d683 2
a684 1
  char mb[MB_LEN_MAX];
d707 3
a709 1
	  wctomb (mb, wc);
@


1.3
log
@readline:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Locally modified files: Makefile.in, configure.in, configure
        (regenerated), config.h.in (regenerated), readline.h, rltty.c,
 	shell.c signals.c.

        Locally added files: acconfig.h, config/*, config.h.bot,
        cross-build/*, doc/inc-hit.texinfo.

        New files: USAGE, rlprivate.h, rlshell.h, xmalloc.h.
examples:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        New files: excallback.c, rlfe.c.
doc:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Regenerated inc-hist.texinfo as copy of hsuser.texinfo, for
        inclusion in the gdb manual.

        New file: rluserman.texinfo
@
text
@d54 2
a61 8
#ifndef _rl_digit_p
#define _rl_digit_p(c)  ((c) >= '0' && (c) <= '9')
#endif

#ifndef _rl_digit_value
#define _rl_digit_value(c) ((c) - '0')
#endif

a65 8
#ifndef isident
#define isident(c) ((_rl_pure_alphabetic (c) || _rl_digit_p (c) || c == '_'))
#endif

#ifndef exchange
#define exchange(x, y) do {int temp = x; x = y; y = temp;} while (0)
#endif

d70 1
a70 1
static char *vi_motion = " hl^$0ftFt;,%wbeWBE|";
d90 3
d94 1
d102 1
a102 1
static char *vi_textmod = "_*\\AaIiCcDdPpYyRrSsXx~";
d105 1
a105 1
static int vi_mark_chars[27];
d107 3
a109 1
static int rl_digit_loop1 __P((void));
d163 2
d171 1
d183 1
a183 1
    _rl_dispatch (_rl_vi_last_command, _rl_keymap);
d186 1
a186 1
  return (0);
d272 1
a272 1
      ding ();
d328 1
a328 1
      ding ();
d350 1
a350 1
      ding ();
d368 1
a368 1
      ding ();
d458 1
a458 1
      if (isident (rl_line_buffer[rl_point]))
d460 1
a460 1
	  while (isident (rl_line_buffer[rl_point]) && rl_point < rl_end)
d465 1
a465 1
	  while (!isident (rl_line_buffer[rl_point]) &&
d495 3
a497 3
      last_is_ident = isident (rl_line_buffer[rl_point - 1]);
      if ((isident (rl_line_buffer[rl_point]) && !last_is_ident) ||
	  (!isident (rl_line_buffer[rl_point]) && last_is_ident))
d505 2
a506 2
	  if (isident (rl_line_buffer[rl_point]))
	    while (--rl_point >= 0 && isident (rl_line_buffer[rl_point]));
d508 1
a508 1
	    while (--rl_point >= 0 && !isident (rl_line_buffer[rl_point]) &&
d530 2
a531 2
	  if (isident (rl_line_buffer[rl_point]))
	    while (++rl_point < rl_end && isident (rl_line_buffer[rl_point]));
d533 1
a533 1
	    while (++rl_point < rl_end && !isident (rl_line_buffer[rl_point])
d555 11
a565 1
    rl_point++;
d619 1
a619 1
      vi_insert_buffer = xrealloc (vi_insert_buffer, vi_insert_buffer_size);
d630 1
d659 1
a659 1
    rl_backward (1, key);
d676 45
d731 5
d745 1
a745 1
	  rl_forward (1, c);
d754 1
a754 1
	  rl_insert (1, c);
d759 1
a759 1
	rl_forward (1, c);
d769 1
a769 1
    rl_point++;
d772 1
a772 1
  rl_backward (1, key);
d780 6
a785 1
    rl_point--;
d808 1
d810 1
d821 1
d823 1
d887 1
a887 1
    exchange (rl_point, rl_mark);
d893 2
a894 1
   Don't recognize minus sign? */
d900 1
d903 10
a912 1
      rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg, 0);
d914 1
d916 1
a916 1
      if (_rl_keymap[c].type == ISFUNC &&
d939 2
d957 1
a957 1
      ding ();
d985 1
a985 1
      ding ();
d1035 1
a1035 1
      ding ();
d1061 1
a1061 1
      ding ();
d1065 4
a1068 1
  end = rl_point + count;
d1076 1
a1076 1
    rl_backward (1, key);
d1101 4
d1106 1
d1114 3
d1118 1
d1120 10
a1129 1
	_rl_vi_last_search_char = target = (*rl_getc_function) (rl_instream);
d1151 3
d1155 1
d1163 1
a1163 1
  int count = 1, brack, pos;
d1168 14
a1181 3
      while ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0 &&
	     rl_point < rl_end - 1)
	rl_forward (1, key);
d1186 1
a1186 1
	  ding ();
d1197 10
a1206 1
	  if (--pos >= 0)
d1216 1
a1216 1
	      ding ();
d1225 6
a1230 1
	  if (++pos < rl_end)
d1240 1
a1240 1
	      ding ();
d1265 5
d1279 5
a1283 1
    _rl_vi_last_replacement = c = (*rl_getc_function) (rl_instream);
d1293 11
a1303 1
      rl_insert (1, c);
d1305 1
a1305 1
	rl_backward (1, c);
d1316 3
a1318 13
  rl_begin_undo_group ();

  if (_rl_uppercase_p (key))
    {
      rl_beg_of_line (1, key);
      rl_kill_line (1, key);
    }
  else
    rl_delete_text (rl_point, rl_point+count);

  rl_end_undo_group ();

  _rl_vi_set_last (key, count, rl_arg_sign);
d1320 1
a1320 17
  if (vi_redoing)
    {
      int o = _rl_doing_an_undo;

      _rl_doing_an_undo = 1;
      if (vi_insert_buffer && *vi_insert_buffer)
	rl_insert_text (vi_insert_buffer);
      _rl_doing_an_undo = o;
    }
  else
    {
      rl_begin_undo_group ();
      _rl_vi_doing_insert = 1;
      rl_vi_insertion_mode (1, key);
    }

  return (0);
a1326 2
  int i;

d1333 1
a1333 1
  for (i = 0; i < count; i++)
d1335 3
a1337 2
      vi_replace_count++;
      rl_begin_undo_group ();
a1338 10
      if (rl_point < rl_end)
	{
	  rl_delete (1, key);
	  rl_insert (1, key);
	}
      else
	rl_insert (1, key);

      rl_end_undo_group ();
    }
d1352 1
a1352 1
	  ding ();
d1361 1
a1361 1
	rl_backward (1, key);
d1422 1
a1422 1
      ding ();
d1440 1
d1442 3
a1444 1
  if (_rl_lowercase_p (ch) == 0)
d1446 1
a1446 1
      ding ();
d1460 1
d1462 2
d1469 1
a1469 1
  else if (_rl_lowercase_p (ch) == 0)
d1471 1
a1471 1
      ding ();
d1478 1
a1478 1
      ding ();
@


1.3.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a53 2
#include "rlmbutil.h"

d60 8
d72 8
d84 1
a84 1
static const char *vi_motion = " hl^$0ftFT;,%wbeWBE|";
a103 3
#if defined (HANDLE_MULTIBYTE)
static char _rl_vi_last_search_mbchar[MB_LEN_MAX];
#else
a104 1
#endif
d112 1
a112 1
static const char *vi_textmod = "_*\\AaIiCcDdPpYyRrSsXx~";
d115 1
a115 1
static int vi_mark_chars['z' - 'a' + 1];
d117 1
a117 3
static void _rl_vi_stuff_insert PARAMS((int));
static void _rl_vi_save_insert PARAMS((UNDO_LIST *));
static int rl_digit_loop1 PARAMS((void));
a170 2
  int r;

a176 1
  r = 0;
d188 1
a188 1
    r = _rl_dispatch (_rl_vi_last_command, _rl_keymap);
d191 1
a191 1
  return (r);
d277 1
a277 1
      rl_ding ();
d333 1
a333 1
      rl_ding ();
d355 1
a355 1
      rl_ding ();
d373 1
a373 1
      rl_ding ();
d463 1
a463 1
      if (_rl_isident (rl_line_buffer[rl_point]))
d465 1
a465 1
	  while (_rl_isident (rl_line_buffer[rl_point]) && rl_point < rl_end)
d470 1
a470 1
	  while (!_rl_isident (rl_line_buffer[rl_point]) &&
d500 3
a502 3
      last_is_ident = _rl_isident (rl_line_buffer[rl_point - 1]);
      if ((_rl_isident (rl_line_buffer[rl_point]) && !last_is_ident) ||
	  (!_rl_isident (rl_line_buffer[rl_point]) && last_is_ident))
d510 2
a511 2
	  if (_rl_isident (rl_line_buffer[rl_point]))
	    while (--rl_point >= 0 && _rl_isident (rl_line_buffer[rl_point]));
d513 1
a513 1
	    while (--rl_point >= 0 && !_rl_isident (rl_line_buffer[rl_point]) &&
d535 2
a536 2
	  if (_rl_isident (rl_line_buffer[rl_point]))
	    while (++rl_point < rl_end && _rl_isident (rl_line_buffer[rl_point]));
d538 1
a538 1
	    while (++rl_point < rl_end && !_rl_isident (rl_line_buffer[rl_point])
d560 1
a560 11
    {
      if (MB_CUR_MAX == 1 || rl_byte_oriented)
	rl_point++;
      else
        {
          int point = rl_point;
          rl_forward_char (1, key);
          if (point == rl_point)
            rl_point = rl_end;
        }
    }
d614 1
a614 1
      vi_insert_buffer = (char *)xrealloc (vi_insert_buffer, vi_insert_buffer_size);
a624 1
      /* The `C', `s', and `S' commands set this. */
d653 1
a653 1
    rl_backward_char (1, key);
a669 45
/* Change the case of the next COUNT characters. */
#if defined (HANDLE_MULTIBYTE)
static int
_rl_vi_change_mbchar_case (count)
     int count;
{
  wchar_t wc;
  char mb[MB_LEN_MAX];
  mbstate_t ps;

  memset (&ps, 0, sizeof (mbstate_t));
  if (_rl_adjust_point (rl_line_buffer, rl_point, &ps) > 0)
    count--;
  while (count-- && rl_point < rl_end)
    {
      mbrtowc (&wc, rl_line_buffer + rl_point, rl_end - rl_point, &ps);
      if (iswupper (wc))
	wc = towlower (wc);
      else if (iswlower (wc))
	wc = towupper (wc);
      else
	{
	  /* Just skip over chars neither upper nor lower case */
	  rl_forward_char (1, 0);
	  continue;
	}

      /* Vi is kind of strange here. */
      if (wc)
	{
	  wctomb (mb, wc);
	  rl_begin_undo_group ();
	  rl_delete (1, 0);
	  rl_insert_text (mb);
	  rl_end_undo_group ();
	  rl_vi_check ();
	}
      else
        rl_forward_char (1, 0);
    }

  return 0;
}
#endif

a679 5
#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    return (_rl_vi_change_mbchar_case (count));
#endif

d689 1
a689 1
	  rl_forward_char (1, c);
d698 1
a698 1
	  _rl_insert_char (1, c);
d703 1
a703 1
	rl_forward_char (1, c);
d713 1
a713 1
    rl_point = _rl_find_next_mbchar (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
d716 1
a716 1
  rl_backward_char (1, key);
d724 1
a724 6
    {
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);
      else
        rl_point--;
    }
a746 1
  RL_SETSTATE(RL_STATE_MOREINPUT);
a747 1
  RL_UNSETSTATE(RL_STATE_MOREINPUT);
a757 1
	  RL_SETSTATE(RL_STATE_MOREINPUT);
a758 1
	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
d822 1
a822 1
    SWAP (rl_point, rl_mark);
d828 1
a828 2
   Don't recognize minus sign?
   Should this do rl_save_prompt/rl_restore_prompt? */
a833 1
  RL_SETSTATE(RL_STATE_NUMERICARG);
d836 1
a836 10
      if (rl_numeric_arg > 1000000)
	{
	  rl_explicit_arg = rl_numeric_arg = 0;
	  rl_ding ();
	  rl_clear_message ();
	  RL_UNSETSTATE(RL_STATE_NUMERICARG);
	  return 1;
	}
      rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg);
      RL_SETSTATE(RL_STATE_MOREINPUT);
a837 1
      RL_UNSETSTATE(RL_STATE_MOREINPUT);
d839 1
a839 1
      if (c >= 0 && _rl_keymap[c].type == ISFUNC &&
a861 2

  RL_UNSETSTATE(RL_STATE_NUMERICARG);
d878 1
a878 1
      rl_ding ();
d906 1
a906 1
      rl_ding ();
d956 1
a956 1
      rl_ding ();
d982 1
a982 1
      rl_ding ();
d986 1
a986 4
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    end = _rl_find_next_mbchar (rl_line_buffer, rl_point, count, MB_FIND_NONZERO);
  else
    end = rl_point + count;
d994 1
a994 1
    rl_backward_char (1, key);
a1018 4
#if defined (HANDLE_MULTIBYTE)
  static char *target;
  static int mb_len;
#else
a1019 1
#endif
a1026 3
#if defined (HANDLE_MULTIBYTE)
	target = _rl_vi_last_search_mbchar;
#else
a1027 1
#endif
d1029 1
a1029 10
	{
#if defined (HANDLE_MULTIBYTE)
	  mb_len = _rl_read_mbchar (_rl_vi_last_search_mbchar, MB_LEN_MAX);
	  target = _rl_vi_last_search_mbchar;
#else
	  RL_SETSTATE(RL_STATE_MOREINPUT);
	  _rl_vi_last_search_char = target = rl_read_key ();
	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
#endif
	}
a1050 3
#if defined (HANDLE_MULTIBYTE)
   return (_rl_char_search_internal (count, dir, target, mb_len));
#else
a1051 1
#endif
d1059 1
a1059 1
  int count = 1, brack, pos, tmp, pre;
d1064 3
a1066 14
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  while ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0)
	    {
	      pre = rl_point;
	      rl_forward_char (1, key);
	      if (pre == rl_point)
	        break;
	    }
	}
      else
	while ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0 &&
		rl_point < rl_end - 1)
	  rl_forward_char (1, key);
d1071 1
a1071 1
	  rl_ding ();
d1082 1
a1082 10
	  tmp = pos;
	  if (MB_CUR_MAX == 1 || rl_byte_oriented)
	    pos--;
	  else
	    {
	      pos = _rl_find_prev_mbchar (rl_line_buffer, pos, MB_FIND_ANY);
	      if (tmp == pos)
	        pos--;
	    }
	  if (pos >= 0)
d1092 1
a1092 1
	      rl_ding ();
d1101 1
a1101 6
	  if (MB_CUR_MAX == 1 || rl_byte_oriented)
	    pos++;
	  else
	    pos = _rl_find_next_mbchar (rl_line_buffer, pos, 1, MB_FIND_ANY);

	  if (pos < rl_end)
d1111 1
a1111 1
	      rl_ding ();
a1135 5
/* XXX - think about reading an entire mbchar with _rl_read_mbchar and
   inserting it in one bunch instead of the loop below (like in
   rl_vi_char_search or _rl_vi_change_mbchar_case.  Set c to mbchar[0]
   for test against 033 or ^C.  Make sure that _rl_read_mbchar does
   this right. */
d1145 1
a1145 5
    {
      RL_SETSTATE(RL_STATE_MOREINPUT);
      _rl_vi_last_replacement = c = rl_read_key ();
      RL_UNSETSTATE(RL_STATE_MOREINPUT);
    }
d1155 1
a1155 11
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	while (_rl_insert_char (1, c))
	  {
	    RL_SETSTATE (RL_STATE_MOREINPUT);
	    c = rl_read_key ();
	    RL_UNSETSTATE (RL_STATE_MOREINPUT);
	  }
      else
#endif
	_rl_insert_char (1, c);
d1157 1
a1157 1
	rl_backward_char (1, c);
d1168 13
a1180 3
  /* If we are redoing, rl_vi_change_to will stuff the last motion char */
  if (vi_redoing == 0)
    rl_stuff_char ((key == 'S') ? 'c' : ' ');	/* `S' == `cc', `s' == `c ' */
d1182 17
a1198 1
  return (rl_vi_change_to (count, 'c'));
d1205 2
d1213 1
a1213 1
  if (count > 0)
d1215 12
a1226 2
      _rl_overwrite_char (count, key);
      vi_replace_count += count;
a1227 1

d1241 1
a1241 1
	  rl_ding ();
d1250 1
a1250 1
	rl_backward_char (1, key);
d1311 1
a1311 1
      rl_ding ();
a1328 1
  RL_SETSTATE(RL_STATE_MOREINPUT);
d1330 1
a1330 3
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

  if (ch < 'a' || ch > 'z')
d1332 1
a1332 1
      rl_ding ();
a1345 1
  RL_SETSTATE(RL_STATE_MOREINPUT);
a1346 2
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

d1352 1
a1352 1
  else if (ch < 'a' || ch > 'z')
d1354 1
a1354 1
      rl_ding ();
d1361 1
a1361 1
      rl_ding ();
@


1.3.24.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d683 1
a683 2
  char mb[MB_LEN_MAX+1];
  int mblen;
d706 1
a706 3
	  mblen = wctomb (mb, wc);
	  if (mblen >= 0)
	    mb[mblen] = '\0';
@


1.3.22.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a53 2
#include "rlmbutil.h"

d60 8
d72 8
d84 1
a84 1
static const char *vi_motion = " hl^$0ftFT;,%wbeWBE|";
a103 3
#if defined (HANDLE_MULTIBYTE)
static char _rl_vi_last_search_mbchar[MB_LEN_MAX];
#else
a104 1
#endif
d112 1
a112 1
static const char *vi_textmod = "_*\\AaIiCcDdPpYyRrSsXx~";
d115 1
a115 1
static int vi_mark_chars['z' - 'a' + 1];
d117 1
a117 3
static void _rl_vi_stuff_insert PARAMS((int));
static void _rl_vi_save_insert PARAMS((UNDO_LIST *));
static int rl_digit_loop1 PARAMS((void));
a170 2
  int r;

a176 1
  r = 0;
d188 1
a188 1
    r = _rl_dispatch (_rl_vi_last_command, _rl_keymap);
d191 1
a191 1
  return (r);
d277 1
a277 1
      rl_ding ();
d333 1
a333 1
      rl_ding ();
d355 1
a355 1
      rl_ding ();
d373 1
a373 1
      rl_ding ();
d463 1
a463 1
      if (_rl_isident (rl_line_buffer[rl_point]))
d465 1
a465 1
	  while (_rl_isident (rl_line_buffer[rl_point]) && rl_point < rl_end)
d470 1
a470 1
	  while (!_rl_isident (rl_line_buffer[rl_point]) &&
d500 3
a502 3
      last_is_ident = _rl_isident (rl_line_buffer[rl_point - 1]);
      if ((_rl_isident (rl_line_buffer[rl_point]) && !last_is_ident) ||
	  (!_rl_isident (rl_line_buffer[rl_point]) && last_is_ident))
d510 2
a511 2
	  if (_rl_isident (rl_line_buffer[rl_point]))
	    while (--rl_point >= 0 && _rl_isident (rl_line_buffer[rl_point]));
d513 1
a513 1
	    while (--rl_point >= 0 && !_rl_isident (rl_line_buffer[rl_point]) &&
d535 2
a536 2
	  if (_rl_isident (rl_line_buffer[rl_point]))
	    while (++rl_point < rl_end && _rl_isident (rl_line_buffer[rl_point]));
d538 1
a538 1
	    while (++rl_point < rl_end && !_rl_isident (rl_line_buffer[rl_point])
d560 1
a560 11
    {
      if (MB_CUR_MAX == 1 || rl_byte_oriented)
	rl_point++;
      else
        {
          int point = rl_point;
          rl_forward_char (1, key);
          if (point == rl_point)
            rl_point = rl_end;
        }
    }
d614 1
a614 1
      vi_insert_buffer = (char *)xrealloc (vi_insert_buffer, vi_insert_buffer_size);
a624 1
      /* The `C', `s', and `S' commands set this. */
d653 1
a653 1
    rl_backward_char (1, key);
a669 45
/* Change the case of the next COUNT characters. */
#if defined (HANDLE_MULTIBYTE)
static int
_rl_vi_change_mbchar_case (count)
     int count;
{
  wchar_t wc;
  char mb[MB_LEN_MAX];
  mbstate_t ps;

  memset (&ps, 0, sizeof (mbstate_t));
  if (_rl_adjust_point (rl_line_buffer, rl_point, &ps) > 0)
    count--;
  while (count-- && rl_point < rl_end)
    {
      mbrtowc (&wc, rl_line_buffer + rl_point, rl_end - rl_point, &ps);
      if (iswupper (wc))
	wc = towlower (wc);
      else if (iswlower (wc))
	wc = towupper (wc);
      else
	{
	  /* Just skip over chars neither upper nor lower case */
	  rl_forward_char (1, 0);
	  continue;
	}

      /* Vi is kind of strange here. */
      if (wc)
	{
	  wctomb (mb, wc);
	  rl_begin_undo_group ();
	  rl_delete (1, 0);
	  rl_insert_text (mb);
	  rl_end_undo_group ();
	  rl_vi_check ();
	}
      else
        rl_forward_char (1, 0);
    }

  return 0;
}
#endif

a679 5
#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    return (_rl_vi_change_mbchar_case (count));
#endif

d689 1
a689 1
	  rl_forward_char (1, c);
d698 1
a698 1
	  _rl_insert_char (1, c);
d703 1
a703 1
	rl_forward_char (1, c);
d713 1
a713 1
    rl_point = _rl_find_next_mbchar (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
d716 1
a716 1
  rl_backward_char (1, key);
d724 1
a724 6
    {
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);
      else
        rl_point--;
    }
a746 1
  RL_SETSTATE(RL_STATE_MOREINPUT);
a747 1
  RL_UNSETSTATE(RL_STATE_MOREINPUT);
a757 1
	  RL_SETSTATE(RL_STATE_MOREINPUT);
a758 1
	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
d822 1
a822 1
    SWAP (rl_point, rl_mark);
d828 1
a828 2
   Don't recognize minus sign?
   Should this do rl_save_prompt/rl_restore_prompt? */
a833 1
  RL_SETSTATE(RL_STATE_NUMERICARG);
d836 1
a836 10
      if (rl_numeric_arg > 1000000)
	{
	  rl_explicit_arg = rl_numeric_arg = 0;
	  rl_ding ();
	  rl_clear_message ();
	  RL_UNSETSTATE(RL_STATE_NUMERICARG);
	  return 1;
	}
      rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg);
      RL_SETSTATE(RL_STATE_MOREINPUT);
a837 1
      RL_UNSETSTATE(RL_STATE_MOREINPUT);
d839 1
a839 1
      if (c >= 0 && _rl_keymap[c].type == ISFUNC &&
a861 2

  RL_UNSETSTATE(RL_STATE_NUMERICARG);
d878 1
a878 1
      rl_ding ();
d906 1
a906 1
      rl_ding ();
d956 1
a956 1
      rl_ding ();
d982 1
a982 1
      rl_ding ();
d986 1
a986 4
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    end = _rl_find_next_mbchar (rl_line_buffer, rl_point, count, MB_FIND_NONZERO);
  else
    end = rl_point + count;
d994 1
a994 1
    rl_backward_char (1, key);
a1018 4
#if defined (HANDLE_MULTIBYTE)
  static char *target;
  static int mb_len;
#else
a1019 1
#endif
a1026 3
#if defined (HANDLE_MULTIBYTE)
	target = _rl_vi_last_search_mbchar;
#else
a1027 1
#endif
d1029 1
a1029 10
	{
#if defined (HANDLE_MULTIBYTE)
	  mb_len = _rl_read_mbchar (_rl_vi_last_search_mbchar, MB_LEN_MAX);
	  target = _rl_vi_last_search_mbchar;
#else
	  RL_SETSTATE(RL_STATE_MOREINPUT);
	  _rl_vi_last_search_char = target = rl_read_key ();
	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
#endif
	}
a1050 3
#if defined (HANDLE_MULTIBYTE)
   return (_rl_char_search_internal (count, dir, target, mb_len));
#else
a1051 1
#endif
d1059 1
a1059 1
  int count = 1, brack, pos, tmp, pre;
d1064 3
a1066 14
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  while ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0)
	    {
	      pre = rl_point;
	      rl_forward_char (1, key);
	      if (pre == rl_point)
	        break;
	    }
	}
      else
	while ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0 &&
		rl_point < rl_end - 1)
	  rl_forward_char (1, key);
d1071 1
a1071 1
	  rl_ding ();
d1082 1
a1082 10
	  tmp = pos;
	  if (MB_CUR_MAX == 1 || rl_byte_oriented)
	    pos--;
	  else
	    {
	      pos = _rl_find_prev_mbchar (rl_line_buffer, pos, MB_FIND_ANY);
	      if (tmp == pos)
	        pos--;
	    }
	  if (pos >= 0)
d1092 1
a1092 1
	      rl_ding ();
d1101 1
a1101 6
	  if (MB_CUR_MAX == 1 || rl_byte_oriented)
	    pos++;
	  else
	    pos = _rl_find_next_mbchar (rl_line_buffer, pos, 1, MB_FIND_ANY);

	  if (pos < rl_end)
d1111 1
a1111 1
	      rl_ding ();
a1135 5
/* XXX - think about reading an entire mbchar with _rl_read_mbchar and
   inserting it in one bunch instead of the loop below (like in
   rl_vi_char_search or _rl_vi_change_mbchar_case.  Set c to mbchar[0]
   for test against 033 or ^C.  Make sure that _rl_read_mbchar does
   this right. */
d1145 1
a1145 5
    {
      RL_SETSTATE(RL_STATE_MOREINPUT);
      _rl_vi_last_replacement = c = rl_read_key ();
      RL_UNSETSTATE(RL_STATE_MOREINPUT);
    }
d1155 1
a1155 11
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	while (_rl_insert_char (1, c))
	  {
	    RL_SETSTATE (RL_STATE_MOREINPUT);
	    c = rl_read_key ();
	    RL_UNSETSTATE (RL_STATE_MOREINPUT);
	  }
      else
#endif
	_rl_insert_char (1, c);
d1157 1
a1157 1
	rl_backward_char (1, c);
d1168 13
a1180 3
  /* If we are redoing, rl_vi_change_to will stuff the last motion char */
  if (vi_redoing == 0)
    rl_stuff_char ((key == 'S') ? 'c' : ' ');	/* `S' == `cc', `s' == `c ' */
d1182 17
a1198 1
  return (rl_vi_change_to (count, 'c'));
d1205 2
d1213 1
a1213 1
  if (count > 0)
d1215 12
a1226 2
      _rl_overwrite_char (count, key);
      vi_replace_count += count;
a1227 1

d1241 1
a1241 1
	  rl_ding ();
d1250 1
a1250 1
	rl_backward_char (1, key);
d1311 1
a1311 1
      rl_ding ();
a1328 1
  RL_SETSTATE(RL_STATE_MOREINPUT);
d1330 1
a1330 3
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

  if (ch < 'a' || ch > 'z')
d1332 1
a1332 1
      rl_ding ();
a1345 1
  RL_SETSTATE(RL_STATE_MOREINPUT);
a1346 2
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

d1352 1
a1352 1
  else if (ch < 'a' || ch > 'z')
d1354 1
a1354 1
      rl_ding ();
d1361 1
a1361 1
      rl_ding ();
@


1.3.16.1
log
@2002-08-24  Elena Zannoni  <ezannoni@@redhat.com>

        Import of readline 4.3:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@a53 2
#include "rlmbutil.h"

d60 8
d72 8
d84 1
a84 1
static const char *vi_motion = " hl^$0ftFT;,%wbeWBE|";
a103 3
#if defined (HANDLE_MULTIBYTE)
static char _rl_vi_last_search_mbchar[MB_LEN_MAX];
#else
a104 1
#endif
d112 1
a112 1
static const char *vi_textmod = "_*\\AaIiCcDdPpYyRrSsXx~";
d115 1
a115 1
static int vi_mark_chars['z' - 'a' + 1];
d117 1
a117 3
static void _rl_vi_stuff_insert PARAMS((int));
static void _rl_vi_save_insert PARAMS((UNDO_LIST *));
static int rl_digit_loop1 PARAMS((void));
a170 2
  int r;

a176 1
  r = 0;
d188 1
a188 1
    r = _rl_dispatch (_rl_vi_last_command, _rl_keymap);
d191 1
a191 1
  return (r);
d277 1
a277 1
      rl_ding ();
d333 1
a333 1
      rl_ding ();
d355 1
a355 1
      rl_ding ();
d373 1
a373 1
      rl_ding ();
d463 1
a463 1
      if (_rl_isident (rl_line_buffer[rl_point]))
d465 1
a465 1
	  while (_rl_isident (rl_line_buffer[rl_point]) && rl_point < rl_end)
d470 1
a470 1
	  while (!_rl_isident (rl_line_buffer[rl_point]) &&
d500 3
a502 3
      last_is_ident = _rl_isident (rl_line_buffer[rl_point - 1]);
      if ((_rl_isident (rl_line_buffer[rl_point]) && !last_is_ident) ||
	  (!_rl_isident (rl_line_buffer[rl_point]) && last_is_ident))
d510 2
a511 2
	  if (_rl_isident (rl_line_buffer[rl_point]))
	    while (--rl_point >= 0 && _rl_isident (rl_line_buffer[rl_point]));
d513 1
a513 1
	    while (--rl_point >= 0 && !_rl_isident (rl_line_buffer[rl_point]) &&
d535 2
a536 2
	  if (_rl_isident (rl_line_buffer[rl_point]))
	    while (++rl_point < rl_end && _rl_isident (rl_line_buffer[rl_point]));
d538 1
a538 1
	    while (++rl_point < rl_end && !_rl_isident (rl_line_buffer[rl_point])
d560 1
a560 11
    {
      if (MB_CUR_MAX == 1 || rl_byte_oriented)
	rl_point++;
      else
        {
          int point = rl_point;
          rl_forward_char (1, key);
          if (point == rl_point)
            rl_point = rl_end;
        }
    }
d614 1
a614 1
      vi_insert_buffer = (char *)xrealloc (vi_insert_buffer, vi_insert_buffer_size);
a624 1
      /* The `C', `s', and `S' commands set this. */
d653 1
a653 1
    rl_backward_char (1, key);
a669 45
/* Change the case of the next COUNT characters. */
#if defined (HANDLE_MULTIBYTE)
static int
_rl_vi_change_mbchar_case (count)
     int count;
{
  wchar_t wc;
  char mb[MB_LEN_MAX];
  mbstate_t ps;

  memset (&ps, 0, sizeof (mbstate_t));
  if (_rl_adjust_point (rl_line_buffer, rl_point, &ps) > 0)
    count--;
  while (count-- && rl_point < rl_end)
    {
      mbrtowc (&wc, rl_line_buffer + rl_point, rl_end - rl_point, &ps);
      if (iswupper (wc))
	wc = towlower (wc);
      else if (iswlower (wc))
	wc = towupper (wc);
      else
	{
	  /* Just skip over chars neither upper nor lower case */
	  rl_forward_char (1, 0);
	  continue;
	}

      /* Vi is kind of strange here. */
      if (wc)
	{
	  wctomb (mb, wc);
	  rl_begin_undo_group ();
	  rl_delete (1, 0);
	  rl_insert_text (mb);
	  rl_end_undo_group ();
	  rl_vi_check ();
	}
      else
        rl_forward_char (1, 0);
    }

  return 0;
}
#endif

a679 5
#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    return (_rl_vi_change_mbchar_case (count));
#endif

d689 1
a689 1
	  rl_forward_char (1, c);
d698 1
a698 1
	  _rl_insert_char (1, c);
d703 1
a703 1
	rl_forward_char (1, c);
d713 1
a713 1
    rl_point = _rl_find_next_mbchar (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
d716 1
a716 1
  rl_backward_char (1, key);
d724 1
a724 6
    {
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);
      else
        rl_point--;
    }
a746 1
  RL_SETSTATE(RL_STATE_MOREINPUT);
a747 1
  RL_UNSETSTATE(RL_STATE_MOREINPUT);
a757 1
	  RL_SETSTATE(RL_STATE_MOREINPUT);
a758 1
	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
d822 1
a822 1
    SWAP (rl_point, rl_mark);
d828 1
a828 2
   Don't recognize minus sign?
   Should this do rl_save_prompt/rl_restore_prompt? */
a833 1
  RL_SETSTATE(RL_STATE_NUMERICARG);
d836 1
a836 10
      if (rl_numeric_arg > 1000000)
	{
	  rl_explicit_arg = rl_numeric_arg = 0;
	  rl_ding ();
	  rl_clear_message ();
	  RL_UNSETSTATE(RL_STATE_NUMERICARG);
	  return 1;
	}
      rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg);
      RL_SETSTATE(RL_STATE_MOREINPUT);
a837 1
      RL_UNSETSTATE(RL_STATE_MOREINPUT);
d839 1
a839 1
      if (c >= 0 && _rl_keymap[c].type == ISFUNC &&
a861 2

  RL_UNSETSTATE(RL_STATE_NUMERICARG);
d878 1
a878 1
      rl_ding ();
d906 1
a906 1
      rl_ding ();
d956 1
a956 1
      rl_ding ();
d982 1
a982 1
      rl_ding ();
d986 1
a986 4
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    end = _rl_find_next_mbchar (rl_line_buffer, rl_point, count, MB_FIND_NONZERO);
  else
    end = rl_point + count;
d994 1
a994 1
    rl_backward_char (1, key);
a1018 4
#if defined (HANDLE_MULTIBYTE)
  static char *target;
  static int mb_len;
#else
a1019 1
#endif
a1026 3
#if defined (HANDLE_MULTIBYTE)
	target = _rl_vi_last_search_mbchar;
#else
a1027 1
#endif
d1029 1
a1029 10
	{
#if defined (HANDLE_MULTIBYTE)
	  mb_len = _rl_read_mbchar (_rl_vi_last_search_mbchar, MB_LEN_MAX);
	  target = _rl_vi_last_search_mbchar;
#else
	  RL_SETSTATE(RL_STATE_MOREINPUT);
	  _rl_vi_last_search_char = target = rl_read_key ();
	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
#endif
	}
a1050 3
#if defined (HANDLE_MULTIBYTE)
   return (_rl_char_search_internal (count, dir, target, mb_len));
#else
a1051 1
#endif
d1059 1
a1059 1
  int count = 1, brack, pos, tmp, pre;
d1064 3
a1066 14
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  while ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0)
	    {
	      pre = rl_point;
	      rl_forward_char (1, key);
	      if (pre == rl_point)
	        break;
	    }
	}
      else
	while ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0 &&
		rl_point < rl_end - 1)
	  rl_forward_char (1, key);
d1071 1
a1071 1
	  rl_ding ();
d1082 1
a1082 10
	  tmp = pos;
	  if (MB_CUR_MAX == 1 || rl_byte_oriented)
	    pos--;
	  else
	    {
	      pos = _rl_find_prev_mbchar (rl_line_buffer, pos, MB_FIND_ANY);
	      if (tmp == pos)
	        pos--;
	    }
	  if (pos >= 0)
d1092 1
a1092 1
	      rl_ding ();
d1101 1
a1101 6
	  if (MB_CUR_MAX == 1 || rl_byte_oriented)
	    pos++;
	  else
	    pos = _rl_find_next_mbchar (rl_line_buffer, pos, 1, MB_FIND_ANY);

	  if (pos < rl_end)
d1111 1
a1111 1
	      rl_ding ();
a1135 5
/* XXX - think about reading an entire mbchar with _rl_read_mbchar and
   inserting it in one bunch instead of the loop below (like in
   rl_vi_char_search or _rl_vi_change_mbchar_case.  Set c to mbchar[0]
   for test against 033 or ^C.  Make sure that _rl_read_mbchar does
   this right. */
d1145 1
a1145 5
    {
      RL_SETSTATE(RL_STATE_MOREINPUT);
      _rl_vi_last_replacement = c = rl_read_key ();
      RL_UNSETSTATE(RL_STATE_MOREINPUT);
    }
d1155 1
a1155 11
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	while (_rl_insert_char (1, c))
	  {
	    RL_SETSTATE (RL_STATE_MOREINPUT);
	    c = rl_read_key ();
	    RL_UNSETSTATE (RL_STATE_MOREINPUT);
	  }
      else
#endif
	_rl_insert_char (1, c);
d1157 1
a1157 1
	rl_backward_char (1, c);
d1168 13
a1180 3
  /* If we are redoing, rl_vi_change_to will stuff the last motion char */
  if (vi_redoing == 0)
    rl_stuff_char ((key == 'S') ? 'c' : ' ');	/* `S' == `cc', `s' == `c ' */
d1182 17
a1198 1
  return (rl_vi_change_to (count, 'c'));
d1205 2
d1213 1
a1213 1
  if (count > 0)
d1215 12
a1226 2
      _rl_overwrite_char (count, key);
      vi_replace_count += count;
a1227 1

d1241 1
a1241 1
	  rl_ding ();
d1250 1
a1250 1
	rl_backward_char (1, key);
d1311 1
a1311 1
      rl_ding ();
a1328 1
  RL_SETSTATE(RL_STATE_MOREINPUT);
d1330 1
a1330 3
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

  if (ch < 'a' || ch > 'z')
d1332 1
a1332 1
      rl_ding ();
a1345 1
  RL_SETSTATE(RL_STATE_MOREINPUT);
a1346 2
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

d1352 1
a1352 1
  else if (ch < 'a' || ch > 'z')
d1354 1
a1354 1
      rl_ding ();
d1361 1
a1361 1
      rl_ding ();
@


1.2
log
@Dummy commit before importof 4.1 version
@
text
@d11 1
a11 1
   as published by the Free Software Foundation; either version 1, or
d22 1
a22 1
   675 Mass Ave, Cambridge, MA 02139, USA. */
d57 3
a79 20
extern char *xmalloc (), *xrealloc ();

/* Variables imported from readline.c */
extern int rl_point, rl_end, rl_mark;
extern FILE *rl_instream;
extern int rl_line_buffer_len, rl_explicit_arg, rl_numeric_arg;
extern Keymap _rl_keymap;
extern char *rl_prompt;
extern char *rl_line_buffer;
extern int rl_arg_sign;

extern int _rl_doing_an_undo;
extern int _rl_undo_group_level;

extern void _rl_dispatch ();
extern int _rl_char_search_internal ();

extern void rl_extend_line_buffer ();
extern int rl_vi_check ();

d117 1
a117 1
static int rl_digit_loop1 ();
d1029 1
a1029 1
	_rl_vi_last_search_char = target = rl_getc (rl_instream);
d1145 1
a1145 1
    _rl_vi_last_replacement = c = rl_getc (rl_instream);
@


1.1
log
@Initial revision
@
text
@d80 1
a80 1
extern int rl_point, rl_end, rl_mark, rl_done;
d355 1
a355 1
    rl_vi_bWord (count);
d357 1
a357 1
    rl_vi_bword (count);
d377 1
a377 1
    rl_vi_fWord (count);
d379 1
a379 1
    rl_vi_fword (count);
d395 1
a395 1
    rl_vi_eWord (count);
d397 1
a397 1
    rl_vi_eword (count);
d403 2
a404 2
rl_vi_fWord (count)
     int count;
d420 2
a421 2
rl_vi_bWord (count)
     int count;
d444 2
a445 2
rl_vi_eWord (count)
     int count;
d474 2
a475 2
rl_vi_fword (count)
     int count;
d500 2
a501 2
rl_vi_bword (count)
     int count;
d539 2
a540 2
rl_vi_eword (count)
     int count;
d732 1
a732 1
  rl_yank ();
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-08-02 snapshot
@
text
@d80 1
a80 1
extern int rl_point, rl_end, rl_mark;
d355 1
a355 1
    rl_vi_bWord (count, key);
d357 1
a357 1
    rl_vi_bword (count, key);
d377 1
a377 1
    rl_vi_fWord (count, key);
d379 1
a379 1
    rl_vi_fword (count, key);
d395 1
a395 1
    rl_vi_eWord (count, key);
d397 1
a397 1
    rl_vi_eword (count, key);
d403 2
a404 2
rl_vi_fWord (count, ignore)
     int count, ignore;
d420 2
a421 2
rl_vi_bWord (count, ignore)
     int count, ignore;
d444 2
a445 2
rl_vi_eWord (count, ignore)
     int count, ignore;
d474 2
a475 2
rl_vi_fword (count, ignore)
     int count, ignore;
d500 2
a501 2
rl_vi_bword (count, ignore)
     int count, ignore;
d539 2
a540 2
rl_vi_eword (count, ignore)
     int count, ignore;
d732 1
a732 1
  rl_yank (1, key);
@


1.1.1.3
log
@Import of readline 4.1
@
text
@d11 1
a11 1
   as published by the Free Software Foundation; either version 2, or
d22 1
a22 1
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
a56 3
#include "rlprivate.h"
#include "xmalloc.h"

d77 20
d134 1
a134 1
static int rl_digit_loop1 __P((void));
d1046 1
a1046 1
	_rl_vi_last_search_char = target = (*rl_getc_function) (rl_instream);
d1162 1
a1162 1
    _rl_vi_last_replacement = c = (*rl_getc_function) (rl_instream);
@


1.1.1.4
log
@import of readline-4.3
@
text
@a53 2
#include "rlmbutil.h"

d60 8
d72 8
d84 1
a84 1
static const char *vi_motion = " hl^$0ftFT;,%wbeWBE|";
a103 3
#if defined (HANDLE_MULTIBYTE)
static char _rl_vi_last_search_mbchar[MB_LEN_MAX];
#else
a104 1
#endif
d112 1
a112 1
static const char *vi_textmod = "_*\\AaIiCcDdPpYyRrSsXx~";
d115 1
a115 1
static int vi_mark_chars['z' - 'a' + 1];
d117 1
a117 3
static void _rl_vi_stuff_insert PARAMS((int));
static void _rl_vi_save_insert PARAMS((UNDO_LIST *));
static int rl_digit_loop1 PARAMS((void));
a170 2
  int r;

a176 1
  r = 0;
d188 1
a188 1
    r = _rl_dispatch (_rl_vi_last_command, _rl_keymap);
d191 1
a191 1
  return (r);
d277 1
a277 1
      rl_ding ();
d333 1
a333 1
      rl_ding ();
d355 1
a355 1
      rl_ding ();
d373 1
a373 1
      rl_ding ();
d463 1
a463 1
      if (_rl_isident (rl_line_buffer[rl_point]))
d465 1
a465 1
	  while (_rl_isident (rl_line_buffer[rl_point]) && rl_point < rl_end)
d470 1
a470 1
	  while (!_rl_isident (rl_line_buffer[rl_point]) &&
d500 3
a502 3
      last_is_ident = _rl_isident (rl_line_buffer[rl_point - 1]);
      if ((_rl_isident (rl_line_buffer[rl_point]) && !last_is_ident) ||
	  (!_rl_isident (rl_line_buffer[rl_point]) && last_is_ident))
d510 2
a511 2
	  if (_rl_isident (rl_line_buffer[rl_point]))
	    while (--rl_point >= 0 && _rl_isident (rl_line_buffer[rl_point]));
d513 1
a513 1
	    while (--rl_point >= 0 && !_rl_isident (rl_line_buffer[rl_point]) &&
d535 2
a536 2
	  if (_rl_isident (rl_line_buffer[rl_point]))
	    while (++rl_point < rl_end && _rl_isident (rl_line_buffer[rl_point]));
d538 1
a538 1
	    while (++rl_point < rl_end && !_rl_isident (rl_line_buffer[rl_point])
d560 1
a560 11
    {
      if (MB_CUR_MAX == 1 || rl_byte_oriented)
	rl_point++;
      else
        {
          int point = rl_point;
          rl_forward_char (1, key);
          if (point == rl_point)
            rl_point = rl_end;
        }
    }
d614 1
a614 1
      vi_insert_buffer = (char *)xrealloc (vi_insert_buffer, vi_insert_buffer_size);
a624 1
      /* The `C', `s', and `S' commands set this. */
d653 1
a653 1
    rl_backward_char (1, key);
a669 45
/* Change the case of the next COUNT characters. */
#if defined (HANDLE_MULTIBYTE)
static int
_rl_vi_change_mbchar_case (count)
     int count;
{
  wchar_t wc;
  char mb[MB_LEN_MAX];
  mbstate_t ps;

  memset (&ps, 0, sizeof (mbstate_t));
  if (_rl_adjust_point (rl_line_buffer, rl_point, &ps) > 0)
    count--;
  while (count-- && rl_point < rl_end)
    {
      mbrtowc (&wc, rl_line_buffer + rl_point, rl_end - rl_point, &ps);
      if (iswupper (wc))
	wc = towlower (wc);
      else if (iswlower (wc))
	wc = towupper (wc);
      else
	{
	  /* Just skip over chars neither upper nor lower case */
	  rl_forward_char (1, 0);
	  continue;
	}

      /* Vi is kind of strange here. */
      if (wc)
	{
	  wctomb (mb, wc);
	  rl_begin_undo_group ();
	  rl_delete (1, 0);
	  rl_insert_text (mb);
	  rl_end_undo_group ();
	  rl_vi_check ();
	}
      else
        rl_forward_char (1, 0);
    }

  return 0;
}
#endif

a679 5
#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    return (_rl_vi_change_mbchar_case (count));
#endif

d689 1
a689 1
	  rl_forward_char (1, c);
d698 1
a698 1
	  _rl_insert_char (1, c);
d703 1
a703 1
	rl_forward_char (1, c);
d713 1
a713 1
    rl_point = _rl_find_next_mbchar (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
d716 1
a716 1
  rl_backward_char (1, key);
d724 1
a724 6
    {
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);
      else
        rl_point--;
    }
a746 1
  RL_SETSTATE(RL_STATE_MOREINPUT);
a747 1
  RL_UNSETSTATE(RL_STATE_MOREINPUT);
a757 1
	  RL_SETSTATE(RL_STATE_MOREINPUT);
a758 1
	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
d822 1
a822 1
    SWAP (rl_point, rl_mark);
d828 1
a828 2
   Don't recognize minus sign?
   Should this do rl_save_prompt/rl_restore_prompt? */
a833 1
  RL_SETSTATE(RL_STATE_NUMERICARG);
d836 1
a836 10
      if (rl_numeric_arg > 1000000)
	{
	  rl_explicit_arg = rl_numeric_arg = 0;
	  rl_ding ();
	  rl_clear_message ();
	  RL_UNSETSTATE(RL_STATE_NUMERICARG);
	  return 1;
	}
      rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg);
      RL_SETSTATE(RL_STATE_MOREINPUT);
a837 1
      RL_UNSETSTATE(RL_STATE_MOREINPUT);
d839 1
a839 1
      if (c >= 0 && _rl_keymap[c].type == ISFUNC &&
a861 2

  RL_UNSETSTATE(RL_STATE_NUMERICARG);
d878 1
a878 1
      rl_ding ();
d906 1
a906 1
      rl_ding ();
d956 1
a956 1
      rl_ding ();
d982 1
a982 1
      rl_ding ();
d986 1
a986 4
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    end = _rl_find_next_mbchar (rl_line_buffer, rl_point, count, MB_FIND_NONZERO);
  else
    end = rl_point + count;
d994 1
a994 1
    rl_backward_char (1, key);
a1018 4
#if defined (HANDLE_MULTIBYTE)
  static char *target;
  static int mb_len;
#else
a1019 1
#endif
a1026 3
#if defined (HANDLE_MULTIBYTE)
	target = _rl_vi_last_search_mbchar;
#else
a1027 1
#endif
d1029 1
a1029 10
	{
#if defined (HANDLE_MULTIBYTE)
	  mb_len = _rl_read_mbchar (_rl_vi_last_search_mbchar, MB_LEN_MAX);
	  target = _rl_vi_last_search_mbchar;
#else
	  RL_SETSTATE(RL_STATE_MOREINPUT);
	  _rl_vi_last_search_char = target = rl_read_key ();
	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
#endif
	}
a1050 3
#if defined (HANDLE_MULTIBYTE)
   return (_rl_char_search_internal (count, dir, target, mb_len));
#else
a1051 1
#endif
d1059 1
a1059 1
  int count = 1, brack, pos, tmp, pre;
d1064 3
a1066 14
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  while ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0)
	    {
	      pre = rl_point;
	      rl_forward_char (1, key);
	      if (pre == rl_point)
	        break;
	    }
	}
      else
	while ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0 &&
		rl_point < rl_end - 1)
	  rl_forward_char (1, key);
d1071 1
a1071 1
	  rl_ding ();
d1082 1
a1082 10
	  tmp = pos;
	  if (MB_CUR_MAX == 1 || rl_byte_oriented)
	    pos--;
	  else
	    {
	      pos = _rl_find_prev_mbchar (rl_line_buffer, pos, MB_FIND_ANY);
	      if (tmp == pos)
	        pos--;
	    }
	  if (pos >= 0)
d1092 1
a1092 1
	      rl_ding ();
d1101 1
a1101 6
	  if (MB_CUR_MAX == 1 || rl_byte_oriented)
	    pos++;
	  else
	    pos = _rl_find_next_mbchar (rl_line_buffer, pos, 1, MB_FIND_ANY);

	  if (pos < rl_end)
d1111 1
a1111 1
	      rl_ding ();
a1135 5
/* XXX - think about reading an entire mbchar with _rl_read_mbchar and
   inserting it in one bunch instead of the loop below (like in
   rl_vi_char_search or _rl_vi_change_mbchar_case.  Set c to mbchar[0]
   for test against 033 or ^C.  Make sure that _rl_read_mbchar does
   this right. */
d1145 1
a1145 5
    {
      RL_SETSTATE(RL_STATE_MOREINPUT);
      _rl_vi_last_replacement = c = rl_read_key ();
      RL_UNSETSTATE(RL_STATE_MOREINPUT);
    }
d1155 1
a1155 11
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	while (_rl_insert_char (1, c))
	  {
	    RL_SETSTATE (RL_STATE_MOREINPUT);
	    c = rl_read_key ();
	    RL_UNSETSTATE (RL_STATE_MOREINPUT);
	  }
      else
#endif
	_rl_insert_char (1, c);
d1157 1
a1157 1
	rl_backward_char (1, c);
d1168 13
a1180 3
  /* If we are redoing, rl_vi_change_to will stuff the last motion char */
  if (vi_redoing == 0)
    rl_stuff_char ((key == 'S') ? 'c' : ' ');	/* `S' == `cc', `s' == `c ' */
d1182 17
a1198 1
  return (rl_vi_change_to (count, 'c'));
d1205 2
d1213 1
a1213 1
  if (count > 0)
d1215 12
a1226 2
      _rl_overwrite_char (count, key);
      vi_replace_count += count;
a1227 1

d1241 1
a1241 1
	  rl_ding ();
d1250 1
a1250 1
	rl_backward_char (1, key);
d1311 1
a1311 1
      rl_ding ();
a1328 1
  RL_SETSTATE(RL_STATE_MOREINPUT);
d1330 1
a1330 3
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

  if (ch < 'a' || ch > 'z')
d1332 1
a1332 1
      rl_ding ();
a1345 1
  RL_SETSTATE(RL_STATE_MOREINPUT);
a1346 2
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

d1352 1
a1352 1
  else if (ch < 'a' || ch > 'z')
d1354 1
a1354 1
      rl_ding ();
d1361 1
a1361 1
      rl_ding ();
@


1.1.1.5
log
@import of readlilne 5.1
@
text
@d4 1
a4 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
a65 2
int _rl_vi_last_command = 'i';	/* default `.' puts you in insert mode */

d86 1
a91 1
static int _rl_vi_last_search_mblen;
a108 2

static int _rl_vi_arg_dispatch PARAMS((int));
a110 12
static int _rl_vi_set_mark PARAMS((void));
static int _rl_vi_goto_mark PARAMS((void));

static int _rl_vi_callback_getchar PARAMS((char *, int));

#if defined (READLINE_CALLBACKS)
static int _rl_vi_callback_set_mark PARAMS((_rl_callback_generic_arg *));
static int _rl_vi_callback_goto_mark PARAMS((_rl_callback_generic_arg *));
static int _rl_vi_callback_change_char PARAMS((_rl_callback_generic_arg *));
static int _rl_vi_callback_char_search PARAMS((_rl_callback_generic_arg *));
#endif

a117 2

  RL_UNSETSTATE(RL_STATE_VICMDONCE);
a137 10
/* A convenience function that calls _rl_vi_set_last to save the last command
   information and enters insertion mode. */
void
rl_vi_start_inserting (key, repeat, sign)
     int key, repeat, sign;
{
  _rl_vi_set_last (key, repeat, sign);
  rl_vi_insertion_mode (1, key);
}

a263 1
      _rl_free_saved_history_line ();
a267 1
      _rl_free_saved_history_line ();
d300 4
a303 2
    rl_vi_start_inserting (key, 1, rl_arg_sign);

d313 2
a314 1
  rl_vi_start_inserting (key, 1, rl_arg_sign);
d432 1
a432 2
      while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))
	rl_point++;
d643 1
a643 1
      if ((_rl_vi_last_key_before_insert == 'i' || _rl_vi_last_key_before_insert == 'a') && rl_undo_list)
a662 7

  /* This is how POSIX.2 says `U' should behave -- everything up until the
     first time you go into command mode should not be undone. */
  if (RL_ISSTATE (RL_STATE_VICMDONCE) == 0)
    rl_free_undo_list ();

  RL_SETSTATE (RL_STATE_VICMDONCE);
d683 1
a683 2
  char mb[MB_LEN_MAX+1];
  int mblen, p;
d706 1
a706 4
	  p = rl_point;
	  mblen = wcrtomb (mb, wc, &ps);
	  if (mblen >= 0)
	    mb[mblen] = '\0';
d708 1
a708 3
	  rl_vi_delete (1, 0);
	  if (rl_point < p)	/* Did we retreat at EOL? */
	    rl_point++;	/* XXX - should we advance more than 1 for mbchar? */
d725 1
a725 1
  int c, p;
a730 1
  c = 0;
a751 1
	  p = rl_point;
d753 1
a753 3
	  rl_vi_delete (1, c);
	  if (rl_point < p)	/* Did we retreat at EOL? */
	    rl_point++;
d771 1
a771 3
  while (count--)
    rl_yank (1, key);

a818 2
	  rl_explicit_arg = 1;
	  RL_SETSTATE (RL_STATE_NUMERICARG|RL_STATE_VIMOTION);
a819 1
	  RL_UNSETSTATE (RL_STATE_VIMOTION);
a891 35
/* Process C as part of the current numeric argument.  Return -1 if the
   argument should be aborted, 0 if we should not read any more chars, and
   1 if we should continue to read chars. */
static int
_rl_vi_arg_dispatch (c)
     int c;
{
  int key;

  key = c;
  if (c >= 0 && _rl_keymap[c].type == ISFUNC && _rl_keymap[c].function == rl_universal_argument)
    {
      rl_numeric_arg *= 4;
      return 1;
    }

  c = UNMETA (c);

  if (_rl_digit_p (c))
    {
      if (rl_explicit_arg)
	rl_numeric_arg = (rl_numeric_arg * 10) + _rl_digit_value (c);
      else
	rl_numeric_arg = _rl_digit_value (c);
      rl_explicit_arg = 1;
      return 1;
    }
  else
    {
      rl_clear_message ();
      rl_stuff_char (key);
      return 0;
    }
}

d898 1
a898 1
  int c, r;
d900 1
d903 12
a914 2
      if (_rl_arg_overflow ())
	return 1;
d916 6
a921 1
      c = _rl_arg_getchar ();
d923 15
a937 3
      r = _rl_vi_arg_dispatch (c);
      if (r <= 0)
	break;
d1017 2
a1018 1
      rl_vi_start_inserting (key, rl_numeric_arg, rl_arg_sign);
d1028 1
a1028 1
  int c, save;
a1029 1
  save = rl_point;
a1053 31
rl_vi_rubout (count, key)
     int count, key;
{
  int p, opoint;

  if (count < 0)
    return (rl_vi_delete (-count, key));

  if (rl_point == 0)
    {
      rl_ding ();
      return -1;
    }

  opoint = rl_point;
  if (count > 1 && MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    rl_backward_char (count, key);
  else if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);
  else
    rl_point -= count;

  if (rl_point < 0)
    rl_point = 0;

  rl_kill_text (rl_point, opoint);
  
  return (0);
}

int
a1058 3
  if (count < 0)
    return (rl_vi_rubout (-count, key));

a1076 1

a1096 26
static int _rl_cs_dir, _rl_cs_orig_dir;

#if defined (READLINE_CALLBACKS)
static int
_rl_vi_callback_char_search (data)
     _rl_callback_generic_arg *data;
{
#if defined (HANDLE_MULTIBYTE)
  _rl_vi_last_search_mblen = _rl_read_mbchar (_rl_vi_last_search_mbchar, MB_LEN_MAX);
#else
  RL_SETSTATE(RL_STATE_MOREINPUT);
  _rl_vi_last_search_char = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);
#endif

  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

#if defined (HANDLE_MULTIBYTE)
  return (_rl_char_search_internal (data->count, _rl_cs_dir, _rl_vi_last_search_mbchar, _rl_vi_last_search_mblen));
#else
  return (_rl_char_search_internal (data->count, _rl_cs_dir, _rl_vi_last_search_char));
#endif  
}
#endif

d1103 1
a1103 1
  static int tlen;
d1107 1
d1110 1
a1110 1
    _rl_cs_dir = (key == ';') ? _rl_cs_orig_dir : -_rl_cs_orig_dir;
d1113 18
d1134 1
a1134 1
          _rl_cs_orig_dir = _rl_cs_dir = FTO;
d1138 1
a1138 1
          _rl_cs_orig_dir = _rl_cs_dir = BTO;
d1142 1
a1142 1
          _rl_cs_orig_dir = _rl_cs_dir = FFIND;
d1146 1
a1146 1
          _rl_cs_orig_dir = _rl_cs_dir = BFIND;
a1148 24

      if (vi_redoing)
	{
	  /* set target and tlen below */
	}
#if defined (READLINE_CALLBACKS)
      else if (RL_ISSTATE (RL_STATE_CALLBACK))
        {
          _rl_callback_data = _rl_callback_data_alloc (count);
          _rl_callback_data->i1 = _rl_cs_dir;
          _rl_callback_func = _rl_vi_callback_char_search;
          return (0);
        }
#endif
      else
	{
#if defined (HANDLE_MULTIBYTE)
	  _rl_vi_last_search_mblen = _rl_read_mbchar (_rl_vi_last_search_mbchar, MB_LEN_MAX);
#else
	  RL_SETSTATE(RL_STATE_MOREINPUT);
	  _rl_vi_last_search_char = rl_read_key ();
	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
#endif
	}
d1152 1
a1152 2
  target = _rl_vi_last_search_mbchar;
  tlen = _rl_vi_last_search_mblen;
d1154 1
a1154 7
  target = _rl_vi_last_search_char;
#endif

#if defined (HANDLE_MULTIBYTE)
  return (_rl_char_search_internal (count, _rl_cs_dir, target, tlen));
#else
  return (_rl_char_search_internal (count, _rl_cs_dir, target));
d1265 8
a1272 4
static int
_rl_vi_change_char (count, c, mb)
     int count, c;
     char *mb;
d1274 10
a1283 1
  int p;
a1287 1
  rl_begin_undo_group ();
d1290 3
a1292 4
      p = rl_point;
      rl_vi_delete (1, c);
      if (rl_point < p)		/* Did we retreat at EOL? */
	rl_point++;
d1295 6
a1300 1
	rl_insert_text (mb);
d1304 4
a1308 6

  /* The cursor shall be left on the last character changed. */
  rl_backward_char (1, c);

  rl_end_undo_group ();

a1311 63
static int
_rl_vi_callback_getchar (mb, mblen)
     char *mb;
     int mblen;
{
  int c;

  RL_SETSTATE(RL_STATE_MOREINPUT);
  c = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    c = _rl_read_mbstring (c, mb, mblen);
#endif

  return c;
}

#if defined (READLINE_CALLBACKS)
static int
_rl_vi_callback_change_char (data)
     _rl_callback_generic_arg *data;
{
  int c;
  char mb[MB_LEN_MAX];

  _rl_vi_last_replacement = c = _rl_vi_callback_getchar (mb, MB_LEN_MAX);

  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

  return (_rl_vi_change_char (data->count, c, mb));
}
#endif

int
rl_vi_change_char (count, key)
     int count, key;
{
  int c;
  char mb[MB_LEN_MAX];

  if (vi_redoing)
    {
      c = _rl_vi_last_replacement;
      mb[0] = c;
      mb[1] = '\0';
    }
#if defined (READLINE_CALLBACKS)
  else if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = _rl_callback_data_alloc (count);
      _rl_callback_func = _rl_vi_callback_change_char;
      return (0);
    }
#endif
  else
    _rl_vi_last_replacement = c = _rl_vi_callback_getchar (mb, MB_LEN_MAX);

  return (_rl_vi_change_char (count, c, mb));
}

d1318 1
a1318 1
    rl_stuff_char ((key == 'S') ? 'c' : 'l');	/* `S' == `cc', `s' == `cl' */
d1434 3
a1436 2
static int
_rl_vi_set_mark ()
a1453 12
#if defined (READLINE_CALLBACKS)
static int
_rl_vi_callback_set_mark (data)
     _rl_callback_generic_arg *data;
{
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

  return (_rl_vi_set_mark ());
}
#endif

d1455 1
a1455 1
rl_vi_set_mark (count, key)
a1457 15
#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = 0;
      _rl_callback_func = _rl_vi_callback_set_mark;
      return (0);
    }
#endif

  return (_rl_vi_set_mark ());
}

static int
_rl_vi_goto_mark ()
{
a1484 27
#if defined (READLINE_CALLBACKS)
static int
_rl_vi_callback_goto_mark (data)
     _rl_callback_generic_arg *data;
{
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

  return (_rl_vi_goto_mark ());
}
#endif

int
rl_vi_goto_mark (count, key)
     int count, key;
{
#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = 0;
      _rl_callback_func = _rl_vi_callback_goto_mark;
      return (0);
    }
#endif

  return (_rl_vi_goto_mark ());
}
@


