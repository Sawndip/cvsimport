head	1.7;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.7
	gdb_7_6-2013-04-26-release:1.7
	gdb_7_6-branch:1.7.0.6
	gdb_7_6-2013-03-12-branchpoint:1.7
	gdb_7_5_1-2012-11-29-release:1.7
	gdb_7_5-2012-08-17-release:1.7
	gdb_7_5-branch:1.7.0.4
	gdb_7_5-2012-07-18-branchpoint:1.7
	gdb_7_4_1-2012-04-26-release:1.7
	gdb_7_4-2012-01-24-release:1.7
	gdb_7_4-branch:1.7.0.2
	gdb_7_4-2011-12-13-branchpoint:1.7
	gdb_7_3_1-2011-09-04-release:1.6
	gdb_7_3-2011-07-26-release:1.6
	gdb_7_3-branch:1.6.0.36
	gdb_7_3-2011-04-01-branchpoint:1.6
	gdb_7_2-2010-09-02-release:1.6
	gdb_7_2-branch:1.6.0.34
	gdb_7_2-2010-07-07-branchpoint:1.6
	gdb_7_1-2010-03-18-release:1.6
	gdb_7_1-branch:1.6.0.32
	gdb_7_1-2010-02-18-branchpoint:1.6
	gdb_7_0_1-2009-12-22-release:1.6
	gdb_7_0-2009-10-06-release:1.6
	gdb_7_0-branch:1.6.0.30
	gdb_7_0-2009-09-16-branchpoint:1.6
	arc-sim-20090309:1.6
	msnyder-checkpoint-072509-branch:1.6.0.28
	msnyder-checkpoint-072509-branchpoint:1.6
	arc-insight_6_8-branch:1.6.0.26
	arc-insight_6_8-branchpoint:1.6
	insight_6_8-branch:1.6.0.24
	insight_6_8-branchpoint:1.6
	reverse-20081226-branch:1.6.0.22
	reverse-20081226-branchpoint:1.6
	multiprocess-20081120-branch:1.6.0.20
	multiprocess-20081120-branchpoint:1.6
	reverse-20080930-branch:1.6.0.18
	reverse-20080930-branchpoint:1.6
	reverse-20080717-branch:1.6.0.16
	reverse-20080717-branchpoint:1.6
	msnyder-reverse-20080609-branch:1.6.0.14
	msnyder-reverse-20080609-branchpoint:1.6
	drow-reverse-20070409-branch:1.6.0.12
	drow-reverse-20070409-branchpoint:1.6
	gdb_6_8-2008-03-27-release:1.6
	gdb_6_8-branch:1.6.0.10
	gdb_6_8-2008-02-26-branchpoint:1.6
	gdb_6_7_1-2007-10-29-release:1.6
	gdb_6_7-2007-10-10-release:1.6
	gdb_6_7-branch:1.6.0.8
	gdb_6_7-2007-09-07-branchpoint:1.6
	insight_6_6-20070208-release:1.6
	gdb_6_6-2006-12-18-release:1.6
	gdb_6_6-branch:1.6.0.6
	gdb_6_6-2006-11-15-branchpoint:1.6
	insight_6_5-20061003-release:1.6
	gdb-csl-symbian-6_4_50_20060226-12:1.4
	gdb-csl-sourcerygxx-3_4_4-25:1.4
	nickrob-async-20060828-mergepoint:1.6
	gdb-csl-symbian-6_4_50_20060226-11:1.4
	gdb-csl-sourcerygxx-4_1-17:1.4
	gdb-csl-20060226-branch-local-2:1.4
	gdb-csl-sourcerygxx-4_1-14:1.4
	gdb-csl-sourcerygxx-4_1-13:1.4
	gdb-csl-sourcerygxx-4_1-12:1.4
	gdb-csl-sourcerygxx-3_4_4-21:1.4
	gdb_6_5-20060621-release:1.6
	gdb-csl-sourcerygxx-4_1-9:1.4
	gdb-csl-sourcerygxx-4_1-8:1.4
	gdb-csl-sourcerygxx-4_1-7:1.4
	gdb-csl-arm-2006q1-6:1.4
	gdb-csl-sourcerygxx-4_1-6:1.4
	gdb-csl-symbian-6_4_50_20060226-10:1.4
	gdb-csl-symbian-6_4_50_20060226-9:1.4
	gdb-csl-symbian-6_4_50_20060226-8:1.4
	gdb-csl-coldfire-4_1-11:1.4
	gdb-csl-sourcerygxx-3_4_4-19:1.4
	gdb-csl-coldfire-4_1-10:1.4
	gdb_6_5-branch:1.6.0.4
	gdb_6_5-2006-05-14-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-5:1.4
	nickrob-async-20060513-branch:1.6.0.2
	nickrob-async-20060513-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-4:1.4
	msnyder-reverse-20060502-branch:1.5.0.4
	msnyder-reverse-20060502-branchpoint:1.5
	gdb-csl-morpho-4_1-4:1.4
	gdb-csl-sourcerygxx-3_4_4-17:1.4
	readline_5_1-import-branch:1.5.0.2
	readline_5_1-import-branchpoint:1.5
	readline-pre-51-import:1.5
	readline_5_1:1.1.1.5
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.4
	gdb-csl-symbian-20060226-branch:1.4.0.78
	gdb-csl-symbian-20060226-branchpoint:1.4
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.4
	msnyder-reverse-20060331-branch:1.4.0.76
	msnyder-reverse-20060331-branchpoint:1.4
	gdb-csl-available-20060303-branch:1.4.0.74
	gdb-csl-available-20060303-branchpoint:1.4
	gdb-csl-20060226-branch:1.4.0.72
	gdb-csl-20060226-branchpoint:1.4
	gdb_6_4-20051202-release:1.4
	msnyder-fork-checkpoint-branch:1.4.0.70
	msnyder-fork-checkpoint-branchpoint:1.4
	gdb-csl-gxxpro-6_3-branch:1.4.0.68
	gdb-csl-gxxpro-6_3-branchpoint:1.4
	gdb_6_4-branch:1.4.0.66
	gdb_6_4-2005-11-01-branchpoint:1.4
	gdb-csl-arm-20051020-branch:1.4.0.64
	gdb-csl-arm-20051020-branchpoint:1.4
	msnyder-tracepoint-checkpoint-branch:1.4.0.62
	msnyder-tracepoint-checkpoint-branchpoint:1.4
	gdb-csl-arm-20050325-2005-q1b:1.4
	gdb-csl-arm-20050325-2005-q1a:1.4
	csl-arm-20050325-branch:1.4.0.60
	csl-arm-20050325-branchpoint:1.4
	gdb_6_3-20041109-release:1.4
	gdb_6_3-branch:1.4.0.56
	gdb_6_3-20041019-branchpoint:1.4
	drow_intercu-merge-20040921:1.4
	drow_intercu-merge-20040915:1.4
	jimb-gdb_6_2-e500-branch:1.4.0.58
	jimb-gdb_6_2-e500-branchpoint:1.4
	gdb_6_2-20040730-release:1.4
	gdb_6_2-branch:1.4.0.54
	gdb_6_2-2004-07-10-gmt-branchpoint:1.4
	gdb_6_1_1-20040616-release:1.4
	gdb_6_1-2004-04-05-release:1.4
	drow_intercu-merge-20040402:1.4
	drow_intercu-merge-20040327:1.4
	ezannoni_pie-20040323-branch:1.4.0.52
	ezannoni_pie-20040323-branchpoint:1.4
	cagney_tramp-20040321-mergepoint:1.4
	cagney_tramp-20040309-branch:1.4.0.50
	cagney_tramp-20040309-branchpoint:1.4
	gdb_6_1-branch:1.4.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.4
	drow_intercu-20040221-branch:1.4.0.46
	drow_intercu-20040221-branchpoint:1.4
	cagney_bfdfile-20040213-branch:1.4.0.44
	cagney_bfdfile-20040213-branchpoint:1.4
	drow-cplus-merge-20040208:1.4
	carlton_dictionary-20040126-merge:1.4
	cagney_bigcore-20040122-branch:1.4.0.42
	cagney_bigcore-20040122-branchpoint:1.4
	drow-cplus-merge-20040113:1.4
	drow-cplus-merge-20031224:1.4
	drow-cplus-merge-20031220:1.4
	carlton_dictionary-20031215-merge:1.4
	drow-cplus-merge-20031214:1.4
	carlton-dictionary-20031111-merge:1.4
	gdb_6_0-2003-10-04-release:1.4
	kettenis_sparc-20030918-branch:1.4.0.40
	kettenis_sparc-20030918-branchpoint:1.4
	carlton_dictionary-20030917-merge:1.4
	ezannoni_pie-20030916-branchpoint:1.4
	ezannoni_pie-20030916-branch:1.4.0.38
	cagney_x86i386-20030821-branch:1.4.0.36
	cagney_x86i386-20030821-branchpoint:1.4
	carlton_dictionary-20030805-merge:1.4
	carlton_dictionary-20030627-merge:1.4
	gdb_6_0-branch:1.4.0.34
	gdb_6_0-2003-06-23-branchpoint:1.4
	jimb-ppc64-linux-20030613-branch:1.4.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.4
	cagney_convert-20030606-branch:1.4.0.30
	cagney_convert-20030606-branchpoint:1.4
	cagney_writestrings-20030508-branch:1.4.0.28
	cagney_writestrings-20030508-branchpoint:1.4
	jimb-ppc64-linux-20030528-branch:1.4.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.4
	carlton_dictionary-20030523-merge:1.4
	cagney_fileio-20030521-branch:1.4.0.24
	cagney_fileio-20030521-branchpoint:1.4
	kettenis_i386newframe-20030517-mergepoint:1.4
	jimb-ppc64-linux-20030509-branch:1.4.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.4
	kettenis_i386newframe-20030504-mergepoint:1.4
	carlton_dictionary-20030430-merge:1.4
	kettenis_i386newframe-20030419-branch:1.4.0.20
	kettenis_i386newframe-20030419-branchpoint:1.4
	carlton_dictionary-20030416-merge:1.4
	cagney_frameaddr-20030409-mergepoint:1.4
	kettenis_i386newframe-20030406-branch:1.4.0.18
	kettenis_i386newframe-20030406-branchpoint:1.4
	cagney_frameaddr-20030403-branchpoint:1.4
	cagney_frameaddr-20030403-branch:1.4.0.16
	cagney_framebase-20030330-mergepoint:1.4
	cagney_framebase-20030326-branch:1.4.0.14
	cagney_framebase-20030326-branchpoint:1.4
	cagney_lazyid-20030317-branch:1.4.0.12
	cagney_lazyid-20030317-branchpoint:1.4
	kettenis-i386newframe-20030316-mergepoint:1.4
	offbyone-20030313-branch:1.4.0.10
	offbyone-20030313-branchpoint:1.4
	kettenis-i386newframe-20030308-branch:1.4.0.8
	kettenis-i386newframe-20030308-branchpoint:1.4
	carlton_dictionary-20030305-merge:1.4
	cagney_offbyone-20030303-branch:1.4.0.6
	cagney_offbyone-20030303-branchpoint:1.4
	carlton_dictionary-20030207-merge:1.4
	interps-20030202-branch:1.4.0.4
	interps-20030202-branchpoint:1.4
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.3
	readline-pre-43-import:1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.24
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	carlton_dictionary-branch:1.3.0.22
	carlton_dictionary-20020920-branchpoint:1.3
	gdb_5_3-branch:1.3.0.20
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.3
	cagney_sysregs-20020825-branch:1.3.0.18
	cagney_sysregs-20020825-branchpoint:1.3
	readline_4_3-import-branch:1.3.0.16
	readline_4_3-import-branchpoint:1.3
	readline_4_3:1.1.1.4
	gdb_5_2_1-2002-07-23-release:1.3
	kseitz_interps-20020528-branch:1.3.0.14
	kseitz_interps-20020528-branchpoint:1.3
	cagney_regbuf-20020515-branch:1.3.0.12
	cagney_regbuf-20020515-branchpoint:1.3
	jimb-macro-020506-branch:1.3.0.10
	jimb-macro-020506-branchpoint:1.3
	gdb_5_2-2002-04-29-release:1.3
	gdb_5_2-branch:1.3.0.8
	gdb_5_2-2002-03-03-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	cygnus_cvs_20020108_pre:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.4
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.2
	gdb_5_1-2001-07-29-branchpoint:1.3
	insight-precleanup-2001-01-01:1.3
	readline_4_1:1.1.1.3
	readline_4_0:1.1.1.2
	FSF:1.1.1
	readline-pre-41-import:1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.7
date	2011.05.11.23.38.39;	author jkratoch;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.05.18.26.12;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.20.20.13.20;	author ezannoni;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2002.12.08.22.31.37;	author ezannoni;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.09.17.19.56;	author ezannoni;	state Exp;
branches
	1.3.16.1
	1.3.22.1
	1.3.24.1;
next	1.2;

1.2
date	2000.07.07.17.15.45;	author ezannoni;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.54;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.5.2.1
date	2006.04.24.22.00.25;	author drow;	state Exp;
branches;
next	;

1.3.16.1
date	2002.08.25.23.41.17;	author ezannoni;	state Exp;
branches;
next	;

1.3.22.1
date	2002.12.23.19.39.44;	author carlton;	state Exp;
branches;
next	;

1.3.24.1
date	2003.12.14.20.28.14;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.54;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.08.02.23.47.58;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.07.09.16.21.20;	author ezannoni;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.08.23.22.02.28;	author ezannoni;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.20.20.05.37;	author ezannoni;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Imported readline 6.2, and upstream patch 001.

[patch 0/3] readline-6.2 rebase
http://sourceware.org/ml/gdb-patches/2011-05/msg00003.html
[patch 1/3] readline-6.2: Merge of already posted patches
http://sourceware.org/ml/gdb-patches/2011-05/msg00004.html
	=
	[Bug-readline] [RFC/readline] bind.c, rl_function_dumper, Free allocated
	http://lists.gnu.org/archive/html/bug-readline/2011-03/msg00000.html
	[Bug-readline] [patch] Fix underquotation in readline/examples/rlfe/conf
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00001.html
	[Bug-readline] [patch] Makefile.in htm<->html
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00002.html
	Re: [Bug-readline] [patch] Makefile.in dependency: callback.o: xmalloc.h
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00004.html
	[Bug-readline] [patch] Remove . from the VPATH directive
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00005.html
	Eli Zaretskii's __MSDOS__ / __GO32__ / __MINGW32__ / __DJGPP__ stuff:
	http://sourceware.org/ml/gdb/2011-04/msg00002.html
	Jan Kratochvil's patch for FSF GDB tree local-specific changes:
	http://sourceware.org/ml/gdb/2011-04/msg00006.html
	Preservation of existing ChangeLog.gdb files, their updates.
[patch 2/3] readline-6.2: Workaround "ask" regression
http://sourceware.org/ml/gdb-patches/2011-05/msg00005.html
[patch 3/3] readline-6.2: Revert 5.x compat., apply 6.x compat.
http://sourceware.org/ml/gdb-patches/2011-05/msg00006.html
[patch 4/3] readline-6.2: Substitute inc-hist.texinfo
http://sourceware.org/ml/gdb-patches/2011-05/msg00010.html

readline/
	Workaround gdb.base/completion.exp regression on readline-6.2.
	* complete.c (get_y_or_n): Disable the return on RL_STATE_CALLBACK.

	Imported readline 6.2, and upstream patch 001.
	* configure: Regenerate.

readline/doc/
	* hsuser.texi (Using History Interactively): Disable !BashFeatures
	@@defcodeindex.  Make the `Programming with GNU History' reference
	external.
	* inc-hist.texinfo: Remove.

	Imported readline 6.2, and upstream patch 001.

readline/examples/
	Imported readline 6.2, and upstream patch 001.

readline/examples/rlfe/
	Imported readline 6.2, and upstream patch 001.

gdb/
	* config.in: Regenerate.
	* configure: Regenerate.
	* configure.ac <--with-system-readline> (for readline_echoing_p):
	Remove the test.
	* tui/tui-io.c (tui_old_readline_echoing_p): Rename to ...
	(tui_old_rl_echoing_p): ... here.
	(tui_setup_io): Rename extern declaration readline_echoing_p to
	_rl_echoing_p.  Adjust assignments for the both renames.

gdb/doc/
	* Makefile.in (GDB_DOC_SOURCE_INCLUDES): Rename inc-hist.texinfo to
	hsuser.texi.
	* gdb.texinfo <!SYSTEM_READLINE>: Rename inc-hist.texinfo inclusion and
	comment to hsuser.texi.  Change rluser.texi name in the comment.
@
text
@/* search.c - code for non-incremental searching in emacs and vi modes. */

/* Copyright (C) 1992-2009 Free Software Foundation, Inc.

   This file is part of the GNU Readline Library (Readline), a library
   for reading lines of text with interactive input and history editing.      

   Readline is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Readline is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Readline.  If not, see <http://www.gnu.org/licenses/>.
*/

#define READLINE_LIBRARY

#if defined (HAVE_CONFIG_H)
#  include <config.h>
#endif

#include <sys/types.h>
#include <stdio.h>

#if defined (HAVE_UNISTD_H)
#  include <unistd.h>
#endif

#if defined (HAVE_STDLIB_H)
#  include <stdlib.h>
#else
#  include "ansi_stdlib.h"
#endif

#include "rldefs.h"
#include "rlmbutil.h"

#include "readline.h"
#include "history.h"

#include "rlprivate.h"
#include "xmalloc.h"

#ifdef abs
#  undef abs
#endif
#define abs(x)		(((x) >= 0) ? (x) : -(x))

_rl_search_cxt *_rl_nscxt = 0;

extern HIST_ENTRY *_rl_saved_line_for_history;

/* Functions imported from the rest of the library. */
extern int _rl_free_history_entry PARAMS((HIST_ENTRY *));

static char *noninc_search_string = (char *) NULL;
static int noninc_history_pos;

static char *prev_line_found = (char *) NULL;

static int rl_history_search_len;
static int rl_history_search_pos;
static char *history_search_string;
static int history_string_size;

static void make_history_line_current PARAMS((HIST_ENTRY *));
static int noninc_search_from_pos PARAMS((char *, int, int));
static int noninc_dosearch PARAMS((char *, int));
static int noninc_search PARAMS((int, int));
static int rl_history_search_internal PARAMS((int, int));
static void rl_history_search_reinit PARAMS((void));

static _rl_search_cxt *_rl_nsearch_init PARAMS((int, int));
static int _rl_nsearch_cleanup PARAMS((_rl_search_cxt *, int));
static void _rl_nsearch_abort PARAMS((_rl_search_cxt *));
static int _rl_nsearch_dispatch PARAMS((_rl_search_cxt *, int));

/* Make the data from the history entry ENTRY be the contents of the
   current line.  This doesn't do anything with rl_point; the caller
   must set it. */
static void
make_history_line_current (entry)
     HIST_ENTRY *entry;
{
  _rl_replace_text (entry->line, 0, rl_end);
  _rl_fix_point (1);
#if defined (VI_MODE)
  if (rl_editing_mode == vi_mode)
    /* POSIX.2 says that the `U' command doesn't affect the copy of any
       command lines to the edit line.  We're going to implement that by
       making the undo list start after the matching line is copied to the
       current editing buffer. */
    rl_free_undo_list ();
#endif

  if (_rl_saved_line_for_history)
    _rl_free_history_entry (_rl_saved_line_for_history);
  _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
}

/* Search the history list for STRING starting at absolute history position
   POS.  If STRING begins with `^', the search must match STRING at the
   beginning of a history line, otherwise a full substring match is performed
   for STRING.  DIR < 0 means to search backwards through the history list,
   DIR >= 0 means to search forward. */
static int
noninc_search_from_pos (string, pos, dir)
     char *string;
     int pos, dir;
{
  int ret, old;

  if (pos < 0)
    return -1;

  old = where_history ();
  if (history_set_pos (pos) == 0)
    return -1;

  RL_SETSTATE(RL_STATE_SEARCH);
  if (*string == '^')
    ret = history_search_prefix (string + 1, dir);
  else
    ret = history_search (string, dir);
  RL_UNSETSTATE(RL_STATE_SEARCH);

  if (ret != -1)
    ret = where_history ();

  history_set_pos (old);
  return (ret);
}

/* Search for a line in the history containing STRING.  If DIR is < 0, the
   search is backwards through previous entries, else through subsequent
   entries.  Returns 1 if the search was successful, 0 otherwise. */
static int
noninc_dosearch (string, dir)
     char *string;
     int dir;
{
  int oldpos, pos;
  HIST_ENTRY *entry;

  if (string == 0 || *string == '\0' || noninc_history_pos < 0)
    {
      rl_ding ();
      return 0;
    }

  pos = noninc_search_from_pos (string, noninc_history_pos + dir, dir);
  if (pos == -1)
    {
      /* Search failed, current history position unchanged. */
      rl_maybe_unsave_line ();
      rl_clear_message ();
      rl_point = 0;
      rl_ding ();
      return 0;
    }

  noninc_history_pos = pos;

  oldpos = where_history ();
  history_set_pos (noninc_history_pos);
  entry = current_history ();
#if defined (VI_MODE)
  if (rl_editing_mode != vi_mode)
#endif
    history_set_pos (oldpos);

  make_history_line_current (entry);

  rl_point = 0;
  rl_mark = rl_end;

  rl_clear_message ();
  return 1;
}

static _rl_search_cxt *
_rl_nsearch_init (dir, pchar)
     int dir, pchar;
{
  _rl_search_cxt *cxt;
  char *p;

  cxt = _rl_scxt_alloc (RL_SEARCH_NSEARCH, 0);
  if (dir < 0)
    cxt->sflags |= SF_REVERSE;		/* not strictly needed */

  cxt->direction = dir;
  cxt->history_pos = cxt->save_line;

  rl_maybe_save_line ();

  /* Clear the undo list, since reading the search string should create its
     own undo list, and the whole list will end up being freed when we
     finish reading the search string. */
  rl_undo_list = 0;

  /* Use the line buffer to read the search string. */
  rl_line_buffer[0] = 0;
  rl_end = rl_point = 0;

  p = _rl_make_prompt_for_search (pchar ? pchar : ':');
  rl_message ("%s", p, 0);
  xfree (p);

  RL_SETSTATE(RL_STATE_NSEARCH);

  _rl_nscxt = cxt;

  return cxt;
}

static int
_rl_nsearch_cleanup (cxt, r)
     _rl_search_cxt *cxt;
     int r;
{
  _rl_scxt_dispose (cxt, 0);
  _rl_nscxt = 0;

  RL_UNSETSTATE(RL_STATE_NSEARCH);

  return (r != 1);
}

static void
_rl_nsearch_abort (cxt)
     _rl_search_cxt *cxt;
{
  rl_maybe_unsave_line ();
  rl_clear_message ();
  rl_point = cxt->save_point;
  rl_mark = cxt->save_mark;
  rl_restore_prompt ();

  RL_UNSETSTATE (RL_STATE_NSEARCH);
}

/* Process just-read character C according to search context CXT.  Return -1
   if the caller should abort the search, 0 if we should break out of the
   loop, and 1 if we should continue to read characters. */
static int
_rl_nsearch_dispatch (cxt, c)
     _rl_search_cxt *cxt;
     int c;
{
  switch (c)
    {
    case CTRL('W'):
      rl_unix_word_rubout (1, c);
      break;

    case CTRL('U'):
      rl_unix_line_discard (1, c);
      break;

    case RETURN:
    case NEWLINE:
      return 0;

    case CTRL('H'):
    case RUBOUT:
      if (rl_point == 0)
	{
	  _rl_nsearch_abort (cxt);
	  return -1;
	}
      _rl_rubout_char (1, c);
      break;

    case CTRL('C'):
    case CTRL('G'):
      rl_ding ();
      _rl_nsearch_abort (cxt);
      return -1;

    default:
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_insert_text (cxt->mb);
      else
#endif
	_rl_insert_char (1, c);
      break;
    }

  (*rl_redisplay_function) ();
  return 1;
}

/* Perform one search according to CXT, using NONINC_SEARCH_STRING.  Return
   -1 if the search should be aborted, any other value means to clean up
   using _rl_nsearch_cleanup ().  Returns 1 if the search was successful,
   0 otherwise. */
static int
_rl_nsearch_dosearch (cxt)
     _rl_search_cxt *cxt;
{
  rl_mark = cxt->save_mark;

  /* If rl_point == 0, we want to re-use the previous search string and
     start from the saved history position.  If there's no previous search
     string, punt. */
  if (rl_point == 0)
    {
      if (noninc_search_string == 0)
	{
	  rl_ding ();
	  rl_restore_prompt ();
	  RL_UNSETSTATE (RL_STATE_NSEARCH);
	  return -1;
	}
    }
  else
    {
      /* We want to start the search from the current history position. */
      noninc_history_pos = cxt->save_line;
      FREE (noninc_search_string);
      noninc_search_string = savestring (rl_line_buffer);

      /* If we don't want the subsequent undo list generated by the search
	 matching a history line to include the contents of the search string,
	 we need to clear rl_line_buffer here.  For now, we just clear the
	 undo list generated by reading the search string.  (If the search
	 fails, the old undo list will be restored by rl_maybe_unsave_line.) */
      rl_free_undo_list ();
    }

  rl_restore_prompt ();
  return (noninc_dosearch (noninc_search_string, cxt->direction));
}

/* Search non-interactively through the history list.  DIR < 0 means to
   search backwards through the history of previous commands; otherwise
   the search is for commands subsequent to the current position in the
   history list.  PCHAR is the character to use for prompting when reading
   the search string; if not specified (0), it defaults to `:'. */
static int
noninc_search (dir, pchar)
     int dir;
     int pchar;
{
  _rl_search_cxt *cxt;
  int c, r;

  cxt = _rl_nsearch_init (dir, pchar);

  if (RL_ISSTATE (RL_STATE_CALLBACK))
    return (0);

  /* Read the search string. */
  r = 0;
  while (1)
    {
      c = _rl_search_getchar (cxt);

      if (c == 0)
	break;

      r = _rl_nsearch_dispatch (cxt, c);
      if (r < 0)
        return 1;
      else if (r == 0)
	break;        
    }

  r = _rl_nsearch_dosearch (cxt);
  return ((r >= 0) ? _rl_nsearch_cleanup (cxt, r) : (r != 1));
}

/* Search forward through the history list for a string.  If the vi-mode
   code calls this, KEY will be `?'. */
int
rl_noninc_forward_search (count, key)
     int count, key;
{
  return noninc_search (1, (key == '?') ? '?' : 0);
}

/* Reverse search the history list for a string.  If the vi-mode code
   calls this, KEY will be `/'. */
int
rl_noninc_reverse_search (count, key)
     int count, key;
{
  return noninc_search (-1, (key == '/') ? '/' : 0);
}

/* Search forward through the history list for the last string searched
   for.  If there is no saved search string, abort. */
int
rl_noninc_forward_search_again (count, key)
     int count, key;
{
  int r;

  if (!noninc_search_string)
    {
      rl_ding ();
      return (-1);
    }
  r = noninc_dosearch (noninc_search_string, 1);
  return (r != 1);
}

/* Reverse search in the history list for the last string searched
   for.  If there is no saved search string, abort. */
int
rl_noninc_reverse_search_again (count, key)
     int count, key;
{
  int r;

  if (!noninc_search_string)
    {
      rl_ding ();
      return (-1);
    }
  r = noninc_dosearch (noninc_search_string, -1);
  return (r != 1);
}

#if defined (READLINE_CALLBACKS)
int
_rl_nsearch_callback (cxt)
     _rl_search_cxt *cxt;
{
  int c, r;

  c = _rl_search_getchar (cxt);
  r = _rl_nsearch_dispatch (cxt, c);
  if (r != 0)
    return 1;

  r = _rl_nsearch_dosearch (cxt);
  return ((r >= 0) ? _rl_nsearch_cleanup (cxt, r) : (r != 1));
}
#endif
  
static int
rl_history_search_internal (count, dir)
     int count, dir;
{
  HIST_ENTRY *temp;
  int ret, oldpos;

  rl_maybe_save_line ();
  temp = (HIST_ENTRY *)NULL;

  /* Search COUNT times through the history for a line whose prefix
     matches history_search_string.  When this loop finishes, TEMP,
     if non-null, is the history line to copy into the line buffer. */
  while (count)
    {
      ret = noninc_search_from_pos (history_search_string, rl_history_search_pos + dir, dir);
      if (ret == -1)
	break;

      /* Get the history entry we found. */
      rl_history_search_pos = ret;
      oldpos = where_history ();
      history_set_pos (rl_history_search_pos);
      temp = current_history ();
      history_set_pos (oldpos);

      /* Don't find multiple instances of the same line. */
      if (prev_line_found && STREQ (prev_line_found, temp->line))
        continue;
      prev_line_found = temp->line;
      count--;
    }

  /* If we didn't find anything at all, return. */
  if (temp == 0)
    {
      rl_maybe_unsave_line ();
      rl_ding ();
      /* If you don't want the saved history line (last match) to show up
         in the line buffer after the search fails, change the #if 0 to
         #if 1 */
#if 0
      if (rl_point > rl_history_search_len)
        {
          rl_point = rl_end = rl_history_search_len;
          rl_line_buffer[rl_end] = '\0';
          rl_mark = 0;
        }
#else
      rl_point = rl_history_search_len;	/* rl_maybe_unsave_line changes it */
      rl_mark = rl_end;
#endif
      return 1;
    }

  /* Copy the line we found into the current line buffer. */
  make_history_line_current (temp);

  rl_point = rl_history_search_len;
  rl_mark = rl_end;

  return 0;
}

static void
rl_history_search_reinit ()
{
  rl_history_search_pos = where_history ();
  rl_history_search_len = rl_point;
  prev_line_found = (char *)NULL;
  if (rl_point)
    {
      if (rl_history_search_len >= history_string_size - 2)
	{
	  history_string_size = rl_history_search_len + 2;
	  history_search_string = (char *)xrealloc (history_search_string, history_string_size);
	}
      history_search_string[0] = '^';
      strncpy (history_search_string + 1, rl_line_buffer, rl_point);
      history_search_string[rl_point + 1] = '\0';
    }
  _rl_free_saved_history_line ();
}

/* Search forward in the history for the string of characters
   from the start of the line to rl_point.  This is a non-incremental
   search. */
int
rl_history_search_forward (count, ignore)
     int count, ignore;
{
  if (count == 0)
    return (0);

  if (rl_last_func != rl_history_search_forward &&
      rl_last_func != rl_history_search_backward)
    rl_history_search_reinit ();

  if (rl_history_search_len == 0)
    return (rl_get_next_history (count, ignore));
  return (rl_history_search_internal (abs (count), (count > 0) ? 1 : -1));
}

/* Search backward through the history for the string of characters
   from the start of the line to rl_point.  This is a non-incremental
   search. */
int
rl_history_search_backward (count, ignore)
     int count, ignore;
{
  if (count == 0)
    return (0);

  if (rl_last_func != rl_history_search_forward &&
      rl_last_func != rl_history_search_backward)
    rl_history_search_reinit ();

  if (rl_history_search_len == 0)
    return (rl_get_previous_history (count, ignore));
  return (rl_history_search_internal (abs (count), (count > 0) ? -1 : 1));
}
@


1.6
log
@Readline 5.1 import for HEAD.
@
text
@d3 1
a3 1
/* Copyright (C) 1992-2005 Free Software Foundation, Inc.
d5 2
a6 3
   This file is part of the Readline Library (the Library), a set of
   routines for providing Emacs style line input to programs that ask
   for it.
d8 1
a8 1
   The Library is free software; you can redistribute it and/or modify
d10 11
a20 2
   the Free Software Foundation; either version 2, or (at your option)
   any later version.
a21 9
   The Library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   The GNU General Public License is often shipped with GNU software, and
   is generally kept in a file called COPYING or LICENSE.  If you do not
   have a copy of the license, write to the Free Software Foundation,
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
a71 1
static UNDO_LIST *noninc_saved_undo_list;
d213 2
a214 2
  rl_message (p, 0, 0);
  free (p);
@


1.5
log
@touched all sources to ease import of readline-5.1
@
text
@d3 1
a3 1
/* Copyright (C) 1992 Free Software Foundation, Inc.
d56 2
d73 1
d76 2
a77 2
static void noninc_dosearch PARAMS((char *, int));
static void noninc_search PARAMS((int, int));
d81 5
d93 10
a102 2
  rl_replace_line (entry->line, 0);
  rl_undo_list = (UNDO_LIST *)entry->data;
d144 2
a145 2
   entries. */
static void
d156 1
a156 1
      return;
d167 1
a167 1
      return;
d178 1
a178 1
  history_set_pos (oldpos);
d186 1
d189 3
a191 9
/* Search non-interactively through the history list.  DIR < 0 means to
   search backwards through the history of previous commands; otherwise
   the search is for commands subsequent to the current position in the
   history list.  PCHAR is the character to use for prompting when reading
   the search string; if not specified (0), it defaults to `:'. */
static void
noninc_search (dir, pchar)
     int dir;
     int pchar;
d193 1
a193 1
  int saved_point, saved_mark, c;
d195 7
a201 3
#if defined (HANDLE_MULTIBYTE)
  char mb[MB_LEN_MAX];
#endif
d204 5
a208 2
  saved_point = rl_point;
  saved_mark = rl_mark;
d218 16
a233 1
#define SEARCH_RETURN rl_restore_prompt (); RL_UNSETSTATE(RL_STATE_NSEARCH); return
d235 2
a236 7
  RL_SETSTATE(RL_STATE_NSEARCH);
  /* Read the search string. */
  while (1)
    {
      RL_SETSTATE(RL_STATE_MOREINPUT);
      c = rl_read_key ();
      RL_UNSETSTATE(RL_STATE_MOREINPUT);
d238 9
a246 4
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	c = _rl_read_mbstring (c, mb, MB_LEN_MAX);
#endif
d248 2
a249 2
      if (c == 0)
	break;
d251 25
a275 1
      switch (c)
d277 11
a287 35
	case CTRL('H'):
	case RUBOUT:
	  if (rl_point == 0)
	    {
	      rl_maybe_unsave_line ();
	      rl_clear_message ();
	      rl_point = saved_point;
	      rl_mark = saved_mark;
	      SEARCH_RETURN;
	    }
	  _rl_rubout_char (1, c);
	  break;

	case CTRL('W'):
	  rl_unix_word_rubout (1, c);
	  break;

	case CTRL('U'):
	  rl_unix_line_discard (1, c);
	  break;

	case RETURN:
	case NEWLINE:
	  goto dosearch;
	  /* NOTREACHED */
	  break;

	case CTRL('C'):
	case CTRL('G'):
	  rl_maybe_unsave_line ();
	  rl_clear_message ();
	  rl_point = saved_point;
	  rl_mark = saved_mark;
	  rl_ding ();
	  SEARCH_RETURN;
d289 1
a289 1
	default:
d291 3
a293 3
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    rl_insert_text (mb);
	  else
d295 2
a296 4
	    _rl_insert_char (1, c);
	  break;
	}
      (*rl_redisplay_function) ();
d299 13
a311 2
 dosearch:
  rl_mark = saved_mark;
d318 1
a318 1
      if (!noninc_search_string)
d321 3
a323 1
	  SEARCH_RETURN;
d329 1
a329 1
      noninc_history_pos = where_history ();
d332 7
d342 39
a380 2
  noninc_dosearch (noninc_search_string, dir);
  RL_UNSETSTATE(RL_STATE_NSEARCH);
d389 1
a389 2
  noninc_search (1, (key == '?') ? '?' : 0);
  return 0;
d398 1
a398 2
  noninc_search (-1, (key == '/') ? '/' : 0);
  return 0;
d407 2
d414 2
a415 2
  noninc_dosearch (noninc_search_string, 1);
  return 0;
d424 2
d431 2
a432 2
  noninc_dosearch (noninc_search_string, -1);
  return 0;
d435 17
@


1.5.2.1
log
@Import readline 5.1 on the branch.
@
text
@d3 1
a3 1
/* Copyright (C) 1992-2005 Free Software Foundation, Inc.
a55 2
_rl_search_cxt *_rl_nscxt = 0;

a70 1
static UNDO_LIST *noninc_saved_undo_list;
d73 2
a74 2
static int noninc_dosearch PARAMS((char *, int));
static int noninc_search PARAMS((int, int));
a77 5
static _rl_search_cxt *_rl_nsearch_init PARAMS((int, int));
static int _rl_nsearch_cleanup PARAMS((_rl_search_cxt *, int));
static void _rl_nsearch_abort PARAMS((_rl_search_cxt *));
static int _rl_nsearch_dispatch PARAMS((_rl_search_cxt *, int));

d85 2
a86 10
  _rl_replace_text (entry->line, 0, rl_end);
  _rl_fix_point (1);
#if defined (VI_MODE)
  if (rl_editing_mode == vi_mode)
    /* POSIX.2 says that the `U' command doesn't affect the copy of any
       command lines to the edit line.  We're going to implement that by
       making the undo list start after the matching line is copied to the
       current editing buffer. */
    rl_free_undo_list ();
#endif
d128 2
a129 2
   entries.  Returns 1 if the search was successful, 0 otherwise. */
static int
d140 1
a140 1
      return 0;
d151 1
a151 1
      return 0;
d162 1
a162 1
    history_set_pos (oldpos);
a169 1
  return 1;
d172 9
a180 3
static _rl_search_cxt *
_rl_nsearch_init (dir, pchar)
     int dir, pchar;
d182 1
a182 1
  _rl_search_cxt *cxt;
d184 3
a186 7

  cxt = _rl_scxt_alloc (RL_SEARCH_NSEARCH, 0);
  if (dir < 0)
    cxt->sflags |= SF_REVERSE;		/* not strictly needed */

  cxt->direction = dir;
  cxt->history_pos = cxt->save_line;
d189 2
a190 5

  /* Clear the undo list, since reading the search string should create its
     own undo list, and the whole list will end up being freed when we
     finish reading the search string. */
  rl_undo_list = 0;
d200 2
d203 6
d210 4
a213 1
  _rl_nscxt = cxt;
d215 2
a216 25
  return cxt;
}

static int
_rl_nsearch_cleanup (cxt, r)
     _rl_search_cxt *cxt;
     int r;
{
  _rl_scxt_dispose (cxt, 0);
  _rl_nscxt = 0;

  RL_UNSETSTATE(RL_STATE_NSEARCH);

  return (r != 1);
}

static void
_rl_nsearch_abort (cxt)
     _rl_search_cxt *cxt;
{
  rl_maybe_unsave_line ();
  rl_clear_message ();
  rl_point = cxt->save_point;
  rl_mark = cxt->save_mark;
  rl_restore_prompt ();
d218 1
a218 28
  RL_UNSETSTATE (RL_STATE_NSEARCH);
}

/* Process just-read character C according to search context CXT.  Return -1
   if the caller should abort the search, 0 if we should break out of the
   loop, and 1 if we should continue to read characters. */
static int
_rl_nsearch_dispatch (cxt, c)
     _rl_search_cxt *cxt;
     int c;
{
  switch (c)
    {
    case CTRL('W'):
      rl_unix_word_rubout (1, c);
      break;

    case CTRL('U'):
      rl_unix_line_discard (1, c);
      break;

    case RETURN:
    case NEWLINE:
      return 0;

    case CTRL('H'):
    case RUBOUT:
      if (rl_point == 0)
d220 35
a254 11
	  _rl_nsearch_abort (cxt);
	  return -1;
	}
      _rl_rubout_char (1, c);
      break;

    case CTRL('C'):
    case CTRL('G'):
      rl_ding ();
      _rl_nsearch_abort (cxt);
      return -1;
d256 1
a256 1
    default:
d258 3
a260 3
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_insert_text (cxt->mb);
      else
d262 4
a265 2
	_rl_insert_char (1, c);
      break;
d268 2
a269 13
  (*rl_redisplay_function) ();
  return 1;
}

/* Perform one search according to CXT, using NONINC_SEARCH_STRING.  Return
   -1 if the search should be aborted, any other value means to clean up
   using _rl_nsearch_cleanup ().  Returns 1 if the search was successful,
   0 otherwise. */
static int
_rl_nsearch_dosearch (cxt)
     _rl_search_cxt *cxt;
{
  rl_mark = cxt->save_mark;
d276 1
a276 1
      if (noninc_search_string == 0)
d279 1
a279 3
	  rl_restore_prompt ();
	  RL_UNSETSTATE (RL_STATE_NSEARCH);
	  return -1;
d285 1
a285 1
      noninc_history_pos = cxt->save_line;
a287 7

      /* If we don't want the subsequent undo list generated by the search
	 matching a history line to include the contents of the search string,
	 we need to clear rl_line_buffer here.  For now, we just clear the
	 undo list generated by reading the search string.  (If the search
	 fails, the old undo list will be restored by rl_maybe_unsave_line.) */
      rl_free_undo_list ();
d291 2
a292 39
  return (noninc_dosearch (noninc_search_string, cxt->direction));
}

/* Search non-interactively through the history list.  DIR < 0 means to
   search backwards through the history of previous commands; otherwise
   the search is for commands subsequent to the current position in the
   history list.  PCHAR is the character to use for prompting when reading
   the search string; if not specified (0), it defaults to `:'. */
static int
noninc_search (dir, pchar)
     int dir;
     int pchar;
{
  _rl_search_cxt *cxt;
  int c, r;

  cxt = _rl_nsearch_init (dir, pchar);

  if (RL_ISSTATE (RL_STATE_CALLBACK))
    return (0);

  /* Read the search string. */
  r = 0;
  while (1)
    {
      c = _rl_search_getchar (cxt);

      if (c == 0)
	break;

      r = _rl_nsearch_dispatch (cxt, c);
      if (r < 0)
        return 1;
      else if (r == 0)
	break;        
    }

  r = _rl_nsearch_dosearch (cxt);
  return ((r >= 0) ? _rl_nsearch_cleanup (cxt, r) : (r != 1));
d301 2
a302 1
  return noninc_search (1, (key == '?') ? '?' : 0);
d311 2
a312 1
  return noninc_search (-1, (key == '/') ? '/' : 0);
a320 2
  int r;

d326 2
a327 2
  r = noninc_dosearch (noninc_search_string, 1);
  return (r != 1);
a335 2
  int r;

d341 2
a342 2
  r = noninc_dosearch (noninc_search_string, -1);
  return (r != 1);
a344 17
#if defined (READLINE_CALLBACKS)
int
_rl_nsearch_callback (cxt)
     _rl_search_cxt *cxt;
{
  int c, r;

  c = _rl_search_getchar (cxt);
  r = _rl_nsearch_dispatch (cxt, c);
  if (r != 0)
    return 1;

  r = _rl_nsearch_dosearch (cxt);
  return ((r >= 0) ? _rl_nsearch_cleanup (cxt, r) : (r != 1));
}
#endif
  
@


1.4
log
@Import of readline 4.3.
Non-readline modified files:

src/gdb/ChangeLog src/gdb/defs.h src/gdb/cli/cli-cmds.c
src/gdb/cli/cli-setshow.c src/gdb/tui/ChangeLog
src/gdb/tui/tuiWin.c

In readline directory:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@@


1.3
log
@readline:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Locally modified files: Makefile.in, configure.in, configure
        (regenerated), config.h.in (regenerated), readline.h, rltty.c,
 	shell.c signals.c.

        Locally added files: acconfig.h, config/*, config.h.bot,
        cross-build/*, doc/inc-hit.texinfo.

        New files: USAGE, rlprivate.h, rlshell.h, xmalloc.h.
examples:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        New files: excallback.c, rlfe.c.
doc:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Regenerated inc-hist.texinfo as copy of hsuser.texinfo, for
        inclusion in the gdb manual.

        New file: rluserman.texinfo
@
text
@d43 2
d56 1
a56 1
extern HIST_ENTRY *saved_line_for_history;
d59 1
a59 1
extern int _rl_free_history_entry __P((HIST_ENTRY *));
d71 7
d85 1
a85 7
  int line_len;

  line_len = strlen (entry->line);
  if (line_len >= rl_line_buffer_len)
    rl_extend_line_buffer (line_len);
  strcpy (rl_line_buffer, entry->line);

a86 1
  rl_end = line_len;
d88 3
a90 3
  if (saved_line_for_history)
    _rl_free_history_entry (saved_line_for_history);
  saved_line_for_history = (HIST_ENTRY *)NULL;
d105 3
d109 2
a110 1
  history_set_pos (pos);
d112 1
d117 1
d139 1
a139 1
      ding ();
d147 1
a147 1
      maybe_unsave_line ();
d150 1
a150 1
      ding ();
d167 2
d182 1
a182 1
  int saved_point, c;
d184 3
d188 1
a188 1
  maybe_save_line ();
d190 1
d200 1
a200 1
#define SEARCH_RETURN rl_restore_prompt (); return
d202 1
d204 1
a204 1
  while (c = rl_read_key ())
d206 12
d224 1
a224 1
	      maybe_unsave_line ();
d227 1
d230 1
a230 1
	  rl_rubout (1, c);
d249 1
a249 1
	  maybe_unsave_line ();
d252 2
a253 1
	  ding ();
d257 6
a262 1
	  rl_insert (1, c);
d269 2
d278 1
a278 1
	  ding ();
d292 1
d323 1
a323 1
      ding ();
d338 1
a338 1
      ding ();
d352 1
a352 1
  maybe_save_line ();
d381 2
a382 2
      maybe_unsave_line ();
      ding ();
d391 1
d394 2
a395 1
      rl_point = rl_history_search_len;	/* maybe_unsave_line changes it */
d404 2
d420 1
a420 1
	  history_search_string = xrealloc (history_search_string, history_string_size);
d426 1
@


1.3.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a42 2
#include "rlmbutil.h"

d54 1
a54 1
extern HIST_ENTRY *_rl_saved_line_for_history;
d57 1
a57 1
extern int _rl_free_history_entry PARAMS((HIST_ENTRY *));
a68 7
static void make_history_line_current PARAMS((HIST_ENTRY *));
static int noninc_search_from_pos PARAMS((char *, int, int));
static void noninc_dosearch PARAMS((char *, int));
static void noninc_search PARAMS((int, int));
static int rl_history_search_internal PARAMS((int, int));
static void rl_history_search_reinit PARAMS((void));

d76 7
a82 1
  rl_replace_line (entry->line, 0);
d84 1
d86 3
a88 3
  if (_rl_saved_line_for_history)
    _rl_free_history_entry (_rl_saved_line_for_history);
  _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
a102 3
  if (pos < 0)
    return -1;

d104 1
a104 2
  if (history_set_pos (pos) == 0)
    return -1;
a105 1
  RL_SETSTATE(RL_STATE_SEARCH);
a109 1
  RL_UNSETSTATE(RL_STATE_SEARCH);
d131 1
a131 1
      rl_ding ();
d139 1
a139 1
      rl_maybe_unsave_line ();
d142 1
a142 1
      rl_ding ();
a158 2
  rl_mark = rl_end;

d172 1
a172 1
  int saved_point, saved_mark, c;
a173 3
#if defined (HANDLE_MULTIBYTE)
  char mb[MB_LEN_MAX];
#endif
d175 1
a175 1
  rl_maybe_save_line ();
a176 1
  saved_mark = rl_mark;
d186 1
a186 1
#define SEARCH_RETURN rl_restore_prompt (); RL_UNSETSTATE(RL_STATE_NSEARCH); return
a187 1
  RL_SETSTATE(RL_STATE_NSEARCH);
d189 1
a189 1
  while (1)
a190 12
      RL_SETSTATE(RL_STATE_MOREINPUT);
      c = rl_read_key ();
      RL_UNSETSTATE(RL_STATE_MOREINPUT);

#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	c = _rl_read_mbstring (c, mb, MB_LEN_MAX);
#endif

      if (c == 0)
	break;

d197 1
a197 1
	      rl_maybe_unsave_line ();
a199 1
	      rl_mark = saved_mark;
d202 1
a202 1
	  _rl_rubout_char (1, c);
d221 1
a221 1
	  rl_maybe_unsave_line ();
d224 1
a224 2
	  rl_mark = saved_mark;
	  rl_ding ();
d228 1
a228 6
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    rl_insert_text (mb);
	  else
#endif
	    _rl_insert_char (1, c);
a234 2
  rl_mark = saved_mark;

d242 1
a242 1
	  rl_ding ();
a255 1
  RL_UNSETSTATE(RL_STATE_NSEARCH);
d286 1
a286 1
      rl_ding ();
d301 1
a301 1
      rl_ding ();
d315 1
a315 1
  rl_maybe_save_line ();
d344 2
a345 2
      rl_maybe_unsave_line ();
      rl_ding ();
a353 1
          rl_mark = 0;
d356 1
a356 2
      rl_point = rl_history_search_len;	/* rl_maybe_unsave_line changes it */
      rl_mark = rl_end;
a364 2
  rl_mark = rl_end;

d379 1
a379 1
	  history_search_string = (char *)xrealloc (history_search_string, history_string_size);
a384 1
  _rl_free_saved_history_line ();
@


1.3.22.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a42 2
#include "rlmbutil.h"

d54 1
a54 1
extern HIST_ENTRY *_rl_saved_line_for_history;
d57 1
a57 1
extern int _rl_free_history_entry PARAMS((HIST_ENTRY *));
a68 7
static void make_history_line_current PARAMS((HIST_ENTRY *));
static int noninc_search_from_pos PARAMS((char *, int, int));
static void noninc_dosearch PARAMS((char *, int));
static void noninc_search PARAMS((int, int));
static int rl_history_search_internal PARAMS((int, int));
static void rl_history_search_reinit PARAMS((void));

d76 7
a82 1
  rl_replace_line (entry->line, 0);
d84 1
d86 3
a88 3
  if (_rl_saved_line_for_history)
    _rl_free_history_entry (_rl_saved_line_for_history);
  _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
a102 3
  if (pos < 0)
    return -1;

d104 1
a104 2
  if (history_set_pos (pos) == 0)
    return -1;
a105 1
  RL_SETSTATE(RL_STATE_SEARCH);
a109 1
  RL_UNSETSTATE(RL_STATE_SEARCH);
d131 1
a131 1
      rl_ding ();
d139 1
a139 1
      rl_maybe_unsave_line ();
d142 1
a142 1
      rl_ding ();
a158 2
  rl_mark = rl_end;

d172 1
a172 1
  int saved_point, saved_mark, c;
a173 3
#if defined (HANDLE_MULTIBYTE)
  char mb[MB_LEN_MAX];
#endif
d175 1
a175 1
  rl_maybe_save_line ();
a176 1
  saved_mark = rl_mark;
d186 1
a186 1
#define SEARCH_RETURN rl_restore_prompt (); RL_UNSETSTATE(RL_STATE_NSEARCH); return
a187 1
  RL_SETSTATE(RL_STATE_NSEARCH);
d189 1
a189 1
  while (1)
a190 12
      RL_SETSTATE(RL_STATE_MOREINPUT);
      c = rl_read_key ();
      RL_UNSETSTATE(RL_STATE_MOREINPUT);

#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	c = _rl_read_mbstring (c, mb, MB_LEN_MAX);
#endif

      if (c == 0)
	break;

d197 1
a197 1
	      rl_maybe_unsave_line ();
a199 1
	      rl_mark = saved_mark;
d202 1
a202 1
	  _rl_rubout_char (1, c);
d221 1
a221 1
	  rl_maybe_unsave_line ();
d224 1
a224 2
	  rl_mark = saved_mark;
	  rl_ding ();
d228 1
a228 6
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    rl_insert_text (mb);
	  else
#endif
	    _rl_insert_char (1, c);
a234 2
  rl_mark = saved_mark;

d242 1
a242 1
	  rl_ding ();
a255 1
  RL_UNSETSTATE(RL_STATE_NSEARCH);
d286 1
a286 1
      rl_ding ();
d301 1
a301 1
      rl_ding ();
d315 1
a315 1
  rl_maybe_save_line ();
d344 2
a345 2
      rl_maybe_unsave_line ();
      rl_ding ();
a353 1
          rl_mark = 0;
d356 1
a356 2
      rl_point = rl_history_search_len;	/* rl_maybe_unsave_line changes it */
      rl_mark = rl_end;
a364 2
  rl_mark = rl_end;

d379 1
a379 1
	  history_search_string = (char *)xrealloc (history_search_string, history_string_size);
a384 1
  _rl_free_saved_history_line ();
@


1.3.16.1
log
@2002-08-24  Elena Zannoni  <ezannoni@@redhat.com>

        Import of readline 4.3:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@a42 2
#include "rlmbutil.h"

d54 1
a54 1
extern HIST_ENTRY *_rl_saved_line_for_history;
d57 1
a57 1
extern int _rl_free_history_entry PARAMS((HIST_ENTRY *));
a68 7
static void make_history_line_current PARAMS((HIST_ENTRY *));
static int noninc_search_from_pos PARAMS((char *, int, int));
static void noninc_dosearch PARAMS((char *, int));
static void noninc_search PARAMS((int, int));
static int rl_history_search_internal PARAMS((int, int));
static void rl_history_search_reinit PARAMS((void));

d76 7
a82 1
  rl_replace_line (entry->line, 0);
d84 1
d86 3
a88 3
  if (_rl_saved_line_for_history)
    _rl_free_history_entry (_rl_saved_line_for_history);
  _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
a102 3
  if (pos < 0)
    return -1;

d104 1
a104 2
  if (history_set_pos (pos) == 0)
    return -1;
a105 1
  RL_SETSTATE(RL_STATE_SEARCH);
a109 1
  RL_UNSETSTATE(RL_STATE_SEARCH);
d131 1
a131 1
      rl_ding ();
d139 1
a139 1
      rl_maybe_unsave_line ();
d142 1
a142 1
      rl_ding ();
a158 2
  rl_mark = rl_end;

d172 1
a172 1
  int saved_point, saved_mark, c;
a173 3
#if defined (HANDLE_MULTIBYTE)
  char mb[MB_LEN_MAX];
#endif
d175 1
a175 1
  rl_maybe_save_line ();
a176 1
  saved_mark = rl_mark;
d186 1
a186 1
#define SEARCH_RETURN rl_restore_prompt (); RL_UNSETSTATE(RL_STATE_NSEARCH); return
a187 1
  RL_SETSTATE(RL_STATE_NSEARCH);
d189 1
a189 1
  while (1)
a190 12
      RL_SETSTATE(RL_STATE_MOREINPUT);
      c = rl_read_key ();
      RL_UNSETSTATE(RL_STATE_MOREINPUT);

#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	c = _rl_read_mbstring (c, mb, MB_LEN_MAX);
#endif

      if (c == 0)
	break;

d197 1
a197 1
	      rl_maybe_unsave_line ();
a199 1
	      rl_mark = saved_mark;
d202 1
a202 1
	  _rl_rubout_char (1, c);
d221 1
a221 1
	  rl_maybe_unsave_line ();
d224 1
a224 2
	  rl_mark = saved_mark;
	  rl_ding ();
d228 1
a228 6
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    rl_insert_text (mb);
	  else
#endif
	    _rl_insert_char (1, c);
a234 2
  rl_mark = saved_mark;

d242 1
a242 1
	  rl_ding ();
a255 1
  RL_UNSETSTATE(RL_STATE_NSEARCH);
d286 1
a286 1
      rl_ding ();
d301 1
a301 1
      rl_ding ();
d315 1
a315 1
  rl_maybe_save_line ();
d344 2
a345 2
      rl_maybe_unsave_line ();
      rl_ding ();
a353 1
          rl_mark = 0;
d356 1
a356 2
      rl_point = rl_history_search_len;	/* rl_maybe_unsave_line changes it */
      rl_mark = rl_end;
a364 2
  rl_mark = rl_end;

d379 1
a379 1
	  history_search_string = (char *)xrealloc (history_search_string, history_string_size);
a384 1
  _rl_free_saved_history_line ();
@


1.2
log
@Dummy commit before importof 4.1 version
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 1, or (at your option)
d22 1
a22 1
   675 Mass Ave, Cambridge, MA 02139, USA. */
d46 3
a53 7
extern char *xmalloc (), *xrealloc ();

/* Variables imported from readline.c */
extern int rl_point, rl_end, rl_line_buffer_len;
extern int rl_editing_mode;
extern char *rl_prompt;
extern char *rl_line_buffer;
a54 1
extern Function *rl_last_func;
d57 1
a57 3
extern int _rl_free_history_entry ();
extern char *_rl_make_prompt_for_search ();
extern void rl_extend_line_buffer ();
d61 1
d64 27
d126 1
a126 1
  int oldpos, pos, line_len;
d156 1
a156 4
  line_len = strlen (entry->line);
  if (line_len >= rl_line_buffer_len)
    rl_extend_line_buffer (line_len);
  strcpy (rl_line_buffer, entry->line);
a157 2
  rl_undo_list = (UNDO_LIST *)entry->data;
  rl_end = strlen (rl_line_buffer);
a159 4

  if (saved_line_for_history)
    _rl_free_history_entry (saved_line_for_history);
  saved_line_for_history = (HIST_ENTRY *)NULL;
d250 1
a250 2
      if (noninc_search_string)
	free (noninc_search_string);
d309 2
a310 2
rl_history_search_internal (count, direction)
     int count, direction;
d312 2
a313 2
  HIST_ENTRY *temp, *old_temp;
  int line_len;
d316 1
d318 3
a320 1
  temp = old_temp = (HIST_ENTRY *)NULL;
d323 16
a338 19
      temp = (direction < 0) ? previous_history () : next_history ();
      if (temp == 0)
        break;
      /* On an empty prefix, make this the same as previous-history. */
      if (rl_point == 0)
	{
	  count--;
	  continue;
	}
      if (STREQN (rl_line_buffer, temp->line, rl_point))
	{
	  /* Don't find multiple instances of the same line. */
	  if (prev_line_found && STREQ (prev_line_found, temp->line))
	    continue;
          if (direction < 0)
            old_temp = temp;
          prev_line_found = temp->line;
          count--;
	}
d341 1
d344 33
a376 3
      if (direction < 0 && old_temp)
	temp = old_temp;
      else
d378 2
a379 3
	  maybe_unsave_line ();
	  ding ();
	  return 1;
d381 3
a384 8

  line_len = strlen (temp->line);
  if (line_len >= rl_line_buffer_len)
    rl_extend_line_buffer (line_len);
  strcpy (rl_line_buffer, temp->line);
  rl_undo_list = (UNDO_LIST *)temp->data;
  rl_end = line_len;
  return 0;
d396 7
a402 2
  if (rl_last_func != rl_history_search_forward)
    prev_line_found = (char *)NULL;
d415 7
a421 2
  if (rl_last_func != rl_history_search_backward)
    prev_line_found = (char *)NULL;
@


1.1
log
@Initial revision
@
text
@a63 1
extern void _rl_restore_prompt ();
d174 1
a174 1
#define SEARCH_RETURN _rl_restore_prompt (); return
d243 1
a243 1
  _rl_restore_prompt ();
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-08-02 snapshot
@
text
@d64 1
d175 1
a175 1
#define SEARCH_RETURN rl_restore_prompt (); return
d244 1
a244 1
  rl_restore_prompt ();
@


1.1.1.3
log
@Import of readline 4.1
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2, or (at your option)
d22 1
a22 1
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
a45 3
#include "rlprivate.h"
#include "xmalloc.h"

d51 7
d59 1
d62 3
a64 1
extern int _rl_free_history_entry __P((HIST_ENTRY *));
a67 1

a69 27
static int rl_history_search_len;
static int rl_history_search_pos;
static char *history_search_string;
static int history_string_size;

/* Make the data from the history entry ENTRY be the contents of the
   current line.  This doesn't do anything with rl_point; the caller
   must set it. */
static void
make_history_line_current (entry)
     HIST_ENTRY *entry;
{
  int line_len;

  line_len = strlen (entry->line);
  if (line_len >= rl_line_buffer_len)
    rl_extend_line_buffer (line_len);
  strcpy (rl_line_buffer, entry->line);

  rl_undo_list = (UNDO_LIST *)entry->data;
  rl_end = line_len;

  if (saved_line_for_history)
    _rl_free_history_entry (saved_line_for_history);
  saved_line_for_history = (HIST_ENTRY *)NULL;
}

d105 1
a105 1
  int oldpos, pos;
d135 4
a138 1
  make_history_line_current (entry);
d140 2
d144 4
d238 2
a239 1
      FREE (noninc_search_string);
d298 2
a299 2
rl_history_search_internal (count, dir)
     int count, dir;
d301 2
a302 2
  HIST_ENTRY *temp;
  int ret, oldpos;
a304 1
  temp = (HIST_ENTRY *)NULL;
d306 1
a306 3
  /* Search COUNT times through the history for a line whose prefix
     matches history_search_string.  When this loop finishes, TEMP,
     if non-null, is the history line to copy into the line buffer. */
d309 19
a327 16
      ret = noninc_search_from_pos (history_search_string, rl_history_search_pos + dir, dir);
      if (ret == -1)
	break;

      /* Get the history entry we found. */
      rl_history_search_pos = ret;
      oldpos = where_history ();
      history_set_pos (rl_history_search_pos);
      temp = current_history ();
      history_set_pos (oldpos);

      /* Don't find multiple instances of the same line. */
      if (prev_line_found && STREQ (prev_line_found, temp->line))
        continue;
      prev_line_found = temp->line;
      count--;
a329 1
  /* If we didn't find anything at all, return. */
d332 8
a339 15
      maybe_unsave_line ();
      ding ();
      /* If you don't want the saved history line (last match) to show up
         in the line buffer after the search fails, change the #if 0 to
         #if 1 */
#if 0
      if (rl_point > rl_history_search_len)
        {
          rl_point = rl_end = rl_history_search_len;
          rl_line_buffer[rl_end] = '\0';
        }
#else
      rl_point = rl_history_search_len;	/* maybe_unsave_line changes it */
#endif
      return 1;
d342 6
a347 4
  /* Copy the line we found into the current line buffer. */
  make_history_line_current (temp);

  rl_point = rl_history_search_len;
a350 19
static void
rl_history_search_reinit ()
{
  rl_history_search_pos = where_history ();
  rl_history_search_len = rl_point;
  prev_line_found = (char *)NULL;
  if (rl_point)
    {
      if (rl_history_search_len >= history_string_size - 2)
	{
	  history_string_size = rl_history_search_len + 2;
	  history_search_string = xrealloc (history_search_string, history_string_size);
	}
      history_search_string[0] = '^';
      strncpy (history_search_string + 1, rl_line_buffer, rl_point);
      history_search_string[rl_point + 1] = '\0';
    }
}

d360 2
a361 7

  if (rl_last_func != rl_history_search_forward &&
      rl_last_func != rl_history_search_backward)
    rl_history_search_reinit ();

  if (rl_history_search_len == 0)
    return (rl_get_next_history (count, ignore));
d374 2
a375 7

  if (rl_last_func != rl_history_search_forward &&
      rl_last_func != rl_history_search_backward)
    rl_history_search_reinit ();

  if (rl_history_search_len == 0)
    return (rl_get_previous_history (count, ignore));
@


1.1.1.4
log
@import of readline-4.3
@
text
@a42 2
#include "rlmbutil.h"

d54 1
a54 1
extern HIST_ENTRY *_rl_saved_line_for_history;
d57 1
a57 1
extern int _rl_free_history_entry PARAMS((HIST_ENTRY *));
a68 7
static void make_history_line_current PARAMS((HIST_ENTRY *));
static int noninc_search_from_pos PARAMS((char *, int, int));
static void noninc_dosearch PARAMS((char *, int));
static void noninc_search PARAMS((int, int));
static int rl_history_search_internal PARAMS((int, int));
static void rl_history_search_reinit PARAMS((void));

d76 7
a82 1
  rl_replace_line (entry->line, 0);
d84 1
d86 3
a88 3
  if (_rl_saved_line_for_history)
    _rl_free_history_entry (_rl_saved_line_for_history);
  _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
a102 3
  if (pos < 0)
    return -1;

d104 1
a104 2
  if (history_set_pos (pos) == 0)
    return -1;
a105 1
  RL_SETSTATE(RL_STATE_SEARCH);
a109 1
  RL_UNSETSTATE(RL_STATE_SEARCH);
d131 1
a131 1
      rl_ding ();
d139 1
a139 1
      rl_maybe_unsave_line ();
d142 1
a142 1
      rl_ding ();
a158 2
  rl_mark = rl_end;

d172 1
a172 1
  int saved_point, saved_mark, c;
a173 3
#if defined (HANDLE_MULTIBYTE)
  char mb[MB_LEN_MAX];
#endif
d175 1
a175 1
  rl_maybe_save_line ();
a176 1
  saved_mark = rl_mark;
d186 1
a186 1
#define SEARCH_RETURN rl_restore_prompt (); RL_UNSETSTATE(RL_STATE_NSEARCH); return
a187 1
  RL_SETSTATE(RL_STATE_NSEARCH);
d189 1
a189 1
  while (1)
a190 12
      RL_SETSTATE(RL_STATE_MOREINPUT);
      c = rl_read_key ();
      RL_UNSETSTATE(RL_STATE_MOREINPUT);

#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	c = _rl_read_mbstring (c, mb, MB_LEN_MAX);
#endif

      if (c == 0)
	break;

d197 1
a197 1
	      rl_maybe_unsave_line ();
a199 1
	      rl_mark = saved_mark;
d202 1
a202 1
	  _rl_rubout_char (1, c);
d221 1
a221 1
	  rl_maybe_unsave_line ();
d224 1
a224 2
	  rl_mark = saved_mark;
	  rl_ding ();
d228 1
a228 6
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    rl_insert_text (mb);
	  else
#endif
	    _rl_insert_char (1, c);
a234 2
  rl_mark = saved_mark;

d242 1
a242 1
	  rl_ding ();
a255 1
  RL_UNSETSTATE(RL_STATE_NSEARCH);
d286 1
a286 1
      rl_ding ();
d301 1
a301 1
      rl_ding ();
d315 1
a315 1
  rl_maybe_save_line ();
d344 2
a345 2
      rl_maybe_unsave_line ();
      rl_ding ();
a353 1
          rl_mark = 0;
d356 1
a356 2
      rl_point = rl_history_search_len;	/* rl_maybe_unsave_line changes it */
      rl_mark = rl_end;
a364 2
  rl_mark = rl_end;

d379 1
a379 1
	  history_search_string = (char *)xrealloc (history_search_string, history_string_size);
a384 1
  _rl_free_saved_history_line ();
@


1.1.1.5
log
@import of readlilne 5.1
@
text
@d3 1
a3 1
/* Copyright (C) 1992-2005 Free Software Foundation, Inc.
a55 2
_rl_search_cxt *_rl_nscxt = 0;

a70 1
static UNDO_LIST *noninc_saved_undo_list;
d73 2
a74 2
static int noninc_dosearch PARAMS((char *, int));
static int noninc_search PARAMS((int, int));
a77 5
static _rl_search_cxt *_rl_nsearch_init PARAMS((int, int));
static int _rl_nsearch_cleanup PARAMS((_rl_search_cxt *, int));
static void _rl_nsearch_abort PARAMS((_rl_search_cxt *));
static int _rl_nsearch_dispatch PARAMS((_rl_search_cxt *, int));

d85 2
a86 10
  _rl_replace_text (entry->line, 0, rl_end);
  _rl_fix_point (1);
#if defined (VI_MODE)
  if (rl_editing_mode == vi_mode)
    /* POSIX.2 says that the `U' command doesn't affect the copy of any
       command lines to the edit line.  We're going to implement that by
       making the undo list start after the matching line is copied to the
       current editing buffer. */
    rl_free_undo_list ();
#endif
d128 2
a129 2
   entries.  Returns 1 if the search was successful, 0 otherwise. */
static int
d140 1
a140 1
      return 0;
d151 1
a151 1
      return 0;
d162 1
a162 1
    history_set_pos (oldpos);
a169 1
  return 1;
d172 9
a180 3
static _rl_search_cxt *
_rl_nsearch_init (dir, pchar)
     int dir, pchar;
d182 1
a182 1
  _rl_search_cxt *cxt;
d184 3
a186 7

  cxt = _rl_scxt_alloc (RL_SEARCH_NSEARCH, 0);
  if (dir < 0)
    cxt->sflags |= SF_REVERSE;		/* not strictly needed */

  cxt->direction = dir;
  cxt->history_pos = cxt->save_line;
d189 2
a190 5

  /* Clear the undo list, since reading the search string should create its
     own undo list, and the whole list will end up being freed when we
     finish reading the search string. */
  rl_undo_list = 0;
d200 2
d203 6
d210 4
a213 1
  _rl_nscxt = cxt;
d215 2
a216 25
  return cxt;
}

static int
_rl_nsearch_cleanup (cxt, r)
     _rl_search_cxt *cxt;
     int r;
{
  _rl_scxt_dispose (cxt, 0);
  _rl_nscxt = 0;

  RL_UNSETSTATE(RL_STATE_NSEARCH);

  return (r != 1);
}

static void
_rl_nsearch_abort (cxt)
     _rl_search_cxt *cxt;
{
  rl_maybe_unsave_line ();
  rl_clear_message ();
  rl_point = cxt->save_point;
  rl_mark = cxt->save_mark;
  rl_restore_prompt ();
d218 1
a218 28
  RL_UNSETSTATE (RL_STATE_NSEARCH);
}

/* Process just-read character C according to search context CXT.  Return -1
   if the caller should abort the search, 0 if we should break out of the
   loop, and 1 if we should continue to read characters. */
static int
_rl_nsearch_dispatch (cxt, c)
     _rl_search_cxt *cxt;
     int c;
{
  switch (c)
    {
    case CTRL('W'):
      rl_unix_word_rubout (1, c);
      break;

    case CTRL('U'):
      rl_unix_line_discard (1, c);
      break;

    case RETURN:
    case NEWLINE:
      return 0;

    case CTRL('H'):
    case RUBOUT:
      if (rl_point == 0)
d220 35
a254 11
	  _rl_nsearch_abort (cxt);
	  return -1;
	}
      _rl_rubout_char (1, c);
      break;

    case CTRL('C'):
    case CTRL('G'):
      rl_ding ();
      _rl_nsearch_abort (cxt);
      return -1;
d256 1
a256 1
    default:
d258 3
a260 3
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_insert_text (cxt->mb);
      else
d262 4
a265 2
	_rl_insert_char (1, c);
      break;
d268 2
a269 13
  (*rl_redisplay_function) ();
  return 1;
}

/* Perform one search according to CXT, using NONINC_SEARCH_STRING.  Return
   -1 if the search should be aborted, any other value means to clean up
   using _rl_nsearch_cleanup ().  Returns 1 if the search was successful,
   0 otherwise. */
static int
_rl_nsearch_dosearch (cxt)
     _rl_search_cxt *cxt;
{
  rl_mark = cxt->save_mark;
d276 1
a276 1
      if (noninc_search_string == 0)
d279 1
a279 3
	  rl_restore_prompt ();
	  RL_UNSETSTATE (RL_STATE_NSEARCH);
	  return -1;
d285 1
a285 1
      noninc_history_pos = cxt->save_line;
a287 7

      /* If we don't want the subsequent undo list generated by the search
	 matching a history line to include the contents of the search string,
	 we need to clear rl_line_buffer here.  For now, we just clear the
	 undo list generated by reading the search string.  (If the search
	 fails, the old undo list will be restored by rl_maybe_unsave_line.) */
      rl_free_undo_list ();
d291 2
a292 39
  return (noninc_dosearch (noninc_search_string, cxt->direction));
}

/* Search non-interactively through the history list.  DIR < 0 means to
   search backwards through the history of previous commands; otherwise
   the search is for commands subsequent to the current position in the
   history list.  PCHAR is the character to use for prompting when reading
   the search string; if not specified (0), it defaults to `:'. */
static int
noninc_search (dir, pchar)
     int dir;
     int pchar;
{
  _rl_search_cxt *cxt;
  int c, r;

  cxt = _rl_nsearch_init (dir, pchar);

  if (RL_ISSTATE (RL_STATE_CALLBACK))
    return (0);

  /* Read the search string. */
  r = 0;
  while (1)
    {
      c = _rl_search_getchar (cxt);

      if (c == 0)
	break;

      r = _rl_nsearch_dispatch (cxt, c);
      if (r < 0)
        return 1;
      else if (r == 0)
	break;        
    }

  r = _rl_nsearch_dosearch (cxt);
  return ((r >= 0) ? _rl_nsearch_cleanup (cxt, r) : (r != 1));
d301 2
a302 1
  return noninc_search (1, (key == '?') ? '?' : 0);
d311 2
a312 1
  return noninc_search (-1, (key == '/') ? '/' : 0);
a320 2
  int r;

d326 2
a327 2
  r = noninc_dosearch (noninc_search_string, 1);
  return (r != 1);
a335 2
  int r;

d341 2
a342 2
  r = noninc_dosearch (noninc_search_string, -1);
  return (r != 1);
a344 17
#if defined (READLINE_CALLBACKS)
int
_rl_nsearch_callback (cxt)
     _rl_search_cxt *cxt;
{
  int c, r;

  c = _rl_search_getchar (cxt);
  r = _rl_nsearch_dispatch (cxt, c);
  if (r != 0)
    return 1;

  r = _rl_nsearch_dosearch (cxt);
  return ((r >= 0) ? _rl_nsearch_cleanup (cxt, r) : (r != 1));
}
#endif
  
@


