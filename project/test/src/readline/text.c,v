head	1.6;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.6
	gdb_7_6-2013-04-26-release:1.6
	gdb_7_6-branch:1.6.0.6
	gdb_7_6-2013-03-12-branchpoint:1.6
	gdb_7_5_1-2012-11-29-release:1.6
	gdb_7_5-2012-08-17-release:1.6
	gdb_7_5-branch:1.6.0.4
	gdb_7_5-2012-07-18-branchpoint:1.6
	gdb_7_4_1-2012-04-26-release:1.6
	gdb_7_4-2012-01-24-release:1.6
	gdb_7_4-branch:1.6.0.2
	gdb_7_4-2011-12-13-branchpoint:1.6
	gdb_7_3_1-2011-09-04-release:1.5
	gdb_7_3-2011-07-26-release:1.5
	gdb_7_3-branch:1.5.0.36
	gdb_7_3-2011-04-01-branchpoint:1.5
	gdb_7_2-2010-09-02-release:1.5
	gdb_7_2-branch:1.5.0.34
	gdb_7_2-2010-07-07-branchpoint:1.5
	gdb_7_1-2010-03-18-release:1.5
	gdb_7_1-branch:1.5.0.32
	gdb_7_1-2010-02-18-branchpoint:1.5
	gdb_7_0_1-2009-12-22-release:1.5
	gdb_7_0-2009-10-06-release:1.5
	gdb_7_0-branch:1.5.0.30
	gdb_7_0-2009-09-16-branchpoint:1.5
	arc-sim-20090309:1.5
	msnyder-checkpoint-072509-branch:1.5.0.28
	msnyder-checkpoint-072509-branchpoint:1.5
	arc-insight_6_8-branch:1.5.0.26
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.24
	insight_6_8-branchpoint:1.5
	reverse-20081226-branch:1.5.0.22
	reverse-20081226-branchpoint:1.5
	multiprocess-20081120-branch:1.5.0.20
	multiprocess-20081120-branchpoint:1.5
	reverse-20080930-branch:1.5.0.18
	reverse-20080930-branchpoint:1.5
	reverse-20080717-branch:1.5.0.16
	reverse-20080717-branchpoint:1.5
	msnyder-reverse-20080609-branch:1.5.0.14
	msnyder-reverse-20080609-branchpoint:1.5
	drow-reverse-20070409-branch:1.5.0.12
	drow-reverse-20070409-branchpoint:1.5
	gdb_6_8-2008-03-27-release:1.5
	gdb_6_8-branch:1.5.0.10
	gdb_6_8-2008-02-26-branchpoint:1.5
	gdb_6_7_1-2007-10-29-release:1.5
	gdb_6_7-2007-10-10-release:1.5
	gdb_6_7-branch:1.5.0.8
	gdb_6_7-2007-09-07-branchpoint:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-2006-12-18-release:1.5
	gdb_6_6-branch:1.5.0.6
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb-csl-symbian-6_4_50_20060226-12:1.3
	gdb-csl-sourcerygxx-3_4_4-25:1.3
	nickrob-async-20060828-mergepoint:1.5
	gdb-csl-symbian-6_4_50_20060226-11:1.3
	gdb-csl-sourcerygxx-4_1-17:1.3
	gdb-csl-20060226-branch-local-2:1.3
	gdb-csl-sourcerygxx-4_1-14:1.3
	gdb-csl-sourcerygxx-4_1-13:1.3
	gdb-csl-sourcerygxx-4_1-12:1.3
	gdb-csl-sourcerygxx-3_4_4-21:1.3
	gdb_6_5-20060621-release:1.5
	gdb-csl-sourcerygxx-4_1-9:1.3
	gdb-csl-sourcerygxx-4_1-8:1.3
	gdb-csl-sourcerygxx-4_1-7:1.3
	gdb-csl-arm-2006q1-6:1.3
	gdb-csl-sourcerygxx-4_1-6:1.3
	gdb-csl-symbian-6_4_50_20060226-10:1.3
	gdb-csl-symbian-6_4_50_20060226-9:1.3
	gdb-csl-symbian-6_4_50_20060226-8:1.3
	gdb-csl-coldfire-4_1-11:1.3
	gdb-csl-sourcerygxx-3_4_4-19:1.3
	gdb-csl-coldfire-4_1-10:1.3
	gdb_6_5-branch:1.5.0.4
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb-csl-sourcerygxx-4_1-5:1.3
	nickrob-async-20060513-branch:1.5.0.2
	nickrob-async-20060513-branchpoint:1.5
	gdb-csl-sourcerygxx-4_1-4:1.3
	msnyder-reverse-20060502-branch:1.4.0.4
	msnyder-reverse-20060502-branchpoint:1.4
	gdb-csl-morpho-4_1-4:1.3
	gdb-csl-sourcerygxx-3_4_4-17:1.3
	readline_5_1-import-branch:1.4.0.2
	readline_5_1-import-branchpoint:1.4
	readline-pre-51-import:1.4
	readline_5_1:1.1.1.2
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.3
	gdb-csl-symbian-20060226-branch:1.3.0.82
	gdb-csl-symbian-20060226-branchpoint:1.3
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.3
	msnyder-reverse-20060331-branch:1.3.0.80
	msnyder-reverse-20060331-branchpoint:1.3
	gdb-csl-available-20060303-branch:1.3.0.78
	gdb-csl-available-20060303-branchpoint:1.3
	gdb-csl-20060226-branch:1.3.0.76
	gdb-csl-20060226-branchpoint:1.3
	gdb_6_4-20051202-release:1.3
	msnyder-fork-checkpoint-branch:1.3.0.74
	msnyder-fork-checkpoint-branchpoint:1.3
	gdb-csl-gxxpro-6_3-branch:1.3.0.72
	gdb-csl-gxxpro-6_3-branchpoint:1.3
	gdb_6_4-branch:1.3.0.70
	gdb_6_4-2005-11-01-branchpoint:1.3
	gdb-csl-arm-20051020-branch:1.3.0.68
	gdb-csl-arm-20051020-branchpoint:1.3
	msnyder-tracepoint-checkpoint-branch:1.3.0.66
	msnyder-tracepoint-checkpoint-branchpoint:1.3
	gdb-csl-arm-20050325-2005-q1b:1.3
	gdb-csl-arm-20050325-2005-q1a:1.3
	csl-arm-20050325-branch:1.3.0.64
	csl-arm-20050325-branchpoint:1.3
	gdb_6_3-20041109-release:1.3
	gdb_6_3-branch:1.3.0.60
	gdb_6_3-20041019-branchpoint:1.3
	drow_intercu-merge-20040921:1.3
	drow_intercu-merge-20040915:1.3
	jimb-gdb_6_2-e500-branch:1.3.0.62
	jimb-gdb_6_2-e500-branchpoint:1.3
	gdb_6_2-20040730-release:1.3
	gdb_6_2-branch:1.3.0.58
	gdb_6_2-2004-07-10-gmt-branchpoint:1.3
	gdb_6_1_1-20040616-release:1.3
	gdb_6_1-2004-04-05-release:1.3
	drow_intercu-merge-20040402:1.3
	drow_intercu-merge-20040327:1.3
	ezannoni_pie-20040323-branch:1.3.0.56
	ezannoni_pie-20040323-branchpoint:1.3
	cagney_tramp-20040321-mergepoint:1.3
	cagney_tramp-20040309-branch:1.3.0.54
	cagney_tramp-20040309-branchpoint:1.3
	gdb_6_1-branch:1.3.0.52
	gdb_6_1-2004-03-01-gmt-branchpoint:1.3
	drow_intercu-20040221-branch:1.3.0.50
	drow_intercu-20040221-branchpoint:1.3
	cagney_bfdfile-20040213-branch:1.3.0.48
	cagney_bfdfile-20040213-branchpoint:1.3
	drow-cplus-merge-20040208:1.3
	carlton_dictionary-20040126-merge:1.3
	cagney_bigcore-20040122-branch:1.3.0.46
	cagney_bigcore-20040122-branchpoint:1.3
	drow-cplus-merge-20040113:1.3
	drow-cplus-merge-20031224:1.3
	drow-cplus-merge-20031220:1.3
	carlton_dictionary-20031215-merge:1.3
	drow-cplus-branch:1.3.0.44
	drow-cplus-merge-20031214:1.3
	carlton-dictionary-20031111-merge:1.3
	gdb_6_0-2003-10-04-release:1.3
	kettenis_sparc-20030918-branch:1.3.0.42
	kettenis_sparc-20030918-branchpoint:1.3
	carlton_dictionary-20030917-merge:1.3
	ezannoni_pie-20030916-branchpoint:1.3
	ezannoni_pie-20030916-branch:1.3.0.40
	cagney_x86i386-20030821-branch:1.3.0.38
	cagney_x86i386-20030821-branchpoint:1.3
	carlton_dictionary-20030805-merge:1.3
	carlton_dictionary-20030627-merge:1.3
	gdb_6_0-branch:1.3.0.36
	gdb_6_0-2003-06-23-branchpoint:1.3
	jimb-ppc64-linux-20030613-branch:1.3.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.3
	cagney_convert-20030606-branch:1.3.0.32
	cagney_convert-20030606-branchpoint:1.3
	cagney_writestrings-20030508-branch:1.3.0.30
	cagney_writestrings-20030508-branchpoint:1.3
	jimb-ppc64-linux-20030528-branch:1.3.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.3
	carlton_dictionary-20030523-merge:1.3
	cagney_fileio-20030521-branch:1.3.0.26
	cagney_fileio-20030521-branchpoint:1.3
	kettenis_i386newframe-20030517-mergepoint:1.3
	jimb-ppc64-linux-20030509-branch:1.3.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.3
	kettenis_i386newframe-20030504-mergepoint:1.3
	carlton_dictionary-20030430-merge:1.3
	kettenis_i386newframe-20030419-branch:1.3.0.22
	kettenis_i386newframe-20030419-branchpoint:1.3
	carlton_dictionary-20030416-merge:1.3
	cagney_frameaddr-20030409-mergepoint:1.3
	kettenis_i386newframe-20030406-branch:1.3.0.20
	kettenis_i386newframe-20030406-branchpoint:1.3
	cagney_frameaddr-20030403-branchpoint:1.3
	cagney_frameaddr-20030403-branch:1.3.0.18
	cagney_framebase-20030330-mergepoint:1.3
	cagney_framebase-20030326-branch:1.3.0.16
	cagney_framebase-20030326-branchpoint:1.3
	cagney_lazyid-20030317-branch:1.3.0.14
	cagney_lazyid-20030317-branchpoint:1.3
	kettenis-i386newframe-20030316-mergepoint:1.3
	offbyone-20030313-branch:1.3.0.12
	offbyone-20030313-branchpoint:1.3
	kettenis-i386newframe-20030308-branch:1.3.0.10
	kettenis-i386newframe-20030308-branchpoint:1.3
	carlton_dictionary-20030305-merge:1.3
	cagney_offbyone-20030303-branch:1.3.0.8
	cagney_offbyone-20030303-branchpoint:1.3
	carlton_dictionary-20030207-merge:1.3
	interps-20030202-branch:1.3.0.6
	interps-20030202-branchpoint:1.3
	cagney-unwind-20030108-branch:1.3.0.4
	cagney-unwind-20030108-branchpoint:1.3
	carlton_dictionary-branch:1.3.0.2
	carlton_dictionary-20021223-merge:1.3
	readline_4_3-import-branch:1.2.0.2
	readline_4_3:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.6
date	2011.05.11.23.38.39;	author jkratoch;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.05.18.26.12;	author drow;	state Exp;
branches;
next	1.4;

1.4
date	2006.04.20.20.13.20;	author ezannoni;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2002.12.08.22.31.37;	author ezannoni;	state Exp;
branches
	1.3.2.1
	1.3.44.1;
next	1.2;

1.2
date	2002.08.24.00.11.11;	author cagney;	state dead;
branches
	1.2.2.1;
next	1.1;

1.1
date	2002.08.23.22.02.28;	author ezannoni;	state Exp;
branches
	1.1.1.1;
next	;

1.4.2.1
date	2006.04.24.22.00.25;	author drow;	state Exp;
branches;
next	;

1.3.2.1
date	2002.12.23.19.39.45;	author carlton;	state Exp;
branches;
next	;

1.3.44.1
date	2003.12.14.20.28.14;	author drow;	state Exp;
branches;
next	;

1.2.2.1
date	2002.08.25.23.41.17;	author ezannoni;	state Exp;
branches;
next	;

1.1.1.1
date	2002.08.23.22.02.28;	author ezannoni;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.04.20.20.05.37;	author ezannoni;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Imported readline 6.2, and upstream patch 001.

[patch 0/3] readline-6.2 rebase
http://sourceware.org/ml/gdb-patches/2011-05/msg00003.html
[patch 1/3] readline-6.2: Merge of already posted patches
http://sourceware.org/ml/gdb-patches/2011-05/msg00004.html
	=
	[Bug-readline] [RFC/readline] bind.c, rl_function_dumper, Free allocated
	http://lists.gnu.org/archive/html/bug-readline/2011-03/msg00000.html
	[Bug-readline] [patch] Fix underquotation in readline/examples/rlfe/conf
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00001.html
	[Bug-readline] [patch] Makefile.in htm<->html
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00002.html
	Re: [Bug-readline] [patch] Makefile.in dependency: callback.o: xmalloc.h
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00004.html
	[Bug-readline] [patch] Remove . from the VPATH directive
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00005.html
	Eli Zaretskii's __MSDOS__ / __GO32__ / __MINGW32__ / __DJGPP__ stuff:
	http://sourceware.org/ml/gdb/2011-04/msg00002.html
	Jan Kratochvil's patch for FSF GDB tree local-specific changes:
	http://sourceware.org/ml/gdb/2011-04/msg00006.html
	Preservation of existing ChangeLog.gdb files, their updates.
[patch 2/3] readline-6.2: Workaround "ask" regression
http://sourceware.org/ml/gdb-patches/2011-05/msg00005.html
[patch 3/3] readline-6.2: Revert 5.x compat., apply 6.x compat.
http://sourceware.org/ml/gdb-patches/2011-05/msg00006.html
[patch 4/3] readline-6.2: Substitute inc-hist.texinfo
http://sourceware.org/ml/gdb-patches/2011-05/msg00010.html

readline/
	Workaround gdb.base/completion.exp regression on readline-6.2.
	* complete.c (get_y_or_n): Disable the return on RL_STATE_CALLBACK.

	Imported readline 6.2, and upstream patch 001.
	* configure: Regenerate.

readline/doc/
	* hsuser.texi (Using History Interactively): Disable !BashFeatures
	@@defcodeindex.  Make the `Programming with GNU History' reference
	external.
	* inc-hist.texinfo: Remove.

	Imported readline 6.2, and upstream patch 001.

readline/examples/
	Imported readline 6.2, and upstream patch 001.

readline/examples/rlfe/
	Imported readline 6.2, and upstream patch 001.

gdb/
	* config.in: Regenerate.
	* configure: Regenerate.
	* configure.ac <--with-system-readline> (for readline_echoing_p):
	Remove the test.
	* tui/tui-io.c (tui_old_readline_echoing_p): Rename to ...
	(tui_old_rl_echoing_p): ... here.
	(tui_setup_io): Rename extern declaration readline_echoing_p to
	_rl_echoing_p.  Adjust assignments for the both renames.

gdb/doc/
	* Makefile.in (GDB_DOC_SOURCE_INCLUDES): Rename inc-hist.texinfo to
	hsuser.texi.
	* gdb.texinfo <!SYSTEM_READLINE>: Rename inc-hist.texinfo inclusion and
	comment to hsuser.texi.  Change rluser.texi name in the comment.
@
text
@/* text.c -- text handling commands for readline. */

/* Copyright (C) 1987-2010 Free Software Foundation, Inc.

   This file is part of the GNU Readline Library (Readline), a library
   for reading lines of text with interactive input and history editing.      

   Readline is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Readline is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Readline.  If not, see <http://www.gnu.org/licenses/>.
*/

#define READLINE_LIBRARY

#if defined (HAVE_CONFIG_H)
#  include <config.h>
#endif

#if defined (HAVE_UNISTD_H)
#  include <unistd.h>
#endif /* HAVE_UNISTD_H */

#if defined (HAVE_STDLIB_H)
#  include <stdlib.h>
#else
#  include "ansi_stdlib.h"
#endif /* HAVE_STDLIB_H */

#if defined (HAVE_LOCALE_H)
#  include <locale.h>
#endif

#include <stdio.h>

/* System-specific feature definitions and include files. */
#include "rldefs.h"
#include "rlmbutil.h"

#if defined (__EMX__)
#  define INCL_DOSPROCESS
#  include <os2.h>
#endif /* __EMX__ */

/* Some standard library routines. */
#include "readline.h"
#include "history.h"

#include "rlprivate.h"
#include "rlshell.h"
#include "xmalloc.h"

/* Forward declarations. */
static int rl_change_case PARAMS((int, int));
static int _rl_char_search PARAMS((int, int, int));

#if defined (READLINE_CALLBACKS)
static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
static int _rl_char_search_callback PARAMS((_rl_callback_generic_arg *));
#endif

/* The largest chunk of text that can be inserted in one call to
   rl_insert_text.  Text blocks larger than this are divided. */
#define TEXT_COUNT_MAX	1024

/* **************************************************************** */
/*								    */
/*			Insert and Delete			    */
/*								    */
/* **************************************************************** */

/* Insert a string of text into the line at point.  This is the only
   way that you should do insertion.  _rl_insert_char () calls this
   function.  Returns the number of characters inserted. */
int
rl_insert_text (string)
     const char *string;
{
  register int i, l;

  l = (string && *string) ? strlen (string) : 0;
  if (l == 0)
    return 0;

  if (rl_end + l >= rl_line_buffer_len)
    rl_extend_line_buffer (rl_end + l);

  for (i = rl_end; i >= rl_point; i--)
    rl_line_buffer[i + l] = rl_line_buffer[i];
  strncpy (rl_line_buffer + rl_point, string, l);

  /* Remember how to undo this if we aren't undoing something. */
  if (_rl_doing_an_undo == 0)
    {
      /* If possible and desirable, concatenate the undos. */
      if ((l == 1) &&
	  rl_undo_list &&
	  (rl_undo_list->what == UNDO_INSERT) &&
	  (rl_undo_list->end == rl_point) &&
	  (rl_undo_list->end - rl_undo_list->start < 20))
	rl_undo_list->end++;
      else
	rl_add_undo (UNDO_INSERT, rl_point, rl_point + l, (char *)NULL);
    }
  rl_point += l;
  rl_end += l;
  rl_line_buffer[rl_end] = '\0';
  return l;
}

/* Delete the string between FROM and TO.  FROM is inclusive, TO is not.
   Returns the number of characters deleted. */
int
rl_delete_text (from, to)
     int from, to;
{
  register char *text;
  register int diff, i;

  /* Fix it if the caller is confused. */
  if (from > to)
    SWAP (from, to);

  /* fix boundaries */
  if (to > rl_end)
    {
      to = rl_end;
      if (from > to)
	from = to;
    }
  if (from < 0)
    from = 0;

  text = rl_copy_text (from, to);

  /* Some versions of strncpy() can't handle overlapping arguments. */
  diff = to - from;
  for (i = from; i < rl_end - diff; i++)
    rl_line_buffer[i] = rl_line_buffer[i + diff];

  /* Remember how to undo this delete. */
  if (_rl_doing_an_undo == 0)
    rl_add_undo (UNDO_DELETE, from, to, text);
  else
    xfree (text);

  rl_end -= diff;
  rl_line_buffer[rl_end] = '\0';
  return (diff);
}

/* Fix up point so that it is within the line boundaries after killing
   text.  If FIX_MARK_TOO is non-zero, the mark is forced within line
   boundaries also. */

#define _RL_FIX_POINT(x) \
	do { \
	if (x > rl_end) \
	  x = rl_end; \
	else if (x < 0) \
	  x = 0; \
	} while (0)

void
_rl_fix_point (fix_mark_too)
     int fix_mark_too;
{
  _RL_FIX_POINT (rl_point);
  if (fix_mark_too)
    _RL_FIX_POINT (rl_mark);
}
#undef _RL_FIX_POINT

/* Replace the contents of the line buffer between START and END with
   TEXT.  The operation is undoable.  To replace the entire line in an
   undoable mode, use _rl_replace_text(text, 0, rl_end); */
int
_rl_replace_text (text, start, end)
     const char *text;
     int start, end;
{
  int n;

  n = 0;
  rl_begin_undo_group ();
  if (start <= end)
    rl_delete_text (start, end + 1);
  rl_point = start;
  if (*text)
    n = rl_insert_text (text);
  rl_end_undo_group ();

  return n;
}

/* Replace the current line buffer contents with TEXT.  If CLEAR_UNDO is
   non-zero, we free the current undo list. */
void
rl_replace_line (text, clear_undo)
     const char *text;
     int clear_undo;
{
  int len;

  len = strlen (text);
  if (len >= rl_line_buffer_len)
    rl_extend_line_buffer (len);
  strcpy (rl_line_buffer, text);
  rl_end = len;

  if (clear_undo)
    rl_free_undo_list ();

  _rl_fix_point (1);
}

/* **************************************************************** */
/*								    */
/*			Readline character functions		    */
/*								    */
/* **************************************************************** */

/* This is not a gap editor, just a stupid line input routine.  No hair
   is involved in writing any of the functions, and none should be. */

/* Note that:

   rl_end is the place in the string that we would place '\0';
   i.e., it is always safe to place '\0' there.

   rl_point is the place in the string where the cursor is.  Sometimes
   this is the same as rl_end.

   Any command that is called interactively receives two arguments.
   The first is a count: the numeric arg pased to this command.
   The second is the key which invoked this command.
*/

/* **************************************************************** */
/*								    */
/*			Movement Commands			    */
/*								    */
/* **************************************************************** */

/* Note that if you `optimize' the display for these functions, you cannot
   use said functions in other functions which do not do optimizing display.
   I.e., you will have to update the data base for rl_redisplay, and you
   might as well let rl_redisplay do that job. */

/* Move forward COUNT bytes. */
int
rl_forward_byte (count, key)
     int count, key;
{
  if (count < 0)
    return (rl_backward_byte (-count, key));

  if (count > 0)
    {
      int end, lend;

      end = rl_point + count;
#if defined (VI_MODE)
      lend = rl_end > 0 ? rl_end - (VI_COMMAND_MODE()) : rl_end;
#else
      lend = rl_end;
#endif

      if (end > lend)
	{
	  rl_point = lend;
	  rl_ding ();
	}
      else
	rl_point = end;
    }

  if (rl_end < 0)
    rl_end = 0;

  return 0;
}

int
_rl_forward_char_internal (count)
     int count;
{
  int point;

#if defined (HANDLE_MULTIBYTE)
  point = _rl_find_next_mbchar (rl_line_buffer, rl_point, count, MB_FIND_NONZERO);

#if defined (VI_MODE)
  if (point >= rl_end && VI_COMMAND_MODE())
    point = _rl_find_prev_mbchar (rl_line_buffer, rl_end, MB_FIND_NONZERO);
#endif

    if (rl_end < 0)
	rl_end = 0;
#else
  point = rl_point + count;
  if (point > rl_end)
    point = rl_end;
#endif

  return (point);
}

#if defined (HANDLE_MULTIBYTE)
/* Move forward COUNT characters. */
int
rl_forward_char (count, key)
     int count, key;
{
  int point;

  if (MB_CUR_MAX == 1 || rl_byte_oriented)
    return (rl_forward_byte (count, key));

  if (count < 0)
    return (rl_backward_char (-count, key));

  if (count > 0)
    {
      if (rl_point == rl_end && EMACS_MODE())
	{
	  rl_ding ();
	  return 0;
	}

      point = _rl_forward_char_internal (count);

      if (rl_point == point)
	rl_ding ();

      rl_point = point;
    }

  return 0;
}
#else /* !HANDLE_MULTIBYTE */
int
rl_forward_char (count, key)
     int count, key;
{
  return (rl_forward_byte (count, key));
}
#endif /* !HANDLE_MULTIBYTE */
  
/* Backwards compatibility. */
int
rl_forward (count, key)
     int count, key;
{
  return (rl_forward_char (count, key));
}

/* Move backward COUNT bytes. */
int
rl_backward_byte (count, key)
     int count, key;
{
  if (count < 0)
    return (rl_forward_byte (-count, key));

  if (count > 0)
    {
      if (rl_point < count)
	{
	  rl_point = 0;
	  rl_ding ();
	}
      else
	rl_point -= count;
    }

  if (rl_point < 0)
    rl_point = 0;

  return 0;
}

#if defined (HANDLE_MULTIBYTE)
/* Move backward COUNT characters. */
int
rl_backward_char (count, key)
     int count, key;
{
  int point;

  if (MB_CUR_MAX == 1 || rl_byte_oriented)
    return (rl_backward_byte (count, key));

  if (count < 0)
    return (rl_forward_char (-count, key));

  if (count > 0)
    {
      point = rl_point;

      while (count > 0 && point > 0)
	{
	  point = _rl_find_prev_mbchar (rl_line_buffer, point, MB_FIND_NONZERO);
	  count--;
	}
      if (count > 0)
	{
	  rl_point = 0;
	  rl_ding ();
	}
      else
        rl_point = point;
    }

  return 0;
}
#else
int
rl_backward_char (count, key)
     int count, key;
{
  return (rl_backward_byte (count, key));
}
#endif

/* Backwards compatibility. */
int
rl_backward (count, key)
     int count, key;
{
  return (rl_backward_char (count, key));
}

/* Move to the beginning of the line. */
int
rl_beg_of_line (count, key)
     int count, key;
{
  rl_point = 0;
  return 0;
}

/* Move to the end of the line. */
int
rl_end_of_line (count, key)
     int count, key;
{
  rl_point = rl_end;
  return 0;
}

/* Move forward a word.  We do what Emacs does.  Handles multibyte chars. */
int
rl_forward_word (count, key)
     int count, key;
{
  int c;

  if (count < 0)
    return (rl_backward_word (-count, key));

  while (count)
    {
      if (rl_point == rl_end)
	return 0;

      /* If we are not in a word, move forward until we are in one.
	 Then, move forward until we hit a non-alphabetic character. */
      c = _rl_char_value (rl_line_buffer, rl_point);

      if (_rl_walphabetic (c) == 0)
	{
	  rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
	  while (rl_point < rl_end)
	    {
	      c = _rl_char_value (rl_line_buffer, rl_point);
	      if (_rl_walphabetic (c))
		break;
	      rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
	    }
	}

      if (rl_point == rl_end)
	return 0;

      rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
      while (rl_point < rl_end)
	{
	  c = _rl_char_value (rl_line_buffer, rl_point);
	  if (_rl_walphabetic (c) == 0)
	    break;
	  rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
	}

      --count;
    }

  return 0;
}

/* Move backward a word.  We do what Emacs does.  Handles multibyte chars. */
int
rl_backward_word (count, key)
     int count, key;
{
  int c, p;

  if (count < 0)
    return (rl_forward_word (-count, key));

  while (count)
    {
      if (rl_point == 0)
	return 0;

      /* Like rl_forward_word (), except that we look at the characters
	 just before point. */

      p = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);
      c = _rl_char_value (rl_line_buffer, p);

      if (_rl_walphabetic (c) == 0)
	{
	  rl_point = p;
	  while (rl_point > 0)
	    {
	      p = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);
	      c = _rl_char_value (rl_line_buffer, p);
	      if (_rl_walphabetic (c))
		break;
	      rl_point = p;
	    }
	}

      while (rl_point)
	{
	  p = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);
	  c = _rl_char_value (rl_line_buffer, p);	  
	  if (_rl_walphabetic (c) == 0)
	    break;
	  else
	    rl_point = p;
	}

      --count;
    }

  return 0;
}

/* Clear the current line.  Numeric argument to C-l does this. */
int
rl_refresh_line (ignore1, ignore2)
     int ignore1, ignore2;
{
  int curr_line;

  curr_line = _rl_current_display_line ();

  _rl_move_vert (curr_line);
  _rl_move_cursor_relative (0, rl_line_buffer);   /* XXX is this right */

  _rl_clear_to_eol (0);		/* arg of 0 means to not use spaces */

  rl_forced_update_display ();
  rl_display_fixed = 1;

  return 0;
}

/* C-l typed to a line without quoting clears the screen, and then reprints
   the prompt and the current input line.  Given a numeric arg, redraw only
   the current line. */
int
rl_clear_screen (count, key)
     int count, key;
{
  if (rl_explicit_arg)
    {
      rl_refresh_line (count, key);
      return 0;
    }

  _rl_clear_screen ();		/* calls termcap function to clear screen */
  rl_forced_update_display ();
  rl_display_fixed = 1;

  return 0;
}

int
rl_skip_csi_sequence (count, key)
     int count, key;
{
  int ch;

  RL_SETSTATE (RL_STATE_MOREINPUT);
  do
    ch = rl_read_key ();
  while (ch >= 0x20 && ch < 0x40);
  RL_UNSETSTATE (RL_STATE_MOREINPUT);

  return 0;
}

int
rl_arrow_keys (count, c)
     int count, c;
{
  int ch;

  RL_SETSTATE(RL_STATE_MOREINPUT);
  ch = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

  switch (_rl_to_upper (ch))
    {
    case 'A':
      rl_get_previous_history (count, ch);
      break;

    case 'B':
      rl_get_next_history (count, ch);
      break;

    case 'C':
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_forward_char (count, ch);
      else
	rl_forward_byte (count, ch);
      break;

    case 'D':
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_backward_char (count, ch);
      else
	rl_backward_byte (count, ch);
      break;

    default:
      rl_ding ();
    }

  return 0;
}

/* **************************************************************** */
/*								    */
/*			Text commands				    */
/*								    */
/* **************************************************************** */

#ifdef HANDLE_MULTIBYTE
static char pending_bytes[MB_LEN_MAX];
static int pending_bytes_length = 0;
static mbstate_t ps = {0};
#endif

/* Insert the character C at the current location, moving point forward.
   If C introduces a multibyte sequence, we read the whole sequence and
   then insert the multibyte char into the line buffer. */
int
_rl_insert_char (count, c)
     int count, c;
{
  register int i;
  char *string;
#ifdef HANDLE_MULTIBYTE
  int string_size;
  char incoming[MB_LEN_MAX + 1];
  int incoming_length = 0;
  mbstate_t ps_back;
  static int stored_count = 0;
#endif

  if (count <= 0)
    return 0;

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX == 1 || rl_byte_oriented)
    {
      incoming[0] = c;
      incoming[1] = '\0';
      incoming_length = 1;
    }
  else
    {
      wchar_t wc;
      size_t ret;

      if (stored_count <= 0)
	stored_count = count;
      else
	count = stored_count;

      ps_back = ps;
      pending_bytes[pending_bytes_length++] = c;
      ret = mbrtowc (&wc, pending_bytes, pending_bytes_length, &ps);

      if (ret == (size_t)-2)
	{
	  /* Bytes too short to compose character, try to wait for next byte.
	     Restore the state of the byte sequence, because in this case the
	     effect of mbstate is undefined. */
	  ps = ps_back;
	  return 1;
	}
      else if (ret == (size_t)-1)
	{
	  /* Invalid byte sequence for the current locale.  Treat first byte
	     as a single character. */
	  incoming[0] = pending_bytes[0];
	  incoming[1] = '\0';
	  incoming_length = 1;
	  pending_bytes_length--;
	  memmove (pending_bytes, pending_bytes + 1, pending_bytes_length);
	  /* Clear the state of the byte sequence, because in this case the
	     effect of mbstate is undefined. */
	  memset (&ps, 0, sizeof (mbstate_t));
	}
      else if (ret == (size_t)0)
	{
	  incoming[0] = '\0';
	  incoming_length = 0;
	  pending_bytes_length--;
	  /* Clear the state of the byte sequence, because in this case the
	     effect of mbstate is undefined. */
	  memset (&ps, 0, sizeof (mbstate_t));
	}
      else
	{
	  /* We successfully read a single multibyte character. */
	  memcpy (incoming, pending_bytes, pending_bytes_length);
	  incoming[pending_bytes_length] = '\0';
	  incoming_length = pending_bytes_length;
	  pending_bytes_length = 0;
	}
    }
#endif /* HANDLE_MULTIBYTE */
	  
  /* If we can optimize, then do it.  But don't let people crash
     readline because of extra large arguments. */
  if (count > 1 && count <= TEXT_COUNT_MAX)
    {
#if defined (HANDLE_MULTIBYTE)
      string_size = count * incoming_length;
      string = (char *)xmalloc (1 + string_size);

      i = 0;
      while (i < string_size)
	{
	  strncpy (string + i, incoming, incoming_length);
	  i += incoming_length;
	}
      incoming_length = 0;
      stored_count = 0;
#else /* !HANDLE_MULTIBYTE */
      string = (char *)xmalloc (1 + count);

      for (i = 0; i < count; i++)
	string[i] = c;
#endif /* !HANDLE_MULTIBYTE */

      string[i] = '\0';
      rl_insert_text (string);
      xfree (string);

      return 0;
    }

  if (count > TEXT_COUNT_MAX)
    {
      int decreaser;
#if defined (HANDLE_MULTIBYTE)
      string_size = incoming_length * TEXT_COUNT_MAX;
      string = (char *)xmalloc (1 + string_size);

      i = 0;
      while (i < string_size)
	{
	  strncpy (string + i, incoming, incoming_length);
	  i += incoming_length;
	}

      while (count)
	{
	  decreaser = (count > TEXT_COUNT_MAX) ? TEXT_COUNT_MAX : count;
	  string[decreaser*incoming_length] = '\0';
	  rl_insert_text (string);
	  count -= decreaser;
	}

      xfree (string);
      incoming_length = 0;
      stored_count = 0;
#else /* !HANDLE_MULTIBYTE */
      char str[TEXT_COUNT_MAX+1];

      for (i = 0; i < TEXT_COUNT_MAX; i++)
	str[i] = c;

      while (count)
	{
	  decreaser = (count > TEXT_COUNT_MAX ? TEXT_COUNT_MAX : count);
	  str[decreaser] = '\0';
	  rl_insert_text (str);
	  count -= decreaser;
	}
#endif /* !HANDLE_MULTIBYTE */

      return 0;
    }

  if (MB_CUR_MAX == 1 || rl_byte_oriented)
    {
      /* We are inserting a single character.
	 If there is pending input, then make a string of all of the
	 pending characters that are bound to rl_insert, and insert
	 them all.  Don't do this if we're current reading input from
	 a macro. */
      if ((RL_ISSTATE (RL_STATE_MACROINPUT) == 0) && _rl_any_typein ())
	_rl_insert_typein (c);
      else
	{
	  /* Inserting a single character. */
	  char str[2];

	  str[1] = '\0';
	  str[0] = c;
	  rl_insert_text (str);
	}
    }
#if defined (HANDLE_MULTIBYTE)
  else
    {
      rl_insert_text (incoming);
      stored_count = 0;
    }
#endif

  return 0;
}

/* Overwrite the character at point (or next COUNT characters) with C.
   If C introduces a multibyte character sequence, read the entire sequence
   before starting the overwrite loop. */
int
_rl_overwrite_char (count, c)
     int count, c;
{
  int i;
#if defined (HANDLE_MULTIBYTE)
  char mbkey[MB_LEN_MAX];
  int k;

  /* Read an entire multibyte character sequence to insert COUNT times. */
  if (count > 0 && MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    k = _rl_read_mbstring (c, mbkey, MB_LEN_MAX);
#endif

  rl_begin_undo_group ();

  for (i = 0; i < count; i++)
    {
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_insert_text (mbkey);
      else
#endif
	_rl_insert_char (1, c);

      if (rl_point < rl_end)
	rl_delete (1, c);
    }

  rl_end_undo_group ();

  return 0;
}

int
rl_insert (count, c)
     int count, c;
{
  return (rl_insert_mode == RL_IM_INSERT ? _rl_insert_char (count, c)
  					 : _rl_overwrite_char (count, c));
}

/* Insert the next typed character verbatim. */
static int
_rl_insert_next (count)
     int count;
{
  int c;

  RL_SETSTATE(RL_STATE_MOREINPUT);
  c = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

  if (c < 0)
    return -1;

#if defined (HANDLE_SIGNALS)
  if (RL_ISSTATE (RL_STATE_CALLBACK) == 0)
    _rl_restore_tty_signals ();
#endif

  return (_rl_insert_char (count, c));  
}

#if defined (READLINE_CALLBACKS)
static int
_rl_insert_next_callback (data)
     _rl_callback_generic_arg *data;
{
  int count;

  count = data->count;

  /* Deregister function, let rl_callback_read_char deallocate data */
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;
 
  return _rl_insert_next (count);
}
#endif
  
int
rl_quoted_insert (count, key)
     int count, key;
{
  /* Let's see...should the callback interface futz with signal handling? */
#if defined (HANDLE_SIGNALS)
  if (RL_ISSTATE (RL_STATE_CALLBACK) == 0)
    _rl_disable_tty_signals ();
#endif

#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = _rl_callback_data_alloc (count);
      _rl_callback_func = _rl_insert_next_callback;
      return (0);
    }
#endif
      
  return _rl_insert_next (count);
}

/* Insert a tab character. */
int
rl_tab_insert (count, key)
     int count, key;
{
  return (_rl_insert_char (count, '\t'));
}

/* What to do when a NEWLINE is pressed.  We accept the whole line.
   KEY is the key that invoked this command.  I guess it could have
   meaning in the future. */
int
rl_newline (count, key)
     int count, key;
{
  rl_done = 1;

  if (_rl_history_preserve_point)
    _rl_history_saved_point = (rl_point == rl_end) ? -1 : rl_point;

  RL_SETSTATE(RL_STATE_DONE);

#if defined (VI_MODE)
  if (rl_editing_mode == vi_mode)
    {
      _rl_vi_done_inserting ();
      if (_rl_vi_textmod_command (_rl_vi_last_command) == 0)	/* XXX */
	_rl_vi_reset_last ();
    }
#endif /* VI_MODE */

  /* If we've been asked to erase empty lines, suppress the final update,
     since _rl_update_final calls rl_crlf(). */
  if (rl_erase_empty_line && rl_point == 0 && rl_end == 0)
    return 0;

  if (_rl_echoing_p)
    _rl_update_final ();
  return 0;
}

/* What to do for some uppercase characters, like meta characters,
   and some characters appearing in emacs_ctlx_keymap.  This function
   is just a stub, you bind keys to it and the code in _rl_dispatch ()
   is special cased. */
int
rl_do_lowercase_version (ignore1, ignore2)
     int ignore1, ignore2;
{
  return 0;
}

/* This is different from what vi does, so the code's not shared.  Emacs
   rubout in overwrite mode has one oddity:  it replaces a control
   character that's displayed as two characters (^X) with two spaces. */
int
_rl_overwrite_rubout (count, key)
     int count, key;
{
  int opoint;
  int i, l;

  if (rl_point == 0)
    {
      rl_ding ();
      return 1;
    }

  opoint = rl_point;

  /* L == number of spaces to insert */
  for (i = l = 0; i < count; i++)
    {
      rl_backward_char (1, key);
      l += rl_character_len (rl_line_buffer[rl_point], rl_point);	/* not exactly right */
    }

  rl_begin_undo_group ();

  if (count > 1 || rl_explicit_arg)
    rl_kill_text (opoint, rl_point);
  else
    rl_delete_text (opoint, rl_point);

  /* Emacs puts point at the beginning of the sequence of spaces. */
  if (rl_point < rl_end)
    {
      opoint = rl_point;
      _rl_insert_char (l, ' ');
      rl_point = opoint;
    }

  rl_end_undo_group ();

  return 0;
}
  
/* Rubout the character behind point. */
int
rl_rubout (count, key)
     int count, key;
{
  if (count < 0)
    return (rl_delete (-count, key));

  if (!rl_point)
    {
      rl_ding ();
      return -1;
    }

  if (rl_insert_mode == RL_IM_OVERWRITE)
    return (_rl_overwrite_rubout (count, key));

  return (_rl_rubout_char (count, key));
}

int
_rl_rubout_char (count, key)
     int count, key;
{
  int orig_point;
  unsigned char c;

  /* Duplicated code because this is called from other parts of the library. */
  if (count < 0)
    return (rl_delete (-count, key));

  if (rl_point == 0)
    {
      rl_ding ();
      return -1;
    }

  orig_point = rl_point;
  if (count > 1 || rl_explicit_arg)
    {
      rl_backward_char (count, key);
      rl_kill_text (orig_point, rl_point);
    }
  else if (MB_CUR_MAX == 1 || rl_byte_oriented)
    {
      c = rl_line_buffer[--rl_point];
      rl_delete_text (rl_point, orig_point);
      /* The erase-at-end-of-line hack is of questionable merit now. */
      if (rl_point == rl_end && ISPRINT (c) && _rl_last_c_pos)
	{
	  int l;
	  l = rl_character_len (c, rl_point);
	  _rl_erase_at_end_of_line (l);
	}
    }
  else
    {
      rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);
      rl_delete_text (rl_point, orig_point);
    }

  return 0;
}

/* Delete the character under the cursor.  Given a numeric argument,
   kill that many characters instead. */
int
rl_delete (count, key)
     int count, key;
{
  int xpoint;

  if (count < 0)
    return (_rl_rubout_char (-count, key));

  if (rl_point == rl_end)
    {
      rl_ding ();
      return -1;
    }

  if (count > 1 || rl_explicit_arg)
    {
      xpoint = rl_point;
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_forward_char (count, key);
      else
	rl_forward_byte (count, key);

      rl_kill_text (xpoint, rl_point);
      rl_point = xpoint;
    }
  else
    {
      xpoint = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
      rl_delete_text (rl_point, xpoint);
    }
  return 0;
}

/* Delete the character under the cursor, unless the insertion
   point is at the end of the line, in which case the character
   behind the cursor is deleted.  COUNT is obeyed and may be used
   to delete forward or backward that many characters. */      
int
rl_rubout_or_delete (count, key)
     int count, key;
{
  if (rl_end != 0 && rl_point == rl_end)
    return (_rl_rubout_char (count, key));
  else
    return (rl_delete (count, key));
}  

/* Delete all spaces and tabs around point. */
int
rl_delete_horizontal_space (count, ignore)
     int count, ignore;
{
  int start;

  while (rl_point && whitespace (rl_line_buffer[rl_point - 1]))
    rl_point--;

  start = rl_point;

  while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))
    rl_point++;

  if (start != rl_point)
    {
      rl_delete_text (start, rl_point);
      rl_point = start;
    }

  if (rl_point < 0)
    rl_point = 0;

  return 0;
}

/* Like the tcsh editing function delete-char-or-list.  The eof character
   is caught before this is invoked, so this really does the same thing as
   delete-char-or-list-or-eof, as long as it's bound to the eof character. */
int
rl_delete_or_show_completions (count, key)
     int count, key;
{
  if (rl_end != 0 && rl_point == rl_end)
    return (rl_possible_completions (count, key));
  else
    return (rl_delete (count, key));
}

#ifndef RL_COMMENT_BEGIN_DEFAULT
#define RL_COMMENT_BEGIN_DEFAULT "#"
#endif

/* Turn the current line into a comment in shell history.
   A K*rn shell style function. */
int
rl_insert_comment (count, key)
     int count, key;
{
  char *rl_comment_text;
  int rl_comment_len;

  rl_beg_of_line (1, key);
  rl_comment_text = _rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT;

  if (rl_explicit_arg == 0)
    rl_insert_text (rl_comment_text);
  else
    {
      rl_comment_len = strlen (rl_comment_text);
      if (STREQN (rl_comment_text, rl_line_buffer, rl_comment_len))
	rl_delete_text (rl_point, rl_point + rl_comment_len);
      else
	rl_insert_text (rl_comment_text);
    }

  (*rl_redisplay_function) ();
  rl_newline (1, '\n');

  return (0);
}

/* **************************************************************** */
/*								    */
/*			Changing Case				    */
/*								    */
/* **************************************************************** */

/* The three kinds of things that we know how to do. */
#define UpCase 1
#define DownCase 2
#define CapCase 3

/* Uppercase the word at point. */
int
rl_upcase_word (count, key)
     int count, key;
{
  return (rl_change_case (count, UpCase));
}

/* Lowercase the word at point. */
int
rl_downcase_word (count, key)
     int count, key;
{
  return (rl_change_case (count, DownCase));
}

/* Upcase the first letter, downcase the rest. */
int
rl_capitalize_word (count, key)
     int count, key;
{
 return (rl_change_case (count, CapCase));
}

/* The meaty function.
   Change the case of COUNT words, performing OP on them.
   OP is one of UpCase, DownCase, or CapCase.
   If a negative argument is given, leave point where it started,
   otherwise, leave it where it moves to. */
static int
rl_change_case (count, op)
     int count, op;
{
  int start, next, end;
  int inword, c, nc, nop;
#if defined (HANDLE_MULTIBYTE)
  wchar_t wc, nwc;
  char mb[MB_LEN_MAX+1];
  int mlen;
  size_t m;
  mbstate_t mps;
#endif

  start = rl_point;
  rl_forward_word (count, 0);
  end = rl_point;

  if (op != UpCase && op != DownCase && op != CapCase)
    {
      rl_ding ();
      return -1;
    }

  if (count < 0)
    SWAP (start, end);

#if defined (HANDLE_MULTIBYTE)
  memset (&mps, 0, sizeof (mbstate_t));
#endif

  /* We are going to modify some text, so let's prepare to undo it. */
  rl_modifying (start, end);

  inword = 0;
  while (start < end)
    {
      c = _rl_char_value (rl_line_buffer, start);
      /*  This assumes that the upper and lower case versions are the same width. */
      next = MB_NEXTCHAR (rl_line_buffer, start, 1, MB_FIND_NONZERO);

      if (_rl_walphabetic (c) == 0)
	{
	  inword = 0;
	  start = next;
	  continue;
	}

      if (op == CapCase)
	{
	  nop = inword ? DownCase : UpCase;
	  inword = 1;
	}
      else
	nop = op;
      if (MB_CUR_MAX == 1 || rl_byte_oriented || isascii (c))
	{
	  nc = (nop == UpCase) ? _rl_to_upper (c) : _rl_to_lower (c);
	  rl_line_buffer[start] = nc;
	}
#if defined (HANDLE_MULTIBYTE)
      else
	{
	  m = mbrtowc (&wc, rl_line_buffer + start, end - start, &mps);
	  if (MB_INVALIDCH (m))
	    wc = (wchar_t)rl_line_buffer[start];
	  else if (MB_NULLWCH (m))
	    wc = L'\0';
	  nwc = (nop == UpCase) ? _rl_to_wupper (wc) : _rl_to_wlower (wc);
	  if  (nwc != wc)	/*  just skip unchanged characters */
	    {
	      mlen = wcrtomb (mb, nwc, &mps);
	      if (mlen > 0)
		mb[mlen] = '\0';
	      /* Assume the same width */
	      strncpy (rl_line_buffer + start, mb, mlen);
	    }
	}
#endif

      start = next;
    }

  rl_point = end;
  return 0;
}

/* **************************************************************** */
/*								    */
/*			Transposition				    */
/*								    */
/* **************************************************************** */

/* Transpose the words at point.  If point is at the end of the line,
   transpose the two words before point. */
int
rl_transpose_words (count, key)
     int count, key;
{
  char *word1, *word2;
  int w1_beg, w1_end, w2_beg, w2_end;
  int orig_point = rl_point;

  if (!count)
    return 0;

  /* Find the two words. */
  rl_forward_word (count, key);
  w2_end = rl_point;
  rl_backward_word (1, key);
  w2_beg = rl_point;
  rl_backward_word (count, key);
  w1_beg = rl_point;
  rl_forward_word (1, key);
  w1_end = rl_point;

  /* Do some check to make sure that there really are two words. */
  if ((w1_beg == w2_beg) || (w2_beg < w1_end))
    {
      rl_ding ();
      rl_point = orig_point;
      return -1;
    }

  /* Get the text of the words. */
  word1 = rl_copy_text (w1_beg, w1_end);
  word2 = rl_copy_text (w2_beg, w2_end);

  /* We are about to do many insertions and deletions.  Remember them
     as one operation. */
  rl_begin_undo_group ();

  /* Do the stuff at word2 first, so that we don't have to worry
     about word1 moving. */
  rl_point = w2_beg;
  rl_delete_text (w2_beg, w2_end);
  rl_insert_text (word1);

  rl_point = w1_beg;
  rl_delete_text (w1_beg, w1_end);
  rl_insert_text (word2);

  /* This is exactly correct since the text before this point has not
     changed in length. */
  rl_point = w2_end;

  /* I think that does it. */
  rl_end_undo_group ();
  xfree (word1);
  xfree (word2);

  return 0;
}

/* Transpose the characters at point.  If point is at the end of the line,
   then transpose the characters before point. */
int
rl_transpose_chars (count, key)
     int count, key;
{
#if defined (HANDLE_MULTIBYTE)
  char *dummy;
  int i;
#else
  char dummy[2];
#endif
  int char_length, prev_point;

  if (count == 0)
    return 0;

  if (!rl_point || rl_end < 2)
    {
      rl_ding ();
      return -1;
    }

  rl_begin_undo_group ();

  if (rl_point == rl_end)
    {
      rl_point = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);
      count = 1;
    }

  prev_point = rl_point;
  rl_point = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);

#if defined (HANDLE_MULTIBYTE)
  char_length = prev_point - rl_point;
  dummy = (char *)xmalloc (char_length + 1);
  for (i = 0; i < char_length; i++)
    dummy[i] = rl_line_buffer[rl_point + i];
  dummy[i] = '\0';
#else
  dummy[0] = rl_line_buffer[rl_point];
  dummy[char_length = 1] = '\0';
#endif

  rl_delete_text (rl_point, rl_point + char_length);

  rl_point = _rl_find_next_mbchar (rl_line_buffer, rl_point, count, MB_FIND_NONZERO);

  _rl_fix_point (0);
  rl_insert_text (dummy);
  rl_end_undo_group ();

#if defined (HANDLE_MULTIBYTE)
  xfree (dummy);
#endif

  return 0;
}

/* **************************************************************** */
/*								    */
/*			Character Searching			    */
/*								    */
/* **************************************************************** */

int
#if defined (HANDLE_MULTIBYTE)
_rl_char_search_internal (count, dir, smbchar, len)
     int count, dir;
     char *smbchar;
     int len;
#else
_rl_char_search_internal (count, dir, schar)
     int count, dir, schar;
#endif
{
  int pos, inc;
#if defined (HANDLE_MULTIBYTE)
  int prepos;
#endif

  if (dir == 0)
    return -1;

  pos = rl_point;
  inc = (dir < 0) ? -1 : 1;
  while (count)
    {
      if ((dir < 0 && pos <= 0) || (dir > 0 && pos >= rl_end))
	{
	  rl_ding ();
	  return -1;
	}

#if defined (HANDLE_MULTIBYTE)
      pos = (inc > 0) ? _rl_find_next_mbchar (rl_line_buffer, pos, 1, MB_FIND_ANY)
		      : _rl_find_prev_mbchar (rl_line_buffer, pos, MB_FIND_ANY);
#else
      pos += inc;
#endif
      do
	{
#if defined (HANDLE_MULTIBYTE)
	  if (_rl_is_mbchar_matched (rl_line_buffer, pos, rl_end, smbchar, len))
#else
	  if (rl_line_buffer[pos] == schar)
#endif
	    {
	      count--;
	      if (dir < 0)
	        rl_point = (dir == BTO) ? _rl_find_next_mbchar (rl_line_buffer, pos, 1, MB_FIND_ANY)
					: pos;
	      else
		rl_point = (dir == FTO) ? _rl_find_prev_mbchar (rl_line_buffer, pos, MB_FIND_ANY)
					: pos;
	      break;
	    }
#if defined (HANDLE_MULTIBYTE)
	  prepos = pos;
#endif
	}
#if defined (HANDLE_MULTIBYTE)
      while ((dir < 0) ? (pos = _rl_find_prev_mbchar (rl_line_buffer, pos, MB_FIND_ANY)) != prepos
		       : (pos = _rl_find_next_mbchar (rl_line_buffer, pos, 1, MB_FIND_ANY)) != prepos);
#else
      while ((dir < 0) ? pos-- : ++pos < rl_end);
#endif
    }
  return (0);
}

/* Search COUNT times for a character read from the current input stream.
   FDIR is the direction to search if COUNT is non-negative; otherwise
   the search goes in BDIR.  So much is dependent on HANDLE_MULTIBYTE
   that there are two separate versions of this function. */
#if defined (HANDLE_MULTIBYTE)
static int
_rl_char_search (count, fdir, bdir)
     int count, fdir, bdir;
{
  char mbchar[MB_LEN_MAX];
  int mb_len;

  mb_len = _rl_read_mbchar (mbchar, MB_LEN_MAX);

  if (mb_len <= 0)
    return -1;

  if (count < 0)
    return (_rl_char_search_internal (-count, bdir, mbchar, mb_len));
  else
    return (_rl_char_search_internal (count, fdir, mbchar, mb_len));
}
#else /* !HANDLE_MULTIBYTE */
static int
_rl_char_search (count, fdir, bdir)
     int count, fdir, bdir;
{
  int c;

  RL_SETSTATE(RL_STATE_MOREINPUT);
  c = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

  if (c < 0)
    return -1;

  if (count < 0)
    return (_rl_char_search_internal (-count, bdir, c));
  else
    return (_rl_char_search_internal (count, fdir, c));
}
#endif /* !HANDLE_MULTIBYTE */

#if defined (READLINE_CALLBACKS)
static int
_rl_char_search_callback (data)
     _rl_callback_generic_arg *data;
{
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

  return (_rl_char_search (data->count, data->i1, data->i2));
}
#endif

int
rl_char_search (count, key)
     int count, key;
{
#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = _rl_callback_data_alloc (count);
      _rl_callback_data->i1 = FFIND;
      _rl_callback_data->i2 = BFIND;
      _rl_callback_func = _rl_char_search_callback;
      return (0);
    }
#endif
  
  return (_rl_char_search (count, FFIND, BFIND));
}

int
rl_backward_char_search (count, key)
     int count, key;
{
#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = _rl_callback_data_alloc (count);
      _rl_callback_data->i1 = BFIND;
      _rl_callback_data->i2 = FFIND;
      _rl_callback_func = _rl_char_search_callback;
      return (0);
    }
#endif

  return (_rl_char_search (count, BFIND, FFIND));
}

/* **************************************************************** */
/*								    */
/*		   The Mark and the Region.			    */
/*								    */
/* **************************************************************** */

/* Set the mark at POSITION. */
int
_rl_set_mark_at_pos (position)
     int position;
{
  if (position > rl_end)
    return -1;

  rl_mark = position;
  return 0;
}

/* A bindable command to set the mark. */
int
rl_set_mark (count, key)
     int count, key;
{
  return (_rl_set_mark_at_pos (rl_explicit_arg ? count : rl_point));
}

/* Exchange the position of mark and point. */
int
rl_exchange_point_and_mark (count, key)
     int count, key;
{
  if (rl_mark > rl_end)
    rl_mark = -1;

  if (rl_mark == -1)
    {
      rl_ding ();
      return -1;
    }
  else
    SWAP (rl_point, rl_mark);

  return 0;
}
@


1.5
log
@Readline 5.1 import for HEAD.
@
text
@d3 1
a3 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
d5 2
a6 2
   This file is part of the GNU Readline Library, a library for
   reading lines of text with interactive input and history editing.
d8 3
a10 3
   The GNU Readline Library is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2, or
d13 3
a15 3
   The GNU Readline Library is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
d18 4
a21 4
   The GNU General Public License is often shipped with GNU software, and
   is generally kept in a file called COPYING or LICENSE.  If you do not
   have a copy of the license, write to the Free Software Foundation,
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
d70 4
d153 1
a153 1
    free (text);
d192 1
d194 2
a195 1
  rl_delete_text (start, end + 1);
d197 2
a198 1
  n = rl_insert_text (text);
d268 3
a270 1
      int end = rl_point + count;
d272 1
a272 1
      int lend = rl_end > 0 ? rl_end - (rl_editing_mode == vi_mode) : rl_end;
d274 1
a274 1
      int lend = rl_end;
d292 25
d333 5
a337 1
      point = _rl_find_next_mbchar (rl_line_buffer, rl_point, count, MB_FIND_NONZERO);
d339 1
a339 4
#if defined (VI_MODE)
      if (rl_end <= point && rl_editing_mode == vi_mode)
	point = _rl_find_prev_mbchar (rl_line_buffer, rl_end, MB_FIND_NONZERO);
#endif
a344 3

      if (rl_end < 0)
	rl_end = 0;
d600 15
d751 1
a751 1
  if (count > 1 && count <= 1024)
d774 1
a774 1
      free (string);
d779 1
a779 1
  if (count > 1024)
d783 1
a783 1
      string_size = incoming_length * 1024;
d795 1
a795 1
	  decreaser = (count > 1024) ? 1024 : count;
d801 1
a801 1
      free (string);
d805 1
a805 1
      char str[1024+1];
d807 1
a807 1
      for (i = 0; i < 1024; i++)
d812 1
a812 1
	  decreaser = (count > 1024 ? 1024 : count);
d827 3
a829 2
	 them all. */
      if (_rl_any_typein ())
d908 3
d994 1
a994 1
  if (readline_echoing_p)
d1125 2
d1138 1
a1138 1
      int orig_point = rl_point;
d1144 2
a1145 2
      rl_kill_text (orig_point, rl_point);
      rl_point = orig_point;
d1149 2
a1150 4
      int new_point;

      new_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
      rl_delete_text (rl_point, new_point);
d1174 1
a1174 1
  int start = rl_point;
d1291 3
a1293 2
  int mblen, p;
  mbstate_t ps;
d1310 1
a1310 1
  memset (&ps, 0, sizeof (mbstate_t));
d1345 5
a1349 1
	  mbrtowc (&wc, rl_line_buffer + start, end - start, &ps);
d1353 3
a1355 3
	      mblen = wcrtomb (mb, nwc, &ps);
	      if (mblen > 0)
		mb[mblen] = '\0';
d1357 1
a1357 1
	      strncpy (rl_line_buffer + start, mb, mblen);
d1430 2
a1431 2
  free (word1);
  free (word2);
d1490 1
a1490 1
  free (dummy);
d1518 3
d1582 3
d1601 3
@


1.4
log
@touched all sources to ease import of readline-5.1
@
text
@d3 1
a3 1
/* Copyright (C) 1987-2002 Free Software Foundation, Inc.
d65 5
d178 3
d428 1
a428 2
/* XXX - these might need changes for multibyte characters */
/* Move forward a word.  We do what Emacs does. */
d445 3
a447 2
      c = rl_line_buffer[rl_point];
      if (rl_alphabetic (c) == 0)
d449 2
a450 1
	  while (++rl_point < rl_end)
d452 2
a453 2
	      c = rl_line_buffer[rl_point];
	      if (rl_alphabetic (c))
d455 1
d462 2
a463 1
      while (++rl_point < rl_end)
d465 2
a466 2
	  c = rl_line_buffer[rl_point];
	  if (rl_alphabetic (c) == 0)
d468 1
d470 1
d477 1
a477 1
/* Move backward a word.  We do what Emacs does. */
d482 1
a482 1
  int c;
d489 1
a489 1
      if (!rl_point)
d495 4
a498 2
      c = rl_line_buffer[rl_point - 1];
      if (rl_alphabetic (c) == 0)
d500 2
a501 1
	  while (--rl_point)
d503 3
a505 2
	      c = rl_line_buffer[rl_point - 1];
	      if (rl_alphabetic (c))
d507 1
d513 3
a515 2
	  c = rl_line_buffer[rl_point - 1];
	  if (rl_alphabetic (c) == 0)
d518 1
a518 1
	    --rl_point;
a774 1
#if defined (HANDLE_MULTIBYTE)
a776 1
#endif
d792 1
a793 1
    }
d821 2
a824 5
      rl_begin_undo_group ();

      if (rl_point < rl_end)
	rl_delete (1, c);

d832 2
a833 1
      rl_end_undo_group ();
d836 2
d850 3
a852 3
int
rl_quoted_insert (count, key)
     int count, key;
a855 4
#if defined (HANDLE_SIGNALS)
  _rl_disable_tty_signals ();
#endif

d861 2
a862 1
  _rl_restore_tty_signals ();
d868 39
d933 2
a934 1
      _rl_vi_reset_last ();
d992 6
a997 3
  opoint = rl_point;
  _rl_insert_char (l, ' ');
  rl_point = opoint;
d1041 1
d1044 1
a1044 7
      orig_point = rl_point;
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_backward_char (count, key);
      else
#endif
        rl_backward_byte (count, key);
d1047 1
a1047 1
  else
d1049 3
a1051 24
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX == 1 || rl_byte_oriented)
	{
#endif
	  c = rl_line_buffer[--rl_point];
	  rl_delete_text (rl_point, rl_point + 1);
#if defined (HANDLE_MULTIBYTE)
	}
      else
	{
	  int orig_point;

	  orig_point = rl_point;
	  rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);
	  c = rl_line_buffer[rl_point];
	  rl_delete_text (rl_point, orig_point);
	}
#endif /* HANDLE_MULTIBYTE */

      /* I don't think that the hack for end of line is needed for
	 multibyte chars. */
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX == 1 || rl_byte_oriented)
#endif
d1059 5
a1073 2
  int r;

a1085 1
#if defined (HANDLE_MULTIBYTE)
a1088 1
#endif
d1091 1
a1091 1
      r = rl_kill_text (orig_point, rl_point);
a1092 1
      return r;
d1097 3
a1099 6
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	new_point = _rl_find_next_mbchar (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
      else
	new_point = rl_point + 1;
	
      return (rl_delete_text (rl_point, new_point));
d1101 1
d1138 4
d1235 8
a1242 2
  register int start, end;
  int inword, c;
d1248 6
d1257 4
d1264 2
a1265 1
  for (inword = 0; start < end; start++)
d1267 5
a1271 2
      c = rl_line_buffer[start];
      switch (op)
d1273 4
a1276 3
	case UpCase:
	  rl_line_buffer[start] = _rl_to_upper (c);
	  break;
d1278 27
a1304 3
	case DownCase:
	  rl_line_buffer[start] = _rl_to_lower (c);
	  break;
d1306 2
a1307 4
	case CapCase:
	  rl_line_buffer[start] = (inword == 0) ? _rl_to_upper (c) : _rl_to_lower (c);
	  inword = rl_alphabetic (rl_line_buffer[start]);
	  break;
a1308 5
	default:
	  rl_ding ();
	  return -1;
	}
    }
d1388 1
a1388 1
  int i, prev_point;
d1392 1
a1392 1
  int char_length;
d1407 1
a1407 4
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);
      else
	--rl_point;
a1410 1
#if defined (HANDLE_MULTIBYTE)
d1412 1
a1412 5
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);
  else
#endif
    rl_point--;
d1546 12
d1562 11
d1580 11
@


1.4.2.1
log
@Import readline 5.1 on the branch.
@
text
@d3 1
a3 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
a64 5
#if defined (READLINE_CALLBACKS)
static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
static int _rl_char_search_callback PARAMS((_rl_callback_generic_arg *));
#endif

a172 3
/* Replace the contents of the line buffer between START and END with
   TEXT.  The operation is undoable.  To replace the entire line in an
   undoable mode, use _rl_replace_text(text, 0, rl_end); */
d420 2
a421 1
/* Move forward a word.  We do what Emacs does.  Handles multibyte chars. */
d438 2
a439 3
      c = _rl_char_value (rl_line_buffer, rl_point);

      if (_rl_walphabetic (c) == 0)
d441 1
a441 2
	  rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
	  while (rl_point < rl_end)
d443 2
a444 2
	      c = _rl_char_value (rl_line_buffer, rl_point);
	      if (_rl_walphabetic (c))
a445 1
	      rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
d452 1
a452 2
      rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
      while (rl_point < rl_end)
d454 2
a455 2
	  c = _rl_char_value (rl_line_buffer, rl_point);
	  if (_rl_walphabetic (c) == 0)
a456 1
	  rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
a457 1

d464 1
a464 1
/* Move backward a word.  We do what Emacs does.  Handles multibyte chars. */
d469 1
a469 1
  int c, p;
d476 1
a476 1
      if (rl_point == 0)
d482 2
a483 4
      p = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);
      c = _rl_char_value (rl_line_buffer, p);

      if (_rl_walphabetic (c) == 0)
d485 1
a485 2
	  rl_point = p;
	  while (rl_point > 0)
d487 2
a488 3
	      p = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);
	      c = _rl_char_value (rl_line_buffer, p);
	      if (_rl_walphabetic (c))
a489 1
	      rl_point = p;
d495 2
a496 3
	  p = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);
	  c = _rl_char_value (rl_line_buffer, p);	  
	  if (_rl_walphabetic (c) == 0)
d499 1
a499 1
	    rl_point = p;
d756 1
d759 1
d775 1
a776 1
#if defined (HANDLE_MULTIBYTE)
a803 2
  rl_begin_undo_group ();

d806 5
d818 1
a818 2
      if (rl_point < rl_end)
	rl_delete (1, c);
a820 2
  rl_end_undo_group ();

d833 3
a835 3
static int
_rl_insert_next (count)
     int count;
d839 4
d848 1
a848 2
  if (RL_ISSTATE (RL_STATE_CALLBACK) == 0)
    _rl_restore_tty_signals ();
a853 39
#if defined (READLINE_CALLBACKS)
static int
_rl_insert_next_callback (data)
     _rl_callback_generic_arg *data;
{
  int count;

  count = data->count;

  /* Deregister function, let rl_callback_read_char deallocate data */
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;
 
  return _rl_insert_next (count);
}
#endif
  
int
rl_quoted_insert (count, key)
     int count, key;
{
  /* Let's see...should the callback interface futz with signal handling? */
#if defined (HANDLE_SIGNALS)
  if (RL_ISSTATE (RL_STATE_CALLBACK) == 0)
    _rl_disable_tty_signals ();
#endif

#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = _rl_callback_data_alloc (count);
      _rl_callback_func = _rl_insert_next_callback;
      return (0);
    }
#endif
      
  return _rl_insert_next (count);
}

d880 1
a880 2
      if (_rl_vi_textmod_command (_rl_vi_last_command) == 0)	/* XXX */
	_rl_vi_reset_last ();
d938 3
a940 6
  if (rl_point < rl_end)
    {
      opoint = rl_point;
      _rl_insert_char (l, ' ');
      rl_point = opoint;
    }
a983 1
  orig_point = rl_point;
d986 7
a992 1
      rl_backward_char (count, key);
d995 1
a995 1
  else if (MB_CUR_MAX == 1 || rl_byte_oriented)
d997 24
a1020 3
      c = rl_line_buffer[--rl_point];
      rl_delete_text (rl_point, orig_point);
      /* The erase-at-end-of-line hack is of questionable merit now. */
a1027 5
  else
    {
      rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);
      rl_delete_text (rl_point, orig_point);
    }
d1038 2
d1052 1
d1056 1
d1059 1
a1059 1
      rl_kill_text (orig_point, rl_point);
d1061 1
d1066 6
a1071 3

      new_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
      rl_delete_text (rl_point, new_point);
a1072 1
  return 0;
a1108 4

  if (rl_point < 0)
    rl_point = 0;

d1202 2
a1203 8
  int start, next, end;
  int inword, c, nc, nop;
#if defined (HANDLE_MULTIBYTE)
  wchar_t wc, nwc;
  char mb[MB_LEN_MAX+1];
  int mblen, p;
  mbstate_t ps;
#endif
a1208 6
  if (op != UpCase && op != DownCase && op != CapCase)
    {
      rl_ding ();
      return -1;
    }

a1211 4
#if defined (HANDLE_MULTIBYTE)
  memset (&ps, 0, sizeof (mbstate_t));
#endif

d1215 1
a1215 2
  inword = 0;
  while (start < end)
d1217 6
a1222 3
      c = _rl_char_value (rl_line_buffer, start);
      /*  This assumes that the upper and lower case versions are the same width. */
      next = MB_NEXTCHAR (rl_line_buffer, start, 1, MB_FIND_NONZERO);
d1224 8
a1231 6
      if (_rl_walphabetic (c) == 0)
	{
	  inword = 0;
	  start = next;
	  continue;
	}
d1233 3
a1235 4
      if (op == CapCase)
	{
	  nop = inword ? DownCase : UpCase;
	  inword = 1;
a1236 24
      else
	nop = op;
      if (MB_CUR_MAX == 1 || rl_byte_oriented || isascii (c))
	{
	  nc = (nop == UpCase) ? _rl_to_upper (c) : _rl_to_lower (c);
	  rl_line_buffer[start] = nc;
	}
#if defined (HANDLE_MULTIBYTE)
      else
	{
	  mbrtowc (&wc, rl_line_buffer + start, end - start, &ps);
	  nwc = (nop == UpCase) ? _rl_to_wupper (wc) : _rl_to_wlower (wc);
	  if  (nwc != wc)	/*  just skip unchanged characters */
	    {
	      mblen = wcrtomb (mb, nwc, &ps);
	      if (mblen > 0)
		mb[mblen] = '\0';
	      /* Assume the same width */
	      strncpy (rl_line_buffer + start, mb, mblen);
	    }
	}
#endif

      start = next;
a1237 1

d1317 1
a1317 1
  int i;
d1321 1
a1321 1
  int char_length, prev_point;
d1336 4
a1339 1
      rl_point = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);
d1343 1
d1345 5
a1349 1
  rl_point = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);
a1482 12
#if defined (READLINE_CALLBACKS)
static int
_rl_char_search_callback (data)
     _rl_callback_generic_arg *data;
{
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

  return (_rl_char_search (data->count, data->i1, data->i2));
}
#endif

a1486 11
#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = _rl_callback_data_alloc (count);
      _rl_callback_data->i1 = FFIND;
      _rl_callback_data->i2 = BFIND;
      _rl_callback_func = _rl_char_search_callback;
      return (0);
    }
#endif
  
a1493 11
#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = _rl_callback_data_alloc (count);
      _rl_callback_data->i1 = BFIND;
      _rl_callback_data->i2 = FFIND;
      _rl_callback_func = _rl_char_search_callback;
      return (0);
    }
#endif

@


1.3
log
@Import of readline 4.3.
Non-readline modified files:

src/gdb/ChangeLog src/gdb/defs.h src/gdb/cli/cli-cmds.c
src/gdb/cli/cli-setshow.c src/gdb/tui/ChangeLog
src/gdb/tui/tuiWin.c

In readline directory:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@@


1.3.44.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.3.2.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2
log
@dummy commit, get CVS off the branch.
@
text
@@


1.2.2.1
log
@2002-08-24  Elena Zannoni  <ezannoni@@redhat.com>

        Import of readline 4.3:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@import of readline-4.3
@
text
@@


1.1.1.2
log
@import of readlilne 5.1
@
text
@d3 1
a3 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
a64 5
#if defined (READLINE_CALLBACKS)
static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
static int _rl_char_search_callback PARAMS((_rl_callback_generic_arg *));
#endif

a172 3
/* Replace the contents of the line buffer between START and END with
   TEXT.  The operation is undoable.  To replace the entire line in an
   undoable mode, use _rl_replace_text(text, 0, rl_end); */
d420 2
a421 1
/* Move forward a word.  We do what Emacs does.  Handles multibyte chars. */
d438 2
a439 3
      c = _rl_char_value (rl_line_buffer, rl_point);

      if (_rl_walphabetic (c) == 0)
d441 1
a441 2
	  rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
	  while (rl_point < rl_end)
d443 2
a444 2
	      c = _rl_char_value (rl_line_buffer, rl_point);
	      if (_rl_walphabetic (c))
a445 1
	      rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
d452 1
a452 2
      rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
      while (rl_point < rl_end)
d454 2
a455 2
	  c = _rl_char_value (rl_line_buffer, rl_point);
	  if (_rl_walphabetic (c) == 0)
a456 1
	  rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
a457 1

d464 1
a464 1
/* Move backward a word.  We do what Emacs does.  Handles multibyte chars. */
d469 1
a469 1
  int c, p;
d476 1
a476 1
      if (rl_point == 0)
d482 2
a483 4
      p = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);
      c = _rl_char_value (rl_line_buffer, p);

      if (_rl_walphabetic (c) == 0)
d485 1
a485 2
	  rl_point = p;
	  while (rl_point > 0)
d487 2
a488 3
	      p = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);
	      c = _rl_char_value (rl_line_buffer, p);
	      if (_rl_walphabetic (c))
a489 1
	      rl_point = p;
d495 2
a496 3
	  p = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);
	  c = _rl_char_value (rl_line_buffer, p);	  
	  if (_rl_walphabetic (c) == 0)
d499 1
a499 1
	    rl_point = p;
d756 1
d759 1
d775 1
a776 1
#if defined (HANDLE_MULTIBYTE)
a803 2
  rl_begin_undo_group ();

d806 5
d818 1
a818 2
      if (rl_point < rl_end)
	rl_delete (1, c);
a820 2
  rl_end_undo_group ();

d833 3
a835 3
static int
_rl_insert_next (count)
     int count;
d839 4
d848 1
a848 2
  if (RL_ISSTATE (RL_STATE_CALLBACK) == 0)
    _rl_restore_tty_signals ();
a853 39
#if defined (READLINE_CALLBACKS)
static int
_rl_insert_next_callback (data)
     _rl_callback_generic_arg *data;
{
  int count;

  count = data->count;

  /* Deregister function, let rl_callback_read_char deallocate data */
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;
 
  return _rl_insert_next (count);
}
#endif
  
int
rl_quoted_insert (count, key)
     int count, key;
{
  /* Let's see...should the callback interface futz with signal handling? */
#if defined (HANDLE_SIGNALS)
  if (RL_ISSTATE (RL_STATE_CALLBACK) == 0)
    _rl_disable_tty_signals ();
#endif

#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = _rl_callback_data_alloc (count);
      _rl_callback_func = _rl_insert_next_callback;
      return (0);
    }
#endif
      
  return _rl_insert_next (count);
}

d880 1
a880 2
      if (_rl_vi_textmod_command (_rl_vi_last_command) == 0)	/* XXX */
	_rl_vi_reset_last ();
d938 3
a940 6
  if (rl_point < rl_end)
    {
      opoint = rl_point;
      _rl_insert_char (l, ' ');
      rl_point = opoint;
    }
a983 1
  orig_point = rl_point;
d986 7
a992 1
      rl_backward_char (count, key);
d995 1
a995 1
  else if (MB_CUR_MAX == 1 || rl_byte_oriented)
d997 24
a1020 3
      c = rl_line_buffer[--rl_point];
      rl_delete_text (rl_point, orig_point);
      /* The erase-at-end-of-line hack is of questionable merit now. */
a1027 5
  else
    {
      rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);
      rl_delete_text (rl_point, orig_point);
    }
d1052 1
d1056 1
d1066 5
a1070 2

      new_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
a1108 4

  if (rl_point < 0)
    rl_point = 0;

d1202 2
a1203 8
  int start, next, end;
  int inword, c, nc, nop;
#if defined (HANDLE_MULTIBYTE)
  wchar_t wc, nwc;
  char mb[MB_LEN_MAX+1];
  int mblen, p;
  mbstate_t ps;
#endif
a1208 6
  if (op != UpCase && op != DownCase && op != CapCase)
    {
      rl_ding ();
      return -1;
    }

a1211 4
#if defined (HANDLE_MULTIBYTE)
  memset (&ps, 0, sizeof (mbstate_t));
#endif

d1215 1
a1215 2
  inword = 0;
  while (start < end)
d1217 10
a1226 3
      c = _rl_char_value (rl_line_buffer, start);
      /*  This assumes that the upper and lower case versions are the same width. */
      next = MB_NEXTCHAR (rl_line_buffer, start, 1, MB_FIND_NONZERO);
d1228 4
a1231 6
      if (_rl_walphabetic (c) == 0)
	{
	  inword = 0;
	  start = next;
	  continue;
	}
d1233 3
a1235 25
      if (op == CapCase)
	{
	  nop = inword ? DownCase : UpCase;
	  inword = 1;
	}
      else
	nop = op;
      if (MB_CUR_MAX == 1 || rl_byte_oriented || isascii (c))
	{
	  nc = (nop == UpCase) ? _rl_to_upper (c) : _rl_to_lower (c);
	  rl_line_buffer[start] = nc;
	}
#if defined (HANDLE_MULTIBYTE)
      else
	{
	  mbrtowc (&wc, rl_line_buffer + start, end - start, &ps);
	  nwc = (nop == UpCase) ? _rl_to_wupper (wc) : _rl_to_wlower (wc);
	  if  (nwc != wc)	/*  just skip unchanged characters */
	    {
	      mblen = wcrtomb (mb, nwc, &ps);
	      if (mblen > 0)
		mb[mblen] = '\0';
	      /* Assume the same width */
	      strncpy (rl_line_buffer + start, mb, mblen);
	    }
a1236 3
#endif

      start = next;
a1237 1

d1317 1
a1317 1
  int i;
d1321 1
a1321 1
  int char_length, prev_point;
d1336 4
a1339 1
      rl_point = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);
d1343 1
d1345 5
a1349 1
  rl_point = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);
a1482 12
#if defined (READLINE_CALLBACKS)
static int
_rl_char_search_callback (data)
     _rl_callback_generic_arg *data;
{
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

  return (_rl_char_search (data->count, data->i1, data->i2));
}
#endif

a1486 11
#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = _rl_callback_data_alloc (count);
      _rl_callback_data->i1 = FFIND;
      _rl_callback_data->i2 = BFIND;
      _rl_callback_func = _rl_char_search_callback;
      return (0);
    }
#endif
  
a1493 11
#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = _rl_callback_data_alloc (count);
      _rl_callback_data->i1 = BFIND;
      _rl_callback_data->i2 = FFIND;
      _rl_callback_func = _rl_char_search_callback;
      return (0);
    }
#endif

@

