head	1.8;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.8
	gdb_7_6-2013-04-26-release:1.8
	gdb_7_6-branch:1.8.0.6
	gdb_7_6-2013-03-12-branchpoint:1.8
	gdb_7_5_1-2012-11-29-release:1.8
	gdb_7_5-2012-08-17-release:1.8
	gdb_7_5-branch:1.8.0.4
	gdb_7_5-2012-07-18-branchpoint:1.8
	gdb_7_4_1-2012-04-26-release:1.8
	gdb_7_4-2012-01-24-release:1.8
	gdb_7_4-branch:1.8.0.2
	gdb_7_4-2011-12-13-branchpoint:1.8
	gdb_7_3_1-2011-09-04-release:1.7
	gdb_7_3-2011-07-26-release:1.7
	gdb_7_3-branch:1.7.0.32
	gdb_7_3-2011-04-01-branchpoint:1.7
	gdb_7_2-2010-09-02-release:1.7
	gdb_7_2-branch:1.7.0.30
	gdb_7_2-2010-07-07-branchpoint:1.7
	gdb_7_1-2010-03-18-release:1.7
	gdb_7_1-branch:1.7.0.28
	gdb_7_1-2010-02-18-branchpoint:1.7
	gdb_7_0_1-2009-12-22-release:1.7
	gdb_7_0-2009-10-06-release:1.7
	gdb_7_0-branch:1.7.0.26
	gdb_7_0-2009-09-16-branchpoint:1.7
	arc-sim-20090309:1.7
	msnyder-checkpoint-072509-branch:1.7.0.24
	msnyder-checkpoint-072509-branchpoint:1.7
	arc-insight_6_8-branch:1.7.0.22
	arc-insight_6_8-branchpoint:1.7
	insight_6_8-branch:1.7.0.20
	insight_6_8-branchpoint:1.7
	reverse-20081226-branch:1.7.0.18
	reverse-20081226-branchpoint:1.7
	multiprocess-20081120-branch:1.7.0.16
	multiprocess-20081120-branchpoint:1.7
	reverse-20080930-branch:1.7.0.14
	reverse-20080930-branchpoint:1.7
	reverse-20080717-branch:1.7.0.12
	reverse-20080717-branchpoint:1.7
	msnyder-reverse-20080609-branch:1.7.0.10
	msnyder-reverse-20080609-branchpoint:1.7
	drow-reverse-20070409-branch:1.7.0.8
	drow-reverse-20070409-branchpoint:1.7
	gdb_6_8-2008-03-27-release:1.7
	gdb_6_8-branch:1.7.0.6
	gdb_6_8-2008-02-26-branchpoint:1.7
	gdb_6_7_1-2007-10-29-release:1.7
	gdb_6_7-2007-10-10-release:1.7
	gdb_6_7-branch:1.7.0.4
	gdb_6_7-2007-09-07-branchpoint:1.7
	insight_6_6-20070208-release:1.7
	gdb_6_6-2006-12-18-release:1.7
	gdb_6_6-branch:1.7.0.2
	gdb_6_6-2006-11-15-branchpoint:1.7
	insight_6_5-20061003-release:1.6
	gdb-csl-symbian-6_4_50_20060226-12:1.4
	gdb-csl-sourcerygxx-3_4_4-25:1.4
	nickrob-async-20060828-mergepoint:1.6
	gdb-csl-symbian-6_4_50_20060226-11:1.4
	gdb-csl-sourcerygxx-4_1-17:1.4
	gdb-csl-20060226-branch-local-2:1.4
	gdb-csl-sourcerygxx-4_1-14:1.4
	gdb-csl-sourcerygxx-4_1-13:1.4
	gdb-csl-sourcerygxx-4_1-12:1.4
	gdb-csl-sourcerygxx-3_4_4-21:1.4
	gdb_6_5-20060621-release:1.6
	gdb-csl-sourcerygxx-4_1-9:1.4
	gdb-csl-sourcerygxx-4_1-8:1.4
	gdb-csl-sourcerygxx-4_1-7:1.4
	gdb-csl-arm-2006q1-6:1.4
	gdb-csl-sourcerygxx-4_1-6:1.4
	gdb-csl-symbian-6_4_50_20060226-10:1.4
	gdb-csl-symbian-6_4_50_20060226-9:1.4
	gdb-csl-symbian-6_4_50_20060226-8:1.4
	gdb-csl-coldfire-4_1-11:1.4
	gdb-csl-sourcerygxx-3_4_4-19:1.4
	gdb-csl-coldfire-4_1-10:1.4
	gdb_6_5-branch:1.6.0.4
	gdb_6_5-2006-05-14-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-5:1.4
	nickrob-async-20060513-branch:1.6.0.2
	nickrob-async-20060513-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-4:1.4
	msnyder-reverse-20060502-branch:1.5.0.4
	msnyder-reverse-20060502-branchpoint:1.5
	gdb-csl-morpho-4_1-4:1.4
	gdb-csl-sourcerygxx-3_4_4-17:1.4
	readline_5_1-import-branch:1.5.0.2
	readline_5_1-import-branchpoint:1.5
	readline-pre-51-import:1.5
	readline_5_1:1.1.1.5
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.4
	gdb-csl-symbian-20060226-branch:1.4.0.78
	gdb-csl-symbian-20060226-branchpoint:1.4
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.4
	msnyder-reverse-20060331-branch:1.4.0.76
	msnyder-reverse-20060331-branchpoint:1.4
	gdb-csl-available-20060303-branch:1.4.0.74
	gdb-csl-available-20060303-branchpoint:1.4
	gdb-csl-20060226-branch:1.4.0.72
	gdb-csl-20060226-branchpoint:1.4
	gdb_6_4-20051202-release:1.4
	msnyder-fork-checkpoint-branch:1.4.0.70
	msnyder-fork-checkpoint-branchpoint:1.4
	gdb-csl-gxxpro-6_3-branch:1.4.0.68
	gdb-csl-gxxpro-6_3-branchpoint:1.4
	gdb_6_4-branch:1.4.0.66
	gdb_6_4-2005-11-01-branchpoint:1.4
	gdb-csl-arm-20051020-branch:1.4.0.64
	gdb-csl-arm-20051020-branchpoint:1.4
	msnyder-tracepoint-checkpoint-branch:1.4.0.62
	msnyder-tracepoint-checkpoint-branchpoint:1.4
	gdb-csl-arm-20050325-2005-q1b:1.4
	gdb-csl-arm-20050325-2005-q1a:1.4
	csl-arm-20050325-branch:1.4.0.60
	csl-arm-20050325-branchpoint:1.4
	gdb_6_3-20041109-release:1.4
	gdb_6_3-branch:1.4.0.56
	gdb_6_3-20041019-branchpoint:1.4
	drow_intercu-merge-20040921:1.4
	drow_intercu-merge-20040915:1.4
	jimb-gdb_6_2-e500-branch:1.4.0.58
	jimb-gdb_6_2-e500-branchpoint:1.4
	gdb_6_2-20040730-release:1.4
	gdb_6_2-branch:1.4.0.54
	gdb_6_2-2004-07-10-gmt-branchpoint:1.4
	gdb_6_1_1-20040616-release:1.4
	gdb_6_1-2004-04-05-release:1.4
	drow_intercu-merge-20040402:1.4
	drow_intercu-merge-20040327:1.4
	ezannoni_pie-20040323-branch:1.4.0.52
	ezannoni_pie-20040323-branchpoint:1.4
	cagney_tramp-20040321-mergepoint:1.4
	cagney_tramp-20040309-branch:1.4.0.50
	cagney_tramp-20040309-branchpoint:1.4
	gdb_6_1-branch:1.4.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.4
	drow_intercu-20040221-branch:1.4.0.46
	drow_intercu-20040221-branchpoint:1.4
	cagney_bfdfile-20040213-branch:1.4.0.44
	cagney_bfdfile-20040213-branchpoint:1.4
	drow-cplus-merge-20040208:1.4
	carlton_dictionary-20040126-merge:1.4
	cagney_bigcore-20040122-branch:1.4.0.42
	cagney_bigcore-20040122-branchpoint:1.4
	drow-cplus-merge-20040113:1.4
	drow-cplus-merge-20031224:1.4
	drow-cplus-merge-20031220:1.4
	carlton_dictionary-20031215-merge:1.4
	drow-cplus-merge-20031214:1.4
	carlton-dictionary-20031111-merge:1.4
	gdb_6_0-2003-10-04-release:1.4
	kettenis_sparc-20030918-branch:1.4.0.40
	kettenis_sparc-20030918-branchpoint:1.4
	carlton_dictionary-20030917-merge:1.4
	ezannoni_pie-20030916-branchpoint:1.4
	ezannoni_pie-20030916-branch:1.4.0.38
	cagney_x86i386-20030821-branch:1.4.0.36
	cagney_x86i386-20030821-branchpoint:1.4
	carlton_dictionary-20030805-merge:1.4
	carlton_dictionary-20030627-merge:1.4
	gdb_6_0-branch:1.4.0.34
	gdb_6_0-2003-06-23-branchpoint:1.4
	jimb-ppc64-linux-20030613-branch:1.4.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.4
	cagney_convert-20030606-branch:1.4.0.30
	cagney_convert-20030606-branchpoint:1.4
	cagney_writestrings-20030508-branch:1.4.0.28
	cagney_writestrings-20030508-branchpoint:1.4
	jimb-ppc64-linux-20030528-branch:1.4.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.4
	carlton_dictionary-20030523-merge:1.4
	cagney_fileio-20030521-branch:1.4.0.24
	cagney_fileio-20030521-branchpoint:1.4
	kettenis_i386newframe-20030517-mergepoint:1.4
	jimb-ppc64-linux-20030509-branch:1.4.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.4
	kettenis_i386newframe-20030504-mergepoint:1.4
	carlton_dictionary-20030430-merge:1.4
	kettenis_i386newframe-20030419-branch:1.4.0.20
	kettenis_i386newframe-20030419-branchpoint:1.4
	carlton_dictionary-20030416-merge:1.4
	cagney_frameaddr-20030409-mergepoint:1.4
	kettenis_i386newframe-20030406-branch:1.4.0.18
	kettenis_i386newframe-20030406-branchpoint:1.4
	cagney_frameaddr-20030403-branchpoint:1.4
	cagney_frameaddr-20030403-branch:1.4.0.16
	cagney_framebase-20030330-mergepoint:1.4
	cagney_framebase-20030326-branch:1.4.0.14
	cagney_framebase-20030326-branchpoint:1.4
	cagney_lazyid-20030317-branch:1.4.0.12
	cagney_lazyid-20030317-branchpoint:1.4
	kettenis-i386newframe-20030316-mergepoint:1.4
	offbyone-20030313-branch:1.4.0.10
	offbyone-20030313-branchpoint:1.4
	kettenis-i386newframe-20030308-branch:1.4.0.8
	kettenis-i386newframe-20030308-branchpoint:1.4
	carlton_dictionary-20030305-merge:1.4
	cagney_offbyone-20030303-branch:1.4.0.6
	cagney_offbyone-20030303-branchpoint:1.4
	carlton_dictionary-20030207-merge:1.4
	interps-20030202-branch:1.4.0.4
	interps-20030202-branchpoint:1.4
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.3
	readline-pre-43-import:1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.24
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	carlton_dictionary-branch:1.3.0.22
	carlton_dictionary-20020920-branchpoint:1.3
	gdb_5_3-branch:1.3.0.20
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.3
	cagney_sysregs-20020825-branch:1.3.0.18
	cagney_sysregs-20020825-branchpoint:1.3
	readline_4_3-import-branch:1.3.0.16
	readline_4_3-import-branchpoint:1.3
	readline_4_3:1.1.1.4
	gdb_5_2_1-2002-07-23-release:1.3
	kseitz_interps-20020528-branch:1.3.0.14
	kseitz_interps-20020528-branchpoint:1.3
	cagney_regbuf-20020515-branch:1.3.0.12
	cagney_regbuf-20020515-branchpoint:1.3
	jimb-macro-020506-branch:1.3.0.10
	jimb-macro-020506-branchpoint:1.3
	gdb_5_2-2002-04-29-release:1.3
	gdb_5_2-branch:1.3.0.8
	gdb_5_2-2002-03-03-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	cygnus_cvs_20020108_pre:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.4
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.2
	gdb_5_1-2001-07-29-branchpoint:1.3
	insight-precleanup-2001-01-01:1.3
	readline_4_1:1.1.1.3
	readline_4_0:1.1.1.2
	FSF:1.1.1
	readline-pre-41-import:1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.8
date	2011.05.11.23.38.39;	author jkratoch;	state Exp;
branches;
next	1.7;

1.7
date	2006.10.21.20.47.07;	author uweigand;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.05.18.26.12;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.20.20.13.20;	author ezannoni;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2002.12.08.22.31.37;	author ezannoni;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.09.17.19.55;	author ezannoni;	state Exp;
branches
	1.3.16.1
	1.3.22.1
	1.3.24.1;
next	1.2;

1.2
date	2000.07.07.17.15.45;	author ezannoni;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.53;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.5.2.1
date	2006.04.24.22.00.25;	author drow;	state Exp;
branches;
next	;

1.3.16.1
date	2002.08.25.23.41.16;	author ezannoni;	state Exp;
branches;
next	;

1.3.22.1
date	2002.12.23.19.39.41;	author carlton;	state Exp;
branches;
next	;

1.3.24.1
date	2003.12.14.20.28.12;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.53;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.08.02.23.47.57;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.07.09.16.21.21;	author ezannoni;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.08.23.22.02.27;	author ezannoni;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.20.20.05.36;	author ezannoni;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Imported readline 6.2, and upstream patch 001.

[patch 0/3] readline-6.2 rebase
http://sourceware.org/ml/gdb-patches/2011-05/msg00003.html
[patch 1/3] readline-6.2: Merge of already posted patches
http://sourceware.org/ml/gdb-patches/2011-05/msg00004.html
	=
	[Bug-readline] [RFC/readline] bind.c, rl_function_dumper, Free allocated
	http://lists.gnu.org/archive/html/bug-readline/2011-03/msg00000.html
	[Bug-readline] [patch] Fix underquotation in readline/examples/rlfe/conf
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00001.html
	[Bug-readline] [patch] Makefile.in htm<->html
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00002.html
	Re: [Bug-readline] [patch] Makefile.in dependency: callback.o: xmalloc.h
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00004.html
	[Bug-readline] [patch] Remove . from the VPATH directive
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00005.html
	Eli Zaretskii's __MSDOS__ / __GO32__ / __MINGW32__ / __DJGPP__ stuff:
	http://sourceware.org/ml/gdb/2011-04/msg00002.html
	Jan Kratochvil's patch for FSF GDB tree local-specific changes:
	http://sourceware.org/ml/gdb/2011-04/msg00006.html
	Preservation of existing ChangeLog.gdb files, their updates.
[patch 2/3] readline-6.2: Workaround "ask" regression
http://sourceware.org/ml/gdb-patches/2011-05/msg00005.html
[patch 3/3] readline-6.2: Revert 5.x compat., apply 6.x compat.
http://sourceware.org/ml/gdb-patches/2011-05/msg00006.html
[patch 4/3] readline-6.2: Substitute inc-hist.texinfo
http://sourceware.org/ml/gdb-patches/2011-05/msg00010.html

readline/
	Workaround gdb.base/completion.exp regression on readline-6.2.
	* complete.c (get_y_or_n): Disable the return on RL_STATE_CALLBACK.

	Imported readline 6.2, and upstream patch 001.
	* configure: Regenerate.

readline/doc/
	* hsuser.texi (Using History Interactively): Disable !BashFeatures
	@@defcodeindex.  Make the `Programming with GNU History' reference
	external.
	* inc-hist.texinfo: Remove.

	Imported readline 6.2, and upstream patch 001.

readline/examples/
	Imported readline 6.2, and upstream patch 001.

readline/examples/rlfe/
	Imported readline 6.2, and upstream patch 001.

gdb/
	* config.in: Regenerate.
	* configure: Regenerate.
	* configure.ac <--with-system-readline> (for readline_echoing_p):
	Remove the test.
	* tui/tui-io.c (tui_old_readline_echoing_p): Rename to ...
	(tui_old_rl_echoing_p): ... here.
	(tui_setup_io): Rename extern declaration readline_echoing_p to
	_rl_echoing_p.  Adjust assignments for the both renames.

gdb/doc/
	* Makefile.in (GDB_DOC_SOURCE_INCLUDES): Rename inc-hist.texinfo to
	hsuser.texi.
	* gdb.texinfo <!SYSTEM_READLINE>: Rename inc-hist.texinfo inclusion and
	comment to hsuser.texi.  Change rluser.texi name in the comment.
@
text
@/* callback.c -- functions to use readline as an X `callback' mechanism. */

/* Copyright (C) 1987-2009 Free Software Foundation, Inc.

   This file is part of the GNU Readline Library (Readline), a library
   for reading lines of text with interactive input and history editing.

   Readline is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Readline is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Readline.  If not, see <http://www.gnu.org/licenses/>.
*/

#define READLINE_LIBRARY

#if defined (HAVE_CONFIG_H)
#  include <config.h>
#endif

#include "rlconf.h"

#if defined (READLINE_CALLBACKS)

#include <sys/types.h>

#ifdef HAVE_STDLIB_H
#  include <stdlib.h>
#else
#  include "ansi_stdlib.h"
#endif

#include <stdio.h>

/* System-specific feature definitions and include files. */
#include "rldefs.h"
#include "readline.h"
#include "rlprivate.h"
#include "xmalloc.h"

/* Private data for callback registration functions.  See comments in
   rl_callback_read_char for more details. */
_rl_callback_func_t *_rl_callback_func = 0;
_rl_callback_generic_arg *_rl_callback_data = 0;

/* **************************************************************** */
/*								    */
/*			Callback Readline Functions		 */
/*								    */
/* **************************************************************** */

/* Allow using readline in situations where a program may have multiple
   things to handle at once, and dispatches them via select().  Call
   rl_callback_handler_install() with the prompt and a function to call
   whenever a complete line of input is ready.  The user must then
   call rl_callback_read_char() every time some input is available, and 
   rl_callback_read_char() will call the user's function with the complete
   text read in at each end of line.  The terminal is kept prepped and
   signals handled all the time, except during calls to the user's function. */

rl_vcpfunc_t *rl_linefunc;		/* user callback function */
static int in_handler;		/* terminal_prepped and signals set? */

/* Make sure the terminal is set up, initialize readline, and prompt. */
static void
_rl_callback_newline ()
{
  rl_initialize ();

  if (in_handler == 0)
    {
      in_handler = 1;

      if (rl_prep_term_function)
	(*rl_prep_term_function) (_rl_meta_flag);

#if defined (HANDLE_SIGNALS)
      rl_set_signals ();
#endif
    }

  readline_internal_setup ();
  RL_CHECK_SIGNALS ();
}

/* Install a readline handler, set up the terminal, and issue the prompt. */
void
rl_callback_handler_install (prompt, linefunc)
     const char *prompt;
     rl_vcpfunc_t *linefunc;
{
  rl_set_prompt (prompt);
  RL_SETSTATE (RL_STATE_CALLBACK);
  rl_linefunc = linefunc;
  _rl_callback_newline ();
}

/* Read one character, and dispatch to the handler if it ends the line. */
void
rl_callback_read_char ()
{
  char *line;
  int eof, jcode;
  static procenv_t olevel;

  if (rl_linefunc == NULL)
    {
      _rl_errmsg ("readline_callback_read_char() called with no handler!");
      abort ();
    }

  memcpy ((void *)olevel, (void *)_rl_top_level, sizeof (procenv_t));
  jcode = setjmp (_rl_top_level);
  if (jcode)
    {
      (*rl_redisplay_function) ();
      _rl_want_redisplay = 0;
      memcpy ((void *)_rl_top_level, (void *)olevel, sizeof (procenv_t));
      return;
    }

  do
    {
      RL_CHECK_SIGNALS ();
      if  (RL_ISSTATE (RL_STATE_ISEARCH))
	{
	  eof = _rl_isearch_callback (_rl_iscxt);
	  if (eof == 0 && (RL_ISSTATE (RL_STATE_ISEARCH) == 0) && RL_ISSTATE (RL_STATE_INPUTPENDING))
	    rl_callback_read_char ();

	  return;
	}
      else if  (RL_ISSTATE (RL_STATE_NSEARCH))
	{
	  eof = _rl_nsearch_callback (_rl_nscxt);
	  return;
	}
#if defined (VI_MODE)
      else if (RL_ISSTATE (RL_STATE_VIMOTION))
	{
	  eof = _rl_vi_domove_callback (_rl_vimvcxt);
	  /* Should handle everything, including cleanup, numeric arguments,
	     and turning off RL_STATE_VIMOTION */
	  if (RL_ISSTATE (RL_STATE_NUMERICARG) == 0)
	    _rl_internal_char_cleanup ();

	  return;
	}
#endif
      else if (RL_ISSTATE (RL_STATE_NUMERICARG))
	{
	  eof = _rl_arg_callback (_rl_argcxt);
	  if (eof == 0 && (RL_ISSTATE (RL_STATE_NUMERICARG) == 0) && RL_ISSTATE (RL_STATE_INPUTPENDING))
	    rl_callback_read_char ();
	  /* XXX - this should handle _rl_last_command_was_kill better */
	  else if (RL_ISSTATE (RL_STATE_NUMERICARG) == 0)
	    _rl_internal_char_cleanup ();

	  return;
	}
      else if (RL_ISSTATE (RL_STATE_MULTIKEY))
	{
	  eof = _rl_dispatch_callback (_rl_kscxt);	/* For now */
	  while ((eof == -1 || eof == -2) && RL_ISSTATE (RL_STATE_MULTIKEY) && _rl_kscxt && (_rl_kscxt->flags & KSEQ_DISPATCHED))
	    eof = _rl_dispatch_callback (_rl_kscxt);
	  if (RL_ISSTATE (RL_STATE_MULTIKEY) == 0)
	    {
	      _rl_internal_char_cleanup ();
	      _rl_want_redisplay = 1;
	    }
	}
      else if (_rl_callback_func)
	{
	  /* This allows functions that simply need to read an additional
	     character (like quoted-insert) to register a function to be
	     called when input is available.  _rl_callback_data is simply a
	     pointer to a struct that has the argument count originally
	     passed to the registering function and space for any additional
	     parameters.  */
	  eof = (*_rl_callback_func) (_rl_callback_data);
	  /* If the function `deregisters' itself, make sure the data is
	     cleaned up. */
	  if (_rl_callback_func == 0)
	    {
	      if (_rl_callback_data) 	
		{
		  _rl_callback_data_dispose (_rl_callback_data);
		  _rl_callback_data = 0;
		}
	      _rl_internal_char_cleanup ();
	    }
	}
      else
	eof = readline_internal_char ();

      RL_CHECK_SIGNALS ();
      if (rl_done == 0 && _rl_want_redisplay)
	{
	  (*rl_redisplay_function) ();
	  _rl_want_redisplay = 0;
	}

      if (rl_done)
	{
	  line = readline_internal_teardown (eof);

	  if (rl_deprep_term_function)
	    (*rl_deprep_term_function) ();
#if defined (HANDLE_SIGNALS)
	  rl_clear_signals ();
#endif
	  in_handler = 0;
	  (*rl_linefunc) (line);

	  /* If the user did not clear out the line, do it for him. */
	  if (rl_line_buffer[0])
	    _rl_init_line_state ();

	  /* Redisplay the prompt if readline_handler_{install,remove}
	     not called. */
	  if (in_handler == 0 && rl_linefunc)
	    _rl_callback_newline ();
	}
    }
  while (rl_pending_input || _rl_pushed_input_available () || RL_ISSTATE (RL_STATE_MACROINPUT));
}

/* Remove the handler, and make sure the terminal is in its normal state. */
void
rl_callback_handler_remove ()
{
  rl_linefunc = NULL;
  RL_UNSETSTATE (RL_STATE_CALLBACK);
  RL_CHECK_SIGNALS ();
  if (in_handler)
    {
      in_handler = 0;
      if (rl_deprep_term_function)
	(*rl_deprep_term_function) ();
#if defined (HANDLE_SIGNALS)
      rl_clear_signals ();
#endif
    }
}

_rl_callback_generic_arg *
_rl_callback_data_alloc (count)
     int count;
{
  _rl_callback_generic_arg *arg;

  arg = (_rl_callback_generic_arg *)xmalloc (sizeof (_rl_callback_generic_arg));
  arg->count = count;

  arg->i1 = arg->i2 = 0;

  return arg;
}

void _rl_callback_data_dispose (arg)
     _rl_callback_generic_arg *arg;
{
  xfree (arg);
}

#endif
@


1.7
log
@	* callback.c: Include "xmalloc.h".
	* Makefile.in: Add dependency.
@
text
@d3 1
a3 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
d5 2
a6 2
   This file is part of the GNU Readline Library, a library for
   reading lines of text with interactive input and history editing.
d8 3
a10 3
   The GNU Readline Library is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2, or
d13 3
a15 3
   The GNU Readline Library is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
d18 4
a21 4
   The GNU General Public License is often shipped with GNU software, and
   is generally kept in a file called COPYING or LICENSE.  If you do not
   have a copy of the license, write to the Free Software Foundation,
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
d90 1
d115 1
a115 1
      fprintf (stderr, "readline: readline_callback_read_char() called with no handler!\r\n");
d119 2
a120 2
  memcpy ((void *)olevel, (void *)readline_top_level, sizeof (procenv_t));
  jcode = setjmp (readline_top_level);
d125 1
a125 1
      memcpy ((void *)readline_top_level, (void *)olevel, sizeof (procenv_t));
d129 1
a129 1
  if  (RL_ISSTATE (RL_STATE_ISEARCH))
d131 6
a136 3
      eof = _rl_isearch_callback (_rl_iscxt);
      if (eof == 0 && (RL_ISSTATE (RL_STATE_ISEARCH) == 0) && RL_ISSTATE (RL_STATE_INPUTPENDING))
	rl_callback_read_char ();
d138 27
a164 15
      return;
    }
  else if  (RL_ISSTATE (RL_STATE_NSEARCH))
    {
      eof = _rl_nsearch_callback (_rl_nscxt);
      return;
    }
  else if (RL_ISSTATE (RL_STATE_NUMERICARG))
    {
      eof = _rl_arg_callback (_rl_argcxt);
      if (eof == 0 && (RL_ISSTATE (RL_STATE_NUMERICARG) == 0) && RL_ISSTATE (RL_STATE_INPUTPENDING))
	rl_callback_read_char ();
      /* XXX - this should handle _rl_last_command_was_kill better */
      else if (RL_ISSTATE (RL_STATE_NUMERICARG) == 0)
	_rl_internal_char_cleanup ();
d166 3
a168 8
      return;
    }
  else if (RL_ISSTATE (RL_STATE_MULTIKEY))
    {
      eof = _rl_dispatch_callback (_rl_kscxt);	/* For now */
      while ((eof == -1 || eof == -2) && RL_ISSTATE (RL_STATE_MULTIKEY) && _rl_kscxt && (_rl_kscxt->flags & KSEQ_DISPATCHED))
	eof = _rl_dispatch_callback (_rl_kscxt);
      if (RL_ISSTATE (RL_STATE_MULTIKEY) == 0)
d170 8
a177 2
	  _rl_internal_char_cleanup ();
	  _rl_want_redisplay = 1;
d179 1
a179 12
    }
  else if (_rl_callback_func)
    {
      /* This allows functions that simply need to read an additional character
	 (like quoted-insert) to register a function to be called when input is
	 available.  _rl_callback_data is simply a pointer to a struct that has
	 the argument count originally passed to the registering function and
	 space for any additional parameters.  */
      eof = (*_rl_callback_func) (_rl_callback_data);
      /* If the function `deregisters' itself, make sure the data is cleaned
	 up. */
      if (_rl_callback_func == 0)
d181 10
a190 1
	  if (_rl_callback_data) 	
d192 6
a197 2
	      _rl_callback_data_dispose (_rl_callback_data);
	      _rl_callback_data = 0;
a198 1
	  _rl_internal_char_cleanup ();
d200 2
a201 3
    }
  else
    eof = readline_internal_char ();
d203 6
a208 5
  if (rl_done == 0 && _rl_want_redisplay)
    {
      (*rl_redisplay_function) ();
      _rl_want_redisplay = 0;
    }
a209 3
  /* We loop in case some function has pushed input back with rl_execute_next. */
  for (;;)
    {
a230 4
      if (rl_pending_input || _rl_pushed_input_available () || RL_ISSTATE (RL_STATE_MACROINPUT))
	eof = readline_internal_char ();
      else
	break;
d232 1
d241 1
d270 1
a270 2
  if (arg)
    free (arg);
@


1.6
log
@Readline 5.1 import for HEAD.
@
text
@d46 1
@


1.5
log
@touched all sources to ease import of readline-5.1
@
text
@d3 1
a3 1
/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
d47 5
d54 1
a54 1
/*			Callback Readline Functions                 */
d80 2
a81 1
      (*rl_prep_term_function) (_rl_meta_flag);
d98 1
d108 2
a109 1
  int eof;
d117 73
a189 1
  eof = readline_internal_char ();
d198 2
a199 1
	  (*rl_deprep_term_function) ();
d215 1
a215 1
      if (rl_pending_input)
d218 1
a218 1
        break;
d227 1
d231 2
a232 1
      (*rl_deprep_term_function) ();
d239 21
@


1.5.2.1
log
@Import readline 5.1 on the branch.
@
text
@d3 1
a3 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
a46 5
/* Private data for callback registration functions.  See comments in
   rl_callback_read_char for more details. */
_rl_callback_func_t *_rl_callback_func = 0;
_rl_callback_generic_arg *_rl_callback_data = 0;

d49 1
a49 1
/*			Callback Readline Functions		 */
d75 1
a75 2
      if (rl_prep_term_function)
	(*rl_prep_term_function) (_rl_meta_flag);
a91 1
  RL_SETSTATE (RL_STATE_CALLBACK);
d101 1
a101 2
  int eof, jcode;
  static procenv_t olevel;
d109 1
a109 73
  memcpy ((void *)olevel, (void *)readline_top_level, sizeof (procenv_t));
  jcode = setjmp (readline_top_level);
  if (jcode)
    {
      (*rl_redisplay_function) ();
      _rl_want_redisplay = 0;
      memcpy ((void *)readline_top_level, (void *)olevel, sizeof (procenv_t));
      return;
    }

  if  (RL_ISSTATE (RL_STATE_ISEARCH))
    {
      eof = _rl_isearch_callback (_rl_iscxt);
      if (eof == 0 && (RL_ISSTATE (RL_STATE_ISEARCH) == 0) && RL_ISSTATE (RL_STATE_INPUTPENDING))
	rl_callback_read_char ();

      return;
    }
  else if  (RL_ISSTATE (RL_STATE_NSEARCH))
    {
      eof = _rl_nsearch_callback (_rl_nscxt);
      return;
    }
  else if (RL_ISSTATE (RL_STATE_NUMERICARG))
    {
      eof = _rl_arg_callback (_rl_argcxt);
      if (eof == 0 && (RL_ISSTATE (RL_STATE_NUMERICARG) == 0) && RL_ISSTATE (RL_STATE_INPUTPENDING))
	rl_callback_read_char ();
      /* XXX - this should handle _rl_last_command_was_kill better */
      else if (RL_ISSTATE (RL_STATE_NUMERICARG) == 0)
	_rl_internal_char_cleanup ();

      return;
    }
  else if (RL_ISSTATE (RL_STATE_MULTIKEY))
    {
      eof = _rl_dispatch_callback (_rl_kscxt);	/* For now */
      while ((eof == -1 || eof == -2) && RL_ISSTATE (RL_STATE_MULTIKEY) && _rl_kscxt && (_rl_kscxt->flags & KSEQ_DISPATCHED))
	eof = _rl_dispatch_callback (_rl_kscxt);
      if (RL_ISSTATE (RL_STATE_MULTIKEY) == 0)
	{
	  _rl_internal_char_cleanup ();
	  _rl_want_redisplay = 1;
	}
    }
  else if (_rl_callback_func)
    {
      /* This allows functions that simply need to read an additional character
	 (like quoted-insert) to register a function to be called when input is
	 available.  _rl_callback_data is simply a pointer to a struct that has
	 the argument count originally passed to the registering function and
	 space for any additional parameters.  */
      eof = (*_rl_callback_func) (_rl_callback_data);
      /* If the function `deregisters' itself, make sure the data is cleaned
	 up. */
      if (_rl_callback_func == 0)
	{
	  if (_rl_callback_data) 	
	    {
	      _rl_callback_data_dispose (_rl_callback_data);
	      _rl_callback_data = 0;
	    }
	  _rl_internal_char_cleanup ();
	}
    }
  else
    eof = readline_internal_char ();

  if (rl_done == 0 && _rl_want_redisplay)
    {
      (*rl_redisplay_function) ();
      _rl_want_redisplay = 0;
    }
d118 1
a118 2
	  if (rl_deprep_term_function)
	    (*rl_deprep_term_function) ();
d134 1
a134 1
      if (rl_pending_input || _rl_pushed_input_available () || RL_ISSTATE (RL_STATE_MACROINPUT))
d137 1
a137 1
	break;
a145 1
  RL_UNSETSTATE (RL_STATE_CALLBACK);
d149 1
a149 2
      if (rl_deprep_term_function)
	(*rl_deprep_term_function) ();
a155 21
_rl_callback_generic_arg *
_rl_callback_data_alloc (count)
     int count;
{
  _rl_callback_generic_arg *arg;

  arg = (_rl_callback_generic_arg *)xmalloc (sizeof (_rl_callback_generic_arg));
  arg->count = count;

  arg->i1 = arg->i2 = 0;

  return arg;
}

void _rl_callback_data_dispose (arg)
     _rl_callback_generic_arg *arg;
{
  if (arg)
    free (arg);
}

@


1.4
log
@Import of readline 4.3.
Non-readline modified files:

src/gdb/ChangeLog src/gdb/defs.h src/gdb/cli/cli-cmds.c
src/gdb/cli/cli-setshow.c src/gdb/tui/ChangeLog
src/gdb/tui/tuiWin.c

In readline directory:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@@


1.3
log
@readline:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Locally modified files: Makefile.in, configure.in, configure
        (regenerated), config.h.in (regenerated), readline.h, rltty.c,
 	shell.c signals.c.

        Locally added files: acconfig.h, config/*, config.h.bot,
        cross-build/*, doc/inc-hit.texinfo.

        New files: USAGE, rlprivate.h, rlshell.h, xmalloc.h.
examples:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        New files: excallback.c, rlfe.c.
doc:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Regenerated inc-hist.texinfo as copy of hsuser.texinfo, for
        inclusion in the gdb manual.

        New file: rluserman.texinfo
@
text
@d33 7
d62 1
a62 1
VFunction *rl_linefunc;		/* user callback function */
d88 2
a89 2
     char *prompt;
     VFunction *linefunc;
d91 1
a91 2
  rl_prompt = prompt;
  rl_visible_prompt_length = rl_prompt ? rl_expand_prompt (rl_prompt) : 0;
d111 2
a112 1
  if (rl_done)
d114 3
a116 1
      line = readline_internal_teardown (eof);
d118 1
a118 1
      (*rl_deprep_term_function) ();
d120 1
a120 1
      rl_clear_signals ();
d122 2
a123 2
      in_handler = 0;
      (*rl_linefunc) (line);
d125 13
a137 7
    /* If the user did not clear out the line, do it for him. */
    if (rl_line_buffer[0])
      _rl_init_line_state ();

    /* Redisplay the prompt if readline_handler_{install,remove} not called. */
      if (in_handler == 0 && rl_linefunc)
	_rl_callback_newline ();
@


1.3.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a32 7

#ifdef HAVE_STDLIB_H
#  include <stdlib.h>
#else
#  include "ansi_stdlib.h"
#endif

d55 1
a55 1
rl_vcpfunc_t *rl_linefunc;		/* user callback function */
d81 2
a82 2
     const char *prompt;
     rl_vcpfunc_t *linefunc;
d84 2
a85 1
  rl_set_prompt (prompt);
d105 1
a105 2
  /* We loop in case some function has pushed input back with rl_execute_next. */
  for (;;)
d107 1
a107 3
      if (rl_done)
	{
	  line = readline_internal_teardown (eof);
d109 1
a109 1
	  (*rl_deprep_term_function) ();
d111 1
a111 1
	  rl_clear_signals ();
d113 2
a114 2
	  in_handler = 0;
	  (*rl_linefunc) (line);
d116 7
a122 13
	  /* If the user did not clear out the line, do it for him. */
	  if (rl_line_buffer[0])
	    _rl_init_line_state ();

	  /* Redisplay the prompt if readline_handler_{install,remove}
	     not called. */
	  if (in_handler == 0 && rl_linefunc)
	    _rl_callback_newline ();
	}
      if (rl_pending_input)
	eof = readline_internal_char ();
      else
        break;
@


1.3.22.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a32 7

#ifdef HAVE_STDLIB_H
#  include <stdlib.h>
#else
#  include "ansi_stdlib.h"
#endif

d55 1
a55 1
rl_vcpfunc_t *rl_linefunc;		/* user callback function */
d81 2
a82 2
     const char *prompt;
     rl_vcpfunc_t *linefunc;
d84 2
a85 1
  rl_set_prompt (prompt);
d105 1
a105 2
  /* We loop in case some function has pushed input back with rl_execute_next. */
  for (;;)
d107 1
a107 3
      if (rl_done)
	{
	  line = readline_internal_teardown (eof);
d109 1
a109 1
	  (*rl_deprep_term_function) ();
d111 1
a111 1
	  rl_clear_signals ();
d113 2
a114 2
	  in_handler = 0;
	  (*rl_linefunc) (line);
d116 7
a122 13
	  /* If the user did not clear out the line, do it for him. */
	  if (rl_line_buffer[0])
	    _rl_init_line_state ();

	  /* Redisplay the prompt if readline_handler_{install,remove}
	     not called. */
	  if (in_handler == 0 && rl_linefunc)
	    _rl_callback_newline ();
	}
      if (rl_pending_input)
	eof = readline_internal_char ();
      else
        break;
@


1.3.16.1
log
@2002-08-24  Elena Zannoni  <ezannoni@@redhat.com>

        Import of readline 4.3:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@a32 7

#ifdef HAVE_STDLIB_H
#  include <stdlib.h>
#else
#  include "ansi_stdlib.h"
#endif

d55 1
a55 1
rl_vcpfunc_t *rl_linefunc;		/* user callback function */
d81 2
a82 2
     const char *prompt;
     rl_vcpfunc_t *linefunc;
d84 2
a85 1
  rl_set_prompt (prompt);
d105 1
a105 2
  /* We loop in case some function has pushed input back with rl_execute_next. */
  for (;;)
d107 1
a107 3
      if (rl_done)
	{
	  line = readline_internal_teardown (eof);
d109 1
a109 1
	  (*rl_deprep_term_function) ();
d111 1
a111 1
	  rl_clear_signals ();
d113 2
a114 2
	  in_handler = 0;
	  (*rl_linefunc) (line);
d116 7
a122 13
	  /* If the user did not clear out the line, do it for him. */
	  if (rl_line_buffer[0])
	    _rl_init_line_state ();

	  /* Redisplay the prompt if readline_handler_{install,remove}
	     not called. */
	  if (in_handler == 0 && rl_linefunc)
	    _rl_callback_newline ();
	}
      if (rl_pending_input)
	eof = readline_internal_char ();
      else
        break;
@


1.2
log
@Dummy commit before importof 4.1 version
@
text
@d10 1
a10 1
   as published by the Free Software Foundation; either version 1, or
d21 1
a21 1
   675 Mass Ave, Cambridge, MA 02139, USA. */
d38 1
a38 9

extern void readline_internal_setup ();
extern char *readline_internal_teardown ();
extern int readline_internal_char ();
extern void _rl_init_line_state ();

extern int _rl_meta_flag;
extern char *rl_prompt;
extern int rl_visible_prompt_length;
@


1.1
log
@Initial revision
@
text
@d39 1
a39 1
extern void readline_internal_startup ();
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-08-02 snapshot
@
text
@d39 1
a39 1
extern void readline_internal_setup ();
@


1.1.1.3
log
@Import of readline 4.1
@
text
@d10 1
a10 1
   as published by the Free Software Foundation; either version 2, or
d21 1
a21 1
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
d38 9
a46 1
#include "rlprivate.h"
@


1.1.1.4
log
@import of readline-4.3
@
text
@a32 7

#ifdef HAVE_STDLIB_H
#  include <stdlib.h>
#else
#  include "ansi_stdlib.h"
#endif

d55 1
a55 1
rl_vcpfunc_t *rl_linefunc;		/* user callback function */
d81 2
a82 2
     const char *prompt;
     rl_vcpfunc_t *linefunc;
d84 2
a85 1
  rl_set_prompt (prompt);
d105 1
a105 2
  /* We loop in case some function has pushed input back with rl_execute_next. */
  for (;;)
d107 1
a107 3
      if (rl_done)
	{
	  line = readline_internal_teardown (eof);
d109 1
a109 1
	  (*rl_deprep_term_function) ();
d111 1
a111 1
	  rl_clear_signals ();
d113 2
a114 2
	  in_handler = 0;
	  (*rl_linefunc) (line);
d116 7
a122 13
	  /* If the user did not clear out the line, do it for him. */
	  if (rl_line_buffer[0])
	    _rl_init_line_state ();

	  /* Redisplay the prompt if readline_handler_{install,remove}
	     not called. */
	  if (in_handler == 0 && rl_linefunc)
	    _rl_callback_newline ();
	}
      if (rl_pending_input)
	eof = readline_internal_char ();
      else
        break;
@


1.1.1.5
log
@import of readlilne 5.1
@
text
@d3 1
a3 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
a46 5
/* Private data for callback registration functions.  See comments in
   rl_callback_read_char for more details. */
_rl_callback_func_t *_rl_callback_func = 0;
_rl_callback_generic_arg *_rl_callback_data = 0;

d49 1
a49 1
/*			Callback Readline Functions		 */
d75 1
a75 2
      if (rl_prep_term_function)
	(*rl_prep_term_function) (_rl_meta_flag);
a91 1
  RL_SETSTATE (RL_STATE_CALLBACK);
d101 1
a101 2
  int eof, jcode;
  static procenv_t olevel;
d109 1
a109 73
  memcpy ((void *)olevel, (void *)readline_top_level, sizeof (procenv_t));
  jcode = setjmp (readline_top_level);
  if (jcode)
    {
      (*rl_redisplay_function) ();
      _rl_want_redisplay = 0;
      memcpy ((void *)readline_top_level, (void *)olevel, sizeof (procenv_t));
      return;
    }

  if  (RL_ISSTATE (RL_STATE_ISEARCH))
    {
      eof = _rl_isearch_callback (_rl_iscxt);
      if (eof == 0 && (RL_ISSTATE (RL_STATE_ISEARCH) == 0) && RL_ISSTATE (RL_STATE_INPUTPENDING))
	rl_callback_read_char ();

      return;
    }
  else if  (RL_ISSTATE (RL_STATE_NSEARCH))
    {
      eof = _rl_nsearch_callback (_rl_nscxt);
      return;
    }
  else if (RL_ISSTATE (RL_STATE_NUMERICARG))
    {
      eof = _rl_arg_callback (_rl_argcxt);
      if (eof == 0 && (RL_ISSTATE (RL_STATE_NUMERICARG) == 0) && RL_ISSTATE (RL_STATE_INPUTPENDING))
	rl_callback_read_char ();
      /* XXX - this should handle _rl_last_command_was_kill better */
      else if (RL_ISSTATE (RL_STATE_NUMERICARG) == 0)
	_rl_internal_char_cleanup ();

      return;
    }
  else if (RL_ISSTATE (RL_STATE_MULTIKEY))
    {
      eof = _rl_dispatch_callback (_rl_kscxt);	/* For now */
      while ((eof == -1 || eof == -2) && RL_ISSTATE (RL_STATE_MULTIKEY) && _rl_kscxt && (_rl_kscxt->flags & KSEQ_DISPATCHED))
	eof = _rl_dispatch_callback (_rl_kscxt);
      if (RL_ISSTATE (RL_STATE_MULTIKEY) == 0)
	{
	  _rl_internal_char_cleanup ();
	  _rl_want_redisplay = 1;
	}
    }
  else if (_rl_callback_func)
    {
      /* This allows functions that simply need to read an additional character
	 (like quoted-insert) to register a function to be called when input is
	 available.  _rl_callback_data is simply a pointer to a struct that has
	 the argument count originally passed to the registering function and
	 space for any additional parameters.  */
      eof = (*_rl_callback_func) (_rl_callback_data);
      /* If the function `deregisters' itself, make sure the data is cleaned
	 up. */
      if (_rl_callback_func == 0)
	{
	  if (_rl_callback_data) 	
	    {
	      _rl_callback_data_dispose (_rl_callback_data);
	      _rl_callback_data = 0;
	    }
	  _rl_internal_char_cleanup ();
	}
    }
  else
    eof = readline_internal_char ();

  if (rl_done == 0 && _rl_want_redisplay)
    {
      (*rl_redisplay_function) ();
      _rl_want_redisplay = 0;
    }
d118 1
a118 2
	  if (rl_deprep_term_function)
	    (*rl_deprep_term_function) ();
d134 1
a134 1
      if (rl_pending_input || _rl_pushed_input_available () || RL_ISSTATE (RL_STATE_MACROINPUT))
d137 1
a137 1
	break;
a145 1
  RL_UNSETSTATE (RL_STATE_CALLBACK);
d149 1
a149 2
      if (rl_deprep_term_function)
	(*rl_deprep_term_function) ();
a155 21
_rl_callback_generic_arg *
_rl_callback_data_alloc (count)
     int count;
{
  _rl_callback_generic_arg *arg;

  arg = (_rl_callback_generic_arg *)xmalloc (sizeof (_rl_callback_generic_arg));
  arg->count = count;

  arg->i1 = arg->i2 = 0;

  return arg;
}

void _rl_callback_data_dispose (arg)
     _rl_callback_generic_arg *arg;
{
  if (arg)
    free (arg);
}

@


