head	1.7;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.7
	gdb_7_6-2013-04-26-release:1.7
	gdb_7_6-branch:1.7.0.6
	gdb_7_6-2013-03-12-branchpoint:1.7
	gdb_7_5_1-2012-11-29-release:1.7
	gdb_7_5-2012-08-17-release:1.7
	gdb_7_5-branch:1.7.0.4
	gdb_7_5-2012-07-18-branchpoint:1.7
	gdb_7_4_1-2012-04-26-release:1.7
	gdb_7_4-2012-01-24-release:1.7
	gdb_7_4-branch:1.7.0.2
	gdb_7_4-2011-12-13-branchpoint:1.7
	gdb_7_3_1-2011-09-04-release:1.6
	gdb_7_3-2011-07-26-release:1.6
	gdb_7_3-branch:1.6.0.36
	gdb_7_3-2011-04-01-branchpoint:1.6
	gdb_7_2-2010-09-02-release:1.6
	gdb_7_2-branch:1.6.0.34
	gdb_7_2-2010-07-07-branchpoint:1.6
	gdb_7_1-2010-03-18-release:1.6
	gdb_7_1-branch:1.6.0.32
	gdb_7_1-2010-02-18-branchpoint:1.6
	gdb_7_0_1-2009-12-22-release:1.6
	gdb_7_0-2009-10-06-release:1.6
	gdb_7_0-branch:1.6.0.30
	gdb_7_0-2009-09-16-branchpoint:1.6
	arc-sim-20090309:1.6
	msnyder-checkpoint-072509-branch:1.6.0.28
	msnyder-checkpoint-072509-branchpoint:1.6
	arc-insight_6_8-branch:1.6.0.26
	arc-insight_6_8-branchpoint:1.6
	insight_6_8-branch:1.6.0.24
	insight_6_8-branchpoint:1.6
	reverse-20081226-branch:1.6.0.22
	reverse-20081226-branchpoint:1.6
	multiprocess-20081120-branch:1.6.0.20
	multiprocess-20081120-branchpoint:1.6
	reverse-20080930-branch:1.6.0.18
	reverse-20080930-branchpoint:1.6
	reverse-20080717-branch:1.6.0.16
	reverse-20080717-branchpoint:1.6
	msnyder-reverse-20080609-branch:1.6.0.14
	msnyder-reverse-20080609-branchpoint:1.6
	drow-reverse-20070409-branch:1.6.0.12
	drow-reverse-20070409-branchpoint:1.6
	gdb_6_8-2008-03-27-release:1.6
	gdb_6_8-branch:1.6.0.10
	gdb_6_8-2008-02-26-branchpoint:1.6
	gdb_6_7_1-2007-10-29-release:1.6
	gdb_6_7-2007-10-10-release:1.6
	gdb_6_7-branch:1.6.0.8
	gdb_6_7-2007-09-07-branchpoint:1.6
	insight_6_6-20070208-release:1.6
	gdb_6_6-2006-12-18-release:1.6
	gdb_6_6-branch:1.6.0.6
	gdb_6_6-2006-11-15-branchpoint:1.6
	insight_6_5-20061003-release:1.6
	gdb-csl-symbian-6_4_50_20060226-12:1.4
	gdb-csl-sourcerygxx-3_4_4-25:1.4
	nickrob-async-20060828-mergepoint:1.6
	gdb-csl-symbian-6_4_50_20060226-11:1.4
	gdb-csl-sourcerygxx-4_1-17:1.4
	gdb-csl-20060226-branch-local-2:1.4
	gdb-csl-sourcerygxx-4_1-14:1.4
	gdb-csl-sourcerygxx-4_1-13:1.4
	gdb-csl-sourcerygxx-4_1-12:1.4
	gdb-csl-sourcerygxx-3_4_4-21:1.4
	gdb_6_5-20060621-release:1.6
	gdb-csl-sourcerygxx-4_1-9:1.4
	gdb-csl-sourcerygxx-4_1-8:1.4
	gdb-csl-sourcerygxx-4_1-7:1.4
	gdb-csl-arm-2006q1-6:1.4
	gdb-csl-sourcerygxx-4_1-6:1.4
	gdb-csl-symbian-6_4_50_20060226-10:1.4
	gdb-csl-symbian-6_4_50_20060226-9:1.4
	gdb-csl-symbian-6_4_50_20060226-8:1.4
	gdb-csl-coldfire-4_1-11:1.4
	gdb-csl-sourcerygxx-3_4_4-19:1.4
	gdb-csl-coldfire-4_1-10:1.4
	gdb_6_5-branch:1.6.0.4
	gdb_6_5-2006-05-14-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-5:1.4
	nickrob-async-20060513-branch:1.6.0.2
	nickrob-async-20060513-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-4:1.4
	msnyder-reverse-20060502-branch:1.5.0.4
	msnyder-reverse-20060502-branchpoint:1.5
	gdb-csl-morpho-4_1-4:1.4
	gdb-csl-sourcerygxx-3_4_4-17:1.4
	readline_5_1-import-branch:1.5.0.2
	readline_5_1-import-branchpoint:1.5
	readline-pre-51-import:1.5
	readline_5_1:1.1.1.5
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.4
	gdb-csl-symbian-20060226-branch:1.4.0.78
	gdb-csl-symbian-20060226-branchpoint:1.4
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.4
	msnyder-reverse-20060331-branch:1.4.0.76
	msnyder-reverse-20060331-branchpoint:1.4
	gdb-csl-available-20060303-branch:1.4.0.74
	gdb-csl-available-20060303-branchpoint:1.4
	gdb-csl-20060226-branch:1.4.0.72
	gdb-csl-20060226-branchpoint:1.4
	gdb_6_4-20051202-release:1.4
	msnyder-fork-checkpoint-branch:1.4.0.70
	msnyder-fork-checkpoint-branchpoint:1.4
	gdb-csl-gxxpro-6_3-branch:1.4.0.68
	gdb-csl-gxxpro-6_3-branchpoint:1.4
	gdb_6_4-branch:1.4.0.66
	gdb_6_4-2005-11-01-branchpoint:1.4
	gdb-csl-arm-20051020-branch:1.4.0.64
	gdb-csl-arm-20051020-branchpoint:1.4
	msnyder-tracepoint-checkpoint-branch:1.4.0.62
	msnyder-tracepoint-checkpoint-branchpoint:1.4
	gdb-csl-arm-20050325-2005-q1b:1.4
	gdb-csl-arm-20050325-2005-q1a:1.4
	csl-arm-20050325-branch:1.4.0.60
	csl-arm-20050325-branchpoint:1.4
	gdb_6_3-20041109-release:1.4
	gdb_6_3-branch:1.4.0.56
	gdb_6_3-20041019-branchpoint:1.4
	drow_intercu-merge-20040921:1.4
	drow_intercu-merge-20040915:1.4
	jimb-gdb_6_2-e500-branch:1.4.0.58
	jimb-gdb_6_2-e500-branchpoint:1.4
	gdb_6_2-20040730-release:1.4
	gdb_6_2-branch:1.4.0.54
	gdb_6_2-2004-07-10-gmt-branchpoint:1.4
	gdb_6_1_1-20040616-release:1.4
	gdb_6_1-2004-04-05-release:1.4
	drow_intercu-merge-20040402:1.4
	drow_intercu-merge-20040327:1.4
	ezannoni_pie-20040323-branch:1.4.0.52
	ezannoni_pie-20040323-branchpoint:1.4
	cagney_tramp-20040321-mergepoint:1.4
	cagney_tramp-20040309-branch:1.4.0.50
	cagney_tramp-20040309-branchpoint:1.4
	gdb_6_1-branch:1.4.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.4
	drow_intercu-20040221-branch:1.4.0.46
	drow_intercu-20040221-branchpoint:1.4
	cagney_bfdfile-20040213-branch:1.4.0.44
	cagney_bfdfile-20040213-branchpoint:1.4
	drow-cplus-merge-20040208:1.4
	carlton_dictionary-20040126-merge:1.4
	cagney_bigcore-20040122-branch:1.4.0.42
	cagney_bigcore-20040122-branchpoint:1.4
	drow-cplus-merge-20040113:1.4
	drow-cplus-merge-20031224:1.4
	drow-cplus-merge-20031220:1.4
	carlton_dictionary-20031215-merge:1.4
	drow-cplus-merge-20031214:1.4
	carlton-dictionary-20031111-merge:1.4
	gdb_6_0-2003-10-04-release:1.4
	kettenis_sparc-20030918-branch:1.4.0.40
	kettenis_sparc-20030918-branchpoint:1.4
	carlton_dictionary-20030917-merge:1.4
	ezannoni_pie-20030916-branchpoint:1.4
	ezannoni_pie-20030916-branch:1.4.0.38
	cagney_x86i386-20030821-branch:1.4.0.36
	cagney_x86i386-20030821-branchpoint:1.4
	carlton_dictionary-20030805-merge:1.4
	carlton_dictionary-20030627-merge:1.4
	gdb_6_0-branch:1.4.0.34
	gdb_6_0-2003-06-23-branchpoint:1.4
	jimb-ppc64-linux-20030613-branch:1.4.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.4
	cagney_convert-20030606-branch:1.4.0.30
	cagney_convert-20030606-branchpoint:1.4
	cagney_writestrings-20030508-branch:1.4.0.28
	cagney_writestrings-20030508-branchpoint:1.4
	jimb-ppc64-linux-20030528-branch:1.4.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.4
	carlton_dictionary-20030523-merge:1.4
	cagney_fileio-20030521-branch:1.4.0.24
	cagney_fileio-20030521-branchpoint:1.4
	kettenis_i386newframe-20030517-mergepoint:1.4
	jimb-ppc64-linux-20030509-branch:1.4.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.4
	kettenis_i386newframe-20030504-mergepoint:1.4
	carlton_dictionary-20030430-merge:1.4
	kettenis_i386newframe-20030419-branch:1.4.0.20
	kettenis_i386newframe-20030419-branchpoint:1.4
	carlton_dictionary-20030416-merge:1.4
	cagney_frameaddr-20030409-mergepoint:1.4
	kettenis_i386newframe-20030406-branch:1.4.0.18
	kettenis_i386newframe-20030406-branchpoint:1.4
	cagney_frameaddr-20030403-branchpoint:1.4
	cagney_frameaddr-20030403-branch:1.4.0.16
	cagney_framebase-20030330-mergepoint:1.4
	cagney_framebase-20030326-branch:1.4.0.14
	cagney_framebase-20030326-branchpoint:1.4
	cagney_lazyid-20030317-branch:1.4.0.12
	cagney_lazyid-20030317-branchpoint:1.4
	kettenis-i386newframe-20030316-mergepoint:1.4
	offbyone-20030313-branch:1.4.0.10
	offbyone-20030313-branchpoint:1.4
	kettenis-i386newframe-20030308-branch:1.4.0.8
	kettenis-i386newframe-20030308-branchpoint:1.4
	carlton_dictionary-20030305-merge:1.4
	cagney_offbyone-20030303-branch:1.4.0.6
	cagney_offbyone-20030303-branchpoint:1.4
	carlton_dictionary-20030207-merge:1.4
	interps-20030202-branch:1.4.0.4
	interps-20030202-branchpoint:1.4
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.3
	readline-pre-43-import:1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.24
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	carlton_dictionary-branch:1.3.0.22
	carlton_dictionary-20020920-branchpoint:1.3
	gdb_5_3-branch:1.3.0.20
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.3
	cagney_sysregs-20020825-branch:1.3.0.18
	cagney_sysregs-20020825-branchpoint:1.3
	readline_4_3-import-branch:1.3.0.16
	readline_4_3-import-branchpoint:1.3
	readline_4_3:1.1.1.4
	gdb_5_2_1-2002-07-23-release:1.3
	kseitz_interps-20020528-branch:1.3.0.14
	kseitz_interps-20020528-branchpoint:1.3
	cagney_regbuf-20020515-branch:1.3.0.12
	cagney_regbuf-20020515-branchpoint:1.3
	jimb-macro-020506-branch:1.3.0.10
	jimb-macro-020506-branchpoint:1.3
	gdb_5_2-2002-04-29-release:1.3
	gdb_5_2-branch:1.3.0.8
	gdb_5_2-2002-03-03-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	cygnus_cvs_20020108_pre:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.4
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.2
	gdb_5_1-2001-07-29-branchpoint:1.3
	insight-precleanup-2001-01-01:1.3
	readline_4_1:1.1.1.3
	readline_4_0:1.1.1.2
	FSF:1.1.1
	readline-pre-41-import:1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.7
date	2011.05.11.23.38.39;	author jkratoch;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.05.18.26.12;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.20.20.13.20;	author ezannoni;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2002.12.08.22.31.37;	author ezannoni;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.09.17.19.56;	author ezannoni;	state Exp;
branches
	1.3.16.1
	1.3.22.1
	1.3.24.1;
next	1.2;

1.2
date	2000.07.07.17.15.45;	author ezannoni;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.53;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.5.2.1
date	2006.04.24.22.00.25;	author drow;	state Exp;
branches;
next	;

1.3.16.1
date	2002.08.25.23.41.17;	author ezannoni;	state Exp;
branches;
next	;

1.3.22.1
date	2002.12.23.19.39.43;	author carlton;	state Exp;
branches;
next	;

1.3.24.1
date	2003.12.14.20.28.14;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.53;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.08.02.23.47.58;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.07.09.16.21.21;	author ezannoni;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.08.23.22.02.28;	author ezannoni;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.20.20.05.38;	author ezannoni;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Imported readline 6.2, and upstream patch 001.

[patch 0/3] readline-6.2 rebase
http://sourceware.org/ml/gdb-patches/2011-05/msg00003.html
[patch 1/3] readline-6.2: Merge of already posted patches
http://sourceware.org/ml/gdb-patches/2011-05/msg00004.html
	=
	[Bug-readline] [RFC/readline] bind.c, rl_function_dumper, Free allocated
	http://lists.gnu.org/archive/html/bug-readline/2011-03/msg00000.html
	[Bug-readline] [patch] Fix underquotation in readline/examples/rlfe/conf
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00001.html
	[Bug-readline] [patch] Makefile.in htm<->html
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00002.html
	Re: [Bug-readline] [patch] Makefile.in dependency: callback.o: xmalloc.h
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00004.html
	[Bug-readline] [patch] Remove . from the VPATH directive
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00005.html
	Eli Zaretskii's __MSDOS__ / __GO32__ / __MINGW32__ / __DJGPP__ stuff:
	http://sourceware.org/ml/gdb/2011-04/msg00002.html
	Jan Kratochvil's patch for FSF GDB tree local-specific changes:
	http://sourceware.org/ml/gdb/2011-04/msg00006.html
	Preservation of existing ChangeLog.gdb files, their updates.
[patch 2/3] readline-6.2: Workaround "ask" regression
http://sourceware.org/ml/gdb-patches/2011-05/msg00005.html
[patch 3/3] readline-6.2: Revert 5.x compat., apply 6.x compat.
http://sourceware.org/ml/gdb-patches/2011-05/msg00006.html
[patch 4/3] readline-6.2: Substitute inc-hist.texinfo
http://sourceware.org/ml/gdb-patches/2011-05/msg00010.html

readline/
	Workaround gdb.base/completion.exp regression on readline-6.2.
	* complete.c (get_y_or_n): Disable the return on RL_STATE_CALLBACK.

	Imported readline 6.2, and upstream patch 001.
	* configure: Regenerate.

readline/doc/
	* hsuser.texi (Using History Interactively): Disable !BashFeatures
	@@defcodeindex.  Make the `Programming with GNU History' reference
	external.
	* inc-hist.texinfo: Remove.

	Imported readline 6.2, and upstream patch 001.

readline/examples/
	Imported readline 6.2, and upstream patch 001.

readline/examples/rlfe/
	Imported readline 6.2, and upstream patch 001.

gdb/
	* config.in: Regenerate.
	* configure: Regenerate.
	* configure.ac <--with-system-readline> (for readline_echoing_p):
	Remove the test.
	* tui/tui-io.c (tui_old_readline_echoing_p): Rename to ...
	(tui_old_rl_echoing_p): ... here.
	(tui_setup_io): Rename extern declaration readline_echoing_p to
	_rl_echoing_p.  Adjust assignments for the both renames.

gdb/doc/
	* Makefile.in (GDB_DOC_SOURCE_INCLUDES): Rename inc-hist.texinfo to
	hsuser.texi.
	* gdb.texinfo <!SYSTEM_READLINE>: Rename inc-hist.texinfo inclusion and
	comment to hsuser.texi.  Change rluser.texi name in the comment.
@
text
@/* history.c -- standalone history library */

/* Copyright (C) 1989-2009 Free Software Foundation, Inc.

   This file contains the GNU History Library (History), a set of
   routines for managing the text of previously typed lines.

   History is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   History is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with History.  If not, see <http://www.gnu.org/licenses/>.
*/

/* The goal is to make the implementation transparent, so that you
   don't have to know what data types are used, just what functions
   you can call.  I think I have done that. */
#define READLINE_LIBRARY

#if defined (HAVE_CONFIG_H)
#  include <config.h>
#endif

#include <stdio.h>

#if defined (HAVE_STDLIB_H)
#  include <stdlib.h>
#else
#  include "ansi_stdlib.h"
#endif /* HAVE_STDLIB_H */

#if defined (HAVE_UNISTD_H)
#  ifdef _MINIX
#    include <sys/types.h>
#  endif
#  include <unistd.h>
#endif

#include "history.h"
#include "histlib.h"

#include "xmalloc.h"

/* The number of slots to increase the_history by. */
#define DEFAULT_HISTORY_GROW_SIZE 50

static char *hist_inittime PARAMS((void));

/* **************************************************************** */
/*								    */
/*			History Functions			    */
/*								    */
/* **************************************************************** */

/* An array of HIST_ENTRY.  This is where we store the history. */
static HIST_ENTRY **the_history = (HIST_ENTRY **)NULL;

/* Non-zero means that we have enforced a limit on the amount of
   history that we save. */
static int history_stifled;

/* The current number of slots allocated to the input_history. */
static int history_size;

/* If HISTORY_STIFLED is non-zero, then this is the maximum number of
   entries to remember. */
int history_max_entries;
int max_input_history;	/* backwards compatibility */

/* The current location of the interactive history pointer.  Just makes
   life easier for outside callers. */
int history_offset;

/* The number of strings currently stored in the history list. */
int history_length;

/* The logical `base' of the history array.  It defaults to 1. */
int history_base = 1;

/* Return the current HISTORY_STATE of the history. */
HISTORY_STATE *
history_get_history_state ()
{
  HISTORY_STATE *state;

  state = (HISTORY_STATE *)xmalloc (sizeof (HISTORY_STATE));
  state->entries = the_history;
  state->offset = history_offset;
  state->length = history_length;
  state->size = history_size;
  state->flags = 0;
  if (history_stifled)
    state->flags |= HS_STIFLED;

  return (state);
}

/* Set the state of the current history array to STATE. */
void
history_set_history_state (state)
     HISTORY_STATE *state;
{
  the_history = state->entries;
  history_offset = state->offset;
  history_length = state->length;
  history_size = state->size;
  if (state->flags & HS_STIFLED)
    history_stifled = 1;
}

/* Begin a session in which the history functions might be used.  This
   initializes interactive variables. */
void
using_history ()
{
  history_offset = history_length;
}

/* Return the number of bytes that the primary history entries are using.
   This just adds up the lengths of the_history->lines and the associated
   timestamps. */
int
history_total_bytes ()
{
  register int i, result;

  for (i = result = 0; the_history && the_history[i]; i++)
    result += HISTENT_BYTES (the_history[i]);

  return (result);
}

/* Returns the magic number which says what history element we are
   looking at now.  In this implementation, it returns history_offset. */
int
where_history ()
{
  return (history_offset);
}

/* Make the current history item be the one at POS, an absolute index.
   Returns zero if POS is out of range, else non-zero. */
int
history_set_pos (pos)
     int pos;
{
  if (pos > history_length || pos < 0 || !the_history)
    return (0);
  history_offset = pos;
  return (1);
}
 
/* Return the current history array.  The caller has to be careful, since this
   is the actual array of data, and could be bashed or made corrupt easily.
   The array is terminated with a NULL pointer. */
HIST_ENTRY **
history_list ()
{
  return (the_history);
}

/* Return the history entry at the current position, as determined by
   history_offset.  If there is no entry there, return a NULL pointer. */
HIST_ENTRY *
current_history ()
{
  return ((history_offset == history_length) || the_history == 0)
		? (HIST_ENTRY *)NULL
		: the_history[history_offset];
}

/* Back up history_offset to the previous history entry, and return
   a pointer to that entry.  If there is no previous entry then return
   a NULL pointer. */
HIST_ENTRY *
previous_history ()
{
  return history_offset ? the_history[--history_offset] : (HIST_ENTRY *)NULL;
}

/* Move history_offset forward to the next history entry, and return
   a pointer to that entry.  If there is no next entry then return a
   NULL pointer. */
HIST_ENTRY *
next_history ()
{
  return (history_offset == history_length) ? (HIST_ENTRY *)NULL : the_history[++history_offset];
}

/* Return the history entry which is logically at OFFSET in the history array.
   OFFSET is relative to history_base. */
HIST_ENTRY *
history_get (offset)
     int offset;
{
  int local_index;

  local_index = offset - history_base;
  return (local_index >= history_length || local_index < 0 || the_history == 0)
		? (HIST_ENTRY *)NULL
		: the_history[local_index];
}

HIST_ENTRY *
alloc_history_entry (string, ts)
     char *string;
     char *ts;
{
  HIST_ENTRY *temp;

  temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));

  temp->line = string ? savestring (string) : string;
  temp->data = (char *)NULL;
  temp->timestamp = ts;

  return temp;
}

time_t
history_get_time (hist)
     HIST_ENTRY *hist;
{
  char *ts;
  time_t t;

  if (hist == 0 || hist->timestamp == 0)
    return 0;
  ts = hist->timestamp;
  if (ts[0] != history_comment_char)
    return 0;
  t = (time_t) atol (ts + 1);		/* XXX - should use strtol() here */
  return t;
}

static char *
hist_inittime ()
{
  time_t t;
  char ts[64], *ret;

  t = (time_t) time ((time_t *)0);
#if defined (HAVE_VSNPRINTF)		/* assume snprintf if vsnprintf exists */
  snprintf (ts, sizeof (ts) - 1, "X%lu", (unsigned long) t);
#else
  sprintf (ts, "X%lu", (unsigned long) t);
#endif
  ret = savestring (ts);
  ret[0] = history_comment_char;

  return ret;
}

/* Place STRING at the end of the history list.  The data field
   is  set to NULL. */
void
add_history (string)
     const char *string;
{
  HIST_ENTRY *temp;

  if (history_stifled && (history_length == history_max_entries))
    {
      register int i;

      /* If the history is stifled, and history_length is zero,
	 and it equals history_max_entries, we don't save items. */
      if (history_length == 0)
	return;

      /* If there is something in the slot, then remove it. */
      if (the_history[0])
	(void) free_history_entry (the_history[0]);

      /* Copy the rest of the entries, moving down one slot. */
      for (i = 0; i < history_length; i++)
	the_history[i] = the_history[i + 1];

      history_base++;
    }
  else
    {
      if (history_size == 0)
	{
	  history_size = DEFAULT_HISTORY_GROW_SIZE;
	  the_history = (HIST_ENTRY **)xmalloc (history_size * sizeof (HIST_ENTRY *));
	  history_length = 1;
	}
      else
	{
	  if (history_length == (history_size - 1))
	    {
	      history_size += DEFAULT_HISTORY_GROW_SIZE;
	      the_history = (HIST_ENTRY **)
		xrealloc (the_history, history_size * sizeof (HIST_ENTRY *));
	    }
	  history_length++;
	}
    }

  temp = alloc_history_entry (string, hist_inittime ());

  the_history[history_length] = (HIST_ENTRY *)NULL;
  the_history[history_length - 1] = temp;
}

/* Change the time stamp of the most recent history entry to STRING. */
void
add_history_time (string)
     const char *string;
{
  HIST_ENTRY *hs;

  if (string == 0)
    return;
  hs = the_history[history_length - 1];
  FREE (hs->timestamp);
  hs->timestamp = savestring (string);
}

/* Free HIST and return the data so the calling application can free it
   if necessary and desired. */
histdata_t
free_history_entry (hist)
     HIST_ENTRY *hist;
{
  histdata_t x;

  if (hist == 0)
    return ((histdata_t) 0);
  FREE (hist->line);
  FREE (hist->timestamp);
  x = hist->data;
  xfree (hist);
  return (x);
}

HIST_ENTRY *
copy_history_entry (hist)
     HIST_ENTRY *hist;
{
  HIST_ENTRY *ret;
  char *ts;

  if (hist == 0)
    return hist;

  ret = alloc_history_entry (hist->line, (char *)NULL);

  ts = hist->timestamp ? savestring (hist->timestamp) : hist->timestamp;
  ret->timestamp = ts;

  ret->data = hist->data;

  return ret;
}
  
/* Make the history entry at WHICH have LINE and DATA.  This returns
   the old entry so you can dispose of the data.  In the case of an
   invalid WHICH, a NULL pointer is returned. */
HIST_ENTRY *
replace_history_entry (which, line, data)
     int which;
     const char *line;
     histdata_t data;
{
  HIST_ENTRY *temp, *old_value;

  if (which < 0 || which >= history_length)
    return ((HIST_ENTRY *)NULL);

  temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
  old_value = the_history[which];

  temp->line = savestring (line);
  temp->data = data;
  temp->timestamp = savestring (old_value->timestamp);
  the_history[which] = temp;

  return (old_value);
}

/* Replace the DATA in the specified history entries, replacing OLD with
   NEW.  WHICH says which one(s) to replace:  WHICH == -1 means to replace
   all of the history entries where entry->data == OLD; WHICH == -2 means
   to replace the `newest' history entry where entry->data == OLD; and
   WHICH >= 0 means to replace that particular history entry's data, as
   long as it matches OLD. */
void
replace_history_data (which,old, new)
     int which;
     histdata_t *old, *new;
{
  HIST_ENTRY *entry;
  register int i, last;

  if (which < -2 || which >= history_length || history_length == 0 || the_history == 0)
    return;

  if (which >= 0)
    {
      entry = the_history[which];
      if (entry && entry->data == old)
	entry->data = new;
      return;
    }

  last = -1;
  for (i = 0; i < history_length; i++)
    {
      entry = the_history[i];
      if (entry == 0)
	continue;
      if (entry->data == old)
	{
	  last = i;
	  if (which == -1)
	    entry->data = new;
	}
    }
  if (which == -2 && last >= 0)
    {
      entry = the_history[last];
      entry->data = new;	/* XXX - we don't check entry->old */
    }
}      
  
/* Remove history element WHICH from the history.  The removed
   element is returned to you so you can free the line, data,
   and containing structure. */
HIST_ENTRY *
remove_history (which)
     int which;
{
  HIST_ENTRY *return_value;
  register int i;

  if (which < 0 || which >= history_length || history_length ==  0 || the_history == 0)
    return ((HIST_ENTRY *)NULL);

  return_value = the_history[which];

  for (i = which; i < history_length; i++)
    the_history[i] = the_history[i + 1];

  history_length--;

  return (return_value);
}

/* Stifle the history list, remembering only MAX number of lines. */
void
stifle_history (max)
     int max;
{
  register int i, j;

  if (max < 0)
    max = 0;

  if (history_length > max)
    {
      /* This loses because we cannot free the data. */
      for (i = 0, j = history_length - max; i < j; i++)
	free_history_entry (the_history[i]);

      history_base = i;
      for (j = 0, i = history_length - max; j < max; i++, j++)
	the_history[j] = the_history[i];
      the_history[j] = (HIST_ENTRY *)NULL;
      history_length = j;
    }

  history_stifled = 1;
  max_input_history = history_max_entries = max;
}

/* Stop stifling the history.  This returns the previous maximum
   number of history entries.  The value is positive if the history
   was stifled, negative if it wasn't. */
int
unstifle_history ()
{
  if (history_stifled)
    {
      history_stifled = 0;
      return (history_max_entries);
    }
  else
    return (-history_max_entries);
}

int
history_is_stifled ()
{
  return (history_stifled);
}

void
clear_history ()
{
  register int i;

  /* This loses because we cannot free the data. */
  for (i = 0; i < history_length; i++)
    {
      free_history_entry (the_history[i]);
      the_history[i] = (HIST_ENTRY *)NULL;
    }

  history_offset = history_length = 0;
}
@


1.6
log
@Readline 5.1 import for HEAD.
@
text
@d3 1
a3 1
/* Copyright (C) 1989-2005 Free Software Foundation, Inc.
d5 1
a5 1
   This file contains the GNU History Library (the Library), a set of
d8 1
a8 1
   The Library is free software; you can redistribute it and/or modify
d10 2
a11 2
   the Free Software Foundation; either version 2, or (at your option)
   any later version.
d13 8
a20 9
   The Library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   The GNU General Public License is often shipped with GNU software, and
   is generally kept in a file called COPYING or LICENSE.  If you do not
   have a copy of the license, write to the Free Software Foundation,
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
d160 1
a160 1
/* Return the current history array.  The caller has to be carefull, since this
d211 16
d308 1
a308 5
  temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
  temp->line = savestring (string);
  temp->data = (char *)NULL;

  temp->timestamp = hist_inittime ();
d321 2
d341 1
a341 1
  free (hist);
d344 20
d390 45
d487 1
a487 1
   was stifled,  negative if it wasn't. */
@


1.5
log
@touched all sources to ease import of readline-5.1
@
text
@d1 1
a1 1
/* History.c -- standalone history library */
d3 1
a3 1
/* Copyright (C) 1989, 1992 Free Software Foundation, Inc.
d55 2
d128 2
a129 1
   This just adds up the lengths of the_history->lines. */
d136 1
a136 1
    result += strlen (the_history[i]->line);
d207 1
a207 1
  return (local_index >= history_length || local_index < 0 || !the_history)
d212 34
d265 1
a265 4
	{
	  free (the_history[0]->line);
	  free (the_history[0]);
	}
d297 2
d303 29
d343 1
a343 1
  if (which >= history_length)
d351 1
d367 4
a370 5
  if (which >= history_length || !history_length)
    return_value = (HIST_ENTRY *)NULL;
  else
    {
      return_value = the_history[which];
d372 2
a373 2
      for (i = which; i < history_length; i++)
	the_history[i] = the_history[i + 1];
d375 1
a375 2
      history_length--;
    }
d394 1
a394 4
	{
	  free (the_history[i]->line);
	  free (the_history[i]);
	}
d436 1
a436 2
      free (the_history[i]->line);
      free (the_history[i]);
@


1.5.2.1
log
@Import readline 5.1 on the branch.
@
text
@d1 1
a1 1
/* history.c -- standalone history library */
d3 1
a3 1
/* Copyright (C) 1989-2005 Free Software Foundation, Inc.
a54 2
static char *hist_inittime PARAMS((void));

d126 1
a126 2
   This just adds up the lengths of the_history->lines and the associated
   timestamps. */
d133 1
a133 1
    result += HISTENT_BYTES (the_history[i]);
d204 1
a204 1
  return (local_index >= history_length || local_index < 0 || the_history == 0)
a208 34
time_t
history_get_time (hist)
     HIST_ENTRY *hist;
{
  char *ts;
  time_t t;

  if (hist == 0 || hist->timestamp == 0)
    return 0;
  ts = hist->timestamp;
  if (ts[0] != history_comment_char)
    return 0;
  t = (time_t) atol (ts + 1);		/* XXX - should use strtol() here */
  return t;
}

static char *
hist_inittime ()
{
  time_t t;
  char ts[64], *ret;

  t = (time_t) time ((time_t *)0);
#if defined (HAVE_VSNPRINTF)		/* assume snprintf if vsnprintf exists */
  snprintf (ts, sizeof (ts) - 1, "X%lu", (unsigned long) t);
#else
  sprintf (ts, "X%lu", (unsigned long) t);
#endif
  ret = savestring (ts);
  ret[0] = history_comment_char;

  return ret;
}

d228 4
a231 1
	(void) free_history_entry (the_history[0]);
a262 2
  temp->timestamp = hist_inittime ();

a266 29
/* Change the time stamp of the most recent history entry to STRING. */
void
add_history_time (string)
     const char *string;
{
  HIST_ENTRY *hs;

  hs = the_history[history_length - 1];
  FREE (hs->timestamp);
  hs->timestamp = savestring (string);
}

/* Free HIST and return the data so the calling application can free it
   if necessary and desired. */
histdata_t
free_history_entry (hist)
     HIST_ENTRY *hist;
{
  histdata_t x;

  if (hist == 0)
    return ((histdata_t) 0);
  FREE (hist->line);
  FREE (hist->timestamp);
  x = hist->data;
  free (hist);
  return (x);
}
  
d278 1
a278 1
  if (which < 0 || which >= history_length)
a285 1
  temp->timestamp = savestring (old_value->timestamp);
d301 5
a305 2
  if (which < 0 || which >= history_length || history_length ==  0 || the_history == 0)
    return ((HIST_ENTRY *)NULL);
d307 2
a308 1
  return_value = the_history[which];
d310 2
a311 4
  for (i = which; i < history_length; i++)
    the_history[i] = the_history[i + 1];

  history_length--;
d330 4
a333 1
	free_history_entry (the_history[i]);
d375 2
a376 1
      free_history_entry (the_history[i]);
@


1.4
log
@Import of readline 4.3.
Non-readline modified files:

src/gdb/ChangeLog src/gdb/defs.h src/gdb/cli/cli-cmds.c
src/gdb/cli/cli-setshow.c src/gdb/tui/ChangeLog
src/gdb/tui/tuiWin.c

In readline directory:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@@


1.3
log
@readline:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Locally modified files: Makefile.in, configure.in, configure
        (regenerated), config.h.in (regenerated), readline.h, rltty.c,
 	shell.c signals.c.

        Locally added files: acconfig.h, config/*, config.h.bot,
        cross-build/*, doc/inc-hit.texinfo.

        New files: USAGE, rlprivate.h, rlshell.h, xmalloc.h.
examples:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        New files: excallback.c, rlfe.c.
doc:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Regenerated inc-hist.texinfo as copy of hsuser.texinfo, for
        inclusion in the gdb manual.

        New file: rluserman.texinfo
@
text
@a46 6
#if defined (HAVE_STRING_H)
#  include <string.h>
#else
#  include <strings.h>
#endif /* !HAVE_STRING_H */

d68 3
d73 2
a74 1
int max_input_history;
a82 3
/* The current number of slots allocated to the input_history. */
static int history_size;

d132 1
a132 3
  result = 0;

  for (i = 0; the_history && the_history[i]; i++)
d213 1
a213 1
     char *string;
d217 1
a217 1
  if (history_stifled && (history_length == max_input_history))
d222 1
a222 1
	 and it equals max_input_history, we don't save items. */
d273 1
a273 1
     char *line;
d276 1
a276 2
  HIST_ENTRY *temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
  HIST_ENTRY *old_value;
d281 1
d299 1
a304 1
      register int i;
d321 2
a327 2
      register int i, j;

d343 1
a343 1
  max_input_history = max;
d346 3
a348 3
/* Stop stifling the history.  This returns the previous amount the 
   history was stifled by.  The value is positive if the history was
   stifled,  negative if it wasn't. */
d355 1
a355 1
      return (-max_input_history);
d357 2
a358 2

  return (max_input_history);
@


1.3.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d47 6
a73 3
/* The current number of slots allocated to the input_history. */
static int history_size;

d76 1
a76 2
int history_max_entries;
int max_input_history;	/* backwards compatibility */
d85 3
d137 3
a139 1
  for (i = result = 0; the_history && the_history[i]; i++)
d220 1
a220 1
     const char *string;
d224 1
a224 1
  if (history_stifled && (history_length == history_max_entries))
d229 1
a229 1
	 and it equals history_max_entries, we don't save items. */
d280 1
a280 1
     const char *line;
d283 2
a284 1
  HIST_ENTRY *temp, *old_value;
a288 1
  temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
a305 1
  register int i;
d311 1
a327 2
  register int i, j;

d333 2
d350 1
a350 1
  max_input_history = history_max_entries = max;
d353 3
a355 3
/* Stop stifling the history.  This returns the previous maximum
   number of history entries.  The value is positive if the history
   was stifled,  negative if it wasn't. */
d362 1
a362 1
      return (history_max_entries);
d364 2
a365 2
  else
    return (-history_max_entries);
@


1.3.22.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d47 6
a73 3
/* The current number of slots allocated to the input_history. */
static int history_size;

d76 1
a76 2
int history_max_entries;
int max_input_history;	/* backwards compatibility */
d85 3
d137 3
a139 1
  for (i = result = 0; the_history && the_history[i]; i++)
d220 1
a220 1
     const char *string;
d224 1
a224 1
  if (history_stifled && (history_length == history_max_entries))
d229 1
a229 1
	 and it equals history_max_entries, we don't save items. */
d280 1
a280 1
     const char *line;
d283 2
a284 1
  HIST_ENTRY *temp, *old_value;
a288 1
  temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
a305 1
  register int i;
d311 1
a327 2
  register int i, j;

d333 2
d350 1
a350 1
  max_input_history = history_max_entries = max;
d353 3
a355 3
/* Stop stifling the history.  This returns the previous maximum
   number of history entries.  The value is positive if the history
   was stifled,  negative if it wasn't. */
d362 1
a362 1
      return (history_max_entries);
d364 2
a365 2
  else
    return (-history_max_entries);
@


1.3.16.1
log
@2002-08-24  Elena Zannoni  <ezannoni@@redhat.com>

        Import of readline 4.3:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@d47 6
a73 3
/* The current number of slots allocated to the input_history. */
static int history_size;

d76 1
a76 2
int history_max_entries;
int max_input_history;	/* backwards compatibility */
d85 3
d137 3
a139 1
  for (i = result = 0; the_history && the_history[i]; i++)
d220 1
a220 1
     const char *string;
d224 1
a224 1
  if (history_stifled && (history_length == history_max_entries))
d229 1
a229 1
	 and it equals history_max_entries, we don't save items. */
d280 1
a280 1
     const char *line;
d283 2
a284 1
  HIST_ENTRY *temp, *old_value;
a288 1
  temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
a305 1
  register int i;
d311 1
a327 2
  register int i, j;

d333 2
d350 1
a350 1
  max_input_history = history_max_entries = max;
d353 3
a355 3
/* Stop stifling the history.  This returns the previous maximum
   number of history entries.  The value is positive if the history
   was stifled,  negative if it wasn't. */
d362 1
a362 1
      return (history_max_entries);
d364 2
a365 2
  else
    return (-history_max_entries);
@


1.2
log
@Dummy commit before importof 4.1 version
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 1, or (at your option)
d21 1
a21 1
   675 Mass Ave, Cambridge, MA 02139, USA. */
d56 1
a56 1
extern char *xmalloc (), *xrealloc ();
@


1.1
log
@Initial revision
@
text
@d281 1
a281 1
     char *data;
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-08-02 snapshot
@
text
@d281 1
a281 1
     histdata_t data;
@


1.1.1.3
log
@Import of readline 4.1
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
d21 1
a21 1
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
d56 1
a56 1
#include "xmalloc.h"
@


1.1.1.4
log
@import of readline-4.3
@
text
@d47 6
a73 3
/* The current number of slots allocated to the input_history. */
static int history_size;

d76 1
a76 2
int history_max_entries;
int max_input_history;	/* backwards compatibility */
d85 3
d137 3
a139 1
  for (i = result = 0; the_history && the_history[i]; i++)
d220 1
a220 1
     const char *string;
d224 1
a224 1
  if (history_stifled && (history_length == history_max_entries))
d229 1
a229 1
	 and it equals history_max_entries, we don't save items. */
d280 1
a280 1
     const char *line;
d283 2
a284 1
  HIST_ENTRY *temp, *old_value;
a288 1
  temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
a305 1
  register int i;
d311 1
a327 2
  register int i, j;

d333 2
d350 1
a350 1
  max_input_history = history_max_entries = max;
d353 3
a355 3
/* Stop stifling the history.  This returns the previous maximum
   number of history entries.  The value is positive if the history
   was stifled,  negative if it wasn't. */
d362 1
a362 1
      return (history_max_entries);
d364 2
a365 2
  else
    return (-history_max_entries);
@


1.1.1.5
log
@import of readlilne 5.1
@
text
@d1 1
a1 1
/* history.c -- standalone history library */
d3 1
a3 1
/* Copyright (C) 1989-2005 Free Software Foundation, Inc.
a54 2
static char *hist_inittime PARAMS((void));

d126 1
a126 2
   This just adds up the lengths of the_history->lines and the associated
   timestamps. */
d133 1
a133 1
    result += HISTENT_BYTES (the_history[i]);
d204 1
a204 1
  return (local_index >= history_length || local_index < 0 || the_history == 0)
a208 34
time_t
history_get_time (hist)
     HIST_ENTRY *hist;
{
  char *ts;
  time_t t;

  if (hist == 0 || hist->timestamp == 0)
    return 0;
  ts = hist->timestamp;
  if (ts[0] != history_comment_char)
    return 0;
  t = (time_t) atol (ts + 1);		/* XXX - should use strtol() here */
  return t;
}

static char *
hist_inittime ()
{
  time_t t;
  char ts[64], *ret;

  t = (time_t) time ((time_t *)0);
#if defined (HAVE_VSNPRINTF)		/* assume snprintf if vsnprintf exists */
  snprintf (ts, sizeof (ts) - 1, "X%lu", (unsigned long) t);
#else
  sprintf (ts, "X%lu", (unsigned long) t);
#endif
  ret = savestring (ts);
  ret[0] = history_comment_char;

  return ret;
}

d228 4
a231 1
	(void) free_history_entry (the_history[0]);
a262 2
  temp->timestamp = hist_inittime ();

a266 29
/* Change the time stamp of the most recent history entry to STRING. */
void
add_history_time (string)
     const char *string;
{
  HIST_ENTRY *hs;

  hs = the_history[history_length - 1];
  FREE (hs->timestamp);
  hs->timestamp = savestring (string);
}

/* Free HIST and return the data so the calling application can free it
   if necessary and desired. */
histdata_t
free_history_entry (hist)
     HIST_ENTRY *hist;
{
  histdata_t x;

  if (hist == 0)
    return ((histdata_t) 0);
  FREE (hist->line);
  FREE (hist->timestamp);
  x = hist->data;
  free (hist);
  return (x);
}
  
d278 1
a278 1
  if (which < 0 || which >= history_length)
a285 1
  temp->timestamp = savestring (old_value->timestamp);
d301 5
a305 2
  if (which < 0 || which >= history_length || history_length ==  0 || the_history == 0)
    return ((HIST_ENTRY *)NULL);
d307 2
a308 1
  return_value = the_history[which];
d310 2
a311 4
  for (i = which; i < history_length; i++)
    the_history[i] = the_history[i + 1];

  history_length--;
d330 4
a333 1
	free_history_entry (the_history[i]);
d375 2
a376 1
      free_history_entry (the_history[i]);
@


