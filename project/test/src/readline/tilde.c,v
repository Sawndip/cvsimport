head	1.8;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.8
	gdb_7_6-2013-04-26-release:1.8
	gdb_7_6-branch:1.8.0.6
	gdb_7_6-2013-03-12-branchpoint:1.8
	gdb_7_5_1-2012-11-29-release:1.8
	gdb_7_5-2012-08-17-release:1.8
	gdb_7_5-branch:1.8.0.4
	gdb_7_5-2012-07-18-branchpoint:1.8
	gdb_7_4_1-2012-04-26-release:1.8
	gdb_7_4-2012-01-24-release:1.8
	gdb_7_4-branch:1.8.0.2
	gdb_7_4-2011-12-13-branchpoint:1.8
	gdb_7_3_1-2011-09-04-release:1.7
	gdb_7_3-2011-07-26-release:1.7
	gdb_7_3-branch:1.7.0.36
	gdb_7_3-2011-04-01-branchpoint:1.7
	gdb_7_2-2010-09-02-release:1.7
	gdb_7_2-branch:1.7.0.34
	gdb_7_2-2010-07-07-branchpoint:1.7
	gdb_7_1-2010-03-18-release:1.7
	gdb_7_1-branch:1.7.0.32
	gdb_7_1-2010-02-18-branchpoint:1.7
	gdb_7_0_1-2009-12-22-release:1.7
	gdb_7_0-2009-10-06-release:1.7
	gdb_7_0-branch:1.7.0.30
	gdb_7_0-2009-09-16-branchpoint:1.7
	arc-sim-20090309:1.7
	msnyder-checkpoint-072509-branch:1.7.0.28
	msnyder-checkpoint-072509-branchpoint:1.7
	arc-insight_6_8-branch:1.7.0.26
	arc-insight_6_8-branchpoint:1.7
	insight_6_8-branch:1.7.0.24
	insight_6_8-branchpoint:1.7
	reverse-20081226-branch:1.7.0.22
	reverse-20081226-branchpoint:1.7
	multiprocess-20081120-branch:1.7.0.20
	multiprocess-20081120-branchpoint:1.7
	reverse-20080930-branch:1.7.0.18
	reverse-20080930-branchpoint:1.7
	reverse-20080717-branch:1.7.0.16
	reverse-20080717-branchpoint:1.7
	msnyder-reverse-20080609-branch:1.7.0.14
	msnyder-reverse-20080609-branchpoint:1.7
	drow-reverse-20070409-branch:1.7.0.12
	drow-reverse-20070409-branchpoint:1.7
	gdb_6_8-2008-03-27-release:1.7
	gdb_6_8-branch:1.7.0.10
	gdb_6_8-2008-02-26-branchpoint:1.7
	gdb_6_7_1-2007-10-29-release:1.7
	gdb_6_7-2007-10-10-release:1.7
	gdb_6_7-branch:1.7.0.8
	gdb_6_7-2007-09-07-branchpoint:1.7
	insight_6_6-20070208-release:1.7
	gdb_6_6-2006-12-18-release:1.7
	gdb_6_6-branch:1.7.0.6
	gdb_6_6-2006-11-15-branchpoint:1.7
	insight_6_5-20061003-release:1.7
	gdb-csl-symbian-6_4_50_20060226-12:1.5
	gdb-csl-sourcerygxx-3_4_4-25:1.5
	nickrob-async-20060828-mergepoint:1.7
	gdb-csl-symbian-6_4_50_20060226-11:1.5
	gdb-csl-sourcerygxx-4_1-17:1.5
	gdb-csl-20060226-branch-local-2:1.5
	gdb-csl-sourcerygxx-4_1-14:1.5
	gdb-csl-sourcerygxx-4_1-13:1.5
	gdb-csl-sourcerygxx-4_1-12:1.5
	gdb-csl-sourcerygxx-3_4_4-21:1.5
	gdb_6_5-20060621-release:1.7
	gdb-csl-sourcerygxx-4_1-9:1.5
	gdb-csl-sourcerygxx-4_1-8:1.5
	gdb-csl-sourcerygxx-4_1-7:1.5
	gdb-csl-arm-2006q1-6:1.5
	gdb-csl-sourcerygxx-4_1-6:1.5
	gdb-csl-symbian-6_4_50_20060226-10:1.5
	gdb-csl-symbian-6_4_50_20060226-9:1.5
	gdb-csl-symbian-6_4_50_20060226-8:1.5
	gdb-csl-coldfire-4_1-11:1.5
	gdb-csl-sourcerygxx-3_4_4-19:1.5
	gdb-csl-coldfire-4_1-10:1.5
	gdb_6_5-branch:1.7.0.4
	gdb_6_5-2006-05-14-branchpoint:1.7
	gdb-csl-sourcerygxx-4_1-5:1.5
	nickrob-async-20060513-branch:1.7.0.2
	nickrob-async-20060513-branchpoint:1.7
	gdb-csl-sourcerygxx-4_1-4:1.5
	msnyder-reverse-20060502-branch:1.6.0.4
	msnyder-reverse-20060502-branchpoint:1.6
	gdb-csl-morpho-4_1-4:1.5
	gdb-csl-sourcerygxx-3_4_4-17:1.5
	readline_5_1-import-branch:1.6.0.2
	readline_5_1-import-branchpoint:1.6
	readline-pre-51-import:1.6
	readline_5_1:1.1.1.5
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.5
	gdb-csl-symbian-20060226-branch:1.5.0.18
	gdb-csl-symbian-20060226-branchpoint:1.5
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.5
	msnyder-reverse-20060331-branch:1.5.0.16
	msnyder-reverse-20060331-branchpoint:1.5
	gdb-csl-available-20060303-branch:1.5.0.14
	gdb-csl-available-20060303-branchpoint:1.5
	gdb-csl-20060226-branch:1.5.0.12
	gdb-csl-20060226-branchpoint:1.5
	gdb_6_4-20051202-release:1.5
	msnyder-fork-checkpoint-branch:1.5.0.10
	msnyder-fork-checkpoint-branchpoint:1.5
	gdb-csl-gxxpro-6_3-branch:1.5.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb-csl-arm-20051020-branch:1.5.0.4
	gdb-csl-arm-20051020-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb-csl-arm-20050325-2005-q1b:1.4.60.1
	gdb-csl-arm-20050325-2005-q1a:1.4.60.1
	csl-arm-20050325-branch:1.4.0.60
	csl-arm-20050325-branchpoint:1.4
	gdb_6_3-20041109-release:1.4
	gdb_6_3-branch:1.4.0.56
	gdb_6_3-20041019-branchpoint:1.4
	drow_intercu-merge-20040921:1.4
	drow_intercu-merge-20040915:1.4
	jimb-gdb_6_2-e500-branch:1.4.0.58
	jimb-gdb_6_2-e500-branchpoint:1.4
	gdb_6_2-20040730-release:1.4
	gdb_6_2-branch:1.4.0.54
	gdb_6_2-2004-07-10-gmt-branchpoint:1.4
	gdb_6_1_1-20040616-release:1.4
	gdb_6_1-2004-04-05-release:1.4
	drow_intercu-merge-20040402:1.4
	drow_intercu-merge-20040327:1.4
	ezannoni_pie-20040323-branch:1.4.0.52
	ezannoni_pie-20040323-branchpoint:1.4
	cagney_tramp-20040321-mergepoint:1.4
	cagney_tramp-20040309-branch:1.4.0.50
	cagney_tramp-20040309-branchpoint:1.4
	gdb_6_1-branch:1.4.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.4
	drow_intercu-20040221-branch:1.4.0.46
	drow_intercu-20040221-branchpoint:1.4
	cagney_bfdfile-20040213-branch:1.4.0.44
	cagney_bfdfile-20040213-branchpoint:1.4
	drow-cplus-merge-20040208:1.4
	carlton_dictionary-20040126-merge:1.4
	cagney_bigcore-20040122-branch:1.4.0.42
	cagney_bigcore-20040122-branchpoint:1.4
	drow-cplus-merge-20040113:1.4
	drow-cplus-merge-20031224:1.4
	drow-cplus-merge-20031220:1.4
	carlton_dictionary-20031215-merge:1.4
	drow-cplus-merge-20031214:1.4
	carlton-dictionary-20031111-merge:1.4
	gdb_6_0-2003-10-04-release:1.4
	kettenis_sparc-20030918-branch:1.4.0.40
	kettenis_sparc-20030918-branchpoint:1.4
	carlton_dictionary-20030917-merge:1.4
	ezannoni_pie-20030916-branchpoint:1.4
	ezannoni_pie-20030916-branch:1.4.0.38
	cagney_x86i386-20030821-branch:1.4.0.36
	cagney_x86i386-20030821-branchpoint:1.4
	carlton_dictionary-20030805-merge:1.4
	carlton_dictionary-20030627-merge:1.4
	gdb_6_0-branch:1.4.0.34
	gdb_6_0-2003-06-23-branchpoint:1.4
	jimb-ppc64-linux-20030613-branch:1.4.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.4
	cagney_convert-20030606-branch:1.4.0.30
	cagney_convert-20030606-branchpoint:1.4
	cagney_writestrings-20030508-branch:1.4.0.28
	cagney_writestrings-20030508-branchpoint:1.4
	jimb-ppc64-linux-20030528-branch:1.4.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.4
	carlton_dictionary-20030523-merge:1.4
	cagney_fileio-20030521-branch:1.4.0.24
	cagney_fileio-20030521-branchpoint:1.4
	kettenis_i386newframe-20030517-mergepoint:1.4
	jimb-ppc64-linux-20030509-branch:1.4.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.4
	kettenis_i386newframe-20030504-mergepoint:1.4
	carlton_dictionary-20030430-merge:1.4
	kettenis_i386newframe-20030419-branch:1.4.0.20
	kettenis_i386newframe-20030419-branchpoint:1.4
	carlton_dictionary-20030416-merge:1.4
	cagney_frameaddr-20030409-mergepoint:1.4
	kettenis_i386newframe-20030406-branch:1.4.0.18
	kettenis_i386newframe-20030406-branchpoint:1.4
	cagney_frameaddr-20030403-branchpoint:1.4
	cagney_frameaddr-20030403-branch:1.4.0.16
	cagney_framebase-20030330-mergepoint:1.4
	cagney_framebase-20030326-branch:1.4.0.14
	cagney_framebase-20030326-branchpoint:1.4
	cagney_lazyid-20030317-branch:1.4.0.12
	cagney_lazyid-20030317-branchpoint:1.4
	kettenis-i386newframe-20030316-mergepoint:1.4
	offbyone-20030313-branch:1.4.0.10
	offbyone-20030313-branchpoint:1.4
	kettenis-i386newframe-20030308-branch:1.4.0.8
	kettenis-i386newframe-20030308-branchpoint:1.4
	carlton_dictionary-20030305-merge:1.4
	cagney_offbyone-20030303-branch:1.4.0.6
	cagney_offbyone-20030303-branchpoint:1.4
	carlton_dictionary-20030207-merge:1.4
	interps-20030202-branch:1.4.0.4
	interps-20030202-branchpoint:1.4
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.3
	readline-pre-43-import:1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.24
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	carlton_dictionary-branch:1.3.0.22
	carlton_dictionary-20020920-branchpoint:1.3
	gdb_5_3-branch:1.3.0.20
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.3
	cagney_sysregs-20020825-branch:1.3.0.18
	cagney_sysregs-20020825-branchpoint:1.3
	readline_4_3-import-branch:1.3.0.16
	readline_4_3-import-branchpoint:1.3
	readline_4_3:1.1.1.4
	gdb_5_2_1-2002-07-23-release:1.3
	kseitz_interps-20020528-branch:1.3.0.14
	kseitz_interps-20020528-branchpoint:1.3
	cagney_regbuf-20020515-branch:1.3.0.12
	cagney_regbuf-20020515-branchpoint:1.3
	jimb-macro-020506-branch:1.3.0.10
	jimb-macro-020506-branchpoint:1.3
	gdb_5_2-2002-04-29-release:1.3
	gdb_5_2-branch:1.3.0.8
	gdb_5_2-2002-03-03-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	cygnus_cvs_20020108_pre:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.4
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.2
	gdb_5_1-2001-07-29-branchpoint:1.3
	insight-precleanup-2001-01-01:1.3
	readline_4_1:1.1.1.3
	readline_4_0:1.1.1.2
	FSF:1.1.1
	readline-pre-41-import:1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.8
date	2011.05.11.23.38.39;	author jkratoch;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.05.18.26.12;	author drow;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.20.20.13.20;	author ezannoni;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2005.05.09.19.42.03;	author mmitchel;	state Exp;
branches;
next	1.4;

1.4
date	2002.12.08.22.31.37;	author ezannoni;	state Exp;
branches
	1.4.60.1;
next	1.3;

1.3
date	2000.07.09.17.19.56;	author ezannoni;	state Exp;
branches
	1.3.16.1
	1.3.22.1
	1.3.24.1;
next	1.2;

1.2
date	2000.07.07.17.15.45;	author ezannoni;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.54;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.6.2.1
date	2006.04.24.22.00.25;	author drow;	state Exp;
branches;
next	;

1.4.60.1
date	2005.03.28.19.34.27;	author mmitchel;	state Exp;
branches;
next	;

1.3.16.1
date	2002.08.25.23.41.17;	author ezannoni;	state Exp;
branches;
next	;

1.3.22.1
date	2002.12.23.19.39.45;	author carlton;	state Exp;
branches;
next	;

1.3.24.1
date	2003.12.14.20.28.14;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.54;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.08.02.23.47.58;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.07.09.16.21.21;	author ezannoni;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.08.23.22.02.28;	author ezannoni;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.20.20.05.37;	author ezannoni;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Imported readline 6.2, and upstream patch 001.

[patch 0/3] readline-6.2 rebase
http://sourceware.org/ml/gdb-patches/2011-05/msg00003.html
[patch 1/3] readline-6.2: Merge of already posted patches
http://sourceware.org/ml/gdb-patches/2011-05/msg00004.html
	=
	[Bug-readline] [RFC/readline] bind.c, rl_function_dumper, Free allocated
	http://lists.gnu.org/archive/html/bug-readline/2011-03/msg00000.html
	[Bug-readline] [patch] Fix underquotation in readline/examples/rlfe/conf
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00001.html
	[Bug-readline] [patch] Makefile.in htm<->html
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00002.html
	Re: [Bug-readline] [patch] Makefile.in dependency: callback.o: xmalloc.h
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00004.html
	[Bug-readline] [patch] Remove . from the VPATH directive
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00005.html
	Eli Zaretskii's __MSDOS__ / __GO32__ / __MINGW32__ / __DJGPP__ stuff:
	http://sourceware.org/ml/gdb/2011-04/msg00002.html
	Jan Kratochvil's patch for FSF GDB tree local-specific changes:
	http://sourceware.org/ml/gdb/2011-04/msg00006.html
	Preservation of existing ChangeLog.gdb files, their updates.
[patch 2/3] readline-6.2: Workaround "ask" regression
http://sourceware.org/ml/gdb-patches/2011-05/msg00005.html
[patch 3/3] readline-6.2: Revert 5.x compat., apply 6.x compat.
http://sourceware.org/ml/gdb-patches/2011-05/msg00006.html
[patch 4/3] readline-6.2: Substitute inc-hist.texinfo
http://sourceware.org/ml/gdb-patches/2011-05/msg00010.html

readline/
	Workaround gdb.base/completion.exp regression on readline-6.2.
	* complete.c (get_y_or_n): Disable the return on RL_STATE_CALLBACK.

	Imported readline 6.2, and upstream patch 001.
	* configure: Regenerate.

readline/doc/
	* hsuser.texi (Using History Interactively): Disable !BashFeatures
	@@defcodeindex.  Make the `Programming with GNU History' reference
	external.
	* inc-hist.texinfo: Remove.

	Imported readline 6.2, and upstream patch 001.

readline/examples/
	Imported readline 6.2, and upstream patch 001.

readline/examples/rlfe/
	Imported readline 6.2, and upstream patch 001.

gdb/
	* config.in: Regenerate.
	* configure: Regenerate.
	* configure.ac <--with-system-readline> (for readline_echoing_p):
	Remove the test.
	* tui/tui-io.c (tui_old_readline_echoing_p): Rename to ...
	(tui_old_rl_echoing_p): ... here.
	(tui_setup_io): Rename extern declaration readline_echoing_p to
	_rl_echoing_p.  Adjust assignments for the both renames.

gdb/doc/
	* Makefile.in (GDB_DOC_SOURCE_INCLUDES): Rename inc-hist.texinfo to
	hsuser.texi.
	* gdb.texinfo <!SYSTEM_READLINE>: Rename inc-hist.texinfo inclusion and
	comment to hsuser.texi.  Change rluser.texi name in the comment.
@
text
@/* tilde.c -- Tilde expansion code (~/foo := $HOME/foo). */

/* Copyright (C) 1988-2009 Free Software Foundation, Inc.

   This file is part of the GNU Readline Library (Readline), a library
   for reading lines of text with interactive input and history editing.

   Readline is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Readline is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Readline.  If not, see <http://www.gnu.org/licenses/>.
*/

#if defined (HAVE_CONFIG_H)
#  include <config.h>
#endif

#if defined (HAVE_UNISTD_H)
#  ifdef _MINIX
#    include <sys/types.h>
#  endif
#  include <unistd.h>
#endif

#if defined (HAVE_STRING_H)
#  include <string.h>
#else /* !HAVE_STRING_H */
#  include <strings.h>
#endif /* !HAVE_STRING_H */  

#if defined (HAVE_STDLIB_H)
#  include <stdlib.h>
#else
#  include "ansi_stdlib.h"
#endif /* HAVE_STDLIB_H */

#include <sys/types.h>
#if defined (HAVE_PWD_H)
#include <pwd.h>
#endif

#include "tilde.h"

#if defined (TEST) || defined (STATIC_MALLOC)
static void *xmalloc (), *xrealloc ();
#else
#  include "xmalloc.h"
#endif /* TEST || STATIC_MALLOC */

#if !defined (HAVE_GETPW_DECLS)
#  if defined (HAVE_GETPWUID)
extern struct passwd *getpwuid PARAMS((uid_t));
#  endif
#  if defined (HAVE_GETPWNAM)
extern struct passwd *getpwnam PARAMS((const char *));
#  endif
#endif /* !HAVE_GETPW_DECLS */

#if !defined (savestring)
#define savestring(x) strcpy ((char *)xmalloc (1 + strlen (x)), (x))
#endif /* !savestring */

#if !defined (NULL)
#  if defined (__STDC__)
#    define NULL ((void *) 0)
#  else
#    define NULL 0x0
#  endif /* !__STDC__ */
#endif /* !NULL */

/* If being compiled as part of bash, these will be satisfied from
   variables.o.  If being compiled as part of readline, they will
   be satisfied from shell.o. */
extern char *sh_get_home_dir PARAMS((void));
extern char *sh_get_env_value PARAMS((const char *));

/* The default value of tilde_additional_prefixes.  This is set to
   whitespace preceding a tilde so that simple programs which do not
   perform any word separation get desired behaviour. */
static const char *default_prefixes[] =
  { " ~", "\t~", (const char *)NULL };

/* The default value of tilde_additional_suffixes.  This is set to
   whitespace or newline so that simple programs which do not
   perform any word separation get desired behaviour. */
static const char *default_suffixes[] =
  { " ", "\n", (const char *)NULL };

/* If non-null, this contains the address of a function that the application
   wants called before trying the standard tilde expansions.  The function
   is called with the text sans tilde, and returns a malloc()'ed string
   which is the expansion, or a NULL pointer if the expansion fails. */
tilde_hook_func_t *tilde_expansion_preexpansion_hook = (tilde_hook_func_t *)NULL;

/* If non-null, this contains the address of a function to call if the
   standard meaning for expanding a tilde fails.  The function is called
   with the text (sans tilde, as in "foo"), and returns a malloc()'ed string
   which is the expansion, or a NULL pointer if there is no expansion. */
tilde_hook_func_t *tilde_expansion_failure_hook = (tilde_hook_func_t *)NULL;

/* When non-null, this is a NULL terminated array of strings which
   are duplicates for a tilde prefix.  Bash uses this to expand
   `=~' and `:~'. */
char **tilde_additional_prefixes = (char **)default_prefixes;

/* When non-null, this is a NULL terminated array of strings which match
   the end of a username, instead of just "/".  Bash sets this to
   `:' and `=~'. */
char **tilde_additional_suffixes = (char **)default_suffixes;

static int tilde_find_prefix PARAMS((const char *, int *));
static int tilde_find_suffix PARAMS((const char *));
static char *isolate_tilde_prefix PARAMS((const char *, int *));
static char *glue_prefix_and_suffix PARAMS((char *, const char *, int));

/* Find the start of a tilde expansion in STRING, and return the index of
   the tilde which starts the expansion.  Place the length of the text
   which identified this tilde starter in LEN, excluding the tilde itself. */
static int
tilde_find_prefix (string, len)
     const char *string;
     int *len;
{
  register int i, j, string_len;
  register char **prefixes;

  prefixes = tilde_additional_prefixes;

  string_len = strlen (string);
  *len = 0;

  if (*string == '\0' || *string == '~')
    return (0);

  if (prefixes)
    {
      for (i = 0; i < string_len; i++)
	{
	  for (j = 0; prefixes[j]; j++)
	    {
	      if (strncmp (string + i, prefixes[j], strlen (prefixes[j])) == 0)
		{
		  *len = strlen (prefixes[j]) - 1;
		  return (i + *len);
		}
	    }
	}
    }
  return (string_len);
}

/* Find the end of a tilde expansion in STRING, and return the index of
   the character which ends the tilde definition.  */
static int
tilde_find_suffix (string)
     const char *string;
{
  register int i, j, string_len;
  register char **suffixes;

  suffixes = tilde_additional_suffixes;
  string_len = strlen (string);

  for (i = 0; i < string_len; i++)
    {
#if defined (__MSDOS__)
      if (string[i] == '/' || string[i] == '\\' /* || !string[i] */)
#else
      if (string[i] == '/' /* || !string[i] */)
#endif
	break;

      for (j = 0; suffixes && suffixes[j]; j++)
	{
	  if (strncmp (string + i, suffixes[j], strlen (suffixes[j])) == 0)
	    return (i);
	}
    }
  return (i);
}

/* Return a new string which is the result of tilde expanding STRING. */
char *
tilde_expand (string)
     const char *string;
{
  char *result;
  int result_size, result_index;

  result_index = result_size = 0;
  if (result = strchr (string, '~'))
    result = (char *)xmalloc (result_size = (strlen (string) + 16));
  else
    result = (char *)xmalloc (result_size = (strlen (string) + 1));

  /* Scan through STRING expanding tildes as we come to them. */
  while (1)
    {
      register int start, end;
      char *tilde_word, *expansion;
      int len;

      /* Make START point to the tilde which starts the expansion. */
      start = tilde_find_prefix (string, &len);

      /* Copy the skipped text into the result. */
      if ((result_index + start + 1) > result_size)
	result = (char *)xrealloc (result, 1 + (result_size += (start + 20)));

      strncpy (result + result_index, string, start);
      result_index += start;

      /* Advance STRING to the starting tilde. */
      string += start;

      /* Make END be the index of one after the last character of the
	 username. */
      end = tilde_find_suffix (string);

      /* If both START and END are zero, we are all done. */
      if (!start && !end)
	break;

      /* Expand the entire tilde word, and copy it into RESULT. */
      tilde_word = (char *)xmalloc (1 + end);
      strncpy (tilde_word, string, end);
      tilde_word[end] = '\0';
      string += end;

      expansion = tilde_expand_word (tilde_word);
      xfree (tilde_word);

      len = strlen (expansion);
#ifdef __CYGWIN__
      /* Fix for Cygwin to prevent ~user/xxx from expanding to //xxx when
	 $HOME for `user' is /.  On cygwin, // denotes a network drive. */
      if (len > 1 || *expansion != '/' || *string != '/')
#endif
	{
	  if ((result_index + len + 1) > result_size)
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

	  strcpy (result + result_index, expansion);
	  result_index += len;
	}
      xfree (expansion);
    }

  result[result_index] = '\0';

  return (result);
}

/* Take FNAME and return the tilde prefix we want expanded.  If LENP is
   non-null, the index of the end of the prefix into FNAME is returned in
   the location it points to. */
static char *
isolate_tilde_prefix (fname, lenp)
     const char *fname;
     int *lenp;
{
  char *ret;
  int i;

  ret = (char *)xmalloc (strlen (fname));
#if defined (__MSDOS__)
  for (i = 1; fname[i] && fname[i] != '/' && fname[i] != '\\'; i++)
#else
  for (i = 1; fname[i] && fname[i] != '/'; i++)
#endif
    ret[i - 1] = fname[i];
  ret[i - 1] = '\0';
  if (lenp)
    *lenp = i;
  return ret;
}

#if 0
/* Public function to scan a string (FNAME) beginning with a tilde and find
   the portion of the string that should be passed to the tilde expansion
   function.  Right now, it just calls tilde_find_suffix and allocates new
   memory, but it can be expanded to do different things later. */
char *
tilde_find_word (fname, flags, lenp)
     const char *fname;
     int flags, *lenp;
{
  int x;
  char *r;

  x = tilde_find_suffix (fname);
  if (x == 0)
    {
      r = savestring (fname);
      if (lenp)
	*lenp = 0;
    }
  else
    {
      r = (char *)xmalloc (1 + x);
      strncpy (r, fname, x);
      r[x] = '\0';
      if (lenp)
	*lenp = x;
    }

  return r;
}
#endif

/* Return a string that is PREFIX concatenated with SUFFIX starting at
   SUFFIND. */
static char *
glue_prefix_and_suffix (prefix, suffix, suffind)
     char *prefix;
     const char *suffix;
     int suffind;
{
  char *ret;
  int plen, slen;

  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
  return ret;
}

/* Do the work of tilde expansion on FILENAME.  FILENAME starts with a
   tilde.  If there is no expansion, call tilde_expansion_failure_hook.
   This always returns a newly-allocated string, never static storage. */
char *
tilde_expand_word (filename)
     const char *filename;
{
  char *dirname, *expansion, *username;
  int user_len;
  struct passwd *user_entry;

  if (filename == 0)
    return ((char *)NULL);

  if (*filename != '~')
    return (savestring (filename));

  /* A leading `~/' or a bare `~' is *always* translated to the value of
     $HOME or the home directory of the current user, regardless of any
     preexpansion hook. */
  if (filename[1] == '\0' || filename[1] == '/')
    {
      /* Prefix $HOME to the rest of the string. */
      expansion = sh_get_env_value ("HOME");

      /* If there is no HOME variable, look up the directory in
	 the password database. */
      if (expansion == 0)
	expansion = sh_get_home_dir ();

      return (glue_prefix_and_suffix (expansion, filename, 1));
    }

  username = isolate_tilde_prefix (filename, &user_len);

  if (tilde_expansion_preexpansion_hook)
    {
      expansion = (*tilde_expansion_preexpansion_hook) (username);
      if (expansion)
	{
	  dirname = glue_prefix_and_suffix (expansion, filename, user_len);
	  xfree (username);
	  xfree (expansion);
	  return (dirname);
	}
    }

  /* No preexpansion hook, or the preexpansion hook failed.  Look in the
     password database. */
  dirname = (char *)NULL;
#if defined (HAVE_GETPWNAM)
  user_entry = getpwnam (username);
#else
  user_entry = 0;
#endif
  if (user_entry == 0)
    {
      /* If the calling program has a special syntax for expanding tildes,
	 and we couldn't find a standard expansion, then let them try. */
      if (tilde_expansion_failure_hook)
	{
	  expansion = (*tilde_expansion_failure_hook) (username);
	  if (expansion)
	    {
	      dirname = glue_prefix_and_suffix (expansion, filename, user_len);
	      xfree (expansion);
	    }
	}
      /* If we don't have a failure hook, or if the failure hook did not
	 expand the tilde, return a copy of what we were passed. */
      if (dirname == 0)
	dirname = savestring (filename);
    }
#if defined (HAVE_GETPWENT)
  else
    dirname = glue_prefix_and_suffix (user_entry->pw_dir, filename, user_len);
#endif

  xfree (username);
#if defined (HAVE_GETPWENT)
  endpwent ();
#endif
  return (dirname);
}


#if defined (TEST)
#undef NULL
#include <stdio.h>

main (argc, argv)
     int argc;
     char **argv;
{
  char *result, line[512];
  int done = 0;

  while (!done)
    {
      printf ("~expand: ");
      fflush (stdout);

      if (!gets (line))
	strcpy (line, "done");

      if ((strcmp (line, "done") == 0) ||
	  (strcmp (line, "quit") == 0) ||
	  (strcmp (line, "exit") == 0))
	{
	  done = 1;
	  break;
	}

      result = tilde_expand (line);
      printf ("  --> %s\n", result);
      free (result);
    }
  exit (0);
}

static void memory_error_and_abort ();

static void *
xmalloc (bytes)
     size_t bytes;
{
  void *temp = (char *)malloc (bytes);

  if (!temp)
    memory_error_and_abort ();
  return (temp);
}

static void *
xrealloc (pointer, bytes)
     void *pointer;
     int bytes;
{
  void *temp;

  if (!pointer)
    temp = malloc (bytes);
  else
    temp = realloc (pointer, bytes);

  if (!temp)
    memory_error_and_abort ();

  return (temp);
}

static void
memory_error_and_abort ()
{
  fprintf (stderr, "readline: out of virtual memory\n");
  abort ();
}

/*
 * Local variables:
 * compile-command: "gcc -g -DTEST -o tilde tilde.c"
 * end:
 */
#endif /* TEST */
@


1.7
log
@Readline 5.1 import for HEAD.
@
text
@d3 1
a3 1
/* Copyright (C) 1988,1989 Free Software Foundation, Inc.
d5 2
a6 2
   This file is part of GNU Readline, a library for reading lines
   of text with interactive input and history editing.
d8 9
a16 9
   Readline is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   Readline is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.
d19 2
a20 2
   along with Readline; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
d239 1
a239 1
      free (tilde_word);
d254 1
a254 1
      free (expansion);
d380 2
a381 2
	  free (username);
	  free (expansion);
d404 1
a404 1
	      free (expansion);
a406 1
      free (username);
d414 5
a418 4
    {
      free (username);
      dirname = glue_prefix_and_suffix (user_entry->pw_dir, filename, user_len);
    }
@


1.6
log
@touched all sources to ease import of readline-5.1
@
text
@d46 1
a46 1
#ifdef HAVE_PWD_H
d48 1
a48 1
#endif /* HAVE_PWD_H */
d58 2
a59 1
#if defined (HAVE_GETPWNAM) && !defined (HAVE_GETPW_DECLS)
d61 2
d64 2
a65 1
#endif /* defined (HAVE_GETPWNAM) && !HAVE_GETPW_DECLS */
d286 33
d389 1
a389 1
#ifdef HAVE_GETPWNAM
d391 3
d413 1
a418 1

@


1.6.2.1
log
@Import readline 5.1 on the branch.
@
text
@d46 1
a46 1
#if defined (HAVE_PWD_H)
d48 1
a48 1
#endif
d58 1
a58 2
#if !defined (HAVE_GETPW_DECLS)
#  if defined (HAVE_GETPWUID)
a59 2
#  endif
#  if defined (HAVE_GETPWNAM)
d61 1
a61 2
#  endif
#endif /* !HAVE_GETPW_DECLS */
a281 33
#if 0
/* Public function to scan a string (FNAME) beginning with a tilde and find
   the portion of the string that should be passed to the tilde expansion
   function.  Right now, it just calls tilde_find_suffix and allocates new
   memory, but it can be expanded to do different things later. */
char *
tilde_find_word (fname, flags, lenp)
     const char *fname;
     int flags, *lenp;
{
  int x;
  char *r;

  x = tilde_find_suffix (fname);
  if (x == 0)
    {
      r = savestring (fname);
      if (lenp)
	*lenp = 0;
    }
  else
    {
      r = (char *)xmalloc (1 + x);
      strncpy (r, fname, x);
      r[x] = '\0';
      if (lenp)
	*lenp = x;
    }

  return r;
}
#endif

d352 1
a352 1
#if defined (HAVE_GETPWNAM)
a353 3
#else
  user_entry = 0;
#endif
a372 1
#if defined (HAVE_GETPWENT)
d378 1
@


1.5
log
@	* readline/aclocal.m4: Use AC_TRY_LINK to check for mbstate_t.
	* readline/complete.c (pwd.h): Guard with HAVE_PWD_H.
	(getpwent): Guard with HAVE_GETPWENT.
	(rl_username_completion_function): Guard use of getpwent.
	(endpwent): Likewise.
	* readline/config.h.in (HAVE_FCNTL): New macro.
	(HAVE_GETPWENT): Likewise.
	(HAVE_GETPWNAM): Likewise.
	(HAVE_GETPWUID): Likewise.
	(HAVE_KILL): Likewise.
	(HAVE_PWD_H): Likewise.
	* readline/configure: Regenerated.
	* readline/configure.in: Handle MinGW when cross compiling.  Check for
	getpwnam, getpwent, getpwuid, kill, and pwd.h.
	* readline/display.c (rl_clear_screen): Treat Windows like DOS.
	(insert_some_chars): Likewise.
	(delete_chars): Likewise.
	* readline/shell.c (pwd.h): Guard with HAVE_PWD_H.
	(getpwuid): Guard with HAVE_GETPWUID.
	(sh_unset_nodelay_mode): Guard use of fnctl with HAVE_FNCTL_H.
	* readline/signals.c (rl_signal_handler): Don't use SIGALRM or
	SIGQUIT if not defined.  Use "raise" if "kill" is not available.
	(rl_set_signals): Don't set handlers for SIGQUIT or SIGALRM if
	they are not defined.
	(rl_clear_signals): Likewise.
	* readline/tilde.c (pwd.h): Guard with HAVE_PWD_H.
	(getpwuid): Guard declaration with HAVE_GETPWUID.
	(getpwnam): Guard declaration with HAVE_GETPWNAM.
	(tilde_expand_word): Guard use of getpwnam with HAVE_GETPWNAM.
@
text
@@


1.4
log
@Import of readline 4.3.
Non-readline modified files:

src/gdb/ChangeLog src/gdb/defs.h src/gdb/cli/cli-cmds.c
src/gdb/cli/cli-setshow.c src/gdb/tui/ChangeLog
src/gdb/tui/tuiWin.c

In readline directory:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@d46 1
d48 1
d58 1
a58 1
#if !defined (HAVE_GETPW_DECLS)
d61 1
a61 1
#endif /* !HAVE_GETPW_DECLS */
d352 1
d380 1
@


1.4.60.1
log
@	* readline/Makefile.in (RLTTYOBJ): New variable.
	(OBJECTS): Use RLTTYOBJ.
	* readline/aclocal.m4: Use AC_RTY_LINK to check for mbstate_t.
	* readline/complete.c (pwd.h): Guard with HAVE_PWD_H.
	(getpwent): Guard with HAVE_GETPWENT.
	(rl_username_completion_function): Guard use of getpwent.
	(endpwent): Likewise.
	* readline/config.h.in (HAVE_FCNTL): New macro.
	(HAVE_GETPWENT): Likewise.
	(HAVE_GETPWNAM): Likewise.
	(HAVE_GETPWUID): Likewise.
	(HAVE_PWD_H): Likewise.
	* readline/configure: Regenerated.
	* readline/configure.in: Handle MinGW when cross compiling.  Check for
	getpwnam, getpwent, getpwuid, and pwd.h.  Set RLTTYOBJ.
	* readline/display.c (rl_clear_screen): Treat Windows like DOS.
	(insert_some_chars): Likewise.
	(delete_chars): Likewise.
	* readline/rldefs.h (NEW_TTY_DRIVER): Do not define for Windows.
	* readline/rlnotty.c: New file.
	* readline/shell.c (pwd.h): Guard with HAVE_PWD_H.
	(getpwuid): Guard with HAVE_GETPWUID.
	(sh_unset_nodelay_mode): Guard use of fnctl with HAVE_FNCTL_H.
	* readline/signals.c (rl_signal_handler): Don't use SIGALRM or
	SIGQUIT if not defined.  Use "raise" rather than "kill".
	(rl_set_signals): Don't set handlers for SIGQUIT or SIGALRM if
	they are not defined.
	(rl_clear_signals): Likewise.
	* readline/tilde.c (pwd.h): Guard with HAVE_PWD_H.
	(getpwuid): Guard declaration with HAVE_GETPWUID.
	(getpwnam): Guard declaration with HAVE_GETPWNAM.
	(tilde_expand_word): Guard use of getpwnam with HAVE_GETPWNAM.
@
text
@a45 1
#ifdef HAVE_PWD_H
a46 1
#endif /* HAVE_PWD_H */
d56 1
a56 1
#if defined (HAVE_GETPWNAM) && !defined (HAVE_GETPW_DECLS)
d59 1
a59 1
#endif /* defined (HAVE_GETPWNAM) && !HAVE_GETPW_DECLS */
a349 1
#ifdef HAVE_GETPWNAM
a376 1
#endif
@


1.3
log
@readline:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Locally modified files: Makefile.in, configure.in, configure
        (regenerated), config.h.in (regenerated), readline.h, rltty.c,
 	shell.c signals.c.

        Locally added files: acconfig.h, config/*, config.h.bot,
        cross-build/*, doc/inc-hit.texinfo.

        New files: USAGE, rlprivate.h, rlshell.h, xmalloc.h.
examples:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        New files: excallback.c, rlfe.c.
doc:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Regenerated inc-hist.texinfo as copy of hsuser.texinfo, for
        inclusion in the gdb manual.

        New file: rluserman.texinfo
@
text
@d51 1
a51 1
static char *xmalloc (), *xrealloc ();
d53 1
a53 6
#  if defined __STDC__
extern char *xmalloc (int);
extern char *xrealloc (void *, int);
#  else
extern char *xmalloc (), *xrealloc ();
#  endif /* !__STDC__ */
d57 2
a58 1
extern struct passwd *getpwuid (), *getpwnam ();
d62 1
a62 4
#  ifndef strcpy
extern char *strcpy ();
#  endif
#define savestring(x) strcpy (xmalloc (1 + strlen (x)), (x))
d76 2
a77 2
extern char *get_home_dir __P((void));
extern char *get_env_value __P((char *));
d82 2
a83 2
static char *default_prefixes[] =
  { " ~", "\t~", (char *)NULL };
d88 2
a89 2
static char *default_suffixes[] =
  { " ", "\n", (char *)NULL };
d95 1
a95 1
CPFunction *tilde_expansion_preexpansion_hook = (CPFunction *)NULL;
d101 1
a101 1
CPFunction *tilde_expansion_failure_hook = (CPFunction *)NULL;
d106 1
a106 1
char **tilde_additional_prefixes = default_prefixes;
d111 6
a116 1
char **tilde_additional_suffixes = default_suffixes;
d123 1
a123 1
     char *string;
d158 1
a158 1
     char *string;
d187 1
a187 1
     char *string;
d194 1
a194 1
    result = xmalloc (result_size = (strlen (string) + 16));
d196 1
a196 1
    result = xmalloc (result_size = (strlen (string) + 1));
d210 1
a210 1
	result = xrealloc (result, 1 + (result_size += (start + 20)));
d227 1
a227 1
      tilde_word = xmalloc (1 + end);
d236 1
a236 1
#ifdef __CYGWIN32__
d238 1
a238 1
         $HOME for `user' is /.  On cygwin, // denotes a network drive. */
d243 1
a243 1
	    result = xrealloc (result, 1 + (result_size += (len + 20)));
d261 1
a261 1
     char *fname;
d267 1
a267 1
  ret = xmalloc (strlen (fname));
d284 2
a285 1
     char *prefix, *suffix;
d293 1
a293 1
  ret = xmalloc (plen + slen + 1);
d305 1
a305 1
     char *filename;
d323 1
a323 1
      expansion = get_env_value ("HOME");
d328 1
a328 1
	expansion = get_home_dir ();
d417 1
a417 1
static char *
d419 1
a419 1
     int bytes;
d421 1
a421 1
  char *temp = (char *)malloc (bytes);
d428 1
a428 1
static char *
d430 1
a430 1
     char *pointer;
d433 1
a433 1
  char *temp;
d436 1
a436 1
    temp = (char *)malloc (bytes);
d438 1
a438 1
    temp = (char *)realloc (pointer, bytes);
@


1.3.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d51 1
a51 1
static void *xmalloc (), *xrealloc ();
d53 6
a58 1
#  include "xmalloc.h"
d62 1
a62 2
extern struct passwd *getpwuid PARAMS((uid_t));
extern struct passwd *getpwnam PARAMS((const char *));
d66 4
a69 1
#define savestring(x) strcpy ((char *)xmalloc (1 + strlen (x)), (x))
d83 2
a84 2
extern char *sh_get_home_dir PARAMS((void));
extern char *sh_get_env_value PARAMS((const char *));
d89 2
a90 2
static const char *default_prefixes[] =
  { " ~", "\t~", (const char *)NULL };
d95 2
a96 2
static const char *default_suffixes[] =
  { " ", "\n", (const char *)NULL };
d102 1
a102 1
tilde_hook_func_t *tilde_expansion_preexpansion_hook = (tilde_hook_func_t *)NULL;
d108 1
a108 1
tilde_hook_func_t *tilde_expansion_failure_hook = (tilde_hook_func_t *)NULL;
d113 1
a113 1
char **tilde_additional_prefixes = (char **)default_prefixes;
d118 1
a118 6
char **tilde_additional_suffixes = (char **)default_suffixes;

static int tilde_find_prefix PARAMS((const char *, int *));
static int tilde_find_suffix PARAMS((const char *));
static char *isolate_tilde_prefix PARAMS((const char *, int *));
static char *glue_prefix_and_suffix PARAMS((char *, const char *, int));
d125 1
a125 1
     const char *string;
d160 1
a160 1
     const char *string;
d189 1
a189 1
     const char *string;
d196 1
a196 1
    result = (char *)xmalloc (result_size = (strlen (string) + 16));
d198 1
a198 1
    result = (char *)xmalloc (result_size = (strlen (string) + 1));
d212 1
a212 1
	result = (char *)xrealloc (result, 1 + (result_size += (start + 20)));
d229 1
a229 1
      tilde_word = (char *)xmalloc (1 + end);
d238 1
a238 1
#ifdef __CYGWIN__
d240 1
a240 1
	 $HOME for `user' is /.  On cygwin, // denotes a network drive. */
d245 1
a245 1
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));
d263 1
a263 1
     const char *fname;
d269 1
a269 1
  ret = (char *)xmalloc (strlen (fname));
d286 1
a286 2
     char *prefix;
     const char *suffix;
d294 1
a294 1
  ret = (char *)xmalloc (plen + slen + 1);
d306 1
a306 1
     const char *filename;
d324 1
a324 1
      expansion = sh_get_env_value ("HOME");
d329 1
a329 1
	expansion = sh_get_home_dir ();
d418 1
a418 1
static void *
d420 1
a420 1
     size_t bytes;
d422 1
a422 1
  void *temp = (char *)malloc (bytes);
d429 1
a429 1
static void *
d431 1
a431 1
     void *pointer;
d434 1
a434 1
  void *temp;
d437 1
a437 1
    temp = malloc (bytes);
d439 1
a439 1
    temp = realloc (pointer, bytes);
@


1.3.22.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d51 1
a51 1
static void *xmalloc (), *xrealloc ();
d53 6
a58 1
#  include "xmalloc.h"
d62 1
a62 2
extern struct passwd *getpwuid PARAMS((uid_t));
extern struct passwd *getpwnam PARAMS((const char *));
d66 4
a69 1
#define savestring(x) strcpy ((char *)xmalloc (1 + strlen (x)), (x))
d83 2
a84 2
extern char *sh_get_home_dir PARAMS((void));
extern char *sh_get_env_value PARAMS((const char *));
d89 2
a90 2
static const char *default_prefixes[] =
  { " ~", "\t~", (const char *)NULL };
d95 2
a96 2
static const char *default_suffixes[] =
  { " ", "\n", (const char *)NULL };
d102 1
a102 1
tilde_hook_func_t *tilde_expansion_preexpansion_hook = (tilde_hook_func_t *)NULL;
d108 1
a108 1
tilde_hook_func_t *tilde_expansion_failure_hook = (tilde_hook_func_t *)NULL;
d113 1
a113 1
char **tilde_additional_prefixes = (char **)default_prefixes;
d118 1
a118 6
char **tilde_additional_suffixes = (char **)default_suffixes;

static int tilde_find_prefix PARAMS((const char *, int *));
static int tilde_find_suffix PARAMS((const char *));
static char *isolate_tilde_prefix PARAMS((const char *, int *));
static char *glue_prefix_and_suffix PARAMS((char *, const char *, int));
d125 1
a125 1
     const char *string;
d160 1
a160 1
     const char *string;
d189 1
a189 1
     const char *string;
d196 1
a196 1
    result = (char *)xmalloc (result_size = (strlen (string) + 16));
d198 1
a198 1
    result = (char *)xmalloc (result_size = (strlen (string) + 1));
d212 1
a212 1
	result = (char *)xrealloc (result, 1 + (result_size += (start + 20)));
d229 1
a229 1
      tilde_word = (char *)xmalloc (1 + end);
d238 1
a238 1
#ifdef __CYGWIN__
d240 1
a240 1
	 $HOME for `user' is /.  On cygwin, // denotes a network drive. */
d245 1
a245 1
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));
d263 1
a263 1
     const char *fname;
d269 1
a269 1
  ret = (char *)xmalloc (strlen (fname));
d286 1
a286 2
     char *prefix;
     const char *suffix;
d294 1
a294 1
  ret = (char *)xmalloc (plen + slen + 1);
d306 1
a306 1
     const char *filename;
d324 1
a324 1
      expansion = sh_get_env_value ("HOME");
d329 1
a329 1
	expansion = sh_get_home_dir ();
d418 1
a418 1
static void *
d420 1
a420 1
     size_t bytes;
d422 1
a422 1
  void *temp = (char *)malloc (bytes);
d429 1
a429 1
static void *
d431 1
a431 1
     void *pointer;
d434 1
a434 1
  void *temp;
d437 1
a437 1
    temp = malloc (bytes);
d439 1
a439 1
    temp = realloc (pointer, bytes);
@


1.3.16.1
log
@2002-08-24  Elena Zannoni  <ezannoni@@redhat.com>

        Import of readline 4.3:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@d51 1
a51 1
static void *xmalloc (), *xrealloc ();
d53 6
a58 1
#  include "xmalloc.h"
d62 1
a62 2
extern struct passwd *getpwuid PARAMS((uid_t));
extern struct passwd *getpwnam PARAMS((const char *));
d66 4
a69 1
#define savestring(x) strcpy ((char *)xmalloc (1 + strlen (x)), (x))
d83 2
a84 2
extern char *sh_get_home_dir PARAMS((void));
extern char *sh_get_env_value PARAMS((const char *));
d89 2
a90 2
static const char *default_prefixes[] =
  { " ~", "\t~", (const char *)NULL };
d95 2
a96 2
static const char *default_suffixes[] =
  { " ", "\n", (const char *)NULL };
d102 1
a102 1
tilde_hook_func_t *tilde_expansion_preexpansion_hook = (tilde_hook_func_t *)NULL;
d108 1
a108 1
tilde_hook_func_t *tilde_expansion_failure_hook = (tilde_hook_func_t *)NULL;
d113 1
a113 1
char **tilde_additional_prefixes = (char **)default_prefixes;
d118 1
a118 6
char **tilde_additional_suffixes = (char **)default_suffixes;

static int tilde_find_prefix PARAMS((const char *, int *));
static int tilde_find_suffix PARAMS((const char *));
static char *isolate_tilde_prefix PARAMS((const char *, int *));
static char *glue_prefix_and_suffix PARAMS((char *, const char *, int));
d125 1
a125 1
     const char *string;
d160 1
a160 1
     const char *string;
d189 1
a189 1
     const char *string;
d196 1
a196 1
    result = (char *)xmalloc (result_size = (strlen (string) + 16));
d198 1
a198 1
    result = (char *)xmalloc (result_size = (strlen (string) + 1));
d212 1
a212 1
	result = (char *)xrealloc (result, 1 + (result_size += (start + 20)));
d229 1
a229 1
      tilde_word = (char *)xmalloc (1 + end);
d238 1
a238 1
#ifdef __CYGWIN__
d240 1
a240 1
	 $HOME for `user' is /.  On cygwin, // denotes a network drive. */
d245 1
a245 1
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));
d263 1
a263 1
     const char *fname;
d269 1
a269 1
  ret = (char *)xmalloc (strlen (fname));
d286 1
a286 2
     char *prefix;
     const char *suffix;
d294 1
a294 1
  ret = (char *)xmalloc (plen + slen + 1);
d306 1
a306 1
     const char *filename;
d324 1
a324 1
      expansion = sh_get_env_value ("HOME");
d329 1
a329 1
	expansion = sh_get_home_dir ();
d418 1
a418 1
static void *
d420 1
a420 1
     size_t bytes;
d422 1
a422 1
  void *temp = (char *)malloc (bytes);
d429 1
a429 1
static void *
d431 1
a431 1
     void *pointer;
d434 1
a434 1
  void *temp;
d437 1
a437 1
    temp = malloc (bytes);
d439 1
a439 1
    temp = realloc (pointer, bytes);
@


1.2
log
@Dummy commit before importof 4.1 version
@
text
@d10 1
a10 1
   Free Software Foundation; either version 1, or (at your option) any
d20 1
a20 1
   Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
d50 11
a65 1
extern char *xmalloc ();
a79 6
#if defined (TEST) || defined (STATIC_MALLOC)
static char *xmalloc (), *xrealloc ();
#else
extern char *xmalloc (), *xrealloc ();
#endif /* TEST || STATIC_MALLOC */

d83 2
a84 2
extern char *get_home_dir ();
extern char *get_env_value ();
d129 3
a131 1
  register char **prefixes = tilde_additional_prefixes;
d170 3
d174 1
d238 8
a245 2
      if ((result_index + len + 1) > result_size)
	result = xrealloc (result, 1 + (result_size += (len + 20)));
d247 3
a249 2
      strcpy (result + result_index, expansion);
      result_index += len;
d270 3
d274 1
d295 1
a295 1
  if (prefix && *prefix)
@


1.1
log
@Initial revision
@
text
@a49 4
#ifdef SHELL
#include "shell.h"
#endif

d76 6
a175 9
#if !defined (SHELL)
static char *
get_string_value (varname)
     char *varname;
{
  return ((char *)getenv (varname));
}
#endif

a279 21
static char *
get_home_dir ()
{
  char *home_dir;

#ifdef SHELL
  home_dir = (char *)NULL;
  if (current_user.home_dir == 0)
    get_current_user_info ();
  home_dir = current_user.home_dir;
#else
  struct passwd *entry;

  home_dir = (char *)NULL;
  entry = getpwuid (getuid ());
  if (entry)
    home_dir = entry->pw_dir;
#endif
  return (home_dir);
}

d303 1
a303 1
      expansion = get_string_value ("HOME");
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-08-02 snapshot
@
text
@d50 4
a79 6
/* If being compiled as part of bash, these will be satisfied from
   variables.o.  If being compiled as part of readline, they will
   be satisfied from shell.o. */
extern char *get_home_dir ();
extern char *get_env_value ();

d174 9
d287 21
d331 1
a331 1
      expansion = get_env_value ("HOME");
@


1.1.1.3
log
@Import of readline 4.1
@
text
@d10 1
a10 1
   Free Software Foundation; either version 2, or (at your option) any
d20 1
a20 1
   Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
a49 11
#if defined (TEST) || defined (STATIC_MALLOC)
static char *xmalloc (), *xrealloc ();
#else
#  if defined __STDC__
extern char *xmalloc (int);
extern char *xrealloc (void *, int);
#  else
extern char *xmalloc (), *xrealloc ();
#  endif /* !__STDC__ */
#endif /* TEST || STATIC_MALLOC */

d55 1
d70 6
d79 2
a80 2
extern char *get_home_dir __P((void));
extern char *get_env_value __P((char *));
d125 1
a125 3
  register char **prefixes;

  prefixes = tilde_additional_prefixes;
a163 3
#if defined (__MSDOS__)
      if (string[i] == '/' || string[i] == '\\' /* || !string[i] */)
#else
a164 1
#endif
d228 2
a229 8
#ifdef __CYGWIN32__
      /* Fix for Cygwin to prevent ~user/xxx from expanding to //xxx when
         $HOME for `user' is /.  On cygwin, // denotes a network drive. */
      if (len > 1 || *expansion != '/' || *string != '/')
#endif
	{
	  if ((result_index + len + 1) > result_size)
	    result = xrealloc (result, 1 + (result_size += (len + 20)));
d231 2
a232 3
	  strcpy (result + result_index, expansion);
	  result_index += len;
	}
a252 3
#if defined (__MSDOS__)
  for (i = 1; fname[i] && fname[i] != '/' && fname[i] != '\\'; i++)
#else
a253 1
#endif
d274 1
a274 1
  if (plen)
@


1.1.1.4
log
@import of readline-4.3
@
text
@d51 1
a51 1
static void *xmalloc (), *xrealloc ();
d53 6
a58 1
#  include "xmalloc.h"
d62 1
a62 2
extern struct passwd *getpwuid PARAMS((uid_t));
extern struct passwd *getpwnam PARAMS((const char *));
d66 4
a69 1
#define savestring(x) strcpy ((char *)xmalloc (1 + strlen (x)), (x))
d83 2
a84 2
extern char *sh_get_home_dir PARAMS((void));
extern char *sh_get_env_value PARAMS((const char *));
d89 2
a90 2
static const char *default_prefixes[] =
  { " ~", "\t~", (const char *)NULL };
d95 2
a96 2
static const char *default_suffixes[] =
  { " ", "\n", (const char *)NULL };
d102 1
a102 1
tilde_hook_func_t *tilde_expansion_preexpansion_hook = (tilde_hook_func_t *)NULL;
d108 1
a108 1
tilde_hook_func_t *tilde_expansion_failure_hook = (tilde_hook_func_t *)NULL;
d113 1
a113 1
char **tilde_additional_prefixes = (char **)default_prefixes;
d118 1
a118 6
char **tilde_additional_suffixes = (char **)default_suffixes;

static int tilde_find_prefix PARAMS((const char *, int *));
static int tilde_find_suffix PARAMS((const char *));
static char *isolate_tilde_prefix PARAMS((const char *, int *));
static char *glue_prefix_and_suffix PARAMS((char *, const char *, int));
d125 1
a125 1
     const char *string;
d160 1
a160 1
     const char *string;
d189 1
a189 1
     const char *string;
d196 1
a196 1
    result = (char *)xmalloc (result_size = (strlen (string) + 16));
d198 1
a198 1
    result = (char *)xmalloc (result_size = (strlen (string) + 1));
d212 1
a212 1
	result = (char *)xrealloc (result, 1 + (result_size += (start + 20)));
d229 1
a229 1
      tilde_word = (char *)xmalloc (1 + end);
d238 1
a238 1
#ifdef __CYGWIN__
d240 1
a240 1
	 $HOME for `user' is /.  On cygwin, // denotes a network drive. */
d245 1
a245 1
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));
d263 1
a263 1
     const char *fname;
d269 1
a269 1
  ret = (char *)xmalloc (strlen (fname));
d286 1
a286 2
     char *prefix;
     const char *suffix;
d294 1
a294 1
  ret = (char *)xmalloc (plen + slen + 1);
d306 1
a306 1
     const char *filename;
d324 1
a324 1
      expansion = sh_get_env_value ("HOME");
d329 1
a329 1
	expansion = sh_get_home_dir ();
d418 1
a418 1
static void *
d420 1
a420 1
     size_t bytes;
d422 1
a422 1
  void *temp = (char *)malloc (bytes);
d429 1
a429 1
static void *
d431 1
a431 1
     void *pointer;
d434 1
a434 1
  void *temp;
d437 1
a437 1
    temp = malloc (bytes);
d439 1
a439 1
    temp = realloc (pointer, bytes);
@


1.1.1.5
log
@import of readlilne 5.1
@
text
@a45 1
#if defined (HAVE_PWD_H)
a46 1
#endif
a56 1
#  if defined (HAVE_GETPWUID)
a57 2
#  endif
#  if defined (HAVE_GETPWNAM)
a58 1
#  endif
a279 33
#if 0
/* Public function to scan a string (FNAME) beginning with a tilde and find
   the portion of the string that should be passed to the tilde expansion
   function.  Right now, it just calls tilde_find_suffix and allocates new
   memory, but it can be expanded to do different things later. */
char *
tilde_find_word (fname, flags, lenp)
     const char *fname;
     int flags, *lenp;
{
  int x;
  char *r;

  x = tilde_find_suffix (fname);
  if (x == 0)
    {
      r = savestring (fname);
      if (lenp)
	*lenp = 0;
    }
  else
    {
      r = (char *)xmalloc (1 + x);
      strncpy (r, fname, x);
      r[x] = '\0';
      if (lenp)
	*lenp = x;
    }

  return r;
}
#endif

a349 1
#if defined (HAVE_GETPWNAM)
a350 3
#else
  user_entry = 0;
#endif
d375 1
a375 1
#if defined (HAVE_GETPWENT)
a376 1
#endif
@


