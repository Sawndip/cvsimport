head	1.13;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.13
	gdb_7_6-2013-04-26-release:1.13
	gdb_7_6-branch:1.13.0.2
	gdb_7_6-2013-03-12-branchpoint:1.13
	gdb_7_5_1-2012-11-29-release:1.12
	gdb_7_5-2012-08-17-release:1.12
	gdb_7_5-branch:1.12.0.4
	gdb_7_5-2012-07-18-branchpoint:1.12
	gdb_7_4_1-2012-04-26-release:1.12
	gdb_7_4-2012-01-24-release:1.12
	gdb_7_4-branch:1.12.0.2
	gdb_7_4-2011-12-13-branchpoint:1.12
	gdb_7_3_1-2011-09-04-release:1.11
	gdb_7_3-2011-07-26-release:1.11
	gdb_7_3-branch:1.11.0.32
	gdb_7_3-2011-04-01-branchpoint:1.11
	gdb_7_2-2010-09-02-release:1.11
	gdb_7_2-branch:1.11.0.30
	gdb_7_2-2010-07-07-branchpoint:1.11
	gdb_7_1-2010-03-18-release:1.11
	gdb_7_1-branch:1.11.0.28
	gdb_7_1-2010-02-18-branchpoint:1.11
	gdb_7_0_1-2009-12-22-release:1.11
	gdb_7_0-2009-10-06-release:1.11
	gdb_7_0-branch:1.11.0.26
	gdb_7_0-2009-09-16-branchpoint:1.11
	arc-sim-20090309:1.11
	msnyder-checkpoint-072509-branch:1.11.0.24
	msnyder-checkpoint-072509-branchpoint:1.11
	arc-insight_6_8-branch:1.11.0.22
	arc-insight_6_8-branchpoint:1.11
	insight_6_8-branch:1.11.0.20
	insight_6_8-branchpoint:1.11
	reverse-20081226-branch:1.11.0.18
	reverse-20081226-branchpoint:1.11
	multiprocess-20081120-branch:1.11.0.16
	multiprocess-20081120-branchpoint:1.11
	reverse-20080930-branch:1.11.0.14
	reverse-20080930-branchpoint:1.11
	reverse-20080717-branch:1.11.0.12
	reverse-20080717-branchpoint:1.11
	msnyder-reverse-20080609-branch:1.11.0.10
	msnyder-reverse-20080609-branchpoint:1.11
	drow-reverse-20070409-branch:1.11.0.8
	drow-reverse-20070409-branchpoint:1.11
	gdb_6_8-2008-03-27-release:1.11
	gdb_6_8-branch:1.11.0.6
	gdb_6_8-2008-02-26-branchpoint:1.11
	gdb_6_7_1-2007-10-29-release:1.11
	gdb_6_7-2007-10-10-release:1.11
	gdb_6_7-branch:1.11.0.4
	gdb_6_7-2007-09-07-branchpoint:1.11
	insight_6_6-20070208-release:1.11
	gdb_6_6-2006-12-18-release:1.11
	gdb_6_6-branch:1.11.0.2
	gdb_6_6-2006-11-15-branchpoint:1.11
	insight_6_5-20061003-release:1.10
	gdb-csl-symbian-6_4_50_20060226-12:1.8
	gdb-csl-sourcerygxx-3_4_4-25:1.7
	nickrob-async-20060828-mergepoint:1.10
	gdb-csl-symbian-6_4_50_20060226-11:1.8
	gdb-csl-sourcerygxx-4_1-17:1.8
	gdb-csl-20060226-branch-local-2:1.8
	gdb-csl-sourcerygxx-4_1-14:1.8
	gdb-csl-sourcerygxx-4_1-13:1.8
	gdb-csl-sourcerygxx-4_1-12:1.8
	gdb-csl-sourcerygxx-3_4_4-21:1.8
	gdb_6_5-20060621-release:1.10
	gdb-csl-sourcerygxx-4_1-9:1.8
	gdb-csl-sourcerygxx-4_1-8:1.8
	gdb-csl-sourcerygxx-4_1-7:1.8
	gdb-csl-arm-2006q1-6:1.8
	gdb-csl-sourcerygxx-4_1-6:1.8
	gdb-csl-symbian-6_4_50_20060226-10:1.8
	gdb-csl-symbian-6_4_50_20060226-9:1.8
	gdb-csl-symbian-6_4_50_20060226-8:1.8
	gdb-csl-coldfire-4_1-11:1.8
	gdb-csl-sourcerygxx-3_4_4-19:1.8
	gdb-csl-coldfire-4_1-10:1.8
	gdb_6_5-branch:1.10.0.4
	gdb_6_5-2006-05-14-branchpoint:1.10
	gdb-csl-sourcerygxx-4_1-5:1.8
	nickrob-async-20060513-branch:1.10.0.2
	nickrob-async-20060513-branchpoint:1.10
	gdb-csl-sourcerygxx-4_1-4:1.8
	msnyder-reverse-20060502-branch:1.9.0.4
	msnyder-reverse-20060502-branchpoint:1.9
	gdb-csl-morpho-4_1-4:1.8
	gdb-csl-sourcerygxx-3_4_4-17:1.8
	readline_5_1-import-branch:1.9.0.2
	readline_5_1-import-branchpoint:1.9
	readline-pre-51-import:1.9
	readline_5_1:1.1.1.7
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.8
	gdb-csl-symbian-20060226-branch:1.8.0.8
	gdb-csl-symbian-20060226-branchpoint:1.8
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.8
	msnyder-reverse-20060331-branch:1.8.0.6
	msnyder-reverse-20060331-branchpoint:1.8
	gdb-csl-available-20060303-branch:1.8.0.4
	gdb-csl-available-20060303-branchpoint:1.8
	gdb-csl-20060226-branch:1.8.0.2
	gdb-csl-20060226-branchpoint:1.8
	gdb_6_4-20051202-release:1.7
	msnyder-fork-checkpoint-branch:1.7.0.30
	msnyder-fork-checkpoint-branchpoint:1.7
	gdb-csl-gxxpro-6_3-branch:1.7.0.28
	gdb-csl-gxxpro-6_3-branchpoint:1.7
	gdb_6_4-branch:1.7.0.26
	gdb_6_4-2005-11-01-branchpoint:1.7
	gdb-csl-arm-20051020-branch:1.7.0.24
	gdb-csl-arm-20051020-branchpoint:1.7
	msnyder-tracepoint-checkpoint-branch:1.7.0.22
	msnyder-tracepoint-checkpoint-branchpoint:1.7
	gdb-csl-arm-20050325-2005-q1b:1.7
	gdb-csl-arm-20050325-2005-q1a:1.7
	csl-arm-20050325-branch:1.7.0.20
	csl-arm-20050325-branchpoint:1.7
	gdb_6_3-20041109-release:1.7
	gdb_6_3-branch:1.7.0.16
	gdb_6_3-20041019-branchpoint:1.7
	drow_intercu-merge-20040921:1.7
	drow_intercu-merge-20040915:1.7
	jimb-gdb_6_2-e500-branch:1.7.0.18
	jimb-gdb_6_2-e500-branchpoint:1.7
	gdb_6_2-20040730-release:1.7
	gdb_6_2-branch:1.7.0.14
	gdb_6_2-2004-07-10-gmt-branchpoint:1.7
	gdb_6_1_1-20040616-release:1.7
	gdb_6_1-2004-04-05-release:1.7
	drow_intercu-merge-20040402:1.7
	drow_intercu-merge-20040327:1.7
	ezannoni_pie-20040323-branch:1.7.0.12
	ezannoni_pie-20040323-branchpoint:1.7
	cagney_tramp-20040321-mergepoint:1.7
	cagney_tramp-20040309-branch:1.7.0.10
	cagney_tramp-20040309-branchpoint:1.7
	gdb_6_1-branch:1.7.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.7
	drow_intercu-20040221-branch:1.7.0.6
	drow_intercu-20040221-branchpoint:1.7
	cagney_bfdfile-20040213-branch:1.7.0.4
	cagney_bfdfile-20040213-branchpoint:1.7
	drow-cplus-merge-20040208:1.7
	carlton_dictionary-20040126-merge:1.7
	cagney_bigcore-20040122-branch:1.7.0.2
	cagney_bigcore-20040122-branchpoint:1.7
	drow-cplus-merge-20040113:1.7
	drow-cplus-merge-20031224:1.6
	drow-cplus-merge-20031220:1.6
	carlton_dictionary-20031215-merge:1.6
	drow-cplus-merge-20031214:1.6
	carlton-dictionary-20031111-merge:1.6
	gdb_6_0-2003-10-04-release:1.6
	kettenis_sparc-20030918-branch:1.6.0.40
	kettenis_sparc-20030918-branchpoint:1.6
	carlton_dictionary-20030917-merge:1.6
	ezannoni_pie-20030916-branchpoint:1.6
	ezannoni_pie-20030916-branch:1.6.0.38
	cagney_x86i386-20030821-branch:1.6.0.36
	cagney_x86i386-20030821-branchpoint:1.6
	carlton_dictionary-20030805-merge:1.6
	carlton_dictionary-20030627-merge:1.6
	gdb_6_0-branch:1.6.0.34
	gdb_6_0-2003-06-23-branchpoint:1.6
	jimb-ppc64-linux-20030613-branch:1.6.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.6
	cagney_convert-20030606-branch:1.6.0.30
	cagney_convert-20030606-branchpoint:1.6
	cagney_writestrings-20030508-branch:1.6.0.28
	cagney_writestrings-20030508-branchpoint:1.6
	jimb-ppc64-linux-20030528-branch:1.6.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.6
	carlton_dictionary-20030523-merge:1.6
	cagney_fileio-20030521-branch:1.6.0.24
	cagney_fileio-20030521-branchpoint:1.6
	kettenis_i386newframe-20030517-mergepoint:1.6
	jimb-ppc64-linux-20030509-branch:1.6.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.6
	kettenis_i386newframe-20030504-mergepoint:1.6
	carlton_dictionary-20030430-merge:1.6
	kettenis_i386newframe-20030419-branch:1.6.0.20
	kettenis_i386newframe-20030419-branchpoint:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.6
	kettenis_i386newframe-20030406-branch:1.6.0.18
	kettenis_i386newframe-20030406-branchpoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.16
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.14
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.12
	cagney_lazyid-20030317-branchpoint:1.6
	kettenis-i386newframe-20030316-mergepoint:1.6
	offbyone-20030313-branch:1.6.0.10
	offbyone-20030313-branchpoint:1.6
	kettenis-i386newframe-20030308-branch:1.6.0.8
	kettenis-i386newframe-20030308-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.6
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.6
	interps-20030202-branch:1.6.0.4
	interps-20030202-branchpoint:1.6
	cagney-unwind-20030108-branch:1.6.0.2
	cagney-unwind-20030108-branchpoint:1.6
	carlton_dictionary-20021223-merge:1.6
	gdb_5_3-2002-12-12-release:1.5
	readline-pre-43-import:1.5
	carlton_dictionary-20021115-merge:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.24
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.22
	carlton_dictionary-20020920-branchpoint:1.5
	gdb_5_3-branch:1.5.0.20
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.5
	cagney_sysregs-20020825-branch:1.5.0.18
	cagney_sysregs-20020825-branchpoint:1.5
	readline_4_3-import-branch:1.5.0.16
	readline_4_3-import-branchpoint:1.5
	readline_4_3:1.1.1.6
	gdb_5_2_1-2002-07-23-release:1.5
	kseitz_interps-20020528-branch:1.5.0.14
	kseitz_interps-20020528-branchpoint:1.5
	cagney_regbuf-20020515-branch:1.5.0.12
	cagney_regbuf-20020515-branchpoint:1.5
	jimb-macro-020506-branch:1.5.0.10
	jimb-macro-020506-branchpoint:1.5
	gdb_5_2-2002-04-29-release:1.5
	gdb_5_2-branch:1.5.0.8
	gdb_5_2-2002-03-03-branchpoint:1.5
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	cygnus_cvs_20020108_pre:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.4
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.2
	gdb_5_1-2001-07-29-branchpoint:1.5
	insight-precleanup-2001-01-01:1.5
	readline_4_1:1.1.1.5
	readline_4_0:1.1.1.4
	FSF:1.1.1
	readline-pre-41-import:1.3
	gdb-premipsmulti-2000-06-06-branch:1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.13
date	2012.10.18.18.55.41;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2011.05.11.23.38.39;	author jkratoch;	state Exp;
branches;
next	1.11;

1.11
date	2006.11.13.09.33.30;	author fred;	state Exp;
branches;
next	1.10;

1.10
date	2006.05.05.18.26.12;	author drow;	state Exp;
branches;
next	1.9;

1.9
date	2006.04.20.20.13.20;	author ezannoni;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2006.02.23.18.14.43;	author drow;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.30.07.25.18;	author eliz;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.08.22.31.37;	author ezannoni;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.10.15.22.16;	author eliz;	state Exp;
branches
	1.5.16.1
	1.5.22.1
	1.5.24.1;
next	1.4;

1.4
date	2000.07.09.17.19.56;	author ezannoni;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.07.17.15.45;	author ezannoni;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.15.12.05.59;	author eliz;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.54;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.9.2.1
date	2006.04.24.22.00.25;	author drow;	state Exp;
branches;
next	;

1.5.16.1
date	2002.08.25.23.41.17;	author ezannoni;	state Exp;
branches;
next	;

1.5.22.1
date	2002.12.23.19.39.45;	author carlton;	state Exp;
branches;
next	1.5.22.2;

1.5.22.2
date	2004.01.26.19.11.51;	author carlton;	state Exp;
branches;
next	;

1.5.24.1
date	2003.12.14.20.28.14;	author drow;	state Exp;
branches;
next	1.5.24.2;

1.5.24.2
date	2004.01.13.16.12.22;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.54;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.30.29;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.08.02.23.47.59;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.07.07.19.14.17;	author ezannoni;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.07.09.16.21.21;	author ezannoni;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.08.23.22.02.28;	author ezannoni;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.04.20.20.05.37;	author ezannoni;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Remove some extraneous changes in readline/terminal.c

This patch removes some unnecessary differences between the official
version of readline, and GDB's copy of it.

readline/ChangeLog.gdb:

        * terminal.c: Remove duplicate includes of windows.h and
        wincon.h.
        (_rl_get_screen_size): Remove redundant code for MinGW getting
        the console size from the Windows API.
@
text
@/* terminal.c -- controlling the terminal with termcap. */

/* Copyright (C) 1996-2009 Free Software Foundation, Inc.

   This file is part of the GNU Readline Library (Readline), a library
   for reading lines of text with interactive input and history editing.      

   Readline is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Readline is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Readline.  If not, see <http://www.gnu.org/licenses/>.
*/

#define READLINE_LIBRARY

#if defined (HAVE_CONFIG_H)
#  include <config.h>
#endif

#include <sys/types.h>
#include "posixstat.h"
#include <fcntl.h>
#if defined (HAVE_SYS_FILE_H)
#  include <sys/file.h>
#endif /* HAVE_SYS_FILE_H */

#if defined (HAVE_UNISTD_H)
#  include <unistd.h>
#endif /* HAVE_UNISTD_H */

#if defined (HAVE_STDLIB_H)
#  include <stdlib.h>
#else
#  include "ansi_stdlib.h"
#endif /* HAVE_STDLIB_H */

#if defined (HAVE_LOCALE_H)
#  include <locale.h>
#endif

#include <stdio.h>

/* System-specific feature definitions and include files. */
#include "rldefs.h"

#if defined (GWINSZ_IN_SYS_IOCTL) && !defined (TIOCGWINSZ)
#  include <sys/ioctl.h>
#endif /* GWINSZ_IN_SYS_IOCTL && !TIOCGWINSZ */

#ifdef __MSDOS__
# include <pc.h>
#endif

#include "rltty.h"
#include "tcap.h"

/* Some standard library routines. */
#include "readline.h"
#include "history.h"

#include "rlprivate.h"
#include "rlshell.h"
#include "xmalloc.h"

#if defined (__MINGW32__)
#  include <windows.h>
#  include <wincon.h>

static void _win_get_screensize PARAMS((int *, int *));
#endif

#if defined (__EMX__)
static void _emx_get_screensize PARAMS((int *, int *));
#endif

#define CUSTOM_REDISPLAY_FUNC() (rl_redisplay_function != rl_redisplay)
#define CUSTOM_INPUT_FUNC() (rl_getc_function != rl_getc)

/*  If the calling application sets this to a non-zero value, readline will
    use the $LINES and $COLUMNS environment variables to set its idea of the
    window size before interrogating the kernel. */
int rl_prefer_env_winsize = 0;

/* **************************************************************** */
/*								    */
/*			Terminal and Termcap			    */
/*								    */
/* **************************************************************** */

#ifndef __MSDOS__
static char *term_buffer = (char *)NULL;
static char *term_string_buffer = (char *)NULL;
#endif /* !__MSDOS__ */

static int tcap_initialized;

#if !defined (__linux__) && !defined (NCURSES_VERSION)
#  if defined (__EMX__) || defined (NEED_EXTERN_PC)
extern 
#  endif /* __EMX__ || NEED_EXTERN_PC */
char PC, *BC, *UP;
#endif /* !__linux__ && !NCURSES_VERSION */

/* Some strings to control terminal actions.  These are output by tputs (). */
char *_rl_term_clreol;
char *_rl_term_clrpag;
char *_rl_term_cr;
char *_rl_term_backspace;
char *_rl_term_goto;
char *_rl_term_pc;

/* Non-zero if we determine that the terminal can do character insertion. */
int _rl_terminal_can_insert = 0;

/* How to insert characters. */
char *_rl_term_im;
char *_rl_term_ei;
char *_rl_term_ic;
char *_rl_term_ip;
char *_rl_term_IC;

/* How to delete characters. */
char *_rl_term_dc;
char *_rl_term_DC;

char *_rl_term_forward_char;

/* How to go up a line. */
char *_rl_term_up;

/* A visible bell; char if the terminal can be made to flash the screen. */
static char *_rl_visible_bell;

/* Non-zero means the terminal can auto-wrap lines. */
int _rl_term_autowrap = -1;

/* Non-zero means that this terminal has a meta key. */
static int term_has_meta;

/* The sequences to write to turn on and off the meta key, if this
   terminal has one. */
static char *_rl_term_mm;
static char *_rl_term_mo;

/* The key sequences output by the arrow keys, if this terminal has any. */
static char *_rl_term_ku;
static char *_rl_term_kd;
static char *_rl_term_kr;
static char *_rl_term_kl;

/* How to initialize and reset the arrow keys, if this terminal has any. */
static char *_rl_term_ks;
static char *_rl_term_ke;

/* The key sequences sent by the Home and End keys, if any. */
static char *_rl_term_kh;
static char *_rl_term_kH;
static char *_rl_term_at7;	/* @@7 */

/* Delete key */
static char *_rl_term_kD;

/* Insert key */
static char *_rl_term_kI;

/* Cursor control */
static char *_rl_term_vs;	/* very visible */
static char *_rl_term_ve;	/* normal */

static void bind_termcap_arrow_keys PARAMS((Keymap));

/* Variables that hold the screen dimensions, used by the display code. */
int _rl_screenwidth, _rl_screenheight, _rl_screenchars;

/* Non-zero means the user wants to enable the keypad. */
int _rl_enable_keypad;

/* Non-zero means the user wants to enable a meta key. */
int _rl_enable_meta = 1;

#if defined (__EMX__)
static void
_emx_get_screensize (swp, shp)
     int *swp, *shp;
{
  int sz[2];

  _scrsize (sz);

  if (swp)
    *swp = sz[0];
  if (shp)
    *shp = sz[1];
}
#endif

#if defined (__MINGW32__)
static void
_win_get_screensize (swp, shp)
     int *swp, *shp;
{
  HANDLE hConOut;
  CONSOLE_SCREEN_BUFFER_INFO scr;

  hConOut = GetStdHandle (STD_OUTPUT_HANDLE);
  if (hConOut != INVALID_HANDLE_VALUE)
    {
      if (GetConsoleScreenBufferInfo (hConOut, &scr))
	{
	  *swp = scr.dwSize.X;
	  *shp = scr.srWindow.Bottom - scr.srWindow.Top + 1;
	}
    }
}
#endif

/* Get readline's idea of the screen size.  TTY is a file descriptor open
   to the terminal.  If IGNORE_ENV is true, we do not pay attention to the
   values of $LINES and $COLUMNS.  The tests for TERM_STRING_BUFFER being
   non-null serve to check whether or not we have initialized termcap. */
void
_rl_get_screen_size (tty, ignore_env)
     int tty, ignore_env;
{
  char *ss;
#if defined (TIOCGWINSZ)
  struct winsize window_size;
#endif /* TIOCGWINSZ */
  int wr, wc;

  wr = wc = -1;
#if defined (TIOCGWINSZ)
  if (ioctl (tty, TIOCGWINSZ, &window_size) == 0)
    {
      wc = (int) window_size.ws_col;
      wr = (int) window_size.ws_row;
    }
#endif /* TIOCGWINSZ */

#if defined (__EMX__)
  _emx_get_screensize (&wc, &wr);
#elif defined (__MINGW32__)
  _win_get_screensize (&wc, &wr);
#endif

  if (ignore_env || rl_prefer_env_winsize == 0)
    {
      _rl_screenwidth = wc;
      _rl_screenheight = wr;
    }
  else
    _rl_screenwidth = _rl_screenheight = -1;

  /* Environment variable COLUMNS overrides setting of "co" if IGNORE_ENV
     is unset.  If we prefer the environment, check it first before
     assigning the value returned by the kernel. */
  if (_rl_screenwidth <= 0)
    {
      if (ignore_env == 0 && (ss = sh_get_env_value ("COLUMNS")))
	_rl_screenwidth = atoi (ss);

      if (_rl_screenwidth <= 0)
        _rl_screenwidth = wc;

#if defined (__DJGPP__)
      if (_rl_screenwidth <= 0)
	_rl_screenwidth = ScreenCols ();
#else
      if (_rl_screenwidth <= 0 && term_string_buffer)
	_rl_screenwidth = tgetnum ("co");
#endif
    }

  /* Environment variable LINES overrides setting of "li" if IGNORE_ENV
     is unset. */
  if (_rl_screenheight <= 0)
    {
      if (ignore_env == 0 && (ss = sh_get_env_value ("LINES")))
	_rl_screenheight = atoi (ss);

      if (_rl_screenheight <= 0)
        _rl_screenheight = wr;

#if defined (__DJGPP__)
      if (_rl_screenheight <= 0)
	_rl_screenheight = ScreenRows ();
#else
      if (_rl_screenheight <= 0 && term_string_buffer)
	_rl_screenheight = tgetnum ("li");
#endif
    }

  /* If all else fails, default to 80x24 terminal. */
  if (_rl_screenwidth <= 1)
    _rl_screenwidth = 80;

  if (_rl_screenheight <= 0)
    _rl_screenheight = 24;

  /* If we're being compiled as part of bash, set the environment
     variables $LINES and $COLUMNS to new values.  Otherwise, just
     do a pair of putenv () or setenv () calls. */
  sh_set_lines_and_columns (_rl_screenheight, _rl_screenwidth);

  if (_rl_term_autowrap == 0)
    _rl_screenwidth--;

  _rl_screenchars = _rl_screenwidth * _rl_screenheight;
}

void
_rl_set_screen_size (rows, cols)
     int rows, cols;
{
  if (_rl_term_autowrap == -1)
    _rl_init_terminal_io (rl_terminal_name);

  if (rows > 0)
    _rl_screenheight = rows;
  if (cols > 0)
    {
      _rl_screenwidth = cols;
      if (_rl_term_autowrap == 0)
	_rl_screenwidth--;
    }

  if (rows > 0 || cols > 0)
    _rl_screenchars = _rl_screenwidth * _rl_screenheight;
}

void
rl_set_screen_size (rows, cols)
     int rows, cols;
{
  _rl_set_screen_size (rows, cols);
}

void
rl_get_screen_size (rows, cols)
     int *rows, *cols;
{
  if (rows)
    *rows = _rl_screenheight;
  if (cols)
    *cols = _rl_screenwidth;
}

void
rl_reset_screen_size ()
{
  _rl_get_screen_size (fileno (rl_instream), 0);
}
     
void
rl_resize_terminal ()
{
  _rl_get_screen_size (fileno (rl_instream), 1);
  if (_rl_echoing_p)
    {
      if (CUSTOM_REDISPLAY_FUNC ())
	rl_forced_update_display ();
      else if (RL_ISSTATE(RL_STATE_REDISPLAYING) == 0)
	_rl_redisplay_after_sigwinch ();
    }
}

struct _tc_string {
     const char * const tc_var;
     char **tc_value;
};

/* This should be kept sorted, just in case we decide to change the
   search algorithm to something smarter. */
static const struct _tc_string tc_strings[] =
{
  { "@@7", &_rl_term_at7 },
  { "DC", &_rl_term_DC },
  { "IC", &_rl_term_IC },
  { "ce", &_rl_term_clreol },
  { "cl", &_rl_term_clrpag },
  { "cr", &_rl_term_cr },
  { "dc", &_rl_term_dc },
  { "ei", &_rl_term_ei },
  { "ic", &_rl_term_ic },
  { "im", &_rl_term_im },
  { "kD", &_rl_term_kD },	/* delete */
  { "kH", &_rl_term_kH },	/* home down ?? */
  { "kI", &_rl_term_kI },	/* insert */
  { "kd", &_rl_term_kd },
  { "ke", &_rl_term_ke },	/* end keypad mode */
  { "kh", &_rl_term_kh },	/* home */
  { "kl", &_rl_term_kl },
  { "kr", &_rl_term_kr },
  { "ks", &_rl_term_ks },	/* start keypad mode */
  { "ku", &_rl_term_ku },
  { "le", &_rl_term_backspace },
  { "mm", &_rl_term_mm },
  { "mo", &_rl_term_mo },
  { "nd", &_rl_term_forward_char },
  { "pc", &_rl_term_pc },
  { "up", &_rl_term_up },
  { "vb", &_rl_visible_bell },
  { "vs", &_rl_term_vs },
  { "ve", &_rl_term_ve },
};

#define NUM_TC_STRINGS (sizeof (tc_strings) / sizeof (struct _tc_string))

/* Read the desired terminal capability strings into BP.  The capabilities
   are described in the TC_STRINGS table. */
static void
get_term_capabilities (bp)
     char **bp;
{
#if !defined (__DJGPP__)	/* XXX - doesn't DJGPP have a termcap library? */
  register int i;

  for (i = 0; i < NUM_TC_STRINGS; i++)
    *(tc_strings[i].tc_value) = tgetstr ((char *)tc_strings[i].tc_var, bp);
#endif
  tcap_initialized = 1;
}

int
_rl_init_terminal_io (terminal_name)
     const char *terminal_name;
{
  const char *term;
  char *buffer;
  int tty, tgetent_ret;

  term = terminal_name ? terminal_name : sh_get_env_value ("TERM");
  _rl_term_clrpag = _rl_term_cr = _rl_term_clreol = (char *)NULL;
  tty = rl_instream ? fileno (rl_instream) : 0;

  if (term == 0)
    term = "dumb";

#ifdef __MSDOS__
  _rl_term_im = _rl_term_ei = _rl_term_ic = _rl_term_IC = (char *)NULL;
  _rl_term_up = _rl_term_dc = _rl_term_DC = _rl_visible_bell = (char *)NULL;
  _rl_term_ku = _rl_term_kd = _rl_term_kl = _rl_term_kr = (char *)NULL;
  _rl_term_mm = _rl_term_mo = (char *)NULL;
  _rl_terminal_can_insert = term_has_meta = _rl_term_autowrap = 0;
  _rl_term_cr = "\r";
  _rl_term_clreol = _rl_term_clrpag = _rl_term_backspace = (char *)NULL;
  _rl_term_goto = _rl_term_pc = _rl_term_ip = (char *)NULL;
  _rl_term_ks = _rl_term_ke =_rl_term_vs = _rl_term_ve = (char *)NULL;
  _rl_term_kh = _rl_term_kH = _rl_term_at7 = _rl_term_kI = (char *)NULL;
#if defined(HACK_TERMCAP_MOTION)
  _rl_term_forward_char = (char *)NULL;
#endif

  _rl_get_screen_size (tty, 0);
#else  /* !__MSDOS__ */
  /* I've separated this out for later work on not calling tgetent at all
     if the calling application has supplied a custom redisplay function,
     (and possibly if the application has supplied a custom input function). */
  if (CUSTOM_REDISPLAY_FUNC())
    {
      tgetent_ret = -1;
    }
  else
    {
      if (term_string_buffer == 0)
	term_string_buffer = (char *)xmalloc(2032);

      if (term_buffer == 0)
	term_buffer = (char *)xmalloc(4080);

      buffer = term_string_buffer;

      tgetent_ret = tgetent (term_buffer, term);
    }

  if (tgetent_ret <= 0)
    {
      FREE (term_string_buffer);
      FREE (term_buffer);
      buffer = term_buffer = term_string_buffer = (char *)NULL;

      _rl_term_autowrap = 0;	/* used by _rl_get_screen_size */

      /* Allow calling application to set default height and width, using
	 rl_set_screen_size */
      if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
	{
#if defined (__EMX__)
	  _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
	  _rl_screenwidth--;
#else /* !__EMX__ */
	  _rl_get_screen_size (tty, 0);
#endif /* !__EMX__ */
	}

      /* Defaults. */
      if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
        {
	  _rl_screenwidth = 79;
	  _rl_screenheight = 24;
        }

      /* Everything below here is used by the redisplay code (tputs). */
      _rl_screenchars = _rl_screenwidth * _rl_screenheight;
      _rl_term_cr = "\r";
      _rl_term_im = _rl_term_ei = _rl_term_ic = _rl_term_IC = (char *)NULL;
      _rl_term_up = _rl_term_dc = _rl_term_DC = _rl_visible_bell = (char *)NULL;
      _rl_term_ku = _rl_term_kd = _rl_term_kl = _rl_term_kr = (char *)NULL;
      _rl_term_kh = _rl_term_kH = _rl_term_kI = _rl_term_kD = (char *)NULL;
      _rl_term_ks = _rl_term_ke = _rl_term_at7 = (char *)NULL;
      _rl_term_mm = _rl_term_mo = (char *)NULL;
      _rl_term_ve = _rl_term_vs = (char *)NULL;
      _rl_term_forward_char = (char *)NULL;
      _rl_terminal_can_insert = term_has_meta = 0;

      /* Reasonable defaults for tgoto().  Readline currently only uses
         tgoto if _rl_term_IC or _rl_term_DC is defined, but just in case we
         change that later... */
      PC = '\0';
      BC = _rl_term_backspace = "\b";
      UP = _rl_term_up;

      return 0;
    }

  get_term_capabilities (&buffer);

  /* Set up the variables that the termcap library expects the application
     to provide. */
  PC = _rl_term_pc ? *_rl_term_pc : 0;
  BC = _rl_term_backspace;
  UP = _rl_term_up;

  if (!_rl_term_cr)
    _rl_term_cr = "\r";

  _rl_term_autowrap = tgetflag ("am") && tgetflag ("xn");

  /* Allow calling application to set default height and width, using
     rl_set_screen_size */
  if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
    _rl_get_screen_size (tty, 0);

  /* "An application program can assume that the terminal can do
      character insertion if *any one of* the capabilities `IC',
      `im', `ic' or `ip' is provided."  But we can't do anything if
      only `ip' is provided, so... */
  _rl_terminal_can_insert = (_rl_term_IC || _rl_term_im || _rl_term_ic);

  /* Check to see if this terminal has a meta key and clear the capability
     variables if there is none. */
  term_has_meta = tgetflag ("km") != 0;
  if (term_has_meta == 0)
    _rl_term_mm = _rl_term_mo = (char *)NULL;

#endif /* !__MSDOS__ */

  /* Attempt to find and bind the arrow keys.  Do not override already
     bound keys in an overzealous attempt, however. */

  bind_termcap_arrow_keys (emacs_standard_keymap);

#if defined (VI_MODE)
  bind_termcap_arrow_keys (vi_movement_keymap);
  bind_termcap_arrow_keys (vi_insertion_keymap);
#endif /* VI_MODE */

  return 0;
}

/* Bind the arrow key sequences from the termcap description in MAP. */
static void
bind_termcap_arrow_keys (map)
     Keymap map;
{
  Keymap xkeymap;

  xkeymap = _rl_keymap;
  _rl_keymap = map;

  rl_bind_keyseq_if_unbound (_rl_term_ku, rl_get_previous_history);
  rl_bind_keyseq_if_unbound (_rl_term_kd, rl_get_next_history);
  rl_bind_keyseq_if_unbound (_rl_term_kr, rl_forward_char);
  rl_bind_keyseq_if_unbound (_rl_term_kl, rl_backward_char);

  rl_bind_keyseq_if_unbound (_rl_term_kh, rl_beg_of_line);	/* Home */
  rl_bind_keyseq_if_unbound (_rl_term_at7, rl_end_of_line);	/* End */

  rl_bind_keyseq_if_unbound (_rl_term_kD, rl_delete);

  _rl_keymap = xkeymap;
}

char *
rl_get_termcap (cap)
     const char *cap;
{
  register int i;

  if (tcap_initialized == 0)
    return ((char *)NULL);
  for (i = 0; i < NUM_TC_STRINGS; i++)
    {
      if (tc_strings[i].tc_var[0] == cap[0] && strcmp (tc_strings[i].tc_var, cap) == 0)
        return *(tc_strings[i].tc_value);
    }
  return ((char *)NULL);
}

/* Re-initialize the terminal considering that the TERM/TERMCAP variable
   has changed. */
int
rl_reset_terminal (terminal_name)
     const char *terminal_name;
{
  _rl_screenwidth = _rl_screenheight = 0;
  _rl_init_terminal_io (terminal_name);
  return 0;
}

/* A function for the use of tputs () */
#ifdef _MINIX
void
_rl_output_character_function (c)
     int c;
{
  putc (c, _rl_out_stream);
}
#else /* !_MINIX */
int
_rl_output_character_function (c)
     int c;
{
  return putc (c, _rl_out_stream);
}
#endif /* !_MINIX */

/* Write COUNT characters from STRING to the output stream. */
void
_rl_output_some_chars (string, count)
     const char *string;
     int count;
{
  fwrite (string, 1, count, _rl_out_stream);
}

/* Move the cursor back. */
int
_rl_backspace (count)
     int count;
{
  register int i;

#ifndef __MSDOS__
  if (_rl_term_backspace)
    for (i = 0; i < count; i++)
      tputs (_rl_term_backspace, 1, _rl_output_character_function);
  else
#endif
    for (i = 0; i < count; i++)
      putc ('\b', _rl_out_stream);
  return 0;
}

/* Move to the start of the next line. */
int
rl_crlf ()
{
#if defined (NEW_TTY_DRIVER) || defined (__MINT__)
  if (_rl_term_cr)
    tputs (_rl_term_cr, 1, _rl_output_character_function);
#endif /* NEW_TTY_DRIVER || __MINT__ */
  putc ('\n', _rl_out_stream);
  return 0;
}

/* Ring the terminal bell. */
int
rl_ding ()
{
  if (_rl_echoing_p)
    {
      switch (_rl_bell_preference)
        {
	case NO_BELL:
	default:
	  break;
	case VISIBLE_BELL:
#ifdef __MSDOS__
	  ScreenVisualBell ();
	  break;
#else
	  if (_rl_visible_bell)
	    {
	      tputs (_rl_visible_bell, 1, _rl_output_character_function);
	      break;
	    }
	  /* FALLTHROUGH */
#endif
	case AUDIBLE_BELL:
	  fprintf (stderr, "\007");
	  fflush (stderr);
	  break;
        }
      return (0);
    }
  return (-1);
}

/* **************************************************************** */
/*								    */
/*	 	Controlling the Meta Key and Keypad		    */
/*								    */
/* **************************************************************** */

void
_rl_enable_meta_key ()
{
#if !defined (__DJGPP__)
  if (term_has_meta && _rl_term_mm)
    tputs (_rl_term_mm, 1, _rl_output_character_function);
#endif
}

void
_rl_control_keypad (on)
     int on;
{
#if !defined (__DJGPP__)
  if (on && _rl_term_ks)
    tputs (_rl_term_ks, 1, _rl_output_character_function);
  else if (!on && _rl_term_ke)
    tputs (_rl_term_ke, 1, _rl_output_character_function);
#endif
}

/* **************************************************************** */
/*								    */
/*	 		Controlling the Cursor			    */
/*								    */
/* **************************************************************** */

/* Set the cursor appropriately depending on IM, which is one of the
   insert modes (insert or overwrite).  Insert mode gets the normal
   cursor.  Overwrite mode gets a very visible cursor.  Only does
   anything if we have both capabilities. */
void
_rl_set_cursor (im, force)
     int im, force;
{
#ifndef __MSDOS__
  if (_rl_term_ve && _rl_term_vs)
    {
      if (force || im != rl_insert_mode)
	{
	  if (im == RL_IM_OVERWRITE)
	    tputs (_rl_term_vs, 1, _rl_output_character_function);
	  else
	    tputs (_rl_term_ve, 1, _rl_output_character_function);
	}
    }
#endif
}
@


1.12
log
@Imported readline 6.2, and upstream patch 001.

[patch 0/3] readline-6.2 rebase
http://sourceware.org/ml/gdb-patches/2011-05/msg00003.html
[patch 1/3] readline-6.2: Merge of already posted patches
http://sourceware.org/ml/gdb-patches/2011-05/msg00004.html
	=
	[Bug-readline] [RFC/readline] bind.c, rl_function_dumper, Free allocated
	http://lists.gnu.org/archive/html/bug-readline/2011-03/msg00000.html
	[Bug-readline] [patch] Fix underquotation in readline/examples/rlfe/conf
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00001.html
	[Bug-readline] [patch] Makefile.in htm<->html
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00002.html
	Re: [Bug-readline] [patch] Makefile.in dependency: callback.o: xmalloc.h
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00004.html
	[Bug-readline] [patch] Remove . from the VPATH directive
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00005.html
	Eli Zaretskii's __MSDOS__ / __GO32__ / __MINGW32__ / __DJGPP__ stuff:
	http://sourceware.org/ml/gdb/2011-04/msg00002.html
	Jan Kratochvil's patch for FSF GDB tree local-specific changes:
	http://sourceware.org/ml/gdb/2011-04/msg00006.html
	Preservation of existing ChangeLog.gdb files, their updates.
[patch 2/3] readline-6.2: Workaround "ask" regression
http://sourceware.org/ml/gdb-patches/2011-05/msg00005.html
[patch 3/3] readline-6.2: Revert 5.x compat., apply 6.x compat.
http://sourceware.org/ml/gdb-patches/2011-05/msg00006.html
[patch 4/3] readline-6.2: Substitute inc-hist.texinfo
http://sourceware.org/ml/gdb-patches/2011-05/msg00010.html

readline/
	Workaround gdb.base/completion.exp regression on readline-6.2.
	* complete.c (get_y_or_n): Disable the return on RL_STATE_CALLBACK.

	Imported readline 6.2, and upstream patch 001.
	* configure: Regenerate.

readline/doc/
	* hsuser.texi (Using History Interactively): Disable !BashFeatures
	@@defcodeindex.  Make the `Programming with GNU History' reference
	external.
	* inc-hist.texinfo: Remove.

	Imported readline 6.2, and upstream patch 001.

readline/examples/
	Imported readline 6.2, and upstream patch 001.

readline/examples/rlfe/
	Imported readline 6.2, and upstream patch 001.

gdb/
	* config.in: Regenerate.
	* configure: Regenerate.
	* configure.ac <--with-system-readline> (for readline_echoing_p):
	Remove the test.
	* tui/tui-io.c (tui_old_readline_echoing_p): Rename to ...
	(tui_old_rl_echoing_p): ... here.
	(tui_setup_io): Rename extern declaration readline_echoing_p to
	_rl_echoing_p.  Adjust assignments for the both renames.

gdb/doc/
	* Makefile.in (GDB_DOC_SOURCE_INCLUDES): Rename inc-hist.texinfo to
	hsuser.texi.
	* gdb.texinfo <!SYSTEM_READLINE>: Rename inc-hist.texinfo inclusion and
	comment to hsuser.texi.  Change rluser.texi name in the comment.
@
text
@a83 5
#if defined (__MINGW32__)
# include <windows.h>
# include <wincon.h>
#endif

a247 14
  /* For MinGW, we get the console size from the Windows API.  */
#if defined (__MINGW32__)
  HANDLE hConOut = GetStdHandle (STD_OUTPUT_HANDLE);
  if (hConOut != INVALID_HANDLE_VALUE)
    {
      CONSOLE_SCREEN_BUFFER_INFO scr;
      if (GetConsoleScreenBufferInfo (hConOut, &scr))
	{
	  wc = scr.dwSize.X;
	  wr = scr.srWindow.Bottom - scr.srWindow.Top + 1;
	}
    }
#endif

@


1.11
log
@2006-11-13  Denis Pilat  <denis.pilat@@st.com>

	* terminal.c (_rl_get_screen_size): use wr and wc variable to store
	window size.
@
text
@d3 1
a3 1
/* Copyright (C) 1996-2005 Free Software Foundation, Inc.
d5 2
a6 2
   This file is part of the GNU Readline Library, a library for
   reading lines of text with interactive input and history editing.
d8 3
a10 3
   The GNU Readline Library is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2, or
d13 3
a15 3
   The GNU Readline Library is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
d18 4
a21 4
   The GNU General Public License is often shipped with GNU software, and
   is generally kept in a file called COPYING or LICENSE.  If you do not
   have a copy of the license, write to the Free Software Foundation,
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
d74 11
d92 4
a95 1
int rl_prefer_env_winsize;
d110 1
a110 1
#if !defined (__linux__)
d115 1
a115 1
#endif /* __linux__ */
a138 1
#if defined (HACK_TERMCAP_MOTION)
a139 1
#endif  /* HACK_TERMCAP_MOTION */
d210 20
d268 3
a270 1
  _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
d384 2
a385 1
  if (readline_echoing_p)
a386 1
      _rl_get_screen_size (fileno (rl_instream), 1);
d389 1
a389 1
      else
d395 1
a395 1
     const char *tc_var;
d401 1
a401 1
static struct _tc_string tc_strings[] =
a425 1
#if defined (HACK_TERMCAP_MOTION)
a426 1
#endif
d540 1
a540 3
#if defined (HACK_TERMCAP_MOTION)
      term_forward_char = (char *)NULL;
#endif
d579 2
a580 2
  term_has_meta = (tgetflag ("km") || tgetflag ("MT"));
  if (!term_has_meta)
d696 1
a696 1
#if defined (NEW_TTY_DRIVER)
d699 1
a699 1
#endif /* NEW_TTY_DRIVER */
d708 1
a708 1
  if (readline_echoing_p)
@


1.10
log
@Readline 5.1 import for HEAD.
@
text
@d229 2
a230 2
	  _rl_screenwidth = scr.dwSize.X;
	  _rl_screenheight = scr.srWindow.Bottom - scr.srWindow.Top + 1;
@


1.9
log
@touched all sources to ease import of readline-5.1
@
text
@d3 1
a3 1
/* Copyright (C) 1996 Free Software Foundation, Inc.
d81 2
a91 3

/* Non-zero means this terminal can't really do anything. */
static int dumb_term;
d136 1
a136 1
int _rl_term_autowrap;
d161 3
d210 1
d212 1
d216 2
a217 2
      _rl_screenwidth = (int) window_size.ws_col;
      _rl_screenheight = (int) window_size.ws_row;
d239 8
d248 2
a249 1
     is unset. */
d255 3
d274 3
d308 2
a309 2
  if (rows == 0 || cols == 0)
    return;
d311 8
a318 2
  _rl_screenheight = rows;
  _rl_screenwidth = cols;
d320 2
a321 4
  if (_rl_term_autowrap == 0)
    _rl_screenwidth--;

  _rl_screenchars = _rl_screenwidth * _rl_screenheight;
d340 6
d379 1
a413 1
#  ifdef __LCC__
a414 3
#  else
    *(tc_strings[i].tc_value) = tgetstr (tc_strings[i].tc_var, bp);
#  endif
a429 1
  _rl_screenwidth = _rl_screenheight = 0;
d479 4
d484 2
a485 2
      _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
      _rl_screenwidth--;
d487 1
a487 1
      _rl_get_screen_size (tty, 0);
d489 1
d504 1
a504 1
      _rl_term_kh = _rl_term_kH = _rl_term_kI = (char *)NULL;
d536 4
a539 1
  _rl_get_screen_size (tty, 0);
d578 7
a584 4
  _rl_bind_if_unbound (_rl_term_ku, rl_get_previous_history);
  _rl_bind_if_unbound (_rl_term_kd, rl_get_next_history);
  _rl_bind_if_unbound (_rl_term_kr, rl_forward);
  _rl_bind_if_unbound (_rl_term_kl, rl_backward);
d586 1
a586 2
  _rl_bind_if_unbound (_rl_term_kh, rl_beg_of_line);	/* Home */
  _rl_bind_if_unbound (_rl_term_at7, rl_end_of_line);	/* End */
d613 1
d695 1
a696 1
	  /* FALLTHROUGH */
@


1.9.2.1
log
@Import readline 5.1 on the branch.
@
text
@d3 1
a3 1
/* Copyright (C) 1996-2005 Free Software Foundation, Inc.
a80 2
int rl_prefer_env_winsize;

d90 3
d137 1
a137 1
int _rl_term_autowrap = -1;
a161 3
/* Delete key */
static char *_rl_term_kD;

a207 1
  int wr, wc;
a208 1
  wr = wc = -1;
d212 2
a213 2
      wc = (int) window_size.ws_col;
      wr = (int) window_size.ws_row;
a234 8
  if (ignore_env || rl_prefer_env_winsize == 0)
    {
      _rl_screenwidth = wc;
      _rl_screenheight = wr;
    }
  else
    _rl_screenwidth = _rl_screenheight = -1;

d236 1
a236 2
     is unset.  If we prefer the environment, check it first before
     assigning the value returned by the kernel. */
a241 3
      if (_rl_screenwidth <= 0)
        _rl_screenwidth = wc;

a257 3
      if (_rl_screenheight <= 0)
        _rl_screenheight = wr;

d289 2
a290 2
  if (_rl_term_autowrap == -1)
    _rl_init_terminal_io (rl_terminal_name);
d292 5
a296 8
  if (rows > 0)
    _rl_screenheight = rows;
  if (cols > 0)
    {
      _rl_screenwidth = cols;
      if (_rl_term_autowrap == 0)
	_rl_screenwidth--;
    }
d298 1
a298 2
  if (rows > 0 || cols > 0)
    _rl_screenchars = _rl_screenwidth * _rl_screenheight;
a316 6

void
rl_reset_screen_size ()
{
  _rl_get_screen_size (fileno (rl_instream), 0);
}
a349 1
  { "kD", &_rl_term_kD },	/* delete */
d384 1
d386 3
d404 1
a453 4
      /* Allow calling application to set default height and width, using
	 rl_set_screen_size */
      if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
	{
d455 2
a456 2
	  _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
	  _rl_screenwidth--;
d458 1
a458 1
	  _rl_get_screen_size (tty, 0);
a459 1
	}
d474 1
a474 1
      _rl_term_kh = _rl_term_kH = _rl_term_kI = _rl_term_kD = (char *)NULL;
d506 1
a506 4
  /* Allow calling application to set default height and width, using
     rl_set_screen_size */
  if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
    _rl_get_screen_size (tty, 0);
d545 4
a548 7
  rl_bind_keyseq_if_unbound (_rl_term_ku, rl_get_previous_history);
  rl_bind_keyseq_if_unbound (_rl_term_kd, rl_get_next_history);
  rl_bind_keyseq_if_unbound (_rl_term_kr, rl_forward_char);
  rl_bind_keyseq_if_unbound (_rl_term_kl, rl_backward_char);

  rl_bind_keyseq_if_unbound (_rl_term_kh, rl_beg_of_line);	/* Home */
  rl_bind_keyseq_if_unbound (_rl_term_at7, rl_end_of_line);	/* End */
d550 2
a551 1
  rl_bind_keyseq_if_unbound (_rl_term_kD, rl_delete);
a577 1
  _rl_screenwidth = _rl_screenheight = 0;
d659 1
a660 1
#endif
@


1.8
log
@	* readline/terminal.c (_rl_get_screen_size): Get console size from
	the Windows API when compiling with MinGW.
@
text
@@


1.7
log
@	* readline.c (rl_save_state, rl_restore_state): Support systems
	that don't define SIGWINCH.

	* terminal.c (_rl_get_screen_size) [__DJGPP__]: Compute the
	screen width and height using console I/O.
	(_rl_init_terminal_io) [__MSDOS__]: Zero out all the _rl_term_*
	variables.  Convert to _rl_* naming scheme.
	(_rl_set_cursor) [__MSDOS__]: Ifdef away this function.

	* display.c (_rl_move_vert) [__MSDOS__]: Don't use undeclared
	variable `l'.  Use `delta' instead recomputing its value anew.
	Assign -delta to i instead of the other way around.
@
text
@d73 5
d217 14
@


1.6
log
@Import of readline 4.3.
Non-readline modified files:

src/gdb/ChangeLog src/gdb/defs.h src/gdb/cli/cli-cmds.c
src/gdb/cli/cli-setshow.c src/gdb/tui/ChangeLog
src/gdb/tui/tuiWin.c

In readline directory:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@d223 4
a226 1
#if !defined (__DJGPP__)
d239 4
a242 1
#if !defined (__DJGPP__)
d391 13
a403 6
  term_im = term_ei = term_ic = term_IC = (char *)NULL;
  term_up = term_dc = term_DC = visible_bell = (char *)NULL;
  term_ku = term_kd = term_kl = term_kr = (char *)NULL;
  term_mm = term_mo = (char *)NULL;
  terminal_can_insert = term_has_meta = _rl_term_autowrap = 0;
  term_cr = "\r";
d693 1
d704 1
@


1.5
log
@A few tweaks required to use Readline as part of the DJGPP port of GDB.
@
text
@d71 4
d100 6
a105 2
char *term_goto, *term_clreol, *term_cr, *term_clrpag, *term_backspace;
char *term_pc;
d108 1
a108 1
int terminal_can_insert = 0;
d111 5
a115 1
char *term_im, *term_ei, *term_ic, *term_ip, *term_IC;
d118 2
a119 1
char *term_dc, *term_DC;
d122 1
a122 1
char *term_forward_char;
d126 1
a126 1
char *term_up;
d128 2
a129 2
/* A visible bell, if the terminal can be made to flash the screen. */
static char *visible_bell;
d138 3
a140 2
   terminal    has one. */
static char *term_mm, *term_mo;
d143 4
a146 1
static char *term_ku, *term_kd, *term_kr, *term_kl;
d149 2
a150 1
static char *term_ks, *term_ke;
d153 12
a164 1
static char *term_kh, *term_kH;
d167 1
a167 1
int screenwidth, screenheight, screenchars;
d207 2
a208 2
      screenwidth = (int) window_size.ws_col;
      screenheight = (int) window_size.ws_row;
d213 1
a213 1
  _emx_get_screensize (&screenwidth, &screenheight);
d218 1
a218 1
  if (screenwidth <= 0)
d220 2
a221 2
      if (ignore_env == 0 && (ss = get_env_value ("COLUMNS")))
	screenwidth = atoi (ss);
d223 3
a225 6
#if defined (__DJGPP__)
      if (screenwidth <= 0)
	screenwidth = ScreenCols ();
#else
      if (screenwidth <= 0 && term_string_buffer)
	screenwidth = tgetnum ("co");
d231 1
a231 1
  if (screenheight <= 0)
d233 2
a234 2
      if (ignore_env == 0 && (ss = get_env_value ("LINES")))
	screenheight = atoi (ss);
d236 3
a238 6
#if defined (__DJGPP__)
      if (screenheight <= 0)
	screenheight = ScreenRows ();
#else
      if (screenheight <= 0 && term_string_buffer)
	screenheight = tgetnum ("li");
d243 2
a244 2
  if (screenwidth <= 1)
    screenwidth = 80;
d246 2
a247 2
  if (screenheight <= 0)
    screenheight = 24;
d252 1
a252 1
  set_lines_and_columns (screenheight, screenwidth);
d255 1
a255 1
    screenwidth--;
d257 1
a257 1
  screenchars = screenwidth * screenheight;
d264 5
a268 2
  screenheight = rows;
  screenwidth = cols;
d271 1
a271 1
    screenwidth--;
d273 8
a280 1
  screenchars = screenwidth * screenheight;
d284 10
d299 4
a302 1
      _rl_redisplay_after_sigwinch ();
d307 1
a307 1
     char *tc_var;
d315 22
a336 20
  { "DC", &term_DC },
  { "IC", &term_IC },
  { "ce", &term_clreol },
  { "cl", &term_clrpag },
  { "cr", &term_cr },
  { "dc", &term_dc },
  { "ei", &term_ei },
  { "ic", &term_ic },
  { "im", &term_im },
  { "kd", &term_kd },
  { "kh", &term_kh },	/* home */
  { "kH", &term_kH },	/* end */
  { "kl", &term_kl },
  { "kr", &term_kr },
  { "ku", &term_ku },
  { "ks", &term_ks },
  { "ke", &term_ke },
  { "le", &term_backspace },
  { "mm", &term_mm },
  { "mo", &term_mo },
d338 1
a338 1
  { "nd", &term_forward_char },
d340 5
a344 3
  { "pc", &term_pc },
  { "up", &term_up },
  { "vb", &visible_bell },
d359 3
d363 1
a367 3
#define CUSTOM_REDISPLAY_FUNC() (rl_redisplay_function != rl_redisplay)
#define CUSTOM_INPUT_FUNC() (rl_getc_function != rl_getc)

d370 1
a370 1
     char *terminal_name;
d372 2
a373 1
  char *term, *buffer;
a374 1
  Keymap xkeymap;
d376 2
a377 2
  term = terminal_name ? terminal_name : get_env_value ("TERM");
  term_clrpag = term_cr = term_clreol = (char *)NULL;
d379 1
a379 1
  screenwidth = screenheight = 0;
d404 1
a404 1
	term_string_buffer = xmalloc(2032);
d407 1
a407 1
	term_buffer = xmalloc(4080);
a419 1
      dumb_term = 1;
d423 2
a424 2
      _emx_get_screensize (&screenwidth, &screenheight);
      screenwidth--;
d430 1
a430 1
      if (screenwidth <= 0 || screenheight <= 0)
d432 2
a433 2
	  screenwidth = 79;
	  screenheight = 24;
d437 9
a445 6
      screenchars = screenwidth * screenheight;
      term_cr = "\r";
      term_im = term_ei = term_ic = term_IC = (char *)NULL;
      term_up = term_dc = term_DC = visible_bell = (char *)NULL;
      term_ku = term_kd = term_kl = term_kr = (char *)NULL;
      term_mm = term_mo = (char *)NULL;
d449 1
a449 1
      terminal_can_insert = term_has_meta = 0;
d452 1
a452 1
         tgoto if term_IC or term_DC is defined, but just in case we
d455 2
a456 2
      BC = term_backspace = "\b";
      UP = term_up;
d465 3
a467 3
  PC = term_pc ? *term_pc : 0;
  BC = term_backspace;
  UP = term_up;
d469 2
a470 2
  if (!term_cr)
    term_cr = "\r";
d480 1
a480 1
  terminal_can_insert = (term_IC || term_im || term_ic);
d486 1
a486 1
    term_mm = term_mo = (char *)NULL;
a491 1
  xkeymap = _rl_keymap;
d493 16
a508 5
  _rl_keymap = emacs_standard_keymap;
  _rl_bind_if_unbound (term_ku, rl_get_previous_history);
  _rl_bind_if_unbound (term_kd, rl_get_next_history);
  _rl_bind_if_unbound (term_kr, rl_forward);
  _rl_bind_if_unbound (term_kl, rl_backward);
d510 2
a511 2
  _rl_bind_if_unbound (term_kh, rl_beg_of_line);	/* Home */
  _rl_bind_if_unbound (term_kH, rl_end_of_line);	/* End */
d513 4
a516 6
#if defined (VI_MODE)
  _rl_keymap = vi_movement_keymap;
  _rl_bind_if_unbound (term_ku, rl_get_previous_history);
  _rl_bind_if_unbound (term_kd, rl_get_next_history);
  _rl_bind_if_unbound (term_kr, rl_forward);
  _rl_bind_if_unbound (term_kl, rl_backward);
d518 2
a519 3
  _rl_bind_if_unbound (term_kh, rl_beg_of_line);	/* Home */
  _rl_bind_if_unbound (term_kH, rl_end_of_line);	/* End */
#endif /* VI_MODE */
a521 2

  return 0;
d526 1
a526 1
     char *cap;
d544 1
a544 1
     char *terminal_name;
d570 1
a570 1
     char *string;
d584 1
a584 1
  if (term_backspace)
d586 1
a586 1
      tputs (term_backspace, 1, _rl_output_character_function);
d596 1
a596 1
crlf ()
d599 2
a600 2
  if (term_cr)
    tputs (term_cr, 1, _rl_output_character_function);
d608 1
a608 1
ding ()
d622 1
a622 1
	  if (visible_bell)
d624 1
a624 1
	      tputs (visible_bell, 1, _rl_output_character_function);
d649 2
a650 2
  if (term_has_meta && term_mm)
    tputs (term_mm, 1, _rl_output_character_function);
d659 4
a662 4
  if (on && term_ks)
    tputs (term_ks, 1, _rl_output_character_function);
  else if (!on && term_ke)
    tputs (term_ke, 1, _rl_output_character_function);
d664 26
@


1.5.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a70 4
#include "xmalloc.h"

#define CUSTOM_REDISPLAY_FUNC() (rl_redisplay_function != rl_redisplay)
#define CUSTOM_INPUT_FUNC() (rl_getc_function != rl_getc)
d96 2
a97 6
char *_rl_term_clreol;
char *_rl_term_clrpag;
char *_rl_term_cr;
char *_rl_term_backspace;
char *_rl_term_goto;
char *_rl_term_pc;
d100 1
a100 1
int _rl_terminal_can_insert = 0;
d103 1
a103 5
char *_rl_term_im;
char *_rl_term_ei;
char *_rl_term_ic;
char *_rl_term_ip;
char *_rl_term_IC;
d106 1
a106 2
char *_rl_term_dc;
char *_rl_term_DC;
d109 1
a109 1
char *_rl_term_forward_char;
d113 1
a113 1
char *_rl_term_up;
d115 2
a116 2
/* A visible bell; char if the terminal can be made to flash the screen. */
static char *_rl_visible_bell;
d125 2
a126 3
   terminal has one. */
static char *_rl_term_mm;
static char *_rl_term_mo;
d129 1
a129 4
static char *_rl_term_ku;
static char *_rl_term_kd;
static char *_rl_term_kr;
static char *_rl_term_kl;
d132 1
a132 2
static char *_rl_term_ks;
static char *_rl_term_ke;
d135 1
a135 12
static char *_rl_term_kh;
static char *_rl_term_kH;
static char *_rl_term_at7;	/* @@7 */

/* Insert key */
static char *_rl_term_kI;

/* Cursor control */
static char *_rl_term_vs;	/* very visible */
static char *_rl_term_ve;	/* normal */

static void bind_termcap_arrow_keys PARAMS((Keymap));
d138 1
a138 1
int _rl_screenwidth, _rl_screenheight, _rl_screenchars;
d178 2
a179 2
      _rl_screenwidth = (int) window_size.ws_col;
      _rl_screenheight = (int) window_size.ws_row;
d184 1
a184 1
  _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
d189 1
a189 1
  if (_rl_screenwidth <= 0)
d191 2
a192 2
      if (ignore_env == 0 && (ss = sh_get_env_value ("COLUMNS")))
	_rl_screenwidth = atoi (ss);
d194 6
a199 3
#if !defined (__DJGPP__)
      if (_rl_screenwidth <= 0 && term_string_buffer)
	_rl_screenwidth = tgetnum ("co");
d205 1
a205 1
  if (_rl_screenheight <= 0)
d207 2
a208 2
      if (ignore_env == 0 && (ss = sh_get_env_value ("LINES")))
	_rl_screenheight = atoi (ss);
d210 6
a215 3
#if !defined (__DJGPP__)
      if (_rl_screenheight <= 0 && term_string_buffer)
	_rl_screenheight = tgetnum ("li");
d220 2
a221 2
  if (_rl_screenwidth <= 1)
    _rl_screenwidth = 80;
d223 2
a224 2
  if (_rl_screenheight <= 0)
    _rl_screenheight = 24;
d229 1
a229 1
  sh_set_lines_and_columns (_rl_screenheight, _rl_screenwidth);
d232 1
a232 1
    _rl_screenwidth--;
d234 1
a234 1
  _rl_screenchars = _rl_screenwidth * _rl_screenheight;
d241 2
a242 5
  if (rows == 0 || cols == 0)
    return;

  _rl_screenheight = rows;
  _rl_screenwidth = cols;
d245 1
a245 1
    _rl_screenwidth--;
d247 1
a247 8
  _rl_screenchars = _rl_screenwidth * _rl_screenheight;
}

void
rl_set_screen_size (rows, cols)
     int rows, cols;
{
  _rl_set_screen_size (rows, cols);
a250 10
rl_get_screen_size (rows, cols)
     int *rows, *cols;
{
  if (rows)
    *rows = _rl_screenheight;
  if (cols)
    *cols = _rl_screenwidth;
}
     
void
d256 1
a256 4
      if (CUSTOM_REDISPLAY_FUNC ())
	rl_forced_update_display ();
      else
	_rl_redisplay_after_sigwinch ();
d261 1
a261 1
     const char *tc_var;
d269 20
a288 22
  { "@@7", &_rl_term_at7 },
  { "DC", &_rl_term_DC },
  { "IC", &_rl_term_IC },
  { "ce", &_rl_term_clreol },
  { "cl", &_rl_term_clrpag },
  { "cr", &_rl_term_cr },
  { "dc", &_rl_term_dc },
  { "ei", &_rl_term_ei },
  { "ic", &_rl_term_ic },
  { "im", &_rl_term_im },
  { "kH", &_rl_term_kH },	/* home down ?? */
  { "kI", &_rl_term_kI },	/* insert */
  { "kd", &_rl_term_kd },
  { "ke", &_rl_term_ke },	/* end keypad mode */
  { "kh", &_rl_term_kh },	/* home */
  { "kl", &_rl_term_kl },
  { "kr", &_rl_term_kr },
  { "ks", &_rl_term_ks },	/* start keypad mode */
  { "ku", &_rl_term_ku },
  { "le", &_rl_term_backspace },
  { "mm", &_rl_term_mm },
  { "mo", &_rl_term_mo },
d290 1
a290 1
  { "nd", &_rl_term_forward_char },
d292 3
a294 5
  { "pc", &_rl_term_pc },
  { "up", &_rl_term_up },
  { "vb", &_rl_visible_bell },
  { "vs", &_rl_term_vs },
  { "ve", &_rl_term_ve },
a308 3
#  ifdef __LCC__
    *(tc_strings[i].tc_value) = tgetstr ((char *)tc_strings[i].tc_var, bp);
#  else
a309 1
#  endif
d314 3
d319 1
a319 1
     const char *terminal_name;
d321 1
a321 2
  const char *term;
  char *buffer;
d323 1
d325 2
a326 2
  term = terminal_name ? terminal_name : sh_get_env_value ("TERM");
  _rl_term_clrpag = _rl_term_cr = _rl_term_clreol = (char *)NULL;
d328 1
a328 1
  _rl_screenwidth = _rl_screenheight = 0;
d353 1
a353 1
	term_string_buffer = (char *)xmalloc(2032);
d356 1
a356 1
	term_buffer = (char *)xmalloc(4080);
d369 1
d373 2
a374 2
      _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
      _rl_screenwidth--;
d380 1
a380 1
      if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
d382 2
a383 2
	  _rl_screenwidth = 79;
	  _rl_screenheight = 24;
d387 6
a392 9
      _rl_screenchars = _rl_screenwidth * _rl_screenheight;
      _rl_term_cr = "\r";
      _rl_term_im = _rl_term_ei = _rl_term_ic = _rl_term_IC = (char *)NULL;
      _rl_term_up = _rl_term_dc = _rl_term_DC = _rl_visible_bell = (char *)NULL;
      _rl_term_ku = _rl_term_kd = _rl_term_kl = _rl_term_kr = (char *)NULL;
      _rl_term_kh = _rl_term_kH = _rl_term_kI = (char *)NULL;
      _rl_term_ks = _rl_term_ke = _rl_term_at7 = (char *)NULL;
      _rl_term_mm = _rl_term_mo = (char *)NULL;
      _rl_term_ve = _rl_term_vs = (char *)NULL;
d396 1
a396 1
      _rl_terminal_can_insert = term_has_meta = 0;
d399 1
a399 1
         tgoto if _rl_term_IC or _rl_term_DC is defined, but just in case we
d402 2
a403 2
      BC = _rl_term_backspace = "\b";
      UP = _rl_term_up;
d412 3
a414 3
  PC = _rl_term_pc ? *_rl_term_pc : 0;
  BC = _rl_term_backspace;
  UP = _rl_term_up;
d416 2
a417 2
  if (!_rl_term_cr)
    _rl_term_cr = "\r";
d427 1
a427 1
  _rl_terminal_can_insert = (_rl_term_IC || _rl_term_im || _rl_term_ic);
d433 1
a433 1
    _rl_term_mm = _rl_term_mo = (char *)NULL;
d439 7
d447 2
a448 1
  bind_termcap_arrow_keys (emacs_standard_keymap);
d451 8
a458 2
  bind_termcap_arrow_keys (vi_movement_keymap);
  bind_termcap_arrow_keys (vi_insertion_keymap);
d461 2
a465 21
/* Bind the arrow key sequences from the termcap description in MAP. */
static void
bind_termcap_arrow_keys (map)
     Keymap map;
{
  Keymap xkeymap;

  xkeymap = _rl_keymap;
  _rl_keymap = map;

  _rl_bind_if_unbound (_rl_term_ku, rl_get_previous_history);
  _rl_bind_if_unbound (_rl_term_kd, rl_get_next_history);
  _rl_bind_if_unbound (_rl_term_kr, rl_forward);
  _rl_bind_if_unbound (_rl_term_kl, rl_backward);

  _rl_bind_if_unbound (_rl_term_kh, rl_beg_of_line);	/* Home */
  _rl_bind_if_unbound (_rl_term_at7, rl_end_of_line);	/* End */

  _rl_keymap = xkeymap;
}

d468 1
a468 1
     const char *cap;
d486 1
a486 1
     const char *terminal_name;
d512 1
a512 1
     const char *string;
d526 1
a526 1
  if (_rl_term_backspace)
d528 1
a528 1
      tputs (_rl_term_backspace, 1, _rl_output_character_function);
d538 1
a538 1
rl_crlf ()
d541 2
a542 2
  if (_rl_term_cr)
    tputs (_rl_term_cr, 1, _rl_output_character_function);
d550 1
a550 1
rl_ding ()
d564 1
a564 1
	  if (_rl_visible_bell)
d566 1
a566 1
	      tputs (_rl_visible_bell, 1, _rl_output_character_function);
d591 2
a592 2
  if (term_has_meta && _rl_term_mm)
    tputs (_rl_term_mm, 1, _rl_output_character_function);
d601 4
a604 4
  if (on && _rl_term_ks)
    tputs (_rl_term_ks, 1, _rl_output_character_function);
  else if (!on && _rl_term_ke)
    tputs (_rl_term_ke, 1, _rl_output_character_function);
a605 26
}

/* **************************************************************** */
/*								    */
/*	 		Controlling the Cursor			    */
/*								    */
/* **************************************************************** */

/* Set the cursor appropriately depending on IM, which is one of the
   insert modes (insert or overwrite).  Insert mode gets the normal
   cursor.  Overwrite mode gets a very visible cursor.  Only does
   anything if we have both capabilities. */
void
_rl_set_cursor (im, force)
     int im, force;
{
  if (_rl_term_ve && _rl_term_vs)
    {
      if (force || im != rl_insert_mode)
	{
	  if (im == RL_IM_OVERWRITE)
	    tputs (_rl_term_vs, 1, _rl_output_character_function);
	  else
	    tputs (_rl_term_ve, 1, _rl_output_character_function);
	}
    }
@


1.5.24.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d223 1
a223 4
#if defined (__DJGPP__)
      if (_rl_screenwidth <= 0)
	_rl_screenwidth = ScreenCols ();
#else
d236 1
a236 4
#if defined (__DJGPP__)
      if (_rl_screenheight <= 0)
	_rl_screenheight = ScreenRows ();
#else
d385 6
a390 13
  _rl_term_im = _rl_term_ei = _rl_term_ic = _rl_term_IC = (char *)NULL;
  _rl_term_up = _rl_term_dc = _rl_term_DC = _rl_visible_bell = (char *)NULL;
  _rl_term_ku = _rl_term_kd = _rl_term_kl = _rl_term_kr = (char *)NULL;
  _rl_term_mm = _rl_term_mo = (char *)NULL;
  _rl_terminal_can_insert = term_has_meta = _rl_term_autowrap = 0;
  _rl_term_cr = "\r";
  _rl_term_clreol = _rl_term_clrpag = _rl_term_backspace = (char *)NULL;
  _rl_term_goto = _rl_term_pc = _rl_term_ip = (char *)NULL;
  _rl_term_ks = _rl_term_ke =_rl_term_vs = _rl_term_ve = (char *)NULL;
  _rl_term_kh = _rl_term_kH = _rl_term_at7 = _rl_term_kI = (char *)NULL;
#if defined(HACK_TERMCAP_MOTION)
  _rl_term_forward_char = (char *)NULL;
#endif
a679 1
#ifndef __MSDOS__
a689 1
#endif
@


1.5.22.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a70 4
#include "xmalloc.h"

#define CUSTOM_REDISPLAY_FUNC() (rl_redisplay_function != rl_redisplay)
#define CUSTOM_INPUT_FUNC() (rl_getc_function != rl_getc)
d96 2
a97 6
char *_rl_term_clreol;
char *_rl_term_clrpag;
char *_rl_term_cr;
char *_rl_term_backspace;
char *_rl_term_goto;
char *_rl_term_pc;
d100 1
a100 1
int _rl_terminal_can_insert = 0;
d103 1
a103 5
char *_rl_term_im;
char *_rl_term_ei;
char *_rl_term_ic;
char *_rl_term_ip;
char *_rl_term_IC;
d106 1
a106 2
char *_rl_term_dc;
char *_rl_term_DC;
d109 1
a109 1
char *_rl_term_forward_char;
d113 1
a113 1
char *_rl_term_up;
d115 2
a116 2
/* A visible bell; char if the terminal can be made to flash the screen. */
static char *_rl_visible_bell;
d125 2
a126 3
   terminal has one. */
static char *_rl_term_mm;
static char *_rl_term_mo;
d129 1
a129 4
static char *_rl_term_ku;
static char *_rl_term_kd;
static char *_rl_term_kr;
static char *_rl_term_kl;
d132 1
a132 2
static char *_rl_term_ks;
static char *_rl_term_ke;
d135 1
a135 12
static char *_rl_term_kh;
static char *_rl_term_kH;
static char *_rl_term_at7;	/* @@7 */

/* Insert key */
static char *_rl_term_kI;

/* Cursor control */
static char *_rl_term_vs;	/* very visible */
static char *_rl_term_ve;	/* normal */

static void bind_termcap_arrow_keys PARAMS((Keymap));
d138 1
a138 1
int _rl_screenwidth, _rl_screenheight, _rl_screenchars;
d178 2
a179 2
      _rl_screenwidth = (int) window_size.ws_col;
      _rl_screenheight = (int) window_size.ws_row;
d184 1
a184 1
  _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
d189 1
a189 1
  if (_rl_screenwidth <= 0)
d191 2
a192 2
      if (ignore_env == 0 && (ss = sh_get_env_value ("COLUMNS")))
	_rl_screenwidth = atoi (ss);
d194 6
a199 3
#if !defined (__DJGPP__)
      if (_rl_screenwidth <= 0 && term_string_buffer)
	_rl_screenwidth = tgetnum ("co");
d205 1
a205 1
  if (_rl_screenheight <= 0)
d207 2
a208 2
      if (ignore_env == 0 && (ss = sh_get_env_value ("LINES")))
	_rl_screenheight = atoi (ss);
d210 6
a215 3
#if !defined (__DJGPP__)
      if (_rl_screenheight <= 0 && term_string_buffer)
	_rl_screenheight = tgetnum ("li");
d220 2
a221 2
  if (_rl_screenwidth <= 1)
    _rl_screenwidth = 80;
d223 2
a224 2
  if (_rl_screenheight <= 0)
    _rl_screenheight = 24;
d229 1
a229 1
  sh_set_lines_and_columns (_rl_screenheight, _rl_screenwidth);
d232 1
a232 1
    _rl_screenwidth--;
d234 1
a234 1
  _rl_screenchars = _rl_screenwidth * _rl_screenheight;
d241 2
a242 5
  if (rows == 0 || cols == 0)
    return;

  _rl_screenheight = rows;
  _rl_screenwidth = cols;
d245 1
a245 1
    _rl_screenwidth--;
d247 1
a247 8
  _rl_screenchars = _rl_screenwidth * _rl_screenheight;
}

void
rl_set_screen_size (rows, cols)
     int rows, cols;
{
  _rl_set_screen_size (rows, cols);
a250 10
rl_get_screen_size (rows, cols)
     int *rows, *cols;
{
  if (rows)
    *rows = _rl_screenheight;
  if (cols)
    *cols = _rl_screenwidth;
}
     
void
d256 1
a256 4
      if (CUSTOM_REDISPLAY_FUNC ())
	rl_forced_update_display ();
      else
	_rl_redisplay_after_sigwinch ();
d261 1
a261 1
     const char *tc_var;
d269 20
a288 22
  { "@@7", &_rl_term_at7 },
  { "DC", &_rl_term_DC },
  { "IC", &_rl_term_IC },
  { "ce", &_rl_term_clreol },
  { "cl", &_rl_term_clrpag },
  { "cr", &_rl_term_cr },
  { "dc", &_rl_term_dc },
  { "ei", &_rl_term_ei },
  { "ic", &_rl_term_ic },
  { "im", &_rl_term_im },
  { "kH", &_rl_term_kH },	/* home down ?? */
  { "kI", &_rl_term_kI },	/* insert */
  { "kd", &_rl_term_kd },
  { "ke", &_rl_term_ke },	/* end keypad mode */
  { "kh", &_rl_term_kh },	/* home */
  { "kl", &_rl_term_kl },
  { "kr", &_rl_term_kr },
  { "ks", &_rl_term_ks },	/* start keypad mode */
  { "ku", &_rl_term_ku },
  { "le", &_rl_term_backspace },
  { "mm", &_rl_term_mm },
  { "mo", &_rl_term_mo },
d290 1
a290 1
  { "nd", &_rl_term_forward_char },
d292 3
a294 5
  { "pc", &_rl_term_pc },
  { "up", &_rl_term_up },
  { "vb", &_rl_visible_bell },
  { "vs", &_rl_term_vs },
  { "ve", &_rl_term_ve },
a308 3
#  ifdef __LCC__
    *(tc_strings[i].tc_value) = tgetstr ((char *)tc_strings[i].tc_var, bp);
#  else
a309 1
#  endif
d314 3
d319 1
a319 1
     const char *terminal_name;
d321 1
a321 2
  const char *term;
  char *buffer;
d323 1
d325 2
a326 2
  term = terminal_name ? terminal_name : sh_get_env_value ("TERM");
  _rl_term_clrpag = _rl_term_cr = _rl_term_clreol = (char *)NULL;
d328 1
a328 1
  _rl_screenwidth = _rl_screenheight = 0;
d353 1
a353 1
	term_string_buffer = (char *)xmalloc(2032);
d356 1
a356 1
	term_buffer = (char *)xmalloc(4080);
d369 1
d373 2
a374 2
      _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
      _rl_screenwidth--;
d380 1
a380 1
      if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
d382 2
a383 2
	  _rl_screenwidth = 79;
	  _rl_screenheight = 24;
d387 6
a392 9
      _rl_screenchars = _rl_screenwidth * _rl_screenheight;
      _rl_term_cr = "\r";
      _rl_term_im = _rl_term_ei = _rl_term_ic = _rl_term_IC = (char *)NULL;
      _rl_term_up = _rl_term_dc = _rl_term_DC = _rl_visible_bell = (char *)NULL;
      _rl_term_ku = _rl_term_kd = _rl_term_kl = _rl_term_kr = (char *)NULL;
      _rl_term_kh = _rl_term_kH = _rl_term_kI = (char *)NULL;
      _rl_term_ks = _rl_term_ke = _rl_term_at7 = (char *)NULL;
      _rl_term_mm = _rl_term_mo = (char *)NULL;
      _rl_term_ve = _rl_term_vs = (char *)NULL;
d396 1
a396 1
      _rl_terminal_can_insert = term_has_meta = 0;
d399 1
a399 1
         tgoto if _rl_term_IC or _rl_term_DC is defined, but just in case we
d402 2
a403 2
      BC = _rl_term_backspace = "\b";
      UP = _rl_term_up;
d412 3
a414 3
  PC = _rl_term_pc ? *_rl_term_pc : 0;
  BC = _rl_term_backspace;
  UP = _rl_term_up;
d416 2
a417 2
  if (!_rl_term_cr)
    _rl_term_cr = "\r";
d427 1
a427 1
  _rl_terminal_can_insert = (_rl_term_IC || _rl_term_im || _rl_term_ic);
d433 1
a433 1
    _rl_term_mm = _rl_term_mo = (char *)NULL;
d439 7
d447 2
a448 1
  bind_termcap_arrow_keys (emacs_standard_keymap);
d451 8
a458 2
  bind_termcap_arrow_keys (vi_movement_keymap);
  bind_termcap_arrow_keys (vi_insertion_keymap);
d461 2
a465 21
/* Bind the arrow key sequences from the termcap description in MAP. */
static void
bind_termcap_arrow_keys (map)
     Keymap map;
{
  Keymap xkeymap;

  xkeymap = _rl_keymap;
  _rl_keymap = map;

  _rl_bind_if_unbound (_rl_term_ku, rl_get_previous_history);
  _rl_bind_if_unbound (_rl_term_kd, rl_get_next_history);
  _rl_bind_if_unbound (_rl_term_kr, rl_forward);
  _rl_bind_if_unbound (_rl_term_kl, rl_backward);

  _rl_bind_if_unbound (_rl_term_kh, rl_beg_of_line);	/* Home */
  _rl_bind_if_unbound (_rl_term_at7, rl_end_of_line);	/* End */

  _rl_keymap = xkeymap;
}

d468 1
a468 1
     const char *cap;
d486 1
a486 1
     const char *terminal_name;
d512 1
a512 1
     const char *string;
d526 1
a526 1
  if (_rl_term_backspace)
d528 1
a528 1
      tputs (_rl_term_backspace, 1, _rl_output_character_function);
d538 1
a538 1
rl_crlf ()
d541 2
a542 2
  if (_rl_term_cr)
    tputs (_rl_term_cr, 1, _rl_output_character_function);
d550 1
a550 1
rl_ding ()
d564 1
a564 1
	  if (_rl_visible_bell)
d566 1
a566 1
	      tputs (_rl_visible_bell, 1, _rl_output_character_function);
d591 2
a592 2
  if (term_has_meta && _rl_term_mm)
    tputs (_rl_term_mm, 1, _rl_output_character_function);
d601 4
a604 4
  if (on && _rl_term_ks)
    tputs (_rl_term_ks, 1, _rl_output_character_function);
  else if (!on && _rl_term_ke)
    tputs (_rl_term_ke, 1, _rl_output_character_function);
a605 26
}

/* **************************************************************** */
/*								    */
/*	 		Controlling the Cursor			    */
/*								    */
/* **************************************************************** */

/* Set the cursor appropriately depending on IM, which is one of the
   insert modes (insert or overwrite).  Insert mode gets the normal
   cursor.  Overwrite mode gets a very visible cursor.  Only does
   anything if we have both capabilities. */
void
_rl_set_cursor (im, force)
     int im, force;
{
  if (_rl_term_ve && _rl_term_vs)
    {
      if (force || im != rl_insert_mode)
	{
	  if (im == RL_IM_OVERWRITE)
	    tputs (_rl_term_vs, 1, _rl_output_character_function);
	  else
	    tputs (_rl_term_ve, 1, _rl_output_character_function);
	}
    }
@


1.5.22.2
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d223 1
a223 4
#if defined (__DJGPP__)
      if (_rl_screenwidth <= 0)
	_rl_screenwidth = ScreenCols ();
#else
d236 1
a236 4
#if defined (__DJGPP__)
      if (_rl_screenheight <= 0)
	_rl_screenheight = ScreenRows ();
#else
d385 6
a390 13
  _rl_term_im = _rl_term_ei = _rl_term_ic = _rl_term_IC = (char *)NULL;
  _rl_term_up = _rl_term_dc = _rl_term_DC = _rl_visible_bell = (char *)NULL;
  _rl_term_ku = _rl_term_kd = _rl_term_kl = _rl_term_kr = (char *)NULL;
  _rl_term_mm = _rl_term_mo = (char *)NULL;
  _rl_terminal_can_insert = term_has_meta = _rl_term_autowrap = 0;
  _rl_term_cr = "\r";
  _rl_term_clreol = _rl_term_clrpag = _rl_term_backspace = (char *)NULL;
  _rl_term_goto = _rl_term_pc = _rl_term_ip = (char *)NULL;
  _rl_term_ks = _rl_term_ke =_rl_term_vs = _rl_term_ve = (char *)NULL;
  _rl_term_kh = _rl_term_kH = _rl_term_at7 = _rl_term_kI = (char *)NULL;
#if defined(HACK_TERMCAP_MOTION)
  _rl_term_forward_char = (char *)NULL;
#endif
a679 1
#ifndef __MSDOS__
a689 1
#endif
@


1.5.16.1
log
@2002-08-24  Elena Zannoni  <ezannoni@@redhat.com>

        Import of readline 4.3:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@a70 4
#include "xmalloc.h"

#define CUSTOM_REDISPLAY_FUNC() (rl_redisplay_function != rl_redisplay)
#define CUSTOM_INPUT_FUNC() (rl_getc_function != rl_getc)
d96 2
a97 6
char *_rl_term_clreol;
char *_rl_term_clrpag;
char *_rl_term_cr;
char *_rl_term_backspace;
char *_rl_term_goto;
char *_rl_term_pc;
d100 1
a100 1
int _rl_terminal_can_insert = 0;
d103 1
a103 5
char *_rl_term_im;
char *_rl_term_ei;
char *_rl_term_ic;
char *_rl_term_ip;
char *_rl_term_IC;
d106 1
a106 2
char *_rl_term_dc;
char *_rl_term_DC;
d109 1
a109 1
char *_rl_term_forward_char;
d113 1
a113 1
char *_rl_term_up;
d115 2
a116 2
/* A visible bell; char if the terminal can be made to flash the screen. */
static char *_rl_visible_bell;
d125 2
a126 3
   terminal has one. */
static char *_rl_term_mm;
static char *_rl_term_mo;
d129 1
a129 4
static char *_rl_term_ku;
static char *_rl_term_kd;
static char *_rl_term_kr;
static char *_rl_term_kl;
d132 1
a132 2
static char *_rl_term_ks;
static char *_rl_term_ke;
d135 1
a135 12
static char *_rl_term_kh;
static char *_rl_term_kH;
static char *_rl_term_at7;	/* @@7 */

/* Insert key */
static char *_rl_term_kI;

/* Cursor control */
static char *_rl_term_vs;	/* very visible */
static char *_rl_term_ve;	/* normal */

static void bind_termcap_arrow_keys PARAMS((Keymap));
d138 1
a138 1
int _rl_screenwidth, _rl_screenheight, _rl_screenchars;
d178 2
a179 2
      _rl_screenwidth = (int) window_size.ws_col;
      _rl_screenheight = (int) window_size.ws_row;
d184 1
a184 1
  _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
d189 1
a189 1
  if (_rl_screenwidth <= 0)
d191 2
a192 2
      if (ignore_env == 0 && (ss = sh_get_env_value ("COLUMNS")))
	_rl_screenwidth = atoi (ss);
d194 6
a199 3
#if !defined (__DJGPP__)
      if (_rl_screenwidth <= 0 && term_string_buffer)
	_rl_screenwidth = tgetnum ("co");
d205 1
a205 1
  if (_rl_screenheight <= 0)
d207 2
a208 2
      if (ignore_env == 0 && (ss = sh_get_env_value ("LINES")))
	_rl_screenheight = atoi (ss);
d210 6
a215 3
#if !defined (__DJGPP__)
      if (_rl_screenheight <= 0 && term_string_buffer)
	_rl_screenheight = tgetnum ("li");
d220 2
a221 2
  if (_rl_screenwidth <= 1)
    _rl_screenwidth = 80;
d223 2
a224 2
  if (_rl_screenheight <= 0)
    _rl_screenheight = 24;
d229 1
a229 1
  sh_set_lines_and_columns (_rl_screenheight, _rl_screenwidth);
d232 1
a232 1
    _rl_screenwidth--;
d234 1
a234 1
  _rl_screenchars = _rl_screenwidth * _rl_screenheight;
d241 2
a242 5
  if (rows == 0 || cols == 0)
    return;

  _rl_screenheight = rows;
  _rl_screenwidth = cols;
d245 1
a245 1
    _rl_screenwidth--;
d247 1
a247 8
  _rl_screenchars = _rl_screenwidth * _rl_screenheight;
}

void
rl_set_screen_size (rows, cols)
     int rows, cols;
{
  _rl_set_screen_size (rows, cols);
a250 10
rl_get_screen_size (rows, cols)
     int *rows, *cols;
{
  if (rows)
    *rows = _rl_screenheight;
  if (cols)
    *cols = _rl_screenwidth;
}
     
void
d256 1
a256 4
      if (CUSTOM_REDISPLAY_FUNC ())
	rl_forced_update_display ();
      else
	_rl_redisplay_after_sigwinch ();
d261 1
a261 1
     const char *tc_var;
d269 20
a288 22
  { "@@7", &_rl_term_at7 },
  { "DC", &_rl_term_DC },
  { "IC", &_rl_term_IC },
  { "ce", &_rl_term_clreol },
  { "cl", &_rl_term_clrpag },
  { "cr", &_rl_term_cr },
  { "dc", &_rl_term_dc },
  { "ei", &_rl_term_ei },
  { "ic", &_rl_term_ic },
  { "im", &_rl_term_im },
  { "kH", &_rl_term_kH },	/* home down ?? */
  { "kI", &_rl_term_kI },	/* insert */
  { "kd", &_rl_term_kd },
  { "ke", &_rl_term_ke },	/* end keypad mode */
  { "kh", &_rl_term_kh },	/* home */
  { "kl", &_rl_term_kl },
  { "kr", &_rl_term_kr },
  { "ks", &_rl_term_ks },	/* start keypad mode */
  { "ku", &_rl_term_ku },
  { "le", &_rl_term_backspace },
  { "mm", &_rl_term_mm },
  { "mo", &_rl_term_mo },
d290 1
a290 1
  { "nd", &_rl_term_forward_char },
d292 3
a294 5
  { "pc", &_rl_term_pc },
  { "up", &_rl_term_up },
  { "vb", &_rl_visible_bell },
  { "vs", &_rl_term_vs },
  { "ve", &_rl_term_ve },
a308 3
#  ifdef __LCC__
    *(tc_strings[i].tc_value) = tgetstr ((char *)tc_strings[i].tc_var, bp);
#  else
a309 1
#  endif
d314 3
d319 1
a319 1
     const char *terminal_name;
d321 1
a321 2
  const char *term;
  char *buffer;
d323 1
d325 2
a326 2
  term = terminal_name ? terminal_name : sh_get_env_value ("TERM");
  _rl_term_clrpag = _rl_term_cr = _rl_term_clreol = (char *)NULL;
d328 1
a328 1
  _rl_screenwidth = _rl_screenheight = 0;
d353 1
a353 1
	term_string_buffer = (char *)xmalloc(2032);
d356 1
a356 1
	term_buffer = (char *)xmalloc(4080);
d369 1
d373 2
a374 2
      _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
      _rl_screenwidth--;
d380 1
a380 1
      if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
d382 2
a383 2
	  _rl_screenwidth = 79;
	  _rl_screenheight = 24;
d387 6
a392 9
      _rl_screenchars = _rl_screenwidth * _rl_screenheight;
      _rl_term_cr = "\r";
      _rl_term_im = _rl_term_ei = _rl_term_ic = _rl_term_IC = (char *)NULL;
      _rl_term_up = _rl_term_dc = _rl_term_DC = _rl_visible_bell = (char *)NULL;
      _rl_term_ku = _rl_term_kd = _rl_term_kl = _rl_term_kr = (char *)NULL;
      _rl_term_kh = _rl_term_kH = _rl_term_kI = (char *)NULL;
      _rl_term_ks = _rl_term_ke = _rl_term_at7 = (char *)NULL;
      _rl_term_mm = _rl_term_mo = (char *)NULL;
      _rl_term_ve = _rl_term_vs = (char *)NULL;
d396 1
a396 1
      _rl_terminal_can_insert = term_has_meta = 0;
d399 1
a399 1
         tgoto if _rl_term_IC or _rl_term_DC is defined, but just in case we
d402 2
a403 2
      BC = _rl_term_backspace = "\b";
      UP = _rl_term_up;
d412 3
a414 3
  PC = _rl_term_pc ? *_rl_term_pc : 0;
  BC = _rl_term_backspace;
  UP = _rl_term_up;
d416 2
a417 2
  if (!_rl_term_cr)
    _rl_term_cr = "\r";
d427 1
a427 1
  _rl_terminal_can_insert = (_rl_term_IC || _rl_term_im || _rl_term_ic);
d433 1
a433 1
    _rl_term_mm = _rl_term_mo = (char *)NULL;
d439 7
d447 2
a448 1
  bind_termcap_arrow_keys (emacs_standard_keymap);
d451 8
a458 2
  bind_termcap_arrow_keys (vi_movement_keymap);
  bind_termcap_arrow_keys (vi_insertion_keymap);
d461 2
a465 21
/* Bind the arrow key sequences from the termcap description in MAP. */
static void
bind_termcap_arrow_keys (map)
     Keymap map;
{
  Keymap xkeymap;

  xkeymap = _rl_keymap;
  _rl_keymap = map;

  _rl_bind_if_unbound (_rl_term_ku, rl_get_previous_history);
  _rl_bind_if_unbound (_rl_term_kd, rl_get_next_history);
  _rl_bind_if_unbound (_rl_term_kr, rl_forward);
  _rl_bind_if_unbound (_rl_term_kl, rl_backward);

  _rl_bind_if_unbound (_rl_term_kh, rl_beg_of_line);	/* Home */
  _rl_bind_if_unbound (_rl_term_at7, rl_end_of_line);	/* End */

  _rl_keymap = xkeymap;
}

d468 1
a468 1
     const char *cap;
d486 1
a486 1
     const char *terminal_name;
d512 1
a512 1
     const char *string;
d526 1
a526 1
  if (_rl_term_backspace)
d528 1
a528 1
      tputs (_rl_term_backspace, 1, _rl_output_character_function);
d538 1
a538 1
rl_crlf ()
d541 2
a542 2
  if (_rl_term_cr)
    tputs (_rl_term_cr, 1, _rl_output_character_function);
d550 1
a550 1
rl_ding ()
d564 1
a564 1
	  if (_rl_visible_bell)
d566 1
a566 1
	      tputs (_rl_visible_bell, 1, _rl_output_character_function);
d591 2
a592 2
  if (term_has_meta && _rl_term_mm)
    tputs (_rl_term_mm, 1, _rl_output_character_function);
d601 4
a604 4
  if (on && _rl_term_ks)
    tputs (_rl_term_ks, 1, _rl_output_character_function);
  else if (!on && _rl_term_ke)
    tputs (_rl_term_ke, 1, _rl_output_character_function);
a605 26
}

/* **************************************************************** */
/*								    */
/*	 		Controlling the Cursor			    */
/*								    */
/* **************************************************************** */

/* Set the cursor appropriately depending on IM, which is one of the
   insert modes (insert or overwrite).  Insert mode gets the normal
   cursor.  Overwrite mode gets a very visible cursor.  Only does
   anything if we have both capabilities. */
void
_rl_set_cursor (im, force)
     int im, force;
{
  if (_rl_term_ve && _rl_term_vs)
    {
      if (force || im != rl_insert_mode)
	{
	  if (im == RL_IM_OVERWRITE)
	    tputs (_rl_term_vs, 1, _rl_output_character_function);
	  else
	    tputs (_rl_term_ve, 1, _rl_output_character_function);
	}
    }
@


1.4
log
@readline:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Locally modified files: Makefile.in, configure.in, configure
        (regenerated), config.h.in (regenerated), readline.h, rltty.c,
 	shell.c signals.c.

        Locally added files: acconfig.h, config/*, config.h.bot,
        cross-build/*, doc/inc-hit.texinfo.

        New files: USAGE, rlprivate.h, rlshell.h, xmalloc.h.
examples:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        New files: excallback.c, rlfe.c.
doc:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Regenerated inc-hist.texinfo as copy of hsuser.texinfo, for
        inclusion in the gdb manual.

        New file: rluserman.texinfo
@
text
@d58 4
d78 1
a81 2
static int tcap_initialized;

d84 3
d194 4
a197 1
#if !defined (__DJGPP__)
d210 4
a213 1
#if !defined (__DJGPP__)
d333 10
d435 2
d525 1
d530 1
d560 4
d569 1
@


1.3
log
@Dummy commit before importof 4.1 version
@
text
@d10 1
a10 1
   as published by the Free Software Foundation; either version 1, or
d21 1
a21 1
   675 Mass Ave, Cambridge, MA 02139, USA. */
a48 1
#include <signal.h>
a49 1
#include <setjmp.h>
a57 4
#if defined (__GO32__)
#  include <pc.h>
#endif

d65 2
a66 15
/* Variables and functions imported from readline.c */
extern FILE *_rl_in_stream, *_rl_out_stream;
extern int readline_echoing_p;
extern int _rl_bell_preference;
extern Keymap _rl_keymap;

/* Functions imported from bind.c */
extern void _rl_bind_if_unbound ();

/* Functions imported from shell.c */
extern void set_lines_and_columns ();
extern char *get_env_value ();

/* Functions imported from display.c */
extern void _rl_redisplay_after_sigwinch ();
a73 1
#ifndef __DJGPP__
d77 2
a80 3
#endif

static int tcap_initialized;
d140 16
a167 3
#if defined (__EMX__)
  int sz[2];
#endif
d178 1
a178 3
  _scrsize (sz);
  screenwidth = sz[0];
  screenheight = sz[1];
d188 1
a188 5
#if defined(__DJGPP__)
      tty = tty;
      if (screenwidth <= 0)
	screenwidth = ScreenCols ();
#else
d201 1
a201 4
#if defined(__DJGPP__)
      if (screenheight <= 0)
	screenheight = ScreenRows ();
#else
d219 1
a219 1
  if (!_rl_term_autowrap)
d257 20
a276 20
  "DC", &term_DC,
  "IC", &term_IC,
  "ce", &term_clreol,
  "cl", &term_clrpag,
  "cr", &term_cr,
  "dc", &term_dc,
  "ei", &term_ei,
  "ic", &term_ic,
  "im", &term_im,
  "kd", &term_kd,
  "kh", &term_kh,	/* home */
  "kH", &term_kH,	/* end */
  "kl", &term_kl,
  "kr", &term_kr,
  "ku", &term_ku,
  "ks", &term_ks,
  "ke", &term_ke,
  "le", &term_backspace,
  "mm", &term_mm,
  "mo", &term_mo,
d278 1
a278 1
  "nd", &term_forward_char,
d280 3
a282 3
  "pc", &term_pc,
  "up", &term_up,
  "vb", &visible_bell,
d293 1
a293 3
#if defined(__DJGPP__)
  bp = bp;
#else
d302 3
a308 23
#if defined (__GO32__)
  terminal_name = terminal_name;
  screenwidth = screenheight = 0;
  _rl_get_screen_size (rl_instream ? fileno (rl_instream) : 0, 0);

  term_cr = "\r";
  term_im = term_ei = term_ic = term_IC = (char *)NULL;
  term_up = term_dc = term_DC = visible_bell = (char *)NULL;

  /* Does the __GO32__ have a meta key?  I don't know. */
  term_has_meta = 0;
  term_mm = term_mo = (char *)NULL;

  /* It probably has arrow keys, but I don't know what they are. */
  term_ku = term_kd = term_kr = term_kl = (char *)NULL;

#if defined (HACK_TERMCAP_MOTION)
  term_forward_char = (char *)NULL;
#endif /* HACK_TERMCAP_MOTION */
  terminal_can_insert = _rl_term_autowrap = 0;
  return 0;
#else /* !__GO32__ */

d310 1
a310 1
  int tty;
d314 3
d318 2
a319 2
  if (term_string_buffer == 0)
    term_string_buffer = xmalloc (2032);
d321 11
a331 2
  if (term_buffer == 0)
    term_buffer = xmalloc (4080);
d333 2
a334 1
  buffer = term_string_buffer;
d336 1
a336 1
  term_clrpag = term_cr = term_clreol = (char *)NULL;
d338 2
a339 2
  if (term == 0)
    term = "dumb";
d341 1
a341 1
  if (tgetent (term_buffer, term) <= 0)
d343 4
d348 18
a365 3
      screenwidth = 79;
      screenheight = 24;
      screenchars = 79 * 24;
d370 1
d374 9
a382 1
      terminal_can_insert = 0;
a396 4
  tty = rl_instream ? fileno (rl_instream) : 0;

  screenwidth = screenheight = 0;

a438 1
#endif /* !__GO32__ */
d484 1
a500 1
#if !defined (__GO32__)
a504 1
#endif /* !__GO32__ */
a533 4
#if defined (__GO32__)
	  ScreenVisualBell ();
	  break;
#else
a538 1
#endif
d559 1
a559 1
#if !defined(__DJGPP__)
d569 1
a569 3
#if defined(__DJGPP__)
  on = on;
#else
@


1.2
log
@[__GO32__]: Include <pc.h>.
Declare _rl_redisplay_after_sigwinch.
[__DJGPP__]: Don't declare term_buffer and term_string_buffer (they are
unused.)
(_rl_get_screen_size) [__DJGPP__]: Call ScreenRows and ScreenCols.
(_rl_init_terminal_io) [__GO32__]: Don't call them here.  Instead, call
_rl_get_screen_size.  Set terminal_name.  Return 0, to be consistent with
the function's declaration.
(ding) [__GO32__]: Support visual bell by calling ScreenVisualBell.
@
text
@@


1.1
log
@Initial revision
@
text
@d60 4
d84 3
d93 1
a96 2
static int tcap_initialized;

d99 3
d198 5
d205 1
d215 4
d221 1
d255 10
d310 3
d317 1
d326 4
a329 3
  screenwidth = ScreenCols ();
  screenheight = ScreenRows ();
  screenchars = screenwidth * screenheight;
d345 1
a345 1
  return;
a531 1
#if !defined (__GO32__)
d538 4
d547 1
a553 4
#else /* __GO32__ */
      fprintf (stderr, "\007");
      fflush (stderr);
#endif /* __GO32__ */
d568 1
d571 1
d578 3
d585 1
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a188 1
#if !defined(__DJGPP__)
a190 1
#endif
a199 1
#if !defined(__DJGPP__)
a201 1
#endif
a279 1
#if !defined(__DJGPP__)
a283 1
#endif
a532 1
#if !defined(__DJGPP__)
a534 1
#endif
a540 1
#if !defined(__DJGPP__)
a544 1
#endif
@


1.1.1.3
log
@import gdb-1999-08-02 snapshot
@
text
@a238 10
void
rl_resize_terminal ()
{
  if (readline_echoing_p)
    {
      _rl_get_screen_size (fileno (rl_instream), 1);
      _rl_redisplay_after_sigwinch ();
    }
}

@


1.1.1.4
log
@Import of readline 4.0
@
text
@d189 1
d192 1
d202 1
d205 1
d294 1
d299 1
d549 1
d552 1
d559 1
d564 1
@


1.1.1.5
log
@Import of readline 4.1
@
text
@d10 1
a10 1
   as published by the Free Software Foundation; either version 2, or
d21 1
a21 1
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
d49 1
d51 1
d67 12
a78 2
#include "rlprivate.h"
#include "rlshell.h"
a151 16
#if defined (__EMX__)
static void
_emx_get_screensize (swp, shp)
     int *swp, *shp;
{
  int sz[2];

  _scrsize (sz);

  if (swp)
    *swp = sz[0];
  if (shp)
    *shp = sz[1];
}
#endif

d164 3
d177 3
a179 1
  _emx_get_screensize (&screenwidth, &screenheight);
a188 1
#if !defined (__DJGPP__)
a190 1
#endif
a199 1
#if !defined (__DJGPP__)
a201 1
#endif
d216 1
a216 1
  if (_rl_term_autowrap == 0)
d254 20
a273 20
  { "DC", &term_DC },
  { "IC", &term_IC },
  { "ce", &term_clreol },
  { "cl", &term_clrpag },
  { "cr", &term_cr },
  { "dc", &term_dc },
  { "ei", &term_ei },
  { "ic", &term_ic },
  { "im", &term_im },
  { "kd", &term_kd },
  { "kh", &term_kh },	/* home */
  { "kH", &term_kH },	/* end */
  { "kl", &term_kl },
  { "kr", &term_kr },
  { "ku", &term_ku },
  { "ks", &term_ks },
  { "ke", &term_ke },
  { "le", &term_backspace },
  { "mm", &term_mm },
  { "mo", &term_mo },
d275 1
a275 1
  { "nd", &term_forward_char },
d277 3
a279 3
  { "pc", &term_pc },
  { "up", &term_up },
  { "vb", &visible_bell },
a289 1
#if !defined (__DJGPP__)	/* XXX - doesn't DJGPP have a termcap library? */
a293 1
#endif
a296 3
#define CUSTOM_REDISPLAY_FUNC() (rl_redisplay_function != rl_redisplay)
#define CUSTOM_INPUT_FUNC() (rl_getc_function != rl_getc)

d301 22
d324 1
a324 1
  int tty, tgetent_ret;
a327 3
  term_clrpag = term_cr = term_clreol = (char *)NULL;
  tty = rl_instream ? fileno (rl_instream) : 0;
  screenwidth = screenheight = 0;
d329 2
a330 2
  if (term == 0)
    term = "dumb";
d332 2
a333 11
  /* I've separated this out for later work on not calling tgetent at all
     if the calling application has supplied a custom redisplay function,
     (and possibly if the application has supplied a custom input function). */
  if (CUSTOM_REDISPLAY_FUNC())
    {
      tgetent_ret = -1;
    }
  else
    {
      if (term_string_buffer == 0)
	term_string_buffer = xmalloc(2032);
d335 1
a335 2
      if (term_buffer == 0)
	term_buffer = xmalloc(4080);
d337 1
a337 1
      buffer = term_string_buffer;
d339 2
a340 2
      tgetent_ret = tgetent (term_buffer, term);
    }
d342 1
a342 1
  if (tgetent_ret <= 0)
a343 4
      FREE (term_string_buffer);
      FREE (term_buffer);
      buffer = term_buffer = term_string_buffer = (char *)NULL;

d345 3
a347 18
      _rl_term_autowrap = 0;	/* used by _rl_get_screen_size */

#if defined (__EMX__)
      _emx_get_screensize (&screenwidth, &screenheight);
      screenwidth--;
#else /* !__EMX__ */
      _rl_get_screen_size (tty, 0);
#endif /* !__EMX__ */

      /* Defaults. */
      if (screenwidth <= 0 || screenheight <= 0)
        {
	  screenwidth = 79;
	  screenheight = 24;
        }

      /* Everything below here is used by the redisplay code (tputs). */
      screenchars = screenwidth * screenheight;
a351 1
      term_mm = term_mo = (char *)NULL;
d355 1
a355 9
      terminal_can_insert = term_has_meta = 0;

      /* Reasonable defaults for tgoto().  Readline currently only uses
         tgoto if term_IC or term_DC is defined, but just in case we
         change that later... */
      PC = '\0';
      BC = term_backspace = "\b";
      UP = term_up;

d370 4
d416 1
a461 1

d478 1
d483 1
d507 1
d525 4
a542 1
#if !defined (__DJGPP__)
a544 1
#endif
a550 1
#if !defined (__DJGPP__)
a554 1
#endif
@


1.1.1.6
log
@import of readline-4.3
@
text
@a66 4
#include "xmalloc.h"

#define CUSTOM_REDISPLAY_FUNC() (rl_redisplay_function != rl_redisplay)
#define CUSTOM_INPUT_FUNC() (rl_getc_function != rl_getc)
d79 3
d90 2
a91 6
char *_rl_term_clreol;
char *_rl_term_clrpag;
char *_rl_term_cr;
char *_rl_term_backspace;
char *_rl_term_goto;
char *_rl_term_pc;
d94 1
a94 1
int _rl_terminal_can_insert = 0;
d97 1
a97 5
char *_rl_term_im;
char *_rl_term_ei;
char *_rl_term_ic;
char *_rl_term_ip;
char *_rl_term_IC;
d100 1
a100 2
char *_rl_term_dc;
char *_rl_term_DC;
d103 1
a103 1
char *_rl_term_forward_char;
d107 1
a107 1
char *_rl_term_up;
d109 2
a110 2
/* A visible bell; char if the terminal can be made to flash the screen. */
static char *_rl_visible_bell;
d119 2
a120 3
   terminal has one. */
static char *_rl_term_mm;
static char *_rl_term_mo;
d123 1
a123 4
static char *_rl_term_ku;
static char *_rl_term_kd;
static char *_rl_term_kr;
static char *_rl_term_kl;
d126 1
a126 2
static char *_rl_term_ks;
static char *_rl_term_ke;
d129 1
a129 12
static char *_rl_term_kh;
static char *_rl_term_kH;
static char *_rl_term_at7;	/* @@7 */

/* Insert key */
static char *_rl_term_kI;

/* Cursor control */
static char *_rl_term_vs;	/* very visible */
static char *_rl_term_ve;	/* normal */

static void bind_termcap_arrow_keys PARAMS((Keymap));
d132 1
a132 1
int _rl_screenwidth, _rl_screenheight, _rl_screenchars;
d172 2
a173 2
      _rl_screenwidth = (int) window_size.ws_col;
      _rl_screenheight = (int) window_size.ws_row;
d178 1
a178 1
  _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
d183 1
a183 1
  if (_rl_screenwidth <= 0)
d185 2
a186 2
      if (ignore_env == 0 && (ss = sh_get_env_value ("COLUMNS")))
	_rl_screenwidth = atoi (ss);
d189 2
a190 2
      if (_rl_screenwidth <= 0 && term_string_buffer)
	_rl_screenwidth = tgetnum ("co");
d196 1
a196 1
  if (_rl_screenheight <= 0)
d198 2
a199 2
      if (ignore_env == 0 && (ss = sh_get_env_value ("LINES")))
	_rl_screenheight = atoi (ss);
d202 2
a203 2
      if (_rl_screenheight <= 0 && term_string_buffer)
	_rl_screenheight = tgetnum ("li");
d208 2
a209 2
  if (_rl_screenwidth <= 1)
    _rl_screenwidth = 80;
d211 2
a212 2
  if (_rl_screenheight <= 0)
    _rl_screenheight = 24;
d217 1
a217 1
  sh_set_lines_and_columns (_rl_screenheight, _rl_screenwidth);
d220 1
a220 1
    _rl_screenwidth--;
d222 1
a222 1
  _rl_screenchars = _rl_screenwidth * _rl_screenheight;
d229 2
a230 5
  if (rows == 0 || cols == 0)
    return;

  _rl_screenheight = rows;
  _rl_screenwidth = cols;
d233 1
a233 1
    _rl_screenwidth--;
d235 1
a235 1
  _rl_screenchars = _rl_screenwidth * _rl_screenheight;
a238 17
rl_set_screen_size (rows, cols)
     int rows, cols;
{
  _rl_set_screen_size (rows, cols);
}

void
rl_get_screen_size (rows, cols)
     int *rows, *cols;
{
  if (rows)
    *rows = _rl_screenheight;
  if (cols)
    *cols = _rl_screenwidth;
}
     
void
d244 1
a244 4
      if (CUSTOM_REDISPLAY_FUNC ())
	rl_forced_update_display ();
      else
	_rl_redisplay_after_sigwinch ();
d249 1
a249 1
     const char *tc_var;
d257 20
a276 22
  { "@@7", &_rl_term_at7 },
  { "DC", &_rl_term_DC },
  { "IC", &_rl_term_IC },
  { "ce", &_rl_term_clreol },
  { "cl", &_rl_term_clrpag },
  { "cr", &_rl_term_cr },
  { "dc", &_rl_term_dc },
  { "ei", &_rl_term_ei },
  { "ic", &_rl_term_ic },
  { "im", &_rl_term_im },
  { "kH", &_rl_term_kH },	/* home down ?? */
  { "kI", &_rl_term_kI },	/* insert */
  { "kd", &_rl_term_kd },
  { "ke", &_rl_term_ke },	/* end keypad mode */
  { "kh", &_rl_term_kh },	/* home */
  { "kl", &_rl_term_kl },
  { "kr", &_rl_term_kr },
  { "ks", &_rl_term_ks },	/* start keypad mode */
  { "ku", &_rl_term_ku },
  { "le", &_rl_term_backspace },
  { "mm", &_rl_term_mm },
  { "mo", &_rl_term_mo },
d278 1
a278 1
  { "nd", &_rl_term_forward_char },
d280 3
a282 5
  { "pc", &_rl_term_pc },
  { "up", &_rl_term_up },
  { "vb", &_rl_visible_bell },
  { "vs", &_rl_term_vs },
  { "ve", &_rl_term_ve },
a296 3
#  ifdef __LCC__
    *(tc_strings[i].tc_value) = tgetstr ((char *)tc_strings[i].tc_var, bp);
#  else
a297 1
#  endif
d302 3
d307 1
a307 1
     const char *terminal_name;
d309 1
a309 2
  const char *term;
  char *buffer;
d311 1
d313 2
a314 2
  term = terminal_name ? terminal_name : sh_get_env_value ("TERM");
  _rl_term_clrpag = _rl_term_cr = _rl_term_clreol = (char *)NULL;
d316 1
a316 1
  _rl_screenwidth = _rl_screenheight = 0;
d331 1
a331 1
	term_string_buffer = (char *)xmalloc(2032);
d334 1
a334 1
	term_buffer = (char *)xmalloc(4080);
d347 1
d351 2
a352 2
      _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
      _rl_screenwidth--;
d358 1
a358 1
      if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
d360 2
a361 2
	  _rl_screenwidth = 79;
	  _rl_screenheight = 24;
d365 6
a370 9
      _rl_screenchars = _rl_screenwidth * _rl_screenheight;
      _rl_term_cr = "\r";
      _rl_term_im = _rl_term_ei = _rl_term_ic = _rl_term_IC = (char *)NULL;
      _rl_term_up = _rl_term_dc = _rl_term_DC = _rl_visible_bell = (char *)NULL;
      _rl_term_ku = _rl_term_kd = _rl_term_kl = _rl_term_kr = (char *)NULL;
      _rl_term_kh = _rl_term_kH = _rl_term_kI = (char *)NULL;
      _rl_term_ks = _rl_term_ke = _rl_term_at7 = (char *)NULL;
      _rl_term_mm = _rl_term_mo = (char *)NULL;
      _rl_term_ve = _rl_term_vs = (char *)NULL;
d374 1
a374 1
      _rl_terminal_can_insert = term_has_meta = 0;
d377 1
a377 1
         tgoto if _rl_term_IC or _rl_term_DC is defined, but just in case we
d380 2
a381 2
      BC = _rl_term_backspace = "\b";
      UP = _rl_term_up;
d390 3
a392 3
  PC = _rl_term_pc ? *_rl_term_pc : 0;
  BC = _rl_term_backspace;
  UP = _rl_term_up;
d394 2
a395 2
  if (!_rl_term_cr)
    _rl_term_cr = "\r";
d405 1
a405 1
  _rl_terminal_can_insert = (_rl_term_IC || _rl_term_im || _rl_term_ic);
d411 1
a411 1
    _rl_term_mm = _rl_term_mo = (char *)NULL;
d415 7
d423 2
a424 1
  bind_termcap_arrow_keys (emacs_standard_keymap);
d427 8
a434 2
  bind_termcap_arrow_keys (vi_movement_keymap);
  bind_termcap_arrow_keys (vi_insertion_keymap);
d437 2
a441 21
/* Bind the arrow key sequences from the termcap description in MAP. */
static void
bind_termcap_arrow_keys (map)
     Keymap map;
{
  Keymap xkeymap;

  xkeymap = _rl_keymap;
  _rl_keymap = map;

  _rl_bind_if_unbound (_rl_term_ku, rl_get_previous_history);
  _rl_bind_if_unbound (_rl_term_kd, rl_get_next_history);
  _rl_bind_if_unbound (_rl_term_kr, rl_forward);
  _rl_bind_if_unbound (_rl_term_kl, rl_backward);

  _rl_bind_if_unbound (_rl_term_kh, rl_beg_of_line);	/* Home */
  _rl_bind_if_unbound (_rl_term_at7, rl_end_of_line);	/* End */

  _rl_keymap = xkeymap;
}

d444 1
a444 1
     const char *cap;
d462 1
a462 1
     const char *terminal_name;
d488 1
a488 1
     const char *string;
d501 1
a501 1
  if (_rl_term_backspace)
d503 1
a503 1
      tputs (_rl_term_backspace, 1, _rl_output_character_function);
d512 1
a512 1
rl_crlf ()
d515 2
a516 2
  if (_rl_term_cr)
    tputs (_rl_term_cr, 1, _rl_output_character_function);
d524 1
a524 1
rl_ding ()
d534 1
a534 1
	  if (_rl_visible_bell)
d536 1
a536 1
	      tputs (_rl_visible_bell, 1, _rl_output_character_function);
d560 2
a561 2
  if (term_has_meta && _rl_term_mm)
    tputs (_rl_term_mm, 1, _rl_output_character_function);
d570 4
a573 4
  if (on && _rl_term_ks)
    tputs (_rl_term_ks, 1, _rl_output_character_function);
  else if (!on && _rl_term_ke)
    tputs (_rl_term_ke, 1, _rl_output_character_function);
a574 26
}

/* **************************************************************** */
/*								    */
/*	 		Controlling the Cursor			    */
/*								    */
/* **************************************************************** */

/* Set the cursor appropriately depending on IM, which is one of the
   insert modes (insert or overwrite).  Insert mode gets the normal
   cursor.  Overwrite mode gets a very visible cursor.  Only does
   anything if we have both capabilities. */
void
_rl_set_cursor (im, force)
     int im, force;
{
  if (_rl_term_ve && _rl_term_vs)
    {
      if (force || im != rl_insert_mode)
	{
	  if (im == RL_IM_OVERWRITE)
	    tputs (_rl_term_vs, 1, _rl_output_character_function);
	  else
	    tputs (_rl_term_ve, 1, _rl_output_character_function);
	}
    }
@


1.1.1.7
log
@import of readlilne 5.1
@
text
@d3 1
a3 1
/* Copyright (C) 1996-2005 Free Software Foundation, Inc.
a71 2
int rl_prefer_env_winsize;

a147 3
/* Delete key */
static char *_rl_term_kD;

a193 1
  int wr, wc;
a194 1
  wr = wc = -1;
d198 2
a199 2
      wc = (int) window_size.ws_col;
      wr = (int) window_size.ws_row;
a206 8
  if (ignore_env || rl_prefer_env_winsize == 0)
    {
      _rl_screenwidth = wc;
      _rl_screenheight = wr;
    }
  else
    _rl_screenwidth = _rl_screenheight = -1;

d208 1
a208 2
     is unset.  If we prefer the environment, check it first before
     assigning the value returned by the kernel. */
a213 3
      if (_rl_screenwidth <= 0)
        _rl_screenwidth = wc;

a226 3
      if (_rl_screenheight <= 0)
        _rl_screenheight = wr;

d255 8
a262 8
  if (rows > 0)
    _rl_screenheight = rows;
  if (cols > 0)
    {
      _rl_screenwidth = cols;
      if (_rl_term_autowrap == 0)
	_rl_screenwidth--;
    }
d264 1
a264 2
  if (rows > 0 || cols > 0)
    _rl_screenchars = _rl_screenwidth * _rl_screenheight;
a282 6

void
rl_reset_screen_size ()
{
  _rl_get_screen_size (fileno (rl_instream), 0);
}
a315 1
  { "kD", &_rl_term_kD },	/* delete */
d350 1
d352 3
d370 1
a402 4
      /* Allow calling application to set default height and width, using
	 rl_set_screen_size */
      if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
	{
d404 2
a405 2
	  _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
	  _rl_screenwidth--;
d407 1
a407 1
	  _rl_get_screen_size (tty, 0);
a408 1
	}
d423 1
a423 1
      _rl_term_kh = _rl_term_kH = _rl_term_kI = _rl_term_kD = (char *)NULL;
d455 1
a455 4
  /* Allow calling application to set default height and width, using
     rl_set_screen_size */
  if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
    _rl_get_screen_size (tty, 0);
d492 4
a495 7
  rl_bind_keyseq_if_unbound (_rl_term_ku, rl_get_previous_history);
  rl_bind_keyseq_if_unbound (_rl_term_kd, rl_get_next_history);
  rl_bind_keyseq_if_unbound (_rl_term_kr, rl_forward_char);
  rl_bind_keyseq_if_unbound (_rl_term_kl, rl_backward_char);

  rl_bind_keyseq_if_unbound (_rl_term_kh, rl_beg_of_line);	/* Home */
  rl_bind_keyseq_if_unbound (_rl_term_at7, rl_end_of_line);	/* End */
d497 2
a498 1
  rl_bind_keyseq_if_unbound (_rl_term_kD, rl_delete);
a524 1
  _rl_screenwidth = _rl_screenheight = 0;
@


