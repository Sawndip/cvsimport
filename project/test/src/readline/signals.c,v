head	1.11;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.11
	gdb_7_6-2013-04-26-release:1.11
	gdb_7_6-branch:1.11.0.4
	gdb_7_6-2013-03-12-branchpoint:1.11
	gdb_7_5_1-2012-11-29-release:1.11
	gdb_7_5-2012-08-17-release:1.11
	gdb_7_5-branch:1.11.0.2
	gdb_7_5-2012-07-18-branchpoint:1.11
	gdb_7_4_1-2012-04-26-release:1.10
	gdb_7_4-2012-01-24-release:1.10
	gdb_7_4-branch:1.10.0.2
	gdb_7_4-2011-12-13-branchpoint:1.10
	gdb_7_3_1-2011-09-04-release:1.9
	gdb_7_3-2011-07-26-release:1.9
	gdb_7_3-branch:1.9.0.16
	gdb_7_3-2011-04-01-branchpoint:1.9
	gdb_7_2-2010-09-02-release:1.9
	gdb_7_2-branch:1.9.0.14
	gdb_7_2-2010-07-07-branchpoint:1.9
	gdb_7_1-2010-03-18-release:1.9
	gdb_7_1-branch:1.9.0.12
	gdb_7_1-2010-02-18-branchpoint:1.9
	gdb_7_0_1-2009-12-22-release:1.9
	gdb_7_0-2009-10-06-release:1.9
	gdb_7_0-branch:1.9.0.10
	gdb_7_0-2009-09-16-branchpoint:1.9
	arc-sim-20090309:1.8
	msnyder-checkpoint-072509-branch:1.9.0.8
	msnyder-checkpoint-072509-branchpoint:1.9
	arc-insight_6_8-branch:1.8.0.20
	arc-insight_6_8-branchpoint:1.8
	insight_6_8-branch:1.8.0.18
	insight_6_8-branchpoint:1.8
	reverse-20081226-branch:1.9.0.6
	reverse-20081226-branchpoint:1.9
	multiprocess-20081120-branch:1.9.0.4
	multiprocess-20081120-branchpoint:1.9
	reverse-20080930-branch:1.9.0.2
	reverse-20080930-branchpoint:1.9
	reverse-20080717-branch:1.8.0.16
	reverse-20080717-branchpoint:1.8
	msnyder-reverse-20080609-branch:1.8.0.14
	msnyder-reverse-20080609-branchpoint:1.8
	drow-reverse-20070409-branch:1.8.0.12
	drow-reverse-20070409-branchpoint:1.8
	gdb_6_8-2008-03-27-release:1.8
	gdb_6_8-branch:1.8.0.10
	gdb_6_8-2008-02-26-branchpoint:1.8
	gdb_6_7_1-2007-10-29-release:1.8
	gdb_6_7-2007-10-10-release:1.8
	gdb_6_7-branch:1.8.0.8
	gdb_6_7-2007-09-07-branchpoint:1.8
	insight_6_6-20070208-release:1.8
	gdb_6_6-2006-12-18-release:1.8
	gdb_6_6-branch:1.8.0.6
	gdb_6_6-2006-11-15-branchpoint:1.8
	insight_6_5-20061003-release:1.8
	gdb-csl-symbian-6_4_50_20060226-12:1.6
	gdb-csl-sourcerygxx-3_4_4-25:1.6
	nickrob-async-20060828-mergepoint:1.8
	gdb-csl-symbian-6_4_50_20060226-11:1.6
	gdb-csl-sourcerygxx-4_1-17:1.6
	gdb-csl-20060226-branch-local-2:1.6
	gdb-csl-sourcerygxx-4_1-14:1.6
	gdb-csl-sourcerygxx-4_1-13:1.6
	gdb-csl-sourcerygxx-4_1-12:1.6
	gdb-csl-sourcerygxx-3_4_4-21:1.6
	gdb_6_5-20060621-release:1.8
	gdb-csl-sourcerygxx-4_1-9:1.6
	gdb-csl-sourcerygxx-4_1-8:1.6
	gdb-csl-sourcerygxx-4_1-7:1.6
	gdb-csl-arm-2006q1-6:1.6
	gdb-csl-sourcerygxx-4_1-6:1.6
	gdb-csl-symbian-6_4_50_20060226-10:1.6
	gdb-csl-symbian-6_4_50_20060226-9:1.6
	gdb-csl-symbian-6_4_50_20060226-8:1.6
	gdb-csl-coldfire-4_1-11:1.6
	gdb-csl-sourcerygxx-3_4_4-19:1.6
	gdb-csl-coldfire-4_1-10:1.6
	gdb_6_5-branch:1.8.0.4
	gdb_6_5-2006-05-14-branchpoint:1.8
	gdb-csl-sourcerygxx-4_1-5:1.6
	nickrob-async-20060513-branch:1.8.0.2
	nickrob-async-20060513-branchpoint:1.8
	gdb-csl-sourcerygxx-4_1-4:1.6
	msnyder-reverse-20060502-branch:1.7.0.4
	msnyder-reverse-20060502-branchpoint:1.7
	gdb-csl-morpho-4_1-4:1.6
	gdb-csl-sourcerygxx-3_4_4-17:1.6
	readline_5_1-import-branch:1.7.0.2
	readline_5_1-import-branchpoint:1.7
	readline-pre-51-import:1.7
	readline_5_1:1.1.1.5
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.6
	gdb-csl-symbian-20060226-branch:1.6.0.18
	gdb-csl-symbian-20060226-branchpoint:1.6
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.6
	msnyder-reverse-20060331-branch:1.6.0.16
	msnyder-reverse-20060331-branchpoint:1.6
	gdb-csl-available-20060303-branch:1.6.0.14
	gdb-csl-available-20060303-branchpoint:1.6
	gdb-csl-20060226-branch:1.6.0.12
	gdb-csl-20060226-branchpoint:1.6
	gdb_6_4-20051202-release:1.6
	msnyder-fork-checkpoint-branch:1.6.0.10
	msnyder-fork-checkpoint-branchpoint:1.6
	gdb-csl-gxxpro-6_3-branch:1.6.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.6
	gdb_6_4-branch:1.6.0.6
	gdb_6_4-2005-11-01-branchpoint:1.6
	gdb-csl-arm-20051020-branch:1.6.0.4
	gdb-csl-arm-20051020-branchpoint:1.6
	msnyder-tracepoint-checkpoint-branch:1.6.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.6
	gdb-csl-arm-20050325-2005-q1b:1.5.60.1
	gdb-csl-arm-20050325-2005-q1a:1.5.60.1
	csl-arm-20050325-branch:1.5.0.60
	csl-arm-20050325-branchpoint:1.5
	gdb_6_3-20041109-release:1.5
	gdb_6_3-branch:1.5.0.56
	gdb_6_3-20041019-branchpoint:1.5
	drow_intercu-merge-20040921:1.5
	drow_intercu-merge-20040915:1.5
	jimb-gdb_6_2-e500-branch:1.5.0.58
	jimb-gdb_6_2-e500-branchpoint:1.5
	gdb_6_2-20040730-release:1.5
	gdb_6_2-branch:1.5.0.54
	gdb_6_2-2004-07-10-gmt-branchpoint:1.5
	gdb_6_1_1-20040616-release:1.5
	gdb_6_1-2004-04-05-release:1.5
	drow_intercu-merge-20040402:1.5
	drow_intercu-merge-20040327:1.5
	ezannoni_pie-20040323-branch:1.5.0.52
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.50
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow_intercu-20040221-branch:1.5.0.46
	drow_intercu-20040221-branchpoint:1.5
	cagney_bfdfile-20040213-branch:1.5.0.44
	cagney_bfdfile-20040213-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	cagney_bigcore-20040122-branch:1.5.0.42
	cagney_bigcore-20040122-branchpoint:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	kettenis_sparc-20030918-branch:1.5.0.40
	kettenis_sparc-20030918-branchpoint:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.38
	cagney_x86i386-20030821-branch:1.5.0.36
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.34
	gdb_6_0-2003-06-23-branchpoint:1.5
	jimb-ppc64-linux-20030613-branch:1.5.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.30
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.28
	cagney_writestrings-20030508-branchpoint:1.5
	jimb-ppc64-linux-20030528-branch:1.5.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.24
	cagney_fileio-20030521-branchpoint:1.5
	kettenis_i386newframe-20030517-mergepoint:1.5
	jimb-ppc64-linux-20030509-branch:1.5.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.5
	kettenis_i386newframe-20030504-mergepoint:1.5
	carlton_dictionary-20030430-merge:1.5
	kettenis_i386newframe-20030419-branch:1.5.0.20
	kettenis_i386newframe-20030419-branchpoint:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	kettenis_i386newframe-20030406-branch:1.5.0.18
	kettenis_i386newframe-20030406-branchpoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.16
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.14
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.12
	cagney_lazyid-20030317-branchpoint:1.5
	kettenis-i386newframe-20030316-mergepoint:1.5
	offbyone-20030313-branch:1.5.0.10
	offbyone-20030313-branchpoint:1.5
	kettenis-i386newframe-20030308-branch:1.5.0.8
	kettenis-i386newframe-20030308-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.6
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.4
	interps-20030202-branchpoint:1.5
	cagney-unwind-20030108-branch:1.5.0.2
	cagney-unwind-20030108-branchpoint:1.5
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.4
	readline-pre-43-import:1.4
	carlton_dictionary-20021115-merge:1.4
	kseitz_interps-20021105-merge:1.4
	kseitz_interps-20021103-merge:1.4
	drow-cplus-merge-20021020:1.4
	drow-cplus-merge-20021025:1.4
	carlton_dictionary-20021025-merge:1.4
	carlton_dictionary-20021011-merge:1.4
	drow-cplus-branch:1.4.0.24
	drow-cplus-branchpoint:1.4
	kseitz_interps-20020930-merge:1.4
	carlton_dictionary-20020927-merge:1.4
	carlton_dictionary-branch:1.4.0.22
	carlton_dictionary-20020920-branchpoint:1.4
	gdb_5_3-branch:1.4.0.20
	gdb_5_3-2002-09-04-branchpoint:1.4
	kseitz_interps-20020829-merge:1.4
	cagney_sysregs-20020825-branch:1.4.0.18
	cagney_sysregs-20020825-branchpoint:1.4
	readline_4_3-import-branch:1.4.0.16
	readline_4_3-import-branchpoint:1.4
	readline_4_3:1.1.1.4
	gdb_5_2_1-2002-07-23-release:1.4
	kseitz_interps-20020528-branch:1.4.0.14
	kseitz_interps-20020528-branchpoint:1.4
	cagney_regbuf-20020515-branch:1.4.0.12
	cagney_regbuf-20020515-branchpoint:1.4
	jimb-macro-020506-branch:1.4.0.10
	jimb-macro-020506-branchpoint:1.4
	gdb_5_2-2002-04-29-release:1.4
	gdb_5_2-branch:1.4.0.8
	gdb_5_2-2002-03-03-branchpoint:1.4
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	insight-precleanup-2001-01-01:1.4
	readline_4_1:1.1.1.3
	readline_4_0:1.1.1.2
	FSF:1.1.1
	readline-pre-41-import:1.3
	gdb-premipsmulti-2000-06-06-branch:1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.11
date	2012.02.24.17.14.43;	author muller;	state Exp;
branches;
next	1.10;

1.10
date	2011.05.11.23.38.39;	author jkratoch;	state Exp;
branches;
next	1.9;

1.9
date	2008.08.10.19.17.42;	author palves;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.05.18.26.12;	author drow;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.20.20.13.20;	author ezannoni;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2005.05.09.19.42.03;	author mmitchel;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.08.22.31.37;	author ezannoni;	state Exp;
branches
	1.5.60.1;
next	1.4;

1.4
date	2000.07.09.17.19.56;	author ezannoni;	state Exp;
branches
	1.4.16.1
	1.4.22.1
	1.4.24.1;
next	1.3;

1.3
date	2000.07.07.17.15.45;	author ezannoni;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.15.11.59.45;	author eliz;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.54;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.7.2.1
date	2006.04.24.22.00.25;	author drow;	state Exp;
branches;
next	;

1.5.60.1
date	2005.03.28.19.34.27;	author mmitchel;	state Exp;
branches;
next	;

1.4.16.1
date	2002.08.25.23.41.17;	author ezannoni;	state Exp;
branches;
next	;

1.4.22.1
date	2002.12.23.19.39.44;	author carlton;	state Exp;
branches;
next	;

1.4.24.1
date	2003.12.14.20.28.14;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.54;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.08.02.23.47.58;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.07.09.16.21.20;	author ezannoni;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.08.23.22.02.28;	author ezannoni;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.20.20.05.37;	author ezannoni;	state Exp;
branches;
next	;


desc
@@


1.11
log
@	* signals.c (_rl_block_sigwinch, _rl_release_sigwinch): Add
	conditional SIGWINCH around functions.
@
text
@/* signals.c -- signal handling support for readline. */

/* Copyright (C) 1987-2009 Free Software Foundation, Inc.

   This file is part of the GNU Readline Library (Readline), a library
   for reading lines of text with interactive input and history editing.      

   Readline is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Readline is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Readline.  If not, see <http://www.gnu.org/licenses/>.
*/

#define READLINE_LIBRARY

#if defined (HAVE_CONFIG_H)
#  include <config.h>
#endif

#include <stdio.h>		/* Just for NULL.  Yuck. */
#include <sys/types.h>
#include <signal.h>

#if defined (HAVE_UNISTD_H)
#  include <unistd.h>
#endif /* HAVE_UNISTD_H */

/* System-specific feature definitions and include files. */
#include "rldefs.h"

#if defined (GWINSZ_IN_SYS_IOCTL)
#  include <sys/ioctl.h>
#endif /* GWINSZ_IN_SYS_IOCTL */

/* Some standard library routines. */
#include "readline.h"
#include "history.h"

#include "rlprivate.h"

#if defined (HANDLE_SIGNALS)

#if !defined (RETSIGTYPE)
#  if defined (VOID_SIGHANDLER)
#    define RETSIGTYPE void
#  else
#    define RETSIGTYPE int
#  endif /* !VOID_SIGHANDLER */
#endif /* !RETSIGTYPE */

#if defined (VOID_SIGHANDLER)
#  define SIGHANDLER_RETURN return
#else
#  define SIGHANDLER_RETURN return (0)
#endif

/* This typedef is equivalent to the one for Function; it allows us
   to say SigHandler *foo = signal (SIGKILL, SIG_IGN); */
typedef RETSIGTYPE SigHandler ();

#if defined (HAVE_POSIX_SIGNALS)
typedef struct sigaction sighandler_cxt;
#  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
#else
typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags; } sighandler_cxt;
#  define sigemptyset(m)
#endif /* !HAVE_POSIX_SIGNALS */

#ifndef SA_RESTART
#  define SA_RESTART 0
#endif

static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));

static RETSIGTYPE rl_signal_handler PARAMS((int));
static RETSIGTYPE _rl_handle_signal PARAMS((int));
     
/* Exported variables for use by applications. */

/* If non-zero, readline will install its own signal handlers for
   SIGINT, SIGTERM, SIGQUIT, SIGALRM, SIGTSTP, SIGTTIN, and SIGTTOU. */
int rl_catch_signals = 1;

/* If non-zero, readline will install a signal handler for SIGWINCH. */
#ifdef SIGWINCH
int rl_catch_sigwinch = 1;
#else
int rl_catch_sigwinch = 0;	/* for the readline state struct in readline.c */
#endif

/* Private variables. */
int _rl_interrupt_immediately = 0;
int volatile _rl_caught_signal = 0;	/* should be sig_atomic_t, but that requires including <signal.h> everywhere */

/* If non-zero, print characters corresponding to received signals as long as
   the user has indicated his desire to do so (_rl_echo_control_chars). */
int _rl_echoctl = 0;

int _rl_intr_char = 0;
int _rl_quit_char = 0;
int _rl_susp_char = 0;

static int signals_set_flag;
static int sigwinch_set_flag;

/* **************************************************************** */
/*					        		    */
/*			   Signal Handling                          */
/*								    */
/* **************************************************************** */

static sighandler_cxt old_int, old_term, old_alrm, old_quit;
#if defined (SIGTSTP)
static sighandler_cxt old_tstp, old_ttou, old_ttin;
#endif
#if defined (SIGWINCH)
static sighandler_cxt old_winch;
#endif

/* Readline signal handler functions. */

/* Called from RL_CHECK_SIGNALS() macro */
RETSIGTYPE
_rl_signal_handler (sig)
     int sig;
{
  _rl_caught_signal = 0;	/* XXX */

  _rl_handle_signal (sig);
  SIGHANDLER_RETURN;
}

static RETSIGTYPE
rl_signal_handler (sig)
     int sig;
{
  if (_rl_interrupt_immediately || RL_ISSTATE(RL_STATE_CALLBACK))
    {
      _rl_interrupt_immediately = 0;
      _rl_handle_signal (sig);
    }
  else
    _rl_caught_signal = sig;

  SIGHANDLER_RETURN;
}

static RETSIGTYPE
_rl_handle_signal (sig)
     int sig;
{
#if defined (HAVE_POSIX_SIGNALS)
  sigset_t set;
#else /* !HAVE_POSIX_SIGNALS */
#  if defined (HAVE_BSD_SIGNALS)
  long omask;
#  else /* !HAVE_BSD_SIGNALS */
  sighandler_cxt dummy_cxt;	/* needed for rl_set_sighandler call */
#  endif /* !HAVE_BSD_SIGNALS */
#endif /* !HAVE_POSIX_SIGNALS */

  RL_SETSTATE(RL_STATE_SIGHANDLER);

#if !defined (HAVE_BSD_SIGNALS) && !defined (HAVE_POSIX_SIGNALS)
  /* Since the signal will not be blocked while we are in the signal
     handler, ignore it until rl_clear_signals resets the catcher. */
#  if defined (SIGALRM)
  if (sig == SIGINT || sig == SIGALRM)
#  else
  if (sig == SIGINT)
#  endif
    rl_set_sighandler (sig, SIG_IGN, &dummy_cxt);
#endif /* !HAVE_BSD_SIGNALS && !HAVE_POSIX_SIGNALS */

  switch (sig)
    {
    case SIGINT:
      _rl_reset_completion_state ();
      rl_free_line_state ();
      /* FALLTHROUGH */

    case SIGTERM:
#if defined (SIGTSTP)
    case SIGTSTP:
    case SIGTTOU:
    case SIGTTIN:
#endif /* SIGTSTP */
#if defined (SIGALRM)
    case SIGALRM:
#endif
#if defined (SIGQUIT)
    case SIGQUIT:
#endif
      rl_echo_signal_char (sig);
      rl_cleanup_after_signal ();

#if defined (HAVE_POSIX_SIGNALS)
      sigemptyset (&set);
      sigprocmask (SIG_BLOCK, (sigset_t *)NULL, &set);
      sigdelset (&set, sig);
#else /* !HAVE_POSIX_SIGNALS */
#  if defined (HAVE_BSD_SIGNALS)
      omask = sigblock (0);
#  endif /* HAVE_BSD_SIGNALS */
#endif /* !HAVE_POSIX_SIGNALS */

#if defined (__EMX__)
      signal (sig, SIG_ACK);
#endif

#if defined (HAVE_KILL)
      kill (getpid (), sig);
#else
      raise (sig);		/* assume we have raise */
#endif

      /* Let the signal that we just sent through.  */
#if defined (HAVE_POSIX_SIGNALS)
      sigprocmask (SIG_SETMASK, &set, (sigset_t *)NULL);
#else /* !HAVE_POSIX_SIGNALS */
#  if defined (HAVE_BSD_SIGNALS)
      sigsetmask (omask & ~(sigmask (sig)));
#  endif /* HAVE_BSD_SIGNALS */
#endif /* !HAVE_POSIX_SIGNALS */

      rl_reset_after_signal ();
    }

  RL_UNSETSTATE(RL_STATE_SIGHANDLER);
  SIGHANDLER_RETURN;
}

#if defined (SIGWINCH)
static RETSIGTYPE
rl_sigwinch_handler (sig)
     int sig;
{
  SigHandler *oh;

#if defined (MUST_REINSTALL_SIGHANDLERS)
  sighandler_cxt dummy_winch;

  /* We don't want to change old_winch -- it holds the state of SIGWINCH
     disposition set by the calling application.  We need this state
     because we call the application's SIGWINCH handler after updating
     our own idea of the screen size. */
  rl_set_sighandler (SIGWINCH, rl_sigwinch_handler, &dummy_winch);
#endif

  RL_SETSTATE(RL_STATE_SIGHANDLER);
  rl_resize_terminal ();

  /* If another sigwinch handler has been installed, call it. */
  oh = (SigHandler *)old_winch.sa_handler;
  if (oh &&  oh != (SigHandler *)SIG_IGN && oh != (SigHandler *)SIG_DFL)
    (*oh) (sig);

  RL_UNSETSTATE(RL_STATE_SIGHANDLER);
  SIGHANDLER_RETURN;
}
#endif  /* SIGWINCH */

/* Functions to manage signal handling. */

#if !defined (HAVE_POSIX_SIGNALS)
static int
rl_sigaction (sig, nh, oh)
     int sig;
     sighandler_cxt *nh, *oh;
{
  oh->sa_handler = signal (sig, nh->sa_handler);
  return 0;
}
#endif /* !HAVE_POSIX_SIGNALS */

/* Set up a readline-specific signal handler, saving the old signal
   information in OHANDLER.  Return the old signal handler, like
   signal(). */
static SigHandler *
rl_set_sighandler (sig, handler, ohandler)
     int sig;
     SigHandler *handler;
     sighandler_cxt *ohandler;
{
  sighandler_cxt old_handler;
#if defined (HAVE_POSIX_SIGNALS)
  struct sigaction act;

  act.sa_handler = handler;
#  if defined (SIGWINCH)
  act.sa_flags = (sig == SIGWINCH) ? SA_RESTART : 0;
#  else
  act.sa_flags = 0;
#  endif /* SIGWINCH */
  sigemptyset (&act.sa_mask);
  sigemptyset (&ohandler->sa_mask);
  sigaction (sig, &act, &old_handler);
#else
  old_handler.sa_handler = (SigHandler *)signal (sig, handler);
#endif /* !HAVE_POSIX_SIGNALS */

  /* XXX -- assume we have memcpy */
  /* If rl_set_signals is called twice in a row, don't set the old handler to
     rl_signal_handler, because that would cause infinite recursion. */
  if (handler != rl_signal_handler || old_handler.sa_handler != rl_signal_handler)
    memcpy (ohandler, &old_handler, sizeof (sighandler_cxt));

  return (ohandler->sa_handler);
}

static void
rl_maybe_set_sighandler (sig, handler, ohandler)
     int sig;
     SigHandler *handler;
     sighandler_cxt *ohandler;
{
  sighandler_cxt dummy;
  SigHandler *oh;

  sigemptyset (&dummy.sa_mask);
  oh = rl_set_sighandler (sig, handler, ohandler);
  if (oh == (SigHandler *)SIG_IGN)
    rl_sigaction (sig, ohandler, &dummy);
}

int
rl_set_signals ()
{
  sighandler_cxt dummy;
  SigHandler *oh;
#if defined (HAVE_POSIX_SIGNALS)
  static int sigmask_set = 0;
  static sigset_t bset, oset;
#endif

#if defined (HAVE_POSIX_SIGNALS)
  if (rl_catch_signals && sigmask_set == 0)
    {
      sigemptyset (&bset);

      sigaddset (&bset, SIGINT);
      sigaddset (&bset, SIGTERM);
#if defined (SIGQUIT)
      sigaddset (&bset, SIGQUIT);
#endif
#if defined (SIGALRM)
      sigaddset (&bset, SIGALRM);
#endif
#if defined (SIGTSTP)
      sigaddset (&bset, SIGTSTP);
#endif
#if defined (SIGTTIN)
      sigaddset (&bset, SIGTTIN);
#endif
#if defined (SIGTTOU)
      sigaddset (&bset, SIGTTOU);
#endif
      sigmask_set = 1;
    }      
#endif /* HAVE_POSIX_SIGNALS */

  if (rl_catch_signals && signals_set_flag == 0)
    {
#if defined (HAVE_POSIX_SIGNALS)
      sigemptyset (&oset);
      sigprocmask (SIG_BLOCK, &bset, &oset);
#endif

      rl_maybe_set_sighandler (SIGINT, rl_signal_handler, &old_int);
      rl_maybe_set_sighandler (SIGTERM, rl_signal_handler, &old_term);
#if defined (SIGQUIT)
      rl_maybe_set_sighandler (SIGQUIT, rl_signal_handler, &old_quit);
#endif

#if defined (SIGALRM)
      oh = rl_set_sighandler (SIGALRM, rl_signal_handler, &old_alrm);
      if (oh == (SigHandler *)SIG_IGN)
	rl_sigaction (SIGALRM, &old_alrm, &dummy);
#if defined (HAVE_POSIX_SIGNALS) && defined (SA_RESTART)
      /* If the application using readline has already installed a signal
	 handler with SA_RESTART, SIGALRM will cause reads to be restarted
	 automatically, so readline should just get out of the way.  Since
	 we tested for SIG_IGN above, we can just test for SIG_DFL here. */
      if (oh != (SigHandler *)SIG_DFL && (old_alrm.sa_flags & SA_RESTART))
	rl_sigaction (SIGALRM, &old_alrm, &dummy);
#endif /* HAVE_POSIX_SIGNALS */
#endif /* SIGALRM */

#if defined (SIGTSTP)
      rl_maybe_set_sighandler (SIGTSTP, rl_signal_handler, &old_tstp);
#endif /* SIGTSTP */

#if defined (SIGTTOU)
      rl_maybe_set_sighandler (SIGTTOU, rl_signal_handler, &old_ttou);
#endif /* SIGTTOU */

#if defined (SIGTTIN)
      rl_maybe_set_sighandler (SIGTTIN, rl_signal_handler, &old_ttin);
#endif /* SIGTTIN */

      signals_set_flag = 1;

#if defined (HAVE_POSIX_SIGNALS)
      sigprocmask (SIG_SETMASK, &oset, (sigset_t *)NULL);
#endif
    }

#if defined (SIGWINCH)
  if (rl_catch_sigwinch && sigwinch_set_flag == 0)
    {
      rl_maybe_set_sighandler (SIGWINCH, rl_sigwinch_handler, &old_winch);
      sigwinch_set_flag = 1;
    }
#endif /* SIGWINCH */

  return 0;
}

int
rl_clear_signals ()
{
  sighandler_cxt dummy;

  if (rl_catch_signals && signals_set_flag == 1)
    {
      sigemptyset (&dummy.sa_mask);

      rl_sigaction (SIGINT, &old_int, &dummy);
      rl_sigaction (SIGTERM, &old_term, &dummy);
#if defined (SIGQUIT)
      rl_sigaction (SIGQUIT, &old_quit, &dummy);
#endif
#if defined (SIGALRM)
      rl_sigaction (SIGALRM, &old_alrm, &dummy);
#endif

#if defined (SIGTSTP)
      rl_sigaction (SIGTSTP, &old_tstp, &dummy);
#endif /* SIGTSTP */

#if defined (SIGTTOU)
      rl_sigaction (SIGTTOU, &old_ttou, &dummy);
#endif /* SIGTTOU */

#if defined (SIGTTIN)
      rl_sigaction (SIGTTIN, &old_ttin, &dummy);
#endif /* SIGTTIN */

      signals_set_flag = 0;
    }

#if defined (SIGWINCH)
  if (rl_catch_sigwinch && sigwinch_set_flag == 1)
    {
      sigemptyset (&dummy.sa_mask);
      rl_sigaction (SIGWINCH, &old_winch, &dummy);
      sigwinch_set_flag = 0;
    }
#endif

  return 0;
}

/* Clean up the terminal and readline state after catching a signal, before
   resending it to the calling application. */
void
rl_cleanup_after_signal ()
{
  _rl_clean_up_for_exit ();
  if (rl_deprep_term_function)
    (*rl_deprep_term_function) ();
  rl_clear_pending_input ();
  rl_clear_signals ();
}

/* Reset the terminal and readline state after a signal handler returns. */
void
rl_reset_after_signal ()
{
  if (rl_prep_term_function)
    (*rl_prep_term_function) (_rl_meta_flag);
  rl_set_signals ();
}

/* Free up the readline variable line state for the current line (undo list,
   any partial history entry, any keyboard macros in progress, and any
   numeric arguments in process) after catching a signal, before calling
   rl_cleanup_after_signal(). */ 
void
rl_free_line_state ()
{
  register HIST_ENTRY *entry;

  rl_free_undo_list ();

  entry = current_history ();
  if (entry)
    entry->data = (char *)NULL;

  _rl_kill_kbd_macro ();
  rl_clear_message ();
  _rl_reset_argument ();
}

#endif  /* HANDLE_SIGNALS */

/* **************************************************************** */
/*								    */
/*			   SIGINT Management			    */
/*								    */
/* **************************************************************** */

#if defined (HAVE_POSIX_SIGNALS)
static sigset_t sigint_set, sigint_oset;
static sigset_t sigwinch_set, sigwinch_oset;
#else /* !HAVE_POSIX_SIGNALS */
#  if defined (HAVE_BSD_SIGNALS)
static int sigint_oldmask;
static int sigwinch_oldmask;
#  endif /* HAVE_BSD_SIGNALS */
#endif /* !HAVE_POSIX_SIGNALS */

static int sigint_blocked;
static int sigwinch_blocked;

/* Cause SIGINT to not be delivered until the corresponding call to
   release_sigint(). */
void
_rl_block_sigint ()
{
  if (sigint_blocked)
    return;

#if defined (HAVE_POSIX_SIGNALS)
  sigemptyset (&sigint_set);
  sigemptyset (&sigint_oset);
  sigaddset (&sigint_set, SIGINT);
  sigprocmask (SIG_BLOCK, &sigint_set, &sigint_oset);
#else /* !HAVE_POSIX_SIGNALS */
#  if defined (HAVE_BSD_SIGNALS)
  sigint_oldmask = sigblock (sigmask (SIGINT));
#  else /* !HAVE_BSD_SIGNALS */
#    if defined (HAVE_USG_SIGHOLD)
  sighold (SIGINT);
#    endif /* HAVE_USG_SIGHOLD */
#  endif /* !HAVE_BSD_SIGNALS */
#endif /* !HAVE_POSIX_SIGNALS */

  sigint_blocked = 1;
}

/* Allow SIGINT to be delivered. */
void
_rl_release_sigint ()
{
  if (sigint_blocked == 0)
    return;

#if defined (HAVE_POSIX_SIGNALS)
  sigprocmask (SIG_SETMASK, &sigint_oset, (sigset_t *)NULL);
#else
#  if defined (HAVE_BSD_SIGNALS)
  sigsetmask (sigint_oldmask);
#  else /* !HAVE_BSD_SIGNALS */
#    if defined (HAVE_USG_SIGHOLD)
  sigrelse (SIGINT);
#    endif /* HAVE_USG_SIGHOLD */
#  endif /* !HAVE_BSD_SIGNALS */
#endif /* !HAVE_POSIX_SIGNALS */

  sigint_blocked = 0;
}

#ifdef SIGWINCH
/* Cause SIGWINCH to not be delivered until the corresponding call to
   release_sigwinch(). */
void
_rl_block_sigwinch ()
{
  if (sigwinch_blocked)
    return;

#if defined (HAVE_POSIX_SIGNALS)
  sigemptyset (&sigwinch_set);
  sigemptyset (&sigwinch_oset);
  sigaddset (&sigwinch_set, SIGWINCH);
  sigprocmask (SIG_BLOCK, &sigwinch_set, &sigwinch_oset);
#else /* !HAVE_POSIX_SIGNALS */
#  if defined (HAVE_BSD_SIGNALS)
  sigwinch_oldmask = sigblock (sigmask (SIGWINCH));
#  else /* !HAVE_BSD_SIGNALS */
#    if defined (HAVE_USG_SIGHOLD)
  sighold (SIGWINCH);
#    endif /* HAVE_USG_SIGHOLD */
#  endif /* !HAVE_BSD_SIGNALS */
#endif /* !HAVE_POSIX_SIGNALS */

  sigwinch_blocked = 1;
}

/* Allow SIGWINCH to be delivered. */
void
_rl_release_sigwinch ()
{
  if (sigwinch_blocked == 0)
    return;

#if defined (HAVE_POSIX_SIGNALS)
  sigprocmask (SIG_SETMASK, &sigwinch_oset, (sigset_t *)NULL);
#else
#  if defined (HAVE_BSD_SIGNALS)
  sigsetmask (sigwinch_oldmask);
#  else /* !HAVE_BSD_SIGNALS */
#    if defined (HAVE_USG_SIGHOLD)
  sigrelse (SIGWINCH);
#    endif /* HAVE_USG_SIGHOLD */
#  endif /* !HAVE_BSD_SIGNALS */
#endif /* !HAVE_POSIX_SIGNALS */

  sigwinch_blocked = 0;
}
#endif /* SIGWINCH */

/* **************************************************************** */
/*								    */
/*		Echoing special control characters		    */
/*								    */
/* **************************************************************** */
void
rl_echo_signal_char (sig)
     int sig;
{
  char cstr[3];
  int cslen, c;

  if (_rl_echoctl == 0 || _rl_echo_control_chars == 0)
    return;

  switch (sig)
    {
    case SIGINT:  c = _rl_intr_char; break;
#if defined (SIGQUIT)
    case SIGQUIT: c = _rl_quit_char; break;
#endif
#if defined (SIGTSTP)
    case SIGTSTP: c = _rl_susp_char; break;
#endif
    default: return;
    }

  if (CTRL_CHAR (c) || c == RUBOUT)
    {
      cstr[0] = '^';
      cstr[1] = CTRL_CHAR (c) ? UNCTRL (c) : '?';
      cstr[cslen = 2] = '\0';
    }
  else
    {
      cstr[0] = c;
      cstr[cslen = 1] = '\0';
    }

  _rl_output_some_chars (cstr, cslen);
}
@


1.10
log
@Imported readline 6.2, and upstream patch 001.

[patch 0/3] readline-6.2 rebase
http://sourceware.org/ml/gdb-patches/2011-05/msg00003.html
[patch 1/3] readline-6.2: Merge of already posted patches
http://sourceware.org/ml/gdb-patches/2011-05/msg00004.html
	=
	[Bug-readline] [RFC/readline] bind.c, rl_function_dumper, Free allocated
	http://lists.gnu.org/archive/html/bug-readline/2011-03/msg00000.html
	[Bug-readline] [patch] Fix underquotation in readline/examples/rlfe/conf
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00001.html
	[Bug-readline] [patch] Makefile.in htm<->html
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00002.html
	Re: [Bug-readline] [patch] Makefile.in dependency: callback.o: xmalloc.h
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00004.html
	[Bug-readline] [patch] Remove . from the VPATH directive
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00005.html
	Eli Zaretskii's __MSDOS__ / __GO32__ / __MINGW32__ / __DJGPP__ stuff:
	http://sourceware.org/ml/gdb/2011-04/msg00002.html
	Jan Kratochvil's patch for FSF GDB tree local-specific changes:
	http://sourceware.org/ml/gdb/2011-04/msg00006.html
	Preservation of existing ChangeLog.gdb files, their updates.
[patch 2/3] readline-6.2: Workaround "ask" regression
http://sourceware.org/ml/gdb-patches/2011-05/msg00005.html
[patch 3/3] readline-6.2: Revert 5.x compat., apply 6.x compat.
http://sourceware.org/ml/gdb-patches/2011-05/msg00006.html
[patch 4/3] readline-6.2: Substitute inc-hist.texinfo
http://sourceware.org/ml/gdb-patches/2011-05/msg00010.html

readline/
	Workaround gdb.base/completion.exp regression on readline-6.2.
	* complete.c (get_y_or_n): Disable the return on RL_STATE_CALLBACK.

	Imported readline 6.2, and upstream patch 001.
	* configure: Regenerate.

readline/doc/
	* hsuser.texi (Using History Interactively): Disable !BashFeatures
	@@defcodeindex.  Make the `Programming with GNU History' reference
	external.
	* inc-hist.texinfo: Remove.

	Imported readline 6.2, and upstream patch 001.

readline/examples/
	Imported readline 6.2, and upstream patch 001.

readline/examples/rlfe/
	Imported readline 6.2, and upstream patch 001.

gdb/
	* config.in: Regenerate.
	* configure: Regenerate.
	* configure.ac <--with-system-readline> (for readline_echoing_p):
	Remove the test.
	* tui/tui-io.c (tui_old_readline_echoing_p): Rename to ...
	(tui_old_rl_echoing_p): ... here.
	(tui_setup_io): Rename extern declaration readline_echoing_p to
	_rl_echoing_p.  Adjust assignments for the both renames.

gdb/doc/
	* Makefile.in (GDB_DOC_SOURCE_INCLUDES): Rename inc-hist.texinfo to
	hsuser.texi.
	* gdb.texinfo <!SYSTEM_READLINE>: Rename inc-hist.texinfo inclusion and
	comment to hsuser.texi.  Change rluser.texi name in the comment.
@
text
@d583 1
d631 1
@


1.9
log
@	Build fixes for DJGPP.

	* signals.c (rl_set_sighandler): Guard access to SIGWINCH.
	* wcwidth.c [__GO32__]: Include wctype.h before wchar.h.
@
text
@d3 1
a3 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
d5 2
a6 2
   This file is part of the GNU Readline Library, a library for
   reading lines of text with interactive input and history editing.
d8 3
a10 3
   The GNU Readline Library is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2, or
d13 3
a15 3
   The GNU Readline Library is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
d18 4
a21 4
   The GNU General Public License is often shipped with GNU software, and
   is generally kept in a file called COPYING or LICENSE.  If you do not
   have a copy of the license, write to the Free Software Foundation,
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
a42 1
#if defined (HANDLE_SIGNALS)
d49 2
d84 3
d100 12
d131 11
d146 15
d187 1
d203 1
d207 1
d299 1
a299 1
#if defined (SIGWINCH)
d301 1
a301 1
#else
d303 1
a303 1
#endif
d340 30
d373 5
d411 4
d481 1
a482 1
  rl_clear_pending_input ();
d515 157
@


1.8
log
@Readline 5.1 import for HEAD.
@
text
@d254 1
d256 3
@


1.7
log
@touched all sources to ease import of readline-5.1
@
text
@d3 1
a3 1
/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
d76 4
d92 2
a96 1
#ifdef SIGWINCH
a97 1
#endif
d134 5
a138 5
  if (sig == SIGINT 
#ifdef SIGALRM
      || sig == SIGALRM
#endif
                       )
d148 1
d154 1
a154 1
#ifdef SIGALRM
d157 1
a157 2
    case SIGTERM:
#ifdef SIGQUIT
d175 1
a175 4
      /* If we have the POSIX kill function, use it; otherwise, fall
	 back to the ISO C raise function.  (Windows is an example of
	 a platform that has raise, but not kill.)  */
#ifdef HAVE_KILL
d178 1
a178 1
      raise (sig);
d254 1
a254 1
  act.sa_flags = 0;	/* XXX - should we set SA_RESTART for SIGWINCH? */
d296 1
a296 1
#ifdef SIGQUIT
d300 1
a300 1
#ifdef SIGALRM
d351 1
a351 1
#ifdef SIGQUIT
d354 1
a354 1
#ifdef SIGALRM
d391 2
a392 1
  (*rl_deprep_term_function) ();
d401 2
a402 1
  (*rl_prep_term_function) (_rl_meta_flag);
d423 1
a423 1
  _rl_init_argument ();
@


1.7.2.1
log
@Import readline 5.1 on the branch.
@
text
@d3 1
a3 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
a75 4
#ifndef SA_RESTART
#  define SA_RESTART 0
#endif

a87 2
#else
int rl_catch_sigwinch = 0;	/* for the readline state struct in readline.c */
d91 1
d93 1
d130 5
a134 5
#  if defined (SIGALRM)
  if (sig == SIGINT || sig == SIGALRM)
#  else
  if (sig == SIGINT)
#  endif
a143 1
    case SIGTERM:
d149 1
a149 1
#if defined (SIGALRM)
d152 2
a153 1
#if defined (SIGQUIT)
d171 4
a174 1
#if defined (HAVE_KILL)
d177 1
a177 1
      raise (sig);		/* assume we have raise */
d253 1
a253 1
  act.sa_flags = (sig == SIGWINCH) ? SA_RESTART : 0;
d295 1
a295 1
#if defined (SIGQUIT)
d299 1
a299 1
#if defined (SIGALRM)
d350 1
a350 1
#if defined (SIGQUIT)
d353 1
a353 1
#if defined (SIGALRM)
d390 1
a390 2
  if (rl_deprep_term_function)
    (*rl_deprep_term_function) ();
d399 1
a399 2
  if (rl_prep_term_function)
    (*rl_prep_term_function) (_rl_meta_flag);
d420 1
a420 1
  _rl_reset_argument ();
@


1.6
log
@	* readline/aclocal.m4: Use AC_TRY_LINK to check for mbstate_t.
	* readline/complete.c (pwd.h): Guard with HAVE_PWD_H.
	(getpwent): Guard with HAVE_GETPWENT.
	(rl_username_completion_function): Guard use of getpwent.
	(endpwent): Likewise.
	* readline/config.h.in (HAVE_FCNTL): New macro.
	(HAVE_GETPWENT): Likewise.
	(HAVE_GETPWNAM): Likewise.
	(HAVE_GETPWUID): Likewise.
	(HAVE_KILL): Likewise.
	(HAVE_PWD_H): Likewise.
	* readline/configure: Regenerated.
	* readline/configure.in: Handle MinGW when cross compiling.  Check for
	getpwnam, getpwent, getpwuid, kill, and pwd.h.
	* readline/display.c (rl_clear_screen): Treat Windows like DOS.
	(insert_some_chars): Likewise.
	(delete_chars): Likewise.
	* readline/shell.c (pwd.h): Guard with HAVE_PWD_H.
	(getpwuid): Guard with HAVE_GETPWUID.
	(sh_unset_nodelay_mode): Guard use of fnctl with HAVE_FNCTL_H.
	* readline/signals.c (rl_signal_handler): Don't use SIGALRM or
	SIGQUIT if not defined.  Use "raise" if "kill" is not available.
	(rl_set_signals): Don't set handlers for SIGQUIT or SIGALRM if
	they are not defined.
	(rl_clear_signals): Likewise.
	* readline/tilde.c (pwd.h): Guard with HAVE_PWD_H.
	(getpwuid): Guard declaration with HAVE_GETPWUID.
	(getpwnam): Guard declaration with HAVE_GETPWNAM.
	(tilde_expand_word): Guard use of getpwnam with HAVE_GETPWNAM.
@
text
@@


1.5
log
@Import of readline 4.3.
Non-readline modified files:

src/gdb/ChangeLog src/gdb/defs.h src/gdb/cli/cli-cmds.c
src/gdb/cli/cli-setshow.c src/gdb/tui/ChangeLog
src/gdb/tui/tuiWin.c

In readline directory:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@d130 5
a134 1
  if (sig == SIGINT || sig == SIGALRM)
d149 1
d151 1
d153 1
d155 1
d171 4
d176 3
d295 1
d297 1
d299 1
d311 1
d350 1
d352 2
d355 1
@


1.5.60.1
log
@	* readline/Makefile.in (RLTTYOBJ): New variable.
	(OBJECTS): Use RLTTYOBJ.
	* readline/aclocal.m4: Use AC_RTY_LINK to check for mbstate_t.
	* readline/complete.c (pwd.h): Guard with HAVE_PWD_H.
	(getpwent): Guard with HAVE_GETPWENT.
	(rl_username_completion_function): Guard use of getpwent.
	(endpwent): Likewise.
	* readline/config.h.in (HAVE_FCNTL): New macro.
	(HAVE_GETPWENT): Likewise.
	(HAVE_GETPWNAM): Likewise.
	(HAVE_GETPWUID): Likewise.
	(HAVE_PWD_H): Likewise.
	* readline/configure: Regenerated.
	* readline/configure.in: Handle MinGW when cross compiling.  Check for
	getpwnam, getpwent, getpwuid, and pwd.h.  Set RLTTYOBJ.
	* readline/display.c (rl_clear_screen): Treat Windows like DOS.
	(insert_some_chars): Likewise.
	(delete_chars): Likewise.
	* readline/rldefs.h (NEW_TTY_DRIVER): Do not define for Windows.
	* readline/rlnotty.c: New file.
	* readline/shell.c (pwd.h): Guard with HAVE_PWD_H.
	(getpwuid): Guard with HAVE_GETPWUID.
	(sh_unset_nodelay_mode): Guard use of fnctl with HAVE_FNCTL_H.
	* readline/signals.c (rl_signal_handler): Don't use SIGALRM or
	SIGQUIT if not defined.  Use "raise" rather than "kill".
	(rl_set_signals): Don't set handlers for SIGQUIT or SIGALRM if
	they are not defined.
	(rl_clear_signals): Likewise.
	* readline/tilde.c (pwd.h): Guard with HAVE_PWD_H.
	(getpwuid): Guard declaration with HAVE_GETPWUID.
	(getpwnam): Guard declaration with HAVE_GETPWNAM.
	(tilde_expand_word): Guard use of getpwnam with HAVE_GETPWNAM.
@
text
@d130 1
a130 5
  if (sig == SIGINT 
#ifdef SIGALRM
      || sig == SIGALRM
#endif
                       )
a144 1
#ifdef SIGALRM
a145 1
#endif
a146 1
#ifdef SIGQUIT
a147 1
#endif
d163 1
a163 1
      raise (sig);
a279 1
#ifdef SIGQUIT
a280 1
#endif
a281 1
#ifdef SIGALRM
a292 1
#endif /* SIGALRM */
a330 1
#ifdef SIGQUIT
a331 2
#endif
#ifdef SIGALRM
a332 1
#endif
@


1.4
log
@readline:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Locally modified files: Makefile.in, configure.in, configure
        (regenerated), config.h.in (regenerated), readline.h, rltty.c,
 	shell.c signals.c.

        Locally added files: acconfig.h, config/*, config.h.bot,
        cross-build/*, doc/inc-hit.texinfo.

        New files: USAGE, rlprivate.h, rlshell.h, xmalloc.h.
examples:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        New files: excallback.c, rlfe.c.
doc:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Regenerated inc-hist.texinfo as copy of hsuser.texinfo, for
        inclusion in the gdb manual.

        New file: rluserman.texinfo
@
text
@d64 1
a64 1
/* This typedef is equivalant to the one for Function; it allows us
d76 2
a77 1
static SigHandler *rl_set_sighandler __P((int, SigHandler *, sighandler_cxt *));
d125 2
d177 1
d198 1
d206 1
d238 1
a238 1
  act.sa_flags = 0;
d369 1
a369 1
  rl_pending_input = 0;
d389 1
a389 1
  free_undo_list ();
@


1.4.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d64 1
a64 1
/* This typedef is equivalent to the one for Function; it allows us
d76 1
a76 2
static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
a123 2
  RL_SETSTATE(RL_STATE_SIGHANDLER);

a173 1
  RL_UNSETSTATE(RL_STATE_SIGHANDLER);
a193 1
  RL_SETSTATE(RL_STATE_SIGHANDLER);
a200 1
  RL_UNSETSTATE(RL_STATE_SIGHANDLER);
d232 1
a232 1
  act.sa_flags = 0;	/* XXX - should we set SA_RESTART for SIGWINCH? */
d363 1
a363 1
  rl_clear_pending_input ();
d383 1
a383 1
  rl_free_undo_list ();
@


1.4.22.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d64 1
a64 1
/* This typedef is equivalent to the one for Function; it allows us
d76 1
a76 2
static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
a123 2
  RL_SETSTATE(RL_STATE_SIGHANDLER);

a173 1
  RL_UNSETSTATE(RL_STATE_SIGHANDLER);
a193 1
  RL_SETSTATE(RL_STATE_SIGHANDLER);
a200 1
  RL_UNSETSTATE(RL_STATE_SIGHANDLER);
d232 1
a232 1
  act.sa_flags = 0;	/* XXX - should we set SA_RESTART for SIGWINCH? */
d363 1
a363 1
  rl_clear_pending_input ();
d383 1
a383 1
  rl_free_undo_list ();
@


1.4.16.1
log
@2002-08-24  Elena Zannoni  <ezannoni@@redhat.com>

        Import of readline 4.3:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@d64 1
a64 1
/* This typedef is equivalent to the one for Function; it allows us
d76 1
a76 2
static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
a123 2
  RL_SETSTATE(RL_STATE_SIGHANDLER);

a173 1
  RL_UNSETSTATE(RL_STATE_SIGHANDLER);
a193 1
  RL_SETSTATE(RL_STATE_SIGHANDLER);
a200 1
  RL_UNSETSTATE(RL_STATE_SIGHANDLER);
d232 1
a232 1
  act.sa_flags = 0;	/* XXX - should we set SA_RESTART for SIGWINCH? */
d363 1
a363 1
  rl_clear_pending_input ();
d383 1
a383 1
  rl_free_undo_list ();
@


1.3
log
@Dummy commit before importof 4.1 version
@
text
@d10 1
a10 1
   as published by the Free Software Foundation; either version 1, or
d21 1
a21 1
   675 Mass Ave, Cambridge, MA 02139, USA. */
a42 4
#if defined (__GO32__) && !defined(__DJGPP__)
#  undef HANDLE_SIGNALS
#endif /* __GO32__  && !__DJGPP__ */

d48 2
d68 7
a74 11
extern int readline_echoing_p;
extern int rl_pending_input;
extern int _rl_meta_flag;

extern void free_undo_list ();
extern void _rl_get_screen_size ();
extern void _rl_redisplay_after_sigwinch ();
extern void _rl_clean_up_for_exit ();
extern void _rl_kill_kbd_macro ();
extern void _rl_init_argument ();
extern void rl_deprep_terminal (), rl_prep_terminal ();
d76 1
a76 1
static SigHandler *rl_set_sighandler ();
a99 8
#if defined (HAVE_POSIX_SIGNALS)
typedef struct sigaction sighandler_cxt;
#  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
#else
typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags; } sighandler_cxt;
#  define sigemptyset(m)
#endif /* !HAVE_POSIX_SIGNALS */

d156 4
d227 1
d235 1
a235 1
  sigaction (sig, &act, ohandler);
d237 1
a237 1
  ohandler->sa_handler = (SigHandler *)signal (sig, handler);
d239 7
@


1.2
log
@[__GO32__]: Don't undef HANDLE_SIGNALS for DJGPP v2.x.
Don't declare sigwinch_set_flag if SIGWINCH is undefined.
@
text
@@


1.1
log
@Initial revision
@
text
@d43 1
a43 1
#if defined (__GO32__)
d45 1
a45 1
#endif /* __GO32__ */
a51 12
extern int readline_echoing_p;
extern int rl_pending_input;
extern int _rl_meta_flag;

extern void free_undo_list ();
extern void _rl_get_screen_size ();
extern void _rl_redisplay_after_sigwinch ();
extern void _rl_clean_up_for_exit ();
extern void _rl_kill_kbd_macro ();
extern void _rl_init_argument ();
extern void rl_deprep_terminal (), rl_prep_terminal ();

d70 12
d84 16
a105 8
/* If we're not being compiled as part of bash, initialize handlers for
   and catch the job control signals (SIGTTIN, SIGTTOU, SIGTSTP) and
   SIGTERM. */
#if !defined (SHELL)
#  define HANDLE_JOB_SIGNALS
#  define HANDLE_SIGTERM
#endif /* !SHELL */

d110 1
a110 1
typedef struct { SigHandler *sa_handler; } sighandler_cxt;
d114 2
a115 3
static sighandler_cxt old_int, old_alrm;

#if defined (HANDLE_JOB_SIGNALS)
a116 4
#endif /* HANDLE_JOB_SIGNALS */

#if defined (HANDLE_SIGTERM)
static sighandler_cxt old_term;
a117 1

d148 2
a149 12
      {
	register HIST_ENTRY *entry;

	free_undo_list ();

	entry = current_history ();
	if (entry)
	  entry->data = (char *)NULL;
      }
      _rl_kill_kbd_macro ();
      rl_clear_message ();
      _rl_init_argument ();
d158 2
a159 4
      _rl_clean_up_for_exit ();
      (*rl_deprep_term_function) ();
      rl_clear_signals ();
      rl_pending_input = 0;
d181 1
a181 2
      (*rl_prep_term_function) (_rl_meta_flag);
      rl_set_signals ();
d189 1
a189 1
rl_handle_sigwinch (sig)
d201 1
a201 1
  rl_set_sighandler (SIGWINCH, rl_handle_sigwinch, &dummy_winch);
d204 1
a204 5
  if (readline_echoing_p)
    {
      _rl_get_screen_size (fileno (rl_instream), 1);
      _rl_redisplay_after_sigwinch ();
    }
d251 5
a255 2
int
rl_set_signals ()
a259 1
#if defined (HAVE_POSIX_SIGNALS)
d261 4
a264 1
#endif
d266 5
a270 3
  oh = rl_set_sighandler (SIGINT, rl_signal_handler, &old_int);
  if (oh == (SigHandler *)SIG_IGN)
    rl_sigaction (SIGINT, &old_int, &dummy);
d272 9
a280 3
  oh = rl_set_sighandler (SIGALRM, rl_signal_handler, &old_alrm);
  if (oh == (SigHandler *)SIG_IGN)
    rl_sigaction (SIGALRM, &old_alrm, &dummy);
d282 6
a287 6
  /* If the application using readline has already installed a signal
     handler with SA_RESTART, SIGALRM will cause reads to be restarted
     automatically, so readline should just get out of the way.  Since
     we tested for SIG_IGN above, we can just test for SIG_DFL here. */
  if (oh != (SigHandler *)SIG_DFL && (old_alrm.sa_flags & SA_RESTART))
    rl_sigaction (SIGALRM, &old_alrm, &dummy);
a289 2
#if defined (HANDLE_JOB_SIGNALS)

d291 1
a291 5
  oh = rl_set_sighandler (SIGTSTP, rl_signal_handler, &old_tstp);
  if (oh == (SigHandler *)SIG_IGN)
    rl_sigaction (SIGTSTP, &old_tstp, &dummy);
#else
  oh = (SigHandler *)NULL;
d295 1
a295 8
  rl_set_sighandler (SIGTTOU, rl_signal_handler, &old_ttou);
  rl_set_sighandler (SIGTTIN, rl_signal_handler, &old_ttin);

  if (oh == (SigHandler *)SIG_IGN)
    {
      rl_set_sighandler (SIGTTOU, SIG_IGN, &dummy);
      rl_set_sighandler (SIGTTIN, SIG_IGN, &dummy);
    }
d298 3
a300 1
#endif /* HANDLE_JOB_SIGNALS */
d302 2
a303 4
#if defined (HANDLE_SIGTERM)
  /* Handle SIGTERM if we're not being compiled as part of bash. */
  rl_set_sighandler (SIGTERM, rl_signal_handler, &old_term);
#endif /* HANDLE_SIGTERM */
d306 5
a310 1
  rl_set_sighandler (SIGWINCH, rl_handle_sigwinch, &old_winch);
d321 3
a323 6
#if defined (HAVE_POSIX_SIGNALS)
  sigemptyset (&dummy.sa_mask);
#endif

  rl_sigaction (SIGINT, &old_int, &dummy);
  rl_sigaction (SIGALRM, &old_alrm, &dummy);
d325 4
a328 1
#if defined (HANDLE_JOB_SIGNALS)
d331 2
a332 2
  rl_sigaction (SIGTSTP, &old_tstp, &dummy);
#endif
d335 1
a335 2
  rl_sigaction (SIGTTOU, &old_ttou, &dummy);
  rl_sigaction (SIGTTIN, &old_ttin, &dummy);
d338 3
a340 1
#endif /* HANDLE_JOB_SIGNALS */
d342 2
a343 3
#if defined (HANDLE_SIGTERM)
  rl_sigaction (SIGTERM, &old_term, &dummy);
#endif /* HANDLE_SIGTERM */
d346 6
a351 2
  sigemptyset (&dummy.sa_mask);
  rl_sigaction (SIGWINCH, &old_winch, &dummy);
d356 40
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-08-02 snapshot
@
text
@d52 12
a81 12
extern int readline_echoing_p;
extern int rl_pending_input;
extern int _rl_meta_flag;

extern void free_undo_list ();
extern void _rl_get_screen_size ();
extern void _rl_redisplay_after_sigwinch ();
extern void _rl_clean_up_for_exit ();
extern void _rl_kill_kbd_macro ();
extern void _rl_init_argument ();
extern void rl_deprep_terminal (), rl_prep_terminal ();

a83 14
/* Exported variables for use by applications. */

/* If non-zero, readline will install its own signal handlers for
   SIGINT, SIGTERM, SIGQUIT, SIGALRM, SIGTSTP, SIGTTIN, and SIGTTOU. */
int rl_catch_signals = 1;

/* If non-zero, readline will install a signal handler for SIGWINCH. */
#ifdef SIGWINCH
int rl_catch_sigwinch = 1;
#endif

static int signals_set_flag;
static int sigwinch_set_flag;

d90 8
d102 1
a102 1
typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags; } sighandler_cxt;
d106 3
a108 2
static sighandler_cxt old_int, old_term, old_alrm, old_quit;
#if defined (SIGTSTP)
d110 4
d115 1
d146 12
a157 2
      rl_free_line_state ();
      /* FALLTHROUGH */
d166 4
a169 2
    case SIGQUIT:
      rl_cleanup_after_signal ();
d191 2
a192 1
      rl_reset_after_signal ();
d200 1
a200 1
rl_sigwinch_handler (sig)
d212 1
a212 1
  rl_set_sighandler (SIGWINCH, rl_sigwinch_handler, &dummy_winch);
d215 5
a219 1
  rl_resize_terminal ();
d266 2
a267 5
static void
rl_maybe_set_sighandler (sig, handler, ohandler)
     int sig;
     SigHandler *handler;
     sighandler_cxt *ohandler;
d272 1
d274 3
a276 1
  oh = rl_set_sighandler (sig, handler, ohandler);
d278 1
a278 2
    rl_sigaction (sig, ohandler, &dummy);
}
d280 3
a282 15
int
rl_set_signals ()
{
  sighandler_cxt dummy;
  SigHandler *oh;

  if (rl_catch_signals && signals_set_flag == 0)
    {
      rl_maybe_set_sighandler (SIGINT, rl_signal_handler, &old_int);
      rl_maybe_set_sighandler (SIGTERM, rl_signal_handler, &old_term);
      rl_maybe_set_sighandler (SIGQUIT, rl_signal_handler, &old_quit);

      oh = rl_set_sighandler (SIGALRM, rl_signal_handler, &old_alrm);
      if (oh == (SigHandler *)SIG_IGN)
	rl_sigaction (SIGALRM, &old_alrm, &dummy);
d284 6
a289 6
      /* If the application using readline has already installed a signal
	 handler with SA_RESTART, SIGALRM will cause reads to be restarted
	 automatically, so readline should just get out of the way.  Since
	 we tested for SIG_IGN above, we can just test for SIG_DFL here. */
      if (oh != (SigHandler *)SIG_DFL && (old_alrm.sa_flags & SA_RESTART))
	rl_sigaction (SIGALRM, &old_alrm, &dummy);
d292 2
d295 5
a299 1
      rl_maybe_set_sighandler (SIGTSTP, rl_signal_handler, &old_tstp);
d303 8
a310 1
      rl_maybe_set_sighandler (SIGTTOU, rl_signal_handler, &old_ttou);
d313 1
a313 3
#if defined (SIGTTIN)
      rl_maybe_set_sighandler (SIGTTIN, rl_signal_handler, &old_ttin);
#endif /* SIGTTIN */
d315 4
a318 2
      signals_set_flag = 1;
    }
d321 1
a321 5
  if (rl_catch_sigwinch && sigwinch_set_flag == 0)
    {
      rl_maybe_set_sighandler (SIGWINCH, rl_sigwinch_handler, &old_winch);
      sigwinch_set_flag = 1;
    }
d332 6
a337 3
  if (rl_catch_signals && signals_set_flag == 1)
    {
      sigemptyset (&dummy.sa_mask);
d339 1
a339 4
      rl_sigaction (SIGINT, &old_int, &dummy);
      rl_sigaction (SIGTERM, &old_term, &dummy);
      rl_sigaction (SIGQUIT, &old_quit, &dummy);
      rl_sigaction (SIGALRM, &old_alrm, &dummy);
d342 2
a343 2
      rl_sigaction (SIGTSTP, &old_tstp, &dummy);
#endif /* SIGTSTP */
d346 2
a347 1
      rl_sigaction (SIGTTOU, &old_ttou, &dummy);
d350 1
a350 3
#if defined (SIGTTIN)
      rl_sigaction (SIGTTIN, &old_ttin, &dummy);
#endif /* SIGTTIN */
d352 3
a354 2
      signals_set_flag = 0;
    }
d357 2
a358 6
  if (rl_catch_sigwinch && sigwinch_set_flag == 1)
    {
      sigemptyset (&dummy.sa_mask);
      rl_sigaction (SIGWINCH, &old_winch, &dummy);
      sigwinch_set_flag = 0;
    }
a362 40

/* Clean up the terminal and readline state after catching a signal, before
   resending it to the calling application. */
void
rl_cleanup_after_signal ()
{
  _rl_clean_up_for_exit ();
  (*rl_deprep_term_function) ();
  rl_clear_signals ();
  rl_pending_input = 0;
}

/* Reset the terminal and readline state after a signal handler returns. */
void
rl_reset_after_signal ()
{
  (*rl_prep_term_function) (_rl_meta_flag);
  rl_set_signals ();
}

/* Free up the readline variable line state for the current line (undo list,
   any partial history entry, any keyboard macros in progress, and any
   numeric arguments in process) after catching a signal, before calling
   rl_cleanup_after_signal(). */ 
void
rl_free_line_state ()
{
  register HIST_ENTRY *entry;

  free_undo_list ();

  entry = current_history ();
  if (entry)
    entry->data = (char *)NULL;

  _rl_kill_kbd_macro ();
  rl_clear_message ();
  _rl_init_argument ();
}

@


1.1.1.3
log
@Import of readline 4.1
@
text
@d10 1
a10 1
   as published by the Free Software Foundation; either version 2, or
d21 1
a21 1
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
d43 4
a51 2
#include "rlprivate.h"

d70 11
a80 7
#if defined (HAVE_POSIX_SIGNALS)
typedef struct sigaction sighandler_cxt;
#  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
#else
typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags; } sighandler_cxt;
#  define sigemptyset(m)
#endif /* !HAVE_POSIX_SIGNALS */
d82 1
a82 1
static SigHandler *rl_set_sighandler __P((int, SigHandler *, sighandler_cxt *));
d104 8
a167 4
#if defined (__EMX__)
      signal (sig, SIG_ACK);
#endif

a234 1
  sighandler_cxt old_handler;
d242 1
a242 1
  sigaction (sig, &act, &old_handler);
d244 1
a244 1
  old_handler.sa_handler = (SigHandler *)signal (sig, handler);
a245 7

  /* XXX -- assume we have memcpy */
  /* If rl_set_signals is called twice in a row, don't set the old handler to
     rl_signal_handler, because that would cause infinite recursion. */
  if (handler != rl_signal_handler || old_handler.sa_handler != rl_signal_handler)
    memcpy (ohandler, &old_handler, sizeof (sighandler_cxt));

@


1.1.1.4
log
@import of readline-4.3
@
text
@d64 1
a64 1
/* This typedef is equivalent to the one for Function; it allows us
d76 1
a76 2
static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
a121 2
  RL_SETSTATE(RL_STATE_SIGHANDLER);

a171 1
  RL_UNSETSTATE(RL_STATE_SIGHANDLER);
a191 1
  RL_SETSTATE(RL_STATE_SIGHANDLER);
a198 1
  RL_UNSETSTATE(RL_STATE_SIGHANDLER);
d230 1
a230 1
  act.sa_flags = 0;	/* XXX - should we set SA_RESTART for SIGWINCH? */
d361 1
a361 1
  rl_clear_pending_input ();
d381 1
a381 1
  rl_free_undo_list ();
@


1.1.1.5
log
@import of readlilne 5.1
@
text
@d3 1
a3 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
a75 4
#ifndef SA_RESTART
#  define SA_RESTART 0
#endif

a87 2
#else
int rl_catch_sigwinch = 0;	/* for the readline state struct in readline.c */
a127 1
#  if defined (SIGALRM)
a128 3
#  else
  if (sig == SIGINT)
#  endif
a137 1
    case SIGTERM:
a142 1
#if defined (SIGALRM)
d144 1
a144 2
#endif
#if defined (SIGQUIT)
a145 1
#endif
a160 1
#if defined (HAVE_KILL)
a161 3
#else
      raise (sig);		/* assume we have raise */
#endif
d236 1
a236 1
  act.sa_flags = (sig == SIGWINCH) ? SA_RESTART : 0;
a277 1
#if defined (SIGQUIT)
a278 1
#endif
a279 1
#if defined (SIGALRM)
a290 1
#endif /* SIGALRM */
a328 1
#if defined (SIGQUIT)
a329 2
#endif
#if defined (SIGALRM)
a330 1
#endif
d365 1
a365 2
  if (rl_deprep_term_function)
    (*rl_deprep_term_function) ();
d374 1
a374 2
  if (rl_prep_term_function)
    (*rl_prep_term_function) (_rl_meta_flag);
d395 1
a395 1
  _rl_reset_argument ();
@


