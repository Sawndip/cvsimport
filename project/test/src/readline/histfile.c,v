head	1.9;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.9
	gdb_7_6-2013-04-26-release:1.9
	gdb_7_6-branch:1.9.0.6
	gdb_7_6-2013-03-12-branchpoint:1.9
	gdb_7_5_1-2012-11-29-release:1.9
	gdb_7_5-2012-08-17-release:1.9
	gdb_7_5-branch:1.9.0.4
	gdb_7_5-2012-07-18-branchpoint:1.9
	gdb_7_4_1-2012-04-26-release:1.9
	gdb_7_4-2012-01-24-release:1.9
	gdb_7_4-branch:1.9.0.2
	gdb_7_4-2011-12-13-branchpoint:1.9
	gdb_7_3_1-2011-09-04-release:1.8
	gdb_7_3-2011-07-26-release:1.8
	gdb_7_3-branch:1.8.0.36
	gdb_7_3-2011-04-01-branchpoint:1.8
	gdb_7_2-2010-09-02-release:1.8
	gdb_7_2-branch:1.8.0.34
	gdb_7_2-2010-07-07-branchpoint:1.8
	gdb_7_1-2010-03-18-release:1.8
	gdb_7_1-branch:1.8.0.32
	gdb_7_1-2010-02-18-branchpoint:1.8
	gdb_7_0_1-2009-12-22-release:1.8
	gdb_7_0-2009-10-06-release:1.8
	gdb_7_0-branch:1.8.0.30
	gdb_7_0-2009-09-16-branchpoint:1.8
	arc-sim-20090309:1.8
	msnyder-checkpoint-072509-branch:1.8.0.28
	msnyder-checkpoint-072509-branchpoint:1.8
	arc-insight_6_8-branch:1.8.0.26
	arc-insight_6_8-branchpoint:1.8
	insight_6_8-branch:1.8.0.24
	insight_6_8-branchpoint:1.8
	reverse-20081226-branch:1.8.0.22
	reverse-20081226-branchpoint:1.8
	multiprocess-20081120-branch:1.8.0.20
	multiprocess-20081120-branchpoint:1.8
	reverse-20080930-branch:1.8.0.18
	reverse-20080930-branchpoint:1.8
	reverse-20080717-branch:1.8.0.16
	reverse-20080717-branchpoint:1.8
	msnyder-reverse-20080609-branch:1.8.0.14
	msnyder-reverse-20080609-branchpoint:1.8
	drow-reverse-20070409-branch:1.8.0.12
	drow-reverse-20070409-branchpoint:1.8
	gdb_6_8-2008-03-27-release:1.8
	gdb_6_8-branch:1.8.0.10
	gdb_6_8-2008-02-26-branchpoint:1.8
	gdb_6_7_1-2007-10-29-release:1.8
	gdb_6_7-2007-10-10-release:1.8
	gdb_6_7-branch:1.8.0.8
	gdb_6_7-2007-09-07-branchpoint:1.8
	insight_6_6-20070208-release:1.8
	gdb_6_6-2006-12-18-release:1.8
	gdb_6_6-branch:1.8.0.6
	gdb_6_6-2006-11-15-branchpoint:1.8
	insight_6_5-20061003-release:1.8
	gdb-csl-symbian-6_4_50_20060226-12:1.5
	gdb-csl-sourcerygxx-3_4_4-25:1.5
	nickrob-async-20060828-mergepoint:1.8
	gdb-csl-symbian-6_4_50_20060226-11:1.5
	gdb-csl-sourcerygxx-4_1-17:1.5
	gdb-csl-20060226-branch-local-2:1.5
	gdb-csl-sourcerygxx-4_1-14:1.5
	gdb-csl-sourcerygxx-4_1-13:1.5
	gdb-csl-sourcerygxx-4_1-12:1.5
	gdb-csl-sourcerygxx-3_4_4-21:1.5
	gdb_6_5-20060621-release:1.8
	gdb-csl-sourcerygxx-4_1-9:1.5
	gdb-csl-sourcerygxx-4_1-8:1.5
	gdb-csl-sourcerygxx-4_1-7:1.5
	gdb-csl-arm-2006q1-6:1.5
	gdb-csl-sourcerygxx-4_1-6:1.5
	gdb-csl-symbian-6_4_50_20060226-10:1.5
	gdb-csl-symbian-6_4_50_20060226-9:1.5
	gdb-csl-symbian-6_4_50_20060226-8:1.5
	gdb-csl-coldfire-4_1-11:1.5
	gdb-csl-sourcerygxx-3_4_4-19:1.5
	gdb-csl-coldfire-4_1-10:1.5
	gdb_6_5-branch:1.8.0.4
	gdb_6_5-2006-05-14-branchpoint:1.8
	gdb-csl-sourcerygxx-4_1-5:1.5
	nickrob-async-20060513-branch:1.8.0.2
	nickrob-async-20060513-branchpoint:1.8
	gdb-csl-sourcerygxx-4_1-4:1.5
	msnyder-reverse-20060502-branch:1.7.0.4
	msnyder-reverse-20060502-branchpoint:1.7
	gdb-csl-morpho-4_1-4:1.5
	gdb-csl-sourcerygxx-3_4_4-17:1.5
	readline_5_1-import-branch:1.7.0.2
	readline_5_1-import-branchpoint:1.7
	readline-pre-51-import:1.7
	readline_5_1:1.1.1.5
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.5
	gdb-csl-symbian-20060226-branch:1.5.0.76
	gdb-csl-symbian-20060226-branchpoint:1.5
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.5
	msnyder-reverse-20060331-branch:1.6.0.2
	msnyder-reverse-20060331-branchpoint:1.6
	gdb-csl-available-20060303-branch:1.5.0.74
	gdb-csl-available-20060303-branchpoint:1.5
	gdb-csl-20060226-branch:1.5.0.72
	gdb-csl-20060226-branchpoint:1.5
	gdb_6_4-20051202-release:1.5
	msnyder-fork-checkpoint-branch:1.5.0.70
	msnyder-fork-checkpoint-branchpoint:1.5
	gdb-csl-gxxpro-6_3-branch:1.5.0.68
	gdb-csl-gxxpro-6_3-branchpoint:1.5
	gdb_6_4-branch:1.5.0.66
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb-csl-arm-20051020-branch:1.5.0.64
	gdb-csl-arm-20051020-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.62
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb-csl-arm-20050325-2005-q1b:1.5
	gdb-csl-arm-20050325-2005-q1a:1.5
	csl-arm-20050325-branch:1.5.0.60
	csl-arm-20050325-branchpoint:1.5
	gdb_6_3-20041109-release:1.5
	gdb_6_3-branch:1.5.0.56
	gdb_6_3-20041019-branchpoint:1.5
	drow_intercu-merge-20040921:1.5
	drow_intercu-merge-20040915:1.5
	jimb-gdb_6_2-e500-branch:1.5.0.58
	jimb-gdb_6_2-e500-branchpoint:1.5
	gdb_6_2-20040730-release:1.5
	gdb_6_2-branch:1.5.0.54
	gdb_6_2-2004-07-10-gmt-branchpoint:1.5
	gdb_6_1_1-20040616-release:1.5
	gdb_6_1-2004-04-05-release:1.5
	drow_intercu-merge-20040402:1.5
	drow_intercu-merge-20040327:1.5
	ezannoni_pie-20040323-branch:1.5.0.52
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.50
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow_intercu-20040221-branch:1.5.0.46
	drow_intercu-20040221-branchpoint:1.5
	cagney_bfdfile-20040213-branch:1.5.0.44
	cagney_bfdfile-20040213-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	cagney_bigcore-20040122-branch:1.5.0.42
	cagney_bigcore-20040122-branchpoint:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	kettenis_sparc-20030918-branch:1.5.0.40
	kettenis_sparc-20030918-branchpoint:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.38
	cagney_x86i386-20030821-branch:1.5.0.36
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.34
	gdb_6_0-2003-06-23-branchpoint:1.5
	jimb-ppc64-linux-20030613-branch:1.5.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.30
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.28
	cagney_writestrings-20030508-branchpoint:1.5
	jimb-ppc64-linux-20030528-branch:1.5.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.24
	cagney_fileio-20030521-branchpoint:1.5
	kettenis_i386newframe-20030517-mergepoint:1.5
	jimb-ppc64-linux-20030509-branch:1.5.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.5
	kettenis_i386newframe-20030504-mergepoint:1.5
	carlton_dictionary-20030430-merge:1.5
	kettenis_i386newframe-20030419-branch:1.5.0.20
	kettenis_i386newframe-20030419-branchpoint:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	kettenis_i386newframe-20030406-branch:1.5.0.18
	kettenis_i386newframe-20030406-branchpoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.16
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.14
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.12
	cagney_lazyid-20030317-branchpoint:1.5
	kettenis-i386newframe-20030316-mergepoint:1.5
	offbyone-20030313-branch:1.5.0.10
	offbyone-20030313-branchpoint:1.5
	kettenis-i386newframe-20030308-branch:1.5.0.8
	kettenis-i386newframe-20030308-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.6
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.4
	interps-20030202-branchpoint:1.5
	cagney-unwind-20030108-branch:1.5.0.2
	cagney-unwind-20030108-branchpoint:1.5
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.4
	readline-pre-43-import:1.4
	carlton_dictionary-20021115-merge:1.4
	kseitz_interps-20021105-merge:1.4
	kseitz_interps-20021103-merge:1.4
	drow-cplus-merge-20021020:1.4
	drow-cplus-merge-20021025:1.4
	carlton_dictionary-20021025-merge:1.4
	carlton_dictionary-20021011-merge:1.4
	drow-cplus-branch:1.4.0.24
	drow-cplus-branchpoint:1.4
	kseitz_interps-20020930-merge:1.4
	carlton_dictionary-20020927-merge:1.4
	carlton_dictionary-branch:1.4.0.22
	carlton_dictionary-20020920-branchpoint:1.4
	gdb_5_3-branch:1.4.0.20
	gdb_5_3-2002-09-04-branchpoint:1.4
	kseitz_interps-20020829-merge:1.4
	cagney_sysregs-20020825-branch:1.4.0.18
	cagney_sysregs-20020825-branchpoint:1.4
	readline_4_3-import-branch:1.4.0.16
	readline_4_3-import-branchpoint:1.4
	readline_4_3:1.1.1.4
	gdb_5_2_1-2002-07-23-release:1.4
	kseitz_interps-20020528-branch:1.4.0.14
	kseitz_interps-20020528-branchpoint:1.4
	cagney_regbuf-20020515-branch:1.4.0.12
	cagney_regbuf-20020515-branchpoint:1.4
	jimb-macro-020506-branch:1.4.0.10
	jimb-macro-020506-branchpoint:1.4
	gdb_5_2-2002-04-29-release:1.4
	gdb_5_2-branch:1.4.0.8
	gdb_5_2-2002-03-03-branchpoint:1.4
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	insight-precleanup-2001-01-01:1.4
	readline_4_1:1.1.1.3
	readline_4_0:1.1.1.2
	FSF:1.1.1
	readline-pre-41-import:1.3
	gdb-premipsmulti-2000-06-06-branch:1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.9
date	2011.05.11.23.38.39;	author jkratoch;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.05.18.26.12;	author drow;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.20.20.13.20;	author ezannoni;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2006.03.21.14.58.24;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.08.22.31.37;	author ezannoni;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.09.17.19.56;	author ezannoni;	state Exp;
branches
	1.4.16.1
	1.4.22.1
	1.4.24.1;
next	1.3;

1.3
date	2000.07.07.17.15.45;	author ezannoni;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.15.11.44.17;	author eliz;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.53;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.7.2.1
date	2006.04.24.22.00.25;	author drow;	state Exp;
branches;
next	;

1.4.16.1
date	2002.08.25.23.41.17;	author ezannoni;	state Exp;
branches;
next	;

1.4.22.1
date	2002.12.23.19.39.43;	author carlton;	state Exp;
branches;
next	;

1.4.24.1
date	2003.12.14.20.28.14;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.53;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.08.02.23.47.58;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.07.09.16.21.21;	author ezannoni;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.08.23.22.02.28;	author ezannoni;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.20.20.05.38;	author ezannoni;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Imported readline 6.2, and upstream patch 001.

[patch 0/3] readline-6.2 rebase
http://sourceware.org/ml/gdb-patches/2011-05/msg00003.html
[patch 1/3] readline-6.2: Merge of already posted patches
http://sourceware.org/ml/gdb-patches/2011-05/msg00004.html
	=
	[Bug-readline] [RFC/readline] bind.c, rl_function_dumper, Free allocated
	http://lists.gnu.org/archive/html/bug-readline/2011-03/msg00000.html
	[Bug-readline] [patch] Fix underquotation in readline/examples/rlfe/conf
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00001.html
	[Bug-readline] [patch] Makefile.in htm<->html
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00002.html
	Re: [Bug-readline] [patch] Makefile.in dependency: callback.o: xmalloc.h
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00004.html
	[Bug-readline] [patch] Remove . from the VPATH directive
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00005.html
	Eli Zaretskii's __MSDOS__ / __GO32__ / __MINGW32__ / __DJGPP__ stuff:
	http://sourceware.org/ml/gdb/2011-04/msg00002.html
	Jan Kratochvil's patch for FSF GDB tree local-specific changes:
	http://sourceware.org/ml/gdb/2011-04/msg00006.html
	Preservation of existing ChangeLog.gdb files, their updates.
[patch 2/3] readline-6.2: Workaround "ask" regression
http://sourceware.org/ml/gdb-patches/2011-05/msg00005.html
[patch 3/3] readline-6.2: Revert 5.x compat., apply 6.x compat.
http://sourceware.org/ml/gdb-patches/2011-05/msg00006.html
[patch 4/3] readline-6.2: Substitute inc-hist.texinfo
http://sourceware.org/ml/gdb-patches/2011-05/msg00010.html

readline/
	Workaround gdb.base/completion.exp regression on readline-6.2.
	* complete.c (get_y_or_n): Disable the return on RL_STATE_CALLBACK.

	Imported readline 6.2, and upstream patch 001.
	* configure: Regenerate.

readline/doc/
	* hsuser.texi (Using History Interactively): Disable !BashFeatures
	@@defcodeindex.  Make the `Programming with GNU History' reference
	external.
	* inc-hist.texinfo: Remove.

	Imported readline 6.2, and upstream patch 001.

readline/examples/
	Imported readline 6.2, and upstream patch 001.

readline/examples/rlfe/
	Imported readline 6.2, and upstream patch 001.

gdb/
	* config.in: Regenerate.
	* configure: Regenerate.
	* configure.ac <--with-system-readline> (for readline_echoing_p):
	Remove the test.
	* tui/tui-io.c (tui_old_readline_echoing_p): Rename to ...
	(tui_old_rl_echoing_p): ... here.
	(tui_setup_io): Rename extern declaration readline_echoing_p to
	_rl_echoing_p.  Adjust assignments for the both renames.

gdb/doc/
	* Makefile.in (GDB_DOC_SOURCE_INCLUDES): Rename inc-hist.texinfo to
	hsuser.texi.
	* gdb.texinfo <!SYSTEM_READLINE>: Rename inc-hist.texinfo inclusion and
	comment to hsuser.texi.  Change rluser.texi name in the comment.
@
text
@/* histfile.c - functions to manipulate the history file. */

/* Copyright (C) 1989-2010 Free Software Foundation, Inc.

   This file contains the GNU History Library (History), a set of
   routines for managing the text of previously typed lines.

   History is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   History is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with History.  If not, see <http://www.gnu.org/licenses/>.
*/

/* The goal is to make the implementation transparent, so that you
   don't have to know what data types are used, just what functions
   you can call.  I think I have done that. */

#define READLINE_LIBRARY

#if defined (__TANDEM)
#  include <floss.h>
#endif

#if defined (HAVE_CONFIG_H)
#  include <config.h>
#endif

#include <stdio.h>

#include <sys/types.h>
#if ! defined (_MINIX) && defined (HAVE_SYS_FILE_H)
#  include <sys/file.h>
#endif
#include "posixstat.h"
#include <fcntl.h>

#if defined (HAVE_STDLIB_H)
#  include <stdlib.h>
#else
#  include "ansi_stdlib.h"
#endif /* HAVE_STDLIB_H */

#if defined (HAVE_UNISTD_H)
#  include <unistd.h>
#endif

#include <ctype.h>

#if defined (__EMX__)
#  undef HAVE_MMAP
#endif

#ifdef HISTORY_USE_MMAP
#  include <sys/mman.h>

#  ifdef MAP_FILE
#    define MAP_RFLAGS	(MAP_FILE|MAP_PRIVATE)
#    define MAP_WFLAGS	(MAP_FILE|MAP_SHARED)
#  else
#    define MAP_RFLAGS	MAP_PRIVATE
#    define MAP_WFLAGS	MAP_SHARED
#  endif

#  ifndef MAP_FAILED
#    define MAP_FAILED	((void *)-1)
#  endif

#endif /* HISTORY_USE_MMAP */

/* If we're compiling for __EMX__ (OS/2) or __CYGWIN__ (cygwin32 environment
   on win 95/98/nt), we want to open files with O_BINARY mode so that there
   is no \n -> \r\n conversion performed.  On other systems, we don't want to
   mess around with O_BINARY at all, so we ensure that it's defined to 0. */
#if defined (__EMX__) || defined (__CYGWIN__)
#  ifndef O_BINARY
#    define O_BINARY 0
#  endif
#else /* !__EMX__ && !__CYGWIN__ */
#  undef O_BINARY
#  define O_BINARY 0
#endif /* !__EMX__ && !__CYGWIN__ */

#include <errno.h>
#if !defined (errno)
extern int errno;
#endif /* !errno */

#include "history.h"
#include "histlib.h"

#include "rlshell.h"
#include "xmalloc.h"

/* If non-zero, we write timestamps to the history file in history_do_write() */
int history_write_timestamps = 0;

/* Does S look like the beginning of a history timestamp entry?  Placeholder
   for more extensive tests. */
#define HIST_TIMESTAMP_START(s)		(*(s) == history_comment_char && isdigit ((s)[1]) )

/* Return the string that should be used in the place of this
   filename.  This only matters when you don't specify the
   filename to read_history (), or write_history (). */
static char *
history_filename (filename)
     const char *filename;
{
  char *return_val;
  const char *home;
  int home_len;

  return_val = filename ? savestring (filename) : (char *)NULL;

  if (return_val)
    return (return_val);
  
  home = sh_get_env_value ("HOME");

  if (home == 0)
    {
#if 0
      home = ".";
      home_len = 1;
#else
      return (NULL);
#endif
    }
  else
    home_len = strlen (home);

  return_val = (char *)xmalloc (2 + home_len + 8); /* strlen(".history") == 8 */
  strcpy (return_val, home);
  return_val[home_len] = '/';
#if defined (__MSDOS__)
  strcpy (return_val + home_len + 1, "_history");
#else
  strcpy (return_val + home_len + 1, ".history");
#endif

  return (return_val);
}

/* Add the contents of FILENAME to the history list, a line at a time.
   If FILENAME is NULL, then read from ~/.history.  Returns 0 if
   successful, or errno if not. */
int
read_history (filename)
     const char *filename;
{
  return (read_history_range (filename, 0, -1));
}

/* Read a range of lines from FILENAME, adding them to the history list.
   Start reading at the FROM'th line and end at the TO'th.  If FROM
   is zero, start at the beginning.  If TO is less than FROM, read
   until the end of the file.  If FILENAME is NULL, then read from
   ~/.history.  Returns 0 if successful, or errno if not. */
int
read_history_range (filename, from, to)
     const char *filename;
     int from, to;
{
  register char *line_start, *line_end, *p;
  char *input, *buffer, *bufend, *last_ts;
  int file, current_line, chars_read;
  struct stat finfo;
  size_t file_size;
#if defined (EFBIG)
  int overflow_errno = EFBIG;
#elif defined (EOVERFLOW)
  int overflow_errno = EOVERFLOW;
#else
  int overflow_errno = EIO;
#endif

  buffer = last_ts = (char *)NULL;
  input = history_filename (filename);
  file = input ? open (input, O_RDONLY|O_BINARY, 0666) : -1;

  if ((file < 0) || (fstat (file, &finfo) == -1))
    goto error_and_exit;

  file_size = (size_t)finfo.st_size;

  /* check for overflow on very large files */
  if (file_size != finfo.st_size || file_size + 1 < file_size)
    {
      errno = overflow_errno;
      goto error_and_exit;
    }

#ifdef HISTORY_USE_MMAP
  /* We map read/write and private so we can change newlines to NULs without
     affecting the underlying object. */
  buffer = (char *)mmap (0, file_size, PROT_READ|PROT_WRITE, MAP_RFLAGS, file, 0);
  if ((void *)buffer == MAP_FAILED)
    {
      errno = overflow_errno;
      goto error_and_exit;
    }
  chars_read = file_size;
#else
  buffer = (char *)malloc (file_size + 1);
  if (buffer == 0)
    {
      errno = overflow_errno;
      goto error_and_exit;
    }

  chars_read = read (file, buffer, file_size);
#endif
  if (chars_read < 0)
    {
  error_and_exit:
      if (errno != 0)
	chars_read = errno;
      else
	chars_read = EIO;
      if (file >= 0)
	close (file);

      FREE (input);
#ifndef HISTORY_USE_MMAP
      FREE (buffer);
#endif

      return (chars_read);
    }

  close (file);

  /* Set TO to larger than end of file if negative. */
  if (to < 0)
    to = chars_read;

  /* Start at beginning of file, work to end. */
  bufend = buffer + chars_read;
  current_line = 0;

  /* Skip lines until we are at FROM. */
  for (line_start = line_end = buffer; line_end < bufend && current_line < from; line_end++)
    if (*line_end == '\n')
      {
      	p = line_end + 1;
      	/* If we see something we think is a timestamp, continue with this
	   line.  We should check more extensively here... */
	if (HIST_TIMESTAMP_START(p) == 0)
	  current_line++;
	line_start = p;
      }

  /* If there are lines left to gobble, then gobble them now. */
  for (line_end = line_start; line_end < bufend; line_end++)
    if (*line_end == '\n')
      {
	/* Change to allow Windows-like \r\n end of line delimiter. */
	if (line_end > line_start && line_end[-1] == '\r')
	  line_end[-1] = '\0';
	else
	  *line_end = '\0';

	if (*line_start)
	  {
	    if (HIST_TIMESTAMP_START(line_start) == 0)
	      {
		add_history (line_start);
		if (last_ts)
		  {
		    add_history_time (last_ts);
		    last_ts = NULL;
		  }
	      }
	    else
	      {
		last_ts = line_start;
		current_line--;
	      }
	  }

	current_line++;

	if (current_line >= to)
	  break;

	line_start = line_end + 1;
      }

  FREE (input);
#ifndef HISTORY_USE_MMAP
  FREE (buffer);
#else
  munmap (buffer, file_size);
#endif

  return (0);
}

/* Truncate the history file FNAME, leaving only LINES trailing lines.
   If FNAME is NULL, then use ~/.history.  Returns 0 on success, errno
   on failure. */
int
history_truncate_file (fname, lines)
     const char *fname;
     int lines;
{
  char *buffer, *filename, *bp, *bp1;		/* bp1 == bp+1 */
  int file, chars_read, rv;
  struct stat finfo;
  size_t file_size;

  buffer = (char *)NULL;
  filename = history_filename (fname);
  file = filename ? open (filename, O_RDONLY|O_BINARY, 0666) : -1;
  rv = 0;

  /* Don't try to truncate non-regular files. */
  if (file == -1 || fstat (file, &finfo) == -1)
    {
      rv = errno;
      if (file != -1)
	close (file);
      goto truncate_exit;
    }

  if (S_ISREG (finfo.st_mode) == 0)
    {
      close (file);
#ifdef EFTYPE
      rv = EFTYPE;
#else
      rv = EINVAL;
#endif
      goto truncate_exit;
    }

  file_size = (size_t)finfo.st_size;

  /* check for overflow on very large files */
  if (file_size != finfo.st_size || file_size + 1 < file_size)
    {
      close (file);
#if defined (EFBIG)
      rv = errno = EFBIG;
#elif defined (EOVERFLOW)
      rv = errno = EOVERFLOW;
#else
      rv = errno = EINVAL;
#endif
      goto truncate_exit;
    }

  buffer = (char *)malloc (file_size + 1);
  if (buffer == 0)
    {
      close (file);
      goto truncate_exit;
    }

  chars_read = read (file, buffer, file_size);
  close (file);

  if (chars_read <= 0)
    {
      rv = (chars_read < 0) ? errno : 0;
      goto truncate_exit;
    }

  /* Count backwards from the end of buffer until we have passed
     LINES lines.  bp1 is set funny initially.  But since bp[1] can't
     be a comment character (since it's off the end) and *bp can't be
     both a newline and the history comment character, it should be OK. */
  for (bp1 = bp = buffer + chars_read - 1; lines && bp > buffer; bp--)
    {
      if (*bp == '\n' && HIST_TIMESTAMP_START(bp1) == 0)
	lines--;
      bp1 = bp;
    }

  /* If this is the first line, then the file contains exactly the
     number of lines we want to truncate to, so we don't need to do
     anything.  It's the first line if we don't find a newline between
     the current value of i and 0.  Otherwise, write from the start of
     this line until the end of the buffer. */
  for ( ; bp > buffer; bp--)
    {
      if (*bp == '\n' && HIST_TIMESTAMP_START(bp1) == 0)
        {
	  bp++;
	  break;
        }
      bp1 = bp;
    }

  /* Write only if there are more lines in the file than we want to
     truncate to. */
  if (bp > buffer && ((file = open (filename, O_WRONLY|O_TRUNC|O_BINARY, 0600)) != -1))
    {
      write (file, bp, chars_read - (bp - buffer));

#if defined (__BEOS__)
      /* BeOS ignores O_TRUNC. */
      ftruncate (file, chars_read - (bp - buffer));
#endif

      close (file);
    }

 truncate_exit:

  FREE (buffer);

  xfree (filename);
  return rv;
}

/* Workhorse function for writing history.  Writes NELEMENT entries
   from the history list to FILENAME.  OVERWRITE is non-zero if you
   wish to replace FILENAME with the entries. */
static int
history_do_write (filename, nelements, overwrite)
     const char *filename;
     int nelements, overwrite;
{
  register int i;
  char *output;
  int file, mode, rv;
#ifdef HISTORY_USE_MMAP
  size_t cursize;

  mode = overwrite ? O_RDWR|O_CREAT|O_TRUNC|O_BINARY : O_RDWR|O_APPEND|O_BINARY;
#else
  mode = overwrite ? O_WRONLY|O_CREAT|O_TRUNC|O_BINARY : O_WRONLY|O_APPEND|O_BINARY;
#endif
  output = history_filename (filename);
  file = output ? open (output, mode, 0600) : -1;
  rv = 0;

  if (file == -1)
    {
      FREE (output);
      return (errno);
    }

#ifdef HISTORY_USE_MMAP
  cursize = overwrite ? 0 : lseek (file, 0, SEEK_END);
#endif

  if (nelements > history_length)
    nelements = history_length;

  /* Build a buffer of all the lines to write, and write them in one syscall.
     Suggested by Peter Ho (peter@@robosts.oxford.ac.uk). */
  {
    HIST_ENTRY **the_history;	/* local */
    register int j;
    int buffer_size;
    char *buffer;

    the_history = history_list ();
    /* Calculate the total number of bytes to write. */
    for (buffer_size = 0, i = history_length - nelements; i < history_length; i++)
#if 0
      buffer_size += 2 + HISTENT_BYTES (the_history[i]);
#else
      {
	if (history_write_timestamps && the_history[i]->timestamp && the_history[i]->timestamp[0])
	  buffer_size += strlen (the_history[i]->timestamp) + 1;
	buffer_size += strlen (the_history[i]->line) + 1;
      }
#endif

    /* Allocate the buffer, and fill it. */
#ifdef HISTORY_USE_MMAP
    if (ftruncate (file, buffer_size+cursize) == -1)
      goto mmap_error;
    buffer = (char *)mmap (0, buffer_size, PROT_READ|PROT_WRITE, MAP_WFLAGS, file, cursize);
    if ((void *)buffer == MAP_FAILED)
      {
mmap_error:
	rv = errno;
	FREE (output);
	close (file);
	return rv;
      }
#else    
    buffer = (char *)malloc (buffer_size);
    if (buffer == 0)
      {
      	rv = errno;
	FREE (output);
	close (file);
	return rv;
      }
#endif

    for (j = 0, i = history_length - nelements; i < history_length; i++)
      {
	if (history_write_timestamps && the_history[i]->timestamp && the_history[i]->timestamp[0])
	  {
	    strcpy (buffer + j, the_history[i]->timestamp);
	    j += strlen (the_history[i]->timestamp);
	    buffer[j++] = '\n';
	  }
	strcpy (buffer + j, the_history[i]->line);
	j += strlen (the_history[i]->line);
	buffer[j++] = '\n';
      }

#ifdef HISTORY_USE_MMAP
    if (msync (buffer, buffer_size, 0) != 0 || munmap (buffer, buffer_size) != 0)
      rv = errno;
#else
    if (write (file, buffer, buffer_size) < 0)
      rv = errno;
    xfree (buffer);
#endif
  }

  close (file);

  FREE (output);

  return (rv);
}

/* Append NELEMENT entries to FILENAME.  The entries appended are from
   the end of the list minus NELEMENTs up to the end of the list. */
int
append_history (nelements, filename)
     int nelements;
     const char *filename;
{
  return (history_do_write (filename, nelements, HISTORY_APPEND));
}

/* Overwrite FILENAME with the current history.  If FILENAME is NULL,
   then write the history list to ~/.history.  Values returned
   are as in read_history ().*/
int
write_history (filename)
     const char *filename;
{
  return (history_do_write (filename, history_length, HISTORY_OVERWRITE));
}
@


1.8
log
@Readline 5.1 import for HEAD.
@
text
@d3 1
a3 1
/* Copyright (C) 1989-2003 Free Software Foundation, Inc.
d5 1
a5 1
   This file contains the GNU History Library (the Library), a set of
d8 1
a8 1
   The Library is free software; you can redistribute it and/or modify
d10 2
a11 2
   the Free Software Foundation; either version 2, or (at your option)
   any later version.
d13 8
a20 9
   The Library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   The GNU General Public License is often shipped with GNU software, and
   is generally kept in a file called COPYING or LICENSE.  If you do not
   have a copy of the license, write to the Free Software Foundation,
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
d55 3
a57 1
#if defined (__EMX__) || defined (__CYGWIN__)
d107 1
a107 1
#define HIST_TIMESTAMP_START(s)		(*(s) == history_comment_char)
d129 1
d132 3
d186 1
a186 1
  file = open (input, O_RDONLY|O_BINARY, 0666);
d264 3
a266 2
	if (line_end - 1 >= line_start && *(line_end - 1) == '\r')
	  *(line_end - 1) = '\0';
d321 1
a321 1
  file = open (filename, O_RDONLY|O_BINARY, 0666);
d420 1
a420 1
  free (filename);
d443 1
d446 1
a446 1
  if ((file = open (output, mode, 0600)) == -1)
d523 1
a523 1
    free (buffer);
@


1.7
log
@touched all sources to ease import of readline-5.1
@
text
@d3 1
a3 1
/* Copyright (C) 1989, 1992 Free Software Foundation, Inc.
d26 1
d29 4
d40 1
a40 1
#ifndef _MINIX
d60 1
a60 1
#ifdef HAVE_MMAP
d75 1
a75 1
#endif /* HAVE_MMAP */
d101 7
d166 2
a167 2
  register char *line_start, *line_end;
  char *input, *buffer, *bufend;
d171 7
d179 1
a179 1
  buffer = (char *)NULL;
d191 1
a191 5
#if defined (EFBIG)
      errno = EFBIG;
#elif defined (EOVERFLOW)
      errno = EOVERFLOW;
#endif
d195 1
a195 1
#ifdef HAVE_MMAP
d200 4
a203 1
    goto error_and_exit;
d208 4
a211 1
    goto error_and_exit;
d218 4
a221 1
      chars_read = errno;
d226 1
a226 1
#ifndef HAVE_MMAP
d247 6
a252 2
	current_line++;
	line_start = line_end + 1;
d265 16
a280 1
	  add_history (line_start);
d291 1
a291 1
#ifndef HAVE_MMAP
d308 1
a308 1
  char *buffer, *filename, *bp;
d371 4
a374 2
     LINES lines. */
  for (bp = buffer + chars_read - 1; lines && bp > buffer; bp--)
d376 1
a376 1
      if (*bp == '\n')
d378 1
d387 8
a394 5
    if (*bp == '\n')
      {
	bp++;
	break;
      }
d429 1
a431 1
#ifdef HAVE_MMAP
d445 1
a445 1
#ifdef HAVE_MMAP
d463 9
a471 1
      buffer_size += 1 + strlen (the_history[i]->line);
d474 1
a474 1
#ifdef HAVE_MMAP
d499 6
d510 1
a510 1
#ifdef HAVE_MMAP
@


1.7.2.1
log
@Import readline 5.1 on the branch.
@
text
@d3 1
a3 1
/* Copyright (C) 1989-2003 Free Software Foundation, Inc.
a25 1

a27 4
#if defined (__TANDEM)
#  include <floss.h>
#endif

d35 1
a35 1
#if ! defined (_MINIX) && defined (HAVE_SYS_FILE_H)
d55 1
a55 1
#ifdef HISTORY_USE_MMAP
d70 1
a70 1
#endif /* HISTORY_USE_MMAP */
a95 7
/* If non-zero, we write timestamps to the history file in history_do_write() */
int history_write_timestamps = 0;

/* Does S look like the beginning of a history timestamp entry?  Placeholder
   for more extensive tests. */
#define HIST_TIMESTAMP_START(s)		(*(s) == history_comment_char)

d154 2
a155 2
  register char *line_start, *line_end, *p;
  char *input, *buffer, *bufend, *last_ts;
a158 7
#if defined (EFBIG)
  int overflow_errno = EFBIG;
#elif defined (EOVERFLOW)
  int overflow_errno = EOVERFLOW;
#else
  int overflow_errno = EIO;
#endif
d160 1
a160 1
  buffer = last_ts = (char *)NULL;
d172 5
a176 1
      errno = overflow_errno;
d180 1
a180 1
#ifdef HISTORY_USE_MMAP
d185 1
a185 4
    {
      errno = overflow_errno;
      goto error_and_exit;
    }
d190 1
a190 4
    {
      errno = overflow_errno;
      goto error_and_exit;
    }
d197 1
a197 4
      if (errno != 0)
	chars_read = errno;
      else
	chars_read = EIO;
d202 1
a202 1
#ifndef HISTORY_USE_MMAP
d223 2
a224 6
      	p = line_end + 1;
      	/* If we see something we think is a timestamp, continue with this
	   line.  We should check more extensively here... */
	if (HIST_TIMESTAMP_START(p) == 0)
	  current_line++;
	line_start = p;
d237 1
a237 16
	  {
	    if (HIST_TIMESTAMP_START(line_start) == 0)
	      {
		add_history (line_start);
		if (last_ts)
		  {
		    add_history_time (last_ts);
		    last_ts = NULL;
		  }
	      }
	    else
	      {
		last_ts = line_start;
		current_line--;
	      }
	  }
d248 1
a248 1
#ifndef HISTORY_USE_MMAP
d265 1
a265 1
  char *buffer, *filename, *bp, *bp1;		/* bp1 == bp+1 */
d328 2
a329 4
     LINES lines.  bp1 is set funny initially.  But since bp[1] can't
     be a comment character (since it's off the end) and *bp can't be
     both a newline and the history comment character, it should be OK. */
  for (bp1 = bp = buffer + chars_read - 1; lines && bp > buffer; bp--)
d331 1
a331 1
      if (*bp == '\n' && HIST_TIMESTAMP_START(bp1) == 0)
a332 1
      bp1 = bp;
d341 5
a345 8
    {
      if (*bp == '\n' && HIST_TIMESTAMP_START(bp1) == 0)
        {
	  bp++;
	  break;
        }
      bp1 = bp;
    }
a379 1
#ifdef HISTORY_USE_MMAP
d382 1
d396 1
a396 1
#ifdef HISTORY_USE_MMAP
d414 1
a414 9
#if 0
      buffer_size += 2 + HISTENT_BYTES (the_history[i]);
#else
      {
	if (history_write_timestamps && the_history[i]->timestamp && the_history[i]->timestamp[0])
	  buffer_size += strlen (the_history[i]->timestamp) + 1;
	buffer_size += strlen (the_history[i]->line) + 1;
      }
#endif
d417 1
a417 1
#ifdef HISTORY_USE_MMAP
a441 6
	if (history_write_timestamps && the_history[i]->timestamp && the_history[i]->timestamp[0])
	  {
	    strcpy (buffer + j, the_history[i]->timestamp);
	    j += strlen (the_history[i]->timestamp);
	    buffer[j++] = '\n';
	  }
d447 1
a447 1
#ifdef HISTORY_USE_MMAP
@


1.6
log
@	* histfile.c (read_history_range): Remove '\r' character from
	history lines.
@
text
@@


1.5
log
@Import of readline 4.3.
Non-readline modified files:

src/gdb/ChangeLog src/gdb/defs.h src/gdb/cli/cli-cmds.c
src/gdb/cli/cli-setshow.c src/gdb/tui/ChangeLog
src/gdb/tui/tuiWin.c

In readline directory:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@d231 4
a234 1
	*line_end = '\0';
@


1.4
log
@readline:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Locally modified files: Makefile.in, configure.in, configure
        (regenerated), config.h.in (regenerated), readline.h, rltty.c,
 	shell.c signals.c.

        Locally added files: acconfig.h, config/*, config.h.bot,
        cross-build/*, doc/inc-hit.texinfo.

        New files: USAGE, rlprivate.h, rlshell.h, xmalloc.h.
examples:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        New files: excallback.c, rlfe.c.
doc:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Regenerated inc-hist.texinfo as copy of hsuser.texinfo, for
        inclusion in the gdb manual.

        New file: rluserman.texinfo
@
text
@d51 18
a68 5
#if defined (HAVE_STRING_H)
#  include <string.h>
#else
#  include <strings.h>
#endif /* !HAVE_STRING_H */
d70 1
d101 1
a101 1
     char *filename;
d103 2
a104 1
  char *return_val, *home;
d112 1
a112 1
  home = get_env_value ("HOME");
d122 1
a122 1
  return_val = xmalloc (2 + home_len + 8); /* strlen(".history") == 8 */
d139 1
a139 1
     char *filename;
d151 1
a151 1
     char *filename;
d154 2
a155 2
  register int line_start, line_end;
  char *input, *buffer;
d174 2
d180 11
a190 1
  buffer = xmalloc (file_size + 1);
d193 1
d197 1
d202 1
d204 1
d206 1
a206 1
      return (errno);
d216 2
a217 1
  line_start = line_end = current_line = 0;
d220 6
a225 11
  while (line_start < chars_read && current_line < from)
    {
      for (line_end = line_start; line_end < chars_read; line_end++)
	if (buffer[line_end] == '\n')
	  {
	    current_line++;
	    line_start = line_end + 1;
	    if (current_line == from)
	      break;
	  }
    }
d228 2
a229 2
  for (line_end = line_start; line_end < chars_read; line_end++)
    if (buffer[line_end] == '\n')
d231 1
a231 1
	buffer[line_end] = '\0';
d233 2
a234 2
	if (buffer[line_start])
	  add_history (buffer + line_start);
d245 1
d247 3
d255 2
a256 1
   If FNAME is NULL, then use ~/.history. */
d259 1
a259 1
     char *fname;
d262 2
a263 3
  register int i;
  int file, chars_read;
  char *buffer, *filename;
d270 1
d272 1
d274 6
a279 1
    goto truncate_exit;
d281 10
a290 3
  /* Don't try to truncate non-regular files. */
  if (S_ISREG(finfo.st_mode) == 0)
    goto truncate_exit;
d299 5
a303 1
      errno = EFBIG;
d308 7
a314 1
  buffer = xmalloc (file_size + 1);
d319 4
a322 1
    goto truncate_exit;
d326 1
a326 1
  for (i = chars_read - 1; lines && i; i--)
d328 1
a328 1
      if (buffer[i] == '\n')
d337 2
a338 2
  for ( ; i; i--)
    if (buffer[i] == '\n')
d340 1
a340 1
	i++;
d346 1
a346 1
  if (i && ((file = open (filename, O_WRONLY|O_TRUNC|O_BINARY, 0600)) != -1))
d348 1
a348 1
      write (file, buffer + i, chars_read - i);
d352 1
a352 1
      ftruncate (file, chars_read - i);
d363 1
a363 1
  return 0;
d371 1
a371 1
     char *filename;
d376 2
a377 1
  int file, mode;
d379 3
d383 1
d385 1
d393 4
d414 22
a435 1
    buffer = xmalloc (buffer_size);
d444 6
a449 1
    write (file, buffer, buffer_size);
d451 1
d458 1
a458 1
  return (0);
d466 1
a466 1
     char *filename;
d476 1
a476 1
     char *filename;
@


1.4.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d51 5
a55 18
#if defined (__EMX__) || defined (__CYGWIN__)
#  undef HAVE_MMAP
#endif

#ifdef HAVE_MMAP
#  include <sys/mman.h>

#  ifdef MAP_FILE
#    define MAP_RFLAGS	(MAP_FILE|MAP_PRIVATE)
#    define MAP_WFLAGS	(MAP_FILE|MAP_SHARED)
#  else
#    define MAP_RFLAGS	MAP_PRIVATE
#    define MAP_WFLAGS	MAP_SHARED
#  endif

#  ifndef MAP_FAILED
#    define MAP_FAILED	((void *)-1)
#  endif
a56 1
#endif /* HAVE_MMAP */
d87 1
a87 1
     const char *filename;
d89 1
a89 2
  char *return_val;
  const char *home;
d97 1
a97 1
  home = sh_get_env_value ("HOME");
d107 1
a107 1
  return_val = (char *)xmalloc (2 + home_len + 8); /* strlen(".history") == 8 */
d124 1
a124 1
     const char *filename;
d136 1
a136 1
     const char *filename;
d139 2
a140 2
  register char *line_start, *line_end;
  char *input, *buffer, *bufend;
a158 2
#elif defined (EOVERFLOW)
      errno = EOVERFLOW;
d163 1
a163 11
#ifdef HAVE_MMAP
  /* We map read/write and private so we can change newlines to NULs without
     affecting the underlying object. */
  buffer = (char *)mmap (0, file_size, PROT_READ|PROT_WRITE, MAP_RFLAGS, file, 0);
  if ((void *)buffer == MAP_FAILED)
    goto error_and_exit;
  chars_read = file_size;
#else
  buffer = (char *)malloc (file_size + 1);
  if (buffer == 0)
    goto error_and_exit;
a165 1
#endif
a168 1
      chars_read = errno;
a172 1
#ifndef HAVE_MMAP
a173 1
#endif
d175 1
a175 1
      return (chars_read);
d185 1
a185 2
  bufend = buffer + chars_read;
  current_line = 0;
d188 11
a198 6
  for (line_start = line_end = buffer; line_end < bufend && current_line < from; line_end++)
    if (*line_end == '\n')
      {
	current_line++;
	line_start = line_end + 1;
      }
d201 2
a202 2
  for (line_end = line_start; line_end < bufend; line_end++)
    if (*line_end == '\n')
d204 1
a204 1
	*line_end = '\0';
d206 2
a207 2
	if (*line_start)
	  add_history (line_start);
a217 1
#ifndef HAVE_MMAP
a218 3
#else
  munmap (buffer, file_size);
#endif
d224 1
a224 2
   If FNAME is NULL, then use ~/.history.  Returns 0 on success, errno
   on failure. */
d227 1
a227 1
     const char *fname;
d230 3
a232 2
  char *buffer, *filename, *bp;
  int file, chars_read, rv;
a238 1
  rv = 0;
a239 1
  /* Don't try to truncate non-regular files. */
d241 1
a241 6
    {
      rv = errno;
      if (file != -1)
	close (file);
      goto truncate_exit;
    }
d243 3
a245 10
  if (S_ISREG (finfo.st_mode) == 0)
    {
      close (file);
#ifdef EFTYPE
      rv = EFTYPE;
#else
      rv = EINVAL;
#endif
      goto truncate_exit;
    }
d254 1
a254 5
      rv = errno = EFBIG;
#elif defined (EOVERFLOW)
      rv = errno = EOVERFLOW;
#else
      rv = errno = EINVAL;
d259 1
a259 7
  buffer = (char *)malloc (file_size + 1);
  if (buffer == 0)
    {
      close (file);
      goto truncate_exit;
    }

d264 1
a264 4
    {
      rv = (chars_read < 0) ? errno : 0;
      goto truncate_exit;
    }
d268 1
a268 1
  for (bp = buffer + chars_read - 1; lines && bp > buffer; bp--)
d270 1
a270 1
      if (*bp == '\n')
d279 2
a280 2
  for ( ; bp > buffer; bp--)
    if (*bp == '\n')
d282 1
a282 1
	bp++;
d288 1
a288 1
  if (bp > buffer && ((file = open (filename, O_WRONLY|O_TRUNC|O_BINARY, 0600)) != -1))
d290 1
a290 1
      write (file, bp, chars_read - (bp - buffer));
d294 1
a294 1
      ftruncate (file, chars_read - (bp - buffer));
d305 1
a305 1
  return rv;
d313 1
a313 1
     const char *filename;
d318 1
a318 2
  int file, mode, rv;
  size_t cursize;
a319 3
#ifdef HAVE_MMAP
  mode = overwrite ? O_RDWR|O_CREAT|O_TRUNC|O_BINARY : O_RDWR|O_APPEND|O_BINARY;
#else
a320 1
#endif
a321 1
  rv = 0;
a328 4
#ifdef HAVE_MMAP
  cursize = overwrite ? 0 : lseek (file, 0, SEEK_END);
#endif

d346 1
a346 22
#ifdef HAVE_MMAP
    if (ftruncate (file, buffer_size+cursize) == -1)
      goto mmap_error;
    buffer = (char *)mmap (0, buffer_size, PROT_READ|PROT_WRITE, MAP_WFLAGS, file, cursize);
    if ((void *)buffer == MAP_FAILED)
      {
mmap_error:
	rv = errno;
	FREE (output);
	close (file);
	return rv;
      }
#else    
    buffer = (char *)malloc (buffer_size);
    if (buffer == 0)
      {
      	rv = errno;
	FREE (output);
	close (file);
	return rv;
      }
#endif
d355 1
a355 6
#ifdef HAVE_MMAP
    if (msync (buffer, buffer_size, 0) != 0 || munmap (buffer, buffer_size) != 0)
      rv = errno;
#else
    if (write (file, buffer, buffer_size) < 0)
      rv = errno;
a356 1
#endif
d363 1
a363 1
  return (rv);
d371 1
a371 1
     const char *filename;
d381 1
a381 1
     const char *filename;
@


1.4.22.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d51 5
a55 18
#if defined (__EMX__) || defined (__CYGWIN__)
#  undef HAVE_MMAP
#endif

#ifdef HAVE_MMAP
#  include <sys/mman.h>

#  ifdef MAP_FILE
#    define MAP_RFLAGS	(MAP_FILE|MAP_PRIVATE)
#    define MAP_WFLAGS	(MAP_FILE|MAP_SHARED)
#  else
#    define MAP_RFLAGS	MAP_PRIVATE
#    define MAP_WFLAGS	MAP_SHARED
#  endif

#  ifndef MAP_FAILED
#    define MAP_FAILED	((void *)-1)
#  endif
a56 1
#endif /* HAVE_MMAP */
d87 1
a87 1
     const char *filename;
d89 1
a89 2
  char *return_val;
  const char *home;
d97 1
a97 1
  home = sh_get_env_value ("HOME");
d107 1
a107 1
  return_val = (char *)xmalloc (2 + home_len + 8); /* strlen(".history") == 8 */
d124 1
a124 1
     const char *filename;
d136 1
a136 1
     const char *filename;
d139 2
a140 2
  register char *line_start, *line_end;
  char *input, *buffer, *bufend;
a158 2
#elif defined (EOVERFLOW)
      errno = EOVERFLOW;
d163 1
a163 11
#ifdef HAVE_MMAP
  /* We map read/write and private so we can change newlines to NULs without
     affecting the underlying object. */
  buffer = (char *)mmap (0, file_size, PROT_READ|PROT_WRITE, MAP_RFLAGS, file, 0);
  if ((void *)buffer == MAP_FAILED)
    goto error_and_exit;
  chars_read = file_size;
#else
  buffer = (char *)malloc (file_size + 1);
  if (buffer == 0)
    goto error_and_exit;
a165 1
#endif
a168 1
      chars_read = errno;
a172 1
#ifndef HAVE_MMAP
a173 1
#endif
d175 1
a175 1
      return (chars_read);
d185 1
a185 2
  bufend = buffer + chars_read;
  current_line = 0;
d188 11
a198 6
  for (line_start = line_end = buffer; line_end < bufend && current_line < from; line_end++)
    if (*line_end == '\n')
      {
	current_line++;
	line_start = line_end + 1;
      }
d201 2
a202 2
  for (line_end = line_start; line_end < bufend; line_end++)
    if (*line_end == '\n')
d204 1
a204 1
	*line_end = '\0';
d206 2
a207 2
	if (*line_start)
	  add_history (line_start);
a217 1
#ifndef HAVE_MMAP
a218 3
#else
  munmap (buffer, file_size);
#endif
d224 1
a224 2
   If FNAME is NULL, then use ~/.history.  Returns 0 on success, errno
   on failure. */
d227 1
a227 1
     const char *fname;
d230 3
a232 2
  char *buffer, *filename, *bp;
  int file, chars_read, rv;
a238 1
  rv = 0;
a239 1
  /* Don't try to truncate non-regular files. */
d241 1
a241 6
    {
      rv = errno;
      if (file != -1)
	close (file);
      goto truncate_exit;
    }
d243 3
a245 10
  if (S_ISREG (finfo.st_mode) == 0)
    {
      close (file);
#ifdef EFTYPE
      rv = EFTYPE;
#else
      rv = EINVAL;
#endif
      goto truncate_exit;
    }
d254 1
a254 5
      rv = errno = EFBIG;
#elif defined (EOVERFLOW)
      rv = errno = EOVERFLOW;
#else
      rv = errno = EINVAL;
d259 1
a259 7
  buffer = (char *)malloc (file_size + 1);
  if (buffer == 0)
    {
      close (file);
      goto truncate_exit;
    }

d264 1
a264 4
    {
      rv = (chars_read < 0) ? errno : 0;
      goto truncate_exit;
    }
d268 1
a268 1
  for (bp = buffer + chars_read - 1; lines && bp > buffer; bp--)
d270 1
a270 1
      if (*bp == '\n')
d279 2
a280 2
  for ( ; bp > buffer; bp--)
    if (*bp == '\n')
d282 1
a282 1
	bp++;
d288 1
a288 1
  if (bp > buffer && ((file = open (filename, O_WRONLY|O_TRUNC|O_BINARY, 0600)) != -1))
d290 1
a290 1
      write (file, bp, chars_read - (bp - buffer));
d294 1
a294 1
      ftruncate (file, chars_read - (bp - buffer));
d305 1
a305 1
  return rv;
d313 1
a313 1
     const char *filename;
d318 1
a318 2
  int file, mode, rv;
  size_t cursize;
a319 3
#ifdef HAVE_MMAP
  mode = overwrite ? O_RDWR|O_CREAT|O_TRUNC|O_BINARY : O_RDWR|O_APPEND|O_BINARY;
#else
a320 1
#endif
a321 1
  rv = 0;
a328 4
#ifdef HAVE_MMAP
  cursize = overwrite ? 0 : lseek (file, 0, SEEK_END);
#endif

d346 1
a346 22
#ifdef HAVE_MMAP
    if (ftruncate (file, buffer_size+cursize) == -1)
      goto mmap_error;
    buffer = (char *)mmap (0, buffer_size, PROT_READ|PROT_WRITE, MAP_WFLAGS, file, cursize);
    if ((void *)buffer == MAP_FAILED)
      {
mmap_error:
	rv = errno;
	FREE (output);
	close (file);
	return rv;
      }
#else    
    buffer = (char *)malloc (buffer_size);
    if (buffer == 0)
      {
      	rv = errno;
	FREE (output);
	close (file);
	return rv;
      }
#endif
d355 1
a355 6
#ifdef HAVE_MMAP
    if (msync (buffer, buffer_size, 0) != 0 || munmap (buffer, buffer_size) != 0)
      rv = errno;
#else
    if (write (file, buffer, buffer_size) < 0)
      rv = errno;
a356 1
#endif
d363 1
a363 1
  return (rv);
d371 1
a371 1
     const char *filename;
d381 1
a381 1
     const char *filename;
@


1.4.16.1
log
@2002-08-24  Elena Zannoni  <ezannoni@@redhat.com>

        Import of readline 4.3:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@d51 5
a55 18
#if defined (__EMX__) || defined (__CYGWIN__)
#  undef HAVE_MMAP
#endif

#ifdef HAVE_MMAP
#  include <sys/mman.h>

#  ifdef MAP_FILE
#    define MAP_RFLAGS	(MAP_FILE|MAP_PRIVATE)
#    define MAP_WFLAGS	(MAP_FILE|MAP_SHARED)
#  else
#    define MAP_RFLAGS	MAP_PRIVATE
#    define MAP_WFLAGS	MAP_SHARED
#  endif

#  ifndef MAP_FAILED
#    define MAP_FAILED	((void *)-1)
#  endif
a56 1
#endif /* HAVE_MMAP */
d87 1
a87 1
     const char *filename;
d89 1
a89 2
  char *return_val;
  const char *home;
d97 1
a97 1
  home = sh_get_env_value ("HOME");
d107 1
a107 1
  return_val = (char *)xmalloc (2 + home_len + 8); /* strlen(".history") == 8 */
d124 1
a124 1
     const char *filename;
d136 1
a136 1
     const char *filename;
d139 2
a140 2
  register char *line_start, *line_end;
  char *input, *buffer, *bufend;
a158 2
#elif defined (EOVERFLOW)
      errno = EOVERFLOW;
d163 1
a163 11
#ifdef HAVE_MMAP
  /* We map read/write and private so we can change newlines to NULs without
     affecting the underlying object. */
  buffer = (char *)mmap (0, file_size, PROT_READ|PROT_WRITE, MAP_RFLAGS, file, 0);
  if ((void *)buffer == MAP_FAILED)
    goto error_and_exit;
  chars_read = file_size;
#else
  buffer = (char *)malloc (file_size + 1);
  if (buffer == 0)
    goto error_and_exit;
a165 1
#endif
a168 1
      chars_read = errno;
a172 1
#ifndef HAVE_MMAP
a173 1
#endif
d175 1
a175 1
      return (chars_read);
d185 1
a185 2
  bufend = buffer + chars_read;
  current_line = 0;
d188 11
a198 6
  for (line_start = line_end = buffer; line_end < bufend && current_line < from; line_end++)
    if (*line_end == '\n')
      {
	current_line++;
	line_start = line_end + 1;
      }
d201 2
a202 2
  for (line_end = line_start; line_end < bufend; line_end++)
    if (*line_end == '\n')
d204 1
a204 1
	*line_end = '\0';
d206 2
a207 2
	if (*line_start)
	  add_history (line_start);
a217 1
#ifndef HAVE_MMAP
a218 3
#else
  munmap (buffer, file_size);
#endif
d224 1
a224 2
   If FNAME is NULL, then use ~/.history.  Returns 0 on success, errno
   on failure. */
d227 1
a227 1
     const char *fname;
d230 3
a232 2
  char *buffer, *filename, *bp;
  int file, chars_read, rv;
a238 1
  rv = 0;
a239 1
  /* Don't try to truncate non-regular files. */
d241 1
a241 6
    {
      rv = errno;
      if (file != -1)
	close (file);
      goto truncate_exit;
    }
d243 3
a245 10
  if (S_ISREG (finfo.st_mode) == 0)
    {
      close (file);
#ifdef EFTYPE
      rv = EFTYPE;
#else
      rv = EINVAL;
#endif
      goto truncate_exit;
    }
d254 1
a254 5
      rv = errno = EFBIG;
#elif defined (EOVERFLOW)
      rv = errno = EOVERFLOW;
#else
      rv = errno = EINVAL;
d259 1
a259 7
  buffer = (char *)malloc (file_size + 1);
  if (buffer == 0)
    {
      close (file);
      goto truncate_exit;
    }

d264 1
a264 4
    {
      rv = (chars_read < 0) ? errno : 0;
      goto truncate_exit;
    }
d268 1
a268 1
  for (bp = buffer + chars_read - 1; lines && bp > buffer; bp--)
d270 1
a270 1
      if (*bp == '\n')
d279 2
a280 2
  for ( ; bp > buffer; bp--)
    if (*bp == '\n')
d282 1
a282 1
	bp++;
d288 1
a288 1
  if (bp > buffer && ((file = open (filename, O_WRONLY|O_TRUNC|O_BINARY, 0600)) != -1))
d290 1
a290 1
      write (file, bp, chars_read - (bp - buffer));
d294 1
a294 1
      ftruncate (file, chars_read - (bp - buffer));
d305 1
a305 1
  return rv;
d313 1
a313 1
     const char *filename;
d318 1
a318 2
  int file, mode, rv;
  size_t cursize;
a319 3
#ifdef HAVE_MMAP
  mode = overwrite ? O_RDWR|O_CREAT|O_TRUNC|O_BINARY : O_RDWR|O_APPEND|O_BINARY;
#else
a320 1
#endif
a321 1
  rv = 0;
a328 4
#ifdef HAVE_MMAP
  cursize = overwrite ? 0 : lseek (file, 0, SEEK_END);
#endif

d346 1
a346 22
#ifdef HAVE_MMAP
    if (ftruncate (file, buffer_size+cursize) == -1)
      goto mmap_error;
    buffer = (char *)mmap (0, buffer_size, PROT_READ|PROT_WRITE, MAP_WFLAGS, file, cursize);
    if ((void *)buffer == MAP_FAILED)
      {
mmap_error:
	rv = errno;
	FREE (output);
	close (file);
	return rv;
      }
#else    
    buffer = (char *)malloc (buffer_size);
    if (buffer == 0)
      {
      	rv = errno;
	FREE (output);
	close (file);
	return rv;
      }
#endif
d355 1
a355 6
#ifdef HAVE_MMAP
    if (msync (buffer, buffer_size, 0) != 0 || munmap (buffer, buffer_size) != 0)
      rv = errno;
#else
    if (write (file, buffer, buffer_size) < 0)
      rv = errno;
a356 1
#endif
d363 1
a363 1
  return (rv);
d371 1
a371 1
     const char *filename;
d381 1
a381 1
     const char *filename;
@


1.3
log
@Dummy commit before importof 4.1 version
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 1, or (at your option)
d21 1
a21 1
   675 Mass Ave, Cambridge, MA 02139, USA. */
d38 1
a38 1
#include <sys/stat.h>
d57 6
a62 1
#if defined (__EMX__)
d66 1
a66 2
#else /* !__EMX__ */
   /* If we're not compiling for __EMX__, we don't want this at all.  Ever. */
d69 1
a69 1
#endif /* !__EMX__ */
d79 2
a80 4
/* Functions imported from shell.c */
extern char *get_env_value ();

extern char *xmalloc (), *xrealloc ();
d110 3
d114 1
d141 1
a141 1
  int file, current_line;
a148 10

#ifdef __MSDOS__
  /* MSDOS doesn't allow leading dots in file names.  Try again
     with the dot replaced by an underscore.  */
  if (file < 0 && !filename)
    {
      input[strlen (input) - 8] = '_';
      file = open (input, O_RDONLY|O_BINARY, 0666);
    }
#endif
d164 3
a166 5
#if 0
  if (read (file, buffer, file_size) != file_size)
#else
  if (read (file, buffer, file_size) < 0)
#endif
d182 1
a182 1
    to = file_size;
d188 1
a188 1
  while (line_start < file_size && current_line < from)
d190 1
a190 1
      for (line_end = line_start; line_end < file_size; line_end++)
d201 1
a201 1
  for (line_end = line_start; line_end < file_size; line_end++)
d240 2
a241 9
#ifdef __MSDOS__
  /* MSDOS doesn't allow leading dots in file names.  Try again
     with the dot replaced by an underscore.  */
  if (file < 0 && !fname)
    {
      filename[strlen (filename) - 8] = '_';
      file = open (filename, O_RDONLY|O_BINARY, 0666);
    }
#endif
d243 2
a244 1
  if (file == -1 || fstat (file, &finfo) == -1)
d290 1
a290 1
      write (file, buffer + i, file_size - i);
d294 1
a294 1
      ftruncate (file, file_size - i);
a324 14
#ifdef __MSDOS__
      /* MSDOS doesn't allow leading dots in file names.  If this is
	 the default file name, try again with the dot replaced by an
	 underscore.  */
      if (!filename)
	{
	  output[strlen (output) - 8] = '_';
	  if ((file = open (output, mode, 0600)) == -1)
	    {
	      FREE (output);
	      return (errno);
	    }
	}
#else
a326 1
#endif
@


1.2
log
@(read_history_range, history_truncate_file, history_do_write) [__MSDOS__]:
Allow for a `_' to replace the leading dot in hard-wrired file names.
@
text
@@


1.1
log
@Initial revision
@
text
@d143 10
d168 1
d170 3
d234 1
a234 1
     register int lines;
d246 10
d303 6
d337 14
d353 1
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-08-02 snapshot
@
text
@a157 1
#if 0
a158 3
#else
  if (read (file, buffer, file_size) < 0)
#endif
d220 1
a220 1
     int lines;
a278 6

#if defined (__BEOS__)
      /* BeOS ignores O_TRUNC. */
      ftruncate (file, file_size - i);
#endif

@


1.1.1.3
log
@Import of readline 4.1
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
d21 1
a21 1
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
d38 1
a38 1
#include "posixstat.h"
d57 1
a57 6

/* If we're compiling for __EMX__ (OS/2) or __CYGWIN__ (cygwin32 environment
   on win 95/98/nt), we want to open files with O_BINARY mode so that there
   is no \n -> \r\n conversion performed.  On other systems, we don't want to
   mess around with O_BINARY at all, so we ensure that it's defined to 0. */
#if defined (__EMX__) || defined (__CYGWIN__)
d61 2
a62 1
#else /* !__EMX__ && !__CYGWIN__ */
d65 1
a65 1
#endif /* !__EMX__ && !__CYGWIN__ */
d75 4
a78 2
#include "rlshell.h"
#include "xmalloc.h"
a107 3
#if defined (__MSDOS__)
  strcpy (return_val + home_len + 1, "_history");
#else
a108 1
#endif
d135 1
a135 1
  int file, current_line, chars_read;
d158 5
a162 3

  chars_read = read (file, buffer, file_size);
  if (chars_read < 0)
d178 1
a178 1
    to = chars_read;
d184 1
a184 1
  while (line_start < chars_read && current_line < from)
d186 1
a186 1
      for (line_end = line_start; line_end < chars_read; line_end++)
d197 1
a197 1
  for (line_end = line_start; line_end < chars_read; line_end++)
a238 4
  /* Don't try to truncate non-regular files. */
  if (S_ISREG(finfo.st_mode) == 0)
    goto truncate_exit;

d282 1
a282 1
      write (file, buffer + i, chars_read - i);
d286 1
a286 1
      ftruncate (file, chars_read - i);
@


1.1.1.4
log
@import of readline-4.3
@
text
@d51 5
a55 18
#if defined (__EMX__) || defined (__CYGWIN__)
#  undef HAVE_MMAP
#endif

#ifdef HAVE_MMAP
#  include <sys/mman.h>

#  ifdef MAP_FILE
#    define MAP_RFLAGS	(MAP_FILE|MAP_PRIVATE)
#    define MAP_WFLAGS	(MAP_FILE|MAP_SHARED)
#  else
#    define MAP_RFLAGS	MAP_PRIVATE
#    define MAP_WFLAGS	MAP_SHARED
#  endif

#  ifndef MAP_FAILED
#    define MAP_FAILED	((void *)-1)
#  endif
a56 1
#endif /* HAVE_MMAP */
d87 1
a87 1
     const char *filename;
d89 1
a89 2
  char *return_val;
  const char *home;
d97 1
a97 1
  home = sh_get_env_value ("HOME");
d107 1
a107 1
  return_val = (char *)xmalloc (2 + home_len + 8); /* strlen(".history") == 8 */
d124 1
a124 1
     const char *filename;
d136 1
a136 1
     const char *filename;
d139 2
a140 2
  register char *line_start, *line_end;
  char *input, *buffer, *bufend;
a158 2
#elif defined (EOVERFLOW)
      errno = EOVERFLOW;
d163 1
a163 11
#ifdef HAVE_MMAP
  /* We map read/write and private so we can change newlines to NULs without
     affecting the underlying object. */
  buffer = (char *)mmap (0, file_size, PROT_READ|PROT_WRITE, MAP_RFLAGS, file, 0);
  if ((void *)buffer == MAP_FAILED)
    goto error_and_exit;
  chars_read = file_size;
#else
  buffer = (char *)malloc (file_size + 1);
  if (buffer == 0)
    goto error_and_exit;
a165 1
#endif
a168 1
      chars_read = errno;
a172 1
#ifndef HAVE_MMAP
a173 1
#endif
d175 1
a175 1
      return (chars_read);
d185 1
a185 2
  bufend = buffer + chars_read;
  current_line = 0;
d188 11
a198 6
  for (line_start = line_end = buffer; line_end < bufend && current_line < from; line_end++)
    if (*line_end == '\n')
      {
	current_line++;
	line_start = line_end + 1;
      }
d201 2
a202 2
  for (line_end = line_start; line_end < bufend; line_end++)
    if (*line_end == '\n')
d204 1
a204 1
	*line_end = '\0';
d206 2
a207 2
	if (*line_start)
	  add_history (line_start);
a217 1
#ifndef HAVE_MMAP
a218 3
#else
  munmap (buffer, file_size);
#endif
d224 1
a224 2
   If FNAME is NULL, then use ~/.history.  Returns 0 on success, errno
   on failure. */
d227 1
a227 1
     const char *fname;
d230 3
a232 2
  char *buffer, *filename, *bp;
  int file, chars_read, rv;
a238 1
  rv = 0;
a239 1
  /* Don't try to truncate non-regular files. */
d241 1
a241 6
    {
      rv = errno;
      if (file != -1)
	close (file);
      goto truncate_exit;
    }
d243 3
a245 10
  if (S_ISREG (finfo.st_mode) == 0)
    {
      close (file);
#ifdef EFTYPE
      rv = EFTYPE;
#else
      rv = EINVAL;
#endif
      goto truncate_exit;
    }
d254 1
a254 5
      rv = errno = EFBIG;
#elif defined (EOVERFLOW)
      rv = errno = EOVERFLOW;
#else
      rv = errno = EINVAL;
d259 1
a259 7
  buffer = (char *)malloc (file_size + 1);
  if (buffer == 0)
    {
      close (file);
      goto truncate_exit;
    }

d264 1
a264 4
    {
      rv = (chars_read < 0) ? errno : 0;
      goto truncate_exit;
    }
d268 1
a268 1
  for (bp = buffer + chars_read - 1; lines && bp > buffer; bp--)
d270 1
a270 1
      if (*bp == '\n')
d279 2
a280 2
  for ( ; bp > buffer; bp--)
    if (*bp == '\n')
d282 1
a282 1
	bp++;
d288 1
a288 1
  if (bp > buffer && ((file = open (filename, O_WRONLY|O_TRUNC|O_BINARY, 0600)) != -1))
d290 1
a290 1
      write (file, bp, chars_read - (bp - buffer));
d294 1
a294 1
      ftruncate (file, chars_read - (bp - buffer));
d305 1
a305 1
  return rv;
d313 1
a313 1
     const char *filename;
d318 1
a318 2
  int file, mode, rv;
  size_t cursize;
a319 3
#ifdef HAVE_MMAP
  mode = overwrite ? O_RDWR|O_CREAT|O_TRUNC|O_BINARY : O_RDWR|O_APPEND|O_BINARY;
#else
a320 1
#endif
a321 1
  rv = 0;
a328 4
#ifdef HAVE_MMAP
  cursize = overwrite ? 0 : lseek (file, 0, SEEK_END);
#endif

d346 1
a346 22
#ifdef HAVE_MMAP
    if (ftruncate (file, buffer_size+cursize) == -1)
      goto mmap_error;
    buffer = (char *)mmap (0, buffer_size, PROT_READ|PROT_WRITE, MAP_WFLAGS, file, cursize);
    if ((void *)buffer == MAP_FAILED)
      {
mmap_error:
	rv = errno;
	FREE (output);
	close (file);
	return rv;
      }
#else    
    buffer = (char *)malloc (buffer_size);
    if (buffer == 0)
      {
      	rv = errno;
	FREE (output);
	close (file);
	return rv;
      }
#endif
d355 1
a355 6
#ifdef HAVE_MMAP
    if (msync (buffer, buffer_size, 0) != 0 || munmap (buffer, buffer_size) != 0)
      rv = errno;
#else
    if (write (file, buffer, buffer_size) < 0)
      rv = errno;
a356 1
#endif
d363 1
a363 1
  return (rv);
d371 1
a371 1
     const char *filename;
d381 1
a381 1
     const char *filename;
@


1.1.1.5
log
@import of readlilne 5.1
@
text
@d3 1
a3 1
/* Copyright (C) 1989-2003 Free Software Foundation, Inc.
a25 1

a27 4
#if defined (__TANDEM)
#  include <floss.h>
#endif

d35 1
a35 1
#if ! defined (_MINIX) && defined (HAVE_SYS_FILE_H)
d55 1
a55 1
#ifdef HISTORY_USE_MMAP
d70 1
a70 1
#endif /* HISTORY_USE_MMAP */
a95 7
/* If non-zero, we write timestamps to the history file in history_do_write() */
int history_write_timestamps = 0;

/* Does S look like the beginning of a history timestamp entry?  Placeholder
   for more extensive tests. */
#define HIST_TIMESTAMP_START(s)		(*(s) == history_comment_char)

d154 2
a155 2
  register char *line_start, *line_end, *p;
  char *input, *buffer, *bufend, *last_ts;
a158 7
#if defined (EFBIG)
  int overflow_errno = EFBIG;
#elif defined (EOVERFLOW)
  int overflow_errno = EOVERFLOW;
#else
  int overflow_errno = EIO;
#endif
d160 1
a160 1
  buffer = last_ts = (char *)NULL;
d172 5
a176 1
      errno = overflow_errno;
d180 1
a180 1
#ifdef HISTORY_USE_MMAP
d185 1
a185 4
    {
      errno = overflow_errno;
      goto error_and_exit;
    }
d190 1
a190 4
    {
      errno = overflow_errno;
      goto error_and_exit;
    }
d197 1
a197 4
      if (errno != 0)
	chars_read = errno;
      else
	chars_read = EIO;
d202 1
a202 1
#ifndef HISTORY_USE_MMAP
d223 2
a224 6
      	p = line_end + 1;
      	/* If we see something we think is a timestamp, continue with this
	   line.  We should check more extensively here... */
	if (HIST_TIMESTAMP_START(p) == 0)
	  current_line++;
	line_start = p;
d234 1
a234 16
	  {
	    if (HIST_TIMESTAMP_START(line_start) == 0)
	      {
		add_history (line_start);
		if (last_ts)
		  {
		    add_history_time (last_ts);
		    last_ts = NULL;
		  }
	      }
	    else
	      {
		last_ts = line_start;
		current_line--;
	      }
	  }
d245 1
a245 1
#ifndef HISTORY_USE_MMAP
d262 1
a262 1
  char *buffer, *filename, *bp, *bp1;		/* bp1 == bp+1 */
d325 2
a326 4
     LINES lines.  bp1 is set funny initially.  But since bp[1] can't
     be a comment character (since it's off the end) and *bp can't be
     both a newline and the history comment character, it should be OK. */
  for (bp1 = bp = buffer + chars_read - 1; lines && bp > buffer; bp--)
d328 1
a328 1
      if (*bp == '\n' && HIST_TIMESTAMP_START(bp1) == 0)
a329 1
      bp1 = bp;
d338 5
a342 8
    {
      if (*bp == '\n' && HIST_TIMESTAMP_START(bp1) == 0)
        {
	  bp++;
	  break;
        }
      bp1 = bp;
    }
a376 1
#ifdef HISTORY_USE_MMAP
d379 1
d393 1
a393 1
#ifdef HISTORY_USE_MMAP
d411 1
a411 9
#if 0
      buffer_size += 2 + HISTENT_BYTES (the_history[i]);
#else
      {
	if (history_write_timestamps && the_history[i]->timestamp && the_history[i]->timestamp[0])
	  buffer_size += strlen (the_history[i]->timestamp) + 1;
	buffer_size += strlen (the_history[i]->line) + 1;
      }
#endif
d414 1
a414 1
#ifdef HISTORY_USE_MMAP
a438 6
	if (history_write_timestamps && the_history[i]->timestamp && the_history[i]->timestamp[0])
	  {
	    strcpy (buffer + j, the_history[i]->timestamp);
	    j += strlen (the_history[i]->timestamp);
	    buffer[j++] = '\n';
	  }
d444 1
a444 1
#ifdef HISTORY_USE_MMAP
@


