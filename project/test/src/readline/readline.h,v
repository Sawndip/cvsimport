head	1.7;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.7
	gdb_7_6-2013-04-26-release:1.7
	gdb_7_6-branch:1.7.0.6
	gdb_7_6-2013-03-12-branchpoint:1.7
	gdb_7_5_1-2012-11-29-release:1.7
	gdb_7_5-2012-08-17-release:1.7
	gdb_7_5-branch:1.7.0.4
	gdb_7_5-2012-07-18-branchpoint:1.7
	gdb_7_4_1-2012-04-26-release:1.7
	gdb_7_4-2012-01-24-release:1.7
	gdb_7_4-branch:1.7.0.2
	gdb_7_4-2011-12-13-branchpoint:1.7
	gdb_7_3_1-2011-09-04-release:1.6
	gdb_7_3-2011-07-26-release:1.6
	gdb_7_3-branch:1.6.0.36
	gdb_7_3-2011-04-01-branchpoint:1.6
	gdb_7_2-2010-09-02-release:1.6
	gdb_7_2-branch:1.6.0.34
	gdb_7_2-2010-07-07-branchpoint:1.6
	gdb_7_1-2010-03-18-release:1.6
	gdb_7_1-branch:1.6.0.32
	gdb_7_1-2010-02-18-branchpoint:1.6
	gdb_7_0_1-2009-12-22-release:1.6
	gdb_7_0-2009-10-06-release:1.6
	gdb_7_0-branch:1.6.0.30
	gdb_7_0-2009-09-16-branchpoint:1.6
	arc-sim-20090309:1.6
	msnyder-checkpoint-072509-branch:1.6.0.28
	msnyder-checkpoint-072509-branchpoint:1.6
	arc-insight_6_8-branch:1.6.0.26
	arc-insight_6_8-branchpoint:1.6
	insight_6_8-branch:1.6.0.24
	insight_6_8-branchpoint:1.6
	reverse-20081226-branch:1.6.0.22
	reverse-20081226-branchpoint:1.6
	multiprocess-20081120-branch:1.6.0.20
	multiprocess-20081120-branchpoint:1.6
	reverse-20080930-branch:1.6.0.18
	reverse-20080930-branchpoint:1.6
	reverse-20080717-branch:1.6.0.16
	reverse-20080717-branchpoint:1.6
	msnyder-reverse-20080609-branch:1.6.0.14
	msnyder-reverse-20080609-branchpoint:1.6
	drow-reverse-20070409-branch:1.6.0.12
	drow-reverse-20070409-branchpoint:1.6
	gdb_6_8-2008-03-27-release:1.6
	gdb_6_8-branch:1.6.0.10
	gdb_6_8-2008-02-26-branchpoint:1.6
	gdb_6_7_1-2007-10-29-release:1.6
	gdb_6_7-2007-10-10-release:1.6
	gdb_6_7-branch:1.6.0.8
	gdb_6_7-2007-09-07-branchpoint:1.6
	insight_6_6-20070208-release:1.6
	gdb_6_6-2006-12-18-release:1.6
	gdb_6_6-branch:1.6.0.6
	gdb_6_6-2006-11-15-branchpoint:1.6
	insight_6_5-20061003-release:1.6
	gdb-csl-symbian-6_4_50_20060226-12:1.4
	gdb-csl-sourcerygxx-3_4_4-25:1.4
	nickrob-async-20060828-mergepoint:1.6
	gdb-csl-symbian-6_4_50_20060226-11:1.4
	gdb-csl-sourcerygxx-4_1-17:1.4
	gdb-csl-20060226-branch-local-2:1.4
	gdb-csl-sourcerygxx-4_1-14:1.4
	gdb-csl-sourcerygxx-4_1-13:1.4
	gdb-csl-sourcerygxx-4_1-12:1.4
	gdb-csl-sourcerygxx-3_4_4-21:1.4
	gdb_6_5-20060621-release:1.6
	gdb-csl-sourcerygxx-4_1-9:1.4
	gdb-csl-sourcerygxx-4_1-8:1.4
	gdb-csl-sourcerygxx-4_1-7:1.4
	gdb-csl-arm-2006q1-6:1.4
	gdb-csl-sourcerygxx-4_1-6:1.4
	gdb-csl-symbian-6_4_50_20060226-10:1.4
	gdb-csl-symbian-6_4_50_20060226-9:1.4
	gdb-csl-symbian-6_4_50_20060226-8:1.4
	gdb-csl-coldfire-4_1-11:1.4
	gdb-csl-sourcerygxx-3_4_4-19:1.4
	gdb-csl-coldfire-4_1-10:1.4
	gdb_6_5-branch:1.6.0.4
	gdb_6_5-2006-05-14-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-5:1.4
	nickrob-async-20060513-branch:1.6.0.2
	nickrob-async-20060513-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-4:1.4
	msnyder-reverse-20060502-branch:1.5.0.4
	msnyder-reverse-20060502-branchpoint:1.5
	gdb-csl-morpho-4_1-4:1.4
	gdb-csl-sourcerygxx-3_4_4-17:1.4
	readline_5_1-import-branch:1.5.0.2
	readline_5_1-import-branchpoint:1.5
	readline-pre-51-import:1.5
	readline_5_1:1.1.1.5
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.4
	gdb-csl-symbian-20060226-branch:1.4.0.78
	gdb-csl-symbian-20060226-branchpoint:1.4
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.4
	msnyder-reverse-20060331-branch:1.4.0.76
	msnyder-reverse-20060331-branchpoint:1.4
	gdb-csl-available-20060303-branch:1.4.0.74
	gdb-csl-available-20060303-branchpoint:1.4
	gdb-csl-20060226-branch:1.4.0.72
	gdb-csl-20060226-branchpoint:1.4
	gdb_6_4-20051202-release:1.4
	msnyder-fork-checkpoint-branch:1.4.0.70
	msnyder-fork-checkpoint-branchpoint:1.4
	gdb-csl-gxxpro-6_3-branch:1.4.0.68
	gdb-csl-gxxpro-6_3-branchpoint:1.4
	gdb_6_4-branch:1.4.0.66
	gdb_6_4-2005-11-01-branchpoint:1.4
	gdb-csl-arm-20051020-branch:1.4.0.64
	gdb-csl-arm-20051020-branchpoint:1.4
	msnyder-tracepoint-checkpoint-branch:1.4.0.62
	msnyder-tracepoint-checkpoint-branchpoint:1.4
	gdb-csl-arm-20050325-2005-q1b:1.4
	gdb-csl-arm-20050325-2005-q1a:1.4
	csl-arm-20050325-branch:1.4.0.60
	csl-arm-20050325-branchpoint:1.4
	gdb_6_3-20041109-release:1.4
	gdb_6_3-branch:1.4.0.56
	gdb_6_3-20041019-branchpoint:1.4
	drow_intercu-merge-20040921:1.4
	drow_intercu-merge-20040915:1.4
	jimb-gdb_6_2-e500-branch:1.4.0.58
	jimb-gdb_6_2-e500-branchpoint:1.4
	gdb_6_2-20040730-release:1.4
	gdb_6_2-branch:1.4.0.54
	gdb_6_2-2004-07-10-gmt-branchpoint:1.4
	gdb_6_1_1-20040616-release:1.4
	gdb_6_1-2004-04-05-release:1.4
	drow_intercu-merge-20040402:1.4
	drow_intercu-merge-20040327:1.4
	ezannoni_pie-20040323-branch:1.4.0.52
	ezannoni_pie-20040323-branchpoint:1.4
	cagney_tramp-20040321-mergepoint:1.4
	cagney_tramp-20040309-branch:1.4.0.50
	cagney_tramp-20040309-branchpoint:1.4
	gdb_6_1-branch:1.4.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.4
	drow_intercu-20040221-branch:1.4.0.46
	drow_intercu-20040221-branchpoint:1.4
	cagney_bfdfile-20040213-branch:1.4.0.44
	cagney_bfdfile-20040213-branchpoint:1.4
	drow-cplus-merge-20040208:1.4
	carlton_dictionary-20040126-merge:1.4
	cagney_bigcore-20040122-branch:1.4.0.42
	cagney_bigcore-20040122-branchpoint:1.4
	drow-cplus-merge-20040113:1.4
	drow-cplus-merge-20031224:1.4
	drow-cplus-merge-20031220:1.4
	carlton_dictionary-20031215-merge:1.4
	drow-cplus-merge-20031214:1.4
	carlton-dictionary-20031111-merge:1.4
	gdb_6_0-2003-10-04-release:1.4
	kettenis_sparc-20030918-branch:1.4.0.40
	kettenis_sparc-20030918-branchpoint:1.4
	carlton_dictionary-20030917-merge:1.4
	ezannoni_pie-20030916-branchpoint:1.4
	ezannoni_pie-20030916-branch:1.4.0.38
	cagney_x86i386-20030821-branch:1.4.0.36
	cagney_x86i386-20030821-branchpoint:1.4
	carlton_dictionary-20030805-merge:1.4
	carlton_dictionary-20030627-merge:1.4
	gdb_6_0-branch:1.4.0.34
	gdb_6_0-2003-06-23-branchpoint:1.4
	jimb-ppc64-linux-20030613-branch:1.4.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.4
	cagney_convert-20030606-branch:1.4.0.30
	cagney_convert-20030606-branchpoint:1.4
	cagney_writestrings-20030508-branch:1.4.0.28
	cagney_writestrings-20030508-branchpoint:1.4
	jimb-ppc64-linux-20030528-branch:1.4.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.4
	carlton_dictionary-20030523-merge:1.4
	cagney_fileio-20030521-branch:1.4.0.24
	cagney_fileio-20030521-branchpoint:1.4
	kettenis_i386newframe-20030517-mergepoint:1.4
	jimb-ppc64-linux-20030509-branch:1.4.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.4
	kettenis_i386newframe-20030504-mergepoint:1.4
	carlton_dictionary-20030430-merge:1.4
	kettenis_i386newframe-20030419-branch:1.4.0.20
	kettenis_i386newframe-20030419-branchpoint:1.4
	carlton_dictionary-20030416-merge:1.4
	cagney_frameaddr-20030409-mergepoint:1.4
	kettenis_i386newframe-20030406-branch:1.4.0.18
	kettenis_i386newframe-20030406-branchpoint:1.4
	cagney_frameaddr-20030403-branchpoint:1.4
	cagney_frameaddr-20030403-branch:1.4.0.16
	cagney_framebase-20030330-mergepoint:1.4
	cagney_framebase-20030326-branch:1.4.0.14
	cagney_framebase-20030326-branchpoint:1.4
	cagney_lazyid-20030317-branch:1.4.0.12
	cagney_lazyid-20030317-branchpoint:1.4
	kettenis-i386newframe-20030316-mergepoint:1.4
	offbyone-20030313-branch:1.4.0.10
	offbyone-20030313-branchpoint:1.4
	kettenis-i386newframe-20030308-branch:1.4.0.8
	kettenis-i386newframe-20030308-branchpoint:1.4
	carlton_dictionary-20030305-merge:1.4
	cagney_offbyone-20030303-branch:1.4.0.6
	cagney_offbyone-20030303-branchpoint:1.4
	carlton_dictionary-20030207-merge:1.4
	interps-20030202-branch:1.4.0.4
	interps-20030202-branchpoint:1.4
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.3
	readline-pre-43-import:1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.24
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	carlton_dictionary-branch:1.3.0.22
	carlton_dictionary-20020920-branchpoint:1.3
	gdb_5_3-branch:1.3.0.20
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.3
	cagney_sysregs-20020825-branch:1.3.0.18
	cagney_sysregs-20020825-branchpoint:1.3
	readline_4_3-import-branch:1.3.0.16
	readline_4_3-import-branchpoint:1.3
	readline_4_3:1.1.1.4
	gdb_5_2_1-2002-07-23-release:1.3
	kseitz_interps-20020528-branch:1.3.0.14
	kseitz_interps-20020528-branchpoint:1.3
	cagney_regbuf-20020515-branch:1.3.0.12
	cagney_regbuf-20020515-branchpoint:1.3
	jimb-macro-020506-branch:1.3.0.10
	jimb-macro-020506-branchpoint:1.3
	gdb_5_2-2002-04-29-release:1.3
	gdb_5_2-branch:1.3.0.8
	gdb_5_2-2002-03-03-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	cygnus_cvs_20020108_pre:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.4
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.2
	gdb_5_1-2001-07-29-branchpoint:1.3
	insight-precleanup-2001-01-01:1.3
	readline_4_1:1.1.1.3
	readline_4_0:1.1.1.2
	FSF:1.1.1
	readline-pre-41-import:1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.7
date	2011.05.11.23.38.39;	author jkratoch;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.05.18.26.12;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.20.20.13.20;	author ezannoni;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2002.12.08.22.31.37;	author ezannoni;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.09.17.19.56;	author ezannoni;	state Exp;
branches
	1.3.16.1
	1.3.22.1
	1.3.24.1;
next	1.2;

1.2
date	2000.07.07.17.15.45;	author ezannoni;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.53;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.5.2.1
date	2006.04.24.22.00.25;	author drow;	state Exp;
branches;
next	;

1.3.16.1
date	2002.08.25.23.41.17;	author ezannoni;	state Exp;
branches;
next	;

1.3.22.1
date	2002.12.23.19.39.44;	author carlton;	state Exp;
branches;
next	;

1.3.24.1
date	2003.12.14.20.28.14;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.53;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.08.02.23.47.58;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.07.09.16.21.20;	author ezannoni;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.08.23.22.02.27;	author ezannoni;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.20.20.05.35;	author ezannoni;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Imported readline 6.2, and upstream patch 001.

[patch 0/3] readline-6.2 rebase
http://sourceware.org/ml/gdb-patches/2011-05/msg00003.html
[patch 1/3] readline-6.2: Merge of already posted patches
http://sourceware.org/ml/gdb-patches/2011-05/msg00004.html
	=
	[Bug-readline] [RFC/readline] bind.c, rl_function_dumper, Free allocated
	http://lists.gnu.org/archive/html/bug-readline/2011-03/msg00000.html
	[Bug-readline] [patch] Fix underquotation in readline/examples/rlfe/conf
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00001.html
	[Bug-readline] [patch] Makefile.in htm<->html
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00002.html
	Re: [Bug-readline] [patch] Makefile.in dependency: callback.o: xmalloc.h
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00004.html
	[Bug-readline] [patch] Remove . from the VPATH directive
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00005.html
	Eli Zaretskii's __MSDOS__ / __GO32__ / __MINGW32__ / __DJGPP__ stuff:
	http://sourceware.org/ml/gdb/2011-04/msg00002.html
	Jan Kratochvil's patch for FSF GDB tree local-specific changes:
	http://sourceware.org/ml/gdb/2011-04/msg00006.html
	Preservation of existing ChangeLog.gdb files, their updates.
[patch 2/3] readline-6.2: Workaround "ask" regression
http://sourceware.org/ml/gdb-patches/2011-05/msg00005.html
[patch 3/3] readline-6.2: Revert 5.x compat., apply 6.x compat.
http://sourceware.org/ml/gdb-patches/2011-05/msg00006.html
[patch 4/3] readline-6.2: Substitute inc-hist.texinfo
http://sourceware.org/ml/gdb-patches/2011-05/msg00010.html

readline/
	Workaround gdb.base/completion.exp regression on readline-6.2.
	* complete.c (get_y_or_n): Disable the return on RL_STATE_CALLBACK.

	Imported readline 6.2, and upstream patch 001.
	* configure: Regenerate.

readline/doc/
	* hsuser.texi (Using History Interactively): Disable !BashFeatures
	@@defcodeindex.  Make the `Programming with GNU History' reference
	external.
	* inc-hist.texinfo: Remove.

	Imported readline 6.2, and upstream patch 001.

readline/examples/
	Imported readline 6.2, and upstream patch 001.

readline/examples/rlfe/
	Imported readline 6.2, and upstream patch 001.

gdb/
	* config.in: Regenerate.
	* configure: Regenerate.
	* configure.ac <--with-system-readline> (for readline_echoing_p):
	Remove the test.
	* tui/tui-io.c (tui_old_readline_echoing_p): Rename to ...
	(tui_old_rl_echoing_p): ... here.
	(tui_setup_io): Rename extern declaration readline_echoing_p to
	_rl_echoing_p.  Adjust assignments for the both renames.

gdb/doc/
	* Makefile.in (GDB_DOC_SOURCE_INCLUDES): Rename inc-hist.texinfo to
	hsuser.texi.
	* gdb.texinfo <!SYSTEM_READLINE>: Rename inc-hist.texinfo inclusion and
	comment to hsuser.texi.  Change rluser.texi name in the comment.
@
text
@/* Readline.h -- the names of functions callable from within readline. */

/* Copyright (C) 1987-2011 Free Software Foundation, Inc.

   This file is part of the GNU Readline Library (Readline), a library
   for reading lines of text with interactive input and history editing.      

   Readline is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Readline is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Readline.  If not, see <http://www.gnu.org/licenses/>.
*/

#if !defined (_READLINE_H_)
#define _READLINE_H_

#ifdef __cplusplus
extern "C" {
#endif

#if defined (READLINE_LIBRARY)
#  include "rlstdc.h"
#  include "rltypedefs.h"
#  include "keymaps.h"
#  include "tilde.h"
#else
#  include <readline/rlstdc.h>
#  include <readline/rltypedefs.h>
#  include <readline/keymaps.h>
#  include <readline/tilde.h>
#endif

/* Hex-encoded Readline version number. */
#define RL_READLINE_VERSION	0x0602		/* Readline 6.2 */
#define RL_VERSION_MAJOR	6
#define RL_VERSION_MINOR	2

/* Readline data structures. */

/* Maintaining the state of undo.  We remember individual deletes and inserts
   on a chain of things to do. */

/* The actions that undo knows how to undo.  Notice that UNDO_DELETE means
   to insert some text, and UNDO_INSERT means to delete some text.   I.e.,
   the code tells undo what to undo, not how to undo it. */
enum undo_code { UNDO_DELETE, UNDO_INSERT, UNDO_BEGIN, UNDO_END };

/* What an element of THE_UNDO_LIST looks like. */
typedef struct undo_list {
  struct undo_list *next;
  int start, end;		/* Where the change took place. */
  char *text;			/* The text to insert, if undoing a delete. */
  enum undo_code what;		/* Delete, Insert, Begin, End. */
} UNDO_LIST;

/* The current undo list for RL_LINE_BUFFER. */
extern UNDO_LIST *rl_undo_list;

/* The data structure for mapping textual names to code addresses. */
typedef struct _funmap {
  const char *name;
  rl_command_func_t *function;
} FUNMAP;

extern FUNMAP **funmap;

/* **************************************************************** */
/*								    */
/*	     Functions available to bind to key sequences	    */
/*								    */
/* **************************************************************** */

/* Bindable commands for numeric arguments. */
extern int rl_digit_argument PARAMS((int, int));
extern int rl_universal_argument PARAMS((int, int));

/* Bindable commands for moving the cursor. */
extern int rl_forward_byte PARAMS((int, int));
extern int rl_forward_char PARAMS((int, int));
extern int rl_forward PARAMS((int, int));
extern int rl_backward_byte PARAMS((int, int));
extern int rl_backward_char PARAMS((int, int));
extern int rl_backward PARAMS((int, int));
extern int rl_beg_of_line PARAMS((int, int));
extern int rl_end_of_line PARAMS((int, int));
extern int rl_forward_word PARAMS((int, int));
extern int rl_backward_word PARAMS((int, int));
extern int rl_refresh_line PARAMS((int, int));
extern int rl_clear_screen PARAMS((int, int));
extern int rl_skip_csi_sequence PARAMS((int, int));
extern int rl_arrow_keys PARAMS((int, int));

/* Bindable commands for inserting and deleting text. */
extern int rl_insert PARAMS((int, int));
extern int rl_quoted_insert PARAMS((int, int));
extern int rl_tab_insert PARAMS((int, int));
extern int rl_newline PARAMS((int, int));
extern int rl_do_lowercase_version PARAMS((int, int));
extern int rl_rubout PARAMS((int, int));
extern int rl_delete PARAMS((int, int));
extern int rl_rubout_or_delete PARAMS((int, int));
extern int rl_delete_horizontal_space PARAMS((int, int));
extern int rl_delete_or_show_completions PARAMS((int, int));
extern int rl_insert_comment PARAMS((int, int));

/* Bindable commands for changing case. */
extern int rl_upcase_word PARAMS((int, int));
extern int rl_downcase_word PARAMS((int, int));
extern int rl_capitalize_word PARAMS((int, int));

/* Bindable commands for transposing characters and words. */
extern int rl_transpose_words PARAMS((int, int));
extern int rl_transpose_chars PARAMS((int, int));

/* Bindable commands for searching within a line. */
extern int rl_char_search PARAMS((int, int));
extern int rl_backward_char_search PARAMS((int, int));

/* Bindable commands for readline's interface to the command history. */
extern int rl_beginning_of_history PARAMS((int, int));
extern int rl_end_of_history PARAMS((int, int));
extern int rl_get_next_history PARAMS((int, int));
extern int rl_get_previous_history PARAMS((int, int));

/* Bindable commands for managing the mark and region. */
extern int rl_set_mark PARAMS((int, int));
extern int rl_exchange_point_and_mark PARAMS((int, int));

/* Bindable commands to set the editing mode (emacs or vi). */
extern int rl_vi_editing_mode PARAMS((int, int));
extern int rl_emacs_editing_mode PARAMS((int, int));

/* Bindable commands to change the insert mode (insert or overwrite) */
extern int rl_overwrite_mode PARAMS((int, int));

/* Bindable commands for managing key bindings. */
extern int rl_re_read_init_file PARAMS((int, int));
extern int rl_dump_functions PARAMS((int, int));
extern int rl_dump_macros PARAMS((int, int));
extern int rl_dump_variables PARAMS((int, int));

/* Bindable commands for word completion. */
extern int rl_complete PARAMS((int, int));
extern int rl_possible_completions PARAMS((int, int));
extern int rl_insert_completions PARAMS((int, int));
extern int rl_old_menu_complete PARAMS((int, int));
extern int rl_menu_complete PARAMS((int, int));
extern int rl_backward_menu_complete PARAMS((int, int));

/* Bindable commands for killing and yanking text, and managing the kill ring. */
extern int rl_kill_word PARAMS((int, int));
extern int rl_backward_kill_word PARAMS((int, int));
extern int rl_kill_line PARAMS((int, int));
extern int rl_backward_kill_line PARAMS((int, int));
extern int rl_kill_full_line PARAMS((int, int));
extern int rl_unix_word_rubout PARAMS((int, int));
extern int rl_unix_filename_rubout PARAMS((int, int));
extern int rl_unix_line_discard PARAMS((int, int));
extern int rl_copy_region_to_kill PARAMS((int, int));
extern int rl_kill_region PARAMS((int, int));
extern int rl_copy_forward_word PARAMS((int, int));
extern int rl_copy_backward_word PARAMS((int, int));
extern int rl_yank PARAMS((int, int));
extern int rl_yank_pop PARAMS((int, int));
extern int rl_yank_nth_arg PARAMS((int, int));
extern int rl_yank_last_arg PARAMS((int, int));
/* Not available unless __CYGWIN__ is defined. */
#ifdef __CYGWIN__
extern int rl_paste_from_clipboard PARAMS((int, int));
#endif

/* Bindable commands for incremental searching. */
extern int rl_reverse_search_history PARAMS((int, int));
extern int rl_forward_search_history PARAMS((int, int));

/* Bindable keyboard macro commands. */
extern int rl_start_kbd_macro PARAMS((int, int));
extern int rl_end_kbd_macro PARAMS((int, int));
extern int rl_call_last_kbd_macro PARAMS((int, int));

/* Bindable undo commands. */
extern int rl_revert_line PARAMS((int, int));
extern int rl_undo_command PARAMS((int, int));

/* Bindable tilde expansion commands. */
extern int rl_tilde_expand PARAMS((int, int));

/* Bindable terminal control commands. */
extern int rl_restart_output PARAMS((int, int));
extern int rl_stop_output PARAMS((int, int));

/* Miscellaneous bindable commands. */
extern int rl_abort PARAMS((int, int));
extern int rl_tty_status PARAMS((int, int));

/* Bindable commands for incremental and non-incremental history searching. */
extern int rl_history_search_forward PARAMS((int, int));
extern int rl_history_search_backward PARAMS((int, int));
extern int rl_noninc_forward_search PARAMS((int, int));
extern int rl_noninc_reverse_search PARAMS((int, int));
extern int rl_noninc_forward_search_again PARAMS((int, int));
extern int rl_noninc_reverse_search_again PARAMS((int, int));

/* Bindable command used when inserting a matching close character. */
extern int rl_insert_close PARAMS((int, int));

/* Not available unless READLINE_CALLBACKS is defined. */
extern void rl_callback_handler_install PARAMS((const char *, rl_vcpfunc_t *));
extern void rl_callback_read_char PARAMS((void));
extern void rl_callback_handler_remove PARAMS((void));

/* Things for vi mode. Not available unless readline is compiled -DVI_MODE. */
/* VI-mode bindable commands. */
extern int rl_vi_redo PARAMS((int, int));
extern int rl_vi_undo PARAMS((int, int));
extern int rl_vi_yank_arg PARAMS((int, int));
extern int rl_vi_fetch_history PARAMS((int, int));
extern int rl_vi_search_again PARAMS((int, int));
extern int rl_vi_search PARAMS((int, int));
extern int rl_vi_complete PARAMS((int, int));
extern int rl_vi_tilde_expand PARAMS((int, int));
extern int rl_vi_prev_word PARAMS((int, int));
extern int rl_vi_next_word PARAMS((int, int));
extern int rl_vi_end_word PARAMS((int, int));
extern int rl_vi_insert_beg PARAMS((int, int));
extern int rl_vi_append_mode PARAMS((int, int));
extern int rl_vi_append_eol PARAMS((int, int));
extern int rl_vi_eof_maybe PARAMS((int, int));
extern int rl_vi_insertion_mode PARAMS((int, int));
extern int rl_vi_insert_mode PARAMS((int, int));
extern int rl_vi_movement_mode PARAMS((int, int));
extern int rl_vi_arg_digit PARAMS((int, int));
extern int rl_vi_change_case PARAMS((int, int));
extern int rl_vi_put PARAMS((int, int));
extern int rl_vi_column PARAMS((int, int));
extern int rl_vi_delete_to PARAMS((int, int));
extern int rl_vi_change_to PARAMS((int, int));
extern int rl_vi_yank_to PARAMS((int, int));
extern int rl_vi_rubout PARAMS((int, int));
extern int rl_vi_delete PARAMS((int, int));
extern int rl_vi_back_to_indent PARAMS((int, int));
extern int rl_vi_first_print PARAMS((int, int));
extern int rl_vi_char_search PARAMS((int, int));
extern int rl_vi_match PARAMS((int, int));
extern int rl_vi_change_char PARAMS((int, int));
extern int rl_vi_subst PARAMS((int, int));
extern int rl_vi_overstrike PARAMS((int, int));
extern int rl_vi_overstrike_delete PARAMS((int, int));
extern int rl_vi_replace PARAMS((int, int));
extern int rl_vi_set_mark PARAMS((int, int));
extern int rl_vi_goto_mark PARAMS((int, int));

/* VI-mode utility functions. */
extern int rl_vi_check PARAMS((void));
extern int rl_vi_domove PARAMS((int, int *));
extern int rl_vi_bracktype PARAMS((int));

extern void rl_vi_start_inserting PARAMS((int, int, int));

/* VI-mode pseudo-bindable commands, used as utility functions. */
extern int rl_vi_fWord PARAMS((int, int));
extern int rl_vi_bWord PARAMS((int, int));
extern int rl_vi_eWord PARAMS((int, int));
extern int rl_vi_fword PARAMS((int, int));
extern int rl_vi_bword PARAMS((int, int));
extern int rl_vi_eword PARAMS((int, int));

/* **************************************************************** */
/*								    */
/*			Well Published Functions		    */
/*								    */
/* **************************************************************** */

/* Readline functions. */
/* Read a line of input.  Prompt with PROMPT.  A NULL PROMPT means none. */
extern char *readline PARAMS((const char *));

extern int rl_set_prompt PARAMS((const char *));
extern int rl_expand_prompt PARAMS((char *));

extern int rl_initialize PARAMS((void));

/* Undocumented; unused by readline */
extern int rl_discard_argument PARAMS((void));

/* Utility functions to bind keys to readline commands. */
extern int rl_add_defun PARAMS((const char *, rl_command_func_t *, int));
extern int rl_bind_key PARAMS((int, rl_command_func_t *));
extern int rl_bind_key_in_map PARAMS((int, rl_command_func_t *, Keymap));
extern int rl_unbind_key PARAMS((int));
extern int rl_unbind_key_in_map PARAMS((int, Keymap));
extern int rl_bind_key_if_unbound PARAMS((int, rl_command_func_t *));
extern int rl_bind_key_if_unbound_in_map PARAMS((int, rl_command_func_t *, Keymap));
extern int rl_unbind_function_in_map PARAMS((rl_command_func_t *, Keymap));
extern int rl_unbind_command_in_map PARAMS((const char *, Keymap));
extern int rl_bind_keyseq PARAMS((const char *, rl_command_func_t *));
extern int rl_bind_keyseq_in_map PARAMS((const char *, rl_command_func_t *, Keymap));
extern int rl_bind_keyseq_if_unbound PARAMS((const char *, rl_command_func_t *));
extern int rl_bind_keyseq_if_unbound_in_map PARAMS((const char *, rl_command_func_t *, Keymap));
extern int rl_generic_bind PARAMS((int, const char *, char *, Keymap));

extern char *rl_variable_value PARAMS((const char *));
extern int rl_variable_bind PARAMS((const char *, const char *));

/* Backwards compatibility, use rl_bind_keyseq_in_map instead. */
extern int rl_set_key PARAMS((const char *, rl_command_func_t *, Keymap));

/* Backwards compatibility, use rl_generic_bind instead. */
extern int rl_macro_bind PARAMS((const char *, const char *, Keymap));

/* Undocumented in the texinfo manual; not really useful to programs. */
extern int rl_translate_keyseq PARAMS((const char *, char *, int *));
extern char *rl_untranslate_keyseq PARAMS((int));

extern rl_command_func_t *rl_named_function PARAMS((const char *));
extern rl_command_func_t *rl_function_of_keyseq PARAMS((const char *, Keymap, int *));

extern void rl_list_funmap_names PARAMS((void));
extern char **rl_invoking_keyseqs_in_map PARAMS((rl_command_func_t *, Keymap));
extern char **rl_invoking_keyseqs PARAMS((rl_command_func_t *));
 
extern void rl_function_dumper PARAMS((int));
extern void rl_macro_dumper PARAMS((int));
extern void rl_variable_dumper PARAMS((int));

extern int rl_read_init_file PARAMS((const char *));
extern int rl_parse_and_bind PARAMS((char *));

/* Functions for manipulating keymaps. */
extern Keymap rl_make_bare_keymap PARAMS((void));
extern Keymap rl_copy_keymap PARAMS((Keymap));
extern Keymap rl_make_keymap PARAMS((void));
extern void rl_discard_keymap PARAMS((Keymap));

extern Keymap rl_get_keymap_by_name PARAMS((const char *));
extern char *rl_get_keymap_name PARAMS((Keymap));
extern void rl_set_keymap PARAMS((Keymap));
extern Keymap rl_get_keymap PARAMS((void));
/* Undocumented; used internally only. */
extern void rl_set_keymap_from_edit_mode PARAMS((void));
extern char *rl_get_keymap_name_from_edit_mode PARAMS((void));

/* Functions for manipulating the funmap, which maps command names to functions. */
extern int rl_add_funmap_entry PARAMS((const char *, rl_command_func_t *));
extern const char **rl_funmap_names PARAMS((void));
/* Undocumented, only used internally -- there is only one funmap, and this
   function may be called only once. */
extern void rl_initialize_funmap PARAMS((void));

/* Utility functions for managing keyboard macros. */
extern void rl_push_macro_input PARAMS((char *));

/* Functions for undoing, from undo.c */
extern void rl_add_undo PARAMS((enum undo_code, int, int, char *));
extern void rl_free_undo_list PARAMS((void));
extern int rl_do_undo PARAMS((void));
extern int rl_begin_undo_group PARAMS((void));
extern int rl_end_undo_group PARAMS((void));
extern int rl_modifying PARAMS((int, int));

/* Functions for redisplay. */
extern void rl_redisplay PARAMS((void));
extern int rl_on_new_line PARAMS((void));
extern int rl_on_new_line_with_prompt PARAMS((void));
extern int rl_forced_update_display PARAMS((void));
extern int rl_clear_message PARAMS((void));
extern int rl_reset_line_state PARAMS((void));
extern int rl_crlf PARAMS((void));

#if defined (USE_VARARGS) && defined (PREFER_STDARG)
extern int rl_message (const char *, ...)  __attribute__((__format__ (printf, 1, 2)));
#else
extern int rl_message ();
#endif

extern int rl_show_char PARAMS((int));

/* Undocumented in texinfo manual. */
extern int rl_character_len PARAMS((int, int));

/* Save and restore internal prompt redisplay information. */
extern void rl_save_prompt PARAMS((void));
extern void rl_restore_prompt PARAMS((void));

/* Modifying text. */
extern void rl_replace_line PARAMS((const char *, int));
extern int rl_insert_text PARAMS((const char *));
extern int rl_delete_text PARAMS((int, int));
extern int rl_kill_text PARAMS((int, int));
extern char *rl_copy_text PARAMS((int, int));

/* Terminal and tty mode management. */
extern void rl_prep_terminal PARAMS((int));
extern void rl_deprep_terminal PARAMS((void));
extern void rl_tty_set_default_bindings PARAMS((Keymap));
extern void rl_tty_unset_default_bindings PARAMS((Keymap));

extern int rl_reset_terminal PARAMS((const char *));
extern void rl_resize_terminal PARAMS((void));
extern void rl_set_screen_size PARAMS((int, int));
extern void rl_get_screen_size PARAMS((int *, int *));
extern void rl_reset_screen_size PARAMS((void));

extern char *rl_get_termcap PARAMS((const char *));

/* Functions for character input. */
extern int rl_stuff_char PARAMS((int));
extern int rl_execute_next PARAMS((int));
extern int rl_clear_pending_input PARAMS((void));
extern int rl_read_key PARAMS((void));
extern int rl_getc PARAMS((FILE *));
extern int rl_set_keyboard_input_timeout PARAMS((int));

/* `Public' utility functions . */
extern void rl_extend_line_buffer PARAMS((int));
extern int rl_ding PARAMS((void));
extern int rl_alphabetic PARAMS((int));
extern void rl_free PARAMS((void *));

/* Readline signal handling, from signals.c */
extern int rl_set_signals PARAMS((void));
extern int rl_clear_signals PARAMS((void));
extern void rl_cleanup_after_signal PARAMS((void));
extern void rl_reset_after_signal PARAMS((void));
extern void rl_free_line_state PARAMS((void));

extern void rl_echo_signal_char PARAMS((int)); 

extern int rl_set_paren_blink_timeout PARAMS((int));

/* Undocumented. */
extern int rl_maybe_save_line PARAMS((void));
extern int rl_maybe_unsave_line PARAMS((void));
extern int rl_maybe_replace_line PARAMS((void));

/* Completion functions. */
extern int rl_complete_internal PARAMS((int));
extern void rl_display_match_list PARAMS((char **, int, int));

extern char **rl_completion_matches PARAMS((const char *, rl_compentry_func_t *));
extern char *rl_username_completion_function PARAMS((const char *, int));
extern char *rl_filename_completion_function PARAMS((const char *, int));

extern int rl_completion_mode PARAMS((rl_command_func_t *));

#if 0
/* Backwards compatibility (compat.c).  These will go away sometime. */
extern void free_undo_list PARAMS((void));
extern int maybe_save_line PARAMS((void));
extern int maybe_unsave_line PARAMS((void));
extern int maybe_replace_line PARAMS((void));

extern int ding PARAMS((void));
extern int alphabetic PARAMS((int));
extern int crlf PARAMS((void));

extern char **completion_matches PARAMS((char *, rl_compentry_func_t *));
extern char *username_completion_function PARAMS((const char *, int));
extern char *filename_completion_function PARAMS((const char *, int));
#endif

/* **************************************************************** */
/*								    */
/*			Well Published Variables		    */
/*								    */
/* **************************************************************** */

/* The version of this incarnation of the readline library. */
extern const char *rl_library_version;		/* e.g., "4.2" */
extern int rl_readline_version;			/* e.g., 0x0402 */

/* True if this is real GNU readline. */
extern int rl_gnu_readline_p;

/* Flags word encapsulating the current readline state. */
extern int rl_readline_state;

/* Says which editing mode readline is currently using.  1 means emacs mode;
   0 means vi mode. */
extern int rl_editing_mode;

/* Insert or overwrite mode for emacs mode.  1 means insert mode; 0 means
   overwrite mode.  Reset to insert mode on each input line. */
extern int rl_insert_mode;

/* The name of the calling program.  You should initialize this to
   whatever was in argv[0].  It is used when parsing conditionals. */
extern const char *rl_readline_name;

/* The prompt readline uses.  This is set from the argument to
   readline (), and should not be assigned to directly. */
extern char *rl_prompt;

/* The prompt string that is actually displayed by rl_redisplay.  Public so
   applications can more easily supply their own redisplay functions. */
extern char *rl_display_prompt;

/* The line buffer that is in use. */
extern char *rl_line_buffer;

/* The location of point, and end. */
extern int rl_point;
extern int rl_end;

/* The mark, or saved cursor position. */
extern int rl_mark;

/* Flag to indicate that readline has finished with the current input
   line and should return it. */
extern int rl_done;

/* If set to a character value, that will be the next keystroke read. */
extern int rl_pending_input;

/* Non-zero if we called this function from _rl_dispatch().  It's present
   so functions can find out whether they were called from a key binding
   or directly from an application. */
extern int rl_dispatching;

/* Non-zero if the user typed a numeric argument before executing the
   current function. */
extern int rl_explicit_arg;

/* The current value of the numeric argument specified by the user. */
extern int rl_numeric_arg;

/* The address of the last command function Readline executed. */
extern rl_command_func_t *rl_last_func;

/* The name of the terminal to use. */
extern const char *rl_terminal_name;

/* The input and output streams. */
extern FILE *rl_instream;
extern FILE *rl_outstream;

/* If non-zero, Readline gives values of LINES and COLUMNS from the environment
   greater precedence than values fetched from the kernel when computing the
   screen dimensions. */
extern int rl_prefer_env_winsize;

/* If non-zero, then this is the address of a function to call just
   before readline_internal () prints the first prompt. */
extern rl_hook_func_t *rl_startup_hook;

/* If non-zero, this is the address of a function to call just before
   readline_internal_setup () returns and readline_internal starts
   reading input characters. */
extern rl_hook_func_t *rl_pre_input_hook;
      
/* The address of a function to call periodically while Readline is
   awaiting character input, or NULL, for no event handling. */
extern rl_hook_func_t *rl_event_hook;

/* The address of the function to call to fetch a character from the current
   Readline input stream */
extern rl_getc_func_t *rl_getc_function;

extern rl_voidfunc_t *rl_redisplay_function;

extern rl_vintfunc_t *rl_prep_term_function;
extern rl_voidfunc_t *rl_deprep_term_function;

/* Dispatch variables. */
extern Keymap rl_executing_keymap;
extern Keymap rl_binding_keymap;

/* Display variables. */
/* If non-zero, readline will erase the entire line, including any prompt,
   if the only thing typed on an otherwise-blank line is something bound to
   rl_newline. */
extern int rl_erase_empty_line;

/* If non-zero, the application has already printed the prompt (rl_prompt)
   before calling readline, so readline should not output it the first time
   redisplay is done. */
extern int rl_already_prompted;

/* A non-zero value means to read only this many characters rather than
   up to a character bound to accept-line. */
extern int rl_num_chars_to_read;

/* The text of a currently-executing keyboard macro. */
extern char *rl_executing_macro;

/* Variables to control readline signal handling. */
/* If non-zero, readline will install its own signal handlers for
   SIGINT, SIGTERM, SIGQUIT, SIGALRM, SIGTSTP, SIGTTIN, and SIGTTOU. */
extern int rl_catch_signals;

/* If non-zero, readline will install a signal handler for SIGWINCH
   that also attempts to call any calling application's SIGWINCH signal
   handler.  Note that the terminal is not cleaned up before the
   application's signal handler is called; use rl_cleanup_after_signal()
   to do that. */
extern int rl_catch_sigwinch;

/* Completion variables. */
/* Pointer to the generator function for completion_matches ().
   NULL means to use rl_filename_completion_function (), the default
   filename completer. */
extern rl_compentry_func_t *rl_completion_entry_function;

/* Optional generator for menu completion.  Default is
   rl_completion_entry_function (rl_filename_completion_function). */
 extern rl_compentry_func_t *rl_menu_completion_entry_function;

/* If rl_ignore_some_completions_function is non-NULL it is the address
   of a function to call after all of the possible matches have been
   generated, but before the actual completion is done to the input line.
   The function is called with one argument; a NULL terminated array
   of (char *).  If your function removes any of the elements, they
   must be free()'ed. */
extern rl_compignore_func_t *rl_ignore_some_completions_function;

/* Pointer to alternative function to create matches.
   Function is called with TEXT, START, and END.
   START and END are indices in RL_LINE_BUFFER saying what the boundaries
   of TEXT are.
   If this function exists and returns NULL then call the value of
   rl_completion_entry_function to try to match, otherwise use the
   array of strings returned. */
extern rl_completion_func_t *rl_attempted_completion_function;

/* The basic list of characters that signal a break between words for the
   completer routine.  The initial contents of this variable is what
   breaks words in the shell, i.e. "n\"\\'`@@$>". */
extern const char *rl_basic_word_break_characters;

/* The list of characters that signal a break between words for
   rl_complete_internal.  The default list is the contents of
   rl_basic_word_break_characters.  */
extern /*const*/ char *rl_completer_word_break_characters;

/* Hook function to allow an application to set the completion word
   break characters before readline breaks up the line.  Allows
   position-dependent word break characters. */
extern rl_cpvfunc_t *rl_completion_word_break_hook;

/* List of characters which can be used to quote a substring of the line.
   Completion occurs on the entire substring, and within the substring   
   rl_completer_word_break_characters are treated as any other character,
   unless they also appear within this list. */
extern const char *rl_completer_quote_characters;

/* List of quote characters which cause a word break. */
extern const char *rl_basic_quote_characters;

/* List of characters that need to be quoted in filenames by the completer. */
extern const char *rl_filename_quote_characters;

/* List of characters that are word break characters, but should be left
   in TEXT when it is passed to the completion function.  The shell uses
   this to help determine what kind of completing to do. */
extern const char *rl_special_prefixes;

/* If non-zero, then this is the address of a function to call when
   completing on a directory name.  The function is called with
   the address of a string (the current directory name) as an arg.  It
   changes what is displayed when the possible completions are printed
   or inserted.  The directory completion hook should perform
   any necessary dequoting.  This function should return 1 if it modifies
   the directory name pointer passed as an argument.  If the directory
   completion hook returns 0, it should not modify the directory name
   pointer passed as an argument. */
extern rl_icppfunc_t *rl_directory_completion_hook;

/* If non-zero, this is the address of a function to call when completing
   a directory name.  This function takes the address of the directory name
   to be modified as an argument.  Unlike rl_directory_completion_hook, it
   only modifies the directory name used in opendir(2), not what is displayed
   when the possible completions are printed or inserted.  If set, it takes
   precedence over rl_directory_completion_hook.  The directory rewrite
   hook should perform any necessary dequoting.  This function has the same
   return value properties as the directory_completion_hook.

   I'm not happy with how this works yet, so it's undocumented.  I'm trying
   it in bash to see how well it goes. */
extern rl_icppfunc_t *rl_directory_rewrite_hook;

/* If non-zero, this is the address of a function to call when reading
   directory entries from the filesystem for completion and comparing
   them to the partial word to be completed.  The function should
   either return its first argument (if no conversion takes place) or
   newly-allocated memory.  This can, for instance, convert filenames
   between character sets for comparison against what's typed at the
   keyboard.  The returned value is what is added to the list of
   matches.  The second argument is the length of the filename to be
   converted. */
extern rl_dequote_func_t *rl_filename_rewrite_hook;

/* Backwards compatibility with previous versions of readline. */
#define rl_symbolic_link_hook rl_directory_completion_hook

/* If non-zero, then this is the address of a function to call when
   completing a word would normally display the list of possible matches.
   This function is called instead of actually doing the display.
   It takes three arguments: (char **matches, int num_matches, int max_length)
   where MATCHES is the array of strings that matched, NUM_MATCHES is the
   number of strings in that array, and MAX_LENGTH is the length of the
   longest string in that array. */
extern rl_compdisp_func_t *rl_completion_display_matches_hook;

/* Non-zero means that the results of the matches are to be treated
   as filenames.  This is ALWAYS zero on entry, and can only be changed
   within a completion entry finder function. */
extern int rl_filename_completion_desired;

/* Non-zero means that the results of the matches are to be quoted using
   double quotes (or an application-specific quoting mechanism) if the
   filename contains any characters in rl_word_break_chars.  This is
   ALWAYS non-zero on entry, and can only be changed within a completion
   entry finder function. */
extern int rl_filename_quoting_desired;

/* Set to a function to quote a filename in an application-specific fashion.
   Called with the text to quote, the type of match found (single or multiple)
   and a pointer to the quoting character to be used, which the function can
   reset if desired. */
extern rl_quote_func_t *rl_filename_quoting_function;

/* Function to call to remove quoting characters from a filename.  Called
   before completion is attempted, so the embedded quotes do not interfere
   with matching names in the file system. */
extern rl_dequote_func_t *rl_filename_dequoting_function;

/* Function to call to decide whether or not a word break character is
   quoted.  If a character is quoted, it does not break words for the
   completer. */
extern rl_linebuf_func_t *rl_char_is_quoted_p;

/* Non-zero means to suppress normal filename completion after the
   user-specified completion function has been called. */
extern int rl_attempted_completion_over;

/* Set to a character describing the type of completion being attempted by
   rl_complete_internal; available for use by application completion
   functions. */
extern int rl_completion_type;

/* Set to the last key used to invoke one of the completion functions */
extern int rl_completion_invoking_key;

/* Up to this many items will be displayed in response to a
   possible-completions call.  After that, we ask the user if she
   is sure she wants to see them all.  The default value is 100. */
extern int rl_completion_query_items;

/* Character appended to completed words when at the end of the line.  The
   default is a space.  Nothing is added if this is '\0'. */
extern int rl_completion_append_character;

/* If set to non-zero by an application completion function,
   rl_completion_append_character will not be appended. */
extern int rl_completion_suppress_append;

/* Set to any quote character readline thinks it finds before any application
   completion function is called. */
extern int rl_completion_quote_character;

/* Set to a non-zero value if readline found quoting anywhere in the word to
   be completed; set before any application completion function is called. */
extern int rl_completion_found_quote;

/* If non-zero, the completion functions don't append any closing quote.
   This is set to 0 by rl_complete_internal and may be changed by an
   application-specific completion function. */
extern int rl_completion_suppress_quote;

/* If non-zero, readline will sort the completion matches.  On by default. */
extern int rl_sort_completion_matches;

/* If non-zero, a slash will be appended to completed filenames that are
   symbolic links to directory names, subject to the value of the
   mark-directories variable (which is user-settable).  This exists so
   that application completion functions can override the user's preference
   (set via the mark-symlinked-directories variable) if appropriate.
   It's set to the value of _rl_complete_mark_symlink_dirs in
   rl_complete_internal before any application-specific completion
   function is called, so without that function doing anything, the user's
   preferences are honored. */
extern int rl_completion_mark_symlink_dirs;

/* If non-zero, then disallow duplicates in the matches. */
extern int rl_ignore_completion_duplicates;

/* If this is non-zero, completion is (temporarily) inhibited, and the
   completion character will be inserted as any other. */
extern int rl_inhibit_completion;

/* Input error; can be returned by (*rl_getc_function) if readline is reading
   a top-level command (RL_ISSTATE (RL_STATE_READCMD)). */
#define READERR			(-2)

/* Definitions available for use by readline clients. */
#define RL_PROMPT_START_IGNORE	'\001'
#define RL_PROMPT_END_IGNORE	'\002'

/* Possible values for do_replace argument to rl_filename_quoting_function,
   called by rl_complete_internal. */
#define NO_MATCH        0
#define SINGLE_MATCH    1
#define MULT_MATCH      2

/* Possible state values for rl_readline_state */
#define RL_STATE_NONE		0x000000		/* no state; before first call */

#define RL_STATE_INITIALIZING	0x0000001	/* initializing */
#define RL_STATE_INITIALIZED	0x0000002	/* initialization done */
#define RL_STATE_TERMPREPPED	0x0000004	/* terminal is prepped */
#define RL_STATE_READCMD	0x0000008	/* reading a command key */
#define RL_STATE_METANEXT	0x0000010	/* reading input after ESC */
#define RL_STATE_DISPATCHING	0x0000020	/* dispatching to a command */
#define RL_STATE_MOREINPUT	0x0000040	/* reading more input in a command function */
#define RL_STATE_ISEARCH	0x0000080	/* doing incremental search */
#define RL_STATE_NSEARCH	0x0000100	/* doing non-inc search */
#define RL_STATE_SEARCH		0x0000200	/* doing a history search */
#define RL_STATE_NUMERICARG	0x0000400	/* reading numeric argument */
#define RL_STATE_MACROINPUT	0x0000800	/* getting input from a macro */
#define RL_STATE_MACRODEF	0x0001000	/* defining keyboard macro */
#define RL_STATE_OVERWRITE	0x0002000	/* overwrite mode */
#define RL_STATE_COMPLETING	0x0004000	/* doing completion */
#define RL_STATE_SIGHANDLER	0x0008000	/* in readline sighandler */
#define RL_STATE_UNDOING	0x0010000	/* doing an undo */
#define RL_STATE_INPUTPENDING	0x0020000	/* rl_execute_next called */
#define RL_STATE_TTYCSAVED	0x0040000	/* tty special chars saved */
#define RL_STATE_CALLBACK	0x0080000	/* using the callback interface */
#define RL_STATE_VIMOTION	0x0100000	/* reading vi motion arg */
#define RL_STATE_MULTIKEY	0x0200000	/* reading multiple-key command */
#define RL_STATE_VICMDONCE	0x0400000	/* entered vi command mode at least once */
#define RL_STATE_REDISPLAYING	0x0800000	/* updating terminal display */

#define RL_STATE_DONE		0x1000000	/* done; accepted line */

#define RL_SETSTATE(x)		(rl_readline_state |= (x))
#define RL_UNSETSTATE(x)	(rl_readline_state &= ~(x))
#define RL_ISSTATE(x)		(rl_readline_state & (x))

struct readline_state {
  /* line state */
  int point;
  int end;
  int mark;
  char *buffer;
  int buflen;
  UNDO_LIST *ul;
  char *prompt;

  /* global state */
  int rlstate;
  int done;
  Keymap kmap;

  /* input state */
  rl_command_func_t *lastfunc;
  int insmode;
  int edmode;
  int kseqlen;
  FILE *inf;
  FILE *outf;
  int pendingin;
  char *macro;

  /* signal state */
  int catchsigs;
  int catchsigwinch;

  /* search state */

  /* completion state */

  /* options state */

  /* reserved for future expansion, so the struct size doesn't change */
  char reserved[64];
};

extern int rl_save_state PARAMS((struct readline_state *));
extern int rl_restore_state PARAMS((struct readline_state *));

#ifdef __cplusplus
}
#endif

#endif /* _READLINE_H_ */
@


1.6
log
@Readline 5.1 import for HEAD.
@
text
@d3 1
a3 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
d5 2
a6 2
   This file is part of the GNU Readline Library, a library for
   reading lines of text with interactive input and history editing.
d8 3
a10 3
   The GNU Readline Library is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2, or
d13 3
a15 3
   The GNU Readline Library is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
d18 3
a20 4
   The GNU General Public License is often shipped with GNU software, and
   is generally kept in a file called COPYING or LICENSE.  If you do not
   have a copy of the license, write to the Free Software Foundation,
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
d42 3
a44 3
#define RL_READLINE_VERSION	0x0501		/* Readline 5.1 */
#define RL_VERSION_MAJOR	5
#define RL_VERSION_MINOR	1
d98 1
d154 1
d156 1
d238 1
d426 1
d434 3
a436 1
 
d502 4
d612 4
d669 5
a673 1
   or inserted. */
d680 7
a686 3
   when the possible completions are printed or inserted.  It is called
   before rl_directory_completion_hook.  I'm not happy with how this works
   yet, so it's undocumented. */
d689 11
d749 3
d778 3
d799 4
d816 24
a839 23
#define RL_STATE_INITIALIZING	0x000001	/* initializing */
#define RL_STATE_INITIALIZED	0x000002	/* initialization done */
#define RL_STATE_TERMPREPPED	0x000004	/* terminal is prepped */
#define RL_STATE_READCMD	0x000008	/* reading a command key */
#define RL_STATE_METANEXT	0x000010	/* reading input after ESC */
#define RL_STATE_DISPATCHING	0x000020	/* dispatching to a command */
#define RL_STATE_MOREINPUT	0x000040	/* reading more input in a command function */
#define RL_STATE_ISEARCH	0x000080	/* doing incremental search */
#define RL_STATE_NSEARCH	0x000100	/* doing non-inc search */
#define RL_STATE_SEARCH		0x000200	/* doing a history search */
#define RL_STATE_NUMERICARG	0x000400	/* reading numeric argument */
#define RL_STATE_MACROINPUT	0x000800	/* getting input from a macro */
#define RL_STATE_MACRODEF	0x001000	/* defining keyboard macro */
#define RL_STATE_OVERWRITE	0x002000	/* overwrite mode */
#define RL_STATE_COMPLETING	0x004000	/* doing completion */
#define RL_STATE_SIGHANDLER	0x008000	/* in readline sighandler */
#define RL_STATE_UNDOING	0x010000	/* doing an undo */
#define RL_STATE_INPUTPENDING	0x020000	/* rl_execute_next called */
#define RL_STATE_TTYCSAVED	0x040000	/* tty special chars saved */
#define RL_STATE_CALLBACK	0x080000	/* using the callback interface */
#define RL_STATE_VIMOTION	0x100000	/* reading vi motion arg */
#define RL_STATE_MULTIKEY	0x200000	/* reading multiple-key command */
#define RL_STATE_VICMDONCE	0x400000	/* entered vi command mode at least once */
d841 1
a841 1
#define RL_STATE_DONE		0x800000	/* done; accepted line */
@


1.5
log
@touched all sources to ease import of readline-5.1
@
text
@d3 1
a3 1
/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
d43 3
a45 3
#define RL_READLINE_VERSION	0x0403		/* Readline 4.3 */
#define RL_VERSION_MAJOR	4
#define RL_VERSION_MINOR	3
d163 1
d244 1
d263 2
d297 2
d301 4
a304 1
extern int rl_set_key PARAMS((const char *, rl_command_func_t *, Keymap));
d306 2
d310 3
d375 1
a375 1
#if (defined (__STDC__) || defined (__cplusplus)) && defined (USE_VARARGS) && defined (PREFER_STDARG)
d401 1
d407 1
d535 5
d627 6
a632 1
extern const char *rl_completer_word_break_characters;
d716 5
d729 12
a740 4
/* Up to this many items will be displayed in response to a
   possible-completions call.  After that, we ask the user if she
   is sure she wants to see them all.  The default value is 100. */
extern int rl_completion_query_items;
d771 1
a771 1
#define RL_STATE_NONE		0x00000		/* no state; before first call */
d773 23
a795 18
#define RL_STATE_INITIALIZING	0x00001		/* initializing */
#define RL_STATE_INITIALIZED	0x00002		/* initialization done */
#define RL_STATE_TERMPREPPED	0x00004		/* terminal is prepped */
#define RL_STATE_READCMD	0x00008		/* reading a command key */
#define RL_STATE_METANEXT	0x00010		/* reading input after ESC */
#define RL_STATE_DISPATCHING	0x00020		/* dispatching to a command */
#define RL_STATE_MOREINPUT	0x00040		/* reading more input in a command function */
#define RL_STATE_ISEARCH	0x00080		/* doing incremental search */
#define RL_STATE_NSEARCH	0x00100		/* doing non-inc search */
#define RL_STATE_SEARCH		0x00200		/* doing a history search */
#define RL_STATE_NUMERICARG	0x00400		/* reading numeric argument */
#define RL_STATE_MACROINPUT	0x00800		/* getting input from a macro */
#define RL_STATE_MACRODEF	0x01000		/* defining keyboard macro */
#define RL_STATE_OVERWRITE	0x02000		/* overwrite mode */
#define RL_STATE_COMPLETING	0x04000		/* doing completion */
#define RL_STATE_SIGHANDLER	0x08000		/* in readline sighandler */
#define RL_STATE_UNDOING	0x10000		/* doing an undo */
#define RL_STATE_INPUTPENDING	0x20000		/* rl_execute_next called */
d797 1
a797 1
#define RL_STATE_DONE		0x80000		/* done; accepted line */
d832 6
@


1.5.2.1
log
@Import readline 5.1 on the branch.
@
text
@d3 1
a3 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
d43 3
a45 3
#define RL_READLINE_VERSION	0x0501		/* Readline 5.1 */
#define RL_VERSION_MAJOR	5
#define RL_VERSION_MINOR	1
a162 1
extern int rl_unix_filename_rubout PARAMS((int, int));
a242 1
extern int rl_vi_rubout PARAMS((int, int));
a260 2
extern void rl_vi_start_inserting PARAMS((int, int, int));

a292 2
extern int rl_bind_key_if_unbound PARAMS((int, rl_command_func_t *));
extern int rl_bind_key_if_unbound_in_map PARAMS((int, rl_command_func_t *, Keymap));
d295 1
a295 4
extern int rl_bind_keyseq PARAMS((const char *, rl_command_func_t *));
extern int rl_bind_keyseq_in_map PARAMS((const char *, rl_command_func_t *, Keymap));
extern int rl_bind_keyseq_if_unbound PARAMS((const char *, rl_command_func_t *));
extern int rl_bind_keyseq_if_unbound_in_map PARAMS((const char *, rl_command_func_t *, Keymap));
a296 2

extern char *rl_variable_value PARAMS((const char *));
a298 3
/* Backwards compatibility, use rl_bind_keyseq_in_map instead. */
extern int rl_set_key PARAMS((const char *, rl_command_func_t *, Keymap));

d361 1
a361 1
#if defined (USE_VARARGS) && defined (PREFER_STDARG)
a386 1
extern void rl_tty_unset_default_bindings PARAMS((Keymap));
a391 1
extern void rl_reset_screen_size PARAMS((void));
a518 5
/* If non-zero, Readline gives values of LINES and COLUMNS from the environment
   greater precedence than values fetched from the kernel when computing the
   screen dimensions. */
extern int rl_prefer_env_winsize;

d606 1
a606 6
extern /*const*/ char *rl_completer_word_break_characters;

/* Hook function to allow an application to set the completion word
   break characters before readline breaks up the line.  Allows
   position-dependent word break characters. */
extern rl_cpvfunc_t *rl_completion_word_break_hook;
a689 5
/* Up to this many items will be displayed in response to a
   possible-completions call.  After that, we ask the user if she
   is sure she wants to see them all.  The default value is 100. */
extern int rl_completion_query_items;

d698 4
a701 12
/* Set to any quote character readline thinks it finds before any application
   completion function is called. */
extern int rl_completion_quote_character;

/* Set to a non-zero value if readline found quoting anywhere in the word to
   be completed; set before any application completion function is called. */
extern int rl_completion_found_quote;

/* If non-zero, the completion functions don't append any closing quote.
   This is set to 0 by rl_complete_internal and may be changed by an
   application-specific completion function. */
extern int rl_completion_suppress_quote;
d732 1
a732 1
#define RL_STATE_NONE		0x000000		/* no state; before first call */
d734 18
a751 23
#define RL_STATE_INITIALIZING	0x000001	/* initializing */
#define RL_STATE_INITIALIZED	0x000002	/* initialization done */
#define RL_STATE_TERMPREPPED	0x000004	/* terminal is prepped */
#define RL_STATE_READCMD	0x000008	/* reading a command key */
#define RL_STATE_METANEXT	0x000010	/* reading input after ESC */
#define RL_STATE_DISPATCHING	0x000020	/* dispatching to a command */
#define RL_STATE_MOREINPUT	0x000040	/* reading more input in a command function */
#define RL_STATE_ISEARCH	0x000080	/* doing incremental search */
#define RL_STATE_NSEARCH	0x000100	/* doing non-inc search */
#define RL_STATE_SEARCH		0x000200	/* doing a history search */
#define RL_STATE_NUMERICARG	0x000400	/* reading numeric argument */
#define RL_STATE_MACROINPUT	0x000800	/* getting input from a macro */
#define RL_STATE_MACRODEF	0x001000	/* defining keyboard macro */
#define RL_STATE_OVERWRITE	0x002000	/* overwrite mode */
#define RL_STATE_COMPLETING	0x004000	/* doing completion */
#define RL_STATE_SIGHANDLER	0x008000	/* in readline sighandler */
#define RL_STATE_UNDOING	0x010000	/* doing an undo */
#define RL_STATE_INPUTPENDING	0x020000	/* rl_execute_next called */
#define RL_STATE_TTYCSAVED	0x040000	/* tty special chars saved */
#define RL_STATE_CALLBACK	0x080000	/* using the callback interface */
#define RL_STATE_VIMOTION	0x100000	/* reading vi motion arg */
#define RL_STATE_MULTIKEY	0x200000	/* reading multiple-key command */
#define RL_STATE_VICMDONCE	0x400000	/* entered vi command mode at least once */
d753 1
a753 1
#define RL_STATE_DONE		0x800000	/* done; accepted line */
a787 6
  /* search state */

  /* completion state */

  /* options state */

@


1.4
log
@Import of readline 4.3.
Non-readline modified files:

src/gdb/ChangeLog src/gdb/defs.h src/gdb/cli/cli-cmds.c
src/gdb/cli/cli-setshow.c src/gdb/tui/ChangeLog
src/gdb/tui/tuiWin.c

In readline directory:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@@


1.3
log
@readline:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Locally modified files: Makefile.in, configure.in, configure
        (regenerated), config.h.in (regenerated), readline.h, rltty.c,
 	shell.c signals.c.

        Locally added files: acconfig.h, config/*, config.h.bot,
        cross-build/*, doc/inc-hit.texinfo.

        New files: USAGE, rlprivate.h, rlshell.h, xmalloc.h.
examples:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        New files: excallback.c, rlfe.c.
doc:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Regenerated inc-hist.texinfo as copy of hsuser.texinfo, for
        inclusion in the gdb manual.

        New file: rluserman.texinfo
@
text
@d32 1
d37 1
d42 5
d70 2
a71 2
  char *name;
  Function *function;
d83 2
a84 2
extern int rl_digit_argument __P((int, int));
extern int rl_universal_argument __P((int, int));
d87 13
a99 9
extern int rl_forward __P((int, int));
extern int rl_backward __P((int, int));
extern int rl_beg_of_line __P((int, int));
extern int rl_end_of_line __P((int, int));
extern int rl_forward_word __P((int, int));
extern int rl_backward_word __P((int, int));
extern int rl_refresh_line __P((int, int));
extern int rl_clear_screen __P((int, int));
extern int rl_arrow_keys __P((int, int));
d102 11
a112 11
extern int rl_insert __P((int, int));
extern int rl_quoted_insert __P((int, int));
extern int rl_tab_insert __P((int, int));
extern int rl_newline __P((int, int));
extern int rl_do_lowercase_version __P((int, int));
extern int rl_rubout __P((int, int));
extern int rl_delete __P((int, int));
extern int rl_rubout_or_delete __P((int, int));
extern int rl_delete_horizontal_space __P((int, int));
extern int rl_delete_or_show_completions __P((int, int));
extern int rl_insert_comment __P((int, int));
d115 3
a117 3
extern int rl_upcase_word __P((int, int));
extern int rl_downcase_word __P((int, int));
extern int rl_capitalize_word __P((int, int));
d120 2
a121 2
extern int rl_transpose_words __P((int, int));
extern int rl_transpose_chars __P((int, int));
d124 2
a125 2
extern int rl_char_search __P((int, int));
extern int rl_backward_char_search __P((int, int));
d128 4
a131 4
extern int rl_beginning_of_history __P((int, int));
extern int rl_end_of_history __P((int, int));
extern int rl_get_next_history __P((int, int));
extern int rl_get_previous_history __P((int, int));
d134 2
a135 2
extern int rl_set_mark __P((int, int));
extern int rl_exchange_point_and_mark __P((int, int));
d138 5
a142 2
extern int rl_vi_editing_mode __P((int, int));
extern int rl_emacs_editing_mode __P((int, int));
d145 4
a148 4
extern int rl_re_read_init_file __P((int, int));
extern int rl_dump_functions __P((int, int));
extern int rl_dump_macros __P((int, int));
extern int rl_dump_variables __P((int, int));
d151 4
a154 4
extern int rl_complete __P((int, int));
extern int rl_possible_completions __P((int, int));
extern int rl_insert_completions __P((int, int));
extern int rl_menu_complete __P((int, int));
d157 18
a174 18
extern int rl_kill_word __P((int, int));
extern int rl_backward_kill_word __P((int, int));
extern int rl_kill_line __P((int, int));
extern int rl_backward_kill_line __P((int, int));
extern int rl_kill_full_line __P((int, int));
extern int rl_unix_word_rubout __P((int, int));
extern int rl_unix_line_discard __P((int, int));
extern int rl_copy_region_to_kill __P((int, int));
extern int rl_kill_region __P((int, int));
extern int rl_copy_forward_word __P((int, int));
extern int rl_copy_backward_word __P((int, int));
extern int rl_yank __P((int, int));
extern int rl_yank_pop __P((int, int));
extern int rl_yank_nth_arg __P((int, int));
extern int rl_yank_last_arg __P((int, int));
/* Not available unless __CYGWIN32__ is defined. */
#ifdef __CYGWIN32__
extern int rl_paste_from_clipboard __P((int, int));
d178 2
a179 2
extern int rl_reverse_search_history __P((int, int));
extern int rl_forward_search_history __P((int, int));
d182 3
a184 3
extern int rl_start_kbd_macro __P((int, int));
extern int rl_end_kbd_macro __P((int, int));
extern int rl_call_last_kbd_macro __P((int, int));
d187 2
a188 2
extern int rl_revert_line __P((int, int));
extern int rl_undo_command __P((int, int));
d191 1
a191 1
extern int rl_tilde_expand __P((int, int));
d194 2
a195 2
extern int rl_restart_output __P((int, int));
extern int rl_stop_output __P((int, int));
d198 2
a199 2
extern int rl_abort __P((int, int));
extern int rl_tty_status __P((int, int));
d202 6
a207 6
extern int rl_history_search_forward __P((int, int));
extern int rl_history_search_backward __P((int, int));
extern int rl_noninc_forward_search __P((int, int));
extern int rl_noninc_reverse_search __P((int, int));
extern int rl_noninc_forward_search_again __P((int, int));
extern int rl_noninc_reverse_search_again __P((int, int));
d210 1
a210 1
extern int rl_insert_close __P((int, int));
d213 3
a215 3
extern void rl_callback_handler_install __P((char *, VFunction *));
extern void rl_callback_read_char __P((void));
extern void rl_callback_handler_remove __P((void));
d219 36
a254 36
extern int rl_vi_redo __P((int, int));
extern int rl_vi_undo __P((int, int));
extern int rl_vi_yank_arg __P((int, int));
extern int rl_vi_fetch_history __P((int, int));
extern int rl_vi_search_again __P((int, int));
extern int rl_vi_search __P((int, int));
extern int rl_vi_complete __P((int, int));
extern int rl_vi_tilde_expand __P((int, int));
extern int rl_vi_prev_word __P((int, int));
extern int rl_vi_next_word __P((int, int));
extern int rl_vi_end_word __P((int, int));
extern int rl_vi_insert_beg __P((int, int));
extern int rl_vi_append_mode __P((int, int));
extern int rl_vi_append_eol __P((int, int));
extern int rl_vi_eof_maybe __P((int, int));
extern int rl_vi_insertion_mode __P((int, int));
extern int rl_vi_movement_mode __P((int, int));
extern int rl_vi_arg_digit __P((int, int));
extern int rl_vi_change_case __P((int, int));
extern int rl_vi_put __P((int, int));
extern int rl_vi_column __P((int, int));
extern int rl_vi_delete_to __P((int, int));
extern int rl_vi_change_to __P((int, int));
extern int rl_vi_yank_to __P((int, int));
extern int rl_vi_delete __P((int, int));
extern int rl_vi_back_to_indent __P((int, int));
extern int rl_vi_first_print __P((int, int));
extern int rl_vi_char_search __P((int, int));
extern int rl_vi_match __P((int, int));
extern int rl_vi_change_char __P((int, int));
extern int rl_vi_subst __P((int, int));
extern int rl_vi_overstrike __P((int, int));
extern int rl_vi_overstrike_delete __P((int, int));
extern int rl_vi_replace __P((int, int));
extern int rl_vi_set_mark __P((int, int));
extern int rl_vi_goto_mark __P((int, int));
d257 3
a259 3
extern int rl_vi_check __P((void));
extern int rl_vi_domove __P((int, int *));
extern int rl_vi_bracktype __P((int));
d262 6
a267 6
extern int rl_vi_fWord __P((int, int));
extern int rl_vi_bWord __P((int, int));
extern int rl_vi_eWord __P((int, int));
extern int rl_vi_fword __P((int, int));
extern int rl_vi_bword __P((int, int));
extern int rl_vi_eword __P((int, int));
d277 1
a277 1
extern char *readline __P((char *));
d279 2
a280 1
extern int rl_initialize __P((void));
d282 4
a285 1
extern int rl_discard_argument __P((void));
d288 10
a297 10
extern int rl_add_defun __P((char *, Function *, int));
extern int rl_bind_key __P((int, Function *));
extern int rl_bind_key_in_map __P((int, Function *, Keymap));
extern int rl_unbind_key __P((int));
extern int rl_unbind_key_in_map __P((int, Keymap));
extern int rl_unbind_function_in_map __P((Function *, Keymap));
extern int rl_unbind_command_in_map __P((char *, Keymap));
extern int rl_set_key __P((char *, Function *, Keymap));
extern int rl_generic_bind __P((int, char *, char *, Keymap));
extern int rl_variable_bind __P((char *, char *));
d300 1
a300 1
extern int rl_macro_bind __P((char *, char *, Keymap));
d303 2
a304 2
extern int rl_translate_keyseq __P((char *, char *, int *));
extern char *rl_untranslate_keyseq __P((int));
d306 2
a307 2
extern Function *rl_named_function __P((char *));
extern Function *rl_function_of_keyseq __P((char *, Keymap, int *));
d309 3
a311 3
extern void rl_list_funmap_names __P((void));
extern char **rl_invoking_keyseqs_in_map __P((Function *, Keymap));
extern char **rl_invoking_keyseqs __P((Function *));
d313 3
a315 3
extern void rl_function_dumper __P((int));
extern void rl_macro_dumper __P((int));
extern void rl_variable_dumper __P((int));
d317 2
a318 2
extern int rl_read_init_file __P((char *));
extern int rl_parse_and_bind __P((char *));
d321 12
a332 11
extern Keymap rl_make_bare_keymap __P((void));
extern Keymap rl_copy_keymap __P((Keymap));
extern Keymap rl_make_keymap __P((void));
extern void rl_discard_keymap __P((Keymap));

extern Keymap rl_get_keymap_by_name __P((char *));
extern char *rl_get_keymap_name __P((Keymap));
extern void rl_set_keymap __P((Keymap));
extern Keymap rl_get_keymap __P((void));
extern void rl_set_keymap_from_edit_mode __P((void));
extern char *rl_get_keymap_name_from_edit_mode __P((void));
d335 5
a339 3
extern int rl_add_funmap_entry __P((char *, Function *));
extern void rl_initialize_funmap __P((void));
extern char **rl_funmap_names __P((void));
d342 1
a342 1
extern void rl_push_macro_input __P((char *));
d345 6
a350 6
extern void rl_add_undo __P((enum undo_code, int, int, char *));
extern void free_undo_list __P((void));
extern int rl_do_undo __P((void));
extern int rl_begin_undo_group __P((void));
extern int rl_end_undo_group __P((void));
extern int rl_modifying __P((int, int));
d353 7
a359 6
extern void rl_redisplay __P((void));
extern int rl_on_new_line __P((void));
extern int rl_on_new_line_with_prompt __P((void));
extern int rl_forced_update_display __P((void));
extern int rl_clear_message __P((void));
extern int rl_reset_line_state __P((void));
d362 1
a362 1
extern int rl_message (const char *, ...);
d367 2
d370 1
a370 3
extern int rl_show_char __P((int));
extern int rl_character_len __P((int, int));
extern int crlf __P((void));
d373 2
a374 2
extern void rl_save_prompt __P((void));
extern void rl_restore_prompt __P((void));
d377 5
a381 4
extern int rl_insert_text __P((char *));
extern int rl_delete_text __P((int, int));
extern int rl_kill_text __P((int, int));
extern char *rl_copy_text __P((int, int));
d384 8
a391 3
extern void rl_prep_terminal __P((int));
extern void rl_deprep_terminal __P((void));
extern void rltty_set_default_bindings __P((Keymap));
d393 9
a401 2
extern int rl_reset_terminal __P((char *));
extern void rl_resize_terminal __P((void));
d404 3
a406 8
extern void rl_extend_line_buffer __P((int));
extern int ding __P((void));

/* Functions for character input. */
extern int rl_stuff_char __P((int));
extern int rl_execute_next __P((int));
extern int rl_read_key __P((void));
extern int rl_getc __P((FILE *));
d409 5
a413 5
extern int rl_set_signals __P((void));
extern int rl_clear_signals __P((void));
extern void rl_cleanup_after_signal __P((void));
extern void rl_reset_after_signal __P((void));
extern void rl_free_line_state __P((void));
d415 2
d418 7
a424 1
extern int rl_expand_prompt __P((char *));
d426 3
a428 3
extern int maybe_save_line __P((void));
extern int maybe_unsave_line __P((void));
extern int maybe_replace_line __P((void));
d430 1
a430 3
/* Completion functions. */
extern int rl_complete_internal __P((int));
extern void rl_display_match_list __P((char **, int, int));
d432 15
a446 3
extern char **completion_matches __P((char *, CPFunction *));
extern char *username_completion_function __P((char *, int));
extern char *filename_completion_function __P((char *, int));
d455 2
a456 1
extern char *rl_library_version;
d461 11
d474 1
a474 1
extern char *rl_readline_name;
d484 2
a485 1
extern int rl_point, rl_end;
d502 10
d513 1
a513 1
extern char *rl_terminal_name;
d516 2
a517 1
extern FILE *rl_instream, *rl_outstream;
d521 1
a521 1
extern Function *rl_startup_hook;
d526 1
a526 1
extern Function *rl_pre_input_hook;
d530 5
a534 1
extern Function *rl_event_hook;
d536 4
a539 4
extern Function *rl_getc_function;
extern VFunction *rl_redisplay_function;
extern VFunction *rl_prep_term_function;
extern VFunction *rl_deprep_term_function;
d560 3
d577 3
a579 3
   NULL means to use filename_entry_function (), the default filename
   completer. */
extern Function *rl_completion_entry_function;
d587 1
a587 1
extern Function *rl_ignore_some_completions_function;
d596 1
a596 1
extern CPPFunction *rl_attempted_completion_function;
d601 1
a601 1
extern char *rl_basic_word_break_characters;
d606 1
a606 1
extern char *rl_completer_word_break_characters;
d612 1
a612 1
extern char *rl_completer_quote_characters;
d615 1
a615 1
extern char *rl_basic_quote_characters;
d618 1
a618 1
extern char *rl_filename_quote_characters;
d623 1
a623 1
extern char *rl_special_prefixes;
d627 13
a639 2
   the address of a string (the current directory name) as an arg. */
extern Function *rl_directory_completion_hook;
d651 1
a651 1
extern VFunction *rl_completion_display_matches_hook;
d669 1
a669 1
extern CPFunction *rl_filename_quoting_function;
d674 1
a674 1
extern CPFunction *rl_filename_dequoting_function;
d679 1
a679 1
extern Function *rl_char_is_quoted_p;
d694 4
d703 11
d720 1
a720 1
   
d731 63
a793 5
#if 0
#if !defined (savestring)
extern char *savestring __P((char *));	/* XXX backwards compatibility */
#endif
#endif
@


1.3.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a31 1
#  include "rltypedefs.h"
a35 1
#  include <readline/rltypedefs.h>
a39 5
/* Hex-encoded Readline version number. */
#define RL_READLINE_VERSION	0x0403		/* Readline 4.3 */
#define RL_VERSION_MAJOR	4
#define RL_VERSION_MINOR	3

d63 2
a64 2
  const char *name;
  rl_command_func_t *function;
d76 2
a77 2
extern int rl_digit_argument PARAMS((int, int));
extern int rl_universal_argument PARAMS((int, int));
d80 9
a88 13
extern int rl_forward_byte PARAMS((int, int));
extern int rl_forward_char PARAMS((int, int));
extern int rl_forward PARAMS((int, int));
extern int rl_backward_byte PARAMS((int, int));
extern int rl_backward_char PARAMS((int, int));
extern int rl_backward PARAMS((int, int));
extern int rl_beg_of_line PARAMS((int, int));
extern int rl_end_of_line PARAMS((int, int));
extern int rl_forward_word PARAMS((int, int));
extern int rl_backward_word PARAMS((int, int));
extern int rl_refresh_line PARAMS((int, int));
extern int rl_clear_screen PARAMS((int, int));
extern int rl_arrow_keys PARAMS((int, int));
d91 11
a101 11
extern int rl_insert PARAMS((int, int));
extern int rl_quoted_insert PARAMS((int, int));
extern int rl_tab_insert PARAMS((int, int));
extern int rl_newline PARAMS((int, int));
extern int rl_do_lowercase_version PARAMS((int, int));
extern int rl_rubout PARAMS((int, int));
extern int rl_delete PARAMS((int, int));
extern int rl_rubout_or_delete PARAMS((int, int));
extern int rl_delete_horizontal_space PARAMS((int, int));
extern int rl_delete_or_show_completions PARAMS((int, int));
extern int rl_insert_comment PARAMS((int, int));
d104 3
a106 3
extern int rl_upcase_word PARAMS((int, int));
extern int rl_downcase_word PARAMS((int, int));
extern int rl_capitalize_word PARAMS((int, int));
d109 2
a110 2
extern int rl_transpose_words PARAMS((int, int));
extern int rl_transpose_chars PARAMS((int, int));
d113 2
a114 2
extern int rl_char_search PARAMS((int, int));
extern int rl_backward_char_search PARAMS((int, int));
d117 4
a120 4
extern int rl_beginning_of_history PARAMS((int, int));
extern int rl_end_of_history PARAMS((int, int));
extern int rl_get_next_history PARAMS((int, int));
extern int rl_get_previous_history PARAMS((int, int));
d123 2
a124 2
extern int rl_set_mark PARAMS((int, int));
extern int rl_exchange_point_and_mark PARAMS((int, int));
d127 2
a128 5
extern int rl_vi_editing_mode PARAMS((int, int));
extern int rl_emacs_editing_mode PARAMS((int, int));

/* Bindable commands to change the insert mode (insert or overwrite) */
extern int rl_overwrite_mode PARAMS((int, int));
d131 4
a134 4
extern int rl_re_read_init_file PARAMS((int, int));
extern int rl_dump_functions PARAMS((int, int));
extern int rl_dump_macros PARAMS((int, int));
extern int rl_dump_variables PARAMS((int, int));
d137 4
a140 4
extern int rl_complete PARAMS((int, int));
extern int rl_possible_completions PARAMS((int, int));
extern int rl_insert_completions PARAMS((int, int));
extern int rl_menu_complete PARAMS((int, int));
d143 18
a160 18
extern int rl_kill_word PARAMS((int, int));
extern int rl_backward_kill_word PARAMS((int, int));
extern int rl_kill_line PARAMS((int, int));
extern int rl_backward_kill_line PARAMS((int, int));
extern int rl_kill_full_line PARAMS((int, int));
extern int rl_unix_word_rubout PARAMS((int, int));
extern int rl_unix_line_discard PARAMS((int, int));
extern int rl_copy_region_to_kill PARAMS((int, int));
extern int rl_kill_region PARAMS((int, int));
extern int rl_copy_forward_word PARAMS((int, int));
extern int rl_copy_backward_word PARAMS((int, int));
extern int rl_yank PARAMS((int, int));
extern int rl_yank_pop PARAMS((int, int));
extern int rl_yank_nth_arg PARAMS((int, int));
extern int rl_yank_last_arg PARAMS((int, int));
/* Not available unless __CYGWIN__ is defined. */
#ifdef __CYGWIN__
extern int rl_paste_from_clipboard PARAMS((int, int));
d164 2
a165 2
extern int rl_reverse_search_history PARAMS((int, int));
extern int rl_forward_search_history PARAMS((int, int));
d168 3
a170 3
extern int rl_start_kbd_macro PARAMS((int, int));
extern int rl_end_kbd_macro PARAMS((int, int));
extern int rl_call_last_kbd_macro PARAMS((int, int));
d173 2
a174 2
extern int rl_revert_line PARAMS((int, int));
extern int rl_undo_command PARAMS((int, int));
d177 1
a177 1
extern int rl_tilde_expand PARAMS((int, int));
d180 2
a181 2
extern int rl_restart_output PARAMS((int, int));
extern int rl_stop_output PARAMS((int, int));
d184 2
a185 2
extern int rl_abort PARAMS((int, int));
extern int rl_tty_status PARAMS((int, int));
d188 6
a193 6
extern int rl_history_search_forward PARAMS((int, int));
extern int rl_history_search_backward PARAMS((int, int));
extern int rl_noninc_forward_search PARAMS((int, int));
extern int rl_noninc_reverse_search PARAMS((int, int));
extern int rl_noninc_forward_search_again PARAMS((int, int));
extern int rl_noninc_reverse_search_again PARAMS((int, int));
d196 1
a196 1
extern int rl_insert_close PARAMS((int, int));
d199 3
a201 3
extern void rl_callback_handler_install PARAMS((const char *, rl_vcpfunc_t *));
extern void rl_callback_read_char PARAMS((void));
extern void rl_callback_handler_remove PARAMS((void));
d205 36
a240 36
extern int rl_vi_redo PARAMS((int, int));
extern int rl_vi_undo PARAMS((int, int));
extern int rl_vi_yank_arg PARAMS((int, int));
extern int rl_vi_fetch_history PARAMS((int, int));
extern int rl_vi_search_again PARAMS((int, int));
extern int rl_vi_search PARAMS((int, int));
extern int rl_vi_complete PARAMS((int, int));
extern int rl_vi_tilde_expand PARAMS((int, int));
extern int rl_vi_prev_word PARAMS((int, int));
extern int rl_vi_next_word PARAMS((int, int));
extern int rl_vi_end_word PARAMS((int, int));
extern int rl_vi_insert_beg PARAMS((int, int));
extern int rl_vi_append_mode PARAMS((int, int));
extern int rl_vi_append_eol PARAMS((int, int));
extern int rl_vi_eof_maybe PARAMS((int, int));
extern int rl_vi_insertion_mode PARAMS((int, int));
extern int rl_vi_movement_mode PARAMS((int, int));
extern int rl_vi_arg_digit PARAMS((int, int));
extern int rl_vi_change_case PARAMS((int, int));
extern int rl_vi_put PARAMS((int, int));
extern int rl_vi_column PARAMS((int, int));
extern int rl_vi_delete_to PARAMS((int, int));
extern int rl_vi_change_to PARAMS((int, int));
extern int rl_vi_yank_to PARAMS((int, int));
extern int rl_vi_delete PARAMS((int, int));
extern int rl_vi_back_to_indent PARAMS((int, int));
extern int rl_vi_first_print PARAMS((int, int));
extern int rl_vi_char_search PARAMS((int, int));
extern int rl_vi_match PARAMS((int, int));
extern int rl_vi_change_char PARAMS((int, int));
extern int rl_vi_subst PARAMS((int, int));
extern int rl_vi_overstrike PARAMS((int, int));
extern int rl_vi_overstrike_delete PARAMS((int, int));
extern int rl_vi_replace PARAMS((int, int));
extern int rl_vi_set_mark PARAMS((int, int));
extern int rl_vi_goto_mark PARAMS((int, int));
d243 3
a245 3
extern int rl_vi_check PARAMS((void));
extern int rl_vi_domove PARAMS((int, int *));
extern int rl_vi_bracktype PARAMS((int));
d248 6
a253 6
extern int rl_vi_fWord PARAMS((int, int));
extern int rl_vi_bWord PARAMS((int, int));
extern int rl_vi_eWord PARAMS((int, int));
extern int rl_vi_fword PARAMS((int, int));
extern int rl_vi_bword PARAMS((int, int));
extern int rl_vi_eword PARAMS((int, int));
d263 1
a263 1
extern char *readline PARAMS((const char *));
d265 1
a265 2
extern int rl_set_prompt PARAMS((const char *));
extern int rl_expand_prompt PARAMS((char *));
d267 1
a267 4
extern int rl_initialize PARAMS((void));

/* Undocumented; unused by readline */
extern int rl_discard_argument PARAMS((void));
d270 10
a279 10
extern int rl_add_defun PARAMS((const char *, rl_command_func_t *, int));
extern int rl_bind_key PARAMS((int, rl_command_func_t *));
extern int rl_bind_key_in_map PARAMS((int, rl_command_func_t *, Keymap));
extern int rl_unbind_key PARAMS((int));
extern int rl_unbind_key_in_map PARAMS((int, Keymap));
extern int rl_unbind_function_in_map PARAMS((rl_command_func_t *, Keymap));
extern int rl_unbind_command_in_map PARAMS((const char *, Keymap));
extern int rl_set_key PARAMS((const char *, rl_command_func_t *, Keymap));
extern int rl_generic_bind PARAMS((int, const char *, char *, Keymap));
extern int rl_variable_bind PARAMS((const char *, const char *));
d282 1
a282 1
extern int rl_macro_bind PARAMS((const char *, const char *, Keymap));
d285 2
a286 2
extern int rl_translate_keyseq PARAMS((const char *, char *, int *));
extern char *rl_untranslate_keyseq PARAMS((int));
d288 2
a289 2
extern rl_command_func_t *rl_named_function PARAMS((const char *));
extern rl_command_func_t *rl_function_of_keyseq PARAMS((const char *, Keymap, int *));
d291 3
a293 3
extern void rl_list_funmap_names PARAMS((void));
extern char **rl_invoking_keyseqs_in_map PARAMS((rl_command_func_t *, Keymap));
extern char **rl_invoking_keyseqs PARAMS((rl_command_func_t *));
d295 3
a297 3
extern void rl_function_dumper PARAMS((int));
extern void rl_macro_dumper PARAMS((int));
extern void rl_variable_dumper PARAMS((int));
d299 2
a300 2
extern int rl_read_init_file PARAMS((const char *));
extern int rl_parse_and_bind PARAMS((char *));
d303 11
a313 12
extern Keymap rl_make_bare_keymap PARAMS((void));
extern Keymap rl_copy_keymap PARAMS((Keymap));
extern Keymap rl_make_keymap PARAMS((void));
extern void rl_discard_keymap PARAMS((Keymap));

extern Keymap rl_get_keymap_by_name PARAMS((const char *));
extern char *rl_get_keymap_name PARAMS((Keymap));
extern void rl_set_keymap PARAMS((Keymap));
extern Keymap rl_get_keymap PARAMS((void));
/* Undocumented; used internally only. */
extern void rl_set_keymap_from_edit_mode PARAMS((void));
extern char *rl_get_keymap_name_from_edit_mode PARAMS((void));
d316 3
a318 5
extern int rl_add_funmap_entry PARAMS((const char *, rl_command_func_t *));
extern const char **rl_funmap_names PARAMS((void));
/* Undocumented, only used internally -- there is only one funmap, and this
   function may be called only once. */
extern void rl_initialize_funmap PARAMS((void));
d321 1
a321 1
extern void rl_push_macro_input PARAMS((char *));
d324 6
a329 6
extern void rl_add_undo PARAMS((enum undo_code, int, int, char *));
extern void rl_free_undo_list PARAMS((void));
extern int rl_do_undo PARAMS((void));
extern int rl_begin_undo_group PARAMS((void));
extern int rl_end_undo_group PARAMS((void));
extern int rl_modifying PARAMS((int, int));
d332 6
a337 7
extern void rl_redisplay PARAMS((void));
extern int rl_on_new_line PARAMS((void));
extern int rl_on_new_line_with_prompt PARAMS((void));
extern int rl_forced_update_display PARAMS((void));
extern int rl_clear_message PARAMS((void));
extern int rl_reset_line_state PARAMS((void));
extern int rl_crlf PARAMS((void));
d340 1
a340 1
extern int rl_message (const char *, ...)  __attribute__((__format__ (printf, 1, 2)));
a344 2
extern int rl_show_char PARAMS((int));

d346 3
a348 1
extern int rl_character_len PARAMS((int, int));
d351 2
a352 2
extern void rl_save_prompt PARAMS((void));
extern void rl_restore_prompt PARAMS((void));
d355 4
a358 5
extern void rl_replace_line PARAMS((const char *, int));
extern int rl_insert_text PARAMS((const char *));
extern int rl_delete_text PARAMS((int, int));
extern int rl_kill_text PARAMS((int, int));
extern char *rl_copy_text PARAMS((int, int));
d361 3
a363 8
extern void rl_prep_terminal PARAMS((int));
extern void rl_deprep_terminal PARAMS((void));
extern void rl_tty_set_default_bindings PARAMS((Keymap));

extern int rl_reset_terminal PARAMS((const char *));
extern void rl_resize_terminal PARAMS((void));
extern void rl_set_screen_size PARAMS((int, int));
extern void rl_get_screen_size PARAMS((int *, int *));
d365 6
a370 1
extern char *rl_get_termcap PARAMS((const char *));
d373 4
a376 11
extern int rl_stuff_char PARAMS((int));
extern int rl_execute_next PARAMS((int));
extern int rl_clear_pending_input PARAMS((void));
extern int rl_read_key PARAMS((void));
extern int rl_getc PARAMS((FILE *));
extern int rl_set_keyboard_input_timeout PARAMS((int));

/* `Public' utility functions . */
extern void rl_extend_line_buffer PARAMS((int));
extern int rl_ding PARAMS((void));
extern int rl_alphabetic PARAMS((int));
d379 5
a383 5
extern int rl_set_signals PARAMS((void));
extern int rl_clear_signals PARAMS((void));
extern void rl_cleanup_after_signal PARAMS((void));
extern void rl_reset_after_signal PARAMS((void));
extern void rl_free_line_state PARAMS((void));
d385 2
a386 1
extern int rl_set_paren_blink_timeout PARAMS((int));
d388 3
a390 4
/* Undocumented. */
extern int rl_maybe_save_line PARAMS((void));
extern int rl_maybe_unsave_line PARAMS((void));
extern int rl_maybe_replace_line PARAMS((void));
d393 2
a394 8
extern int rl_complete_internal PARAMS((int));
extern void rl_display_match_list PARAMS((char **, int, int));

extern char **rl_completion_matches PARAMS((const char *, rl_compentry_func_t *));
extern char *rl_username_completion_function PARAMS((const char *, int));
extern char *rl_filename_completion_function PARAMS((const char *, int));

extern int rl_completion_mode PARAMS((rl_command_func_t *));
d396 3
a398 15
#if 0
/* Backwards compatibility (compat.c).  These will go away sometime. */
extern void free_undo_list PARAMS((void));
extern int maybe_save_line PARAMS((void));
extern int maybe_unsave_line PARAMS((void));
extern int maybe_replace_line PARAMS((void));

extern int ding PARAMS((void));
extern int alphabetic PARAMS((int));
extern int crlf PARAMS((void));

extern char **completion_matches PARAMS((char *, rl_compentry_func_t *));
extern char *username_completion_function PARAMS((const char *, int));
extern char *filename_completion_function PARAMS((const char *, int));
#endif
d407 1
a407 2
extern const char *rl_library_version;		/* e.g., "4.2" */
extern int rl_readline_version;			/* e.g., 0x0402 */
a411 11
/* Flags word encapsulating the current readline state. */
extern int rl_readline_state;

/* Says which editing mode readline is currently using.  1 means emacs mode;
   0 means vi mode. */
extern int rl_editing_mode;

/* Insert or overwrite mode for emacs mode.  1 means insert mode; 0 means
   overwrite mode.  Reset to insert mode on each input line. */
extern int rl_insert_mode;

d414 1
a414 1
extern const char *rl_readline_name;
d424 1
a424 2
extern int rl_point;
extern int rl_end;
a440 10
/* Non-zero if the user typed a numeric argument before executing the
   current function. */
extern int rl_explicit_arg;

/* The current value of the numeric argument specified by the user. */
extern int rl_numeric_arg;

/* The address of the last command function Readline executed. */
extern rl_command_func_t *rl_last_func;

d442 1
a442 1
extern const char *rl_terminal_name;
d445 1
a445 2
extern FILE *rl_instream;
extern FILE *rl_outstream;
d449 1
a449 1
extern rl_hook_func_t *rl_startup_hook;
d454 1
a454 1
extern rl_hook_func_t *rl_pre_input_hook;
d458 1
a458 5
extern rl_hook_func_t *rl_event_hook;

/* The address of the function to call to fetch a character from the current
   Readline input stream */
extern rl_getc_func_t *rl_getc_function;
d460 4
a463 4
extern rl_voidfunc_t *rl_redisplay_function;

extern rl_vintfunc_t *rl_prep_term_function;
extern rl_voidfunc_t *rl_deprep_term_function;
a483 3
/* The text of a currently-executing keyboard macro. */
extern char *rl_executing_macro;

d498 3
a500 3
   NULL means to use rl_filename_completion_function (), the default
   filename completer. */
extern rl_compentry_func_t *rl_completion_entry_function;
d508 1
a508 1
extern rl_compignore_func_t *rl_ignore_some_completions_function;
d517 1
a517 1
extern rl_completion_func_t *rl_attempted_completion_function;
d522 1
a522 1
extern const char *rl_basic_word_break_characters;
d527 1
a527 1
extern const char *rl_completer_word_break_characters;
d533 1
a533 1
extern const char *rl_completer_quote_characters;
d536 1
a536 1
extern const char *rl_basic_quote_characters;
d539 1
a539 1
extern const char *rl_filename_quote_characters;
d544 1
a544 1
extern const char *rl_special_prefixes;
d548 2
a549 13
   the address of a string (the current directory name) as an arg.  It
   changes what is displayed when the possible completions are printed
   or inserted. */
extern rl_icppfunc_t *rl_directory_completion_hook;

/* If non-zero, this is the address of a function to call when completing
   a directory name.  This function takes the address of the directory name
   to be modified as an argument.  Unlike rl_directory_completion_hook, it
   only modifies the directory name used in opendir(2), not what is displayed
   when the possible completions are printed or inserted.  It is called
   before rl_directory_completion_hook.  I'm not happy with how this works
   yet, so it's undocumented. */
extern rl_icppfunc_t *rl_directory_rewrite_hook;
d561 1
a561 1
extern rl_compdisp_func_t *rl_completion_display_matches_hook;
d579 1
a579 1
extern rl_quote_func_t *rl_filename_quoting_function;
d584 1
a584 1
extern rl_dequote_func_t *rl_filename_dequoting_function;
d589 1
a589 1
extern rl_linebuf_func_t *rl_char_is_quoted_p;
a603 4
/* If set to non-zero by an application completion function,
   rl_completion_append_character will not be appended. */
extern int rl_completion_suppress_append;

a608 11
/* If non-zero, a slash will be appended to completed filenames that are
   symbolic links to directory names, subject to the value of the
   mark-directories variable (which is user-settable).  This exists so
   that application completion functions can override the user's preference
   (set via the mark-symlinked-directories variable) if appropriate.
   It's set to the value of _rl_complete_mark_symlink_dirs in
   rl_complete_internal before any application-specific completion
   function is called, so without that function doing anything, the user's
   preferences are honored. */
extern int rl_completion_mark_symlink_dirs;

d615 1
a615 1

d626 5
a630 63
/* Possible state values for rl_readline_state */
#define RL_STATE_NONE		0x00000		/* no state; before first call */

#define RL_STATE_INITIALIZING	0x00001		/* initializing */
#define RL_STATE_INITIALIZED	0x00002		/* initialization done */
#define RL_STATE_TERMPREPPED	0x00004		/* terminal is prepped */
#define RL_STATE_READCMD	0x00008		/* reading a command key */
#define RL_STATE_METANEXT	0x00010		/* reading input after ESC */
#define RL_STATE_DISPATCHING	0x00020		/* dispatching to a command */
#define RL_STATE_MOREINPUT	0x00040		/* reading more input in a command function */
#define RL_STATE_ISEARCH	0x00080		/* doing incremental search */
#define RL_STATE_NSEARCH	0x00100		/* doing non-inc search */
#define RL_STATE_SEARCH		0x00200		/* doing a history search */
#define RL_STATE_NUMERICARG	0x00400		/* reading numeric argument */
#define RL_STATE_MACROINPUT	0x00800		/* getting input from a macro */
#define RL_STATE_MACRODEF	0x01000		/* defining keyboard macro */
#define RL_STATE_OVERWRITE	0x02000		/* overwrite mode */
#define RL_STATE_COMPLETING	0x04000		/* doing completion */
#define RL_STATE_SIGHANDLER	0x08000		/* in readline sighandler */
#define RL_STATE_UNDOING	0x10000		/* doing an undo */
#define RL_STATE_INPUTPENDING	0x20000		/* rl_execute_next called */

#define RL_STATE_DONE		0x80000		/* done; accepted line */

#define RL_SETSTATE(x)		(rl_readline_state |= (x))
#define RL_UNSETSTATE(x)	(rl_readline_state &= ~(x))
#define RL_ISSTATE(x)		(rl_readline_state & (x))

struct readline_state {
  /* line state */
  int point;
  int end;
  int mark;
  char *buffer;
  int buflen;
  UNDO_LIST *ul;
  char *prompt;

  /* global state */
  int rlstate;
  int done;
  Keymap kmap;

  /* input state */
  rl_command_func_t *lastfunc;
  int insmode;
  int edmode;
  int kseqlen;
  FILE *inf;
  FILE *outf;
  int pendingin;
  char *macro;

  /* signal state */
  int catchsigs;
  int catchsigwinch;

  /* reserved for future expansion, so the struct size doesn't change */
  char reserved[64];
};

extern int rl_save_state PARAMS((struct readline_state *));
extern int rl_restore_state PARAMS((struct readline_state *));
@


1.3.22.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a31 1
#  include "rltypedefs.h"
a35 1
#  include <readline/rltypedefs.h>
a39 5
/* Hex-encoded Readline version number. */
#define RL_READLINE_VERSION	0x0403		/* Readline 4.3 */
#define RL_VERSION_MAJOR	4
#define RL_VERSION_MINOR	3

d63 2
a64 2
  const char *name;
  rl_command_func_t *function;
d76 2
a77 2
extern int rl_digit_argument PARAMS((int, int));
extern int rl_universal_argument PARAMS((int, int));
d80 9
a88 13
extern int rl_forward_byte PARAMS((int, int));
extern int rl_forward_char PARAMS((int, int));
extern int rl_forward PARAMS((int, int));
extern int rl_backward_byte PARAMS((int, int));
extern int rl_backward_char PARAMS((int, int));
extern int rl_backward PARAMS((int, int));
extern int rl_beg_of_line PARAMS((int, int));
extern int rl_end_of_line PARAMS((int, int));
extern int rl_forward_word PARAMS((int, int));
extern int rl_backward_word PARAMS((int, int));
extern int rl_refresh_line PARAMS((int, int));
extern int rl_clear_screen PARAMS((int, int));
extern int rl_arrow_keys PARAMS((int, int));
d91 11
a101 11
extern int rl_insert PARAMS((int, int));
extern int rl_quoted_insert PARAMS((int, int));
extern int rl_tab_insert PARAMS((int, int));
extern int rl_newline PARAMS((int, int));
extern int rl_do_lowercase_version PARAMS((int, int));
extern int rl_rubout PARAMS((int, int));
extern int rl_delete PARAMS((int, int));
extern int rl_rubout_or_delete PARAMS((int, int));
extern int rl_delete_horizontal_space PARAMS((int, int));
extern int rl_delete_or_show_completions PARAMS((int, int));
extern int rl_insert_comment PARAMS((int, int));
d104 3
a106 3
extern int rl_upcase_word PARAMS((int, int));
extern int rl_downcase_word PARAMS((int, int));
extern int rl_capitalize_word PARAMS((int, int));
d109 2
a110 2
extern int rl_transpose_words PARAMS((int, int));
extern int rl_transpose_chars PARAMS((int, int));
d113 2
a114 2
extern int rl_char_search PARAMS((int, int));
extern int rl_backward_char_search PARAMS((int, int));
d117 4
a120 4
extern int rl_beginning_of_history PARAMS((int, int));
extern int rl_end_of_history PARAMS((int, int));
extern int rl_get_next_history PARAMS((int, int));
extern int rl_get_previous_history PARAMS((int, int));
d123 2
a124 2
extern int rl_set_mark PARAMS((int, int));
extern int rl_exchange_point_and_mark PARAMS((int, int));
d127 2
a128 5
extern int rl_vi_editing_mode PARAMS((int, int));
extern int rl_emacs_editing_mode PARAMS((int, int));

/* Bindable commands to change the insert mode (insert or overwrite) */
extern int rl_overwrite_mode PARAMS((int, int));
d131 4
a134 4
extern int rl_re_read_init_file PARAMS((int, int));
extern int rl_dump_functions PARAMS((int, int));
extern int rl_dump_macros PARAMS((int, int));
extern int rl_dump_variables PARAMS((int, int));
d137 4
a140 4
extern int rl_complete PARAMS((int, int));
extern int rl_possible_completions PARAMS((int, int));
extern int rl_insert_completions PARAMS((int, int));
extern int rl_menu_complete PARAMS((int, int));
d143 18
a160 18
extern int rl_kill_word PARAMS((int, int));
extern int rl_backward_kill_word PARAMS((int, int));
extern int rl_kill_line PARAMS((int, int));
extern int rl_backward_kill_line PARAMS((int, int));
extern int rl_kill_full_line PARAMS((int, int));
extern int rl_unix_word_rubout PARAMS((int, int));
extern int rl_unix_line_discard PARAMS((int, int));
extern int rl_copy_region_to_kill PARAMS((int, int));
extern int rl_kill_region PARAMS((int, int));
extern int rl_copy_forward_word PARAMS((int, int));
extern int rl_copy_backward_word PARAMS((int, int));
extern int rl_yank PARAMS((int, int));
extern int rl_yank_pop PARAMS((int, int));
extern int rl_yank_nth_arg PARAMS((int, int));
extern int rl_yank_last_arg PARAMS((int, int));
/* Not available unless __CYGWIN__ is defined. */
#ifdef __CYGWIN__
extern int rl_paste_from_clipboard PARAMS((int, int));
d164 2
a165 2
extern int rl_reverse_search_history PARAMS((int, int));
extern int rl_forward_search_history PARAMS((int, int));
d168 3
a170 3
extern int rl_start_kbd_macro PARAMS((int, int));
extern int rl_end_kbd_macro PARAMS((int, int));
extern int rl_call_last_kbd_macro PARAMS((int, int));
d173 2
a174 2
extern int rl_revert_line PARAMS((int, int));
extern int rl_undo_command PARAMS((int, int));
d177 1
a177 1
extern int rl_tilde_expand PARAMS((int, int));
d180 2
a181 2
extern int rl_restart_output PARAMS((int, int));
extern int rl_stop_output PARAMS((int, int));
d184 2
a185 2
extern int rl_abort PARAMS((int, int));
extern int rl_tty_status PARAMS((int, int));
d188 6
a193 6
extern int rl_history_search_forward PARAMS((int, int));
extern int rl_history_search_backward PARAMS((int, int));
extern int rl_noninc_forward_search PARAMS((int, int));
extern int rl_noninc_reverse_search PARAMS((int, int));
extern int rl_noninc_forward_search_again PARAMS((int, int));
extern int rl_noninc_reverse_search_again PARAMS((int, int));
d196 1
a196 1
extern int rl_insert_close PARAMS((int, int));
d199 3
a201 3
extern void rl_callback_handler_install PARAMS((const char *, rl_vcpfunc_t *));
extern void rl_callback_read_char PARAMS((void));
extern void rl_callback_handler_remove PARAMS((void));
d205 36
a240 36
extern int rl_vi_redo PARAMS((int, int));
extern int rl_vi_undo PARAMS((int, int));
extern int rl_vi_yank_arg PARAMS((int, int));
extern int rl_vi_fetch_history PARAMS((int, int));
extern int rl_vi_search_again PARAMS((int, int));
extern int rl_vi_search PARAMS((int, int));
extern int rl_vi_complete PARAMS((int, int));
extern int rl_vi_tilde_expand PARAMS((int, int));
extern int rl_vi_prev_word PARAMS((int, int));
extern int rl_vi_next_word PARAMS((int, int));
extern int rl_vi_end_word PARAMS((int, int));
extern int rl_vi_insert_beg PARAMS((int, int));
extern int rl_vi_append_mode PARAMS((int, int));
extern int rl_vi_append_eol PARAMS((int, int));
extern int rl_vi_eof_maybe PARAMS((int, int));
extern int rl_vi_insertion_mode PARAMS((int, int));
extern int rl_vi_movement_mode PARAMS((int, int));
extern int rl_vi_arg_digit PARAMS((int, int));
extern int rl_vi_change_case PARAMS((int, int));
extern int rl_vi_put PARAMS((int, int));
extern int rl_vi_column PARAMS((int, int));
extern int rl_vi_delete_to PARAMS((int, int));
extern int rl_vi_change_to PARAMS((int, int));
extern int rl_vi_yank_to PARAMS((int, int));
extern int rl_vi_delete PARAMS((int, int));
extern int rl_vi_back_to_indent PARAMS((int, int));
extern int rl_vi_first_print PARAMS((int, int));
extern int rl_vi_char_search PARAMS((int, int));
extern int rl_vi_match PARAMS((int, int));
extern int rl_vi_change_char PARAMS((int, int));
extern int rl_vi_subst PARAMS((int, int));
extern int rl_vi_overstrike PARAMS((int, int));
extern int rl_vi_overstrike_delete PARAMS((int, int));
extern int rl_vi_replace PARAMS((int, int));
extern int rl_vi_set_mark PARAMS((int, int));
extern int rl_vi_goto_mark PARAMS((int, int));
d243 3
a245 3
extern int rl_vi_check PARAMS((void));
extern int rl_vi_domove PARAMS((int, int *));
extern int rl_vi_bracktype PARAMS((int));
d248 6
a253 6
extern int rl_vi_fWord PARAMS((int, int));
extern int rl_vi_bWord PARAMS((int, int));
extern int rl_vi_eWord PARAMS((int, int));
extern int rl_vi_fword PARAMS((int, int));
extern int rl_vi_bword PARAMS((int, int));
extern int rl_vi_eword PARAMS((int, int));
d263 1
a263 1
extern char *readline PARAMS((const char *));
d265 1
a265 2
extern int rl_set_prompt PARAMS((const char *));
extern int rl_expand_prompt PARAMS((char *));
d267 1
a267 4
extern int rl_initialize PARAMS((void));

/* Undocumented; unused by readline */
extern int rl_discard_argument PARAMS((void));
d270 10
a279 10
extern int rl_add_defun PARAMS((const char *, rl_command_func_t *, int));
extern int rl_bind_key PARAMS((int, rl_command_func_t *));
extern int rl_bind_key_in_map PARAMS((int, rl_command_func_t *, Keymap));
extern int rl_unbind_key PARAMS((int));
extern int rl_unbind_key_in_map PARAMS((int, Keymap));
extern int rl_unbind_function_in_map PARAMS((rl_command_func_t *, Keymap));
extern int rl_unbind_command_in_map PARAMS((const char *, Keymap));
extern int rl_set_key PARAMS((const char *, rl_command_func_t *, Keymap));
extern int rl_generic_bind PARAMS((int, const char *, char *, Keymap));
extern int rl_variable_bind PARAMS((const char *, const char *));
d282 1
a282 1
extern int rl_macro_bind PARAMS((const char *, const char *, Keymap));
d285 2
a286 2
extern int rl_translate_keyseq PARAMS((const char *, char *, int *));
extern char *rl_untranslate_keyseq PARAMS((int));
d288 2
a289 2
extern rl_command_func_t *rl_named_function PARAMS((const char *));
extern rl_command_func_t *rl_function_of_keyseq PARAMS((const char *, Keymap, int *));
d291 3
a293 3
extern void rl_list_funmap_names PARAMS((void));
extern char **rl_invoking_keyseqs_in_map PARAMS((rl_command_func_t *, Keymap));
extern char **rl_invoking_keyseqs PARAMS((rl_command_func_t *));
d295 3
a297 3
extern void rl_function_dumper PARAMS((int));
extern void rl_macro_dumper PARAMS((int));
extern void rl_variable_dumper PARAMS((int));
d299 2
a300 2
extern int rl_read_init_file PARAMS((const char *));
extern int rl_parse_and_bind PARAMS((char *));
d303 11
a313 12
extern Keymap rl_make_bare_keymap PARAMS((void));
extern Keymap rl_copy_keymap PARAMS((Keymap));
extern Keymap rl_make_keymap PARAMS((void));
extern void rl_discard_keymap PARAMS((Keymap));

extern Keymap rl_get_keymap_by_name PARAMS((const char *));
extern char *rl_get_keymap_name PARAMS((Keymap));
extern void rl_set_keymap PARAMS((Keymap));
extern Keymap rl_get_keymap PARAMS((void));
/* Undocumented; used internally only. */
extern void rl_set_keymap_from_edit_mode PARAMS((void));
extern char *rl_get_keymap_name_from_edit_mode PARAMS((void));
d316 3
a318 5
extern int rl_add_funmap_entry PARAMS((const char *, rl_command_func_t *));
extern const char **rl_funmap_names PARAMS((void));
/* Undocumented, only used internally -- there is only one funmap, and this
   function may be called only once. */
extern void rl_initialize_funmap PARAMS((void));
d321 1
a321 1
extern void rl_push_macro_input PARAMS((char *));
d324 6
a329 6
extern void rl_add_undo PARAMS((enum undo_code, int, int, char *));
extern void rl_free_undo_list PARAMS((void));
extern int rl_do_undo PARAMS((void));
extern int rl_begin_undo_group PARAMS((void));
extern int rl_end_undo_group PARAMS((void));
extern int rl_modifying PARAMS((int, int));
d332 6
a337 7
extern void rl_redisplay PARAMS((void));
extern int rl_on_new_line PARAMS((void));
extern int rl_on_new_line_with_prompt PARAMS((void));
extern int rl_forced_update_display PARAMS((void));
extern int rl_clear_message PARAMS((void));
extern int rl_reset_line_state PARAMS((void));
extern int rl_crlf PARAMS((void));
d340 1
a340 1
extern int rl_message (const char *, ...)  __attribute__((__format__ (printf, 1, 2)));
a344 2
extern int rl_show_char PARAMS((int));

d346 3
a348 1
extern int rl_character_len PARAMS((int, int));
d351 2
a352 2
extern void rl_save_prompt PARAMS((void));
extern void rl_restore_prompt PARAMS((void));
d355 4
a358 5
extern void rl_replace_line PARAMS((const char *, int));
extern int rl_insert_text PARAMS((const char *));
extern int rl_delete_text PARAMS((int, int));
extern int rl_kill_text PARAMS((int, int));
extern char *rl_copy_text PARAMS((int, int));
d361 3
a363 8
extern void rl_prep_terminal PARAMS((int));
extern void rl_deprep_terminal PARAMS((void));
extern void rl_tty_set_default_bindings PARAMS((Keymap));

extern int rl_reset_terminal PARAMS((const char *));
extern void rl_resize_terminal PARAMS((void));
extern void rl_set_screen_size PARAMS((int, int));
extern void rl_get_screen_size PARAMS((int *, int *));
d365 6
a370 1
extern char *rl_get_termcap PARAMS((const char *));
d373 4
a376 11
extern int rl_stuff_char PARAMS((int));
extern int rl_execute_next PARAMS((int));
extern int rl_clear_pending_input PARAMS((void));
extern int rl_read_key PARAMS((void));
extern int rl_getc PARAMS((FILE *));
extern int rl_set_keyboard_input_timeout PARAMS((int));

/* `Public' utility functions . */
extern void rl_extend_line_buffer PARAMS((int));
extern int rl_ding PARAMS((void));
extern int rl_alphabetic PARAMS((int));
d379 5
a383 5
extern int rl_set_signals PARAMS((void));
extern int rl_clear_signals PARAMS((void));
extern void rl_cleanup_after_signal PARAMS((void));
extern void rl_reset_after_signal PARAMS((void));
extern void rl_free_line_state PARAMS((void));
d385 2
a386 1
extern int rl_set_paren_blink_timeout PARAMS((int));
d388 3
a390 4
/* Undocumented. */
extern int rl_maybe_save_line PARAMS((void));
extern int rl_maybe_unsave_line PARAMS((void));
extern int rl_maybe_replace_line PARAMS((void));
d393 2
a394 8
extern int rl_complete_internal PARAMS((int));
extern void rl_display_match_list PARAMS((char **, int, int));

extern char **rl_completion_matches PARAMS((const char *, rl_compentry_func_t *));
extern char *rl_username_completion_function PARAMS((const char *, int));
extern char *rl_filename_completion_function PARAMS((const char *, int));

extern int rl_completion_mode PARAMS((rl_command_func_t *));
d396 3
a398 15
#if 0
/* Backwards compatibility (compat.c).  These will go away sometime. */
extern void free_undo_list PARAMS((void));
extern int maybe_save_line PARAMS((void));
extern int maybe_unsave_line PARAMS((void));
extern int maybe_replace_line PARAMS((void));

extern int ding PARAMS((void));
extern int alphabetic PARAMS((int));
extern int crlf PARAMS((void));

extern char **completion_matches PARAMS((char *, rl_compentry_func_t *));
extern char *username_completion_function PARAMS((const char *, int));
extern char *filename_completion_function PARAMS((const char *, int));
#endif
d407 1
a407 2
extern const char *rl_library_version;		/* e.g., "4.2" */
extern int rl_readline_version;			/* e.g., 0x0402 */
a411 11
/* Flags word encapsulating the current readline state. */
extern int rl_readline_state;

/* Says which editing mode readline is currently using.  1 means emacs mode;
   0 means vi mode. */
extern int rl_editing_mode;

/* Insert or overwrite mode for emacs mode.  1 means insert mode; 0 means
   overwrite mode.  Reset to insert mode on each input line. */
extern int rl_insert_mode;

d414 1
a414 1
extern const char *rl_readline_name;
d424 1
a424 2
extern int rl_point;
extern int rl_end;
a440 10
/* Non-zero if the user typed a numeric argument before executing the
   current function. */
extern int rl_explicit_arg;

/* The current value of the numeric argument specified by the user. */
extern int rl_numeric_arg;

/* The address of the last command function Readline executed. */
extern rl_command_func_t *rl_last_func;

d442 1
a442 1
extern const char *rl_terminal_name;
d445 1
a445 2
extern FILE *rl_instream;
extern FILE *rl_outstream;
d449 1
a449 1
extern rl_hook_func_t *rl_startup_hook;
d454 1
a454 1
extern rl_hook_func_t *rl_pre_input_hook;
d458 1
a458 5
extern rl_hook_func_t *rl_event_hook;

/* The address of the function to call to fetch a character from the current
   Readline input stream */
extern rl_getc_func_t *rl_getc_function;
d460 4
a463 4
extern rl_voidfunc_t *rl_redisplay_function;

extern rl_vintfunc_t *rl_prep_term_function;
extern rl_voidfunc_t *rl_deprep_term_function;
a483 3
/* The text of a currently-executing keyboard macro. */
extern char *rl_executing_macro;

d498 3
a500 3
   NULL means to use rl_filename_completion_function (), the default
   filename completer. */
extern rl_compentry_func_t *rl_completion_entry_function;
d508 1
a508 1
extern rl_compignore_func_t *rl_ignore_some_completions_function;
d517 1
a517 1
extern rl_completion_func_t *rl_attempted_completion_function;
d522 1
a522 1
extern const char *rl_basic_word_break_characters;
d527 1
a527 1
extern const char *rl_completer_word_break_characters;
d533 1
a533 1
extern const char *rl_completer_quote_characters;
d536 1
a536 1
extern const char *rl_basic_quote_characters;
d539 1
a539 1
extern const char *rl_filename_quote_characters;
d544 1
a544 1
extern const char *rl_special_prefixes;
d548 2
a549 13
   the address of a string (the current directory name) as an arg.  It
   changes what is displayed when the possible completions are printed
   or inserted. */
extern rl_icppfunc_t *rl_directory_completion_hook;

/* If non-zero, this is the address of a function to call when completing
   a directory name.  This function takes the address of the directory name
   to be modified as an argument.  Unlike rl_directory_completion_hook, it
   only modifies the directory name used in opendir(2), not what is displayed
   when the possible completions are printed or inserted.  It is called
   before rl_directory_completion_hook.  I'm not happy with how this works
   yet, so it's undocumented. */
extern rl_icppfunc_t *rl_directory_rewrite_hook;
d561 1
a561 1
extern rl_compdisp_func_t *rl_completion_display_matches_hook;
d579 1
a579 1
extern rl_quote_func_t *rl_filename_quoting_function;
d584 1
a584 1
extern rl_dequote_func_t *rl_filename_dequoting_function;
d589 1
a589 1
extern rl_linebuf_func_t *rl_char_is_quoted_p;
a603 4
/* If set to non-zero by an application completion function,
   rl_completion_append_character will not be appended. */
extern int rl_completion_suppress_append;

a608 11
/* If non-zero, a slash will be appended to completed filenames that are
   symbolic links to directory names, subject to the value of the
   mark-directories variable (which is user-settable).  This exists so
   that application completion functions can override the user's preference
   (set via the mark-symlinked-directories variable) if appropriate.
   It's set to the value of _rl_complete_mark_symlink_dirs in
   rl_complete_internal before any application-specific completion
   function is called, so without that function doing anything, the user's
   preferences are honored. */
extern int rl_completion_mark_symlink_dirs;

d615 1
a615 1

d626 5
a630 63
/* Possible state values for rl_readline_state */
#define RL_STATE_NONE		0x00000		/* no state; before first call */

#define RL_STATE_INITIALIZING	0x00001		/* initializing */
#define RL_STATE_INITIALIZED	0x00002		/* initialization done */
#define RL_STATE_TERMPREPPED	0x00004		/* terminal is prepped */
#define RL_STATE_READCMD	0x00008		/* reading a command key */
#define RL_STATE_METANEXT	0x00010		/* reading input after ESC */
#define RL_STATE_DISPATCHING	0x00020		/* dispatching to a command */
#define RL_STATE_MOREINPUT	0x00040		/* reading more input in a command function */
#define RL_STATE_ISEARCH	0x00080		/* doing incremental search */
#define RL_STATE_NSEARCH	0x00100		/* doing non-inc search */
#define RL_STATE_SEARCH		0x00200		/* doing a history search */
#define RL_STATE_NUMERICARG	0x00400		/* reading numeric argument */
#define RL_STATE_MACROINPUT	0x00800		/* getting input from a macro */
#define RL_STATE_MACRODEF	0x01000		/* defining keyboard macro */
#define RL_STATE_OVERWRITE	0x02000		/* overwrite mode */
#define RL_STATE_COMPLETING	0x04000		/* doing completion */
#define RL_STATE_SIGHANDLER	0x08000		/* in readline sighandler */
#define RL_STATE_UNDOING	0x10000		/* doing an undo */
#define RL_STATE_INPUTPENDING	0x20000		/* rl_execute_next called */

#define RL_STATE_DONE		0x80000		/* done; accepted line */

#define RL_SETSTATE(x)		(rl_readline_state |= (x))
#define RL_UNSETSTATE(x)	(rl_readline_state &= ~(x))
#define RL_ISSTATE(x)		(rl_readline_state & (x))

struct readline_state {
  /* line state */
  int point;
  int end;
  int mark;
  char *buffer;
  int buflen;
  UNDO_LIST *ul;
  char *prompt;

  /* global state */
  int rlstate;
  int done;
  Keymap kmap;

  /* input state */
  rl_command_func_t *lastfunc;
  int insmode;
  int edmode;
  int kseqlen;
  FILE *inf;
  FILE *outf;
  int pendingin;
  char *macro;

  /* signal state */
  int catchsigs;
  int catchsigwinch;

  /* reserved for future expansion, so the struct size doesn't change */
  char reserved[64];
};

extern int rl_save_state PARAMS((struct readline_state *));
extern int rl_restore_state PARAMS((struct readline_state *));
@


1.3.16.1
log
@2002-08-24  Elena Zannoni  <ezannoni@@redhat.com>

        Import of readline 4.3:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@a31 1
#  include "rltypedefs.h"
a35 1
#  include <readline/rltypedefs.h>
a39 5
/* Hex-encoded Readline version number. */
#define RL_READLINE_VERSION	0x0403		/* Readline 4.3 */
#define RL_VERSION_MAJOR	4
#define RL_VERSION_MINOR	3

d63 2
a64 2
  const char *name;
  rl_command_func_t *function;
d76 2
a77 2
extern int rl_digit_argument PARAMS((int, int));
extern int rl_universal_argument PARAMS((int, int));
d80 9
a88 13
extern int rl_forward_byte PARAMS((int, int));
extern int rl_forward_char PARAMS((int, int));
extern int rl_forward PARAMS((int, int));
extern int rl_backward_byte PARAMS((int, int));
extern int rl_backward_char PARAMS((int, int));
extern int rl_backward PARAMS((int, int));
extern int rl_beg_of_line PARAMS((int, int));
extern int rl_end_of_line PARAMS((int, int));
extern int rl_forward_word PARAMS((int, int));
extern int rl_backward_word PARAMS((int, int));
extern int rl_refresh_line PARAMS((int, int));
extern int rl_clear_screen PARAMS((int, int));
extern int rl_arrow_keys PARAMS((int, int));
d91 11
a101 11
extern int rl_insert PARAMS((int, int));
extern int rl_quoted_insert PARAMS((int, int));
extern int rl_tab_insert PARAMS((int, int));
extern int rl_newline PARAMS((int, int));
extern int rl_do_lowercase_version PARAMS((int, int));
extern int rl_rubout PARAMS((int, int));
extern int rl_delete PARAMS((int, int));
extern int rl_rubout_or_delete PARAMS((int, int));
extern int rl_delete_horizontal_space PARAMS((int, int));
extern int rl_delete_or_show_completions PARAMS((int, int));
extern int rl_insert_comment PARAMS((int, int));
d104 3
a106 3
extern int rl_upcase_word PARAMS((int, int));
extern int rl_downcase_word PARAMS((int, int));
extern int rl_capitalize_word PARAMS((int, int));
d109 2
a110 2
extern int rl_transpose_words PARAMS((int, int));
extern int rl_transpose_chars PARAMS((int, int));
d113 2
a114 2
extern int rl_char_search PARAMS((int, int));
extern int rl_backward_char_search PARAMS((int, int));
d117 4
a120 4
extern int rl_beginning_of_history PARAMS((int, int));
extern int rl_end_of_history PARAMS((int, int));
extern int rl_get_next_history PARAMS((int, int));
extern int rl_get_previous_history PARAMS((int, int));
d123 2
a124 2
extern int rl_set_mark PARAMS((int, int));
extern int rl_exchange_point_and_mark PARAMS((int, int));
d127 2
a128 5
extern int rl_vi_editing_mode PARAMS((int, int));
extern int rl_emacs_editing_mode PARAMS((int, int));

/* Bindable commands to change the insert mode (insert or overwrite) */
extern int rl_overwrite_mode PARAMS((int, int));
d131 4
a134 4
extern int rl_re_read_init_file PARAMS((int, int));
extern int rl_dump_functions PARAMS((int, int));
extern int rl_dump_macros PARAMS((int, int));
extern int rl_dump_variables PARAMS((int, int));
d137 4
a140 4
extern int rl_complete PARAMS((int, int));
extern int rl_possible_completions PARAMS((int, int));
extern int rl_insert_completions PARAMS((int, int));
extern int rl_menu_complete PARAMS((int, int));
d143 18
a160 18
extern int rl_kill_word PARAMS((int, int));
extern int rl_backward_kill_word PARAMS((int, int));
extern int rl_kill_line PARAMS((int, int));
extern int rl_backward_kill_line PARAMS((int, int));
extern int rl_kill_full_line PARAMS((int, int));
extern int rl_unix_word_rubout PARAMS((int, int));
extern int rl_unix_line_discard PARAMS((int, int));
extern int rl_copy_region_to_kill PARAMS((int, int));
extern int rl_kill_region PARAMS((int, int));
extern int rl_copy_forward_word PARAMS((int, int));
extern int rl_copy_backward_word PARAMS((int, int));
extern int rl_yank PARAMS((int, int));
extern int rl_yank_pop PARAMS((int, int));
extern int rl_yank_nth_arg PARAMS((int, int));
extern int rl_yank_last_arg PARAMS((int, int));
/* Not available unless __CYGWIN__ is defined. */
#ifdef __CYGWIN__
extern int rl_paste_from_clipboard PARAMS((int, int));
d164 2
a165 2
extern int rl_reverse_search_history PARAMS((int, int));
extern int rl_forward_search_history PARAMS((int, int));
d168 3
a170 3
extern int rl_start_kbd_macro PARAMS((int, int));
extern int rl_end_kbd_macro PARAMS((int, int));
extern int rl_call_last_kbd_macro PARAMS((int, int));
d173 2
a174 2
extern int rl_revert_line PARAMS((int, int));
extern int rl_undo_command PARAMS((int, int));
d177 1
a177 1
extern int rl_tilde_expand PARAMS((int, int));
d180 2
a181 2
extern int rl_restart_output PARAMS((int, int));
extern int rl_stop_output PARAMS((int, int));
d184 2
a185 2
extern int rl_abort PARAMS((int, int));
extern int rl_tty_status PARAMS((int, int));
d188 6
a193 6
extern int rl_history_search_forward PARAMS((int, int));
extern int rl_history_search_backward PARAMS((int, int));
extern int rl_noninc_forward_search PARAMS((int, int));
extern int rl_noninc_reverse_search PARAMS((int, int));
extern int rl_noninc_forward_search_again PARAMS((int, int));
extern int rl_noninc_reverse_search_again PARAMS((int, int));
d196 1
a196 1
extern int rl_insert_close PARAMS((int, int));
d199 3
a201 3
extern void rl_callback_handler_install PARAMS((const char *, rl_vcpfunc_t *));
extern void rl_callback_read_char PARAMS((void));
extern void rl_callback_handler_remove PARAMS((void));
d205 36
a240 36
extern int rl_vi_redo PARAMS((int, int));
extern int rl_vi_undo PARAMS((int, int));
extern int rl_vi_yank_arg PARAMS((int, int));
extern int rl_vi_fetch_history PARAMS((int, int));
extern int rl_vi_search_again PARAMS((int, int));
extern int rl_vi_search PARAMS((int, int));
extern int rl_vi_complete PARAMS((int, int));
extern int rl_vi_tilde_expand PARAMS((int, int));
extern int rl_vi_prev_word PARAMS((int, int));
extern int rl_vi_next_word PARAMS((int, int));
extern int rl_vi_end_word PARAMS((int, int));
extern int rl_vi_insert_beg PARAMS((int, int));
extern int rl_vi_append_mode PARAMS((int, int));
extern int rl_vi_append_eol PARAMS((int, int));
extern int rl_vi_eof_maybe PARAMS((int, int));
extern int rl_vi_insertion_mode PARAMS((int, int));
extern int rl_vi_movement_mode PARAMS((int, int));
extern int rl_vi_arg_digit PARAMS((int, int));
extern int rl_vi_change_case PARAMS((int, int));
extern int rl_vi_put PARAMS((int, int));
extern int rl_vi_column PARAMS((int, int));
extern int rl_vi_delete_to PARAMS((int, int));
extern int rl_vi_change_to PARAMS((int, int));
extern int rl_vi_yank_to PARAMS((int, int));
extern int rl_vi_delete PARAMS((int, int));
extern int rl_vi_back_to_indent PARAMS((int, int));
extern int rl_vi_first_print PARAMS((int, int));
extern int rl_vi_char_search PARAMS((int, int));
extern int rl_vi_match PARAMS((int, int));
extern int rl_vi_change_char PARAMS((int, int));
extern int rl_vi_subst PARAMS((int, int));
extern int rl_vi_overstrike PARAMS((int, int));
extern int rl_vi_overstrike_delete PARAMS((int, int));
extern int rl_vi_replace PARAMS((int, int));
extern int rl_vi_set_mark PARAMS((int, int));
extern int rl_vi_goto_mark PARAMS((int, int));
d243 3
a245 3
extern int rl_vi_check PARAMS((void));
extern int rl_vi_domove PARAMS((int, int *));
extern int rl_vi_bracktype PARAMS((int));
d248 6
a253 6
extern int rl_vi_fWord PARAMS((int, int));
extern int rl_vi_bWord PARAMS((int, int));
extern int rl_vi_eWord PARAMS((int, int));
extern int rl_vi_fword PARAMS((int, int));
extern int rl_vi_bword PARAMS((int, int));
extern int rl_vi_eword PARAMS((int, int));
d263 1
a263 1
extern char *readline PARAMS((const char *));
d265 1
a265 2
extern int rl_set_prompt PARAMS((const char *));
extern int rl_expand_prompt PARAMS((char *));
d267 1
a267 4
extern int rl_initialize PARAMS((void));

/* Undocumented; unused by readline */
extern int rl_discard_argument PARAMS((void));
d270 10
a279 10
extern int rl_add_defun PARAMS((const char *, rl_command_func_t *, int));
extern int rl_bind_key PARAMS((int, rl_command_func_t *));
extern int rl_bind_key_in_map PARAMS((int, rl_command_func_t *, Keymap));
extern int rl_unbind_key PARAMS((int));
extern int rl_unbind_key_in_map PARAMS((int, Keymap));
extern int rl_unbind_function_in_map PARAMS((rl_command_func_t *, Keymap));
extern int rl_unbind_command_in_map PARAMS((const char *, Keymap));
extern int rl_set_key PARAMS((const char *, rl_command_func_t *, Keymap));
extern int rl_generic_bind PARAMS((int, const char *, char *, Keymap));
extern int rl_variable_bind PARAMS((const char *, const char *));
d282 1
a282 1
extern int rl_macro_bind PARAMS((const char *, const char *, Keymap));
d285 2
a286 2
extern int rl_translate_keyseq PARAMS((const char *, char *, int *));
extern char *rl_untranslate_keyseq PARAMS((int));
d288 2
a289 2
extern rl_command_func_t *rl_named_function PARAMS((const char *));
extern rl_command_func_t *rl_function_of_keyseq PARAMS((const char *, Keymap, int *));
d291 3
a293 3
extern void rl_list_funmap_names PARAMS((void));
extern char **rl_invoking_keyseqs_in_map PARAMS((rl_command_func_t *, Keymap));
extern char **rl_invoking_keyseqs PARAMS((rl_command_func_t *));
d295 3
a297 3
extern void rl_function_dumper PARAMS((int));
extern void rl_macro_dumper PARAMS((int));
extern void rl_variable_dumper PARAMS((int));
d299 2
a300 2
extern int rl_read_init_file PARAMS((const char *));
extern int rl_parse_and_bind PARAMS((char *));
d303 11
a313 12
extern Keymap rl_make_bare_keymap PARAMS((void));
extern Keymap rl_copy_keymap PARAMS((Keymap));
extern Keymap rl_make_keymap PARAMS((void));
extern void rl_discard_keymap PARAMS((Keymap));

extern Keymap rl_get_keymap_by_name PARAMS((const char *));
extern char *rl_get_keymap_name PARAMS((Keymap));
extern void rl_set_keymap PARAMS((Keymap));
extern Keymap rl_get_keymap PARAMS((void));
/* Undocumented; used internally only. */
extern void rl_set_keymap_from_edit_mode PARAMS((void));
extern char *rl_get_keymap_name_from_edit_mode PARAMS((void));
d316 3
a318 5
extern int rl_add_funmap_entry PARAMS((const char *, rl_command_func_t *));
extern const char **rl_funmap_names PARAMS((void));
/* Undocumented, only used internally -- there is only one funmap, and this
   function may be called only once. */
extern void rl_initialize_funmap PARAMS((void));
d321 1
a321 1
extern void rl_push_macro_input PARAMS((char *));
d324 6
a329 6
extern void rl_add_undo PARAMS((enum undo_code, int, int, char *));
extern void rl_free_undo_list PARAMS((void));
extern int rl_do_undo PARAMS((void));
extern int rl_begin_undo_group PARAMS((void));
extern int rl_end_undo_group PARAMS((void));
extern int rl_modifying PARAMS((int, int));
d332 6
a337 7
extern void rl_redisplay PARAMS((void));
extern int rl_on_new_line PARAMS((void));
extern int rl_on_new_line_with_prompt PARAMS((void));
extern int rl_forced_update_display PARAMS((void));
extern int rl_clear_message PARAMS((void));
extern int rl_reset_line_state PARAMS((void));
extern int rl_crlf PARAMS((void));
d340 1
a340 1
extern int rl_message (const char *, ...)  __attribute__((__format__ (printf, 1, 2)));
a344 2
extern int rl_show_char PARAMS((int));

d346 3
a348 1
extern int rl_character_len PARAMS((int, int));
d351 2
a352 2
extern void rl_save_prompt PARAMS((void));
extern void rl_restore_prompt PARAMS((void));
d355 4
a358 5
extern void rl_replace_line PARAMS((const char *, int));
extern int rl_insert_text PARAMS((const char *));
extern int rl_delete_text PARAMS((int, int));
extern int rl_kill_text PARAMS((int, int));
extern char *rl_copy_text PARAMS((int, int));
d361 3
a363 8
extern void rl_prep_terminal PARAMS((int));
extern void rl_deprep_terminal PARAMS((void));
extern void rl_tty_set_default_bindings PARAMS((Keymap));

extern int rl_reset_terminal PARAMS((const char *));
extern void rl_resize_terminal PARAMS((void));
extern void rl_set_screen_size PARAMS((int, int));
extern void rl_get_screen_size PARAMS((int *, int *));
d365 6
a370 1
extern char *rl_get_termcap PARAMS((const char *));
d373 4
a376 11
extern int rl_stuff_char PARAMS((int));
extern int rl_execute_next PARAMS((int));
extern int rl_clear_pending_input PARAMS((void));
extern int rl_read_key PARAMS((void));
extern int rl_getc PARAMS((FILE *));
extern int rl_set_keyboard_input_timeout PARAMS((int));

/* `Public' utility functions . */
extern void rl_extend_line_buffer PARAMS((int));
extern int rl_ding PARAMS((void));
extern int rl_alphabetic PARAMS((int));
d379 5
a383 5
extern int rl_set_signals PARAMS((void));
extern int rl_clear_signals PARAMS((void));
extern void rl_cleanup_after_signal PARAMS((void));
extern void rl_reset_after_signal PARAMS((void));
extern void rl_free_line_state PARAMS((void));
d385 2
a386 1
extern int rl_set_paren_blink_timeout PARAMS((int));
d388 3
a390 4
/* Undocumented. */
extern int rl_maybe_save_line PARAMS((void));
extern int rl_maybe_unsave_line PARAMS((void));
extern int rl_maybe_replace_line PARAMS((void));
d393 2
a394 8
extern int rl_complete_internal PARAMS((int));
extern void rl_display_match_list PARAMS((char **, int, int));

extern char **rl_completion_matches PARAMS((const char *, rl_compentry_func_t *));
extern char *rl_username_completion_function PARAMS((const char *, int));
extern char *rl_filename_completion_function PARAMS((const char *, int));

extern int rl_completion_mode PARAMS((rl_command_func_t *));
d396 3
a398 15
#if 0
/* Backwards compatibility (compat.c).  These will go away sometime. */
extern void free_undo_list PARAMS((void));
extern int maybe_save_line PARAMS((void));
extern int maybe_unsave_line PARAMS((void));
extern int maybe_replace_line PARAMS((void));

extern int ding PARAMS((void));
extern int alphabetic PARAMS((int));
extern int crlf PARAMS((void));

extern char **completion_matches PARAMS((char *, rl_compentry_func_t *));
extern char *username_completion_function PARAMS((const char *, int));
extern char *filename_completion_function PARAMS((const char *, int));
#endif
d407 1
a407 2
extern const char *rl_library_version;		/* e.g., "4.2" */
extern int rl_readline_version;			/* e.g., 0x0402 */
a411 11
/* Flags word encapsulating the current readline state. */
extern int rl_readline_state;

/* Says which editing mode readline is currently using.  1 means emacs mode;
   0 means vi mode. */
extern int rl_editing_mode;

/* Insert or overwrite mode for emacs mode.  1 means insert mode; 0 means
   overwrite mode.  Reset to insert mode on each input line. */
extern int rl_insert_mode;

d414 1
a414 1
extern const char *rl_readline_name;
d424 1
a424 2
extern int rl_point;
extern int rl_end;
a440 10
/* Non-zero if the user typed a numeric argument before executing the
   current function. */
extern int rl_explicit_arg;

/* The current value of the numeric argument specified by the user. */
extern int rl_numeric_arg;

/* The address of the last command function Readline executed. */
extern rl_command_func_t *rl_last_func;

d442 1
a442 1
extern const char *rl_terminal_name;
d445 1
a445 2
extern FILE *rl_instream;
extern FILE *rl_outstream;
d449 1
a449 1
extern rl_hook_func_t *rl_startup_hook;
d454 1
a454 1
extern rl_hook_func_t *rl_pre_input_hook;
d458 1
a458 5
extern rl_hook_func_t *rl_event_hook;

/* The address of the function to call to fetch a character from the current
   Readline input stream */
extern rl_getc_func_t *rl_getc_function;
d460 4
a463 4
extern rl_voidfunc_t *rl_redisplay_function;

extern rl_vintfunc_t *rl_prep_term_function;
extern rl_voidfunc_t *rl_deprep_term_function;
a483 3
/* The text of a currently-executing keyboard macro. */
extern char *rl_executing_macro;

d498 3
a500 3
   NULL means to use rl_filename_completion_function (), the default
   filename completer. */
extern rl_compentry_func_t *rl_completion_entry_function;
d508 1
a508 1
extern rl_compignore_func_t *rl_ignore_some_completions_function;
d517 1
a517 1
extern rl_completion_func_t *rl_attempted_completion_function;
d522 1
a522 1
extern const char *rl_basic_word_break_characters;
d527 1
a527 1
extern const char *rl_completer_word_break_characters;
d533 1
a533 1
extern const char *rl_completer_quote_characters;
d536 1
a536 1
extern const char *rl_basic_quote_characters;
d539 1
a539 1
extern const char *rl_filename_quote_characters;
d544 1
a544 1
extern const char *rl_special_prefixes;
d548 2
a549 13
   the address of a string (the current directory name) as an arg.  It
   changes what is displayed when the possible completions are printed
   or inserted. */
extern rl_icppfunc_t *rl_directory_completion_hook;

/* If non-zero, this is the address of a function to call when completing
   a directory name.  This function takes the address of the directory name
   to be modified as an argument.  Unlike rl_directory_completion_hook, it
   only modifies the directory name used in opendir(2), not what is displayed
   when the possible completions are printed or inserted.  It is called
   before rl_directory_completion_hook.  I'm not happy with how this works
   yet, so it's undocumented. */
extern rl_icppfunc_t *rl_directory_rewrite_hook;
d561 1
a561 1
extern rl_compdisp_func_t *rl_completion_display_matches_hook;
d579 1
a579 1
extern rl_quote_func_t *rl_filename_quoting_function;
d584 1
a584 1
extern rl_dequote_func_t *rl_filename_dequoting_function;
d589 1
a589 1
extern rl_linebuf_func_t *rl_char_is_quoted_p;
a603 4
/* If set to non-zero by an application completion function,
   rl_completion_append_character will not be appended. */
extern int rl_completion_suppress_append;

a608 11
/* If non-zero, a slash will be appended to completed filenames that are
   symbolic links to directory names, subject to the value of the
   mark-directories variable (which is user-settable).  This exists so
   that application completion functions can override the user's preference
   (set via the mark-symlinked-directories variable) if appropriate.
   It's set to the value of _rl_complete_mark_symlink_dirs in
   rl_complete_internal before any application-specific completion
   function is called, so without that function doing anything, the user's
   preferences are honored. */
extern int rl_completion_mark_symlink_dirs;

d615 1
a615 1

d626 5
a630 63
/* Possible state values for rl_readline_state */
#define RL_STATE_NONE		0x00000		/* no state; before first call */

#define RL_STATE_INITIALIZING	0x00001		/* initializing */
#define RL_STATE_INITIALIZED	0x00002		/* initialization done */
#define RL_STATE_TERMPREPPED	0x00004		/* terminal is prepped */
#define RL_STATE_READCMD	0x00008		/* reading a command key */
#define RL_STATE_METANEXT	0x00010		/* reading input after ESC */
#define RL_STATE_DISPATCHING	0x00020		/* dispatching to a command */
#define RL_STATE_MOREINPUT	0x00040		/* reading more input in a command function */
#define RL_STATE_ISEARCH	0x00080		/* doing incremental search */
#define RL_STATE_NSEARCH	0x00100		/* doing non-inc search */
#define RL_STATE_SEARCH		0x00200		/* doing a history search */
#define RL_STATE_NUMERICARG	0x00400		/* reading numeric argument */
#define RL_STATE_MACROINPUT	0x00800		/* getting input from a macro */
#define RL_STATE_MACRODEF	0x01000		/* defining keyboard macro */
#define RL_STATE_OVERWRITE	0x02000		/* overwrite mode */
#define RL_STATE_COMPLETING	0x04000		/* doing completion */
#define RL_STATE_SIGHANDLER	0x08000		/* in readline sighandler */
#define RL_STATE_UNDOING	0x10000		/* doing an undo */
#define RL_STATE_INPUTPENDING	0x20000		/* rl_execute_next called */

#define RL_STATE_DONE		0x80000		/* done; accepted line */

#define RL_SETSTATE(x)		(rl_readline_state |= (x))
#define RL_UNSETSTATE(x)	(rl_readline_state &= ~(x))
#define RL_ISSTATE(x)		(rl_readline_state & (x))

struct readline_state {
  /* line state */
  int point;
  int end;
  int mark;
  char *buffer;
  int buflen;
  UNDO_LIST *ul;
  char *prompt;

  /* global state */
  int rlstate;
  int done;
  Keymap kmap;

  /* input state */
  rl_command_func_t *lastfunc;
  int insmode;
  int edmode;
  int kseqlen;
  FILE *inf;
  FILE *outf;
  int pendingin;
  char *macro;

  /* signal state */
  int catchsigs;
  int catchsigwinch;

  /* reserved for future expansion, so the struct size doesn't change */
  char reserved[64];
};

extern int rl_save_state PARAMS((struct readline_state *));
extern int rl_restore_state PARAMS((struct readline_state *));
@


1.2
log
@Dummy commit before importof 4.1 version
@
text
@d10 1
a10 1
   as published by the Free Software Foundation; either version 1, or
d21 1
a21 1
   675 Mass Ave, Cambridge, MA 02139, USA. */
d195 1
a195 1
/* Not available unless readline is compiled -DPAREN_MATCHING. */
d334 1
d339 1
a339 1
#if defined (__STDC__) && defined (USE_VARARGS) && defined (PREFER_STDARG)
d409 3
d475 9
d626 1
d628 2
a629 1
extern char *savestring ();	/* XXX backwards compatibility */
@


1.1
log
@Initial revision
@
text
@d26 4
d31 1
d35 1
d69 5
a73 33
/* Functions available to bind to key sequences. */
extern int
  rl_tilde_expand (), rl_set_mark (), rl_exchange_point_and_mark (),
  rl_beg_of_line (), rl_backward (), rl_delete (), rl_end_of_line (),
  rl_forward (), ding (), rl_newline (), rl_kill_line (),
  rl_copy_region_to_kill (), rl_kill_region (), rl_char_search (),
  rl_clear_screen (), rl_get_next_history (), rl_get_previous_history (),
  rl_quoted_insert (), rl_reverse_search_history (), rl_transpose_chars (),
  rl_unix_line_discard (), rl_unix_word_rubout (),
  rl_yank (), rl_rubout (), rl_backward_word (), rl_kill_word (),
  rl_forward_word (), rl_tab_insert (), rl_yank_pop (), rl_yank_nth_arg (),
  rl_backward_kill_word (), rl_backward_kill_line (), rl_transpose_words (),
  rl_complete (), rl_possible_completions (), rl_insert_completions (),
  rl_menu_complete (),
  rl_do_lowercase_version (), rl_kill_full_line (),
  rl_digit_argument (), rl_universal_argument (), rl_abort (),
  rl_undo_command (), rl_revert_line (), rl_beginning_of_history (),
  rl_end_of_history (), rl_forward_search_history (), rl_insert (),
  rl_upcase_word (), rl_downcase_word (), rl_capitalize_word (),
  rl_restart_output (), rl_re_read_init_file (),
  rl_dump_functions (), rl_dump_variables (), rl_dump_macros (),
  rl_delete_horizontal_space (), rl_history_search_forward (),
  rl_history_search_backward (), rl_tty_status (), rl_yank_last_arg (),
  rl_insert_comment (), rl_backward_char_search (),
  rl_copy_forward_word (), rl_copy_backward_word ();

/* Not available unless readline is compiled -DPAREN_MATCHING. */
extern int rl_insert_close ();

/* Not available unless READLINE_CALLBACKS is defined. */
extern void rl_callback_handler_install ();
extern void rl_callback_read_char ();
extern void rl_callback_handler_remove ();
d75 83
d160 1
a160 1
extern int rl_paste_from_clipboard ();
d163 31
a193 2
/* These are *both* defined even when VI_MODE is not. */
extern int rl_vi_editing_mode (), rl_emacs_editing_mode ();
d195 7
a201 5
/* Non incremental history searching. */
extern int rl_noninc_forward_search ();
extern int rl_noninc_reverse_search ();
extern int rl_noninc_forward_search_again ();
extern int rl_noninc_reverse_search_again ();
d204 50
a253 23
extern int rl_vi_check ();
extern int
  rl_vi_undo (), rl_vi_redo (), rl_vi_tilde_expand (),
  rl_vi_movement_mode (), rl_vi_insertion_mode (), rl_vi_arg_digit (),
  rl_vi_prev_word (), rl_vi_next_word (), rl_vi_char_search (),
  rl_vi_eof_maybe (), rl_vi_append_mode (), rl_vi_put (),
  rl_vi_append_eol (), rl_vi_insert_beg (), rl_vi_delete (),
  rl_vi_first_print (), rl_vi_fword (), rl_vi_fWord (), rl_vi_bword (),
  rl_vi_bWord (), rl_vi_eword (), rl_vi_eWord (), rl_vi_end_word (),
  rl_vi_change_case (), rl_vi_match (), rl_vi_bracktype (),
  rl_vi_change_char (), rl_vi_yank_arg (), rl_vi_search (),
  rl_vi_search_again (),  rl_vi_subst (), rl_vi_overstrike (),
  rl_vi_overstrike_delete (), rl_vi_replace(), rl_vi_column (),
  rl_vi_delete_to (), rl_vi_change_to (), rl_vi_yank_to (),
  rl_vi_complete (), rl_vi_fetch_history (), rl_vi_set_mark (),
  rl_vi_goto_mark (), rl_vi_back_to_indent ();

/* Keyboard macro commands. */
extern int rl_start_kbd_macro (), rl_end_kbd_macro ();
extern int rl_call_last_kbd_macro ();
extern void rl_push_macro_input ();

extern int rl_arrow_keys(), rl_refresh_line ();
d263 3
a265 1
extern char *readline ();
d267 1
a267 23
/* These functions are from bind.c. */
/* rl_add_defun (char *name, Function *function, int key)
   Add NAME to the list of named functions.  Make FUNCTION
   be the function that gets called.
   If KEY is not -1, then bind it. */
extern int rl_add_defun ();

extern Keymap rl_make_bare_keymap ();
extern Keymap rl_copy_keymap ();
extern Keymap rl_make_keymap ();
extern void rl_discard_keymap ();
extern Keymap rl_get_keymap (), rl_get_keymap_by_name ();
extern void rl_set_keymap ();
extern char *rl_get_keymap_name ();

extern int rl_bind_key (), rl_bind_key_in_map ();
extern int rl_unbind_key (), rl_unbind_key_in_map ();
extern int rl_unbind_function_in_map (), rl_unbind_command_in_map ();
extern int rl_set_key ();
extern int rl_generic_bind ();
extern int rl_parse_and_bind ();
/* Backwards compatibility, use rl_generic_bind instead. */
extern int rl_macro_bind (), rl_variable_bind ();
d269 11
a279 1
extern int rl_read_init_file ();
d281 2
a282 6
extern Function *rl_named_function (), *rl_function_of_keyseq ();
extern char **rl_invoking_keyseqs (), **rl_invoking_keyseqs_in_map ();
extern void rl_function_dumper ();
extern void rl_variable_dumper ();
extern void rl_macro_dumper ();
extern void rl_list_funmap_names ();
d285 2
a286 2
extern int rl_translate_keyseq ();
extern void rl_initialize_funmap ();
d288 42
a329 5
/* Functions for undoing. */
extern int rl_begin_undo_group (), rl_end_undo_group ();
extern void rl_add_undo (), free_undo_list ();
extern int rl_do_undo ();
extern int rl_modifying ();
d332 5
a336 5
extern void rl_redisplay ();
extern int rl_forced_update_display ();
extern int rl_clear_message ();
extern int rl_reset_line_state ();
extern int rl_on_new_line ();
d345 7
a351 3
extern int rl_character_len ();
extern int rl_show_char ();
extern int crlf ();
d354 32
a385 8
extern int rl_insert_text (), rl_delete_text ();
extern int rl_kill_text ();
extern char *rl_copy_text ();

/* `Public' utility functions. */
extern int rl_reset_terminal ();
extern int rl_stuff_char ();
extern int rl_read_key (), rl_getc ();
d387 3
a389 6
extern int rl_initialize ();

/* Undocumented. */
extern int rl_expand_prompt ();
extern int rl_set_signals (), rl_clear_signals ();
extern int maybe_save_line (), maybe_unsave_line (), maybe_replace_line ();
d392 2
a393 2
/* These functions are from complete.c. */
extern int rl_complete_internal ();
d395 3
a397 5
/* Return an array of strings which are the result of repeatadly calling
   FUNC with TEXT. */
extern char **completion_matches ();
extern char *username_completion_function ();
extern char *filename_completion_function ();
d422 1
d425 2
d429 1
d447 5
d465 18
d541 9
d615 4
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-08-02 snapshot
@
text
@a25 4
#ifdef __cplusplus
extern "C" {
#endif

a26 1
#  include "rlstdc.h"
a29 1
#  include <readline/rlstdc.h>
d63 33
a95 5
/* **************************************************************** */
/*								    */
/*	     Functions available to bind to key sequences	    */
/*								    */
/* **************************************************************** */
a96 83
/* Bindable commands for numeric arguments. */
extern int rl_digit_argument __P((int, int));
extern int rl_universal_argument __P((int, int));

/* Bindable commands for moving the cursor. */
extern int rl_forward __P((int, int));
extern int rl_backward __P((int, int));
extern int rl_beg_of_line __P((int, int));
extern int rl_end_of_line __P((int, int));
extern int rl_forward_word __P((int, int));
extern int rl_backward_word __P((int, int));
extern int rl_refresh_line __P((int, int));
extern int rl_clear_screen __P((int, int));
extern int rl_arrow_keys __P((int, int));

/* Bindable commands for inserting and deleting text. */
extern int rl_insert __P((int, int));
extern int rl_quoted_insert __P((int, int));
extern int rl_tab_insert __P((int, int));
extern int rl_newline __P((int, int));
extern int rl_do_lowercase_version __P((int, int));
extern int rl_rubout __P((int, int));
extern int rl_delete __P((int, int));
extern int rl_rubout_or_delete __P((int, int));
extern int rl_delete_horizontal_space __P((int, int));
extern int rl_delete_or_show_completions __P((int, int));
extern int rl_insert_comment __P((int, int));

/* Bindable commands for changing case. */
extern int rl_upcase_word __P((int, int));
extern int rl_downcase_word __P((int, int));
extern int rl_capitalize_word __P((int, int));

/* Bindable commands for transposing characters and words. */
extern int rl_transpose_words __P((int, int));
extern int rl_transpose_chars __P((int, int));

/* Bindable commands for searching within a line. */
extern int rl_char_search __P((int, int));
extern int rl_backward_char_search __P((int, int));

/* Bindable commands for readline's interface to the command history. */
extern int rl_beginning_of_history __P((int, int));
extern int rl_end_of_history __P((int, int));
extern int rl_get_next_history __P((int, int));
extern int rl_get_previous_history __P((int, int));

/* Bindable commands for managing the mark and region. */
extern int rl_set_mark __P((int, int));
extern int rl_exchange_point_and_mark __P((int, int));

/* Bindable commands to set the editing mode (emacs or vi). */
extern int rl_vi_editing_mode __P((int, int));
extern int rl_emacs_editing_mode __P((int, int));

/* Bindable commands for managing key bindings. */
extern int rl_re_read_init_file __P((int, int));
extern int rl_dump_functions __P((int, int));
extern int rl_dump_macros __P((int, int));
extern int rl_dump_variables __P((int, int));

/* Bindable commands for word completion. */
extern int rl_complete __P((int, int));
extern int rl_possible_completions __P((int, int));
extern int rl_insert_completions __P((int, int));
extern int rl_menu_complete __P((int, int));

/* Bindable commands for killing and yanking text, and managing the kill ring. */
extern int rl_kill_word __P((int, int));
extern int rl_backward_kill_word __P((int, int));
extern int rl_kill_line __P((int, int));
extern int rl_backward_kill_line __P((int, int));
extern int rl_kill_full_line __P((int, int));
extern int rl_unix_word_rubout __P((int, int));
extern int rl_unix_line_discard __P((int, int));
extern int rl_copy_region_to_kill __P((int, int));
extern int rl_kill_region __P((int, int));
extern int rl_copy_forward_word __P((int, int));
extern int rl_copy_backward_word __P((int, int));
extern int rl_yank __P((int, int));
extern int rl_yank_pop __P((int, int));
extern int rl_yank_nth_arg __P((int, int));
extern int rl_yank_last_arg __P((int, int));
d99 1
a99 1
extern int rl_paste_from_clipboard __P((int, int));
d102 2
a103 31
/* Bindable commands for incremental searching. */
extern int rl_reverse_search_history __P((int, int));
extern int rl_forward_search_history __P((int, int));

/* Bindable keyboard macro commands. */
extern int rl_start_kbd_macro __P((int, int));
extern int rl_end_kbd_macro __P((int, int));
extern int rl_call_last_kbd_macro __P((int, int));

/* Bindable undo commands. */
extern int rl_revert_line __P((int, int));
extern int rl_undo_command __P((int, int));

/* Bindable tilde expansion commands. */
extern int rl_tilde_expand __P((int, int));

/* Bindable terminal control commands. */
extern int rl_restart_output __P((int, int));
extern int rl_stop_output __P((int, int));

/* Miscellaneous bindable commands. */
extern int rl_abort __P((int, int));
extern int rl_tty_status __P((int, int));

/* Bindable commands for incremental and non-incremental history searching. */
extern int rl_history_search_forward __P((int, int));
extern int rl_history_search_backward __P((int, int));
extern int rl_noninc_forward_search __P((int, int));
extern int rl_noninc_reverse_search __P((int, int));
extern int rl_noninc_forward_search_again __P((int, int));
extern int rl_noninc_reverse_search_again __P((int, int));
d105 5
a109 2
/* Not available unless readline is compiled -DPAREN_MATCHING. */
extern int rl_insert_close __P((int, int));
d111 22
a132 4
/* Not available unless READLINE_CALLBACKS is defined. */
extern void rl_callback_handler_install __P((char *, VFunction *));
extern void rl_callback_read_char __P((void));
extern void rl_callback_handler_remove __P((void));
d134 1
a134 51
/* Things for vi mode. Not available unless readline is compiled -DVI_MODE. */
/* VI-mode bindable commands. */
extern int rl_vi_redo __P((int, int));
extern int rl_vi_undo __P((int, int));
extern int rl_vi_yank_arg __P((int, int));
extern int rl_vi_fetch_history __P((int, int));
extern int rl_vi_search_again __P((int, int));
extern int rl_vi_search __P((int, int));
extern int rl_vi_complete __P((int, int));
extern int rl_vi_tilde_expand __P((int, int));
extern int rl_vi_prev_word __P((int, int));
extern int rl_vi_next_word __P((int, int));
extern int rl_vi_end_word __P((int, int));
extern int rl_vi_insert_beg __P((int, int));
extern int rl_vi_append_mode __P((int, int));
extern int rl_vi_append_eol __P((int, int));
extern int rl_vi_eof_maybe __P((int, int));
extern int rl_vi_insertion_mode __P((int, int));
extern int rl_vi_movement_mode __P((int, int));
extern int rl_vi_arg_digit __P((int, int));
extern int rl_vi_change_case __P((int, int));
extern int rl_vi_put __P((int, int));
extern int rl_vi_column __P((int, int));
extern int rl_vi_delete_to __P((int, int));
extern int rl_vi_change_to __P((int, int));
extern int rl_vi_yank_to __P((int, int));
extern int rl_vi_delete __P((int, int));
extern int rl_vi_back_to_indent __P((int, int));
extern int rl_vi_first_print __P((int, int));
extern int rl_vi_char_search __P((int, int));
extern int rl_vi_match __P((int, int));
extern int rl_vi_change_char __P((int, int));
extern int rl_vi_subst __P((int, int));
extern int rl_vi_overstrike __P((int, int));
extern int rl_vi_overstrike_delete __P((int, int));
extern int rl_vi_replace __P((int, int));
extern int rl_vi_set_mark __P((int, int));
extern int rl_vi_goto_mark __P((int, int));

/* VI-mode utility functions. */
extern int rl_vi_check __P((void));
extern int rl_vi_domove __P((int, int *));
extern int rl_vi_bracktype __P((int));

/* VI-mode pseudo-bindable commands, used as utility functions. */
extern int rl_vi_fWord __P((int, int));
extern int rl_vi_bWord __P((int, int));
extern int rl_vi_eWord __P((int, int));
extern int rl_vi_fword __P((int, int));
extern int rl_vi_bword __P((int, int));
extern int rl_vi_eword __P((int, int));
d144 1
a144 1
extern char *readline __P((char *));
d146 23
a168 1
extern int rl_initialize __P((void));
d170 1
a170 1
extern int rl_discard_argument __P((void));
d172 6
a177 14
/* Utility functions to bind keys to readline commands. */
extern int rl_add_defun __P((char *, Function *, int));
extern int rl_bind_key __P((int, Function *));
extern int rl_bind_key_in_map __P((int, Function *, Keymap));
extern int rl_unbind_key __P((int));
extern int rl_unbind_key_in_map __P((int, Keymap));
extern int rl_unbind_function_in_map __P((Function *, Keymap));
extern int rl_unbind_command_in_map __P((char *, Keymap));
extern int rl_set_key __P((char *, Function *, Keymap));
extern int rl_generic_bind __P((int, char *, char *, Keymap));
extern int rl_variable_bind __P((char *, char *));

/* Backwards compatibility, use rl_generic_bind instead. */
extern int rl_macro_bind __P((char *, char *, Keymap));
d180 2
a181 2
extern int rl_translate_keyseq __P((char *, char *, int *));
extern char *rl_untranslate_keyseq __P((int));
d183 5
a187 42
extern Function *rl_named_function __P((char *));
extern Function *rl_function_of_keyseq __P((char *, Keymap, int *));

extern void rl_list_funmap_names __P((void));
extern char **rl_invoking_keyseqs_in_map __P((Function *, Keymap));
extern char **rl_invoking_keyseqs __P((Function *));
 
extern void rl_function_dumper __P((int));
extern void rl_macro_dumper __P((int));
extern void rl_variable_dumper __P((int));

extern int rl_read_init_file __P((char *));
extern int rl_parse_and_bind __P((char *));

/* Functions for manipulating keymaps. */
extern Keymap rl_make_bare_keymap __P((void));
extern Keymap rl_copy_keymap __P((Keymap));
extern Keymap rl_make_keymap __P((void));
extern void rl_discard_keymap __P((Keymap));

extern Keymap rl_get_keymap_by_name __P((char *));
extern char *rl_get_keymap_name __P((Keymap));
extern void rl_set_keymap __P((Keymap));
extern Keymap rl_get_keymap __P((void));
extern void rl_set_keymap_from_edit_mode __P((void));
extern char *rl_get_keymap_name_from_edit_mode __P((void));

/* Functions for manipulating the funmap, which maps command names to functions. */
extern int rl_add_funmap_entry __P((char *, Function *));
extern void rl_initialize_funmap __P((void));
extern char **rl_funmap_names __P((void));

/* Utility functions for managing keyboard macros. */
extern void rl_push_macro_input __P((char *));

/* Functions for undoing, from undo.c */
extern void rl_add_undo __P((enum undo_code, int, int, char *));
extern void free_undo_list __P((void));
extern int rl_do_undo __P((void));
extern int rl_begin_undo_group __P((void));
extern int rl_end_undo_group __P((void));
extern int rl_modifying __P((int, int));
d190 5
a194 5
extern void rl_redisplay __P((void));
extern int rl_on_new_line __P((void));
extern int rl_forced_update_display __P((void));
extern int rl_clear_message __P((void));
extern int rl_reset_line_state __P((void));
d203 3
a205 7
extern int rl_show_char __P((int));
extern int rl_character_len __P((int, int));
extern int crlf __P((void));

/* Save and restore internal prompt redisplay information. */
extern void rl_save_prompt __P((void));
extern void rl_restore_prompt __P((void));
d208 11
a218 30
extern int rl_insert_text __P((char *));
extern int rl_delete_text __P((int, int));
extern int rl_kill_text __P((int, int));
extern char *rl_copy_text __P((int, int));

/* Terminal and tty mode management. */
extern void rl_prep_terminal __P((int));
extern void rl_deprep_terminal __P((void));
extern void rltty_set_default_bindings __P((Keymap));

extern int rl_reset_terminal __P((char *));
extern void rl_resize_terminal __P((void));

/* `Public' utility functions . */
extern void rl_extend_line_buffer __P((int));
extern int ding __P((void));

/* Functions for character input. */
extern int rl_stuff_char __P((int));
extern int rl_execute_next __P((int));
extern int rl_read_key __P((void));
extern int rl_getc __P((FILE *));

/* Readline signal handling, from signals.c */
extern int rl_set_signals __P((void));
extern int rl_clear_signals __P((void));
extern void rl_cleanup_after_signal __P((void));
extern void rl_reset_after_signal __P((void));
extern void rl_free_line_state __P((void));
 
d220 3
a222 5
extern int rl_expand_prompt __P((char *));

extern int maybe_save_line __P((void));
extern int maybe_unsave_line __P((void));
extern int maybe_replace_line __P((void));
d225 2
a226 2
extern int rl_complete_internal __P((int));
extern void rl_display_match_list __P((char **, int, int));
d228 5
a232 3
extern char **completion_matches __P((char *, CPFunction *));
extern char *username_completion_function __P((char *, int));
extern char *filename_completion_function __P((char *, int));
a256 1
/* The mark, or saved cursor position. */
a258 2
/* Flag to indicate that readline has finished with the current input
   line and should return it. */
a260 1
/* If set to a character value, that will be the next keystroke read. */
a277 5
/* If non-zero, this is the address of a function to call just before
   readline_internal_setup () returns and readline_internal starts
   reading input characters. */
extern Function *rl_pre_input_hook;
      
a290 18
/* Display variables. */
/* If non-zero, readline will erase the entire line, including any prompt,
   if the only thing typed on an otherwise-blank line is something bound to
   rl_newline. */
extern int rl_erase_empty_line;

/* Variables to control readline signal handling. */
/* If non-zero, readline will install its own signal handlers for
   SIGINT, SIGTERM, SIGQUIT, SIGALRM, SIGTSTP, SIGTTIN, and SIGTTOU. */
extern int rl_catch_signals;

/* If non-zero, readline will install a signal handler for SIGWINCH
   that also attempts to call any calling application's SIGWINCH signal
   handler.  Note that the terminal is not cleaned up before the
   application's signal handler is called; use rl_cleanup_after_signal()
   to do that. */
extern int rl_catch_sigwinch;

a348 9
/* If non-zero, then this is the address of a function to call when
   completing a word would normally display the list of possible matches.
   This function is called instead of actually doing the display.
   It takes three arguments: (char **matches, int num_matches, int max_length)
   where MATCHES is the array of strings that matched, NUM_MATCHES is the
   number of strings in that array, and MAX_LENGTH is the length of the
   longest string in that array. */
extern VFunction *rl_completion_display_matches_hook;

a413 4
#endif

#ifdef __cplusplus
}
@


1.1.1.3
log
@Import of readline 4.1
@
text
@d10 1
a10 1
   as published by the Free Software Foundation; either version 2, or
d21 1
a21 1
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
d195 1
a195 1
/* Bindable command used when inserting a matching close character. */
a333 1
extern int rl_on_new_line_with_prompt __P((void));
d338 1
a338 1
#if (defined (__STDC__) || defined (__cplusplus)) && defined (USE_VARARGS) && defined (PREFER_STDARG)
a407 3
/* True if this is real GNU readline. */
extern int rl_gnu_readline_p;

a470 9
/* If non-zero, the application has already printed the prompt (rl_prompt)
   before calling readline, so readline should not output it the first time
   redisplay is done. */
extern int rl_already_prompted;

/* A non-zero value means to read only this many characters rather than
   up to a character bound to accept-line. */
extern int rl_num_chars_to_read;

d614 1
a614 1
extern char *savestring __P((char *));	/* XXX backwards compatibility */
@


1.1.1.4
log
@import of readline-4.3
@
text
@a31 1
#  include "rltypedefs.h"
a35 1
#  include <readline/rltypedefs.h>
a39 5
/* Hex-encoded Readline version number. */
#define RL_READLINE_VERSION	0x0403		/* Readline 4.3 */
#define RL_VERSION_MAJOR	4
#define RL_VERSION_MINOR	3

d63 2
a64 2
  const char *name;
  rl_command_func_t *function;
d76 2
a77 2
extern int rl_digit_argument PARAMS((int, int));
extern int rl_universal_argument PARAMS((int, int));
d80 9
a88 13
extern int rl_forward_byte PARAMS((int, int));
extern int rl_forward_char PARAMS((int, int));
extern int rl_forward PARAMS((int, int));
extern int rl_backward_byte PARAMS((int, int));
extern int rl_backward_char PARAMS((int, int));
extern int rl_backward PARAMS((int, int));
extern int rl_beg_of_line PARAMS((int, int));
extern int rl_end_of_line PARAMS((int, int));
extern int rl_forward_word PARAMS((int, int));
extern int rl_backward_word PARAMS((int, int));
extern int rl_refresh_line PARAMS((int, int));
extern int rl_clear_screen PARAMS((int, int));
extern int rl_arrow_keys PARAMS((int, int));
d91 11
a101 11
extern int rl_insert PARAMS((int, int));
extern int rl_quoted_insert PARAMS((int, int));
extern int rl_tab_insert PARAMS((int, int));
extern int rl_newline PARAMS((int, int));
extern int rl_do_lowercase_version PARAMS((int, int));
extern int rl_rubout PARAMS((int, int));
extern int rl_delete PARAMS((int, int));
extern int rl_rubout_or_delete PARAMS((int, int));
extern int rl_delete_horizontal_space PARAMS((int, int));
extern int rl_delete_or_show_completions PARAMS((int, int));
extern int rl_insert_comment PARAMS((int, int));
d104 3
a106 3
extern int rl_upcase_word PARAMS((int, int));
extern int rl_downcase_word PARAMS((int, int));
extern int rl_capitalize_word PARAMS((int, int));
d109 2
a110 2
extern int rl_transpose_words PARAMS((int, int));
extern int rl_transpose_chars PARAMS((int, int));
d113 2
a114 2
extern int rl_char_search PARAMS((int, int));
extern int rl_backward_char_search PARAMS((int, int));
d117 4
a120 4
extern int rl_beginning_of_history PARAMS((int, int));
extern int rl_end_of_history PARAMS((int, int));
extern int rl_get_next_history PARAMS((int, int));
extern int rl_get_previous_history PARAMS((int, int));
d123 2
a124 2
extern int rl_set_mark PARAMS((int, int));
extern int rl_exchange_point_and_mark PARAMS((int, int));
d127 2
a128 5
extern int rl_vi_editing_mode PARAMS((int, int));
extern int rl_emacs_editing_mode PARAMS((int, int));

/* Bindable commands to change the insert mode (insert or overwrite) */
extern int rl_overwrite_mode PARAMS((int, int));
d131 4
a134 4
extern int rl_re_read_init_file PARAMS((int, int));
extern int rl_dump_functions PARAMS((int, int));
extern int rl_dump_macros PARAMS((int, int));
extern int rl_dump_variables PARAMS((int, int));
d137 4
a140 4
extern int rl_complete PARAMS((int, int));
extern int rl_possible_completions PARAMS((int, int));
extern int rl_insert_completions PARAMS((int, int));
extern int rl_menu_complete PARAMS((int, int));
d143 18
a160 18
extern int rl_kill_word PARAMS((int, int));
extern int rl_backward_kill_word PARAMS((int, int));
extern int rl_kill_line PARAMS((int, int));
extern int rl_backward_kill_line PARAMS((int, int));
extern int rl_kill_full_line PARAMS((int, int));
extern int rl_unix_word_rubout PARAMS((int, int));
extern int rl_unix_line_discard PARAMS((int, int));
extern int rl_copy_region_to_kill PARAMS((int, int));
extern int rl_kill_region PARAMS((int, int));
extern int rl_copy_forward_word PARAMS((int, int));
extern int rl_copy_backward_word PARAMS((int, int));
extern int rl_yank PARAMS((int, int));
extern int rl_yank_pop PARAMS((int, int));
extern int rl_yank_nth_arg PARAMS((int, int));
extern int rl_yank_last_arg PARAMS((int, int));
/* Not available unless __CYGWIN__ is defined. */
#ifdef __CYGWIN__
extern int rl_paste_from_clipboard PARAMS((int, int));
d164 2
a165 2
extern int rl_reverse_search_history PARAMS((int, int));
extern int rl_forward_search_history PARAMS((int, int));
d168 3
a170 3
extern int rl_start_kbd_macro PARAMS((int, int));
extern int rl_end_kbd_macro PARAMS((int, int));
extern int rl_call_last_kbd_macro PARAMS((int, int));
d173 2
a174 2
extern int rl_revert_line PARAMS((int, int));
extern int rl_undo_command PARAMS((int, int));
d177 1
a177 1
extern int rl_tilde_expand PARAMS((int, int));
d180 2
a181 2
extern int rl_restart_output PARAMS((int, int));
extern int rl_stop_output PARAMS((int, int));
d184 2
a185 2
extern int rl_abort PARAMS((int, int));
extern int rl_tty_status PARAMS((int, int));
d188 6
a193 6
extern int rl_history_search_forward PARAMS((int, int));
extern int rl_history_search_backward PARAMS((int, int));
extern int rl_noninc_forward_search PARAMS((int, int));
extern int rl_noninc_reverse_search PARAMS((int, int));
extern int rl_noninc_forward_search_again PARAMS((int, int));
extern int rl_noninc_reverse_search_again PARAMS((int, int));
d196 1
a196 1
extern int rl_insert_close PARAMS((int, int));
d199 3
a201 3
extern void rl_callback_handler_install PARAMS((const char *, rl_vcpfunc_t *));
extern void rl_callback_read_char PARAMS((void));
extern void rl_callback_handler_remove PARAMS((void));
d205 36
a240 36
extern int rl_vi_redo PARAMS((int, int));
extern int rl_vi_undo PARAMS((int, int));
extern int rl_vi_yank_arg PARAMS((int, int));
extern int rl_vi_fetch_history PARAMS((int, int));
extern int rl_vi_search_again PARAMS((int, int));
extern int rl_vi_search PARAMS((int, int));
extern int rl_vi_complete PARAMS((int, int));
extern int rl_vi_tilde_expand PARAMS((int, int));
extern int rl_vi_prev_word PARAMS((int, int));
extern int rl_vi_next_word PARAMS((int, int));
extern int rl_vi_end_word PARAMS((int, int));
extern int rl_vi_insert_beg PARAMS((int, int));
extern int rl_vi_append_mode PARAMS((int, int));
extern int rl_vi_append_eol PARAMS((int, int));
extern int rl_vi_eof_maybe PARAMS((int, int));
extern int rl_vi_insertion_mode PARAMS((int, int));
extern int rl_vi_movement_mode PARAMS((int, int));
extern int rl_vi_arg_digit PARAMS((int, int));
extern int rl_vi_change_case PARAMS((int, int));
extern int rl_vi_put PARAMS((int, int));
extern int rl_vi_column PARAMS((int, int));
extern int rl_vi_delete_to PARAMS((int, int));
extern int rl_vi_change_to PARAMS((int, int));
extern int rl_vi_yank_to PARAMS((int, int));
extern int rl_vi_delete PARAMS((int, int));
extern int rl_vi_back_to_indent PARAMS((int, int));
extern int rl_vi_first_print PARAMS((int, int));
extern int rl_vi_char_search PARAMS((int, int));
extern int rl_vi_match PARAMS((int, int));
extern int rl_vi_change_char PARAMS((int, int));
extern int rl_vi_subst PARAMS((int, int));
extern int rl_vi_overstrike PARAMS((int, int));
extern int rl_vi_overstrike_delete PARAMS((int, int));
extern int rl_vi_replace PARAMS((int, int));
extern int rl_vi_set_mark PARAMS((int, int));
extern int rl_vi_goto_mark PARAMS((int, int));
d243 3
a245 3
extern int rl_vi_check PARAMS((void));
extern int rl_vi_domove PARAMS((int, int *));
extern int rl_vi_bracktype PARAMS((int));
d248 6
a253 6
extern int rl_vi_fWord PARAMS((int, int));
extern int rl_vi_bWord PARAMS((int, int));
extern int rl_vi_eWord PARAMS((int, int));
extern int rl_vi_fword PARAMS((int, int));
extern int rl_vi_bword PARAMS((int, int));
extern int rl_vi_eword PARAMS((int, int));
d263 1
a263 1
extern char *readline PARAMS((const char *));
d265 1
a265 2
extern int rl_set_prompt PARAMS((const char *));
extern int rl_expand_prompt PARAMS((char *));
d267 1
a267 4
extern int rl_initialize PARAMS((void));

/* Undocumented; unused by readline */
extern int rl_discard_argument PARAMS((void));
d270 10
a279 10
extern int rl_add_defun PARAMS((const char *, rl_command_func_t *, int));
extern int rl_bind_key PARAMS((int, rl_command_func_t *));
extern int rl_bind_key_in_map PARAMS((int, rl_command_func_t *, Keymap));
extern int rl_unbind_key PARAMS((int));
extern int rl_unbind_key_in_map PARAMS((int, Keymap));
extern int rl_unbind_function_in_map PARAMS((rl_command_func_t *, Keymap));
extern int rl_unbind_command_in_map PARAMS((const char *, Keymap));
extern int rl_set_key PARAMS((const char *, rl_command_func_t *, Keymap));
extern int rl_generic_bind PARAMS((int, const char *, char *, Keymap));
extern int rl_variable_bind PARAMS((const char *, const char *));
d282 1
a282 1
extern int rl_macro_bind PARAMS((const char *, const char *, Keymap));
d285 2
a286 2
extern int rl_translate_keyseq PARAMS((const char *, char *, int *));
extern char *rl_untranslate_keyseq PARAMS((int));
d288 2
a289 2
extern rl_command_func_t *rl_named_function PARAMS((const char *));
extern rl_command_func_t *rl_function_of_keyseq PARAMS((const char *, Keymap, int *));
d291 3
a293 3
extern void rl_list_funmap_names PARAMS((void));
extern char **rl_invoking_keyseqs_in_map PARAMS((rl_command_func_t *, Keymap));
extern char **rl_invoking_keyseqs PARAMS((rl_command_func_t *));
d295 3
a297 3
extern void rl_function_dumper PARAMS((int));
extern void rl_macro_dumper PARAMS((int));
extern void rl_variable_dumper PARAMS((int));
d299 2
a300 2
extern int rl_read_init_file PARAMS((const char *));
extern int rl_parse_and_bind PARAMS((char *));
d303 11
a313 12
extern Keymap rl_make_bare_keymap PARAMS((void));
extern Keymap rl_copy_keymap PARAMS((Keymap));
extern Keymap rl_make_keymap PARAMS((void));
extern void rl_discard_keymap PARAMS((Keymap));

extern Keymap rl_get_keymap_by_name PARAMS((const char *));
extern char *rl_get_keymap_name PARAMS((Keymap));
extern void rl_set_keymap PARAMS((Keymap));
extern Keymap rl_get_keymap PARAMS((void));
/* Undocumented; used internally only. */
extern void rl_set_keymap_from_edit_mode PARAMS((void));
extern char *rl_get_keymap_name_from_edit_mode PARAMS((void));
d316 3
a318 5
extern int rl_add_funmap_entry PARAMS((const char *, rl_command_func_t *));
extern const char **rl_funmap_names PARAMS((void));
/* Undocumented, only used internally -- there is only one funmap, and this
   function may be called only once. */
extern void rl_initialize_funmap PARAMS((void));
d321 1
a321 1
extern void rl_push_macro_input PARAMS((char *));
d324 6
a329 6
extern void rl_add_undo PARAMS((enum undo_code, int, int, char *));
extern void rl_free_undo_list PARAMS((void));
extern int rl_do_undo PARAMS((void));
extern int rl_begin_undo_group PARAMS((void));
extern int rl_end_undo_group PARAMS((void));
extern int rl_modifying PARAMS((int, int));
d332 6
a337 7
extern void rl_redisplay PARAMS((void));
extern int rl_on_new_line PARAMS((void));
extern int rl_on_new_line_with_prompt PARAMS((void));
extern int rl_forced_update_display PARAMS((void));
extern int rl_clear_message PARAMS((void));
extern int rl_reset_line_state PARAMS((void));
extern int rl_crlf PARAMS((void));
d340 1
a340 1
extern int rl_message (const char *, ...)  __attribute__((__format__ (printf, 1, 2)));
a344 2
extern int rl_show_char PARAMS((int));

d346 3
a348 1
extern int rl_character_len PARAMS((int, int));
d351 2
a352 2
extern void rl_save_prompt PARAMS((void));
extern void rl_restore_prompt PARAMS((void));
d355 4
a358 5
extern void rl_replace_line PARAMS((const char *, int));
extern int rl_insert_text PARAMS((const char *));
extern int rl_delete_text PARAMS((int, int));
extern int rl_kill_text PARAMS((int, int));
extern char *rl_copy_text PARAMS((int, int));
d361 3
a363 8
extern void rl_prep_terminal PARAMS((int));
extern void rl_deprep_terminal PARAMS((void));
extern void rl_tty_set_default_bindings PARAMS((Keymap));

extern int rl_reset_terminal PARAMS((const char *));
extern void rl_resize_terminal PARAMS((void));
extern void rl_set_screen_size PARAMS((int, int));
extern void rl_get_screen_size PARAMS((int *, int *));
d365 6
a370 1
extern char *rl_get_termcap PARAMS((const char *));
d373 4
a376 11
extern int rl_stuff_char PARAMS((int));
extern int rl_execute_next PARAMS((int));
extern int rl_clear_pending_input PARAMS((void));
extern int rl_read_key PARAMS((void));
extern int rl_getc PARAMS((FILE *));
extern int rl_set_keyboard_input_timeout PARAMS((int));

/* `Public' utility functions . */
extern void rl_extend_line_buffer PARAMS((int));
extern int rl_ding PARAMS((void));
extern int rl_alphabetic PARAMS((int));
d379 5
a383 5
extern int rl_set_signals PARAMS((void));
extern int rl_clear_signals PARAMS((void));
extern void rl_cleanup_after_signal PARAMS((void));
extern void rl_reset_after_signal PARAMS((void));
extern void rl_free_line_state PARAMS((void));
d385 2
a386 1
extern int rl_set_paren_blink_timeout PARAMS((int));
d388 3
a390 4
/* Undocumented. */
extern int rl_maybe_save_line PARAMS((void));
extern int rl_maybe_unsave_line PARAMS((void));
extern int rl_maybe_replace_line PARAMS((void));
d393 2
a394 2
extern int rl_complete_internal PARAMS((int));
extern void rl_display_match_list PARAMS((char **, int, int));
d396 3
a398 21
extern char **rl_completion_matches PARAMS((const char *, rl_compentry_func_t *));
extern char *rl_username_completion_function PARAMS((const char *, int));
extern char *rl_filename_completion_function PARAMS((const char *, int));

extern int rl_completion_mode PARAMS((rl_command_func_t *));

#if 0
/* Backwards compatibility (compat.c).  These will go away sometime. */
extern void free_undo_list PARAMS((void));
extern int maybe_save_line PARAMS((void));
extern int maybe_unsave_line PARAMS((void));
extern int maybe_replace_line PARAMS((void));

extern int ding PARAMS((void));
extern int alphabetic PARAMS((int));
extern int crlf PARAMS((void));

extern char **completion_matches PARAMS((char *, rl_compentry_func_t *));
extern char *username_completion_function PARAMS((const char *, int));
extern char *filename_completion_function PARAMS((const char *, int));
#endif
d407 1
a407 2
extern const char *rl_library_version;		/* e.g., "4.2" */
extern int rl_readline_version;			/* e.g., 0x0402 */
a411 11
/* Flags word encapsulating the current readline state. */
extern int rl_readline_state;

/* Says which editing mode readline is currently using.  1 means emacs mode;
   0 means vi mode. */
extern int rl_editing_mode;

/* Insert or overwrite mode for emacs mode.  1 means insert mode; 0 means
   overwrite mode.  Reset to insert mode on each input line. */
extern int rl_insert_mode;

d414 1
a414 1
extern const char *rl_readline_name;
d424 1
a424 2
extern int rl_point;
extern int rl_end;
a440 10
/* Non-zero if the user typed a numeric argument before executing the
   current function. */
extern int rl_explicit_arg;

/* The current value of the numeric argument specified by the user. */
extern int rl_numeric_arg;

/* The address of the last command function Readline executed. */
extern rl_command_func_t *rl_last_func;

d442 1
a442 1
extern const char *rl_terminal_name;
d445 1
a445 2
extern FILE *rl_instream;
extern FILE *rl_outstream;
d449 1
a449 1
extern rl_hook_func_t *rl_startup_hook;
d454 1
a454 1
extern rl_hook_func_t *rl_pre_input_hook;
d458 1
a458 5
extern rl_hook_func_t *rl_event_hook;

/* The address of the function to call to fetch a character from the current
   Readline input stream */
extern rl_getc_func_t *rl_getc_function;
d460 4
a463 4
extern rl_voidfunc_t *rl_redisplay_function;

extern rl_vintfunc_t *rl_prep_term_function;
extern rl_voidfunc_t *rl_deprep_term_function;
a483 3
/* The text of a currently-executing keyboard macro. */
extern char *rl_executing_macro;

d498 3
a500 3
   NULL means to use rl_filename_completion_function (), the default
   filename completer. */
extern rl_compentry_func_t *rl_completion_entry_function;
d508 1
a508 1
extern rl_compignore_func_t *rl_ignore_some_completions_function;
d517 1
a517 1
extern rl_completion_func_t *rl_attempted_completion_function;
d522 1
a522 1
extern const char *rl_basic_word_break_characters;
d527 1
a527 1
extern const char *rl_completer_word_break_characters;
d533 1
a533 1
extern const char *rl_completer_quote_characters;
d536 1
a536 1
extern const char *rl_basic_quote_characters;
d539 1
a539 1
extern const char *rl_filename_quote_characters;
d544 1
a544 1
extern const char *rl_special_prefixes;
d548 2
a549 13
   the address of a string (the current directory name) as an arg.  It
   changes what is displayed when the possible completions are printed
   or inserted. */
extern rl_icppfunc_t *rl_directory_completion_hook;

/* If non-zero, this is the address of a function to call when completing
   a directory name.  This function takes the address of the directory name
   to be modified as an argument.  Unlike rl_directory_completion_hook, it
   only modifies the directory name used in opendir(2), not what is displayed
   when the possible completions are printed or inserted.  It is called
   before rl_directory_completion_hook.  I'm not happy with how this works
   yet, so it's undocumented. */
extern rl_icppfunc_t *rl_directory_rewrite_hook;
d561 1
a561 1
extern rl_compdisp_func_t *rl_completion_display_matches_hook;
d579 1
a579 1
extern rl_quote_func_t *rl_filename_quoting_function;
d584 1
a584 1
extern rl_dequote_func_t *rl_filename_dequoting_function;
d589 1
a589 1
extern rl_linebuf_func_t *rl_char_is_quoted_p;
a603 4
/* If set to non-zero by an application completion function,
   rl_completion_append_character will not be appended. */
extern int rl_completion_suppress_append;

a608 11
/* If non-zero, a slash will be appended to completed filenames that are
   symbolic links to directory names, subject to the value of the
   mark-directories variable (which is user-settable).  This exists so
   that application completion functions can override the user's preference
   (set via the mark-symlinked-directories variable) if appropriate.
   It's set to the value of _rl_complete_mark_symlink_dirs in
   rl_complete_internal before any application-specific completion
   function is called, so without that function doing anything, the user's
   preferences are honored. */
extern int rl_completion_mark_symlink_dirs;

d615 1
a615 1

d626 3
a628 63
/* Possible state values for rl_readline_state */
#define RL_STATE_NONE		0x00000		/* no state; before first call */

#define RL_STATE_INITIALIZING	0x00001		/* initializing */
#define RL_STATE_INITIALIZED	0x00002		/* initialization done */
#define RL_STATE_TERMPREPPED	0x00004		/* terminal is prepped */
#define RL_STATE_READCMD	0x00008		/* reading a command key */
#define RL_STATE_METANEXT	0x00010		/* reading input after ESC */
#define RL_STATE_DISPATCHING	0x00020		/* dispatching to a command */
#define RL_STATE_MOREINPUT	0x00040		/* reading more input in a command function */
#define RL_STATE_ISEARCH	0x00080		/* doing incremental search */
#define RL_STATE_NSEARCH	0x00100		/* doing non-inc search */
#define RL_STATE_SEARCH		0x00200		/* doing a history search */
#define RL_STATE_NUMERICARG	0x00400		/* reading numeric argument */
#define RL_STATE_MACROINPUT	0x00800		/* getting input from a macro */
#define RL_STATE_MACRODEF	0x01000		/* defining keyboard macro */
#define RL_STATE_OVERWRITE	0x02000		/* overwrite mode */
#define RL_STATE_COMPLETING	0x04000		/* doing completion */
#define RL_STATE_SIGHANDLER	0x08000		/* in readline sighandler */
#define RL_STATE_UNDOING	0x10000		/* doing an undo */
#define RL_STATE_INPUTPENDING	0x20000		/* rl_execute_next called */

#define RL_STATE_DONE		0x80000		/* done; accepted line */

#define RL_SETSTATE(x)		(rl_readline_state |= (x))
#define RL_UNSETSTATE(x)	(rl_readline_state &= ~(x))
#define RL_ISSTATE(x)		(rl_readline_state & (x))

struct readline_state {
  /* line state */
  int point;
  int end;
  int mark;
  char *buffer;
  int buflen;
  UNDO_LIST *ul;
  char *prompt;

  /* global state */
  int rlstate;
  int done;
  Keymap kmap;

  /* input state */
  rl_command_func_t *lastfunc;
  int insmode;
  int edmode;
  int kseqlen;
  FILE *inf;
  FILE *outf;
  int pendingin;
  char *macro;

  /* signal state */
  int catchsigs;
  int catchsigwinch;

  /* reserved for future expansion, so the struct size doesn't change */
  char reserved[64];
};

extern int rl_save_state PARAMS((struct readline_state *));
extern int rl_restore_state PARAMS((struct readline_state *));
@


1.1.1.5
log
@import of readlilne 5.1
@
text
@d3 1
a3 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
d43 3
a45 3
#define RL_READLINE_VERSION	0x0501		/* Readline 5.1 */
#define RL_VERSION_MAJOR	5
#define RL_VERSION_MINOR	1
a162 1
extern int rl_unix_filename_rubout PARAMS((int, int));
a242 1
extern int rl_vi_rubout PARAMS((int, int));
a260 2
extern void rl_vi_start_inserting PARAMS((int, int, int));

a292 2
extern int rl_bind_key_if_unbound PARAMS((int, rl_command_func_t *));
extern int rl_bind_key_if_unbound_in_map PARAMS((int, rl_command_func_t *, Keymap));
d295 1
a295 4
extern int rl_bind_keyseq PARAMS((const char *, rl_command_func_t *));
extern int rl_bind_keyseq_in_map PARAMS((const char *, rl_command_func_t *, Keymap));
extern int rl_bind_keyseq_if_unbound PARAMS((const char *, rl_command_func_t *));
extern int rl_bind_keyseq_if_unbound_in_map PARAMS((const char *, rl_command_func_t *, Keymap));
a296 2

extern char *rl_variable_value PARAMS((const char *));
a298 3
/* Backwards compatibility, use rl_bind_keyseq_in_map instead. */
extern int rl_set_key PARAMS((const char *, rl_command_func_t *, Keymap));

d361 1
a361 1
#if defined (USE_VARARGS) && defined (PREFER_STDARG)
a386 1
extern void rl_tty_unset_default_bindings PARAMS((Keymap));
a391 1
extern void rl_reset_screen_size PARAMS((void));
a518 5
/* If non-zero, Readline gives values of LINES and COLUMNS from the environment
   greater precedence than values fetched from the kernel when computing the
   screen dimensions. */
extern int rl_prefer_env_winsize;

d606 1
a606 6
extern /*const*/ char *rl_completer_word_break_characters;

/* Hook function to allow an application to set the completion word
   break characters before readline breaks up the line.  Allows
   position-dependent word break characters. */
extern rl_cpvfunc_t *rl_completion_word_break_hook;
a689 5
/* Up to this many items will be displayed in response to a
   possible-completions call.  After that, we ask the user if she
   is sure she wants to see them all.  The default value is 100. */
extern int rl_completion_query_items;

d698 4
a701 12
/* Set to any quote character readline thinks it finds before any application
   completion function is called. */
extern int rl_completion_quote_character;

/* Set to a non-zero value if readline found quoting anywhere in the word to
   be completed; set before any application completion function is called. */
extern int rl_completion_found_quote;

/* If non-zero, the completion functions don't append any closing quote.
   This is set to 0 by rl_complete_internal and may be changed by an
   application-specific completion function. */
extern int rl_completion_suppress_quote;
d732 1
a732 1
#define RL_STATE_NONE		0x000000		/* no state; before first call */
d734 18
a751 23
#define RL_STATE_INITIALIZING	0x000001	/* initializing */
#define RL_STATE_INITIALIZED	0x000002	/* initialization done */
#define RL_STATE_TERMPREPPED	0x000004	/* terminal is prepped */
#define RL_STATE_READCMD	0x000008	/* reading a command key */
#define RL_STATE_METANEXT	0x000010	/* reading input after ESC */
#define RL_STATE_DISPATCHING	0x000020	/* dispatching to a command */
#define RL_STATE_MOREINPUT	0x000040	/* reading more input in a command function */
#define RL_STATE_ISEARCH	0x000080	/* doing incremental search */
#define RL_STATE_NSEARCH	0x000100	/* doing non-inc search */
#define RL_STATE_SEARCH		0x000200	/* doing a history search */
#define RL_STATE_NUMERICARG	0x000400	/* reading numeric argument */
#define RL_STATE_MACROINPUT	0x000800	/* getting input from a macro */
#define RL_STATE_MACRODEF	0x001000	/* defining keyboard macro */
#define RL_STATE_OVERWRITE	0x002000	/* overwrite mode */
#define RL_STATE_COMPLETING	0x004000	/* doing completion */
#define RL_STATE_SIGHANDLER	0x008000	/* in readline sighandler */
#define RL_STATE_UNDOING	0x010000	/* doing an undo */
#define RL_STATE_INPUTPENDING	0x020000	/* rl_execute_next called */
#define RL_STATE_TTYCSAVED	0x040000	/* tty special chars saved */
#define RL_STATE_CALLBACK	0x080000	/* using the callback interface */
#define RL_STATE_VIMOTION	0x100000	/* reading vi motion arg */
#define RL_STATE_MULTIKEY	0x200000	/* reading multiple-key command */
#define RL_STATE_VICMDONCE	0x400000	/* entered vi command mode at least once */
d753 1
a753 1
#define RL_STATE_DONE		0x800000	/* done; accepted line */
a787 6
  /* search state */

  /* completion state */

  /* options state */

@


