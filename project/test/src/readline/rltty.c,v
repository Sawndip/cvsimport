head	1.11;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.11
	gdb_7_6-2013-04-26-release:1.11
	gdb_7_6-branch:1.11.0.6
	gdb_7_6-2013-03-12-branchpoint:1.11
	gdb_7_5_1-2012-11-29-release:1.11
	gdb_7_5-2012-08-17-release:1.11
	gdb_7_5-branch:1.11.0.4
	gdb_7_5-2012-07-18-branchpoint:1.11
	gdb_7_4_1-2012-04-26-release:1.11
	gdb_7_4-2012-01-24-release:1.11
	gdb_7_4-branch:1.11.0.2
	gdb_7_4-2011-12-13-branchpoint:1.11
	gdb_7_3_1-2011-09-04-release:1.10
	gdb_7_3-2011-07-26-release:1.10
	gdb_7_3-branch:1.10.0.20
	gdb_7_3-2011-04-01-branchpoint:1.10
	gdb_7_2-2010-09-02-release:1.10
	gdb_7_2-branch:1.10.0.18
	gdb_7_2-2010-07-07-branchpoint:1.10
	gdb_7_1-2010-03-18-release:1.10
	gdb_7_1-branch:1.10.0.16
	gdb_7_1-2010-02-18-branchpoint:1.10
	gdb_7_0_1-2009-12-22-release:1.10
	gdb_7_0-2009-10-06-release:1.10
	gdb_7_0-branch:1.10.0.14
	gdb_7_0-2009-09-16-branchpoint:1.10
	arc-sim-20090309:1.9
	msnyder-checkpoint-072509-branch:1.10.0.12
	msnyder-checkpoint-072509-branchpoint:1.10
	arc-insight_6_8-branch:1.9.0.16
	arc-insight_6_8-branchpoint:1.9
	insight_6_8-branch:1.9.0.14
	insight_6_8-branchpoint:1.9
	reverse-20081226-branch:1.10.0.10
	reverse-20081226-branchpoint:1.10
	multiprocess-20081120-branch:1.10.0.8
	multiprocess-20081120-branchpoint:1.10
	reverse-20080930-branch:1.10.0.6
	reverse-20080930-branchpoint:1.10
	reverse-20080717-branch:1.10.0.4
	reverse-20080717-branchpoint:1.10
	msnyder-reverse-20080609-branch:1.10.0.2
	msnyder-reverse-20080609-branchpoint:1.10
	drow-reverse-20070409-branch:1.9.0.12
	drow-reverse-20070409-branchpoint:1.9
	gdb_6_8-2008-03-27-release:1.9
	gdb_6_8-branch:1.9.0.10
	gdb_6_8-2008-02-26-branchpoint:1.9
	gdb_6_7_1-2007-10-29-release:1.9
	gdb_6_7-2007-10-10-release:1.9
	gdb_6_7-branch:1.9.0.8
	gdb_6_7-2007-09-07-branchpoint:1.9
	insight_6_6-20070208-release:1.9
	gdb_6_6-2006-12-18-release:1.9
	gdb_6_6-branch:1.9.0.6
	gdb_6_6-2006-11-15-branchpoint:1.9
	insight_6_5-20061003-release:1.9
	gdb-csl-symbian-6_4_50_20060226-12:1.7
	gdb-csl-sourcerygxx-3_4_4-25:1.7
	nickrob-async-20060828-mergepoint:1.9
	gdb-csl-symbian-6_4_50_20060226-11:1.7
	gdb-csl-sourcerygxx-4_1-17:1.7
	gdb-csl-20060226-branch-local-2:1.7
	gdb-csl-sourcerygxx-4_1-14:1.7
	gdb-csl-sourcerygxx-4_1-13:1.7
	gdb-csl-sourcerygxx-4_1-12:1.7
	gdb-csl-sourcerygxx-3_4_4-21:1.7
	gdb_6_5-20060621-release:1.9
	gdb-csl-sourcerygxx-4_1-9:1.7
	gdb-csl-sourcerygxx-4_1-8:1.7
	gdb-csl-sourcerygxx-4_1-7:1.7
	gdb-csl-arm-2006q1-6:1.7
	gdb-csl-sourcerygxx-4_1-6:1.7
	gdb-csl-symbian-6_4_50_20060226-10:1.7
	gdb-csl-symbian-6_4_50_20060226-9:1.7
	gdb-csl-symbian-6_4_50_20060226-8:1.7
	gdb-csl-coldfire-4_1-11:1.7
	gdb-csl-sourcerygxx-3_4_4-19:1.7
	gdb-csl-coldfire-4_1-10:1.7
	gdb_6_5-branch:1.9.0.4
	gdb_6_5-2006-05-14-branchpoint:1.9
	gdb-csl-sourcerygxx-4_1-5:1.7
	nickrob-async-20060513-branch:1.9.0.2
	nickrob-async-20060513-branchpoint:1.9
	gdb-csl-sourcerygxx-4_1-4:1.7
	msnyder-reverse-20060502-branch:1.8.0.4
	msnyder-reverse-20060502-branchpoint:1.8
	gdb-csl-morpho-4_1-4:1.7
	gdb-csl-sourcerygxx-3_4_4-17:1.7
	readline_5_1-import-branch:1.8.0.2
	readline_5_1-import-branchpoint:1.8
	readline-pre-51-import:1.8
	readline_5_1:1.1.1.7
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.7
	gdb-csl-symbian-20060226-branch:1.7.0.16
	gdb-csl-symbian-20060226-branchpoint:1.7
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.7
	msnyder-reverse-20060331-branch:1.7.0.14
	msnyder-reverse-20060331-branchpoint:1.7
	gdb-csl-available-20060303-branch:1.7.0.12
	gdb-csl-available-20060303-branchpoint:1.7
	gdb-csl-20060226-branch:1.7.0.10
	gdb-csl-20060226-branchpoint:1.7
	gdb_6_4-20051202-release:1.7
	msnyder-fork-checkpoint-branch:1.7.0.8
	msnyder-fork-checkpoint-branchpoint:1.7
	gdb-csl-gxxpro-6_3-branch:1.7.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.7
	gdb_6_4-branch:1.7.0.4
	gdb_6_4-2005-11-01-branchpoint:1.7
	gdb-csl-arm-20051020-branch:1.7.0.2
	gdb-csl-arm-20051020-branchpoint:1.7
	msnyder-tracepoint-checkpoint-branch:1.6.0.62
	msnyder-tracepoint-checkpoint-branchpoint:1.6
	gdb-csl-arm-20050325-2005-q1b:1.6
	gdb-csl-arm-20050325-2005-q1a:1.6
	csl-arm-20050325-branch:1.6.0.60
	csl-arm-20050325-branchpoint:1.6
	gdb_6_3-20041109-release:1.6
	gdb_6_3-branch:1.6.0.56
	gdb_6_3-20041019-branchpoint:1.6
	drow_intercu-merge-20040921:1.6
	drow_intercu-merge-20040915:1.6
	jimb-gdb_6_2-e500-branch:1.6.0.58
	jimb-gdb_6_2-e500-branchpoint:1.6
	gdb_6_2-20040730-release:1.6
	gdb_6_2-branch:1.6.0.54
	gdb_6_2-2004-07-10-gmt-branchpoint:1.6
	gdb_6_1_1-20040616-release:1.6
	gdb_6_1-2004-04-05-release:1.6
	drow_intercu-merge-20040402:1.6
	drow_intercu-merge-20040327:1.6
	ezannoni_pie-20040323-branch:1.6.0.52
	ezannoni_pie-20040323-branchpoint:1.6
	cagney_tramp-20040321-mergepoint:1.6
	cagney_tramp-20040309-branch:1.6.0.50
	cagney_tramp-20040309-branchpoint:1.6
	gdb_6_1-branch:1.6.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	drow_intercu-20040221-branch:1.6.0.46
	drow_intercu-20040221-branchpoint:1.6
	cagney_bfdfile-20040213-branch:1.6.0.44
	cagney_bfdfile-20040213-branchpoint:1.6
	drow-cplus-merge-20040208:1.6
	carlton_dictionary-20040126-merge:1.6
	cagney_bigcore-20040122-branch:1.6.0.42
	cagney_bigcore-20040122-branchpoint:1.6
	drow-cplus-merge-20040113:1.6
	drow-cplus-merge-20031224:1.6
	drow-cplus-merge-20031220:1.6
	carlton_dictionary-20031215-merge:1.6
	drow-cplus-merge-20031214:1.6
	carlton-dictionary-20031111-merge:1.6
	gdb_6_0-2003-10-04-release:1.6
	kettenis_sparc-20030918-branch:1.6.0.40
	kettenis_sparc-20030918-branchpoint:1.6
	carlton_dictionary-20030917-merge:1.6
	ezannoni_pie-20030916-branchpoint:1.6
	ezannoni_pie-20030916-branch:1.6.0.38
	cagney_x86i386-20030821-branch:1.6.0.36
	cagney_x86i386-20030821-branchpoint:1.6
	carlton_dictionary-20030805-merge:1.6
	carlton_dictionary-20030627-merge:1.6
	gdb_6_0-branch:1.6.0.34
	gdb_6_0-2003-06-23-branchpoint:1.6
	jimb-ppc64-linux-20030613-branch:1.6.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.6
	cagney_convert-20030606-branch:1.6.0.30
	cagney_convert-20030606-branchpoint:1.6
	cagney_writestrings-20030508-branch:1.6.0.28
	cagney_writestrings-20030508-branchpoint:1.6
	jimb-ppc64-linux-20030528-branch:1.6.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.6
	carlton_dictionary-20030523-merge:1.6
	cagney_fileio-20030521-branch:1.6.0.24
	cagney_fileio-20030521-branchpoint:1.6
	kettenis_i386newframe-20030517-mergepoint:1.6
	jimb-ppc64-linux-20030509-branch:1.6.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.6
	kettenis_i386newframe-20030504-mergepoint:1.6
	carlton_dictionary-20030430-merge:1.6
	kettenis_i386newframe-20030419-branch:1.6.0.20
	kettenis_i386newframe-20030419-branchpoint:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.6
	kettenis_i386newframe-20030406-branch:1.6.0.18
	kettenis_i386newframe-20030406-branchpoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.16
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.14
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.12
	cagney_lazyid-20030317-branchpoint:1.6
	kettenis-i386newframe-20030316-mergepoint:1.6
	offbyone-20030313-branch:1.6.0.10
	offbyone-20030313-branchpoint:1.6
	kettenis-i386newframe-20030308-branch:1.6.0.8
	kettenis-i386newframe-20030308-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.6
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.6
	interps-20030202-branch:1.6.0.4
	interps-20030202-branchpoint:1.6
	cagney-unwind-20030108-branch:1.6.0.2
	cagney-unwind-20030108-branchpoint:1.6
	carlton_dictionary-20021223-merge:1.6
	gdb_5_3-2002-12-12-release:1.5
	readline-pre-43-import:1.5
	carlton_dictionary-20021115-merge:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.24
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.22
	carlton_dictionary-20020920-branchpoint:1.5
	gdb_5_3-branch:1.5.0.20
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.5
	cagney_sysregs-20020825-branch:1.5.0.18
	cagney_sysregs-20020825-branchpoint:1.5
	readline_4_3-import-branch:1.5.0.16
	readline_4_3-import-branchpoint:1.5
	readline_4_3:1.1.1.6
	gdb_5_2_1-2002-07-23-release:1.5
	kseitz_interps-20020528-branch:1.5.0.14
	kseitz_interps-20020528-branchpoint:1.5
	cagney_regbuf-20020515-branch:1.5.0.12
	cagney_regbuf-20020515-branchpoint:1.5
	jimb-macro-020506-branch:1.5.0.10
	jimb-macro-020506-branchpoint:1.5
	gdb_5_2-2002-04-29-release:1.5
	gdb_5_2-branch:1.5.0.8
	gdb_5_2-2002-03-03-branchpoint:1.5
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	cygnus_cvs_20020108_pre:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.4
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.2
	gdb_5_1-2001-07-29-branchpoint:1.5
	insight-precleanup-2001-01-01:1.4
	readline_4_1:1.1.1.5
	readline_4_0:1.1.1.4
	FSF:1.1.1
	readline-pre-41-import:1.3
	gdb-premipsmulti-2000-06-06-branch:1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.11
date	2011.05.11.23.38.39;	author jkratoch;	state Exp;
branches;
next	1.10;

1.10
date	2008.03.24.12.59.51;	author jkratoch;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.05.18.26.12;	author drow;	state Exp;
branches;
next	1.8;

1.8
date	2006.04.20.20.13.20;	author ezannoni;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2005.07.25.15.09.31;	author mmitchel;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.08.22.31.37;	author ezannoni;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.08.14.57.30;	author cgf;	state Exp;
branches
	1.5.16.1
	1.5.22.1
	1.5.24.1;
next	1.4;

1.4
date	2000.07.09.17.19.56;	author ezannoni;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.07.17.15.45;	author ezannoni;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.15.11.57.42;	author eliz;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.53;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.8.2.1
date	2006.04.24.22.00.25;	author drow;	state Exp;
branches;
next	;

1.5.16.1
date	2002.08.25.23.41.17;	author ezannoni;	state Exp;
branches;
next	;

1.5.22.1
date	2002.12.23.19.39.44;	author carlton;	state Exp;
branches;
next	;

1.5.24.1
date	2003.12.14.20.28.14;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.53;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.08.02.23.47.58;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.08.16.19.57.16;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.07.07.19.14.17;	author ezannoni;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.07.09.16.21.20;	author ezannoni;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.08.23.22.02.28;	author ezannoni;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.04.20.20.05.37;	author ezannoni;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Imported readline 6.2, and upstream patch 001.

[patch 0/3] readline-6.2 rebase
http://sourceware.org/ml/gdb-patches/2011-05/msg00003.html
[patch 1/3] readline-6.2: Merge of already posted patches
http://sourceware.org/ml/gdb-patches/2011-05/msg00004.html
	=
	[Bug-readline] [RFC/readline] bind.c, rl_function_dumper, Free allocated
	http://lists.gnu.org/archive/html/bug-readline/2011-03/msg00000.html
	[Bug-readline] [patch] Fix underquotation in readline/examples/rlfe/conf
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00001.html
	[Bug-readline] [patch] Makefile.in htm<->html
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00002.html
	Re: [Bug-readline] [patch] Makefile.in dependency: callback.o: xmalloc.h
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00004.html
	[Bug-readline] [patch] Remove . from the VPATH directive
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00005.html
	Eli Zaretskii's __MSDOS__ / __GO32__ / __MINGW32__ / __DJGPP__ stuff:
	http://sourceware.org/ml/gdb/2011-04/msg00002.html
	Jan Kratochvil's patch for FSF GDB tree local-specific changes:
	http://sourceware.org/ml/gdb/2011-04/msg00006.html
	Preservation of existing ChangeLog.gdb files, their updates.
[patch 2/3] readline-6.2: Workaround "ask" regression
http://sourceware.org/ml/gdb-patches/2011-05/msg00005.html
[patch 3/3] readline-6.2: Revert 5.x compat., apply 6.x compat.
http://sourceware.org/ml/gdb-patches/2011-05/msg00006.html
[patch 4/3] readline-6.2: Substitute inc-hist.texinfo
http://sourceware.org/ml/gdb-patches/2011-05/msg00010.html

readline/
	Workaround gdb.base/completion.exp regression on readline-6.2.
	* complete.c (get_y_or_n): Disable the return on RL_STATE_CALLBACK.

	Imported readline 6.2, and upstream patch 001.
	* configure: Regenerate.

readline/doc/
	* hsuser.texi (Using History Interactively): Disable !BashFeatures
	@@defcodeindex.  Make the `Programming with GNU History' reference
	external.
	* inc-hist.texinfo: Remove.

	Imported readline 6.2, and upstream patch 001.

readline/examples/
	Imported readline 6.2, and upstream patch 001.

readline/examples/rlfe/
	Imported readline 6.2, and upstream patch 001.

gdb/
	* config.in: Regenerate.
	* configure: Regenerate.
	* configure.ac <--with-system-readline> (for readline_echoing_p):
	Remove the test.
	* tui/tui-io.c (tui_old_readline_echoing_p): Rename to ...
	(tui_old_rl_echoing_p): ... here.
	(tui_setup_io): Rename extern declaration readline_echoing_p to
	_rl_echoing_p.  Adjust assignments for the both renames.

gdb/doc/
	* Makefile.in (GDB_DOC_SOURCE_INCLUDES): Rename inc-hist.texinfo to
	hsuser.texi.
	* gdb.texinfo <!SYSTEM_READLINE>: Rename inc-hist.texinfo inclusion and
	comment to hsuser.texi.  Change rluser.texi name in the comment.
@
text
@/* rltty.c -- functions to prepare and restore the terminal for readline's
   use. */

/* Copyright (C) 1992-2005 Free Software Foundation, Inc.

   This file is part of the GNU Readline Library (Readline), a library
   for reading lines of text with interactive input and history editing.      

   Readline is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Readline is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Readline.  If not, see <http://www.gnu.org/licenses/>.
*/

#define READLINE_LIBRARY

#if defined (HAVE_CONFIG_H)
#  include <config.h>
#endif

#include <sys/types.h>
#include <signal.h>
#include <errno.h>
#include <stdio.h>

#if defined (HAVE_UNISTD_H)
#  include <unistd.h>
#endif /* HAVE_UNISTD_H */

#include "rldefs.h"

#if defined (GWINSZ_IN_SYS_IOCTL)
#  include <sys/ioctl.h>
#endif /* GWINSZ_IN_SYS_IOCTL */

#include "rltty.h"
#include "readline.h"
#include "rlprivate.h"

#if !defined (errno)
extern int errno;
#endif /* !errno */

rl_vintfunc_t *rl_prep_term_function = rl_prep_terminal;
rl_voidfunc_t *rl_deprep_term_function = rl_deprep_terminal;

static void set_winsize PARAMS((int));

/* **************************************************************** */
/*								    */
/*		      Saving and Restoring the TTY	    	    */
/*								    */
/* **************************************************************** */

/* Non-zero means that the terminal is in a prepped state. */
static int terminal_prepped;

static _RL_TTY_CHARS _rl_tty_chars, _rl_last_tty_chars;

/* If non-zero, means that this process has called tcflow(fd, TCOOFF)
   and output is suspended. */
#if defined (__ksr1__)
static int ksrflow;
#endif

/* Dummy call to force a backgrounded readline to stop before it tries
   to get the tty settings. */
static void
set_winsize (tty)
     int tty;
{
#if defined (TIOCGWINSZ)
  struct winsize w;

  if (ioctl (tty, TIOCGWINSZ, &w) == 0)
      (void) ioctl (tty, TIOCSWINSZ, &w);
#endif /* TIOCGWINSZ */
}

#if defined (NO_TTY_DRIVER)
/* Nothing */
#elif defined (NEW_TTY_DRIVER)

/* Values for the `flags' field of a struct bsdtty.  This tells which
   elements of the struct bsdtty have been fetched from the system and
   are valid. */
#define SGTTY_SET	0x01
#define LFLAG_SET	0x02
#define TCHARS_SET	0x04
#define LTCHARS_SET	0x08

struct bsdtty {
  struct sgttyb sgttyb;	/* Basic BSD tty driver information. */
  int lflag;		/* Local mode flags, like LPASS8. */
#if defined (TIOCGETC)
  struct tchars tchars;	/* Terminal special characters, including ^S and ^Q. */
#endif
#if defined (TIOCGLTC)
  struct ltchars ltchars; /* 4.2 BSD editing characters */
#endif
  int flags;		/* Bitmap saying which parts of the struct are valid. */
};

#define TIOTYPE struct bsdtty

static TIOTYPE otio;

static void save_tty_chars PARAMS((TIOTYPE *));
static int _get_tty_settings PARAMS((int, TIOTYPE *));
static int get_tty_settings PARAMS((int, TIOTYPE *));
static int _set_tty_settings PARAMS((int, TIOTYPE *));
static int set_tty_settings PARAMS((int, TIOTYPE *));

static void prepare_terminal_settings PARAMS((int, TIOTYPE, TIOTYPE *));

static void set_special_char PARAMS((Keymap, TIOTYPE *, int, rl_command_func_t));

static void
save_tty_chars (tiop)
     TIOTYPE *tiop;
{
  _rl_last_tty_chars = _rl_tty_chars;

  if (tiop->flags & SGTTY_SET)
    {
      _rl_tty_chars.t_erase = tiop->sgttyb.sg_erase;
      _rl_tty_chars.t_kill = tiop->sgttyb.sg_kill;
    }

  if (tiop->flags & TCHARS_SET)
    {
      _rl_intr_char = _rl_tty_chars.t_intr = tiop->tchars.t_intrc;
      _rl_quit_char = _rl_tty_chars.t_quit = tiop->tchars.t_quitc;

      _rl_tty_chars.t_start = tiop->tchars.t_startc;
      _rl_tty_chars.t_stop = tiop->tchars.t_stopc;
      _rl_tty_chars.t_eof = tiop->tchars.t_eofc;
      _rl_tty_chars.t_eol = '\n';
      _rl_tty_chars.t_eol2 = tiop->tchars.t_brkc;
    }

  if (tiop->flags & LTCHARS_SET)
    {
      _rl_susp_char = _rl_tty_chars.t_susp = tiop->ltchars.t_suspc;

      _rl_tty_chars.t_dsusp = tiop->ltchars.t_dsuspc;
      _rl_tty_chars.t_reprint = tiop->ltchars.t_rprntc;
      _rl_tty_chars.t_flush = tiop->ltchars.t_flushc;
      _rl_tty_chars.t_werase = tiop->ltchars.t_werasc;
      _rl_tty_chars.t_lnext = tiop->ltchars.t_lnextc;
    }

  _rl_tty_chars.t_status = -1;
}

static int
get_tty_settings (tty, tiop)
     int tty;
     TIOTYPE *tiop;
{
  set_winsize (tty);

  tiop->flags = tiop->lflag = 0;

  errno = 0;
  if (ioctl (tty, TIOCGETP, &(tiop->sgttyb)) < 0)
    return -1;
  tiop->flags |= SGTTY_SET;

#if defined (TIOCLGET)
  if (ioctl (tty, TIOCLGET, &(tiop->lflag)) == 0)
    tiop->flags |= LFLAG_SET;
#endif

#if defined (TIOCGETC)
  if (ioctl (tty, TIOCGETC, &(tiop->tchars)) == 0)
    tiop->flags |= TCHARS_SET;
#endif

#if defined (TIOCGLTC)
  if (ioctl (tty, TIOCGLTC, &(tiop->ltchars)) == 0)
    tiop->flags |= LTCHARS_SET;
#endif

  return 0;
}

static int
set_tty_settings (tty, tiop)
     int tty;
     TIOTYPE *tiop;
{
  if (tiop->flags & SGTTY_SET)
    {
      ioctl (tty, TIOCSETN, &(tiop->sgttyb));
      tiop->flags &= ~SGTTY_SET;
    }
  _rl_echoing_p = 1;

#if defined (TIOCLSET)
  if (tiop->flags & LFLAG_SET)
    {
      ioctl (tty, TIOCLSET, &(tiop->lflag));
      tiop->flags &= ~LFLAG_SET;
    }
#endif

#if defined (TIOCSETC)
  if (tiop->flags & TCHARS_SET)
    {
      ioctl (tty, TIOCSETC, &(tiop->tchars));
      tiop->flags &= ~TCHARS_SET;
    }
#endif

#if defined (TIOCSLTC)
  if (tiop->flags & LTCHARS_SET)
    {
      ioctl (tty, TIOCSLTC, &(tiop->ltchars));
      tiop->flags &= ~LTCHARS_SET;
    }
#endif

  return 0;
}

static void
prepare_terminal_settings (meta_flag, oldtio, tiop)
     int meta_flag;
     TIOTYPE oldtio, *tiop;
{
  _rl_echoing_p = (oldtio.sgttyb.sg_flags & ECHO);
  _rl_echoctl = (oldtio.sgttyb.sg_flags & ECHOCTL);

  /* Copy the original settings to the structure we're going to use for
     our settings. */
  tiop->sgttyb = oldtio.sgttyb;
  tiop->lflag = oldtio.lflag;
#if defined (TIOCGETC)
  tiop->tchars = oldtio.tchars;
#endif
#if defined (TIOCGLTC)
  tiop->ltchars = oldtio.ltchars;
#endif
  tiop->flags = oldtio.flags;

  /* First, the basic settings to put us into character-at-a-time, no-echo
     input mode. */
  tiop->sgttyb.sg_flags &= ~(ECHO | CRMOD);
  tiop->sgttyb.sg_flags |= CBREAK;

  /* If this terminal doesn't care how the 8th bit is used, then we can
     use it for the meta-key.  If only one of even or odd parity is
     specified, then the terminal is using parity, and we cannot. */
#if !defined (ANYP)
#  define ANYP (EVENP | ODDP)
#endif
  if (((oldtio.sgttyb.sg_flags & ANYP) == ANYP) ||
      ((oldtio.sgttyb.sg_flags & ANYP) == 0))
    {
      tiop->sgttyb.sg_flags |= ANYP;

      /* Hack on local mode flags if we can. */
#if defined (TIOCLGET)
#  if defined (LPASS8)
      tiop->lflag |= LPASS8;
#  endif /* LPASS8 */
#endif /* TIOCLGET */
    }

#if defined (TIOCGETC)
#  if defined (USE_XON_XOFF)
  /* Get rid of terminal output start and stop characters. */
  tiop->tchars.t_stopc = -1; /* C-s */
  tiop->tchars.t_startc = -1; /* C-q */

  /* If there is an XON character, bind it to restart the output. */
  if (oldtio.tchars.t_startc != -1)
    rl_bind_key (oldtio.tchars.t_startc, rl_restart_output);
#  endif /* USE_XON_XOFF */

  /* If there is an EOF char, bind _rl_eof_char to it. */
  if (oldtio.tchars.t_eofc != -1)
    _rl_eof_char = oldtio.tchars.t_eofc;

#  if defined (NO_KILL_INTR)
  /* Get rid of terminal-generated SIGQUIT and SIGINT. */
  tiop->tchars.t_quitc = -1; /* C-\ */
  tiop->tchars.t_intrc = -1; /* C-c */
#  endif /* NO_KILL_INTR */
#endif /* TIOCGETC */

#if defined (TIOCGLTC)
  /* Make the interrupt keys go away.  Just enough to make people happy. */
  tiop->ltchars.t_dsuspc = -1;	/* C-y */
  tiop->ltchars.t_lnextc = -1;	/* C-v */
#endif /* TIOCGLTC */
}

#else  /* !defined (NEW_TTY_DRIVER) */

#if !defined (VMIN)
#  define VMIN VEOF
#endif

#if !defined (VTIME)
#  define VTIME VEOL
#endif

#if defined (TERMIOS_TTY_DRIVER)
#  define TIOTYPE struct termios
#  define DRAIN_OUTPUT(fd)	tcdrain (fd)
#  define GETATTR(tty, tiop)	(tcgetattr (tty, tiop))
#  ifdef M_UNIX
#    define SETATTR(tty, tiop)	(tcsetattr (tty, TCSANOW, tiop))
#  else
#    define SETATTR(tty, tiop)	(tcsetattr (tty, TCSADRAIN, tiop))
#  endif /* !M_UNIX */
#else
#  define TIOTYPE struct termio
#  define DRAIN_OUTPUT(fd)
#  define GETATTR(tty, tiop)	(ioctl (tty, TCGETA, tiop))
#  define SETATTR(tty, tiop)	(ioctl (tty, TCSETAW, tiop))
#endif /* !TERMIOS_TTY_DRIVER */

static TIOTYPE otio;

static void save_tty_chars PARAMS((TIOTYPE *));
static int _get_tty_settings PARAMS((int, TIOTYPE *));
static int get_tty_settings PARAMS((int, TIOTYPE *));
static int _set_tty_settings PARAMS((int, TIOTYPE *));
static int set_tty_settings PARAMS((int, TIOTYPE *));

static void prepare_terminal_settings PARAMS((int, TIOTYPE, TIOTYPE *));

static void set_special_char PARAMS((Keymap, TIOTYPE *, int, rl_command_func_t));
static void _rl_bind_tty_special_chars PARAMS((Keymap, TIOTYPE));

#if defined (FLUSHO)
#  define OUTPUT_BEING_FLUSHED(tp)  (tp->c_lflag & FLUSHO)
#else
#  define OUTPUT_BEING_FLUSHED(tp)  0
#endif

static void
save_tty_chars (tiop)
     TIOTYPE *tiop;
{
  _rl_last_tty_chars = _rl_tty_chars;

  _rl_tty_chars.t_eof = tiop->c_cc[VEOF];
  _rl_tty_chars.t_eol = tiop->c_cc[VEOL];
#ifdef VEOL2
  _rl_tty_chars.t_eol2 = tiop->c_cc[VEOL2];
#endif
  _rl_tty_chars.t_erase = tiop->c_cc[VERASE];
#ifdef VWERASE
  _rl_tty_chars.t_werase = tiop->c_cc[VWERASE];
#endif
  _rl_tty_chars.t_kill = tiop->c_cc[VKILL];
#ifdef VREPRINT
  _rl_tty_chars.t_reprint = tiop->c_cc[VREPRINT];
#endif
  _rl_intr_char = _rl_tty_chars.t_intr = tiop->c_cc[VINTR];
  _rl_quit_char = _rl_tty_chars.t_quit = tiop->c_cc[VQUIT];
#ifdef VSUSP
  _rl_susp_char = _rl_tty_chars.t_susp = tiop->c_cc[VSUSP];
#endif
#ifdef VDSUSP
  _rl_tty_chars.t_dsusp = tiop->c_cc[VDSUSP];
#endif
#ifdef VSTART
  _rl_tty_chars.t_start = tiop->c_cc[VSTART];
#endif
#ifdef VSTOP
  _rl_tty_chars.t_stop = tiop->c_cc[VSTOP];
#endif
#ifdef VLNEXT
  _rl_tty_chars.t_lnext = tiop->c_cc[VLNEXT];
#endif
#ifdef VDISCARD
  _rl_tty_chars.t_flush = tiop->c_cc[VDISCARD];
#endif
#ifdef VSTATUS
  _rl_tty_chars.t_status = tiop->c_cc[VSTATUS];
#endif
}

#if defined (_AIX) || defined (_AIX41)
/* Currently this is only used on AIX */
static void
rltty_warning (msg)
     char *msg;
{
  _rl_errmsg ("warning: %s", msg);
}
#endif

#if defined (_AIX)
void
setopost(tp)
TIOTYPE *tp;
{
  if ((tp->c_oflag & OPOST) == 0)
    {
      _rl_errmsg ("warning: turning on OPOST for terminal\r");
      tp->c_oflag |= OPOST|ONLCR;
    }
}
#endif

static int
_get_tty_settings (tty, tiop)
     int tty;
     TIOTYPE *tiop;
{
  int ioctl_ret;

  while (1)
    {
      ioctl_ret = GETATTR (tty, tiop);
      if (ioctl_ret < 0)
	{
	  if (errno != EINTR)
	    return -1;
	  else
	    continue;
	}
      if (OUTPUT_BEING_FLUSHED (tiop))
	{
#if defined (FLUSHO)
	  _rl_errmsg ("warning: turning off output flushing");
	  tiop->c_lflag &= ~FLUSHO;
	  break;
#else
	  continue;
#endif
	}
      break;
    }

  return 0;
}

static int
get_tty_settings (tty, tiop)
     int tty;
     TIOTYPE *tiop;
{
  set_winsize (tty);

  errno = 0;
  if (_get_tty_settings (tty, tiop) < 0)
    return -1;

#if defined (_AIX)
  setopost(tiop);
#endif

  return 0;
}

static int
_set_tty_settings (tty, tiop)
     int tty;
     TIOTYPE *tiop;
{
  while (SETATTR (tty, tiop) < 0)
    {
      if (errno != EINTR)
	return -1;
      errno = 0;
    }
  return 0;
}

static int
set_tty_settings (tty, tiop)
     int tty;
     TIOTYPE *tiop;
{
  if (_set_tty_settings (tty, tiop) < 0)
    return -1;
    
#if 0

#if defined (TERMIOS_TTY_DRIVER)
#  if defined (__ksr1__)
  if (ksrflow)
    {
      ksrflow = 0;
      tcflow (tty, TCOON);
    }
#  else /* !ksr1 */
  tcflow (tty, TCOON);		/* Simulate a ^Q. */
#  endif /* !ksr1 */
#else
  ioctl (tty, TCXONC, 1);	/* Simulate a ^Q. */
#endif /* !TERMIOS_TTY_DRIVER */

#endif /* 0 */

  return 0;
}

static void
prepare_terminal_settings (meta_flag, oldtio, tiop)
     int meta_flag;
     TIOTYPE oldtio, *tiop;
{
  _rl_echoing_p = (oldtio.c_lflag & ECHO);
#if defined (ECHOCTL)
  _rl_echoctl = (oldtio.c_lflag & ECHOCTL);
#endif

  tiop->c_lflag &= ~(ICANON | ECHO);

  if ((unsigned char) oldtio.c_cc[VEOF] != (unsigned char) _POSIX_VDISABLE)
    _rl_eof_char = oldtio.c_cc[VEOF];

#if defined (USE_XON_XOFF)
#if defined (IXANY)
  tiop->c_iflag &= ~(IXON | IXOFF | IXANY);
#else
  /* `strict' Posix systems do not define IXANY. */
  tiop->c_iflag &= ~(IXON | IXOFF);
#endif /* IXANY */
#endif /* USE_XON_XOFF */

  /* Only turn this off if we are using all 8 bits. */
  if (((tiop->c_cflag & CSIZE) == CS8) || meta_flag)
    tiop->c_iflag &= ~(ISTRIP | INPCK);

  /* Make sure we differentiate between CR and NL on input. */
  tiop->c_iflag &= ~(ICRNL | INLCR);

#if !defined (HANDLE_SIGNALS)
  tiop->c_lflag &= ~ISIG;
#else
  tiop->c_lflag |= ISIG;
#endif

  tiop->c_cc[VMIN] = 1;
  tiop->c_cc[VTIME] = 0;

#if defined (FLUSHO)
  if (OUTPUT_BEING_FLUSHED (tiop))
    {
      tiop->c_lflag &= ~FLUSHO;
      oldtio.c_lflag &= ~FLUSHO;
    }
#endif

  /* Turn off characters that we need on Posix systems with job control,
     just to be sure.  This includes ^Y and ^V.  This should not really
     be necessary.  */
#if defined (TERMIOS_TTY_DRIVER) && defined (_POSIX_VDISABLE)

#if defined (VLNEXT)
  tiop->c_cc[VLNEXT] = _POSIX_VDISABLE;
#endif

#if defined (VDSUSP)
  tiop->c_cc[VDSUSP] = _POSIX_VDISABLE;
#endif

#endif /* TERMIOS_TTY_DRIVER && _POSIX_VDISABLE */
}
#endif  /* !NEW_TTY_DRIVER */

/* Put the terminal in CBREAK mode so that we can detect key presses. */
#if defined (NO_TTY_DRIVER)
void
rl_prep_terminal (meta_flag)
     int meta_flag;
{
  _rl_echoing_p = 1;
}

void
rl_deprep_terminal ()
{
}

#else /* ! NO_TTY_DRIVER */
void
rl_prep_terminal (meta_flag)
     int meta_flag;
{
  int tty;
  TIOTYPE tio;

  if (terminal_prepped)
    return;

  /* Try to keep this function from being INTerrupted. */
  _rl_block_sigint ();

  tty = rl_instream ? fileno (rl_instream) : fileno (stdin);

  if (get_tty_settings (tty, &tio) < 0)
    {
#if defined (ENOTSUP)
      /* MacOS X and Linux, at least, lie about the value of errno if
	 tcgetattr fails. */
      if (errno == ENOTTY || errno == EINVAL || errno == ENOTSUP)
#else
      if (errno == ENOTTY || errno == EINVAL)
#endif
	_rl_echoing_p = 1;		/* XXX */

      _rl_release_sigint ();
      return;
    }

  otio = tio;

  if (_rl_bind_stty_chars)
    {
#if defined (VI_MODE)
      /* If editing in vi mode, make sure we restore the bindings in the
	 insertion keymap no matter what keymap we ended up in. */
      if (rl_editing_mode == vi_mode)
	rl_tty_unset_default_bindings (vi_insertion_keymap);
      else
#endif
	rl_tty_unset_default_bindings (_rl_keymap);
    }
  save_tty_chars (&otio);
  RL_SETSTATE(RL_STATE_TTYCSAVED);
  if (_rl_bind_stty_chars)
    {
#if defined (VI_MODE)
      /* If editing in vi mode, make sure we set the bindings in the
	 insertion keymap no matter what keymap we ended up in. */
      if (rl_editing_mode == vi_mode)
	_rl_bind_tty_special_chars (vi_insertion_keymap, tio);	
      else
#endif
	_rl_bind_tty_special_chars (_rl_keymap, tio);
    }

  prepare_terminal_settings (meta_flag, otio, &tio);

  if (set_tty_settings (tty, &tio) < 0)
    {
      _rl_release_sigint ();
      return;
    }

  if (_rl_enable_keypad)
    _rl_control_keypad (1);

  fflush (rl_outstream);
  terminal_prepped = 1;
  RL_SETSTATE(RL_STATE_TERMPREPPED);

  _rl_release_sigint ();
}

/* Restore the terminal's normal settings and modes. */
void
rl_deprep_terminal ()
{
  int tty;

  if (!terminal_prepped)
    return;

  /* Try to keep this function from being interrupted. */
  _rl_block_sigint ();

  tty = rl_instream ? fileno (rl_instream) : fileno (stdout);

  if (_rl_enable_keypad)
    _rl_control_keypad (0);

  fflush (rl_outstream);

  if (set_tty_settings (tty, &otio) < 0)
    {
      _rl_release_sigint ();
      return;
    }

  terminal_prepped = 0;
  RL_UNSETSTATE(RL_STATE_TERMPREPPED);

  _rl_release_sigint ();
}
#endif /* !NO_TTY_DRIVER */

/* **************************************************************** */
/*								    */
/*			Bogus Flow Control      		    */
/*								    */
/* **************************************************************** */

int
rl_restart_output (count, key)
     int count, key;
{
#if defined (__MINGW32__)
  return 0;
#else /* !__MING32__ */

  int fildes = fileno (rl_outstream);
#if defined (TIOCSTART)
#if defined (apollo)
  ioctl (&fildes, TIOCSTART, 0);
#else
  ioctl (fildes, TIOCSTART, 0);
#endif /* apollo */

#else /* !TIOCSTART */
#  if defined (TERMIOS_TTY_DRIVER)
#    if defined (__ksr1__)
  if (ksrflow)
    {
      ksrflow = 0;
      tcflow (fildes, TCOON);
    }
#    else /* !ksr1 */
  tcflow (fildes, TCOON);		/* Simulate a ^Q. */
#    endif /* !ksr1 */
#  else /* !TERMIOS_TTY_DRIVER */
#    if defined (TCXONC)
  ioctl (fildes, TCXONC, TCOON);
#    endif /* TCXONC */
#  endif /* !TERMIOS_TTY_DRIVER */
#endif /* !TIOCSTART */

  return 0;
#endif /* !__MINGW32__ */
}

int
rl_stop_output (count, key)
     int count, key;
{
#if defined (__MINGW32__)
  return 0;
#else

  int fildes = fileno (rl_instream);

#if defined (TIOCSTOP)
# if defined (apollo)
  ioctl (&fildes, TIOCSTOP, 0);
# else
  ioctl (fildes, TIOCSTOP, 0);
# endif /* apollo */
#else /* !TIOCSTOP */
# if defined (TERMIOS_TTY_DRIVER)
#  if defined (__ksr1__)
  ksrflow = 1;
#  endif /* ksr1 */
  tcflow (fildes, TCOOFF);
# else
#   if defined (TCXONC)
  ioctl (fildes, TCXONC, TCOON);
#   endif /* TCXONC */
# endif /* !TERMIOS_TTY_DRIVER */
#endif /* !TIOCSTOP */

  return 0;
#endif /* !__MINGW32__ */
}

/* **************************************************************** */
/*								    */
/*			Default Key Bindings			    */
/*								    */
/* **************************************************************** */

#if !defined (NO_TTY_DRIVER)
#define SET_SPECIAL(sc, func)	set_special_char(kmap, &ttybuff, sc, func)
#endif

#if defined (NO_TTY_DRIVER)

#define SET_SPECIAL(sc, func)
#define RESET_SPECIAL(c)

#elif defined (NEW_TTY_DRIVER)
static void
set_special_char (kmap, tiop, sc, func)
     Keymap kmap;
     TIOTYPE *tiop;
     int sc;
     rl_command_func_t *func;
{
  if (sc != -1 && kmap[(unsigned char)sc].type == ISFUNC)
    kmap[(unsigned char)sc].function = func;
}

#define RESET_SPECIAL(c) \
  if (c != -1 && kmap[(unsigned char)c].type == ISFUNC) \
    kmap[(unsigned char)c].function = rl_insert;

static void
_rl_bind_tty_special_chars (kmap, ttybuff)
     Keymap kmap;
     TIOTYPE ttybuff;
{
  if (ttybuff.flags & SGTTY_SET)
    {
      SET_SPECIAL (ttybuff.sgttyb.sg_erase, rl_rubout);
      SET_SPECIAL (ttybuff.sgttyb.sg_kill, rl_unix_line_discard);
    }

#  if defined (TIOCGLTC)
  if (ttybuff.flags & LTCHARS_SET)
    {
      SET_SPECIAL (ttybuff.ltchars.t_werasc, rl_unix_word_rubout);
      SET_SPECIAL (ttybuff.ltchars.t_lnextc, rl_quoted_insert);
    }
#  endif /* TIOCGLTC */
}

#else /* !NEW_TTY_DRIVER */
static void
set_special_char (kmap, tiop, sc, func)
     Keymap kmap;
     TIOTYPE *tiop;
     int sc;
     rl_command_func_t *func;
{
  unsigned char uc;

  uc = tiop->c_cc[sc];
  if (uc != (unsigned char)_POSIX_VDISABLE && kmap[uc].type == ISFUNC)
    kmap[uc].function = func;
}

/* used later */
#define RESET_SPECIAL(uc) \
  if (uc != (unsigned char)_POSIX_VDISABLE && kmap[uc].type == ISFUNC) \
    kmap[uc].function = rl_insert;

static void
_rl_bind_tty_special_chars (kmap, ttybuff)
     Keymap kmap;
     TIOTYPE ttybuff;
{
  SET_SPECIAL (VERASE, rl_rubout);
  SET_SPECIAL (VKILL, rl_unix_line_discard);

#  if defined (VLNEXT) && defined (TERMIOS_TTY_DRIVER)
  SET_SPECIAL (VLNEXT, rl_quoted_insert);
#  endif /* VLNEXT && TERMIOS_TTY_DRIVER */

#  if defined (VWERASE) && defined (TERMIOS_TTY_DRIVER)
  SET_SPECIAL (VWERASE, rl_unix_word_rubout);
#  endif /* VWERASE && TERMIOS_TTY_DRIVER */
}

#endif /* !NEW_TTY_DRIVER */

/* Set the system's default editing characters to their readline equivalents
   in KMAP.  Should be static, now that we have rl_tty_set_default_bindings. */
void
rltty_set_default_bindings (kmap)
     Keymap kmap;
{
#if !defined (NO_TTY_DRIVER)
  TIOTYPE ttybuff;
  int tty;

  tty = fileno (rl_instream);

  if (get_tty_settings (tty, &ttybuff) == 0)
    _rl_bind_tty_special_chars (kmap, ttybuff);
#endif
}

/* New public way to set the system default editing chars to their readline
   equivalents. */
void
rl_tty_set_default_bindings (kmap)
     Keymap kmap;
{
  rltty_set_default_bindings (kmap);
}

/* Rebind all of the tty special chars that readline worries about back
   to self-insert.  Call this before saving the current terminal special
   chars with save_tty_chars().  This only works on POSIX termios or termio
   systems. */
void
rl_tty_unset_default_bindings (kmap)
     Keymap kmap;
{
  /* Don't bother before we've saved the tty special chars at least once. */
  if (RL_ISSTATE(RL_STATE_TTYCSAVED) == 0)
    return;

  RESET_SPECIAL (_rl_tty_chars.t_erase);
  RESET_SPECIAL (_rl_tty_chars.t_kill);

#  if defined (VLNEXT) && defined (TERMIOS_TTY_DRIVER)
  RESET_SPECIAL (_rl_tty_chars.t_lnext);
#  endif /* VLNEXT && TERMIOS_TTY_DRIVER */

#  if defined (VWERASE) && defined (TERMIOS_TTY_DRIVER)
  RESET_SPECIAL (_rl_tty_chars.t_werase);
#  endif /* VWERASE && TERMIOS_TTY_DRIVER */
}

#if defined (HANDLE_SIGNALS)

#if defined (NEW_TTY_DRIVER) || defined (NO_TTY_DRIVER)
int
_rl_disable_tty_signals ()
{
  return 0;
}

int
_rl_restore_tty_signals ()
{
  return 0;
}
#else

static TIOTYPE sigstty, nosigstty;
static int tty_sigs_disabled = 0;

int
_rl_disable_tty_signals ()
{
  if (tty_sigs_disabled)
    return 0;

  if (_get_tty_settings (fileno (rl_instream), &sigstty) < 0)
    return -1;

  nosigstty = sigstty;

  nosigstty.c_lflag &= ~ISIG;
  nosigstty.c_iflag &= ~IXON;

  if (_set_tty_settings (fileno (rl_instream), &nosigstty) < 0)
    return (_set_tty_settings (fileno (rl_instream), &sigstty));

  tty_sigs_disabled = 1;
  return 0;
}

int
_rl_restore_tty_signals ()
{
  int r;

  if (tty_sigs_disabled == 0)
    return 0;

  r = _set_tty_settings (fileno (rl_instream), &sigstty);

  if (r == 0)
    tty_sigs_disabled = 0;

  return r;
}
#endif /* !NEW_TTY_DRIVER */

#endif /* HANDLE_SIGNALS */
@


1.10
log
@	PR gdb/544
	* rltty.c (block_sigint, release_sigint): Rename to...
	(_rl_block_sigint, _rl_release_sigint): ...these and make them global.
	* rltty.h (_rl_block_sigint, _rl_release_sigint): New prototypes.
	* display.c (rl_redisplay): Wrap the function by the calls to
	_RL_BLOCK_SIGINT and _RL_RELEASE_SIGINT.
@
text
@d6 2
a7 2
   This file is part of the GNU Readline Library, a library for
   reading lines of text with interactive input and history editing.
d9 3
a11 3
   The GNU Readline Library is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2, or
d14 3
a16 3
   The GNU Readline Library is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
d19 4
a22 4
   The GNU General Public License is often shipped with GNU software, and
   is generally kept in a file called COPYING or LICENSE.  If you do not
   have a copy of the license, write to the Free Software Foundation,
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
a54 3
void _rl_block_sigint PARAMS((void));
void _rl_release_sigint PARAMS((void));

a58 64
/*			   Signal Management			    */
/*								    */
/* **************************************************************** */

#if defined (HAVE_POSIX_SIGNALS)
static sigset_t sigint_set, sigint_oset;
#else /* !HAVE_POSIX_SIGNALS */
#  if defined (HAVE_BSD_SIGNALS)
static int sigint_oldmask;
#  endif /* HAVE_BSD_SIGNALS */
#endif /* !HAVE_POSIX_SIGNALS */

static int sigint_blocked;

/* Cause SIGINT to not be delivered until the corresponding call to
   _rl_release_sigint(). */
void
_rl_block_sigint ()
{
  if (sigint_blocked)
    return;

#if defined (HAVE_POSIX_SIGNALS)
  sigemptyset (&sigint_set);
  sigemptyset (&sigint_oset);
  sigaddset (&sigint_set, SIGINT);
  sigprocmask (SIG_BLOCK, &sigint_set, &sigint_oset);
#else /* !HAVE_POSIX_SIGNALS */
#  if defined (HAVE_BSD_SIGNALS)
  sigint_oldmask = sigblock (sigmask (SIGINT));
#  else /* !HAVE_BSD_SIGNALS */
#    if defined (HAVE_USG_SIGHOLD)
  sighold (SIGINT);
#    endif /* HAVE_USG_SIGHOLD */
#  endif /* !HAVE_BSD_SIGNALS */
#endif /* !HAVE_POSIX_SIGNALS */

  sigint_blocked = 1;
}

/* Allow SIGINT to be delivered. */
void
_rl_release_sigint ()
{
  if (sigint_blocked == 0)
    return;

#if defined (HAVE_POSIX_SIGNALS)
  sigprocmask (SIG_SETMASK, &sigint_oset, (sigset_t *)NULL);
#else
#  if defined (HAVE_BSD_SIGNALS)
  sigsetmask (sigint_oldmask);
#  else /* !HAVE_BSD_SIGNALS */
#    if defined (HAVE_USG_SIGHOLD)
  sigrelse (SIGINT);
#    endif /* HAVE_USG_SIGHOLD */
#  endif /* !HAVE_BSD_SIGNALS */
#endif /* !HAVE_POSIX_SIGNALS */

  sigint_blocked = 0;
}

/* **************************************************************** */
/*								    */
d140 3
a142 2
      _rl_tty_chars.t_intr = tiop->tchars.t_intrc;
      _rl_tty_chars.t_quit = tiop->tchars.t_quitc;
d152 2
a153 1
      _rl_tty_chars.t_susp = tiop->ltchars.t_suspc;
d206 1
a206 1
  readline_echoing_p = 1;
d240 2
a241 1
  readline_echoing_p = (oldtio.sgttyb.sg_flags & ECHO);
d372 2
a373 2
  _rl_tty_chars.t_intr = tiop->c_cc[VINTR];
  _rl_tty_chars.t_quit = tiop->c_cc[VQUIT];
d375 1
a375 1
  _rl_tty_chars.t_susp = tiop->c_cc[VSUSP];
d403 1
a403 1
  fprintf (stderr, "readline: warning: %s\n", msg);
d414 1
a414 1
      rltty_warning ("turning on OPOST for terminal\r");
d439 2
a440 2
#if defined (FLUSHO) && defined (_AIX41)
	  rltty_warning ("turning off output flushing");
d519 4
a522 1
  readline_echoing_p = (oldtio.c_lflag & ECHO);
d585 1
a585 1
  readline_echoing_p = 1;
d607 1
a607 1
  tty = fileno (rl_instream);
d612 3
a614 2
      /* MacOS X, at least, lies about the value of errno if tcgetattr fails. */
      if (errno == ENOTTY || errno == ENOTSUP)
d616 1
a616 1
      if (errno == ENOTTY)
d618 2
a619 1
	readline_echoing_p = 1;		/* XXX */
d681 1
a681 1
  tty = fileno (rl_instream);
d806 1
a806 1
  if (c != -1 && kmap[(unsigned char)c].type == ISFUNC)
a876 1
  static int called = 0;
@


1.9
log
@Readline 5.1 import for HEAD.
@
text
@d55 2
a56 2
static void block_sigint PARAMS((void));
static void release_sigint PARAMS((void));
d77 3
a79 3
   release_sigint(). */
static void
block_sigint ()
d103 2
a104 2
static void
release_sigint ()
d666 1
a666 1
  block_sigint ();
d679 1
a679 1
      release_sigint ();
d714 1
a714 1
      release_sigint ();
d725 1
a725 1
  release_sigint ();
d738 1
a738 1
  block_sigint ();
d749 1
a749 1
      release_sigint ();
d756 1
a756 1
  release_sigint ();
@


1.8
log
@touched all sources to ease import of readline-5.1
@
text
@d4 1
a4 1
/* Copyright (C) 1992 Free Software Foundation, Inc.
d191 2
a233 1
#if defined (TIOCGWINSZ)
a234 1
#endif
d238 1
d408 3
a521 1
#if defined (TIOCGWINSZ)
a522 1
#endif
d524 1
d638 1
a638 1
#endif  /* NEW_TTY_DRIVER */
d640 1
a640 2
/* Put the terminal in CBREAK mode so that we can detect key
   presses. */
a654 1
/* Put the terminal in CBREAK mode so that we can detect key presses. */
d672 7
d685 11
d697 12
d843 12
a854 4
/* Set the system's default editing characters to their readline equivalents
   in KMAP.  Should be static, now that we have rl_tty_set_default_bindings. */
void
rltty_set_default_bindings (kmap)
d856 3
d860 3
a862 3
#if !defined (NO_TTY_DRIVER)
  TIOTYPE ttybuff;
  int tty = fileno (rl_instream);
d864 3
a866 1
#if defined (NEW_TTY_DRIVER)
d868 6
a873 11
#define SET_SPECIAL(sc, func) \
  do \
    { \
      int ic; \
      ic = sc; \
      if (ic != -1 && kmap[(unsigned char)ic].type == ISFUNC) \
	kmap[(unsigned char)ic].function = func; \
    } \
  while (0)

  if (get_tty_settings (tty, &ttybuff) == 0)
d875 3
a877 5
      if (ttybuff.flags & SGTTY_SET)
	{
	  SET_SPECIAL (ttybuff.sgttyb.sg_erase, rl_rubout);
	  SET_SPECIAL (ttybuff.sgttyb.sg_kill, rl_unix_line_discard);
	}
d880 5
a884 5
      if (ttybuff.flags & LTCHARS_SET)
	{
	  SET_SPECIAL (ttybuff.ltchars.t_werasc, rl_unix_word_rubout);
	  SET_SPECIAL (ttybuff.ltchars.t_lnextc, rl_quoted_insert);
	}
d886 1
a886 1
    }
d889 8
d898 9
a906 9
#define SET_SPECIAL(sc, func) \
  do \
    { \
      unsigned char uc; \
      uc = ttybuff.c_cc[sc]; \
      if (uc != (unsigned char)_POSIX_VDISABLE && kmap[uc].type == ISFUNC) \
	kmap[uc].function = func; \
    } \
  while (0)
d908 7
a914 4
  if (get_tty_settings (tty, &ttybuff) == 0)
    {
      SET_SPECIAL (VERASE, rl_rubout);
      SET_SPECIAL (VKILL, rl_unix_line_discard);
d917 1
a917 1
      SET_SPECIAL (VLNEXT, rl_quoted_insert);
d921 1
a921 1
      SET_SPECIAL (VWERASE, rl_unix_word_rubout);
d923 2
a924 1
    }
d926 16
d954 24
@


1.8.2.1
log
@Import readline 5.1 on the branch.
@
text
@d4 1
a4 1
/* Copyright (C) 1992-2005 Free Software Foundation, Inc.
a190 2
static void set_special_char PARAMS((Keymap, TIOTYPE *, int, rl_command_func_t));

d232 1
d234 1
a237 1
  errno = 0;
a406 3
static void set_special_char PARAMS((Keymap, TIOTYPE *, int, rl_command_func_t));
static void _rl_bind_tty_special_chars PARAMS((Keymap, TIOTYPE));

d518 1
d520 1
a521 1
  errno = 0;
d635 1
a635 1
#endif  /* !NEW_TTY_DRIVER */
d637 2
a638 1
/* Put the terminal in CBREAK mode so that we can detect key presses. */
d653 1
a670 7
#if defined (ENOTSUP)
      /* MacOS X, at least, lies about the value of errno if tcgetattr fails. */
      if (errno == ENOTTY || errno == ENOTSUP)
#else
      if (errno == ENOTTY)
#endif
	readline_echoing_p = 1;		/* XXX */
a676 11
  if (_rl_bind_stty_chars)
    {
#if defined (VI_MODE)
      /* If editing in vi mode, make sure we restore the bindings in the
	 insertion keymap no matter what keymap we ended up in. */
      if (rl_editing_mode == vi_mode)
	rl_tty_unset_default_bindings (vi_insertion_keymap);
      else
#endif
	rl_tty_unset_default_bindings (_rl_keymap);
    }
a677 12
  RL_SETSTATE(RL_STATE_TTYCSAVED);
  if (_rl_bind_stty_chars)
    {
#if defined (VI_MODE)
      /* If editing in vi mode, make sure we set the bindings in the
	 insertion keymap no matter what keymap we ended up in. */
      if (rl_editing_mode == vi_mode)
	_rl_bind_tty_special_chars (vi_insertion_keymap, tio);	
      else
#endif
	_rl_bind_tty_special_chars (_rl_keymap, tio);
    }
d812 6
d819 2
a820 2
#define SET_SPECIAL(sc, func)	set_special_char(kmap, &ttybuff, sc, func)
#endif
d822 1
a822 1
#if defined (NO_TTY_DRIVER)
d824 9
a832 2
#define SET_SPECIAL(sc, func)
#define RESET_SPECIAL(c)
d834 1
a834 22
#elif defined (NEW_TTY_DRIVER)
static void
set_special_char (kmap, tiop, sc, func)
     Keymap kmap;
     TIOTYPE *tiop;
     int sc;
     rl_command_func_t *func;
{
  if (sc != -1 && kmap[(unsigned char)sc].type == ISFUNC)
    kmap[(unsigned char)sc].function = func;
}

#define RESET_SPECIAL(c) \
  if (c != -1 && kmap[(unsigned char)c].type == ISFUNC)
    kmap[(unsigned char)c].function = rl_insert;

static void
_rl_bind_tty_special_chars (kmap, ttybuff)
     Keymap kmap;
     TIOTYPE ttybuff;
{
  if (ttybuff.flags & SGTTY_SET)
d836 5
a840 3
      SET_SPECIAL (ttybuff.sgttyb.sg_erase, rl_rubout);
      SET_SPECIAL (ttybuff.sgttyb.sg_kill, rl_unix_line_discard);
    }
d843 6
a848 4
  if (ttybuff.flags & LTCHARS_SET)
    {
      SET_SPECIAL (ttybuff.ltchars.t_werasc, rl_unix_word_rubout);
      SET_SPECIAL (ttybuff.ltchars.t_lnextc, rl_quoted_insert);
a849 2
#  endif /* TIOCGLTC */
}
a851 8
static void
set_special_char (kmap, tiop, sc, func)
     Keymap kmap;
     TIOTYPE *tiop;
     int sc;
     rl_command_func_t *func;
{
  unsigned char uc;
d853 9
a861 4
  uc = tiop->c_cc[sc];
  if (uc != (unsigned char)_POSIX_VDISABLE && kmap[uc].type == ISFUNC)
    kmap[uc].function = func;
}
d863 4
a866 12
/* used later */
#define RESET_SPECIAL(uc) \
  if (uc != (unsigned char)_POSIX_VDISABLE && kmap[uc].type == ISFUNC) \
    kmap[uc].function = rl_insert;

static void
_rl_bind_tty_special_chars (kmap, ttybuff)
     Keymap kmap;
     TIOTYPE ttybuff;
{
  SET_SPECIAL (VERASE, rl_rubout);
  SET_SPECIAL (VKILL, rl_unix_line_discard);
d869 1
a869 1
  SET_SPECIAL (VLNEXT, rl_quoted_insert);
d873 1
a873 1
  SET_SPECIAL (VWERASE, rl_unix_word_rubout);
d875 1
a875 2
}

a876 16

/* Set the system's default editing characters to their readline equivalents
   in KMAP.  Should be static, now that we have rl_tty_set_default_bindings. */
void
rltty_set_default_bindings (kmap)
     Keymap kmap;
{
#if !defined (NO_TTY_DRIVER)
  TIOTYPE ttybuff;
  int tty;
  static int called = 0;

  tty = fileno (rl_instream);

  if (get_tty_settings (tty, &ttybuff) == 0)
    _rl_bind_tty_special_chars (kmap, ttybuff);
a888 24
/* Rebind all of the tty special chars that readline worries about back
   to self-insert.  Call this before saving the current terminal special
   chars with save_tty_chars().  This only works on POSIX termios or termio
   systems. */
void
rl_tty_unset_default_bindings (kmap)
     Keymap kmap;
{
  /* Don't bother before we've saved the tty special chars at least once. */
  if (RL_ISSTATE(RL_STATE_TTYCSAVED) == 0)
    return;

  RESET_SPECIAL (_rl_tty_chars.t_erase);
  RESET_SPECIAL (_rl_tty_chars.t_kill);

#  if defined (VLNEXT) && defined (TERMIOS_TTY_DRIVER)
  RESET_SPECIAL (_rl_tty_chars.t_lnext);
#  endif /* VLNEXT && TERMIOS_TTY_DRIVER */

#  if defined (VWERASE) && defined (TERMIOS_TTY_DRIVER)
  RESET_SPECIAL (_rl_tty_chars.t_werase);
#  endif /* VWERASE && TERMIOS_TTY_DRIVER */
}

@


1.7
log
@	* input.c (rl_getc): Use getch to read console input on
	Windows.
	* readline.c (bind_arrow_keys_internal): Translate
	Windows keysequences into POSIX key sequences.
	* rldefs.h (NO_TTY_DRIVER): Define on MinGW.
	* rltty.c: Conditionalize on NO_TTY_DRIVER throughout.
@
text
@@


1.6
log
@Import of readline 4.3.
Non-readline modified files:

src/gdb/ChangeLog src/gdb/defs.h src/gdb/cli/cli-cmds.c
src/gdb/cli/cli-setshow.c src/gdb/tui/ChangeLog
src/gdb/tui/tuiWin.c

In readline directory:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@d155 3
a157 1
#if defined (NEW_TTY_DRIVER)
d637 16
d727 1
d739 4
d770 1
d777 4
d803 1
d818 1
d877 1
d891 1
a891 1
#if defined (NEW_TTY_DRIVER)
@


1.5
log
@* rltty.c (save_tty_chars): Fix compilation-stopping typo.
@
text
@d52 7
a58 2
VFunction *rl_prep_term_function = rl_prep_terminal;
VFunction *rl_deprep_term_function = rl_deprep_terminal;
d181 8
d236 2
a237 1
  ioctl (tty, TIOCGETP, &(tiop->sgttyb));
d241 2
a242 2
  ioctl (tty, TIOCLGET, &(tiop->lflag));
  tiop->flags |= LFLAG_SET;
d246 2
a247 2
  ioctl (tty, TIOCGETC, &(tiop->tchars));
  tiop->flags |= TCHARS_SET;
d251 2
a252 2
  ioctl (tty, TIOCGLTC, &(tiop->ltchars));
  tiop->flags |= LTCHARS_SET;
d298 1
a298 1
prepare_terminal_settings (meta_flag, otio, tiop)
d300 1
a300 1
     TIOTYPE otio, *tiop;
d302 1
a302 1
  readline_echoing_p = (otio.sgttyb.sg_flags & ECHO);
d306 2
a307 2
  tiop->sgttyb = otio.sgttyb;
  tiop->lflag = otio.lflag;
d309 1
a309 1
  tiop->tchars = otio.tchars;
d312 1
a312 1
  tiop->ltchars = otio.ltchars;
d314 1
a314 1
  tiop->flags = otio.flags;
d327 2
a328 2
  if (((otio.sgttyb.sg_flags & ANYP) == ANYP) ||
      ((otio.sgttyb.sg_flags & ANYP) == 0))
d347 2
a348 2
  if (otio.tchars.t_startc != -1)
    rl_bind_key (otio.tchars.t_startc, rl_restart_output);
d352 2
a353 2
  if (otio.tchars.t_eofc != -1)
    _rl_eof_char = otio.tchars.t_eofc;
d392 1
a392 1
#  define SETATTR(tty, tiop)	(ioctl (tty, TCSETA, tiop))
d397 8
d574 1
a574 1
prepare_terminal_settings (meta_flag, otio, tiop)
d576 1
a576 1
     TIOTYPE otio, *tiop;
d578 1
a578 1
  readline_echoing_p = (otio.c_lflag & ECHO);
d582 2
a583 2
  if ((unsigned char) otio.c_cc[VEOF] != (unsigned char) _POSIX_VDISABLE)
    _rl_eof_char = otio.c_cc[VEOF];
d614 1
a614 1
      otio.c_lflag &= ~FLUSHO;
d674 1
d705 1
d782 3
d799 2
a800 2
      if (ic != -1 && kmap[ic].type == ISFUNC) \
	kmap[ic].function = func; \
d849 9
d889 1
d901 2
d906 6
a911 1
  return (_set_tty_settings (fileno (rl_instream), &sigstty));
@


1.5.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d52 2
a53 7
rl_vintfunc_t *rl_prep_term_function = rl_prep_terminal;
rl_voidfunc_t *rl_deprep_term_function = rl_deprep_terminal;

static void block_sigint PARAMS((void));
static void release_sigint PARAMS((void));

static void set_winsize PARAMS((int));
a175 8
static void save_tty_chars PARAMS((TIOTYPE *));
static int _get_tty_settings PARAMS((int, TIOTYPE *));
static int get_tty_settings PARAMS((int, TIOTYPE *));
static int _set_tty_settings PARAMS((int, TIOTYPE *));
static int set_tty_settings PARAMS((int, TIOTYPE *));

static void prepare_terminal_settings PARAMS((int, TIOTYPE, TIOTYPE *));

d223 1
a223 2
  if (ioctl (tty, TIOCGETP, &(tiop->sgttyb)) < 0)
    return -1;
d227 2
a228 2
  if (ioctl (tty, TIOCLGET, &(tiop->lflag)) == 0)
    tiop->flags |= LFLAG_SET;
d232 2
a233 2
  if (ioctl (tty, TIOCGETC, &(tiop->tchars)) == 0)
    tiop->flags |= TCHARS_SET;
d237 2
a238 2
  if (ioctl (tty, TIOCGLTC, &(tiop->ltchars)) == 0)
    tiop->flags |= LTCHARS_SET;
d284 1
a284 1
prepare_terminal_settings (meta_flag, oldtio, tiop)
d286 1
a286 1
     TIOTYPE oldtio, *tiop;
d288 1
a288 1
  readline_echoing_p = (oldtio.sgttyb.sg_flags & ECHO);
d292 2
a293 2
  tiop->sgttyb = oldtio.sgttyb;
  tiop->lflag = oldtio.lflag;
d295 1
a295 1
  tiop->tchars = oldtio.tchars;
d298 1
a298 1
  tiop->ltchars = oldtio.ltchars;
d300 1
a300 1
  tiop->flags = oldtio.flags;
d313 2
a314 2
  if (((oldtio.sgttyb.sg_flags & ANYP) == ANYP) ||
      ((oldtio.sgttyb.sg_flags & ANYP) == 0))
d333 2
a334 2
  if (oldtio.tchars.t_startc != -1)
    rl_bind_key (oldtio.tchars.t_startc, rl_restart_output);
d338 2
a339 2
  if (oldtio.tchars.t_eofc != -1)
    _rl_eof_char = oldtio.tchars.t_eofc;
d378 1
a378 1
#  define SETATTR(tty, tiop)	(ioctl (tty, TCSETAW, tiop))
a382 8
static void save_tty_chars PARAMS((TIOTYPE *));
static int _get_tty_settings PARAMS((int, TIOTYPE *));
static int get_tty_settings PARAMS((int, TIOTYPE *));
static int _set_tty_settings PARAMS((int, TIOTYPE *));
static int set_tty_settings PARAMS((int, TIOTYPE *));

static void prepare_terminal_settings PARAMS((int, TIOTYPE, TIOTYPE *));

d552 1
a552 1
prepare_terminal_settings (meta_flag, oldtio, tiop)
d554 1
a554 1
     TIOTYPE oldtio, *tiop;
d556 1
a556 1
  readline_echoing_p = (oldtio.c_lflag & ECHO);
d560 2
a561 2
  if ((unsigned char) oldtio.c_cc[VEOF] != (unsigned char) _POSIX_VDISABLE)
    _rl_eof_char = oldtio.c_cc[VEOF];
d592 1
a592 1
      oldtio.c_lflag &= ~FLUSHO;
a651 1
  RL_SETSTATE(RL_STATE_TERMPREPPED);
a681 1
  RL_UNSETSTATE(RL_STATE_TERMPREPPED);
a757 3

/* Set the system's default editing characters to their readline equivalents
   in KMAP.  Should be static, now that we have rl_tty_set_default_bindings. */
d772 2
a773 2
      if (ic != -1 && kmap[(unsigned char)ic].type == ISFUNC) \
	kmap[(unsigned char)ic].function = func; \
a821 9
/* New public way to set the system default editing chars to their readline
   equivalents. */
void
rl_tty_set_default_bindings (kmap)
     Keymap kmap;
{
  rltty_set_default_bindings (kmap);
}

a852 1
  nosigstty.c_iflag &= ~IXON;
a863 2
  int r;

d867 1
a867 6
  r = _set_tty_settings (fileno (rl_instream), &sigstty);

  if (r == 0)
    tty_sigs_disabled = 0;

  return r;
@


1.5.22.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d52 2
a53 7
rl_vintfunc_t *rl_prep_term_function = rl_prep_terminal;
rl_voidfunc_t *rl_deprep_term_function = rl_deprep_terminal;

static void block_sigint PARAMS((void));
static void release_sigint PARAMS((void));

static void set_winsize PARAMS((int));
a175 8
static void save_tty_chars PARAMS((TIOTYPE *));
static int _get_tty_settings PARAMS((int, TIOTYPE *));
static int get_tty_settings PARAMS((int, TIOTYPE *));
static int _set_tty_settings PARAMS((int, TIOTYPE *));
static int set_tty_settings PARAMS((int, TIOTYPE *));

static void prepare_terminal_settings PARAMS((int, TIOTYPE, TIOTYPE *));

d223 1
a223 2
  if (ioctl (tty, TIOCGETP, &(tiop->sgttyb)) < 0)
    return -1;
d227 2
a228 2
  if (ioctl (tty, TIOCLGET, &(tiop->lflag)) == 0)
    tiop->flags |= LFLAG_SET;
d232 2
a233 2
  if (ioctl (tty, TIOCGETC, &(tiop->tchars)) == 0)
    tiop->flags |= TCHARS_SET;
d237 2
a238 2
  if (ioctl (tty, TIOCGLTC, &(tiop->ltchars)) == 0)
    tiop->flags |= LTCHARS_SET;
d284 1
a284 1
prepare_terminal_settings (meta_flag, oldtio, tiop)
d286 1
a286 1
     TIOTYPE oldtio, *tiop;
d288 1
a288 1
  readline_echoing_p = (oldtio.sgttyb.sg_flags & ECHO);
d292 2
a293 2
  tiop->sgttyb = oldtio.sgttyb;
  tiop->lflag = oldtio.lflag;
d295 1
a295 1
  tiop->tchars = oldtio.tchars;
d298 1
a298 1
  tiop->ltchars = oldtio.ltchars;
d300 1
a300 1
  tiop->flags = oldtio.flags;
d313 2
a314 2
  if (((oldtio.sgttyb.sg_flags & ANYP) == ANYP) ||
      ((oldtio.sgttyb.sg_flags & ANYP) == 0))
d333 2
a334 2
  if (oldtio.tchars.t_startc != -1)
    rl_bind_key (oldtio.tchars.t_startc, rl_restart_output);
d338 2
a339 2
  if (oldtio.tchars.t_eofc != -1)
    _rl_eof_char = oldtio.tchars.t_eofc;
d378 1
a378 1
#  define SETATTR(tty, tiop)	(ioctl (tty, TCSETAW, tiop))
a382 8
static void save_tty_chars PARAMS((TIOTYPE *));
static int _get_tty_settings PARAMS((int, TIOTYPE *));
static int get_tty_settings PARAMS((int, TIOTYPE *));
static int _set_tty_settings PARAMS((int, TIOTYPE *));
static int set_tty_settings PARAMS((int, TIOTYPE *));

static void prepare_terminal_settings PARAMS((int, TIOTYPE, TIOTYPE *));

d552 1
a552 1
prepare_terminal_settings (meta_flag, oldtio, tiop)
d554 1
a554 1
     TIOTYPE oldtio, *tiop;
d556 1
a556 1
  readline_echoing_p = (oldtio.c_lflag & ECHO);
d560 2
a561 2
  if ((unsigned char) oldtio.c_cc[VEOF] != (unsigned char) _POSIX_VDISABLE)
    _rl_eof_char = oldtio.c_cc[VEOF];
d592 1
a592 1
      oldtio.c_lflag &= ~FLUSHO;
a651 1
  RL_SETSTATE(RL_STATE_TERMPREPPED);
a681 1
  RL_UNSETSTATE(RL_STATE_TERMPREPPED);
a757 3

/* Set the system's default editing characters to their readline equivalents
   in KMAP.  Should be static, now that we have rl_tty_set_default_bindings. */
d772 2
a773 2
      if (ic != -1 && kmap[(unsigned char)ic].type == ISFUNC) \
	kmap[(unsigned char)ic].function = func; \
a821 9
/* New public way to set the system default editing chars to their readline
   equivalents. */
void
rl_tty_set_default_bindings (kmap)
     Keymap kmap;
{
  rltty_set_default_bindings (kmap);
}

a852 1
  nosigstty.c_iflag &= ~IXON;
a863 2
  int r;

d867 1
a867 6
  r = _set_tty_settings (fileno (rl_instream), &sigstty);

  if (r == 0)
    tty_sigs_disabled = 0;

  return r;
@


1.5.16.1
log
@2002-08-24  Elena Zannoni  <ezannoni@@redhat.com>

        Import of readline 4.3:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@d52 2
a53 7
rl_vintfunc_t *rl_prep_term_function = rl_prep_terminal;
rl_voidfunc_t *rl_deprep_term_function = rl_deprep_terminal;

static void block_sigint PARAMS((void));
static void release_sigint PARAMS((void));

static void set_winsize PARAMS((int));
a175 8
static void save_tty_chars PARAMS((TIOTYPE *));
static int _get_tty_settings PARAMS((int, TIOTYPE *));
static int get_tty_settings PARAMS((int, TIOTYPE *));
static int _set_tty_settings PARAMS((int, TIOTYPE *));
static int set_tty_settings PARAMS((int, TIOTYPE *));

static void prepare_terminal_settings PARAMS((int, TIOTYPE, TIOTYPE *));

d223 1
a223 2
  if (ioctl (tty, TIOCGETP, &(tiop->sgttyb)) < 0)
    return -1;
d227 2
a228 2
  if (ioctl (tty, TIOCLGET, &(tiop->lflag)) == 0)
    tiop->flags |= LFLAG_SET;
d232 2
a233 2
  if (ioctl (tty, TIOCGETC, &(tiop->tchars)) == 0)
    tiop->flags |= TCHARS_SET;
d237 2
a238 2
  if (ioctl (tty, TIOCGLTC, &(tiop->ltchars)) == 0)
    tiop->flags |= LTCHARS_SET;
d284 1
a284 1
prepare_terminal_settings (meta_flag, oldtio, tiop)
d286 1
a286 1
     TIOTYPE oldtio, *tiop;
d288 1
a288 1
  readline_echoing_p = (oldtio.sgttyb.sg_flags & ECHO);
d292 2
a293 2
  tiop->sgttyb = oldtio.sgttyb;
  tiop->lflag = oldtio.lflag;
d295 1
a295 1
  tiop->tchars = oldtio.tchars;
d298 1
a298 1
  tiop->ltchars = oldtio.ltchars;
d300 1
a300 1
  tiop->flags = oldtio.flags;
d313 2
a314 2
  if (((oldtio.sgttyb.sg_flags & ANYP) == ANYP) ||
      ((oldtio.sgttyb.sg_flags & ANYP) == 0))
d333 2
a334 2
  if (oldtio.tchars.t_startc != -1)
    rl_bind_key (oldtio.tchars.t_startc, rl_restart_output);
d338 2
a339 2
  if (oldtio.tchars.t_eofc != -1)
    _rl_eof_char = oldtio.tchars.t_eofc;
d378 1
a378 1
#  define SETATTR(tty, tiop)	(ioctl (tty, TCSETAW, tiop))
a382 8
static void save_tty_chars PARAMS((TIOTYPE *));
static int _get_tty_settings PARAMS((int, TIOTYPE *));
static int get_tty_settings PARAMS((int, TIOTYPE *));
static int _set_tty_settings PARAMS((int, TIOTYPE *));
static int set_tty_settings PARAMS((int, TIOTYPE *));

static void prepare_terminal_settings PARAMS((int, TIOTYPE, TIOTYPE *));

d552 1
a552 1
prepare_terminal_settings (meta_flag, oldtio, tiop)
d554 1
a554 1
     TIOTYPE oldtio, *tiop;
d556 1
a556 1
  readline_echoing_p = (oldtio.c_lflag & ECHO);
d560 2
a561 2
  if ((unsigned char) oldtio.c_cc[VEOF] != (unsigned char) _POSIX_VDISABLE)
    _rl_eof_char = oldtio.c_cc[VEOF];
d592 1
a592 1
      oldtio.c_lflag &= ~FLUSHO;
a651 1
  RL_SETSTATE(RL_STATE_TERMPREPPED);
a681 1
  RL_UNSETSTATE(RL_STATE_TERMPREPPED);
a757 3

/* Set the system's default editing characters to their readline equivalents
   in KMAP.  Should be static, now that we have rl_tty_set_default_bindings. */
d772 2
a773 2
      if (ic != -1 && kmap[(unsigned char)ic].type == ISFUNC) \
	kmap[(unsigned char)ic].function = func; \
a821 9
/* New public way to set the system default editing chars to their readline
   equivalents. */
void
rl_tty_set_default_bindings (kmap)
     Keymap kmap;
{
  rltty_set_default_bindings (kmap);
}

a852 1
  nosigstty.c_iflag &= ~IXON;
a863 2
  int r;

d867 1
a867 6
  r = _set_tty_settings (fileno (rl_instream), &sigstty);

  if (r == 0)
    tty_sigs_disabled = 0;

  return r;
@


1.4
log
@readline:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Locally modified files: Makefile.in, configure.in, configure
        (regenerated), config.h.in (regenerated), readline.h, rltty.c,
 	shell.c signals.c.

        Locally added files: acconfig.h, config/*, config.h.bot,
        cross-build/*, doc/inc-hit.texinfo.

        New files: USAGE, rlprivate.h, rlshell.h, xmalloc.h.
examples:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        New files: excallback.c, rlfe.c.
doc:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Regenerated inc-hist.texinfo as copy of hsuser.texinfo, for
        inclusion in the gdb manual.

        New file: rluserman.texinfo
@
text
@d193 1
a193 1
      _rl_tty_chars.t_stop = tiop->tchars.t_stopc
@


1.3
log
@Dummy commit before importof 4.1 version
@
text
@d11 1
a11 1
   as published by the Free Software Foundation; either version 1, or
d22 1
a22 1
   675 Mass Ave, Cambridge, MA 02139, USA. */
d46 1
a51 17
extern int readline_echoing_p;
extern int _rl_eof_char;

extern int _rl_enable_keypad, _rl_enable_meta;

extern void _rl_control_keypad ();

#if defined (__GO32__)
#  include <pc.h>
#  if !defined (__DJGPP__)
#    undef HANDLE_SIGNALS
#  endif /* !__DJGPP__ */
#endif /* __GO32__ */

/* Indirect functions to allow apps control over terminal management. */
extern void rl_prep_terminal (), rl_deprep_terminal ();

d93 1
d101 1
a101 1
  if (!sigint_blocked)
d128 2
a135 1
#if defined (TIOCGWINSZ)
d142 1
d147 1
a148 1
#endif /* TIOCGWINSZ */
d176 36
a287 1
#if !defined (__GO32__) || defined (HAVE_TERMIOS_H)
a352 1
#endif /* !__GO32__ || HAVE_TERMIOS_H */
d390 46
d441 1
d457 1
a457 1
get_tty_settings (tty, tiop)
a462 4
#if defined (TIOCGWINSZ)
  set_winsize (tty);
#endif

d486 15
d509 1
a509 1
set_tty_settings (tty, tiop)
d519 2
d522 8
d546 1
a546 1
#endif
a617 1
#if !defined (__GO32__) || defined (HAVE_TERMIOS_H)
d637 2
a653 1
#endif /* !__GO32__ || HAVE_TERMIOS_H */
a659 1
#if !defined (__GO32__) || defined (HAVE_TERMIOS_H)
a683 1
#endif /* !__GO32__ || HAVE_TERMIOS_H */
d821 51
@


1.2
log
@[__GO32__]: Don't undef HANDLE_SIGNALS if __DJGPP__ is defined.
(prepare_terminal_settings, rl_prep_terminal, rl_deprep_terminal)
[__GO32__]: Don't bypass termios code if HAVE_TERMIOS_H is defined.
@
text
@@


1.1
log
@Initial revision
@
text
@d40 1
a40 1
#if !defined (SHELL) && defined (GWINSZ_IN_SYS_IOCTL)
d42 1
a42 1
#endif /* !SHELL && GWINSZ_IN_SYS_IOCTL */
d60 3
a62 1
#  undef HANDLE_SIGNALS
d149 1
a149 1
#if !defined (SHELL) && defined (TIOCGWINSZ)
d161 1
a161 3
#else /* SHELL || !TIOCGWINSZ */
#  define set_winsize(tty)
#endif /* SHELL || !TIOCGWINSZ */
d194 1
d196 1
d265 1
a265 1
#if !defined (__GO32__)
d331 1
a331 1
#endif /* !__GO32__ */
d394 2
d397 1
d529 1
a529 1
#if !defined (__GO32__)
d564 1
a564 1
#endif /* !__GO32__ */
d571 1
a571 1
#if !defined (__GO32__)
d596 1
a596 1
#endif /* !__GO32__ */
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-08-02 snapshot
@
text
@d40 1
a40 1
#if defined (GWINSZ_IN_SYS_IOCTL)
d42 1
a42 1
#endif /* GWINSZ_IN_SYS_IOCTL */
d147 1
a147 1
#if defined (TIOCGWINSZ)
d159 3
a161 1
#endif /* TIOCGWINSZ */
a391 1

@


1.1.1.3
log
@import gdb-1999-08-16 snapshot
@
text
@a191 1
#if defined (TIOCGWINSZ)
a192 1
#endif
a390 1
#if defined (TIOCGWINSZ)
a391 1
#endif
@


1.1.1.4
log
@Import of readline 4.0
@
text
@d192 1
d194 1
d393 1
d395 1
@


1.1.1.5
log
@Import of readline 4.1
@
text
@d11 1
a11 1
   as published by the Free Software Foundation; either version 2, or
d22 1
a22 1
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
a45 1
#include "rlprivate.h"
d51 15
a106 1

d114 1
a114 1
  if (sigint_blocked == 0)
a140 2
static _RL_TTY_CHARS _rl_tty_chars, _rl_last_tty_chars;

d147 1
a153 1
#if defined (TIOCGWINSZ)
d158 1
a159 1
}
a186 36
static void
save_tty_chars (tiop)
     TIOTYPE *tiop;
{
  _rl_last_tty_chars = _rl_tty_chars;

  if (tiop->flags & SGTTY_SET)
    {
      _rl_tty_chars.t_erase = tiop->sgttyb.sg_erase;
      _rl_tty_chars.t_kill = tiop->sgttyb.sg_kill;
    }

  if (tiop->flags & TCHARS_SET)
    {
      _rl_tty_chars.t_intr = tiop->tchars.t_intrc;
      _rl_tty_chars.t_quit = tiop->tchars.t_quitc;
      _rl_tty_chars.t_start = tiop->tchars.t_startc;
      _rl_tty_chars.t_stop = tiop->tchars.t_stopc
      _rl_tty_chars.t_eof = tiop->tchars.t_eofc;
      _rl_tty_chars.t_eol = '\n';
      _rl_tty_chars.t_eol2 = tiop->tchars.t_brkc;
    }

  if (tiop->flags & LTCHARS_SET)
    {
      _rl_tty_chars.t_susp = tiop->ltchars.t_suspc;
      _rl_tty_chars.t_dsusp = tiop->ltchars.t_dsuspc;
      _rl_tty_chars.t_reprint = tiop->ltchars.t_rprntc;
      _rl_tty_chars.t_flush = tiop->ltchars.t_flushc;
      _rl_tty_chars.t_werase = tiop->ltchars.t_werasc;
      _rl_tty_chars.t_lnext = tiop->ltchars.t_lnextc;
    }

  _rl_tty_chars.t_status = -1;
}

d261 1
d327 1
a364 46
save_tty_chars (tiop)
     TIOTYPE *tiop;
{
  _rl_last_tty_chars = _rl_tty_chars;

  _rl_tty_chars.t_eof = tiop->c_cc[VEOF];
  _rl_tty_chars.t_eol = tiop->c_cc[VEOL];
#ifdef VEOL2
  _rl_tty_chars.t_eol2 = tiop->c_cc[VEOL2];
#endif
  _rl_tty_chars.t_erase = tiop->c_cc[VERASE];
#ifdef VWERASE
  _rl_tty_chars.t_werase = tiop->c_cc[VWERASE];
#endif
  _rl_tty_chars.t_kill = tiop->c_cc[VKILL];
#ifdef VREPRINT
  _rl_tty_chars.t_reprint = tiop->c_cc[VREPRINT];
#endif
  _rl_tty_chars.t_intr = tiop->c_cc[VINTR];
  _rl_tty_chars.t_quit = tiop->c_cc[VQUIT];
#ifdef VSUSP
  _rl_tty_chars.t_susp = tiop->c_cc[VSUSP];
#endif
#ifdef VDSUSP
  _rl_tty_chars.t_dsusp = tiop->c_cc[VDSUSP];
#endif
#ifdef VSTART
  _rl_tty_chars.t_start = tiop->c_cc[VSTART];
#endif
#ifdef VSTOP
  _rl_tty_chars.t_stop = tiop->c_cc[VSTOP];
#endif
#ifdef VLNEXT
  _rl_tty_chars.t_lnext = tiop->c_cc[VLNEXT];
#endif
#ifdef VDISCARD
  _rl_tty_chars.t_flush = tiop->c_cc[VDISCARD];
#endif
#ifdef VSTATUS
  _rl_tty_chars.t_status = tiop->c_cc[VSTATUS];
#endif
}

#if defined (_AIX) || defined (_AIX41)
/* Currently this is only used on AIX */
static void
a369 1
#endif
d385 1
a385 1
_get_tty_settings (tty, tiop)
d391 2
a415 13
  return 0;
}

static int
get_tty_settings (tty, tiop)
     int tty;
     TIOTYPE *tiop;
{
  set_winsize (tty);

  if (_get_tty_settings (tty, tiop) < 0)
    return -1;

d424 1
a424 1
_set_tty_settings (tty, tiop)
a433 2
  return 0;
}
a434 8
static int
set_tty_settings (tty, tiop)
     int tty;
     TIOTYPE *tiop;
{
  if (_set_tty_settings (tty, tiop) < 0)
    return -1;
    
d451 1
a451 1
#endif /* 0 */
d523 1
a542 2
  save_tty_chars (&otio);

d558 1
d565 1
d590 1
a727 51

#if defined (HANDLE_SIGNALS)

#if defined (NEW_TTY_DRIVER)
int
_rl_disable_tty_signals ()
{
  return 0;
}

int
_rl_restore_tty_signals ()
{
  return 0;
}
#else

static TIOTYPE sigstty, nosigstty;
static int tty_sigs_disabled = 0;

int
_rl_disable_tty_signals ()
{
  if (tty_sigs_disabled)
    return 0;

  if (_get_tty_settings (fileno (rl_instream), &sigstty) < 0)
    return -1;

  nosigstty = sigstty;

  nosigstty.c_lflag &= ~ISIG;

  if (_set_tty_settings (fileno (rl_instream), &nosigstty) < 0)
    return (_set_tty_settings (fileno (rl_instream), &sigstty));

  tty_sigs_disabled = 1;
  return 0;
}

int
_rl_restore_tty_signals ()
{
  if (tty_sigs_disabled == 0)
    return 0;

  return (_set_tty_settings (fileno (rl_instream), &sigstty));
}
#endif /* !NEW_TTY_DRIVER */

#endif /* HANDLE_SIGNALS */
@


1.1.1.6
log
@import of readline-4.3
@
text
@d52 2
a53 7
rl_vintfunc_t *rl_prep_term_function = rl_prep_terminal;
rl_voidfunc_t *rl_deprep_term_function = rl_deprep_terminal;

static void block_sigint PARAMS((void));
static void release_sigint PARAMS((void));

static void set_winsize PARAMS((int));
a175 8
static void save_tty_chars PARAMS((TIOTYPE *));
static int _get_tty_settings PARAMS((int, TIOTYPE *));
static int get_tty_settings PARAMS((int, TIOTYPE *));
static int _set_tty_settings PARAMS((int, TIOTYPE *));
static int set_tty_settings PARAMS((int, TIOTYPE *));

static void prepare_terminal_settings PARAMS((int, TIOTYPE, TIOTYPE *));

d193 1
a193 1
      _rl_tty_chars.t_stop = tiop->tchars.t_stopc;
d221 1
a221 2
  if (ioctl (tty, TIOCGETP, &(tiop->sgttyb)) < 0)
    return -1;
d225 2
a226 2
  if (ioctl (tty, TIOCLGET, &(tiop->lflag)) == 0)
    tiop->flags |= LFLAG_SET;
d230 2
a231 2
  if (ioctl (tty, TIOCGETC, &(tiop->tchars)) == 0)
    tiop->flags |= TCHARS_SET;
d235 2
a236 2
  if (ioctl (tty, TIOCGLTC, &(tiop->ltchars)) == 0)
    tiop->flags |= LTCHARS_SET;
d282 1
a282 1
prepare_terminal_settings (meta_flag, oldtio, tiop)
d284 1
a284 1
     TIOTYPE oldtio, *tiop;
d286 1
a286 1
  readline_echoing_p = (oldtio.sgttyb.sg_flags & ECHO);
d290 2
a291 2
  tiop->sgttyb = oldtio.sgttyb;
  tiop->lflag = oldtio.lflag;
d293 1
a293 1
  tiop->tchars = oldtio.tchars;
d296 1
a296 1
  tiop->ltchars = oldtio.ltchars;
d298 1
a298 1
  tiop->flags = oldtio.flags;
d311 2
a312 2
  if (((oldtio.sgttyb.sg_flags & ANYP) == ANYP) ||
      ((oldtio.sgttyb.sg_flags & ANYP) == 0))
d331 2
a332 2
  if (oldtio.tchars.t_startc != -1)
    rl_bind_key (oldtio.tchars.t_startc, rl_restart_output);
d336 2
a337 2
  if (oldtio.tchars.t_eofc != -1)
    _rl_eof_char = oldtio.tchars.t_eofc;
d376 1
a376 1
#  define SETATTR(tty, tiop)	(ioctl (tty, TCSETAW, tiop))
a380 8
static void save_tty_chars PARAMS((TIOTYPE *));
static int _get_tty_settings PARAMS((int, TIOTYPE *));
static int get_tty_settings PARAMS((int, TIOTYPE *));
static int _set_tty_settings PARAMS((int, TIOTYPE *));
static int set_tty_settings PARAMS((int, TIOTYPE *));

static void prepare_terminal_settings PARAMS((int, TIOTYPE, TIOTYPE *));

d548 1
a548 1
prepare_terminal_settings (meta_flag, oldtio, tiop)
d550 1
a550 1
     TIOTYPE oldtio, *tiop;
d552 1
a552 1
  readline_echoing_p = (oldtio.c_lflag & ECHO);
d556 2
a557 2
  if ((unsigned char) oldtio.c_cc[VEOF] != (unsigned char) _POSIX_VDISABLE)
    _rl_eof_char = oldtio.c_cc[VEOF];
d588 1
a588 1
      oldtio.c_lflag &= ~FLUSHO;
a647 1
  RL_SETSTATE(RL_STATE_TERMPREPPED);
a677 1
  RL_UNSETSTATE(RL_STATE_TERMPREPPED);
a753 3

/* Set the system's default editing characters to their readline equivalents
   in KMAP.  Should be static, now that we have rl_tty_set_default_bindings. */
d768 2
a769 2
      if (ic != -1 && kmap[(unsigned char)ic].type == ISFUNC) \
	kmap[(unsigned char)ic].function = func; \
a817 9
/* New public way to set the system default editing chars to their readline
   equivalents. */
void
rl_tty_set_default_bindings (kmap)
     Keymap kmap;
{
  rltty_set_default_bindings (kmap);
}

a848 1
  nosigstty.c_iflag &= ~IXON;
a859 2
  int r;

d863 1
a863 6
  r = _set_tty_settings (fileno (rl_instream), &sigstty);

  if (r == 0)
    tty_sigs_disabled = 0;

  return r;
@


1.1.1.7
log
@import of readlilne 5.1
@
text
@d4 1
a4 1
/* Copyright (C) 1992-2005 Free Software Foundation, Inc.
d155 1
a155 3
#if defined (NO_TTY_DRIVER)
/* Nothing */
#elif defined (NEW_TTY_DRIVER)
a188 2
static void set_special_char PARAMS((Keymap, TIOTYPE *, int, rl_command_func_t));

a233 1
  errno = 0;
a402 3
static void set_special_char PARAMS((Keymap, TIOTYPE *, int, rl_command_func_t));
static void _rl_bind_tty_special_chars PARAMS((Keymap, TIOTYPE));

a515 1
  errno = 0;
d629 1
a629 1
#endif  /* !NEW_TTY_DRIVER */
a631 14
#if defined (NO_TTY_DRIVER)
void
rl_prep_terminal (meta_flag)
     int meta_flag;
{
  readline_echoing_p = 1;
}

void
rl_deprep_terminal ()
{
}

#else /* ! NO_TTY_DRIVER */
a648 7
#if defined (ENOTSUP)
      /* MacOS X, at least, lies about the value of errno if tcgetattr fails. */
      if (errno == ENOTTY || errno == ENOTSUP)
#else
      if (errno == ENOTTY)
#endif
	readline_echoing_p = 1;		/* XXX */
a654 11
  if (_rl_bind_stty_chars)
    {
#if defined (VI_MODE)
      /* If editing in vi mode, make sure we restore the bindings in the
	 insertion keymap no matter what keymap we ended up in. */
      if (rl_editing_mode == vi_mode)
	rl_tty_unset_default_bindings (vi_insertion_keymap);
      else
#endif
	rl_tty_unset_default_bindings (_rl_keymap);
    }
a655 12
  RL_SETSTATE(RL_STATE_TTYCSAVED);
  if (_rl_bind_stty_chars)
    {
#if defined (VI_MODE)
      /* If editing in vi mode, make sure we set the bindings in the
	 insertion keymap no matter what keymap we ended up in. */
      if (rl_editing_mode == vi_mode)
	_rl_bind_tty_special_chars (vi_insertion_keymap, tio);	
      else
#endif
	_rl_bind_tty_special_chars (_rl_keymap, tio);
    }
a704 1
#endif /* !NO_TTY_DRIVER */
a715 4
#if defined (__MINGW32__)
  return 0;
#else /* !__MING32__ */

a742 1
#endif /* !__MINGW32__ */
a748 4
#if defined (__MINGW32__)
  return 0;
#else

a770 1
#endif /* !__MINGW32__ */
d779 4
a782 12
#if !defined (NO_TTY_DRIVER)
#define SET_SPECIAL(sc, func)	set_special_char(kmap, &ttybuff, sc, func)
#endif

#if defined (NO_TTY_DRIVER)

#define SET_SPECIAL(sc, func)
#define RESET_SPECIAL(c)

#elif defined (NEW_TTY_DRIVER)
static void
set_special_char (kmap, tiop, sc, func)
a783 3
     TIOTYPE *tiop;
     int sc;
     rl_command_func_t *func;
d785 4
a788 3
  if (sc != -1 && kmap[(unsigned char)sc].type == ISFUNC)
    kmap[(unsigned char)sc].function = func;
}
d790 9
a798 3
#define RESET_SPECIAL(c) \
  if (c != -1 && kmap[(unsigned char)c].type == ISFUNC)
    kmap[(unsigned char)c].function = rl_insert;
d800 1
a800 6
static void
_rl_bind_tty_special_chars (kmap, ttybuff)
     Keymap kmap;
     TIOTYPE ttybuff;
{
  if (ttybuff.flags & SGTTY_SET)
d802 5
a806 3
      SET_SPECIAL (ttybuff.sgttyb.sg_erase, rl_rubout);
      SET_SPECIAL (ttybuff.sgttyb.sg_kill, rl_unix_line_discard);
    }
d809 6
a814 4
  if (ttybuff.flags & LTCHARS_SET)
    {
      SET_SPECIAL (ttybuff.ltchars.t_werasc, rl_unix_word_rubout);
      SET_SPECIAL (ttybuff.ltchars.t_lnextc, rl_quoted_insert);
a815 2
#  endif /* TIOCGLTC */
}
a817 8
static void
set_special_char (kmap, tiop, sc, func)
     Keymap kmap;
     TIOTYPE *tiop;
     int sc;
     rl_command_func_t *func;
{
  unsigned char uc;
d819 9
a827 4
  uc = tiop->c_cc[sc];
  if (uc != (unsigned char)_POSIX_VDISABLE && kmap[uc].type == ISFUNC)
    kmap[uc].function = func;
}
d829 4
a832 12
/* used later */
#define RESET_SPECIAL(uc) \
  if (uc != (unsigned char)_POSIX_VDISABLE && kmap[uc].type == ISFUNC) \
    kmap[uc].function = rl_insert;

static void
_rl_bind_tty_special_chars (kmap, ttybuff)
     Keymap kmap;
     TIOTYPE ttybuff;
{
  SET_SPECIAL (VERASE, rl_rubout);
  SET_SPECIAL (VKILL, rl_unix_line_discard);
d835 1
a835 1
  SET_SPECIAL (VLNEXT, rl_quoted_insert);
d839 1
a839 1
  SET_SPECIAL (VWERASE, rl_unix_word_rubout);
d841 1
a841 2
}

a842 17

/* Set the system's default editing characters to their readline equivalents
   in KMAP.  Should be static, now that we have rl_tty_set_default_bindings. */
void
rltty_set_default_bindings (kmap)
     Keymap kmap;
{
#if !defined (NO_TTY_DRIVER)
  TIOTYPE ttybuff;
  int tty;
  static int called = 0;

  tty = fileno (rl_instream);

  if (get_tty_settings (tty, &ttybuff) == 0)
    _rl_bind_tty_special_chars (kmap, ttybuff);
#endif
a853 24
/* Rebind all of the tty special chars that readline worries about back
   to self-insert.  Call this before saving the current terminal special
   chars with save_tty_chars().  This only works on POSIX termios or termio
   systems. */
void
rl_tty_unset_default_bindings (kmap)
     Keymap kmap;
{
  /* Don't bother before we've saved the tty special chars at least once. */
  if (RL_ISSTATE(RL_STATE_TTYCSAVED) == 0)
    return;

  RESET_SPECIAL (_rl_tty_chars.t_erase);
  RESET_SPECIAL (_rl_tty_chars.t_kill);

#  if defined (VLNEXT) && defined (TERMIOS_TTY_DRIVER)
  RESET_SPECIAL (_rl_tty_chars.t_lnext);
#  endif /* VLNEXT && TERMIOS_TTY_DRIVER */

#  if defined (VWERASE) && defined (TERMIOS_TTY_DRIVER)
  RESET_SPECIAL (_rl_tty_chars.t_werase);
#  endif /* VWERASE && TERMIOS_TTY_DRIVER */
}

d856 1
a856 1
#if defined (NEW_TTY_DRIVER) || defined (NO_TTY_DRIVER)
@


