head	1.7;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.7
	gdb_7_6-2013-04-26-release:1.7
	gdb_7_6-branch:1.7.0.6
	gdb_7_6-2013-03-12-branchpoint:1.7
	gdb_7_5_1-2012-11-29-release:1.7
	gdb_7_5-2012-08-17-release:1.7
	gdb_7_5-branch:1.7.0.4
	gdb_7_5-2012-07-18-branchpoint:1.7
	gdb_7_4_1-2012-04-26-release:1.7
	gdb_7_4-2012-01-24-release:1.7
	gdb_7_4-branch:1.7.0.2
	gdb_7_4-2011-12-13-branchpoint:1.7
	gdb_7_3_1-2011-09-04-release:1.6
	gdb_7_3-2011-07-26-release:1.6
	gdb_7_3-branch:1.6.0.36
	gdb_7_3-2011-04-01-branchpoint:1.6
	gdb_7_2-2010-09-02-release:1.6
	gdb_7_2-branch:1.6.0.34
	gdb_7_2-2010-07-07-branchpoint:1.6
	gdb_7_1-2010-03-18-release:1.6
	gdb_7_1-branch:1.6.0.32
	gdb_7_1-2010-02-18-branchpoint:1.6
	gdb_7_0_1-2009-12-22-release:1.6
	gdb_7_0-2009-10-06-release:1.6
	gdb_7_0-branch:1.6.0.30
	gdb_7_0-2009-09-16-branchpoint:1.6
	arc-sim-20090309:1.6
	msnyder-checkpoint-072509-branch:1.6.0.28
	msnyder-checkpoint-072509-branchpoint:1.6
	arc-insight_6_8-branch:1.6.0.26
	arc-insight_6_8-branchpoint:1.6
	insight_6_8-branch:1.6.0.24
	insight_6_8-branchpoint:1.6
	reverse-20081226-branch:1.6.0.22
	reverse-20081226-branchpoint:1.6
	multiprocess-20081120-branch:1.6.0.20
	multiprocess-20081120-branchpoint:1.6
	reverse-20080930-branch:1.6.0.18
	reverse-20080930-branchpoint:1.6
	reverse-20080717-branch:1.6.0.16
	reverse-20080717-branchpoint:1.6
	msnyder-reverse-20080609-branch:1.6.0.14
	msnyder-reverse-20080609-branchpoint:1.6
	drow-reverse-20070409-branch:1.6.0.12
	drow-reverse-20070409-branchpoint:1.6
	gdb_6_8-2008-03-27-release:1.6
	gdb_6_8-branch:1.6.0.10
	gdb_6_8-2008-02-26-branchpoint:1.6
	gdb_6_7_1-2007-10-29-release:1.6
	gdb_6_7-2007-10-10-release:1.6
	gdb_6_7-branch:1.6.0.8
	gdb_6_7-2007-09-07-branchpoint:1.6
	insight_6_6-20070208-release:1.6
	gdb_6_6-2006-12-18-release:1.6
	gdb_6_6-branch:1.6.0.6
	gdb_6_6-2006-11-15-branchpoint:1.6
	insight_6_5-20061003-release:1.6
	gdb-csl-symbian-6_4_50_20060226-12:1.4
	gdb-csl-sourcerygxx-3_4_4-25:1.4
	nickrob-async-20060828-mergepoint:1.6
	gdb-csl-symbian-6_4_50_20060226-11:1.4
	gdb-csl-sourcerygxx-4_1-17:1.4
	gdb-csl-20060226-branch-local-2:1.4
	gdb-csl-sourcerygxx-4_1-14:1.4
	gdb-csl-sourcerygxx-4_1-13:1.4
	gdb-csl-sourcerygxx-4_1-12:1.4
	gdb-csl-sourcerygxx-3_4_4-21:1.4
	gdb_6_5-20060621-release:1.6
	gdb-csl-sourcerygxx-4_1-9:1.4
	gdb-csl-sourcerygxx-4_1-8:1.4
	gdb-csl-sourcerygxx-4_1-7:1.4
	gdb-csl-arm-2006q1-6:1.4
	gdb-csl-sourcerygxx-4_1-6:1.4
	gdb-csl-symbian-6_4_50_20060226-10:1.4
	gdb-csl-symbian-6_4_50_20060226-9:1.4
	gdb-csl-symbian-6_4_50_20060226-8:1.4
	gdb-csl-coldfire-4_1-11:1.4
	gdb-csl-sourcerygxx-3_4_4-19:1.4
	gdb-csl-coldfire-4_1-10:1.4
	gdb_6_5-branch:1.6.0.4
	gdb_6_5-2006-05-14-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-5:1.4
	nickrob-async-20060513-branch:1.6.0.2
	nickrob-async-20060513-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-4:1.4
	msnyder-reverse-20060502-branch:1.5.0.4
	msnyder-reverse-20060502-branchpoint:1.5
	gdb-csl-morpho-4_1-4:1.4
	gdb-csl-sourcerygxx-3_4_4-17:1.4
	readline_5_1-import-branch:1.5.0.2
	readline_5_1-import-branchpoint:1.5
	readline-pre-51-import:1.5
	readline_5_1:1.1.1.5
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.4
	gdb-csl-symbian-20060226-branch:1.4.0.78
	gdb-csl-symbian-20060226-branchpoint:1.4
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.4
	msnyder-reverse-20060331-branch:1.4.0.76
	msnyder-reverse-20060331-branchpoint:1.4
	gdb-csl-available-20060303-branch:1.4.0.74
	gdb-csl-available-20060303-branchpoint:1.4
	gdb-csl-20060226-branch:1.4.0.72
	gdb-csl-20060226-branchpoint:1.4
	gdb_6_4-20051202-release:1.4
	msnyder-fork-checkpoint-branch:1.4.0.70
	msnyder-fork-checkpoint-branchpoint:1.4
	gdb-csl-gxxpro-6_3-branch:1.4.0.68
	gdb-csl-gxxpro-6_3-branchpoint:1.4
	gdb_6_4-branch:1.4.0.66
	gdb_6_4-2005-11-01-branchpoint:1.4
	gdb-csl-arm-20051020-branch:1.4.0.64
	gdb-csl-arm-20051020-branchpoint:1.4
	msnyder-tracepoint-checkpoint-branch:1.4.0.62
	msnyder-tracepoint-checkpoint-branchpoint:1.4
	gdb-csl-arm-20050325-2005-q1b:1.4
	gdb-csl-arm-20050325-2005-q1a:1.4
	csl-arm-20050325-branch:1.4.0.60
	csl-arm-20050325-branchpoint:1.4
	gdb_6_3-20041109-release:1.4
	gdb_6_3-branch:1.4.0.56
	gdb_6_3-20041019-branchpoint:1.4
	drow_intercu-merge-20040921:1.4
	drow_intercu-merge-20040915:1.4
	jimb-gdb_6_2-e500-branch:1.4.0.58
	jimb-gdb_6_2-e500-branchpoint:1.4
	gdb_6_2-20040730-release:1.4
	gdb_6_2-branch:1.4.0.54
	gdb_6_2-2004-07-10-gmt-branchpoint:1.4
	gdb_6_1_1-20040616-release:1.4
	gdb_6_1-2004-04-05-release:1.4
	drow_intercu-merge-20040402:1.4
	drow_intercu-merge-20040327:1.4
	ezannoni_pie-20040323-branch:1.4.0.52
	ezannoni_pie-20040323-branchpoint:1.4
	cagney_tramp-20040321-mergepoint:1.4
	cagney_tramp-20040309-branch:1.4.0.50
	cagney_tramp-20040309-branchpoint:1.4
	gdb_6_1-branch:1.4.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.4
	drow_intercu-20040221-branch:1.4.0.46
	drow_intercu-20040221-branchpoint:1.4
	cagney_bfdfile-20040213-branch:1.4.0.44
	cagney_bfdfile-20040213-branchpoint:1.4
	drow-cplus-merge-20040208:1.4
	carlton_dictionary-20040126-merge:1.4
	cagney_bigcore-20040122-branch:1.4.0.42
	cagney_bigcore-20040122-branchpoint:1.4
	drow-cplus-merge-20040113:1.4
	drow-cplus-merge-20031224:1.4
	drow-cplus-merge-20031220:1.4
	carlton_dictionary-20031215-merge:1.4
	drow-cplus-merge-20031214:1.4
	carlton-dictionary-20031111-merge:1.4
	gdb_6_0-2003-10-04-release:1.4
	kettenis_sparc-20030918-branch:1.4.0.40
	kettenis_sparc-20030918-branchpoint:1.4
	carlton_dictionary-20030917-merge:1.4
	ezannoni_pie-20030916-branchpoint:1.4
	ezannoni_pie-20030916-branch:1.4.0.38
	cagney_x86i386-20030821-branch:1.4.0.36
	cagney_x86i386-20030821-branchpoint:1.4
	carlton_dictionary-20030805-merge:1.4
	carlton_dictionary-20030627-merge:1.4
	gdb_6_0-branch:1.4.0.34
	gdb_6_0-2003-06-23-branchpoint:1.4
	jimb-ppc64-linux-20030613-branch:1.4.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.4
	cagney_convert-20030606-branch:1.4.0.30
	cagney_convert-20030606-branchpoint:1.4
	cagney_writestrings-20030508-branch:1.4.0.28
	cagney_writestrings-20030508-branchpoint:1.4
	jimb-ppc64-linux-20030528-branch:1.4.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.4
	carlton_dictionary-20030523-merge:1.4
	cagney_fileio-20030521-branch:1.4.0.24
	cagney_fileio-20030521-branchpoint:1.4
	kettenis_i386newframe-20030517-mergepoint:1.4
	jimb-ppc64-linux-20030509-branch:1.4.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.4
	kettenis_i386newframe-20030504-mergepoint:1.4
	carlton_dictionary-20030430-merge:1.4
	kettenis_i386newframe-20030419-branch:1.4.0.20
	kettenis_i386newframe-20030419-branchpoint:1.4
	carlton_dictionary-20030416-merge:1.4
	cagney_frameaddr-20030409-mergepoint:1.4
	kettenis_i386newframe-20030406-branch:1.4.0.18
	kettenis_i386newframe-20030406-branchpoint:1.4
	cagney_frameaddr-20030403-branchpoint:1.4
	cagney_frameaddr-20030403-branch:1.4.0.16
	cagney_framebase-20030330-mergepoint:1.4
	cagney_framebase-20030326-branch:1.4.0.14
	cagney_framebase-20030326-branchpoint:1.4
	cagney_lazyid-20030317-branch:1.4.0.12
	cagney_lazyid-20030317-branchpoint:1.4
	kettenis-i386newframe-20030316-mergepoint:1.4
	offbyone-20030313-branch:1.4.0.10
	offbyone-20030313-branchpoint:1.4
	kettenis-i386newframe-20030308-branch:1.4.0.8
	kettenis-i386newframe-20030308-branchpoint:1.4
	carlton_dictionary-20030305-merge:1.4
	cagney_offbyone-20030303-branch:1.4.0.6
	cagney_offbyone-20030303-branchpoint:1.4
	carlton_dictionary-20030207-merge:1.4
	interps-20030202-branch:1.4.0.4
	interps-20030202-branchpoint:1.4
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.3
	readline-pre-43-import:1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.24
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	carlton_dictionary-branch:1.3.0.22
	carlton_dictionary-20020920-branchpoint:1.3
	gdb_5_3-branch:1.3.0.20
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.3
	cagney_sysregs-20020825-branch:1.3.0.18
	cagney_sysregs-20020825-branchpoint:1.3
	readline_4_3-import-branch:1.3.0.16
	readline_4_3-import-branchpoint:1.3
	readline_4_3:1.1.1.4
	gdb_5_2_1-2002-07-23-release:1.3
	kseitz_interps-20020528-branch:1.3.0.14
	kseitz_interps-20020528-branchpoint:1.3
	cagney_regbuf-20020515-branch:1.3.0.12
	cagney_regbuf-20020515-branchpoint:1.3
	jimb-macro-020506-branch:1.3.0.10
	jimb-macro-020506-branchpoint:1.3
	gdb_5_2-2002-04-29-release:1.3
	gdb_5_2-branch:1.3.0.8
	gdb_5_2-2002-03-03-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	cygnus_cvs_20020108_pre:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.4
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.2
	gdb_5_1-2001-07-29-branchpoint:1.3
	insight-precleanup-2001-01-01:1.3
	readline_4_1:1.1.1.3
	readline_4_0:1.1.1.2
	FSF:1.1.1
	readline-pre-41-import:1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.7
date	2011.05.11.23.38.39;	author jkratoch;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.05.18.26.12;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.20.20.13.20;	author ezannoni;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2002.12.08.22.31.37;	author ezannoni;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.09.17.19.56;	author ezannoni;	state Exp;
branches
	1.3.16.1
	1.3.22.1
	1.3.24.1;
next	1.2;

1.2
date	2000.07.07.17.15.45;	author ezannoni;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.53;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.5.2.1
date	2006.04.24.22.00.25;	author drow;	state Exp;
branches;
next	;

1.3.16.1
date	2002.08.25.23.41.17;	author ezannoni;	state Exp;
branches;
next	;

1.3.22.1
date	2002.12.23.19.39.43;	author carlton;	state Exp;
branches;
next	;

1.3.24.1
date	2003.12.14.20.28.14;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.53;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.08.02.23.47.58;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.07.09.16.21.20;	author ezannoni;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.08.23.22.02.28;	author ezannoni;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.20.20.05.36;	author ezannoni;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Imported readline 6.2, and upstream patch 001.

[patch 0/3] readline-6.2 rebase
http://sourceware.org/ml/gdb-patches/2011-05/msg00003.html
[patch 1/3] readline-6.2: Merge of already posted patches
http://sourceware.org/ml/gdb-patches/2011-05/msg00004.html
	=
	[Bug-readline] [RFC/readline] bind.c, rl_function_dumper, Free allocated
	http://lists.gnu.org/archive/html/bug-readline/2011-03/msg00000.html
	[Bug-readline] [patch] Fix underquotation in readline/examples/rlfe/conf
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00001.html
	[Bug-readline] [patch] Makefile.in htm<->html
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00002.html
	Re: [Bug-readline] [patch] Makefile.in dependency: callback.o: xmalloc.h
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00004.html
	[Bug-readline] [patch] Remove . from the VPATH directive
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00005.html
	Eli Zaretskii's __MSDOS__ / __GO32__ / __MINGW32__ / __DJGPP__ stuff:
	http://sourceware.org/ml/gdb/2011-04/msg00002.html
	Jan Kratochvil's patch for FSF GDB tree local-specific changes:
	http://sourceware.org/ml/gdb/2011-04/msg00006.html
	Preservation of existing ChangeLog.gdb files, their updates.
[patch 2/3] readline-6.2: Workaround "ask" regression
http://sourceware.org/ml/gdb-patches/2011-05/msg00005.html
[patch 3/3] readline-6.2: Revert 5.x compat., apply 6.x compat.
http://sourceware.org/ml/gdb-patches/2011-05/msg00006.html
[patch 4/3] readline-6.2: Substitute inc-hist.texinfo
http://sourceware.org/ml/gdb-patches/2011-05/msg00010.html

readline/
	Workaround gdb.base/completion.exp regression on readline-6.2.
	* complete.c (get_y_or_n): Disable the return on RL_STATE_CALLBACK.

	Imported readline 6.2, and upstream patch 001.
	* configure: Regenerate.

readline/doc/
	* hsuser.texi (Using History Interactively): Disable !BashFeatures
	@@defcodeindex.  Make the `Programming with GNU History' reference
	external.
	* inc-hist.texinfo: Remove.

	Imported readline 6.2, and upstream patch 001.

readline/examples/
	Imported readline 6.2, and upstream patch 001.

readline/examples/rlfe/
	Imported readline 6.2, and upstream patch 001.

gdb/
	* config.in: Regenerate.
	* configure: Regenerate.
	* configure.ac <--with-system-readline> (for readline_echoing_p):
	Remove the test.
	* tui/tui-io.c (tui_old_readline_echoing_p): Rename to ...
	(tui_old_rl_echoing_p): ... here.
	(tui_setup_io): Rename extern declaration readline_echoing_p to
	_rl_echoing_p.  Adjust assignments for the both renames.

gdb/doc/
	* Makefile.in (GDB_DOC_SOURCE_INCLUDES): Rename inc-hist.texinfo to
	hsuser.texi.
	* gdb.texinfo <!SYSTEM_READLINE>: Rename inc-hist.texinfo inclusion and
	comment to hsuser.texi.  Change rluser.texi name in the comment.
@
text
@/* isearch.c - incremental searching */

/* **************************************************************** */
/*								    */
/*			I-Search and Searching			    */
/*								    */
/* **************************************************************** */

/* Copyright (C) 1987-2009 Free Software Foundation, Inc.

   This file is part of the GNU Readline Library (Readline), a library
   for reading lines of text with interactive input and history editing.      

   Readline is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Readline is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Readline.  If not, see <http://www.gnu.org/licenses/>.
*/

#define READLINE_LIBRARY

#if defined (HAVE_CONFIG_H)
#  include <config.h>
#endif

#include <sys/types.h>

#include <stdio.h>

#if defined (HAVE_UNISTD_H)
#  include <unistd.h>
#endif

#if defined (HAVE_STDLIB_H)
#  include <stdlib.h>
#else
#  include "ansi_stdlib.h"
#endif

#include "rldefs.h"
#include "rlmbutil.h"

#include "readline.h"
#include "history.h"

#include "rlprivate.h"
#include "xmalloc.h"

/* Variables exported to other files in the readline library. */
char *_rl_isearch_terminators = (char *)NULL;

_rl_search_cxt *_rl_iscxt = 0;

/* Variables imported from other files in the readline library. */
extern HIST_ENTRY *_rl_saved_line_for_history;

static int rl_search_history PARAMS((int, int));

static _rl_search_cxt *_rl_isearch_init PARAMS((int));
static void _rl_isearch_fini PARAMS((_rl_search_cxt *));
static int _rl_isearch_cleanup PARAMS((_rl_search_cxt *, int));

/* Last line found by the current incremental search, so we don't `find'
   identical lines many times in a row.  Now part of isearch context. */
/* static char *prev_line_found; */

/* Last search string and its length. */
static char *last_isearch_string;
static int last_isearch_string_len;

static char * const default_isearch_terminators = "\033\012";

_rl_search_cxt *
_rl_scxt_alloc (type, flags)
     int type, flags;
{
  _rl_search_cxt *cxt;

  cxt = (_rl_search_cxt *)xmalloc (sizeof (_rl_search_cxt));

  cxt->type = type;
  cxt->sflags = flags;

  cxt->search_string = 0;
  cxt->search_string_size = cxt->search_string_index = 0;

  cxt->lines = 0;
  cxt->allocated_line = 0;
  cxt->hlen = cxt->hindex = 0;

  cxt->save_point = rl_point;
  cxt->save_mark = rl_mark;
  cxt->save_line = where_history ();
  cxt->last_found_line = cxt->save_line;
  cxt->prev_line_found = 0;

  cxt->save_undo_list = 0;

  cxt->keymap = _rl_keymap;
  cxt->okeymap = _rl_keymap;

  cxt->history_pos = 0;
  cxt->direction = 0;

  cxt->lastc = 0;

  cxt->sline = 0;
  cxt->sline_len = cxt->sline_index = 0;

  cxt->search_terminators = 0;

  return cxt;
}

void
_rl_scxt_dispose (cxt, flags)
     _rl_search_cxt *cxt;
     int flags;
{
  FREE (cxt->search_string);
  FREE (cxt->allocated_line);
  FREE (cxt->lines);

  xfree (cxt);
}

/* Search backwards through the history looking for a string which is typed
   interactively.  Start with the current line. */
int
rl_reverse_search_history (sign, key)
     int sign, key;
{
  return (rl_search_history (-sign, key));
}

/* Search forwards through the history looking for a string which is typed
   interactively.  Start with the current line. */
int
rl_forward_search_history (sign, key)
     int sign, key;
{
  return (rl_search_history (sign, key));
}

/* Display the current state of the search in the echo-area.
   SEARCH_STRING contains the string that is being searched for,
   DIRECTION is zero for forward, or non-zero for reverse,
   WHERE is the history list number of the current line.  If it is
   -1, then this line is the starting one. */
static void
rl_display_search (search_string, reverse_p, where)
     char *search_string;
     int reverse_p, where;
{
  char *message;
  int msglen, searchlen;

  searchlen = (search_string && *search_string) ? strlen (search_string) : 0;

  message = (char *)xmalloc (searchlen + 33);
  msglen = 0;

#if defined (NOTDEF)
  if (where != -1)
    {
      sprintf (message, "[%d]", where + history_base);
      msglen = strlen (message);
    }
#endif /* NOTDEF */

  message[msglen++] = '(';

  if (reverse_p)
    {
      strcpy (message + msglen, "reverse-");
      msglen += 8;
    }

  strcpy (message + msglen, "i-search)`");
  msglen += 10;

  if (search_string)
    {
      strcpy (message + msglen, search_string);
      msglen += searchlen;
    }

  strcpy (message + msglen, "': ");

  rl_message ("%s", message);
  xfree (message);
  (*rl_redisplay_function) ();
}

static _rl_search_cxt *
_rl_isearch_init (direction)
     int direction;
{
  _rl_search_cxt *cxt;
  register int i;
  HIST_ENTRY **hlist;

  cxt = _rl_scxt_alloc (RL_SEARCH_ISEARCH, 0);
  if (direction < 0)
    cxt->sflags |= SF_REVERSE;

  cxt->search_terminators = _rl_isearch_terminators ? _rl_isearch_terminators
						: default_isearch_terminators;

  /* Create an arrary of pointers to the lines that we want to search. */
  hlist = history_list ();
  rl_maybe_replace_line ();
  i = 0;
  if (hlist)
    for (i = 0; hlist[i]; i++);

  /* Allocate space for this many lines, +1 for the current input line,
     and remember those lines. */
  cxt->lines = (char **)xmalloc ((1 + (cxt->hlen = i)) * sizeof (char *));
  for (i = 0; i < cxt->hlen; i++)
    cxt->lines[i] = hlist[i]->line;

  if (_rl_saved_line_for_history)
    cxt->lines[i] = _rl_saved_line_for_history->line;
  else
    {
      /* Keep track of this so we can free it. */
      cxt->allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));
      strcpy (cxt->allocated_line, &rl_line_buffer[0]);
      cxt->lines[i] = cxt->allocated_line;
    }

  cxt->hlen++;

  /* The line where we start the search. */
  cxt->history_pos = cxt->save_line;

  rl_save_prompt ();

  /* Initialize search parameters. */
  cxt->search_string = (char *)xmalloc (cxt->search_string_size = 128);
  cxt->search_string[cxt->search_string_index = 0] = '\0';

  /* Normalize DIRECTION into 1 or -1. */
  cxt->direction = (direction >= 0) ? 1 : -1;

  cxt->sline = rl_line_buffer;
  cxt->sline_len = strlen (cxt->sline);
  cxt->sline_index = rl_point;

  _rl_iscxt = cxt;		/* save globally */

  return cxt;
}

static void
_rl_isearch_fini (cxt)
     _rl_search_cxt *cxt;
{
  /* First put back the original state. */
  strcpy (rl_line_buffer, cxt->lines[cxt->save_line]);

  rl_restore_prompt ();

  /* Save the search string for possible later use. */
  FREE (last_isearch_string);
  last_isearch_string = cxt->search_string;
  last_isearch_string_len = cxt->search_string_index;
  cxt->search_string = 0;

  if (cxt->last_found_line < cxt->save_line)
    rl_get_previous_history (cxt->save_line - cxt->last_found_line, 0);
  else
    rl_get_next_history (cxt->last_found_line - cxt->save_line, 0);

  /* If the string was not found, put point at the end of the last matching
     line.  If last_found_line == orig_line, we didn't find any matching
     history lines at all, so put point back in its original position. */
  if (cxt->sline_index < 0)
    {
      if (cxt->last_found_line == cxt->save_line)
	cxt->sline_index = cxt->save_point;
      else
	cxt->sline_index = strlen (rl_line_buffer);
      rl_mark = cxt->save_mark;
    }

  rl_point = cxt->sline_index;
  /* Don't worry about where to put the mark here; rl_get_previous_history
     and rl_get_next_history take care of it. */

  rl_clear_message ();
}

int
_rl_search_getchar (cxt)
     _rl_search_cxt *cxt;
{
  int c;

  /* Read a key and decide how to proceed. */
  RL_SETSTATE(RL_STATE_MOREINPUT);
  c = cxt->lastc = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    c = cxt->lastc = _rl_read_mbstring (cxt->lastc, cxt->mb, MB_LEN_MAX);
#endif

  return c;
}

/* Process just-read character C according to isearch context CXT.  Return
   -1 if the caller should just free the context and return, 0 if we should
   break out of the loop, and 1 if we should continue to read characters. */
int
_rl_isearch_dispatch (cxt, c)
     _rl_search_cxt *cxt;
     int c;
{
  int n, wstart, wlen, limit, cval;
  rl_command_func_t *f;

  f = (rl_command_func_t *)NULL;

  if (c < 0)
    {
      cxt->sflags |= SF_FAILED;
      cxt->history_pos = cxt->last_found_line;
      return -1;
    }

  /* If we are moving into a new keymap, modify cxt->keymap and go on.
     This can be a problem if c == ESC and we want to terminate the
     incremental search, so we check */
  if (c >= 0 && cxt->keymap[c].type == ISKMAP && strchr (cxt->search_terminators, cxt->lastc) == 0)
    {
      cxt->keymap = FUNCTION_TO_KEYMAP (cxt->keymap, c);
      cxt->sflags |= SF_CHGKMAP;
      /* XXX - we should probably save this sequence, so we can do
	 something useful if this doesn't end up mapping to a command. */
      return 1;
    }

  /* Translate the keys we do something with to opcodes. */
  if (c >= 0 && cxt->keymap[c].type == ISFUNC)
    {
      f = cxt->keymap[c].function;

      if (f == rl_reverse_search_history)
	cxt->lastc = (cxt->sflags & SF_REVERSE) ? -1 : -2;
      else if (f == rl_forward_search_history)
	cxt->lastc = (cxt->sflags & SF_REVERSE) ? -2 : -1;
      else if (f == rl_rubout)
	cxt->lastc = -3;
      else if (c == CTRL ('G') || f == rl_abort)
	cxt->lastc = -4;
      else if (c == CTRL ('W') || f == rl_unix_word_rubout)	/* XXX */
	cxt->lastc = -5;
      else if (c == CTRL ('Y') || f == rl_yank)	/* XXX */
	cxt->lastc = -6;
    }

  /* If we changed the keymap earlier while translating a key sequence into
     a command, restore it now that we've succeeded. */
  if (cxt->sflags & SF_CHGKMAP)
    {
      cxt->keymap = cxt->okeymap;
      cxt->sflags &= ~SF_CHGKMAP;
    }

  /* The characters in isearch_terminators (set from the user-settable
     variable isearch-terminators) are used to terminate the search but
     not subsequently execute the character as a command.  The default
     value is "\033\012" (ESC and C-J). */
  if (cxt->lastc > 0 && strchr (cxt->search_terminators, cxt->lastc))
    {
      /* ESC still terminates the search, but if there is pending
	 input or if input arrives within 0.1 seconds (on systems
	 with select(2)) it is used as a prefix character
	 with rl_execute_next.  WATCH OUT FOR THIS!  This is intended
	 to allow the arrow keys to be used like ^F and ^B are used
	 to terminate the search and execute the movement command.
	 XXX - since _rl_input_available depends on the application-
	 settable keyboard timeout value, this could alternatively
	 use _rl_input_queued(100000) */
      if (cxt->lastc == ESC && _rl_input_available ())
	rl_execute_next (ESC);
      return (0);
    }

#define ENDSRCH_CHAR(c) \
  ((CTRL_CHAR (c) || META_CHAR (c) || (c) == RUBOUT) && ((c) != CTRL ('G')))

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      if (cxt->lastc >= 0 && (cxt->mb[0] && cxt->mb[1] == '\0') && ENDSRCH_CHAR (cxt->lastc))
	{
	  /* This sets rl_pending_input to LASTC; it will be picked up the next
	     time rl_read_key is called. */
	  rl_execute_next (cxt->lastc);
	  return (0);
	}
    }
  else
#endif
    if (cxt->lastc >= 0 && ENDSRCH_CHAR (cxt->lastc))
      {
	/* This sets rl_pending_input to LASTC; it will be picked up the next
	   time rl_read_key is called. */
	rl_execute_next (cxt->lastc);
	return (0);
      }

  /* Now dispatch on the character.  `Opcodes' affect the search string or
     state.  Other characters are added to the string.  */
  switch (cxt->lastc)
    {
    /* search again */
    case -1:
      if (cxt->search_string_index == 0)
	{
	  if (last_isearch_string)
	    {
	      cxt->search_string_size = 64 + last_isearch_string_len;
	      cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	      strcpy (cxt->search_string, last_isearch_string);
	      cxt->search_string_index = last_isearch_string_len;
	      rl_display_search (cxt->search_string, (cxt->sflags & SF_REVERSE), -1);
	      break;
	    }
	  return (1);
	}
      else if (cxt->sflags & SF_REVERSE)
	cxt->sline_index--;
      else if (cxt->sline_index != cxt->sline_len)
	cxt->sline_index++;
      else
	rl_ding ();
      break;

    /* switch directions */
    case -2:
      cxt->direction = -cxt->direction;
      if (cxt->direction < 0)
	cxt->sflags |= SF_REVERSE;
      else
	cxt->sflags &= ~SF_REVERSE;
      break;

    /* delete character from search string. */
    case -3:	/* C-H, DEL */
      /* This is tricky.  To do this right, we need to keep a
	 stack of search positions for the current search, with
	 sentinels marking the beginning and end.  But this will
	 do until we have a real isearch-undo. */
      if (cxt->search_string_index == 0)
	rl_ding ();
      else
	cxt->search_string[--cxt->search_string_index] = '\0';
      break;

    case -4:	/* C-G, abort */
      rl_replace_line (cxt->lines[cxt->save_line], 0);
      rl_point = cxt->save_point;
      rl_mark = cxt->save_mark;
      rl_restore_prompt();
      rl_clear_message ();

      return -1;

    case -5:	/* C-W */
      /* skip over portion of line we already matched and yank word */
      wstart = rl_point + cxt->search_string_index;
      if (wstart >= rl_end)
	{
	  rl_ding ();
	  break;
	}

      /* if not in a word, move to one. */
      cval = _rl_char_value (rl_line_buffer, wstart);
      if (_rl_walphabetic (cval) == 0)
	{
	  rl_ding ();
	  break;
	}
      n = MB_NEXTCHAR (rl_line_buffer, wstart, 1, MB_FIND_NONZERO);;
      while (n < rl_end)
	{
	  cval = _rl_char_value (rl_line_buffer, n);
	  if (_rl_walphabetic (cval) == 0)
	    break;
	  n = MB_NEXTCHAR (rl_line_buffer, n, 1, MB_FIND_NONZERO);;
	}
      wlen = n - wstart + 1;
      if (cxt->search_string_index + wlen + 1 >= cxt->search_string_size)
	{
	  cxt->search_string_size += wlen + 1;
	  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	}
      for (; wstart < n; wstart++)
	cxt->search_string[cxt->search_string_index++] = rl_line_buffer[wstart];
      cxt->search_string[cxt->search_string_index] = '\0';
      break;

    case -6:	/* C-Y */
      /* skip over portion of line we already matched and yank rest */
      wstart = rl_point + cxt->search_string_index;
      if (wstart >= rl_end)
	{
	  rl_ding ();
	  break;
	}
      n = rl_end - wstart + 1;
      if (cxt->search_string_index + n + 1 >= cxt->search_string_size)
	{
	  cxt->search_string_size += n + 1;
	  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	}
      for (n = wstart; n < rl_end; n++)
	cxt->search_string[cxt->search_string_index++] = rl_line_buffer[n];
      cxt->search_string[cxt->search_string_index] = '\0';
      break;

    /* Add character to search string and continue search. */
    default:
      if (cxt->search_string_index + 2 >= cxt->search_string_size)
	{
	  cxt->search_string_size += 128;
	  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	}
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  int j, l;
	  for (j = 0, l = strlen (cxt->mb); j < l; )
	    cxt->search_string[cxt->search_string_index++] = cxt->mb[j++];
	}
      else
#endif
	cxt->search_string[cxt->search_string_index++] = c;
      cxt->search_string[cxt->search_string_index] = '\0';
      break;
    }

  for (cxt->sflags &= ~(SF_FOUND|SF_FAILED);; )
    {
      limit = cxt->sline_len - cxt->search_string_index + 1;

      /* Search the current line. */
      while ((cxt->sflags & SF_REVERSE) ? (cxt->sline_index >= 0) : (cxt->sline_index < limit))
	{
	  if (STREQN (cxt->search_string, cxt->sline + cxt->sline_index, cxt->search_string_index))
	    {
	      cxt->sflags |= SF_FOUND;
	      break;
	    }
	  else
	    cxt->sline_index += cxt->direction;
	}
      if (cxt->sflags & SF_FOUND)
	break;

      /* Move to the next line, but skip new copies of the line
	 we just found and lines shorter than the string we're
	 searching for. */
      do
	{
	  /* Move to the next line. */
	  cxt->history_pos += cxt->direction;

	  /* At limit for direction? */
	  if ((cxt->sflags & SF_REVERSE) ? (cxt->history_pos < 0) : (cxt->history_pos == cxt->hlen))
	    {
	      cxt->sflags |= SF_FAILED;
	      break;
	    }

	  /* We will need these later. */
	  cxt->sline = cxt->lines[cxt->history_pos];
	  cxt->sline_len = strlen (cxt->sline);
	}
      while ((cxt->prev_line_found && STREQ (cxt->prev_line_found, cxt->lines[cxt->history_pos])) ||
	     (cxt->search_string_index > cxt->sline_len));

      if (cxt->sflags & SF_FAILED)
	break;

      /* Now set up the line for searching... */
      cxt->sline_index = (cxt->sflags & SF_REVERSE) ? cxt->sline_len - cxt->search_string_index : 0;
    }

  if (cxt->sflags & SF_FAILED)
    {
      /* We cannot find the search string.  Ding the bell. */
      rl_ding ();
      cxt->history_pos = cxt->last_found_line;
      return 1;
    }

  /* We have found the search string.  Just display it.  But don't
     actually move there in the history list until the user accepts
     the location. */
  if (cxt->sflags & SF_FOUND)
    {
      cxt->prev_line_found = cxt->lines[cxt->history_pos];
      rl_replace_line (cxt->lines[cxt->history_pos], 0);
      rl_point = cxt->sline_index;
      cxt->last_found_line = cxt->history_pos;
      rl_display_search (cxt->search_string, (cxt->sflags & SF_REVERSE), (cxt->history_pos == cxt->save_line) ? -1 : cxt->history_pos);
    }

  return 1;
}

static int
_rl_isearch_cleanup (cxt, r)
     _rl_search_cxt *cxt;
     int r;
{
  if (r >= 0)
    _rl_isearch_fini (cxt);
  _rl_scxt_dispose (cxt, 0);
  _rl_iscxt = 0;

  RL_UNSETSTATE(RL_STATE_ISEARCH);

  return (r != 0);
}

/* Search through the history looking for an interactively typed string.
   This is analogous to i-search.  We start the search in the current line.
   DIRECTION is which direction to search; >= 0 means forward, < 0 means
   backwards. */
static int
rl_search_history (direction, invoking_key)
     int direction, invoking_key;
{
  _rl_search_cxt *cxt;		/* local for now, but saved globally */
  int c, r;

  RL_SETSTATE(RL_STATE_ISEARCH);
  cxt = _rl_isearch_init (direction);

  rl_display_search (cxt->search_string, (cxt->sflags & SF_REVERSE), -1);

  /* If we are using the callback interface, all we do is set up here and
      return.  The key is that we leave RL_STATE_ISEARCH set. */
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    return (0);

  r = -1;
  for (;;)
    {
      c = _rl_search_getchar (cxt);
      /* We might want to handle EOF here (c == 0) */
      r = _rl_isearch_dispatch (cxt, cxt->lastc);
      if (r <= 0)
        break;
    }

  /* The searching is over.  The user may have found the string that she
     was looking for, or else she may have exited a failing search.  If
     LINE_INDEX is -1, then that shows that the string searched for was
     not found.  We use this to determine where to place rl_point. */
  return (_rl_isearch_cleanup (cxt, r));
}

#if defined (READLINE_CALLBACKS)
/* Called from the callback functions when we are ready to read a key.  The
   callback functions know to call this because RL_ISSTATE(RL_STATE_ISEARCH).
   If _rl_isearch_dispatch finishes searching, this function is responsible
   for turning off RL_STATE_ISEARCH, which it does using _rl_isearch_cleanup. */
int
_rl_isearch_callback (cxt)
     _rl_search_cxt *cxt;
{
  int c, r;

  c = _rl_search_getchar (cxt);
  /* We might want to handle EOF here */
  r = _rl_isearch_dispatch (cxt, cxt->lastc);

  return (r <= 0) ? _rl_isearch_cleanup (cxt, r) : 0;
}
#endif
@


1.6
log
@Readline 5.1 import for HEAD.
@
text
@d1 2
d9 1
a9 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
d11 2
a12 3
   This file contains the Readline Library (the Library), a set of
   routines for providing Emacs style line input to programs that ask
   for it.
d14 1
a14 1
   The Library is free software; you can redistribute it and/or modify
d16 11
a26 2
   the Free Software Foundation; either version 2, or (at your option)
   any later version.
a27 9
   The Library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   The GNU General Public License is often shipped with GNU software, and
   is generally kept in a file called COPYING or LICENSE.  If you do not
   have a copy of the license, write to the Free Software Foundation,
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
d72 2
a73 2
   identical lines many times in a row. */
static char *prev_line_found;
d79 1
a79 1
static char *default_isearch_terminators = "\033\012";
d107 3
d132 1
a132 1
  free (cxt);
d199 1
a199 1
  free (message);
d334 2
a335 3
 
 /* Translate the keys we do something with to opcodes. */
  if (c >= 0 && _rl_keymap[c].type == ISFUNC)
d337 21
a357 1
      f = _rl_keymap[c].function;
d365 1
a365 1
      else if (c == CTRL ('G'))
d367 1
a367 1
      else if (c == CTRL ('W'))	/* XXX */
d369 1
a369 1
      else if (c == CTRL ('Y'))	/* XXX */
d373 8
d385 1
a385 1
  if (strchr (cxt->search_terminators, cxt->lastc))
d409 1
a409 1
	  /* This sets rl_pending_input to c; it will be picked up the next
@


1.5
log
@touched all sources to ease import of readline-5.1
@
text
@d7 1
a7 1
/* Copyright (C) 1987-2002 Free Software Foundation, Inc.
d59 2
a63 1
/* Forward declarations */
d66 4
d80 51
d151 1
a151 1
   DIRECTION is zero for forward, or 1 for reverse,
d199 3
a201 7
/* Search through the history looking for an interactively typed string.
   This is analogous to i-search.  We start the search in the current line.
   DIRECTION is which direction to search; >= 0 means forward, < 0 means
   backwards. */
static int
rl_search_history (direction, invoking_key)
     int direction, invoking_key;
d203 2
a204 16
  /* The string that the user types in to search for. */
  char *search_string;

  /* The current length of SEARCH_STRING. */
  int search_string_index;

  /* The amount of space that SEARCH_STRING has allocated to it. */
  int search_string_size;

  /* The list of lines to search through. */
  char **lines, *allocated_line;

  /* The length of LINES. */
  int hlen;

  /* Where we get LINES from. */
d207 3
a209 13
  register int i;
  int orig_point, orig_mark, orig_line, last_found_line;
  int c, found, failed, sline_len;
  int n, wstart, wlen;
#if defined (HANDLE_MULTIBYTE)
  char mb[MB_LEN_MAX];
#endif

  /* The line currently being searched. */
  char *sline;

  /* Offset in that line. */
  int line_index;
d211 1
a211 17
  /* Non-zero if we are doing a reverse search. */
  int reverse;

  /* The list of characters which terminate the search, but are not
     subsequently executed.  If the variable isearch-terminators has
     been set, we use that value, otherwise we use ESC and C-J. */
  char *isearch_terminators;

  RL_SETSTATE(RL_STATE_ISEARCH);
  orig_point = rl_point;
  orig_mark = rl_mark;
  last_found_line = orig_line = where_history ();
  reverse = direction < 0;
  hlist = history_list ();
  allocated_line = (char *)NULL;

  isearch_terminators = _rl_isearch_terminators ? _rl_isearch_terminators
d215 1
d223 3
a225 3
  lines = (char **)xmalloc ((1 + (hlen = i)) * sizeof (char *));
  for (i = 0; i < hlen; i++)
    lines[i] = hlist[i]->line;
d228 1
a228 1
    lines[i] = _rl_saved_line_for_history->line;
d232 3
a234 3
      allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));
      strcpy (allocated_line, &rl_line_buffer[0]);
      lines[i] = allocated_line;
d237 1
a237 1
  hlen++;
d240 1
a240 1
  i = orig_line;
d245 2
a246 4
  search_string = (char *)xmalloc (search_string_size = 128);
  *search_string = '\0';
  search_string_index = 0;
  prev_line_found = (char *)0;		/* XXX */
d249 19
a267 1
  direction = (direction >= 0) ? 1 : -1;
d269 5
a273 1
  rl_display_search (search_string, reverse, -1);
d275 4
a278 3
  sline = rl_line_buffer;
  sline_len = strlen (sline);
  line_index = rl_point;
d280 4
a283 2
  found = failed = 0;
  for (;;)
d285 6
a290 1
      rl_command_func_t *f = (rl_command_func_t *)NULL;
d292 17
a308 4
      /* Read a key and decide how to proceed. */
      RL_SETSTATE(RL_STATE_MOREINPUT);
      c = rl_read_key ();
      RL_UNSETSTATE(RL_STATE_MOREINPUT);
d311 2
a312 2
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	c = _rl_read_mbstring (c, mb, MB_LEN_MAX);
d315 34
a348 4
      /* Translate the keys we do something with to opcodes. */
      if (c >= 0 && _rl_keymap[c].type == ISFUNC)
	{
	  f = _rl_keymap[c].function;
d350 19
a368 33
	  if (f == rl_reverse_search_history)
	    c = reverse ? -1 : -2;
	  else if (f == rl_forward_search_history)
	    c =  !reverse ? -1 : -2;
	  else if (f == rl_rubout)
	    c = -3;
	  else if (c == CTRL ('G'))
	    c = -4;
	  else if (c == CTRL ('W'))	/* XXX */
	    c = -5;
	  else if (c == CTRL ('Y'))	/* XXX */
	    c = -6;
	}

      /* The characters in isearch_terminators (set from the user-settable
	 variable isearch-terminators) are used to terminate the search but
	 not subsequently execute the character as a command.  The default
	 value is "\033\012" (ESC and C-J). */
      if (strchr (isearch_terminators, c))
	{
	  /* ESC still terminates the search, but if there is pending
	     input or if input arrives within 0.1 seconds (on systems
	     with select(2)) it is used as a prefix character
	     with rl_execute_next.  WATCH OUT FOR THIS!  This is intended
	     to allow the arrow keys to be used like ^F and ^B are used
	     to terminate the search and execute the movement command.
	     XXX - since _rl_input_available depends on the application-
	     settable keyboard timeout value, this could alternatively
	     use _rl_input_queued(100000) */
	  if (c == ESC && _rl_input_available ())
	    rl_execute_next (ESC);
	  break;
	}
d374 27
a400 1
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
d402 1
a402 1
	  if (c >= 0 && strlen (mb) == 1 && ENDSRCH_CHAR (c))
d404 5
a408 3
	      /* This sets rl_pending_input to c; it will be picked up the next
		 time rl_read_key is called. */
	      rl_execute_next (c);
d411 1
d413 13
d427 28
a454 2
#endif
      if (c >= 0 && ENDSRCH_CHAR (c))
d456 1
a456 3
	  /* This sets rl_pending_input to c; it will be picked up the next
	     time rl_read_key is called. */
	  rl_execute_next (c);
d460 3
a462 1
      switch (c)
d464 1
a464 20
	case -1:
	  if (search_string_index == 0)
	    {
	      if (last_isearch_string)
		{
		  search_string_size = 64 + last_isearch_string_len;
		  search_string = (char *)xrealloc (search_string, search_string_size);
		  strcpy (search_string, last_isearch_string);
		  search_string_index = last_isearch_string_len;
		  rl_display_search (search_string, reverse, -1);
		  break;
		}
	      continue;
	    }
	  else if (reverse)
	    --line_index;
	  else if (line_index != sline_len)
	    ++line_index;
	  else
	    rl_ding ();
d466 26
a491 5

	  /* switch directions */
	case -2:
	  direction = -direction;
	  reverse = direction < 0;
d493 32
d526 3
a528 10
	/* delete character from search string. */
	case -3:	/* C-H, DEL */
	  /* This is tricky.  To do this right, we need to keep a
	     stack of search positions for the current search, with
	     sentinels marking the beginning and end.  But this will
	     do until we have a real isearch-undo. */
	  if (search_string_index == 0)
	    rl_ding ();
	  else
	    search_string[--search_string_index] = '\0';
d530 4
a533 18
	  break;

	case -4:	/* C-G */
	  rl_replace_line (lines[orig_line], 0);
	  rl_point = orig_point;
	  rl_mark = orig_mark;
	  rl_restore_prompt();
	  rl_clear_message ();
	  if (allocated_line)
	    free (allocated_line);
	  free (lines);
	  RL_UNSETSTATE(RL_STATE_ISEARCH);
	  return 0;

	case -5:	/* C-W */
	  /* skip over portion of line we already matched */
	  wstart = rl_point + search_string_index;
	  if (wstart >= rl_end)
d535 1
a535 1
	      rl_ding ();
d538 5
d544 7
a550 19
	  /* if not in a word, move to one. */
	  if (rl_alphabetic(rl_line_buffer[wstart]) == 0)
	    {
	      rl_ding ();
	      break;
	    }
	  n = wstart;
	  while (n < rl_end && rl_alphabetic(rl_line_buffer[n]))
	    n++;
	  wlen = n - wstart + 1;
	  if (search_string_index + wlen + 1 >= search_string_size)
	    {
	      search_string_size += wlen + 1;
	      search_string = (char *)xrealloc (search_string, search_string_size);
	    }
	  for (; wstart < n; wstart++)
	    search_string[search_string_index++] = rl_line_buffer[wstart];
	  search_string[search_string_index] = '\0';
	  break;
d552 2
a553 4
	case -6:	/* C-Y */
	  /* skip over portion of line we already matched */
	  wstart = rl_point + search_string_index;
	  if (wstart >= rl_end)
d555 1
a555 1
	      rl_ding ();
a557 10
	  n = rl_end - wstart + 1;
	  if (search_string_index + n + 1 >= search_string_size)
	    {
	      search_string_size += n + 1;
	      search_string = (char *)xrealloc (search_string, search_string_size);
	    }
	  for (n = wstart; n < rl_end; n++)
	    search_string[search_string_index++] = rl_line_buffer[n];
	  search_string[search_string_index] = '\0';
	  break;
d559 3
a561 19
	default:
	  /* Add character to search string and continue search. */
	  if (search_string_index + 2 >= search_string_size)
	    {
	      search_string_size += 128;
	      search_string = (char *)xrealloc (search_string, search_string_size);
	    }
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      int j, l;
	      for (j = 0, l = strlen (mb); j < l; )
		search_string[search_string_index++] = mb[j++];
	    }
	  else
#endif
	    search_string[search_string_index++] = c;
	  search_string[search_string_index] = '\0';
	  break;
d563 2
d566 2
a567 3
      for (found = failed = 0;;)
	{
	  int limit = sline_len - search_string_index + 1;
d569 3
a571 13
	  /* Search the current line. */
	  while (reverse ? (line_index >= 0) : (line_index < limit))
	    {
	      if (STREQN (search_string, sline + line_index, search_string_index))
		{
		  found++;
		  break;
		}
	      else
		line_index += direction;
	    }
	  if (found)
	    break;
d573 7
a579 7
	  /* Move to the next line, but skip new copies of the line
	     we just found and lines shorter than the string we're
	     searching for. */
	  do
	    {
	      /* Move to the next line. */
	      i += direction;
d581 11
a591 13
	      /* At limit for direction? */
	      if (reverse ? (i < 0) : (i == hlen))
		{
		  failed++;
		  break;
		}

	      /* We will need these later. */
	      sline = lines[i];
	      sline_len = strlen (sline);
	    }
	  while ((prev_line_found && STREQ (prev_line_found, lines[i])) ||
		 (search_string_index > sline_len));
d593 2
a594 2
	  if (failed)
	    break;
d596 9
a604 3
	  /* Now set up the line for searching... */
	  line_index = reverse ? sline_len - search_string_index : 0;
	}
d606 1
a606 7
      if (failed)
	{
	  /* We cannot find the search string.  Ding the bell. */
	  rl_ding ();
	  i = last_found_line;
	  continue; 		/* XXX - was break */
	}
d608 2
a609 12
      /* We have found the search string.  Just display it.  But don't
	 actually move there in the history list until the user accepts
	 the location. */
      if (found)
	{
	  prev_line_found = lines[i];
	  rl_replace_line (lines[i], 0);
	  rl_point = line_index;
	  last_found_line = i;
	  rl_display_search (search_string, reverse, (i == orig_line) ? -1 : i);
	}
    }
d611 10
a620 4
  /* The searching is over.  The user may have found the string that she
     was looking for, or else she may have exited a failing search.  If
     LINE_INDEX is -1, then that shows that the string searched for was
     not found.  We use this to determine where to place rl_point. */
d622 2
a623 2
  /* First put back the original state. */
  strcpy (rl_line_buffer, lines[orig_line]);
d625 1
a625 1
  rl_restore_prompt ();
d627 4
a630 4
  /* Save the search string for possible later use. */
  FREE (last_isearch_string);
  last_isearch_string = search_string;
  last_isearch_string_len = search_string_index;
d632 2
a633 9
  if (last_found_line < orig_line)
    rl_get_previous_history (orig_line - last_found_line, 0);
  else
    rl_get_next_history (last_found_line - orig_line, 0);

  /* If the string was not found, put point at the end of the last matching
     line.  If last_found_line == orig_line, we didn't find any matching
     history lines at all, so put point back in its original position. */
  if (line_index < 0)
d635 5
a639 5
      if (last_found_line == orig_line)
	line_index = orig_point;
      else
	line_index = strlen (rl_line_buffer);
      rl_mark = orig_mark;
d642 6
a647 3
  rl_point = line_index;
  /* Don't worry about where to put the mark here; rl_get_previous_history
     and rl_get_next_history take care of it. */
d649 10
a658 1
  rl_clear_message ();
d660 3
a662 2
  FREE (allocated_line);
  free (lines);
d664 1
a664 3
  RL_UNSETSTATE(RL_STATE_ISEARCH);

  return 0;
d666 1
@


1.5.2.1
log
@Import readline 5.1 on the branch.
@
text
@d7 1
a7 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
a58 2
_rl_search_cxt *_rl_iscxt = 0;

d62 1
a64 4
static _rl_search_cxt *_rl_isearch_init PARAMS((int));
static void _rl_isearch_fini PARAMS((_rl_search_cxt *));
static int _rl_isearch_cleanup PARAMS((_rl_search_cxt *, int));

a74 51
_rl_search_cxt *
_rl_scxt_alloc (type, flags)
     int type, flags;
{
  _rl_search_cxt *cxt;

  cxt = (_rl_search_cxt *)xmalloc (sizeof (_rl_search_cxt));

  cxt->type = type;
  cxt->sflags = flags;

  cxt->search_string = 0;
  cxt->search_string_size = cxt->search_string_index = 0;

  cxt->lines = 0;
  cxt->allocated_line = 0;
  cxt->hlen = cxt->hindex = 0;

  cxt->save_point = rl_point;
  cxt->save_mark = rl_mark;
  cxt->save_line = where_history ();
  cxt->last_found_line = cxt->save_line;
  cxt->prev_line_found = 0;

  cxt->save_undo_list = 0;

  cxt->history_pos = 0;
  cxt->direction = 0;

  cxt->lastc = 0;

  cxt->sline = 0;
  cxt->sline_len = cxt->sline_index = 0;

  cxt->search_terminators = 0;

  return cxt;
}

void
_rl_scxt_dispose (cxt, flags)
     _rl_search_cxt *cxt;
     int flags;
{
  FREE (cxt->search_string);
  FREE (cxt->allocated_line);
  FREE (cxt->lines);

  free (cxt);
}

d95 1
a95 1
   DIRECTION is zero for forward, or non-zero for reverse,
d143 7
a149 3
static _rl_search_cxt *
_rl_isearch_init (direction)
     int direction;
d151 18
a168 1
  _rl_search_cxt *cxt;
d170 15
a184 1
  HIST_ENTRY **hlist;
d186 4
a189 3
  cxt = _rl_scxt_alloc (RL_SEARCH_ISEARCH, 0);
  if (direction < 0)
    cxt->sflags |= SF_REVERSE;
d191 9
a199 1
  cxt->search_terminators = _rl_isearch_terminators ? _rl_isearch_terminators
a202 1
  hlist = history_list ();
d210 3
a212 3
  cxt->lines = (char **)xmalloc ((1 + (cxt->hlen = i)) * sizeof (char *));
  for (i = 0; i < cxt->hlen; i++)
    cxt->lines[i] = hlist[i]->line;
d215 1
a215 1
    cxt->lines[i] = _rl_saved_line_for_history->line;
d219 3
a221 3
      cxt->allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));
      strcpy (cxt->allocated_line, &rl_line_buffer[0]);
      cxt->lines[i] = cxt->allocated_line;
d224 1
a224 1
  cxt->hlen++;
d227 1
a227 1
  cxt->history_pos = cxt->save_line;
d232 4
a235 2
  cxt->search_string = (char *)xmalloc (cxt->search_string_size = 128);
  cxt->search_string[cxt->search_string_index = 0] = '\0';
d238 1
a238 1
  cxt->direction = (direction >= 0) ? 1 : -1;
d240 1
a240 3
  cxt->sline = rl_line_buffer;
  cxt->sline_len = strlen (cxt->sline);
  cxt->sline_index = rl_point;
d242 3
a244 1
  _rl_iscxt = cxt;		/* save globally */
d246 2
a247 27
  return cxt;
}

static void
_rl_isearch_fini (cxt)
     _rl_search_cxt *cxt;
{
  /* First put back the original state. */
  strcpy (rl_line_buffer, cxt->lines[cxt->save_line]);

  rl_restore_prompt ();

  /* Save the search string for possible later use. */
  FREE (last_isearch_string);
  last_isearch_string = cxt->search_string;
  last_isearch_string_len = cxt->search_string_index;
  cxt->search_string = 0;

  if (cxt->last_found_line < cxt->save_line)
    rl_get_previous_history (cxt->save_line - cxt->last_found_line, 0);
  else
    rl_get_next_history (cxt->last_found_line - cxt->save_line, 0);

  /* If the string was not found, put point at the end of the last matching
     line.  If last_found_line == orig_line, we didn't find any matching
     history lines at all, so put point back in its original position. */
  if (cxt->sline_index < 0)
d249 1
a249 6
      if (cxt->last_found_line == cxt->save_line)
	cxt->sline_index = cxt->save_point;
      else
	cxt->sline_index = strlen (rl_line_buffer);
      rl_mark = cxt->save_mark;
    }
d251 4
a254 17
  rl_point = cxt->sline_index;
  /* Don't worry about where to put the mark here; rl_get_previous_history
     and rl_get_next_history take care of it. */

  rl_clear_message ();
}

int
_rl_search_getchar (cxt)
     _rl_search_cxt *cxt;
{
  int c;

  /* Read a key and decide how to proceed. */
  RL_SETSTATE(RL_STATE_MOREINPUT);
  c = cxt->lastc = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);
d257 2
a258 2
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    c = cxt->lastc = _rl_read_mbstring (cxt->lastc, cxt->mb, MB_LEN_MAX);
d261 4
a264 2
  return c;
}
d266 33
a298 51
/* Process just-read character C according to isearch context CXT.  Return
   -1 if the caller should just free the context and return, 0 if we should
   break out of the loop, and 1 if we should continue to read characters. */
int
_rl_isearch_dispatch (cxt, c)
     _rl_search_cxt *cxt;
     int c;
{
  int n, wstart, wlen, limit, cval;
  rl_command_func_t *f;

  f = (rl_command_func_t *)NULL;
 
 /* Translate the keys we do something with to opcodes. */
  if (c >= 0 && _rl_keymap[c].type == ISFUNC)
    {
      f = _rl_keymap[c].function;

      if (f == rl_reverse_search_history)
	cxt->lastc = (cxt->sflags & SF_REVERSE) ? -1 : -2;
      else if (f == rl_forward_search_history)
	cxt->lastc = (cxt->sflags & SF_REVERSE) ? -2 : -1;
      else if (f == rl_rubout)
	cxt->lastc = -3;
      else if (c == CTRL ('G'))
	cxt->lastc = -4;
      else if (c == CTRL ('W'))	/* XXX */
	cxt->lastc = -5;
      else if (c == CTRL ('Y'))	/* XXX */
	cxt->lastc = -6;
    }

  /* The characters in isearch_terminators (set from the user-settable
     variable isearch-terminators) are used to terminate the search but
     not subsequently execute the character as a command.  The default
     value is "\033\012" (ESC and C-J). */
  if (strchr (cxt->search_terminators, cxt->lastc))
    {
      /* ESC still terminates the search, but if there is pending
	 input or if input arrives within 0.1 seconds (on systems
	 with select(2)) it is used as a prefix character
	 with rl_execute_next.  WATCH OUT FOR THIS!  This is intended
	 to allow the arrow keys to be used like ^F and ^B are used
	 to terminate the search and execute the movement command.
	 XXX - since _rl_input_available depends on the application-
	 settable keyboard timeout value, this could alternatively
	 use _rl_input_queued(100000) */
      if (cxt->lastc == ESC && _rl_input_available ())
	rl_execute_next (ESC);
      return (0);
    }
d304 1
a304 3
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      if (cxt->lastc >= 0 && (cxt->mb[0] && cxt->mb[1] == '\0') && ENDSRCH_CHAR (cxt->lastc))
d306 1
a306 25
	  /* This sets rl_pending_input to c; it will be picked up the next
	     time rl_read_key is called. */
	  rl_execute_next (cxt->lastc);
	  return (0);
	}
    }
  else
#endif
    if (cxt->lastc >= 0 && ENDSRCH_CHAR (cxt->lastc))
      {
	/* This sets rl_pending_input to LASTC; it will be picked up the next
	   time rl_read_key is called. */
	rl_execute_next (cxt->lastc);
	return (0);
      }

  /* Now dispatch on the character.  `Opcodes' affect the search string or
     state.  Other characters are added to the string.  */
  switch (cxt->lastc)
    {
    /* search again */
    case -1:
      if (cxt->search_string_index == 0)
	{
	  if (last_isearch_string)
d308 3
a310 5
	      cxt->search_string_size = 64 + last_isearch_string_len;
	      cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	      strcpy (cxt->search_string, last_isearch_string);
	      cxt->search_string_index = last_isearch_string_len;
	      rl_display_search (cxt->search_string, (cxt->sflags & SF_REVERSE), -1);
a312 1
	  return (1);
a313 4
      else if (cxt->sflags & SF_REVERSE)
	cxt->sline_index--;
      else if (cxt->sline_index != cxt->sline_len)
	cxt->sline_index++;
d315 2
a316 37
	rl_ding ();
      break;

    /* switch directions */
    case -2:
      cxt->direction = -cxt->direction;
      if (cxt->direction < 0)
	cxt->sflags |= SF_REVERSE;
      else
	cxt->sflags &= ~SF_REVERSE;
      break;

    /* delete character from search string. */
    case -3:	/* C-H, DEL */
      /* This is tricky.  To do this right, we need to keep a
	 stack of search positions for the current search, with
	 sentinels marking the beginning and end.  But this will
	 do until we have a real isearch-undo. */
      if (cxt->search_string_index == 0)
	rl_ding ();
      else
	cxt->search_string[--cxt->search_string_index] = '\0';
      break;

    case -4:	/* C-G, abort */
      rl_replace_line (cxt->lines[cxt->save_line], 0);
      rl_point = cxt->save_point;
      rl_mark = cxt->save_mark;
      rl_restore_prompt();
      rl_clear_message ();

      return -1;

    case -5:	/* C-W */
      /* skip over portion of line we already matched and yank word */
      wstart = rl_point + cxt->search_string_index;
      if (wstart >= rl_end)
d318 3
a320 1
	  rl_ding ();
d324 1
a324 3
      /* if not in a word, move to one. */
      cval = _rl_char_value (rl_line_buffer, wstart);
      if (_rl_walphabetic (cval) == 0)
d326 20
a345 1
	  rl_ding ();
d347 5
a351 26
	}
      n = MB_NEXTCHAR (rl_line_buffer, wstart, 1, MB_FIND_NONZERO);;
      while (n < rl_end)
	{
	  cval = _rl_char_value (rl_line_buffer, n);
	  if (_rl_walphabetic (cval) == 0)
	    break;
	  n = MB_NEXTCHAR (rl_line_buffer, n, 1, MB_FIND_NONZERO);;
	}
      wlen = n - wstart + 1;
      if (cxt->search_string_index + wlen + 1 >= cxt->search_string_size)
	{
	  cxt->search_string_size += wlen + 1;
	  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	}
      for (; wstart < n; wstart++)
	cxt->search_string[cxt->search_string_index++] = rl_line_buffer[wstart];
      cxt->search_string[cxt->search_string_index] = '\0';
      break;

    case -6:	/* C-Y */
      /* skip over portion of line we already matched and yank rest */
      wstart = rl_point + cxt->search_string_index;
      if (wstart >= rl_end)
	{
	  rl_ding ();
a352 32
	}
      n = rl_end - wstart + 1;
      if (cxt->search_string_index + n + 1 >= cxt->search_string_size)
	{
	  cxt->search_string_size += n + 1;
	  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	}
      for (n = wstart; n < rl_end; n++)
	cxt->search_string[cxt->search_string_index++] = rl_line_buffer[n];
      cxt->search_string[cxt->search_string_index] = '\0';
      break;

    /* Add character to search string and continue search. */
    default:
      if (cxt->search_string_index + 2 >= cxt->search_string_size)
	{
	  cxt->search_string_size += 128;
	  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	}
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  int j, l;
	  for (j = 0, l = strlen (cxt->mb); j < l; )
	    cxt->search_string[cxt->search_string_index++] = cxt->mb[j++];
	}
      else
#endif
	cxt->search_string[cxt->search_string_index++] = c;
      cxt->search_string[cxt->search_string_index] = '\0';
      break;
    }
d354 12
a365 3
  for (cxt->sflags &= ~(SF_FOUND|SF_FAILED);; )
    {
      limit = cxt->sline_len - cxt->search_string_index + 1;
d367 16
a382 4
      /* Search the current line. */
      while ((cxt->sflags & SF_REVERSE) ? (cxt->sline_index >= 0) : (cxt->sline_index < limit))
	{
	  if (STREQN (cxt->search_string, cxt->sline + cxt->sline_index, cxt->search_string_index))
d384 1
a384 1
	      cxt->sflags |= SF_FOUND;
a386 5
	  else
	    cxt->sline_index += cxt->direction;
	}
      if (cxt->sflags & SF_FOUND)
	break;
d388 19
a406 7
      /* Move to the next line, but skip new copies of the line
	 we just found and lines shorter than the string we're
	 searching for. */
      do
	{
	  /* Move to the next line. */
	  cxt->history_pos += cxt->direction;
d408 4
a411 2
	  /* At limit for direction? */
	  if ((cxt->sflags & SF_REVERSE) ? (cxt->history_pos < 0) : (cxt->history_pos == cxt->hlen))
d413 1
a413 1
	      cxt->sflags |= SF_FAILED;
d416 10
d427 19
a445 3
	  /* We will need these later. */
	  cxt->sline = cxt->lines[cxt->history_pos];
	  cxt->sline_len = strlen (cxt->sline);
a446 2
      while ((cxt->prev_line_found && STREQ (cxt->prev_line_found, cxt->lines[cxt->history_pos])) ||
	     (cxt->search_string_index > cxt->sline_len));
d448 3
a450 2
      if (cxt->sflags & SF_FAILED)
	break;
d452 21
a472 3
      /* Now set up the line for searching... */
      cxt->sline_index = (cxt->sflags & SF_REVERSE) ? cxt->sline_len - cxt->search_string_index : 0;
    }
d474 13
a486 7
  if (cxt->sflags & SF_FAILED)
    {
      /* We cannot find the search string.  Ding the bell. */
      rl_ding ();
      cxt->history_pos = cxt->last_found_line;
      return 1;
    }
d488 2
a489 11
  /* We have found the search string.  Just display it.  But don't
     actually move there in the history list until the user accepts
     the location. */
  if (cxt->sflags & SF_FOUND)
    {
      cxt->prev_line_found = cxt->lines[cxt->history_pos];
      rl_replace_line (cxt->lines[cxt->history_pos], 0);
      rl_point = cxt->sline_index;
      cxt->last_found_line = cxt->history_pos;
      rl_display_search (cxt->search_string, (cxt->sflags & SF_REVERSE), (cxt->history_pos == cxt->save_line) ? -1 : cxt->history_pos);
    }
d491 3
a493 2
  return 1;
}
d495 7
a501 9
static int
_rl_isearch_cleanup (cxt, r)
     _rl_search_cxt *cxt;
     int r;
{
  if (r >= 0)
    _rl_isearch_fini (cxt);
  _rl_scxt_dispose (cxt, 0);
  _rl_iscxt = 0;
d503 12
a514 1
  RL_UNSETSTATE(RL_STATE_ISEARCH);
d516 4
a519 2
  return (r != 0);
}
d521 2
a522 10
/* Search through the history looking for an interactively typed string.
   This is analogous to i-search.  We start the search in the current line.
   DIRECTION is which direction to search; >= 0 means forward, < 0 means
   backwards. */
static int
rl_search_history (direction, invoking_key)
     int direction, invoking_key;
{
  _rl_search_cxt *cxt;		/* local for now, but saved globally */
  int c, r;
d524 1
a524 2
  RL_SETSTATE(RL_STATE_ISEARCH);
  cxt = _rl_isearch_init (direction);
d526 4
a529 1
  rl_display_search (cxt->search_string, (cxt->sflags & SF_REVERSE), -1);
d531 4
a534 4
  /* If we are using the callback interface, all we do is set up here and
      return.  The key is that we leave RL_STATE_ISEARCH set. */
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    return (0);
d536 4
a539 2
  r = -1;
  for (;;)
d541 5
a545 5
      c = _rl_search_getchar (cxt);
      /* We might want to handle EOF here (c == 0) */
      r = _rl_isearch_dispatch (cxt, cxt->lastc);
      if (r <= 0)
        break;
d548 5
a552 6
  /* The searching is over.  The user may have found the string that she
     was looking for, or else she may have exited a failing search.  If
     LINE_INDEX is -1, then that shows that the string searched for was
     not found.  We use this to determine where to place rl_point. */
  return (_rl_isearch_cleanup (cxt, r));
}
d554 2
a555 10
#if defined (READLINE_CALLBACKS)
/* Called from the callback functions when we are ready to read a key.  The
   callback functions know to call this because RL_ISSTATE(RL_STATE_ISEARCH).
   If _rl_isearch_dispatch finishes searching, this function is responsible
   for turning off RL_STATE_ISEARCH, which it does using _rl_isearch_cleanup. */
int
_rl_isearch_callback (cxt)
     _rl_search_cxt *cxt;
{
  int c, r;
d557 1
a557 3
  c = _rl_search_getchar (cxt);
  /* We might want to handle EOF here */
  r = _rl_isearch_dispatch (cxt, cxt->lastc);
d559 1
a559 1
  return (r <= 0) ? _rl_isearch_cleanup (cxt, r) : 0;
a560 1
#endif
@


1.4
log
@Import of readline 4.3.
Non-readline modified files:

src/gdb/ChangeLog src/gdb/defs.h src/gdb/cli/cli-cmds.c
src/gdb/cli/cli-setshow.c src/gdb/tui/ChangeLog
src/gdb/tui/tuiWin.c

In readline directory:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@@


1.3
log
@readline:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Locally modified files: Makefile.in, configure.in, configure
        (regenerated), config.h.in (regenerated), readline.h, rltty.c,
 	shell.c signals.c.

        Locally added files: acconfig.h, config/*, config.h.bot,
        cross-build/*, doc/inc-hit.texinfo.

        New files: USAGE, rlprivate.h, rlshell.h, xmalloc.h.
examples:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        New files: excallback.c, rlfe.c.
doc:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Regenerated inc-hist.texinfo as copy of hsuser.texinfo, for
        inclusion in the gdb manual.

        New file: rluserman.texinfo
@
text
@d7 1
a7 1
/* Copyright (C) 1987,1989 Free Software Foundation, Inc.
d48 2
d57 1
a57 1
unsigned char *_rl_isearch_terminators = (unsigned char *)NULL;
d60 1
a60 1
extern HIST_ENTRY *saved_line_for_history;
d63 1
a63 1
static int rl_search_history __P((int, int));
d69 6
d108 1
a108 1
  message = xmalloc (searchlen + 33);
d138 1
a138 1
  rl_message ("%s", message, 0);
d170 1
a170 1
  int orig_point, orig_line, last_found_line;
d172 4
d189 1
a189 1
  unsigned char *isearch_terminators;
d191 1
d193 1
d200 1
a200 1
						: (unsigned char *)"\033\012";
d203 1
a203 1
  maybe_replace_line ();
d214 2
a215 2
  if (saved_line_for_history)
    lines[i] = saved_line_for_history->line;
d219 1
a219 1
      allocated_line = xmalloc (1 + strlen (rl_line_buffer));
d232 1
a232 1
  search_string = xmalloc (search_string_size = 128);
d249 1
a249 1
      Function *f = (Function *)NULL;
d252 1
d254 1
d256 7
a262 1
      if (_rl_keymap[c].type == ISFUNC)
d270 8
a279 6
#if 0
      /* Let NEWLINE (^J) terminate the search for people who don't like
	 using ESC.  ^M can still be used to terminate the search and
	 immediately execute the command. */
      if (c == ESC || c == NEWLINE)
#else
a284 1
#endif
d291 5
a295 2
	     to terminate the search and execute the movement command. */
	  if (c == ESC && _rl_input_available ())	/* XXX */
d300 17
a316 1
      if (c >= 0 && (CTRL_CHAR (c) || META_CHAR (c) || c == RUBOUT) && c != CTRL ('G'))
d318 2
d328 12
a339 1
	    continue;
d345 1
a345 1
	    ding ();
d354 15
a368 2
	case CTRL ('G'):
	  strcpy (rl_line_buffer, lines[orig_line]);
d370 1
a370 1
	  rl_end = strlen (rl_line_buffer);
d376 1
d379 39
a417 6
#if 0
	/* delete character from search string. */
	case -3:
	  if (search_string_index == 0)
	    ding ();
	  else
d419 2
a420 4
	      search_string[--search_string_index] = '\0';
	      /* This is tricky.  To do this right, we need to keep a
		 stack of search positions for the current search, with
		 sentinels marking the beginning and end. */
d422 3
a425 1
#endif
d432 8
a439 1
	      search_string = xrealloc (search_string, search_string_size);
d441 3
a443 1
	  search_string[search_string_index++] = c;
d498 1
a498 1
	  ding ();
a507 2
	  int line_len;

d509 1
a509 6
	  line_len = strlen (lines[i]);

	  if (line_len >= rl_line_buffer_len)
	    rl_extend_line_buffer (line_len);

	  strcpy (rl_line_buffer, lines[i]);
a510 1
	  rl_end = line_len;
d526 4
a529 2
  /* Free the search string. */
  free (search_string);
d536 3
a538 1
  /* If the string was not found, put point at the end of the line. */
d540 8
a547 1
    line_index = strlen (rl_line_buffer);
d549 3
d554 1
a554 2
  if (allocated_line)
    free (allocated_line);
d556 2
@


1.3.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d7 1
a7 1
/* Copyright (C) 1987-2002 Free Software Foundation, Inc.
a47 2
#include "rlmbutil.h"

d55 1
a55 1
char *_rl_isearch_terminators = (char *)NULL;
d58 1
a58 1
extern HIST_ENTRY *_rl_saved_line_for_history;
d61 1
a61 1
static int rl_search_history PARAMS((int, int));
a66 6
/* Last search string and its length. */
static char *last_isearch_string;
static int last_isearch_string_len;

static char *default_isearch_terminators = "\033\012";

d100 1
a100 1
  message = (char *)xmalloc (searchlen + 33);
d130 1
a130 1
  rl_message ("%s", message);
d162 1
a162 1
  int orig_point, orig_mark, orig_line, last_found_line;
a163 4
  int n, wstart, wlen;
#if defined (HANDLE_MULTIBYTE)
  char mb[MB_LEN_MAX];
#endif
d177 1
a177 1
  char *isearch_terminators;
a178 1
  RL_SETSTATE(RL_STATE_ISEARCH);
a179 1
  orig_mark = rl_mark;
d186 1
a186 1
						: default_isearch_terminators;
d189 1
a189 1
  rl_maybe_replace_line ();
d200 2
a201 2
  if (_rl_saved_line_for_history)
    lines[i] = _rl_saved_line_for_history->line;
d205 1
a205 1
      allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));
d218 1
a218 1
  search_string = (char *)xmalloc (search_string_size = 128);
d235 1
a235 1
      rl_command_func_t *f = (rl_command_func_t *)NULL;
a237 1
      RL_SETSTATE(RL_STATE_MOREINPUT);
a238 1
      RL_UNSETSTATE(RL_STATE_MOREINPUT);
d240 1
a240 7
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	c = _rl_read_mbstring (c, mb, MB_LEN_MAX);
#endif

      /* Translate the keys we do something with to opcodes. */
      if (c >= 0 && _rl_keymap[c].type == ISFUNC)
a247 8
	  else if (f == rl_rubout)
	    c = -3;
	  else if (c == CTRL ('G'))
	    c = -4;
	  else if (c == CTRL ('W'))	/* XXX */
	    c = -5;
	  else if (c == CTRL ('Y'))	/* XXX */
	    c = -6;
d250 6
d261 1
d268 2
a269 5
	     to terminate the search and execute the movement command.
	     XXX - since _rl_input_available depends on the application-
	     settable keyboard timeout value, this could alternatively
	     use _rl_input_queued(100000) */
	  if (c == ESC && _rl_input_available ())
d274 1
a274 17
#define ENDSRCH_CHAR(c) \
  ((CTRL_CHAR (c) || META_CHAR (c) || (c) == RUBOUT) && ((c) != CTRL ('G')))

#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  if (c >= 0 && strlen (mb) == 1 && ENDSRCH_CHAR (c))
	    {
	      /* This sets rl_pending_input to c; it will be picked up the next
		 time rl_read_key is called. */
	      rl_execute_next (c);
	      break;
	    }
	}
      else
#endif
      if (c >= 0 && ENDSRCH_CHAR (c))
a275 2
	  /* This sets rl_pending_input to c; it will be picked up the next
	     time rl_read_key is called. */
d284 1
a284 12
	    {
	      if (last_isearch_string)
		{
		  search_string_size = 64 + last_isearch_string_len;
		  search_string = (char *)xrealloc (search_string, search_string_size);
		  strcpy (search_string, last_isearch_string);
		  search_string_index = last_isearch_string_len;
		  rl_display_search (search_string, reverse, -1);
		  break;
		}
	      continue;
	    }
d290 1
a290 1
	    rl_ding ();
d299 2
a300 15
	/* delete character from search string. */
	case -3:	/* C-H, DEL */
	  /* This is tricky.  To do this right, we need to keep a
	     stack of search positions for the current search, with
	     sentinels marking the beginning and end.  But this will
	     do until we have a real isearch-undo. */
	  if (search_string_index == 0)
	    rl_ding ();
	  else
	    search_string[--search_string_index] = '\0';

	  break;

	case -4:	/* C-G */
	  rl_replace_line (lines[orig_line], 0);
d302 1
a302 1
	  rl_mark = orig_mark;
a307 1
	  RL_UNSETSTATE(RL_STATE_ISEARCH);
d310 6
a315 11
	case -5:	/* C-W */
	  /* skip over portion of line we already matched */
	  wstart = rl_point + search_string_index;
	  if (wstart >= rl_end)
	    {
	      rl_ding ();
	      break;
	    }

	  /* if not in a word, move to one. */
	  if (rl_alphabetic(rl_line_buffer[wstart]) == 0)
d317 4
a320 2
	      rl_ding ();
	      break;
a321 31
	  n = wstart;
	  while (n < rl_end && rl_alphabetic(rl_line_buffer[n]))
	    n++;
	  wlen = n - wstart + 1;
	  if (search_string_index + wlen + 1 >= search_string_size)
	    {
	      search_string_size += wlen + 1;
	      search_string = (char *)xrealloc (search_string, search_string_size);
	    }
	  for (; wstart < n; wstart++)
	    search_string[search_string_index++] = rl_line_buffer[wstart];
	  search_string[search_string_index] = '\0';
	  break;

	case -6:	/* C-Y */
	  /* skip over portion of line we already matched */
	  wstart = rl_point + search_string_index;
	  if (wstart >= rl_end)
	    {
	      rl_ding ();
	      break;
	    }
	  n = rl_end - wstart + 1;
	  if (search_string_index + n + 1 >= search_string_size)
	    {
	      search_string_size += n + 1;
	      search_string = (char *)xrealloc (search_string, search_string_size);
	    }
	  for (n = wstart; n < rl_end; n++)
	    search_string[search_string_index++] = rl_line_buffer[n];
	  search_string[search_string_index] = '\0';
d323 1
d330 1
a330 8
	      search_string = (char *)xrealloc (search_string, search_string_size);
	    }
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      int j, l;
	      for (j = 0, l = strlen (mb); j < l; )
		search_string[search_string_index++] = mb[j++];
d332 1
a332 3
	  else
#endif
	    search_string[search_string_index++] = c;
d387 1
a387 1
	  rl_ding ();
d397 2
d400 6
a405 1
	  rl_replace_line (lines[i], 0);
d407 1
d423 2
a424 4
  /* Save the search string for possible later use. */
  FREE (last_isearch_string);
  last_isearch_string = search_string;
  last_isearch_string_len = search_string_index;
d431 1
a431 3
  /* If the string was not found, put point at the end of the last matching
     line.  If last_found_line == orig_line, we didn't find any matching
     history lines at all, so put point back in its original position. */
d433 1
a433 8
    {
      if (last_found_line == orig_line)
	line_index = orig_point;
      else
	line_index = strlen (rl_line_buffer);
      rl_mark = orig_mark;
    }

a434 3
  /* Don't worry about where to put the mark here; rl_get_previous_history
     and rl_get_next_history take care of it. */

d437 2
a438 1
  FREE (allocated_line);
a439 2

  RL_UNSETSTATE(RL_STATE_ISEARCH);
@


1.3.22.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d7 1
a7 1
/* Copyright (C) 1987-2002 Free Software Foundation, Inc.
a47 2
#include "rlmbutil.h"

d55 1
a55 1
char *_rl_isearch_terminators = (char *)NULL;
d58 1
a58 1
extern HIST_ENTRY *_rl_saved_line_for_history;
d61 1
a61 1
static int rl_search_history PARAMS((int, int));
a66 6
/* Last search string and its length. */
static char *last_isearch_string;
static int last_isearch_string_len;

static char *default_isearch_terminators = "\033\012";

d100 1
a100 1
  message = (char *)xmalloc (searchlen + 33);
d130 1
a130 1
  rl_message ("%s", message);
d162 1
a162 1
  int orig_point, orig_mark, orig_line, last_found_line;
a163 4
  int n, wstart, wlen;
#if defined (HANDLE_MULTIBYTE)
  char mb[MB_LEN_MAX];
#endif
d177 1
a177 1
  char *isearch_terminators;
a178 1
  RL_SETSTATE(RL_STATE_ISEARCH);
a179 1
  orig_mark = rl_mark;
d186 1
a186 1
						: default_isearch_terminators;
d189 1
a189 1
  rl_maybe_replace_line ();
d200 2
a201 2
  if (_rl_saved_line_for_history)
    lines[i] = _rl_saved_line_for_history->line;
d205 1
a205 1
      allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));
d218 1
a218 1
  search_string = (char *)xmalloc (search_string_size = 128);
d235 1
a235 1
      rl_command_func_t *f = (rl_command_func_t *)NULL;
a237 1
      RL_SETSTATE(RL_STATE_MOREINPUT);
a238 1
      RL_UNSETSTATE(RL_STATE_MOREINPUT);
d240 1
a240 7
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	c = _rl_read_mbstring (c, mb, MB_LEN_MAX);
#endif

      /* Translate the keys we do something with to opcodes. */
      if (c >= 0 && _rl_keymap[c].type == ISFUNC)
a247 8
	  else if (f == rl_rubout)
	    c = -3;
	  else if (c == CTRL ('G'))
	    c = -4;
	  else if (c == CTRL ('W'))	/* XXX */
	    c = -5;
	  else if (c == CTRL ('Y'))	/* XXX */
	    c = -6;
d250 6
d261 1
d268 2
a269 5
	     to terminate the search and execute the movement command.
	     XXX - since _rl_input_available depends on the application-
	     settable keyboard timeout value, this could alternatively
	     use _rl_input_queued(100000) */
	  if (c == ESC && _rl_input_available ())
d274 1
a274 17
#define ENDSRCH_CHAR(c) \
  ((CTRL_CHAR (c) || META_CHAR (c) || (c) == RUBOUT) && ((c) != CTRL ('G')))

#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  if (c >= 0 && strlen (mb) == 1 && ENDSRCH_CHAR (c))
	    {
	      /* This sets rl_pending_input to c; it will be picked up the next
		 time rl_read_key is called. */
	      rl_execute_next (c);
	      break;
	    }
	}
      else
#endif
      if (c >= 0 && ENDSRCH_CHAR (c))
a275 2
	  /* This sets rl_pending_input to c; it will be picked up the next
	     time rl_read_key is called. */
d284 1
a284 12
	    {
	      if (last_isearch_string)
		{
		  search_string_size = 64 + last_isearch_string_len;
		  search_string = (char *)xrealloc (search_string, search_string_size);
		  strcpy (search_string, last_isearch_string);
		  search_string_index = last_isearch_string_len;
		  rl_display_search (search_string, reverse, -1);
		  break;
		}
	      continue;
	    }
d290 1
a290 1
	    rl_ding ();
d299 2
a300 15
	/* delete character from search string. */
	case -3:	/* C-H, DEL */
	  /* This is tricky.  To do this right, we need to keep a
	     stack of search positions for the current search, with
	     sentinels marking the beginning and end.  But this will
	     do until we have a real isearch-undo. */
	  if (search_string_index == 0)
	    rl_ding ();
	  else
	    search_string[--search_string_index] = '\0';

	  break;

	case -4:	/* C-G */
	  rl_replace_line (lines[orig_line], 0);
d302 1
a302 1
	  rl_mark = orig_mark;
a307 1
	  RL_UNSETSTATE(RL_STATE_ISEARCH);
d310 6
a315 11
	case -5:	/* C-W */
	  /* skip over portion of line we already matched */
	  wstart = rl_point + search_string_index;
	  if (wstart >= rl_end)
	    {
	      rl_ding ();
	      break;
	    }

	  /* if not in a word, move to one. */
	  if (rl_alphabetic(rl_line_buffer[wstart]) == 0)
d317 4
a320 2
	      rl_ding ();
	      break;
a321 31
	  n = wstart;
	  while (n < rl_end && rl_alphabetic(rl_line_buffer[n]))
	    n++;
	  wlen = n - wstart + 1;
	  if (search_string_index + wlen + 1 >= search_string_size)
	    {
	      search_string_size += wlen + 1;
	      search_string = (char *)xrealloc (search_string, search_string_size);
	    }
	  for (; wstart < n; wstart++)
	    search_string[search_string_index++] = rl_line_buffer[wstart];
	  search_string[search_string_index] = '\0';
	  break;

	case -6:	/* C-Y */
	  /* skip over portion of line we already matched */
	  wstart = rl_point + search_string_index;
	  if (wstart >= rl_end)
	    {
	      rl_ding ();
	      break;
	    }
	  n = rl_end - wstart + 1;
	  if (search_string_index + n + 1 >= search_string_size)
	    {
	      search_string_size += n + 1;
	      search_string = (char *)xrealloc (search_string, search_string_size);
	    }
	  for (n = wstart; n < rl_end; n++)
	    search_string[search_string_index++] = rl_line_buffer[n];
	  search_string[search_string_index] = '\0';
d323 1
d330 1
a330 8
	      search_string = (char *)xrealloc (search_string, search_string_size);
	    }
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      int j, l;
	      for (j = 0, l = strlen (mb); j < l; )
		search_string[search_string_index++] = mb[j++];
d332 1
a332 3
	  else
#endif
	    search_string[search_string_index++] = c;
d387 1
a387 1
	  rl_ding ();
d397 2
d400 6
a405 1
	  rl_replace_line (lines[i], 0);
d407 1
d423 2
a424 4
  /* Save the search string for possible later use. */
  FREE (last_isearch_string);
  last_isearch_string = search_string;
  last_isearch_string_len = search_string_index;
d431 1
a431 3
  /* If the string was not found, put point at the end of the last matching
     line.  If last_found_line == orig_line, we didn't find any matching
     history lines at all, so put point back in its original position. */
d433 1
a433 8
    {
      if (last_found_line == orig_line)
	line_index = orig_point;
      else
	line_index = strlen (rl_line_buffer);
      rl_mark = orig_mark;
    }

a434 3
  /* Don't worry about where to put the mark here; rl_get_previous_history
     and rl_get_next_history take care of it. */

d437 2
a438 1
  FREE (allocated_line);
a439 2

  RL_UNSETSTATE(RL_STATE_ISEARCH);
@


1.3.16.1
log
@2002-08-24  Elena Zannoni  <ezannoni@@redhat.com>

        Import of readline 4.3:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@d7 1
a7 1
/* Copyright (C) 1987-2002 Free Software Foundation, Inc.
a47 2
#include "rlmbutil.h"

d55 1
a55 1
char *_rl_isearch_terminators = (char *)NULL;
d58 1
a58 1
extern HIST_ENTRY *_rl_saved_line_for_history;
d61 1
a61 1
static int rl_search_history PARAMS((int, int));
a66 6
/* Last search string and its length. */
static char *last_isearch_string;
static int last_isearch_string_len;

static char *default_isearch_terminators = "\033\012";

d100 1
a100 1
  message = (char *)xmalloc (searchlen + 33);
d130 1
a130 1
  rl_message ("%s", message);
d162 1
a162 1
  int orig_point, orig_mark, orig_line, last_found_line;
a163 4
  int n, wstart, wlen;
#if defined (HANDLE_MULTIBYTE)
  char mb[MB_LEN_MAX];
#endif
d177 1
a177 1
  char *isearch_terminators;
a178 1
  RL_SETSTATE(RL_STATE_ISEARCH);
a179 1
  orig_mark = rl_mark;
d186 1
a186 1
						: default_isearch_terminators;
d189 1
a189 1
  rl_maybe_replace_line ();
d200 2
a201 2
  if (_rl_saved_line_for_history)
    lines[i] = _rl_saved_line_for_history->line;
d205 1
a205 1
      allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));
d218 1
a218 1
  search_string = (char *)xmalloc (search_string_size = 128);
d235 1
a235 1
      rl_command_func_t *f = (rl_command_func_t *)NULL;
a237 1
      RL_SETSTATE(RL_STATE_MOREINPUT);
a238 1
      RL_UNSETSTATE(RL_STATE_MOREINPUT);
d240 1
a240 7
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	c = _rl_read_mbstring (c, mb, MB_LEN_MAX);
#endif

      /* Translate the keys we do something with to opcodes. */
      if (c >= 0 && _rl_keymap[c].type == ISFUNC)
a247 8
	  else if (f == rl_rubout)
	    c = -3;
	  else if (c == CTRL ('G'))
	    c = -4;
	  else if (c == CTRL ('W'))	/* XXX */
	    c = -5;
	  else if (c == CTRL ('Y'))	/* XXX */
	    c = -6;
d250 6
d261 1
d268 2
a269 5
	     to terminate the search and execute the movement command.
	     XXX - since _rl_input_available depends on the application-
	     settable keyboard timeout value, this could alternatively
	     use _rl_input_queued(100000) */
	  if (c == ESC && _rl_input_available ())
d274 1
a274 17
#define ENDSRCH_CHAR(c) \
  ((CTRL_CHAR (c) || META_CHAR (c) || (c) == RUBOUT) && ((c) != CTRL ('G')))

#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  if (c >= 0 && strlen (mb) == 1 && ENDSRCH_CHAR (c))
	    {
	      /* This sets rl_pending_input to c; it will be picked up the next
		 time rl_read_key is called. */
	      rl_execute_next (c);
	      break;
	    }
	}
      else
#endif
      if (c >= 0 && ENDSRCH_CHAR (c))
a275 2
	  /* This sets rl_pending_input to c; it will be picked up the next
	     time rl_read_key is called. */
d284 1
a284 12
	    {
	      if (last_isearch_string)
		{
		  search_string_size = 64 + last_isearch_string_len;
		  search_string = (char *)xrealloc (search_string, search_string_size);
		  strcpy (search_string, last_isearch_string);
		  search_string_index = last_isearch_string_len;
		  rl_display_search (search_string, reverse, -1);
		  break;
		}
	      continue;
	    }
d290 1
a290 1
	    rl_ding ();
d299 2
a300 15
	/* delete character from search string. */
	case -3:	/* C-H, DEL */
	  /* This is tricky.  To do this right, we need to keep a
	     stack of search positions for the current search, with
	     sentinels marking the beginning and end.  But this will
	     do until we have a real isearch-undo. */
	  if (search_string_index == 0)
	    rl_ding ();
	  else
	    search_string[--search_string_index] = '\0';

	  break;

	case -4:	/* C-G */
	  rl_replace_line (lines[orig_line], 0);
d302 1
a302 1
	  rl_mark = orig_mark;
a307 1
	  RL_UNSETSTATE(RL_STATE_ISEARCH);
d310 6
a315 11
	case -5:	/* C-W */
	  /* skip over portion of line we already matched */
	  wstart = rl_point + search_string_index;
	  if (wstart >= rl_end)
	    {
	      rl_ding ();
	      break;
	    }

	  /* if not in a word, move to one. */
	  if (rl_alphabetic(rl_line_buffer[wstart]) == 0)
d317 4
a320 2
	      rl_ding ();
	      break;
a321 31
	  n = wstart;
	  while (n < rl_end && rl_alphabetic(rl_line_buffer[n]))
	    n++;
	  wlen = n - wstart + 1;
	  if (search_string_index + wlen + 1 >= search_string_size)
	    {
	      search_string_size += wlen + 1;
	      search_string = (char *)xrealloc (search_string, search_string_size);
	    }
	  for (; wstart < n; wstart++)
	    search_string[search_string_index++] = rl_line_buffer[wstart];
	  search_string[search_string_index] = '\0';
	  break;

	case -6:	/* C-Y */
	  /* skip over portion of line we already matched */
	  wstart = rl_point + search_string_index;
	  if (wstart >= rl_end)
	    {
	      rl_ding ();
	      break;
	    }
	  n = rl_end - wstart + 1;
	  if (search_string_index + n + 1 >= search_string_size)
	    {
	      search_string_size += n + 1;
	      search_string = (char *)xrealloc (search_string, search_string_size);
	    }
	  for (n = wstart; n < rl_end; n++)
	    search_string[search_string_index++] = rl_line_buffer[n];
	  search_string[search_string_index] = '\0';
d323 1
d330 1
a330 8
	      search_string = (char *)xrealloc (search_string, search_string_size);
	    }
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      int j, l;
	      for (j = 0, l = strlen (mb); j < l; )
		search_string[search_string_index++] = mb[j++];
d332 1
a332 3
	  else
#endif
	    search_string[search_string_index++] = c;
d387 1
a387 1
	  rl_ding ();
d397 2
d400 6
a405 1
	  rl_replace_line (lines[i], 0);
d407 1
d423 2
a424 4
  /* Save the search string for possible later use. */
  FREE (last_isearch_string);
  last_isearch_string = search_string;
  last_isearch_string_len = search_string_index;
d431 1
a431 3
  /* If the string was not found, put point at the end of the last matching
     line.  If last_found_line == orig_line, we didn't find any matching
     history lines at all, so put point back in its original position. */
d433 1
a433 8
    {
      if (last_found_line == orig_line)
	line_index = orig_point;
      else
	line_index = strlen (rl_line_buffer);
      rl_mark = orig_mark;
    }

a434 3
  /* Don't worry about where to put the mark here; rl_get_previous_history
     and rl_get_next_history take care of it. */

d437 2
a438 1
  FREE (allocated_line);
a439 2

  RL_UNSETSTATE(RL_STATE_ISEARCH);
@


1.2
log
@Dummy commit before importof 4.1 version
@
text
@d15 1
a15 1
   the Free Software Foundation; either version 1, or (at your option)
d26 1
a26 1
   675 Mass Ave, Cambridge, MA 02139, USA. */
d51 3
a57 1
extern Keymap _rl_keymap;
a58 10
extern int rl_line_buffer_len;
extern int rl_point, rl_end;
extern char *rl_line_buffer;

extern int rl_execute_next ();
extern void rl_extend_line_buffer ();

extern int _rl_input_available ();

extern char *xmalloc (), *xrealloc ();
d60 2
a61 1
static int rl_search_history ();
@


1.1
log
@Initial revision
@
text
@d51 3
a60 3
extern void _rl_save_prompt ();
extern void _rl_restore_prompt ();

d181 5
d192 3
d222 1
a222 1
  _rl_save_prompt ();
d257 1
d262 7
d310 1
a310 1
	  _rl_restore_prompt();
d428 1
a428 1
  _rl_restore_prompt ();
d434 1
a434 1
    rl_get_previous_history (orig_line - last_found_line);
d436 1
a436 1
    rl_get_next_history (last_found_line - orig_line);
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-08-02 snapshot
@
text
@a50 3
/* Variables exported to other files in the readline library. */
unsigned char *_rl_isearch_terminators = (unsigned char *)NULL;

d58 3
a180 5
  /* The list of characters which terminate the search, but are not
     subsequently executed.  If the variable isearch-terminators has
     been set, we use that value, otherwise we use ESC and C-J. */
  unsigned char *isearch_terminators;

a186 3
  isearch_terminators = _rl_isearch_terminators ? _rl_isearch_terminators
						: (unsigned char *)"\033\012";

d214 1
a214 1
  rl_save_prompt ();
a248 1
#if 0
a252 7
#else
      /* The characters in isearch_terminators (set from the user-settable
	 variable isearch-terminators) are used to terminate the search but
	 not subsequently execute the character as a command.  The default
	 value is "\033\012" (ESC and C-J). */
      if (strchr (isearch_terminators, c))
#endif
d294 1
a294 1
	  rl_restore_prompt();
d412 1
a412 1
  rl_restore_prompt ();
d418 1
a418 1
    rl_get_previous_history (orig_line - last_found_line, 0);
d420 1
a420 1
    rl_get_next_history (last_found_line - orig_line, 0);
@


1.1.1.3
log
@Import of readline 4.1
@
text
@d15 1
a15 1
   the Free Software Foundation; either version 2, or (at your option)
d26 1
a26 1
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
a50 3
#include "rlprivate.h"
#include "xmalloc.h"

d55 1
d57 10
d68 1
a68 2
/* Forward declarations */
static int rl_search_history __P((int, int));
@


1.1.1.4
log
@import of readline-4.3
@
text
@d7 1
a7 1
/* Copyright (C) 1987-2002 Free Software Foundation, Inc.
a47 2
#include "rlmbutil.h"

d55 1
a55 1
char *_rl_isearch_terminators = (char *)NULL;
d58 1
a58 1
extern HIST_ENTRY *_rl_saved_line_for_history;
d61 1
a61 1
static int rl_search_history PARAMS((int, int));
a66 6
/* Last search string and its length. */
static char *last_isearch_string;
static int last_isearch_string_len;

static char *default_isearch_terminators = "\033\012";

d100 1
a100 1
  message = (char *)xmalloc (searchlen + 33);
d130 1
a130 1
  rl_message ("%s", message);
d162 1
a162 1
  int orig_point, orig_mark, orig_line, last_found_line;
a163 4
  int n, wstart, wlen;
#if defined (HANDLE_MULTIBYTE)
  char mb[MB_LEN_MAX];
#endif
d177 1
a177 1
  char *isearch_terminators;
a178 1
  RL_SETSTATE(RL_STATE_ISEARCH);
a179 1
  orig_mark = rl_mark;
d186 1
a186 1
						: default_isearch_terminators;
d189 1
a189 1
  rl_maybe_replace_line ();
d200 2
a201 2
  if (_rl_saved_line_for_history)
    lines[i] = _rl_saved_line_for_history->line;
d205 1
a205 1
      allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));
d218 1
a218 1
  search_string = (char *)xmalloc (search_string_size = 128);
d235 1
a235 1
      rl_command_func_t *f = (rl_command_func_t *)NULL;
a237 1
      RL_SETSTATE(RL_STATE_MOREINPUT);
a238 1
      RL_UNSETSTATE(RL_STATE_MOREINPUT);
d240 1
a240 7
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	c = _rl_read_mbstring (c, mb, MB_LEN_MAX);
#endif

      /* Translate the keys we do something with to opcodes. */
      if (c >= 0 && _rl_keymap[c].type == ISFUNC)
a247 8
	  else if (f == rl_rubout)
	    c = -3;
	  else if (c == CTRL ('G'))
	    c = -4;
	  else if (c == CTRL ('W'))	/* XXX */
	    c = -5;
	  else if (c == CTRL ('Y'))	/* XXX */
	    c = -6;
d250 6
d261 1
d268 2
a269 5
	     to terminate the search and execute the movement command.
	     XXX - since _rl_input_available depends on the application-
	     settable keyboard timeout value, this could alternatively
	     use _rl_input_queued(100000) */
	  if (c == ESC && _rl_input_available ())
d274 1
a274 17
#define ENDSRCH_CHAR(c) \
  ((CTRL_CHAR (c) || META_CHAR (c) || (c) == RUBOUT) && ((c) != CTRL ('G')))

#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  if (c >= 0 && strlen (mb) == 1 && ENDSRCH_CHAR (c))
	    {
	      /* This sets rl_pending_input to c; it will be picked up the next
		 time rl_read_key is called. */
	      rl_execute_next (c);
	      break;
	    }
	}
      else
#endif
      if (c >= 0 && ENDSRCH_CHAR (c))
a275 2
	  /* This sets rl_pending_input to c; it will be picked up the next
	     time rl_read_key is called. */
d284 1
a284 12
	    {
	      if (last_isearch_string)
		{
		  search_string_size = 64 + last_isearch_string_len;
		  search_string = (char *)xrealloc (search_string, search_string_size);
		  strcpy (search_string, last_isearch_string);
		  search_string_index = last_isearch_string_len;
		  rl_display_search (search_string, reverse, -1);
		  break;
		}
	      continue;
	    }
d290 1
a290 1
	    rl_ding ();
d299 2
a300 15
	/* delete character from search string. */
	case -3:	/* C-H, DEL */
	  /* This is tricky.  To do this right, we need to keep a
	     stack of search positions for the current search, with
	     sentinels marking the beginning and end.  But this will
	     do until we have a real isearch-undo. */
	  if (search_string_index == 0)
	    rl_ding ();
	  else
	    search_string[--search_string_index] = '\0';

	  break;

	case -4:	/* C-G */
	  rl_replace_line (lines[orig_line], 0);
d302 1
a302 1
	  rl_mark = orig_mark;
a307 1
	  RL_UNSETSTATE(RL_STATE_ISEARCH);
d310 6
a315 11
	case -5:	/* C-W */
	  /* skip over portion of line we already matched */
	  wstart = rl_point + search_string_index;
	  if (wstart >= rl_end)
	    {
	      rl_ding ();
	      break;
	    }

	  /* if not in a word, move to one. */
	  if (rl_alphabetic(rl_line_buffer[wstart]) == 0)
d317 4
a320 2
	      rl_ding ();
	      break;
a321 31
	  n = wstart;
	  while (n < rl_end && rl_alphabetic(rl_line_buffer[n]))
	    n++;
	  wlen = n - wstart + 1;
	  if (search_string_index + wlen + 1 >= search_string_size)
	    {
	      search_string_size += wlen + 1;
	      search_string = (char *)xrealloc (search_string, search_string_size);
	    }
	  for (; wstart < n; wstart++)
	    search_string[search_string_index++] = rl_line_buffer[wstart];
	  search_string[search_string_index] = '\0';
	  break;

	case -6:	/* C-Y */
	  /* skip over portion of line we already matched */
	  wstart = rl_point + search_string_index;
	  if (wstart >= rl_end)
	    {
	      rl_ding ();
	      break;
	    }
	  n = rl_end - wstart + 1;
	  if (search_string_index + n + 1 >= search_string_size)
	    {
	      search_string_size += n + 1;
	      search_string = (char *)xrealloc (search_string, search_string_size);
	    }
	  for (n = wstart; n < rl_end; n++)
	    search_string[search_string_index++] = rl_line_buffer[n];
	  search_string[search_string_index] = '\0';
d323 1
d330 1
a330 8
	      search_string = (char *)xrealloc (search_string, search_string_size);
	    }
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      int j, l;
	      for (j = 0, l = strlen (mb); j < l; )
		search_string[search_string_index++] = mb[j++];
d332 1
a332 3
	  else
#endif
	    search_string[search_string_index++] = c;
d387 1
a387 1
	  rl_ding ();
d397 2
d400 6
a405 1
	  rl_replace_line (lines[i], 0);
d407 1
d423 2
a424 4
  /* Save the search string for possible later use. */
  FREE (last_isearch_string);
  last_isearch_string = search_string;
  last_isearch_string_len = search_string_index;
d431 1
a431 3
  /* If the string was not found, put point at the end of the last matching
     line.  If last_found_line == orig_line, we didn't find any matching
     history lines at all, so put point back in its original position. */
d433 1
a433 8
    {
      if (last_found_line == orig_line)
	line_index = orig_point;
      else
	line_index = strlen (rl_line_buffer);
      rl_mark = orig_mark;
    }

a434 3
  /* Don't worry about where to put the mark here; rl_get_previous_history
     and rl_get_next_history take care of it. */

d437 2
a438 1
  FREE (allocated_line);
a439 2

  RL_UNSETSTATE(RL_STATE_ISEARCH);
@


1.1.1.5
log
@import of readlilne 5.1
@
text
@d7 1
a7 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
a58 2
_rl_search_cxt *_rl_iscxt = 0;

d62 1
a64 4
static _rl_search_cxt *_rl_isearch_init PARAMS((int));
static void _rl_isearch_fini PARAMS((_rl_search_cxt *));
static int _rl_isearch_cleanup PARAMS((_rl_search_cxt *, int));

a74 51
_rl_search_cxt *
_rl_scxt_alloc (type, flags)
     int type, flags;
{
  _rl_search_cxt *cxt;

  cxt = (_rl_search_cxt *)xmalloc (sizeof (_rl_search_cxt));

  cxt->type = type;
  cxt->sflags = flags;

  cxt->search_string = 0;
  cxt->search_string_size = cxt->search_string_index = 0;

  cxt->lines = 0;
  cxt->allocated_line = 0;
  cxt->hlen = cxt->hindex = 0;

  cxt->save_point = rl_point;
  cxt->save_mark = rl_mark;
  cxt->save_line = where_history ();
  cxt->last_found_line = cxt->save_line;
  cxt->prev_line_found = 0;

  cxt->save_undo_list = 0;

  cxt->history_pos = 0;
  cxt->direction = 0;

  cxt->lastc = 0;

  cxt->sline = 0;
  cxt->sline_len = cxt->sline_index = 0;

  cxt->search_terminators = 0;

  return cxt;
}

void
_rl_scxt_dispose (cxt, flags)
     _rl_search_cxt *cxt;
     int flags;
{
  FREE (cxt->search_string);
  FREE (cxt->allocated_line);
  FREE (cxt->lines);

  free (cxt);
}

d95 1
a95 1
   DIRECTION is zero for forward, or non-zero for reverse,
d143 7
a149 3
static _rl_search_cxt *
_rl_isearch_init (direction)
     int direction;
d151 18
a168 1
  _rl_search_cxt *cxt;
d170 15
a184 1
  HIST_ENTRY **hlist;
d186 4
a189 3
  cxt = _rl_scxt_alloc (RL_SEARCH_ISEARCH, 0);
  if (direction < 0)
    cxt->sflags |= SF_REVERSE;
d191 9
a199 1
  cxt->search_terminators = _rl_isearch_terminators ? _rl_isearch_terminators
a202 1
  hlist = history_list ();
d210 3
a212 3
  cxt->lines = (char **)xmalloc ((1 + (cxt->hlen = i)) * sizeof (char *));
  for (i = 0; i < cxt->hlen; i++)
    cxt->lines[i] = hlist[i]->line;
d215 1
a215 1
    cxt->lines[i] = _rl_saved_line_for_history->line;
d219 3
a221 3
      cxt->allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));
      strcpy (cxt->allocated_line, &rl_line_buffer[0]);
      cxt->lines[i] = cxt->allocated_line;
d224 1
a224 1
  cxt->hlen++;
d227 1
a227 1
  cxt->history_pos = cxt->save_line;
d232 4
a235 2
  cxt->search_string = (char *)xmalloc (cxt->search_string_size = 128);
  cxt->search_string[cxt->search_string_index = 0] = '\0';
d238 1
a238 1
  cxt->direction = (direction >= 0) ? 1 : -1;
d240 1
a240 3
  cxt->sline = rl_line_buffer;
  cxt->sline_len = strlen (cxt->sline);
  cxt->sline_index = rl_point;
d242 3
a244 1
  _rl_iscxt = cxt;		/* save globally */
d246 2
a247 27
  return cxt;
}

static void
_rl_isearch_fini (cxt)
     _rl_search_cxt *cxt;
{
  /* First put back the original state. */
  strcpy (rl_line_buffer, cxt->lines[cxt->save_line]);

  rl_restore_prompt ();

  /* Save the search string for possible later use. */
  FREE (last_isearch_string);
  last_isearch_string = cxt->search_string;
  last_isearch_string_len = cxt->search_string_index;
  cxt->search_string = 0;

  if (cxt->last_found_line < cxt->save_line)
    rl_get_previous_history (cxt->save_line - cxt->last_found_line, 0);
  else
    rl_get_next_history (cxt->last_found_line - cxt->save_line, 0);

  /* If the string was not found, put point at the end of the last matching
     line.  If last_found_line == orig_line, we didn't find any matching
     history lines at all, so put point back in its original position. */
  if (cxt->sline_index < 0)
d249 1
a249 6
      if (cxt->last_found_line == cxt->save_line)
	cxt->sline_index = cxt->save_point;
      else
	cxt->sline_index = strlen (rl_line_buffer);
      rl_mark = cxt->save_mark;
    }
d251 4
a254 17
  rl_point = cxt->sline_index;
  /* Don't worry about where to put the mark here; rl_get_previous_history
     and rl_get_next_history take care of it. */

  rl_clear_message ();
}

int
_rl_search_getchar (cxt)
     _rl_search_cxt *cxt;
{
  int c;

  /* Read a key and decide how to proceed. */
  RL_SETSTATE(RL_STATE_MOREINPUT);
  c = cxt->lastc = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);
d257 2
a258 2
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    c = cxt->lastc = _rl_read_mbstring (cxt->lastc, cxt->mb, MB_LEN_MAX);
d261 4
a264 2
  return c;
}
d266 33
a298 51
/* Process just-read character C according to isearch context CXT.  Return
   -1 if the caller should just free the context and return, 0 if we should
   break out of the loop, and 1 if we should continue to read characters. */
int
_rl_isearch_dispatch (cxt, c)
     _rl_search_cxt *cxt;
     int c;
{
  int n, wstart, wlen, limit, cval;
  rl_command_func_t *f;

  f = (rl_command_func_t *)NULL;
 
 /* Translate the keys we do something with to opcodes. */
  if (c >= 0 && _rl_keymap[c].type == ISFUNC)
    {
      f = _rl_keymap[c].function;

      if (f == rl_reverse_search_history)
	cxt->lastc = (cxt->sflags & SF_REVERSE) ? -1 : -2;
      else if (f == rl_forward_search_history)
	cxt->lastc = (cxt->sflags & SF_REVERSE) ? -2 : -1;
      else if (f == rl_rubout)
	cxt->lastc = -3;
      else if (c == CTRL ('G'))
	cxt->lastc = -4;
      else if (c == CTRL ('W'))	/* XXX */
	cxt->lastc = -5;
      else if (c == CTRL ('Y'))	/* XXX */
	cxt->lastc = -6;
    }

  /* The characters in isearch_terminators (set from the user-settable
     variable isearch-terminators) are used to terminate the search but
     not subsequently execute the character as a command.  The default
     value is "\033\012" (ESC and C-J). */
  if (strchr (cxt->search_terminators, cxt->lastc))
    {
      /* ESC still terminates the search, but if there is pending
	 input or if input arrives within 0.1 seconds (on systems
	 with select(2)) it is used as a prefix character
	 with rl_execute_next.  WATCH OUT FOR THIS!  This is intended
	 to allow the arrow keys to be used like ^F and ^B are used
	 to terminate the search and execute the movement command.
	 XXX - since _rl_input_available depends on the application-
	 settable keyboard timeout value, this could alternatively
	 use _rl_input_queued(100000) */
      if (cxt->lastc == ESC && _rl_input_available ())
	rl_execute_next (ESC);
      return (0);
    }
d304 1
a304 3
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      if (cxt->lastc >= 0 && (cxt->mb[0] && cxt->mb[1] == '\0') && ENDSRCH_CHAR (cxt->lastc))
d306 1
a306 25
	  /* This sets rl_pending_input to c; it will be picked up the next
	     time rl_read_key is called. */
	  rl_execute_next (cxt->lastc);
	  return (0);
	}
    }
  else
#endif
    if (cxt->lastc >= 0 && ENDSRCH_CHAR (cxt->lastc))
      {
	/* This sets rl_pending_input to LASTC; it will be picked up the next
	   time rl_read_key is called. */
	rl_execute_next (cxt->lastc);
	return (0);
      }

  /* Now dispatch on the character.  `Opcodes' affect the search string or
     state.  Other characters are added to the string.  */
  switch (cxt->lastc)
    {
    /* search again */
    case -1:
      if (cxt->search_string_index == 0)
	{
	  if (last_isearch_string)
d308 3
a310 5
	      cxt->search_string_size = 64 + last_isearch_string_len;
	      cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	      strcpy (cxt->search_string, last_isearch_string);
	      cxt->search_string_index = last_isearch_string_len;
	      rl_display_search (cxt->search_string, (cxt->sflags & SF_REVERSE), -1);
a312 1
	  return (1);
a313 4
      else if (cxt->sflags & SF_REVERSE)
	cxt->sline_index--;
      else if (cxt->sline_index != cxt->sline_len)
	cxt->sline_index++;
d315 2
a316 37
	rl_ding ();
      break;

    /* switch directions */
    case -2:
      cxt->direction = -cxt->direction;
      if (cxt->direction < 0)
	cxt->sflags |= SF_REVERSE;
      else
	cxt->sflags &= ~SF_REVERSE;
      break;

    /* delete character from search string. */
    case -3:	/* C-H, DEL */
      /* This is tricky.  To do this right, we need to keep a
	 stack of search positions for the current search, with
	 sentinels marking the beginning and end.  But this will
	 do until we have a real isearch-undo. */
      if (cxt->search_string_index == 0)
	rl_ding ();
      else
	cxt->search_string[--cxt->search_string_index] = '\0';
      break;

    case -4:	/* C-G, abort */
      rl_replace_line (cxt->lines[cxt->save_line], 0);
      rl_point = cxt->save_point;
      rl_mark = cxt->save_mark;
      rl_restore_prompt();
      rl_clear_message ();

      return -1;

    case -5:	/* C-W */
      /* skip over portion of line we already matched and yank word */
      wstart = rl_point + cxt->search_string_index;
      if (wstart >= rl_end)
d318 3
a320 1
	  rl_ding ();
d324 1
a324 3
      /* if not in a word, move to one. */
      cval = _rl_char_value (rl_line_buffer, wstart);
      if (_rl_walphabetic (cval) == 0)
d326 20
a345 1
	  rl_ding ();
d347 5
a351 26
	}
      n = MB_NEXTCHAR (rl_line_buffer, wstart, 1, MB_FIND_NONZERO);;
      while (n < rl_end)
	{
	  cval = _rl_char_value (rl_line_buffer, n);
	  if (_rl_walphabetic (cval) == 0)
	    break;
	  n = MB_NEXTCHAR (rl_line_buffer, n, 1, MB_FIND_NONZERO);;
	}
      wlen = n - wstart + 1;
      if (cxt->search_string_index + wlen + 1 >= cxt->search_string_size)
	{
	  cxt->search_string_size += wlen + 1;
	  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	}
      for (; wstart < n; wstart++)
	cxt->search_string[cxt->search_string_index++] = rl_line_buffer[wstart];
      cxt->search_string[cxt->search_string_index] = '\0';
      break;

    case -6:	/* C-Y */
      /* skip over portion of line we already matched and yank rest */
      wstart = rl_point + cxt->search_string_index;
      if (wstart >= rl_end)
	{
	  rl_ding ();
a352 32
	}
      n = rl_end - wstart + 1;
      if (cxt->search_string_index + n + 1 >= cxt->search_string_size)
	{
	  cxt->search_string_size += n + 1;
	  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	}
      for (n = wstart; n < rl_end; n++)
	cxt->search_string[cxt->search_string_index++] = rl_line_buffer[n];
      cxt->search_string[cxt->search_string_index] = '\0';
      break;

    /* Add character to search string and continue search. */
    default:
      if (cxt->search_string_index + 2 >= cxt->search_string_size)
	{
	  cxt->search_string_size += 128;
	  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	}
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  int j, l;
	  for (j = 0, l = strlen (cxt->mb); j < l; )
	    cxt->search_string[cxt->search_string_index++] = cxt->mb[j++];
	}
      else
#endif
	cxt->search_string[cxt->search_string_index++] = c;
      cxt->search_string[cxt->search_string_index] = '\0';
      break;
    }
d354 12
a365 3
  for (cxt->sflags &= ~(SF_FOUND|SF_FAILED);; )
    {
      limit = cxt->sline_len - cxt->search_string_index + 1;
d367 16
a382 4
      /* Search the current line. */
      while ((cxt->sflags & SF_REVERSE) ? (cxt->sline_index >= 0) : (cxt->sline_index < limit))
	{
	  if (STREQN (cxt->search_string, cxt->sline + cxt->sline_index, cxt->search_string_index))
d384 1
a384 1
	      cxt->sflags |= SF_FOUND;
a386 5
	  else
	    cxt->sline_index += cxt->direction;
	}
      if (cxt->sflags & SF_FOUND)
	break;
d388 19
a406 7
      /* Move to the next line, but skip new copies of the line
	 we just found and lines shorter than the string we're
	 searching for. */
      do
	{
	  /* Move to the next line. */
	  cxt->history_pos += cxt->direction;
d408 4
a411 2
	  /* At limit for direction? */
	  if ((cxt->sflags & SF_REVERSE) ? (cxt->history_pos < 0) : (cxt->history_pos == cxt->hlen))
d413 1
a413 1
	      cxt->sflags |= SF_FAILED;
d416 10
d427 19
a445 3
	  /* We will need these later. */
	  cxt->sline = cxt->lines[cxt->history_pos];
	  cxt->sline_len = strlen (cxt->sline);
a446 2
      while ((cxt->prev_line_found && STREQ (cxt->prev_line_found, cxt->lines[cxt->history_pos])) ||
	     (cxt->search_string_index > cxt->sline_len));
d448 3
a450 2
      if (cxt->sflags & SF_FAILED)
	break;
d452 21
a472 3
      /* Now set up the line for searching... */
      cxt->sline_index = (cxt->sflags & SF_REVERSE) ? cxt->sline_len - cxt->search_string_index : 0;
    }
d474 13
a486 7
  if (cxt->sflags & SF_FAILED)
    {
      /* We cannot find the search string.  Ding the bell. */
      rl_ding ();
      cxt->history_pos = cxt->last_found_line;
      return 1;
    }
d488 2
a489 11
  /* We have found the search string.  Just display it.  But don't
     actually move there in the history list until the user accepts
     the location. */
  if (cxt->sflags & SF_FOUND)
    {
      cxt->prev_line_found = cxt->lines[cxt->history_pos];
      rl_replace_line (cxt->lines[cxt->history_pos], 0);
      rl_point = cxt->sline_index;
      cxt->last_found_line = cxt->history_pos;
      rl_display_search (cxt->search_string, (cxt->sflags & SF_REVERSE), (cxt->history_pos == cxt->save_line) ? -1 : cxt->history_pos);
    }
d491 3
a493 2
  return 1;
}
d495 7
a501 9
static int
_rl_isearch_cleanup (cxt, r)
     _rl_search_cxt *cxt;
     int r;
{
  if (r >= 0)
    _rl_isearch_fini (cxt);
  _rl_scxt_dispose (cxt, 0);
  _rl_iscxt = 0;
d503 12
a514 1
  RL_UNSETSTATE(RL_STATE_ISEARCH);
d516 4
a519 2
  return (r != 0);
}
d521 2
a522 10
/* Search through the history looking for an interactively typed string.
   This is analogous to i-search.  We start the search in the current line.
   DIRECTION is which direction to search; >= 0 means forward, < 0 means
   backwards. */
static int
rl_search_history (direction, invoking_key)
     int direction, invoking_key;
{
  _rl_search_cxt *cxt;		/* local for now, but saved globally */
  int c, r;
d524 1
a524 2
  RL_SETSTATE(RL_STATE_ISEARCH);
  cxt = _rl_isearch_init (direction);
d526 4
a529 1
  rl_display_search (cxt->search_string, (cxt->sflags & SF_REVERSE), -1);
d531 4
a534 4
  /* If we are using the callback interface, all we do is set up here and
      return.  The key is that we leave RL_STATE_ISEARCH set. */
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    return (0);
d536 4
a539 2
  r = -1;
  for (;;)
d541 5
a545 5
      c = _rl_search_getchar (cxt);
      /* We might want to handle EOF here (c == 0) */
      r = _rl_isearch_dispatch (cxt, cxt->lastc);
      if (r <= 0)
        break;
d548 5
a552 6
  /* The searching is over.  The user may have found the string that she
     was looking for, or else she may have exited a failing search.  If
     LINE_INDEX is -1, then that shows that the string searched for was
     not found.  We use this to determine where to place rl_point. */
  return (_rl_isearch_cleanup (cxt, r));
}
d554 2
a555 10
#if defined (READLINE_CALLBACKS)
/* Called from the callback functions when we are ready to read a key.  The
   callback functions know to call this because RL_ISSTATE(RL_STATE_ISEARCH).
   If _rl_isearch_dispatch finishes searching, this function is responsible
   for turning off RL_STATE_ISEARCH, which it does using _rl_isearch_cleanup. */
int
_rl_isearch_callback (cxt)
     _rl_search_cxt *cxt;
{
  int c, r;
d557 1
a557 3
  c = _rl_search_getchar (cxt);
  /* We might want to handle EOF here */
  r = _rl_isearch_dispatch (cxt, cxt->lastc);
d559 1
a559 1
  return (r <= 0) ? _rl_isearch_cleanup (cxt, r) : 0;
a560 1
#endif
@


