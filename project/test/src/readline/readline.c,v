head	1.12;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.11
	gdb_7_6-2013-04-26-release:1.11
	gdb_7_6-branch:1.11.0.6
	gdb_7_6-2013-03-12-branchpoint:1.11
	gdb_7_5_1-2012-11-29-release:1.11
	gdb_7_5-2012-08-17-release:1.11
	gdb_7_5-branch:1.11.0.4
	gdb_7_5-2012-07-18-branchpoint:1.11
	gdb_7_4_1-2012-04-26-release:1.11
	gdb_7_4-2012-01-24-release:1.11
	gdb_7_4-branch:1.11.0.2
	gdb_7_4-2011-12-13-branchpoint:1.11
	gdb_7_3_1-2011-09-04-release:1.10
	gdb_7_3-2011-07-26-release:1.10
	gdb_7_3-branch:1.10.0.36
	gdb_7_3-2011-04-01-branchpoint:1.10
	gdb_7_2-2010-09-02-release:1.10
	gdb_7_2-branch:1.10.0.34
	gdb_7_2-2010-07-07-branchpoint:1.10
	gdb_7_1-2010-03-18-release:1.10
	gdb_7_1-branch:1.10.0.32
	gdb_7_1-2010-02-18-branchpoint:1.10
	gdb_7_0_1-2009-12-22-release:1.10
	gdb_7_0-2009-10-06-release:1.10
	gdb_7_0-branch:1.10.0.30
	gdb_7_0-2009-09-16-branchpoint:1.10
	arc-sim-20090309:1.10
	msnyder-checkpoint-072509-branch:1.10.0.28
	msnyder-checkpoint-072509-branchpoint:1.10
	arc-insight_6_8-branch:1.10.0.26
	arc-insight_6_8-branchpoint:1.10
	insight_6_8-branch:1.10.0.24
	insight_6_8-branchpoint:1.10
	reverse-20081226-branch:1.10.0.22
	reverse-20081226-branchpoint:1.10
	multiprocess-20081120-branch:1.10.0.20
	multiprocess-20081120-branchpoint:1.10
	reverse-20080930-branch:1.10.0.18
	reverse-20080930-branchpoint:1.10
	reverse-20080717-branch:1.10.0.16
	reverse-20080717-branchpoint:1.10
	msnyder-reverse-20080609-branch:1.10.0.14
	msnyder-reverse-20080609-branchpoint:1.10
	drow-reverse-20070409-branch:1.10.0.12
	drow-reverse-20070409-branchpoint:1.10
	gdb_6_8-2008-03-27-release:1.10
	gdb_6_8-branch:1.10.0.10
	gdb_6_8-2008-02-26-branchpoint:1.10
	gdb_6_7_1-2007-10-29-release:1.10
	gdb_6_7-2007-10-10-release:1.10
	gdb_6_7-branch:1.10.0.8
	gdb_6_7-2007-09-07-branchpoint:1.10
	insight_6_6-20070208-release:1.10
	gdb_6_6-2006-12-18-release:1.10
	gdb_6_6-branch:1.10.0.6
	gdb_6_6-2006-11-15-branchpoint:1.10
	insight_6_5-20061003-release:1.10
	gdb-csl-symbian-6_4_50_20060226-12:1.8.16.3
	gdb-csl-sourcerygxx-3_4_4-25:1.8
	nickrob-async-20060828-mergepoint:1.10
	gdb-csl-symbian-6_4_50_20060226-11:1.8.16.3
	gdb-csl-sourcerygxx-4_1-17:1.8.10.1
	gdb-csl-20060226-branch-local-2:1.8.10.1
	gdb-csl-sourcerygxx-4_1-14:1.8
	gdb-csl-sourcerygxx-4_1-13:1.8
	gdb-csl-sourcerygxx-4_1-12:1.8
	gdb-csl-sourcerygxx-3_4_4-21:1.8
	gdb_6_5-20060621-release:1.10
	gdb-csl-sourcerygxx-4_1-9:1.8
	gdb-csl-sourcerygxx-4_1-8:1.8
	gdb-csl-sourcerygxx-4_1-7:1.8
	gdb-csl-arm-2006q1-6:1.8
	gdb-csl-sourcerygxx-4_1-6:1.8
	gdb-csl-symbian-6_4_50_20060226-10:1.8.16.3
	gdb-csl-symbian-6_4_50_20060226-9:1.8.16.3
	gdb-csl-symbian-6_4_50_20060226-8:1.8.16.3
	gdb-csl-coldfire-4_1-11:1.8
	gdb-csl-sourcerygxx-3_4_4-19:1.8
	gdb-csl-coldfire-4_1-10:1.8
	gdb_6_5-branch:1.10.0.4
	gdb_6_5-2006-05-14-branchpoint:1.10
	gdb-csl-sourcerygxx-4_1-5:1.8
	nickrob-async-20060513-branch:1.10.0.2
	nickrob-async-20060513-branchpoint:1.10
	gdb-csl-sourcerygxx-4_1-4:1.8
	msnyder-reverse-20060502-branch:1.9.0.4
	msnyder-reverse-20060502-branchpoint:1.9
	gdb-csl-morpho-4_1-4:1.8
	gdb-csl-sourcerygxx-3_4_4-17:1.8
	readline_5_1-import-branch:1.9.0.2
	readline_5_1-import-branchpoint:1.9
	readline-pre-51-import:1.9
	readline_5_1:1.1.1.5
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.8
	gdb-csl-symbian-20060226-branch:1.8.0.16
	gdb-csl-symbian-20060226-branchpoint:1.8
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.8
	msnyder-reverse-20060331-branch:1.8.0.14
	msnyder-reverse-20060331-branchpoint:1.8
	gdb-csl-available-20060303-branch:1.8.0.12
	gdb-csl-available-20060303-branchpoint:1.8
	gdb-csl-20060226-branch:1.8.0.10
	gdb-csl-20060226-branchpoint:1.8
	gdb_6_4-20051202-release:1.8
	msnyder-fork-checkpoint-branch:1.8.0.8
	msnyder-fork-checkpoint-branchpoint:1.8
	gdb-csl-gxxpro-6_3-branch:1.8.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.8
	gdb_6_4-branch:1.8.0.4
	gdb_6_4-2005-11-01-branchpoint:1.8
	gdb-csl-arm-20051020-branch:1.8.0.2
	gdb-csl-arm-20051020-branchpoint:1.8
	msnyder-tracepoint-checkpoint-branch:1.7.0.20
	msnyder-tracepoint-checkpoint-branchpoint:1.7
	gdb-csl-arm-20050325-2005-q1b:1.7
	gdb-csl-arm-20050325-2005-q1a:1.7
	csl-arm-20050325-branch:1.7.0.18
	csl-arm-20050325-branchpoint:1.7
	gdb_6_3-20041109-release:1.7
	gdb_6_3-branch:1.7.0.14
	gdb_6_3-20041019-branchpoint:1.7
	drow_intercu-merge-20040921:1.7
	drow_intercu-merge-20040915:1.7
	jimb-gdb_6_2-e500-branch:1.7.0.16
	jimb-gdb_6_2-e500-branchpoint:1.7
	gdb_6_2-20040730-release:1.7
	gdb_6_2-branch:1.7.0.12
	gdb_6_2-2004-07-10-gmt-branchpoint:1.7
	gdb_6_1_1-20040616-release:1.7
	gdb_6_1-2004-04-05-release:1.7
	drow_intercu-merge-20040402:1.7
	drow_intercu-merge-20040327:1.7
	ezannoni_pie-20040323-branch:1.7.0.10
	ezannoni_pie-20040323-branchpoint:1.7
	cagney_tramp-20040321-mergepoint:1.7
	cagney_tramp-20040309-branch:1.7.0.8
	cagney_tramp-20040309-branchpoint:1.7
	gdb_6_1-branch:1.7.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.7
	drow_intercu-20040221-branch:1.7.0.4
	drow_intercu-20040221-branchpoint:1.7
	cagney_bfdfile-20040213-branch:1.7.0.2
	cagney_bfdfile-20040213-branchpoint:1.7
	drow-cplus-merge-20040208:1.7
	carlton_dictionary-20040126-merge:1.6
	cagney_bigcore-20040122-branch:1.6.0.2
	cagney_bigcore-20040122-branchpoint:1.6
	drow-cplus-merge-20040113:1.6
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	kettenis_sparc-20030918-branch:1.5.0.40
	kettenis_sparc-20030918-branchpoint:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.38
	cagney_x86i386-20030821-branch:1.5.0.36
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.34
	gdb_6_0-2003-06-23-branchpoint:1.5
	jimb-ppc64-linux-20030613-branch:1.5.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.30
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.28
	cagney_writestrings-20030508-branchpoint:1.5
	jimb-ppc64-linux-20030528-branch:1.5.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.24
	cagney_fileio-20030521-branchpoint:1.5
	kettenis_i386newframe-20030517-mergepoint:1.5
	jimb-ppc64-linux-20030509-branch:1.5.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.5
	kettenis_i386newframe-20030504-mergepoint:1.5
	carlton_dictionary-20030430-merge:1.5
	kettenis_i386newframe-20030419-branch:1.5.0.20
	kettenis_i386newframe-20030419-branchpoint:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	kettenis_i386newframe-20030406-branch:1.5.0.18
	kettenis_i386newframe-20030406-branchpoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.16
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.14
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.12
	cagney_lazyid-20030317-branchpoint:1.5
	kettenis-i386newframe-20030316-mergepoint:1.5
	offbyone-20030313-branch:1.5.0.10
	offbyone-20030313-branchpoint:1.5
	kettenis-i386newframe-20030308-branch:1.5.0.8
	kettenis-i386newframe-20030308-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.6
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.4
	interps-20030202-branchpoint:1.5
	cagney-unwind-20030108-branch:1.5.0.2
	cagney-unwind-20030108-branchpoint:1.5
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.4
	readline-pre-43-import:1.4
	carlton_dictionary-20021115-merge:1.4
	kseitz_interps-20021105-merge:1.4
	kseitz_interps-20021103-merge:1.4
	drow-cplus-merge-20021020:1.4
	drow-cplus-merge-20021025:1.4
	carlton_dictionary-20021025-merge:1.4
	carlton_dictionary-20021011-merge:1.4
	drow-cplus-branch:1.4.0.24
	drow-cplus-branchpoint:1.4
	kseitz_interps-20020930-merge:1.4
	carlton_dictionary-20020927-merge:1.4
	carlton_dictionary-branch:1.4.0.22
	carlton_dictionary-20020920-branchpoint:1.4
	gdb_5_3-branch:1.4.0.20
	gdb_5_3-2002-09-04-branchpoint:1.4
	kseitz_interps-20020829-merge:1.4
	cagney_sysregs-20020825-branch:1.4.0.18
	cagney_sysregs-20020825-branchpoint:1.4
	readline_4_3-import-branch:1.4.0.16
	readline_4_3-import-branchpoint:1.4
	readline_4_3:1.1.1.4
	gdb_5_2_1-2002-07-23-release:1.4
	kseitz_interps-20020528-branch:1.4.0.14
	kseitz_interps-20020528-branchpoint:1.4
	cagney_regbuf-20020515-branch:1.4.0.12
	cagney_regbuf-20020515-branchpoint:1.4
	jimb-macro-020506-branch:1.4.0.10
	jimb-macro-020506-branchpoint:1.4
	gdb_5_2-2002-04-29-release:1.4
	gdb_5_2-branch:1.4.0.8
	gdb_5_2-2002-03-03-branchpoint:1.4
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	insight-precleanup-2001-01-01:1.4
	readline_4_1:1.1.1.3
	readline_4_0:1.1.1.2
	FSF:1.1.1
	readline-pre-41-import:1.3
	gdb-premipsmulti-2000-06-06-branch:1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.12
date	2013.09.24.14.49.48;	author muller;	state Exp;
branches;
next	1.11;

1.11
date	2011.05.11.23.38.39;	author jkratoch;	state Exp;
branches;
next	1.10;

1.10
date	2006.05.05.18.26.12;	author drow;	state Exp;
branches;
next	1.9;

1.9
date	2006.04.20.20.13.20;	author ezannoni;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2005.07.25.15.09.31;	author mmitchel;	state Exp;
branches
	1.8.10.1
	1.8.16.1;
next	1.7;

1.7
date	2004.01.27.22.25.15;	author ezannoni;	state Exp;
branches
	1.7.18.1;
next	1.6;

1.6
date	2003.12.30.07.25.18;	author eliz;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.08.22.31.37;	author ezannoni;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.09.17.19.56;	author ezannoni;	state Exp;
branches
	1.4.16.1
	1.4.22.1
	1.4.24.1;
next	1.3;

1.3
date	2000.07.07.17.15.45;	author ezannoni;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.15.11.53.33;	author eliz;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.53;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.9.2.1
date	2006.04.24.22.00.25;	author drow;	state Exp;
branches;
next	;

1.8.10.1
date	2006.07.23.22.22.49;	author kazu;	state Exp;
branches;
next	;

1.8.16.1
date	2006.04.12.14.48.23;	author drow;	state Exp;
branches;
next	1.8.16.2;

1.8.16.2
date	2006.04.12.14.52.05;	author drow;	state Exp;
branches;
next	1.8.16.3;

1.8.16.3
date	2006.04.12.18.11.43;	author drow;	state Exp;
branches;
next	;

1.7.18.1
date	2005.06.08.16.38.25;	author mmitchel;	state Exp;
branches;
next	;

1.4.16.1
date	2002.08.25.23.41.17;	author ezannoni;	state Exp;
branches;
next	;

1.4.22.1
date	2002.12.23.19.39.44;	author carlton;	state Exp;
branches;
next	1.4.22.2;

1.4.22.2
date	2004.01.26.19.11.51;	author carlton;	state Exp;
branches;
next	;

1.4.24.1
date	2003.12.14.20.28.14;	author drow;	state Exp;
branches;
next	1.4.24.2;

1.4.24.2
date	2004.01.13.16.12.22;	author drow;	state Exp;
branches;
next	1.4.24.3;

1.4.24.3
date	2004.02.09.19.44.03;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.53;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.08.02.23.47.58;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.07.09.16.21.20;	author ezannoni;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.08.23.22.02.28;	author ezannoni;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.20.20.05.37;	author ezannoni;	state Exp;
branches;
next	;


desc
@@


1.12
log
@	* readline.c (bind_arrow_keys_internal):
	Handle VK_HOME, VK_END, VK_DELETE and VK_INSERT for mingw
	hosts.
@
text
@/* readline.c -- a general facility for reading lines of input
   with emacs style editing and completion. */

/* Copyright (C) 1987-2009 Free Software Foundation, Inc.

   This file is part of the GNU Readline Library (Readline), a library
   for reading lines of text with interactive input and history editing.      

   Readline is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Readline is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Readline.  If not, see <http://www.gnu.org/licenses/>.
*/

#define READLINE_LIBRARY

#if defined (HAVE_CONFIG_H)
#  include <config.h>
#endif

#include <sys/types.h>
#include "posixstat.h"
#include <fcntl.h>
#if defined (HAVE_SYS_FILE_H)
#  include <sys/file.h>
#endif /* HAVE_SYS_FILE_H */

#if defined (HAVE_UNISTD_H)
#  include <unistd.h>
#endif /* HAVE_UNISTD_H */

#if defined (HAVE_STDLIB_H)
#  include <stdlib.h>
#else
#  include "ansi_stdlib.h"
#endif /* HAVE_STDLIB_H */

#if defined (HAVE_LOCALE_H)
#  include <locale.h>
#endif

#include <stdio.h>
#include "posixjmp.h"
#include <errno.h>

#if !defined (errno)
extern int errno;
#endif /* !errno */

/* System-specific feature definitions and include files. */
#include "rldefs.h"
#include "rlmbutil.h"

#if defined (__EMX__)
#  define INCL_DOSPROCESS
#  include <os2.h>
#endif /* __EMX__ */

/* Some standard library routines. */
#include "readline.h"
#include "history.h"

#include "rlprivate.h"
#include "rlshell.h"
#include "xmalloc.h"

#ifndef RL_LIBRARY_VERSION
#  define RL_LIBRARY_VERSION "5.1"
#endif

#ifndef RL_READLINE_VERSION
#  define RL_READLINE_VERSION	0x0501
#endif

extern void _rl_free_history_entry PARAMS((HIST_ENTRY *));

/* Forward declarations used in this file. */
static char *readline_internal PARAMS((void));
static void readline_initialize_everything PARAMS((void));

static void bind_arrow_keys_internal PARAMS((Keymap));
static void bind_arrow_keys PARAMS((void));

static void readline_default_bindings PARAMS((void));
static void reset_default_bindings PARAMS((void));

static int _rl_subseq_result PARAMS((int, Keymap, int, int));
static int _rl_subseq_getchar PARAMS((int));

/* **************************************************************** */
/*								    */
/*			Line editing input utility		    */
/*								    */
/* **************************************************************** */

const char *rl_library_version = RL_LIBRARY_VERSION;

int rl_readline_version = RL_READLINE_VERSION;

/* True if this is `real' readline as opposed to some stub substitute. */
int rl_gnu_readline_p = 1;

/* A pointer to the keymap that is currently in use.
   By default, it is the standard emacs keymap. */
Keymap _rl_keymap = emacs_standard_keymap;


/* The current style of editing. */
int rl_editing_mode = emacs_mode;

/* The current insert mode:  input (the default) or overwrite */
int rl_insert_mode = RL_IM_DEFAULT;

/* Non-zero if we called this function from _rl_dispatch().  It's present
   so functions can find out whether they were called from a key binding
   or directly from an application. */
int rl_dispatching;

/* Non-zero if the previous command was a kill command. */
int _rl_last_command_was_kill = 0;

/* The current value of the numeric argument specified by the user. */
int rl_numeric_arg = 1;

/* Non-zero if an argument was typed. */
int rl_explicit_arg = 0;

/* Temporary value used while generating the argument. */
int rl_arg_sign = 1;

/* Non-zero means we have been called at least once before. */
static int rl_initialized;

#if 0
/* If non-zero, this program is running in an EMACS buffer. */
static int running_in_emacs;
#endif

/* Flags word encapsulating the current readline state. */
int rl_readline_state = RL_STATE_NONE;

/* The current offset in the current input line. */
int rl_point;

/* Mark in the current input line. */
int rl_mark;

/* Length of the current input line. */
int rl_end;

/* Make this non-zero to return the current input_line. */
int rl_done;

/* The last function executed by readline. */
rl_command_func_t *rl_last_func = (rl_command_func_t *)NULL;

/* Top level environment for readline_internal (). */
procenv_t _rl_top_level;

/* The streams we interact with. */
FILE *_rl_in_stream, *_rl_out_stream;

/* The names of the streams that we do input and output to. */
FILE *rl_instream = (FILE *)NULL;
FILE *rl_outstream = (FILE *)NULL;

/* Non-zero means echo characters as they are read.  Defaults to no echo;
   set to 1 if there is a controlling terminal, we can get its attributes,
   and the attributes include `echo'.  Look at rltty.c:prepare_terminal_settings
   for the code that sets it. */
int _rl_echoing_p = 0;

/* Current prompt. */
char *rl_prompt = (char *)NULL;
int rl_visible_prompt_length = 0;

/* Set to non-zero by calling application if it has already printed rl_prompt
   and does not want readline to do it the first time. */
int rl_already_prompted = 0;

/* The number of characters read in order to type this complete command. */
int rl_key_sequence_length = 0;

/* If non-zero, then this is the address of a function to call just
   before readline_internal_setup () prints the first prompt. */
rl_hook_func_t *rl_startup_hook = (rl_hook_func_t *)NULL;

/* If non-zero, this is the address of a function to call just before
   readline_internal_setup () returns and readline_internal starts
   reading input characters. */
rl_hook_func_t *rl_pre_input_hook = (rl_hook_func_t *)NULL;

/* What we use internally.  You should always refer to RL_LINE_BUFFER. */
static char *the_line;

/* The character that can generate an EOF.  Really read from
   the terminal driver... just defaulted here. */
int _rl_eof_char = CTRL ('D');

/* Non-zero makes this the next keystroke to read. */
int rl_pending_input = 0;

/* Pointer to a useful terminal name. */
const char *rl_terminal_name = (const char *)NULL;

/* Non-zero means to always use horizontal scrolling in line display. */
int _rl_horizontal_scroll_mode = 0;

/* Non-zero means to display an asterisk at the starts of history lines
   which have been modified. */
int _rl_mark_modified_lines = 0;  

/* The style of `bell' notification preferred.  This can be set to NO_BELL,
   AUDIBLE_BELL, or VISIBLE_BELL. */
int _rl_bell_preference = AUDIBLE_BELL;
     
/* String inserted into the line by rl_insert_comment (). */
char *_rl_comment_begin;

/* Keymap holding the function currently being executed. */
Keymap rl_executing_keymap;

/* Keymap we're currently using to dispatch. */
Keymap _rl_dispatching_keymap;

/* Non-zero means to erase entire line, including prompt, on empty input lines. */
int rl_erase_empty_line = 0;

/* Non-zero means to read only this many characters rather than up to a
   character bound to accept-line. */
int rl_num_chars_to_read;

/* Line buffer and maintenence. */
char *rl_line_buffer = (char *)NULL;
int rl_line_buffer_len = 0;

/* Key sequence `contexts' */
_rl_keyseq_cxt *_rl_kscxt = 0;

/* Forward declarations used by the display, termcap, and history code. */

/* **************************************************************** */
/*								    */
/*			`Forward' declarations  		    */
/*								    */
/* **************************************************************** */

/* Non-zero means do not parse any lines other than comments and
   parser directives. */
unsigned char _rl_parsing_conditionalized_out = 0;

/* Non-zero means to convert characters with the meta bit set to
   escape-prefixed characters so we can indirect through
   emacs_meta_keymap or vi_escape_keymap. */
int _rl_convert_meta_chars_to_ascii = 1;

/* Non-zero means to output characters with the meta bit set directly
   rather than as a meta-prefixed escape sequence. */
int _rl_output_meta_chars = 0;

/* Non-zero means to look at the termios special characters and bind
   them to equivalent readline functions at startup. */
int _rl_bind_stty_chars = 1;

/* Non-zero means to go through the history list at every newline (or
   whenever rl_done is set and readline returns) and revert each line to
   its initial state. */
int _rl_revert_all_at_newline = 0;

/* Non-zero means to honor the termios ECHOCTL bit and echo control
   characters corresponding to keyboard-generated signals. */
int _rl_echo_control_chars = 1;

/* **************************************************************** */
/*								    */
/*			Top Level Functions			    */
/*								    */
/* **************************************************************** */

/* Non-zero means treat 0200 bit in terminal input as Meta bit. */
int _rl_meta_flag = 0;	/* Forward declaration */

/* Set up the prompt and expand it.  Called from readline() and
   rl_callback_handler_install (). */
int
rl_set_prompt (prompt)
     const char *prompt;
{
  FREE (rl_prompt);
  rl_prompt = prompt ? savestring (prompt) : (char *)NULL;
  rl_display_prompt = rl_prompt ? rl_prompt : "";

  rl_visible_prompt_length = rl_expand_prompt (rl_prompt);
  return 0;
}
  
/* Read a line of input.  Prompt with PROMPT.  An empty PROMPT means
   none.  A return value of NULL means that EOF was encountered. */
char *
readline (prompt)
     const char *prompt;
{
  char *value;
#if 0
  int in_callback;
#endif

  /* If we are at EOF return a NULL string. */
  if (rl_pending_input == EOF)
    {
      rl_clear_pending_input ();
      return ((char *)NULL);
    }

#if 0
  /* If readline() is called after installing a callback handler, temporarily
     turn off the callback state to avoid ensuing messiness.  Patch supplied
     by the gdb folks.  XXX -- disabled.  This can be fooled and readline
     left in a strange state by a poorly-timed longjmp. */
  if (in_callback = RL_ISSTATE (RL_STATE_CALLBACK))
    RL_UNSETSTATE (RL_STATE_CALLBACK);
#endif

  rl_set_prompt (prompt);

  rl_initialize ();
  if (rl_prep_term_function)
    (*rl_prep_term_function) (_rl_meta_flag);

#if defined (HANDLE_SIGNALS)
  rl_set_signals ();
#endif

  value = readline_internal ();
  if (rl_deprep_term_function)
    (*rl_deprep_term_function) ();

#if defined (HANDLE_SIGNALS)
  rl_clear_signals ();
#endif

#if 0
  if (in_callback)
    RL_SETSTATE (RL_STATE_CALLBACK);
#endif

  return (value);
}

#if defined (READLINE_CALLBACKS)
#  define STATIC_CALLBACK
#else
#  define STATIC_CALLBACK static
#endif

STATIC_CALLBACK void
readline_internal_setup ()
{
  char *nprompt;

  _rl_in_stream = rl_instream;
  _rl_out_stream = rl_outstream;

  if (rl_startup_hook)
    (*rl_startup_hook) ();

  /* If we're not echoing, we still want to at least print a prompt, because
     rl_redisplay will not do it for us.  If the calling application has a
     custom redisplay function, though, let that function handle it. */
  if (_rl_echoing_p == 0 && rl_redisplay_function == rl_redisplay)
    {
      if (rl_prompt && rl_already_prompted == 0)
	{
	  nprompt = _rl_strip_prompt (rl_prompt);
	  fprintf (_rl_out_stream, "%s", nprompt);
	  fflush (_rl_out_stream);
	  xfree (nprompt);
	}
    }
  else
    {
      if (rl_prompt && rl_already_prompted)
	rl_on_new_line_with_prompt ();
      else
	rl_on_new_line ();
      (*rl_redisplay_function) ();
    }

#if defined (VI_MODE)
  if (rl_editing_mode == vi_mode)
    rl_vi_insert_mode (1, 'i');
#endif /* VI_MODE */

  if (rl_pre_input_hook)
    (*rl_pre_input_hook) ();

  RL_CHECK_SIGNALS ();
}

STATIC_CALLBACK char *
readline_internal_teardown (eof)
     int eof;
{
  char *temp;
  HIST_ENTRY *entry;

  RL_CHECK_SIGNALS ();

  /* Restore the original of this history line, iff the line that we
     are editing was originally in the history, AND the line has changed. */
  entry = current_history ();

  if (entry && rl_undo_list)
    {
      temp = savestring (the_line);
      rl_revert_line (1, 0);
      entry = replace_history_entry (where_history (), the_line, (histdata_t)NULL);
      _rl_free_history_entry (entry);

      strcpy (the_line, temp);
      xfree (temp);
    }

  if (_rl_revert_all_at_newline)
    _rl_revert_all_lines ();

  /* At any rate, it is highly likely that this line has an undo list.  Get
     rid of it now. */
  if (rl_undo_list)
    rl_free_undo_list ();

  /* Restore normal cursor, if available. */
  _rl_set_insert_mode (RL_IM_INSERT, 0);

  return (eof ? (char *)NULL : savestring (the_line));
}

void
_rl_internal_char_cleanup ()
{
#if defined (VI_MODE)
  /* In vi mode, when you exit insert mode, the cursor moves back
     over the previous character.  We explicitly check for that here. */
  if (rl_editing_mode == vi_mode && _rl_keymap == vi_movement_keymap)
    rl_vi_check ();
#endif /* VI_MODE */

  if (rl_num_chars_to_read && rl_end >= rl_num_chars_to_read)
    {
      (*rl_redisplay_function) ();
      _rl_want_redisplay = 0;
      rl_newline (1, '\n');
    }

  if (rl_done == 0)
    {
      (*rl_redisplay_function) ();
      _rl_want_redisplay = 0;
    }

  /* If the application writer has told us to erase the entire line if
     the only character typed was something bound to rl_newline, do so. */
  if (rl_erase_empty_line && rl_done && rl_last_func == rl_newline &&
      rl_point == 0 && rl_end == 0)
    _rl_erase_entire_line ();
}

STATIC_CALLBACK int
#if defined (READLINE_CALLBACKS)
readline_internal_char ()
#else
readline_internal_charloop ()
#endif
{
  static int lastc, eof_found;
  int c, code, lk;

  lastc = -1;
  eof_found = 0;

#if !defined (READLINE_CALLBACKS)
  while (rl_done == 0)
    {
#endif
      lk = _rl_last_command_was_kill;

      code = setjmp (_rl_top_level);

      if (code)
	{
	  (*rl_redisplay_function) ();
	  _rl_want_redisplay = 0;
	  /* If we get here, we're not being called from something dispatched
	     from _rl_callback_read_char(), which sets up its own value of
	     _rl_top_level (saving and restoring the old, of course), so
	     we can just return here. */
	  if (RL_ISSTATE (RL_STATE_CALLBACK))
	    return (0);
	}

      if (rl_pending_input == 0)
	{
	  /* Then initialize the argument and number of keys read. */
	  _rl_reset_argument ();
	  rl_key_sequence_length = 0;
	}

      RL_SETSTATE(RL_STATE_READCMD);
      c = rl_read_key ();
      RL_UNSETSTATE(RL_STATE_READCMD);

      /* look at input.c:rl_getc() for the circumstances under which this will
	 be returned; punt immediately on read error without converting it to
	 a newline. */
      if (c == READERR)
	{
#if defined (READLINE_CALLBACKS)
	  RL_SETSTATE(RL_STATE_DONE);
	  return (rl_done = 1);
#else
	  eof_found = 1;
	  break;
#endif
	}

      /* EOF typed to a non-blank line is a <NL>. */
      if (c == EOF && rl_end)
	c = NEWLINE;

      /* The character _rl_eof_char typed to blank line, and not as the
	 previous character is interpreted as EOF. */
      if (((c == _rl_eof_char && lastc != c) || c == EOF) && !rl_end)
	{
#if defined (READLINE_CALLBACKS)
	  RL_SETSTATE(RL_STATE_DONE);
	  return (rl_done = 1);
#else
	  eof_found = 1;
	  break;
#endif
	}

      lastc = c;
      _rl_dispatch ((unsigned char)c, _rl_keymap);
      RL_CHECK_SIGNALS ();

      /* If there was no change in _rl_last_command_was_kill, then no kill
	 has taken place.  Note that if input is pending we are reading
	 a prefix command, so nothing has changed yet. */
      if (rl_pending_input == 0 && lk == _rl_last_command_was_kill)
	_rl_last_command_was_kill = 0;

      _rl_internal_char_cleanup ();

#if defined (READLINE_CALLBACKS)
      return 0;
#else
    }

  return (eof_found);
#endif
}

#if defined (READLINE_CALLBACKS)
static int
readline_internal_charloop ()
{
  int eof = 1;

  while (rl_done == 0)
    eof = readline_internal_char ();
  return (eof);
}
#endif /* READLINE_CALLBACKS */

/* Read a line of input from the global rl_instream, doing output on
   the global rl_outstream.
   If rl_prompt is non-null, then that is our prompt. */
static char *
readline_internal ()
{
  int eof;

  readline_internal_setup ();
  eof = readline_internal_charloop ();
  return (readline_internal_teardown (eof));
}

void
_rl_init_line_state ()
{
  rl_point = rl_end = rl_mark = 0;
  the_line = rl_line_buffer;
  the_line[0] = 0;
}

void
_rl_set_the_line ()
{
  the_line = rl_line_buffer;
}

#if defined (READLINE_CALLBACKS)
_rl_keyseq_cxt *
_rl_keyseq_cxt_alloc ()
{
  _rl_keyseq_cxt *cxt;

  cxt = (_rl_keyseq_cxt *)xmalloc (sizeof (_rl_keyseq_cxt));

  cxt->flags = cxt->subseq_arg = cxt->subseq_retval = 0;

  cxt->okey = 0;
  cxt->ocxt = _rl_kscxt;
  cxt->childval = 42;		/* sentinel value */

  return cxt;
}

void
_rl_keyseq_cxt_dispose (cxt)
    _rl_keyseq_cxt *cxt;
{
  xfree (cxt);
}

void
_rl_keyseq_chain_dispose ()
{
  _rl_keyseq_cxt *cxt;

  while (_rl_kscxt)
    {
      cxt = _rl_kscxt;
      _rl_kscxt = _rl_kscxt->ocxt;
      _rl_keyseq_cxt_dispose (cxt);
    }
}
#endif

static int
_rl_subseq_getchar (key)
     int key;
{
  int k;

  if (key == ESC)
    RL_SETSTATE(RL_STATE_METANEXT);
  RL_SETSTATE(RL_STATE_MOREINPUT);
  k = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);
  if (key == ESC)
    RL_UNSETSTATE(RL_STATE_METANEXT);

  return k;
}

#if defined (READLINE_CALLBACKS)
int
_rl_dispatch_callback (cxt)
     _rl_keyseq_cxt *cxt;
{
  int nkey, r;

  /* For now */
  /* The first time this context is used, we want to read input and dispatch
     on it.  When traversing the chain of contexts back `up', we want to use
     the value from the next context down.  We're simulating recursion using
     a chain of contexts. */
  if ((cxt->flags & KSEQ_DISPATCHED) == 0)
    {
      nkey = _rl_subseq_getchar (cxt->okey);
      if (nkey < 0)
	{
	  _rl_abort_internal ();
	  return -1;
	}
      r = _rl_dispatch_subseq (nkey, cxt->dmap, cxt->subseq_arg);
      cxt->flags |= KSEQ_DISPATCHED;
    }
  else
    r = cxt->childval;

  /* For now */
  if (r != -3)	/* don't do this if we indicate there will be other matches */
    r = _rl_subseq_result (r, cxt->oldmap, cxt->okey, (cxt->flags & KSEQ_SUBSEQ));

  RL_CHECK_SIGNALS ();
  if (r == 0)			/* success! */
    {
      _rl_keyseq_chain_dispose ();
      RL_UNSETSTATE (RL_STATE_MULTIKEY);
      return r;
    }

  if (r != -3)			/* magic value that says we added to the chain */
    _rl_kscxt = cxt->ocxt;
  if (_rl_kscxt)
    _rl_kscxt->childval = r;
  if (r != -3)
    _rl_keyseq_cxt_dispose (cxt);

  return r;
}
#endif /* READLINE_CALLBACKS */
  
/* Do the command associated with KEY in MAP.
   If the associated command is really a keymap, then read
   another key, and dispatch into that map. */
int
_rl_dispatch (key, map)
     register int key;
     Keymap map;
{
  _rl_dispatching_keymap = map;
  return _rl_dispatch_subseq (key, map, 0);
}

int
_rl_dispatch_subseq (key, map, got_subseq)
     register int key;
     Keymap map;
     int got_subseq;
{
  int r, newkey;
  char *macro;
  rl_command_func_t *func;
#if defined (READLINE_CALLBACKS)
  _rl_keyseq_cxt *cxt;
#endif

  if (META_CHAR (key) && _rl_convert_meta_chars_to_ascii)
    {
      if (map[ESC].type == ISKMAP)
	{
	  if (RL_ISSTATE (RL_STATE_MACRODEF))
	    _rl_add_macro_char (ESC);
	  map = FUNCTION_TO_KEYMAP (map, ESC);
	  key = UNMETA (key);
	  rl_key_sequence_length += 2;
	  return (_rl_dispatch (key, map));
	}
      else
	rl_ding ();
      return 0;
    }

  if (RL_ISSTATE (RL_STATE_MACRODEF))
    _rl_add_macro_char (key);

  r = 0;
  switch (map[key].type)
    {
    case ISFUNC:
      func = map[key].function;
      if (func)
	{
	  /* Special case rl_do_lowercase_version (). */
	  if (func == rl_do_lowercase_version)
	    return (_rl_dispatch (_rl_to_lower (key), map));

	  rl_executing_keymap = map;

	  rl_dispatching = 1;
	  RL_SETSTATE(RL_STATE_DISPATCHING);
	  (*map[key].function)(rl_numeric_arg * rl_arg_sign, key);
	  RL_UNSETSTATE(RL_STATE_DISPATCHING);
	  rl_dispatching = 0;

	  /* If we have input pending, then the last command was a prefix
	     command.  Don't change the state of rl_last_func.  Otherwise,
	     remember the last command executed in this variable. */
	  if (rl_pending_input == 0 && map[key].function != rl_digit_argument)
	    rl_last_func = map[key].function;

	  RL_CHECK_SIGNALS ();
	}
      else if (map[ANYOTHERKEY].function)
	{
	  /* OK, there's no function bound in this map, but there is a
	     shadow function that was overridden when the current keymap
	     was created.  Return -2 to note  that. */
	  _rl_unget_char  (key);
	  return -2;
	}
      else if (got_subseq)
	{
	  /* Return -1 to note that we're in a subsequence, but  we don't
	     have a matching key, nor was one overridden.  This means
	     we need to back up the recursion chain and find the last
	     subsequence that is bound to a function. */
	  _rl_unget_char (key);
	  return -1;
	}
      else
	{
#if defined (READLINE_CALLBACKS)
	  RL_UNSETSTATE (RL_STATE_MULTIKEY);
	  _rl_keyseq_chain_dispose ();
#endif
	  _rl_abort_internal ();
	  return -1;
	}
      break;

    case ISKMAP:
      if (map[key].function != 0)
	{
#if defined (VI_MODE)
	  /* The only way this test will be true is if a subsequence has been
	     bound starting with ESC, generally the arrow keys.  What we do is
	     check whether there's input in the queue, which there generally
	     will be if an arrow key has been pressed, and, if there's not,
	     just dispatch to (what we assume is) rl_vi_movement_mode right
	     away.  This is essentially an input test with a zero timeout. */
	  if (rl_editing_mode == vi_mode && key == ESC && map == vi_insertion_keymap
	      && _rl_input_queued (0) == 0)
	    return (_rl_dispatch (ANYOTHERKEY, FUNCTION_TO_KEYMAP (map, key)));
#endif

	  rl_key_sequence_length++;
	  _rl_dispatching_keymap = FUNCTION_TO_KEYMAP (map, key);

	  /* Allocate new context here.  Use linked contexts (linked through
	     cxt->ocxt) to simulate recursion */
#if defined (READLINE_CALLBACKS)
	  if (RL_ISSTATE (RL_STATE_CALLBACK))
	    {
	      /* Return 0 only the first time, to indicate success to
		 _rl_callback_read_char.  The rest of the time, we're called
		 from _rl_dispatch_callback, so we return -3 to indicate
		 special handling is necessary. */
	      r = RL_ISSTATE (RL_STATE_MULTIKEY) ? -3 : 0;
	      cxt = _rl_keyseq_cxt_alloc ();

	      if (got_subseq)
		cxt->flags |= KSEQ_SUBSEQ;
	      cxt->okey = key;
	      cxt->oldmap = map;
	      cxt->dmap = _rl_dispatching_keymap;
	      cxt->subseq_arg = got_subseq || cxt->dmap[ANYOTHERKEY].function;

	      RL_SETSTATE (RL_STATE_MULTIKEY);
	      _rl_kscxt = cxt;

	      return r;		/* don't indicate immediate success */
	    }
#endif

	  newkey = _rl_subseq_getchar (key);
	  if (newkey < 0)
	    {
	      _rl_abort_internal ();
	      return -1;
	    }

	  r = _rl_dispatch_subseq (newkey, _rl_dispatching_keymap, got_subseq || map[ANYOTHERKEY].function);
	  return _rl_subseq_result (r, map, key, got_subseq);
	}
      else
	{
	  _rl_abort_internal ();
	  return -1;
	}
      break;

    case ISMACR:
      if (map[key].function != 0)
	{
	  macro = savestring ((char *)map[key].function);
	  _rl_with_macro_input (macro);
	  return 0;
	}
      break;
    }
#if defined (VI_MODE)
  if (rl_editing_mode == vi_mode && _rl_keymap == vi_movement_keymap &&
      key != ANYOTHERKEY &&
      _rl_vi_textmod_command (key))
    _rl_vi_set_last (key, rl_numeric_arg, rl_arg_sign);
#endif

  return (r);
}

static int
_rl_subseq_result (r, map, key, got_subseq)
     int r;
     Keymap map;
     int key, got_subseq;
{
  Keymap m;
  int type, nt;
  rl_command_func_t *func, *nf;

  if (r == -2)
    /* We didn't match anything, and the keymap we're indexed into
       shadowed a function previously bound to that prefix.  Call
       the function.  The recursive call to _rl_dispatch_subseq has
       already taken care of pushing any necessary input back onto
       the input queue with _rl_unget_char. */
    {
      m = _rl_dispatching_keymap;
      type = m[ANYOTHERKEY].type;
      func = m[ANYOTHERKEY].function;
      if (type == ISFUNC && func == rl_do_lowercase_version)
	r = _rl_dispatch (_rl_to_lower (key), map);
      else if (type == ISFUNC && func == rl_insert)
	{
	  /* If the function that was shadowed was self-insert, we
	     somehow need a keymap with map[key].func == self-insert.
	     Let's use this one. */
	  nt = m[key].type;
	  nf = m[key].function;

	  m[key].type = type;
	  m[key].function = func;
	  r = _rl_dispatch (key, m);
	  m[key].type = nt;
	  m[key].function = nf;
	}
      else
	r = _rl_dispatch (ANYOTHERKEY, m);
    }
  else if (r && map[ANYOTHERKEY].function)
    {
      /* We didn't match (r is probably -1), so return something to
	 tell the caller that it should try ANYOTHERKEY for an
	 overridden function. */
      _rl_unget_char (key);
      _rl_dispatching_keymap = map;
      return -2;
    }
  else if (r && got_subseq)
    {
      /* OK, back up the chain. */
      _rl_unget_char (key);
      _rl_dispatching_keymap = map;
      return -1;
    }

  return r;
}

/* **************************************************************** */
/*								    */
/*			Initializations 			    */
/*								    */
/* **************************************************************** */

/* Initialize readline (and terminal if not already). */
int
rl_initialize ()
{
  /* If we have never been called before, initialize the
     terminal and data structures. */
  if (!rl_initialized)
    {
      RL_SETSTATE(RL_STATE_INITIALIZING);
      readline_initialize_everything ();
      RL_UNSETSTATE(RL_STATE_INITIALIZING);
      rl_initialized++;
      RL_SETSTATE(RL_STATE_INITIALIZED);
    }

  /* Initalize the current line information. */
  _rl_init_line_state ();

  /* We aren't done yet.  We haven't even gotten started yet! */
  rl_done = 0;
  RL_UNSETSTATE(RL_STATE_DONE);

  /* Tell the history routines what is going on. */
  _rl_start_using_history ();

  /* Make the display buffer match the state of the line. */
  rl_reset_line_state ();

  /* No such function typed yet. */
  rl_last_func = (rl_command_func_t *)NULL;

  /* Parsing of key-bindings begins in an enabled state. */
  _rl_parsing_conditionalized_out = 0;

#if defined (VI_MODE)
  if (rl_editing_mode == vi_mode)
    _rl_vi_initialize_line ();
#endif

  /* Each line starts in insert mode (the default). */
  _rl_set_insert_mode (RL_IM_DEFAULT, 1);

  return 0;
}

#if 0
#if defined (__EMX__)
static void
_emx_build_environ ()
{
  TIB *tibp;
  PIB *pibp;
  char *t, **tp;
  int c;

  DosGetInfoBlocks (&tibp, &pibp);
  t = pibp->pib_pchenv;
  for (c = 1; *t; c++)
    t += strlen (t) + 1;
  tp = environ = (char **)xmalloc ((c + 1) * sizeof (char *));
  t = pibp->pib_pchenv;
  while (*t)
    {
      *tp++ = t;
      t += strlen (t) + 1;
    }
  *tp = 0;
}
#endif /* __EMX__ */
#endif

/* Initialize the entire state of the world. */
static void
readline_initialize_everything ()
{
#if 0
#if defined (__EMX__)
  if (environ == 0)
    _emx_build_environ ();
#endif
#endif

#if 0
  /* Find out if we are running in Emacs -- UNUSED. */
  running_in_emacs = sh_get_env_value ("EMACS") != (char *)0;
#endif

  /* Set up input and output if they are not already set up. */
  if (!rl_instream)
    rl_instream = stdin;

  if (!rl_outstream)
    rl_outstream = stdout;

  /* Bind _rl_in_stream and _rl_out_stream immediately.  These values
     may change, but they may also be used before readline_internal ()
     is called. */
  _rl_in_stream = rl_instream;
  _rl_out_stream = rl_outstream;

  /* Allocate data structures. */
  if (rl_line_buffer == 0)
    rl_line_buffer = (char *)xmalloc (rl_line_buffer_len = DEFAULT_BUFFER_SIZE);

  /* Initialize the terminal interface. */
  if (rl_terminal_name == 0)
    rl_terminal_name = sh_get_env_value ("TERM");
  _rl_init_terminal_io (rl_terminal_name);

  /* Bind tty characters to readline functions. */
  readline_default_bindings ();

  /* Initialize the function names. */
  rl_initialize_funmap ();

  /* Decide whether we should automatically go into eight-bit mode. */
  _rl_init_eightbit ();
      
  /* Read in the init file. */
  rl_read_init_file ((char *)NULL);

  /* XXX */
  if (_rl_horizontal_scroll_mode && _rl_term_autowrap)
    {
      _rl_screenwidth--;
      _rl_screenchars -= _rl_screenheight;
    }

  /* Override the effect of any `set keymap' assignments in the
     inputrc file. */
  rl_set_keymap_from_edit_mode ();

  /* Try to bind a common arrow key prefix, if not already bound. */
  bind_arrow_keys ();

  /* Enable the meta key, if this terminal has one. */
  if (_rl_enable_meta)
    _rl_enable_meta_key ();

  /* If the completion parser's default word break characters haven't
     been set yet, then do so now. */
  if (rl_completer_word_break_characters == (char *)NULL)
    rl_completer_word_break_characters = (char *)rl_basic_word_break_characters;
}

/* If this system allows us to look at the values of the regular
   input editing characters, then bind them to their readline
   equivalents, iff the characters are not bound to keymaps. */
static void
readline_default_bindings ()
{
  if (_rl_bind_stty_chars)
    rl_tty_set_default_bindings (_rl_keymap);
}

/* Reset the default bindings for the terminal special characters we're
   interested in back to rl_insert and read the new ones. */
static void
reset_default_bindings ()
{
  if (_rl_bind_stty_chars)
    {
      rl_tty_unset_default_bindings (_rl_keymap);
      rl_tty_set_default_bindings (_rl_keymap);
    }
}

/* Bind some common arrow key sequences in MAP. */
static void
bind_arrow_keys_internal (map)
     Keymap map;
{
  Keymap xkeymap;

  xkeymap = _rl_keymap;
  _rl_keymap = map;

#if defined (__MSDOS__)
  rl_bind_keyseq_if_unbound ("\033[0A", rl_get_previous_history);
  rl_bind_keyseq_if_unbound ("\033[0B", rl_backward_char);
  rl_bind_keyseq_if_unbound ("\033[0C", rl_forward_char);
  rl_bind_keyseq_if_unbound ("\033[0D", rl_get_next_history);
#endif

  rl_bind_keyseq_if_unbound ("\033[A", rl_get_previous_history);
  rl_bind_keyseq_if_unbound ("\033[B", rl_get_next_history);
  rl_bind_keyseq_if_unbound ("\033[C", rl_forward_char);
  rl_bind_keyseq_if_unbound ("\033[D", rl_backward_char);
  rl_bind_keyseq_if_unbound ("\033[H", rl_beg_of_line);
  rl_bind_keyseq_if_unbound ("\033[F", rl_end_of_line);

  rl_bind_keyseq_if_unbound ("\033OA", rl_get_previous_history);
  rl_bind_keyseq_if_unbound ("\033OB", rl_get_next_history);
  rl_bind_keyseq_if_unbound ("\033OC", rl_forward_char);
  rl_bind_keyseq_if_unbound ("\033OD", rl_backward_char);
  rl_bind_keyseq_if_unbound ("\033OH", rl_beg_of_line);
  rl_bind_keyseq_if_unbound ("\033OF", rl_end_of_line);

#if defined (__MINGW32__)
  rl_bind_keyseq_if_unbound ("\340H", rl_get_previous_history);
  rl_bind_keyseq_if_unbound ("\340P", rl_get_next_history);
  rl_bind_keyseq_if_unbound ("\340M", rl_forward_char);
  rl_bind_keyseq_if_unbound ("\340K", rl_backward_char);
  rl_bind_keyseq_if_unbound ("\340G", rl_beg_of_line);
  rl_bind_keyseq_if_unbound ("\340O", rl_end_of_line);
  rl_bind_keyseq_if_unbound ("\340S", rl_delete);
  rl_bind_keyseq_if_unbound ("\340R", rl_overwrite_mode);
#endif

  _rl_keymap = xkeymap;
}

/* Try and bind the common arrow key prefixes after giving termcap and
   the inputrc file a chance to bind them and create `real' keymaps
   for the arrow key prefix. */
static void
bind_arrow_keys ()
{
  bind_arrow_keys_internal (emacs_standard_keymap);

#if defined (VI_MODE)
  bind_arrow_keys_internal (vi_movement_keymap);
  /* Unbind vi_movement_keymap[ESC] to allow users to repeatedly hit ESC
     in vi command mode while still allowing the arrow keys to work. */
  if (vi_movement_keymap[ESC].type == ISKMAP)
    rl_bind_keyseq_in_map ("\033", (rl_command_func_t *)NULL, vi_movement_keymap);
  bind_arrow_keys_internal (vi_insertion_keymap);
#endif
}

/* **************************************************************** */
/*								    */
/*		Saving and Restoring Readline's state		    */
/*								    */
/* **************************************************************** */

int
rl_save_state (sp)
     struct readline_state *sp;
{
  if (sp == 0)
    return -1;

  sp->point = rl_point;
  sp->end = rl_end;
  sp->mark = rl_mark;
  sp->buffer = rl_line_buffer;
  sp->buflen = rl_line_buffer_len;
  sp->ul = rl_undo_list;
  sp->prompt = rl_prompt;

  sp->rlstate = rl_readline_state;
  sp->done = rl_done;
  sp->kmap = _rl_keymap;

  sp->lastfunc = rl_last_func;
  sp->insmode = rl_insert_mode;
  sp->edmode = rl_editing_mode;
  sp->kseqlen = rl_key_sequence_length;
  sp->inf = rl_instream;
  sp->outf = rl_outstream;
  sp->pendingin = rl_pending_input;
  sp->macro = rl_executing_macro;

  sp->catchsigs = rl_catch_signals;
  sp->catchsigwinch = rl_catch_sigwinch;

  return (0);
}

int
rl_restore_state (sp)
     struct readline_state *sp;
{
  if (sp == 0)
    return -1;

  rl_point = sp->point;
  rl_end = sp->end;
  rl_mark = sp->mark;
  the_line = rl_line_buffer = sp->buffer;
  rl_line_buffer_len = sp->buflen;
  rl_undo_list = sp->ul;
  rl_prompt = sp->prompt;

  rl_readline_state = sp->rlstate;
  rl_done = sp->done;
  _rl_keymap = sp->kmap;

  rl_last_func = sp->lastfunc;
  rl_insert_mode = sp->insmode;
  rl_editing_mode = sp->edmode;
  rl_key_sequence_length = sp->kseqlen;
  rl_instream = sp->inf;
  rl_outstream = sp->outf;
  rl_pending_input = sp->pendingin;
  rl_executing_macro = sp->macro;

  rl_catch_signals = sp->catchsigs;
  rl_catch_sigwinch = sp->catchsigwinch;

  return (0);
}
@


1.11
log
@Imported readline 6.2, and upstream patch 001.

[patch 0/3] readline-6.2 rebase
http://sourceware.org/ml/gdb-patches/2011-05/msg00003.html
[patch 1/3] readline-6.2: Merge of already posted patches
http://sourceware.org/ml/gdb-patches/2011-05/msg00004.html
	=
	[Bug-readline] [RFC/readline] bind.c, rl_function_dumper, Free allocated
	http://lists.gnu.org/archive/html/bug-readline/2011-03/msg00000.html
	[Bug-readline] [patch] Fix underquotation in readline/examples/rlfe/conf
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00001.html
	[Bug-readline] [patch] Makefile.in htm<->html
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00002.html
	Re: [Bug-readline] [patch] Makefile.in dependency: callback.o: xmalloc.h
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00004.html
	[Bug-readline] [patch] Remove . from the VPATH directive
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00005.html
	Eli Zaretskii's __MSDOS__ / __GO32__ / __MINGW32__ / __DJGPP__ stuff:
	http://sourceware.org/ml/gdb/2011-04/msg00002.html
	Jan Kratochvil's patch for FSF GDB tree local-specific changes:
	http://sourceware.org/ml/gdb/2011-04/msg00006.html
	Preservation of existing ChangeLog.gdb files, their updates.
[patch 2/3] readline-6.2: Workaround "ask" regression
http://sourceware.org/ml/gdb-patches/2011-05/msg00005.html
[patch 3/3] readline-6.2: Revert 5.x compat., apply 6.x compat.
http://sourceware.org/ml/gdb-patches/2011-05/msg00006.html
[patch 4/3] readline-6.2: Substitute inc-hist.texinfo
http://sourceware.org/ml/gdb-patches/2011-05/msg00010.html

readline/
	Workaround gdb.base/completion.exp regression on readline-6.2.
	* complete.c (get_y_or_n): Disable the return on RL_STATE_CALLBACK.

	Imported readline 6.2, and upstream patch 001.
	* configure: Regenerate.

readline/doc/
	* hsuser.texi (Using History Interactively): Disable !BashFeatures
	@@defcodeindex.  Make the `Programming with GNU History' reference
	external.
	* inc-hist.texinfo: Remove.

	Imported readline 6.2, and upstream patch 001.

readline/examples/
	Imported readline 6.2, and upstream patch 001.

readline/examples/rlfe/
	Imported readline 6.2, and upstream patch 001.

gdb/
	* config.in: Regenerate.
	* configure: Regenerate.
	* configure.ac <--with-system-readline> (for readline_echoing_p):
	Remove the test.
	* tui/tui-io.c (tui_old_readline_echoing_p): Rename to ...
	(tui_old_rl_echoing_p): ... here.
	(tui_setup_io): Rename extern declaration readline_echoing_p to
	_rl_echoing_p.  Adjust assignments for the both renames.

gdb/doc/
	* Makefile.in (GDB_DOC_SOURCE_INCLUDES): Rename inc-hist.texinfo to
	hsuser.texi.
	* gdb.texinfo <!SYSTEM_READLINE>: Rename inc-hist.texinfo inclusion and
	comment to hsuser.texi.  Change rluser.texi name in the comment.
@
text
@d1162 4
@


1.10
log
@Readline 5.1 import for HEAD.
@
text
@d4 1
a4 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
d6 2
a7 2
   This file is part of the GNU Readline Library, a library for
   reading lines of text with interactive input and history editing.
d9 3
a11 3
   The GNU Readline Library is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2, or
d14 3
a16 3
   The GNU Readline Library is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
d19 4
a22 4
   The GNU General Public License is often shipped with GNU software, and
   is generally kept in a file called COPYING or LICENSE.  If you do not
   have a copy of the license, write to the Free Software Foundation,
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
d52 5
d166 1
a166 1
procenv_t readline_top_level;
d179 1
a179 1
int readline_echoing_p = 0;
d273 9
d312 3
d323 9
d350 5
d378 1
a378 1
  if (readline_echoing_p == 0 && rl_redisplay_function == rl_redisplay)
d385 1
a385 1
	  free (nprompt);
d399 1
a399 1
    rl_vi_insertion_mode (1, 'i');
d404 2
d415 2
d429 1
a429 1
      free (temp);
d432 3
d495 1
a495 1
      code = setjmp (readline_top_level);
d503 1
a503 1
	     readline_top_level (saving and restoring the old, of course), so
d520 14
d553 1
d632 1
a632 1
  free (cxt);
a673 1
#if 1
d681 5
a690 3
#else
  r = _rl_dispatch_subseq (nkey, cxt->dmap, cxt->subseq_arg);
#endif
d693 2
a694 1
  r = _rl_subseq_result (r, cxt->oldmap, cxt->okey, (cxt->flags & KSEQ_SUBSEQ));
d696 1
d783 2
d839 1
a839 1
		 from _rl_dispatch_callback, so we return 3 to indicate
d903 1
a903 1
  
d1177 4
@


1.9
log
@touched all sources to ease import of readline-5.1
@
text
@d4 1
a4 1
/* Copyright (C) 1987-2002 Free Software Foundation, Inc.
d71 1
a71 1
#  define RL_LIBRARY_VERSION "4.3"
d75 1
a75 1
#  define RL_READLINE_VERSION	0x0403
d88 4
d110 1
d226 3
d240 3
d264 4
d285 1
d309 2
a310 1
  (*rl_prep_term_function) (_rl_meta_flag);
d317 2
a318 1
  (*rl_deprep_term_function) ();
d368 1
a368 1
    rl_vi_insertion_mode (1, 0);
d408 30
d460 10
a469 1
	(*rl_redisplay_function) ();
d474 1
a474 1
	  _rl_init_argument ();
d508 1
a508 21
#if defined (VI_MODE)
      /* In vi mode, when you exit insert mode, the cursor moves back
	 over the previous character.  We explicitly check for that here. */
      if (rl_editing_mode == vi_mode && _rl_keymap == vi_movement_keymap)
	rl_vi_check ();
#endif /* VI_MODE */

      if (rl_num_chars_to_read && rl_end >= rl_num_chars_to_read)
        {
          (*rl_redisplay_function) ();
          rl_newline (1, '\n');
        }

      if (rl_done == 0)
	(*rl_redisplay_function) ();

      /* If the application writer has told us to erase the entire line if
	  the only character typed was something bound to rl_newline, do so. */
      if (rl_erase_empty_line && rl_done && rl_last_func == rl_newline &&
	  rl_point == 0 && rl_end == 0)
	_rl_erase_entire_line ();
d558 101
d667 1
d680 3
a715 4
#if 0
	  _rl_suppress_redisplay = (map[key].function == rl_insert) && _rl_input_available ();
#endif

d718 1
a718 1
	  r = (*map[key].function)(rl_numeric_arg * rl_arg_sign, key);
d747 4
d772 20
d793 2
a794 7
	  if (key == ESC)
	    RL_SETSTATE(RL_STATE_METANEXT);
	  RL_SETSTATE(RL_STATE_MOREINPUT);
	  newkey = rl_read_key ();
	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
	  if (key == ESC)
	    RL_UNSETSTATE(RL_STATE_METANEXT);
d796 5
d807 2
a808 23
	  r = _rl_dispatch_subseq (newkey, FUNCTION_TO_KEYMAP (map, key), got_subseq || map[ANYOTHERKEY].function);

	  if (r == -2)
	    /* We didn't match anything, and the keymap we're indexed into
	       shadowed a function previously bound to that prefix.  Call
	       the function.  The recursive call to _rl_dispatch_subseq has
	       already taken care of pushing any necessary input back onto
	       the input queue with _rl_unget_char. */
	    r = _rl_dispatch (ANYOTHERKEY, FUNCTION_TO_KEYMAP (map, key));
	  else if (r && map[ANYOTHERKEY].function)
	    {
	      /* We didn't match (r is probably -1), so return something to
		 tell the caller that it should try ANYOTHERKEY for an
		 overridden function. */
	      _rl_unget_char (key);
	      return -2;
	    }
	  else if (r && got_subseq)
	    {
	      /* OK, back up the chain. */
	      _rl_unget_char (key);
	      return -1;
	    }
d832 1
d836 59
d1043 1
a1043 1
    rl_completer_word_break_characters = rl_basic_word_break_characters;
d1052 14
a1065 1
  rl_tty_set_default_bindings (_rl_keymap);
d1079 26
a1104 35
   _rl_bind_if_unbound ("\033[0A", rl_get_previous_history);
   _rl_bind_if_unbound ("\033[0B", rl_backward_char);
   _rl_bind_if_unbound ("\033[0C", rl_forward_char);
   _rl_bind_if_unbound ("\033[0D", rl_get_next_history);
#endif

#ifdef __MINGW32__
   /* Under Windows, when an extend key (like an arrow key) is
      pressed, getch() will return 340 (octal) followed by a code for
      the extended key.  We use macros to transform those into the
      normal ANSI terminal sequences for these keys.  */

   /* Up arrow.  */
   rl_macro_bind ("\340H", "\033[A", map);
   /* Left arrow.  */
   rl_macro_bind ("\340K", "\033[D", map);
   /* Right arrow.  */
   rl_macro_bind ("\340M", "\033[C", map);
   /* Down arrow.  */
   rl_macro_bind ("\340P", "\033[B", map);
#endif

  _rl_bind_if_unbound ("\033[A", rl_get_previous_history);
  _rl_bind_if_unbound ("\033[B", rl_get_next_history);
  _rl_bind_if_unbound ("\033[C", rl_forward_char);
  _rl_bind_if_unbound ("\033[D", rl_backward_char);
  _rl_bind_if_unbound ("\033[H", rl_beg_of_line);
  _rl_bind_if_unbound ("\033[F", rl_end_of_line);

  _rl_bind_if_unbound ("\033OA", rl_get_previous_history);
  _rl_bind_if_unbound ("\033OB", rl_get_next_history);
  _rl_bind_if_unbound ("\033OC", rl_forward_char);
  _rl_bind_if_unbound ("\033OD", rl_backward_char);
  _rl_bind_if_unbound ("\033OH", rl_beg_of_line);
  _rl_bind_if_unbound ("\033OF", rl_end_of_line);
a1157 1
#if defined (SIGWINCH)
a1158 1
#endif
a1191 1
#if defined (SIGWINCH)
a1192 1
#endif
@


1.9.2.1
log
@Import readline 5.1 on the branch.
@
text
@d4 1
a4 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
d71 1
a71 1
#  define RL_LIBRARY_VERSION "5.1"
d75 1
a75 1
#  define RL_READLINE_VERSION	0x0501
a87 4
static void reset_default_bindings PARAMS((void));

static int _rl_subseq_result PARAMS((int, Keymap, int, int));
static int _rl_subseq_getchar PARAMS((int));
a105 1

a220 3
/* Keymap we're currently using to dispatch. */
Keymap _rl_dispatching_keymap;

a231 3
/* Key sequence `contexts' */
_rl_keyseq_cxt *_rl_kscxt = 0;

a252 4
/* Non-zero means to look at the termios special characters and bind
   them to equivalent readline functions at startup. */
int _rl_bind_stty_chars = 1;

a269 1
  rl_display_prompt = rl_prompt ? rl_prompt : "";
d293 1
a293 2
  if (rl_prep_term_function)
    (*rl_prep_term_function) (_rl_meta_flag);
d300 1
a300 2
  if (rl_deprep_term_function)
    (*rl_deprep_term_function) ();
d350 1
a350 1
    rl_vi_insertion_mode (1, 'i');
a389 30
void
_rl_internal_char_cleanup ()
{
#if defined (VI_MODE)
  /* In vi mode, when you exit insert mode, the cursor moves back
     over the previous character.  We explicitly check for that here. */
  if (rl_editing_mode == vi_mode && _rl_keymap == vi_movement_keymap)
    rl_vi_check ();
#endif /* VI_MODE */

  if (rl_num_chars_to_read && rl_end >= rl_num_chars_to_read)
    {
      (*rl_redisplay_function) ();
      _rl_want_redisplay = 0;
      rl_newline (1, '\n');
    }

  if (rl_done == 0)
    {
      (*rl_redisplay_function) ();
      _rl_want_redisplay = 0;
    }

  /* If the application writer has told us to erase the entire line if
     the only character typed was something bound to rl_newline, do so. */
  if (rl_erase_empty_line && rl_done && rl_last_func == rl_newline &&
      rl_point == 0 && rl_end == 0)
    _rl_erase_entire_line ();
}

d412 1
a412 10
	{
	  (*rl_redisplay_function) ();
	  _rl_want_redisplay = 0;
	  /* If we get here, we're not being called from something dispatched
	     from _rl_callback_read_char(), which sets up its own value of
	     readline_top_level (saving and restoring the old, of course), so
	     we can just return here. */
	  if (RL_ISSTATE (RL_STATE_CALLBACK))
	    return (0);
	}
d417 1
a417 1
	  _rl_reset_argument ();
d451 21
a471 1
      _rl_internal_char_cleanup ();
a520 101
#if defined (READLINE_CALLBACKS)
_rl_keyseq_cxt *
_rl_keyseq_cxt_alloc ()
{
  _rl_keyseq_cxt *cxt;

  cxt = (_rl_keyseq_cxt *)xmalloc (sizeof (_rl_keyseq_cxt));

  cxt->flags = cxt->subseq_arg = cxt->subseq_retval = 0;

  cxt->okey = 0;
  cxt->ocxt = _rl_kscxt;
  cxt->childval = 42;		/* sentinel value */

  return cxt;
}

void
_rl_keyseq_cxt_dispose (cxt)
    _rl_keyseq_cxt *cxt;
{
  free (cxt);
}

void
_rl_keyseq_chain_dispose ()
{
  _rl_keyseq_cxt *cxt;

  while (_rl_kscxt)
    {
      cxt = _rl_kscxt;
      _rl_kscxt = _rl_kscxt->ocxt;
      _rl_keyseq_cxt_dispose (cxt);
    }
}
#endif

static int
_rl_subseq_getchar (key)
     int key;
{
  int k;

  if (key == ESC)
    RL_SETSTATE(RL_STATE_METANEXT);
  RL_SETSTATE(RL_STATE_MOREINPUT);
  k = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);
  if (key == ESC)
    RL_UNSETSTATE(RL_STATE_METANEXT);

  return k;
}

#if defined (READLINE_CALLBACKS)
int
_rl_dispatch_callback (cxt)
     _rl_keyseq_cxt *cxt;
{
  int nkey, r;

  /* For now */
#if 1
  /* The first time this context is used, we want to read input and dispatch
     on it.  When traversing the chain of contexts back `up', we want to use
     the value from the next context down.  We're simulating recursion using
     a chain of contexts. */
  if ((cxt->flags & KSEQ_DISPATCHED) == 0)
    {
      nkey = _rl_subseq_getchar (cxt->okey);
      r = _rl_dispatch_subseq (nkey, cxt->dmap, cxt->subseq_arg);
      cxt->flags |= KSEQ_DISPATCHED;
    }
  else
    r = cxt->childval;
#else
  r = _rl_dispatch_subseq (nkey, cxt->dmap, cxt->subseq_arg);
#endif

  /* For now */
  r = _rl_subseq_result (r, cxt->oldmap, cxt->okey, (cxt->flags & KSEQ_SUBSEQ));

  if (r == 0)			/* success! */
    {
      _rl_keyseq_chain_dispose ();
      RL_UNSETSTATE (RL_STATE_MULTIKEY);
      return r;
    }

  if (r != -3)			/* magic value that says we added to the chain */
    _rl_kscxt = cxt->ocxt;
  if (_rl_kscxt)
    _rl_kscxt->childval = r;
  if (r != -3)
    _rl_keyseq_cxt_dispose (cxt);

  return r;
}
#endif /* READLINE_CALLBACKS */
  
a528 1
  _rl_dispatching_keymap = map;
a540 3
#if defined (READLINE_CALLBACKS)
  _rl_keyseq_cxt *cxt;
#endif
d574 4
d580 1
a580 1
	  (*map[key].function)(rl_numeric_arg * rl_arg_sign, key);
a608 4
#if defined (READLINE_CALLBACKS)
	  RL_UNSETSTATE (RL_STATE_MULTIKEY);
	  _rl_keyseq_chain_dispose ();
#endif
a629 1
	  _rl_dispatching_keymap = FUNCTION_TO_KEYMAP (map, key);
d631 9
a639 4
	  /* Allocate new context here.  Use linked contexts (linked through
	     cxt->ocxt) to simulate recursion */
#if defined (READLINE_CALLBACKS)
	  if (RL_ISSTATE (RL_STATE_CALLBACK))
d641 3
a643 13
	      /* Return 0 only the first time, to indicate success to
		 _rl_callback_read_char.  The rest of the time, we're called
		 from _rl_dispatch_callback, so we return 3 to indicate
		 special handling is necessary. */
	      r = RL_ISSTATE (RL_STATE_MULTIKEY) ? -3 : 0;
	      cxt = _rl_keyseq_cxt_alloc ();

	      if (got_subseq)
		cxt->flags |= KSEQ_SUBSEQ;
	      cxt->okey = key;
	      cxt->oldmap = map;
	      cxt->dmap = _rl_dispatching_keymap;
	      cxt->subseq_arg = got_subseq || cxt->dmap[ANYOTHERKEY].function;
d645 1
a645 2
	      RL_SETSTATE (RL_STATE_MULTIKEY);
	      _rl_kscxt = cxt;
d647 14
a660 1
	      return r;		/* don't indicate immediate success */
d662 1
a662 4
#endif

	  newkey = _rl_subseq_getchar (key);
	  if (newkey < 0)
d664 2
a665 1
	      _rl_abort_internal ();
a667 3

	  r = _rl_dispatch_subseq (newkey, _rl_dispatching_keymap, got_subseq || map[ANYOTHERKEY].function);
	  return _rl_subseq_result (r, map, key, got_subseq);
a690 1

a693 59
static int
_rl_subseq_result (r, map, key, got_subseq)
     int r;
     Keymap map;
     int key, got_subseq;
{
  Keymap m;
  int type, nt;
  rl_command_func_t *func, *nf;
  
  if (r == -2)
    /* We didn't match anything, and the keymap we're indexed into
       shadowed a function previously bound to that prefix.  Call
       the function.  The recursive call to _rl_dispatch_subseq has
       already taken care of pushing any necessary input back onto
       the input queue with _rl_unget_char. */
    {
      m = _rl_dispatching_keymap;
      type = m[ANYOTHERKEY].type;
      func = m[ANYOTHERKEY].function;
      if (type == ISFUNC && func == rl_do_lowercase_version)
	r = _rl_dispatch (_rl_to_lower (key), map);
      else if (type == ISFUNC && func == rl_insert)
	{
	  /* If the function that was shadowed was self-insert, we
	     somehow need a keymap with map[key].func == self-insert.
	     Let's use this one. */
	  nt = m[key].type;
	  nf = m[key].function;

	  m[key].type = type;
	  m[key].function = func;
	  r = _rl_dispatch (key, m);
	  m[key].type = nt;
	  m[key].function = nf;
	}
      else
	r = _rl_dispatch (ANYOTHERKEY, m);
    }
  else if (r && map[ANYOTHERKEY].function)
    {
      /* We didn't match (r is probably -1), so return something to
	 tell the caller that it should try ANYOTHERKEY for an
	 overridden function. */
      _rl_unget_char (key);
      _rl_dispatching_keymap = map;
      return -2;
    }
  else if (r && got_subseq)
    {
      /* OK, back up the chain. */
      _rl_unget_char (key);
      _rl_dispatching_keymap = map;
      return -1;
    }

  return r;
}

d842 1
a842 1
    rl_completer_word_break_characters = (char *)rl_basic_word_break_characters;
d851 1
a851 14
  if (_rl_bind_stty_chars)
    rl_tty_set_default_bindings (_rl_keymap);
}

/* Reset the default bindings for the terminal special characters we're
   interested in back to rl_insert and read the new ones. */
static void
reset_default_bindings ()
{
  if (_rl_bind_stty_chars)
    {
      rl_tty_unset_default_bindings (_rl_keymap);
      rl_tty_set_default_bindings (_rl_keymap);
    }
d865 35
a899 26
  rl_bind_keyseq_if_unbound ("\033[0A", rl_get_previous_history);
  rl_bind_keyseq_if_unbound ("\033[0B", rl_backward_char);
  rl_bind_keyseq_if_unbound ("\033[0C", rl_forward_char);
  rl_bind_keyseq_if_unbound ("\033[0D", rl_get_next_history);
#endif

  rl_bind_keyseq_if_unbound ("\033[A", rl_get_previous_history);
  rl_bind_keyseq_if_unbound ("\033[B", rl_get_next_history);
  rl_bind_keyseq_if_unbound ("\033[C", rl_forward_char);
  rl_bind_keyseq_if_unbound ("\033[D", rl_backward_char);
  rl_bind_keyseq_if_unbound ("\033[H", rl_beg_of_line);
  rl_bind_keyseq_if_unbound ("\033[F", rl_end_of_line);

  rl_bind_keyseq_if_unbound ("\033OA", rl_get_previous_history);
  rl_bind_keyseq_if_unbound ("\033OB", rl_get_next_history);
  rl_bind_keyseq_if_unbound ("\033OC", rl_forward_char);
  rl_bind_keyseq_if_unbound ("\033OD", rl_backward_char);
  rl_bind_keyseq_if_unbound ("\033OH", rl_beg_of_line);
  rl_bind_keyseq_if_unbound ("\033OF", rl_end_of_line);

#if defined (__MINGW32__)
  rl_bind_keyseq_if_unbound ("\340H", rl_get_previous_history);
  rl_bind_keyseq_if_unbound ("\340P", rl_get_next_history);
  rl_bind_keyseq_if_unbound ("\340M", rl_forward_char);
  rl_bind_keyseq_if_unbound ("\340K", rl_backward_char);
#endif
d953 1
d955 1
d989 1
d991 1
@


1.8
log
@	* input.c (rl_getc): Use getch to read console input on
	Windows.
	* readline.c (bind_arrow_keys_internal): Translate
	Windows keysequences into POSIX key sequences.
	* rldefs.h (NO_TTY_DRIVER): Define on MinGW.
	* rltty.c: Conditionalize on NO_TTY_DRIVER throughout.
@
text
@@


1.8.10.1
log
@	readline/
	Backport from mainline:
	* emacs_keymap.c: Add a MINGW32 hack.
	* readline.c: Use _rl_bind_if_unbound to avoid macro bugs.
@
text
@d872 13
a884 4
  _rl_bind_if_unbound ("\340H", rl_get_previous_history);
  _rl_bind_if_unbound ("\340P", rl_get_next_history);
  _rl_bind_if_unbound ("\340M", rl_forward_char);
  _rl_bind_if_unbound ("\340K", rl_backward_char);
@


1.8.16.1
log
@Actually include patch, not just changelog.
@
text
@d872 13
a884 4
  _rl_bind_if_unbound ("\340H", rl_get_previous_history);
  _rl_bind_if_unbound ("\340P", rl_get_next_history);
  _rl_bind_if_unbound ("\340M", rl_forward_char);
  _rl_bind_if_unbound ("\340K", rl_backward_char);
@


1.8.16.2
log
@No, really, check in the RIGHT patch!
[Revert half of changes from previous commit.]
@
text
@d872 4
a875 13
   /* Under Windows, when an extend key (like an arrow key) is
      pressed, getch() will return 340 (octal) followed by a code for
      the extended key.  We use macros to transform those into the
      normal ANSI terminal sequences for these keys.  */

   /* Up arrow.  */
   rl_macro_bind ("\340H", "\033[A", map);
   /* Left arrow.  */
   rl_macro_bind ("\340K", "\033[D", map);
   /* Right arrow.  */
   rl_macro_bind ("\340M", "\033[C", map);
   /* Down arrow.  */
   rl_macro_bind ("\340P", "\033[B", map);
@


1.8.16.3
log
@Add experimental support for SymbianOS-related protocol features.
@
text
@d872 13
a884 4
  _rl_bind_if_unbound ("\340H", rl_get_previous_history);
  _rl_bind_if_unbound ("\340P", rl_get_next_history);
  _rl_bind_if_unbound ("\340M", rl_forward_char);
  _rl_bind_if_unbound ("\340K", rl_backward_char);
@


1.7
log
@2004-01-27  Elena Zannoni  <ezannoni@@redhat.com>

        Merge in official patches to readline-4.3 from
	ftp://ftp.cwru.edu/pub/bash/readline-4.3-patches:
	NOTE: Patch-ID readline-43-004 was already applied (see below).

	* bind.c (rl_generic_bind): Pressing certain key sequences
	causes an infinite loop in _rl_dispatch_subseq with the `key' argument
	set to 256.  This eventually causes bash to exceed the stack size
	limit and crash with a segmentation violation.
	Patch-ID: readline43-001.

	* readline.c (_rl_dispatch_subseq): Repeating an edit in
	vi-mode with `.' does not work.
	Patch-ID: readline43-002.

	* mbutil.c (_rl_get_char_len, _rl_compare_chars,
	_rl_adjust_point): When in a locale with multibyte characters, the
	readline display updater will occasionally cause a
	segmentation fault when attempting to compute the length of the first
	multibyte character on the line.
	Patch-ID: readline43-003.

	* vi_mode.c (_rl_vi_change_mbchar_case): Using the vi editing
	mode's case-changing commands in a locale with multibyte characters
	will cause garbage characters to be inserted into the editing buffer.
	Patch-ID: readline43-005.
@
text
@d871 16
@


1.7.18.1
log
@	* readline/input.c (rL_getc): Use getch, not getche.
	* readline/readline.c (bind_arrow_keys_internal): Translate
	Windows keysequences into POSIX key sequences.
	* readline/rlnotty.c (tputs): Fix thinko.
	(rl_prep_terminal): Set readline_echoing_p.
@
text
@a870 16
#ifdef __MINGW32__
   /* Under Windows, when an extend key (like an arrow key) is
      pressed, getch() will return 0xE0 followed by a code for the
      extended key.  We use macros to transform those into the normal
      UNIX sequences for these keys.  */

   /* Up arrow.  */
   rl_macro_bind ("\340H", "\033[A", map);
   /* Left arrow.  */
   rl_macro_bind ("\340K", "\033[D", map);
   /* Right arrow.  */
   rl_macro_bind ("\340M", "\033[C", map);
   /* Down arrow.  */
   rl_macro_bind ("\340P", "\033[B", map);
#endif

@


1.6
log
@	* readline.c (rl_save_state, rl_restore_state): Support systems
	that don't define SIGWINCH.

	* terminal.c (_rl_get_screen_size) [__DJGPP__]: Compute the
	screen width and height using console I/O.
	(_rl_init_terminal_io) [__MSDOS__]: Zero out all the _rl_term_*
	variables.  Convert to _rl_* naming scheme.
	(_rl_set_cursor) [__MSDOS__]: Ifdef away this function.

	* display.c (_rl_move_vert) [__MSDOS__]: Don't use undeclared
	variable `l'.  Use `delta' instead recomputing its value anew.
	Assign -delta to i instead of the other way around.
@
text
@d687 1
@


1.5
log
@Import of readline 4.3.
Non-readline modified files:

src/gdb/ChangeLog src/gdb/defs.h src/gdb/cli/cli-cmds.c
src/gdb/cli/cli-setshow.c src/gdb/tui/ChangeLog
src/gdb/tui/tuiWin.c

In readline directory:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@d936 1
d938 1
d972 1
d974 1
@


1.4
log
@readline:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Locally modified files: Makefile.in, configure.in, configure
        (regenerated), config.h.in (regenerated), readline.h, rltty.c,
 	shell.c signals.c.

        Locally added files: acconfig.h, config/*, config.h.bot,
        cross-build/*, doc/inc-hit.texinfo.

        New files: USAGE, rlprivate.h, rlshell.h, xmalloc.h.
examples:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        New files: excallback.c, rlfe.c.
doc:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Regenerated inc-hist.texinfo as copy of hsuser.texinfo, for
        inclusion in the gdb manual.

        New file: rluserman.texinfo
@
text
@d4 1
a4 1
/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
d55 1
d71 1
a71 1
#  define RL_LIBRARY_VERSION "4.1"
d74 5
a78 2
/* Evaluates its arguments multiple times. */
#define SWAP(s, e)  do { int t; t = s; s = e; e = t; } while (0)
d81 2
a82 1
void _rl_free_history_entry __P((HIST_ENTRY *));
d84 2
a85 5
static char *readline_internal __P((void));
static void readline_initialize_everything __P((void));
static void start_using_history __P((void));
static void bind_arrow_keys __P((void));
static int rl_change_case __P((int, int));
d87 1
a87 1
static void readline_default_bindings __P((void));
d95 1
a95 1
char *rl_library_version = RL_LIBRARY_VERSION;
d97 3
d109 3
d132 1
d135 4
d153 1
a153 1
Function *rl_last_func = (Function *)NULL;
d165 5
a169 2
/* Non-zero means echo characters as they are read. */
int readline_echoing_p = 1;
d172 1
a172 1
char *rl_prompt;
d184 1
a184 1
Function *rl_startup_hook = (Function *)NULL;
d189 1
a189 1
Function *rl_pre_input_hook = (Function *)NULL;
d202 1
a202 1
char *rl_terminal_name = (char *)NULL;
d232 1
a232 1
/* Forward declarations used by the display and termcap code. */
d262 13
d279 1
a279 1
     char *prompt;
a282 2
  rl_prompt = prompt;

d286 1
a286 1
      rl_pending_input = 0;
d290 1
a290 1
  rl_visible_prompt_length = rl_expand_prompt (rl_prompt);
d326 4
a329 1
  if (readline_echoing_p == 0)
d346 2
d349 2
a350 2
      if (rl_editing_mode == vi_mode)
	rl_vi_insertion_mode (1, 0);
a351 1
    }
d382 4
a385 1
    free_undo_list ();
d421 1
d423 1
d434 1
d510 1
a510 1
  rl_point = rl_end = 0;
d529 9
d540 1
a540 1
  Function *func;
d546 1
a546 1
	  if (_rl_defining_kbd_macro)
d554 1
a554 1
	ding ();
d558 1
a558 1
  if (_rl_defining_kbd_macro)
d566 1
a566 1
      if (func != (Function *)NULL)
d579 1
d581 1
d587 1
a587 1
	  if (!rl_pending_input && map[key].function != rl_digit_argument)
d590 17
d615 1
a615 1
      if (map[key].function != (Function *)NULL)
d617 12
d630 4
d635 33
a667 1
	  r = _rl_dispatch (newkey, FUNCTION_TO_KEYMAP (map, key));
d677 1
a677 1
      if (map[key].function != (Function *)NULL)
d707 1
d709 1
d711 1
d719 1
d722 1
a722 1
  start_using_history ();
d728 1
a728 1
  rl_last_func = (Function *)NULL;
d738 3
d781 4
a784 2
  /* Find out if we are running in Emacs. */
  running_in_emacs = get_env_value ("EMACS") != (char *)0;
d801 1
a801 1
    rl_line_buffer = xmalloc (rl_line_buffer_len = DEFAULT_BUFFER_SIZE);
d804 3
a806 1
  _rl_init_terminal_io ((char *)NULL);
d823 2
a824 2
      screenwidth--;
      screenchars -= screenheight;
d850 1
a850 1
  rltty_set_default_bindings (_rl_keymap);
d853 1
d855 2
a856 1
bind_arrow_keys_internal ()
d858 4
a861 1
  Function *f;
d864 19
a882 18
  f = rl_function_of_keyseq ("\033[0A", _rl_keymap, (int *)NULL);
  if (!f || f == rl_do_lowercase_version)
    {
       _rl_bind_if_unbound ("\033[0A", rl_get_previous_history);
       _rl_bind_if_unbound ("\033[0B", rl_backward);
       _rl_bind_if_unbound ("\033[0C", rl_forward);
       _rl_bind_if_unbound ("\033[0D", rl_get_next_history);
    }
#endif
	
  f = rl_function_of_keyseq ("\033[A", _rl_keymap, (int *)NULL);
  if (!f || f == rl_do_lowercase_version)
    {
      _rl_bind_if_unbound ("\033[A", rl_get_previous_history);
      _rl_bind_if_unbound ("\033[B", rl_get_next_history);
      _rl_bind_if_unbound ("\033[C", rl_forward);
      _rl_bind_if_unbound ("\033[D", rl_backward);
    }
d884 1
a884 8
  f = rl_function_of_keyseq ("\033OA", _rl_keymap, (int *)NULL);
  if (!f || f == rl_do_lowercase_version)
    {
      _rl_bind_if_unbound ("\033OA", rl_get_previous_history);
      _rl_bind_if_unbound ("\033OB", rl_get_next_history);
      _rl_bind_if_unbound ("\033OC", rl_forward);
      _rl_bind_if_unbound ("\033OD", rl_backward);
    }
d887 1
a887 1
/* Try and bind the common arrow key prefix after giving termcap and
d893 1
a893 6
  Keymap xkeymap;

  xkeymap = _rl_keymap;

  _rl_keymap = emacs_standard_keymap;
  bind_arrow_keys_internal ();
d896 2
a897 2
  _rl_keymap = vi_movement_keymap;
  bind_arrow_keys_internal ();
a898 115

  _rl_keymap = xkeymap;
}


/* **************************************************************** */
/*								    */
/*			Numeric Arguments			    */
/*								    */
/* **************************************************************** */

/* Handle C-u style numeric args, as well as M--, and M-digits. */
static int
rl_digit_loop ()
{
  int key, c, sawminus, sawdigits;

  rl_save_prompt ();

  sawminus = sawdigits = 0;
  while (1)
    {
      if (rl_numeric_arg > 1000000)
	{
	  sawdigits = rl_explicit_arg = rl_numeric_arg = 0;
	  ding ();
	  rl_restore_prompt ();
	  rl_clear_message ();
	  return 1;
	}
      rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg);
      key = c = rl_read_key ();

      /* If we see a key bound to `universal-argument' after seeing digits,
	 it ends the argument but is otherwise ignored. */
      if (_rl_keymap[c].type == ISFUNC &&
	  _rl_keymap[c].function == rl_universal_argument)
	{
	  if (sawdigits == 0)
	    {
	      rl_numeric_arg *= 4;
	      continue;
	    }
	  else
	    {
	      key = rl_read_key ();
	      rl_restore_prompt ();
	      rl_clear_message ();
	      return (_rl_dispatch (key, _rl_keymap));
	    }
	}

      c = UNMETA (c);

      if (_rl_digit_p (c))
	{
	  rl_numeric_arg = rl_explicit_arg ? (rl_numeric_arg * 10) + c - '0' : c - '0';
	  sawdigits = rl_explicit_arg = 1;
	}
      else if (c == '-' && rl_explicit_arg == 0)
	{
	  rl_numeric_arg = sawminus = 1;
	  rl_arg_sign = -1;
	}
      else
	{
	  /* Make M-- command equivalent to M--1 command. */
	  if (sawminus && rl_numeric_arg == 1 && rl_explicit_arg == 0)
	    rl_explicit_arg = 1;
	  rl_restore_prompt ();
	  rl_clear_message ();
	  return (_rl_dispatch (key, _rl_keymap));
	}
    }

  return 0;
}

/* Add the current digit to the argument in progress. */
int
rl_digit_argument (ignore, key)
     int ignore, key;
{
  rl_pending_input = key;
  return (rl_digit_loop ());
}

/* What to do when you abort reading an argument. */
int
rl_discard_argument ()
{
  ding ();
  rl_clear_message ();
  _rl_init_argument ();
  return 0;
}

/* Create a default argument. */
int
_rl_init_argument ()
{
  rl_numeric_arg = rl_arg_sign = 1;
  rl_explicit_arg = 0;
  return 0;
}

/* C-u, universal argument.  Multiply the current argument by 4.
   Read a key.  If the key has nothing to do with arguments, then
   dispatch on it.  If the key is the abort character then abort. */
int
rl_universal_argument (count, key)
     int count, key;
{
  rl_numeric_arg *= 4;
  return (rl_digit_loop ());
d903 1
a903 1
/*			Insert and Delete			    */
a906 3
/* Insert a string of text into the line at point.  This is the only
   way that you should do insertion.  rl_insert () calls this
   function. */
d908 2
a909 2
rl_insert_text (string)
     char *string;
d911 2
a912 1
  register int i, l = strlen (string);
d914 20
a933 2
  if (rl_end + l >= rl_line_buffer_len)
    rl_extend_line_buffer (rl_end + l);
d935 2
a936 3
  for (i = rl_end; i >= rl_point; i--)
    the_line[i + l] = the_line[i];
  strncpy (the_line + rl_point, string, l);
d938 1
a938 17
  /* Remember how to undo this if we aren't undoing something. */
  if (!_rl_doing_an_undo)
    {
      /* If possible and desirable, concatenate the undos. */
      if ((l == 1) &&
	  rl_undo_list &&
	  (rl_undo_list->what == UNDO_INSERT) &&
	  (rl_undo_list->end == rl_point) &&
	  (rl_undo_list->end - rl_undo_list->start < 20))
	rl_undo_list->end++;
      else
	rl_add_undo (UNDO_INSERT, rl_point, rl_point + l, (char *)NULL);
    }
  rl_point += l;
  rl_end += l;
  the_line[rl_end] = '\0';
  return l;
a940 2
/* Delete the string between FROM and TO.  FROM is
   inclusive, TO is not. */
d942 2
a943 2
rl_delete_text (from, to)
     int from, to;
d945 2
a946 2
  register char *text;
  register int diff, i;
d948 20
a967 3
  /* Fix it if the caller is confused. */
  if (from > to)
    SWAP (from, to);
d969 2
a970 7
  /* fix boundaries */
  if (to > rl_end)
    {
      to = rl_end;
      if (from > to)
        from = to;
    }
d972 1
a972 1129
  text = rl_copy_text (from, to);

  /* Some versions of strncpy() can't handle overlapping arguments. */
  diff = to - from;
  for (i = from; i < rl_end - diff; i++)
    the_line[i] = the_line[i + diff];

  /* Remember how to undo this delete. */
  if (_rl_doing_an_undo == 0)
    rl_add_undo (UNDO_DELETE, from, to, text);
  else
    free (text);

  rl_end -= diff;
  the_line[rl_end] = '\0';
  return (diff);
}

/* Fix up point so that it is within the line boundaries after killing
   text.  If FIX_MARK_TOO is non-zero, the mark is forced within line
   boundaries also. */

#define _RL_FIX_POINT(x) \
	do { \
	if (x > rl_end) \
	  x = rl_end; \
	else if (x < 0) \
	  x = 0; \
	} while (0)

void
_rl_fix_point (fix_mark_too)
     int fix_mark_too;
{
  _RL_FIX_POINT (rl_point);
  if (fix_mark_too)
    _RL_FIX_POINT (rl_mark);
}
#undef _RL_FIX_POINT

void
_rl_replace_text (text, start, end)
     char *text;
     int start, end;
{
  rl_begin_undo_group ();
  rl_delete_text (start, end + 1);
  rl_point = start;
  rl_insert_text (text);
  rl_end_undo_group ();
}

/* **************************************************************** */
/*								    */
/*			Readline character functions		    */
/*								    */
/* **************************************************************** */

/* This is not a gap editor, just a stupid line input routine.  No hair
   is involved in writing any of the functions, and none should be. */

/* Note that:

   rl_end is the place in the string that we would place '\0';
   i.e., it is always safe to place '\0' there.

   rl_point is the place in the string where the cursor is.  Sometimes
   this is the same as rl_end.

   Any command that is called interactively receives two arguments.
   The first is a count: the numeric arg pased to this command.
   The second is the key which invoked this command.
*/

/* **************************************************************** */
/*								    */
/*			Movement Commands			    */
/*								    */
/* **************************************************************** */

/* Note that if you `optimize' the display for these functions, you cannot
   use said functions in other functions which do not do optimizing display.
   I.e., you will have to update the data base for rl_redisplay, and you
   might as well let rl_redisplay do that job. */

/* Move forward COUNT characters. */
int
rl_forward (count, key)
     int count, key;
{
  if (count < 0)
    rl_backward (-count, key);
  else if (count > 0)
    {
      int end = rl_point + count;
#if defined (VI_MODE)
      int lend = rl_end - (rl_editing_mode == vi_mode);
#else
      int lend = rl_end;
#endif

      if (end > lend)
	{
	  rl_point = lend;
	  ding ();
	}
      else
	rl_point = end;
    }

  if (rl_end < 0)
    rl_end = 0;

  return 0;
}

/* Move backward COUNT characters. */
int
rl_backward (count, key)
     int count, key;
{
  if (count < 0)
    rl_forward (-count, key);
  else if (count > 0)
    {
      if (rl_point < count)
	{
	  rl_point = 0;
	  ding ();
	}
      else
        rl_point -= count;
    }
  return 0;
}

/* Move to the beginning of the line. */
int
rl_beg_of_line (count, key)
     int count, key;
{
  rl_point = 0;
  return 0;
}

/* Move to the end of the line. */
int
rl_end_of_line (count, key)
     int count, key;
{
  rl_point = rl_end;
  return 0;
}

/* Move forward a word.  We do what Emacs does. */
int
rl_forward_word (count, key)
     int count, key;
{
  int c;

  if (count < 0)
    {
      rl_backward_word (-count, key);
      return 0;
    }

  while (count)
    {
      if (rl_point == rl_end)
	return 0;

      /* If we are not in a word, move forward until we are in one.
	 Then, move forward until we hit a non-alphabetic character. */
      c = the_line[rl_point];
      if (alphabetic (c) == 0)
	{
	  while (++rl_point < rl_end)
	    {
	      c = the_line[rl_point];
	      if (alphabetic (c))
		break;
	    }
	}
      if (rl_point == rl_end)
	return 0;
      while (++rl_point < rl_end)
	{
	  c = the_line[rl_point];
	  if (alphabetic (c) == 0)
	    break;
	}
      --count;
    }
  return 0;
}

/* Move backward a word.  We do what Emacs does. */
int
rl_backward_word (count, key)
     int count, key;
{
  int c;

  if (count < 0)
    {
      rl_forward_word (-count, key);
      return 0;
    }

  while (count)
    {
      if (!rl_point)
	return 0;

      /* Like rl_forward_word (), except that we look at the characters
	 just before point. */

      c = the_line[rl_point - 1];
      if (alphabetic (c) == 0)
	{
	  while (--rl_point)
	    {
	      c = the_line[rl_point - 1];
	      if (alphabetic (c))
		break;
	    }
	}

      while (rl_point)
	{
	  c = the_line[rl_point - 1];
	  if (alphabetic (c) == 0)
	    break;
	  else
	    --rl_point;
	}
      --count;
    }
  return 0;
}

/* Clear the current line.  Numeric argument to C-l does this. */
int
rl_refresh_line (ignore1, ignore2)
     int ignore1, ignore2;
{
  int curr_line;

  curr_line = _rl_current_display_line ();

  _rl_move_vert (curr_line);
  _rl_move_cursor_relative (0, the_line);   /* XXX is this right */

  _rl_clear_to_eol (0);		/* arg of 0 means to not use spaces */

  rl_forced_update_display ();
  rl_display_fixed = 1;

  return 0;
}

/* C-l typed to a line without quoting clears the screen, and then reprints
   the prompt and the current input line.  Given a numeric arg, redraw only
   the current line. */
int
rl_clear_screen (count, key)
     int count, key;
{
  if (rl_explicit_arg)
    {
      rl_refresh_line (count, key);
      return 0;
    }

  _rl_clear_screen ();		/* calls termcap function to clear screen */
  rl_forced_update_display ();
  rl_display_fixed = 1;

  return 0;
}

int
rl_arrow_keys (count, c)
     int count, c;
{
  int ch;

  ch = rl_read_key ();

  switch (_rl_to_upper (ch))
    {
    case 'A':
      rl_get_previous_history (count, ch);
      break;

    case 'B':
      rl_get_next_history (count, ch);
      break;

    case 'C':
      rl_forward (count, ch);
      break;

    case 'D':
      rl_backward (count, ch);
      break;

    default:
      ding ();
    }
  return 0;
}


/* **************************************************************** */
/*								    */
/*			Text commands				    */
/*								    */
/* **************************************************************** */

/* Insert the character C at the current location, moving point forward. */
int
rl_insert (count, c)
     int count, c;
{
  register int i;
  char *string;

  if (count <= 0)
    return 0;

  /* If we can optimize, then do it.  But don't let people crash
     readline because of extra large arguments. */
  if (count > 1 && count <= 1024)
    {
      string = xmalloc (1 + count);

      for (i = 0; i < count; i++)
	string[i] = c;

      string[i] = '\0';
      rl_insert_text (string);
      free (string);

      return 0;
    }

  if (count > 1024)
    {
      int decreaser;
      char str[1024+1];

      for (i = 0; i < 1024; i++)
	str[i] = c;

      while (count)
	{
	  decreaser = (count > 1024 ? 1024 : count);
	  str[decreaser] = '\0';
	  rl_insert_text (str);
	  count -= decreaser;
	}

      return 0;
    }

  /* We are inserting a single character.
     If there is pending input, then make a string of all of the
     pending characters that are bound to rl_insert, and insert
     them all. */
  if (_rl_any_typein ())
    _rl_insert_typein (c);
  else
    {
      /* Inserting a single character. */
      char str[2];

      str[1] = '\0';
      str[0] = c;
      rl_insert_text (str);
    }
  return 0;
}

/* Insert the next typed character verbatim. */
int
rl_quoted_insert (count, key)
     int count, key;
{
  int c;

#if defined (HANDLE_SIGNALS)
  _rl_disable_tty_signals ();
#endif
  c = rl_read_key ();
#if defined (HANDLE_SIGNALS)
  _rl_restore_tty_signals ();
#endif

  return (rl_insert (count, c));  
}

/* Insert a tab character. */
int
rl_tab_insert (count, key)
     int count, key;
{
  return (rl_insert (count, '\t'));
}

/* What to do when a NEWLINE is pressed.  We accept the whole line.
   KEY is the key that invoked this command.  I guess it could have
   meaning in the future. */
int
rl_newline (count, key)
     int count, key;
{
  rl_done = 1;

#if defined (VI_MODE)
  if (rl_editing_mode == vi_mode)
    {
      _rl_vi_done_inserting ();
      _rl_vi_reset_last ();
    }
#endif /* VI_MODE */

  /* If we've been asked to erase empty lines, suppress the final update,
     since _rl_update_final calls crlf(). */
  if (rl_erase_empty_line && rl_point == 0 && rl_end == 0)
    return 0;

  if (readline_echoing_p)
    _rl_update_final ();
  return 0;
}

/* What to do for some uppercase characters, like meta characters,
   and some characters appearing in emacs_ctlx_keymap.  This function
   is just a stub, you bind keys to it and the code in _rl_dispatch ()
   is special cased. */
int
rl_do_lowercase_version (ignore1, ignore2)
     int ignore1, ignore2;
{
  return 0;
}

/* Rubout the character behind point. */
int
rl_rubout (count, key)
     int count, key;
{
  if (count < 0)
    {
      rl_delete (-count, key);
      return 0;
    }

  if (!rl_point)
    {
      ding ();
      return -1;
    }

  if (count > 1 || rl_explicit_arg)
    {
      int orig_point = rl_point;
      rl_backward (count, key);
      rl_kill_text (orig_point, rl_point);
    }
  else
    {
      int c = the_line[--rl_point];
      rl_delete_text (rl_point, rl_point + 1);

      if (rl_point == rl_end && isprint (c) && _rl_last_c_pos)
	{
	  int l;
	  l = rl_character_len (c, rl_point);
	  _rl_erase_at_end_of_line (l);
	}
    }
  return 0;
}

/* Delete the character under the cursor.  Given a numeric argument,
   kill that many characters instead. */
int
rl_delete (count, key)
     int count, key;
{
  if (count < 0)
    return (rl_rubout (-count, key));

  if (rl_point == rl_end)
    {
      ding ();
      return -1;
    }

  if (count > 1 || rl_explicit_arg)
    {
      int orig_point = rl_point;
      rl_forward (count, key);
      rl_kill_text (orig_point, rl_point);
      rl_point = orig_point;
      return 0;
    }
  else
    return (rl_delete_text (rl_point, rl_point + 1));
}

/* Delete the character under the cursor, unless the insertion
   point is at the end of the line, in which case the character
   behind the cursor is deleted.  COUNT is obeyed and may be used
   to delete forward or backward that many characters. */      
int
rl_rubout_or_delete (count, key)
     int count, key;
{
  if (rl_end != 0 && rl_point == rl_end)
    return (rl_rubout (count, key));
  else
    return (rl_delete (count, key));
}  

/* Delete all spaces and tabs around point. */
int
rl_delete_horizontal_space (count, ignore)
     int count, ignore;
{
  int start = rl_point;

  while (rl_point && whitespace (the_line[rl_point - 1]))
    rl_point--;

  start = rl_point;

  while (rl_point < rl_end && whitespace (the_line[rl_point]))
    rl_point++;

  if (start != rl_point)
    {
      rl_delete_text (start, rl_point);
      rl_point = start;
    }
  return 0;
}

/* Like the tcsh editing function delete-char-or-list.  The eof character
   is caught before this is invoked, so this really does the same thing as
   delete-char-or-list-or-eof, as long as it's bound to the eof character. */
int
rl_delete_or_show_completions (count, key)
     int count, key;
{
  if (rl_end != 0 && rl_point == rl_end)
    return (rl_possible_completions (count, key));
  else
    return (rl_delete (count, key));
}

#ifndef RL_COMMENT_BEGIN_DEFAULT
#define RL_COMMENT_BEGIN_DEFAULT "#"
#endif

/* Turn the current line into a comment in shell history.
   A K*rn shell style function. */
int
rl_insert_comment (count, key)
     int count, key;
{
  rl_beg_of_line (1, key);
  rl_insert_text (_rl_comment_begin ? _rl_comment_begin
				    : RL_COMMENT_BEGIN_DEFAULT);
  (*rl_redisplay_function) ();
  rl_newline (1, '\n');
  return (0);
}

/* **************************************************************** */
/*								    */
/*			Changing Case				    */
/*								    */
/* **************************************************************** */

/* The three kinds of things that we know how to do. */
#define UpCase 1
#define DownCase 2
#define CapCase 3

/* Uppercase the word at point. */
int
rl_upcase_word (count, key)
     int count, key;
{
  return (rl_change_case (count, UpCase));
}

/* Lowercase the word at point. */
int
rl_downcase_word (count, key)
     int count, key;
{
  return (rl_change_case (count, DownCase));
}

/* Upcase the first letter, downcase the rest. */
int
rl_capitalize_word (count, key)
     int count, key;
{
 return (rl_change_case (count, CapCase));
}

/* The meaty function.
   Change the case of COUNT words, performing OP on them.
   OP is one of UpCase, DownCase, or CapCase.
   If a negative argument is given, leave point where it started,
   otherwise, leave it where it moves to. */
static int
rl_change_case (count, op)
     int count, op;
{
  register int start, end;
  int inword, c;

  start = rl_point;
  rl_forward_word (count, 0);
  end = rl_point;

  if (count < 0)
    SWAP (start, end);

  /* We are going to modify some text, so let's prepare to undo it. */
  rl_modifying (start, end);

  for (inword = 0; start < end; start++)
    {
      c = the_line[start];
      switch (op)
	{
	case UpCase:
	  the_line[start] = _rl_to_upper (c);
	  break;

	case DownCase:
	  the_line[start] = _rl_to_lower (c);
	  break;

	case CapCase:
	  the_line[start] = (inword == 0) ? _rl_to_upper (c) : _rl_to_lower (c);
	  inword = alphabetic (the_line[start]);
	  break;

	default:
	  ding ();
	  return -1;
	}
    }
  rl_point = end;
  return 0;
}

/* **************************************************************** */
/*								    */
/*			Transposition				    */
/*								    */
/* **************************************************************** */

/* Transpose the words at point. */
int
rl_transpose_words (count, key)
     int count, key;
{
  char *word1, *word2;
  int w1_beg, w1_end, w2_beg, w2_end;
  int orig_point = rl_point;

  if (!count)
    return 0;

  /* Find the two words. */
  rl_forward_word (count, key);
  w2_end = rl_point;
  rl_backward_word (1, key);
  w2_beg = rl_point;
  rl_backward_word (count, key);
  w1_beg = rl_point;
  rl_forward_word (1, key);
  w1_end = rl_point;

  /* Do some check to make sure that there really are two words. */
  if ((w1_beg == w2_beg) || (w2_beg < w1_end))
    {
      ding ();
      rl_point = orig_point;
      return -1;
    }

  /* Get the text of the words. */
  word1 = rl_copy_text (w1_beg, w1_end);
  word2 = rl_copy_text (w2_beg, w2_end);

  /* We are about to do many insertions and deletions.  Remember them
     as one operation. */
  rl_begin_undo_group ();

  /* Do the stuff at word2 first, so that we don't have to worry
     about word1 moving. */
  rl_point = w2_beg;
  rl_delete_text (w2_beg, w2_end);
  rl_insert_text (word1);

  rl_point = w1_beg;
  rl_delete_text (w1_beg, w1_end);
  rl_insert_text (word2);

  /* This is exactly correct since the text before this point has not
     changed in length. */
  rl_point = w2_end;

  /* I think that does it. */
  rl_end_undo_group ();
  free (word1);
  free (word2);

  return 0;
}

/* Transpose the characters at point.  If point is at the end of the line,
   then transpose the characters before point. */
int
rl_transpose_chars (count, key)
     int count, key;
{
  char dummy[2];

  if (!count)
    return 0;

  if (!rl_point || rl_end < 2)
    {
      ding ();
      return -1;
    }

  rl_begin_undo_group ();

  if (rl_point == rl_end)
    {
      --rl_point;
      count = 1;
    }
  rl_point--;

  dummy[0] = the_line[rl_point];
  dummy[1] = '\0';

  rl_delete_text (rl_point, rl_point + 1);

  rl_point += count;
  _rl_fix_point (0);
  rl_insert_text (dummy);

  rl_end_undo_group ();
  return 0;
}

/* **************************************************************** */
/*								    */
/*			Character Searching			    */
/*								    */
/* **************************************************************** */

int
_rl_char_search_internal (count, dir, schar)
     int count, dir, schar;
{
  int pos, inc;

  pos = rl_point;
  inc = (dir < 0) ? -1 : 1;
  while (count)
    {
      if ((dir < 0 && pos <= 0) || (dir > 0 && pos >= rl_end))
	{
	  ding ();
	  return -1;
	}

      pos += inc;
      do
	{
	  if (rl_line_buffer[pos] == schar)
	    {
	      count--;
	      if (dir < 0)
	        rl_point = (dir == BTO) ? pos + 1 : pos;
	      else
		rl_point = (dir == FTO) ? pos - 1 : pos;
	      break;
	    }
	}
      while ((dir < 0) ? pos-- : ++pos < rl_end);
    }
  return (0);
}

/* Search COUNT times for a character read from the current input stream.
   FDIR is the direction to search if COUNT is non-negative; otherwise
   the search goes in BDIR. */
static int
_rl_char_search (count, fdir, bdir)
     int count, fdir, bdir;
{
  int c;

  c = rl_read_key ();
  if (count < 0)
    return (_rl_char_search_internal (-count, bdir, c));
  else
    return (_rl_char_search_internal (count, fdir, c));
}

int
rl_char_search (count, key)
     int count, key;
{
  return (_rl_char_search (count, FFIND, BFIND));
}

int
rl_backward_char_search (count, key)
     int count, key;
{
  return (_rl_char_search (count, BFIND, FFIND));
}

/* **************************************************************** */
/*								    */
/*			History Utilities			    */
/*								    */
/* **************************************************************** */

/* We already have a history library, and that is what we use to control
   the history features of readline.  This is our local interface to
   the history mechanism. */

/* While we are editing the history, this is the saved
   version of the original line. */
HIST_ENTRY *saved_line_for_history = (HIST_ENTRY *)NULL;

/* Set the history pointer back to the last entry in the history. */
static void
start_using_history ()
{
  using_history ();
  if (saved_line_for_history)
    _rl_free_history_entry (saved_line_for_history);

  saved_line_for_history = (HIST_ENTRY *)NULL;
}

/* Free the contents (and containing structure) of a HIST_ENTRY. */
void
_rl_free_history_entry (entry)
     HIST_ENTRY *entry;
{
  if (entry == 0)
    return;
  if (entry->line)
    free (entry->line);
  free (entry);
}

/* Perhaps put back the current line if it has changed. */
int
maybe_replace_line ()
{
  HIST_ENTRY *temp;

  temp = current_history ();
  /* If the current line has changed, save the changes. */
  if (temp && ((UNDO_LIST *)(temp->data) != rl_undo_list))
    {
      temp = replace_history_entry (where_history (), the_line, (histdata_t)rl_undo_list);
      free (temp->line);
      free (temp);
    }
  return 0;
}

/* Put back the saved_line_for_history if there is one. */
int
maybe_unsave_line ()
{
  int line_len;

  if (saved_line_for_history)
    {
      line_len = strlen (saved_line_for_history->line);

      if (line_len >= rl_line_buffer_len)
	rl_extend_line_buffer (line_len);

      strcpy (the_line, saved_line_for_history->line);
      rl_undo_list = (UNDO_LIST *)saved_line_for_history->data;
      _rl_free_history_entry (saved_line_for_history);
      saved_line_for_history = (HIST_ENTRY *)NULL;
      rl_end = rl_point = strlen (the_line);
    }
  else
    ding ();
  return 0;
}

/* Save the current line in saved_line_for_history. */
int
maybe_save_line ()
{
  if (saved_line_for_history == 0)
    {
      saved_line_for_history = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
      saved_line_for_history->line = savestring (the_line);
      saved_line_for_history->data = (char *)rl_undo_list;
    }
  return 0;
}

/* **************************************************************** */
/*								    */
/*			History Commands			    */
/*								    */
/* **************************************************************** */

/* Meta-< goes to the start of the history. */
int
rl_beginning_of_history (count, key)
     int count, key;
{
  return (rl_get_previous_history (1 + where_history (), key));
}

/* Meta-> goes to the end of the history.  (The current line). */
int
rl_end_of_history (count, key)
     int count, key;
{
  maybe_replace_line ();
  using_history ();
  maybe_unsave_line ();
  return 0;
}

/* Move down to the next history line. */
int
rl_get_next_history (count, key)
     int count, key;
{
  HIST_ENTRY *temp;
  int line_len;

  if (count < 0)
    return (rl_get_previous_history (-count, key));

  if (count == 0)
    return 0;

  maybe_replace_line ();

  temp = (HIST_ENTRY *)NULL;
  while (count)
    {
      temp = next_history ();
      if (!temp)
	break;
      --count;
    }

  if (temp == 0)
    maybe_unsave_line ();
  else
    {
      line_len = strlen (temp->line);

      if (line_len >= rl_line_buffer_len)
	rl_extend_line_buffer (line_len);

      strcpy (the_line, temp->line);
      rl_undo_list = (UNDO_LIST *)temp->data;
      rl_end = rl_point = strlen (the_line);
#if defined (VI_MODE)
      if (rl_editing_mode == vi_mode)
	rl_point = 0;
#endif /* VI_MODE */
    }
  return 0;
}

/* Get the previous item out of our interactive history, making it the current
   line.  If there is no previous history, just ding. */
int
rl_get_previous_history (count, key)
     int count, key;
{
  HIST_ENTRY *old_temp, *temp;
  int line_len;

  if (count < 0)
    return (rl_get_next_history (-count, key));

  if (count == 0)
    return 0;

  /* If we don't have a line saved, then save this one. */
  maybe_save_line ();

  /* If the current line has changed, save the changes. */
  maybe_replace_line ();

  temp = old_temp = (HIST_ENTRY *)NULL;
  while (count)
    {
      temp = previous_history ();
      if (temp == 0)
	break;

      old_temp = temp;
      --count;
    }

  /* If there was a large argument, and we moved back to the start of the
     history, that is not an error.  So use the last value found. */
  if (!temp && old_temp)
    temp = old_temp;

  if (temp == 0)
    ding ();
  else
    {
      line_len = strlen (temp->line);

      if (line_len >= rl_line_buffer_len)
	rl_extend_line_buffer (line_len);

      strcpy (the_line, temp->line);
      rl_undo_list = (UNDO_LIST *)temp->data;
      rl_end = rl_point = line_len;

#if defined (VI_MODE)
      if (rl_editing_mode == vi_mode)
	rl_point = 0;
#endif /* VI_MODE */
    }
  return 0;
}

/* **************************************************************** */
/*								    */
/*		   The Mark and the Region.			    */
/*								    */
/* **************************************************************** */

/* Set the mark at POSITION. */
int
_rl_set_mark_at_pos (position)
     int position;
{
  if (position > rl_end)
    return -1;

  rl_mark = position;
  return 0;
}

/* A bindable command to set the mark. */
int
rl_set_mark (count, key)
     int count, key;
{
  return (_rl_set_mark_at_pos (rl_explicit_arg ? count : rl_point));
}

/* Exchange the position of mark and point. */
int
rl_exchange_point_and_mark (count, key)
     int count, key;
{
  if (rl_mark > rl_end)
    rl_mark = -1;

  if (rl_mark == -1)
    {
      ding ();
      return -1;
    }
  else
    SWAP (rl_point, rl_mark);

  return 0;
}

/* **************************************************************** */
/*								    */
/*			    Editing Modes			    */
/*								    */
/* **************************************************************** */
/* How to toggle back and forth between editing modes. */
int
rl_vi_editing_mode (count, key)
     int count, key;
{
#if defined (VI_MODE)
  rl_editing_mode = vi_mode;
  rl_vi_insertion_mode (1, key);
#endif /* VI_MODE */
  return 0;
}

int
rl_emacs_editing_mode (count, key)
     int count, key;
{
  rl_editing_mode = emacs_mode;
  _rl_keymap = emacs_standard_keymap;
  return 0;
@


1.4.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d4 1
a4 1
/* Copyright (C) 1987-2002 Free Software Foundation, Inc.
a54 1
#include "rlmbutil.h"
d70 1
a70 1
#  define RL_LIBRARY_VERSION "4.3"
d73 2
a74 5
#ifndef RL_READLINE_VERSION
#  define RL_READLINE_VERSION	0x0403
#endif

extern void _rl_free_history_entry PARAMS((HIST_ENTRY *));
d77 1
a77 2
static char *readline_internal PARAMS((void));
static void readline_initialize_everything PARAMS((void));
d79 5
a83 2
static void bind_arrow_keys_internal PARAMS((Keymap));
static void bind_arrow_keys PARAMS((void));
d85 1
a85 1
static void readline_default_bindings PARAMS((void));
d93 1
a93 1
const char *rl_library_version = RL_LIBRARY_VERSION;
a94 3
int rl_readline_version = RL_READLINE_VERSION;

/* True if this is `real' readline as opposed to some stub substitute. */
a103 3
/* The current insert mode:  input (the default) or overwrite */
int rl_insert_mode = RL_IM_DEFAULT;

a123 1
#if 0
a125 4
#endif

/* Flags word encapsulating the current readline state. */
int rl_readline_state = RL_STATE_NONE;
d140 1
a140 1
rl_command_func_t *rl_last_func = (rl_command_func_t *)NULL;
d152 2
a153 5
/* Non-zero means echo characters as they are read.  Defaults to no echo;
   set to 1 if there is a controlling terminal, we can get its attributes,
   and the attributes include `echo'.  Look at rltty.c:prepare_terminal_settings
   for the code that sets it. */
int readline_echoing_p = 0;
d156 1
a156 1
char *rl_prompt = (char *)NULL;
d168 1
a168 1
rl_hook_func_t *rl_startup_hook = (rl_hook_func_t *)NULL;
d173 1
a173 1
rl_hook_func_t *rl_pre_input_hook = (rl_hook_func_t *)NULL;
d186 1
a186 1
const char *rl_terminal_name = (const char *)NULL;
d216 1
a216 1
/* Forward declarations used by the display, termcap, and history code. */
a245 13
/* Set up the prompt and expand it.  Called from readline() and
   rl_callback_handler_install (). */
int
rl_set_prompt (prompt)
     const char *prompt;
{
  FREE (rl_prompt);
  rl_prompt = prompt ? savestring (prompt) : (char *)NULL;

  rl_visible_prompt_length = rl_expand_prompt (rl_prompt);
  return 0;
}
  
d250 1
a250 1
     const char *prompt;
d254 2
d259 1
a259 1
      rl_clear_pending_input ();
d263 1
a263 1
  rl_set_prompt (prompt);
d299 1
a299 4
  /* If we're not echoing, we still want to at least print a prompt, because
     rl_redisplay will not do it for us.  If the calling application has a
     custom redisplay function, though, let that function handle it. */
  if (readline_echoing_p == 0 && rl_redisplay_function == rl_redisplay)
a315 2
    }

d317 2
a318 2
  if (rl_editing_mode == vi_mode)
    rl_vi_insertion_mode (1, 0);
d320 1
d351 1
a351 4
    rl_free_undo_list ();

  /* Restore normal cursor, if available. */
  _rl_set_insert_mode (RL_IM_INSERT, 0);
a386 1
      RL_SETSTATE(RL_STATE_READCMD);
a387 1
      RL_UNSETSTATE(RL_STATE_READCMD);
a397 1
	  RL_SETSTATE(RL_STATE_DONE);
d473 1
a473 1
  rl_point = rl_end = rl_mark = 0;
a491 9
  return _rl_dispatch_subseq (key, map, 0);
}

int
_rl_dispatch_subseq (key, map, got_subseq)
     register int key;
     Keymap map;
     int got_subseq;
{
d494 1
a494 1
  rl_command_func_t *func;
d500 1
a500 1
	  if (RL_ISSTATE (RL_STATE_MACRODEF))
d508 1
a508 1
	rl_ding ();
d512 1
a512 1
  if (RL_ISSTATE (RL_STATE_MACRODEF))
d520 1
a520 1
      if (func)
a532 1
	  RL_SETSTATE(RL_STATE_DISPATCHING);
a533 1
	  RL_UNSETSTATE(RL_STATE_DISPATCHING);
d539 1
a539 1
	  if (rl_pending_input == 0 && map[key].function != rl_digit_argument)
a541 17
      else if (map[ANYOTHERKEY].function)
	{
	  /* OK, there's no function bound in this map, but there is a
	     shadow function that was overridden when the current keymap
	     was created.  Return -2 to note  that. */
	  _rl_unget_char  (key);
	  return -2;
	}
      else if (got_subseq)
	{
	  /* Return -1 to note that we're in a subsequence, but  we don't
	     have a matching key, nor was one overridden.  This means
	     we need to back up the recursion chain and find the last
	     subsequence that is bound to a function. */
	  _rl_unget_char (key);
	  return -1;
	}
d550 1
a550 1
      if (map[key].function != 0)
a551 12
#if defined (VI_MODE)
	  /* The only way this test will be true is if a subsequence has been
	     bound starting with ESC, generally the arrow keys.  What we do is
	     check whether there's input in the queue, which there generally
	     will be if an arrow key has been pressed, and, if there's not,
	     just dispatch to (what we assume is) rl_vi_movement_mode right
	     away.  This is essentially an input test with a zero timeout. */
	  if (rl_editing_mode == vi_mode && key == ESC && map == vi_insertion_keymap
	      && _rl_input_queued (0) == 0)
	    return (_rl_dispatch (ANYOTHERKEY, FUNCTION_TO_KEYMAP (map, key)));
#endif

a552 4

	  if (key == ESC)
	    RL_SETSTATE(RL_STATE_METANEXT);
	  RL_SETSTATE(RL_STATE_MOREINPUT);
d554 1
a554 33
	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
	  if (key == ESC)
	    RL_UNSETSTATE(RL_STATE_METANEXT);

	  if (newkey < 0)
	    {
	      _rl_abort_internal ();
	      return -1;
	    }

	  r = _rl_dispatch_subseq (newkey, FUNCTION_TO_KEYMAP (map, key), got_subseq || map[ANYOTHERKEY].function);

	  if (r == -2)
	    /* We didn't match anything, and the keymap we're indexed into
	       shadowed a function previously bound to that prefix.  Call
	       the function.  The recursive call to _rl_dispatch_subseq has
	       already taken care of pushing any necessary input back onto
	       the input queue with _rl_unget_char. */
	    r = _rl_dispatch (ANYOTHERKEY, FUNCTION_TO_KEYMAP (map, key));
	  else if (r && map[ANYOTHERKEY].function)
	    {
	      /* We didn't match (r is probably -1), so return something to
		 tell the caller that it should try ANYOTHERKEY for an
		 overridden function. */
	      _rl_unget_char (key);
	      return -2;
	    }
	  else if (r && got_subseq)
	    {
	      /* OK, back up the chain. */
	      _rl_unget_char (key);
	      return -1;
	    }
d564 1
a564 1
      if (map[key].function != 0)
a593 1
      RL_SETSTATE(RL_STATE_INITIALIZING);
a594 1
      RL_UNSETSTATE(RL_STATE_INITIALIZING);
a595 1
      RL_SETSTATE(RL_STATE_INITIALIZED);
a602 1
  RL_UNSETSTATE(RL_STATE_DONE);
d605 1
a605 1
  _rl_start_using_history ();
d611 1
a611 1
  rl_last_func = (rl_command_func_t *)NULL;
a620 3
  /* Each line starts in insert mode (the default). */
  _rl_set_insert_mode (RL_IM_DEFAULT, 1);

d661 2
a662 4
#if 0
  /* Find out if we are running in Emacs -- UNUSED. */
  running_in_emacs = sh_get_env_value ("EMACS") != (char *)0;
#endif
d679 1
a679 1
    rl_line_buffer = (char *)xmalloc (rl_line_buffer_len = DEFAULT_BUFFER_SIZE);
d682 1
a682 3
  if (rl_terminal_name == 0)
    rl_terminal_name = sh_get_env_value ("TERM");
  _rl_init_terminal_io (rl_terminal_name);
d699 2
a700 2
      _rl_screenwidth--;
      _rl_screenchars -= _rl_screenheight;
d726 1
a726 1
  rl_tty_set_default_bindings (_rl_keymap);
a728 1
/* Bind some common arrow key sequences in MAP. */
d730 1
a730 2
bind_arrow_keys_internal (map)
     Keymap map;
d732 1
a732 4
  Keymap xkeymap;

  xkeymap = _rl_keymap;
  _rl_keymap = map;
d735 18
a752 19
   _rl_bind_if_unbound ("\033[0A", rl_get_previous_history);
   _rl_bind_if_unbound ("\033[0B", rl_backward_char);
   _rl_bind_if_unbound ("\033[0C", rl_forward_char);
   _rl_bind_if_unbound ("\033[0D", rl_get_next_history);
#endif

  _rl_bind_if_unbound ("\033[A", rl_get_previous_history);
  _rl_bind_if_unbound ("\033[B", rl_get_next_history);
  _rl_bind_if_unbound ("\033[C", rl_forward_char);
  _rl_bind_if_unbound ("\033[D", rl_backward_char);
  _rl_bind_if_unbound ("\033[H", rl_beg_of_line);
  _rl_bind_if_unbound ("\033[F", rl_end_of_line);

  _rl_bind_if_unbound ("\033OA", rl_get_previous_history);
  _rl_bind_if_unbound ("\033OB", rl_get_next_history);
  _rl_bind_if_unbound ("\033OC", rl_forward_char);
  _rl_bind_if_unbound ("\033OD", rl_backward_char);
  _rl_bind_if_unbound ("\033OH", rl_beg_of_line);
  _rl_bind_if_unbound ("\033OF", rl_end_of_line);
d754 8
a761 1
  _rl_keymap = xkeymap;
d764 1
a764 1
/* Try and bind the common arrow key prefixes after giving termcap and
d770 6
a775 1
  bind_arrow_keys_internal (emacs_standard_keymap);
d778 2
a779 2
  bind_arrow_keys_internal (vi_movement_keymap);
  bind_arrow_keys_internal (vi_insertion_keymap);
d781 229
d1014 23
a1036 1
/*		Saving and Restoring Readline's state		    */
d1040 66
d1107 2
a1108 2
rl_save_state (sp)
     struct readline_state *sp;
d1110 103
a1212 2
  if (sp == 0)
    return -1;
d1214 1
a1214 20
  sp->point = rl_point;
  sp->end = rl_end;
  sp->mark = rl_mark;
  sp->buffer = rl_line_buffer;
  sp->buflen = rl_line_buffer_len;
  sp->ul = rl_undo_list;
  sp->prompt = rl_prompt;

  sp->rlstate = rl_readline_state;
  sp->done = rl_done;
  sp->kmap = _rl_keymap;

  sp->lastfunc = rl_last_func;
  sp->insmode = rl_insert_mode;
  sp->edmode = rl_editing_mode;
  sp->kseqlen = rl_key_sequence_length;
  sp->inf = rl_instream;
  sp->outf = rl_outstream;
  sp->pendingin = rl_pending_input;
  sp->macro = rl_executing_macro;
d1216 2
a1217 2
  sp->catchsigs = rl_catch_signals;
  sp->catchsigwinch = rl_catch_sigwinch;
d1219 1
a1219 1
  return (0);
d1222 3
d1226 2
a1227 2
rl_restore_state (sp)
     struct readline_state *sp;
d1229 12
a1240 2
  if (sp == 0)
    return -1;
d1242 5
a1246 20
  rl_point = sp->point;
  rl_end = sp->end;
  rl_mark = sp->mark;
  the_line = rl_line_buffer = sp->buffer;
  rl_line_buffer_len = sp->buflen;
  rl_undo_list = sp->ul;
  rl_prompt = sp->prompt;

  rl_readline_state = sp->rlstate;
  rl_done = sp->done;
  _rl_keymap = sp->kmap;

  rl_last_func = sp->lastfunc;
  rl_insert_mode = sp->insmode;
  rl_editing_mode = sp->edmode;
  rl_key_sequence_length = sp->kseqlen;
  rl_instream = sp->inf;
  rl_outstream = sp->outf;
  rl_pending_input = sp->pendingin;
  rl_executing_macro = sp->macro;
d1248 1
a1248 2
  rl_catch_signals = sp->catchsigs;
  rl_catch_sigwinch = sp->catchsigwinch;
d1250 518
d1769 320
@


1.4.24.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@a935 1
#if defined (SIGWINCH)
a936 1
#endif
a969 1
#if defined (SIGWINCH)
a970 1
#endif
@


1.4.24.3
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@a686 1
      key != ANYOTHERKEY &&
@


1.4.22.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d4 1
a4 1
/* Copyright (C) 1987-2002 Free Software Foundation, Inc.
a54 1
#include "rlmbutil.h"
d70 1
a70 1
#  define RL_LIBRARY_VERSION "4.3"
d73 2
a74 5
#ifndef RL_READLINE_VERSION
#  define RL_READLINE_VERSION	0x0403
#endif

extern void _rl_free_history_entry PARAMS((HIST_ENTRY *));
d77 1
a77 2
static char *readline_internal PARAMS((void));
static void readline_initialize_everything PARAMS((void));
d79 5
a83 2
static void bind_arrow_keys_internal PARAMS((Keymap));
static void bind_arrow_keys PARAMS((void));
d85 1
a85 1
static void readline_default_bindings PARAMS((void));
d93 1
a93 1
const char *rl_library_version = RL_LIBRARY_VERSION;
a94 3
int rl_readline_version = RL_READLINE_VERSION;

/* True if this is `real' readline as opposed to some stub substitute. */
a103 3
/* The current insert mode:  input (the default) or overwrite */
int rl_insert_mode = RL_IM_DEFAULT;

a123 1
#if 0
a125 4
#endif

/* Flags word encapsulating the current readline state. */
int rl_readline_state = RL_STATE_NONE;
d140 1
a140 1
rl_command_func_t *rl_last_func = (rl_command_func_t *)NULL;
d152 2
a153 5
/* Non-zero means echo characters as they are read.  Defaults to no echo;
   set to 1 if there is a controlling terminal, we can get its attributes,
   and the attributes include `echo'.  Look at rltty.c:prepare_terminal_settings
   for the code that sets it. */
int readline_echoing_p = 0;
d156 1
a156 1
char *rl_prompt = (char *)NULL;
d168 1
a168 1
rl_hook_func_t *rl_startup_hook = (rl_hook_func_t *)NULL;
d173 1
a173 1
rl_hook_func_t *rl_pre_input_hook = (rl_hook_func_t *)NULL;
d186 1
a186 1
const char *rl_terminal_name = (const char *)NULL;
d216 1
a216 1
/* Forward declarations used by the display, termcap, and history code. */
a245 13
/* Set up the prompt and expand it.  Called from readline() and
   rl_callback_handler_install (). */
int
rl_set_prompt (prompt)
     const char *prompt;
{
  FREE (rl_prompt);
  rl_prompt = prompt ? savestring (prompt) : (char *)NULL;

  rl_visible_prompt_length = rl_expand_prompt (rl_prompt);
  return 0;
}
  
d250 1
a250 1
     const char *prompt;
d254 2
d259 1
a259 1
      rl_clear_pending_input ();
d263 1
a263 1
  rl_set_prompt (prompt);
d299 1
a299 4
  /* If we're not echoing, we still want to at least print a prompt, because
     rl_redisplay will not do it for us.  If the calling application has a
     custom redisplay function, though, let that function handle it. */
  if (readline_echoing_p == 0 && rl_redisplay_function == rl_redisplay)
a315 2
    }

d317 2
a318 2
  if (rl_editing_mode == vi_mode)
    rl_vi_insertion_mode (1, 0);
d320 1
d351 1
a351 4
    rl_free_undo_list ();

  /* Restore normal cursor, if available. */
  _rl_set_insert_mode (RL_IM_INSERT, 0);
a386 1
      RL_SETSTATE(RL_STATE_READCMD);
a387 1
      RL_UNSETSTATE(RL_STATE_READCMD);
a397 1
	  RL_SETSTATE(RL_STATE_DONE);
d473 1
a473 1
  rl_point = rl_end = rl_mark = 0;
a491 9
  return _rl_dispatch_subseq (key, map, 0);
}

int
_rl_dispatch_subseq (key, map, got_subseq)
     register int key;
     Keymap map;
     int got_subseq;
{
d494 1
a494 1
  rl_command_func_t *func;
d500 1
a500 1
	  if (RL_ISSTATE (RL_STATE_MACRODEF))
d508 1
a508 1
	rl_ding ();
d512 1
a512 1
  if (RL_ISSTATE (RL_STATE_MACRODEF))
d520 1
a520 1
      if (func)
a532 1
	  RL_SETSTATE(RL_STATE_DISPATCHING);
a533 1
	  RL_UNSETSTATE(RL_STATE_DISPATCHING);
d539 1
a539 1
	  if (rl_pending_input == 0 && map[key].function != rl_digit_argument)
a541 17
      else if (map[ANYOTHERKEY].function)
	{
	  /* OK, there's no function bound in this map, but there is a
	     shadow function that was overridden when the current keymap
	     was created.  Return -2 to note  that. */
	  _rl_unget_char  (key);
	  return -2;
	}
      else if (got_subseq)
	{
	  /* Return -1 to note that we're in a subsequence, but  we don't
	     have a matching key, nor was one overridden.  This means
	     we need to back up the recursion chain and find the last
	     subsequence that is bound to a function. */
	  _rl_unget_char (key);
	  return -1;
	}
d550 1
a550 1
      if (map[key].function != 0)
a551 12
#if defined (VI_MODE)
	  /* The only way this test will be true is if a subsequence has been
	     bound starting with ESC, generally the arrow keys.  What we do is
	     check whether there's input in the queue, which there generally
	     will be if an arrow key has been pressed, and, if there's not,
	     just dispatch to (what we assume is) rl_vi_movement_mode right
	     away.  This is essentially an input test with a zero timeout. */
	  if (rl_editing_mode == vi_mode && key == ESC && map == vi_insertion_keymap
	      && _rl_input_queued (0) == 0)
	    return (_rl_dispatch (ANYOTHERKEY, FUNCTION_TO_KEYMAP (map, key)));
#endif

a552 4

	  if (key == ESC)
	    RL_SETSTATE(RL_STATE_METANEXT);
	  RL_SETSTATE(RL_STATE_MOREINPUT);
d554 1
a554 33
	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
	  if (key == ESC)
	    RL_UNSETSTATE(RL_STATE_METANEXT);

	  if (newkey < 0)
	    {
	      _rl_abort_internal ();
	      return -1;
	    }

	  r = _rl_dispatch_subseq (newkey, FUNCTION_TO_KEYMAP (map, key), got_subseq || map[ANYOTHERKEY].function);

	  if (r == -2)
	    /* We didn't match anything, and the keymap we're indexed into
	       shadowed a function previously bound to that prefix.  Call
	       the function.  The recursive call to _rl_dispatch_subseq has
	       already taken care of pushing any necessary input back onto
	       the input queue with _rl_unget_char. */
	    r = _rl_dispatch (ANYOTHERKEY, FUNCTION_TO_KEYMAP (map, key));
	  else if (r && map[ANYOTHERKEY].function)
	    {
	      /* We didn't match (r is probably -1), so return something to
		 tell the caller that it should try ANYOTHERKEY for an
		 overridden function. */
	      _rl_unget_char (key);
	      return -2;
	    }
	  else if (r && got_subseq)
	    {
	      /* OK, back up the chain. */
	      _rl_unget_char (key);
	      return -1;
	    }
d564 1
a564 1
      if (map[key].function != 0)
a593 1
      RL_SETSTATE(RL_STATE_INITIALIZING);
a594 1
      RL_UNSETSTATE(RL_STATE_INITIALIZING);
a595 1
      RL_SETSTATE(RL_STATE_INITIALIZED);
a602 1
  RL_UNSETSTATE(RL_STATE_DONE);
d605 1
a605 1
  _rl_start_using_history ();
d611 1
a611 1
  rl_last_func = (rl_command_func_t *)NULL;
a620 3
  /* Each line starts in insert mode (the default). */
  _rl_set_insert_mode (RL_IM_DEFAULT, 1);

d661 2
a662 4
#if 0
  /* Find out if we are running in Emacs -- UNUSED. */
  running_in_emacs = sh_get_env_value ("EMACS") != (char *)0;
#endif
d679 1
a679 1
    rl_line_buffer = (char *)xmalloc (rl_line_buffer_len = DEFAULT_BUFFER_SIZE);
d682 1
a682 3
  if (rl_terminal_name == 0)
    rl_terminal_name = sh_get_env_value ("TERM");
  _rl_init_terminal_io (rl_terminal_name);
d699 2
a700 2
      _rl_screenwidth--;
      _rl_screenchars -= _rl_screenheight;
d726 1
a726 1
  rl_tty_set_default_bindings (_rl_keymap);
a728 1
/* Bind some common arrow key sequences in MAP. */
d730 1
a730 2
bind_arrow_keys_internal (map)
     Keymap map;
d732 1
a732 4
  Keymap xkeymap;

  xkeymap = _rl_keymap;
  _rl_keymap = map;
d735 18
a752 19
   _rl_bind_if_unbound ("\033[0A", rl_get_previous_history);
   _rl_bind_if_unbound ("\033[0B", rl_backward_char);
   _rl_bind_if_unbound ("\033[0C", rl_forward_char);
   _rl_bind_if_unbound ("\033[0D", rl_get_next_history);
#endif

  _rl_bind_if_unbound ("\033[A", rl_get_previous_history);
  _rl_bind_if_unbound ("\033[B", rl_get_next_history);
  _rl_bind_if_unbound ("\033[C", rl_forward_char);
  _rl_bind_if_unbound ("\033[D", rl_backward_char);
  _rl_bind_if_unbound ("\033[H", rl_beg_of_line);
  _rl_bind_if_unbound ("\033[F", rl_end_of_line);

  _rl_bind_if_unbound ("\033OA", rl_get_previous_history);
  _rl_bind_if_unbound ("\033OB", rl_get_next_history);
  _rl_bind_if_unbound ("\033OC", rl_forward_char);
  _rl_bind_if_unbound ("\033OD", rl_backward_char);
  _rl_bind_if_unbound ("\033OH", rl_beg_of_line);
  _rl_bind_if_unbound ("\033OF", rl_end_of_line);
d754 8
a761 1
  _rl_keymap = xkeymap;
d764 1
a764 1
/* Try and bind the common arrow key prefixes after giving termcap and
d770 6
a775 1
  bind_arrow_keys_internal (emacs_standard_keymap);
d778 2
a779 2
  bind_arrow_keys_internal (vi_movement_keymap);
  bind_arrow_keys_internal (vi_insertion_keymap);
d781 229
d1014 23
a1036 1
/*		Saving and Restoring Readline's state		    */
d1040 66
d1107 2
a1108 2
rl_save_state (sp)
     struct readline_state *sp;
d1110 103
a1212 2
  if (sp == 0)
    return -1;
d1214 1
a1214 20
  sp->point = rl_point;
  sp->end = rl_end;
  sp->mark = rl_mark;
  sp->buffer = rl_line_buffer;
  sp->buflen = rl_line_buffer_len;
  sp->ul = rl_undo_list;
  sp->prompt = rl_prompt;

  sp->rlstate = rl_readline_state;
  sp->done = rl_done;
  sp->kmap = _rl_keymap;

  sp->lastfunc = rl_last_func;
  sp->insmode = rl_insert_mode;
  sp->edmode = rl_editing_mode;
  sp->kseqlen = rl_key_sequence_length;
  sp->inf = rl_instream;
  sp->outf = rl_outstream;
  sp->pendingin = rl_pending_input;
  sp->macro = rl_executing_macro;
d1216 2
a1217 2
  sp->catchsigs = rl_catch_signals;
  sp->catchsigwinch = rl_catch_sigwinch;
d1219 1
a1219 1
  return (0);
d1222 3
d1226 2
a1227 2
rl_restore_state (sp)
     struct readline_state *sp;
d1229 12
a1240 2
  if (sp == 0)
    return -1;
d1242 5
a1246 20
  rl_point = sp->point;
  rl_end = sp->end;
  rl_mark = sp->mark;
  the_line = rl_line_buffer = sp->buffer;
  rl_line_buffer_len = sp->buflen;
  rl_undo_list = sp->ul;
  rl_prompt = sp->prompt;

  rl_readline_state = sp->rlstate;
  rl_done = sp->done;
  _rl_keymap = sp->kmap;

  rl_last_func = sp->lastfunc;
  rl_insert_mode = sp->insmode;
  rl_editing_mode = sp->edmode;
  rl_key_sequence_length = sp->kseqlen;
  rl_instream = sp->inf;
  rl_outstream = sp->outf;
  rl_pending_input = sp->pendingin;
  rl_executing_macro = sp->macro;
d1248 1
a1248 2
  rl_catch_signals = sp->catchsigs;
  rl_catch_sigwinch = sp->catchsigwinch;
d1250 518
d1769 320
@


1.4.22.2
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@a935 1
#if defined (SIGWINCH)
a936 1
#endif
a969 1
#if defined (SIGWINCH)
a970 1
#endif
@


1.4.16.1
log
@2002-08-24  Elena Zannoni  <ezannoni@@redhat.com>

        Import of readline 4.3:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@d4 1
a4 1
/* Copyright (C) 1987-2002 Free Software Foundation, Inc.
a54 1
#include "rlmbutil.h"
d70 1
a70 1
#  define RL_LIBRARY_VERSION "4.3"
d73 2
a74 5
#ifndef RL_READLINE_VERSION
#  define RL_READLINE_VERSION	0x0403
#endif

extern void _rl_free_history_entry PARAMS((HIST_ENTRY *));
d77 1
a77 2
static char *readline_internal PARAMS((void));
static void readline_initialize_everything PARAMS((void));
d79 5
a83 2
static void bind_arrow_keys_internal PARAMS((Keymap));
static void bind_arrow_keys PARAMS((void));
d85 1
a85 1
static void readline_default_bindings PARAMS((void));
d93 1
a93 1
const char *rl_library_version = RL_LIBRARY_VERSION;
a94 3
int rl_readline_version = RL_READLINE_VERSION;

/* True if this is `real' readline as opposed to some stub substitute. */
a103 3
/* The current insert mode:  input (the default) or overwrite */
int rl_insert_mode = RL_IM_DEFAULT;

a123 1
#if 0
a125 4
#endif

/* Flags word encapsulating the current readline state. */
int rl_readline_state = RL_STATE_NONE;
d140 1
a140 1
rl_command_func_t *rl_last_func = (rl_command_func_t *)NULL;
d152 2
a153 5
/* Non-zero means echo characters as they are read.  Defaults to no echo;
   set to 1 if there is a controlling terminal, we can get its attributes,
   and the attributes include `echo'.  Look at rltty.c:prepare_terminal_settings
   for the code that sets it. */
int readline_echoing_p = 0;
d156 1
a156 1
char *rl_prompt = (char *)NULL;
d168 1
a168 1
rl_hook_func_t *rl_startup_hook = (rl_hook_func_t *)NULL;
d173 1
a173 1
rl_hook_func_t *rl_pre_input_hook = (rl_hook_func_t *)NULL;
d186 1
a186 1
const char *rl_terminal_name = (const char *)NULL;
d216 1
a216 1
/* Forward declarations used by the display, termcap, and history code. */
a245 13
/* Set up the prompt and expand it.  Called from readline() and
   rl_callback_handler_install (). */
int
rl_set_prompt (prompt)
     const char *prompt;
{
  FREE (rl_prompt);
  rl_prompt = prompt ? savestring (prompt) : (char *)NULL;

  rl_visible_prompt_length = rl_expand_prompt (rl_prompt);
  return 0;
}
  
d250 1
a250 1
     const char *prompt;
d254 2
d259 1
a259 1
      rl_clear_pending_input ();
d263 1
a263 1
  rl_set_prompt (prompt);
d299 1
a299 4
  /* If we're not echoing, we still want to at least print a prompt, because
     rl_redisplay will not do it for us.  If the calling application has a
     custom redisplay function, though, let that function handle it. */
  if (readline_echoing_p == 0 && rl_redisplay_function == rl_redisplay)
a315 2
    }

d317 2
a318 2
  if (rl_editing_mode == vi_mode)
    rl_vi_insertion_mode (1, 0);
d320 1
d351 1
a351 4
    rl_free_undo_list ();

  /* Restore normal cursor, if available. */
  _rl_set_insert_mode (RL_IM_INSERT, 0);
a386 1
      RL_SETSTATE(RL_STATE_READCMD);
a387 1
      RL_UNSETSTATE(RL_STATE_READCMD);
a397 1
	  RL_SETSTATE(RL_STATE_DONE);
d473 1
a473 1
  rl_point = rl_end = rl_mark = 0;
a491 9
  return _rl_dispatch_subseq (key, map, 0);
}

int
_rl_dispatch_subseq (key, map, got_subseq)
     register int key;
     Keymap map;
     int got_subseq;
{
d494 1
a494 1
  rl_command_func_t *func;
d500 1
a500 1
	  if (RL_ISSTATE (RL_STATE_MACRODEF))
d508 1
a508 1
	rl_ding ();
d512 1
a512 1
  if (RL_ISSTATE (RL_STATE_MACRODEF))
d520 1
a520 1
      if (func)
a532 1
	  RL_SETSTATE(RL_STATE_DISPATCHING);
a533 1
	  RL_UNSETSTATE(RL_STATE_DISPATCHING);
d539 1
a539 1
	  if (rl_pending_input == 0 && map[key].function != rl_digit_argument)
a541 17
      else if (map[ANYOTHERKEY].function)
	{
	  /* OK, there's no function bound in this map, but there is a
	     shadow function that was overridden when the current keymap
	     was created.  Return -2 to note  that. */
	  _rl_unget_char  (key);
	  return -2;
	}
      else if (got_subseq)
	{
	  /* Return -1 to note that we're in a subsequence, but  we don't
	     have a matching key, nor was one overridden.  This means
	     we need to back up the recursion chain and find the last
	     subsequence that is bound to a function. */
	  _rl_unget_char (key);
	  return -1;
	}
d550 1
a550 1
      if (map[key].function != 0)
a551 12
#if defined (VI_MODE)
	  /* The only way this test will be true is if a subsequence has been
	     bound starting with ESC, generally the arrow keys.  What we do is
	     check whether there's input in the queue, which there generally
	     will be if an arrow key has been pressed, and, if there's not,
	     just dispatch to (what we assume is) rl_vi_movement_mode right
	     away.  This is essentially an input test with a zero timeout. */
	  if (rl_editing_mode == vi_mode && key == ESC && map == vi_insertion_keymap
	      && _rl_input_queued (0) == 0)
	    return (_rl_dispatch (ANYOTHERKEY, FUNCTION_TO_KEYMAP (map, key)));
#endif

a552 4

	  if (key == ESC)
	    RL_SETSTATE(RL_STATE_METANEXT);
	  RL_SETSTATE(RL_STATE_MOREINPUT);
d554 1
a554 33
	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
	  if (key == ESC)
	    RL_UNSETSTATE(RL_STATE_METANEXT);

	  if (newkey < 0)
	    {
	      _rl_abort_internal ();
	      return -1;
	    }

	  r = _rl_dispatch_subseq (newkey, FUNCTION_TO_KEYMAP (map, key), got_subseq || map[ANYOTHERKEY].function);

	  if (r == -2)
	    /* We didn't match anything, and the keymap we're indexed into
	       shadowed a function previously bound to that prefix.  Call
	       the function.  The recursive call to _rl_dispatch_subseq has
	       already taken care of pushing any necessary input back onto
	       the input queue with _rl_unget_char. */
	    r = _rl_dispatch (ANYOTHERKEY, FUNCTION_TO_KEYMAP (map, key));
	  else if (r && map[ANYOTHERKEY].function)
	    {
	      /* We didn't match (r is probably -1), so return something to
		 tell the caller that it should try ANYOTHERKEY for an
		 overridden function. */
	      _rl_unget_char (key);
	      return -2;
	    }
	  else if (r && got_subseq)
	    {
	      /* OK, back up the chain. */
	      _rl_unget_char (key);
	      return -1;
	    }
d564 1
a564 1
      if (map[key].function != 0)
a593 1
      RL_SETSTATE(RL_STATE_INITIALIZING);
a594 1
      RL_UNSETSTATE(RL_STATE_INITIALIZING);
a595 1
      RL_SETSTATE(RL_STATE_INITIALIZED);
a602 1
  RL_UNSETSTATE(RL_STATE_DONE);
d605 1
a605 1
  _rl_start_using_history ();
d611 1
a611 1
  rl_last_func = (rl_command_func_t *)NULL;
a620 3
  /* Each line starts in insert mode (the default). */
  _rl_set_insert_mode (RL_IM_DEFAULT, 1);

d661 2
a662 4
#if 0
  /* Find out if we are running in Emacs -- UNUSED. */
  running_in_emacs = sh_get_env_value ("EMACS") != (char *)0;
#endif
d679 1
a679 1
    rl_line_buffer = (char *)xmalloc (rl_line_buffer_len = DEFAULT_BUFFER_SIZE);
d682 1
a682 3
  if (rl_terminal_name == 0)
    rl_terminal_name = sh_get_env_value ("TERM");
  _rl_init_terminal_io (rl_terminal_name);
d699 2
a700 2
      _rl_screenwidth--;
      _rl_screenchars -= _rl_screenheight;
d726 1
a726 1
  rl_tty_set_default_bindings (_rl_keymap);
a728 1
/* Bind some common arrow key sequences in MAP. */
d730 1
a730 2
bind_arrow_keys_internal (map)
     Keymap map;
d732 1
a732 4
  Keymap xkeymap;

  xkeymap = _rl_keymap;
  _rl_keymap = map;
d735 18
a752 19
   _rl_bind_if_unbound ("\033[0A", rl_get_previous_history);
   _rl_bind_if_unbound ("\033[0B", rl_backward_char);
   _rl_bind_if_unbound ("\033[0C", rl_forward_char);
   _rl_bind_if_unbound ("\033[0D", rl_get_next_history);
#endif

  _rl_bind_if_unbound ("\033[A", rl_get_previous_history);
  _rl_bind_if_unbound ("\033[B", rl_get_next_history);
  _rl_bind_if_unbound ("\033[C", rl_forward_char);
  _rl_bind_if_unbound ("\033[D", rl_backward_char);
  _rl_bind_if_unbound ("\033[H", rl_beg_of_line);
  _rl_bind_if_unbound ("\033[F", rl_end_of_line);

  _rl_bind_if_unbound ("\033OA", rl_get_previous_history);
  _rl_bind_if_unbound ("\033OB", rl_get_next_history);
  _rl_bind_if_unbound ("\033OC", rl_forward_char);
  _rl_bind_if_unbound ("\033OD", rl_backward_char);
  _rl_bind_if_unbound ("\033OH", rl_beg_of_line);
  _rl_bind_if_unbound ("\033OF", rl_end_of_line);
d754 8
a761 1
  _rl_keymap = xkeymap;
d764 1
a764 1
/* Try and bind the common arrow key prefixes after giving termcap and
d770 6
a775 1
  bind_arrow_keys_internal (emacs_standard_keymap);
d778 2
a779 2
  bind_arrow_keys_internal (vi_movement_keymap);
  bind_arrow_keys_internal (vi_insertion_keymap);
d781 229
d1014 23
a1036 1
/*		Saving and Restoring Readline's state		    */
d1040 66
d1107 2
a1108 2
rl_save_state (sp)
     struct readline_state *sp;
d1110 103
a1212 2
  if (sp == 0)
    return -1;
d1214 1
a1214 20
  sp->point = rl_point;
  sp->end = rl_end;
  sp->mark = rl_mark;
  sp->buffer = rl_line_buffer;
  sp->buflen = rl_line_buffer_len;
  sp->ul = rl_undo_list;
  sp->prompt = rl_prompt;

  sp->rlstate = rl_readline_state;
  sp->done = rl_done;
  sp->kmap = _rl_keymap;

  sp->lastfunc = rl_last_func;
  sp->insmode = rl_insert_mode;
  sp->edmode = rl_editing_mode;
  sp->kseqlen = rl_key_sequence_length;
  sp->inf = rl_instream;
  sp->outf = rl_outstream;
  sp->pendingin = rl_pending_input;
  sp->macro = rl_executing_macro;
d1216 2
a1217 2
  sp->catchsigs = rl_catch_signals;
  sp->catchsigwinch = rl_catch_sigwinch;
d1219 1
a1219 1
  return (0);
d1222 3
d1226 2
a1227 2
rl_restore_state (sp)
     struct readline_state *sp;
d1229 12
a1240 2
  if (sp == 0)
    return -1;
d1242 5
a1246 20
  rl_point = sp->point;
  rl_end = sp->end;
  rl_mark = sp->mark;
  the_line = rl_line_buffer = sp->buffer;
  rl_line_buffer_len = sp->buflen;
  rl_undo_list = sp->ul;
  rl_prompt = sp->prompt;

  rl_readline_state = sp->rlstate;
  rl_done = sp->done;
  _rl_keymap = sp->kmap;

  rl_last_func = sp->lastfunc;
  rl_insert_mode = sp->insmode;
  rl_editing_mode = sp->edmode;
  rl_key_sequence_length = sp->kseqlen;
  rl_instream = sp->inf;
  rl_outstream = sp->outf;
  rl_pending_input = sp->pendingin;
  rl_executing_macro = sp->macro;
d1248 1
a1248 2
  rl_catch_signals = sp->catchsigs;
  rl_catch_sigwinch = sp->catchsigwinch;
d1250 518
d1769 320
@


1.3
log
@Dummy commit before importof 4.1 version
@
text
@d11 1
a11 1
   as published by the Free Software Foundation; either version 1, or
d22 1
a22 1
   675 Mass Ave, Cambridge, MA 02139, USA. */
a49 1
#include <signal.h>
d65 4
d70 1
a70 1
#  define RL_LIBRARY_VERSION "4.0"
a75 82
/* NOTE: Functions and variables prefixed with `_rl_' are
   pseudo-global: they are global so they can be shared
   between files in the readline library, but are not intended
   to be visible to readline callers. */

/* Variables and functions imported from terminal.c */
extern int _rl_init_terminal_io ();
extern void _rl_enable_meta_key ();
#ifdef _MINIX
extern void _rl_output_character_function ();
#else
extern int _rl_output_character_function ();
#endif

extern int _rl_enable_meta;
extern int _rl_term_autowrap;
extern int screenwidth, screenheight, screenchars;

/* Variables and functions imported from rltty.c. */
extern void rl_prep_terminal (), rl_deprep_terminal ();
extern void rltty_set_default_bindings ();

/* Functions imported from util.c. */
extern void _rl_abort_internal ();
extern void rl_extend_line_buffer ();
extern int alphabetic ();

/* Functions imported from bind.c. */
extern void _rl_bind_if_unbound ();

/* Functions imported from input.c. */
extern int _rl_any_typein ();
extern void _rl_insert_typein ();
extern int rl_read_key ();

/* Functions imported from nls.c */
extern int _rl_init_eightbit ();

/* Functions imported from shell.c */
extern char *get_env_value ();

/* External redisplay functions and variables from display.c */
extern void _rl_move_vert ();
extern void _rl_update_final ();
extern void _rl_clear_to_eol ();
extern void _rl_clear_screen ();
extern void _rl_erase_entire_line ();

extern void _rl_erase_at_end_of_line ();
extern void _rl_move_cursor_relative ();

extern int _rl_vis_botlin;
extern int _rl_last_c_pos;
extern int _rl_horizontal_scroll_mode;
extern int rl_display_fixed;
extern int _rl_suppress_redisplay;
extern char *rl_display_prompt;

/* Variables imported from complete.c. */
extern char *rl_completer_word_break_characters;
extern char *rl_basic_word_break_characters;
extern int rl_completion_query_items;
extern int rl_complete_with_tilde_expansion;

/* Variables and functions from macro.c. */
extern void _rl_add_macro_char ();
extern void _rl_with_macro_input ();
extern int _rl_next_macro_key ();
extern int _rl_defining_kbd_macro;

#if defined (VI_MODE)
/* Functions imported from vi_mode.c. */
extern void _rl_vi_set_last ();
extern void _rl_vi_reset_last ();
extern void _rl_vi_done_inserting ();
extern int _rl_vi_textmod_command ();
extern void _rl_vi_initialize_line ();
#endif /* VI_MODE */

extern UNDO_LIST *rl_undo_list;
extern int _rl_doing_an_undo;

d77 1
a77 1
void _rl_free_history_entry ();
d79 5
a83 2
int _rl_dispatch ();
int _rl_init_argument ();
d85 1
a85 18
static char *readline_internal ();
static void readline_initialize_everything ();
static void start_using_history ();
static void bind_arrow_keys ();

#if !defined (__GO32__) || defined (HAVE_TERMIOS_H)
static void readline_default_bindings ();
#endif /* !__GO32__ */

#if defined (__GO32__)
#  include <go32.h>
#  include <pc.h>
#  if !defined (__DJGPP__)
#    undef HANDLE_SIGNALS
#  endif /* !__DJGPP__ */
#endif /* __GO32__ */

extern char *xmalloc (), *xrealloc ();
d95 2
d159 4
d208 4
d291 2
d301 1
a301 1
      if (rl_prompt)
d303 2
a304 1
	  fprintf (_rl_out_stream, "%s", rl_prompt);
d306 1
d311 4
a314 1
      rl_on_new_line ();
d406 1
a406 1
      _rl_dispatch (c, _rl_keymap);
d421 6
d624 1
d648 1
d654 1
d659 1
a683 1
#if !defined (__GO32__) || defined (HAVE_TERMIOS_H)
a685 1
#endif /* !__GO32__ || HAVE_TERMIOS_H */
d734 11
d1069 4
d1207 1
a1207 1
  int curr_line, nleft;
d1209 1
a1209 11
  /* Find out whether or not there might be invisible characters in the
     editing buffer. */
  if (rl_display_prompt == rl_prompt)
    nleft = _rl_last_c_pos - screenwidth - rl_visible_prompt_length;
  else
    nleft = _rl_last_c_pos - screenwidth;

  if (nleft > 0)
    curr_line = 1 + nleft / screenwidth;
  else
    curr_line = 0;
a1213 10
#if defined (__GO32__) && !defined (__DJGPP__)
  {
    int row, col, width, row_start;

    ScreenGetCursor (&row, &col);
    width = ScreenCols ();
    row_start = ScreenPrimary + (row * width);
    memset (row_start + col, 0, (width - col) * 2);
  }
#else /* !__GO32__ || __DJGPP__ */
a1214 1
#endif /* !__GO32__ || __DJGPP__ */
d1352 3
d1356 4
a1551 2

static int rl_change_case ();
@


1.2
log
@[__GO32__]: If HAVE_TEMIOS_H is defined, declare readline_default_bindings.
Don't undef HANDLE_SIGNALS if __DJGPP__ is defined.
(readline_initialize_everything): [__GO32__]: Call readline_default_bindings
if HAVE_TERMIOS_H is defined.
(rl_refresh_line) [__GO32__]: Don't use this code if __DJGPP__ is defined.
@
text
@@


1.1
log
@Initial revision
@
text
@d67 1
a67 1
#  define RL_LIBRARY_VERSION "2.2-bash"
a85 1
extern void _rl_get_screen_size ();
a101 1
extern int rl_set_keymap_from_edit_mode ();
d119 1
a119 3

extern void _rl_save_prompt ();
extern void _rl_restore_prompt ();
d166 1
a166 1
#if !defined (__GO32__)
d173 3
a175 1
#  undef HANDLE_SIGNALS
d254 1
a254 1
   before readline_internal () prints the first prompt. */
d257 5
d292 3
d397 3
d417 1
a417 1
      entry = replace_history_entry (where_history (), the_line, (HIST_ENTRY *)NULL);
d500 6
d519 1
a519 1
  int eof;
d750 1
a750 1
#if !defined (__GO32__)
d753 1
a753 1
#endif /* !__GO32__ */
d855 1
a855 1
  _rl_save_prompt ();
d860 8
d884 1
a884 1
	      _rl_restore_prompt ();
d907 1
a907 1
	  _rl_restore_prompt ();
d1257 2
a1258 1
rl_refresh_line ()
d1277 1
a1277 1
#if defined (__GO32__)
d1286 1
a1286 1
#else /* !__GO32__ */
d1288 1
a1288 1
#endif /* !__GO32__ */
d1305 1
a1305 1
      rl_refresh_line ();
d1455 5
a1538 1
  
d1541 14
d1578 13
d1917 1
a1917 1
      temp = replace_history_entry (where_history (), the_line, rl_undo_list);
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-08-02 snapshot
@
text
@d67 1
a67 1
#  define RL_LIBRARY_VERSION "4.0"
d86 1
d103 1
d121 3
a123 1
extern void _rl_erase_entire_line ();
d256 1
a256 1
   before readline_internal_setup () prints the first prompt. */
a258 5
/* If non-zero, this is the address of a function to call just before
   readline_internal_setup () returns and readline_internal starts
   reading input characters. */
Function *rl_pre_input_hook = (Function *)NULL;

a288 3
/* Non-zero means to erase entire line, including prompt, on empty input lines. */
int rl_erase_empty_line = 0;

a390 3

  if (rl_pre_input_hook)
    (*rl_pre_input_hook) ();
d408 1
a408 1
      entry = replace_history_entry (where_history (), the_line, (histdata_t)NULL);
a490 6
      /* If the application writer has told us to erase the entire line if
	  the only character typed was something bound to rl_newline, do so. */
      if (rl_erase_empty_line && rl_done && rl_last_func == rl_newline &&
	  rl_point == 0 && rl_end == 0)
	_rl_erase_entire_line ();

d504 1
a504 1
  int eof = 1;
d840 1
a840 1
  rl_save_prompt ();
a844 8
      if (rl_numeric_arg > 1000000)
	{
	  sawdigits = rl_explicit_arg = rl_numeric_arg = 0;
	  ding ();
	  rl_restore_prompt ();
	  rl_clear_message ();
	  return 1;
	}
d861 1
a861 1
	      rl_restore_prompt ();
d884 1
a884 1
	  rl_restore_prompt ();
d1234 1
a1234 2
rl_refresh_line (ignore1, ignore2)
     int ignore1, ignore2;
d1281 1
a1281 1
      rl_refresh_line (count, key);
a1430 5
  /* If we've been asked to erase empty lines, suppress the final update,
     since _rl_update_final calls crlf(). */
  if (rl_erase_empty_line && rl_point == 0 && rl_end == 0)
    return 0;

d1510 1
a1512 14
/* Delete the character under the cursor, unless the insertion
   point is at the end of the line, in which case the character
   behind the cursor is deleted.  COUNT is obeyed and may be used
   to delete forward or backward that many characters. */      
int
rl_rubout_or_delete (count, key)
     int count, key;
{
  if (rl_end != 0 && rl_point == rl_end)
    return (rl_rubout (count, key));
  else
    return (rl_delete (count, key));
}  

a1535 13
/* Like the tcsh editing function delete-char-or-list.  The eof character
   is caught before this is invoked, so this really does the same thing as
   delete-char-or-list-or-eof, as long as it's bound to the eof character. */
int
rl_delete_or_show_completions (count, key)
     int count, key;
{
  if (rl_end != 0 && rl_point == rl_end)
    return (rl_possible_completions (count, key));
  else
    return (rl_delete (count, key));
}

d1862 1
a1862 1
      temp = replace_history_entry (where_history (), the_line, (histdata_t)rl_undo_list);
@


1.1.1.3
log
@Import of readline 4.1
@
text
@d11 1
a11 1
   as published by the Free Software Foundation; either version 2, or
d22 1
a22 1
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
d50 1
a65 4
#include "rlprivate.h"
#include "rlshell.h"
#include "xmalloc.h"

d67 1
a67 1
#  define RL_LIBRARY_VERSION "4.1"
d73 82
d156 1
a156 1
void _rl_free_history_entry __P((HIST_ENTRY *));
d158 2
a159 5
static char *readline_internal __P((void));
static void readline_initialize_everything __P((void));
static void start_using_history __P((void));
static void bind_arrow_keys __P((void));
static int rl_change_case __P((int, int));
d161 16
a176 1
static void readline_default_bindings __P((void));
a185 2
int rl_gnu_readline_p = 1;

a247 4
/* Set to non-zero by calling application if it has already printed rl_prompt
   and does not want readline to do it the first time. */
int rl_already_prompted = 0;

a292 4
/* Non-zero means to read only this many characters rather than up to a
   character bound to accept-line. */
int rl_num_chars_to_read;

a371 2
  char *nprompt;

d380 1
a380 1
      if (rl_prompt && rl_already_prompted == 0)
d382 1
a382 2
	  nprompt = _rl_strip_prompt (rl_prompt);
	  fprintf (_rl_out_stream, "%s", nprompt);
a383 1
	  free (nprompt);
d388 1
a388 4
      if (rl_prompt && rl_already_prompted)
	rl_on_new_line_with_prompt ();
      else
	rl_on_new_line ();
d480 1
a480 1
      _rl_dispatch ((unsigned char)c, _rl_keymap);
a494 6
      if (rl_num_chars_to_read && rl_end >= rl_num_chars_to_read)
        {
          (*rl_redisplay_function) ();
          rl_newline (1, '\n');
        }

a691 1
#if 0
a714 1
#endif
a719 1
#if 0
a723 1
#endif
d748 1
d751 1
a799 11
#if defined (__MSDOS__)
  f = rl_function_of_keyseq ("\033[0A", _rl_keymap, (int *)NULL);
  if (!f || f == rl_do_lowercase_version)
    {
       _rl_bind_if_unbound ("\033[0A", rl_get_previous_history);
       _rl_bind_if_unbound ("\033[0B", rl_backward);
       _rl_bind_if_unbound ("\033[0C", rl_forward);
       _rl_bind_if_unbound ("\033[0D", rl_get_next_history);
    }
#endif
	
a1123 4

  if (rl_end < 0)
    rl_end = 0;

d1258 1
a1258 1
  int curr_line;
d1260 11
a1270 1
  curr_line = _rl_current_display_line ();
d1275 10
d1286 1
a1423 3
#if defined (HANDLE_SIGNALS)
  _rl_disable_tty_signals ();
#endif
a1424 4
#if defined (HANDLE_SIGNALS)
  _rl_restore_tty_signals ();
#endif

d1617 2
@


1.1.1.4
log
@import of readline-4.3
@
text
@d4 1
a4 1
/* Copyright (C) 1987-2002 Free Software Foundation, Inc.
a54 1
#include "rlmbutil.h"
d70 1
a70 1
#  define RL_LIBRARY_VERSION "4.3"
d73 2
a74 5
#ifndef RL_READLINE_VERSION
#  define RL_READLINE_VERSION	0x0403
#endif

extern void _rl_free_history_entry PARAMS((HIST_ENTRY *));
d77 1
a77 2
static char *readline_internal PARAMS((void));
static void readline_initialize_everything PARAMS((void));
d79 5
a83 2
static void bind_arrow_keys_internal PARAMS((Keymap));
static void bind_arrow_keys PARAMS((void));
d85 1
a85 1
static void readline_default_bindings PARAMS((void));
d93 1
a93 1
const char *rl_library_version = RL_LIBRARY_VERSION;
a94 3
int rl_readline_version = RL_READLINE_VERSION;

/* True if this is `real' readline as opposed to some stub substitute. */
a103 3
/* The current insert mode:  input (the default) or overwrite */
int rl_insert_mode = RL_IM_DEFAULT;

a123 1
#if 0
a125 4
#endif

/* Flags word encapsulating the current readline state. */
int rl_readline_state = RL_STATE_NONE;
d140 1
a140 1
rl_command_func_t *rl_last_func = (rl_command_func_t *)NULL;
d152 2
a153 5
/* Non-zero means echo characters as they are read.  Defaults to no echo;
   set to 1 if there is a controlling terminal, we can get its attributes,
   and the attributes include `echo'.  Look at rltty.c:prepare_terminal_settings
   for the code that sets it. */
int readline_echoing_p = 0;
d156 1
a156 1
char *rl_prompt = (char *)NULL;
d168 1
a168 1
rl_hook_func_t *rl_startup_hook = (rl_hook_func_t *)NULL;
d173 1
a173 1
rl_hook_func_t *rl_pre_input_hook = (rl_hook_func_t *)NULL;
d186 1
a186 1
const char *rl_terminal_name = (const char *)NULL;
d216 1
a216 1
/* Forward declarations used by the display, termcap, and history code. */
a245 13
/* Set up the prompt and expand it.  Called from readline() and
   rl_callback_handler_install (). */
int
rl_set_prompt (prompt)
     const char *prompt;
{
  FREE (rl_prompt);
  rl_prompt = prompt ? savestring (prompt) : (char *)NULL;

  rl_visible_prompt_length = rl_expand_prompt (rl_prompt);
  return 0;
}
  
d250 1
a250 1
     const char *prompt;
d254 2
d259 1
a259 1
      rl_clear_pending_input ();
d263 1
a263 1
  rl_set_prompt (prompt);
d299 1
a299 4
  /* If we're not echoing, we still want to at least print a prompt, because
     rl_redisplay will not do it for us.  If the calling application has a
     custom redisplay function, though, let that function handle it. */
  if (readline_echoing_p == 0 && rl_redisplay_function == rl_redisplay)
a315 2
    }

d317 2
a318 2
  if (rl_editing_mode == vi_mode)
    rl_vi_insertion_mode (1, 0);
d320 1
d351 1
a351 4
    rl_free_undo_list ();

  /* Restore normal cursor, if available. */
  _rl_set_insert_mode (RL_IM_INSERT, 0);
a386 1
      RL_SETSTATE(RL_STATE_READCMD);
a387 1
      RL_UNSETSTATE(RL_STATE_READCMD);
a397 1
	  RL_SETSTATE(RL_STATE_DONE);
d473 1
a473 1
  rl_point = rl_end = rl_mark = 0;
a491 9
  return _rl_dispatch_subseq (key, map, 0);
}

int
_rl_dispatch_subseq (key, map, got_subseq)
     register int key;
     Keymap map;
     int got_subseq;
{
d494 1
a494 1
  rl_command_func_t *func;
d500 1
a500 1
	  if (RL_ISSTATE (RL_STATE_MACRODEF))
d508 1
a508 1
	rl_ding ();
d512 1
a512 1
  if (RL_ISSTATE (RL_STATE_MACRODEF))
d520 1
a520 1
      if (func)
a532 1
	  RL_SETSTATE(RL_STATE_DISPATCHING);
a533 1
	  RL_UNSETSTATE(RL_STATE_DISPATCHING);
d539 1
a539 1
	  if (rl_pending_input == 0 && map[key].function != rl_digit_argument)
a541 17
      else if (map[ANYOTHERKEY].function)
	{
	  /* OK, there's no function bound in this map, but there is a
	     shadow function that was overridden when the current keymap
	     was created.  Return -2 to note  that. */
	  _rl_unget_char  (key);
	  return -2;
	}
      else if (got_subseq)
	{
	  /* Return -1 to note that we're in a subsequence, but  we don't
	     have a matching key, nor was one overridden.  This means
	     we need to back up the recursion chain and find the last
	     subsequence that is bound to a function. */
	  _rl_unget_char (key);
	  return -1;
	}
d550 1
a550 1
      if (map[key].function != 0)
a551 12
#if defined (VI_MODE)
	  /* The only way this test will be true is if a subsequence has been
	     bound starting with ESC, generally the arrow keys.  What we do is
	     check whether there's input in the queue, which there generally
	     will be if an arrow key has been pressed, and, if there's not,
	     just dispatch to (what we assume is) rl_vi_movement_mode right
	     away.  This is essentially an input test with a zero timeout. */
	  if (rl_editing_mode == vi_mode && key == ESC && map == vi_insertion_keymap
	      && _rl_input_queued (0) == 0)
	    return (_rl_dispatch (ANYOTHERKEY, FUNCTION_TO_KEYMAP (map, key)));
#endif

a552 4

	  if (key == ESC)
	    RL_SETSTATE(RL_STATE_METANEXT);
	  RL_SETSTATE(RL_STATE_MOREINPUT);
d554 1
a554 33
	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
	  if (key == ESC)
	    RL_UNSETSTATE(RL_STATE_METANEXT);

	  if (newkey < 0)
	    {
	      _rl_abort_internal ();
	      return -1;
	    }

	  r = _rl_dispatch_subseq (newkey, FUNCTION_TO_KEYMAP (map, key), got_subseq || map[ANYOTHERKEY].function);

	  if (r == -2)
	    /* We didn't match anything, and the keymap we're indexed into
	       shadowed a function previously bound to that prefix.  Call
	       the function.  The recursive call to _rl_dispatch_subseq has
	       already taken care of pushing any necessary input back onto
	       the input queue with _rl_unget_char. */
	    r = _rl_dispatch (ANYOTHERKEY, FUNCTION_TO_KEYMAP (map, key));
	  else if (r && map[ANYOTHERKEY].function)
	    {
	      /* We didn't match (r is probably -1), so return something to
		 tell the caller that it should try ANYOTHERKEY for an
		 overridden function. */
	      _rl_unget_char (key);
	      return -2;
	    }
	  else if (r && got_subseq)
	    {
	      /* OK, back up the chain. */
	      _rl_unget_char (key);
	      return -1;
	    }
d564 1
a564 1
      if (map[key].function != 0)
a593 1
      RL_SETSTATE(RL_STATE_INITIALIZING);
a594 1
      RL_UNSETSTATE(RL_STATE_INITIALIZING);
a595 1
      RL_SETSTATE(RL_STATE_INITIALIZED);
a602 1
  RL_UNSETSTATE(RL_STATE_DONE);
d605 1
a605 1
  _rl_start_using_history ();
d611 1
a611 1
  rl_last_func = (rl_command_func_t *)NULL;
a620 3
  /* Each line starts in insert mode (the default). */
  _rl_set_insert_mode (RL_IM_DEFAULT, 1);

d661 2
a662 4
#if 0
  /* Find out if we are running in Emacs -- UNUSED. */
  running_in_emacs = sh_get_env_value ("EMACS") != (char *)0;
#endif
d679 1
a679 1
    rl_line_buffer = (char *)xmalloc (rl_line_buffer_len = DEFAULT_BUFFER_SIZE);
d682 1
a682 3
  if (rl_terminal_name == 0)
    rl_terminal_name = sh_get_env_value ("TERM");
  _rl_init_terminal_io (rl_terminal_name);
d699 2
a700 2
      _rl_screenwidth--;
      _rl_screenchars -= _rl_screenheight;
d726 1
a726 1
  rl_tty_set_default_bindings (_rl_keymap);
a728 1
/* Bind some common arrow key sequences in MAP. */
d730 1
a730 2
bind_arrow_keys_internal (map)
     Keymap map;
d732 1
a732 4
  Keymap xkeymap;

  xkeymap = _rl_keymap;
  _rl_keymap = map;
d735 18
a752 19
   _rl_bind_if_unbound ("\033[0A", rl_get_previous_history);
   _rl_bind_if_unbound ("\033[0B", rl_backward_char);
   _rl_bind_if_unbound ("\033[0C", rl_forward_char);
   _rl_bind_if_unbound ("\033[0D", rl_get_next_history);
#endif

  _rl_bind_if_unbound ("\033[A", rl_get_previous_history);
  _rl_bind_if_unbound ("\033[B", rl_get_next_history);
  _rl_bind_if_unbound ("\033[C", rl_forward_char);
  _rl_bind_if_unbound ("\033[D", rl_backward_char);
  _rl_bind_if_unbound ("\033[H", rl_beg_of_line);
  _rl_bind_if_unbound ("\033[F", rl_end_of_line);

  _rl_bind_if_unbound ("\033OA", rl_get_previous_history);
  _rl_bind_if_unbound ("\033OB", rl_get_next_history);
  _rl_bind_if_unbound ("\033OC", rl_forward_char);
  _rl_bind_if_unbound ("\033OD", rl_backward_char);
  _rl_bind_if_unbound ("\033OH", rl_beg_of_line);
  _rl_bind_if_unbound ("\033OF", rl_end_of_line);
d754 8
a761 1
  _rl_keymap = xkeymap;
d764 1
a764 1
/* Try and bind the common arrow key prefixes after giving termcap and
d770 6
a775 1
  bind_arrow_keys_internal (emacs_standard_keymap);
d778 2
a779 2
  bind_arrow_keys_internal (vi_movement_keymap);
  bind_arrow_keys_internal (vi_insertion_keymap);
d781 229
d1014 23
a1036 1
/*		Saving and Restoring Readline's state		    */
d1040 66
d1107 2
a1108 2
rl_save_state (sp)
     struct readline_state *sp;
d1110 103
a1212 2
  if (sp == 0)
    return -1;
d1214 1
a1214 20
  sp->point = rl_point;
  sp->end = rl_end;
  sp->mark = rl_mark;
  sp->buffer = rl_line_buffer;
  sp->buflen = rl_line_buffer_len;
  sp->ul = rl_undo_list;
  sp->prompt = rl_prompt;

  sp->rlstate = rl_readline_state;
  sp->done = rl_done;
  sp->kmap = _rl_keymap;

  sp->lastfunc = rl_last_func;
  sp->insmode = rl_insert_mode;
  sp->edmode = rl_editing_mode;
  sp->kseqlen = rl_key_sequence_length;
  sp->inf = rl_instream;
  sp->outf = rl_outstream;
  sp->pendingin = rl_pending_input;
  sp->macro = rl_executing_macro;
d1216 2
a1217 2
  sp->catchsigs = rl_catch_signals;
  sp->catchsigwinch = rl_catch_sigwinch;
d1219 1
a1219 1
  return (0);
d1222 3
d1226 2
a1227 2
rl_restore_state (sp)
     struct readline_state *sp;
d1229 12
a1240 2
  if (sp == 0)
    return -1;
d1242 5
a1246 20
  rl_point = sp->point;
  rl_end = sp->end;
  rl_mark = sp->mark;
  the_line = rl_line_buffer = sp->buffer;
  rl_line_buffer_len = sp->buflen;
  rl_undo_list = sp->ul;
  rl_prompt = sp->prompt;

  rl_readline_state = sp->rlstate;
  rl_done = sp->done;
  _rl_keymap = sp->kmap;

  rl_last_func = sp->lastfunc;
  rl_insert_mode = sp->insmode;
  rl_editing_mode = sp->edmode;
  rl_key_sequence_length = sp->kseqlen;
  rl_instream = sp->inf;
  rl_outstream = sp->outf;
  rl_pending_input = sp->pendingin;
  rl_executing_macro = sp->macro;
d1248 1
a1248 2
  rl_catch_signals = sp->catchsigs;
  rl_catch_sigwinch = sp->catchsigwinch;
d1250 518
d1769 320
@


1.1.1.5
log
@import of readlilne 5.1
@
text
@d4 1
a4 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
d71 1
a71 1
#  define RL_LIBRARY_VERSION "5.1"
d75 1
a75 1
#  define RL_READLINE_VERSION	0x0501
a87 4
static void reset_default_bindings PARAMS((void));

static int _rl_subseq_result PARAMS((int, Keymap, int, int));
static int _rl_subseq_getchar PARAMS((int));
a105 1

a220 3
/* Keymap we're currently using to dispatch. */
Keymap _rl_dispatching_keymap;

a231 3
/* Key sequence `contexts' */
_rl_keyseq_cxt *_rl_kscxt = 0;

a252 4
/* Non-zero means to look at the termios special characters and bind
   them to equivalent readline functions at startup. */
int _rl_bind_stty_chars = 1;

d293 1
a293 2
  if (rl_prep_term_function)
    (*rl_prep_term_function) (_rl_meta_flag);
d300 1
a300 2
  if (rl_deprep_term_function)
    (*rl_deprep_term_function) ();
d350 1
a350 1
    rl_vi_insertion_mode (1, 'i');
a389 30
void
_rl_internal_char_cleanup ()
{
#if defined (VI_MODE)
  /* In vi mode, when you exit insert mode, the cursor moves back
     over the previous character.  We explicitly check for that here. */
  if (rl_editing_mode == vi_mode && _rl_keymap == vi_movement_keymap)
    rl_vi_check ();
#endif /* VI_MODE */

  if (rl_num_chars_to_read && rl_end >= rl_num_chars_to_read)
    {
      (*rl_redisplay_function) ();
      _rl_want_redisplay = 0;
      rl_newline (1, '\n');
    }

  if (rl_done == 0)
    {
      (*rl_redisplay_function) ();
      _rl_want_redisplay = 0;
    }

  /* If the application writer has told us to erase the entire line if
     the only character typed was something bound to rl_newline, do so. */
  if (rl_erase_empty_line && rl_done && rl_last_func == rl_newline &&
      rl_point == 0 && rl_end == 0)
    _rl_erase_entire_line ();
}

d412 1
a412 10
	{
	  (*rl_redisplay_function) ();
	  _rl_want_redisplay = 0;
	  /* If we get here, we're not being called from something dispatched
	     from _rl_callback_read_char(), which sets up its own value of
	     readline_top_level (saving and restoring the old, of course), so
	     we can just return here. */
	  if (RL_ISSTATE (RL_STATE_CALLBACK))
	    return (0);
	}
d417 1
a417 1
	  _rl_reset_argument ();
d451 21
a471 1
      _rl_internal_char_cleanup ();
a520 101
#if defined (READLINE_CALLBACKS)
_rl_keyseq_cxt *
_rl_keyseq_cxt_alloc ()
{
  _rl_keyseq_cxt *cxt;

  cxt = (_rl_keyseq_cxt *)xmalloc (sizeof (_rl_keyseq_cxt));

  cxt->flags = cxt->subseq_arg = cxt->subseq_retval = 0;

  cxt->okey = 0;
  cxt->ocxt = _rl_kscxt;
  cxt->childval = 42;		/* sentinel value */

  return cxt;
}

void
_rl_keyseq_cxt_dispose (cxt)
    _rl_keyseq_cxt *cxt;
{
  free (cxt);
}

void
_rl_keyseq_chain_dispose ()
{
  _rl_keyseq_cxt *cxt;

  while (_rl_kscxt)
    {
      cxt = _rl_kscxt;
      _rl_kscxt = _rl_kscxt->ocxt;
      _rl_keyseq_cxt_dispose (cxt);
    }
}
#endif

static int
_rl_subseq_getchar (key)
     int key;
{
  int k;

  if (key == ESC)
    RL_SETSTATE(RL_STATE_METANEXT);
  RL_SETSTATE(RL_STATE_MOREINPUT);
  k = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);
  if (key == ESC)
    RL_UNSETSTATE(RL_STATE_METANEXT);

  return k;
}

#if defined (READLINE_CALLBACKS)
int
_rl_dispatch_callback (cxt)
     _rl_keyseq_cxt *cxt;
{
  int nkey, r;

  /* For now */
#if 1
  /* The first time this context is used, we want to read input and dispatch
     on it.  When traversing the chain of contexts back `up', we want to use
     the value from the next context down.  We're simulating recursion using
     a chain of contexts. */
  if ((cxt->flags & KSEQ_DISPATCHED) == 0)
    {
      nkey = _rl_subseq_getchar (cxt->okey);
      r = _rl_dispatch_subseq (nkey, cxt->dmap, cxt->subseq_arg);
      cxt->flags |= KSEQ_DISPATCHED;
    }
  else
    r = cxt->childval;
#else
  r = _rl_dispatch_subseq (nkey, cxt->dmap, cxt->subseq_arg);
#endif

  /* For now */
  r = _rl_subseq_result (r, cxt->oldmap, cxt->okey, (cxt->flags & KSEQ_SUBSEQ));

  if (r == 0)			/* success! */
    {
      _rl_keyseq_chain_dispose ();
      RL_UNSETSTATE (RL_STATE_MULTIKEY);
      return r;
    }

  if (r != -3)			/* magic value that says we added to the chain */
    _rl_kscxt = cxt->ocxt;
  if (_rl_kscxt)
    _rl_kscxt->childval = r;
  if (r != -3)
    _rl_keyseq_cxt_dispose (cxt);

  return r;
}
#endif /* READLINE_CALLBACKS */
  
a528 1
  _rl_dispatching_keymap = map;
a540 3
#if defined (READLINE_CALLBACKS)
  _rl_keyseq_cxt *cxt;
#endif
d574 4
a608 4
#if defined (READLINE_CALLBACKS)
	  RL_UNSETSTATE (RL_STATE_MULTIKEY);
	  _rl_keyseq_chain_dispose ();
#endif
a629 1
	  _rl_dispatching_keymap = FUNCTION_TO_KEYMAP (map, key);
d631 9
a639 4
	  /* Allocate new context here.  Use linked contexts (linked through
	     cxt->ocxt) to simulate recursion */
#if defined (READLINE_CALLBACKS)
	  if (RL_ISSTATE (RL_STATE_CALLBACK))
d641 3
a643 13
	      /* Return 0 only the first time, to indicate success to
		 _rl_callback_read_char.  The rest of the time, we're called
		 from _rl_dispatch_callback, so we return 3 to indicate
		 special handling is necessary. */
	      r = RL_ISSTATE (RL_STATE_MULTIKEY) ? -3 : 0;
	      cxt = _rl_keyseq_cxt_alloc ();

	      if (got_subseq)
		cxt->flags |= KSEQ_SUBSEQ;
	      cxt->okey = key;
	      cxt->oldmap = map;
	      cxt->dmap = _rl_dispatching_keymap;
	      cxt->subseq_arg = got_subseq || cxt->dmap[ANYOTHERKEY].function;
d645 1
a645 2
	      RL_SETSTATE (RL_STATE_MULTIKEY);
	      _rl_kscxt = cxt;
d647 14
a660 1
	      return r;		/* don't indicate immediate success */
d662 1
a662 4
#endif

	  newkey = _rl_subseq_getchar (key);
	  if (newkey < 0)
d664 2
a665 1
	      _rl_abort_internal ();
a667 3

	  r = _rl_dispatch_subseq (newkey, _rl_dispatching_keymap, got_subseq || map[ANYOTHERKEY].function);
	  return _rl_subseq_result (r, map, key, got_subseq);
a686 1
      key != ANYOTHERKEY &&
a689 1

a692 59
static int
_rl_subseq_result (r, map, key, got_subseq)
     int r;
     Keymap map;
     int key, got_subseq;
{
  Keymap m;
  int type, nt;
  rl_command_func_t *func, *nf;
  
  if (r == -2)
    /* We didn't match anything, and the keymap we're indexed into
       shadowed a function previously bound to that prefix.  Call
       the function.  The recursive call to _rl_dispatch_subseq has
       already taken care of pushing any necessary input back onto
       the input queue with _rl_unget_char. */
    {
      m = _rl_dispatching_keymap;
      type = m[ANYOTHERKEY].type;
      func = m[ANYOTHERKEY].function;
      if (type == ISFUNC && func == rl_do_lowercase_version)
	r = _rl_dispatch (_rl_to_lower (key), map);
      else if (type == ISFUNC && func == rl_insert)
	{
	  /* If the function that was shadowed was self-insert, we
	     somehow need a keymap with map[key].func == self-insert.
	     Let's use this one. */
	  nt = m[key].type;
	  nf = m[key].function;

	  m[key].type = type;
	  m[key].function = func;
	  r = _rl_dispatch (key, m);
	  m[key].type = nt;
	  m[key].function = nf;
	}
      else
	r = _rl_dispatch (ANYOTHERKEY, m);
    }
  else if (r && map[ANYOTHERKEY].function)
    {
      /* We didn't match (r is probably -1), so return something to
	 tell the caller that it should try ANYOTHERKEY for an
	 overridden function. */
      _rl_unget_char (key);
      _rl_dispatching_keymap = map;
      return -2;
    }
  else if (r && got_subseq)
    {
      /* OK, back up the chain. */
      _rl_unget_char (key);
      _rl_dispatching_keymap = map;
      return -1;
    }

  return r;
}

d841 1
a841 1
    rl_completer_word_break_characters = (char *)rl_basic_word_break_characters;
d850 1
a850 14
  if (_rl_bind_stty_chars)
    rl_tty_set_default_bindings (_rl_keymap);
}

/* Reset the default bindings for the terminal special characters we're
   interested in back to rl_insert and read the new ones. */
static void
reset_default_bindings ()
{
  if (_rl_bind_stty_chars)
    {
      rl_tty_unset_default_bindings (_rl_keymap);
      rl_tty_set_default_bindings (_rl_keymap);
    }
d864 19
a882 26
  rl_bind_keyseq_if_unbound ("\033[0A", rl_get_previous_history);
  rl_bind_keyseq_if_unbound ("\033[0B", rl_backward_char);
  rl_bind_keyseq_if_unbound ("\033[0C", rl_forward_char);
  rl_bind_keyseq_if_unbound ("\033[0D", rl_get_next_history);
#endif

  rl_bind_keyseq_if_unbound ("\033[A", rl_get_previous_history);
  rl_bind_keyseq_if_unbound ("\033[B", rl_get_next_history);
  rl_bind_keyseq_if_unbound ("\033[C", rl_forward_char);
  rl_bind_keyseq_if_unbound ("\033[D", rl_backward_char);
  rl_bind_keyseq_if_unbound ("\033[H", rl_beg_of_line);
  rl_bind_keyseq_if_unbound ("\033[F", rl_end_of_line);

  rl_bind_keyseq_if_unbound ("\033OA", rl_get_previous_history);
  rl_bind_keyseq_if_unbound ("\033OB", rl_get_next_history);
  rl_bind_keyseq_if_unbound ("\033OC", rl_forward_char);
  rl_bind_keyseq_if_unbound ("\033OD", rl_backward_char);
  rl_bind_keyseq_if_unbound ("\033OH", rl_beg_of_line);
  rl_bind_keyseq_if_unbound ("\033OF", rl_end_of_line);

#if defined (__MINGW32__)
  rl_bind_keyseq_if_unbound ("\340H", rl_get_previous_history);
  rl_bind_keyseq_if_unbound ("\340P", rl_get_next_history);
  rl_bind_keyseq_if_unbound ("\340M", rl_forward_char);
  rl_bind_keyseq_if_unbound ("\340K", rl_backward_char);
#endif
@


