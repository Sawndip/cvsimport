head	1.13;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.13
	gdb_7_6-2013-04-26-release:1.13
	gdb_7_6-branch:1.13.0.6
	gdb_7_6-2013-03-12-branchpoint:1.13
	gdb_7_5_1-2012-11-29-release:1.13
	gdb_7_5-2012-08-17-release:1.13
	gdb_7_5-branch:1.13.0.4
	gdb_7_5-2012-07-18-branchpoint:1.13
	gdb_7_4_1-2012-04-26-release:1.13
	gdb_7_4-2012-01-24-release:1.13
	gdb_7_4-branch:1.13.0.2
	gdb_7_4-2011-12-13-branchpoint:1.13
	gdb_7_3_1-2011-09-04-release:1.12
	gdb_7_3-2011-07-26-release:1.12
	gdb_7_3-branch:1.12.0.20
	gdb_7_3-2011-04-01-branchpoint:1.12
	gdb_7_2-2010-09-02-release:1.12
	gdb_7_2-branch:1.12.0.18
	gdb_7_2-2010-07-07-branchpoint:1.12
	gdb_7_1-2010-03-18-release:1.12
	gdb_7_1-branch:1.12.0.16
	gdb_7_1-2010-02-18-branchpoint:1.12
	gdb_7_0_1-2009-12-22-release:1.12
	gdb_7_0-2009-10-06-release:1.12
	gdb_7_0-branch:1.12.0.14
	gdb_7_0-2009-09-16-branchpoint:1.12
	arc-sim-20090309:1.11
	msnyder-checkpoint-072509-branch:1.12.0.12
	msnyder-checkpoint-072509-branchpoint:1.12
	arc-insight_6_8-branch:1.11.0.16
	arc-insight_6_8-branchpoint:1.11
	insight_6_8-branch:1.11.0.14
	insight_6_8-branchpoint:1.11
	reverse-20081226-branch:1.12.0.10
	reverse-20081226-branchpoint:1.12
	multiprocess-20081120-branch:1.12.0.8
	multiprocess-20081120-branchpoint:1.12
	reverse-20080930-branch:1.12.0.6
	reverse-20080930-branchpoint:1.12
	reverse-20080717-branch:1.12.0.4
	reverse-20080717-branchpoint:1.12
	msnyder-reverse-20080609-branch:1.12.0.2
	msnyder-reverse-20080609-branchpoint:1.12
	drow-reverse-20070409-branch:1.11.0.12
	drow-reverse-20070409-branchpoint:1.11
	gdb_6_8-2008-03-27-release:1.11
	gdb_6_8-branch:1.11.0.10
	gdb_6_8-2008-02-26-branchpoint:1.11
	gdb_6_7_1-2007-10-29-release:1.11
	gdb_6_7-2007-10-10-release:1.11
	gdb_6_7-branch:1.11.0.8
	gdb_6_7-2007-09-07-branchpoint:1.11
	insight_6_6-20070208-release:1.11
	gdb_6_6-2006-12-18-release:1.11
	gdb_6_6-branch:1.11.0.6
	gdb_6_6-2006-11-15-branchpoint:1.11
	insight_6_5-20061003-release:1.11
	gdb-csl-symbian-6_4_50_20060226-12:1.9
	gdb-csl-sourcerygxx-3_4_4-25:1.9
	nickrob-async-20060828-mergepoint:1.11
	gdb-csl-symbian-6_4_50_20060226-11:1.9
	gdb-csl-sourcerygxx-4_1-17:1.9
	gdb-csl-20060226-branch-local-2:1.9
	gdb-csl-sourcerygxx-4_1-14:1.9
	gdb-csl-sourcerygxx-4_1-13:1.9
	gdb-csl-sourcerygxx-4_1-12:1.9
	gdb-csl-sourcerygxx-3_4_4-21:1.9
	gdb_6_5-20060621-release:1.11
	gdb-csl-sourcerygxx-4_1-9:1.9
	gdb-csl-sourcerygxx-4_1-8:1.9
	gdb-csl-sourcerygxx-4_1-7:1.9
	gdb-csl-arm-2006q1-6:1.9
	gdb-csl-sourcerygxx-4_1-6:1.9
	gdb-csl-symbian-6_4_50_20060226-10:1.9
	gdb-csl-symbian-6_4_50_20060226-9:1.9
	gdb-csl-symbian-6_4_50_20060226-8:1.9
	gdb-csl-coldfire-4_1-11:1.9
	gdb-csl-sourcerygxx-3_4_4-19:1.9
	gdb-csl-coldfire-4_1-10:1.9
	gdb_6_5-branch:1.11.0.4
	gdb_6_5-2006-05-14-branchpoint:1.11
	gdb-csl-sourcerygxx-4_1-5:1.9
	nickrob-async-20060513-branch:1.11.0.2
	nickrob-async-20060513-branchpoint:1.11
	gdb-csl-sourcerygxx-4_1-4:1.9
	msnyder-reverse-20060502-branch:1.10.0.4
	msnyder-reverse-20060502-branchpoint:1.10
	gdb-csl-morpho-4_1-4:1.9
	gdb-csl-sourcerygxx-3_4_4-17:1.9
	readline_5_1-import-branch:1.10.0.2
	readline_5_1-import-branchpoint:1.10
	readline-pre-51-import:1.10
	readline_5_1:1.1.1.7
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.9
	gdb-csl-symbian-20060226-branch:1.9.0.18
	gdb-csl-symbian-20060226-branchpoint:1.9
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.9
	msnyder-reverse-20060331-branch:1.9.0.16
	msnyder-reverse-20060331-branchpoint:1.9
	gdb-csl-available-20060303-branch:1.9.0.14
	gdb-csl-available-20060303-branchpoint:1.9
	gdb-csl-20060226-branch:1.9.0.12
	gdb-csl-20060226-branchpoint:1.9
	gdb_6_4-20051202-release:1.9
	msnyder-fork-checkpoint-branch:1.9.0.10
	msnyder-fork-checkpoint-branchpoint:1.9
	gdb-csl-gxxpro-6_3-branch:1.9.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.9
	gdb_6_4-branch:1.9.0.6
	gdb_6_4-2005-11-01-branchpoint:1.9
	gdb-csl-arm-20051020-branch:1.9.0.4
	gdb-csl-arm-20051020-branchpoint:1.9
	msnyder-tracepoint-checkpoint-branch:1.9.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.9
	gdb-csl-arm-20050325-2005-q1b:1.8.20.1
	gdb-csl-arm-20050325-2005-q1a:1.8.20.1
	csl-arm-20050325-branch:1.8.0.20
	csl-arm-20050325-branchpoint:1.8
	gdb_6_3-20041109-release:1.8
	gdb_6_3-branch:1.8.0.16
	gdb_6_3-20041019-branchpoint:1.8
	drow_intercu-merge-20040921:1.8
	drow_intercu-merge-20040915:1.8
	jimb-gdb_6_2-e500-branch:1.8.0.18
	jimb-gdb_6_2-e500-branchpoint:1.8
	gdb_6_2-20040730-release:1.8
	gdb_6_2-branch:1.8.0.14
	gdb_6_2-2004-07-10-gmt-branchpoint:1.8
	gdb_6_1_1-20040616-release:1.8
	gdb_6_1-2004-04-05-release:1.8
	drow_intercu-merge-20040402:1.8
	drow_intercu-merge-20040327:1.8
	ezannoni_pie-20040323-branch:1.8.0.12
	ezannoni_pie-20040323-branchpoint:1.8
	cagney_tramp-20040321-mergepoint:1.8
	cagney_tramp-20040309-branch:1.8.0.10
	cagney_tramp-20040309-branchpoint:1.8
	gdb_6_1-branch:1.8.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.8
	drow_intercu-20040221-branch:1.8.0.6
	drow_intercu-20040221-branchpoint:1.8
	cagney_bfdfile-20040213-branch:1.8.0.4
	cagney_bfdfile-20040213-branchpoint:1.8
	drow-cplus-merge-20040208:1.8
	carlton_dictionary-20040126-merge:1.8
	cagney_bigcore-20040122-branch:1.8.0.2
	cagney_bigcore-20040122-branchpoint:1.8
	drow-cplus-merge-20040113:1.8
	drow-cplus-merge-20031224:1.7
	drow-cplus-merge-20031220:1.7
	carlton_dictionary-20031215-merge:1.7
	drow-cplus-merge-20031214:1.7
	carlton-dictionary-20031111-merge:1.7
	gdb_6_0-2003-10-04-release:1.7
	kettenis_sparc-20030918-branch:1.7.0.38
	kettenis_sparc-20030918-branchpoint:1.7
	carlton_dictionary-20030917-merge:1.7
	ezannoni_pie-20030916-branchpoint:1.7
	ezannoni_pie-20030916-branch:1.7.0.36
	cagney_x86i386-20030821-branch:1.7.0.34
	cagney_x86i386-20030821-branchpoint:1.7
	carlton_dictionary-20030805-merge:1.7
	carlton_dictionary-20030627-merge:1.7
	gdb_6_0-branch:1.7.0.32
	gdb_6_0-2003-06-23-branchpoint:1.7
	jimb-ppc64-linux-20030613-branch:1.7.0.30
	jimb-ppc64-linux-20030613-branchpoint:1.7
	cagney_convert-20030606-branch:1.7.0.28
	cagney_convert-20030606-branchpoint:1.7
	cagney_writestrings-20030508-branch:1.7.0.26
	cagney_writestrings-20030508-branchpoint:1.7
	jimb-ppc64-linux-20030528-branch:1.7.0.24
	jimb-ppc64-linux-20030528-branchpoint:1.7
	carlton_dictionary-20030523-merge:1.7
	cagney_fileio-20030521-branch:1.7.0.22
	cagney_fileio-20030521-branchpoint:1.7
	kettenis_i386newframe-20030517-mergepoint:1.7
	jimb-ppc64-linux-20030509-branch:1.7.0.20
	jimb-ppc64-linux-20030509-branchpoint:1.7
	kettenis_i386newframe-20030504-mergepoint:1.7
	carlton_dictionary-20030430-merge:1.7
	kettenis_i386newframe-20030419-branch:1.7.0.18
	kettenis_i386newframe-20030419-branchpoint:1.7
	carlton_dictionary-20030416-merge:1.7
	cagney_frameaddr-20030409-mergepoint:1.7
	kettenis_i386newframe-20030406-branch:1.7.0.16
	kettenis_i386newframe-20030406-branchpoint:1.7
	cagney_frameaddr-20030403-branchpoint:1.7
	cagney_frameaddr-20030403-branch:1.7.0.14
	cagney_framebase-20030330-mergepoint:1.7
	cagney_framebase-20030326-branch:1.7.0.12
	cagney_framebase-20030326-branchpoint:1.7
	cagney_lazyid-20030317-branch:1.7.0.10
	cagney_lazyid-20030317-branchpoint:1.7
	kettenis-i386newframe-20030316-mergepoint:1.7
	offbyone-20030313-branch:1.7.0.8
	offbyone-20030313-branchpoint:1.7
	kettenis-i386newframe-20030308-branch:1.7.0.6
	kettenis-i386newframe-20030308-branchpoint:1.7
	carlton_dictionary-20030305-merge:1.7
	cagney_offbyone-20030303-branch:1.7.0.4
	cagney_offbyone-20030303-branchpoint:1.7
	carlton_dictionary-20030207-merge:1.7
	interps-20030202-branch:1.7.0.2
	interps-20030202-branchpoint:1.7
	cagney-unwind-20030108-branch:1.6.0.2
	cagney-unwind-20030108-branchpoint:1.6
	carlton_dictionary-20021223-merge:1.6
	gdb_5_3-2002-12-12-release:1.5
	readline-pre-43-import:1.5
	carlton_dictionary-20021115-merge:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.24
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.22
	carlton_dictionary-20020920-branchpoint:1.5
	gdb_5_3-branch:1.5.0.20
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.5
	cagney_sysregs-20020825-branch:1.5.0.18
	cagney_sysregs-20020825-branchpoint:1.5
	readline_4_3-import-branch:1.5.0.16
	readline_4_3-import-branchpoint:1.5
	readline_4_3:1.1.1.6
	gdb_5_2_1-2002-07-23-release:1.5
	kseitz_interps-20020528-branch:1.5.0.14
	kseitz_interps-20020528-branchpoint:1.5
	cagney_regbuf-20020515-branch:1.5.0.12
	cagney_regbuf-20020515-branchpoint:1.5
	jimb-macro-020506-branch:1.5.0.10
	jimb-macro-020506-branchpoint:1.5
	gdb_5_2-2002-04-29-release:1.5
	gdb_5_2-branch:1.5.0.8
	gdb_5_2-2002-03-03-branchpoint:1.5
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	cygnus_cvs_20020108_pre:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.4
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.2
	gdb_5_1-2001-07-29-branchpoint:1.5
	insight-precleanup-2001-01-01:1.5
	readline_4_1:1.1.1.5
	readline_4_0:1.1.1.4
	FSF:1.1.1
	readline-pre-41-import:1.3
	gdb-premipsmulti-2000-06-06-branch:1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.13
date	2011.05.11.23.38.39;	author jkratoch;	state Exp;
branches;
next	1.12;

1.12
date	2008.03.24.12.59.51;	author jkratoch;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.05.18.26.12;	author drow;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.20.20.13.20;	author ezannoni;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2005.05.09.19.42.03;	author mmitchel;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.30.07.25.18;	author eliz;	state Exp;
branches
	1.8.20.1;
next	1.7;

1.7
date	2003.01.11.00.43.53;	author chastain;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.08.22.31.37;	author ezannoni;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.10.15.22.16;	author eliz;	state Exp;
branches
	1.5.16.1
	1.5.22.1
	1.5.24.1;
next	1.4;

1.4
date	2000.07.09.17.19.56;	author ezannoni;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.07.17.15.45;	author ezannoni;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.15.11.41.26;	author eliz;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.53;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.10.2.1
date	2006.04.24.22.00.25;	author drow;	state Exp;
branches;
next	;

1.8.20.1
date	2005.03.28.19.34.27;	author mmitchel;	state Exp;
branches;
next	1.8.20.2;

1.8.20.2
date	2005.06.08.16.48.52;	author mmitchel;	state Exp;
branches;
next	;

1.5.16.1
date	2002.08.25.23.41.16;	author ezannoni;	state Exp;
branches;
next	;

1.5.22.1
date	2002.12.23.19.39.42;	author carlton;	state Exp;
branches;
next	1.5.22.2;

1.5.22.2
date	2003.02.07.19.18.04;	author carlton;	state Exp;
branches;
next	1.5.22.3;

1.5.22.3
date	2004.01.26.19.11.51;	author carlton;	state Exp;
branches;
next	;

1.5.24.1
date	2003.12.14.20.28.13;	author drow;	state Exp;
branches;
next	1.5.24.2;

1.5.24.2
date	2004.01.13.16.12.22;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.53;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.30.27;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.08.02.23.47.57;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.07.07.19.14.17;	author ezannoni;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.07.09.16.21.20;	author ezannoni;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.08.23.22.02.27;	author ezannoni;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.04.20.20.05.36;	author ezannoni;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Imported readline 6.2, and upstream patch 001.

[patch 0/3] readline-6.2 rebase
http://sourceware.org/ml/gdb-patches/2011-05/msg00003.html
[patch 1/3] readline-6.2: Merge of already posted patches
http://sourceware.org/ml/gdb-patches/2011-05/msg00004.html
	=
	[Bug-readline] [RFC/readline] bind.c, rl_function_dumper, Free allocated
	http://lists.gnu.org/archive/html/bug-readline/2011-03/msg00000.html
	[Bug-readline] [patch] Fix underquotation in readline/examples/rlfe/conf
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00001.html
	[Bug-readline] [patch] Makefile.in htm<->html
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00002.html
	Re: [Bug-readline] [patch] Makefile.in dependency: callback.o: xmalloc.h
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00004.html
	[Bug-readline] [patch] Remove . from the VPATH directive
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00005.html
	Eli Zaretskii's __MSDOS__ / __GO32__ / __MINGW32__ / __DJGPP__ stuff:
	http://sourceware.org/ml/gdb/2011-04/msg00002.html
	Jan Kratochvil's patch for FSF GDB tree local-specific changes:
	http://sourceware.org/ml/gdb/2011-04/msg00006.html
	Preservation of existing ChangeLog.gdb files, their updates.
[patch 2/3] readline-6.2: Workaround "ask" regression
http://sourceware.org/ml/gdb-patches/2011-05/msg00005.html
[patch 3/3] readline-6.2: Revert 5.x compat., apply 6.x compat.
http://sourceware.org/ml/gdb-patches/2011-05/msg00006.html
[patch 4/3] readline-6.2: Substitute inc-hist.texinfo
http://sourceware.org/ml/gdb-patches/2011-05/msg00010.html

readline/
	Workaround gdb.base/completion.exp regression on readline-6.2.
	* complete.c (get_y_or_n): Disable the return on RL_STATE_CALLBACK.

	Imported readline 6.2, and upstream patch 001.
	* configure: Regenerate.

readline/doc/
	* hsuser.texi (Using History Interactively): Disable !BashFeatures
	@@defcodeindex.  Make the `Programming with GNU History' reference
	external.
	* inc-hist.texinfo: Remove.

	Imported readline 6.2, and upstream patch 001.

readline/examples/
	Imported readline 6.2, and upstream patch 001.

readline/examples/rlfe/
	Imported readline 6.2, and upstream patch 001.

gdb/
	* config.in: Regenerate.
	* configure: Regenerate.
	* configure.ac <--with-system-readline> (for readline_echoing_p):
	Remove the test.
	* tui/tui-io.c (tui_old_readline_echoing_p): Rename to ...
	(tui_old_rl_echoing_p): ... here.
	(tui_setup_io): Rename extern declaration readline_echoing_p to
	_rl_echoing_p.  Adjust assignments for the both renames.

gdb/doc/
	* Makefile.in (GDB_DOC_SOURCE_INCLUDES): Rename inc-hist.texinfo to
	hsuser.texi.
	* gdb.texinfo <!SYSTEM_READLINE>: Rename inc-hist.texinfo inclusion and
	comment to hsuser.texi.  Change rluser.texi name in the comment.
@
text
@/* display.c -- readline redisplay facility. */

/* Copyright (C) 1987-2009 Free Software Foundation, Inc.

   This file is part of the GNU Readline Library (Readline), a library    
   for reading lines of text with interactive input and history editing.

   Readline is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Readline is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Readline.  If not, see <http://www.gnu.org/licenses/>.
*/

#define READLINE_LIBRARY

#if defined (HAVE_CONFIG_H)
#  include <config.h>
#endif

#include <sys/types.h>

#if defined (HAVE_UNISTD_H)
#  include <unistd.h>
#endif /* HAVE_UNISTD_H */

#include "posixstat.h"

#if defined (HAVE_STDLIB_H)
#  include <stdlib.h>
#else
#  include "ansi_stdlib.h"
#endif /* HAVE_STDLIB_H */

#include <stdio.h>

#ifdef __MSDOS__
# include <pc.h>
#endif

/* System-specific feature definitions and include files. */
#include "rldefs.h"
#include "rlmbutil.h"

/* Termcap library stuff. */
#include "tcap.h"

/* Some standard library routines. */
#include "readline.h"
#include "history.h"

#include "rlprivate.h"
#include "xmalloc.h"

#if !defined (strchr) && !defined (__STDC__)
extern char *strchr (), *strrchr ();
#endif /* !strchr && !__STDC__ */

static void update_line PARAMS((char *, char *, int, int, int, int));
static void space_to_eol PARAMS((int));
static void delete_chars PARAMS((int));
static void insert_some_chars PARAMS((char *, int, int));
static void cr PARAMS((void));

/* State of visible and invisible lines. */
struct line_state
  {
    char *line;
    int *lbreaks;
    int lbsize;
#if defined (HANDLE_MULTIBYTE)
    int *wrapped_line;
    int wbsize;
#endif
  };

/* The line display buffers.  One is the line currently displayed on
   the screen.  The other is the line about to be displayed. */
static struct line_state line_state_array[2];
static struct line_state *line_state_visible = &line_state_array[0];
static struct line_state *line_state_invisible = &line_state_array[1];
static int line_structures_initialized = 0;

/* Backwards-compatible names. */
#define inv_lbreaks	(line_state_invisible->lbreaks)
#define inv_lbsize	(line_state_invisible->lbsize)
#define vis_lbreaks	(line_state_visible->lbreaks)
#define vis_lbsize	(line_state_visible->lbsize)

#define visible_line	(line_state_visible->line)
#define invisible_line	(line_state_invisible->line)

#if defined (HANDLE_MULTIBYTE)
static int _rl_col_width PARAMS((const char *, int, int, int));
#else
#  define _rl_col_width(l, s, e, f)	(((e) <= (s)) ? 0 : (e) - (s))
#endif

/* Heuristic used to decide whether it is faster to move from CUR to NEW
   by backing up or outputting a carriage return and moving forward.  CUR
   and NEW are either both buffer positions or absolute screen positions. */
#define CR_FASTER(new, cur) (((new) + 1) < ((cur) - (new)))

/* _rl_last_c_pos is an absolute cursor position in multibyte locales and a
   buffer index in others.  This macro is used when deciding whether the
   current cursor position is in the middle of a prompt string containing
   invisible characters.  XXX - might need to take `modmark' into account. */
#define PROMPT_ENDING_INDEX \
  ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) ? prompt_physical_chars : prompt_last_invisible+1)
  

/* **************************************************************** */
/*								    */
/*			Display stuff				    */
/*								    */
/* **************************************************************** */

/* This is the stuff that is hard for me.  I never seem to write good
   display routines in C.  Let's see how I do this time. */

/* (PWP) Well... Good for a simple line updater, but totally ignores
   the problems of input lines longer than the screen width.

   update_line and the code that calls it makes a multiple line,
   automatically wrapping line update.  Careful attention needs
   to be paid to the vertical position variables. */

/* Keep two buffers; one which reflects the current contents of the
   screen, and the other to draw what we think the new contents should
   be.  Then compare the buffers, and make whatever changes to the
   screen itself that we should.  Finally, make the buffer that we
   just drew into be the one which reflects the current contents of the
   screen, and place the cursor where it belongs.

   Commands that want to can fix the display themselves, and then let
   this function know that the display has been fixed by setting the
   RL_DISPLAY_FIXED variable.  This is good for efficiency. */

/* Application-specific redisplay function. */
rl_voidfunc_t *rl_redisplay_function = rl_redisplay;

/* Global variables declared here. */
/* What YOU turn on when you have handled all redisplay yourself. */
int rl_display_fixed = 0;

int _rl_suppress_redisplay = 0;
int _rl_want_redisplay = 0;

/* The stuff that gets printed out before the actual text of the line.
   This is usually pointing to rl_prompt. */
char *rl_display_prompt = (char *)NULL;

/* Pseudo-global variables declared here. */

/* The visible cursor position.  If you print some text, adjust this. */
/* NOTE: _rl_last_c_pos is used as a buffer index when not in a locale
   supporting multibyte characters, and an absolute cursor position when
   in such a locale.  This is an artifact of the donated multibyte support.
   Care must be taken when modifying its value. */
int _rl_last_c_pos = 0;
int _rl_last_v_pos = 0;

static int cpos_adjusted;
static int cpos_buffer_position;
static int prompt_multibyte_chars;

/* Number of lines currently on screen minus 1. */
int _rl_vis_botlin = 0;

/* Variables used only in this file. */
/* The last left edge of text that was displayed.  This is used when
   doing horizontal scrolling.  It shifts in thirds of a screenwidth. */
static int last_lmargin;

/* A buffer for `modeline' messages. */
static char msg_buf[128];

/* Non-zero forces the redisplay even if we thought it was unnecessary. */
static int forced_display;

/* Default and initial buffer size.  Can grow. */
static int line_size = 1024;

/* Variables to keep track of the expanded prompt string, which may
   include invisible characters. */

static char *local_prompt, *local_prompt_prefix;
static int local_prompt_len;
static int prompt_visible_length, prompt_prefix_length;

/* The number of invisible characters in the line currently being
   displayed on the screen. */
static int visible_wrap_offset;

/* The number of invisible characters in the prompt string.  Static so it
   can be shared between rl_redisplay and update_line */
static int wrap_offset;

/* The index of the last invisible character in the prompt string. */
static int prompt_last_invisible;

/* The length (buffer offset) of the first line of the last (possibly
   multi-line) buffer displayed on the screen. */
static int visible_first_line_len;

/* Number of invisible characters on the first physical line of the prompt.
   Only valid when the number of physical characters in the prompt exceeds
   (or is equal to) _rl_screenwidth. */
static int prompt_invis_chars_first_line;

static int prompt_last_screen_line;

static int prompt_physical_chars;

/* set to a non-zero value by rl_redisplay if we are marking modified history
   lines and the current line is so marked. */
static int modmark;

/* Variables to save and restore prompt and display information. */

/* These are getting numerous enough that it's time to create a struct. */

static char *saved_local_prompt;
static char *saved_local_prefix;
static int saved_last_invisible;
static int saved_visible_length;
static int saved_prefix_length;
static int saved_local_length;
static int saved_invis_chars_first_line;
static int saved_physical_chars;

/* Expand the prompt string S and return the number of visible
   characters in *LP, if LP is not null.  This is currently more-or-less
   a placeholder for expansion.  LIP, if non-null is a place to store the
   index of the last invisible character in the returned string. NIFLP,
   if non-zero, is a place to store the number of invisible characters in
   the first prompt line.  The previous are used as byte counts -- indexes
   into a character buffer. */

/* Current implementation:
	\001 (^A) start non-visible characters
	\002 (^B) end non-visible characters
   all characters except \001 and \002 (following a \001) are copied to
   the returned string; all characters except those between \001 and
   \002 are assumed to be `visible'. */	

static char *
expand_prompt (pmt, lp, lip, niflp, vlp)
     char *pmt;
     int *lp, *lip, *niflp, *vlp;
{
  char *r, *ret, *p, *igstart;
  int l, rl, last, ignoring, ninvis, invfl, invflset, ind, pind, physchars;

  /* Short-circuit if we can. */
  if ((MB_CUR_MAX <= 1 || rl_byte_oriented) && strchr (pmt, RL_PROMPT_START_IGNORE) == 0)
    {
      r = savestring (pmt);
      if (lp)
	*lp = strlen (r);
      if (lip)
	*lip = 0;
      if (niflp)
	*niflp = 0;
      if (vlp)
	*vlp = lp ? *lp : strlen (r);
      return r;
    }

  l = strlen (pmt);
  r = ret = (char *)xmalloc (l + 1);

  invfl = 0;	/* invisible chars in first line of prompt */
  invflset = 0;	/* we only want to set invfl once */

  igstart = 0;
  for (rl = ignoring = last = ninvis = physchars = 0, p = pmt; p && *p; p++)
    {
      /* This code strips the invisible character string markers
	 RL_PROMPT_START_IGNORE and RL_PROMPT_END_IGNORE */
      if (ignoring == 0 && *p == RL_PROMPT_START_IGNORE)		/* XXX - check ignoring? */
	{
	  ignoring = 1;
	  igstart = p;
	  continue;
	}
      else if (ignoring && *p == RL_PROMPT_END_IGNORE)
	{
	  ignoring = 0;
	  if (p != (igstart + 1))
	    last = r - ret - 1;
	  continue;
	}
      else
	{
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      pind = p - pmt;
	      ind = _rl_find_next_mbchar (pmt, pind, 1, MB_FIND_NONZERO);
	      l = ind - pind;
	      while (l--)
	        *r++ = *p++;
	      if (!ignoring)
		{
		  /* rl ends up being assigned to prompt_visible_length,
		     which is the number of characters in the buffer that
		     contribute to characters on the screen, which might
		     not be the same as the number of physical characters
		     on the screen in the presence of multibyte characters */
		  rl += ind - pind;
		  physchars += _rl_col_width (pmt, pind, ind, 0);
		}
	      else
		ninvis += ind - pind;
	      p--;			/* compensate for later increment */
	    }
	  else
#endif
	    {
	      *r++ = *p;
	      if (!ignoring)
		{
		  rl++;			/* visible length byte counter */
		  physchars++;
		}
	      else
		ninvis++;		/* invisible chars byte counter */
	    }

	  if (invflset == 0 && rl >= _rl_screenwidth)
	    {
	      invfl = ninvis;
	      invflset = 1;
	    }
	}
    }

  if (rl < _rl_screenwidth)
    invfl = ninvis;

  *r = '\0';
  if (lp)
    *lp = rl;
  if (lip)
    *lip = last;
  if (niflp)
    *niflp = invfl;
  if  (vlp)
    *vlp = physchars;
  return ret;
}

/* Just strip out RL_PROMPT_START_IGNORE and RL_PROMPT_END_IGNORE from
   PMT and return the rest of PMT. */
char *
_rl_strip_prompt (pmt)
     char *pmt;
{
  char *ret;

  ret = expand_prompt (pmt, (int *)NULL, (int *)NULL, (int *)NULL, (int *)NULL);
  return ret;
}

/*
 * Expand the prompt string into the various display components, if
 * necessary.
 *
 * local_prompt = expanded last line of string in rl_display_prompt
 *		  (portion after the final newline)
 * local_prompt_prefix = portion before last newline of rl_display_prompt,
 *			 expanded via expand_prompt
 * prompt_visible_length = number of visible characters in local_prompt
 * prompt_prefix_length = number of visible characters in local_prompt_prefix
 *
 * This function is called once per call to readline().  It may also be
 * called arbitrarily to expand the primary prompt.
 *
 * The return value is the number of visible characters on the last line
 * of the (possibly multi-line) prompt.
 */
int
rl_expand_prompt (prompt)
     char *prompt;
{
  char *p, *t;
  int c;

  /* Clear out any saved values. */
  FREE (local_prompt);
  FREE (local_prompt_prefix);

  local_prompt = local_prompt_prefix = (char *)0;
  local_prompt_len = 0;
  prompt_last_invisible = prompt_invis_chars_first_line = 0;
  prompt_visible_length = prompt_physical_chars = 0;

  if (prompt == 0 || *prompt == 0)
    return (0);

  p = strrchr (prompt, '\n');
  if (!p)
    {
      /* The prompt is only one logical line, though it might wrap. */
      local_prompt = expand_prompt (prompt, &prompt_visible_length,
					    &prompt_last_invisible,
					    &prompt_invis_chars_first_line,
					    &prompt_physical_chars);
      local_prompt_prefix = (char *)0;
      local_prompt_len = local_prompt ? strlen (local_prompt) : 0;
      return (prompt_visible_length);
    }
  else
    {
      /* The prompt spans multiple lines. */
      t = ++p;
      local_prompt = expand_prompt (p, &prompt_visible_length,
				       &prompt_last_invisible,
				       &prompt_invis_chars_first_line,
				       &prompt_physical_chars);
      c = *t; *t = '\0';
      /* The portion of the prompt string up to and including the
	 final newline is now null-terminated. */
      local_prompt_prefix = expand_prompt (prompt, &prompt_prefix_length,
						   (int *)NULL,
						   (int *)NULL,
						   (int *)NULL);
      *t = c;
      local_prompt_len = local_prompt ? strlen (local_prompt) : 0;
      return (prompt_prefix_length);
    }
}

/* Initialize the VISIBLE_LINE and INVISIBLE_LINE arrays, and their associated
   arrays of line break markers.  MINSIZE is the minimum size of VISIBLE_LINE
   and INVISIBLE_LINE; if it is greater than LINE_SIZE, LINE_SIZE is
   increased.  If the lines have already been allocated, this ensures that
   they can hold at least MINSIZE characters. */
static void
init_line_structures (minsize)
      int minsize;
{
  register int n;

  if (invisible_line == 0)	/* initialize it */
    {
      if (line_size < minsize)
	line_size = minsize;
      visible_line = (char *)xmalloc (line_size);
      invisible_line = (char *)xmalloc (line_size);
    }
  else if (line_size < minsize)	/* ensure it can hold MINSIZE chars */
    {
      line_size *= 2;
      if (line_size < minsize)
	line_size = minsize;
      visible_line = (char *)xrealloc (visible_line, line_size);
      invisible_line = (char *)xrealloc (invisible_line, line_size);
    }

  for (n = minsize; n < line_size; n++)
    {
      visible_line[n] = 0;
      invisible_line[n] = 1;
    }

  if (vis_lbreaks == 0)
    {
      /* should be enough. */
      inv_lbsize = vis_lbsize = 256;

#if defined (HANDLE_MULTIBYTE)
      line_state_visible->wbsize = vis_lbsize;
      line_state_visible->wrapped_line = (int *)xmalloc (line_state_visible->wbsize * sizeof (int));

      line_state_invisible->wbsize = inv_lbsize;
      line_state_invisible->wrapped_line = (int *)xmalloc (line_state_invisible->wbsize * sizeof (int));
#endif

      inv_lbreaks = (int *)xmalloc (inv_lbsize * sizeof (int));
      vis_lbreaks = (int *)xmalloc (vis_lbsize * sizeof (int));
      inv_lbreaks[0] = vis_lbreaks[0] = 0;
    }

  line_structures_initialized = 1;
}
  
/* Basic redisplay algorithm. */
void
rl_redisplay ()
{
  register int in, out, c, linenum, cursor_linenum;
  register char *line;
  int inv_botlin, lb_botlin, lb_linenum, o_cpos;
  int newlines, lpos, temp, n0, num, prompt_lines_estimate;
  char *prompt_this_line;
#if defined (HANDLE_MULTIBYTE)
  wchar_t wc;
  size_t wc_bytes;
  int wc_width;
  mbstate_t ps;
  int _rl_wrapped_multicolumn = 0;
#endif

  if (_rl_echoing_p == 0)
    return;

  /* Block keyboard interrupts because this function manipulates global
     data structures. */
  _rl_block_sigint ();  
  RL_SETSTATE (RL_STATE_REDISPLAYING);

  if (!rl_display_prompt)
    rl_display_prompt = "";

  if (line_structures_initialized == 0)
    {
      init_line_structures (0);
      rl_on_new_line ();
    }

  /* Draw the line into the buffer. */
  cpos_buffer_position = -1;

  prompt_multibyte_chars = prompt_visible_length - prompt_physical_chars;

  line = invisible_line;
  out = inv_botlin = 0;

  /* Mark the line as modified or not.  We only do this for history
     lines. */
  modmark = 0;
  if (_rl_mark_modified_lines && current_history () && rl_undo_list)
    {
      line[out++] = '*';
      line[out] = '\0';
      modmark = 1;
    }

  /* If someone thought that the redisplay was handled, but the currently
     visible line has a different modification state than the one about
     to become visible, then correct the caller's misconception. */
  if (visible_line[0] != invisible_line[0])
    rl_display_fixed = 0;

  /* If the prompt to be displayed is the `primary' readline prompt (the
     one passed to readline()), use the values we have already expanded.
     If not, use what's already in rl_display_prompt.  WRAP_OFFSET is the
     number of non-visible characters in the prompt string. */
  if (rl_display_prompt == rl_prompt || local_prompt)
    {
      if (local_prompt_prefix && forced_display)
	_rl_output_some_chars (local_prompt_prefix, strlen (local_prompt_prefix));

      if (local_prompt_len > 0)
	{
	  temp = local_prompt_len + out + 2;
	  if (temp >= line_size)
	    {
	      line_size = (temp + 1024) - (temp % 1024);
	      visible_line = (char *)xrealloc (visible_line, line_size);
	      line = invisible_line = (char *)xrealloc (invisible_line, line_size);
	    }
	  strncpy (line + out, local_prompt, local_prompt_len);
	  out += local_prompt_len;
	}
      line[out] = '\0';
      wrap_offset = local_prompt_len - prompt_visible_length;
    }
  else
    {
      int pmtlen;
      prompt_this_line = strrchr (rl_display_prompt, '\n');
      if (!prompt_this_line)
	prompt_this_line = rl_display_prompt;
      else
	{
	  prompt_this_line++;
	  pmtlen = prompt_this_line - rl_display_prompt;	/* temp var */
	  if (forced_display)
	    {
	      _rl_output_some_chars (rl_display_prompt, pmtlen);
	      /* Make sure we are at column zero even after a newline,
		 regardless of the state of terminal output processing. */
	      if (pmtlen < 2 || prompt_this_line[-2] != '\r')
		cr ();
	    }
	}

      prompt_physical_chars = pmtlen = strlen (prompt_this_line);
      temp = pmtlen + out + 2;
      if (temp >= line_size)
	{
	  line_size = (temp + 1024) - (temp % 1024);
	  visible_line = (char *)xrealloc (visible_line, line_size);
	  line = invisible_line = (char *)xrealloc (invisible_line, line_size);
	}
      strncpy (line + out,  prompt_this_line, pmtlen);
      out += pmtlen;
      line[out] = '\0';
      wrap_offset = prompt_invis_chars_first_line = 0;
    }

#define CHECK_INV_LBREAKS() \
      do { \
	if (newlines >= (inv_lbsize - 2)) \
	  { \
	    inv_lbsize *= 2; \
	    inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \
	  } \
      } while (0)

#if defined (HANDLE_MULTIBYTE)	  
#define CHECK_LPOS() \
      do { \
	lpos++; \
	if (lpos >= _rl_screenwidth) \
	  { \
	    if (newlines >= (inv_lbsize - 2)) \
	      { \
		inv_lbsize *= 2; \
		inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \
	      } \
	    inv_lbreaks[++newlines] = out; \
	    if (newlines >= (line_state_invisible->wbsize - 1)) \
	      { \
		line_state_invisible->wbsize *= 2; \
		line_state_invisible->wrapped_line = (int *)xrealloc (line_state_invisible->wrapped_line, line_state_invisible->wbsize * sizeof(int)); \
	      } \
	    line_state_invisible->wrapped_line[newlines] = _rl_wrapped_multicolumn; \
	    lpos = 0; \
	  } \
      } while (0)
#else
#define CHECK_LPOS() \
      do { \
	lpos++; \
	if (lpos >= _rl_screenwidth) \
	  { \
	    if (newlines >= (inv_lbsize - 2)) \
	      { \
		inv_lbsize *= 2; \
		inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \
	      } \
	    inv_lbreaks[++newlines] = out; \
	    lpos = 0; \
	  } \
      } while (0)
#endif

  /* inv_lbreaks[i] is where line i starts in the buffer. */
  inv_lbreaks[newlines = 0] = 0;
  lpos = prompt_physical_chars + modmark;

#if defined (HANDLE_MULTIBYTE)
  memset (line_state_invisible->wrapped_line, 0, line_state_invisible->wbsize * sizeof (int));
  num = 0;
#endif

  /* prompt_invis_chars_first_line is the number of invisible characters in
     the first physical line of the prompt.
     wrap_offset - prompt_invis_chars_first_line is the number of invis
     chars on the second (or, more generally, last) line. */

  /* This is zero-based, used to set the newlines */
  prompt_lines_estimate = lpos / _rl_screenwidth;

  /* what if lpos is already >= _rl_screenwidth before we start drawing the
     contents of the command line? */
  while (lpos >= _rl_screenwidth)
    {
      int z;
      /* fix from Darin Johnson <darin@@acuson.com> for prompt string with
         invisible characters that is longer than the screen width.  The
         prompt_invis_chars_first_line variable could be made into an array
         saying how many invisible characters there are per line, but that's
         probably too much work for the benefit gained.  How many people have
         prompts that exceed two physical lines?
         Additional logic fix from Edward Catmur <ed@@catmur.co.uk> */
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0 && prompt_multibyte_chars > 0)
	{
	  n0 = num;
          temp = local_prompt_len;
          while (num < temp)
	    {
	      z = _rl_col_width  (local_prompt, n0, num, 1);
	      if (z > _rl_screenwidth)
		{
	          num = _rl_find_prev_mbchar (local_prompt, num, MB_FIND_ANY);
	          break;
		}
	      else if (z == _rl_screenwidth)
	        break;
	      num++;
	    }
          temp = num;
	}
      else
#endif /* !HANDLE_MULTIBYTE */
	temp = ((newlines + 1) * _rl_screenwidth);

      /* Now account for invisible characters in the current line. */
      /* XXX - this assumes that the invisible characters may be split, but only
	 between the first and the last lines. */
      temp += ((local_prompt_prefix == 0) ? ((newlines == 0) ? prompt_invis_chars_first_line
							     : ((newlines == prompt_lines_estimate) ? wrap_offset : prompt_invis_chars_first_line))
					  : ((newlines == 0) ? wrap_offset : 0));
             
      inv_lbreaks[++newlines] = temp;
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0 && prompt_multibyte_chars > 0)
	lpos -= _rl_col_width (local_prompt, n0, num, 1);
      else
#endif
	lpos -= _rl_screenwidth;
    }

  prompt_last_screen_line = newlines;

  /* Draw the rest of the line (after the prompt) into invisible_line, keeping
     track of where the cursor is (cpos_buffer_position), the number of the line containing
     the cursor (lb_linenum), the last line number (lb_botlin and inv_botlin).
     It maintains an array of line breaks for display (inv_lbreaks).
     This handles expanding tabs for display and displaying meta characters. */
  lb_linenum = 0;
#if defined (HANDLE_MULTIBYTE)
  in = 0;
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      memset (&ps, 0, sizeof (mbstate_t));
      /* XXX - what if wc_bytes ends up <= 0? check for MB_INVALIDCH */
      wc_bytes = mbrtowc (&wc, rl_line_buffer, rl_end, &ps);
    }
  else
    wc_bytes = 1;
  while (in < rl_end)
#else
  for (in = 0; in < rl_end; in++)
#endif
    {
      c = (unsigned char)rl_line_buffer[in];

#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  if (MB_INVALIDCH (wc_bytes))
	    {
	      /* Byte sequence is invalid or shortened.  Assume that the
	         first byte represents a character. */
	      wc_bytes = 1;
	      /* Assume that a character occupies a single column. */
	      wc_width = 1;
	      memset (&ps, 0, sizeof (mbstate_t));
	    }
	  else if (MB_NULLWCH (wc_bytes))
	    break;			/* Found '\0' */
	  else
	    {
	      temp = wcwidth (wc);
	      wc_width = (temp >= 0) ? temp : 1;
	    }
	}
#endif

      if (out + 8 >= line_size)		/* XXX - 8 for \t */
	{
	  line_size *= 2;
	  visible_line = (char *)xrealloc (visible_line, line_size);
	  invisible_line = (char *)xrealloc (invisible_line, line_size);
	  line = invisible_line;
	}

      if (in == rl_point)
	{
	  cpos_buffer_position = out;
	  lb_linenum = newlines;
	}

#if defined (HANDLE_MULTIBYTE)
      if (META_CHAR (c) && _rl_output_meta_chars == 0)	/* XXX - clean up */
#else
      if (META_CHAR (c))
#endif
	{
	  if (_rl_output_meta_chars == 0)
	    {
	      sprintf (line + out, "\\%o", c);

	      if (lpos + 4 >= _rl_screenwidth)
		{
		  temp = _rl_screenwidth - lpos;
		  CHECK_INV_LBREAKS ();
		  inv_lbreaks[++newlines] = out + temp;
		  lpos = 4 - temp;
		}
	      else
		lpos += 4;

	      out += 4;
	    }
	  else
	    {
	      line[out++] = c;
	      CHECK_LPOS();
	    }
	}
#if defined (DISPLAY_TABS)
      else if (c == '\t')
	{
	  register int newout;

#if 0
	  newout = (out | (int)7) + 1;
#else
	  newout = out + 8 - lpos % 8;
#endif
	  temp = newout - out;
	  if (lpos + temp >= _rl_screenwidth)
	    {
	      register int temp2;
	      temp2 = _rl_screenwidth - lpos;
	      CHECK_INV_LBREAKS ();
	      inv_lbreaks[++newlines] = out + temp2;
	      lpos = temp - temp2;
	      while (out < newout)
		line[out++] = ' ';
	    }
	  else
	    {
	      while (out < newout)
		line[out++] = ' ';
	      lpos += temp;
	    }
	}
#endif
      else if (c == '\n' && _rl_horizontal_scroll_mode == 0 && _rl_term_up && *_rl_term_up)
	{
	  line[out++] = '\0';	/* XXX - sentinel */
	  CHECK_INV_LBREAKS ();
	  inv_lbreaks[++newlines] = out;
	  lpos = 0;
	}
      else if (CTRL_CHAR (c) || c == RUBOUT)
	{
	  line[out++] = '^';
	  CHECK_LPOS();
	  line[out++] = CTRL_CHAR (c) ? UNCTRL (c) : '?';
	  CHECK_LPOS();
	}
      else
	{
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      register int i;

	      _rl_wrapped_multicolumn = 0;

	      if (_rl_screenwidth < lpos + wc_width)
		for (i = lpos; i < _rl_screenwidth; i++)
		  {
		    /* The space will be removed in update_line() */
		    line[out++] = ' ';
		    _rl_wrapped_multicolumn++;
		    CHECK_LPOS();
		  }
	      if (in == rl_point)
		{
		  cpos_buffer_position = out;
		  lb_linenum = newlines;
		}
	      for (i = in; i < in+wc_bytes; i++)
		line[out++] = rl_line_buffer[i];
	      for (i = 0; i < wc_width; i++)
		CHECK_LPOS();
	    }
	  else
	    {
	      line[out++] = c;
	      CHECK_LPOS();
	    }
#else
	  line[out++] = c;
	  CHECK_LPOS();
#endif
	}

#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  in += wc_bytes;
	  /* XXX - what if wc_bytes ends up <= 0? check for MB_INVALIDCH */
	  wc_bytes = mbrtowc (&wc, rl_line_buffer + in, rl_end - in, &ps);
	}
      else
        in++;
#endif

    }
  line[out] = '\0';
  if (cpos_buffer_position < 0)
    {
      cpos_buffer_position = out;
      lb_linenum = newlines;
    }

  inv_botlin = lb_botlin = newlines;
  CHECK_INV_LBREAKS ();
  inv_lbreaks[newlines+1] = out;
  cursor_linenum = lb_linenum;

  /* CPOS_BUFFER_POSITION == position in buffer where cursor should be placed.
     CURSOR_LINENUM == line number where the cursor should be placed. */

  /* PWP: now is when things get a bit hairy.  The visible and invisible
     line buffers are really multiple lines, which would wrap every
     (screenwidth - 1) characters.  Go through each in turn, finding
     the changed region and updating it.  The line order is top to bottom. */

  /* If we can move the cursor up and down, then use multiple lines,
     otherwise, let long lines display in a single terminal line, and
     horizontally scroll it. */

  if (_rl_horizontal_scroll_mode == 0 && _rl_term_up && *_rl_term_up)
    {
      int nleft, pos, changed_screen_line, tx;

      if (!rl_display_fixed || forced_display)
	{
	  forced_display = 0;

	  /* If we have more than a screenful of material to display, then
	     only display a screenful.  We should display the last screen,
	     not the first.  */
	  if (out >= _rl_screenchars)
	    {
	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		out = _rl_find_prev_mbchar (line, _rl_screenchars, MB_FIND_ANY);
	      else
		out = _rl_screenchars - 1;
	    }

	  /* The first line is at character position 0 in the buffer.  The
	     second and subsequent lines start at inv_lbreaks[N], offset by
	     OFFSET (which has already been calculated above).  */

#define INVIS_FIRST()	(prompt_physical_chars > _rl_screenwidth ? prompt_invis_chars_first_line : wrap_offset)
#define WRAP_OFFSET(line, offset)  ((line == 0) \
					? (offset ? INVIS_FIRST() : 0) \
					: ((line == prompt_last_screen_line) ? wrap_offset-prompt_invis_chars_first_line : 0))
#define W_OFFSET(line, offset) ((line) == 0 ? offset : 0)
#define VIS_LLEN(l)	((l) > _rl_vis_botlin ? 0 : (vis_lbreaks[l+1] - vis_lbreaks[l]))
#define INV_LLEN(l)	(inv_lbreaks[l+1] - inv_lbreaks[l])
#define VIS_CHARS(line) (visible_line + vis_lbreaks[line])
#define VIS_LINE(line) ((line) > _rl_vis_botlin) ? "" : VIS_CHARS(line)
#define INV_LINE(line) (invisible_line + inv_lbreaks[line])

#define OLD_CPOS_IN_PROMPT() (cpos_adjusted == 0 && \
			_rl_last_c_pos != o_cpos && \
			_rl_last_c_pos > wrap_offset && \
			o_cpos < prompt_last_invisible)

	  /* For each line in the buffer, do the updating display. */
	  for (linenum = 0; linenum <= inv_botlin; linenum++)
	    {
	      /* This can lead us astray if we execute a program that changes
		 the locale from a non-multibyte to a multibyte one. */
	      o_cpos = _rl_last_c_pos;
	      cpos_adjusted = 0;
	      update_line (VIS_LINE(linenum), INV_LINE(linenum), linenum,
			   VIS_LLEN(linenum), INV_LLEN(linenum), inv_botlin);

	      /* update_line potentially changes _rl_last_c_pos, but doesn't
		 take invisible characters into account, since _rl_last_c_pos
		 is an absolute cursor position in a multibyte locale.  See
		 if compensating here is the right thing, or if we have to
		 change update_line itself.  There are several cases in which
		 update_line adjusts _rl_last_c_pos itself (so it can pass
		 _rl_move_cursor_relative accurate values); it communicates
		 this back by setting cpos_adjusted.  If we assume that
		 _rl_last_c_pos is correct (an absolute cursor position) each
		 time update_line is called, then we can assume in our
		 calculations that o_cpos does not need to be adjusted by
		 wrap_offset. */
	      if (linenum == 0 && (MB_CUR_MAX > 1 && rl_byte_oriented == 0) && OLD_CPOS_IN_PROMPT())
		_rl_last_c_pos -= prompt_invis_chars_first_line;	/* XXX - was wrap_offset */
	      else if (linenum == prompt_last_screen_line && prompt_physical_chars > _rl_screenwidth &&
			(MB_CUR_MAX > 1 && rl_byte_oriented == 0) &&
			cpos_adjusted == 0 &&
			_rl_last_c_pos != o_cpos &&
			_rl_last_c_pos > (prompt_last_invisible - _rl_screenwidth - prompt_invis_chars_first_line))
		_rl_last_c_pos -= (wrap_offset-prompt_invis_chars_first_line);
		  
	      /* If this is the line with the prompt, we might need to
		 compensate for invisible characters in the new line. Do
		 this only if there is not more than one new line (which
		 implies that we completely overwrite the old visible line)
		 and the new line is shorter than the old.  Make sure we are
		 at the end of the new line before clearing. */
	      if (linenum == 0 &&
		  inv_botlin == 0 && _rl_last_c_pos == out &&
		  (wrap_offset > visible_wrap_offset) &&
		  (_rl_last_c_pos < visible_first_line_len))
		{
		  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		    nleft = _rl_screenwidth - _rl_last_c_pos;
		  else
		    nleft = _rl_screenwidth + wrap_offset - _rl_last_c_pos;
		  if (nleft)
		    _rl_clear_to_eol (nleft);
		}
#if 0
	      /* This segment is intended to handle the case where the prompt
		 has invisible characters on the second line and the new line
		 to be displayed needs to clear the rest of the old characters
		 out (e.g., when printing the i-search prompt).  In general,
		 the case of the new line being shorter than the old.
		 Incomplete */
	      else if (linenum == prompt_last_screen_line &&
		       prompt_physical_chars > _rl_screenwidth &&
		       wrap_offset != prompt_invis_chars_first_line &&
		       _rl_last_c_pos == out &&
#endif


	      /* Since the new first line is now visible, save its length. */
	      if (linenum == 0)
		visible_first_line_len = (inv_botlin > 0) ? inv_lbreaks[1] : out - wrap_offset;
	    }

	  /* We may have deleted some lines.  If so, clear the left over
	     blank ones at the bottom out. */
	  if (_rl_vis_botlin > inv_botlin)
	    {
	      char *tt;
	      for (; linenum <= _rl_vis_botlin; linenum++)
		{
		  tt = VIS_CHARS (linenum);
		  _rl_move_vert (linenum);
		  _rl_move_cursor_relative (0, tt);
		  _rl_clear_to_eol
		    ((linenum == _rl_vis_botlin) ? strlen (tt) : _rl_screenwidth);
		}
	    }
	  _rl_vis_botlin = inv_botlin;

	  /* CHANGED_SCREEN_LINE is set to 1 if we have moved to a
	     different screen line during this redisplay. */
	  changed_screen_line = _rl_last_v_pos != cursor_linenum;
	  if (changed_screen_line)
	    {
	      _rl_move_vert (cursor_linenum);
	      /* If we moved up to the line with the prompt using _rl_term_up,
		 the physical cursor position on the screen stays the same,
		 but the buffer position needs to be adjusted to account
		 for invisible characters. */
	      if ((MB_CUR_MAX == 1 || rl_byte_oriented) && cursor_linenum == 0 && wrap_offset)
		_rl_last_c_pos += wrap_offset;
	    }

	  /* We have to reprint the prompt if it contains invisible
	     characters, since it's not generally OK to just reprint
	     the characters from the current cursor position.  But we
	     only need to reprint it if the cursor is before the last
	     invisible character in the prompt string. */
	  nleft = prompt_visible_length + wrap_offset;
	  if (cursor_linenum == 0 && wrap_offset > 0 && _rl_last_c_pos > 0 &&
#if 0
	      _rl_last_c_pos <= PROMPT_ENDING_INDEX && local_prompt)
#else
	      _rl_last_c_pos < PROMPT_ENDING_INDEX && local_prompt)
#endif
	    {
#if defined (__MSDOS__)
	      putc ('\r', rl_outstream);
#else
	      if (_rl_term_cr)
		tputs (_rl_term_cr, 1, _rl_output_character_function);
#endif
	      if (modmark)
		_rl_output_some_chars ("*", 1);

	      _rl_output_some_chars (local_prompt, nleft);
	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		_rl_last_c_pos = _rl_col_width (local_prompt, 0, nleft, 1) - wrap_offset + modmark;
	      else
		_rl_last_c_pos = nleft + modmark;
	    }

	  /* Where on that line?  And where does that line start
	     in the buffer? */
	  pos = inv_lbreaks[cursor_linenum];
	  /* nleft == number of characters in the line buffer between the
	     start of the line and the desired cursor position. */
	  nleft = cpos_buffer_position - pos;

	  /* NLEFT is now a number of characters in a buffer.  When in a
	     multibyte locale, however, _rl_last_c_pos is an absolute cursor
	     position that doesn't take invisible characters in the prompt
	     into account.  We use a fudge factor to compensate. */

	  /* Since _rl_backspace() doesn't know about invisible characters in the
	     prompt, and there's no good way to tell it, we compensate for
	     those characters here and call _rl_backspace() directly. */
	  if (wrap_offset && cursor_linenum == 0 && nleft < _rl_last_c_pos)
	    {
	      /* TX == new physical cursor position in multibyte locale. */
	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		tx = _rl_col_width (&visible_line[pos], 0, nleft, 1) - visible_wrap_offset;
	      else
		tx = nleft;
	      if (tx >= 0 && _rl_last_c_pos > tx)
		{
	          _rl_backspace (_rl_last_c_pos - tx);	/* XXX */
	          _rl_last_c_pos = tx;
		}
	    }

	  /* We need to note that in a multibyte locale we are dealing with
	     _rl_last_c_pos as an absolute cursor position, but moving to a
	     point specified by a buffer position (NLEFT) that doesn't take
	     invisible characters into account. */
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    _rl_move_cursor_relative (nleft, &invisible_line[pos]);
	  else if (nleft != _rl_last_c_pos)
	    _rl_move_cursor_relative (nleft, &invisible_line[pos]);
	}
    }
  else				/* Do horizontal scrolling. */
    {
#define M_OFFSET(margin, offset) ((margin) == 0 ? offset : 0)
      int lmargin, ndisp, nleft, phys_c_pos, t;

      /* Always at top line. */
      _rl_last_v_pos = 0;

      /* Compute where in the buffer the displayed line should start.  This
	 will be LMARGIN. */

      /* The number of characters that will be displayed before the cursor. */
      ndisp = cpos_buffer_position - wrap_offset;
      nleft  = prompt_visible_length + wrap_offset;
      /* Where the new cursor position will be on the screen.  This can be
	 longer than SCREENWIDTH; if it is, lmargin will be adjusted. */
      phys_c_pos = cpos_buffer_position - (last_lmargin ? last_lmargin : wrap_offset);
      t = _rl_screenwidth / 3;

      /* If the number of characters had already exceeded the screenwidth,
	 last_lmargin will be > 0. */

      /* If the number of characters to be displayed is more than the screen
	 width, compute the starting offset so that the cursor is about
	 two-thirds of the way across the screen. */
      if (phys_c_pos > _rl_screenwidth - 2)
	{
	  lmargin = cpos_buffer_position - (2 * t);
	  if (lmargin < 0)
	    lmargin = 0;
	  /* If the left margin would be in the middle of a prompt with
	     invisible characters, don't display the prompt at all. */
	  if (wrap_offset && lmargin > 0 && lmargin < nleft)
	    lmargin = nleft;
	}
      else if (ndisp < _rl_screenwidth - 2)		/* XXX - was -1 */
	lmargin = 0;
      else if (phys_c_pos < 1)
	{
	  /* If we are moving back towards the beginning of the line and
	     the last margin is no longer correct, compute a new one. */
	  lmargin = ((cpos_buffer_position - 1) / t) * t;	/* XXX */
	  if (wrap_offset && lmargin > 0 && lmargin < nleft)
	    lmargin = nleft;
	}
      else
	lmargin = last_lmargin;

      /* If the first character on the screen isn't the first character
	 in the display line, indicate this with a special character. */
      if (lmargin > 0)
	line[lmargin] = '<';

      /* If SCREENWIDTH characters starting at LMARGIN do not encompass
	 the whole line, indicate that with a special character at the
	 right edge of the screen.  If LMARGIN is 0, we need to take the
	 wrap offset into account. */
      t = lmargin + M_OFFSET (lmargin, wrap_offset) + _rl_screenwidth;
      if (t < out)
	line[t - 1] = '>';

      if (rl_display_fixed == 0 || forced_display || lmargin != last_lmargin)
	{
	  forced_display = 0;
	  o_cpos = _rl_last_c_pos;
	  cpos_adjusted = 0;
	  update_line (&visible_line[last_lmargin],
		       &invisible_line[lmargin],
		       0,
		       _rl_screenwidth + visible_wrap_offset,
		       _rl_screenwidth + (lmargin ? 0 : wrap_offset),
		       0);

	  if ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) && OLD_CPOS_IN_PROMPT())
	    _rl_last_c_pos -= prompt_invis_chars_first_line;	/* XXX - was wrap_offset */

	  /* If the visible new line is shorter than the old, but the number
	     of invisible characters is greater, and we are at the end of
	     the new line, we need to clear to eol. */
	  t = _rl_last_c_pos - M_OFFSET (lmargin, wrap_offset);
	  if ((M_OFFSET (lmargin, wrap_offset) > visible_wrap_offset) &&
	      (_rl_last_c_pos == out) &&
	      t < visible_first_line_len)
	    {
	      nleft = _rl_screenwidth - t;
	      _rl_clear_to_eol (nleft);
	    }
	  visible_first_line_len = out - lmargin - M_OFFSET (lmargin, wrap_offset);
	  if (visible_first_line_len > _rl_screenwidth)
	    visible_first_line_len = _rl_screenwidth;

	  _rl_move_cursor_relative (cpos_buffer_position - lmargin, &invisible_line[lmargin]);
	  last_lmargin = lmargin;
	}
    }
  fflush (rl_outstream);

  /* Swap visible and non-visible lines. */
  {
    struct line_state *vtemp = line_state_visible;

    line_state_visible = line_state_invisible;
    line_state_invisible = vtemp;

    rl_display_fixed = 0;
    /* If we are displaying on a single line, and last_lmargin is > 0, we
       are not displaying any invisible characters, so set visible_wrap_offset
       to 0. */
    if (_rl_horizontal_scroll_mode && last_lmargin)
      visible_wrap_offset = 0;
    else
      visible_wrap_offset = wrap_offset;
  }

  RL_UNSETSTATE (RL_STATE_REDISPLAYING);
  _rl_release_sigint ();
}

/* PWP: update_line() is based on finding the middle difference of each
   line on the screen; vis:

			     /old first difference
	/beginning of line   |	      /old last same       /old EOL
	v		     v	      v		    v
old:	eddie> Oh, my little gruntle-buggy is to me, as lurgid as
new:	eddie> Oh, my little buggy says to me, as lurgid as
	^		     ^	^			   ^
	\beginning of line   |	\new last same	   \new end of line
			     \new first difference

   All are character pointers for the sake of speed.  Special cases for
   no differences, as well as for end of line additions must be handled.

   Could be made even smarter, but this works well enough */
static void
update_line (old, new, current_line, omax, nmax, inv_botlin)
     register char *old, *new;
     int current_line, omax, nmax, inv_botlin;
{
  register char *ofd, *ols, *oe, *nfd, *nls, *ne;
  int temp, lendiff, wsatend, od, nd, twidth, o_cpos;
  int current_invis_chars;
  int col_lendiff, col_temp;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps_new, ps_old;
  int new_offset, old_offset;
#endif

  /* If we're at the right edge of a terminal that supports xn, we're
     ready to wrap around, so do so.  This fixes problems with knowing
     the exact cursor position and cut-and-paste with certain terminal
     emulators.  In this calculation, TEMP is the physical screen
     position of the cursor. */
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    temp = _rl_last_c_pos;
  else
    temp = _rl_last_c_pos - WRAP_OFFSET (_rl_last_v_pos, visible_wrap_offset);
  if (temp == _rl_screenwidth && _rl_term_autowrap && !_rl_horizontal_scroll_mode
	&& _rl_last_v_pos == current_line - 1)
    {
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  wchar_t wc;
	  mbstate_t ps;
	  int tempwidth, bytes;
	  size_t ret;

	  /* This fixes only double-column characters, but if the wrapped
	     character comsumes more than three columns, spaces will be
	     inserted in the string buffer. */
	  if (current_line < line_state_visible->wbsize && line_state_visible->wrapped_line[current_line] > 0)
	    _rl_clear_to_eol (line_state_visible->wrapped_line[current_line]);

	  memset (&ps, 0, sizeof (mbstate_t));
	  ret = mbrtowc (&wc, new, MB_CUR_MAX, &ps);
	  if (MB_INVALIDCH (ret))
	    {
	      tempwidth = 1;
	      ret = 1;
	    }
	  else if (MB_NULLWCH (ret))
	    tempwidth = 0;
	  else
	    tempwidth = wcwidth (wc);

	  if (tempwidth > 0)
	    {
	      int count, i;
	      bytes = ret;
	      for (count = 0; count < bytes; count++)
		putc (new[count], rl_outstream);
	      _rl_last_c_pos = tempwidth;
	      _rl_last_v_pos++;
	      memset (&ps, 0, sizeof (mbstate_t));
	      ret = mbrtowc (&wc, old, MB_CUR_MAX, &ps);
	      if (ret != 0 && bytes != 0)
		{
		  if (MB_INVALIDCH (ret))
		    ret = 1;
		  memmove (old+bytes, old+ret, strlen (old+ret));
		  memcpy (old, new, bytes);
		  /* Fix up indices if we copy data from one line to another */
		  omax += bytes - ret;
		  for (i = current_line+1; i < inv_botlin+1; i++)
		    vis_lbreaks[i] += bytes - ret;
		}
	    }
	  else
	    {
	      putc (' ', rl_outstream);
	      _rl_last_c_pos = 1;
	      _rl_last_v_pos++;
	      if (old[0] && new[0])
		old[0] = new[0];
	    }
	}
      else
#endif
	{
	  if (new[0])
	    putc (new[0], rl_outstream);
	  else
	    putc (' ', rl_outstream);
	  _rl_last_c_pos = 1;
	  _rl_last_v_pos++;
	  if (old[0] && new[0])
	    old[0] = new[0];
	}
    }

      
  /* Find first difference. */
#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      /* See if the old line is a subset of the new line, so that the
	 only change is adding characters. */
      temp = (omax < nmax) ? omax : nmax;
      if (memcmp (old, new, temp) == 0)		/* adding at the end */
	{
	  ofd = old + temp;
	  nfd = new + temp;
	}
      else
	{      
	  memset (&ps_new, 0, sizeof(mbstate_t));
	  memset (&ps_old, 0, sizeof(mbstate_t));

	  if (omax == nmax && STREQN (new, old, omax))
	    {
	      ofd = old + omax;
	      nfd = new + nmax;
	    }
	  else
	    {
	      new_offset = old_offset = 0;
	      for (ofd = old, nfd = new;
		    (ofd - old < omax) && *ofd &&
		    _rl_compare_chars(old, old_offset, &ps_old, new, new_offset, &ps_new); )
		{
		  old_offset = _rl_find_next_mbchar (old, old_offset, 1, MB_FIND_ANY);
		  new_offset = _rl_find_next_mbchar (new, new_offset, 1, MB_FIND_ANY);
		  ofd = old + old_offset;
		  nfd = new + new_offset;
		}
	    }
	}
    }
  else
#endif
  for (ofd = old, nfd = new;
       (ofd - old < omax) && *ofd && (*ofd == *nfd);
       ofd++, nfd++)
    ;

  /* Move to the end of the screen line.  ND and OD are used to keep track
     of the distance between ne and new and oe and old, respectively, to
     move a subtraction out of each loop. */
  for (od = ofd - old, oe = ofd; od < omax && *oe; oe++, od++);
  for (nd = nfd - new, ne = nfd; nd < nmax && *ne; ne++, nd++);

  /* If no difference, continue to next line. */
  if (ofd == oe && nfd == ne)
    return;

  wsatend = 1;			/* flag for trailing whitespace */

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      ols = old + _rl_find_prev_mbchar (old, oe - old, MB_FIND_ANY);
      nls = new + _rl_find_prev_mbchar (new, ne - new, MB_FIND_ANY);
      while ((ols > ofd) && (nls > nfd))
	{
	  memset (&ps_old, 0, sizeof (mbstate_t));
	  memset (&ps_new, 0, sizeof (mbstate_t));

#if 0
	  /* On advice from jir@@yamato.ibm.com */
	  _rl_adjust_point (old, ols - old, &ps_old);
	  _rl_adjust_point (new, nls - new, &ps_new);
#endif

	  if (_rl_compare_chars (old, ols - old, &ps_old, new, nls - new, &ps_new) == 0)
	    break;

	  if (*ols == ' ')
	    wsatend = 0;

	  ols = old + _rl_find_prev_mbchar (old, ols - old, MB_FIND_ANY);
	  nls = new + _rl_find_prev_mbchar (new, nls - new, MB_FIND_ANY);
	}
    }
  else
    {
#endif /* HANDLE_MULTIBYTE */
  ols = oe - 1;			/* find last same */
  nls = ne - 1;
  while ((ols > ofd) && (nls > nfd) && (*ols == *nls))
    {
      if (*ols != ' ')
	wsatend = 0;
      ols--;
      nls--;
    }
#if defined (HANDLE_MULTIBYTE)
    }
#endif

  if (wsatend)
    {
      ols = oe;
      nls = ne;
    }
#if defined (HANDLE_MULTIBYTE)
  /* This may not work for stateful encoding, but who cares?  To handle
     stateful encoding properly, we have to scan each string from the
     beginning and compare. */
  else if (_rl_compare_chars (ols, 0, NULL, nls, 0, NULL) == 0)
#else
  else if (*ols != *nls)
#endif
    {
      if (*ols)			/* don't step past the NUL */
	{
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    ols = old + _rl_find_next_mbchar (old, ols - old, 1, MB_FIND_ANY);
	  else
	    ols++;
	}
      if (*nls)
	{
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    nls = new + _rl_find_next_mbchar (new, nls - new, 1, MB_FIND_ANY);
	  else
	    nls++;
	}
    }

  /* count of invisible characters in the current invisible line. */
  current_invis_chars = W_OFFSET (current_line, wrap_offset);
  if (_rl_last_v_pos != current_line)
    {
      _rl_move_vert (current_line);
      if ((MB_CUR_MAX == 1 || rl_byte_oriented) && current_line == 0 && visible_wrap_offset)
	_rl_last_c_pos += visible_wrap_offset;
    }

  /* If this is the first line and there are invisible characters in the
     prompt string, and the prompt string has not changed, and the current
     cursor position is before the last invisible character in the prompt,
     and the index of the character to move to is past the end of the prompt
     string, then redraw the entire prompt string.  We can only do this
     reliably if the terminal supports a `cr' capability.

     This is not an efficiency hack -- there is a problem with redrawing
     portions of the prompt string if they contain terminal escape
     sequences (like drawing the `unbold' sequence without a corresponding
     `bold') that manifests itself on certain terminals. */

  lendiff = local_prompt_len;
  od = ofd - old;	/* index of first difference in visible line */
  if (current_line == 0 && !_rl_horizontal_scroll_mode &&
      _rl_term_cr && lendiff > prompt_visible_length && _rl_last_c_pos > 0 &&
      od >= lendiff && _rl_last_c_pos < PROMPT_ENDING_INDEX)
    {
#if defined (__MSDOS__)
      putc ('\r', rl_outstream);
#else
      tputs (_rl_term_cr, 1, _rl_output_character_function);
#endif
      if (modmark)
	_rl_output_some_chars ("*", 1);
      _rl_output_some_chars (local_prompt, lendiff);
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  /* We take wrap_offset into account here so we can pass correct
	     information to _rl_move_cursor_relative. */
	  _rl_last_c_pos = _rl_col_width (local_prompt, 0, lendiff, 1) - wrap_offset + modmark;
	  cpos_adjusted = 1;
	}
      else
	_rl_last_c_pos = lendiff + modmark;
    }

  o_cpos = _rl_last_c_pos;

  /* When this function returns, _rl_last_c_pos is correct, and an absolute
     cursor postion in multibyte mode, but a buffer index when not in a
     multibyte locale. */
  _rl_move_cursor_relative (od, old);
#if 1
#if defined (HANDLE_MULTIBYTE)
  /* We need to indicate that the cursor position is correct in the presence of
     invisible characters in the prompt string.  Let's see if setting this when
     we make sure we're at the end of the drawn prompt string works. */
  if (current_line == 0 && MB_CUR_MAX > 1 && rl_byte_oriented == 0 &&
      (_rl_last_c_pos > 0 || o_cpos > 0) &&
      _rl_last_c_pos == prompt_physical_chars)
    cpos_adjusted = 1;
#endif
#endif

  /* if (len (new) > len (old))
     lendiff == difference in buffer
     col_lendiff == difference on screen
     When not using multibyte characters, these are equal */
  lendiff = (nls - nfd) - (ols - ofd);
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    col_lendiff = _rl_col_width (new, nfd - new, nls - new, 1) - _rl_col_width (old, ofd - old, ols - old, 1);
  else
    col_lendiff = lendiff;

  /* If we are changing the number of invisible characters in a line, and
     the spot of first difference is before the end of the invisible chars,
     lendiff needs to be adjusted. */
  if (current_line == 0 && !_rl_horizontal_scroll_mode &&
      current_invis_chars != visible_wrap_offset)
    {
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  lendiff += visible_wrap_offset - current_invis_chars;
	  col_lendiff += visible_wrap_offset - current_invis_chars;
	}
      else
	{
	  lendiff += visible_wrap_offset - current_invis_chars;
	  col_lendiff = lendiff;
	}
    }

  /* Insert (diff (len (old), len (new)) ch. */
  temp = ne - nfd;
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    col_temp = _rl_col_width (new, nfd - new, ne - new, 1);
  else
    col_temp = temp;

  if (col_lendiff > 0)	/* XXX - was lendiff */
    {
      /* Non-zero if we're increasing the number of lines. */
      int gl = current_line >= _rl_vis_botlin && inv_botlin > _rl_vis_botlin;
      /* If col_lendiff is > 0, implying that the new string takes up more
	 screen real estate than the old, but lendiff is < 0, meaning that it
	 takes fewer bytes, we need to just output the characters starting
	 from the first difference.  These will overwrite what is on the
	 display, so there's no reason to do a smart update.  This can really
	 only happen in a multibyte environment. */
      if (lendiff < 0)
	{
	  _rl_output_some_chars (nfd, temp);
	  _rl_last_c_pos += _rl_col_width (nfd, 0, temp, 1);
	  /* If nfd begins before any invisible characters in the prompt,
	     adjust _rl_last_c_pos to account for wrap_offset and set
	     cpos_adjusted to let the caller know. */
	  if (current_line == 0 && wrap_offset && ((nfd - new) <= prompt_last_invisible))
	    {
	      _rl_last_c_pos -= wrap_offset;
	      cpos_adjusted = 1;
	    }
	  return;
	}
      /* Sometimes it is cheaper to print the characters rather than
	 use the terminal's capabilities.  If we're growing the number
	 of lines, make sure we actually cause the new line to wrap
	 around on auto-wrapping terminals. */
      else if (_rl_terminal_can_insert && ((2 * col_temp) >= col_lendiff || _rl_term_IC) && (!_rl_term_autowrap || !gl))
	{
	  /* If lendiff > prompt_visible_length and _rl_last_c_pos == 0 and
	     _rl_horizontal_scroll_mode == 1, inserting the characters with
	     _rl_term_IC or _rl_term_ic will screw up the screen because of the
	     invisible characters.  We need to just draw them. */
	  /* The same thing happens if we're trying to draw before the last
	     invisible character in the prompt string or we're increasing the
	     number of invisible characters in the line and we're not drawing
	     the entire prompt string. */
	  if (*ols && ((_rl_horizontal_scroll_mode &&
			_rl_last_c_pos == 0 &&
			lendiff > prompt_visible_length &&
			current_invis_chars > 0) == 0) &&
		      (((MB_CUR_MAX > 1 && rl_byte_oriented == 0) &&
		        current_line == 0 && wrap_offset &&
		        ((nfd - new) <= prompt_last_invisible) &&
		        (col_lendiff < prompt_visible_length)) == 0) &&
		      (visible_wrap_offset >= current_invis_chars))
	    {
	      insert_some_chars (nfd, lendiff, col_lendiff);
	      _rl_last_c_pos += col_lendiff;
	    }
#if 0		/* XXX - for now */
	  else if ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) && _rl_last_c_pos == 0 && wrap_offset && (nfd-new) <= prompt_last_invisible && col_lendiff < prompt_visible_length && visible_wrap_offset >= current_invis_chars)
	    {
	      _rl_output_some_chars (nfd, lendiff);
	      _rl_last_c_pos += col_lendiff;
	    }
#endif
	  else if ((MB_CUR_MAX == 1 || rl_byte_oriented != 0) && *ols == 0 && lendiff > 0)
	    {
	      /* At the end of a line the characters do not have to
		 be "inserted".  They can just be placed on the screen. */
	      /* However, this screws up the rest of this block, which
		 assumes you've done the insert because you can. */
	      _rl_output_some_chars (nfd, lendiff);
	      _rl_last_c_pos += col_lendiff;
	    }
	  else
	    {
	      _rl_output_some_chars (nfd, temp);
	      _rl_last_c_pos += col_temp;
	      /* If nfd begins before the last invisible character in the
		 prompt, adjust _rl_last_c_pos to account for wrap_offset
		 and set cpos_adjusted to let the caller know. */
	      if ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) && current_line == 0 && wrap_offset && ((nfd - new) <= prompt_last_invisible))
		{
		  _rl_last_c_pos -= wrap_offset;
		  cpos_adjusted = 1;
		}
	      return;
	    }
	  /* Copy (new) chars to screen from first diff to last match. */
	  temp = nls - nfd;
	  if ((temp - lendiff) > 0)
	    {
	      _rl_output_some_chars (nfd + lendiff, temp - lendiff);
	     /* XXX -- this bears closer inspection.  Fixes a redisplay bug
		reported against bash-3.0-alpha by Andreas Schwab involving
		multibyte characters and prompt strings with invisible
		characters, but was previously disabled. */
	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		twidth = _rl_col_width (nfd+lendiff, 0, temp-col_lendiff, 1);
	      else
		twidth = temp - lendiff;
	      _rl_last_c_pos += twidth;
	      /* If nfd begins before the last invisible character in the
		 prompt, adjust _rl_last_c_pos to account for wrap_offset
		 and set cpos_adjusted to let the caller know. */
	      if ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) && current_line == 0 && wrap_offset && ((nfd - new) <= prompt_last_invisible))
		{
		  _rl_last_c_pos -= wrap_offset;
		  cpos_adjusted = 1;
		}
	    }
	}
      else
	{
	  /* cannot insert chars, write to EOL */
	  _rl_output_some_chars (nfd, temp);
	  _rl_last_c_pos += col_temp;
	  /* If we're in a multibyte locale and were before the last invisible
	     char in the current line (which implies we just output some invisible
	     characters) we need to adjust _rl_last_c_pos, since it represents
	     a physical character position. */
	  if ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) &&
		current_line == prompt_last_screen_line && wrap_offset &&
		wrap_offset != prompt_invis_chars_first_line &&
		((nfd-new) < (prompt_last_invisible-(current_line*_rl_screenwidth))))
	    {
	      _rl_last_c_pos -= wrap_offset - prompt_invis_chars_first_line;
	      cpos_adjusted = 1;
	    }
	}
    }
  else				/* Delete characters from line. */
    {
      /* If possible and inexpensive to use terminal deletion, then do so. */
      if (_rl_term_dc && (2 * col_temp) >= -col_lendiff)
	{
	  /* If all we're doing is erasing the invisible characters in the
	     prompt string, don't bother.  It screws up the assumptions
	     about what's on the screen. */
	  if (_rl_horizontal_scroll_mode && _rl_last_c_pos == 0 &&
	      -lendiff == visible_wrap_offset)
	    col_lendiff = 0;

	  if (col_lendiff)
	    delete_chars (-col_lendiff); /* delete (diff) characters */

	  /* Copy (new) chars to screen from first diff to last match */
	  temp = nls - nfd;
	  if (temp > 0)
	    {
	      /* If nfd begins at the prompt, or before the invisible
		 characters in the prompt, we need to adjust _rl_last_c_pos
		 in a multibyte locale to account for the wrap offset and
		 set cpos_adjusted accordingly. */
	      _rl_output_some_chars (nfd, temp);
	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		{
		  _rl_last_c_pos += _rl_col_width (nfd, 0, temp, 1);
		  if (current_line == 0 && wrap_offset &&  ((nfd - new) <= prompt_last_invisible))
		    {
		      _rl_last_c_pos -= wrap_offset;
		      cpos_adjusted = 1;
		    }
		}
	      else
		_rl_last_c_pos += temp;
	    }
	}
      /* Otherwise, print over the existing material. */
      else
	{
	  if (temp > 0)
	    {
	      /* If nfd begins at the prompt, or before the invisible
		 characters in the prompt, we need to adjust _rl_last_c_pos
		 in a multibyte locale to account for the wrap offset and
		 set cpos_adjusted accordingly. */
	      _rl_output_some_chars (nfd, temp);
	      _rl_last_c_pos += col_temp;		/* XXX */
	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		{
		  if (current_line == 0 && wrap_offset &&  ((nfd - new) <= prompt_last_invisible))
		    {
		      _rl_last_c_pos -= wrap_offset;
		      cpos_adjusted = 1;
		    }
		}
	    }
	  lendiff = (oe - old) - (ne - new);
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    col_lendiff = _rl_col_width (old, 0, oe - old, 1) - _rl_col_width (new, 0, ne - new, 1);
	  else
	    col_lendiff = lendiff;

#if 0
	  if (col_lendiff)
#else
	  /* If we've already printed over the entire width of the screen,
	     including the old material, then col_lendiff doesn't matter and
	     space_to_eol will insert too many spaces.  XXX - maybe we should
	     adjust col_lendiff based on the difference between _rl_last_c_pos
	     and _rl_screenwidth */
	  if (col_lendiff && ((MB_CUR_MAX == 1 || rl_byte_oriented) || (_rl_last_c_pos < _rl_screenwidth)))
#endif
	    {	  
	      if (_rl_term_autowrap && current_line < inv_botlin)
		space_to_eol (col_lendiff);
	      else
		_rl_clear_to_eol (col_lendiff);
	    }
	}
    }
}

/* Tell the update routines that we have moved onto a new (empty) line. */
int
rl_on_new_line ()
{
  if (visible_line)
    visible_line[0] = '\0';

  _rl_last_c_pos = _rl_last_v_pos = 0;
  _rl_vis_botlin = last_lmargin = 0;
  if (vis_lbreaks)
    vis_lbreaks[0] = vis_lbreaks[1] = 0;
  visible_wrap_offset = 0;
  return 0;
}

/* Tell the update routines that we have moved onto a new line with the
   prompt already displayed.  Code originally from the version of readline
   distributed with CLISP.  rl_expand_prompt must have already been called
   (explicitly or implicitly).  This still doesn't work exactly right. */
int
rl_on_new_line_with_prompt ()
{
  int prompt_size, i, l, real_screenwidth, newlines;
  char *prompt_last_line, *lprompt;

  /* Initialize visible_line and invisible_line to ensure that they can hold
     the already-displayed prompt. */
  prompt_size = strlen (rl_prompt) + 1;
  init_line_structures (prompt_size);

  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
  strcpy (invisible_line, lprompt);

  /* If the prompt contains newlines, take the last tail. */
  prompt_last_line = strrchr (rl_prompt, '\n');
  if (!prompt_last_line)
    prompt_last_line = rl_prompt;

  l = strlen (prompt_last_line);
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    _rl_last_c_pos = _rl_col_width (prompt_last_line, 0, l, 1);	/* XXX */
  else
    _rl_last_c_pos = l;

  /* Dissect prompt_last_line into screen lines. Note that here we have
     to use the real screenwidth. Readline's notion of screenwidth might be
     one less, see terminal.c. */
  real_screenwidth = _rl_screenwidth + (_rl_term_autowrap ? 0 : 1);
  _rl_last_v_pos = l / real_screenwidth;
  /* If the prompt length is a multiple of real_screenwidth, we don't know
     whether the cursor is at the end of the last line, or already at the
     beginning of the next line. Output a newline just to be safe. */
  if (l > 0 && (l % real_screenwidth) == 0)
    _rl_output_some_chars ("\n", 1);
  last_lmargin = 0;

  newlines = 0; i = 0;
  while (i <= l)
    {
      _rl_vis_botlin = newlines;
      vis_lbreaks[newlines++] = i;
      i += real_screenwidth;
    }
  vis_lbreaks[newlines] = l;
  visible_wrap_offset = 0;

  rl_display_prompt = rl_prompt;	/* XXX - make sure it's set */

  return 0;
}

/* Actually update the display, period. */
int
rl_forced_update_display ()
{
  register char *temp;

  if (visible_line)
    {
      temp = visible_line;
      while (*temp)
	*temp++ = '\0';
    }
  rl_on_new_line ();
  forced_display++;
  (*rl_redisplay_function) ();
  return 0;
}

/* Move the cursor from _rl_last_c_pos to NEW, which are buffer indices.
   (Well, when we don't have multibyte characters, _rl_last_c_pos is a
   buffer index.)
   DATA is the contents of the screen line of interest; i.e., where
   the movement is being done. */
void
_rl_move_cursor_relative (new, data)
     int new;
     const char *data;
{
  register int i;
  int woff;			/* number of invisible chars on current line */
  int cpos, dpos;		/* current and desired cursor positions */
  int adjust;

  woff = WRAP_OFFSET (_rl_last_v_pos, wrap_offset);
  cpos = _rl_last_c_pos;

  if (cpos == 0 && cpos == new)
    return;

#if defined (HANDLE_MULTIBYTE)
  /* If we have multibyte characters, NEW is indexed by the buffer point in
     a multibyte string, but _rl_last_c_pos is the display position.  In
     this case, NEW's display position is not obvious and must be
     calculated.  We need to account for invisible characters in this line,
     as long as we are past them and they are counted by _rl_col_width. */
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      adjust = 1;
      /* Try to short-circuit common cases and eliminate a bunch of multibyte
	 character function calls. */
      /* 1.  prompt string */
      if (new == local_prompt_len && memcmp (data, local_prompt, new) == 0)
	{
	  dpos = prompt_physical_chars;
	  cpos_adjusted = 1;
	  adjust = 0;
	}
      /* 2.  prompt_string + line contents */
      else if (new > local_prompt_len && local_prompt && memcmp (data, local_prompt, local_prompt_len) == 0)
	{
	  dpos = prompt_physical_chars + _rl_col_width (data, local_prompt_len, new, 1);
	  cpos_adjusted = 1;
	  adjust = 0;
	}
      else
        dpos = _rl_col_width (data, 0, new, 1);

      /* Use NEW when comparing against the last invisible character in the
	 prompt string, since they're both buffer indices and DPOS is a
	 desired display position. */
      if (adjust && ((new > prompt_last_invisible) ||		/* XXX - don't use woff here */
	  (prompt_physical_chars >= _rl_screenwidth &&
	   _rl_last_v_pos == prompt_last_screen_line &&
	   wrap_offset >= woff && dpos >= woff &&
	   new > (prompt_last_invisible-(_rl_screenwidth*_rl_last_v_pos)-wrap_offset))))
	   /* XXX last comparison might need to be >= */
	{
	  dpos -= woff;
	  /* Since this will be assigned to _rl_last_c_pos at the end (more
	     precisely, _rl_last_c_pos == dpos when this function returns),
	     let the caller know. */
	  cpos_adjusted = 1;
	}
    }
  else
#endif
    dpos = new;

  /* If we don't have to do anything, then return. */
  if (cpos == dpos)
    return;

  /* It may be faster to output a CR, and then move forwards instead
     of moving backwards. */
  /* i == current physical cursor position. */
#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    i = _rl_last_c_pos;
  else
#endif
  i = _rl_last_c_pos - woff;
  if (dpos == 0 || CR_FASTER (dpos, _rl_last_c_pos) ||
      (_rl_term_autowrap && i == _rl_screenwidth))
    {
#if defined (__MSDOS__)
      putc ('\r', rl_outstream);
#else
      tputs (_rl_term_cr, 1, _rl_output_character_function);
#endif /* !__MSDOS__ */
      cpos = _rl_last_c_pos = 0;
    }

  if (cpos < dpos)
    {
      /* Move the cursor forward.  We do it by printing the command
	 to move the cursor forward if there is one, else print that
	 portion of the output buffer again.  Which is cheaper? */

      /* The above comment is left here for posterity.  It is faster
	 to print one character (non-control) than to print a control
	 sequence telling the terminal to move forward one character.
	 That kind of control is for people who don't know what the
	 data is underneath the cursor. */

      /* However, we need a handle on where the current display position is
	 in the buffer for the immediately preceding comment to be true.
	 In multibyte locales, we don't currently have that info available.
	 Without it, we don't know where the data we have to display begins
	 in the buffer and we have to go back to the beginning of the screen
	 line.  In this case, we can use the terminal sequence to move forward
	 if it's available. */
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  if (_rl_term_forward_char)
	    {
	      for (i = cpos; i < dpos; i++)
	        tputs (_rl_term_forward_char, 1, _rl_output_character_function);
	    }
	  else
	    {
	      tputs (_rl_term_cr, 1, _rl_output_character_function);
	      for (i = 0; i < new; i++)
		putc (data[i], rl_outstream);
	    }
	}
      else
	for (i = cpos; i < new; i++)
	  putc (data[i], rl_outstream);
    }

#if defined (HANDLE_MULTIBYTE)
  /* NEW points to the buffer point, but _rl_last_c_pos is the display point.
     The byte length of the string is probably bigger than the column width
     of the string, which means that if NEW == _rl_last_c_pos, then NEW's
     display point is less than _rl_last_c_pos. */
#endif
  else if (cpos > dpos)
    _rl_backspace (cpos - dpos);

  _rl_last_c_pos = dpos;
}

/* PWP: move the cursor up or down. */
void
_rl_move_vert (to)
     int to;
{
  register int delta, i;

  if (_rl_last_v_pos == to || to > _rl_screenheight)
    return;

  if ((delta = to - _rl_last_v_pos) > 0)
    {
      for (i = 0; i < delta; i++)
	putc ('\n', rl_outstream);
#if defined (__MSDOS__)
      putc ('\r', rl_outstream);
#else
      tputs (_rl_term_cr, 1, _rl_output_character_function);
#endif
      _rl_last_c_pos = 0;
    }
  else
    {			/* delta < 0 */
#ifdef __MSDOS__
      int row, col;

      fflush (rl_outstream); /* make sure the cursor pos is current! */
      ScreenGetCursor (&row, &col);
      ScreenSetCursor (row + delta, col);
      i = -delta;    /* in case someone wants to use it after the loop */
#else /* !__MSDOS__ */
      if (_rl_term_up && *_rl_term_up)
	for (i = 0; i < -delta; i++)
	  tputs (_rl_term_up, 1, _rl_output_character_function);
#endif /* !__MSDOS__ */
    }

  _rl_last_v_pos = to;		/* Now TO is here */
}

/* Physically print C on rl_outstream.  This is for functions which know
   how to optimize the display.  Return the number of characters output. */
int
rl_show_char (c)
     int c;
{
  int n = 1;
  if (META_CHAR (c) && (_rl_output_meta_chars == 0))
    {
      fprintf (rl_outstream, "M-");
      n += 2;
      c = UNMETA (c);
    }

#if defined (DISPLAY_TABS)
  if ((CTRL_CHAR (c) && c != '\t') || c == RUBOUT)
#else
  if (CTRL_CHAR (c) || c == RUBOUT)
#endif /* !DISPLAY_TABS */
    {
      fprintf (rl_outstream, "C-");
      n += 2;
      c = CTRL_CHAR (c) ? UNCTRL (c) : '?';
    }

  putc (c, rl_outstream);
  fflush (rl_outstream);
  return n;
}

int
rl_character_len (c, pos)
     register int c, pos;
{
  unsigned char uc;

  uc = (unsigned char)c;

  if (META_CHAR (uc))
    return ((_rl_output_meta_chars == 0) ? 4 : 1);

  if (uc == '\t')
    {
#if defined (DISPLAY_TABS)
      return (((pos | 7) + 1) - pos);
#else
      return (2);
#endif /* !DISPLAY_TABS */
    }

  if (CTRL_CHAR (c) || c == RUBOUT)
    return (2);

  return ((ISPRINT (uc)) ? 1 : 2);
}
/* How to print things in the "echo-area".  The prompt is treated as a
   mini-modeline. */
static int msg_saved_prompt = 0;

#if defined (USE_VARARGS)
int
#if defined (PREFER_STDARG)
rl_message (const char *format, ...)
#else
rl_message (va_alist)
     va_dcl
#endif
{
  va_list args;
#if defined (PREFER_VARARGS)
  char *format;
#endif

#if defined (PREFER_STDARG)
  va_start (args, format);
#else
  va_start (args);
  format = va_arg (args, char *);
#endif

#if defined (HAVE_VSNPRINTF)
  vsnprintf (msg_buf, sizeof (msg_buf) - 1, format, args);
#else
  vsprintf (msg_buf, format, args);
  msg_buf[sizeof(msg_buf) - 1] = '\0';	/* overflow? */
#endif
  va_end (args);

  if (saved_local_prompt == 0)
    {
      rl_save_prompt ();
      msg_saved_prompt = 1;
    }
  rl_display_prompt = msg_buf;
  local_prompt = expand_prompt (msg_buf, &prompt_visible_length,
					 &prompt_last_invisible,
					 &prompt_invis_chars_first_line,
					 &prompt_physical_chars);
  local_prompt_prefix = (char *)NULL;
  local_prompt_len = local_prompt ? strlen (local_prompt) : 0;
  (*rl_redisplay_function) ();

  return 0;
}
#else /* !USE_VARARGS */
int
rl_message (format, arg1, arg2)
     char *format;
{
  sprintf (msg_buf, format, arg1, arg2);
  msg_buf[sizeof(msg_buf) - 1] = '\0';	/* overflow? */

  rl_display_prompt = msg_buf;
  if (saved_local_prompt == 0)
    {
      rl_save_prompt ();
      msg_saved_prompt = 1;
    }
  local_prompt = expand_prompt (msg_buf, &prompt_visible_length,
					 &prompt_last_invisible,
					 &prompt_invis_chars_first_line,
					 &prompt_physical_chars);
  local_prompt_prefix = (char *)NULL;
  local_prompt_len = local_prompt ? strlen (local_prompt) : 0;
  (*rl_redisplay_function) ();
      
  return 0;
}
#endif /* !USE_VARARGS */

/* How to clear things from the "echo-area". */
int
rl_clear_message ()
{
  rl_display_prompt = rl_prompt;
  if (msg_saved_prompt)
    {
      rl_restore_prompt ();
      msg_saved_prompt = 0;
    }
  (*rl_redisplay_function) ();
  return 0;
}

int
rl_reset_line_state ()
{
  rl_on_new_line ();

  rl_display_prompt = rl_prompt ? rl_prompt : "";
  forced_display = 1;
  return 0;
}

void
rl_save_prompt ()
{
  saved_local_prompt = local_prompt;
  saved_local_prefix = local_prompt_prefix;
  saved_prefix_length = prompt_prefix_length;
  saved_local_length = local_prompt_len;
  saved_last_invisible = prompt_last_invisible;
  saved_visible_length = prompt_visible_length;
  saved_invis_chars_first_line = prompt_invis_chars_first_line;
  saved_physical_chars = prompt_physical_chars;

  local_prompt = local_prompt_prefix = (char *)0;
  local_prompt_len = 0;
  prompt_last_invisible = prompt_visible_length = prompt_prefix_length = 0;
  prompt_invis_chars_first_line = prompt_physical_chars = 0;
}

void
rl_restore_prompt ()
{
  FREE (local_prompt);
  FREE (local_prompt_prefix);

  local_prompt = saved_local_prompt;
  local_prompt_prefix = saved_local_prefix;
  local_prompt_len = saved_local_length;
  prompt_prefix_length = saved_prefix_length;
  prompt_last_invisible = saved_last_invisible;
  prompt_visible_length = saved_visible_length;
  prompt_invis_chars_first_line = saved_invis_chars_first_line;
  prompt_physical_chars = saved_physical_chars;

  /* can test saved_local_prompt to see if prompt info has been saved. */
  saved_local_prompt = saved_local_prefix = (char *)0;
  saved_local_length = 0;
  saved_last_invisible = saved_visible_length = saved_prefix_length = 0;
  saved_invis_chars_first_line = saved_physical_chars = 0;
}

char *
_rl_make_prompt_for_search (pchar)
     int pchar;
{
  int len;
  char *pmt, *p;

  rl_save_prompt ();

  /* We've saved the prompt, and can do anything with the various prompt
     strings we need before they're restored.  We want the unexpanded
     portion of the prompt string after any final newline. */
  p = rl_prompt ? strrchr (rl_prompt, '\n') : 0;
  if (p == 0)
    {
      len = (rl_prompt && *rl_prompt) ? strlen (rl_prompt) : 0;
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, rl_prompt);
      pmt[len] = pchar;
      pmt[len+1] = '\0';
    }
  else
    {
      p++;
      len = strlen (p);
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, p);
      pmt[len] = pchar;
      pmt[len+1] = '\0';
    }  

  /* will be overwritten by expand_prompt, called from rl_message */
  prompt_physical_chars = saved_physical_chars + 1;
  return pmt;
}

/* Quick redisplay hack when erasing characters at the end of the line. */
void
_rl_erase_at_end_of_line (l)
     int l;
{
  register int i;

  _rl_backspace (l);
  for (i = 0; i < l; i++)
    putc (' ', rl_outstream);
  _rl_backspace (l);
  for (i = 0; i < l; i++)
    visible_line[--_rl_last_c_pos] = '\0';
  rl_display_fixed++;
}

/* Clear to the end of the line.  COUNT is the minimum
   number of character spaces to clear, */
void
_rl_clear_to_eol (count)
     int count;
{
#ifndef __MSDOS__
  if (_rl_term_clreol)
    tputs (_rl_term_clreol, 1, _rl_output_character_function);
  else
#endif
  if (count)
    space_to_eol (count);
}

/* Clear to the end of the line using spaces.  COUNT is the minimum
   number of character spaces to clear, */
static void
space_to_eol (count)
     int count;
{
  register int i;

  for (i = 0; i < count; i++)
   putc (' ', rl_outstream);

  _rl_last_c_pos += count;
}

void
_rl_clear_screen ()
{
#if defined (__GO32__)
  ScreenClear ();	/* FIXME: only works in text modes */
  ScreenSetCursor (0, 0);  /* term_clrpag is "cl" which homes the cursor */
#else
  if (_rl_term_clrpag)
    tputs (_rl_term_clrpag, 1, _rl_output_character_function);
  else
    rl_crlf ();
#endif
}

/* Insert COUNT characters from STRING to the output stream at column COL. */
static void
insert_some_chars (string, count, col)
     char *string;
     int count, col;
{
#if defined (__MSDOS__) || defined (__MINGW32__)
  _rl_output_some_chars (string, count);
#else
  /* DEBUGGING */
  if (MB_CUR_MAX == 1 || rl_byte_oriented)
    if (count != col)
      _rl_ttymsg ("debug: insert_some_chars: count (%d) != col (%d)", count, col);

  /* If IC is defined, then we do not have to "enter" insert mode. */
  if (_rl_term_IC)
    {
      char *buffer;

      buffer = tgoto (_rl_term_IC, 0, col);
      tputs (buffer, 1, _rl_output_character_function);
      _rl_output_some_chars (string, count);
    }
  else
    {
      register int i;

      /* If we have to turn on insert-mode, then do so. */
      if (_rl_term_im && *_rl_term_im)
	tputs (_rl_term_im, 1, _rl_output_character_function);

      /* If there is a special command for inserting characters, then
	 use that first to open up the space. */
      if (_rl_term_ic && *_rl_term_ic)
	{
	  for (i = col; i--; )
	    tputs (_rl_term_ic, 1, _rl_output_character_function);
	}

      /* Print the text. */
      _rl_output_some_chars (string, count);

      /* If there is a string to turn off insert mode, we had best use
	 it now. */
      if (_rl_term_ei && *_rl_term_ei)
	tputs (_rl_term_ei, 1, _rl_output_character_function);
    }
#endif /* __MSDOS__ || __MINGW32__ */
}

/* Delete COUNT characters from the display line. */
static void
delete_chars (count)
     int count;
{
  if (count > _rl_screenwidth)	/* XXX */
    return;

#if !defined (__MSDOS__) && !defined (__MINGW32__)
  if (_rl_term_DC && *_rl_term_DC)
    {
      char *buffer;
      buffer = tgoto (_rl_term_DC, count, count);
      tputs (buffer, count, _rl_output_character_function);
    }
  else
    {
      if (_rl_term_dc && *_rl_term_dc)
	while (count--)
	  tputs (_rl_term_dc, 1, _rl_output_character_function);
    }
#endif /* !__MSDOS__ && !__MINGW32__ */
}

void
_rl_update_final ()
{
  int full_lines;

  full_lines = 0;
  /* If the cursor is the only thing on an otherwise-blank last line,
     compensate so we don't print an extra CRLF. */
  if (_rl_vis_botlin && _rl_last_c_pos == 0 &&
	visible_line[vis_lbreaks[_rl_vis_botlin]] == 0)
    {
      _rl_vis_botlin--;
      full_lines = 1;
    }
  _rl_move_vert (_rl_vis_botlin);
  /* If we've wrapped lines, remove the final xterm line-wrap flag. */
  if (full_lines && _rl_term_autowrap && (VIS_LLEN(_rl_vis_botlin) == _rl_screenwidth))
    {
      char *last_line;

      last_line = &visible_line[vis_lbreaks[_rl_vis_botlin]];
      cpos_buffer_position = -1;	/* don't know where we are in buffer */
      _rl_move_cursor_relative (_rl_screenwidth - 1, last_line);	/* XXX */
      _rl_clear_to_eol (0);
      putc (last_line[_rl_screenwidth - 1], rl_outstream);
    }
  _rl_vis_botlin = 0;
  rl_crlf ();
  fflush (rl_outstream);
  rl_display_fixed++;
}

/* Move to the start of the current line. */
static void
cr ()
{
  if (_rl_term_cr)
    {
#if defined (__MSDOS__)
      putc ('\r', rl_outstream);
#else
      tputs (_rl_term_cr, 1, _rl_output_character_function);
#endif
      _rl_last_c_pos = 0;
    }
}

/* Redraw the last line of a multi-line prompt that may possibly contain
   terminal escape sequences.  Called with the cursor at column 0 of the
   line to draw the prompt on. */
static void
redraw_prompt (t)
     char *t;
{
  char *oldp;

  oldp = rl_display_prompt;
  rl_save_prompt ();

  rl_display_prompt = t;
  local_prompt = expand_prompt (t, &prompt_visible_length,
				   &prompt_last_invisible,
				   &prompt_invis_chars_first_line,
				   &prompt_physical_chars);
  local_prompt_prefix = (char *)NULL;
  local_prompt_len = local_prompt ? strlen (local_prompt) : 0;

  rl_forced_update_display ();

  rl_display_prompt = oldp;
  rl_restore_prompt();
}
      
/* Redisplay the current line after a SIGWINCH is received. */
void
_rl_redisplay_after_sigwinch ()
{
  char *t;

  /* Clear the last line (assuming that the screen size change will result in
     either more or fewer characters on that line only) and put the cursor at
     column 0.  Make sure the right thing happens if we have wrapped to a new
     screen line. */
  if (_rl_term_cr)
    {
      _rl_move_vert (_rl_vis_botlin);

#if defined (__MSDOS__)
      putc ('\r', rl_outstream);
#else
      tputs (_rl_term_cr, 1, _rl_output_character_function);
#endif
      _rl_last_c_pos = 0;
#if defined (__MSDOS__)
      space_to_eol (_rl_screenwidth);
      putc ('\r', rl_outstream);
#else
      if (_rl_term_clreol)
	tputs (_rl_term_clreol, 1, _rl_output_character_function);
      else
	{
	  space_to_eol (_rl_screenwidth);
	  tputs (_rl_term_cr, 1, _rl_output_character_function);
	}
#endif
      if (_rl_last_v_pos > 0)
	_rl_move_vert (0);
    }
  else
    rl_crlf ();

  /* Redraw only the last line of a multi-line prompt. */
  t = strrchr (rl_display_prompt, '\n');
  if (t)
    redraw_prompt (++t);
  else
    rl_forced_update_display ();
}

void
_rl_clean_up_for_exit ()
{
  if (_rl_echoing_p)
    {
      _rl_move_vert (_rl_vis_botlin);
      _rl_vis_botlin = 0;
      fflush (rl_outstream);
      rl_restart_output (1, 0);
    }
}

void
_rl_erase_entire_line ()
{
  cr ();
  _rl_clear_to_eol (0);
  cr ();
  fflush (rl_outstream);
}

/* return the `current display line' of the cursor -- the number of lines to
   move up to get to the first screen line of the current readline line. */
int
_rl_current_display_line ()
{
  int ret, nleft;

  /* Find out whether or not there might be invisible characters in the
     editing buffer. */
  if (rl_display_prompt == rl_prompt)
    nleft = _rl_last_c_pos - _rl_screenwidth - rl_visible_prompt_length;
  else
    nleft = _rl_last_c_pos - _rl_screenwidth;

  if (nleft > 0)
    ret = 1 + nleft / _rl_screenwidth;
  else
    ret = 0;

  return ret;
}

#if defined (HANDLE_MULTIBYTE)
/* Calculate the number of screen columns occupied by STR from START to END.
   In the case of multibyte characters with stateful encoding, we have to
   scan from the beginning of the string to take the state into account. */
static int
_rl_col_width (str, start, end, flags)
     const char *str;
     int start, end, flags;
{
  wchar_t wc;
  mbstate_t ps;
  int tmp, point, width, max;

  if (end <= start)
    return 0;
  if (MB_CUR_MAX == 1 || rl_byte_oriented)
{
_rl_ttymsg ("_rl_col_width: called with MB_CUR_MAX == 1");
    return (end - start);
}

  memset (&ps, 0, sizeof (mbstate_t));

  point = 0;
  max = end;

  /* Try to short-circuit common cases.  The adjustment to remove wrap_offset
     is done by the caller. */
  /* 1.  prompt string */
  if (flags && start == 0 && end == local_prompt_len && memcmp (str, local_prompt, local_prompt_len) == 0)
    return (prompt_physical_chars + wrap_offset);
  /* 2.  prompt string + line contents */
  else if (flags && start == 0 && local_prompt_len > 0 && end > local_prompt_len && local_prompt && memcmp (str, local_prompt, local_prompt_len) == 0)
    {
      tmp = prompt_physical_chars + wrap_offset;
      /* XXX - try to call ourselves recursively with non-prompt portion */
      tmp += _rl_col_width (str, local_prompt_len, end, flags);
      return (tmp);
    }

  while (point < start)
    {
      tmp = mbrlen (str + point, max, &ps);
      if (MB_INVALIDCH ((size_t)tmp))
	{
	  /* In this case, the bytes are invalid or too short to compose a
	     multibyte character, so we assume that the first byte represents
	     a single character. */
	  point++;
	  max--;

	  /* Clear the state of the byte sequence, because in this case the
	     effect of mbstate is undefined. */
	  memset (&ps, 0, sizeof (mbstate_t));
	}
      else if (MB_NULLWCH (tmp))
	break;		/* Found '\0' */
      else
	{
	  point += tmp;
	  max -= tmp;
	}
    }

  /* If START is not a byte that starts a character, then POINT will be
     greater than START.  In this case, assume that (POINT - START) gives
     a byte count that is the number of columns of difference. */
  width = point - start;

  while (point < end)
    {
      tmp = mbrtowc (&wc, str + point, max, &ps);
      if (MB_INVALIDCH ((size_t)tmp))
	{
	  /* In this case, the bytes are invalid or too short to compose a
	     multibyte character, so we assume that the first byte represents
	     a single character. */
	  point++;
	  max--;

	  /* and assume that the byte occupies a single column. */
	  width++;

	  /* Clear the state of the byte sequence, because in this case the
	     effect of mbstate is undefined. */
	  memset (&ps, 0, sizeof (mbstate_t));
	}
      else if (MB_NULLWCH (tmp))
	break;			/* Found '\0' */
      else
	{
	  point += tmp;
	  max -= tmp;
	  tmp = wcwidth(wc);
	  width += (tmp >= 0) ? tmp : 1;
	}
    }

  width += point - end;

  return width;
}
#endif /* HANDLE_MULTIBYTE */
@


1.12
log
@	PR gdb/544
	* rltty.c (block_sigint, release_sigint): Rename to...
	(_rl_block_sigint, _rl_release_sigint): ...these and make them global.
	* rltty.h (_rl_block_sigint, _rl_release_sigint): New prototypes.
	* display.c (rl_redisplay): Wrap the function by the calls to
	_RL_BLOCK_SIGINT and _RL_RELEASE_SIGINT.
@
text
@d3 1
a3 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
d5 2
a6 2
   This file is part of the GNU Readline Library, a library for
   reading lines of text with interactive input and history editing.
d8 3
a10 3
   The GNU Readline Library is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2, or
d13 3
a15 3
   The GNU Readline Library is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
d18 4
a21 4
   The GNU General Public License is often shipped with GNU software, and
   is generally kept in a file called COPYING or LICENSE.  If you do not
   have a copy of the license, write to the Free Software Foundation,
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
a65 4
#if defined (HACK_TERMCAP_MOTION)
extern char *_rl_term_forward_char;
#endif

d72 28
d101 1
a101 2
static int _rl_col_width PARAMS((const char *, int, int));
static int *_rl_wrapped_line;
d103 1
a103 1
#  define _rl_col_width(l, s, e)	(((e) <= (s)) ? 0 : (e) - (s))
a105 3
static int *inv_lbreaks, *vis_lbreaks;
static int inv_lbsize, vis_lbsize;

d107 2
a108 1
   by backing up or outputting a carriage return and moving forward. */
d111 8
d171 2
a181 5
/* The line display buffers.  One is the line currently displayed on
   the screen.  The other is the line about to be displayed. */
static char *visible_line = (char *)NULL;
static char *invisible_line = (char *)NULL;

d195 1
d222 4
d235 1
d259 1
a259 1
  char *r, *ret, *p;
d283 1
d288 1
a288 1
      if (*p == RL_PROMPT_START_IGNORE)
d290 2
a291 1
	  ignoring++;
d297 1
a297 1
	  if (p[-1] != RL_PROMPT_START_IGNORE)
d313 5
d319 1
a319 1
		  physchars += _rl_col_width (pmt, pind, ind);
d402 1
d418 1
d427 1
a427 1
				       (int *)NULL,
d434 1
a434 1
						   &prompt_invis_chars_first_line,
d437 1
d479 9
a489 3
#if defined (HANDLE_MULTIBYTE)
      _rl_wrapped_line = (int *)xmalloc (vis_lbsize * sizeof (int));
#endif
d492 2
d502 2
a503 2
  int c_pos, inv_botlin, lb_botlin, lb_linenum, o_cpos;
  int newlines, lpos, temp, modmark, n0, num;
d513 1
a513 1
  if (!readline_echoing_p)
d516 4
a519 3
  /* Signals are blocked through this function as the global data structures
     could get corrupted upon modifications from an invoked signal handler. */
  _rl_block_sigint ();
d524 1
a524 1
  if (invisible_line == 0 || vis_lbreaks == 0)
d531 3
a533 1
  c_pos = -1;
a559 1
      int local_len = local_prompt ? strlen (local_prompt) : 0;
d563 1
a563 1
      if (local_len > 0)
d565 1
a565 1
	  temp = local_len + out + 2;
d572 2
a573 2
	  strncpy (line + out, local_prompt, local_len);
	  out += local_len;
d576 1
a576 1
      wrap_offset = local_len - prompt_visible_length;
a630 1
		_rl_wrapped_line = (int *)xrealloc (_rl_wrapped_line, inv_lbsize * sizeof (int)); \
d633 6
a638 1
	    _rl_wrapped_line[newlines] = _rl_wrapped_multicolumn; \
a660 3
#if 0
  lpos = out - wrap_offset;
#else
a661 1
#endif
d664 1
a664 1
  memset (_rl_wrapped_line, 0, vis_lbsize);
d671 4
a674 1
     chars on the second line. */
d680 1
d689 1
a689 3
      n0 = num;
      temp = local_prompt ? strlen (local_prompt) : 0;
      while (num < temp)
d691 3
a693 1
	  if (_rl_col_width  (local_prompt, n0, num) > _rl_screenwidth)
d695 9
a703 2
	      num = _rl_find_prev_mbchar (local_prompt, num, MB_FIND_ANY);
	      break;
d705 1
a705 1
	  num++;
d707 1
a707 3
      temp = num +
#else
      temp = ((newlines + 1) * _rl_screenwidth) +
d709 8
a716 3
             ((local_prompt_prefix == 0) ? ((newlines == 0) ? prompt_invis_chars_first_line
							    : ((newlines == 1) ? wrap_offset : 0))
					 : ((newlines == 0) ? wrap_offset :0));
d720 3
a722 3
      lpos -= _rl_col_width (local_prompt, n0, num);
#else
      lpos -= _rl_screenwidth;
d724 1
d730 1
a730 1
     track of where the cursor is (c_pos), the number of the line containing
d740 1
d784 1
a784 1
	  c_pos = out;
d878 1
a878 1
		  c_pos = out;
d901 1
d910 1
a910 1
  if (c_pos < 0)
d912 1
a912 1
      c_pos = out;
d921 1
a921 1
  /* C_POS == position in buffer where cursor should be placed.
d956 4
d967 5
d975 2
d986 1
a986 1
		 change update_line itself.  There is one case in which
d989 13
a1001 7
		 this back by setting cpos_adjusted */
	      if (linenum == 0 && (MB_CUR_MAX > 1 && rl_byte_oriented == 0) &&
		  cpos_adjusted == 0 &&
		  _rl_last_c_pos != o_cpos &&
		  _rl_last_c_pos > wrap_offset &&
		  o_cpos < prompt_last_invisible)
		_rl_last_c_pos -= wrap_offset;
d1021 13
d1077 5
a1081 1
	      _rl_last_c_pos <= prompt_last_invisible && local_prompt)
d1089 3
d1094 1
a1094 1
		_rl_last_c_pos = _rl_col_width (local_prompt, 0, nleft) - wrap_offset;
d1096 1
a1096 1
		_rl_last_c_pos = nleft;
d1103 2
a1104 2
	     start of the line and the cursor position. */
	  nleft = c_pos - pos;
d1116 1
d1118 1
a1118 1
		tx = _rl_col_width (&visible_line[pos], 0, nleft) - visible_wrap_offset;
d1121 1
a1121 1
	      if (_rl_last_c_pos > tx)
d1150 1
a1150 1
      ndisp = c_pos - wrap_offset;
d1154 1
a1154 1
      phys_c_pos = c_pos - (last_lmargin ? last_lmargin : wrap_offset);
d1165 1
a1165 1
	  lmargin = c_pos - (2 * t);
d1179 1
a1179 1
	  lmargin = ((c_pos - 1) / t) * t;	/* XXX */
d1199 1
a1199 1
      if (!rl_display_fixed || forced_display || lmargin != last_lmargin)
d1202 2
d1211 3
d1229 1
a1229 1
	  _rl_move_cursor_relative (c_pos - lmargin, &invisible_line[lmargin]);
d1237 1
a1237 2
    char *vtemp = visible_line;
    int *itemp = vis_lbreaks, ntemp = vis_lbsize;
d1239 2
a1240 8
    visible_line = invisible_line;
    invisible_line = vtemp;

    vis_lbreaks = inv_lbreaks;
    inv_lbreaks = itemp;

    vis_lbsize = inv_lbsize;
    inv_lbsize = ntemp;
d1252 1
d1278 1
a1278 1
  int temp, lendiff, wsatend, od, nd;
d1283 1
a1283 1
  int new_offset, old_offset, tmp;
d1294 1
a1294 1
    temp = _rl_last_c_pos - W_OFFSET(_rl_last_v_pos, visible_wrap_offset);
d1309 2
a1310 2
	  if (_rl_wrapped_line[current_line] > 0)
	    _rl_clear_to_eol (_rl_wrapped_line[current_line]);
d1326 1
a1326 1
	      int count;
d1337 2
a1338 3
		    memmove (old+bytes, old+1, strlen (old+1));
		  else
		    memmove (old+bytes, old+ret, strlen (old+ret));
d1340 4
d1377 1
a1377 1
      if (memcmp (old, new, temp) == 0)
d1519 1
a1519 1
  lendiff = local_prompt ? strlen (local_prompt) : 0;
d1523 1
a1523 1
      od >= lendiff && _rl_last_c_pos <= prompt_last_invisible)
d1530 2
d1537 1
a1537 1
	  _rl_last_c_pos = _rl_col_width (local_prompt, 0, lendiff) - wrap_offset;
d1541 1
a1541 1
	_rl_last_c_pos = lendiff;
d1544 5
d1550 11
d1568 1
a1568 1
    col_lendiff = _rl_col_width (new, nfd - new, nls - new) - _rl_col_width (old, ofd - old, ols - old);
d1593 1
a1593 1
    col_temp = _rl_col_width (new, nfd - new, ne - new);
d1601 20
d1625 1
a1625 1
      if (_rl_terminal_can_insert && ((2 * col_temp) >= col_lendiff || _rl_term_IC) && (!_rl_term_autowrap || !gl))
d1631 13
a1643 2
	  if (*ols && (!_rl_horizontal_scroll_mode || _rl_last_c_pos > 0 ||
			lendiff <= prompt_visible_length || !current_invis_chars))
d1648 7
a1665 3
	      /* We have horizontal scrolling and we are not inserting at
		 the end.  We have invisible characters in this line.  This
		 is a dumb update. */
d1668 8
a1682 1
#if 1
d1687 13
a1699 4
	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-col_lendiff);
#else
	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-lendiff);
#endif
d1711 8
d1740 4
d1745 11
a1755 1
	      _rl_last_c_pos += _rl_col_width (nfd, 0, temp);;
d1763 4
d1769 8
d1780 1
a1780 1
	    col_lendiff = _rl_col_width (old, 0, oe - old) - _rl_col_width (new, 0, ne - new);
d1784 1
d1786 8
d1847 1
a1847 1
    _rl_last_c_pos = _rl_col_width (prompt_last_line, 0, l);	/* XXX */
d1882 2
d1886 1
a1886 2
      register char *temp = visible_line;

d1909 1
d1911 1
a1911 1
  woff = W_OFFSET (_rl_last_v_pos, wrap_offset);
d1913 4
d1925 36
a1960 3
      dpos = _rl_col_width (data, 0, new);
      if (dpos > woff)
	dpos -= woff;
d1979 1
a1979 1
  if (new == 0 || CR_FASTER (new, _rl_last_c_pos) ||
d2001 8
a2008 8
#if defined (HACK_TERMCAP_MOTION)
      if (_rl_term_forward_char)
	{
	  for (i = cpos; i < dpos; i++)
	    tputs (_rl_term_forward_char, 1, _rl_output_character_function);
	}
      else
#endif /* HACK_TERMCAP_MOTION */
d2011 11
a2021 3
	  tputs (_rl_term_cr, 1, _rl_output_character_function);
	  for (i = 0; i < new; i++)
	    putc (data[i], rl_outstream);
d2179 1
d2203 1
d2240 1
d2247 1
d2260 1
d2269 1
d2383 1
a2383 1
      fprintf(stderr, "readline: debug: insert_some_chars: count (%d) != col (%d)\n", count, col);
d2466 2
a2467 1
      _rl_move_cursor_relative (_rl_screenwidth - 1, last_line);
d2510 1
d2524 4
a2527 2
  /* Clear the current line and put the cursor at column 0.  Make sure
     the right thing happens if we have wrapped to a new screen line. */
d2530 2
d2567 1
a2567 1
  if (readline_echoing_p)
d2612 1
a2612 1
_rl_col_width (str, start, end)
d2614 1
a2614 1
     int start, end;
d2617 1
a2617 1
  mbstate_t ps = {0};
d2622 7
d2633 14
@


1.11
log
@Readline 5.1 import for HEAD.
@
text
@d466 4
d1146 2
@


1.10
log
@touched all sources to ease import of readline-5.1
@
text
@d3 1
a3 1
/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
d125 1
d132 1
d134 4
d141 2
d193 14
d212 2
a213 1
   the first prompt line. */
d223 1
a223 1
expand_prompt (pmt, lp, lip, niflp)
d225 1
a225 1
     int *lp, *lip, *niflp;
d228 1
a228 1
  int l, rl, last, ignoring, ninvis, invfl;
d231 1
a231 1
  if (strchr (pmt, RL_PROMPT_START_IGNORE) == 0)
d236 6
d249 1
d251 1
a251 1
  for (rl = ignoring = last = ninvis = 0, p = pmt; p && *p; p++)
d263 2
a264 1
	  last = r - ret - 1;
d269 17
a285 3
	  *r++ = *p;
	  if (!ignoring)
	    rl++;
d287 17
a303 3
	    ninvis++;
	  if (rl == _rl_screenwidth)
	    invfl = ninvis;
d317 2
d330 1
a330 1
  ret = expand_prompt (pmt, (int *)NULL, (int *)NULL, (int *)NULL);
d363 2
a364 1
  prompt_last_invisible = prompt_visible_length = 0;
d375 2
a376 1
					    &prompt_invis_chars_first_line);
d386 2
a387 1
				       &prompt_invis_chars_first_line);
d393 2
a394 1
						   &prompt_invis_chars_first_line);
d452 2
a453 2
  int c_pos, inv_botlin, lb_botlin, lb_linenum;
  int newlines, lpos, temp;
d469 1
a469 1
  if (invisible_line == 0)
d483 1
d488 1
d542 1
a542 1
      pmtlen = strlen (prompt_this_line);
d601 1
d603 4
d609 1
d626 16
a641 1
         prompts that exceed two physical lines? */
d643 8
a650 2
#if 0
             ((newlines == 0) ? prompt_invis_chars_first_line : 0) +
d652 1
a652 1
             ((newlines == 0 && local_prompt_prefix == 0) ? prompt_invis_chars_first_line : 0) +
a653 4
             ((newlines == 1) ? wrap_offset : 0);

      inv_lbreaks[++newlines] = temp;
      lpos -= _rl_screenwidth;
d683 1
a683 1
	  if (wc_bytes == (size_t)-1 || wc_bytes == (size_t)-2)
d692 1
a692 1
	  else if (wc_bytes == (size_t)0)
d697 1
a697 1
	      wc_width = (temp < 0) ? 1 : temp;
d862 1
a862 1
      int nleft, pos, changed_screen_line;
d893 2
d898 15
d924 4
a927 1
		  nleft = _rl_screenwidth + wrap_offset - _rl_last_c_pos;
d963 1
a963 1
	      if (cursor_linenum == 0 && wrap_offset)
d984 1
a984 1
		_rl_last_c_pos = _rl_col_width(local_prompt, 0, nleft);
d996 5
a1005 1
	      _rl_backspace (_rl_last_c_pos - nleft);
d1007 1
a1007 1
		_rl_last_c_pos = _rl_col_width (&visible_line[pos], 0, nleft);
d1009 6
a1014 1
		_rl_last_c_pos = nleft;
d1017 4
d1179 4
a1182 1
  temp = _rl_last_c_pos - W_OFFSET(_rl_last_v_pos, visible_wrap_offset);
d1202 1
a1202 1
	  if (ret == (size_t)-1 || ret == (size_t)-2)
d1207 1
a1207 1
	  else if (ret == 0)
d1224 1
a1224 1
		  if (ret == (size_t)-1 || ret == (size_t)-2)
d1247 1
a1247 1
	  _rl_last_c_pos = 1;		/* XXX */
d1259 12
a1270 2
      memset (&ps_new, 0, sizeof(mbstate_t));
      memset (&ps_old, 0, sizeof(mbstate_t));
d1272 18
a1289 9
      new_offset = old_offset = 0;
      for (ofd = old, nfd = new;
	   (ofd - old < omax) && *ofd &&
	     _rl_compare_chars(old, old_offset, &ps_old, new, new_offset, &ps_new); )
	{
	  old_offset = _rl_find_next_mbchar (old, old_offset, 1, MB_FIND_ANY);
	  new_offset = _rl_find_next_mbchar (new, new_offset, 1, MB_FIND_ANY);
	  ofd = old + old_offset;
	  nfd = new + new_offset;
d1321 2
d1325 1
d1388 1
a1388 1
      if (current_line == 0 && visible_wrap_offset)
d1417 6
a1422 1
	_rl_last_c_pos = _rl_col_width (local_prompt, 0, lendiff);
d1484 1
a1484 1
	  else if (*ols == 0)
d1507 5
a1511 1
#if 0
d1523 4
d1558 1
a1558 1
	      _rl_last_c_pos += col_temp;
d1594 2
a1595 1
   distributed with CLISP. */
d1600 1
a1600 1
  char *prompt_last_line;
d1609 3
a1611 2
  strcpy (visible_line, rl_prompt);
  strcpy (invisible_line, rl_prompt);
d1620 1
a1620 1
    _rl_last_c_pos = _rl_col_width (prompt_last_line, 0, l);
d1646 2
d1669 2
d1679 2
d1682 2
a1683 1
  /* If we don't have to do anything, then return. */
d1688 3
a1690 2
     calculated. */
  if (MB_CUR_MAX == 1 || rl_byte_oriented)
d1692 3
a1694 2
      if (_rl_last_c_pos == new)
	return;
d1696 6
a1701 1
  else if (_rl_last_c_pos == _rl_col_width (data, 0, new))
a1702 3
#else
  if (_rl_last_c_pos == new) return;
#endif
d1707 6
a1712 1
  i = _rl_last_c_pos - W_OFFSET(_rl_last_v_pos, visible_wrap_offset);
d1721 1
a1721 1
      _rl_last_c_pos = 0;
d1724 1
a1724 1
  if (_rl_last_c_pos < new)
d1738 2
a1739 18
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      int width;
	      width = _rl_col_width (data, _rl_last_c_pos, new);
	      for (i = 0; i < width; i++)
		tputs (_rl_term_forward_char, 1, _rl_output_character_function);
	    }
	  else
	    {
	      for (i = _rl_last_c_pos; i < new; i++)
		tputs (_rl_term_forward_char, 1, _rl_output_character_function);
	    }
	}
      else if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  tputs (_rl_term_cr, 1, _rl_output_character_function);
	  for (i = 0; i < new; i++)
	    putc (data[i], rl_outstream);
d1742 1
a1742 5
	for (i = _rl_last_c_pos; i < new; i++)
	  putc (data[i], rl_outstream);

#else /* !HACK_TERMCAP_MOTION */

d1750 1
a1750 1
	for (i = _rl_last_c_pos; i < new; i++)
d1752 1
a1753 3
#endif /* !HACK_TERMCAP_MOTION */

    }
a1758 3
  else if (_rl_last_c_pos >= new)
#else
  else if (_rl_last_c_pos > new)
d1760 2
a1761 6
    {
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	_rl_backspace (_rl_last_c_pos - _rl_col_width (data, 0, new));
      else
	_rl_backspace (_rl_last_c_pos - new);
    }
d1763 1
a1763 4
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    _rl_last_c_pos =  _rl_col_width (data, 0, new);
  else
    _rl_last_c_pos = new;
a1860 1

d1863 1
d1894 5
d1900 5
d1906 1
d1916 1
d1918 10
d1929 1
d1939 5
a1957 5
static char *saved_local_prompt;
static char *saved_local_prefix;
static int saved_last_invisible;
static int saved_visible_length;

d1963 1
d1966 2
d1970 2
a1971 1
  prompt_last_invisible = prompt_visible_length = 0;
d1982 1
d1985 7
d1999 1
a1999 1
  char *pmt;
d2003 5
a2007 1
  if (saved_local_prompt == 0)
d2018 2
a2019 1
      len = *saved_local_prompt ? strlen (saved_local_prompt) : 0;
d2022 1
a2022 1
	strcpy (pmt, saved_local_prompt);
d2025 4
a2028 4
      local_prompt = savestring (pmt);
      prompt_last_invisible = saved_last_invisible;
      prompt_visible_length = saved_visible_length + 1;
    }
d2097 1
a2097 1
#if defined(__MSDOS__) || defined(__MINGW32__)
d2099 1
a2099 1
#else  /* !__MSDOS__ && !__MINGW32__ */
d2138 1
a2138 1
#endif /* !__MSDOS__ */
d2149 1
a2149 1
#if !defined(__MSDOS__) && !defined(__MINGW32__)  
d2218 1
a2218 2
  char *oldp, *oldl, *oldlprefix;
  int oldlen, oldlast, oldplen, oldninvis;
a2219 1
  /* Geez, I should make this a struct. */
d2221 1
a2221 6
  oldl = local_prompt;
  oldlprefix = local_prompt_prefix;
  oldlen = prompt_visible_length;
  oldplen = prompt_prefix_length;
  oldlast = prompt_last_invisible;
  oldninvis = prompt_invis_chars_first_line;
d2226 2
a2227 1
				   &prompt_invis_chars_first_line);
d2229 1
d2233 1
a2233 6
  local_prompt = oldl;
  local_prompt_prefix = oldlprefix;
  prompt_visible_length = oldlen;
  prompt_prefix_length = oldplen;
  prompt_last_invisible = oldlast;
  prompt_invis_chars_first_line = oldninvis;
d2343 1
a2343 1
      if ((size_t)tmp == (size_t)-1 || (size_t)tmp == (size_t)-2)
d2355 2
a2356 2
      else if (tmp == 0)
        break;		/* Found '\0' */
d2372 1
a2372 1
      if ((size_t)tmp == (size_t)-1 || (size_t)tmp == (size_t)-2)
d2387 2
a2388 2
      else if (tmp == 0)
        break;			/* Found '\0' */
@


1.10.2.1
log
@Import readline 5.1 on the branch.
@
text
@d3 1
a3 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
a124 1
int _rl_want_redisplay = 0;
a130 1

a131 4
/* NOTE: _rl_last_c_pos is used as a buffer index when not in a locale
   supporting multibyte characters, and an absolute cursor position when
   in such a locale.  This is an artifact of the donated multibyte support.
   Care must be taken when modifying its value. */
a134 2
static int cpos_adjusted;

a184 14
static int prompt_physical_chars;

/* Variables to save and restore prompt and display information. */

/* These are getting numerous enough that it's time to create a struct. */

static char *saved_local_prompt;
static char *saved_local_prefix;
static int saved_last_invisible;
static int saved_visible_length;
static int saved_prefix_length;
static int saved_invis_chars_first_line;
static int saved_physical_chars;

d190 1
a190 2
   the first prompt line.  The previous are used as byte counts -- indexes
   into a character buffer. */
d200 1
a200 1
expand_prompt (pmt, lp, lip, niflp, vlp)
d202 1
a202 1
     int *lp, *lip, *niflp, *vlp;
d205 1
a205 1
  int l, rl, last, ignoring, ninvis, invfl, invflset, ind, pind, physchars;
d208 1
a208 1
  if ((MB_CUR_MAX <= 1 || rl_byte_oriented) && strchr (pmt, RL_PROMPT_START_IGNORE) == 0)
a212 6
      if (lip)
	*lip = 0;
      if (niflp)
	*niflp = 0;
      if (vlp)
	*vlp = lp ? *lp : strlen (r);
a219 1
  invflset = 0;	/* we only want to set invfl once */
d221 1
a221 1
  for (rl = ignoring = last = ninvis = physchars = 0, p = pmt; p && *p; p++)
d233 1
a233 2
	  if (p[-1] != RL_PROMPT_START_IGNORE)
	    last = r - ret - 1;
d238 3
a240 17
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      pind = p - pmt;
	      ind = _rl_find_next_mbchar (pmt, pind, 1, MB_FIND_NONZERO);
	      l = ind - pind;
	      while (l--)
	        *r++ = *p++;
	      if (!ignoring)
		{
		  rl += ind - pind;
		  physchars += _rl_col_width (pmt, pind, ind);
		}
	      else
		ninvis += ind - pind;
	      p--;			/* compensate for later increment */
	    }
d242 3
a244 17
#endif
	    {
	      *r++ = *p;
	      if (!ignoring)
		{
		  rl++;			/* visible length byte counter */
		  physchars++;
		}
	      else
		ninvis++;		/* invisible chars byte counter */
	    }

	  if (invflset == 0 && rl >= _rl_screenwidth)
	    {
	      invfl = ninvis;
	      invflset = 1;
	    }
a257 2
  if  (vlp)
    *vlp = physchars;
d269 1
a269 1
  ret = expand_prompt (pmt, (int *)NULL, (int *)NULL, (int *)NULL, (int *)NULL);
d302 1
a302 2
  prompt_last_invisible = prompt_invis_chars_first_line = 0;
  prompt_visible_length = prompt_physical_chars = 0;
d313 1
a313 2
					    &prompt_invis_chars_first_line,
					    &prompt_physical_chars);
d323 1
a323 2
				       (int *)NULL,
				       &prompt_physical_chars);
d329 1
a329 2
						   &prompt_invis_chars_first_line,
						   (int *)NULL);
d387 2
a388 2
  int c_pos, inv_botlin, lb_botlin, lb_linenum, o_cpos;
  int newlines, lpos, temp, modmark, n0, num;
d404 1
a404 1
  if (invisible_line == 0 || vis_lbreaks == 0)
a417 1
  modmark = 0;
a421 1
      modmark = 1;
d475 1
a475 1
      prompt_physical_chars = pmtlen = strlen (prompt_this_line);
a533 1
#if 0
a534 4
#else
  lpos = prompt_physical_chars + modmark;
#endif

a536 1
  num = 0;
d553 4
a556 15
         prompts that exceed two physical lines?
         Additional logic fix from Edward Catmur <ed@@catmur.co.uk> */
#if defined (HANDLE_MULTIBYTE)
      n0 = num;
      temp = local_prompt ? strlen (local_prompt) : 0;
      while (num < temp)
	{
	  if (_rl_col_width  (local_prompt, n0, num) > _rl_screenwidth)
	    {
	      num = _rl_find_prev_mbchar (local_prompt, num, MB_FIND_ANY);
	      break;
	    }
	  num++;
	}
      temp = num +
d558 4
a561 6
      temp = ((newlines + 1) * _rl_screenwidth) +
#endif /* !HANDLE_MULTIBYTE */
             ((local_prompt_prefix == 0) ? ((newlines == 0) ? prompt_invis_chars_first_line
							    : ((newlines == 1) ? wrap_offset : 0))
					 : ((newlines == 0) ? wrap_offset :0));
             
a562 3
#if defined (HANDLE_MULTIBYTE)
      lpos -= _rl_col_width (local_prompt, n0, num);
#else
a563 1
#endif
d593 1
a593 1
	  if (MB_INVALIDCH (wc_bytes))
d602 1
a602 1
	  else if (MB_NULLWCH (wc_bytes))
d607 1
a607 1
	      wc_width = (temp >= 0) ? temp : 1;
d772 1
a772 1
      int nleft, pos, changed_screen_line, tx;
a802 2
	      o_cpos = _rl_last_c_pos;
	      cpos_adjusted = 0;
a805 15
	      /* update_line potentially changes _rl_last_c_pos, but doesn't
		 take invisible characters into account, since _rl_last_c_pos
		 is an absolute cursor position in a multibyte locale.  See
		 if compensating here is the right thing, or if we have to
		 change update_line itself.  There is one case in which
		 update_line adjusts _rl_last_c_pos itself (so it can pass
		 _rl_move_cursor_relative accurate values); it communicates
		 this back by setting cpos_adjusted */
	      if (linenum == 0 && (MB_CUR_MAX > 1 && rl_byte_oriented == 0) &&
		  cpos_adjusted == 0 &&
		  _rl_last_c_pos != o_cpos &&
		  _rl_last_c_pos > wrap_offset &&
		  o_cpos < prompt_last_invisible)
		_rl_last_c_pos -= wrap_offset;
		  
d817 1
a817 4
		  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		    nleft = _rl_screenwidth - _rl_last_c_pos;
		  else
		    nleft = _rl_screenwidth + wrap_offset - _rl_last_c_pos;
d853 1
a853 1
	      if ((MB_CUR_MAX == 1 || rl_byte_oriented) && cursor_linenum == 0 && wrap_offset)
d874 1
a874 1
		_rl_last_c_pos = _rl_col_width (local_prompt, 0, nleft) - wrap_offset;
a885 5
	  /* NLEFT is now a number of characters in a buffer.  When in a
	     multibyte locale, however, _rl_last_c_pos is an absolute cursor
	     position that doesn't take invisible characters in the prompt
	     into account.  We use a fudge factor to compensate. */

d891 1
d893 1
a893 1
		tx = _rl_col_width (&visible_line[pos], 0, nleft) - visible_wrap_offset;
d895 1
a895 6
		tx = nleft;
	      if (_rl_last_c_pos > tx)
		{
	          _rl_backspace (_rl_last_c_pos - tx);	/* XXX */
	          _rl_last_c_pos = tx;
		}
a897 4
	  /* We need to note that in a multibyte locale we are dealing with
	     _rl_last_c_pos as an absolute cursor position, but moving to a
	     point specified by a buffer position (NLEFT) that doesn't take
	     invisible characters into account. */
d1056 1
a1056 4
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    temp = _rl_last_c_pos;
  else
    temp = _rl_last_c_pos - W_OFFSET(_rl_last_v_pos, visible_wrap_offset);
d1076 1
a1076 1
	  if (MB_INVALIDCH (ret))
d1081 1
a1081 1
	  else if (MB_NULLWCH (ret))
d1098 1
a1098 1
		  if (MB_INVALIDCH (ret))
d1121 1
a1121 1
	  _rl_last_c_pos = 1;
d1133 2
a1134 12
      /* See if the old line is a subset of the new line, so that the
	 only change is adding characters. */
      temp = (omax < nmax) ? omax : nmax;
      if (memcmp (old, new, temp) == 0)
	{
	  ofd = old + temp;
	  nfd = new + temp;
	}
      else
	{      
	  memset (&ps_new, 0, sizeof(mbstate_t));
	  memset (&ps_old, 0, sizeof(mbstate_t));
d1136 9
a1144 18
	  if (omax == nmax && STREQN (new, old, omax))
	    {
	      ofd = old + omax;
	      nfd = new + nmax;
	    }
	  else
	    {
	      new_offset = old_offset = 0;
	      for (ofd = old, nfd = new;
		    (ofd - old < omax) && *ofd &&
		    _rl_compare_chars(old, old_offset, &ps_old, new, new_offset, &ps_new); )
		{
		  old_offset = _rl_find_next_mbchar (old, old_offset, 1, MB_FIND_ANY);
		  new_offset = _rl_find_next_mbchar (new, new_offset, 1, MB_FIND_ANY);
		  ofd = old + old_offset;
		  nfd = new + new_offset;
		}
	    }
a1175 2
#if 0
	  /* On advice from jir@@yamato.ibm.com */
a1177 1
#endif
d1240 1
a1240 1
      if ((MB_CUR_MAX == 1 || rl_byte_oriented) && current_line == 0 && visible_wrap_offset)
d1269 1
a1269 6
	{
	  /* We take wrap_offset into account here so we can pass correct
	     information to _rl_move_cursor_relative. */
	  _rl_last_c_pos = _rl_col_width (local_prompt, 0, lendiff) - wrap_offset;
	  cpos_adjusted = 1;
	}
d1331 1
a1331 1
	  else if ((MB_CUR_MAX == 1 || rl_byte_oriented != 0) && *ols == 0 && lendiff > 0)
d1354 1
a1354 5
#if 1
	     /* XXX -- this bears closer inspection.  Fixes a redisplay bug
		reported against bash-3.0-alpha by Andreas Schwab involving
		multibyte characters and prompt strings with invisible
		characters, but was previously disabled. */
a1365 4
	  /* If we're in a multibyte locale and were before the last invisible
	     char in the current line (which implies we just output some invisible
	     characters) we need to adjust _rl_last_c_pos, since it represents
	     a physical character position. */
d1397 1
a1397 1
	      _rl_last_c_pos += col_temp;		/* XXX */
d1433 1
a1433 2
   distributed with CLISP.  rl_expand_prompt must have already been called
   (explicitly or implicitly).  This still doesn't work exactly right. */
d1438 1
a1438 1
  char *prompt_last_line, *lprompt;
d1447 2
a1448 3
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
  strcpy (invisible_line, lprompt);
d1457 1
a1457 1
    _rl_last_c_pos = _rl_col_width (prompt_last_line, 0, l);	/* XXX */
a1482 2
  rl_display_prompt = rl_prompt;	/* XXX - make sure it's set */

a1503 2
   (Well, when we don't have multibyte characters, _rl_last_c_pos is a
   buffer index.)
a1511 2
  int woff;			/* number of invisible chars on current line */
  int cpos, dpos;		/* current and desired cursor positions */
d1513 1
a1513 2
  woff = W_OFFSET (_rl_last_v_pos, wrap_offset);
  cpos = _rl_last_c_pos;
d1518 2
a1519 3
     calculated.  We need to account for invisible characters in this line,
     as long as we are past them and they are counted by _rl_col_width. */
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
d1521 2
a1522 3
      dpos = _rl_col_width (data, 0, new);
      if (dpos > woff)
	dpos -= woff;
d1524 4
a1527 1
  else
a1528 5
    dpos = new;

  /* If we don't have to do anything, then return. */
  if (cpos == dpos)
    return;
d1533 1
a1533 6
#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    i = _rl_last_c_pos;
  else
#endif
  i = _rl_last_c_pos - woff;
d1542 1
a1542 1
      cpos = _rl_last_c_pos = 0;
d1545 1
a1545 1
  if (cpos < dpos)
d1559 18
a1576 2
	  for (i = cpos; i < dpos; i++)
	    tputs (_rl_term_forward_char, 1, _rl_output_character_function);
d1579 5
a1583 1
#endif /* HACK_TERMCAP_MOTION */
d1591 1
a1591 1
	for (i = cpos; i < new; i++)
d1593 3
a1596 1

d1602 3
d1606 6
a1611 2
  else if (cpos > dpos)
    _rl_backspace (cpos - dpos);
d1613 4
a1616 1
  _rl_last_c_pos = dpos;
d1714 1
a1716 1
static int msg_saved_prompt = 0;
a1746 5
  if (saved_local_prompt == 0)
    {
      rl_save_prompt ();
      msg_saved_prompt = 1;
    }
a1747 5
  local_prompt = expand_prompt (msg_buf, &prompt_visible_length,
					 &prompt_last_invisible,
					 &prompt_invis_chars_first_line,
					 &prompt_physical_chars);
  local_prompt_prefix = (char *)NULL;
a1748 1

a1757 1

a1758 10
  if (saved_local_prompt == 0)
    {
      rl_save_prompt ();
      msg_saved_prompt = 1;
    }
  local_prompt = expand_prompt (msg_buf, &prompt_visible_length,
					 &prompt_last_invisible,
					 &prompt_invis_chars_first_line,
					 &prompt_physical_chars);
  local_prompt_prefix = (char *)NULL;
a1759 1
      
a1768 5
  if (msg_saved_prompt)
    {
      rl_restore_prompt ();
      msg_saved_prompt = 0;
    }
d1783 5
a1792 1
  saved_prefix_length = prompt_prefix_length;
a1794 2
  saved_invis_chars_first_line = prompt_invis_chars_first_line;
  saved_physical_chars = prompt_physical_chars;
d1797 1
a1797 2
  prompt_last_invisible = prompt_visible_length = prompt_prefix_length = 0;
  prompt_invis_chars_first_line = prompt_physical_chars = 0;
a1807 1
  prompt_prefix_length = saved_prefix_length;
a1809 7
  prompt_invis_chars_first_line = saved_invis_chars_first_line;
  prompt_physical_chars = saved_physical_chars;

  /* can test saved_local_prompt to see if prompt info has been saved. */
  saved_local_prompt = saved_local_prefix = (char *)0;
  saved_last_invisible = saved_visible_length = saved_prefix_length = 0;
  saved_invis_chars_first_line = saved_physical_chars = 0;
d1817 1
a1817 1
  char *pmt, *p;
d1821 1
a1821 5
  /* We've saved the prompt, and can do anything with the various prompt
     strings we need before they're restored.  We want the unexpanded
     portion of the prompt string after any final newline. */
  p = rl_prompt ? strrchr (rl_prompt, '\n') : 0;
  if (p == 0)
d1832 1
a1832 2
      p++;
      len = strlen (p);
d1835 1
a1835 1
	strcpy (pmt, p);
d1838 4
a1841 4
    }  

  /* will be overwritten by expand_prompt, called from rl_message */
  prompt_physical_chars = saved_physical_chars + 1;
d1910 1
a1910 1
#if defined (__MSDOS__) || defined (__MINGW32__)
d1912 1
a1912 1
#else
d1951 1
a1951 1
#endif /* __MSDOS__ || __MINGW32__ */
d1962 1
a1962 1
#if !defined (__MSDOS__) && !defined (__MINGW32__)
d2031 2
a2032 1
  char *oldp;
d2034 1
d2036 6
a2041 1
  rl_save_prompt ();
d2046 1
a2046 2
				   &prompt_invis_chars_first_line,
				   &prompt_physical_chars);
a2047 1

d2051 6
a2056 1
  rl_restore_prompt();
d2166 1
a2166 1
      if (MB_INVALIDCH ((size_t)tmp))
d2178 2
a2179 2
      else if (MB_NULLWCH (tmp))
	break;		/* Found '\0' */
d2195 1
a2195 1
      if (MB_INVALIDCH ((size_t)tmp))
d2210 2
a2211 2
      else if (MB_NULLWCH (tmp))
	break;			/* Found '\0' */
@


1.9
log
@	* readline/aclocal.m4: Use AC_TRY_LINK to check for mbstate_t.
	* readline/complete.c (pwd.h): Guard with HAVE_PWD_H.
	(getpwent): Guard with HAVE_GETPWENT.
	(rl_username_completion_function): Guard use of getpwent.
	(endpwent): Likewise.
	* readline/config.h.in (HAVE_FCNTL): New macro.
	(HAVE_GETPWENT): Likewise.
	(HAVE_GETPWNAM): Likewise.
	(HAVE_GETPWUID): Likewise.
	(HAVE_KILL): Likewise.
	(HAVE_PWD_H): Likewise.
	* readline/configure: Regenerated.
	* readline/configure.in: Handle MinGW when cross compiling.  Check for
	getpwnam, getpwent, getpwuid, kill, and pwd.h.
	* readline/display.c (rl_clear_screen): Treat Windows like DOS.
	(insert_some_chars): Likewise.
	(delete_chars): Likewise.
	* readline/shell.c (pwd.h): Guard with HAVE_PWD_H.
	(getpwuid): Guard with HAVE_GETPWUID.
	(sh_unset_nodelay_mode): Guard use of fnctl with HAVE_FNCTL_H.
	* readline/signals.c (rl_signal_handler): Don't use SIGALRM or
	SIGQUIT if not defined.  Use "raise" if "kill" is not available.
	(rl_set_signals): Don't set handlers for SIGQUIT or SIGALRM if
	they are not defined.
	(rl_clear_signals): Likewise.
	* readline/tilde.c (pwd.h): Guard with HAVE_PWD_H.
	(getpwuid): Guard declaration with HAVE_GETPWUID.
	(getpwnam): Guard declaration with HAVE_GETPWNAM.
	(tilde_expand_word): Guard use of getpwnam with HAVE_GETPWNAM.
@
text
@@


1.8
log
@	* readline.c (rl_save_state, rl_restore_state): Support systems
	that don't define SIGWINCH.

	* terminal.c (_rl_get_screen_size) [__DJGPP__]: Compute the
	screen width and height using console I/O.
	(_rl_init_terminal_io) [__MSDOS__]: Zero out all the _rl_term_*
	variables.  Convert to _rl_* naming scheme.
	(_rl_set_cursor) [__MSDOS__]: Ifdef away this function.

	* display.c (_rl_move_vert) [__MSDOS__]: Don't use undeclared
	variable `l'.  Use `delta' instead recomputing its value anew.
	Assign -delta to i instead of the other way around.
@
text
@d1910 1
a1910 1
#ifdef __MSDOS__
d1912 1
a1912 1
#else  /* !__MSDOS__ */
d1962 1
a1962 1
#ifndef __MSDOS__
d1975 1
a1975 1
#endif /* !__MSDOS__ */
@


1.8.20.1
log
@	* readline/Makefile.in (RLTTYOBJ): New variable.
	(OBJECTS): Use RLTTYOBJ.
	* readline/aclocal.m4: Use AC_RTY_LINK to check for mbstate_t.
	* readline/complete.c (pwd.h): Guard with HAVE_PWD_H.
	(getpwent): Guard with HAVE_GETPWENT.
	(rl_username_completion_function): Guard use of getpwent.
	(endpwent): Likewise.
	* readline/config.h.in (HAVE_FCNTL): New macro.
	(HAVE_GETPWENT): Likewise.
	(HAVE_GETPWNAM): Likewise.
	(HAVE_GETPWUID): Likewise.
	(HAVE_PWD_H): Likewise.
	* readline/configure: Regenerated.
	* readline/configure.in: Handle MinGW when cross compiling.  Check for
	getpwnam, getpwent, getpwuid, and pwd.h.  Set RLTTYOBJ.
	* readline/display.c (rl_clear_screen): Treat Windows like DOS.
	(insert_some_chars): Likewise.
	(delete_chars): Likewise.
	* readline/rldefs.h (NEW_TTY_DRIVER): Do not define for Windows.
	* readline/rlnotty.c: New file.
	* readline/shell.c (pwd.h): Guard with HAVE_PWD_H.
	(getpwuid): Guard with HAVE_GETPWUID.
	(sh_unset_nodelay_mode): Guard use of fnctl with HAVE_FNCTL_H.
	* readline/signals.c (rl_signal_handler): Don't use SIGALRM or
	SIGQUIT if not defined.  Use "raise" rather than "kill".
	(rl_set_signals): Don't set handlers for SIGQUIT or SIGALRM if
	they are not defined.
	(rl_clear_signals): Likewise.
	* readline/tilde.c (pwd.h): Guard with HAVE_PWD_H.
	(getpwuid): Guard declaration with HAVE_GETPWUID.
	(getpwnam): Guard declaration with HAVE_GETPWNAM.
	(tilde_expand_word): Guard use of getpwnam with HAVE_GETPWNAM.
@
text
@d1910 1
a1910 1
#if defined(__MSDOS__) || defined(__MINGW32__)
d1912 1
a1912 1
#else  /* !__MSDOS__ && !__MINGW32__ */
d1962 1
a1962 1
#if !defined(__MSDOS__) && !defined(__MINGW32__)  
d1975 1
a1975 1
#endif /* !__MSDOS__ && !__MINGW32__ */
@


1.8.20.2
log
@	* readline/display.c (insert_some_chars): Likewise.
	(delete_chars): Likewise.
@
text
@d1910 1
a1910 1
#ifdef __MSDOS__
d1912 1
a1912 1
#else  /* !__MSDOS__ */
d1962 1
a1962 1
#ifndef __MSDOS__
d1975 1
a1975 1
#endif /* !__MSDOS__ */
@


1.7
log
@2003-01-09  Michael Chastain  <mec@@shout.net>

	From Chet Ramey, <chet@@po.cwru.edu>, the readline maintainer:
	* display.c: Fix perverse screen refresh with UTF-8.
@
text
@d1645 1
a1645 1
      l = fflush (rl_outstream); /* make sure the cursor pos is current! */
d1647 2
a1648 2
      ScreenSetCursor ((row + to - _rl_last_v_pos), col);
      delta = i;
@


1.6
log
@Import of readline 4.3.
Non-readline modified files:

src/gdb/ChangeLog src/gdb/defs.h src/gdb/cli/cli-cmds.c
src/gdb/cli/cli-setshow.c src/gdb/tui/ChangeLog
src/gdb/tui/tuiWin.c

In readline directory:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@d77 1
a77 1
static int _rl_col_width PARAMS((char *, int, int));
d1355 1
a1355 1
	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-lendiff) - col_lendiff;
d1357 1
a1357 1
	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-col_lendiff);
d1517 9
a1525 2
     this case, NEW's display position is not obvious. */
  if ((MB_CUR_MAX == 1 || rl_byte_oriented ) && _rl_last_c_pos == new) return;
d1608 1
a1608 5
	{
	  tputs (_rl_term_cr, 1, _rl_output_character_function);
	  for (i = 0; i < new; i++)
	    putc (data[i], rl_outstream);
	}
d2150 1
a2150 1
     char *str;
a2225 1
	  
@


1.5
log
@A few tweaks required to use Readline as part of the DJGPP port of GDB.
@
text
@d50 1
d67 1
a67 1
extern char *term_forward_char;
d70 12
a81 5
static void update_line __P((char *, char *, int, int, int, int));
static void space_to_eol __P((int));
static void delete_chars __P((int));
static void insert_some_chars __P((char *, int));
static void cr __P((void));
d118 1
a118 1
VFunction *rl_redisplay_function = rl_redisplay;
d157 3
d161 1
a161 1
static int visible_length, prefix_length;
d167 2
a168 1
/* static so it can be shared between rl_redisplay and update_line */
d171 2
a172 2
/* The index of the last invisible_character in the prompt string. */
static int last_invisible;
d178 7
d188 3
a190 1
   index of the last invisible character in the returned string. */
d200 1
a200 1
expand_prompt (pmt, lp, lip)
d202 1
a202 1
     int *lp, *lip;
d205 1
a205 1
  int l, rl, last, ignoring;
d217 5
a221 3
  r = ret = xmalloc (l + 1);
  
  for (rl = ignoring = last = 0, p = pmt; p && *p; p++)
d241 4
d248 3
d256 2
d269 1
a269 1
  ret = expand_prompt (pmt, (int *)NULL, (int *)NULL);
d281 2
a282 2
 * visible_length = number of visible characters in local_prompt
 * prefix_length = number of visible characters in local_prompt_prefix
d298 3
a300 4
  if (local_prompt)
    free (local_prompt);
  if (local_prompt_prefix)
    free (local_prompt_prefix);
d302 1
a302 1
  last_invisible = visible_length = 0;
d310 4
a313 2
      /* The prompt is only one line. */
      local_prompt = expand_prompt (prompt, &visible_length, &last_invisible);
d315 1
a315 1
      return (visible_length);
d321 3
a323 1
      local_prompt = expand_prompt (p, &visible_length, &last_invisible);
d327 3
a329 1
      local_prompt_prefix = expand_prompt (prompt, &prefix_length, (int *)NULL);
d331 1
a331 1
      return (prefix_length);
d350 2
a351 2
      visible_line = xmalloc (line_size);
      invisible_line = xmalloc (line_size);
d358 2
a359 2
      visible_line = xrealloc (visible_line, line_size);
      invisible_line = xrealloc (invisible_line, line_size);
d374 3
d390 7
d446 2
a447 2
	      visible_line = xrealloc (visible_line, line_size);
	      line = invisible_line = xrealloc (invisible_line, line_size);
d453 1
a453 1
      wrap_offset = local_len - visible_length;
d480 2
a481 2
	  visible_line = xrealloc (visible_line, line_size);
	  line = invisible_line = xrealloc (invisible_line, line_size);
d486 1
a486 1
      wrap_offset = 0;
d497 19
a515 1
	  
d519 1
a519 1
	if (lpos >= screenwidth) \
d530 1
d535 8
d544 1
a544 1
  /* XXX - what if lpos is already >= screenwidth before we start drawing the
d546 1
a546 1
  while (lpos >= screenwidth)
d548 13
a560 6
      /* XXX - possible fix from Darin Johnson <darin@@acuson.com> for prompt
	 string with invisible characters that is longer than the screen
	 width.  XXX - this doesn't work right if invisible characters have
	 to be put on the second screen line -- it adds too much (the number
	 of invisible chars after the screenwidth). */
      temp = ((newlines + 1) * screenwidth) + ((newlines == 0) ? wrap_offset : 0);
d563 1
a563 1
      lpos -= screenwidth;
d566 7
d574 11
d586 1
d590 22
d615 2
a616 2
	  visible_line = xrealloc (visible_line, line_size);
	  invisible_line = xrealloc (invisible_line, line_size);
d626 3
d630 1
d636 1
a636 1
	      if (lpos + 4 >= screenwidth)
d638 1
a638 1
		  temp = screenwidth - lpos;
d657 1
a657 1
	  register int temp, newout;
d665 1
a665 1
	  if (lpos + temp >= screenwidth)
d668 1
a668 1
	      temp2 = screenwidth - lpos;
d683 1
a683 1
      else if (c == '\n' && _rl_horizontal_scroll_mode == 0 && term_up && *term_up)
d699 31
d732 8
d741 4
d758 2
a759 1
  /* C_POS == position in buffer where cursor should be placed. */
d770 1
a770 1
  if (_rl_horizontal_scroll_mode == 0 && term_up && *term_up)
d781 7
a787 2
	  if (out >= screenchars)
	    out = screenchars - 1;
d817 1
a817 1
		  nleft = screenwidth + wrap_offset - _rl_last_c_pos;
d838 1
a838 1
		    ((linenum == _rl_vis_botlin) ? strlen (tt) : screenwidth);
d849 1
a849 1
	      /* If we moved up to the line with the prompt using term_up,
d862 1
a862 1
	  nleft = visible_length + wrap_offset;
d864 1
a864 1
	      _rl_last_c_pos <= last_invisible && local_prompt)
d869 2
a870 2
	      if (term_cr)
		tputs (term_cr, 1, _rl_output_character_function);
d873 4
a876 1
	      _rl_last_c_pos = nleft;
d892 4
a895 1
	      _rl_last_c_pos = nleft;
d898 3
a900 1
	  if (nleft != _rl_last_c_pos)
d917 1
a917 1
      nleft  = visible_length + wrap_offset;
d921 1
a921 1
      t = screenwidth / 3;
d929 1
a929 1
      if (phys_c_pos > screenwidth - 2)
d939 1
a939 1
      else if (ndisp < screenwidth - 2)		/* XXX - was -1 */
d961 1
a961 1
      t = lmargin + M_OFFSET (lmargin, wrap_offset) + screenwidth;
d971 2
a972 2
		       screenwidth + visible_wrap_offset,
		       screenwidth + (lmargin ? 0 : wrap_offset),
d983 1
a983 1
	      nleft = screenwidth - t;
d987 2
a988 2
	  if (visible_first_line_len > screenwidth)
	    visible_first_line_len = screenwidth;
d998 1
a998 1
    char *temp = visible_line;
d1002 1
a1002 1
    invisible_line = temp;
d1045 5
d1057 2
a1058 2
  if (temp == screenwidth && _rl_term_autowrap && !_rl_horizontal_scroll_mode
      && _rl_last_v_pos == current_line - 1)
d1060 54
a1113 2
      if (new[0])
	putc (new[0], rl_outstream);
d1115 11
a1125 5
	putc (' ', rl_outstream);
      _rl_last_c_pos = 1;		/* XXX */
      _rl_last_v_pos++;
      if (old[0] && new[0])
	old[0] = new[0];
d1127 1
d1130 19
d1165 27
d1201 3
d1210 6
d1217 1
d1220 6
a1225 1
	ols++;
d1227 6
a1232 1
	nls++;
d1259 2
a1260 2
      term_cr && lendiff > visible_length && _rl_last_c_pos > 0 &&
      od > lendiff && _rl_last_c_pos < last_invisible)
d1265 1
a1265 1
      tputs (term_cr, 1, _rl_output_character_function);
d1268 4
a1271 1
      _rl_last_c_pos = lendiff;
d1276 4
a1279 1
  /* if (len (new) > len (old)) */
d1281 4
d1291 12
a1302 1
    lendiff += visible_wrap_offset - current_invis_chars;
d1306 6
a1311 1
  if (lendiff > 0)
d1319 1
a1319 1
      if (terminal_can_insert && ((2 * temp) >= lendiff || term_IC) && (!_rl_term_autowrap || !gl))
d1321 1
a1321 1
	  /* If lendiff > visible_length and _rl_last_c_pos == 0 and
d1323 1
a1323 1
	     term_IC or term_ic will screw up the screen because of the
d1326 1
a1326 1
			lendiff <= visible_length || !current_invis_chars))
d1328 2
a1329 2
	      insert_some_chars (nfd, lendiff);
	      _rl_last_c_pos += lendiff;
d1338 1
a1338 1
	      _rl_last_c_pos += lendiff;
d1346 1
a1346 1
	      _rl_last_c_pos += temp;
d1354 5
a1358 1
	      _rl_last_c_pos += temp - lendiff;
d1365 1
a1365 1
	  _rl_last_c_pos += temp;
d1371 1
a1371 1
      if (term_dc && (2 * temp) >= -lendiff)
d1378 1
a1378 1
	    lendiff = 0;
d1380 2
a1381 2
	  if (lendiff)
	    delete_chars (-lendiff); /* delete (diff) characters */
d1388 1
a1388 1
	      _rl_last_c_pos += temp;
d1397 1
a1397 1
	      _rl_last_c_pos += temp;
d1400 6
a1405 1
	  if (lendiff)
d1408 1
a1408 1
		space_to_eol (lendiff);
d1410 1
a1410 1
		_rl_clear_to_eol (lendiff);
d1456 4
a1459 1
  _rl_last_c_pos = l;
d1464 1
a1464 1
  real_screenwidth = screenwidth + (_rl_term_autowrap ? 0 : 1);
d1509 1
a1509 1
     char *data;
d1514 6
d1521 1
d1528 1
a1528 1
      (_rl_term_autowrap && i == screenwidth))
d1533 1
a1533 1
      tputs (term_cr, 1, _rl_output_character_function);
d1550 22
a1571 1
      if (term_forward_char)
d1573 10
a1582 1
	  tputs (term_forward_char, 1, _rl_output_character_function);
d1586 10
d1597 11
a1607 3
      for (i = _rl_last_c_pos; i < new; i++)
	putc (data[i], rl_outstream);
#endif /* HACK_TERMCAP_MOTION */
d1609 5
a1613 3
  else if (_rl_last_c_pos > new)
    _rl_backspace (_rl_last_c_pos - new);
  _rl_last_c_pos = new;
d1623 1
a1623 1
  if (_rl_last_v_pos == to || to > screenheight)
d1633 1
a1633 1
      tputs (term_cr, 1, _rl_output_character_function);
d1642 1
a1642 1
      i = fflush (rl_outstream); /* make sure the cursor pos is current! */
d1647 1
a1647 1
      if (term_up && *term_up)
d1649 1
a1649 1
	  tputs (term_up, 1, _rl_output_character_function);
d1709 1
a1709 1
  return ((isprint (uc)) ? 1 : 2);
d1736 3
d1740 2
d1754 1
d1790 2
a1791 2
  saved_last_invisible = last_invisible;
  saved_visible_length = visible_length;
d1794 1
a1794 1
  last_invisible = visible_length = 0;
d1800 2
a1801 4
  if (local_prompt)
    free (local_prompt);
  if (local_prompt_prefix)
    free (local_prompt_prefix);
d1805 2
a1806 2
  last_invisible = saved_last_invisible;
  visible_length = saved_visible_length;
d1821 1
a1821 1
      pmt = xmalloc (len + 2);
d1830 1
a1830 1
      pmt = xmalloc (len + 2);
d1836 2
a1837 2
      last_invisible = saved_last_invisible;
      visible_length = saved_visible_length + 1;
d1865 2
a1866 2
  if (term_clreol)
    tputs (term_clreol, 1, _rl_output_character_function);
d1894 2
a1895 2
  if (term_clrpag)
    tputs (term_clrpag, 1, _rl_output_character_function);
d1897 1
a1897 1
    crlf ();
d1901 1
a1901 1
/* Insert COUNT characters from STRING to the output stream. */
d1903 1
a1903 1
insert_some_chars (string, count)
d1905 1
a1905 1
     int count;
d1910 5
d1916 1
a1916 1
  if (term_IC)
d1919 2
a1920 1
      buffer = tgoto (term_IC, 0, count);
d1929 2
a1930 2
      if (term_im && *term_im)
	tputs (term_im, 1, _rl_output_character_function);
d1934 1
a1934 1
      if (term_ic && *term_ic)
d1936 2
a1937 2
	  for (i = count; i--; )
	    tputs (term_ic, 1, _rl_output_character_function);
d1945 2
a1946 2
      if (term_ei && *term_ei)
	tputs (term_ei, 1, _rl_output_character_function);
d1956 1
a1956 1
  if (count > screenwidth)	/* XXX */
d1960 1
a1960 1
  if (term_DC && *term_DC)
d1963 1
a1963 1
      buffer = tgoto (term_DC, count, count);
d1968 1
a1968 1
      if (term_dc && *term_dc)
d1970 1
a1970 1
	  tputs (term_dc, 1, _rl_output_character_function);
d1991 1
a1991 1
  if (full_lines && _rl_term_autowrap && (VIS_LLEN(_rl_vis_botlin) == screenwidth))
d1994 1
a1994 3
#if 0
      last_line = &visible_line[inv_lbreaks[_rl_vis_botlin]];
#else
d1996 1
a1996 2
#endif
      _rl_move_cursor_relative (screenwidth - 1, last_line);
d1998 1
a1998 1
      putc (last_line[screenwidth - 1], rl_outstream);
d2001 1
a2001 1
  crlf ();
d2010 1
a2010 1
  if (term_cr)
d2015 1
a2015 1
      tputs (term_cr, 1, _rl_output_character_function);
d2029 1
a2029 1
  int oldlen, oldlast, oldplen;
d2035 4
a2038 3
  oldlen = visible_length;
  oldplen = prefix_length;
  oldlast = last_invisible;
d2041 3
a2043 1
  local_prompt = expand_prompt (t, &visible_length, &last_invisible);
d2050 4
a2053 3
  visible_length = oldlen;
  prefix_length = oldplen;
  last_invisible = oldlast;
d2064 1
a2064 1
  if (term_cr)
d2069 1
a2069 1
      tputs (term_cr, 1, _rl_output_character_function);
d2073 1
a2073 1
      space_to_eol (screenwidth);
d2076 2
a2077 2
      if (term_clreol)
	tputs (term_clreol, 1, _rl_output_character_function);
d2080 2
a2081 2
	  space_to_eol (screenwidth);
	  tputs (term_cr, 1, _rl_output_character_function);
d2088 1
a2088 1
    crlf ();
d2129 1
a2129 1
    nleft = _rl_last_c_pos - screenwidth - rl_visible_prompt_length;
d2131 1
a2131 1
    nleft = _rl_last_c_pos - screenwidth;
d2134 1
a2134 1
    ret = 1 + nleft / screenwidth;
d2140 84
@


1.5.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a49 1
#include "rlmbutil.h"
d66 1
a66 1
extern char *_rl_term_forward_char;
d69 5
a73 12
static void update_line PARAMS((char *, char *, int, int, int, int));
static void space_to_eol PARAMS((int));
static void delete_chars PARAMS((int));
static void insert_some_chars PARAMS((char *, int, int));
static void cr PARAMS((void));

#if defined (HANDLE_MULTIBYTE)
static int _rl_col_width PARAMS((const char *, int, int));
static int *_rl_wrapped_line;
#else
#  define _rl_col_width(l, s, e)	(((e) <= (s)) ? 0 : (e) - (s))
#endif
d110 1
a110 1
rl_voidfunc_t *rl_redisplay_function = rl_redisplay;
a148 3
/* Variables to keep track of the expanded prompt string, which may
   include invisible characters. */

d150 1
a150 1
static int prompt_visible_length, prompt_prefix_length;
d156 1
a156 2
/* The number of invisible characters in the prompt string.  Static so it
   can be shared between rl_redisplay and update_line */
d159 2
a160 2
/* The index of the last invisible character in the prompt string. */
static int prompt_last_invisible;
a165 7
/* Number of invisible characters on the first physical line of the prompt.
   Only valid when the number of physical characters in the prompt exceeds
   (or is equal to) _rl_screenwidth. */
static int prompt_invis_chars_first_line;

static int prompt_last_screen_line;

d169 1
a169 3
   index of the last invisible character in the returned string. NIFLP,
   if non-zero, is a place to store the number of invisible characters in
   the first prompt line. */
d179 1
a179 1
expand_prompt (pmt, lp, lip, niflp)
d181 1
a181 1
     int *lp, *lip, *niflp;
d184 1
a184 1
  int l, rl, last, ignoring, ninvis, invfl;
d196 3
a198 5
  r = ret = (char *)xmalloc (l + 1);

  invfl = 0;	/* invisible chars in first line of prompt */

  for (rl = ignoring = last = ninvis = 0, p = pmt; p && *p; p++)
a217 4
	  else
	    ninvis++;
	  if (rl == _rl_screenwidth)
	    invfl = ninvis;
a220 3
  if (rl < _rl_screenwidth)
    invfl = ninvis;

a225 2
  if (niflp)
    *niflp = invfl;
d237 1
a237 1
  ret = expand_prompt (pmt, (int *)NULL, (int *)NULL, (int *)NULL);
d249 2
a250 2
 * prompt_visible_length = number of visible characters in local_prompt
 * prompt_prefix_length = number of visible characters in local_prompt_prefix
d266 4
a269 3
  FREE (local_prompt);
  FREE (local_prompt_prefix);

d271 1
a271 1
  prompt_last_invisible = prompt_visible_length = 0;
d279 2
a280 4
      /* The prompt is only one logical line, though it might wrap. */
      local_prompt = expand_prompt (prompt, &prompt_visible_length,
					    &prompt_last_invisible,
					    &prompt_invis_chars_first_line);
d282 1
a282 1
      return (prompt_visible_length);
d288 1
a288 3
      local_prompt = expand_prompt (p, &prompt_visible_length,
				       &prompt_last_invisible,
				       &prompt_invis_chars_first_line);
d292 1
a292 3
      local_prompt_prefix = expand_prompt (prompt, &prompt_prefix_length,
						   (int *)NULL,
						   &prompt_invis_chars_first_line);
d294 1
a294 1
      return (prompt_prefix_length);
d313 2
a314 2
      visible_line = (char *)xmalloc (line_size);
      invisible_line = (char *)xmalloc (line_size);
d321 2
a322 2
      visible_line = (char *)xrealloc (visible_line, line_size);
      invisible_line = (char *)xrealloc (invisible_line, line_size);
a336 3
#if defined (HANDLE_MULTIBYTE)
      _rl_wrapped_line = (int *)xmalloc (vis_lbsize * sizeof (int));
#endif
a349 7
#if defined (HANDLE_MULTIBYTE)
  wchar_t wc;
  size_t wc_bytes;
  int wc_width;
  mbstate_t ps;
  int _rl_wrapped_multicolumn = 0;
#endif
d399 2
a400 2
	      visible_line = (char *)xrealloc (visible_line, line_size);
	      line = invisible_line = (char *)xrealloc (invisible_line, line_size);
d406 1
a406 1
      wrap_offset = local_len - prompt_visible_length;
d433 2
a434 2
	  visible_line = (char *)xrealloc (visible_line, line_size);
	  line = invisible_line = (char *)xrealloc (invisible_line, line_size);
d439 1
a439 1
      wrap_offset = prompt_invis_chars_first_line = 0;
d450 1
a450 19

#if defined (HANDLE_MULTIBYTE)	  
#define CHECK_LPOS() \
      do { \
	lpos++; \
	if (lpos >= _rl_screenwidth) \
	  { \
	    if (newlines >= (inv_lbsize - 2)) \
	      { \
		inv_lbsize *= 2; \
		inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \
		_rl_wrapped_line = (int *)xrealloc (_rl_wrapped_line, inv_lbsize * sizeof (int)); \
	      } \
	    inv_lbreaks[++newlines] = out; \
	    _rl_wrapped_line[newlines] = _rl_wrapped_multicolumn; \
	    lpos = 0; \
	  } \
      } while (0)
#else
d454 1
a454 1
	if (lpos >= _rl_screenwidth) \
a464 1
#endif
a468 8
#if defined (HANDLE_MULTIBYTE)
  memset (_rl_wrapped_line, 0, vis_lbsize);
#endif

  /* prompt_invis_chars_first_line is the number of invisible characters in
     the first physical line of the prompt.
     wrap_offset - prompt_invis_chars_first_line is the number of invis
     chars on the second line. */
d470 1
a470 1
  /* what if lpos is already >= _rl_screenwidth before we start drawing the
d472 1
a472 1
  while (lpos >= _rl_screenwidth)
d474 6
a479 13
      /* fix from Darin Johnson <darin@@acuson.com> for prompt string with
         invisible characters that is longer than the screen width.  The
         prompt_invis_chars_first_line variable could be made into an array
         saying how many invisible characters there are per line, but that's
         probably too much work for the benefit gained.  How many people have
         prompts that exceed two physical lines? */
      temp = ((newlines + 1) * _rl_screenwidth) +
#if 0
             ((newlines == 0) ? prompt_invis_chars_first_line : 0) +
#else
             ((newlines == 0 && local_prompt_prefix == 0) ? prompt_invis_chars_first_line : 0) +
#endif
             ((newlines == 1) ? wrap_offset : 0);
d482 1
a482 1
      lpos -= _rl_screenwidth;
a484 7
  prompt_last_screen_line = newlines;

  /* Draw the rest of the line (after the prompt) into invisible_line, keeping
     track of where the cursor is (c_pos), the number of the line containing
     the cursor (lb_linenum), the last line number (lb_botlin and inv_botlin).
     It maintains an array of line breaks for display (inv_lbreaks).
     This handles expanding tabs for display and displaying meta characters. */
a485 11
#if defined (HANDLE_MULTIBYTE)
  in = 0;
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      memset (&ps, 0, sizeof (mbstate_t));
      wc_bytes = mbrtowc (&wc, rl_line_buffer, rl_end, &ps);
    }
  else
    wc_bytes = 1;
  while (in < rl_end)
#else
a486 1
#endif
a489 22
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  if (wc_bytes == (size_t)-1 || wc_bytes == (size_t)-2)
	    {
	      /* Byte sequence is invalid or shortened.  Assume that the
	         first byte represents a character. */
	      wc_bytes = 1;
	      /* Assume that a character occupies a single column. */
	      wc_width = 1;
	      memset (&ps, 0, sizeof (mbstate_t));
	    }
	  else if (wc_bytes == (size_t)0)
	    break;			/* Found '\0' */
	  else
	    {
	      temp = wcwidth (wc);
	      wc_width = (temp < 0) ? 1 : temp;
	    }
	}
#endif

d493 2
a494 2
	  visible_line = (char *)xrealloc (visible_line, line_size);
	  invisible_line = (char *)xrealloc (invisible_line, line_size);
a503 3
#if defined (HANDLE_MULTIBYTE)
      if (META_CHAR (c) && _rl_output_meta_chars == 0)	/* XXX - clean up */
#else
a504 1
#endif
d510 1
a510 1
	      if (lpos + 4 >= _rl_screenwidth)
d512 1
a512 1
		  temp = _rl_screenwidth - lpos;
d531 1
a531 1
	  register int newout;
d539 1
a539 1
	  if (lpos + temp >= _rl_screenwidth)
d542 1
a542 1
	      temp2 = _rl_screenwidth - lpos;
d557 1
a557 1
      else if (c == '\n' && _rl_horizontal_scroll_mode == 0 && _rl_term_up && *_rl_term_up)
a572 31
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      register int i;

	      _rl_wrapped_multicolumn = 0;

	      if (_rl_screenwidth < lpos + wc_width)
		for (i = lpos; i < _rl_screenwidth; i++)
		  {
		    /* The space will be removed in update_line() */
		    line[out++] = ' ';
		    _rl_wrapped_multicolumn++;
		    CHECK_LPOS();
		  }
	      if (in == rl_point)
		{
		  c_pos = out;
		  lb_linenum = newlines;
		}
	      for (i = in; i < in+wc_bytes; i++)
		line[out++] = rl_line_buffer[i];
	      for (i = 0; i < wc_width; i++)
		CHECK_LPOS();
	    }
	  else
	    {
	      line[out++] = c;
	      CHECK_LPOS();
	    }
#else
a574 8
#endif
	}

#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  in += wc_bytes;
	  wc_bytes = mbrtowc (&wc, rl_line_buffer + in, rl_end - in, &ps);
a575 4
      else
        in++;
#endif

d589 1
a589 2
  /* C_POS == position in buffer where cursor should be placed.
     CURSOR_LINENUM == line number where the cursor should be placed. */
d600 1
a600 1
  if (_rl_horizontal_scroll_mode == 0 && _rl_term_up && *_rl_term_up)
d611 2
a612 7
	  if (out >= _rl_screenchars)
	    {
	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		out = _rl_find_prev_mbchar (line, _rl_screenchars, MB_FIND_ANY);
	      else
		out = _rl_screenchars - 1;
	    }
d642 1
a642 1
		  nleft = _rl_screenwidth + wrap_offset - _rl_last_c_pos;
d663 1
a663 1
		    ((linenum == _rl_vis_botlin) ? strlen (tt) : _rl_screenwidth);
d674 1
a674 1
	      /* If we moved up to the line with the prompt using _rl_term_up,
d687 1
a687 1
	  nleft = prompt_visible_length + wrap_offset;
d689 1
a689 1
	      _rl_last_c_pos <= prompt_last_invisible && local_prompt)
d694 2
a695 2
	      if (_rl_term_cr)
		tputs (_rl_term_cr, 1, _rl_output_character_function);
d698 1
a698 4
	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		_rl_last_c_pos = _rl_col_width(local_prompt, 0, nleft);
	      else
		_rl_last_c_pos = nleft;
d714 1
a714 4
	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		_rl_last_c_pos = _rl_col_width (&visible_line[pos], 0, nleft);
	      else
		_rl_last_c_pos = nleft;
d717 1
a717 3
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    _rl_move_cursor_relative (nleft, &invisible_line[pos]);
	  else if (nleft != _rl_last_c_pos)
d734 1
a734 1
      nleft  = prompt_visible_length + wrap_offset;
d738 1
a738 1
      t = _rl_screenwidth / 3;
d746 1
a746 1
      if (phys_c_pos > _rl_screenwidth - 2)
d756 1
a756 1
      else if (ndisp < _rl_screenwidth - 2)		/* XXX - was -1 */
d778 1
a778 1
      t = lmargin + M_OFFSET (lmargin, wrap_offset) + _rl_screenwidth;
d788 2
a789 2
		       _rl_screenwidth + visible_wrap_offset,
		       _rl_screenwidth + (lmargin ? 0 : wrap_offset),
d800 1
a800 1
	      nleft = _rl_screenwidth - t;
d804 2
a805 2
	  if (visible_first_line_len > _rl_screenwidth)
	    visible_first_line_len = _rl_screenwidth;
d815 1
a815 1
    char *vtemp = visible_line;
d819 1
a819 1
    invisible_line = vtemp;
a861 5
  int col_lendiff, col_temp;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps_new, ps_old;
  int new_offset, old_offset, tmp;
#endif
d869 2
a870 2
  if (temp == _rl_screenwidth && _rl_term_autowrap && !_rl_horizontal_scroll_mode
	&& _rl_last_v_pos == current_line - 1)
d872 2
a873 54
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  wchar_t wc;
	  mbstate_t ps;
	  int tempwidth, bytes;
	  size_t ret;

	  /* This fixes only double-column characters, but if the wrapped
	     character comsumes more than three columns, spaces will be
	     inserted in the string buffer. */
	  if (_rl_wrapped_line[current_line] > 0)
	    _rl_clear_to_eol (_rl_wrapped_line[current_line]);

	  memset (&ps, 0, sizeof (mbstate_t));
	  ret = mbrtowc (&wc, new, MB_CUR_MAX, &ps);
	  if (ret == (size_t)-1 || ret == (size_t)-2)
	    {
	      tempwidth = 1;
	      ret = 1;
	    }
	  else if (ret == 0)
	    tempwidth = 0;
	  else
	    tempwidth = wcwidth (wc);

	  if (tempwidth > 0)
	    {
	      int count;
	      bytes = ret;
	      for (count = 0; count < bytes; count++)
		putc (new[count], rl_outstream);
	      _rl_last_c_pos = tempwidth;
	      _rl_last_v_pos++;
	      memset (&ps, 0, sizeof (mbstate_t));
	      ret = mbrtowc (&wc, old, MB_CUR_MAX, &ps);
	      if (ret != 0 && bytes != 0)
		{
		  if (ret == (size_t)-1 || ret == (size_t)-2)
		    memmove (old+bytes, old+1, strlen (old+1));
		  else
		    memmove (old+bytes, old+ret, strlen (old+ret));
		  memcpy (old, new, bytes);
		}
	    }
	  else
	    {
	      putc (' ', rl_outstream);
	      _rl_last_c_pos = 1;
	      _rl_last_v_pos++;
	      if (old[0] && new[0])
		old[0] = new[0];
	    }
	}
d875 5
a879 11
#endif
	{
	  if (new[0])
	    putc (new[0], rl_outstream);
	  else
	    putc (' ', rl_outstream);
	  _rl_last_c_pos = 1;		/* XXX */
	  _rl_last_v_pos++;
	  if (old[0] && new[0])
	    old[0] = new[0];
	}
a880 1

a882 19
#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      memset (&ps_new, 0, sizeof(mbstate_t));
      memset (&ps_old, 0, sizeof(mbstate_t));

      new_offset = old_offset = 0;
      for (ofd = old, nfd = new;
	   (ofd - old < omax) && *ofd &&
	     _rl_compare_chars(old, old_offset, &ps_old, new, new_offset, &ps_new); )
	{
	  old_offset = _rl_find_next_mbchar (old, old_offset, 1, MB_FIND_ANY);
	  new_offset = _rl_find_next_mbchar (new, new_offset, 1, MB_FIND_ANY);
	  ofd = old + old_offset;
	  nfd = new + new_offset;
	}
    }
  else
#endif
a898 27

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      ols = old + _rl_find_prev_mbchar (old, oe - old, MB_FIND_ANY);
      nls = new + _rl_find_prev_mbchar (new, ne - new, MB_FIND_ANY);
      while ((ols > ofd) && (nls > nfd))
	{
	  memset (&ps_old, 0, sizeof (mbstate_t));
	  memset (&ps_new, 0, sizeof (mbstate_t));

	  _rl_adjust_point (old, ols - old, &ps_old);
	  _rl_adjust_point (new, nls - new, &ps_new);

	  if (_rl_compare_chars (old, ols - old, &ps_old, new, nls - new, &ps_new) == 0)
	    break;

	  if (*ols == ' ')
	    wsatend = 0;

	  ols = old + _rl_find_prev_mbchar (old, ols - old, MB_FIND_ANY);
	  nls = new + _rl_find_prev_mbchar (new, nls - new, MB_FIND_ANY);
	}
    }
  else
    {
#endif /* HANDLE_MULTIBYTE */
a907 3
#if defined (HANDLE_MULTIBYTE)
    }
#endif
a913 6
#if defined (HANDLE_MULTIBYTE)
  /* This may not work for stateful encoding, but who cares?  To handle
     stateful encoding properly, we have to scan each string from the
     beginning and compare. */
  else if (_rl_compare_chars (ols, 0, NULL, nls, 0, NULL) == 0)
#else
a914 1
#endif
d917 1
a917 6
	{
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    ols = old + _rl_find_next_mbchar (old, ols - old, 1, MB_FIND_ANY);
	  else
	    ols++;
	}
d919 1
a919 6
	{
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    nls = new + _rl_find_next_mbchar (new, nls - new, 1, MB_FIND_ANY);
	  else
	    nls++;
	}
d946 2
a947 2
      _rl_term_cr && lendiff > prompt_visible_length && _rl_last_c_pos > 0 &&
      od >= lendiff && _rl_last_c_pos <= prompt_last_invisible)
d952 1
a952 1
      tputs (_rl_term_cr, 1, _rl_output_character_function);
d955 1
a955 4
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	_rl_last_c_pos = _rl_col_width (local_prompt, 0, lendiff);
      else
	_rl_last_c_pos = lendiff;
d960 1
a960 4
  /* if (len (new) > len (old))
     lendiff == difference in buffer
     col_lendiff == difference on screen
     When not using multibyte characters, these are equal */
a961 4
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    col_lendiff = _rl_col_width (new, nfd - new, nls - new) - _rl_col_width (old, ofd - old, ols - old);
  else
    col_lendiff = lendiff;
d968 1
a968 12
    {
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  lendiff += visible_wrap_offset - current_invis_chars;
	  col_lendiff += visible_wrap_offset - current_invis_chars;
	}
      else
	{
	  lendiff += visible_wrap_offset - current_invis_chars;
	  col_lendiff = lendiff;
	}
    }
d972 1
a972 6
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    col_temp = _rl_col_width (new, nfd - new, ne - new);
  else
    col_temp = temp;

  if (col_lendiff > 0)	/* XXX - was lendiff */
d980 1
a980 1
      if (_rl_terminal_can_insert && ((2 * col_temp) >= col_lendiff || _rl_term_IC) && (!_rl_term_autowrap || !gl))
d982 1
a982 1
	  /* If lendiff > prompt_visible_length and _rl_last_c_pos == 0 and
d984 1
a984 1
	     _rl_term_IC or _rl_term_ic will screw up the screen because of the
d987 1
a987 1
			lendiff <= prompt_visible_length || !current_invis_chars))
d989 2
a990 2
	      insert_some_chars (nfd, lendiff, col_lendiff);
	      _rl_last_c_pos += col_lendiff;
d999 1
a999 1
	      _rl_last_c_pos += col_lendiff;
d1007 1
a1007 1
	      _rl_last_c_pos += col_temp;
d1015 1
a1015 5
#if 0
	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-col_lendiff);
#else
	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-lendiff);
#endif
d1022 1
a1022 1
	  _rl_last_c_pos += col_temp;
d1028 1
a1028 1
      if (_rl_term_dc && (2 * col_temp) >= -col_lendiff)
d1035 1
a1035 1
	    col_lendiff = 0;
d1037 2
a1038 2
	  if (col_lendiff)
	    delete_chars (-col_lendiff); /* delete (diff) characters */
d1045 1
a1045 1
	      _rl_last_c_pos += _rl_col_width (nfd, 0, temp);;
d1054 1
a1054 1
	      _rl_last_c_pos += col_temp;
d1057 1
a1057 6
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    col_lendiff = _rl_col_width (old, 0, oe - old) - _rl_col_width (new, 0, ne - new);
	  else
	    col_lendiff = lendiff;

	  if (col_lendiff)
d1060 1
a1060 1
		space_to_eol (col_lendiff);
d1062 1
a1062 1
		_rl_clear_to_eol (col_lendiff);
d1108 1
a1108 4
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    _rl_last_c_pos = _rl_col_width (prompt_last_line, 0, l);
  else
    _rl_last_c_pos = l;
d1113 1
a1113 1
  real_screenwidth = _rl_screenwidth + (_rl_term_autowrap ? 0 : 1);
d1158 1
a1158 1
     const char *data;
a1162 13
#if defined (HANDLE_MULTIBYTE)
  /* If we have multibyte characters, NEW is indexed by the buffer point in
     a multibyte string, but _rl_last_c_pos is the display position.  In
     this case, NEW's display position is not obvious and must be
     calculated. */
  if (MB_CUR_MAX == 1 || rl_byte_oriented)
    {
      if (_rl_last_c_pos == new)
	return;
    }
  else if (_rl_last_c_pos == _rl_col_width (data, 0, new))
    return;
#else
a1163 1
#endif
d1170 1
a1170 1
      (_rl_term_autowrap && i == _rl_screenwidth))
d1175 1
a1175 1
      tputs (_rl_term_cr, 1, _rl_output_character_function);
d1192 1
a1192 22
      if (_rl_term_forward_char)
	{
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      int width;
	      width = _rl_col_width (data, _rl_last_c_pos, new);
	      for (i = 0; i < width; i++)
		tputs (_rl_term_forward_char, 1, _rl_output_character_function);
	    }
	  else
	    {
	      for (i = _rl_last_c_pos; i < new; i++)
		tputs (_rl_term_forward_char, 1, _rl_output_character_function);
	    }
	}
      else if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  tputs (_rl_term_cr, 1, _rl_output_character_function);
	  for (i = 0; i < new; i++)
	    putc (data[i], rl_outstream);
	}
      else
d1194 1
a1194 10
	  putc (data[i], rl_outstream);

#else /* !HACK_TERMCAP_MOTION */

      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  tputs (_rl_term_cr, 1, _rl_output_character_function);
	  for (i = 0; i < new; i++)
	    putc (data[i], rl_outstream);
	}
d1198 4
a1201 3

#endif /* !HACK_TERMCAP_MOTION */

a1202 7
#if defined (HANDLE_MULTIBYTE)
  /* NEW points to the buffer point, but _rl_last_c_pos is the display point.
     The byte length of the string is probably bigger than the column width
     of the string, which means that if NEW == _rl_last_c_pos, then NEW's
     display point is less than _rl_last_c_pos. */
  else if (_rl_last_c_pos >= new)
#else
d1204 2
a1205 12
#endif
    {
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	_rl_backspace (_rl_last_c_pos - _rl_col_width (data, 0, new));
      else
	_rl_backspace (_rl_last_c_pos - new);
    }

  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    _rl_last_c_pos =  _rl_col_width (data, 0, new);
  else
    _rl_last_c_pos = new;
d1215 1
a1215 1
  if (_rl_last_v_pos == to || to > _rl_screenheight)
d1225 1
a1225 1
      tputs (_rl_term_cr, 1, _rl_output_character_function);
d1234 1
a1234 1
      l = fflush (rl_outstream); /* make sure the cursor pos is current! */
d1239 1
a1239 1
      if (_rl_term_up && *_rl_term_up)
d1241 1
a1241 1
	  tputs (_rl_term_up, 1, _rl_output_character_function);
d1301 1
a1301 1
  return ((ISPRINT (uc)) ? 1 : 2);
a1327 3
#if defined (HAVE_VSNPRINTF)
  vsnprintf (msg_buf, sizeof (msg_buf) - 1, format, args);
#else
a1328 2
  msg_buf[sizeof(msg_buf) - 1] = '\0';	/* overflow? */
#endif
a1340 1
  msg_buf[sizeof(msg_buf) - 1] = '\0';	/* overflow? */
d1376 2
a1377 2
  saved_last_invisible = prompt_last_invisible;
  saved_visible_length = prompt_visible_length;
d1380 1
a1380 1
  prompt_last_invisible = prompt_visible_length = 0;
d1386 4
a1389 2
  FREE (local_prompt);
  FREE (local_prompt_prefix);
d1393 2
a1394 2
  prompt_last_invisible = saved_last_invisible;
  prompt_visible_length = saved_visible_length;
d1409 1
a1409 1
      pmt = (char *)xmalloc (len + 2);
d1418 1
a1418 1
      pmt = (char *)xmalloc (len + 2);
d1424 2
a1425 2
      prompt_last_invisible = saved_last_invisible;
      prompt_visible_length = saved_visible_length + 1;
d1453 2
a1454 2
  if (_rl_term_clreol)
    tputs (_rl_term_clreol, 1, _rl_output_character_function);
d1482 2
a1483 2
  if (_rl_term_clrpag)
    tputs (_rl_term_clrpag, 1, _rl_output_character_function);
d1485 1
a1485 1
    rl_crlf ();
d1489 1
a1489 1
/* Insert COUNT characters from STRING to the output stream at column COL. */
d1491 1
a1491 1
insert_some_chars (string, count, col)
d1493 1
a1493 1
     int count, col;
a1497 5
  /* DEBUGGING */
  if (MB_CUR_MAX == 1 || rl_byte_oriented)
    if (count != col)
      fprintf(stderr, "readline: debug: insert_some_chars: count (%d) != col (%d)\n", count, col);

d1499 1
a1499 1
  if (_rl_term_IC)
d1502 1
a1502 2

      buffer = tgoto (_rl_term_IC, 0, col);
d1511 2
a1512 2
      if (_rl_term_im && *_rl_term_im)
	tputs (_rl_term_im, 1, _rl_output_character_function);
d1516 1
a1516 1
      if (_rl_term_ic && *_rl_term_ic)
d1518 2
a1519 2
	  for (i = col; i--; )
	    tputs (_rl_term_ic, 1, _rl_output_character_function);
d1527 2
a1528 2
      if (_rl_term_ei && *_rl_term_ei)
	tputs (_rl_term_ei, 1, _rl_output_character_function);
d1538 1
a1538 1
  if (count > _rl_screenwidth)	/* XXX */
d1542 1
a1542 1
  if (_rl_term_DC && *_rl_term_DC)
d1545 1
a1545 1
      buffer = tgoto (_rl_term_DC, count, count);
d1550 1
a1550 1
      if (_rl_term_dc && *_rl_term_dc)
d1552 1
a1552 1
	  tputs (_rl_term_dc, 1, _rl_output_character_function);
d1573 1
a1573 1
  if (full_lines && _rl_term_autowrap && (VIS_LLEN(_rl_vis_botlin) == _rl_screenwidth))
d1576 3
a1578 1

d1580 2
a1581 1
      _rl_move_cursor_relative (_rl_screenwidth - 1, last_line);
d1583 1
a1583 1
      putc (last_line[_rl_screenwidth - 1], rl_outstream);
d1586 1
a1586 1
  rl_crlf ();
d1595 1
a1595 1
  if (_rl_term_cr)
d1600 1
a1600 1
      tputs (_rl_term_cr, 1, _rl_output_character_function);
d1614 1
a1614 1
  int oldlen, oldlast, oldplen, oldninvis;
d1620 3
a1622 4
  oldlen = prompt_visible_length;
  oldplen = prompt_prefix_length;
  oldlast = prompt_last_invisible;
  oldninvis = prompt_invis_chars_first_line;
d1625 1
a1625 3
  local_prompt = expand_prompt (t, &prompt_visible_length,
				   &prompt_last_invisible,
				   &prompt_invis_chars_first_line);
d1632 3
a1634 4
  prompt_visible_length = oldlen;
  prompt_prefix_length = oldplen;
  prompt_last_invisible = oldlast;
  prompt_invis_chars_first_line = oldninvis;
d1645 1
a1645 1
  if (_rl_term_cr)
d1650 1
a1650 1
      tputs (_rl_term_cr, 1, _rl_output_character_function);
d1654 1
a1654 1
      space_to_eol (_rl_screenwidth);
d1657 2
a1658 2
      if (_rl_term_clreol)
	tputs (_rl_term_clreol, 1, _rl_output_character_function);
d1661 2
a1662 2
	  space_to_eol (_rl_screenwidth);
	  tputs (_rl_term_cr, 1, _rl_output_character_function);
d1669 1
a1669 1
    rl_crlf ();
d1710 1
a1710 1
    nleft = _rl_last_c_pos - _rl_screenwidth - rl_visible_prompt_length;
d1712 1
a1712 1
    nleft = _rl_last_c_pos - _rl_screenwidth;
d1715 1
a1715 1
    ret = 1 + nleft / _rl_screenwidth;
a1720 83

#if defined (HANDLE_MULTIBYTE)
/* Calculate the number of screen columns occupied by STR from START to END.
   In the case of multibyte characters with stateful encoding, we have to
   scan from the beginning of the string to take the state into account. */
static int
_rl_col_width (str, start, end)
     const char *str;
     int start, end;
{
  wchar_t wc;
  mbstate_t ps = {0};
  int tmp, point, width, max;

  if (end <= start)
    return 0;

  point = 0;
  max = end;

  while (point < start)
    {
      tmp = mbrlen (str + point, max, &ps);
      if ((size_t)tmp == (size_t)-1 || (size_t)tmp == (size_t)-2)
	{
	  /* In this case, the bytes are invalid or too short to compose a
	     multibyte character, so we assume that the first byte represents
	     a single character. */
	  point++;
	  max--;

	  /* Clear the state of the byte sequence, because in this case the
	     effect of mbstate is undefined. */
	  memset (&ps, 0, sizeof (mbstate_t));
	}
      else if (tmp == 0)
        break;		/* Found '\0' */
      else
	{
	  point += tmp;
	  max -= tmp;
	}
    }

  /* If START is not a byte that starts a character, then POINT will be
     greater than START.  In this case, assume that (POINT - START) gives
     a byte count that is the number of columns of difference. */
  width = point - start;

  while (point < end)
    {
      tmp = mbrtowc (&wc, str + point, max, &ps);
      if ((size_t)tmp == (size_t)-1 || (size_t)tmp == (size_t)-2)
	{
	  /* In this case, the bytes are invalid or too short to compose a
	     multibyte character, so we assume that the first byte represents
	     a single character. */
	  point++;
	  max--;

	  /* and assume that the byte occupies a single column. */
	  width++;

	  /* Clear the state of the byte sequence, because in this case the
	     effect of mbstate is undefined. */
	  memset (&ps, 0, sizeof (mbstate_t));
	}
      else if (tmp == 0)
        break;			/* Found '\0' */
      else
	{
	  point += tmp;
	  max -= tmp;
	  tmp = wcwidth(wc);
	  width += (tmp >= 0) ? tmp : 1;
	}
    }

  width += point - end;

  return width;
}
#endif /* HANDLE_MULTIBYTE */
@


1.5.24.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d1645 1
a1645 1
      fflush (rl_outstream); /* make sure the cursor pos is current! */
d1647 2
a1648 2
      ScreenSetCursor (row + delta, col);
      i = -delta;    /* in case someone wants to use it after the loop */
@


1.5.22.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a49 1
#include "rlmbutil.h"
d66 1
a66 1
extern char *_rl_term_forward_char;
d69 5
a73 12
static void update_line PARAMS((char *, char *, int, int, int, int));
static void space_to_eol PARAMS((int));
static void delete_chars PARAMS((int));
static void insert_some_chars PARAMS((char *, int, int));
static void cr PARAMS((void));

#if defined (HANDLE_MULTIBYTE)
static int _rl_col_width PARAMS((char *, int, int));
static int *_rl_wrapped_line;
#else
#  define _rl_col_width(l, s, e)	(((e) <= (s)) ? 0 : (e) - (s))
#endif
d110 1
a110 1
rl_voidfunc_t *rl_redisplay_function = rl_redisplay;
a148 3
/* Variables to keep track of the expanded prompt string, which may
   include invisible characters. */

d150 1
a150 1
static int prompt_visible_length, prompt_prefix_length;
d156 1
a156 2
/* The number of invisible characters in the prompt string.  Static so it
   can be shared between rl_redisplay and update_line */
d159 2
a160 2
/* The index of the last invisible character in the prompt string. */
static int prompt_last_invisible;
a165 7
/* Number of invisible characters on the first physical line of the prompt.
   Only valid when the number of physical characters in the prompt exceeds
   (or is equal to) _rl_screenwidth. */
static int prompt_invis_chars_first_line;

static int prompt_last_screen_line;

d169 1
a169 3
   index of the last invisible character in the returned string. NIFLP,
   if non-zero, is a place to store the number of invisible characters in
   the first prompt line. */
d179 1
a179 1
expand_prompt (pmt, lp, lip, niflp)
d181 1
a181 1
     int *lp, *lip, *niflp;
d184 1
a184 1
  int l, rl, last, ignoring, ninvis, invfl;
d196 3
a198 5
  r = ret = (char *)xmalloc (l + 1);

  invfl = 0;	/* invisible chars in first line of prompt */

  for (rl = ignoring = last = ninvis = 0, p = pmt; p && *p; p++)
a217 4
	  else
	    ninvis++;
	  if (rl == _rl_screenwidth)
	    invfl = ninvis;
a220 3
  if (rl < _rl_screenwidth)
    invfl = ninvis;

a225 2
  if (niflp)
    *niflp = invfl;
d237 1
a237 1
  ret = expand_prompt (pmt, (int *)NULL, (int *)NULL, (int *)NULL);
d249 2
a250 2
 * prompt_visible_length = number of visible characters in local_prompt
 * prompt_prefix_length = number of visible characters in local_prompt_prefix
d266 4
a269 3
  FREE (local_prompt);
  FREE (local_prompt_prefix);

d271 1
a271 1
  prompt_last_invisible = prompt_visible_length = 0;
d279 2
a280 4
      /* The prompt is only one logical line, though it might wrap. */
      local_prompt = expand_prompt (prompt, &prompt_visible_length,
					    &prompt_last_invisible,
					    &prompt_invis_chars_first_line);
d282 1
a282 1
      return (prompt_visible_length);
d288 1
a288 3
      local_prompt = expand_prompt (p, &prompt_visible_length,
				       &prompt_last_invisible,
				       &prompt_invis_chars_first_line);
d292 1
a292 3
      local_prompt_prefix = expand_prompt (prompt, &prompt_prefix_length,
						   (int *)NULL,
						   &prompt_invis_chars_first_line);
d294 1
a294 1
      return (prompt_prefix_length);
d313 2
a314 2
      visible_line = (char *)xmalloc (line_size);
      invisible_line = (char *)xmalloc (line_size);
d321 2
a322 2
      visible_line = (char *)xrealloc (visible_line, line_size);
      invisible_line = (char *)xrealloc (invisible_line, line_size);
a336 3
#if defined (HANDLE_MULTIBYTE)
      _rl_wrapped_line = (int *)xmalloc (vis_lbsize * sizeof (int));
#endif
a349 7
#if defined (HANDLE_MULTIBYTE)
  wchar_t wc;
  size_t wc_bytes;
  int wc_width;
  mbstate_t ps;
  int _rl_wrapped_multicolumn = 0;
#endif
d399 2
a400 2
	      visible_line = (char *)xrealloc (visible_line, line_size);
	      line = invisible_line = (char *)xrealloc (invisible_line, line_size);
d406 1
a406 1
      wrap_offset = local_len - prompt_visible_length;
d433 2
a434 2
	  visible_line = (char *)xrealloc (visible_line, line_size);
	  line = invisible_line = (char *)xrealloc (invisible_line, line_size);
d439 1
a439 1
      wrap_offset = prompt_invis_chars_first_line = 0;
d450 1
a450 19

#if defined (HANDLE_MULTIBYTE)	  
#define CHECK_LPOS() \
      do { \
	lpos++; \
	if (lpos >= _rl_screenwidth) \
	  { \
	    if (newlines >= (inv_lbsize - 2)) \
	      { \
		inv_lbsize *= 2; \
		inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \
		_rl_wrapped_line = (int *)xrealloc (_rl_wrapped_line, inv_lbsize * sizeof (int)); \
	      } \
	    inv_lbreaks[++newlines] = out; \
	    _rl_wrapped_line[newlines] = _rl_wrapped_multicolumn; \
	    lpos = 0; \
	  } \
      } while (0)
#else
d454 1
a454 1
	if (lpos >= _rl_screenwidth) \
a464 1
#endif
a468 8
#if defined (HANDLE_MULTIBYTE)
  memset (_rl_wrapped_line, 0, vis_lbsize);
#endif

  /* prompt_invis_chars_first_line is the number of invisible characters in
     the first physical line of the prompt.
     wrap_offset - prompt_invis_chars_first_line is the number of invis
     chars on the second line. */
d470 1
a470 1
  /* what if lpos is already >= _rl_screenwidth before we start drawing the
d472 1
a472 1
  while (lpos >= _rl_screenwidth)
d474 6
a479 13
      /* fix from Darin Johnson <darin@@acuson.com> for prompt string with
         invisible characters that is longer than the screen width.  The
         prompt_invis_chars_first_line variable could be made into an array
         saying how many invisible characters there are per line, but that's
         probably too much work for the benefit gained.  How many people have
         prompts that exceed two physical lines? */
      temp = ((newlines + 1) * _rl_screenwidth) +
#if 0
             ((newlines == 0) ? prompt_invis_chars_first_line : 0) +
#else
             ((newlines == 0 && local_prompt_prefix == 0) ? prompt_invis_chars_first_line : 0) +
#endif
             ((newlines == 1) ? wrap_offset : 0);
d482 1
a482 1
      lpos -= _rl_screenwidth;
a484 7
  prompt_last_screen_line = newlines;

  /* Draw the rest of the line (after the prompt) into invisible_line, keeping
     track of where the cursor is (c_pos), the number of the line containing
     the cursor (lb_linenum), the last line number (lb_botlin and inv_botlin).
     It maintains an array of line breaks for display (inv_lbreaks).
     This handles expanding tabs for display and displaying meta characters. */
a485 11
#if defined (HANDLE_MULTIBYTE)
  in = 0;
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      memset (&ps, 0, sizeof (mbstate_t));
      wc_bytes = mbrtowc (&wc, rl_line_buffer, rl_end, &ps);
    }
  else
    wc_bytes = 1;
  while (in < rl_end)
#else
a486 1
#endif
a489 22
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  if (wc_bytes == (size_t)-1 || wc_bytes == (size_t)-2)
	    {
	      /* Byte sequence is invalid or shortened.  Assume that the
	         first byte represents a character. */
	      wc_bytes = 1;
	      /* Assume that a character occupies a single column. */
	      wc_width = 1;
	      memset (&ps, 0, sizeof (mbstate_t));
	    }
	  else if (wc_bytes == (size_t)0)
	    break;			/* Found '\0' */
	  else
	    {
	      temp = wcwidth (wc);
	      wc_width = (temp < 0) ? 1 : temp;
	    }
	}
#endif

d493 2
a494 2
	  visible_line = (char *)xrealloc (visible_line, line_size);
	  invisible_line = (char *)xrealloc (invisible_line, line_size);
a503 3
#if defined (HANDLE_MULTIBYTE)
      if (META_CHAR (c) && _rl_output_meta_chars == 0)	/* XXX - clean up */
#else
a504 1
#endif
d510 1
a510 1
	      if (lpos + 4 >= _rl_screenwidth)
d512 1
a512 1
		  temp = _rl_screenwidth - lpos;
d531 1
a531 1
	  register int newout;
d539 1
a539 1
	  if (lpos + temp >= _rl_screenwidth)
d542 1
a542 1
	      temp2 = _rl_screenwidth - lpos;
d557 1
a557 1
      else if (c == '\n' && _rl_horizontal_scroll_mode == 0 && _rl_term_up && *_rl_term_up)
a572 31
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      register int i;

	      _rl_wrapped_multicolumn = 0;

	      if (_rl_screenwidth < lpos + wc_width)
		for (i = lpos; i < _rl_screenwidth; i++)
		  {
		    /* The space will be removed in update_line() */
		    line[out++] = ' ';
		    _rl_wrapped_multicolumn++;
		    CHECK_LPOS();
		  }
	      if (in == rl_point)
		{
		  c_pos = out;
		  lb_linenum = newlines;
		}
	      for (i = in; i < in+wc_bytes; i++)
		line[out++] = rl_line_buffer[i];
	      for (i = 0; i < wc_width; i++)
		CHECK_LPOS();
	    }
	  else
	    {
	      line[out++] = c;
	      CHECK_LPOS();
	    }
#else
a574 8
#endif
	}

#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  in += wc_bytes;
	  wc_bytes = mbrtowc (&wc, rl_line_buffer + in, rl_end - in, &ps);
a575 4
      else
        in++;
#endif

d589 1
a589 2
  /* C_POS == position in buffer where cursor should be placed.
     CURSOR_LINENUM == line number where the cursor should be placed. */
d600 1
a600 1
  if (_rl_horizontal_scroll_mode == 0 && _rl_term_up && *_rl_term_up)
d611 2
a612 7
	  if (out >= _rl_screenchars)
	    {
	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		out = _rl_find_prev_mbchar (line, _rl_screenchars, MB_FIND_ANY);
	      else
		out = _rl_screenchars - 1;
	    }
d642 1
a642 1
		  nleft = _rl_screenwidth + wrap_offset - _rl_last_c_pos;
d663 1
a663 1
		    ((linenum == _rl_vis_botlin) ? strlen (tt) : _rl_screenwidth);
d674 1
a674 1
	      /* If we moved up to the line with the prompt using _rl_term_up,
d687 1
a687 1
	  nleft = prompt_visible_length + wrap_offset;
d689 1
a689 1
	      _rl_last_c_pos <= prompt_last_invisible && local_prompt)
d694 2
a695 2
	      if (_rl_term_cr)
		tputs (_rl_term_cr, 1, _rl_output_character_function);
d698 1
a698 4
	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		_rl_last_c_pos = _rl_col_width(local_prompt, 0, nleft);
	      else
		_rl_last_c_pos = nleft;
d714 1
a714 4
	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		_rl_last_c_pos = _rl_col_width (&visible_line[pos], 0, nleft);
	      else
		_rl_last_c_pos = nleft;
d717 1
a717 3
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    _rl_move_cursor_relative (nleft, &invisible_line[pos]);
	  else if (nleft != _rl_last_c_pos)
d734 1
a734 1
      nleft  = prompt_visible_length + wrap_offset;
d738 1
a738 1
      t = _rl_screenwidth / 3;
d746 1
a746 1
      if (phys_c_pos > _rl_screenwidth - 2)
d756 1
a756 1
      else if (ndisp < _rl_screenwidth - 2)		/* XXX - was -1 */
d778 1
a778 1
      t = lmargin + M_OFFSET (lmargin, wrap_offset) + _rl_screenwidth;
d788 2
a789 2
		       _rl_screenwidth + visible_wrap_offset,
		       _rl_screenwidth + (lmargin ? 0 : wrap_offset),
d800 1
a800 1
	      nleft = _rl_screenwidth - t;
d804 2
a805 2
	  if (visible_first_line_len > _rl_screenwidth)
	    visible_first_line_len = _rl_screenwidth;
d815 1
a815 1
    char *vtemp = visible_line;
d819 1
a819 1
    invisible_line = vtemp;
a861 5
  int col_lendiff, col_temp;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps_new, ps_old;
  int new_offset, old_offset, tmp;
#endif
d869 2
a870 2
  if (temp == _rl_screenwidth && _rl_term_autowrap && !_rl_horizontal_scroll_mode
	&& _rl_last_v_pos == current_line - 1)
d872 2
a873 54
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  wchar_t wc;
	  mbstate_t ps;
	  int tempwidth, bytes;
	  size_t ret;

	  /* This fixes only double-column characters, but if the wrapped
	     character comsumes more than three columns, spaces will be
	     inserted in the string buffer. */
	  if (_rl_wrapped_line[current_line] > 0)
	    _rl_clear_to_eol (_rl_wrapped_line[current_line]);

	  memset (&ps, 0, sizeof (mbstate_t));
	  ret = mbrtowc (&wc, new, MB_CUR_MAX, &ps);
	  if (ret == (size_t)-1 || ret == (size_t)-2)
	    {
	      tempwidth = 1;
	      ret = 1;
	    }
	  else if (ret == 0)
	    tempwidth = 0;
	  else
	    tempwidth = wcwidth (wc);

	  if (tempwidth > 0)
	    {
	      int count;
	      bytes = ret;
	      for (count = 0; count < bytes; count++)
		putc (new[count], rl_outstream);
	      _rl_last_c_pos = tempwidth;
	      _rl_last_v_pos++;
	      memset (&ps, 0, sizeof (mbstate_t));
	      ret = mbrtowc (&wc, old, MB_CUR_MAX, &ps);
	      if (ret != 0 && bytes != 0)
		{
		  if (ret == (size_t)-1 || ret == (size_t)-2)
		    memmove (old+bytes, old+1, strlen (old+1));
		  else
		    memmove (old+bytes, old+ret, strlen (old+ret));
		  memcpy (old, new, bytes);
		}
	    }
	  else
	    {
	      putc (' ', rl_outstream);
	      _rl_last_c_pos = 1;
	      _rl_last_v_pos++;
	      if (old[0] && new[0])
		old[0] = new[0];
	    }
	}
d875 5
a879 11
#endif
	{
	  if (new[0])
	    putc (new[0], rl_outstream);
	  else
	    putc (' ', rl_outstream);
	  _rl_last_c_pos = 1;		/* XXX */
	  _rl_last_v_pos++;
	  if (old[0] && new[0])
	    old[0] = new[0];
	}
a880 1

a882 19
#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      memset (&ps_new, 0, sizeof(mbstate_t));
      memset (&ps_old, 0, sizeof(mbstate_t));

      new_offset = old_offset = 0;
      for (ofd = old, nfd = new;
	   (ofd - old < omax) && *ofd &&
	     _rl_compare_chars(old, old_offset, &ps_old, new, new_offset, &ps_new); )
	{
	  old_offset = _rl_find_next_mbchar (old, old_offset, 1, MB_FIND_ANY);
	  new_offset = _rl_find_next_mbchar (new, new_offset, 1, MB_FIND_ANY);
	  ofd = old + old_offset;
	  nfd = new + new_offset;
	}
    }
  else
#endif
a898 27

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      ols = old + _rl_find_prev_mbchar (old, oe - old, MB_FIND_ANY);
      nls = new + _rl_find_prev_mbchar (new, ne - new, MB_FIND_ANY);
      while ((ols > ofd) && (nls > nfd))
	{
	  memset (&ps_old, 0, sizeof (mbstate_t));
	  memset (&ps_new, 0, sizeof (mbstate_t));

	  _rl_adjust_point (old, ols - old, &ps_old);
	  _rl_adjust_point (new, nls - new, &ps_new);

	  if (_rl_compare_chars (old, ols - old, &ps_old, new, nls - new, &ps_new) == 0)
	    break;

	  if (*ols == ' ')
	    wsatend = 0;

	  ols = old + _rl_find_prev_mbchar (old, ols - old, MB_FIND_ANY);
	  nls = new + _rl_find_prev_mbchar (new, nls - new, MB_FIND_ANY);
	}
    }
  else
    {
#endif /* HANDLE_MULTIBYTE */
a907 3
#if defined (HANDLE_MULTIBYTE)
    }
#endif
a913 6
#if defined (HANDLE_MULTIBYTE)
  /* This may not work for stateful encoding, but who cares?  To handle
     stateful encoding properly, we have to scan each string from the
     beginning and compare. */
  else if (_rl_compare_chars (ols, 0, NULL, nls, 0, NULL) == 0)
#else
a914 1
#endif
d917 1
a917 6
	{
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    ols = old + _rl_find_next_mbchar (old, ols - old, 1, MB_FIND_ANY);
	  else
	    ols++;
	}
d919 1
a919 6
	{
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    nls = new + _rl_find_next_mbchar (new, nls - new, 1, MB_FIND_ANY);
	  else
	    nls++;
	}
d946 2
a947 2
      _rl_term_cr && lendiff > prompt_visible_length && _rl_last_c_pos > 0 &&
      od >= lendiff && _rl_last_c_pos <= prompt_last_invisible)
d952 1
a952 1
      tputs (_rl_term_cr, 1, _rl_output_character_function);
d955 1
a955 4
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	_rl_last_c_pos = _rl_col_width (local_prompt, 0, lendiff);
      else
	_rl_last_c_pos = lendiff;
d960 1
a960 4
  /* if (len (new) > len (old))
     lendiff == difference in buffer
     col_lendiff == difference on screen
     When not using multibyte characters, these are equal */
a961 4
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    col_lendiff = _rl_col_width (new, nfd - new, nls - new) - _rl_col_width (old, ofd - old, ols - old);
  else
    col_lendiff = lendiff;
d968 1
a968 12
    {
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  lendiff += visible_wrap_offset - current_invis_chars;
	  col_lendiff += visible_wrap_offset - current_invis_chars;
	}
      else
	{
	  lendiff += visible_wrap_offset - current_invis_chars;
	  col_lendiff = lendiff;
	}
    }
d972 1
a972 6
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    col_temp = _rl_col_width (new, nfd - new, ne - new);
  else
    col_temp = temp;

  if (col_lendiff > 0)	/* XXX - was lendiff */
d980 1
a980 1
      if (_rl_terminal_can_insert && ((2 * col_temp) >= col_lendiff || _rl_term_IC) && (!_rl_term_autowrap || !gl))
d982 1
a982 1
	  /* If lendiff > prompt_visible_length and _rl_last_c_pos == 0 and
d984 1
a984 1
	     _rl_term_IC or _rl_term_ic will screw up the screen because of the
d987 1
a987 1
			lendiff <= prompt_visible_length || !current_invis_chars))
d989 2
a990 2
	      insert_some_chars (nfd, lendiff, col_lendiff);
	      _rl_last_c_pos += col_lendiff;
d999 1
a999 1
	      _rl_last_c_pos += col_lendiff;
d1007 1
a1007 1
	      _rl_last_c_pos += col_temp;
d1015 1
a1015 5
#if 0
	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-lendiff) - col_lendiff;
#else
	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-col_lendiff);
#endif
d1022 1
a1022 1
	  _rl_last_c_pos += col_temp;
d1028 1
a1028 1
      if (_rl_term_dc && (2 * col_temp) >= -col_lendiff)
d1035 1
a1035 1
	    col_lendiff = 0;
d1037 2
a1038 2
	  if (col_lendiff)
	    delete_chars (-col_lendiff); /* delete (diff) characters */
d1045 1
a1045 1
	      _rl_last_c_pos += _rl_col_width (nfd, 0, temp);;
d1054 1
a1054 1
	      _rl_last_c_pos += col_temp;
d1057 1
a1057 6
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    col_lendiff = _rl_col_width (old, 0, oe - old) - _rl_col_width (new, 0, ne - new);
	  else
	    col_lendiff = lendiff;

	  if (col_lendiff)
d1060 1
a1060 1
		space_to_eol (col_lendiff);
d1062 1
a1062 1
		_rl_clear_to_eol (col_lendiff);
d1108 1
a1108 4
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    _rl_last_c_pos = _rl_col_width (prompt_last_line, 0, l);
  else
    _rl_last_c_pos = l;
d1113 1
a1113 1
  real_screenwidth = _rl_screenwidth + (_rl_term_autowrap ? 0 : 1);
d1158 1
a1158 1
     const char *data;
a1162 6
#if defined (HANDLE_MULTIBYTE)
  /* If we have multibyte characters, NEW is indexed by the buffer point in
     a multibyte string, but _rl_last_c_pos is the display position.  In
     this case, NEW's display position is not obvious. */
  if ((MB_CUR_MAX == 1 || rl_byte_oriented ) && _rl_last_c_pos == new) return;
#else
a1163 1
#endif
d1170 1
a1170 1
      (_rl_term_autowrap && i == _rl_screenwidth))
d1175 1
a1175 1
      tputs (_rl_term_cr, 1, _rl_output_character_function);
d1192 1
a1192 22
      if (_rl_term_forward_char)
	{
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      int width;
	      width = _rl_col_width (data, _rl_last_c_pos, new);
	      for (i = 0; i < width; i++)
		tputs (_rl_term_forward_char, 1, _rl_output_character_function);
	    }
	  else
	    {
	      for (i = _rl_last_c_pos; i < new; i++)
		tputs (_rl_term_forward_char, 1, _rl_output_character_function);
	    }
	}
      else if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  tputs (_rl_term_cr, 1, _rl_output_character_function);
	  for (i = 0; i < new; i++)
	    putc (data[i], rl_outstream);
	}
      else
d1194 1
a1194 10
	  putc (data[i], rl_outstream);

#else /* !HACK_TERMCAP_MOTION */

      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  tputs (_rl_term_cr, 1, _rl_output_character_function);
	  for (i = 0; i < new; i++)
	    putc (data[i], rl_outstream);
	}
d1198 4
a1201 3

#endif /* !HACK_TERMCAP_MOTION */

a1202 7
#if defined (HANDLE_MULTIBYTE)
  /* NEW points to the buffer point, but _rl_last_c_pos is the display point.
     The byte length of the string is probably bigger than the column width
     of the string, which means that if NEW == _rl_last_c_pos, then NEW's
     display point is less than _rl_last_c_pos. */
  else if (_rl_last_c_pos >= new)
#else
d1204 2
a1205 16
#endif
    {
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  tputs (_rl_term_cr, 1, _rl_output_character_function);
	  for (i = 0; i < new; i++)
	    putc (data[i], rl_outstream);
	}
      else
	_rl_backspace (_rl_last_c_pos - new);
    }

  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    _rl_last_c_pos =  _rl_col_width (data, 0, new);
  else
    _rl_last_c_pos = new;
d1215 1
a1215 1
  if (_rl_last_v_pos == to || to > _rl_screenheight)
d1225 1
a1225 1
      tputs (_rl_term_cr, 1, _rl_output_character_function);
d1234 1
a1234 1
      l = fflush (rl_outstream); /* make sure the cursor pos is current! */
d1239 1
a1239 1
      if (_rl_term_up && *_rl_term_up)
d1241 1
a1241 1
	  tputs (_rl_term_up, 1, _rl_output_character_function);
d1301 1
a1301 1
  return ((ISPRINT (uc)) ? 1 : 2);
a1327 3
#if defined (HAVE_VSNPRINTF)
  vsnprintf (msg_buf, sizeof (msg_buf) - 1, format, args);
#else
a1328 2
  msg_buf[sizeof(msg_buf) - 1] = '\0';	/* overflow? */
#endif
a1340 1
  msg_buf[sizeof(msg_buf) - 1] = '\0';	/* overflow? */
d1376 2
a1377 2
  saved_last_invisible = prompt_last_invisible;
  saved_visible_length = prompt_visible_length;
d1380 1
a1380 1
  prompt_last_invisible = prompt_visible_length = 0;
d1386 4
a1389 2
  FREE (local_prompt);
  FREE (local_prompt_prefix);
d1393 2
a1394 2
  prompt_last_invisible = saved_last_invisible;
  prompt_visible_length = saved_visible_length;
d1409 1
a1409 1
      pmt = (char *)xmalloc (len + 2);
d1418 1
a1418 1
      pmt = (char *)xmalloc (len + 2);
d1424 2
a1425 2
      prompt_last_invisible = saved_last_invisible;
      prompt_visible_length = saved_visible_length + 1;
d1453 2
a1454 2
  if (_rl_term_clreol)
    tputs (_rl_term_clreol, 1, _rl_output_character_function);
d1482 2
a1483 2
  if (_rl_term_clrpag)
    tputs (_rl_term_clrpag, 1, _rl_output_character_function);
d1485 1
a1485 1
    rl_crlf ();
d1489 1
a1489 1
/* Insert COUNT characters from STRING to the output stream at column COL. */
d1491 1
a1491 1
insert_some_chars (string, count, col)
d1493 1
a1493 1
     int count, col;
a1497 5
  /* DEBUGGING */
  if (MB_CUR_MAX == 1 || rl_byte_oriented)
    if (count != col)
      fprintf(stderr, "readline: debug: insert_some_chars: count (%d) != col (%d)\n", count, col);

d1499 1
a1499 1
  if (_rl_term_IC)
d1502 1
a1502 2

      buffer = tgoto (_rl_term_IC, 0, col);
d1511 2
a1512 2
      if (_rl_term_im && *_rl_term_im)
	tputs (_rl_term_im, 1, _rl_output_character_function);
d1516 1
a1516 1
      if (_rl_term_ic && *_rl_term_ic)
d1518 2
a1519 2
	  for (i = col; i--; )
	    tputs (_rl_term_ic, 1, _rl_output_character_function);
d1527 2
a1528 2
      if (_rl_term_ei && *_rl_term_ei)
	tputs (_rl_term_ei, 1, _rl_output_character_function);
d1538 1
a1538 1
  if (count > _rl_screenwidth)	/* XXX */
d1542 1
a1542 1
  if (_rl_term_DC && *_rl_term_DC)
d1545 1
a1545 1
      buffer = tgoto (_rl_term_DC, count, count);
d1550 1
a1550 1
      if (_rl_term_dc && *_rl_term_dc)
d1552 1
a1552 1
	  tputs (_rl_term_dc, 1, _rl_output_character_function);
d1573 1
a1573 1
  if (full_lines && _rl_term_autowrap && (VIS_LLEN(_rl_vis_botlin) == _rl_screenwidth))
d1576 3
a1578 1

d1580 2
a1581 1
      _rl_move_cursor_relative (_rl_screenwidth - 1, last_line);
d1583 1
a1583 1
      putc (last_line[_rl_screenwidth - 1], rl_outstream);
d1586 1
a1586 1
  rl_crlf ();
d1595 1
a1595 1
  if (_rl_term_cr)
d1600 1
a1600 1
      tputs (_rl_term_cr, 1, _rl_output_character_function);
d1614 1
a1614 1
  int oldlen, oldlast, oldplen, oldninvis;
d1620 3
a1622 4
  oldlen = prompt_visible_length;
  oldplen = prompt_prefix_length;
  oldlast = prompt_last_invisible;
  oldninvis = prompt_invis_chars_first_line;
d1625 1
a1625 3
  local_prompt = expand_prompt (t, &prompt_visible_length,
				   &prompt_last_invisible,
				   &prompt_invis_chars_first_line);
d1632 3
a1634 4
  prompt_visible_length = oldlen;
  prompt_prefix_length = oldplen;
  prompt_last_invisible = oldlast;
  prompt_invis_chars_first_line = oldninvis;
d1645 1
a1645 1
  if (_rl_term_cr)
d1650 1
a1650 1
      tputs (_rl_term_cr, 1, _rl_output_character_function);
d1654 1
a1654 1
      space_to_eol (_rl_screenwidth);
d1657 2
a1658 2
      if (_rl_term_clreol)
	tputs (_rl_term_clreol, 1, _rl_output_character_function);
d1661 2
a1662 2
	  space_to_eol (_rl_screenwidth);
	  tputs (_rl_term_cr, 1, _rl_output_character_function);
d1669 1
a1669 1
    rl_crlf ();
d1710 1
a1710 1
    nleft = _rl_last_c_pos - _rl_screenwidth - rl_visible_prompt_length;
d1712 1
a1712 1
    nleft = _rl_last_c_pos - _rl_screenwidth;
d1715 1
a1715 1
    ret = 1 + nleft / _rl_screenwidth;
a1720 84

#if defined (HANDLE_MULTIBYTE)
/* Calculate the number of screen columns occupied by STR from START to END.
   In the case of multibyte characters with stateful encoding, we have to
   scan from the beginning of the string to take the state into account. */
static int
_rl_col_width (str, start, end)
     char *str;
     int start, end;
{
  wchar_t wc;
  mbstate_t ps = {0};
  int tmp, point, width, max;

  if (end <= start)
    return 0;

  point = 0;
  max = end;

  while (point < start)
    {
      tmp = mbrlen (str + point, max, &ps);
      if ((size_t)tmp == (size_t)-1 || (size_t)tmp == (size_t)-2)
	{
	  /* In this case, the bytes are invalid or too short to compose a
	     multibyte character, so we assume that the first byte represents
	     a single character. */
	  point++;
	  max--;

	  /* Clear the state of the byte sequence, because in this case the
	     effect of mbstate is undefined. */
	  memset (&ps, 0, sizeof (mbstate_t));
	}
      else if (tmp == 0)
        break;		/* Found '\0' */
      else
	{
	  point += tmp;
	  max -= tmp;
	}
    }

  /* If START is not a byte that starts a character, then POINT will be
     greater than START.  In this case, assume that (POINT - START) gives
     a byte count that is the number of columns of difference. */
  width = point - start;

  while (point < end)
    {
      tmp = mbrtowc (&wc, str + point, max, &ps);
      if ((size_t)tmp == (size_t)-1 || (size_t)tmp == (size_t)-2)
	{
	  /* In this case, the bytes are invalid or too short to compose a
	     multibyte character, so we assume that the first byte represents
	     a single character. */
	  point++;
	  max--;

	  /* and assume that the byte occupies a single column. */
	  width++;

	  /* Clear the state of the byte sequence, because in this case the
	     effect of mbstate is undefined. */
	  memset (&ps, 0, sizeof (mbstate_t));
	}
      else if (tmp == 0)
        break;			/* Found '\0' */
      else
	{
	  point += tmp;
	  max -= tmp;
	  tmp = wcwidth(wc);
	  width += (tmp >= 0) ? tmp : 1;
	}
    }

  width += point - end;

  return width;
}
#endif /* HANDLE_MULTIBYTE */
	  
@


1.5.22.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d77 1
a77 1
static int _rl_col_width PARAMS((const char *, int, int));
d1355 2
a1357 2
#else
	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-lendiff);
d1517 2
a1518 9
     this case, NEW's display position is not obvious and must be
     calculated. */
  if (MB_CUR_MAX == 1 || rl_byte_oriented)
    {
      if (_rl_last_c_pos == new)
	return;
    }
  else if (_rl_last_c_pos == _rl_col_width (data, 0, new))
    return;
d1601 5
a1605 1
	_rl_backspace (_rl_last_c_pos - _rl_col_width (data, 0, new));
d2147 1
a2147 1
     const char *str;
d2223 1
@


1.5.22.3
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d1645 1
a1645 1
      fflush (rl_outstream); /* make sure the cursor pos is current! */
d1647 2
a1648 2
      ScreenSetCursor (row + delta, col);
      i = -delta;    /* in case someone wants to use it after the loop */
@


1.5.16.1
log
@2002-08-24  Elena Zannoni  <ezannoni@@redhat.com>

        Import of readline 4.3:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@a49 1
#include "rlmbutil.h"
d66 1
a66 1
extern char *_rl_term_forward_char;
d69 5
a73 12
static void update_line PARAMS((char *, char *, int, int, int, int));
static void space_to_eol PARAMS((int));
static void delete_chars PARAMS((int));
static void insert_some_chars PARAMS((char *, int, int));
static void cr PARAMS((void));

#if defined (HANDLE_MULTIBYTE)
static int _rl_col_width PARAMS((char *, int, int));
static int *_rl_wrapped_line;
#else
#  define _rl_col_width(l, s, e)	(((e) <= (s)) ? 0 : (e) - (s))
#endif
d110 1
a110 1
rl_voidfunc_t *rl_redisplay_function = rl_redisplay;
a148 3
/* Variables to keep track of the expanded prompt string, which may
   include invisible characters. */

d150 1
a150 1
static int prompt_visible_length, prompt_prefix_length;
d156 1
a156 2
/* The number of invisible characters in the prompt string.  Static so it
   can be shared between rl_redisplay and update_line */
d159 2
a160 2
/* The index of the last invisible character in the prompt string. */
static int prompt_last_invisible;
a165 7
/* Number of invisible characters on the first physical line of the prompt.
   Only valid when the number of physical characters in the prompt exceeds
   (or is equal to) _rl_screenwidth. */
static int prompt_invis_chars_first_line;

static int prompt_last_screen_line;

d169 1
a169 3
   index of the last invisible character in the returned string. NIFLP,
   if non-zero, is a place to store the number of invisible characters in
   the first prompt line. */
d179 1
a179 1
expand_prompt (pmt, lp, lip, niflp)
d181 1
a181 1
     int *lp, *lip, *niflp;
d184 1
a184 1
  int l, rl, last, ignoring, ninvis, invfl;
d196 3
a198 5
  r = ret = (char *)xmalloc (l + 1);

  invfl = 0;	/* invisible chars in first line of prompt */

  for (rl = ignoring = last = ninvis = 0, p = pmt; p && *p; p++)
a217 4
	  else
	    ninvis++;
	  if (rl == _rl_screenwidth)
	    invfl = ninvis;
a220 3
  if (rl < _rl_screenwidth)
    invfl = ninvis;

a225 2
  if (niflp)
    *niflp = invfl;
d237 1
a237 1
  ret = expand_prompt (pmt, (int *)NULL, (int *)NULL, (int *)NULL);
d249 2
a250 2
 * prompt_visible_length = number of visible characters in local_prompt
 * prompt_prefix_length = number of visible characters in local_prompt_prefix
d266 4
a269 3
  FREE (local_prompt);
  FREE (local_prompt_prefix);

d271 1
a271 1
  prompt_last_invisible = prompt_visible_length = 0;
d279 2
a280 4
      /* The prompt is only one logical line, though it might wrap. */
      local_prompt = expand_prompt (prompt, &prompt_visible_length,
					    &prompt_last_invisible,
					    &prompt_invis_chars_first_line);
d282 1
a282 1
      return (prompt_visible_length);
d288 1
a288 3
      local_prompt = expand_prompt (p, &prompt_visible_length,
				       &prompt_last_invisible,
				       &prompt_invis_chars_first_line);
d292 1
a292 3
      local_prompt_prefix = expand_prompt (prompt, &prompt_prefix_length,
						   (int *)NULL,
						   &prompt_invis_chars_first_line);
d294 1
a294 1
      return (prompt_prefix_length);
d313 2
a314 2
      visible_line = (char *)xmalloc (line_size);
      invisible_line = (char *)xmalloc (line_size);
d321 2
a322 2
      visible_line = (char *)xrealloc (visible_line, line_size);
      invisible_line = (char *)xrealloc (invisible_line, line_size);
a336 3
#if defined (HANDLE_MULTIBYTE)
      _rl_wrapped_line = (int *)xmalloc (vis_lbsize * sizeof (int));
#endif
a349 7
#if defined (HANDLE_MULTIBYTE)
  wchar_t wc;
  size_t wc_bytes;
  int wc_width;
  mbstate_t ps;
  int _rl_wrapped_multicolumn = 0;
#endif
d399 2
a400 2
	      visible_line = (char *)xrealloc (visible_line, line_size);
	      line = invisible_line = (char *)xrealloc (invisible_line, line_size);
d406 1
a406 1
      wrap_offset = local_len - prompt_visible_length;
d433 2
a434 2
	  visible_line = (char *)xrealloc (visible_line, line_size);
	  line = invisible_line = (char *)xrealloc (invisible_line, line_size);
d439 1
a439 1
      wrap_offset = prompt_invis_chars_first_line = 0;
d450 1
a450 19

#if defined (HANDLE_MULTIBYTE)	  
#define CHECK_LPOS() \
      do { \
	lpos++; \
	if (lpos >= _rl_screenwidth) \
	  { \
	    if (newlines >= (inv_lbsize - 2)) \
	      { \
		inv_lbsize *= 2; \
		inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \
		_rl_wrapped_line = (int *)xrealloc (_rl_wrapped_line, inv_lbsize * sizeof (int)); \
	      } \
	    inv_lbreaks[++newlines] = out; \
	    _rl_wrapped_line[newlines] = _rl_wrapped_multicolumn; \
	    lpos = 0; \
	  } \
      } while (0)
#else
d454 1
a454 1
	if (lpos >= _rl_screenwidth) \
a464 1
#endif
a468 8
#if defined (HANDLE_MULTIBYTE)
  memset (_rl_wrapped_line, 0, vis_lbsize);
#endif

  /* prompt_invis_chars_first_line is the number of invisible characters in
     the first physical line of the prompt.
     wrap_offset - prompt_invis_chars_first_line is the number of invis
     chars on the second line. */
d470 1
a470 1
  /* what if lpos is already >= _rl_screenwidth before we start drawing the
d472 1
a472 1
  while (lpos >= _rl_screenwidth)
d474 6
a479 13
      /* fix from Darin Johnson <darin@@acuson.com> for prompt string with
         invisible characters that is longer than the screen width.  The
         prompt_invis_chars_first_line variable could be made into an array
         saying how many invisible characters there are per line, but that's
         probably too much work for the benefit gained.  How many people have
         prompts that exceed two physical lines? */
      temp = ((newlines + 1) * _rl_screenwidth) +
#if 0
             ((newlines == 0) ? prompt_invis_chars_first_line : 0) +
#else
             ((newlines == 0 && local_prompt_prefix == 0) ? prompt_invis_chars_first_line : 0) +
#endif
             ((newlines == 1) ? wrap_offset : 0);
d482 1
a482 1
      lpos -= _rl_screenwidth;
a484 7
  prompt_last_screen_line = newlines;

  /* Draw the rest of the line (after the prompt) into invisible_line, keeping
     track of where the cursor is (c_pos), the number of the line containing
     the cursor (lb_linenum), the last line number (lb_botlin and inv_botlin).
     It maintains an array of line breaks for display (inv_lbreaks).
     This handles expanding tabs for display and displaying meta characters. */
a485 11
#if defined (HANDLE_MULTIBYTE)
  in = 0;
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      memset (&ps, 0, sizeof (mbstate_t));
      wc_bytes = mbrtowc (&wc, rl_line_buffer, rl_end, &ps);
    }
  else
    wc_bytes = 1;
  while (in < rl_end)
#else
a486 1
#endif
a489 22
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  if (wc_bytes == (size_t)-1 || wc_bytes == (size_t)-2)
	    {
	      /* Byte sequence is invalid or shortened.  Assume that the
	         first byte represents a character. */
	      wc_bytes = 1;
	      /* Assume that a character occupies a single column. */
	      wc_width = 1;
	      memset (&ps, 0, sizeof (mbstate_t));
	    }
	  else if (wc_bytes == (size_t)0)
	    break;			/* Found '\0' */
	  else
	    {
	      temp = wcwidth (wc);
	      wc_width = (temp < 0) ? 1 : temp;
	    }
	}
#endif

d493 2
a494 2
	  visible_line = (char *)xrealloc (visible_line, line_size);
	  invisible_line = (char *)xrealloc (invisible_line, line_size);
a503 3
#if defined (HANDLE_MULTIBYTE)
      if (META_CHAR (c) && _rl_output_meta_chars == 0)	/* XXX - clean up */
#else
a504 1
#endif
d510 1
a510 1
	      if (lpos + 4 >= _rl_screenwidth)
d512 1
a512 1
		  temp = _rl_screenwidth - lpos;
d531 1
a531 1
	  register int newout;
d539 1
a539 1
	  if (lpos + temp >= _rl_screenwidth)
d542 1
a542 1
	      temp2 = _rl_screenwidth - lpos;
d557 1
a557 1
      else if (c == '\n' && _rl_horizontal_scroll_mode == 0 && _rl_term_up && *_rl_term_up)
a572 31
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      register int i;

	      _rl_wrapped_multicolumn = 0;

	      if (_rl_screenwidth < lpos + wc_width)
		for (i = lpos; i < _rl_screenwidth; i++)
		  {
		    /* The space will be removed in update_line() */
		    line[out++] = ' ';
		    _rl_wrapped_multicolumn++;
		    CHECK_LPOS();
		  }
	      if (in == rl_point)
		{
		  c_pos = out;
		  lb_linenum = newlines;
		}
	      for (i = in; i < in+wc_bytes; i++)
		line[out++] = rl_line_buffer[i];
	      for (i = 0; i < wc_width; i++)
		CHECK_LPOS();
	    }
	  else
	    {
	      line[out++] = c;
	      CHECK_LPOS();
	    }
#else
a574 8
#endif
	}

#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  in += wc_bytes;
	  wc_bytes = mbrtowc (&wc, rl_line_buffer + in, rl_end - in, &ps);
a575 4
      else
        in++;
#endif

d589 1
a589 2
  /* C_POS == position in buffer where cursor should be placed.
     CURSOR_LINENUM == line number where the cursor should be placed. */
d600 1
a600 1
  if (_rl_horizontal_scroll_mode == 0 && _rl_term_up && *_rl_term_up)
d611 2
a612 7
	  if (out >= _rl_screenchars)
	    {
	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		out = _rl_find_prev_mbchar (line, _rl_screenchars, MB_FIND_ANY);
	      else
		out = _rl_screenchars - 1;
	    }
d642 1
a642 1
		  nleft = _rl_screenwidth + wrap_offset - _rl_last_c_pos;
d663 1
a663 1
		    ((linenum == _rl_vis_botlin) ? strlen (tt) : _rl_screenwidth);
d674 1
a674 1
	      /* If we moved up to the line with the prompt using _rl_term_up,
d687 1
a687 1
	  nleft = prompt_visible_length + wrap_offset;
d689 1
a689 1
	      _rl_last_c_pos <= prompt_last_invisible && local_prompt)
d694 2
a695 2
	      if (_rl_term_cr)
		tputs (_rl_term_cr, 1, _rl_output_character_function);
d698 1
a698 4
	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		_rl_last_c_pos = _rl_col_width(local_prompt, 0, nleft);
	      else
		_rl_last_c_pos = nleft;
d714 1
a714 4
	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		_rl_last_c_pos = _rl_col_width (&visible_line[pos], 0, nleft);
	      else
		_rl_last_c_pos = nleft;
d717 1
a717 3
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    _rl_move_cursor_relative (nleft, &invisible_line[pos]);
	  else if (nleft != _rl_last_c_pos)
d734 1
a734 1
      nleft  = prompt_visible_length + wrap_offset;
d738 1
a738 1
      t = _rl_screenwidth / 3;
d746 1
a746 1
      if (phys_c_pos > _rl_screenwidth - 2)
d756 1
a756 1
      else if (ndisp < _rl_screenwidth - 2)		/* XXX - was -1 */
d778 1
a778 1
      t = lmargin + M_OFFSET (lmargin, wrap_offset) + _rl_screenwidth;
d788 2
a789 2
		       _rl_screenwidth + visible_wrap_offset,
		       _rl_screenwidth + (lmargin ? 0 : wrap_offset),
d800 1
a800 1
	      nleft = _rl_screenwidth - t;
d804 2
a805 2
	  if (visible_first_line_len > _rl_screenwidth)
	    visible_first_line_len = _rl_screenwidth;
d815 1
a815 1
    char *vtemp = visible_line;
d819 1
a819 1
    invisible_line = vtemp;
a861 5
  int col_lendiff, col_temp;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps_new, ps_old;
  int new_offset, old_offset, tmp;
#endif
d869 2
a870 2
  if (temp == _rl_screenwidth && _rl_term_autowrap && !_rl_horizontal_scroll_mode
	&& _rl_last_v_pos == current_line - 1)
d872 2
a873 54
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  wchar_t wc;
	  mbstate_t ps;
	  int tempwidth, bytes;
	  size_t ret;

	  /* This fixes only double-column characters, but if the wrapped
	     character comsumes more than three columns, spaces will be
	     inserted in the string buffer. */
	  if (_rl_wrapped_line[current_line] > 0)
	    _rl_clear_to_eol (_rl_wrapped_line[current_line]);

	  memset (&ps, 0, sizeof (mbstate_t));
	  ret = mbrtowc (&wc, new, MB_CUR_MAX, &ps);
	  if (ret == (size_t)-1 || ret == (size_t)-2)
	    {
	      tempwidth = 1;
	      ret = 1;
	    }
	  else if (ret == 0)
	    tempwidth = 0;
	  else
	    tempwidth = wcwidth (wc);

	  if (tempwidth > 0)
	    {
	      int count;
	      bytes = ret;
	      for (count = 0; count < bytes; count++)
		putc (new[count], rl_outstream);
	      _rl_last_c_pos = tempwidth;
	      _rl_last_v_pos++;
	      memset (&ps, 0, sizeof (mbstate_t));
	      ret = mbrtowc (&wc, old, MB_CUR_MAX, &ps);
	      if (ret != 0 && bytes != 0)
		{
		  if (ret == (size_t)-1 || ret == (size_t)-2)
		    memmove (old+bytes, old+1, strlen (old+1));
		  else
		    memmove (old+bytes, old+ret, strlen (old+ret));
		  memcpy (old, new, bytes);
		}
	    }
	  else
	    {
	      putc (' ', rl_outstream);
	      _rl_last_c_pos = 1;
	      _rl_last_v_pos++;
	      if (old[0] && new[0])
		old[0] = new[0];
	    }
	}
d875 5
a879 11
#endif
	{
	  if (new[0])
	    putc (new[0], rl_outstream);
	  else
	    putc (' ', rl_outstream);
	  _rl_last_c_pos = 1;		/* XXX */
	  _rl_last_v_pos++;
	  if (old[0] && new[0])
	    old[0] = new[0];
	}
a880 1

a882 19
#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      memset (&ps_new, 0, sizeof(mbstate_t));
      memset (&ps_old, 0, sizeof(mbstate_t));

      new_offset = old_offset = 0;
      for (ofd = old, nfd = new;
	   (ofd - old < omax) && *ofd &&
	     _rl_compare_chars(old, old_offset, &ps_old, new, new_offset, &ps_new); )
	{
	  old_offset = _rl_find_next_mbchar (old, old_offset, 1, MB_FIND_ANY);
	  new_offset = _rl_find_next_mbchar (new, new_offset, 1, MB_FIND_ANY);
	  ofd = old + old_offset;
	  nfd = new + new_offset;
	}
    }
  else
#endif
a898 27

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      ols = old + _rl_find_prev_mbchar (old, oe - old, MB_FIND_ANY);
      nls = new + _rl_find_prev_mbchar (new, ne - new, MB_FIND_ANY);
      while ((ols > ofd) && (nls > nfd))
	{
	  memset (&ps_old, 0, sizeof (mbstate_t));
	  memset (&ps_new, 0, sizeof (mbstate_t));

	  _rl_adjust_point (old, ols - old, &ps_old);
	  _rl_adjust_point (new, nls - new, &ps_new);

	  if (_rl_compare_chars (old, ols - old, &ps_old, new, nls - new, &ps_new) == 0)
	    break;

	  if (*ols == ' ')
	    wsatend = 0;

	  ols = old + _rl_find_prev_mbchar (old, ols - old, MB_FIND_ANY);
	  nls = new + _rl_find_prev_mbchar (new, nls - new, MB_FIND_ANY);
	}
    }
  else
    {
#endif /* HANDLE_MULTIBYTE */
a907 3
#if defined (HANDLE_MULTIBYTE)
    }
#endif
a913 6
#if defined (HANDLE_MULTIBYTE)
  /* This may not work for stateful encoding, but who cares?  To handle
     stateful encoding properly, we have to scan each string from the
     beginning and compare. */
  else if (_rl_compare_chars (ols, 0, NULL, nls, 0, NULL) == 0)
#else
a914 1
#endif
d917 1
a917 6
	{
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    ols = old + _rl_find_next_mbchar (old, ols - old, 1, MB_FIND_ANY);
	  else
	    ols++;
	}
d919 1
a919 6
	{
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    nls = new + _rl_find_next_mbchar (new, nls - new, 1, MB_FIND_ANY);
	  else
	    nls++;
	}
d946 2
a947 2
      _rl_term_cr && lendiff > prompt_visible_length && _rl_last_c_pos > 0 &&
      od >= lendiff && _rl_last_c_pos <= prompt_last_invisible)
d952 1
a952 1
      tputs (_rl_term_cr, 1, _rl_output_character_function);
d955 1
a955 4
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	_rl_last_c_pos = _rl_col_width (local_prompt, 0, lendiff);
      else
	_rl_last_c_pos = lendiff;
d960 1
a960 4
  /* if (len (new) > len (old))
     lendiff == difference in buffer
     col_lendiff == difference on screen
     When not using multibyte characters, these are equal */
a961 4
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    col_lendiff = _rl_col_width (new, nfd - new, nls - new) - _rl_col_width (old, ofd - old, ols - old);
  else
    col_lendiff = lendiff;
d968 1
a968 12
    {
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  lendiff += visible_wrap_offset - current_invis_chars;
	  col_lendiff += visible_wrap_offset - current_invis_chars;
	}
      else
	{
	  lendiff += visible_wrap_offset - current_invis_chars;
	  col_lendiff = lendiff;
	}
    }
d972 1
a972 6
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    col_temp = _rl_col_width (new, nfd - new, ne - new);
  else
    col_temp = temp;

  if (col_lendiff > 0)	/* XXX - was lendiff */
d980 1
a980 1
      if (_rl_terminal_can_insert && ((2 * col_temp) >= col_lendiff || _rl_term_IC) && (!_rl_term_autowrap || !gl))
d982 1
a982 1
	  /* If lendiff > prompt_visible_length and _rl_last_c_pos == 0 and
d984 1
a984 1
	     _rl_term_IC or _rl_term_ic will screw up the screen because of the
d987 1
a987 1
			lendiff <= prompt_visible_length || !current_invis_chars))
d989 2
a990 2
	      insert_some_chars (nfd, lendiff, col_lendiff);
	      _rl_last_c_pos += col_lendiff;
d999 1
a999 1
	      _rl_last_c_pos += col_lendiff;
d1007 1
a1007 1
	      _rl_last_c_pos += col_temp;
d1015 1
a1015 5
#if 0
	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-lendiff) - col_lendiff;
#else
	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-col_lendiff);
#endif
d1022 1
a1022 1
	  _rl_last_c_pos += col_temp;
d1028 1
a1028 1
      if (_rl_term_dc && (2 * col_temp) >= -col_lendiff)
d1035 1
a1035 1
	    col_lendiff = 0;
d1037 2
a1038 2
	  if (col_lendiff)
	    delete_chars (-col_lendiff); /* delete (diff) characters */
d1045 1
a1045 1
	      _rl_last_c_pos += _rl_col_width (nfd, 0, temp);;
d1054 1
a1054 1
	      _rl_last_c_pos += col_temp;
d1057 1
a1057 6
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    col_lendiff = _rl_col_width (old, 0, oe - old) - _rl_col_width (new, 0, ne - new);
	  else
	    col_lendiff = lendiff;

	  if (col_lendiff)
d1060 1
a1060 1
		space_to_eol (col_lendiff);
d1062 1
a1062 1
		_rl_clear_to_eol (col_lendiff);
d1108 1
a1108 4
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    _rl_last_c_pos = _rl_col_width (prompt_last_line, 0, l);
  else
    _rl_last_c_pos = l;
d1113 1
a1113 1
  real_screenwidth = _rl_screenwidth + (_rl_term_autowrap ? 0 : 1);
d1158 1
a1158 1
     const char *data;
a1162 6
#if defined (HANDLE_MULTIBYTE)
  /* If we have multibyte characters, NEW is indexed by the buffer point in
     a multibyte string, but _rl_last_c_pos is the display position.  In
     this case, NEW's display position is not obvious. */
  if ((MB_CUR_MAX == 1 || rl_byte_oriented ) && _rl_last_c_pos == new) return;
#else
a1163 1
#endif
d1170 1
a1170 1
      (_rl_term_autowrap && i == _rl_screenwidth))
d1175 1
a1175 1
      tputs (_rl_term_cr, 1, _rl_output_character_function);
d1192 1
a1192 22
      if (_rl_term_forward_char)
	{
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      int width;
	      width = _rl_col_width (data, _rl_last_c_pos, new);
	      for (i = 0; i < width; i++)
		tputs (_rl_term_forward_char, 1, _rl_output_character_function);
	    }
	  else
	    {
	      for (i = _rl_last_c_pos; i < new; i++)
		tputs (_rl_term_forward_char, 1, _rl_output_character_function);
	    }
	}
      else if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  tputs (_rl_term_cr, 1, _rl_output_character_function);
	  for (i = 0; i < new; i++)
	    putc (data[i], rl_outstream);
	}
      else
d1194 1
a1194 10
	  putc (data[i], rl_outstream);

#else /* !HACK_TERMCAP_MOTION */

      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  tputs (_rl_term_cr, 1, _rl_output_character_function);
	  for (i = 0; i < new; i++)
	    putc (data[i], rl_outstream);
	}
d1198 4
a1201 3

#endif /* !HACK_TERMCAP_MOTION */

a1202 7
#if defined (HANDLE_MULTIBYTE)
  /* NEW points to the buffer point, but _rl_last_c_pos is the display point.
     The byte length of the string is probably bigger than the column width
     of the string, which means that if NEW == _rl_last_c_pos, then NEW's
     display point is less than _rl_last_c_pos. */
  else if (_rl_last_c_pos >= new)
#else
d1204 2
a1205 16
#endif
    {
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  tputs (_rl_term_cr, 1, _rl_output_character_function);
	  for (i = 0; i < new; i++)
	    putc (data[i], rl_outstream);
	}
      else
	_rl_backspace (_rl_last_c_pos - new);
    }

  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    _rl_last_c_pos =  _rl_col_width (data, 0, new);
  else
    _rl_last_c_pos = new;
d1215 1
a1215 1
  if (_rl_last_v_pos == to || to > _rl_screenheight)
d1225 1
a1225 1
      tputs (_rl_term_cr, 1, _rl_output_character_function);
d1234 1
a1234 1
      l = fflush (rl_outstream); /* make sure the cursor pos is current! */
d1239 1
a1239 1
      if (_rl_term_up && *_rl_term_up)
d1241 1
a1241 1
	  tputs (_rl_term_up, 1, _rl_output_character_function);
d1301 1
a1301 1
  return ((ISPRINT (uc)) ? 1 : 2);
a1327 3
#if defined (HAVE_VSNPRINTF)
  vsnprintf (msg_buf, sizeof (msg_buf) - 1, format, args);
#else
a1328 2
  msg_buf[sizeof(msg_buf) - 1] = '\0';	/* overflow? */
#endif
a1340 1
  msg_buf[sizeof(msg_buf) - 1] = '\0';	/* overflow? */
d1376 2
a1377 2
  saved_last_invisible = prompt_last_invisible;
  saved_visible_length = prompt_visible_length;
d1380 1
a1380 1
  prompt_last_invisible = prompt_visible_length = 0;
d1386 4
a1389 2
  FREE (local_prompt);
  FREE (local_prompt_prefix);
d1393 2
a1394 2
  prompt_last_invisible = saved_last_invisible;
  prompt_visible_length = saved_visible_length;
d1409 1
a1409 1
      pmt = (char *)xmalloc (len + 2);
d1418 1
a1418 1
      pmt = (char *)xmalloc (len + 2);
d1424 2
a1425 2
      prompt_last_invisible = saved_last_invisible;
      prompt_visible_length = saved_visible_length + 1;
d1453 2
a1454 2
  if (_rl_term_clreol)
    tputs (_rl_term_clreol, 1, _rl_output_character_function);
d1482 2
a1483 2
  if (_rl_term_clrpag)
    tputs (_rl_term_clrpag, 1, _rl_output_character_function);
d1485 1
a1485 1
    rl_crlf ();
d1489 1
a1489 1
/* Insert COUNT characters from STRING to the output stream at column COL. */
d1491 1
a1491 1
insert_some_chars (string, count, col)
d1493 1
a1493 1
     int count, col;
a1497 5
  /* DEBUGGING */
  if (MB_CUR_MAX == 1 || rl_byte_oriented)
    if (count != col)
      fprintf(stderr, "readline: debug: insert_some_chars: count (%d) != col (%d)\n", count, col);

d1499 1
a1499 1
  if (_rl_term_IC)
d1502 1
a1502 2

      buffer = tgoto (_rl_term_IC, 0, col);
d1511 2
a1512 2
      if (_rl_term_im && *_rl_term_im)
	tputs (_rl_term_im, 1, _rl_output_character_function);
d1516 1
a1516 1
      if (_rl_term_ic && *_rl_term_ic)
d1518 2
a1519 2
	  for (i = col; i--; )
	    tputs (_rl_term_ic, 1, _rl_output_character_function);
d1527 2
a1528 2
      if (_rl_term_ei && *_rl_term_ei)
	tputs (_rl_term_ei, 1, _rl_output_character_function);
d1538 1
a1538 1
  if (count > _rl_screenwidth)	/* XXX */
d1542 1
a1542 1
  if (_rl_term_DC && *_rl_term_DC)
d1545 1
a1545 1
      buffer = tgoto (_rl_term_DC, count, count);
d1550 1
a1550 1
      if (_rl_term_dc && *_rl_term_dc)
d1552 1
a1552 1
	  tputs (_rl_term_dc, 1, _rl_output_character_function);
d1573 1
a1573 1
  if (full_lines && _rl_term_autowrap && (VIS_LLEN(_rl_vis_botlin) == _rl_screenwidth))
d1576 3
a1578 1

d1580 2
a1581 1
      _rl_move_cursor_relative (_rl_screenwidth - 1, last_line);
d1583 1
a1583 1
      putc (last_line[_rl_screenwidth - 1], rl_outstream);
d1586 1
a1586 1
  rl_crlf ();
d1595 1
a1595 1
  if (_rl_term_cr)
d1600 1
a1600 1
      tputs (_rl_term_cr, 1, _rl_output_character_function);
d1614 1
a1614 1
  int oldlen, oldlast, oldplen, oldninvis;
d1620 3
a1622 4
  oldlen = prompt_visible_length;
  oldplen = prompt_prefix_length;
  oldlast = prompt_last_invisible;
  oldninvis = prompt_invis_chars_first_line;
d1625 1
a1625 3
  local_prompt = expand_prompt (t, &prompt_visible_length,
				   &prompt_last_invisible,
				   &prompt_invis_chars_first_line);
d1632 3
a1634 4
  prompt_visible_length = oldlen;
  prompt_prefix_length = oldplen;
  prompt_last_invisible = oldlast;
  prompt_invis_chars_first_line = oldninvis;
d1645 1
a1645 1
  if (_rl_term_cr)
d1650 1
a1650 1
      tputs (_rl_term_cr, 1, _rl_output_character_function);
d1654 1
a1654 1
      space_to_eol (_rl_screenwidth);
d1657 2
a1658 2
      if (_rl_term_clreol)
	tputs (_rl_term_clreol, 1, _rl_output_character_function);
d1661 2
a1662 2
	  space_to_eol (_rl_screenwidth);
	  tputs (_rl_term_cr, 1, _rl_output_character_function);
d1669 1
a1669 1
    rl_crlf ();
d1710 1
a1710 1
    nleft = _rl_last_c_pos - _rl_screenwidth - rl_visible_prompt_length;
d1712 1
a1712 1
    nleft = _rl_last_c_pos - _rl_screenwidth;
d1715 1
a1715 1
    ret = 1 + nleft / _rl_screenwidth;
a1720 84

#if defined (HANDLE_MULTIBYTE)
/* Calculate the number of screen columns occupied by STR from START to END.
   In the case of multibyte characters with stateful encoding, we have to
   scan from the beginning of the string to take the state into account. */
static int
_rl_col_width (str, start, end)
     char *str;
     int start, end;
{
  wchar_t wc;
  mbstate_t ps = {0};
  int tmp, point, width, max;

  if (end <= start)
    return 0;

  point = 0;
  max = end;

  while (point < start)
    {
      tmp = mbrlen (str + point, max, &ps);
      if ((size_t)tmp == (size_t)-1 || (size_t)tmp == (size_t)-2)
	{
	  /* In this case, the bytes are invalid or too short to compose a
	     multibyte character, so we assume that the first byte represents
	     a single character. */
	  point++;
	  max--;

	  /* Clear the state of the byte sequence, because in this case the
	     effect of mbstate is undefined. */
	  memset (&ps, 0, sizeof (mbstate_t));
	}
      else if (tmp == 0)
        break;		/* Found '\0' */
      else
	{
	  point += tmp;
	  max -= tmp;
	}
    }

  /* If START is not a byte that starts a character, then POINT will be
     greater than START.  In this case, assume that (POINT - START) gives
     a byte count that is the number of columns of difference. */
  width = point - start;

  while (point < end)
    {
      tmp = mbrtowc (&wc, str + point, max, &ps);
      if ((size_t)tmp == (size_t)-1 || (size_t)tmp == (size_t)-2)
	{
	  /* In this case, the bytes are invalid or too short to compose a
	     multibyte character, so we assume that the first byte represents
	     a single character. */
	  point++;
	  max--;

	  /* and assume that the byte occupies a single column. */
	  width++;

	  /* Clear the state of the byte sequence, because in this case the
	     effect of mbstate is undefined. */
	  memset (&ps, 0, sizeof (mbstate_t));
	}
      else if (tmp == 0)
        break;			/* Found '\0' */
      else
	{
	  point += tmp;
	  max -= tmp;
	  tmp = wcwidth(wc);
	  width += (tmp >= 0) ? tmp : 1;
	}
    }

  width += point - end;

  return width;
}
#endif /* HANDLE_MULTIBYTE */
	  
@


1.4
log
@readline:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Locally modified files: Makefile.in, configure.in, configure
        (regenerated), config.h.in (regenerated), readline.h, rltty.c,
 	shell.c signals.c.

        Locally added files: acconfig.h, config/*, config.h.bot,
        cross-build/*, doc/inc-hit.texinfo.

        New files: USAGE, rlprivate.h, rlshell.h, xmalloc.h.
examples:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        New files: excallback.c, rlfe.c.
doc:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Regenerated inc-hist.texinfo as copy of hsuser.texinfo, for
        inclusion in the gdb manual.

        New file: rluserman.texinfo
@
text
@d44 4
d1231 8
d1242 1
d1452 1
d1455 3
a1457 1
  else if (count)
d1478 4
d1486 1
d1495 3
d1530 1
d1541 1
d1554 1
@


1.3
log
@Dummy commit before importof 4.1 version
@
text
@d10 1
a10 1
   as published by the Free Software Foundation; either version 1, or
d21 1
a21 1
   675 Mass Ave, Cambridge, MA 02139, USA. */
a43 5
#if defined (__GO32__)
#  include <go32.h>
#  include <pc.h>
#endif /* __GO32__ */

d54 3
d61 2
a62 16
/* Global and pseudo-global variables and functions
   imported from readline.c. */
extern char *rl_prompt;
extern int readline_echoing_p;

extern int _rl_output_meta_chars;
extern int _rl_horizontal_scroll_mode;
extern int _rl_mark_modified_lines;
extern int _rl_prefer_visible_bell;

/* Variables and functions imported from terminal.c */
extern void _rl_output_some_chars ();
#ifdef _MINIX
extern void _rl_output_character_function ();
#else
extern int _rl_output_character_function ();
a63 1
extern int _rl_backspace ();
d65 5
a69 15
extern char *term_clreol, *term_clrpag;
extern char *term_im, *term_ic,  *term_ei, *term_DC;
extern char *term_up, *term_dc, *term_cr, *term_IC;
extern int screenheight, screenwidth, screenchars;
extern int terminal_can_insert, _rl_term_autowrap;

/* Pseudo-global functions (local to the readline library) exported
   by this file. */
void _rl_move_cursor_relative (), _rl_output_some_chars ();
void _rl_move_vert ();
void _rl_clear_to_eol (), _rl_clear_screen ();

static void update_line (), space_to_eol ();
static void delete_chars (), insert_some_chars ();
static void cr ();
d72 1
a72 2

extern char *xmalloc (), *xrealloc ();
d165 1
a165 1
   index of the last invisible character in ther eturned string. */
d225 12
d294 43
d355 1
a355 13
      visible_line = xmalloc (line_size);
      invisible_line = xmalloc (line_size);
      for (in = 0; in < line_size; in++)
	{
	  visible_line[in] = 0;
	  invisible_line[in] = 1;
	}

      /* should be enough, but then again, this is just for testing. */
      inv_lbreaks = (int *)malloc (256 * sizeof (int));
      vis_lbreaks = (int *)malloc (256 * sizeof (int));
      inv_lbreaks[0] = vis_lbreaks[0] = 0;

d413 1
d416 1
a416 1
	      _rl_output_some_chars (rl_display_prompt, prompt_this_line - rl_display_prompt);
d419 1
a419 1
	      if (prompt_this_line[-2] != '\r')
d438 9
d452 5
a469 3
#if 0
      temp = ((newlines + 1) * screenwidth) - ((newlines == 0) ? wrap_offset : 0);
#else
d472 3
a474 1
	 width. */
d476 1
a476 1
#endif
d509 1
d539 1
d556 1
d581 1
d812 2
a813 1
    int *itemp = vis_lbreaks;
d816 1
d819 4
d949 1
a949 1
#endif /* !__MSDOS__ */
d1079 52
a1187 2
      extern char *term_forward_char;

a1213 11
#if defined (__GO32__)
  {
    int row, col;

    i = fflush (rl_outstream);	/* make sure the cursor pos is current! */
    ScreenGetCursor (&row, &col);
    ScreenSetCursor ((row + to - _rl_last_v_pos), col);
    delta = i;
  }
#else /* !__GO32__ */

d1218 3
d1222 1
d1231 1
a1231 1
#endif /* !__GO32__ */
a1438 1
#if !defined (__GO32__)
a1441 1
#endif /* !__GO32__ */
a1461 4
#if defined (__GO32__)
  ScreenClear ();	/* FIXME: only works in text modes */
  ScreenSetCursor (0, 0);  /* term_clrpag is "cl" which homes the cursor */
#else
a1464 1
#endif /* !__GO32__ */
a1473 15
#if defined (__GO32__)
#ifndef __DJGPP__
  int row, col, width;
  char *row_start;

  ScreenGetCursor (&row, &col);
  width = ScreenCols ();
  row_start = ScreenPrimary + (row * width);

  memcpy (row_start + col + count, row_start + col, width - col - count);
#endif /* !__DJGPP__ */
  /* Place the text on the screen. */
  _rl_output_some_chars (string, count);
#else /* !_GO32 */

a1505 1
#endif /* !__GO32__ */
a1512 13
#if !defined (__DJGPP__)
#if defined (__GO32__)
  int row, col, width;
  char *row_start;

  ScreenGetCursor (&row, &col);
  width = ScreenCols ();
  row_start = ScreenPrimary + (row * width);

  memcpy (row_start + col, row_start + col + count, width - col - count);
  memset (row_start + width - count, 0, count * 2);
#else /* !_GO32 */

a1527 2
#endif /* !__GO32__ */
#endif /* !__DJGPP__ */
d1549 1
d1551 3
d1574 1
a1574 1
#endif /* !__MSDOS__ */
d1579 31
d1614 1
a1614 1
  char *t, *oldp, *oldl, *oldlprefix;
d1624 1
a1624 1
#endif /* !__MSDOS__ */
d1647 1
a1647 11
    {
      oldp = rl_display_prompt;
      oldl = local_prompt;
      oldlprefix = local_prompt_prefix;
      rl_display_prompt = ++t;
      local_prompt = local_prompt_prefix = (char *)NULL;
      rl_forced_update_display ();
      rl_display_prompt = oldp;
      local_prompt = oldl;
      local_prompt_prefix = oldlprefix;
    }
d1671 22
@


1.2
log
@(_rl_move_vert) [__GO32__]: fflush the stream, to make sure cursor position
is up-to-date.
(space_to_eol) [__GO32__]: Clear the screen and home the cursor.
(insert_some_chars) [__GO32__]: Don't write directly to the screen in DJGPP
versions 2.x (it doesn't work).
(delete_chars) [__GO32__]: Ditto.
@
text
@@


1.1
log
@Initial revision
@
text
@d283 1
a283 1
  last_invisible = 0;
d376 7
d409 7
d424 6
a429 6
        lpos++; \
        if (lpos >= screenwidth) \
          { \
            inv_lbreaks[++newlines] = out; \
            lpos = 0; \
          } \
d498 2
d501 3
d523 5
a527 5
        {
          line[out++] = '\0';	/* XXX - sentinel */
          inv_lbreaks[++newlines] = out;
          lpos = 0;
        }
d638 3
a640 3
	         the physical cursor position on the screen stays the same,
	         but the buffer position needs to be adjusted to account
	         for invisible characters. */
d642 1
a642 1
	        _rl_last_c_pos += wrap_offset;
d654 3
d659 1
d699 1
a699 1
         longer than SCREENWIDTH; if it is, lmargin will be adjusted. */
d704 1
a704 1
         last_lmargin will be > 0. */
d707 2
a708 2
         width, compute the starting offset so that the cursor is about
         two-thirds of the way across the screen. */
d720 1
a720 1
        lmargin = 0;
d730 1
a730 1
        lmargin = last_lmargin;
d738 3
a740 3
         the whole line, indicate that with a special characters at the
         right edge of the screen.  If LMARGIN is 0, we need to take the
         wrap offset into account. */
d743 1
a743 1
        line[t - 1] = '>';
d808 1
a808 1
   no differences, as well as for end of line additions must be handeled.
d836 1
a836 1
        old[0] = new[0];
d906 3
d910 1
d925 1
a925 4
    {
      temp = visible_wrap_offset - current_invis_chars;
      lendiff += temp;
    }
d954 1
a954 1
	         assumes you've done the insert because you can. */
d1014 7
a1020 4
	  if (_rl_term_autowrap && current_line < inv_botlin)
	    space_to_eol (lendiff);
	  else
	    _rl_clear_to_eol (lendiff);
d1049 1
a1049 1
        *temp++ = '\0';
d1110 1
a1110 1
  else if (_rl_last_c_pos != new)
d1129 1
d1132 1
d1277 1
a1277 1
_rl_save_prompt ()
d1289 1
a1289 1
_rl_restore_prompt ()
d1309 1
a1309 1
  _rl_save_prompt ();
d1316 1
a1316 1
        strcpy (pmt, rl_prompt);
d1325 1
a1325 1
        strcpy (pmt, saved_local_prompt);
d1382 4
a1385 1
#if !defined (__GO32__)
d1400 1
d1409 1
a1409 1

d1454 1
d1483 1
d1522 3
d1526 1
d1541 3
d1545 1
d1547 4
d1558 1
d1591 1
a1591 1
      rl_restart_output ();
d1593 9
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a634 3
#if defined (__MSDOS__)
	      putc ('\r', rl_outstream);
#else
a636 1
#endif
a882 3
#if defined (__MSDOS__)
      putc ('\r', rl_outstream);
#else
a883 1
#endif /* !__MSDOS__ */
a1486 3
#if defined (__MSDOS__)
      putc ('\r', rl_outstream);
#else
a1487 1
#endif /* !__MSDOS__ */
a1501 3
#if defined (__MSDOS__)
      putc ('\r', rl_outstream);
#else
a1502 1
#endif /* !__MSDOS__ */
a1503 4
#if defined (__MSDOS__)
      space_to_eol (screenwidth);
      putc ('\r', rl_outstream);
#else
a1510 1
#endif
@


1.1.1.3
log
@import gdb-1999-08-02 snapshot
@
text
@d283 1
a283 1
  last_invisible = visible_length = 0;
a375 7
	  temp = local_len + out + 2;
	  if (temp >= line_size)
	    {
	      line_size = (temp + 1024) - (temp % 1024);
	      visible_line = xrealloc (visible_line, line_size);
	      line = invisible_line = xrealloc (invisible_line, line_size);
	    }
a401 7
      temp = pmtlen + out + 2;
      if (temp >= line_size)
	{
	  line_size = (temp + 1024) - (temp % 1024);
	  visible_line = xrealloc (visible_line, line_size);
	  line = invisible_line = xrealloc (invisible_line, line_size);
	}
d410 6
a415 6
	lpos++; \
	if (lpos >= screenwidth) \
	  { \
	    inv_lbreaks[++newlines] = out; \
	    lpos = 0; \
	  } \
a483 2

#if 0
a484 3
#else
	  newout = out + 8 - lpos % 8;
#endif
d504 5
a508 5
	{
	  line[out++] = '\0';	/* XXX - sentinel */
	  inv_lbreaks[++newlines] = out;
	  lpos = 0;
	}
d619 3
a621 3
		 the physical cursor position on the screen stays the same,
		 but the buffer position needs to be adjusted to account
		 for invisible characters. */
d623 1
a623 1
		_rl_last_c_pos += wrap_offset;
d680 1
a680 1
	 longer than SCREENWIDTH; if it is, lmargin will be adjusted. */
d685 1
a685 1
	 last_lmargin will be > 0. */
d688 2
a689 2
	 width, compute the starting offset so that the cursor is about
	 two-thirds of the way across the screen. */
d701 1
a701 1
	lmargin = 0;
d711 1
a711 1
	lmargin = last_lmargin;
d719 3
a721 3
	 the whole line, indicate that with a special character at the
	 right edge of the screen.  If LMARGIN is 0, we need to take the
	 wrap offset into account. */
d724 1
a724 1
	line[t - 1] = '>';
d789 1
a789 1
   no differences, as well as for end of line additions must be handled.
d817 1
a817 1
	old[0] = new[0];
d906 4
a909 1
    lendiff += visible_wrap_offset - current_invis_chars;
d938 1
a938 1
		 assumes you've done the insert because you can. */
d998 4
a1001 7
	  if (lendiff)
	    {	  
	      if (_rl_term_autowrap && current_line < inv_botlin)
		space_to_eol (lendiff);
	      else
		_rl_clear_to_eol (lendiff);
	    }
d1030 1
a1030 1
	*temp++ = '\0';
d1091 1
a1091 1
  else if (_rl_last_c_pos > new)
d1256 1
a1256 1
rl_save_prompt ()
d1268 1
a1268 1
rl_restore_prompt ()
d1288 1
a1288 1
  rl_save_prompt ();
d1295 1
a1295 1
	strcpy (pmt, rl_prompt);
d1304 1
a1304 1
	strcpy (pmt, saved_local_prompt);
d1564 1
a1564 1
      rl_restart_output (1, 0);
a1565 9
}

void
_rl_erase_entire_line ()
{
  cr ();
  _rl_clear_to_eol (0);
  cr ();
  fflush (rl_outstream);
@


1.1.1.4
log
@Import of readline 4.0
@
text
@d654 3
d659 1
d906 3
d910 1
d1514 3
d1518 1
d1533 3
d1537 1
d1539 4
d1550 1
@


1.1.1.5
log
@Import of readline 4.1
@
text
@d10 1
a10 1
   as published by the Free Software Foundation; either version 2, or
d21 1
a21 1
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
d44 5
a58 3
#include "rlprivate.h"
#include "xmalloc.h"

d63 16
a78 2
#if defined (HACK_TERMCAP_MOTION)
extern char *term_forward_char;
d80 1
d82 15
a96 5
static void update_line __P((char *, char *, int, int, int, int));
static void space_to_eol __P((int));
static void delete_chars __P((int));
static void insert_some_chars __P((char *, int));
static void cr __P((void));
d99 2
a100 1
static int inv_lbsize, vis_lbsize;
d193 1
a193 1
   index of the last invisible character in the returned string. */
a252 12
/* Just strip out RL_PROMPT_START_IGNORE and RL_PROMPT_END_IGNORE from
   PMT and return the rest of PMT. */
char *
_rl_strip_prompt (pmt)
     char *pmt;
{
  char *ret;

  ret = expand_prompt (pmt, (int *)NULL, (int *)NULL);
  return ret;
}

a309 43
/* Initialize the VISIBLE_LINE and INVISIBLE_LINE arrays, and their associated
   arrays of line break markers.  MINSIZE is the minimum size of VISIBLE_LINE
   and INVISIBLE_LINE; if it is greater than LINE_SIZE, LINE_SIZE is
   increased.  If the lines have already been allocated, this ensures that
   they can hold at least MINSIZE characters. */
static void
init_line_structures (minsize)
      int minsize;
{
  register int n;

  if (invisible_line == 0)	/* initialize it */
    {
      if (line_size < minsize)
	line_size = minsize;
      visible_line = xmalloc (line_size);
      invisible_line = xmalloc (line_size);
    }
  else if (line_size < minsize)	/* ensure it can hold MINSIZE chars */
    {
      line_size *= 2;
      if (line_size < minsize)
	line_size = minsize;
      visible_line = xrealloc (visible_line, line_size);
      invisible_line = xrealloc (invisible_line, line_size);
    }

  for (n = minsize; n < line_size; n++)
    {
      visible_line[n] = 0;
      invisible_line[n] = 1;
    }

  if (vis_lbreaks == 0)
    {
      /* should be enough. */
      inv_lbsize = vis_lbsize = 256;
      inv_lbreaks = (int *)xmalloc (inv_lbsize * sizeof (int));
      vis_lbreaks = (int *)xmalloc (vis_lbsize * sizeof (int));
      inv_lbreaks[0] = vis_lbreaks[0] = 0;
    }
}
  
d328 13
a340 1
      init_line_structures (0);
a397 1
	  pmtlen = prompt_this_line - rl_display_prompt;	/* temp var */
d400 1
a400 1
	      _rl_output_some_chars (rl_display_prompt, pmtlen);
d403 1
a403 1
	      if (pmtlen < 2 || prompt_this_line[-2] != '\r')
a421 9
#define CHECK_INV_LBREAKS() \
      do { \
	if (newlines >= (inv_lbsize - 2)) \
	  { \
	    inv_lbsize *= 2; \
	    inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \
	  } \
      } while (0)
	  
a426 5
	    if (newlines >= (inv_lbsize - 2)) \
	      { \
		inv_lbsize *= 2; \
		inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \
	      } \
d440 3
d445 1
a445 3
	 width.  XXX - this doesn't work right if invisible characters have
	 to be put on the second screen line -- it adds too much (the number
	 of invisible chars after the screenwidth). */
d447 1
a447 1

a479 1
		  CHECK_INV_LBREAKS ();
a508 1
	      CHECK_INV_LBREAKS ();
a524 1
	  CHECK_INV_LBREAKS ();
a548 1
  CHECK_INV_LBREAKS ();
a653 3
#if defined (__MSDOS__)
	      putc ('\r', rl_outstream);
#else
a655 1
#endif
d775 1
a775 2
    int *itemp = vis_lbreaks, ntemp = vis_lbsize;

a777 1

a779 4

    vis_lbsize = inv_lbsize;
    inv_lbsize = ntemp;

a901 3
#if defined (__MSDOS__)
      putc ('\r', rl_outstream);
#else
a902 1
#endif
a1031 52
/* Tell the update routines that we have moved onto a new line with the
   prompt already displayed.  Code originally from the version of readline
   distributed with CLISP. */
int
rl_on_new_line_with_prompt ()
{
  int prompt_size, i, l, real_screenwidth, newlines;
  char *prompt_last_line;

  /* Initialize visible_line and invisible_line to ensure that they can hold
     the already-displayed prompt. */
  prompt_size = strlen (rl_prompt) + 1;
  init_line_structures (prompt_size);

  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  strcpy (visible_line, rl_prompt);
  strcpy (invisible_line, rl_prompt);

  /* If the prompt contains newlines, take the last tail. */
  prompt_last_line = strrchr (rl_prompt, '\n');
  if (!prompt_last_line)
    prompt_last_line = rl_prompt;

  l = strlen (prompt_last_line);
  _rl_last_c_pos = l;

  /* Dissect prompt_last_line into screen lines. Note that here we have
     to use the real screenwidth. Readline's notion of screenwidth might be
     one less, see terminal.c. */
  real_screenwidth = screenwidth + (_rl_term_autowrap ? 0 : 1);
  _rl_last_v_pos = l / real_screenwidth;
  /* If the prompt length is a multiple of real_screenwidth, we don't know
     whether the cursor is at the end of the last line, or already at the
     beginning of the next line. Output a newline just to be safe. */
  if (l > 0 && (l % real_screenwidth) == 0)
    _rl_output_some_chars ("\n", 1);
  last_lmargin = 0;

  newlines = 0; i = 0;
  while (i <= l)
    {
      _rl_vis_botlin = newlines;
      vis_lbreaks[newlines++] = i;
      i += real_screenwidth;
    }
  vis_lbreaks[newlines] = l;
  visible_wrap_offset = 0;

  return 0;
}

d1089 2
d1117 9
a1129 3
#if defined (__MSDOS__)
      putc ('\r', rl_outstream);
#else
a1130 1
#endif
d1139 1
a1139 1

d1347 1
d1351 1
d1372 1
d1376 1
d1386 14
d1432 1
d1440 12
d1467 1
a1488 1
#if 0
a1489 3
#else
      last_line = &visible_line[vis_lbreaks[_rl_vis_botlin]];
#endif
a1505 3
#if defined (__MSDOS__)
      putc ('\r', rl_outstream);
#else
a1506 1
#endif
a1510 31
/* Redraw the last line of a multi-line prompt that may possibly contain
   terminal escape sequences.  Called with the cursor at column 0 of the
   line to draw the prompt on. */
static void
redraw_prompt (t)
     char *t;
{
  char *oldp, *oldl, *oldlprefix;
  int oldlen, oldlast, oldplen;

  /* Geez, I should make this a struct. */
  oldp = rl_display_prompt;
  oldl = local_prompt;
  oldlprefix = local_prompt_prefix;
  oldlen = visible_length;
  oldplen = prefix_length;
  oldlast = last_invisible;

  rl_display_prompt = t;
  local_prompt = expand_prompt (t, &visible_length, &last_invisible);
  local_prompt_prefix = (char *)NULL;
  rl_forced_update_display ();

  rl_display_prompt = oldp;
  local_prompt = oldl;
  local_prompt_prefix = oldlprefix;
  visible_length = oldlen;
  prefix_length = oldplen;
  last_invisible = oldlast;
}
      
d1515 1
a1515 1
  char *t;
a1520 3
#if defined (__MSDOS__)
      putc ('\r', rl_outstream);
#else
a1521 1
#endif
a1522 4
#if defined (__MSDOS__)
      space_to_eol (screenwidth);
      putc ('\r', rl_outstream);
#else
a1529 1
#endif
d1539 11
a1549 1
    redraw_prompt (++t);
a1572 22
}

/* return the `current display line' of the cursor -- the number of lines to
   move up to get to the first screen line of the current readline line. */
int
_rl_current_display_line ()
{
  int ret, nleft;

  /* Find out whether or not there might be invisible characters in the
     editing buffer. */
  if (rl_display_prompt == rl_prompt)
    nleft = _rl_last_c_pos - screenwidth - rl_visible_prompt_length;
  else
    nleft = _rl_last_c_pos - screenwidth;

  if (nleft > 0)
    ret = 1 + nleft / screenwidth;
  else
    ret = 0;

  return ret;
@


1.1.1.6
log
@import of readline-4.3
@
text
@a45 1
#include "rlmbutil.h"
d62 1
a62 1
extern char *_rl_term_forward_char;
d65 5
a69 12
static void update_line PARAMS((char *, char *, int, int, int, int));
static void space_to_eol PARAMS((int));
static void delete_chars PARAMS((int));
static void insert_some_chars PARAMS((char *, int, int));
static void cr PARAMS((void));

#if defined (HANDLE_MULTIBYTE)
static int _rl_col_width PARAMS((char *, int, int));
static int *_rl_wrapped_line;
#else
#  define _rl_col_width(l, s, e)	(((e) <= (s)) ? 0 : (e) - (s))
#endif
d106 1
a106 1
rl_voidfunc_t *rl_redisplay_function = rl_redisplay;
a144 3
/* Variables to keep track of the expanded prompt string, which may
   include invisible characters. */

d146 1
a146 1
static int prompt_visible_length, prompt_prefix_length;
d152 1
a152 2
/* The number of invisible characters in the prompt string.  Static so it
   can be shared between rl_redisplay and update_line */
d155 2
a156 2
/* The index of the last invisible character in the prompt string. */
static int prompt_last_invisible;
a161 7
/* Number of invisible characters on the first physical line of the prompt.
   Only valid when the number of physical characters in the prompt exceeds
   (or is equal to) _rl_screenwidth. */
static int prompt_invis_chars_first_line;

static int prompt_last_screen_line;

d165 1
a165 3
   index of the last invisible character in the returned string. NIFLP,
   if non-zero, is a place to store the number of invisible characters in
   the first prompt line. */
d175 1
a175 1
expand_prompt (pmt, lp, lip, niflp)
d177 1
a177 1
     int *lp, *lip, *niflp;
d180 1
a180 1
  int l, rl, last, ignoring, ninvis, invfl;
d192 3
a194 5
  r = ret = (char *)xmalloc (l + 1);

  invfl = 0;	/* invisible chars in first line of prompt */

  for (rl = ignoring = last = ninvis = 0, p = pmt; p && *p; p++)
a213 4
	  else
	    ninvis++;
	  if (rl == _rl_screenwidth)
	    invfl = ninvis;
a216 3
  if (rl < _rl_screenwidth)
    invfl = ninvis;

a221 2
  if (niflp)
    *niflp = invfl;
d233 1
a233 1
  ret = expand_prompt (pmt, (int *)NULL, (int *)NULL, (int *)NULL);
d245 2
a246 2
 * prompt_visible_length = number of visible characters in local_prompt
 * prompt_prefix_length = number of visible characters in local_prompt_prefix
d262 4
a265 3
  FREE (local_prompt);
  FREE (local_prompt_prefix);

d267 1
a267 1
  prompt_last_invisible = prompt_visible_length = 0;
d275 2
a276 4
      /* The prompt is only one logical line, though it might wrap. */
      local_prompt = expand_prompt (prompt, &prompt_visible_length,
					    &prompt_last_invisible,
					    &prompt_invis_chars_first_line);
d278 1
a278 1
      return (prompt_visible_length);
d284 1
a284 3
      local_prompt = expand_prompt (p, &prompt_visible_length,
				       &prompt_last_invisible,
				       &prompt_invis_chars_first_line);
d288 1
a288 3
      local_prompt_prefix = expand_prompt (prompt, &prompt_prefix_length,
						   (int *)NULL,
						   &prompt_invis_chars_first_line);
d290 1
a290 1
      return (prompt_prefix_length);
d309 2
a310 2
      visible_line = (char *)xmalloc (line_size);
      invisible_line = (char *)xmalloc (line_size);
d317 2
a318 2
      visible_line = (char *)xrealloc (visible_line, line_size);
      invisible_line = (char *)xrealloc (invisible_line, line_size);
a332 3
#if defined (HANDLE_MULTIBYTE)
      _rl_wrapped_line = (int *)xmalloc (vis_lbsize * sizeof (int));
#endif
a345 7
#if defined (HANDLE_MULTIBYTE)
  wchar_t wc;
  size_t wc_bytes;
  int wc_width;
  mbstate_t ps;
  int _rl_wrapped_multicolumn = 0;
#endif
d395 2
a396 2
	      visible_line = (char *)xrealloc (visible_line, line_size);
	      line = invisible_line = (char *)xrealloc (invisible_line, line_size);
d402 1
a402 1
      wrap_offset = local_len - prompt_visible_length;
d429 2
a430 2
	  visible_line = (char *)xrealloc (visible_line, line_size);
	  line = invisible_line = (char *)xrealloc (invisible_line, line_size);
d435 1
a435 1
      wrap_offset = prompt_invis_chars_first_line = 0;
d446 1
a446 19

#if defined (HANDLE_MULTIBYTE)	  
#define CHECK_LPOS() \
      do { \
	lpos++; \
	if (lpos >= _rl_screenwidth) \
	  { \
	    if (newlines >= (inv_lbsize - 2)) \
	      { \
		inv_lbsize *= 2; \
		inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \
		_rl_wrapped_line = (int *)xrealloc (_rl_wrapped_line, inv_lbsize * sizeof (int)); \
	      } \
	    inv_lbreaks[++newlines] = out; \
	    _rl_wrapped_line[newlines] = _rl_wrapped_multicolumn; \
	    lpos = 0; \
	  } \
      } while (0)
#else
d450 1
a450 1
	if (lpos >= _rl_screenwidth) \
a460 1
#endif
a464 8
#if defined (HANDLE_MULTIBYTE)
  memset (_rl_wrapped_line, 0, vis_lbsize);
#endif

  /* prompt_invis_chars_first_line is the number of invisible characters in
     the first physical line of the prompt.
     wrap_offset - prompt_invis_chars_first_line is the number of invis
     chars on the second line. */
d466 1
a466 1
  /* what if lpos is already >= _rl_screenwidth before we start drawing the
d468 1
a468 1
  while (lpos >= _rl_screenwidth)
d470 6
a475 13
      /* fix from Darin Johnson <darin@@acuson.com> for prompt string with
         invisible characters that is longer than the screen width.  The
         prompt_invis_chars_first_line variable could be made into an array
         saying how many invisible characters there are per line, but that's
         probably too much work for the benefit gained.  How many people have
         prompts that exceed two physical lines? */
      temp = ((newlines + 1) * _rl_screenwidth) +
#if 0
             ((newlines == 0) ? prompt_invis_chars_first_line : 0) +
#else
             ((newlines == 0 && local_prompt_prefix == 0) ? prompt_invis_chars_first_line : 0) +
#endif
             ((newlines == 1) ? wrap_offset : 0);
d478 1
a478 1
      lpos -= _rl_screenwidth;
a480 7
  prompt_last_screen_line = newlines;

  /* Draw the rest of the line (after the prompt) into invisible_line, keeping
     track of where the cursor is (c_pos), the number of the line containing
     the cursor (lb_linenum), the last line number (lb_botlin and inv_botlin).
     It maintains an array of line breaks for display (inv_lbreaks).
     This handles expanding tabs for display and displaying meta characters. */
a481 11
#if defined (HANDLE_MULTIBYTE)
  in = 0;
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      memset (&ps, 0, sizeof (mbstate_t));
      wc_bytes = mbrtowc (&wc, rl_line_buffer, rl_end, &ps);
    }
  else
    wc_bytes = 1;
  while (in < rl_end)
#else
a482 1
#endif
a485 22
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  if (wc_bytes == (size_t)-1 || wc_bytes == (size_t)-2)
	    {
	      /* Byte sequence is invalid or shortened.  Assume that the
	         first byte represents a character. */
	      wc_bytes = 1;
	      /* Assume that a character occupies a single column. */
	      wc_width = 1;
	      memset (&ps, 0, sizeof (mbstate_t));
	    }
	  else if (wc_bytes == (size_t)0)
	    break;			/* Found '\0' */
	  else
	    {
	      temp = wcwidth (wc);
	      wc_width = (temp < 0) ? 1 : temp;
	    }
	}
#endif

d489 2
a490 2
	  visible_line = (char *)xrealloc (visible_line, line_size);
	  invisible_line = (char *)xrealloc (invisible_line, line_size);
a499 3
#if defined (HANDLE_MULTIBYTE)
      if (META_CHAR (c) && _rl_output_meta_chars == 0)	/* XXX - clean up */
#else
a500 1
#endif
d506 1
a506 1
	      if (lpos + 4 >= _rl_screenwidth)
d508 1
a508 1
		  temp = _rl_screenwidth - lpos;
d527 1
a527 1
	  register int newout;
d535 1
a535 1
	  if (lpos + temp >= _rl_screenwidth)
d538 1
a538 1
	      temp2 = _rl_screenwidth - lpos;
d553 1
a553 1
      else if (c == '\n' && _rl_horizontal_scroll_mode == 0 && _rl_term_up && *_rl_term_up)
a568 31
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      register int i;

	      _rl_wrapped_multicolumn = 0;

	      if (_rl_screenwidth < lpos + wc_width)
		for (i = lpos; i < _rl_screenwidth; i++)
		  {
		    /* The space will be removed in update_line() */
		    line[out++] = ' ';
		    _rl_wrapped_multicolumn++;
		    CHECK_LPOS();
		  }
	      if (in == rl_point)
		{
		  c_pos = out;
		  lb_linenum = newlines;
		}
	      for (i = in; i < in+wc_bytes; i++)
		line[out++] = rl_line_buffer[i];
	      for (i = 0; i < wc_width; i++)
		CHECK_LPOS();
	    }
	  else
	    {
	      line[out++] = c;
	      CHECK_LPOS();
	    }
#else
a570 8
#endif
	}

#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  in += wc_bytes;
	  wc_bytes = mbrtowc (&wc, rl_line_buffer + in, rl_end - in, &ps);
a571 4
      else
        in++;
#endif

d585 1
a585 2
  /* C_POS == position in buffer where cursor should be placed.
     CURSOR_LINENUM == line number where the cursor should be placed. */
d596 1
a596 1
  if (_rl_horizontal_scroll_mode == 0 && _rl_term_up && *_rl_term_up)
d607 2
a608 7
	  if (out >= _rl_screenchars)
	    {
	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		out = _rl_find_prev_mbchar (line, _rl_screenchars, MB_FIND_ANY);
	      else
		out = _rl_screenchars - 1;
	    }
d638 1
a638 1
		  nleft = _rl_screenwidth + wrap_offset - _rl_last_c_pos;
d659 1
a659 1
		    ((linenum == _rl_vis_botlin) ? strlen (tt) : _rl_screenwidth);
d670 1
a670 1
	      /* If we moved up to the line with the prompt using _rl_term_up,
d683 1
a683 1
	  nleft = prompt_visible_length + wrap_offset;
d685 1
a685 1
	      _rl_last_c_pos <= prompt_last_invisible && local_prompt)
d690 2
a691 2
	      if (_rl_term_cr)
		tputs (_rl_term_cr, 1, _rl_output_character_function);
d694 1
a694 4
	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		_rl_last_c_pos = _rl_col_width(local_prompt, 0, nleft);
	      else
		_rl_last_c_pos = nleft;
d710 1
a710 4
	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		_rl_last_c_pos = _rl_col_width (&visible_line[pos], 0, nleft);
	      else
		_rl_last_c_pos = nleft;
d713 1
a713 3
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    _rl_move_cursor_relative (nleft, &invisible_line[pos]);
	  else if (nleft != _rl_last_c_pos)
d730 1
a730 1
      nleft  = prompt_visible_length + wrap_offset;
d734 1
a734 1
      t = _rl_screenwidth / 3;
d742 1
a742 1
      if (phys_c_pos > _rl_screenwidth - 2)
d752 1
a752 1
      else if (ndisp < _rl_screenwidth - 2)		/* XXX - was -1 */
d774 1
a774 1
      t = lmargin + M_OFFSET (lmargin, wrap_offset) + _rl_screenwidth;
d784 2
a785 2
		       _rl_screenwidth + visible_wrap_offset,
		       _rl_screenwidth + (lmargin ? 0 : wrap_offset),
d796 1
a796 1
	      nleft = _rl_screenwidth - t;
d800 2
a801 2
	  if (visible_first_line_len > _rl_screenwidth)
	    visible_first_line_len = _rl_screenwidth;
d811 1
a811 1
    char *vtemp = visible_line;
d815 1
a815 1
    invisible_line = vtemp;
a857 5
  int col_lendiff, col_temp;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps_new, ps_old;
  int new_offset, old_offset, tmp;
#endif
d865 2
a866 2
  if (temp == _rl_screenwidth && _rl_term_autowrap && !_rl_horizontal_scroll_mode
	&& _rl_last_v_pos == current_line - 1)
d868 2
a869 54
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  wchar_t wc;
	  mbstate_t ps;
	  int tempwidth, bytes;
	  size_t ret;

	  /* This fixes only double-column characters, but if the wrapped
	     character comsumes more than three columns, spaces will be
	     inserted in the string buffer. */
	  if (_rl_wrapped_line[current_line] > 0)
	    _rl_clear_to_eol (_rl_wrapped_line[current_line]);

	  memset (&ps, 0, sizeof (mbstate_t));
	  ret = mbrtowc (&wc, new, MB_CUR_MAX, &ps);
	  if (ret == (size_t)-1 || ret == (size_t)-2)
	    {
	      tempwidth = 1;
	      ret = 1;
	    }
	  else if (ret == 0)
	    tempwidth = 0;
	  else
	    tempwidth = wcwidth (wc);

	  if (tempwidth > 0)
	    {
	      int count;
	      bytes = ret;
	      for (count = 0; count < bytes; count++)
		putc (new[count], rl_outstream);
	      _rl_last_c_pos = tempwidth;
	      _rl_last_v_pos++;
	      memset (&ps, 0, sizeof (mbstate_t));
	      ret = mbrtowc (&wc, old, MB_CUR_MAX, &ps);
	      if (ret != 0 && bytes != 0)
		{
		  if (ret == (size_t)-1 || ret == (size_t)-2)
		    memmove (old+bytes, old+1, strlen (old+1));
		  else
		    memmove (old+bytes, old+ret, strlen (old+ret));
		  memcpy (old, new, bytes);
		}
	    }
	  else
	    {
	      putc (' ', rl_outstream);
	      _rl_last_c_pos = 1;
	      _rl_last_v_pos++;
	      if (old[0] && new[0])
		old[0] = new[0];
	    }
	}
d871 5
a875 11
#endif
	{
	  if (new[0])
	    putc (new[0], rl_outstream);
	  else
	    putc (' ', rl_outstream);
	  _rl_last_c_pos = 1;		/* XXX */
	  _rl_last_v_pos++;
	  if (old[0] && new[0])
	    old[0] = new[0];
	}
a876 1

a878 19
#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      memset (&ps_new, 0, sizeof(mbstate_t));
      memset (&ps_old, 0, sizeof(mbstate_t));

      new_offset = old_offset = 0;
      for (ofd = old, nfd = new;
	   (ofd - old < omax) && *ofd &&
	     _rl_compare_chars(old, old_offset, &ps_old, new, new_offset, &ps_new); )
	{
	  old_offset = _rl_find_next_mbchar (old, old_offset, 1, MB_FIND_ANY);
	  new_offset = _rl_find_next_mbchar (new, new_offset, 1, MB_FIND_ANY);
	  ofd = old + old_offset;
	  nfd = new + new_offset;
	}
    }
  else
#endif
a894 27

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      ols = old + _rl_find_prev_mbchar (old, oe - old, MB_FIND_ANY);
      nls = new + _rl_find_prev_mbchar (new, ne - new, MB_FIND_ANY);
      while ((ols > ofd) && (nls > nfd))
	{
	  memset (&ps_old, 0, sizeof (mbstate_t));
	  memset (&ps_new, 0, sizeof (mbstate_t));

	  _rl_adjust_point (old, ols - old, &ps_old);
	  _rl_adjust_point (new, nls - new, &ps_new);

	  if (_rl_compare_chars (old, ols - old, &ps_old, new, nls - new, &ps_new) == 0)
	    break;

	  if (*ols == ' ')
	    wsatend = 0;

	  ols = old + _rl_find_prev_mbchar (old, ols - old, MB_FIND_ANY);
	  nls = new + _rl_find_prev_mbchar (new, nls - new, MB_FIND_ANY);
	}
    }
  else
    {
#endif /* HANDLE_MULTIBYTE */
a903 3
#if defined (HANDLE_MULTIBYTE)
    }
#endif
a909 6
#if defined (HANDLE_MULTIBYTE)
  /* This may not work for stateful encoding, but who cares?  To handle
     stateful encoding properly, we have to scan each string from the
     beginning and compare. */
  else if (_rl_compare_chars (ols, 0, NULL, nls, 0, NULL) == 0)
#else
a910 1
#endif
d913 1
a913 6
	{
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    ols = old + _rl_find_next_mbchar (old, ols - old, 1, MB_FIND_ANY);
	  else
	    ols++;
	}
d915 1
a915 6
	{
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    nls = new + _rl_find_next_mbchar (new, nls - new, 1, MB_FIND_ANY);
	  else
	    nls++;
	}
d942 2
a943 2
      _rl_term_cr && lendiff > prompt_visible_length && _rl_last_c_pos > 0 &&
      od >= lendiff && _rl_last_c_pos <= prompt_last_invisible)
d948 1
a948 1
      tputs (_rl_term_cr, 1, _rl_output_character_function);
d951 1
a951 4
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	_rl_last_c_pos = _rl_col_width (local_prompt, 0, lendiff);
      else
	_rl_last_c_pos = lendiff;
d956 1
a956 4
  /* if (len (new) > len (old))
     lendiff == difference in buffer
     col_lendiff == difference on screen
     When not using multibyte characters, these are equal */
a957 4
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    col_lendiff = _rl_col_width (new, nfd - new, nls - new) - _rl_col_width (old, ofd - old, ols - old);
  else
    col_lendiff = lendiff;
d964 1
a964 12
    {
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  lendiff += visible_wrap_offset - current_invis_chars;
	  col_lendiff += visible_wrap_offset - current_invis_chars;
	}
      else
	{
	  lendiff += visible_wrap_offset - current_invis_chars;
	  col_lendiff = lendiff;
	}
    }
d968 1
a968 6
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    col_temp = _rl_col_width (new, nfd - new, ne - new);
  else
    col_temp = temp;

  if (col_lendiff > 0)	/* XXX - was lendiff */
d976 1
a976 1
      if (_rl_terminal_can_insert && ((2 * col_temp) >= col_lendiff || _rl_term_IC) && (!_rl_term_autowrap || !gl))
d978 1
a978 1
	  /* If lendiff > prompt_visible_length and _rl_last_c_pos == 0 and
d980 1
a980 1
	     _rl_term_IC or _rl_term_ic will screw up the screen because of the
d983 1
a983 1
			lendiff <= prompt_visible_length || !current_invis_chars))
d985 2
a986 2
	      insert_some_chars (nfd, lendiff, col_lendiff);
	      _rl_last_c_pos += col_lendiff;
d995 1
a995 1
	      _rl_last_c_pos += col_lendiff;
d1003 1
a1003 1
	      _rl_last_c_pos += col_temp;
d1011 1
a1011 5
#if 0
	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-lendiff) - col_lendiff;
#else
	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-col_lendiff);
#endif
d1018 1
a1018 1
	  _rl_last_c_pos += col_temp;
d1024 1
a1024 1
      if (_rl_term_dc && (2 * col_temp) >= -col_lendiff)
d1031 1
a1031 1
	    col_lendiff = 0;
d1033 2
a1034 2
	  if (col_lendiff)
	    delete_chars (-col_lendiff); /* delete (diff) characters */
d1041 1
a1041 1
	      _rl_last_c_pos += _rl_col_width (nfd, 0, temp);;
d1050 1
a1050 1
	      _rl_last_c_pos += col_temp;
d1053 1
a1053 6
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    col_lendiff = _rl_col_width (old, 0, oe - old) - _rl_col_width (new, 0, ne - new);
	  else
	    col_lendiff = lendiff;

	  if (col_lendiff)
d1056 1
a1056 1
		space_to_eol (col_lendiff);
d1058 1
a1058 1
		_rl_clear_to_eol (col_lendiff);
d1104 1
a1104 4
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    _rl_last_c_pos = _rl_col_width (prompt_last_line, 0, l);
  else
    _rl_last_c_pos = l;
d1109 1
a1109 1
  real_screenwidth = _rl_screenwidth + (_rl_term_autowrap ? 0 : 1);
d1154 1
a1154 1
     const char *data;
a1158 6
#if defined (HANDLE_MULTIBYTE)
  /* If we have multibyte characters, NEW is indexed by the buffer point in
     a multibyte string, but _rl_last_c_pos is the display position.  In
     this case, NEW's display position is not obvious. */
  if ((MB_CUR_MAX == 1 || rl_byte_oriented ) && _rl_last_c_pos == new) return;
#else
a1159 1
#endif
d1166 1
a1166 1
      (_rl_term_autowrap && i == _rl_screenwidth))
d1171 1
a1171 1
      tputs (_rl_term_cr, 1, _rl_output_character_function);
d1188 1
a1188 22
      if (_rl_term_forward_char)
	{
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      int width;
	      width = _rl_col_width (data, _rl_last_c_pos, new);
	      for (i = 0; i < width; i++)
		tputs (_rl_term_forward_char, 1, _rl_output_character_function);
	    }
	  else
	    {
	      for (i = _rl_last_c_pos; i < new; i++)
		tputs (_rl_term_forward_char, 1, _rl_output_character_function);
	    }
	}
      else if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  tputs (_rl_term_cr, 1, _rl_output_character_function);
	  for (i = 0; i < new; i++)
	    putc (data[i], rl_outstream);
	}
      else
d1190 1
a1190 10
	  putc (data[i], rl_outstream);

#else /* !HACK_TERMCAP_MOTION */

      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  tputs (_rl_term_cr, 1, _rl_output_character_function);
	  for (i = 0; i < new; i++)
	    putc (data[i], rl_outstream);
	}
d1194 4
a1197 3

#endif /* !HACK_TERMCAP_MOTION */

a1198 7
#if defined (HANDLE_MULTIBYTE)
  /* NEW points to the buffer point, but _rl_last_c_pos is the display point.
     The byte length of the string is probably bigger than the column width
     of the string, which means that if NEW == _rl_last_c_pos, then NEW's
     display point is less than _rl_last_c_pos. */
  else if (_rl_last_c_pos >= new)
#else
d1200 2
a1201 16
#endif
    {
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  tputs (_rl_term_cr, 1, _rl_output_character_function);
	  for (i = 0; i < new; i++)
	    putc (data[i], rl_outstream);
	}
      else
	_rl_backspace (_rl_last_c_pos - new);
    }

  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    _rl_last_c_pos =  _rl_col_width (data, 0, new);
  else
    _rl_last_c_pos = new;
d1211 1
a1211 1
  if (_rl_last_v_pos == to || to > _rl_screenheight)
d1221 1
a1221 1
      tputs (_rl_term_cr, 1, _rl_output_character_function);
d1227 1
a1227 1
      if (_rl_term_up && *_rl_term_up)
d1229 1
a1229 1
	  tputs (_rl_term_up, 1, _rl_output_character_function);
d1288 1
a1288 1
  return ((ISPRINT (uc)) ? 1 : 2);
a1314 3
#if defined (HAVE_VSNPRINTF)
  vsnprintf (msg_buf, sizeof (msg_buf) - 1, format, args);
#else
a1315 2
  msg_buf[sizeof(msg_buf) - 1] = '\0';	/* overflow? */
#endif
a1327 1
  msg_buf[sizeof(msg_buf) - 1] = '\0';	/* overflow? */
d1363 2
a1364 2
  saved_last_invisible = prompt_last_invisible;
  saved_visible_length = prompt_visible_length;
d1367 1
a1367 1
  prompt_last_invisible = prompt_visible_length = 0;
d1373 4
a1376 2
  FREE (local_prompt);
  FREE (local_prompt_prefix);
d1380 2
a1381 2
  prompt_last_invisible = saved_last_invisible;
  prompt_visible_length = saved_visible_length;
d1396 1
a1396 1
      pmt = (char *)xmalloc (len + 2);
d1405 1
a1405 1
      pmt = (char *)xmalloc (len + 2);
d1411 2
a1412 2
      prompt_last_invisible = saved_last_invisible;
      prompt_visible_length = saved_visible_length + 1;
d1439 2
a1440 2
  if (_rl_term_clreol)
    tputs (_rl_term_clreol, 1, _rl_output_character_function);
d1462 2
a1463 2
  if (_rl_term_clrpag)
    tputs (_rl_term_clrpag, 1, _rl_output_character_function);
d1465 1
a1465 1
    rl_crlf ();
d1468 1
a1468 1
/* Insert COUNT characters from STRING to the output stream at column COL. */
d1470 1
a1470 1
insert_some_chars (string, count, col)
d1472 1
a1472 1
     int count, col;
a1473 5
  /* DEBUGGING */
  if (MB_CUR_MAX == 1 || rl_byte_oriented)
    if (count != col)
      fprintf(stderr, "readline: debug: insert_some_chars: count (%d) != col (%d)\n", count, col);

d1475 1
a1475 1
  if (_rl_term_IC)
d1478 1
a1478 2

      buffer = tgoto (_rl_term_IC, 0, col);
d1487 2
a1488 2
      if (_rl_term_im && *_rl_term_im)
	tputs (_rl_term_im, 1, _rl_output_character_function);
d1492 1
a1492 1
      if (_rl_term_ic && *_rl_term_ic)
d1494 2
a1495 2
	  for (i = col; i--; )
	    tputs (_rl_term_ic, 1, _rl_output_character_function);
d1503 2
a1504 2
      if (_rl_term_ei && *_rl_term_ei)
	tputs (_rl_term_ei, 1, _rl_output_character_function);
d1513 1
a1513 1
  if (count > _rl_screenwidth)	/* XXX */
d1516 1
a1516 1
  if (_rl_term_DC && *_rl_term_DC)
d1519 1
a1519 1
      buffer = tgoto (_rl_term_DC, count, count);
d1524 1
a1524 1
      if (_rl_term_dc && *_rl_term_dc)
d1526 1
a1526 1
	  tputs (_rl_term_dc, 1, _rl_output_character_function);
d1546 1
a1546 1
  if (full_lines && _rl_term_autowrap && (VIS_LLEN(_rl_vis_botlin) == _rl_screenwidth))
d1549 3
a1551 1

d1553 2
a1554 1
      _rl_move_cursor_relative (_rl_screenwidth - 1, last_line);
d1556 1
a1556 1
      putc (last_line[_rl_screenwidth - 1], rl_outstream);
d1559 1
a1559 1
  rl_crlf ();
d1568 1
a1568 1
  if (_rl_term_cr)
d1573 1
a1573 1
      tputs (_rl_term_cr, 1, _rl_output_character_function);
d1587 1
a1587 1
  int oldlen, oldlast, oldplen, oldninvis;
d1593 3
a1595 4
  oldlen = prompt_visible_length;
  oldplen = prompt_prefix_length;
  oldlast = prompt_last_invisible;
  oldninvis = prompt_invis_chars_first_line;
d1598 1
a1598 3
  local_prompt = expand_prompt (t, &prompt_visible_length,
				   &prompt_last_invisible,
				   &prompt_invis_chars_first_line);
d1605 3
a1607 4
  prompt_visible_length = oldlen;
  prompt_prefix_length = oldplen;
  prompt_last_invisible = oldlast;
  prompt_invis_chars_first_line = oldninvis;
d1618 1
a1618 1
  if (_rl_term_cr)
d1623 1
a1623 1
      tputs (_rl_term_cr, 1, _rl_output_character_function);
d1627 1
a1627 1
      space_to_eol (_rl_screenwidth);
d1630 2
a1631 2
      if (_rl_term_clreol)
	tputs (_rl_term_clreol, 1, _rl_output_character_function);
d1634 2
a1635 2
	  space_to_eol (_rl_screenwidth);
	  tputs (_rl_term_cr, 1, _rl_output_character_function);
d1642 1
a1642 1
    rl_crlf ();
d1683 1
a1683 1
    nleft = _rl_last_c_pos - _rl_screenwidth - rl_visible_prompt_length;
d1685 1
a1685 1
    nleft = _rl_last_c_pos - _rl_screenwidth;
d1688 1
a1688 1
    ret = 1 + nleft / _rl_screenwidth;
a1693 84

#if defined (HANDLE_MULTIBYTE)
/* Calculate the number of screen columns occupied by STR from START to END.
   In the case of multibyte characters with stateful encoding, we have to
   scan from the beginning of the string to take the state into account. */
static int
_rl_col_width (str, start, end)
     char *str;
     int start, end;
{
  wchar_t wc;
  mbstate_t ps = {0};
  int tmp, point, width, max;

  if (end <= start)
    return 0;

  point = 0;
  max = end;

  while (point < start)
    {
      tmp = mbrlen (str + point, max, &ps);
      if ((size_t)tmp == (size_t)-1 || (size_t)tmp == (size_t)-2)
	{
	  /* In this case, the bytes are invalid or too short to compose a
	     multibyte character, so we assume that the first byte represents
	     a single character. */
	  point++;
	  max--;

	  /* Clear the state of the byte sequence, because in this case the
	     effect of mbstate is undefined. */
	  memset (&ps, 0, sizeof (mbstate_t));
	}
      else if (tmp == 0)
        break;		/* Found '\0' */
      else
	{
	  point += tmp;
	  max -= tmp;
	}
    }

  /* If START is not a byte that starts a character, then POINT will be
     greater than START.  In this case, assume that (POINT - START) gives
     a byte count that is the number of columns of difference. */
  width = point - start;

  while (point < end)
    {
      tmp = mbrtowc (&wc, str + point, max, &ps);
      if ((size_t)tmp == (size_t)-1 || (size_t)tmp == (size_t)-2)
	{
	  /* In this case, the bytes are invalid or too short to compose a
	     multibyte character, so we assume that the first byte represents
	     a single character. */
	  point++;
	  max--;

	  /* and assume that the byte occupies a single column. */
	  width++;

	  /* Clear the state of the byte sequence, because in this case the
	     effect of mbstate is undefined. */
	  memset (&ps, 0, sizeof (mbstate_t));
	}
      else if (tmp == 0)
        break;			/* Found '\0' */
      else
	{
	  point += tmp;
	  max -= tmp;
	  tmp = wcwidth(wc);
	  width += (tmp >= 0) ? tmp : 1;
	}
    }

  width += point - end;

  return width;
}
#endif /* HANDLE_MULTIBYTE */
	  
@


1.1.1.7
log
@import of readlilne 5.1
@
text
@d3 1
a3 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
d73 1
a73 1
static int _rl_col_width PARAMS((const char *, int, int));
a120 1
int _rl_want_redisplay = 0;
a126 1

a127 4
/* NOTE: _rl_last_c_pos is used as a buffer index when not in a locale
   supporting multibyte characters, and an absolute cursor position when
   in such a locale.  This is an artifact of the donated multibyte support.
   Care must be taken when modifying its value. */
a130 2
static int cpos_adjusted;

a180 14
static int prompt_physical_chars;

/* Variables to save and restore prompt and display information. */

/* These are getting numerous enough that it's time to create a struct. */

static char *saved_local_prompt;
static char *saved_local_prefix;
static int saved_last_invisible;
static int saved_visible_length;
static int saved_prefix_length;
static int saved_invis_chars_first_line;
static int saved_physical_chars;

d186 1
a186 2
   the first prompt line.  The previous are used as byte counts -- indexes
   into a character buffer. */
d196 1
a196 1
expand_prompt (pmt, lp, lip, niflp, vlp)
d198 1
a198 1
     int *lp, *lip, *niflp, *vlp;
d201 1
a201 1
  int l, rl, last, ignoring, ninvis, invfl, invflset, ind, pind, physchars;
d204 1
a204 1
  if ((MB_CUR_MAX <= 1 || rl_byte_oriented) && strchr (pmt, RL_PROMPT_START_IGNORE) == 0)
a208 6
      if (lip)
	*lip = 0;
      if (niflp)
	*niflp = 0;
      if (vlp)
	*vlp = lp ? *lp : strlen (r);
a215 1
  invflset = 0;	/* we only want to set invfl once */
d217 1
a217 1
  for (rl = ignoring = last = ninvis = physchars = 0, p = pmt; p && *p; p++)
d229 1
a229 2
	  if (p[-1] != RL_PROMPT_START_IGNORE)
	    last = r - ret - 1;
d234 3
a236 17
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      pind = p - pmt;
	      ind = _rl_find_next_mbchar (pmt, pind, 1, MB_FIND_NONZERO);
	      l = ind - pind;
	      while (l--)
	        *r++ = *p++;
	      if (!ignoring)
		{
		  rl += ind - pind;
		  physchars += _rl_col_width (pmt, pind, ind);
		}
	      else
		ninvis += ind - pind;
	      p--;			/* compensate for later increment */
	    }
d238 3
a240 17
#endif
	    {
	      *r++ = *p;
	      if (!ignoring)
		{
		  rl++;			/* visible length byte counter */
		  physchars++;
		}
	      else
		ninvis++;		/* invisible chars byte counter */
	    }

	  if (invflset == 0 && rl >= _rl_screenwidth)
	    {
	      invfl = ninvis;
	      invflset = 1;
	    }
a253 2
  if  (vlp)
    *vlp = physchars;
d265 1
a265 1
  ret = expand_prompt (pmt, (int *)NULL, (int *)NULL, (int *)NULL, (int *)NULL);
d298 1
a298 2
  prompt_last_invisible = prompt_invis_chars_first_line = 0;
  prompt_visible_length = prompt_physical_chars = 0;
d309 1
a309 2
					    &prompt_invis_chars_first_line,
					    &prompt_physical_chars);
d319 1
a319 2
				       (int *)NULL,
				       &prompt_physical_chars);
d325 1
a325 2
						   &prompt_invis_chars_first_line,
						   (int *)NULL);
d383 2
a384 2
  int c_pos, inv_botlin, lb_botlin, lb_linenum, o_cpos;
  int newlines, lpos, temp, modmark, n0, num;
d400 1
a400 1
  if (invisible_line == 0 || vis_lbreaks == 0)
a413 1
  modmark = 0;
a417 1
      modmark = 1;
d471 1
a471 1
      prompt_physical_chars = pmtlen = strlen (prompt_this_line);
a529 1
#if 0
a530 4
#else
  lpos = prompt_physical_chars + modmark;
#endif

a532 1
  num = 0;
d549 4
a552 15
         prompts that exceed two physical lines?
         Additional logic fix from Edward Catmur <ed@@catmur.co.uk> */
#if defined (HANDLE_MULTIBYTE)
      n0 = num;
      temp = local_prompt ? strlen (local_prompt) : 0;
      while (num < temp)
	{
	  if (_rl_col_width  (local_prompt, n0, num) > _rl_screenwidth)
	    {
	      num = _rl_find_prev_mbchar (local_prompt, num, MB_FIND_ANY);
	      break;
	    }
	  num++;
	}
      temp = num +
d554 4
a557 6
      temp = ((newlines + 1) * _rl_screenwidth) +
#endif /* !HANDLE_MULTIBYTE */
             ((local_prompt_prefix == 0) ? ((newlines == 0) ? prompt_invis_chars_first_line
							    : ((newlines == 1) ? wrap_offset : 0))
					 : ((newlines == 0) ? wrap_offset :0));
             
a558 3
#if defined (HANDLE_MULTIBYTE)
      lpos -= _rl_col_width (local_prompt, n0, num);
#else
a559 1
#endif
d589 1
a589 1
	  if (MB_INVALIDCH (wc_bytes))
d598 1
a598 1
	  else if (MB_NULLWCH (wc_bytes))
d603 1
a603 1
	      wc_width = (temp >= 0) ? temp : 1;
d768 1
a768 1
      int nleft, pos, changed_screen_line, tx;
a798 2
	      o_cpos = _rl_last_c_pos;
	      cpos_adjusted = 0;
a801 15
	      /* update_line potentially changes _rl_last_c_pos, but doesn't
		 take invisible characters into account, since _rl_last_c_pos
		 is an absolute cursor position in a multibyte locale.  See
		 if compensating here is the right thing, or if we have to
		 change update_line itself.  There is one case in which
		 update_line adjusts _rl_last_c_pos itself (so it can pass
		 _rl_move_cursor_relative accurate values); it communicates
		 this back by setting cpos_adjusted */
	      if (linenum == 0 && (MB_CUR_MAX > 1 && rl_byte_oriented == 0) &&
		  cpos_adjusted == 0 &&
		  _rl_last_c_pos != o_cpos &&
		  _rl_last_c_pos > wrap_offset &&
		  o_cpos < prompt_last_invisible)
		_rl_last_c_pos -= wrap_offset;
		  
d813 1
a813 4
		  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		    nleft = _rl_screenwidth - _rl_last_c_pos;
		  else
		    nleft = _rl_screenwidth + wrap_offset - _rl_last_c_pos;
d849 1
a849 1
	      if ((MB_CUR_MAX == 1 || rl_byte_oriented) && cursor_linenum == 0 && wrap_offset)
d870 1
a870 1
		_rl_last_c_pos = _rl_col_width (local_prompt, 0, nleft) - wrap_offset;
a881 5
	  /* NLEFT is now a number of characters in a buffer.  When in a
	     multibyte locale, however, _rl_last_c_pos is an absolute cursor
	     position that doesn't take invisible characters in the prompt
	     into account.  We use a fudge factor to compensate. */

d887 1
d889 1
a889 1
		tx = _rl_col_width (&visible_line[pos], 0, nleft) - visible_wrap_offset;
d891 1
a891 6
		tx = nleft;
	      if (_rl_last_c_pos > tx)
		{
	          _rl_backspace (_rl_last_c_pos - tx);	/* XXX */
	          _rl_last_c_pos = tx;
		}
a893 4
	  /* We need to note that in a multibyte locale we are dealing with
	     _rl_last_c_pos as an absolute cursor position, but moving to a
	     point specified by a buffer position (NLEFT) that doesn't take
	     invisible characters into account. */
d1052 1
a1052 4
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    temp = _rl_last_c_pos;
  else
    temp = _rl_last_c_pos - W_OFFSET(_rl_last_v_pos, visible_wrap_offset);
d1072 1
a1072 1
	  if (MB_INVALIDCH (ret))
d1077 1
a1077 1
	  else if (MB_NULLWCH (ret))
d1094 1
a1094 1
		  if (MB_INVALIDCH (ret))
d1117 1
a1117 1
	  _rl_last_c_pos = 1;
d1129 2
a1130 12
      /* See if the old line is a subset of the new line, so that the
	 only change is adding characters. */
      temp = (omax < nmax) ? omax : nmax;
      if (memcmp (old, new, temp) == 0)
	{
	  ofd = old + temp;
	  nfd = new + temp;
	}
      else
	{      
	  memset (&ps_new, 0, sizeof(mbstate_t));
	  memset (&ps_old, 0, sizeof(mbstate_t));
d1132 9
a1140 18
	  if (omax == nmax && STREQN (new, old, omax))
	    {
	      ofd = old + omax;
	      nfd = new + nmax;
	    }
	  else
	    {
	      new_offset = old_offset = 0;
	      for (ofd = old, nfd = new;
		    (ofd - old < omax) && *ofd &&
		    _rl_compare_chars(old, old_offset, &ps_old, new, new_offset, &ps_new); )
		{
		  old_offset = _rl_find_next_mbchar (old, old_offset, 1, MB_FIND_ANY);
		  new_offset = _rl_find_next_mbchar (new, new_offset, 1, MB_FIND_ANY);
		  ofd = old + old_offset;
		  nfd = new + new_offset;
		}
	    }
a1171 2
#if 0
	  /* On advice from jir@@yamato.ibm.com */
a1173 1
#endif
d1236 1
a1236 1
      if ((MB_CUR_MAX == 1 || rl_byte_oriented) && current_line == 0 && visible_wrap_offset)
d1265 1
a1265 6
	{
	  /* We take wrap_offset into account here so we can pass correct
	     information to _rl_move_cursor_relative. */
	  _rl_last_c_pos = _rl_col_width (local_prompt, 0, lendiff) - wrap_offset;
	  cpos_adjusted = 1;
	}
d1327 1
a1327 1
	  else if ((MB_CUR_MAX == 1 || rl_byte_oriented != 0) && *ols == 0 && lendiff > 0)
d1350 3
a1352 5
#if 1
	     /* XXX -- this bears closer inspection.  Fixes a redisplay bug
		reported against bash-3.0-alpha by Andreas Schwab involving
		multibyte characters and prompt strings with invisible
		characters, but was previously disabled. */
a1353 2
#else
	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-lendiff);
a1361 4
	  /* If we're in a multibyte locale and were before the last invisible
	     char in the current line (which implies we just output some invisible
	     characters) we need to adjust _rl_last_c_pos, since it represents
	     a physical character position. */
d1393 1
a1393 1
	      _rl_last_c_pos += col_temp;		/* XXX */
d1429 1
a1429 2
   distributed with CLISP.  rl_expand_prompt must have already been called
   (explicitly or implicitly).  This still doesn't work exactly right. */
d1434 1
a1434 1
  char *prompt_last_line, *lprompt;
d1443 2
a1444 3
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
  strcpy (invisible_line, lprompt);
d1453 1
a1453 1
    _rl_last_c_pos = _rl_col_width (prompt_last_line, 0, l);	/* XXX */
a1478 2
  rl_display_prompt = rl_prompt;	/* XXX - make sure it's set */

a1499 2
   (Well, when we don't have multibyte characters, _rl_last_c_pos is a
   buffer index.)
a1507 2
  int woff;			/* number of invisible chars on current line */
  int cpos, dpos;		/* current and desired cursor positions */
d1509 1
a1509 2
  woff = W_OFFSET (_rl_last_v_pos, wrap_offset);
  cpos = _rl_last_c_pos;
d1513 4
a1516 10
     this case, NEW's display position is not obvious and must be
     calculated.  We need to account for invisible characters in this line,
     as long as we are past them and they are counted by _rl_col_width. */
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      dpos = _rl_col_width (data, 0, new);
      if (dpos > woff)
	dpos -= woff;
    }
  else
a1517 5
    dpos = new;

  /* If we don't have to do anything, then return. */
  if (cpos == dpos)
    return;
d1522 1
a1522 6
#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    i = _rl_last_c_pos;
  else
#endif
  i = _rl_last_c_pos - woff;
d1531 1
a1531 1
      cpos = _rl_last_c_pos = 0;
d1534 1
a1534 1
  if (cpos < dpos)
d1548 18
a1565 2
	  for (i = cpos; i < dpos; i++)
	    tputs (_rl_term_forward_char, 1, _rl_output_character_function);
d1568 5
a1572 1
#endif /* HACK_TERMCAP_MOTION */
d1580 1
a1580 1
	for (i = cpos; i < new; i++)
d1582 3
a1585 1

d1591 3
d1595 10
a1604 2
  else if (cpos > dpos)
    _rl_backspace (cpos - dpos);
d1606 4
a1609 1
  _rl_last_c_pos = dpos;
d1698 1
a1700 1
static int msg_saved_prompt = 0;
a1730 5
  if (saved_local_prompt == 0)
    {
      rl_save_prompt ();
      msg_saved_prompt = 1;
    }
a1731 5
  local_prompt = expand_prompt (msg_buf, &prompt_visible_length,
					 &prompt_last_invisible,
					 &prompt_invis_chars_first_line,
					 &prompt_physical_chars);
  local_prompt_prefix = (char *)NULL;
a1732 1

a1741 1

a1742 10
  if (saved_local_prompt == 0)
    {
      rl_save_prompt ();
      msg_saved_prompt = 1;
    }
  local_prompt = expand_prompt (msg_buf, &prompt_visible_length,
					 &prompt_last_invisible,
					 &prompt_invis_chars_first_line,
					 &prompt_physical_chars);
  local_prompt_prefix = (char *)NULL;
a1743 1
      
a1752 5
  if (msg_saved_prompt)
    {
      rl_restore_prompt ();
      msg_saved_prompt = 0;
    }
d1767 5
a1776 1
  saved_prefix_length = prompt_prefix_length;
a1778 2
  saved_invis_chars_first_line = prompt_invis_chars_first_line;
  saved_physical_chars = prompt_physical_chars;
d1781 1
a1781 2
  prompt_last_invisible = prompt_visible_length = prompt_prefix_length = 0;
  prompt_invis_chars_first_line = prompt_physical_chars = 0;
a1791 1
  prompt_prefix_length = saved_prefix_length;
a1793 7
  prompt_invis_chars_first_line = saved_invis_chars_first_line;
  prompt_physical_chars = saved_physical_chars;

  /* can test saved_local_prompt to see if prompt info has been saved. */
  saved_local_prompt = saved_local_prefix = (char *)0;
  saved_last_invisible = saved_visible_length = saved_prefix_length = 0;
  saved_invis_chars_first_line = saved_physical_chars = 0;
a1825 3

  prompt_physical_chars = saved_physical_chars + 1;

a1885 3
#if defined (__MSDOS__) || defined (__MINGW32__)
  _rl_output_some_chars (string, count);
#else
a1923 1
#endif /* __MSDOS__ || __MINGW32__ */
a1933 1
#if !defined (__MSDOS__) && !defined (__MINGW32__)
a1945 1
#endif /* !__MSDOS__ && !__MINGW32__ */
d2001 2
a2002 1
  char *oldp;
d2004 1
d2006 6
a2011 1
  rl_save_prompt ();
d2016 1
a2016 2
				   &prompt_invis_chars_first_line,
				   &prompt_physical_chars);
a2017 1

d2021 6
a2026 1
  rl_restore_prompt();
d2120 1
a2120 1
     const char *str;
d2136 1
a2136 1
      if (MB_INVALIDCH ((size_t)tmp))
d2148 2
a2149 2
      else if (MB_NULLWCH (tmp))
	break;		/* Found '\0' */
d2165 1
a2165 1
      if (MB_INVALIDCH ((size_t)tmp))
d2180 2
a2181 2
      else if (MB_NULLWCH (tmp))
	break;			/* Found '\0' */
d2196 1
@


