head	1.11;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.11
	gdb_7_6-2013-04-26-release:1.11
	gdb_7_6-branch:1.11.0.6
	gdb_7_6-2013-03-12-branchpoint:1.11
	gdb_7_5_1-2012-11-29-release:1.11
	gdb_7_5-2012-08-17-release:1.11
	gdb_7_5-branch:1.11.0.4
	gdb_7_5-2012-07-18-branchpoint:1.11
	gdb_7_4_1-2012-04-26-release:1.11
	gdb_7_4-2012-01-24-release:1.11
	gdb_7_4-branch:1.11.0.2
	gdb_7_4-2011-12-13-branchpoint:1.11
	gdb_7_3_1-2011-09-04-release:1.8
	gdb_7_3-2011-07-26-release:1.8
	gdb_7_3-branch:1.8.0.36
	gdb_7_3-2011-04-01-branchpoint:1.8
	gdb_7_2-2010-09-02-release:1.8
	gdb_7_2-branch:1.8.0.34
	gdb_7_2-2010-07-07-branchpoint:1.8
	gdb_7_1-2010-03-18-release:1.8
	gdb_7_1-branch:1.8.0.32
	gdb_7_1-2010-02-18-branchpoint:1.8
	gdb_7_0_1-2009-12-22-release:1.8
	gdb_7_0-2009-10-06-release:1.8
	gdb_7_0-branch:1.8.0.30
	gdb_7_0-2009-09-16-branchpoint:1.8
	arc-sim-20090309:1.8
	msnyder-checkpoint-072509-branch:1.8.0.28
	msnyder-checkpoint-072509-branchpoint:1.8
	arc-insight_6_8-branch:1.8.0.26
	arc-insight_6_8-branchpoint:1.8
	insight_6_8-branch:1.8.0.24
	insight_6_8-branchpoint:1.8
	reverse-20081226-branch:1.8.0.22
	reverse-20081226-branchpoint:1.8
	multiprocess-20081120-branch:1.8.0.20
	multiprocess-20081120-branchpoint:1.8
	reverse-20080930-branch:1.8.0.18
	reverse-20080930-branchpoint:1.8
	reverse-20080717-branch:1.8.0.16
	reverse-20080717-branchpoint:1.8
	msnyder-reverse-20080609-branch:1.8.0.14
	msnyder-reverse-20080609-branchpoint:1.8
	drow-reverse-20070409-branch:1.8.0.12
	drow-reverse-20070409-branchpoint:1.8
	gdb_6_8-2008-03-27-release:1.8
	gdb_6_8-branch:1.8.0.10
	gdb_6_8-2008-02-26-branchpoint:1.8
	gdb_6_7_1-2007-10-29-release:1.8
	gdb_6_7-2007-10-10-release:1.8
	gdb_6_7-branch:1.8.0.8
	gdb_6_7-2007-09-07-branchpoint:1.8
	insight_6_6-20070208-release:1.8
	gdb_6_6-2006-12-18-release:1.8
	gdb_6_6-branch:1.8.0.6
	gdb_6_6-2006-11-15-branchpoint:1.8
	insight_6_5-20061003-release:1.8
	gdb-csl-symbian-6_4_50_20060226-12:1.6
	gdb-csl-sourcerygxx-3_4_4-25:1.6
	nickrob-async-20060828-mergepoint:1.8
	gdb-csl-symbian-6_4_50_20060226-11:1.6
	gdb-csl-sourcerygxx-4_1-17:1.6
	gdb-csl-20060226-branch-local-2:1.6
	gdb-csl-sourcerygxx-4_1-14:1.6
	gdb-csl-sourcerygxx-4_1-13:1.6
	gdb-csl-sourcerygxx-4_1-12:1.6
	gdb-csl-sourcerygxx-3_4_4-21:1.6
	gdb_6_5-20060621-release:1.8
	gdb-csl-sourcerygxx-4_1-9:1.6
	gdb-csl-sourcerygxx-4_1-8:1.6
	gdb-csl-sourcerygxx-4_1-7:1.6
	gdb-csl-arm-2006q1-6:1.6
	gdb-csl-sourcerygxx-4_1-6:1.6
	gdb-csl-symbian-6_4_50_20060226-10:1.6
	gdb-csl-symbian-6_4_50_20060226-9:1.6
	gdb-csl-symbian-6_4_50_20060226-8:1.6
	gdb-csl-coldfire-4_1-11:1.6
	gdb-csl-sourcerygxx-3_4_4-19:1.6
	gdb-csl-coldfire-4_1-10:1.6
	gdb_6_5-branch:1.8.0.4
	gdb_6_5-2006-05-14-branchpoint:1.8
	gdb-csl-sourcerygxx-4_1-5:1.6
	nickrob-async-20060513-branch:1.8.0.2
	nickrob-async-20060513-branchpoint:1.8
	gdb-csl-sourcerygxx-4_1-4:1.6
	msnyder-reverse-20060502-branch:1.7.0.4
	msnyder-reverse-20060502-branchpoint:1.7
	gdb-csl-morpho-4_1-4:1.6
	gdb-csl-sourcerygxx-3_4_4-17:1.6
	readline_5_1-import-branch:1.7.0.2
	readline_5_1-import-branchpoint:1.7
	readline-pre-51-import:1.7
	readline_5_1:1.1.1.5
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.6
	gdb-csl-symbian-20060226-branch:1.6.0.18
	gdb-csl-symbian-20060226-branchpoint:1.6
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.6
	msnyder-reverse-20060331-branch:1.6.0.16
	msnyder-reverse-20060331-branchpoint:1.6
	gdb-csl-available-20060303-branch:1.6.0.14
	gdb-csl-available-20060303-branchpoint:1.6
	gdb-csl-20060226-branch:1.6.0.12
	gdb-csl-20060226-branchpoint:1.6
	gdb_6_4-20051202-release:1.6
	msnyder-fork-checkpoint-branch:1.6.0.10
	msnyder-fork-checkpoint-branchpoint:1.6
	gdb-csl-gxxpro-6_3-branch:1.6.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.6
	gdb_6_4-branch:1.6.0.6
	gdb_6_4-2005-11-01-branchpoint:1.6
	gdb-csl-arm-20051020-branch:1.6.0.4
	gdb-csl-arm-20051020-branchpoint:1.6
	msnyder-tracepoint-checkpoint-branch:1.6.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.6
	gdb-csl-arm-20050325-2005-q1b:1.5.60.1
	gdb-csl-arm-20050325-2005-q1a:1.5.60.1
	csl-arm-20050325-branch:1.5.0.60
	csl-arm-20050325-branchpoint:1.5
	gdb_6_3-20041109-release:1.5
	gdb_6_3-branch:1.5.0.56
	gdb_6_3-20041019-branchpoint:1.5
	drow_intercu-merge-20040921:1.5
	drow_intercu-merge-20040915:1.5
	jimb-gdb_6_2-e500-branch:1.5.0.58
	jimb-gdb_6_2-e500-branchpoint:1.5
	gdb_6_2-20040730-release:1.5
	gdb_6_2-branch:1.5.0.54
	gdb_6_2-2004-07-10-gmt-branchpoint:1.5
	gdb_6_1_1-20040616-release:1.5
	gdb_6_1-2004-04-05-release:1.5
	drow_intercu-merge-20040402:1.5
	drow_intercu-merge-20040327:1.5
	ezannoni_pie-20040323-branch:1.5.0.52
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.50
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow_intercu-20040221-branch:1.5.0.46
	drow_intercu-20040221-branchpoint:1.5
	cagney_bfdfile-20040213-branch:1.5.0.44
	cagney_bfdfile-20040213-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	cagney_bigcore-20040122-branch:1.5.0.42
	cagney_bigcore-20040122-branchpoint:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	kettenis_sparc-20030918-branch:1.5.0.40
	kettenis_sparc-20030918-branchpoint:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.38
	cagney_x86i386-20030821-branch:1.5.0.36
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.34
	gdb_6_0-2003-06-23-branchpoint:1.5
	jimb-ppc64-linux-20030613-branch:1.5.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.30
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.28
	cagney_writestrings-20030508-branchpoint:1.5
	jimb-ppc64-linux-20030528-branch:1.5.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.24
	cagney_fileio-20030521-branchpoint:1.5
	kettenis_i386newframe-20030517-mergepoint:1.5
	jimb-ppc64-linux-20030509-branch:1.5.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.5
	kettenis_i386newframe-20030504-mergepoint:1.5
	carlton_dictionary-20030430-merge:1.5
	kettenis_i386newframe-20030419-branch:1.5.0.20
	kettenis_i386newframe-20030419-branchpoint:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	kettenis_i386newframe-20030406-branch:1.5.0.18
	kettenis_i386newframe-20030406-branchpoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.16
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.14
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.12
	cagney_lazyid-20030317-branchpoint:1.5
	kettenis-i386newframe-20030316-mergepoint:1.5
	offbyone-20030313-branch:1.5.0.10
	offbyone-20030313-branchpoint:1.5
	kettenis-i386newframe-20030308-branch:1.5.0.8
	kettenis-i386newframe-20030308-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.6
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.4
	interps-20030202-branchpoint:1.5
	cagney-unwind-20030108-branch:1.5.0.2
	cagney-unwind-20030108-branchpoint:1.5
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.4
	readline-pre-43-import:1.4
	carlton_dictionary-20021115-merge:1.4
	kseitz_interps-20021105-merge:1.4
	kseitz_interps-20021103-merge:1.4
	drow-cplus-merge-20021020:1.4
	drow-cplus-merge-20021025:1.4
	carlton_dictionary-20021025-merge:1.4
	carlton_dictionary-20021011-merge:1.4
	drow-cplus-branch:1.4.0.24
	drow-cplus-branchpoint:1.4
	kseitz_interps-20020930-merge:1.4
	carlton_dictionary-20020927-merge:1.4
	carlton_dictionary-branch:1.4.0.22
	carlton_dictionary-20020920-branchpoint:1.4
	gdb_5_3-branch:1.4.0.20
	gdb_5_3-2002-09-04-branchpoint:1.4
	kseitz_interps-20020829-merge:1.4
	cagney_sysregs-20020825-branch:1.4.0.18
	cagney_sysregs-20020825-branchpoint:1.4
	readline_4_3-import-branch:1.4.0.16
	readline_4_3-import-branchpoint:1.4
	readline_4_3:1.1.1.4
	gdb_5_2_1-2002-07-23-release:1.4
	kseitz_interps-20020528-branch:1.4.0.14
	kseitz_interps-20020528-branchpoint:1.4
	cagney_regbuf-20020515-branch:1.4.0.12
	cagney_regbuf-20020515-branchpoint:1.4
	jimb-macro-020506-branch:1.4.0.10
	jimb-macro-020506-branchpoint:1.4
	gdb_5_2-2002-04-29-release:1.4
	gdb_5_2-branch:1.4.0.8
	gdb_5_2-2002-03-03-branchpoint:1.4
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	insight-precleanup-2001-01-01:1.4
	readline_4_1:1.1.1.3
	readline_4_0:1.1.1.2
	FSF:1.1.1
	readline-pre-41-import:1.3
	gdb-premipsmulti-2000-06-06-branch:1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.11
date	2011.10.12.00.23.23;	author sterling;	state Exp;
branches;
next	1.10;

1.10
date	2011.10.11.23.30.27;	author sterling;	state Exp;
branches;
next	1.9;

1.9
date	2011.05.11.23.38.39;	author jkratoch;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.05.18.26.12;	author drow;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.20.20.13.20;	author ezannoni;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2005.05.09.19.42.02;	author mmitchel;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.08.22.31.37;	author ezannoni;	state Exp;
branches
	1.5.60.1;
next	1.4;

1.4
date	2000.07.09.17.19.55;	author ezannoni;	state Exp;
branches
	1.4.16.1
	1.4.22.1
	1.4.24.1;
next	1.3;

1.3
date	2000.07.07.17.15.45;	author ezannoni;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.15.11.36.20;	author eliz;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.53;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.7.2.1
date	2006.04.24.22.00.25;	author drow;	state Exp;
branches;
next	;

1.5.60.1
date	2005.03.28.19.34.24;	author mmitchel;	state Exp;
branches;
next	;

1.4.16.1
date	2002.08.25.23.41.16;	author ezannoni;	state Exp;
branches;
next	;

1.4.22.1
date	2002.12.23.19.39.41;	author carlton;	state Exp;
branches;
next	;

1.4.24.1
date	2003.12.14.20.28.12;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.53;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.08.02.23.47.57;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.07.09.16.21.20;	author ezannoni;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.08.23.22.02.27;	author ezannoni;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.20.20.05.36;	author ezannoni;	state Exp;
branches;
next	;


desc
@@


1.11
log
@2011-05-11  Sterling Augustine  <saugustine@@google.com>

	* complete.c (rl_completion_matches): Undo inadvertant checkin.
@
text
@/* complete.c -- filename completion for readline. */

/* Copyright (C) 1987-2011 Free Software Foundation, Inc.

   This file is part of the GNU Readline Library (Readline), a library
   for reading lines of text with interactive input and history editing.

   Readline is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Readline is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Readline.  If not, see <http://www.gnu.org/licenses/>.
*/

#define READLINE_LIBRARY

#if defined (HAVE_CONFIG_H)
#  include <config.h>
#endif

#include <sys/types.h>
#include <fcntl.h>
#if defined (HAVE_SYS_FILE_H)
#  include <sys/file.h>
#endif

#if defined (HAVE_UNISTD_H)
#  include <unistd.h>
#endif /* HAVE_UNISTD_H */

#if defined (HAVE_STDLIB_H)
#  include <stdlib.h>
#else
#  include "ansi_stdlib.h"
#endif /* HAVE_STDLIB_H */

#include <stdio.h>

#include <errno.h>
#if !defined (errno)
extern int errno;
#endif /* !errno */

#if defined (HAVE_PWD_H)
#include <pwd.h>
#endif

#include "posixdir.h"
#include "posixstat.h"

/* System-specific feature definitions and include files. */
#include "rldefs.h"
#include "rlmbutil.h"

/* Some standard library routines. */
#include "readline.h"
#include "xmalloc.h"
#include "rlprivate.h"

#ifdef __STDC__
typedef int QSFUNC (const void *, const void *);
#else
typedef int QSFUNC ();
#endif

#ifdef HAVE_LSTAT
#  define LSTAT lstat
#else
#  define LSTAT stat
#endif

/* Unix version of a hidden file.  Could be different on other systems. */
#define HIDDEN_FILE(fname)	((fname)[0] == '.')

/* Most systems don't declare getpwent in <pwd.h> if _POSIX_SOURCE is
   defined. */
#if defined (HAVE_GETPWENT) && (!defined (HAVE_GETPW_DECLS) || defined (_POSIX_SOURCE))
extern struct passwd *getpwent PARAMS((void));
#endif /* HAVE_GETPWENT && (!HAVE_GETPW_DECLS || _POSIX_SOURCE) */

/* If non-zero, then this is the address of a function to call when
   completing a word would normally display the list of possible matches.
   This function is called instead of actually doing the display.
   It takes three arguments: (char **matches, int num_matches, int max_length)
   where MATCHES is the array of strings that matched, NUM_MATCHES is the
   number of strings in that array, and MAX_LENGTH is the length of the
   longest string in that array. */
rl_compdisp_func_t *rl_completion_display_matches_hook = (rl_compdisp_func_t *)NULL;

#if defined (VISIBLE_STATS)
#  if !defined (X_OK)
#    define X_OK 1
#  endif
static int stat_char PARAMS((char *));
#endif

static int path_isdir PARAMS((const char *));

static char *rl_quote_filename PARAMS((char *, int, char *));

static void set_completion_defaults PARAMS((int));
static int get_y_or_n PARAMS((int));
static int _rl_internal_pager PARAMS((int));
static char *printable_part PARAMS((char *));
static int fnwidth PARAMS((const char *));
static int fnprint PARAMS((const char *, int));
static int print_filename PARAMS((char *, char *, int));

static char **gen_completion_matches PARAMS((char *, int, int, rl_compentry_func_t *, int, int));

static char **remove_duplicate_matches PARAMS((char **));
static void insert_match PARAMS((char *, int, int, char *));
static int append_to_match PARAMS((char *, int, int, int));
static void insert_all_matches PARAMS((char **, int, char *));
static int complete_fncmp PARAMS((const char *, int, const char *, int));
static void display_matches PARAMS((char **));
static int compute_lcd_of_matches PARAMS((char **, int, const char *));
static int postprocess_matches PARAMS((char ***, int));
static int complete_get_screenwidth PARAMS((void));

static char *make_quoted_replacement PARAMS((char *, int, char *));

/* **************************************************************** */
/*								    */
/*	Completion matching, from readline's point of view.	    */
/*								    */
/* **************************************************************** */

/* Variables known only to the readline library. */

/* If non-zero, non-unique completions always show the list of matches. */
int _rl_complete_show_all = 0;

/* If non-zero, non-unique completions show the list of matches, unless it
   is not possible to do partial completion and modify the line. */
int _rl_complete_show_unmodified = 0;

/* If non-zero, completed directory names have a slash appended. */
int _rl_complete_mark_directories = 1;

/* If non-zero, the symlinked directory completion behavior introduced in
   readline-4.2a is disabled, and symlinks that point to directories have
   a slash appended (subject to the value of _rl_complete_mark_directories).
   This is user-settable via the mark-symlinked-directories variable. */
int _rl_complete_mark_symlink_dirs = 0;

/* If non-zero, completions are printed horizontally in alphabetical order,
   like `ls -x'. */
int _rl_print_completions_horizontally;

/* Non-zero means that case is not significant in filename completion. */
#if defined (__MSDOS__) && !defined (__DJGPP__)
int _rl_completion_case_fold = 1;
#else
int _rl_completion_case_fold = 0;
#endif

/* Non-zero means that `-' and `_' are equivalent when comparing filenames
  for completion. */
int _rl_completion_case_map = 0;

/* If zero, don't match hidden files (filenames beginning with a `.' on
   Unix) when doing filename completion. */
int _rl_match_hidden_files = 1;

/* Length in characters of a common prefix replaced with an ellipsis (`...')
   when displaying completion matches.  Matches whose printable portion has
   more than this number of displaying characters in common will have the common
   display prefix replaced with an ellipsis. */
int _rl_completion_prefix_display_length = 0;

/* The readline-private number of screen columns to use when displaying
   matches.  If < 0 or > _rl_screenwidth, it is ignored. */
int _rl_completion_columns = -1;

/* Global variables available to applications using readline. */

#if defined (VISIBLE_STATS)
/* Non-zero means add an additional character to each filename displayed
   during listing completion iff rl_filename_completion_desired which helps
   to indicate the type of file being listed. */
int rl_visible_stats = 0;
#endif /* VISIBLE_STATS */

/* If non-zero, when completing in the middle of a word, don't insert
   characters from the match that match characters following point in
   the word.  This means, for instance, completing when the cursor is
   after the `e' in `Makefile' won't result in `Makefilefile'. */
int _rl_skip_completed_text = 0;

/* If non-zero, menu completion displays the common prefix first in the
   cycle of possible completions instead of the last. */
int _rl_menu_complete_prefix_first = 0;

/* If non-zero, then this is the address of a function to call when
   completing on a directory name.  The function is called with
   the address of a string (the current directory name) as an arg. */
rl_icppfunc_t *rl_directory_completion_hook = (rl_icppfunc_t *)NULL;

rl_icppfunc_t *rl_directory_rewrite_hook = (rl_icppfunc_t *)NULL;

/* If non-zero, this is the address of a function to call when reading
   directory entries from the filesystem for completion and comparing
   them to the partial word to be completed.  The function should
   either return its first argument (if no conversion takes place) or
   newly-allocated memory.  This can, for instance, convert filenames
   between character sets for comparison against what's typed at the
   keyboard.  The returned value is what is added to the list of
   matches.  The second argument is the length of the filename to be
   converted. */
rl_dequote_func_t *rl_filename_rewrite_hook = (rl_dequote_func_t *)NULL;

/* Non-zero means readline completion functions perform tilde expansion. */
int rl_complete_with_tilde_expansion = 0;

/* Pointer to the generator function for completion_matches ().
   NULL means to use rl_filename_completion_function (), the default filename
   completer. */
rl_compentry_func_t *rl_completion_entry_function = (rl_compentry_func_t *)NULL;

/* Pointer to generator function for rl_menu_complete ().  NULL means to use
   *rl_completion_entry_function (see above). */
rl_compentry_func_t *rl_menu_completion_entry_function = (rl_compentry_func_t *)NULL;

/* Pointer to alternative function to create matches.
   Function is called with TEXT, START, and END.
   START and END are indices in RL_LINE_BUFFER saying what the boundaries
   of TEXT are.
   If this function exists and returns NULL then call the value of
   rl_completion_entry_function to try to match, otherwise use the
   array of strings returned. */
rl_completion_func_t *rl_attempted_completion_function = (rl_completion_func_t *)NULL;

/* Non-zero means to suppress normal filename completion after the
   user-specified completion function has been called. */
int rl_attempted_completion_over = 0;

/* Set to a character indicating the type of completion being performed
   by rl_complete_internal, available for use by application completion
   functions. */
int rl_completion_type = 0;

/* Up to this many items will be displayed in response to a
   possible-completions call.  After that, we ask the user if
   she is sure she wants to see them all.  A negative value means
   don't ask. */
int rl_completion_query_items = 100;

int _rl_page_completions = 1;

/* The basic list of characters that signal a break between words for the
   completer routine.  The contents of this variable is what breaks words
   in the shell, i.e. " \t\n\"\\'`@@$><=" */
const char *rl_basic_word_break_characters = " \t\n\"\\'`@@$><=;|&{("; /* }) */

/* List of basic quoting characters. */
const char *rl_basic_quote_characters = "\"'";

/* The list of characters that signal a break between words for
   rl_complete_internal.  The default list is the contents of
   rl_basic_word_break_characters.  */
/*const*/ char *rl_completer_word_break_characters = (/*const*/ char *)NULL;

/* Hook function to allow an application to set the completion word
   break characters before readline breaks up the line.  Allows
   position-dependent word break characters. */
rl_cpvfunc_t *rl_completion_word_break_hook = (rl_cpvfunc_t *)NULL;

/* List of characters which can be used to quote a substring of the line.
   Completion occurs on the entire substring, and within the substring
   rl_completer_word_break_characters are treated as any other character,
   unless they also appear within this list. */
const char *rl_completer_quote_characters = (const char *)NULL;

/* List of characters that should be quoted in filenames by the completer. */
const char *rl_filename_quote_characters = (const char *)NULL;

/* List of characters that are word break characters, but should be left
   in TEXT when it is passed to the completion function.  The shell uses
   this to help determine what kind of completing to do. */
const char *rl_special_prefixes = (const char *)NULL;

/* If non-zero, then disallow duplicates in the matches. */
int rl_ignore_completion_duplicates = 1;

/* Non-zero means that the results of the matches are to be treated
   as filenames.  This is ALWAYS zero on entry, and can only be changed
   within a completion entry finder function. */
int rl_filename_completion_desired = 0;

/* Non-zero means that the results of the matches are to be quoted using
   double quotes (or an application-specific quoting mechanism) if the
   filename contains any characters in rl_filename_quote_chars.  This is
   ALWAYS non-zero on entry, and can only be changed within a completion
   entry finder function. */
int rl_filename_quoting_desired = 1;

/* This function, if defined, is called by the completer when real
   filename completion is done, after all the matching names have been
   generated. It is passed a (char**) known as matches in the code below.
   It consists of a NULL-terminated array of pointers to potential
   matching strings.  The 1st element (matches[0]) is the maximal
   substring that is common to all matches. This function can re-arrange
   the list of matches as required, but all elements of the array must be
   free()'d if they are deleted. The main intent of this function is
   to implement FIGNORE a la SunOS csh. */
rl_compignore_func_t *rl_ignore_some_completions_function = (rl_compignore_func_t *)NULL;

/* Set to a function to quote a filename in an application-specific fashion.
   Called with the text to quote, the type of match found (single or multiple)
   and a pointer to the quoting character to be used, which the function can
   reset if desired. */
rl_quote_func_t *rl_filename_quoting_function = rl_quote_filename;
         
/* Function to call to remove quoting characters from a filename.  Called
   before completion is attempted, so the embedded quotes do not interfere
   with matching names in the file system.  Readline doesn't do anything
   with this; it's set only by applications. */
rl_dequote_func_t *rl_filename_dequoting_function = (rl_dequote_func_t *)NULL;

/* Function to call to decide whether or not a word break character is
   quoted.  If a character is quoted, it does not break words for the
   completer. */
rl_linebuf_func_t *rl_char_is_quoted_p = (rl_linebuf_func_t *)NULL;

/* If non-zero, the completion functions don't append anything except a
   possible closing quote.  This is set to 0 by rl_complete_internal and
   may be changed by an application-specific completion function. */
int rl_completion_suppress_append = 0;

/* Character appended to completed words when at the end of the line.  The
   default is a space. */
int rl_completion_append_character = ' ';

/* If non-zero, the completion functions don't append any closing quote.
   This is set to 0 by rl_complete_internal and may be changed by an
   application-specific completion function. */
int rl_completion_suppress_quote = 0;

/* Set to any quote character readline thinks it finds before any application
   completion function is called. */
int rl_completion_quote_character;

/* Set to a non-zero value if readline found quoting anywhere in the word to
   be completed; set before any application completion function is called. */
int rl_completion_found_quote;

/* If non-zero, a slash will be appended to completed filenames that are
   symbolic links to directory names, subject to the value of the
   mark-directories variable (which is user-settable).  This exists so
   that application completion functions can override the user's preference
   (set via the mark-symlinked-directories variable) if appropriate.
   It's set to the value of _rl_complete_mark_symlink_dirs in
   rl_complete_internal before any application-specific completion
   function is called, so without that function doing anything, the user's
   preferences are honored. */
int rl_completion_mark_symlink_dirs;

/* If non-zero, inhibit completion (temporarily). */
int rl_inhibit_completion;

/* Set to the last key used to invoke one of the completion functions */
int rl_completion_invoking_key;

/* If non-zero, sort the completion matches.  On by default. */
int rl_sort_completion_matches = 1;

/* Variables local to this file. */

/* Local variable states what happened during the last completion attempt. */
static int completion_changed_buffer;

/* The result of the query to the user about displaying completion matches */
static int completion_y_or_n;

/*************************************/
/*				     */
/*    Bindable completion functions  */
/*				     */
/*************************************/

/* Complete the word at or before point.  You have supplied the function
   that does the initial simple matching selection algorithm (see
   rl_completion_matches ()).  The default is to do filename completion. */
int
rl_complete (ignore, invoking_key)
     int ignore, invoking_key;
{
  rl_completion_invoking_key = invoking_key;

  if (rl_inhibit_completion)
    return (_rl_insert_char (ignore, invoking_key));
  else if (rl_last_func == rl_complete && !completion_changed_buffer)
    return (rl_complete_internal ('?'));
  else if (_rl_complete_show_all)
    return (rl_complete_internal ('!'));
  else if (_rl_complete_show_unmodified)
    return (rl_complete_internal ('@@'));
  else
    return (rl_complete_internal (TAB));
}

/* List the possible completions.  See description of rl_complete (). */
int
rl_possible_completions (ignore, invoking_key)
     int ignore, invoking_key;
{
  rl_completion_invoking_key = invoking_key;
  return (rl_complete_internal ('?'));
}

int
rl_insert_completions (ignore, invoking_key)
     int ignore, invoking_key;
{
  rl_completion_invoking_key = invoking_key;
  return (rl_complete_internal ('*'));
}

/* Return the correct value to pass to rl_complete_internal performing
   the same tests as rl_complete.  This allows consecutive calls to an
   application's completion function to list possible completions and for
   an application-specific completion function to honor the
   show-all-if-ambiguous readline variable. */
int
rl_completion_mode (cfunc)
     rl_command_func_t *cfunc;
{
  if (rl_last_func == cfunc && !completion_changed_buffer)
    return '?';
  else if (_rl_complete_show_all)
    return '!';
  else if (_rl_complete_show_unmodified)
    return '@@';
  else
    return TAB;
}

/************************************/
/*				    */
/*    Completion utility functions  */
/*				    */
/************************************/

/* Reset readline state on a signal or other event. */
void
_rl_reset_completion_state ()
{
  rl_completion_found_quote = 0;
  rl_completion_quote_character = 0;
}

/* Set default values for readline word completion.  These are the variables
   that application completion functions can change or inspect. */
static void
set_completion_defaults (what_to_do)
     int what_to_do;
{
  /* Only the completion entry function can change these. */
  rl_filename_completion_desired = 0;
  rl_filename_quoting_desired = 1;
  rl_completion_type = what_to_do;
  rl_completion_suppress_append = rl_completion_suppress_quote = 0;
  rl_completion_append_character = ' ';

  /* The completion entry function may optionally change this. */
  rl_completion_mark_symlink_dirs = _rl_complete_mark_symlink_dirs;
}

/* The user must press "y" or "n". Non-zero return means "y" pressed. */
static int
get_y_or_n (for_pager)
     int for_pager;
{
  int c;

/* Disabled for GDB due to the gdb.base/readline-ask.exp regression.
   [patch] testsuite: Test readline-6.2 "ask" regression
   http://sourceware.org/ml/gdb-patches/2011-05/msg00002.html  */
#if 0
  /* For now, disable pager in callback mode, until we later convert to state
     driven functions.  Have to wait until next major version to add new
     state definition, since it will change value of RL_STATE_DONE. */
#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    return 1;
#endif
#endif

  for (;;)
    {
      RL_SETSTATE(RL_STATE_MOREINPUT);
      c = rl_read_key ();
      RL_UNSETSTATE(RL_STATE_MOREINPUT);

      if (c == 'y' || c == 'Y' || c == ' ')
	return (1);
      if (c == 'n' || c == 'N' || c == RUBOUT)
	return (0);
      if (c == ABORT_CHAR || c < 0)
	_rl_abort_internal ();
      if (for_pager && (c == NEWLINE || c == RETURN))
	return (2);
      if (for_pager && (c == 'q' || c == 'Q'))
	return (0);
      rl_ding ();
    }
}

static int
_rl_internal_pager (lines)
     int lines;
{
  int i;

  fprintf (rl_outstream, "--More--");
  fflush (rl_outstream);
  i = get_y_or_n (1);
  _rl_erase_entire_line ();
  if (i == 0)
    return -1;
  else if (i == 2)
    return (lines - 1);
  else
    return 0;
}

static int
path_isdir (filename)
     const char *filename;
{
  struct stat finfo;

  return (stat (filename, &finfo) == 0 && S_ISDIR (finfo.st_mode));
}

#if defined (VISIBLE_STATS)
/* Return the character which best describes FILENAME.
     `@@' for symbolic links
     `/' for directories
     `*' for executables
     `=' for sockets
     `|' for FIFOs
     `%' for character special devices
     `#' for block special devices */
static int
stat_char (filename)
     char *filename;
{
  struct stat finfo;
  int character, r;

  /* Short-circuit a //server on cygwin, since that will always behave as
     a directory. */
#if __CYGWIN__
  if (filename[0] == '/' && filename[1] == '/' && strchr (filename+2, '/') == 0)
    return '/';
#endif

#if defined (HAVE_LSTAT) && defined (S_ISLNK)
  r = lstat (filename, &finfo);
#else
  r = stat (filename, &finfo);
#endif

  if (r == -1)
    return (0);

  character = 0;
  if (S_ISDIR (finfo.st_mode))
    character = '/';
#if defined (S_ISCHR)
  else if (S_ISCHR (finfo.st_mode))
    character = '%';
#endif /* S_ISCHR */
#if defined (S_ISBLK)
  else if (S_ISBLK (finfo.st_mode))
    character = '#';
#endif /* S_ISBLK */
#if defined (S_ISLNK)
  else if (S_ISLNK (finfo.st_mode))
    character = '@@';
#endif /* S_ISLNK */
#if defined (S_ISSOCK)
  else if (S_ISSOCK (finfo.st_mode))
    character = '=';
#endif /* S_ISSOCK */
#if defined (S_ISFIFO)
  else if (S_ISFIFO (finfo.st_mode))
    character = '|';
#endif
  else if (S_ISREG (finfo.st_mode))
    {
      if (access (filename, X_OK) == 0)
	character = '*';
    }
  return (character);
}
#endif /* VISIBLE_STATS */

/* Return the portion of PATHNAME that should be output when listing
   possible completions.  If we are hacking filename completion, we
   are only interested in the basename, the portion following the
   final slash.  Otherwise, we return what we were passed.  Since
   printing empty strings is not very informative, if we're doing
   filename completion, and the basename is the empty string, we look
   for the previous slash and return the portion following that.  If
   there's no previous slash, we just return what we were passed. */
static char *
printable_part (pathname)
      char *pathname;
{
  char *temp, *x;

  if (rl_filename_completion_desired == 0)	/* don't need to do anything */
    return (pathname);

  temp = strrchr (pathname, '/');
#if defined (__MSDOS__)
  if (temp == 0 && ISALPHA ((unsigned char)pathname[0]) && pathname[1] == ':')
    temp = pathname + 1;
#endif

  if (temp == 0 || *temp == '\0')
    return (pathname);
  /* If the basename is NULL, we might have a pathname like '/usr/src/'.
     Look for a previous slash and, if one is found, return the portion
     following that slash.  If there's no previous slash, just return the
     pathname we were passed. */
  else if (temp[1] == '\0')
    {
      for (x = temp - 1; x > pathname; x--)
        if (*x == '/')
          break;
      return ((*x == '/') ? x + 1 : pathname);
    }
  else
    return ++temp;
}

/* Compute width of STRING when displayed on screen by print_filename */
static int
fnwidth (string)
     const char *string;
{
  int width, pos;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
  int left, w;
  size_t clen;
  wchar_t wc;

  left = strlen (string) + 1;
  memset (&ps, 0, sizeof (mbstate_t));
#endif

  width = pos = 0;
  while (string[pos])
    {
      if (CTRL_CHAR (string[pos]) || string[pos] == RUBOUT)
	{
	  width += 2;
	  pos++;
	}
      else
	{
#if defined (HANDLE_MULTIBYTE)
	  clen = mbrtowc (&wc, string + pos, left - pos, &ps);
	  if (MB_INVALIDCH (clen))
	    {
	      width++;
	      pos++;
	      memset (&ps, 0, sizeof (mbstate_t));
	    }
	  else if (MB_NULLWCH (clen))
	    break;
	  else
	    {
	      pos += clen;
	      w = wcwidth (wc);
	      width += (w >= 0) ? w : 1;
	    }
#else
	  width++;
	  pos++;
#endif
	}
    }

  return width;
}

#define ELLIPSIS_LEN	3

static int
fnprint (to_print, prefix_bytes)
     const char *to_print;
     int prefix_bytes;
{
  int printed_len, w;
  const char *s;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
  const char *end;
  size_t tlen;
  int width;
  wchar_t wc;

  end = to_print + strlen (to_print) + 1;
  memset (&ps, 0, sizeof (mbstate_t));
#endif

  printed_len = 0;

  /* Don't print only the ellipsis if the common prefix is one of the
     possible completions */
  if (to_print[prefix_bytes] == '\0')
    prefix_bytes = 0;

  if (prefix_bytes)
    {
      char ellipsis;

      ellipsis = (to_print[prefix_bytes] == '.') ? '_' : '.';
      for (w = 0; w < ELLIPSIS_LEN; w++)
	putc (ellipsis, rl_outstream);
      printed_len = ELLIPSIS_LEN;
    }

  s = to_print + prefix_bytes;
  while (*s)
    {
      if (CTRL_CHAR (*s))
        {
          putc ('^', rl_outstream);
          putc (UNCTRL (*s), rl_outstream);
          printed_len += 2;
          s++;
#if defined (HANDLE_MULTIBYTE)
	  memset (&ps, 0, sizeof (mbstate_t));
#endif
        }
      else if (*s == RUBOUT)
	{
	  putc ('^', rl_outstream);
	  putc ('?', rl_outstream);
	  printed_len += 2;
	  s++;
#if defined (HANDLE_MULTIBYTE)
	  memset (&ps, 0, sizeof (mbstate_t));
#endif
	}
      else
	{
#if defined (HANDLE_MULTIBYTE)
	  tlen = mbrtowc (&wc, s, end - s, &ps);
	  if (MB_INVALIDCH (tlen))
	    {
	      tlen = 1;
	      width = 1;
	      memset (&ps, 0, sizeof (mbstate_t));
	    }
	  else if (MB_NULLWCH (tlen))
	    break;
	  else
	    {
	      w = wcwidth (wc);
	      width = (w >= 0) ? w : 1;
	    }
	  fwrite (s, 1, tlen, rl_outstream);
	  s += tlen;
	  printed_len += width;
#else
	  putc (*s, rl_outstream);
	  s++;
	  printed_len++;
#endif
	}
    }

  return printed_len;
}

/* Output TO_PRINT to rl_outstream.  If VISIBLE_STATS is defined and we
   are using it, check for and output a single character for `special'
   filenames.  Return the number of characters we output. */

static int
print_filename (to_print, full_pathname, prefix_bytes)
     char *to_print, *full_pathname;
     int prefix_bytes;
{
  int printed_len, extension_char, slen, tlen;
  char *s, c, *new_full_pathname, *dn;

  extension_char = 0;
  printed_len = fnprint (to_print, prefix_bytes);

#if defined (VISIBLE_STATS)
 if (rl_filename_completion_desired && (rl_visible_stats || _rl_complete_mark_directories))
#else
 if (rl_filename_completion_desired && _rl_complete_mark_directories)
#endif
    {
      /* If to_print != full_pathname, to_print is the basename of the
	 path passed.  In this case, we try to expand the directory
	 name before checking for the stat character. */
      if (to_print != full_pathname)
	{
	  /* Terminate the directory name. */
	  c = to_print[-1];
	  to_print[-1] = '\0';

	  /* If setting the last slash in full_pathname to a NUL results in
	     full_pathname being the empty string, we are trying to complete
	     files in the root directory.  If we pass a null string to the
	     bash directory completion hook, for example, it will expand it
	     to the current directory.  We just want the `/'. */
	  if (full_pathname == 0 || *full_pathname == 0)
	    dn = "/";
	  else if (full_pathname[0] != '/')
	    dn = full_pathname;
	  else if (full_pathname[1] == 0)
	    dn = "//";		/* restore trailing slash to `//' */
	  else if (full_pathname[1] == '/' && full_pathname[2] == 0)
	    dn = "/";		/* don't turn /// into // */
	  else
	    dn = full_pathname;
	  s = tilde_expand (dn);
	  if (rl_directory_completion_hook)
	    (*rl_directory_completion_hook) (&s);

	  slen = strlen (s);
	  tlen = strlen (to_print);
	  new_full_pathname = (char *)xmalloc (slen + tlen + 2);
	  strcpy (new_full_pathname, s);
	  if (s[slen - 1] == '/')
	    slen--;
	  else
	    new_full_pathname[slen] = '/';
	  new_full_pathname[slen] = '/';
	  strcpy (new_full_pathname + slen + 1, to_print);

#if defined (VISIBLE_STATS)
	  if (rl_visible_stats)
	    extension_char = stat_char (new_full_pathname);
	  else
#endif
	  if (path_isdir (new_full_pathname))
	    extension_char = '/';

	  xfree (new_full_pathname);
	  to_print[-1] = c;
	}
      else
	{
	  s = tilde_expand (full_pathname);
#if defined (VISIBLE_STATS)
	  if (rl_visible_stats)
	    extension_char = stat_char (s);
	  else
#endif
	    if (path_isdir (s))
	      extension_char = '/';
	}

      xfree (s);
      if (extension_char)
	{
	  putc (extension_char, rl_outstream);
	  printed_len++;
	}
    }

  return printed_len;
}

static char *
rl_quote_filename (s, rtype, qcp)
     char *s;
     int rtype;
     char *qcp;
{
  char *r;

  r = (char *)xmalloc (strlen (s) + 2);
  *r = *rl_completer_quote_characters;
  strcpy (r + 1, s);
  if (qcp)
    *qcp = *rl_completer_quote_characters;
  return r;
}

/* Find the bounds of the current word for completion purposes, and leave
   rl_point set to the end of the word.  This function skips quoted
   substrings (characters between matched pairs of characters in
   rl_completer_quote_characters).  First we try to find an unclosed
   quoted substring on which to do matching.  If one is not found, we use
   the word break characters to find the boundaries of the current word.
   We call an application-specific function to decide whether or not a
   particular word break character is quoted; if that function returns a
   non-zero result, the character does not break a word.  This function
   returns the opening quote character if we found an unclosed quoted
   substring, '\0' otherwise.  FP, if non-null, is set to a value saying
   which (shell-like) quote characters we found (single quote, double
   quote, or backslash) anywhere in the string.  DP, if non-null, is set to
   the value of the delimiter character that caused a word break. */

char
_rl_find_completion_word (fp, dp)
     int *fp, *dp;
{
  int scan, end, found_quote, delimiter, pass_next, isbrk;
  char quote_char, *brkchars;

  end = rl_point;
  found_quote = delimiter = 0;
  quote_char = '\0';

  brkchars = 0;
  if (rl_completion_word_break_hook)
    brkchars = (*rl_completion_word_break_hook) ();
  if (brkchars == 0)
    brkchars = rl_completer_word_break_characters;

  if (rl_completer_quote_characters)
    {
      /* We have a list of characters which can be used in pairs to
	 quote substrings for the completer.  Try to find the start
	 of an unclosed quoted substring. */
      /* FOUND_QUOTE is set so we know what kind of quotes we found. */
      for (scan = pass_next = 0; scan < end; scan = MB_NEXTCHAR (rl_line_buffer, scan, 1, MB_FIND_ANY))
	{
	  if (pass_next)
	    {
	      pass_next = 0;
	      continue;
	    }

	  /* Shell-like semantics for single quotes -- don't allow backslash
	     to quote anything in single quotes, especially not the closing
	     quote.  If you don't like this, take out the check on the value
	     of quote_char. */
	  if (quote_char != '\'' && rl_line_buffer[scan] == '\\')
	    {
	      pass_next = 1;
	      found_quote |= RL_QF_BACKSLASH;
	      continue;
	    }

	  if (quote_char != '\0')
	    {
	      /* Ignore everything until the matching close quote char. */
	      if (rl_line_buffer[scan] == quote_char)
		{
		  /* Found matching close.  Abandon this substring. */
		  quote_char = '\0';
		  rl_point = end;
		}
	    }
	  else if (strchr (rl_completer_quote_characters, rl_line_buffer[scan]))
	    {
	      /* Found start of a quoted substring. */
	      quote_char = rl_line_buffer[scan];
	      rl_point = scan + 1;
	      /* Shell-like quoting conventions. */
	      if (quote_char == '\'')
		found_quote |= RL_QF_SINGLE_QUOTE;
	      else if (quote_char == '"')
		found_quote |= RL_QF_DOUBLE_QUOTE;
	      else
		found_quote |= RL_QF_OTHER_QUOTE;      
	    }
	}
    }

  if (rl_point == end && quote_char == '\0')
    {
      /* We didn't find an unclosed quoted substring upon which to do
         completion, so use the word break characters to find the
         substring on which to complete. */
      while (rl_point = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_ANY))
	{
	  scan = rl_line_buffer[rl_point];

	  if (strchr (brkchars, scan) == 0)
	    continue;

	  /* Call the application-specific function to tell us whether
	     this word break character is quoted and should be skipped. */
	  if (rl_char_is_quoted_p && found_quote &&
	      (*rl_char_is_quoted_p) (rl_line_buffer, rl_point))
	    continue;

	  /* Convoluted code, but it avoids an n^2 algorithm with calls
	     to char_is_quoted. */
	  break;
	}
    }

  /* If we are at an unquoted word break, then advance past it. */
  scan = rl_line_buffer[rl_point];

  /* If there is an application-specific function to say whether or not
     a character is quoted and we found a quote character, let that
     function decide whether or not a character is a word break, even
     if it is found in rl_completer_word_break_characters.  Don't bother
     if we're at the end of the line, though. */
  if (scan)
    {
      if (rl_char_is_quoted_p)
	isbrk = (found_quote == 0 ||
		(*rl_char_is_quoted_p) (rl_line_buffer, rl_point) == 0) &&
		strchr (brkchars, scan) != 0;
      else
	isbrk = strchr (brkchars, scan) != 0;

      if (isbrk)
	{
	  /* If the character that caused the word break was a quoting
	     character, then remember it as the delimiter. */
	  if (rl_basic_quote_characters &&
	      strchr (rl_basic_quote_characters, scan) &&
	      (end - rl_point) > 1)
	    delimiter = scan;

	  /* If the character isn't needed to determine something special
	     about what kind of completion to perform, then advance past it. */
	  if (rl_special_prefixes == 0 || strchr (rl_special_prefixes, scan) == 0)
	    rl_point++;
	}
    }

  if (fp)
    *fp = found_quote;
  if (dp)
    *dp = delimiter;

  return (quote_char);
}

static char **
gen_completion_matches (text, start, end, our_func, found_quote, quote_char)
     char *text;
     int start, end;
     rl_compentry_func_t *our_func;
     int found_quote, quote_char;
{
  char **matches;

  rl_completion_found_quote = found_quote;
  rl_completion_quote_character = quote_char;

  /* If the user wants to TRY to complete, but then wants to give
     up and use the default completion function, they set the
     variable rl_attempted_completion_function. */
  if (rl_attempted_completion_function)
    {
      _rl_interrupt_immediately++;
      matches = (*rl_attempted_completion_function) (text, start, end);
      if (_rl_interrupt_immediately > 0)
	_rl_interrupt_immediately--;

      if (matches || rl_attempted_completion_over)
	{
	  rl_attempted_completion_over = 0;
	  return (matches);
	}
    }

  /* XXX -- filename dequoting moved into rl_filename_completion_function */

  matches = rl_completion_matches (text, our_func);
  return matches;  
}

/* Filter out duplicates in MATCHES.  This frees up the strings in
   MATCHES. */
static char **
remove_duplicate_matches (matches)
     char **matches;
{
  char *lowest_common;
  int i, j, newlen;
  char dead_slot;
  char **temp_array;

  /* Sort the items. */
  for (i = 0; matches[i]; i++)
    ;

  /* Sort the array without matches[0], since we need it to
     stay in place no matter what. */
  if (i && rl_sort_completion_matches)
    qsort (matches+1, i-1, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);

  /* Remember the lowest common denominator for it may be unique. */
  lowest_common = savestring (matches[0]);

  for (i = newlen = 0; matches[i + 1]; i++)
    {
      if (strcmp (matches[i], matches[i + 1]) == 0)
	{
	  xfree (matches[i]);
	  matches[i] = (char *)&dead_slot;
	}
      else
	newlen++;
    }

  /* We have marked all the dead slots with (char *)&dead_slot.
     Copy all the non-dead entries into a new array. */
  temp_array = (char **)xmalloc ((3 + newlen) * sizeof (char *));
  for (i = j = 1; matches[i]; i++)
    {
      if (matches[i] != (char *)&dead_slot)
	temp_array[j++] = matches[i];
    }
  temp_array[j] = (char *)NULL;

  if (matches[0] != (char *)&dead_slot)
    xfree (matches[0]);

  /* Place the lowest common denominator back in [0]. */
  temp_array[0] = lowest_common;

  /* If there is one string left, and it is identical to the
     lowest common denominator, then the LCD is the string to
     insert. */
  if (j == 2 && strcmp (temp_array[0], temp_array[1]) == 0)
    {
      xfree (temp_array[1]);
      temp_array[1] = (char *)NULL;
    }
  return (temp_array);
}

/* Find the common prefix of the list of matches, and put it into
   matches[0]. */
static int
compute_lcd_of_matches (match_list, matches, text)
     char **match_list;
     int matches;
     const char *text;
{
  register int i, c1, c2, si;
  int low;		/* Count of max-matched characters. */
  char *dtext;		/* dequoted TEXT, if needed */
#if defined (HANDLE_MULTIBYTE)
  int v;
  mbstate_t ps1, ps2;
  wchar_t wc1, wc2;
#endif

  /* If only one match, just use that.  Otherwise, compare each
     member of the list with the next, finding out where they
     stop matching. */
  if (matches == 1)
    {
      match_list[0] = match_list[1];
      match_list[1] = (char *)NULL;
      return 1;
    }

  for (i = 1, low = 100000; i < matches; i++)
    {
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  memset (&ps1, 0, sizeof (mbstate_t));
	  memset (&ps2, 0, sizeof (mbstate_t));
	}
#endif
      if (_rl_completion_case_fold)
	{
	  for (si = 0;
	       (c1 = _rl_to_lower(match_list[i][si])) &&
	       (c2 = _rl_to_lower(match_list[i + 1][si]));
	       si++)
#if defined (HANDLE_MULTIBYTE)
	    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	      {
		v = mbrtowc (&wc1, match_list[i]+si, strlen (match_list[i]+si), &ps1);
		mbrtowc (&wc2, match_list[i+1]+si, strlen (match_list[i+1]+si), &ps2);
		wc1 = towlower (wc1);
		wc2 = towlower (wc2);
		if (wc1 != wc2)
		  break;
		else if (v > 1)
		  si += v - 1;
	      }
	    else
#endif
	    if (c1 != c2)
	      break;
	}
      else
	{
	  for (si = 0;
	       (c1 = match_list[i][si]) &&
	       (c2 = match_list[i + 1][si]);
	       si++)
#if defined (HANDLE_MULTIBYTE)
	    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	      {
		mbstate_t ps_back;
		ps_back = ps1;
		if (!_rl_compare_chars (match_list[i], si, &ps1, match_list[i+1], si, &ps2))
		  break;
		else if ((v = _rl_get_char_len (&match_list[i][si], &ps_back)) > 1)
		  si += v - 1;
	      }
	    else
#endif
	    if (c1 != c2)
	      break;
	}

      if (low > si)
	low = si;
    }

  /* If there were multiple matches, but none matched up to even the
     first character, and the user typed something, use that as the
     value of matches[0]. */
  if (low == 0 && text && *text)
    {
      match_list[0] = (char *)xmalloc (strlen (text) + 1);
      strcpy (match_list[0], text);
    }
  else
    {
      match_list[0] = (char *)xmalloc (low + 1);

      /* XXX - this might need changes in the presence of multibyte chars */

      /* If we are ignoring case, try to preserve the case of the string
	 the user typed in the face of multiple matches differing in case. */
      if (_rl_completion_case_fold)
	{
	  /* We're making an assumption here:
		IF we're completing filenames AND
		   the application has defined a filename dequoting function AND
		   we found a quote character AND
		   the application has requested filename quoting
		THEN
		   we assume that TEXT was dequoted before checking against
		   the file system and needs to be dequoted here before we
		   check against the list of matches
		FI */
	  dtext = (char *)NULL;
	  if (rl_filename_completion_desired &&
	      rl_filename_dequoting_function &&
	      rl_completion_found_quote &&
	      rl_filename_quoting_desired)
	    {
	      dtext = (*rl_filename_dequoting_function) ((char *)text, rl_completion_quote_character);
	      text = dtext;
	    }

	  /* sort the list to get consistent answers. */
	  qsort (match_list+1, matches, sizeof(char *), (QSFUNC *)_rl_qsort_string_compare);

	  si = strlen (text);
	  if (si <= low)
	    {
	      for (i = 1; i <= matches; i++)
		if (strncmp (match_list[i], text, si) == 0)
		  {
		    strncpy (match_list[0], match_list[i], low);
		    break;
		  }
	      /* no casematch, use first entry */
	      if (i > matches)
		strncpy (match_list[0], match_list[1], low);
	    }
	  else
	    /* otherwise, just use the text the user typed. */
	    strncpy (match_list[0], text, low);

	  FREE (dtext);
	}
      else
        strncpy (match_list[0], match_list[1], low);

      match_list[0][low] = '\0';
    }

  return matches;
}

static int
postprocess_matches (matchesp, matching_filenames)
     char ***matchesp;
     int matching_filenames;
{
  char *t, **matches, **temp_matches;
  int nmatch, i;

  matches = *matchesp;

  if (matches == 0)
    return 0;

  /* It seems to me that in all the cases we handle we would like
     to ignore duplicate possiblilities.  Scan for the text to
     insert being identical to the other completions. */
  if (rl_ignore_completion_duplicates)
    {
      temp_matches = remove_duplicate_matches (matches);
      xfree (matches);
      matches = temp_matches;
    }

  /* If we are matching filenames, then here is our chance to
     do clever processing by re-examining the list.  Call the
     ignore function with the array as a parameter.  It can
     munge the array, deleting matches as it desires. */
  if (rl_ignore_some_completions_function && matching_filenames)
    {
      for (nmatch = 1; matches[nmatch]; nmatch++)
	;
      (void)(*rl_ignore_some_completions_function) (matches);
      if (matches == 0 || matches[0] == 0)
	{
	  FREE (matches);
	  *matchesp = (char **)0;
	  return 0;
        }
      else
	{
	  /* If we removed some matches, recompute the common prefix. */
	  for (i = 1; matches[i]; i++)
	    ;
	  if (i > 1 && i < nmatch)
	    {
	      t = matches[0];
	      compute_lcd_of_matches (matches, i - 1, t);
	      FREE (t);
	    }
	}
    }

  *matchesp = matches;
  return (1);
}

static int
complete_get_screenwidth ()
{
  int cols;
  char *envcols;

  cols = _rl_completion_columns;
  if (cols >= 0 && cols <= _rl_screenwidth)
    return cols;
  envcols = getenv ("COLUMNS");
  if (envcols && *envcols)
    cols = atoi (envcols);
  if (cols >= 0 && cols <= _rl_screenwidth)
    return cols;
  return _rl_screenwidth;
}

/* A convenience function for displaying a list of strings in
   columnar format on readline's output stream.  MATCHES is the list
   of strings, in argv format, LEN is the number of strings in MATCHES,
   and MAX is the length of the longest string in MATCHES. */
void
rl_display_match_list (matches, len, max)
     char **matches;
     int len, max;
{
  int count, limit, printed_len, lines, cols;
  int i, j, k, l, common_length, sind;
  char *temp, *t;

  /* Find the length of the prefix common to all items: length as displayed
     characters (common_length) and as a byte index into the matches (sind) */
  common_length = sind = 0;
  if (_rl_completion_prefix_display_length > 0)
    {
      t = printable_part (matches[0]);
      temp = strrchr (t, '/');
      common_length = temp ? fnwidth (temp) : fnwidth (t);
      sind = temp ? strlen (temp) : strlen (t);

      if (common_length > _rl_completion_prefix_display_length && common_length > ELLIPSIS_LEN)
	max -= common_length - ELLIPSIS_LEN;
      else
	common_length = sind = 0;
    }

  /* How many items of MAX length can we fit in the screen window? */
  cols = complete_get_screenwidth ();
  max += 2;
  limit = cols / max;
  if (limit != 1 && (limit * max == cols))
    limit--;

  /* If cols == 0, limit will end up -1 */
  if (cols < _rl_screenwidth && limit < 0)
    limit = 1;

  /* Avoid a possible floating exception.  If max > cols,
     limit will be 0 and a divide-by-zero fault will result. */
  if (limit == 0)
    limit = 1;

  /* How many iterations of the printing loop? */
  count = (len + (limit - 1)) / limit;

  /* Watch out for special case.  If LEN is less than LIMIT, then
     just do the inner printing loop.
	   0 < len <= limit  implies  count = 1. */

  /* Sort the items if they are not already sorted. */
  if (rl_ignore_completion_duplicates == 0 && rl_sort_completion_matches)
    qsort (matches + 1, len, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);

  rl_crlf ();

  lines = 0;
  if (_rl_print_completions_horizontally == 0)
    {
      /* Print the sorted items, up-and-down alphabetically, like ls. */
      for (i = 1; i <= count; i++)
	{
	  for (j = 0, l = i; j < limit; j++)
	    {
	      if (l > len || matches[l] == 0)
		break;
	      else
		{
		  temp = printable_part (matches[l]);
		  printed_len = print_filename (temp, matches[l], sind);

		  if (j + 1 < limit)
		    for (k = 0; k < max - printed_len; k++)
		      putc (' ', rl_outstream);
		}
	      l += count;
	    }
	  rl_crlf ();
	  lines++;
	  if (_rl_page_completions && lines >= (_rl_screenheight - 1) && i < count)
	    {
	      lines = _rl_internal_pager (lines);
	      if (lines < 0)
		return;
	    }
	}
    }
  else
    {
      /* Print the sorted items, across alphabetically, like ls -x. */
      for (i = 1; matches[i]; i++)
	{
	  temp = printable_part (matches[i]);
	  printed_len = print_filename (temp, matches[i], sind);
	  /* Have we reached the end of this line? */
	  if (matches[i+1])
	    {
	      if (i && (limit > 1) && (i % limit) == 0)
		{
		  rl_crlf ();
		  lines++;
		  if (_rl_page_completions && lines >= _rl_screenheight - 1)
		    {
		      lines = _rl_internal_pager (lines);
		      if (lines < 0)
			return;
		    }
		}
	      else
		for (k = 0; k < max - printed_len; k++)
		  putc (' ', rl_outstream);
	    }
	}
      rl_crlf ();
    }
}

/* Display MATCHES, a list of matching filenames in argv format.  This
   handles the simple case -- a single match -- first.  If there is more
   than one match, we compute the number of strings in the list and the
   length of the longest string, which will be needed by the display
   function.  If the application wants to handle displaying the list of
   matches itself, it sets RL_COMPLETION_DISPLAY_MATCHES_HOOK to the
   address of a function, and we just call it.  If we're handling the
   display ourselves, we just call rl_display_match_list.  We also check
   that the list of matches doesn't exceed the user-settable threshold,
   and ask the user if he wants to see the list if there are more matches
   than RL_COMPLETION_QUERY_ITEMS. */
static void
display_matches (matches)
     char **matches;
{
  int len, max, i;
  char *temp;

  /* Move to the last visible line of a possibly-multiple-line command. */
  _rl_move_vert (_rl_vis_botlin);

  /* Handle simple case first.  What if there is only one answer? */
  if (matches[1] == 0)
    {
      temp = printable_part (matches[0]);
      rl_crlf ();
      print_filename (temp, matches[0], 0);
      rl_crlf ();

      rl_forced_update_display ();
      rl_display_fixed = 1;

      return;
    }

  /* There is more than one answer.  Find out how many there are,
     and find the maximum printed length of a single entry. */
  for (max = 0, i = 1; matches[i]; i++)
    {
      temp = printable_part (matches[i]);
      len = fnwidth (temp);

      if (len > max)
	max = len;
    }

  len = i - 1;

  /* If the caller has defined a display hook, then call that now. */
  if (rl_completion_display_matches_hook)
    {
      (*rl_completion_display_matches_hook) (matches, len, max);
      return;
    }
	
  /* If there are many items, then ask the user if she really wants to
     see them all. */
  if (rl_completion_query_items > 0 && len >= rl_completion_query_items)
    {
      rl_crlf ();
      fprintf (rl_outstream, "Display all %d possibilities? (y or n)", len);
      fflush (rl_outstream);
      if ((completion_y_or_n = get_y_or_n (0)) == 0)
	{
	  rl_crlf ();

	  rl_forced_update_display ();
	  rl_display_fixed = 1;

	  return;
	}
    }

  rl_display_match_list (matches, len, max);

  rl_forced_update_display ();
  rl_display_fixed = 1;
}

static char *
make_quoted_replacement (match, mtype, qc)
     char *match;
     int mtype;
     char *qc;	/* Pointer to quoting character, if any */
{
  int should_quote, do_replace;
  char *replacement;

  /* If we are doing completion on quoted substrings, and any matches
     contain any of the completer_word_break_characters, then auto-
     matically prepend the substring with a quote character (just pick
     the first one from the list of such) if it does not already begin
     with a quote string.  FIXME: Need to remove any such automatically
     inserted quote character when it no longer is necessary, such as
     if we change the string we are completing on and the new set of
     matches don't require a quoted substring. */
  replacement = match;

  should_quote = match && rl_completer_quote_characters &&
			rl_filename_completion_desired &&
			rl_filename_quoting_desired;

  if (should_quote)
    should_quote = should_quote && (!qc || !*qc ||
		     (rl_completer_quote_characters && strchr (rl_completer_quote_characters, *qc)));

  if (should_quote)
    {
      /* If there is a single match, see if we need to quote it.
         This also checks whether the common prefix of several
	 matches needs to be quoted. */
      should_quote = rl_filename_quote_characters
			? (_rl_strpbrk (match, rl_filename_quote_characters) != 0)
			: 0;

      do_replace = should_quote ? mtype : NO_MATCH;
      /* Quote the replacement, since we found an embedded
	 word break character in a potential match. */
      if (do_replace != NO_MATCH && rl_filename_quoting_function)
	replacement = (*rl_filename_quoting_function) (match, do_replace, qc);
    }
  return (replacement);
}

static void
insert_match (match, start, mtype, qc)
     char *match;
     int start, mtype;
     char *qc;
{
  char *replacement, *r;
  char oqc;
  int end, rlen;

  oqc = qc ? *qc : '\0';
  replacement = make_quoted_replacement (match, mtype, qc);

  /* Now insert the match. */
  if (replacement)
    {
      rlen = strlen (replacement);
      /* Don't double an opening quote character. */
      if (qc && *qc && start && rl_line_buffer[start - 1] == *qc &&
	    replacement[0] == *qc)
	start--;
      /* If make_quoted_replacement changed the quoting character, remove
	 the opening quote and insert the (fully-quoted) replacement. */
      else if (qc && (*qc != oqc) && start && rl_line_buffer[start - 1] == oqc &&
	    replacement[0] != oqc)
	start--;
      end = rl_point - 1;
      /* Don't double a closing quote character */
      if (qc && *qc && end && rl_line_buffer[rl_point] == *qc && replacement[rlen - 1] == *qc)
        end++;
      if (_rl_skip_completed_text)
	{
	  r = replacement;
	  while (start < rl_end && *r && rl_line_buffer[start] == *r)
	    {
	      start++;
	      r++;
	    }
	  if (start <= end || *r)
	    _rl_replace_text (r, start, end);
	  rl_point = start + strlen (r);
	}
      else
	_rl_replace_text (replacement, start, end);
      if (replacement != match)
        xfree (replacement);
    }
}

/* Append any necessary closing quote and a separator character to the
   just-inserted match.  If the user has specified that directories
   should be marked by a trailing `/', append one of those instead.  The
   default trailing character is a space.  Returns the number of characters
   appended.  If NONTRIVIAL_MATCH is set, we test for a symlink (if the OS
   has them) and don't add a suffix for a symlink to a directory.  A
   nontrivial match is one that actually adds to the word being completed.
   The variable rl_completion_mark_symlink_dirs controls this behavior
   (it's initially set to the what the user has chosen, indicated by the
   value of _rl_complete_mark_symlink_dirs, but may be modified by an
   application's completion function). */
static int
append_to_match (text, delimiter, quote_char, nontrivial_match)
     char *text;
     int delimiter, quote_char, nontrivial_match;
{
  char temp_string[4], *filename;
  int temp_string_index, s;
  struct stat finfo;

  temp_string_index = 0;
  if (quote_char && rl_point && rl_completion_suppress_quote == 0 &&
      rl_line_buffer[rl_point - 1] != quote_char)
    temp_string[temp_string_index++] = quote_char;

  if (delimiter)
    temp_string[temp_string_index++] = delimiter;
  else if (rl_completion_suppress_append == 0 && rl_completion_append_character)
    temp_string[temp_string_index++] = rl_completion_append_character;

  temp_string[temp_string_index++] = '\0';

  if (rl_filename_completion_desired)
    {
      filename = tilde_expand (text);
      s = (nontrivial_match && rl_completion_mark_symlink_dirs == 0)
		? LSTAT (filename, &finfo)
		: stat (filename, &finfo);
      if (s == 0 && S_ISDIR (finfo.st_mode))
	{
	  if (_rl_complete_mark_directories /* && rl_completion_suppress_append == 0 */)
	    {
	      /* This is clumsy.  Avoid putting in a double slash if point
		 is at the end of the line and the previous character is a
		 slash. */
	      if (rl_point && rl_line_buffer[rl_point] == '\0' && rl_line_buffer[rl_point - 1] == '/')
		;
	      else if (rl_line_buffer[rl_point] != '/')
		rl_insert_text ("/");
	    }
	}
#ifdef S_ISLNK
      /* Don't add anything if the filename is a symlink and resolves to a
	 directory. */
      else if (s == 0 && S_ISLNK (finfo.st_mode) &&
	       stat (filename, &finfo) == 0 && S_ISDIR (finfo.st_mode))
	;
#endif
      else
	{
	  if (rl_point == rl_end && temp_string_index)
	    rl_insert_text (temp_string);
	}
      xfree (filename);
    }
  else
    {
      if (rl_point == rl_end && temp_string_index)
	rl_insert_text (temp_string);
    }

  return (temp_string_index);
}

static void
insert_all_matches (matches, point, qc)
     char **matches;
     int point;
     char *qc;
{
  int i;
  char *rp;

  rl_begin_undo_group ();
  /* remove any opening quote character; make_quoted_replacement will add
     it back. */
  if (qc && *qc && point && rl_line_buffer[point - 1] == *qc)
    point--;
  rl_delete_text (point, rl_point);
  rl_point = point;

  if (matches[1])
    {
      for (i = 1; matches[i]; i++)
	{
	  rp = make_quoted_replacement (matches[i], SINGLE_MATCH, qc);
	  rl_insert_text (rp);
	  rl_insert_text (" ");
	  if (rp != matches[i])
	    xfree (rp);
	}
    }
  else
    {
      rp = make_quoted_replacement (matches[0], SINGLE_MATCH, qc);
      rl_insert_text (rp);
      rl_insert_text (" ");
      if (rp != matches[0])
	xfree (rp);
    }
  rl_end_undo_group ();
}

void
_rl_free_match_list (matches)
     char **matches;
{
  register int i;

  if (matches == 0)
    return;

  for (i = 0; matches[i]; i++)
    xfree (matches[i]);
  xfree (matches);
}

/* Complete the word at or before point.
   WHAT_TO_DO says what to do with the completion.
   `?' means list the possible completions.
   TAB means do standard completion.
   `*' means insert all of the possible completions.
   `!' means to do standard completion, and list all possible completions if
   there is more than one.
   `@@' means to do standard completion, and list all possible completions if
   there is more than one and partial completion is not possible. */
int
rl_complete_internal (what_to_do)
     int what_to_do;
{
  char **matches;
  rl_compentry_func_t *our_func;
  int start, end, delimiter, found_quote, i, nontrivial_lcd;
  char *text, *saved_line_buffer;
  char quote_char;
#if 1
  int tlen, mlen;
#endif

  RL_SETSTATE(RL_STATE_COMPLETING);

  set_completion_defaults (what_to_do);

  saved_line_buffer = rl_line_buffer ? savestring (rl_line_buffer) : (char *)NULL;
  our_func = rl_completion_entry_function
		? rl_completion_entry_function
		: rl_filename_completion_function;
  /* We now look backwards for the start of a filename/variable word. */
  end = rl_point;
  found_quote = delimiter = 0;
  quote_char = '\0';

  if (rl_point)
    /* This (possibly) changes rl_point.  If it returns a non-zero char,
       we know we have an open quote. */
    quote_char = _rl_find_completion_word (&found_quote, &delimiter);

  start = rl_point;
  rl_point = end;

  text = rl_copy_text (start, end);
  matches = gen_completion_matches (text, start, end, our_func, found_quote, quote_char);
  /* nontrivial_lcd is set if the common prefix adds something to the word
     being completed. */
  nontrivial_lcd = matches && strcmp (text, matches[0]) != 0;
#if 1
  if (what_to_do == '!' || what_to_do == '@@')
    tlen = strlen (text);
#endif
  xfree (text);

  if (matches == 0)
    {
      rl_ding ();
      FREE (saved_line_buffer);
      completion_changed_buffer = 0;
      RL_UNSETSTATE(RL_STATE_COMPLETING);
      _rl_reset_completion_state ();
      return (0);
    }

  /* If we are matching filenames, the attempted completion function will
     have set rl_filename_completion_desired to a non-zero value.  The basic
     rl_filename_completion_function does this. */
  i = rl_filename_completion_desired;

  if (postprocess_matches (&matches, i) == 0)
    {
      rl_ding ();
      FREE (saved_line_buffer);
      completion_changed_buffer = 0;
      RL_UNSETSTATE(RL_STATE_COMPLETING);
      _rl_reset_completion_state ();
      return (0);
    }

  switch (what_to_do)
    {
    case TAB:
    case '!':
    case '@@':
      /* Insert the first match with proper quoting. */
#if 0
      if (*matches[0])
	insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);
#else
      if (what_to_do == TAB)
        {
          if (*matches[0])
	    insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);
        }
      else if (*matches[0] && matches[1] == 0)
	/* should we perform the check only if there are multiple matches? */
	insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);
      else if (*matches[0])	/* what_to_do != TAB && multiple matches */
	{
	  mlen = *matches[0] ? strlen (matches[0]) : 0;
	  if (mlen >= tlen)
	    insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);
	}
#endif

      /* If there are more matches, ring the bell to indicate.
	 If we are in vi mode, Posix.2 says to not ring the bell.
	 If the `show-all-if-ambiguous' variable is set, display
	 all the matches immediately.  Otherwise, if this was the
	 only match, and we are hacking files, check the file to
	 see if it was a directory.  If so, and the `mark-directories'
	 variable is set, add a '/' to the name.  If not, and we
	 are at the end of the line, then add a space.  */
      if (matches[1])
	{
	  if (what_to_do == '!')
	    {
	      display_matches (matches);
	      break;
	    }
	  else if (what_to_do == '@@')
	    {
	      if (nontrivial_lcd == 0)
		display_matches (matches);
	      break;
	    }
	  else if (rl_editing_mode != vi_mode)
	    rl_ding ();	/* There are other matches remaining. */
	}
      else
	append_to_match (matches[0], delimiter, quote_char, nontrivial_lcd);

      break;

    case '*':
      insert_all_matches (matches, start, &quote_char);
      break;

    case '?':
      display_matches (matches);
      break;

    default:
      _rl_ttymsg ("bad value %d for what_to_do in rl_complete", what_to_do);
      rl_ding ();
      FREE (saved_line_buffer);
      RL_UNSETSTATE(RL_STATE_COMPLETING);
      _rl_reset_completion_state ();
      return 1;
    }

  _rl_free_match_list (matches);

  /* Check to see if the line has changed through all of this manipulation. */
  if (saved_line_buffer)
    {
      completion_changed_buffer = strcmp (rl_line_buffer, saved_line_buffer) != 0;
      xfree (saved_line_buffer);
    }

  RL_UNSETSTATE(RL_STATE_COMPLETING);
  _rl_reset_completion_state ();
  return 0;
}

/***************************************************************/
/*							       */
/*  Application-callable completion match generator functions  */
/*							       */
/***************************************************************/

/* Return an array of (char *) which is a list of completions for TEXT.
   If there are no completions, return a NULL pointer.
   The first entry in the returned array is the substitution for TEXT.
   The remaining entries are the possible completions.
   The array is terminated with a NULL pointer.

   ENTRY_FUNCTION is a function of two args, and returns a (char *).
     The first argument is TEXT.
     The second is a state argument; it should be zero on the first call, and
     non-zero on subsequent calls.  It returns a NULL pointer to the caller
     when there are no more matches.
 */
char **
rl_completion_matches (text, entry_function)
     const char *text;
     rl_compentry_func_t *entry_function;
{
  /* Number of slots in match_list. */
  int match_list_size;

  /* The list of matches. */
  char **match_list;

  /* Number of matches actually found. */
  int matches;

  /* Temporary string binder. */
  char *string;

  matches = 0;
  match_list_size = 10;
  match_list = (char **)xmalloc ((match_list_size + 1) * sizeof (char *));
  match_list[1] = (char *)NULL;

  _rl_interrupt_immediately++;
  while (string = (*entry_function) (text, matches))
    {
      if (matches + 1 == match_list_size)
	match_list = (char **)xrealloc
	  (match_list, ((match_list_size += 10) + 1) * sizeof (char *));

      match_list[++matches] = string;
      match_list[matches + 1] = (char *)NULL;
    }
  if (_rl_interrupt_immediately > 0)
    _rl_interrupt_immediately--;

  /* If there were any matches, then look through them finding out the
     lowest common denominator.  That then becomes match_list[0]. */
  if (matches)
    compute_lcd_of_matches (match_list, matches, text);
  else				/* There were no matches. */
    {
      xfree (match_list);
      match_list = (char **)NULL;
    }
  return (match_list);
}

/* A completion function for usernames.
   TEXT contains a partial username preceded by a random
   character (usually `~').  */
char *
rl_username_completion_function (text, state)
     const char *text;
     int state;
{
#if defined (__WIN32__) || defined (__OPENNT)
  return (char *)NULL;
#else /* !__WIN32__ && !__OPENNT) */
  static char *username = (char *)NULL;
  static struct passwd *entry;
  static int namelen, first_char, first_char_loc;
  char *value;

  if (state == 0)
    {
      FREE (username);

      first_char = *text;
      first_char_loc = first_char == '~';

      username = savestring (&text[first_char_loc]);
      namelen = strlen (username);
      setpwent ();
    }

#if defined (HAVE_GETPWENT)
  while (entry = getpwent ())
    {
      /* Null usernames should result in all users as possible completions. */
      if (namelen == 0 || (STREQN (username, entry->pw_name, namelen)))
	break;
    }
#endif

  if (entry == 0)
    {
#if defined (HAVE_GETPWENT)
      endpwent ();
#endif
      return ((char *)NULL);
    }
  else
    {
      value = (char *)xmalloc (2 + strlen (entry->pw_name));

      *value = *text;

      strcpy (value + first_char_loc, entry->pw_name);

      if (first_char == '~')
	rl_filename_completion_desired = 1;

      return (value);
    }
#endif /* !__WIN32__ && !__OPENNT */
}

/* Return non-zero if CONVFN matches FILENAME up to the length of FILENAME
   (FILENAME_LEN).  If _rl_completion_case_fold is set, compare without
   regard to the alphabetic case of characters.  CONVFN is the possibly-
   converted directory entry; FILENAME is what the user typed. */
static int
complete_fncmp (convfn, convlen, filename, filename_len)
     const char *convfn;
     int convlen;
     const char *filename;
     int filename_len;
{
  register char *s1, *s2;
  int d, len;

  /* Otherwise, if these match up to the length of filename, then
     it is a match. */
  if (_rl_completion_case_fold && _rl_completion_case_map)
    {
      /* Case-insensitive comparison treating _ and - as equivalent */
      if (filename_len == 0)
	return 1;
      if (convlen < filename_len)
	return 0;
      s1 = (char *)convfn;
      s2 = (char *)filename;
      len = filename_len;
      do
	{
	  d = _rl_to_lower (*s1) - _rl_to_lower (*s2);
	  /* *s1 == [-_] && *s2 == [-_] */
	  if ((*s1 == '-' || *s1 == '_') && (*s2 == '-' || *s2 == '_'))
	    d = 0;
	  if (d != 0)
	    return 0;
	  s1++; s2++;	/* already checked convlen >= filename_len */
	}
      while (--len != 0);
      return 1;
    }
  else if (_rl_completion_case_fold)
    {
      if ((_rl_to_lower (convfn[0]) == _rl_to_lower (filename[0])) &&
	  (convlen >= filename_len) &&
	  (_rl_strnicmp (filename, convfn, filename_len) == 0))
	return 1;
    }
  else
    {
      if ((convfn[0] == filename[0]) &&
	  (convlen >= filename_len) &&
	  (strncmp (filename, convfn, filename_len) == 0))
	return 1;
    }
  return 0;
}

/* Okay, now we write the entry_function for filename completion.  In the
   general case.  Note that completion in the shell is a little different
   because of all the pathnames that must be followed when looking up the
   completion for a command. */
char *
rl_filename_completion_function (text, state)
     const char *text;
     int state;
{
  static DIR *directory = (DIR *)NULL;
  static char *filename = (char *)NULL;
  static char *dirname = (char *)NULL;
  static char *users_dirname = (char *)NULL;
  static int filename_len;
  char *temp, *dentry, *convfn;
  int dirlen, dentlen, convlen;
  struct dirent *entry;

  /* If we don't have any state, then do some initialization. */
  if (state == 0)
    {
      /* If we were interrupted before closing the directory or reading
	 all of its contents, close it. */
      if (directory)
	{
	  closedir (directory);
	  directory = (DIR *)NULL;
	}
      FREE (dirname);
      FREE (filename);
      FREE (users_dirname);

      filename = savestring (text);
      if (*text == 0)
	text = ".";
      dirname = savestring (text);

      temp = strrchr (dirname, '/');

#if defined (__MSDOS__)
      /* special hack for //X/... */
      if (dirname[0] == '/' && dirname[1] == '/' && ISALPHA ((unsigned char)dirname[2]) && dirname[3] == '/')
        temp = strrchr (dirname + 3, '/');
#endif

      if (temp)
	{
	  strcpy (filename, ++temp);
	  *temp = '\0';
	}
#if defined (__MSDOS__)
      /* searches from current directory on the drive */
      else if (ISALPHA ((unsigned char)dirname[0]) && dirname[1] == ':')
        {
          strcpy (filename, dirname + 2);
          dirname[2] = '\0';
        }
#endif
      else
	{
	  dirname[0] = '.';
	  dirname[1] = '\0';
	}

      /* We aren't done yet.  We also support the "~user" syntax. */

      /* Save the version of the directory that the user typed, dequoting
	 it if necessary. */
      if (rl_completion_found_quote && rl_filename_dequoting_function)
	users_dirname = (*rl_filename_dequoting_function) (dirname, rl_completion_quote_character);
      else
	users_dirname = savestring (dirname);

      if (*dirname == '~')
	{
	  temp = tilde_expand (dirname);
	  xfree (dirname);
	  dirname = temp;
	}

      /* We have saved the possibly-dequoted version of the directory name
	 the user typed.  Now transform the directory name we're going to
	 pass to opendir(2).  The directory rewrite hook modifies only the
	 directory name; the directory completion hook modifies both the
	 directory name passed to opendir(2) and the version the user
	 typed.  Both the directory completion and rewrite hooks should perform
	 any necessary dequoting.  The hook functions return 1 if they modify
	 the directory name argument.  If either hook returns 0, it should
	 not modify the directory name pointer passed as an argument. */
      if (rl_directory_rewrite_hook)
	(*rl_directory_rewrite_hook) (&dirname);
      else if (rl_directory_completion_hook && (*rl_directory_completion_hook) (&dirname))
	{
	  xfree (users_dirname);
	  users_dirname = savestring (dirname);
	}
      else if (rl_completion_found_quote && rl_filename_dequoting_function)
	{
	  /* delete single and double quotes */
	  xfree (dirname);
	  dirname = savestring (users_dirname);
	}
      directory = opendir (dirname);

      /* Now dequote a non-null filename. */
      if (filename && *filename && rl_completion_found_quote && rl_filename_dequoting_function)
	{
	  /* delete single and double quotes */
	  temp = (*rl_filename_dequoting_function) (filename, rl_completion_quote_character);
	  xfree (filename);
	  filename = temp;
	}
      filename_len = strlen (filename);

      rl_filename_completion_desired = 1;
    }

  /* At this point we should entertain the possibility of hacking wildcarded
     filenames, like /usr/man/man<WILD>/te<TAB>.  If the directory name
     contains globbing characters, then build an array of directories, and
     then map over that list while completing. */
  /* *** UNIMPLEMENTED *** */

  /* Now that we have some state, we can read the directory. */

  entry = (struct dirent *)NULL;
  while (directory && (entry = readdir (directory)))
    {
      convfn = dentry = entry->d_name;
      convlen = dentlen = D_NAMLEN (entry);

      if (rl_filename_rewrite_hook)
	{
	  convfn = (*rl_filename_rewrite_hook) (dentry, dentlen);
	  convlen = (convfn == dentry) ? dentlen : strlen (convfn);
	}

      /* Special case for no filename.  If the user has disabled the
         `match-hidden-files' variable, skip filenames beginning with `.'.
	 All other entries except "." and ".." match. */
      if (filename_len == 0)
	{
	  if (_rl_match_hidden_files == 0 && HIDDEN_FILE (convfn))
	    continue;

	  if (convfn[0] != '.' ||
	       (convfn[1] && (convfn[1] != '.' || convfn[2])))
	    break;
	}
      else
	{
	  if (complete_fncmp (convfn, convlen, filename, filename_len))
	    break;
	}
    }

  if (entry == 0)
    {
      if (directory)
	{
	  closedir (directory);
	  directory = (DIR *)NULL;
	}
      if (dirname)
	{
	  xfree (dirname);
	  dirname = (char *)NULL;
	}
      if (filename)
	{
	  xfree (filename);
	  filename = (char *)NULL;
	}
      if (users_dirname)
	{
	  xfree (users_dirname);
	  users_dirname = (char *)NULL;
	}

      return (char *)NULL;
    }
  else
    {
      /* dirname && (strcmp (dirname, ".") != 0) */
      if (dirname && (dirname[0] != '.' || dirname[1]))
	{
	  if (rl_complete_with_tilde_expansion && *users_dirname == '~')
	    {
	      dirlen = strlen (dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, dirname);
	      /* Canonicalization cuts off any final slash present.  We
		 may need to add it back. */
	      if (dirname[dirlen - 1] != '/')
	        {
	          temp[dirlen++] = '/';
	          temp[dirlen] = '\0';
	        }
	    }
	  else
	    {
	      dirlen = strlen (users_dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, users_dirname);
	      /* Make sure that temp has a trailing slash here. */
	      if (users_dirname[dirlen - 1] != '/')
		temp[dirlen++] = '/';
	    }

	  strcpy (temp + dirlen, convfn);
	}
      else
	temp = savestring (convfn);

      if (convfn != dentry)
	xfree (convfn);

      return (temp);
    }
}

/* An initial implementation of a menu completion function a la tcsh.  The
   first time (if the last readline command was not rl_old_menu_complete), we
   generate the list of matches.  This code is very similar to the code in
   rl_complete_internal -- there should be a way to combine the two.  Then,
   for each item in the list of matches, we insert the match in an undoable
   fashion, with the appropriate character appended (this happens on the
   second and subsequent consecutive calls to rl_old_menu_complete).  When we
   hit the end of the match list, we restore the original unmatched text,
   ring the bell, and reset the counter to zero. */
int
rl_old_menu_complete (count, invoking_key)
     int count, invoking_key;
{
  rl_compentry_func_t *our_func;
  int matching_filenames, found_quote;

  static char *orig_text;
  static char **matches = (char **)0;
  static int match_list_index = 0;
  static int match_list_size = 0;
  static int orig_start, orig_end;
  static char quote_char;
  static int delimiter;

  /* The first time through, we generate the list of matches and set things
     up to insert them. */
  if (rl_last_func != rl_old_menu_complete)
    {
      /* Clean up from previous call, if any. */
      FREE (orig_text);
      if (matches)
	_rl_free_match_list (matches);

      match_list_index = match_list_size = 0;
      matches = (char **)NULL;

      rl_completion_invoking_key = invoking_key;

      RL_SETSTATE(RL_STATE_COMPLETING);

      /* Only the completion entry function can change these. */
      set_completion_defaults ('%');

      our_func = rl_menu_completion_entry_function;
      if (our_func == 0)
	our_func = rl_completion_entry_function
			? rl_completion_entry_function
			: rl_filename_completion_function;

      /* We now look backwards for the start of a filename/variable word. */
      orig_end = rl_point;
      found_quote = delimiter = 0;
      quote_char = '\0';

      if (rl_point)
	/* This (possibly) changes rl_point.  If it returns a non-zero char,
	   we know we have an open quote. */
	quote_char = _rl_find_completion_word (&found_quote, &delimiter);

      orig_start = rl_point;
      rl_point = orig_end;

      orig_text = rl_copy_text (orig_start, orig_end);
      matches = gen_completion_matches (orig_text, orig_start, orig_end,
					our_func, found_quote, quote_char);

      /* If we are matching filenames, the attempted completion function will
	 have set rl_filename_completion_desired to a non-zero value.  The basic
	 rl_filename_completion_function does this. */
      matching_filenames = rl_filename_completion_desired;

      if (matches == 0 || postprocess_matches (&matches, matching_filenames) == 0)
	{
	  rl_ding ();
	  FREE (matches);
	  matches = (char **)0;
	  FREE (orig_text);
	  orig_text = (char *)0;
	  completion_changed_buffer = 0;
	  RL_UNSETSTATE(RL_STATE_COMPLETING);
	  return (0);
	}

      RL_UNSETSTATE(RL_STATE_COMPLETING);

      for (match_list_size = 0; matches[match_list_size]; match_list_size++)
        ;
      /* matches[0] is lcd if match_list_size > 1, but the circular buffer
	 code below should take care of it. */

      if (match_list_size > 1 && _rl_complete_show_all)
	display_matches (matches);
    }

  /* Now we have the list of matches.  Replace the text between
     rl_line_buffer[orig_start] and rl_line_buffer[rl_point] with
     matches[match_list_index], and add any necessary closing char. */

  if (matches == 0 || match_list_size == 0) 
    {
      rl_ding ();
      FREE (matches);
      matches = (char **)0;
      completion_changed_buffer = 0;
      return (0);
    }

  match_list_index += count;
  if (match_list_index < 0)
    {
      while (match_list_index < 0)
	match_list_index += match_list_size;
    }
  else
    match_list_index %= match_list_size;

  if (match_list_index == 0 && match_list_size > 1)
    {
      rl_ding ();
      insert_match (orig_text, orig_start, MULT_MATCH, &quote_char);
    }
  else
    {
      insert_match (matches[match_list_index], orig_start, SINGLE_MATCH, &quote_char);
      append_to_match (matches[match_list_index], delimiter, quote_char,
		       strcmp (orig_text, matches[match_list_index]));
    }

  completion_changed_buffer = 1;
  return (0);
}

int
rl_menu_complete (count, ignore)
     int count, ignore;
{
  rl_compentry_func_t *our_func;
  int matching_filenames, found_quote;

  static char *orig_text;
  static char **matches = (char **)0;
  static int match_list_index = 0;
  static int match_list_size = 0;
  static int nontrivial_lcd = 0;
  static int full_completion = 0;	/* set to 1 if menu completion should reinitialize on next call */
  static int orig_start, orig_end;
  static char quote_char;
  static int delimiter, cstate;

  /* The first time through, we generate the list of matches and set things
     up to insert them. */
  if ((rl_last_func != rl_menu_complete && rl_last_func != rl_backward_menu_complete) || full_completion)
    {
      /* Clean up from previous call, if any. */
      FREE (orig_text);
      if (matches)
	_rl_free_match_list (matches);

      match_list_index = match_list_size = 0;
      matches = (char **)NULL;

      full_completion = 0;

      RL_SETSTATE(RL_STATE_COMPLETING);

      /* Only the completion entry function can change these. */
      set_completion_defaults ('%');

      our_func = rl_menu_completion_entry_function;
      if (our_func == 0)
	our_func = rl_completion_entry_function
			? rl_completion_entry_function
			: rl_filename_completion_function;

      /* We now look backwards for the start of a filename/variable word. */
      orig_end = rl_point;
      found_quote = delimiter = 0;
      quote_char = '\0';

      if (rl_point)
	/* This (possibly) changes rl_point.  If it returns a non-zero char,
	   we know we have an open quote. */
	quote_char = _rl_find_completion_word (&found_quote, &delimiter);

      orig_start = rl_point;
      rl_point = orig_end;

      orig_text = rl_copy_text (orig_start, orig_end);
      matches = gen_completion_matches (orig_text, orig_start, orig_end,
					our_func, found_quote, quote_char);

      nontrivial_lcd = matches && strcmp (orig_text, matches[0]) != 0;

      /* If we are matching filenames, the attempted completion function will
	 have set rl_filename_completion_desired to a non-zero value.  The basic
	 rl_filename_completion_function does this. */
      matching_filenames = rl_filename_completion_desired;

      if (matches == 0 || postprocess_matches (&matches, matching_filenames) == 0)
	{
	  rl_ding ();
	  FREE (matches);
	  matches = (char **)0;
	  FREE (orig_text);
	  orig_text = (char *)0;
	  completion_changed_buffer = 0;
	  RL_UNSETSTATE(RL_STATE_COMPLETING);
	  return (0);
	}

      RL_UNSETSTATE(RL_STATE_COMPLETING);

      for (match_list_size = 0; matches[match_list_size]; match_list_size++)
        ;

      if (match_list_size == 0) 
	{
	  rl_ding ();
	  FREE (matches);
	  matches = (char **)0;
	  match_list_index = 0;
	  completion_changed_buffer = 0;
	  return (0);
        }

      /* matches[0] is lcd if match_list_size > 1, but the circular buffer
	 code below should take care of it. */
      if (*matches[0])
	{
	  insert_match (matches[0], orig_start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);
	  orig_end = orig_start + strlen (matches[0]);
	  completion_changed_buffer = STREQ (orig_text, matches[0]) == 0;
	}

      if (match_list_size > 1 && _rl_complete_show_all)
	{
	  display_matches (matches);
	  /* If there are so many matches that the user has to be asked
	     whether or not he wants to see the matches, menu completion
	     is unwieldy. */
	  if (rl_completion_query_items > 0 && match_list_size >= rl_completion_query_items)
	    {
	      rl_ding ();
	      FREE (matches);
	      matches = (char **)0;
	      full_completion = 1;
	      return (0);
	    }
	}
      else if (match_list_size <= 1)
	{
	  append_to_match (matches[0], delimiter, quote_char, nontrivial_lcd);
	  full_completion = 1;
	  return (0);
	}
      else if (_rl_menu_complete_prefix_first && match_list_size > 1)
	{
	  rl_ding ();
	  return (0);
	}
    }

  /* Now we have the list of matches.  Replace the text between
     rl_line_buffer[orig_start] and rl_line_buffer[rl_point] with
     matches[match_list_index], and add any necessary closing char. */

  if (matches == 0 || match_list_size == 0) 
    {
      rl_ding ();
      FREE (matches);
      matches = (char **)0;
      completion_changed_buffer = 0;
      return (0);
    }

  match_list_index += count;
  if (match_list_index < 0)
    {
      while (match_list_index < 0)
	match_list_index += match_list_size;
    }
  else
    match_list_index %= match_list_size;

  if (match_list_index == 0 && match_list_size > 1)
    {
      rl_ding ();
      insert_match (matches[0], orig_start, MULT_MATCH, &quote_char);
    }
  else
    {
      insert_match (matches[match_list_index], orig_start, SINGLE_MATCH, &quote_char);
      append_to_match (matches[match_list_index], delimiter, quote_char,
		       strcmp (orig_text, matches[match_list_index]));
    }

  completion_changed_buffer = 1;
  return (0);
}

int
rl_backward_menu_complete (count, key)
     int count, key;
{
  /* Positive arguments to backward-menu-complete translate into negative
     arguments for menu-complete, and vice versa. */
  return (rl_menu_complete (-count, key));
}
@


1.10
log
@2011-10-11  Sterling Augustine  <saugustine@@google.com>

	* dwarf2read.c: Undo inadvertent changes in previous commit.
@
text
@d1997 1
a1997 2
  while (string = (*entry_function) (text, matches)
         && matches <= rl_completion_query_items)
@


1.9
log
@Imported readline 6.2, and upstream patch 001.

[patch 0/3] readline-6.2 rebase
http://sourceware.org/ml/gdb-patches/2011-05/msg00003.html
[patch 1/3] readline-6.2: Merge of already posted patches
http://sourceware.org/ml/gdb-patches/2011-05/msg00004.html
	=
	[Bug-readline] [RFC/readline] bind.c, rl_function_dumper, Free allocated
	http://lists.gnu.org/archive/html/bug-readline/2011-03/msg00000.html
	[Bug-readline] [patch] Fix underquotation in readline/examples/rlfe/conf
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00001.html
	[Bug-readline] [patch] Makefile.in htm<->html
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00002.html
	Re: [Bug-readline] [patch] Makefile.in dependency: callback.o: xmalloc.h
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00004.html
	[Bug-readline] [patch] Remove . from the VPATH directive
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00005.html
	Eli Zaretskii's __MSDOS__ / __GO32__ / __MINGW32__ / __DJGPP__ stuff:
	http://sourceware.org/ml/gdb/2011-04/msg00002.html
	Jan Kratochvil's patch for FSF GDB tree local-specific changes:
	http://sourceware.org/ml/gdb/2011-04/msg00006.html
	Preservation of existing ChangeLog.gdb files, their updates.
[patch 2/3] readline-6.2: Workaround "ask" regression
http://sourceware.org/ml/gdb-patches/2011-05/msg00005.html
[patch 3/3] readline-6.2: Revert 5.x compat., apply 6.x compat.
http://sourceware.org/ml/gdb-patches/2011-05/msg00006.html
[patch 4/3] readline-6.2: Substitute inc-hist.texinfo
http://sourceware.org/ml/gdb-patches/2011-05/msg00010.html

readline/
	Workaround gdb.base/completion.exp regression on readline-6.2.
	* complete.c (get_y_or_n): Disable the return on RL_STATE_CALLBACK.

	Imported readline 6.2, and upstream patch 001.
	* configure: Regenerate.

readline/doc/
	* hsuser.texi (Using History Interactively): Disable !BashFeatures
	@@defcodeindex.  Make the `Programming with GNU History' reference
	external.
	* inc-hist.texinfo: Remove.

	Imported readline 6.2, and upstream patch 001.

readline/examples/
	Imported readline 6.2, and upstream patch 001.

readline/examples/rlfe/
	Imported readline 6.2, and upstream patch 001.

gdb/
	* config.in: Regenerate.
	* configure: Regenerate.
	* configure.ac <--with-system-readline> (for readline_echoing_p):
	Remove the test.
	* tui/tui-io.c (tui_old_readline_echoing_p): Rename to ...
	(tui_old_rl_echoing_p): ... here.
	(tui_setup_io): Rename extern declaration readline_echoing_p to
	_rl_echoing_p.  Adjust assignments for the both renames.

gdb/doc/
	* Makefile.in (GDB_DOC_SOURCE_INCLUDES): Rename inc-hist.texinfo to
	hsuser.texi.
	* gdb.texinfo <!SYSTEM_READLINE>: Rename inc-hist.texinfo inclusion and
	comment to hsuser.texi.  Change rluser.texi name in the comment.
@
text
@d1997 2
a1998 1
  while (string = (*entry_function) (text, matches))
@


1.8
log
@Readline 5.1 import for HEAD.
@
text
@d3 1
a3 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
d5 2
a6 2
   This file is part of the GNU Readline Library, a library for
   reading lines of text with interactive input and history editing.
d8 3
a10 3
   The GNU Readline Library is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2, or
d13 3
a15 3
   The GNU Readline Library is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
d18 4
a21 4
   The GNU General Public License is often shipped with GNU software, and
   is generally kept in a file called COPYING or LICENSE.  If you do not
   have a copy of the license, write to the Free Software Foundation,
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
d113 2
a114 2
static int fnprint PARAMS((const char *));
static int print_filename PARAMS((char *, char *));
d122 1
d126 1
d162 1
a162 1
int _rl_completion_case_fold;
d165 5
a169 1
/* If non-zero, don't match hidden files (filenames beginning with a `.' on
d173 10
d192 10
d209 11
d228 4
d369 6
d380 3
d396 2
d415 1
d423 1
d452 8
d471 1
d484 13
d507 1
a507 1
      if (c == ABORT_CHAR)
d560 7
d667 1
a667 1
      if (CTRL_CHAR (*string) || *string == RUBOUT)
d700 2
d703 1
a703 1
fnprint (to_print)
d705 1
d707 1
a707 1
  int printed_len;
d713 1
a713 1
  int width, w;
d721 17
a737 1
  s = to_print;
d796 1
a796 1
print_filename (to_print, full_pathname)
d798 1
d804 1
a804 1
  printed_len = fnprint (to_print);
d859 1
a859 1
	  free (new_full_pathname);
d874 1
a874 1
      free (s);
d1056 1
a1056 1
  char **matches, *temp;
d1066 1
d1068 2
d1078 1
a1078 12
  /* Beware -- we're stripping the quotes here.  Do this only if we know
     we are doing filename completion and the application has defined a
     filename dequoting function. */
  temp = (char *)NULL;

  if (found_quote && our_func == rl_filename_completion_function &&
      rl_filename_dequoting_function)
    {
      /* delete single and double quotes */
      temp = (*rl_filename_dequoting_function) (text, quote_char);
      text = temp;	/* not freeing text is not a memory leak */
    }
a1080 1
  FREE (temp);
d1101 1
a1101 1
  if (i)
d1111 1
a1111 1
	  free (matches[i]);
d1129 1
a1129 1
    free (matches[0]);
d1139 1
a1139 1
      free (temp_array[1]);
d1213 2
a1214 1
		mbstate_t ps_back = ps1;
d1318 1
a1318 1
      free (matches);
d1355 17
d1381 19
a1399 3
  int count, limit, printed_len, lines;
  int i, j, k, l;
  char *temp;
d1402 1
d1404 2
a1405 2
  limit = _rl_screenwidth / max;
  if (limit != 1 && (limit * max == _rl_screenwidth))
d1408 5
a1412 1
  /* Avoid a possible floating exception.  If max > _rl_screenwidth,
d1425 1
a1425 1
  if (rl_ignore_completion_duplicates == 0)
d1443 1
a1443 1
		  printed_len = print_filename (temp, matches[l]);
d1467 1
a1467 1
	  printed_len = print_filename (temp, matches[i]);
d1517 1
a1517 1
      print_filename (temp, matches[0]);
d1553 1
a1553 1
      if (get_y_or_n (0) == 0)
d1621 1
a1621 1
  char *replacement;
d1623 1
d1631 1
d1641 18
a1658 1
      _rl_replace_text (replacement, start, rl_point - 1);
d1660 1
a1660 1
        free (replacement);
d1727 1
a1727 1
      free (filename);
d1763 1
a1763 1
	    free (rp);
d1772 1
a1772 1
	free (rp);
d1787 2
a1788 2
    free (matches[i]);
  free (matches);
d1809 3
d1839 5
a1843 1
  free (text);
d1851 1
d1866 1
d1876 1
d1879 16
d1934 1
a1934 1
      fprintf (stderr, "\r\nreadline: bad value %d for what_to_do in rl_complete\n", what_to_do);
d1938 1
d1948 1
a1948 1
      free (saved_line_buffer);
d1952 1
d1996 1
d2006 2
d2015 1
a2015 1
      free (match_list);
d2081 56
d2151 2
a2152 2
  char *temp;
  int dirlen;
d2203 6
a2208 2
      /* Save the version of the directory that the user typed. */
      users_dirname = savestring (dirname);
d2213 1
a2213 1
	  free (dirname);
d2217 9
d2228 1
a2228 2

      if (rl_directory_completion_hook && (*rl_directory_completion_hook) (&dirname))
d2230 1
a2230 1
	  free (users_dirname);
d2233 7
d2241 8
a2248 1
      directory = opendir (dirname);
d2265 9
d2279 1
a2279 1
	  if (_rl_match_hidden_files == 0 && HIDDEN_FILE (entry->d_name))
d2282 2
a2283 3
	  if (entry->d_name[0] != '.' ||
	       (entry->d_name[1] &&
		 (entry->d_name[1] != '.' || entry->d_name[2])))
d2288 2
a2289 16
	  /* Otherwise, if these match up to the length of filename, then
	     it is a match. */
	  if (_rl_completion_case_fold)
	    {
	      if ((_rl_to_lower (entry->d_name[0]) == _rl_to_lower (filename[0])) &&
		  (((int)D_NAMLEN (entry)) >= filename_len) &&
		  (_rl_strnicmp (filename, entry->d_name, filename_len) == 0))
		break;
	    }
	  else
	    {
	      if ((entry->d_name[0] == filename[0]) &&
		  (((int)D_NAMLEN (entry)) >= filename_len) &&
		  (strncmp (filename, entry->d_name, filename_len) == 0))
		break;
	    }
d2302 1
a2302 1
	  free (dirname);
d2307 1
a2307 1
	  free (filename);
d2312 1
a2312 1
	  free (users_dirname);
d2346 1
a2346 1
	  strcpy (temp + dirlen, entry->d_name);
d2349 4
a2352 1
	temp = savestring (entry->d_name);
d2359 1
a2359 1
   first time (if the last readline command was not rl_menu_complete), we
d2364 1
a2364 1
   second and subsequent consecutive calls to rl_menu_complete).  When we
d2368 123
d2501 2
d2505 1
a2505 1
  static int delimiter;
d2509 1
a2509 1
  if (rl_last_func != rl_menu_complete)
d2519 4
d2526 3
a2528 1
      our_func = rl_completion_entry_function
d2549 2
d2558 1
a2558 1
    	  rl_ding ();
d2563 3
a2565 2
    	  completion_changed_buffer = 0;
          return (0);
d2568 2
d2572 11
d2585 33
d2635 4
a2638 1
    match_list_index += match_list_size;
d2645 1
a2645 1
      insert_match (orig_text, orig_start, MULT_MATCH, &quote_char);
d2657 9
@


1.7
log
@touched all sources to ease import of readline-5.1
@
text
@d3 1
a3 1
/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
d31 1
a31 1
#include <sys/file.h>
d51 1
a51 1
#ifdef HAVE_PWD_H
d84 1
a84 2
#if defined(HAVE_GETPWENT) && \
    (!defined (HAVE_GETPW_DECLS) || defined (_POSIX_SOURCE))
d86 1
a86 1
#endif /* defiend (HAVE_GETPWENT) && (!HAVE_GETPW_DECLS || _POSIX_SOURCE) */
d104 2
d112 2
d139 4
d211 2
a212 1
   she is sure she wants to see them all. */
d228 6
a233 1
const char *rl_completer_word_break_characters = (const char *)NULL;
d301 13
d352 2
d386 2
d408 1
a408 1
  rl_completion_suppress_append = 0;
d459 9
d565 124
a692 21
#define PUTX(c) \
    do { \
      if (CTRL_CHAR (c)) \
        { \
          putc ('^', rl_outstream); \
          putc (UNCTRL (c), rl_outstream); \
          printed_len += 2; \
        } \
      else if (c == RUBOUT) \
	{ \
	  putc ('^', rl_outstream); \
	  putc ('?', rl_outstream); \
	  printed_len += 2; \
	} \
      else \
	{ \
	  putc (c, rl_outstream); \
	  printed_len++; \
	} \
    } while (0)

d697 2
a698 3
  int printed_len = 0;
#if !defined (VISIBLE_STATS)
  char *s;
d700 2
a701 7
  for (s = to_print; *s; s++)
    {
      PUTX (*s);
    }
#else  
  char *s, c, *new_full_pathname;
  int extension_char, slen, tlen;
d703 5
a707 6
  for (s = to_print; *s; s++)
    {
      PUTX (*s);
    }

 if (rl_filename_completion_desired && rl_visible_stats)
d723 11
a733 1
	  s = tilde_expand (full_pathname && *full_pathname ? full_pathname : "/");
d741 4
d748 7
a754 1
	  extension_char = stat_char (new_full_pathname);
d762 7
a768 1
	  extension_char = stat_char (s);
d778 1
a778 1
#endif /* VISIBLE_STATS */
d818 1
a818 1
  char quote_char;
d824 6
d836 1
a836 1
      for (scan = pass_next = 0; scan < end; scan++)
d886 1
a886 5
#if defined (HANDLE_MULTIBYTE)
      while (rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_ANY))
#else
      while (--rl_point)
#endif
d890 1
a890 1
	  if (strchr (rl_completer_word_break_characters, scan) == 0)
d918 1
a918 1
		strchr (rl_completer_word_break_characters, scan) != 0;
d920 1
a920 1
	isbrk = strchr (rl_completer_word_break_characters, scan) != 0;
d955 3
d1061 1
d1153 20
d1192 2
d1398 1
a1398 1
      len = strlen (temp);
d1415 1
a1415 1
  if (len >= rl_completion_query_items)
d1533 2
a1534 1
  if (quote_char && rl_point && rl_line_buffer[rl_point - 1] != quote_char)
d1552 1
a1552 1
	  if (_rl_complete_mark_directories)
d1645 3
a1647 1
   there is more than one. */
a1665 1

d1713 1
d1733 6
d1866 1
a1866 1
#ifdef HAVE_GETPWENT
d1877 1
a1877 1
#ifdef HAVE_GETPWENT
d2191 1
a2191 1
  match_list_index = (match_list_index + count) % match_list_size;
d2194 2
@


1.7.2.1
log
@Import readline 5.1 on the branch.
@
text
@d3 1
a3 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
d31 1
a31 1
#  include <sys/file.h>
d51 1
a51 1
#if defined (HAVE_PWD_H)
d84 2
a85 1
#if defined (HAVE_GETPWENT) && (!defined (HAVE_GETPW_DECLS) || defined (_POSIX_SOURCE))
d87 1
a87 1
#endif /* HAVE_GETPWENT && (!HAVE_GETPW_DECLS || _POSIX_SOURCE) */
a104 2
static int path_isdir PARAMS((const char *));

a110 2
static int fnwidth PARAMS((const char *));
static int fnprint PARAMS((const char *));
a135 4
/* If non-zero, non-unique completions show the list of matches, unless it
   is not possible to do partial completion and modify the line. */
int _rl_complete_show_unmodified = 0;

d204 1
a204 2
   she is sure she wants to see them all.  A negative value means
   don't ask. */
d220 1
a220 6
/*const*/ char *rl_completer_word_break_characters = (/*const*/ char *)NULL;

/* Hook function to allow an application to set the completion word
   break characters before readline breaks up the line.  Allows
   position-dependent word break characters. */
rl_cpvfunc_t *rl_completion_word_break_hook = (rl_cpvfunc_t *)NULL;
a287 13
/* If non-zero, the completion functions don't append any closing quote.
   This is set to 0 by rl_complete_internal and may be changed by an
   application-specific completion function. */
int rl_completion_suppress_quote = 0;

/* Set to any quote character readline thinks it finds before any application
   completion function is called. */
int rl_completion_quote_character;

/* Set to a non-zero value if readline found quoting anywhere in the word to
   be completed; set before any application completion function is called. */
int rl_completion_found_quote;

a325 2
  else if (_rl_complete_show_unmodified)
    return (rl_complete_internal ('@@'));
a357 2
  else if (_rl_complete_show_unmodified)
    return '@@';
d378 1
a378 1
  rl_completion_suppress_append = rl_completion_suppress_quote = 0;
a428 9
static int
path_isdir (filename)
     const char *filename;
{
  struct stat finfo;

  return (stat (filename, &finfo) == 0 && S_ISDIR (finfo.st_mode));
}

a525 124
/* Compute width of STRING when displayed on screen by print_filename */
static int
fnwidth (string)
     const char *string;
{
  int width, pos;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
  int left, w;
  size_t clen;
  wchar_t wc;

  left = strlen (string) + 1;
  memset (&ps, 0, sizeof (mbstate_t));
#endif

  width = pos = 0;
  while (string[pos])
    {
      if (CTRL_CHAR (*string) || *string == RUBOUT)
	{
	  width += 2;
	  pos++;
	}
      else
	{
#if defined (HANDLE_MULTIBYTE)
	  clen = mbrtowc (&wc, string + pos, left - pos, &ps);
	  if (MB_INVALIDCH (clen))
	    {
	      width++;
	      pos++;
	      memset (&ps, 0, sizeof (mbstate_t));
	    }
	  else if (MB_NULLWCH (clen))
	    break;
	  else
	    {
	      pos += clen;
	      w = wcwidth (wc);
	      width += (w >= 0) ? w : 1;
	    }
#else
	  width++;
	  pos++;
#endif
	}
    }

  return width;
}

static int
fnprint (to_print)
     const char *to_print;
{
  int printed_len;
  const char *s;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
  const char *end;
  size_t tlen;
  int width, w;
  wchar_t wc;

  end = to_print + strlen (to_print) + 1;
  memset (&ps, 0, sizeof (mbstate_t));
#endif

  printed_len = 0;
  s = to_print;
  while (*s)
    {
      if (CTRL_CHAR (*s))
        {
          putc ('^', rl_outstream);
          putc (UNCTRL (*s), rl_outstream);
          printed_len += 2;
          s++;
#if defined (HANDLE_MULTIBYTE)
	  memset (&ps, 0, sizeof (mbstate_t));
#endif
        }
      else if (*s == RUBOUT)
	{
	  putc ('^', rl_outstream);
	  putc ('?', rl_outstream);
	  printed_len += 2;
	  s++;
#if defined (HANDLE_MULTIBYTE)
	  memset (&ps, 0, sizeof (mbstate_t));
#endif
	}
      else
	{
#if defined (HANDLE_MULTIBYTE)
	  tlen = mbrtowc (&wc, s, end - s, &ps);
	  if (MB_INVALIDCH (tlen))
	    {
	      tlen = 1;
	      width = 1;
	      memset (&ps, 0, sizeof (mbstate_t));
	    }
	  else if (MB_NULLWCH (tlen))
	    break;
	  else
	    {
	      w = wcwidth (wc);
	      width = (w >= 0) ? w : 1;
	    }
	  fwrite (s, 1, tlen, rl_outstream);
	  s += tlen;
	  printed_len += width;
#else
	  putc (*s, rl_outstream);
	  s++;
	  printed_len++;
#endif
	}
    }

  return printed_len;
}

d530 21
d555 3
a557 2
  int printed_len, extension_char, slen, tlen;
  char *s, c, *new_full_pathname, *dn;
d559 7
a565 2
  extension_char = 0;
  printed_len = fnprint (to_print);
d567 6
a572 5
#if defined (VISIBLE_STATS)
 if (rl_filename_completion_desired && (rl_visible_stats || _rl_complete_mark_directories))
#else
 if (rl_filename_completion_desired && _rl_complete_mark_directories)
#endif
d588 1
a588 11
	  if (full_pathname == 0 || *full_pathname == 0)
	    dn = "/";
	  else if (full_pathname[0] != '/')
	    dn = full_pathname;
	  else if (full_pathname[1] == 0)
	    dn = "//";		/* restore trailing slash to `//' */
	  else if (full_pathname[1] == '/' && full_pathname[2] == 0)
	    dn = "/";		/* don't turn /// into // */
	  else
	    dn = full_pathname;
	  s = tilde_expand (dn);
a595 4
	  if (s[slen - 1] == '/')
	    slen--;
	  else
	    new_full_pathname[slen] = '/';
d599 1
a599 7
#if defined (VISIBLE_STATS)
	  if (rl_visible_stats)
	    extension_char = stat_char (new_full_pathname);
	  else
#endif
	  if (path_isdir (new_full_pathname))
	    extension_char = '/';
d607 1
a607 7
#if defined (VISIBLE_STATS)
	  if (rl_visible_stats)
	    extension_char = stat_char (s);
	  else
#endif
	    if (path_isdir (s))
	      extension_char = '/';
d617 1
a617 1

d657 1
a657 1
  char quote_char, *brkchars;
a662 6
  brkchars = 0;
  if (rl_completion_word_break_hook)
    brkchars = (*rl_completion_word_break_hook) ();
  if (brkchars == 0)
    brkchars = rl_completer_word_break_characters;

d669 1
a669 1
      for (scan = pass_next = 0; scan < end; scan = MB_NEXTCHAR (rl_line_buffer, scan, 1, MB_FIND_ANY))
d719 5
a723 1
      while (rl_point = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_ANY))
d727 1
a727 1
	  if (strchr (brkchars, scan) == 0)
d755 1
a755 1
		strchr (brkchars, scan) != 0;
d757 1
a757 1
	isbrk = strchr (brkchars, scan) != 0;
a791 3
  rl_completion_found_quote = found_quote;
  rl_completion_quote_character = quote_char;

a894 1
  char *dtext;		/* dequoted TEXT, if needed */
a985 20
	  /* We're making an assumption here:
		IF we're completing filenames AND
		   the application has defined a filename dequoting function AND
		   we found a quote character AND
		   the application has requested filename quoting
		THEN
		   we assume that TEXT was dequoted before checking against
		   the file system and needs to be dequoted here before we
		   check against the list of matches
		FI */
	  dtext = (char *)NULL;
	  if (rl_filename_completion_desired &&
	      rl_filename_dequoting_function &&
	      rl_completion_found_quote &&
	      rl_filename_quoting_desired)
	    {
	      dtext = (*rl_filename_dequoting_function) ((char *)text, rl_completion_quote_character);
	      text = dtext;
	    }

a1004 2

	  FREE (dtext);
d1209 1
a1209 1
      len = fnwidth (temp);
d1226 1
a1226 1
  if (rl_completion_query_items > 0 && len >= rl_completion_query_items)
d1344 1
a1344 2
  if (quote_char && rl_point && rl_completion_suppress_quote == 0 &&
      rl_line_buffer[rl_point - 1] != quote_char)
d1362 1
a1362 1
	  if (_rl_complete_mark_directories /* && rl_completion_suppress_append == 0 */)
d1455 1
a1455 3
   there is more than one.
   `@@' means to do standard completion, and list all possible completions if
   there is more than one and partial completion is not possible. */
d1474 1
a1521 1
    case '@@':
a1540 6
	  else if (what_to_do == '@@')
	    {
	      if (nontrivial_lcd == 0)
		display_matches (matches);
	      break;
	    }
d1668 1
a1668 1
#if defined (HAVE_GETPWENT)
d1679 1
a1679 1
#if defined (HAVE_GETPWENT)
d1993 1
a1993 1
  match_list_index += count;
a1995 2
  else
    match_list_index %= match_list_size;
@


1.6
log
@	* readline/aclocal.m4: Use AC_TRY_LINK to check for mbstate_t.
	* readline/complete.c (pwd.h): Guard with HAVE_PWD_H.
	(getpwent): Guard with HAVE_GETPWENT.
	(rl_username_completion_function): Guard use of getpwent.
	(endpwent): Likewise.
	* readline/config.h.in (HAVE_FCNTL): New macro.
	(HAVE_GETPWENT): Likewise.
	(HAVE_GETPWNAM): Likewise.
	(HAVE_GETPWUID): Likewise.
	(HAVE_KILL): Likewise.
	(HAVE_PWD_H): Likewise.
	* readline/configure: Regenerated.
	* readline/configure.in: Handle MinGW when cross compiling.  Check for
	getpwnam, getpwent, getpwuid, kill, and pwd.h.
	* readline/display.c (rl_clear_screen): Treat Windows like DOS.
	(insert_some_chars): Likewise.
	(delete_chars): Likewise.
	* readline/shell.c (pwd.h): Guard with HAVE_PWD_H.
	(getpwuid): Guard with HAVE_GETPWUID.
	(sh_unset_nodelay_mode): Guard use of fnctl with HAVE_FNCTL_H.
	* readline/signals.c (rl_signal_handler): Don't use SIGALRM or
	SIGQUIT if not defined.  Use "raise" if "kill" is not available.
	(rl_set_signals): Don't set handlers for SIGQUIT or SIGALRM if
	they are not defined.
	(rl_clear_signals): Likewise.
	* readline/tilde.c (pwd.h): Guard with HAVE_PWD_H.
	(getpwuid): Guard declaration with HAVE_GETPWUID.
	(getpwnam): Guard declaration with HAVE_GETPWNAM.
	(tilde_expand_word): Guard use of getpwnam with HAVE_GETPWNAM.
@
text
@@


1.5
log
@Import of readline 4.3.
Non-readline modified files:

src/gdb/ChangeLog src/gdb/defs.h src/gdb/cli/cli-cmds.c
src/gdb/cli/cli-setshow.c src/gdb/tui/ChangeLog
src/gdb/tui/tuiWin.c

In readline directory:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@d51 1
d53 1
d84 2
a85 1
#if !defined (HAVE_GETPW_DECLS) || defined (_POSIX_SOURCE)
d87 1
a87 1
#endif /* !HAVE_GETPW_DECLS || _POSIX_SOURCE */
d1668 1
d1675 1
d1679 1
d1681 1
@


1.5.60.1
log
@	* readline/Makefile.in (RLTTYOBJ): New variable.
	(OBJECTS): Use RLTTYOBJ.
	* readline/aclocal.m4: Use AC_RTY_LINK to check for mbstate_t.
	* readline/complete.c (pwd.h): Guard with HAVE_PWD_H.
	(getpwent): Guard with HAVE_GETPWENT.
	(rl_username_completion_function): Guard use of getpwent.
	(endpwent): Likewise.
	* readline/config.h.in (HAVE_FCNTL): New macro.
	(HAVE_GETPWENT): Likewise.
	(HAVE_GETPWNAM): Likewise.
	(HAVE_GETPWUID): Likewise.
	(HAVE_PWD_H): Likewise.
	* readline/configure: Regenerated.
	* readline/configure.in: Handle MinGW when cross compiling.  Check for
	getpwnam, getpwent, getpwuid, and pwd.h.  Set RLTTYOBJ.
	* readline/display.c (rl_clear_screen): Treat Windows like DOS.
	(insert_some_chars): Likewise.
	(delete_chars): Likewise.
	* readline/rldefs.h (NEW_TTY_DRIVER): Do not define for Windows.
	* readline/rlnotty.c: New file.
	* readline/shell.c (pwd.h): Guard with HAVE_PWD_H.
	(getpwuid): Guard with HAVE_GETPWUID.
	(sh_unset_nodelay_mode): Guard use of fnctl with HAVE_FNCTL_H.
	* readline/signals.c (rl_signal_handler): Don't use SIGALRM or
	SIGQUIT if not defined.  Use "raise" rather than "kill".
	(rl_set_signals): Don't set handlers for SIGQUIT or SIGALRM if
	they are not defined.
	(rl_clear_signals): Likewise.
	* readline/tilde.c (pwd.h): Guard with HAVE_PWD_H.
	(getpwuid): Guard declaration with HAVE_GETPWUID.
	(getpwnam): Guard declaration with HAVE_GETPWNAM.
	(tilde_expand_word): Guard use of getpwnam with HAVE_GETPWNAM.
@
text
@a50 1
#ifdef HAVE_PWD_H
a51 1
#endif
d82 1
a82 2
#if defined(HAVE_GETPWENT) && \
    (!defined (HAVE_GETPW_DECLS) || defined (_POSIX_SOURCE))
d84 1
a84 1
#endif /* defiend (HAVE_GETPWENT) && (!HAVE_GETPW_DECLS || _POSIX_SOURCE) */
a1664 1
#ifdef HAVE_GETPWENT
a1670 1
#endif
a1673 1
#ifdef HAVE_GETPWENT
a1674 1
#endif
@


1.4
log
@readline:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Locally modified files: Makefile.in, configure.in, configure
        (regenerated), config.h.in (regenerated), readline.h, rltty.c,
 	shell.c signals.c.

        Locally added files: acconfig.h, config/*, config.h.bot,
        cross-build/*, doc/inc-hit.texinfo.

        New files: USAGE, rlprivate.h, rlshell.h, xmalloc.h.
examples:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        New files: excallback.c, rlfe.c.
doc:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Regenerated inc-hist.texinfo as copy of hsuser.texinfo, for
        inclusion in the gdb manual.

        New file: rluserman.texinfo
@
text
@a51 12
#if !defined (HAVE_GETPW_DECLS)
extern struct passwd *getpwent ();
#endif /* USG && !HAVE_GETPW_DECLS */

/* ISC systems don't define getpwent() if _POSIX_SOURCE is defined. */
#if defined (isc386) && defined (_POSIX_SOURCE)
#  if defined (__STDC__)
extern struct passwd *getpwent (void);
#  else
extern struct passwd *getpwent ();
#  endif /* !__STDC__ */
#endif /* isc386 && _POSIX_SOURCE */
d58 1
d71 15
d93 1
a93 5
VFunction *rl_completion_display_matches_hook = (VFunction *)NULL;

/* Forward declarations for functions defined and used in this file. */
char *filename_completion_function __P((char *, int));
char **completion_matches __P((char *, CPFunction *));
d99 1
a99 1
static int stat_char __P((char *));
d102 17
a118 2
static char *rl_quote_filename __P((char *, int, char *));
static char *rl_strpbrk __P((char *, char *));
d120 1
a120 6
static char **remove_duplicate_matches __P((char **));
static void insert_match __P((char *, int, int, char *));
static int append_to_match __P((char *, int, int));
static void insert_all_matches __P((char **, int, char *));
static void display_matches __P((char **));
static int compute_lcd_of_matches __P((char **, int, char *));
d136 6
d153 4
d169 3
a171 1
Function *rl_directory_completion_hook = (Function *)NULL;
d177 1
a177 1
   NULL means to use filename_completion_function (), the default filename
d179 1
a179 1
Function *rl_completion_entry_function = (Function *)NULL;
d188 1
a188 1
CPPFunction *rl_attempted_completion_function = (CPPFunction *)NULL;
d204 2
d209 1
a209 1
char *rl_basic_word_break_characters = " \t\n\"\\'`@@$><=;|&{(";
d212 1
a212 1
char *rl_basic_quote_characters = "\"'";
d217 1
a217 1
char *rl_completer_word_break_characters = (char *)NULL;
d223 1
a223 1
char *rl_completer_quote_characters = (char *)NULL;
d226 1
a226 1
char *rl_filename_quote_characters = (char *)NULL;
d231 1
a231 1
char *rl_special_prefixes = (char *)NULL;
d257 1
a257 1
Function *rl_ignore_some_completions_function = (Function *)NULL;
d263 1
a263 1
CPFunction *rl_filename_quoting_function = rl_quote_filename;
d269 1
a269 1
CPFunction *rl_filename_dequoting_function = (CPFunction *)NULL;
d274 6
a279 1
Function *rl_char_is_quoted_p = (Function *)NULL;
d285 11
d312 1
a312 1
   completion_matches ()).  The default is to do filename completion. */
d318 1
a318 1
    return (rl_insert (ignore, invoking_key));
d342 17
d365 5
a369 5
/* Find the first occurrence in STRING1 of any character from STRING2.
   Return a pointer to the character in STRING1. */
static char *
rl_strpbrk (string1, string2)
     char *string1, *string2;
d371 5
a375 1
  register char *scan;
d377 2
a378 11
  for (; *string1; string1++)
    {
      for (scan = string2; *scan; scan++)
	{
	  if (*string1 == *scan)
	    {
	      return (string1);
	    }
	}
    }
  return ((char *)NULL);
d383 2
a384 1
get_y_or_n ()
d390 1
d392 2
d400 5
a404 1
      ding ();
d408 18
d486 5
a490 1
   final slash.  Otherwise, we return what we were passed. */
d495 4
a498 1
  char *temp;
d500 1
a500 1
  temp = rl_filename_completion_desired ? strrchr (pathname, '/') : (char *)NULL;
d502 1
a502 1
  if (rl_filename_completion_desired && temp == 0 && isalpha (pathname[0]) && pathname[1] == ':')
d505 16
a520 1
  return (temp ? ++temp : pathname);
d591 1
a591 1
	  new_full_pathname = xmalloc (slen + tlen + 2);
d626 1
a626 1
  r = xmalloc (strlen (s) + 2);
d637 1
a637 1
   rl_completer_quote_characters.  First we try to find an unclosed
d649 2
a650 2
static char
find_completion_word (fp, dp)
d674 5
a678 1
	  if (rl_line_buffer[scan] == '\\')
d705 2
d716 3
d720 1
d784 1
a784 1
     Function *our_func;
d808 1
a808 1
  if (found_quote && our_func == (Function *)filename_completion_function &&
d816 1
a816 1
  matches = completion_matches (text, (CPFunction *)our_func);
d888 1
a888 1
     char *text;
d892 5
d910 7
d923 14
d946 11
d970 1
a970 1
      match_list[0] = xmalloc (strlen (text) + 1);
d975 31
a1005 2
      match_list[0] = xmalloc (low + 1);
      strncpy (match_list[0], match_list[1], low);
d1022 3
d1077 1
a1077 1
  int count, limit, printed_len;
d1083 2
a1084 2
  limit = screenwidth / max;
  if (limit != 1 && (limit * max == screenwidth))
d1087 1
a1087 1
  /* Avoid a possible floating exception.  If max > screenwidth,
d1103 1
a1103 1
  crlf ();
d1105 1
d1126 8
a1133 1
	  crlf ();
d1147 10
a1156 1
		crlf ();
d1162 1
a1162 1
      crlf ();
d1191 1
a1191 1
      crlf ();
d1193 1
a1193 1
      crlf ();
d1225 1
a1225 1
      crlf ();
d1228 1
a1228 1
      if (get_y_or_n () == 0)
d1230 1
a1230 1
	  crlf ();
d1278 1
a1278 1
			? (rl_strpbrk (match, rl_filename_quote_characters) != 0)
d1324 7
a1330 1
   appended. */
d1332 1
a1332 1
append_to_match (text, delimiter, quote_char)
d1334 1
a1334 1
     int delimiter, quote_char;
d1337 1
a1337 1
  int temp_string_index;
d1346 1
a1346 1
  else if (rl_completion_append_character)
d1354 4
a1357 1
      if (stat (filename, &finfo) == 0 && S_ISDIR (finfo.st_mode))
d1359 10
a1368 2
	  if (_rl_complete_mark_directories && rl_line_buffer[rl_point] != '/')
	    rl_insert_text ("/");
d1370 7
d1379 1
a1379 1
	  if (rl_point == rl_end)
d1386 1
a1386 1
      if (rl_point == rl_end)
d1432 2
a1433 2
static void
free_match_list (matches)
d1438 3
d1458 2
a1459 2
  Function *our_func;
  int start, end, delimiter, found_quote, i;
d1463 3
a1465 4
  /* Only the completion entry function can change these. */
  rl_filename_completion_desired = 0;
  rl_filename_quoting_desired = 1;
  rl_completion_type = what_to_do;
d1470 1
a1470 1
		: (Function *)filename_completion_function;
d1480 1
a1480 1
    quote_char = find_completion_word (&found_quote, &delimiter);
d1487 3
d1494 1
a1494 1
      ding ();
d1496 2
a1500 5
#if 0
  /* If we are matching filenames, our_func will have been set to
     filename_completion_function */
  i = our_func == (Function *)filename_completion_function;
#else
d1503 1
a1503 1
     filename_completion_function does this. */
a1504 1
#endif
d1508 1
a1508 1
      ding ();
d1511 1
d1539 1
a1539 1
	    ding ();	/* There are other matches remaining. */
d1542 1
a1542 1
	append_to_match (matches[0], delimiter, quote_char);
d1556 1
a1556 1
      ding ();
d1558 1
d1562 1
a1562 1
  free_match_list (matches);
d1571 1
d1594 3
a1596 3
completion_matches (text, entry_function)
     char *text;
     CPFunction *entry_function;
d1641 2
a1642 2
username_completion_function (text, state)
     char *text;
d1679 1
a1679 1
      value = xmalloc (2 + strlen (entry->pw_name));
d1698 2
a1699 2
filename_completion_function (text, state)
     char *text;
d1734 1
a1734 1
      if (dirname[0] == '/' && dirname[1] == '/' && isalpha (dirname[2]) && dirname[3] == '/')
d1745 1
a1745 1
      else if (isalpha (dirname[0]) && dirname[1] == ':')
d1769 3
d1795 3
a1797 2
      /* Special case for no filename.
	 All entries except "." and ".." match. */
d1800 3
d1862 1
a1862 1
	      temp = xmalloc (2 + dirlen + D_NAMLEN (entry));
d1875 1
a1875 1
	      temp = xmalloc (1 + dirlen + D_NAMLEN (entry));
d1877 3
d1904 1
a1904 1
  Function *our_func;
d1922 1
a1922 1
	free_match_list (matches);
d1928 1
a1928 3
      rl_filename_completion_desired = 0;
      rl_filename_quoting_desired = 1;
      rl_completion_type = '%';
d1932 1
a1932 1
			: (Function *)filename_completion_function;
d1942 1
a1942 1
	quote_char = find_completion_word (&found_quote, &delimiter);
a1950 5
#if 0
      /* If we are matching filenames, our_func will have been set to
	 filename_completion_function */
      matching_filenames = our_func == (Function *)filename_completion_function;
#else
d1953 1
a1953 1
	 filename_completion_function does this. */
d1955 1
a1955 1
#endif
d1958 1
a1958 1
    	  ding ();
d1979 1
a1979 1
      ding ();
d1992 1
a1992 1
      ding ();
d1998 2
a1999 1
      append_to_match (matches[match_list_index], delimiter, quote_char);
@


1.4.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d52 12
a69 1
#include "rlmbutil.h"
a81 15
#ifdef HAVE_LSTAT
#  define LSTAT lstat
#else
#  define LSTAT stat
#endif

/* Unix version of a hidden file.  Could be different on other systems. */
#define HIDDEN_FILE(fname)	((fname)[0] == '.')

/* Most systems don't declare getpwent in <pwd.h> if _POSIX_SOURCE is
   defined. */
#if !defined (HAVE_GETPW_DECLS) || defined (_POSIX_SOURCE)
extern struct passwd *getpwent PARAMS((void));
#endif /* !HAVE_GETPW_DECLS || _POSIX_SOURCE */

d89 5
a93 1
rl_compdisp_func_t *rl_completion_display_matches_hook = (rl_compdisp_func_t *)NULL;
d99 1
a99 1
static int stat_char PARAMS((char *));
d102 2
a103 17
static char *rl_quote_filename PARAMS((char *, int, char *));

static void set_completion_defaults PARAMS((int));
static int get_y_or_n PARAMS((int));
static int _rl_internal_pager PARAMS((int));
static char *printable_part PARAMS((char *));
static int print_filename PARAMS((char *, char *));

static char **gen_completion_matches PARAMS((char *, int, int, rl_compentry_func_t *, int, int));

static char **remove_duplicate_matches PARAMS((char **));
static void insert_match PARAMS((char *, int, int, char *));
static int append_to_match PARAMS((char *, int, int, int));
static void insert_all_matches PARAMS((char **, int, char *));
static void display_matches PARAMS((char **));
static int compute_lcd_of_matches PARAMS((char **, int, const char *));
static int postprocess_matches PARAMS((char ***, int));
d105 6
a110 1
static char *make_quoted_replacement PARAMS((char *, int, char *));
a125 6
/* If non-zero, the symlinked directory completion behavior introduced in
   readline-4.2a is disabled, and symlinks that point to directories have
   a slash appended (subject to the value of _rl_complete_mark_directories).
   This is user-settable via the mark-symlinked-directories variable. */
int _rl_complete_mark_symlink_dirs = 0;

a136 4
/* If non-zero, don't match hidden files (filenames beginning with a `.' on
   Unix) when doing filename completion. */
int _rl_match_hidden_files = 1;

d149 1
a149 3
rl_icppfunc_t *rl_directory_completion_hook = (rl_icppfunc_t *)NULL;

rl_icppfunc_t *rl_directory_rewrite_hook = (rl_icppfunc_t *)NULL;
d155 1
a155 1
   NULL means to use rl_filename_completion_function (), the default filename
d157 1
a157 1
rl_compentry_func_t *rl_completion_entry_function = (rl_compentry_func_t *)NULL;
d166 1
a166 1
rl_completion_func_t *rl_attempted_completion_function = (rl_completion_func_t *)NULL;
a181 2
int _rl_page_completions = 1;

d185 1
a185 1
const char *rl_basic_word_break_characters = " \t\n\"\\'`@@$><=;|&{("; /* }) */
d188 1
a188 1
const char *rl_basic_quote_characters = "\"'";
d193 1
a193 1
const char *rl_completer_word_break_characters = (const char *)NULL;
d199 1
a199 1
const char *rl_completer_quote_characters = (const char *)NULL;
d202 1
a202 1
const char *rl_filename_quote_characters = (const char *)NULL;
d207 1
a207 1
const char *rl_special_prefixes = (const char *)NULL;
d233 1
a233 1
rl_compignore_func_t *rl_ignore_some_completions_function = (rl_compignore_func_t *)NULL;
d239 1
a239 1
rl_quote_func_t *rl_filename_quoting_function = rl_quote_filename;
d245 1
a245 1
rl_dequote_func_t *rl_filename_dequoting_function = (rl_dequote_func_t *)NULL;
d250 1
a250 6
rl_linebuf_func_t *rl_char_is_quoted_p = (rl_linebuf_func_t *)NULL;

/* If non-zero, the completion functions don't append anything except a
   possible closing quote.  This is set to 0 by rl_complete_internal and
   may be changed by an application-specific completion function. */
int rl_completion_suppress_append = 0;
a255 11
/* If non-zero, a slash will be appended to completed filenames that are
   symbolic links to directory names, subject to the value of the
   mark-directories variable (which is user-settable).  This exists so
   that application completion functions can override the user's preference
   (set via the mark-symlinked-directories variable) if appropriate.
   It's set to the value of _rl_complete_mark_symlink_dirs in
   rl_complete_internal before any application-specific completion
   function is called, so without that function doing anything, the user's
   preferences are honored. */
int rl_completion_mark_symlink_dirs;

d272 1
a272 1
   rl_completion_matches ()).  The default is to do filename completion. */
d278 1
a278 1
    return (_rl_insert_char (ignore, invoking_key));
a301 17
/* Return the correct value to pass to rl_complete_internal performing
   the same tests as rl_complete.  This allows consecutive calls to an
   application's completion function to list possible completions and for
   an application-specific completion function to honor the
   show-all-if-ambiguous readline variable. */
int
rl_completion_mode (cfunc)
     rl_command_func_t *cfunc;
{
  if (rl_last_func == cfunc && !completion_changed_buffer)
    return '?';
  else if (_rl_complete_show_all)
    return '!';
  else
    return TAB;
}

d308 5
a312 5
/* Set default values for readline word completion.  These are the variables
   that application completion functions can change or inspect. */
static void
set_completion_defaults (what_to_do)
     int what_to_do;
d314 1
a314 5
  /* Only the completion entry function can change these. */
  rl_filename_completion_desired = 0;
  rl_filename_quoting_desired = 1;
  rl_completion_type = what_to_do;
  rl_completion_suppress_append = 0;
d316 11
a326 2
  /* The completion entry function may optionally change this. */
  rl_completion_mark_symlink_dirs = _rl_complete_mark_symlink_dirs;
d331 1
a331 2
get_y_or_n (for_pager)
     int for_pager;
a336 1
      RL_SETSTATE(RL_STATE_MOREINPUT);
a337 2
      RL_UNSETSTATE(RL_STATE_MOREINPUT);

d344 1
a344 5
      if (for_pager && (c == NEWLINE || c == RETURN))
	return (2);
      if (for_pager && (c == 'q' || c == 'Q'))
	return (0);
      rl_ding ();
a347 18
static int
_rl_internal_pager (lines)
     int lines;
{
  int i;

  fprintf (rl_outstream, "--More--");
  fflush (rl_outstream);
  i = get_y_or_n (1);
  _rl_erase_entire_line ();
  if (i == 0)
    return -1;
  else if (i == 2)
    return (lines - 1);
  else
    return 0;
}

d408 1
a408 5
   final slash.  Otherwise, we return what we were passed.  Since
   printing empty strings is not very informative, if we're doing
   filename completion, and the basename is the empty string, we look
   for the previous slash and return the portion following that.  If
   there's no previous slash, we just return what we were passed. */
d413 1
a413 4
  char *temp, *x;

  if (rl_filename_completion_desired == 0)	/* don't need to do anything */
    return (pathname);
d415 1
a415 1
  temp = strrchr (pathname, '/');
d417 1
a417 1
  if (temp == 0 && ISALPHA ((unsigned char)pathname[0]) && pathname[1] == ':')
d420 1
a420 16

  if (temp == 0 || *temp == '\0')
    return (pathname);
  /* If the basename is NULL, we might have a pathname like '/usr/src/'.
     Look for a previous slash and, if one is found, return the portion
     following that slash.  If there's no previous slash, just return the
     pathname we were passed. */
  else if (temp[1] == '\0')
    {
      for (x = temp - 1; x > pathname; x--)
        if (*x == '/')
          break;
      return ((*x == '/') ? x + 1 : pathname);
    }
  else
    return ++temp;
d491 1
a491 1
	  new_full_pathname = (char *)xmalloc (slen + tlen + 2);
d526 1
a526 1
  r = (char *)xmalloc (strlen (s) + 2);
d537 1
a537 1
   rl_completer_quote_characters).  First we try to find an unclosed
d549 2
a550 2
char
_rl_find_completion_word (fp, dp)
d574 1
a574 5
	  /* Shell-like semantics for single quotes -- don't allow backslash
	     to quote anything in single quotes, especially not the closing
	     quote.  If you don't like this, take out the check on the value
	     of quote_char. */
	  if (quote_char != '\'' && rl_line_buffer[scan] == '\\')
a600 2
	      else
		found_quote |= RL_QF_OTHER_QUOTE;      
a609 3
#if defined (HANDLE_MULTIBYTE)
      while (rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_ANY))
#else
a610 1
#endif
d674 1
a674 1
     rl_compentry_func_t *our_func;
d698 1
a698 1
  if (found_quote && our_func == rl_filename_completion_function &&
d706 1
a706 1
  matches = rl_completion_matches (text, our_func);
d778 1
a778 1
     const char *text;
a781 5
#if defined (HANDLE_MULTIBYTE)
  int v;
  mbstate_t ps1, ps2;
  wchar_t wc1, wc2;
#endif
a794 7
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  memset (&ps1, 0, sizeof (mbstate_t));
	  memset (&ps2, 0, sizeof (mbstate_t));
	}
#endif
a800 14
#if defined (HANDLE_MULTIBYTE)
	    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	      {
		v = mbrtowc (&wc1, match_list[i]+si, strlen (match_list[i]+si), &ps1);
		mbrtowc (&wc2, match_list[i+1]+si, strlen (match_list[i+1]+si), &ps2);
		wc1 = towlower (wc1);
		wc2 = towlower (wc2);
		if (wc1 != wc2)
		  break;
		else if (v > 1)
		  si += v - 1;
	      }
	    else
#endif
a809 11
#if defined (HANDLE_MULTIBYTE)
	    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	      {
		mbstate_t ps_back = ps1;
		if (!_rl_compare_chars (match_list[i], si, &ps1, match_list[i+1], si, &ps2))
		  break;
		else if ((v = _rl_get_char_len (&match_list[i][si], &ps_back)) > 1)
		  si += v - 1;
	      }
	    else
#endif
d823 1
a823 1
      match_list[0] = (char *)xmalloc (strlen (text) + 1);
d828 2
a829 31
      match_list[0] = (char *)xmalloc (low + 1);

      /* XXX - this might need changes in the presence of multibyte chars */

      /* If we are ignoring case, try to preserve the case of the string
	 the user typed in the face of multiple matches differing in case. */
      if (_rl_completion_case_fold)
	{
	  /* sort the list to get consistent answers. */
	  qsort (match_list+1, matches, sizeof(char *), (QSFUNC *)_rl_qsort_string_compare);

	  si = strlen (text);
	  if (si <= low)
	    {
	      for (i = 1; i <= matches; i++)
		if (strncmp (match_list[i], text, si) == 0)
		  {
		    strncpy (match_list[0], match_list[i], low);
		    break;
		  }
	      /* no casematch, use first entry */
	      if (i > matches)
		strncpy (match_list[0], match_list[1], low);
	    }
	  else
	    /* otherwise, just use the text the user typed. */
	    strncpy (match_list[0], text, low);
	}
      else
        strncpy (match_list[0], match_list[1], low);

a845 3
  if (matches == 0)
    return 0;

d898 1
a898 1
  int count, limit, printed_len, lines;
d904 2
a905 2
  limit = _rl_screenwidth / max;
  if (limit != 1 && (limit * max == _rl_screenwidth))
d908 1
a908 1
  /* Avoid a possible floating exception.  If max > _rl_screenwidth,
d924 1
a924 1
  rl_crlf ();
a925 1
  lines = 0;
d946 1
a946 8
	  rl_crlf ();
	  lines++;
	  if (_rl_page_completions && lines >= (_rl_screenheight - 1) && i < count)
	    {
	      lines = _rl_internal_pager (lines);
	      if (lines < 0)
		return;
	    }
d960 1
a960 10
		{
		  rl_crlf ();
		  lines++;
		  if (_rl_page_completions && lines >= _rl_screenheight - 1)
		    {
		      lines = _rl_internal_pager (lines);
		      if (lines < 0)
			return;
		    }
		}
d966 1
a966 1
      rl_crlf ();
d995 1
a995 1
      rl_crlf ();
d997 1
a997 1
      rl_crlf ();
d1029 1
a1029 1
      rl_crlf ();
d1032 1
a1032 1
      if (get_y_or_n (0) == 0)
d1034 1
a1034 1
	  rl_crlf ();
d1082 1
a1082 1
			? (_rl_strpbrk (match, rl_filename_quote_characters) != 0)
d1128 1
a1128 7
   appended.  If NONTRIVIAL_MATCH is set, we test for a symlink (if the OS
   has them) and don't add a suffix for a symlink to a directory.  A
   nontrivial match is one that actually adds to the word being completed.
   The variable rl_completion_mark_symlink_dirs controls this behavior
   (it's initially set to the what the user has chosen, indicated by the
   value of _rl_complete_mark_symlink_dirs, but may be modified by an
   application's completion function). */
d1130 1
a1130 1
append_to_match (text, delimiter, quote_char, nontrivial_match)
d1132 1
a1132 1
     int delimiter, quote_char, nontrivial_match;
d1135 1
a1135 1
  int temp_string_index, s;
d1144 1
a1144 1
  else if (rl_completion_suppress_append == 0 && rl_completion_append_character)
d1152 1
a1152 4
      s = (nontrivial_match && rl_completion_mark_symlink_dirs == 0)
		? LSTAT (filename, &finfo)
		: stat (filename, &finfo);
      if (s == 0 && S_ISDIR (finfo.st_mode))
d1154 2
a1155 10
	  if (_rl_complete_mark_directories)
	    {
	      /* This is clumsy.  Avoid putting in a double slash if point
		 is at the end of the line and the previous character is a
		 slash. */
	      if (rl_point && rl_line_buffer[rl_point] == '\0' && rl_line_buffer[rl_point - 1] == '/')
		;
	      else if (rl_line_buffer[rl_point] != '/')
		rl_insert_text ("/");
	    }
a1156 7
#ifdef S_ISLNK
      /* Don't add anything if the filename is a symlink and resolves to a
	 directory. */
      else if (s == 0 && S_ISLNK (finfo.st_mode) &&
	       stat (filename, &finfo) == 0 && S_ISDIR (finfo.st_mode))
	;
#endif
d1159 1
a1159 1
	  if (rl_point == rl_end && temp_string_index)
d1166 1
a1166 1
      if (rl_point == rl_end && temp_string_index)
d1212 2
a1213 2
void
_rl_free_match_list (matches)
a1217 3
  if (matches == 0)
    return;

d1235 2
a1236 2
  rl_compentry_func_t *our_func;
  int start, end, delimiter, found_quote, i, nontrivial_lcd;
d1240 4
a1243 3
  RL_SETSTATE(RL_STATE_COMPLETING);

  set_completion_defaults (what_to_do);
d1248 1
a1248 1
		: rl_filename_completion_function;
d1258 1
a1258 1
    quote_char = _rl_find_completion_word (&found_quote, &delimiter);
a1264 3
  /* nontrivial_lcd is set if the common prefix adds something to the word
     being completed. */
  nontrivial_lcd = matches && strcmp (text, matches[0]) != 0;
d1269 1
a1269 1
      rl_ding ();
a1270 2
      completion_changed_buffer = 0;
      RL_UNSETSTATE(RL_STATE_COMPLETING);
d1274 5
d1281 1
a1281 1
     rl_filename_completion_function does this. */
d1283 1
d1287 1
a1287 1
      rl_ding ();
a1289 1
      RL_UNSETSTATE(RL_STATE_COMPLETING);
d1317 1
a1317 1
	    rl_ding ();	/* There are other matches remaining. */
d1320 1
a1320 1
	append_to_match (matches[0], delimiter, quote_char, nontrivial_lcd);
d1334 1
a1334 1
      rl_ding ();
a1335 1
      RL_UNSETSTATE(RL_STATE_COMPLETING);
d1339 1
a1339 1
  _rl_free_match_list (matches);
a1347 1
  RL_UNSETSTATE(RL_STATE_COMPLETING);
d1370 3
a1372 3
rl_completion_matches (text, entry_function)
     const char *text;
     rl_compentry_func_t *entry_function;
d1417 2
a1418 2
rl_username_completion_function (text, state)
     const char *text;
d1455 1
a1455 1
      value = (char *)xmalloc (2 + strlen (entry->pw_name));
d1474 2
a1475 2
rl_filename_completion_function (text, state)
     const char *text;
d1510 1
a1510 1
      if (dirname[0] == '/' && dirname[1] == '/' && ISALPHA ((unsigned char)dirname[2]) && dirname[3] == '/')
d1521 1
a1521 1
      else if (ISALPHA ((unsigned char)dirname[0]) && dirname[1] == ':')
a1544 3
      if (rl_directory_rewrite_hook)
	(*rl_directory_rewrite_hook) (&dirname);

d1568 2
a1569 3
      /* Special case for no filename.  If the user has disabled the
         `match-hidden-files' variable, skip filenames beginning with `.'.
	 All other entries except "." and ".." match. */
a1571 3
	  if (_rl_match_hidden_files == 0 && HIDDEN_FILE (entry->d_name))
	    continue;

d1631 1
a1631 1
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
d1644 1
a1644 1
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
a1645 3
	      /* Make sure that temp has a trailing slash here. */
	      if (users_dirname[dirlen - 1] != '/')
		temp[dirlen++] = '/';
d1670 1
a1670 1
  rl_compentry_func_t *our_func;
d1688 1
a1688 1
	_rl_free_match_list (matches);
d1694 3
a1696 1
      set_completion_defaults ('%');
d1700 1
a1700 1
			: rl_filename_completion_function;
d1710 1
a1710 1
	quote_char = _rl_find_completion_word (&found_quote, &delimiter);
d1719 5
d1726 1
a1726 1
	 rl_filename_completion_function does this. */
d1728 1
a1728 1

d1731 1
a1731 1
    	  rl_ding ();
d1752 1
a1752 1
      rl_ding ();
d1765 1
a1765 1
      rl_ding ();
d1771 1
a1771 2
      append_to_match (matches[match_list_index], delimiter, quote_char,
		       strcmp (orig_text, matches[match_list_index]));
@


1.4.22.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d52 12
a69 1
#include "rlmbutil.h"
a81 15
#ifdef HAVE_LSTAT
#  define LSTAT lstat
#else
#  define LSTAT stat
#endif

/* Unix version of a hidden file.  Could be different on other systems. */
#define HIDDEN_FILE(fname)	((fname)[0] == '.')

/* Most systems don't declare getpwent in <pwd.h> if _POSIX_SOURCE is
   defined. */
#if !defined (HAVE_GETPW_DECLS) || defined (_POSIX_SOURCE)
extern struct passwd *getpwent PARAMS((void));
#endif /* !HAVE_GETPW_DECLS || _POSIX_SOURCE */

d89 5
a93 1
rl_compdisp_func_t *rl_completion_display_matches_hook = (rl_compdisp_func_t *)NULL;
d99 1
a99 1
static int stat_char PARAMS((char *));
d102 2
a103 17
static char *rl_quote_filename PARAMS((char *, int, char *));

static void set_completion_defaults PARAMS((int));
static int get_y_or_n PARAMS((int));
static int _rl_internal_pager PARAMS((int));
static char *printable_part PARAMS((char *));
static int print_filename PARAMS((char *, char *));

static char **gen_completion_matches PARAMS((char *, int, int, rl_compentry_func_t *, int, int));

static char **remove_duplicate_matches PARAMS((char **));
static void insert_match PARAMS((char *, int, int, char *));
static int append_to_match PARAMS((char *, int, int, int));
static void insert_all_matches PARAMS((char **, int, char *));
static void display_matches PARAMS((char **));
static int compute_lcd_of_matches PARAMS((char **, int, const char *));
static int postprocess_matches PARAMS((char ***, int));
d105 6
a110 1
static char *make_quoted_replacement PARAMS((char *, int, char *));
a125 6
/* If non-zero, the symlinked directory completion behavior introduced in
   readline-4.2a is disabled, and symlinks that point to directories have
   a slash appended (subject to the value of _rl_complete_mark_directories).
   This is user-settable via the mark-symlinked-directories variable. */
int _rl_complete_mark_symlink_dirs = 0;

a136 4
/* If non-zero, don't match hidden files (filenames beginning with a `.' on
   Unix) when doing filename completion. */
int _rl_match_hidden_files = 1;

d149 1
a149 3
rl_icppfunc_t *rl_directory_completion_hook = (rl_icppfunc_t *)NULL;

rl_icppfunc_t *rl_directory_rewrite_hook = (rl_icppfunc_t *)NULL;
d155 1
a155 1
   NULL means to use rl_filename_completion_function (), the default filename
d157 1
a157 1
rl_compentry_func_t *rl_completion_entry_function = (rl_compentry_func_t *)NULL;
d166 1
a166 1
rl_completion_func_t *rl_attempted_completion_function = (rl_completion_func_t *)NULL;
a181 2
int _rl_page_completions = 1;

d185 1
a185 1
const char *rl_basic_word_break_characters = " \t\n\"\\'`@@$><=;|&{("; /* }) */
d188 1
a188 1
const char *rl_basic_quote_characters = "\"'";
d193 1
a193 1
const char *rl_completer_word_break_characters = (const char *)NULL;
d199 1
a199 1
const char *rl_completer_quote_characters = (const char *)NULL;
d202 1
a202 1
const char *rl_filename_quote_characters = (const char *)NULL;
d207 1
a207 1
const char *rl_special_prefixes = (const char *)NULL;
d233 1
a233 1
rl_compignore_func_t *rl_ignore_some_completions_function = (rl_compignore_func_t *)NULL;
d239 1
a239 1
rl_quote_func_t *rl_filename_quoting_function = rl_quote_filename;
d245 1
a245 1
rl_dequote_func_t *rl_filename_dequoting_function = (rl_dequote_func_t *)NULL;
d250 1
a250 6
rl_linebuf_func_t *rl_char_is_quoted_p = (rl_linebuf_func_t *)NULL;

/* If non-zero, the completion functions don't append anything except a
   possible closing quote.  This is set to 0 by rl_complete_internal and
   may be changed by an application-specific completion function. */
int rl_completion_suppress_append = 0;
a255 11
/* If non-zero, a slash will be appended to completed filenames that are
   symbolic links to directory names, subject to the value of the
   mark-directories variable (which is user-settable).  This exists so
   that application completion functions can override the user's preference
   (set via the mark-symlinked-directories variable) if appropriate.
   It's set to the value of _rl_complete_mark_symlink_dirs in
   rl_complete_internal before any application-specific completion
   function is called, so without that function doing anything, the user's
   preferences are honored. */
int rl_completion_mark_symlink_dirs;

d272 1
a272 1
   rl_completion_matches ()).  The default is to do filename completion. */
d278 1
a278 1
    return (_rl_insert_char (ignore, invoking_key));
a301 17
/* Return the correct value to pass to rl_complete_internal performing
   the same tests as rl_complete.  This allows consecutive calls to an
   application's completion function to list possible completions and for
   an application-specific completion function to honor the
   show-all-if-ambiguous readline variable. */
int
rl_completion_mode (cfunc)
     rl_command_func_t *cfunc;
{
  if (rl_last_func == cfunc && !completion_changed_buffer)
    return '?';
  else if (_rl_complete_show_all)
    return '!';
  else
    return TAB;
}

d308 5
a312 5
/* Set default values for readline word completion.  These are the variables
   that application completion functions can change or inspect. */
static void
set_completion_defaults (what_to_do)
     int what_to_do;
d314 1
a314 5
  /* Only the completion entry function can change these. */
  rl_filename_completion_desired = 0;
  rl_filename_quoting_desired = 1;
  rl_completion_type = what_to_do;
  rl_completion_suppress_append = 0;
d316 11
a326 2
  /* The completion entry function may optionally change this. */
  rl_completion_mark_symlink_dirs = _rl_complete_mark_symlink_dirs;
d331 1
a331 2
get_y_or_n (for_pager)
     int for_pager;
a336 1
      RL_SETSTATE(RL_STATE_MOREINPUT);
a337 2
      RL_UNSETSTATE(RL_STATE_MOREINPUT);

d344 1
a344 5
      if (for_pager && (c == NEWLINE || c == RETURN))
	return (2);
      if (for_pager && (c == 'q' || c == 'Q'))
	return (0);
      rl_ding ();
a347 18
static int
_rl_internal_pager (lines)
     int lines;
{
  int i;

  fprintf (rl_outstream, "--More--");
  fflush (rl_outstream);
  i = get_y_or_n (1);
  _rl_erase_entire_line ();
  if (i == 0)
    return -1;
  else if (i == 2)
    return (lines - 1);
  else
    return 0;
}

d408 1
a408 5
   final slash.  Otherwise, we return what we were passed.  Since
   printing empty strings is not very informative, if we're doing
   filename completion, and the basename is the empty string, we look
   for the previous slash and return the portion following that.  If
   there's no previous slash, we just return what we were passed. */
d413 1
a413 4
  char *temp, *x;

  if (rl_filename_completion_desired == 0)	/* don't need to do anything */
    return (pathname);
d415 1
a415 1
  temp = strrchr (pathname, '/');
d417 1
a417 1
  if (temp == 0 && ISALPHA ((unsigned char)pathname[0]) && pathname[1] == ':')
d420 1
a420 16

  if (temp == 0 || *temp == '\0')
    return (pathname);
  /* If the basename is NULL, we might have a pathname like '/usr/src/'.
     Look for a previous slash and, if one is found, return the portion
     following that slash.  If there's no previous slash, just return the
     pathname we were passed. */
  else if (temp[1] == '\0')
    {
      for (x = temp - 1; x > pathname; x--)
        if (*x == '/')
          break;
      return ((*x == '/') ? x + 1 : pathname);
    }
  else
    return ++temp;
d491 1
a491 1
	  new_full_pathname = (char *)xmalloc (slen + tlen + 2);
d526 1
a526 1
  r = (char *)xmalloc (strlen (s) + 2);
d537 1
a537 1
   rl_completer_quote_characters).  First we try to find an unclosed
d549 2
a550 2
char
_rl_find_completion_word (fp, dp)
d574 1
a574 5
	  /* Shell-like semantics for single quotes -- don't allow backslash
	     to quote anything in single quotes, especially not the closing
	     quote.  If you don't like this, take out the check on the value
	     of quote_char. */
	  if (quote_char != '\'' && rl_line_buffer[scan] == '\\')
a600 2
	      else
		found_quote |= RL_QF_OTHER_QUOTE;      
a609 3
#if defined (HANDLE_MULTIBYTE)
      while (rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_ANY))
#else
a610 1
#endif
d674 1
a674 1
     rl_compentry_func_t *our_func;
d698 1
a698 1
  if (found_quote && our_func == rl_filename_completion_function &&
d706 1
a706 1
  matches = rl_completion_matches (text, our_func);
d778 1
a778 1
     const char *text;
a781 5
#if defined (HANDLE_MULTIBYTE)
  int v;
  mbstate_t ps1, ps2;
  wchar_t wc1, wc2;
#endif
a794 7
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  memset (&ps1, 0, sizeof (mbstate_t));
	  memset (&ps2, 0, sizeof (mbstate_t));
	}
#endif
a800 14
#if defined (HANDLE_MULTIBYTE)
	    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	      {
		v = mbrtowc (&wc1, match_list[i]+si, strlen (match_list[i]+si), &ps1);
		mbrtowc (&wc2, match_list[i+1]+si, strlen (match_list[i+1]+si), &ps2);
		wc1 = towlower (wc1);
		wc2 = towlower (wc2);
		if (wc1 != wc2)
		  break;
		else if (v > 1)
		  si += v - 1;
	      }
	    else
#endif
a809 11
#if defined (HANDLE_MULTIBYTE)
	    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	      {
		mbstate_t ps_back = ps1;
		if (!_rl_compare_chars (match_list[i], si, &ps1, match_list[i+1], si, &ps2))
		  break;
		else if ((v = _rl_get_char_len (&match_list[i][si], &ps_back)) > 1)
		  si += v - 1;
	      }
	    else
#endif
d823 1
a823 1
      match_list[0] = (char *)xmalloc (strlen (text) + 1);
d828 2
a829 31
      match_list[0] = (char *)xmalloc (low + 1);

      /* XXX - this might need changes in the presence of multibyte chars */

      /* If we are ignoring case, try to preserve the case of the string
	 the user typed in the face of multiple matches differing in case. */
      if (_rl_completion_case_fold)
	{
	  /* sort the list to get consistent answers. */
	  qsort (match_list+1, matches, sizeof(char *), (QSFUNC *)_rl_qsort_string_compare);

	  si = strlen (text);
	  if (si <= low)
	    {
	      for (i = 1; i <= matches; i++)
		if (strncmp (match_list[i], text, si) == 0)
		  {
		    strncpy (match_list[0], match_list[i], low);
		    break;
		  }
	      /* no casematch, use first entry */
	      if (i > matches)
		strncpy (match_list[0], match_list[1], low);
	    }
	  else
	    /* otherwise, just use the text the user typed. */
	    strncpy (match_list[0], text, low);
	}
      else
        strncpy (match_list[0], match_list[1], low);

a845 3
  if (matches == 0)
    return 0;

d898 1
a898 1
  int count, limit, printed_len, lines;
d904 2
a905 2
  limit = _rl_screenwidth / max;
  if (limit != 1 && (limit * max == _rl_screenwidth))
d908 1
a908 1
  /* Avoid a possible floating exception.  If max > _rl_screenwidth,
d924 1
a924 1
  rl_crlf ();
a925 1
  lines = 0;
d946 1
a946 8
	  rl_crlf ();
	  lines++;
	  if (_rl_page_completions && lines >= (_rl_screenheight - 1) && i < count)
	    {
	      lines = _rl_internal_pager (lines);
	      if (lines < 0)
		return;
	    }
d960 1
a960 10
		{
		  rl_crlf ();
		  lines++;
		  if (_rl_page_completions && lines >= _rl_screenheight - 1)
		    {
		      lines = _rl_internal_pager (lines);
		      if (lines < 0)
			return;
		    }
		}
d966 1
a966 1
      rl_crlf ();
d995 1
a995 1
      rl_crlf ();
d997 1
a997 1
      rl_crlf ();
d1029 1
a1029 1
      rl_crlf ();
d1032 1
a1032 1
      if (get_y_or_n (0) == 0)
d1034 1
a1034 1
	  rl_crlf ();
d1082 1
a1082 1
			? (_rl_strpbrk (match, rl_filename_quote_characters) != 0)
d1128 1
a1128 7
   appended.  If NONTRIVIAL_MATCH is set, we test for a symlink (if the OS
   has them) and don't add a suffix for a symlink to a directory.  A
   nontrivial match is one that actually adds to the word being completed.
   The variable rl_completion_mark_symlink_dirs controls this behavior
   (it's initially set to the what the user has chosen, indicated by the
   value of _rl_complete_mark_symlink_dirs, but may be modified by an
   application's completion function). */
d1130 1
a1130 1
append_to_match (text, delimiter, quote_char, nontrivial_match)
d1132 1
a1132 1
     int delimiter, quote_char, nontrivial_match;
d1135 1
a1135 1
  int temp_string_index, s;
d1144 1
a1144 1
  else if (rl_completion_suppress_append == 0 && rl_completion_append_character)
d1152 1
a1152 4
      s = (nontrivial_match && rl_completion_mark_symlink_dirs == 0)
		? LSTAT (filename, &finfo)
		: stat (filename, &finfo);
      if (s == 0 && S_ISDIR (finfo.st_mode))
d1154 2
a1155 10
	  if (_rl_complete_mark_directories)
	    {
	      /* This is clumsy.  Avoid putting in a double slash if point
		 is at the end of the line and the previous character is a
		 slash. */
	      if (rl_point && rl_line_buffer[rl_point] == '\0' && rl_line_buffer[rl_point - 1] == '/')
		;
	      else if (rl_line_buffer[rl_point] != '/')
		rl_insert_text ("/");
	    }
a1156 7
#ifdef S_ISLNK
      /* Don't add anything if the filename is a symlink and resolves to a
	 directory. */
      else if (s == 0 && S_ISLNK (finfo.st_mode) &&
	       stat (filename, &finfo) == 0 && S_ISDIR (finfo.st_mode))
	;
#endif
d1159 1
a1159 1
	  if (rl_point == rl_end && temp_string_index)
d1166 1
a1166 1
      if (rl_point == rl_end && temp_string_index)
d1212 2
a1213 2
void
_rl_free_match_list (matches)
a1217 3
  if (matches == 0)
    return;

d1235 2
a1236 2
  rl_compentry_func_t *our_func;
  int start, end, delimiter, found_quote, i, nontrivial_lcd;
d1240 4
a1243 3
  RL_SETSTATE(RL_STATE_COMPLETING);

  set_completion_defaults (what_to_do);
d1248 1
a1248 1
		: rl_filename_completion_function;
d1258 1
a1258 1
    quote_char = _rl_find_completion_word (&found_quote, &delimiter);
a1264 3
  /* nontrivial_lcd is set if the common prefix adds something to the word
     being completed. */
  nontrivial_lcd = matches && strcmp (text, matches[0]) != 0;
d1269 1
a1269 1
      rl_ding ();
a1270 2
      completion_changed_buffer = 0;
      RL_UNSETSTATE(RL_STATE_COMPLETING);
d1274 5
d1281 1
a1281 1
     rl_filename_completion_function does this. */
d1283 1
d1287 1
a1287 1
      rl_ding ();
a1289 1
      RL_UNSETSTATE(RL_STATE_COMPLETING);
d1317 1
a1317 1
	    rl_ding ();	/* There are other matches remaining. */
d1320 1
a1320 1
	append_to_match (matches[0], delimiter, quote_char, nontrivial_lcd);
d1334 1
a1334 1
      rl_ding ();
a1335 1
      RL_UNSETSTATE(RL_STATE_COMPLETING);
d1339 1
a1339 1
  _rl_free_match_list (matches);
a1347 1
  RL_UNSETSTATE(RL_STATE_COMPLETING);
d1370 3
a1372 3
rl_completion_matches (text, entry_function)
     const char *text;
     rl_compentry_func_t *entry_function;
d1417 2
a1418 2
rl_username_completion_function (text, state)
     const char *text;
d1455 1
a1455 1
      value = (char *)xmalloc (2 + strlen (entry->pw_name));
d1474 2
a1475 2
rl_filename_completion_function (text, state)
     const char *text;
d1510 1
a1510 1
      if (dirname[0] == '/' && dirname[1] == '/' && ISALPHA ((unsigned char)dirname[2]) && dirname[3] == '/')
d1521 1
a1521 1
      else if (ISALPHA ((unsigned char)dirname[0]) && dirname[1] == ':')
a1544 3
      if (rl_directory_rewrite_hook)
	(*rl_directory_rewrite_hook) (&dirname);

d1568 2
a1569 3
      /* Special case for no filename.  If the user has disabled the
         `match-hidden-files' variable, skip filenames beginning with `.'.
	 All other entries except "." and ".." match. */
a1571 3
	  if (_rl_match_hidden_files == 0 && HIDDEN_FILE (entry->d_name))
	    continue;

d1631 1
a1631 1
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
d1644 1
a1644 1
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
a1645 3
	      /* Make sure that temp has a trailing slash here. */
	      if (users_dirname[dirlen - 1] != '/')
		temp[dirlen++] = '/';
d1670 1
a1670 1
  rl_compentry_func_t *our_func;
d1688 1
a1688 1
	_rl_free_match_list (matches);
d1694 3
a1696 1
      set_completion_defaults ('%');
d1700 1
a1700 1
			: rl_filename_completion_function;
d1710 1
a1710 1
	quote_char = _rl_find_completion_word (&found_quote, &delimiter);
d1719 5
d1726 1
a1726 1
	 rl_filename_completion_function does this. */
d1728 1
a1728 1

d1731 1
a1731 1
    	  rl_ding ();
d1752 1
a1752 1
      rl_ding ();
d1765 1
a1765 1
      rl_ding ();
d1771 1
a1771 2
      append_to_match (matches[match_list_index], delimiter, quote_char,
		       strcmp (orig_text, matches[match_list_index]));
@


1.4.16.1
log
@2002-08-24  Elena Zannoni  <ezannoni@@redhat.com>

        Import of readline 4.3:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@d52 12
a69 1
#include "rlmbutil.h"
a81 15
#ifdef HAVE_LSTAT
#  define LSTAT lstat
#else
#  define LSTAT stat
#endif

/* Unix version of a hidden file.  Could be different on other systems. */
#define HIDDEN_FILE(fname)	((fname)[0] == '.')

/* Most systems don't declare getpwent in <pwd.h> if _POSIX_SOURCE is
   defined. */
#if !defined (HAVE_GETPW_DECLS) || defined (_POSIX_SOURCE)
extern struct passwd *getpwent PARAMS((void));
#endif /* !HAVE_GETPW_DECLS || _POSIX_SOURCE */

d89 5
a93 1
rl_compdisp_func_t *rl_completion_display_matches_hook = (rl_compdisp_func_t *)NULL;
d99 1
a99 1
static int stat_char PARAMS((char *));
d102 2
a103 17
static char *rl_quote_filename PARAMS((char *, int, char *));

static void set_completion_defaults PARAMS((int));
static int get_y_or_n PARAMS((int));
static int _rl_internal_pager PARAMS((int));
static char *printable_part PARAMS((char *));
static int print_filename PARAMS((char *, char *));

static char **gen_completion_matches PARAMS((char *, int, int, rl_compentry_func_t *, int, int));

static char **remove_duplicate_matches PARAMS((char **));
static void insert_match PARAMS((char *, int, int, char *));
static int append_to_match PARAMS((char *, int, int, int));
static void insert_all_matches PARAMS((char **, int, char *));
static void display_matches PARAMS((char **));
static int compute_lcd_of_matches PARAMS((char **, int, const char *));
static int postprocess_matches PARAMS((char ***, int));
d105 6
a110 1
static char *make_quoted_replacement PARAMS((char *, int, char *));
a125 6
/* If non-zero, the symlinked directory completion behavior introduced in
   readline-4.2a is disabled, and symlinks that point to directories have
   a slash appended (subject to the value of _rl_complete_mark_directories).
   This is user-settable via the mark-symlinked-directories variable. */
int _rl_complete_mark_symlink_dirs = 0;

a136 4
/* If non-zero, don't match hidden files (filenames beginning with a `.' on
   Unix) when doing filename completion. */
int _rl_match_hidden_files = 1;

d149 1
a149 3
rl_icppfunc_t *rl_directory_completion_hook = (rl_icppfunc_t *)NULL;

rl_icppfunc_t *rl_directory_rewrite_hook = (rl_icppfunc_t *)NULL;
d155 1
a155 1
   NULL means to use rl_filename_completion_function (), the default filename
d157 1
a157 1
rl_compentry_func_t *rl_completion_entry_function = (rl_compentry_func_t *)NULL;
d166 1
a166 1
rl_completion_func_t *rl_attempted_completion_function = (rl_completion_func_t *)NULL;
a181 2
int _rl_page_completions = 1;

d185 1
a185 1
const char *rl_basic_word_break_characters = " \t\n\"\\'`@@$><=;|&{("; /* }) */
d188 1
a188 1
const char *rl_basic_quote_characters = "\"'";
d193 1
a193 1
const char *rl_completer_word_break_characters = (const char *)NULL;
d199 1
a199 1
const char *rl_completer_quote_characters = (const char *)NULL;
d202 1
a202 1
const char *rl_filename_quote_characters = (const char *)NULL;
d207 1
a207 1
const char *rl_special_prefixes = (const char *)NULL;
d233 1
a233 1
rl_compignore_func_t *rl_ignore_some_completions_function = (rl_compignore_func_t *)NULL;
d239 1
a239 1
rl_quote_func_t *rl_filename_quoting_function = rl_quote_filename;
d245 1
a245 1
rl_dequote_func_t *rl_filename_dequoting_function = (rl_dequote_func_t *)NULL;
d250 1
a250 6
rl_linebuf_func_t *rl_char_is_quoted_p = (rl_linebuf_func_t *)NULL;

/* If non-zero, the completion functions don't append anything except a
   possible closing quote.  This is set to 0 by rl_complete_internal and
   may be changed by an application-specific completion function. */
int rl_completion_suppress_append = 0;
a255 11
/* If non-zero, a slash will be appended to completed filenames that are
   symbolic links to directory names, subject to the value of the
   mark-directories variable (which is user-settable).  This exists so
   that application completion functions can override the user's preference
   (set via the mark-symlinked-directories variable) if appropriate.
   It's set to the value of _rl_complete_mark_symlink_dirs in
   rl_complete_internal before any application-specific completion
   function is called, so without that function doing anything, the user's
   preferences are honored. */
int rl_completion_mark_symlink_dirs;

d272 1
a272 1
   rl_completion_matches ()).  The default is to do filename completion. */
d278 1
a278 1
    return (_rl_insert_char (ignore, invoking_key));
a301 17
/* Return the correct value to pass to rl_complete_internal performing
   the same tests as rl_complete.  This allows consecutive calls to an
   application's completion function to list possible completions and for
   an application-specific completion function to honor the
   show-all-if-ambiguous readline variable. */
int
rl_completion_mode (cfunc)
     rl_command_func_t *cfunc;
{
  if (rl_last_func == cfunc && !completion_changed_buffer)
    return '?';
  else if (_rl_complete_show_all)
    return '!';
  else
    return TAB;
}

d308 5
a312 5
/* Set default values for readline word completion.  These are the variables
   that application completion functions can change or inspect. */
static void
set_completion_defaults (what_to_do)
     int what_to_do;
d314 1
a314 5
  /* Only the completion entry function can change these. */
  rl_filename_completion_desired = 0;
  rl_filename_quoting_desired = 1;
  rl_completion_type = what_to_do;
  rl_completion_suppress_append = 0;
d316 11
a326 2
  /* The completion entry function may optionally change this. */
  rl_completion_mark_symlink_dirs = _rl_complete_mark_symlink_dirs;
d331 1
a331 2
get_y_or_n (for_pager)
     int for_pager;
a336 1
      RL_SETSTATE(RL_STATE_MOREINPUT);
a337 2
      RL_UNSETSTATE(RL_STATE_MOREINPUT);

d344 1
a344 5
      if (for_pager && (c == NEWLINE || c == RETURN))
	return (2);
      if (for_pager && (c == 'q' || c == 'Q'))
	return (0);
      rl_ding ();
a347 18
static int
_rl_internal_pager (lines)
     int lines;
{
  int i;

  fprintf (rl_outstream, "--More--");
  fflush (rl_outstream);
  i = get_y_or_n (1);
  _rl_erase_entire_line ();
  if (i == 0)
    return -1;
  else if (i == 2)
    return (lines - 1);
  else
    return 0;
}

d408 1
a408 5
   final slash.  Otherwise, we return what we were passed.  Since
   printing empty strings is not very informative, if we're doing
   filename completion, and the basename is the empty string, we look
   for the previous slash and return the portion following that.  If
   there's no previous slash, we just return what we were passed. */
d413 1
a413 4
  char *temp, *x;

  if (rl_filename_completion_desired == 0)	/* don't need to do anything */
    return (pathname);
d415 1
a415 1
  temp = strrchr (pathname, '/');
d417 1
a417 1
  if (temp == 0 && ISALPHA ((unsigned char)pathname[0]) && pathname[1] == ':')
d420 1
a420 16

  if (temp == 0 || *temp == '\0')
    return (pathname);
  /* If the basename is NULL, we might have a pathname like '/usr/src/'.
     Look for a previous slash and, if one is found, return the portion
     following that slash.  If there's no previous slash, just return the
     pathname we were passed. */
  else if (temp[1] == '\0')
    {
      for (x = temp - 1; x > pathname; x--)
        if (*x == '/')
          break;
      return ((*x == '/') ? x + 1 : pathname);
    }
  else
    return ++temp;
d491 1
a491 1
	  new_full_pathname = (char *)xmalloc (slen + tlen + 2);
d526 1
a526 1
  r = (char *)xmalloc (strlen (s) + 2);
d537 1
a537 1
   rl_completer_quote_characters).  First we try to find an unclosed
d549 2
a550 2
char
_rl_find_completion_word (fp, dp)
d574 1
a574 5
	  /* Shell-like semantics for single quotes -- don't allow backslash
	     to quote anything in single quotes, especially not the closing
	     quote.  If you don't like this, take out the check on the value
	     of quote_char. */
	  if (quote_char != '\'' && rl_line_buffer[scan] == '\\')
a600 2
	      else
		found_quote |= RL_QF_OTHER_QUOTE;      
a609 3
#if defined (HANDLE_MULTIBYTE)
      while (rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_ANY))
#else
a610 1
#endif
d674 1
a674 1
     rl_compentry_func_t *our_func;
d698 1
a698 1
  if (found_quote && our_func == rl_filename_completion_function &&
d706 1
a706 1
  matches = rl_completion_matches (text, our_func);
d778 1
a778 1
     const char *text;
a781 5
#if defined (HANDLE_MULTIBYTE)
  int v;
  mbstate_t ps1, ps2;
  wchar_t wc1, wc2;
#endif
a794 7
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  memset (&ps1, 0, sizeof (mbstate_t));
	  memset (&ps2, 0, sizeof (mbstate_t));
	}
#endif
a800 14
#if defined (HANDLE_MULTIBYTE)
	    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	      {
		v = mbrtowc (&wc1, match_list[i]+si, strlen (match_list[i]+si), &ps1);
		mbrtowc (&wc2, match_list[i+1]+si, strlen (match_list[i+1]+si), &ps2);
		wc1 = towlower (wc1);
		wc2 = towlower (wc2);
		if (wc1 != wc2)
		  break;
		else if (v > 1)
		  si += v - 1;
	      }
	    else
#endif
a809 11
#if defined (HANDLE_MULTIBYTE)
	    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	      {
		mbstate_t ps_back = ps1;
		if (!_rl_compare_chars (match_list[i], si, &ps1, match_list[i+1], si, &ps2))
		  break;
		else if ((v = _rl_get_char_len (&match_list[i][si], &ps_back)) > 1)
		  si += v - 1;
	      }
	    else
#endif
d823 1
a823 1
      match_list[0] = (char *)xmalloc (strlen (text) + 1);
d828 2
a829 31
      match_list[0] = (char *)xmalloc (low + 1);

      /* XXX - this might need changes in the presence of multibyte chars */

      /* If we are ignoring case, try to preserve the case of the string
	 the user typed in the face of multiple matches differing in case. */
      if (_rl_completion_case_fold)
	{
	  /* sort the list to get consistent answers. */
	  qsort (match_list+1, matches, sizeof(char *), (QSFUNC *)_rl_qsort_string_compare);

	  si = strlen (text);
	  if (si <= low)
	    {
	      for (i = 1; i <= matches; i++)
		if (strncmp (match_list[i], text, si) == 0)
		  {
		    strncpy (match_list[0], match_list[i], low);
		    break;
		  }
	      /* no casematch, use first entry */
	      if (i > matches)
		strncpy (match_list[0], match_list[1], low);
	    }
	  else
	    /* otherwise, just use the text the user typed. */
	    strncpy (match_list[0], text, low);
	}
      else
        strncpy (match_list[0], match_list[1], low);

a845 3
  if (matches == 0)
    return 0;

d898 1
a898 1
  int count, limit, printed_len, lines;
d904 2
a905 2
  limit = _rl_screenwidth / max;
  if (limit != 1 && (limit * max == _rl_screenwidth))
d908 1
a908 1
  /* Avoid a possible floating exception.  If max > _rl_screenwidth,
d924 1
a924 1
  rl_crlf ();
a925 1
  lines = 0;
d946 1
a946 8
	  rl_crlf ();
	  lines++;
	  if (_rl_page_completions && lines >= (_rl_screenheight - 1) && i < count)
	    {
	      lines = _rl_internal_pager (lines);
	      if (lines < 0)
		return;
	    }
d960 1
a960 10
		{
		  rl_crlf ();
		  lines++;
		  if (_rl_page_completions && lines >= _rl_screenheight - 1)
		    {
		      lines = _rl_internal_pager (lines);
		      if (lines < 0)
			return;
		    }
		}
d966 1
a966 1
      rl_crlf ();
d995 1
a995 1
      rl_crlf ();
d997 1
a997 1
      rl_crlf ();
d1029 1
a1029 1
      rl_crlf ();
d1032 1
a1032 1
      if (get_y_or_n (0) == 0)
d1034 1
a1034 1
	  rl_crlf ();
d1082 1
a1082 1
			? (_rl_strpbrk (match, rl_filename_quote_characters) != 0)
d1128 1
a1128 7
   appended.  If NONTRIVIAL_MATCH is set, we test for a symlink (if the OS
   has them) and don't add a suffix for a symlink to a directory.  A
   nontrivial match is one that actually adds to the word being completed.
   The variable rl_completion_mark_symlink_dirs controls this behavior
   (it's initially set to the what the user has chosen, indicated by the
   value of _rl_complete_mark_symlink_dirs, but may be modified by an
   application's completion function). */
d1130 1
a1130 1
append_to_match (text, delimiter, quote_char, nontrivial_match)
d1132 1
a1132 1
     int delimiter, quote_char, nontrivial_match;
d1135 1
a1135 1
  int temp_string_index, s;
d1144 1
a1144 1
  else if (rl_completion_suppress_append == 0 && rl_completion_append_character)
d1152 1
a1152 4
      s = (nontrivial_match && rl_completion_mark_symlink_dirs == 0)
		? LSTAT (filename, &finfo)
		: stat (filename, &finfo);
      if (s == 0 && S_ISDIR (finfo.st_mode))
d1154 2
a1155 10
	  if (_rl_complete_mark_directories)
	    {
	      /* This is clumsy.  Avoid putting in a double slash if point
		 is at the end of the line and the previous character is a
		 slash. */
	      if (rl_point && rl_line_buffer[rl_point] == '\0' && rl_line_buffer[rl_point - 1] == '/')
		;
	      else if (rl_line_buffer[rl_point] != '/')
		rl_insert_text ("/");
	    }
a1156 7
#ifdef S_ISLNK
      /* Don't add anything if the filename is a symlink and resolves to a
	 directory. */
      else if (s == 0 && S_ISLNK (finfo.st_mode) &&
	       stat (filename, &finfo) == 0 && S_ISDIR (finfo.st_mode))
	;
#endif
d1159 1
a1159 1
	  if (rl_point == rl_end && temp_string_index)
d1166 1
a1166 1
      if (rl_point == rl_end && temp_string_index)
d1212 2
a1213 2
void
_rl_free_match_list (matches)
a1217 3
  if (matches == 0)
    return;

d1235 2
a1236 2
  rl_compentry_func_t *our_func;
  int start, end, delimiter, found_quote, i, nontrivial_lcd;
d1240 4
a1243 3
  RL_SETSTATE(RL_STATE_COMPLETING);

  set_completion_defaults (what_to_do);
d1248 1
a1248 1
		: rl_filename_completion_function;
d1258 1
a1258 1
    quote_char = _rl_find_completion_word (&found_quote, &delimiter);
a1264 3
  /* nontrivial_lcd is set if the common prefix adds something to the word
     being completed. */
  nontrivial_lcd = matches && strcmp (text, matches[0]) != 0;
d1269 1
a1269 1
      rl_ding ();
a1270 2
      completion_changed_buffer = 0;
      RL_UNSETSTATE(RL_STATE_COMPLETING);
d1274 5
d1281 1
a1281 1
     rl_filename_completion_function does this. */
d1283 1
d1287 1
a1287 1
      rl_ding ();
a1289 1
      RL_UNSETSTATE(RL_STATE_COMPLETING);
d1317 1
a1317 1
	    rl_ding ();	/* There are other matches remaining. */
d1320 1
a1320 1
	append_to_match (matches[0], delimiter, quote_char, nontrivial_lcd);
d1334 1
a1334 1
      rl_ding ();
a1335 1
      RL_UNSETSTATE(RL_STATE_COMPLETING);
d1339 1
a1339 1
  _rl_free_match_list (matches);
a1347 1
  RL_UNSETSTATE(RL_STATE_COMPLETING);
d1370 3
a1372 3
rl_completion_matches (text, entry_function)
     const char *text;
     rl_compentry_func_t *entry_function;
d1417 2
a1418 2
rl_username_completion_function (text, state)
     const char *text;
d1455 1
a1455 1
      value = (char *)xmalloc (2 + strlen (entry->pw_name));
d1474 2
a1475 2
rl_filename_completion_function (text, state)
     const char *text;
d1510 1
a1510 1
      if (dirname[0] == '/' && dirname[1] == '/' && ISALPHA ((unsigned char)dirname[2]) && dirname[3] == '/')
d1521 1
a1521 1
      else if (ISALPHA ((unsigned char)dirname[0]) && dirname[1] == ':')
a1544 3
      if (rl_directory_rewrite_hook)
	(*rl_directory_rewrite_hook) (&dirname);

d1568 2
a1569 3
      /* Special case for no filename.  If the user has disabled the
         `match-hidden-files' variable, skip filenames beginning with `.'.
	 All other entries except "." and ".." match. */
a1571 3
	  if (_rl_match_hidden_files == 0 && HIDDEN_FILE (entry->d_name))
	    continue;

d1631 1
a1631 1
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
d1644 1
a1644 1
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
a1645 3
	      /* Make sure that temp has a trailing slash here. */
	      if (users_dirname[dirlen - 1] != '/')
		temp[dirlen++] = '/';
d1670 1
a1670 1
  rl_compentry_func_t *our_func;
d1688 1
a1688 1
	_rl_free_match_list (matches);
d1694 3
a1696 1
      set_completion_defaults ('%');
d1700 1
a1700 1
			: rl_filename_completion_function;
d1710 1
a1710 1
	quote_char = _rl_find_completion_word (&found_quote, &delimiter);
d1719 5
d1726 1
a1726 1
	 rl_filename_completion_function does this. */
d1728 1
a1728 1

d1731 1
a1731 1
    	  rl_ding ();
d1752 1
a1752 1
      rl_ding ();
d1765 1
a1765 1
      rl_ding ();
d1771 1
a1771 2
      append_to_match (matches[match_list_index], delimiter, quote_char,
		       strcmp (orig_text, matches[match_list_index]));
@


1.3
log
@Dummy commit before importof 4.1 version
@
text
@d10 1
a10 1
   as published by the Free Software Foundation; either version 1, or
d21 1
a21 1
   675 Mass Ave, Cambridge, MA 02139, USA. */
d73 2
d76 5
a80 13
extern char *tilde_expand ();
extern char *rl_copy_text ();
extern void _rl_abort_internal ();
extern int _rl_qsort_string_compare ();
extern void _rl_replace_text ();

extern Function *rl_last_func;
extern int rl_editing_mode;
extern int screenwidth;

extern void _rl_move_vert ();
extern int _rl_vis_botlin;
extern int rl_display_fixed;
d92 2
a93 2
char *filename_completion_function ();
char **completion_matches ();
d99 1
a99 1
static int stat_char ();
d102 2
a103 9
static char *rl_quote_filename ();
static char *rl_strpbrk ();

static char **remove_duplicate_matches ();
static void insert_match ();
static int append_to_match ();
static void insert_all_matches ();
static void display_matches ();
static int compute_lcd_of_matches ();
d105 6
a110 1
extern char *xmalloc (), *xrealloc ();
d131 3
d135 1
d416 4
d480 6
a485 1
	  s = tilde_expand (full_pathname);
d635 10
a644 7
     if it is found in rl_completer_word_break_characters. */
  if (rl_char_is_quoted_p)
    isbrk = (found_quote == 0 ||
 		(*rl_char_is_quoted_p) (rl_line_buffer, rl_point) == 0) &&
	      strchr (rl_completer_word_break_characters, scan) != 0;
  else
    isbrk = strchr (rl_completer_word_break_characters, scan) != 0;
d646 14
a659 11
  if (isbrk)
    {
      /* If the character that caused the word break was a quoting
	 character, then remember it as the delimiter. */
      if (rl_basic_quote_characters && strchr (rl_basic_quote_characters, scan) && (end - rl_point) > 1)
	delimiter = scan;

      /* If the character isn't needed to determine something special
	 about what kind of completion to perform, then advance past it. */
      if (rl_special_prefixes == 0 || strchr (rl_special_prefixes, scan) == 0)
	rl_point++;
d729 1
a729 1
    qsort (matches+1, i-1, sizeof (char *), _rl_qsort_string_compare);
d922 1
a922 1
    qsort (matches + 1, len, sizeof (char *), _rl_qsort_string_compare);
d1423 1
a1423 1
#else /* !__WIN32__ && !__OPENNT */
d1466 1
a1466 1
#endif /* !__GO32__ */
d1508 6
d1519 7
a1525 7
#if defined (__WIN32__) || defined (__OPENNT) || defined (__MSDOS__)
      /* Handle the drive-relative names "d:foo/bar".  */
      else if (dirname[1] == ':')
	{
	  strcpy (filename, dirname + 2);
	  dirname[2] = '\0';
	}
d1688 1
a1688 5
	{
	  for (match_list_index = 0; matches[match_list_index]; match_list_index++)
	    free (matches[match_list_index]);
	  free (matches);
	}
@


1.2
log
@(username_completion_function) [__GO32__]: Don't bypass getpw* calls.
(filename_completion_function): Handle drive-relative file names d:foo.
@
text
@@


1.1
log
@Initial revision
@
text
@d88 9
d686 1
d695 1
a695 1
  matches = completion_matches (text, our_func);
d826 1
a826 2
postprocess_matches (text, matchesp, matching_filenames)
     char *text;
a856 1
	  ding ();
d868 1
a868 1
	      compute_lcd_of_matches (matches, i - 1, text);
d878 6
a883 2
static void
display_matches (matches)
d885 1
d887 1
a887 1
  int len, count, limit, max, printed_len;
a890 52
  /* Move to the last visible line of a possibly-multiple-line command. */
  _rl_move_vert (_rl_vis_botlin);

  /* Handle simple case first.  What if there is only one answer? */
  if (matches[1] == 0)
    {
      temp = printable_part (matches[0]);
      crlf ();
      print_filename (temp, matches[0]);
      crlf ();
#if 0
      rl_on_new_line ();
#else
      rl_forced_update_display ();
      rl_display_fixed = 1;
#endif
      return;
    }

  /* There is more than one answer.  Find out how many there are,
     and find the maximum printed length of a single entry. */
  for (max = 0, i = 1; matches[i]; i++)
    {
      temp = printable_part (matches[i]);
      len = strlen (temp);

      if (len > max)
	max = len;
    }

  len = i - 1;

  /* If there are many items, then ask the user if she really wants to
     see them all. */
  if (len >= rl_completion_query_items)
    {
      crlf ();
      fprintf (rl_outstream, "Display all %d possibilities? (y or n)", len);
      fflush (rl_outstream);
      if (get_y_or_n () == 0)
	{
	  crlf ();
#if 0
	  rl_on_new_line ();
#else
	  rl_forced_update_display ();
	  rl_display_fixed = 1;
#endif
	  return;
	}
    }

d957 76
a1033 3
#if 0
  rl_on_new_line ();
#else
a1035 1
#endif
d1062 2
a1063 5
#if defined (SHELL)
    should_quote = should_quote && (!qc || !*qc || *qc == '"' || *qc == '\'');
#else /* !SHELL */
    should_quote = should_quote && (!qc || !*qc);
#endif /* !SHELL */
d1201 11
d1254 1
a1259 1
      free (text);
d1263 1
d1267 8
a1274 1
  if (postprocess_matches (text, &matches, i) == 0)
d1276 1
d1278 1
a1278 1
      free (text);
a1281 2
  free (text);

d1328 1
a1328 3
  for (i = 0; matches[i]; i++)
    free (matches[i]);
  free (matches);
d1407 1
a1408 1
     char *text;
d1410 1
a1410 1
#if defined (__GO32__) || defined (__WIN32__)
d1412 1
a1412 1
#else /* !__GO32__ */
d1464 1
a1465 1
     char *text;
d1502 8
d1631 1
a1631 1
	  strcpy (temp + dirlen, entry->d_name); /* strcat (temp, entry->d_name); */
d1706 1
d1710 7
a1716 1
      if (matches == 0 || postprocess_matches (orig_text, &matches, matching_filenames) == 0)
d1750 1
a1750 1
  if (match_list_index == 0)
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-08-02 snapshot
@
text
@a87 9
/* If non-zero, then this is the address of a function to call when
   completing a word would normally display the list of possible matches.
   This function is called instead of actually doing the display.
   It takes three arguments: (char **matches, int num_matches, int max_length)
   where MATCHES is the array of strings that matched, NUM_MATCHES is the
   number of strings in that array, and MAX_LENGTH is the length of the
   longest string in that array. */
VFunction *rl_completion_display_matches_hook = (VFunction *)NULL;

a676 1

d685 1
a685 1
  matches = completion_matches (text, (CPFunction *)our_func);
d816 2
a817 1
postprocess_matches (matchesp, matching_filenames)
d848 1
d860 1
a860 1
	      compute_lcd_of_matches (matches, i - 1, t);
d870 2
a871 6
/* A convenience function for displaying a list of strings in
   columnar format on readline's output stream.  MATCHES is the list
   of strings, in argv format, LEN is the number of strings in MATCHES,
   and MAX is the length of the longest string in MATCHES. */
void
rl_display_match_list (matches, len, max)
a872 1
     int len, max;
d874 1
a874 1
  int count, limit, printed_len;
d878 52
a995 76
}

/* Display MATCHES, a list of matching filenames in argv format.  This
   handles the simple case -- a single match -- first.  If there is more
   than one match, we compute the number of strings in the list and the
   length of the longest string, which will be needed by the display
   function.  If the application wants to handle displaying the list of
   matches itself, it sets RL_COMPLETION_DISPLAY_MATCHES_HOOK to the
   address of a function, and we just call it.  If we're handling the
   display ourselves, we just call rl_display_match_list.  We also check
   that the list of matches doesn't exceed the user-settable threshold,
   and ask the user if he wants to see the list if there are more matches
   than RL_COMPLETION_QUERY_ITEMS. */
static void
display_matches (matches)
     char **matches;
{
  int len, max, i;
  char *temp;

  /* Move to the last visible line of a possibly-multiple-line command. */
  _rl_move_vert (_rl_vis_botlin);

  /* Handle simple case first.  What if there is only one answer? */
  if (matches[1] == 0)
    {
      temp = printable_part (matches[0]);
      crlf ();
      print_filename (temp, matches[0]);
      crlf ();

      rl_forced_update_display ();
      rl_display_fixed = 1;

      return;
    }

  /* There is more than one answer.  Find out how many there are,
     and find the maximum printed length of a single entry. */
  for (max = 0, i = 1; matches[i]; i++)
    {
      temp = printable_part (matches[i]);
      len = strlen (temp);

      if (len > max)
	max = len;
    }

  len = i - 1;

  /* If the caller has defined a display hook, then call that now. */
  if (rl_completion_display_matches_hook)
    {
      (*rl_completion_display_matches_hook) (matches, len, max);
      return;
    }
	
  /* If there are many items, then ask the user if she really wants to
     see them all. */
  if (len >= rl_completion_query_items)
    {
      crlf ();
      fprintf (rl_outstream, "Display all %d possibilities? (y or n)", len);
      fflush (rl_outstream);
      if (get_y_or_n () == 0)
	{
	  crlf ();

	  rl_forced_update_display ();
	  rl_display_fixed = 1;

	  return;
	}
    }

  rl_display_match_list (matches, len, max);
d997 3
d1002 1
d1029 5
a1033 2
    should_quote = should_quote && (!qc || !*qc ||
		     (rl_completer_quote_characters && strchr (rl_completer_quote_characters, *qc)));
a1170 11
static void
free_match_list (matches)
     char **matches;
{
  register int i;

  for (i = 0; matches[i]; i++)
    free (matches[i]);
  free (matches);
}

a1212 1
  free (text);
d1218 1
a1221 1
#if 0
d1225 1
a1225 8
#else
  /* If we are matching filenames, the attempted completion function will
     have set rl_filename_completion_desired to a non-zero value.  The basic
     filename_completion_function does this. */
  i = rl_filename_completion_desired;
#endif

  if (postprocess_matches (&matches, i) == 0)
a1226 1
      ding ();
d1228 1
a1228 1
      completion_changed_buffer = 0;
d1232 2
d1280 3
a1282 1
  free_match_list (matches);
d1361 1
a1362 1
     int state;
d1364 1
a1364 1
#if defined (__GO32__) || defined (__WIN32__) || defined (__OPENNT)
d1418 1
a1419 1
     int state;
d1577 1
a1577 1
	  strcpy (temp + dirlen, entry->d_name);
a1651 1
#if 0
d1655 1
a1655 7
#else
      /* If we are matching filenames, the attempted completion function will
	 have set rl_filename_completion_desired to a non-zero value.  The basic
	 filename_completion_function does this. */
      matching_filenames = rl_filename_completion_desired;
#endif
      if (matches == 0 || postprocess_matches (&matches, matching_filenames) == 0)
d1689 1
a1689 1
  if (match_list_index == 0 && match_list_size > 1)
@


1.1.1.3
log
@Import of readline 4.1
@
text
@d10 1
a10 1
   as published by the Free Software Foundation; either version 2, or
d21 1
a21 1
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
a72 2
#include "xmalloc.h"
#include "rlprivate.h"
d74 13
a86 5
#ifdef __STDC__
typedef int QSFUNC (const void *, const void *);
#else
typedef int QSFUNC ();
#endif
d98 2
a99 2
char *filename_completion_function __P((char *, int));
char **completion_matches __P((char *, CPFunction *));
d105 1
a105 1
static int stat_char __P((char *));
d108 9
a116 2
static char *rl_quote_filename __P((char *, int, char *));
static char *rl_strpbrk __P((char *, char *));
d118 1
a118 6
static char **remove_duplicate_matches __P((char **));
static void insert_match __P((char *, int, int, char *));
static int append_to_match __P((char *, int, int));
static void insert_all_matches __P((char **, int, char *));
static void display_matches __P((char **));
static int compute_lcd_of_matches __P((char **, int, char *));
a138 3
#if defined (__MSDOS__) && !defined (__DJGPP__)
int _rl_completion_case_fold = 1;
#else
a139 1
#endif
a419 4
#if defined (__MSDOS__)
  if (rl_filename_completion_desired && temp == 0 && isalpha (pathname[0]) && pathname[1] == ':')
    temp = pathname + 1;
#endif
d480 1
a480 6
	  /* If setting the last slash in full_pathname to a NUL results in
	     full_pathname being the empty string, we are trying to complete
	     files in the root directory.  If we pass a null string to the
	     bash directory completion hook, for example, it will expand it
	     to the current directory.  We just want the `/'. */
	  s = tilde_expand (full_pathname && *full_pathname ? full_pathname : "/");
d630 7
a636 10
     if it is found in rl_completer_word_break_characters.  Don't bother
     if we're at the end of the line, though. */
  if (scan)
    {
      if (rl_char_is_quoted_p)
	isbrk = (found_quote == 0 ||
		(*rl_char_is_quoted_p) (rl_line_buffer, rl_point) == 0) &&
		strchr (rl_completer_word_break_characters, scan) != 0;
      else
	isbrk = strchr (rl_completer_word_break_characters, scan) != 0;
d638 11
a648 14
      if (isbrk)
	{
	  /* If the character that caused the word break was a quoting
	     character, then remember it as the delimiter. */
	  if (rl_basic_quote_characters &&
	      strchr (rl_basic_quote_characters, scan) &&
	      (end - rl_point) > 1)
	    delimiter = scan;

	  /* If the character isn't needed to determine something special
	     about what kind of completion to perform, then advance past it. */
	  if (rl_special_prefixes == 0 || strchr (rl_special_prefixes, scan) == 0)
	    rl_point++;
	}
d718 1
a718 1
    qsort (matches+1, i-1, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);
d911 1
a911 1
    qsort (matches + 1, len, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);
d1410 1
a1410 1
#if defined (__WIN32__) || defined (__OPENNT)
d1412 1
a1412 1
#else /* !__WIN32__ && !__OPENNT) */
d1455 1
a1455 1
#endif /* !__WIN32__ && !__OPENNT */
a1496 6
#if defined (__MSDOS__)
      /* special hack for //X/... */
      if (dirname[0] == '/' && dirname[1] == '/' && isalpha (dirname[2]) && dirname[3] == '/')
        temp = strrchr (dirname + 3, '/');
#endif

a1501 8
#if defined (__MSDOS__)
      /* searches from current directory on the drive */
      else if (isalpha (dirname[0]) && dirname[1] == ':')
        {
          strcpy (filename, dirname + 2);
          dirname[2] = '\0';
        }
#endif
d1663 5
a1667 1
	free_match_list (matches);
@


1.1.1.4
log
@import of readline-4.3
@
text
@d52 12
a69 1
#include "rlmbutil.h"
a81 15
#ifdef HAVE_LSTAT
#  define LSTAT lstat
#else
#  define LSTAT stat
#endif

/* Unix version of a hidden file.  Could be different on other systems. */
#define HIDDEN_FILE(fname)	((fname)[0] == '.')

/* Most systems don't declare getpwent in <pwd.h> if _POSIX_SOURCE is
   defined. */
#if !defined (HAVE_GETPW_DECLS) || defined (_POSIX_SOURCE)
extern struct passwd *getpwent PARAMS((void));
#endif /* !HAVE_GETPW_DECLS || _POSIX_SOURCE */

d89 5
a93 1
rl_compdisp_func_t *rl_completion_display_matches_hook = (rl_compdisp_func_t *)NULL;
d99 1
a99 1
static int stat_char PARAMS((char *));
d102 2
a103 17
static char *rl_quote_filename PARAMS((char *, int, char *));

static void set_completion_defaults PARAMS((int));
static int get_y_or_n PARAMS((int));
static int _rl_internal_pager PARAMS((int));
static char *printable_part PARAMS((char *));
static int print_filename PARAMS((char *, char *));

static char **gen_completion_matches PARAMS((char *, int, int, rl_compentry_func_t *, int, int));

static char **remove_duplicate_matches PARAMS((char **));
static void insert_match PARAMS((char *, int, int, char *));
static int append_to_match PARAMS((char *, int, int, int));
static void insert_all_matches PARAMS((char **, int, char *));
static void display_matches PARAMS((char **));
static int compute_lcd_of_matches PARAMS((char **, int, const char *));
static int postprocess_matches PARAMS((char ***, int));
d105 6
a110 1
static char *make_quoted_replacement PARAMS((char *, int, char *));
a125 6
/* If non-zero, the symlinked directory completion behavior introduced in
   readline-4.2a is disabled, and symlinks that point to directories have
   a slash appended (subject to the value of _rl_complete_mark_directories).
   This is user-settable via the mark-symlinked-directories variable. */
int _rl_complete_mark_symlink_dirs = 0;

a136 4
/* If non-zero, don't match hidden files (filenames beginning with a `.' on
   Unix) when doing filename completion. */
int _rl_match_hidden_files = 1;

d149 1
a149 3
rl_icppfunc_t *rl_directory_completion_hook = (rl_icppfunc_t *)NULL;

rl_icppfunc_t *rl_directory_rewrite_hook = (rl_icppfunc_t *)NULL;
d155 1
a155 1
   NULL means to use rl_filename_completion_function (), the default filename
d157 1
a157 1
rl_compentry_func_t *rl_completion_entry_function = (rl_compentry_func_t *)NULL;
d166 1
a166 1
rl_completion_func_t *rl_attempted_completion_function = (rl_completion_func_t *)NULL;
a181 2
int _rl_page_completions = 1;

d185 1
a185 1
const char *rl_basic_word_break_characters = " \t\n\"\\'`@@$><=;|&{("; /* }) */
d188 1
a188 1
const char *rl_basic_quote_characters = "\"'";
d193 1
a193 1
const char *rl_completer_word_break_characters = (const char *)NULL;
d199 1
a199 1
const char *rl_completer_quote_characters = (const char *)NULL;
d202 1
a202 1
const char *rl_filename_quote_characters = (const char *)NULL;
d207 1
a207 1
const char *rl_special_prefixes = (const char *)NULL;
d233 1
a233 1
rl_compignore_func_t *rl_ignore_some_completions_function = (rl_compignore_func_t *)NULL;
d239 1
a239 1
rl_quote_func_t *rl_filename_quoting_function = rl_quote_filename;
d245 1
a245 1
rl_dequote_func_t *rl_filename_dequoting_function = (rl_dequote_func_t *)NULL;
d250 1
a250 6
rl_linebuf_func_t *rl_char_is_quoted_p = (rl_linebuf_func_t *)NULL;

/* If non-zero, the completion functions don't append anything except a
   possible closing quote.  This is set to 0 by rl_complete_internal and
   may be changed by an application-specific completion function. */
int rl_completion_suppress_append = 0;
a255 11
/* If non-zero, a slash will be appended to completed filenames that are
   symbolic links to directory names, subject to the value of the
   mark-directories variable (which is user-settable).  This exists so
   that application completion functions can override the user's preference
   (set via the mark-symlinked-directories variable) if appropriate.
   It's set to the value of _rl_complete_mark_symlink_dirs in
   rl_complete_internal before any application-specific completion
   function is called, so without that function doing anything, the user's
   preferences are honored. */
int rl_completion_mark_symlink_dirs;

d272 1
a272 1
   rl_completion_matches ()).  The default is to do filename completion. */
d278 1
a278 1
    return (_rl_insert_char (ignore, invoking_key));
a301 17
/* Return the correct value to pass to rl_complete_internal performing
   the same tests as rl_complete.  This allows consecutive calls to an
   application's completion function to list possible completions and for
   an application-specific completion function to honor the
   show-all-if-ambiguous readline variable. */
int
rl_completion_mode (cfunc)
     rl_command_func_t *cfunc;
{
  if (rl_last_func == cfunc && !completion_changed_buffer)
    return '?';
  else if (_rl_complete_show_all)
    return '!';
  else
    return TAB;
}

d308 5
a312 5
/* Set default values for readline word completion.  These are the variables
   that application completion functions can change or inspect. */
static void
set_completion_defaults (what_to_do)
     int what_to_do;
d314 1
a314 5
  /* Only the completion entry function can change these. */
  rl_filename_completion_desired = 0;
  rl_filename_quoting_desired = 1;
  rl_completion_type = what_to_do;
  rl_completion_suppress_append = 0;
d316 11
a326 2
  /* The completion entry function may optionally change this. */
  rl_completion_mark_symlink_dirs = _rl_complete_mark_symlink_dirs;
d331 1
a331 2
get_y_or_n (for_pager)
     int for_pager;
a336 1
      RL_SETSTATE(RL_STATE_MOREINPUT);
a337 2
      RL_UNSETSTATE(RL_STATE_MOREINPUT);

d344 1
a344 5
      if (for_pager && (c == NEWLINE || c == RETURN))
	return (2);
      if (for_pager && (c == 'q' || c == 'Q'))
	return (0);
      rl_ding ();
a347 18
static int
_rl_internal_pager (lines)
     int lines;
{
  int i;

  fprintf (rl_outstream, "--More--");
  fflush (rl_outstream);
  i = get_y_or_n (1);
  _rl_erase_entire_line ();
  if (i == 0)
    return -1;
  else if (i == 2)
    return (lines - 1);
  else
    return 0;
}

d408 1
a408 5
   final slash.  Otherwise, we return what we were passed.  Since
   printing empty strings is not very informative, if we're doing
   filename completion, and the basename is the empty string, we look
   for the previous slash and return the portion following that.  If
   there's no previous slash, we just return what we were passed. */
d413 1
a413 4
  char *temp, *x;

  if (rl_filename_completion_desired == 0)	/* don't need to do anything */
    return (pathname);
d415 1
a415 1
  temp = strrchr (pathname, '/');
d417 1
a417 1
  if (temp == 0 && ISALPHA ((unsigned char)pathname[0]) && pathname[1] == ':')
d420 1
a420 16

  if (temp == 0 || *temp == '\0')
    return (pathname);
  /* If the basename is NULL, we might have a pathname like '/usr/src/'.
     Look for a previous slash and, if one is found, return the portion
     following that slash.  If there's no previous slash, just return the
     pathname we were passed. */
  else if (temp[1] == '\0')
    {
      for (x = temp - 1; x > pathname; x--)
        if (*x == '/')
          break;
      return ((*x == '/') ? x + 1 : pathname);
    }
  else
    return ++temp;
d491 1
a491 1
	  new_full_pathname = (char *)xmalloc (slen + tlen + 2);
d526 1
a526 1
  r = (char *)xmalloc (strlen (s) + 2);
d537 1
a537 1
   rl_completer_quote_characters).  First we try to find an unclosed
d549 2
a550 2
char
_rl_find_completion_word (fp, dp)
d574 1
a574 5
	  /* Shell-like semantics for single quotes -- don't allow backslash
	     to quote anything in single quotes, especially not the closing
	     quote.  If you don't like this, take out the check on the value
	     of quote_char. */
	  if (quote_char != '\'' && rl_line_buffer[scan] == '\\')
a600 2
	      else
		found_quote |= RL_QF_OTHER_QUOTE;      
a609 3
#if defined (HANDLE_MULTIBYTE)
      while (rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_ANY))
#else
a610 1
#endif
d674 1
a674 1
     rl_compentry_func_t *our_func;
d698 1
a698 1
  if (found_quote && our_func == rl_filename_completion_function &&
d706 1
a706 1
  matches = rl_completion_matches (text, our_func);
d778 1
a778 1
     const char *text;
a781 5
#if defined (HANDLE_MULTIBYTE)
  int v;
  mbstate_t ps1, ps2;
  wchar_t wc1, wc2;
#endif
a794 7
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  memset (&ps1, 0, sizeof (mbstate_t));
	  memset (&ps2, 0, sizeof (mbstate_t));
	}
#endif
a800 14
#if defined (HANDLE_MULTIBYTE)
	    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	      {
		v = mbrtowc (&wc1, match_list[i]+si, strlen (match_list[i]+si), &ps1);
		mbrtowc (&wc2, match_list[i+1]+si, strlen (match_list[i+1]+si), &ps2);
		wc1 = towlower (wc1);
		wc2 = towlower (wc2);
		if (wc1 != wc2)
		  break;
		else if (v > 1)
		  si += v - 1;
	      }
	    else
#endif
a809 11
#if defined (HANDLE_MULTIBYTE)
	    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	      {
		mbstate_t ps_back = ps1;
		if (!_rl_compare_chars (match_list[i], si, &ps1, match_list[i+1], si, &ps2))
		  break;
		else if ((v = _rl_get_char_len (&match_list[i][si], &ps_back)) > 1)
		  si += v - 1;
	      }
	    else
#endif
d823 1
a823 1
      match_list[0] = (char *)xmalloc (strlen (text) + 1);
d828 2
a829 31
      match_list[0] = (char *)xmalloc (low + 1);

      /* XXX - this might need changes in the presence of multibyte chars */

      /* If we are ignoring case, try to preserve the case of the string
	 the user typed in the face of multiple matches differing in case. */
      if (_rl_completion_case_fold)
	{
	  /* sort the list to get consistent answers. */
	  qsort (match_list+1, matches, sizeof(char *), (QSFUNC *)_rl_qsort_string_compare);

	  si = strlen (text);
	  if (si <= low)
	    {
	      for (i = 1; i <= matches; i++)
		if (strncmp (match_list[i], text, si) == 0)
		  {
		    strncpy (match_list[0], match_list[i], low);
		    break;
		  }
	      /* no casematch, use first entry */
	      if (i > matches)
		strncpy (match_list[0], match_list[1], low);
	    }
	  else
	    /* otherwise, just use the text the user typed. */
	    strncpy (match_list[0], text, low);
	}
      else
        strncpy (match_list[0], match_list[1], low);

a845 3
  if (matches == 0)
    return 0;

d898 1
a898 1
  int count, limit, printed_len, lines;
d904 2
a905 2
  limit = _rl_screenwidth / max;
  if (limit != 1 && (limit * max == _rl_screenwidth))
d908 1
a908 1
  /* Avoid a possible floating exception.  If max > _rl_screenwidth,
d924 1
a924 1
  rl_crlf ();
a925 1
  lines = 0;
d946 1
a946 8
	  rl_crlf ();
	  lines++;
	  if (_rl_page_completions && lines >= (_rl_screenheight - 1) && i < count)
	    {
	      lines = _rl_internal_pager (lines);
	      if (lines < 0)
		return;
	    }
d960 1
a960 10
		{
		  rl_crlf ();
		  lines++;
		  if (_rl_page_completions && lines >= _rl_screenheight - 1)
		    {
		      lines = _rl_internal_pager (lines);
		      if (lines < 0)
			return;
		    }
		}
d966 1
a966 1
      rl_crlf ();
d995 1
a995 1
      rl_crlf ();
d997 1
a997 1
      rl_crlf ();
d1029 1
a1029 1
      rl_crlf ();
d1032 1
a1032 1
      if (get_y_or_n (0) == 0)
d1034 1
a1034 1
	  rl_crlf ();
d1082 1
a1082 1
			? (_rl_strpbrk (match, rl_filename_quote_characters) != 0)
d1128 1
a1128 7
   appended.  If NONTRIVIAL_MATCH is set, we test for a symlink (if the OS
   has them) and don't add a suffix for a symlink to a directory.  A
   nontrivial match is one that actually adds to the word being completed.
   The variable rl_completion_mark_symlink_dirs controls this behavior
   (it's initially set to the what the user has chosen, indicated by the
   value of _rl_complete_mark_symlink_dirs, but may be modified by an
   application's completion function). */
d1130 1
a1130 1
append_to_match (text, delimiter, quote_char, nontrivial_match)
d1132 1
a1132 1
     int delimiter, quote_char, nontrivial_match;
d1135 1
a1135 1
  int temp_string_index, s;
d1144 1
a1144 1
  else if (rl_completion_suppress_append == 0 && rl_completion_append_character)
d1152 1
a1152 4
      s = (nontrivial_match && rl_completion_mark_symlink_dirs == 0)
		? LSTAT (filename, &finfo)
		: stat (filename, &finfo);
      if (s == 0 && S_ISDIR (finfo.st_mode))
d1154 2
a1155 10
	  if (_rl_complete_mark_directories)
	    {
	      /* This is clumsy.  Avoid putting in a double slash if point
		 is at the end of the line and the previous character is a
		 slash. */
	      if (rl_point && rl_line_buffer[rl_point] == '\0' && rl_line_buffer[rl_point - 1] == '/')
		;
	      else if (rl_line_buffer[rl_point] != '/')
		rl_insert_text ("/");
	    }
a1156 7
#ifdef S_ISLNK
      /* Don't add anything if the filename is a symlink and resolves to a
	 directory. */
      else if (s == 0 && S_ISLNK (finfo.st_mode) &&
	       stat (filename, &finfo) == 0 && S_ISDIR (finfo.st_mode))
	;
#endif
d1159 1
a1159 1
	  if (rl_point == rl_end && temp_string_index)
d1166 1
a1166 1
      if (rl_point == rl_end && temp_string_index)
d1212 2
a1213 2
void
_rl_free_match_list (matches)
a1217 3
  if (matches == 0)
    return;

d1235 2
a1236 2
  rl_compentry_func_t *our_func;
  int start, end, delimiter, found_quote, i, nontrivial_lcd;
d1240 4
a1243 3
  RL_SETSTATE(RL_STATE_COMPLETING);

  set_completion_defaults (what_to_do);
d1248 1
a1248 1
		: rl_filename_completion_function;
d1258 1
a1258 1
    quote_char = _rl_find_completion_word (&found_quote, &delimiter);
a1264 3
  /* nontrivial_lcd is set if the common prefix adds something to the word
     being completed. */
  nontrivial_lcd = matches && strcmp (text, matches[0]) != 0;
d1269 1
a1269 1
      rl_ding ();
a1270 2
      completion_changed_buffer = 0;
      RL_UNSETSTATE(RL_STATE_COMPLETING);
d1274 5
d1281 1
a1281 1
     rl_filename_completion_function does this. */
d1283 1
d1287 1
a1287 1
      rl_ding ();
a1289 1
      RL_UNSETSTATE(RL_STATE_COMPLETING);
d1317 1
a1317 1
	    rl_ding ();	/* There are other matches remaining. */
d1320 1
a1320 1
	append_to_match (matches[0], delimiter, quote_char, nontrivial_lcd);
d1334 1
a1334 1
      rl_ding ();
a1335 1
      RL_UNSETSTATE(RL_STATE_COMPLETING);
d1339 1
a1339 1
  _rl_free_match_list (matches);
a1347 1
  RL_UNSETSTATE(RL_STATE_COMPLETING);
d1370 3
a1372 3
rl_completion_matches (text, entry_function)
     const char *text;
     rl_compentry_func_t *entry_function;
d1417 2
a1418 2
rl_username_completion_function (text, state)
     const char *text;
d1455 1
a1455 1
      value = (char *)xmalloc (2 + strlen (entry->pw_name));
d1474 2
a1475 2
rl_filename_completion_function (text, state)
     const char *text;
d1510 1
a1510 1
      if (dirname[0] == '/' && dirname[1] == '/' && ISALPHA ((unsigned char)dirname[2]) && dirname[3] == '/')
d1521 1
a1521 1
      else if (ISALPHA ((unsigned char)dirname[0]) && dirname[1] == ':')
a1544 3
      if (rl_directory_rewrite_hook)
	(*rl_directory_rewrite_hook) (&dirname);

d1568 2
a1569 3
      /* Special case for no filename.  If the user has disabled the
         `match-hidden-files' variable, skip filenames beginning with `.'.
	 All other entries except "." and ".." match. */
a1571 3
	  if (_rl_match_hidden_files == 0 && HIDDEN_FILE (entry->d_name))
	    continue;

d1631 1
a1631 1
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
d1644 1
a1644 1
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
a1645 3
	      /* Make sure that temp has a trailing slash here. */
	      if (users_dirname[dirlen - 1] != '/')
		temp[dirlen++] = '/';
d1670 1
a1670 1
  rl_compentry_func_t *our_func;
d1688 1
a1688 1
	_rl_free_match_list (matches);
d1694 3
a1696 1
      set_completion_defaults ('%');
d1700 1
a1700 1
			: rl_filename_completion_function;
d1710 1
a1710 1
	quote_char = _rl_find_completion_word (&found_quote, &delimiter);
d1719 5
d1726 1
a1726 1
	 rl_filename_completion_function does this. */
d1728 1
a1728 1

d1731 1
a1731 1
    	  rl_ding ();
d1752 1
a1752 1
      rl_ding ();
d1765 1
a1765 1
      rl_ding ();
d1771 1
a1771 2
      append_to_match (matches[match_list_index], delimiter, quote_char,
		       strcmp (orig_text, matches[match_list_index]));
@


1.1.1.5
log
@import of readlilne 5.1
@
text
@d3 1
a3 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
d31 1
a31 1
#  include <sys/file.h>
a50 1
#if defined (HAVE_PWD_H)
a51 1
#endif
d82 1
a82 1
#if defined (HAVE_GETPWENT) && (!defined (HAVE_GETPW_DECLS) || defined (_POSIX_SOURCE))
d84 1
a84 1
#endif /* HAVE_GETPWENT && (!HAVE_GETPW_DECLS || _POSIX_SOURCE) */
a101 2
static int path_isdir PARAMS((const char *));

a107 2
static int fnwidth PARAMS((const char *));
static int fnprint PARAMS((const char *));
a132 4
/* If non-zero, non-unique completions show the list of matches, unless it
   is not possible to do partial completion and modify the line. */
int _rl_complete_show_unmodified = 0;

d201 1
a201 2
   she is sure she wants to see them all.  A negative value means
   don't ask. */
d217 1
a217 6
/*const*/ char *rl_completer_word_break_characters = (/*const*/ char *)NULL;

/* Hook function to allow an application to set the completion word
   break characters before readline breaks up the line.  Allows
   position-dependent word break characters. */
rl_cpvfunc_t *rl_completion_word_break_hook = (rl_cpvfunc_t *)NULL;
a284 13
/* If non-zero, the completion functions don't append any closing quote.
   This is set to 0 by rl_complete_internal and may be changed by an
   application-specific completion function. */
int rl_completion_suppress_quote = 0;

/* Set to any quote character readline thinks it finds before any application
   completion function is called. */
int rl_completion_quote_character;

/* Set to a non-zero value if readline found quoting anywhere in the word to
   be completed; set before any application completion function is called. */
int rl_completion_found_quote;

a322 2
  else if (_rl_complete_show_unmodified)
    return (rl_complete_internal ('@@'));
a354 2
  else if (_rl_complete_show_unmodified)
    return '@@';
d375 1
a375 1
  rl_completion_suppress_append = rl_completion_suppress_quote = 0;
a425 9
static int
path_isdir (filename)
     const char *filename;
{
  struct stat finfo;

  return (stat (filename, &finfo) == 0 && S_ISDIR (finfo.st_mode));
}

a522 124
/* Compute width of STRING when displayed on screen by print_filename */
static int
fnwidth (string)
     const char *string;
{
  int width, pos;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
  int left, w;
  size_t clen;
  wchar_t wc;

  left = strlen (string) + 1;
  memset (&ps, 0, sizeof (mbstate_t));
#endif

  width = pos = 0;
  while (string[pos])
    {
      if (CTRL_CHAR (*string) || *string == RUBOUT)
	{
	  width += 2;
	  pos++;
	}
      else
	{
#if defined (HANDLE_MULTIBYTE)
	  clen = mbrtowc (&wc, string + pos, left - pos, &ps);
	  if (MB_INVALIDCH (clen))
	    {
	      width++;
	      pos++;
	      memset (&ps, 0, sizeof (mbstate_t));
	    }
	  else if (MB_NULLWCH (clen))
	    break;
	  else
	    {
	      pos += clen;
	      w = wcwidth (wc);
	      width += (w >= 0) ? w : 1;
	    }
#else
	  width++;
	  pos++;
#endif
	}
    }

  return width;
}

static int
fnprint (to_print)
     const char *to_print;
{
  int printed_len;
  const char *s;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
  const char *end;
  size_t tlen;
  int width, w;
  wchar_t wc;

  end = to_print + strlen (to_print) + 1;
  memset (&ps, 0, sizeof (mbstate_t));
#endif

  printed_len = 0;
  s = to_print;
  while (*s)
    {
      if (CTRL_CHAR (*s))
        {
          putc ('^', rl_outstream);
          putc (UNCTRL (*s), rl_outstream);
          printed_len += 2;
          s++;
#if defined (HANDLE_MULTIBYTE)
	  memset (&ps, 0, sizeof (mbstate_t));
#endif
        }
      else if (*s == RUBOUT)
	{
	  putc ('^', rl_outstream);
	  putc ('?', rl_outstream);
	  printed_len += 2;
	  s++;
#if defined (HANDLE_MULTIBYTE)
	  memset (&ps, 0, sizeof (mbstate_t));
#endif
	}
      else
	{
#if defined (HANDLE_MULTIBYTE)
	  tlen = mbrtowc (&wc, s, end - s, &ps);
	  if (MB_INVALIDCH (tlen))
	    {
	      tlen = 1;
	      width = 1;
	      memset (&ps, 0, sizeof (mbstate_t));
	    }
	  else if (MB_NULLWCH (tlen))
	    break;
	  else
	    {
	      w = wcwidth (wc);
	      width = (w >= 0) ? w : 1;
	    }
	  fwrite (s, 1, tlen, rl_outstream);
	  s += tlen;
	  printed_len += width;
#else
	  putc (*s, rl_outstream);
	  s++;
	  printed_len++;
#endif
	}
    }

  return printed_len;
}

d527 21
d552 3
a554 2
  int printed_len, extension_char, slen, tlen;
  char *s, c, *new_full_pathname, *dn;
d556 7
a562 2
  extension_char = 0;
  printed_len = fnprint (to_print);
d564 6
a569 5
#if defined (VISIBLE_STATS)
 if (rl_filename_completion_desired && (rl_visible_stats || _rl_complete_mark_directories))
#else
 if (rl_filename_completion_desired && _rl_complete_mark_directories)
#endif
d585 1
a585 11
	  if (full_pathname == 0 || *full_pathname == 0)
	    dn = "/";
	  else if (full_pathname[0] != '/')
	    dn = full_pathname;
	  else if (full_pathname[1] == 0)
	    dn = "//";		/* restore trailing slash to `//' */
	  else if (full_pathname[1] == '/' && full_pathname[2] == 0)
	    dn = "/";		/* don't turn /// into // */
	  else
	    dn = full_pathname;
	  s = tilde_expand (dn);
a592 4
	  if (s[slen - 1] == '/')
	    slen--;
	  else
	    new_full_pathname[slen] = '/';
d596 1
a596 7
#if defined (VISIBLE_STATS)
	  if (rl_visible_stats)
	    extension_char = stat_char (new_full_pathname);
	  else
#endif
	  if (path_isdir (new_full_pathname))
	    extension_char = '/';
d604 1
a604 7
#if defined (VISIBLE_STATS)
	  if (rl_visible_stats)
	    extension_char = stat_char (s);
	  else
#endif
	    if (path_isdir (s))
	      extension_char = '/';
d614 1
a614 1

d654 1
a654 1
  char quote_char, *brkchars;
a659 6
  brkchars = 0;
  if (rl_completion_word_break_hook)
    brkchars = (*rl_completion_word_break_hook) ();
  if (brkchars == 0)
    brkchars = rl_completer_word_break_characters;

d666 1
a666 1
      for (scan = pass_next = 0; scan < end; scan = MB_NEXTCHAR (rl_line_buffer, scan, 1, MB_FIND_ANY))
d716 5
a720 1
      while (rl_point = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_ANY))
d724 1
a724 1
	  if (strchr (brkchars, scan) == 0)
d752 1
a752 1
		strchr (brkchars, scan) != 0;
d754 1
a754 1
	isbrk = strchr (brkchars, scan) != 0;
a788 3
  rl_completion_found_quote = found_quote;
  rl_completion_quote_character = quote_char;

a891 1
  char *dtext;		/* dequoted TEXT, if needed */
a982 20
	  /* We're making an assumption here:
		IF we're completing filenames AND
		   the application has defined a filename dequoting function AND
		   we found a quote character AND
		   the application has requested filename quoting
		THEN
		   we assume that TEXT was dequoted before checking against
		   the file system and needs to be dequoted here before we
		   check against the list of matches
		FI */
	  dtext = (char *)NULL;
	  if (rl_filename_completion_desired &&
	      rl_filename_dequoting_function &&
	      rl_completion_found_quote &&
	      rl_filename_quoting_desired)
	    {
	      dtext = (*rl_filename_dequoting_function) ((char *)text, rl_completion_quote_character);
	      text = dtext;
	    }

a1001 2

	  FREE (dtext);
d1206 1
a1206 1
      len = fnwidth (temp);
d1223 1
a1223 1
  if (rl_completion_query_items > 0 && len >= rl_completion_query_items)
d1341 1
a1341 2
  if (quote_char && rl_point && rl_completion_suppress_quote == 0 &&
      rl_line_buffer[rl_point - 1] != quote_char)
d1359 1
a1359 1
	  if (_rl_complete_mark_directories /* && rl_completion_suppress_append == 0 */)
d1452 1
a1452 3
   there is more than one.
   `@@' means to do standard completion, and list all possible completions if
   there is more than one and partial completion is not possible. */
d1471 1
a1518 1
    case '@@':
a1537 6
	  else if (what_to_do == '@@')
	    {
	      if (nontrivial_lcd == 0)
		display_matches (matches);
	      break;
	    }
a1664 1
#if defined (HAVE_GETPWENT)
a1670 1
#endif
a1673 1
#if defined (HAVE_GETPWENT)
a1674 1
#endif
d1986 1
a1986 1
  match_list_index += count;
a1988 2
  else
    match_list_index %= match_list_size;
@


