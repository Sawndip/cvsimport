head	1.8;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.7
	gdb_7_6-2013-04-26-release:1.7
	gdb_7_6-branch:1.7.0.6
	gdb_7_6-2013-03-12-branchpoint:1.7
	gdb_7_5_1-2012-11-29-release:1.7
	gdb_7_5-2012-08-17-release:1.7
	gdb_7_5-branch:1.7.0.4
	gdb_7_5-2012-07-18-branchpoint:1.7
	gdb_7_4_1-2012-04-26-release:1.7
	gdb_7_4-2012-01-24-release:1.7
	gdb_7_4-branch:1.7.0.2
	gdb_7_4-2011-12-13-branchpoint:1.7
	gdb_7_3_1-2011-09-04-release:1.6
	gdb_7_3-2011-07-26-release:1.6
	gdb_7_3-branch:1.6.0.36
	gdb_7_3-2011-04-01-branchpoint:1.6
	gdb_7_2-2010-09-02-release:1.6
	gdb_7_2-branch:1.6.0.34
	gdb_7_2-2010-07-07-branchpoint:1.6
	gdb_7_1-2010-03-18-release:1.6
	gdb_7_1-branch:1.6.0.32
	gdb_7_1-2010-02-18-branchpoint:1.6
	gdb_7_0_1-2009-12-22-release:1.6
	gdb_7_0-2009-10-06-release:1.6
	gdb_7_0-branch:1.6.0.30
	gdb_7_0-2009-09-16-branchpoint:1.6
	arc-sim-20090309:1.6
	msnyder-checkpoint-072509-branch:1.6.0.28
	msnyder-checkpoint-072509-branchpoint:1.6
	arc-insight_6_8-branch:1.6.0.26
	arc-insight_6_8-branchpoint:1.6
	insight_6_8-branch:1.6.0.24
	insight_6_8-branchpoint:1.6
	reverse-20081226-branch:1.6.0.22
	reverse-20081226-branchpoint:1.6
	multiprocess-20081120-branch:1.6.0.20
	multiprocess-20081120-branchpoint:1.6
	reverse-20080930-branch:1.6.0.18
	reverse-20080930-branchpoint:1.6
	reverse-20080717-branch:1.6.0.16
	reverse-20080717-branchpoint:1.6
	msnyder-reverse-20080609-branch:1.6.0.14
	msnyder-reverse-20080609-branchpoint:1.6
	drow-reverse-20070409-branch:1.6.0.12
	drow-reverse-20070409-branchpoint:1.6
	gdb_6_8-2008-03-27-release:1.6
	gdb_6_8-branch:1.6.0.10
	gdb_6_8-2008-02-26-branchpoint:1.6
	gdb_6_7_1-2007-10-29-release:1.6
	gdb_6_7-2007-10-10-release:1.6
	gdb_6_7-branch:1.6.0.8
	gdb_6_7-2007-09-07-branchpoint:1.6
	insight_6_6-20070208-release:1.6
	gdb_6_6-2006-12-18-release:1.6
	gdb_6_6-branch:1.6.0.6
	gdb_6_6-2006-11-15-branchpoint:1.6
	insight_6_5-20061003-release:1.6
	gdb-csl-symbian-6_4_50_20060226-12:1.4
	gdb-csl-sourcerygxx-3_4_4-25:1.4
	nickrob-async-20060828-mergepoint:1.6
	gdb-csl-symbian-6_4_50_20060226-11:1.4
	gdb-csl-sourcerygxx-4_1-17:1.4
	gdb-csl-20060226-branch-local-2:1.4
	gdb-csl-sourcerygxx-4_1-14:1.4
	gdb-csl-sourcerygxx-4_1-13:1.4
	gdb-csl-sourcerygxx-4_1-12:1.4
	gdb-csl-sourcerygxx-3_4_4-21:1.4
	gdb_6_5-20060621-release:1.6
	gdb-csl-sourcerygxx-4_1-9:1.4
	gdb-csl-sourcerygxx-4_1-8:1.4
	gdb-csl-sourcerygxx-4_1-7:1.4
	gdb-csl-arm-2006q1-6:1.4
	gdb-csl-sourcerygxx-4_1-6:1.4
	gdb-csl-symbian-6_4_50_20060226-10:1.4
	gdb-csl-symbian-6_4_50_20060226-9:1.4
	gdb-csl-symbian-6_4_50_20060226-8:1.4
	gdb-csl-coldfire-4_1-11:1.4
	gdb-csl-sourcerygxx-3_4_4-19:1.4
	gdb-csl-coldfire-4_1-10:1.4
	gdb_6_5-branch:1.6.0.4
	gdb_6_5-2006-05-14-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-5:1.4
	nickrob-async-20060513-branch:1.6.0.2
	nickrob-async-20060513-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-4:1.4
	msnyder-reverse-20060502-branch:1.5.0.4
	msnyder-reverse-20060502-branchpoint:1.5
	gdb-csl-morpho-4_1-4:1.4
	gdb-csl-sourcerygxx-3_4_4-17:1.4
	readline_5_1-import-branch:1.5.0.2
	readline_5_1-import-branchpoint:1.5
	readline-pre-51-import:1.5
	readline_5_1:1.1.1.5
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.4
	gdb-csl-symbian-20060226-branch:1.4.0.78
	gdb-csl-symbian-20060226-branchpoint:1.4
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.4
	msnyder-reverse-20060331-branch:1.4.0.76
	msnyder-reverse-20060331-branchpoint:1.4
	gdb-csl-available-20060303-branch:1.4.0.74
	gdb-csl-available-20060303-branchpoint:1.4
	gdb-csl-20060226-branch:1.4.0.72
	gdb-csl-20060226-branchpoint:1.4
	gdb_6_4-20051202-release:1.4
	msnyder-fork-checkpoint-branch:1.4.0.70
	msnyder-fork-checkpoint-branchpoint:1.4
	gdb-csl-gxxpro-6_3-branch:1.4.0.68
	gdb-csl-gxxpro-6_3-branchpoint:1.4
	gdb_6_4-branch:1.4.0.66
	gdb_6_4-2005-11-01-branchpoint:1.4
	gdb-csl-arm-20051020-branch:1.4.0.64
	gdb-csl-arm-20051020-branchpoint:1.4
	msnyder-tracepoint-checkpoint-branch:1.4.0.62
	msnyder-tracepoint-checkpoint-branchpoint:1.4
	gdb-csl-arm-20050325-2005-q1b:1.4
	gdb-csl-arm-20050325-2005-q1a:1.4
	csl-arm-20050325-branch:1.4.0.60
	csl-arm-20050325-branchpoint:1.4
	gdb_6_3-20041109-release:1.4
	gdb_6_3-branch:1.4.0.56
	gdb_6_3-20041019-branchpoint:1.4
	drow_intercu-merge-20040921:1.4
	drow_intercu-merge-20040915:1.4
	jimb-gdb_6_2-e500-branch:1.4.0.58
	jimb-gdb_6_2-e500-branchpoint:1.4
	gdb_6_2-20040730-release:1.4
	gdb_6_2-branch:1.4.0.54
	gdb_6_2-2004-07-10-gmt-branchpoint:1.4
	gdb_6_1_1-20040616-release:1.4
	gdb_6_1-2004-04-05-release:1.4
	drow_intercu-merge-20040402:1.4
	drow_intercu-merge-20040327:1.4
	ezannoni_pie-20040323-branch:1.4.0.52
	ezannoni_pie-20040323-branchpoint:1.4
	cagney_tramp-20040321-mergepoint:1.4
	cagney_tramp-20040309-branch:1.4.0.50
	cagney_tramp-20040309-branchpoint:1.4
	gdb_6_1-branch:1.4.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.4
	drow_intercu-20040221-branch:1.4.0.46
	drow_intercu-20040221-branchpoint:1.4
	cagney_bfdfile-20040213-branch:1.4.0.44
	cagney_bfdfile-20040213-branchpoint:1.4
	drow-cplus-merge-20040208:1.4
	carlton_dictionary-20040126-merge:1.4
	cagney_bigcore-20040122-branch:1.4.0.42
	cagney_bigcore-20040122-branchpoint:1.4
	drow-cplus-merge-20040113:1.4
	drow-cplus-merge-20031224:1.4
	drow-cplus-merge-20031220:1.4
	carlton_dictionary-20031215-merge:1.4
	drow-cplus-merge-20031214:1.4
	carlton-dictionary-20031111-merge:1.4
	gdb_6_0-2003-10-04-release:1.4
	kettenis_sparc-20030918-branch:1.4.0.40
	kettenis_sparc-20030918-branchpoint:1.4
	carlton_dictionary-20030917-merge:1.4
	ezannoni_pie-20030916-branchpoint:1.4
	ezannoni_pie-20030916-branch:1.4.0.38
	cagney_x86i386-20030821-branch:1.4.0.36
	cagney_x86i386-20030821-branchpoint:1.4
	carlton_dictionary-20030805-merge:1.4
	carlton_dictionary-20030627-merge:1.4
	gdb_6_0-branch:1.4.0.34
	gdb_6_0-2003-06-23-branchpoint:1.4
	jimb-ppc64-linux-20030613-branch:1.4.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.4
	cagney_convert-20030606-branch:1.4.0.30
	cagney_convert-20030606-branchpoint:1.4
	cagney_writestrings-20030508-branch:1.4.0.28
	cagney_writestrings-20030508-branchpoint:1.4
	jimb-ppc64-linux-20030528-branch:1.4.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.4
	carlton_dictionary-20030523-merge:1.4
	cagney_fileio-20030521-branch:1.4.0.24
	cagney_fileio-20030521-branchpoint:1.4
	kettenis_i386newframe-20030517-mergepoint:1.4
	jimb-ppc64-linux-20030509-branch:1.4.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.4
	kettenis_i386newframe-20030504-mergepoint:1.4
	carlton_dictionary-20030430-merge:1.4
	kettenis_i386newframe-20030419-branch:1.4.0.20
	kettenis_i386newframe-20030419-branchpoint:1.4
	carlton_dictionary-20030416-merge:1.4
	cagney_frameaddr-20030409-mergepoint:1.4
	kettenis_i386newframe-20030406-branch:1.4.0.18
	kettenis_i386newframe-20030406-branchpoint:1.4
	cagney_frameaddr-20030403-branchpoint:1.4
	cagney_frameaddr-20030403-branch:1.4.0.16
	cagney_framebase-20030330-mergepoint:1.4
	cagney_framebase-20030326-branch:1.4.0.14
	cagney_framebase-20030326-branchpoint:1.4
	cagney_lazyid-20030317-branch:1.4.0.12
	cagney_lazyid-20030317-branchpoint:1.4
	kettenis-i386newframe-20030316-mergepoint:1.4
	offbyone-20030313-branch:1.4.0.10
	offbyone-20030313-branchpoint:1.4
	kettenis-i386newframe-20030308-branch:1.4.0.8
	kettenis-i386newframe-20030308-branchpoint:1.4
	carlton_dictionary-20030305-merge:1.4
	cagney_offbyone-20030303-branch:1.4.0.6
	cagney_offbyone-20030303-branchpoint:1.4
	carlton_dictionary-20030207-merge:1.4
	interps-20030202-branch:1.4.0.4
	interps-20030202-branchpoint:1.4
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.3
	readline-pre-43-import:1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.24
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	carlton_dictionary-branch:1.3.0.22
	carlton_dictionary-20020920-branchpoint:1.3
	gdb_5_3-branch:1.3.0.20
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.3
	cagney_sysregs-20020825-branch:1.3.0.18
	cagney_sysregs-20020825-branchpoint:1.3
	readline_4_3-import-branch:1.3.0.16
	readline_4_3-import-branchpoint:1.3
	readline_4_3:1.1.1.4
	gdb_5_2_1-2002-07-23-release:1.3
	kseitz_interps-20020528-branch:1.3.0.14
	kseitz_interps-20020528-branchpoint:1.3
	cagney_regbuf-20020515-branch:1.3.0.12
	cagney_regbuf-20020515-branchpoint:1.3
	jimb-macro-020506-branch:1.3.0.10
	jimb-macro-020506-branchpoint:1.3
	gdb_5_2-2002-04-29-release:1.3
	gdb_5_2-branch:1.3.0.8
	gdb_5_2-2002-03-03-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	cygnus_cvs_20020108_pre:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.4
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.2
	gdb_5_1-2001-07-29-branchpoint:1.3
	insight-precleanup-2001-01-01:1.3
	readline_4_1:1.1.1.3
	readline_4_0:1.1.1.2
	FSF:1.1.1
	readline-pre-41-import:1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.8
date	2013.09.23.16.05.24;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2011.05.11.23.38.39;	author jkratoch;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.05.18.26.12;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.20.20.13.20;	author ezannoni;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2002.12.08.22.31.37;	author ezannoni;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.09.17.19.56;	author ezannoni;	state Exp;
branches
	1.3.16.1
	1.3.22.1
	1.3.24.1;
next	1.2;

1.2
date	2000.07.07.17.15.45;	author ezannoni;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.54;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.5.2.1
date	2006.04.24.22.00.25;	author drow;	state Exp;
branches;
next	;

1.3.16.1
date	2002.08.25.23.41.17;	author ezannoni;	state Exp;
branches;
next	;

1.3.22.1
date	2002.12.23.19.39.45;	author carlton;	state Exp;
branches;
next	;

1.3.24.1
date	2003.12.14.20.28.14;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.54;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.08.02.23.47.59;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.07.09.16.21.21;	author ezannoni;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.08.23.22.02.28;	author ezannoni;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.20.20.05.37;	author ezannoni;	state Exp;
branches;
next	;


desc
@@


1.8
log
@[MinGW] Fix a compilation error in readline/util.c:_rl_strnicmp

readline/ChangeLog.gdb:

	* readline/util.c (_rl_strnicmp): Add missing semicolon.
@
text
@/* util.c -- readline utility functions */

/* Copyright (C) 1987-2010 Free Software Foundation, Inc.

   This file is part of the GNU Readline Library (Readline), a library
   for reading lines of text with interactive input and history editing.      

   Readline is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Readline is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Readline.  If not, see <http://www.gnu.org/licenses/>.
*/

#define READLINE_LIBRARY

#if defined (HAVE_CONFIG_H)
#  include <config.h>
#endif

#include <sys/types.h>
#include <fcntl.h>
#include "posixjmp.h"

#if defined (HAVE_UNISTD_H)
#  include <unistd.h>           /* for _POSIX_VERSION */
#endif /* HAVE_UNISTD_H */

#if defined (HAVE_STDLIB_H)
#  include <stdlib.h>
#else
#  include "ansi_stdlib.h"
#endif /* HAVE_STDLIB_H */

#include <stdio.h>
#include <ctype.h>

/* System-specific feature definitions and include files. */
#include "rldefs.h"
#include "rlmbutil.h"

#if defined (TIOCSTAT_IN_SYS_IOCTL)
#  include <sys/ioctl.h>
#endif /* TIOCSTAT_IN_SYS_IOCTL */

/* Some standard library routines. */
#include "readline.h"

#include "rlprivate.h"
#include "xmalloc.h"

/* **************************************************************** */
/*								    */
/*			Utility Functions			    */
/*								    */
/* **************************************************************** */

/* Return 0 if C is not a member of the class of characters that belong
   in words, or 1 if it is. */

int _rl_allow_pathname_alphabetic_chars = 0;
static const char * const pathname_alphabetic_chars = "/-_=~.#$";

int
rl_alphabetic (c)
     int c;
{
  if (ALPHABETIC (c))
    return (1);

  return (_rl_allow_pathname_alphabetic_chars &&
	    strchr (pathname_alphabetic_chars, c) != NULL);
}

#if defined (HANDLE_MULTIBYTE)
int
_rl_walphabetic (wchar_t wc)
{
  int c;

  if (iswalnum (wc))
    return (1);     

  c = wc & 0177;
  return (_rl_allow_pathname_alphabetic_chars &&
	    strchr (pathname_alphabetic_chars, c) != NULL);
}
#endif

/* How to abort things. */
int
_rl_abort_internal ()
{
  rl_ding ();
  rl_clear_message ();
  _rl_reset_argument ();
  rl_clear_pending_input ();

  RL_UNSETSTATE (RL_STATE_MACRODEF);
  while (rl_executing_macro)
    _rl_pop_executing_macro ();

  rl_last_func = (rl_command_func_t *)NULL;
  longjmp (_rl_top_level, 1);
  return (0);
}

int
rl_abort (count, key)
     int count, key;
{
  return (_rl_abort_internal ());
}

int
_rl_null_function (count, key)
     int count, key;
{
  return 0;
}

int
rl_tty_status (count, key)
     int count, key;
{
#if defined (TIOCSTAT)
  ioctl (1, TIOCSTAT, (char *)0);
  rl_refresh_line (count, key);
#else
  rl_ding ();
#endif
  return 0;
}

/* Return a copy of the string between FROM and TO.
   FROM is inclusive, TO is not. */
char *
rl_copy_text (from, to)
     int from, to;
{
  register int length;
  char *copy;

  /* Fix it if the caller is confused. */
  if (from > to)
    SWAP (from, to);

  length = to - from;
  copy = (char *)xmalloc (1 + length);
  strncpy (copy, rl_line_buffer + from, length);
  copy[length] = '\0';
  return (copy);
}

/* Increase the size of RL_LINE_BUFFER until it has enough space to hold
   LEN characters. */
void
rl_extend_line_buffer (len)
     int len;
{
  while (len >= rl_line_buffer_len)
    {
      rl_line_buffer_len += DEFAULT_BUFFER_SIZE;
      rl_line_buffer = (char *)xrealloc (rl_line_buffer, rl_line_buffer_len);
    }

  _rl_set_the_line ();
}


/* A function for simple tilde expansion. */
int
rl_tilde_expand (ignore, key)
     int ignore, key;
{
  register int start, end;
  char *homedir, *temp;
  int len;

  end = rl_point;
  start = end - 1;

  if (rl_point == rl_end && rl_line_buffer[rl_point] == '~')
    {
      homedir = tilde_expand ("~");
      _rl_replace_text (homedir, start, end);
      xfree (homedir);
      return (0);
    }
  else if (rl_line_buffer[start] != '~')
    {
      for (; !whitespace (rl_line_buffer[start]) && start >= 0; start--)
        ;
      start++;
    }

  end = start;
  do
    end++;
  while (whitespace (rl_line_buffer[end]) == 0 && end < rl_end);

  if (whitespace (rl_line_buffer[end]) || end >= rl_end)
    end--;

  /* If the first character of the current word is a tilde, perform
     tilde expansion and insert the result.  If not a tilde, do
     nothing. */
  if (rl_line_buffer[start] == '~')
    {
      len = end - start + 1;
      temp = (char *)xmalloc (len + 1);
      strncpy (temp, rl_line_buffer + start, len);
      temp[len] = '\0';
      homedir = tilde_expand (temp);
      xfree (temp);

      _rl_replace_text (homedir, start, end);
      xfree (homedir);
    }

  return (0);
}

#if defined (USE_VARARGS)
void
#if defined (PREFER_STDARG)
_rl_ttymsg (const char *format, ...)
#else
_rl_ttymsg (va_alist)
     va_dcl
#endif
{
  va_list args;
#if defined (PREFER_VARARGS)
  char *format;
#endif

#if defined (PREFER_STDARG)
  va_start (args, format);
#else
  va_start (args);
  format = va_arg (args, char *);
#endif

  fprintf (stderr, "readline: ");
  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");
  fflush (stderr);

  va_end (args);

  rl_forced_update_display ();
}

void
#if defined (PREFER_STDARG)
_rl_errmsg (const char *format, ...)
#else
_rl_errmsg (va_alist)
     va_dcl
#endif
{
  va_list args;
#if defined (PREFER_VARARGS)
  char *format;
#endif

#if defined (PREFER_STDARG)
  va_start (args, format);
#else
  va_start (args);
  format = va_arg (args, char *);
#endif

  fprintf (stderr, "readline: ");
  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");
  fflush (stderr);

  va_end (args);
}

#else /* !USE_VARARGS */
void
_rl_ttymsg (format, arg1, arg2)
     char *format;
{
  fprintf (stderr, "readline: ");
  fprintf (stderr, format, arg1, arg2);
  fprintf (stderr, "\n");

  rl_forced_update_display ();
}

void
_rl_errmsg (format, arg1, arg2)
     char *format;
{
  fprintf (stderr, "readline: ");
  fprintf (stderr, format, arg1, arg2);
  fprintf (stderr, "\n");
}
#endif /* !USE_VARARGS */

/* **************************************************************** */
/*								    */
/*			String Utility Functions		    */
/*								    */
/* **************************************************************** */

/* Determine if s2 occurs in s1.  If so, return a pointer to the
   match in s1.  The compare is case insensitive. */
char *
_rl_strindex (s1, s2)
     register const char *s1, *s2;
{
  register int i, l, len;

  for (i = 0, l = strlen (s2), len = strlen (s1); (len - i) >= l; i++)
    if (_rl_strnicmp (s1 + i, s2, l) == 0)
      return ((char *) (s1 + i));
  return ((char *)NULL);
}

#ifndef HAVE_STRPBRK
/* Find the first occurrence in STRING1 of any character from STRING2.
   Return a pointer to the character in STRING1. */
char *
_rl_strpbrk (string1, string2)
     const char *string1, *string2;
{
  register const char *scan;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
  register int i, v;

  memset (&ps, 0, sizeof (mbstate_t));
#endif

  for (; *string1; string1++)
    {
      for (scan = string2; *scan; scan++)
	{
	  if (*string1 == *scan)
	    return ((char *)string1);
	}
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  v = _rl_get_char_len (string1, &ps);
	  if (v > 1)
	    string1 += v - 1;	/* -1 to account for auto-increment in loop */
	}
#endif
    }
  return ((char *)NULL);
}
#endif

#if !defined (HAVE_STRCASECMP)
/* Compare at most COUNT characters from string1 to string2.  Case
   doesn't matter (strncasecmp). */
int
_rl_strnicmp (string1, string2, count)
     char *string1, *string2;
     int count;
{
  register char *s1, *s2;
  int d;

  if (count <= 0 || (string1 == string2))
    return 0;

  s1 = string1;
  s2 = string2;
  do
    {
      d = _rl_to_lower (*s1) - _rl_to_lower (*s2);	/* XXX - cast to unsigned char? */
      if (d != 0)
	return d;
      if (*s1++ == '\0')
        break;
      s2++;
    }
  while (--count != 0);

  return (0);
}

/* strcmp (), but caseless (strcasecmp). */
int
_rl_stricmp (string1, string2)
     char *string1, *string2;
{
  register char *s1, *s2;
  int d;

  s1 = string1;
  s2 = string2;

  if (s1 == s2)
    return 0;

  while ((d = _rl_to_lower (*s1) - _rl_to_lower (*s2)) == 0)
    {
      if (*s1++ == '\0')
        return 0;
      s2++;
    }

  return (d);
}
#endif /* !HAVE_STRCASECMP */

/* Stupid comparison routine for qsort () ing strings. */
int
_rl_qsort_string_compare (s1, s2)
  char **s1, **s2;
{
#if defined (HAVE_STRCOLL)
  return (strcoll (*s1, *s2));
#else
  int result;

  result = **s1 - **s2;
  if (result == 0)
    result = strcmp (*s1, *s2);

  return result;
#endif
}

/* Function equivalents for the macros defined in chardefs.h. */
#define FUNCTION_FOR_MACRO(f)	int (f) (c) int c; { return f (c); }

FUNCTION_FOR_MACRO (_rl_digit_p)
FUNCTION_FOR_MACRO (_rl_digit_value)
FUNCTION_FOR_MACRO (_rl_lowercase_p)
FUNCTION_FOR_MACRO (_rl_pure_alphabetic)
FUNCTION_FOR_MACRO (_rl_to_lower)
FUNCTION_FOR_MACRO (_rl_to_upper)
FUNCTION_FOR_MACRO (_rl_uppercase_p)

/* A convenience function, to force memory deallocation to be performed
   by readline.  DLLs on Windows apparently require this. */
void
rl_free (mem)
     void *mem;
{
  if (mem)
    free (mem);
}

/* Backwards compatibility, now that savestring has been removed from
   all `public' readline header files. */
#undef _rl_savestring
char *
_rl_savestring (s)
     const char *s;
{
  return (strcpy ((char *)xmalloc (1 + (int)strlen (s)), (s)));
}

#if defined (USE_VARARGS)
static FILE *_rl_tracefp;

void
#if defined (PREFER_STDARG)
_rl_trace (const char *format, ...)
#else
_rl_trace (va_alist)
     va_dcl
#endif
{
  va_list args;
#if defined (PREFER_VARARGS)
  char *format;
#endif

#if defined (PREFER_STDARG)
  va_start (args, format);
#else
  va_start (args);
  format = va_arg (args, char *);
#endif

  if (_rl_tracefp == 0)
    _rl_tropen ();
  vfprintf (_rl_tracefp, format, args);
  fprintf (_rl_tracefp, "\n");
  fflush (_rl_tracefp);

  va_end (args);
}

int
_rl_tropen ()
{
  char fnbuf[128];

  if (_rl_tracefp)
    fclose (_rl_tracefp);
  sprintf (fnbuf, "/var/tmp/rltrace.%ld", getpid());
  unlink(fnbuf);
  _rl_tracefp = fopen (fnbuf, "w+");
  return _rl_tracefp != 0;
}

int
_rl_trclose ()
{
  int r;

  r = fclose (_rl_tracefp);
  _rl_tracefp = 0;
  return r;
}

#endif
@


1.7
log
@Imported readline 6.2, and upstream patch 001.

[patch 0/3] readline-6.2 rebase
http://sourceware.org/ml/gdb-patches/2011-05/msg00003.html
[patch 1/3] readline-6.2: Merge of already posted patches
http://sourceware.org/ml/gdb-patches/2011-05/msg00004.html
	=
	[Bug-readline] [RFC/readline] bind.c, rl_function_dumper, Free allocated
	http://lists.gnu.org/archive/html/bug-readline/2011-03/msg00000.html
	[Bug-readline] [patch] Fix underquotation in readline/examples/rlfe/conf
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00001.html
	[Bug-readline] [patch] Makefile.in htm<->html
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00002.html
	Re: [Bug-readline] [patch] Makefile.in dependency: callback.o: xmalloc.h
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00004.html
	[Bug-readline] [patch] Remove . from the VPATH directive
	http://lists.gnu.org/archive/html/bug-readline/2011-04/msg00005.html
	Eli Zaretskii's __MSDOS__ / __GO32__ / __MINGW32__ / __DJGPP__ stuff:
	http://sourceware.org/ml/gdb/2011-04/msg00002.html
	Jan Kratochvil's patch for FSF GDB tree local-specific changes:
	http://sourceware.org/ml/gdb/2011-04/msg00006.html
	Preservation of existing ChangeLog.gdb files, their updates.
[patch 2/3] readline-6.2: Workaround "ask" regression
http://sourceware.org/ml/gdb-patches/2011-05/msg00005.html
[patch 3/3] readline-6.2: Revert 5.x compat., apply 6.x compat.
http://sourceware.org/ml/gdb-patches/2011-05/msg00006.html
[patch 4/3] readline-6.2: Substitute inc-hist.texinfo
http://sourceware.org/ml/gdb-patches/2011-05/msg00010.html

readline/
	Workaround gdb.base/completion.exp regression on readline-6.2.
	* complete.c (get_y_or_n): Disable the return on RL_STATE_CALLBACK.

	Imported readline 6.2, and upstream patch 001.
	* configure: Regenerate.

readline/doc/
	* hsuser.texi (Using History Interactively): Disable !BashFeatures
	@@defcodeindex.  Make the `Programming with GNU History' reference
	external.
	* inc-hist.texinfo: Remove.

	Imported readline 6.2, and upstream patch 001.

readline/examples/
	Imported readline 6.2, and upstream patch 001.

readline/examples/rlfe/
	Imported readline 6.2, and upstream patch 001.

gdb/
	* config.in: Regenerate.
	* configure: Regenerate.
	* configure.ac <--with-system-readline> (for readline_echoing_p):
	Remove the test.
	* tui/tui-io.c (tui_old_readline_echoing_p): Rename to ...
	(tui_old_rl_echoing_p): ... here.
	(tui_setup_io): Rename extern declaration readline_echoing_p to
	_rl_echoing_p.  Adjust assignments for the both renames.

gdb/doc/
	* Makefile.in (GDB_DOC_SOURCE_INCLUDES): Rename inc-hist.texinfo to
	hsuser.texi.
	* gdb.texinfo <!SYSTEM_READLINE>: Rename inc-hist.texinfo inclusion and
	comment to hsuser.texi.  Change rluser.texi name in the comment.
@
text
@d392 1
a392 1
  while (--count != 0)
@


1.6
log
@Readline 5.1 import for HEAD.
@
text
@d3 1
a3 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
d5 2
a6 2
   This file is part of the GNU Readline Library, a library for
   reading lines of text with interactive input and history editing.
d8 3
a10 3
   The GNU Readline Library is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2, or
d13 3
a15 3
   The GNU Readline Library is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
d18 4
a21 4
   The GNU General Public License is often shipped with GNU software, and
   is generally kept in a file called COPYING or LICENSE.  If you do not
   have a copy of the license, write to the Free Software Foundation,
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
d69 1
a69 1
static const char *pathname_alphabetic_chars = "/-_=~.#$";
d84 1
a84 2
_rl_walphabetic (wc)
     wchar_t wc;
d111 1
a111 1
  longjmp (readline_top_level, 1);
d123 7
d194 1
d222 1
a222 1
      free (temp);
d225 1
d231 81
d369 1
a369 1
   doesn't matter. */
d375 5
a379 1
  register char ch1, ch2;
d381 3
a383 1
  while (count)
d385 4
a388 5
      ch1 = *string1++;
      ch2 = *string2++;
      if (_rl_to_upper(ch1) == _rl_to_upper(ch2))
	count--;
      else
d390 1
d392 3
a394 1
  return (count);
d397 1
a397 1
/* strcmp (), but caseless. */
d402 8
a409 1
  register char ch1, ch2;
d411 1
a411 1
  while (*string1 && *string2)
d413 3
a415 4
      ch1 = *string1++;
      ch2 = *string2++;
      if (_rl_to_upper(ch1) != _rl_to_upper(ch2))
	return (1);
d417 2
a418 1
  return (*string1 - *string2);
d451 10
d470 57
@


1.5
log
@touched all sources to ease import of readline-5.1
@
text
@d3 1
a3 1
/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
d47 1
d82 16
d104 1
a104 1
  _rl_init_argument ();
d270 1
a270 1
	    string += v - 1;	/* -1 to account for auto-increment in loop */
@


1.5.2.1
log
@Import readline 5.1 on the branch.
@
text
@d3 1
a3 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
a46 1
#include "rlmbutil.h"
a80 16
#if defined (HANDLE_MULTIBYTE)
int
_rl_walphabetic (wc)
     wchar_t wc;
{
  int c;

  if (iswalnum (wc))
    return (1);     

  c = wc & 0177;
  return (_rl_allow_pathname_alphabetic_chars &&
	    strchr (pathname_alphabetic_chars, c) != NULL);
}
#endif

d87 1
a87 1
  _rl_reset_argument ();
d253 1
a253 1
	    string1 += v - 1;	/* -1 to account for auto-increment in loop */
@


1.4
log
@Import of readline 4.3.
Non-readline modified files:

src/gdb/ChangeLog src/gdb/defs.h src/gdb/cli/cli-cmds.c
src/gdb/cli/cli-setshow.c src/gdb/tui/ChangeLog
src/gdb/tui/tuiWin.c

In readline directory:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@@


1.3
log
@readline:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Locally modified files: Makefile.in, configure.in, configure
        (regenerated), config.h.in (regenerated), readline.h, rltty.c,
 	shell.c signals.c.

        Locally added files: acconfig.h, config/*, config.h.bot,
        cross-build/*, doc/inc-hit.texinfo.

        New files: USAGE, rlprivate.h, rlshell.h, xmalloc.h.
examples:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        New files: excallback.c, rlfe.c.
doc:
2000-07-09  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * Import of readline 4.1.

        Regenerated inc-hist.texinfo as copy of hsuser.texinfo, for
        inclusion in the gdb manual.

        New file: rluserman.texinfo
@
text
@a57 2
#define SWAP(s, e)  do { int t; t = s; s = e; e = t; } while (0)

d68 1
a68 1
static char *pathname_alphabetic_chars = "/-_=~.#$";
d71 1
a71 1
alphabetic (c)
d85 1
a85 1
  ding ();
d88 1
a88 1
  rl_pending_input = 0;
d90 2
a91 2
  _rl_defining_kbd_macro = 0;
  while (_rl_executing_macro)
d94 1
a94 1
  rl_last_func = (Function *)NULL;
d114 1
a114 1
  ding ();
d133 1
a133 1
  copy = xmalloc (1 + length);
d148 1
a148 1
      rl_line_buffer = xrealloc (rl_line_buffer, rl_line_buffer_len);
d194 1
a194 1
      temp = xmalloc (len + 1);
d216 1
a216 1
     register char *s1, *s2;
d222 1
a222 1
      return (s1 + i);
d226 35
d319 2
a320 32
/* Function equivalents for the macros defined in chartypes.h. */
#undef _rl_uppercase_p
int
_rl_uppercase_p (c)
     int c;
{
  return (isupper (c));
}

#undef _rl_lowercase_p
int
_rl_lowercase_p (c)
     int c;
{
  return (islower (c));
}

#undef _rl_pure_alphabetic
int
_rl_pure_alphabetic (c)
     int c;
{
  return (isupper (c) || islower (c));
}

#undef _rl_digit_p
int
_rl_digit_p (c)
     int c;
{
  return (isdigit (c));
}
d322 7
a328 23
#undef _rl_to_lower
int
_rl_to_lower (c)
     int c;
{
  return (isupper (c) ? tolower (c) : c);
}

#undef _rl_to_upper
int
_rl_to_upper (c)
     int c;
{
  return (islower (c) ? toupper (c) : c);
}

#undef _rl_digit_value
int
_rl_digit_value (c)
     int c;
{
  return (isdigit (c) ? c - '0' : c);
}
d335 1
a335 1
     char *s;
d337 1
a337 1
  return ((char *)strcpy (xmalloc (1 + (int)strlen (s)), (s)));
@


1.3.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d58 2
d70 1
a70 1
static const char *pathname_alphabetic_chars = "/-_=~.#$";
d73 1
a73 1
rl_alphabetic (c)
d87 1
a87 1
  rl_ding ();
d90 1
a90 1
  rl_clear_pending_input ();
d92 2
a93 2
  RL_UNSETSTATE (RL_STATE_MACRODEF);
  while (rl_executing_macro)
d96 1
a96 1
  rl_last_func = (rl_command_func_t *)NULL;
d116 1
a116 1
  rl_ding ();
d135 1
a135 1
  copy = (char *)xmalloc (1 + length);
d150 1
a150 1
      rl_line_buffer = (char *)xrealloc (rl_line_buffer, rl_line_buffer_len);
d196 1
a196 1
      temp = (char *)xmalloc (len + 1);
d218 1
a218 1
     register const char *s1, *s2;
d224 1
a224 1
      return ((char *) (s1 + i));
a227 35
#ifndef HAVE_STRPBRK
/* Find the first occurrence in STRING1 of any character from STRING2.
   Return a pointer to the character in STRING1. */
char *
_rl_strpbrk (string1, string2)
     const char *string1, *string2;
{
  register const char *scan;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
  register int i, v;

  memset (&ps, 0, sizeof (mbstate_t));
#endif

  for (; *string1; string1++)
    {
      for (scan = string2; *scan; scan++)
	{
	  if (*string1 == *scan)
	    return ((char *)string1);
	}
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  v = _rl_get_char_len (string1, &ps);
	  if (v > 1)
	    string += v - 1;	/* -1 to account for auto-increment in loop */
	}
#endif
    }
  return ((char *)NULL);
}
#endif

d286 32
a317 2
/* Function equivalents for the macros defined in chardefs.h. */
#define FUNCTION_FOR_MACRO(f)	int (f) (c) int c; { return f (c); }
d319 23
a341 7
FUNCTION_FOR_MACRO (_rl_digit_p)
FUNCTION_FOR_MACRO (_rl_digit_value)
FUNCTION_FOR_MACRO (_rl_lowercase_p)
FUNCTION_FOR_MACRO (_rl_pure_alphabetic)
FUNCTION_FOR_MACRO (_rl_to_lower)
FUNCTION_FOR_MACRO (_rl_to_upper)
FUNCTION_FOR_MACRO (_rl_uppercase_p)
d348 1
a348 1
     const char *s;
d350 1
a350 1
  return (strcpy ((char *)xmalloc (1 + (int)strlen (s)), (s)));
@


1.3.22.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d58 2
d70 1
a70 1
static const char *pathname_alphabetic_chars = "/-_=~.#$";
d73 1
a73 1
rl_alphabetic (c)
d87 1
a87 1
  rl_ding ();
d90 1
a90 1
  rl_clear_pending_input ();
d92 2
a93 2
  RL_UNSETSTATE (RL_STATE_MACRODEF);
  while (rl_executing_macro)
d96 1
a96 1
  rl_last_func = (rl_command_func_t *)NULL;
d116 1
a116 1
  rl_ding ();
d135 1
a135 1
  copy = (char *)xmalloc (1 + length);
d150 1
a150 1
      rl_line_buffer = (char *)xrealloc (rl_line_buffer, rl_line_buffer_len);
d196 1
a196 1
      temp = (char *)xmalloc (len + 1);
d218 1
a218 1
     register const char *s1, *s2;
d224 1
a224 1
      return ((char *) (s1 + i));
a227 35
#ifndef HAVE_STRPBRK
/* Find the first occurrence in STRING1 of any character from STRING2.
   Return a pointer to the character in STRING1. */
char *
_rl_strpbrk (string1, string2)
     const char *string1, *string2;
{
  register const char *scan;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
  register int i, v;

  memset (&ps, 0, sizeof (mbstate_t));
#endif

  for (; *string1; string1++)
    {
      for (scan = string2; *scan; scan++)
	{
	  if (*string1 == *scan)
	    return ((char *)string1);
	}
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  v = _rl_get_char_len (string1, &ps);
	  if (v > 1)
	    string += v - 1;	/* -1 to account for auto-increment in loop */
	}
#endif
    }
  return ((char *)NULL);
}
#endif

d286 32
a317 2
/* Function equivalents for the macros defined in chardefs.h. */
#define FUNCTION_FOR_MACRO(f)	int (f) (c) int c; { return f (c); }
d319 23
a341 7
FUNCTION_FOR_MACRO (_rl_digit_p)
FUNCTION_FOR_MACRO (_rl_digit_value)
FUNCTION_FOR_MACRO (_rl_lowercase_p)
FUNCTION_FOR_MACRO (_rl_pure_alphabetic)
FUNCTION_FOR_MACRO (_rl_to_lower)
FUNCTION_FOR_MACRO (_rl_to_upper)
FUNCTION_FOR_MACRO (_rl_uppercase_p)
d348 1
a348 1
     const char *s;
d350 1
a350 1
  return (strcpy ((char *)xmalloc (1 + (int)strlen (s)), (s)));
@


1.3.16.1
log
@2002-08-24  Elena Zannoni  <ezannoni@@redhat.com>

        Import of readline 4.3:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@d58 2
d70 1
a70 1
static const char *pathname_alphabetic_chars = "/-_=~.#$";
d73 1
a73 1
rl_alphabetic (c)
d87 1
a87 1
  rl_ding ();
d90 1
a90 1
  rl_clear_pending_input ();
d92 2
a93 2
  RL_UNSETSTATE (RL_STATE_MACRODEF);
  while (rl_executing_macro)
d96 1
a96 1
  rl_last_func = (rl_command_func_t *)NULL;
d116 1
a116 1
  rl_ding ();
d135 1
a135 1
  copy = (char *)xmalloc (1 + length);
d150 1
a150 1
      rl_line_buffer = (char *)xrealloc (rl_line_buffer, rl_line_buffer_len);
d196 1
a196 1
      temp = (char *)xmalloc (len + 1);
d218 1
a218 1
     register const char *s1, *s2;
d224 1
a224 1
      return ((char *) (s1 + i));
a227 35
#ifndef HAVE_STRPBRK
/* Find the first occurrence in STRING1 of any character from STRING2.
   Return a pointer to the character in STRING1. */
char *
_rl_strpbrk (string1, string2)
     const char *string1, *string2;
{
  register const char *scan;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
  register int i, v;

  memset (&ps, 0, sizeof (mbstate_t));
#endif

  for (; *string1; string1++)
    {
      for (scan = string2; *scan; scan++)
	{
	  if (*string1 == *scan)
	    return ((char *)string1);
	}
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  v = _rl_get_char_len (string1, &ps);
	  if (v > 1)
	    string += v - 1;	/* -1 to account for auto-increment in loop */
	}
#endif
    }
  return ((char *)NULL);
}
#endif

d286 32
a317 2
/* Function equivalents for the macros defined in chardefs.h. */
#define FUNCTION_FOR_MACRO(f)	int (f) (c) int c; { return f (c); }
d319 23
a341 7
FUNCTION_FOR_MACRO (_rl_digit_p)
FUNCTION_FOR_MACRO (_rl_digit_value)
FUNCTION_FOR_MACRO (_rl_lowercase_p)
FUNCTION_FOR_MACRO (_rl_pure_alphabetic)
FUNCTION_FOR_MACRO (_rl_to_lower)
FUNCTION_FOR_MACRO (_rl_to_upper)
FUNCTION_FOR_MACRO (_rl_uppercase_p)
d348 1
a348 1
     const char *s;
d350 1
a350 1
  return (strcpy ((char *)xmalloc (1 + (int)strlen (s)), (s)));
@


1.2
log
@Dummy commit before importof 4.1 version
@
text
@d10 1
a10 1
   as published by the Free Software Foundation; either version 1, or
d21 1
a21 1
   675 Mass Ave, Cambridge, MA 02139, USA. */
d55 3
a58 17

/* Pseudo-globals imported from readline.c */
extern int readline_echoing_p;
extern procenv_t readline_top_level;
extern int rl_line_buffer_len;
extern Function *rl_last_func;

extern int _rl_defining_kbd_macro;
extern char *_rl_executing_macro;

/* Pseudo-global functions imported from other library files. */
extern void _rl_replace_text ();
extern void _rl_pop_executing_macro ();
extern void _rl_set_the_line ();
extern void _rl_init_argument ();

extern char *xmalloc (), *xrealloc ();
@


1.1
log
@Initial revision
@
text
@d67 1
d128 1
a128 1
  rl_refresh_line ();
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-08-02 snapshot
@
text
@a66 1
extern void _rl_replace_text ();
d127 1
a127 1
  rl_refresh_line (count, key);
@


1.1.1.3
log
@Import of readline 4.1
@
text
@d10 1
a10 1
   as published by the Free Software Foundation; either version 2, or
d21 1
a21 1
   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
d55 16
a70 2
#include "rlprivate.h"
#include "xmalloc.h"
d72 1
a72 1
#define SWAP(s, e)  do { int t; t = s; s = e; e = t; } while (0)
@


1.1.1.4
log
@import of readline-4.3
@
text
@d58 2
d70 1
a70 1
static const char *pathname_alphabetic_chars = "/-_=~.#$";
d73 1
a73 1
rl_alphabetic (c)
d87 1
a87 1
  rl_ding ();
d90 1
a90 1
  rl_clear_pending_input ();
d92 2
a93 2
  RL_UNSETSTATE (RL_STATE_MACRODEF);
  while (rl_executing_macro)
d96 1
a96 1
  rl_last_func = (rl_command_func_t *)NULL;
d116 1
a116 1
  rl_ding ();
d135 1
a135 1
  copy = (char *)xmalloc (1 + length);
d150 1
a150 1
      rl_line_buffer = (char *)xrealloc (rl_line_buffer, rl_line_buffer_len);
d196 1
a196 1
      temp = (char *)xmalloc (len + 1);
d218 1
a218 1
     register const char *s1, *s2;
d224 1
a224 1
      return ((char *) (s1 + i));
a227 35
#ifndef HAVE_STRPBRK
/* Find the first occurrence in STRING1 of any character from STRING2.
   Return a pointer to the character in STRING1. */
char *
_rl_strpbrk (string1, string2)
     const char *string1, *string2;
{
  register const char *scan;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
  register int i, v;

  memset (&ps, 0, sizeof (mbstate_t));
#endif

  for (; *string1; string1++)
    {
      for (scan = string2; *scan; scan++)
	{
	  if (*string1 == *scan)
	    return ((char *)string1);
	}
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  v = _rl_get_char_len (string1, &ps);
	  if (v > 1)
	    string += v - 1;	/* -1 to account for auto-increment in loop */
	}
#endif
    }
  return ((char *)NULL);
}
#endif

d286 32
a317 2
/* Function equivalents for the macros defined in chardefs.h. */
#define FUNCTION_FOR_MACRO(f)	int (f) (c) int c; { return f (c); }
d319 23
a341 7
FUNCTION_FOR_MACRO (_rl_digit_p)
FUNCTION_FOR_MACRO (_rl_digit_value)
FUNCTION_FOR_MACRO (_rl_lowercase_p)
FUNCTION_FOR_MACRO (_rl_pure_alphabetic)
FUNCTION_FOR_MACRO (_rl_to_lower)
FUNCTION_FOR_MACRO (_rl_to_upper)
FUNCTION_FOR_MACRO (_rl_uppercase_p)
d348 1
a348 1
     const char *s;
d350 1
a350 1
  return (strcpy ((char *)xmalloc (1 + (int)strlen (s)), (s)));
@


1.1.1.5
log
@import of readlilne 5.1
@
text
@d3 1
a3 1
/* Copyright (C) 1987-2005 Free Software Foundation, Inc.
a46 1
#include "rlmbutil.h"
a80 16
#if defined (HANDLE_MULTIBYTE)
int
_rl_walphabetic (wc)
     wchar_t wc;
{
  int c;

  if (iswalnum (wc))
    return (1);     

  c = wc & 0177;
  return (_rl_allow_pathname_alphabetic_chars &&
	    strchr (pathname_alphabetic_chars, c) != NULL);
}
#endif

d87 1
a87 1
  _rl_reset_argument ();
d253 1
a253 1
	    string1 += v - 1;	/* -1 to account for auto-increment in loop */
@


