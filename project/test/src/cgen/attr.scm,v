head	1.17;
access;
symbols
	sid-snapshot-20180601:1.17
	cgen-snapshot-20180601:1.17
	sid-snapshot-20180501:1.17
	cgen-snapshot-20180501:1.17
	sid-snapshot-20180401:1.17
	cgen-snapshot-20180401:1.17
	sid-snapshot-20180301:1.17
	cgen-snapshot-20180301:1.17
	sid-snapshot-20180201:1.17
	cgen-snapshot-20180201:1.17
	sid-snapshot-20180101:1.17
	cgen-snapshot-20180101:1.17
	sid-snapshot-20171201:1.17
	cgen-snapshot-20171201:1.17
	sid-snapshot-20171101:1.17
	cgen-snapshot-20171101:1.17
	sid-snapshot-20171001:1.17
	cgen-snapshot-20171001:1.17
	sid-snapshot-20170901:1.17
	cgen-snapshot-20170901:1.17
	sid-snapshot-20170801:1.17
	cgen-snapshot-20170801:1.17
	sid-snapshot-20170701:1.17
	cgen-snapshot-20170701:1.17
	sid-snapshot-20170601:1.17
	cgen-snapshot-20170601:1.17
	sid-snapshot-20170501:1.17
	cgen-snapshot-20170501:1.17
	sid-snapshot-20170401:1.17
	cgen-snapshot-20170401:1.17
	sid-snapshot-20170301:1.17
	cgen-snapshot-20170301:1.17
	sid-snapshot-20170201:1.17
	cgen-snapshot-20170201:1.17
	sid-snapshot-20170101:1.17
	cgen-snapshot-20170101:1.17
	sid-snapshot-20161201:1.17
	cgen-snapshot-20161201:1.17
	sid-snapshot-20161101:1.17
	cgen-snapshot-20161101:1.17
	sid-snapshot-20160901:1.17
	cgen-snapshot-20160901:1.17
	sid-snapshot-20160801:1.17
	cgen-snapshot-20160801:1.17
	sid-snapshot-20160701:1.17
	cgen-snapshot-20160701:1.17
	sid-snapshot-20160601:1.17
	cgen-snapshot-20160601:1.17
	sid-snapshot-20160501:1.17
	cgen-snapshot-20160501:1.17
	sid-snapshot-20160401:1.17
	cgen-snapshot-20160401:1.17
	sid-snapshot-20160301:1.17
	cgen-snapshot-20160301:1.17
	sid-snapshot-20160201:1.17
	cgen-snapshot-20160201:1.17
	sid-snapshot-20160101:1.17
	cgen-snapshot-20160101:1.17
	sid-snapshot-20151201:1.17
	cgen-snapshot-20151201:1.17
	sid-snapshot-20151101:1.17
	cgen-snapshot-20151101:1.17
	sid-snapshot-20151001:1.17
	cgen-snapshot-20151001:1.17
	sid-snapshot-20150901:1.17
	cgen-snapshot-20150901:1.17
	sid-snapshot-20150801:1.17
	cgen-snapshot-20150801:1.17
	sid-snapshot-20150701:1.17
	cgen-snapshot-20150701:1.17
	sid-snapshot-20150601:1.17
	cgen-snapshot-20150601:1.17
	sid-snapshot-20150501:1.17
	cgen-snapshot-20150501:1.17
	sid-snapshot-20150401:1.17
	cgen-snapshot-20150401:1.17
	sid-snapshot-20150301:1.17
	cgen-snapshot-20150301:1.17
	sid-snapshot-20150201:1.17
	cgen-snapshot-20150201:1.17
	sid-snapshot-20150101:1.17
	cgen-snapshot-20150101:1.17
	sid-snapshot-20141201:1.17
	cgen-snapshot-20141201:1.17
	sid-snapshot-20141101:1.17
	cgen-snapshot-20141101:1.17
	sid-snapshot-20141001:1.17
	cgen-snapshot-20141001:1.17
	sid-snapshot-20140901:1.17
	cgen-snapshot-20140901:1.17
	sid-snapshot-20140801:1.17
	cgen-snapshot-20140801:1.17
	sid-snapshot-20140701:1.17
	cgen-snapshot-20140701:1.17
	sid-snapshot-20140601:1.17
	cgen-snapshot-20140601:1.17
	sid-snapshot-20140501:1.17
	cgen-snapshot-20140501:1.17
	sid-snapshot-20140401:1.17
	cgen-snapshot-20140401:1.17
	sid-snapshot-20140301:1.17
	cgen-snapshot-20140301:1.17
	sid-snapshot-20140201:1.17
	cgen-snapshot-20140201:1.17
	sid-snapshot-20140101:1.17
	cgen-snapshot-20140101:1.17
	sid-snapshot-20131201:1.17
	cgen-snapshot-20131201:1.17
	sid-snapshot-20131101:1.17
	cgen-snapshot-20131101:1.17
	sid-snapshot-20131001:1.17
	cgen-snapshot-20131001:1.17
	sid-snapshot-20130901:1.17
	cgen-snapshot-20130901:1.17
	sid-snapshot-20130801:1.17
	cgen-snapshot-20130801:1.17
	sid-snapshot-20130701:1.17
	cgen-snapshot-20130701:1.17
	sid-snapshot-20130601:1.17
	cgen-snapshot-20130601:1.17
	sid-snapshot-20130501:1.17
	cgen-snapshot-20130501:1.17
	sid-snapshot-20130401:1.17
	cgen-snapshot-20130401:1.17
	sid-snapshot-20130301:1.17
	cgen-snapshot-20130301:1.17
	sid-snapshot-20130201:1.17
	cgen-snapshot-20130201:1.17
	sid-snapshot-20130101:1.17
	cgen-snapshot-20130101:1.17
	sid-snapshot-20121201:1.17
	cgen-snapshot-20121201:1.17
	sid-snapshot-20121101:1.17
	cgen-snapshot-20121101:1.17
	sid-snapshot-20121001:1.17
	cgen-snapshot-20121001:1.17
	sid-snapshot-20120901:1.17
	cgen-snapshot-20120901:1.17
	sid-snapshot-20120801:1.17
	cgen-snapshot-20120801:1.17
	sid-snapshot-20120701:1.17
	cgen-snapshot-20120701:1.17
	sid-snapshot-20120601:1.17
	cgen-snapshot-20120601:1.17
	sid-snapshot-20120501:1.17
	cgen-snapshot-20120501:1.17
	sid-snapshot-20120401:1.17
	cgen-snapshot-20120401:1.17
	sid-snapshot-20120301:1.17
	cgen-snapshot-20120301:1.17
	sid-snapshot-20120201:1.17
	cgen-snapshot-20120201:1.17
	sid-snapshot-20120101:1.17
	cgen-snapshot-20120101:1.17
	sid-snapshot-20111201:1.17
	cgen-snapshot-20111201:1.17
	sid-snapshot-20111101:1.17
	cgen-snapshot-20111101:1.17
	sid-snapshot-20111001:1.17
	cgen-snapshot-20111001:1.17
	sid-snapshot-20110901:1.17
	cgen-snapshot-20110901:1.17
	sid-snapshot-20110801:1.17
	cgen-snapshot-20110801:1.17
	sid-snapshot-20110701:1.17
	cgen-snapshot-20110701:1.17
	sid-snapshot-20110601:1.17
	cgen-snapshot-20110601:1.17
	sid-snapshot-20110501:1.17
	cgen-snapshot-20110501:1.17
	sid-snapshot-20110401:1.17
	cgen-snapshot-20110401:1.17
	sid-snapshot-20110301:1.17
	cgen-snapshot-20110301:1.17
	sid-snapshot-20110201:1.17
	cgen-snapshot-20110201:1.17
	sid-snapshot-20110101:1.17
	cgen-snapshot-20110101:1.17
	sid-snapshot-20101201:1.17
	cgen-snapshot-20101201:1.17
	sid-snapshot-20101101:1.17
	cgen-snapshot-20101101:1.17
	sid-snapshot-20101001:1.17
	cgen-snapshot-20101001:1.17
	sid-snapshot-20100901:1.17
	cgen-snapshot-20100901:1.17
	sid-snapshot-20100801:1.17
	cgen-snapshot-20100801:1.17
	sid-snapshot-20100701:1.17
	cgen-snapshot-20100701:1.17
	sid-snapshot-20100601:1.17
	cgen-snapshot-20100601:1.17
	sid-snapshot-20100501:1.17
	cgen-snapshot-20100501:1.17
	sid-snapshot-20100401:1.17
	cgen-snapshot-20100401:1.17
	sid-snapshot-20100301:1.17
	cgen-snapshot-20100301:1.17
	sid-snapshot-20100201:1.17
	cgen-snapshot-20100201:1.17
	sid-snapshot-20100101:1.17
	cgen-snapshot-20100101:1.17
	sid-snapshot-20091201:1.17
	cgen-snapshot-20091201:1.17
	sid-snapshot-20091101:1.16
	cgen-snapshot-20091101:1.16
	sid-snapshot-20091001:1.13
	cgen-snapshot-20091001:1.13
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.10
	cgen-snapshot-20090901:1.10
	sid-snapshot-20090801:1.8
	cgen-snapshot-20090801:1.8
	sid-snapshot-20090701:1.7
	cgen-snapshot-20090701:1.7
	dje-cgen-play1-branch:1.7.0.2
	dje-cgen-play1-branchpoint:1.7
	cgen-1_1-branch:1.6.0.2
	cgen-1_1-branchpoint:1.6
	sid-snapshot-20090601:1.5
	cgen-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	cgen-snapshot-20090501:1.5
	sid-snapshot-20090401:1.5
	cgen-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.2
	arc-insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	cgen-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	cgen-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	cgen-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	cgen-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	cgen-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	cgen-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	cgen-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	cgen-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	cgen-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	cgen-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	cgen-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	cgen-snapshot-20080401:1.5
	sid-snapshot-20080301:1.5
	cgen-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	cgen-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	cgen-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	cgen-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	cgen-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	cgen-snapshot-20071001:1.5
	msnyder-fork-checkpoint-branch:1.4.0.2
	msnyder-fork-checkpoint-branchpoint:1.4
	sid-20020905-branchpoint:1.1.1.1
	sid-20020905-branch:1.1.1.1.0.6
	cagney_regbuf-20020515-branch:1.1.1.1.0.4
	cagney_regbuf-20020515-branchpoint:1.1.1.1
	cygnus_cvs_20020108_pre:1.1.1.1
	cgen-1-1-branch:1.1.1.1.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.17
date	2009.11.03.16.24.01;	author devans;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.26.00.56.34;	author devans;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.26.00.25.33;	author devans;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.25.16.30.42;	author devans;	state Exp;
branches;
next	1.13;

1.13
date	2009.09.23.22.30.19;	author devans;	state Exp;
branches;
next	1.12;

1.12
date	2009.09.12.17.34.15;	author devans;	state Exp;
branches;
next	1.11;

1.11
date	2009.09.07.22.17.33;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2009.08.12.22.33.37;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2009.08.05.20.30.36;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2009.07.18.20.44.58;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.14.17.09.56;	author devans;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2007.02.05.19.43.30;	author brolley;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.28.19.30.02;	author brolley;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.16.05.35.47;	author devans;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.10.21.22.02;	author devans;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.6.2.1
date	2009.06.24.14.57.45;	author devans;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.17
log
@	Specify isa(s) when doing ifield, operand, insn lookups.
	ACU = all callers updated.
	* attr.scm (/attr-eval): Call rtx-value instead of rtx-eval-with-estate.
	* enum.scm (define-full-insn-enum): Pass isa-name-list to
	current-ifld-lookup.
	* html.scm (get-insn-properties): Pass isa-name-list to
	current-op-lookup.
	* ifield.scm (/ifld-parse-follows): New arg isas, ACU.
	* insn.scm (/parse-insn-format-symbol): New arg isa-name-list, ACU.
	(/parse-insn-format-list, /parse-insn-iformat-iflds): Ditto.
	(/parse-insn-format, syntax-break-out): Ditto.
	* mach.scm (obj-filter-by-isa): New function.
	(current-ifld-lookup): New optional arg maybe-isa-name-list.
	(/ifld-already-defined?, /op-already-defined?): Simplify.
	(current-op-lookup): New optional arg maybe-isa-name-list.
	(current-insn-lookup): New arg isa-name-list, ACU.
	(/insn-already-defined?, /minsn-already-defined?): Simplify.
	(current-minsn-lookup): New arg isa-name-list, ACU.
	* minsn.scm (/minsn-compute-iflds): Pass isa-name-list to
	current-op-lookup.
	* opc-itab.scm (compute-syntax): New arg isa-name-list, ACU.
	(gen-syntax-entry): Ditto.
	* operand.scm (/operand-parse): Pass isa-name-list to
	current-ifld-lookup.
	(/derived-parse-encoding): New arg isa-name-list, ACU.
	(/derived-parse-ifield-assertion): Ditto.
	(/derived-operand-parse): Pass isa-name-list to current-op-lookup.
	(/anyof-parse-choice): Ditto.
	(anyof-satisfies-assertions?): Pass context to rtx-solve.
	(/anyof-merge-syntax): New arg container, ACU.
	(operand-builtin!): Add pc to all isas.
	* rtl-c.scm (estate-make-for-rtl-c): Delete arg extra-vars-alist, ACU.
	(estate-make-for-rtl-c++, rtl-c-expr-parsed): Ditto.
	(rtl-c-parsed, rtl-c++-parsed): Ditto.
	(rtl-c): New arg isa-name-list, ACU.
	(rtl-c-expr, rtl-c++): Ditto.
	(closure): New arg isa-name-list, ACU.
	* rtl-traverse.scm (/make-cstate): New arg isa-name-list, ACU.
	(/cstate-isas): New function.
	(/rtx-canon-symbol-list): New function.
	(/rtx-canon-env-stack): Renamed from /rtx-canon-env, ACU.
	updated.
	(/rtx-make-canon-table): Rename ENV to ENVSTACK, new entry SYMBOLLIST.
	(/rtx-canon-rtx-operand): Pass isa list to current-op-lookup.
	(/rtx-canon-rtx-ref, /rtx-canon): Ditto.
	(rtx-canonicalize): New arg isa-name-list, ACU.
	(rtx-canonicalize-stmt): Delete.
	(tstate-make): New arg isas, ACU.
	(tstate-isas, tstate--set-isas!): New functions.
	(tstate-env-stack): Renamed from tstate-env, ACU.
	(tstate-set-env-stack!): Renamed from tstate-set-env!, ACU.
	(tstate-make-closure): Renamed from tstate-new-env, new arg
	isa-name-list, ACU.
	(/rtx-traverse-env): Delete.
	(/rtx-make-traverser-table): Rename ENV to ENVSTACK, new entry
	SUMBOLLIST.
	(/rtx-traverse): Include conditional flag in dump output.
	Update isa,envstack for closures.  Pass isa list to current-op-lookup.
	(<eval-state>): New member isas.  Rename env to env-stack.
	(<eval-state> vmake!): Handle #:isas.  #:env renamed to #:env-stack.
	(<eval-state>): New getter/setter for isas.  Rename env getter/setter
	to env-stack.
	(estate-make-for-eval): Provide #:isas.
	(estate-make-closure): Renamed from estate-new-env.  New arg
	isa-name-list, ACU.
	* rtl-xform.scm (/rtx-simplify-expr-fn): Handle closures.
	(/rtx-trim-args): ENV renamed to ENVSTACK.  Ad ITERATION, SYMBOLLIST.
	(/rtx-trim-for-doc): Handle closures.
	* rtl.scm (/rtx-valid-types): Rename ENV to ENVSTACK.  Add ITERATION,
	SYMBOLLIST.
	(rtx-env-var-list): Delete.
	(rtx-env-make): Handle already-compiled environments.
	(rtx-var-alist-to-env): New function.
	(rtx-var-alist-to-closure-env-stack, rtx-make-env-stack): New functions.
	(rtx-env-stack-dump): Renamed from rtx-env-dump, ACU.
	(rtx-operand-obj): New arg isa-name-list, ACU.
	(rtx-closure-isas, rtx-closure-env-stack, rtx-closure-expr): New
	functions.
	* rtx-funcs.scm (closure): New arg isa-name-list, reorder args, ACU.
	* sem-frags.scm (<sfrag>): Delete member compiled-semantics.
	(/frag-compute-desired-frags): Minor simplification.
	(/frag-pick-best): Ditto.
	* sid-cpu.scm (gen-semantic-code): Require canonical rtl.
	(/gen-sfrag-code): Update.
	* sim-cpu.scm (gen-semantic-code): Require canonical rtl.
	* utils-cgen.scm (sanitize): New arg isa-name-list, ACU.
	* utils.scm (non-null-intersection?): New function.
@
text
@; Attributes.
; Copyright (C) 2000, 2003, 2005, 2009 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.

; There are 5 kinds of attributes: boolean, integer, enum, bitset, and string.
; Boolean attributes are really enum attributes with two possible values,
; but they occur frequently enough that they are special cased.
; String attributes are intentionally not documented in the manual as
; being supported - they're still a bit of work-in-progress.
;
; All objects that use attributes must have two methods:
; - 'get-atlist - returns the object's attr-list
; - 'set-atlist! - set the object's attr-list
;
; In .cpu files, attribute lists are associative lists of (NAME VALUE).
; Boolean attributes are specified as (NAME #t) or (NAME #f),
; but for convenience ATTR and !ATTR are also supported.
; integer/enum attrs are specified as (ATTR value).
; string attrs are specified as (ATTR "value").
; Bitset attrs are specified as (ATTR val1 val2 val3), each value must be
; a valid Scheme symbol (stick with valid C symbols + "-" and you'll be fine).
; For backwards compatibility (ATTR val1,val2,val3) and
; (ATTR "val1,val2,val3") are also supported for bitset values.
; val1,val2,val3 is not portable (e.g. mzscheme will reject it).
; In all cases the value needn't be constant, and can be an expression,
; though expressions are currently only supported for META-attributes
; (attributes that don't appear in any generated code).
;
; Example:
; (FOO1 !FOO2 (BAR 3) (FOO3 X) (MACH sparc sparclite))
;
; ??? Implementation of expressions is being postponed as long
; as possible, avoiding adding complications for complication's sake, and
; because I'm not completely sure how I want to do them.
; The syntax for an expression value is (ATTR (rtx-func ...)).
;
; ??? May wish to allow a bitset attribute like (ATTR val1 !val2), where `!'
; means to turn off that particular bit (or bits if val2 refers to several).
;
; ??? May wish to allow specifying enum attributes by only having to
; specify the value (move names into "enum space" or some such).

; An attr-list (or "atlist") is a collection of attributes.
; Attributes are stored as an associative list.
; There is possible confusion between "alist" (associative-list) and
; "atlist" (attribute-list) but in practice I haven't had a problem.
; ??? May wish to change this to a list of objects, as the alist doesn't carry
; enough info.  However the alist is simple and fast.

(define <attr-list> (class-make '<attr-list> nil '(prefix attrs) nil))

(define atlist-prefix (elm-make-getter <attr-list> 'prefix))
(define atlist-attrs (elm-make-getter <attr-list> 'attrs))

(define (atlist? x) (class-instance? <attr-list> x))

; An empty attribute-list.

(define atlist-empty (make <attr-list> "" nil))

; The attribute baseclass.
; The attributes of <ident> are the set of attributes for this attribute
; [meaning attributes themselves can have attributes].
; [Ya, that's clumsily written.  I left it that way for fun.]
; An odd notion that is of some use.  It's current raison d'etre is to
; support sanitization of attributes [which is implemented with the
; `sanitize' attribute].

(define <attribute>
  (class-make '<attribute>
	      '(<ident>)
	      '(
		; List of object types this attribute is for.
		; Possible element values are:
		; attr, enum, cpu, mach, model, ifield, hardware, operand,
		; insn
		; A value of #f means the attribute is for everything.
		for
		)
	      nil)
)

; Accessors.

(define atlist-for (elm-make-getter <attribute> 'for))

; A class for each type of attribute.

; `values' exists for boolean-attribute to simplify the code, it's ignored.
; Ditto for `default'.  The default for boolean-attribute is always #f.

(define <boolean-attribute>
  (class-make '<boolean-attribute>
	      '(<attribute>)
	      '(default values)
	      nil)
)

; VALUES is ignored for string-attribute.

(define <string-attribute>
  (class-make '<string-attribute>
	      '(<attribute>)
	      '(default values)
	      nil)
)

; For bitset attributes VALUES is a list of
; (symbol bit-number-or-#f attr-list comment-or-#f),
; one for each bit.
; If bit-number is #f (unspecified), cgen will choose.
; Int's are used to record the bitset in the generated code so there's a limit
; of 32 elements, though there's nothing inherent in the description language
; that precludes removing the limit.
; NOTE: While one might want to record each element as an object, there's
; currently no need for the added complexity.

(define <bitset-attribute>
  (class-make '<bitset-attribute>
	      '(<attribute>)
	      '(default values)
	      nil)
)

; For integer attributes VALUES is a list of (int),
; one for each possible value,
; or the empty list of all values are permissible.
; Note that each element is itself a list.  This is for consistency.

(define <integer-attribute>
  (class-make '<integer-attribute>
	      '(<attribute>)
	      '(default values)
	      nil)
)

; For enum attributes VALUES is a list of
; (symbol enum-value-or-#f attr-list comment-or-#f),
; one for each possible.
; If enum-value is #f (unspecified) cgen will apply the standard rule for
; assigning enum values.
; NOTE: While one might want to record each element as an object, there's
; currently no need for the added complexity.

(define <enum-attribute>
  (class-make '<enum-attribute>
	      '(<attribute>)
	      '(default values)
	      nil)
)

; Return a boolean indicating if X is a <boolean-attribute> object.

(define (bool-attr? x) (class-instance? <boolean-attribute> x))

; Return a symbol indicating the kind of attribute ATTR is.
; The result is one of boolean,integer,enum,bitset or string.

(define (attr-kind attr)
  (case (object-class-name attr)
    ((<boolean-attribute>) 'boolean)
    ((<string-attribute>)  'string)
    ((<integer-attribute>) 'integer)
    ((<enum-attribute>)    'enum)
    ((<bitset-attribute>)  'bitset)
    (else (error "attr-kind: internal error, not an attribute class"
		 (object-class-name attr))))
)

; Accessors.

(define (attr-default attr) (elm-xget attr 'default))
(define (attr-values attr) (elm-xget attr 'values))

; Create an attribute.
; Attributes are stored in attribute lists using the actual value
; rather than an object containing the value, so we only have to cons
; NAME and VALUE rather than building some object.  This is for simplicity
; and speed.  We try to incrementally complicate things, only as necessary.

; VALUE must be #f or #t.

(define (bool-attr-make name value) (cons name value))

; VALUES must be a list of symbols.
; E.g., (val1 val2) not val1,val2.

(define (bitset-attr-make name values) (cons name values))

; VALUE must be a number (or maybe a symbol).

(define (int-attr-make name value) (cons name value))

; VALUE must be a symbol.

(define (enum-attr-make name value) (cons name value))

;; Return a procedure to parse an attribute.
;; RIGHT-TYPE? is a procedure that verifies the value is the right type.
;; MESSAGE is printed if there is an error.
;; The result of the parsed attribute is (name . value).

(define (/parse-simple-attribute right-type? message)
  (lambda (self context val)
    (if (and (not (null? val))
	     (right-type? (car val))
	     (null? (cdr val)))
	(cons (obj:name self) (car val))
	(parse-error context message (cons (obj:name self) val))))
)

; A boolean attribute's value is either #t or #f.

(method-make!
 <boolean-attribute> 'parse-value
 (/parse-simple-attribute boolean? "boolean attribute not one of #f/#t")
)

(method-make!
 <string-attribute> 'parse-value
 (/parse-simple-attribute string? "invalid argument to string attribute"))

; A bitset attribute's value is a list of symbols.
; For backwards compatibility (ATTR val1,val2,val3) and
; (ATTR "val1,val2,val3") are also supported for bitset values.
; val1,val2,val3 is not portable (e.g. mzscheme will reject it).
;
; We don't validate the values.  In the case of the MACH attribute,
; there's no current mechanism to create it after all define-mach's have
; been read in.
; ??? Need to decide whether all define-mach's must appear before any
; define-insn's.  It would be nice to be able to spread an architecture's
; description over several .cpu files.
; ??? On the other hand, all machs are specified in define-arch.
; Perhaps creation of builtins could be defered until then.

(method-make!
 <bitset-attribute> 'parse-value
 (lambda (self context val)
   (let ((value (if (and (= (length val) 1)
			 (or (symbol? (car val)) (string? (car val))))
		    (map string->symbol (string-cut (->string (car val)) #\,))
		    val))
	 (message "improper bitset attribute"))
     ;; NOTE: An empty list is ok.
     (if (all-true? (map symbol? value))
	 (cons (obj:name self) value)
	 (parse-error context message (cons (obj:name self) val)))))
)

; An integer attribute's value is a number
; (or maybe a symbol representing that value).

(method-make!
 <integer-attribute> 'parse-value
 (/parse-simple-attribute (lambda (x) (or (number? x) (symbol? x)))
			  "improper integer attribute")
)

; An enum attribute's value is a symbol representing that value.

(method-make!
 <enum-attribute> 'parse-value
 (/parse-simple-attribute (lambda (x) (or (symbol? x) (string? x)))
			  "improper enum attribute")
)

; Parse a boolean attribute's value definition.

(method-make!
 <boolean-attribute> 'parse-value-def
 (lambda (self context values)
   (if (equal? values '(#f #t))
       values
       (parse-error context "boolean value list must be (#f #t)" values)))
)

; Ignore values for strings.
; They're not supported and /attr-read catches this.

(method-make!
 <string-attribute> 'parse-value-def
 (lambda (self context values) #f)
)

; Parse a bitset attribute's value definition.

(method-make!
 <bitset-attribute> 'parse-value-def
 (lambda (self context values)
   ;; parse-enum-vals works well enough
   (parse-enum-vals context "" values))
)

; Parse an integer attribute's value definition.
; VALUES may be #f which means any value is ok.
; A fixed set of VALUES is work-in-progress.

(method-make!
 <integer-attribute> 'parse-value-def
 (lambda (self context values)
   (if values
       (for-each (lambda (val)
		   ;; A list entry is for providing a sanitization key.
		   (if (or (not (list? val))
			   (not (number? (car val))))
		       (parse-error context
				    "invalid element in integer attribute list"
				    val)))
		 values))
   values)
)

; Parse an enum attribute's value definition.
; See parse-enum-vals for more info.

(method-make!
 <enum-attribute> 'parse-value-def
 (lambda (self context values)
   (parse-enum-vals context "" values))
)

; Make an attribute list object from a list of name/value pairs.

(define (atlist-make prefix . attrs) (make <attr-list> prefix attrs))

; Parse an attribute definition.
; This is the main routine for building an attribute object from a
; description in the .cpu file.
; All arguments are in raw (non-evaluated) form.
; TYPE-CLASS is the class of the object to create.
; i.e. one of <{boolean,bitset,integer,enum,string}-attribute>.
; For enum attributes, if DEFAULT is #f use the first value.
; For all other attribute kinds, we use what /attr-read gives us.
; ??? Allowable values for integer attributes is wip,
; for now it is the portable set of integers (int32_t).

(define (/attr-parse context type-class name comment attrs for default values)
  (logit 2 "Processing attribute " name " ...\n")

  ;; Pick out name first to augment the error context.
  (let* ((name (parse-name context name))
	 (context (context-append-name context name))
	 (result (new type-class))
	 (parsed-values (send result 'parse-value-def context values)))

    (elm-xset! result 'name name)
    (elm-xset! result 'comment (parse-comment context comment))
    (elm-xset! result 'attrs (atlist-parse context attrs ""))
    (elm-xset! result 'for for)

    ;; Set the default.
    ;; FIXME: Clean up with /attr-read.
    (case (class-name type-class)
      ((<boolean-attribute>)
       ;; ??? docs say default must be #f, but we want to allow an rtx to
       ;; specify the default.
       (if (and (not (memq default '(#f #t)))
		(not (/attr-val-is-rtx? default)))
	   (parse-error context "invalid default" default))
       (elm-xset! result 'default default))
      ((<string-attribute>)
       (let ((default (or default "")))
	 (if (and (not (string? default))
		  (not (/attr-val-is-rtx? default)))
	     (parse-error context "invalid default" default))
	 (elm-xset! result 'default default)))
      ((<integer-attribute>)
       (let ((default (if default default (if (null? values) 0 (car values)))))
	 (if (and (not (integer? default))
		  (not (/attr-val-is-rtx? default)))
	     (parse-error context "invalid default" default))
	 (elm-xset! result 'default default)))
      ((<enum-attribute>)
       (let ((default (if default default (caar parsed-values))))
	 (if (and (not (assq default parsed-values))
		  (not (/attr-val-is-rtx? default)))
	     (parse-error context "invalid default" default))
	 (elm-xset! result 'default default)))
      ((<bitset-attribute>)
       ;; bitset attributes must specify a default, /attr-read catches this
       (assert default)
       ;; It's also /attr-read's job to ensure it is a list.
       (assert (list? default))
       (let ((default default))
	 ;; NOTE: We don't allow an rtx for bitset attributes,
	 ;; the rtl language currently doesn't support them.
	 (if (/attr-val-is-rtx? default)
	     (parse-error context "invalid default, rtx not supported for bitset" default))
	 (if (not (all-true? (map (lambda (v) (assq v parsed-values))
				  default)))
	     (parse-error context "invalid default" default))
	 (elm-xset! result 'default default))))

    (elm-xset! result 'values parsed-values)

    result)
)

; Read an attribute description
; This is the main routine for analyzing attributes in the .cpu file.
; CONTEXT is a <context> object for error messages.
; ARG-LIST is an associative list of field name and field value.
; /attr-parse is invoked to create the attribute object.

(define (/attr-read context . arg-list)
  (let (
	(type 'not-set) ;; attribute type
	(type-class 'not-set) ;; attribute class
	(name #f)
	(comment "")
	(attrs nil)
	(for #f) ;; assume for everything
	(default #f) ;; #f indicates "not set"
	(values #f) ;; #f indicates "not set"
	)

    ;; Loop over each element in ARG-LIST, recording what's found.
    (let loop ((arg-list arg-list))
      (if (null? arg-list)
	  nil
	  (let ((arg (car arg-list))
		(elm-name (caar arg-list)))
	    (case elm-name
	      ((type)
	       (set! type-class (case (cadr arg)
				  ((boolean) <boolean-attribute>)
				  ((string) <string-attribute>)
				  ((bitset) <bitset-attribute>)
				  ((integer) <integer-attribute>)
				  ((enum) <enum-attribute>)
				  (else (parse-error
					 context
					 "invalid attribute type"
					 (cadr arg)))))
	       (set! type (cadr arg)))
	      ((name) (set! name (cadr arg)))
	      ((comment) (set! comment (cadr arg)))
	      ((attrs) (set! attrs (cdr arg)))
	      ((for) (set! for (cdr arg)))
	      ((default) (set! default (cdr arg)))
	      ((values) (set! values (cdr arg)))
	      (else (parse-error context "invalid attribute arg" arg)))
	    (loop (cdr arg-list)))))

    ;; Must have type now.
    (if (eq? type-class 'not-set)
	(parse-error context "type not specified") arg-list)

    ;; For scalar attributes, fix up the default.
    (if (and default (memq type '(boolean string integer enum)))
	(begin
	  (if (!= (length default) 1)
	      (parse-error context "invalid default" default))
	  ;; Don't change rtx values.
	  (if (not (pair? (car default)))
	      (set! default (car default)))))

    ;; Establish proper defaults now that we know the type.
    ;; FIXME: Clean up with /attr-parse.
    (case type
      ((boolean)
       (if (eq? default #f)
	   (set! default #f)) ;; really a nop, but for consistency
       (if (eq? values #f)
	   (set! values '(#f #t))))
      ((bitset) ;; FIXME
       (if (eq? default #f)
	   (parse-error context "bitset attribute default not specified"
			arg-list))
       (if (eq? values #f)
	   (parse-error context "bitset attribute values not specified"
			arg-list)))
      ((integer) ;; FIXME
       (if (eq? default #f)
	   (set! default 0))
       (if (eq? values #f)
	   (set! values #f))) ;; really a nop, but for consistency
      ((enum) ;; FIXME
;; There are some existing cases where no default is specified,
;; expecting that the first value is the default.
;;     (if (eq? default #f)
;;	   (parse-error context "enum attribute default not specified"
;;			arg-list))
       (if (eq? values #f)
	   (parse-error context "enum attribute values not specified"
			arg-list)))
      ((string)
       (if (eq? default #f)
	   (set! default ""))
       (if (not (eq? values #f))
	   (parse-error context "string attribute values specified"
			arg-list)))
      )

    ;; Now that we've identified the elements, build the object.
    (/attr-parse context type-class name comment attrs for default values))
)

; Main routines for defining attributes in .cpu files.

(define define-attr
  (lambda arg-list
    (let ((a (apply /attr-read (cons (make-current-context "define-attr")
				     arg-list))))
      (current-attr-add! a)
      a))
)

; Query routines.

; Lookup ATTR-NAME in ATTR-LIST.
; The result is the object or #f if not found.

(define (attr-lookup attr-name attr-list)
  (object-assq attr-name attr-list)
)

; Return a boolean indicating if boolean attribute ATTR is "true" in
; attribute alist ALIST.
; Note that if the attribute isn't present, it is defined to be #f.

(method-make!
 <attr-list> 'has-attr?
 (lambda (self attr)
   (let ((a (assq attr (elm-get self 'attrs))))
     (cond ((not a) a)
	   ((boolean? (cdr a)) (cdr a))
	   (else (error "Not a boolean attribute:" attr)))))
)

(define (atlist-has-attr? atlist attr)
  (send atlist 'has-attr? attr)
)

; Return a boolean indicating if attribute ATTR is present in
; attribute alist ALIST.

(method-make!
 <attr-list> 'attr-present?
 (lambda (self attr)
   (->bool (assq attr (elm-get self 'attrs))))
)

(define (atlist-attr-present? atlist attr)
  (send atlist 'attr-present? attr)
)

;; Return #t if attribute value VAL is an rtx expression.
;; RTXs in attributes are recorded as a list of one element
;; which is the rtx.
;; I.e., ((rtx foo bar)).

(define (/attr-val-is-rtx? val)
  (and (pair? val)
       (null? (cdr val))
       (pair? (car val))) ;; pair? -> cheap non-null-list?
)

; Expand attribute value ATVAL, which is an rtx expression.
; OWNER is the containing object or #f if there is none.
; OWNER is needed if an attribute is defined in terms of other attributes.
; OWNER is also needed to get the ISA(s) in which to evaluate the expression.
; If it's #f obviously ATVAL can't be defined in terms of others,
; or refer to operands that require an ISA to disambiguate.

(define (/attr-eval atval owner)
  (let* ((atval-expr (car atval))
	 (expr (rtx-simplify #f owner
			     (rtx-canonicalize #f 'DFLT
					       (and owner (obj-isa-list owner))
					       nil atval-expr)
			     nil))
	 (value (rtx-value expr owner)))
    (cond ((symbol? value) value)
	  ((number? value) value)
	  (error "/attr-eval: internal error, unsupported result:" value)))
)

; Return value of ATTR in attribute alist ALIST.
; If not present, return the default value.
; If ATTR is an unknown attribute, return #f.
; OWNER is the containing object or #f if there is none.

(define (attr-value alist attr owner)
  (let ((a (assq-ref alist attr)))
    (if a
	(if (/attr-val-is-rtx? a)
	    (/attr-eval a owner)
	    a)
	(attr-lookup-default attr owner)))
)

; Return the value of ATTR in ATLIST.
; If not present, return the default value.
; If ATTR is an unknown attribute, return #f.
; OWNER is the containing object or #f if there is none.

(define (atlist-attr-value atlist attr owner)
  (attr-value (atlist-attrs atlist) attr owner)
)

; Same as atlist-attr-value but return nil if attribute not present.

(define (atlist-attr-value-no-default atlist attr owner)
  (let ((a (assq-ref (atlist-attrs atlist) attr)))
    (if a
	(if (/attr-val-is-rtx? a)
	    (/attr-eval a owner)
	    a)
	nil))
)

; Return the default for attribute A.
;
; If A is unknown return #f.
; This means the caller can't distinguish booleans from unknowns,
; but the caller is left to deal with that.
;
; OWNER is the containing object or #f if there is none.

(define (attr-lookup-default a owner)
  (let ((at (current-attr-lookup a)))
    (if at
	(if (bool-attr? at)
	    #f ;; FIXME: should fetch default from the attribute
	    (let ((deflt (attr-default at)))
	      (if deflt
		  (if (/attr-val-is-rtx? deflt)
		      (/attr-eval deflt owner)
		      deflt)
		  ;; If no default was provided, use the first value.
		  ;; FIXME: This shouldn't happen.  /attr-parse should DTRT.
		  (caar (attr-values at)))))
	#f))
)

; Return a boolean indicating if X is present in BITSET.
; Bitset values are recorded as (val1 val2 ...).

(define (bitset-attr-member? x bitset)
  (->bool (memq x bitset))
)

; Routines for accessing attributes in objects.

; Get/set attributes of OBJ.
; OBJ is any object which supports the get-atlist message.

(define (obj-atlist obj)
  (let ((result (send obj 'get-atlist)))
    ; As a speed up, we allow objects to specify an empty attribute list
    ; with #f or (), rather than creating an attr-list object.
    ; ??? There is atlist-empty now which should be used directly.
    (if (or (null? result) (not result))
	atlist-empty
	result))
)

(define (obj-set-atlist! obj attrs) (send obj 'set-atlist! attrs))

; Add attribute ATTR to OBJ.
; The attribute is prepended to the front so it overrides any existing
; definition.

(define (obj-cons-attr! obj attr)
  (obj-set-atlist! obj (atlist-cons attr (obj-atlist obj)))
)

; Add attribute list ATLIST to OBJ.
; Attributes in ATLIST override existing values, so ATLIST is "prepended".

(define (obj-prepend-atlist! obj atlist)
  ; Must have same prefix.
  (assert (equal? (atlist-prefix (obj-atlist obj))
		  (atlist-prefix atlist)))
  (obj-set-atlist! obj (atlist-append atlist (obj-atlist obj)))
)

; Return boolean of whether OBJ has boolean attribute ATTR or not.
; OBJ is any object that supports attributes.

(define (obj-has-attr? obj attr)
  (atlist-has-attr? (obj-atlist obj) attr)
)

; FIXME: for backward compatibility.  Delete in time.
(define has-attr? obj-has-attr?)

; Return a boolean indicating if attribute ATTR is present in OBJ.

(define (obj-attr-present? obj attr)
  (atlist-attr-present? (obj-atlist obj) attr)
)

; Return value of attribute ATTR in OBJ.
; If the attribute isn't present, the default is returned.
; If ATTR is an unknown attribute, return #f.
; OBJ is any object that supports the get-atlist method.

(define (obj-attr-value obj attr)
  (let ((atlist (obj-atlist obj)))
    (atlist-attr-value atlist attr obj))
)

; Return boolean of whether OBJ has attribute ATTR value VALUE or not.
; OBJ is any object that supports attributes.
; NOTE: The default value of the attribute IS considered.

(define (obj-has-attr-value? obj attr value)
  (let ((a (obj-attr-value obj attr)))
    (eq? a value))
)

; Return boolean of whether OBJ explicitly has attribute ATTR value VALUE
; or not.
; OBJ is any object that supports attributes.
; NOTE: The default value of the attribute IS NOT considered.

(define (obj-has-attr-value-no-default? obj attr value)
  (let* ((atlist (obj-atlist obj))
	 (objs-value (atlist-attr-value-no-default atlist attr obj)))
    (and (not (null? objs-value)) (eq? value objs-value)))
)

; Utilities.

; Generate a list representing a bit mask of the indices of 'values'
; within 'all-values'. Each element in the resulting list represents a byte.
; Both bits and bytes are indexed from left to right starting at 0
; with 8 bits in a byte.

(define (charmask-bytes values all-values vec-length)
  (logit 3 "charmask-bytes for " values " " all-values "\n")
  (let ((result (make-vector vec-length 0))
	(indices (map (lambda (name)
			(list-ref (map cadr all-values)
				  (element-lookup-index name (map car all-values) 0)))
		      values)))
    (logit 3 "indices: " indices "\n")
    (for-each (lambda (x)
		(let* ((byteno (quotient x 8))
		       (bitno (- 7 (remainder x 8)))
		       (byteval (logior (vector-ref result byteno)
					(ash 1 bitno))))
		  (vector-set! result byteno byteval)))
	      indices)
    (logit 3 "result: " (vector->list result) "\n")
    (vector->list result))
)

; Convert a bitset value into a bit string based on the
; index of each member in values.
; VALUE is a list of symbols in the bitset.
; VALUES is the values member of the attribute's definition.

(define (/bitset-attr->charmask value values)
  (let* ((values-names (map car values))
	 (values-values (map cadr values))
	 (vec-length (+ 1 (quotient (apply max values-values) 8))))
    (string-append "{ " (number->string vec-length) ", \""
		   (string-map (lambda (x)
				 (string-append "\\x" (number->hex x)))
			       (charmask-bytes value values vec-length))
		   "\" }"))
)

; Return the enum of ATTR-NAME for type TYPE.
; TYPE is one of 'ifld, 'hw, 'operand, 'insn.

(define (gen-attr-enum type attr-name)
  (string-upcase (string-append "CGEN_" type "_" (gen-sym attr-name)))
)

; Return a list of enum value definitions for gen-enum-decl.
; Attributes numbers are organized as follows: booleans are numbered 0-31.
; The range is because that's what fits in a portable int.  Unused numbers
; are left unused.  Non-booleans are numbered starting at 32.
; An alternative is start numbering the booleans at 32.  The generated code
; is simpler with the current way (the "- 32" to get back the bit number or
; array index number occurs less often).
;
; Three special values are created:
; END-BOOLS - mark end of boolean attributes
; END-NBOOLS - mark end of non-boolean attributes
; START-NBOOLS - marks the start of the non-boolean attributes
; (needed in case first non-bool is sanytized out).
;
; ATTR-OBJ-LIST is a list of <attribute> objects (always subclassed of course).

(define (attr-list-enum-list attr-obj-list)
  (let ((sorted-attrs (/attr-sort (attr-remove-meta-attrs attr-obj-list))))
    (assert (<= (length (car sorted-attrs)) 32))
    (append!
     (map (lambda (bool-attr)
	    (list (obj:name bool-attr) '-
		  (atlist-attrs (obj-atlist bool-attr))))
	  (car sorted-attrs))
     (list '(END-BOOLS))
     (list '(START-NBOOLS 31))
     (map (lambda (nbool-attr)
	    (list (obj:name nbool-attr) '-
		  (atlist-attrs (obj-atlist nbool-attr))))
	  (cdr sorted-attrs))
     (list '(END-NBOOLS))
     ))
)

; Sort an alist of attributes so non-boolean attributes are at the front.
; This is used to sort a particular object's attributes.
; This is required by the C support code (cgen.h:CGEN_ATTR_VALUE).
; Boolean attributes appear as (NAME . #t/#f), non-boolean ones appear as
; (NAME . VALUE).  Attributes of the same type are sorted by name.

(define (/attr-sort-alist alist)
  (sort alist
	(lambda (a b)
	  ;(display (list a b "\n"))
	  (cond ((and (boolean? (cdr a)) (boolean? (cdr b)))
		 (string<? (symbol->string (car a)) (symbol->string (car b))))
		((boolean? (cdr a)) #f) ; we know b is non-bool here
		((boolean? (cdr b)) #t) ; we know a is non-bool here
		(else (string<? (symbol->string (car a))
				(symbol->string (car b)))))))
)

; Sort ATTR-LIST into two lists: bools and non-bools.
; The car of the result is the bools, the cdr is the non-bools.
; Attributes requiring a fixed index have the INDEX attribute,
; and used for the few special attributes that are refered to by
; architecture independent code.
; For each of non-bools and bools, put attributes with the INDEX attribute
; first.  This is used to sort a list of attributes for output (e.g. define
; the attr enum).
;
; FIXME: Record index number with the INDEX attribute and sort on it.
; At present it's just a boolean.

(define (/attr-sort attr-list)
  (let loop ((fixed-non-bools nil)
	     (non-fixed-non-bools nil)
	     (fixed-bools nil)
	     (non-fixed-bools nil)
	     (attr-list attr-list))
    (cond ((null? attr-list)
	   (cons (append! (reverse! fixed-bools)
			  (reverse! non-fixed-bools))
		 (append! (reverse! fixed-non-bools)
			  (reverse! non-fixed-non-bools))))
	  ((bool-attr? (car attr-list))
	   (if (obj-has-attr? (car attr-list) 'INDEX)
	       (loop fixed-non-bools non-fixed-non-bools
		     (cons (car attr-list) fixed-bools) non-fixed-bools
		     (cdr attr-list))
	       (loop fixed-non-bools non-fixed-non-bools
		     fixed-bools (cons (car attr-list) non-fixed-bools)
		     (cdr attr-list))))
	  (else
	   (if (obj-has-attr? (car attr-list) 'INDEX)
	       (loop (cons (car attr-list) fixed-non-bools) non-fixed-non-bools
		     fixed-bools non-fixed-bools
		     (cdr attr-list))
	       (loop fixed-non-bools (cons (car attr-list) non-fixed-non-bools)
		     fixed-bools non-fixed-bools
		     (cdr attr-list))))))
)

; Return number of non-bools in attributes ATLIST.

(define (attr-count-non-bools atlist)
  (count-true (map (lambda (a) (not (bool-attr? a)))
		   atlist))
)

; Given an alist of attributes, return the non-bools.

(define (attr-non-bool-attrs alist)
  (let loop ((result nil) (alist alist))
    (cond ((null? alist) (reverse! result))
	  ((boolean? (cdar alist)) (loop result (cdr alist)))
	  (else	(loop (cons (car alist) result) (cdr alist)))))
)

; Given an alist of attributes, return the bools.

(define (attr-bool-attrs alist)
  (let loop ((result nil) (alist alist))
    (cond ((null? alist) (reverse! result))
	  ((boolean? (cdar alist))
	   (loop (cons (car alist) result) (cdr alist)))
	  (else	(loop result (cdr alist)))))
)

; Parse an attribute spec.
; CONTEXT is a <context> object or #f if there is none.
; ATTRS is a list of attribute specs (e.g. (FOO !BAR (BAZ 3))).
; The result is the attribute alist.

(define (attr-parse context attrs)
  (logit 4 (list 'attr-parse context attrs) "\n")
  (if (not (list? attrs))
      (parse-error context "improper attribute list" attrs))
  (let ((alist nil))
    (for-each (lambda (elm)
		(cond ((symbol? elm)
		       ; boolean attribute
		       (if (char=? (string-ref (symbol->string elm) 0) #\!)
			   (set! alist (acons (string->symbol (string-drop1 (symbol->string elm))) #f alist))
			   (set! alist (acons elm #t alist)))
		       (if (not (current-attr-lookup (caar alist)))
			   (parse-error context "unknown attribute" (caar alist))))
		      ((and (list? elm) (pair? elm) (symbol? (car elm)))
		       (let ((a (current-attr-lookup (car elm))))
			 (if (not a)
			     (parse-error context "unknown attribute" elm))
			 (set! alist (cons (send a 'parse-value
						 context (cdr elm))
					   alist))))
		      (else (parse-error context "improper attribute" elm))))
	      attrs)
    alist)
)

; Parse an object attribute spec.
; ATTRS is a list of attribute specs (e.g. (FOO !BAR (BAZ 3))).
; The result is an <attr-list> object.

(define (atlist-parse context attrs prefix)
  (make <attr-list> prefix (attr-parse context attrs))
)

;; Return the source form of an atlist's values.
;; Externally scalar attributes (boolean, integer, enum and string) are
;; ((name1 value1) (name2 value2) ...).
;; Internally they are ((name1 . value1) (name2 . value2) ...).
;; Externally bitset attributes are (name value1 value2 ...).
;; Internally they are the same, (name value1 value2 ...).
;; If the value is an rtx expression, externally it is (name (expr)),
;; and internally it is the same, (name (expr)).

(define (atlist-source-form atlist)
  (map (lambda (attr)
	 (let ((value (cdr attr)))
	   (if (pair? value)
	       (cons (car attr) value)
	       (list (car attr) value))))
       (atlist-attrs atlist))
)

; Cons an attribute to an attribute list to create a new attribute list.
; ATLIST is either an attr-list object or #f or () (both of the latter two
; signify an empty attribute list, in which case we make the prefix of the
; result "").

(define (atlist-cons attr atlist)
  (if (or (not atlist) (null? atlist))
      (make <attr-list> "" (cons attr nil))
      (make <attr-list> (atlist-prefix atlist) (cons attr (atlist-attrs atlist))))
)

; Append one attribute list to another.
; The prefix for the new atlist is taken from the first one.

(define (atlist-append attr-list1 attr-list2)
  (make <attr-list>
	(atlist-prefix attr-list1)
	(append (atlist-attrs attr-list1) (atlist-attrs attr-list2)))
)

; Remove meta-attributes from ALIST.
; "meta" may be the wrong adjective to use here.
; The attributes in question are not intended to appear in generated files.
; They started out being attributes of attributes, hence the name "meta".

(define (attr-remove-meta-attrs-alist alist)
  (let ((all-attrs (current-attr-list)))
    ; FIXME: Why not use find?
    (let loop ((result nil) (alist alist))
      (if (null? alist)
	  (reverse! result)
	  (let ((attr (attr-lookup (caar alist) all-attrs)))
	    (if (and attr (has-attr? attr 'META))
		(loop result (cdr alist))
		(loop (cons (car alist) result) (cdr alist)))))))
)

; Remove meta-attributes from ATTR-LIST.
; "meta" may be the wrong adjective to use here.
; The attributes in question are not intended to appear in generated files.
; They started out being attributes of attributes, hence the name "meta".

(define (attr-remove-meta-attrs attr-list)
  ; FIXME: Why not use find?
  (let loop ((result nil) (attr-list attr-list))
    (cond ((null? attr-list)
	   (reverse! result))
	  ((has-attr? (car attr-list) 'META)
	   (loop result (cdr attr-list)))
	  (else
	   (loop (cons (car attr-list) result) (cdr attr-list)))))
)

; Remove duplicates from ATTRS, a list of attributes.
; Attribute lists are typically small so we use a simple O^2 algorithm.
; The leading entry of an attribute overrides subsequent ones so this is
; defined to pick the first entry of each attribute.

(define (attr-nub attrs)
  (let loop ((result nil) (attrs attrs))
    (cond ((null? attrs) (reverse! result))
	  ((assq (caar attrs) result) (loop result (cdr attrs)))
	  (else (loop (cons (car attrs) result) (cdr attrs)))))
)

; Return a list of all attrs in TABLE-LIST, a list of lists of arbitrary
; elements.   A list of lists is passed to simplify computation of insn
; attributes where the insns and macro-insns are on separate lists and
; appending them into one list would be unnecessarily expensive.
; ACCESSOR is a function to access the attrs field from TABLE-LIST.
; Duplicates are eliminated and the list is sorted so non-boolean attributes
; are at the front (required by the C code that fetches attribute values).
; STD-ATTRS is an `attr-list' object of attrs that are always available.
; The actual values returned are random (e.g. #t vs #f).  We could
; canonicalize them.
; The result is an alist of all the attributes that are used in TABLE-LIST.
; ??? The cdr of each element is some random value.  Perhaps it should be
; the default value or perhaps we should just return a list of names.
; ??? No longer used.

(define (attr-compute-all table-list accessor std-attrs)
  (let ((accessor (lambda (elm) (atlist-attrs (accessor elm)))))
    (attr-remove-meta-attrs-alist
     (attr-nub
      (/attr-sort-alist
       (append
	(apply append
	       (map (lambda (table-elm)
		      (apply append
			     (find-apply accessor
					 (lambda (e)
					   (let ((attrs (accessor e)))
					     (not (null? attrs))))
					 table-elm)))
		    table-list))
	(atlist-attrs std-attrs))))))
)

; Return lists of attributes for particular object types.
; FIXME: The output shouldn't be required to be sorted.

(define (current-attr-list-for type)
  (let ((sorted (/attr-sort (find (lambda (a)
				    (if (atlist-for a)
					(memq type (atlist-for a))
					#t))
				  (attr-remove-meta-attrs
				   (current-attr-list))))))
    ; Current behaviour puts the non-bools at the front.
    (append! (cdr sorted) (car sorted)))
)
(define (current-ifld-attr-list)
  (current-attr-list-for 'ifield)
)
(define (current-hw-attr-list)
  (current-attr-list-for 'hardware)
)
(define (current-op-attr-list)
  (current-attr-list-for 'operand)
)
(define (current-insn-attr-list)
  (current-attr-list-for 'insn)
)

; Methods to emit the C value of an attribute.
; These don't _really_ belong here (C code doesn't belong in the appl'n
; independent part of CGEN), but there isn't a better place for them
; (maybe utils-cgen.scm?) and there's only a few of them.

(method-make!
 <boolean-attribute> 'gen-value-for-defn-raw
 (lambda (self value)
   (if (not value)
       "0"
       "1"))
 ;(string-upcase (string-append (obj:str-name self) "_" value)))
)

(method-make!
 <boolean-attribute> 'gen-value-for-defn
 (lambda (self value)
   (send self 'gen-value-for-defn-raw value))
)

;; NOTE: VALUE is a list of symbols in the bitset.

(method-make!
 <bitset-attribute> 'gen-value-for-defn-raw
 (lambda (self value)
   (if (string=? (string-downcase (gen-sym self)) "isa")
       (/bitset-attr->charmask value (elm-get self 'values))
       (string-drop1
	(string-upcase
	 (string-map (lambda (x)
		       (string-append "|(1<<"
				      (gen-sym self)
				      "_" (gen-c-symbol x) ")"))
		     value))))
 )
)

;; NOTE: VALUE is a list of symbols in the bitset.

(method-make!
 <bitset-attribute> 'gen-value-for-defn
 (lambda (self value)
   (string-append
    "{ "
    (if (string=? (string-downcase (gen-sym self)) "isa")
	(/bitset-attr->charmask value (elm-get self 'values))
	(string-append
	 "{ "
	 (string-drop1
	  (string-upcase
	   (string-map (lambda (x)
			 (string-append "|(1<<"
					(gen-sym self)
					"_" (gen-c-symbol x) ")"))
		       value)))
	 ", 0 }"))
    " }")
 )
)

(method-make!
 <integer-attribute> 'gen-value-for-defn-raw
 (lambda (self value)
   (number->string value)
 )
)

(method-make!
 <integer-attribute> 'gen-value-for-defn
 (lambda (self value)
   (string-append
    "{ { "
    (send self 'gen-value-for-defn-raw value)
    ", 0 } }")
 )
)

(method-make!
 <enum-attribute> 'gen-value-for-defn-raw
 (lambda (self value)
   (string-upcase
    (gen-c-symbol (string-append (obj:str-name self)
				 "_"
				 (symbol->string value))))
 )
)

(method-make!
 <enum-attribute> 'gen-value-for-defn
 (lambda (self value)
   (string-append
    "{ { "
     (send self 'gen-value-for-defn-raw value)
     ", 0 } }")
 )
)

;; Doesn't handle escape sequences.
(method-make!
 <string-attribute> 'gen-value-for-defn-raw
 (lambda (self value)
   (string-append "\"" value "\""))
)

(method-make!
 <string-attribute> 'gen-value-for-defn
 (lambda (self value)
   (send self 'gen-value-for-defn-raw value))
)


; Called before loading a .cpu file to initialize.

(define (attr-init!)

  (reader-add-command! 'define-attr
		       "\
Define an attribute, name/value pair list version.
"
		       nil 'arg-list define-attr)

  *UNSPECIFIED*
)

; Called before a . cpu file is read in to install any builtins.
; One thing this does is define all attributes requiring a fixed index,
; keeping them all in one place.
; ??? Perhaps it would make sense to define all predefined attributes here.

(define (attr-builtin!)
  (define-attr '(type boolean) '(name VIRTUAL) '(comment "virtual object"))

  ; The meta attribute is used for attributes that aren't to appear in
  ; generated output (need a better name).
  (define-attr '(for attr) '(type boolean) '(name META))

  ; Objects to keep local to a generated file.
  (define-attr '(for keyword) '(type boolean) '(name PRIVATE))

  ; Attributes requiring fixed indices.
  (define-attr '(for attr) '(type boolean) '(name INDEX) '(attrs META))

  ; ALIAS is used for instructions that are aliases of more general insns.
  ; ALIAS insns are ignored by the simulator.
  (define-attr '(for insn) '(type boolean) '(name ALIAS)
    '(comment "insn is an alias of another")
    '(attrs INDEX))

  *UNSPECIFIED*
)

; Called after loading a .cpu file to perform any post-processing required.

(define (attr-finish!)
  *UNSPECIFIED*
)
@


1.16
log
@	Record bitset attributes internally as a list.
	Record rtx attribute values internally as ((rtx-expr)).
	* attr.scm (bitset-attr?): Delete, unused.
	(<bitset-attribute> parse-value): Rewrite.
	(/attr-parse): Rewrite bitset default value processing.
	(/attr-read): Pick out values of scalar attributes to distinguish
	them from bitset values which are a list.
	Fix spelling errors for processing of default values.
	Handle string attributes.
	(bitset-attr->list): Delete, all callers updated.
	(/bitset-attr->charmask): Renamed from bitset-attr->charmask.
	All callers updated.
	(atlist-source-form): Rewrite.
	* hardware.scm (<hardware-base> 'get-isas): Update recognition
	of all isas.
	(hardware-builtin!): Update spec of ISA attribute, (ISA foo,bar)
	-> (ISA foo bar).
	* intrinsics.scm (target:belongs-to-group?): Update, bitset attribute
	values are now lists.
	* mach.scm (def-isa-attr!): Update, bitset attribute values,
	including the default, are now lists.
	(all-isas-attr-value): Result is now a list.
	* doc/rtl.texi: Clean up pass over attribute docs.
@
text
@d564 3
a566 1
; If it's #f obviously ATVAL can't be defined in terms of others.
d569 7
a575 4
  (let* ((estate (estate-make-for-eval #f owner))
	 (atval-expr (car atval))
	 (expr (rtx-simplify #f owner (rtx-canonicalize #f 'DFLT atval-expr nil) nil))
	 (value (rtx-eval-with-estate expr DFLT estate)))
@


1.15
log
@	* attr.scm (/attr-parse): Use /attr-val-is-rtx? to detect rtx values.
	Disallow rtx values for bitset attributes.
	(/attr-read): Record rtx in default value as ((rtx-expr)).
	(/attr-eval): Update.
@
text
@d6 5
a10 3
; There are 4 kinds of attributes: boolean, integer, enum, and bitset.  Boolean
; attributes are really enum attributes with two possible values, but they
; occur frequently enough that they are special cased.
d20 6
a25 2
; string attrs are specified as (ATTR value).
; Bitset attrs are specified as (ATTR val1,val2,val3).
d31 1
a31 1
; (FOO1 !FOO2 (BAR 3) (FOO3 X) (MACH sparc,sparclite))
d38 1
a38 1
; ??? May wish to allow a bitset attribute like (ATTR val1,!val2), where `!'
a156 4
; Return a boolean indicating if X is a <bitset-attribute> object.

(define (bitset-attr? x) (class-instance? <bitset-attribute> x))

d186 2
a187 3
; VALUES must be a comma separated list of symbols
; (e.g. val1,val2 not (val1 val2)).
; FIXME: require values to be a string (i.e. "val1,val2")
d224 5
a228 1
; A bitset attribute's value is a comma separated list of elements.
d240 10
a249 2
 (/parse-simple-attribute (lambda (x) (or (symbol? x) (string? x)))
			  "improper bitset attribute")
d279 2
a280 2
; Ignore values for strings.  We can't do any error checking since
; the default value is (#f #t).
a287 1
; FIXME: treated as enum?
d292 1
d298 1
d305 1
d334 4
a337 2
; If DEFAULT is #f, use the first value.
; ??? Allowable values for integer attributes is wip.
d353 2
a354 1
    ; Set the default.
d357 2
d382 5
a386 1
       (let ((default (if default default (caar parsed-values))))
d391 2
a392 1
	 (if (not (assq default parsed-values))
d409 2
a410 1
	(type-class 'not-set) ; attribute type
d414 3
a416 3
	(for #f) ; assume for everything
	(default #f) ; #f indicates "not set"
	(values #f) ; #f indicates "not set"
d419 1
a419 1
    ; Loop over each element in ARG-LIST, recording what's found.
d426 12
a437 10
	      ((type) (set! type-class (case (cadr arg)
					((boolean) <boolean-attribute>)
					((string) <string-attribute>)
					((bitset) <bitset-attribute>)
					((integer) <integer-attribute>)
					((enum) <enum-attribute>)
					(else (parse-error
					       context
					       "invalid attribute type"
					       (cadr arg))))))
d442 1
a442 1
	      ((default) (set! default (cadr arg)))
d447 1
a447 7
    ; If the default is a list it is an rtx expression,
    ; convert it to ((rtx-expression)) so that it is recognized by
    ; /attr-val-is-rtx?.
    (if (pair? default) ;; pair? -> cheap non-null-list?
	(set! default (list default)))

    ; Must have type now.
d450 14
a463 3
    ; Establish proper defaults now that we know the type.
    (case (class-name type-class)
      ((<boolean-attribute>)
d465 1
a465 1
	   (set! default #f)) ; really a nop, but for consistency
d468 1
a468 1
      ((bitset-attribute>) ;; FIXME
d470 1
a470 1
	   (parse-error context "bitset-attribute default not specified"
d473 1
a473 1
	   (parse-error context "bitset-attribute values not specified"
d475 1
a475 1
      ((integer-attribute>) ;; FIXME
d479 11
a489 2
	   (set! values #f))) ; really a nop, but for consistency
      ((enum-attribute>) ;; FIXME
d491 3
a493 4
	   (parse-error context "enum-attribute default not specified"
			arg-list))
       (if (eq? values #f)
	   (parse-error context "bitset-attribute values not specified"
d497 1
a497 1
    ; Now that we've identified the elements, build the object.
d578 1
d591 2
d611 5
a615 2
; If A isn't a non-boolean attribute, we assume it's a boolean one, and
; return #f (??? for backward's compatibility, to be removed in time).
d622 1
a622 1
	    #f
d628 2
a629 1
		  ; If no default was provided, use the first value.
d635 1
a635 1
; Bitset values are recorded as val1,val2,....
d638 1
a638 1
  (->bool (memq x (bitset-attr->list bitset)))
d694 1
a723 6
; Convert a bitset value "a,b,c" into a list (a b c).

(define (bitset-attr->list x)
  (map string->symbol (string-cut (->string x) #\,))
)

d728 1
d749 5
a753 2
; index of each member in values
(define (bitset-attr->charmask value values)
d760 1
a760 2
			       (charmask-bytes (bitset-attr->list value)
					       values vec-length))
d763 1
d896 1
d928 8
a935 3
; Return the source form of an atlist's values.
; Externally attributes are ((name1 value1) (name2 value2) ...).
; Internally they are ((name1 . value1) (name2 . value2) ...).
d939 4
a942 1
	 (list (car attr) (cdr attr)))
d1090 2
d1096 1
a1096 1
       (bitset-attr->charmask value (elm-get self 'values))
d1103 1
a1103 1
		     (bitset-attr->list value)))))
d1107 2
d1115 1
a1115 1
	(bitset-attr->charmask value (elm-get self 'values))
d1124 1
a1124 1
		       (bitset-attr->list value))))
@


1.14
log
@	Change internal representation of rtx attribute values.
	* attr.scm (/attr-val-is-rtx?): New function.
	(attr-value): Call it.
	(atlist-attr-value-no-default, attr-lookup-default): Ditto.
@
text
@d335 1
d340 1
a340 1
		(not (rtx? default)))
d346 1
a346 1
		  (not (rtx? default)))
d352 1
a352 1
		  (not (rtx? default)))
d355 1
a355 1
      ((<bitset-attribute> <enum-attribute>)
d358 10
a367 1
		  (not (rtx? default)))
d370 1
d419 6
d527 2
a528 1
	 (expr (rtx-simplify #f owner (rtx-canonicalize #f 'DFLT atval nil) nil))
@


1.13
log
@	* xc16x.cpu (h-cr): New hardware.
	(muls): Comment out parts that won't compile, add fixme.
	(mulu, divl, divlu, jmpabs, jmpa-, jmprel, jbc, jnbs, callr): Ditto.
	(scxti, scxtmg, scxtm, bclear, bclr18, bset19, bitset, bmov): Ditto.
	(bmovn, band, bor, bxor, bcmp, bfldl, bfldh): Ditto.

	Rewrite rtl processing to require it to be "canonicalized" first,
	and write a full canonicalizer / expression checker.
	Remove all appearances of DFLT in canonical rtl.
	* attr.scm (/attr-eval atval owner): Call rtx-canonicalize,
	then rtx-simplify.
	* iformat.scm (ifmt-analyze) Use canonical semantics.
	* insn (<insn>): New member canonical-semantics.
	* mach.scm (<arch>): New member multi-insns-instantiated?.
	(/instantiate-multi-insns!): New function.
	(/canonicalize-insns!): New function.
	(arch-analyze-insns!): Canonicalize insn semantics before processing
	them.
	* mode.scm (/mode-set-word-params!): New function.
	(mode-void?): New function.
	(mode-compatible?): VOID is compatible with VOID.
	(/mode-word-sizes-defined?): New global.
	(mode-set-word-modes!): Use/set it.
	(mode-ensure-word-sizes-defined): Update.
	(mode-builtin!): New builtin "modes" SYM, INSN, MACH.
	Redo WI/UWI/AI/IAI handling.
	(op:new-mode): No longer accept DFLT.
	(<derived-operand> constructor): Ensure all fields are initialized.
	(<anyof-operand> constructor): Ditto.
	(/derived-parse-ifield-assertion): Delete arg `args'.
	All callers updated.
	* rtl-c.scm (<rtl-c-eval-state>): New member `for-insn?'.
	(rtl-c): Call rtx-canonicalize instead of rtx-compile.
	(rtl-c-expr, rtl-c++): Ditto.
	(/rtl-c-get): Use mode of operand, not containing expression.
	(rtl-c-set-quiet, rtl-c-set-trace): Remove DFLT support.
	(/rtx-use-sem-fn?): Don't check for (insn? owner), check
	estate-for-insn? instead.
	(s-unop): Use mode of expression, not first operand.
	(s-binop, s-binop-with-bit, s-shop, s-cmpop): Ditto.
	(s-sequence): Remove DFLT support.
	(ifield): Use mode of expression, not UINT.
	(pc): Comment out, unused.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	(set, set-quiet): Pass src to rtl-c-set-{trace,quiet} for expansion.
	* rtl-traverse.scm (/rtx-canon-debug?): New global.
	(/make-cstate): New function.
	(/cstate-context, /cstate-outer-expr): New functions.
	(/rtx-canon-error): New function.
	(/rtx-lookup-hw, /rtx-pick-mode, /rtx-pick-mode3, /rtx-pick-op-mode,
	/rtx-get-last-cond-case-rtx): New functions.
	(/rtx-canon-*): New functions.
	(/rtx-canner-table, /rtx-operand-canoners): New globals.
	(/rtx-make-canon-table, /rtx-special-expr-canoners): New functions.
	(/rtx-option, /rtx-option-list?): Rewrite.
	(rtx-munge-mode&options): Replaces /rtx-munge-mode&options.
	Rewritten, all callers updated.
	(/rtx-canon-expr, /rtx-canon): New functions.
	(rtx-canonicalize): Move here from rtl-xform.scm and rewrite.
	(rtx-canonicalize-stmt): New function.
	(tstate-make): Remove arg `set?'.  All callers updated.
	(tstate-new-set?): Delete.
	(/rtx-traverse-options, /rtx-traverse-*mode): Delete,
	moved to /rtx-canon-*.
	(/rtx-traverse-normal-operand): New function.
	(/rtx-traverse-rtx-list): Delete arg `mode', all callers updated.
	(/rtx-traverse-rtx, /rtx-traverse-setrtx,, /rtx-traverse-testrtx,
	/rtx-traverse-condrtx, /rtx-traverse-casertx, /rtx-traverse-locals,
	/rtx-traverse-iteration, /rtx-traverse-env, /rtx-traverse-attrs):
	Ditto.
	(/rtx-traverse-symbol, /rtx-traverse-string, /rtx-traverse-number,
	/rtx-traverse-symornum, /rtx-traverse-object): Delete.
	(/rtx-make-traverser-table): Update.
	(/rtx-traverse-operands): Remove mode processing, now done during
	canonicalization.
	(/rtx-traverse-expr): Delete arg `mode', all callers updated.
	(/rtx-traverse): Ditto.
	(rtx-init-traverser-tables!): New function.
	* rtl-xform (/rtx-verify-no-dflt-modes-expr-fn): New function.
	(rtx-verify-no-dflt-modes): New function.
	(/rtx-simplify-expr-fn): Update, `arg' mode deleted.
	(rtx-simplify-insn): Use insn-canonical-semantics.
	(rtx-canonicalize): Moved to rtl-traverse.scm.
	(/compile-expr-fn, rtx-compile): Delete.
	(/rtx-trim-rtx-list): New function.
	(/rtx-trim-for-doc): Handle set, if.
	* rtl.scm (<rtx-func>): New members result-mode, matchexpr-index.
	(/rtx-valid-mode-types): Update.
	(/rtx-valid-matches): Update.
	(/rtx-find-matchexpr-index): New function.
	(rtx-lookup): Require rtx-kind to be the rtx name.
	(def-rtx-node): New arg result-mode, all callers updated.
	(def-rtx-syntax-node, def-rtx-operand-node): Ditto.
	(rtx-lazy-sem-mode): Delete.
	(/rtx-closure-make): New arg `mode', all callers updated.
	(rtx-make-ifield, rtx-make-operand, rtx-make-local): Ditto.
	(rtx-operand-obj): Rewrite.
	(rtx-make-xop): New functions.
	(/hw): Renamed from `hw', all callers updated.
	Use the correct mode instead of DFLT for the index.
	(rtl-builtin!): Call rtx-init-traversal-tables!.
	(rtl-finish!): Update.
	* rtx-funcs.scm (all rtx functions): New parameter: result-mode.
	Update mode arg-type.
	(pc): Comment out.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	* sem-frags.scm (/frag-hash-compute!): Update, mode arg deleted.
	(/frag-cost-compute!): Ditto.
	* semantics.scm (/build-operand!): Delete args op-name, op.
	New arg op-expr.  All callers updated.
	(/build-mem-operand!): Remove DFLT support.
	(semantic-compile): Update process-expr!, mode arg deleted.
	* sid-cpu.scm (gen-semantic-code): Specify #:for-insn? in
	rtl-c++ calls.
	(/gen-sem-case, /gen-sfrag-code): Ditto.
	* sid.scm (/op-gen-set-trace1): Renamed from /op-gen-set-trace.
	(/op-gen-set-trace): New function.  If not doing profiling,
	call /op-gen-set-quiet.
	* sim-cpu.scm (gen-semantic-code): Specify #:for-insn? in rtl-c calls.
	* utils-gen.scm (/gen-ifld-extract-base): Update call to rtl-c.
	(/gen-ifld-extract-beyond, gen-multi-ifld-extract): Ditto.
	* utils.scm (find-first-index): New function.
	* doc/rtl.texi: Delete docs for `attr'.  Add `int-attr'.
@
text
@d198 4
a201 3
;;; Return a procedure to parse an attribute.
;;; RIGHT-TYPE? is a procedure that verifies the value is the right type.
;;; MESSAGE is printed if there is an error.
d492 11
d524 1
a524 1
	(if (pair? a) ; pair? -> cheap non-null-list?
d542 1
a542 1
	(if (pair? a) ; pair? -> cheap non-null-list?
d560 1
a560 1
		  (if (pair? deflt) ; pair? -> cheap non-null-list?
@


1.12
log
@	Clean up pass of mode handling.
	Make use of mode name vs <mode> object more consistent and clear.
	* hardware.scm (/keyword-read): Default mode to the mode name,
	not the <mode> object.
	(/hw-parse-indices): Parse mode name and pass mode object to
	<hw-asm> constructor.
	(/hw-parse-values): Ditto.
	(<hw-register> parse!): Pass mode name to /hw-parse-indices
	and /hw-parse-values.
	(<hw-memory> parse!): Ditto.
	(<hw-address> parse!): Ditto.
	* mode.scm (/mode-table): New global, replaces mode-list.
	Modes stored in hashtable instead of list.
	(/mode-class-table): New global.
	(mode-list-non-alias-values): Update.
	(mode:eq?, mode-compatible?, mode:add!): Update.
	(mode:lookup): Restrict arg to the mode's name.  All callers updated.
	(mode-maybe-lookup): New function.
	(mode-real-name): Restrict arg to a <mode> object.  All callers updated.
	(mode-real-mode, mode-sem-mode, mode-bigger?): Ditto.
	(mode-find, mode-set-word-modes!): Update
	(mode-ensure-word-sizes-defined): Update.
	(/sort-mode-classes!): New function.
	(mode-builtin!): Update.  Sort mode classes here.
	(mode-finish!): Sort mode classes here too.
	* rtl-c.scm (/rtl-c-get): Restrict mode arg to a <mode> object.
	All callers updated.
	(rtl-c-set-quiet): Allow mode to be name of object.
	(rtl-c-set-trace): Ditto.
	* rtl-traverse.scm (rtl-eval-with-estate): Restrict mode arg to
	<mode> object.  All callers updated.
	* rtl.scm (rtx-sem-mode): Restrict arg to <mode> object.
	(rtx-lazy-sem-mode): Ditto.
	(<rtx-temp> make!): Assert mode arg is a <mode> object.
	(rtx-env-make): Allow var-list modes to be name or object.
	* sem-frags.scm (/frag-expr-assq-locals): New function.
	(/frag-compute-locals!): Call it.
	(/sfrag-create-cse-mapping): Renamed from sfrag-create-cse-mapping.
	All callers updated.
	* semantics.scm (/build-mem-operand!): Handle mode aliases.
@
text
@d498 1
a498 1
	 (expr (rtx-compile #f (rtx-simplify #f owner atval nil) nil))
@


1.11
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d499 1
a499 1
	 (value (rtx-eval-with-estate expr 'DFLT estate)))
@


1.10
log
@	Clean up cpu file parsing, pass context consistently instead of the
	old "errtxt" argument.
	NOTE: ACU == "All Callers Updated".
	* attr.scm (-parse-simple-attribute): Renamed from
	parse-simple-attribute, ACU.
	(-attr-parse): Change errtxt argument to context, ACU.
	(-attr-read): Ditto.
	(atlist-parse): Ditto.  Put context arg first.
	(attr-parse): Use parse-error instead of context-error.
	* enum.scm (parse-enum-vals): Change errtxt argument to context, ACU.
	(-enum-parse-prefix, -enum-parse, -enum-read): Ditto.
	* hardware.scm (-keyword-parse): Renamed from keyword-parse.
	`context' arg is now a <context> object.  ACU.
	(-keyword-read): `context' arg is now a <context> object.  ACU.
	(-hw-parse-indices): Change errtxt argument to context, ACU.
	(-hw-parse-values, -hw-parse-handlers): Ditto.
	(-hw-parse-getter, -hw-parse-setter, -hw-parse, -hw-read): Ditto.
	(-hw-validate-layout, -hw-create-getter-from-layout,
	-hw-create-setter-from-layout): Ditto.
	(<hw-register>:parse!, <hw-pc>:parse!): Ditto.
	(<hw-memory>:parse!, <hw-immediate>:parse!): Ditto.
	(<hw-address>:parse!): Ditto.
	* ifield.scm (-ifield-parse, ifield-read): Ditto.
	(-ifld-parse-follows, -ifld-parse-encode-decode): Ditto.
	(-ifld-parse-encode, -ifld-parse-decode): Ditto.
	(-multi-ifield-parse, -multi-ifield-read): Ditto.
	* insn.scm (-insn-parse, -insn-read): Ditto.
	(parse-syntax): Ditto.  Put context arg first.
	(-parse-insn-format-symbol): Change errtxt argument to context, ACU.
	(-parse-insn-format-ifield-spec, -parse-insn-format-list): Ditto.
	(-parse-insn-format): Ditto.
	* mach.scm (-arch-parse-alignment, -arch-parse-machs): Ditto.
	(-arch-parse-isas): Ditto.
	(-isa-read): Add context arg, ACU.
	(-cpu-parse, -cpu-read, -mach-read): Ditto.
	* minsn.scm (-minsn-parse-expansion): Change errtxt argument to
	context, ACU.
	(-minsn-parse, -minsn-read, -minsn-compute-iflds): Ditto.
	(minsn-make-alias): Ditto.
	* mode.scm (-mode-parse): Ditto.
	(parse-mode-name): Ditto.  Put context arg first.
	* model.scm (-prefetch-parse, -retire-parse, -pipeline-parse): Change
	errtxt argument to context, ACU.
	(-unit-parse, -model-parse, -model-read): Ditto.
	* operand.scm (-operand-parse-getter): Use parse-error instead of
	context-error.
	(-operand-parse-setter): Ditto.
	(-operand-parse): Change errtxt argument to context, ACU.
	(-operand-read, -derived-operand-parse, -derived-operand-read): Ditto.
	(-anyof-operand-parse, -anyof-operand-read): Ditto.
	* read.scm (reader-error): Delete.  Use parse-error instead.
	(parse-error): Change errtxt argument to context, ACU.  Split args
	argument into expr and maybe-help-text.
	(-reader-process-expanded-1!): Reorganize.
	* rtl.scm (-subr-read): Change errtxt argument to context, ACU.
	* types.scm (parse-type): Ditto.
	* utils-cgen.scm (single-location->simple-string): New function.
	(<context>): Replace members file,lineno with location.
	(make-prefix-context): Renamed from context-make-prefix, ACU.
	(make-current-context): New function.
	(context-append, context-append-name): New functions.
	(context-make-reader): Delete.
	(parse-name): Change errtxt argument to context, ACU.
	Put context arg first.
	(parse-comment): Ditto.
	(parse-number): Change errtxt argument to context, ACU.
	(arg-list-validate-name, arg-list-check-no-args,
	arg-list-symbol-arg): Ditto.

	* read.scm (-cmd-if): Don't assume test is a list.

	* html.scm (get-insn-properties): Delete errtxt, unused.
@
text
@d202 1
a202 1
(define (-parse-simple-attribute right-type? message)
d215 1
a215 1
 (-parse-simple-attribute boolean? "boolean attribute not one of #f/#t")
d220 1
a220 1
 (-parse-simple-attribute string? "invalid argument to string attribute"))
d234 1
a234 1
 (-parse-simple-attribute (lambda (x) (or (symbol? x) (string? x)))
d243 1
a243 1
 (-parse-simple-attribute (lambda (x) (or (number? x) (symbol? x)))
d251 1
a251 1
 (-parse-simple-attribute (lambda (x) (or (symbol? x) (string? x)))
d321 1
a321 1
(define (-attr-parse context type-class name comment attrs for default values)
d368 1
a368 1
; -attr-parse is invoked to create the attribute object.
d370 1
a370 1
(define (-attr-read context . arg-list)
d439 1
a439 1
    (-attr-parse context type-class name comment attrs for default values))
d446 1
a446 1
    (let ((a (apply -attr-read (cons (make-current-context "define-attr")
d496 1
a496 1
(define (-attr-eval atval owner)
d502 1
a502 1
	  (error "-attr-eval: internal error, unsupported result:" value)))
d513 1
a513 1
	    (-attr-eval a owner)
d531 1
a531 1
	    (-attr-eval a owner)
d549 1
a549 1
		      (-attr-eval deflt owner)
d711 1
a711 1
  (let ((sorted-attrs (-attr-sort (attr-remove-meta-attrs attr-obj-list))))
d734 1
a734 1
(define (-attr-sort-alist alist)
d758 1
a758 1
(define (-attr-sort attr-list)
d944 1
a944 1
      (-attr-sort-alist
d962 1
a962 1
  (let ((sorted (-attr-sort (find (lambda (a)
@


1.9
log
@(-attr-read): Add some fixmes.
@
text
@d198 6
a203 2
(define (parse-simple-attribute right-type? message)
  (lambda (self errtxt val)
d208 1
a208 1
	(parse-error errtxt message (cons (obj:name self) val))))
d215 1
a215 1
 (parse-simple-attribute boolean? "boolean attribute not one of #f/#t")
d220 1
a220 1
 (parse-simple-attribute string? "invalid argument to string attribute"))
d234 2
a235 2
 (parse-simple-attribute (lambda (x) (or (symbol? x) (string? x)))
			 "improper bitset attribute")
d243 2
a244 2
 (parse-simple-attribute (lambda (x) (or (number? x) (symbol? x)))
			 "improper integer attribute")
d251 2
a252 2
 (parse-simple-attribute (lambda (x) (or (symbol? x) (string? x)))
			 "improper enum attribute")
d259 1
a259 1
 (lambda (self errtxt values)
d262 1
a262 1
       (parse-error errtxt "boolean value list must be (#f #t)" values)))
d270 1
a270 1
 (lambda (self errtxt values) #f)
d278 2
a279 2
 (lambda (self errtxt values)
   (parse-enum-vals errtxt "" values))
d287 1
a287 1
 (lambda (self errtxt values)
d292 3
a294 1
		       (parse-error errtxt "invalid element in integer attribute list" val)))
d304 2
a305 2
 (lambda (self errtxt values)
   (parse-enum-vals errtxt "" values))
d321 1
a321 1
(define (-attr-parse errtxt type-class name comment attrs for default values)
d323 4
a326 2
  (let* ((name (parse-name name errtxt))
	 (errtxt (stringsym-append errtxt ":" name))
d328 2
a329 1
	 (parsed-values (send result 'parse-value-def errtxt values)))
d331 2
a332 2
    (elm-xset! result 'comment (parse-comment comment errtxt))
    (elm-xset! result 'attrs (atlist-parse attrs "" errtxt))
d339 1
a339 1
	   (parse-error errtxt "invalid default" default))
d345 1
a345 1
	     (parse-error errtxt "invalid default" default))
d351 1
a351 1
	     (parse-error errtxt "invalid default" default))
d357 1
a357 1
	     (parse-error errtxt "invalid default" default))
d360 1
d366 1
a366 1
; ERRTXT is prepended to error messages to provide context.
d370 2
a371 2
(define (-attr-read errtxt . arg-list)
  (let (; Current attribute elements:
d373 1
a373 1
	(name nil)
d377 2
a378 2
	(default #f) ; indicates "not set"
	(values #f) ; indicates "not set"
d380 1
d395 1
a395 1
					       errtxt
d404 1
a404 1
	      (else (parse-error errtxt "invalid attribute arg" arg)))
d406 1
d409 1
a409 1
	(parse-error errtxt "type not specified"))
d419 2
a420 1
	   (parse-error errtxt "bitset-attribute default not specified"))
d422 2
a423 1
	   (parse-error errtxt "bitset-attribute values not specified")))
d431 2
a432 1
	   (parse-error errtxt "enum-attribute default not specified"))
d434 2
a435 1
	   (parse-error errtxt "bitset-attribute values not specified")))
d437 1
d439 1
a439 2
    (-attr-parse errtxt type-class name comment attrs for default values)
    )
d446 2
a447 1
    (let ((a (apply -attr-read (cons "define-attr" arg-list))))
d820 1
a820 1
      (context-error context "improper attribute list" attrs))
d829 1
a829 1
			   (context-error context "unknown attribute" (caar alist))))
d833 1
a833 1
			     (context-error context "unknown attribute" elm))
d835 3
a837 3
						 (context-prefix context);FIXME
						 (cdr elm)) alist))))
		      (else (context-error context "improper attribute" elm))))
d846 2
a847 2
(define (atlist-parse attrs prefix errtxt)
  (make <attr-list> prefix (attr-parse (context-make-prefix errtxt) attrs))
@


1.8
log
@	Use hash tables to record ifields, operands, insns, macro-insns.
	* attr.scm (attr-builtin!): Tweak some comments.
	* hardware.scm (hardware-builtin!): Call all-isas-attr-value.
	* ifield.scm (<ifield>): Subclass from <ordered-ident> instead of
	<ident>.
	(<multi-ifield>): New constructor.
	(ifield-builtin!): Add isa attr to f-nil, f-anyof.
	* insn.scm (<insn>): Subclass from <ordered-ident> instead of
	<ident>.
	(-sub-insn-make!): Add hack to avoid differences in generated code.
	(multi-insn-instantiate!): Add total number of multi-insns to
	logging message.
	* mach.scm (<arch>): Rename members ifld-list, op-list, insn-list,
	minsn-list to foo-table.  New member next-ordinal.
	Update getters/setters.
	(arch-ifld-list, arch-op-list, arch-insn-list, arch-minsn-list):
	New functions.
	(-get-next-ordinal!, -get-lowest-ordinal): New function.
	(-make-ident-object-table, -ident-object-table->list,
	-ident-object-table-add!, -ident-object-table-lookup): New functions.
	(current-ifld-list, current-ifld-add! current-ifld-lookup,
	-ifld-already-defined?): Rewrite.
	(current-op-list, current-op-add! current-op-lookup,
	-op-already-defined?): Rewrite.
	(current-raw-insn-list, insn-list-car, insn-list-splice!): Delete.
	(current-insn-list, current-insn-add! current-insn-lookup,
	-insn-already-defined?): Rewrite.
	(current-minsn-list, current-minsn-add! current-minsn-lookup,
	-minsn-already-defined?): Rewrite.
	(all-isas-attr-value, all-isas-attr, attr-isa-list): New functions.
	(MAX-VIRTUAL-INSNS): Define.
	(arch-analyze-insns!): Add hack to avoid differences in generated code.
	Update use of arch-insn-list.
	(mach-init!): Initialize ifld-table, op-table, insn-table, minsn-table.
	(arch-finish!): Delete references to ifld-table, op-table, insn-table,
	minsn-table.
	* minsn.scm (<macro-insn>): Subclass from <ordered-ident> instead of
	<ident>.  New constructor.
	* operand.scm (<operand>): Subclass from <ordered-ident> instead of
	<ident>.
	* sid.scm (-virtual-insn-add!): New function.
	(-create-virtual-insns!): Call it.
	(-fill-sim-insn-list!): Rewrite.
	* sim.scm (-virtual-insn-add!, -create-virtual-insns!): New functions.
	(sim-finish!): Move contents to -create-virtual-insns!, and call it.
	* utils-cgen.scm (<ordered-ident>): New class.
	(obj-ordinal, obj-set-ordinal!): New functions.
	(add-ident-methods!): Delete.

	* model.scm (parse-insn-timing): Change logging message to level 3.
@
text
@d405 1
a405 1
      ((bitset-attribute>)
d410 1
a410 1
      ((integer-attribute>)
d415 1
a415 1
      ((enum-attribute>)
@


1.7
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d738 1
a738 1
; ??? Record index number with the INDEX attribute?
d843 1
a843 1
; cons an attribute to an attribute list to create a new attribute list
d1103 2
a1106 1
  (define-attr '(for attr) '(type boolean) '(name INDEX) '(attrs META))
@


1.6
log
@	* attr.scm: Removing trailing whitespace.
	* cgen-intrinsics.scm: Ditto.
	* cgen-sim.scm: Ditto.
	* cos.scm: Ditto.
	* enum.scm: Ditto.
	* guile.scm: Ditto.
	* sim.scm: Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2003, 2005 Red Hat, Inc.
@


1.6.2.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2003, 2005, 2009 Red Hat, Inc.
@


1.5
log
@2007-02-05  Dave Brolley  <brolley@@redhat.com>

        * opc-asmdis.scm (-gen-init-asm-fn): Include CGEN_ASM_INIT_HOOK
        in the generated code for @@arch@@_cgen_init_asm if it is defined.

        * Contribute the following changes:
        2005-04-05  Richard Sandiford  <rsandifo@@redhat.com>

        * attr.scm (<string-attribute>): New attribute class.
        (attr-kind): Handle <string-attribute>.
        (parse-simple-attribute): New function.
        (<boolean-attribute> 'parse-value): Use parse-simple-attribute.
        (<bitset-attribute> 'parse-value): Likewise.
        (<boolean-attribute> 'parse-value): Likewise.
        (<enum-attribute> 'parse-value): Likewise.
        (<string-attribute> 'parse-value): New function.
        (-attr-parse): Handle <string-attribute>.
        (-attr-read): Likewise.
        (<string-attribute> 'gen-value-for-defn-raw): New function.
        (<string-attribute> 'gen-value-for-defn): New function.
@
text
@d1033 1
a1033 1
   (string-append 
@


1.4
log
@2005-10-28  Dave Brolley  <brolley@@redhat.com>

        Contribute the following changes:
        2005-09-19  Dave Brolley  <brolley@@redhat.com>

        * attr.scm (gen-value-for-defn-raw): New methods.
        (gen-value-for-defn): Don't test for 'SID-SIMULATOR. Call
        gen-value-for-defn-raw.
        * sid.scm (gen-obj-attr-sid-defn): Call gen-value-for-defn-raw.

        2002-12-13  Dave Brolley  <brolley@@redhat.com>

        * utils-cgen.scm (gen-attr-type): Moved from sid.scm.
        (-gen-attr-accessors): New function.
        (gen-obj-attr-defn): Update terminating initializer.
        (gen-obj-attr-end-defn): New function.
        * sid.scm (gen-attr-type): Moved to utils-cgen.scm.
        * sid-cpu.scm (cgen-desc.h): Generate code to include
        "opcode/cgen-bitset.h"
        * intrinsics.scm (kept-insn-isas): Correct the extraction of the isa
        name.
        * desc.scm ('gen-defn): Update terminating initializer.
        * desc-cpu.scm (gen-ifld-decls): Call -gen-attr-accessors. Update
        terminatinig initializer.
        (gen-hw-decls): Ditto.
        (gen-operand-decls): Ditto.
        (gen-insn-decls): Ditto.
        (-gen-hash-defines): Generate code to include "opcde/cgen-bitset.h"
        (gen-insn-table): Update terminating initializer.
        (-gen-cpu-open): Update generation of @@arch@@_cgen_rebuild_tables,
        @@arch@@_cgen_cpu_open, @@arch@@_cgen_cpu_close.
        * attr.scm (charmask-bytes): New function.
        (bitset-attr->charmask): New function.
        (<bitset-attribute>): Handle isa-attributes specially. Also handle
        differences for SID-SIMULATOR.
        (<integer-attribute>): Handle differences for SID-SIMULATOR.
        (<enum-attribute>): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2003 Red Hat, Inc.
d18 1
d94 9
d156 1
a156 1
; The result is one of boolean,integer,enum,bitset.
d161 1
d198 9
d211 1
a211 6
 (lambda (self errtxt val)
   (if (and (not (null? val))
	    (boolean? (car val)))
       (cons (obj:name self) (car val))
       (parse-error errtxt "boolean attribute not one of #f/#t"
		    (cons (obj:name self) val))))
d214 4
d230 2
a231 8
 (lambda (self errtxt val)
   (if (and (not (null? val))
	    (or (symbol? (car val))
		(string? (car val)))
	    (null? (cdr val)))
       (cons (obj:name self) (car val))
       (parse-error errtxt "improper bitset attribute"
		    (cons (obj:name self) val))))
d239 2
a240 7
 (lambda (self errtxt val)
   (if (and (not (null? val))
	    (or (number? (car val)) (symbol? (car val)))
	    (null? (cdr val)))
       (cons (obj:name self) (car val))
       (parse-error errtxt "improper integer attribute"
		    (cons (obj:name self) val))))
d247 2
a248 7
 (lambda (self errtxt val)
   (if (and (not (null? val))
	    (or (symbol? (car val)) (string? (car val)))
	    (null? (cdr val)))
       (cons (obj:name self) (car val))
       (parse-error errtxt "improper enum attribute"
		    (cons (obj:name self) val))))
d261 8
d311 1
a311 1
; i.e. one of <{boolean,bitset,integer,enum}-attribute>.
d332 6
d379 1
d1059 14
@


1.3
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
d616 36
d955 1
a955 1
 <boolean-attribute> 'gen-value-for-defn
d964 21
d987 23
a1009 7
   (string-drop1
    (string-upcase
     (string-map (lambda (x)
		   (string-append "|(1<<"
				  (gen-sym self)
				  "_" (gen-c-symbol x) ")"))
		 (bitset-attr->list value)))))
d1015 5
a1019 1
   (number->string value))
d1023 1
a1023 1
 <enum-attribute> 'gen-value-for-defn
d1028 12
a1039 1
				 (symbol->string value)))))
@


1.2
log
@	* mach.scm (current-*-add!): Disallow redefinition.  Make result
	"unspecified".
	* insn.scm (insn-builtin!): Don't define relaxable here, now defined in
	operand.scm.
	* operand.scm (operand-builtin!): Define RELAXABLE for insns too.
	* cpu/m32r.cpu (disp8,disp24): RELAX renamed to RELAXABLE.

	* gen-all-doc: Split arm and frv docs up a bit.

	* cpu/arm.cpu: Add IDOC attribute.
	* cpu/frv.cpu: Ditto.
	* cpu/i960.cpu: Ditto.
	* cpu/openrisc.cpu: Ditto.
	* cpu/xstormy16.cpu: Ditto.
	* cpu/m32r.cpu: Ditto.
	(all insns): Explicitly specify IDOC attribute.

	* Makefile.am (MACH,ISAS,INSN_FILE_NAME): New vars.
	(desc,opcodes,sim-arch,sim-cpu,gas-test,sim-test): Use MACH,ISAS.
	(html): Use MACH,ISAS,INSN_FILE_NAME.  Generate insn.html separately.
	* Makefile.in: Regenerate.
	* attr.scm (<integer-attribute>:parse-value-def): Implement.
	(-attr-read): Defer computing default value until we know the type.
	(attr-has-attr?): Delete, move contents to <attr-list>:has-attr?.
	(<attr-list>:attr-present?): New method.
	(atlist-attr-present?,obj-attr-present?): New fns.
	(obj-has-attr-value?,obj-has-attr-value-no-default?): New fns.
	(attr-builtin!): New insn attr IDOC.
	* cgen-doc.scm (doc-arguments): New args -I,-N.
	* enum.scm (parse-enum-vals): New arg errtxt, all callers updated.
	Support comment as fourth element of enum value.
	(enum-val-name,enum-val-value,enum-val-attrs,enum-val-comment): New fns.
	* html.scm (gen-html-header): New arg kind, all callers updated.
	(gen-table-of-contents): New arg insn-file, all callers updated.
	(gen-list-entry,gen-doc-header): New fn.
	(get-operands): Delete.
	(gen-iformat-table): Rewrite.
	(gen-insn-doc-1): Print constant-folded and trimmed semantics.
	(gen-insn-doc-list): New args name, comment, insns.  All callers updated.
	(get-insn-properties,guess-insn-idoc-attr!): New fn.
	(insn-sets-pc?,insn-refs-mem?,insn-uses-fpu?): New fns.
	(get-insns-for-category,gen-categories-insn-lists): New fns.
	(gen-insn-docs): Simplify each insn's semantics first.
	Print insn tables sorted by IDOC categories.
	(*insn-html-file-name*): New global.
	(cgen-insn.html): New fn.
	(cgen-all): Update.
	* insn.scm (<insn>): Create a setter for the `tmp' member.
	* semantics.scm (insn-build-known-values): Renamed from
	-build-known-values.  All callers updated.

	* rtl.scm: Move traveral/evaluation support to ...
	* rtl-traverse.scm: New file.
	* read.scm: Maybe-load rtl-traverse.scm.

	* rtl.scm (-rtx-valid-types): Add SETRTX.

	* rtx-funcs.scm (nop,parallel): Fix mode.

	* utils.scm (eqv-lookup-index): New fn.
	(assq-lookup-index): Renamed from lookup-index.  All callers updated.

	* dev.scm (load-doc): Set APPLICATION.
@
text
@d307 1
a307 1
	 (errtxt (string-append errtxt ":" name))
d613 1
a613 1
  (map string->symbol (string-cut x #\,))
d754 2
a755 2
		       (if (char=? (string-ref elm 0) #\!)
			   (set! alist (acons (string->symbol (string-drop1 elm)) #f alist))
d924 1
a924 1
 ;(string-upcase (string-append (obj:name self) "_" value)))
d948 4
a951 1
   (string-upcase (gen-c-symbol (string-append (obj:name self) "_" value))))
@


1.1
log
@Initial revision
@
text
@d93 4
a96 1
; For bitset attributes, VALUES is a list of symbols, one for each bit.
d100 2
d110 4
a113 2
; For integer attributes, VALUES is a list of ints, one for each possible
; value, or the empty list of all values are permissible.
d122 7
a128 2
; For enum attributes, VALUES is a list of symbols, one for each possible
; value.
d175 1
d264 1
a264 1
   (parse-enum-vals "" values))
d268 1
a268 1
; FIXME: Unfinished.
d272 8
a279 1
 (lambda (self errtxt values) values)
d288 1
a288 1
   (parse-enum-vals "" values))
d350 2
a351 2
	(default #f) ; assume boolean
	(values '(#f #t)) ; assume boolean
d377 26
d408 1
a408 1
; Main routine for defining attributes in .cpu files.
d430 7
a436 5
(define (attr-has-attr? alist attr)
  (let ((a (assq attr alist)))
    (cond ((not a) a)
	  ((boolean? (cdr a)) (cdr a))
	  (else (error "Not a boolean attribute:" attr))))
d439 2
a440 2
(method-make! <attr-list> 'has-attr?
	      (lambda (self attr) (attr-has-attr? (elm-get self 'attrs) attr))
d443 11
a453 2
(define (atlist-has-attr? atlist attr)
  (send atlist 'has-attr? attr)
d542 1
d564 1
a564 1
; OBJ is any object.
d573 6
d586 20
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
