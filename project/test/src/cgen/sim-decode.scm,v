head	1.17;
access;
symbols
	sid-snapshot-20180601:1.17
	cgen-snapshot-20180601:1.17
	sid-snapshot-20180501:1.17
	cgen-snapshot-20180501:1.17
	sid-snapshot-20180401:1.17
	cgen-snapshot-20180401:1.17
	sid-snapshot-20180301:1.17
	cgen-snapshot-20180301:1.17
	sid-snapshot-20180201:1.17
	cgen-snapshot-20180201:1.17
	sid-snapshot-20180101:1.17
	cgen-snapshot-20180101:1.17
	sid-snapshot-20171201:1.17
	cgen-snapshot-20171201:1.17
	sid-snapshot-20171101:1.17
	cgen-snapshot-20171101:1.17
	sid-snapshot-20171001:1.17
	cgen-snapshot-20171001:1.17
	sid-snapshot-20170901:1.17
	cgen-snapshot-20170901:1.17
	sid-snapshot-20170801:1.17
	cgen-snapshot-20170801:1.17
	sid-snapshot-20170701:1.17
	cgen-snapshot-20170701:1.17
	sid-snapshot-20170601:1.17
	cgen-snapshot-20170601:1.17
	sid-snapshot-20170501:1.17
	cgen-snapshot-20170501:1.17
	sid-snapshot-20170401:1.17
	cgen-snapshot-20170401:1.17
	sid-snapshot-20170301:1.17
	cgen-snapshot-20170301:1.17
	sid-snapshot-20170201:1.17
	cgen-snapshot-20170201:1.17
	sid-snapshot-20170101:1.17
	cgen-snapshot-20170101:1.17
	sid-snapshot-20161201:1.17
	cgen-snapshot-20161201:1.17
	sid-snapshot-20161101:1.17
	cgen-snapshot-20161101:1.17
	sid-snapshot-20160901:1.17
	cgen-snapshot-20160901:1.17
	sid-snapshot-20160801:1.17
	cgen-snapshot-20160801:1.17
	sid-snapshot-20160701:1.17
	cgen-snapshot-20160701:1.17
	sid-snapshot-20160601:1.17
	cgen-snapshot-20160601:1.17
	sid-snapshot-20160501:1.17
	cgen-snapshot-20160501:1.17
	sid-snapshot-20160401:1.17
	cgen-snapshot-20160401:1.17
	sid-snapshot-20160301:1.17
	cgen-snapshot-20160301:1.17
	sid-snapshot-20160201:1.17
	cgen-snapshot-20160201:1.17
	sid-snapshot-20160101:1.17
	cgen-snapshot-20160101:1.17
	sid-snapshot-20151201:1.17
	cgen-snapshot-20151201:1.17
	sid-snapshot-20151101:1.17
	cgen-snapshot-20151101:1.17
	sid-snapshot-20151001:1.17
	cgen-snapshot-20151001:1.17
	sid-snapshot-20150901:1.17
	cgen-snapshot-20150901:1.17
	sid-snapshot-20150801:1.17
	cgen-snapshot-20150801:1.17
	sid-snapshot-20150701:1.17
	cgen-snapshot-20150701:1.17
	sid-snapshot-20150601:1.17
	cgen-snapshot-20150601:1.17
	sid-snapshot-20150501:1.17
	cgen-snapshot-20150501:1.17
	sid-snapshot-20150401:1.17
	cgen-snapshot-20150401:1.17
	sid-snapshot-20150301:1.17
	cgen-snapshot-20150301:1.17
	sid-snapshot-20150201:1.17
	cgen-snapshot-20150201:1.17
	sid-snapshot-20150101:1.17
	cgen-snapshot-20150101:1.17
	sid-snapshot-20141201:1.17
	cgen-snapshot-20141201:1.17
	sid-snapshot-20141101:1.17
	cgen-snapshot-20141101:1.17
	sid-snapshot-20141001:1.17
	cgen-snapshot-20141001:1.17
	sid-snapshot-20140901:1.17
	cgen-snapshot-20140901:1.17
	sid-snapshot-20140801:1.17
	cgen-snapshot-20140801:1.17
	sid-snapshot-20140701:1.17
	cgen-snapshot-20140701:1.17
	sid-snapshot-20140601:1.17
	cgen-snapshot-20140601:1.17
	sid-snapshot-20140501:1.17
	cgen-snapshot-20140501:1.17
	sid-snapshot-20140401:1.17
	cgen-snapshot-20140401:1.17
	sid-snapshot-20140301:1.17
	cgen-snapshot-20140301:1.17
	sid-snapshot-20140201:1.17
	cgen-snapshot-20140201:1.17
	sid-snapshot-20140101:1.17
	cgen-snapshot-20140101:1.17
	sid-snapshot-20131201:1.17
	cgen-snapshot-20131201:1.17
	sid-snapshot-20131101:1.17
	cgen-snapshot-20131101:1.17
	sid-snapshot-20131001:1.17
	cgen-snapshot-20131001:1.17
	sid-snapshot-20130901:1.17
	cgen-snapshot-20130901:1.17
	sid-snapshot-20130801:1.17
	cgen-snapshot-20130801:1.17
	sid-snapshot-20130701:1.17
	cgen-snapshot-20130701:1.17
	sid-snapshot-20130601:1.17
	cgen-snapshot-20130601:1.17
	sid-snapshot-20130501:1.17
	cgen-snapshot-20130501:1.17
	sid-snapshot-20130401:1.17
	cgen-snapshot-20130401:1.17
	sid-snapshot-20130301:1.17
	cgen-snapshot-20130301:1.17
	sid-snapshot-20130201:1.17
	cgen-snapshot-20130201:1.17
	sid-snapshot-20130101:1.17
	cgen-snapshot-20130101:1.17
	sid-snapshot-20121201:1.17
	cgen-snapshot-20121201:1.17
	sid-snapshot-20121101:1.17
	cgen-snapshot-20121101:1.17
	sid-snapshot-20121001:1.17
	cgen-snapshot-20121001:1.17
	sid-snapshot-20120901:1.17
	cgen-snapshot-20120901:1.17
	sid-snapshot-20120801:1.17
	cgen-snapshot-20120801:1.17
	sid-snapshot-20120701:1.17
	cgen-snapshot-20120701:1.17
	sid-snapshot-20120601:1.17
	cgen-snapshot-20120601:1.17
	sid-snapshot-20120501:1.17
	cgen-snapshot-20120501:1.17
	sid-snapshot-20120401:1.17
	cgen-snapshot-20120401:1.17
	sid-snapshot-20120301:1.17
	cgen-snapshot-20120301:1.17
	sid-snapshot-20120201:1.17
	cgen-snapshot-20120201:1.17
	sid-snapshot-20120101:1.17
	cgen-snapshot-20120101:1.17
	sid-snapshot-20111201:1.17
	cgen-snapshot-20111201:1.17
	sid-snapshot-20111101:1.17
	cgen-snapshot-20111101:1.17
	sid-snapshot-20111001:1.17
	cgen-snapshot-20111001:1.17
	sid-snapshot-20110901:1.17
	cgen-snapshot-20110901:1.17
	sid-snapshot-20110801:1.17
	cgen-snapshot-20110801:1.17
	sid-snapshot-20110701:1.17
	cgen-snapshot-20110701:1.17
	sid-snapshot-20110601:1.17
	cgen-snapshot-20110601:1.17
	sid-snapshot-20110501:1.17
	cgen-snapshot-20110501:1.17
	sid-snapshot-20110401:1.17
	cgen-snapshot-20110401:1.17
	sid-snapshot-20110301:1.17
	cgen-snapshot-20110301:1.17
	sid-snapshot-20110201:1.17
	cgen-snapshot-20110201:1.17
	sid-snapshot-20110101:1.17
	cgen-snapshot-20110101:1.17
	sid-snapshot-20101201:1.17
	cgen-snapshot-20101201:1.17
	sid-snapshot-20101101:1.17
	cgen-snapshot-20101101:1.17
	sid-snapshot-20101001:1.17
	cgen-snapshot-20101001:1.17
	sid-snapshot-20100901:1.17
	cgen-snapshot-20100901:1.17
	sid-snapshot-20100801:1.17
	cgen-snapshot-20100801:1.17
	sid-snapshot-20100701:1.17
	cgen-snapshot-20100701:1.17
	sid-snapshot-20100601:1.17
	cgen-snapshot-20100601:1.17
	sid-snapshot-20100501:1.17
	cgen-snapshot-20100501:1.17
	sid-snapshot-20100401:1.17
	cgen-snapshot-20100401:1.17
	sid-snapshot-20100301:1.17
	cgen-snapshot-20100301:1.17
	sid-snapshot-20100201:1.15
	cgen-snapshot-20100201:1.15
	sid-snapshot-20100101:1.15
	cgen-snapshot-20100101:1.15
	sid-snapshot-20091201:1.15
	cgen-snapshot-20091201:1.15
	sid-snapshot-20091101:1.13
	cgen-snapshot-20091101:1.13
	sid-snapshot-20091001:1.13
	cgen-snapshot-20091001:1.13
	arc-sim-20090309:1.9
	sid-snapshot-20090901:1.11
	cgen-snapshot-20090901:1.11
	sid-snapshot-20090801:1.11
	cgen-snapshot-20090801:1.11
	sid-snapshot-20090701:1.11
	cgen-snapshot-20090701:1.11
	dje-cgen-play1-branch:1.11.0.2
	dje-cgen-play1-branchpoint:1.11
	cgen-1_1-branch:1.10.0.2
	cgen-1_1-branchpoint:1.10
	sid-snapshot-20090601:1.9
	cgen-snapshot-20090601:1.9
	sid-snapshot-20090501:1.9
	cgen-snapshot-20090501:1.9
	sid-snapshot-20090401:1.9
	cgen-snapshot-20090401:1.9
	arc-insight_6_8-branch:1.9.0.4
	arc-insight_6_8-branchpoint:1.9
	sid-snapshot-20090301:1.9
	cgen-snapshot-20090301:1.9
	sid-snapshot-20090201:1.9
	cgen-snapshot-20090201:1.9
	sid-snapshot-20090101:1.9
	cgen-snapshot-20090101:1.9
	sid-snapshot-20081201:1.9
	cgen-snapshot-20081201:1.9
	sid-snapshot-20081101:1.9
	cgen-snapshot-20081101:1.9
	sid-snapshot-20081001:1.9
	cgen-snapshot-20081001:1.9
	sid-snapshot-20080901:1.9
	cgen-snapshot-20080901:1.9
	sid-snapshot-20080801:1.9
	cgen-snapshot-20080801:1.9
	sid-snapshot-20080701:1.9
	cgen-snapshot-20080701:1.9
	sid-snapshot-20080601:1.9
	cgen-snapshot-20080601:1.9
	sid-snapshot-20080501:1.9
	cgen-snapshot-20080501:1.9
	sid-snapshot-20080403:1.9
	sid-snapshot-20080401:1.9
	cgen-snapshot-20080401:1.9
	sid-snapshot-20080301:1.9
	cgen-snapshot-20080301:1.9
	sid-snapshot-20080201:1.9
	cgen-snapshot-20080201:1.9
	sid-snapshot-20080101:1.9
	cgen-snapshot-20080101:1.9
	sid-snapshot-20071201:1.9
	cgen-snapshot-20071201:1.9
	sid-snapshot-20071101:1.9
	cgen-snapshot-20071101:1.9
	sid-snapshot-20071001:1.9
	cgen-snapshot-20071001:1.9
	msnyder-fork-checkpoint-branch:1.9.0.2
	msnyder-fork-checkpoint-branchpoint:1.9
	sid-20020905-branchpoint:1.6
	sid-20020905-branch:1.6.0.6
	cagney_regbuf-20020515-branch:1.6.0.4
	cagney_regbuf-20020515-branchpoint:1.6
	cygnus_cvs_20020108_pre:1.6
	cgen-1-1-branch:1.6.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.17
date	2010.02.13.03.39.15;	author devans;	state Exp;
branches;
next	1.16;

1.16
date	2010.02.12.02.12.12;	author devans;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.23.00.59.57;	author devans;	state Exp;
branches;
next	1.14;

1.14
date	2009.11.03.16.24.02;	author devans;	state Exp;
branches;
next	1.13;

1.13
date	2009.09.10.07.23.29;	author devans;	state Exp;
branches;
next	1.12;

1.12
date	2009.09.07.22.17.34;	author devans;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.20.21.34.28;	author devans;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2003.07.08.16.19.35;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.15.07.25.02;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.20.02.22.22;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	2001.04.02.22.04.48;	author bje;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.05.15.43.38;	author brolley;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.06.12.11.09;	author bje;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.07.12.27.00;	author bje;	state Exp;
branches;
next	1.2;

1.2
date	2000.11.11.17.26.22;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.10.2.1
date	2009.06.24.14.57.46;	author devans;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.17
log
@update copyright year
@
text
@; Decoder generation.
; Copyright (C) 2000, 2001, 2009, 2010 Red Hat, Inc.
; This file is part of CGEN.

; Names of various global vars.

; Name of insn descriptor table var.
(define IDESC-TABLE-VAR "@@prefix@@_insn_data")

; Return decode entries for each insn.
; ??? At one point we generated one variable per instruction rather than one
; big array.  It doesn't matter too much (yet).  Generating one big array is
; simpler.

(define (/gen-decode-insn-globals insn-list)
  ; Print the higher detailed stuff at higher verbosity.
  (logit 2 "Processing decode insn globals ...\n")

  (string-write

   (if (and (with-parallel?) (not (with-parallel-only?)))
       "\
/* Insn can't be executed in parallel.
   Or is that \"do NOt Pass to Air defense Radar\"? :-) */
#define NOPAR (-1)
\n"
       "")

   "\
/* The instruction descriptor array.
   This is computed at runtime.  Space for it is not malloc'd to save a
   teensy bit of cpu in the decoder.  Moving it to malloc space is trivial
   but won't be done until necessary (we don't currently support the runtime
   addition of instructions nor an SMP machine with different cpus).  */
static IDESC " IDESC-TABLE-VAR "[@@PREFIX@@_INSN__MAX];

/* Commas between elements are contained in the macros.
   Some of these are conditionally compiled out.  */

static const struct insn_sem @@prefix@@_insn_sem[] =
{\n"

   (string-list-map
    (lambda (insn)
      (let ((name (gen-sym insn))
	    (pbb? (obj-has-attr? insn 'PBB))
	    (virtual? (insn-virtual? insn)))
	(string-list
	 "  { "
	 (if virtual?
	     (string-append "VIRTUAL_INSN_" (string-upcase name) ", ")
	     (string-append "@@ARCH@@_INSN_" (string-upcase name) ", "))
         (string-append "@@PREFIX@@_INSN_" (string-upcase name) ", ")
	 "@@PREFIX@@_" (/gen-fmt-enum (insn-sfmt insn))
	 (if (and (with-parallel?) (not (with-parallel-only?)))
	     (string-list
	      (if (insn-parallel? insn)
		  (string-append ", @@PREFIX@@_INSN_PAR_"
				 (string-upcase name)
				 ", "
				 (if (with-parallel-read?)
				     "@@PREFIX@@_INSN_READ_"
				     "@@PREFIX@@_INSN_WRITE_")
				 (string-upcase name))
		  ", NOPAR, NOPAR "))
	     "")
	 " },\n")))
    insn-list)

   "\
};

static const struct insn_sem @@prefix@@_insn_sem_invalid =
{
  VIRTUAL_INSN_X_INVALID, @@PREFIX@@_INSN_X_INVALID, @@PREFIX@@_SFMT_EMPTY"
   (if (and (with-parallel?) (not (with-parallel-only?)))
       ", NOPAR, NOPAR"
       "")
   "
};
\n"
   )
)

; Return enum name of format FMT.

(define (/gen-fmt-enum fmt)
  (string-upcase (gen-sym fmt))
)

; Generate decls for the insn descriptor table type IDESC.

(define (/gen-idesc-decls)
  (string-append "\
extern const IDESC *@@prefix@@_decode (SIM_CPU *, IADDR,
                                  CGEN_INSN_WORD,"
  (if (adata-integral-insn? CURRENT-ARCH)
      " CGEN_INSN_WORD,\n"
      "\n")
  "\
                                  ARGBUF *);
extern void @@prefix@@_init_idesc_table (SIM_CPU *);
extern void @@prefix@@_sem_init_idesc_table (SIM_CPU *);
extern void @@prefix@@_semf_init_idesc_table (SIM_CPU *);
\n")
)

; Return definition of C function to initialize the IDESC table.
; @@prefix@@_init_idesc_table is defined here as it depends on with-parallel?
; and thus can't be defined in sim/common.

(define (/gen-idesc-init-fn)
  (string-append "\
/* Initialize an IDESC from the compile-time computable parts.  */

static INLINE void
init_idesc (SIM_CPU *cpu, IDESC *id, const struct insn_sem *t)
{
  const CGEN_INSN *insn_table = CGEN_CPU_INSN_TABLE (CPU_CPU_DESC (cpu))->init_entries;

  id->num = t->index;
  id->sfmt = t->sfmt;
  if ((int) t->type <= 0)
    id->idata = & cgen_virtual_insn_table[- (int) t->type];
  else
    id->idata = & insn_table[t->type];
  id->attrs = CGEN_INSN_ATTRS (id->idata);
  /* Oh my god, a magic number.  */
  id->length = CGEN_INSN_BITSIZE (id->idata) / 8;

#if WITH_PROFILE_MODEL_P
  id->timing = & MODEL_TIMING (CPU_MODEL (cpu)) [t->index];
  {
    SIM_DESC sd = CPU_STATE (cpu);
    SIM_ASSERT (t->index == id->timing->num);
  }
#endif

  /* Semantic pointers are initialized elsewhere.  */
}

/* Initialize the instruction descriptor table.  */

void
@@prefix@@_init_idesc_table (SIM_CPU *cpu)
{
  IDESC *id,*tabend;
  const struct insn_sem *t,*tend;
  int tabsize = @@PREFIX@@_INSN__MAX;
  IDESC *table = " IDESC-TABLE-VAR ";

  memset (table, 0, tabsize * sizeof (IDESC));

  /* First set all entries to the `invalid insn'.  */
  t = & @@prefix@@_insn_sem_invalid;
  for (id = table, tabend = table + tabsize; id < tabend; ++id)
    init_idesc (cpu, id, t);

  /* Now fill in the values for the chosen cpu.  */
  for (t = @@prefix@@_insn_sem, tend = t + sizeof (@@prefix@@_insn_sem) / sizeof (*t);
       t != tend; ++t)
    {
      init_idesc (cpu, & table[t->index], t);\n"

   (if (and (with-parallel?) (not (with-parallel-only?)))
       "\
      if (t->par_index != NOPAR)
	{
	  init_idesc (cpu, &table[t->par_index], t);
	  table[t->index].par_idesc = &table[t->par_index];
	}\n"
       "")

   (if (and (with-parallel-write?) (not (with-parallel-only?)))
       "\
      if (t->par_index != NOPAR)
	{
	  init_idesc (cpu, &table[t->write_index], t);
	  table[t->par_index].par_idesc = &table[t->write_index];
	}\n"
       "")

   "\
    }

  /* Link the IDESC table into the cpu.  */
  CPU_IDESC (cpu) = table;
}

")
)

; Instruction field extraction support.
; Two implementations are provided, one for !with-scache and one for
; with-scache.
;
; Extracting ifields is a three phase process.  First the ifields are
; extracted and stored in local variables.  Then any ifields requiring
; additional processing for operands are handled.  Then in the with-scache
; case the results are stored in a struct for later retrieval by the semantic
; code.
;
; The !with-scache case does this processing in the semantic function,
; except it doesn't need the last step (it doesn't need to store the results
; in a struct for later use).
;
; The with-scache case extracts the ifields in the decode function.
; Furthermore, we use <sformat-argbuf> to reduce the quantity of structures
; created (this helps semantic-fragment pbb engines).

; Return C code to record <ifield> F for the semantic handler
; in a local variable rather than an ARGBUF struct.

(define (/gen-record-argbuf-ifld f sfmt)
  (string-append "  " (gen-ifld-argbuf-ref f)
		 " = " (gen-extracted-ifld-value f) ";\n")
)

; Return three of arguments to TRACE:
; string argument to fprintf, character indicating type of third arg, value.
; The type is one of: x.

(define (/gen-trace-argbuf-ifld f sfmt)
  (string-append
   ; FIXME: Add method to return fprintf format string.
   ", \"" (gen-sym f) " 0x%x\""
   ", 'x'"
   ", " (gen-extracted-ifld-value f))
)

; Instruction field extraction support cont'd.
; Hardware support.

; gen-extract method.
; For the default case we use the ifield as is, which is output elsewhere.

(method-make!
 <hardware-base> 'gen-extract
 (lambda (self op sfmt local?)
   "")
)

; gen-trace-extract method.
; Return appropriate arguments for TRACE_EXTRACT.

(method-make!
 <hardware-base> 'gen-trace-extract
 (lambda (self op sfmt)
   "")
)

; Extract the necessary fields into ARGBUF.

(method-make!
 <hw-register> 'gen-extract
 (lambda (self op sfmt local?)
   (if (hw-cache-addr? self)
       (string-append "  "
		      (if local?
			  (gen-hw-index-argbuf-name (op:index op))
			  (gen-hw-index-argbuf-ref (op:index op)))
		      " = & "
		      (gen-cpu-ref (gen-sym (op:type op)))
		      (gen-array-ref (gen-extracted-ifld-value (op-ifield op)))
		      ";\n")
       ""))
)

; Return appropriate arguments for TRACE_EXTRACT.

(method-make!
 <hw-register> 'gen-trace-extract
 (lambda (self op sfmt)
   (if (hw-cache-addr? self)
       (string-append
	; FIXME: Add method to return fprintf format string.
	", \"" (gen-sym op) " 0x%x\""
	", 'x'"
	", " (gen-extracted-ifld-value (op-ifield op)))
       ""))
)

; Extract the necessary fields into ARGBUF.

(method-make!
 <hw-address> 'gen-extract
 (lambda (self op sfmt local?)
   (string-append "  "
		  (if local?
		      (gen-hw-index-argbuf-name (op:index op))
		      (gen-hw-index-argbuf-ref (op:index op)))
		  " = "
		  (gen-extracted-ifld-value (op-ifield op))
		  ";\n"))
)

; Return appropriate arguments for TRACE_EXTRACT.

(method-make!
 <hw-address> 'gen-trace-extract
 (lambda (self op sfmt)
   (string-append
    ; FIXME: Add method to return fprintf format string.
    ", \"" (gen-sym op) " 0x%x\""
    ", 'x'"
    ", " (gen-extracted-ifld-value (op-ifield op))))
)

; Instruction field extraction support cont'd.
; Operand support.

; Return C code to record the field for the semantic handler.
; In the case of a register, this is usually the address of the register's
; value (if CACHE-ADDR).
; LOCAL? indicates whether to record the value in a local variable or in
; the ARGBUF struct.
; ??? Later allow target to provide an `extract' expression.

(define (/gen-op-extract op sfmt local?)
  (send (op:type op) 'gen-extract op sfmt local?)
)

; Return three of arguments to TRACE_EXTRACT:
; string argument to fprintf, character indicating type of third arg, value.
; The type is one of: x.

(define (/gen-op-trace-extract op sfmt)
  (send (op:type op) 'gen-trace-extract op sfmt)
)

; Return C code to define local vars to hold processed ifield data for
; <sformat> SFMT.
; This is used when !with-scache.
; Definitions of the extracted ifields is handled elsewhere.

(define (gen-sfmt-op-argbuf-defns sfmt)
  (let ((operands (sfmt-extracted-operands sfmt)))
    (string-list-map (lambda (op)
		       (let ((var-spec (sfmt-op-sbuf-elm op sfmt)))
			 (if var-spec
			     (string-append "  "
					    (cadr var-spec)
					    " "
					    (car var-spec)
					    ";\n")
			     "")))
		     operands))
)

; Return C code to assign values to the local vars that hold processed ifield
; data for <sformat> SFMT.
; This is used when !with-scache.
; Assignment of the extracted ifields is handled elsewhere.

(define (gen-sfmt-op-argbuf-assigns sfmt)
  (let ((operands (sfmt-extracted-operands sfmt)))
    (string-list-map (lambda (op)
		       (/gen-op-extract op sfmt #t))
		     operands))
)

; Instruction field extraction support cont'd.
; Emit extraction section of decode function.

; Return C code to record insn field data for <sformat> SFMT.
; This is used when with-scache.

(define (/gen-record-args sfmt)
  (let ((operands (sfmt-extracted-operands sfmt))
	(iflds (sfmt-needed-iflds sfmt)))
    (string-list
     "  /* Record the fields for the semantic handler.  */\n"
     (string-list-map (lambda (f) (/gen-record-argbuf-ifld f sfmt))
		      iflds)
     (string-list-map (lambda (op) (/gen-op-extract op sfmt #f))
		      operands)
     "  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "
     "\"" (gen-sym sfmt) "\""
     (string-list-map (lambda (f) (/gen-trace-argbuf-ifld f sfmt))
		      iflds)
     (string-list-map (lambda (op) (/gen-op-trace-extract op sfmt))
		      operands)
     ", (char *) 0));\n"
     ))
)

; Return C code to record insn field data for profiling.
; Also recorded are operands not mentioned in the fields but mentioned
; in the semantic code.
;
; FIXME: Register usage may need to be tracked as an array of longs.
; If there are more than 32 regs, we can't know which until build time.
; ??? For now we only handle reg sets of 32 or less.
;
; ??? The other way to obtain register numbers is to defer computing them
; until they're actually needed.  It will speed up execution when not doing
; profiling, though the speed up is only for the extraction phase.
; On the other hand the current way has one memory reference per register
; number in the profiling routines.  For RISC this can be a lose, though for
; more complicated instruction sets it could be a win as all the computation
; is kept to the extraction phase.  If someone wants to put forth some real
; data, this might then be changed (or at least noted).

(define (/gen-record-profile-args sfmt)
  (let ((in-ops (find op-profilable? (sfmt-in-ops sfmt)))
	(out-ops (find op-profilable? (sfmt-out-ops sfmt)))
	)
    (if (and (null? in-ops) (null? out-ops))
	""
	(string-list
	 "#if WITH_PROFILE_MODEL_P\n"
	 "  /* Record the fields for profiling.  */\n"
	 "  if (PROFILE_MODEL_P (current_cpu))\n"
	 "    {\n"
	 (string-list-map (lambda (op) (op:record-profile op sfmt #f))
			  in-ops)
	 (string-list-map (lambda (op) (op:record-profile op sfmt #t))
			  out-ops)
	 "    }\n"
	 "#endif\n"
	 )))
)

; Return C code that extracts the fields of <sformat> SFMT.
;
; Extraction is based on formats to reduce the amount of code generated.
; However, we also need to emit code which records the hardware elements used
; by the semantic code.  This is currently done by recording this information
; with the format.

(define (/gen-extract-case sfmt)
  (logit 2 "Processing extractor for \"" (sfmt-key sfmt) "\" ...\n")
  (string-list
   " extract_" (gen-sym sfmt) ":\n"
   "  {\n"
   "    const IDESC *idesc = &" IDESC-TABLE-VAR "[itype];\n"
   (if (> (length (sfmt-iflds sfmt)) 0)
       (string-append
	"    CGEN_INSN_WORD insn = "
	(if (adata-integral-insn? CURRENT-ARCH)
	    "entire_insn;\n"
	    "base_insn;\n"))
       "")
   (gen-define-field-macro sfmt)
   (gen-define-ifields (sfmt-iflds sfmt) (sfmt-length sfmt) "    " #f)
   "\n"
   (gen-extract-ifields (sfmt-iflds sfmt) (sfmt-length sfmt) "    " #f)
   "\n"
   (/gen-record-args sfmt)
   "\n"
   (/gen-record-profile-args sfmt)
   (gen-undef-field-macro sfmt)
   "    return idesc;\n"
   "  }\n\n"
   )
)

; For each format, return its extraction function.

(define (/gen-all-extractors)
  (logit 2 "Processing extractors ...\n")
  (string-list-map /gen-extract-case (current-sfmt-list))
)

; Generate top level decoder.
; INITIAL-BITNUMS is a target supplied list of bit numbers to use to
; build the first decode table.  If nil, we compute 8 bits of it (FIXME)
; ourselves.
; LSB0? is non-#f if bit number 0 is the least significant bit.

(define (/gen-decode-fn insn-list initial-bitnums lsb0?)

  ; Compute the initial DECODE-BITSIZE as the minimum of all insn lengths.
  ; The caller of @@prefix@@_decode must fetch and pass exactly this number of bits
  ; of the instruction.
  ; ??? Make this a parameter later but only if necessary.

  (let ((decode-bitsize (apply min (map insn-base-mask-length insn-list))))

    ; Compute INITIAL-BITNUMS if not supplied.
    ; 0 is passed for the start bit (it is independent of lsb0?)
    (if (null? initial-bitnums)
	(set! initial-bitnums (decode-get-best-bits insn-list nil
						    0 ; startbit
						    8 ; max
						    decode-bitsize
						    lsb0?)))

    ; All set.  gen-decoder does the hard part, we just print out the result. 
    (let ((decode-code (gen-decoder insn-list initial-bitnums
				    decode-bitsize
				    "    " lsb0?
				    (current-insn-lookup 'x-invalid #f)
				    #f)))

      (string-write
       "\
/* Given an instruction, return a pointer to its IDESC entry.  */

const IDESC *
@@prefix@@_decode (SIM_CPU *current_cpu, IADDR pc,
              CGEN_INSN_WORD base_insn,"
       (if (adata-integral-insn? CURRENT-ARCH)
	   " CGEN_INSN_WORD entire_insn,\n"
	   "\n")
       "\
              ARGBUF *abuf)
{
  /* Result of decoder.  */
  @@PREFIX@@_INSN_TYPE itype;

  {
    CGEN_INSN_WORD insn = base_insn;
\n"

       decode-code

       "\
  }
\n"

       (if (with-scache?)
           (string-list "\
  /* The instruction has been decoded, now extract the fields.  */\n\n"
            /gen-all-extractors)
	   ; Without the scache, extraction is defered until the semantic code.
	   (string-list "\
  /* Extraction is defered until the semantic code.  */

 done:
  return &" IDESC-TABLE-VAR "[itype];\n"))

       "\
}\n"
       )))
)

; Entry point.  Generate decode.h.

(define (cgen-decode.h)
  (logit 1 "Generating " (gen-cpu-name) "'s decode.h ...\n")

  (sim-analyze-insns!)

  ; Turn parallel execution support on if cpu needs it.
  (set-with-parallel?! (state-parallel-exec?))

  (string-write
   (gen-c-copyright "Decode header for @@prefix@@."
		  CURRENT-COPYRIGHT CURRENT-PACKAGE)
   "\
#ifndef @@PREFIX@@_DECODE_H
#define @@PREFIX@@_DECODE_H

"
   /gen-idesc-decls
   (lambda () (gen-cpu-insn-enum-decl (current-cpu)
				      (non-multi-insns (non-alias-insns (current-insn-list)))))
   (lambda () (gen-sfmt-enum-decl (current-sfmt-list)))
   gen-model-fn-decls
   "#endif /* @@PREFIX@@_DECODE_H */\n"
   )
)

; Entry point.  Generate decode.c.

(define (cgen-decode.c)
  (logit 1 "Generating " (gen-cpu-name) "'s decode.c ...\n")

  (sim-analyze-insns!)

  ; Turn parallel execution support on if cpu needs it.
  (set-with-parallel?! (state-parallel-exec?))

  ; Tell the rtx->c translator we are the simulator.
  (rtl-c-config! #:rtl-cover-fns? #t)

  (string-write
   (gen-c-copyright "Simulator instruction decoder for @@prefix@@."
		  CURRENT-COPYRIGHT CURRENT-PACKAGE)
   "\
#define WANT_CPU @@cpu@@
#define WANT_CPU_@@CPU@@

#include \"sim-main.h\"
#include \"sim-assert.h\"\n\n"

   (lambda () (/gen-decode-insn-globals (non-multi-insns (non-alias-insns (current-insn-list)))))
   /gen-idesc-init-fn
   (lambda () (/gen-decode-fn (real-insns (current-insn-list))
			      (state-decode-assist)
			      (current-arch-insn-lsb0?)))
   )
)
@


1.16
log
@	* desc-cpu.scm (/gen-cpu-open): Remove comment on K&R support.
	* utils-cgen.scm (gen-define-with-symcat): Remove K&R support.

	* utils-sim.scm (compute-sformat-argbufs!): Use more consistent name
	for name of empty sbuf.

	* iformat.scm (/sfmt-search-key, /ifmt-lookup-sfmt!): Add assert.

	* insn.scm (<insn>): Add initial value for members fmt-desc, ifmt,
	sfmt, tmp.
	(/sub-insn-ifields): Delete old commented out code.
	(/sub-insn-make!, /parse-insn-format-symbol): Ditto.
	* operand.scm (/anyof-merge-setter, anyof-merge-semantics): Ditto.

	* sim-decode.scm (/gen-decode-insn-globals): Tweak formatting of
	generated code.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2001, 2009 Red Hat, Inc.
@


1.15
log
@	* mach.scm (<derived-arch-data>): New member large-insn-word?.
	(/adata-set-derived!): Set it.
	(adata-large-insn-word?): New function.
	* sim-arch.scm (/gen-cpuall-includes): Don't #include cgen-engine.h
	here.
	* sim-cpu.scm (cgen-cpu.h): #include it here.
	(/gen-cpu-defines): Define CGEN_INSN_WORD.
	(/gen-no-scache-semantic-fn): Use CGEN_INSN_WORD instead of
	CGEN_INSN_INT.
	* sim-decode.scm (/gen-idesc-decls): Ditto.
	(/gen-extract-case, /gen-decode-fn): Ditto.
	* sim-model.scm (/gen-model-insn-fn): Ditto.
	* sim.scm (gen-argbuf-type): Ditto.
@
text
@d73 2
a74 1
static const struct insn_sem @@prefix@@_insn_sem_invalid = {
@


1.14
log
@	Specify isa(s) when doing ifield, operand, insn lookups.
	ACU = all callers updated.
	* attr.scm (/attr-eval): Call rtx-value instead of rtx-eval-with-estate.
	* enum.scm (define-full-insn-enum): Pass isa-name-list to
	current-ifld-lookup.
	* html.scm (get-insn-properties): Pass isa-name-list to
	current-op-lookup.
	* ifield.scm (/ifld-parse-follows): New arg isas, ACU.
	* insn.scm (/parse-insn-format-symbol): New arg isa-name-list, ACU.
	(/parse-insn-format-list, /parse-insn-iformat-iflds): Ditto.
	(/parse-insn-format, syntax-break-out): Ditto.
	* mach.scm (obj-filter-by-isa): New function.
	(current-ifld-lookup): New optional arg maybe-isa-name-list.
	(/ifld-already-defined?, /op-already-defined?): Simplify.
	(current-op-lookup): New optional arg maybe-isa-name-list.
	(current-insn-lookup): New arg isa-name-list, ACU.
	(/insn-already-defined?, /minsn-already-defined?): Simplify.
	(current-minsn-lookup): New arg isa-name-list, ACU.
	* minsn.scm (/minsn-compute-iflds): Pass isa-name-list to
	current-op-lookup.
	* opc-itab.scm (compute-syntax): New arg isa-name-list, ACU.
	(gen-syntax-entry): Ditto.
	* operand.scm (/operand-parse): Pass isa-name-list to
	current-ifld-lookup.
	(/derived-parse-encoding): New arg isa-name-list, ACU.
	(/derived-parse-ifield-assertion): Ditto.
	(/derived-operand-parse): Pass isa-name-list to current-op-lookup.
	(/anyof-parse-choice): Ditto.
	(anyof-satisfies-assertions?): Pass context to rtx-solve.
	(/anyof-merge-syntax): New arg container, ACU.
	(operand-builtin!): Add pc to all isas.
	* rtl-c.scm (estate-make-for-rtl-c): Delete arg extra-vars-alist, ACU.
	(estate-make-for-rtl-c++, rtl-c-expr-parsed): Ditto.
	(rtl-c-parsed, rtl-c++-parsed): Ditto.
	(rtl-c): New arg isa-name-list, ACU.
	(rtl-c-expr, rtl-c++): Ditto.
	(closure): New arg isa-name-list, ACU.
	* rtl-traverse.scm (/make-cstate): New arg isa-name-list, ACU.
	(/cstate-isas): New function.
	(/rtx-canon-symbol-list): New function.
	(/rtx-canon-env-stack): Renamed from /rtx-canon-env, ACU.
	updated.
	(/rtx-make-canon-table): Rename ENV to ENVSTACK, new entry SYMBOLLIST.
	(/rtx-canon-rtx-operand): Pass isa list to current-op-lookup.
	(/rtx-canon-rtx-ref, /rtx-canon): Ditto.
	(rtx-canonicalize): New arg isa-name-list, ACU.
	(rtx-canonicalize-stmt): Delete.
	(tstate-make): New arg isas, ACU.
	(tstate-isas, tstate--set-isas!): New functions.
	(tstate-env-stack): Renamed from tstate-env, ACU.
	(tstate-set-env-stack!): Renamed from tstate-set-env!, ACU.
	(tstate-make-closure): Renamed from tstate-new-env, new arg
	isa-name-list, ACU.
	(/rtx-traverse-env): Delete.
	(/rtx-make-traverser-table): Rename ENV to ENVSTACK, new entry
	SUMBOLLIST.
	(/rtx-traverse): Include conditional flag in dump output.
	Update isa,envstack for closures.  Pass isa list to current-op-lookup.
	(<eval-state>): New member isas.  Rename env to env-stack.
	(<eval-state> vmake!): Handle #:isas.  #:env renamed to #:env-stack.
	(<eval-state>): New getter/setter for isas.  Rename env getter/setter
	to env-stack.
	(estate-make-for-eval): Provide #:isas.
	(estate-make-closure): Renamed from estate-new-env.  New arg
	isa-name-list, ACU.
	* rtl-xform.scm (/rtx-simplify-expr-fn): Handle closures.
	(/rtx-trim-args): ENV renamed to ENVSTACK.  Ad ITERATION, SYMBOLLIST.
	(/rtx-trim-for-doc): Handle closures.
	* rtl.scm (/rtx-valid-types): Rename ENV to ENVSTACK.  Add ITERATION,
	SYMBOLLIST.
	(rtx-env-var-list): Delete.
	(rtx-env-make): Handle already-compiled environments.
	(rtx-var-alist-to-env): New function.
	(rtx-var-alist-to-closure-env-stack, rtx-make-env-stack): New functions.
	(rtx-env-stack-dump): Renamed from rtx-env-dump, ACU.
	(rtx-operand-obj): New arg isa-name-list, ACU.
	(rtx-closure-isas, rtx-closure-env-stack, rtx-closure-expr): New
	functions.
	* rtx-funcs.scm (closure): New arg isa-name-list, reorder args, ACU.
	* sem-frags.scm (<sfrag>): Delete member compiled-semantics.
	(/frag-compute-desired-frags): Minor simplification.
	(/frag-pick-best): Ditto.
	* sid-cpu.scm (gen-semantic-code): Require canonical rtl.
	(/gen-sfrag-code): Update.
	* sim-cpu.scm (gen-semantic-code): Require canonical rtl.
	* utils-cgen.scm (sanitize): New arg isa-name-list, ACU.
	* utils.scm (non-null-intersection?): New function.
@
text
@d95 1
a95 1
                                  CGEN_INSN_INT,"
d97 1
a97 1
      " CGEN_INSN_INT,\n"
d438 1
a438 1
	"    CGEN_INSN_INT insn = "
d501 1
a501 1
              CGEN_INSN_INT base_insn,"
d503 1
a503 1
	   " CGEN_INSN_INT entire_insn,\n"
d512 1
a512 1
    CGEN_INSN_INT insn = base_insn;
@


1.13
log
@	* insn.scm (/parse-insn-format): New arg `verify?', all callers updated.
	(/insn-parse): Don't verify iformat for virtual insns.

	* sid-decode.scm (cgen-decode.cxx): Remove redundant call to
	non-multi-insns.
	* sid-model.scm (/gen-model-insn-fn-decls): Ditto.
	(/gen-model-insn-fns, /gen-model-class-decls): Ditto.
	* sid.scm (pbb-engine-insns): Ditto.
	* sim-decode.scm (cgen-decode.c): Ditto.
@
text
@d492 1
a492 1
				    (current-insn-lookup 'x-invalid)
@


1.12
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d589 1
a589 1
   (lambda () (/gen-decode-fn (non-multi-insns (real-insns (current-insn-list)))
@


1.11
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d15 1
a15 1
(define (-gen-decode-insn-globals insn-list)
d54 1
a54 1
	 "@@PREFIX@@_" (-gen-fmt-enum (insn-sfmt insn))
d86 1
a86 1
(define (-gen-fmt-enum fmt)
d92 1
a92 1
(define (-gen-idesc-decls)
d111 1
a111 1
(define (-gen-idesc-init-fn)
d213 1
a213 1
(define (-gen-record-argbuf-ifld f sfmt)
d222 1
a222 1
(define (-gen-trace-argbuf-ifld f sfmt)
d318 1
a318 1
(define (-gen-op-extract op sfmt local?)
d326 1
a326 1
(define (-gen-op-trace-extract op sfmt)
d357 1
a357 1
		       (-gen-op-extract op sfmt #t))
d367 1
a367 1
(define (-gen-record-args sfmt)
d372 1
a372 1
     (string-list-map (lambda (f) (-gen-record-argbuf-ifld f sfmt))
d374 1
a374 1
     (string-list-map (lambda (op) (-gen-op-extract op sfmt #f))
d378 1
a378 1
     (string-list-map (lambda (f) (-gen-trace-argbuf-ifld f sfmt))
d380 1
a380 1
     (string-list-map (lambda (op) (-gen-op-trace-extract op sfmt))
d403 1
a403 1
(define (-gen-record-profile-args sfmt)
d430 1
a430 1
(define (-gen-extract-case sfmt)
d448 1
a448 1
   (-gen-record-args sfmt)
d450 1
a450 1
   (-gen-record-profile-args sfmt)
d459 1
a459 1
(define (-gen-all-extractors)
d461 1
a461 1
  (string-list-map -gen-extract-case (current-sfmt-list))
d470 1
a470 1
(define (-gen-decode-fn insn-list initial-bitnums lsb0?)
d524 1
a524 1
            -gen-all-extractors)
d555 1
a555 1
   -gen-idesc-decls
d587 3
a589 3
   (lambda () (-gen-decode-insn-globals (non-multi-insns (non-alias-insns (current-insn-list)))))
   -gen-idesc-init-fn
   (lambda () (-gen-decode-fn (non-multi-insns (real-insns (current-insn-list)))
@


1.10
log
@	* desc-cpu.scm (cgen-desc.h): Tweak logit message for consistency.
	(cgen-desc.c): Ditto.
	* sid-cpu.scm (cgen-desc.h, cgen-cpu.h, cgen-defs.h): Ditto.
	(cgen-write.cxx, cgen-semantics.cxx, cgen-sem-switch.cxx): Ditto.
	* sid-decode.scm (cgen-decode.h, cgen-decode.cxx): Ditto.
	* sid-model.scm (cgen-model.cxx, cgen-model.h): Ditto.
	* sim-arch.scm (cgen-arch.h, cgen-arch.c): Ditto.
	(cgen-cpuall.h, cgen-ops.c): Ditto.
	* sim-cpu.scm (cgen-cpu.h, cgen-defs.h, cgen-cpu.c): Ditto.
	(cgen-read.c, cgen-write.c, cgen-semantics.c): Ditto.
	(cgen-sem-switch.c): Ditto.
	* sim-decode.scm (cgen-decode.h, cgen-decode.c): Ditto.
	* sim-model.c (cgen-model.c): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2001 Red Hat, Inc.
@


1.10.2.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2001, 2009 Red Hat, Inc.
@


1.9
log
@misc. whitespace and comment cleanup
@
text
@d540 1
a540 1
  (logit 1 "Generating " (gen-cpu-name) " decode.h ...\n")
d567 1
a567 1
  (logit 1 "Generating " (gen-cpu-name) " decode.c ...\n")
@


1.8
log
@	* Makefile.am (srcroot): New var.
	(html): New rule.
	* Makefile.in: Regenerate.
	* cgen-doc.scm: New file.
	* html.scm: New file.
	* gen-all-doc: New file.
	* dev.scm (cload): Handle DOC application.
	(load-doc): New fn.
	* machs.scm (machs-for-cpu): New fn.
	* model.scm (models-for-cpu): New fn.
	* utils.scm (gen-c-copyright): Renamed from gen-copyright.
	All uses updated.
	(iota): Rewrite to be identical to pmacro version.  All uses updated.
	* utils-cgen.scm (alpha-sort-obj-list): New fn.
@
text
@a468 3
; FIXME: Need to be perfect for every subtable, or allow target more control.
; Leave for later (and don't give target more control until oodles of effort
; have been spent trying to be perfect! ... or close enough).
@


1.7
log
@	Back out sim*.scm changes of 2001-04-02  Ben Elliston  <bje@@redhat.com>
	Instead do:
	* sim-decode.scm (-gen-decode-insn-globals): Use @@PREFIX@@_INSN__MAX
	as size of IDESC-TABLE-VAR.
	(@@prefix@@_init_idesc_table): Ditto.
	* sim-model.scm (-gen-mach-defns): Ditto.
	* sim.scm (gen-cpu-insn-enum-decl): Rename last elm from max to -max.

	* utils-scm.scm (-gen-decode-insn-entry): Fix some spacing in output.

	* insn.scm (-parse-insn-format-symbol): Improve error message.
	(-parse-insn-format): Ditto.
@
text
@d551 1
a551 1
   (gen-copyright "Decode header for @@prefix@@."
d581 1
a581 1
   (gen-copyright "Simulator instruction decoder for @@prefix@@."
@


1.6
log
@2001-04-02  Ben Elliston  <bje@@redhat.com>

	* sim-decode.scm (@@prefix@@_init_idesc_table): Compute tabsize
	using the size of the table and its elements.
	(-gen-decode-insn-globals): Define the idesc table's size to be
	the last instruction enum plus one, not @@PREFIX@@_INSN_MAX.
	* sim-model.scm (-gen-mach-defns): Define CPU_MAX_INSNS as the
	last instruction enum plus one, not @@CPU@@_INSN_MAX.
@
text
@d35 1
a35 3
static IDESC " IDESC-TABLE-VAR "[@@PREFIX@@_INSN_"
   (string-upcase (gen-c-symbol (caar (list-take -1
       (gen-obj-list-enums (non-multi-insns (current-insn-list))))))) " + 1];
d148 1
a148 1
  int tabsize = sizeof (" IDESC-TABLE-VAR ") / sizeof (IDESC);
@


1.5
log
@2001-03-05  Dave Brolley  <brolley@@redhat.com>

        * sim-decode.scm (-gen-extract-case): Generate declaration of "insn"
        if the number of ifields is greater than zero.
@
text
@d35 3
a37 1
static IDESC " IDESC-TABLE-VAR "[@@PREFIX@@_INSN_MAX];
d150 1
a150 1
  int tabsize = @@PREFIX@@_INSN_MAX;
@


1.4
log
@2001-01-06  Ben Elliston  <bje@@redhat.com>

	* utils-gen.scm (gen-sfmt-enum-decl): Use @@prefix@@ and @@PREFIX@@
	instead of @@cpu@@ and @@CPU@@ to generically prefix symbol names.
	* sim-cpu.scm (-gen-sem-fn-table-entry): Likewise.
	(-gen-semantic-fn-table): Likewise.
	(-gen-scache-semantic-fn): Likewise.
	(-gen-no-scache-semantic-fn): Likewise.
	(cgen-read.c): Likewise.
	(cgen-sem-switch.c): Likewise.
	* desc-cpu.scm (cgen-desc.c): Use @@arch@@, not @@prefix@@, since this
	is a filename prefix.
	* sim-decode.scm (IDESC-TABLE-VAR): Use @@prefix@@, et al.
	(-gen-decode-insn-globals): Likewise.
	(-gen-idesc-decls): Likewise.
	(cgen-decode.h): Likewise.
	(cgen-decode.c): Likewise.
	* sim.scm (gen-cpu-insn-enum-decl): Likewise.
	(gen-cpu-insn-enum): Likewise.
	(sim-finish!): Likewise.
@
text
@d436 1
a436 1
   (if (< (length (sfmt-iflds sfmt)) 0)
@


1.3
log
@2000-12-07  Ben Elliston  <bje@@redhat.com>

	* sim-decode.scm (-gen-extract-case): Do not emit a definition for
	"insn" when there are zero ifields to extract.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
d8 1
a8 1
(define IDESC-TABLE-VAR "@@cpu@@_insn_data")
d35 1
a35 1
static IDESC " IDESC-TABLE-VAR "[@@CPU@@_INSN_MAX];
d40 1
a40 1
static const struct insn_sem @@cpu@@_insn_sem[] =
d53 2
a54 2
	 "@@CPU@@_INSN_" (string-upcase name) ", "
	 "@@CPU@@_" (-gen-fmt-enum (insn-sfmt insn))
d58 1
a58 1
		  (string-append ", @@CPU@@_INSN_PAR_"
d62 2
a63 2
				     "@@CPU@@_INSN_READ_"
				     "@@CPU@@_INSN_WRITE_")
d73 2
a74 2
static const struct insn_sem @@cpu@@_insn_sem_invalid = {
  VIRTUAL_INSN_X_INVALID, @@CPU@@_INSN_X_INVALID, @@CPU@@_SFMT_EMPTY"
d94 1
a94 1
extern const IDESC *@@cpu@@_decode (SIM_CPU *, IADDR,
d101 3
a103 3
extern void @@cpu@@_init_idesc_table (SIM_CPU *);
extern void @@cpu@@_sem_init_idesc_table (SIM_CPU *);
extern void @@cpu@@_semf_init_idesc_table (SIM_CPU *);
d108 1
a108 1
; @@cpu@@_init_idesc_table is defined here as it depends on with-parallel?
d144 1
a144 1
@@cpu@@_init_idesc_table (SIM_CPU *cpu)
d148 1
a148 1
  int tabsize = @@CPU@@_INSN_MAX;
d154 1
a154 1
  t = & @@cpu@@_insn_sem_invalid;
d159 1
a159 1
  for (t = @@cpu@@_insn_sem, tend = t + sizeof (@@cpu@@_insn_sem) / sizeof (*t);
d476 1
a476 1
  ; The caller of @@cpu@@_decode must fetch and pass exactly this number of bits
d503 1
a503 1
@@cpu@@_decode (SIM_CPU *current_cpu, IADDR pc,
d512 1
a512 1
  @@CPU@@_INSN_TYPE itype;
d551 1
a551 1
   (gen-copyright "Decode header for @@cpu@@."
d554 2
a555 2
#ifndef @@CPU@@_DECODE_H
#define @@CPU@@_DECODE_H
d563 1
a563 1
   "#endif /* @@CPU@@_DECODE_H */\n"
d581 1
a581 1
   (gen-copyright "Simulator instruction decoder for @@cpu@@."
@


1.2
log
@* parameter to enable sim decode/extract separation

2000-11-10  Frank Ch. Eigler  <fche@@redhat.com>

	* utils-sim.scm (-gen-decode-insn-entry): Add fn? parameter to signal
	request to emit calls to insn extractors as functions rather than
	branches to inline blocks.
	(-gen-decode-expr-set-itype, -gen-decode-expr-entry): Ditto.
	(-gen-decode-table-entry, -gen-decoder-switch, gen-decoder): Ditto.

	* sim-decode.c (-gen-decode-fn): Tell (gen-decode) to emit branches
	to extractor clauses.
@
text
@d436 7
a442 4
   "    CGEN_INSN_INT insn = "
   (if (adata-integral-insn? CURRENT-ARCH)
       "entire_insn;\n"
       "base_insn;\n")
@


1.1
log
@Initial revision
@
text
@d492 2
a493 1
				    (current-insn-lookup 'x-invalid))))
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
