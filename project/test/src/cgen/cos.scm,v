head	1.13;
access;
symbols
	sid-snapshot-20180601:1.13
	cgen-snapshot-20180601:1.13
	sid-snapshot-20180501:1.13
	cgen-snapshot-20180501:1.13
	sid-snapshot-20180401:1.13
	cgen-snapshot-20180401:1.13
	sid-snapshot-20180301:1.13
	cgen-snapshot-20180301:1.13
	sid-snapshot-20180201:1.13
	cgen-snapshot-20180201:1.13
	sid-snapshot-20180101:1.13
	cgen-snapshot-20180101:1.13
	sid-snapshot-20171201:1.13
	cgen-snapshot-20171201:1.13
	sid-snapshot-20171101:1.13
	cgen-snapshot-20171101:1.13
	sid-snapshot-20171001:1.13
	cgen-snapshot-20171001:1.13
	sid-snapshot-20170901:1.13
	cgen-snapshot-20170901:1.13
	sid-snapshot-20170801:1.13
	cgen-snapshot-20170801:1.13
	sid-snapshot-20170701:1.13
	cgen-snapshot-20170701:1.13
	sid-snapshot-20170601:1.13
	cgen-snapshot-20170601:1.13
	sid-snapshot-20170501:1.13
	cgen-snapshot-20170501:1.13
	sid-snapshot-20170401:1.13
	cgen-snapshot-20170401:1.13
	sid-snapshot-20170301:1.13
	cgen-snapshot-20170301:1.13
	sid-snapshot-20170201:1.13
	cgen-snapshot-20170201:1.13
	sid-snapshot-20170101:1.13
	cgen-snapshot-20170101:1.13
	sid-snapshot-20161201:1.13
	cgen-snapshot-20161201:1.13
	sid-snapshot-20161101:1.13
	cgen-snapshot-20161101:1.13
	sid-snapshot-20160901:1.13
	cgen-snapshot-20160901:1.13
	sid-snapshot-20160801:1.13
	cgen-snapshot-20160801:1.13
	sid-snapshot-20160701:1.13
	cgen-snapshot-20160701:1.13
	sid-snapshot-20160601:1.13
	cgen-snapshot-20160601:1.13
	sid-snapshot-20160501:1.13
	cgen-snapshot-20160501:1.13
	sid-snapshot-20160401:1.13
	cgen-snapshot-20160401:1.13
	sid-snapshot-20160301:1.13
	cgen-snapshot-20160301:1.13
	sid-snapshot-20160201:1.13
	cgen-snapshot-20160201:1.13
	sid-snapshot-20160101:1.13
	cgen-snapshot-20160101:1.13
	sid-snapshot-20151201:1.13
	cgen-snapshot-20151201:1.13
	sid-snapshot-20151101:1.13
	cgen-snapshot-20151101:1.13
	sid-snapshot-20151001:1.13
	cgen-snapshot-20151001:1.13
	sid-snapshot-20150901:1.13
	cgen-snapshot-20150901:1.13
	sid-snapshot-20150801:1.13
	cgen-snapshot-20150801:1.13
	sid-snapshot-20150701:1.13
	cgen-snapshot-20150701:1.13
	sid-snapshot-20150601:1.13
	cgen-snapshot-20150601:1.13
	sid-snapshot-20150501:1.13
	cgen-snapshot-20150501:1.13
	sid-snapshot-20150401:1.13
	cgen-snapshot-20150401:1.13
	sid-snapshot-20150301:1.13
	cgen-snapshot-20150301:1.13
	sid-snapshot-20150201:1.13
	cgen-snapshot-20150201:1.13
	sid-snapshot-20150101:1.13
	cgen-snapshot-20150101:1.13
	sid-snapshot-20141201:1.13
	cgen-snapshot-20141201:1.13
	sid-snapshot-20141101:1.13
	cgen-snapshot-20141101:1.13
	sid-snapshot-20141001:1.13
	cgen-snapshot-20141001:1.13
	sid-snapshot-20140901:1.13
	cgen-snapshot-20140901:1.13
	sid-snapshot-20140801:1.13
	cgen-snapshot-20140801:1.13
	sid-snapshot-20140701:1.13
	cgen-snapshot-20140701:1.13
	sid-snapshot-20140601:1.13
	cgen-snapshot-20140601:1.13
	sid-snapshot-20140501:1.13
	cgen-snapshot-20140501:1.13
	sid-snapshot-20140401:1.13
	cgen-snapshot-20140401:1.13
	sid-snapshot-20140301:1.13
	cgen-snapshot-20140301:1.13
	sid-snapshot-20140201:1.13
	cgen-snapshot-20140201:1.13
	sid-snapshot-20140101:1.13
	cgen-snapshot-20140101:1.13
	sid-snapshot-20131201:1.13
	cgen-snapshot-20131201:1.13
	sid-snapshot-20131101:1.13
	cgen-snapshot-20131101:1.13
	sid-snapshot-20131001:1.13
	cgen-snapshot-20131001:1.13
	sid-snapshot-20130901:1.13
	cgen-snapshot-20130901:1.13
	sid-snapshot-20130801:1.13
	cgen-snapshot-20130801:1.13
	sid-snapshot-20130701:1.13
	cgen-snapshot-20130701:1.13
	sid-snapshot-20130601:1.13
	cgen-snapshot-20130601:1.13
	sid-snapshot-20130501:1.13
	cgen-snapshot-20130501:1.13
	sid-snapshot-20130401:1.13
	cgen-snapshot-20130401:1.13
	sid-snapshot-20130301:1.13
	cgen-snapshot-20130301:1.13
	sid-snapshot-20130201:1.13
	cgen-snapshot-20130201:1.13
	sid-snapshot-20130101:1.13
	cgen-snapshot-20130101:1.13
	sid-snapshot-20121201:1.13
	cgen-snapshot-20121201:1.13
	sid-snapshot-20121101:1.13
	cgen-snapshot-20121101:1.13
	sid-snapshot-20121001:1.13
	cgen-snapshot-20121001:1.13
	sid-snapshot-20120901:1.13
	cgen-snapshot-20120901:1.13
	sid-snapshot-20120801:1.13
	cgen-snapshot-20120801:1.13
	sid-snapshot-20120701:1.13
	cgen-snapshot-20120701:1.13
	sid-snapshot-20120601:1.13
	cgen-snapshot-20120601:1.13
	sid-snapshot-20120501:1.13
	cgen-snapshot-20120501:1.13
	sid-snapshot-20120401:1.13
	cgen-snapshot-20120401:1.13
	sid-snapshot-20120301:1.13
	cgen-snapshot-20120301:1.13
	sid-snapshot-20120201:1.13
	cgen-snapshot-20120201:1.13
	sid-snapshot-20120101:1.13
	cgen-snapshot-20120101:1.13
	sid-snapshot-20111201:1.13
	cgen-snapshot-20111201:1.13
	sid-snapshot-20111101:1.13
	cgen-snapshot-20111101:1.13
	sid-snapshot-20111001:1.13
	cgen-snapshot-20111001:1.13
	sid-snapshot-20110901:1.13
	cgen-snapshot-20110901:1.13
	sid-snapshot-20110801:1.13
	cgen-snapshot-20110801:1.13
	sid-snapshot-20110701:1.13
	cgen-snapshot-20110701:1.13
	sid-snapshot-20110601:1.13
	cgen-snapshot-20110601:1.13
	sid-snapshot-20110501:1.13
	cgen-snapshot-20110501:1.13
	sid-snapshot-20110401:1.13
	cgen-snapshot-20110401:1.13
	sid-snapshot-20110301:1.13
	cgen-snapshot-20110301:1.13
	sid-snapshot-20110201:1.13
	cgen-snapshot-20110201:1.13
	sid-snapshot-20110101:1.13
	cgen-snapshot-20110101:1.13
	sid-snapshot-20101201:1.13
	cgen-snapshot-20101201:1.13
	sid-snapshot-20101101:1.13
	cgen-snapshot-20101101:1.13
	sid-snapshot-20101001:1.13
	cgen-snapshot-20101001:1.13
	sid-snapshot-20100901:1.13
	cgen-snapshot-20100901:1.13
	sid-snapshot-20100801:1.13
	cgen-snapshot-20100801:1.13
	sid-snapshot-20100701:1.13
	cgen-snapshot-20100701:1.13
	sid-snapshot-20100601:1.13
	cgen-snapshot-20100601:1.13
	sid-snapshot-20100501:1.13
	cgen-snapshot-20100501:1.13
	sid-snapshot-20100401:1.13
	cgen-snapshot-20100401:1.13
	sid-snapshot-20100301:1.13
	cgen-snapshot-20100301:1.13
	sid-snapshot-20100201:1.13
	cgen-snapshot-20100201:1.13
	sid-snapshot-20100101:1.11
	cgen-snapshot-20100101:1.11
	sid-snapshot-20091201:1.11
	cgen-snapshot-20091201:1.11
	sid-snapshot-20091101:1.11
	cgen-snapshot-20091101:1.11
	sid-snapshot-20091001:1.10
	cgen-snapshot-20091001:1.10
	arc-sim-20090309:1.3
	sid-snapshot-20090901:1.5
	cgen-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	cgen-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	cgen-snapshot-20090701:1.5
	dje-cgen-play1-branch:1.5.0.2
	dje-cgen-play1-branchpoint:1.5
	cgen-1_1-branch:1.4.0.2
	cgen-1_1-branchpoint:1.4
	sid-snapshot-20090601:1.3
	cgen-snapshot-20090601:1.3
	sid-snapshot-20090501:1.3
	cgen-snapshot-20090501:1.3
	sid-snapshot-20090401:1.3
	cgen-snapshot-20090401:1.3
	arc-insight_6_8-branch:1.3.0.4
	arc-insight_6_8-branchpoint:1.3
	sid-snapshot-20090301:1.3
	cgen-snapshot-20090301:1.3
	sid-snapshot-20090201:1.3
	cgen-snapshot-20090201:1.3
	sid-snapshot-20090101:1.3
	cgen-snapshot-20090101:1.3
	sid-snapshot-20081201:1.3
	cgen-snapshot-20081201:1.3
	sid-snapshot-20081101:1.3
	cgen-snapshot-20081101:1.3
	sid-snapshot-20081001:1.3
	cgen-snapshot-20081001:1.3
	sid-snapshot-20080901:1.3
	cgen-snapshot-20080901:1.3
	sid-snapshot-20080801:1.3
	cgen-snapshot-20080801:1.3
	sid-snapshot-20080701:1.3
	cgen-snapshot-20080701:1.3
	sid-snapshot-20080601:1.3
	cgen-snapshot-20080601:1.3
	sid-snapshot-20080501:1.3
	cgen-snapshot-20080501:1.3
	sid-snapshot-20080403:1.3
	sid-snapshot-20080401:1.3
	cgen-snapshot-20080401:1.3
	sid-snapshot-20080301:1.3
	cgen-snapshot-20080301:1.3
	sid-snapshot-20080201:1.3
	cgen-snapshot-20080201:1.3
	sid-snapshot-20080101:1.3
	cgen-snapshot-20080101:1.3
	sid-snapshot-20071201:1.3
	cgen-snapshot-20071201:1.3
	sid-snapshot-20071101:1.3
	cgen-snapshot-20071101:1.3
	sid-snapshot-20071001:1.3
	cgen-snapshot-20071001:1.3
	msnyder-fork-checkpoint-branch:1.3.0.2
	msnyder-fork-checkpoint-branchpoint:1.3
	sid-20020905-branchpoint:1.1.1.1
	sid-20020905-branch:1.1.1.1.0.6
	cagney_regbuf-20020515-branch:1.1.1.1.0.4
	cagney_regbuf-20020515-branchpoint:1.1.1.1
	cygnus_cvs_20020108_pre:1.1.1.1
	cgen-1-1-branch:1.1.1.1.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.13
date	2010.01.25.00.40.28;	author devans;	state Exp;
branches;
next	1.12;

1.12
date	2010.01.24.21.43.59;	author devans;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.28.16.37.33;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2009.09.28.02.40.49;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.27.18.34.36;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2009.09.27.18.31.33;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2009.09.08.06.43.32;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	2009.09.07.22.17.33;	author devans;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.14.17.09.56;	author devans;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2005.02.07.18.36.44;	author jimb;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.16.05.35.47;	author devans;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.4.2.1
date	2009.06.24.14.57.45;	author devans;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.13
log
@	* utils-cgen.scm (<location>): Define using new define-class.
	(<ident>, <source-ident>, <context>): Ditto.

	* cos.scm (/object-string): New function.
	(/object-error): Use it.
	(/object-count-true): New function
	(object-copy-top): Delete.  All callers changed to call object-copy.
	(/parse-member-list, /build-getter-defs, /build-setter-defs): New fns.
	(define-class, define-interface, define-method): New macros.
	(define-getters, define-setters, vmake): Moved here ...
	* utils-cgen.scm: ... from here.
@
text
@;; Cgen's Object System.
;; Copyright (C) 2000, 2009, 2010 Red Hat, Inc.
;; This file is part of CGEN.
;; See file COPYING.CGEN for details.
;;
;; Scheme implementations don't agree on a lot of things beyond the basics.
;; This is a simple object system for cgen's needs.
;; I thought at the start that when Guile had an official object system
;; we'd switch over, but the higher order bit now is to be usable on
;; multiple Scheme implementations: Guile isn't fast enough.
;;
;; NOTE: The original COS supported multiple inheritance.  This does not.
;;
;; Classes look like:
;;
;; #(class-tag
;;   class-name
;;   class-uid ;; unique id of class, index into /class-table
;;   parent-name
;;   elm-alist ;; not including parent classes
;;   method-alist ;; not including parent classes
;;   full-elm-initial-list ;; including parent classes
;;   method-cache ;; ??? not currently used
;;   class-descriptor)
;;
;; PARENT-NAME is the name of the parent class, if any.
;; If a subclasses b which subclasses c, then parent-name for a is b,
;; the parent-name for b is c, and the parent-name for c is #f.
;;
;; ELM-ALIST is an alist of (symbol vector-offset-with-class . initial-value)
;; for this class only.
;; Values can be looked up by name, via elm-make-[gs]etter routines.
;; Various Lisp (or Lisp-like) OOP systems (e.g. CLOS, Dylan) call these
;; "slots".  Maybe for consistency "slot" would be a better name.  Some might
;; confuse that with intentions at directions though.
;;
;; METHOD-ALIST is an alist of (symbol . procedure) for this class only.
;;
;; FULL-ELM-INITIAL-LIST is the elements of the flattened inheritance tree.
;; Initially it is #f meaning it hasn't been computed yet.
;; It is computed when the class is first instantiated.  During development,
;; it can be reset to #f after some module has been reloaded (as long as no
;; elements have been deleted/added/moved/etc., existing objects are ok).
;;
;; METHOD-CACHE is an alist of the methods of the flattened inheritance
;; tree.  Each element is (symbol . (parent-list-entry . method)).
;; Initially it is #f meaning it hasn't been computed yet.
;; It is computed when the class is first instantiated.  During development,
;; it can be reset to #f after some module has been reloaded (requires all
;; object instantiation to happen later of course).
;; FIXME: We don't yet implement the method cache.
;;
;; CLASS-DESCRIPTOR is the processed form of parent-name-list.
;; There is an entry for the class and one for each parent (recursively):
;; (class offset child-backpointer [parent-descriptor]).
;; offset is the offset in the element vector of the class's elements.
;; child-backpointer is #f in the top level object.
;; ??? child->subclass, parent->superclass?
;; Initially the class-descriptor is #f meaning it hasn't been computed yet.
;; It is computed when the class is first instantiated.  During development,
;; it can be reset to #f after some module has been reloaded (requires all
;; object instantiation to happen later of course).
;;
;; An object is a vector: #(object-tag class-name class-uid elm1 elm2 ...)
;; Vectors are nice in that they're self-evaluating.
;; Both class name and uid are stored here for a better developer experience.
;; It might be better to store the class-descriptor instead, but it's big and
;; vastly reduces the S/N ratio when displaying objects.
;;
;; -----------------------------------------------------------------------------
;;
;; User visible procs/macros:
;;
;; (define-class name prefix parents members)
;;
;; This is a macro that defines several things:
;; - the class object with the specified class members
;; - a predicate to identify instances of this class, named "class?"
;; - getters and setters for each member
;; NAME is the name of the class.
;; Convention requires class names to be decorated as <class-name>.
;; ??? This might change to require the actual class object, but not yet.
;; PREFIX is prepended to member getters/setters.
;; PARENTS is a list of parent class names.
;; It must contain at most one element, multiple inheritance isn't supported.
;; Each element of MEMBERS is either member-name (for uninitialized
;;  elements) or (member-name . initial-value).
;; MEMBER-NAME may begin with modifiers / and !:
;; / - member is private: getter/setter begins with /
;; ! - member is writable: readonly members do not get a setter
;; / and ! may not appear elsewhere in MEMBER-NAME.
;; / and ! may appear in either order.
;;
;; (class-make name parents members unused) -> class
;;
;; Create a class.  The result is then passed back by procedures requiring
;; a class argument.
;; NAME is the name of the class.
;; Convention requires class names to be decorated as <class-name>.
;; PARENTS is a list of parent class names.
;; It must contain at most one element, multiple inheritance isn't supported.
;; ??? This might change to require the actual class object, but not yet.
;; MEMBERS is a list of members, each list member is either a name (for
;; uninitialized elements) or (name . initial-value).
;; UNUSED must be the empty list, it will eventually be deleted.
;;
;; (class-list) -> list of all defined classes
;;
;; (class-name class) -> name of CLASS
;;
;; (class-lookup class-name) -> class
;;
;; (class-instance? class object) -> #t if OBJECT is an instance of CLASS
;;
;; (object-class object) -> class of OBJECT
;;
;; (object-class-name object) -> class name of OBJECT
;;
;; (send object method-name . args) -> result of invoking METHOD-NAME
;;
;; (send-next object class-name method-name . args) -> result of invoking next METHOD-NAME
;;
;; (new class) -> instantiate CLASS
;;
;; The object is initialized with values specified when CLASS
;; (and its parent classes) was defined.
;;
;; (vmake class . args) -> instantiate class and initialize it with 'vmake!
;;
;; This is shorthand for (send (new class) 'vmake! args).
;; ARGS is a list of option names and arguments (a la CLOS).
;; ??? Not implemented yet.
;;
;; (method-vmake! object . args) -> modify OBJECT from ARGS
;;
;; This is the standard 'vmake! method, available for use by user-written
;; 'vmake! methods.
;; ??? Not implemented yet.
;;
;; (make class . args) -> instantiate CLASS and initialize it with 'make!
;;
;; This is shorthand for (send (new class) 'make! arg1 ...).
;; This is a positional form of `new'.
;;
;; (method-make-make! class elm1-name elm2-name ...) -> unspecified
;;
;; Create a 'make! method that sets the specified elements.
;;
;; (object-copy object) -> copy of OBJECT
;;
;; Return a copy of OBJECT.
;; NOTE: This does a shallow copy.
;;
;; (object-assign! dstsrc) -> unspecified
;;
;; Assign the contents of SRC to DST.
;; Both must be objects of the same class.
;;
;; (class? foo) -> return #t if FOO is a class
;;
;; (object? foo) -> return #t if FOO is an object
;;
;; (method-make! class name lambda) -> unspecified
;;
;; Add method NAME to CLASS.
;;
;; (method-make-forward! class elm-name methods) -> unspecified
;;
;; Add METHODS to CLASS that pass the "message" onto the object in element
;; ELM-NAME.
;;
;; (elm-get object elm-name) -> value of element ELM-NAME in OBJ
;;
;; Can only be used in methods.
;;
;; (elm-set! object elm-name new-value) -> unspecified
;;
;; Set element ELM-NAME in OBJECT to NEW-VALUE.
;; Can only be used in methods.
;;
;; (elm-make-getter class elm-name) -> lambda
;;
;; Return efficient lambda to get the value of ELM-NAME in CLASS.
;;
;; (elm-make-setter class elm-name) -> lambda
;;
;; Return efficient lambda to set the value of ELM-NAME in CLASS.
;;
;; Conventions used in this file:
;; - procs/vars internal to this file are prefixed with "/"
;; - except for a few exceptions, public procs/macros begin with one of
;;   define-, class-, object-, elm-, method-.
;;   The exceptions are make, vmake, new, send, send-next.
;;
;; NOTES:
;; - "send" as a public interface is deprecated

(define /class-tag "class")
(define /object-tag "object")

;; Alist of all classes.
;; Each element is (class-name class?-object).
;; Note that classes are consed unto the front.

(define /class-list '())

;; Table of all classes, indexed by class-uid.
;; Note that classes are appended to the end.

(define /class-table '#())

;; Internal variables to mark their respective properties.
(define /object-unspecified #:unspecified)
(define /object-unbound #:unbound)

;; True if error messages are verbose and debugging messages are printed.

(define /object-verbose? #f)

;; Cover fn to set verbosity.

(define (object-set-verbose! verbose?)
  (set! /object-verbose? verbose?)
)

;; Signal error if not class/object.

(define (/class-check maybe-class proc-name . extra-text)
  (if (not (class? maybe-class))
      (apply /object-error
	     (append! (list proc-name maybe-class "not a class")
		      extra-text)))
  /object-unspecified
)

(define (/object-check-name maybe-name proc-name . extra-text)
  (if (not (symbol? maybe-name))
      (apply /object-error
	     (append! (list proc-name maybe-name) extra-text)))
  /object-unspecified
)

(define (/object-check maybe-object proc-name . extra-text)
  (if (not (object? maybe-object))
      (apply /object-error
	     (append! (list proc-name maybe-object "not an object")
		      extra-text)))
  /object-unspecified
)

;; Main routine to flag a cos error.
;; X is any arbitrary Scheme data.

(define (/object-error proc-name x . text)
  (error (string-append proc-name ": "
			(apply string-append (map /object->string text))
			(if (object? x)
			    (string-append
			     " (class: " (/object->string (/object-class-name x))
			     (if (method-present? x 'get-name)
				 (string-append ", name: "
						(/object->string (send x 'get-name)))
				 "")
			     ")")
			    "")
			"")
	 x)
)

;; Utility to count the number of non-#f elements in FLAGS.

(define (/object-count-true flags)
  (let loop ((result 0) (flags flags))
    (if (null? flags)
	result
	(loop (+ result (if (car flags) 1 0))
	      (cdr flags))))
)

;; If S is a symbol, convert it to a string.
;; Otherwise S must be a string, returned unchanged.

(define (/object->string s)
  (cond ((symbol? s) (symbol->string s))
	((string? s) s)
	(else (error "not a symbol or string" s)))
)

;; Low level class operations.

;; Return boolean indicating if X is a class.

(define (class? class)
  (and (vector? class) (eq? /class-tag (vector-ref class 0)))
)

;; Accessors.

(define (/class-name class) (vector-ref class 1))
(define (/class-uid class) (vector-ref class 2))
(define (/class-parent-name class) (vector-ref class 3))
(define (/class-elements class) (vector-ref class 4))
(define (/class-methods class) (vector-ref class 5))
(define (/class-all-initial-values class) (vector-ref class 6))
(define (/class-method-cache class) (vector-ref class 7))
(define (/class-class-desc class) (vector-ref class 8))

(define (/class-set-uid! class uid)
  (vector-set! class 2 uid)
)

(define (/class-set-methods! class method-alist)
  (vector-set! class 5 method-alist)
)

(define (/class-set-all-initial-values! class init-list)
  (vector-set! class 6 init-list)
)

(define (/class-set-method-cache! class all-meth-list)
  (vector-set! class 7 all-meth-list)
)

(define (/class-set-class-desc! class parent-list)
  (vector-set! class 8 parent-list)
)

;; Make a class.
;; The new definition overrides any existing definition.

(define (/class-make! name parent-name elements)
  (let ((class (vector /class-tag name
		       #f ;; uid filled in later
		       parent-name elements
		       '() ;; methods, none yet
		       #f #f #f))
	(list-entry (assq name /class-list)))
    (if list-entry
	(let ((uid (/class-uid (cdr list-entry))))
	  (/class-set-uid! class uid)
	  (set-cdr! list-entry class))
	(let ((uid (vector-length /class-table)))
	  (/class-set-uid! class uid)
	  (set! /class-table (list->vector
			      (append (vector->list /class-table)
				      (list class))))
	  (set! /class-list (acons name class /class-list))))
    class)
)

;; Lookup a class given its name.
;; The result is the class or #f if not found.

(define (class-lookup name) (assq-ref /class-list name))

;; Lookup a class given its uid.

(define (/class-lookup-uid uid) (vector-ref /class-table uid))

;; Return a list of all direct parent classes of CLASS.
;; The list can have at most one element.
;; this is for callers that prefer a list result.

(define (/class-parent-classes class)
  (if (/class-parent-name class)
      (let ((parent (class-lookup (/class-parent-name class))))
	(if parent
	    (list parent)
	    ;; The proc name we pass here is made up as we don't
	    ;; want it to be the name of an internal proc.
	    (/object-error "class" parent "not a class")))
      '())
)

;; Cover proc of /class-name for the outside world to use.
;; The result is the name of the class or #f if CLASS is not a class.
;; We could issue an error here, but to be consistent with object-class-name
;; we don't.

(define (class-name class)
  (if (class? class)
      (/class-name class)
      #f)
)

;; Class descriptor utilities.
;; A class-descriptor is:
;; (class offset child-backpointer [parent-descriptor])

(define (/class-desc? maybe-class-desc)
  (and (pair? maybe-class-desc)
       (class? (car maybe-class-desc)))
)
(define /class-desc-class car)
(define /class-desc-offset cadr)
(define /class-desc-child caddr)
(define /class-desc-parents cdddr) ;; nil or list of one element

;; Compute the class descriptor of CLASS.
;; OFFSET is the beginning offset in the element vector.
;; We can assume the parents of CLASS have already been initialized.
;;
;; A class-descriptor is:
;; (class offset child (parent-entry))
;; CLASS is the class? data structure of the class.
;; OFFSET is the offset into the object vector of the baseclass's elements.
;; CHILD is the backlink to the direct child class or #f if no subclass.
;; PARENT-ENTRY is the class descriptor of the parent class.

(define (/class-compute-class-desc class offset child)

  ;; OFFSET must be global to the calculation because it is continually
  ;; incremented as we recurse down through the hierarchy (actually, as we
  ;; traverse back up).  At any point in time it is the offset from the start
  ;; of the element vector of the next class's elements.
  ;; Object elements are laid out using a depth first traversal of the
  ;; inheritance tree.

  (define (compute1 class child)

    ;; Build the result first, then build our parents so that our parents have
    ;; the right value for the CHILD-BACKPOINTER field.
    ;; FIXME: Can't assume append! works that way.
    ;; Use a bogus value (999) for offset for the moment.
    ;; The correct value is set later.

    (let ((result (list class 999 child)))

      ;; Recurse on the parent.

      (if (/class-parent-name class)
	  (let ((parent (class-lookup (/class-parent-name class))))
	    (if (not parent)
		;; The proc name we pass here is made up as we don't
		;; want it to be the name of an internal proc.
		(/object-error "class" (car parents) "not a class"))

	    (let ((parent-desc (compute1 parent result)))

	      ;; We use `append!' here as the location of `result' is now fixed
	      ;; so that our parent's child-backpointer remains stable.
	      (append! result (list parent-desc)))))

      (list-set! result 1 offset)
      (set! offset (+ offset (length (/class-elements class))))
      result))

  (compute1 class child)
)

;; Return the top level class-descriptor of CLASS-DESC.

(define (/class-desc-top class-desc)
  (if (/class-desc-child class-desc)
      (/class-desc-top (/class-desc-child class-desc))
      class-desc)
)

;; Pretty print a class descriptor.

(define (class-desc-dump class-desc)
  (let* ((cep (current-error-port))
	 (top-desc (/class-desc-top class-desc))
	 (spaces (lambda (n port)
		   (display (make-string n #\space) port)))
	 (writeln (lambda (indent port . args)
		    (spaces indent port)
		    (for-each (lambda (arg) (display arg port))
			      args)
		    (newline port)))
	 )
    (letrec ((dump (lambda (cd indent)
		     (writeln indent cep "Class: "
			      (/class-name (/class-desc-class cd)))
		     (writeln indent cep "  offset: "
			      (/class-desc-offset cd))
		     (writeln indent cep "  child:       "
			      (if (/class-desc-child cd)
				  (/class-name (/class-desc-class
						(/class-desc-child cd)))
				  "-top-"))
		     (for-each (lambda (parent-cd) (dump parent-cd (+ indent 4)))
			       (/class-desc-parents cd))
		     )))
      (display "Top level class: " cep)
      (display (/class-name (/class-desc-class top-desc)) cep)
      (newline cep)
      (dump class-desc 0)
      ))
)

;; Low level object utilities.

;; Make an object.
;; All elements get initial (or unbound) values.

(define (/object-make! class)
  (/class-check-init! class)
  (apply vector (append! (list /object-tag
			       (/class-name class)
			       (/class-uid class))
			 (/class-all-initial-values class)))
)

;; Make an object using VALUES.
;; VALUES must specify all elements in the class (and parent classes).

(define (/object-make-with-values! class values)
  (/class-check-init! class)
  (apply vector (append! (list /object-tag
			       (/class-name class)
			       (/class-uid class))
			 values))
)

;; Copy an object.
;; WARNING: A shallow copy is currently done on the elements!

(define (/object-copy obj)
  (/object-vector-copy obj)
)

;; Accessors.

(define (/object-class-name obj) (vector-ref obj 1))
(define (/object-class-uid obj) (vector-ref obj 2))

(define (/object-class-desc obj)
  (/class-class-desc (/object-class obj))
)

(define (/object-class obj)
  (/class-lookup-uid (/object-class-uid obj))
)

(define (/object-elm-get obj elm-offset)
  (vector-ref obj elm-offset)
)

(define (/object-elm-set! obj elm-offset new-val)
  (vector-set! obj elm-offset new-val)
  /object-unspecified
)

;; Return boolean indicating if X is an object.

(define (object? obj)
  (and (vector? obj)
       (>= (vector-length obj) 3)
       (eq? /object-tag (vector-ref obj 0)))
)

;; Return the class of an object.

(define (object-class obj)
  (/object-check obj "object-class")
  (/object-class obj)
)

;; Cover proc of /object-class-name for the outside world to use.
;; The result is the name of the class or #f if OBJ is not an object.

(define (object-class-name obj)
  (if (object? obj)
      (/object-class-name obj)
      #f)
)

;; Class operations.

;; Return the list of initial values for CLASS.
;; The result does not include parent classes.

(define (/class-my-initial-values class)
  (map cadr (/class-elements class))
)

;; Initialize class if not already done.
;; FIXME: Need circularity check.  Later.

(define (/class-check-init! class)
  ;; This should be fast the second time through, so don't do any
  ;; computation until we know it's necessary.

  (if (/class-all-initial-values class)

      #t ;; nothing to do

      (begin

	;; First pass ensures all parents are initialized.
	(for-each /class-check-init!
		  (/class-parent-classes class))

	;; Next pass initializes the initial value list.
	(letrec ((get-inits
		  (lambda (class)
		    (let ((parents (/class-parent-classes class)))
		      (append (apply append (map get-inits parents))
			      (/class-my-initial-values class))))))

	  (let* ((parents (/class-parent-classes class))
		 (inits (append (apply append (map get-inits parents))
				(/class-my-initial-values class))))
	    (/class-set-all-initial-values! class inits)))

	;; Next pass initializes the class's class-descriptor.
	;; Object elements begin at offset 3 in the element vector.
	(/class-set-class-desc! class
				(/class-compute-class-desc class 3 #f))
	))

  /object-unspecified
)

;; Make a class.
;;
;; PARENTS is the name of parent class as a list, i.e. () or (<parent>).
;; It's a list just in case multiple-inheritance is added one day.
;; The parent need not exist yet, though it must exist when the class
;; is first instantiated.
;; ELMS is a either a list of either element names or name/value pairs.
;; Elements without initial values are marked as "unbound".
;; UNUSED must be the empty list, it will eventually be deleted.

(define (class-make name parents elms unused)
  (if (> (length parents) 1)
      (/object-error "class-make" parents "multiple-inheritance is not supported"))
  (if (not (null? unused))
      (/object-error "class-make" methods "unused parameter must be ()"))

  (let ((elm-list #f))

    ;; Mark elements without initial values as unbound, and
    ;; compute indices into the element vector (relative to the class's
    ;; offset).
    ;; Elements are recorded as (symbol initial-value . vector-index)
    (let loop ((elm-list-tmp '()) (index 0) (elms elms))
      (if (null? elms)
	  (set! elm-list (reverse! elm-list-tmp)) ;; done
	  (if (pair? (car elms))
	      (loop (acons (caar elms)
			   (cons (cdar elms) index)
			   elm-list-tmp)
		    (+ index 1)
		    (cdr elms))
	      (loop (acons (car elms)
			   (cons /object-unbound index)
			   elm-list-tmp)
		    (+ index 1)
		    (cdr elms)))))

    (let ((result (/class-make! name
				(if (null? parents) #f (car parents))
				elm-list)))

      ;; Create the standard `make!' method.
      ;; The caller can override afterwards if desired.
      ;; Note that if there are any parent classes then we don't know the names
      ;; of all of the elements yet, that is only known after the class has been
      ;; initialized which only happens when the class is first instantiated.
      ;; This method won't be called until that happens though so we're safe.
      ;; This is written without knowledge of the names, it just initializes
      ;; all elements.
      (method-make! result 'make!
		    (lambda args
		      (let ((self (car args)))
			;; Ensure exactly all of the elements are provided.
			(if (not (= (length args)
				    (- (vector-length self) 2)))
			    (/object-error "make!" "" "wrong number of arguments to method `make!'"))
			(/object-make-with-values! (/object-class self)
						   (cdr args)))))

      result))
)

;; Create an object of a class CLASS.

(define (new class)
  (/class-check class "new")

  (if /object-verbose?
      (display (string-append "Instantiating class " (/class-name class) ".\n")
	       (current-error-port)))

  (/object-make! class)
)

;; Make a copy of OBJ.
;; WARNING: A shallow copy is done on the elements!

(define (object-copy obj)
  (/object-check obj "object-copy")
  (/object-copy obj)
)

;; Assign object SRC to object DST.
;; They must have the same class.

(define (object-assign! dst src)
  (/object-check dst "object-assign!")
  (/object-check src "object-assign!")
  (if (not (eq? (/object-class-name dst) (/object-class-name src)))
      (/object-error "object-assign" (list dst src) "not same class"))

  (let ((n (vector-length dst)))
    (let loop ((i 0))
      (if (< i n)
	  (begin
	    (vector-set! dst i (vector-ref src i))
	    (loop (+ i 1))))))
  /object-unspecified
)

;; Utility to define a standard `make!' method.
;; A standard make! method is one in which all it does is initialize
;; fields from args.

(define (method-make-make! class args)
  (let ((lambda-expr
	 (append (list 'lambda (cons 'self args))
		 (map (lambda (elm) (list 'elm-set! 'self
					  (list 'quote elm) elm))
		      args)
		 '(self))))
    (method-make! class 'make! (eval1 lambda-expr)))
)

;; The "standard" way to invoke `make!' is (send (new class) 'make! ...).
;; This puts all that in a cover function.

(define (make class . operands)
  (apply send (append (cons (new class) '()) '(make!) operands))
)

;; Return #t if class X is a subclass of BASE-NAME.

(define (/class-subclass? base-name x)
  (if (eq? base-name (/class-name x))
      #t
      (let ((parent-name (/class-parent-name x)))
	(if parent-name
	    (/class-subclass? base-name (class-lookup parent-name))
	    #f)))
)

;; Return #t if OBJECT is an instance of CLASS.
;; This does not signal an error if OBJECT is not an object as this is
;; intended to be used in class predicates.

(define (class-instance? class object)
  (/class-check class "class-instance?")
  (if (object? object)
      (/class-subclass? (/class-name class) (/object-class object))
      #f)
)

;; Subroutine of define-class.
;; Parse a define-class member list and return a list of five elements:
;; - list of all members
;; - list of public readable members
;; - list of public writable members
;; - list of private readable members
;; - list of private writable members
;; MEMBER-SPEC is a list of members, with private members prefixed with '/',
;; and writable members prefixed with '!'.  / and ! may appear in any order.
;; Each element is either member-name or (member-name . initial-value).

(define (/parse-member-list member-spec)
  (let loop ((member-spec member-spec)
	     (members nil)
	     (public-readable nil)
	     (public-writable nil)
	     (private-readable nil)
	     (private-writable nil))
    (if (null? member-spec)
	(list (reverse! members)
	      (reverse! public-readable)
	      (reverse! public-writable)
	      (reverse! private-readable)
	      (reverse! private-writable))
	(let* ((spec (car member-spec))
	       (sym (if (pair? spec) (car spec) spec))
	       (str (symbol->string sym)))
	  (let ((private? (string-index str #\/))
		(writable? (string-index str #\!)))
	    ;; ??? Assumes /,! are first characters.
	    (let* ((stripped-str (substring str (/object-count-true (list private? writable?))))
		   (stripped-sym (string->symbol stripped-str)))
	      (loop (cdr member-spec)
		    ;; Combine initial value if present.
		    (cons (if (pair? spec)
			      (cons stripped-sym (cdr spec))
			      stripped-sym)
			  members)
		    (if (not private?)
			(cons stripped-sym public-readable)
			public-readable)
		    (if (and (not private?) writable?)
			(cons stripped-sym public-writable)
			public-writable)
		    (if private?
			(cons stripped-sym private-readable)
			private-readable)
		    (if (and private? writable?)
			(cons stripped-sym private-writable)
			private-writable)))))))
)

;; Subroutine of define-class.
;; Return a list of definitions of member getters.

(define (/build-getter-defs class prefix members private?)
  (let ((str-prefix (symbol->string prefix)))
    (cons 'begin
	  (map (lambda (m)
		 (let* ((elm-name (if (pair? m) (car m) m))
			(name (string-append (if private? "/" "")
					     str-prefix
					     (symbol->string elm-name)))
			(getter-name (string->symbol name)))
		   `(define ,getter-name
		      (elm-make-getter ,class (quote ,elm-name)))))
	       members)))
)

;; Subroutine of define-class.
;; Return a list of definitions of member getters.

(define (/build-setter-defs class prefix members private?)
  (let ((str-prefix (symbol->string prefix)))
    (cons 'begin
	  (map (lambda (m)
		 (let* ((elm-name (if (pair? m) (car m) m))
			(name (string-append (if private? "/" "")
					     str-prefix
					     "set-"
					     (symbol->string elm-name)
					     "!"))
			(getter-name (string->symbol name)))
		   `(define ,getter-name
		      (elm-make-setter ,class (quote ,elm-name)))))
	       members)))
)

;; Main routine to define a class.
;;
;; This defines several things:
;; - the class object with the specified class members
;; - a predicate to identify instances of this class, named "class?"
;; - getters and setters for each member
;;
;; Private members are specified as /member.
;; Writable members are specified as !member.
;; / and ! may be combined in any order.
;;
;; By convention name is formatted as <class-name>.

(defmacro define-class (name prefix parents members)
  (let* ((parsed-members (/parse-member-list members))
	 (str-name (symbol->string name))
	 (str-name-len (string-length str-name))
	 (name-sans-decorations (substring str-name 1 (- str-name-len 1))))
    ;; Enforce the <class> naming convention.
    (if (or (not (eq? (string-ref str-name 0) #\<))
	    (not (eq? (string-ref str-name (- str-name-len 1)) #\>)))
	(/object-error "define-class" name " not formatted as <class>: "))
    `(begin
       (define ,name (class-make (quote ,name) (quote ,parents) (quote ,(car parsed-members)) nil))
       ,(/build-getter-defs name prefix (list-ref parsed-members 1) #f)
       ,(/build-setter-defs name prefix (list-ref parsed-members 2) #f)
       ,(/build-getter-defs name prefix (list-ref parsed-members 3) #t)
       ,(/build-setter-defs name prefix (list-ref parsed-members 4) #t)
       (define ,(string->symbol (string-append name-sans-decorations "?"))
	 (lambda (obj) (class-instance? ,name obj)))))
)

;; Element operations.

;; Lookup an element in a class-desc.
;; The result is elm-index or #f if not found.

(define (/class-lookup-element class-desc elm-name)
  (let* ((class (/class-desc-class class-desc))
	 (elm (assq elm-name (/class-elements class))))
    (if elm
	(+ (cddr elm) ;; elm is (name init-value . index)
	   (/class-desc-offset class-desc))
	(let ((parents (/class-desc-parents class-desc)))
	  (if (null? parents)
	      #f
	      (/class-lookup-element (car parents) elm-name)))))
)

;; Return a boolean indicating if ELM-NAME is bound in OBJ.

(define (elm-bound? obj elm-name)
  (/object-check obj "elm-bound?")
  (let ((index (/class-lookup-element (/object-class-desc obj) elm-name)))
    (if index
	(not (eq? (/object-elm-get obj index) /object-unbound))
	(/object-error "elm-bound?" obj "element not present: " elm-name)))
)

;; Subroutine of elm-get.

(define (/elm-make-method-getter self elm-name)
  (/object-check self "elm-get")
  (let ((index (/class-lookup-element (/object-class-desc self) elm-name)))
    (if index
	(procedure->memoizing-macro
	 (lambda (exp env)
	   `(lambda (obj)
	      (/object-elm-get obj ,index))))
	(/object-error "elm-get" self "element not present: " elm-name)))
)

;; Get an element from an object.
;; If OBJ is `self' then the caller is required to be a method and we emit
;; memoized code.  Otherwise we do things the slow way.
;; ??? There must be a better way.
;; What this does is turn
;; (elm-get self 'foo)
;; into
;; ((/elm-make-method-get self 'foo) self)
;; Note the extra set of parens.  /elm-make-method-get then does the lookup of
;; foo and returns a memoizing macro that returns the code to perform the
;; operation with O(1).  Cute, but I'm hoping there's an easier/better way.

(defmacro elm-get (self elm-name)
  (if (eq? self 'self)
      `(((/elm-make-method-getter ,self ,elm-name)) ,self)
      `(elm-xget ,self ,elm-name))
)

;; Subroutine of elm-set!.

(define (/elm-make-method-setter self elm-name)
  (/object-check self "elm-set!")
  (let ((index (/class-lookup-element (/object-class-desc self) elm-name)))
    (if index
	(procedure->memoizing-macro
	 (lambda (exp env)
	   `(lambda (obj new-val)
	      (/object-elm-set! obj ,index new-val))))
	(/object-error "elm-set!" self "element not present: " elm-name)))
)

;; Set an element in an object.
;; This can only be used by methods.
;; See the comments for `elm-get'!

(defmacro elm-set! (self elm-name new-val)
  (if (eq? self 'self)
      `(((/elm-make-method-setter ,self ,elm-name)) ,self ,new-val)
      `(elm-xset! ,self ,elm-name ,new-val))
)

;; Get an element from an object.
;; This is for invoking from outside a method, and without having to
;; use elm-make-getter.  It should be used sparingly.

(define (elm-xget obj elm-name)
  (/object-check obj "elm-xget")
  (let ((index (/class-lookup-element (/object-class-desc obj) elm-name)))
    (if index
	(/object-elm-get obj index)
	(/object-error "elm-xget" obj "element not present: " elm-name)))
)

;; Set an element in an object.
;; This is for invoking from outside a method, and without having to
;; use elm-make-setter.  It should be used sparingly.

(define (elm-xset! obj elm-name new-val)
  (/object-check obj "elm-xset!")
  (let ((index (/class-lookup-element (/object-class-desc obj) elm-name)))
    (if index
	(/object-elm-set! obj index new-val)
	(/object-error "elm-xset!" obj "element not present: " elm-name)))
)

;; Return a boolean indicating if object OBJ has element ELM-NAME.

(define (elm-present? obj elm-name)
  (/object-check obj "elm-present?")
  (->bool (/class-lookup-element (/object-class-desc obj) elm-name))
)

;; Return lambda to get element ELM-NAME in CLASS.
;; FIXME: validate elm-name.

(define (elm-make-getter class elm-name)
  (/class-check class "elm-make-getter")
  ;; We use delay here as we can't assume parent classes have been
  ;; initialized yet.
  (let ((fast-index (delay (/class-lookup-element
			    (/class-class-desc class) elm-name))))
    (lambda (obj)
      (let ((index (force fast-index)))
	(/object-elm-get obj index))))
)

;; Return lambda to set element ELM-NAME in CLASS.
;; FIXME: validate elm-name.

(define (elm-make-setter class elm-name)
  (/class-check class "elm-make-setter")
  ;; We use delay here as we can't assume parent classes have been
  ;; initialized yet.
  (let ((fast-index (delay (/class-lookup-element
			    (/class-class-desc class) elm-name))))
    (lambda (obj newval)
      (let ((index (force fast-index)))
	(/object-elm-set! obj index newval))))
)

;; Method operations.

;; Lookup the next method in a class.
;; This means begin the search in the parent.

(define (/method-lookup-next class-desc method-name)
  (let ((parent-descs (/class-desc-parents class-desc)))
    (if (null? parent-descs)
	#f
	(let ((parent-desc (car parent-descs)))
	  (/method-lookup parent-desc method-name))))
)

;; Lookup a method in a class.
;; The result is (class-desc . method).  If the method is found in a parent
;; class, the associated parent class descriptor is returned.

(define (/method-lookup class-desc method-name)
  (if /object-verbose?
      (display (string-append "Looking up method " method-name " in "
			      (/class-name (/class-desc-class class-desc)) ".\n")
	       (current-error-port)))

  (let ((meth (assq method-name (/class-methods (/class-desc-class class-desc)))))
    (if meth
	;; Found.
	(cons class-desc (cdr meth))
	;; Method not found, search parents.
	(/method-lookup-next class-desc method-name)))
)

;; Return a boolean indicating if object OBJ has method NAME.

(define (method-present? obj name)
  (/object-check obj "method-present?")
  (->bool (/method-lookup (/object-class-desc obj) name))
)

;; Add a method to a class.

(define (method-make! class method-name method)
  (/class-check class "method-make!")
  (/object-check-name method-name "method-make!" "method-name must be a symbol")
  (if (not (procedure? method))
      (/object-error "method-make!" method "method must be a procedure"))
  (/class-set-methods! class (acons method-name method
				    (/class-methods class)))
  /object-unspecified
)

;; Utility to create "forwarding" methods.
;; METHODS are forwarded to class member ELM-NAME, assumed to be an object.
;; The created methods take a variable number of arguments.
;; Argument length checking will be done by the receiving method.
;; FIXME: ensure elm-name is a symbol

(define (method-make-forward! class elm-name methods)
  (for-each (lambda (method-name)
	      (method-make!
	       class method-name
	       (eval1 `(lambda args
			 (apply send
				(cons (elm-get (car args)
					       (quote ,elm-name))
				      (cons (quote ,method-name)
					    (cdr args))))))))
	    methods)
  /object-unspecified
)

;; Utility of send, send-next.

(define (/object-method-notify obj method-name maybe-next)
  (set! /object-verbose? #f)
  (display (string-append "Sending " maybe-next method-name " to"
			  (if (method-present? obj 'get-name)
			      (let ((name (send obj 'get-name)))
				(if (or (symbol? name) (string? name))
				    (string-append " object " name)
				    ""))
			      "")
			  " class " (object-class-name obj) ".\n")
	   (current-error-port))
  (set! /object-verbose? #t)
)

;; Invoke a method in an object.
;; When the method is invoked, the (possible parent class) object in which the
;; method is found is passed to the method.
;; ??? The word `send' comes from "sending messages".  Perhaps should pick
;; a better name for this operation, except this is deprecated as a public API.

(define (send obj method-name . args)
  (/object-check obj "send")
  (if /object-verbose? (/object-method-notify obj method-name ""))

  (let ((class-desc.meth (/method-lookup (/object-class-desc obj)
					 method-name)))
    (if class-desc.meth
	(apply (cdr class-desc.meth)
	       (cons obj args))
	(/object-error "send" obj "method not supported: " method-name)))
)

;; Invoke the next method named METHOD-NAME in the heirarchy of OBJ.
;; i.e. the method that would have been invoked if the calling method
;; didn't exist.
;; CLASS-NAME is the class of the invoking method.
;; It is present to simplify things: otherwise we have to either include in
;; objects the notion a current class or specialization, or include the class
;; as an argument to methods.
;; This may only be called by a method.
;; ??? Ideally we shouldn't need either CLASS-NAME or METHOD-NAME arguments.
;; They could be removed with a bit of effort, but is it worth it?
;; One possibility is if method-make! was a macro, then maybe send-next could
;; work with method-make! and get the values from it.
;;
;; While `send' is deprecated, this is not, yet anyway.

(define (send-next obj class-name method-name . args)
  (/object-check obj "send-next")
  (if /object-verbose? (/object-method-notify obj method-name "next "))

  (let* ((class (class-lookup class-name)) ;; FIXME: slow
	 (class-desc.meth (/method-lookup-next (/class-class-desc class)
					       method-name)))
    (if class-desc.meth
	(apply (cdr class-desc.meth)
	       (cons obj args))
	(/object-error "send-next" obj "method not supported: " method-name)))
)

;; Create an interface.
;; This defines a function named NAME that invokes METHOD-NAME.

(defmacro define-interface (name method-name . arg-list)
  `(define (,name object ,@@arg-list)
     (send object (quote ,method-name) ,@@arg-list))
)

;; Wrapper to define a method.
;; `self' must be the first argument.

(defmacro define-method (class name args . body)
  `(method-make! ,class (quote ,name) ,(cons 'lambda (cons args body)))
)

;; Miscellaneous publically accessible utilities.

;; Return list of all classes.

(define (class-list) (map cdr /class-list))

;; Utility to map over a class and all its parent classes, recursively.

(define (class-map-over-class proc class)
  (cons (proc class)
	(map (lambda (class) (class-map-over-class proc class))
	     (/class-parent-classes class)))
)

;; Return class tree of a class or object.

(define (class-tree class-or-object)
  (cond ((class? class-or-object)
	 (class-map-over-class class-name class-or-object))
	((object? class-or-object)
	 (class-map-over-class class-name (/object-class class-or-object)))
	(else (/object-error "class-tree" class-or-object
			     "not a class or object")))
)

;; Return names of each alist.

(define (/class-alist-names class)
  (list (/class-name class)
	(map car (/class-elements class))
	(map car (/class-methods class)))
)

;; Return complete layout of class-or-object.

(define (class-layout class-or-object)
  (cond ((class? class-or-object)
	 (class-map-over-class /class-alist-names class-or-object))
	((object? class-or-object)
	 (class-map-over-class /class-alist-names (/object-class class-or-object)))
	(else (/object-error "class-layout" class-or-object
			     "not a class or object")))
)

;; Define the getter for a list of elements of a class.

(defmacro define-getters (class class-prefix elm-names)
  (cons 'begin
	(map (lambda (elm-name)
	       (if (pair? elm-name)
		   `(define ,(symbol-append class-prefix '- (cdr elm-name))
		      (elm-make-getter ,class (quote ,(car elm-name))))
		   `(define ,(symbol-append class-prefix '- elm-name)
		      (elm-make-getter ,class (quote ,elm-name)))))
	     elm-names))
)

;; Define the setter for a list of elements of a class.

(defmacro define-setters (class class-prefix elm-names)
  (cons 'begin
	(map (lambda (elm-name)
	       (if (pair? elm-name)
		   `(define ,(symbol-append class-prefix '-set- (cdr elm-name) '!)
		      (elm-make-setter ,class (quote ,(car elm-name))))
		   `(define ,(symbol-append class-prefix '-set- elm-name '!)
		      (elm-make-setter ,class (quote ,elm-name)))))
	     elm-names))
)

;; Make an object, specifying values for particular elements.

(define (vmake class . args)
  (let ((obj (new class)))
    (let ((unrecognized (send obj 'vmake! args)))
      (if (null? unrecognized)
	  obj
	  (error "vmake: unknown options:" unrecognized))))
)

;; Like assq but based on the `name' element.
;; WARNING: Slow.

(define (object-assq name obj-list)
  (find-first (lambda (o) (eq? (elm-xget o 'name) name))
	      obj-list)
)

;; Like memq but based on the `name' element.
;; WARNING: Slow.

(define (object-memq name obj-list)
  (let loop ((r obj-list))
    (cond ((null? r) #f)
	  ((eq? name (elm-xget (car r) 'name)) r)
	  (else (loop (cdr r)))))
)

;; Misc. internal utilities.

;; We need a fast vector copy operation.
;; If `vector-copy' doesn't exist (which is assumed to be the fast one),
;; provide a simple version.

(if (defined? 'vector-copy)
    (define /object-vector-copy vector-copy)
    (define (/object-vector-copy v) (list->vector (vector->list v)))
)
@


1.12
log
@	* cos.scm: Follow commenting convention.  Why did a single ; have to
	get indented like it does? :-(
@
text
@d32 1
a32 2
;; Values can be looked up by name, via elm-make-[gs]etter routines, or
;; methods can use elm-get/set! for speed.
d35 1
a35 1
;; confuse that with intentions at directions.
d72 1
a72 1
;; User visible procs:
d74 21
a94 1
;; (class-make name parents elements methods) -> class
d97 9
a105 5
;; a class argument.  Note however that PARENTS is a list of class names,
;; not the class data type.  This allows reloading the definition of a
;; parent class without having to reload any subclasses.  To implement this
;; classes are recorded internally, and `object-init!' must be called if any
;; class has been redefined.
d149 1
a149 1
;; (object-copy object) -> copy of OBJ
d151 2
a152 2
;; ??? Whether to discard the parent or keep it and retain specialization
;; is undecided.
d154 4
a157 1
;; (object-copy-top object) -> copy of OBJECT with spec'n discarded
d183 1
a183 1
;; Return lambda to get the value of ELM-NAME in CLASS.
d187 1
a187 1
;; Return lambda to set the value of ELM-NAME in CLASS.
d190 7
a196 7
;; - procs/vars internal to this file are prefixed with "-"
;;   [Of course this could all be put in a module; later if ever since
;;   once Guile has its own official object system we'll convert.  Note that
;;   it currently does not.]
;; - except for a few exceptions, public procs begin with one of
;;   class-, object-, elm-, method-.
;;   The exceptions are make, new, parent, send.
d256 1
a256 1
			(apply string-append (map ->string text))
d259 1
a259 1
			     " (class: " (->string (/object-class-name x))
d262 1
a262 1
						(->string (send x 'get-name)))
d269 19
d424 1
a424 1
    ;; Use a bogus value for offset for the moment.
d624 1
a624 2
;; METHODS is an initial alist of methods.  More methods can be added with
;; method-make!.
d626 1
a626 1
(define (class-make name parents elms methods)
d628 3
a630 3
      (/object-error 'class-make parents "multiple-inheritance is not supported"))
  (if (> (length methods) 0)
      (/object-error 'class-make methods "methods specified with class"))
a697 10
;; Make a copy of OBJ.
;; This makes a copy of top level object, with any specialization discarded.
;; WARNING: A shallow copy is done on the elements!
;; FIXME: Delete, specialization gone.

(define (object-copy-top obj)
  (/object-check obj "object-copy-top")
  (/object-copy obj)
)

d727 1
a727 2
    (method-make! class 'make! (eval1 lambda-expr))
    )
d758 120
d903 1
a903 1
	(/object-error "elm-get" self "element not present: " elm-name)))
d1109 1
a1109 1
;; a better name for this operation.
d1135 2
a1149 2

;; Miscellaneous publically accessible utilities.
d1151 2
a1152 1
;; Reset the object system (delete all classes).
d1154 3
a1156 4
(define (object-reset!)
  (set! /class-list (list))
  (set! /class-table (vector))
  /object-unspecified
d1159 5
a1163 14
;; Call once to initialize the object system.
;; Only necessary if classes have been modified after objects have been
;; instantiated.  This usually happens during development only.

(define (object-init!)
  (for-each (lambda (class)
	      (/class-set-all-initial-values! class #f)
	      (/class-set-all-methods! class #f)
	      (/class-set-class-desc! class #f))
	    (class-list))
  (for-each (lambda (class)
	      (/class-check-init! class))
	    (class-list))
  /object-unspecified
d1165 2
d1210 36
@


1.11
log
@	* cos.scm (object-assign!): New function.
	* mode.scm (/mode-set-word-params!): Call it.
@
text
@d1 170
a170 170
; Cgen's Object System.
; Copyright (C) 2000, 2009 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.
;
; Scheme implementations don't agree on a lot of things beyond the basics.
; This is a simple object system for cgen's needs.
; I thought at the start that when Guile had an official object system
; we'd switch over, but the higher order bit now is to be usable on
; multiple Scheme implementations: Guile isn't fast enough.
;
; NOTE: The original COS supported multiple inheritance.  This does not.
;
; Classes look like:
;
; #(class-tag
;   class-name
;   class-uid ; unique id of class, index into /class-table
;   parent-name
;   elm-alist ; not including parent classes
;   method-alist ; not including parent classes
;   full-elm-initial-list ; including parent classes
;   method-cache ; ??? not currently used
;   class-descriptor)
;
; PARENT-NAME is the name of the parent class, if any.
; If a subclasses b which subclasses c, then parent-name for a is b,
; the parent-name for b is c, and the parent-name for c is #f.
;
; ELM-ALIST is an alist of (symbol vector-offset-with-class . initial-value)
; for this class only.
; Values can be looked up by name, via elm-make-[gs]etter routines, or
; methods can use elm-get/set! for speed.
; Various Lisp (or Lisp-like) OOP systems (e.g. CLOS, Dylan) call these
; "slots".  Maybe for consistency "slot" would be a better name.  Some might
; confuse that with intentions at directions.
;
; METHOD-ALIST is an alist of (symbol . procedure) for this class only.
;
; FULL-ELM-INITIAL-LIST is the elements of the flattened inheritance tree.
; Initially it is #f meaning it hasn't been computed yet.
; It is computed when the class is first instantiated.  During development,
; it can be reset to #f after some module has been reloaded (as long as no
; elements have been deleted/added/moved/etc., existing objects are ok).
;
; METHOD-CACHE is an alist of the methods of the flattened inheritance
; tree.  Each element is (symbol . (parent-list-entry . method)).
; Initially it is #f meaning it hasn't been computed yet.
; It is computed when the class is first instantiated.  During development,
; it can be reset to #f after some module has been reloaded (requires all
; object instantiation to happen later of course).
; FIXME: We don't yet implement the method cache.
;
; CLASS-DESCRIPTOR is the processed form of parent-name-list.
; There is an entry for the class and one for each parent (recursively):
; (class offset child-backpointer [parent-descriptor]).
; offset is the offset in the element vector of the class's elements.
; child-backpointer is #f in the top level object.
; ??? child->subclass, parent->superclass?
; Initially the class-descriptor is #f meaning it hasn't been computed yet.
; It is computed when the class is first instantiated.  During development,
; it can be reset to #f after some module has been reloaded (requires all
; object instantiation to happen later of course).
;
; An object is a vector: #(object-tag class-name class-uid elm1 elm2 ...)
; Vectors are nice in that they're self-evaluating.
; Both class name and uid are stored here for a better developer experience.
; It might be better to store the class-descriptor instead, but it's big and
; vastly reduces the S/N ratio when displaying objects.
;
; -----------------------------------------------------------------------------
;
; User visible procs:
;
; (class-make name parents elements methods) -> class
;
; Create a class.  The result is then passed back by procedures requiring
; a class argument.  Note however that PARENTS is a list of class names,
; not the class data type.  This allows reloading the definition of a
; parent class without having to reload any subclasses.  To implement this
; classes are recorded internally, and `object-init!' must be called if any
; class has been redefined.
;
; (class-list) -> list of all defined classes
;
; (class-name class) -> name of CLASS
;
; (class-lookup class-name) -> class
;
; (class-instance? class object) -> #t if OBJECT is an instance of CLASS
;
; (object-class object) -> class of OBJECT
;
; (object-class-name object) -> class name of OBJECT
;
; (send object method-name . args) -> result of invoking METHOD-NAME
;
; (send-next object class-name method-name . args) -> result of invoking next METHOD-NAME
;
; (new class) -> instantiate CLASS
;
; The object is initialized with values specified when CLASS
; (and its parent classes) was defined.
;
; (vmake class . args) -> instantiate class and initialize it with 'vmake!
;
; This is shorthand for (send (new class) 'vmake! args).
; ARGS is a list of option names and arguments (a la CLOS).
; ??? Not implemented yet.
;
; (method-vmake! object . args) -> modify OBJECT from ARGS
;
; This is the standard 'vmake! method, available for use by user-written
; 'vmake! methods.
; ??? Not implemented yet.
;
; (make class . args) -> instantiate CLASS and initialize it with 'make!
;
; This is shorthand for (send (new class) 'make! arg1 ...).
; This is a positional form of `new'.
;
; (method-make-make! class elm1-name elm2-name ...) -> unspecified
;
; Create a 'make! method that sets the specified elements.
;
; (object-copy object) -> copy of OBJ
;
; ??? Whether to discard the parent or keep it and retain specialization
; is undecided.
;
; (object-copy-top object) -> copy of OBJECT with spec'n discarded
;
; (class? foo) -> return #t if FOO is a class
;
; (object? foo) -> return #t if FOO is an object
;
; (method-make! class name lambda) -> unspecified
;
; Add method NAME to CLASS.
;
; (method-make-forward! class elm-name methods) -> unspecified
;
; Add METHODS to CLASS that pass the "message" onto the object in element
; ELM-NAME.
;
; (elm-get object elm-name) -> value of element ELM-NAME in OBJ
;
; Can only be used in methods.
;
; (elm-set! object elm-name new-value) -> unspecified
;
; Set element ELM-NAME in OBJECT to NEW-VALUE.
; Can only be used in methods.
;
; (elm-make-getter class elm-name) -> lambda
;
; Return lambda to get the value of ELM-NAME in CLASS.
;
; (elm-make-setter class elm-name) -> lambda
;
; Return lambda to set the value of ELM-NAME in CLASS.
;
; Conventions used in this file:
; - procs/vars internal to this file are prefixed with "-"
;   [Of course this could all be put in a module; later if ever since
;   once Guile has its own official object system we'll convert.  Note that
;   it currently does not.]
; - except for a few exceptions, public procs begin with one of
;   class-, object-, elm-, method-.
;   The exceptions are make, new, parent, send.
d190 1
a190 1
; True if error messages are verbose and debugging messages are printed.
d194 1
a194 1
; Cover fn to set verbosity.
d200 1
a200 1
; Signal error if not class/object.
d244 1
a244 1
; Low level class operations.
d246 1
a246 1
; Return boolean indicating if X is a class.
d252 1
a252 1
; Accessors.
d283 2
a284 2
; Make a class.
; The new definition overrides any existing definition.
d306 2
a307 2
; Lookup a class given its name.
; The result is the class or #f if not found.
d330 4
a333 4
; Cover proc of /class-name for the outside world to use.
; The result is the name of the class or #f if CLASS is not a class.
; We could issue an error here, but to be consistent with object-class-name
; we don't.
d341 3
a343 3
; Class descriptor utilities.
; A class-descriptor is:
; (class offset child-backpointer [parent-descriptor])
d354 10
a363 10
; Compute the class descriptor of CLASS.
; OFFSET is the beginning offset in the element vector.
; We can assume the parents of CLASS have already been initialized.
;
; A class-descriptor is:
; (class offset child (parent-entry))
; CLASS is the class? data structure of the class.
; OFFSET is the offset into the object vector of the baseclass's elements.
; CHILD is the backlink to the direct child class or #f if no subclass.
; PARENT-ENTRY is the class descriptor of the parent class.
d367 6
a372 6
  ; OFFSET must be global to the calculation because it is continually
  ; incremented as we recurse down through the hierarchy (actually, as we
  ; traverse back up).  At any point in time it is the offset from the start
  ; of the element vector of the next class's elements.
  ; Object elements are laid out using a depth first traversal of the
  ; inheritance tree.
d406 1
a406 1
; Return the top level class-descriptor of CLASS-DESC.
d414 1
a414 1
; Pretty print a class descriptor.
d447 1
a447 1
; Low level object utilities.
d449 2
a450 2
; Make an object.
; All elements get initial (or unbound) values.
d460 2
a461 2
; Make an object using VALUES.
; VALUES must specify all elements in the class (and parent classes).
d471 2
a472 2
; Copy an object.
; WARNING: A shallow copy is currently done on the elements!
d478 1
a478 1
; Accessors.
d500 1
a500 1
; Return boolean indicating if X is an object.
d508 1
a508 1
; Return the class of an object.
d515 2
a516 2
; Cover proc of /object-class-name for the outside world to use.
; The result is the name of the class or #f if OBJ is not an object.
d524 1
a524 1
; Class operations.
d526 2
a527 2
; Return the list of initial values for CLASS.
; The result does not include parent classes.
d533 2
a534 2
; Initialize class if not already done.
; FIXME: Need circularity check.  Later.
d537 2
a538 2
  ; This should be fast the second time through, so don't do any
  ; computation until we know it's necessary.
d546 1
a546 1
	; First pass ensures all parents are initialized.
d550 1
a550 1
	; Next pass initializes the initial value list.
d562 2
a563 2
	; Next pass initializes the class's class-descriptor.
	; Object elements begin at offset 3 in the element vector.
d571 10
a580 10
; Make a class.
;
; PARENTS is the name of parent class as a list, i.e. () or (<parent>).
; It's a list just in case multiple-inheritance is added one day.
; The parent need not exist yet, though it must exist when the class
; is first instantiated.
; ELMS is a either a list of either element names or name/value pairs.
; Elements without initial values are marked as "unbound".
; METHODS is an initial alist of methods.  More methods can be added with
; method-make!.
d590 4
a593 4
    ; Mark elements without initial values as unbound, and
    ; compute indices into the element vector (relative to the class's
    ; offset).
    ; Elements are recorded as (symbol initial-value . vector-index)
d596 1
a596 1
	  (set! elm-list (reverse! elm-list-tmp)) ; done
d613 8
a620 8
      ; Create the standard `make!' method.
      ; The caller can override afterwards if desired.
      ; Note that if there are any parent classes then we don't know the names
      ; of all of the elements yet, that is only known after the class has been
      ; initialized which only happens when the class is first instantiated.
      ; This method won't be called until that happens though so we're safe.
      ; This is written without knowledge of the names, it just initializes
      ; all elements.
d624 1
a624 1
			; Ensure exactly all of the elements are provided.
d634 1
a634 1
; Create an object of a class CLASS.
d646 2
a647 2
; Make a copy of OBJ.
; WARNING: A shallow copy is done on the elements!
d654 4
a657 4
; Make a copy of OBJ.
; This makes a copy of top level object, with any specialization discarded.
; WARNING: A shallow copy is done on the elements!
; FIXME: Delete, specialization gone.
d664 2
a665 2
; Assign object SRC to object DST.
; They must have the same class.
d682 3
a684 3
; Utility to define a standard `make!' method.
; A standard make! method is one in which all it does is initialize
; fields from args.
d697 2
a698 2
; The "standard" way to invoke `make!' is (send (new class) 'make! ...).
; This puts all that in a cover function.
d704 1
a704 1
; Return #t if class X is a subclass of BASE-NAME.
d715 3
a717 3
; Return #t if OBJECT is an instance of CLASS.
; This does not signal an error if OBJECT is not an object as this is
; intended to be used in class predicates.
d726 1
a726 1
; Element operations.
d728 2
a729 2
; Lookup an element in a class-desc.
; The result is elm-index or #f if not found.
d743 1
a743 1
; Return a boolean indicating if ELM-NAME is bound in OBJ.
d753 1
a753 1
; Subroutine of elm-get.
d766 11
a776 11
; Get an element from an object.
; If OBJ is `self' then the caller is required to be a method and we emit
; memoized code.  Otherwise we do things the slow way.
; ??? There must be a better way.
; What this does is turn
; (elm-get self 'foo)
; into
; ((/elm-make-method-get self 'foo) self)
; Note the extra set of parens.  /elm-make-method-get then does the lookup of
; foo and returns a memoizing macro that returns the code to perform the
; operation with O(1).  Cute, but I'm hoping there's an easier/better way.
d784 1
a784 1
; Subroutine of elm-set!.
d797 3
a799 3
; Set an element in an object.
; This can only be used by methods.
; See the comments for `elm-get'!
d807 3
a809 3
; Get an element from an object.
; This is for invoking from outside a method, and without having to
; use elm-make-getter.  It should be used sparingly.
d819 3
a821 3
; Set an element in an object.
; This is for invoking from outside a method, and without having to
; use elm-make-setter.  It should be used sparingly.
d831 1
a831 1
; Return a boolean indicating if object OBJ has element ELM-NAME.
d838 2
a839 2
; Return lambda to get element ELM-NAME in CLASS.
; FIXME: validate elm-name.
d843 2
a844 2
  ; We use delay here as we can't assume parent classes have been
  ; initialized yet.
d852 2
a853 2
; Return lambda to set element ELM-NAME in CLASS.
; FIXME: validate elm-name.
d857 2
a858 2
  ; We use delay here as we can't assume parent classes have been
  ; initialized yet.
d866 1
a866 1
; Method operations.
d868 2
a869 2
; Lookup the next method in a class.
; This means begin the search in the parent.
d879 3
a881 3
; Lookup a method in a class.
; The result is (class-desc . method).  If the method is found in a parent
; class, the associated parent class descriptor is returned.
d893 1
a893 1
	; Method not found, search parents.
d897 1
a897 1
; Return a boolean indicating if object OBJ has method NAME.
d904 1
a904 1
; Add a method to a class.
d916 5
a920 5
; Utility to create "forwarding" methods.
; METHODS are forwarded to class member ELM-NAME, assumed to be an object.
; The created methods take a variable number of arguments.
; Argument length checking will be done by the receiving method.
; FIXME: ensure elm-name is a symbol
d936 1
a936 1
; Utility of send, send-next.
d952 5
a956 5
; Invoke a method in an object.
; When the method is invoked, the (possible parent class) object in which the
; method is found is passed to the method.
; ??? The word `send' comes from "sending messages".  Perhaps should pick
; a better name for this operation.
d970 12
a981 12
; Invoke the next method named METHOD-NAME in the heirarchy of OBJ.
; i.e. the method that would have been invoked if the calling method
; didn't exist.
; CLASS-NAME is the class of the invoking method.
; It is present to simplify things: otherwise we have to either include in
; objects the notion a current class or specialization, or include the class
; as an argument to methods.
; This may only be called by a method.
; ??? Ideally we shouldn't need either CLASS-NAME or METHOD-NAME arguments.
; They could be removed with a bit of effort, but is it worth it?
; One possibility is if method-make! was a macro, then maybe send-next could
; work with method-make! and get the values from it.
d996 1
a996 1
; Miscellaneous publically accessible utilities.
d998 1
a998 1
; Reset the object system (delete all classes).
d1006 3
a1008 3
; Call once to initialize the object system.
; Only necessary if classes have been modified after objects have been
; instantiated.  This usually happens during development only.
d1022 1
a1022 1
; Return list of all classes.
d1026 1
a1026 1
; Utility to map over a class and all its parent classes, recursively.
d1034 1
a1034 1
; Return class tree of a class or object.
d1045 1
a1045 1
; Return names of each alist.
d1053 1
a1053 1
; Return complete layout of class-or-object.
d1064 2
a1065 2
; Like assq but based on the `name' element.
; WARNING: Slow.
d1072 2
a1073 2
; Like memq but based on the `name' element.
; WARNING: Slow.
d1082 1
a1082 1
; Misc. internal utilities.
d1084 3
a1086 3
; We need a fast vector copy operation.
; If `vector-copy' doesn't exist (which is assumed to be the fast one),
; provide a simple version.
@


1.10
log
@	* cos.scm (/class-table): New global.
	(/class-uid, /class-set-uid!): New functions.
	(/class-parent-name): Renamed from /class-parents.
	(/class-make!): Change parents arg to parent-name, all callers updated.
	Assign uid to class.
	(/class-lookup-uid): New function.
	(/class-parent-classes): Rewrite.
	(/class-mi?): Delete.
	(/class-desc-mi?, /class-desc-offset-case, /class-desc-offset-case):
	Delete.
	(/class-desc-offset, /class-desc-child, /class-desc-parents): Update.
	(/class-compute-class-desc, class-desc-dump): Update.
	(/object-make!): Update.
	(/object-make-with-values!): Delete arg class-desc, all callers
	updated.
	(/object-copy): Delete arg top?, all callers updated.
	(/object-specialize): Delete.
	(/object-elements, /object-top-class): Delete.
	(/object-class-name, /object-class-desc): Update.
	(/object-class-uid): New function.
	(/object-elm-get, /object-elm-set!, object?, /class-check-init!,
	class-make, /class-subclass? /class-lookup-element,
	Update.
	(/elm-delta, elm-list): Delete.
	(/elm-make-method-getter, elm-get, elm-xget): Update.
	(/elm-make-method-setter, elm-set!, elm-xset!): Update.
	(elm-make-getter, elm-make-setter): Update.
	(/method-lookup-next): Update.
	(send): Don't specialize class passed to method.
	(send-next): New arg class-name, all callers updated.
	(/class-parent, /class-parent-via-path, object-parent): Delete.
	(class-cons-parent!, class-append-parent!): Delete.
	(object-reset!): Init /class-table.
@
text
@d664 18
@


1.9
log
@	* cos.scm (/object-debug-classes): Delete.
	(/object-debug-elements, /object-debug-methods): Delete.
@
text
@d6 7
a12 8
; When Guile has an official object implementation that is stable, things will
; be switched over then.  Until such time, there's no point in getting hyper
; (although doing so is certainly fun, but only to a point).
; If the Guile team decides there won't be any official object system
; (which isn't unreasonable) then we'll pick the final object system then.
; Until such time, there are better things to do than trying to build a
; better object system.  If this is important enough to you, help the Guile
; team finish the module(/object?) system.
d18 6
a23 5
;   parent-name-list
;   elm-alist
;   method-alist
;   full-elm-initial-list
;   full-method-alist ; ??? not currently used
d26 3
a28 2
; PARENT-NAME-LIST is a list of the names of parent classes (the inheritance
; tree).
d30 1
a30 1
; ELM-ALIST is an alist of (symbol private? vector-index . initial-value)
d36 1
a36 2
; confuse that with intentions at directions.  Given that something better
; will eventually happen, being deliberately different is useful.
d38 1
a38 2
; METHOD-ALIST is an alist of (symbol . procedure) for this
; class only.
d43 2
a44 2
; it can be reset to #f after some module has been reloaded (requires all
; object instantiation happens later of course).
d46 1
a46 1
; FULL-METHOD-ALIST is an alist of the methods of the flattened inheritance
d51 2
a52 1
; object instantiation happens later of course).
d56 2
a57 7
; (class mi? (base-offset . delta) child-backpointer (parent1-entry) ...).
; mi? is #t if the class or any parent class has multiple inheritance.
; This is used by the element access routines.
; base-offset is the offset in the element vector of the baseclass (or first
; baseclass in the mi case).
; delta is the offset from base-offset of the class's own elements
; (as opposed to elements in any parent class).
d65 5
a69 15
; An object is a vector of 2 elements: #(object-elements class-descriptor).
; ??? Things would be simpler if objects were a pair but that makes eval'ing
; them trickier.  Vectors are nice in that they're self-evaluating, though
; due to the self-referencing, which Guile 1.2 can't handle, apps have to
; be careful.
; ??? We could use smobs/records/whatever but the difference isn't big enough
; for me to care at this point in time.
;
; `object-elements' looks like:
;
; #(object-tag
;   class
;   element1
;   element2
;   ...)
d71 1
a71 1
; CLASS is the class the object is an instance of.
d98 1
a98 1
; (send-next object method-name . args) -> result of invoking next METHOD-NAME
a132 2
; (object-parent object parent-path) -> parent object in OBJECT via PARENT-PATH
;
d175 3
a177 1
; List of all classes.
d181 6
a186 1
; ??? Were written as a procedures for Hobbit's sake (I think).
d209 1
d216 1
d225 3
a227 1
; X is any arbitrary Scheme data.
d255 7
a261 6
(define (/class-parents class) (vector-ref class 2))
(define (/class-elements class) (vector-ref class 3))
(define (/class-methods class) (vector-ref class 4))
(define (/class-all-initial-values class) (vector-ref class 5))
(define (/class-all-methods class) (vector-ref class 6))
(define (/class-class-desc class) (vector-ref class 7))
d263 2
a264 6
(define (/class-set-parents! class parents)
  (vector-set! class 2 parents)
)

(define (/class-set-elements! class elm-alist)
  (vector-set! class 3 elm-alist)
d268 1
a268 1
  (vector-set! class 4 method-alist)
d272 1
a272 1
  (vector-set! class 5 init-list)
d275 2
a276 2
(define (/class-set-all-methods! class all-meth-list)
  (vector-set! class 6 all-meth-list)
d280 1
a280 1
  (vector-set! class 7 parent-list)
d286 6
a291 2
(define (/class-make! name parents elements methods)
  (let ((class (vector /class-tag name parents elements methods #f #f #f))
d294 9
a302 2
	(set-cdr! list-entry class)
	(set! /class-list (acons name class /class-list)))
d311 7
a317 1
; Return a list of all direct parent classes of CLASS.
d320 8
a327 11
  ; /class-parents returns the names, we want the actual classes.
  (let loop ((parents (/class-parents class))
	     (result '()))
    (if (null? parents)
	(reverse! result)
	(let ((parent (class-lookup (car parents))))
	  (if (not parent)
	      ; The proc name we pass here is made up as we don't
	      ; want it to be the name of an internal proc.
	      (/object-error "class" (car parents) "not a class"))
	  (loop (cdr parents) (cons parent result)))))
a339 7

; Return a boolean indicating if CLASS or any parent class has
; multiple inheritance.

(define (/class-mi? class)
  (/class-desc-mi? (/class-class-desc class))
)
d343 1
a343 1
; (class mi? (base-offset . delta) child-backpointer (parent1-entry) ...)
a344 3
;(define (/class-desc-make class offset bkptr parents)
;   (append (list class offset bkptr) parents)
;)
d350 3
a352 9
(define /class-desc-mi? cadr)
(define /class-desc-offset caddr)
(define /class-desc-offset-base caaddr)
(define /class-desc-offset-delta cdaddr)
(define /class-desc-child cadddr)
(define /class-desc-parents cddddr)
; Note that this is an assq on the classes themselves, not their names.
; The result is the parent's class-descriptor.
(define /class-desc-lookup-parent assq)
d359 5
a363 7
; (class mi? (base-offset . delta) child-backpointer (parent1-entry) ...)
; MI? is a boolean indicating if multiple inheritance is present.
; BASE-OFFSET is the offset into the object vector of the baseclass's elements
; (or first baseclass in the mi case).
; DELTA is the offset from BASE-OFFSET of the class's own elements.
; CHILD is the backlink to the direct child class or #f for the top class.
; ??? Is the use of `top' backwards from traditional usage?
d374 18
a391 1
  (define (compute1 class child base-offset)
d393 1
a393 30
    ; Build the result first, then build our parents so that our parents have
    ; the right value for the CHILD-BACKPOINTER field.
    ; Use a bogus value for mi? and offset for the moment.
    ; The correct values are set later.

    (let ((result (list class #f (cons 999 999) child))
	  (mi? (> (length (/class-parents class)) 1)))

      ; Recurse on the parents.
      ; We use `append!' here as the location of `result' is now fixed so
      ; that our parent's child-backpointer remains stable.

      (append! result
	       (let loop ((parents (/class-parents class))
			  (parent-descs '())
			  (base-offset base-offset))
		 (if (null? parents)
		     (reverse! parent-descs)
		     (let ((parent (class-lookup (car parents))))
		       (if (not parent)
			   ; The proc name we pass here is made up as we don't
			   ; want it to be the name of an internal proc.
			   (/object-error "class" (car parents) "not a class"))
		       (if (and (not mi?)
				(/class-mi? parent))
			   (set! mi? #t))
		       (let ((parent-desc (compute1 parent result base-offset)))
			 (loop (cdr parents)
			       (cons parent-desc parent-descs)
			       offset))))))
d395 5
a399 2
      (list-set! result 1 mi?)
      (list-set! result 2 (cons base-offset (- offset base-offset)))
d403 1
a403 1
  (compute1 class child offset)
d430 2
a431 6
		     (writeln indent cep "  mi?:         "
			      (/class-desc-mi? cd))
		     (writeln indent cep "  base offset: "
			      (/class-desc-offset-base cd))
		     (writeln indent cep "  delta:       "
			      (/class-desc-offset-delta cd))
d454 4
a457 3
  (vector (apply vector (append! (list /object-tag class)
				 (/class-all-initial-values class)))
	  (/class-class-desc class))
d463 1
a463 1
(define (/object-make-with-values! class class-desc values)
d465 4
a468 2
  (vector (apply vector (append! (list /object-tag class) values))
	  class-desc)
a471 2
; If TOP?, the copy is of the top level object with any specialization
; discarded.
d474 2
a475 6
(define (/object-copy obj top?)
  (if top?
      (vector (/object-vector-copy (/object-elements obj))
	      (/class-class-desc (/object-top-class obj)))
      (vector (/object-vector-copy (/object-elements obj))
	      (/object-class-desc obj)))
d478 4
a481 3
; Specialize an object to be one from a parent class.
; The result is the same object, but with a different view (confined to
; a particular parent class).
d483 2
a484 2
(define (/object-specialize obj class-desc)
  (vector (/object-elements obj) class-desc)
d487 3
a489 1
; Accessors.
d491 2
a492 9
(define (/object-elements obj) (vector-ref obj 0))
(define (/object-class-desc obj) (vector-ref obj 1))
(define (/object-class obj) (/class-desc-class (/object-class-desc obj)))
(define (/object-class-name obj) (/class-name (/object-class obj)))
(define (/object-top-class obj) (vector-ref (/object-elements obj) 1))

(define (/object-elm-get obj class-desc elm-base-offset)
  (vector-ref (/object-elements obj)
	      (+ (/class-desc-offset-base class-desc) elm-base-offset))
d495 2
a496 4
(define (/object-elm-set! obj class-desc elm-base-offset new-val)
  (vector-set! (/object-elements obj)
	       (+ (/class-desc-offset-base class-desc) elm-base-offset)
	       new-val)
a499 6
; Return a boolean indicating of OBJ has multiple-inheritance.

(define (/object-mi? obj)
  (/class-mi? (/object-top-class obj))
)

d504 2
a505 4
       (= (vector-length obj) 2)
       (vector? (vector-ref obj 0))
       (eq? /object-tag (vector-ref (vector-ref obj 0) 0))
       (/class-desc? (vector-ref obj 1)))
d540 3
a542 1
  (if (not (/class-all-initial-values class))
d563 1
a563 1
	; Object elements begin at offset 2 in the element vector.
d565 1
a565 1
				(/class-compute-class-desc class 2 #f))
d573 4
a576 2
; PARENTS is a list of names of parent classes.  The parents need not
; exist yet, though they must exist when the class is first instantiated.
d583 5
d593 1
a593 2
    ; Elements are recorded as (symbol initial-value private? . vector-index)
    ; FIXME: For now all elements are marked as "public".
d599 1
a599 1
			   (cons (cdar elms) (cons #f index))
d604 1
a604 1
			   (cons /object-unbound (cons #f index))
d609 3
a611 1
    (let ((result (/class-make! name parents elm-list methods)))
d626 1
a626 1
				    (- (vector-length (/object-elements self)) 1)))
d628 1
a628 2
			(/object-make-with-values! (/object-top-class self)
						   (/object-class-desc self)
d651 1
a651 1
  (/object-copy obj #f)
d657 1
d661 1
a661 1
  (/object-copy obj #t)
d691 4
a694 6
      (let loop ((parents (/class-parents x)))
	(if (null? parents)
	    #f
	    (if (/class-subclass? base-name (class-lookup (car parents)))
		#t
		(loop (cdr parents))))))
d711 1
a711 3
; The result is (class-desc . (private? . elm-offset)) or #f if not found.
; ??? We could define accessors of the result but knowledge of its format
; is restricted to this section of the source.
d717 3
a719 2
	(cons class-desc (cddr elm))
	(let loop ((parents (/class-desc-parents class-desc)))
d722 1
a722 14
	      (let ((elm (/class-lookup-element (car parents) elm-name)))
		(if elm
		    elm
		    (loop (cdr parents)))))
	  ))
    )
)

; Given the result of /class-lookup-element, return the element's delta
; from base-offset.

(define (/elm-delta index)
  (+ (/class-desc-offset-delta (car index))
     (cddr index))
d725 1
a725 1
; Return a boolean indicating if ELM is bound in OBJ.
d727 1
a727 1
(define (elm-bound? obj elm)
d729 4
a732 3
  (let* ((index (/class-lookup-element (/object-class-desc obj) elm))
	 (val (/object-elm-get obj (car index) (/elm-delta index))))
    (not (eq? val /object-unbound)))
d737 1
a737 1
(define (/elm-make-method-getter self name)
d739 1
a739 1
  (let ((index (/class-lookup-element (/object-class-desc self) name)))
d744 2
a745 3
	      (/object-elm-get obj (/object-class-desc obj)
			       ,(/elm-delta index)))))
	(/object-error "elm-get" self "element not present: " name)))
d755 2
a756 2
; ((-elm-make-method-get self 'foo) self)
; Note the extra set of parens.  -elm-make-method-get then does the lookup of
d760 1
a760 1
(defmacro elm-get (self name)
d762 2
a763 2
      `(((/elm-make-method-getter ,self ,name)) ,self)
      `(elm-xget ,self ,name))
d768 1
a768 1
(define (/elm-make-method-setter self name)
d770 1
a770 1
  (let ((index (/class-lookup-element (/object-class-desc self) name)))
d775 2
a776 3
	      (/object-elm-set! obj (/object-class-desc obj)
				,(/elm-delta index) new-val))))
	(/object-error "elm-set!" self "element not present: " name)))
d783 1
a783 1
(defmacro elm-set! (self name new-val)
d785 2
a786 2
      `(((/elm-make-method-setter ,self ,name)) ,self ,new-val)
      `(elm-xset! ,self ,name ,new-val))
d793 1
a793 1
(define (elm-xget obj name)
d795 1
a795 2
  (let ((index (/class-lookup-element (/object-class-desc obj) name)))
    ; FIXME: check private?
d797 2
a798 2
	(/object-elm-get obj (car index) (/elm-delta index))
	(/object-error "elm-xget" obj "element not present: " name)))
d805 1
a805 1
(define (elm-xset! obj name new-val)
d807 1
a807 2
  (let ((index (/class-lookup-element (/object-class-desc obj) name)))
    ; FIXME: check private?
d809 2
a810 2
	(/object-elm-set! obj (car index) (/elm-delta index) new-val)
	(/object-error "elm-xset!" obj "element not present: " name)))
d813 1
a813 1
; Return a boolean indicating if object OBJ has element NAME.
d815 1
a815 1
(define (elm-present? obj name)
d817 1
a817 1
  (->bool (/class-lookup-element (/object-class-desc obj) name))
d820 2
a821 2
; Return lambda to get element NAME in CLASS.
; FIXME: validate name.
d823 1
a823 1
(define (elm-make-getter class name)
d828 1
a828 1
			    (/class-class-desc class) name))))
d830 2
a831 6
      ; ??? Should be able to use fast-index in mi case.
      ; ??? Need to involve CLASS in lookup.
      (let ((index (if (/object-mi? obj)
		       (/class-lookup-element (/object-class-desc obj) name)
		       (force fast-index))))
      (/object-elm-get obj (car index) (/elm-delta index)))))
d834 2
a835 2
; Return lambda to set element NAME in CLASS.
; FIXME: validate name.
d837 1
a837 1
(define (elm-make-setter class name)
d842 1
a842 1
			    (/class-class-desc class) name))))
d844 2
a845 12
      ; ??? Should be able to use fast-index in mi case.
      ; ??? Need to involve CLASS in lookup.
      (let ((index (if (/object-mi? obj)
		       (/class-lookup-element (/object-class-desc obj) name)
		       (force fast-index))))
	(/object-elm-set! obj (car index) (/elm-delta index) newval))))
)

; Return a list of all elements in OBJ.

(define (elm-list obj)
  (cddr (vector->list (/object-elements obj)))
d851 1
a851 1
; This means begin the search in the parents.
d854 2
a855 2
  (let loop ((parents (/class-desc-parents class-desc)))
    (if (null? parents)
d857 2
a858 4
	(let ((meth (/method-lookup (car parents) method-name)))
	  (if meth
	      meth
	      (loop (cdr parents))))))
a863 2
;
; FIXME: We don't yet implement the method cache.
a886 1
; FIXME: ensure method-name is a symbol
d890 1
a941 1
  (/object-check-name method-name "send" "not a method name")
d948 1
a948 2
	       (cons (/object-specialize obj (car class-desc.meth))
		     args))
d955 4
d960 4
a963 2
; ??? Ideally we shouldn't need the METHOD-NAME argument.  It could be
; removed with a bit of effort, but is it worth it?
d965 1
a965 1
(define (send-next obj method-name . args)
a966 1
  (/object-check-name method-name "send-next" "not a method name")
d969 3
a971 2
  (let ((class-desc.meth (/method-lookup-next (/object-class-desc obj)
					      method-name)))
d974 1
a974 2
	       (cons (/object-specialize obj (car class-desc.meth))
		     args))
a977 94
; Parent operations.

; Subroutine of `parent' to lookup a (potentially nested) parent class.
; The result is the parent's class-descriptor or #f if not found.

(define (/class-parent class-desc parent)
  (let* ((parent-descs (/class-desc-parents class-desc))
	 (desc (/class-desc-lookup-parent parent parent-descs)))
    (if desc
	desc
	(let loop ((parents parent-descs))
	  (if (null? parents)
	      #f
	      (let ((desc (/class-parent (car parents) parent)))
		(if desc
		    desc
		    (loop (cdr parents))))))))
)

; Subroutine of `parent' to lookup a parent via a path.
; PARENT-PATH, a list, is the exact path to the parent class.
; The result is the parent's class-descriptor or #f if not found.
; For completeness' sake, if PARENT-PATH is empty, CLASS-DESC is returned.

(define (/class-parent-via-path class-desc parent-path)
  (if (null? parent-path)
      class-desc
      (let ((desc (/class-desc-lookup-parent (car parent-path)
					     (/class-desc-parents class-desc))))
	(if desc
	    (if (null? (cdr parent-path))
		desc
		(/class-parent-via-path (car desc) (cdr parent-path)))
	    #f)))
)

; Lookup a parent class of object OBJ.
; CLASS is either a class or a list of classes.
; If CLASS is a list, it is a (possibly empty) "path" to the parent.
; Otherwise it is any parent and is searched for breadth-first.
; ??? Methinks this should be depth-first.
; The result is OBJ, specialized to the found parent.

(define (object-parent obj class)
  (/object-check obj "object-parent")
  (cond ((class? class) #t)
	((list? class) (for-each (lambda (class) (/class-check class
							       "object-parent"))
				 class))
	(else (/object-error "object-parent" class "invalid parent path")))
		
  ; Hobbit generates C code that passes the function
  ; /class-parent-via-path or /class-parent, not the appropriate
  ; SCM object.
; (let ((result ((if (or (null? class) (pair? class))
;		     /class-parent-via-path
;		     /class-parent)
;		   obj class)))
  ; So it's rewritten like this.
  (let ((result (if (class? class)
		    (/class-parent (/object-class-desc obj) class)
		    (/class-parent-via-path (/object-class-desc obj) class))))
    (if result
	(/object-specialize obj result)
	(/object-error "object-parent" obj "parent not present")))
  ; FIXME: should print path in error message.
)

; Make PARENT-NAME a parent of CLASS, cons'd unto the front of the search
; order.  This is used to add a parent class to a class after it has already
; been created.  Obviously this isn't something one does willy-nilly.
; The parent is added to the front of the current parent list (affects
; method lookup).

(define (class-cons-parent! class parent-name)
  (/class-check class "class-cons-parent!")
  (/object-check-name parent-name "class-cons-parent!" "not a class name")
  (/class-set-parents! class (cons parent-name (/class-parents class)))
  /object-unspecified
)

; Make PARENT-NAME a parent of CLASS, cons'd unto the end of the search order.
; This is used to add a parent class to a class after it has already been
; created.  Obviously this isn't something one does willy-nilly.
; The parent is added to the end of the current parent list (affects
; method lookup).

(define (class-append-parent! class parent-name)
  (/class-check class "class-append-parent!")
  (/object-check-name parent-name "class-append-parent!" "not a class name")
  (/class-set-parents! obj (append (/class-parents obj) (list parent-name)))
  /object-unspecified
)

d983 2
a984 1
  (set! /class-list '())
a1068 1
; FIXME: Need deep copier instead.
@


1.8
log
@	* cos.scm (/method-lookup): Delete arg virtual?, all callers updated.
	(method-proc): Delete.
	(method-make-virtual!, method-make-virtual-forward!): Delete.
	* ifield.scm (<ifield> field-start): Update.
	(<ifield> field-length, pretty-print): Update.
	(<multi-ifield> field-length, field-start, pretty-print): Update.
	* sid-cpu.scm (/gen-hardware-struct): Use gen-defn instead of gen-decl.
	* sid.scm (<scalar> gen-sym-defn): Renamed from gen-sym-decl.
	(<array> gen-sym-defn): Ditto.
	(<hardware-base> gen-defn): Renamed from gen-defn.
	(<hw-register> gen-type): Update.
	(<hw-register> gen-defn): Renamed from gen-sym-decl, rewrite.
	(<hw-memory>, <hw-address>, <hw-iaddress> gen-type): Update.
	(<hw-memory>, <hw-address> gen-defn): Renamed from gen-sym-decl.
	(<hw-immediate> gen-type): Update.
	(<hw-immediate> gen-defn): Renamed from gen-sym-decl, rewrite.
	* sim-cpu.scm (/gen-hardware-struct): Use gen-defn instead of gen-decl.
	* sim.scm (<scalar> gen-sym-defn): Renamed from gen-sym-decl.
	(<array> gen-sym-defn): Ditto.
	(<hardware-base> gen-defn): Renamed from gen-defn.
	(<hw-register> gen-type): Update.
	(<hw-register> gen-defn): Renamed from gen-sym-decl, rewrite.
	(<hw-memory>, <hw-address>, <hw-iaddress> gen-type): Update.
	(<hw-memory>, <hw-address> gen-defn): Renamed from gen-sym-decl.
	(<hw-immediate> gen-type): Update.
	(<hw-immediate> gen-defn): Renamed from gen-sym-decl, rewrite.
@
text
@a199 12
; Associative list of classes to be traced.

(define /object-debug-classes #f)

; Associative list of elements to be traced.

(define /object-debug-elements #f)

; Associative list of messages to be traced.

(define /object-debug-methods #f)

@


1.7
log
@	* cos.scm (/object-error): Convert symbols to strings before passing
	to string-append.
@
text
@d38 1
a38 1
; METHOD-ALIST is an alist of (symbol . (virtual? . procedure)) for this
a157 4
; (method-make-virtual! class name lambda) -> unspecified
;
; Add virtual method NAME to CLASS.
;
a162 5
; (method-make-virtual-forward! class elm-name methods) -> unspecified
;
; Add virtual METHODS to CLASS that pass the "message" onto the object in
; element ELM-NAME.
;
a929 2
; ??? What should this do for virtual methods.  At present we treat them as
; non-virtual.
d935 1
a935 1
	(let ((meth (/method-lookup (car parents) method-name #f)))
d943 1
a943 4
; class, the associated parent class descriptor is returned.  If the method is
; a virtual method, the appropriate subclass's class descriptor is returned.
; VIRTUAL? is #t if virtual methods are to be treated as such.
; Otherwise they're treated as normal methods.
d947 1
a947 1
(define (/method-lookup class-desc method-name virtual?)
d955 2
a956 24
	(if (and virtual? (cadr meth)) ; virtual?
	    ; Traverse back up the inheritance chain looking for overriding
	    ; methods.  The closest one to the top is the one to use.
	    (let loop ((child (/class-desc-child class-desc))
		       (goal-class-desc class-desc)
		       (goal-meth meth))
	      (if child
		  (begin
		    (if /object-verbose?
			(display (string-append "Looking up virtual method "
						method-name " in "
						(/class-name (/class-desc-class child))
						".\n")
				 (current-error-port)))
		    (let ((meth (assq method-name (/class-methods (/class-desc-class child)))))
		      (if meth
			  ; Method found, update goal object and method.
			  (loop (/class-desc-child child) child meth)
			  ; Method not found at this level.
			  (loop (/class-desc-child child) goal-class-desc goal-meth))))
		  ; Went all the way up to the top.
		  (cons goal-class-desc (cddr goal-meth))))
	    ; Non-virtual, done.
	    (cons class-desc (cddr meth)))
d965 1
a965 12
  (->bool (/method-lookup (/object-class-desc obj) name #f))
)

; Return method NAME of CLASS or #f if not present.
; ??? Assumes CLASS has been initialized.

(define (method-proc class name)
  (/class-check class "method-proc")
  (let ((meth (/method-lookup (/class-class-desc class) name #t)))
    (if meth
	(cdr meth)
	#f))
d975 1
a975 15
  (/class-set-methods! class (acons method-name
				    (cons #f method)
				    (/class-methods class)))
  /object-unspecified
)

; Add a virtual method to a class.
; FIXME: ensure method-name is a symbol

(define (method-make-virtual! class method-name method)
  (/class-check class "method-make-virtual!")
  (if (not (procedure? method))
      (/object-error "method-make-virtual!" method "method must be a procedure"))
  (/class-set-methods! class (acons method-name
				    (cons #t method)
a999 17
; Same as method-make-forward! but creates virtual methods.
; FIXME: ensure elm-name is a symbol

(define (method-make-virtual-forward! class elm-name methods)
  (for-each (lambda (method-name)
	      (method-make-virtual!
	       class method-name
	       (eval1 `(lambda args
			 (apply send
				(cons (elm-get (car args)
					       (quote ,elm-name))
				      (cons (quote ,method-name)
					    (cdr args))))))))
	    methods)
  /object-unspecified
)

d1028 1
a1028 1
					 method-name #t)))
a1246 13

; Profiling support

(if (and #f (defined? 'proc-profile))
    (begin
      (proc-profile elm-get)
      (proc-profile elm-xset!)
      (proc-profile elm-present?)
      (proc-profile /method-lookup)
      (proc-profile send)
      (proc-profile new)
      (proc-profile make)
      ))
@


1.6
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d256 2
a257 1
  (error (string-append proc-name ": " (apply string-append text)
d260 1
a260 1
			     " (class: " (/object-class-name x)
d263 1
a263 1
						(send x 'get-name))
@


1.5
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d198 2
a199 2
(define -class-tag "class")
(define -object-tag "object")
d203 1
a203 1
(define -class-list '())
d206 2
a207 2
(define -object-unspecified #:unspecified)
(define -object-unbound #:unbound)
d211 1
a211 1
(define -object-debug-classes #f)
d215 1
a215 1
(define -object-debug-elements #f)
d219 1
a219 1
(define -object-debug-methods #f)
d223 1
a223 1
(define -object-verbose? #f)
d228 1
a228 1
  (set! -object-verbose? verbose?)
d233 1
a233 1
(define (-class-check maybe-class proc-name . extra-text)
d235 1
a235 1
      (apply -object-error
d238 1
a238 1
  -object-unspecified
d240 1
a240 1
(define (-object-check-name maybe-name proc-name . extra-text)
d242 1
a242 1
      (apply -object-error
d244 1
a244 1
  -object-unspecified
d246 1
a246 1
(define (-object-check maybe-object proc-name . extra-text)
d248 1
a248 1
      (apply -object-error
d251 1
a251 1
  -object-unspecified
d255 1
a255 1
(define (-object-error proc-name x . text)
d259 1
a259 1
			     " (class: " (-object-class-name x)
d275 1
a275 1
  (and (vector? class) (eq? -class-tag (vector-ref class 0)))
d280 7
a286 7
(define (-class-name class) (vector-ref class 1))
(define (-class-parents class) (vector-ref class 2))
(define (-class-elements class) (vector-ref class 3))
(define (-class-methods class) (vector-ref class 4))
(define (-class-all-initial-values class) (vector-ref class 5))
(define (-class-all-methods class) (vector-ref class 6))
(define (-class-class-desc class) (vector-ref class 7))
d288 1
a288 1
(define (-class-set-parents! class parents)
d292 1
a292 1
(define (-class-set-elements! class elm-alist)
d296 1
a296 1
(define (-class-set-methods! class method-alist)
d300 1
a300 1
(define (-class-set-all-initial-values! class init-list)
d304 1
a304 1
(define (-class-set-all-methods! class all-meth-list)
d308 1
a308 1
(define (-class-set-class-desc! class parent-list)
d315 3
a317 3
(define (-class-make! name parents elements methods)
  (let ((class (vector -class-tag name parents elements methods #f #f #f))
	(list-entry (assq name -class-list)))
d320 1
a320 1
	(set! -class-list (acons name class -class-list)))
d327 1
a327 1
(define (class-lookup name) (assq-ref -class-list name))
d331 3
a333 3
(define (-class-parent-classes class)
  ; -class-parents returns the names, we want the actual classes.
  (let loop ((parents (-class-parents class))
d341 1
a341 1
	      (-object-error "class" (car parents) "not a class"))
d345 1
a345 1
; Cover proc of -class-name for the outside world to use.
d352 1
a352 1
      (-class-name class)
d359 2
a360 2
(define (-class-mi? class)
  (-class-desc-mi? (-class-class-desc class))
d367 1
a367 1
;(define (-class-desc-make class offset bkptr parents)
d370 1
a370 1
(define (-class-desc? maybe-class-desc)
d374 7
a380 7
(define -class-desc-class car)
(define -class-desc-mi? cadr)
(define -class-desc-offset caddr)
(define -class-desc-offset-base caaddr)
(define -class-desc-offset-delta cdaddr)
(define -class-desc-child cadddr)
(define -class-desc-parents cddddr)
d383 1
a383 1
(define -class-desc-lookup-parent assq)
d398 1
a398 1
(define (-class-compute-class-desc class offset child)
d415 1
a415 1
	  (mi? (> (length (-class-parents class)) 1)))
d422 1
a422 1
	       (let loop ((parents (-class-parents class))
d431 1
a431 1
			   (-object-error "class" (car parents) "not a class"))
d433 1
a433 1
				(-class-mi? parent))
d442 1
a442 1
      (set! offset (+ offset (length (-class-elements class))))
d450 3
a452 3
(define (-class-desc-top class-desc)
  (if (-class-desc-child class-desc)
      (-class-desc-top (-class-desc-child class-desc))
d460 1
a460 1
	 (top-desc (-class-desc-top class-desc))
d471 1
a471 1
			      (-class-name (-class-desc-class cd)))
d473 1
a473 1
			      (-class-desc-mi? cd))
d475 1
a475 1
			      (-class-desc-offset-base cd))
d477 1
a477 1
			      (-class-desc-offset-delta cd))
d479 3
a481 3
			      (if (-class-desc-child cd)
				  (-class-name (-class-desc-class
						(-class-desc-child cd)))
d484 1
a484 1
			       (-class-desc-parents cd))
d487 1
a487 1
      (display (-class-name (-class-desc-class top-desc)) cep)
d498 5
a502 5
(define (-object-make! class)
  (-class-check-init! class)
  (vector (apply vector (append! (list -object-tag class)
				 (-class-all-initial-values class)))
	  (-class-class-desc class))
d508 3
a510 3
(define (-object-make-with-values! class class-desc values)
  (-class-check-init! class)
  (vector (apply vector (append! (list -object-tag class) values))
d519 1
a519 1
(define (-object-copy obj top?)
d521 4
a524 4
      (vector (-object-vector-copy (-object-elements obj))
	      (-class-class-desc (-object-top-class obj)))
      (vector (-object-vector-copy (-object-elements obj))
	      (-object-class-desc obj)))
d531 2
a532 2
(define (-object-specialize obj class-desc)
  (vector (-object-elements obj) class-desc)
d537 9
a545 9
(define (-object-elements obj) (vector-ref obj 0))
(define (-object-class-desc obj) (vector-ref obj 1))
(define (-object-class obj) (-class-desc-class (-object-class-desc obj)))
(define (-object-class-name obj) (-class-name (-object-class obj)))
(define (-object-top-class obj) (vector-ref (-object-elements obj) 1))

(define (-object-elm-get obj class-desc elm-base-offset)
  (vector-ref (-object-elements obj)
	      (+ (-class-desc-offset-base class-desc) elm-base-offset))
d548 3
a550 3
(define (-object-elm-set! obj class-desc elm-base-offset new-val)
  (vector-set! (-object-elements obj)
	       (+ (-class-desc-offset-base class-desc) elm-base-offset)
d552 1
a552 1
  -object-unspecified
d557 2
a558 2
(define (-object-mi? obj)
  (-class-mi? (-object-top-class obj))
d567 2
a568 2
       (eq? -object-tag (vector-ref (vector-ref obj 0) 0))
       (-class-desc? (vector-ref obj 1)))
d574 2
a575 2
  (-object-check obj "object-class")
  (-object-class obj)
d578 1
a578 1
; Cover proc of -object-class-name for the outside world to use.
d583 1
a583 1
      (-object-class-name obj)
d592 2
a593 2
(define (-class-my-initial-values class)
  (map cadr (-class-elements class))
d599 1
a599 1
(define (-class-check-init! class)
d603 1
a603 1
  (if (not (-class-all-initial-values class))
d608 2
a609 2
	(for-each -class-check-init!
		  (-class-parent-classes class))
d614 1
a614 1
		    (let ((parents (-class-parent-classes class)))
d616 1
a616 1
			      (-class-my-initial-values class))))))
d618 1
a618 1
	  (let* ((parents (-class-parent-classes class))
d620 2
a621 2
				(-class-my-initial-values class))))
	    (-class-set-all-initial-values! class inits)))
d625 2
a626 2
	(-class-set-class-desc! class
				(-class-compute-class-desc class 2 #f))
d629 1
a629 1
  -object-unspecified
d659 1
a659 1
			   (cons -object-unbound (cons #f index))
d664 1
a664 1
    (let ((result (-class-make! name parents elm-list methods)))
d679 4
a682 4
				    (- (vector-length (-object-elements self)) 1)))
			    (-object-error "make!" "" "wrong number of arguments to method `make!'"))
			(-object-make-with-values! (-object-top-class self)
						   (-object-class-desc self)
d691 1
a691 1
  (-class-check class "new")
d693 2
a694 2
  (if -object-verbose?
      (display (string-append "Instantiating class " (-class-name class) ".\n")
d697 1
a697 1
  (-object-make! class)
d704 2
a705 2
  (-object-check obj "object-copy")
  (-object-copy obj #f)
d713 2
a714 2
  (-object-check obj "object-copy-top")
  (-object-copy obj #t)
d741 2
a742 2
(define (-class-subclass? base-name x)
  (if (eq? base-name (-class-name x))
d744 1
a744 1
      (let loop ((parents (-class-parents x)))
d747 1
a747 1
	    (if (-class-subclass? base-name (class-lookup (car parents)))
d757 1
a757 1
  (-class-check class "class-instance?")
d759 1
a759 1
      (-class-subclass? (-class-name class) (-object-class object))
d770 3
a772 3
(define (-class-lookup-element class-desc elm-name)
  (let* ((class (-class-desc-class class-desc))
	 (elm (assq elm-name (-class-elements class))))
d775 1
a775 1
	(let loop ((parents (-class-desc-parents class-desc)))
d778 1
a778 1
	      (let ((elm (-class-lookup-element (car parents) elm-name)))
d786 1
a786 1
; Given the result of -class-lookup-element, return the element's delta
d789 2
a790 2
(define (-elm-delta index)
  (+ (-class-desc-offset-delta (car index))
d797 4
a800 4
  (-object-check obj "elm-bound?")
  (let* ((index (-class-lookup-element (-object-class-desc obj) elm))
	 (val (-object-elm-get obj (car index) (-elm-delta index))))
    (not (eq? val -object-unbound)))
d805 3
a807 3
(define (-elm-make-method-getter self name)
  (-object-check self "elm-get")
  (let ((index (-class-lookup-element (-object-class-desc self) name)))
d812 3
a814 3
	      (-object-elm-get obj (-object-class-desc obj)
			       ,(-elm-delta index)))))
	(-object-error "elm-get" self "element not present: " name)))
d831 1
a831 1
      `(((-elm-make-method-getter ,self ,name)) ,self)
d837 3
a839 3
(define (-elm-make-method-setter self name)
  (-object-check self "elm-set!")
  (let ((index (-class-lookup-element (-object-class-desc self) name)))
d844 3
a846 3
	      (-object-elm-set! obj (-object-class-desc obj)
				,(-elm-delta index) new-val))))
	(-object-error "elm-set!" self "element not present: " name)))
d855 1
a855 1
      `(((-elm-make-method-setter ,self ,name)) ,self ,new-val)
d864 2
a865 2
  (-object-check obj "elm-xget")
  (let ((index (-class-lookup-element (-object-class-desc obj) name)))
d868 2
a869 2
	(-object-elm-get obj (car index) (-elm-delta index))
	(-object-error "elm-xget" obj "element not present: " name)))
d877 2
a878 2
  (-object-check obj "elm-xset!")
  (let ((index (-class-lookup-element (-object-class-desc obj) name)))
d881 2
a882 2
	(-object-elm-set! obj (car index) (-elm-delta index) new-val)
	(-object-error "elm-xset!" obj "element not present: " name)))
d888 2
a889 2
  (-object-check obj "elm-present?")
  (->bool (-class-lookup-element (-object-class-desc obj) name))
d896 1
a896 1
  (-class-check class "elm-make-getter")
d899 2
a900 2
  (let ((fast-index (delay (-class-lookup-element
			    (-class-class-desc class) name))))
d904 2
a905 2
      (let ((index (if (-object-mi? obj)
		       (-class-lookup-element (-object-class-desc obj) name)
d907 1
a907 1
      (-object-elm-get obj (car index) (-elm-delta index)))))
d914 1
a914 1
  (-class-check class "elm-make-setter")
d917 2
a918 2
  (let ((fast-index (delay (-class-lookup-element
			    (-class-class-desc class) name))))
d922 2
a923 2
      (let ((index (if (-object-mi? obj)
		       (-class-lookup-element (-object-class-desc obj) name)
d925 1
a925 1
	(-object-elm-set! obj (car index) (-elm-delta index) newval))))
d931 1
a931 1
  (cddr (vector->list (-object-elements obj)))
d941 2
a942 2
(define (-method-lookup-next class-desc method-name)
  (let loop ((parents (-class-desc-parents class-desc)))
d945 1
a945 1
	(let ((meth (-method-lookup (car parents) method-name #f)))
d960 2
a961 2
(define (-method-lookup class-desc method-name virtual?)
  (if -object-verbose?
d963 1
a963 1
			      (-class-name (-class-desc-class class-desc)) ".\n")
d966 1
a966 1
  (let ((meth (assq method-name (-class-methods (-class-desc-class class-desc)))))
d971 1
a971 1
	    (let loop ((child (-class-desc-child class-desc))
d976 1
a976 1
		    (if -object-verbose?
d979 1
a979 1
						(-class-name (-class-desc-class child))
d982 1
a982 1
		    (let ((meth (assq method-name (-class-methods (-class-desc-class child)))))
d985 1
a985 1
			  (loop (-class-desc-child child) child meth)
d987 1
a987 1
			  (loop (-class-desc-child child) goal-class-desc goal-meth))))
d993 1
a993 1
	(-method-lookup-next class-desc method-name)))
d999 2
a1000 2
  (-object-check obj "method-present?")
  (->bool (-method-lookup (-object-class-desc obj) name #f))
d1007 2
a1008 2
  (-class-check class "method-proc")
  (let ((meth (-method-lookup (-class-class-desc class) name #t)))
d1018 1
a1018 1
  (-class-check class "method-make!")
d1020 2
a1021 2
      (-object-error "method-make!" method "method must be a procedure"))
  (-class-set-methods! class (acons method-name
d1023 2
a1024 2
				    (-class-methods class)))
  -object-unspecified
d1031 1
a1031 1
  (-class-check class "method-make-virtual!")
d1033 2
a1034 2
      (-object-error "method-make-virtual!" method "method must be a procedure"))
  (-class-set-methods! class (acons method-name
d1036 2
a1037 2
				    (-class-methods class)))
  -object-unspecified
d1057 1
a1057 1
  -object-unspecified
d1074 1
a1074 1
  -object-unspecified
d1079 2
a1080 2
(define (-object-method-notify obj method-name maybe-next)
  (set! -object-verbose? #f)
d1090 1
a1090 1
  (set! -object-verbose? #t)
d1100 3
a1102 3
  (-object-check obj "send")
  (-object-check-name method-name "send" "not a method name")
  (if -object-verbose? (-object-method-notify obj method-name ""))
d1104 1
a1104 1
  (let ((class-desc.meth (-method-lookup (-object-class-desc obj)
d1108 1
a1108 1
	       (cons (-object-specialize obj (car class-desc.meth))
d1110 1
a1110 1
	(-object-error "send" obj "method not supported: " method-name)))
d1121 3
a1123 3
  (-object-check obj "send-next")
  (-object-check-name method-name "send-next" "not a method name")
  (if -object-verbose? (-object-method-notify obj method-name "next "))
d1125 1
a1125 1
  (let ((class-desc.meth (-method-lookup-next (-object-class-desc obj)
d1129 1
a1129 1
	       (cons (-object-specialize obj (car class-desc.meth))
d1131 1
a1131 1
	(-object-error "send-next" obj "method not supported: " method-name)))
d1139 3
a1141 3
(define (-class-parent class-desc parent)
  (let* ((parent-descs (-class-desc-parents class-desc))
	 (desc (-class-desc-lookup-parent parent parent-descs)))
d1147 1
a1147 1
	      (let ((desc (-class-parent (car parents) parent)))
d1158 1
a1158 1
(define (-class-parent-via-path class-desc parent-path)
d1161 2
a1162 2
      (let ((desc (-class-desc-lookup-parent (car parent-path)
					     (-class-desc-parents class-desc))))
d1166 1
a1166 1
		(-class-parent-via-path (car desc) (cdr parent-path)))
d1178 1
a1178 1
  (-object-check obj "object-parent")
d1180 1
a1180 1
	((list? class) (for-each (lambda (class) (-class-check class
d1183 1
a1183 1
	(else (-object-error "object-parent" class "invalid parent path")))
d1186 1
a1186 1
  ; -class-parent-via-path or -class-parent, not the appropriate
d1189 2
a1190 2
;		     -class-parent-via-path
;		     -class-parent)
d1194 2
a1195 2
		    (-class-parent (-object-class-desc obj) class)
		    (-class-parent-via-path (-object-class-desc obj) class))))
d1197 2
a1198 2
	(-object-specialize obj result)
	(-object-error "object-parent" obj "parent not present")))
d1209 4
a1212 4
  (-class-check class "class-cons-parent!")
  (-object-check-name parent-name "class-cons-parent!" "not a class name")
  (-class-set-parents! class (cons parent-name (-class-parents class)))
  -object-unspecified
d1222 4
a1225 4
  (-class-check class "class-append-parent!")
  (-object-check-name parent-name "class-append-parent!" "not a class name")
  (-class-set-parents! obj (append (-class-parents obj) (list parent-name)))
  -object-unspecified
d1233 2
a1234 2
  (set! -class-list '())
  -object-unspecified
d1243 3
a1245 3
	      (-class-set-all-initial-values! class #f)
	      (-class-set-all-methods! class #f)
	      (-class-set-class-desc! class #f))
d1248 1
a1248 1
	      (-class-check-init! class))
d1250 1
a1250 1
  -object-unspecified
d1255 1
a1255 1
(define (class-list) (map cdr -class-list))
d1262 1
a1262 1
	     (-class-parent-classes class)))
d1271 2
a1272 2
	 (class-map-over-class class-name (-object-class class-or-object)))
	(else (-object-error "class-tree" class-or-object
d1278 4
a1281 4
(define (-class-alist-names class)
  (list (-class-name class)
	(map car (-class-elements class))
	(map car (-class-methods class)))
d1288 1
a1288 1
	 (class-map-over-class -class-alist-names class-or-object))
d1290 2
a1291 2
	 (class-map-over-class -class-alist-names (-object-class class-or-object)))
	(else (-object-error "class-layout" class-or-object
d1321 2
a1322 2
    (define -object-vector-copy vector-copy)
    (define (-object-vector-copy v) (list->vector (vector->list v)))
d1332 1
a1332 1
      (proc-profile -method-lookup)
@


1.4
log
@	* attr.scm: Removing trailing whitespace.
	* cgen-intrinsics.scm: Ditto.
	* cgen-sim.scm: Ditto.
	* cos.scm: Ditto.
	* enum.scm: Ditto.
	* guile.scm: Ditto.
	* sim.scm: Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
@


1.4.2.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2009 Red Hat, Inc.
@


1.3
log
@* cos.scm: Profile elm-xset! when requested, not elm-set!; the
latter is a macro.
@
text
@d166 1
a166 1
;                                 
@


1.2
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@d1330 1
a1330 1
      (proc-profile elm-set!)
@


1.1
log
@Initial revision
@
text
@d203 1
a203 1
(define -class-list ())
d334 1
a334 1
	     (result ()))
d423 1
a423 1
			  (parent-descs ())
d649 1
a649 1
    (let loop ((elm-list-tmp ()) (index 0) (elms elms))
d728 1
a728 1
    (method-make! class 'make! (eval lambda-expr))
d736 1
a736 1
  (apply send (append (cons (new class) ()) '(make!) operands))
d1050 6
a1055 6
	       (eval `(lambda args
			(apply send
			       (cons (elm-get (car args)
					      (quote ,elm-name))
				     (cons (quote ,method-name)
					   (cdr args))))))))
d1067 6
a1072 6
	       (eval `(lambda args
			(apply send
			       (cons (elm-get (car args)
					      (quote ,elm-name))
				     (cons (quote ,method-name)
					   (cdr args))))))))
d1233 1
a1233 1
  (set! -class-list ())
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
