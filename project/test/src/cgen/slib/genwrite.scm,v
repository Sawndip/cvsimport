head	1.1;
branch	1.1.1;
access;
symbols
	sid-snapshot-20180601:1.1.1.1
	cgen-snapshot-20180601:1.1.1.1
	sid-snapshot-20180501:1.1.1.1
	cgen-snapshot-20180501:1.1.1.1
	sid-snapshot-20180401:1.1.1.1
	cgen-snapshot-20180401:1.1.1.1
	sid-snapshot-20180301:1.1.1.1
	cgen-snapshot-20180301:1.1.1.1
	sid-snapshot-20180201:1.1.1.1
	cgen-snapshot-20180201:1.1.1.1
	sid-snapshot-20180101:1.1.1.1
	cgen-snapshot-20180101:1.1.1.1
	sid-snapshot-20171201:1.1.1.1
	cgen-snapshot-20171201:1.1.1.1
	sid-snapshot-20171101:1.1.1.1
	cgen-snapshot-20171101:1.1.1.1
	sid-snapshot-20171001:1.1.1.1
	cgen-snapshot-20171001:1.1.1.1
	sid-snapshot-20170901:1.1.1.1
	cgen-snapshot-20170901:1.1.1.1
	sid-snapshot-20170801:1.1.1.1
	cgen-snapshot-20170801:1.1.1.1
	sid-snapshot-20170701:1.1.1.1
	cgen-snapshot-20170701:1.1.1.1
	sid-snapshot-20170601:1.1.1.1
	cgen-snapshot-20170601:1.1.1.1
	sid-snapshot-20170501:1.1.1.1
	cgen-snapshot-20170501:1.1.1.1
	sid-snapshot-20170401:1.1.1.1
	cgen-snapshot-20170401:1.1.1.1
	sid-snapshot-20170301:1.1.1.1
	cgen-snapshot-20170301:1.1.1.1
	sid-snapshot-20170201:1.1.1.1
	cgen-snapshot-20170201:1.1.1.1
	sid-snapshot-20170101:1.1.1.1
	cgen-snapshot-20170101:1.1.1.1
	sid-snapshot-20161201:1.1.1.1
	cgen-snapshot-20161201:1.1.1.1
	sid-snapshot-20161101:1.1.1.1
	cgen-snapshot-20161101:1.1.1.1
	sid-snapshot-20160901:1.1.1.1
	cgen-snapshot-20160901:1.1.1.1
	sid-snapshot-20160801:1.1.1.1
	cgen-snapshot-20160801:1.1.1.1
	sid-snapshot-20160701:1.1.1.1
	cgen-snapshot-20160701:1.1.1.1
	sid-snapshot-20160601:1.1.1.1
	cgen-snapshot-20160601:1.1.1.1
	sid-snapshot-20160501:1.1.1.1
	cgen-snapshot-20160501:1.1.1.1
	sid-snapshot-20160401:1.1.1.1
	cgen-snapshot-20160401:1.1.1.1
	sid-snapshot-20160301:1.1.1.1
	cgen-snapshot-20160301:1.1.1.1
	sid-snapshot-20160201:1.1.1.1
	cgen-snapshot-20160201:1.1.1.1
	sid-snapshot-20160101:1.1.1.1
	cgen-snapshot-20160101:1.1.1.1
	sid-snapshot-20151201:1.1.1.1
	cgen-snapshot-20151201:1.1.1.1
	sid-snapshot-20151101:1.1.1.1
	cgen-snapshot-20151101:1.1.1.1
	sid-snapshot-20151001:1.1.1.1
	cgen-snapshot-20151001:1.1.1.1
	sid-snapshot-20150901:1.1.1.1
	cgen-snapshot-20150901:1.1.1.1
	sid-snapshot-20150801:1.1.1.1
	cgen-snapshot-20150801:1.1.1.1
	sid-snapshot-20150701:1.1.1.1
	cgen-snapshot-20150701:1.1.1.1
	sid-snapshot-20150601:1.1.1.1
	cgen-snapshot-20150601:1.1.1.1
	sid-snapshot-20150501:1.1.1.1
	cgen-snapshot-20150501:1.1.1.1
	sid-snapshot-20150401:1.1.1.1
	cgen-snapshot-20150401:1.1.1.1
	sid-snapshot-20150301:1.1.1.1
	cgen-snapshot-20150301:1.1.1.1
	sid-snapshot-20150201:1.1.1.1
	cgen-snapshot-20150201:1.1.1.1
	sid-snapshot-20150101:1.1.1.1
	cgen-snapshot-20150101:1.1.1.1
	sid-snapshot-20141201:1.1.1.1
	cgen-snapshot-20141201:1.1.1.1
	sid-snapshot-20141101:1.1.1.1
	cgen-snapshot-20141101:1.1.1.1
	sid-snapshot-20141001:1.1.1.1
	cgen-snapshot-20141001:1.1.1.1
	sid-snapshot-20140901:1.1.1.1
	cgen-snapshot-20140901:1.1.1.1
	sid-snapshot-20140801:1.1.1.1
	cgen-snapshot-20140801:1.1.1.1
	sid-snapshot-20140701:1.1.1.1
	cgen-snapshot-20140701:1.1.1.1
	sid-snapshot-20140601:1.1.1.1
	cgen-snapshot-20140601:1.1.1.1
	sid-snapshot-20140501:1.1.1.1
	cgen-snapshot-20140501:1.1.1.1
	sid-snapshot-20140401:1.1.1.1
	cgen-snapshot-20140401:1.1.1.1
	sid-snapshot-20140301:1.1.1.1
	cgen-snapshot-20140301:1.1.1.1
	sid-snapshot-20140201:1.1.1.1
	cgen-snapshot-20140201:1.1.1.1
	sid-snapshot-20140101:1.1.1.1
	cgen-snapshot-20140101:1.1.1.1
	sid-snapshot-20131201:1.1.1.1
	cgen-snapshot-20131201:1.1.1.1
	sid-snapshot-20131101:1.1.1.1
	cgen-snapshot-20131101:1.1.1.1
	sid-snapshot-20131001:1.1.1.1
	cgen-snapshot-20131001:1.1.1.1
	sid-snapshot-20130901:1.1.1.1
	cgen-snapshot-20130901:1.1.1.1
	sid-snapshot-20130801:1.1.1.1
	cgen-snapshot-20130801:1.1.1.1
	sid-snapshot-20130701:1.1.1.1
	cgen-snapshot-20130701:1.1.1.1
	sid-snapshot-20130601:1.1.1.1
	cgen-snapshot-20130601:1.1.1.1
	sid-snapshot-20130501:1.1.1.1
	cgen-snapshot-20130501:1.1.1.1
	sid-snapshot-20130401:1.1.1.1
	cgen-snapshot-20130401:1.1.1.1
	sid-snapshot-20130301:1.1.1.1
	cgen-snapshot-20130301:1.1.1.1
	sid-snapshot-20130201:1.1.1.1
	cgen-snapshot-20130201:1.1.1.1
	sid-snapshot-20130101:1.1.1.1
	cgen-snapshot-20130101:1.1.1.1
	sid-snapshot-20121201:1.1.1.1
	cgen-snapshot-20121201:1.1.1.1
	sid-snapshot-20121101:1.1.1.1
	cgen-snapshot-20121101:1.1.1.1
	sid-snapshot-20121001:1.1.1.1
	cgen-snapshot-20121001:1.1.1.1
	sid-snapshot-20120901:1.1.1.1
	cgen-snapshot-20120901:1.1.1.1
	sid-snapshot-20120801:1.1.1.1
	cgen-snapshot-20120801:1.1.1.1
	sid-snapshot-20120701:1.1.1.1
	cgen-snapshot-20120701:1.1.1.1
	sid-snapshot-20120601:1.1.1.1
	cgen-snapshot-20120601:1.1.1.1
	sid-snapshot-20120501:1.1.1.1
	cgen-snapshot-20120501:1.1.1.1
	sid-snapshot-20120401:1.1.1.1
	cgen-snapshot-20120401:1.1.1.1
	sid-snapshot-20120301:1.1.1.1
	cgen-snapshot-20120301:1.1.1.1
	sid-snapshot-20120201:1.1.1.1
	cgen-snapshot-20120201:1.1.1.1
	sid-snapshot-20120101:1.1.1.1
	cgen-snapshot-20120101:1.1.1.1
	sid-snapshot-20111201:1.1.1.1
	cgen-snapshot-20111201:1.1.1.1
	sid-snapshot-20111101:1.1.1.1
	cgen-snapshot-20111101:1.1.1.1
	sid-snapshot-20111001:1.1.1.1
	cgen-snapshot-20111001:1.1.1.1
	sid-snapshot-20110901:1.1.1.1
	cgen-snapshot-20110901:1.1.1.1
	sid-snapshot-20110801:1.1.1.1
	cgen-snapshot-20110801:1.1.1.1
	sid-snapshot-20110701:1.1.1.1
	cgen-snapshot-20110701:1.1.1.1
	sid-snapshot-20110601:1.1.1.1
	cgen-snapshot-20110601:1.1.1.1
	sid-snapshot-20110501:1.1.1.1
	cgen-snapshot-20110501:1.1.1.1
	sid-snapshot-20110401:1.1.1.1
	cgen-snapshot-20110401:1.1.1.1
	sid-snapshot-20110301:1.1.1.1
	cgen-snapshot-20110301:1.1.1.1
	sid-snapshot-20110201:1.1.1.1
	cgen-snapshot-20110201:1.1.1.1
	sid-snapshot-20110101:1.1.1.1
	cgen-snapshot-20110101:1.1.1.1
	sid-snapshot-20101201:1.1.1.1
	cgen-snapshot-20101201:1.1.1.1
	sid-snapshot-20101101:1.1.1.1
	cgen-snapshot-20101101:1.1.1.1
	sid-snapshot-20101001:1.1.1.1
	cgen-snapshot-20101001:1.1.1.1
	sid-snapshot-20100901:1.1.1.1
	cgen-snapshot-20100901:1.1.1.1
	sid-snapshot-20100801:1.1.1.1
	cgen-snapshot-20100801:1.1.1.1
	sid-snapshot-20100701:1.1.1.1
	cgen-snapshot-20100701:1.1.1.1
	sid-snapshot-20100601:1.1.1.1
	cgen-snapshot-20100601:1.1.1.1
	sid-snapshot-20100501:1.1.1.1
	cgen-snapshot-20100501:1.1.1.1
	sid-snapshot-20100401:1.1.1.1
	cgen-snapshot-20100401:1.1.1.1
	sid-snapshot-20100301:1.1.1.1
	cgen-snapshot-20100301:1.1.1.1
	sid-snapshot-20100201:1.1.1.1
	cgen-snapshot-20100201:1.1.1.1
	sid-snapshot-20100101:1.1.1.1
	cgen-snapshot-20100101:1.1.1.1
	sid-snapshot-20091201:1.1.1.1
	cgen-snapshot-20091201:1.1.1.1
	sid-snapshot-20091101:1.1.1.1
	cgen-snapshot-20091101:1.1.1.1
	sid-snapshot-20091001:1.1.1.1
	cgen-snapshot-20091001:1.1.1.1
	arc-sim-20090309:1.1.1.1
	sid-snapshot-20090901:1.1.1.1
	cgen-snapshot-20090901:1.1.1.1
	sid-snapshot-20090801:1.1.1.1
	cgen-snapshot-20090801:1.1.1.1
	sid-snapshot-20090701:1.1.1.1
	cgen-snapshot-20090701:1.1.1.1
	dje-cgen-play1-branch:1.1.1.1.0.14
	dje-cgen-play1-branchpoint:1.1.1.1
	cgen-1_1-branch:1.1.1.1.0.12
	cgen-1_1-branchpoint:1.1.1.1
	sid-snapshot-20090601:1.1.1.1
	cgen-snapshot-20090601:1.1.1.1
	sid-snapshot-20090501:1.1.1.1
	cgen-snapshot-20090501:1.1.1.1
	sid-snapshot-20090401:1.1.1.1
	cgen-snapshot-20090401:1.1.1.1
	arc-insight_6_8-branch:1.1.1.1.0.10
	arc-insight_6_8-branchpoint:1.1.1.1
	sid-snapshot-20090301:1.1.1.1
	cgen-snapshot-20090301:1.1.1.1
	sid-snapshot-20090201:1.1.1.1
	cgen-snapshot-20090201:1.1.1.1
	sid-snapshot-20090101:1.1.1.1
	cgen-snapshot-20090101:1.1.1.1
	sid-snapshot-20081201:1.1.1.1
	cgen-snapshot-20081201:1.1.1.1
	sid-snapshot-20081101:1.1.1.1
	cgen-snapshot-20081101:1.1.1.1
	sid-snapshot-20081001:1.1.1.1
	cgen-snapshot-20081001:1.1.1.1
	sid-snapshot-20080901:1.1.1.1
	cgen-snapshot-20080901:1.1.1.1
	sid-snapshot-20080801:1.1.1.1
	cgen-snapshot-20080801:1.1.1.1
	sid-snapshot-20080701:1.1.1.1
	cgen-snapshot-20080701:1.1.1.1
	sid-snapshot-20080601:1.1.1.1
	cgen-snapshot-20080601:1.1.1.1
	sid-snapshot-20080501:1.1.1.1
	cgen-snapshot-20080501:1.1.1.1
	sid-snapshot-20080403:1.1.1.1
	sid-snapshot-20080401:1.1.1.1
	cgen-snapshot-20080401:1.1.1.1
	sid-snapshot-20080301:1.1.1.1
	cgen-snapshot-20080301:1.1.1.1
	sid-snapshot-20080201:1.1.1.1
	cgen-snapshot-20080201:1.1.1.1
	sid-snapshot-20080101:1.1.1.1
	cgen-snapshot-20080101:1.1.1.1
	sid-snapshot-20071201:1.1.1.1
	cgen-snapshot-20071201:1.1.1.1
	sid-snapshot-20071101:1.1.1.1
	cgen-snapshot-20071101:1.1.1.1
	sid-snapshot-20071001:1.1.1.1
	cgen-snapshot-20071001:1.1.1.1
	msnyder-fork-checkpoint-branch:1.1.1.1.0.8
	msnyder-fork-checkpoint-branchpoint:1.1.1.1
	sid-20020905-branchpoint:1.1.1.1
	sid-20020905-branch:1.1.1.1.0.6
	cagney_regbuf-20020515-branch:1.1.1.1.0.4
	cagney_regbuf-20020515-branchpoint:1.1.1.1
	cygnus_cvs_20020108_pre:1.1.1.1
	cgen-1-1-branch:1.1.1.1.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2000.07.28.04.11.53;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.07.28.04.11.53;	author bje;	state Exp;
branches;
next	;


desc
@@



1.1
log
@Initial revision
@
text
@;;"genwrite.scm" generic write used by pretty-print and truncated-print.
;; Copyright (c) 1991, Marc Feeley
;; Author: Marc Feeley (feeley@@iro.umontreal.ca)
;; Distribution restrictions: none

(define (generic-write obj display? width output)

  (define (read-macro? l)
    (define (length1? l) (and (pair? l) (null? (cdr l))))
    (let ((head (car l)) (tail (cdr l)))
      (case head
        ((QUOTE QUASIQUOTE UNQUOTE UNQUOTE-SPLICING) (length1? tail))
        (else                                        #f))))

  (define (read-macro-body l)
    (cadr l))

  (define (read-macro-prefix l)
    (let ((head (car l)) (tail (cdr l)))
      (case head
        ((QUOTE)            "'")
        ((QUASIQUOTE)       "`")
        ((UNQUOTE)          ",")
        ((UNQUOTE-SPLICING) ",@@"))))

  (define (out str col)
    (and col (output str) (+ col (string-length str))))

  (define (wr obj col)

    (define (wr-expr expr col)
      (if (read-macro? expr)
        (wr (read-macro-body expr) (out (read-macro-prefix expr) col))
        (wr-lst expr col)))

    (define (wr-lst l col)
      (if (pair? l)
	  (let loop ((l (cdr l))
		     (col (and col (wr (car l) (out "(" col)))))
	    (cond ((not col) col)
		  ((pair? l)
		   (loop (cdr l) (wr (car l) (out " " col))))
		  ((null? l) (out ")" col))
		  (else      (out ")" (wr l (out " . " col))))))
	  (out "()" col)))

    (cond ((pair? obj)        (wr-expr obj col))
          ((null? obj)        (wr-lst obj col))
          ((vector? obj)      (wr-lst (vector->list obj) (out "#" col)))
          ((boolean? obj)     (out (if obj "#t" "#f") col))
          ((number? obj)      (out (number->string obj) col))
          ((symbol? obj)      (out (symbol->string obj) col))
          ((procedure? obj)   (out "#[procedure]" col))
          ((string? obj)      (if display?
                                (out obj col)
                                (let loop ((i 0) (j 0) (col (out "\"" col)))
                                  (if (and col (< j (string-length obj)))
                                    (let ((c (string-ref obj j)))
                                      (if (or (char=? c #\\)
                                              (char=? c #\"))
                                        (loop j
                                              (+ j 1)
                                              (out "\\"
                                                   (out (substring obj i j)
                                                        col)))
                                        (loop i (+ j 1) col)))
                                    (out "\""
                                         (out (substring obj i j) col))))))
          ((char? obj)        (if display?
                                (out (make-string 1 obj) col)
                                (out (case obj
                                       ((#\space)   "space")
                                       ((#\newline) "newline")
                                       (else        (make-string 1 obj)))
                                     (out "#\\" col))))
          ((input-port? obj)  (out "#[input-port]" col))
          ((output-port? obj) (out "#[output-port]" col))
          ((eof-object? obj)  (out "#[eof-object]" col))
          ((keyword? obj)  (let* ((o (symbol->string 
                                        (keyword-dash-symbol obj)))
                                  (oo (list->string 
                                       (append (list #\# #\:)
                                               (cdr (string->list o))))))
                                (out oo col)))
          (else               (out "#[unknown]" col))))

  (define (pp obj col)

    (define (spaces n col)
      (if (> n 0)
        (if (> n 7)
          (spaces (- n 8) (out "        " col))
          (out (substring "        " 0 n) col))
        col))

    (define (indent to col)
      (and col
           (if (< to col)
             (and (out (make-string 1 #\newline) col) (spaces to 0))
             (spaces (- to col) col))))

    (define (pr obj col extra pp-pair)
      (if (or (pair? obj) (vector? obj)) ; may have to split on multiple lines
        (let ((result '())
              (left (min (+ (- (- width col) extra) 1) max-expr-width)))
          (generic-write obj display? #f
            (lambda (str)
              (set! result (cons str result))
              (set! left (- left (string-length str)))
              (> left 0)))
          (if (> left 0) ; all can be printed on one line
            (out (reverse-string-append result) col)
            (if (pair? obj)
              (pp-pair obj col extra)
              (pp-list (vector->list obj) (out "#" col) extra pp-expr))))
        (wr obj col)))

    (define (pp-expr expr col extra)
      (if (read-macro? expr)
        (pr (read-macro-body expr)
            (out (read-macro-prefix expr) col)
            extra
            pp-expr)
        (let ((head (car expr)))
          (if (symbol? head)
            (let ((proc (style head)))
              (if proc
                (proc expr col extra)
                (if (> (string-length (symbol->string head))
                       max-call-head-width)
                  (pp-general expr col extra #f #f #f pp-expr)
                  (pp-call expr col extra pp-expr))))
            (pp-list expr col extra pp-expr)))))

    ; (head item1
    ;       item2
    ;       item3)
    (define (pp-call expr col extra pp-item)
      (let ((col* (wr (car expr) (out "(" col))))
        (and col
             (pp-down (cdr expr) col* (+ col* 1) extra pp-item))))

    ; (item1
    ;  item2
    ;  item3)
    (define (pp-list l col extra pp-item)
      (let ((col (out "(" col)))
        (pp-down l col col extra pp-item)))

    (define (pp-down l col1 col2 extra pp-item)
      (let loop ((l l) (col col1))
        (and col
             (cond ((pair? l)
                    (let ((rest (cdr l)))
                      (let ((extra (if (null? rest) (+ extra 1) 0)))
                        (loop rest
                              (pr (car l) (indent col2 col) extra pp-item)))))
                   ((null? l)
                    (out ")" col))
                   (else
                    (out ")"
                         (pr l
                             (indent col2 (out "." (indent col2 col)))
                             (+ extra 1)
                             pp-item)))))))

    (define (pp-general expr col extra named? pp-1 pp-2 pp-3)

      (define (tail1 rest col1 col2 col3)
        (if (and pp-1 (pair? rest))
          (let* ((val1 (car rest))
                 (rest (cdr rest))
                 (extra (if (null? rest) (+ extra 1) 0)))
            (tail2 rest col1 (pr val1 (indent col3 col2) extra pp-1) col3))
          (tail2 rest col1 col2 col3)))

      (define (tail2 rest col1 col2 col3)
        (if (and pp-2 (pair? rest))
          (let* ((val1 (car rest))
                 (rest (cdr rest))
                 (extra (if (null? rest) (+ extra 1) 0)))
            (tail3 rest col1 (pr val1 (indent col3 col2) extra pp-2)))
          (tail3 rest col1 col2)))

      (define (tail3 rest col1 col2)
        (pp-down rest col2 col1 extra pp-3))

      (let* ((head (car expr))
             (rest (cdr expr))
             (col* (wr head (out "(" col))))
        (if (and named? (pair? rest))
          (let* ((name (car rest))
                 (rest (cdr rest))
                 (col** (wr name (out " " col*))))
            (tail1 rest (+ col indent-general) col** (+ col** 1)))
          (tail1 rest (+ col indent-general) col* (+ col* 1)))))

    (define (pp-expr-list l col extra)
      (pp-list l col extra pp-expr))

    (define (pp-LAMBDA expr col extra)
      (pp-general expr col extra #f pp-expr-list #f pp-expr))

    (define (pp-IF expr col extra)
      (pp-general expr col extra #f pp-expr #f pp-expr))

    (define (pp-COND expr col extra)
      (pp-call expr col extra pp-expr-list))

    (define (pp-CASE expr col extra)
      (pp-general expr col extra #f pp-expr #f pp-expr-list))

    (define (pp-AND expr col extra)
      (pp-call expr col extra pp-expr))

    (define (pp-LET expr col extra)
      (let* ((rest (cdr expr))
             (named? (and (pair? rest) (symbol? (car rest)))))
        (pp-general expr col extra named? pp-expr-list #f pp-expr)))

    (define (pp-BEGIN expr col extra)
      (pp-general expr col extra #f #f #f pp-expr))

    (define (pp-DO expr col extra)
      (pp-general expr col extra #f pp-expr-list pp-expr-list pp-expr))

    ; define formatting style (change these to suit your style)

    (define indent-general 2)

    (define max-call-head-width 5)

    (define max-expr-width 50)

    (define (style head)
      (case head
        ((LAMBDA LET* LETREC DEFINE) pp-LAMBDA)
        ((IF SET!)                   pp-IF)
        ((COND)                      pp-COND)
        ((CASE)                      pp-CASE)
        ((AND OR)                    pp-AND)
        ((LET)                       pp-LET)
        ((BEGIN)                     pp-BEGIN)
        ((DO)                        pp-DO)
        (else                        #f)))

    (pr obj col 0 pp-expr))

  (if width
    (out (make-string 1 #\newline) (pp obj 0))
    (wr obj 0)))

; (reverse-string-append l) = (apply string-append (reverse l))

(define (reverse-string-append l)

  (define (rev-string-append l i)
    (if (pair? l)
      (let* ((str (car l))
             (len (string-length str))
             (result (rev-string-append (cdr l) (+ i len))))
        (let loop ((j 0) (k (- (- (string-length result) i) len)))
          (if (< j len)
            (begin
              (string-set! result k (string-ref str j))
              (loop (+ j 1) (+ k 1)))
            result)))
      (make-string i)))

  (rev-string-append l 0))
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
