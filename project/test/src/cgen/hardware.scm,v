head	1.15;
access;
symbols
	sid-snapshot-20180601:1.15
	cgen-snapshot-20180601:1.15
	sid-snapshot-20180501:1.15
	cgen-snapshot-20180501:1.15
	sid-snapshot-20180401:1.15
	cgen-snapshot-20180401:1.15
	sid-snapshot-20180301:1.15
	cgen-snapshot-20180301:1.15
	sid-snapshot-20180201:1.15
	cgen-snapshot-20180201:1.15
	sid-snapshot-20180101:1.15
	cgen-snapshot-20180101:1.15
	sid-snapshot-20171201:1.15
	cgen-snapshot-20171201:1.15
	sid-snapshot-20171101:1.15
	cgen-snapshot-20171101:1.15
	sid-snapshot-20171001:1.15
	cgen-snapshot-20171001:1.15
	sid-snapshot-20170901:1.15
	cgen-snapshot-20170901:1.15
	sid-snapshot-20170801:1.15
	cgen-snapshot-20170801:1.15
	sid-snapshot-20170701:1.15
	cgen-snapshot-20170701:1.15
	sid-snapshot-20170601:1.15
	cgen-snapshot-20170601:1.15
	sid-snapshot-20170501:1.15
	cgen-snapshot-20170501:1.15
	sid-snapshot-20170401:1.15
	cgen-snapshot-20170401:1.15
	sid-snapshot-20170301:1.15
	cgen-snapshot-20170301:1.15
	sid-snapshot-20170201:1.15
	cgen-snapshot-20170201:1.15
	sid-snapshot-20170101:1.15
	cgen-snapshot-20170101:1.15
	sid-snapshot-20161201:1.15
	cgen-snapshot-20161201:1.15
	sid-snapshot-20161101:1.15
	cgen-snapshot-20161101:1.15
	sid-snapshot-20160901:1.15
	cgen-snapshot-20160901:1.15
	sid-snapshot-20160801:1.15
	cgen-snapshot-20160801:1.15
	sid-snapshot-20160701:1.15
	cgen-snapshot-20160701:1.15
	sid-snapshot-20160601:1.15
	cgen-snapshot-20160601:1.15
	sid-snapshot-20160501:1.15
	cgen-snapshot-20160501:1.15
	sid-snapshot-20160401:1.15
	cgen-snapshot-20160401:1.15
	sid-snapshot-20160301:1.15
	cgen-snapshot-20160301:1.15
	sid-snapshot-20160201:1.15
	cgen-snapshot-20160201:1.15
	sid-snapshot-20160101:1.15
	cgen-snapshot-20160101:1.15
	sid-snapshot-20151201:1.15
	cgen-snapshot-20151201:1.15
	sid-snapshot-20151101:1.15
	cgen-snapshot-20151101:1.15
	sid-snapshot-20151001:1.15
	cgen-snapshot-20151001:1.15
	sid-snapshot-20150901:1.15
	cgen-snapshot-20150901:1.15
	sid-snapshot-20150801:1.15
	cgen-snapshot-20150801:1.15
	sid-snapshot-20150701:1.15
	cgen-snapshot-20150701:1.15
	sid-snapshot-20150601:1.15
	cgen-snapshot-20150601:1.15
	sid-snapshot-20150501:1.15
	cgen-snapshot-20150501:1.15
	sid-snapshot-20150401:1.15
	cgen-snapshot-20150401:1.15
	sid-snapshot-20150301:1.15
	cgen-snapshot-20150301:1.15
	sid-snapshot-20150201:1.15
	cgen-snapshot-20150201:1.15
	sid-snapshot-20150101:1.15
	cgen-snapshot-20150101:1.15
	sid-snapshot-20141201:1.15
	cgen-snapshot-20141201:1.15
	sid-snapshot-20141101:1.15
	cgen-snapshot-20141101:1.15
	sid-snapshot-20141001:1.15
	cgen-snapshot-20141001:1.15
	sid-snapshot-20140901:1.15
	cgen-snapshot-20140901:1.15
	sid-snapshot-20140801:1.15
	cgen-snapshot-20140801:1.15
	sid-snapshot-20140701:1.15
	cgen-snapshot-20140701:1.15
	sid-snapshot-20140601:1.15
	cgen-snapshot-20140601:1.15
	sid-snapshot-20140501:1.15
	cgen-snapshot-20140501:1.15
	sid-snapshot-20140401:1.15
	cgen-snapshot-20140401:1.15
	sid-snapshot-20140301:1.15
	cgen-snapshot-20140301:1.15
	sid-snapshot-20140201:1.15
	cgen-snapshot-20140201:1.15
	sid-snapshot-20140101:1.15
	cgen-snapshot-20140101:1.15
	sid-snapshot-20131201:1.15
	cgen-snapshot-20131201:1.15
	sid-snapshot-20131101:1.15
	cgen-snapshot-20131101:1.15
	sid-snapshot-20131001:1.15
	cgen-snapshot-20131001:1.15
	sid-snapshot-20130901:1.15
	cgen-snapshot-20130901:1.15
	sid-snapshot-20130801:1.15
	cgen-snapshot-20130801:1.15
	sid-snapshot-20130701:1.15
	cgen-snapshot-20130701:1.15
	sid-snapshot-20130601:1.15
	cgen-snapshot-20130601:1.15
	sid-snapshot-20130501:1.15
	cgen-snapshot-20130501:1.15
	sid-snapshot-20130401:1.15
	cgen-snapshot-20130401:1.15
	sid-snapshot-20130301:1.15
	cgen-snapshot-20130301:1.15
	sid-snapshot-20130201:1.15
	cgen-snapshot-20130201:1.15
	sid-snapshot-20130101:1.15
	cgen-snapshot-20130101:1.15
	sid-snapshot-20121201:1.15
	cgen-snapshot-20121201:1.15
	sid-snapshot-20121101:1.15
	cgen-snapshot-20121101:1.15
	sid-snapshot-20121001:1.15
	cgen-snapshot-20121001:1.15
	sid-snapshot-20120901:1.15
	cgen-snapshot-20120901:1.15
	sid-snapshot-20120801:1.15
	cgen-snapshot-20120801:1.15
	sid-snapshot-20120701:1.15
	cgen-snapshot-20120701:1.15
	sid-snapshot-20120601:1.15
	cgen-snapshot-20120601:1.15
	sid-snapshot-20120501:1.15
	cgen-snapshot-20120501:1.15
	sid-snapshot-20120401:1.15
	cgen-snapshot-20120401:1.15
	sid-snapshot-20120301:1.15
	cgen-snapshot-20120301:1.15
	sid-snapshot-20120201:1.15
	cgen-snapshot-20120201:1.15
	sid-snapshot-20120101:1.15
	cgen-snapshot-20120101:1.15
	sid-snapshot-20111201:1.15
	cgen-snapshot-20111201:1.15
	sid-snapshot-20111101:1.15
	cgen-snapshot-20111101:1.15
	sid-snapshot-20111001:1.15
	cgen-snapshot-20111001:1.15
	sid-snapshot-20110901:1.15
	cgen-snapshot-20110901:1.15
	sid-snapshot-20110801:1.15
	cgen-snapshot-20110801:1.15
	sid-snapshot-20110701:1.15
	cgen-snapshot-20110701:1.15
	sid-snapshot-20110601:1.15
	cgen-snapshot-20110601:1.15
	sid-snapshot-20110501:1.15
	cgen-snapshot-20110501:1.15
	sid-snapshot-20110401:1.15
	cgen-snapshot-20110401:1.15
	sid-snapshot-20110301:1.15
	cgen-snapshot-20110301:1.15
	sid-snapshot-20110201:1.15
	cgen-snapshot-20110201:1.15
	sid-snapshot-20110101:1.15
	cgen-snapshot-20110101:1.15
	sid-snapshot-20101201:1.15
	cgen-snapshot-20101201:1.15
	sid-snapshot-20101101:1.15
	cgen-snapshot-20101101:1.15
	sid-snapshot-20101001:1.15
	cgen-snapshot-20101001:1.15
	sid-snapshot-20100901:1.15
	cgen-snapshot-20100901:1.15
	sid-snapshot-20100801:1.15
	cgen-snapshot-20100801:1.15
	sid-snapshot-20100701:1.15
	cgen-snapshot-20100701:1.15
	sid-snapshot-20100601:1.15
	cgen-snapshot-20100601:1.15
	sid-snapshot-20100501:1.15
	cgen-snapshot-20100501:1.15
	sid-snapshot-20100401:1.15
	cgen-snapshot-20100401:1.15
	sid-snapshot-20100301:1.15
	cgen-snapshot-20100301:1.15
	sid-snapshot-20100201:1.15
	cgen-snapshot-20100201:1.15
	sid-snapshot-20100101:1.15
	cgen-snapshot-20100101:1.15
	sid-snapshot-20091201:1.15
	cgen-snapshot-20091201:1.15
	sid-snapshot-20091101:1.14
	cgen-snapshot-20091101:1.14
	sid-snapshot-20091001:1.13
	cgen-snapshot-20091001:1.13
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.10
	cgen-snapshot-20090901:1.10
	sid-snapshot-20090801:1.7
	cgen-snapshot-20090801:1.7
	sid-snapshot-20090701:1.6
	cgen-snapshot-20090701:1.6
	dje-cgen-play1-branch:1.6.0.2
	dje-cgen-play1-branchpoint:1.6
	cgen-1_1-branch:1.5.0.4
	cgen-1_1-branchpoint:1.5
	sid-snapshot-20090601:1.5
	cgen-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	cgen-snapshot-20090501:1.5
	sid-snapshot-20090401:1.5
	cgen-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.2
	arc-insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	cgen-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	cgen-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	cgen-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	cgen-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	cgen-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	cgen-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	cgen-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	cgen-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	cgen-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	cgen-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	cgen-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	cgen-snapshot-20080401:1.5
	sid-snapshot-20080301:1.5
	cgen-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	cgen-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	cgen-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	cgen-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	cgen-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	cgen-snapshot-20071001:1.5
	msnyder-fork-checkpoint-branch:1.4.0.2
	msnyder-fork-checkpoint-branchpoint:1.4
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	cygnus_cvs_20020108_pre:1.2
	cgen-1-1-branch:1.2.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.15
date	2009.11.23.09.03.00;	author devans;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.26.00.56.34;	author devans;	state Exp;
branches;
next	1.13;

1.13
date	2009.09.22.17.44.01;	author devans;	state Exp;
branches;
next	1.12;

1.12
date	2009.09.12.17.34.15;	author devans;	state Exp;
branches;
next	1.11;

1.11
date	2009.09.07.22.17.33;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2009.08.29.18.31.58;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2009.08.24.06.46.16;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2009.08.12.22.33.37;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.18.20.44.58;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches;
next	1.5;

1.5
date	2006.07.14.18.49.32;	author brolley;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2003.07.16.05.35.47;	author devans;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.04.20.22.49;	author devans;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.24.15.35.47;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.5.4.1
date	2009.06.24.14.57.45;	author devans;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.15
log
@	* hardware.scm (hw-pc?): New function.
	* ifield.scm (ifld-signed?): New function.
	* iformat.scm (ifmt-analyze): Call insn-cti-attr? instead of insn-cti?.
	* insn.scm (insn-cti-attr?): Renamed from insn-ctl?.
	(insn-cti?): New function.
	* rtl.scm (/hw): Create <pc> object for pcs.
	* semantics.scm (/build-reg-operand!): New args ref-type, sem-attrs.
	All callers updated.  Watch for sets to the pc.
	(semantic-attrs): Watch for sets to the pc.
	* sid.scm (<pc> cxmake-get): Handle raw-reg.
	* sim.scm (<pc> cxmake-get): Handle raw-reg.
	(<operand> cxmake-get): Add debugging printf.
	* utils-gen.scm (/gen-ifld-extract-base): Emit calls to
	EXTRACT_[LM]SB0_LG[SU]INT for values > 32 bits.
	(/gen-extract-word): Ditto.

	* utils.scm (gen-c-hex-constant): New function.
	* utils-sim.scm (/gen-decode-insn-entry): Call it.
@
text
@; Hardware descriptions.
; Copyright (C) 2000, 2009 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.

; This is the base class for all hardware descriptions.
; The actual hardware objects inherit from this (e.g. register, immediate).
; This is used to describe registers, memory, and immediates.
; ??? Maybe other things as well, but this is all that's needed at present.
; ??? Eventually rename to <hardware> but not yet.

(define <hardware-base>
  (class-make '<hardware-base>
	      '(<ident>)
	      '(
		; Name used in semantics.
		; This is for cases where a particular hardware element is
		; sufficiently different on different mach's of an architecture
		; that it is defined separately for each case.  The semantics
		; refer to this name (which means that one must use a different
		; mechanism if one wants both machs in the same semantic code).
		sem-name

		; The type, an object of class <array>.
		; (mode + scalar or vector length)
		type

		; Indexing support.
		; An object of class <hw-asm>, or a subclass of it, or
		; #f if there is no special indexing support.
		; For register banks, a table of register names.
		; ??? Same class as VALUES.
		; ??? There are currently no descriptions that require both an
		; INDICES and a VALUES specification.  It might make sense to
		; combine them (which is how things used to be), but it is odd
		; to have them combined.
		(indices . #f)

		; Table of values.
		; An object of class <hw-asm>, or a subclass of it, or
		; #f if there is no special values support.
		; For immediates with special names, a table of names.
		; ??? Same class as INDICES.
		(values . #f)

		; Associative list of (symbol . "handler") entries.
		; Each entry maps an operation to its handler (which is up to
		; the application but is generally a function name).
		(handlers . ())

		; Get/set handlers or #f to use the default.
		(get . #f)
		(set . #f)

		; Associative list of get/set handlers for each supported mode,
		; or #f to use the default.
		; ??? An interesting idea, but not sure it's the best way
		; to go.  Another way is to explicitly handle it in the insn
		; [complicates the RTL].  Another way is to handle this in
		; operand get/set handlers.  Another way is to have virtual
		; regs for each non-default mode.  Not sure which is better.
		;(getters . #f)
		;(setters . #f)

		; List of <isa> objects that use this hardware element
		; or #f if not computed yet.
		; This is a derived from the ISA attribute and is for speed.
		(isas-cache . #f)

		; Flag indicates whether this hw has been used in a (delay ...)
		; rtl expression
		(used-in-delay-rtl? . #f)
		)
	      nil)
)

; Accessors

(define-getters <hardware-base> hw
  (sem-name type indices values handlers
   ; ??? These might be more properly named hw-get/hw-set, but those names
   ; seem ambiguous.
   (get . getter) (set . setter)
   isas-cache used-in-delay-rtl?)
)

; Mode,rank,shape support.

(method-make-forward! <hardware-base> 'type '(get-mode get-rank get-shape get-num-elms))
(define (hw-mode hw) (send hw 'get-mode))
(define (hw-rank hw) (send hw 'get-rank))
(define (hw-shape hw) (send hw 'get-shape))
(define (hw-num-elms hw) (send hw 'get-num-elms))

; Return default mode to reference HW in.

(define (hw-default-mode hw)
  (hw-mode hw)
)

; Return a boolean indicating if X is a hardware object.
; ??? <hardware-base> to be renamed <hardware> in time.

(define (hardware? x) (class-instance? <hardware-base> x))

; Return #t if HW is a scalar.

(define (hw-scalar? hw) (= (hw-rank hw) 0))

; Return number of bits in an element of HW.

(define (hw-bits hw)
  (type-bits (hw-type hw))
)

; Generate the name of the enum for hardware object HW.
; This uses the semantic name, not obj:name.
; If HW is a symbol, it is already the semantic name.

(define (hw-enum hw)
  (if (symbol? hw)
      (string-upcase (string-append "HW_" (gen-c-symbol hw)))
      (string-upcase (string-append "HW_" (gen-c-symbol (hw-sem-name hw)))))
)

; Return a boolean indicating if it's ok to reference SELF in mode
; NEW-MODE-NAME, index INDEX.
; Hardware types are required to override this method.
; VOID and DFLT are never valid for NEW-MODE-NAME.

(method-make!
 <hardware-base> 'mode-ok?
 (lambda (self new-mode-name index)
   (error "mode-ok? method not overridden:" (obj:name self)))
)

(define (hw-mode-ok? hw new-mode-name index)
  (send hw 'mode-ok? new-mode-name index)
)

; Return mode to use for the index or #f if scalar.

(method-make!
 <hardware-base> 'get-index-mode
 (lambda (self)
   (error "get-index-mode method not overridden:" (obj:name self)))
)

(define (hw-index-mode hw) (send hw 'get-index-mode))

; Compute the isas used by HW and cache the results.

(method-make!
 <hardware-base> 'get-isas
 (lambda (self)
   (or (elm-get self 'isas-cache)
       (let* ((isas (obj-attr-value self 'ISA))
	      (isa-objs (if (equal? isas '(all)) (current-isa-list)
			    (map current-isa-lookup isas))))
	 (elm-set! self 'isas-cache isa-objs)
	 isa-objs)))
)

(define (hw-isas hw) (send hw 'get-isas))

; Was this hardware used in a (delay ...) rtl expression?

(method-make!
 <hardware-base> 'used-in-delay-rtl?
 (lambda (self) (elm-get self 'used-in-delay-rtl?))
)

(define (hw-used-in-delay-rtl? hw) (send hw 'used-in-delay-rtl?))

; FIXME: replace pc?,memory?,register?,iaddress? with just one method.

; Return boolean indicating if hardware element is the PC.

(method-make! <hardware-base> 'pc? (lambda (self) #f))

; Return boolean indicating if hardware element is some kind of memory.
; ??? Need to allow multiple kinds of memory and therefore need to allow
; .cpu files to specify this (i.e. an attribute).  We could use has-attr?
; here, or we could have the code that creates the object override this
; method if the MEMORY attribute is present.
; ??? Could also use a member instead of a method.

(method-make! <hardware-base> 'memory? (lambda (self) #f))
(define (memory? hw) (send hw 'memory?))

; Return boolean indicating if hardware element is some kind of register.

(method-make! <hardware-base> 'register? (lambda (self) #f))
(define (register? hw) (send hw 'register?))

; Return boolean indicating if hardware element is an address.

(method-make! <hardware-base> 'address? (lambda (self) #f))
(method-make! <hardware-base> 'iaddress? (lambda (self) #f))
(define (address? hw) (send hw 'address?))
(define (iaddress? hw) (send hw 'iaddress?))

; Assembler support.

; Baseclass.

(define <hw-asm>
  (class-make '<hw-asm> '(<ident>)
	      '(
		; The <mode> object of the mode to use.
		; A copy of the object's mode if we're in the "values"
		; member.  If we're in the "indices" member this is typically
		; UINT.
		mode
		)
	      nil)
)

; Keywords.
; Keyword lists associate a name with a number and are used for things
; like register name tables (the `indices' field of a hw spec) and
; immediate value tables (the `values' field of a hw spec).
;
; TODO: For things like the sparc fp regs, have a quasi-keyword that is
; prefix plus number.  This will save having to create a table of each
; register name.

(define <keyword>
  (class-make '<keyword> '(<hw-asm>)
	      '(
		; Prefix value to pass to the corresponding enum.
		enum-prefix

		; Prefix of each name in VALUES, as a string.
		; This is *not* prepended to each name in the enum.
		name-prefix

		; Associative list of values.
		; Each element is (name value [attrs]).
		; ??? May wish to allow calling a function to compute the
		; value at runtime.
		values
		)
	      nil)
)

; Accessors

(define-getters <keyword> kw (mode enum-prefix name-prefix values))

; Parse a keyword spec.
;
; ENUM-PREFIX is for the corresponding enum.
; The syntax of VALUES is: (prefix ((name1 [value1 [(attr-list1)]]) ...))
; NAME-PREFIX is a prefix added to each value's name in the generated
; lookup table.
; Each value is a number of mode MODE, the name of the mode.
; ??? We have no problem handling any kind of number, we're Scheme.
; However, it's not clear yet how applications will want to handle it, but
; that is left to the application.  Still, it might be preferable to impose
; some restrictions which can later be relaxed as necessary.
; ??? It would be useful to have two names for each value: asm name, enum name.

(define (/keyword-parse context name comment attrs mode enum-prefix
			name-prefix values)
  ;; Pick out name first to augment the error context.
  (let* ((name (parse-name context name))
	 (context (context-append-name context name))
	 (enum-prefix (or enum-prefix
			  (if (equal? (cgen-rtl-version) '(0 7))
			      (string-upcase (->string name))
			      (string-append ;; default to NAME-
			       (string-upcase (->string name))
			       "-")))))

    ;; FIXME: parse values.
    (let ((result (make <keyword>
		    (parse-name context name)
		    (parse-comment context comment)
		    (atlist-parse context attrs "")
		    (parse-mode-name (context-append context ": mode") mode)
		    (parse-string (context-append context ": enum-prefix")
				  enum-prefix)
		    (parse-string (context-append context ": name-prefix")
				  name-prefix)
		    values)))
      result))
)

; Read a keyword description
; This is the main routine for analyzing a keyword description in the .cpu
; file.
; CONTEXT is a <context> object for error messages.
; ARG-LIST is an associative list of field name and field value.
; /keyword-parse is invoked to create the <keyword> object.

(define (/keyword-read context . arg-list)
  (let (
	(name #f)
	(comment "")
	(attrs nil)
	(mode 'INT)
	(enum-prefix #f) ;; #f indicates "not set"
	(name-prefix "")
	(values nil)
	)

    ; Loop over each element in ARG-LIST, recording what's found.
    (let loop ((arg-list arg-list))
      (if (null? arg-list)
	  nil
	  (let ((arg (car arg-list))
		(elm-name (caar arg-list)))
	    (case elm-name
	      ((name) (set! name (cadr arg)))
	      ((comment) (set! comment (cadr arg)))
	      ((attrs) (set! attrs (cdr arg)))
	      ((mode) (set! mode (cadr arg)))
	      ((print-name)
	       ;; Renamed to enum-prefix in rtl version 0.8.
	       (if (not (equal? (cgen-rtl-version) '(0 7)))
		   (parse-error context "print-name renamed to enum-prefix" arg))
	       (set! enum-prefix (cadr arg)))
	      ((enum-prefix)
	       ;; enum-prefix added in rtl version 0.8.
	       (if (and (= (cgen-rtl-major) 0)
			(< (cgen-rtl-minor) 8))
		   (parse-error context "invalid hardware arg" arg))
	       (set! enum-prefix (cadr arg)))
	      ((prefix)
	       ;; Renamed to name-prefix in rtl version 0.8.
	       (if (not (equal? (cgen-rtl-version) '(0 7)))
		   (parse-error context "prefix renamed to name-prefix" arg))
	       (set! name-prefix (cadr arg)))
	      ((name-prefix)
	       ;; name-prefix added in rtl version 0.8.
	       (if (and (= (cgen-rtl-major) 0)
			(< (cgen-rtl-minor) 8))
		   (parse-error context "invalid hardware arg" arg))
	       (set! name-prefix (cadr arg)))
	      ((values) (set! values (cdr arg)))
	      (else (parse-error context "invalid hardware arg" arg)))
	    (loop (cdr arg-list)))))

    ; Now that we've identified the elements, build the object.
    (/keyword-parse context name comment attrs mode
		    enum-prefix name-prefix values))
)

; Define a keyword object, name/value pair list version.

(define define-keyword
  (lambda arg-list
    (let ((kw (apply /keyword-read (cons (make-current-context "define-keyword")
					 arg-list))))
      (if kw
	  (begin
	    (current-kw-add! kw)
	    ; Define an enum so the values are usable everywhere.
	    ; One use is giving names to register numbers and special constants
	    ; to make periphery C/C++ code more legible.
	    ; FIXME: Should pass on mode to enum.
	    (define-full-enum (obj:name kw) (obj:comment kw)
	      (atlist-source-form (obj-atlist kw))
	      (if (and (= (cgen-rtl-major) 0)
		       (< (cgen-rtl-minor) 8))
		  ;; Prior to rtl version 0.8 we up-cased the prefix here
		  ;; and added the trailing - ourselves.
		  (string-upcase (string-append (kw-enum-prefix kw) "-"))
		  (kw-enum-prefix kw))
	      (kw-values kw))))
      kw))
)

; Parsing support.

; List of hardware types.
; This maps names in the `type' entry of define-hardware to the class name.

(define /hardware-types
  '((register . <hw-register>)
    (pc . <hw-pc>)
    (memory . <hw-memory>)
    (immediate . <hw-immediate>)
    (address . <hw-address>)
    (iaddress . <hw-iaddress>))
)

; Parse an inline keyword spec.
; These are keywords defined inside something else.
; CONTAINER is the <ident> object of the container.
; MODE is the name of the mode.

(define (/hw-parse-keyword context args container mode)
  (if (!= (length args) 2)
      (parse-error context "invalid keyword spec" args))

  ; Name, comment, and attributes are copied from our container object.
  ; They're needed to output the table.
  ; ??? This isn't quite right as some day a container may contain multiple
  ; keyword instances.  To be fixed in time.
  (/keyword-parse context (obj:name container) (obj:comment container)
		  ;; PRIVATE: keyword table is implicitly defined, it isn't
		  ;; accessible with current-kw-lookup.
		  (cons 'PRIVATE (atlist-source-form (obj-atlist container)))
		  mode
		  ;; This is unused, use a magic value to catch any uses.
		  "UNUSED"
		  (car args) ; prefix
		  (cadr args)) ; value
)

; Parse an indices spec.
; CONTAINER is the <ident> object of the container.
; Currently there is only special support for keywords.
; Otherwise MODE is used.  MODE is the name, not a <mode> object.
; The syntax is: (keyword keyword-spec) - see <keyword> for details.

(define (/hw-parse-indices context indices container mode)
  (if (null? indices)
      (make <hw-asm>
	(obj:name container) (obj:comment container) (obj-atlist container)
	(parse-mode-name (context-append context ": mode") mode))
      (begin
	(if (not (list? indices))
	    (parse-error context "invalid indices spec" indices))
	(case (car indices)
	  ((keyword) (/hw-parse-keyword context (cdr indices) container mode))
	  ((extern-keyword) (begin
			      (if (null? (cdr indices))
				  (parse-error context "missing keyword name"
					       indices))
			      (let ((kw (current-kw-lookup (cadr indices))))
				(if (not kw)
				    (parse-error context "unknown keyword"
						 indices))
				kw)))
	  (else (parse-error context "unknown indices type" (car indices))))))
)

; Parse a values spec.
; CONTAINER is the <ident> object of the container.
; Currently there is only special support for keywords.
; Otherwise MODE is used.  MODE is the name, not a <mode> object.
; The syntax is: (keyword keyword-spec) - see <keyword> for details.

(define (/hw-parse-values context values container mode)
  (if (null? values)
      (make <hw-asm>
	(obj:name container) (obj:comment container) (obj-atlist container)
	(parse-mode-name (context-append context ": mode") mode))
      (begin
	(if (not (list? values))
	    (parse-error context "invalid values spec" values))
	(case (car values)
	  ((keyword) (/hw-parse-keyword context (cdr values) container mode))
	  ((extern-keyword) (begin
			      (if (null? (cdr values))
				  (parse-error context "missing keyword name"
					       values))
			      (let ((kw (current-kw-lookup (cadr values))))
				(if (not kw)
				    (parse-error context "unknown keyword"
						 values))
				kw)))
	  (else (parse-error context "unknown values type" (car values))))))
)

; Parse a handlers spec.
; Each element is (name "string").

(define (/hw-parse-handlers context handlers)
  (parse-handlers context '(parse print) handlers)
)

; Parse a getter spec.
; The syntax is (([index]) (expression)).
; Omit `index' for scalar objects.
; Externally they're specified as `get'.  Internally we use `getter'.

(define (/hw-parse-getter context getter scalar?)
  (if (null? getter)
      #f ; use default
      (let ((valid "((index) (expression))")
	    (scalar-valid "(() (expression))"))
	(if (or (not (list? getter))
		(!= (length getter) 2)
		(not (and (list? (car getter))
			  (= (length (car getter)) (if scalar? 0 1)))))
	    (parse-error context
			 (string-append "invalid getter, should be "
					(if scalar? scalar-valid valid))
			 getter))
	(if (not (rtx? (cadr getter)))
	    (parse-error context "invalid rtx expression" getter))
	getter))
)

; Parse a setter spec.
; The syntax is (([index] newval) (expression)).
; Omit `index' for scalar objects.
; Externally they're specified as `set'.  Internally we use `setter'.

(define (/hw-parse-setter context setter scalar?)
  (if (null? setter)
      #f ; use default
      (let ((valid "((index newval) (expression))")
	    (scalar-valid "((newval) (expression))"))
	(if (or (not (list? setter))
		(!= (length setter) 2)
		(not (and (list? (car setter))
			  (= (length (car setter)) (if scalar? 1 2)))))
	    (parse-error context
			 (string-append "invalid setter, should be "
					(if scalar? scalar-valid valid))
			 setter))
	(if (not (rtx? (cadr setter)))
	    (parse-error context "invalid rtx expression" setter))
	setter))
)

; Parse hardware description
; This is the main routine for building a hardware object from a hardware
; description in the .cpu file.
; All arguments are in raw (non-evaluated) form.
; The result is the parsed object or #f if object isn't for selected mach(s).
;
; ??? Might want to redo to handle hardware type specific specs more cleanly.
; E.g. <hw-immediate> shouldn't have to see get/set specs.

(define (/hw-parse context name comment attrs semantic-name type
		   indices values handlers get set layout)
  (logit 2 "Processing hardware element " name " ...\n")

  (if (null? type)
      (parse-error context "missing hardware type" name))

  ;; Pick out name first to augment the error context.
  (let* ((name (parse-name context name))
	 (context (context-append-name context name))
	 (class-name (assq-ref /hardware-types (car type)))
	 (atlist-obj (atlist-parse context attrs "cgen_hw")))

    (if (not class-name)
	(parse-error context "unknown hardware type" type))

    (if (keep-atlist? atlist-obj #f)

	(let ((result (new (class-lookup class-name))))
	  (send result 'set-name! name)
	  (send result 'set-comment! (parse-comment context comment))
	  (send result 'set-atlist! atlist-obj)
	  (elm-xset! result 'sem-name semantic-name)
	  (send result 'parse! context
		(cdr type) indices values handlers get set layout)
	  ; If this is a virtual reg, get/set specs must be provided.
	  (if (and (obj-has-attr? result 'VIRTUAL)
		   (not (and (hw-getter result) (hw-setter result))))
	      (parse-error context "virtual reg requires get/set specs" name))
	  ; If get or set specs are specified, can't have CACHE-ADDR.
	  (if (and (obj-has-attr? result 'CACHE-ADDR)
		   (or (hw-getter result) (hw-setter result)))
	      (parse-error context "can't have CACHE-ADDR with get/set specs"
			   name))
	  result)

	(begin
	  (logit 2 "Ignoring " name ".\n")
	  #f)))
)

; Read a hardware description
; This is the main routine for analyzing a hardware description in the .cpu
; file.
; CONTEXT is a <context> object for error messages.
; ARG-LIST is an associative list of field name and field value.
; /hw-parse is invoked to create the <hardware> object.

(define (/hw-read context . arg-list)
  (let (
	(name nil)
	(comment "")
	(attrs nil)
	(semantic-name nil) ; name used in semantics, default is `name'
	(type nil)          ; hardware type (register, immediate, etc.)
	(indices nil)
	(values nil)
	(handlers nil)
	(get nil)
	(set nil)
	(layout nil)
	)

    ; Loop over each element in ARG-LIST, recording what's found.
    (let loop ((arg-list arg-list))
      (if (null? arg-list)
	  nil
	  (let ((arg (car arg-list))
		(elm-name (caar arg-list)))
	    (case elm-name
	      ((name) (set! name (cadr arg)))
	      ((comment) (set! comment (cadr arg)))
	      ((attrs) (set! attrs (cdr arg)))
	      ((semantic-name) (set! semantic-name (cadr arg)))
	      ((type) (set! type (cdr arg)))
	      ((indices) (set! indices (cdr arg)))
	      ((values) (set! values (cdr arg)))
	      ((handlers) (set! handlers (cdr arg)))
	      ((get) (set! get (cdr arg)))
	      ((set) (set! set (cdr arg)))
	      ((layout) (set! layout (cdr arg)))
	      (else (parse-error context "invalid hardware arg" arg)))
	    (loop (cdr arg-list)))))

    ; Now that we've identified the elements, build the object.
    (/hw-parse context name comment attrs
	       (if (null? semantic-name) name semantic-name)
	       type indices values handlers get set layout))
)

; Define a hardware object, name/value pair list version.

(define define-hardware
  (lambda arg-list
    (let ((hw (apply /hw-read (cons (make-current-context "define-hardware")
				    arg-list))))
      (if hw
	  (current-hw-add! hw))
      hw))
)

; Define a hardware object, all arguments specified.

(define (define-full-hardware name comment attrs semantic-name type
			      indices values handlers get set layout)
  (let ((hw (/hw-parse (make-current-context "define-full-hardware")
		       name comment attrs semantic-name type
		       indices values handlers get set layout)))
    (if hw
	(current-hw-add! hw))
    hw)
)

; Main routine for modifying existing definitions.

(define modify-hardware
  (lambda arg-list
    (let ((context (make-current-context "modify-hardware")))

      ; FIXME: Experiment.  This implements the :name/value style by
      ; converting it to (name value).  In the end there shouldn't be two
      ; styles.  People might prefer :name/value, but it's not as amenable
      ; to macro processing (insert potshots regarding macro usage).
      (if (keyword-list? (car arg-list))
	  (set! arg-list (keyword-list->arg-list arg-list)))

      ; First find out which element.
      ; There's no requirement that the name be specified first.
      (let ((hw-spec (assq 'name arg-list)))
	(if (not hw-spec)
	    (parse-error context "hardware name not specified" arg-list))

	(let ((hw (current-hw-lookup (arg-list-symbol-arg context hw-spec))))
	  (if (not hw)
	      (parse-error context "undefined hardware element" hw-spec))

	  ; Process the rest of the args now that we have the affected object.
	  (let loop ((args arg-list))
	    (if (null? args)
		#f ; done
		(let ((arg-spec (car args)))
		  (case (car arg-spec)
		    ((name) #f) ; ignore, already processed
		    ((add-attrs)
		     (let ((atlist-obj (atlist-parse context (cdr arg-spec)
						     "cgen_hw")))
		       ; prepend attrs so new ones override existing ones
		       (obj-prepend-atlist! hw atlist-obj)))
		    (else
		     (parse-error context "invalid/unsupported option"
				  (car arg-spec))))
		  (loop (cdr args))))))))

    *UNSPECIFIED*)
)

; Lookup a hardware object using its semantic name.
; The result is a list of elements with SEM-NAME.
; Callers must deal with cases where there is more than one.

(define (current-hw-sem-lookup sem-name)
  (find (lambda (hw) (eq? (hw-sem-name hw) sem-name))
	(current-hw-list))
)

; Same as current-hw-sem-lookup, but result is 1 hw element or #f if not
; found.  An error is signalled if multiple hw elements are found.

(define (current-hw-sem-lookup-1 sem-name)
  (let ((hw-objs (current-hw-sem-lookup sem-name)))
    (case (length hw-objs)
      ((0) #f)
      ((1) (car hw-objs))
      (else (error "ambiguous hardware reference" sem-name))))
)

; Basic hardware types.
; These inherit from `hardware-base'.
; ??? Might wish to allow each target to add more, but we provide enough
; examples to cover most cpus.

; A register (or an array of them).

(define <hw-register> (class-make '<hw-register> '(<hardware-base>) nil nil))

; Subroutine of -hw-create-[gs]etter-from-layout to validate a layout.
; Valid values:
; - 0 or 1
; - (value length)
; - hardware-name

(define (/hw-validate-layout context layout width)
  (if (not (list? layout))
      (parse-error context "layout is not a list" layout))

  (let loop ((layout layout) (shift 0))
    (if (null? layout)
	(begin
	  ; Done.  Now see if number of bits in layout matches total width.
	  (if (not (= shift width))
	      (parse-error context (string-append
				    "insufficient number of bits (need "
				    (number->string width)
				    ")")
			   shift)))
	; Validate next entry.
	(let ((val (car layout)))
	  (cond ((number? val)
		 (if (not (memq val '(0 1)))
		     (parse-error context
				  "non 0/1 layout entry requires length"
				  val))
		 (loop (cdr layout) (1+ shift)))
		((pair? val)
		 (if (or (not (number? (car val)))
			 (not (pair? (cdr val)))
			 (not (number? (cadr val)))
			 (not (null? (cddr val))))
		     (parse-error context
				  "syntax error in layout, expecting `(value length)'"
				  val))
		 (loop (cdr layout) (+ shift (cadr val))))
		((symbol? val)
		 (let ((hw (current-hw-lookup val)))
		   (if (not hw)
		       (parse-error context "unknown hardware element" val))
		   (if (not (hw-scalar? hw))
		       (parse-error context "non-scalar hardware element" val))
		   (loop (cdr layout)
			 (+ shift (hw-bits hw)))))
		(else
		 (parse-error context "bad layout element" val))))))

  *UNSPECIFIED*
)

; Return the getter spec to use for LAYOUT.
; WIDTH is the width of the combined value in bits.
;
; Example:
; Assuming h-hw[123] are 1 bit registers, and width is 32
; given ((0 29) h-hw1 h-hw2 h-hw3), return
; (()
;  (or SI (sll SI (zext SI (reg h-hw1)) 2)
;      (or SI (sll SI (zext SI (reg h-hw2)) 1)
;          (zext SI (reg h-hw3)))))

(define (/hw-create-getter-from-layout context layout width)
  (let ((add-to-res (lambda (result mode-name val shift)
		      (if (null? result)
			  (rtx-make 'sll mode-name val shift)
			  (rtx-make 'or mode-name
				    (rtx-make 'sll mode-name
					      (rtx-make 'zext mode-name val)
					      shift)
				    result))))
	(mode-name (obj:name (mode-find width 'UINT))))
    (let loop ((result nil) (layout (reverse layout)) (shift 0))
      (if (null? layout)
	  (list nil result) ; getter spec: (get () (expression))
	  (let ((val (car layout)))
	    (cond ((number? val)
		   ; ignore if zero
		   (if (= val 0)
		       (loop result (cdr layout) (1+ shift))
		       (loop (add-to-res result mode-name val shift)
			     (cdr layout)
			     (1+ shift))))
		  ((pair? val)
		   ; ignore if zero
		   (if (= (car val) 0)
		       (loop result (cdr layout) (+ shift (cadr val)))
		       (loop (add-to-res result mode-name (car val) shift)
			     (cdr layout)
			     (+ shift (cadr val)))))
		  ((symbol? val)
		   (let ((hw (current-hw-lookup val)))
		     (loop (add-to-res result mode-name
				       (rtx-make 'reg val)
				       shift)
			   (cdr layout)
			   (+ shift (hw-bits hw)))))
		  (else
		   (assert (begin "bad layout element" #f))))))))
)

; Return the setter spec to use for LAYOUT.
; WIDTH is the width of the combined value in bits.
;
; Example:
; Assuming h-hw[123] are 1 bit registers,
; given (h-hw1 h-hw2 h-hw3), return
; ((val)
;  (sequence ()
;            (set (reg h-hw1) (and (srl val 2) 1))
;            (set (reg h-hw2) (and (srl val 1) 1))
;            (set (reg h-hw3) (and (srl val 0) 1))
;            ))

(define (/hw-create-setter-from-layout context layout width)
  (let ((mode-name (obj:name (mode-find width 'UINT))))
    (let loop ((sets nil) (layout (reverse layout)) (shift 0))
      (if (null? layout)
	  (list '(val) ; setter spec: (set (val) (expression))
		(apply rtx-make (cons 'sequence (cons nil sets))))
	  (let ((val (car layout)))
	    (cond ((number? val)
		   (loop sets (cdr layout) (1+ shift)))
		  ((pair? val)
		   (loop sets (cdr layout) (+ shift (cadr val))))
		  ((symbol? val)
		   (let ((hw (current-hw-lookup val)))
		     (loop (cons (rtx-make 'set
					   (rtx-make 'reg val)
					   (rtx-make 'and
						     (rtx-make 'srl 'val shift)
						     (1- (logsll 1 (hw-bits hw)))))
				 sets)
			   (cdr layout)
			   (+ shift (hw-bits hw)))))
		  (else
		   (assert (begin "bad layout element" #f))))))))
)

; Parse a register spec.
; .cpu syntax: (register mode [(dimension)])
;          or: (register (mode bits) [(dimension)])

(method-make!
 <hw-register> 'parse!
 (lambda (self context type indices values handlers getter setter layout)
   (if (or (null? type)
	   (> (length type) 2))
       (parse-error context "invalid register spec" type))
   (if (and (= (length type) 2)
	    (or (not (list? (cadr type)))
		(> (length (cadr type)) 1)))
       (parse-error context "bad register dimension spec" type))

   ; Must parse and set type before analyzing LAYOUT.
   (elm-set! self 'type (parse-type context type))

   ; LAYOUT is a shorthand way of specifying getter/setter specs.
   ; For registers that are just a collection of other registers
   ; (e.g. the status register in mips), it's easier to specify the
   ; registers that make up the bigger register, rather than to specify
   ; get/set specs.
   ; We don't override any provided get/set specs though.
   (if (not (null? layout))
       (let ((width (hw-bits self)))
	 (/hw-validate-layout context layout width)
	 (if (null? getter)
	     (set! getter
		   (/hw-create-getter-from-layout context layout width)))
	 (if (null? setter)
	     (set! setter
		   (/hw-create-setter-from-layout context layout width)))
	 ))

   (elm-set! self 'indices (/hw-parse-indices context indices self 'UINT))
   (elm-set! self 'values (/hw-parse-values context values self
					    (obj:name (send (elm-get self 'type)
							    'get-mode))))
   (elm-set! self 'handlers (/hw-parse-handlers context handlers))
   (elm-set! self 'get (/hw-parse-getter context getter (hw-scalar? self)))
   (elm-set! self 'set (/hw-parse-setter context setter (hw-scalar? self)))
   *UNSPECIFIED*)
)

; Return boolean indicating if hardware element is some kind of register.

(method-make! <hw-register> 'register? (lambda (self) #t))

; Return a boolean indicating if it's ok to reference SELF in mode
; NEW-MODE-NAME, index INDEX.
;
; ??? INDEX isn't currently used.  The intent is to use it if it's a known
; value, and otherwise assume for our purposes it's valid and leave any
; further error checking to elsewhere.
;
; ??? This method makes more sense if we support multiple modes via
; getters/setters.  Maybe we will some day, so this is left as is for now.

(method-make!
 <hw-register> 'mode-ok?
 (lambda (self new-mode-name index)
   (let ((cur-mode (send self 'get-mode))
	 (new-mode (mode:lookup new-mode-name)))
     (if (mode:eq? new-mode-name cur-mode)
	 #t
	 ; ??? Subject to revisiting.
	 ; Only allow floats if same mode (which is handled above).
	 ; Only allow non-widening if ints.
	 ; On architectures where shortening/widening can refer to a
	 ; quasi-different register, it is up to the target to handle this.
	 ; See the comments for the getter/setter/getters/setters class
	 ; members.
	 (let ((cur-mode-class (mode:class cur-mode))
	       (cur-bits (mode:bits cur-mode))
	       (new-mode-class (mode:class new-mode))
	       (new-bits (mode:bits new-mode)))
	   ; Compensate for registers defined with an unsigned mode.
	   (if (eq? cur-mode-class 'UINT)
	       (set! cur-mode-class 'INT))
	   (if (eq? new-mode-class 'UINT)
	       (set! new-mode-class 'INT))
	   (if (eq? cur-mode-class 'INT)
	       (and (eq? new-mode-class cur-mode-class)
		    (<= new-bits cur-bits))
	       #f)))))
)

; Return mode to use for the index or #f if scalar.

(method-make!
 <hw-register> 'get-index-mode
 (lambda (self)
   (if (scalar? (hw-type self))
       #f
       UINT))
)

; The program counter (PC) hardware register.
; This is a separate class as the simulator needs a place to put special
; get/set methods.

(define <hw-pc> (class-make '<hw-pc> '(<hw-register>) nil nil))

; Parse a pc spec.

(method-make!
 <hw-pc> 'parse!
 (lambda (self context type indices values handlers getter setter layout)
   (if (not (null? type))
       (elm-set! self 'type (parse-type context type))
       (elm-set! self 'type (make <scalar> (mode:lookup 'IAI))))
   (if (not (null? indices))
       (parse-error context "indices specified for pc" indices))
   (if (not (null? values))
       (parse-error context "values specified for pc" values))
   (if (not (null? layout))
       (parse-error context "layout specified for pc" values))
   ; The initial value of INDICES, VALUES is #f which is what we want.
   (elm-set! self 'handlers (/hw-parse-handlers context handlers))
   (elm-set! self 'get (/hw-parse-getter context getter (hw-scalar? self)))
   (elm-set! self 'set (/hw-parse-setter context setter (hw-scalar? self)))
   *UNSPECIFIED*)
)

; Indicate we're the pc.

(method-make! <hw-pc> 'pc? (lambda (self) #t))

(define (hw-pc? hw) (send hw 'pc?))

; Memory.

(define <hw-memory> (class-make '<hw-memory> '(<hardware-base>) nil nil))

; Parse a memory spec.
; .cpu syntax: (memory mode [(dimension)])
;          or: (memory (mode bits) [(dimension)])

(method-make!
 <hw-memory> 'parse!
 (lambda (self context type indices values handlers getter setter layout)
   (if (or (null? type)
	   (> (length type) 2))
       (parse-error context "invalid memory spec" type))
   (if (and (= (length type) 2)
	    (or (not (list? (cadr type)))
		(> (length (cadr type)) 1)))
       (parse-error context "bad memory dimension spec" type))
   (if (not (null? layout))
       (parse-error context "layout specified for memory" values))
   (elm-set! self 'type (parse-type context type))
   ; Setting INDICES,VALUES here is mostly for experimentation at present.
   (elm-set! self 'indices (/hw-parse-indices context indices self 'AI))
   (elm-set! self 'values (/hw-parse-values context values self
					    (obj:name (send (elm-get self 'type)
							    'get-mode))))
   (elm-set! self 'handlers (/hw-parse-handlers context handlers))
   (elm-set! self 'get (/hw-parse-getter context getter (hw-scalar? self)))
   (elm-set! self 'set (/hw-parse-setter context setter (hw-scalar? self)))
   *UNSPECIFIED*)
)

; Return boolean indicating if hardware element is some kind of memory.

(method-make! <hw-memory> 'memory? (lambda (self) #t))

; Return a boolean indicating if it's ok to reference SELF in mode
; NEW-MODE-NAME, index INDEX.

(method-make!
 <hw-memory> 'mode-ok?
 (lambda (self new-mode-name index)
   ; Allow any mode for now.
   #t)
)

; Return mode to use for the index or #f if scalar.

(method-make!
 <hw-memory> 'get-index-mode
 (lambda (self)
   AI)
)

; Immediate values (numbers recorded in the insn).

(define <hw-immediate> (class-make '<hw-immediate> '(<hardware-base>) nil nil))

; Parse an immediate spec.
; .cpu syntax: (immediate mode)
;          or: (immediate (mode bits))

(method-make!
 <hw-immediate> 'parse!
 (lambda (self context type indices values handlers getter setter layout)
   (if (not (= (length type) 1))
       (parse-error context "invalid immediate spec" type))
   (elm-set! self 'type (parse-type context type))
   ; An array of immediates may be useful some day, but not yet.
   (if (not (null? indices))
       (parse-error context "indices specified for immediate" indices))
   (if (not (null? layout))
       (parse-error context "layout specified for immediate" values))
   (elm-set! self 'values (/hw-parse-values context values self
					    (obj:name (send (elm-get self 'type)
							    'get-mode))))
   (elm-set! self 'handlers (/hw-parse-handlers context handlers))
   (if (not (null? getter))
       (parse-error context "getter specified for immediate" getter))
   (if (not (null? setter))
       (parse-error context "setter specified for immediate" setter))
   *UNSPECIFIED*)
)

; Return a boolean indicating if it's ok to reference SELF in mode
; NEW-MODE-NAME, index INDEX.

(method-make!
 <hw-immediate> 'mode-ok?
 (lambda (self new-mode-name index)
   (let ((cur-mode (send self 'get-mode))
	 (new-mode (mode:lookup new-mode-name)))
     (if (mode:eq? new-mode-name cur-mode)
	 #t
	 ; ??? Subject to revisiting.
	 ; Only allow floats if same mode (which is handled above).
	 ; For ints allow anything.
	 (let ((cur-mode-class (mode:class cur-mode))
	       (new-mode-class (mode:class new-mode)))
	   (->bool (and (memq cur-mode-class '(INT UINT))
			(memq new-mode-class '(INT UINT))))))))
)

; These are scalars.

(method-make!
 <hw-immediate> 'get-index-mode
 (lambda (self) #f)
)

; Addresses.
; These are usually symbols.

(define <hw-address> (class-make '<hw-address> '(<hardware-base>) nil nil))

(method-make! <hw-address> 'address? (lambda (self) #t))

; Parse an address spec.

(method-make!
 <hw-address> 'parse!
 (lambda (self context type indices values handlers getter setter layout)
   (if (not (null? type))
       (parse-error context "invalid address spec" type))
   (elm-set! self 'type (make <scalar> AI))
   (if (not (null? indices))
       (parse-error context "indices specified for address" indices))
   (if (not (null? values))
       (parse-error context "values specified for address" values))
   (if (not (null? layout))
       (parse-error context "layout specified for address" values))
   (elm-set! self 'values (/hw-parse-values context values self
					    (obj:name (send (elm-get self 'type)
							    'get-mode))))
   (elm-set! self 'handlers (/hw-parse-handlers context handlers))
   (if (not (null? getter))
       (parse-error context "getter specified for address" getter))
   (if (not (null? setter))
       (parse-error context "setter specified for address" setter))
   *UNSPECIFIED*)
)

; Return a boolean indicating if it's ok to reference SELF in mode
; NEW-MODE-NAME, index INDEX.

(method-make!
 <hw-address> 'mode-ok?
 (lambda (self new-mode-name index)
   ; We currently don't allow referencing an address in any mode other than
   ; the original mode.
   (mode-compatible? 'samesize new-mode-name (send self 'get-mode)))
)

; Instruction addresses.
; These are treated separately from normal addresses as the simulator
; may wish to treat them specially.
; FIXME: Doesn't use mode IAI.

(define <hw-iaddress> (class-make '<hw-iaddress> '(<hw-address>) nil nil))

(method-make! <hw-iaddress> 'iaddress? (lambda (self) #t))

; Misc. random hardware support.

; Map a mode to a hardware object that can contain immediate values of that
; mode.

(define (hardware-for-mode mode)
  (cond ((mode:eq? mode 'AI) h-addr)
	((mode:eq? mode 'IAI) h-iaddr)
	((mode-signed? mode) h-sint)
	((mode-unsigned? mode) h-uint)
	(else (error "Don't know h-object for mode " mode)))
)

; Called when a cpu-family is read in to set the word sizes.
; Must be called after mode-set-word-modes! has been called.

(define (hw-update-word-modes!)
  (elm-xset! h-addr 'type (make <scalar> (mode:lookup 'AI)))
  (elm-xset! h-iaddr 'type (make <scalar> (mode:lookup 'IAI)))
)

; Builtins, attributes, init/fini support.

(define h-memory #f)
(define h-sint #f) ;; FIXME: convention says this should be named h-int
(define h-uint #f)
(define h-addr #f)
(define h-iaddr #f)

; Called before reading a .cpu file in.

(define (hardware-init!)
  (reader-add-command! 'define-keyword
		       "\
Define a keyword, name/value pair list version.
"
		       nil 'arg-list define-keyword)
  (reader-add-command! 'define-hardware
		       "\
Define a hardware element, name/value pair list version.
"
		       nil 'arg-list define-hardware)
  (reader-add-command! 'define-full-hardware
		       "\
Define a hardware element, all arguments specified.
"
		       nil '(name comment attrs semantic-name type
				  indices values handlers get set layout)
		       define-full-hardware)
  (reader-add-command! 'modify-hardware
		       "\
Modify a hardware element, name/value pair list version.
"
		       nil 'arg-list modify-hardware)

  *UNSPECIFIED*
)

; Install builtin hardware objects.

(define (hardware-builtin!)
  ; Standard h/w attributes.
  (define-attr '(for hardware) '(type boolean) '(name CACHE-ADDR)
    '(comment "cache register address during insn extraction"))
  ; FIXME: This should be deletable.
  (define-attr '(for hardware) '(type boolean) '(name PC)
    '(comment "the program counter"))
  (define-attr '(for hardware) '(type boolean) '(name PROFILE)
    '(comment "collect profiling data"))

  (let ((all (all-isas-attr-value)))
    ; ??? The program counter, h-pc, used to be defined here.
    ; However, some targets need to modify it (e.g. provide special get/set
    ; specs).  There's still an outstanding issue of how to add things to
    ; objects after the fact (e.g. model parameters to instructions), but
    ; that's further down the road.
    (set! h-memory (define-full-hardware 'h-memory "memory"
		     `((ISA ,@@all))
		     ; Ensure memory not flagged as a scalar.
		     'h-memory '(memory UQI (1)) nil nil nil
		     nil nil nil))
    (set! h-sint (define-full-hardware 'h-sint "signed integer"
		   `((ISA ,@@all))
		   'h-sint '(immediate (INT 32)) nil nil nil
		   nil nil nil))
    (set! h-uint (define-full-hardware 'h-uint "unsigned integer"
		   `((ISA ,@@all))
		   'h-uint '(immediate (UINT 32)) nil nil nil
		   nil nil nil))
    (set! h-addr (define-full-hardware 'h-addr "address"
		   `((ISA ,@@all))
		   'h-addr '(address) nil nil '((print "print_address"))
		   nil nil nil))
    ; Instruction addresses.
    ; These are different because the simulator may want to do something
    ; special with them, and some architectures treat them differently.
    (set! h-iaddr (define-full-hardware 'h-iaddr "instruction address"
		    `((ISA ,@@all))
		    'h-iaddr '(iaddress) nil nil '((print "print_address"))
		    nil nil nil)))

  *UNSPECIFIED*
)

; Called after a .cpu file has been read in.

(define (hardware-finish!)
  *UNSPECIFIED*
)
@


1.14
log
@	Record bitset attributes internally as a list.
	Record rtx attribute values internally as ((rtx-expr)).
	* attr.scm (bitset-attr?): Delete, unused.
	(<bitset-attribute> parse-value): Rewrite.
	(/attr-parse): Rewrite bitset default value processing.
	(/attr-read): Pick out values of scalar attributes to distinguish
	them from bitset values which are a list.
	Fix spelling errors for processing of default values.
	Handle string attributes.
	(bitset-attr->list): Delete, all callers updated.
	(/bitset-attr->charmask): Renamed from bitset-attr->charmask.
	All callers updated.
	(atlist-source-form): Rewrite.
	* hardware.scm (<hardware-base> 'get-isas): Update recognition
	of all isas.
	(hardware-builtin!): Update spec of ISA attribute, (ISA foo,bar)
	-> (ISA foo bar).
	* intrinsics.scm (target:belongs-to-group?): Update, bitset attribute
	values are now lists.
	* mach.scm (def-isa-attr!): Update, bitset attribute values,
	including the default, are now lists.
	(all-isas-attr-value): Result is now a list.
	* doc/rtl.texi: Clean up pass over attribute docs.
@
text
@d984 2
@


1.13
log
@(h-sint): add fixme
@
text
@d158 2
a159 3
	      (isa-objs (if (eq? isas 'all) (current-isa-list)
			    (map current-isa-lookup
				 (bitset-attr->list isas)))))
d1223 1
a1223 1
		     `((ISA ,all))
d1228 1
a1228 1
		   `((ISA ,all))
d1232 1
a1232 1
		   `((ISA ,all))
d1236 1
a1236 1
		   `((ISA ,all))
d1243 1
a1243 1
		    `((ISA ,all))
@


1.12
log
@	Clean up pass of mode handling.
	Make use of mode name vs <mode> object more consistent and clear.
	* hardware.scm (/keyword-read): Default mode to the mode name,
	not the <mode> object.
	(/hw-parse-indices): Parse mode name and pass mode object to
	<hw-asm> constructor.
	(/hw-parse-values): Ditto.
	(<hw-register> parse!): Pass mode name to /hw-parse-indices
	and /hw-parse-values.
	(<hw-memory> parse!): Ditto.
	(<hw-address> parse!): Ditto.
	* mode.scm (/mode-table): New global, replaces mode-list.
	Modes stored in hashtable instead of list.
	(/mode-class-table): New global.
	(mode-list-non-alias-values): Update.
	(mode:eq?, mode-compatible?, mode:add!): Update.
	(mode:lookup): Restrict arg to the mode's name.  All callers updated.
	(mode-maybe-lookup): New function.
	(mode-real-name): Restrict arg to a <mode> object.  All callers updated.
	(mode-real-mode, mode-sem-mode, mode-bigger?): Ditto.
	(mode-find, mode-set-word-modes!): Update
	(mode-ensure-word-sizes-defined): Update.
	(/sort-mode-classes!): New function.
	(mode-builtin!): Update.  Sort mode classes here.
	(mode-finish!): Sort mode classes here too.
	* rtl-c.scm (/rtl-c-get): Restrict mode arg to a <mode> object.
	All callers updated.
	(rtl-c-set-quiet): Allow mode to be name of object.
	(rtl-c-set-trace): Ditto.
	* rtl-traverse.scm (rtl-eval-with-estate): Restrict mode arg to
	<mode> object.  All callers updated.
	* rtl.scm (rtx-sem-mode): Restrict arg to <mode> object.
	(rtx-lazy-sem-mode): Ditto.
	(<rtx-temp> make!): Assert mode arg is a <mode> object.
	(rtx-env-make): Allow var-list modes to be name or object.
	* sem-frags.scm (/frag-expr-assq-locals): New function.
	(/frag-compute-locals!): Call it.
	(/sfrag-create-cse-mapping): Renamed from sfrag-create-cse-mapping.
	All callers updated.
	* semantics.scm (/build-mem-operand!): Handle mode aliases.
@
text
@d1171 1
a1171 1
(define h-sint #f)
@


1.11
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d211 1
a211 1
		; The mode to use.
d258 1
a258 1
; Each value is a number of mode MODE.
d303 1
a303 1
	(mode INT)
d393 1
d417 1
a417 1
; Otherwise MODE is used.
d424 1
a424 1
	mode)
d445 1
a445 1
; Otherwise MODE is used.
d452 1
a452 1
	mode)
d891 1
a891 1
   (elm-set! self 'indices (/hw-parse-indices context indices self UINT))
d893 2
a894 2
					    (send (elm-get self 'type)
						  'get-mode)))
d1007 1
a1007 1
   (elm-set! self 'indices (/hw-parse-indices context indices self AI))
d1009 2
a1010 2
					    (send (elm-get self 'type)
						  'get-mode)))
d1059 2
a1060 2
					    (send (elm-get self 'type)
						  'get-mode)))
d1117 2
a1118 2
					    (send (elm-get self 'type)
						  'get-mode)))
@


1.10
log
@	* hardware.scm (-keyword-parse): Fix `enum-prefix' default for
	rtl version 0.7.
	* doc/rtl.texi: Improve docs on rtl 0.7 vs 0.8 differences.
@
text
@d265 1
a265 1
(define (-keyword-parse context name comment attrs mode enum-prefix
d296 1
a296 1
; -keyword-parse is invoked to create the <keyword> object.
d298 1
a298 1
(define (-keyword-read context . arg-list)
d347 1
a347 1
    (-keyword-parse context name comment attrs mode
d355 1
a355 1
    (let ((kw (apply -keyword-read (cons (make-current-context "define-keyword")
d381 1
a381 1
(define -hardware-types
d394 1
a394 1
(define (-hw-parse-keyword context args container mode)
d402 1
a402 1
  (-keyword-parse context (obj:name container) (obj:comment container)
d419 1
a419 1
(define (-hw-parse-indices context indices container mode)
d428 1
a428 1
	  ((keyword) (-hw-parse-keyword context (cdr indices) container mode))
d447 1
a447 1
(define (-hw-parse-values context values container mode)
d456 1
a456 1
	  ((keyword) (-hw-parse-keyword context (cdr values) container mode))
d472 1
a472 1
(define (-hw-parse-handlers context handlers)
d481 1
a481 1
(define (-hw-parse-getter context getter scalar?)
d504 1
a504 1
(define (-hw-parse-setter context setter scalar?)
d531 1
a531 1
(define (-hw-parse context name comment attrs semantic-name type
d541 1
a541 1
	 (class-name (assq-ref -hardware-types (car type)))
d577 1
a577 1
; -hw-parse is invoked to create the <hardware> object.
d579 1
a579 1
(define (-hw-read context . arg-list)
d616 1
a616 1
    (-hw-parse context name comment attrs
d625 1
a625 1
    (let ((hw (apply -hw-read (cons (make-current-context "define-hardware")
d636 1
a636 1
  (let ((hw (-hw-parse (make-current-context "define-full-hardware")
d722 1
a722 1
(define (-hw-validate-layout context layout width)
d778 1
a778 1
(define (-hw-create-getter-from-layout context layout width)
d830 1
a830 1
(define (-hw-create-setter-from-layout context layout width)
d881 1
a881 1
	 (-hw-validate-layout context layout width)
d884 1
a884 1
		   (-hw-create-getter-from-layout context layout width)))
d887 1
a887 1
		   (-hw-create-setter-from-layout context layout width)))
d890 2
a891 2
   (elm-set! self 'indices (-hw-parse-indices context indices self UINT))
   (elm-set! self 'values (-hw-parse-values context values self
d894 3
a896 3
   (elm-set! self 'handlers (-hw-parse-handlers context handlers))
   (elm-set! self 'get (-hw-parse-getter context getter (hw-scalar? self)))
   (elm-set! self 'set (-hw-parse-setter context setter (hw-scalar? self)))
d974 3
a976 3
   (elm-set! self 'handlers (-hw-parse-handlers context handlers))
   (elm-set! self 'get (-hw-parse-getter context getter (hw-scalar? self)))
   (elm-set! self 'set (-hw-parse-setter context setter (hw-scalar? self)))
d1006 2
a1007 2
   (elm-set! self 'indices (-hw-parse-indices context indices self AI))
   (elm-set! self 'values (-hw-parse-values context values self
d1010 3
a1012 3
   (elm-set! self 'handlers (-hw-parse-handlers context handlers))
   (elm-set! self 'get (-hw-parse-getter context getter (hw-scalar? self)))
   (elm-set! self 'set (-hw-parse-setter context setter (hw-scalar? self)))
d1057 1
a1057 1
   (elm-set! self 'values (-hw-parse-values context values self
d1060 1
a1060 1
   (elm-set! self 'handlers (-hw-parse-handlers context handlers))
d1115 1
a1115 1
   (elm-set! self 'values (-hw-parse-values context values self
d1118 1
a1118 1
   (elm-set! self 'handlers (-hw-parse-handlers context handlers))
@


1.9
log
@	* hardware.scm (<keyword>): Rename member print-name -> enum-prefix.
	Rename member prefix -> name-prefix.
	(<keyword> getters): Update.
	(-keyword-parse): Update.  Default enum-prefix to NAME-.
	(-keyword-read): Update.  Don't compute default value for
	enum-prefix here.
	(define-keyword): Update.
	(-hw-parse-keyword): Pass "UNUSED" for enum-prefix to -keyword-parse.
	* read.scm (cgen-rtl-version): New function.
	(-supported-rtl-versions): Add (0 8).
	* desc-cpu.scm (-gen-hw-decl): Remove cruft.
	* desc.scm (<keyword> gen-defn): prefix -> name-prefix.
	* gas-test.scm (<keyword> test-data): prefix -> name-prefix.
	* cpu/arm.cpu (gr-names, shift-type): Call define-rtl-version.
	Update, print-name -> enum-prefix, make uppercase.
	Remove unnecessary name-prefix spec.
	* cpu/fr30.cpu (gr-names, cr-names, dr-names): Ditto.
	* cpu/ip2k.cpu (register-names): Ditto.
	* cpu/m68k.cpu (dr-names, ar-names): Ditto.
	* cpu/sparc.cpu (gr-names): Ditto.
	* cpu/xc16x.cpu (gr-names, ext-names,psw-names): Ditto.
	(grb-names, conditioncode-names, extconditioncode-names): Ditto.
	(grb8-names, r8-names, regmem8-names, regdiv8-names): Ditto.
	(reg0-name, reg0-name1, regbmem8-names, memgr8-names): Ditto.
	* cpu/ia32.cpu (gr8-names, gr16-names, gr-names): Call
	define-rtl-version.  Update, print-name -> enum-prefix, make uppercase,
	prefix -> name-prefix.
	* cpu/sh64-compact.cpu (frc-names): Call define-rtl-version.
	Update, print-name -> enum-prefix, make uppercase.
	(drc-names, xf-names): Ditto.
	* cpu/xstormy16.cpu (gr-names, gr-Rb-names): Ditto.
	* doc/rtl.texi (Keywords): New section.
	(hardware indices): Update text.
	(rtl versions): Add 0.8.
@
text
@d271 5
a275 3
			  (string-append ;; default to NAME-
			   (string-upcase (->string name))
			   "-"))))
@


1.8
log
@	Clean up cpu file parsing, pass context consistently instead of the
	old "errtxt" argument.
	NOTE: ACU == "All Callers Updated".
	* attr.scm (-parse-simple-attribute): Renamed from
	parse-simple-attribute, ACU.
	(-attr-parse): Change errtxt argument to context, ACU.
	(-attr-read): Ditto.
	(atlist-parse): Ditto.  Put context arg first.
	(attr-parse): Use parse-error instead of context-error.
	* enum.scm (parse-enum-vals): Change errtxt argument to context, ACU.
	(-enum-parse-prefix, -enum-parse, -enum-read): Ditto.
	* hardware.scm (-keyword-parse): Renamed from keyword-parse.
	`context' arg is now a <context> object.  ACU.
	(-keyword-read): `context' arg is now a <context> object.  ACU.
	(-hw-parse-indices): Change errtxt argument to context, ACU.
	(-hw-parse-values, -hw-parse-handlers): Ditto.
	(-hw-parse-getter, -hw-parse-setter, -hw-parse, -hw-read): Ditto.
	(-hw-validate-layout, -hw-create-getter-from-layout,
	-hw-create-setter-from-layout): Ditto.
	(<hw-register>:parse!, <hw-pc>:parse!): Ditto.
	(<hw-memory>:parse!, <hw-immediate>:parse!): Ditto.
	(<hw-address>:parse!): Ditto.
	* ifield.scm (-ifield-parse, ifield-read): Ditto.
	(-ifld-parse-follows, -ifld-parse-encode-decode): Ditto.
	(-ifld-parse-encode, -ifld-parse-decode): Ditto.
	(-multi-ifield-parse, -multi-ifield-read): Ditto.
	* insn.scm (-insn-parse, -insn-read): Ditto.
	(parse-syntax): Ditto.  Put context arg first.
	(-parse-insn-format-symbol): Change errtxt argument to context, ACU.
	(-parse-insn-format-ifield-spec, -parse-insn-format-list): Ditto.
	(-parse-insn-format): Ditto.
	* mach.scm (-arch-parse-alignment, -arch-parse-machs): Ditto.
	(-arch-parse-isas): Ditto.
	(-isa-read): Add context arg, ACU.
	(-cpu-parse, -cpu-read, -mach-read): Ditto.
	* minsn.scm (-minsn-parse-expansion): Change errtxt argument to
	context, ACU.
	(-minsn-parse, -minsn-read, -minsn-compute-iflds): Ditto.
	(minsn-make-alias): Ditto.
	* mode.scm (-mode-parse): Ditto.
	(parse-mode-name): Ditto.  Put context arg first.
	* model.scm (-prefetch-parse, -retire-parse, -pipeline-parse): Change
	errtxt argument to context, ACU.
	(-unit-parse, -model-parse, -model-read): Ditto.
	* operand.scm (-operand-parse-getter): Use parse-error instead of
	context-error.
	(-operand-parse-setter): Ditto.
	(-operand-parse): Change errtxt argument to context, ACU.
	(-operand-read, -derived-operand-parse, -derived-operand-read): Ditto.
	(-anyof-operand-parse, -anyof-operand-read): Ditto.
	* read.scm (reader-error): Delete.  Use parse-error instead.
	(parse-error): Change errtxt argument to context, ACU.  Split args
	argument into expr and maybe-help-text.
	(-reader-process-expanded-1!): Reorganize.
	* rtl.scm (-subr-read): Change errtxt argument to context, ACU.
	* types.scm (parse-type): Ditto.
	* utils-cgen.scm (single-location->simple-string): New function.
	(<context>): Replace members file,lineno with location.
	(make-prefix-context): Renamed from context-make-prefix, ACU.
	(make-current-context): New function.
	(context-append, context-append-name): New functions.
	(context-make-reader): Delete.
	(parse-name): Change errtxt argument to context, ACU.
	Put context arg first.
	(parse-comment): Ditto.
	(parse-number): Change errtxt argument to context, ACU.
	(arg-list-validate-name, arg-list-check-no-args,
	arg-list-symbol-arg): Ditto.

	* read.scm (-cmd-if): Don't assume test is a list.

	* html.scm (get-insn-properties): Delete errtxt, unused.
@
text
@d232 2
a233 2
		; Name to use in generated code, as a string.
		print-name
d236 2
a237 1
		prefix
d250 1
a250 4
(define kw-mode (elm-make-getter <keyword> 'mode))
(define kw-print-name (elm-make-getter <keyword> 'print-name))
(define kw-prefix (elm-make-getter <keyword> 'prefix))
(define kw-values (elm-make-getter <keyword> 'values))
d254 1
d256 2
a257 1
; PREFIX is a string prefix for each name.
d263 1
d265 22
a286 13
(define (-keyword-parse context name comment attrs mode print-name prefix values)
  ; FIXME: parse values.
  (let ((result (make <keyword>
		  (parse-name context name)
		  (parse-comment context comment)
		  (atlist-parse context attrs "")
		  (parse-mode-name (context-append context ": mode") mode)
		  (parse-string (context-append context ": print-name")
				print-name)
		  (parse-string (context-append context ": prefix")
				prefix)
		  values)))
    result)
d302 2
a303 2
	(print-name #f) ;; #f indicates "not set"
	(prefix "")
d318 22
a339 2
	      ((print-name) (set! print-name (cadr arg)))
	      ((prefix) (set! prefix (cadr arg)))
d346 1
a346 2
		    (or print-name name)
		    prefix values))
d361 1
d364 6
a369 1
	      (string-upcase (string-append (kw-print-name kw) "-"))
d396 1
a396 1
  ; These are copied from our container object.
d398 2
a399 2
  ; ??? This isn't quite right as the container may contain multiple keyword
  ; instances.  To be fixed in time.
d401 2
a402 2
		  ;; PRIVATE: keyword table is implicitly defined and made
		  ;; "static" (in the C sense).
d405 2
a406 1
		  (obj:name container) ; print-name
@


1.7
log
@	Use hash tables to record ifields, operands, insns, macro-insns.
	* attr.scm (attr-builtin!): Tweak some comments.
	* hardware.scm (hardware-builtin!): Call all-isas-attr-value.
	* ifield.scm (<ifield>): Subclass from <ordered-ident> instead of
	<ident>.
	(<multi-ifield>): New constructor.
	(ifield-builtin!): Add isa attr to f-nil, f-anyof.
	* insn.scm (<insn>): Subclass from <ordered-ident> instead of
	<ident>.
	(-sub-insn-make!): Add hack to avoid differences in generated code.
	(multi-insn-instantiate!): Add total number of multi-insns to
	logging message.
	* mach.scm (<arch>): Rename members ifld-list, op-list, insn-list,
	minsn-list to foo-table.  New member next-ordinal.
	Update getters/setters.
	(arch-ifld-list, arch-op-list, arch-insn-list, arch-minsn-list):
	New functions.
	(-get-next-ordinal!, -get-lowest-ordinal): New function.
	(-make-ident-object-table, -ident-object-table->list,
	-ident-object-table-add!, -ident-object-table-lookup): New functions.
	(current-ifld-list, current-ifld-add! current-ifld-lookup,
	-ifld-already-defined?): Rewrite.
	(current-op-list, current-op-add! current-op-lookup,
	-op-already-defined?): Rewrite.
	(current-raw-insn-list, insn-list-car, insn-list-splice!): Delete.
	(current-insn-list, current-insn-add! current-insn-lookup,
	-insn-already-defined?): Rewrite.
	(current-minsn-list, current-minsn-add! current-minsn-lookup,
	-minsn-already-defined?): Rewrite.
	(all-isas-attr-value, all-isas-attr, attr-isa-list): New functions.
	(MAX-VIRTUAL-INSNS): Define.
	(arch-analyze-insns!): Add hack to avoid differences in generated code.
	Update use of arch-insn-list.
	(mach-init!): Initialize ifld-table, op-table, insn-table, minsn-table.
	(arch-finish!): Delete references to ifld-table, op-table, insn-table,
	minsn-table.
	* minsn.scm (<macro-insn>): Subclass from <ordered-ident> instead of
	<ident>.  New constructor.
	* operand.scm (<operand>): Subclass from <ordered-ident> instead of
	<ident>.
	* sid.scm (-virtual-insn-add!): New function.
	(-create-virtual-insns!): Call it.
	(-fill-sim-insn-list!): Rewrite.
	* sim.scm (-virtual-insn-add!, -create-virtual-insns!): New functions.
	(sim-finish!): Move contents to -create-virtual-insns!, and call it.
	* utils-cgen.scm (<ordered-ident>): New class.
	(obj-ordinal, obj-set-ordinal!): New functions.
	(add-ident-methods!): Delete.

	* model.scm (parse-insn-timing): Change logging message to level 3.
@
text
@d264 1
a264 1
(define (keyword-parse context name comment attrs mode print-name prefix values)
d267 8
a274 6
		  (parse-name name context)
		  (parse-comment comment context)
		  (atlist-parse attrs "" context)
		  (parse-mode-name mode (string-append context ": mode"))
		  (parse-string (string-append context ": print-name") print-name)
		  (parse-string (string-append context ": prefix") prefix)
d282 1
d284 1
a284 1
; keyword-parse is invoked to create the <keyword> object.
d287 2
a288 1
  (let ((name #f)
d292 1
a292 1
	(print-name #f)
d296 1
d313 1
d315 3
a317 4
    (keyword-parse context name comment attrs mode
		   (or print-name name)
		   prefix values)
    )
d324 2
a325 1
    (let ((kw (apply -keyword-read (cons "define-keyword" arg-list))))
d365 8
a372 8
  (keyword-parse context (obj:name container) (obj:comment container)
		 ; PRIVATE: keyword table is implicitly defined and made
		 ; "static" (in the C sense).
		 (cons 'PRIVATE (atlist-source-form (obj-atlist container)))
		 mode
		 (obj:name container) ; print-name
		 (car args) ; prefix
		 (cadr args)) ; value
d381 1
a381 1
(define (-hw-parse-indices errtxt indices container mode)
d388 1
a388 1
	    (parse-error errtxt "invalid indices spec" indices))
d390 1
a390 1
	  ((keyword) (-hw-parse-keyword errtxt (cdr indices) container mode))
d393 1
a393 1
				  (parse-error errtxt "missing keyword name"
d397 1
a397 1
				    (parse-error errtxt "unknown keyword"
d400 1
a400 1
	  (else (parse-error errtxt "unknown indices type" (car indices))))))
d409 1
a409 1
(define (-hw-parse-values errtxt values container mode)
d416 1
a416 1
	    (parse-error errtxt "invalid values spec" values))
d418 1
a418 1
	  ((keyword) (-hw-parse-keyword errtxt (cdr values) container mode))
d421 1
a421 1
				  (parse-error errtxt "missing keyword name"
d425 1
a425 1
				    (parse-error errtxt "unknown keyword"
d428 1
a428 1
	  (else (parse-error errtxt "unknown values type" (car values))))))
d434 2
a435 2
(define (-hw-parse-handlers errtxt handlers)
  (parse-handlers errtxt '(parse print) handlers)
d443 1
a443 1
(define (-hw-parse-getter errtxt getter scalar?)
d452 1
a452 1
	    (parse-error errtxt
d457 1
a457 1
	    (parse-error errtxt "invalid rtx expression" getter))
d466 1
a466 1
(define (-hw-parse-setter errtxt setter scalar?)
d475 1
a475 1
	    (parse-error errtxt
d480 1
a480 1
	    (parse-error errtxt "invalid rtx expression" setter))
d493 1
a493 1
(define (-hw-parse errtxt name comment attrs semantic-name type
d498 1
a498 1
      (parse-error errtxt "missing hardware type" name))
d500 5
a504 4
  ; Pick out name first 'cus we need it as a string(/symbol).
  (let ((name (parse-name name "hardware"))
	(class-name (assq-ref -hardware-types (car type)))
	(atlist-obj (atlist-parse attrs "cgen_hw" errtxt)))
d507 1
a507 1
	(parse-error errtxt "unknown hardware type" type))
d513 1
a513 1
	  (send result 'set-comment! (parse-comment comment errtxt))
d516 1
a516 1
	  (send result 'parse! errtxt
d521 1
a521 1
	      (parse-error errtxt "virtual reg requires get/set specs" name))
d525 2
a526 1
	      (parse-error errtxt "can't have CACHE-ADDR with get/set specs" name))
d537 1
d541 3
a543 2
(define (-hw-read errtxt . arg-list)
  (let ((name nil)          ; name of hardware
d555 1
d574 1
a574 1
	      (else (parse-error errtxt "invalid hardware arg" arg)))
d576 1
d578 1
a578 1
    (-hw-parse errtxt name comment attrs
d580 1
a580 2
	       type indices values handlers get set layout)
    )
d587 2
a588 1
    (let ((hw (apply -hw-read (cons "define-hardware" arg-list))))
d598 1
a598 1
  (let ((hw (-hw-parse "define-full-hardware"
d610 1
a610 1
    (let ((errtxt "modify-hardware"))
d623 1
a623 1
	    (parse-error errtxt "hardware name not specified"))
d625 1
a625 1
	(let ((hw (current-hw-lookup (arg-list-symbol-arg errtxt hw-spec))))
d627 1
a627 1
	      (parse-error errtxt "undefined hardware element" hw-spec))
d637 2
a638 2
		     (let ((atlist-obj (atlist-parse (cdr arg-spec)
						     "cgen_hw" errtxt)))
d642 2
a643 1
		     (parse-error errtxt "invalid/unsupported option" (car arg-spec))))
d684 1
a684 1
(define (-hw-validate-layout errtxt layout width)
d686 1
a686 1
      (parse-error errtxt "layout is not a list" layout))
d693 4
a696 4
	      (parse-error errtxt (string-append
				   "insufficient number of bits (need "
				   (number->string width)
				   ")")
d702 1
a702 1
		     (parse-error errtxt
d711 1
a711 1
		     (parse-error errtxt
d718 1
a718 1
		       (parse-error errtxt "unknown hardware element" val))
d720 1
a720 1
		       (parse-error errtxt "non-scalar hardware element" val))
d724 2
a725 1
		 (parse-error errtxt "bad layout element" val))))))
d740 1
a740 1
(define (-hw-create-getter-from-layout errtxt layout width)
d792 1
a792 1
(define (-hw-create-setter-from-layout errtxt layout width)
d823 1
a823 1
 (lambda (self errtxt type indices values handlers getter setter layout)
d826 1
a826 1
       (parse-error errtxt "invalid register spec" type))
d830 1
a830 1
       (parse-error errtxt "bad register dimension spec" type))
d833 1
a833 1
   (elm-set! self 'type (parse-type errtxt type))
d843 1
a843 1
	 (-hw-validate-layout errtxt layout width)
d846 1
a846 1
		   (-hw-create-getter-from-layout errtxt layout width)))
d849 1
a849 1
		   (-hw-create-setter-from-layout errtxt layout width)))
d852 2
a853 2
   (elm-set! self 'indices (-hw-parse-indices errtxt indices self UINT))
   (elm-set! self 'values (-hw-parse-values errtxt values self
d856 3
a858 3
   (elm-set! self 'handlers (-hw-parse-handlers errtxt handlers))
   (elm-set! self 'get (-hw-parse-getter errtxt getter (hw-scalar? self)))
   (elm-set! self 'set (-hw-parse-setter errtxt setter (hw-scalar? self)))
d925 1
a925 1
 (lambda (self errtxt type indices values handlers getter setter layout)
d927 1
a927 1
       (elm-set! self 'type (parse-type errtxt type))
d930 1
a930 1
       (parse-error errtxt "indices specified for pc" indices))
d932 1
a932 1
       (parse-error errtxt "values specified for pc" values))
d934 1
a934 1
       (parse-error errtxt "layout specified for pc" values))
d936 3
a938 3
   (elm-set! self 'handlers (-hw-parse-handlers errtxt handlers))
   (elm-set! self 'get (-hw-parse-getter errtxt getter (hw-scalar? self)))
   (elm-set! self 'set (-hw-parse-setter errtxt setter (hw-scalar? self)))
d956 1
a956 1
 (lambda (self errtxt type indices values handlers getter setter layout)
d959 1
a959 1
       (parse-error errtxt "invalid memory spec" type))
d963 1
a963 1
       (parse-error errtxt "bad memory dimension spec" type))
d965 2
a966 2
       (parse-error errtxt "layout specified for memory" values))
   (elm-set! self 'type (parse-type errtxt type))
d968 2
a969 2
   (elm-set! self 'indices (-hw-parse-indices errtxt indices self AI))
   (elm-set! self 'values (-hw-parse-values errtxt values self
d972 3
a974 3
   (elm-set! self 'handlers (-hw-parse-handlers errtxt handlers))
   (elm-set! self 'get (-hw-parse-getter errtxt getter (hw-scalar? self)))
   (elm-set! self 'set (-hw-parse-setter errtxt setter (hw-scalar? self)))
d1010 1
a1010 1
 (lambda (self errtxt type indices values handlers getter setter layout)
d1012 2
a1013 2
       (parse-error errtxt "invalid immediate spec" type))
   (elm-set! self 'type (parse-type errtxt type))
d1016 1
a1016 1
       (parse-error errtxt "indices specified for immediate" indices))
d1018 2
a1019 2
       (parse-error errtxt "layout specified for immediate" values))
   (elm-set! self 'values (-hw-parse-values errtxt values self
d1022 1
a1022 1
   (elm-set! self 'handlers (-hw-parse-handlers errtxt handlers))
d1024 1
a1024 1
       (parse-error errtxt "getter specified for immediate" getter))
d1026 1
a1026 1
       (parse-error errtxt "setter specified for immediate" setter))
d1067 1
a1067 1
 (lambda (self errtxt type indices values handlers getter setter layout)
d1069 1
a1069 1
       (parse-error errtxt "invalid address spec" type))
d1072 1
a1072 1
       (parse-error errtxt "indices specified for address" indices))
d1074 1
a1074 1
       (parse-error errtxt "values specified for address" values))
d1076 2
a1077 2
       (parse-error errtxt "layout specified for address" values))
   (elm-set! self 'values (-hw-parse-values errtxt values self
d1080 1
a1080 1
   (elm-set! self 'handlers (-hw-parse-handlers errtxt handlers))
d1082 1
a1082 1
       (parse-error errtxt "getter specified for address" getter))
d1084 1
a1084 1
       (parse-error errtxt "setter specified for address" setter))
@


1.6
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d1164 1
a1164 1
  (let ((all (stringize (current-arch-isa-name-list) ",")))
@


1.5
log
@2006-07-14  Dave Brolley  <brolley@@redhat.com>

        * sid.scm (-op-gen-delayed-set-maybe-trace): If delay used, note the
        hardware or memory mode which was used.
        * sid-cpu.scm (hw-need-write-stack?): New function.
        (-gen-hw-stream-and-destream-fns): Compute stack-regs. Use it to
        identify hardware which uses write stacks.
        (useful-mode-names): Renamed to write-stack-memory-mode-names.
        Initialized to an empty list.
        (-gen-writestacks, -gen-reset-fn, -gen-unified-write-fn): Use
        hw-need-write-stack?.
        * hardware.scm (used-in-delay-rtl?): New member of <hardware-base>.
        (define-getters <hardware-base>): Define used-in-delay-rtl?.
        (used-in-delay-rtl?): New method of <hardware-base>.
        (hw-used-in-delay-rtl?): New function.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
@


1.5.4.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2009 Red Hat, Inc.
@


1.4
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@d69 4
d84 1
a84 1
   isas-cache)
d167 9
@


1.3
log
@	Better handling of 64 bit and mixed 32/64 bit architectures.
	* hardware.scm (hw-update-word-modes!): New fn.
	* mach.scm (define-cpu)): Call mode-set-word-modes!,
	hw-update-word-modes!.
	(state-word-bitsize): Replace FIXME with requested check.
	(arch-analyze-insns!): Call mode-ensure-word-sizes-defined.
	* mode.scm (mode-find): Ignore INT,UINT.
	(-mode-word-sizes-kind): New global.
	(mode-set-word-modes!,mode-set-identical-word-bitsizes!,
	mode-set-biggest-word-bitsizes!,mode-ensure-word-sizes-defined): New fns.
	(mode-init!): Initialize -mode-word-sizes-kind.  Move initialization
	of mode-list to ...
	(mode-builtin!): ... here.  Initialize WI/UWI/AI/IAI to something
	unusable, correct values set later.
	(mode-finish!): Remove cruft.
	* html.scm (doc-init!): Call mode-set-biggest-word-bitsizes!.
	* opcodes.scm (opcodes-init!): Ditto.
	* rtx-funcs.scm (annul): Fix mode of pc.
	* cpu/ia64.cpu: Remove cruft that sets word modes.
	* cpu/xstormy16.cpu (define-cpu): Set word-bitsize.
@
text
@d219 1
a219 1
		; Name to use in generated code.
d315 1
a315 1
	      (string-upcase (symbol-append (kw-print-name kw) '-))
@


1.2
log
@2000-08-24  Frank Ch. Eigler  <fche@@redhat.com>

	* hardware.scm (<hw-immediate> get-index-mode): Define method.
	* operand.scm (<operand> gen-pretty-name): Tolerate no op:sem-name.
	* rtl-c.scm (-c-rtl-get): Improve an error message.
	* sim.scm (-op-gen-set-trace): Support <derived-operand> lvalues.
@
text
@d1022 1
a1023 1
; These are scalars.
a1028 1

d1081 1
a1081 7
; Builtins, attributes, init/fini support.

(define h-memory #f)
(define h-sint #f)
(define h-uint #f)
(define h-addr #f)
(define h-iaddr #f)
d1083 2
a1085 1
; Map a mode to a hardware object that can contain immediate values of that mode
d1088 1
a1088 1
	((mode:eq? mode 'IAI) h-addr)
d1094 15
@


1.1
log
@Initial revision
@
text
@d1022 8
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
