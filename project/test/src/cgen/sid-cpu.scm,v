head	1.29;
access;
symbols
	sid-snapshot-20180601:1.29
	cgen-snapshot-20180601:1.29
	sid-snapshot-20180501:1.29
	cgen-snapshot-20180501:1.29
	sid-snapshot-20180401:1.29
	cgen-snapshot-20180401:1.29
	sid-snapshot-20180301:1.29
	cgen-snapshot-20180301:1.29
	sid-snapshot-20180201:1.29
	cgen-snapshot-20180201:1.29
	sid-snapshot-20180101:1.29
	cgen-snapshot-20180101:1.29
	sid-snapshot-20171201:1.29
	cgen-snapshot-20171201:1.29
	sid-snapshot-20171101:1.29
	cgen-snapshot-20171101:1.29
	sid-snapshot-20171001:1.29
	cgen-snapshot-20171001:1.29
	sid-snapshot-20170901:1.29
	cgen-snapshot-20170901:1.29
	sid-snapshot-20170801:1.29
	cgen-snapshot-20170801:1.29
	sid-snapshot-20170701:1.29
	cgen-snapshot-20170701:1.29
	sid-snapshot-20170601:1.29
	cgen-snapshot-20170601:1.29
	sid-snapshot-20170501:1.29
	cgen-snapshot-20170501:1.29
	sid-snapshot-20170401:1.29
	cgen-snapshot-20170401:1.29
	sid-snapshot-20170301:1.29
	cgen-snapshot-20170301:1.29
	sid-snapshot-20170201:1.29
	cgen-snapshot-20170201:1.29
	sid-snapshot-20170101:1.29
	cgen-snapshot-20170101:1.29
	sid-snapshot-20161201:1.29
	cgen-snapshot-20161201:1.29
	sid-snapshot-20161101:1.29
	cgen-snapshot-20161101:1.29
	sid-snapshot-20160901:1.29
	cgen-snapshot-20160901:1.29
	sid-snapshot-20160801:1.29
	cgen-snapshot-20160801:1.29
	sid-snapshot-20160701:1.29
	cgen-snapshot-20160701:1.29
	sid-snapshot-20160601:1.29
	cgen-snapshot-20160601:1.29
	sid-snapshot-20160501:1.29
	cgen-snapshot-20160501:1.29
	sid-snapshot-20160401:1.29
	cgen-snapshot-20160401:1.29
	sid-snapshot-20160301:1.29
	cgen-snapshot-20160301:1.29
	sid-snapshot-20160201:1.29
	cgen-snapshot-20160201:1.29
	sid-snapshot-20160101:1.29
	cgen-snapshot-20160101:1.29
	sid-snapshot-20151201:1.29
	cgen-snapshot-20151201:1.29
	sid-snapshot-20151101:1.29
	cgen-snapshot-20151101:1.29
	sid-snapshot-20151001:1.29
	cgen-snapshot-20151001:1.29
	sid-snapshot-20150901:1.29
	cgen-snapshot-20150901:1.29
	sid-snapshot-20150801:1.29
	cgen-snapshot-20150801:1.29
	sid-snapshot-20150701:1.29
	cgen-snapshot-20150701:1.29
	sid-snapshot-20150601:1.29
	cgen-snapshot-20150601:1.29
	sid-snapshot-20150501:1.29
	cgen-snapshot-20150501:1.29
	sid-snapshot-20150401:1.29
	cgen-snapshot-20150401:1.29
	sid-snapshot-20150301:1.29
	cgen-snapshot-20150301:1.29
	sid-snapshot-20150201:1.29
	cgen-snapshot-20150201:1.29
	sid-snapshot-20150101:1.29
	cgen-snapshot-20150101:1.29
	sid-snapshot-20141201:1.29
	cgen-snapshot-20141201:1.29
	sid-snapshot-20141101:1.29
	cgen-snapshot-20141101:1.29
	sid-snapshot-20141001:1.29
	cgen-snapshot-20141001:1.29
	sid-snapshot-20140901:1.29
	cgen-snapshot-20140901:1.29
	sid-snapshot-20140801:1.29
	cgen-snapshot-20140801:1.29
	sid-snapshot-20140701:1.29
	cgen-snapshot-20140701:1.29
	sid-snapshot-20140601:1.29
	cgen-snapshot-20140601:1.29
	sid-snapshot-20140501:1.29
	cgen-snapshot-20140501:1.29
	sid-snapshot-20140401:1.29
	cgen-snapshot-20140401:1.29
	sid-snapshot-20140301:1.29
	cgen-snapshot-20140301:1.29
	sid-snapshot-20140201:1.29
	cgen-snapshot-20140201:1.29
	sid-snapshot-20140101:1.29
	cgen-snapshot-20140101:1.29
	sid-snapshot-20131201:1.29
	cgen-snapshot-20131201:1.29
	sid-snapshot-20131101:1.29
	cgen-snapshot-20131101:1.29
	sid-snapshot-20131001:1.29
	cgen-snapshot-20131001:1.29
	sid-snapshot-20130901:1.29
	cgen-snapshot-20130901:1.29
	sid-snapshot-20130801:1.29
	cgen-snapshot-20130801:1.29
	sid-snapshot-20130701:1.29
	cgen-snapshot-20130701:1.29
	sid-snapshot-20130601:1.29
	cgen-snapshot-20130601:1.29
	sid-snapshot-20130501:1.29
	cgen-snapshot-20130501:1.29
	sid-snapshot-20130401:1.29
	cgen-snapshot-20130401:1.29
	sid-snapshot-20130301:1.29
	cgen-snapshot-20130301:1.29
	sid-snapshot-20130201:1.29
	cgen-snapshot-20130201:1.29
	sid-snapshot-20130101:1.29
	cgen-snapshot-20130101:1.29
	sid-snapshot-20121201:1.29
	cgen-snapshot-20121201:1.29
	sid-snapshot-20121101:1.29
	cgen-snapshot-20121101:1.29
	sid-snapshot-20121001:1.29
	cgen-snapshot-20121001:1.29
	sid-snapshot-20120901:1.29
	cgen-snapshot-20120901:1.29
	sid-snapshot-20120801:1.29
	cgen-snapshot-20120801:1.29
	sid-snapshot-20120701:1.29
	cgen-snapshot-20120701:1.29
	sid-snapshot-20120601:1.29
	cgen-snapshot-20120601:1.29
	sid-snapshot-20120501:1.29
	cgen-snapshot-20120501:1.29
	sid-snapshot-20120401:1.29
	cgen-snapshot-20120401:1.29
	sid-snapshot-20120301:1.29
	cgen-snapshot-20120301:1.29
	sid-snapshot-20120201:1.29
	cgen-snapshot-20120201:1.29
	sid-snapshot-20120101:1.29
	cgen-snapshot-20120101:1.29
	sid-snapshot-20111201:1.29
	cgen-snapshot-20111201:1.29
	sid-snapshot-20111101:1.29
	cgen-snapshot-20111101:1.29
	sid-snapshot-20111001:1.29
	cgen-snapshot-20111001:1.29
	sid-snapshot-20110901:1.29
	cgen-snapshot-20110901:1.29
	sid-snapshot-20110801:1.29
	cgen-snapshot-20110801:1.29
	sid-snapshot-20110701:1.29
	cgen-snapshot-20110701:1.29
	sid-snapshot-20110601:1.29
	cgen-snapshot-20110601:1.29
	sid-snapshot-20110501:1.29
	cgen-snapshot-20110501:1.29
	sid-snapshot-20110401:1.29
	cgen-snapshot-20110401:1.29
	sid-snapshot-20110301:1.29
	cgen-snapshot-20110301:1.29
	sid-snapshot-20110201:1.29
	cgen-snapshot-20110201:1.29
	sid-snapshot-20110101:1.29
	cgen-snapshot-20110101:1.29
	sid-snapshot-20101201:1.29
	cgen-snapshot-20101201:1.29
	sid-snapshot-20101101:1.29
	cgen-snapshot-20101101:1.29
	sid-snapshot-20101001:1.29
	cgen-snapshot-20101001:1.29
	sid-snapshot-20100901:1.29
	cgen-snapshot-20100901:1.29
	sid-snapshot-20100801:1.29
	cgen-snapshot-20100801:1.29
	sid-snapshot-20100701:1.29
	cgen-snapshot-20100701:1.29
	sid-snapshot-20100601:1.29
	cgen-snapshot-20100601:1.29
	sid-snapshot-20100501:1.29
	cgen-snapshot-20100501:1.29
	sid-snapshot-20100401:1.29
	cgen-snapshot-20100401:1.29
	sid-snapshot-20100301:1.29
	cgen-snapshot-20100301:1.29
	sid-snapshot-20100201:1.28
	cgen-snapshot-20100201:1.28
	sid-snapshot-20100101:1.27
	cgen-snapshot-20100101:1.27
	sid-snapshot-20091201:1.27
	cgen-snapshot-20091201:1.27
	sid-snapshot-20091101:1.26
	cgen-snapshot-20091101:1.26
	sid-snapshot-20091001:1.23
	cgen-snapshot-20091001:1.23
	arc-sim-20090309:1.18
	sid-snapshot-20090901:1.20
	cgen-snapshot-20090901:1.20
	sid-snapshot-20090801:1.20
	cgen-snapshot-20090801:1.20
	sid-snapshot-20090701:1.20
	cgen-snapshot-20090701:1.20
	dje-cgen-play1-branch:1.20.0.2
	dje-cgen-play1-branchpoint:1.20
	cgen-1_1-branch:1.19.0.2
	cgen-1_1-branchpoint:1.19
	sid-snapshot-20090601:1.18
	cgen-snapshot-20090601:1.18
	sid-snapshot-20090501:1.18
	cgen-snapshot-20090501:1.18
	sid-snapshot-20090401:1.18
	cgen-snapshot-20090401:1.18
	arc-insight_6_8-branch:1.18.0.2
	arc-insight_6_8-branchpoint:1.18
	sid-snapshot-20090301:1.18
	cgen-snapshot-20090301:1.18
	sid-snapshot-20090201:1.18
	cgen-snapshot-20090201:1.18
	sid-snapshot-20090101:1.18
	cgen-snapshot-20090101:1.18
	sid-snapshot-20081201:1.18
	cgen-snapshot-20081201:1.18
	sid-snapshot-20081101:1.18
	cgen-snapshot-20081101:1.18
	sid-snapshot-20081001:1.18
	cgen-snapshot-20081001:1.18
	sid-snapshot-20080901:1.18
	cgen-snapshot-20080901:1.18
	sid-snapshot-20080801:1.18
	cgen-snapshot-20080801:1.18
	sid-snapshot-20080701:1.18
	cgen-snapshot-20080701:1.18
	sid-snapshot-20080601:1.18
	cgen-snapshot-20080601:1.18
	sid-snapshot-20080501:1.18
	cgen-snapshot-20080501:1.18
	sid-snapshot-20080403:1.18
	sid-snapshot-20080401:1.18
	cgen-snapshot-20080401:1.18
	sid-snapshot-20080301:1.18
	cgen-snapshot-20080301:1.18
	sid-snapshot-20080201:1.18
	cgen-snapshot-20080201:1.18
	sid-snapshot-20080101:1.18
	cgen-snapshot-20080101:1.18
	sid-snapshot-20071201:1.18
	cgen-snapshot-20071201:1.18
	sid-snapshot-20071101:1.18
	cgen-snapshot-20071101:1.18
	sid-snapshot-20071001:1.18
	cgen-snapshot-20071001:1.18
	msnyder-fork-checkpoint-branch:1.14.0.2
	msnyder-fork-checkpoint-branchpoint:1.14
	sid-20020905-branchpoint:1.7
	sid-20020905-branch:1.7.0.4
	cagney_regbuf-20020515-branch:1.7.0.2
	cagney_regbuf-20020515-branchpoint:1.7
	cygnus_cvs_20020108_pre:1.6
	cgen-1-1-branch:1.4.0.2;
locks; strict;
comment	@# @;


1.29
date	2010.02.13.03.39.15;	author devans;	state Exp;
branches;
next	1.28;

1.28
date	2010.01.25.03.50.43;	author devans;	state Exp;
branches;
next	1.27;

1.27
date	2009.11.03.16.24.02;	author devans;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.26.00.56.34;	author devans;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.24.18.03.43;	author devans;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.24.00.20.30;	author devans;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.27.18.31.33;	author devans;	state Exp;
branches;
next	1.22;

1.22
date	2009.09.23.22.30.19;	author devans;	state Exp;
branches;
next	1.21;

1.21
date	2009.09.07.22.17.34;	author devans;	state Exp;
branches;
next	1.20;

1.20
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches;
next	1.19;

1.19
date	2009.06.20.21.34.28;	author devans;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2006.07.14.18.49.32;	author brolley;	state Exp;
branches;
next	1.17;

1.17
date	2006.05.09.19.00.12;	author brolley;	state Exp;
branches;
next	1.16;

1.16
date	2006.05.09.18.07.51;	author brolley;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.28.18.59.24;	author nathan;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.28.19.30.02;	author brolley;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.29.19.25.33;	author brolley;	state Exp;
branches;
next	1.12;

1.12
date	2005.06.15.21.28.19;	author brolley;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.16.05.35.47;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.10.18.26.02;	author brolley;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.15.07.25.02;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.03.23.07.50;	author fche;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.07.18.46.19;	author fche;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.07.08.23.59;	author bje;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.07.07.05.05;	author bje;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.12.02.54.39;	author fche;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.02.21.18.27;	author bje;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.29.18.56.26;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.08.22.34.20;	author bje;	state Exp;
branches;
next	;

1.19.2.1
date	2009.06.24.14.57.46;	author devans;	state Exp;
branches;
next	;


desc
@@


1.29
log
@update copyright year
@
text
@; CPU family related simulator generator, excluding decoding and model support.
; Copyright (C) 2000, 2002, 2003, 2005, 2006, 2009, 2010 Red Hat, Inc.
; This file is part of CGEN.

; ***********
; cgen-desc.h

(define (/last-insn)
  (string-upcase (gen-c-symbol (caar (list-take -1
       (gen-obj-list-enums (non-multi-insns (current-insn-list))))))))

; Declare the attributes.

(define (/gen-attr-decls)
  (string-list
   "// Insn attribute indices.\n\n"
   (gen-attr-enum-decl "cgen_insn" (current-insn-attr-list))
   "// Attributes.\n\n"
   (string-list-map gen-decl (current-attr-list))
   )
)

; Generate class to hold an instruction's attributes.

(define (/gen-insn-attr-decls)
   (let ((attrs (current-insn-attr-list)))
     (string-append
      "// Insn attributes.\n\n"
      ; FIXME: maybe make class, but that'll require a constructor.  Later.
      "struct @@arch@@_insn_attr {\n"
      "  unsigned int bools;\n"
      (string-map (lambda (attr)
		    (if (bool-attr? attr)
			""
			(string-append "  "
				       (gen-attr-type attr)
				       " "
				       (string-downcase (gen-sym attr))
				       ";\n")))
		  attrs)
      ;"public:\n"
      (string-map (lambda (attr)
		    (string-append
		     "  inline "
		     (gen-attr-type attr)
		     " get_" (string-downcase (gen-sym attr)) "_attr"
		     " () { return "
		     (if (bool-attr? attr)
			 (string-append "(bools & "
					(gen-attr-mask "cgen_insn" (obj:name attr))
					") != 0")
			 (string-downcase (gen-sym attr)))
		     "; }\n"))
		  attrs)
				   
      "};\n\n"
      ))
)


; Emit a macro that specifies the word-bitsize for each machine.
(define (/gen-mach-params)
  (string-map (lambda (mach) 
		(string-append
		 "#define MACH_" (string-upcase (gen-sym mach)) "_INSN_CHUNK_BITSIZE "
		 (number->string (cpu-insn-chunk-bitsize (mach-cpu mach))) "\n"))
	      (current-mach-list))
)


; Generate <cpu>-desc.h.

(define (cgen-desc.h)
  (logit 1 "Generating " (gen-cpu-name) "-desc.h ...\n")

  (string-write
   (gen-c-copyright "Misc. entries in the @@arch@@ description file."
		  copyright-red-hat package-red-hat-simulators)
   "\
#ifndef DESC_@@ARCH@@_H
#define DESC_@@ARCH@@_H

#include \"cgen/bitset.h\"

namespace @@arch@@ {
\n"

   (let ((enums (find (lambda (obj) (not (obj-has-attr? obj 'VIRTUAL)))
		      (current-enum-list))))
     (if (null? enums)
	 ""
	 (string-list
	  "// Enums.\n\n"
	  (string-map gen-decl enums))))

   /gen-attr-decls
   /gen-insn-attr-decls
   /gen-mach-params

   "
} // end @@arch@@ namespace

#endif /* DESC_@@ARCH@@_H */\n"
   )
)

; **********
; cgen-cpu.h

; Print out file containing elements to add to cpu class.

; Get/set fns for hardware element HW.

(define (/gen-reg-access-defns hw)
  (let ((scalar? (hw-scalar? hw))
	(name (obj:name hw))
	(getter (hw-getter hw))
	(setter (hw-setter hw))
	(type (gen-type hw)))
    (let ((get-code (if getter
			(let ((mode (hw-mode hw))
			      (args (car getter))
			      (expr (cadr getter)))
			  (string-append
			   "return "
			   (rtl-c++ mode
				    #f ;; h/w is not ISA-specific
				    (if scalar?
					nil
					(list (list (car args) 'UINT "regno")))
				    expr
				    #:rtl-cover-fns? #t)
			   ";"))
			(string-append
			 "return this->hardware."
			 (gen-c-symbol name)
			 (if scalar? "" "[regno]")
			 ";")))
	  (set-code (if setter
			(let ((args (car setter))
			      (expr (cadr setter)))
			  (rtl-c++
			   VOID ; not `mode', sets have mode VOID
			   #f ;; h/w is not ISA-specific
			   (if scalar?
			       (list (list (car args) (hw-mode hw) "newval"))
			       (list (list (car args) 'UINT "regno")
				     (list (cadr args) (hw-mode hw) "newval")))
			   expr
			   #:rtl-cover-fns? #t))
			(string-append
			 "this->hardware."
			 (gen-c-symbol name)
			 (if scalar? "" "[regno]")
			 " = newval;"))))
      (string-append
       "  inline " type " "
       (gen-reg-get-fun-name hw)
       " ("
       (if scalar? "" "UINT regno")
       ") const"
       " { " get-code " }"
       "\n"
       "  inline void "
       (gen-reg-set-fun-name hw)
       " ("
       (if scalar? "" "UINT regno, ")
       type " newval)"
       " { " set-code " }"
       "\n\n")))
)

; Return a boolean indicating if hardware element HW needs storage allocated
; for it in the SIM_CPU struct.

(define (hw-need-storage? hw)
  (and (register? hw)
       (not (obj-has-attr? hw 'VIRTUAL)))
)

(define (hw-need-write-stack? hw)
  (and (register? hw) (hw-used-in-delay-rtl? hw))
)

; Subroutine of /gen-hardware-types to generate the struct containing
; hardware elements of one isa.

(define (/gen-hardware-struct prefix hw-list)
  (if (null? hw-list)
      ; If struct is empty, leave it out to simplify generated code.
      ""
      (string-list
       (if prefix
	   (string-append "  // Hardware elements for " prefix ".\n")
	   "  // Hardware elements.\n")
       "  struct {\n"
       (string-list-map gen-defn hw-list)
       "  } "
       (if prefix
	   (string-append prefix "_")
	   "")
       "hardware;\n\n"
       ))
)

; Return C type declarations of all of the hardware elements.
; The name of the type is prepended with the cpu family name.

(define (/gen-hardware-types)
  (string-list
   "// CPU state information.\n\n"
   (/gen-hardware-struct #f (find hw-need-storage? (current-hw-list))))
)

(define (/gen-hw-stream-and-destream-fns) 
  (let* ((sa string-append)
	 (regs (find hw-need-storage? (current-hw-list)))
	 (stack-regs (find hw-need-write-stack? (current-hw-list)))
	 (reg-dim (lambda (r) 
		    (let ((dims (/hw-vector-dims r)))
		      (if (equal? 0 (length dims)) 
			  "0"
			  (number->string (car dims))))))
	 (write-stacks 
	  (map (lambda (n) (sa n "_writes"))
	       (append (map (lambda (r) (gen-c-symbol (obj:name r))) stack-regs)
		       (map (lambda (m) (sa (symbol->string m) "_memory")) write-stack-memory-mode-names))))
	 (stream-reg (lambda (r) 
		       (let ((rname (sa "hardware." (gen-c-symbol (obj:name r)))))
			 (if (hw-scalar? r)
			     (sa "    ost << " rname " << ' ';\n")
			     (sa "    for (int i = 0; i < " (reg-dim r) 
				 "; i++)\n      ost << " rname "[i] << ' ';\n")))))
	 (destream-reg (lambda (r) 
			 (let ((rname (sa "hardware." (gen-c-symbol (obj:name r)))))
			   (if (hw-scalar? r)
			       (sa "    ist >> " rname ";\n")
			       (sa "    for (int i = 0; i < " (reg-dim r) 
				   "; i++)\n      ist >> " rname "[i];\n")))))
	 (stream-stacks (lambda (s) (sa "    stream_stacks ( stacks." s ", ost);\n")))
	 (destream-stacks (lambda (s) (sa "    destream_stacks ( stacks." s ", ist);\n")))
	 (stack-boilerplate
	  (sa
	   "  template <typename ST> \n"
	   "  void stream_stacks (const ST &st, std::ostream &ost) const\n"
	   "  {\n"
	   "    for (int i = 0; i < @@prefix@@::pipe_sz; i++)\n"
	   "    {\n"
	   "      ost << st[i].t << ' ';\n"
	   "      for (int j = 0; j <= st[i].t; j++)\n"
	   "      {\n"
	   "        ost << st[i].buf[j].pc << ' ';\n"
	   "        ost << st[i].buf[j].val << ' ';\n"
	   "        ost << st[i].buf[j].idx0 << ' ';\n"
	   "      }\n"
	   "    }\n"
	   "  }\n"
	   "  \n"
	   "  template <typename ST> \n"
	   "  void destream_stacks (ST &st, std::istream &ist)\n"
	   "  {\n"
	   "    for (int i = 0; i < @@prefix@@::pipe_sz; i++)\n"
	   "    {\n"
	   "      ist >> st[i].t;\n"
	   "      for (int j = 0; j <= st[i].t; j++)\n"
	   "      {\n"
	   "        ist >> st[i].buf[j].pc;\n"
	   "        ist >> st[i].buf[j].val;\n"
	   "        ist >> st[i].buf[j].idx0;\n"
	   "      }\n"
	   "    }\n"
	   "  }\n"
	   "  \n")))
    (sa
     "  void stream_cgen_hardware (std::ostream &ost) const \n  {\n"
     (string-map stream-reg regs)
     "  }\n"
     "  void destream_cgen_hardware (std::istream &ist) \n  {\n"
     (string-map destream-reg regs)
     "  }\n"
     (if (with-parallel?) 
	 (sa stack-boilerplate
	     "  void stream_cgen_write_stacks (std::ostream &ost, "
	     "const @@prefix@@::write_stacks &stacks) const \n  {\n"
	     (string-map stream-stacks write-stacks)
	     "  }\n"
	     "  void destream_cgen_write_stacks (std::istream &ist, "
	     "@@prefix@@::write_stacks &stacks) \n  {\n"
	     (string-map destream-stacks write-stacks)
	     "  }\n")
	 ""))))


; Generate <cpu>-cpu.h

(define (cgen-cpu.h)
  (logit 1 "Generating " (gen-cpu-name) "-cpu.h ...\n")
  (assert-keep-one)

  ; Turn parallel execution support on if cpu needs it.
  (set-with-parallel?! (state-parallel-exec?))

  ; Initialize rtl->c generation.
  (rtl-c-config! #:rtl-cover-fns? #t)

  (string-write
   (gen-c-copyright "CPU class elements for @@cpu@@."
		  copyright-red-hat package-red-hat-simulators)
   "\
// This file is included in the middle of the cpu class struct.

public:
\n"

   /gen-hardware-types

   /gen-hw-stream-and-destream-fns

   "  // C++ register access function templates\n"
   "#define current_cpu this\n\n"
   (lambda ()
     (string-list-map /gen-reg-access-defns
		      (find register? (current-hw-list))))
   "#undef current_cpu\n\n"
   )
)

; **********
; cgen-defs.h

; Print various parameters of the cpu family.
; A "cpu family" here is a collection of variants of a particular architecture
; that share sufficient commonality that they can be handled together.

(define (/gen-cpu-defines)
  (string-append
   "\
/* Maximum number of instructions that are fetched at a time.
   This is for LIW type instructions sets (e.g. m32r).  */\n"
   "#define @@CPU@@_MAX_LIW_INSNS " (number->string (cpu-liw-insns (current-cpu))) "\n\n"
   "/* Maximum number of instructions that can be executed in parallel.  */\n"
   "#define @@CPU@@_MAX_PARALLEL_INSNS " (number->string (cpu-parallel-insns (current-cpu))) "\n"
   "\n"
;   (gen-enum-decl '@@prefix@@_virtual
;		  "@@prefix@@ virtual insns"
;		  "@@ARCH@@_INSN_" ; not @@CPU@@ to match CGEN_INSN_TYPE in opc.h
;		  '((x-invalid 0)
;		    (x-before -1) (x-after -2)
;		    (x-begin -3) (x-chain -4) (x-cti-chain -5)))
   )
)

; Generate type of struct holding model state while executing.

(define (/gen-model-decls)
  (logit 2 "Generating model decls ...\n")
  (string-list
   (string-list-map
    (lambda (model)
      (string-list
       "typedef struct {\n"
       (if (null? (model:state model))
	   "  int empty;\n"
	   (string-map (lambda (var)
			 (string-append "  "
					(mode:c-type (mode:lookup (cadr var)))
					" "
					(gen-c-symbol (car var))
					";\n"))
		       (model:state model)))
       "} " 
       (if (null? (model:state model)) "BLANK" "@@CPU@@") "_MODEL_DATA;\n\n"
       ))
    (current-model-list))
   "   
typedef int (@@CPU@@_MODEL_FN) (struct @@cpu@@_cpu*, void*);

typedef struct {
  /* This is an integer that identifies this insn.
     How this works is up to the target.  */
  int num;

  /* Function to handle insn-specific profiling.  */
  @@CPU@@_MODEL_FN *model_fn;

  /* Array of function units used by this insn.  */
  UNIT units[MAX_UNITS];
} @@CPU@@_INSN_TIMING;"
   )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; begin stack-based write schedule
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define write-stack-memory-mode-names '())

(define (/calculated-memory-write-buffer-size)
  (let* ((is-mem? (lambda (op) (eq? (hw-sem-name (op:type op)) 'h-memory)))
	 (count-mem-writes
	  (lambda (sfmt) (length (find is-mem? (sfmt-out-ops sfmt))))))
    (apply max (append '(0) (map count-mem-writes (current-sfmt-list))))))


;; note: this doesn't really correctly approximate the worst case. user-supplied functions
;; might rewrite the pipeline extensively while it's running. 
;(define (/worst-case-number-of-writes-to hw-name)
;  (let* ((sfmts (current-sfmt-list))
;	 (out-ops (map sfmt-out-ops sfmts))
;	 (pred (lambda (op) (equal? hw-name (gen-c-symbol (obj:name (op:type op))))))
;	 (filtered-ops (map (lambda (ops) (find pred ops)) out-ops)))
;    (apply max (cons 0 (map (lambda (ops) (length ops)) filtered-ops)))))
	 
(define (/hw-gen-write-stack-decl nm mode)
  (let* (
; for the time being, we're disabling this size-estimation stuff and just
; requiring the user to supply a parameter WRITE_BUF_SZ before they include -defs.h
;	 (pipe-sz (+ 1 (max-delay (cpu-max-delay (current-cpu)))))
;	 (sz (* pipe-sz (/worst-case-number-of-writes-to nm))))
	 
	 (mode-pad (spaces (- 4 (string-length (symbol->string mode)))))
	 (stack-name (string-append nm "_writes")))
    (string-append
     "  write_stack< write<" (symbol->string mode) "> >" mode-pad "\t" stack-name "\t[pipe_sz];\n")))


(define (/hw-gen-write-struct-decl)
  (let* ((dims (/worst-case-index-dims))
	 (sa string-append)
	 (ns number->string)
	 (idxs (iota dims))
	 (ctor (sa "write (PCADDR _pc, MODE _val"
		   (string-map (lambda (x) (sa ", USI _idx" (ns x) "=0")) idxs)
		   ") : pc(_pc), val(_val)"
		   (string-map (lambda (x) (sa ", idx" (ns x) "(_idx" (ns x) ")")) idxs)
		   " {} \n"))
	 (idx-fields (string-map (lambda (x) (sa "    USI idx" (ns x) ";\n")) idxs)))
    (sa
     "\n\n"
     "  template <typename MODE>\n"
     "  struct write\n"
     "  {\n"
     "    USI pc;\n"
     "    MODE val;\n"
     idx-fields
     "    " ctor 
     "    write() {}\n"
     "  };\n" )))
	       
(define (/hw-vector-dims hw) (elm-get (hw-type hw) 'dimensions))			    
(define (/worst-case-index-dims)
  (apply max
	 (append '(1) ; for memory accesses
		 (map (lambda (hw) (length (/hw-vector-dims hw))) 
		      (find (lambda (hw) (not (scalar? hw))) (current-hw-list))))))


(define (/gen-writestacks)
  (let* ((hw (find hw-need-write-stack? (current-hw-list)))
	 (modes write-stack-memory-mode-names) 
	 (hw-pairs (map (lambda (h) (list (gen-c-symbol (obj:name h))
					    (obj:name (hw-mode h)))) 
			hw))
	 (mem-pairs (map (lambda (m) (list (string-append (symbol->string m)
							  "_memory") m)) 
			 modes))
	 (all-pairs (append mem-pairs hw-pairs))

	 (h1 "\n\n// write stacks used in parallel execution\n\n  struct write_stacks\n  {\n  // types of stacks\n\n")
	 (wb (string-append
	      "\n\n  // unified writeback function (defined in @@prefix@@-write.cc)"
	        "\n  void writeback (int tick, @@cpu@@::@@cpu@@_cpu* current_cpu);"
		"\n  // unified write-stack clearing function (defined in @@prefix@@-write.cc)"
	        "\n  void reset ();"))
	 (zz "\n\n  }; // end struct @@prefix@@::write_stacks \n\n"))    
    (string-append	
     (/hw-gen-write-struct-decl)
     (foldl (lambda (s pair) (string-append s (apply /hw-gen-write-stack-decl pair))) h1 all-pairs)	  
     wb
     zz)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; end stack-based write schedule
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	  

; Generate the definition of the structure that holds register values, etc.
; for use during parallel execution.  

(define (gen-write-stack-structure)
  (let ((membuf-sz (/calculated-memory-write-buffer-size))
	(max-delay (cpu-max-delay (current-cpu))))
    (logit 2 "Generating write stack structure ...\n")
    (string-append
     "  static const int max_delay = "   
     (number->string max-delay) ";\n"
     "  static const int pipe_sz = "     
     (number->string (+ 1 max-delay)) "; // max_delay + 1\n"

"
  template <typename ELT> 
  struct write_stack 
  {
    int t;
    const int sz;
    ELT buf[WRITE_BUF_SZ];

    write_stack       ()             : t(-1), sz(WRITE_BUF_SZ) {}
    inline bool empty ()             { return (t == -1); }
    inline void clear ()             { t = -1; }
    inline void pop   ()             { if (t > -1) t--;}
    inline void push  (const ELT &e) { if (t+1 < sz) buf [++t] = e;}
    inline ELT &top   ()             { return buf [t>0 ? ( t<sz ? t : sz-1) : 0];}
  };

  // look ahead for latest write with index = idx, where time of write is
  // <= dist steps from base (present) in write_stack array st.
  // returning def if no scheduled write is found.

  template <typename STKS, typename VAL>
  inline VAL lookahead (int dist, int base, STKS &st, VAL def, int idx=0)
  {
    for (; dist > 0; --dist)
    {
      write_stack <VAL> &v = st [(base + dist) % pipe_sz];
      for (int i = v.t; i > 0; --i) 
	  if (v.buf [i].idx0 == idx) return v.buf [i];
    }
    return def;
  }

"
 
     (/gen-writestacks)     
     )))

; Generate the TRACE_RECORD struct definition.

(define (/gen-trace-record-type)
  (string-list
   "\
/* Collection of various things for the trace handler to use.  */

typedef struct @@prefix@@_trace_record {
  PCADDR pc;
  /* FIXME:wip */
} @@CPU@@_TRACE_RECORD;
\n"
   )
)

; Generate <cpu>-defs.h

(define (cgen-defs.h)
  (logit 1 "Generating " (gen-cpu-name) "-defs.h ...\n")
  (assert-keep-one)

  ; Turn parallel execution support on if cpu needs it.
  (set-with-parallel?! (state-parallel-exec?))

  ; Initialize rtl->c generation.
  (rtl-c-config! #:rtl-cover-fns? #t)

  (string-write
   (gen-c-copyright "CPU family header for @@cpu@@ / @@prefix@@."
		  copyright-red-hat package-red-hat-simulators)
   "\
#ifndef DEFS_@@PREFIX@@_H
#define DEFS_@@PREFIX@@_H

")
   (if (with-parallel?)
       (string-write "\
#include <stack>
#include \"cgen-types.h\"

// forward declaration\n\n  
namespace @@cpu@@ {
struct @@cpu@@_cpu;
}

namespace @@prefix@@ {

using namespace cgen;

"
		     gen-write-stack-structure
		     "\
} // end @@prefix@@ namespace
"))
   (string-write "\

#endif /* DEFS_@@PREFIX@@_H */\n"
   )
)

; **************
; cgen-write.cxx

; This is the other way of implementing parallel execution support.
; Instead of fetching all the input operands first, write all the output
; operands and their addresses to holding variables, and then run a
; post-processing pass to update the cpu state.

; Return C code to fetch and save all output operands to instructions with
; <sformat> SFMT.


; Generate <cpu>-write.cxx.

(define (/gen-register-writer nm mode dims)
  (let* ((pad "    ")
	 (sa string-append)
	 (mode (symbol->string mode))
	 (idx-args (string-map (lambda (x) (sa "w.idx" (number->string x) ", ")) 
			       (iota dims))))
    (sa pad "while (! " nm "_writes[tick].empty())\n"
	pad "{\n"
	pad "  write<" mode "> &w = " nm "_writes[tick].top();\n"
	pad "  current_cpu->" nm "_set(" idx-args "w.val);\n"
	pad "  " nm "_writes[tick].pop();\n"
	pad "}\n\n")))

(define (/gen-memory-writer nm mode dims)
  (let* ((pad "    ")
	 (sa string-append)
	 (mode (symbol->string mode))
	 (idx-args (string-map (lambda (x) (sa ", w.idx" (number->string x) "")) 
			       (iota dims))))
    (sa pad "while (! " nm "_writes[tick].empty())\n"
	pad "{\n"
	pad "  write<" mode "> &w = " nm "_writes[tick].top();\n"
	pad "  current_cpu->SETMEM" mode " (w.pc" idx-args ", w.val);\n"
	pad "  " nm "_writes[tick].pop();\n"
	pad "}\n\n")))


(define (/gen-reset-fn)
  (let* ((sa string-append)
	 (objs (append (map (lambda (h) (gen-c-symbol (obj:name h))) 
			    (find hw-need-write-stack? (current-hw-list)))
		       (map (lambda (m) (sa (symbol->string m) "_memory"))
			    write-stack-memory-mode-names)))
	 (clr (lambda (elt) (sa "    clear_stacks (" elt "_writes);\n"))))
    (sa 
     "  template <typename ST> \n"
     "  static void clear_stacks (ST &st)\n"
     "  {\n"
     "    for (int i = 0; i < @@prefix@@::pipe_sz; i++)\n"
     "      st[i].clear();\n"
     "  }\n\n"
     "  void @@prefix@@::write_stacks::reset ()\n  {\n"
     (string-map clr objs)
     "  }")))

(define (/gen-unified-write-fn) 
  (let* ((hw (find hw-need-write-stack? (current-hw-list)))
	 (modes write-stack-memory-mode-names)	
	 (hw-triples (map (lambda (h) (list (gen-c-symbol (obj:name h))
					    (obj:name (hw-mode h))
					    (length (/hw-vector-dims h)))) 
			hw))
	 (mem-triples (map (lambda (m) (list (string-append (symbol->string m)
							    "_memory")
					     m 1)) 
			 modes)))
    (logit 2 "Generating writer function ...\n") 
    (string-append
     "
  void @@prefix@@::write_stacks::writeback (int tick, @@cpu@@::@@cpu@@_cpu* current_cpu) 
  {
"
     "\n    // register writeback loops\n"
     (string-map (lambda (t) (apply /gen-register-writer t)) hw-triples)
     "\n    // memory writeback loops\n"
     (string-map (lambda (t) (apply /gen-memory-writer t)) mem-triples)
"
  }
")))

(define (cgen-write.cxx)
  (logit 1 "Generating " (gen-cpu-name) "-write.cxx ...\n")
  (assert-keep-one)

  (sim-analyze-insns!)

  ; Turn parallel execution support off.
  (set-with-parallel?! #f)

  ; Tell the rtx->c translator we are the simulator.
  (rtl-c-config! #:rtl-cover-fns? #t)

  (string-write
   (gen-c-copyright (string-append "Simulator instruction operand writer for "
				   (symbol->string (current-arch-name))
				   ".")
		 copyright-red-hat package-red-hat-simulators)
   "\

#include \"@@cpu@@.h\"

"
   /gen-reset-fn
   /gen-unified-write-fn
   )
)

; ******************
; cgen-semantics.cxx

; Return C code to perform the semantics of INSN.

(define (gen-semantic-code insn)
  (cond ((insn-compiled-semantics insn)
	 => (lambda (sem)
	      (rtl-c++-parsed VOID sem
			      #:for-insn? #t
			      #:rtl-cover-fns? #t
			      #:owner insn)))
	((insn-canonical-semantics insn)
	 => (lambda (sem)
	      (rtl-c++-parsed VOID sem
			      #:for-insn? #t
			      #:rtl-cover-fns? #t
			      #:owner insn)))
	(else
	 (context-error (make-obj-context insn #f)
			"While generating semantic code"
			"semantics of insn are not canonicalized")))
)

; Return definition of C function to perform INSN.
; This version handles the with-scache case.

(define (/gen-scache-semantic-fn insn)
  (logit 2 "Processing semantics for " (obj:name insn) ": \"" (insn-syntax insn) "\" ...\n")
  (set! /with-profile? /with-profile-fn?)
  (let ((cti? (insn-cti? insn))
	(insn-len (insn-length-bytes insn)))
    (string-list
     "// ********** " (obj:name insn) ": " (insn-syntax insn) "\n\n"
     (if (with-parallel?)
	 "void\n"
	 "sem_status\n")
     "@@prefix@@_sem_" (gen-sym insn)
     (if (with-parallel?)
	 (string-append " (@@cpu@@_cpu* current_cpu, @@prefix@@_scache* sem, const int tick, \n\t"
			"@@prefix@@::write_stacks &buf)\n")
	 " (@@cpu@@_cpu* current_cpu, @@prefix@@_scache* sem)\n")
     "{\n"
     (gen-define-field-macro (insn-sfmt insn))
     "  sem_status status = SEM_STATUS_NORMAL;\n"
     "  @@prefix@@_scache* abuf = sem;\n"
     ; Unconditionally written operands are not recorded here.
     (if (or (with-profile?) (with-parallel-write?))
	 "  unsigned long long written = 0;\n"
	 "")
     ; The address of this insn, needed by extraction and semantic code.
     ; Note that the address recorded in the cpu state struct is not used.
     ; For faster engines that copy will be out of date.
     "  PCADDR pc = abuf->addr;\n"
     "  PCADDR npc = pc + " (number->string insn-len) ";\n"
     "\n"
     (gen-semantic-code insn)
     "\n"
     ; Only update what's been written if some are conditionally written.
     ; Otherwise we know they're all written so there's no point in
     ; keeping track.
     (if (or (with-profile?) (with-parallel-write?))
	 (if (/any-cond-written? (insn-sfmt insn))
	     "  abuf->written = written;\n"
	     "")
	 "")
     (if cti?
	 "  current_cpu->done_cti_insn (npc, status);\n"
	 "  current_cpu->done_insn (npc, status);\n")
     (if (with-parallel?)
	 ""
	 "  return status;\n")
     (gen-undef-field-macro (insn-sfmt insn))
      "}\n\n"
     ))
)

(define (/gen-all-semantic-fns)
  (logit 2 "Processing semantics ...\n")
  (let ((insns (scache-engine-insns)))
    (if (with-scache?)
	(string-write-map /gen-scache-semantic-fn insns)
	(error "must specify `with-scache'")))
)

; Generate <cpu>-sem.cxx.
; Each instruction is implemented in its own function.

(define (cgen-semantics.cxx)
  (logit 1 "Generating " (gen-cpu-name) "-semantics.cxx ...\n")
  (assert-keep-one)

  (sim-analyze-insns!)

  ; Turn parallel execution support on if cpu needs it.
  (set-with-parallel?! (state-parallel-exec?))

  ; Tell the rtx->c translator we are the simulator.
  (rtl-c-config! #:rtl-cover-fns? #t)

  ; Indicate we're currently not generating a pbb engine.
  (set-current-pbb-engine?! #f)

  (string-write
   (gen-c-copyright "Simulator instruction semantics for @@prefix@@."
		  copyright-red-hat package-red-hat-simulators)
   "\

#if HAVE_CONFIG_H
#include \"config.h\"
#endif
#include \"@@cpu@@.h\"

using namespace @@cpu@@; // FIXME: namespace organization still wip\n")
  (if (with-parallel?)
      (string-write "\
using namespace @@prefix@@; // FIXME: namespace organization still wip\n"))
  (string-write "\
#define GET_ATTR(name) GET_ATTR_##name ()

\n"

   /gen-all-semantic-fns
   )
)

; *******************
; cgen-sem-switch.cxx
;
; The semantic switch engine has two flavors: one case per insn, and one
; case per "frag" (where each insn is split into one or more fragments).

; Utility of /gen-sem-case to return the mask of operands always written
; to in <sformat> SFMT.
; ??? Not currently used.

(define (/uncond-written-mask sfmt)
  (apply + (map (lambda (op)
		  (if (op:cond? op)
		      0
		      (logsll 1 (op:num op))))
		(sfmt-out-ops sfmt)))
)

; Utility of /gen-sem-case to return #t if any operand in <sformat> SFMT is
; conditionally written to.

(define (/any-cond-written? sfmt)
  (any-true? (map op:cond? (sfmt-out-ops sfmt)))
)

; One case per insn version.

; Generate a switch case to perform INSN.

(define (/gen-sem-case insn parallel?)
  (logit 2 "Processing "
	 (if parallel? "parallel " "")
	 "semantic switch case for " (obj:name insn) ": \""
	 (insn-syntax insn) "\" ...\n")
  (set! /with-profile? /with-profile-sw?)
  (let ((cti? (insn-cti? insn))
	(insn-len (insn-length-bytes insn)))
    (string-list
     ; INSN_ is prepended here and not elsewhere to avoid name collisions
     ; with symbols like AND, etc.
     "\
// ********** " (insn-syntax insn) "

  CASE (INSN_" (if parallel? "PAR_" "") (string-upcase (gen-sym insn)) "):
    {
      @@prefix@@_scache* abuf = vpc;\n"
     (if (with-scache?)
	 (gen-define-field-macro (insn-sfmt insn))
	 "")
     ; Unconditionally written operands are not recorded here.
     (if (or (with-profile?) (with-parallel-write?))
	 "      unsigned long long written = 0;\n"
	 "")
     ; The address of this insn, needed by extraction and semantic code.
     ; Note that the address recorded in the cpu state struct is not used.
     "      PCADDR pc = abuf->addr;\n"
     (if (and cti? (not parallel?))
	 (string-append "      PCADDR npc;\n"
			"      branch_status br_status = BRANCH_UNTAKEN;\n")
	 "")
     (string-list "      vpc = vpc + 1;\n")
     ; Emit setup-semantics code for real insns.
     (if (and (insn-real? insn)
	      (isa-setup-semantics (current-isa)))
	 (string-append
	  "      "
	  (rtl-c++ VOID (obj-isa-list insn) nil
		   (isa-setup-semantics (current-isa))
		   #:for-insn? #t
		   #:rtl-cover-fns? #t
		   #:owner insn))
	 "")
     "\n"
     (gen-semantic-code insn)
     "\n"
     ; Only update what's been written if some are conditionally written.
     ; Otherwise we know they're all written so there's no point in
     ; keeping track.
     (if (or (with-profile?) (with-parallel-write?))
	 (if (/any-cond-written? (insn-sfmt insn))
	     "        abuf->written = written;\n"
	     "")
	 "")
     (if (and cti? (not parallel?))
	 (string-append "      pbb_br_npc = npc;\n"
			"      pbb_br_status = br_status;\n")
	 "")
     (if (with-scache?)
	 (gen-undef-field-macro (insn-sfmt insn))
	 "")
     "    }\n"
     "    NEXT (vpc);\n\n"
     ))
)

(define (/gen-sem-switch)
  (logit 2 "Processing semantic switch ...\n")
  ; Turn parallel execution support off.
  (set-with-parallel?! #f)
  (string-write-map (lambda (insn) (/gen-sem-case insn #f))
		    (non-multi-insns (non-alias-insns (current-insn-list))))
)

; Generate the guts of a C switch statement to execute parallel instructions.
; This switch is included after the non-parallel instructions in the semantic
; switch.
;
; ??? We duplicate the writeback case for each insn, even though we only need
; one case per insn format.  The former keeps the code for each insn
; together and might improve cache usage.  On the other hand the latter
; reduces the amount of code, though it is believed that in this particular
; instance the win isn't big enough.

(define (/gen-parallel-sem-switch)
  (logit 2 "Processing parallel insn semantic switch ...\n")
  ; Turn parallel execution support on.
  (set-with-parallel?! #t)
  (string-write-map (lambda (insn)
		      (string-list (/gen-sem-case insn #t)
				   (/gen-write-case (insn-sfmt insn) insn)))
		    (parallel-insns (current-insn-list)))
)

; Return computed-goto engine.

(define (/gen-sem-switch-engine)
  (string-write
   "\
void
@@cpu@@_cpu::@@prefix@@_pbb_run ()
{
  @@cpu@@_cpu* current_cpu = this;
  @@prefix@@_scache* vpc;
  // These two are used to pass data from cti insns to the cti-chain insn.
  PCADDR pbb_br_npc;
  branch_status pbb_br_status;

#ifdef __GNUC__
{
  static const struct sem_labels
    {
      enum @@prefix@@_insn_type insn;
      void *label;
    }
  labels[] = 
    {\n"

   (lambda ()
     (string-write-map (lambda (insn)
			 (string-append "      { "
					"@@PREFIX@@_INSN_"
					(string-upcase (gen-sym insn))
					", && case_INSN_"
					(string-upcase (gen-sym insn))
					" },\n"))
		       (non-multi-insns (non-alias-insns (current-insn-list)))))

   (if (state-parallel-exec?)
       (lambda ()
	 (string-write-map (lambda (insn)
			     (string-append "      { "
					    "@@PREFIX@@_INSN_PAR_"
					    (string-upcase (gen-sym insn))
					    ", && case_INSN_PAR_"
					    (string-upcase (gen-sym insn))
					    " },\n"
					    "      { "
					    "@@PREFIX@@_INSN_WRITE_"
					    (string-upcase (gen-sym insn))
					    ", && case_INSN_WRITE_"
					    (string-upcase (gen-sym insn))
					    " },\n"))
			   (parallel-insns (current-insn-list))))
       "")

   "    { (@@prefix@@_insn_type) 0, 0 }
  };

  if (! @@prefix@@_idesc::idesc_table_initialized_p)
    {
      for (int i=0; labels[i].label != 0; i++)
	@@prefix@@_idesc::idesc_table[labels[i].insn].cgoto.label = labels[i].label; 

      // confirm that table is all filled up
      for (int i = 0; i <= @@PREFIX@@_INSN_" (/last-insn) "; i++)
        assert (@@prefix@@_idesc::idesc_table[i].cgoto.label != 0);

      // Initialize the compiler virtual insn.
      current_cpu->@@prefix@@_engine.compile_begin_insn (current_cpu);

      @@prefix@@_idesc::idesc_table_initialized_p = true;
    }
}
#endif

#ifdef __GNUC__
#define CASE(X) case_##X
// Branch to next handler without going around main loop.
#define NEXT(vpc) goto * vpc->execute.cgoto.label;
// Break out of threaded interpreter and return to \"main loop\".
#define BREAK(vpc) goto end_switch
#else
#define CASE(X) case @@PREFIX@@_##X
#define NEXT(vpc) goto restart
#define BREAK(vpc) break
#endif

  // Get next insn to execute.
  vpc = current_cpu->@@prefix@@_engine.get_next_vpc (current_cpu->h_pc_get ());

restart:
#ifdef __GNUC__
  goto * vpc->execute.cgoto.label;
#else
  switch (vpc->idesc->sem_index)
#endif

  {
"

  /gen-sem-switch

   (if (state-parallel-exec?)
       /gen-parallel-sem-switch
       "")

"
#ifdef __GNUC__
    end_switch: ;
#else
    default: abort();
#endif
  }

  // Save vpc for next time.
  current_cpu->@@prefix@@_engine.set_next_vpc (vpc);
}
\n"
   )
)

; Semantic frag version.

; Return declaration of frag enum.

(define (/gen-sfrag-enum-decl frag-list)
  (gen-enum-decl "@@prefix@@_frag_type"
		 "semantic fragments in cpu family @@prefix@@"
		 "@@PREFIX@@_FRAG_"
		 (append '((list-end))
			 (map (lambda (i)
				(cons (obj:name i)
				      (cons '-
					    (atlist-attrs (obj-atlist i)))))
			      frag-list)
			 '((max))))
)

; Return header file decls for semantic frag threaded engine.

(define (/gen-sfrag-engine-decls)
  (string-write
   "namespace @@cpu@@ {\n\n"

   ; FIXME: vector->list
   (/gen-sfrag-enum-decl (vector->list (sim-sfrag-frag-table)))

   "\
struct @@prefix@@_insn_frag {
  @@PREFIX@@_INSN_TYPE itype;
  // 4: header+middle+trailer+delimiter
  @@PREFIX@@_FRAG_TYPE ftype[4];
};

struct @@prefix@@_pbb_label {
  @@PREFIX@@_FRAG_TYPE frag;
  void *label;
};

} // end @@cpu@@ namespace
\n")
)

; Return C code to perform the semantics of FRAG.
; LOCALS is a list of sequence locals made global to all frags.
; Each element is (symbol <mode> "c-var-name").

(define (/gen-sfrag-code frag locals)
  (let ((sem (sfrag-semantics frag))
	; If the frag has one owner, use it.  Otherwise indicate the owner is
	; unknown.  In cases where the owner is needed by the semantics, the
	; frag should have only one owner.  In practice this means that frags
	; with the ref,current-insn rtx cannot be used by multiple insns.
	(owner (if (= (length (sfrag-users frag)) 1)
		   (car (sfrag-users frag))
		   #f)))
    ;; NOTE: (sfrag-users frag) is nil for the x-header and x-trailer frags.
    ;; They are just nops.
    (rtl-c++ VOID (and owner (obj-isa-list owner)) locals sem
	     #:for-insn? #t
	     #:rtl-cover-fns? #t
	     #:owner owner))
)

; Generate a switch case to perform FRAG.
; LOCALS is a list of sequence locals made global to all frags.
; Each element is (symbol <mode> "c-var-name").

(define (/gen-sfrag-case frag locals)
  (set! /with-profile? /with-profile-sw?)
  (let ((cti? (sfmt-cti? (sfrag-sfmt frag)))
	(parallel? (sfrag-parallel? frag)))
    (logit 2 "Processing "
	   (if parallel? "parallel " "")
	   "semantic switch case for " (obj:name frag) " ...\n")
    (string-list
     ; FRAG_ is prepended here and not elsewhere to avoid name collisions
     ; with symbols like AND, etc.
     "\
// ********** "
     (if (= (length (sfrag-users frag)) 1)
	 "used only by:"
	 "used by:")
     (string-drop1
      (string-map (lambda (user)
		    (string-append ", " (obj:str-name user)))
		  (sfrag-users frag)))
     "

  CASE (FRAG_" (string-upcase (gen-sym frag)) "):
    {\n"
     (if (sfrag-header? frag)
	 (string-append "      abuf = vpc;\n"
			"      vpc = vpc + 1;\n")
	 "")
     (gen-define-field-macro (sfrag-sfmt frag))
     ; Unconditionally written operands are not recorded here.
     (if (or (with-profile?) (with-parallel-write?))
	 "      unsigned long long written = 0;\n"
	 "")
     ; The address of this insn, needed by extraction and semantic code.
     ; Note that the address recorded in the cpu state struct is not used.
     "      PCADDR pc = abuf->addr;\n"
     (if (and cti?
	      (not parallel?)
	      (sfrag-header? frag))
	 (string-append ; "      npc = 0;\n" ??? needed?
	  "      br_status = BRANCH_UNTAKEN;\n")
	 "")
     ; Emit setup-semantics code for headers of real insns.
     (if (and (sfrag-header? frag)
	      (not (obj-has-attr? frag 'VIRTUAL))
	      (isa-setup-semantics (current-isa)))
	 (string-append
	  "      "
	  (rtl-c++ VOID (list (obj:name (current-isa))) nil
		   (isa-setup-semantics (current-isa))
		   #:rtl-cover-fns? #t
		   #:owner #f))
	 "")
     "\n"
     (/gen-sfrag-code frag locals)
     "\n"
     ; Only update what's been written if some are conditionally written.
     ; Otherwise we know they're all written so there's no point in
     ; keeping track.
     (if (or (with-profile?) (with-parallel-write?))
	 (if (/any-cond-written? (sfrag-sfmt frag))
	     "        abuf->written = written;\n"
	     "")
	 "")
     (if (and cti?
	      (not parallel?)
	      (sfrag-trailer? frag))
	 (string-append "      pbb_br_npc = npc;\n"
			"      pbb_br_status = br_status;\n")
	 "")
     (gen-undef-field-macro (sfrag-sfmt frag))
     "    }\n"
     (if (sfrag-trailer? frag)
	 "    NEXT_INSN (vpc, fragpc);\n"
	 "    NEXT_FRAG (fragpc);\n")
     "\n"
     ))
)

; Convert locals from form computed by sem-find-common-frags to that needed by
; /gen-sfrag-engine-code (and ultimately rtl-c++).

(define (/frag-convert-c-locals locals)
  (map (lambda (local)
	 (list (car local) (mode:lookup (cadr local))
	       (gen-c-symbol (car local))))
       locals)
)

; Return definition of insn frag usage table.

(define (/gen-sfrag-engine-frag-table insn-list frag-table frag-usage)
  (string-write
   "\
// Table of frags used by each insn.

const @@prefix@@_insn_frag @@prefix@@_frag_usage[] = {\n"

   (lambda ()
     (for-each (lambda (insn frag-nums)
		 (string-write "  { "
			       "@@PREFIX@@_INSN_"
			       (string-upcase (gen-sym insn))
			       (string-map (lambda (frag-num)
					     (string-append ", @@PREFIX@@_FRAG_"
							    (string-upcase (gen-sym (vector-ref frag-table frag-num)))))
					   frag-nums)
			       ", @@PREFIX@@_FRAG_LIST_END },\n"))
	       insn-list frag-usage)
     "")
   "};\n\n")
)

; Return sfrag computed-goto engine.
; LOCALS is a list of sequence locals made global to all frags.
; Each element is (symbol <mode> "c-var-name").

(define (/gen-sfrag-engine-fn frag-table locals)
  (string-write
   "\
void
@@cpu@@_cpu::@@prefix@@_pbb_run ()
{
  @@cpu@@_cpu* current_cpu = this;
  @@prefix@@_scache* vpc;
  @@prefix@@_scache* abuf;
#ifdef __GNUC__
  void** fragpc;
#else
  ARM_FRAG_TYPE* fragpc;
#endif

#ifdef __GNUC__
{
  static const @@prefix@@_pbb_label labels[] =
    {
      { @@PREFIX@@_FRAG_LIST_END, 0 },
"

   (lambda ()
     (string-write-map (lambda (frag)
			 (string-append "      { "
					"@@PREFIX@@_FRAG_"
					(string-upcase (gen-sym frag))
					", && case_FRAG_"
					(string-upcase (gen-sym frag))
					" },\n"))
		       ; FIXME: vector->list
		       (vector->list frag-table)))

   "\
      { @@PREFIX@@_FRAG_MAX, 0 }
    };

  if (! @@prefix@@_idesc::idesc_table_initialized_p)
    {
      // Several tables are in play here:
      // idesc table: const table of misc things for each insn
      // frag usage table: const set of frags used by each insn
      // frag label table: same as frag usage table, but contains labels
      // selected insn frag table: table of pointers to either the frag usage
      // table (if !gnuc) or frag label table (if gnuc) for the currently
      // selected ISA.  Insns not in the ISA are redirected to the `invalid'
      // insn handler.  FIXME: This one isn't implemented yet.

      // Allocate frag label table and point idesc table entries at it.
      // FIXME: Temporary hack, to be redone.
      static void** frag_label_table;
      int max_insns = @@PREFIX@@_INSN_" (/last-insn) " + 1;
      int tabsize = max_insns * 4;
      frag_label_table = new void* [tabsize];
      memset (frag_label_table, 0, sizeof (void*) * tabsize);
      int i;
      void** v;
      for (i = 0, v = frag_label_table; i < max_insns; ++i)
	{
	  @@prefix@@_idesc::idesc_table[@@prefix@@_frag_usage[i].itype].cgoto.frags = v;
	  for (int j = 0; @@prefix@@_frag_usage[i].ftype[j] != @@PREFIX@@_FRAG_LIST_END; ++j)
	    *v++ = labels[@@prefix@@_frag_usage[i].ftype[j]].label;
	}

      // Initialize the compiler virtual insn.
      // FIXME: Also needed if !gnuc.
      current_cpu->@@prefix@@_engine.compile_begin_insn (current_cpu);

      @@prefix@@_idesc::idesc_table_initialized_p = true;
    }
}
#endif

#ifdef __GNUC__
#define CASE(X) case_##X
// Branch to next handler without going around main loop.
#define NEXT_INSN(vpc, fragpc) fragpc = vpc->execute.cgoto.frags; goto * *fragpc
#define NEXT_FRAG(fragpc) ++fragpc; goto * *fragpc
// Break out of threaded interpreter and return to \"main loop\".
#define BREAK(vpc) goto end_switch
#else
#define CASE(X) case @@PREFIX@@_##X
#define NEXT_INSN(vpc, fragpc) fragpc = vpc->idesc->frags; goto restart
#define NEXT_FRAG(fragpc) ++fragpc; goto restart
#define BREAK(vpc) break
#endif

  // Get next insn to execute.
  vpc = current_cpu->@@prefix@@_engine.get_next_vpc (current_cpu->h_pc_get ());

  {
    // These two are used to pass data from cti insns to the cti-chain insn.
    PCADDR pbb_br_npc;
    branch_status pbb_br_status;
    // These two are used to build up values of the previous two.
    PCADDR npc;
    branch_status br_status;
    // Top level locals moved here so they're usable by multiple fragments.
"

   (lambda ()
     (string-write-map (lambda (local)
			 (string-append "    "
					(mode:c-type (cadr local))
					" "
					(caddr local)
					";\n"))
		       locals))

   "\

restart:
#ifdef __GNUC__
  fragpc = vpc->execute.cgoto.frags;
  goto * *fragpc;
#else
  fragpc = vpc->idesc->frags;
  switch (*fragpc)
#endif

    {

"

   (lambda ()
     ; Turn parallel execution support off.
     ; ??? Still needed?
     (set-with-parallel?! #f)
     (string-write-map (lambda (frag)
			 (/gen-sfrag-case frag locals))
		       ; FIXME: vector->list
		       (vector->list frag-table)))

   "
#ifdef __GNUC__
    end_switch: ;
#else
    default: abort ();
#endif
    }
  }

  // Save vpc for next time.
  current_cpu->@@prefix@@_engine.set_next_vpc (vpc);
}
\n")
)

(define (/gen-sfrag-engine)
  (string-write
   (lambda ()
     (/gen-sfrag-engine-frag-table (sim-sfrag-insn-list)
				   (sim-sfrag-frag-table)
				   (sim-sfrag-usage-table)))
   (lambda ()
     (/gen-sfrag-engine-fn (sim-sfrag-frag-table)
			   (/frag-convert-c-locals (sim-sfrag-locals-list))))
   )
)

; Generate sem-switch.cxx.

(define (cgen-sem-switch.cxx)
  (logit 1 "Generating " (gen-cpu-name) "-sem-switch.cxx ...\n")

  (sim-analyze-insns!)
  (if (with-sem-frags?)
      (sim-sfrag-analyze-insns!))

  ; Turn parallel execution support off.
  ; It is later turned on/off when generating the actual semantic code.
  (set-with-parallel?! #f)

  ; Tell the rtx->c translator we are the simulator.
  (rtl-c-config! #:rtl-cover-fns? #t)

  ; Indicate we're currently generating a pbb engine.
  (set-current-pbb-engine?! #t)

  (string-write
   (gen-c-copyright "Simulator instruction semantics for @@prefix@@."
		  copyright-red-hat package-red-hat-simulators)
   "\

#include \"@@cpu@@.h\"

using namespace @@cpu@@; // FIXME: namespace organization still wip

#define GET_ATTR(name) GET_ATTR_##name ()

\n"

   (if (with-sem-frags?)
       /gen-sfrag-engine-decls
       "")

   (if (with-sem-frags?)
       /gen-sfrag-engine
       /gen-sem-switch-engine)
   )
)
@


1.28
log
@	* desc-cpu.scm (cgen-desc.h): Don't print virtual enums.
	* sid-cpu.scm (cgen-desc.h): Ditto.
	* enum.scm (enum-builtin!): New function.
	* read.scm (reader-install-builtin!): Call it.
	* rtl-c.scm (s-convop): Delete, replaced with ...
	(s-int-convop, s-float-convop): ... new fns.
	(ext, zext, trunc): Update.
	(fext, ftrunc, float, ufloat, fix, ufix): Update.
	* rtx-funcs.scm (fext, ftrunc, float, ufloat, fix, ufix): New parameter
	`how'.
	* cpu/mep-fmax.cpu (fcvtsw): Update.
	* cpu/sh.cpu (h-fsd, h-fmov): Update.
	* doc/rtl.texi (float-convop): Update.

	* frv.cpu (floating-point-conversion): Update call to fp conv op.
	(floating-point-dual-conversion, ne-floating-point-dual-conversion,
	conditional-floating-point-conversion, ne-floating-point-conversion,
	float-parallel-mul-add-double-semantics): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2002, 2003, 2005, 2006, 2009 Red Hat, Inc.
@


1.27
log
@	Specify isa(s) when doing ifield, operand, insn lookups.
	ACU = all callers updated.
	* attr.scm (/attr-eval): Call rtx-value instead of rtx-eval-with-estate.
	* enum.scm (define-full-insn-enum): Pass isa-name-list to
	current-ifld-lookup.
	* html.scm (get-insn-properties): Pass isa-name-list to
	current-op-lookup.
	* ifield.scm (/ifld-parse-follows): New arg isas, ACU.
	* insn.scm (/parse-insn-format-symbol): New arg isa-name-list, ACU.
	(/parse-insn-format-list, /parse-insn-iformat-iflds): Ditto.
	(/parse-insn-format, syntax-break-out): Ditto.
	* mach.scm (obj-filter-by-isa): New function.
	(current-ifld-lookup): New optional arg maybe-isa-name-list.
	(/ifld-already-defined?, /op-already-defined?): Simplify.
	(current-op-lookup): New optional arg maybe-isa-name-list.
	(current-insn-lookup): New arg isa-name-list, ACU.
	(/insn-already-defined?, /minsn-already-defined?): Simplify.
	(current-minsn-lookup): New arg isa-name-list, ACU.
	* minsn.scm (/minsn-compute-iflds): Pass isa-name-list to
	current-op-lookup.
	* opc-itab.scm (compute-syntax): New arg isa-name-list, ACU.
	(gen-syntax-entry): Ditto.
	* operand.scm (/operand-parse): Pass isa-name-list to
	current-ifld-lookup.
	(/derived-parse-encoding): New arg isa-name-list, ACU.
	(/derived-parse-ifield-assertion): Ditto.
	(/derived-operand-parse): Pass isa-name-list to current-op-lookup.
	(/anyof-parse-choice): Ditto.
	(anyof-satisfies-assertions?): Pass context to rtx-solve.
	(/anyof-merge-syntax): New arg container, ACU.
	(operand-builtin!): Add pc to all isas.
	* rtl-c.scm (estate-make-for-rtl-c): Delete arg extra-vars-alist, ACU.
	(estate-make-for-rtl-c++, rtl-c-expr-parsed): Ditto.
	(rtl-c-parsed, rtl-c++-parsed): Ditto.
	(rtl-c): New arg isa-name-list, ACU.
	(rtl-c-expr, rtl-c++): Ditto.
	(closure): New arg isa-name-list, ACU.
	* rtl-traverse.scm (/make-cstate): New arg isa-name-list, ACU.
	(/cstate-isas): New function.
	(/rtx-canon-symbol-list): New function.
	(/rtx-canon-env-stack): Renamed from /rtx-canon-env, ACU.
	updated.
	(/rtx-make-canon-table): Rename ENV to ENVSTACK, new entry SYMBOLLIST.
	(/rtx-canon-rtx-operand): Pass isa list to current-op-lookup.
	(/rtx-canon-rtx-ref, /rtx-canon): Ditto.
	(rtx-canonicalize): New arg isa-name-list, ACU.
	(rtx-canonicalize-stmt): Delete.
	(tstate-make): New arg isas, ACU.
	(tstate-isas, tstate--set-isas!): New functions.
	(tstate-env-stack): Renamed from tstate-env, ACU.
	(tstate-set-env-stack!): Renamed from tstate-set-env!, ACU.
	(tstate-make-closure): Renamed from tstate-new-env, new arg
	isa-name-list, ACU.
	(/rtx-traverse-env): Delete.
	(/rtx-make-traverser-table): Rename ENV to ENVSTACK, new entry
	SUMBOLLIST.
	(/rtx-traverse): Include conditional flag in dump output.
	Update isa,envstack for closures.  Pass isa list to current-op-lookup.
	(<eval-state>): New member isas.  Rename env to env-stack.
	(<eval-state> vmake!): Handle #:isas.  #:env renamed to #:env-stack.
	(<eval-state>): New getter/setter for isas.  Rename env getter/setter
	to env-stack.
	(estate-make-for-eval): Provide #:isas.
	(estate-make-closure): Renamed from estate-new-env.  New arg
	isa-name-list, ACU.
	* rtl-xform.scm (/rtx-simplify-expr-fn): Handle closures.
	(/rtx-trim-args): ENV renamed to ENVSTACK.  Ad ITERATION, SYMBOLLIST.
	(/rtx-trim-for-doc): Handle closures.
	* rtl.scm (/rtx-valid-types): Rename ENV to ENVSTACK.  Add ITERATION,
	SYMBOLLIST.
	(rtx-env-var-list): Delete.
	(rtx-env-make): Handle already-compiled environments.
	(rtx-var-alist-to-env): New function.
	(rtx-var-alist-to-closure-env-stack, rtx-make-env-stack): New functions.
	(rtx-env-stack-dump): Renamed from rtx-env-dump, ACU.
	(rtx-operand-obj): New arg isa-name-list, ACU.
	(rtx-closure-isas, rtx-closure-env-stack, rtx-closure-expr): New
	functions.
	* rtx-funcs.scm (closure): New arg isa-name-list, reorder args, ACU.
	* sem-frags.scm (<sfrag>): Delete member compiled-semantics.
	(/frag-compute-desired-frags): Minor simplification.
	(/frag-pick-best): Ditto.
	* sid-cpu.scm (gen-semantic-code): Require canonical rtl.
	(/gen-sfrag-code): Update.
	* sim-cpu.scm (gen-semantic-code): Require canonical rtl.
	* utils-cgen.scm (sanitize): New arg isa-name-list, ACU.
	* utils.scm (non-null-intersection?): New function.
@
text
@d88 7
a94 2
   "// Enums.\n\n"
   (lambda () (string-map gen-decl (current-enum-list)))
@


1.26
log
@	Record bitset attributes internally as a list.
	Record rtx attribute values internally as ((rtx-expr)).
	* attr.scm (bitset-attr?): Delete, unused.
	(<bitset-attribute> parse-value): Rewrite.
	(/attr-parse): Rewrite bitset default value processing.
	(/attr-read): Pick out values of scalar attributes to distinguish
	them from bitset values which are a list.
	Fix spelling errors for processing of default values.
	Handle string attributes.
	(bitset-attr->list): Delete, all callers updated.
	(/bitset-attr->charmask): Renamed from bitset-attr->charmask.
	All callers updated.
	(atlist-source-form): Rewrite.
	* hardware.scm (<hardware-base> 'get-isas): Update recognition
	of all isas.
	(hardware-builtin!): Update spec of ISA attribute, (ISA foo,bar)
	-> (ISA foo bar).
	* intrinsics.scm (target:belongs-to-group?): Update, bitset attribute
	values are now lists.
	* mach.scm (def-isa-attr!): Update, bitset attribute values,
	including the default, are now lists.
	(all-isas-attr-value): Result is now a list.
	* doc/rtl.texi: Clean up pass over attribute docs.
@
text
@a113 1
	(isas (obj-attr-value hw 'ISA))
d121 2
a122 1
			   (rtl-c++ mode expr
d126 1
d139 1
a139 1
			   expr
d144 1
a708 3
  ; Indicate generating code for INSN.
  ; Use the canonical form if available.
  ; The case when they're not available is for virtual insns. (??? Still true?)
d711 1
a711 1
	      (rtl-c++-parsed VOID sem nil
d717 1
a717 1
	      (rtl-c++-parsed VOID sem nil
d722 3
a724 4
	 (rtl-c++ VOID (insn-semantics insn) nil
		  #:for-insn? #t
		  #:rtl-cover-fns? #t
		  #:owner insn)))
d895 2
a896 1
	  (rtl-c++ VOID (isa-setup-semantics (current-isa)) nil
d1117 1
a1117 4
  ; Indicate generating code for FRAG.
  ; Use the compiled form if available.
  ; The case when they're not available is for virtual insns.
  (let ((sem (sfrag-compiled-semantics frag))
d1124 7
a1130 11
		   #f))
	)
    (if sem
	(rtl-c++-parsed VOID sem locals
			#:for-insn? #t
			#:rtl-cover-fns? #t
			#:owner owner)
	(rtl-c++ VOID (sfrag-semantics frag) locals
		 #:for-insn? #t
		 #:rtl-cover-fns? #t
		 #:owner owner)))
d1184 2
a1185 1
	  (rtl-c++ VOID (isa-setup-semantics (current-isa)) nil
@


1.25
log
@	* sid-cpu.scm (/gen-sem-case): Tweaking debugging printf.
	(/gen-sfrag-case): Ditto.
	* sim-cpu.scm (/gen-sem-case): Ditto.
@
text
@d114 1
a114 1
	(isas (bitset-attr->list (obj-attr-value hw 'ISA)))
@


1.24
log
@	* desc-cpu.scm (/gen-hash-defines): Remove #include of cgen-bitset.h.
	* sid-cpu.scm (cgen-desc.h): Update location of cgen's bitset.h.
@
text
@d863 2
a864 1
	 "semantic switch case for \"" (insn-syntax insn) "\" ...\n")
d1151 1
a1151 1
	   "semantic switch case for \"" (obj:name frag) "\" ...\n")
@


1.23
log
@	* cos.scm (/method-lookup): Delete arg virtual?, all callers updated.
	(method-proc): Delete.
	(method-make-virtual!, method-make-virtual-forward!): Delete.
	* ifield.scm (<ifield> field-start): Update.
	(<ifield> field-length, pretty-print): Update.
	(<multi-ifield> field-length, field-start, pretty-print): Update.
	* sid-cpu.scm (/gen-hardware-struct): Use gen-defn instead of gen-decl.
	* sid.scm (<scalar> gen-sym-defn): Renamed from gen-sym-decl.
	(<array> gen-sym-defn): Ditto.
	(<hardware-base> gen-defn): Renamed from gen-defn.
	(<hw-register> gen-type): Update.
	(<hw-register> gen-defn): Renamed from gen-sym-decl, rewrite.
	(<hw-memory>, <hw-address>, <hw-iaddress> gen-type): Update.
	(<hw-memory>, <hw-address> gen-defn): Renamed from gen-sym-decl.
	(<hw-immediate> gen-type): Update.
	(<hw-immediate> gen-defn): Renamed from gen-sym-decl, rewrite.
	* sim-cpu.scm (/gen-hardware-struct): Use gen-defn instead of gen-decl.
	* sim.scm (<scalar> gen-sym-defn): Renamed from gen-sym-decl.
	(<array> gen-sym-defn): Ditto.
	(<hardware-base> gen-defn): Renamed from gen-defn.
	(<hw-register> gen-type): Update.
	(<hw-register> gen-defn): Renamed from gen-sym-decl, rewrite.
	(<hw-memory>, <hw-address>, <hw-iaddress> gen-type): Update.
	(<hw-memory>, <hw-address> gen-defn): Renamed from gen-sym-decl.
	(<hw-immediate> gen-type): Update.
	(<hw-immediate> gen-defn): Renamed from gen-sym-decl, rewrite.
@
text
@d83 1
a83 1
#include \"opcode/cgen-bitset.h\"
@


1.22
log
@	* xc16x.cpu (h-cr): New hardware.
	(muls): Comment out parts that won't compile, add fixme.
	(mulu, divl, divlu, jmpabs, jmpa-, jmprel, jbc, jnbs, callr): Ditto.
	(scxti, scxtmg, scxtm, bclear, bclr18, bset19, bitset, bmov): Ditto.
	(bmovn, band, bor, bxor, bcmp, bfldl, bfldh): Ditto.

	Rewrite rtl processing to require it to be "canonicalized" first,
	and write a full canonicalizer / expression checker.
	Remove all appearances of DFLT in canonical rtl.
	* attr.scm (/attr-eval atval owner): Call rtx-canonicalize,
	then rtx-simplify.
	* iformat.scm (ifmt-analyze) Use canonical semantics.
	* insn (<insn>): New member canonical-semantics.
	* mach.scm (<arch>): New member multi-insns-instantiated?.
	(/instantiate-multi-insns!): New function.
	(/canonicalize-insns!): New function.
	(arch-analyze-insns!): Canonicalize insn semantics before processing
	them.
	* mode.scm (/mode-set-word-params!): New function.
	(mode-void?): New function.
	(mode-compatible?): VOID is compatible with VOID.
	(/mode-word-sizes-defined?): New global.
	(mode-set-word-modes!): Use/set it.
	(mode-ensure-word-sizes-defined): Update.
	(mode-builtin!): New builtin "modes" SYM, INSN, MACH.
	Redo WI/UWI/AI/IAI handling.
	(op:new-mode): No longer accept DFLT.
	(<derived-operand> constructor): Ensure all fields are initialized.
	(<anyof-operand> constructor): Ditto.
	(/derived-parse-ifield-assertion): Delete arg `args'.
	All callers updated.
	* rtl-c.scm (<rtl-c-eval-state>): New member `for-insn?'.
	(rtl-c): Call rtx-canonicalize instead of rtx-compile.
	(rtl-c-expr, rtl-c++): Ditto.
	(/rtl-c-get): Use mode of operand, not containing expression.
	(rtl-c-set-quiet, rtl-c-set-trace): Remove DFLT support.
	(/rtx-use-sem-fn?): Don't check for (insn? owner), check
	estate-for-insn? instead.
	(s-unop): Use mode of expression, not first operand.
	(s-binop, s-binop-with-bit, s-shop, s-cmpop): Ditto.
	(s-sequence): Remove DFLT support.
	(ifield): Use mode of expression, not UINT.
	(pc): Comment out, unused.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	(set, set-quiet): Pass src to rtl-c-set-{trace,quiet} for expansion.
	* rtl-traverse.scm (/rtx-canon-debug?): New global.
	(/make-cstate): New function.
	(/cstate-context, /cstate-outer-expr): New functions.
	(/rtx-canon-error): New function.
	(/rtx-lookup-hw, /rtx-pick-mode, /rtx-pick-mode3, /rtx-pick-op-mode,
	/rtx-get-last-cond-case-rtx): New functions.
	(/rtx-canon-*): New functions.
	(/rtx-canner-table, /rtx-operand-canoners): New globals.
	(/rtx-make-canon-table, /rtx-special-expr-canoners): New functions.
	(/rtx-option, /rtx-option-list?): Rewrite.
	(rtx-munge-mode&options): Replaces /rtx-munge-mode&options.
	Rewritten, all callers updated.
	(/rtx-canon-expr, /rtx-canon): New functions.
	(rtx-canonicalize): Move here from rtl-xform.scm and rewrite.
	(rtx-canonicalize-stmt): New function.
	(tstate-make): Remove arg `set?'.  All callers updated.
	(tstate-new-set?): Delete.
	(/rtx-traverse-options, /rtx-traverse-*mode): Delete,
	moved to /rtx-canon-*.
	(/rtx-traverse-normal-operand): New function.
	(/rtx-traverse-rtx-list): Delete arg `mode', all callers updated.
	(/rtx-traverse-rtx, /rtx-traverse-setrtx,, /rtx-traverse-testrtx,
	/rtx-traverse-condrtx, /rtx-traverse-casertx, /rtx-traverse-locals,
	/rtx-traverse-iteration, /rtx-traverse-env, /rtx-traverse-attrs):
	Ditto.
	(/rtx-traverse-symbol, /rtx-traverse-string, /rtx-traverse-number,
	/rtx-traverse-symornum, /rtx-traverse-object): Delete.
	(/rtx-make-traverser-table): Update.
	(/rtx-traverse-operands): Remove mode processing, now done during
	canonicalization.
	(/rtx-traverse-expr): Delete arg `mode', all callers updated.
	(/rtx-traverse): Ditto.
	(rtx-init-traverser-tables!): New function.
	* rtl-xform (/rtx-verify-no-dflt-modes-expr-fn): New function.
	(rtx-verify-no-dflt-modes): New function.
	(/rtx-simplify-expr-fn): Update, `arg' mode deleted.
	(rtx-simplify-insn): Use insn-canonical-semantics.
	(rtx-canonicalize): Moved to rtl-traverse.scm.
	(/compile-expr-fn, rtx-compile): Delete.
	(/rtx-trim-rtx-list): New function.
	(/rtx-trim-for-doc): Handle set, if.
	* rtl.scm (<rtx-func>): New members result-mode, matchexpr-index.
	(/rtx-valid-mode-types): Update.
	(/rtx-valid-matches): Update.
	(/rtx-find-matchexpr-index): New function.
	(rtx-lookup): Require rtx-kind to be the rtx name.
	(def-rtx-node): New arg result-mode, all callers updated.
	(def-rtx-syntax-node, def-rtx-operand-node): Ditto.
	(rtx-lazy-sem-mode): Delete.
	(/rtx-closure-make): New arg `mode', all callers updated.
	(rtx-make-ifield, rtx-make-operand, rtx-make-local): Ditto.
	(rtx-operand-obj): Rewrite.
	(rtx-make-xop): New functions.
	(/hw): Renamed from `hw', all callers updated.
	Use the correct mode instead of DFLT for the index.
	(rtl-builtin!): Call rtx-init-traversal-tables!.
	(rtl-finish!): Update.
	* rtx-funcs.scm (all rtx functions): New parameter: result-mode.
	Update mode arg-type.
	(pc): Comment out.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	* sem-frags.scm (/frag-hash-compute!): Update, mode arg deleted.
	(/frag-cost-compute!): Ditto.
	* semantics.scm (/build-operand!): Delete args op-name, op.
	New arg op-expr.  All callers updated.
	(/build-mem-operand!): Remove DFLT support.
	(semantic-compile): Update process-expr!, mode arg deleted.
	* sid-cpu.scm (gen-semantic-code): Specify #:for-insn? in
	rtl-c++ calls.
	(/gen-sem-case, /gen-sfrag-code): Ditto.
	* sid.scm (/op-gen-set-trace1): Renamed from /op-gen-set-trace.
	(/op-gen-set-trace): New function.  If not doing profiling,
	call /op-gen-set-quiet.
	* sim-cpu.scm (gen-semantic-code): Specify #:for-insn? in rtl-c calls.
	* utils-gen.scm (/gen-ifld-extract-base): Update call to rtl-c.
	(/gen-ifld-extract-beyond, gen-multi-ifld-extract): Ditto.
	* utils.scm (find-first-index): New function.
	* doc/rtl.texi: Delete docs for `attr'.  Add `int-attr'.
@
text
@d190 1
a190 1
       (string-list-map gen-decl hw-list)
@


1.21
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d708 19
a726 12
  ; Use the compiled form if available.
  ; The case when they're not available is for virtual insns.
  (let ((sem-c-code
	 (if (insn-compiled-semantics insn)
	     (rtl-c++-parsed VOID (insn-compiled-semantics insn) nil
			     #:rtl-cover-fns? #t
			     #:owner insn)
	     (rtl-c++ VOID (insn-semantics insn) nil
		      #:rtl-cover-fns? #t
		      #:owner insn)))
	)
    sem-c-code)
d897 1
d1123 2
a1124 1
	; frag should have only one owner.
d1131 1
d1135 1
@


1.20
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d8 1
a8 1
(define (-last-insn)
d14 1
a14 1
(define (-gen-attr-decls)
d25 1
a25 1
(define (-gen-insn-attr-decls)
d62 1
a62 1
(define (-gen-mach-params)
d91 3
a93 3
   -gen-attr-decls
   -gen-insn-attr-decls
   -gen-mach-params
d109 1
a109 1
(define (-gen-reg-access-defns hw)
d178 1
a178 1
; Subroutine of -gen-hardware-types to generate the struct containing
d181 1
a181 1
(define (-gen-hardware-struct prefix hw-list)
d202 1
a202 1
(define (-gen-hardware-types)
d205 1
a205 1
   (-gen-hardware-struct #f (find hw-need-storage? (current-hw-list))))
d208 1
a208 1
(define (-gen-hw-stream-and-destream-fns) 
d213 1
a213 1
		    (let ((dims (-hw-vector-dims r)))
d308 1
a308 1
   -gen-hardware-types
d310 1
a310 1
   -gen-hw-stream-and-destream-fns
d315 1
a315 1
     (string-list-map -gen-reg-access-defns
d328 1
a328 1
(define (-gen-cpu-defines)
d348 1
a348 1
(define (-gen-model-decls)
d391 1
a391 1
(define (-calculated-memory-write-buffer-size)
d400 1
a400 1
;(define (-worst-case-number-of-writes-to hw-name)
d407 1
a407 1
(define (-hw-gen-write-stack-decl nm mode)
d412 1
a412 1
;	 (sz (* pipe-sz (-worst-case-number-of-writes-to nm))))
d420 2
a421 2
(define (-hw-gen-write-struct-decl)
  (let* ((dims (-worst-case-index-dims))
d443 2
a444 2
(define (-hw-vector-dims hw) (elm-get (hw-type hw) 'dimensions))			    
(define (-worst-case-index-dims)
d447 1
a447 1
		 (map (lambda (hw) (length (-hw-vector-dims hw))) 
d451 1
a451 1
(define (-gen-writestacks)
d470 2
a471 2
     (-hw-gen-write-struct-decl)
     (foldl (lambda (s pair) (string-append s (apply -hw-gen-write-stack-decl pair))) h1 all-pairs)	  
d484 1
a484 1
  (let ((membuf-sz (-calculated-memory-write-buffer-size))
d527 1
a527 1
     (-gen-writestacks)     
d532 1
a532 1
(define (-gen-trace-record-type)
d604 1
a604 1
(define (-gen-register-writer nm mode dims)
d617 1
a617 1
(define (-gen-memory-writer nm mode dims)
d631 1
a631 1
(define (-gen-reset-fn)
d649 1
a649 1
(define (-gen-unified-write-fn) 
d654 1
a654 1
					    (length (-hw-vector-dims h)))) 
d667 1
a667 1
     (string-map (lambda (t) (apply -gen-register-writer t)) hw-triples)
d669 1
a669 1
     (string-map (lambda (t) (apply -gen-memory-writer t)) mem-triples)
d696 2
a697 2
   -gen-reset-fn
   -gen-unified-write-fn
d725 1
a725 1
(define (-gen-scache-semantic-fn insn)
d727 1
a727 1
  (set! -with-profile? -with-profile-fn?)
d760 1
a760 1
	 (if (-any-cond-written? (insn-sfmt insn))
d775 1
a775 1
(define (-gen-all-semantic-fns)
d779 1
a779 1
	(string-write-map -gen-scache-semantic-fn insns)
d820 1
a820 1
   -gen-all-semantic-fns
d830 1
a830 1
; Utility of -gen-sem-case to return the mask of operands always written
d834 1
a834 1
(define (-uncond-written-mask sfmt)
d842 1
a842 1
; Utility of -gen-sem-case to return #t if any operand in <sformat> SFMT is
d845 1
a845 1
(define (-any-cond-written? sfmt)
d853 1
a853 1
(define (-gen-sem-case insn parallel?)
d857 1
a857 1
  (set! -with-profile? -with-profile-sw?)
d900 1
a900 1
	 (if (-any-cond-written? (insn-sfmt insn))
d916 1
a916 1
(define (-gen-sem-switch)
d920 1
a920 1
  (string-write-map (lambda (insn) (-gen-sem-case insn #f))
d934 1
a934 1
(define (-gen-parallel-sem-switch)
d939 2
a940 2
		      (string-list (-gen-sem-case insn #t)
				   (-gen-write-case (insn-sfmt insn) insn)))
d946 1
a946 1
(define (-gen-sem-switch-engine)
d1005 1
a1005 1
      for (int i = 0; i <= @@PREFIX@@_INSN_" (-last-insn) "; i++)
d1041 1
a1041 1
  -gen-sem-switch
d1044 1
a1044 1
       -gen-parallel-sem-switch
d1066 1
a1066 1
(define (-gen-sfrag-enum-decl frag-list)
d1081 1
a1081 1
(define (-gen-sfrag-engine-decls)
d1086 1
a1086 1
   (-gen-sfrag-enum-decl (vector->list (sim-sfrag-frag-table)))
d1108 1
a1108 1
(define (-gen-sfrag-code frag locals)
d1133 2
a1134 2
(define (-gen-sfrag-case frag locals)
  (set! -with-profile? -with-profile-sw?)
d1185 1
a1185 1
     (-gen-sfrag-code frag locals)
d1191 1
a1191 1
	 (if (-any-cond-written? (sfrag-sfmt frag))
d1211 1
a1211 1
; -gen-sfrag-engine-code (and ultimately rtl-c++).
d1213 1
a1213 1
(define (-frag-convert-c-locals locals)
d1222 1
a1222 1
(define (-gen-sfrag-engine-frag-table insn-list frag-table frag-usage)
d1248 1
a1248 1
(define (-gen-sfrag-engine-fn frag-table locals)
d1299 1
a1299 1
      int max_insns = @@PREFIX@@_INSN_" (-last-insn) " + 1;
d1377 1
a1377 1
			 (-gen-sfrag-case frag locals))
d1396 1
a1396 1
(define (-gen-sfrag-engine)
d1399 1
a1399 1
     (-gen-sfrag-engine-frag-table (sim-sfrag-insn-list)
d1403 2
a1404 2
     (-gen-sfrag-engine-fn (sim-sfrag-frag-table)
			   (-frag-convert-c-locals (sim-sfrag-locals-list))))
d1441 1
a1441 1
       -gen-sfrag-engine-decls
d1445 2
a1446 2
       -gen-sfrag-engine
       -gen-sem-switch-engine)
@


1.19
log
@	* desc-cpu.scm (cgen-desc.h): Tweak logit message for consistency.
	(cgen-desc.c): Ditto.
	* sid-cpu.scm (cgen-desc.h, cgen-cpu.h, cgen-defs.h): Ditto.
	(cgen-write.cxx, cgen-semantics.cxx, cgen-sem-switch.cxx): Ditto.
	* sid-decode.scm (cgen-decode.h, cgen-decode.cxx): Ditto.
	* sid-model.scm (cgen-model.cxx, cgen-model.h): Ditto.
	* sim-arch.scm (cgen-arch.h, cgen-arch.c): Ditto.
	(cgen-cpuall.h, cgen-ops.c): Ditto.
	* sim-cpu.scm (cgen-cpu.h, cgen-defs.h, cgen-cpu.c): Ditto.
	(cgen-read.c, cgen-write.c, cgen-semantics.c): Ditto.
	(cgen-sem-switch.c): Ditto.
	* sim-decode.scm (cgen-decode.h, cgen-decode.c): Ditto.
	* sim-model.c (cgen-model.c): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2002, 2003, 2005, 2006 Red Hat, Inc.
@


1.19.2.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2002, 2003, 2005, 2006, 2009 Red Hat, Inc.
@


1.18
log
@2006-07-14  Dave Brolley  <brolley@@redhat.com>

        * sid.scm (-op-gen-delayed-set-maybe-trace): If delay used, note the
        hardware or memory mode which was used.
        * sid-cpu.scm (hw-need-write-stack?): New function.
        (-gen-hw-stream-and-destream-fns): Compute stack-regs. Use it to
        identify hardware which uses write stacks.
        (useful-mode-names): Renamed to write-stack-memory-mode-names.
        Initialized to an empty list.
        (-gen-writestacks, -gen-reset-fn, -gen-unified-write-fn): Use
        hw-need-write-stack?.
        * hardware.scm (used-in-delay-rtl?): New member of <hardware-base>.
        (define-getters <hardware-base>): Define used-in-delay-rtl?.
        (used-in-delay-rtl?): New method of <hardware-base>.
        (hw-used-in-delay-rtl?): New function.
@
text
@d74 1
a74 1
  (logit 1 "Generating " (gen-cpu-name) " desc.h ...\n")
d290 1
a290 1
  (logit 1 "Generating " (gen-cpu-name) " cpu.h ...\n")
d548 1
a548 1
  (logit 1 "Generating " (gen-cpu-name) " defs.h ...\n")
d675 1
a675 1
  (logit 1 "Generating " (gen-cpu-name) " write.cxx ...\n")
d787 1
a787 1
  (logit 1 "Generating " (gen-cpu-name) " semantics.cxx ...\n")
d1411 1
a1411 1
  (logit 1 "Generating " (gen-cpu-name) " sem-switch.cxx ...\n")
@


1.17
log
@2006-05-09  Dave Brolley  <brolley@@redhat.com>

        * sid-cpu.scm (-gen-hw-stream-and-destream-fns): Use symbol->string instead of
        object->string om the mode.
        (-hw-gen-write-stack-decl): Likewise.
@
text
@d174 4
d211 1
d219 2
a220 2
	       (append (map (lambda (r) (gen-c-symbol (obj:name r))) regs)
		       (map (lambda (m) (sa (symbol->string m) "_memory")) useful-mode-names))))
d389 1
a389 1
(define useful-mode-names '(BI QI HI SI DI UQI UHI USI UDI SF DF))
d452 2
a453 2
  (let* ((hw (find register? (current-hw-list)))
	 (modes useful-mode-names) 
d634 1
a634 1
			    (find register? (current-hw-list)))
d636 1
a636 1
			    useful-mode-names)))
d650 2
a651 2
  (let* ((hw (find register? (current-hw-list)))
	 (modes useful-mode-names)	
@


1.16
log
@2006-05-09  Dave Brolley  <brolley@@redhat.com>

        * sid-cpu.scm (-gen-scache-semantic-fn): Generate code to set
        abuf->written if profiling.
@
text
@d215 1
a215 1
		       (map (lambda (m) (sa (object->string m) "_memory")) useful-mode-names))))
d409 1
a409 1
	 (mode-pad (spaces (- 4 (string-length (object->string mode)))))
d412 1
a412 1
     "  write_stack< write<" (object->string mode) "> >" mode-pad "\t" stack-name "\t[pipe_sz];\n")))
@


1.15
log
@	* sid-cpu.scm (-gen-hw-stream-and-destream-fns): Stringize mode
	for concatenation.
	(-hw-gen-write-stack-decl): Likewise.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2002, 2003, 2005 Red Hat, Inc.
d751 8
@


1.14
log
@2005-10-28  Dave Brolley  <brolley@@redhat.com>

        Contribute the following changes:
        2005-09-19  Dave Brolley  <brolley@@redhat.com>

        * attr.scm (gen-value-for-defn-raw): New methods.
        (gen-value-for-defn): Don't test for 'SID-SIMULATOR. Call
        gen-value-for-defn-raw.
        * sid.scm (gen-obj-attr-sid-defn): Call gen-value-for-defn-raw.

        2002-12-13  Dave Brolley  <brolley@@redhat.com>

        * utils-cgen.scm (gen-attr-type): Moved from sid.scm.
        (-gen-attr-accessors): New function.
        (gen-obj-attr-defn): Update terminating initializer.
        (gen-obj-attr-end-defn): New function.
        * sid.scm (gen-attr-type): Moved to utils-cgen.scm.
        * sid-cpu.scm (cgen-desc.h): Generate code to include
        "opcode/cgen-bitset.h"
        * intrinsics.scm (kept-insn-isas): Correct the extraction of the isa
        name.
        * desc.scm ('gen-defn): Update terminating initializer.
        * desc-cpu.scm (gen-ifld-decls): Call -gen-attr-accessors. Update
        terminatinig initializer.
        (gen-hw-decls): Ditto.
        (gen-operand-decls): Ditto.
        (gen-insn-decls): Ditto.
        (-gen-hash-defines): Generate code to include "opcde/cgen-bitset.h"
        (gen-insn-table): Update terminating initializer.
        (-gen-cpu-open): Update generation of @@arch@@_cgen_rebuild_tables,
        @@arch@@_cgen_cpu_open, @@arch@@_cgen_cpu_close.
        * attr.scm (charmask-bytes): New function.
        (bitset-attr->charmask): New function.
        (<bitset-attribute>): Handle isa-attributes specially. Also handle
        differences for SID-SIMULATOR.
        (<integer-attribute>): Handle differences for SID-SIMULATOR.
        (<enum-attribute>): Ditto.
@
text
@d215 1
a215 1
		       (map (lambda (m) (sa m "_memory")) useful-mode-names))))
d409 1
a409 1
	 (mode-pad (spaces (- 4 (string-length mode))))
d412 1
a412 1
     "  write_stack< write<" mode "> >" mode-pad "\t" stack-name "\t[pipe_sz];\n")))
@


1.13
log
@2005-07-29  Dave Brolley  <brolley@@redhat.com>

        * sid-cpu.scm (-gen-scache-semantic-fn): Generate a declation of 'writte
n'
        if with-profile or with-parallel-write.
        (cgen-semantics.cxx): Make the @@prefix@@ namespace available if with-para
llel.
@
text
@d83 2
a654 1

a657 1

@


1.12
log
@2005-06-15  Dave Brolley  <brolley@@redhat.com>

        * sid-cpu.scm (-gen-hw-stream-and-destream-fns): New function.
        (cgen-cpu.h): Call it.

        Contributed on behalf of Graydon Hoare
        2001-06-05  graydon hoare  <graydon@@redhat.com>

        * utils.scm (foldl): Define.
        (foldr): Define.
        (filter): Define.
        (union): Define.
        (intersection): Simplify.
        * sid.scm : Set APPLICATION to SID-SIMULATOR.
        (-op-gen-delayed-set-maybe-trace): Define.
        (<operand> 'gen-set-{quiet,trace}): Delegate to
        op-gen-delayed-set-quiet etc. Note: this is still a little tangled
        up and needs cleaning.
        (-with-parallel?): Hardwire with-parallel to #t.
        (<operand> 'cxmake-get): Replace with lookahead-aware code
        * sid-decode.scm: Remove per-insn writeback fns.
        (-gen-idesc-decls): Redefine sem_fn type.
        * sid-cpu.scm (gen-write-stack-structure): Replace parexec stuff
        with write stack stuff.
        (cgen-write.cxx): Replace per-insn writebacks with single write
        stack writeback. Add write stack reset function.
        (-gen-scache-semantic-fn insn): Replace parexec stuff with write
        stack stuff.
        * rtl-c.scm (xop): Clone operand into delayed operand if #:delayed
        estate attribute set.
        (delay): Set #:delayed attribute to calculated delay, update
        maximum delay of cpu, check (delay ...) usage.
        * operand.scm (<operand>): Add delayed slot to <operand>.
        * mach.scm (<cpu>): Add max-delay slot to <cpu>.
        * dev.scm (load-sid): Set APPLICATION to SID-SIMULATOR.
        * doc/rtl.texi (Expressions): Add section on (delay ...).
@
text
@d739 4
a742 1

d798 5
a802 2
using namespace @@cpu@@; // FIXME: namespace organization still wip

@


1.11
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2002 Red Hat, Inc.
d202 78
d303 2
d378 97
a474 3
; Utility of gen-parallel-exec-type to generate the definition of one
; structure in PAREXEC.
; SFMT is an <sformat> object.
d476 25
a500 29
(define (gen-parallel-exec-elm sfmt)
  (string-append
   "    struct { /* " (obj:comment sfmt) " */\n"
   (let ((sem-ops
	  ((if (with-parallel-write?) sfmt-out-ops sfmt-in-ops) sfmt)))
     (if (null? sem-ops)
	 "      int empty;\n"
	 (string-map
	  (lambda (op)
	    (logit 2 "Processing operand " (obj:name op) " of format "
		   (obj:name sfmt) " ...\n")
	      (if (with-parallel-write?)
		  (let ((index-type (and (op-save-index? op)
					 (gen-index-type op sfmt))))
		    (string-append "      " (gen-type op)
				   " " (gen-sym op) ";\n"
				   (if index-type
				       (string-append "      " index-type 
						      " " (gen-sym op) "_idx;\n")
				       "")))
		  (string-append "      "
				 (gen-type op)
				 " "
				 (gen-sym op)
				 ";\n")))
	  sem-ops)))
   "    } " (gen-sym sfmt) ";\n"
   )
)
d502 3
a504 9
; Generate the definition of the structure that holds register values, etc.
; for use during parallel execution.  When instructions are executed parallelly
; either
; - their inputs are read before their outputs are written.  Thus we have to
; fetch the input values of several instructions before executing any of them.
; - or their outputs are queued here first and then written out after all insns
; have executed.
; The fetched/queued values are stored in an array of PAREXEC structs, one
; element per instruction.
d506 11
a516 7
(define (gen-parallel-exec-type)
  (logit 2 "Generating PAREXEC type ...\n")
  (string-append
   (if (with-parallel-write?)
       "/* Queued output values of an instruction.  */\n"
       "/* Fetched input values of an instruction.  */\n")
   "\
d518 4
a521 10
struct @@prefix@@_parexec {
  union {\n"
   (string-map gen-parallel-exec-elm (current-sfmt-list))
   "\
  } operands;
  /* For conditionally written operands, bitmask of which ones were.  */
  unsigned long long written;
};\n\n"
   )
)
d557 7
d565 4
a568 1
\n"
d570 1
a570 3
   (if (with-parallel?)
       gen-parallel-exec-type
       "")
d572 6
a577 2
   "\
} // end @@cpu@@ namespace
a593 6
(define (-gen-write-args sfmt)
  (string-map (lambda (op) (op:write op sfmt))
	      (sfmt-out-ops sfmt))
)

; Utility of gen-write-fns to generate a writer function for <sformat> SFMT.
d595 1
a595 25
(define (-gen-write-fn sfmt)
  (logit 2 "Processing write function for \"" (obj:name sfmt) "\" ...\n")
  (string-list
   "\nsem_status\n"
   (-gen-write-fn-name sfmt) " (@@cpu@@_cpu* current_cpu, @@prefix@@_scache* sem, @@prefix@@_parexec* par_exec)\n"
   "{\n"
   (if (with-scache?)
       (gen-define-field-macro sfmt)
       "")
   (gen-define-parallel-operand-macro sfmt)
   "  @@prefix@@_scache* abuf = sem;\n"
   "  unsigned long long written = abuf->written;\n"
   "  PCADDR pc = abuf->addr;\n"
   "  PCADDR npc = 0; // dummy value for branches\n"
   "  sem_status status = SEM_STATUS_NORMAL; // ditto\n"
   "\n"
   (-gen-write-args sfmt)
   "\n"
   "  return status;\n"
   (gen-undef-parallel-operand-macro sfmt)
   (if (with-scache?)
       (gen-undef-field-macro sfmt)
       "")
   "}\n\n")
)
d597 56
a652 5
(define (-gen-write-fns)
  (logit 2 "Processing writer functions ...\n")
  (string-write-map (lambda (sfmt) (-gen-write-fn sfmt))
		    (current-sfmt-list))
)
d654 3
d658 10
a667 1
; Generate <cpu>-write.cxx.
a688 1
using namespace @@cpu@@;
d691 2
a692 1
   -gen-write-fns
d732 2
a733 1
	 " (@@cpu@@_cpu* current_cpu, @@prefix@@_scache* sem, @@prefix@@_parexec* par_exec)\n"
a736 3
     (if (with-parallel?)
	 (gen-define-parallel-operand-macro (insn-sfmt insn))
	 "")
d739 1
a739 4
     ; Unconditionally written operands are not recorded here.
     (if (or (with-profile?) (with-parallel-write?))
	 "  unsigned long long written = 0;\n"
	 "")
a747 8
     ; Only update what's been written if some are conditionally written.
     ; Otherwise we know they're all written so there's no point in
     ; keeping track.
     (if (or (with-profile?) (with-parallel-write?))
	 (if (-any-cond-written? (insn-sfmt insn))
	     "  abuf->written = written;\n"
	     "")
	 "")
a753 3
     (if (with-parallel?)
	 (gen-undef-parallel-operand-macro (insn-sfmt insn))
	 "")
d755 1
a755 1
     "}\n\n"
a852 3
     (if parallel?
	 (gen-define-parallel-operand-macro (insn-sfmt insn))
	 "")
a888 3
     (if parallel?
	 (gen-undef-parallel-operand-macro (insn-sfmt insn))
	 "")
a1141 3
     (if parallel?
	 (gen-define-parallel-operand-macro (sfrag-sfmt frag))
	 "")
a1181 3
     (if parallel?
	 (gen-undef-parallel-operand-macro (sfrag-sfmt frag))
	 "")
@


1.10
log
@2003-06-10  Dave Brolley  <brolley@@redhat.com>

        * sid-cpu.scm: Generate #include of config.h into @@prefix@@-sem.cxx.
        * sid-decode.scm: Generate #include of config.h into
        @@prefix@@-decode.cxx.
        * sid-model.scm: Generate #include of config.h into @@prefix@@-model.cxx.
@
text
@d476 2
a477 1
				(current-arch-name) ".")
d946 1
a946 1
		    (string-append ", " (obj:name user)))
@


1.9
log
@	* Makefile.am (srcroot): New var.
	(html): New rule.
	* Makefile.in: Regenerate.
	* cgen-doc.scm: New file.
	* html.scm: New file.
	* gen-all-doc: New file.
	* dev.scm (cload): Handle DOC application.
	(load-doc): New fn.
	* machs.scm (machs-for-cpu): New fn.
	* model.scm (models-for-cpu): New fn.
	* utils.scm (gen-c-copyright): Renamed from gen-copyright.
	All uses updated.
	(iota): Rewrite to be identical to pmacro version.  All uses updated.
	* utils-cgen.scm (alpha-sort-obj-list): New fn.
@
text
@d598 3
@


1.8
log
@2003-02-03  Frank Ch. Eigler  <fche@@redhat.com>

	* sid-cpu.scm (-gen-sfrag-engine-fn): Generate more hygienic C++.
@
text
@d77 1
a77 1
   (gen-copyright "Misc. entries in the @@arch@@ description file."
d215 1
a215 1
   (gen-copyright "CPU class elements for @@cpu@@."
d389 1
a389 1
   (gen-copyright "CPU family header for @@cpu@@ / @@prefix@@."
d475 1
a475 1
   (gen-copyright (string-append "Simulator instruction operand writer for "
d594 1
a594 1
   (gen-copyright "Simulator instruction semantics for @@prefix@@."
d1226 1
a1226 1
   (gen-copyright "Simulator instruction semantics for @@prefix@@."
@


1.7
log
@* better support multiple-isa devices.

2002-01-25  Frank Ch. Eigler  <fche@@redhat.com>

        * sid-cpu.scm (-gen-hardware-types): Generate single hardware union
        for multiple-isa configurations.
        * sid-decode.scm (-gen-decode-fn): Tolerate empty insn list.
@
text
@d1099 1
a1099 1
      frag_label_table = new (void*) [tabsize];
@


1.6
log
@2002-01-07  Ben Elliston  <bje@@redhat.com>

	* utils.scm (package-cygnus-simulators): Rename from this ..
	(package-red-hat-simulators): .. to this.
	* opcodes.scm (option-set!): Use package-red-hat-simulators.
	* sid-cpu.scm (cgen-desc.h): Likewise.
	(cgen-cpu.h): Likewise.
	(cgen-defs.h): Likewise.
	(cgen-write.cxx): Likewise.
	(cgen-semantics.cxx): Likewise.
	(cgen-sem-switch.cxx): Likewise.
	* sid-decode.scm (cgen-decode.h): Likewise.
	(cgen-decode.cxx): Likewise.
	* sid-model.scm (cgen-model.cxx): Likewise.
	* sid.scm (option-set!): Likewise.
	* sim.scm (option-set!): Likewise.
@
text
@d199 1
a199 30
   (if (with-multiple-isa?)
       (let ((keep-isas (current-keep-isa-name-list))
	     (candidates (find hw-need-storage? (current-hw-list))))
	 (string-list
	  ; First emit a struct that contains all the common elements.
	  ; A common element is one supported by more than isa.
	  (-gen-hardware-struct #f
				(find (lambda (hw)
					(> (count-common
					    keep-isas
					    (bitset-attr->list
					     (obj-attr-value hw 'ISA)))
					   1))
				      candidates))
	  ; Now emit structs for each isa.  These contain entries for elements
	  ; supported by exactly one isa.
	  (string-list-map (lambda (isa)
			     (-gen-hardware-struct
			      isa
			      (find (lambda (hw)
				      (= (count-common
					  keep-isas
					  (bitset-attr->list
					   (obj-attr-value hw 'ISA)))
					 1))
				    candidates)))
			   keep-isas)
	  ))
       (-gen-hardware-struct #f (find hw-need-storage? (current-hw-list))))
   )
@


1.5
log
@2002-01-07  Ben Elliston  <bje@@redhat.com>

	* utils.scm (copyright-fsf): Add 2002.
	(copyright-cygnus): Rename to copyright-red-hat.
	(copyright-red-hat): Add 2002.
	(CURRENT-COPYRIGHT): Update comment.
	* opcodes.scm (option-set!): Update callers.
	* sid-model.scm (cgen-model.cxx): Likewise.
	* sid-cpu.scm: Likewise.
	* sid-decode.scm: Likewise.
	* sid.scm (option-set!): Handle "redhat" as an option for
	"copyright"; use copyright-red-hat.
	* sim.scm (option-set!): Likewise.
@
text
@d78 1
a78 1
		  copyright-red-hat package-cygnus-simulators)
d245 1
a245 1
		  copyright-red-hat package-cygnus-simulators)
d419 1
a419 1
		  copyright-red-hat package-cygnus-simulators)
d506 1
a506 1
		 copyright-red-hat package-cygnus-simulators)
d624 1
a624 1
		  copyright-red-hat package-cygnus-simulators)
d1256 1
a1256 1
		  copyright-red-hat package-cygnus-simulators)
@


1.4
log
@* more 16/32-bit insn set support; simulator (sid)

2001-07-11  Frank Ch. Eigler  <fche@@redhat.com>

	* sid-cpu.scm (-gen-mach-params): New proc to emit ...CHUNK_BITSIZE...
	(cgen-desc.h): Call it.
	* sid-decode.scm (-gen-decode-fn): Use base-insn-bitsize as
	decode-size.
	* utils-sim.scm (-gen-decode-insn-entry): For SID only, prepare
	entire_insn for extraction, if it's shorter than base-insn-bitsize.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
d78 1
a78 1
		  copyright-cygnus package-cygnus-simulators)
d245 1
a245 1
		  copyright-cygnus package-cygnus-simulators)
d419 1
a419 1
		  copyright-cygnus package-cygnus-simulators)
d506 1
a506 1
		 copyright-cygnus package-cygnus-simulators)
d624 1
a624 1
		  copyright-cygnus package-cygnus-simulators)
d1256 1
a1256 1
		  copyright-cygnus package-cygnus-simulators)
@


1.3
log
@2001-04-02  Ben Elliston  <bje@@redhat.com>

	* sid-cpu.scm (-last-insn): New function.
	(-gen-sem-switch-engine): Loop through idesc while less than or
	equal to the last instruction enum, not less than the MAX enum.
	(-gen-sfrag-engine-fn): Clean up frag_label_table initialisation.
	* sid-decode.scm (-gen-decode-insn-globals): Define the idesc
	table's size to be the last instruction enum plus one, not
	@@PREFIX@@_INSN_MAX.
	* sid.scm (gen-cpu-insn-enum-decl): Do not append a dummy `max'
	instruction onto the instruction list.
@
text
@d60 11
d91 1
@


1.2
log
@* belated outward merge

2001-01-26  Frank Ch. Eigler  <fche@@redhat.com>

	* sid-cpu.scm (gen-parallel-exec-type): Use unsigned long long for
	writeback tracking.
	(-gen-write-fn, -gen-sem-case, -gen-sfrag-case): Ditto.
	* sid-decode.scm (-gen-scache-decls): Exclude writeback tracking field
	if unnecessary.
	* sid.scm (<operand> gen-write): Use unsigned long long expression
	for writeback.
	(-op-gen-set-trace, -op-gen-set-trace-parallel): Ditto.
	(<unit> gen-profile-code): Ditto.

2001-01-08  Frank Ch. Eigler  <fche@@redhat.com>

	* operand.scm (<operand> pretty-sem-name): New field.
	(<operand> make): Initialize it from hw-name.
	(op:set-pretty-sem-name!): New function.
	(<operand> gen-pretty-name): Default to fetching new field.
	* rtl.scm (hw): Copy hw-name to pretty-sem-name instead.  Restore
	sem-name setting from -rtx-hw-name.
@
text
@d8 4
d814 1
a814 1
      for (int i=0; i<@@PREFIX@@_INSN_MAX; i++)
d1056 1
a1056 6

   "\
  { @@PREFIX@@_INSN_MAX }
};
\n"
   )
d1114 4
a1117 2
      frag_label_table = new (void*) [@@PREFIX@@_INSN_MAX * 4];
      memset (frag_label_table, 0, sizeof (void*) * @@PREFIX@@_INSN_MAX * 4);
d1120 1
a1120 1
      for (i = 0, v = frag_label_table; i < @@PREFIX@@_INSN_MAX; ++i)
a1125 4

      // Record frags used by each insn.
      //for (int i = 0; @@prefix@@_frag_usage[i].itype != @@PREFIX@@_INSN_MAX; ++i)
      //  @@prefix@@_idesc::idesc_table[@@prefix@@_frag_usage[i].itype].frags = & @@prefix@@_frag_usage[i];
@


1.1
log
@2000-12-08  Ben Elliston  <bje@@redhat.com>

	* dev.scm (load-sid): New function.
	* cgen-sid.scm: New file.
	* sid-cpu.scm: Likeiwse.
	* sid-decode.scm: Likewise.
	* sid-model.scm: Likewise.
	* sid.scm: Likewise.
@
text
@d369 1
a369 1
  unsigned written;
d451 1
a451 1
   "  unsigned written = abuf->written;\n"
d548 1
a548 1
	 "  unsigned written = 0;\n"
d676 1
a676 1
	 "      unsigned written = 0;\n"
d971 1
a971 1
	 "      unsigned written = 0;\n"
@

