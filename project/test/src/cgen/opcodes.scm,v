head	1.21;
access;
symbols
	sid-snapshot-20180601:1.21
	cgen-snapshot-20180601:1.21
	sid-snapshot-20180501:1.21
	cgen-snapshot-20180501:1.21
	sid-snapshot-20180401:1.21
	cgen-snapshot-20180401:1.21
	sid-snapshot-20180301:1.21
	cgen-snapshot-20180301:1.21
	sid-snapshot-20180201:1.21
	cgen-snapshot-20180201:1.21
	sid-snapshot-20180101:1.21
	cgen-snapshot-20180101:1.21
	sid-snapshot-20171201:1.21
	cgen-snapshot-20171201:1.21
	sid-snapshot-20171101:1.21
	cgen-snapshot-20171101:1.21
	sid-snapshot-20171001:1.21
	cgen-snapshot-20171001:1.21
	sid-snapshot-20170901:1.21
	cgen-snapshot-20170901:1.21
	sid-snapshot-20170801:1.21
	cgen-snapshot-20170801:1.21
	sid-snapshot-20170701:1.21
	cgen-snapshot-20170701:1.21
	sid-snapshot-20170601:1.21
	cgen-snapshot-20170601:1.21
	sid-snapshot-20170501:1.21
	cgen-snapshot-20170501:1.21
	sid-snapshot-20170401:1.21
	cgen-snapshot-20170401:1.21
	sid-snapshot-20170301:1.21
	cgen-snapshot-20170301:1.21
	sid-snapshot-20170201:1.21
	cgen-snapshot-20170201:1.21
	sid-snapshot-20170101:1.21
	cgen-snapshot-20170101:1.21
	sid-snapshot-20161201:1.21
	cgen-snapshot-20161201:1.21
	sid-snapshot-20161101:1.21
	cgen-snapshot-20161101:1.21
	sid-snapshot-20160901:1.21
	cgen-snapshot-20160901:1.21
	sid-snapshot-20160801:1.21
	cgen-snapshot-20160801:1.21
	sid-snapshot-20160701:1.21
	cgen-snapshot-20160701:1.21
	sid-snapshot-20160601:1.21
	cgen-snapshot-20160601:1.21
	sid-snapshot-20160501:1.21
	cgen-snapshot-20160501:1.21
	sid-snapshot-20160401:1.21
	cgen-snapshot-20160401:1.21
	sid-snapshot-20160301:1.21
	cgen-snapshot-20160301:1.21
	sid-snapshot-20160201:1.21
	cgen-snapshot-20160201:1.21
	sid-snapshot-20160101:1.21
	cgen-snapshot-20160101:1.21
	sid-snapshot-20151201:1.21
	cgen-snapshot-20151201:1.21
	sid-snapshot-20151101:1.21
	cgen-snapshot-20151101:1.21
	sid-snapshot-20151001:1.21
	cgen-snapshot-20151001:1.21
	sid-snapshot-20150901:1.21
	cgen-snapshot-20150901:1.21
	sid-snapshot-20150801:1.21
	cgen-snapshot-20150801:1.21
	sid-snapshot-20150701:1.21
	cgen-snapshot-20150701:1.21
	sid-snapshot-20150601:1.21
	cgen-snapshot-20150601:1.21
	sid-snapshot-20150501:1.21
	cgen-snapshot-20150501:1.21
	sid-snapshot-20150401:1.21
	cgen-snapshot-20150401:1.21
	sid-snapshot-20150301:1.21
	cgen-snapshot-20150301:1.21
	sid-snapshot-20150201:1.21
	cgen-snapshot-20150201:1.21
	sid-snapshot-20150101:1.21
	cgen-snapshot-20150101:1.21
	sid-snapshot-20141201:1.21
	cgen-snapshot-20141201:1.21
	sid-snapshot-20141101:1.21
	cgen-snapshot-20141101:1.21
	sid-snapshot-20141001:1.21
	cgen-snapshot-20141001:1.21
	sid-snapshot-20140901:1.21
	cgen-snapshot-20140901:1.21
	sid-snapshot-20140801:1.21
	cgen-snapshot-20140801:1.21
	sid-snapshot-20140701:1.21
	cgen-snapshot-20140701:1.21
	sid-snapshot-20140601:1.21
	cgen-snapshot-20140601:1.21
	sid-snapshot-20140501:1.21
	cgen-snapshot-20140501:1.21
	sid-snapshot-20140401:1.21
	cgen-snapshot-20140401:1.21
	sid-snapshot-20140301:1.21
	cgen-snapshot-20140301:1.21
	sid-snapshot-20140201:1.21
	cgen-snapshot-20140201:1.21
	sid-snapshot-20140101:1.21
	cgen-snapshot-20140101:1.21
	sid-snapshot-20131201:1.21
	cgen-snapshot-20131201:1.21
	sid-snapshot-20131101:1.21
	cgen-snapshot-20131101:1.21
	sid-snapshot-20131001:1.21
	cgen-snapshot-20131001:1.21
	sid-snapshot-20130901:1.21
	cgen-snapshot-20130901:1.21
	sid-snapshot-20130801:1.21
	cgen-snapshot-20130801:1.21
	sid-snapshot-20130701:1.21
	cgen-snapshot-20130701:1.21
	sid-snapshot-20130601:1.21
	cgen-snapshot-20130601:1.21
	sid-snapshot-20130501:1.21
	cgen-snapshot-20130501:1.21
	sid-snapshot-20130401:1.21
	cgen-snapshot-20130401:1.21
	sid-snapshot-20130301:1.21
	cgen-snapshot-20130301:1.21
	sid-snapshot-20130201:1.21
	cgen-snapshot-20130201:1.21
	sid-snapshot-20130101:1.21
	cgen-snapshot-20130101:1.21
	sid-snapshot-20121201:1.21
	cgen-snapshot-20121201:1.21
	sid-snapshot-20121101:1.21
	cgen-snapshot-20121101:1.21
	sid-snapshot-20121001:1.21
	cgen-snapshot-20121001:1.21
	sid-snapshot-20120901:1.21
	cgen-snapshot-20120901:1.21
	sid-snapshot-20120801:1.21
	cgen-snapshot-20120801:1.21
	sid-snapshot-20120701:1.21
	cgen-snapshot-20120701:1.21
	sid-snapshot-20120601:1.21
	cgen-snapshot-20120601:1.21
	sid-snapshot-20120501:1.21
	cgen-snapshot-20120501:1.21
	sid-snapshot-20120401:1.21
	cgen-snapshot-20120401:1.21
	sid-snapshot-20120301:1.21
	cgen-snapshot-20120301:1.21
	sid-snapshot-20120201:1.21
	cgen-snapshot-20120201:1.21
	sid-snapshot-20120101:1.21
	cgen-snapshot-20120101:1.21
	sid-snapshot-20111201:1.21
	cgen-snapshot-20111201:1.21
	sid-snapshot-20111101:1.21
	cgen-snapshot-20111101:1.21
	sid-snapshot-20111001:1.21
	cgen-snapshot-20111001:1.21
	sid-snapshot-20110901:1.21
	cgen-snapshot-20110901:1.21
	sid-snapshot-20110801:1.21
	cgen-snapshot-20110801:1.21
	sid-snapshot-20110701:1.21
	cgen-snapshot-20110701:1.21
	sid-snapshot-20110601:1.21
	cgen-snapshot-20110601:1.21
	sid-snapshot-20110501:1.21
	cgen-snapshot-20110501:1.21
	sid-snapshot-20110401:1.21
	cgen-snapshot-20110401:1.21
	sid-snapshot-20110301:1.21
	cgen-snapshot-20110301:1.21
	sid-snapshot-20110201:1.21
	cgen-snapshot-20110201:1.21
	sid-snapshot-20110101:1.21
	cgen-snapshot-20110101:1.21
	sid-snapshot-20101201:1.21
	cgen-snapshot-20101201:1.21
	sid-snapshot-20101101:1.21
	cgen-snapshot-20101101:1.21
	sid-snapshot-20101001:1.21
	cgen-snapshot-20101001:1.21
	sid-snapshot-20100901:1.21
	cgen-snapshot-20100901:1.21
	sid-snapshot-20100801:1.21
	cgen-snapshot-20100801:1.21
	sid-snapshot-20100701:1.21
	cgen-snapshot-20100701:1.21
	sid-snapshot-20100601:1.21
	cgen-snapshot-20100601:1.21
	sid-snapshot-20100501:1.21
	cgen-snapshot-20100501:1.21
	sid-snapshot-20100401:1.21
	cgen-snapshot-20100401:1.21
	sid-snapshot-20100301:1.21
	cgen-snapshot-20100301:1.21
	sid-snapshot-20100201:1.20
	cgen-snapshot-20100201:1.20
	sid-snapshot-20100101:1.20
	cgen-snapshot-20100101:1.20
	sid-snapshot-20091201:1.20
	cgen-snapshot-20091201:1.20
	sid-snapshot-20091101:1.19
	cgen-snapshot-20091101:1.19
	sid-snapshot-20091001:1.18
	cgen-snapshot-20091001:1.18
	arc-sim-20090309:1.11
	sid-snapshot-20090901:1.15
	cgen-snapshot-20090901:1.15
	sid-snapshot-20090801:1.13
	cgen-snapshot-20090801:1.13
	sid-snapshot-20090701:1.12
	cgen-snapshot-20090701:1.12
	dje-cgen-play1-branch:1.12.0.2
	dje-cgen-play1-branchpoint:1.12
	cgen-1_1-branch:1.11.0.6
	cgen-1_1-branchpoint:1.11
	sid-snapshot-20090601:1.11
	cgen-snapshot-20090601:1.11
	sid-snapshot-20090501:1.11
	cgen-snapshot-20090501:1.11
	sid-snapshot-20090401:1.11
	cgen-snapshot-20090401:1.11
	arc-insight_6_8-branch:1.11.0.4
	arc-insight_6_8-branchpoint:1.11
	sid-snapshot-20090301:1.11
	cgen-snapshot-20090301:1.11
	sid-snapshot-20090201:1.11
	cgen-snapshot-20090201:1.11
	sid-snapshot-20090101:1.11
	cgen-snapshot-20090101:1.11
	sid-snapshot-20081201:1.11
	cgen-snapshot-20081201:1.11
	sid-snapshot-20081101:1.11
	cgen-snapshot-20081101:1.11
	sid-snapshot-20081001:1.11
	cgen-snapshot-20081001:1.11
	sid-snapshot-20080901:1.11
	cgen-snapshot-20080901:1.11
	sid-snapshot-20080801:1.11
	cgen-snapshot-20080801:1.11
	sid-snapshot-20080701:1.11
	cgen-snapshot-20080701:1.11
	sid-snapshot-20080601:1.11
	cgen-snapshot-20080601:1.11
	sid-snapshot-20080501:1.11
	cgen-snapshot-20080501:1.11
	sid-snapshot-20080403:1.11
	sid-snapshot-20080401:1.11
	cgen-snapshot-20080401:1.11
	sid-snapshot-20080301:1.11
	cgen-snapshot-20080301:1.11
	sid-snapshot-20080201:1.11
	cgen-snapshot-20080201:1.11
	sid-snapshot-20080101:1.11
	cgen-snapshot-20080101:1.11
	sid-snapshot-20071201:1.11
	cgen-snapshot-20071201:1.11
	sid-snapshot-20071101:1.11
	cgen-snapshot-20071101:1.11
	sid-snapshot-20071001:1.11
	cgen-snapshot-20071001:1.11
	msnyder-fork-checkpoint-branch:1.11.0.2
	msnyder-fork-checkpoint-branchpoint:1.11
	sid-20020905-branchpoint:1.4
	sid-20020905-branch:1.4.0.4
	cagney_regbuf-20020515-branch:1.4.0.2
	cagney_regbuf-20020515-branchpoint:1.4
	cygnus_cvs_20020108_pre:1.4
	cgen-1-1-branch:1.2.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.21
date	2010.02.10.04.22.57;	author devans;	state Exp;
branches;
next	1.20;

1.20
date	2009.11.03.16.24.02;	author devans;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.15.06.13.20;	author devans;	state Exp;
branches;
next	1.18;

1.18
date	2009.09.12.17.19.54;	author devans;	state Exp;
branches;
next	1.17;

1.17
date	2009.09.09.17.06.19;	author devans;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.07.22.17.34;	author devans;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.22.23.41.05;	author devans;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.19.04.20.29;	author devans;	state Exp;
branches;
next	1.13;

1.13
date	2009.07.07.18.27.08;	author devans;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2005.04.04.10.09.54;	author nickc;	state Exp;
branches
	1.11.6.1;
next	1.10;

1.10
date	2005.02.23.16.04.38;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.27.20.31.12;	author jimb;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.20.23.12.50;	author jimb;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.08.17.17.22;	author brolley;	state Exp;
branches;
next	1.6;

1.6
date	2003.07.16.05.35.47;	author devans;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.04.20.22.49;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.07.08.23.59;	author bje;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.07.07.05.05;	author bje;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.05.14.11.09;	author bje;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.12.2.1
date	2009.07.14.16.19.51;	author devans;	state Exp;
branches;
next	;

1.11.6.1
date	2009.06.24.14.57.46;	author devans;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.21
log
@tweak comment
@
text
@; General cpu info generator support.
; Copyright (C) 2000, 2002, 2005, 2009 Red Hat, Inc.
; This file is part of CGEN.

; Global state variables.

; Specify which application.
(set! APPLICATION 'OPCODES)

; Records the -OPC arg which specifies the path to the .opc file.
(define /opc-file-path #f)
(define (opc-file-path)
  (if /opc-file-path
      /opc-file-path
      (error ".opc file unspecified, missing -OPC argument"))
)
(define (set-opc-file-path! path)
  (set! /opc-file-path path)
)

; Return #t if the -OPC parameter was specified.

(define (opc-file-provided?)
  (and /opc-file-path #t)
)

; Boolean indicating if we're to build the operand instance table.
; The default is no, since only the m32r uses it at present.
; ??? Simulator tracing support could use it.
; ??? Might be lazily built at runtime by parsing the semantic code
; (which would be recorded in the insn table).
; FIXME: Referenced outside this file in opc-opinst.scm.
(define /opcodes-build-operand-instance-table? #f)

; String containing copyright text.
(define CURRENT-COPYRIGHT #f)

; String containing text defining the package we're generating code for.
(define CURRENT-PACKAGE #f)

; Initialize the options.

(define (option-init!)
  (set! /opcodes-build-operand-instance-table? #f)
  (set! CURRENT-COPYRIGHT copyright-fsf)
  (set! CURRENT-PACKAGE package-gnu-binutils-gdb)
  *UNSPECIFIED*
)

; Handle an option passed in from the command line.

(define (option-set! name value)
  (case name
    ((opinst) (set! /opcodes-build-operand-instance-table? #t))
    ((copyright) (cond ((equal?  value '("fsf"))
			(set! CURRENT-COPYRIGHT copyright-fsf))
		       ((equal? value '("redhat"))
			(set! CURRENT-COPYRIGHT copyright-red-hat))
		       (else (error "invalid copyright value" value))))
    ((package) (cond ((equal?  value '("binutils"))
		      (set! CURRENT-PACKAGE package-gnu-binutils-gdb))
		     ((equal?  value '("gnusim"))
		      (set! CURRENT-PACKAGE package-gnu-simulators))
		     ((equal? value '("cygsim"))
		      (set! CURRENT-PACKAGE package-red-hat-simulators))
		     (else (error "invalid package value" value))))
    (else (error "unknown option" name))
    )
  *UNSPECIFIED*
)

; Instruction fields support code.

; Default type of variable to use to hold ifield value.

(define (gen-ifield-default-type)
  ; FIXME: Use long for now.
  "long"
)

; Given field F, return a C definition of a variable big enough to hold
; its value.

(define (gen-ifield-value-decl f)
  (gen-obj-sanitize f (string-append "  "
				     (gen-ifield-default-type)
				     " " (gen-sym f) ";\n"))
)

; Return name of function to call to insert the value of <ifield> F
; into an insn.

(define (ifld-insert-fn-name f)
  "insert_normal"
)

; Return name of function to call to extract the value of <ifield> F
; into an insn.

(define (ifld-extract-fn-name f)
  "extract_normal"
)

; Default routine to emit C code to insert a field in an insn.

(method-make!
 <ifield> 'gen-insert
 (lambda (self operand)
   (let* ((encode (elm-get self 'encode))
	  (need-extra? encode) ; use to also handle operand's `insert' field
	  (varname (gen-operand-result-var self)))
     (string-append
      (if need-extra?
	  (string-append "      {\n"
			 "        "
			 (gen-ifield-default-type)
			 " value = " varname ";\n")
	  "")
      (if encode
	  (string-append "        value = "
			 ;; NOTE: ENCODE is either, e.g.,
			 ;; ((value pc) (sra <mode> value 1))
			 ;; or
			 ;; (((<mode> value) (<mode> pc)) (sra <mode> value 1))
			 (let ((expr (cadr encode))
			       (value (if (symbol? (caar encode)) (caar encode) (cadr (caar encode))))
			       (pc (if (symbol? (cadar encode)) (cadar encode) (cadr (cadar encode)))))
			   (rtl-c DFLT
				  (obj-isa-list self)
				  (list (list value (obj:name (ifld-decode-mode self)) "value")
					(list pc 'IAI "pc"))
				  expr))
			 ";\n")
	  "")
      (if need-extra?
	  "  "
	  "")
      "      errmsg = "
      (ifld-insert-fn-name self)
      " (cd, "
      (if need-extra?
	  "value"
	  varname)
      ", "
      ; We explicitly pass the attributes here rather than look them up
      ; to give the code more optimization opportunities.
      ; ??? Maybe when fields are recorded in opc.c, stop doing this, and
      ; pass a pointer to the recorded attributes instead.
      (gen-bool-attrs (if (eq? (mode:class (ifld-mode self)) 'INT)
			  (atlist-cons (bool-attr-make 'SIGNED #t)
				       (obj-atlist self))
			  (obj-atlist self))
		      gen-attr-mask)
      ", " (number->string (ifld-word-offset self))
      ", " (number->string (ifld-start self))
      ", " (number->string (ifld-length self))
      ", " (number->string (ifld-word-length self))
      ", total_length"
      ", buffer"
      ");\n"
      (if need-extra?
	  "      }\n"
	  "")
      )))
)

; Default routine to emit C code to extract a field from an insn.

(method-make!
 <ifield> 'gen-extract
 (lambda (self operand)
   (let* ((decode (elm-get self 'decode))
	  (need-extra? decode) ; use to also handle operand's `extract' field
	  (varname (gen-operand-result-var self)))
     (string-append
      (if need-extra?
	  (string-append "      {\n        "
			 (gen-ifield-default-type)
			 " value;\n  ")
	  "")
      "      length = "
      (ifld-extract-fn-name self)
      " (cd, ex_info, insn_value, "
      ; We explicitly pass the attributes here rather than look them up
      ; to give the code more optimization opportunities.
      ; ??? Maybe when fields are recorded in opc.c, stop doing this, and
      ; pass a pointer to the recorded attributes instead.
      (gen-bool-attrs (if (eq? (mode:class (ifld-mode self)) 'INT)
			  (atlist-cons (bool-attr-make 'SIGNED #t)
				       (obj-atlist self))
			  (obj-atlist self))
		      gen-attr-mask)
      ", " (number->string (ifld-word-offset self))
      ", " (number->string (ifld-start self))
      ", " (number->string (ifld-length self))
      ", " (number->string (ifld-word-length self))
      ", total_length"
      ", pc"
      ", & "
      (if need-extra?
	  "value"
	  varname)
      ");\n"
      (if decode
	  (string-append "        value = "
			 ;; NOTE: DECODE is either, e.g.,
			 ;; ((value pc) (sll DI value 1))
			 ;; or
			 ;; (((<mode> value) (<mode> pc)) (sll DI value 1))
			 (let ((expr (cadr decode))
			       (value (if (symbol? (caar decode)) (caar decode) (cadr (caar decode))))
			       (pc (if (symbol? (cadar decode)) (cadar decode) (cadr (cadar decode)))))
			   (rtl-c DFLT
				  (obj-isa-list self)
				  (list (list value (obj:name (ifld-decode-mode self)) "value")
					(list pc 'IAI "pc"))
				  expr))
			 ";\n")
	  "")
      (if need-extra?
	  (string-append "        " varname " = value;\n"
			 "      }\n")
	  "")
      )))
)

; gen-insert of multi-ifields

(method-make!
 <multi-ifield> 'gen-insert
 (lambda (self operand)
   (let* ((varname (gen-operand-result-var self))
	  (encode (elm-get self 'encode))
	  (need-extra? encode))
     (string-list
      "      {\n"
      (if need-extra?
	  (string-append "        " varname " = "
			 (let ((expr (cadr encode))
			       (value (caar encode))
			       (pc (cadar encode)))
			   (rtl-c DFLT
				  (obj-isa-list self)
				  (list (list value (obj:name (ifld-decode-mode self)) varname)
					(list pc 'IAI "pc"))
				  expr))
			 ";\n")
	  "")
      (let ((expr (elm-get self 'insert)))
	(rtl-c VOID (obj-isa-list self) nil expr))
      (string-list-map (lambda (subfld)
			 (string-list
			  "  "
			  (send subfld 'gen-insert operand)
			  "        if (errmsg)\n"
			  "          break;\n"))
		       (elm-get self 'subfields))
      "      }\n"
      )))
)

; gen-insert of derived-operands

(method-make!
 <derived-operand> 'gen-insert
 (lambda (self operand)
   "      abort();\n")
)

; gen-extract of multi-ifields

(method-make!
 <multi-ifield> 'gen-extract
 (lambda (self operand)
   (let* ((varname (gen-operand-result-var self))
	  (decode (elm-get self 'decode))
	  (need-extra? decode))
     (string-list
      "      {\n"
      (string-list-map (lambda (subfld)
			 (string-list
			  "  "
			  (send subfld 'gen-extract operand)
			  "        if (length <= 0) break;\n"
			  ))
		       (elm-get self 'subfields))
      (let ((expr (elm-get self 'extract)))
	(rtl-c VOID (obj-isa-list self) nil expr))
      (if need-extra?
	  (string-append "        " varname " = "
			 (let ((expr (cadr decode))
			       (value (caar decode))
			       (pc (cadar decode)))
			   (rtl-c DFLT
				  (obj-isa-list self)
				  (list (list value (obj:name (ifld-decode-mode self)) varname)
					(list pc 'IAI "pc"))
				  expr))
			 ";\n")
	  "")
      "      }\n"
      )))
)


(method-make!
 <derived-operand> 'gen-extract
 (lambda (self operand)
   "      abort();\n")
)

;(method-make!
; <derived-operand> 'gen-extract
; (lambda (self operand)
;   (string-list
;    "      {\n"
;    (string-list-map (lambda (subop)
;		       (string-list
;			"  " (send subop 'gen-extract operand)
;			"        if (length <= 0)\n"
;			"          break;\n"))
;		     (elm-get self 'args))
;    "      }\n"
;    ))
;)


; Hardware index support code.

(method-make!
 <hw-index> 'gen-insert
 (lambda (self operand)
   (case (hw-index:type self)
     ((ifield)
      (send (hw-index:value self) 'gen-insert operand))
     (else
      "")))
)

(method-make!
 <hw-index> 'gen-extract
 (lambda (self operand)
   (case (hw-index:type self)
     ((ifield)
      (send (hw-index:value self) 'gen-extract operand))
     (else
      ""))))

; HW-ASM is the base class for supporting hardware elements in the opcode table
; (aka assembler/disassembler).

; Utility to return C code to parse a number of <mode> MODE for an operand.
; RESULT-VAR-NAME is a string containing the variable to store the
; parsed number in.
; PARSE-FN is the name of the function to call or #f to use the default.
; OP-ENUM is the enum of the operand.

(define (/gen-parse-number mode parse-fn op-enum result-var-name)
  (string-append
   "      errmsg = "
   ; Use operand's special parse function if there is one, otherwise compute
   ; the function's name from the mode.
   (or parse-fn
       (case (obj:name mode)
	 ((QI HI SI INT) "cgen_parse_signed_integer")
	 ((BI UQI UHI USI UINT) "cgen_parse_unsigned_integer")
	 (else (error "unsupported (as yet) mode for parsing"
		      (obj:name mode)))))
   " (cd, strp, "
   op-enum
   ", "
   ; This is to pacify gcc 4.x which will complain about
   ; incorrect signed-ness of pointers passed to functions.
   (case (obj:name mode)
	 ((QI HI SI INT) "(long *)")
	 ((BI UQI UHI USI UINT) "(unsigned long *)")
   )
   " (& " result-var-name
   "));\n"
   )
)

; Utility to return C code to parse an address.
; RESULT-VAR-NAME is a string containing the variable to store the
; parsed number in.
; PARSE-FN is the name of the function to call or #f to use the default.
; OP-ENUM is the enum of the operand.

(define (/gen-parse-address parse-fn op-enum result-var-name)
  (string-append
   "      {\n"
   "        bfd_vma value = 0;\n"
   "        errmsg = "
   ; Use operand's special parse function if there is one.
   (or parse-fn
       "cgen_parse_address")
   " (cd, strp, "
   op-enum
   ", 0, " ; opinfo arg
   "NULL, " ; result_type arg (FIXME)
   " & value);\n"
   "        " result-var-name " = value;\n"
   "      }\n"
   )
)

; Return C code to parse an expression.

(method-make!
 <hw-asm> 'gen-parse
 (lambda (self operand)
   (let ((mode (elm-get self 'mode))
	 (result-var
	  (case (hw-index:type (op:index operand))
	    ((ifield) (gen-operand-result-var (op-ifield operand)))
	    (else "junk"))))
     (if (address? (op:type operand))
	 (/gen-parse-address (send operand 'gen-function-name 'parse)
			     (op-enum operand)
			     result-var)
	 (/gen-parse-number mode (send operand 'gen-function-name 'parse)
			    (op-enum operand)
			    result-var))))
)

; Default method to emit C code to print a hardware element.

(method-make!
 <hw-asm> 'gen-print
 (lambda (self operand)
   (let ((value
	  (case (hw-index:type (op:index operand))
	    ((ifield) (gen-operand-result-var (op-ifield operand)))
	    (else "0"))))
     (string-append
      "      "
      (or (send operand 'gen-function-name 'print)
	  (and (address? (op:type operand))
	       "print_address")
	  "print_normal")
;    (or (send operand 'gen-function-name 'print)
;	(case (obj:name (elm-get self 'mode))
;	  ((QI HI SI INT) "print_signed")
;	  ((BI UQI UHI USI UINT) "print_unsigned")
;	  (else (error "unsupported (as yet) mode for printing"
;		       (obj:name (elm-get self 'mode))))))
      " (cd, info, "
      value
      ", "
      ; We explicitly pass the attributes here rather than look them up
      ; to give the code more optimization opportunities.
      (gen-bool-attrs (if (eq? (mode:class (elm-get self 'mode)) 'INT)
			  (atlist-cons (bool-attr-make 'SIGNED #t)
				       (obj-atlist operand))
			  (obj-atlist operand))
		      gen-attr-mask)
      ;(gen-bool-attrs (obj-atlist operand) gen-attr-mask)
      ", pc, length"
      ");\n"
      )))
)

; Keyword support.

; Return C code to parse a keyword.

(method-make!
 <keyword> 'gen-parse
 (lambda (self operand)
   (let ((result-var 
	  (case (hw-index:type (op:index operand))
	    ((ifield) (gen-operand-result-var (op-ifield operand)))
	    (else "junk"))))
     (string-append
      "      errmsg = "
      (or (send operand 'gen-function-name 'parse)
	  "cgen_parse_keyword")
      " (cd, strp, "
      (send self 'gen-ref) ", "
      ;(op-enum operand) ", "
      "& " result-var
      ");\n"
      )))
)

; Return C code to print a keyword.

(method-make!
 <keyword> 'gen-print
 (lambda (self operand)
   (let ((value
	  (case (hw-index:type (op:index operand))
	    ((ifield) (gen-operand-result-var (op-ifield operand)))
	    (else "0"))))
     (string-append
      "      "
      (or (send operand 'gen-function-name 'print)
	  "print_keyword")
      " (cd, "
      "info" ; The disassemble_info argument to print_insn.
      ", "
      (send self 'gen-ref)
      ", " value
      ", "
      ; We explicitly pass the attributes here rather than look them up
      ; to give the code more optimization opportunities.
      (gen-bool-attrs (obj-atlist operand) gen-attr-mask)
      ");\n"
      )))
)

; Hardware support.

; For registers, use the indices field.  Ignore values.
; ??? Not that that will always be the case.

(method-make-forward! <hw-register> 'indices '(gen-parse gen-print))

; No such support for memory yet.

(method-make!
 <hw-memory> 'gen-parse
 (lambda (self operand)
   (error "gen-parse of memory not supported yet"))
)

(method-make!
 <hw-memory> 'gen-print
 (lambda (self operand)
   (error "gen-print of memory not supported yet"))
)

; For immediates, use the values field.  Ignore indices.
; ??? Not that that will always be the case.

(method-make-forward! <hw-immediate> 'values '(gen-parse gen-print))

; For addresses, use the values field.  Ignore indices.

(method-make-forward! <hw-address> 'values '(gen-parse gen-print))

; Generate the C code for dealing with operands.
; This code is inserted into cgen-{ibld,asm,dis}.in above the insn routines
; so that it can be inlined if desired.  ??? Actually this isn't always the
; case but this is minutiae to be dealt with much later.

; Generate the guts of a C switch to handle an operation for all operands.
; WHAT is one of fget/fset/parse/insert/extract/print.
;
; The "f" prefix (e.g. set -> fset) is for "field" to distinguish the
; operations from similar ones in other contexts.  ??? I'd prefer to come
; up with better names for fget/fset but I haven't come up with anything
; satisfactory yet.

(define (gen-switch what)
  (string-list-map
   (lambda (ops)
     ; OPS is a list of operands with the same name that for whatever reason
     ; were defined separately.
     (logit 3 (string/symbol-append
	       "Processing " (obj:str-name (car ops)) " " what " ...\n"))
     (if (= (length ops) 1)
	 (gen-obj-sanitize
	  (car ops)
	  (string-list
	   "    case @@ARCH@@_OPERAND_"
	   (string-upcase (gen-sym (car ops)))
	   " :\n"
	   (send (car ops) (symbol-append 'gen- what) (car ops))
	   "      break;\n"))
	 (string-list
	  ; FIXME: operand name doesn't get sanitized.
	  "    case @@ARCH@@_OPERAND_"
	  (string-upcase (gen-sym (car ops)))
	  " :\n"
	  ; There's more than one operand defined with this name, so we
	  ; have to distinguish them.
	  ; FIXME: Unfinished.
	  (string-list-map (lambda (op)
			     (gen-obj-sanitize
			      op
			      (string-list
			       (send op (symbol-append 'gen- what) op)
			       )))
			   ops)
	  "      break;\n"
	  )))
   (op-sort (find (lambda (op) (and (not (has-attr? op 'SEM-ONLY))
				    (not (anyof-operand? op))
				    (not (derived-operand? op))))
		  (current-op-list))))
)

; Operand support.

; Return the function name to use for WHAT or #f if there isn't a special one.
; WHAT is one of fget/fset/parse/insert/extract/print.

(method-make!
 <operand> 'gen-function-name
 (lambda (self what)
   (let ((handlers (elm-get self 'handlers)))
     (let ((fn (assq-ref handlers what)))
       (and fn (string-append (symbol->string what) "_" (car fn))))))
)

; Interface fns.
; The default is to forward the request onto TYPE.
; OP is a copy of SELF so the method we forward to sees it.
; There is one case in the fget/fset/parse/insert/extract/print
; switches for each operand.
; These are invoked via gen-switch.

; Emit C code to get an operand value from the fields struct.
; Operand values are stored in a struct "indexed" by field name.
;
; The "f" prefix (e.g. set -> fset) is for "field" to distinguish the
; operations from similar ones in other contexts.  ??? I'd prefer to come
; up with better names for fget/fset but I haven't come up with anything
; satisfactory yet.

(method-make!
 <operand> 'gen-fget
 (lambda (self operand)
   (case (hw-index:type (op:index self))
     ((ifield)
      (string-append "      value = "
		     (gen-operand-result-var (op-ifield self))
		     ";\n"))
     (else
      "      value = 0;\n")))
)

(method-make!
 <derived-operand> 'gen-fget
 (lambda (self operand)
   "      abort();\n") ; should never be called
)

; Emit C code to save an operand value in the fields struct.

(method-make!
 <operand> 'gen-fset
 (lambda (self operand)
   (case (hw-index:type (op:index self))
     ((ifield)
      (string-append "      "
		     (gen-operand-result-var (op-ifield self))
		     " = value;\n"))
     (else
      ""))) ; ignore
)

(method-make!
 <derived-operand> 'gen-fset
 (lambda (self operand)
   "      abort();\n") ; should never be called
)

; Need to call op:type to resolve the hardware reference.
;(method-make-forward! <operand> 'type '(gen-parse gen-print))

(method-make!
 <operand> 'gen-parse
 (lambda (self operand)
   (send (op:type self) 'gen-parse operand))
)

(method-make!
 <derived-operand> 'gen-parse
 (lambda (self operand)
   "      abort();\n") ; should never be called
)

(method-make!
 <operand> 'gen-print
 (lambda (self operand)
   (send (op:type self) 'gen-print operand))
)

(method-make!
 <derived-operand> 'gen-print
 (lambda (self operand)
   "      abort();\n") ; should never be called
)

(method-make-forward! <operand> 'index '(gen-insert gen-extract))
; But: <derived-operand> has its own gen-insert / gen-extract.

; Return the value of PC.
; Used by insert/extract fields.

(method-make!
 <pc> 'cxmake-get
 (lambda (self estate mode index selector)
   (cx:make IAI "pc"))
)

; Opcodes init,finish,analyzer support.

; Initialize any opcodes specific things before loading the .cpu file.

(define (opcodes-init!)
  (desc-init!)
  (mode-set-biggest-word-bitsizes!)
  *UNSPECIFIED*
)

; Finish any opcodes specific things after loading the .cpu file.
; This is separate from analyze-data! as cpu-load performs some
; consistency checks in between.

(define (opcodes-finish!)
  (desc-finish!)
  *UNSPECIFIED*
)

; Compute various needed globals and assign any computed fields of
; the various objects.  This is the standard routine that is called after
; a .cpu file is loaded.

(define (opcodes-analyze!)
  (desc-analyze!)

  ; Initialize the rtl->c translator.
  (rtl-c-config!)

  ; Only include semantic operands when computing the format tables if we're
  ; generating operand instance tables.
  ; ??? Actually, may always be able to exclude the semantic operands.
  ; Still need to traverse the semantics to derive machine computed attributes.
  (arch-analyze-insns! CURRENT-ARCH
		       #t ; include aliases
		       /opcodes-build-operand-instance-table?)

  *UNSPECIFIED*
)

; Extra target specific code generation.

; Pick out a section from the .opc file.
; The section is delimited with:
; /* -- name ... */
; ...
; /* -- ... */
;
; FIXME: This is a pretty involved bit of code.  'twould be nice to split
; it up into manageable chunks.

(define (read-cpu.opc opc-file delim)
  (let ((file opc-file)
	(start-delim (string-append "/* -- " delim))
	(end-delim "/* -- "))
    (if (file-exists? file)
	(let ((port (open-file file "r"))
	      ; Extra amount is added to SIZE so substring's to fetch possible
	      ; delim won't fail, even at end of file
	      (size (+ (file-size file) (string-length start-delim))))
	  (if port
	      (let ((result (make-string size #\space)))
		(let loop ((start -1) (line 0) (index 0))
		  (let ((char (read-char port)))
		    (if (not (eof-object? char))
			(string-set! result index char))
		    (cond ((eof-object? char)
			   (begin
			     (close-port port)
			     ; End of file, did we find the text?
			     (if (=? start -1)
				 ""
				 (substring result start index))))
			  ((char=? char #\newline)
			   ; Check for start delim or end delim?
			   (if (=? start -1)
			       (if (string=? (substring result line
							(+ (string-length start-delim)
							   line))
					     start-delim)
				   (loop line (+ index 1) (+ index 1))
				   (loop -1 (+ index 1) (+ index 1)))
			       (if (string=? (substring result line
							(+ (string-length end-delim)
							   line))
					     end-delim)
				   (begin
				     (close-port port)
				     (substring result start (+ index 1)))
				   (loop start (+ index 1) (+ index 1)))))
			  (else
			   (loop start line (+ index 1)))))))
		(error "Unable to open:" file)))
	"" ; file doesn't exist
	))
)

(define (gen-extra-cpu.h opc-file arch)
  (logit 2 "Generating extra cpu.h stuff from " arch ".opc ...\n")
  (read-cpu.opc opc-file "cpu.h")
)
(define (gen-extra-cpu.c opc-file arch)
  (logit 2 "Generating extra cpu.c stuff from " arch ".opc ...\n")
  (read-cpu.opc opc-file "cpu.c")
)
(define (gen-extra-opc.h opc-file arch)
  (logit 2 "Generating extra opc.h stuff from " arch ".opc ...\n")
  (read-cpu.opc opc-file "opc.h")
)
(define (gen-extra-opc.c opc-file arch)
  (logit 2 "Generating extra opc.c stuff from " arch ".opc ...\n")
  (read-cpu.opc opc-file "opc.c")
)
(define (gen-extra-asm.c opc-file arch)
  (logit 2 "Generating extra asm.c stuff from " arch ".opc ...\n")
  (read-cpu.opc opc-file "asm.c")
)
(define (gen-extra-dis.c opc-file arch)
  (logit 2 "Generating extra dis.c stuff from " arch ".opc ...\n")
  (read-cpu.opc opc-file "dis.c")
)
(define (gen-extra-ibld.h opc-file arch)
  (logit 2 "Generating extra ibld.h stuff from " arch ".opc ...\n")
  (read-cpu.opc opc-file "ibld.h")
)
(define (gen-extra-ibld.c opc-file arch)
  (logit 2 "Generating extra ibld.c stuff from " arch ".opc ...\n")
  (read-cpu.opc opc-file "ibld.c")
)

; For debugging.

(define (cgen-all)
  (string-write
   cgen-desc.h
   cgen-desc.c
   cgen-opinst.c
   cgen-opc.h
   cgen-opc.c
   cgen-ibld.h
   cgen-ibld.in
   cgen-asm.in
   cgen-dis.in
   )
)
@


1.20
log
@	Specify isa(s) when doing ifield, operand, insn lookups.
	ACU = all callers updated.
	* attr.scm (/attr-eval): Call rtx-value instead of rtx-eval-with-estate.
	* enum.scm (define-full-insn-enum): Pass isa-name-list to
	current-ifld-lookup.
	* html.scm (get-insn-properties): Pass isa-name-list to
	current-op-lookup.
	* ifield.scm (/ifld-parse-follows): New arg isas, ACU.
	* insn.scm (/parse-insn-format-symbol): New arg isa-name-list, ACU.
	(/parse-insn-format-list, /parse-insn-iformat-iflds): Ditto.
	(/parse-insn-format, syntax-break-out): Ditto.
	* mach.scm (obj-filter-by-isa): New function.
	(current-ifld-lookup): New optional arg maybe-isa-name-list.
	(/ifld-already-defined?, /op-already-defined?): Simplify.
	(current-op-lookup): New optional arg maybe-isa-name-list.
	(current-insn-lookup): New arg isa-name-list, ACU.
	(/insn-already-defined?, /minsn-already-defined?): Simplify.
	(current-minsn-lookup): New arg isa-name-list, ACU.
	* minsn.scm (/minsn-compute-iflds): Pass isa-name-list to
	current-op-lookup.
	* opc-itab.scm (compute-syntax): New arg isa-name-list, ACU.
	(gen-syntax-entry): Ditto.
	* operand.scm (/operand-parse): Pass isa-name-list to
	current-ifld-lookup.
	(/derived-parse-encoding): New arg isa-name-list, ACU.
	(/derived-parse-ifield-assertion): Ditto.
	(/derived-operand-parse): Pass isa-name-list to current-op-lookup.
	(/anyof-parse-choice): Ditto.
	(anyof-satisfies-assertions?): Pass context to rtx-solve.
	(/anyof-merge-syntax): New arg container, ACU.
	(operand-builtin!): Add pc to all isas.
	* rtl-c.scm (estate-make-for-rtl-c): Delete arg extra-vars-alist, ACU.
	(estate-make-for-rtl-c++, rtl-c-expr-parsed): Ditto.
	(rtl-c-parsed, rtl-c++-parsed): Ditto.
	(rtl-c): New arg isa-name-list, ACU.
	(rtl-c-expr, rtl-c++): Ditto.
	(closure): New arg isa-name-list, ACU.
	* rtl-traverse.scm (/make-cstate): New arg isa-name-list, ACU.
	(/cstate-isas): New function.
	(/rtx-canon-symbol-list): New function.
	(/rtx-canon-env-stack): Renamed from /rtx-canon-env, ACU.
	updated.
	(/rtx-make-canon-table): Rename ENV to ENVSTACK, new entry SYMBOLLIST.
	(/rtx-canon-rtx-operand): Pass isa list to current-op-lookup.
	(/rtx-canon-rtx-ref, /rtx-canon): Ditto.
	(rtx-canonicalize): New arg isa-name-list, ACU.
	(rtx-canonicalize-stmt): Delete.
	(tstate-make): New arg isas, ACU.
	(tstate-isas, tstate--set-isas!): New functions.
	(tstate-env-stack): Renamed from tstate-env, ACU.
	(tstate-set-env-stack!): Renamed from tstate-set-env!, ACU.
	(tstate-make-closure): Renamed from tstate-new-env, new arg
	isa-name-list, ACU.
	(/rtx-traverse-env): Delete.
	(/rtx-make-traverser-table): Rename ENV to ENVSTACK, new entry
	SUMBOLLIST.
	(/rtx-traverse): Include conditional flag in dump output.
	Update isa,envstack for closures.  Pass isa list to current-op-lookup.
	(<eval-state>): New member isas.  Rename env to env-stack.
	(<eval-state> vmake!): Handle #:isas.  #:env renamed to #:env-stack.
	(<eval-state>): New getter/setter for isas.  Rename env getter/setter
	to env-stack.
	(estate-make-for-eval): Provide #:isas.
	(estate-make-closure): Renamed from estate-new-env.  New arg
	isa-name-list, ACU.
	* rtl-xform.scm (/rtx-simplify-expr-fn): Handle closures.
	(/rtx-trim-args): ENV renamed to ENVSTACK.  Ad ITERATION, SYMBOLLIST.
	(/rtx-trim-for-doc): Handle closures.
	* rtl.scm (/rtx-valid-types): Rename ENV to ENVSTACK.  Add ITERATION,
	SYMBOLLIST.
	(rtx-env-var-list): Delete.
	(rtx-env-make): Handle already-compiled environments.
	(rtx-var-alist-to-env): New function.
	(rtx-var-alist-to-closure-env-stack, rtx-make-env-stack): New functions.
	(rtx-env-stack-dump): Renamed from rtx-env-dump, ACU.
	(rtx-operand-obj): New arg isa-name-list, ACU.
	(rtx-closure-isas, rtx-closure-env-stack, rtx-closure-expr): New
	functions.
	* rtx-funcs.scm (closure): New arg isa-name-list, reorder args, ACU.
	* sem-frags.scm (<sfrag>): Delete member compiled-semantics.
	(/frag-compute-desired-frags): Minor simplification.
	(/frag-pick-best): Ditto.
	* sid-cpu.scm (gen-semantic-code): Require canonical rtl.
	(/gen-sfrag-code): Update.
	* sim-cpu.scm (gen-semantic-code): Require canonical rtl.
	* utils-cgen.scm (sanitize): New arg isa-name-list, ACU.
	* utils.scm (non-null-intersection?): New function.
@
text
@d122 1
a122 1
			 ;; ((value pc) (sra DI value 1))
d124 1
a124 1
			 ;; (((<mode> value) (<mode> pc)) (sra DI value 1))
@


1.19
log
@	* opcode.scm (<ifield>, 'gen-insert): Use ifld-decode-mode instead of
	ifld-encode-mode.
	(<multi-ifield>, 'gen-insert): Ditto.
@
text
@d128 2
a129 1
			   (rtl-c DFLT expr
d131 2
a132 1
					(list pc 'IAI "pc"))))
d213 2
a214 1
			   (rtl-c DFLT expr
d216 2
a217 1
					(list pc 'IAI "pc"))))
d242 2
a243 1
			   (rtl-c DFLT expr
d245 2
a246 1
					(list pc 'IAI "pc"))))
d250 1
a250 1
	(rtl-c VOID expr nil))
d288 1
a288 1
	(rtl-c VOID expr nil))
d294 2
a295 1
			   (rtl-c DFLT expr
d297 2
a298 1
					(list pc 'IAI "pc"))))
@


1.18
log
@whitespace tweaks
@
text
@d129 1
a129 1
				  (list (list value (obj:name (ifld-encode-mode self)) "value")
d239 1
a239 1
				  (list (list value (obj:name (ifld-encode-mode self)) varname)
@


1.17
log
@	* dev.scm (*): Change default verbosity level to 2.

	* ifield.scm (<ifield> pretty-print): New method.
	(ifld-pretty-print): New function.
	(<multi-ifield> pretty-print): New method.

	* ifield.scm (<ifield> field-start): Delete word-len arg.
	All callers updated.
	(ifld-start): Ditto.
	(<multi-ifield> field-start): Ditto.
	* operand.scm (<hw-index> field-start): Ditto.
@
text
@a651 1

a681 1

@


1.16
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d153 1
a153 1
      ", " (number->string (ifld-start self #f))
d192 1
a192 1
      ", " (number->string (ifld-start self #f))
@


1.15
log
@	* Makefile.am (OPTIONS): Define.
	(desc): Just generate <arch>-desc.[ch] files.
	* Makefile.in: Regenerate.
	* desc-cpu.scm (cgen-desc.h): Skip call to gen-extra-cpu.h if there's
	no .opc file.
	(cgen-desc.c): Similarly.
	* gen-all-desc: New file.
	* opcodes.scm (opc-file-provided?): New function.
@
text
@d11 1
a11 1
(define -opc-file-path #f)
d13 2
a14 2
  (if -opc-file-path
      -opc-file-path
d18 1
a18 1
  (set! -opc-file-path path)
d24 1
a24 1
  (and -opc-file-path #t)
d32 2
a33 1
(define -opcodes-build-operand-instance-table? #f)
d44 1
a44 1
  (set! -opcodes-build-operand-instance-table? #f)
d54 1
a54 1
    ((opinst) (set! -opcodes-build-operand-instance-table? #t))
d350 1
a350 1
(define (-gen-parse-number mode parse-fn op-enum result-var-name)
d381 1
a381 1
(define (-gen-parse-address parse-fn op-enum result-var-name)
d410 1
a410 1
	 (-gen-parse-address (send operand 'gen-function-name 'parse)
d413 1
a413 1
	 (-gen-parse-number mode (send operand 'gen-function-name 'parse)
d728 1
a728 1
		       -opcodes-build-operand-instance-table?)
@


1.14
log
@	* ifield.scm (ifld-encode-mode): Add FIXME.
	* opcodes.scm (<ifield> 'gen-insert): Handle encode parameters with
	modes.
	(<ifield> 'gen-extract): Similarly.

	* read.scm (parse-error): Handle #f for context-location.
	* utils-cgen.scm (unspecified-location): Fix building of
	single-location.
@
text
@d21 6
@


1.13
log
@	* cgen-opc.scm (-opc-file-path,opc-file-path): Move to opcodes.scm
	(opc-arguments, -OPC): Call set-opc-file-path!.
	* opcodes.scm (-opc-file-path,opc-file-path): Moved here.
	(set-opc-file-path!): New function.
	* dev.scm: Mention set-opc-file-path!.  Mention doc options.
@
text
@d114 4
d119 2
a120 2
			       (value (caar encode))
			       (pc (cadar encode)))
d197 4
d202 2
a203 2
			       (value (caar decode))
			       (pc (cadar decode)))
@


1.12
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d10 11
@


1.12.2.1
log
@Bring over various patches from the trunk.
@
text
@a9 11
; Records the -OPC arg which specifies the path to the .opc file.
(define -opc-file-path #f)
(define (opc-file-path)
  (if -opc-file-path
      -opc-file-path
      (error ".opc file unspecified, missing -OPC argument"))
)
(define (set-opc-file-path! path)
  (set! -opc-file-path path)
)

@


1.11
log
@Initialise value to zero to avoid a compile time warning.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2002, 2005 Red Hat, Inc.
@


1.11.6.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2002, 2005, 2009 Red Hat, Inc.
@


1.10
log
@Fix compile time warnings generated by gcc 4.0
@
text
@d358 1
a358 1
   "        bfd_vma value;\n"
@


1.9
log
@* utils.scm (string/symbol->append): Renamed from 'concat'.
* opcodes.scm (gen-switch): Use new name.
* insn.scm (-sub-insn-make!): Same.
* rtl.scm (rtx-dump): Same.
* semantics.scm (semantic-compile): Same.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2002 Red Hat, Inc.
d337 9
a345 2
   ", &" result-var-name
   ");\n"
@


1.8
log
@* opcodes.scm (gen-switch): Use concat instead of string-map.
@
text
@d519 2
a520 1
     (logit 3 (concat "Processing " (obj:str-name (car ops)) " " what " ...\n"))
@


1.7
log
@2003-09-08  Dave Brolley  <brolley@@redhat.com>

        On behalf of Doug Evans <dje@@sebabeach.org>
        Pass in paths to input files, instead of assuming they live in
        $srcdir/cpu.  Plus misc. option processing cleanup.
        * cgen-doc.scm (doc-arguments): Make options strings not symbols.
        Add pre-process pass to all options.
        * cgen-gas.scm (gas-arguments): Ditto.
        * cgen-sid.scm (sim-arguments): Ditto.
        * cgen-sim.scm (sim-arguments): Ditto.
        * cgen-stest.scm (stest-arguments): Ditto.
        * cgen-opc.scm (opc-arguments): Ditto.  New argument -OPC.
        (-opc-file-path): New global.
        (opc-file-path): New fn.
        * opcodes.scm (read-cpu.opc): Replace srcdir,cpu args with opc-file.
        All callers updated.
        (gen-extra-cpu.h,gen-extra-cpu.c,gen-extra-opc.h,gen-extra-opc.c,
        gen-extra-asm.c,gen-extra-dis.c,gen-extra-ibld.h,gen-extra-ibld.c):
        Replace srcdir arg with opc-file.  All callers updated.
        * read.scm (-opt-spec-update): Delete.
        (opt-get-first-pass,opt-get-second-pass): New fns.
        (-cgen): Process application-specific arguments in two passes.
@
text
@d519 1
a519 1
     (logit 3 (string-append "Processing " (obj:str-name (car ops)) " " what " ...\n"))
@


1.6
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@a699 1
; For now, such code lives in <arch>.opc.
d710 2
a711 4
(define (read-cpu.opc srcdir cpu delim)
  (let ((file (string-append srcdir "/cpu/"
			     (symbol->string (current-arch-name))
			     ".opc"))
d756 1
a756 2
; FIXME: collapse into one?
(define (gen-extra-cpu.h srcdir arch)
d758 1
a758 1
  (read-cpu.opc srcdir arch "cpu.h")
d760 1
a760 1
(define (gen-extra-cpu.c srcdir arch)
d762 1
a762 1
  (read-cpu.opc srcdir arch "cpu.c")
d764 1
a764 1
(define (gen-extra-opc.h srcdir arch)
d766 1
a766 1
  (read-cpu.opc srcdir arch "opc.h")
d768 1
a768 1
(define (gen-extra-opc.c srcdir arch)
d770 1
a770 1
  (read-cpu.opc srcdir arch "opc.c")
d772 1
a772 1
(define (gen-extra-asm.c srcdir arch)
d774 1
a774 1
  (read-cpu.opc srcdir arch "asm.c")
d776 1
a776 1
(define (gen-extra-dis.c srcdir arch)
d778 1
a778 1
  (read-cpu.opc srcdir arch "dis.c")
d780 1
a780 1
(define (gen-extra-ibld.h srcdir arch)
d782 1
a782 1
  (read-cpu.opc srcdir arch "ibld.h")
d784 1
a784 1
(define (gen-extra-ibld.c srcdir arch)
d786 1
a786 1
  (read-cpu.opc srcdir arch "ibld.c")
@


1.5
log
@	Better handling of 64 bit and mixed 32/64 bit architectures.
	* hardware.scm (hw-update-word-modes!): New fn.
	* mach.scm (define-cpu)): Call mode-set-word-modes!,
	hw-update-word-modes!.
	(state-word-bitsize): Replace FIXME with requested check.
	(arch-analyze-insns!): Call mode-ensure-word-sizes-defined.
	* mode.scm (mode-find): Ignore INT,UINT.
	(-mode-word-sizes-kind): New global.
	(mode-set-word-modes!,mode-set-identical-word-bitsizes!,
	mode-set-biggest-word-bitsizes!,mode-ensure-word-sizes-defined): New fns.
	(mode-init!): Initialize -mode-word-sizes-kind.  Move initialization
	of mode-list to ...
	(mode-builtin!): ... here.  Initialize WI/UWI/AI/IAI to something
	unusable, correct values set later.
	(mode-finish!): Remove cruft.
	* html.scm (doc-init!): Call mode-set-biggest-word-bitsizes!.
	* opcodes.scm (opcodes-init!): Ditto.
	* rtx-funcs.scm (annul): Fix mode of pc.
	* cpu/ia64.cpu: Remove cruft that sets word modes.
	* cpu/xstormy16.cpu (define-cpu): Set word-bitsize.
@
text
@d519 1
a519 1
     (logit 3 (string-append "Processing " (obj:name (car ops)) " " what " ...\n"))
d562 1
a562 1
       (and fn (string-append what "_" (car fn))))))
d712 3
a714 1
  (let ((file (string-append srcdir "/cpu/" (current-arch-name) ".opc"))
@


1.4
log
@2002-01-07  Ben Elliston  <bje@@redhat.com>

	* utils.scm (package-cygnus-simulators): Rename from this ..
	(package-red-hat-simulators): .. to this.
	* opcodes.scm (option-set!): Use package-red-hat-simulators.
	* sid-cpu.scm (cgen-desc.h): Likewise.
	(cgen-cpu.h): Likewise.
	(cgen-defs.h): Likewise.
	(cgen-write.cxx): Likewise.
	(cgen-semantics.cxx): Likewise.
	(cgen-sem-switch.cxx): Likewise.
	* sid-decode.scm (cgen-decode.h): Likewise.
	(cgen-decode.cxx): Likewise.
	* sid-model.scm (cgen-model.cxx): Likewise.
	* sid.scm (option-set!): Likewise.
	* sim.scm (option-set!): Likewise.
@
text
@d665 1
@


1.3
log
@2002-01-07  Ben Elliston  <bje@@redhat.com>

	* utils.scm (copyright-fsf): Add 2002.
	(copyright-cygnus): Rename to copyright-red-hat.
	(copyright-red-hat): Add 2002.
	(CURRENT-COPYRIGHT): Update comment.
	* opcodes.scm (option-set!): Update callers.
	* sid-model.scm (cgen-model.cxx): Likewise.
	* sid-cpu.scm: Likewise.
	* sid-decode.scm: Likewise.
	* sid.scm (option-set!): Handle "redhat" as an option for
	"copyright"; use copyright-red-hat.
	* sim.scm (option-set!): Likewise.
@
text
@d47 1
a47 1
		      (set! CURRENT-PACKAGE package-cygnus-simulators))
@


1.2
log
@2001-07-06  Ben Elliston  <bje@@redhat.com>

	* opcodes.scm (read-cpu.opc): Read .opc files from subdir/cpu.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
d39 2
a40 2
		       ((equal? value '("cygnus"))
			(set! CURRENT-COPYRIGHT copyright-cygnus))
@


1.1
log
@Initial revision
@
text
@d711 1
a711 1
  (let ((file (string-append srcdir "/" (current-arch-name) ".opc"))
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
