head	1.8;
access;
symbols
	sid-snapshot-20180601:1.8
	cgen-snapshot-20180601:1.8
	sid-snapshot-20180501:1.8
	cgen-snapshot-20180501:1.8
	sid-snapshot-20180401:1.8
	cgen-snapshot-20180401:1.8
	sid-snapshot-20180301:1.8
	cgen-snapshot-20180301:1.8
	sid-snapshot-20180201:1.8
	cgen-snapshot-20180201:1.8
	sid-snapshot-20180101:1.8
	cgen-snapshot-20180101:1.8
	sid-snapshot-20171201:1.8
	cgen-snapshot-20171201:1.8
	sid-snapshot-20171101:1.8
	cgen-snapshot-20171101:1.8
	sid-snapshot-20171001:1.8
	cgen-snapshot-20171001:1.8
	sid-snapshot-20170901:1.8
	cgen-snapshot-20170901:1.8
	sid-snapshot-20170801:1.8
	cgen-snapshot-20170801:1.8
	sid-snapshot-20170701:1.8
	cgen-snapshot-20170701:1.8
	sid-snapshot-20170601:1.8
	cgen-snapshot-20170601:1.8
	sid-snapshot-20170501:1.8
	cgen-snapshot-20170501:1.8
	sid-snapshot-20170401:1.8
	cgen-snapshot-20170401:1.8
	sid-snapshot-20170301:1.8
	cgen-snapshot-20170301:1.8
	sid-snapshot-20170201:1.8
	cgen-snapshot-20170201:1.8
	sid-snapshot-20170101:1.8
	cgen-snapshot-20170101:1.8
	sid-snapshot-20161201:1.8
	cgen-snapshot-20161201:1.8
	sid-snapshot-20161101:1.8
	cgen-snapshot-20161101:1.8
	sid-snapshot-20160901:1.8
	cgen-snapshot-20160901:1.8
	sid-snapshot-20160801:1.8
	cgen-snapshot-20160801:1.8
	sid-snapshot-20160701:1.8
	cgen-snapshot-20160701:1.8
	sid-snapshot-20160601:1.8
	cgen-snapshot-20160601:1.8
	sid-snapshot-20160501:1.8
	cgen-snapshot-20160501:1.8
	sid-snapshot-20160401:1.8
	cgen-snapshot-20160401:1.8
	sid-snapshot-20160301:1.8
	cgen-snapshot-20160301:1.8
	sid-snapshot-20160201:1.8
	cgen-snapshot-20160201:1.8
	sid-snapshot-20160101:1.8
	cgen-snapshot-20160101:1.8
	sid-snapshot-20151201:1.8
	cgen-snapshot-20151201:1.8
	sid-snapshot-20151101:1.8
	cgen-snapshot-20151101:1.8
	sid-snapshot-20151001:1.8
	cgen-snapshot-20151001:1.8
	sid-snapshot-20150901:1.8
	cgen-snapshot-20150901:1.8
	sid-snapshot-20150801:1.8
	cgen-snapshot-20150801:1.8
	sid-snapshot-20150701:1.8
	cgen-snapshot-20150701:1.8
	sid-snapshot-20150601:1.8
	cgen-snapshot-20150601:1.8
	sid-snapshot-20150501:1.8
	cgen-snapshot-20150501:1.8
	sid-snapshot-20150401:1.8
	cgen-snapshot-20150401:1.8
	sid-snapshot-20150301:1.8
	cgen-snapshot-20150301:1.8
	sid-snapshot-20150201:1.8
	cgen-snapshot-20150201:1.8
	sid-snapshot-20150101:1.8
	cgen-snapshot-20150101:1.8
	sid-snapshot-20141201:1.8
	cgen-snapshot-20141201:1.8
	sid-snapshot-20141101:1.8
	cgen-snapshot-20141101:1.8
	sid-snapshot-20141001:1.8
	cgen-snapshot-20141001:1.8
	sid-snapshot-20140901:1.8
	cgen-snapshot-20140901:1.8
	sid-snapshot-20140801:1.8
	cgen-snapshot-20140801:1.8
	sid-snapshot-20140701:1.8
	cgen-snapshot-20140701:1.8
	sid-snapshot-20140601:1.8
	cgen-snapshot-20140601:1.8
	sid-snapshot-20140501:1.8
	cgen-snapshot-20140501:1.8
	sid-snapshot-20140401:1.8
	cgen-snapshot-20140401:1.8
	sid-snapshot-20140301:1.8
	cgen-snapshot-20140301:1.8
	sid-snapshot-20140201:1.8
	cgen-snapshot-20140201:1.8
	sid-snapshot-20140101:1.8
	cgen-snapshot-20140101:1.8
	sid-snapshot-20131201:1.8
	cgen-snapshot-20131201:1.8
	sid-snapshot-20131101:1.8
	cgen-snapshot-20131101:1.8
	sid-snapshot-20131001:1.8
	cgen-snapshot-20131001:1.8
	sid-snapshot-20130901:1.8
	cgen-snapshot-20130901:1.8
	sid-snapshot-20130801:1.8
	cgen-snapshot-20130801:1.8
	sid-snapshot-20130701:1.8
	cgen-snapshot-20130701:1.8
	sid-snapshot-20130601:1.8
	cgen-snapshot-20130601:1.8
	sid-snapshot-20130501:1.8
	cgen-snapshot-20130501:1.8
	sid-snapshot-20130401:1.8
	cgen-snapshot-20130401:1.8
	sid-snapshot-20130301:1.8
	cgen-snapshot-20130301:1.8
	sid-snapshot-20130201:1.8
	cgen-snapshot-20130201:1.8
	sid-snapshot-20130101:1.8
	cgen-snapshot-20130101:1.8
	sid-snapshot-20121201:1.8
	cgen-snapshot-20121201:1.8
	sid-snapshot-20121101:1.8
	cgen-snapshot-20121101:1.8
	sid-snapshot-20121001:1.8
	cgen-snapshot-20121001:1.8
	sid-snapshot-20120901:1.8
	cgen-snapshot-20120901:1.8
	sid-snapshot-20120801:1.8
	cgen-snapshot-20120801:1.8
	sid-snapshot-20120701:1.8
	cgen-snapshot-20120701:1.8
	sid-snapshot-20120601:1.8
	cgen-snapshot-20120601:1.8
	sid-snapshot-20120501:1.8
	cgen-snapshot-20120501:1.8
	sid-snapshot-20120401:1.8
	cgen-snapshot-20120401:1.8
	sid-snapshot-20120301:1.8
	cgen-snapshot-20120301:1.8
	sid-snapshot-20120201:1.8
	cgen-snapshot-20120201:1.8
	sid-snapshot-20120101:1.8
	cgen-snapshot-20120101:1.8
	sid-snapshot-20111201:1.8
	cgen-snapshot-20111201:1.8
	sid-snapshot-20111101:1.8
	cgen-snapshot-20111101:1.8
	sid-snapshot-20111001:1.8
	cgen-snapshot-20111001:1.8
	sid-snapshot-20110901:1.8
	cgen-snapshot-20110901:1.8
	sid-snapshot-20110801:1.8
	cgen-snapshot-20110801:1.8
	sid-snapshot-20110701:1.8
	cgen-snapshot-20110701:1.8
	sid-snapshot-20110601:1.8
	cgen-snapshot-20110601:1.8
	sid-snapshot-20110501:1.8
	cgen-snapshot-20110501:1.8
	sid-snapshot-20110401:1.8
	cgen-snapshot-20110401:1.8
	sid-snapshot-20110301:1.8
	cgen-snapshot-20110301:1.8
	sid-snapshot-20110201:1.8
	cgen-snapshot-20110201:1.8
	sid-snapshot-20110101:1.8
	cgen-snapshot-20110101:1.8
	sid-snapshot-20101201:1.8
	cgen-snapshot-20101201:1.8
	sid-snapshot-20101101:1.8
	cgen-snapshot-20101101:1.8
	sid-snapshot-20101001:1.8
	cgen-snapshot-20101001:1.8
	sid-snapshot-20100901:1.8
	cgen-snapshot-20100901:1.8
	sid-snapshot-20100801:1.8
	cgen-snapshot-20100801:1.8
	sid-snapshot-20100701:1.8
	cgen-snapshot-20100701:1.8
	sid-snapshot-20100601:1.8
	cgen-snapshot-20100601:1.8
	sid-snapshot-20100501:1.8
	cgen-snapshot-20100501:1.8
	sid-snapshot-20100401:1.8
	cgen-snapshot-20100401:1.8
	sid-snapshot-20100301:1.8
	cgen-snapshot-20100301:1.8
	sid-snapshot-20100201:1.8
	cgen-snapshot-20100201:1.8
	sid-snapshot-20100101:1.8
	cgen-snapshot-20100101:1.8
	sid-snapshot-20091201:1.8
	cgen-snapshot-20091201:1.8
	sid-snapshot-20091101:1.8
	cgen-snapshot-20091101:1.8
	sid-snapshot-20091001:1.8
	cgen-snapshot-20091001:1.8
	arc-sim-20090309:1.4
	sid-snapshot-20090901:1.7
	cgen-snapshot-20090901:1.7
	sid-snapshot-20090801:1.6
	cgen-snapshot-20090801:1.6
	sid-snapshot-20090701:1.5
	cgen-snapshot-20090701:1.5
	dje-cgen-play1-branch:1.5.0.2
	dje-cgen-play1-branchpoint:1.5
	cgen-1_1-branch:1.4.0.6
	cgen-1_1-branchpoint:1.4
	sid-snapshot-20090601:1.4
	cgen-snapshot-20090601:1.4
	sid-snapshot-20090501:1.4
	cgen-snapshot-20090501:1.4
	sid-snapshot-20090401:1.4
	cgen-snapshot-20090401:1.4
	arc-insight_6_8-branch:1.4.0.4
	arc-insight_6_8-branchpoint:1.4
	sid-snapshot-20090301:1.4
	cgen-snapshot-20090301:1.4
	sid-snapshot-20090201:1.4
	cgen-snapshot-20090201:1.4
	sid-snapshot-20090101:1.4
	cgen-snapshot-20090101:1.4
	sid-snapshot-20081201:1.4
	cgen-snapshot-20081201:1.4
	sid-snapshot-20081101:1.4
	cgen-snapshot-20081101:1.4
	sid-snapshot-20081001:1.4
	cgen-snapshot-20081001:1.4
	sid-snapshot-20080901:1.4
	cgen-snapshot-20080901:1.4
	sid-snapshot-20080801:1.4
	cgen-snapshot-20080801:1.4
	sid-snapshot-20080701:1.4
	cgen-snapshot-20080701:1.4
	sid-snapshot-20080601:1.4
	cgen-snapshot-20080601:1.4
	sid-snapshot-20080501:1.4
	cgen-snapshot-20080501:1.4
	sid-snapshot-20080403:1.4
	sid-snapshot-20080401:1.4
	cgen-snapshot-20080401:1.4
	sid-snapshot-20080301:1.4
	cgen-snapshot-20080301:1.4
	sid-snapshot-20080201:1.4
	cgen-snapshot-20080201:1.4
	sid-snapshot-20080101:1.4
	cgen-snapshot-20080101:1.4
	sid-snapshot-20071201:1.4
	cgen-snapshot-20071201:1.4
	sid-snapshot-20071101:1.4
	cgen-snapshot-20071101:1.4
	sid-snapshot-20071001:1.4
	cgen-snapshot-20071001:1.4
	msnyder-fork-checkpoint-branch:1.4.0.2
	msnyder-fork-checkpoint-branchpoint:1.4
	sid-20020905-branchpoint:1.1.1.1
	sid-20020905-branch:1.1.1.1.0.6
	cagney_regbuf-20020515-branch:1.1.1.1.0.4
	cagney_regbuf-20020515-branchpoint:1.1.1.1
	cygnus_cvs_20020108_pre:1.1.1.1
	cgen-1-1-branch:1.1.1.1.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.8
date	2009.09.08.06.51.44;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2009.08.12.22.33.37;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	2009.07.22.18.30.59;	author devans;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	2002.12.21.22.19.22;	author devans;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	2002.12.20.06.39.04;	author devans;	state Exp;
branches;
next	1.2;

1.2
date	2002.10.07.23.50.30;	author hp;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.4.6.1
date	2009.06.24.14.57.46;	author devans;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.8
log
@	* types.scm (<struct>): Delete.

	* pmacros.scm (/pmacro-env-make): New argument `loc', all callers
	updated.
	(/pmacro-loc-error): New function.

	* mach.scm (/isa-parse-decode-assist): New function.
	(/isa-parse): Call it.

	* decode.scm (/get-subopcode-value): New function.
	(/opcode-slots): Call it.
	(/fill-slot!): Add logging message.
@
text
@; Type system.
; This provides the low level classes for describing data, except for
; the actual type (confusingly enough) which is described in mode.scm.
; Copyright (C) 2000, 2009 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.

; Array type.
; DIMENSIONS has a suitable initial value so (new <scalar>) to works.

(define <array> (class-make '<array> nil '(mode (dimensions . ())) nil))

; Return number of elements in array.

(method-make!
 <array> 'get-num-elms
 (lambda (self)
   (apply * (elm-get self 'dimensions)))
)

; Return mode of the array.

(method-make! <array> 'get-mode (lambda (self) (elm-get self 'mode)))

; Return the rank of the array (number of dimensions).

(method-make! <array> 'get-rank (lambda (self) (length (elm-get self 'dimensions)))
)

; Return shape of array

(method-make! <array> 'get-shape (lambda (self) (elm-get self 'dimensions))
)

; Return #t if X is an array.

(define (array? x) (class-instance? <array> x))

; Scalar type.

(define <scalar> (class-make '<scalar> '(<array>) nil nil))

(method-make-make! <scalar> '(mode))

; Return #t if X is a scalar.

(define (scalar? x) (and (array? x) (= (send x 'get-rank) 0)))

; Return number of bits in an element of TYPE.

(define (type-bits type)
  (mode:bits (send type 'get-mode))
)

; Integers.
; These are like scalars but are specified in bits.
; BITS is the size in bits.
; ATTRS contains !UNSIGNED [or nothing] or UNSIGNED.
;
; A mode is needed so we know how big a field is needed to record the value.
; It might be more appropriate to use a host mode though.
;
; FIXME: Need to separate rank from type.  scalar/array are not types.
;
;(define <integer> (class-make '<integer> nil '(attrs bits) nil))
;
;(method-make! <integer> 'get-atlist (lambda (self) (elm-get self 'attrs)))
;
;(method-make!
; <integer> 'get-mode 
; (lambda (self)
;   (mode-find (elm-get self 'bits)
;	      (if (has-attr? self 'UNSIGNED) 'UINT 'INT))
;   )
;)
;
; FIXME: Quick hack.  Revisit.
;
;(method-make! <integer> 'get-rank (lambda (self) 0))

; Parse a type spec.
; TYPE-SPEC is: (mode [(dimensions ...)])
;           or: ((mode bits) [(dimensions ...)])

(define (parse-type context type-spec)
  ; Preliminary error checking.
  (let ((expected
	 ", expected (mode [(dimensions)]) or ((mode bits) [(dimensions)])"))
    (if (not (list? type-spec))
	(parse-error context (string-append "invalid type spec" expected)
		     type-spec))
    (let ((len (length type-spec)))
      (if (or (< len 1)
	      (> len 2))
	  (parse-error context (string-append "invalid type spec" expected)
		       type-spec))
      ; Validate the mode spec.
      (cond ((symbol? (car type-spec))
	     #t) ; ok
	    ((list? (car type-spec))
	     (begin
	       (if (not (= (length (car type-spec)) 2))
		   (parse-error context
				(string-append "invalid mode in type spec"
					       expected)
				type-spec))
	       (if (not (symbol? (caar type-spec)))
		   (parse-error context
				(string-append "invalid mode in type spec"
					       expected)
				type-spec))
	       (if (not (integer? (cadar type-spec)))
		   (parse-error context
				(string-append "invalid #bits in type spec"
					       expected)
				type-spec))
	       ))
	     (else
	      (parse-error context
			   (string-append "invalid mode in type spec" expected)
			   type-spec)))
      ; Validate the dimension list if present.
      (if (= len 2)
	  (if (or (not (list? (cadr type-spec)))
		  (not (all-true? (map non-negative-integer?
				       (cadr type-spec)))))
	      (parse-error context
			   (string-append "invalid dimension spec in type spec"
					  expected)
			   type-spec)))
      ))

  ; Pick out the arguments.
  (let ((mode (if (list? (car type-spec)) (caar type-spec) (car type-spec)))
	(bits (if (list? (car type-spec)) (cadar type-spec) #f))
	(dims (if (> (length type-spec) 1) (cadr type-spec) nil)))

    ; Look up the mode and create the mode object.
    (let* ((base-mode (parse-mode-name context mode))
	   (mode-obj
	    (cond ((eq? mode 'INT)
		   (mode-make-int bits))
		  ((eq? mode 'UINT)
		   (mode-make-uint bits))
		  (else
		   (if (and bits (!= bits (mode:bits base-mode)))
		       (parse-error context "wrong number of bits for mode"
				    bits))
		   base-mode))))

      ; All done, create the <array> object.
      ; ??? Special casing scalars is a concession for apps that think
      ; scalars aren't arrays.  Not sure it should stay.
      (if (null? dims)
	  (make <scalar> mode-obj)
	  (make <array> mode-obj dims))))
)

; Bit ranges.
; ??? Perhaps this should live in a different source file, but for now
; it's here.
;
; Endianness is not recorded with the bitrange.
; Values are operated on a "word" at a time.
; This is to handle bi-endian systems: we don't want two copies of
; every bitrange.
;
; Instruction word sizes are based on the "base insn length" which is the
; number of bytes the cpu first looks at to decode an insn.  In cases where
; the total length is longer than the base insn length, the word length
; for the rest of the insn is the base insn length replicated as many times
; as necessary.  The trailing part [last few bytes] of the insn may not fill
; the entire word, in which case the numbering is adjusted for it.
; ??? Might need to have an insn-base-length and an insn-word-length.
;
; Instructions that have words of one endianness and sub-words of a different
; endianness are handled at a higher level.
;
; Bit numbering examples:
; [each byte is represented MSB to LSB, low address to high address]
;
; lsb0? = #f
; insn-word-length = 2
; endian = little
; | 8 ... 15 | 0 ... 7 | 24 ... 31 | 16 ... 23 | 40 ... 47 | 32 ... 39 |
;
; lsb0? = #t
; insn-word-length = 2
; endian = little
; [note that this is the little endian canonical form (*)
;  - word length is irrelevant]
; | 7 ... 0 | 15 ... 8 | 23 ... 16 | 31 ... 24 | 39 ... 32 | 47 ... 40 |
;
; lsb0? = #f
; insn-word-length = 2
; endian = big
; [note that this is the big endian canonical form (*)
;  - word length is irrelevant]
; | 0 ... 7 | 8 ... 15 | 16 ... 23 | 24 ... 31 | 32 ... 39 | 40 ... 47 |
;
; lsb0? = #t
; insn-word-length = 2
; endian = big
; | 15 ... 8 | 7 ... 0 | 31 ... 24 | 23 ... 16 | 47 ... 40 | 39 ... 32 |
;
; (*) NOTE: This canonical form should not be confused with what might be
; called the canonical form when writing .cpu ifield descriptions: lsb0? = #f.
; The ifield canonical form is lsb0? = #f because the starting bit number of
; ifields is defined to be the MSB.
; ---
; At the bitrange level, insns with different sized words is supported.
; This is because each <bitrange> contains the specs of the word it resides in.
; For example a 48 bit insn with a 16 bit opcode and a 32 bit immediate value
; might [but not necessarily] consist of one 16 bit "word" and one 32 bit
; "word".
;
; Examples:
;
; lsb0? = #f
; insn-word-length = 2, 4
; endian = little
; | 8 ... 15 | 0 ... 7 | 40 ... 47 | 32 ... 39 | 24 ... 31 | 16 ... 23 |
;
; lsb0? = #t
; insn-word-length = 2, 4
; endian = little
; | 7 ... 0 | 15 ... 8 | 23 ... 16 | 31 ... 24 | 39 ... 32 | 47 ... 40 |
;
; lsb0? = #f
; insn-word-length = 2, 4
; endian = big
; | 0 ... 7 | 8 ... 15 | 16 ... 23 | 24 ... 31 | 32 ... 39 | 40 ... 47 |
;
; lsb0? = #t
; insn-word-length = 2, 4
; endian = big
; | 15 ... 8 | 7 ... 0 | 47 ... 40 | 39 ... 32 | 31 ... 24 | 23 ... 16 |

(define <bitrange>
  (class-make '<bitrange>
	      nil
	      '(
		; offset in bits from the start of the insn of the word
		; in which the value resides [must be divisible by 8]
		; [this allows the bitrange to be independent of the lengths
		; of words preceding this one]
		word-offset
		; starting bit number within the word,
		; this is the MSB of the bitrange within the word
		; [externally, = word-offset + start]
		start
		; number of bits in the value
		length
		; length of word in which the value resides
		word-length
		; lsb = bit number 0?
		lsb0?
		)
	      nil)
)

; Accessor fns.

(define-getters <bitrange> bitrange
  (word-offset start length word-length lsb0?)
)

(define-setters <bitrange> bitrange
  ; lsb0? left out on purpose: not sure changing it should be allowed
  (word-offset start length word-length)
)

; Return a boolean indicating if two bitranges overlap.
;
; lsb0? = #t: 31 ...  0
; lsb0? = #f: 0  ... 31

(define (bitrange-overlap? start1 length1 start2 length2 lsb0?)
  (if lsb0?
      (let ((end1 (- start1 length1))
	    (end2 (- start2 length2)))
	(and (< end1 start2)
	     (> start1 end2)))
      (let ((end1 (+ start1 length1))
	    (end2 (+ start2 length2)))
	(and (> end1 start2)
	     (< start1 end2))))
)

; Return a boolean indicating if BITPOS is beyond bitrange START,LEN.
; ??? This needs more thought.

(define (bitpos-beyond? bitpos start length word-length lsb0?)
  (>= bitpos (+ start length))
)

; Return the offset of the word after <bitrange> br.

(define (bitrange-next-word br)
  (let ((word-offset (bitrange-word-offset br))
	(start (bitrange-start br))
	(length (bitrange-length br))
	(word-length (bitrange-word-length br))
	(lsb0? (bitrange-lsb0? br)))
    ; ??? revisit
    (+ word-offset word-length))
)

; Initialize/finalize support.

(define (types-init!)
  *UNSPECIFIED*
)

(define (types-finish!)
  *UNSPECIFIED*
)
@


1.7
log
@	Clean up cpu file parsing, pass context consistently instead of the
	old "errtxt" argument.
	NOTE: ACU == "All Callers Updated".
	* attr.scm (-parse-simple-attribute): Renamed from
	parse-simple-attribute, ACU.
	(-attr-parse): Change errtxt argument to context, ACU.
	(-attr-read): Ditto.
	(atlist-parse): Ditto.  Put context arg first.
	(attr-parse): Use parse-error instead of context-error.
	* enum.scm (parse-enum-vals): Change errtxt argument to context, ACU.
	(-enum-parse-prefix, -enum-parse, -enum-read): Ditto.
	* hardware.scm (-keyword-parse): Renamed from keyword-parse.
	`context' arg is now a <context> object.  ACU.
	(-keyword-read): `context' arg is now a <context> object.  ACU.
	(-hw-parse-indices): Change errtxt argument to context, ACU.
	(-hw-parse-values, -hw-parse-handlers): Ditto.
	(-hw-parse-getter, -hw-parse-setter, -hw-parse, -hw-read): Ditto.
	(-hw-validate-layout, -hw-create-getter-from-layout,
	-hw-create-setter-from-layout): Ditto.
	(<hw-register>:parse!, <hw-pc>:parse!): Ditto.
	(<hw-memory>:parse!, <hw-immediate>:parse!): Ditto.
	(<hw-address>:parse!): Ditto.
	* ifield.scm (-ifield-parse, ifield-read): Ditto.
	(-ifld-parse-follows, -ifld-parse-encode-decode): Ditto.
	(-ifld-parse-encode, -ifld-parse-decode): Ditto.
	(-multi-ifield-parse, -multi-ifield-read): Ditto.
	* insn.scm (-insn-parse, -insn-read): Ditto.
	(parse-syntax): Ditto.  Put context arg first.
	(-parse-insn-format-symbol): Change errtxt argument to context, ACU.
	(-parse-insn-format-ifield-spec, -parse-insn-format-list): Ditto.
	(-parse-insn-format): Ditto.
	* mach.scm (-arch-parse-alignment, -arch-parse-machs): Ditto.
	(-arch-parse-isas): Ditto.
	(-isa-read): Add context arg, ACU.
	(-cpu-parse, -cpu-read, -mach-read): Ditto.
	* minsn.scm (-minsn-parse-expansion): Change errtxt argument to
	context, ACU.
	(-minsn-parse, -minsn-read, -minsn-compute-iflds): Ditto.
	(minsn-make-alias): Ditto.
	* mode.scm (-mode-parse): Ditto.
	(parse-mode-name): Ditto.  Put context arg first.
	* model.scm (-prefetch-parse, -retire-parse, -pipeline-parse): Change
	errtxt argument to context, ACU.
	(-unit-parse, -model-parse, -model-read): Ditto.
	* operand.scm (-operand-parse-getter): Use parse-error instead of
	context-error.
	(-operand-parse-setter): Ditto.
	(-operand-parse): Change errtxt argument to context, ACU.
	(-operand-read, -derived-operand-parse, -derived-operand-read): Ditto.
	(-anyof-operand-parse, -anyof-operand-read): Ditto.
	* read.scm (reader-error): Delete.  Use parse-error instead.
	(parse-error): Change errtxt argument to context, ACU.  Split args
	argument into expr and maybe-help-text.
	(-reader-process-expanded-1!): Reorganize.
	* rtl.scm (-subr-read): Change errtxt argument to context, ACU.
	* types.scm (parse-type): Ditto.
	* utils-cgen.scm (single-location->simple-string): New function.
	(<context>): Replace members file,lineno with location.
	(make-prefix-context): Renamed from context-make-prefix, ACU.
	(make-current-context): New function.
	(context-append, context-append-name): New functions.
	(context-make-reader): Delete.
	(parse-name): Change errtxt argument to context, ACU.
	Put context arg first.
	(parse-comment): Ditto.
	(parse-number): Change errtxt argument to context, ACU.
	(arg-list-validate-name, arg-list-check-no-args,
	arg-list-symbol-arg): Ditto.

	* read.scm (-cmd-if): Don't assume test is a list.

	* html.scm (get-insn-properties): Delete errtxt, unused.
@
text
@a80 5
; Structures.
; FIXME: Unfinished.

(define <struct> (class-make '<struct> nil '(members) nil))

@


1.6
log
@	* modes.scm (TI,OI): New modes.
	* types.scm (parse-type): Improve error checking.  Don't hardwire
	mode names here.
	* utils.scm (non-negative-integer?): New function.
@
text
@d90 1
a90 1
(define (parse-type errtxt type-spec)
d95 1
a95 1
	(parse-error errtxt (string-append "invalid type spec" expected)
d100 1
a100 1
	  (parse-error errtxt (string-append "invalid type spec" expected)
d108 1
a108 1
		   (parse-error errtxt
d113 1
a113 1
		   (parse-error errtxt
d118 1
a118 1
		   (parse-error errtxt
d124 1
a124 1
	      (parse-error errtxt
d132 1
a132 1
	      (parse-error errtxt
d144 1
a144 1
    (let* ((base-mode (parse-mode-name mode errtxt))
d152 1
a152 1
		       (parse-error errtxt "wrong number of bits for mode"
@


1.5
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d92 45
a136 3
  (if (and (list? (car type-spec))
	   (not (= (length (car type-spec)) 2)))
      (parse-error errtxt "invalid type spec" type-spec))
d143 12
a154 23
    ; FIXME: Need more error checking here.
    ; Validate the mode and bits.
    (let ((mode-obj
	   (case mode
	     ((INT)
	      (if (integer? bits)
		  (mode-make-int bits)
		  (parse-error errtxt "invalid number of bits" bits)))
	     ((UINT)
	      (if (integer? bits)
		  (mode-make-uint bits)
		  (parse-error errtxt "invalid number of bits" bits)))
	     ((BI QI HI SI DI WI UQI UHI USI UDI UWI SF DF XF TF)
	      (let ((x (parse-mode-name mode errtxt)))
		(if (and bits (not (= bits (mode:bits x))))
		    (parse-error errtxt "wrong number of bits for mode" bits))
		x))
	     (else (parse-error errtxt "unknown/unsupported mode" mode)))))

      ; Validate the dimension spec.
      (if (or (not (list? dims))
	      (not (all-true? (map integer? dims))))
	  (parse-error errtxt "invalid dimension spec" dims))
@


1.4
log
@comment tweaks
@
text
@d4 1
a4 1
; Copyright (C) 2000 Red Hat, Inc.
@


1.4.6.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d4 1
a4 1
; Copyright (C) 2000, 2009 Red Hat, Inc.
@


1.3
log
@	* mode.scm (mode-sem-mode): New fn.
	* operand.scm (op:new-mode): Update. mode-name.
	(op-natural-mode?) New fn.
	* rtl.scm (hw): Set hw-name,mode-name.
plus some comment tweaks
@
text
@d164 1
a164 1
; [note that this is the little endian canonical form
d171 1
a171 1
; [note that this is the big endian canonical form
d180 10
a189 5
; While there are no current examples, the intent is to not preclude
; situations where each "word" in an insn isn't the same size.  For example a
; 48 bit insn with a 16 bit opcode and a 32 bit immediate value might [but not
; necessarily] consist of one 16 bit "word" and one 32 bit "word".
; Bitranges support this situation, however none of the rest of the code does.
d222 2
a223 1
		; starting bit number within the word
@


1.2
log
@	* types.scm (bitrange-overlap?): Handle lsb0?.
@
text
@d242 3
@


1.1
log
@Initial revision
@
text
@d244 9
a252 5
  ; ??? lsb0?
  (let ((end1 (+ start1 length1))
	(end2 (+ start2 length2)))
    (not (or (<= end1 start2)
	     (>= start1 end2))))
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
