head	1.22;
access;
symbols
	sid-snapshot-20180601:1.22
	cgen-snapshot-20180601:1.22
	sid-snapshot-20180501:1.22
	cgen-snapshot-20180501:1.22
	sid-snapshot-20180401:1.22
	cgen-snapshot-20180401:1.22
	sid-snapshot-20180301:1.22
	cgen-snapshot-20180301:1.22
	sid-snapshot-20180201:1.22
	cgen-snapshot-20180201:1.22
	sid-snapshot-20180101:1.22
	cgen-snapshot-20180101:1.22
	sid-snapshot-20171201:1.22
	cgen-snapshot-20171201:1.22
	sid-snapshot-20171101:1.22
	cgen-snapshot-20171101:1.22
	sid-snapshot-20171001:1.22
	cgen-snapshot-20171001:1.22
	sid-snapshot-20170901:1.22
	cgen-snapshot-20170901:1.22
	sid-snapshot-20170801:1.22
	cgen-snapshot-20170801:1.22
	sid-snapshot-20170701:1.22
	cgen-snapshot-20170701:1.22
	sid-snapshot-20170601:1.22
	cgen-snapshot-20170601:1.22
	sid-snapshot-20170501:1.22
	cgen-snapshot-20170501:1.22
	sid-snapshot-20170401:1.22
	cgen-snapshot-20170401:1.22
	sid-snapshot-20170301:1.22
	cgen-snapshot-20170301:1.22
	sid-snapshot-20170201:1.22
	cgen-snapshot-20170201:1.22
	sid-snapshot-20170101:1.22
	cgen-snapshot-20170101:1.22
	sid-snapshot-20161201:1.22
	cgen-snapshot-20161201:1.22
	sid-snapshot-20161101:1.22
	cgen-snapshot-20161101:1.22
	sid-snapshot-20160901:1.22
	cgen-snapshot-20160901:1.22
	sid-snapshot-20160801:1.22
	cgen-snapshot-20160801:1.22
	sid-snapshot-20160701:1.22
	cgen-snapshot-20160701:1.22
	sid-snapshot-20160601:1.22
	cgen-snapshot-20160601:1.22
	sid-snapshot-20160501:1.22
	cgen-snapshot-20160501:1.22
	sid-snapshot-20160401:1.22
	cgen-snapshot-20160401:1.22
	sid-snapshot-20160301:1.22
	cgen-snapshot-20160301:1.22
	sid-snapshot-20160201:1.22
	cgen-snapshot-20160201:1.22
	sid-snapshot-20160101:1.22
	cgen-snapshot-20160101:1.22
	sid-snapshot-20151201:1.22
	cgen-snapshot-20151201:1.22
	sid-snapshot-20151101:1.22
	cgen-snapshot-20151101:1.22
	sid-snapshot-20151001:1.22
	cgen-snapshot-20151001:1.22
	sid-snapshot-20150901:1.22
	cgen-snapshot-20150901:1.22
	sid-snapshot-20150801:1.22
	cgen-snapshot-20150801:1.22
	sid-snapshot-20150701:1.22
	cgen-snapshot-20150701:1.22
	sid-snapshot-20150601:1.22
	cgen-snapshot-20150601:1.22
	sid-snapshot-20150501:1.22
	cgen-snapshot-20150501:1.22
	sid-snapshot-20150401:1.22
	cgen-snapshot-20150401:1.22
	sid-snapshot-20150301:1.22
	cgen-snapshot-20150301:1.22
	sid-snapshot-20150201:1.22
	cgen-snapshot-20150201:1.22
	sid-snapshot-20150101:1.22
	cgen-snapshot-20150101:1.22
	sid-snapshot-20141201:1.22
	cgen-snapshot-20141201:1.22
	sid-snapshot-20141101:1.22
	cgen-snapshot-20141101:1.22
	sid-snapshot-20141001:1.22
	cgen-snapshot-20141001:1.22
	sid-snapshot-20140901:1.22
	cgen-snapshot-20140901:1.22
	sid-snapshot-20140801:1.22
	cgen-snapshot-20140801:1.22
	sid-snapshot-20140701:1.22
	cgen-snapshot-20140701:1.22
	sid-snapshot-20140601:1.22
	cgen-snapshot-20140601:1.22
	sid-snapshot-20140501:1.22
	cgen-snapshot-20140501:1.22
	sid-snapshot-20140401:1.22
	cgen-snapshot-20140401:1.22
	sid-snapshot-20140301:1.22
	cgen-snapshot-20140301:1.22
	sid-snapshot-20140201:1.22
	cgen-snapshot-20140201:1.22
	sid-snapshot-20140101:1.22
	cgen-snapshot-20140101:1.22
	sid-snapshot-20131201:1.22
	cgen-snapshot-20131201:1.22
	sid-snapshot-20131101:1.22
	cgen-snapshot-20131101:1.22
	sid-snapshot-20131001:1.22
	cgen-snapshot-20131001:1.22
	sid-snapshot-20130901:1.22
	cgen-snapshot-20130901:1.22
	sid-snapshot-20130801:1.22
	cgen-snapshot-20130801:1.22
	sid-snapshot-20130701:1.22
	cgen-snapshot-20130701:1.22
	sid-snapshot-20130601:1.22
	cgen-snapshot-20130601:1.22
	sid-snapshot-20130501:1.22
	cgen-snapshot-20130501:1.22
	sid-snapshot-20130401:1.22
	cgen-snapshot-20130401:1.22
	sid-snapshot-20130301:1.22
	cgen-snapshot-20130301:1.22
	sid-snapshot-20130201:1.22
	cgen-snapshot-20130201:1.22
	sid-snapshot-20130101:1.22
	cgen-snapshot-20130101:1.22
	sid-snapshot-20121201:1.22
	cgen-snapshot-20121201:1.22
	sid-snapshot-20121101:1.22
	cgen-snapshot-20121101:1.22
	sid-snapshot-20121001:1.22
	cgen-snapshot-20121001:1.22
	sid-snapshot-20120901:1.22
	cgen-snapshot-20120901:1.22
	sid-snapshot-20120801:1.22
	cgen-snapshot-20120801:1.22
	sid-snapshot-20120701:1.22
	cgen-snapshot-20120701:1.22
	sid-snapshot-20120601:1.22
	cgen-snapshot-20120601:1.22
	sid-snapshot-20120501:1.22
	cgen-snapshot-20120501:1.22
	sid-snapshot-20120401:1.22
	cgen-snapshot-20120401:1.22
	sid-snapshot-20120301:1.22
	cgen-snapshot-20120301:1.22
	sid-snapshot-20120201:1.22
	cgen-snapshot-20120201:1.22
	sid-snapshot-20120101:1.22
	cgen-snapshot-20120101:1.22
	sid-snapshot-20111201:1.22
	cgen-snapshot-20111201:1.22
	sid-snapshot-20111101:1.22
	cgen-snapshot-20111101:1.22
	sid-snapshot-20111001:1.22
	cgen-snapshot-20111001:1.22
	sid-snapshot-20110901:1.22
	cgen-snapshot-20110901:1.22
	sid-snapshot-20110801:1.22
	cgen-snapshot-20110801:1.22
	sid-snapshot-20110701:1.22
	cgen-snapshot-20110701:1.22
	sid-snapshot-20110601:1.22
	cgen-snapshot-20110601:1.22
	sid-snapshot-20110501:1.22
	cgen-snapshot-20110501:1.22
	sid-snapshot-20110401:1.22
	cgen-snapshot-20110401:1.22
	sid-snapshot-20110301:1.22
	cgen-snapshot-20110301:1.22
	sid-snapshot-20110201:1.22
	cgen-snapshot-20110201:1.22
	sid-snapshot-20110101:1.22
	cgen-snapshot-20110101:1.22
	sid-snapshot-20101201:1.22
	cgen-snapshot-20101201:1.22
	sid-snapshot-20101101:1.22
	cgen-snapshot-20101101:1.22
	sid-snapshot-20101001:1.22
	cgen-snapshot-20101001:1.22
	sid-snapshot-20100901:1.22
	cgen-snapshot-20100901:1.22
	sid-snapshot-20100801:1.22
	cgen-snapshot-20100801:1.22
	sid-snapshot-20100701:1.22
	cgen-snapshot-20100701:1.22
	sid-snapshot-20100601:1.22
	cgen-snapshot-20100601:1.22
	sid-snapshot-20100501:1.22
	cgen-snapshot-20100501:1.22
	sid-snapshot-20100401:1.22
	cgen-snapshot-20100401:1.22
	sid-snapshot-20100301:1.22
	cgen-snapshot-20100301:1.22
	sid-snapshot-20100201:1.22
	cgen-snapshot-20100201:1.22
	sid-snapshot-20100101:1.21
	cgen-snapshot-20100101:1.21
	sid-snapshot-20091201:1.21
	cgen-snapshot-20091201:1.21
	sid-snapshot-20091101:1.21
	cgen-snapshot-20091101:1.21
	sid-snapshot-20091001:1.21
	cgen-snapshot-20091001:1.21
	arc-sim-20090309:1.4
	sid-snapshot-20090901:1.20
	cgen-snapshot-20090901:1.20
	sid-snapshot-20090801:1.9
	cgen-snapshot-20090801:1.9
	sid-snapshot-20090701:1.5
	cgen-snapshot-20090701:1.5
	dje-cgen-play1-branch:1.5.0.4
	dje-cgen-play1-branchpoint:1.5
	cgen-1_1-branch:1.5.0.2
	cgen-1_1-branchpoint:1.5
	sid-snapshot-20090601:1.4
	cgen-snapshot-20090601:1.4
	sid-snapshot-20090501:1.4
	cgen-snapshot-20090501:1.4
	sid-snapshot-20090401:1.4
	cgen-snapshot-20090401:1.4
	arc-insight_6_8-branch:1.4.0.8
	arc-insight_6_8-branchpoint:1.4
	sid-snapshot-20090301:1.4
	cgen-snapshot-20090301:1.4
	sid-snapshot-20090201:1.4
	cgen-snapshot-20090201:1.4
	sid-snapshot-20090101:1.4
	cgen-snapshot-20090101:1.4
	sid-snapshot-20081201:1.4
	cgen-snapshot-20081201:1.4
	sid-snapshot-20081101:1.4
	cgen-snapshot-20081101:1.4
	sid-snapshot-20081001:1.4
	cgen-snapshot-20081001:1.4
	sid-snapshot-20080901:1.4
	cgen-snapshot-20080901:1.4
	sid-snapshot-20080801:1.4
	cgen-snapshot-20080801:1.4
	sid-snapshot-20080701:1.4
	cgen-snapshot-20080701:1.4
	sid-snapshot-20080601:1.4
	cgen-snapshot-20080601:1.4
	sid-snapshot-20080501:1.4
	cgen-snapshot-20080501:1.4
	sid-snapshot-20080403:1.4
	sid-snapshot-20080401:1.4
	cgen-snapshot-20080401:1.4
	sid-snapshot-20080301:1.4
	cgen-snapshot-20080301:1.4
	sid-snapshot-20080201:1.4
	cgen-snapshot-20080201:1.4
	sid-snapshot-20080101:1.4
	cgen-snapshot-20080101:1.4
	sid-snapshot-20071201:1.4
	cgen-snapshot-20071201:1.4
	sid-snapshot-20071101:1.4
	cgen-snapshot-20071101:1.4
	sid-snapshot-20071001:1.4
	cgen-snapshot-20071001:1.4
	msnyder-fork-checkpoint-branch:1.4.0.6
	msnyder-fork-checkpoint-branchpoint:1.4
	sid-20020905-branchpoint:1.4
	sid-20020905-branch:1.4.0.4
	cagney_regbuf-20020515-branch:1.4.0.2
	cagney_regbuf-20020515-branchpoint:1.4
	cygnus_cvs_20020108_pre:1.2
	cgen-1-1-branch:1.2.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.22
date	2010.01.20.06.31.25;	author devans;	state Exp;
branches;
next	1.21;

1.21
date	2009.09.01.16.31.27;	author devans;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.25.16.19.48;	author devans;	state Exp;
branches;
next	1.19;

1.19
date	2009.08.25.16.13.35;	author devans;	state Exp;
branches;
next	1.18;

1.18
date	2009.08.20.15.55.55;	author devans;	state Exp;
branches;
next	1.17;

1.17
date	2009.08.20.05.38.29;	author devans;	state Exp;
branches;
next	1.16;

1.16
date	2009.08.20.05.33.14;	author devans;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.18.01.40.57;	author devans;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.17.15.27.55;	author devans;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.13.19.36.52;	author devans;	state Exp;
branches;
next	1.12;

1.12
date	2009.08.13.19.10.01;	author devans;	state Exp;
branches;
next	1.11;

1.11
date	2009.08.13.17.57.51;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2009.08.13.16.23.17;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2009.07.22.17.32.27;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2009.07.20.00.57.03;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.19.16.57.53;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	2009.07.13.20.55.21;	author devans;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.14.18.32.27;	author devans;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2002.03.20.22.05.57;	author hp;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.28.19.52.32;	author hp;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.19.03.36.24;	author bje;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.5.4.1
date	2009.07.14.16.08.51;	author devans;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.22
log
@(.splice): Note that arguments are evaluated first.
@
text
@@@c Copyright (C) 2000, 2009 Red Hat, Inc.
@@c This file is part of the CGEN manual.
@@c For copying conditions, see the file cgen.texi.

@@node Preprocessor macros
@@chapter Preprocessor macros
@@cindex Preprocessor macros
@@cindex pmacros

Preprocessor macros provide a way of simplifying the writing of
@@file{.cpu} files.

@@menu
* Pmacros introduction::   Introduction to pmacros
* Defining pmacros::       @@code{define-pmacro}
* Using pmacros::          Using preprocessor macros
* Pmacro expansion::       How pmacros are expanded
* Syntactic forms::        Pmacros that defer argument expansion
* Default argument values::  Specifying default values of arguments
* Multiple result statements::  Using @@code{begin}
* Symbols and strings::    Symbols and strings
* Number utilities::       Manipulating numbers
* List utilities::         Manipulating lists
* Iteration utilities::    Iterating over lists
* Conditional macros::     Conditional execution
* Pmacro utilities::       Utilities for using macros
* Debugging utilities::    Pmacros to assist debugging
* Comparisons::            Comparing things
* Arithmetic functions::   Math
* Logical functions::      Shifts, bitwise logical functions
* Internal use pmacros::   For internal use only
@@end menu

@@node Pmacros introduction
@@section Pmacros introduction

The macro facility provided by CGEN is quite extensive.
This is to give @@file{.cpu} file writers the freedom to
write the file in ways that work for the architecture in question.
Not all architectures are best described in the same way.

The macros are called @@samp{pmacros} because the word @@samp{macro}
has become overloaded.  For clarity, we give them a unique name:
@@samp{pmacros}.

One important point to keep in mind regarding pmacros is that
when loading @@file{.cpu} files all pmacros are expanded and discarded,
their only purpose is to simplify writing the @@code{dni}s and other
elements of the architecture description.

Therefore, do not try to write RTL as pmacros.
You can of course use pmacros to assist in the writing of RTL,
but remember that the resulting RTL @@emph{cannot} use pmacros.
By the time the RTL is processed all pmacros have been expanded
and discarded.

A simple picture may help.
Here is a basic diagram of the steps in processing cpu descriptions.

@@example
         (1) .cpu file
                |
      (2) pmacro expansion
                |
(3) define-@@{insn,operand,etc.@@} processing
                |
   (4) instruction set analysis
                |
 (5) application source file generation
@@end example

Once CGEN gets to step (3) pmacros no longer exist.

@@node Defining pmacros
@@section Defining pmacros
@@cindex define-pmacro

There are two kinds of macros:

@@itemize @@bullet
@@item function macros
@@item variable macros
@@end itemize

Preprocessor function macros are defined with:

@@smallexample
(define-pmacro (name [parm1 parm2 ... parmN])
  ["optional comment"]
  expansion
)
@@end smallexample

@@samp{expansion} must be exactly one expression.

Preprocessor variable macros are just global variables, nothing special.
When invoked their value is used in place of their name.

Variable macros are defined with:

@@smallexample
(define-pmacro name
  ["optional comment"]
  expansion
)
@@end smallexample

@@node Using pmacros
@@section Using pmacros

Functional macros are invoked in either of two ways: positional arguments
or specifying arguments by name.

@@smallexample
(define-pmacro (foo arg1 arg2) (bar arg1 arg2))

;; Invoke by positional arguments.

(foo abc def) ==> (bar abc def)

;; Invoke by naming arguments.

(foo #:arg1 ghi #:arg2 jkl) ==> (bar ghi jkl)
@@end smallexample

Variable macros are invoked simply by specifying their name.

@@smallexample
(define-pmacro foo "abc")

(.str foo "def") ==> "abcdef"
@@end smallexample

@@node Pmacro expansion
@@section Pmacro expansion

Most@@footnote{Syntactic form pmacros don't pre-evaluate their arguments.
@@xref{Syntactic forms}.}
function pmacros are expanded by first processing any macros in the invocation,
binding the resulting expressions to the pmacro's parameters,
processing the pmacro according to its definition, and returning the result.
Free variables are left unchanged.@@footnote{A "free variable",
as defined here, is one that is not already bound, be it to
parameter, macro, or local variable within a macro.
Note that to pmacros, cpu description file elements like
@@code{reg}, @@code{sequence}, @@code{VOID}, etc. are just symbols;
they have no special meaning.}

Variable macros are expanded simply by replacing their name with their value.

After a pmacro has been expanded, if the result is a symbol that names
another pmacro, it is in turn processed.  This happens just once,
not repeatedly.@@footnote{This behaviour will go away eventually, do not
rely on it.}

Here is a simple example that uses pmacros to simplify the
definition of several instructions.

@@smallexample
;; OP1_*,OP2_* are previously defined enums
(define-pmacro arithmetic-insns
  ((add OP2_0) (sub OP2_1) (mul OP2_2) (div OP2_3))
)
(define-pmacro (make-arith-reg/reg-format opcode)
  (+ OP1_0 opcode dr sr)
)
(define-pmacro (make-arith-reg/imm-format opcode)
  (+ OP1_1 opcode dr sr)
)
(define-pmacro (define-arith-insn ispec)
  (begin
    (dni (.ref ispec 0)
         (.str (.ref ispec 0) " reg/reg")
         ()
         (.str (.ref ispec 0) " $dr,$sr")
         (make-arith-reg/reg-format (.ref ispec 1))
         (set dr ((.ref ispec 0) dr sr))
         ()
         )
    (dni (.ref ispec 0)
         (.str (.ref ispec 0) " reg/imm")
         ()
         (.str (.ref ispec 0) " $dr,$imm")
         (make-arith-reg/imm-format (.ref ispec 1))
         (set dr ((.ref ispec 0) dr imm))
         ()
         )
  )
)

;; Create dnis for each kind of instruction.
;; The result of this is:
;; (begin (begin (dni ...) ...) (begin (dni ...) ...) ...)
(.splice begin (.unsplice (.map define-arith-insn arithmetic-insns)))
@@end smallexample

The @@code{.splice}, @@code{.unsplice} are necessary to pass properly
formed expressions to the @@file{.cpu} file reader.
If we just used @@samp{(.map define-arith-insn arithmetic-insns)}
the reader would see @@samp{((begin (dni ...) ...) (begin (dni ...) ...))}.
Note how the first @@code{begin} is nested within a list, and does not
appear in the ``top level'' list.

Another way to accomplish the same thing that doesn't require
@@code{.splice}, @@code{.unsplice} is to use @@code{.for-each}, @@code{.exec}.
@@code{.for-each} is only used for its side-effects, it does not
return a result.  Therefore, in order to actually cause the
@@file{.cpu} file reader to see any definitions we need to use
@@code{.exec} to pass the dnis to the reader.

@@smallexample
(define-pmacro (define-arith-insn ispec)
  (.exec (dni (.ref ispec 0)
           (.str (.ref ispec 0) " reg/reg")
           ()
           (.str (.ref ispec 0) " $dr,$sr")
           (make-arith-reg/reg-format (.ref ispec 1))
           (set dr ((.ref ispec 0) dr sr))
           ()
           ))
  (.exec (dni (.ref ispec 0)
           (.str (.ref ispec 0) " reg/imm")
           ()
           (.str (.ref ispec 0) " $dr,$imm")
           (make-arith-reg/imm-format (.ref ispec 1))
           (set dr ((.ref ispec 0) dr imm))
           ()
           ))
)
(.for-each define-arith-insn arithmetic-insns)
@@end smallexample

@@node Syntactic forms
@@section Syntactic forms

Some function pmacros are called @@samp{syntactic forms}.
These pmacros are processed differently in that parameters are
@@emph{not} evaluated first.  Instead it is up to the pmacro
to decide when, and if, the parameters are evaluated.

The syntactic forms are:

@@itemize @@bullet

@@item @@code{.pmacro}.
@@xref{Defining a pmacro inline}.
@@item @@code{.let}, @@code{.let*}.
@@xref{Defining a block of locals}.
@@item @@code{.if}.
@@xref{Traditional @@code{if}}.
@@item @@code{.case}.
@@xref{Traditional @@code{case}}.
@@item @@code{.cond}.
@@xref{Extended if/elseif/else}.
@@item @@code{.begin}.
@@xref{A block of statements}.
@@item @@code{.andif}.
@@xref{.andif}.
@@item @@code{.orif}.
@@xref{.orif}.

@@end itemize

The docs for each syntactic pmacro describes when it evaluates its arguments.

All syntactic form pmacros are pre-defined.
The user can not currently define his/her own.

@@node Default argument values
@@section Default argument values

Invoking pmacros by specifying argument names allows some, or all,
arguments to be elided and thus allows for arguments to have default values.

Specify default values with the following syntax.

@@smallexample
(define-pmacro (macro-name (arg1 . default-value)
                           (arg2 . default value) ...)
  ...
)
@@end smallexample

To invoke a pmacro with default values for some, or all,
arguments, you @@emph{must} specify arguments by name.

Example:

@@smallexample
(define-pmacro (foo (arg1 . 1) (arg2 . 2))
  (bar arg1 arg2)
)

(foo #:arg1 4) ==> (bar 4 2)

(foo 4) ==> ERROR, must invoke pmacro by specifying arguments by name
@@end smallexample

@@node Multiple result statements
@@section Multiple result statements
@@cindex begin

The result of a preprocessor macro is exactly one expression.
It is often useful, however, to return multiple expressions, say for
example when you want one macro to define several instructions.

The way to do this is to enclose all the expressions with @@code{begin}.
@@code{begin} is only valid at the top [definition] level.

Note that this is @@emph{not} the @@code{.begin} builtin pmacro.
We want to pass a list of statements to the @@file{.cpu} file reader,
and pmacros have all been evaluated and discarded by this point.

@@node Symbols and strings
@@section Symbols and strings

There are several builtin macros for symbol and string manipulation.

@@menu
* Symbol concatenation::          The @@code{.sym} builtin
* String concatenation::          The @@code{.str} builtin
* Convert a number to a hex::     The @@code{.hex} builtin
* Convert a string to uppercase:: The @@code{.upcase} builtin
* Convert a string to lowercase:: The @@code{.downcase} builtin
* Getting part of a string::      The @@code{.substring} builtin
* Symbol or string length::       The @@code{.length} builtin
@@end menu

@@node Symbol concatenation
@@subsection Symbol concatenation
@@cindex .sym

Symbol and string concatenation are supported. Symbol concatenation is
done with:

@@code{(.sym arg1 arg2 ...)}

Acceptable arguments are symbols, strings, and numbers.
The result is a symbol with the arguments concatenated together.
Numbers are converted to a string, base 10, and then to a symbol.
The result must be a valid Scheme symbol with the additional restriction
that the first character must be a letter.  The resulting symbol
is recursively macro-expanded.

@@node String concatenation
@@subsection String concatenation
@@cindex .str

String concatenation is done with

@@code{(.str arg1 arg2 ...)}

Acceptable arguments are symbols, strings, and numbers.  The result is a
string with the arguments concatenated together.
Numbers are converted base 10.

Example:

@@smallexample
(define-pmacro (bin-op mnemonic op2-op sem-op)
  (dni mnemonic
       (.str mnemonic " reg/reg")
       ()
       (.str mnemonic " $dr,$sr")
       (+ OP1_0 op2-op dr sr)
       (set dr (sem-op dr sr))
       ())
)
(bin-op and OP2_12 and)
(bin-op or OP2_14 or)
(bin-op xor OP2_13 xor)
@@end smallexample

@@node Convert a number to a hex
@@subsection Convert a number to a hex
@@cindex .hex

Convert a number to a lowercase hex string with @@code{.hex}.  If
@@code{width} is present, the result is that many characters beginning
with the least significant digit.  Zeros are prepended as necessary.

Syntax: @@code{(.hex number [width])}

Examples:

@@smallexample
(.hex 42)   --> "2a"
(.hex 42 1) --> "a"
(.hex 42 4) --> "002a"
@@end smallexample

@@node Convert a string to uppercase
@@subsection Convert a string to uppercase
@@cindex .upcase

Convert a string to uppercase with @@code{.upcase}.

Syntax: @@code{(.upcase string)}

Example:

@@smallexample
(.upcase "foo!") --> "FOO!"
@@end smallexample

@@node Convert a string to lowercase
@@subsection Convert a string to lowercase
@@cindex .downcase

Convert a string to lowercase with @@code{.downcase}.

Syntax: @@code{(.downcase string)}

Example:

@@smallexample
(.downcase "BAR?") --> "bar?"
@@end smallexample

@@node Getting part of a string
@@subsection Getting part of a string
@@cindex .substring

Extract a part of a string with @@code{.substring}.

Syntax: @@samp{(.substring string start end)}

where @@samp{start} is the starting character, and @@samp{end} is one past
the ending character.  Character numbering begins at position 0.
If @@samp{start} and @@samp{end} are the same, and both valid, the empty
string is returned.

Example:

@@smallexample
(.substring "howzitgoineh?" 2 6) --> "wzit"
@@end smallexample

@@node Symbol or string length
@@subsection Symbol or string length
@@c @@cindex .length - the @@cindex for this is in the list section

Compute the length, in characters, of a symbol or string.

Syntax: @@samp{(.length symbol-or-string)}

Examples:

@@smallexample
(.length abc) --> 3
(.length "def") --> 3
(.length "") --> 0
@@end smallexample

@@node Number utilities
@@section Number utilities

Builtin macros for manipulating numbers.

@@menu
* Number generation::             The @@code{.iota} builtin
@@end menu

@@node Number generation
@@subsection Number generation
@@cindex .iota
@@cindex Number generation

Machine descriptions often require a list of sequential numbers.
Generate a list of numbers with the @@code{.iota} builtin macro.

Syntax: @@samp{(.iota count [start [incr]])}.

Examples:

@@smallexample
(.iota 5)      --> 0 1 2 3 4
(.iota 5 4)    --> 4 5 6 7 8
(.iota 5 5 -1) --> 5 4 3 2 1
@@end smallexample

@@node List utilities
@@section List utilities

Builtin macros for maninpulating lists.

@@menu
* Creating lists::                The @@code{.list} builtin
* List splicing::                 The @@code{.splice} builtin
* Referencing a list element::    The @@code{.ref} builtin
* List length::                   The @@code{.length} builtin
* Lists of repeated elements::    The @@code{.replicate} builtin
* Finding a subset of a list::    The @@code{.find} builtin
* car/cdr::                       car, cdr, etc. from Scheme/Lisp
@@end menu

@@node Creating lists
@@subsection Creating lists
@@cindex .list

Lists can be created with the @@code{.list} builtin.

Syntax: @@samp{(.list elm1 elm2 ...)}

It's somewhat redundant as lists can also be created simply writing
@@samp{(elm1 elm2 ...)}.

@@node List splicing
@@subsection List splicing
@@cindex .splice

Syntax: @@samp{(.splice [expr1] [expr2] [(.unsplice list1)]
              [(.unsplice list2)] [expr3] ...)}

It is often useful to splice a list into a "parent" list.
This is best explained with an example.

@@smallexample
(define-pmacro (splice-test a b c)
               (.splice a (.unsplice b) c))
(pmacro-dump (splice-test 1 (2) 3))

--> (1 2 3)
@@end smallexample

Note that a level of parentheses around @@code{2} has been removed.

This is useful, for example, when one wants to pass a list of fields to
a macro that defines an instruction.  For example:

@@smallexample
(define-pmacro (cond-move-1 name comment mnemonic cc-prefix cc-name cc-opcode
			    src-name src-opcode cond test)
  (dni name
       (.str "move %" cc-name " " comment ", v9 page 191")
       ((MACH64))
       (.str mnemonic " " cc-prefix cc-name ",$" src-name ",$rd")
       (.splice + OP_2 rd OP3_MOVCC cond
		(.unsplice cc-opcode) (.unsplice src-opcode))
       (if (test cc-name)
	   (set rd src-name))
       ())
)
@@end smallexample

This macro, taken from @@file{sparc64.cpu}, defines a conditional move
instruction. Arguments @@code{cc-opcode} and @@code{src-opcode} are lists
of fields. The macro is invoked with (simplified from @@file{sparc64.cpu}):

@@smallexample
(cond-move-1 mova-icc "blah ..." mova
             "%" icc ((f-fmt4-cc2 1) (f-fmt4-cc1-0 0))
             rs2 ((f-i 0) (f-fmt4-res10-6 0) rs2)
             CC_A test-always)
(cond-move-1 mova-imm-icc "blah ..." mova
             "%" icc ((f-fmt4-cc2 1) (f-fmt4-cc1-0 0))
             simm11 ((f-i 1) simm11)
             CC_A test-always)
@@end smallexample

Macro @@code{cond-move-1} is being used here to define both the register
and the immediate value case.  Each case has a slightly different list
of opcode fields.  Without the use of @@code{.splice}/@@code{.unsplice},
the resulting formats would be:

@@smallexample
(+ OP_2 rd OP3_MOVCC CC_A ((f-fmt4-cc2-1) (f-fmt4-cc1-0 0))
   ((f-i 0) (f-fmt4-res10-6 0) rs2))

and

(+ OP_2 rd OP3_MOVCC CC_A ((f-fmt4-cc2-1) (f-fmt4-cc1-0 0))
   ((f-i 1) simm11))
@@end smallexample

respectively.  This is not what is wanted.  What is wanted is

@@smallexample
(+ OP_2 rd OP3_MOVCC CC_A (f-fmt4-cc2-1) (f-fmt4-cc1-0 0)
   (f-i 0) (f-fmt4-res10-6 0) rs2)

and

(+ OP_2 rd OP3_MOVCC CC_A (f-fmt4-cc2-1) (f-fmt4-cc1-0 0)
   (f-i 1) simm11)
@@end smallexample

respectively, which is what @@code{.splice} achieves.

@@code{.unsplice} is a special reserved symbol that is only recognized inside
@@code{.splice}.  There can be any number of @@code{.unsplice} expressions
in a @@code{.splice} but they all must be at the ``top level''.

I.e. this is not supported:
@@samp{(.splice 1 (2 3 (.unsplice (4 5))))}.

Note that @@code{.splice} without any @@code{.unsplice} expressions
behaves identically to @@code{.list}.

Also note that the arguments to @@code{.splice} and @@code{.unsplice} are
evaluted first.  Any macro invocations are first expanded, and then
@@code{.unsplice} is processed.

@@node Referencing a list element
@@subsection Referencing a list element
@@cindex .ref

Reference elements of a list with @@code{.ref}.

Syntax: @@samp{(.ref list element-number)}

Example:

@@smallexample
(.ref (1 2 3) 1) --> 2
@@end smallexample

@@node List length
@@subsection List length
@@cindex .length

The length of a list is computed with @@code{.length}.

Syntax: @@samp{(.length list)}.

Example:

@@smallexample
(.length (1 2 3)) --> 3
@@end smallexample

@@node Lists of repeated elements
@@subsection Lists of repeated elements
@@cindex .replicate

Create a list of repeated elements with @@code{.replicate}.

Syntax: @@samp{(.replicate n expr)}

Example:

@@smallexample
(.replicate 4 5) --> (5 5 5 5)
@@end smallexample

@@node Finding a subset of a list
@@subsection Finding a subset of a list
@@cindex .find

Compute a subset of a list matching a specified predicate with @@code{.find}.

Syntax: @@samp{(.find predicate list)}

Example:

@@smallexample
(.find (.pmacro (n) (.lt n 2)) (.iota 4)) --> (0 1)
@@end smallexample

@@node car/cdr
@@subsection car/cdr
@@cindex .car
@@cindex .cdr
@@cindex .caar
@@cindex .cadr
@@cindex .cdar
@@cindex .cddr

CGEN provides a small set of pmacros for those familiar with
Scheme/Lisp lists.

@@itemize @@bullet
@@item car

Equivalent to @@samp{(.ref list 0)}.

Example:

@@smallexample
(.car (1 2 3)) --> 1
@@end smallexample

@@item cdr

Return all elements of the list after the first one.

Example:

@@smallexample
(.cdr (1 2 3)) --> (2 3)
@@end smallexample

@@item caar

Return the first element of the first element of the list.

I.e., the @@code{car} of the @@code{car} of the list.

Example:

@@smallexample
(.caar ((1 2 3) (4 5 6))) --> 1
@@end smallexample

@@item cadr

Return the second element of the list.

I.e., the @@code{car} of the @@code{cdr} of the list.

Example:

@@smallexample
(.cadr (1 2 3)) --> 2
@@end smallexample

@@item cdar

Return all elements after the first element of the first element of the list.
That's a bit of a mouthful, it's easier to understand by applying
@@code{car} and @@code{cdr} in turn.

I.e., the @@code{cdr} of the @@code{car} of the list.

Example:

@@smallexample
(.cadr ((1 2 3) (4 5 6))) --> (2 3)
@@end smallexample

@@item cddr

I.e., the @@code{cdr} of the @@code{cdr} of the list.

Return all elements of the list after the first two.

Example:

@@smallexample
(.cddr (1 2 3)) --> (3)
@@end smallexample

@@end itemize

@@node Iteration utilities
@@section Iteration utilities

Macros for iterating over lists

@@menu
* Mapping a macro over a list::   The @@code{.map} builtin
* Iterating over a list::         The @@code{.for-each} builtin
@@end menu

@@node Mapping a macro over a list
@@subsection Mapping a macro over a list
@@cindex .map

Apply a macro to each element of a list, or set of lists, with @@code{.map}.
The order in which each element of the list is processed is unspecified.

The syntax is @@samp{(.map macro-name list1 [list2 ...])}.
@@samp{macro} must take as many arguments as there are lists.

The result is a list with @@samp{macro} applied to each element of
@@samp{listN}.  This is often useful in constructing enum and register name lists.

Example:

@@smallexample
(define-pmacro (foo name number) ((.sym X name) number))
(.map foo (A B C D E) (.iota 5))

-->

((XA 0) (XB 1) (XC 2) (XD 3) (XE 4))
@@end smallexample

@@node Iterating over a list
@@subsection Iterating over a list
@@cindex .for-each

Apply a macro to each element of a list, or set of lists,
with @@code{.for-each}.
Each element of the list is guaranteed to be processed in order.

The syntax is @@samp{(.for-each macro list1 [list2 ...])}.
@@samp{macro} must take as many arguments as there are lists.

There is no result, or rather the result is always the empty list ().
Note that this macro is therefore useless for macro expansion.
It's purpose is to process @@code{macro} for its side-effects.
The @@code{.exec} builtin pmacro is useful here.

@@node Conditional macros
@@section Conditional macros

Macros for conditional execution.

@@menu
* Traditional @@code{if}::         The @@code{.if} builtin
* Traditional @@code{case}::       The @@code{.case} builtin
* Extended if/elseif/else::       The @@code{.cond} builtin
@@end menu

@@node Traditional @@code{if}
@@subsection Traditional @@code{if}
@@cindex .if

Syntax: @@samp{(.if condition then-expr [else-expr])}.

The @@code{condition} is evaluated, and if it is non-#f then
@@code{then-expr} is evaluated and returned.
Otherwise, if @@code{else-expr} is present it is evaluated and returned.
Otherwise, the empty list @@code{()} is returned.

@@node Traditional @@code{case}
@@subsection Traditional @@code{case}
@@cindex .case

Syntax: @@samp{(.case expr ((case1-list) expr-list) [case-list] [(else expr-list)])}

The expression @@code{expr} is evaluated, and then
each case list is examined in turn to look for a match.
The first case list with an element that matches @@code{expr} wins,
its @@code{expr-list} is evaluated and the result of the last expression
in the expression list is returned.

If there is no successful match and no @@code{else} part,
then the empty list @@code{()} is returned.

@@node Extended if/elseif/else
@@subsection Extended if/elseif/else
@@cindex .cond

Syntax: @@samp{(.cond (expr1 expr-list) [cond-list] [(else expr-list)])}

Each condition's expression is evaluated in turn.
The first condition to evaluate to non-#f wins,
its @@code{expr-list} is evaluated and the result of the last expression
in the expression list is returned.

If there is no successful condition and no @@code{else} part,
then the empty list @@code{()} is returned.

@@node Pmacro utilities
@@section Pmacro utilities

Pmacros for working with pmacros.

@@menu
* Re-evaluating an expression::      The @@code{.eval} builtin
* Immediate execution of a command:: The @@code{.exec} builtin
* Applying a pmacro to a list::      The @@code{.apply} builtin
* Defining a pmacro inline::         The @@code{.pmacro} builtin
* Passing pmacros as arguments::     Passing a pmacro to another pmacro
* Defining a block of locals::       The @@code{.let}, @@code{.let*} builtins
* A block of statements::            The @@code{.begin} builtin
* Testing if something is a pmacro:: The @@code{.pmacro?} builtin
@@end menu

@@node Re-evaluating an expression
@@subsection Re-evaluating an expression
@@cindex .eval

Syntax: @@samp{(.eval expr)}

Sometimes one wishes to build up an expression in non-trivial ways
and then have the expression evaluated.
Use the @@code{.eval} builtin pmacro for this purpose,
it re-evaluates @@samp{expr}, invoking any pmacros contained therein.

A perhaps contrived example is when one wants to construct the pmacro's
name from a set of parameters.

Example:

@@smallexample
(define-pmacro (do-foo a b) (foo a b))
(define-pmacro (do-bar a b) (bar a b))
(define-pmacro (doer what a b) (.eval (.list (.sym do- what) a b)))
(doer foo 1 2) ;; --> (foo 1 2)
(doer bar 3 4) ;; --> (bar 3 4)
@@end smallexample

@@node Immediate execution of a command
@@subsection Immediate execution of a command
@@cindex .exec

Syntax: @@samp{(.exec expr)}

Sometimes one wishes to pass an expression to the @@file{.cpu} file reader
immediately, rather than waiting for it to process the expression
that is the result of a pmacro.  This typically happens with the
@@code{.for-each} builtin pmacro.
Use the @@code{.exec} builtin pmacro for this purpose.
It immediately passes @@samp{expr} to the @@file{.cpu} file reader
for processing and returns @@code{()} as a result.

@@node Applying a pmacro to a list
@@subsection Applying a pmacro to a list
@@cindex .apply

Invoke a macro with each argument coming from an element of a list,
with @@code{.apply}.

The syntax is @@samp{(.apply macro-name list)}.

The result is the result of invoking macro @@samp{macro-name}.
@@samp{macro-name} should take as many arguments as there elements in
@@samp{list}.  If @@samp{macro-name} takes a variable number of trailing
arguments, there must be at least as many list elements as there are
fixed arguments.
@@c clumsily worded or what

Example:
@@c need a more useful example

Example:

@@smallexample
(.apply .str (.iota 5)) --> "01234"
@@end smallexample

Note that @@code{(.str (.iota 5))} is an error.  Here the list
@@samp{(0 1 2 3 4)} is passed as the first argument of @@code{.str},
which is wrong.

@@node Defining a pmacro inline
@@subsection Defining a pmacro inline
@@cindex .pmacro

Define a macro inline with @@code{.pmacro}.
This is only supported when passing macros as arguments to other macros,
and as values for local variables in @@code{.let} or @@code{.let*}.

Example:

@@smallexample
(define-pmacro (load-op suffix op2-op mode ext-op)
  (begin
    (dni (.sym ld suffix) (.str "ld" suffix)
	 ()
	 (.str "ld" suffix " $dr,@@@@$sr")
	 (+ OP1_2 op2-op dr sr)
	 (set dr (ext-op WI (mem mode sr)))
	 ())
  )
)

(load-op "" OP2_12 WI (.pmacro (mode expr) expr))
(load-op b OP2_8 QI (.pmacro (mode expr) (ext mode expr)))
(load-op h OP2_10 HI (.pmacro (mode expr) (ext mode expr)))
(load-op ub OP2_9 QI (.pmacro (mode expr) (zext mode expr)))
(load-op uh OP2_11 HI (.pmacro (mode expr) (zext mode expr)))
@@end smallexample

.pmacro's bind the same way Scheme lambda expressions do.
In the following example, arg2 in the second pmacro is bound
to the arg2 argument of the outer pmacro.

@@smallexample
(define-pmacro (foo arg1 arg2) ((.pmacro (bar) (+ arg2 bar)) arg1))
(foo 3 4) ==> (+ 4 3)
@@end smallexample

The contents of a @@code{.pmacro} are not evaluated until the pmacro
is invoked.

@@node Passing pmacros as arguments
@@subsection Passing pmacros as arguments

Macros may be passed to other macros.

Example:

@@smallexample
(define-pmacro (no-ext-expr mode expr) expr)
(define-pmacro (ext-expr mode expr) (ext mode expr))
(define-pmacro (zext-expr mode expr) (zext mode expr))

(define-pmacro (load-op suffix op2-op mode ext-op)
  (begin
    (dni (.sym ld suffix) (.str "ld" suffix)
	 ()
	 (.str "ld" suffix " $dr,@@@@$sr")
	 (+ OP1_2 op2-op dr sr)
	 (set dr (ext-op WI (mem mode sr)))
	 ())
  )
)

(load-op "" OP2_12 WI no-ext-expr)
(load-op b OP2_8 QI ext-expr)
(load-op h OP2_10 HI ext-expr)
(load-op ub OP2_9 QI zext-expr)
(load-op uh OP2_11 HI zext-expr)
@@end smallexample

@@node Defining a block of locals
@@subsection Defining a block of locals
@@cindex .let
@@cindex .let*

It is often handy to assign expressions to local variables,
if only to improve readability.
This is accomplished with the @@code{.let} and @@code{.let*} builtin pmacros.

@@code{.let} and @@code{.let*} have the same syntax:

    @@samp{(.let local-list expr1 [expr2 ...])}

    @@samp{(.let* local-list expr1 [expr2 ...])}

where @@samp{local-list} is a list of local variable assignments,
with the syntax @@samp{(name expr)}.  All variable names must be distinct.

The difference is that in @@code{.let} all expressions of all locals
are evaluated @@emph{first} and @@emph{then} assigned to the locals,
whereas in @@code{.let*} each local is evaluated and assigned in turn.
This means that expressions in @@code{.let} cannot refer to other locals
in the @@code{.let}.  If they do, they will get the values the variables had
before the @@code{.let}.  Also remember that symbols in pmacros are
``self-quoting'', so if a symbol isn't bound to any value, its value is
the symbol name.

Example:

@@smallexample
(define-pmacro (load-op suffix op2-op mode ext-op)
  (.let (
         (no-ext-expr (.pmacro (mode expr) expr))
         (ext-expr (.pmacro (mode expr) (ext mode expr)))
         (zext-expr (.pmacro (mode expr) (zext mode expr)))
        )
    (begin
      (dni (.sym ld suffix) (.str "ld" suffix)
	   ()
           (.str "ld" suffix " $dr,@@@@$sr")
           (+ OP1_2 op2-op dr sr)
           (set dr (ext-op WI (mem mode sr)))
           ())
    )
  )
)

(load-op "" OP2_12 WI no-ext-expr)
(load-op b OP2_8 QI ext-expr)
(load-op h OP2_10 HI ext-expr)
(load-op ub OP2_9 QI zext-expr)
(load-op uh OP2_11 HI zext-expr)
@@end smallexample

Note that one can also assign pmacros to local variables.

Note that @@code{.let*} is equivalent to a set of nested @@code{.let}
expressions:

@@smallexample
(.let* ((x 1) (y x)) y)
;; is equivalent to
(.let ((x 1)) (.let ((y x)) y))
@@end smallexample

@@node A block of statements
@@subsection A block of statements
@@cindex .begin

Sometimes one wishes to have a list of expressions (or statements)
and the context only allows one expression.
This can happen, for example, in the @@samp{then} and @@samp{else}
clauses of the @@code{.if} builtin pmacro.
Use the @@code{.begin} builtin pmacro for these situations.

Syntax: @@samp{(.begin [expr1 [expr2 ...]])}

Each expression is evaluated in turn and the result is the result
of the last expression.

@@node Testing if something is a pmacro
@@subsection Testing if something is a pmacro
@@cindex .pmacro?

Sometimes one wishes to know if an argument is a pmacro or not.
This is useful when one is writing a pmacro that has a parameter
that is either a pmacro or is not (e.g., it could be an rtl function
instead).  When the parameter is a pmacro one might like to @@samp{.apply}
it to another argument, and if not one might like to simply construct
a list of it and the other argument.

Syntax: @@samp{(.pmacro? arg)}

Example:

@@smallexample
(define-pmacro (compare a b) (if (eq a b) 1 0))
(define-pmacro (maybe-apply fun args)
  (.if (.pmacro? fun)
       (.apply fun args)
       (.splice fun (.unsplice args))))
(define-pmacro (gen-semantics semfun args)
  (set dest (maybe-apply semfun args)))
(gen-semantics add (op1 op2))) ;; ==> (set dest (add op1 op2))
(gen-semantics compare (op1 op2))) ;; ==> (set dest (if (eq op1 op2) 1 0))
@@end smallexample

@@node Debugging utilities
@@section Debugging utilities

@@menu
* .print::     Printing a diagnostic message
* .dump::      Printing arbitrarily complex objects
* .error::     Signalling an error has occurred
@@end menu

@@node .print
@@subsection .print
@@cindex .print

Syntax: @@samp{(.print expr1 [...])}

Evaluate and print the supplied expressions.
This is useful for debugging and logging messages.

NOTE: Strings are printed without enclosing quotes.
Use @@code{dump} if you want to print strings with enclosing quotes.

The result is the empty list @@code{()}.

@@node .dump
@@subsection .dump
@@cindex .dump

Syntax: @@samp{(.dump expr1 [...])}

Evaluate and print the supplied expressions.
This is useful for debugging and logging messages.

NOTE: Strings are printed with enclosing quotes.
Use @@code{print} if you want to print strings without enclosing quotes.

The result is the empty list @@code{()}.

@@node .error
@@subsection .error
@@cindex .error

Syntax: @@samp{(.error expr1 [...])}

Evaluate the supplied expressions and signal an error.
The expressions are typically error messages, often with the
object that caused the error.

@@node Comparisons
@@section Comparisons

Builtin macros for comparing objects.

In CGEN ``true'' is represented by @@code{#t}
and ``false'' is represented by @@code{#f}.

@@menu
* .equal?::      Deep comparison
* .andif::       && in C
* .orif::        || in C
* .not::         ! in C
* .eq::          Shallow comparison
* .ne::          Shallow comparison
* .lt::          Less than
* .gt::          Greater than
* .le::          Less than or equal to
* .ge::          Greater than or equal to
@@end menu

@@node .equal?
@@subsection .equal?
@@cindex .equal?

Syntax: @@samp{(.equal? x y)}

Return #t if @@code{x} is equal to @@code{y}, otherwise #f.

A ``deep'' comparison is used.
I.e., if @@code{x} and @@code{y} are lists, list elements
are recursively compared

Examples:

@@smallexample
(.equal? "abc" "abc") --> #t
(.equal? symbol1 symbol1) --> #t
(.equal? ((1 2 3) (4 5 6)) ((1 2 3) (4 5 6))) --> #t
@@end smallexample

@@node .andif
@@subsection .andif
@@cindex .andif

Syntax: @@samp{(.andif [expr1 [expr2 ...]])}

Each expression is evaluated in turn.
If an expression evaluates to false (@@code{#f}) then
evaluation stops and the result is @@code{#f}.
If all expressions evaluate to non-@@code{#f}, then
the value of the last expression is returned.

Note that this is a special form.
Just like @@code{&&} in C, evaluation of subsequent
expressions is not done once an expression is found
that evaluates to ``false''.

Examples:

@@smallexample
(.andif 1 #f 2) --> #f
(.andif 1 2 3) --> 3
(.andif) --> #t
@@end smallexample

@@node .orif
@@subsection .orif
@@cindex .orif

Syntax: @@samp{(.orif [expr1 [expr2 ...]])}

Each expression is evaluated in turn.
If an expression evaluates to non-false (@@code{#f}) then
evaluation stops and the result is the value of the first
non-@@code{#f} expression.
If all expressions evaluate to @@code{#f}, then
the result is @@code{#f}.

Note that this is a special form.
Just like @@code{||} in C, evaluation of subsequent
expressions is not done once an expression is found
that evaluates to non-``false''.

Examples:

@@smallexample
(.orif 1 2 3) --> 1
(.orif #f #f #f) --> #f
(.orif) --> #f
@@end smallexample

@@node .not
@@subsection .not
@@cindex .not

Syntax: @@samp{(.not expr)}

If @@code{expr} is @@code{#f} return @@code{#t}.
If @@code{expr} is non-@@code{#f} return @@code{#f}.

@@emph{Note that (.not 0) is not 1, it is #f!}.

@@node .eq
@@subsection .eq
@@cindex .eq

Syntax: @@samp{(.eq x y)}

Return ``true'' if @@code{x} equals @@code{y}, otherwise ``false''.

Note that this does @@emph{not} do a deep comparison,
and can only be used with symbols, strings, and numbers.
Both @@code{x} and @@code{y} must be the same type.

Examples:

@@smallexample
(.eq 1 1) -> #t
(.eq 0 1) -> #f
(.eq 0 one) -> error
(.eq one one) -> #t
(.eq zero one) -> #f
(.eq "abc" "abc") -> #t
(.eq "abc" "def") -> #f
@@end smallexample

@@node .ne
@@subsection .ne
@@cindex .ne

Syntax: @@samp{(.ne x y)}

Return ``true'' if @@code{x} does not equal @@code{y}, otherwise ``false''.

Note that this does @@emph{not} do a deep comparison,
and can only be used with symbols, strings, and numbers.
Both @@code{x} and @@code{y} must be the same type.

Examples:

@@smallexample
(.ne 1 1) -> #f
(.ne 0 1) -> #t
(.ne 0 one) -> error
(.ne one one) -> #f
(.ne zero one) -> #t
(.ne "abc" "abc") -> #f
(.ne "abc" "def") -> #t
@@end smallexample

@@node .lt
@@subsection .lt
@@cindex .lt

Syntax: @@samp{(.lt x y)}

Return ``true'' if @@code{x} is less than @@code{y}, otherwise ``false''.

Both @@code{x} and @@code{y} must be numbers.

@@node .gt
@@subsection .gt
@@cindex .gt

Syntax: @@samp{(.gt x y)}

Return ``true'' if @@code{x} is greater than @@code{y}, otherwise ``false''.

Both @@code{x} and @@code{y} must be numbers.

@@node .le
@@subsection .le
@@cindex .le

Syntax: @@samp{(.le x y)}

Return ``true'' if @@code{x} is less than or equal to @@code{y},
otherwise ``false''.

Both @@code{x} and @@code{y} must be numbers.

@@node .ge
@@subsection .ge
@@cindex .ge

Syntax: @@samp{(.ge x y)}

Return ``true'' if @@code{x} is greater than or equal to @@code{y},
otherwise ``false''.

Both @@code{x} and @@code{y} must be numbers.

@@node Arithmetic functions
@@section Arithmetic functions

@@menu
* .add::      Addition
* .sub::      Subtraction
* .mul::      Multiplication
* .div::      Integer division
* .rem::      Integer remainder
@@end menu

@@node .add
@@subsection .add
@@cindex .add

Syntax: @@samp{(.add x y)}

Return @@code{x} + @@code{y}.

@@node .sub
@@subsection .sub
@@cindex .sub

Syntax: @@samp{(.sub x y)}

Return @@code{x} - @@code{y}.

@@node .mul
@@subsection .mul
@@cindex .mul

Syntax: @@samp{(.mul x y)}

Return @@code{x} * @@code{y}.

@@node .div
@@subsection .div
@@cindex .div

Syntax: @@samp{(.div x y)}

Return the quotient of @@code{x} divided by @@code{y}.

Only integer division is supported,
both @@code{x} and @@code{y} must be integers.

@@node .rem
@@subsection .rem
@@cindex .rem

Syntax: @@samp{(.rem x y)}

Return the remainder of @@code{x} divided by @@code{y}.

Only integer division is supported,
both @@code{x} and @@code{y} must be integers.

@@c Need to define and document behaviour for negative numbers.

@@node Logical functions
@@section Logical functions

Builtin macros for shifts and bitwise functions.

@@menu
* .sll::       Shift left logical
* .srl::       Shift right logical
* .sra::       Shift right arithmetic
* .and::       Bitwise and
* .or::        Bitwise or
* .xor::       Bitwise exclusive-or
* .inv::       Bitwise inversion
@@end menu

@@node .sll
@@subsection .sll
@@cindex .sll

Syntax: @@samp{(.sll x n)}

Shift @@code{x} left by @@code{n} bits.
Zeroes are shifted into the low-order bits.

@@code{n} must be a non-negative integer.

@@node .srl
@@subsection .srl
@@cindex .srl

Syntax: @@samp{(.srl x n)}

Shift @@code{x} right by @@code{n} bits.

@@code{x} @@emph{must} be a non-negative integer.
Numbers at the pmacro level have ``infinite precision'',
and shifting zeroes into the high-order bits of
infinite-precision negative numbers is undefined.

@@code{n} must be a non-negative integer.

@@node .sra
@@subsection .sra
@@cindex .sra

Syntax: @@samp{(.sra x n)}

Shift @@code{x} right arithmetically by @@code{n} bits.
The sign bit of @@code{x} is shifted into the high-order bits.

@@code{n} must be a non-negative integer.

@@node .and
@@subsection .and
@@cindex .and

Syntax: @@samp{(.and x y)}

Return the bitwise @@code{and} of @@code{x} and @@code{y}.

@@node .or
@@subsection .or
@@cindex .or

Syntax: @@samp{(.or x y)}

Return the bitwise @@code{or} of @@code{x} and @@code{y}.

@@node .xor
@@subsection .xor
@@cindex .xor

Syntax: @@samp{(.xor x y)}

Return the bitwise @@code{exclusive-or} of @@code{x} and @@code{y}.

@@node .inv
@@subsection .inv
@@cindex .inv

Syntax: @@samp{(.inv x)}

Return the bitwise @@code{inversion} of @@code{x}.

@@node Internal use pmacros
@@section Internal use pmacros

This section documents pmacros that are for internal use only.
Today there's only one, @@samp{.internal-test}, and it is used
by the testsuite.

@@subsection .internal-test
@@cindex .internal-test

Syntax: @@samp{(.internal-test expr)}

Execute @@samp{expr} as a Scheme expression and return #f if the
expression returns #f and return #t if the expression returns non-#f.

This is for use in the CGEN testsuite only.
See the testsuite for usage examples.
@


1.21
log
@	Pmacro .equals -> .equal?
	* pmacros.scm (-pmacro-builtin-equal?): Renamed from
	-pmacro-builtin-equals.  All callers updated.
	(pmacros-init!): Rename .equals to .equal?.
	* doc/pmacros.texi: Update.
	* testsuite/pmacros-1.test: Update.
@
text
@d600 4
@


1.20
log
@tweak previous change for consistency
@
text
@d1159 1
a1159 1
* .equals::      Deep comparison
d1171 3
a1173 3
@@node .equals
@@subsection .equals
@@cindex .equals
d1175 1
a1175 1
Syntax: @@samp{(.equals x y)}
d1186 3
a1188 3
(.equals "abc" "abc") --> #t
(.equals symbol1 symbol1) --> #t
(.equals ((1 2 3) (4 5 6)) ((1 2 3) (4 5 6))) --> #t
@


1.19
log
@	* doc/pmacros.texi (pmacro default argument values): Add text.
@
text
@d284 1
a284 1
To invoke a pmacro with default values for some (or all)
@


1.18
log
@	* doc/pmacros.texi (.splice): Add more text.
@
text
@d284 3
d294 3
a296 1
(foo #:arg2 33) ==> (bar 1 33)
@


1.17
log
@(.dump): fix typo
@
text
@d483 1
a483 1
* Creating lists::
d486 1
a486 1
* List length::
d507 3
d586 8
a593 1
@@code{.splice}.
@


1.16
log
@	New builtin .pmacro?.
	* pmacros.scm (-pmacro-builtin-pmacro?): New function.
	(pmacros-init!): Add .pmacro?.
	* doc/pmacros.text: Document .pmacro?.
	* testsuite/pmacros-1.test: Test .pmacro?.
@
text
@d1121 1
a1121 1
Use @@code{dump} if you want to print strings without enclosing quotes.
@


1.15
log
@	* pmacros.scm (-pmacro-builtin-internal-test): New function.
	(pmacros-init!): Add .internal-test.
	* testsuite/test-utils.sh.in (post_process): Tweak FAIL output.
	* testsuite/testsuite.cpu (internal-verify): New pmacro.
	* doc/pmacros.text: Document .internal-test.

	* utils-cgen.scm (parse-name): Handle (add 3) -> add3.
	(parse-comment): Allow numbers.
	* doc/porting.texi: Document that names and comments may be lists.

	* insn.scm (-insn-parse): Fix typo.
@
text
@d840 1
d1061 27
@


1.14
log
@	Rename .eval -> .exec.  Add new .eval.
	* pmacros.scm (-pmacro-built-exec): Renamed from -pmacro-builtin-eval.
	(-pmacro-builtin-eval): New function.
	(pmacros-init!): Add .exec.
	* doc/pmacros.texi: Update, .exec -> .eval.  Document new .eval.
	* testsuite/location-1.test: Update.
	* testsuite/pmacros-1.test: Add test for .eval.
@
text
@d31 1
d1442 18
@


1.13
log
@	* pmacros.scm (pmacro-dump): New function.
	(check-pmacro): Tweak debugging output.
	* doc/cgenint.texi: Mention pmacro-dump, pmacro-debug.
	* doc/pmacros.texi (.splice): Use pmacro-dump instead of pmacro-expand.
@
text
@d150 4
a153 3
After a pmacro has been expanded, if the result of the pmacro is another
pmacro invocation, it is in turn processed.  This happens just once,
not repeatedly.
d204 1
a204 1
@@code{.splice}, @@code{.unsplice} is to use @@code{.for-each}, @@code{.eval}.
d208 1
a208 1
@@code{.eval} to pass the dnis to the reader.
d212 1
a212 1
  (.eval (dni (.ref ispec 0)
d220 1
a220 1
  (.eval (dni (.ref ispec 0)
d773 1
a773 1
The @@code{.eval} builtin pmacro is useful here.
d829 1
a829 1
Macros for working with pmacros.
d832 7
a838 6
* Immediate evaluation of a macro:: The @@code{.eval} builtin
* Applying a macro to a list::      The @@code{.apply} builtin
* Defining a pmacro inline::        The @@code{.pmacro} builtin
* Passing macros as arguments::     Passing a macro to another macro
* Defining a block of locals::      The @@code{.let}, @@code{.let*} builtins
* A block of statements::           The @@code{.begin} builtin
d841 2
a842 2
@@node Immediate evaluation of a macro
@@subsection Immediate evaluation of a macro
d847 24
d875 1
a875 1
Use the @@code{.eval} builtin pmacro for this purpose.
d877 1
a877 1
and returns @@code{()} as a result.
d879 2
a880 2
@@node Applying a macro to a list
@@subsection Applying a macro to a list
d949 2
a950 2
@@node Passing macros as arguments
@@subsection Passing macros as arguments
@


1.12
log
@New section for syntactic forms.
@
text
@d511 1
a511 1
(pmacro-expand (splice-test 1 (2) 3))
@


1.11
log
@	Add .let* pmacro builtin.
	* pmacros.scm (-pmacro-builtin-let*): New function.
	(pmacros-init!): Add .let*.
	* doc/pmacros.texi: Document .let*.
	* testsuite/pmacros-1.test: Test .let*.
@
text
@d18 1
d21 9
a29 9
* Symbols and strings::    Macros for symbols and strings
* Number utilities::       Macros for manipulating numbers
* List utilities::         Macros for manipulating lists
* Iteration utilities::    Macros for iterating over lists
* Conditional macros::     Macros for conditional execution
* Pmacro utilities::       Macros for using macros
* Debugging utilities::    Macros for debugging
* Comparisons::            Macros for comparing things
* Arithmetic functions::   Macros for doing math
d136 3
a138 1
Most function pmacros are expanded by processing any macros in th invocation,
d148 1
a148 10
Some function pmacros are called @@samp{syntactic forms}.
These pmacros are processed differently in that parameters are
@@emph{not} evaluated first.  Instead it is up to the pmacro
to decide when, and if, the parameters are evaluated.
The syntactic forms are: @@code{.pmacro}, @@code{.let}, @@code{.let*}, @@code{.if},
@@code{.case}, @@code{.cond}, @@code{.begin}, @@code{.andif}, and @@code{.orif}.

If the result of the pmacro is another pmacro invocation,
it is in turn processed.
@@c Need to document whether this happens just once, or repeatedly.
d150 3
a152 1
Variable macros are expanded simply by replacing their name with their value.
d231 36
d920 3
d1030 3
@


1.10
log
@some minor tweaks
@
text
@d149 1
a149 1
The syntactic forms are: @@code{.pmacro}, @@code{.let}, @@code{.if},
d801 1
a801 1
* Defining a macro inline::         The @@code{.pmacro} builtin
d803 1
a803 1
* Defining a block of locals::      The @@code{.let} builtin
d850 2
a851 2
@@node Defining a macro inline
@@subsection Defining a macro inline
d856 1
a856 1
and as values for local variables in @@code{.let}.
d921 1
d925 1
a925 1
This is accomplished with the @@code{.let} builtin pmacro.
d927 3
a929 1
Note that one can also assign pmacros to local variables.
d931 1
a931 1
Syntax: @@samp{(.let local-list expr1 [expr2 ...])}
d934 10
a943 1
with the syntax @@samp{(name expr)}.
d972 11
@


1.9
log
@	* pmacros.scm (-pmacro-builtin-find): New predicate.
	(pmacros-init!): Add .find.
	* doc/pmacros.tex: Document .find.
	* testsuite/pmacros-1.test: Test .find.
@
text
@d599 1
a599 1
Syntax: @@samp{(.find predicate l)}
d666 3
a668 1
Return all elements of the first element of the list after the first one.
@


1.8
log
@	Fix binding of nested pmacro parameters.
	* pmacros.scm (-pmacro-env-make): New arg prev-env.
	All callers updated.
	(-pmacro-bulid-lambda): Ditto.
	* doc/pmacros.texi: Update.
@
text
@d451 1
a451 1
* Referencing a list element::
d453 2
a454 1
* Lists of repeated elements::
d593 14
@


1.7
log
@	* doc/pmacros.texi (.not): Emphasize (.not 0) is not 1.

	Rename builtin boolean pmacros, for consistency with rtl.
	* pmacros.scm: .and -> .andif, .or -> .orif, .bitand -> .and,
	.bitor -> .or, .bitxor -> .xor, .bitinv -> .inv.
	* doc/pmacros.texi: Update.
	* testsuite/pmacros-1.test: Update.
@
text
@d862 3
a864 4
.pmacro's don't bind the way Scheme lambda expressions do.
In the following example, arg2 in the second pmacro is not bound
to the arg2 argument of the first pmacro.
@@c FIXME: Feels like a bug rather than a feechure.
d868 1
a868 1
(foo 3 4) ==> (+ arg2 3)
@


1.6
log
@	Extend pmacro language, add testsuite.
	* Makefile.am (SUBDIRS): Add testsuite.
	* Makefile.in: Regenerate.
	* configure.in (AC_OUTPUT): Create testsuite/Makefile,
	testsuite/test-utils.sh.
	* configure: Regenerate.
	* dev.scm (cload): Handle testsuite app.
	(load-testsuite): New function.
	* pmacros.scm: (-pmacro-debug?): New global.
	(-smacro-table): New global.
	(-smacro-lookup, -smacro-set!): New functions.
	(-pmacro-make): New argument `syntactic-form?', all callers updated.
	(-pmacro-syntactic-form?): New function.
	(-pmacro-expected-number, -pmacro-verify-number): New functions.
	(-pmacro-expected-integer, -pmacro-verify-integer): New functions.
	(-pmacro-expected-non-negative-integer): New function.
	(-pmacro-verify-non-negative-integer): New function.
	(-pmacro-expand-expr-list): New function.
	(-pmacro-process-args-1): Renamed from -pmacro-process-args.
	(-pmacro-process-args): Renamed from -pmacro-invoke.
	(-pmacro-apply, -smacro-apply): New functions.
	(-pmacro-expand): Rewrite syntactic form processing.
	(-pmacro-build-lambda): Reformat.
	(define-pmacro): Watch for more errors in definition.
	(pmacro-debug): New function.
	(pmacro-trace): Set/reset -pmacro-debug?.
	(all existing builtin pmacro helpers): Rename to -pmacro-builtin-foo.
	(-pmacro-builtin-substring): Fix.  Add support for `end' marker.
	(-pmacro-builtin-for-each, et.al.): New helpers for .for-each, .let,
	.if, .case, .cond, .begin, .print, .dump, .error, .list, .ref,
	.length, .replicate, .equals, .and, .or, .not, .eq, .ne, .lt, .gt,
	.le, .ge, .add, .sub, .mul, .div, .rem, .sll, .srl, .sra, .bitand,
	.bitor, .bitxor, bitinv, .car, .cdr, .caar, .cadr, .cdar, .cddr.
	(pmacros-init!): Initialize -smacro-table.
	Rewrite pmacro initialization.
	* read.scm (reader-process-expanded): Renamed from
	-reader-process-expanded.  All callers updated.
	Recognize () as a no-op.
	(cpu-load): Tweak logging messages.
	* utils.scm (message): Add comment.
	* cpu/play.cpu: Add some instructions to play with .let.
	* doc/cgenint.texi: Move some debugging related docs to here from
	cgen.texi.
	* doc/pmacros.texi: Reorganize.  Add docs for new builtin pmacros.
	* testsuite/Makefile.am: New file.
	* testsuite/Makefile.in: New file.
	* testsuite/test-utils.sh.in: New file.
	* testsuite/run-tests.sh: New file.
	* testsuite/testsuite.cpu: New file.
	* testsuite/pmacros-1.test: New file.
@
text
@d150 1
a150 1
@@code{.case}, @@code{.cond}, @@code{.begin}, @@code{.and}, and @@code{.or}.
d1013 2
a1014 2
* .and::         && in C
* .or::          || in C
d1044 3
a1046 3
@@node .and
@@subsection .and
@@cindex .and
d1048 1
a1048 1
Syntax: @@samp{(.and [expr1 [expr2 ...]])}
d1064 3
a1066 3
(.and 1 #f 2) --> #f
(.and 1 2 3) --> 3
(.and) --> #t
d1069 3
a1071 3
@@node .or
@@subsection .or
@@cindex .or
d1073 1
a1073 1
Syntax: @@samp{(.or [expr1 [expr2 ...]])}
d1090 3
a1092 3
(.or 1 2 3) --> 1
(.or #f #f #f) --> #f
(.or) --> #f
d1104 2
d1264 4
a1267 4
* .bitand::    Bitwise and
* .bitor::     Bitwise or
* .bitxor::    Bitwise exclusive-or
* .bitinv::    Bitwise inversion
d1307 3
a1309 3
@@node .bitand
@@subsection .bitand
@@cindex .bitand
d1311 1
a1311 1
Syntax: @@samp{(.bitand x y)}
d1315 3
a1317 3
@@node .bitor
@@subsection .bitor
@@cindex .bitor
d1319 1
a1319 1
Syntax: @@samp{(.bitor x y)}
d1323 3
a1325 3
@@node .bitxor
@@subsection .bitxor
@@cindex .bitxor
d1327 1
a1327 1
Syntax: @@samp{(.bitxor x y)}
d1331 3
a1333 3
@@node .bitinv
@@subsection .bitinv
@@cindex .bitinv
d1335 1
a1335 1
Syntax: @@samp{(.bitinv x)}
@


1.5
log
@	* doc/cgenint.texi: Renamed from internals.texi.  Several cleanups.
	* doc/app.texi: Cleanup pass.
	* doc/cgen.texi: Cleanup pass.
	* doc/glossary.texi: Add entries for ifield, iformat, sformat, insn.
	* doc/intro.texi: Cleanup pass.
	* doc/mdate-sh: New file.
	* doc/opcodes.texi: Cleanup pass.
	* doc/pmacros.texi: Cleanup pass.
	* doc/porting.texi: Cleanup pass.
	* doc/rtl.texi: Cleanup pass.
	* doc/running.texi: Cleanup pass.  Document more runtime options.
	* doc/stamp-vti: Update.
	* doc/version.texi: Update.
@
text
@d11 1
a11 1
@@file{.cpu} files and serve the same purpose that macros do in C.
d14 16
a29 17
* Defining a preprocessor macro:: @@code{define-pmacro}
* Using preprocessor macros::     Using preprocessor macros
* Macro expansion::               The @@code{pmacro-expand} procedure
* Default argument values::       Specifying default values of arguments
* Multiple output expressions::   Using @@code{begin}
* Symbol concatenation::          The @@code{.sym} builtin
* String concatenation::          The @@code{.str} builtin
* Convert a number to a hex::     The @@code{.hex} builtin
* Convert a string to uppercase:: The @@code{.upcase} builtin
* Convert a string to lowercase:: The @@code{.downcase} builtin
* Getting part of a string::      The @@code{.substring} builtin
* List splicing::                 The @@code{.splice} builtin
* Number generation::             The @@code{.iota} builtin
* Mapping a macro over a list::   The @@code{.map} builtin
* Applying a macro to a list::    The @@code{.apply} builtin
* Defining a macro inline::       The @@code{.pmacro} builtin
* Passing macros as arguments::   Passing a macro to another macro
d32 42
a73 2
@@node Defining a preprocessor macro
@@section Defining a preprocessor macro
d76 8
a83 1
Preprocessor macros are defined with:
d86 2
a87 1
(define-pmacro (name parm1 parm2 ... parmN)
d92 4
a95 4
The result is @@samp{expansion} with parameters replaced with the actual
arguments of the macro invocation.  Free variables are left unchanged.
[A "free variable", as defined here, is one that doesn't appear in the
parameter list.]
d97 1
a97 2
@@c ??? This used to be true, but currently isn't.
@@c If the result is another macro invocation, it is expanded in turn.  
d99 6
a104 1
@@samp{expansion} must be exactly one expression.
d106 2
a107 2
@@node Using preprocessor macros
@@section Using preprocessor macros
d109 2
a110 3
Preprocessor macros are invoked in either of two ways: positional arguments
and arguments by name.
@@c Rather lame wording.
d115 1
a115 1
; Invoke by positional arguments.
d119 1
a119 1
; Invoke by naming arguments.
d124 1
a124 2
@@c If you think more should be said here, I agree.
@@c Please think of something.
d126 2
a127 2
@@node Macro expansion
@@section Macro expansion
d129 28
a156 2
At the implementation level, pmacros are expanded with the
@@code{pmacro-expand} Scheme procedure.
d158 2
a159 2
The following is executed from a Guile shell, as opposed to 
appearing in a cpu description file, hence the extra quoting.
d162 71
a232 3
guile> (define-pmacro '(foo a b) '(+ a b))
guile> (pmacro-expand '(foo 3 4))
(+ 3 4)
d260 2
a261 2
@@node Multiple output expressions
@@section Multiple output expressions
d271 18
a288 5
??? It's moderately clumsy to restrict @@code{begin} like this.
Using @@code{sequence} for this purpose might be cleaner except that
sequence locals don't make sense in this context (though perhaps that's
a lesser evil).  In the end, @@code{begin} can be shorthand for a void-mode
sequence with no locals so I haven't been in a rush to resolve this.
d291 1
a291 1
@@section Symbol concatenation
d307 1
a307 1
@@section String concatenation
d336 1
a336 1
@@section Convert a number to a hex
d354 1
a354 1
@@section Convert a string to uppercase
d368 2
a369 1
@@section Convert a string to lowercase
d382 1
a382 1
@@section Getting part of a string
d387 1
a387 1
Syntax: @@code{(.substring string start end)}
d400 68
d469 1
a469 1
@@section List splicing
d478 1
a478 1
(pmacro-expand (splice-test (1 (2) 3)))
d550 112
a661 4
@@node Number generation
@@section Number generation
@@cindex .iota
@@cindex Number generation
d663 1
a663 2
Machine descriptions often require a list of sequential numbers.
Generate a list of numbers with the @@code{.iota} builtin macro.
d665 1
a665 1
The syntax is @@samp{(.iota count [start [incr]])}.
d667 1
a667 1
Examples:
d670 1
a670 3
(.iota 5)      --> 0 1 2 3 4
(.iota 5 4)    --> 4 5 6 7 8
(.iota 5 5 -1) --> 5 4 3 2 1
d673 12
d686 1
a686 1
@@section Mapping a macro over a list
d690 1
d693 1
d695 2
a696 3
The result is a list with @@samp{macro-name} applied to each element of
@@samp{listN}.  @@samp{macro-name} should take as many arguments as there
are lists.  This is often useful in constructing enum and register name lists.
d709 95
d805 1
a805 1
@@section Applying a macro to a list
d823 2
d826 1
a826 5
(.apply .str (.iota 5))

-->

"01234"
d834 1
a834 1
@@section Defining a macro inline
d838 4
a841 1
This is only supported when passing macros as arguments to other macros.
d850 1
a850 1
	 (set dr (ext-op WI (mem: mode sr)))
d856 4
a859 4
(load-op b OP2_8 QI (.pmacro (mode expr) (ext: mode expr)))
(load-op h OP2_10 HI (.pmacro (mode expr) (ext: mode expr)))
(load-op ub OP2_9 QI (.pmacro (mode expr) (zext: mode expr)))
(load-op uh OP2_11 HI (.pmacro (mode expr) (zext: mode expr)))
d865 1
d873 1
a873 1
@@section Passing macros as arguments
d881 2
a882 2
(define-pmacro (ext-expr mode expr) (ext: mode expr))
(define-pmacro (zext-expr mode expr) (zext: mode expr))
d890 1
a890 1
	 (set dr (ext-op WI (mem: mode sr)))
d901 435
@


1.5.4.1
log
@Copy over from trunk.
	Extend pmacro language, add testsuite.
	* Makefile.am (SUBDIRS): Add testsuite.
	* Makefile.in: Regenerate.
	* configure.in (AC_OUTPUT): Create testsuite/Makefile,
	testsuite/test-utils.sh.
	* configure: Regenerate.
	* dev.scm (cload): Handle testsuite app.
	(load-testsuite): New function.
	* pmacros.scm: (-pmacro-debug?): New global.
	(-smacro-table): New global.
	(-smacro-lookup, -smacro-set!): New functions.
	(-pmacro-make): New argument `syntactic-form?', all callers updated.
	(-pmacro-syntactic-form?): New function.
	(-pmacro-expected-number, -pmacro-verify-number): New functions.
	(-pmacro-expected-integer, -pmacro-verify-integer): New functions.
	(-pmacro-expected-non-negative-integer): New function.
	(-pmacro-verify-non-negative-integer): New function.
	(-pmacro-expand-expr-list): New function.
	(-pmacro-process-args-1): Renamed from -pmacro-process-args.
	(-pmacro-process-args): Renamed from -pmacro-invoke.
	(-pmacro-apply, -smacro-apply): New functions.
	(-pmacro-expand): Rewrite syntactic form processing.
	(-pmacro-build-lambda): Reformat.
	(define-pmacro): Watch for more errors in definition.
	(pmacro-debug): New function.
	(pmacro-trace): Set/reset -pmacro-debug?.
	(all existing builtin pmacro helpers): Rename to -pmacro-builtin-foo.
	(-pmacro-builtin-substring): Fix.  Add support for `end' marker.
	(-pmacro-builtin-for-each, et.al.): New helpers for .for-each, .let,
	.if, .case, .cond, .begin, .print, .dump, .error, .list, .ref,
	.length, .replicate, .equals, .and, .or, .not, .eq, .ne, .lt, .gt,
	.le, .ge, .add, .sub, .mul, .div, .rem, .sll, .srl, .sra, .bitand,
	.bitor, .bitxor, bitinv, .car, .cdr, .caar, .cadr, .cdar, .cddr.
	(pmacros-init!): Initialize -smacro-table.
	Rewrite pmacro initialization.
	* read.scm (reader-process-expanded): Renamed from
	-reader-process-expanded.  All callers updated.
	Recognize () as a no-op.
	(cpu-load): Tweak logging messages.
	* utils.scm (message): Add comment.
	* cpu/play.cpu: Add some instructions to play with .let.
	* doc/cgenint.texi: Move some debugging related docs to here from
	cgen.texi.
	* doc/pmacros.texi: Reorganize.  Add docs for new builtin pmacros.
	* testsuite/Makefile.am: New file.
	* testsuite/Makefile.in: New file.
	* testsuite/test-utils.sh.in: New file.
	* testsuite/run-tests.sh: New file.
	* testsuite/testsuite.cpu: New file.
	* testsuite/pmacros-1.test: New file.
@
text
@d11 1
a11 1
@@file{.cpu} files.
d14 17
a30 16
* Pmacros introduction::   Introduction to pmacros
* Defining pmacros::       @@code{define-pmacro}
* Using pmacros::          Using preprocessor macros
* Pmacro expansion::       How pmacros are expanded
* Default argument values::  Specifying default values of arguments
* Multiple result statements::  Using @@code{begin}
* Symbols and strings::    Macros for symbols and strings
* Number utilities::       Macros for manipulating numbers
* List utilities::         Macros for manipulating lists
* Iteration utilities::    Macros for iterating over lists
* Conditional macros::     Macros for conditional execution
* Pmacro utilities::       Macros for using macros
* Debugging utilities::    Macros for debugging
* Comparisons::            Macros for comparing things
* Arithmetic functions::   Macros for doing math
* Logical functions::      Shifts, bitwise logical functions
d33 2
a34 42
@@node Pmacros introduction
@@section Pmacros introduction

The macro facility provided by CGEN is quite extensive.
This is to give @@file{.cpu} file writers the freedom to
write the file in ways that work for the architecture in question.
Not all architectures are best described in the same way.

The macros are called @@samp{pmacros} because the word @@samp{macro}
has become overloaded.  For clarity, we give them a unique name:
@@samp{pmacros}.

One important point to keep in mind regarding pmacros is that
when loading @@file{.cpu} files all pmacros are expanded and discarded,
their only purpose is to simplify writing the @@code{dni}s and other
elements of the architecture description.

Therefore, do not try to write RTL as pmacros.
You can of course use pmacros to assist in the writing of RTL,
but remember that the resulting RTL @@emph{cannot} use pmacros.
By the time the RTL is processed all pmacros have been expanded
and discarded.

A simple picture may help.
Here is a basic diagram of the steps in processing cpu descriptions.

@@example
         (1) .cpu file
                |
      (2) pmacro expansion
                |
(3) define-@@{insn,operand,etc.@@} processing
                |
   (4) instruction set analysis
                |
 (5) application source file generation
@@end example

Once CGEN gets to step (3) pmacros no longer exist.

@@node Defining pmacros
@@section Defining pmacros
d37 1
a37 8
There are two kinds of macros:

@@itemize @@bullet
@@item function macros
@@item variable macros
@@end itemize

Preprocessor function macros are defined with:
d40 1
a40 2
(define-pmacro (name [parm1 parm2 ... parmN])
  ["optional comment"]
d45 4
a48 1
@@samp{expansion} must be exactly one expression.
d50 2
a51 2
Preprocessor variable macros are just global variables, nothing special.
When invoked their value is used in place of their name.
d53 1
a53 1
Variable macros are defined with:
d55 2
a56 6
@@smallexample
(define-pmacro name
  ["optional comment"]
  expansion
)
@@end smallexample
d58 3
a60 5
@@node Using pmacros
@@section Using pmacros

Functional macros are invoked in either of two ways: positional arguments
or specifying arguments by name.
d65 1
a65 1
;; Invoke by positional arguments.
d69 1
a69 1
;; Invoke by naming arguments.
d74 2
a75 1
Variable macros are invoked simply by specifying their name.
d77 2
a78 2
@@smallexample
(define-pmacro foo "abc")
d80 2
a81 28
(.str foo "def") ==> "abcdef"
@@end smallexample

@@node Pmacro expansion
@@section Pmacro expansion

Most function pmacros are expanded by processing any macros in th invocation,
binding the resulting expressions to the pmacro's parameters,
processing the pmacro according to its definition, and returning the result.
Free variables are left unchanged.@@footnote{A "free variable",
as defined here, is one that is not already bound, be it to
parameter, macro, or local variable within a macro.
Note that to pmacros, cpu description file elements like
@@code{reg}, @@code{sequence}, @@code{VOID}, etc. are just symbols;
they have no special meaning.}

Some function pmacros are called @@samp{syntactic forms}.
These pmacros are processed differently in that parameters are
@@emph{not} evaluated first.  Instead it is up to the pmacro
to decide when, and if, the parameters are evaluated.
The syntactic forms are: @@code{.pmacro}, @@code{.let}, @@code{.if},
@@code{.case}, @@code{.cond}, @@code{.begin}, @@code{.and}, and @@code{.or}.

If the result of the pmacro is another pmacro invocation,
it is in turn processed.
@@c Need to document whether this happens just once, or repeatedly.

Variable macros are expanded simply by replacing their name with their value.
d83 2
a84 2
Here is a simple example that uses pmacros to simplify the
definition of several instructions.
d87 3
a89 71
;; OP1_*,OP2_* are previously defined enums
(define-pmacro arithmetic-insns
  ((add OP2_0) (sub OP2_1) (mul OP2_2) (div OP2_3))
)
(define-pmacro (make-arith-reg/reg-format opcode)
  (+ OP1_0 opcode dr sr)
)
(define-pmacro (make-arith-reg/imm-format opcode)
  (+ OP1_1 opcode dr sr)
)
(define-pmacro (define-arith-insn ispec)
  (begin
    (dni (.ref ispec 0)
         (.str (.ref ispec 0) " reg/reg")
         ()
         (.str (.ref ispec 0) " $dr,$sr")
         (make-arith-reg/reg-format (.ref ispec 1))
         (set dr ((.ref ispec 0) dr sr))
         ()
         )
    (dni (.ref ispec 0)
         (.str (.ref ispec 0) " reg/imm")
         ()
         (.str (.ref ispec 0) " $dr,$imm")
         (make-arith-reg/imm-format (.ref ispec 1))
         (set dr ((.ref ispec 0) dr imm))
         ()
         )
  )
)

;; Create dnis for each kind of instruction.
;; The result of this is:
;; (begin (begin (dni ...) ...) (begin (dni ...) ...) ...)
(.splice begin (.unsplice (.map define-arith-insn arithmetic-insns)))
@@end smallexample

The @@code{.splice}, @@code{.unsplice} are necessary to pass properly
formed expressions to the @@file{.cpu} file reader.
If we just used @@samp{(.map define-arith-insn arithmetic-insns)}
the reader would see @@samp{((begin (dni ...) ...) (begin (dni ...) ...))}.
Note how the first @@code{begin} is nested within a list, and does not
appear in the ``top level'' list.

Another way to accomplish the same thing that doesn't require
@@code{.splice}, @@code{.unsplice} is to use @@code{.for-each}, @@code{.eval}.
@@code{.for-each} is only used for its side-effects, it does not
return a result.  Therefore, in order to actually cause the
@@file{.cpu} file reader to see any definitions we need to use
@@code{.eval} to pass the dnis to the reader.

@@smallexample
(define-pmacro (define-arith-insn ispec)
  (.eval (dni (.ref ispec 0)
           (.str (.ref ispec 0) " reg/reg")
           ()
           (.str (.ref ispec 0) " $dr,$sr")
           (make-arith-reg/reg-format (.ref ispec 1))
           (set dr ((.ref ispec 0) dr sr))
           ()
           ))
  (.eval (dni (.ref ispec 0)
           (.str (.ref ispec 0) " reg/imm")
           ()
           (.str (.ref ispec 0) " $dr,$imm")
           (make-arith-reg/imm-format (.ref ispec 1))
           (set dr ((.ref ispec 0) dr imm))
           ()
           ))
)
(.for-each define-arith-insn arithmetic-insns)
d117 2
a118 2
@@node Multiple result statements
@@section Multiple result statements
d128 5
a132 18
Note that this is @@emph{not} the @@code{.begin} builtin pmacro.
We want to pass a list of statements to the @@file{.cpu} file reader,
and pmacros have all been evaluated and discarded by this point.

@@node Symbols and strings
@@section Symbols and strings

There are several builtin macros for symbol and string manipulation.

@@menu
* Symbol concatenation::          The @@code{.sym} builtin
* String concatenation::          The @@code{.str} builtin
* Convert a number to a hex::     The @@code{.hex} builtin
* Convert a string to uppercase:: The @@code{.upcase} builtin
* Convert a string to lowercase:: The @@code{.downcase} builtin
* Getting part of a string::      The @@code{.substring} builtin
* Symbol or string length::       The @@code{.length} builtin
@@end menu
d135 1
a135 1
@@subsection Symbol concatenation
d151 1
a151 1
@@subsection String concatenation
d180 1
a180 1
@@subsection Convert a number to a hex
d198 1
a198 1
@@subsection Convert a string to uppercase
d212 1
a212 2
@@subsection Convert a string to lowercase
@@cindex .downcase
d225 1
a225 1
@@subsection Getting part of a string
d230 1
a230 1
Syntax: @@samp{(.substring string start end)}
a242 68
@@node Symbol or string length
@@subsection Symbol or string length
@@c @@cindex .length - the @@cindex for this is in the list section

Compute the length, in characters, of a symbol or string.

Syntax: @@samp{(.length symbol-or-string)}

Examples:

@@smallexample
(.length abc) --> 3
(.length "def") --> 3
(.length "") --> 0
@@end smallexample

@@node Number utilities
@@section Number utilities

Builtin macros for manipulating numbers.

@@menu
* Number generation::             The @@code{.iota} builtin
@@end menu

@@node Number generation
@@subsection Number generation
@@cindex .iota
@@cindex Number generation

Machine descriptions often require a list of sequential numbers.
Generate a list of numbers with the @@code{.iota} builtin macro.

Syntax: @@samp{(.iota count [start [incr]])}.

Examples:

@@smallexample
(.iota 5)      --> 0 1 2 3 4
(.iota 5 4)    --> 4 5 6 7 8
(.iota 5 5 -1) --> 5 4 3 2 1
@@end smallexample

@@node List utilities
@@section List utilities

Builtin macros for maninpulating lists.

@@menu
* Creating lists::
* List splicing::                 The @@code{.splice} builtin
* Referencing a list element::
* List length::
* Lists of repeated elements::
* car/cdr::                       car, cdr, etc. from Scheme/Lisp
@@end menu

@@node Creating lists
@@subsection Creating lists
@@cindex .list

Lists can be created with the @@code{.list} builtin.

Syntax: @@samp{(.list elm1 elm2 ...)}

It's somewhat redundant as lists can also be created simply writing
@@samp{(elm1 elm2 ...)}.

d244 1
a244 1
@@subsection List splicing
d253 1
a253 1
(pmacro-expand (splice-test 1 (2) 3))
d325 4
a328 3
@@node Referencing a list element
@@subsection Referencing a list element
@@cindex .ref
d330 2
a331 1
Reference elements of a list with @@code{.ref}.
d333 1
a333 1
Syntax: @@samp{(.ref list element-number)}
d335 1
a335 1
Example:
d338 3
a340 62
(.ref (1 2 3) 1) --> 2
@@end smallexample

@@node List length
@@subsection List length
@@cindex .length

The length of a list is computed with @@code{.length}.

Syntax: @@samp{(.length list)}.

Example:

@@smallexample
(.length (1 2 3)) --> 3
@@end smallexample

@@node Lists of repeated elements
@@subsection Lists of repeated elements
@@cindex .replicate

Create a list of repeated elements with @@code{.replicate}.

Syntax: @@samp{(.replicate n expr)}

Example:

@@smallexample
(.replicate 4 5) --> (5 5 5 5)
@@end smallexample

@@node car/cdr
@@subsection car/cdr
@@cindex .car
@@cindex .cdr
@@cindex .caar
@@cindex .cadr
@@cindex .cdar
@@cindex .cddr

CGEN provides a small set of pmacros for those familiar with
Scheme/Lisp lists.

@@itemize @@bullet
@@item car

Equivalent to @@samp{(.ref list 0)}.

Example:

@@smallexample
(.car (1 2 3)) --> 1
@@end smallexample

@@item cdr

Return all elements of the list after the first one.

Example:

@@smallexample
(.cdr (1 2 3)) --> (2 3)
a342 60
@@item caar

Return the first element of the first element of the list.

I.e., the @@code{car} of the @@code{car} of the list.

Example:

@@smallexample
(.caar ((1 2 3) (4 5 6))) --> 1
@@end smallexample

@@item cadr

Return the second element of the list.

I.e., the @@code{car} of the @@code{cdr} of the list.

Example:

@@smallexample
(.cadr (1 2 3)) --> 2
@@end smallexample

@@item cdar

Return all elements of the first element of the list after the first one.

I.e., the @@code{cdr} of the @@code{car} of the list.

Example:

@@smallexample
(.cadr ((1 2 3) (4 5 6))) --> (2 3)
@@end smallexample

@@item cddr

I.e., the @@code{cdr} of the @@code{cdr} of the list.

Return all elements of the list after the first two.

Example:

@@smallexample
(.cddr (1 2 3)) --> (3)
@@end smallexample

@@end itemize

@@node Iteration utilities
@@section Iteration utilities

Macros for iterating over lists

@@menu
* Mapping a macro over a list::   The @@code{.map} builtin
* Iterating over a list::         The @@code{.for-each} builtin
@@end menu

d344 1
a344 1
@@subsection Mapping a macro over a list
a347 1
The order in which each element of the list is processed is unspecified.
a349 1
@@samp{macro} must take as many arguments as there are lists.
d351 3
a353 2
The result is a list with @@samp{macro} applied to each element of
@@samp{listN}.  This is often useful in constructing enum and register name lists.
a365 95
@@node Iterating over a list
@@subsection Iterating over a list
@@cindex .for-each

Apply a macro to each element of a list, or set of lists,
with @@code{.for-each}.
Each element of the list is guaranteed to be processed in order.

The syntax is @@samp{(.for-each macro list1 [list2 ...])}.
@@samp{macro} must take as many arguments as there are lists.

There is no result, or rather the result is always the empty list ().
Note that this macro is therefore useless for macro expansion.
It's purpose is to process @@code{macro} for its side-effects.
The @@code{.eval} builtin pmacro is useful here.

@@node Conditional macros
@@section Conditional macros

Macros for conditional execution.

@@menu
* Traditional @@code{if}::         The @@code{.if} builtin
* Traditional @@code{case}::       The @@code{.case} builtin
* Extended if/elseif/else::       The @@code{.cond} builtin
@@end menu

@@node Traditional @@code{if}
@@subsection Traditional @@code{if}
@@cindex .if

Syntax: @@samp{(.if condition then-expr [else-expr])}.

The @@code{condition} is evaluated, and if it is non-#f then
@@code{then-expr} is evaluated and returned.
Otherwise, if @@code{else-expr} is present it is evaluated and returned.
Otherwise, the empty list @@code{()} is returned.

@@node Traditional @@code{case}
@@subsection Traditional @@code{case}
@@cindex .case

Syntax: @@samp{(.case expr ((case1-list) expr-list) [case-list] [(else expr-list)])}

The expression @@code{expr} is evaluated, and then
each case list is examined in turn to look for a match.
The first case list with an element that matches @@code{expr} wins,
its @@code{expr-list} is evaluated and the result of the last expression
in the expression list is returned.

If there is no successful match and no @@code{else} part,
then the empty list @@code{()} is returned.

@@node Extended if/elseif/else
@@subsection Extended if/elseif/else
@@cindex .cond

Syntax: @@samp{(.cond (expr1 expr-list) [cond-list] [(else expr-list)])}

Each condition's expression is evaluated in turn.
The first condition to evaluate to non-#f wins,
its @@code{expr-list} is evaluated and the result of the last expression
in the expression list is returned.

If there is no successful condition and no @@code{else} part,
then the empty list @@code{()} is returned.

@@node Pmacro utilities
@@section Pmacro utilities

Macros for working with pmacros.

@@menu
* Immediate evaluation of a macro:: The @@code{.eval} builtin
* Applying a macro to a list::      The @@code{.apply} builtin
* Defining a macro inline::         The @@code{.pmacro} builtin
* Passing macros as arguments::     Passing a macro to another macro
* Defining a block of locals::      The @@code{.let} builtin
* A block of statements::           The @@code{.begin} builtin
@@end menu

@@node Immediate evaluation of a macro
@@subsection Immediate evaluation of a macro
@@cindex .eval

Syntax: @@samp{(.eval expr)}

Sometimes one wishes to pass an expression to the @@file{.cpu} file reader
immediately, rather than waiting for it to process the expression
that is the result of a pmacro.  This typically happens with the
@@code{.for-each} builtin pmacro.
Use the @@code{.eval} builtin pmacro for this purpose.
It immediately passes @@samp{expr} to the @@file{.cpu} file reader
and returns @@code{()} as a result.

d367 1
a367 1
@@subsection Applying a macro to a list
d385 4
a388 1
Example:
d390 1
a390 2
@@smallexample
(.apply .str (.iota 5)) --> "01234"
d398 1
a398 1
@@subsection Defining a macro inline
d402 1
a402 4
This is only supported when passing macros as arguments to other macros,
and as values for local variables in @@code{.let}.

Example:
d411 1
a411 1
	 (set dr (ext-op WI (mem mode sr)))
d417 4
a420 4
(load-op b OP2_8 QI (.pmacro (mode expr) (ext mode expr)))
(load-op h OP2_10 HI (.pmacro (mode expr) (ext mode expr)))
(load-op ub OP2_9 QI (.pmacro (mode expr) (zext mode expr)))
(load-op uh OP2_11 HI (.pmacro (mode expr) (zext mode expr)))
a425 1
@@c FIXME: Feels like a bug rather than a feechure.
d433 1
a433 1
@@subsection Passing macros as arguments
d441 2
a442 2
(define-pmacro (ext-expr mode expr) (ext mode expr))
(define-pmacro (zext-expr mode expr) (zext mode expr))
d450 1
a450 1
	 (set dr (ext-op WI (mem mode sr)))
a460 435

@@node Defining a block of locals
@@subsection Defining a block of locals
@@cindex .let

It is often handy to assign expressions to local variables,
if only to improve readability.
This is accomplished with the @@code{.let} builtin pmacro.

Note that one can also assign pmacros to local variables.

Syntax: @@samp{(.let local-list expr1 [expr2 ...])}

where @@samp{local-list} is a list of local variable assignments,
with the syntax @@samp{(name expr)}.

Example:

@@smallexample
(define-pmacro (load-op suffix op2-op mode ext-op)
  (.let (
         (no-ext-expr (.pmacro (mode expr) expr))
         (ext-expr (.pmacro (mode expr) (ext mode expr)))
         (zext-expr (.pmacro (mode expr) (zext mode expr)))
        )
    (begin
      (dni (.sym ld suffix) (.str "ld" suffix)
	   ()
           (.str "ld" suffix " $dr,@@@@$sr")
           (+ OP1_2 op2-op dr sr)
           (set dr (ext-op WI (mem mode sr)))
           ())
    )
  )
)

(load-op "" OP2_12 WI no-ext-expr)
(load-op b OP2_8 QI ext-expr)
(load-op h OP2_10 HI ext-expr)
(load-op ub OP2_9 QI zext-expr)
(load-op uh OP2_11 HI zext-expr)
@@end smallexample

@@node A block of statements
@@subsection A block of statements
@@cindex .begin

Sometimes one wishes to have a list of expressions (or statements)
and the context only allows one expression.
This can happen, for example, in the @@samp{then} and @@samp{else}
clauses of the @@code{.if} builtin pmacro.
Use the @@code{.begin} builtin pmacro for these situations.

Syntax: @@samp{(.begin [expr1 [expr2 ...]])}

@@node Debugging utilities
@@section Debugging utilities

@@menu
* .print::     Printing a diagnostic message
* .dump::      Printing arbitrarily complex objects
* .error::     Signalling an error has occurred
@@end menu

@@node .print
@@subsection .print
@@cindex .print

Syntax: @@samp{(.print expr1 [...])}

Evaluate and print the supplied expressions.
This is useful for debugging and logging messages.

NOTE: Strings are printed without enclosing quotes.
Use @@code{dump} if you want to print strings with enclosing quotes.

The result is the empty list @@code{()}.

@@node .dump
@@subsection .dump
@@cindex .dump

Syntax: @@samp{(.dump expr1 [...])}

Evaluate and print the supplied expressions.
This is useful for debugging and logging messages.

NOTE: Strings are printed with enclosing quotes.
Use @@code{dump} if you want to print strings without enclosing quotes.

The result is the empty list @@code{()}.

@@node .error
@@subsection .error
@@cindex .error

Syntax: @@samp{(.error expr1 [...])}

Evaluate the supplied expressions and signal an error.
The expressions are typically error messages, often with the
object that caused the error.

@@node Comparisons
@@section Comparisons

Builtin macros for comparing objects.

In CGEN ``true'' is represented by @@code{#t}
and ``false'' is represented by @@code{#f}.

@@menu
* .equals::      Deep comparison
* .and::         && in C
* .or::          || in C
* .not::         ! in C
* .eq::          Shallow comparison
* .ne::          Shallow comparison
* .lt::          Less than
* .gt::          Greater than
* .le::          Less than or equal to
* .ge::          Greater than or equal to
@@end menu

@@node .equals
@@subsection .equals
@@cindex .equals

Syntax: @@samp{(.equals x y)}

Return #t if @@code{x} is equal to @@code{y}, otherwise #f.

A ``deep'' comparison is used.
I.e., if @@code{x} and @@code{y} are lists, list elements
are recursively compared

Examples:

@@smallexample
(.equals "abc" "abc") --> #t
(.equals symbol1 symbol1) --> #t
(.equals ((1 2 3) (4 5 6)) ((1 2 3) (4 5 6))) --> #t
@@end smallexample

@@node .and
@@subsection .and
@@cindex .and

Syntax: @@samp{(.and [expr1 [expr2 ...]])}

Each expression is evaluated in turn.
If an expression evaluates to false (@@code{#f}) then
evaluation stops and the result is @@code{#f}.
If all expressions evaluate to non-@@code{#f}, then
the value of the last expression is returned.

Note that this is a special form.
Just like @@code{&&} in C, evaluation of subsequent
expressions is not done once an expression is found
that evaluates to ``false''.

Examples:

@@smallexample
(.and 1 #f 2) --> #f
(.and 1 2 3) --> 3
(.and) --> #t
@@end smallexample

@@node .or
@@subsection .or
@@cindex .or

Syntax: @@samp{(.or [expr1 [expr2 ...]])}

Each expression is evaluated in turn.
If an expression evaluates to non-false (@@code{#f}) then
evaluation stops and the result is the value of the first
non-@@code{#f} expression.
If all expressions evaluate to @@code{#f}, then
the result is @@code{#f}.

Note that this is a special form.
Just like @@code{||} in C, evaluation of subsequent
expressions is not done once an expression is found
that evaluates to non-``false''.

Examples:

@@smallexample
(.or 1 2 3) --> 1
(.or #f #f #f) --> #f
(.or) --> #f
@@end smallexample

@@node .not
@@subsection .not
@@cindex .not

Syntax: @@samp{(.not expr)}

If @@code{expr} is @@code{#f} return @@code{#t}.
If @@code{expr} is non-@@code{#f} return @@code{#f}.

@@node .eq
@@subsection .eq
@@cindex .eq

Syntax: @@samp{(.eq x y)}

Return ``true'' if @@code{x} equals @@code{y}, otherwise ``false''.

Note that this does @@emph{not} do a deep comparison,
and can only be used with symbols, strings, and numbers.
Both @@code{x} and @@code{y} must be the same type.

Examples:

@@smallexample
(.eq 1 1) -> #t
(.eq 0 1) -> #f
(.eq 0 one) -> error
(.eq one one) -> #t
(.eq zero one) -> #f
(.eq "abc" "abc") -> #t
(.eq "abc" "def") -> #f
@@end smallexample

@@node .ne
@@subsection .ne
@@cindex .ne

Syntax: @@samp{(.ne x y)}

Return ``true'' if @@code{x} does not equal @@code{y}, otherwise ``false''.

Note that this does @@emph{not} do a deep comparison,
and can only be used with symbols, strings, and numbers.
Both @@code{x} and @@code{y} must be the same type.

Examples:

@@smallexample
(.ne 1 1) -> #f
(.ne 0 1) -> #t
(.ne 0 one) -> error
(.ne one one) -> #f
(.ne zero one) -> #t
(.ne "abc" "abc") -> #f
(.ne "abc" "def") -> #t
@@end smallexample

@@node .lt
@@subsection .lt
@@cindex .lt

Syntax: @@samp{(.lt x y)}

Return ``true'' if @@code{x} is less than @@code{y}, otherwise ``false''.

Both @@code{x} and @@code{y} must be numbers.

@@node .gt
@@subsection .gt
@@cindex .gt

Syntax: @@samp{(.gt x y)}

Return ``true'' if @@code{x} is greater than @@code{y}, otherwise ``false''.

Both @@code{x} and @@code{y} must be numbers.

@@node .le
@@subsection .le
@@cindex .le

Syntax: @@samp{(.le x y)}

Return ``true'' if @@code{x} is less than or equal to @@code{y},
otherwise ``false''.

Both @@code{x} and @@code{y} must be numbers.

@@node .ge
@@subsection .ge
@@cindex .ge

Syntax: @@samp{(.ge x y)}

Return ``true'' if @@code{x} is greater than or equal to @@code{y},
otherwise ``false''.

Both @@code{x} and @@code{y} must be numbers.

@@node Arithmetic functions
@@section Arithmetic functions

@@menu
* .add::      Addition
* .sub::      Subtraction
* .mul::      Multiplication
* .div::      Integer division
* .rem::      Integer remainder
@@end menu

@@node .add
@@subsection .add
@@cindex .add

Syntax: @@samp{(.add x y)}

Return @@code{x} + @@code{y}.

@@node .sub
@@subsection .sub
@@cindex .sub

Syntax: @@samp{(.sub x y)}

Return @@code{x} - @@code{y}.

@@node .mul
@@subsection .mul
@@cindex .mul

Syntax: @@samp{(.mul x y)}

Return @@code{x} * @@code{y}.

@@node .div
@@subsection .div
@@cindex .div

Syntax: @@samp{(.div x y)}

Return the quotient of @@code{x} divided by @@code{y}.

Only integer division is supported,
both @@code{x} and @@code{y} must be integers.

@@node .rem
@@subsection .rem
@@cindex .rem

Syntax: @@samp{(.rem x y)}

Return the remainder of @@code{x} divided by @@code{y}.

Only integer division is supported,
both @@code{x} and @@code{y} must be integers.

@@c Need to define and document behaviour for negative numbers.

@@node Logical functions
@@section Logical functions

Builtin macros for shifts and bitwise functions.

@@menu
* .sll::       Shift left logical
* .srl::       Shift right logical
* .sra::       Shift right arithmetic
* .bitand::    Bitwise and
* .bitor::     Bitwise or
* .bitxor::    Bitwise exclusive-or
* .bitinv::    Bitwise inversion
@@end menu

@@node .sll
@@subsection .sll
@@cindex .sll

Syntax: @@samp{(.sll x n)}

Shift @@code{x} left by @@code{n} bits.
Zeroes are shifted into the low-order bits.

@@code{n} must be a non-negative integer.

@@node .srl
@@subsection .srl
@@cindex .srl

Syntax: @@samp{(.srl x n)}

Shift @@code{x} right by @@code{n} bits.

@@code{x} @@emph{must} be a non-negative integer.
Numbers at the pmacro level have ``infinite precision'',
and shifting zeroes into the high-order bits of
infinite-precision negative numbers is undefined.

@@code{n} must be a non-negative integer.

@@node .sra
@@subsection .sra
@@cindex .sra

Syntax: @@samp{(.sra x n)}

Shift @@code{x} right arithmetically by @@code{n} bits.
The sign bit of @@code{x} is shifted into the high-order bits.

@@code{n} must be a non-negative integer.

@@node .bitand
@@subsection .bitand
@@cindex .bitand

Syntax: @@samp{(.bitand x y)}

Return the bitwise @@code{and} of @@code{x} and @@code{y}.

@@node .bitor
@@subsection .bitor
@@cindex .bitor

Syntax: @@samp{(.bitor x y)}

Return the bitwise @@code{or} of @@code{x} and @@code{y}.

@@node .bitxor
@@subsection .bitxor
@@cindex .bitxor

Syntax: @@samp{(.bitxor x y)}

Return the bitwise @@code{exclusive-or} of @@code{x} and @@code{y}.

@@node .bitinv
@@subsection .bitinv
@@cindex .bitinv

Syntax: @@samp{(.bitinv x)}

Return the bitwise @@code{inversion} of @@code{x}.
@


1.4
log
@	* doc/pmacros.texi (Symbol concatenation): Mention that .sym
	results are expanded recursively.
@
text
@d1 1
a1 1
@@c Copyright (C) 2000 Red Hat, Inc.
d15 1
a15 1
* Using preprocessor macros::
d80 1
a80 1
At the implementation level, pmacros are expand with the
d423 3
a425 3
Currently, .pmacro's don't bind the way Scheme lambda expressions do.
For example, arg2 in the second pmacro is not bound to the arg2 argument
of the first pmacro.
a431 3
One can make an argument either way.  I'm not sure what the right thing
to do here is (leave things as is, or have lexical binding like Scheme).

@


1.3
log
@	* doc/pmacros.texi: Fix .substr typo to .substring.
	Mention that .sym expansions are not further expanded.
@
text
@d147 2
a148 2
that the first character must be a letter.  The result is not further
expanded, regardless of whether there's a macro by that name.
@


1.2
log
@* Add some more concept index entries.
@
text
@d24 1
a24 1
* Getting part of a string::      The @@code{.substr} builtin
d147 2
a148 1
that the first character must be a letter.
d226 1
a226 1
@@cindex .substr
d228 1
a228 1
Extract a part of a string with @@code{.substr}.
d230 1
a230 1
Syntax: @@code{(.substr string start end)}
d240 1
a240 1
(.substr "howzitgoineh?" 2 6) --> "wzit"
@


1.1
log
@Initial revision
@
text
@d180 1
d198 1
d225 1
d367 1
d398 1
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
