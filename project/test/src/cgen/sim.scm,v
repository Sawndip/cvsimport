head	1.33;
access;
symbols
	sid-snapshot-20180601:1.33
	cgen-snapshot-20180601:1.33
	sid-snapshot-20180501:1.33
	cgen-snapshot-20180501:1.33
	sid-snapshot-20180401:1.33
	cgen-snapshot-20180401:1.33
	sid-snapshot-20180301:1.33
	cgen-snapshot-20180301:1.33
	sid-snapshot-20180201:1.33
	cgen-snapshot-20180201:1.33
	sid-snapshot-20180101:1.33
	cgen-snapshot-20180101:1.33
	sid-snapshot-20171201:1.33
	cgen-snapshot-20171201:1.33
	sid-snapshot-20171101:1.33
	cgen-snapshot-20171101:1.33
	sid-snapshot-20171001:1.33
	cgen-snapshot-20171001:1.33
	sid-snapshot-20170901:1.33
	cgen-snapshot-20170901:1.33
	sid-snapshot-20170801:1.33
	cgen-snapshot-20170801:1.33
	sid-snapshot-20170701:1.33
	cgen-snapshot-20170701:1.33
	sid-snapshot-20170601:1.33
	cgen-snapshot-20170601:1.33
	sid-snapshot-20170501:1.33
	cgen-snapshot-20170501:1.33
	sid-snapshot-20170401:1.33
	cgen-snapshot-20170401:1.33
	sid-snapshot-20170301:1.33
	cgen-snapshot-20170301:1.33
	sid-snapshot-20170201:1.33
	cgen-snapshot-20170201:1.33
	sid-snapshot-20170101:1.33
	cgen-snapshot-20170101:1.33
	sid-snapshot-20161201:1.33
	cgen-snapshot-20161201:1.33
	sid-snapshot-20161101:1.33
	cgen-snapshot-20161101:1.33
	sid-snapshot-20160901:1.33
	cgen-snapshot-20160901:1.33
	sid-snapshot-20160801:1.33
	cgen-snapshot-20160801:1.33
	sid-snapshot-20160701:1.33
	cgen-snapshot-20160701:1.33
	sid-snapshot-20160601:1.33
	cgen-snapshot-20160601:1.33
	sid-snapshot-20160501:1.32
	cgen-snapshot-20160501:1.32
	sid-snapshot-20160401:1.32
	cgen-snapshot-20160401:1.32
	sid-snapshot-20160301:1.32
	cgen-snapshot-20160301:1.32
	sid-snapshot-20160201:1.32
	cgen-snapshot-20160201:1.32
	sid-snapshot-20160101:1.32
	cgen-snapshot-20160101:1.32
	sid-snapshot-20151201:1.32
	cgen-snapshot-20151201:1.32
	sid-snapshot-20151101:1.32
	cgen-snapshot-20151101:1.32
	sid-snapshot-20151001:1.32
	cgen-snapshot-20151001:1.32
	sid-snapshot-20150901:1.32
	cgen-snapshot-20150901:1.32
	sid-snapshot-20150801:1.32
	cgen-snapshot-20150801:1.32
	sid-snapshot-20150701:1.32
	cgen-snapshot-20150701:1.32
	sid-snapshot-20150601:1.32
	cgen-snapshot-20150601:1.32
	sid-snapshot-20150501:1.32
	cgen-snapshot-20150501:1.32
	sid-snapshot-20150401:1.32
	cgen-snapshot-20150401:1.32
	sid-snapshot-20150301:1.32
	cgen-snapshot-20150301:1.32
	sid-snapshot-20150201:1.32
	cgen-snapshot-20150201:1.32
	sid-snapshot-20150101:1.32
	cgen-snapshot-20150101:1.32
	sid-snapshot-20141201:1.32
	cgen-snapshot-20141201:1.32
	sid-snapshot-20141101:1.32
	cgen-snapshot-20141101:1.32
	sid-snapshot-20141001:1.32
	cgen-snapshot-20141001:1.32
	sid-snapshot-20140901:1.32
	cgen-snapshot-20140901:1.32
	sid-snapshot-20140801:1.32
	cgen-snapshot-20140801:1.32
	sid-snapshot-20140701:1.32
	cgen-snapshot-20140701:1.32
	sid-snapshot-20140601:1.32
	cgen-snapshot-20140601:1.32
	sid-snapshot-20140501:1.32
	cgen-snapshot-20140501:1.32
	sid-snapshot-20140401:1.32
	cgen-snapshot-20140401:1.32
	sid-snapshot-20140301:1.32
	cgen-snapshot-20140301:1.32
	sid-snapshot-20140201:1.32
	cgen-snapshot-20140201:1.32
	sid-snapshot-20140101:1.32
	cgen-snapshot-20140101:1.32
	sid-snapshot-20131201:1.32
	cgen-snapshot-20131201:1.32
	sid-snapshot-20131101:1.32
	cgen-snapshot-20131101:1.32
	sid-snapshot-20131001:1.32
	cgen-snapshot-20131001:1.32
	sid-snapshot-20130901:1.32
	cgen-snapshot-20130901:1.32
	sid-snapshot-20130801:1.32
	cgen-snapshot-20130801:1.32
	sid-snapshot-20130701:1.32
	cgen-snapshot-20130701:1.32
	sid-snapshot-20130601:1.32
	cgen-snapshot-20130601:1.32
	sid-snapshot-20130501:1.32
	cgen-snapshot-20130501:1.32
	sid-snapshot-20130401:1.32
	cgen-snapshot-20130401:1.32
	sid-snapshot-20130301:1.32
	cgen-snapshot-20130301:1.32
	sid-snapshot-20130201:1.32
	cgen-snapshot-20130201:1.32
	sid-snapshot-20130101:1.32
	cgen-snapshot-20130101:1.32
	sid-snapshot-20121201:1.32
	cgen-snapshot-20121201:1.32
	sid-snapshot-20121101:1.32
	cgen-snapshot-20121101:1.32
	sid-snapshot-20121001:1.32
	cgen-snapshot-20121001:1.32
	sid-snapshot-20120901:1.32
	cgen-snapshot-20120901:1.32
	sid-snapshot-20120801:1.32
	cgen-snapshot-20120801:1.32
	sid-snapshot-20120701:1.32
	cgen-snapshot-20120701:1.32
	sid-snapshot-20120601:1.32
	cgen-snapshot-20120601:1.32
	sid-snapshot-20120501:1.32
	cgen-snapshot-20120501:1.32
	sid-snapshot-20120401:1.32
	cgen-snapshot-20120401:1.32
	sid-snapshot-20120301:1.32
	cgen-snapshot-20120301:1.32
	sid-snapshot-20120201:1.32
	cgen-snapshot-20120201:1.32
	sid-snapshot-20120101:1.32
	cgen-snapshot-20120101:1.32
	sid-snapshot-20111201:1.32
	cgen-snapshot-20111201:1.32
	sid-snapshot-20111101:1.32
	cgen-snapshot-20111101:1.32
	sid-snapshot-20111001:1.32
	cgen-snapshot-20111001:1.32
	sid-snapshot-20110901:1.32
	cgen-snapshot-20110901:1.32
	sid-snapshot-20110801:1.32
	cgen-snapshot-20110801:1.32
	sid-snapshot-20110701:1.32
	cgen-snapshot-20110701:1.32
	sid-snapshot-20110601:1.32
	cgen-snapshot-20110601:1.32
	sid-snapshot-20110501:1.32
	cgen-snapshot-20110501:1.32
	sid-snapshot-20110401:1.32
	cgen-snapshot-20110401:1.32
	sid-snapshot-20110301:1.32
	cgen-snapshot-20110301:1.32
	sid-snapshot-20110201:1.32
	cgen-snapshot-20110201:1.32
	sid-snapshot-20110101:1.32
	cgen-snapshot-20110101:1.32
	sid-snapshot-20101201:1.32
	cgen-snapshot-20101201:1.32
	sid-snapshot-20101101:1.32
	cgen-snapshot-20101101:1.32
	sid-snapshot-20101001:1.32
	cgen-snapshot-20101001:1.32
	sid-snapshot-20100901:1.32
	cgen-snapshot-20100901:1.32
	sid-snapshot-20100801:1.32
	cgen-snapshot-20100801:1.32
	sid-snapshot-20100701:1.32
	cgen-snapshot-20100701:1.32
	sid-snapshot-20100601:1.32
	cgen-snapshot-20100601:1.32
	sid-snapshot-20100501:1.32
	cgen-snapshot-20100501:1.32
	sid-snapshot-20100401:1.32
	cgen-snapshot-20100401:1.32
	sid-snapshot-20100301:1.32
	cgen-snapshot-20100301:1.32
	sid-snapshot-20100201:1.32
	cgen-snapshot-20100201:1.32
	sid-snapshot-20100101:1.31
	cgen-snapshot-20100101:1.31
	sid-snapshot-20091201:1.30
	cgen-snapshot-20091201:1.30
	sid-snapshot-20091101:1.24
	cgen-snapshot-20091101:1.24
	sid-snapshot-20091001:1.23
	cgen-snapshot-20091001:1.23
	arc-sim-20090309:1.14
	sid-snapshot-20090901:1.19
	cgen-snapshot-20090901:1.19
	sid-snapshot-20090801:1.18
	cgen-snapshot-20090801:1.18
	sid-snapshot-20090701:1.17
	cgen-snapshot-20090701:1.17
	dje-cgen-play1-branch:1.17.0.2
	dje-cgen-play1-branchpoint:1.17
	cgen-1_1-branch:1.16.0.2
	cgen-1_1-branchpoint:1.16
	sid-snapshot-20090601:1.15
	cgen-snapshot-20090601:1.15
	sid-snapshot-20090501:1.15
	cgen-snapshot-20090501:1.15
	sid-snapshot-20090401:1.15
	cgen-snapshot-20090401:1.15
	arc-insight_6_8-branch:1.14.0.2
	arc-insight_6_8-branchpoint:1.14
	sid-snapshot-20090301:1.15
	cgen-snapshot-20090301:1.15
	sid-snapshot-20090201:1.15
	cgen-snapshot-20090201:1.15
	sid-snapshot-20090101:1.15
	cgen-snapshot-20090101:1.15
	sid-snapshot-20081201:1.14
	cgen-snapshot-20081201:1.14
	sid-snapshot-20081101:1.14
	cgen-snapshot-20081101:1.14
	sid-snapshot-20081001:1.14
	cgen-snapshot-20081001:1.14
	sid-snapshot-20080901:1.14
	cgen-snapshot-20080901:1.14
	sid-snapshot-20080801:1.14
	cgen-snapshot-20080801:1.14
	sid-snapshot-20080701:1.14
	cgen-snapshot-20080701:1.14
	sid-snapshot-20080601:1.14
	cgen-snapshot-20080601:1.14
	sid-snapshot-20080501:1.14
	cgen-snapshot-20080501:1.14
	sid-snapshot-20080403:1.14
	sid-snapshot-20080401:1.14
	cgen-snapshot-20080401:1.14
	sid-snapshot-20080301:1.14
	cgen-snapshot-20080301:1.14
	sid-snapshot-20080201:1.14
	cgen-snapshot-20080201:1.14
	sid-snapshot-20080101:1.14
	cgen-snapshot-20080101:1.14
	sid-snapshot-20071201:1.14
	cgen-snapshot-20071201:1.14
	sid-snapshot-20071101:1.14
	cgen-snapshot-20071101:1.14
	sid-snapshot-20071001:1.14
	cgen-snapshot-20071001:1.14
	msnyder-fork-checkpoint-branch:1.13.0.2
	msnyder-fork-checkpoint-branchpoint:1.13
	sid-20020905-branchpoint:1.9
	sid-20020905-branch:1.9.0.4
	cagney_regbuf-20020515-branch:1.9.0.2
	cagney_regbuf-20020515-branchpoint:1.9
	cygnus_cvs_20020108_pre:1.9
	cgen-1-1-branch:1.7.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.33
date	2016.05.09.21.50.25;	author vapier;	state Exp;
branches;
next	1.32;

1.32
date	2010.01.25.00.40.29;	author devans;	state Exp;
branches;
next	1.31;

1.31
date	2009.12.16.15.33.33;	author devans;	state Exp;
branches;
next	1.30;

1.30
date	2009.11.23.09.03.01;	author devans;	state Exp;
branches;
next	1.29;

1.29
date	2009.11.23.00.59.57;	author devans;	state Exp;
branches;
next	1.28;

1.28
date	2009.11.21.09.57.58;	author devans;	state Exp;
branches;
next	1.27;

1.27
date	2009.11.05.19.23.08;	author devans;	state Exp;
branches;
next	1.26;

1.26
date	2009.11.05.16.55.33;	author devans;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.03.16.24.02;	author devans;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.26.00.56.34;	author devans;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.27.18.31.33;	author devans;	state Exp;
branches;
next	1.22;

1.22
date	2009.09.25.19.40.08;	author devans;	state Exp;
branches;
next	1.21;

1.21
date	2009.09.12.17.32.56;	author devans;	state Exp;
branches;
next	1.20;

1.20
date	2009.09.07.22.17.34;	author devans;	state Exp;
branches;
next	1.19;

1.19
date	2009.08.12.22.33.37;	author devans;	state Exp;
branches;
next	1.18;

1.18
date	2009.07.18.20.44.58;	author devans;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.14.17.09.56;	author devans;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2008.12.23.17.31.59;	author fche;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.09.18.33.04;	author brolley;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.16.05.35.48;	author devans;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.15.07.25.02;	author devans;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.20.07.58.32;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.20.02.22.22;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.07.08.23.59;	author bje;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.07.07.05.05;	author bje;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.06.12.11.09;	author bje;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.23.13.07.24;	author bje;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.13.11.21.57;	author fche;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.05.16.13.39;	author brolley;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.24.15.35.47;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.22.19.14.30;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.16.2.1
date	2009.06.24.14.57.46;	author devans;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.33
log
@cgen: sim: Updates to sim files to match gdb types

The types like MACH and MODEL have changes to SIM_MACH and SIM_MODEL
make updates to match these changes.  This way people dont have to
manually update the generated files in GDB.
@
text
@; Simulator generator support routines.
; Copyright (C) 2000, 2001, 2002, 2006, 2009 Red Hat, Inc.
; This file is part of CGEN.

; One goal of this file is to provide cover functions for all methods.
; i.e. this file fills in the missing pieces of the interface between
; the application independent part of CGEN (i.e. the code loaded by read.scm)
; and the application dependent part (i.e. sim-*.scm).
; `send' is not intended to appear in sim-*.scm.
; [It still does but that's to be fixed.]

; Specify which application.
(set! APPLICATION 'SIMULATOR)

; Cover functions for various methods.

; Return the C type of something.  This isn't always a mode.

(define (gen-type self) (send self 'gen-type))

; Return the C type of an index's value or #f if not needed (scalar).

(define (gen-index-type op sfmt)
  (let ((index-mode (send op 'get-index-mode)))
    (if index-mode
	(mode:c-type index-mode)
	#f))
)

; Misc. state info.

; Currently supported options:
; with-scache
;	generate code to use the scache
;	This is an all or nothing option, either scache is used or it's not.
; with-profile fn|sw
;	generate code to do profiling in the semantic function
;	code (fn) or in the semantic switch (sw)
; with-generic-write
;	For architectures that have parallel execution.
;	Execute the semantics by recording the results in a generic buffer,
;	and doing a post-semantics writeback pass.
; with-parallel-only
;	Only generate parallel versions of each insn.
; with-multiple-isa
;	Enable multiple-isa support (eg. arm+thumb).
; copyright fsf|redhat
;	emit an FSF or Cygnus copyright (temporary, pending decision)
; package gnusim|cygsim
;	indicate the software package

; #t if the scache is being used
(define /with-scache? #f)
(define (with-scache?) /with-scache?)

; #t if we're generating profiling code
; Each of the function and switch semantic code can have profiling.
; The options as passed are stored in /with-profile-{fn,sw}?, and
; /with-profile? is set at code generation time.
(define /with-profile-fn? #f)
(define /with-profile-sw? #f)
(define /with-profile? #f)
(define (with-profile?) /with-profile?)
(define (with-any-profile?) (or /with-profile-fn? /with-profile-sw?))

; #t if multiple isa support is enabled
(define /with-multiple-isa? #f)
(define (with-multiple-isa?) /with-multiple-isa?)

; Handle parallel execution with generic writeback pass.
(define /with-generic-write? #f)
(define (with-generic-write?) /with-generic-write?)

; Only generate parallel versions of each insn.
(define /with-parallel-only? #f)
(define (with-parallel-only?) /with-parallel-only?)

; String containing copyright text.
(define CURRENT-COPYRIGHT #f)

; String containing text defining the package we're generating code for.
(define CURRENT-PACKAGE #f)

; Initialize the options.

(define (option-init!)
  (set! /with-scache? #f)
  (set! /with-profile-fn? #f)
  (set! /with-profile-sw? #f)
  (set! /with-multiple-isa? #f)
  (set! /with-generic-write? #f)
  (set! /with-parallel-only? #f)
  (set! CURRENT-COPYRIGHT copyright-fsf)
  (set! CURRENT-PACKAGE package-gnu-simulators)
  *UNSPECIFIED*
)

; Handle an option passed in from the command line.

(define (option-set! name value)
  (case name
    ((with-scache) (set! /with-scache? #t))
    ((with-profile) (cond ((equal? value '("fn"))
			   (set! /with-profile-fn? #t))
			  ((equal? value '("sw"))
			   (set! /with-profile-sw? #t))
			  (else (error "invalid with-profile value" value))))
    ((with-multiple-isa) (set! /with-multiple-isa? #t))
    ((with-generic-write) (set! /with-generic-write? #t))
    ((with-parallel-only) (set! /with-parallel-only? #t))
    ((copyright) (cond ((equal?  value '("fsf"))
			(set! CURRENT-COPYRIGHT copyright-fsf))
		       ((equal? value '("redhat"))
			(set! CURRENT-COPYRIGHT copyright-red-hat))
		       (else (error "invalid copyright value" value))))
    ((package) (cond ((equal?  value '("gnusim"))
		      (set! CURRENT-PACKAGE package-gnu-simulators))
		     ((equal? value '("cygsim"))
		      (set! CURRENT-PACKAGE package-red-hat-simulators))
		     (else (error "invalid package value" value))))
    (else (error "unknown option" name))
    )
  *UNSPECIFIED*
)

; #t if the cpu can execute insns parallely.
; This one isn't passed on the command line, but we follow the convention
; of prefixing these things with `with-'.
; While processing operand reading (or writing), parallel execution support
; needs to be turned off, so it is up to the appropriate cgen-foo.c proc to
; set-with-parallel?! appropriately.
(define /with-parallel? #f)
(define (with-parallel?) /with-parallel?)
(define (set-with-parallel?! flag) (set! /with-parallel? flag))

; Kind of parallel support.
; If 'read, read pre-processing is done.
; If 'write, write post-processing is done.
; ??? At present we always use write post-processing, though the previous
; version used read pre-processing.  Not sure supporting both is useful
; in the long run.
(define /with-parallel-kind 'write)
; #t if parallel support is provided by read pre-processing.
(define (with-parallel-read?)
  (and /with-parallel? (eq? /with-parallel-kind 'read))
)
; #t if parallel support is provided by write post-processing.
(define (with-parallel-write?)
  (and /with-parallel? (eq? /with-parallel-kind 'write))
)

; Misc. utilities.

; All machine generated cpu elements are accessed through a cover macro
; to hide the details of the underlying implementation.

(define c-cpu-macro "CPU")

(define (gen-cpu-ref sym)
  (string-append c-cpu-macro " (" sym ")")
)


; Return C code to fetch a value from instruction memory.
; PC-VAR is the C expression containing the address of the start of the
; instruction.
; ??? Aligned/unaligned support?

(define (gen-ifetch pc-var bitoffset bitsize)
  (string-append "GETIMEM"
		 (case bitsize
		   ((8) "UQI")
		   ((16) "UHI")
		   ((32) "USI")
		   (else (error "bad bitsize argument to gen-ifetch" bitsize)))
		 " (current_cpu, "
		 pc-var " + " (number->string (quotient bitoffset 8))
		 ")")
)

; Instruction field support code.

; Return a <c-expr> object of the value of an ifield.

(define (/cxmake-ifld-val mode f)
  (if (with-scache?)
      ; ??? Perhaps a better way would be to defer evaluating the src of a
      ; set until the method processing the dest.
      (cx:make-with-atlist mode (gen-ifld-argbuf-ref f)
			   (atlist-make "" (bool-attr-make 'CACHED #t)))
      (cx:make mode (gen-extracted-ifld-value f)))
)

; Type system.

; Methods:
; gen-type - return C code representing the type
; gen-sym-defn - generate decl using the provided symbol
; gen-sym-get-macro - generate GET macro for accessing CPU elements
; gen-sym-set-macro - generate SET macro for accessing CPU elements

; Scalar type

(method-make!
 <scalar> 'gen-type
 (lambda (self) (mode:c-type (elm-get self 'mode)))
)

(method-make!
 <scalar> 'gen-sym-defn
 (lambda (self sym comment)
   (string-append
    "  /* " comment " */\n"
    "  " (send self 'gen-type) " "
    (gen-c-symbol sym) ";\n"))
)

(method-make!
 <scalar> 'gen-sym-get-macro
 (lambda (self sym comment)
   (let ((sym (gen-c-symbol sym)))
     (gen-get-macro sym "" (gen-cpu-ref sym))))
)

(method-make!
 <scalar> 'gen-sym-set-macro
 (lambda (self sym comment)
   (let ((sym (gen-c-symbol sym)))
     (gen-set-macro sym "" (gen-cpu-ref sym))))
)

(method-make! <scalar> 'gen-ref (lambda (self sym index estate) sym))

; Array type

(method-make!
 <array> 'gen-type
 (lambda (self) (mode:c-type (elm-get self 'mode)))
)

(method-make!
 <array> 'gen-sym-defn
 (lambda (self sym comment)
   (string-append
    "  /* " comment " */\n"
    "  " (send self 'gen-type) " "
    (gen-c-symbol sym)
    (gen-array-ref (elm-get self 'dimensions))
    ";\n")
   )
)

(method-make!
 <array> 'gen-sym-get-macro
 (lambda (self sym comment)
   (let ((sym (gen-c-symbol sym))
	 (rank (length (elm-get self 'dimensions))))
     (string-append
      "#define GET_" (string-upcase sym)
      "(" (string-drop 2 (gen-macro-args rank)) ") "
      (gen-cpu-ref sym) (gen-array-ref (macro-args rank)) "\n"
      )))
)

(method-make!
 <array> 'gen-sym-set-macro
 (lambda (self sym comment)
   (let ((sym (gen-c-symbol sym))
	 (rank (length (elm-get self 'dimensions))))
     (string-append
      "#define SET_" (string-upcase sym)
      "(" (string-drop 2 (gen-macro-args rank)) ", x) "
      "(" (gen-cpu-ref sym) (gen-array-ref (macro-args rank))
      " = (x))\n"
      )))
)

; Return a reference to the array.
; SYM is the name of the array.
; INDEX is either a single index object or a (possibly empty) list of objects,
; one object per dimension.

(method-make!
 <array> 'gen-ref
 (lambda (self sym index estate)
   (let ((gen-index1 (lambda (idx)
		       (string-append "["
				      (/gen-hw-index idx estate)
				      "]"))))
     (string-append sym
		    (cond ((list? index) (string-map gen-index1 index))
			  (else (gen-index1 index))))))
)

; Integers
;
;(method-make!
; <integer> 'gen-type
; (lambda (self)
;   (mode:c-type (mode-find (elm-get self 'bits)
;			   (if (has-attr? self 'UNSIGNED)
;			       'UINT 'INT)))
;   )
;)
;
;(method-make! <integer> 'gen-sym-defn (lambda (self sym comment) ""))
;(method-make! <integer> 'gen-sym-get-macro (lambda (self sym comment) ""))
;(method-make! <integer> 'gen-sym-set-macro (lambda (self sym comment) ""))

; Hardware descriptions support code.
;
; Various operations are required for each h/w object to support the various
; things the simulator will want to do with it.
;
; Methods:
; gen-type      - C type to use to record value, as a string.
;                 ??? Delete and just use get-mode?
; gen-defn      - generate a definition of the h/w element
; gen-get-macro - Generate definition of the GET access macro.
; gen-set-macro - Generate definition of the SET access macro.
; gen-write     - Same as gen-read except done on output operands
; cxmake-get    - Return a <c-expr> object to fetch the value.
; gen-set-quiet - Set the value.
;                 ??? Could just call this gen-set as there is no gen-set-trace
;                 but for consistency with the messages passed to operands
;                 we use this same.
; save-index?   - return #t if an index needs to be saved for parallel
;                 execution post-write processing
; gen-profile-decl
; gen-record-profile
; get-mode
; gen-profile-locals
; gen-sym-get-macro - Generate default GET access macro.
; gen-sym-set-macro - Generate default SET access macro.
; gen-ref       - Return a C reference to the object.

; gen-type handler, must be overridden.

(method-make!
 <hardware-base> 'gen-type
 (lambda (self) (error "gen-type not overridden:" self))
)

; Generate CPU state struct entries, must be overridden.

(method-make!
 <hardware-base> 'gen-defn
 (lambda (self) (error "gen-defn not overridden:" self))
)

(method-make! <hardware-base> 'gen-sym-decl (lambda (self sym comment) ""))

; Return a C reference to a hardware object.

(method-make! <hardware-base> 'gen-ref (lambda (self sym index estate) sym))

; Each hardware type must provide its own gen-write method.

(method-make!
 <hardware-base> 'gen-write
 (lambda (self estate index mode sfmt op access-macro)
   (error "gen-write method not overridden:" self))
)

(method-make! <hardware-base> 'gen-profile-decl (lambda (self) ""))

; Default gen-record-profile method.

(method-make!
 <hardware-base> 'gen-record-profile
 (lambda (self index sfmt estate)
   "") ; nothing to do
)

; Default cxmake-get method.
; Return a <c-expr> object of the value of SELF.
; ESTATE is the current rtl evaluator state.
; INDEX is a <hw-index> object.  It must be an ifield.
; SELECTOR is a hardware selector RTX.

(method-make!
 <hardware-base> 'cxmake-get
 (lambda (self estate mode index selector)
   (if (not (eq? 'ifield (hw-index:type index)))
       (error "not an ifield hw-index" index))
   (/cxmake-ifld-val mode (hw-index:value index)))
)

; Handle gen-get-macro/gen-set-macro.

(method-make!
 <hardware-base> 'gen-get-macro
 (lambda (self)
   "")
)

(method-make!
 <hardware-base> 'gen-set-macro
 (lambda (self)
   "")
)

; PC support

; 'gen-set-quiet helper for PC values.
; NEWVAL is a <c-expr> object of the value to be assigned.
; If OPTIONS contains #:direct, set the PC directly, bypassing semantic
; code considerations.
; ??? OPTIONS support wip.  Probably want a new form (or extend existing form)
; of rtx: that takes a variable number of named arguments.
; ??? Another way to get #:direct might be (raw-reg h-pc).

(define (/hw-gen-set-quiet-pc self estate mode index selector newval . options)
  (if (not (send self 'pc?)) (error "Not a PC:" self))
  (cond ((memq #:direct options)
	 (/hw-gen-set-quiet self estate mode index selector newval))
	((has-attr? newval 'CACHED)
	 (string-append "SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, "
			(cx:c newval)
			", vpc);\n"))
	(else
	 (string-append "SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, "
			(cx:c newval)
			", vpc);\n")))
)

(method-make! <hw-pc> 'gen-set-quiet /hw-gen-set-quiet-pc)

; Handle updates of the pc during parallel execution.
; This is done in a post-processing pass after semantic evaluation.
; SFMT is the <sformat>.
; OP is the operand.
; ACCESS-MACRO is the runtime C macro to use to fetch indices computed
; during semantic evaluation.
;
; ??? This wouldn't be necessary if gen-set-quiet were a virtual method.
; At this point I'm reluctant to willy nilly make methods virtual.

(method-make!
 <hw-pc> 'gen-write
 (lambda (self estate index mode sfmt op access-macro)
   (string-append "  "
		  (send self 'gen-set-quiet estate VOID index hw-selector-default
			(cx:make DFLT (string-append access-macro
						   " (" (gen-sym op) ")")))))
)

(method-make!
 <hw-pc> 'cxmake-skip
 (lambda (self estate yes?)
   (cx:make VOID
	    (string-append "if ("
			   yes?
			   ")\n"
			   "  SEM_SKIP_INSN (current_cpu, sem_arg, vpc);\n")))
)

; Registers.

(method-make-forward! <hw-register> 'type '(gen-type))

(method-make!
 <hw-register> 'gen-defn
 (lambda (self)
   (send (elm-get self 'type) 'gen-sym-defn (obj:name self) (obj:comment self)))
)

(method-make-forward! <hw-register> 'type '(gen-ref
					    gen-sym-get-macro
					    gen-sym-set-macro))

; For parallel instructions supported by queueing outputs for later update,
; return a boolean indicating if an index needs to be recorded.
; An example of when the index isn't needed is if the index can be determined
; during extraction.

(method-make!
 <hw-register> 'save-index?
 (lambda (self op)
   ; FIXME: Later handle case where register number is determined at runtime.
   #f)
)

; Handle updates of registers during parallel execution.
; This is done in a post-processing pass after semantic evaluation.
; SFMT is the <sformat>.
; OP is the <operand>.
; ACCESS-MACRO is the runtime C macro to use to fetch indices computed
; during semantic evaluation.
; FIXME: May need mode of OP.

(method-make!
 <hw-register> 'gen-write
 (lambda (self estate index mode sfmt op access-macro)
   ; First get a hw-index object to use during indexing.
   ; Some indices, e.g. memory addresses, are computed during semantic
   ; evaluation.  Others are computed during the extraction phase.
   (let ((index (send index 'get-write-index self sfmt op access-macro)))
     (string-append "  "
		    (send self 'gen-set-quiet estate mode index hw-selector-default
			  (cx:make DFLT (string-append access-macro
						     " (" (gen-sym op) ")"))))))
)

(method-make!
 <hw-register> 'gen-profile-decl
 (lambda (self)
   (string-append
    "  /* " (obj:comment self) " */\n"
    "  unsigned long " (gen-c-symbol (obj:name self)) ";\n"))
)

(method-make!
 <hw-register> 'gen-record-profile
 (lambda (self index sfmt estate)
   ; FIXME: Need to handle scalars.
   (/gen-hw-index-raw index estate))
)

(method-make!
 <hw-register> 'gen-get-macro
 (lambda (self)
   (let ((getter (elm-get self 'get))
	 (mode (send self 'get-mode)))
     (if getter
	 (let ((args (car getter))
	       (expr (cadr getter)))
	   (gen-get-macro2 (gen-sym self)
			   (if (hw-scalar? self) "" "index")
			   (rtl-c mode
				  #f ;; h/w is not ISA-specific
				  (if (hw-scalar? self)
				      nil
				      (list (list (car args) 'UINT "index")))
				  expr
				  #:rtl-cover-fns? #t #:macro? #t)))
	 (send self 'gen-sym-get-macro
	       (obj:name self) (obj:comment self)))))
)

(method-make!
 <hw-register> 'gen-set-macro
 (lambda (self)
   (let ((setter (elm-get self 'set))
	 (mode (send self 'get-mode)))
     (if setter
	 (let ((args (car setter))
	       (expr (cadr setter)))
	   (gen-set-macro2 (gen-sym self)
			   (if (hw-scalar? self) "" "index")
			   "x"
			   (rtl-c VOID ;; not `mode', sets have mode VOID
				  #f ;; h/w is not ISA-specific
				  (if (hw-scalar? self)
				      (list (list (car args) (hw-mode self) "(x)"))
				      (list (list (car args) 'UINT "(index)")
					    (list (cadr args) (hw-mode self) "(x)")))
				  expr
				  #:rtl-cover-fns? #t #:macro? #t)))
	 (send self 'gen-sym-set-macro
	       (obj:name self) (obj:comment self)))))
)

; Utility to build a <c-expr> object to fetch the value of a register.

(define (/hw-cxmake-get hw estate mode index selector)
  (let ((mode (if (mode:eq? 'DFLT mode)
		  (send hw 'get-mode)
		  mode))
	(getter (hw-getter hw)))
    ; If the register is accessed via a cover function/macro, do it.
    ; Otherwise fetch the value from the cached address or from the CPU struct.
    (cx:make mode
	     (cond (getter
		    (let ((scalar? (hw-scalar? hw))
			  (c-index (/gen-hw-index index estate)))
		      (string-append "GET_"
				     (string-upcase (gen-sym hw))
				     " ("
				     (if scalar? "" c-index)
				     ")")))
		   ((and (hw-cache-addr? hw) ; FIXME: redo test
			 (eq? 'ifield (hw-index:type index)))
		    (string-append
		     "* "
		     (if (with-scache?)
			 (gen-hw-index-argbuf-ref index)
			 (gen-hw-index-argbuf-name index))))
		   (else (gen-cpu-ref (send hw 'gen-ref
					    (gen-sym hw) index estate))))))
)

(method-make! <hw-register> 'cxmake-get /hw-cxmake-get)

; raw-reg: support
; ??? raw-reg: support is wip

(method-make!
 <hw-register> 'cxmake-get-raw
 (lambda (self estate mode index selector)
  (let ((mode (if (mode:eq? 'DFLT mode)
		  (send self 'get-mode)
		  mode)))
    (cx:make mode (gen-cpu-ref (send self 'gen-ref
				     (gen-sym self) index estate)))))
)

; Utilities to generate C code to assign a variable to a register.

(define (/hw-gen-set-quiet hw estate mode index selector newval)
  (let ((setter (hw-setter hw)))
    (cond (setter
	   (let ((scalar? (hw-scalar? hw))
		 (c-index (/gen-hw-index index estate)))
	     (string-append "SET_"
			    (string-upcase (gen-sym hw))
			    " ("
			    (if scalar? "" (string-append c-index ", "))
			    (cx:c newval)
			    ");\n")))
	  ((and (hw-cache-addr? hw) ; FIXME: redo test
		(eq? 'ifield (hw-index:type index)))
	   (string-append "* "
			  (if (with-scache?)
			      (gen-hw-index-argbuf-ref index)
			      (gen-hw-index-argbuf-name index))
			  " = " (cx:c newval) ";\n"))
	  (else (string-append (gen-cpu-ref (send hw 'gen-ref
						  (gen-sym hw) index estate))
			       " = " (cx:c newval) ";\n"))))
)

(method-make! <hw-register> 'gen-set-quiet /hw-gen-set-quiet)

; raw-reg: support
; ??? wip

(method-make!
 <hw-register> 'gen-set-quiet-raw
 (lambda (self estate mode index selector newval)
   (string-append (gen-cpu-ref (send self 'gen-ref
				     (gen-sym self) index estate))
		  " = " (cx:c newval) ";\n"))
)

; Return name of C access function for getting/setting a register.

(define (gen-reg-getter-fn hw prefix)
  (string-append prefix "_" (gen-sym hw) "_get")
)

(define (gen-reg-setter-fn hw prefix)
  (string-append prefix "_" (gen-sym hw) "_set")
)

; Generate decls for access fns of register HW, beginning with
; PREFIX, using C type TYPE.
; SCALAR? is #t if the register is a scalar.  Otherwise it is #f and the
; register is a bank of registers.

(define (gen-reg-access-decl hw prefix type scalar?)
  (string-append
   type " "
   (gen-reg-getter-fn hw prefix)
   " (SIM_CPU *"
   (if scalar? "" ", UINT")
   ");\n"
   "void "
   (gen-reg-setter-fn hw prefix)
   " (SIM_CPU *, "
   (if scalar? "" "UINT, ")
   type ");\n"
   )
)

; Generate defns of access fns of register HW, beginning with
; PREFIX, using C type TYPE.
; SCALAR? is #t if the register is a scalar.  Otherwise it is #f and the
; register is a bank of registers.
; GET/SET-CODE are C fragments to get/set the value.
; ??? Inlining left for later.

(define (gen-reg-access-defn hw prefix type scalar? get-code set-code)
  (string-append
   "/* Get the value of " (obj:str-name hw) ".  */\n\n"
   type "\n"
   (gen-reg-getter-fn hw prefix)
   " (SIM_CPU *current_cpu"
   (if scalar? "" ", UINT regno")
   ")\n{\n"
   get-code
   "}\n\n"
   "/* Set a value for " (obj:str-name hw) ".  */\n\n"
   "void\n"
   (gen-reg-setter-fn hw prefix)
   " (SIM_CPU *current_cpu, "
   (if scalar? "" "UINT regno, ")
   type " newval)\n"
   "{\n"
   set-code
   "}\n\n")
)

; Memory support.

(method-make!
 <hw-memory> 'cxmake-get
 (lambda (self estate mode index selector)
   (let ((mode (if (mode:eq? 'DFLT mode)
		   (hw-mode self)
		   mode))
	 (default-selector? (hw-selector-default? selector)))
     (cx:make mode
	      (string-append "GETMEM" (obj:str-name mode)
			     (if default-selector? "" "ASI")
			     " ("
			     "current_cpu, pc, "
			     (/gen-hw-index index estate)
			     (if default-selector?
				 ""
				 (string-append ", "
						(/gen-hw-selector selector)))
			     ")"))))
)

(method-make!
 <hw-memory> 'gen-set-quiet
 (lambda (self estate mode index selector newval)
   (let ((mode (if (mode:eq? 'DFLT mode)
		   (hw-mode self)
		   mode))
	 (default-selector? (hw-selector-default? selector)))
     (string-append "SETMEM" (obj:str-name mode)
		    (if default-selector? "" "ASI")
		    " ("
		    "current_cpu, pc, "
		    (/gen-hw-index index estate)
		    (if default-selector?
			""
			(string-append ", "
				       (/gen-hw-selector selector)))
		    ", " (cx:c newval) ");\n")))
)

(method-make-forward! <hw-memory> 'type '(gen-type))
(method-make! <hw-memory> 'gen-defn (lambda (self sym comment) ""))
(method-make! <hw-memory> 'gen-sym-get-macro (lambda (self sym comment) ""))
(method-make! <hw-memory> 'gen-sym-set-macro (lambda (self sym comment) ""))

; For parallel instructions supported by queueing outputs for later update,
; return the type of the index or #f if not needed.

(method-make!
 <hw-memory> 'save-index?
 (lambda (self op)
   ; In the case of the complete memory address being an immediate
   ; argument, we can return #f (later).
   AI)
)

(method-make!
 <hw-memory> 'gen-write
 (lambda (self estate index mode sfmt op access-macro)
   (let ((index (send index 'get-write-index self sfmt op access-macro)))
     (string-append "  "
		    (send self 'gen-set-quiet estate mode index
			  hw-selector-default
			  (cx:make DFLT (string-append access-macro " ("
						     (gen-sym op)
						     ")"))))))
)

; Immediates, addresses.

(method-make-forward! <hw-immediate> 'type '(gen-type))

(method-make!
 <hw-immediate> 'gen-defn
 (lambda (self)
   (send (elm-get self 'type) 'gen-sym-defn (obj:name self) (obj:comment self)))
)

(method-make-forward! <hw-immediate> 'type '(gen-sym-get-macro
					     gen-sym-set-macro))

(method-make!
 <hw-immediate> 'gen-write
 (lambda (self estate index mode sfmt op access-macro)
   (error "gen-write of <hw-immediate> shouldn't happen"))
)

;; FIXME
(method-make! <hw-address> 'gen-type (lambda (self) "ADDR"))
(method-make! <hw-address> 'gen-defn (lambda (self sym comment) ""))
(method-make! <hw-address> 'gen-sym-get-macro (lambda (self sym comment) ""))
(method-make! <hw-address> 'gen-sym-set-macro (lambda (self sym comment) ""))

; Return a <c-expr> object of the value of SELF.
; ESTATE is the current rtl evaluator state.
; INDEX is a hw-index object.  It must be an ifield.
; Needed because we record our own copy of the ifield in ARGBUF.
; SELECTOR is a hardware selector RTX.

(method-make!
 <hw-address> 'cxmake-get
 (lambda (self estate mode index selector)
   (if (not (eq? 'ifield (hw-index:type index)))
       (error "not an ifield hw-index" index))
   (if (with-scache?)
       (cx:make mode (gen-hw-index-argbuf-ref index))
       (cx:make mode (gen-hw-index-argbuf-name index))))
)

(method-make!
 <hw-address> 'gen-write
 (lambda (self estate index mode sfmt op access-macro)
   (error "gen-write of <hw-address> shouldn't happen"))
)

;; FIXME: consistency says there should be gen-defn, gen-sym-[gs]et-macro
(method-make! <hw-iaddress> 'gen-type (lambda (self) "IADDR"))

; Return a <c-expr> object of the value of SELF.
; ESTATE is the current rtl evaluator state.
; INDEX is a <hw-index> object.  It must be an ifield.
; Needed because we record our own copy of the ifield in ARGBUF,
; *and* because we want to record in the result the 'CACHED attribute
; since instruction addresses based on ifields are fixed [and thus cacheable].
; SELECTOR is a hardware selector RTX.

(method-make!
 <hw-iaddress> 'cxmake-get
 (lambda (self estate mode index selector)
   (if (not (eq? 'ifield (hw-index:type index)))
       (error "not an ifield hw-index" index))
   (if (with-scache?)
       ; ??? Perhaps a better way would be to defer evaluating the src of a
       ; set until the method processing the dest.
       (cx:make-with-atlist mode (gen-hw-index-argbuf-ref index)
			    (atlist-make "" (bool-attr-make 'CACHED #t)))
       (cx:make mode (gen-hw-index-argbuf-name index))))
)

; Hardware index support code.

; Return the index to use by the gen-write method.
; In the cases where this is needed (the index isn't known until insn
; execution time), the index is computed along with the value to be stored,
; so this is easy.

(method-make!
 <hw-index> 'get-write-index
 (lambda (self hw sfmt op access-macro)
   (if (memq (hw-index:type self) '(scalar constant enum str-expr ifield))
       self
       (let ((index-mode (send hw 'get-index-mode)))
	 (if index-mode
	     (make <hw-index> 'anonymous 'str-expr index-mode
		   (string-append access-macro " (" (/op-index-name op) ")"))
	     (hw-index-scalar)))))
)

; Return the name of the PAREXEC structure member holding a hardware index
; for operand OP.

(define (/op-index-name op)
  (string-append (gen-sym op) "_idx")
)

; Cover fn to hardware indices to generate the actual C code.
; INDEX is the hw-index object (i.e. op:index).
; The result is a string of C code.
; FIXME:wip

(define (/gen-hw-index-raw index estate)
  (let ((type (hw-index:type index))
	(mode (hw-index:mode index))
	(value (hw-index:value index)))
    (case type
      ((scalar) "")
      ; special case UINT to cut down on unnecessary verbosity.
      ; ??? May wish to handle more similarily.
      ((constant) (if (mode:eq? 'UINT mode)
		      (number->string value)
		      (string-append "((" (mode:c-type mode) ") "
				     (number->string value)
				     ")")))
      ((enum) (let ((sym (hw-index-enum-name index))
		    (obj (hw-index-enum-obj index)))
		(gen-enum-sym obj sym)))
      ((str-expr) value)
      ((rtx) (rtl-c-with-estate estate mode value))
      ((ifield) (if (= (ifld-length value) 0)
		    ""
		    (gen-extracted-ifld-value value)))
      ((operand) (cx:c (send value 'cxmake-get estate mode (op:index value)
			     (op:selector value) #f)))
      (else (error "/gen-hw-index-raw: invalid index:" index))))
)

; Same as /gen-hw-index-raw except used where speedups are possible.
; e.g. doing array index calcs at extraction time.

(define (/gen-hw-index index estate)
  (let ((type (hw-index:type index))
	(mode (hw-index:mode index))
	(value (hw-index:value index)))
    (case type
      ((scalar) "")
      ((constant) (string-append "((" (mode:c-type mode) ") "
				 (number->string value)
				 ")"))
      ((enum) (let ((sym (hw-index-enum-name index))
		    (obj (hw-index-enum-obj index)))
		(gen-enum-sym obj sym)))
      ((str-expr) value)
      ((rtx) (rtl-c-with-estate estate mode value))
      ((ifield) (if (= (ifld-length value) 0)
		    ""
		    (cx:c (/cxmake-ifld-val mode value))))
      ((operand) (cx:c (send value 'cxmake-get estate mode (op:index value)
			     (op:selector value))))
      (else (error "/gen-hw-index: invalid index:" index))))
)

; Return address where HW is stored.

(define (/gen-hw-addr hw estate index)
  (let ((setter (hw-setter hw)))
    (cond ((and (hw-cache-addr? hw) ; FIXME: redo test
		(eq? 'ifield (hw-index:type index)))
	   (if (with-scache?)
	       (gen-hw-index-argbuf-ref index)
	       (gen-hw-index-argbuf-name index)))
	  (else
	   (string-append "& "
			  (gen-cpu-ref (send hw 'gen-ref
					     (gen-sym hw) index estate))))))
)

; Return a <c-expr> object of the value of a hardware index.

(method-make!
 <hw-index> 'cxmake-get
 (lambda (self estate mode)
   (let ((mode (if (mode:eq? 'DFLT mode) (elm-get self 'mode) mode)))
     ; If MODE is VOID, abort.
     (if (mode:eq? 'VOID mode)
	 (error "hw-index:cxmake-get: result needs a mode" self))
     (cx:make (if (mode:host? mode)
		  ; FIXME: Temporary hack to generate same code as before.
		  (let ((xmode (object-copy mode)))
		    (obj-cons-attr! xmode (bool-attr-make 'FORCE-C #t))
		    xmode)
		  mode)
	      (/gen-hw-index self estate))))
)

; Hardware selector support code.

; Generate C code for SEL.

(define (/gen-hw-selector sel)
  (rtl-c INT #f nil sel)
)

; Instruction operand support code.

; Methods:
; gen-type      - Return C type to use to hold operand's value.
; gen-read      - Record an operand's value prior to parallely executing
;                 several instructions.  Not used if gen-write used.
; gen-write     - Write back an operand's value after parallely executing
;                 several instructions.  Not used if gen-read used.
; cxmake-get    - Return C code to fetch the value of an operand.
; gen-set-quiet - Return C code to set the value of an operand.
; gen-set-trace - Return C code to set the value of an operand, and print
;                 a result trace message.  ??? Ideally this will go away when
;                 trace record support is complete.

; Return the C type of an operand.
; Generally we forward things on to TYPE, but for the actual type we need to
; use the get-mode method.

;(method-make-forward! <operand> 'type '(gen-type))
(method-make!
 <operand> 'gen-type
 (lambda (self)
   ; First get the mode.
   (let ((mode (send self 'get-mode)))
     ; If it's VOID use the type's type.
     (if (mode:eq? 'DFLT mode)
	 (send (op:type self) 'gen-type)
	 (mode:c-type mode))))
)

; Extra pc operand methods.

(method-make!
 <pc> 'cxmake-get
 (lambda (self estate mode index selector)
   (let ((mode (if (mode:eq? 'DFLT mode)
		   (send self 'get-mode)
		   mode)))

     (logit 4 "<pc> cxmake-get self=" (obj:name self) " mode=" (obj:name mode) "\n")

     (if (obj-has-attr? self 'RAW)
	 (let ((hw (op:type self))
	       ;; For consistency with <operand> process index,selector similarly.
	       (index (if index index (op:index self)))
	       (selector (if selector selector (op:selector self))))
	   (send hw 'cxmake-get-raw estate mode index selector))
	 ;; The enclosing function must set `pc' to the correct value.
	 (cx:make mode "pc"))))
)

(method-make!
 <pc> 'cxmake-skip
 (lambda (self estate yes?)
   (send (op:type self) 'cxmake-skip estate
	 (rtl-c INT (obj-isa-list self) nil yes? #:rtl-cover-fns? #t)))
)

; For parallel write post-processing, we don't want to defer setting the pc.
; ??? Not sure anymore.
;(method-make!
; <pc> 'gen-set-quiet
; (lambda (self estate mode index selector newval)
;   (/op-gen-set-quiet self estate mode index selector newval)))
;(method-make!
; <pc> 'gen-set-trace
; (lambda (self estate mode index selector newval)
;   (/op-gen-set-trace self estate mode index selector newval)))

; Name of C macro to access parallel execution operand support.

(define /par-operand-macro "OPRND")

; Return C code to fetch an operand's value and save it away for the
; semantic handler.  This is used to handle parallel execution of several
; instructions where all inputs of all insns are read before any outputs are
; written.
; For operands, the word `read' is only used in this context.

(define (op:read op sfmt)
  (let ((estate (estate-make-for-rtl-c nil)))
    (send op 'gen-read estate sfmt /par-operand-macro))
)

; Return C code to write an operand's value.
; This is used to handle parallel execution of several instructions where all
; outputs are written to temporary spots first, and then a final
; post-processing pass is run to update cpu state.
; For operands, the word `write' is only used in this context.

(define (op:write op sfmt)
  (let ((estate (estate-make-for-rtl-c nil)))
    (send op 'gen-write estate sfmt /par-operand-macro))
)

; Default gen-read method.
; This is used to help support targets with parallel insns.
; Either this or gen-write (but not both) is used.

(method-make!
 <operand> 'gen-read
 (lambda (self estate sfmt access-macro)
   (string-append "  "
		  access-macro " ("
		  (gen-sym self)
		  ") = "
		  ; Pass #f for the index -> use the operand's builtin index.
		  ; Ditto for the selector.
		  (cx:c (send self 'cxmake-get estate DFLT #f #f))
		  ";\n"))
)

; Forward gen-write onto the <hardware> object.

(method-make!
 <operand> 'gen-write
 (lambda (self estate sfmt access-macro)
   (let ((write-back-code (send (op:type self) 'gen-write estate
				(op:index self) (op:mode self)
				sfmt self access-macro)))
     ; If operand is conditionally written, we have to check that first.
     ; ??? If two (or more) operands are written based on the same condition,
     ; all the tests can be collapsed together.  Not sure that's a big
     ; enough win yet.
     (if (op:cond? self)
	 (string-append "  if (written & (1 << "
			(number->string (op:num self))
			"))\n"
			"    {\n"
			"    " write-back-code
			"    }\n")
	 write-back-code)))
)

; Return <c-expr> object to get the value of an operand.
; ESTATE is the current rtl evaluator state.
; If INDEX is non-#f use it, otherwise use (op:index self).
; This special handling of #f for INDEX is *only* supported for operands
; in cxmake-get, gen-set-quiet, and gen-set-trace.
; Ditto for SELECTOR.

(method-make!
 <operand> 'cxmake-get
 (lambda (self estate mode index selector)
   (let ((mode (if (mode:eq? 'DFLT mode)
		   (send self 'get-mode)
		   mode))
	 (index (if index index (op:index self)))
	 (selector (if selector selector (op:selector self))))
     ;; If the instruction could be parallely executed with others and we're
     ;; doing read pre-processing, the operand has already been fetched, we
     ;; just have to grab the cached value.
     (let ((result
	    (cond ((obj-has-attr? self 'RAW)
		   (send (op:type self) 'cxmake-get-raw estate mode index selector))
		  ((with-parallel-read?)
		   (cx:make-with-atlist mode
					(string-append /par-operand-macro
						       " (" (gen-sym self) ")")
					nil)) ;; FIXME: want CACHED attr if present
		  ((op:getter self)
		   (let ((args (car (op:getter self)))
			 (expr (cadr (op:getter self))))
		     (rtl-c-expr mode
				 (obj-isa-list self)
				 (if (= (length args) 0)
				     nil
				     (list (list (car args) 'UINT index)))
				 expr
				 #:rtl-cover-fns? #t)))
		  (else
		   (send (op:type self) 'cxmake-get estate mode index selector)))))

       (logit 4 "<operand> cxmake-get self=" (obj:name self) " mode=" (obj:name mode)
	      " index=" (obj:name index) " selector=" selector "\n")

       result)))
)

; Utilities to implement gen-set-quiet/gen-set-trace.

(define (/op-gen-set-quiet op estate mode index selector newval)
  (send (op:type op) 'gen-set-quiet estate mode index selector newval)
)

; Return C code to call the appropriate queued-write handler.
; ??? wip

(define (/op-gen-queued-write op estate mode index selector newval)
  (let* ((hw (op:type op))
	 (setter (hw-setter hw))
	 (sem-mode (mode:sem-mode mode)))
    (string-append
     "    "
     "sim_queue_"
     ; FIXME: clean up (pc? op) vs (memory? hw)
     ; FIXME: (send 'pc?) is a temporary hack, (pc? op) didn't work
     (cond ((send hw 'pc?)
	    (string-append
	     (if setter
		 "fn_"
		 "")
	     "pc"))
	   (else
	    (string-append
	     (cond ((memory? hw)
		    "mem_")
		   ((hw-scalar? hw)
		    "scalar_")
		   (else ""))
	     (if setter
		 "fn_"
		 "")
	     (string-downcase (symbol->string (if sem-mode
						  (mode-real-name sem-mode)
						  (mode-real-name mode)))))))
     "_write (current_cpu"
     ; ??? May need to include h/w id some day.
     (if setter
	 (string-append ", " (gen-reg-setter-fn hw "@@cpu@@"))
	 "")
     (cond ((hw-scalar? hw)
	    "")
	   (setter
	    (string-append ", " (/gen-hw-index index estate)))
	   ((memory? hw)
	    (string-append ", " (/gen-hw-index index estate)))
	   (else
	    (string-append ", " (/gen-hw-addr (op:type op) estate index))))
     ", "
     newval
     ");\n"))
)

(define (/op-gen-set-quiet-parallel op estate mode index selector newval)
  (if (with-generic-write?)
      (/op-gen-queued-write op estate mode index selector (cx:c newval))
      (string-append
       (if (op-save-index? op)
	   (string-append "    "
			  /par-operand-macro " (" (/op-index-name op) ")"
			  " = " (/gen-hw-index index estate) ";\n")
	   "")
       "    "
       /par-operand-macro " (" (gen-sym op) ")"
       " = " (cx:c newval) ";\n"))
)

(define /operand-number-elaboration-written? #f)

;; Return code to update `written'.

(define (/op-gen-written-update op)
  (if (op:cond? op)
      ;; FIXME: we don't yet handle a large number of operands
      (if (< (op:num op) 32)
	  (string-append "    written |= (1 << "
			 (number->string (op:num op))
			 ");\n")
	  (begin
	    ;; FIXME: This creates broken simulators if with-parallel-write?.
;;	    (message (if (with-parallel-write?) "Error: " "Warning: ")
;;		     (obj:name op)
;;		     " operand number " (op:num op)
;;		     " is too large (>= 32)\n")
	    (if (not /operand-number-elaboration-written?)
		(begin
		  (message "This is a current internal cgen limitation.\n")
		  (if (not (with-parallel-write?))
		      (message "The only effect is a loss in profiling capability.\n"))
		  (set! /operand-number-elaboration-written? #t)))
	    ""))
      "")
)

(define (/op-gen-set-trace op estate mode index selector newval)
  (string-append
   "  {\n"
   "    " (mode:c-type mode) " opval = " (cx:c newval) ";\n"
   ; Dispatch to setter code if appropriate
   "    "
   (if (op:setter op)
       (let ((args (car (op:setter op)))
	     (expr (cadr (op:setter op))))
	 (rtl-c VOID
		(obj-isa-list op)
		(if (= (length args) 0)
		    (list (list 'newval mode "opval"))
		    (list (list (car args) 'UINT index)
			  (list 'newval mode "opval")))
		expr
		#:rtl-cover-fns? #t))
       ;else
       (send (op:type op) 'gen-set-quiet estate mode index selector
	     (cx:make-with-atlist mode "opval" (cx:atlist newval))))
   (/op-gen-written-update op)
; TRACE_RESULT_<MODE> (cpu, abuf, hwnum, opnum, value);
; For each insn record array of operand numbers [or indices into
; operand instance table].
; Could just scan the operand table for the operand or hardware number,
; assuming the operand number is stored in `op'.
   "    CGEN_TRACE_RESULT (current_cpu, abuf"
   ", " (send op 'gen-pretty-name mode)
   ", " (mode:printf-type mode)
   ", opval);\n"
   "  }\n")
)

(define (/op-gen-set-trace-parallel op estate mode index selector newval)
  (string-append
   "  {\n"
   "    " (mode:c-type mode) " opval = " (cx:c newval) ";\n"
   (if (with-generic-write?)
       (/op-gen-queued-write op estate mode index selector "opval")
       (string-append
	(if (op-save-index? op)
	    (string-append "    "
			   /par-operand-macro " (" (/op-index-name op) ")"
			   " = " (/gen-hw-index index estate) ";\n")
	    "")
	"    " /par-operand-macro " (" (gen-sym op) ")"
	" = opval;\n"))
   (/op-gen-written-update op)
; TRACE_RESULT_<MODE> (cpu, abuf, hwnum, opnum, value);
; For each insn record array of operand numbers [or indices into
; operand instance table].
; Could just scan the operand table for the operand or hardware number,
; assuming the operand number is stored in `op'.
   "    CGEN_TRACE_RESULT (current_cpu, abuf"
   ", " (send op 'gen-pretty-name mode)
   ", " (mode:printf-type mode)
   ", opval);\n"
   "  }\n")
)

; Return C code to set the value of an operand.
; NEWVAL is a <c-expr> object of the value to store.
; If INDEX is non-#f use it, otherwise use (op:index self).
; This special handling of #f for INDEX is *only* supported for operands
; in cxmake-get, gen-set-quiet, and gen-set-trace.
; Ditto for SELECTOR.

(method-make!
 <operand> 'gen-set-quiet
 (lambda (self estate mode index selector newval)
   (let ((mode (if (mode:eq? 'DFLT mode)
		   (send self 'get-mode)
		   mode))
	 (index (if index index (op:index self)))
	 (selector (if selector selector (op:selector self))))
     ; ??? raw-reg: support wip
     (cond ((obj-has-attr? self 'RAW)
	    (send (op:type self) 'gen-set-quiet-raw estate mode index selector newval))
	   ((with-parallel-write?)
	    (/op-gen-set-quiet-parallel self estate mode index selector newval))
	   (else
	    (/op-gen-set-quiet self estate mode index selector newval)))))
)

; Return C code to set the value of an operand and print TRACE_RESULT message.
; NEWVAL is a <c-expr> object of the value to store.
; If INDEX is non-#f use it, otherwise use (op:index self).
; This special handling of #f for INDEX is *only* supported for operands
; in cxmake-get, gen-set-quiet, and gen-set-trace.
; Ditto for SELECTOR.

(method-make!
 <operand> 'gen-set-trace
 (lambda (self estate mode index selector newval)
   (let ((mode (if (mode:eq? 'DFLT mode)
		   (send self 'get-mode)
		   mode))
	 (index (if index index (op:index self)))
	 (selector (if selector selector (op:selector self))))
     ; ??? raw-reg: support wip
     (cond ((obj-has-attr? self 'RAW)
	    (send (op:type self) 'gen-set-quiet-raw estate mode index selector newval))
	   ((with-parallel-write?)
	    (/op-gen-set-trace-parallel self estate mode index selector newval))
	   (else
	    (/op-gen-set-trace self estate mode index selector newval)))))
)

; Define and undefine C macros to tuck away details of instruction format used
; in the parallel execution functions.  See gen-define-field-macro for a
; similar thing done for extraction/semantic functions.

(define (gen-define-parallel-operand-macro sfmt)
  (string-append "#define " /par-operand-macro "(f) "
		 "par_exec->operands."
		 (gen-sym sfmt)
		 ".f\n")
)

(define (gen-undef-parallel-operand-macro sfmt)
  (string-append "#undef " /par-operand-macro "\n")
)

; Operand profiling and parallel execution support.

(method-make!
 <operand> 'save-index?
 (lambda (self) (send (op:type self) 'save-index? self))
)

; Return boolean indicating if operand OP needs its index saved
; (for parallel write post-processing support).

(define (op-save-index? op)
  (send op 'save-index?)
)

; Return C code to record profile data for modeling use.
; In the case of a register, this is usually the register's number.
; This shouldn't be called in the case of a scalar, the code should be
; smart enough to know there is no need.

(define (op:record-profile op sfmt out?)
  (let ((estate (estate-make-for-rtl-c nil)))
    (send op 'gen-record-profile sfmt out? estate))
)

; Return C code to record the data needed for profiling operand SELF.
; This is done during extraction.

(method-make!
 <operand> 'gen-record-profile
 (lambda (self sfmt out? estate)
   (if (hw-scalar? (op:type self))
       ""
       (string-append "      "
		      (gen-argbuf-ref (send self 'sbuf-profile-sym out?))
		      " = "
		      (send (op:type self) 'gen-record-profile
			    (op:index self) sfmt estate)
		      ";\n")))
)

; Return C code to track profiling of operand SELF.
; This is usually called by the x-after handler.

(method-make!
 <operand> 'gen-profile-code
 (lambda (self insn out?)
   (string-append "  "
		  "@@cpu@@_model_mark_"
		  (if out? "set_" "get_")
		  (gen-sym (op:type self))
		  " (current_cpu"
		  (if (hw-scalar? (op:type self))
		      ""
		      (string-append ", "
				     (gen-argbuf-ref
				      (send self 'sbuf-profile-sym out?))))
		  ");\n"))
)

; CPU, mach, model support.

; Return the declaration of the cpu/insn enum.

(define (gen-cpu-insn-enum-decl cpu insn-list)
  (gen-enum-decl "@@prefix@@_insn_type"
		 "instructions in cpu family @@cpu@@"
		 "@@PREFIX@@_INSN_"
		 (append! (map (lambda (i)
				 (cons (obj:name i)
				       (cons '-
					     (atlist-attrs (obj-atlist i)))))
			       insn-list)
			  (if (with-parallel?)
			      (apply append!
				     (map (lambda (i)
					    (list
					     (cons (symbol-append 'par- (obj:name i))
						   (cons '-
							 (atlist-attrs (obj-atlist i))))
					     (cons (symbol-append 'write- (obj:name i))
						   (cons '-
							 (atlist-attrs (obj-atlist i))))))
					  (parallel-insns insn-list)))
			      nil)
			  (list '(-max))))
)

; Return the enum of INSN in cpu family CPU.
; In addition to CGEN_INSN_TYPE, an enum is created for each insn in each
; cpu family.  This collapses the insn enum space for each cpu to increase
; cache efficiently (since the IDESC table is similarily collapsed).

(define (gen-cpu-insn-enum cpu insn)
  (string-upcase (string-append "@@PREFIX@@_INSN_" (gen-sym insn)))
)

; Return C code to declare the machine data.

(define (/gen-mach-decls)
  (string-append
   (string-map (lambda (mach)
		 (gen-obj-sanitize mach
				   (string-append "extern const SIM_MACH "
						  (gen-sym mach)
						  "_mach;\n")))
	       (current-mach-list))
   "\n")
)

; Return C code to define the machine data.

(define (/gen-mach-data)
  (string-append
   "const SIM_MACH *sim_machs[] =\n{\n"
   (string-map (lambda (mach)
		 (gen-obj-sanitize
		  mach
		  (string-append "#ifdef " (gen-have-cpu (mach-cpu mach)) "\n"
				 "  & " (gen-sym mach) "_mach,\n"
				 "#endif\n")))
	       (current-mach-list))
   "  0\n"
   "};\n\n"
   )
)

; Return C declarations of cpu model support stuff.
; ??? This goes in arch.h but a better place is each cpu.h.

(define (/gen-arch-model-decls)
  (string-append
   (gen-enum-decl 'model_type "model types"
		  "MODEL_"
		  (append (map (lambda (model)
				 (cons (obj:name model)
				       (cons '-
					     (atlist-attrs (obj-atlist model)))))
			       (current-model-list))
			  '((max))))
   "#define MAX_MODELS ((int) MODEL_MAX)\n\n"
   (gen-enum-decl 'unit_type "unit types"
		  "UNIT_"
		  (cons '(none)
			(append
			 ; "apply append" squeezes out nils.
			 (apply append
				; create <model_name>-<unit-name> for each unit
				(map (lambda (model)
				       (let ((units (model:units model)))
					 (if (null? units)
					     nil
					     (map (lambda (unit)
						    (cons (symbol-append (obj:name model) '-
									 (obj:name unit))
							  (cons '- (atlist-attrs (obj-atlist model)))))
						  units))))
				     (current-model-list)))
			 '((max)))))
   ; FIXME: revisit MAX_UNITS
   "#define MAX_UNITS ("
   (number->string
    (apply max
	   (map (lambda (lengths) (apply max lengths))
		(map (lambda (insn)
		       (let ((timing (insn-timing insn)))
			 (if (null? timing)
			     '(1)
			     (map (lambda (insn-timing)
				    (if (null? (cdr insn-timing))
					'1
					(length (timing:units (cdr insn-timing)))))
				  timing))))
		     (current-insn-list)))))
   ")\n\n"
   )
)

; Function units.

(method-make! <unit> 'gen-decl (lambda (self) ""))

; Lookup operand named OP-NAME in INSN.
; Returns #f if OP-NAME is not an operand of INSN.
; IN-OUT is 'in to request an input operand, 'out to request an output operand,
; and 'in-out to request either (though if an operand is used for input and
; output then the input version is returned).
; FIXME: Move elsewhere.

(define (insn-op-lookup op-name insn in-out)
  (letrec ((lookup (lambda (op-list)
		     (cond ((null? op-list) #f)
			   ((eq? op-name (op:sem-name (car op-list))) (car op-list))
			   (else (lookup (cdr op-list)))))))
    (case in-out
      ((in) (lookup (sfmt-in-ops (insn-sfmt insn))))
      ((out) (lookup (sfmt-out-ops (insn-sfmt insn))))
      ((in-out) (or (lookup (sfmt-in-ops (insn-sfmt insn)))
		    (lookup (sfmt-out-ops (insn-sfmt insn)))))
      (else (error "insn-op-lookup: bad arg:" in-out))))
)

; Return C code to profile a unit's usage.
; UNIT-NUM is number of the unit in INSN.
; OVERRIDES is a list of (name value) pairs, where
; - NAME is a spec name, one of cycles, pred, in, out.
;   The only ones we're concerned with are in,out.  They map operand names
;   as they appear in the semantic code to operand names as they appear in
;   the function unit spec.
; - VALUE is the operand to NAME.  For in,out it is (NAME VALUE) where
;   - NAME is the name of an input/output arg of the unit.
;   - VALUE is the name of the operand as it appears in semantic code.
;
; ??? This is a big sucker, though half of it is just the definitions
; of utility fns.

(method-make!
 <unit> 'gen-profile-code
 (lambda (self unit-num insn overrides cycles-var-name)
   (let (
	 (inputs (unit:inputs self))
	 (outputs (unit:outputs self))

	  ; Return C code to initialize UNIT-REFERENCED-VAR to be a bit mask
	  ; of operands of UNIT that were read/written by INSN.
	  ; INSN-REFERENCED-VAR is a bitmask of operands read/written by INSN.
	  ; All we have to do is map INSN-REFERENCED-VAR to
	  ; UNIT-REFERENCED-VAR.
	  ; ??? For now we assume all input operands are read.
	  (gen-ref-arg (lambda (arg num in-out)
			 (let* ((op-name (assq-ref overrides (car arg)))
				(op (insn-op-lookup (if op-name
							(car op-name)
							(car arg))
						    insn in-out))
				(insn-referenced-var "insn_referenced")
				(unit-referenced-var "referenced"))
			   (if op
			       (if (op:cond? op)
				   (string-append "    "
						  "if ("
						  insn-referenced-var
						  " & (1 << "
						  (number->string (op:num op))
						  ")) "
						  unit-referenced-var
						  " |= 1 << "
						  (number->string num)
						  ";\n")
				   (string-append "    "
						  unit-referenced-var
						  " |= 1 << "
						  (number->string num)
						  ";\n"))
			       ""))))

	  ; Initialize unit argument ARG.
	  ; OUT? is #f for input args, #t for output args.
	  (gen-arg-init (lambda (arg out?)
			  (if (or
			       ; Ignore scalars.
			       (null? (cdr arg))
			       ; Ignore remapped arg, handled elsewhere.
			       (assq (car arg) overrides)
			       ; Ignore operands not in INSN.
			       (not (insn-op-lookup (car arg) insn
						    (if out? 'out 'in))))
			      ""
			      (let ((sym (gen-profile-sym (gen-c-symbol (car arg))
							   out?)))
				(string-append "    "
					       sym
					       " = "
					       (gen-argbuf-ref sym)
					       ";\n")))))

	  ; Return C code to declare variable to hold unit argument ARG.
	  ; OUT? is #f for input args, #t for output args.
	  (gen-arg-decl (lambda (arg out?)
			  (if (null? (cdr arg)) ; ignore scalars
			      ""
			      (string-append "    "
					     (mode:c-type (mode:lookup (cadr arg)))
					     " "
					     (gen-profile-sym (gen-c-symbol (car arg))
							      out?)
					     " = "
					     (if (null? (cddr arg))
						 "0"
						 (number->string (caddr arg)))
					     ";\n"))))

	  ; Return C code to pass unit argument ARG to the handler.
	  ; OUT? is #f for input args, #t for output args.
	  (gen-arg-arg (lambda (arg out?)
			 (if (null? (cdr arg)) ; ignore scalars
			     ""
			     (string-append ", "
					    (gen-profile-sym (gen-c-symbol (car arg))
							     out?)))))
	  )

     (string-list
      "  {\n"
      "    int referenced = 0;\n"
      "    int UNUSED insn_referenced = abuf->written;\n"
      ; Declare variables to hold unit arguments.
      (string-map (lambda (arg) (gen-arg-decl arg #f))
		  inputs)
      (string-map (lambda (arg) (gen-arg-decl arg #t))
		  outputs)
      ; Initialize 'em, being careful not to initialize an operand that
      ; has an override.
      (let (; Make a list of names of in/out overrides.
	    (in-overrides (find-apply cadr
				      (lambda (elm) (eq? (car elm) 'in))
				      overrides))
	    (out-overrides (find-apply cadr
				      (lambda (elm) (eq? (car elm) 'out))
				      overrides)))
	(string-list
	 (string-map (lambda (arg)
		       (if (memq (car arg) in-overrides)
			   ""
			   (gen-arg-init arg #f)))
		     inputs)
	 (string-map (lambda (arg)
		       (if (memq (car arg) out-overrides)
			   ""
			   (gen-arg-init arg #t)))
		     outputs)))
      (string-map (lambda (arg)
		    (case (car arg)
		      ((pred) "")
		      ((cycles) "")
		      ((in)
		       (if (caddr arg)
			   (string-append "    "
					  (gen-profile-sym (gen-c-symbol (cadr arg)) #f)
					  " = "
					  (gen-argbuf-ref
					   (gen-profile-sym (gen-c-symbol (caddr arg)) #f))
					  ";\n")
			   ""))
		      ((out)
		       (if (caddr arg)
			   (string-append "    "
					  (gen-profile-sym (gen-c-symbol (cadr arg)) #t)
					  " = "
					  (gen-argbuf-ref
					   (gen-profile-sym (gen-c-symbol (caddr arg)) #t))
					  ";\n")
			   ""))
		      (else
		       (parse-error (make-prefix-context "insn function unit spec")
				    "invalid spec" arg))))
		  overrides)
      ; Create bitmask indicating which args were referenced.
      (string-map (lambda (arg num) (gen-ref-arg arg num 'in))
		  inputs
		  (iota (length inputs)))
      (string-map (lambda (arg num) (gen-ref-arg arg num 'out))
		  outputs
		  (iota (length outputs)
			(length inputs)))
      ; Emit the call to the handler.
      "    " cycles-var-name " += "
      (gen-model-unit-fn-name (unit:model self) self)
      " (current_cpu, idesc"
      ", " (number->string unit-num)
      ", referenced"
      (string-map (lambda (arg) (gen-arg-arg arg #f))
		  inputs)
      (string-map (lambda (arg) (gen-arg-arg arg #t))
		  outputs)
      ");\n"
      "  }\n"
      )))
)

; Return C code to profile an insn-specific unit's usage.
; UNIT-NUM is number of the unit in INSN.

(method-make!
 <iunit> 'gen-profile-code
 (lambda (self unit-num insn cycles-var-name)
   (let ((args (iunit:args self))
	 (unit (iunit:unit self)))
     (send unit 'gen-profile-code unit-num insn args cycles-var-name)))
)

; ARGBUF generation.
; ARGBUF support is put in cpuall.h, which doesn't depend on sim-cpu.scm,
; so this support is here.

; Utility of /gen-argbuf-fields-union to generate the definition for
; <sformat-abuf> SBUF.

(define (/gen-argbuf-elm sbuf)
  (logit 2 "Processing sbuf format " (obj:name sbuf) " ...\n")
  (string-list
   "  struct { /* " (obj:comment sbuf) " */\n"
   (let ((elms (sbuf-elms sbuf)))
     (if (null? elms)
	 "    int empty;\n"
	 (string-list-map (lambda (elm)
			    (string-append "    "
					   (cadr elm)
					   " "
					   (car elm)
					   ";\n"))
			  (sbuf-elms sbuf))))
   "  } " (gen-sym sbuf) ";\n")
)

; Utility of gen-argbuf-type to generate the union of extracted ifields.

(define (/gen-argbuf-fields-union)
  (string-list
   "\
/* Instruction argument buffer.  */

union sem_fields {\n"
   (string-list-map /gen-argbuf-elm (current-sbuf-list))
   "\
#if WITH_SCACHE_PBB
  /* Writeback handler.  */
  struct {
    /* Pointer to argbuf entry for insn whose results need writing back.  */
    const struct argbuf *abuf;
  } write;
  /* x-before handler */
  struct {
    /*const SCACHE *insns[MAX_PARALLEL_INSNS];*/
    int first_p;
  } before;
  /* x-after handler */
  struct {
    int empty;
  } after;
  /* This entry is used to terminate each pbb.  */
  struct {
    /* Number of insns in pbb.  */
    int insn_count;
    /* Next pbb to execute.  */
    SCACHE *next;
    SCACHE *branch_target;
  } chain;
#endif
};\n\n"
   )
)

; Generate the definition of the structure that records arguments.
; This is a union of structures with one structure for each insn format.
; It also includes hardware profiling information and miscellaneous
; administrivia.
; CPU-DATA? is #t if data for the currently selected cpu is to be included.

(define (gen-argbuf-type cpu-data?)
  (logit 2 "Generating ARGBUF type ...\n")
  (string-list
   (if (and cpu-data? (with-scache?))
       (/gen-argbuf-fields-union)
       "")
   (if cpu-data? "" "#ifndef WANT_CPU\n")
   "\
/* The ARGBUF struct.  */
struct argbuf {
  /* These are the baseclass definitions.  */
  IADDR addr;
  const IDESC *idesc;
  char trace_p;
  char profile_p;
  /* ??? Temporary hack for skip insns.  */
  char skip_count;
  char unused;
  /* cpu specific data follows */\n"
   (if cpu-data?
       (if (with-scache?)
	    "\
  union sem semantic;
  int written;
  union sem_fields fields;\n"
	    "\
  CGEN_INSN_WORD insn;
  int written;\n")
       "")
   "};\n"
   (if cpu-data? "" "#endif\n")
   "\n"
   )
)

; Generate the definition of the structure that records a cached insn.
; This is cpu family specific (member `argbuf' is) so it is machine generated.
; CPU-DATA? is #t if data for the currently selected cpu is to be included.

(define (gen-scache-type cpu-data?)
  (logit 2 "Generating SCACHE type ...\n")
  (string-append
   (if cpu-data? "" "#ifndef WANT_CPU\n")
   "\
/* A cached insn.

   ??? SCACHE used to contain more than just argbuf.  We could delete the
   type entirely and always just use ARGBUF, but for future concerns and as
   a level of abstraction it is left in.  */

struct scache {
  struct argbuf argbuf;\n"
   (if (with-generic-write?) "\
  int first_insn_p;
  int last_insn_p;\n" "")
   "};\n"
   (if cpu-data? "" "#endif\n")
   "\n"
  )
)

; Mode support.

; Generate a table of mode data.
; For now all we need is the names.

(define (gen-mode-defs)
  (string-append
   "const char *mode_names[] = {\n"
   (string-map (lambda (m)
		 (string-append "  \"" (string-upcase (obj:str-name m)) "\",\n"))
	       ; We don't treat aliases as being different from the real
	       ; mode here, so ignore them.
	       (mode-list-non-alias-values))
   "};\n\n"
   )
)

; Insn profiling support.

; Generate declarations for local variables needed for modelling code.

(method-make!
 <insn> 'gen-profile-locals
 (lambda (self model)
;   (let ((cti? (or (has-attr? self 'UNCOND-CTI)
;		   (has-attr? self 'COND-CTI))))
;     (string-append
;      (if cti? "  int UNUSED taken_p = 0;\n" "")
;      ))
   "")
)

; Generate C code to profile INSN.

(method-make!
 <insn> 'gen-profile-code
 (lambda (self model cycles-var-name)
   (string-list
    (let ((timing (assq-ref (insn-timing self) (obj:name model))))
      (if timing
	  (string-list-map (lambda (iunit unit-num)
			     (send iunit 'gen-profile-code unit-num self cycles-var-name))
			   (timing:units timing)
			   (iota (length (timing:units timing))))
	  (send (model-default-unit model) 'gen-profile-code 0 self nil cycles-var-name)))
    ))
)

; .cpu file loading support

; Only run sim-analyze-insns! once.
(define /sim-insns-analyzed? #f)

; List of computed sformat argument buffers.
(define /sim-sformat-abuf-list #f)
(define (current-sbuf-list) /sim-sformat-abuf-list)

; Called before/after the .cpu file has been read in.

(define (sim-init!)
  (set! /sim-insns-analyzed? #f)
  (set! /sim-sformat-abuf-list #f)
  *UNSPECIFIED*
)

;; Subroutine of /create-virtual-insns!.
;; Add virtual insn INSN to the database.
;; We put virtual insns ahead of normal insns because they're kind of special,
;; and it helps to see them first in lists.
;; ORDINAL is a used to place the insn ahead of normal insns;
;; it is a pair so we can do the update for the next virtual insn here.

(define (/virtual-insn-add! ordinal insn)
  (obj-set-ordinal! insn (cdr ordinal))
  (current-insn-add! insn)
  (set-cdr! ordinal (- (cdr ordinal) 1))
)

; Create the virtual insns.

(define (/create-virtual-insns!)
  (let ((all (all-isas-attr-value))
	(context (make-prefix-context "virtual insns"))
	;; Record as a pair so /virtual-insn-add! can update it.
	(ordinal (cons #f -1)))

    (/virtual-insn-add!
     ordinal
     (insn-read context
		'(name x-begin)
		'(comment "pbb begin handler")
		`(attrs VIRTUAL PBB (ISA ,@@all))
		'(syntax "--begin--")
		'(semantics (c-code VOID "\
  {
#if WITH_SCACHE_PBB_@@PREFIX@@
#if defined DEFINE_SWITCH || defined FAST_P
    /* In the switch case FAST_P is a constant, allowing several optimizations
       in any called inline functions.  */
    vpc = @@prefix@@_pbb_begin (current_cpu, FAST_P);
#else
#if 0 /* cgen engine can't handle dynamic fast/full switching yet.  */
    vpc = @@prefix@@_pbb_begin (current_cpu, STATE_RUN_FAST_P (CPU_STATE (current_cpu)));
#else
    vpc = @@prefix@@_pbb_begin (current_cpu, 0);
#endif
#endif
#endif
  }
"))
		))

    (/virtual-insn-add!
     ordinal
     (insn-read context
		'(name x-chain)
		'(comment "pbb chain handler")
		`(attrs VIRTUAL PBB (ISA ,@@all))
		'(syntax "--chain--")
		'(semantics (c-code VOID "\
  {
#if WITH_SCACHE_PBB_@@PREFIX@@
    vpc = @@prefix@@_pbb_chain (current_cpu, sem_arg);
#ifdef DEFINE_SWITCH
    BREAK (sem);
#endif
#endif
  }
"))
		))

    (/virtual-insn-add!
     ordinal
     (insn-read context
		'(name x-cti-chain)
		'(comment "pbb cti-chain handler")
		`(attrs VIRTUAL PBB (ISA ,@@all))
		'(syntax "--cti-chain--")
		'(semantics (c-code VOID "\
  {
#if WITH_SCACHE_PBB_@@PREFIX@@
#ifdef DEFINE_SWITCH
    vpc = @@prefix@@_pbb_cti_chain (current_cpu, sem_arg,
			       pbb_br_type, pbb_br_npc);
    BREAK (sem);
#else
    /* FIXME: Allow provision of explicit ifmt spec in insn spec.  */
    vpc = @@prefix@@_pbb_cti_chain (current_cpu, sem_arg,
			       CPU_PBB_BR_TYPE (current_cpu),
			       CPU_PBB_BR_NPC (current_cpu));
#endif
#endif
  }
"))
		))

    (/virtual-insn-add!
     ordinal
     (insn-read context
		'(name x-before)
		'(comment "pbb begin handler")
		`(attrs VIRTUAL PBB (ISA ,@@all))
		'(syntax "--before--")
		'(semantics (c-code VOID "\
  {
#if WITH_SCACHE_PBB_@@PREFIX@@
    @@prefix@@_pbb_before (current_cpu, sem_arg);
#endif
  }
"))
		))

    (/virtual-insn-add!
     ordinal
     (insn-read context
		'(name x-after)
		'(comment "pbb after handler")
		`(attrs VIRTUAL PBB (ISA ,@@all))
		'(syntax "--after--")
		'(semantics (c-code VOID "\
  {
#if WITH_SCACHE_PBB_@@PREFIX@@
    @@prefix@@_pbb_after (current_cpu, sem_arg);
#endif
  }
"))
		))

    (/virtual-insn-add!
     ordinal
     (insn-read context
		'(name x-invalid)
		'(comment "invalid insn handler")
		`(attrs VIRTUAL (ISA ,@@all))
		'(syntax "--invalid--")
		(list 'semantics (list 'c-code 'VOID (string-append "\
  {
    /* Update the recorded pc in the cpu state struct.
       Only necessary for WITH_SCACHE case, but to avoid the
       conditional compilation ....  */
    SET_H_PC (pc);
    /* Virtual insns have zero size.  Overwrite vpc with address of next insn
       using the default-insn-bitsize spec.  When executing insns in parallel
       we may want to queue the fault and continue execution.  */
    vpc = SEM_NEXT_VPC (sem_arg, pc, " (number->string (bits->bytes (state-default-insn-bitsize))) ");
    vpc = sim_engine_invalid_insn (current_cpu, pc, vpc);
  }
")))
		))
    )
)

(define (sim-finish!)
  ; Add begin,chain,before,after,invalid handlers if not provided.
  ; The code generators should first look for x-foo-@@prefix@@, then for x-foo.
  ; ??? This is good enough for the first pass.  Will eventually need to use
  ; less C and more RTL.
  (/create-virtual-insns!)

  *UNSPECIFIED*
)

; Called after file is read in and global error checks are done
; to initialize tables.

(define (sim-analyze!)
  *UNSPECIFIED*
)

; Scan insns, analyzing semantics and computing instruction formats.
; 'twould be nice to do this in sim-analyze! but it doesn't know whether this
; needs to be done or not (which is determined by what files are being
; generated).  Since this is an expensive operation, we defer doing this
; to the files that need it.

(define (sim-analyze-insns!)
  ; This can only be done if one isa and one cpu family is being kept.
  (assert-keep-one)

  (if (not /sim-insns-analyzed?)

      (begin
	(arch-analyze-insns! CURRENT-ARCH
			     #f ; don't include aliases
			     #t) ; do analyze the semantics

	; Compute the set of sformat argument buffers.
	(set! /sim-sformat-abuf-list (compute-sformat-argbufs! (current-sfmt-list)))

	(set! /sim-insns-analyzed? #t)))

  ; Do our own error checking.
  (assert (current-insn-lookup 'x-invalid #f))

  *UNSPECIFIED*
)

; For debugging.

(define (cgen-all-arch)
  (string-write
   cgen-arch.h
   cgen-arch.c
   cgen-cpuall.h
   ;cgen-mem-ops.h
   ;cgen-sem-ops.h
   ;cgen-ops.c
   )
)

(define (cgen-all-cpu)
  (string-write
   cgen-cpu.h
   cgen-cpu.c
   cgen-decode.h
   cgen-decode.c
   ;cgen-extract.c
   cgen-read.c
   cgen-write.c
   cgen-semantics.c
   cgen-sem-switch.c
   cgen-model.c
   ;cgen-mainloop.in
   )
)
@


1.32
log
@	* utils-cgen.scm (<location>): Define using new define-class.
	(<ident>, <source-ident>, <context>): Ditto.

	* cos.scm (/object-string): New function.
	(/object-error): Use it.
	(/object-count-true): New function
	(object-copy-top): Delete.  All callers changed to call object-copy.
	(/parse-member-list, /build-getter-defs, /build-setter-defs): New fns.
	(define-class, define-interface, define-method): New macros.
	(define-getters, define-setters, vmake): Moved here ...
	* utils-cgen.scm: ... from here.
@
text
@d1268 1
a1268 1
   "    TRACE_RESULT (current_cpu, abuf"
d1295 1
a1295 1
   "    TRACE_RESULT (current_cpu, abuf"
d1467 1
a1467 1
				   (string-append "extern const MACH "
d1478 1
a1478 1
   "const MACH *sim_machs[] =\n{\n"
@


1.31
log
@	* sim.scm (/op-gen-written-update): Disable operand number is too
	large warning, for now.
@
text
@d952 1
a952 1
		  (let ((xmode (object-copy-top mode)))
@


1.30
log
@	* hardware.scm (hw-pc?): New function.
	* ifield.scm (ifld-signed?): New function.
	* iformat.scm (ifmt-analyze): Call insn-cti-attr? instead of insn-cti?.
	* insn.scm (insn-cti-attr?): Renamed from insn-ctl?.
	(insn-cti?): New function.
	* rtl.scm (/hw): Create <pc> object for pcs.
	* semantics.scm (/build-reg-operand!): New args ref-type, sem-attrs.
	All callers updated.  Watch for sets to the pc.
	(semantic-attrs): Watch for sets to the pc.
	* sid.scm (<pc> cxmake-get): Handle raw-reg.
	* sim.scm (<pc> cxmake-get): Handle raw-reg.
	(<operand> cxmake-get): Add debugging printf.
	* utils-gen.scm (/gen-ifld-extract-base): Emit calls to
	EXTRACT_[LM]SB0_LG[SU]INT for values > 32 bits.
	(/gen-extract-word): Ditto.

	* utils.scm (gen-c-hex-constant): New function.
	* utils-sim.scm (/gen-decode-insn-entry): Call it.
@
text
@d1228 4
a1231 4
	    (message (if (with-parallel-write?) "Error: " "Warning: ")
		     (obj:name op)
		     " operand number " (op:num op)
		     " is too large (>= 32)\n")
@


1.29
log
@	* mach.scm (<derived-arch-data>): New member large-insn-word?.
	(/adata-set-derived!): Set it.
	(adata-large-insn-word?): New function.
	* sim-arch.scm (/gen-cpuall-includes): Don't #include cgen-engine.h
	here.
	* sim-cpu.scm (cgen-cpu.h): #include it here.
	(/gen-cpu-defines): Define CGEN_INSN_WORD.
	(/gen-no-scache-semantic-fn): Use CGEN_INSN_WORD instead of
	CGEN_INSN_INT.
	* sim-decode.scm (/gen-idesc-decls): Ditto.
	(/gen-extract-case, /gen-decode-fn): Ditto.
	* sim-model.scm (/gen-model-insn-fn): Ditto.
	* sim.scm (gen-argbuf-type): Ditto.
@
text
@d1005 11
a1015 2
     ; The enclosing function must set `pc' to the correct value.
     (cx:make mode "pc")))
d1116 28
a1143 23
     ; If the instruction could be parallely executed with others and we're
     ; doing read pre-processing, the operand has already been fetched, we
     ; just have to grab the cached value.
     ; ??? reg-raw: support wip
     (cond ((obj-has-attr? self 'RAW)
	    (send (op:type self) 'cxmake-get-raw estate mode index selector))
	   ((with-parallel-read?)
	    (cx:make-with-atlist mode
				 (string-append /par-operand-macro
						" (" (gen-sym self) ")")
				 nil)) ; FIXME: want CACHED attr if present
	   ((op:getter self)
	    (let ((args (car (op:getter self)))
		  (expr (cadr (op:getter self))))
	      (rtl-c-expr mode
			  (obj-isa-list self)
			  (if (= (length args) 0)
			      nil
			      (list (list (car args) 'UINT index)))
			  expr
			  #:rtl-cover-fns? #t)))
	   (else
	    (send (op:type self) 'cxmake-get estate mode index selector)))))
@


1.28
log
@	* sim.scm (/operand-number-elaboration-written?): New variable.
	(/op-gen-written-update op): New function.
	(/op-gen-set-trace, /op-gen-set-trace-parallel): Call it.
@
text
@d1835 1
a1835 1
  CGEN_INSN_INT insn;
@


1.27
log
@	* utils-cgen.scm (gen-set-macro2): New function.
	* sim.scm (<hw-register> gen-get-macro): Call it.
@
text
@d1201 27
d1248 1
a1248 5
   (if (op:cond? op)
       (string-append "    written |= (1 << "
		      (number->string (op:num op))
		      ");\n")
       "")
d1275 1
a1275 5
   (if (op:cond? op)
       (string-append "    written |= (1 << "
		      (number->string (op:num op))
		      ");\n")
       "")
@


1.26
log
@	* utils.scm (reduce): Delete.

	* rtl-traverse.scm (/rtx-canon-rtx-enum): Tweak local name.

	* enum.scm (gen-enum-sym): Make consistent with gen-enum-decl
	regarding PREFIX attribute handling.

	* operand.scm (<hw-index>): Add enum to possible types, all uses
	updated.
	(hw-index-constant?, hw-index-constant-value): New functions.
	(make-enum-hw-index, hw-index-enum-name, hw-index-enum-value,
	hw-index-enum-obj): New functions.
	(/operand-parse): Handle enum indices.
	* intrinsics.scm (md-operand:fixed-register): Use hw-index-constant?,
	hw-index-constant-value.
	* rtl.scm (rtx-constant-value): Fix handling of enums.
	* rtx-funcs.scm (enum): Ditto.
	* sid.scm (<hardware-base> cxmake-get): Only ifield indices are
	currently supported here.
@
text
@d528 9
a536 9
	   (gen-get-macro (gen-sym self)
			  (if (hw-scalar? self) "" "index")
			  (rtl-c mode
				 #f ;; h/w is not ISA-specific
				 (if (hw-scalar? self)
				     nil
				     (list (list (car args) 'UINT "index")))
				 expr
				 #:rtl-cover-fns? #t)))
d550 1
a550 3
			   (if (hw-scalar? self)
			       ""
			       "index")
@


1.25
log
@	Specify isa(s) when doing ifield, operand, insn lookups.
	ACU = all callers updated.
	* attr.scm (/attr-eval): Call rtx-value instead of rtx-eval-with-estate.
	* enum.scm (define-full-insn-enum): Pass isa-name-list to
	current-ifld-lookup.
	* html.scm (get-insn-properties): Pass isa-name-list to
	current-op-lookup.
	* ifield.scm (/ifld-parse-follows): New arg isas, ACU.
	* insn.scm (/parse-insn-format-symbol): New arg isa-name-list, ACU.
	(/parse-insn-format-list, /parse-insn-iformat-iflds): Ditto.
	(/parse-insn-format, syntax-break-out): Ditto.
	* mach.scm (obj-filter-by-isa): New function.
	(current-ifld-lookup): New optional arg maybe-isa-name-list.
	(/ifld-already-defined?, /op-already-defined?): Simplify.
	(current-op-lookup): New optional arg maybe-isa-name-list.
	(current-insn-lookup): New arg isa-name-list, ACU.
	(/insn-already-defined?, /minsn-already-defined?): Simplify.
	(current-minsn-lookup): New arg isa-name-list, ACU.
	* minsn.scm (/minsn-compute-iflds): Pass isa-name-list to
	current-op-lookup.
	* opc-itab.scm (compute-syntax): New arg isa-name-list, ACU.
	(gen-syntax-entry): Ditto.
	* operand.scm (/operand-parse): Pass isa-name-list to
	current-ifld-lookup.
	(/derived-parse-encoding): New arg isa-name-list, ACU.
	(/derived-parse-ifield-assertion): Ditto.
	(/derived-operand-parse): Pass isa-name-list to current-op-lookup.
	(/anyof-parse-choice): Ditto.
	(anyof-satisfies-assertions?): Pass context to rtx-solve.
	(/anyof-merge-syntax): New arg container, ACU.
	(operand-builtin!): Add pc to all isas.
	* rtl-c.scm (estate-make-for-rtl-c): Delete arg extra-vars-alist, ACU.
	(estate-make-for-rtl-c++, rtl-c-expr-parsed): Ditto.
	(rtl-c-parsed, rtl-c++-parsed): Ditto.
	(rtl-c): New arg isa-name-list, ACU.
	(rtl-c-expr, rtl-c++): Ditto.
	(closure): New arg isa-name-list, ACU.
	* rtl-traverse.scm (/make-cstate): New arg isa-name-list, ACU.
	(/cstate-isas): New function.
	(/rtx-canon-symbol-list): New function.
	(/rtx-canon-env-stack): Renamed from /rtx-canon-env, ACU.
	updated.
	(/rtx-make-canon-table): Rename ENV to ENVSTACK, new entry SYMBOLLIST.
	(/rtx-canon-rtx-operand): Pass isa list to current-op-lookup.
	(/rtx-canon-rtx-ref, /rtx-canon): Ditto.
	(rtx-canonicalize): New arg isa-name-list, ACU.
	(rtx-canonicalize-stmt): Delete.
	(tstate-make): New arg isas, ACU.
	(tstate-isas, tstate--set-isas!): New functions.
	(tstate-env-stack): Renamed from tstate-env, ACU.
	(tstate-set-env-stack!): Renamed from tstate-set-env!, ACU.
	(tstate-make-closure): Renamed from tstate-new-env, new arg
	isa-name-list, ACU.
	(/rtx-traverse-env): Delete.
	(/rtx-make-traverser-table): Rename ENV to ENVSTACK, new entry
	SUMBOLLIST.
	(/rtx-traverse): Include conditional flag in dump output.
	Update isa,envstack for closures.  Pass isa list to current-op-lookup.
	(<eval-state>): New member isas.  Rename env to env-stack.
	(<eval-state> vmake!): Handle #:isas.  #:env renamed to #:env-stack.
	(<eval-state>): New getter/setter for isas.  Rename env getter/setter
	to env-stack.
	(estate-make-for-eval): Provide #:isas.
	(estate-make-closure): Renamed from estate-new-env.  New arg
	isa-name-list, ACU.
	* rtl-xform.scm (/rtx-simplify-expr-fn): Handle closures.
	(/rtx-trim-args): ENV renamed to ENVSTACK.  Ad ITERATION, SYMBOLLIST.
	(/rtx-trim-for-doc): Handle closures.
	* rtl.scm (/rtx-valid-types): Rename ENV to ENVSTACK.  Add ITERATION,
	SYMBOLLIST.
	(rtx-env-var-list): Delete.
	(rtx-env-make): Handle already-compiled environments.
	(rtx-var-alist-to-env): New function.
	(rtx-var-alist-to-closure-env-stack, rtx-make-env-stack): New functions.
	(rtx-env-stack-dump): Renamed from rtx-env-dump, ACU.
	(rtx-operand-obj): New arg isa-name-list, ACU.
	(rtx-closure-isas, rtx-closure-env-stack, rtx-closure-expr): New
	functions.
	* rtx-funcs.scm (closure): New arg isa-name-list, reorder args, ACU.
	* sem-frags.scm (<sfrag>): Delete member compiled-semantics.
	(/frag-compute-desired-frags): Minor simplification.
	(/frag-pick-best): Ditto.
	* sid-cpu.scm (gen-semantic-code): Require canonical rtl.
	(/gen-sfrag-code): Update.
	* sim-cpu.scm (gen-semantic-code): Require canonical rtl.
	* utils-cgen.scm (sanitize): New arg isa-name-list, ACU.
	* utils.scm (non-null-intersection?): New function.
@
text
@d856 1
a856 1
   (if (memq (hw-index:type self) '(scalar constant str-expr ifield))
d890 3
d915 3
@


1.24
log
@	Record bitset attributes internally as a list.
	Record rtx attribute values internally as ((rtx-expr)).
	* attr.scm (bitset-attr?): Delete, unused.
	(<bitset-attribute> parse-value): Rewrite.
	(/attr-parse): Rewrite bitset default value processing.
	(/attr-read): Pick out values of scalar attributes to distinguish
	them from bitset values which are a list.
	Fix spelling errors for processing of default values.
	Handle string attributes.
	(bitset-attr->list): Delete, all callers updated.
	(/bitset-attr->charmask): Renamed from bitset-attr->charmask.
	All callers updated.
	(atlist-source-form): Rewrite.
	* hardware.scm (<hardware-base> 'get-isas): Update recognition
	of all isas.
	(hardware-builtin!): Update spec of ISA attribute, (ISA foo,bar)
	-> (ISA foo bar).
	* intrinsics.scm (target:belongs-to-group?): Update, bitset attribute
	values are now lists.
	* mach.scm (def-isa-attr!): Update, bitset attribute values,
	including the default, are now lists.
	(all-isas-attr-value): Result is now a list.
	* doc/rtl.texi: Clean up pass over attribute docs.
@
text
@d530 2
a531 1
			  (rtl-c mode expr
d535 1
d554 2
a555 2
			   (rtl-c VOID ; not `mode', sets have mode VOID
				  expr
d560 1
d960 1
a960 1
  (rtl-c 'INT sel nil)
d1009 1
a1009 1
	 (rtl-c INT yes? nil #:rtl-cover-fns? #t)))
d1034 1
a1034 1
  (let ((estate (estate-make-for-rtl-c nil nil)))
d1045 1
a1045 1
  (let ((estate (estate-make-for-rtl-c nil nil)))
d1117 2
a1118 1
	      (rtl-c-expr mode expr
d1122 1
d1206 2
a1207 1
	 (rtl-c 'VOID expr
d1212 1
d1348 1
a1348 1
  (let ((estate (estate-make-for-rtl-c nil nil)))
d2099 1
a2099 1
  (assert (current-insn-lookup 'x-invalid))
@


1.23
log
@	* cos.scm (/method-lookup): Delete arg virtual?, all callers updated.
	(method-proc): Delete.
	(method-make-virtual!, method-make-virtual-forward!): Delete.
	* ifield.scm (<ifield> field-start): Update.
	(<ifield> field-length, pretty-print): Update.
	(<multi-ifield> field-length, field-start, pretty-print): Update.
	* sid-cpu.scm (/gen-hardware-struct): Use gen-defn instead of gen-decl.
	* sid.scm (<scalar> gen-sym-defn): Renamed from gen-sym-decl.
	(<array> gen-sym-defn): Ditto.
	(<hardware-base> gen-defn): Renamed from gen-defn.
	(<hw-register> gen-type): Update.
	(<hw-register> gen-defn): Renamed from gen-sym-decl, rewrite.
	(<hw-memory>, <hw-address>, <hw-iaddress> gen-type): Update.
	(<hw-memory>, <hw-address> gen-defn): Renamed from gen-sym-decl.
	(<hw-immediate> gen-type): Update.
	(<hw-immediate> gen-defn): Renamed from gen-sym-decl, rewrite.
	* sim-cpu.scm (/gen-hardware-struct): Use gen-defn instead of gen-decl.
	* sim.scm (<scalar> gen-sym-defn): Renamed from gen-sym-decl.
	(<array> gen-sym-defn): Ditto.
	(<hardware-base> gen-defn): Renamed from gen-defn.
	(<hw-register> gen-type): Update.
	(<hw-register> gen-defn): Renamed from gen-sym-decl, rewrite.
	(<hw-memory>, <hw-address>, <hw-iaddress> gen-type): Update.
	(<hw-memory>, <hw-address> gen-defn): Renamed from gen-sym-decl.
	(<hw-immediate> gen-type): Update.
	(<hw-immediate> gen-defn): Renamed from gen-sym-decl, rewrite.
@
text
@d1931 1
a1931 1
		`(attrs VIRTUAL PBB (ISA ,all))
d1957 1
a1957 1
		`(attrs VIRTUAL PBB (ISA ,all))
d1976 1
a1976 1
		`(attrs VIRTUAL PBB (ISA ,all))
d2001 1
a2001 1
		`(attrs VIRTUAL PBB (ISA ,all))
d2017 1
a2017 1
		`(attrs VIRTUAL PBB (ISA ,all))
d2033 1
a2033 1
		`(attrs VIRTUAL (ISA ,all))
@


1.22
log
@	* operand.scm (/anyof-merge-setter): Handle set-quiet.

	* rtl-c.scm (estate-make-for-rtl-c): Delete args context, owner,
	rtl-cover-fns?, macro?.  All callers updated.
	(estate-make-for-normal-rtl-c): Delete, have all callers call
	estate-make-for-rtl-c directly.
	(rtl-c-parsed): Pass #:outer-expr to estate-make-for-rtl-c.
	(rtl-c, rtl-c-expr-parsed, rtl-c-expr, rtl-c++-parsed, rtl-c++): Ditto.

	* rtl-c.scm (/par-replace-set-dest-expr-fn): New function,
	replaces /par-replace-set-dests.
	(/par-replace-set-src-expr-fn): New function, replaces
	/par-replace-set-srcs.
	(s-parallel): Rewrite.

	* rtl.scm (rtx-pretty-strdump): New function.
	* rtl-traverse.scm (/rtx-canon-error): Use it.
	(<eval-state>): New member outer-expr.
	(estate-error): Include outer expression in error message if present.

	* rtl.scm (rtx-single-set?): Handle set-quiet.
@
text
@d198 1
a198 1
; gen-sym-decl - generate decl using the provided symbol
d210 1
a210 1
 <scalar> 'gen-sym-decl
d242 1
a242 1
 <array> 'gen-sym-decl
d306 1
a306 1
;(method-make! <integer> 'gen-sym-decl (lambda (self sym comment) ""))
d316 3
a318 1
; gen-decl
a326 2
; gen-type      - C type to use to record value, as a string.
;                 ??? Delete and just use get-mode?
a332 1
; gen-sym-decl  - Return a C declaration using the provided symbol.
d337 1
a337 1
; Generate CPU state struct entries.
d340 9
a348 3
 <hardware-base> 'gen-decl
 (lambda (self)
   (send self 'gen-sym-decl (obj:name self) (obj:comment self)))
d351 1
a351 1
(method-make-virtual! <hardware-base> 'gen-sym-decl (lambda (self sym comment) ""))
a364 7
; gen-type handler, must be overridden

(method-make-virtual!
 <hardware-base> 'gen-type
 (lambda (self) (error "gen-type not overridden:" self))
)

d460 8
a467 2
; Forward these methods onto TYPE.
(method-make-virtual-forward! <hw-register> 'type '(gen-type gen-sym-decl))
d744 2
a745 2
(method-make-virtual-forward! <hw-memory> 'type '(gen-type))
(method-make-virtual! <hw-memory> 'gen-sym-decl (lambda (self sym comment) ""))
d774 8
a781 2
; Forward these methods onto TYPE.
(method-make-virtual-forward! <hw-immediate> 'type '(gen-type gen-sym-decl))
d791 3
a793 3
; FIXME.
(method-make-virtual! <hw-address> 'gen-type (lambda (self) "ADDR"))
(method-make-virtual! <hw-address> 'gen-sym-decl (lambda (self sym comment) ""))
d819 2
a820 2
; FIXME: revisit.
(method-make-virtual! <hw-iaddress> 'gen-type (lambda (self) "IADDR"))
@


1.21
log
@whitespace fix
@
text
@d1021 1
a1021 1
  (let ((estate (estate-make-for-normal-rtl-c nil nil)))
d1032 1
a1032 1
  (let ((estate (estate-make-for-normal-rtl-c nil nil)))
d1331 1
a1331 1
  (let ((estate (estate-make-for-normal-rtl-c nil nil)))
@


1.20
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d1148 2
a1149 2
				  (mode-real-name sem-mode)
				  (mode-real-name mode)))))))
@


1.19
log
@	Clean up cpu file parsing, pass context consistently instead of the
	old "errtxt" argument.
	NOTE: ACU == "All Callers Updated".
	* attr.scm (-parse-simple-attribute): Renamed from
	parse-simple-attribute, ACU.
	(-attr-parse): Change errtxt argument to context, ACU.
	(-attr-read): Ditto.
	(atlist-parse): Ditto.  Put context arg first.
	(attr-parse): Use parse-error instead of context-error.
	* enum.scm (parse-enum-vals): Change errtxt argument to context, ACU.
	(-enum-parse-prefix, -enum-parse, -enum-read): Ditto.
	* hardware.scm (-keyword-parse): Renamed from keyword-parse.
	`context' arg is now a <context> object.  ACU.
	(-keyword-read): `context' arg is now a <context> object.  ACU.
	(-hw-parse-indices): Change errtxt argument to context, ACU.
	(-hw-parse-values, -hw-parse-handlers): Ditto.
	(-hw-parse-getter, -hw-parse-setter, -hw-parse, -hw-read): Ditto.
	(-hw-validate-layout, -hw-create-getter-from-layout,
	-hw-create-setter-from-layout): Ditto.
	(<hw-register>:parse!, <hw-pc>:parse!): Ditto.
	(<hw-memory>:parse!, <hw-immediate>:parse!): Ditto.
	(<hw-address>:parse!): Ditto.
	* ifield.scm (-ifield-parse, ifield-read): Ditto.
	(-ifld-parse-follows, -ifld-parse-encode-decode): Ditto.
	(-ifld-parse-encode, -ifld-parse-decode): Ditto.
	(-multi-ifield-parse, -multi-ifield-read): Ditto.
	* insn.scm (-insn-parse, -insn-read): Ditto.
	(parse-syntax): Ditto.  Put context arg first.
	(-parse-insn-format-symbol): Change errtxt argument to context, ACU.
	(-parse-insn-format-ifield-spec, -parse-insn-format-list): Ditto.
	(-parse-insn-format): Ditto.
	* mach.scm (-arch-parse-alignment, -arch-parse-machs): Ditto.
	(-arch-parse-isas): Ditto.
	(-isa-read): Add context arg, ACU.
	(-cpu-parse, -cpu-read, -mach-read): Ditto.
	* minsn.scm (-minsn-parse-expansion): Change errtxt argument to
	context, ACU.
	(-minsn-parse, -minsn-read, -minsn-compute-iflds): Ditto.
	(minsn-make-alias): Ditto.
	* mode.scm (-mode-parse): Ditto.
	(parse-mode-name): Ditto.  Put context arg first.
	* model.scm (-prefetch-parse, -retire-parse, -pipeline-parse): Change
	errtxt argument to context, ACU.
	(-unit-parse, -model-parse, -model-read): Ditto.
	* operand.scm (-operand-parse-getter): Use parse-error instead of
	context-error.
	(-operand-parse-setter): Ditto.
	(-operand-parse): Change errtxt argument to context, ACU.
	(-operand-read, -derived-operand-parse, -derived-operand-read): Ditto.
	(-anyof-operand-parse, -anyof-operand-read): Ditto.
	* read.scm (reader-error): Delete.  Use parse-error instead.
	(parse-error): Change errtxt argument to context, ACU.  Split args
	argument into expr and maybe-help-text.
	(-reader-process-expanded-1!): Reorganize.
	* rtl.scm (-subr-read): Change errtxt argument to context, ACU.
	* types.scm (parse-type): Ditto.
	* utils-cgen.scm (single-location->simple-string): New function.
	(<context>): Replace members file,lineno with location.
	(make-prefix-context): Renamed from context-make-prefix, ACU.
	(make-current-context): New function.
	(context-append, context-append-name): New functions.
	(context-make-reader): Delete.
	(parse-name): Change errtxt argument to context, ACU.
	Put context arg first.
	(parse-comment): Ditto.
	(parse-number): Change errtxt argument to context, ACU.
	(arg-list-validate-name, arg-list-check-no-args,
	arg-list-symbol-arg): Ditto.

	* read.scm (-cmd-if): Don't assume test is a list.

	* html.scm (get-insn-properties): Delete errtxt, unused.
@
text
@d53 2
a54 2
(define -with-scache? #f)
(define (with-scache?) -with-scache?)
d58 7
a64 7
; The options as passed are stored in -with-profile-{fn,sw}?, and
; -with-profile? is set at code generation time.
(define -with-profile-fn? #f)
(define -with-profile-sw? #f)
(define -with-profile? #f)
(define (with-profile?) -with-profile?)
(define (with-any-profile?) (or -with-profile-fn? -with-profile-sw?))
d67 2
a68 2
(define -with-multiple-isa? #f)
(define (with-multiple-isa?) -with-multiple-isa?)
d71 2
a72 2
(define -with-generic-write? #f)
(define (with-generic-write?) -with-generic-write?)
d75 2
a76 2
(define -with-parallel-only? #f)
(define (with-parallel-only?) -with-parallel-only?)
d87 6
a92 6
  (set! -with-scache? #f)
  (set! -with-profile-fn? #f)
  (set! -with-profile-sw? #f)
  (set! -with-multiple-isa? #f)
  (set! -with-generic-write? #f)
  (set! -with-parallel-only? #f)
d102 1
a102 1
    ((with-scache) (set! -with-scache? #t))
d104 1
a104 1
			   (set! -with-profile-fn? #t))
d106 1
a106 1
			   (set! -with-profile-sw? #t))
d108 3
a110 3
    ((with-multiple-isa) (set! -with-multiple-isa? #t))
    ((with-generic-write) (set! -with-generic-write? #t))
    ((with-parallel-only) (set! -with-parallel-only? #t))
d132 3
a134 3
(define -with-parallel? #f)
(define (with-parallel?) -with-parallel?)
(define (set-with-parallel?! flag) (set! -with-parallel? flag))
d142 1
a142 1
(define -with-parallel-kind 'write)
d145 1
a145 1
  (and -with-parallel? (eq? -with-parallel-kind 'read))
d149 1
a149 1
  (and -with-parallel? (eq? -with-parallel-kind 'write))
d185 1
a185 1
(define (-cxmake-ifld-val mode f)
d288 1
a288 1
				      (-gen-hw-index idx estate)
d388 1
a388 1
   (-cxmake-ifld-val mode (hw-index:value index)))
d415 1
a415 1
(define (-hw-gen-set-quiet-pc self estate mode index selector newval . options)
d418 1
a418 1
	 (-hw-gen-set-quiet self estate mode index selector newval))
d429 1
a429 1
(method-make! <hw-pc> 'gen-set-quiet -hw-gen-set-quiet-pc)
d513 1
a513 1
   (-gen-hw-index-raw index estate))
d561 1
a561 1
(define (-hw-cxmake-get hw estate mode index selector)
d571 1
a571 1
			  (c-index (-gen-hw-index index estate)))
d588 1
a588 1
(method-make! <hw-register> 'cxmake-get -hw-cxmake-get)
d605 1
a605 1
(define (-hw-gen-set-quiet hw estate mode index selector newval)
d609 1
a609 1
		 (c-index (-gen-hw-index index estate)))
d628 1
a628 1
(method-make! <hw-register> 'gen-set-quiet -hw-gen-set-quiet)
d713 1
a713 1
			     (-gen-hw-index index estate)
d717 1
a717 1
						(-gen-hw-selector selector)))
d732 1
a732 1
		    (-gen-hw-index index estate)
d736 1
a736 1
				       (-gen-hw-selector selector)))
d848 1
a848 1
		   (string-append access-macro " (" (-op-index-name op) ")"))
d855 1
a855 1
(define (-op-index-name op)
d864 1
a864 1
(define (-gen-hw-index-raw index estate)
d884 1
a884 1
      (else (error "-gen-hw-index-raw: invalid index:" index))))
d887 1
a887 1
; Same as -gen-hw-index-raw except used where speedups are possible.
d890 1
a890 1
(define (-gen-hw-index index estate)
d903 1
a903 1
		    (cx:c (-cxmake-ifld-val mode value))))
d906 1
a906 1
      (else (error "-gen-hw-index: invalid index:" index))))
d911 1
a911 1
(define (-gen-hw-addr hw estate index)
d939 1
a939 1
	      (-gen-hw-index self estate))))
d946 1
a946 1
(define (-gen-hw-selector sel)
d1004 1
a1004 1
;   (-op-gen-set-quiet self estate mode index selector newval)))
d1008 1
a1008 1
;   (-op-gen-set-trace self estate mode index selector newval)))
d1012 1
a1012 1
(define -par-operand-macro "OPRND")
d1022 1
a1022 1
    (send op 'gen-read estate sfmt -par-operand-macro))
d1033 1
a1033 1
    (send op 'gen-write estate sfmt -par-operand-macro))
d1098 1
a1098 1
				 (string-append -par-operand-macro
d1115 1
a1115 1
(define (-op-gen-set-quiet op estate mode index selector newval)
d1122 1
a1122 1
(define (-op-gen-queued-write op estate mode index selector newval)
d1158 1
a1158 1
	    (string-append ", " (-gen-hw-index index estate)))
d1160 1
a1160 1
	    (string-append ", " (-gen-hw-index index estate)))
d1162 1
a1162 1
	    (string-append ", " (-gen-hw-addr (op:type op) estate index))))
d1168 1
a1168 1
(define (-op-gen-set-quiet-parallel op estate mode index selector newval)
d1170 1
a1170 1
      (-op-gen-queued-write op estate mode index selector (cx:c newval))
d1174 2
a1175 2
			  -par-operand-macro " (" (-op-index-name op) ")"
			  " = " (-gen-hw-index index estate) ";\n")
d1178 1
a1178 1
       -par-operand-macro " (" (gen-sym op) ")"
d1182 1
a1182 1
(define (-op-gen-set-trace op estate mode index selector newval)
d1217 1
a1217 1
(define (-op-gen-set-trace-parallel op estate mode index selector newval)
d1222 1
a1222 1
       (-op-gen-queued-write op estate mode index selector "opval")
d1226 2
a1227 2
			   -par-operand-macro " (" (-op-index-name op) ")"
			   " = " (-gen-hw-index index estate) ";\n")
d1229 1
a1229 1
	"    " -par-operand-macro " (" (gen-sym op) ")"
d1267 1
a1267 1
	    (-op-gen-set-quiet-parallel self estate mode index selector newval))
d1269 1
a1269 1
	    (-op-gen-set-quiet self estate mode index selector newval)))))
d1291 1
a1291 1
	    (-op-gen-set-trace-parallel self estate mode index selector newval))
d1293 1
a1293 1
	    (-op-gen-set-trace self estate mode index selector newval)))))
d1301 1
a1301 1
  (string-append "#define " -par-operand-macro "(f) "
d1308 1
a1308 1
  (string-append "#undef " -par-operand-macro "\n")
d1409 1
a1409 1
(define (-gen-mach-decls)
d1422 1
a1422 1
(define (-gen-mach-data)
d1440 1
a1440 1
(define (-gen-arch-model-decls)
d1705 1
a1705 1
; Utility of -gen-argbuf-fields-union to generate the definition for
d1708 1
a1708 1
(define (-gen-argbuf-elm sbuf)
d1727 1
a1727 1
(define (-gen-argbuf-fields-union)
d1733 1
a1733 1
   (string-list-map -gen-argbuf-elm (current-sbuf-list))
d1773 1
a1773 1
       (-gen-argbuf-fields-union)
d1881 1
a1881 1
(define -sim-insns-analyzed? #f)
d1884 2
a1885 2
(define -sim-sformat-abuf-list #f)
(define (current-sbuf-list) -sim-sformat-abuf-list)
d1890 2
a1891 2
  (set! -sim-insns-analyzed? #f)
  (set! -sim-sformat-abuf-list #f)
d1895 1
a1895 1
;; Subroutine of -create-virtual-insns!.
d1902 1
a1902 1
(define (-virtual-insn-add! ordinal insn)
d1910 1
a1910 1
(define (-create-virtual-insns!)
d1913 1
a1913 1
	;; Record as a pair so -virtual-insn-add! can update it.
d1916 1
a1916 1
    (-virtual-insn-add!
d1942 1
a1942 1
    (-virtual-insn-add!
d1961 1
a1961 1
    (-virtual-insn-add!
d1986 1
a1986 1
    (-virtual-insn-add!
d2002 1
a2002 1
    (-virtual-insn-add!
d2018 1
a2018 1
    (-virtual-insn-add!
d2047 1
a2047 1
  (-create-virtual-insns!)
d2069 1
a2069 1
  (if (not -sim-insns-analyzed?)
d2077 1
a2077 1
	(set! -sim-sformat-abuf-list (compute-sformat-argbufs! (current-sfmt-list)))
d2079 1
a2079 1
	(set! -sim-insns-analyzed? #t)))
@


1.18
log
@	Use hash tables to record ifields, operands, insns, macro-insns.
	* attr.scm (attr-builtin!): Tweak some comments.
	* hardware.scm (hardware-builtin!): Call all-isas-attr-value.
	* ifield.scm (<ifield>): Subclass from <ordered-ident> instead of
	<ident>.
	(<multi-ifield>): New constructor.
	(ifield-builtin!): Add isa attr to f-nil, f-anyof.
	* insn.scm (<insn>): Subclass from <ordered-ident> instead of
	<ident>.
	(-sub-insn-make!): Add hack to avoid differences in generated code.
	(multi-insn-instantiate!): Add total number of multi-insns to
	logging message.
	* mach.scm (<arch>): Rename members ifld-list, op-list, insn-list,
	minsn-list to foo-table.  New member next-ordinal.
	Update getters/setters.
	(arch-ifld-list, arch-op-list, arch-insn-list, arch-minsn-list):
	New functions.
	(-get-next-ordinal!, -get-lowest-ordinal): New function.
	(-make-ident-object-table, -ident-object-table->list,
	-ident-object-table-add!, -ident-object-table-lookup): New functions.
	(current-ifld-list, current-ifld-add! current-ifld-lookup,
	-ifld-already-defined?): Rewrite.
	(current-op-list, current-op-add! current-op-lookup,
	-op-already-defined?): Rewrite.
	(current-raw-insn-list, insn-list-car, insn-list-splice!): Delete.
	(current-insn-list, current-insn-add! current-insn-lookup,
	-insn-already-defined?): Rewrite.
	(current-minsn-list, current-minsn-add! current-minsn-lookup,
	-minsn-already-defined?): Rewrite.
	(all-isas-attr-value, all-isas-attr, attr-isa-list): New functions.
	(MAX-VIRTUAL-INSNS): Define.
	(arch-analyze-insns!): Add hack to avoid differences in generated code.
	Update use of arch-insn-list.
	(mach-init!): Initialize ifld-table, op-table, insn-table, minsn-table.
	(arch-finish!): Delete references to ifld-table, op-table, insn-table,
	minsn-table.
	* minsn.scm (<macro-insn>): Subclass from <ordered-ident> instead of
	<ident>.  New constructor.
	* operand.scm (<operand>): Subclass from <ordered-ident> instead of
	<ident>.
	* sid.scm (-virtual-insn-add!): New function.
	(-create-virtual-insns!): Call it.
	(-fill-sim-insn-list!): Rewrite.
	* sim.scm (-virtual-insn-add!, -create-virtual-insns!): New functions.
	(sim-finish!): Move contents to -create-virtual-insns!, and call it.
	* utils-cgen.scm (<ordered-ident>): New class.
	(obj-ordinal, obj-set-ordinal!): New functions.
	(add-ident-methods!): Delete.

	* model.scm (parse-insn-timing): Change logging message to level 3.
@
text
@d1664 1
a1664 1
		       (parse-error "insn function unit spec"
d1912 1
a1912 1
	(context "virtual insns")
@


1.17
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d1895 12
a1906 5
(define (sim-finish!)
  ; Add begin,chain,before,after,invalid handlers if not provided.
  ; The code generators should first look for x-foo-@@prefix@@, then for x-foo.
  ; ??? This is good enough for the first pass.  Will eventually need to use
  ; less C and more RTL.
d1908 1
a1908 1
  (let ((all (stringize (current-arch-isa-name-list) ",")))
d1910 14
a1923 3
    (define-full-insn 'x-begin "pbb begin handler"
      `(VIRTUAL PBB (ISA ,all))
      "--begin--" '() '() '(c-code VOID "\
d1939 2
a1940 1
") nil)
d1942 8
a1949 3
    (define-full-insn 'x-chain "pbb chain handler"
      `(VIRTUAL PBB (ISA ,all))
      "--chain--" '() '() '(c-code VOID "\
d1958 2
a1959 1
") nil)
d1961 8
a1968 3
    (define-full-insn 'x-cti-chain "pbb cti-chain handler"
      `(VIRTUAL PBB (ISA ,all))
      "--cti-chain--" '() '() '(c-code VOID "\
d1983 2
a1984 1
") nil)
d1986 8
a1993 3
    (define-full-insn 'x-before "pbb begin handler"
      `(VIRTUAL PBB (ISA ,all))
      "--before--" '() '() '(c-code VOID "\
d1999 2
a2000 1
") nil)
d2002 8
a2009 3
    (define-full-insn 'x-after "pbb after handler"
      `(VIRTUAL PBB (ISA ,all))
      "--after--" '() '() '(c-code VOID "\
d2015 2
a2016 1
") nil)
d2018 8
a2025 3
    (define-full-insn 'x-invalid "invalid insn handler"
      `(VIRTUAL (ISA ,all))
      "--invalid--" '() '() (list 'c-code 'VOID (string-append "\
d2037 11
a2047 1
")) nil))
@


1.16
log
@	* attr.scm: Removing trailing whitespace.
	* cgen-intrinsics.scm: Ditto.
	* cgen-sim.scm: Ditto.
	* cos.scm: Ditto.
	* enum.scm: Ditto.
	* guile.scm: Ditto.
	* sim.scm: Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2001, 2002, 2006 Red Hat, Inc.
@


1.16.2.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2001, 2002, 2006, 2009 Red Hat, Inc.
@


1.15
log
@2008-12-23  Frank Ch. Eigler  <fche@@redhat.com>

	* sim.scm (-op-gen-queued-write): Add needed symbol->string.
@
text
@d1990 1
a1990 1
  
@


1.14
log
@2006-05-09  Dave Brolley  <brolley@@redhat.com>

        * sid-model.scm (-gen-model-class-decls): Handle the case where insn-timing
        is null.
        * sim.scm (-gen-arch-model-decls): Likewise.
@
text
@d1147 1
a1147 1
	     (string-downcase (if sem-mode
d1149 1
a1149 1
				  (mode-real-name mode))))))
@


1.13
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2001, 2002 Red Hat, Inc.
d1479 3
a1481 1
				    (length (timing:units (cdr insn-timing))))
@


1.12
log
@	* Makefile.am (srcroot): New var.
	(html): New rule.
	* Makefile.in: Regenerate.
	* cgen-doc.scm: New file.
	* html.scm: New file.
	* gen-all-doc: New file.
	* dev.scm (cload): Handle DOC application.
	(load-doc): New fn.
	* machs.scm (machs-for-cpu): New fn.
	* model.scm (models-for-cpu): New fn.
	* utils.scm (gen-c-copyright): Renamed from gen-copyright.
	All uses updated.
	(iota): Rewrite to be identical to pmacro version.  All uses updated.
	* utils-cgen.scm (alpha-sort-obj-list): New fn.
@
text
@d325 1
a325 1
; gen-type      - C type to use to record value.
d680 1
a680 1
   "/* Get the value of " (obj:name hw) ".  */\n\n"
d688 1
a688 1
   "/* Set a value for " (obj:name hw) ".  */\n\n"
d709 1
a709 1
	      (string-append "GETMEM" (obj:name mode)
d728 1
a728 1
     (string-append "SETMEM" (obj:name mode)
d1837 1
a1837 1
		 (string-append "  \"" (string-upcase (obj:name m)) "\",\n"))
d1903 1
a1903 1
      "--begin--" () () '(c-code VOID "\
d1923 1
a1923 1
      "--chain--" () () '(c-code VOID "\
d1936 1
a1936 1
      "--cti-chain--" () () '(c-code VOID "\
d1955 1
a1955 1
      "--before--" () () '(c-code VOID "\
d1965 1
a1965 1
      "--after--" () () '(c-code VOID "\
d1975 1
a1975 1
      "--invalid--" () () (list 'c-code 'VOID (string-append "\
@


1.11
log
@	* utils-sim.scm (gen-profile-sym): New fn.
	(<operand>,sbuf-profile-sym): New method.
	(<operand>,sbuf-profile-elm): Use it.
	* sim.scm (<operand>,gen-record-profile): Use sbuf-profile-sym instead
	of hardcoding symbol name.
	(<operand>,gen-profile-code): Ditto.
	(<unit>,gen-profile-code): Use gen-profile-sym instead of hardcoding
	symbol name.
@
text
@d1671 2
a1672 2
		  (iota (length inputs)
			(length outputs)))
@


1.10
log
@	Back out sim*.scm changes of 2001-04-02  Ben Elliston  <bje@@redhat.com>
	Instead do:
	* sim-decode.scm (-gen-decode-insn-globals): Use @@PREFIX@@_INSN__MAX
	as size of IDESC-TABLE-VAR.
	(@@prefix@@_init_idesc_table): Ditto.
	* sim-model.scm (-gen-mach-defns): Ditto.
	* sim.scm (gen-cpu-insn-enum-decl): Rename last elm from max to -max.

	* utils-scm.scm (-gen-decode-insn-entry): Fix some spacing in output.

	* insn.scm (-parse-insn-format-symbol): Improve error message.
	(-parse-insn-format): Ditto.
@
text
@d1344 1
a1344 2
		      (gen-argbuf-ref (string-append (if out? "out_" "in_")
						      (gen-sym self)))
d1366 1
a1366 2
				      (string-append (if out? "out_" "in_")
						     (gen-sym self)))))
d1576 7
a1582 8
			      (string-append "    "
					     (if out? "out_" "in_")
					     (gen-c-symbol (car arg))
					     " = "
					     (gen-argbuf-ref
					      (string-append (if out? "out_" "in_")
							     (gen-c-symbol (car arg))))
					     ";\n"))))
d1592 2
a1593 2
					     (if out? "out_" "in_")
					     (gen-c-symbol (car arg))
d1606 2
a1607 2
					    (if out? "out_" "in_")
					    (gen-c-symbol (car arg))))))
d1645 2
a1646 2
			   (string-append "    in_"
					  (gen-c-symbol (cadr arg))
d1649 1
a1649 3
					   (string-append
					    "in_"
					    (gen-c-symbol (caddr arg))))
d1654 2
a1655 2
			   (string-append "    out_"
					  (gen-c-symbol (cadr arg))
d1658 1
a1658 3
					   (string-append
					    "out_"
					    (gen-c-symbol (caddr arg))))
@


1.9
log
@2002-01-07  Ben Elliston  <bje@@redhat.com>

	* utils.scm (package-cygnus-simulators): Rename from this ..
	(package-red-hat-simulators): .. to this.
	* opcodes.scm (option-set!): Use package-red-hat-simulators.
	* sid-cpu.scm (cgen-desc.h): Likewise.
	(cgen-cpu.h): Likewise.
	(cgen-defs.h): Likewise.
	(cgen-write.cxx): Likewise.
	(cgen-semantics.cxx): Likewise.
	(cgen-sem-switch.cxx): Likewise.
	* sid-decode.scm (cgen-decode.h): Likewise.
	(cgen-decode.cxx): Likewise.
	* sid-model.scm (cgen-model.cxx): Likewise.
	* sid.scm (option-set!): Likewise.
	* sim.scm (option-set!): Likewise.
@
text
@d1397 1
a1397 1
			  (list '(max))))
@


1.8
log
@2002-01-07  Ben Elliston  <bje@@redhat.com>

	* utils.scm (copyright-fsf): Add 2002.
	(copyright-cygnus): Rename to copyright-red-hat.
	(copyright-red-hat): Add 2002.
	(CURRENT-COPYRIGHT): Update comment.
	* opcodes.scm (option-set!): Update callers.
	* sid-model.scm (cgen-model.cxx): Likewise.
	* sid-cpu.scm: Likewise.
	* sid-decode.scm: Likewise.
	* sid.scm (option-set!): Handle "redhat" as an option for
	"copyright"; use copyright-red-hat.
	* sim.scm (option-set!): Likewise.
@
text
@d119 1
a119 1
		      (set! CURRENT-PACKAGE package-cygnus-simulators))
@


1.7
log
@2001-01-06  Ben Elliston  <bje@@redhat.com>

	* utils-gen.scm (gen-sfmt-enum-decl): Use @@prefix@@ and @@PREFIX@@
	instead of @@cpu@@ and @@CPU@@ to generically prefix symbol names.
	* sim-cpu.scm (-gen-sem-fn-table-entry): Likewise.
	(-gen-semantic-fn-table): Likewise.
	(-gen-scache-semantic-fn): Likewise.
	(-gen-no-scache-semantic-fn): Likewise.
	(cgen-read.c): Likewise.
	(cgen-sem-switch.c): Likewise.
	* desc-cpu.scm (cgen-desc.c): Use @@arch@@, not @@prefix@@, since this
	is a filename prefix.
	* sim-decode.scm (IDESC-TABLE-VAR): Use @@prefix@@, et al.
	(-gen-decode-insn-globals): Likewise.
	(-gen-idesc-decls): Likewise.
	(cgen-decode.h): Likewise.
	(cgen-decode.c): Likewise.
	* sim.scm (gen-cpu-insn-enum-decl): Likewise.
	(gen-cpu-insn-enum): Likewise.
	(sim-finish!): Likewise.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2001 Red Hat, Inc.
d47 1
a47 1
; copyright fsf|cygnus
d113 2
a114 2
		       ((equal? value '("cygnus"))
			(set! CURRENT-COPYRIGHT copyright-cygnus))
@


1.6
log
@2000-11-24  Ben Elliston  <bje@@redhat.com>

	* sim.scm (-with-multiple-isa?): New symbol.
	(with-multiple-isa?): New function.
	(option-init!): Initialise -with-multiple-isa?.
	(option-set!): Handle with-multiple-isa option.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
d1377 1
a1377 1
  (gen-enum-decl "@@cpu@@_insn_type"
d1379 1
a1379 1
		 "@@CPU@@_INSN_"
d1406 1
a1406 1
  (string-upcase (string-append "@@CPU@@_INSN_" (gen-sym insn)))
d1902 1
a1902 1
  ; The code generators should first look for x-foo-@@cpu@@, then for x-foo.
d1912 1
a1912 1
#if WITH_SCACHE_PBB_@@CPU@@
d1916 1
a1916 1
    vpc = @@cpu@@_pbb_begin (current_cpu, FAST_P);
d1919 1
a1919 1
    vpc = @@cpu@@_pbb_begin (current_cpu, STATE_RUN_FAST_P (CPU_STATE (current_cpu)));
d1921 1
a1921 1
    vpc = @@cpu@@_pbb_begin (current_cpu, 0);
d1932 2
a1933 2
#if WITH_SCACHE_PBB_@@CPU@@
    vpc = @@cpu@@_pbb_chain (current_cpu, sem_arg);
d1945 1
a1945 1
#if WITH_SCACHE_PBB_@@CPU@@
d1947 1
a1947 1
    vpc = @@cpu@@_pbb_cti_chain (current_cpu, sem_arg,
d1952 1
a1952 1
    vpc = @@cpu@@_pbb_cti_chain (current_cpu, sem_arg,
d1964 2
a1965 2
#if WITH_SCACHE_PBB_@@CPU@@
    @@cpu@@_pbb_before (current_cpu, sem_arg);
d1974 2
a1975 2
#if WITH_SCACHE_PBB_@@CPU@@
    @@cpu@@_pbb_after (current_cpu, sem_arg);
@


1.5
log
@* cleanup

2000-10-13  matthew green  <mrg@@cygnus.com>

	* utils-cgen.scm (get-ifetch): Move from here ...
	* sim.scm (get-ifetch): ... to here.
@
text
@d45 2
d66 4
d90 1
d108 1
@


1.4
log
@2000-09-05  Dave Brolley  <brolley@@redhat.com>

	* sim.scm (sim-finish!): Honour the definition of FAST_P when calling
	@@cpu@@_pbb_begin. Use 0 if FAST_P is not defined.
@
text
@d155 18
@


1.3
log
@2000-08-24  Frank Ch. Eigler  <fche@@redhat.com>

	* hardware.scm (<hw-immediate> get-index-mode): Define method.
	* operand.scm (<operand> gen-pretty-name): Tolerate no op:sem-name.
	* rtl-c.scm (-c-rtl-get): Improve an error message.
	* sim.scm (-op-gen-set-trace): Support <derived-operand> lvalues.
@
text
@d1887 1
a1887 1
#ifdef DEFINE_SWITCH
d1892 1
d1894 3
@


1.2
log
@* snapshot of work toward more complete support of derived-operands

2000-08-22  Frank Ch. Eigler  <fche@@redhat.com>

	* Makefile.in (DIST_COMMON): Regenerated.
	* ifield.scm (derived-ifield needed-iflds): New method.
	* iformat.scm (-ifmt-lookup-sfmt!): Use base ifields for
	sfmts built from derived-ifields.
	* operand.scm (-derived-parse-encoding): Give derived-ifield a fixed
	type symbol 'derived-ifield, not an unparseable string.
	* utils-sim.scm (op-needed-iflds) Handler 'derived-ifield case.
	(-sfmt-contents): Add tracing.

	From Doug Evans <dje@@transmeta.com>:
	* sim.scm (operand cxmake-get): Result is a <c-expr>, not a string of
	C code.
@
text
@d1160 14
a1173 2
   "    " (send (op:type op) 'gen-set-quiet estate mode index selector
		(cx:make-with-atlist mode "opval" (cx:atlist newval)))
@


1.1
log
@Initial revision
@
text
@d1078 5
a1082 5
	      (rtl-c mode expr
		     (if (= (length args) 0)
			 nil
			 (list (list (car args) 'UINT index)))
		     #:rtl-cover-fns? #t)))
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
