head	1.27;
access;
symbols
	sid-snapshot-20180601:1.27
	cgen-snapshot-20180601:1.27
	sid-snapshot-20180501:1.27
	cgen-snapshot-20180501:1.27
	sid-snapshot-20180401:1.27
	cgen-snapshot-20180401:1.27
	sid-snapshot-20180301:1.27
	cgen-snapshot-20180301:1.27
	sid-snapshot-20180201:1.27
	cgen-snapshot-20180201:1.27
	sid-snapshot-20180101:1.27
	cgen-snapshot-20180101:1.27
	sid-snapshot-20171201:1.27
	cgen-snapshot-20171201:1.27
	sid-snapshot-20171101:1.27
	cgen-snapshot-20171101:1.27
	sid-snapshot-20171001:1.27
	cgen-snapshot-20171001:1.27
	sid-snapshot-20170901:1.27
	cgen-snapshot-20170901:1.27
	sid-snapshot-20170801:1.27
	cgen-snapshot-20170801:1.27
	sid-snapshot-20170701:1.27
	cgen-snapshot-20170701:1.27
	sid-snapshot-20170601:1.27
	cgen-snapshot-20170601:1.27
	sid-snapshot-20170501:1.27
	cgen-snapshot-20170501:1.27
	sid-snapshot-20170401:1.27
	cgen-snapshot-20170401:1.27
	sid-snapshot-20170301:1.27
	cgen-snapshot-20170301:1.27
	sid-snapshot-20170201:1.27
	cgen-snapshot-20170201:1.27
	sid-snapshot-20170101:1.27
	cgen-snapshot-20170101:1.27
	sid-snapshot-20161201:1.27
	cgen-snapshot-20161201:1.27
	sid-snapshot-20161101:1.27
	cgen-snapshot-20161101:1.27
	sid-snapshot-20160901:1.27
	cgen-snapshot-20160901:1.27
	sid-snapshot-20160801:1.27
	cgen-snapshot-20160801:1.27
	sid-snapshot-20160701:1.27
	cgen-snapshot-20160701:1.27
	sid-snapshot-20160601:1.27
	cgen-snapshot-20160601:1.27
	sid-snapshot-20160501:1.27
	cgen-snapshot-20160501:1.27
	sid-snapshot-20160401:1.27
	cgen-snapshot-20160401:1.27
	sid-snapshot-20160301:1.27
	cgen-snapshot-20160301:1.27
	sid-snapshot-20160201:1.27
	cgen-snapshot-20160201:1.27
	sid-snapshot-20160101:1.27
	cgen-snapshot-20160101:1.27
	sid-snapshot-20151201:1.27
	cgen-snapshot-20151201:1.27
	sid-snapshot-20151101:1.27
	cgen-snapshot-20151101:1.27
	sid-snapshot-20151001:1.27
	cgen-snapshot-20151001:1.27
	sid-snapshot-20150901:1.27
	cgen-snapshot-20150901:1.27
	sid-snapshot-20150801:1.27
	cgen-snapshot-20150801:1.27
	sid-snapshot-20150701:1.27
	cgen-snapshot-20150701:1.27
	sid-snapshot-20150601:1.27
	cgen-snapshot-20150601:1.27
	sid-snapshot-20150501:1.27
	cgen-snapshot-20150501:1.27
	sid-snapshot-20150401:1.27
	cgen-snapshot-20150401:1.27
	sid-snapshot-20150301:1.27
	cgen-snapshot-20150301:1.27
	sid-snapshot-20150201:1.27
	cgen-snapshot-20150201:1.27
	sid-snapshot-20150101:1.27
	cgen-snapshot-20150101:1.27
	sid-snapshot-20141201:1.27
	cgen-snapshot-20141201:1.27
	sid-snapshot-20141101:1.27
	cgen-snapshot-20141101:1.27
	sid-snapshot-20141001:1.27
	cgen-snapshot-20141001:1.27
	sid-snapshot-20140901:1.27
	cgen-snapshot-20140901:1.27
	sid-snapshot-20140801:1.27
	cgen-snapshot-20140801:1.27
	sid-snapshot-20140701:1.27
	cgen-snapshot-20140701:1.27
	sid-snapshot-20140601:1.27
	cgen-snapshot-20140601:1.27
	sid-snapshot-20140501:1.27
	cgen-snapshot-20140501:1.27
	sid-snapshot-20140401:1.27
	cgen-snapshot-20140401:1.27
	sid-snapshot-20140301:1.27
	cgen-snapshot-20140301:1.27
	sid-snapshot-20140201:1.27
	cgen-snapshot-20140201:1.27
	sid-snapshot-20140101:1.27
	cgen-snapshot-20140101:1.27
	sid-snapshot-20131201:1.27
	cgen-snapshot-20131201:1.27
	sid-snapshot-20131101:1.27
	cgen-snapshot-20131101:1.27
	sid-snapshot-20131001:1.27
	cgen-snapshot-20131001:1.27
	sid-snapshot-20130901:1.27
	cgen-snapshot-20130901:1.27
	sid-snapshot-20130801:1.27
	cgen-snapshot-20130801:1.27
	sid-snapshot-20130701:1.27
	cgen-snapshot-20130701:1.27
	sid-snapshot-20130601:1.27
	cgen-snapshot-20130601:1.27
	sid-snapshot-20130501:1.27
	cgen-snapshot-20130501:1.27
	sid-snapshot-20130401:1.27
	cgen-snapshot-20130401:1.27
	sid-snapshot-20130301:1.27
	cgen-snapshot-20130301:1.27
	sid-snapshot-20130201:1.27
	cgen-snapshot-20130201:1.27
	sid-snapshot-20130101:1.27
	cgen-snapshot-20130101:1.27
	sid-snapshot-20121201:1.27
	cgen-snapshot-20121201:1.27
	sid-snapshot-20121101:1.27
	cgen-snapshot-20121101:1.27
	sid-snapshot-20121001:1.27
	cgen-snapshot-20121001:1.27
	sid-snapshot-20120901:1.27
	cgen-snapshot-20120901:1.27
	sid-snapshot-20120801:1.27
	cgen-snapshot-20120801:1.27
	sid-snapshot-20120701:1.27
	cgen-snapshot-20120701:1.27
	sid-snapshot-20120601:1.27
	cgen-snapshot-20120601:1.27
	sid-snapshot-20120501:1.27
	cgen-snapshot-20120501:1.27
	sid-snapshot-20120401:1.27
	cgen-snapshot-20120401:1.27
	sid-snapshot-20120301:1.27
	cgen-snapshot-20120301:1.27
	sid-snapshot-20120201:1.27
	cgen-snapshot-20120201:1.27
	sid-snapshot-20120101:1.27
	cgen-snapshot-20120101:1.27
	sid-snapshot-20111201:1.27
	cgen-snapshot-20111201:1.27
	sid-snapshot-20111101:1.27
	cgen-snapshot-20111101:1.27
	sid-snapshot-20111001:1.27
	cgen-snapshot-20111001:1.27
	sid-snapshot-20110901:1.27
	cgen-snapshot-20110901:1.27
	sid-snapshot-20110801:1.27
	cgen-snapshot-20110801:1.27
	sid-snapshot-20110701:1.27
	cgen-snapshot-20110701:1.27
	sid-snapshot-20110601:1.27
	cgen-snapshot-20110601:1.27
	sid-snapshot-20110501:1.27
	cgen-snapshot-20110501:1.27
	sid-snapshot-20110401:1.27
	cgen-snapshot-20110401:1.27
	sid-snapshot-20110301:1.27
	cgen-snapshot-20110301:1.27
	sid-snapshot-20110201:1.27
	cgen-snapshot-20110201:1.27
	sid-snapshot-20110101:1.27
	cgen-snapshot-20110101:1.27
	sid-snapshot-20101201:1.27
	cgen-snapshot-20101201:1.27
	sid-snapshot-20101101:1.27
	cgen-snapshot-20101101:1.27
	sid-snapshot-20101001:1.27
	cgen-snapshot-20101001:1.27
	sid-snapshot-20100901:1.27
	cgen-snapshot-20100901:1.27
	sid-snapshot-20100801:1.27
	cgen-snapshot-20100801:1.27
	sid-snapshot-20100701:1.27
	cgen-snapshot-20100701:1.27
	sid-snapshot-20100601:1.27
	cgen-snapshot-20100601:1.27
	sid-snapshot-20100501:1.27
	cgen-snapshot-20100501:1.27
	sid-snapshot-20100401:1.27
	cgen-snapshot-20100401:1.27
	sid-snapshot-20100301:1.27
	cgen-snapshot-20100301:1.27
	sid-snapshot-20100201:1.26
	cgen-snapshot-20100201:1.26
	sid-snapshot-20100101:1.23
	cgen-snapshot-20100101:1.23
	sid-snapshot-20091201:1.23
	cgen-snapshot-20091201:1.23
	sid-snapshot-20091101:1.23
	cgen-snapshot-20091101:1.23
	sid-snapshot-20091001:1.23
	cgen-snapshot-20091001:1.23
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.20
	cgen-snapshot-20090901:1.20
	sid-snapshot-20090801:1.10
	cgen-snapshot-20090801:1.10
	sid-snapshot-20090701:1.6
	cgen-snapshot-20090701:1.6
	dje-cgen-play1-branch:1.6.0.2
	dje-cgen-play1-branchpoint:1.6
	cgen-1_1-branch:1.5.0.6
	cgen-1_1-branchpoint:1.5
	sid-snapshot-20090601:1.5
	cgen-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	cgen-snapshot-20090501:1.5
	sid-snapshot-20090401:1.5
	cgen-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.4
	arc-insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	cgen-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	cgen-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	cgen-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	cgen-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	cgen-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	cgen-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	cgen-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	cgen-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	cgen-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	cgen-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	cgen-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	cgen-snapshot-20080401:1.5
	sid-snapshot-20080301:1.5
	cgen-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	cgen-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	cgen-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	cgen-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	cgen-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	cgen-snapshot-20071001:1.5
	msnyder-fork-checkpoint-branch:1.5.0.2
	msnyder-fork-checkpoint-branchpoint:1.5
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.4
	cagney_regbuf-20020515-branch:1.2.0.2
	cagney_regbuf-20020515-branchpoint:1.2
	cygnus_cvs_20020108_pre:1.1.1.1
	cgen-1-1-branch:1.1.1.1.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.27
date	2010.02.13.03.39.15;	author devans;	state Exp;
branches;
next	1.26;

1.26
date	2010.01.29.02.59.01;	author devans;	state Exp;
branches;
next	1.25;

1.25
date	2010.01.28.04.45.15;	author devans;	state Exp;
branches;
next	1.24;

1.24
date	2010.01.24.23.37.39;	author devans;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.08.06.51.44;	author devans;	state Exp;
branches;
next	1.22;

1.22
date	2009.09.07.22.17.34;	author devans;	state Exp;
branches;
next	1.21;

1.21
date	2009.09.01.16.31.26;	author devans;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.25.16.13.34;	author devans;	state Exp;
branches;
next	1.19;

1.19
date	2009.08.20.05.33.14;	author devans;	state Exp;
branches;
next	1.18;

1.18
date	2009.08.20.04.51.09;	author devans;	state Exp;
branches;
next	1.17;

1.17
date	2009.08.19.17.04.27;	author devans;	state Exp;
branches;
next	1.16;

1.16
date	2009.08.18.01.40.56;	author devans;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.17.15.27.55;	author devans;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.13.19.36.52;	author devans;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.13.17.57.51;	author devans;	state Exp;
branches;
next	1.12;

1.12
date	2009.08.07.21.29.20;	author devans;	state Exp;
branches;
next	1.11;

1.11
date	2009.08.06.16.40.43;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2009.07.22.17.32.27;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2009.07.20.00.57.03;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2009.07.19.16.57.52;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.13.20.55.21;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2005.06.13.22.28.30;	author jimb;	state Exp;
branches
	1.5.6.1;
next	1.4;

1.4
date	2005.02.14.17.48.25;	author jimb;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.16.05.35.47;	author devans;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.19.20.44.30;	author hp;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.6.2.1
date	2009.07.14.16.08.50;	author devans;	state Exp;
branches;
next	;

1.5.6.1
date	2009.06.24.14.57.46;	author devans;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.27
log
@update copyright year
@
text
@;; Preprocessor-like macro support.
;; Copyright (C) 2000, 2009, 2010 Red Hat, Inc.
;; This file is part of CGEN.
;; See file COPYING.CGEN for details.

;; TODO:
;; - Like C preprocessor macros, there is no scoping [one can argue
;;   there should be].  Maybe in time (??? Hmmm... done?)
;; - Support for multiple macro tables.

;; Non-standard required routines:
;; Provided by Guile:
;;   make-hash-table, hashq-ref, hashq-set!, symbol-append,
;;   source-properties
;; Provided by CGEN:
;;   location-property, location-property-set!,
;;   source-properties-location->string,
;;   single-location->string, location-top, unspecified-location,
;;   reader-process-expanded!, num-args-ok?, *UNSPECIFIED*.

;; The convention we use says `-' begins "local" objects.
;; At some point this might also use the Guile module system.

;; This uses Guile's source-properties system to track source location.
;; The chain of macro invocations is tracked and stored in the result as
;; object property "location-property".

;; Exported routines:
;;
;; pmacro-init! - initialize the pmacro system
;;
;; define-pmacro - define a symbolic or procedural pmacro
;;
;;	(define-pmacro symbol ["comment"] expansion)
;;	(define-pmacro (symbol [args]) ["comment"] (expansion))
;;
;; ARGS is a list of `symbol' or `(symbol default-value)' elements.
;;
;; pmacro-expand - expand all pmacros in an expression
;;
;;	(pmacro-expand expression loc)
;;
;; pmacro-trace - same as pmacro-expand, but trace macro expansion
;;                Output is sent to current-error-port.
;;
;;	(pmacro-trace expression loc)
;;
;; pmacro-dump - expand all pmacros in an expression, for debugging purposes
;;
;;	(pmacro-dump expression)

;; pmacro-debug - expand all pmacros in an expression,
;;                printing various debugging messages.
;;                This does not process %exec.
;;
;;	(pmacro-debug expression)

;; Builtin pmacros:
;;
;; (%sym symbol1 symbol2 ...)          - symbolstr-append
;; (%str string1 string2 ...)          - stringsym-append
;; (%hex number [width])               - convert to hex string
;; (%upcase string)
;; (%downcase string)
;; (%substring string start end)       - get part of a string
;; (%splice a b (%unsplice c) d e ...) - splice list into another list
;; (%iota count [start [increment]])   - number generator
;; (%map pmacro arg1 . arg-rest)
;; (%for-each pmacro arg1 . arg-rest)
;; (%eval expr)                        - expand (or evaluate it) expr
;; (%exec expr)                        - execute expr immediately
;; (%apply pmacro-name arg)
;; (%pmacro (arg-list) expansion)      - akin go lambda in Scheme
;; (%pmacro? arg)
;; (%let (var-list) expr1 . expr-rest) - akin to let in Scheme
;; (%let* (var-list) expr1 . expr-rest) - akin to let* in Scheme
;; (%if expr then [else])
;; (%case expr ((case-list1) stmt) [case-expr-stmt-list] [(else stmt)])
;; (%cond (expr stmt) [(cond-expr-stmt-list)] [(else stmt)])
;; (%begin . stmt-list)
;; (%print . exprs)                    - for debugging messages
;; (%dump expr)                        - dump expr in readable format
;; (%error . message)                  - print error message and exit
;; (%list . exprs)
;; (%ref l n)                          - extract the n'th element of list l
;; (%length x)                         - length of symbol, string, or list
;; (%replicate n expr)                 - return list of expr replicated n times
;; (%find pred l)                      - return elements of list l matching pred
;; (%equal? x y)                       - deep comparison
;; (%andif expr . rest)                - && in C
;; (%orif expr . rest)                 - || in C
;; (%not expr)                         - ! in C
;; (%eq x y)
;; (%ne x y)
;; (%lt x y)
;; (%gt x y)
;; (%le x y)
;; (%ge x y)
;; (%add x y)
;; (%sub x y)
;; (%mul x y)
;; (%div x y)                          - integer division
;; (%rem x y)                          - integer remainder
;; (%sll x n)                          - shift left logical
;; (%srl x n)                          - shift right logical
;; (%sra x n)                          - shift right arithmetic
;; (%and x y)                          - bitwise and
;; (%or x y)                           - bitwise or
;; (%xor x y)                          - bitwise xor
;; (%inv x)                            - bitwise invert
;; (%car l)
;; (%cdr l)
;; (%caar l)
;; (%cadr l)
;; (%cdar l)
;; (%cddr l)
;; (%internal-test expr)               - testsuite internal use only
;;
;; NOTE: %cons currently absent on purpose
;;
;; %sym and %str convert numbers to symbols/strings as necessary (base 10).
;;
;; %pmacro is for constructing pmacros on-the-fly, like lambda, and is currently
;; only valid as arguments to other pmacros or assigned to a local in a {%let}
;; or {%let*}.
;;
;; NOTE: While Scheme requires tail recursion to be implemented as a loop,
;; we do not.  We might some day, but not today.
;;
;; ??? Methinks .foo isn't a valid R5RS symbol.  May need to change 
;; to something else.

;; True if doing pmacro expansion via pmacro-debug.
(define /pmacro-debug? #f)
;; True if doing pmacro expansion via pmacro-trace.
(define /pmacro-trace? #f)

;; The original prefix to pmacro names.
(define /pmacro-orig-prefix ".")

;; The prefix to pmacro names.
(define /pmacro-prefix "%")

;; The pmacro table.
(define /pmacro-table #f)
(define (/pmacro-lookup name) (hashq-ref /pmacro-table name #f))
(define (/pmacro-set! name val) (hashq-set! /pmacro-table name val))

;; A copy of syntactic pmacros is kept separately.
(define /smacro-table #f)
(define (/smacro-lookup name) (hashq-ref /smacro-table name #f))
(define (/smacro-set! name val) (hashq-set! /smacro-table name val))

;; Marker to indicate a value is a pmacro.
;; NOTE: Naming this "<pmacro>" is intentional.  It makes them look like
;; objects of class <pmacro>.  However we don't use COS in part to avoid
;; a dependency on COS and in part because displaying COS objects isn't well
;; supported (displaying them in debugging dumps adds a lot of noise).
(define /pmacro-marker '<pmacro>)

;; Utilities to create and access pmacros.
(define (/pmacro-make name arg-spec default-values
		      syntactic-form? transformer comment)
  (vector /pmacro-marker name arg-spec default-values
	  syntactic-form? transformer comment)
)
(define (/pmacro? x) (and (vector? x) (eq? (vector-ref x 0) /pmacro-marker)))
(define (/pmacro-name pmac) (vector-ref pmac 1))
(define (/pmacro-arg-spec pmac) (vector-ref pmac 2))
(define (/pmacro-default-values pmac) (vector-ref pmac 3))
(define (/pmacro-syntactic-form? pmac) (vector-ref pmac 4))
(define (/pmacro-transformer pmac) (vector-ref pmac 5))
(define (/pmacro-comment pmac) (vector-ref pmac 6))

;; Create a new environment, prepending NAMES to PREV-ENV.

(define (/pmacro-env-make loc prev-env names values)
  (if (= (length names) (length values))
      (append! (map cons names values) prev-env)
      (/pmacro-loc-error loc
			 (string-append "invalid number of parameters, expected "
					(number->string (length names)))
			 values))
)

;; Look up NAME in ENV.

(define (/pmacro-env-ref env name) (assq name env))

;; Error message generator.

(define (/pmacro-error msg expr)
  (error (string-append
	  (or (port-filename (current-input-port)) "<input>")
	  ":"
	  (number->string (port-line (current-input-port)))
	  ":"
	  msg
	  ":")
	 expr)
)

;; Error message generator when we have a location.

(define (/pmacro-loc-error loc errmsg expr)
  (let* ((top-sloc (location-top loc))
	 (intro "During pmacro expansion")
	 (text (string-append "Error: " errmsg)))
    (error (simple-format
	    #f
	    "\n~A:\n@@ ~A:\n\n~A: ~A:"
	    intro
	    (location->string loc)
	    (single-location->simple-string top-sloc)
	    text)
	   expr))
)

;; Issue an error where a number was expected.

(define (/pmacro-expected-number op n)
  (/pmacro-error (string-append "invalid arg for " op ", expected number") n)
)

;; Verify N is a number.

(define (/pmacro-verify-number op n)
  (if (not (number? n))
      (/pmacro-expected-number op n))
)

;; Issue an error where an integer was expected.

(define (/pmacro-expected-integer op n)
  (/pmacro-error (string-append "invalid arg for " op ", expected integer") n)
)

;; Verify N is an integer.

(define (/pmacro-verify-integer op n)
  (if (not (integer? n))
      (/pmacro-expected-integer op n))
)

;; Issue an error where a non-negative integer was expected.

(define (/pmacro-expected-non-negative-integer op n)
  (/pmacro-error (string-append "invalid arg for " op ", expected non-negative integer") n)
)

;; Verify N is a non-negative integer.

(define (/pmacro-verify-non-negative-integer op n)
  (if (or (not (integer? n))
	  (< n 0))
      (/pmacro-expected-non-negative-integer op n))
)

;; Expand a list of expressions, in order.
;; The result is the value of the last one.

(define (/pmacro-expand-expr-list exprs env loc)
  (let ((result nil))
    (for-each (lambda (expr)
		(set! result (/pmacro-expand expr env loc)))
	      exprs)
    result)
)

;; Process list of keyword/value specified arguments.

(define (/pmacro-process-keyworded-args arg-spec default-values args)
  ;; Build a list of default values, then override ones specified in ARGS,
  (let ((result-alist (alist-copy default-values)))
    (let loop ((args args))
      (cond ((null? args)
	     #f) ;; done
	    ((and (pair? args) (keyword? (car args)))
	     (let ((elm (assq (car args) result-alist)))
	       (if (not elm)
		   (/pmacro-error "not an argument name" (car args)))
	       (if (null? (cdr args))
		   (/pmacro-error "missing argument to #:keyword" (car args)))
	       (set-cdr! elm (cadr args))
	       (loop (cddr args))))
	    (else
	     (/pmacro-error "bad keyword/value argument list" args))))

    ;; Ensure each element has a value.
    (let loop ((to-scan result-alist))
      (if (null? to-scan)
	  #f ;; done
	  (begin
	    (if (not (cdar to-scan))
		(/pmacro-error "argument value not specified" (caar to-scan)))
	    (loop (cdr to-scan)))))

    ;; If varargs pmacro, adjust result.
    (if (list? arg-spec)
	(map cdr result-alist) ;; not varargs
	(let ((nr-args (length (result-alist))))
	  (append! (map cdr (list-head result-alist (- nr-args 1)))
		   (cdr (list-tail result-alist (- nr-args 1)))))))
)

;; Process a pmacro argument list.
;; ARGS is either a fully specified position dependent argument list,
;; or is a list of keyword/value pairs with missing values coming from
;; DEFAULT-VALUES.

(define (/pmacro-process-args-1 arg-spec default-values args)
  (if (and (pair? args) (keyword? (car args)))
      (/pmacro-process-keyworded-args arg-spec default-values args)
      args)
)

;; Subroutine of /pmacro-apply,/smacro-apply to simplify them.
;; Process the arguments, verify the correct number is present.

(define (/pmacro-process-args macro args)
  (let ((arg-spec (/pmacro-arg-spec macro))
	(default-values (/pmacro-default-values macro)))
    (let ((processed-args (/pmacro-process-args-1 arg-spec default-values args)))
      (if (not (num-args-ok? (length processed-args) arg-spec))
	  (/pmacro-error (string-append
			  "wrong number of arguments to pmacro "
			  (with-output-to-string
			    (lambda ()
			      (write (cons (/pmacro-name macro)
					   (/pmacro-arg-spec macro))))))
			 args))
      processed-args))
)

;; Invoke a pmacro.

(define (/pmacro-apply macro args)
  (apply (/pmacro-transformer macro)
	 (/pmacro-process-args macro args))
)

;; Invoke a syntactic-form pmacro.
;; ENV, LOC are handed down from /pmacro-expand.

(define (/smacro-apply macro args env loc)
  (apply (/pmacro-transformer macro)
	 (cons loc (cons env (/pmacro-process-args macro args))))
)

;; Expand expression EXP using ENV, an alist of variable assignments.
;; LOC is the location stack thus far.

(define (/pmacro-expand exp env loc)

  (define cep (current-error-port))

  ;; If the symbol is in `env', return its value.
  ;; Otherwise see if symbol is a globally defined pmacro.
  ;; Otherwise return the symbol unchanged.

  (define (scan-symbol sym)
    (let ((val (/pmacro-env-ref env sym)))
      (if val
	  (cdr val) ;; cdr is value of (name . value) pair
	  (let ((val (/pmacro-lookup sym)))
	    (if val
		;; Symbol is a pmacro.
		;; If this is a procedural pmacro, let caller perform expansion.
		;; Otherwise, return the pmacro's value.
		(if (procedure? (/pmacro-transformer val))
		    val
		    (/pmacro-transformer val))
		;; Return symbol unchanged.
		sym)))))

  ;; See if (car exp) is a pmacro.
  ;; Return pmacro or #f.

  (define (check-pmacro exp)
    (if /pmacro-debug?
	(begin
	  (display "Checking for pmacro: " cep)
	  (write exp cep)
	  (newline cep)))
    (and (/pmacro? (car exp)) (car exp)))

  ;; Subroutine of scan-list to simplify it.
  ;; Macro expand EXP which is known to be a non-null list.
  ;; LOC is the location stack thus far.

  (define (scan-list1 exp loc)
    ;; Check for syntactic forms.
    ;; They are handled differently in that we leave it to the transformer
    ;; routine to evaluate the arguments.
    ;; Note that we also don't support passing syntactic form functions
    ;; as arguments: We look up (car exp) here, not its expansion.
    (let ((sform (/smacro-lookup (car exp))))
      (if sform
	  (begin
	    ;; ??? Is it useful to trace these?
	    (/smacro-apply sform (cdr exp) env loc))
	  ;; Not a syntactic form.
	  ;; See if we have a pmacro.  Do this before evaluating all the
	  ;; arguments (even though we will eventually evaluate all the
	  ;; arguments before invoking the pmacro) so that tracing is more
	  ;; legible (we print the expression we're about to evaluate *before*
	  ;; we evaluate its arguments).
	  (let ((scanned-car (scan (car exp) loc)))
	    (if (/pmacro? scanned-car)
		(begin
		  ;; Trace expansion here, we know we have a pmacro.
		  (if /pmacro-trace?
		      (let ((src-props (source-properties exp))
			    (indent (spaces (* 2 (length (location-list loc))))))
			;; We use `write' to display `exp' to see strings quoted.
			(display indent cep)
			(display "Expanding: " cep)
			(write exp cep)
			(newline cep)
			(display indent cep)
			(display "      env: " cep)
			(write env cep)
			(newline cep)
			(if (not (null? src-props))
			    (begin
			      (display indent cep)
			      (display " location: " cep)
			      (display (source-properties-location->string src-props) cep)
			      (newline cep)))))
		  ;; Evaluate all the arguments before invoking the pmacro.
		  (let* ((scanned-args (map (lambda (e) (scan e loc))
					    (cdr exp)))
			 (result (if (procedure? (/pmacro-transformer scanned-car))
				     (/pmacro-apply scanned-car scanned-args)
				     (cons (/pmacro-transformer scanned-car) scanned-args))))
		    (if /pmacro-trace?
			(let ((indent (spaces (* 2 (length (location-list loc))))))
			  (display indent cep)
			  (display "   result: " cep)
			  (write result cep)
			  (newline cep)))
		    result))
		;; Not a pmacro.
		(cons scanned-car (map (lambda (e) (scan e loc))
				       (cdr exp))))))))

  ;; Macro expand EXP which is known to be a non-null list.
  ;; LOC is the location stack thus far.
  ;;
  ;; This uses scan-list1 to do the real work, this handles location tracking.

  (define (scan-list exp loc)
    (let ((src-props (source-properties exp))
	  (new-loc loc))
      (if (not (null? src-props))
	  (let ((file (assq-ref src-props 'filename))
		(line (assq-ref src-props 'line))
		(column (assq-ref src-props 'column)))
	    (set! new-loc (location-push-single loc file line column #f))))
      (let ((result (scan-list1 exp new-loc)))
	(if (pair? result) ;; pair? -> cheap non-null-list?
	    (begin
	      ;; Copy source location to new expression.
	      (if (null? (source-properties result))
		  (set-source-properties! result src-props))
	      (let ((loc-prop (location-property result)))
		(if loc-prop
		    (location-property-set! result (location-push new-loc loc-prop))
		    (location-property-set! result new-loc)))))
	result)))

  ;; Scan EXP, an arbitrary value.
  ;; LOC is the location stack thus far.

  (define (scan exp loc)
    (let ((result (cond ((symbol? exp)
			 (scan-symbol exp))
			((pair? exp) ;; pair? -> cheap non-null-list?
			 (scan-list exp loc))
			;; Not a symbol or expression, return unchanged.
			(else
			 exp))))
      ;; Re-examining `result' to see if it is another pmacro invocation
      ;; allows doing things like ((%sym a b c) arg1 arg2)
      ;; where `abc' is a pmacro.  Scheme doesn't work this way, but then
      ;; this is CGEN.
      (if (symbol? result) (scan-symbol result) result)))

  (scan exp loc)
)

;; Return the argument spec from ARGS.
;; ARGS is a [possibly improper] list of `symbol' or `(symbol default-value)'
;; elements.  For varargs pmacros, ARGS must be an improper list
;; (e.g. (a b . c)) with the last element being a symbol.

(define (/pmacro-get-arg-spec args)
  (let ((parse-arg
	 (lambda (arg)
	   (cond ((symbol? arg)
		  arg)
		 ((and (pair? arg) (symbol? (car arg)))
		  (car arg))
		 (else
		  (/pmacro-error "argument not `symbol' or `(symbol . default-value)'"
				 arg))))))
    (if (list? args)
	(map parse-arg args)
	(letrec ((parse-improper-list
		  (lambda (args)
		    (cond ((symbol? args)
			   args)
			  ((pair? args)
			   (cons (parse-arg (car args))
				 (parse-improper-list (cdr args))))
			  (else
			   (/pmacro-error "argument not `symbol' or `(symbol . default-value)'"
					  args))))))
	  (parse-improper-list args))))
)

;; Return the default values specified in ARGS.
;; The result is an alist of (#:arg-name . default-value) elements.
;; ARGS is a [possibly improper] list of `symbol' or `(symbol . default-value)'
;; elements.  For varargs pmacros, ARGS must be an improper list
;; (e.g. (a b . c)) with the last element being a symbol.
;; Unspecified default values are recorded as #f.

(define (/pmacro-get-default-values args)
  (let ((parse-arg
	 (lambda (arg)
	   (cond ((symbol? arg)
		  (cons (symbol->keyword arg) #f))
		 ((and (pair? arg) (symbol? (car arg)))
		  (cons (symbol->keyword (car arg)) (cdr arg)))
		 (else
		  (/pmacro-error "argument not `symbol' or `(symbol . default-value)'"
				 arg))))))
    (if (list? args)
	(map parse-arg args)
	(letrec ((parse-improper-list
		  (lambda (args)
		    (cond ((symbol? args)
			   (cons (parse-arg args) nil))
			  ((pair? args)
			   (cons (parse-arg (car args))
				 (parse-improper-list (cdr args))))
			  (else
			   (/pmacro-error "argument not `symbol' or `(symbol . default-value)'"
					  args))))))
	  (parse-improper-list args))))
)

;; Build a procedure that performs a pmacro expansion.

;; Earlier version, doesn't work with LOC as a <location> object,
;; COS objects don't pass through eval1.
;(define (/pmacro-build-lambda prev-env params expansion)
;;  (eval1 `(lambda ,params
;;	    (/pmacro-expand ',expansion
;;			    (/pmacro-env-make ',prev-env
;;					      ',params (list ,@@params))))
;;)

(define (/pmacro-build-lambda loc prev-env params expansion)
  (lambda args
    (/pmacro-expand expansion
		    (/pmacro-env-make loc prev-env params args)
		    loc))
)

;; While using `define-macro' seems preferable, boot-9.scm uses it and
;; I'd rather not risk a collision.  I could of course make the association
;; during parsing, maybe later.
;; On the other hand, calling them pmacros removes all ambiguity.
;; In the end the ambiguity removal is the deciding win.
;;
;; The syntax is one of:
;; (define-pmacro symbol expansion)
;; (define-pmacro symbol ["comment"] expansion)
;; (define-pmacro (name args ...) expansion)
;; (define-pmacro (name args ...) "documentation" expansion)
;;
;; If `expansion' is the name of a pmacro, its value is used (rather than its
;; name).
;; ??? The goal here is to follow Scheme's define/lambda, but not all variants
;; are supported yet.  There's also the difference that we treat undefined
;; symbols as being themselves (i.e. "self quoting" so-to-speak).
;;
;; ??? We may want user-definable "syntactic" pmacros some day.  Later.

(define (define-pmacro header arg1 . arg-rest)
  (if (and (not (symbol? header))
	   (not (list? header)))
      (/pmacro-error "invalid pmacro header" header))
  (let ((name (if (symbol? header) header (car header)))
	(arg-spec (if (symbol? header) #f (/pmacro-get-arg-spec (cdr header))))
	(default-values (if (symbol? header) #f (/pmacro-get-default-values (cdr header))))
	(comment (if (null? arg-rest) "" arg1))
	(expansion (if (null? arg-rest) arg1 (car arg-rest))))
    ;;(if (> (length arg-rest) 1)
	;;(/pmacro-error "extraneous arguments to define-pmacro" (cdr arg-rest)))
    ;;(if (not (string? comment))
	;;(/pmacro-error "invalid pmacro comment, expected string" comment))
    (if (symbol? header)
	(if (symbol? expansion)
	    (let ((maybe-pmacro (/pmacro-lookup expansion)))
	      (if maybe-pmacro
		  (/pmacro-set! name
				(/pmacro-make name
					      (/pmacro-arg-spec maybe-pmacro)
					      (/pmacro-default-values maybe-pmacro)
					      #f ;; syntactic-form?
					      (/pmacro-transformer maybe-pmacro)
					      comment))
		  (/pmacro-set! name (/pmacro-make name #f #f #f expansion comment))))
	    (/pmacro-set! name (/pmacro-make name #f #f #f expansion comment)))
	(/pmacro-set! name
		      (/pmacro-make name arg-spec default-values #f
				    (/pmacro-build-lambda (current-reader-location)
							  nil
							  arg-spec
							  expansion)
				    comment))))
    *UNSPECIFIED*
)

;; Expand any pmacros in EXPR.
;; LOC is the <location> of EXPR.

(define (pmacro-expand expr loc)
  (/pmacro-expand expr '() loc)
)

;; Debugging routine to trace pmacro expansion.

(define (pmacro-trace expr loc)
  ;; FIXME: Need unwind protection.
  (let ((old-trace /pmacro-trace?)
	(src-props (and (pair? expr) (source-properties expr)))
	(cep (current-error-port)))
    (set! /pmacro-trace? #t)
    ;; We use `write' to display `expr' to see strings quoted.
    (display "Pmacro expanding: " cep) (write expr cep) (newline cep)
    ;;(display "Top level env: " cep) (display nil cep) (newline cep)
    (display "Pmacro location: " cep)
    (if (and src-props (not (null? src-props)))
	(display (source-properties-location->string src-props) cep)
	(display (single-location->string (location-top loc)) cep))
    (newline cep)
    (let ((result (/pmacro-expand expr '() loc)))
      (display "Pmacro result: " cep) (write result cep) (newline cep)
      (set! /pmacro-trace? old-trace)
      result))
)

;; Debugging utility to expand a pmacro, with no initial source location.

(define (pmacro-dump expr)
  (/pmacro-expand expr '() (unspecified-location))
)

;; Expand any pmacros in EXPR, printing various debugging messages.
;; This does not process %exec.

(define (pmacro-debug expr)
  ;; FIXME: Need unwind protection.
  (let ((old-debug /pmacro-debug?))
    (set! /pmacro-debug? #t)
    (let ((result (pmacro-trace expr (unspecified-location))))
      (set! /pmacro-debug? old-debug)
      result))
)

;; Builtin pmacros.

;; (%sym symbol1 symbol2 ...) - symbol-append, auto-convert numbers

(define /pmacro-builtin-sym
  (lambda args
    (string->symbol
     (apply string-append
	    (map (lambda (elm)
		   (cond ((number? elm) (number->string elm))
			 ((symbol? elm) (symbol->string elm))
			 ((string? elm) elm)
			 (else
			  (/pmacro-error "invalid argument to %sym" elm))))
		 args))))
)

;; (%str string1 string2 ...) - string-append, auto-convert numbers

(define /pmacro-builtin-str
  (lambda args
    (apply string-append
	   (map (lambda (elm)
		  (cond ((number? elm) (number->string elm))
			((symbol? elm) (symbol->string elm))
			((string? elm) elm)
			(else
			 (/pmacro-error "invalid argument to %str" elm))))
		args)))
)

;; (%hex number [width]) - convert number to hex string
;; WIDTH, if present, is the number of characters in the result, beginning
;; from the least significant digit.

(define (/pmacro-builtin-hex num . width)
  (if (> (length width) 1)
      (/pmacro-error "wrong number of arguments to %hex"
		     (cons '%hex (cons num width))))
  (let ((str (number->string num 16)))
    (if (null? width)
	str
	(let ((len (string-length str)))
	  (substring (string-append (make-string (car width) #\0) str)
		     len (+ len (car width))))))
)

;; (%upcase string) - convert a string or symbol to uppercase

(define (/pmacro-builtin-upcase str)
  (cond
   ((string? str) (string-upcase str))
   ((symbol? str) (string->symbol (string-upcase (symbol->string str))))
   (else (/pmacro-error "invalid argument to %upcase" str)))
)

;; (%downcase string) - convert a string or symbol to lowercase

(define (/pmacro-builtin-downcase str)
  (cond
   ((string? str) (string-downcase str))
   ((symbol? str) (string->symbol (string-downcase (symbol->string str))))
   (else (/pmacro-error "invalid argument to %downcase" str)))
)

;; (%substring string start end) - get part of a string
;; `end' can be the symbol `end'.

(define (/pmacro-builtin-substring str start end)
  (if (not (integer? start)) ;; FIXME: non-negative-integer
      (/pmacro-error "start not an integer" start))
  (if (and (not (integer? end))
	   (not (eq? end 'end)))
      (/pmacro-error "end not an integer nor symbol `end'" end))
  (cond ((string? str)
	 (if (eq? end 'end)
	     (substring str start)
	     (substring str start end)))
	((symbol? str)
	 (if (eq? end 'end)
	     (string->symbol (substring (symbol->string str) start))
	     (string->symbol (substring (symbol->string str) start end))))
	(else
	 (/pmacro-error "invalid argument to %substring" str)))
)

;; %splice - splicing support
;; Splice lists into the outer list.
;;
;; E.g. (define-pmacro '(splice-test a b c) '(%splice a (%unsplice b) c))
;; (pmacro-expand '(splice-test (1 (2) 3))) --> (1 2 3)
;;
;; Similar to `(1 ,@@'(2) 3) in Scheme, though the terminology is slightly
;; different (??? may need to revisit).  In Scheme there's quasi-quote,
;; unquote, unquote-splicing.  Here we have splice, unsplice; with the proviso
;; that pmacros don't have the concept of "quoting", thus all subexpressions
;; are macro-expanded first, before performing any unsplicing.
;; [??? Some may want a quoting facility, but I'd like to defer adding it as
;; long as possible (and ideally never add it).]
;;
;; NOTE: The implementation relies on %unsplice being undefined so that
;; (%unsplice (42)) is expanded unchanged.

(define /pmacro-builtin-splice
  (lambda arg-list
    ;; ??? Not the most efficient implementation.
    (let* ((unsplice-str (if (rtl-version-at-least? 0 9) "%unsplice" ".unsplice"))
	   (unsplice-sym (string->symbol unsplice-str)))
      (let loop ((arg-list arg-list) (result '()))
	(cond ((null? arg-list) result)
	      ((and (pair? (car arg-list)) (eq? unsplice-sym (caar arg-list)))
	       (if (= (length (car arg-list)) 2)
		   (if (list? (cadar arg-list))
		       (loop (cdr arg-list) (append result (cadar arg-list)))
		       (/pmacro-error (string-append "argument to " unsplice-str " must be a list")
				      (car arg-list)))
		   (/pmacro-error (string-append "wrong number of arguments to " unsplice-str)
				  (car arg-list))))
	      (else
	       (loop (cdr arg-list) (append result (list (car arg-list)))))))))
)

;; %iota
;; Usage:
;; (%iota count)            ;; start=0, incr=1
;; (%iota count start)      ;; incr=1
;; (%iota count start incr)

(define (/pmacro-builtin-iota count . start-incr)
  (if (> (length start-incr) 2)
      (/pmacro-error "wrong number of arguments to %iota"
		     (cons '%iota (cons count start-incr))))
  (if (< count 0)
      (/pmacro-error "count must be non-negative"
		     (cons '%iota (cons count start-incr))))
  (let ((start (if (pair? start-incr) (car start-incr) 0))
	(incr (if (= (length start-incr) 2) (cadr start-incr) 1)))
    (let loop ((i start) (count count) (result '()))
      (if (= count 0)
	  (reverse! result)
	  (loop (+ i incr) (- count 1) (cons i result)))))
)

;; (%map pmacro arg1 . arg-rest)

(define (/pmacro-builtin-map pmacro arg1 . arg-rest)
  (if (not (/pmacro? pmacro))
      (/pmacro-error "not a pmacro" pmacro))
  (let ((transformer (/pmacro-transformer pmacro)))
    (if (not (procedure? transformer))
	(/pmacro-error "not a procedural pmacro" pmacro))
    (apply map (cons transformer (cons arg1 arg-rest))))
)

;; (%for-each pmacro arg1 . arg-rest)

(define (/pmacro-builtin-for-each pmacro arg1 . arg-rest)
  (if (not (/pmacro? pmacro))
      (/pmacro-error "not a pmacro" pmacro))
  (let ((transformer (/pmacro-transformer pmacro)))
    (if (not (procedure? transformer))
	(/pmacro-error "not a procedural pmacro" pmacro))
    (apply for-each (cons transformer (cons arg1 arg-rest)))
    nil) ;; need to return something the reader will accept and ignore
)

;; (%eval expr)
;; NOTE: This is implemented as a syntactic form in order to get ENV and LOC.
;; That's an implementation detail, and this is not really a syntactic form.
;;
;; ??? I debated whether to call this %expand, %eval has been a source of
;; confusion/headaches.

(define (/pmacro-builtin-eval loc env expr)
  ;; /pmacro-expand is invoked twice because we're implemented as a syntactic
  ;; form:  We *want* to be passed an evaluated expression, and then we
  ;; re-evaluate it.  But syntactic forms pass parameters unevaluated, so we
  ;; have to do the first one ourselves.
  (/pmacro-expand (/pmacro-expand expr env loc) env loc)
)

;; (%exec expr)

(define (/pmacro-builtin-exec expr)
  ;; If we're expanding pmacros for debugging purposes, don't execute,
  ;; just return unchanged.
  (if /pmacro-debug?
      (list '%exec expr)
      (begin
	(reader-process-expanded! expr)
	nil)) ;; need to return something the reader will accept and ignore
)

;; (%apply pmacro-name arg)

(define (/pmacro-builtin-apply pmacro arg-list)
  (if (not (/pmacro? pmacro))
      (/pmacro-error "not a pmacro" pmacro))
  (let ((transformer (/pmacro-transformer pmacro)))
    (if (not (procedure? transformer))
	(/pmacro-error "not a procedural pmacro" pmacro))
    (apply transformer arg-list))
)

;; (%pmacro (arg-list) expansion)
;; NOTE: syntactic form

(define (/pmacro-builtin-pmacro loc env params expansion)
  ;; ??? Prohibiting improper lists seems unnecessarily restrictive here.
  ;; e.g. (define (foo bar . baz) ...)
  (if (not (list? params))
      (/pmacro-error "%pmacro parameter-spec is not a list" params))
  (/pmacro-make '%anonymous params #f #f
		(/pmacro-build-lambda loc env params expansion) "")
)

;; (%pmacro? arg)

(define (/pmacro-builtin-pmacro? arg)
  (/pmacro? arg)
)

;; (%let (var-list) expr1 . expr-rest)
;; NOTE: syntactic form

(define (/pmacro-builtin-let loc env locals expr1 . expr-rest)
  (if (not (list? locals))
      (/pmacro-error "locals is not a list" locals))
  (if (not (all-true? (map (lambda (l)
			     (and (list? l)
				  (= (length l) 2)
				  (symbol? (car l))))
			   locals)))
      (/pmacro-error "syntax error in locals list" locals))
  (let* ((evald-locals (map (lambda (l)
			      (cons (car l) (/pmacro-expand (cadr l) env loc)))
			    locals))
	 (new-env (append! evald-locals env)))
    (/pmacro-expand-expr-list (cons expr1 expr-rest) new-env loc))
)

;; (%let* (var-list) expr1 . expr-rest)
;; NOTE: syntactic form

(define (/pmacro-builtin-let* loc env locals expr1 . expr-rest)
  (if (not (list? locals))
      (/pmacro-error "locals is not a list" locals))
  (if (not (all-true? (map (lambda (l)
			     (and (list? l)
				  (= (length l) 2)
				  (symbol? (car l))))
			   locals)))
      (/pmacro-error "syntax error in locals list" locals))
  (let loop ((locals locals) (new-env env))
    (if (null? locals)
	(/pmacro-expand-expr-list (cons expr1 expr-rest) new-env loc)
	(loop (cdr locals) (acons (caar locals)
				  (/pmacro-expand (cadar locals) new-env loc)
				  new-env))))
)

;; (%if expr then [else])
;; NOTE: syntactic form

(define (/pmacro-builtin-if loc env expr then-clause . else-clause)
  (case (length else-clause)
    ((0) (if (/pmacro-expand expr env loc)
	     (/pmacro-expand then-clause env loc)
	     nil))
    ((1) (if (/pmacro-expand expr env loc)
	     (/pmacro-expand then-clause env loc)
	     (/pmacro-expand (car else-clause) env loc)))
    (else (/pmacro-error "too many elements in else-clause, expecting 0 or 1" else-clause)))
)

;; (%case expr ((case-list1) stmt) [case-expr-stmt-list] [(else stmt)])
;; NOTE: syntactic form
;; NOTE: this uses "member" for case comparison (Scheme uses memq I think)

(define (/pmacro-builtin-case loc env expr case1 . rest)
  (let ((evald-expr (/pmacro-expand expr env loc)))
    (let loop ((cases (cons case1 rest)))
      (if (null? cases)
	  nil
	  (begin
	    (if (not (list? (car cases)))
		(/pmacro-error "case statement not a list" (car cases)))
	    (if (= (length (car cases)) 1)
		(/pmacro-error "case statement has case but no expr" (car cases)))
	    (if (and (not (eq? (caar cases) 'else))
		     (not (list? (caar cases))))
		(/pmacro-error "case must be \"else\" or list of choices" (caar cases)))
	    (cond ((eq? (caar cases) 'else)
		   (/pmacro-expand-expr-list (cdar cases) env loc))
		  ((member evald-expr (caar cases))
		   (/pmacro-expand-expr-list (cdar cases) env loc))
		  (else
		   (loop (cdr cases))))))))
)

;; (%cond (expr stmt) [(cond-expr-stmt-list)] [(else stmt)])
;; NOTE: syntactic form

(define (/pmacro-builtin-cond loc env expr1 . rest)
  (let loop ((exprs (cons expr1 rest)))
    (cond ((null? exprs)
	   nil)
	  ((eq? (car exprs) 'else)
	   (/pmacro-expand-expr-list (cdar exprs) env loc))
	  (else
	   (let ((evald-expr (/pmacro-expand (caar exprs) env loc)))
	     (if evald-expr
		 (/pmacro-expand-expr-list (cdar exprs) env loc)
		 (loop (cdr exprs)))))))
)

;; (%begin . stmt-list)
;; NOTE: syntactic form

(define (/pmacro-builtin-begin loc env . rest)
  (/pmacro-expand-expr-list rest env loc)
)

;; (%print . expr)
;; Strings have quotes removed.

(define (/pmacro-builtin-print . exprs)
  (apply message exprs)
  nil ;; need to return something the reader will accept and ignore
)

;; (%dump expr)
;; Strings do not have quotes removed.

(define (/pmacro-builtin-dump expr)
  (write expr (current-error-port))
  nil ;; need to return something the reader will accept and ignore
)

;; (%error . expr)

(define (/pmacro-builtin-error . exprs)
  (apply error exprs)
)

;; (%list expr1 ...)

(define (/pmacro-builtin-list . exprs)
  exprs
)

;; (%ref expr index)

(define (/pmacro-builtin-ref l n)
  (if (not (list? l))
      (/pmacro-error "invalid arg for %ref, expected list" l))
  (if (not (integer? n)) ;; FIXME: call non-negative-integer?
      (/pmacro-error "invalid arg for %ref, expected non-negative integer" n))
  (list-ref l n)
)

;; (%length x)

(define (/pmacro-builtin-length x)
  (cond ((symbol? x) (string-length (symbol->string x)))
	((string? x) (string-length x))
	((list? x) (length x))
	(else
	 (/pmacro-error "invalid arg for %length, expected symbol, string, or list" x)))
)

;; (%replicate n expr)

(define (/pmacro-builtin-replicate n expr)
  (if (not (integer? n)) ;; FIXME: call non-negative-integer?
      (/pmacro-error "invalid arg for %replicate, expected non-negative integer" n))
  (make-list n expr)
)

;; (%find pred l)

(define (/pmacro-builtin-find pred l)
  (if (not (/pmacro? pred))
      (/pmacro-error "not a pmacro" pred))
  (if (not (list? l))
      (/pmacro-error "not a list" l))
  (let ((transformer (/pmacro-transformer pred)))
    (if (not (procedure? transformer))
	(/pmacro-error "not a procedural macro" pred))
    (find transformer l))
)

;; (%equal? x y)

(define (/pmacro-builtin-equal? x y)
  (equal? x y)
)

;; (%andif . rest)
;; NOTE: syntactic form
;; Elements of EXPRS are evaluated one at a time.
;; Unprocessed elements are not evaluated.

(define (/pmacro-builtin-andif loc env . exprs)
  (if (null? exprs)
      #t
      (let loop ((exprs exprs))
	(let ((evald-expr (/pmacro-expand (car exprs) env loc)))
	  (cond ((null? (cdr exprs)) evald-expr)
		(evald-expr (loop (cdr exprs)))
		(else #f)))))
)

;; (%orif . rest)
;; NOTE: syntactic form
;; Elements of EXPRS are evaluated one at a time.
;; Unprocessed elements are not evaluated.

(define (/pmacro-builtin-orif loc env . exprs)
  (let loop ((exprs exprs))
    (if (null? exprs)
	#f
	(let ((evald-expr (/pmacro-expand (car exprs) env loc)))
	  (if evald-expr
	      evald-expr
	      (loop (cdr exprs))))))
)

;; (%not expr)

(define (/pmacro-builtin-not x)
  (not x)
)

;; Verify x,y are compatible for eq/ne comparisons.

(define (/pmacro-compatible-for-equality x y)
  (or (and (symbol? x) (symbol? y))
      (and (string? x) (string? y))
      (and (number? x) (number? y)))
)

;; (%eq expr)

(define (/pmacro-builtin-eq x y)
  (cond ((symbol? x)
	 (if (symbol? y)
	     (eq? x y)
	     (/pmacro-error "incompatible args for %eq, expected symbol" y)))
	((string? x)
	 (if (string? y)
	     (string=? x y)
	     (/pmacro-error "incompatible args for %eq, expected string" y)))
	((number? x)
	 (if (number? y)
	     (= x y)
	     (/pmacro-error "incompatible args for %eq, expected number" y)))
	(else
	 (/pmacro-error "unsupported args for %eq" (list x y))))
)

;; (%ne expr)

(define (/pmacro-builtin-ne x y)
  (cond ((symbol? x)
	 (if (symbol? y)
	     (not (eq? x y))
	     (/pmacro-error "incompatible args for %ne, expected symbol" y)))
	((string? x)
	 (if (string? y)
	     (not (string=? x y))
	     (/pmacro-error "incompatible args for %ne, expected string" y)))
	((number? x)
	 (if (number? y)
	     (not (= x y))
	     (/pmacro-error "incompatible args for %ne, expected number" y)))
	(else
	 (/pmacro-error "unsupported args for %ne" (list x y))))
)

;; (%lt expr)

(define (/pmacro-builtin-lt x y)
  (/pmacro-verify-number "%lt" x)
  (/pmacro-verify-number "%lt" y)
  (< x y)
)

;; (%gt expr)

(define (/pmacro-builtin-gt x y)
  (/pmacro-verify-number "%gt" x)
  (/pmacro-verify-number "%gt" y)
  (> x y)
)

;; (%le expr)

(define (/pmacro-builtin-le x y)
  (/pmacro-verify-number "%le" x)
  (/pmacro-verify-number "%le" y)
  (<= x y)
)

;; (%ge expr)

(define (/pmacro-builtin-ge x y)
  (/pmacro-verify-number "%ge" x)
  (/pmacro-verify-number "%ge" y)
  (>= x y)
)

;; (%add x y)

(define (/pmacro-builtin-add x y)
  (/pmacro-verify-number "%add" x)
  (/pmacro-verify-number "%add" y)
  (+ x y)
)

;; (%sub x y)

(define (/pmacro-builtin-sub x y)
  (/pmacro-verify-number "%sub" x)
  (/pmacro-verify-number "%sub" y)
  (- x y)
)

;; (%mul x y)

(define (/pmacro-builtin-mul x y)
  (/pmacro-verify-number "%mul" x)
  (/pmacro-verify-number "%mul" y)
  (* x y)
)

;; (%div x y) - integer division

(define (/pmacro-builtin-div x y)
  (/pmacro-verify-integer "%div" x)
  (/pmacro-verify-integer "%div" y)
  (quotient x y)
)

;; (%rem x y) - integer remainder
;; ??? Need to decide behavior.

(define (/pmacro-builtin-rem x y)
  (/pmacro-verify-integer "%rem" x)
  (/pmacro-verify-integer "%rem" y)
  (remainder x y)
)

;; (%sll x n) - shift left logical

(define (/pmacro-builtin-sll x n)
  (/pmacro-verify-integer "%sll" x)
  (/pmacro-verify-non-negative-integer "%sll" n)
  (ash x n)
)

;; (%srl x n) - shift right logical
;; X must be non-negative, otherwise behavior is undefined.
;; [Unless we introduce a size argument: How do you logical shift right
;; an arbitrary precision negative number?]

(define (/pmacro-builtin-srl x n)
  (/pmacro-verify-non-negative-integer "%srl" x)
  (/pmacro-verify-non-negative-integer "%srl" n)
  (ash x (- n))
)

;; (%sra x n) - shift right arithmetic

(define (/pmacro-builtin-sra x n)
  (/pmacro-verify-integer "%sra" x)
  (/pmacro-verify-non-negative-integer "%sra" n)
  (ash x (- n))
)

;; (%and x y) - bitwise and

(define (/pmacro-builtin-and x y)
  (/pmacro-verify-integer "%and" x)
  (/pmacro-verify-integer "%and" y)
  (logand x y)
)

;; (%or x y) - bitwise or

(define (/pmacro-builtin-or x y)
  (/pmacro-verify-integer "%or" x)
  (/pmacro-verify-integer "%or" y)
  (logior x y)
)

;; (%xor x y) - bitwise xor

(define (/pmacro-builtin-xor x y)
  (/pmacro-verify-integer "%xor" x)
  (/pmacro-verify-integer "%xor" y)
  (logxor x y)
)

;; (%inv x) - bitwise invert

(define (/pmacro-builtin-inv x)
  (/pmacro-verify-integer "%inv" x)
  (lognot x)
)

;; (%car expr)

(define (/pmacro-builtin-car l)
  (if (pair? l)
      (car l)
      (/pmacro-error "invalid arg for %car, expected pair" l))
)

;; (%cdr expr)

(define (/pmacro-builtin-cdr l)
  (if (pair? l)
      (cdr l)
      (/pmacro-error "invalid arg for %cdr, expected pair" l))
)

;; (%caar expr)

(define (/pmacro-builtin-caar l)
  (if (and (pair? l) (pair? (car l)))
      (caar l)
      (/pmacro-error "invalid arg for %caar" l))
)

;; (%cadr expr)

(define (/pmacro-builtin-cadr l)
  (if (and (pair? l) (pair? (cdr l)))
      (cadr l)
      (/pmacro-error "invalid arg for %cadr" l))
)

;; (%cdar expr)

(define (/pmacro-builtin-cdar l)
  (if (and (pair? l) (pair? (car l)))
      (cdar l)
      (/pmacro-error "invalid arg for %cdar" l))
)

;; (%cddr expr)

(define (/pmacro-builtin-cddr l)
  (if (and (pair? l) (pair? (cdr l)))
      (cddr l)
      (/pmacro-error "invalid arg for %cddr" l))
)

;; (%internal-test expr)
;; This is an internal builtin for use by the testsuite.
;; EXPR is a Scheme expression that is executed to verify proper
;; behaviour of something.  It must return #f for FAIL, non-#f for PASS.
;; The result is #f for FAIL, #t for PASS.
;; This must be used in an expression, it is not sufficient to do
;; (%internal-test mumble) because the reader will see #f or #t and complain.

(define (/pmacro-builtin-internal-test expr)
  (and (eval1 expr) #t)
)

;; Initialization.
;; If RTL-VERSION >= (0 9), install %pmacros, otherwise install .pmacros.

(define (pmacros-init! rtl-version)
  (set! /pmacro-table (make-hash-table 127))
  (set! /smacro-table (make-hash-table 41))

  ;; Predefined pmacros.

  (let ((macros
	 ;; name arg-spec syntactic? function description
	 (list
	  (list 'sym 'symbols #f /pmacro-builtin-sym "symbol-append")
	  (list 'str 'strings #f /pmacro-builtin-str "string-append")
	  (list 'hex '(number . width) #f /pmacro-builtin-hex "convert to -hex, with optional width")
	  (list 'upcase '(string) #f /pmacro-builtin-upcase "string-upcase")
	  (list 'downcase '(string) #f /pmacro-builtin-downcase "string-downcase")
	  (list 'substring '(string start end) #f /pmacro-builtin-substring "get start of a string")
	  (list 'splice 'arg-list #f /pmacro-builtin-splice "splice lists into the outer list")
	  (list 'iota '(count . start-incr) #f /pmacro-builtin-iota "iota number generator")
	  (list 'map '(pmacro list1 . rest) #f /pmacro-builtin-map "map a pmacro over a list of arguments")
	  (list 'for-each '(pmacro list1 . rest) #f /pmacro-builtin-for-each "execute a pmacro over a list of arguments")
	  (list 'eval '(expr) #t /pmacro-builtin-eval "expand(evaluate) expr")
	  (list 'exec '(expr) #f /pmacro-builtin-exec "execute expr immediately")
	  (list 'apply '(pmacro arg-list) #f /pmacro-builtin-apply "apply a pmacro to a list of arguments")
	  (list 'pmacro '(params expansion) #t /pmacro-builtin-pmacro "create a pmacro on-the-fly")
	  (list 'pmacro? '(arg) #f /pmacro-builtin-pmacro? "return true if arg is a pmacro")
	  (list 'let '(locals expr1 . rest) #t /pmacro-builtin-let "create a binding context, let-style")
	  (list 'let* '(locals expr1 . rest) #t /pmacro-builtin-let* "create a binding context, let*-style")
	  (list 'if '(expr then . else) #t /pmacro-builtin-if "if expr is true, process then, else else")
	  (list 'case '(expr case1 . rest) #t /pmacro-builtin-case "process statement that matches expr")
	  (list 'cond '(expr1 . rest) #t /pmacro-builtin-cond "process first statement whose expr succeeds")
	  (list 'begin 'rest #t /pmacro-builtin-begin "process a sequence of statements")
	  (list 'print 'exprs #f /pmacro-builtin-print "print exprs, for debugging purposes")
	  (list 'dump '(expr)  #f /pmacro-builtin-dump "dump expr, for debugging purposes")
	  (list 'error 'message #f /pmacro-builtin-error "print error message and exit")
	  (list 'list 'exprs #f /pmacro-builtin-list "return a list of exprs")
	  (list 'ref '(l n) #f /pmacro-builtin-ref "return n'th element of list l")
	  (list 'length '(x) #f /pmacro-builtin-length "return length of symbol, string, or list")
	  (list 'replicate '(n expr) #f /pmacro-builtin-replicate "return list of expr replicated n times")
	  (list 'find '(pred l) #f /pmacro-builtin-find "return elements of list l matching pred")
	  (list 'equal? '(x y) #f /pmacro-builtin-equal? "deep comparison of x and y")
	  (list 'andif 'rest #t /pmacro-builtin-andif "return first #f element, otherwise return last element")
	  (list 'orif 'rest #t /pmacro-builtin-orif "return first non-#f element found, otherwise #f")
	  (list 'not '(x) #f /pmacro-builtin-not "return !x")
	  (list 'eq '(x y) #f /pmacro-builtin-eq "return true if x == y")
	  (list 'ne '(x y) #f /pmacro-builtin-ne "return true if x != y")
	  (list 'lt '(x y) #f /pmacro-builtin-lt "return true if x < y")
	  (list 'gt '(x y) #f /pmacro-builtin-gt "return true if x > y")
	  (list 'le '(x y) #f /pmacro-builtin-le "return true if x <= y")
	  (list 'ge '(x y) #f /pmacro-builtin-ge "return true if x >= y")
	  (list 'add '(x y) #f /pmacro-builtin-add "return x + y")
	  (list 'sub '(x y) #f /pmacro-builtin-sub "return x - y")
	  (list 'mul '(x y) #f /pmacro-builtin-mul "return x * y")
	  (list 'div '(x y) #f /pmacro-builtin-div "return x / y")
	  (list 'rem '(x y) #f /pmacro-builtin-rem "return x % y")
	  (list 'sll '(x n) #f /pmacro-builtin-sll "return logical x << n")
	  (list 'srl '(x n) #f /pmacro-builtin-srl "return logical x >> n")
	  (list 'sra '(x n) #f /pmacro-builtin-sra "return arithmetic x >> n")
	  (list 'and '(x y) #f /pmacro-builtin-and "return x & y")
	  (list 'or '(x y) #f /pmacro-builtin-or "return x | y")
	  (list 'xor '(x y) #f /pmacro-builtin-xor "return x ^ y")
	  (list 'inv '(x) #f /pmacro-builtin-inv "return ~x")
	  (list 'car '(x) #f /pmacro-builtin-car "return (car x)")
	  (list 'cdr '(x) #f /pmacro-builtin-cdr "return (cdr x)")
	  (list 'caar '(x) #f /pmacro-builtin-caar "return (caar x)")
	  (list 'cadr '(x) #f /pmacro-builtin-cadr "return (cadr x)")
	  (list 'cdar '(x) #f /pmacro-builtin-cdar "return (cdar x)")
	  (list 'cddr '(x) #f /pmacro-builtin-cddr "return (cddr x)")
	  (list 'internal-test '(expr) #f /pmacro-builtin-internal-test "testsuite use only")
	  ))
	(prefix (if (member rtl-version '((0 7) (0 8)))
		    /pmacro-orig-prefix
		    /pmacro-prefix)))

    (for-each (lambda (x)
		(let ((name (list-ref x 0))
		      (arg-spec (list-ref x 1))
		      (syntactic? (list-ref x 2))
		      (pmacro (list-ref x 3))
		      (comment (list-ref x 4)))
		  (let ((full-name (string->symbol (string-append prefix (symbol->string name)))))
		    (/pmacro-set! full-name
				  (/pmacro-make full-name arg-spec #f syntactic? pmacro comment))
		    (if syntactic?
			(/smacro-set! full-name
				      (/pmacro-make full-name arg-spec #f syntactic? pmacro comment))))))

	      macros))
)
@


1.26
log
@	* pmacros.scm (pmacros-init!): New arg rtl-version, all callers
	updated.  Use %-prefix if rtl-version >= 0.9.
	* read.scm (/supported-rtl-versions): Add (0 9).
	(/rtl-version-valid?): New function.
	(/cmd-define-rtl-version): If new rtl version, reinvoke pmacros-init!.
	(/reader-expr): New function.
	(reader-process): New function.
	(/reader-process-with-loc!): Renamed from /reader-process!.
	Don't pre-expand `if' commands.
	(/cmd-if): Simplify.  Pmacro-expand test, then, else clauses here.
	Handle rtl-version-equal?, rtl-version-at-least?.
	* testsuite/Makefile.am (clean-test-files): Remove *.test.cpu*.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/pmacros-1.test: Test both . and % as prefixes.
	* testsuite/testsuite.cpu (/begin, /print, /dump): New pmacros.
	(newline, print-match, print-expr, print-thunk): Use them.
	(internal-verify): Update definition.
	* doc/rtl.texi (define-rtl-version): Document rtl version 0.9.
	(Top level conditionals): New node.
@
text
@d2 1
a2 1
;; Copyright (C) 2000, 2009 Red Hat, Inc.
@


1.25
log
@	* pmacros.scm: Follow commenting convention.  Replace change to
	$pmacro to %pmacro.  $pmacro is confusing with $ in assembler syntax.
	(/pmacro-orig-prefix, /pmacro-prefix): New globals.
@
text
@d1347 1
d1349 1
a1349 1
(define (pmacros-init!)
d1353 1
a1353 1
  ;; Some "predefined" pmacros.
d1416 4
a1419 1
	  )))
d1427 7
a1433 8
		  (for-each (lambda (prefix)
			      (let ((full-name (string->symbol (string-append prefix (symbol->string name)))))
				(/pmacro-set! full-name
					      (/pmacro-make full-name arg-spec #f syntactic? pmacro comment))
				(if syntactic?
				    (/smacro-set! full-name
						  (/pmacro-make full-name arg-spec #f syntactic? pmacro comment)))))
			    (list /pmacro-orig-prefix))))
a1435 3

;; Initialize so we're ready to use after loading.
(pmacros-init!)
@


1.24
log
@minor whitespace fix
@
text
@d1 131
a131 131
; Preprocessor-like macro support.
; Copyright (C) 2000, 2009 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.

; TODO:
; - Like C preprocessor macros, there is no scoping [one can argue
;   there should be].  Maybe in time (??? Hmmm... done?)
; - Support for multiple macro tables.

; Non-standard required routines:
; Provided by Guile:
;   make-hash-table, hashq-ref, hashq-set!, symbol-append,
;   source-properties
; Provided by CGEN:
;   location-property, location-property-set!,
;   source-properties-location->string,
;   single-location->string, location-top, unspecified-location,
;   reader-process-expanded!, num-args-ok?, *UNSPECIFIED*.

; The convention we use says `-' begins "local" objects.
; At some point this might also use the Guile module system.

; This uses Guile's source-properties system to track source location.
; The chain of macro invocations is tracked and stored in the result as
; object property "location-property".

; Exported routines:
;
; pmacro-init! - initialize the pmacro system
;
; define-pmacro - define a symbolic or procedural pmacro
;
;	(define-pmacro symbol ["comment"] expansion)
;	(define-pmacro (symbol [args]) ["comment"] (expansion))
;
; ARGS is a list of `symbol' or `(symbol default-value)' elements.
;
; pmacro-expand - expand all pmacros in an expression
;
;	(pmacro-expand expression loc)
;
; pmacro-trace - same as pmacro-expand, but trace macro expansion
;                Output is sent to current-error-port.
;
;	(pmacro-trace expression loc)
;
; pmacro-dump - expand all pmacros in an expression, for debugging purposes
;
;	(pmacro-dump expression)

; pmacro-debug - expand all pmacros in an expression,
;                printing various debugging messages.
;                This does not process $exec.
;
;	(pmacro-debug expression)

; Builtin pmacros:
;
; ($sym symbol1 symbol2 ...)          - symbolstr-append
; ($str string1 string2 ...)          - stringsym-append
; ($hex number [width])               - convert to hex string
; ($upcase string)
; ($downcase string)
; ($substring string start end)       - get part of a string
; ($splice a b ($unsplice c) d e ...) - splice list into another list
; ($iota count [start [increment]])   - number generator
; ($map pmacro arg1 . arg-rest)
; ($for-each pmacro arg1 . arg-rest)
; ($eval expr)                        - expand (or evaluate it) expr
; ($exec expr)                        - execute expr immediately
; ($apply pmacro-name arg)
; ($pmacro (arg-list) expansion)      - akin go lambda in Scheme
; ($pmacro? arg)
; ($let (var-list) expr1 . expr-rest) - akin to let in Scheme
; ($let* (var-list) expr1 . expr-rest) - akin to let* in Scheme
; ($if expr then [else])
; ($case expr ((case-list1) stmt) [case-expr-stmt-list] [(else stmt)])
; ($cond (expr stmt) [(cond-expr-stmt-list)] [(else stmt)])
; ($begin . stmt-list)
; ($print . exprs)                    - for debugging messages
; ($dump expr)                        - dump expr in readable format
; ($error . message)                  - print error message and exit
; ($list . exprs)
; ($ref l n)                          - extract the n'th element of list l
; ($length x)                         - length of symbol, string, or list
; ($replicate n expr)                 - return list of expr replicated n times
; ($find pred l)                      - return elements of list l matching pred
; ($equal? x y)                       - deep comparison
; ($andif expr . rest)                - && in C
; ($orif expr . rest)                 - || in C
; ($not expr)                         - ! in C
; ($eq x y)
; ($ne x y)
; ($lt x y)
; ($gt x y)
; ($le x y)
; ($ge x y)
; ($add x y)
; ($sub x y)
; ($mul x y)
; ($div x y)                          - integer division
; ($rem x y)                          - integer remainder
; ($sll x n)                          - shift left logical
; ($srl x n)                          - shift right logical
; ($sra x n)                          - shift right arithmetic
; ($and x y)                          - bitwise and
; ($or x y)                           - bitwise or
; ($xor x y)                          - bitwise xor
; ($inv x)                            - bitwise invert
; ($car l)
; ($cdr l)
; ($caar l)
; ($cadr l)
; ($cdar l)
; ($cddr l)
; ($internal-test expr)               - testsuite internal use only
;
; NOTE: $cons currently absent on purpose
;
; $sym and $str convert numbers to symbols/strings as necessary (base 10).
;
; $pmacro is for constructing pmacros on-the-fly, like lambda, and is currently
; only valid as arguments to other pmacros or assigned to a local in a {$let}
; or {$let*}.
;
; NOTE: While Scheme requires tail recursion to be implemented as a loop,
; we do not.  We might some day, but not today.
;
; ??? Methinks .foo isn't a valid R5RS symbol.  May need to change 
; to something else.
d133 1
a133 1
; True if doing pmacro expansion via pmacro-debug.
d135 1
a135 1
; True if doing pmacro expansion via pmacro-trace.
d138 7
a144 1
; The pmacro table.
d149 1
a149 1
; A copy of syntactic pmacros is kept separately.
d154 5
a158 5
; Marker to indicate a value is a pmacro.
; NOTE: Naming this "<pmacro>" is intentional.  It makes them look like
; objects of class <pmacro>.  However we don't use COS in part to avoid
; a dependency on COS and in part because displaying COS objects isn't well
; supported (displaying them in debugging dumps adds a lot of noise).
d161 1
a161 1
; Utilities to create and access pmacros.
d190 1
a190 1
; Error message generator.
d203 1
a203 1
; Error message generator when we have a location.
d219 1
a219 1
; Issue an error where a number was expected.
d225 1
a225 1
; Verify N is a number.
d232 1
a232 1
; Issue an error where an integer was expected.
d238 1
a238 1
; Verify N is an integer.
d245 1
a245 1
; Issue an error where a non-negative integer was expected.
d251 1
a251 1
; Verify N is a non-negative integer.
d259 2
a260 2
; Expand a list of expressions, in order.
; The result is the value of the last one.
d270 1
a270 1
; Process list of keyword/value specified arguments.
d273 1
a273 1
  ; Build a list of default values, then override ones specified in ARGS,
d277 1
a277 1
	     #f) ; done
d289 1
a289 1
    ; Ensure each element has a value.
d292 1
a292 1
	  #f ; done
d298 1
a298 1
    ; If varargs pmacro, adjust result.
d300 1
a300 1
	(map cdr result-alist) ; not varargs
d306 4
a309 4
; Process a pmacro argument list.
; ARGS is either a fully specified position dependent argument list,
; or is a list of keyword/value pairs with missing values coming from
; DEFAULT-VALUES.
d317 2
a318 2
; Subroutine of /pmacro-apply,/smacro-apply to simplify them.
; Process the arguments, verify the correct number is present.
d335 1
a335 1
; Invoke a pmacro.
d342 2
a343 2
; Invoke a syntactic-form pmacro.
; ENV, LOC are handed down from /pmacro-expand.
d484 1
a484 1
      ;; allows doing things like (($sym a b c) arg1 arg2)
d492 4
a495 4
; Return the argument spec from ARGS.
; ARGS is a [possibly improper] list of `symbol' or `(symbol default-value)'
; elements.  For varargs pmacros, ARGS must be an improper list
; (e.g. (a b . c)) with the last element being a symbol.
d522 6
a527 6
; Return the default values specified in ARGS.
; The result is an alist of (#:arg-name . default-value) elements.
; ARGS is a [possibly improper] list of `symbol' or `(symbol . default-value)'
; elements.  For varargs pmacros, ARGS must be an improper list
; (e.g. (a b . c)) with the last element being a symbol.
; Unspecified default values are recorded as #f.
d554 1
a554 1
; Build a procedure that performs a pmacro expansion.
d556 2
a557 2
; Earlier version, doesn't work with LOC as a <location> object,
; COS objects don't pass through eval1.
d559 5
a563 5
;  (eval1 `(lambda ,params
;	    (/pmacro-expand ',expansion
;			    (/pmacro-env-make ',prev-env
;					      ',params (list ,@@params))))
;)
d572 19
a590 19
; While using `define-macro' seems preferable, boot-9.scm uses it and
; I'd rather not risk a collision.  I could of course make the association
; during parsing, maybe later.
; On the other hand, calling them pmacros removes all ambiguity.
; In the end the ambiguity removal is the deciding win.
;
; The syntax is one of:
; (define-pmacro symbol expansion)
; (define-pmacro symbol ["comment"] expansion)
; (define-pmacro (name args ...) expansion)
; (define-pmacro (name args ...) "documentation" expansion)
;
; If `expansion' is the name of a pmacro, its value is used (rather than its
; name).
; ??? The goal here is to follow Scheme's define/lambda, but not all variants
; are supported yet.  There's also the difference that we treat undefined
; symbols as being themselves (i.e. "self quoting" so-to-speak).
;
; ??? We may want user-definable "syntactic" pmacros some day.  Later.
d613 1
a613 1
					      #f ; syntactic-form?
d628 2
a629 2
; Expand any pmacros in EXPR.
; LOC is the <location> of EXPR.
d635 1
a635 1
; Debugging routine to trace pmacro expansion.
d638 1
a638 1
  ; FIXME: Need unwind protection.
d657 1
a657 1
; Debugging utility to expand a pmacro, with no initial source location.
d663 2
a664 2
; Expand any pmacros in EXPR, printing various debugging messages.
; This does not process $exec.
d667 1
a667 1
  ; FIXME: Need unwind protection.
d675 1
a675 1
; Builtin pmacros.
d677 1
a677 1
; ($sym symbol1 symbol2 ...) - symbol-append, auto-convert numbers
d688 1
a688 1
			  (/pmacro-error "invalid argument to $sym" elm))))
d692 1
a692 1
; ($str string1 string2 ...) - string-append, auto-convert numbers
d702 1
a702 1
			 (/pmacro-error "invalid argument to $str" elm))))
d706 3
a708 3
; ($hex number [width]) - convert number to hex string
; WIDTH, if present, is the number of characters in the result, beginning
; from the least significant digit.
d712 2
a713 2
      (/pmacro-error "wrong number of arguments to $hex"
		     (cons '$hex (cons num width))))
d722 1
a722 1
; ($upcase string) - convert a string or symbol to uppercase
d728 1
a728 1
   (else (/pmacro-error "invalid argument to $upcase" str)))
d731 1
a731 1
; ($downcase string) - convert a string or symbol to lowercase
d737 1
a737 1
   (else (/pmacro-error "invalid argument to $downcase" str)))
d740 2
a741 2
; ($substring string start end) - get part of a string
; `end' can be the symbol `end'.
d758 1
a758 1
	 (/pmacro-error "invalid argument to $substring" str)))
d761 16
a776 16
; $splice - splicing support
; Splice lists into the outer list.
;
; E.g. (define-pmacro '(splice-test a b c) '($splice a ($unsplice b) c))
; (pmacro-expand '(splice-test (1 (2) 3))) --> (1 2 3)
;
; Similar to `(1 ,@@'(2) 3) in Scheme, though the terminology is slightly
; different (??? may need to revisit).  In Scheme there's quasi-quote,
; unquote, unquote-splicing.  Here we have splice, unsplice; with the proviso
; that pmacros don't have the concept of "quoting", thus all subexpressions
; are macro-expanded first, before performing any unsplicing.
; [??? Some may want a quoting facility, but I'd like to defer adding it as
; long as possible (and ideally never add it).]
;
; NOTE: The implementation relies on $unsplice being undefined so that
; ($unsplice (42)) is expanded unchanged.
d780 2
a781 2
    ; ??? Not the most efficient implementation.
    (let* ((unsplice-str (if (rtl-version-at-least? 0 9) "$unsplice" ".unsplice"))
d797 5
a801 5
; $iota
; Usage:
; ($iota count)            ; start=0, incr=1
; ($iota count start)      ; incr=1
; ($iota count start incr)
d805 2
a806 2
      (/pmacro-error "wrong number of arguments to $iota"
		     (cons '$iota (cons count start-incr))))
d809 1
a809 1
		     (cons '$iota (cons count start-incr))))
d818 1
a818 1
; ($map pmacro arg1 . arg-rest)
d829 1
a829 1
; ($for-each pmacro arg1 . arg-rest)
d838 1
a838 1
    nil) ; need to return something the reader will accept and ignore
d841 6
a846 6
; ($eval expr)
; NOTE: This is implemented as a syntactic form in order to get ENV and LOC.
; That's an implementation detail, and this is not really a syntactic form.
;
; ??? I debated whether to call this $expand, $eval has been a source of
; confusion/headaches.
d856 1
a856 1
; ($exec expr)
d862 1
a862 1
      (list '$exec expr)
d868 1
a868 1
; ($apply pmacro-name arg)
d879 2
a880 2
; ($pmacro (arg-list) expansion)
; NOTE: syntactic form
d886 2
a887 2
      (/pmacro-error "$pmacro parameter-spec is not a list" params))
  (/pmacro-make '$anonymous params #f #f
d891 1
a891 1
; ($pmacro? arg)
d897 2
a898 2
; ($let (var-list) expr1 . expr-rest)
; NOTE: syntactic form
d916 2
a917 2
; ($let* (var-list) expr1 . expr-rest)
; NOTE: syntactic form
d936 2
a937 2
; ($if expr then [else])
; NOTE: syntactic form
d950 3
a952 3
; ($case expr ((case-list1) stmt) [case-expr-stmt-list] [(else stmt)])
; NOTE: syntactic form
; NOTE: this uses "member" for case comparison (Scheme uses memq I think)
d975 2
a976 2
; ($cond (expr stmt) [(cond-expr-stmt-list)] [(else stmt)])
; NOTE: syntactic form
d991 2
a992 2
; ($begin . stmt-list)
; NOTE: syntactic form
d998 2
a999 2
; ($print . expr)
; Strings have quotes removed.
d1003 1
a1003 1
  nil ; need to return something the reader will accept and ignore
d1006 2
a1007 2
; ($dump expr)
; Strings do not have quotes removed.
d1011 1
a1011 1
  nil ; need to return something the reader will accept and ignore
d1014 1
a1014 1
; ($error . expr)
d1020 1
a1020 1
; ($list expr1 ...)
d1026 1
a1026 1
; ($ref expr index)
d1030 1
a1030 1
      (/pmacro-error "invalid arg for $ref, expected list" l))
d1032 1
a1032 1
      (/pmacro-error "invalid arg for $ref, expected non-negative integer" n))
d1036 1
a1036 1
; ($length x)
d1043 1
a1043 1
	 (/pmacro-error "invalid arg for $length, expected symbol, string, or list" x)))
d1046 1
a1046 1
; ($replicate n expr)
d1050 1
a1050 1
      (/pmacro-error "invalid arg for $replicate, expected non-negative integer" n))
d1054 1
a1054 1
; ($find pred l)
d1067 1
a1067 1
; ($equal? x y)
d1073 4
a1076 4
; ($andif . rest)
; NOTE: syntactic form
; Elements of EXPRS are evaluated one at a time.
; Unprocessed elements are not evaluated.
d1088 4
a1091 4
; ($orif . rest)
; NOTE: syntactic form
; Elements of EXPRS are evaluated one at a time.
; Unprocessed elements are not evaluated.
d1103 1
a1103 1
; ($not expr)
d1109 1
a1109 1
; Verify x,y are compatible for eq/ne comparisons.
d1117 1
a1117 1
; ($eq expr)
d1123 1
a1123 1
	     (/pmacro-error "incompatible args for $eq, expected symbol" y)))
d1127 1
a1127 1
	     (/pmacro-error "incompatible args for $eq, expected string" y)))
d1131 1
a1131 1
	     (/pmacro-error "incompatible args for $eq, expected number" y)))
d1133 1
a1133 1
	 (/pmacro-error "unsupported args for $eq" (list x y))))
d1136 1
a1136 1
; ($ne expr)
d1142 1
a1142 1
	     (/pmacro-error "incompatible args for $ne, expected symbol" y)))
d1146 1
a1146 1
	     (/pmacro-error "incompatible args for $ne, expected string" y)))
d1150 1
a1150 1
	     (/pmacro-error "incompatible args for $ne, expected number" y)))
d1152 1
a1152 1
	 (/pmacro-error "unsupported args for $ne" (list x y))))
d1155 1
a1155 1
; ($lt expr)
d1158 2
a1159 2
  (/pmacro-verify-number "$lt" x)
  (/pmacro-verify-number "$lt" y)
d1163 1
a1163 1
; ($gt expr)
d1166 2
a1167 2
  (/pmacro-verify-number "$gt" x)
  (/pmacro-verify-number "$gt" y)
d1171 1
a1171 1
; ($le expr)
d1174 2
a1175 2
  (/pmacro-verify-number "$le" x)
  (/pmacro-verify-number "$le" y)
d1179 1
a1179 1
; ($ge expr)
d1182 2
a1183 2
  (/pmacro-verify-number "$ge" x)
  (/pmacro-verify-number "$ge" y)
d1187 1
a1187 1
; ($add x y)
d1190 2
a1191 2
  (/pmacro-verify-number "$add" x)
  (/pmacro-verify-number "$add" y)
d1195 1
a1195 1
; ($sub x y)
d1198 2
a1199 2
  (/pmacro-verify-number "$sub" x)
  (/pmacro-verify-number "$sub" y)
d1203 1
a1203 1
; ($mul x y)
d1206 2
a1207 2
  (/pmacro-verify-number "$mul" x)
  (/pmacro-verify-number "$mul" y)
d1211 1
a1211 1
; ($div x y) - integer division
d1214 2
a1215 2
  (/pmacro-verify-integer "$div" x)
  (/pmacro-verify-integer "$div" y)
d1219 2
a1220 2
; ($rem x y) - integer remainder
; ??? Need to decide behavior.
d1223 2
a1224 2
  (/pmacro-verify-integer "$rem" x)
  (/pmacro-verify-integer "$rem" y)
d1228 1
a1228 1
; ($sll x n) - shift left logical
d1231 2
a1232 2
  (/pmacro-verify-integer "$sll" x)
  (/pmacro-verify-non-negative-integer "$sll" n)
d1236 4
a1239 4
; ($srl x n) - shift right logical
; X must be non-negative, otherwise behavior is undefined.
; [Unless we introduce a size argument: How do you logical shift right
; an arbitrary precision negative number?]
d1242 2
a1243 2
  (/pmacro-verify-non-negative-integer "$srl" x)
  (/pmacro-verify-non-negative-integer "$srl" n)
d1247 1
a1247 1
; ($sra x n) - shift right arithmetic
d1250 2
a1251 2
  (/pmacro-verify-integer "$sra" x)
  (/pmacro-verify-non-negative-integer "$sra" n)
d1255 1
a1255 1
; ($and x y) - bitwise and
d1258 2
a1259 2
  (/pmacro-verify-integer "$and" x)
  (/pmacro-verify-integer "$and" y)
d1263 1
a1263 1
; ($or x y) - bitwise or
d1266 2
a1267 2
  (/pmacro-verify-integer "$or" x)
  (/pmacro-verify-integer "$or" y)
d1271 1
a1271 1
; ($xor x y) - bitwise xor
d1274 2
a1275 2
  (/pmacro-verify-integer "$xor" x)
  (/pmacro-verify-integer "$xor" y)
d1279 1
a1279 1
; ($inv x) - bitwise invert
d1282 1
a1282 1
  (/pmacro-verify-integer "$inv" x)
d1286 1
a1286 1
; ($car expr)
d1291 1
a1291 1
      (/pmacro-error "invalid arg for $car, expected pair" l))
d1294 1
a1294 1
; ($cdr expr)
d1299 1
a1299 1
      (/pmacro-error "invalid arg for $cdr, expected pair" l))
d1302 1
a1302 1
; ($caar expr)
d1307 1
a1307 1
      (/pmacro-error "invalid arg for $caar" l))
d1310 1
a1310 1
; ($cadr expr)
d1315 1
a1315 1
      (/pmacro-error "invalid arg for $cadr" l))
d1318 1
a1318 1
; ($cdar expr)
d1323 1
a1323 1
      (/pmacro-error "invalid arg for $cdar" l))
d1326 1
a1326 1
; ($cddr expr)
d1331 1
a1331 1
      (/pmacro-error "invalid arg for $cddr" l))
d1334 7
a1340 7
; ($internal-test expr)
; This is an internal builtin for use by the testsuite.
; EXPR is a Scheme expression that is executed to verify proper
; behaviour of something.  It must return #f for FAIL, non-#f for PASS.
; The result is #f for FAIL, #t for PASS.
; This must be used in an expression, it is not sufficient to do
; ($internal-test mumble) because the reader will see #f or #t and complain.
d1346 1
a1346 1
; Initialization.
d1352 1
a1352 1
  ; Some "predefined" pmacros.
d1416 1
d1418 1
a1418 1
		(let ((name (string->symbol (string-append "." (symbol->string (list-ref x 0)))))
d1423 8
a1430 5
		  (/pmacro-set! name
				(/pmacro-make name arg-spec #f syntactic? pmacro comment))
		  (if syntactic?
		      (/smacro-set! name
				    (/pmacro-make name arg-spec #f syntactic? pmacro comment)))))
d1434 1
a1434 1
; Initialize so we're ready to use after loading.
@


1.23
log
@	* types.scm (<struct>): Delete.

	* pmacros.scm (/pmacro-env-make): New argument `loc', all callers
	updated.
	(/pmacro-loc-error): New function.

	* mach.scm (/isa-parse-decode-assist): New function.
	(/isa-parse): Call it.

	* decode.scm (/get-subopcode-value): New function.
	(/opcode-slots): Call it.
	(/fill-slot!): Add logging message.
@
text
@d1373 1
a1373 1
	  (list 'dump '(expr)  #f/pmacro-builtin-dump "dump expr, for debugging purposes")
@


1.22
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d169 1
a169 2
; Cover functions to manage an "environment" in case a need or desire for
; another method arises.
d171 7
a177 2
(define (/pmacro-env-make prev-env names values)
  (append! (map cons names values) prev-env)
d179 3
d197 16
d562 1
a562 1
		    (/pmacro-env-make prev-env params args)
@


1.21
log
@	Pmacro .equals -> .equal?
	* pmacros.scm (-pmacro-builtin-equal?): Renamed from
	-pmacro-builtin-equals.  All callers updated.
	(pmacros-init!): Rename .equals to .equal?.
	* doc/pmacros.texi: Update.
	* testsuite/pmacros-1.test: Update.
@
text
@d54 1
a54 1
;                This does not process .exec.
d60 58
a117 58
; (.sym symbol1 symbol2 ...)          - symbolstr-append
; (.str string1 string2 ...)          - stringsym-append
; (.hex number [width])               - convert to hex string
; (.upcase string)
; (.downcase string)
; (.substring string start end)       - get part of a string
; (.splice a b (.unsplice c) d e ...) - splice list into another list
; (.iota count [start [increment]])   - number generator
; (.map pmacro arg1 . arg-rest)
; (.for-each pmacro arg1 . arg-rest)
; (.eval expr)                        - expand (or evaluate it) expr
; (.exec expr)                        - execute expr immediately
; (.apply pmacro-name arg)
; (.pmacro (arg-list) expansion)      - akin go lambda in Scheme
; (.pmacro? arg)
; (.let (var-list) expr1 . expr-rest) - akin to let in Scheme
; (.let* (var-list) expr1 . expr-rest) - akin to let* in Scheme
; (.if expr then [else])
; (.case expr ((case-list1) stmt) [case-expr-stmt-list] [(else stmt)])
; (.cond (expr stmt) [(cond-expr-stmt-list)] [(else stmt)])
; (.begin . stmt-list)
; (.print . exprs)                    - for debugging messages
; (.dump expr)                        - dump expr in readable format
; (.error . message)                  - print error message and exit
; (.list . exprs)
; (.ref l n)                          - extract the n'th element of list l
; (.length x)                         - length of symbol, string, or list
; (.replicate n expr)                 - return list of expr replicated n times
; (.find pred l)                      - return elements of list l matching pred
; (.equal? x y)                       - deep comparison
; (.andif expr . rest)                - && in C
; (.orif expr . rest)                 - || in C
; (.not expr)                         - ! in C
; (.eq x y)
; (.ne x y)
; (.lt x y)
; (.gt x y)
; (.le x y)
; (.ge x y)
; (.add x y)
; (.sub x y)
; (.mul x y)
; (.div x y)                          - integer division
; (.rem x y)                          - integer remainder
; (.sll x n)                          - shift left logical
; (.srl x n)                          - shift right logical
; (.sra x n)                          - shift right arithmetic
; (.and x y)                          - bitwise and
; (.or x y)                           - bitwise or
; (.xor x y)                          - bitwise xor
; (.inv x)                            - bitwise invert
; (.car l)
; (.cdr l)
; (.caar l)
; (.cadr l)
; (.cdar l)
; (.cddr l)
; (.internal-test expr)               - testsuite internal use only
d119 1
a119 1
; NOTE: .cons currently absent on purpose
d121 1
a121 1
; .sym and .str convert numbers to symbols/strings as necessary (base 10).
d123 3
a125 3
; .pmacro is for constructing pmacros on-the-fly, like lambda, and is currently
; only valid as arguments to other pmacros or assigned to a local in a {.let}
; or {.let*}.
d134 1
a134 1
(define -pmacro-debug? #f)
d136 1
a136 1
(define -pmacro-trace? #f)
d139 3
a141 3
(define -pmacro-table #f)
(define (-pmacro-lookup name) (hashq-ref -pmacro-table name))
(define (-pmacro-set! name val) (hashq-set! -pmacro-table name val))
d144 3
a146 3
(define -smacro-table #f)
(define (-smacro-lookup name) (hashq-ref -smacro-table name))
(define (-smacro-set! name val) (hashq-set! -smacro-table name val))
d153 1
a153 1
(define -pmacro-marker '<pmacro>)
d156 1
a156 1
(define (-pmacro-make name arg-spec default-values
d158 1
a158 1
  (vector -pmacro-marker name arg-spec default-values
d161 7
a167 7
(define (-pmacro? x) (and (vector? x) (eq? (vector-ref x 0) -pmacro-marker)))
(define (-pmacro-name pmac) (vector-ref pmac 1))
(define (-pmacro-arg-spec pmac) (vector-ref pmac 2))
(define (-pmacro-default-values pmac) (vector-ref pmac 3))
(define (-pmacro-syntactic-form? pmac) (vector-ref pmac 4))
(define (-pmacro-transformer pmac) (vector-ref pmac 5))
(define (-pmacro-comment pmac) (vector-ref pmac 6))
d172 1
a172 1
(define (-pmacro-env-make prev-env names values)
d175 1
a175 1
(define (-pmacro-env-ref env name) (assq name env))
d179 1
a179 1
(define (-pmacro-error msg expr)
d192 2
a193 2
(define (-pmacro-expected-number op n)
  (-pmacro-error (string-append "invalid arg for " op ", expected number") n)
d198 1
a198 1
(define (-pmacro-verify-number op n)
d200 1
a200 1
      (-pmacro-expected-number op n))
d205 2
a206 2
(define (-pmacro-expected-integer op n)
  (-pmacro-error (string-append "invalid arg for " op ", expected integer") n)
d211 1
a211 1
(define (-pmacro-verify-integer op n)
d213 1
a213 1
      (-pmacro-expected-integer op n))
d218 2
a219 2
(define (-pmacro-expected-non-negative-integer op n)
  (-pmacro-error (string-append "invalid arg for " op ", expected non-negative integer") n)
d224 1
a224 1
(define (-pmacro-verify-non-negative-integer op n)
d227 1
a227 1
      (-pmacro-expected-non-negative-integer op n))
d233 1
a233 1
(define (-pmacro-expand-expr-list exprs env loc)
d236 1
a236 1
		(set! result (-pmacro-expand expr env loc)))
d243 1
a243 1
(define (-pmacro-process-keyworded-args arg-spec default-values args)
d252 1
a252 1
		   (-pmacro-error "not an argument name" (car args)))
d254 1
a254 1
		   (-pmacro-error "missing argument to #:keyword" (car args)))
d258 1
a258 1
	     (-pmacro-error "bad keyword/value argument list" args))))
d266 1
a266 1
		(-pmacro-error "argument value not specified" (caar to-scan)))
d282 1
a282 1
(define (-pmacro-process-args-1 arg-spec default-values args)
d284 1
a284 1
      (-pmacro-process-keyworded-args arg-spec default-values args)
d288 1
a288 1
; Subroutine of -pmacro-apply/-smacro-apply to simplify them.
d291 4
a294 4
(define (-pmacro-process-args macro args)
  (let ((arg-spec (-pmacro-arg-spec macro))
	(default-values (-pmacro-default-values macro)))
    (let ((processed-args (-pmacro-process-args-1 arg-spec default-values args)))
d296 1
a296 1
	  (-pmacro-error (string-append
d300 2
a301 2
			      (write (cons (-pmacro-name macro)
					   (-pmacro-arg-spec macro))))))
d308 3
a310 3
(define (-pmacro-apply macro args)
  (apply (-pmacro-transformer macro)
	 (-pmacro-process-args macro args))
d314 1
a314 1
; ENV, LOC are handed down from -pmacro-expand.
d316 3
a318 3
(define (-smacro-apply macro args env loc)
  (apply (-pmacro-transformer macro)
	 (cons loc (cons env (-pmacro-process-args macro args))))
d324 1
a324 1
(define (-pmacro-expand exp env loc)
d333 1
a333 1
    (let ((val (-pmacro-env-ref env sym)))
d336 1
a336 1
	  (let ((val (-pmacro-lookup sym)))
d341 1
a341 1
		(if (procedure? (-pmacro-transformer val))
d343 1
a343 1
		    (-pmacro-transformer val))
d351 1
a351 1
    (if -pmacro-debug?
d356 1
a356 1
    (and (-pmacro? (car exp)) (car exp)))
d368 1
a368 1
    (let ((sform (-smacro-lookup (car exp))))
d372 1
a372 1
	    (-smacro-apply sform (cdr exp) env loc))
d380 1
a380 1
	    (if (-pmacro? scanned-car)
d383 1
a383 1
		  (if -pmacro-trace?
d404 4
a407 4
			 (result (if (procedure? (-pmacro-transformer scanned-car))
				     (-pmacro-apply scanned-car scanned-args)
				     (cons (-pmacro-transformer scanned-car) scanned-args))))
		    (if -pmacro-trace?
d455 1
a455 1
      ;; allows doing things like ((.sym a b c) arg1 arg2)
d468 1
a468 1
(define (-pmacro-get-arg-spec args)
d476 1
a476 1
		  (-pmacro-error "argument not `symbol' or `(symbol . default-value)'"
d488 1
a488 1
			   (-pmacro-error "argument not `symbol' or `(symbol . default-value)'"
d500 1
a500 1
(define (-pmacro-get-default-values args)
d508 1
a508 1
		  (-pmacro-error "argument not `symbol' or `(symbol . default-value)'"
d520 1
a520 1
			   (-pmacro-error "argument not `symbol' or `(symbol . default-value)'"
d529 1
a529 1
;(define (-pmacro-build-lambda prev-env params expansion)
d531 2
a532 2
;	    (-pmacro-expand ',expansion
;			    (-pmacro-env-make ',prev-env
d536 1
a536 1
(define (-pmacro-build-lambda loc prev-env params expansion)
d538 2
a539 2
    (-pmacro-expand expansion
		    (-pmacro-env-make prev-env params args)
d566 1
a566 1
      (-pmacro-error "invalid pmacro header" header))
d568 2
a569 2
	(arg-spec (if (symbol? header) #f (-pmacro-get-arg-spec (cdr header))))
	(default-values (if (symbol? header) #f (-pmacro-get-default-values (cdr header))))
d573 1
a573 1
	;;(-pmacro-error "extraneous arguments to define-pmacro" (cdr arg-rest)))
d575 1
a575 1
	;;(-pmacro-error "invalid pmacro comment, expected string" comment))
d578 1
a578 1
	    (let ((maybe-pmacro (-pmacro-lookup expansion)))
d580 4
a583 4
		  (-pmacro-set! name
				(-pmacro-make name
					      (-pmacro-arg-spec maybe-pmacro)
					      (-pmacro-default-values maybe-pmacro)
d585 1
a585 1
					      (-pmacro-transformer maybe-pmacro)
d587 5
a591 5
		  (-pmacro-set! name (-pmacro-make name #f #f #f expansion comment))))
	    (-pmacro-set! name (-pmacro-make name #f #f #f expansion comment)))
	(-pmacro-set! name
		      (-pmacro-make name arg-spec default-values #f
				    (-pmacro-build-lambda (current-reader-location)
d603 1
a603 1
  (-pmacro-expand expr '() loc)
d610 1
a610 1
  (let ((old-trace -pmacro-trace?)
d613 1
a613 1
    (set! -pmacro-trace? #t)
d622 1
a622 1
    (let ((result (-pmacro-expand expr '() loc)))
d624 1
a624 1
      (set! -pmacro-trace? old-trace)
d631 1
a631 1
  (-pmacro-expand expr '() (unspecified-location))
d635 1
a635 1
; This does not process .exec.
d639 2
a640 2
  (let ((old-debug -pmacro-debug?))
    (set! -pmacro-debug? #t)
d642 1
a642 1
      (set! -pmacro-debug? old-debug)
d648 1
a648 1
; (.sym symbol1 symbol2 ...) - symbol-append, auto-convert numbers
d650 1
a650 1
(define -pmacro-builtin-sym
d659 1
a659 1
			  (-pmacro-error "invalid argument to .str" elm))))
d663 1
a663 1
; (.str string1 string2 ...) - string-append, auto-convert numbers
d665 1
a665 1
(define -pmacro-builtin-str
d673 1
a673 1
			 (-pmacro-error "invalid argument to .str" elm))))
d677 1
a677 1
; (.hex number [width]) - convert number to hex string
d681 1
a681 1
(define (-pmacro-builtin-hex num . width)
d683 2
a684 2
      (-pmacro-error "wrong number of arguments to .hex"
		     (cons '.hex (cons num width))))
d693 1
a693 1
; (.upcase string) - convert a string or symbol to uppercase
d695 1
a695 1
(define (-pmacro-builtin-upcase str)
d699 1
a699 1
   (else (-pmacro-error "invalid argument to .upcase" str)))
d702 1
a702 1
; (.downcase string) - convert a string or symbol to lowercase
d704 1
a704 1
(define (-pmacro-builtin-downcase str)
d708 1
a708 1
   (else (-pmacro-error "invalid argument to .downcase" str)))
d711 1
a711 1
; (.substring string start end) - get part of a string
d714 1
a714 1
(define (-pmacro-builtin-substring str start end)
d716 1
a716 1
      (-pmacro-error "start not an integer" start))
d719 1
a719 1
      (-pmacro-error "end not an integer nor symbol `end'" end))
d729 1
a729 1
	 (-pmacro-error "invalid argument to .substring" str)))
d732 1
a732 1
; .splice - splicing support
d735 1
a735 1
; E.g. (define-pmacro '(splice-test a b c) '(.splice a (.unsplice b) c))
d746 2
a747 2
; NOTE: The implementation relies on .unsplice being undefined so that
; (.unsplice (42)) is expanded unchanged.
d749 1
a749 1
(define -pmacro-builtin-splice
d752 14
a765 12
    (let loop ((arg-list arg-list) (result '()))
      (cond ((null? arg-list) result)
	    ((and (pair? (car arg-list)) (eq? '.unsplice (caar arg-list)))
	     (if (= (length (car arg-list)) 2)
		 (if (list? (cadar arg-list))
		     (loop (cdr arg-list) (append result (cadar arg-list)))
		     (-pmacro-error "argument to .unsplice must be a list"
				    (car arg-list)))
		 (-pmacro-error "wrong number of arguments to .unsplice"
				(car arg-list))))
	    (else
	     (loop (cdr arg-list) (append result (list (car arg-list))))))))
d768 1
a768 1
; .iota
d770 3
a772 3
; (.iota count)            ; start=0, incr=1
; (.iota count start)      ; incr=1
; (.iota count start incr)
d774 1
a774 1
(define (-pmacro-builtin-iota count . start-incr)
d776 2
a777 2
      (-pmacro-error "wrong number of arguments to .iota"
		     (cons '.iota (cons count start-incr))))
d779 2
a780 2
      (-pmacro-error "count must be non-negative"
		     (cons '.iota (cons count start-incr))))
d789 1
a789 1
; (.map pmacro arg1 . arg-rest)
d791 4
a794 4
(define (-pmacro-builtin-map pmacro arg1 . arg-rest)
  (if (not (-pmacro? pmacro))
      (-pmacro-error "not a pmacro" pmacro))
  (let ((transformer (-pmacro-transformer pmacro)))
d796 1
a796 1
	(-pmacro-error "not a procedural pmacro" pmacro))
d800 1
a800 1
; (.for-each pmacro arg1 . arg-rest)
d802 4
a805 4
(define (-pmacro-builtin-for-each pmacro arg1 . arg-rest)
  (if (not (-pmacro? pmacro))
      (-pmacro-error "not a pmacro" pmacro))
  (let ((transformer (-pmacro-transformer pmacro)))
d807 1
a807 1
	(-pmacro-error "not a procedural pmacro" pmacro))
d812 1
a812 1
; (.eval expr)
d816 1
a816 1
; ??? I debated whether to call this .expand, .eval has been a source of
d819 2
a820 2
(define (-pmacro-builtin-eval loc env expr)
  ;; -pmacro-expand is invoked twice because we're implemented as a syntactic
d824 1
a824 1
  (-pmacro-expand (-pmacro-expand expr env loc) env loc)
d827 1
a827 1
; (.exec expr)
d829 1
a829 1
(define (-pmacro-builtin-exec expr)
d832 2
a833 2
  (if -pmacro-debug?
      (list '.exec expr)
d839 1
a839 1
; (.apply pmacro-name arg)
d841 4
a844 4
(define (-pmacro-builtin-apply pmacro arg-list)
  (if (not (-pmacro? pmacro))
      (-pmacro-error "not a pmacro" pmacro))
  (let ((transformer (-pmacro-transformer pmacro)))
d846 1
a846 1
	(-pmacro-error "not a procedural pmacro" pmacro))
d850 1
a850 1
; (.pmacro (arg-list) expansion)
d853 1
a853 1
(define (-pmacro-builtin-pmacro loc env params expansion)
d857 3
a859 3
      (-pmacro-error ".pmacro parameter-spec is not a list" params))
  (-pmacro-make '.anonymous params #f #f
		(-pmacro-build-lambda loc env params expansion) "")
d862 1
a862 1
; (.pmacro? arg)
d864 2
a865 2
(define (-pmacro-builtin-pmacro? arg)
  (-pmacro? arg)
d868 1
a868 1
; (.let (var-list) expr1 . expr-rest)
d871 1
a871 1
(define (-pmacro-builtin-let loc env locals expr1 . expr-rest)
d873 1
a873 1
      (-pmacro-error "locals is not a list" locals))
d879 1
a879 1
      (-pmacro-error "syntax error in locals list" locals))
d881 1
a881 1
			      (cons (car l) (-pmacro-expand (cadr l) env loc)))
d884 1
a884 1
    (-pmacro-expand-expr-list (cons expr1 expr-rest) new-env loc))
d887 1
a887 1
; (.let* (var-list) expr1 . expr-rest)
d890 1
a890 1
(define (-pmacro-builtin-let* loc env locals expr1 . expr-rest)
d892 1
a892 1
      (-pmacro-error "locals is not a list" locals))
d898 1
a898 1
      (-pmacro-error "syntax error in locals list" locals))
d901 1
a901 1
	(-pmacro-expand-expr-list (cons expr1 expr-rest) new-env loc)
d903 1
a903 1
				  (-pmacro-expand (cadar locals) new-env loc)
d907 1
a907 1
; (.if expr then [else])
d910 1
a910 1
(define (-pmacro-builtin-if loc env expr then-clause . else-clause)
d912 2
a913 2
    ((0) (if (-pmacro-expand expr env loc)
	     (-pmacro-expand then-clause env loc)
d915 4
a918 4
    ((1) (if (-pmacro-expand expr env loc)
	     (-pmacro-expand then-clause env loc)
	     (-pmacro-expand (car else-clause) env loc)))
    (else (-pmacro-error "too many elements in else-clause, expecting 0 or 1" else-clause)))
d921 1
a921 1
; (.case expr ((case-list1) stmt) [case-expr-stmt-list] [(else stmt)])
d925 2
a926 2
(define (-pmacro-builtin-case loc env expr case1 . rest)
  (let ((evald-expr (-pmacro-expand expr env loc)))
d932 1
a932 1
		(-pmacro-error "case statement not a list" (car cases)))
d934 1
a934 1
		(-pmacro-error "case statement has case but no expr" (car cases)))
d937 1
a937 1
		(-pmacro-error "case must be \"else\" or list of choices" (caar cases)))
d939 1
a939 1
		   (-pmacro-expand-expr-list (cdar cases) env loc))
d941 1
a941 1
		   (-pmacro-expand-expr-list (cdar cases) env loc))
d946 1
a946 1
; (.cond (expr stmt) [(cond-expr-stmt-list)] [(else stmt)])
d949 1
a949 1
(define (-pmacro-builtin-cond loc env expr1 . rest)
d954 1
a954 1
	   (-pmacro-expand-expr-list (cdar exprs) env loc))
d956 1
a956 1
	   (let ((evald-expr (-pmacro-expand (caar exprs) env loc)))
d958 1
a958 1
		 (-pmacro-expand-expr-list (cdar exprs) env loc)
d962 1
a962 1
; (.begin . stmt-list)
d965 2
a966 2
(define (-pmacro-builtin-begin loc env . rest)
  (-pmacro-expand-expr-list rest env loc)
d969 1
a969 1
; (.print . expr)
d972 1
a972 1
(define (-pmacro-builtin-print . exprs)
d977 1
a977 1
; (.dump expr)
d980 1
a980 1
(define (-pmacro-builtin-dump expr)
d985 1
a985 1
; (.error . expr)
d987 1
a987 1
(define (-pmacro-builtin-error . exprs)
d991 1
a991 1
; (.list expr1 ...)
d993 1
a993 1
(define (-pmacro-builtin-list . exprs)
d997 1
a997 1
; (.ref expr index)
d999 1
a999 1
(define (-pmacro-builtin-ref l n)
d1001 1
a1001 1
      (-pmacro-error "invalid arg for .ref, expected list" l))
d1003 1
a1003 1
      (-pmacro-error "invalid arg for .ref, expected non-negative integer" n))
d1007 1
a1007 1
; (.length x)
d1009 1
a1009 1
(define (-pmacro-builtin-length x)
d1014 1
a1014 1
	 (-pmacro-error "invalid arg for .length, expected symbol, string, or list" x)))
d1017 1
a1017 1
; (.replicate n expr)
d1019 1
a1019 1
(define (-pmacro-builtin-replicate n expr)
d1021 1
a1021 1
      (-pmacro-error "invalid arg for .replicate, expected non-negative integer" n))
d1025 1
a1025 1
; (.find pred l)
d1027 3
a1029 3
(define (-pmacro-builtin-find pred l)
  (if (not (-pmacro? pred))
      (-pmacro-error "not a pmacro" pred))
d1031 2
a1032 2
      (-pmacro-error "not a list" l))
  (let ((transformer (-pmacro-transformer pred)))
d1034 1
a1034 1
	(-pmacro-error "not a procedural macro" pred))
d1038 1
a1038 1
; (.equal? x y)
d1040 1
a1040 1
(define (-pmacro-builtin-equal? x y)
d1044 1
a1044 1
; (.andif . rest)
d1049 1
a1049 1
(define (-pmacro-builtin-andif loc env . exprs)
d1053 1
a1053 1
	(let ((evald-expr (-pmacro-expand (car exprs) env loc)))
d1059 1
a1059 1
; (.orif . rest)
d1064 1
a1064 1
(define (-pmacro-builtin-orif loc env . exprs)
d1068 1
a1068 1
	(let ((evald-expr (-pmacro-expand (car exprs) env loc)))
d1074 1
a1074 1
; (.not expr)
d1076 1
a1076 1
(define (-pmacro-builtin-not x)
d1082 1
a1082 1
(define (-pmacro-compatible-for-equality x y)
d1088 1
a1088 1
; (.eq expr)
d1090 1
a1090 1
(define (-pmacro-builtin-eq x y)
d1094 1
a1094 1
	     (-pmacro-error "incompatible args for .eq, expected symbol" y)))
d1098 1
a1098 1
	     (-pmacro-error "incompatible args for .eq, expected string" y)))
d1102 1
a1102 1
	     (-pmacro-error "incompatible args for .eq, expected number" y)))
d1104 1
a1104 1
	 (-pmacro-error "unsupported args for .eq" (list x y))))
d1107 1
a1107 1
; (.ne expr)
d1109 1
a1109 1
(define (-pmacro-builtin-ne x y)
d1113 1
a1113 1
	     (-pmacro-error "incompatible args for .ne, expected symbol" y)))
d1117 1
a1117 1
	     (-pmacro-error "incompatible args for .ne, expected string" y)))
d1121 1
a1121 1
	     (-pmacro-error "incompatible args for .ne, expected number" y)))
d1123 1
a1123 1
	 (-pmacro-error "unsupported args for .ne" (list x y))))
d1126 1
a1126 1
; (.lt expr)
d1128 3
a1130 3
(define (-pmacro-builtin-lt x y)
  (-pmacro-verify-number ".lt" x)
  (-pmacro-verify-number ".lt" y)
d1134 1
a1134 1
; (.gt expr)
d1136 3
a1138 3
(define (-pmacro-builtin-gt x y)
  (-pmacro-verify-number ".gt" x)
  (-pmacro-verify-number ".gt" y)
d1142 1
a1142 1
; (.le expr)
d1144 3
a1146 3
(define (-pmacro-builtin-le x y)
  (-pmacro-verify-number ".le" x)
  (-pmacro-verify-number ".le" y)
d1150 1
a1150 1
; (.ge expr)
d1152 3
a1154 3
(define (-pmacro-builtin-ge x y)
  (-pmacro-verify-number ".ge" x)
  (-pmacro-verify-number ".ge" y)
d1158 1
a1158 1
; (.add x y)
d1160 3
a1162 3
(define (-pmacro-builtin-add x y)
  (-pmacro-verify-number ".add" x)
  (-pmacro-verify-number ".add" y)
d1166 1
a1166 1
; (.sub x y)
d1168 3
a1170 3
(define (-pmacro-builtin-sub x y)
  (-pmacro-verify-number ".sub" x)
  (-pmacro-verify-number ".sub" y)
d1174 1
a1174 1
; (.mul x y)
d1176 3
a1178 3
(define (-pmacro-builtin-mul x y)
  (-pmacro-verify-number ".mul" x)
  (-pmacro-verify-number ".mul" y)
d1182 1
a1182 1
; (.div x y) - integer division
d1184 3
a1186 3
(define (-pmacro-builtin-div x y)
  (-pmacro-verify-integer ".div" x)
  (-pmacro-verify-integer ".div" y)
d1190 1
a1190 1
; (.rem x y) - integer remainder
d1193 3
a1195 3
(define (-pmacro-builtin-rem x y)
  (-pmacro-verify-integer ".rem" x)
  (-pmacro-verify-integer ".rem" y)
d1199 1
a1199 1
; (.sll x n) - shift left logical
d1201 3
a1203 3
(define (-pmacro-builtin-sll x n)
  (-pmacro-verify-integer ".sll" x)
  (-pmacro-verify-non-negative-integer ".sll" n)
d1207 1
a1207 1
; (.srl x n) - shift right logical
d1212 3
a1214 3
(define (-pmacro-builtin-srl x n)
  (-pmacro-verify-non-negative-integer ".srl" x)
  (-pmacro-verify-non-negative-integer ".srl" n)
d1218 1
a1218 1
; (.sra x n) - shift right arithmetic
d1220 3
a1222 3
(define (-pmacro-builtin-sra x n)
  (-pmacro-verify-integer ".sra" x)
  (-pmacro-verify-non-negative-integer ".sra" n)
d1226 1
a1226 1
; (.and x y) - bitwise and
d1228 3
a1230 3
(define (-pmacro-builtin-and x y)
  (-pmacro-verify-integer ".and" x)
  (-pmacro-verify-integer ".and" y)
d1234 1
a1234 1
; (.or x y) - bitwise or
d1236 3
a1238 3
(define (-pmacro-builtin-or x y)
  (-pmacro-verify-integer ".or" x)
  (-pmacro-verify-integer ".or" y)
d1242 1
a1242 1
; (.xor x y) - bitwise xor
d1244 3
a1246 3
(define (-pmacro-builtin-xor x y)
  (-pmacro-verify-integer ".xor" x)
  (-pmacro-verify-integer ".xor" y)
d1250 1
a1250 1
; (.inv x) - bitwise invert
d1252 2
a1253 2
(define (-pmacro-builtin-inv x)
  (-pmacro-verify-integer ".inv" x)
d1257 1
a1257 1
; (.car expr)
d1259 1
a1259 1
(define (-pmacro-builtin-car l)
d1262 1
a1262 1
      (-pmacro-error "invalid arg for .car, expected pair" l))
d1265 1
a1265 1
; (.cdr expr)
d1267 1
a1267 1
(define (-pmacro-builtin-cdr l)
d1270 1
a1270 1
      (-pmacro-error "invalid arg for .cdr, expected pair" l))
d1273 1
a1273 1
; (.caar expr)
d1275 1
a1275 1
(define (-pmacro-builtin-caar l)
d1278 1
a1278 1
      (-pmacro-error "invalid arg for .caar" l))
d1281 1
a1281 1
; (.cadr expr)
d1283 1
a1283 1
(define (-pmacro-builtin-cadr l)
d1286 1
a1286 1
      (-pmacro-error "invalid arg for .cadr" l))
d1289 1
a1289 1
; (.cdar expr)
d1291 1
a1291 1
(define (-pmacro-builtin-cdar l)
d1294 1
a1294 1
      (-pmacro-error "invalid arg for .cdar" l))
d1297 1
a1297 1
; (.cddr expr)
d1299 1
a1299 1
(define (-pmacro-builtin-cddr l)
d1302 1
a1302 1
      (-pmacro-error "invalid arg for .cddr" l))
d1305 1
a1305 1
; (.internal-test expr)
d1311 1
a1311 1
; (.internal-test mumble) because the reader will see #f or #t and complain.
d1313 1
a1313 1
(define (-pmacro-builtin-internal-test expr)
d1320 2
a1321 2
  (set! -pmacro-table (make-hash-table 127))
  (set! -smacro-table (make-hash-table 41))
d1328 58
a1385 58
	  (list '.sym 'symbols #f -pmacro-builtin-sym "symbol-append")
	  (list '.str 'strings #f -pmacro-builtin-str "string-append")
	  (list '.hex '(number . width) #f -pmacro-builtin-hex "convert to -hex, with optional width")
	  (list '.upcase '(string) #f -pmacro-builtin-upcase "string-upcase")
	  (list '.downcase '(string) #f -pmacro-builtin-downcase "string-downcase")
	  (list '.substring '(string start end) #f -pmacro-builtin-substring "get start of a string")
	  (list '.splice 'arg-list #f -pmacro-builtin-splice "splice lists into the outer list")
	  (list '.iota '(count . start-incr) #f -pmacro-builtin-iota "iota number generator")
	  (list '.map '(pmacro list1 . rest) #f -pmacro-builtin-map "map a pmacro over a list of arguments")
	  (list '.for-each '(pmacro list1 . rest) #f -pmacro-builtin-for-each "execute a pmacro over a list of arguments")
	  (list '.eval '(expr) #t -pmacro-builtin-eval "expand(evaluate) expr")
	  (list '.exec '(expr) #f -pmacro-builtin-exec "execute expr immediately")
	  (list '.apply '(pmacro arg-list) #f -pmacro-builtin-apply "apply a pmacro to a list of arguments")
	  (list '.pmacro '(params expansion) #t -pmacro-builtin-pmacro "create a pmacro on-the-fly")
	  (list '.pmacro? '(arg) #f -pmacro-builtin-pmacro? "return true if arg is a pmacro")
	  (list '.let '(locals expr1 . rest) #t -pmacro-builtin-let "create a binding context, let-style")
	  (list '.let* '(locals expr1 . rest) #t -pmacro-builtin-let* "create a binding context, let*-style")
	  (list '.if '(expr then . else) #t -pmacro-builtin-if "if expr is true, process then, else else")
	  (list '.case '(expr case1 . rest) #t -pmacro-builtin-case "process statement that matches expr")
	  (list '.cond '(expr1 . rest) #t -pmacro-builtin-cond "process first statement whose expr succeeds")
	  (list '.begin 'rest #t -pmacro-builtin-begin "process a sequence of statements")
	  (list '.print 'exprs #f -pmacro-builtin-print "print exprs, for debugging purposes")
	  (list '.dump '(expr)  #f-pmacro-builtin-dump "dump expr, for debugging purposes")
	  (list '.error 'message #f -pmacro-builtin-error "print error message and exit")
	  (list '.list 'exprs #f -pmacro-builtin-list "return a list of exprs")
	  (list '.ref '(l n) #f -pmacro-builtin-ref "return n'th element of list l")
	  (list '.length '(x) #f -pmacro-builtin-length "return length of symbol, string, or list")
	  (list '.replicate '(n expr) #f -pmacro-builtin-replicate "return list of expr replicated n times")
	  (list '.find '(pred l) #f -pmacro-builtin-find "return elements of list l matching pred")
	  (list '.equal? '(x y) #f -pmacro-builtin-equal? "deep comparison of x and y")
	  (list '.andif 'rest #t -pmacro-builtin-andif "return first #f element, otherwise return last element")
	  (list '.orif 'rest #t -pmacro-builtin-orif "return first non-#f element found, otherwise #f")
	  (list '.not '(x) #f -pmacro-builtin-not "return !x")
	  (list '.eq '(x y) #f -pmacro-builtin-eq "return true if x == y")
	  (list '.ne '(x y) #f -pmacro-builtin-ne "return true if x != y")
	  (list '.lt '(x y) #f -pmacro-builtin-lt "return true if x < y")
	  (list '.gt '(x y) #f -pmacro-builtin-gt "return true if x > y")
	  (list '.le '(x y) #f -pmacro-builtin-le "return true if x <= y")
	  (list '.ge '(x y) #f -pmacro-builtin-ge "return true if x >= y")
	  (list '.add '(x y) #f -pmacro-builtin-add "return x + y")
	  (list '.sub '(x y) #f -pmacro-builtin-sub "return x - y")
	  (list '.mul '(x y) #f -pmacro-builtin-mul "return x * y")
	  (list '.div '(x y) #f -pmacro-builtin-div "return x / y")
	  (list '.rem '(x y) #f -pmacro-builtin-rem "return x % y")
	  (list '.sll '(x n) #f -pmacro-builtin-sll "return logical x << n")
	  (list '.srl '(x n) #f -pmacro-builtin-srl "return logical x >> n")
	  (list '.sra '(x n) #f -pmacro-builtin-sra "return arithmetic x >> n")
	  (list '.and '(x y) #f -pmacro-builtin-and "return x & y")
	  (list '.or '(x y) #f -pmacro-builtin-or "return x | y")
	  (list '.xor '(x y) #f -pmacro-builtin-xor "return x ^ y")
	  (list '.inv '(x) #f -pmacro-builtin-inv "return ~x")
	  (list '.car '(x) #f -pmacro-builtin-car "return (car x)")
	  (list '.cdr '(x) #f -pmacro-builtin-cdr "return (cdr x)")
	  (list '.caar '(x) #f -pmacro-builtin-caar "return (caar x)")
	  (list '.cadr '(x) #f -pmacro-builtin-cadr "return (cadr x)")
	  (list '.cdar '(x) #f -pmacro-builtin-cdar "return (cdar x)")
	  (list '.cddr '(x) #f -pmacro-builtin-cddr "return (cddr x)")
	  (list '.internal-test '(expr) #f -pmacro-builtin-internal-test "testsuite use only")
d1388 1
a1388 1
		(let ((name (list-ref x 0))
d1393 2
a1394 2
		  (-pmacro-set! name
				(-pmacro-make name arg-spec #f syntactic? pmacro comment))
d1396 2
a1397 2
		      (-smacro-set! name
				    (-pmacro-make name arg-spec #f syntactic? pmacro comment)))))
@


1.20
log
@	* doc/pmacros.texi (pmacro default argument values): Add text.
@
text
@d89 1
a89 1
; (.equals x y)                       - deep comparison
d1036 1
a1036 1
; (.equals x y)
d1038 1
a1038 1
(define (-pmacro-builtin-equals x y)
d1355 1
a1355 1
	  (list '.equals '(x y) #f -pmacro-builtin-equals "deep comparison of x and y")
@


1.19
log
@	New builtin .pmacro?.
	* pmacros.scm (-pmacro-builtin-pmacro?): New function.
	(pmacros-init!): Add .pmacro?.
	* doc/pmacros.text: Document .pmacro?.
	* testsuite/pmacros-1.test: Test .pmacro?.
@
text
@d314 1
a314 1
; ENV is handed down from -pmacro-expand.
@


1.18
log
@	* pmacros.scm (scan-list1): Reorganize tracing so that the tracing
	of a pmacro begins before its arguments are evaluated, improves
	readability.
@
text
@d74 1
d860 6
d1340 1
@


1.17
log
@	* pmacros.scm (.sll, .srl, .sra): Fix thinko.
	* testsuite/pmacros-1.test: Ditto.  Add better tests.
@
text
@d148 4
d365 2
d373 33
a405 7
	  ;; Evaluate all the arguments first.
	  (let ((scanned-exp (map (lambda (e) (scan e loc))
				  exp)))
	    (let ((macro (check-pmacro scanned-exp)))
	      (if macro
		  (begin
		    ;; Trace expansion here, we know we have a pmacro.
d407 1
a407 3
			(let ((src-props (source-properties exp))
			      (indent (spaces (* 2 (length (location-list loc))))))
			  ;; We use `write' to display `exp' to see strings quoted.
d409 7
a415 24
			  (display "Expanding: " cep)
			  (write exp cep)
			  (newline cep)
			  (display indent cep)
			  (display "      env: " cep)
			  (display env cep)
			  (newline cep)
			  (if (not (null? src-props))
			      (begin
				(display indent cep)
				(display " location: " cep)
				(display (source-properties-location->string src-props) cep)
				(newline cep)))))
		    (let ((result (if (procedure? (-pmacro-transformer macro))
				      (-pmacro-apply macro (cdr scanned-exp))
				      (cons (-pmacro-transformer macro) (cdr scanned-exp)))))
		      (if -pmacro-trace?
			  (let ((indent (spaces (* 2 (length (location-list loc))))))
			    (display indent cep)
			    (display "   result: " cep)
			    (write result cep)
			    (newline cep)))
		      result))
		  scanned-exp))))))
@


1.16
log
@	* pmacros.scm (-pmacro-builtin-internal-test): New function.
	(pmacros-init!): Add .internal-test.
	* testsuite/test-utils.sh.in (post_process): Tweak FAIL output.
	* testsuite/testsuite.cpu (internal-verify): New pmacro.
	* doc/pmacros.text: Document .internal-test.

	* utils-cgen.scm (parse-name): Handle (add 3) -> add3.
	(parse-comment): Allow numbers.
	* doc/porting.texi: Document that names and comments may be lists.

	* insn.scm (-insn-parse): Fix typo.
@
text
@d1182 1
a1182 3
  (if (= n 0)
      x
      (* x n 2))
d1193 1
a1193 3
  (if (= n 0)
      x
      (quotient x (* n 2)))
d1201 1
a1201 3
  (cond ((= n 0) x)
	((= x -1) -1)
	(else (quotient x (* n 2))))
@


1.15
log
@	Rename .eval -> .exec.  Add new .eval.
	* pmacros.scm (-pmacro-built-exec): Renamed from -pmacro-builtin-eval.
	(-pmacro-builtin-eval): New function.
	(pmacros-init!): Add .exec.
	* doc/pmacros.texi: Update, .exec -> .eval.  Document new .eval.
	* testsuite/location-1.test: Update.
	* testsuite/pmacros-1.test: Add test for .eval.
@
text
@d116 1
d793 1
a793 1
    nil) ; need to return something the reader will accept
d820 1
a820 1
	nil)) ;; need to return something the reader will accept
d952 1
a952 1
  nil ; need to return something the reader will accept
d960 1
a960 1
  nil ; need to return something the reader will accept
d1288 12
d1368 1
@


1.14
log
@	* pmacros.scm (pmacro-dump): New function.
	(check-pmacro): Tweak debugging output.
	* doc/cgenint.texi: Mention pmacro-dump, pmacro-debug.
	* doc/pmacros.texi (.splice): Use pmacro-dump instead of pmacro-expand.
@
text
@d54 1
a54 1
;                This does not process .eval.
d66 1
a66 1
; (.splice a b (.unsplice c) d e ...) - quasi-quote/unquote-splicing
d70 2
a71 1
; (.eval expr)                        - process expr immediately
d620 1
a620 1
; This does not process .eval.
d724 9
a732 2
; different (??? may need to revisit).  In Scheme we have quasi-quote,
; unquote, unquote-splicing.  Here we have splice, unsplice.
d736 1
a736 2
    ; ??? Not the most efficient implementation, but will the difference
    ; ever be measureable?
d796 15
d812 2
a813 2
(define (-pmacro-builtin-eval expr)
  ;; If we're expanding pmacros for debugging purposes, don't eval,
d816 1
a816 1
      (list '.eval expr)
d1309 2
a1310 1
	  (list '.eval '(expr) #f -pmacro-builtin-eval "process expr immediately")
@


1.13
log
@	Add .let* pmacro builtin.
	* pmacros.scm (-pmacro-builtin-let*): New function.
	(pmacros-init!): Add .let*.
	* doc/pmacros.texi: Document .let*.
	* testsuite/pmacros-1.test: Test .let*.
@
text
@d48 4
d346 1
a346 1
	  (display "macro?   " cep)
d612 6
@


1.12
log
@	Add -t option for tracing things like commands, pmacro expansion.
	* dev.scm (cload): New arg #:trace.
	* pmacros.scm (-pmacro-expand): Rewrite pmacro tracing.
	(pmacro-trace): New arg `loc'.  Rewrite pmacro tracing.
	(pmacro-debug): Call pmacro-trace instead of -pmacro-expand.
	* read.scm (<reader>): New members trace-commands?, trace-pmacros?.
	(-reader-process-expanded-1!): Trace commands if requested.
	(-reader-process!): Call pmacro-trace of pmacro tracing requested.
	(-set-trace-options!): New function.
	(-init-reader!): New function.
	(cpu-load): New arg trace-options, all callers updated.
	Call -init-reader! and -set-trace-options!.
	(cgen-usage): Improve output formatting.
	(common-arguments): New option -t.
	(-cgen): Process -t.
	* utils-cgen.scm (single-location->string): Renamed from
	pretty-print-single-location.  All callers updated.
	(location->string): Renamed from pretty-print-location.
	All callers updated.
	(source-properties-location->string): New function.
	* doc/running.texi: Document -t.
@
text
@d70 1
d117 5
a121 1
; only valid as arguments to other pmacros or assigned to a local in a {.let}.
d818 1
a818 1
      (-pmacro-error ".let locals is not a list" locals))
d832 20
d1280 2
a1281 1
	  (list '.let '(locals expr1 . rest) #t -pmacro-builtin-let "create a binding context")
@


1.11
log
@	Track source location better, for better error messages.
	* pmacros.scm (-pmacro-eval): Delete, unused.
	(pmacro-expand, -pmacro-expand): New arg `loc', all callers updated.
	(-pmacro-expand-expr-list, -smacro-apply): Ditto.
	(scan-list, scan): Ditto.
	(-pmacro-builtin-pmacro, -pmacro-builtin-let, -pmacro-builtin-if,
	-pmacro-builtin-case, -pmacro-builtin-cond, -pmacro-builtin-begin,
	-pmacro-builtin-andif, -pmacro-builtin-orif): Ditto.
	(scan-list1): New function.
	(-pmacro-build-lambda): New arg `loc', all callers updated.  Rewrite.
	* read.scm (<reader>): New member `location'.
	(-reader-lookup-command): Renamed from reader-lookup-command,
	all callers updated.
	(reader-error): Rewrite to produce better source location info.
	(current-reader-location): New function.
	(-reader-process-expanded-1!): Renamed from -reader-process-expanded-1.
	All callers updated.  Record source location of expression.
	(reader-process-expanded!): Renamed from reader-process-expanded.
	All callers updated.
	(-reader-process!): Renamed from reader-process.  New arg `loc'.
	All callers updated.  Record source location of define-pmacro.
	* utils-cgen.scm (<location>): New class.
	(single-location): New (pseudo) class.
	(pretty-print-single-location, pretty-print-location): New functions.
	(location-top, location-push-single, location-push): New functions.
	(unspecified-location, current-input-location): New functions.
	(location-property): New object property.
	(location-property-set!): New function.
	(<source-ident>): Renamed from <ordered-ident>.  New member `location'.
	All uses updated.
	* testsuite/location-1.test: New testcase.
	* testsuite/run-tests.sh: Fix fail count handling.
	* testsuite/test-utils.sh.in (run_cgen): New option `-f'.  Allow tests
	to expect cgen to fail.

	* pmacros.scm (*): Use "pmacro" instead of "macro" more consistently.

	* read.scm (-cmd-include): Renamed from include.  All callers updated.
	(-cmd-if): Renamed from cmd-if.  All callers updated.
	Use reader-process-expanded! on then/else clauses instead of eval1.
@
text
@a8 2
;   On the other hand these macros aren't intended for use outside
;   the cpu description file.
a9 1
; - Comments for .pmacros.
d11 9
a19 6
; Required routines:
; make-hash-table, hashq-ref, hashq-set!
; string-append, symbol-append, map, apply, number?, number->string,
; eval, reader-process-expanded!, num-args-ok?, *UNSPECIFIED*.
; `num-args-ok?' and `*UNSPECIFIED*' are defined in cgen's utils.scm.
; reader-process-expanded! is defined in cgen's read.scm.
d24 4
d43 2
a44 1
; pmacro-debug - expand all pmacros in an expression, but don't process .eval
d46 1
a46 1
;	(pmacro-debug expression)
d48 3
a50 1
; pmacro-trace - same as pmacro-expand, but print debugging messages
d52 1
a52 1
;	(pmacro-trace expression)
d121 1
a121 1
; True if doing pmacro expansion via pmacro-debug or pmacro-trace.
d312 4
a315 3
  ; If the symbol is in `env', return its value.
  ; Otherwise see if symbol is a globally defined pmacro.
  ; Otherwise return the symbol unchanged.
d319 1
a319 1
	  (cdr val) ; cdr is value of (name . value) pair
d322 3
a324 3
		; Symbol is a pmacro.
		; If this is a procedural pmacro, let caller perform expansion.
		; Otherwise, return the pmacro's value.
d328 1
a328 1
		; Return symbol unchanged.
d331 3
a333 2
  ; See if (car exp) is a pmacro.
  ; Return pmacro or #f.
d335 1
a335 1
    (if -pmacro-trace?
d345 1
d352 3
a354 1
	  (-smacro-apply sform (cdr exp) env loc)
d361 30
a390 3
		  (if (procedure? (-pmacro-transformer macro))
		      (-pmacro-apply macro (cdr scanned-exp))
		      (cons (-pmacro-transformer macro) (cdr scanned-exp)))
d397 1
a400 2
      (logit 4 "scan-list exp: " exp)
      (logit 4 "    src-props: " src-props)
a404 1
	    (logit 4 "new src-props: " file line)
d420 1
d429 4
a432 4
      ; Re-examining `result' to see if it is another pmacro invocation
      ; allows doing things like ((.sym a b c) arg1 arg2)
      ; where `abc' is a pmacro.  Scheme doesn't work this way, but then
      ; this is CGEN.
d435 1
a435 11
  (if -pmacro-trace?
      (begin
	; We use `write' to display `exp' to see strings quoted.
	(display "expand: " cep) (write exp cep) (newline cep)
	(display "   env: " cep) (display env cep) (newline cep)))

  (let ((result (scan exp loc)))
    (if -pmacro-trace?
	(begin
	  (display "result:  " cep) (write result cep) (newline cep)))
    result)
d581 1
a581 1
; Expand any pmacros in EXPR, without processing .eval.
d583 1
a583 1
(define (pmacro-debug expr)
d585 15
a599 4
  (let ((old-debug -pmacro-debug?))
    (set! -pmacro-debug? #t)
    (let ((result (-pmacro-expand expr '() (unspecified-location))))
      (set! -pmacro-debug? old-debug)
d603 2
a604 1
; Debugging routine to trace pmacro expansion.
d606 1
a606 1
(define (pmacro-trace expr)
d608 1
a608 2
  (let ((old-debug -pmacro-debug?)
	(old-trace -pmacro-trace?))
d610 1
a610 2
    (set! -pmacro-trace? #t)
    (let ((result (-pmacro-expand expr '() (unspecified-location))))
a611 1
      (set! -pmacro-trace? old-trace)
@


1.10
log
@	* pmacros.scm (-pmacro-builtin-find): New predicate.
	(pmacros-init!): Add .find.
	* doc/pmacros.tex: Document .find.
	* testsuite/pmacros-1.test: Test .find.
@
text
@d17 1
a17 1
; eval, num-args-ok?, *UNSPECIFIED*.
d19 1
d28 1
a28 1
; define-pmacro - define a symbolic or procedural macro
d35 1
a35 1
; pmacro-expand - expand all macros in an expression
d37 5
a41 1
;	(pmacro-expand expression)
d47 1
a47 1
; Builtin macros:
d60 1
a60 1
; (.apply macro-name arg)
d109 1
a109 1
; only valid as arguments to other macros or assigned to a local in a {.let}.
d114 1
a114 1
; True if doing macro expansion via pmacro-debug or pmacro-trace.
d116 1
a116 1
; True if doing macro expansion via pmacro-trace.
d207 1
a207 8
; Utility to evaluate pmacro args.
; ??? Currently unused, keep for now.

(define (-pmacro-eval expr)
  (eval1 expr)
)

; Expand a list of expressions, in order
d210 1
a210 1
(define (-pmacro-expand-expr-list exprs env)
d213 1
a213 1
		(set! result (-pmacro-expand expr env)))
d293 1
a293 1
(define (-smacro-apply macro args env)
d295 1
a295 1
	 (cons env (-pmacro-process-args macro args)))
d298 2
a299 1
; Expand expression EXP using ENV, an alist of variable assignments.
d301 1
a301 1
(define (-pmacro-expand exp env)
d314 3
a316 3
		; Symbol is a macro.
		; If this is a procedural macro, let caller perform expansion.
		; Otherwise, return the macro's value.
d323 3
a325 3
  ; See if (car exp) is a macro.
  ; Return macro or #f.
  (define (check-macro exp)
d333 4
a336 2
  ;; Scan each element in EXP and see if the result is a macro invocation.
  (define (scan-list exp)
d342 1
a342 1
	  (-smacro-apply sform (cdr exp) env)
d345 3
a347 2
	  (let ((scanned-exp (map scan exp)))
	    (let ((macro (check-macro scanned-exp)))
d354 37
a390 6
  ; Scan EXP, an arbitrary value.
  (define (scan exp)
    (let ((result (cond ((symbol? exp) (scan-symbol exp))
			((and (list? exp) (not (null? exp))) (scan-list exp))
			; Not a symbol or expression, return unchanged.
			(else exp))))
d403 1
a403 1
  (let ((result (scan exp)))
d474 14
a487 5
(define (-pmacro-build-lambda prev-env params expansion)
  (eval1 `(lambda ,params
	    (-pmacro-expand ',expansion
			    (-pmacro-env-make ',prev-env
					      ',params (list ,@@params)))))
d490 1
a490 1
; ??? I'd prefer to use `define-macro', but boot-9.scm uses it and
d493 2
a494 1
; ??? On the other hand, calling them pmacros removes all ambiguity.
d508 1
a508 1
; ??? We may want user-definable "syntactic" macros some day.  Later.
d513 1
a513 1
      (-pmacro-error "invalid pmacro definition" header))
d538 4
a541 2
				    (-pmacro-build-lambda nil
							  arg-spec expansion)
d547 1
d549 2
a550 2
(define (pmacro-expand expr)
  (-pmacro-expand expr '())
d559 1
a559 1
    (let ((result (-pmacro-expand expr '())))
d564 1
a564 1
; Debugging routine to trace macro expansion.
d572 1
a572 1
    (let ((result (-pmacro-expand expr '())))
d578 1
a578 1
; Builtin macros.
d720 1
a720 1
	(-pmacro-error "not a procedural macro" pmacro))
d731 1
a731 1
	(-pmacro-error "not a procedural macro" pmacro))
d739 1
a739 1
  ;; If we're expanding macros for debugging purposes, don't eval,
d744 1
a744 1
	(reader-process-expanded expr)
d748 1
a748 1
; (.apply macro-name arg)
d755 1
a755 1
	(-pmacro-error "not a procedural macro" pmacro))
d760 1
a760 1
; Note: syntactic form
d762 1
a762 1
(define (-pmacro-builtin-pmacro env params expansion)
d768 1
a768 1
		(-pmacro-build-lambda env params expansion) "")
d772 1
a772 1
; Note: syntactic form
d774 1
a774 1
(define (-pmacro-builtin-let env locals expr1 . expr-rest)
d784 1
a784 1
			      (cons (car l) (-pmacro-expand (cadr l) env)))
d787 1
a787 1
    (-pmacro-expand-expr-list (cons expr1 expr-rest) new-env))
d791 1
a791 1
; Note: syntactic form
d793 1
a793 1
(define (-pmacro-builtin-if env expr then-clause . else-clause)
d795 2
a796 2
    ((0) (if (-pmacro-expand expr env)
	     (-pmacro-expand then-clause env)
d798 3
a800 3
    ((1) (if (-pmacro-expand expr env)
	     (-pmacro-expand then-clause env)
	     (-pmacro-expand (car else-clause) env)))
d805 2
a806 2
; Note: syntactic form
; Note: this uses "member" for case comparison (Scheme uses memq I think)
d808 2
a809 2
(define (-pmacro-builtin-case env expr case1 . rest)
  (let ((evald-expr (-pmacro-expand expr env)))
d822 1
a822 1
		   (-pmacro-expand-expr-list (cdar cases) env))
d824 1
a824 1
		   (-pmacro-expand-expr-list (cdar cases) env))
d830 1
a830 1
; Note: syntactic form
d832 1
a832 1
(define (-pmacro-builtin-cond env expr1 . rest)
d837 1
a837 1
	   (-pmacro-expand-expr-list (cdar exprs) env))
d839 1
a839 1
	   (let ((evald-expr (-pmacro-expand (caar exprs) env)))
d841 1
a841 1
		 (-pmacro-expand-expr-list (cdar exprs) env)
d846 1
a846 1
; Note: syntactic form
d848 2
a849 2
(define (-pmacro-builtin-begin env . rest)
  (-pmacro-expand-expr-list rest env)
d928 1
a928 1
; Note: syntactic form
d932 1
a932 1
(define (-pmacro-builtin-andif env . exprs)
d936 1
a936 1
	(let ((evald-expr (-pmacro-expand (car exprs) env)))
d943 1
a943 1
; Note: syntactic form
d947 1
a947 1
(define (-pmacro-builtin-orif env . exprs)
d951 1
a951 1
	(let ((evald-expr (-pmacro-expand (car exprs) env)))
d1200 1
a1200 1
  ; Some "predefined" macros.
d1213 2
a1214 2
	  (list '.map '(pmacro list1 . rest) #f -pmacro-builtin-map "map a macro over a list of arguments")
	  (list '.for-each '(pmacro list1 . rest) #f -pmacro-builtin-for-each "execute a macro over a list of arguments")
d1216 1
a1216 1
	  (list '.apply '(macro arg-list) #f -pmacro-builtin-apply "apply a macro to a list of arguments")
@


1.9
log
@	Fix binding of nested pmacro parameters.
	* pmacros.scm (-pmacro-env-make): New arg prev-env.
	All callers updated.
	(-pmacro-bulid-lambda): Ditto.
	* doc/pmacros.texi: Update.
@
text
@d69 1
d862 13
d1184 1
@


1.8
log
@	* doc/pmacros.texi (.not): Emphasize (.not 0) is not 1.

	Rename builtin boolean pmacros, for consistency with rtl.
	* pmacros.scm: .and -> .andif, .or -> .orif, .bitand -> .and,
	.bitor -> .or, .bitxor -> .xor, .bitinv -> .inv.
	* doc/pmacros.texi: Update.
	* testsuite/pmacros-1.test: Update.
@
text
@d103 1
a103 3
; only valid as arguments to other macros.
; ??? Nested pmacros don't bind their arguments the way nested lambda's do.
; Should they?
d143 3
a145 1
(define (-pmacro-env-make names values) (map cons names values))
d440 1
a440 1
(define (-pmacro-build-lambda params expansion)
d443 2
a444 1
			    (-pmacro-env-make ',params (list ,@@params)))))
d462 1
a462 1
; symbols as being themselves.
d494 2
a495 1
				    (-pmacro-build-lambda arg-spec expansion)
d720 2
a721 1
  (-pmacro-make '.anonymous params #f #f (-pmacro-build-lambda params expansion) "")
@


1.7
log
@	Extend pmacro language, add testsuite.
	* Makefile.am (SUBDIRS): Add testsuite.
	* Makefile.in: Regenerate.
	* configure.in (AC_OUTPUT): Create testsuite/Makefile,
	testsuite/test-utils.sh.
	* configure: Regenerate.
	* dev.scm (cload): Handle testsuite app.
	(load-testsuite): New function.
	* pmacros.scm: (-pmacro-debug?): New global.
	(-smacro-table): New global.
	(-smacro-lookup, -smacro-set!): New functions.
	(-pmacro-make): New argument `syntactic-form?', all callers updated.
	(-pmacro-syntactic-form?): New function.
	(-pmacro-expected-number, -pmacro-verify-number): New functions.
	(-pmacro-expected-integer, -pmacro-verify-integer): New functions.
	(-pmacro-expected-non-negative-integer): New function.
	(-pmacro-verify-non-negative-integer): New function.
	(-pmacro-expand-expr-list): New function.
	(-pmacro-process-args-1): Renamed from -pmacro-process-args.
	(-pmacro-process-args): Renamed from -pmacro-invoke.
	(-pmacro-apply, -smacro-apply): New functions.
	(-pmacro-expand): Rewrite syntactic form processing.
	(-pmacro-build-lambda): Reformat.
	(define-pmacro): Watch for more errors in definition.
	(pmacro-debug): New function.
	(pmacro-trace): Set/reset -pmacro-debug?.
	(all existing builtin pmacro helpers): Rename to -pmacro-builtin-foo.
	(-pmacro-builtin-substring): Fix.  Add support for `end' marker.
	(-pmacro-builtin-for-each, et.al.): New helpers for .for-each, .let,
	.if, .case, .cond, .begin, .print, .dump, .error, .list, .ref,
	.length, .replicate, .equals, .and, .or, .not, .eq, .ne, .lt, .gt,
	.le, .ge, .add, .sub, .mul, .div, .rem, .sll, .srl, .sra, .bitand,
	.bitor, .bitxor, bitinv, .car, .cdr, .caar, .cadr, .cdar, .cddr.
	(pmacros-init!): Initialize -smacro-table.
	Rewrite pmacro initialization.
	* read.scm (reader-process-expanded): Renamed from
	-reader-process-expanded.  All callers updated.
	Recognize () as a no-op.
	(cpu-load): Tweak logging messages.
	* utils.scm (message): Add comment.
	* cpu/play.cpu: Add some instructions to play with .let.
	* doc/cgenint.texi: Move some debugging related docs to here from
	cgen.texi.
	* doc/pmacros.texi: Reorganize.  Add docs for new builtin pmacros.
	* testsuite/Makefile.am: New file.
	* testsuite/Makefile.in: New file.
	* testsuite/test-utils.sh.in: New file.
	* testsuite/run-tests.sh: New file.
	* testsuite/testsuite.cpu: New file.
	* testsuite/pmacros-1.test: New file.
@
text
@d70 2
a71 2
; (.and expr . rest)                  - && in C
; (.or expr . rest)                   - || in C
d87 4
a90 4
; (.bitand x y)                       - bitwise and
; (.bitor x y)                        - bitwise or
; (.bitxor x y)                       - bitwise xor
; (.bitinv x)                         - bitwise invert
d864 1
a864 1
; (.and . rest)
d869 1
a869 1
(define (-pmacro-builtin-and env . exprs)
d879 1
a879 1
; (.or . rest)
d884 1
a884 1
(define (-pmacro-builtin-or env . exprs)
d1052 1
a1052 1
; (.bitand x y) - bitwise and
d1054 3
a1056 3
(define (-pmacro-builtin-bitand x y)
  (-pmacro-verify-integer ".bitand" x)
  (-pmacro-verify-integer ".bitand" y)
d1060 1
a1060 1
; (.bitor x y) - bitwise or
d1062 3
a1064 3
(define (-pmacro-builtin-bitor x y)
  (-pmacro-verify-integer ".bitor" x)
  (-pmacro-verify-integer ".bitor" y)
d1068 1
a1068 1
; (.bitxor x y) - bitwise xor
d1070 3
a1072 3
(define (-pmacro-builtin-bitxor x y)
  (-pmacro-verify-integer ".bitxor" x)
  (-pmacro-verify-integer ".bitxor" y)
d1076 1
a1076 1
; (.bitinv x) - bitwise invert
d1078 2
a1079 2
(define (-pmacro-builtin-bitinv x)
  (-pmacro-verify-integer ".bitinv" x)
d1168 2
a1169 2
	  (list '.and 'rest #t -pmacro-builtin-and "return #f if any element is #f, otherwise return last element")
	  (list '.or 'rest #t -pmacro-builtin-or "return first non-#f element, otherwise #f")
d1185 4
a1188 4
	  (list '.bitand '(x y) #f -pmacro-builtin-bitand "return x & y")
	  (list '.bitor '(x y) #f -pmacro-builtin-bitor "return x | y")
	  (list '.bitxor '(x y) #f -pmacro-builtin-bitxor "return x ^ y")
	  (list '.bitinv '(x) #f -pmacro-builtin-bitinv "return ~x")
@


1.6
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d29 2
a30 2
;	(define-pmacro symbol "comment" expansion)
;	(define-pmacro (symbol [args]) "comment" (expansion))
d46 3
a48 3
; (.hex number)                       - convert to hex string
; (.upcase string)                    - convert to uppercase
; (.downcase string)                  - convert to lowercase
d52 47
a98 4
; (.map macro-name arg1 ...)          - map
; (.apply macro-name arg)             - apply
; (.pmacro (arg-list) expansion)      - lambda (??? call it .lambda?)
; (.eval (expr))                      - eval (experimental)
a106 3
; .eval is an experiment.  Ports that consider themselves to be of beta
; quality or better don't use it.
;
d108 1
a108 1
; to something else.  Where's Quad when you need it?! :-)
d110 3
d115 1
d120 5
d129 4
a132 2
(define (-pmacro-make name arg-spec default-values transformer comment)
  (vector -pmacro-marker name arg-spec default-values transformer comment)
d138 3
a140 2
(define (-pmacro-transformer pmac) (vector-ref pmac 4))
(define (-pmacro-comment pmac) (vector-ref pmac 5))
d161 58
d260 1
a260 1
(define (-pmacro-process-args arg-spec default-values args)
d266 2
a267 3
; Invoke a procedural macro.
; ??? A better name might be -pmacro-apply but that is taken by the
; .apply handler.
d269 1
a269 1
(define (-pmacro-invoke macro args)
d272 1
a272 1
    (let ((processed-args (-pmacro-process-args arg-spec default-values args)))
d281 16
a296 1
      (apply (-pmacro-transformer macro) processed-args)))
d333 1
a333 1
  ; Scan each element in EXP and see if the result is a macro invocation.
d335 15
a349 14
    ; Check for syntactic forms.
    (case (car exp)
      ((.pmacro)
       (if (not (= (length exp) 3))
	   (-pmacro-error "wrong number of arguments to .pmacro" exp))
       (-pmacro-pmacro (cadr exp) (caddr exp)))
      (else
       (let ((scanned-exp (map scan exp)))
	 (let ((macro (check-macro scanned-exp)))
	   (if macro
	       (if (procedure? (-pmacro-transformer macro))
		   (-pmacro-invoke macro (cdr scanned-exp))
		   (cons (-pmacro-transformer macro) (cdr scanned-exp)))
	       scanned-exp))))))
d442 2
a443 1
	    (-pmacro-expand ',expansion (-pmacro-env-make ',params (list ,@@params)))))
d452 4
a455 2
; (define (name args ...) expansion)
; (define (name args ...) "documentation" expansion)
d462 2
d466 3
d474 4
d486 1
d489 2
a490 2
		  (-pmacro-set! name (-pmacro-make name #f #f expansion comment))))
	    (-pmacro-set! name (-pmacro-make name #f #f expansion comment)))
d492 1
a492 1
		      (-pmacro-make name arg-spec default-values
d504 11
d518 4
a521 2
  ; ??? Need unwind protection.
  (let ((old -pmacro-trace?))
d524 2
a525 1
      (set! -pmacro-trace? old)
d531 1
a531 1
; .sym - symbol-append, auto-convert numbers
d533 1
a533 1
(define -pmacro-sym
d546 1
a546 1
; .str - string-append, auto-convert numbers
d548 1
a548 1
(define -pmacro-str
d560 1
a560 1
; .hex - convert number to hex string
d564 1
a564 1
(define (-pmacro-hex num . width)
d576 1
a576 1
; .upcase - convert a string to uppercase
d578 1
a578 1
(define (-pmacro-upcase str)
d585 1
a585 1
; .downcase - convert a string to lowercase
d587 1
a587 1
(define (-pmacro-downcase str)
d594 2
a595 1
; .substring - get part of a string
d597 16
a612 2
(define (-pmacro-substring str start end)
  (substring str start end)
d625 1
a625 1
(define -pmacro-splice
d649 1
a649 1
(define (-pmacro-iota count . start-incr)
d664 1
a664 1
; .map
d666 1
a666 1
(define (-pmacro-map pmacro arg1 . arg-rest)
d675 13
a687 1
; .apply
d689 13
a701 1
(define (-pmacro-apply pmacro arg-list)
d710 2
a711 1
; .pmacro
d713 3
a715 1
(define (-pmacro-pmacro params expansion)
d717 412
a1128 2
      (-pmacro-error "bad parameter list" params))
  (-pmacro-make '.anonymous params #f (-pmacro-build-lambda params expansion) "")
d1135 1
d1139 69
a1207 36
  (-pmacro-set! '.sym
		(-pmacro-make '.sym 'symbols #f -pmacro-sym "symbol-append"))
  (-pmacro-set! '.str
		(-pmacro-make '.str 'strings #f -pmacro-str "string-append"))
  (-pmacro-set! '.hex
		(-pmacro-make '.hex '(number . width) #f -pmacro-hex
			      "convert to hex, with optional width"))
  (-pmacro-set! '.upcase
		(-pmacro-make '.upcase '(string) #f
			      -pmacro-upcase "string-upcase"))
  (-pmacro-set! '.downcase
		(-pmacro-make '.downcase '(string) #f
			      -pmacro-downcase "string-downcase"))
  (-pmacro-set! '.substring
		(-pmacro-make '.substring '(string start end) #f
			      -pmacro-substring "get part of a string"))
  (-pmacro-set! '.splice
		(-pmacro-make '.splice 'arg-list #f -pmacro-splice
			      "splice lists into the outer list"))
  (-pmacro-set! '.iota
		(-pmacro-make '.iota '(count . start-incr) #f -pmacro-iota
			      "iota number generator"))
  (-pmacro-set! '.map
		(-pmacro-make '.map '(macro-name arg1 . arg-rest) #f
			      -pmacro-map
			      "map a macro over a list of arguments"))
  (-pmacro-set! '.apply
		(-pmacro-make '.apply '(macro-name arg-list) #f -pmacro-apply
			      "apply a macro, taking arguments from a list"))
  (-pmacro-set! '.pmacro
		(-pmacro-make '.pmacro '(params expansion) #f -pmacro-pmacro
			      "create a pmacro on-the-fly"))

  ; doesn't work, Hobbit creates "eval" variable
  ;(-pmacro-set! '.eval (-pmacro-make '.eval '(expr) #f eval "eval"))
  (-pmacro-set! '.eval (-pmacro-make '.eval '(expr) #f (eval1 'eval1) "eval"))
@


1.6.2.1
log
@Copy over from trunk.
	Extend pmacro language, add testsuite.
	* Makefile.am (SUBDIRS): Add testsuite.
	* Makefile.in: Regenerate.
	* configure.in (AC_OUTPUT): Create testsuite/Makefile,
	testsuite/test-utils.sh.
	* configure: Regenerate.
	* dev.scm (cload): Handle testsuite app.
	(load-testsuite): New function.
	* pmacros.scm: (-pmacro-debug?): New global.
	(-smacro-table): New global.
	(-smacro-lookup, -smacro-set!): New functions.
	(-pmacro-make): New argument `syntactic-form?', all callers updated.
	(-pmacro-syntactic-form?): New function.
	(-pmacro-expected-number, -pmacro-verify-number): New functions.
	(-pmacro-expected-integer, -pmacro-verify-integer): New functions.
	(-pmacro-expected-non-negative-integer): New function.
	(-pmacro-verify-non-negative-integer): New function.
	(-pmacro-expand-expr-list): New function.
	(-pmacro-process-args-1): Renamed from -pmacro-process-args.
	(-pmacro-process-args): Renamed from -pmacro-invoke.
	(-pmacro-apply, -smacro-apply): New functions.
	(-pmacro-expand): Rewrite syntactic form processing.
	(-pmacro-build-lambda): Reformat.
	(define-pmacro): Watch for more errors in definition.
	(pmacro-debug): New function.
	(pmacro-trace): Set/reset -pmacro-debug?.
	(all existing builtin pmacro helpers): Rename to -pmacro-builtin-foo.
	(-pmacro-builtin-substring): Fix.  Add support for `end' marker.
	(-pmacro-builtin-for-each, et.al.): New helpers for .for-each, .let,
	.if, .case, .cond, .begin, .print, .dump, .error, .list, .ref,
	.length, .replicate, .equals, .and, .or, .not, .eq, .ne, .lt, .gt,
	.le, .ge, .add, .sub, .mul, .div, .rem, .sll, .srl, .sra, .bitand,
	.bitor, .bitxor, bitinv, .car, .cdr, .caar, .cadr, .cdar, .cddr.
	(pmacros-init!): Initialize -smacro-table.
	Rewrite pmacro initialization.
	* read.scm (reader-process-expanded): Renamed from
	-reader-process-expanded.  All callers updated.
	Recognize () as a no-op.
	(cpu-load): Tweak logging messages.
	* utils.scm (message): Add comment.
	* cpu/play.cpu: Add some instructions to play with .let.
	* doc/cgenint.texi: Move some debugging related docs to here from
	cgen.texi.
	* doc/pmacros.texi: Reorganize.  Add docs for new builtin pmacros.
	* testsuite/Makefile.am: New file.
	* testsuite/Makefile.in: New file.
	* testsuite/test-utils.sh.in: New file.
	* testsuite/run-tests.sh: New file.
	* testsuite/testsuite.cpu: New file.
	* testsuite/pmacros-1.test: New file.
@
text
@d29 2
a30 2
;	(define-pmacro symbol ["comment"] expansion)
;	(define-pmacro (symbol [args]) ["comment"] (expansion))
d46 3
a48 3
; (.hex number [width])               - convert to hex string
; (.upcase string)
; (.downcase string)
d52 4
a55 47
; (.map pmacro arg1 . arg-rest)
; (.for-each pmacro arg1 . arg-rest)
; (.eval expr)                        - process expr immediately
; (.apply macro-name arg)
; (.pmacro (arg-list) expansion)      - akin go lambda in Scheme
; (.let (var-list) expr1 . expr-rest) - akin to let in Scheme
; (.if expr then [else])
; (.case expr ((case-list1) stmt) [case-expr-stmt-list] [(else stmt)])
; (.cond (expr stmt) [(cond-expr-stmt-list)] [(else stmt)])
; (.begin . stmt-list)
; (.print . exprs)                    - for debugging messages
; (.dump expr)                        - dump expr in readable format
; (.error . message)                  - print error message and exit
; (.list . exprs)
; (.ref l n)                          - extract the n'th element of list l
; (.length x)                         - length of symbol, string, or list
; (.replicate n expr)                 - return list of expr replicated n times
; (.equals x y)                       - deep comparison
; (.and expr . rest)                  - && in C
; (.or expr . rest)                   - || in C
; (.not expr)                         - ! in C
; (.eq x y)
; (.ne x y)
; (.lt x y)
; (.gt x y)
; (.le x y)
; (.ge x y)
; (.add x y)
; (.sub x y)
; (.mul x y)
; (.div x y)                          - integer division
; (.rem x y)                          - integer remainder
; (.sll x n)                          - shift left logical
; (.srl x n)                          - shift right logical
; (.sra x n)                          - shift right arithmetic
; (.bitand x y)                       - bitwise and
; (.bitor x y)                        - bitwise or
; (.bitxor x y)                       - bitwise xor
; (.bitinv x)                         - bitwise invert
; (.car l)
; (.cdr l)
; (.caar l)
; (.cadr l)
; (.cdar l)
; (.cddr l)
;
; NOTE: .cons currently absent on purpose
d64 3
d68 1
a68 1
; to something else.
a69 3
; True if doing macro expansion via pmacro-debug or pmacro-trace.
(define -pmacro-debug? #f)
; True if doing macro expansion via pmacro-trace.
a71 1
; The pmacro table.
a75 5
; A copy of syntactic pmacros is kept separately.
(define -smacro-table #f)
(define (-smacro-lookup name) (hashq-ref -smacro-table name))
(define (-smacro-set! name val) (hashq-set! -smacro-table name val))

d80 2
a81 4
(define (-pmacro-make name arg-spec default-values
		      syntactic-form? transformer comment)
  (vector -pmacro-marker name arg-spec default-values
	  syntactic-form? transformer comment)
d87 2
a88 3
(define (-pmacro-syntactic-form? pmac) (vector-ref pmac 4))
(define (-pmacro-transformer pmac) (vector-ref pmac 5))
(define (-pmacro-comment pmac) (vector-ref pmac 6))
a108 58
; Issue an error where a number was expected.

(define (-pmacro-expected-number op n)
  (-pmacro-error (string-append "invalid arg for " op ", expected number") n)
)

; Verify N is a number.

(define (-pmacro-verify-number op n)
  (if (not (number? n))
      (-pmacro-expected-number op n))
)

; Issue an error where an integer was expected.

(define (-pmacro-expected-integer op n)
  (-pmacro-error (string-append "invalid arg for " op ", expected integer") n)
)

; Verify N is an integer.

(define (-pmacro-verify-integer op n)
  (if (not (integer? n))
      (-pmacro-expected-integer op n))
)

; Issue an error where a non-negative integer was expected.

(define (-pmacro-expected-non-negative-integer op n)
  (-pmacro-error (string-append "invalid arg for " op ", expected non-negative integer") n)
)

; Verify N is a non-negative integer.

(define (-pmacro-verify-non-negative-integer op n)
  (if (or (not (integer? n))
	  (< n 0))
      (-pmacro-expected-non-negative-integer op n))
)

; Utility to evaluate pmacro args.
; ??? Currently unused, keep for now.

(define (-pmacro-eval expr)
  (eval1 expr)
)

; Expand a list of expressions, in order
; The result is the value of the last one.

(define (-pmacro-expand-expr-list exprs env)
  (let ((result nil))
    (for-each (lambda (expr)
		(set! result (-pmacro-expand expr env)))
	      exprs)
    result)
)

d150 1
a150 1
(define (-pmacro-process-args-1 arg-spec default-values args)
d156 3
a158 2
; Subroutine of -pmacro-apply/-smacro-apply to simplify them.
; Process the arguments, verify the correct number is present.
d160 1
a160 1
(define (-pmacro-process-args macro args)
d163 1
a163 1
    (let ((processed-args (-pmacro-process-args-1 arg-spec default-values args)))
d172 1
a172 16
      processed-args))
)

; Invoke a pmacro.

(define (-pmacro-apply macro args)
  (apply (-pmacro-transformer macro)
	 (-pmacro-process-args macro args))
)

; Invoke a syntactic-form pmacro.
; ENV is handed down from -pmacro-expand.

(define (-smacro-apply macro args env)
  (apply (-pmacro-transformer macro)
	 (cons env (-pmacro-process-args macro args)))
d209 1
a209 1
  ;; Scan each element in EXP and see if the result is a macro invocation.
d211 14
a224 15
    ;; Check for syntactic forms.
    ;; They are handled differently in that we leave it to the transformer
    ;; routine to evaluate the arguments.
    (let ((sform (-smacro-lookup (car exp))))
      (if sform
	  (-smacro-apply sform (cdr exp) env)
	  ;; Not a syntactic form.
	  ;; Evaluate all the arguments first.
	  (let ((scanned-exp (map scan exp)))
	    (let ((macro (check-macro scanned-exp)))
	      (if macro
		  (if (procedure? (-pmacro-transformer macro))
		      (-pmacro-apply macro (cdr scanned-exp))
		      (cons (-pmacro-transformer macro) (cdr scanned-exp)))
		  scanned-exp))))))
d317 1
a317 2
	    (-pmacro-expand ',expansion
			    (-pmacro-env-make ',params (list ,@@params)))))
d326 2
a327 4
; (define-pmacro symbol expansion)
; (define-pmacro symbol ["comment"] expansion)
; (define-pmacro (name args ...) expansion)
; (define-pmacro (name args ...) "documentation" expansion)
a333 2
;
; ??? We may want user-definable "syntactic" macros some day.  Later.
a335 3
  (if (and (not (symbol? header))
	   (not (list? header)))
      (-pmacro-error "invalid pmacro definition" header))
a340 4
    ;;(if (> (length arg-rest) 1)
	;;(-pmacro-error "extraneous arguments to define-pmacro" (cdr arg-rest)))
    ;;(if (not (string? comment))
	;;(-pmacro-error "invalid pmacro comment, expected string" comment))
a348 1
					      #f ; syntactic-form?
d351 2
a352 2
		  (-pmacro-set! name (-pmacro-make name #f #f #f expansion comment))))
	    (-pmacro-set! name (-pmacro-make name #f #f #f expansion comment)))
d354 1
a354 1
		      (-pmacro-make name arg-spec default-values #f
a365 11
; Expand any pmacros in EXPR, without processing .eval.

(define (pmacro-debug expr)
  ; FIXME: Need unwind protection.
  (let ((old-debug -pmacro-debug?))
    (set! -pmacro-debug? #t)
    (let ((result (-pmacro-expand expr '())))
      (set! -pmacro-debug? old-debug)
      result))
)

d369 2
a370 4
  ; FIXME: Need unwind protection.
  (let ((old-debug -pmacro-debug?)
	(old-trace -pmacro-trace?))
    (set! -pmacro-debug? #t)
d373 1
a373 2
      (set! -pmacro-debug? old-debug)
      (set! -pmacro-trace? old-trace)
d379 1
a379 1
; (.sym symbol1 symbol2 ...) - symbol-append, auto-convert numbers
d381 1
a381 1
(define -pmacro-builtin-sym
d394 1
a394 1
; (.str string1 string2 ...) - string-append, auto-convert numbers
d396 1
a396 1
(define -pmacro-builtin-str
d408 1
a408 1
; (.hex number [width]) - convert number to hex string
d412 1
a412 1
(define (-pmacro-builtin-hex num . width)
d424 1
a424 1
; (.upcase string) - convert a string or symbol to uppercase
d426 1
a426 1
(define (-pmacro-builtin-upcase str)
d433 1
a433 1
; (.downcase string) - convert a string or symbol to lowercase
d435 1
a435 1
(define (-pmacro-builtin-downcase str)
d442 1
a442 2
; (.substring string start end) - get part of a string
; `end' can be the symbol `end'.
d444 2
a445 16
(define (-pmacro-builtin-substring str start end)
  (if (not (integer? start)) ;; FIXME: non-negative-integer
      (-pmacro-error "start not an integer" start))
  (if (and (not (integer? end))
	   (not (eq? end 'end)))
      (-pmacro-error "end not an integer nor symbol `end'" end))
  (cond ((string? str)
	 (if (eq? end 'end)
	     (substring str start)
	     (substring str start end)))
	((symbol? str)
	 (if (eq? end 'end)
	     (string->symbol (substring (symbol->string str) start))
	     (string->symbol (substring (symbol->string str) start end))))
	(else
	 (-pmacro-error "invalid argument to .substring" str)))
d458 1
a458 1
(define -pmacro-builtin-splice
d482 1
a482 1
(define (-pmacro-builtin-iota count . start-incr)
d497 1
a497 1
; (.map pmacro arg1 . arg-rest)
d499 1
a499 1
(define (-pmacro-builtin-map pmacro arg1 . arg-rest)
d508 1
a508 13
; (.for-each pmacro arg1 . arg-rest)

(define (-pmacro-builtin-for-each pmacro arg1 . arg-rest)
  (if (not (-pmacro? pmacro))
      (-pmacro-error "not a pmacro" pmacro))
  (let ((transformer (-pmacro-transformer pmacro)))
    (if (not (procedure? transformer))
	(-pmacro-error "not a procedural macro" pmacro))
    (apply for-each (cons transformer (cons arg1 arg-rest)))
    nil) ; need to return something the reader will accept
)

; (.eval expr)
d510 1
a510 13
(define (-pmacro-builtin-eval expr)
  ;; If we're expanding macros for debugging purposes, don't eval,
  ;; just return unchanged.
  (if -pmacro-debug?
      (list '.eval expr)
      (begin
	(reader-process-expanded expr)
	nil)) ;; need to return something the reader will accept
)

; (.apply macro-name arg)

(define (-pmacro-builtin-apply pmacro arg-list)
d519 1
a519 2
; (.pmacro (arg-list) expansion)
; Note: syntactic form
d521 1
a521 3
(define (-pmacro-builtin-pmacro env params expansion)
  ;; ??? Prohibiting improper lists seems unnecessarily restrictive here.
  ;; e.g. (define (foo bar . baz) ...)
d523 2
a524 412
      (-pmacro-error ".pmacro parameter-spec is not a list" params))
  (-pmacro-make '.anonymous params #f #f (-pmacro-build-lambda params expansion) "")
)

; (.let (var-list) expr1 . expr-rest)
; Note: syntactic form

(define (-pmacro-builtin-let env locals expr1 . expr-rest)
  (if (not (list? locals))
      (-pmacro-error ".let locals is not a list" locals))
  (if (not (all-true? (map (lambda (l)
			     (and (list? l)
				  (= (length l) 2)
				  (symbol? (car l))))
			   locals)))
      (-pmacro-error "syntax error in locals list" locals))
  (let* ((evald-locals (map (lambda (l)
			      (cons (car l) (-pmacro-expand (cadr l) env)))
			    locals))
	 (new-env (append! evald-locals env)))
    (-pmacro-expand-expr-list (cons expr1 expr-rest) new-env))
)

; (.if expr then [else])
; Note: syntactic form

(define (-pmacro-builtin-if env expr then-clause . else-clause)
  (case (length else-clause)
    ((0) (if (-pmacro-expand expr env)
	     (-pmacro-expand then-clause env)
	     nil))
    ((1) (if (-pmacro-expand expr env)
	     (-pmacro-expand then-clause env)
	     (-pmacro-expand (car else-clause) env)))
    (else (-pmacro-error "too many elements in else-clause, expecting 0 or 1" else-clause)))
)

; (.case expr ((case-list1) stmt) [case-expr-stmt-list] [(else stmt)])
; Note: syntactic form
; Note: this uses "member" for case comparison (Scheme uses memq I think)

(define (-pmacro-builtin-case env expr case1 . rest)
  (let ((evald-expr (-pmacro-expand expr env)))
    (let loop ((cases (cons case1 rest)))
      (if (null? cases)
	  nil
	  (begin
	    (if (not (list? (car cases)))
		(-pmacro-error "case statement not a list" (car cases)))
	    (if (= (length (car cases)) 1)
		(-pmacro-error "case statement has case but no expr" (car cases)))
	    (if (and (not (eq? (caar cases) 'else))
		     (not (list? (caar cases))))
		(-pmacro-error "case must be \"else\" or list of choices" (caar cases)))
	    (cond ((eq? (caar cases) 'else)
		   (-pmacro-expand-expr-list (cdar cases) env))
		  ((member evald-expr (caar cases))
		   (-pmacro-expand-expr-list (cdar cases) env))
		  (else
		   (loop (cdr cases))))))))
)

; (.cond (expr stmt) [(cond-expr-stmt-list)] [(else stmt)])
; Note: syntactic form

(define (-pmacro-builtin-cond env expr1 . rest)
  (let loop ((exprs (cons expr1 rest)))
    (cond ((null? exprs)
	   nil)
	  ((eq? (car exprs) 'else)
	   (-pmacro-expand-expr-list (cdar exprs) env))
	  (else
	   (let ((evald-expr (-pmacro-expand (caar exprs) env)))
	     (if evald-expr
		 (-pmacro-expand-expr-list (cdar exprs) env)
		 (loop (cdr exprs)))))))
)

; (.begin . stmt-list)
; Note: syntactic form

(define (-pmacro-builtin-begin env . rest)
  (-pmacro-expand-expr-list rest env)
)

; (.print . expr)
; Strings have quotes removed.

(define (-pmacro-builtin-print . exprs)
  (apply message exprs)
  nil ; need to return something the reader will accept
)

; (.dump expr)
; Strings do not have quotes removed.

(define (-pmacro-builtin-dump expr)
  (write expr (current-error-port))
  nil ; need to return something the reader will accept
)

; (.error . expr)

(define (-pmacro-builtin-error . exprs)
  (apply error exprs)
)

; (.list expr1 ...)

(define (-pmacro-builtin-list . exprs)
  exprs
)

; (.ref expr index)

(define (-pmacro-builtin-ref l n)
  (if (not (list? l))
      (-pmacro-error "invalid arg for .ref, expected list" l))
  (if (not (integer? n)) ;; FIXME: call non-negative-integer?
      (-pmacro-error "invalid arg for .ref, expected non-negative integer" n))
  (list-ref l n)
)

; (.length x)

(define (-pmacro-builtin-length x)
  (cond ((symbol? x) (string-length (symbol->string x)))
	((string? x) (string-length x))
	((list? x) (length x))
	(else
	 (-pmacro-error "invalid arg for .length, expected symbol, string, or list" x)))
)

; (.replicate n expr)

(define (-pmacro-builtin-replicate n expr)
  (if (not (integer? n)) ;; FIXME: call non-negative-integer?
      (-pmacro-error "invalid arg for .replicate, expected non-negative integer" n))
  (make-list n expr)
)

; (.equals x y)

(define (-pmacro-builtin-equals x y)
  (equal? x y)
)

; (.and . rest)
; Note: syntactic form
; Elements of EXPRS are evaluated one at a time.
; Unprocessed elements are not evaluated.

(define (-pmacro-builtin-and env . exprs)
  (if (null? exprs)
      #t
      (let loop ((exprs exprs))
	(let ((evald-expr (-pmacro-expand (car exprs) env)))
	  (cond ((null? (cdr exprs)) evald-expr)
		(evald-expr (loop (cdr exprs)))
		(else #f)))))
)

; (.or . rest)
; Note: syntactic form
; Elements of EXPRS are evaluated one at a time.
; Unprocessed elements are not evaluated.

(define (-pmacro-builtin-or env . exprs)
  (let loop ((exprs exprs))
    (if (null? exprs)
	#f
	(let ((evald-expr (-pmacro-expand (car exprs) env)))
	  (if evald-expr
	      evald-expr
	      (loop (cdr exprs))))))
)

; (.not expr)

(define (-pmacro-builtin-not x)
  (not x)
)

; Verify x,y are compatible for eq/ne comparisons.

(define (-pmacro-compatible-for-equality x y)
  (or (and (symbol? x) (symbol? y))
      (and (string? x) (string? y))
      (and (number? x) (number? y)))
)

; (.eq expr)

(define (-pmacro-builtin-eq x y)
  (cond ((symbol? x)
	 (if (symbol? y)
	     (eq? x y)
	     (-pmacro-error "incompatible args for .eq, expected symbol" y)))
	((string? x)
	 (if (string? y)
	     (string=? x y)
	     (-pmacro-error "incompatible args for .eq, expected string" y)))
	((number? x)
	 (if (number? y)
	     (= x y)
	     (-pmacro-error "incompatible args for .eq, expected number" y)))
	(else
	 (-pmacro-error "unsupported args for .eq" (list x y))))
)

; (.ne expr)

(define (-pmacro-builtin-ne x y)
  (cond ((symbol? x)
	 (if (symbol? y)
	     (not (eq? x y))
	     (-pmacro-error "incompatible args for .ne, expected symbol" y)))
	((string? x)
	 (if (string? y)
	     (not (string=? x y))
	     (-pmacro-error "incompatible args for .ne, expected string" y)))
	((number? x)
	 (if (number? y)
	     (not (= x y))
	     (-pmacro-error "incompatible args for .ne, expected number" y)))
	(else
	 (-pmacro-error "unsupported args for .ne" (list x y))))
)

; (.lt expr)

(define (-pmacro-builtin-lt x y)
  (-pmacro-verify-number ".lt" x)
  (-pmacro-verify-number ".lt" y)
  (< x y)
)

; (.gt expr)

(define (-pmacro-builtin-gt x y)
  (-pmacro-verify-number ".gt" x)
  (-pmacro-verify-number ".gt" y)
  (> x y)
)

; (.le expr)

(define (-pmacro-builtin-le x y)
  (-pmacro-verify-number ".le" x)
  (-pmacro-verify-number ".le" y)
  (<= x y)
)

; (.ge expr)

(define (-pmacro-builtin-ge x y)
  (-pmacro-verify-number ".ge" x)
  (-pmacro-verify-number ".ge" y)
  (>= x y)
)

; (.add x y)

(define (-pmacro-builtin-add x y)
  (-pmacro-verify-number ".add" x)
  (-pmacro-verify-number ".add" y)
  (+ x y)
)

; (.sub x y)

(define (-pmacro-builtin-sub x y)
  (-pmacro-verify-number ".sub" x)
  (-pmacro-verify-number ".sub" y)
  (- x y)
)

; (.mul x y)

(define (-pmacro-builtin-mul x y)
  (-pmacro-verify-number ".mul" x)
  (-pmacro-verify-number ".mul" y)
  (* x y)
)

; (.div x y) - integer division

(define (-pmacro-builtin-div x y)
  (-pmacro-verify-integer ".div" x)
  (-pmacro-verify-integer ".div" y)
  (quotient x y)
)

; (.rem x y) - integer remainder
; ??? Need to decide behavior.

(define (-pmacro-builtin-rem x y)
  (-pmacro-verify-integer ".rem" x)
  (-pmacro-verify-integer ".rem" y)
  (remainder x y)
)

; (.sll x n) - shift left logical

(define (-pmacro-builtin-sll x n)
  (-pmacro-verify-integer ".sll" x)
  (-pmacro-verify-non-negative-integer ".sll" n)
  (if (= n 0)
      x
      (* x n 2))
)

; (.srl x n) - shift right logical
; X must be non-negative, otherwise behavior is undefined.
; [Unless we introduce a size argument: How do you logical shift right
; an arbitrary precision negative number?]

(define (-pmacro-builtin-srl x n)
  (-pmacro-verify-non-negative-integer ".srl" x)
  (-pmacro-verify-non-negative-integer ".srl" n)
  (if (= n 0)
      x
      (quotient x (* n 2)))
)

; (.sra x n) - shift right arithmetic

(define (-pmacro-builtin-sra x n)
  (-pmacro-verify-integer ".sra" x)
  (-pmacro-verify-non-negative-integer ".sra" n)
  (cond ((= n 0) x)
	((= x -1) -1)
	(else (quotient x (* n 2))))
)

; (.bitand x y) - bitwise and

(define (-pmacro-builtin-bitand x y)
  (-pmacro-verify-integer ".bitand" x)
  (-pmacro-verify-integer ".bitand" y)
  (logand x y)
)

; (.bitor x y) - bitwise or

(define (-pmacro-builtin-bitor x y)
  (-pmacro-verify-integer ".bitor" x)
  (-pmacro-verify-integer ".bitor" y)
  (logior x y)
)

; (.bitxor x y) - bitwise xor

(define (-pmacro-builtin-bitxor x y)
  (-pmacro-verify-integer ".bitxor" x)
  (-pmacro-verify-integer ".bitxor" y)
  (logxor x y)
)

; (.bitinv x) - bitwise invert

(define (-pmacro-builtin-bitinv x)
  (-pmacro-verify-integer ".bitinv" x)
  (lognot x)
)

; (.car expr)

(define (-pmacro-builtin-car l)
  (if (pair? l)
      (car l)
      (-pmacro-error "invalid arg for .car, expected pair" l))
)

; (.cdr expr)

(define (-pmacro-builtin-cdr l)
  (if (pair? l)
      (cdr l)
      (-pmacro-error "invalid arg for .cdr, expected pair" l))
)

; (.caar expr)

(define (-pmacro-builtin-caar l)
  (if (and (pair? l) (pair? (car l)))
      (caar l)
      (-pmacro-error "invalid arg for .caar" l))
)

; (.cadr expr)

(define (-pmacro-builtin-cadr l)
  (if (and (pair? l) (pair? (cdr l)))
      (cadr l)
      (-pmacro-error "invalid arg for .cadr" l))
)

; (.cdar expr)

(define (-pmacro-builtin-cdar l)
  (if (and (pair? l) (pair? (car l)))
      (cdar l)
      (-pmacro-error "invalid arg for .cdar" l))
)

; (.cddr expr)

(define (-pmacro-builtin-cddr l)
  (if (and (pair? l) (pair? (cdr l)))
      (cddr l)
      (-pmacro-error "invalid arg for .cddr" l))
a530 1
  (set! -smacro-table (make-hash-table 41))
d534 36
a569 69
  (let ((macros
	 ;; name arg-spec syntactic? function description
	 (list
	  (list '.sym 'symbols #f -pmacro-builtin-sym "symbol-append")
	  (list '.str 'strings #f -pmacro-builtin-str "string-append")
	  (list '.hex '(number . width) #f -pmacro-builtin-hex "convert to -hex, with optional width")
	  (list '.upcase '(string) #f -pmacro-builtin-upcase "string-upcase")
	  (list '.downcase '(string) #f -pmacro-builtin-downcase "string-downcase")
	  (list '.substring '(string start end) #f -pmacro-builtin-substring "get start of a string")
	  (list '.splice 'arg-list #f -pmacro-builtin-splice "splice lists into the outer list")
	  (list '.iota '(count . start-incr) #f -pmacro-builtin-iota "iota number generator")
	  (list '.map '(pmacro list1 . rest) #f -pmacro-builtin-map "map a macro over a list of arguments")
	  (list '.for-each '(pmacro list1 . rest) #f -pmacro-builtin-for-each "execute a macro over a list of arguments")
	  (list '.eval '(expr) #f -pmacro-builtin-eval "process expr immediately")
	  (list '.apply '(macro arg-list) #f -pmacro-builtin-apply "apply a macro to a list of arguments")
	  (list '.pmacro '(params expansion) #t -pmacro-builtin-pmacro "create a pmacro on-the-fly")
	  (list '.let '(locals expr1 . rest) #t -pmacro-builtin-let "create a binding context")
	  (list '.if '(expr then . else) #t -pmacro-builtin-if "if expr is true, process then, else else")
	  (list '.case '(expr case1 . rest) #t -pmacro-builtin-case "process statement that matches expr")
	  (list '.cond '(expr1 . rest) #t -pmacro-builtin-cond "process first statement whose expr succeeds")
	  (list '.begin 'rest #t -pmacro-builtin-begin "process a sequence of statements")
	  (list '.print 'exprs #f -pmacro-builtin-print "print exprs, for debugging purposes")
	  (list '.dump '(expr)  #f-pmacro-builtin-dump "dump expr, for debugging purposes")
	  (list '.error 'message #f -pmacro-builtin-error "print error message and exit")
	  (list '.list 'exprs #f -pmacro-builtin-list "return a list of exprs")
	  (list '.ref '(l n) #f -pmacro-builtin-ref "return n'th element of list l")
	  (list '.length '(x) #f -pmacro-builtin-length "return length of symbol, string, or list")
	  (list '.replicate '(n expr) #f -pmacro-builtin-replicate "return list of expr replicated n times")
	  (list '.equals '(x y) #f -pmacro-builtin-equals "deep comparison of x and y")
	  (list '.and 'rest #t -pmacro-builtin-and "return #f if any element is #f, otherwise return last element")
	  (list '.or 'rest #t -pmacro-builtin-or "return first non-#f element, otherwise #f")
	  (list '.not '(x) #f -pmacro-builtin-not "return !x")
	  (list '.eq '(x y) #f -pmacro-builtin-eq "return true if x == y")
	  (list '.ne '(x y) #f -pmacro-builtin-ne "return true if x != y")
	  (list '.lt '(x y) #f -pmacro-builtin-lt "return true if x < y")
	  (list '.gt '(x y) #f -pmacro-builtin-gt "return true if x > y")
	  (list '.le '(x y) #f -pmacro-builtin-le "return true if x <= y")
	  (list '.ge '(x y) #f -pmacro-builtin-ge "return true if x >= y")
	  (list '.add '(x y) #f -pmacro-builtin-add "return x + y")
	  (list '.sub '(x y) #f -pmacro-builtin-sub "return x - y")
	  (list '.mul '(x y) #f -pmacro-builtin-mul "return x * y")
	  (list '.div '(x y) #f -pmacro-builtin-div "return x / y")
	  (list '.rem '(x y) #f -pmacro-builtin-rem "return x % y")
	  (list '.sll '(x n) #f -pmacro-builtin-sll "return logical x << n")
	  (list '.srl '(x n) #f -pmacro-builtin-srl "return logical x >> n")
	  (list '.sra '(x n) #f -pmacro-builtin-sra "return arithmetic x >> n")
	  (list '.bitand '(x y) #f -pmacro-builtin-bitand "return x & y")
	  (list '.bitor '(x y) #f -pmacro-builtin-bitor "return x | y")
	  (list '.bitxor '(x y) #f -pmacro-builtin-bitxor "return x ^ y")
	  (list '.bitinv '(x) #f -pmacro-builtin-bitinv "return ~x")
	  (list '.car '(x) #f -pmacro-builtin-car "return (car x)")
	  (list '.cdr '(x) #f -pmacro-builtin-cdr "return (cdr x)")
	  (list '.caar '(x) #f -pmacro-builtin-caar "return (caar x)")
	  (list '.cadr '(x) #f -pmacro-builtin-cadr "return (cadr x)")
	  (list '.cdar '(x) #f -pmacro-builtin-cdar "return (cdar x)")
	  (list '.cddr '(x) #f -pmacro-builtin-cddr "return (cddr x)")
	  )))
    (for-each (lambda (x)
		(let ((name (list-ref x 0))
		      (arg-spec (list-ref x 1))
		      (syntactic? (list-ref x 2))
		      (pmacro (list-ref x 3))
		      (comment (list-ref x 4)))
		  (-pmacro-set! name
				(-pmacro-make name arg-spec #f syntactic? pmacro comment))
		  (if syntactic?
		      (-smacro-set! name
				    (-pmacro-make name arg-spec #f syntactic? pmacro comment)))))
	      macros))
@


1.5
log
@* pmacros.scm (-pmacro-upcase, -pmacro-downcase): Handle symbols
as well as strings.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
@


1.5.6.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2009 Red Hat, Inc.
@


1.4
log
@* pmacros.scm (pmacros-init!): For .eval macros, use eval1 as the
transformer procedure, not eval.  Transformer procedures take one
argument.
@
text
@d427 4
a430 1
  (string-upcase str)
d436 4
a439 1
  (string-downcase str)
@


1.3
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@d563 1
a563 1
  (-pmacro-set! '.eval (-pmacro-make '.eval '(expr) #f (eval1 'eval) "eval"))
@


1.2
log
@	* pmacros.scm (-pmacro-expand,scan): If result is a symbol,
	call scan-symbol on it, to enable recursive macro-expansion.
@
text
@d44 2
a45 2
; (.sym symbol1 symbol2 ...)          - symbol-append
; (.str string1 string2 ...)          - string-append
d316 2
a317 2
  (eval `(lambda ,params
	   (-pmacro-expand ',expansion (-pmacro-env-make ',params (list ,@@params)))))
d383 9
a391 6
    (apply symbol-append
	   (map (lambda (elm)
		  (if (number? elm)
		      (number->string elm)
		      elm))
		args)))
d400 5
a404 3
		  (if (number? elm)
		      (number->string elm)
		      elm))
d563 1
a563 1
  (-pmacro-set! '.eval (-pmacro-make '.eval '(expr) #f (eval 'eval) "eval"))
@


1.1
log
@Initial revision
@
text
@d232 5
a236 5
      ; ??? We use to re-examine `result' to see if it was another pmacro
      ; invocation.  This allowed doing things like ((.sym a b c) arg1 arg2)
      ; where `abc' is a pmacro.  Scheme doesn't work this way, so it was
      ; removed.  It can be put back should it ever be warranted.
      result))
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
