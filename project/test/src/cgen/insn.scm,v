head	1.42;
access;
symbols
	sid-snapshot-20180601:1.42
	cgen-snapshot-20180601:1.42
	sid-snapshot-20180501:1.42
	cgen-snapshot-20180501:1.42
	sid-snapshot-20180401:1.42
	cgen-snapshot-20180401:1.42
	sid-snapshot-20180301:1.42
	cgen-snapshot-20180301:1.42
	sid-snapshot-20180201:1.42
	cgen-snapshot-20180201:1.42
	sid-snapshot-20180101:1.42
	cgen-snapshot-20180101:1.42
	sid-snapshot-20171201:1.42
	cgen-snapshot-20171201:1.42
	sid-snapshot-20171101:1.42
	cgen-snapshot-20171101:1.42
	sid-snapshot-20171001:1.42
	cgen-snapshot-20171001:1.42
	sid-snapshot-20170901:1.42
	cgen-snapshot-20170901:1.42
	sid-snapshot-20170801:1.42
	cgen-snapshot-20170801:1.42
	sid-snapshot-20170701:1.42
	cgen-snapshot-20170701:1.42
	sid-snapshot-20170601:1.42
	cgen-snapshot-20170601:1.42
	sid-snapshot-20170501:1.42
	cgen-snapshot-20170501:1.42
	sid-snapshot-20170401:1.42
	cgen-snapshot-20170401:1.42
	sid-snapshot-20170301:1.42
	cgen-snapshot-20170301:1.42
	sid-snapshot-20170201:1.42
	cgen-snapshot-20170201:1.42
	sid-snapshot-20170101:1.42
	cgen-snapshot-20170101:1.42
	sid-snapshot-20161201:1.42
	cgen-snapshot-20161201:1.42
	sid-snapshot-20161101:1.42
	cgen-snapshot-20161101:1.42
	sid-snapshot-20160901:1.42
	cgen-snapshot-20160901:1.42
	sid-snapshot-20160801:1.42
	cgen-snapshot-20160801:1.42
	sid-snapshot-20160701:1.42
	cgen-snapshot-20160701:1.42
	sid-snapshot-20160601:1.42
	cgen-snapshot-20160601:1.42
	sid-snapshot-20160501:1.42
	cgen-snapshot-20160501:1.42
	sid-snapshot-20160401:1.42
	cgen-snapshot-20160401:1.42
	sid-snapshot-20160301:1.42
	cgen-snapshot-20160301:1.42
	sid-snapshot-20160201:1.42
	cgen-snapshot-20160201:1.42
	sid-snapshot-20160101:1.42
	cgen-snapshot-20160101:1.42
	sid-snapshot-20151201:1.42
	cgen-snapshot-20151201:1.42
	sid-snapshot-20151101:1.42
	cgen-snapshot-20151101:1.42
	sid-snapshot-20151001:1.42
	cgen-snapshot-20151001:1.42
	sid-snapshot-20150901:1.42
	cgen-snapshot-20150901:1.42
	sid-snapshot-20150801:1.42
	cgen-snapshot-20150801:1.42
	sid-snapshot-20150701:1.42
	cgen-snapshot-20150701:1.42
	sid-snapshot-20150601:1.42
	cgen-snapshot-20150601:1.42
	sid-snapshot-20150501:1.42
	cgen-snapshot-20150501:1.42
	sid-snapshot-20150401:1.42
	cgen-snapshot-20150401:1.42
	sid-snapshot-20150301:1.42
	cgen-snapshot-20150301:1.42
	sid-snapshot-20150201:1.42
	cgen-snapshot-20150201:1.42
	sid-snapshot-20150101:1.42
	cgen-snapshot-20150101:1.42
	sid-snapshot-20141201:1.42
	cgen-snapshot-20141201:1.42
	sid-snapshot-20141101:1.42
	cgen-snapshot-20141101:1.42
	sid-snapshot-20141001:1.42
	cgen-snapshot-20141001:1.42
	sid-snapshot-20140901:1.42
	cgen-snapshot-20140901:1.42
	sid-snapshot-20140801:1.42
	cgen-snapshot-20140801:1.42
	sid-snapshot-20140701:1.42
	cgen-snapshot-20140701:1.42
	sid-snapshot-20140601:1.42
	cgen-snapshot-20140601:1.42
	sid-snapshot-20140501:1.42
	cgen-snapshot-20140501:1.42
	sid-snapshot-20140401:1.42
	cgen-snapshot-20140401:1.42
	sid-snapshot-20140301:1.42
	cgen-snapshot-20140301:1.42
	sid-snapshot-20140201:1.42
	cgen-snapshot-20140201:1.42
	sid-snapshot-20140101:1.42
	cgen-snapshot-20140101:1.42
	sid-snapshot-20131201:1.42
	cgen-snapshot-20131201:1.42
	sid-snapshot-20131101:1.42
	cgen-snapshot-20131101:1.42
	sid-snapshot-20131001:1.42
	cgen-snapshot-20131001:1.42
	sid-snapshot-20130901:1.42
	cgen-snapshot-20130901:1.42
	sid-snapshot-20130801:1.42
	cgen-snapshot-20130801:1.42
	sid-snapshot-20130701:1.42
	cgen-snapshot-20130701:1.42
	sid-snapshot-20130601:1.42
	cgen-snapshot-20130601:1.42
	sid-snapshot-20130501:1.42
	cgen-snapshot-20130501:1.42
	sid-snapshot-20130401:1.42
	cgen-snapshot-20130401:1.42
	sid-snapshot-20130301:1.42
	cgen-snapshot-20130301:1.42
	sid-snapshot-20130201:1.42
	cgen-snapshot-20130201:1.42
	sid-snapshot-20130101:1.42
	cgen-snapshot-20130101:1.42
	sid-snapshot-20121201:1.42
	cgen-snapshot-20121201:1.42
	sid-snapshot-20121101:1.42
	cgen-snapshot-20121101:1.42
	sid-snapshot-20121001:1.42
	cgen-snapshot-20121001:1.42
	sid-snapshot-20120901:1.42
	cgen-snapshot-20120901:1.42
	sid-snapshot-20120801:1.42
	cgen-snapshot-20120801:1.42
	sid-snapshot-20120701:1.42
	cgen-snapshot-20120701:1.42
	sid-snapshot-20120601:1.42
	cgen-snapshot-20120601:1.42
	sid-snapshot-20120501:1.42
	cgen-snapshot-20120501:1.42
	sid-snapshot-20120401:1.42
	cgen-snapshot-20120401:1.42
	sid-snapshot-20120301:1.42
	cgen-snapshot-20120301:1.42
	sid-snapshot-20120201:1.42
	cgen-snapshot-20120201:1.42
	sid-snapshot-20120101:1.42
	cgen-snapshot-20120101:1.42
	sid-snapshot-20111201:1.42
	cgen-snapshot-20111201:1.42
	sid-snapshot-20111101:1.42
	cgen-snapshot-20111101:1.42
	sid-snapshot-20111001:1.42
	cgen-snapshot-20111001:1.42
	sid-snapshot-20110901:1.42
	cgen-snapshot-20110901:1.42
	sid-snapshot-20110801:1.42
	cgen-snapshot-20110801:1.42
	sid-snapshot-20110701:1.42
	cgen-snapshot-20110701:1.42
	sid-snapshot-20110601:1.42
	cgen-snapshot-20110601:1.42
	sid-snapshot-20110501:1.42
	cgen-snapshot-20110501:1.42
	sid-snapshot-20110401:1.42
	cgen-snapshot-20110401:1.42
	sid-snapshot-20110301:1.42
	cgen-snapshot-20110301:1.42
	sid-snapshot-20110201:1.42
	cgen-snapshot-20110201:1.42
	sid-snapshot-20110101:1.42
	cgen-snapshot-20110101:1.42
	sid-snapshot-20101201:1.42
	cgen-snapshot-20101201:1.42
	sid-snapshot-20101101:1.42
	cgen-snapshot-20101101:1.42
	sid-snapshot-20101001:1.42
	cgen-snapshot-20101001:1.42
	sid-snapshot-20100901:1.42
	cgen-snapshot-20100901:1.42
	sid-snapshot-20100801:1.42
	cgen-snapshot-20100801:1.42
	sid-snapshot-20100701:1.42
	cgen-snapshot-20100701:1.42
	sid-snapshot-20100601:1.42
	cgen-snapshot-20100601:1.42
	sid-snapshot-20100501:1.42
	cgen-snapshot-20100501:1.42
	sid-snapshot-20100401:1.42
	cgen-snapshot-20100401:1.42
	sid-snapshot-20100301:1.42
	cgen-snapshot-20100301:1.42
	sid-snapshot-20100201:1.40
	cgen-snapshot-20100201:1.40
	sid-snapshot-20100101:1.40
	cgen-snapshot-20100101:1.40
	sid-snapshot-20091201:1.40
	cgen-snapshot-20091201:1.40
	sid-snapshot-20091101:1.36
	cgen-snapshot-20091101:1.36
	sid-snapshot-20091001:1.35
	cgen-snapshot-20091001:1.35
	arc-sim-20090309:1.14
	sid-snapshot-20090901:1.26
	cgen-snapshot-20090901:1.26
	sid-snapshot-20090801:1.21
	cgen-snapshot-20090801:1.21
	sid-snapshot-20090701:1.16
	cgen-snapshot-20090701:1.16
	dje-cgen-play1-branch:1.16.0.2
	dje-cgen-play1-branchpoint:1.16
	cgen-1_1-branch:1.14.0.6
	cgen-1_1-branchpoint:1.14
	sid-snapshot-20090601:1.14
	cgen-snapshot-20090601:1.14
	sid-snapshot-20090501:1.14
	cgen-snapshot-20090501:1.14
	sid-snapshot-20090401:1.14
	cgen-snapshot-20090401:1.14
	arc-insight_6_8-branch:1.14.0.4
	arc-insight_6_8-branchpoint:1.14
	sid-snapshot-20090301:1.14
	cgen-snapshot-20090301:1.14
	sid-snapshot-20090201:1.14
	cgen-snapshot-20090201:1.14
	sid-snapshot-20090101:1.14
	cgen-snapshot-20090101:1.14
	sid-snapshot-20081201:1.14
	cgen-snapshot-20081201:1.14
	sid-snapshot-20081101:1.14
	cgen-snapshot-20081101:1.14
	sid-snapshot-20081001:1.14
	cgen-snapshot-20081001:1.14
	sid-snapshot-20080901:1.14
	cgen-snapshot-20080901:1.14
	sid-snapshot-20080801:1.14
	cgen-snapshot-20080801:1.14
	sid-snapshot-20080701:1.14
	cgen-snapshot-20080701:1.14
	sid-snapshot-20080601:1.14
	cgen-snapshot-20080601:1.14
	sid-snapshot-20080501:1.14
	cgen-snapshot-20080501:1.14
	sid-snapshot-20080403:1.14
	sid-snapshot-20080401:1.14
	cgen-snapshot-20080401:1.14
	sid-snapshot-20080301:1.14
	cgen-snapshot-20080301:1.14
	sid-snapshot-20080201:1.14
	cgen-snapshot-20080201:1.14
	sid-snapshot-20080101:1.14
	cgen-snapshot-20080101:1.14
	sid-snapshot-20071201:1.14
	cgen-snapshot-20071201:1.14
	sid-snapshot-20071101:1.14
	cgen-snapshot-20071101:1.14
	sid-snapshot-20071001:1.14
	cgen-snapshot-20071001:1.14
	msnyder-fork-checkpoint-branch:1.14.0.2
	msnyder-fork-checkpoint-branchpoint:1.14
	sid-20020905-branchpoint:1.6
	sid-20020905-branch:1.6.0.4
	cagney_regbuf-20020515-branch:1.6.0.2
	cagney_regbuf-20020515-branchpoint:1.6
	cygnus_cvs_20020108_pre:1.6
	cgen-1-1-branch:1.5.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.42
date	2010.02.13.03.39.15;	author devans;	state Exp;
branches;
next	1.41;

1.41
date	2010.02.12.02.12.12;	author devans;	state Exp;
branches;
next	1.40;

1.40
date	2009.11.23.09.03.01;	author devans;	state Exp;
branches;
next	1.39;

1.39
date	2009.11.23.03.28.31;	author devans;	state Exp;
branches;
next	1.38;

1.38
date	2009.11.03.16.24.01;	author devans;	state Exp;
branches;
next	1.37;

1.37
date	2009.11.01.22.54.16;	author devans;	state Exp;
branches;
next	1.36;

1.36
date	2009.10.26.00.56.34;	author devans;	state Exp;
branches;
next	1.35;

1.35
date	2009.09.23.22.30.19;	author devans;	state Exp;
branches;
next	1.34;

1.34
date	2009.09.10.08.07.04;	author devans;	state Exp;
branches;
next	1.33;

1.33
date	2009.09.10.07.23.29;	author devans;	state Exp;
branches;
next	1.32;

1.32
date	2009.09.09.22.21.29;	author devans;	state Exp;
branches;
next	1.31;

1.31
date	2009.09.09.21.01.39;	author devans;	state Exp;
branches;
next	1.30;

1.30
date	2009.09.09.20.43.04;	author devans;	state Exp;
branches;
next	1.29;

1.29
date	2009.09.09.08.00.16;	author devans;	state Exp;
branches;
next	1.28;

1.28
date	2009.09.09.03.51.11;	author devans;	state Exp;
branches;
next	1.27;

1.27
date	2009.09.07.22.17.34;	author devans;	state Exp;
branches;
next	1.26;

1.26
date	2009.08.27.04.22.56;	author devans;	state Exp;
branches;
next	1.25;

1.25
date	2009.08.19.15.58.10;	author devans;	state Exp;
branches;
next	1.24;

1.24
date	2009.08.18.01.40.56;	author devans;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.12.22.33.37;	author devans;	state Exp;
branches;
next	1.22;

1.22
date	2009.08.06.16.40.43;	author devans;	state Exp;
branches;
next	1.21;

1.21
date	2009.07.21.05.44.41;	author devans;	state Exp;
branches;
next	1.20;

1.20
date	2009.07.18.20.44.58;	author devans;	state Exp;
branches;
next	1.19;

1.19
date	2009.07.16.17.22.44;	author devans;	state Exp;
branches;
next	1.18;

1.18
date	2009.07.07.18.52.32;	author devans;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.07.18.44.09;	author devans;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2009.06.22.07.02.36;	author devans;	state Exp;
branches;
next	1.14;

1.14
date	2005.01.27.20.31.12;	author jimb;	state Exp;
branches
	1.14.6.1;
next	1.13;

1.13
date	2005.01.20.22.57.10;	author jimb;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.16.05.35.47;	author devans;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.08.16.19.35;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.10.21.58.33;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.10.21.22.02;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2002.12.20.02.22.22;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.18.01.43.11;	author bje;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.03.18.30.26;	author brolley;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.18.03.17.12;	author bje;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.17.19.34.07;	author graydon;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.12.11.42.48;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.27.02.28.06;	author devans;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.16.2.1
date	2009.07.14.16.19.51;	author devans;	state Exp;
branches;
next	;

1.14.6.1
date	2009.06.24.14.57.45;	author devans;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.42
log
@update copyright year
@
text
@; Instruction definitions.
; Copyright (C) 2000, 2009, 2010 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.

; Class to hold an insn.

(define <insn>
  (class-make '<insn>
	      '(<source-ident>)
	      '(
		; Used to explicitly specify mnemonic, now it's computed from
		; syntax string.  ??? Might be useful as an override someday.
		;mnemonic

		; Instruction syntax string.
		syntax

		; The insn fields as specified in the .cpu file.
		; Also contains values for constant fields.
		iflds
		(/insn-value . #f) ; Lazily computed cache
		(/insn-base-value . #f) ; Lazily computed cache

		; RTL source of assertions of ifield values or #f if none.
		; This is used, for example, by the decoder to help
		; distinguish what would otherwise be an ambiguity in the
		; specification.  It is also used by decode-split support.
		; ??? It could also be used the the assembler/disassembler
		; some day.
		(ifield-assertion . #f)

		; The <fmt-desc> of the insn.
		; This is used to help calculate the ifmt,sfmt members.
		(fmt-desc . #f)

		; The <iformat> of the insn.
		(ifmt . #f)

		; The <sformat> of the insn.
		(sfmt . #f)

		; Temp slot for use by applications.
		(tmp . #f)

		; Instruction semantics.
		; This is the rtl in source form, as provided in the
		; description file, or #f if there is none.
		;
		; There are a few issues (ick, I hate that word) to consider
		; here:
		; - some apps don't need the trap checks (e.g. SIGSEGV)
		; - some apps treat the pieces in different ways
		; - the simulator tries to merge common fragments among insns
		;   to reduce code size in a pbb simulator
		;
		; Some insns don't have any semantics at all, they are defined
		; in another insn [akin to anonymous patterns in gcc].  wip.
		;
		; ??? GCC-like apps will need a new field to allow specifying
		; the semantics if a different value is needed.  wip.
		; ??? May wish to put this and the compiled forms in a
		; separate class.
		; ??? Contents of trap expressions is wip.  It will probably
		; be a sequence with an #:errchk modifier or some such.
		semantics

		; The processed form of the semantics.
		; This remains #f for virtual insns (FIXME: keep?).
		(canonical-semantics . #f)

		; The processed form of the semantics.
		; This remains #f for virtual insns (FIXME: keep?).
		(compiled-semantics . #f)

		; The mapping of the semantics onto the host.
		; FIXME: Not sure what its value will be.
		; Another thing that will be needed is [in some cases] a more
		; simplified version of the RTL for use by apps like compilers.
		; Perhaps that's what this will become.
		;host-semantics

		; The function unit usage of the instruction.
		timing
		)
	      nil)
)

(method-make-make! <insn>
		   '(location name comment attrs syntax iflds ifield-assertion
		     semantics timing)
)

; Accessor fns

(define-getters <insn> insn
  (syntax iflds ifield-assertion fmt-desc ifmt sfmt tmp
	  semantics canonical-semantics compiled-semantics timing)
)

(define-setters <insn> insn
  (fmt-desc ifmt sfmt tmp ifield-assertion
   canonical-semantics compiled-semantics)
)

; Return a boolean indicating if X is an <insn>.

(define (insn? x) (class-instance? <insn> x))

; Return a list of the machs that support INSN.

(define (insn-machs insn)
  nil ; ??? wip
)

; Return the length of INSN in bits.

(define (insn-length insn)
  (ifmt-length (insn-ifmt insn))
)

; Return the length of INSN in bytes.

(define (insn-length-bytes insn)
  (bits->bytes (insn-length insn))
)

; Return instruction mnemonic.
; This is computed from the syntax string.
; The mnemonic, as we define it, is everything up to, but not including, the
; first space or '$'.
; FIXME: Rename to syntax-mnemonic, and take a syntax string argument.
; FIXME: Doesn't handle \$ to indicate a $ is actually in the mnemonic.

(define (insn-mnemonic insn)
  (letrec ((mnem-len (lambda (str len)
		       (cond ((= (string-length str) 0) len)
			     ((char=? #\space (string-ref str 0)) len)
			     ((char=? #\$ (string-ref str 0)) len)
			     (else (mnem-len (string-drop1 str) (+ len 1)))))))
    (string-take (mnem-len (insn-syntax insn) 0) (insn-syntax insn)))
)

; Return enum cgen_insn_types value for INSN.

(define (insn-enum insn)
  (string-upcase (string-append "@@ARCH@@_INSN_" (gen-sym insn)))
)

; Return enum for insn named INSN-NAME.
; This is needed for the `invalid' insn, there is no object for it.
; [Though obviously having such an object seems like a good idea.]

(define (gen-insn-enum insn-name)
  (string-upcase (string-append "@@ARCH@@_INSN_" (gen-c-symbol insn-name)))
)

; Insns with derived operands (see define-derived-operand).
; ??? These are [currently] recorded separately to minimize impact on existing
; code while the design is worked out.
;
; The class is called <multi-insn> because the insn has multiple variants,
; one for each combination of "anyof" alternatives.
; Internally we create one <insn> per alternative.  The theory is that this
; will remain an internal implementation issue.  When appropriate applications
; will collapse the number of insns in a way that is appropriate for them.
;
; ??? Another way to do this is with insn templates.  One problem the current
; way has is that it requires each operand's assembler syntax to be self
; contained (one way to fix this is to use "fake" operands like before).
; Insn templates needn't have this problem.  On the other hand insn templates
; [seem to] require more description file entries.
;
; ??? This doesn't use all of the members of <insn>.
; The <multi-insn> class is wip, but should eventually reorganize <insn>.
; This reorganization might also take into account real, virtual, etc. insns.

(define <multi-insn>
  (class-make '<multi-insn>
	      '(<insn>)
	      '(
		; An <insn> is created for each combination of "anyof"
		; alternatives.  They are recorded with other insns, but a
		; list of them is recorded here as well.
		; This is #f if the sub-insns haven't been instantiated yet.
		(sub-insns . #f)
		)
	      nil)
)

(method-make-make! <multi-insn>
		   '(location name comment attrs syntax iflds ifield-assertion
		     semantics timing)
)

(define-getters <multi-insn> multi-insn (sub-insns))

; Return a boolean indicating if X is a <multi-insn>.

(define (multi-insn? x) (class-instance? <multi-insn> x))

; Subroutine of /sub-insn-make! to create the ifield list.
; Return encoding of {insn} with each element of {anyof-operands} replaced
; with {new-values}.
; {value-names} is a list of names of {anyof-operands}.

(define (/sub-insn-ifields insn anyof-operands value-names new-values)
  ; Delete ifields of {anyof-operands} and add those for {new-values}.
  (let ((iflds
	 (append!
	  ; Delete ifields in {anyof-operands}.
	  (find (lambda (f)
		  (not (and (ifld-anyof-operand? f)
			    (memq (obj:name (ifld-get-value f))
				  value-names))))
		(insn-iflds insn))
	  ; Add ifields for {new-values}.
	  (map derived-encoding new-values)))

	; Return the last ifield of OWNER in IFLD-LIST.
	; OWNER is the object that owns the <ifield> we want.
	; For ifields, the owner is the ifield itself.
	; For operands, the owner is the operand.
	; For derived operands, the owner is the "anyof" parent.
	; IFLD-LIST is an unsorted list of <ifield> elements.
	(find-preceder
	 (lambda (ifld-list owner)
	   (cond ((ifield? owner)
		  owner)
		 ((anyof-operand? owner)
		  ; This is the interesting case.  The instantiated choice of
		  ; {owner} is in {ifld-list}.  We have to find it.
		  (let* ((name (obj:name owner))
			 (result
			  (find-first (lambda (f)
					(and (derived-ifield? f)
					     (anyof-instance? (derived-ifield-owner f))
					     (eq? name (obj:name (anyof-instance-parent (derived-ifield-owner f))))))
				      ifld-list)))
		    (assert result)
		    result))
		 ((operand? owner) ; derived operands are handled here too
		  (let ((result (op-ifield owner)))
		    (assert result)
		    result))
		 (else
		  (error "`owner' not <ifield>, <operand>, or <derived-operand>")))))
	)

    ; Resolve any `follows' specs.
    ; Bad worst case performance but ifield lists aren't usually that long.
    ; FIXME: Doesn't handle A following B following C.
    (map (lambda (f)
	   (let ((follows (ifld-follows f)))
	     (if follows
		 (let ((preceder (find-preceder iflds follows)))
		   (ifld-new-word-offset f (ifld-next-word preceder)))
		 f)))
	 iflds))
)


; Subroutine of multi-insn-instantiate! to instantiate one insn.
; INSN is the parent insn.
; ANYOF-OPERANDS is a list of the <anyof-operand>'s of INSN.
; NEW-VALUES is a list of the value to use for each corresponding element in
; ANYOF-OPERANDS.  Each element is a <derived-operand>.

(define (/sub-insn-make! insn anyof-operands new-values)
  (assert (= (length anyof-operands) (length new-values)))
  (assert (all-true? (map anyof-operand? anyof-operands)))
  (assert (all-true? (map derived-operand? new-values)))
  (logit 3 "Instantiating "
	 (obj:name insn)
	 ":"
	 (string-map (lambda (op newval)
		       (string/symbol-append " "
					     (obj:name op)
					     "="
					     (obj:name newval)))
		     anyof-operands new-values)
	 " ...\n")

  (let* ((value-names (map obj:name anyof-operands))
	 (ifields (/sub-insn-ifields insn anyof-operands value-names new-values))
	 (known-values (ifld-known-values ifields)))

    ; Don't create insn if ifield assertions fail.
    (if (all-true? (map (lambda (op)
			  (anyof-satisfies-assertions? op known-values))
			new-values))

	(let ((sub-insn
	       (make <insn>
		     (obj-location insn)
		     (apply symbol-append
			    (cons (obj:name insn)
				  (map (lambda (anyof)
					 (symbol-append '- (obj:name anyof)))
				       new-values)))
		     (obj:comment insn)
		     (obj-atlist insn)
		     (/anyof-merge-syntax (insn-syntax insn)
					  value-names new-values insn)
		     ifields
		     (insn-ifield-assertion insn) ; FIXME
		     (anyof-merge-semantics (insn-semantics insn)
					    value-names new-values)
		     (insn-timing insn)
		     )))
	  (logit 3 "   instantiated.\n")
	  (current-insn-add! sub-insn)

	  ;; FIXME: Hack to remove differences in generated code when we
	  ;; switched to recording insns in hash tables.
	  ;; See similar comment in arch-analyze-insns!.
	  ;; Make the ordinals count backwards.
	  ;; Subtract 2 because mach.scm:-get-next-ordinal! adds 1.
	  (arch-set-next-ordinal! CURRENT-ARCH
				  (- (arch-next-ordinal CURRENT-ARCH) 2))
	  )

	(begin
	  logit 3 "    failed ifield assertions.\n")))

  *UNSPECIFIED*
)

; Instantiate all sub-insns of MULTI-INSN.
; ??? Might be better to return the list of insns, rather than add them to
; the global list, and leave it to the caller to add them.

(define (multi-insn-instantiate! multi-insn)
  ; We shouldn't get called more than once.
  (assert (not (multi-insn-sub-insns multi-insn)))

  (let ((iflds (insn-iflds multi-insn)))

    ; What we want to create here is the set of all "anyof" alternatives.
    ; From that we create one <insn> per alternative.

    (let* ((anyof-iflds (find ifld-anyof-operand? iflds))
	   (anyof-operands (map ifld-get-value anyof-iflds)))

      (assert (all-true? (map anyof-operand? anyof-operands)))
      (logit 4 "  anyof: " (map obj:name anyof-operands) "\n")
      (logit 4 "    choices: "
	     (map (lambda (l) (map obj:name l))
		  (map anyof-choices anyof-operands))
	     "\n")

      ; Iterate over all combinations.
      ; TODO is a list with one element for each <anyof-operand>.
      ; Each element is in turn a list of all choices (<derived-operands>'s)
      ; for the <anyof-operand>.  Note that some of these values may be
      ; derived from nested <anyof-operand>'s.
      ; ??? anyof-all-choices should cache the results. [Still useful?]
      ; ??? Need to cache results of assertion processing in addition or
      ; instead of anyof-all-choices. [Still useful?]

      (let* ((todo (map anyof-all-choices anyof-operands))
	     (lengths (map length todo))
	     (total (apply * lengths)))

	(logit 2 "Instantiating " total " multi-insns for "
	       (obj:name multi-insn) " ...\n")

	; ??? One might prefer a `do' loop here, but every time I see one I
	; have to spend too long remembering its syntax.
	(let loop ((i 0))
	  (if (< i total)
	      (let* ((indices (split-value lengths i))
		     (anyof-instances (map list-ref todo indices)))
		(logit 4 "Derived: " (map obj:name anyof-instances) "\n")
		(/sub-insn-make! multi-insn anyof-operands anyof-instances)
		(loop (+ i 1))))))))

  *UNSPECIFIED*
)

; Parse an instruction description.
; This is the main routine for building an insn object from a
; description in the .cpu file.
; All arguments are in raw (non-evaluated) form.
; The result is the parsed object or #f if insn isn't for selected mach(s).

(define (/insn-parse context name comment attrs syntax fmt ifield-assertion
		     semantics timing)
  (logit 2 "Processing insn " name " ...\n")

  ;; Pick out name first to augment the error context.
  (let* ((name (parse-name context name))
	 (context (context-append-name context name))
	 (atlist-obj (atlist-parse context attrs "cgen_insn"))
	 (isa-name-list (atlist-attr-value atlist-obj 'ISA #f)))

    ;; Verify all specified ISAs are valid.
    (if (not (all-true? (map current-isa-lookup isa-name-list)))
	(parse-error context "unknown isa in isa list" isa-name-list))

    (if (keep-atlist? atlist-obj #f)

	(let ((ifield-assertion (if (and ifield-assertion
					 (not (null? ifield-assertion)))
				    (rtx-canonicalize context
						      'DFLT ;; BI?
						      isa-name-list nil
						      ifield-assertion)
				    #f))
	      (semantics (if (not (null? semantics))
			     semantics
			     #f))
	      (format (/parse-insn-format
		       (context-append context " format")
		       (and (not (atlist-has-attr? atlist-obj 'VIRTUAL))
			    (reader-verify-iformat? CURRENT-READER))
		       isa-name-list
		       fmt))
	      (comment (parse-comment context comment))
	      ; If there are no semantics, mark this as an alias.
	      ; ??? Not sure this makes sense for multi-insns.
	      (atlist-obj (if semantics
			      atlist-obj
			      (atlist-cons (bool-attr-make 'ALIAS #t)
					   atlist-obj)))
	      (syntax (parse-syntax context syntax))
	      (timing (parse-insn-timing context timing))
	      )

	  (if (anyof-operand-format? format)

	      (make <multi-insn>
		(context-location context)
		name comment atlist-obj
		syntax
		format
		ifield-assertion
		semantics
		timing)

	      (make <insn>
		(context-location context)
		name comment atlist-obj
		syntax
		format
		ifield-assertion
		semantics
		timing)))

	(begin
	  (logit 2 "Ignoring " name ".\n")
	  #f)))
)

; Read an instruction description.
; This is the main routine for analyzing instructions in the .cpu file.
; This is also used to create virtual insns by apps like simulators.
; CONTEXT is a <context> object for error messages.
; ARG-LIST is an associative list of field name and field value.
; /insn-parse is invoked to create the <insn> object.

(define (insn-read context . arg-list)
  (let (
	(name nil)
	(comment "")
	(attrs nil)
	(syntax nil)
	(fmt nil)
	(ifield-assertion nil)
	(semantics nil)
	(timing nil)
	)

    ; Loop over each element in ARG-LIST, recording what's found.
    (let loop ((arg-list arg-list))
      (if (null? arg-list)
	  nil
	  (let ((arg (car arg-list))
		(elm-name (caar arg-list)))
	    (case elm-name
	      ((name) (set! name (cadr arg)))
	      ((comment) (set! comment (cadr arg)))
	      ((attrs) (set! attrs (cdr arg)))
	      ((syntax) (set! syntax (cadr arg)))
	      ((format) (set! fmt (cadr arg)))
	      ((ifield-assertion) (set! ifield-assertion (cadr arg)))
	      ((semantics) (set! semantics (cadr arg)))
	      ((timing) (set! timing (cdr arg)))
	      (else (parse-error context "invalid insn arg" arg)))
	    (loop (cdr arg-list)))))

    ; Now that we've identified the elements, build the object.
    (/insn-parse context name comment attrs syntax fmt ifield-assertion
		 semantics timing))
)

; Define an instruction object, name/value pair list version.

(define define-insn
  (lambda arg-list
    (let ((i (apply insn-read (cons (make-current-context "define-insn")
				    arg-list))))
      (if i
	  (current-insn-add! i))
      i))
)

; Define an instruction object, all arguments specified.

(define (define-full-insn name comment attrs syntax fmt ifield-assertion
	  semantics timing)
  (let ((i (/insn-parse (make-current-context "define-full-insn")
			name comment attrs
			syntax fmt ifield-assertion
			semantics timing)))
    (if i
	(current-insn-add! i))
    i)
)

; Parsing support.

; Parse an insn syntax field.
; SYNTAX is either a string or a list of strings, each element of which may
; in turn be a list of strings.
; ??? Not sure this extra flexibility is worth it yet.

(define (parse-syntax context syntax)
  (cond ((list? syntax)
	 (string-map (lambda (elm) (parse-syntax context elm)) syntax))
	((or (string? syntax) (symbol? syntax))
	 syntax)
	(else (parse-error context "improper syntax" syntax)))
)

; Subroutine of /parse-insn-format to parse a symbol ifield spec.

(define (/parse-insn-format-symbol context isa-name-list sym)
  (let ((op (current-op-lookup sym isa-name-list)))
    (if op
	(cond ((derived-operand? op)
	       ; There is a one-to-one relationship b/w derived operands and
	       ; the associated derived ifield.
	       (let ((ifld (op-ifield op)))
		 (assert (derived-ifield? ifld))
		 ifld))
	      ((anyof-operand? op)
	       (ifld-new-value f-anyof op))
	      (else
	       (let ((ifld (op-ifield op)))
		 (ifld-new-value ifld op))))
	; An insn-enum?
	(let ((e (ienum-lookup-val sym)))
	  (if e
	      (ifld-new-value (ienum:fld (cdr e)) (car e))
	      (parse-error context "bad format element, expecting symbol to be operand or insn enum" sym)))))
)

; Subroutine of /parse-insn-format to parse an (ifield-name value) ifield spec.
;
; The last element is the ifield's value.  It must be an integer.
; ??? Whether it can be negative is still unspecified.
; ??? While there might be a case where allowing floating point values is
; desirable, supporting them would require precise conversion routines.
; They should be rare enough that we instead punt.
;
; ??? May wish to support something like "(% startbit bitsize value)".
;
; ??? Error messages need improvement, but that's generally true of cgen.

(define (/parse-insn-format-ifield-spec context ifld ifld-spec)
  (if (!= (length ifld-spec) 2)
      (parse-error context "bad ifield format, should be (ifield-name value)" ifld-spec))

  (let ((value (cadr ifld-spec)))
    ; ??? This use to allow (ifield-name operand-name).  That's how
    ; `operand-name' elements are handled, but there's no current need
    ; to handle (ifield-name operand-name).
    (cond ((integer? value)
	   (ifld-new-value ifld value))
	  ((symbol? value)
	   (let ((e (enum-lookup-val value)))
	     (if (not e)
		 (parse-error context "symbolic ifield value not an enum" ifld-spec))
	     (ifld-new-value ifld (car e))))
	  (else
	   (parse-error context "ifield value not an integer or enum" ifld-spec))))
)

; Subroutine of /parse-insn-format to parse an
; (ifield-name value) ifield spec.
; ??? There is room for growth in the specification syntax here.
; Possibilities are (ifield-name|operand-name [options] [value]).

(define (/parse-insn-format-list context isa-name-list spec)
  (let ((ifld (current-ifld-lookup (car spec) isa-name-list)))
    (if ifld
	(/parse-insn-format-ifield-spec context ifld spec)
	(parse-error context "unknown ifield" spec)))
)

; Subroutine of /parse-insn-format to simplify it.
; Parse the provided iformat spec and return the list of ifields.
; ISA-NAME-lIST is the ISA attribute of the containing insn.

(define (/parse-insn-iformat-iflds context isa-name-list fld-list)
  (if (null? fld-list)
      nil ; field list unspecified
      (case (car fld-list)
	((+) (map (lambda (fld)
		    (let ((f (if (string? fld)
				 (string->symbol fld)
				 fld)))
		      (cond ((symbol? f)
			     (/parse-insn-format-symbol context isa-name-list f))
			    ((and (list? f)
				  ; ??? This use to allow <ifield> objects
				  ; in the `car' position.  Checked for below.
				  (symbol? (car f)))
			     (/parse-insn-format-list context isa-name-list f))
			    (else
			     (if (and (list? f)
				      (ifield? (car f)))
				 (parse-error context "FIXME: <ifield> object in format spec" f))
			     (parse-error context "bad format element, neither symbol nor ifield spec" f)))))
		  (cdr fld-list)))
	((=) (begin
	       (if (or (!= (length fld-list) 2)
		       (not (symbol? (cadr fld-list))))
		   (parse-error context
				"bad `=' format spec, should be `(= insn-name)'"
				fld-list))
	       (let ((insn (current-insn-lookup (cadr fld-list) isa-name-list)))
		 (if (not insn)
		     (parse-error context "unknown insn" (cadr fld-list)))
		 (insn-iflds insn))))
	(else
	 (parse-error context "format must begin with `+' or `='" fld-list))
	))
)

; Given an insn format field from a .cpu file, replace it with a list of
; ifield objects with the values assigned.
; ISA-NAME-LIST is the ISA attribute of the containing insn.
; If VERIFY? is non-#f, perform various checks on the format.
;
; An insn format field is a list of ifields that make up the instruction.
; All bits must be specified, including reserved bits
; [at present little checking is made of this, but the rule still holds].
;
; A normal entry begins with `+' and then consist of the following:
; - operand name
; - (ifield-name [options] value)
; - (operand-name [options] [value])
; - insn ifield enum
;
; Example: (+ OP1_ADD (f-res2 0) dr src1 (f-src2 1) (f-res1 #xea))
;
; where OP1_ADD is an enum, dr and src1 are operands, and f-src2 and f-res1
; are ifield's.  The `+' allows for future extension.
;
; The other form of entry begins with `=' and is followed by an instruction
; name that has the same format.  The specified instruction must already be
; defined.  Instructions with this form typically also include an
; `ifield-assertion' spec to keep them separate.
;
; An empty field list is ok.  This means it's unspecified.
; VIRTUAL insns have this.
;
; This is one of the more important routines to be efficient.
; It's called for each instruction, and is one of the more expensive routines
; in insn parsing.

(define (/parse-insn-format context verify? isa-name-list ifld-list)
  (let* ((parsed-ifld-list
	  (/parse-insn-iformat-iflds context isa-name-list ifld-list)))

    ;; NOTE: We could sort the fields here, but it introduces differences
    ;; in the generated opcodes files.  Later it might be a good thing to do
    ;; but keeping the output consistent is important right now.
    ;;   (sorted-ifld-list (sort-ifield-list parsed-ifld-list
    ;;                                       (not (current-arch-insn-lsb0?))))
    ;; The rest of the code assumes the list isn't sorted.
    ;; Is there a benefit to removing this assumption?  Note that
    ;; multi-ifields can be discontiguous, so the sorting isn't perfect.

    (if verify?

	;; Just pick the first ISA, the base len for each should be the same.
	;; If not this is caught by compute-insn-base-mask-length.
	(let* ((isa (current-isa-lookup (car isa-name-list)))
	       (base-len (isa-base-insn-bitsize isa))
	       (pretty-print-iflds (lambda (iflds)
				     (if (null? iflds)
					 " none provided"
					 (string-map (lambda (f)
						       (string-append " "
								      (ifld-pretty-print f)))
						     iflds)))))

	  ;; Perform some error checking.
	  ;; Look for overlapping ifields and missing bits.
	  ;; With derived ifields this is really hard, so only do the base insn
	  ;; for now.  Do the simple test for now, it doesn't catch everything,
	  ;; but it should catch a lot.
	  ;; ??? One thing we don't catch yet is overlapping bits.

	  (let* ((base-iflds (find (lambda (f)
				     (not (ifld-beyond-base? f)))
				   (ifields-simple-ifields parsed-ifld-list)))
		 (base-iflds-length (apply + (map ifld-length base-iflds))))

	    ;; FIXME: We don't use parse-error here because some existing ports
	    ;; have problems, and I don't have time to fix them right now.
	    (cond ((< base-iflds-length base-len)
		   (parse-warning context
				  (string-append
				   "insufficient number of bits specified in base insn\n"
				   "ifields:"
				   (pretty-print-iflds parsed-ifld-list)
				   "\nprovided spec")
				  ifld-list))
		  ((> base-iflds-length base-len)
		   (parse-warning context
				  (string-append
				   "too many or duplicated bits specified in base insn\n"
				   "ifields:"
				   (pretty-print-iflds parsed-ifld-list)
				   "\nprovided spec")
				  ifld-list)))

	    ;; Detect duplicate ifields.
	    (if (!= (length base-iflds)
		    (length (obj-list-nub base-iflds)))
		(parse-error-continuable context
					 "duplicate ifields present"
					 ifld-list))
	    )
	  ))

    parsed-ifld-list)
)

; Return a boolean indicating if IFLD-LIST contains anyof operands.

(define (anyof-operand-format? ifld-list)
  (any-true? (map (lambda (f)
		    (or (ifld-anyof? f)
			(derived-ifield? f)))
		  ifld-list))
)

; Insn utilities.
; ??? multi-insn support wip, may require changes here.

; Return a boolean indicating if INSN is an alias insn.

(define (insn-alias? insn)
  (obj-has-attr? insn 'ALIAS)
)

; Return a list of instructions that are not aliases in INSN-LIST.

(define (non-alias-insns insn-list)
  (find (lambda (insn)
	  (not (insn-alias? insn)))
	insn-list)
)

; Return a boolean indicating if INSN is a "real" INSN
; (not ALIAS and not VIRTUAL and not a <multi-insn>).

(define (insn-real? insn)
  (let ((atlist (obj-atlist insn)))
    (and (not (atlist-has-attr? atlist 'ALIAS))
	 (not (atlist-has-attr? atlist 'VIRTUAL))
	 (not (multi-insn? insn))))
)

; Return a list of real instructions in INSN-LIST.

(define (real-insns insn-list)
  (find insn-real? insn-list)
)

; Return a boolean indicating if INSN is a virtual insn.

(define (insn-virtual? insn)
  (obj-has-attr? insn 'VIRTUAL)
)

; Return a list of virtual instructions in INSN-LIST.

(define (virtual-insns insn-list)
  (find insn-virtual? insn-list)
)

; Return a list of non-alias/non-pbb insns in INSN-LIST.

(define (non-alias-pbb-insns insn-list)
  (find (lambda (insn)
	  (let ((atlist (obj-atlist insn)))
	    (and (not (atlist-has-attr? atlist 'ALIAS))
		 (not (atlist-has-attr? atlist 'PBB)))))
	insn-list)
)

; Return a list of multi-insns in INSN-LIST.

(define (multi-insns insn-list)
  (find multi-insn? insn-list)
)

; And the opposite:

(define (non-multi-insns insn-list)
  (find (lambda (insn) (not (multi-insn? insn))) insn-list)
)

; Filter out instructions whose ifield patterns are strict supersets of
; another, keeping the less general cousin.  Used to resolve ambiguity
; when there are no more bits to consider.

(define (filter-non-specialized-ambiguous-insns insn-list)
  (logit 3 "Filtering " (length insn-list) " instructions for non specializations.\n")
  (find (lambda (insn)
	  (let* ((i-mask (insn-base-mask insn))
		 (i-mask-len (insn-base-mask-length insn))
		 (i-value (insn-value insn))
		 (subset-insn (find-first 
			       (lambda (insn2) ; insn2: possible submatch (more mask bits)
				    (let ((i2-mask (insn-base-mask insn2))
					  (i2-mask-len (insn-base-mask-length insn2))
					  (i2-value (insn-value insn2)))
				      (and (not (eq? insn insn2))
					   (= i-mask-len i2-mask-len)
					   (mask-superset? i-mask i-value i2-mask i2-value))))
				  insn-list))
		 (keep? (not subset-insn)))
	    (if (not keep?) 
		(logit 2
		       "Instruction " (obj:name insn) " specialization-filtered by "
		       (obj:name subset-insn) "\n"))
	    keep?))
	insn-list)
)

; Filter out instructions whose ifield patterns are identical.

(define (filter-identical-ambiguous-insns insn-list)
  (logit 3 "Filtering " (length insn-list) " instructions for identical variants.\n")
  (let loop ((l insn-list) (result nil))
    (cond ((null? l) (reverse! result))
	  ((find-identical-insn (car l) (cdr l)) (loop (cdr l) result))
	  (else (loop (cdr l) (cons (car l) result)))
	  )
    )
)

(define (find-identical-insn insn insn-list)
  (let ((i-mask (insn-base-mask insn))
	(i-mask-len (insn-base-mask-length insn))
	(i-value (insn-value insn)))
    (find-first 
     (lambda (insn2)
       (let ((i2-mask (insn-base-mask insn2))
	     (i2-mask-len (insn-base-mask-length insn2))
	     (i2-value (insn-value insn2)))
	 (and (= i-mask-len i2-mask-len)
	      (= i-mask i2-mask)
	      (= i-value i2-value))))
       insn-list))
)

; Helper function for above: does (m1,v1) match a STRICT superset of (m2,v2) ?
;
; eg> mask-superset? #b1100 #b1000 #b1110 #b1010 -> #t
; eg> mask-superset? #b1100 #b1000 #b1010 #b1010 -> #f
; eg> mask-superset? #b1100 #b1000 #b1110 #b1100 -> #f
; eg> mask-superset? #b1100 #b1000 #b1100 #b1000 -> #f

(define (mask-superset? m1 v1 m2 v2)
  (let ((result
	 (and (= (cg-logand m1 m2) m1)
	      (= (cg-logand m1 v1) (cg-logand m1 v2))
	      (not (and (= m1 m2) (= v1 v2))))))
    (if result (logit 4
		      "(" (number->string m1 16) "," (number->string v1 16) ")"
		      " contains "
		      "(" (number->string m2 16) "," (number->string v2 16) ")"
		      "\n"))
    result)
)

;; Return a boolean indicating if INSN is a cti [control transfer insn]
;; according the its attributes.
;;
;; N.B. This only looks at the insn's atlist, which only contains what was
;; specified in the .cpu file.  .cpu files are not required to manually mark
;; CTI insns.  Basically this exists as an escape hatch in case semantic-attrs
;; gets it wrong.

(define (insn-cti-attr? insn)
  (atlist-cti? (obj-atlist insn))
)

;; Return a boolean indicating if INSN is a cti [control transfer insn].
;; This includes SKIP-CTI insns even though they don't terminate a basic block.
;; ??? SKIP-CTI insns are wip, waiting for more examples of how they're used.
;;
;; N.B. This requires the <sformat> of INSN.

(define (insn-cti? insn)
  (or (insn-cti-attr? insn)
      (sfmt-cti? (insn-sfmt insn)))
)

; Return a boolean indicating if INSN can be executed in parallel.
; Such insns are required to have enum attribute PARALLEL != NO.
; This is worded specifically to allow the PARALLEL attribute to have more
; than just NO/YES values (should a target want to do so).
; This specification may not be sufficient, but the intent is explicit.

(define (insn-parallel? insn)
  (let ((atval (obj-attr-value insn 'PARALLEL)))
    (and atval (not (eq? atval 'NO))))
)

; Return a list of the insns that support parallel execution in INSN-LIST.

(define (parallel-insns insn-list)
  (find insn-parallel? insn-list)
)

; Instruction field utilities.

; Return a boolean indicating if INSN has ifield named F-NAME.

(define (insn-has-ifield? insn f-name)
  (->bool (object-assq f-name (insn-iflds insn)))
)

; Insn opcode value utilities.

; Given INSN, return the length in bits of the base mask (insn-base-mask).

(define (insn-base-mask-length insn)
  (ifmt-mask-length (insn-ifmt insn))
)

; Given INSN, return the bitmask of constant values (the opcode field)
; in the base part.

(define (insn-base-mask insn)
  (ifmt-mask (insn-ifmt insn))
)

; Given INSN, return the sum of the constant values in the insn
; (i.e. the opcode field).
;
; See also (compute-insn-base-mask).
;
; FIXME: For non-fixed-length ISAs, using this doesn't feel right.

(define (insn-value insn)
  (if (elm-get insn '/insn-value)
      (elm-get insn '/insn-value)
      (let* ((base-len (insn-base-mask-length insn))
	     (value (apply +
			   (map (lambda (fld) (ifld-value fld base-len (ifld-get-value fld)))
				(find ifld-constant?
				      (ifields-base-ifields (insn-iflds insn))))
			   )))
	(elm-set! insn '/insn-value value)
	value))
)

;; Return the base value of INSN.

(define (insn-base-value insn)
  (if (elm-get insn '/insn-base-value)
      (elm-get insn '/insn-base-value)
      (let* ((base-len (insn-base-mask-length insn))
	     (constant-base-iflds
	      (find (lambda (f)
		      (and (ifld-constant? f)
			   (not (ifld-beyond-base? f))))
		    (ifields-base-ifields (insn-iflds insn))))
	     (base-value (apply +
				(map (lambda (f)
				       (ifld-value f base-len (ifld-get-value f)))
				     constant-base-iflds))))
	(elm-set! insn '/insn-base-value base-value)
	base-value))
)

; Insn operand utilities.

; Lookup operand SEM-NAME in INSN.

(define (insn-lookup-op insn sem-name)
  (or (op:lookup-sem-name (sfmt-in-ops (insn-sfmt insn)) sem-name)
      (op:lookup-sem-name (sfmt-out-ops (insn-sfmt insn)) sem-name))
)

; Insn syntax utilities.

; Create a list of syntax strings broken up into a list of characters and
; operand objects.

(define (syntax-break-out syntax isa-name-list)
  (let ((result nil))
    ; ??? The style of the following could be more Scheme-like.  Later.
    (let loop ()
      (if (> (string-length syntax) 0)
	  (begin
	    (cond 
	     ; Handle escaped syntax metacharacters.
	     ((char=? #\\ (string-ref syntax 0))
	      (begin
		(if (= (string-length syntax) 1)
		    (parse-error context "syntax-break-out: missing char after '\\' in " syntax))
		(set! result (cons (substring syntax 1 2) result))
		(set! syntax (string-drop 2 syntax))))
		; Handle operand reference.
	     ((char=? #\$ (string-ref syntax 0))
	      ; Extract the symbol from the string, get the operand.
	      ; FIXME: Will crash if $ is last char in string.
	      (if (char=? #\{ (string-ref syntax 1))
		  (let ((n (string-index syntax #\})))
		    (set! result (cons (current-op-lookup
					(string->symbol
					 (substring syntax 2 n))
					isa-name-list)
				       result))
		    (set! syntax (string-drop (+ 1 n) syntax)))
		  (let ((n (id-len (string-drop1 syntax))))
		    (set! result (cons (current-op-lookup
					(string->symbol
					 (substring syntax 1 (+ 1 n)))
					isa-name-list)
				       result))
		    (set! syntax (string-drop (+ 1 n) syntax)))))
	     ; Handle everything else.
	     (else (set! result (cons (substring syntax 0 1) result))
		   (set! syntax (string-drop1 syntax))))
	    (loop))))
    (reverse result))
)

; Given a list of syntax elements (e.g. the result of syntax-break-out),
; create a syntax string.

(define (syntax-make elements)
  (apply string-append
	 (map (lambda (e)
		(cond ((char? e)
		       (string "\\" e))
		      ((string? e)
		       e)
		      (else
		       (assert (operand? e))
		       (string-append "${" (obj:str-name e) "}"))))
	      elements))
)

; Called before a .cpu file is read in.

(define (insn-init!)
  (reader-add-command! 'define-insn
		       "\
Define an instruction, name/value pair list version.
"
		       nil 'arg-list define-insn)
  (reader-add-command! 'define-full-insn
		       "\
Define an instruction, all arguments specified.
"
		       nil '(name comment attrs syntax fmt ifield-assertion semantics timing)
		       define-full-insn)

  *UNSPECIFIED*
)

; Called before a .cpu file is read in to install any builtins.

(define (insn-builtin!)
  ; Standard insn attributes.
  ; ??? Some of these can be combined into one.

  (define-attr '(for insn) '(type boolean) '(name UNCOND-CTI) '(comment "unconditional cti"))

  (define-attr '(for insn) '(type boolean) '(name COND-CTI) '(comment "conditional cti"))

  ; SKIP-CTI: one or more immediately following instructions are conditionally
  ; executed (or skipped)
  (define-attr '(for insn) '(type boolean) '(name SKIP-CTI) '(comment "skip cti"))

  ; DELAY-SLOT: insn has one or more delay slots (wip)
  (define-attr '(for insn) '(type boolean) '(name DELAY-SLOT) '(comment "insn has a delay slot"))

  ; RELAXABLE: Insn has one or more identical but larger variants.
  ; The assembler tries this one first and then the relaxation phase
  ; switches to the larger ones as necessary.
  ; All insns of identical behaviour have a RELAX_FOO attribute that groups
  ; them together.
  ; FIXME: This is a case where we need one attribute with several values.
  ; Presently each RELAX_FOO will use up a bit.
  (define-attr '(for insn) '(type boolean) '(name RELAXABLE)
    '(comment "insn is relaxable"))

  ; RELAXED: Large relaxable variant.  Avoided by assembler in first pass.
  (define-attr '(for insn) '(type boolean) '(name RELAXED)
    '(comment "relaxed form of insn"))

  ; NO-DIS: For macro insns, do not use during disassembly.
  (define-attr '(for insn) '(type boolean) '(name NO-DIS) '(comment "don't use for disassembly"))

  ; PBB: Virtual insn used for PBB support.
  (define-attr '(for insn) '(type boolean) '(name PBB) '(comment "virtual insn used for PBB support"))

  ; DECODE-SPLIT: insn resulted from decode-split processing
  (define-attr '(for insn) '(type boolean) '(name DECODE-SPLIT) '(comment "insn split from another insn for decoding purposes") '(attrs META))

  ; Also (defined elsewhere):
  ; VIRTUAL: Helper insn used by the simulator.

  *UNSPECIFIED*
)

; Called after the .cpu file has been read in.

(define (insn-finish!)
  *UNSPECIFIED*
)
@


1.41
log
@	* desc-cpu.scm (/gen-cpu-open): Remove comment on K&R support.
	* utils-cgen.scm (gen-define-with-symcat): Remove K&R support.

	* utils-sim.scm (compute-sformat-argbufs!): Use more consistent name
	for name of empty sbuf.

	* iformat.scm (/sfmt-search-key, /ifmt-lookup-sfmt!): Add assert.

	* insn.scm (<insn>): Add initial value for members fmt-desc, ifmt,
	sfmt, tmp.
	(/sub-insn-ifields): Delete old commented out code.
	(/sub-insn-make!, /parse-insn-format-symbol): Ditto.
	* operand.scm (/anyof-merge-setter, anyof-merge-semantics): Ditto.

	* sim-decode.scm (/gen-decode-insn-globals): Tweak formatting of
	generated code.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2009 Red Hat, Inc.
@


1.40
log
@	* hardware.scm (hw-pc?): New function.
	* ifield.scm (ifld-signed?): New function.
	* iformat.scm (ifmt-analyze): Call insn-cti-attr? instead of insn-cti?.
	* insn.scm (insn-cti-attr?): Renamed from insn-ctl?.
	(insn-cti?): New function.
	* rtl.scm (/hw): Create <pc> object for pcs.
	* semantics.scm (/build-reg-operand!): New args ref-type, sem-attrs.
	All callers updated.  Watch for sets to the pc.
	(semantic-attrs): Watch for sets to the pc.
	* sid.scm (<pc> cxmake-get): Handle raw-reg.
	* sim.scm (<pc> cxmake-get): Handle raw-reg.
	(<operand> cxmake-get): Add debugging printf.
	* utils-gen.scm (/gen-ifld-extract-base): Emit calls to
	EXTRACT_[LM]SB0_LG[SU]INT for values > 32 bits.
	(/gen-extract-word): Ditto.

	* utils.scm (gen-c-hex-constant): New function.
	* utils-sim.scm (/gen-decode-insn-entry): Call it.
@
text
@d35 1
a35 1
		fmt-desc
d38 1
a38 1
		ifmt
d41 1
a41 1
		sfmt
d44 1
a44 1
		tmp
a207 2
  ; (debug-repl-env insn anyof-operands value-names new-values)

a227 1
	   ;(debug-repl-env ifld-list owner)
a239 1
		    ;(debug-repl-env ifld-list owner)
a269 1
  ;(debug-repl-env insn anyof-operands new-values)
a283 4
;  (if (eq? '@@sib+disp8-QI-disp32-8
;	   (obj:name (car new-values)))
;      (debug-repl-env insn anyof-operands new-values))

a538 1
  ;(debug-repl-env sym)
@


1.39
log
@	* insn.scm (/parse-insn-format): Watch for duplicate ifields.
	* read.scm (parse-error-continuable): New function.
	(define /continuable-error-found?): New variable.
	(/init-reader!): Initialize it.
	(/finish-reader!): New function.
	(cpu-load): Call it.
	* utils-cgen.scm (obj-list-nub): New function.
@
text
@d905 17
a921 3
; Return a boolean indicating if INSN is a cti [control transfer insn].
; This includes SKIP-CTI insns even though they don't terminate a basic block.
; ??? SKIP-CTI insns are wip, waiting for more examples of how they're used.
d924 2
a925 1
  (atlist-cti? (obj-atlist insn))
@


1.38
log
@	Specify isa(s) when doing ifield, operand, insn lookups.
	ACU = all callers updated.
	* attr.scm (/attr-eval): Call rtx-value instead of rtx-eval-with-estate.
	* enum.scm (define-full-insn-enum): Pass isa-name-list to
	current-ifld-lookup.
	* html.scm (get-insn-properties): Pass isa-name-list to
	current-op-lookup.
	* ifield.scm (/ifld-parse-follows): New arg isas, ACU.
	* insn.scm (/parse-insn-format-symbol): New arg isa-name-list, ACU.
	(/parse-insn-format-list, /parse-insn-iformat-iflds): Ditto.
	(/parse-insn-format, syntax-break-out): Ditto.
	* mach.scm (obj-filter-by-isa): New function.
	(current-ifld-lookup): New optional arg maybe-isa-name-list.
	(/ifld-already-defined?, /op-already-defined?): Simplify.
	(current-op-lookup): New optional arg maybe-isa-name-list.
	(current-insn-lookup): New arg isa-name-list, ACU.
	(/insn-already-defined?, /minsn-already-defined?): Simplify.
	(current-minsn-lookup): New arg isa-name-list, ACU.
	* minsn.scm (/minsn-compute-iflds): Pass isa-name-list to
	current-op-lookup.
	* opc-itab.scm (compute-syntax): New arg isa-name-list, ACU.
	(gen-syntax-entry): Ditto.
	* operand.scm (/operand-parse): Pass isa-name-list to
	current-ifld-lookup.
	(/derived-parse-encoding): New arg isa-name-list, ACU.
	(/derived-parse-ifield-assertion): Ditto.
	(/derived-operand-parse): Pass isa-name-list to current-op-lookup.
	(/anyof-parse-choice): Ditto.
	(anyof-satisfies-assertions?): Pass context to rtx-solve.
	(/anyof-merge-syntax): New arg container, ACU.
	(operand-builtin!): Add pc to all isas.
	* rtl-c.scm (estate-make-for-rtl-c): Delete arg extra-vars-alist, ACU.
	(estate-make-for-rtl-c++, rtl-c-expr-parsed): Ditto.
	(rtl-c-parsed, rtl-c++-parsed): Ditto.
	(rtl-c): New arg isa-name-list, ACU.
	(rtl-c-expr, rtl-c++): Ditto.
	(closure): New arg isa-name-list, ACU.
	* rtl-traverse.scm (/make-cstate): New arg isa-name-list, ACU.
	(/cstate-isas): New function.
	(/rtx-canon-symbol-list): New function.
	(/rtx-canon-env-stack): Renamed from /rtx-canon-env, ACU.
	updated.
	(/rtx-make-canon-table): Rename ENV to ENVSTACK, new entry SYMBOLLIST.
	(/rtx-canon-rtx-operand): Pass isa list to current-op-lookup.
	(/rtx-canon-rtx-ref, /rtx-canon): Ditto.
	(rtx-canonicalize): New arg isa-name-list, ACU.
	(rtx-canonicalize-stmt): Delete.
	(tstate-make): New arg isas, ACU.
	(tstate-isas, tstate--set-isas!): New functions.
	(tstate-env-stack): Renamed from tstate-env, ACU.
	(tstate-set-env-stack!): Renamed from tstate-set-env!, ACU.
	(tstate-make-closure): Renamed from tstate-new-env, new arg
	isa-name-list, ACU.
	(/rtx-traverse-env): Delete.
	(/rtx-make-traverser-table): Rename ENV to ENVSTACK, new entry
	SUMBOLLIST.
	(/rtx-traverse): Include conditional flag in dump output.
	Update isa,envstack for closures.  Pass isa list to current-op-lookup.
	(<eval-state>): New member isas.  Rename env to env-stack.
	(<eval-state> vmake!): Handle #:isas.  #:env renamed to #:env-stack.
	(<eval-state>): New getter/setter for isas.  Rename env getter/setter
	to env-stack.
	(estate-make-for-eval): Provide #:isas.
	(estate-make-closure): Renamed from estate-new-env.  New arg
	isa-name-list, ACU.
	* rtl-xform.scm (/rtx-simplify-expr-fn): Handle closures.
	(/rtx-trim-args): ENV renamed to ENVSTACK.  Ad ITERATION, SYMBOLLIST.
	(/rtx-trim-for-doc): Handle closures.
	* rtl.scm (/rtx-valid-types): Rename ENV to ENVSTACK.  Add ITERATION,
	SYMBOLLIST.
	(rtx-env-var-list): Delete.
	(rtx-env-make): Handle already-compiled environments.
	(rtx-var-alist-to-env): New function.
	(rtx-var-alist-to-closure-env-stack, rtx-make-env-stack): New functions.
	(rtx-env-stack-dump): Renamed from rtx-env-dump, ACU.
	(rtx-operand-obj): New arg isa-name-list, ACU.
	(rtx-closure-isas, rtx-closure-env-stack, rtx-closure-expr): New
	functions.
	* rtx-funcs.scm (closure): New arg isa-name-list, reorder args, ACU.
	* sem-frags.scm (<sfrag>): Delete member compiled-semantics.
	(/frag-compute-desired-frags): Minor simplification.
	(/frag-pick-best): Ditto.
	* sid-cpu.scm (gen-semantic-code): Require canonical rtl.
	(/gen-sfrag-code): Update.
	* sim-cpu.scm (gen-semantic-code): Require canonical rtl.
	* utils-cgen.scm (sanitize): New arg isa-name-list, ACU.
	* utils.scm (non-null-intersection?): New function.
@
text
@d659 1
a659 1
; [at present no checking is made of this, but the rule still holds].
d722 1
d741 7
@


1.37
log
@whitespace cleanup
@
text
@d313 1
a313 1
					  value-names new-values)
d404 5
a408 1
	 (isas (atlist-attr-value atlist-obj 'ISA #f)))
d414 4
a417 2
				    (rtx-canonicalize context 'DFLT ;; BI?
						      ifield-assertion nil)
d426 1
a426 5
		       ;; Just pick the first, the base len
		       ;; for each should be the same.
		       ;; If not this is caught by
		       ;; compute-insn-base-mask-length.
		       (current-isa-lookup (car isas))
d547 1
a547 1
(define (/parse-insn-format-symbol context sym)
d549 1
a549 1
  (let ((op (current-op-lookup sym)))
d605 2
a606 2
(define (/parse-insn-format-list context spec)
  (let ((ifld (current-ifld-lookup (car spec))))
d614 1
d616 1
a616 1
(define (/parse-insn-iformat-iflds context fld-list)
d625 1
a625 1
			     (/parse-insn-format-symbol context f))
d630 1
a630 1
			     (/parse-insn-format-list context f))
d643 1
a643 1
	       (let ((insn (current-insn-lookup (cadr fld-list))))
d654 2
a655 3
; ISA is an <isa> object or #f.
; If VERIFY? is non-#f, perform various checks on the format
; (ISA must be an <isa> object).
d684 3
a686 2
(define (/parse-insn-format context verify? isa ifld-list)
  (let* ((parsed-ifld-list (/parse-insn-iformat-iflds context ifld-list)))
d699 11
a709 8
	(let ((base-len (isa-base-insn-bitsize isa))
	      (pretty-print-iflds (lambda (iflds)
				    (if (null? iflds)
					" none provided"
					(string-map (lambda (f)
						      (string-append " "
								     (ifld-pretty-print f)))
						    iflds)))))
d998 1
a998 1
(define (syntax-break-out syntax)
d1020 2
a1021 1
					 (substring syntax 2 n)))
d1027 2
a1028 1
					 (substring syntax 1 (+ 1 n))))
@


1.36
log
@	Record bitset attributes internally as a list.
	Record rtx attribute values internally as ((rtx-expr)).
	* attr.scm (bitset-attr?): Delete, unused.
	(<bitset-attribute> parse-value): Rewrite.
	(/attr-parse): Rewrite bitset default value processing.
	(/attr-read): Pick out values of scalar attributes to distinguish
	them from bitset values which are a list.
	Fix spelling errors for processing of default values.
	Handle string attributes.
	(bitset-attr->list): Delete, all callers updated.
	(/bitset-attr->charmask): Renamed from bitset-attr->charmask.
	All callers updated.
	(atlist-source-form): Rewrite.
	* hardware.scm (<hardware-base> 'get-isas): Update recognition
	of all isas.
	(hardware-builtin!): Update spec of ISA attribute, (ISA foo,bar)
	-> (ISA foo bar).
	* intrinsics.scm (target:belongs-to-group?): Update, bitset attribute
	values are now lists.
	* mach.scm (def-isa-attr!): Update, bitset attribute values,
	including the default, are now lists.
	(all-isas-attr-value): Result is now a list.
	* doc/rtl.texi: Clean up pass over attribute docs.
@
text
@d877 1
a877 1
; 
a890 3



@


1.35
log
@	* xc16x.cpu (h-cr): New hardware.
	(muls): Comment out parts that won't compile, add fixme.
	(mulu, divl, divlu, jmpabs, jmpa-, jmprel, jbc, jnbs, callr): Ditto.
	(scxti, scxtmg, scxtm, bclear, bclr18, bset19, bitset, bmov): Ditto.
	(bmovn, band, bor, bxor, bcmp, bfldl, bfldh): Ditto.

	Rewrite rtl processing to require it to be "canonicalized" first,
	and write a full canonicalizer / expression checker.
	Remove all appearances of DFLT in canonical rtl.
	* attr.scm (/attr-eval atval owner): Call rtx-canonicalize,
	then rtx-simplify.
	* iformat.scm (ifmt-analyze) Use canonical semantics.
	* insn (<insn>): New member canonical-semantics.
	* mach.scm (<arch>): New member multi-insns-instantiated?.
	(/instantiate-multi-insns!): New function.
	(/canonicalize-insns!): New function.
	(arch-analyze-insns!): Canonicalize insn semantics before processing
	them.
	* mode.scm (/mode-set-word-params!): New function.
	(mode-void?): New function.
	(mode-compatible?): VOID is compatible with VOID.
	(/mode-word-sizes-defined?): New global.
	(mode-set-word-modes!): Use/set it.
	(mode-ensure-word-sizes-defined): Update.
	(mode-builtin!): New builtin "modes" SYM, INSN, MACH.
	Redo WI/UWI/AI/IAI handling.
	(op:new-mode): No longer accept DFLT.
	(<derived-operand> constructor): Ensure all fields are initialized.
	(<anyof-operand> constructor): Ditto.
	(/derived-parse-ifield-assertion): Delete arg `args'.
	All callers updated.
	* rtl-c.scm (<rtl-c-eval-state>): New member `for-insn?'.
	(rtl-c): Call rtx-canonicalize instead of rtx-compile.
	(rtl-c-expr, rtl-c++): Ditto.
	(/rtl-c-get): Use mode of operand, not containing expression.
	(rtl-c-set-quiet, rtl-c-set-trace): Remove DFLT support.
	(/rtx-use-sem-fn?): Don't check for (insn? owner), check
	estate-for-insn? instead.
	(s-unop): Use mode of expression, not first operand.
	(s-binop, s-binop-with-bit, s-shop, s-cmpop): Ditto.
	(s-sequence): Remove DFLT support.
	(ifield): Use mode of expression, not UINT.
	(pc): Comment out, unused.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	(set, set-quiet): Pass src to rtl-c-set-{trace,quiet} for expansion.
	* rtl-traverse.scm (/rtx-canon-debug?): New global.
	(/make-cstate): New function.
	(/cstate-context, /cstate-outer-expr): New functions.
	(/rtx-canon-error): New function.
	(/rtx-lookup-hw, /rtx-pick-mode, /rtx-pick-mode3, /rtx-pick-op-mode,
	/rtx-get-last-cond-case-rtx): New functions.
	(/rtx-canon-*): New functions.
	(/rtx-canner-table, /rtx-operand-canoners): New globals.
	(/rtx-make-canon-table, /rtx-special-expr-canoners): New functions.
	(/rtx-option, /rtx-option-list?): Rewrite.
	(rtx-munge-mode&options): Replaces /rtx-munge-mode&options.
	Rewritten, all callers updated.
	(/rtx-canon-expr, /rtx-canon): New functions.
	(rtx-canonicalize): Move here from rtl-xform.scm and rewrite.
	(rtx-canonicalize-stmt): New function.
	(tstate-make): Remove arg `set?'.  All callers updated.
	(tstate-new-set?): Delete.
	(/rtx-traverse-options, /rtx-traverse-*mode): Delete,
	moved to /rtx-canon-*.
	(/rtx-traverse-normal-operand): New function.
	(/rtx-traverse-rtx-list): Delete arg `mode', all callers updated.
	(/rtx-traverse-rtx, /rtx-traverse-setrtx,, /rtx-traverse-testrtx,
	/rtx-traverse-condrtx, /rtx-traverse-casertx, /rtx-traverse-locals,
	/rtx-traverse-iteration, /rtx-traverse-env, /rtx-traverse-attrs):
	Ditto.
	(/rtx-traverse-symbol, /rtx-traverse-string, /rtx-traverse-number,
	/rtx-traverse-symornum, /rtx-traverse-object): Delete.
	(/rtx-make-traverser-table): Update.
	(/rtx-traverse-operands): Remove mode processing, now done during
	canonicalization.
	(/rtx-traverse-expr): Delete arg `mode', all callers updated.
	(/rtx-traverse): Ditto.
	(rtx-init-traverser-tables!): New function.
	* rtl-xform (/rtx-verify-no-dflt-modes-expr-fn): New function.
	(rtx-verify-no-dflt-modes): New function.
	(/rtx-simplify-expr-fn): Update, `arg' mode deleted.
	(rtx-simplify-insn): Use insn-canonical-semantics.
	(rtx-canonicalize): Moved to rtl-traverse.scm.
	(/compile-expr-fn, rtx-compile): Delete.
	(/rtx-trim-rtx-list): New function.
	(/rtx-trim-for-doc): Handle set, if.
	* rtl.scm (<rtx-func>): New members result-mode, matchexpr-index.
	(/rtx-valid-mode-types): Update.
	(/rtx-valid-matches): Update.
	(/rtx-find-matchexpr-index): New function.
	(rtx-lookup): Require rtx-kind to be the rtx name.
	(def-rtx-node): New arg result-mode, all callers updated.
	(def-rtx-syntax-node, def-rtx-operand-node): Ditto.
	(rtx-lazy-sem-mode): Delete.
	(/rtx-closure-make): New arg `mode', all callers updated.
	(rtx-make-ifield, rtx-make-operand, rtx-make-local): Ditto.
	(rtx-operand-obj): Rewrite.
	(rtx-make-xop): New functions.
	(/hw): Renamed from `hw', all callers updated.
	Use the correct mode instead of DFLT for the index.
	(rtl-builtin!): Call rtx-init-traversal-tables!.
	(rtl-finish!): Update.
	* rtx-funcs.scm (all rtx functions): New parameter: result-mode.
	Update mode arg-type.
	(pc): Comment out.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	* sem-frags.scm (/frag-hash-compute!): Update, mode arg deleted.
	(/frag-cost-compute!): Ditto.
	* semantics.scm (/build-operand!): Delete args op-name, op.
	New arg op-expr.  All callers updated.
	(/build-mem-operand!): Remove DFLT support.
	(semantic-compile): Update process-expr!, mode arg deleted.
	* sid-cpu.scm (gen-semantic-code): Specify #:for-insn? in
	rtl-c++ calls.
	(/gen-sem-case, /gen-sfrag-code): Ditto.
	* sid.scm (/op-gen-set-trace1): Renamed from /op-gen-set-trace.
	(/op-gen-set-trace): New function.  If not doing profiling,
	call /op-gen-set-quiet.
	* sim-cpu.scm (gen-semantic-code): Specify #:for-insn? in rtl-c calls.
	* utils-gen.scm (/gen-ifld-extract-base): Update call to rtl-c.
	(/gen-ifld-extract-beyond, gen-multi-ifld-extract): Ditto.
	* utils.scm (find-first-index): New function.
	* doc/rtl.texi: Delete docs for `attr'.  Add `int-attr'.
@
text
@d404 1
a404 1
	 (isas (bitset-attr->list (atlist-attr-value atlist-obj 'ISA #f))))
@


1.34
log
@* insn.scm (/parse-insn-format): Improve error message for missing or
too many bits.
@
text
@d47 2
a48 1
		; This is the rtl in source form or #f if there is none.
d66 5
a70 1
		(semantics . #f)
d72 1
a72 1
		; The processed form of the above.
d81 1
a81 1
		host-semantics
d98 1
a98 1
	  semantics compiled-semantics host-semantics timing)
d102 2
a103 1
  (fmt-desc ifmt sfmt tmp ifield-assertion compiled-semantics)
d410 2
a411 1
				    (rtx-canonicalize context ifield-assertion)
d710 1
@


1.33
log
@	* insn.scm (/parse-insn-format): New arg `verify?', all callers updated.
	(/insn-parse): Don't verify iformat for virtual insns.

	* sid-decode.scm (cgen-decode.cxx): Remove redundant call to
	non-multi-insns.
	* sid-model.scm (/gen-model-insn-fn-decls): Ditto.
	(/gen-model-insn-fns, /gen-model-class-decls): Ditto.
	* sid.scm (pbb-engine-insns): Ditto.
	* sim-decode.scm (cgen-decode.c): Ditto.
@
text
@d689 8
a696 1
	(let ((base-len (isa-base-insn-bitsize isa)))
d712 5
a716 1
				  "insufficient number of bits specified in base insn"
d720 5
a724 1
				  "too many or duplicated bits specified in base insn"
@


1.32
log
@	* insn.scm (/insn-parse): Canonicalize the ifield-assertion before
	saving.
@
text
@d409 10
a418 7
	      (format (/parse-insn-format (context-append context " format")
					  ;; Just pick the first, the base len
					  ;; for each should be the same.
					  ;; If not this is caught by
					  ;; compute-insn-base-mask-length.
					  (current-isa-lookup (car isas))
					  fmt))
d644 3
a646 2
; If ISA is non-#f, it is an <isa> object, and we perform various checks
; on the format (which require an isa).
d675 1
a675 1
(define (/parse-insn-format context isa ifld-list)
d687 2
a688 2
    (if (and isa
	     (reader-verify-iformat? CURRENT-READER))
@


1.31
log
@(/parse-insn-format): Tweak error message.
@
text
@d402 3
a404 2
	(let ((ifield-assertion (if (not (null? ifield-assertion))
				    ifield-assertion
@


1.30
log
@	Add support for controlling warnings/errors.
	Add tests for iformat description errors.
	* dev.scm (cload): New option #:diag.
	* read.scm (<reader>): New member verify-iformat?.
	(/parse-diagnostic, parse-warning): New functions.
	(parse-error): Guts moved to /parse-diagnostic.
	(/set-diagnostic-options!): New function.
	(cpu-load): New arg diagnostic-options, all callers updated.
	Recognize -w diagnostic-option-list.
	* ifield.scm (ifields-base-ifields): Move here from iformat.scm.
	(ifld-simple-ifields, ifields-simple-ifields): New function.
	* insn.scm (/parse-insn-format-iflds): New function.
	(/parse-insn-format): Guts moved to /parse-insn-format-iflds.
	New arg isa, all callers updated.  Do some basic validation of the
	ifield list if requested.
	* mach.scm (/sanity-check-insns): Improve error message text.
	* doc/running.text: Document -w option.

	* ifield.scm (/multi-ifield-parse): Initialize bitrange.
@
text
@d704 1
a704 1
				  "too many bits specified in base insn"
@


1.29
log
@	* ifield.scm (ifld-beyond-base?): Remove args base-bitsize,
	total-bitsize.  All callers updated.
	* insn.scm (<insn>): Rename member ifld-values to /insn-value.
	New member /insn-base-value.
	(insn-base-value): New function.
	* mach.scm (/sanity-check-insns): New function.
	(arch-analyze-insns!): Call it.
@
text
@d397 2
a398 1
	 (atlist-obj (atlist-parse context attrs "cgen_insn")))
d409 5
d599 2
a600 29
; Given an insn format field from a .cpu file, replace it with a list of
; ifield objects with the values assigned.
;
; An insn format field is a list of ifields that make up the instruction.
; All bits must be specified, including reserved bits
; [at present no checking is made of this, but the rule still holds].
;
; A normal entry begins with `+' and then consist of the following:
; - operand name
; - (ifield-name [options] value)
; - (operand-name [options] [value])
; - insn ifield enum
;
; Example: (+ OP1_ADD (f-res2 0) dr src1 (f-src2 1) (f-res1 #xea))
;
; where OP1_ADD is an enum, dr and src1 are operands, and f-src2 and f-res1
; are ifield's.  The `+' allows for future extension.
;
; The other form of entry begins with `=' and is followed by an instruction
; name that has the same format.  The specified instruction must already be
; defined.  Instructions with this form typically also include an
; `ifield-assertion' spec to keep them separate.
;
; An empty field list is ok.  This means it's unspecified.
; VIRTUAL insns have this.
;
; This is one of the more important routines to be efficient.
; It's called for each instruction, and is one of the more expensive routines
; in insn parsing.
d602 1
a602 1
(define (/parse-insn-format context fld-list)
d638 74
@


1.28
log
@	* iformat.scm (ifields-base-ifields): Simplify.
	(compute-insn-length): Simplify, call ifields-base-ifields.
	(compute-insn-base-mask): Ditto.
	* ifield.scm (ifld-known-values): Ditto.
	(ifld-base-ifields): Ditto.
	* insn.scm (insn-value): Ditto.
	* pgmr-tools.scm (pgmr-pretty-print-insn-format): Ditto.
@
text
@d22 2
a23 1
		(iflds-values . #f) ; Lazily computed cache
d865 2
d869 2
a870 2
  (if (elm-get insn 'iflds-values)
      (elm-get insn 'iflds-values)
d877 1
a877 1
	(elm-set! insn 'iflds-values value)
d880 19
@


1.27
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d864 1
a864 1
;
d872 1
a872 1
				      (collect ifld-base-ifields (insn-iflds insn))))
d875 2
a876 3
	value)
      )
  )
@


1.26
log
@	* ifield.scm (<ifield> constructor): New arg `location',
	all callers updated.
	* insn.scm (<insn> constructor): Ditto.
	(<multi-insn> constructor): Ditto.
	* minsn.scm (<macro-insn> constructor): Ditto.
	* operand.scm (<operand> constructor): Ditto.
	* utils-cgen.scm (builtin-location): New function.
	(<source-ident>): Fix default value of member `location'.
	(source-ident?): New function.
@
text
@d195 1
a195 1
; Subroutine of -sub-insn-make! to create the ifield list.
d200 1
a200 1
(define (-sub-insn-ifields insn anyof-operands value-names new-values)
d266 1
a266 1
(define (-sub-insn-make! insn anyof-operands new-values)
d287 1
a287 1
	 (ifields (-sub-insn-ifields insn anyof-operands value-names new-values))
d305 1
a305 1
		     (-anyof-merge-syntax (insn-syntax insn)
d377 1
a377 1
		(-sub-insn-make! multi-insn anyof-operands anyof-instances)
d389 1
a389 1
(define (-insn-parse context name comment attrs syntax fmt ifield-assertion
d406 1
a406 1
	      (format (-parse-insn-format (context-append context " format")
d449 1
a449 1
; -insn-parse is invoked to create the <insn> object.
d482 1
a482 1
    (-insn-parse context name comment attrs syntax fmt ifield-assertion
d501 1
a501 1
  (let ((i (-insn-parse (make-current-context "define-full-insn")
d525 1
a525 1
; Subroutine of -parse-insn-format to parse a symbol ifield spec.
d527 1
a527 1
(define (-parse-insn-format-symbol context sym)
d549 1
a549 1
; Subroutine of -parse-insn-format to parse an (ifield-name value) ifield spec.
d561 1
a561 1
(define (-parse-insn-format-ifield-spec context ifld ifld-spec)
d580 1
a580 1
; Subroutine of -parse-insn-format to parse an
d585 1
a585 1
(define (-parse-insn-format-list context spec)
d588 1
a588 1
	(-parse-insn-format-ifield-spec context ifld spec)
d622 1
a622 1
(define (-parse-insn-format context fld-list)
d631 1
a631 1
			     (-parse-insn-format-symbol context f))
d636 1
a636 1
			     (-parse-insn-format-list context f))
@


1.25
log
@add some fixmes
@
text
@d84 2
a85 2
		   '(name comment attrs syntax iflds ifield-assertion
			  semantics timing)
d185 2
a186 2
		   '(name comment attrs syntax iflds ifield-assertion
			  semantics timing)
d297 1
d422 1
d431 1
@


1.24
log
@	* pmacros.scm (-pmacro-builtin-internal-test): New function.
	(pmacros-init!): Add .internal-test.
	* testsuite/test-utils.sh.in (post_process): Tweak FAIL output.
	* testsuite/testsuite.cpu (internal-verify): New pmacro.
	* doc/pmacros.text: Document .internal-test.

	* utils-cgen.scm (parse-name): Handle (add 3) -> add3.
	(parse-comment): Allow numbers.
	* doc/porting.texi: Document that names and comments may be lists.

	* insn.scm (-insn-parse): Fix typo.
@
text
@d126 1
d897 1
a897 1
	     ; Handle escaped syntax metacharacters 
d904 1
a904 1
		; Handle operand reference
d907 1
d921 1
a921 1
	     ; Handle everything else
@


1.23
log
@	Clean up cpu file parsing, pass context consistently instead of the
	old "errtxt" argument.
	NOTE: ACU == "All Callers Updated".
	* attr.scm (-parse-simple-attribute): Renamed from
	parse-simple-attribute, ACU.
	(-attr-parse): Change errtxt argument to context, ACU.
	(-attr-read): Ditto.
	(atlist-parse): Ditto.  Put context arg first.
	(attr-parse): Use parse-error instead of context-error.
	* enum.scm (parse-enum-vals): Change errtxt argument to context, ACU.
	(-enum-parse-prefix, -enum-parse, -enum-read): Ditto.
	* hardware.scm (-keyword-parse): Renamed from keyword-parse.
	`context' arg is now a <context> object.  ACU.
	(-keyword-read): `context' arg is now a <context> object.  ACU.
	(-hw-parse-indices): Change errtxt argument to context, ACU.
	(-hw-parse-values, -hw-parse-handlers): Ditto.
	(-hw-parse-getter, -hw-parse-setter, -hw-parse, -hw-read): Ditto.
	(-hw-validate-layout, -hw-create-getter-from-layout,
	-hw-create-setter-from-layout): Ditto.
	(<hw-register>:parse!, <hw-pc>:parse!): Ditto.
	(<hw-memory>:parse!, <hw-immediate>:parse!): Ditto.
	(<hw-address>:parse!): Ditto.
	* ifield.scm (-ifield-parse, ifield-read): Ditto.
	(-ifld-parse-follows, -ifld-parse-encode-decode): Ditto.
	(-ifld-parse-encode, -ifld-parse-decode): Ditto.
	(-multi-ifield-parse, -multi-ifield-read): Ditto.
	* insn.scm (-insn-parse, -insn-read): Ditto.
	(parse-syntax): Ditto.  Put context arg first.
	(-parse-insn-format-symbol): Change errtxt argument to context, ACU.
	(-parse-insn-format-ifield-spec, -parse-insn-format-list): Ditto.
	(-parse-insn-format): Ditto.
	* mach.scm (-arch-parse-alignment, -arch-parse-machs): Ditto.
	(-arch-parse-isas): Ditto.
	(-isa-read): Add context arg, ACU.
	(-cpu-parse, -cpu-read, -mach-read): Ditto.
	* minsn.scm (-minsn-parse-expansion): Change errtxt argument to
	context, ACU.
	(-minsn-parse, -minsn-read, -minsn-compute-iflds): Ditto.
	(minsn-make-alias): Ditto.
	* mode.scm (-mode-parse): Ditto.
	(parse-mode-name): Ditto.  Put context arg first.
	* model.scm (-prefetch-parse, -retire-parse, -pipeline-parse): Change
	errtxt argument to context, ACU.
	(-unit-parse, -model-parse, -model-read): Ditto.
	* operand.scm (-operand-parse-getter): Use parse-error instead of
	context-error.
	(-operand-parse-setter): Ditto.
	(-operand-parse): Change errtxt argument to context, ACU.
	(-operand-read, -derived-operand-parse, -derived-operand-read): Ditto.
	(-anyof-operand-parse, -anyof-operand-read): Ditto.
	* read.scm (reader-error): Delete.  Use parse-error instead.
	(parse-error): Change errtxt argument to context, ACU.  Split args
	argument into expr and maybe-help-text.
	(-reader-process-expanded-1!): Reorganize.
	* rtl.scm (-subr-read): Change errtxt argument to context, ACU.
	* types.scm (parse-type): Ditto.
	* utils-cgen.scm (single-location->simple-string): New function.
	(<context>): Replace members file,lineno with location.
	(make-prefix-context): Renamed from context-make-prefix, ACU.
	(make-current-context): New function.
	(context-append, context-append-name): New functions.
	(context-make-reader): Delete.
	(parse-name): Change errtxt argument to context, ACU.
	Put context arg first.
	(parse-comment): Ditto.
	(parse-number): Change errtxt argument to context, ACU.
	(arg-list-validate-name, arg-list-check-no-args,
	arg-list-symbol-arg): Ditto.

	* read.scm (-cmd-if): Don't assume test is a list.

	* html.scm (get-insn-properties): Delete errtxt, unused.
@
text
@d392 3
a394 3
  (let ((name (parse-name context name))
	(context (context-append-name context name))
	(atlist-obj (atlist-parse context attrs "cgen_insn")))
@


1.22
log
@	Track source location better, for better error messages.
	* pmacros.scm (-pmacro-eval): Delete, unused.
	(pmacro-expand, -pmacro-expand): New arg `loc', all callers updated.
	(-pmacro-expand-expr-list, -smacro-apply): Ditto.
	(scan-list, scan): Ditto.
	(-pmacro-builtin-pmacro, -pmacro-builtin-let, -pmacro-builtin-if,
	-pmacro-builtin-case, -pmacro-builtin-cond, -pmacro-builtin-begin,
	-pmacro-builtin-andif, -pmacro-builtin-orif): Ditto.
	(scan-list1): New function.
	(-pmacro-build-lambda): New arg `loc', all callers updated.  Rewrite.
	* read.scm (<reader>): New member `location'.
	(-reader-lookup-command): Renamed from reader-lookup-command,
	all callers updated.
	(reader-error): Rewrite to produce better source location info.
	(current-reader-location): New function.
	(-reader-process-expanded-1!): Renamed from -reader-process-expanded-1.
	All callers updated.  Record source location of expression.
	(reader-process-expanded!): Renamed from reader-process-expanded.
	All callers updated.
	(-reader-process!): Renamed from reader-process.  New arg `loc'.
	All callers updated.  Record source location of define-pmacro.
	* utils-cgen.scm (<location>): New class.
	(single-location): New (pseudo) class.
	(pretty-print-single-location, pretty-print-location): New functions.
	(location-top, location-push-single, location-push): New functions.
	(unspecified-location, current-input-location): New functions.
	(location-property): New object property.
	(location-property-set!): New function.
	(<source-ident>): Renamed from <ordered-ident>.  New member `location'.
	All uses updated.
	* testsuite/location-1.test: New testcase.
	* testsuite/run-tests.sh: Fix fail count handling.
	* testsuite/test-utils.sh.in (run_cgen): New option `-f'.  Allow tests
	to expect cgen to fail.

	* pmacros.scm (*): Use "pmacro" instead of "macro" more consistently.

	* read.scm (-cmd-include): Renamed from include.  All callers updated.
	(-cmd-if): Renamed from cmd-if.  All callers updated.
	Use reader-process-expanded! on then/else clauses instead of eval1.
@
text
@d387 1
a387 1
(define (-insn-parse errtxt name comment attrs syntax fmt ifield-assertion
d391 4
a394 2
  (let ((name (parse-name name errtxt))
	(atlist-obj (atlist-parse attrs "cgen_insn" errtxt)))
d404 1
a404 1
	      (format (-parse-insn-format (string-append errtxt " format")
d406 1
a406 1
	      (comment (parse-comment comment errtxt))
d413 2
a414 2
	      (syntax (parse-syntax syntax errtxt))
	      (timing (parse-insn-timing errtxt timing))
d443 1
a443 1
; ERRTXT is prepended to error messages to provide context.
d447 3
a449 2
(define (insn-read errtxt . arg-list)
  (let ((name nil)
d458 1
d474 1
a474 1
	      (else (parse-error errtxt "invalid insn arg" arg)))
d476 1
d478 2
a479 3
    (-insn-parse errtxt name comment attrs syntax fmt ifield-assertion
		 semantics timing)
    )
d486 2
a487 1
    (let ((i (apply insn-read (cons "define-insn" arg-list))))
d497 2
a498 1
  (let ((i (-insn-parse "define-full-insn" name comment attrs
d513 1
a513 1
(define (parse-syntax syntax errtxt)
d515 1
a515 1
	 (string-map (lambda (elm) (parse-syntax elm errtxt)) syntax))
d518 1
a518 1
	(else (parse-error errtxt "improper syntax" syntax)))
d523 1
a523 1
(define (-parse-insn-format-symbol errtxt sym)
d542 1
a542 1
	      (parse-error errtxt "bad format element, expecting symbol to be operand or insn enum" sym)))))
d557 1
a557 1
(define (-parse-insn-format-ifield-spec errtxt ifld ifld-spec)
d559 1
a559 1
      (parse-error errtxt "bad ifield format, should be (ifield-name value)" ifld-spec))
d570 1
a570 1
		 (parse-error errtxt "symbolic ifield value not an enum" ifld-spec))
d573 1
a573 1
	   (parse-error errtxt "ifield value not an integer or enum" ifld-spec))))
d581 1
a581 1
(define (-parse-insn-format-list errtxt spec)
d584 2
a585 2
	(-parse-insn-format-ifield-spec errtxt ifld spec)
	(parse-error errtxt "unknown ifield" spec)))
d618 1
a618 1
(define (-parse-insn-format errtxt fld-list)
d627 1
a627 1
			     (-parse-insn-format-symbol errtxt f))
d632 1
a632 1
			     (-parse-insn-format-list errtxt f))
d636 2
a637 2
				 (parse-error errtxt "FIXME: <ifield> object in format spec"))
			     (parse-error errtxt "bad format element, neither symbol nor ifield spec" f)))))
d642 1
a642 1
		   (parse-error errtxt
d647 1
a647 1
		     (parse-error errtxt "unknown insn" (cadr fld-list)))
d650 1
a650 1
	 (parse-error errtxt "format must begin with `+' or `='" fld-list))
@


1.21
log
@	* insn.scm (multi-insn-instantiate!): Use logging messages instead of
	commented out printfs.
	* rtl.scm (rtl-finish!): Whitespace tweaks.
@
text
@d10 1
a10 1
	      '(<ordered-ident>)
d440 1
d954 1
a954 1
; Called before a . cpu file is read in to install any builtins.
@


1.20
log
@	Use hash tables to record ifields, operands, insns, macro-insns.
	* attr.scm (attr-builtin!): Tweak some comments.
	* hardware.scm (hardware-builtin!): Call all-isas-attr-value.
	* ifield.scm (<ifield>): Subclass from <ordered-ident> instead of
	<ident>.
	(<multi-ifield>): New constructor.
	(ifield-builtin!): Add isa attr to f-nil, f-anyof.
	* insn.scm (<insn>): Subclass from <ordered-ident> instead of
	<ident>.
	(-sub-insn-make!): Add hack to avoid differences in generated code.
	(multi-insn-instantiate!): Add total number of multi-insns to
	logging message.
	* mach.scm (<arch>): Rename members ifld-list, op-list, insn-list,
	minsn-list to foo-table.  New member next-ordinal.
	Update getters/setters.
	(arch-ifld-list, arch-op-list, arch-insn-list, arch-minsn-list):
	New functions.
	(-get-next-ordinal!, -get-lowest-ordinal): New function.
	(-make-ident-object-table, -ident-object-table->list,
	-ident-object-table-add!, -ident-object-table-lookup): New functions.
	(current-ifld-list, current-ifld-add! current-ifld-lookup,
	-ifld-already-defined?): Rewrite.
	(current-op-list, current-op-add! current-op-lookup,
	-op-already-defined?): Rewrite.
	(current-raw-insn-list, insn-list-car, insn-list-splice!): Delete.
	(current-insn-list, current-insn-add! current-insn-lookup,
	-insn-already-defined?): Rewrite.
	(current-minsn-list, current-minsn-add! current-minsn-lookup,
	-minsn-already-defined?): Rewrite.
	(all-isas-attr-value, all-isas-attr, attr-isa-list): New functions.
	(MAX-VIRTUAL-INSNS): Define.
	(arch-analyze-insns!): Add hack to avoid differences in generated code.
	Update use of arch-insn-list.
	(mach-init!): Initialize ifld-table, op-table, insn-table, minsn-table.
	(arch-finish!): Delete references to ifld-table, op-table, insn-table,
	minsn-table.
	* minsn.scm (<macro-insn>): Subclass from <ordered-ident> instead of
	<ident>.  New constructor.
	* operand.scm (<operand>): Subclass from <ordered-ident> instead of
	<ident>.
	* sid.scm (-virtual-insn-add!): New function.
	(-create-virtual-insns!): Call it.
	(-fill-sim-insn-list!): Rewrite.
	* sim.scm (-virtual-insn-add!, -create-virtual-insns!): New functions.
	(sim-finish!): Move contents to -create-virtual-insns!, and call it.
	* utils-cgen.scm (<ordered-ident>): New class.
	(obj-ordinal, obj-set-ordinal!): New functions.
	(add-ident-methods!): Delete.

	* model.scm (parse-insn-timing): Change logging message to level 3.
@
text
@d342 2
a343 1
    (let ((anyof-iflds (find ifld-anyof-operand? iflds)))
d345 6
a350 5
      (assert (all-true? (map anyof-operand? (map ifld-get-value anyof-iflds))))
      ;(display (obj:name multi-insn) (current-error-port))
      ;(display " anyof: " (current-error-port))
      ;(display (map obj:name (map ifld-get-value anyof-iflds)) (current-error-port))
      ;(newline (current-error-port))
d357 1
a357 1
      ; ??? anyof-all-choices should cache the results.
d359 1
a359 1
      ; instead of anyof-all-choices.
d361 1
a361 2
      (let* ((anyof-operands (map ifld-get-value anyof-iflds))
	     (todo (map anyof-all-choices anyof-operands))
d374 1
a374 3
		;(display "derived: " (current-error-port))
		;(display (map obj:name anyof-instances) (current-error-port))
		;(newline (current-error-port))
@


1.19
log
@	* insn.scm (multi-insn-instantiate!): Tweak logging message.
@
text
@d10 1
a10 1
	      '(<ident>)
d312 10
a321 1
	  (current-insn-add! sub-insn))
a333 2
  (logit 2 "Instantiating multi-insns for " (obj:name multi-insn) " ...\n")

d363 4
@


1.18
log
@(-parse-insn-format-ifield-spec): Tweak error message.
@
text
@d325 1
a325 1
  (logit 2 "Instantiating " (obj:name multi-insn) " ...\n")
a327 1
  ; ??? Though we could ignore second and subsequent calls.
@


1.17
log
@	* cpu/play.cpu (add): Use (ifield enum) for one format element.
	* cpu/play.opc: New file.

	Allow arbitrary enums in instruction formats, e.g. (f-op1 OP1_4).
	* insn.scm (-parse-insn-format-ifield-spec): Recognize (ifield enum).
	* doc/rtl.texi (Instructions): Update.
@
text
@d557 1
a557 1
	   (parse-error errtxt "ifield value not an integer" ifld-spec))))
@


1.16
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d549 9
a557 3
    (if (not (integer? value))
	(parse-error errtxt "ifield value not an integer" ifld-spec))
    (ifld-new-value ifld value))
@


1.16.2.1
log
@Bring over various patches from the trunk.
@
text
@d549 3
a551 9
    (cond ((integer? value)
	   (ifld-new-value ifld value))
	  ((symbol? value)
	   (let ((e (enum-lookup-val value)))
	     (if (not e)
		 (parse-error errtxt "symbolic ifield value not an enum" ifld-spec))
	     (ifld-new-value ifld (car e))))
	  (else
	   (parse-error errtxt "ifield value not an integer or enum" ifld-spec))))
@


1.15
log
@	* rtl-xform.scm (rtx-simplify-insn): New function.
	* html.scm (gen-insn-docs): Call it.
	* sem-frags.scm (sem-find-common-frags, -frag-test-data): Ditto.
	* iformat.scm (ifmt-analyze): Minor simplification.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
@


1.14
log
@* utils.scm (string/symbol->append): Renamed from 'concat'.
* opcodes.scm (gen-switch): Use new name.
* insn.scm (-sub-insn-make!): Same.
* rtl.scm (rtx-dump): Same.
* semantics.scm (semantic-compile): Same.
@
text
@d67 1
a67 1
		; Each element of rtl is replaced with the associated object.
@


1.14.6.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2009 Red Hat, Inc.
@


1.13
log
@* utils.scm (concat): New function.
* insn.scm (-sub-insn-make!): Use concat instead of string-map.
* rtl.scm (rtx-dump): Same.
* semantics.scm (semantic-compile): Same.
@
text
@d274 4
a277 4
		       (concat " "
			       (obj:name op)
			       "="
			       (obj:name newval)))
@


1.12
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@d274 4
a277 4
		       (string-append " "
				      (obj:name op)
				      "="
				      (obj:name newval)))
@


1.11
log
@misc. whitespace and comment cleanup
@
text
@d916 1
a916 1
		       (string-append "${" (obj:name e) "}"))))
@


1.10
log
@back out RELAX part of previous patch and instead implement FIXME:
rename insn RELAX to RELAXED.

	* insn.scm (insn-builtin!): RELAX renamed to RELAXABLE.
	* cpu/m32r.cpu (all insns): Ditto.
@
text
@a707 1

@


1.9
log
@	* mach.scm (current-*-add!): Disallow redefinition.  Make result
	"unspecified".
	* insn.scm (insn-builtin!): Don't define relaxable here, now defined in
	operand.scm.
	* operand.scm (operand-builtin!): Define RELAXABLE for insns too.
	* cpu/m32r.cpu (disp8,disp24): RELAX renamed to RELAXABLE.

	* gen-all-doc: Split arm and frv docs up a bit.

	* cpu/arm.cpu: Add IDOC attribute.
	* cpu/frv.cpu: Ditto.
	* cpu/i960.cpu: Ditto.
	* cpu/openrisc.cpu: Ditto.
	* cpu/xstormy16.cpu: Ditto.
	* cpu/m32r.cpu: Ditto.
	(all insns): Explicitly specify IDOC attribute.

	* Makefile.am (MACH,ISAS,INSN_FILE_NAME): New vars.
	(desc,opcodes,sim-arch,sim-cpu,gas-test,sim-test): Use MACH,ISAS.
	(html): Use MACH,ISAS,INSN_FILE_NAME.  Generate insn.html separately.
	* Makefile.in: Regenerate.
	* attr.scm (<integer-attribute>:parse-value-def): Implement.
	(-attr-read): Defer computing default value until we know the type.
	(attr-has-attr?): Delete, move contents to <attr-list>:has-attr?.
	(<attr-list>:attr-present?): New method.
	(atlist-attr-present?,obj-attr-present?): New fns.
	(obj-has-attr-value?,obj-has-attr-value-no-default?): New fns.
	(attr-builtin!): New insn attr IDOC.
	* cgen-doc.scm (doc-arguments): New args -I,-N.
	* enum.scm (parse-enum-vals): New arg errtxt, all callers updated.
	Support comment as fourth element of enum value.
	(enum-val-name,enum-val-value,enum-val-attrs,enum-val-comment): New fns.
	* html.scm (gen-html-header): New arg kind, all callers updated.
	(gen-table-of-contents): New arg insn-file, all callers updated.
	(gen-list-entry,gen-doc-header): New fn.
	(get-operands): Delete.
	(gen-iformat-table): Rewrite.
	(gen-insn-doc-1): Print constant-folded and trimmed semantics.
	(gen-insn-doc-list): New args name, comment, insns.  All callers updated.
	(get-insn-properties,guess-insn-idoc-attr!): New fn.
	(insn-sets-pc?,insn-refs-mem?,insn-uses-fpu?): New fns.
	(get-insns-for-category,gen-categories-insn-lists): New fns.
	(gen-insn-docs): Simplify each insn's semantics first.
	Print insn tables sorted by IDOC categories.
	(*insn-html-file-name*): New global.
	(cgen-insn.html): New fn.
	(cgen-all): Update.
	* insn.scm (<insn>): Create a setter for the `tmp' member.
	* semantics.scm (insn-build-known-values): Renamed from
	-build-known-values.  All callers updated.

	* rtl.scm: Move traveral/evaluation support to ...
	* rtl-traverse.scm: New file.
	* read.scm: Maybe-load rtl-traverse.scm.

	* rtl.scm (-rtx-valid-types): Add SETRTX.

	* rtx-funcs.scm (nop,parallel): Fix mode.

	* utils.scm (eqv-lookup-index): New fn.
	(assq-lookup-index): Renamed from lookup-index.  All callers updated.

	* dev.scm (load-doc): Set APPLICATION.
@
text
@d963 2
a964 3
  ; NOTE: Defined in operand.scm because we can't define it twice.
  ;(define-attr '(for insn) '(type boolean) '(name RELAXABLE)
  ;  '(comment "insn is relaxable"))
d966 3
a968 3
  ; RELAX: Large relaxable variant.  Avoided by assembler in first pass.
  ; FIXME: Rename this to RELAXED.
  (define-attr '(for insn) '(type boolean) '(name RELAX) '(comment "relaxed form of insn"))
@


1.8
log
@	Back out sim*.scm changes of 2001-04-02  Ben Elliston  <bje@@redhat.com>
	Instead do:
	* sim-decode.scm (-gen-decode-insn-globals): Use @@PREFIX@@_INSN__MAX
	as size of IDESC-TABLE-VAR.
	(@@prefix@@_init_idesc_table): Ditto.
	* sim-model.scm (-gen-mach-defns): Ditto.
	* sim.scm (gen-cpu-insn-enum-decl): Rename last elm from max to -max.

	* utils-scm.scm (-gen-decode-insn-entry): Fix some spacing in output.

	* insn.scm (-parse-insn-format-symbol): Improve error message.
	(-parse-insn-format): Ditto.
@
text
@a42 1
		; ??? Will go away in time.
d96 1
a96 1
  (fmt-desc ifmt sfmt ifield-assertion compiled-semantics)
d963 3
a965 1
  (define-attr '(for insn) '(type boolean) '(name RELAXABLE) '(comment "insn is relaxable"))
@


1.7
log
@* lost patch from RH tree:

2001-09-17  graydon hoare  <graydon@@redhat.com>

	* insn.scm (syntax-break-out): Correct logic in handling escaped
	syntax characters.
@
text
@d527 1
a527 1
	      (parse-error errtxt "bad format element" sym)))))
d616 1
a616 1
			     (parse-error errtxt "bad format element" f)))))
d904 1
a904 1
  )
@


1.6
log
@2002-01-03  Dave Brolley  <brolley@@redhat.com>

	* decode.scm (-distinguishing-bit-population): Compute num-insns, the
	number of insns in the list.  Update the population count function to
	identify and prioritize 3 catgories of useful bits.
	(-population-top-few): Don't consider bits with a population count of
	zero.
	(-build-decode-table-entry): Don't call
	filter-harmlessly-ambiguous-insns.  Filter out non-specialized and
	identical insns at the next tree level.
	* insn.scm (filter-harmlessly-ambiguous-insns): Note in a comment that
	this function is no longer used.
	(filter-non-specialized-ambiguous-insns): New function.
	(filter-identical-ambiguous-insns): New function.
	(find-identical-insn): New function.
	(filter-harmlessly-ambiguous-insns): Removed.
@
text
@d712 1
a712 1
; when there are no more bits to consider while decoding.
d878 6
a883 4
	      (set! result (cons (substring syntax 0 1) result))
	      (set! result (cons (substring syntax 1 1) result))
	      (set! syntax (string-drop 2 syntax)))
	     ; Handle operand reference
@


1.5
log
@* back out for now.
@
text
@d710 3
a712 3
; Filter out instructions whose ifield patterns are strict subsets of
; another.  For decoding purpose, it is sufficient to consider the
; more general cousin.
d714 2
a715 2
(define (filter-harmlessly-ambiguous-insns insn-list)
  (logit 3 "Filtering " (length insn-list) " instructions.\n")
d720 2
a721 2
		 (superset-insn (find-first 
				  (lambda (insn2) ; insn2: possible supermatch (fewer mask bits)
d727 1
a727 1
					   (mask-superset? i2-mask i2-value i-mask i-value))))
d729 1
a729 1
		 (keep? (not superset-insn)))
d732 2
a733 2
		       "Instruction " (obj:name insn) " ambiguity-filtered by "
		       (obj:name superset-insn) "\n"))
d738 26
@


1.4
log
@2001-09-17  graydon hoare  <graydon@@redhat.com>

	* insn.scm (syntax-break-out): Change $ escape specifier
	from \$ to $$, to reduce interactions with scheme and C escaping
	conventions.
	* doc/rtl.texi (Instructions): Document change.
@
text
@d851 3
a853 4
	     ((and 
	       (char=? #\$ (string-ref syntax 0))
	       (char=? #\$ (string-ref syntax 1)))
	      (set! result (cons "$" result))
@


1.3
log
@* ambiguous insn sim decode fix

2001-07-12  Frank Ch. Eigler  <fche@@redhat.com>

        * insn.scm (filter-harmlessly-ambiguous-insns): Fix msg typo.
        (mask-superset?): Look for strict supersets to allow rejection of
        duplicate insns.
@
text
@d851 4
a854 3
	     ((char=? #\\ (string-ref syntax 0))
	      (set! result (cons (substring syntax 0 1) result))
	      (set! result (cons (substring syntax 1 1) result))
@


1.2
log
@	* insn.scm (-parse-insn-format-symbol): Fix spelling error,
	op-ifld -> op-ifield.
@
text
@d732 1
a732 1
		       "Instruction " (obj:name insn) "ambiguity-filtered by "
d739 1
a739 1
; Helper function for above: does (m1,v1) match a superset of (m2,v2) ?
d744 2
d749 2
a750 1
	      (= (cg-logand m1 v1) (cg-logand m1 v2)))))
@


1.1
log
@Initial revision
@
text
@d515 1
a515 1
	       (let ((ifld (op-ifld op)))
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
