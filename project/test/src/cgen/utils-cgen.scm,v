head	1.29;
access;
symbols
	sid-snapshot-20180601:1.29
	cgen-snapshot-20180601:1.29
	sid-snapshot-20180501:1.29
	cgen-snapshot-20180501:1.29
	sid-snapshot-20180401:1.29
	cgen-snapshot-20180401:1.29
	sid-snapshot-20180301:1.29
	cgen-snapshot-20180301:1.29
	sid-snapshot-20180201:1.29
	cgen-snapshot-20180201:1.29
	sid-snapshot-20180101:1.29
	cgen-snapshot-20180101:1.29
	sid-snapshot-20171201:1.29
	cgen-snapshot-20171201:1.29
	sid-snapshot-20171101:1.29
	cgen-snapshot-20171101:1.29
	sid-snapshot-20171001:1.29
	cgen-snapshot-20171001:1.29
	sid-snapshot-20170901:1.29
	cgen-snapshot-20170901:1.29
	sid-snapshot-20170801:1.29
	cgen-snapshot-20170801:1.29
	sid-snapshot-20170701:1.29
	cgen-snapshot-20170701:1.29
	sid-snapshot-20170601:1.29
	cgen-snapshot-20170601:1.29
	sid-snapshot-20170501:1.29
	cgen-snapshot-20170501:1.29
	sid-snapshot-20170401:1.29
	cgen-snapshot-20170401:1.29
	sid-snapshot-20170301:1.29
	cgen-snapshot-20170301:1.29
	sid-snapshot-20170201:1.29
	cgen-snapshot-20170201:1.29
	sid-snapshot-20170101:1.29
	cgen-snapshot-20170101:1.29
	sid-snapshot-20161201:1.29
	cgen-snapshot-20161201:1.29
	sid-snapshot-20161101:1.29
	cgen-snapshot-20161101:1.29
	sid-snapshot-20160901:1.29
	cgen-snapshot-20160901:1.29
	sid-snapshot-20160801:1.29
	cgen-snapshot-20160801:1.29
	sid-snapshot-20160701:1.29
	cgen-snapshot-20160701:1.29
	sid-snapshot-20160601:1.29
	cgen-snapshot-20160601:1.29
	sid-snapshot-20160501:1.29
	cgen-snapshot-20160501:1.29
	sid-snapshot-20160401:1.29
	cgen-snapshot-20160401:1.29
	sid-snapshot-20160301:1.29
	cgen-snapshot-20160301:1.29
	sid-snapshot-20160201:1.29
	cgen-snapshot-20160201:1.29
	sid-snapshot-20160101:1.29
	cgen-snapshot-20160101:1.29
	sid-snapshot-20151201:1.29
	cgen-snapshot-20151201:1.29
	sid-snapshot-20151101:1.29
	cgen-snapshot-20151101:1.29
	sid-snapshot-20151001:1.29
	cgen-snapshot-20151001:1.29
	sid-snapshot-20150901:1.29
	cgen-snapshot-20150901:1.29
	sid-snapshot-20150801:1.29
	cgen-snapshot-20150801:1.29
	sid-snapshot-20150701:1.29
	cgen-snapshot-20150701:1.29
	sid-snapshot-20150601:1.29
	cgen-snapshot-20150601:1.29
	sid-snapshot-20150501:1.29
	cgen-snapshot-20150501:1.29
	sid-snapshot-20150401:1.29
	cgen-snapshot-20150401:1.29
	sid-snapshot-20150301:1.29
	cgen-snapshot-20150301:1.29
	sid-snapshot-20150201:1.29
	cgen-snapshot-20150201:1.29
	sid-snapshot-20150101:1.29
	cgen-snapshot-20150101:1.29
	sid-snapshot-20141201:1.29
	cgen-snapshot-20141201:1.29
	sid-snapshot-20141101:1.29
	cgen-snapshot-20141101:1.29
	sid-snapshot-20141001:1.29
	cgen-snapshot-20141001:1.29
	sid-snapshot-20140901:1.29
	cgen-snapshot-20140901:1.29
	sid-snapshot-20140801:1.29
	cgen-snapshot-20140801:1.29
	sid-snapshot-20140701:1.29
	cgen-snapshot-20140701:1.29
	sid-snapshot-20140601:1.29
	cgen-snapshot-20140601:1.29
	sid-snapshot-20140501:1.29
	cgen-snapshot-20140501:1.29
	sid-snapshot-20140401:1.29
	cgen-snapshot-20140401:1.29
	sid-snapshot-20140301:1.29
	cgen-snapshot-20140301:1.29
	sid-snapshot-20140201:1.29
	cgen-snapshot-20140201:1.29
	sid-snapshot-20140101:1.29
	cgen-snapshot-20140101:1.29
	sid-snapshot-20131201:1.29
	cgen-snapshot-20131201:1.29
	sid-snapshot-20131101:1.29
	cgen-snapshot-20131101:1.29
	sid-snapshot-20131001:1.29
	cgen-snapshot-20131001:1.29
	sid-snapshot-20130901:1.29
	cgen-snapshot-20130901:1.29
	sid-snapshot-20130801:1.29
	cgen-snapshot-20130801:1.29
	sid-snapshot-20130701:1.29
	cgen-snapshot-20130701:1.29
	sid-snapshot-20130601:1.29
	cgen-snapshot-20130601:1.29
	sid-snapshot-20130501:1.29
	cgen-snapshot-20130501:1.29
	sid-snapshot-20130401:1.29
	cgen-snapshot-20130401:1.29
	sid-snapshot-20130301:1.29
	cgen-snapshot-20130301:1.29
	sid-snapshot-20130201:1.29
	cgen-snapshot-20130201:1.29
	sid-snapshot-20130101:1.29
	cgen-snapshot-20130101:1.29
	sid-snapshot-20121201:1.29
	cgen-snapshot-20121201:1.29
	sid-snapshot-20121101:1.29
	cgen-snapshot-20121101:1.29
	sid-snapshot-20121001:1.29
	cgen-snapshot-20121001:1.29
	sid-snapshot-20120901:1.29
	cgen-snapshot-20120901:1.29
	sid-snapshot-20120801:1.29
	cgen-snapshot-20120801:1.29
	sid-snapshot-20120701:1.29
	cgen-snapshot-20120701:1.29
	sid-snapshot-20120601:1.29
	cgen-snapshot-20120601:1.29
	sid-snapshot-20120501:1.29
	cgen-snapshot-20120501:1.29
	sid-snapshot-20120401:1.29
	cgen-snapshot-20120401:1.29
	sid-snapshot-20120301:1.29
	cgen-snapshot-20120301:1.29
	sid-snapshot-20120201:1.29
	cgen-snapshot-20120201:1.29
	sid-snapshot-20120101:1.29
	cgen-snapshot-20120101:1.29
	sid-snapshot-20111201:1.29
	cgen-snapshot-20111201:1.29
	sid-snapshot-20111101:1.29
	cgen-snapshot-20111101:1.29
	sid-snapshot-20111001:1.29
	cgen-snapshot-20111001:1.29
	sid-snapshot-20110901:1.29
	cgen-snapshot-20110901:1.29
	sid-snapshot-20110801:1.29
	cgen-snapshot-20110801:1.29
	sid-snapshot-20110701:1.29
	cgen-snapshot-20110701:1.29
	sid-snapshot-20110601:1.29
	cgen-snapshot-20110601:1.29
	sid-snapshot-20110501:1.29
	cgen-snapshot-20110501:1.29
	sid-snapshot-20110401:1.29
	cgen-snapshot-20110401:1.29
	sid-snapshot-20110301:1.29
	cgen-snapshot-20110301:1.29
	sid-snapshot-20110201:1.29
	cgen-snapshot-20110201:1.29
	sid-snapshot-20110101:1.29
	cgen-snapshot-20110101:1.29
	sid-snapshot-20101201:1.29
	cgen-snapshot-20101201:1.29
	sid-snapshot-20101101:1.29
	cgen-snapshot-20101101:1.29
	sid-snapshot-20101001:1.28
	cgen-snapshot-20101001:1.28
	sid-snapshot-20100901:1.28
	cgen-snapshot-20100901:1.28
	sid-snapshot-20100801:1.28
	cgen-snapshot-20100801:1.28
	sid-snapshot-20100701:1.28
	cgen-snapshot-20100701:1.28
	sid-snapshot-20100601:1.28
	cgen-snapshot-20100601:1.28
	sid-snapshot-20100501:1.28
	cgen-snapshot-20100501:1.28
	sid-snapshot-20100401:1.28
	cgen-snapshot-20100401:1.28
	sid-snapshot-20100301:1.28
	cgen-snapshot-20100301:1.28
	sid-snapshot-20100201:1.26
	cgen-snapshot-20100201:1.26
	sid-snapshot-20100101:1.23
	cgen-snapshot-20100101:1.23
	sid-snapshot-20091201:1.23
	cgen-snapshot-20091201:1.23
	sid-snapshot-20091101:1.20
	cgen-snapshot-20091101:1.20
	sid-snapshot-20091001:1.20
	cgen-snapshot-20091001:1.20
	arc-sim-20090309:1.7
	sid-snapshot-20090901:1.18
	cgen-snapshot-20090901:1.18
	sid-snapshot-20090801:1.9
	cgen-snapshot-20090801:1.9
	sid-snapshot-20090701:1.8
	cgen-snapshot-20090701:1.8
	dje-cgen-play1-branch:1.8.0.2
	dje-cgen-play1-branchpoint:1.8
	cgen-1_1-branch:1.7.0.6
	cgen-1_1-branchpoint:1.7
	sid-snapshot-20090601:1.7
	cgen-snapshot-20090601:1.7
	sid-snapshot-20090501:1.7
	cgen-snapshot-20090501:1.7
	sid-snapshot-20090401:1.7
	cgen-snapshot-20090401:1.7
	arc-insight_6_8-branch:1.7.0.4
	arc-insight_6_8-branchpoint:1.7
	sid-snapshot-20090301:1.7
	cgen-snapshot-20090301:1.7
	sid-snapshot-20090201:1.7
	cgen-snapshot-20090201:1.7
	sid-snapshot-20090101:1.7
	cgen-snapshot-20090101:1.7
	sid-snapshot-20081201:1.7
	cgen-snapshot-20081201:1.7
	sid-snapshot-20081101:1.7
	cgen-snapshot-20081101:1.7
	sid-snapshot-20081001:1.7
	cgen-snapshot-20081001:1.7
	sid-snapshot-20080901:1.7
	cgen-snapshot-20080901:1.7
	sid-snapshot-20080801:1.7
	cgen-snapshot-20080801:1.7
	sid-snapshot-20080701:1.7
	cgen-snapshot-20080701:1.7
	sid-snapshot-20080601:1.7
	cgen-snapshot-20080601:1.7
	sid-snapshot-20080501:1.7
	cgen-snapshot-20080501:1.7
	sid-snapshot-20080403:1.7
	sid-snapshot-20080401:1.7
	cgen-snapshot-20080401:1.7
	sid-snapshot-20080301:1.7
	cgen-snapshot-20080301:1.7
	sid-snapshot-20080201:1.7
	cgen-snapshot-20080201:1.7
	sid-snapshot-20080101:1.7
	cgen-snapshot-20080101:1.7
	sid-snapshot-20071201:1.7
	cgen-snapshot-20071201:1.7
	sid-snapshot-20071101:1.7
	cgen-snapshot-20071101:1.7
	sid-snapshot-20071001:1.7
	cgen-snapshot-20071001:1.7
	msnyder-fork-checkpoint-branch:1.7.0.2
	msnyder-fork-checkpoint-branchpoint:1.7
	sid-20020905-branchpoint:1.3
	sid-20020905-branch:1.3.0.6
	cagney_regbuf-20020515-branch:1.3.0.4
	cagney_regbuf-20020515-branchpoint:1.3
	cygnus_cvs_20020108_pre:1.3
	cgen-1-1-branch:1.3.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.29
date	2010.10.09.06.50.20;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2010.02.13.03.39.15;	author devans;	state Exp;
branches;
next	1.27;

1.27
date	2010.02.12.02.12.12;	author devans;	state Exp;
branches;
next	1.26;

1.26
date	2010.01.25.00.40.29;	author devans;	state Exp;
branches;
next	1.25;

1.25
date	2010.01.24.23.54.57;	author devans;	state Exp;
branches;
next	1.24;

1.24
date	2010.01.24.23.48.37;	author devans;	state Exp;
branches;
next	1.23;

1.23
date	2009.11.23.03.28.31;	author devans;	state Exp;
branches;
next	1.22;

1.22
date	2009.11.05.19.23.08;	author devans;	state Exp;
branches;
next	1.21;

1.21
date	2009.11.03.16.24.02;	author devans;	state Exp;
branches;
next	1.20;

1.20
date	2009.09.17.16.49.12;	author devans;	state Exp;
branches;
next	1.19;

1.19
date	2009.09.07.22.17.34;	author devans;	state Exp;
branches;
next	1.18;

1.18
date	2009.08.27.06.09.02;	author devans;	state Exp;
branches;
next	1.17;

1.17
date	2009.08.27.05.47.12;	author devans;	state Exp;
branches;
next	1.16;

1.16
date	2009.08.27.04.22.56;	author devans;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.22.23.16.01;	author devans;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.19.04.20.29;	author devans;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.18.01.40.57;	author devans;	state Exp;
branches;
next	1.12;

1.12
date	2009.08.12.22.33.37;	author devans;	state Exp;
branches;
next	1.11;

1.11
date	2009.08.07.21.29.20;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2009.08.06.16.40.43;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2009.07.18.20.44.58;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.28.19.30.02;	author brolley;	state Exp;
branches
	1.7.6.1;
next	1.6;

1.6
date	2004.12.16.21.24.07;	author jimb;	state Exp;
branches;
next	1.5;

1.5
date	2003.07.16.05.35.48;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.15.07.25.03;	author devans;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.20.19.03.33;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.13.11.21.57;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.7.6.1
date	2009.06.24.14.57.46;	author devans;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.29
log
@cgen/
	* utils-cgen.scm (gen-attr-accessors): Rename bool attribute to bool_.
	* cpu/mep.opc (mep_cgen_insn_supported): Ditto.
include/opcode/
	* cgen.h (CGEN_ATTR, CGEN_ATTR_TYPE): Rename bool attribute to bool_.
	(CGEN_ATTR_BOOLS, CGEN_ATTR_CGEN_INSN_ALIAS_VALUE): Likewise.

opcodes/
	* fr30-desc.h: Regenerate.
	* frv-desc.h: Regenerate.
	* ip2k-desc.h: Regenerate.
	* iq2000-desc.h: Regenerate.
	* lm32-desc.h: Regenerate.
	* m32c-desc.h: Regenerate.
	* m32r-desc.h: Regenerate.
	* mep-desc.h: Regenerate.
	* mep-opc.c: Regenerate.
	* mt-desc.h: Regenerate.
	* openrisc-desc.h: Regenerate.
	* xc16x-desc.h: Regenerate.
	* xstormy16-desc.h: Regenerate.
@
text
@;; CGEN Utilities.
;; Copyright (C) 2000, 2002, 2003, 2009, 2010 Red Hat, Inc.
;; This file is part of CGEN.
;; See file COPYING.CGEN for details.
;;
;; This file contains utilities specific to cgen.
;; Generic utilities should go in utils.scm.

;; True if text of sanitize markers are to be emitted.
;; This is a debugging tool only, though it could have use in sanitized trees.
(define include-sanitize-marker? #t)

;; Utility to display command line invocation for debugging purposes.

(define (display-argv argv)
  (let ((cep (current-error-port)))
    (display "cgen -s " cep)
    (for-each (lambda (arg)
		;; Output double-quotes if string has a space for better
		;; correspondence to how to specify string to shell.
		(if (string-index arg #\space)
		    (write arg cep)
		    (display arg cep))
		(display " " cep))
	      argv)
    (newline cep))
)

;; Source locations are recorded as a stack, with (ideally) one extra level
;; for each macro invocation.

(define-class <location> location- () 
  (
   ;; A list of "single-location" objects,
   ;; sorted by most recent location first.
   !list
   )
)

;; A single source location.
;; This is recorded as a vector for simplicity.
;; END? is true if the location marks the end of the expression.
;; NOTE: LINE and COLUMN are origin-0 (the first line is line 0).

(define (make-single-location file line column end?)
  (vector file line column end?)
)

(define (single-location-file sloc) (vector-ref sloc 0))
(define (single-location-line sloc) (vector-ref sloc 1))
(define (single-location-column sloc) (vector-ref sloc 2))
(define (single-location-end? sloc) (vector-ref sloc 3))

;; Return a single-location in a readable form.

(define (single-location->string sloc)
  ;; +1: numbers are recorded origin-0
  (string-append (single-location-file sloc)
		 ":"
		 (number->string (+ (single-location-line sloc) 1))
		 ":"
		 (number->string (+ (single-location-column sloc) 1))
		 (if (single-location-end? sloc) "(end)" ""))
)

;; Same as single-location->string, except omit any directory info in
;; the file name.

(define (single-location->simple-string sloc)
  ;; +1: numbers are recorded origin-0
  (string-append (basename (single-location-file sloc))
		 ":"
		 (number->string (+ (single-location-line sloc) 1))
		 ":"
		 (number->string (+ (single-location-column sloc) 1))
		 (if (single-location-end? sloc) "(end)" ""))
)

;; Return a location in a readable form.

(define (location->string loc)
  (let ((ref-from " referenced from:"))
    (string-drop
     (- 0 (string-length ref-from) 1)
     (string-drop1
      (apply string-append
	     (map (lambda (sloc)
		    (string-append "\n"
				   (single-location->string sloc)
				   ":"
				   ref-from))
		  (location-list loc))))))
)

;; Return the location information in Guile's source-properties
;; in a readable form.

(define (source-properties-location->string src-props)
  (let ((file (assq-ref src-props 'filename))
	(line (assq-ref src-props 'line))
	(column (assq-ref src-props 'column)))
    (string-append file
		   ":"
		   (number->string (+ line 1))
		   ":"
		   (number->string (+ column 1))))
)

;; Return the top location on LOC's stack.

(define (location-top loc)
  (car (location-list loc))
)

;; Return a new <location> with FILE, LINE pushed onto the stack.

(define (location-push-single loc file line column end?)
  (make <location> (cons (make-single-location file line column end?)
			 (location-list loc)))
)

;; Return a new <location> with NEW-LOC preappended to LOC.

(define (location-push loc new-loc)
  (make <location> (append (location-list new-loc)
			   (location-list loc)))
)

;; Return an unspecified <location>.
;; This is mainly for use in debugging utilities.
;; Ideally for .cpu-file related stuff we always have a location,
;; but that's not always true.

(define (unspecified-location)
  (make <location> (list (make-single-location "unspecified" 0 0 #f)))
)

;; Return a location denoting a builtin object.

(define (builtin-location)
  (make <location> (list (make-single-location "builtin" 0 0 #f)))
)

;; Return a <location> object for the current input port.
;; END? is true if the location marks the end of the expression.

(define (current-input-location end?)
  (let ((cip (current-input-port)))
    (make <location> (list (make-single-location (port-filename cip)
						 (port-line cip)
						 (port-column cip)
						 end?))))
)

;; An object property for tracking source locations during macro expansion.

(define location-property (make-object-property))

;; Set FORM's location to LOC.

(define (location-property-set! form loc)
  (set! (location-property form) loc)
  *UNSPECIFIED*
)

;; Each named entry in the description file typically has these three members:
;; name, comment attrs.

(define-class <ident> ident- () (!name !comment !attrs))

;; All objects defined in the .cpu file have name, comment, attrs elements.
;; Where in the class hierarchy they're recorded depends on the object.
;; Each object is required to provide these interfaces.

(define-interface obj-name get-name)
(define-interface obj-comment get-comment)
;; FIXME: See definition of obj-atlist.
(define-interface obj-atlist1 get-atlist)

(define-interface obj-set-name! set-name! newval)
(define-interface obj-set-comment! set-comment! newval)
(define-interface obj-set-atlist! set-atlist! newval)

;; Get/set attributes of OBJ.
;; OBJ is any object which supports the get-atlist interface.

(define (obj-atlist obj)
  (let ((result (obj-atlist1 obj)))
    ;; As a speed up, we allow objects to specify an empty attribute list
    ;; with #f or (), rather than creating an attr-list object.
    ;; ??? There is atlist-empty now which should be used directly, after
    ;; which we can delete use and rename obj-atlist1 -> obj-atlist.
    (if (or (null? result) (not result))
	atlist-empty
	result))
)

(define-method <ident> get-name (self)
  (ident-name self))
(define-method <ident> get-comment (self)
  (ident-comment self))
(define-method <ident> get-atlist (self)
  (ident-attrs self))

(define-method <ident> set-name! (self newval)
  (ident-set-name! self newval))
(define-method <ident> set-comment! (self newval)
  (ident-set-comment! self newval))
(define-method <ident> set-atlist! (self newval)
  (ident-set-attrs! self newval))

;; FIXME: Delete and replace with the above interfaces.
(define (obj:name obj) (obj-name obj))
(define (obj:comment obj) (obj-comment obj))

;; Utility to return the name as a string.

(define (obj:str-name obj) (symbol->string (obj:name obj)))

;; Given a list of named objects, return a string of comma-separated names.

(define (obj-csv-names obj-list)
  (string-drop1
   (string-map (lambda (o)
		 (string-append ","
				(obj:str-name o)))
	       obj-list))
)

;; Subclass of <ident> for use by description file objects.
;;
;; Records the source location of the object.
;;
;; We also record an internally generated entry, ordinal, to record the
;; relative position within the description file.  It's generally more efficient
;; to record some kinds of objects (e.g. insns) in a hash table.  But we also
;; want to emit these objects in file order.  Recording the object's relative
;; position lets us generate an ordered list when we need to.
;; We can't just use the line number because we want an ordering over multiple
;; input files.

(define-class <source-ident> source-ident- (<ident>)
  (
   ;; A <location> object.
   (/!location . #f)
   ;; #f for ordinal means "unassigned"
   (/!ordinal . #f)
   )
)

(define-interface obj-location get-location)
(define-interface obj-set-location! set-location! newval)

(define-method <source-ident> get-location (self)
  (/source-ident-location self))
(define-method <source-ident> set-location! (self newval)
  (/source-ident-set-location! self newval))

(define-interface obj-ordinal get-ordinal)
(define-interface obj-set-ordinal! set-ordinal! newval)

(define-method <source-ident> get-ordinal (self)
  (/source-ident-ordinal self))
(define-method <source-ident> set-ordinal! (self newval)
  (/source-ident-set-ordinal! self newval))

;; Parsing utilities

;; A parsing/processing context, used to give better error messages.
;; LOCATION must be an object created with make-location.

(define-class <context> context- ()
  (
   ;; Location of the object being processed,
   ;; or #f if unknown (or there is none).
   (location . #f)
   ;; Error message prefix or #f if there is none.
   (prefix . #f)
   )
)

;; Create a <context> object that is just a prefix.

(define (make-prefix-context prefix)
  (make <context> #f prefix)
)

;; Create a <context> object that (current-reader-location) with PREFIX.

(define (make-current-context prefix)
  (make <context> (current-reader-location) prefix)
)

;; Create a <context> object from <source-ident> object OBJ.

(define (make-obj-context obj prefix)
  (make <context> (obj-location obj) prefix)
)

;; Create a new context from CONTEXT with TEXT appended to the prefix.

(define (context-append context text)
  (make <context> (context-location context)
	(string-append (context-prefix context) text))
)

;; Create a new context from CONTEXT with NAME appended to the prefix.

(define (context-append-name context name)
  (context-append context (stringsym-append ":" name))
)

;; Call this to issue an error message when all you have is a context.
;; CONTEXT is a <context> object or #f if there is none.
;; INTRO is a general introduction to what cgen was doing.
;; ERRMSG is, yes, you guessed it, the error message.
;; EXPR is the value that had the error if there is one.

(define (context-error context intro errmsg . expr)
  (apply context-owner-error
	 (cons context
	       (cons #f
		     (cons intro
			   (cons errmsg expr)))))
)

;; Call this to issue an error message when you have a context and an
;; <ident> or <source-ident> object (we call the "owner").
;; CONTEXT is a <context> object or #f if there is none.
;; OWNER is an <ident> or <source-ident> object or #f if there is none.
;; INTRO is a general introduction to what cgen was doing.
;;   If OWNER is non-#f, the text " of <object-name>" is appended.
;; ERRMSG is, yes, you guessed it, the error message.
;; EXPR is the value that had the error if there is one.

(define (context-owner-error context owner intro errmsg . expr)
  ;; If we don't have a context, look at the owner to try to find one.
  ;; We want to include the source location in the error if we can.
  (if (and (not context)
	   owner
	   (source-ident? owner))
      (set! context (make-obj-context owner #f)))
  (if (not context)
      (set! context (make-prefix-context #f)))

  (let* ((loc (context-location context))
	 (top-sloc (and loc (location-top loc)))
	 (intro (string-append intro
			       (if owner
				   (string-append " of "
						  (obj:str-name owner))
				   "")))
	 (prefix (or (context-prefix context) "Error"))
	 (text (string-append prefix ": " errmsg)))

    (if loc

	(apply error
	       (cons
		(simple-format
		 #f
		 "\n~A:\n@@ ~A:\n\n~A: ~A:"
		 intro
		 (location->string loc)
		 (single-location->simple-string top-sloc)
		 text)
		expr))

	(apply error
	       (cons
		(simple-format
		 #f
		 "\n~A:\n~A:"
		 intro
		 text)
		expr))))
)

;; Parse an object name.
;; NAME is either a symbol or a list of symbols which are concatenated
;; together.  Each element can in turn be a list of symbols, and so on.
;; This supports symbol concatenation in the description file without having
;; to using string-append or some such.

(define (parse-name context name)
  (string->symbol
   (let parse ((name name))
     (cond
      ((symbol? name) (symbol->string name))
      ((string? name) name)
      ((number? name) (number->string name))
      ((list? name) (string-map parse name))
      (else (parse-error context "improper name" name)))))
)

;; Parse an object comment.
;; COMMENT is either a string or a list of strings, each element of which may
;; in turn be a list of strings.

(define (parse-comment context comment)
  (cond ((string? comment) comment)
	((symbol? comment) (symbol->string comment))
	((number? comment) (number->string comment))
	((list? comment)
	 (string-map (lambda (elm) (parse-comment context elm)) comment))
	(else (parse-error context "improper comment" comment)))
)

;; Parse a symbol.

(define (parse-symbol context value)
  (if (and (not (symbol? value)) (not (string? value)))
      (parse-error context "not a symbol or string" value))
  (->symbol value)
)

;; Parse a string.

(define (parse-string context value)
  (if (and (not (symbol? value)) (not (string? value)))
      (parse-error context "not a string or symbol" value))
  (->string value)
)

;; Parse a number.
;; VALID-VALUES is a list of numbers and (min . max) pairs.

(define (parse-number context value . valid-values)
  (if (not (number? value))
      (parse-error context "not a number" value))
  (if (any-true? (map (lambda (test)
			(if (pair? test)
			    (and (>= value (car test))
				 (<= value (cdr test)))
			    (= value test)))
		      valid-values))
      value
      (parse-error context "invalid number" value valid-values))
)

;; Parse a boolean value

(define (parse-boolean context value)
  (if (boolean? value)
      value
      (parse-error context "not a boolean (#f/#t)" value))
)

;; Parse a list of handlers.
;; Each entry is (symbol "string").
;; These map function to a handler for it.
;; The meaning is up to the application but generally the handler is a
;; C/C++ function name.
;; ALLOWED is a list valid values for the symbol or #f if anything is allowed.
;; The result is handlers unchanged.

(define (parse-handlers context allowed handlers)
  (if (not (list? handlers))
      (parse-error context "bad handler spec" handlers))
  (for-each (lambda (arg)
	      (if (not (list-elements-ok? arg (list symbol? string?)))
		  (parse-error context "bad handler spec" arg))
	      (if (and allowed (not (memq (car arg) allowed)))
		  (parse-error context "unknown handler type" (car arg))))
	    handlers)
  handlers
)

;; Return a boolean indicating if X is a keyword.
;; This also handles symbols named :foo because Guile doesn't stablely support
;; :keywords (how does one enable :keywords? read-options doesn't appear to
;; work).

(define (keyword-list? x)
  (and (list? x)
       (not (null? x))
       (or (keyword? (car x))
	   (and (symbol? (car x))
		(char=? (string-ref (symbol->string (car x)) 0) #\:))))
)

;; Convert a list like (#:key1 val1 #:key2 val2 ...) to
;; ((#:key1 val1) (#:key2 val2) ...).
;; Missing values are specified with an empty list.
;; This also supports (:sym1 val1 ...) because Guile doesn't stablely support
;; :keywords (#:keywords work, but #:foo shouldn't appear in the description
;; language).

(define (keyword-list->arg-list kl)
  ;; Scan KL backwards, building up each element as we go.
  (let loop ((result nil) (current nil) (rkl (reverse kl)))
    (cond ((null? rkl)
	   result)
	  ((keyword? (car rkl))
	   (loop (acons (keyword->symbol (car rkl)) current result)
		 nil
		 (cdr rkl)))
	  ((and (symbol? (car rkl))
		(char=? (string-ref (symbol->string (car rkl)) 0) #\:))
	   (loop (acons (string->symbol
			 (substring (car rkl) 1 (string-length (car rkl))))
			current result)
		 nil
		 (cdr rkl)))
	  (else
	   (loop result
		 (cons (car rkl) current)
		 (cdr rkl)))))
)

;; Signal an error if the argument name is not a symbol.
;; This is done by each of the argument validation routines so the caller
;; doesn't need to make two calls.

(define (arg-list-validate-name context arg-spec)
  (if (null? arg-spec)
      (parse-error context "empty argument spec" arg-spec))
  (if (not (symbol? (car arg-spec)))
      (parse-error context "argument name not a symbol" arg-spec))
  *UNSPECIFIED*
)

;; Signal a parse error if an argument was specified with a value.
;; ARG-SPEC is (name value).

(define (arg-list-check-no-args context arg-spec)
  (arg-list-validate-name context arg-spec)
  (if (not (null? (cdr arg-spec)))
      (parse-error context (string-append (car arg-spec)
					  " takes zero arguments")))
  *UNSPECIFIED*
)

;; Validate and return a symbol argument.
;; ARG-SPEC is (name value).

(define (arg-list-symbol-arg context arg-spec)
  (arg-list-validate-name context arg-spec)
  (if (or (!= (length (cdr arg-spec)) 1)
	  (not (symbol? (cadr arg-spec))))
      (parse-error context (string-append (car arg-spec)
					  ": argument not a symbol")))
  (cadr arg-spec)
)

;; Sanitization

;; Sanitization is handled via attributes.  Anything that must be sanitized
;; has a `sanitize' attribute with the value being the keyword to sanitize on.
;; Ideally most, if not all, of the guts of the generated sanitization is here.

;; Utility to simplify expression in .cpu file.
;; Usage: (sanitize isa-name-list keyword entry-type entry-name1 [entry-name2 ...])
;; Enum attribute `(sanitize keyword)' is added to the entry.

(define (sanitize isa-name-list keyword entry-type . entry-names)
  (for-each (lambda (entry-name)
	      (let ((entry #f))
		(case entry-type
		  ((attr) (set! entry (current-attr-lookup entry-name)))
		  ((enum) (set! entry (current-enum-lookup entry-name)))
		  ((isa) (set! entry (current-isa-lookup entry-name)))
		  ((cpu) (set! entry (current-cpu-lookup entry-name)))
		  ((mach) (set! entry (current-mach-lookup entry-name)))
		  ((model) (set! entry (current-model-lookup entry-name)))
		  ((ifield) (set! entry (current-ifld-lookup entry-name isa-name-list)))
		  ((hardware) (set! entry (current-hw-lookup entry-name)))
		  ((operand) (set! entry (current-op-lookup entry-name isa-name-list)))
		  ((insn) (set! entry (current-insn-lookup entry-name isa-name-list)))
		  ((macro-insn) (set! entry (current-minsn-lookup entry-name isa-name-list)))
		  (else (parse-error (make-prefix-context "sanitize")
				     "unknown entry type" entry-type)))

		;; ENTRY is #f in the case where the element was discarded
		;; because its mach wasn't selected.  But in the case where
		;; we're keeping everything, ensure ENTRY is not #f to
		;; catch spelling errors.

		(if entry

		    (begin
		      (obj-cons-attr! entry (enum-attr-make 'sanitize keyword))
		      ;; Propagate the sanitize attribute to class members
		      ;; as necessary.
		      (case entry-type
			((hardware)
			 (if (hw-indices entry)
			     (obj-cons-attr! (hw-indices entry)
					     (enum-attr-make 'sanitize
							     keyword)))
			 (if (hw-values entry)
			     (obj-cons-attr! (hw-values entry)
					     (enum-attr-make 'sanitize
							     keyword))))
			))

		    (if (and (eq? APPLICATION 'OPCODES) (keep-all?))
			(parse-error (make-prefix-context "sanitize")
				     (string-append "unknown " entry-type)
				     entry-name)))))
	    entry-names)

  #f ;; caller eval's our result, so return a no-op
)

;; Return TEXT sanitized with KEYWORD.
;; TEXT must exist on a line (or lines) by itself.
;; i.e. it is assumed that it begins at column 1 and ends with a newline.
;; If KEYWORD is #f, no sanitization is generated.

(define (gen-sanitize keyword text)
  (cond ((null? text) "")
	((pair? text) ;; pair? -> cheap list?
	 (if (and keyword include-sanitize-marker?)
	     (string-list
	      ;; split string to avoid removal
	      "/* start-"
	      "sanitize-" keyword " */\n"
	      text
	      "/* end-"
	      "sanitize-" keyword " */\n")
	     text))
	(else
	 (if (= (string-length text) 0)
	     ""
	     (if (and keyword include-sanitize-marker?)
		 (string-append
		  ;; split string to avoid removal
		  "/* start-"
		  "sanitize-" keyword " */\n"
		  text
		  "/* end-"
		  "sanitize-" keyword " */\n")
		 text))))
)

;; Return TEXT sanitized with OBJ's sanitization, if it has any.
;; OBJ may be #f.

(define (gen-obj-sanitize obj text)
  (if obj
      (let ((san (obj-attr-value obj 'sanitize)))
	(gen-sanitize (if (or (not san) (eq? san 'none)) #f san)
		      text))
      (gen-sanitize #f text))
)

;; Cover procs to handle generation of object declarations and definitions.
;; All object output should be routed through gen-decl and gen-defn.

;; Send the gen-decl message to OBJ, and sanitize the output if necessary.

(define (gen-decl obj)
  (logit 3 "Generating decl for "
	 (cond ((method-present? obj 'get-name) (send obj 'get-name))
	       ((elm-present? obj 'name) (elm-get obj 'name))
	       (else "unknown"))
	 " ...\n")
  (cond ((and (method-present? obj 'gen-decl) (not (has-attr? obj 'META)))
	 (gen-obj-sanitize obj (send obj 'gen-decl)))
	(else ""))
)

;; Send the gen-defn message to OBJ, and sanitize the output if necessary.

(define (gen-defn obj)
  (logit 3 "Generating defn for "
	 (cond ((method-present? obj 'get-name) (send obj 'get-name))
	       ((elm-present? obj 'name) (elm-xget obj 'name))
	       (else "unknown"))
	 " ...\n")
  (cond ((and (method-present? obj 'gen-defn) (not (has-attr? obj 'META)))
	 (gen-obj-sanitize obj (send obj 'gen-defn)))
	(else ""))
)

;; Attributes

;; Return the C/C++ type to use to hold a value for attribute ATTR.

(define (gen-attr-type attr)
  (if (string=? (string-downcase (gen-sym attr)) "isa")
      "CGEN_BITSET"
      (case (attr-kind attr)
	((boolean) "int")
	((bitset)  "unsigned int")
	((integer) "int")
	((enum)    (string-append "enum " (string-downcase (gen-sym attr)) "_attr"))
	))
)

;; Return C macros for accessing an object's attributes ATTRS.
;; PREFIX is one of "cgen_ifld", "cgen_hw", "cgen_operand", "cgen_insn".
;; ATTRS is an alist of attribute values.  The value is unimportant except that
;; it is used to determine bool/non-bool.
;; Non-bools need to be separated from bools as they're each recorded
;; differently.  Non-bools are recorded in an int for each.  All bools are
;; combined into one int to save space.
;; ??? We assume there is at least one bool.

(define (gen-attr-accessors prefix attrs)
  (string-append
   "/* " prefix " attribute accessor macros.  */\n"
   (string-map (lambda (attr)
		 (string-append
		  "#define CGEN_ATTR_"
		  (string-upcase prefix)
		  "_"
		  (string-upcase (gen-sym attr))
		  "_VALUE(attrs) "
		  (if (bool-attr? attr)
		      (string-append
		       "(((attrs)->bool_ & (1 << "
		       (string-upcase prefix)
		       "_"
		       (string-upcase (gen-sym attr))
		       ")) != 0)")
		      (string-append
		       "((attrs)->nonbool["
		       (string-upcase prefix)
		       "_"
		       (string-upcase (gen-sym attr))
		       "-"
		       (string-upcase prefix)
		       "_START_NBOOLS-1]."
		       (case (attr-kind attr)
			 ((bitset)
			  (if (string=? (string-downcase (gen-sym attr)) "isa")
			      ""
			      "non"))
			 (else "non"))
		       "bitset)"))
		  "\n"))
	       attrs)
   "\n")
)

;; Return C code to declare an enum of attributes ATTRS.
;; PREFIX is one of "cgen_ifld", "cgen_hw", "cgen_operand", "cgen_insn".
;; ATTRS is an alist of attribute values.  The value is unimportant except that
;; it is used to determine bool/non-bool.
;; Non-bools need to be separated from bools as they're each recorded
;; differently.  Non-bools are recorded in an int for each.  All bools are
;; combined into one int to save space.
;; ??? We assume there is at least one bool.

(define (gen-attr-enum-decl prefix attrs)
  (string-append
   (gen-enum-decl (string-append prefix "_attr")
		  (string-append prefix " attrs")
		  (string-append prefix "_")
		  (attr-list-enum-list attrs))
   "/* Number of non-boolean elements in " prefix "_attr.  */\n"
   "#define " (string-upcase prefix) "_NBOOL_ATTRS "
   "(" (string-upcase prefix) "_END_NBOOLS - "
   (string-upcase prefix) "_START_NBOOLS - 1)\n"
   "\n")
)

;; Return name of symbol ATTR-NAME.
;; PREFIX is the prefix arg to gen-attr-enum-decl.

(define (gen-attr-name prefix attr-name)
  (string-upcase (gen-c-symbol (string-append prefix "_"
					      (symbol->string attr-name))))
)

;; Normal gen-mask argument to gen-bool-attrs.
;; Returns "(1<< PREFIX_NAME)" where PREFIX is from atlist-prefix and
;; NAME is the name of the attribute.
;; ??? This used to return PREFIX_NAME-CGEN_ATTR_BOOL_OFFSET.
;; The tradeoff is simplicity vs perceived maximum number of boolean attributes
;; needed.  In the end the maximum number needn't be fixed, and the simplicity
;; of the current way is good.

(define (gen-attr-mask prefix name)
  (string-append "(1<<" (gen-attr-name prefix name) ")")
)

;; Return C expression of bitmasks of boolean attributes in ATTRS.
;; ATTRS is an <attr-list> object, it need not be pre-sorted.
;; GEN-MASK is a procedure that returns the C code of the mask.

(define (gen-bool-attrs attrs gen-mask)
  (let loop ((result "0")
	     (alist (attr-remove-meta-attrs-alist
		     (attr-nub (atlist-attrs attrs)))))
    (cond ((null? alist) result)
	  ((and (boolean? (cdar alist)) (cdar alist))
	   (loop (string-append result
				;; `|' is used here instead of `+' so we don't
				;; have to care about duplicates.
				"|" (gen-mask (atlist-prefix attrs)
					      (caar alist)))
		 (cdr alist)))
	  (else (loop result (cdr alist)))))
)

;; Return the C definition of OBJ's attributes.
;; TYPE is one of 'ifld, 'hw, 'operand, 'insn.
;; [Other objects have attributes but these are the only ones we currently
;; emit definitions for.]
;; OBJ is any object that supports the 'get-atlist message.
;; ALL-ATTRS is an ordered alist of all attributes.
;; "ordered" means all the non-boolean attributes are at the front and
;; duplicate entries have been removed.
;; GEN-MASK is the gen-mask arg to gen-bool-attrs.

(define (gen-obj-attr-defn type obj all-attrs num-non-bools gen-mask)
  (let* ((attrs (obj-atlist obj))
	 (non-bools (attr-non-bool-attrs (atlist-attrs attrs)))
	 (all-non-bools (list-take num-non-bools all-attrs)))
  (string-append
   "{ "
   (gen-bool-attrs attrs gen-mask)
   ", {"
   ;; For the boolean case, we can (currently) get away with only specifying
   ;; the attributes that are used since they all fit in one int and the
   ;; default is currently always #f (and won't be changed without good
   ;; reason).  In the non-boolean case order is important since each value
   ;; has a specific spot in an array, all of them must be specified.
   (if (null? all-non-bools)
       " 0"
       (string-drop1 ;; drop the leading ","
	(string-map (lambda (attr)
		      (let ((val (or (assq-ref non-bools (obj:name attr))
				     (attr-default attr))))
			;; FIXME: Are we missing attr-prefix here?
			(string-append ", "
				       (send attr 'gen-value-for-defn val))))
		    all-non-bools)))
   " } }"
   ))
)

;; Return the C definition of the terminating entry of an object's attributes.
;; ALL-ATTRS is an ordered alist of all attributes.
;; "ordered" means all the non-boolean attributes are at the front and
;; duplicate entries have been removed.

(define (gen-obj-attr-end-defn all-attrs num-non-bools)
  (let ((all-non-bools (list-take num-non-bools all-attrs)))
    (string-append
     "{ 0, {"
     (if (null? all-non-bools)
	 " { 0, 0 }"
	 (string-drop1 ;; drop the leading ","
	  (string-map (lambda (attr)
			(let ((val (attr-default attr)))
			  ;; FIXME: Are we missing attr-prefix here?
			  (string-append ", "
					 (send attr 'gen-value-for-defn val))))
		      all-non-bools)))
     " } }"
     ))
)

;; Return a boolean indicating if ATLIST indicates a CTI insn.

(define (atlist-cti? atlist)
  (or (atlist-has-attr? atlist 'UNCOND-CTI)
      (atlist-has-attr? atlist 'COND-CTI))
)

;; Misc. gen-* procs

;; Return name of obj as a C symbol.

(define (gen-sym obj) (gen-c-symbol (obj:name obj)))

;; Return the name of the selected cpu family.
;; An error is signalled if more than one has been selected.

(define (gen-cpu-name)
  ;; FIXME: error checking
  (gen-sym (current-cpu))
)

;; Return HAVE_CPU_<CPU>.

(define (gen-have-cpu cpu)
  (string-append "HAVE_CPU_"
		 (string-upcase (gen-sym cpu)))
)

;; Return the bfd mach name for MACH.

(define (gen-mach-bfd-name mach)
  (string-append "bfd_mach_" (gen-c-symbol (mach-bfd-name mach)))
)

;; Return definition of C macro to get the value of SYM.
;; INDEX-ARGS, EXPR must not have any newlines.

(define (gen-get-macro sym index-args expr)
  (string-append
   "#define GET_" (string-upcase sym) "(" index-args ") " expr "\n")
)

;; Return definition of C macro to get the value of SYM, version 2.
;; EXPR is a C expression *without* proper \newline handling,
;; we prepend \ to each line.
;; INDEX-ARGS, EXPR must not have any newlines.

(define (gen-get-macro2 sym index-args expr)
  (string-append
   "#define GET_" (string-upcase sym) "(" index-args ") "
   (backslash "\n" expr)
   "\n")
)

;; Return definition of C macro to set the value of SYM.
;; INDEX-ARGS, EXPR, LVALUE must not have any newlines.

(define (gen-set-macro sym index-args lvalue)
  (string-append
   "#define SET_" (string-upcase sym)
   "(" index-args
   (if (equal? index-args "") "" ", ")
   "x) (" lvalue " = (x))\n")
)

;; Return definition of C macro to set the value of SYM, version 2.
;; EXPR is one or more C statements *without* proper \newline handling,
;; we prepend \ to each line.
;; INDEX-ARGS, NEWVAL-ARG must not have any newlines.

(define (gen-set-macro2 sym index-args newval-arg expr)
  (string-append
   "#define SET_" (string-upcase sym)
   "(" index-args
   (if (equal? index-args "") "" ", ")
   newval-arg ") \\\n"
   "do { \\\n"
   (backslash "\n" expr)
   ";} while (0)\n")
)

;; Misc. object utilities.

;; Return the nub of a list of objects.

(define (obj-list-nub obj-list)
  (nub obj-list obj:name)
)

;; Sort a list of objects with get-name methods alphabetically.

(define (alpha-sort-obj-list l)
  (sort l
	(lambda (o1 o2)
	  (symbol<? (obj:name o1) (obj:name o2))))
)

;; Called before loading the .cpu file to initialize.

(define (utils-init!)
  (reader-add-command! 'sanitize
		       "\
Mark an entry as being sanitized.
"
		       nil '(keyword entry-type . entry-names) sanitize)

  *UNSPECIFIED*
)

;; Return the definition of a C macro that concatenates its argument symbols.

(define (gen-define-with-symcat head . args)
  (string-append
   "#define "
   head
   (string-map (lambda (elm) (string-append "##" elm)) args)
   "\n")
)
@


1.28
log
@update copyright year
@
text
@d713 1
a713 1
		       "(((attrs)->bool & (1 << "
@


1.27
log
@	* desc-cpu.scm (/gen-cpu-open): Remove comment on K&R support.
	* utils-cgen.scm (gen-define-with-symcat): Remove K&R support.

	* utils-sim.scm (compute-sformat-argbufs!): Use more consistent name
	for name of empty sbuf.

	* iformat.scm (/sfmt-search-key, /ifmt-lookup-sfmt!): Add assert.

	* insn.scm (<insn>): Add initial value for members fmt-desc, ifmt,
	sfmt, tmp.
	(/sub-insn-ifields): Delete old commented out code.
	(/sub-insn-make!, /parse-insn-format-symbol): Ditto.
	* operand.scm (/anyof-merge-setter, anyof-merge-semantics): Ditto.

	* sim-decode.scm (/gen-decode-insn-globals): Tweak formatting of
	generated code.
@
text
@d2 1
a2 1
;; Copyright (C) 2000, 2002, 2003, 2009 Red Hat, Inc.
@


1.26
log
@	* utils-cgen.scm (<location>): Define using new define-class.
	(<ident>, <source-ident>, <context>): Ditto.

	* cos.scm (/object-string): New function.
	(/object-error): Use it.
	(/object-count-true): New function
	(object-copy-top): Delete.  All callers changed to call object-copy.
	(/parse-member-list, /build-getter-defs, /build-setter-defs): New fns.
	(define-class, define-interface, define-method): New macros.
	(define-getters, define-setters, vmake): Moved here ...
	* utils-cgen.scm: ... from here.
@
text
@d967 1
a967 6
;; Return a pair of definitions for a C macro that concatenates its
;; argument symbols.  The definitions are conditional on ANSI C
;; semantics: one contains ANSI concat operators (##), and the other
;; uses the empty-comment trick (/**/).  We must do this, rather than
;; use CONCATn(...) as defined in include/symcat.h, in order to avoid
;; spuriously expanding our macro's args.
d971 4
a974 12
   "\
#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
#define "
   head (string-map (lambda (elm) (string-append "##" elm)) args)
   "
#else
#define "
   head (string-map (lambda (elm) (string-append "/**/" elm)) args)
   "
#endif
"
   )
@


1.25
log
@whitespace fixes in previous patch
@
text
@a28 41
;; COS utilities.
;; Perhaps these should be provided with cos (cgen-object-system), but for
;; now they live here.

;; Define the getter for a list of elements of a class.

(defmacro define-getters (class class-prefix elm-names)
  (cons 'begin
	(map (lambda (elm-name)
	       (if (pair? elm-name)
		   `(define ,(symbol-append class-prefix '- (cdr elm-name))
		      (elm-make-getter ,class (quote ,(car elm-name))))
		   `(define ,(symbol-append class-prefix '- elm-name)
		      (elm-make-getter ,class (quote ,elm-name)))))
	     elm-names))
)

;; Define the setter for a list of elements of a class.

(defmacro define-setters (class class-prefix elm-names)
  (cons 'begin
	(map (lambda (elm-name)
	       (if (pair? elm-name)
		   `(define ,(symbol-append class-prefix '-set- (cdr elm-name) '!)
		      (elm-make-setter ,class (quote ,(car elm-name))))
		   `(define ,(symbol-append class-prefix '-set- elm-name '!)
		      (elm-make-setter ,class (quote ,elm-name)))))
	     elm-names))
)

;; Make an object, specifying values for particular elements.
;; ??? Eventually move to cos.scm/cos.c.

(define (vmake class . args)
  (let ((obj (new class)))
    (let ((unrecognized (send obj 'vmake! args)))
      (if (null? unrecognized)
	  obj
	  (error "vmake: unknown options:" unrecognized))))
)

d32 7
a38 11
(define <location> (class-make '<location>
			       nil
			       '(
				 ;; A list of "single-location" objects,
				 ;; sorted by most recent location first.
				 list
				 )
			       nil))

(define-getters <location> location (list))
(define-setters <location> location (list))
d169 1
a169 12
(define <ident> (class-make '<ident> '() '(name comment attrs) '()))

(method-make! <ident> 'get-name (lambda (self) (elm-get self 'name)))
(method-make! <ident> 'get-comment (lambda (self) (elm-get self 'comment)))
(method-make! <ident> 'get-atlist (lambda (self) (elm-get self 'attrs)))

(method-make! <ident> 'set-name!
	      (lambda (self newval) (elm-set! self 'name newval)))
(method-make! <ident> 'set-comment!
	      (lambda (self newval) (elm-set! self 'comment newval)))
(method-make! <ident> 'set-atlist!
	      (lambda (self newval) (elm-set! self 'attrs newval)))
d171 1
a171 1
;; All objects defined in the .cpu file have these elements.
d173 1
a173 1
;; Additionally most objects have `name', `comment' and `attrs' elements.
d175 40
a214 3
(define (obj:name obj) (send obj 'get-name))
(define (obj-set-name! obj name) (send obj 'set-name! name))
(define (obj:comment obj) (send obj 'get-comment))
d242 8
a249 23
(define <source-ident>
  (class-make '<source-ident> '(<ident>)
	      '(
		;; A <location> object.
		(location . #f)
		;; #f for ordinal means "unassigned"
		(ordinal . #f)
		)
	      '()))

(method-make! <source-ident> 'get-location
	      (lambda (self) (elm-get self 'location)))
(method-make! <source-ident> 'set-location!
	      (lambda (self newval) (elm-set! self 'location newval)))
(define (obj-location obj) (send obj 'get-location))
(define (obj-set-location! obj location) (send obj 'set-location! location))

(method-make! <source-ident> 'get-ordinal
	      (lambda (self) (elm-get self 'ordinal)))
(method-make! <source-ident> 'set-ordinal!
	      (lambda (self newval) (elm-set! self 'ordinal newval)))
(define (obj-ordinal obj) (send obj 'get-ordinal))
(define (obj-set-ordinal! obj ordinal) (send obj 'set-ordinal! ordinal))
d251 2
a252 1
;; Return a boolean indicating if X is a <source-ident>.
d254 12
a265 1
(define (source-ident? x) (class-instance? <source-ident> x))
d272 8
a279 10
(define <context>
  (class-make '<context> nil
	      '(
		;; Location of the object being processed,
		;; or #f if unknown (or there is none).
		(location . #f)
		;; Error message prefix or #f if there is none.
		(prefix . #f)
		)
	      nil)
a281 4
;; Accessors.

(define-getters <context> context (location prefix))

d737 1
@


1.24
log
@* utils-cgen.scm: Follow commenting convention.
@
text
@d1 4
a4 4
;;CGEN Utilities.
;;Copyright (C) 2000, 2002, 2003, 2009 Red Hat, Inc.
;;This file is part of CGEN.
;;See file COPYING.CGEN for details.
d6 2
a7 2
;;This file contains utilities specific to cgen.
;;Generic utilities should go in utils.scm.
d9 2
a10 2
;;True if text of sanitize markers are to be emitted.
;;This is a debugging tool only, though it could have use in sanitized trees.
d13 1
a13 1
;;Utility to display command line invocation for debugging purposes.
d29 3
a31 3
;;COS utilities.
;;Perhaps these should be provided with cos (cgen-object-system), but for
;;now they live here.
d33 1
a33 1
;;Define the getter for a list of elements of a class.
d46 1
a46 1
;;Define the setter for a list of elements of a class.
d59 2
a60 2
;;Make an object, specifying values for particular elements.
;;??? Eventually move to cos.scm/cos.c.
d70 2
a71 2
;;; Source locations are recorded as a stack, with (ideally) one extra level
;;; for each macro invocation.
d85 4
a88 4
;;; A single source location.
;;; This is recorded as a vector for simplicity.
;;; END? is true if the location marks the end of the expression.
;;; NOTE: LINE and COLUMN are origin-0 (the first line is line 0).
d99 1
a99 1
;;; Return a single-location in a readable form.
d111 2
a112 2
;;; Same as single-location->string, except omit any directory info in
;;; the file name.
d124 1
a124 1
;;; Return a location in a readable form.
d140 2
a141 2
;;; Return the location information in Guile's source-properties
;;; in a readable form.
d154 1
a154 1
;;; Return the top location on LOC's stack.
d160 1
a160 1
;;; Return a new <location> with FILE, LINE pushed onto the stack.
d167 1
a167 1
;;; Return a new <location> with NEW-LOC preappended to LOC.
d174 4
a177 4
;;; Return an unspecified <location>.
;;; This is mainly for use in debugging utilities.
;;; Ideally for .cpu-file related stuff we always have a location,
;;; but that's not always true.
d183 1
a183 1
;;; Return a location denoting a builtin object.
d189 2
a190 2
;;; Return a <location> object for the current input port.
;;; END? is true if the location marks the end of the expression.
d200 1
a200 1
;;; An object property for tracking source locations during macro expansion.
d204 1
a204 1
;;; Set FORM's location to LOC.
d211 2
a212 2
;;Each named entry in the description file typically has these three members:
;;name, comment attrs.
d227 3
a229 3
;;All objects defined in the .cpu file have these elements.
;;Where in the class hierarchy they're recorded depends on the object.
;;Additionally most objects have `name', `comment' and `attrs' elements.
d235 1
a235 1
;;Utility to return the name as a string.
d249 1
a249 1
;;Subclass of <ident> for use by description file objects.
d251 1
a251 1
;;Records the source location of the object.
d253 7
a259 7
;;We also record an internally generated entry, ordinal, to record the
;;relative position within the description file.  It's generally more efficient
;;to record some kinds of objects (e.g. insns) in a hash table.  But we also
;;want to emit these objects in file order.  Recording the object's relative
;;position lets us generate an ordered list when we need to.
;;We can't just use the line number because we want an ordering over multiple
;;input files.
d285 1
a285 1
;;Return a boolean indicating if X is a <source-ident>.
d289 1
a289 1
;;Parsing utilities
d291 2
a292 2
;;; A parsing/processing context, used to give better error messages.
;;; LOCATION must be an object created with make-location.
d306 1
a306 1
;;Accessors.
d310 1
a310 1
;;Create a <context> object that is just a prefix.
d316 1
a316 1
;;Create a <context> object that (current-reader-location) with PREFIX.
d322 1
a322 1
;;Create a <context> object from <source-ident> object OBJ.
d328 1
a328 1
;;Create a new context from CONTEXT with TEXT appended to the prefix.
d335 1
a335 1
;;Create a new context from CONTEXT with NAME appended to the prefix.
d341 5
a345 5
;;Call this to issue an error message when all you have is a context.
;;CONTEXT is a <context> object or #f if there is none.
;;INTRO is a general introduction to what cgen was doing.
;;ERRMSG is, yes, you guessed it, the error message.
;;EXPR is the value that had the error if there is one.
d355 8
a362 8
;;Call this to issue an error message when you have a context and an
;;<ident> or <source-ident> object (we call the "owner").
;;CONTEXT is a <context> object or #f if there is none.
;;OWNER is an <ident> or <source-ident> object or #f if there is none.
;;INTRO is a general introduction to what cgen was doing.
;;  If OWNER is non-#f, the text " of <object-name>" is appended.
;;ERRMSG is, yes, you guessed it, the error message.
;;EXPR is the value that had the error if there is one.
d407 5
a411 5
;;Parse an object name.
;;NAME is either a symbol or a list of symbols which are concatenated
;;together.  Each element can in turn be a list of symbols, and so on.
;;This supports symbol concatenation in the description file without having
;;to using string-append or some such.
d424 3
a426 3
;;Parse an object comment.
;;COMMENT is either a string or a list of strings, each element of which may
;;in turn be a list of strings.
d437 1
a437 1
;;Parse a symbol.
d445 1
a445 1
;;Parse a string.
d453 2
a454 2
;;Parse a number.
;;VALID-VALUES is a list of numbers and (min . max) pairs.
d469 1
a469 1
;;Parse a boolean value
d477 7
a483 7
;;Parse a list of handlers.
;;Each entry is (symbol "string").
;;These map function to a handler for it.
;;The meaning is up to the application but generally the handler is a
;;C/C++ function name.
;;ALLOWED is a list valid values for the symbol or #f if anything is allowed.
;;The result is handlers unchanged.
d497 4
a500 4
;;Return a boolean indicating if X is a keyword.
;;This also handles symbols named :foo because Guile doesn't stablely support
;;:keywords (how does one enable :keywords? read-options doesn't appear to
;;work).
d510 6
a515 6
;;Convert a list like (#:key1 val1 #:key2 val2 ...) to
;;((#:key1 val1) (#:key2 val2) ...).
;;Missing values are specified with an empty list.
;;This also supports (:sym1 val1 ...) because Guile doesn't stablely support
;;:keywords (#:keywords work, but #:foo shouldn't appear in the description
;;language).
d539 3
a541 3
;;Signal an error if the argument name is not a symbol.
;;This is done by each of the argument validation routines so the caller
;;doesn't need to make two calls.
d551 2
a552 2
;;Signal a parse error if an argument was specified with a value.
;;ARG-SPEC is (name value).
d562 2
a563 2
;;Validate and return a symbol argument.
;;ARG-SPEC is (name value).
d574 1
a574 1
;;Sanitization
d576 7
a582 7
;;Sanitization is handled via attributes.  Anything that must be sanitized
;;has a `sanitize' attribute with the value being the keyword to sanitize on.
;;Ideally most, if not all, of the guts of the generated sanitization is here.

;;Utility to simplify expression in .cpu file.
;;Usage: (sanitize isa-name-list keyword entry-type entry-name1 [entry-name2 ...])
;;Enum attribute `(sanitize keyword)' is added to the entry.
d634 4
a637 4
;;Return TEXT sanitized with KEYWORD.
;;TEXT must exist on a line (or lines) by itself.
;;i.e. it is assumed that it begins at column 1 and ends with a newline.
;;If KEYWORD is #f, no sanitization is generated.
d665 2
a666 2
;;Return TEXT sanitized with OBJ's sanitization, if it has any.
;;OBJ may be #f.
d676 2
a677 2
;;Cover procs to handle generation of object declarations and definitions.
;;All object output should be routed through gen-decl and gen-defn.
d679 1
a679 1
;;Send the gen-decl message to OBJ, and sanitize the output if necessary.
d692 1
a692 1
;;Send the gen-defn message to OBJ, and sanitize the output if necessary.
d705 1
a705 1
;;Attributes
d707 1
a707 1
;;Return the C/C++ type to use to hold a value for attribute ATTR.
d720 8
a727 8
;;Return C macros for accessing an object's attributes ATTRS.
;;PREFIX is one of "cgen_ifld", "cgen_hw", "cgen_operand", "cgen_insn".
;;ATTRS is an alist of attribute values.  The value is unimportant except that
;;it is used to determine bool/non-bool.
;;Non-bools need to be separated from bools as they're each recorded
;;differently.  Non-bools are recorded in an int for each.  All bools are
;;combined into one int to save space.
;;??? We assume there is at least one bool.
d765 8
a772 8
;;Return C code to declare an enum of attributes ATTRS.
;;PREFIX is one of "cgen_ifld", "cgen_hw", "cgen_operand", "cgen_insn".
;;ATTRS is an alist of attribute values.  The value is unimportant except that
;;it is used to determine bool/non-bool.
;;Non-bools need to be separated from bools as they're each recorded
;;differently.  Non-bools are recorded in an int for each.  All bools are
;;combined into one int to save space.
;;??? We assume there is at least one bool.
d787 2
a788 2
;;Return name of symbol ATTR-NAME.
;;PREFIX is the prefix arg to gen-attr-enum-decl.
d795 7
a801 7
;;Normal gen-mask argument to gen-bool-attrs.
;;Returns "(1<< PREFIX_NAME)" where PREFIX is from atlist-prefix and
;;NAME is the name of the attribute.
;;??? This used to return PREFIX_NAME-CGEN_ATTR_BOOL_OFFSET.
;;The tradeoff is simplicity vs perceived maximum number of boolean attributes
;;needed.  In the end the maximum number needn't be fixed, and the simplicity
;;of the current way is good.
d807 3
a809 3
;;Return C expression of bitmasks of boolean attributes in ATTRS.
;;ATTRS is an <attr-list> object, it need not be pre-sorted.
;;GEN-MASK is a procedure that returns the C code of the mask.
d826 9
a834 9
;;Return the C definition of OBJ's attributes.
;;TYPE is one of 'ifld, 'hw, 'operand, 'insn.
;;[Other objects have attributes but these are the only ones we currently
;;emit definitions for.]
;;OBJ is any object that supports the 'get-atlist message.
;;ALL-ATTRS is an ordered alist of all attributes.
;;"ordered" means all the non-boolean attributes are at the front and
;;duplicate entries have been removed.
;;GEN-MASK is the gen-mask arg to gen-bool-attrs.
d863 4
a866 4
;;Return the C definition of the terminating entry of an object's attributes.
;;ALL-ATTRS is an ordered alist of all attributes.
;;"ordered" means all the non-boolean attributes are at the front and
;;duplicate entries have been removed.
d885 1
a885 1
;;Return a boolean indicating if ATLIST indicates a CTI insn.
d892 1
a892 1
;;Misc. gen-* procs
d894 1
a894 1
;;Return name of obj as a C symbol.
d898 2
a899 2
;;Return the name of the selected cpu family.
;;An error is signalled if more than one has been selected.
d906 1
a906 1
;;Return HAVE_CPU_<CPU>.
d913 1
a913 1
;;Return the bfd mach name for MACH.
d982 1
a982 1
;;Called before loading the .cpu file to initialize.
d994 6
a999 6
;;Return a pair of definitions for a C macro that concatenates its
;;argument symbols.  The definitions are conditional on ANSI C
;;semantics: one contains ANSI concat operators (##), and the other
;;uses the empty-comment trick (/**/).  We must do this, rather than
;;use CONCATn(...) as defined in include/symcat.h, in order to avoid
;;spuriously expanding our macro's args.
@


1.23
log
@	* insn.scm (/parse-insn-format): Watch for duplicate ifields.
	* read.scm (parse-error-continuable): New function.
	(define /continuable-error-found?): New variable.
	(/init-reader!): Initialize it.
	(/finish-reader!): New function.
	(cpu-load): Call it.
	* utils-cgen.scm (obj-list-nub): New function.
@
text
@d1 7
a7 7
; CGEN Utilities.
; Copyright (C) 2000, 2002, 2003, 2009 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.
;
; This file contains utilities specific to cgen.
; Generic utilities should go in utils.scm.
d9 2
a10 2
; True if text of sanitize markers are to be emitted.
; This is a debugging tool only, though it could have use in sanitized trees.
d13 1
a13 1
; Utility to display command line invocation for debugging purposes.
d19 2
a20 2
		; Output double-quotes if string has a space for better
		; correspondence to how to specify string to shell.
d29 3
a31 3
; COS utilities.
; Perhaps these should be provided with cos (cgen-object-system), but for
; now they live here.
d33 1
a33 1
; Define the getter for a list of elements of a class.
d46 1
a46 1
; Define the setter for a list of elements of a class.
d59 2
a60 2
; Make an object, specifying values for particular elements.
; ??? Eventually move to cos.scm/cos.c.
d211 2
a212 2
; Each named entry in the description file typically has these three members:
; name, comment attrs.
d227 3
a229 3
; All objects defined in the .cpu file have these elements.
; Where in the class hierarchy they're recorded depends on the object.
; Additionally most objects have `name', `comment' and `attrs' elements.
d235 1
a235 1
; Utility to return the name as a string.
d249 11
a259 11
; Subclass of <ident> for use by description file objects.
;
; Records the source location of the object.
;
; We also record an internally generated entry, ordinal, to record the
; relative position within the description file.  It's generally more efficient
; to record some kinds of objects (e.g. insns) in a hash table.  But we also
; want to emit these objects in file order.  Recording the object's relative
; position lets us generate an ordered list when we need to.
; We can't just use the line number because we want an ordering over multiple
; input files.
d285 1
a285 1
; Return a boolean indicating if X is a <source-ident>.
d289 1
a289 1
; Parsing utilities
d306 1
a306 1
; Accessors.
d310 1
a310 1
; Create a <context> object that is just a prefix.
d316 1
a316 1
; Create a <context> object that (current-reader-location) with PREFIX.
d322 1
a322 1
; Create a <context> object from <source-ident> object OBJ.
d328 1
a328 1
; Create a new context from CONTEXT with TEXT appended to the prefix.
d335 1
a335 1
; Create a new context from CONTEXT with NAME appended to the prefix.
d341 5
a345 5
; Call this to issue an error message when all you have is a context.
; CONTEXT is a <context> object or #f if there is none.
; INTRO is a general introduction to what cgen was doing.
; ERRMSG is, yes, you guessed it, the error message.
; EXPR is the value that had the error if there is one.
d355 8
a362 8
; Call this to issue an error message when you have a context and an
; <ident> or <source-ident> object (we call the "owner").
; CONTEXT is a <context> object or #f if there is none.
; OWNER is an <ident> or <source-ident> object or #f if there is none.
; INTRO is a general introduction to what cgen was doing.
;   If OWNER is non-#f, the text " of <object-name>" is appended.
; ERRMSG is, yes, you guessed it, the error message.
; EXPR is the value that had the error if there is one.
d407 5
a411 5
; Parse an object name.
; NAME is either a symbol or a list of symbols which are concatenated
; together.  Each element can in turn be a list of symbols, and so on.
; This supports symbol concatenation in the description file without having
; to using string-append or some such.
d424 3
a426 3
; Parse an object comment.
; COMMENT is either a string or a list of strings, each element of which may
; in turn be a list of strings.
d437 1
a437 1
; Parse a symbol.
d445 1
a445 1
; Parse a string.
d453 2
a454 2
; Parse a number.
; VALID-VALUES is a list of numbers and (min . max) pairs.
d469 1
a469 1
; Parse a boolean value
d477 7
a483 7
; Parse a list of handlers.
; Each entry is (symbol "string").
; These map function to a handler for it.
; The meaning is up to the application but generally the handler is a
; C/C++ function name.
; ALLOWED is a list valid values for the symbol or #f if anything is allowed.
; The result is handlers unchanged.
d497 4
a500 4
; Return a boolean indicating if X is a keyword.
; This also handles symbols named :foo because Guile doesn't stablely support
; :keywords (how does one enable :keywords? read-options doesn't appear to
; work).
d510 6
a515 6
; Convert a list like (#:key1 val1 #:key2 val2 ...) to
; ((#:key1 val1) (#:key2 val2) ...).
; Missing values are specified with an empty list.
; This also supports (:sym1 val1 ...) because Guile doesn't stablely support
; :keywords (#:keywords work, but #:foo shouldn't appear in the description
; language).
d518 1
a518 1
  ; Scan KL backwards, building up each element as we go.
d539 3
a541 3
; Signal an error if the argument name is not a symbol.
; This is done by each of the argument validation routines so the caller
; doesn't need to make two calls.
d551 2
a552 2
; Signal a parse error if an argument was specified with a value.
; ARG-SPEC is (name value).
d562 2
a563 2
; Validate and return a symbol argument.
; ARG-SPEC is (name value).
d574 1
a574 1
; Sanitization
d576 7
a582 7
; Sanitization is handled via attributes.  Anything that must be sanitized
; has a `sanitize' attribute with the value being the keyword to sanitize on.
; Ideally most, if not all, of the guts of the generated sanitization is here.

; Utility to simplify expression in .cpu file.
; Usage: (sanitize isa-name-list keyword entry-type entry-name1 [entry-name2 ...])
; Enum attribute `(sanitize keyword)' is added to the entry.
d602 4
a605 4
		; ENTRY is #f in the case where the element was discarded
		; because its mach wasn't selected.  But in the case where
		; we're keeping everything, ensure ENTRY is not #f to
		; catch spelling errors.
d611 2
a612 2
		      ; Propagate the sanitize attribute to class members
		      ; as necessary.
d631 1
a631 1
  #f ; caller eval's our result, so return a no-op
d634 4
a637 4
; Return TEXT sanitized with KEYWORD.
; TEXT must exist on a line (or lines) by itself.
; i.e. it is assumed that it begins at column 1 and ends with a newline.
; If KEYWORD is #f, no sanitization is generated.
d641 1
a641 1
	((pair? text) ; pair? -> cheap list?
d644 1
a644 1
	      ; split string to avoid removal
d656 1
a656 1
		  ; split string to avoid removal
d665 2
a666 2
; Return TEXT sanitized with OBJ's sanitization, if it has any.
; OBJ may be #f.
d676 2
a677 2
; Cover procs to handle generation of object declarations and definitions.
; All object output should be routed through gen-decl and gen-defn.
d679 1
a679 1
; Send the gen-decl message to OBJ, and sanitize the output if necessary.
d692 1
a692 1
; Send the gen-defn message to OBJ, and sanitize the output if necessary.
d705 1
a705 1
; Attributes
d707 1
a707 1
; Return the C/C++ type to use to hold a value for attribute ATTR.
d720 8
a727 8
; Return C macros for accessing an object's attributes ATTRS.
; PREFIX is one of "cgen_ifld", "cgen_hw", "cgen_operand", "cgen_insn".
; ATTRS is an alist of attribute values.  The value is unimportant except that
; it is used to determine bool/non-bool.
; Non-bools need to be separated from bools as they're each recorded
; differently.  Non-bools are recorded in an int for each.  All bools are
; combined into one int to save space.
; ??? We assume there is at least one bool.
d765 8
a772 8
; Return C code to declare an enum of attributes ATTRS.
; PREFIX is one of "cgen_ifld", "cgen_hw", "cgen_operand", "cgen_insn".
; ATTRS is an alist of attribute values.  The value is unimportant except that
; it is used to determine bool/non-bool.
; Non-bools need to be separated from bools as they're each recorded
; differently.  Non-bools are recorded in an int for each.  All bools are
; combined into one int to save space.
; ??? We assume there is at least one bool.
d787 2
a788 2
; Return name of symbol ATTR-NAME.
; PREFIX is the prefix arg to gen-attr-enum-decl.
d795 7
a801 7
; Normal gen-mask argument to gen-bool-attrs.
; Returns "(1<< PREFIX_NAME)" where PREFIX is from atlist-prefix and
; NAME is the name of the attribute.
; ??? This used to return PREFIX_NAME-CGEN_ATTR_BOOL_OFFSET.
; The tradeoff is simplicity vs perceived maximum number of boolean attributes
; needed.  In the end the maximum number needn't be fixed, and the simplicity
; of the current way is good.
d807 3
a809 3
; Return C expression of bitmasks of boolean attributes in ATTRS.
; ATTRS is an <attr-list> object, it need not be pre-sorted.
; GEN-MASK is a procedure that returns the C code of the mask.
d818 2
a819 2
				; `|' is used here instead of `+' so we don't
				; have to care about duplicates.
d826 9
a834 9
; Return the C definition of OBJ's attributes.
; TYPE is one of 'ifld, 'hw, 'operand, 'insn.
; [Other objects have attributes but these are the only ones we currently
; emit definitions for.]
; OBJ is any object that supports the 'get-atlist message.
; ALL-ATTRS is an ordered alist of all attributes.
; "ordered" means all the non-boolean attributes are at the front and
; duplicate entries have been removed.
; GEN-MASK is the gen-mask arg to gen-bool-attrs.
d844 5
a848 5
   ; For the boolean case, we can (currently) get away with only specifying
   ; the attributes that are used since they all fit in one int and the
   ; default is currently always #f (and won't be changed without good
   ; reason).  In the non-boolean case order is important since each value
   ; has a specific spot in an array, all of them must be specified.
d851 1
a851 1
       (string-drop1 ; drop the leading ","
d855 1
a855 1
			; FIXME: Are we missing attr-prefix here?
d863 4
a866 4
; Return the C definition of the terminating entry of an object's attributes.
; ALL-ATTRS is an ordered alist of all attributes.
; "ordered" means all the non-boolean attributes are at the front and
; duplicate entries have been removed.
d874 1
a874 1
	 (string-drop1 ; drop the leading ","
d877 1
a877 1
					; FIXME: Are we missing attr-prefix here?
d885 1
a885 1
; Return a boolean indicating if ATLIST indicates a CTI insn.
d892 1
a892 1
; Misc. gen-* procs
d894 1
a894 1
; Return name of obj as a C symbol.
d898 2
a899 2
; Return the name of the selected cpu family.
; An error is signalled if more than one has been selected.
d902 1
a902 1
  ; FIXME: error checking
d906 1
a906 1
; Return HAVE_CPU_<CPU>.
d913 1
a913 1
; Return the bfd mach name for MACH.
d982 1
a982 1
; Called before loading the .cpu file to initialize.
d994 6
a999 6
; Return a pair of definitions for a C macro that concatenates its
; argument symbols.  The definitions are conditional on ANSI C
; semantics: one contains ANSI concat operators (##), and the other
; uses the empty-comment trick (/**/).  We must do this, rather than
; use CONCATn(...) as defined in include/symcat.h, in order to avoid
; spuriously expanding our macro's args.
@


1.22
log
@	* utils-cgen.scm (gen-set-macro2): New function.
	* sim.scm (<hw-register> gen-get-macro): Call it.
@
text
@d884 1
d966 7
a972 1
; Misc. object utilities.
d974 1
a974 1
; Sort a list of objects with get-name methods alphabetically.
@


1.21
log
@	Specify isa(s) when doing ifield, operand, insn lookups.
	ACU = all callers updated.
	* attr.scm (/attr-eval): Call rtx-value instead of rtx-eval-with-estate.
	* enum.scm (define-full-insn-enum): Pass isa-name-list to
	current-ifld-lookup.
	* html.scm (get-insn-properties): Pass isa-name-list to
	current-op-lookup.
	* ifield.scm (/ifld-parse-follows): New arg isas, ACU.
	* insn.scm (/parse-insn-format-symbol): New arg isa-name-list, ACU.
	(/parse-insn-format-list, /parse-insn-iformat-iflds): Ditto.
	(/parse-insn-format, syntax-break-out): Ditto.
	* mach.scm (obj-filter-by-isa): New function.
	(current-ifld-lookup): New optional arg maybe-isa-name-list.
	(/ifld-already-defined?, /op-already-defined?): Simplify.
	(current-op-lookup): New optional arg maybe-isa-name-list.
	(current-insn-lookup): New arg isa-name-list, ACU.
	(/insn-already-defined?, /minsn-already-defined?): Simplify.
	(current-minsn-lookup): New arg isa-name-list, ACU.
	* minsn.scm (/minsn-compute-iflds): Pass isa-name-list to
	current-op-lookup.
	* opc-itab.scm (compute-syntax): New arg isa-name-list, ACU.
	(gen-syntax-entry): Ditto.
	* operand.scm (/operand-parse): Pass isa-name-list to
	current-ifld-lookup.
	(/derived-parse-encoding): New arg isa-name-list, ACU.
	(/derived-parse-ifield-assertion): Ditto.
	(/derived-operand-parse): Pass isa-name-list to current-op-lookup.
	(/anyof-parse-choice): Ditto.
	(anyof-satisfies-assertions?): Pass context to rtx-solve.
	(/anyof-merge-syntax): New arg container, ACU.
	(operand-builtin!): Add pc to all isas.
	* rtl-c.scm (estate-make-for-rtl-c): Delete arg extra-vars-alist, ACU.
	(estate-make-for-rtl-c++, rtl-c-expr-parsed): Ditto.
	(rtl-c-parsed, rtl-c++-parsed): Ditto.
	(rtl-c): New arg isa-name-list, ACU.
	(rtl-c-expr, rtl-c++): Ditto.
	(closure): New arg isa-name-list, ACU.
	* rtl-traverse.scm (/make-cstate): New arg isa-name-list, ACU.
	(/cstate-isas): New function.
	(/rtx-canon-symbol-list): New function.
	(/rtx-canon-env-stack): Renamed from /rtx-canon-env, ACU.
	updated.
	(/rtx-make-canon-table): Rename ENV to ENVSTACK, new entry SYMBOLLIST.
	(/rtx-canon-rtx-operand): Pass isa list to current-op-lookup.
	(/rtx-canon-rtx-ref, /rtx-canon): Ditto.
	(rtx-canonicalize): New arg isa-name-list, ACU.
	(rtx-canonicalize-stmt): Delete.
	(tstate-make): New arg isas, ACU.
	(tstate-isas, tstate--set-isas!): New functions.
	(tstate-env-stack): Renamed from tstate-env, ACU.
	(tstate-set-env-stack!): Renamed from tstate-set-env!, ACU.
	(tstate-make-closure): Renamed from tstate-new-env, new arg
	isa-name-list, ACU.
	(/rtx-traverse-env): Delete.
	(/rtx-make-traverser-table): Rename ENV to ENVSTACK, new entry
	SUMBOLLIST.
	(/rtx-traverse): Include conditional flag in dump output.
	Update isa,envstack for closures.  Pass isa list to current-op-lookup.
	(<eval-state>): New member isas.  Rename env to env-stack.
	(<eval-state> vmake!): Handle #:isas.  #:env renamed to #:env-stack.
	(<eval-state>): New getter/setter for isas.  Rename env getter/setter
	to env-stack.
	(estate-make-for-eval): Provide #:isas.
	(estate-make-closure): Renamed from estate-new-env.  New arg
	isa-name-list, ACU.
	* rtl-xform.scm (/rtx-simplify-expr-fn): Handle closures.
	(/rtx-trim-args): ENV renamed to ENVSTACK.  Ad ITERATION, SYMBOLLIST.
	(/rtx-trim-for-doc): Handle closures.
	* rtl.scm (/rtx-valid-types): Rename ENV to ENVSTACK.  Add ITERATION,
	SYMBOLLIST.
	(rtx-env-var-list): Delete.
	(rtx-env-make): Handle already-compiled environments.
	(rtx-var-alist-to-env): New function.
	(rtx-var-alist-to-closure-env-stack, rtx-make-env-stack): New functions.
	(rtx-env-stack-dump): Renamed from rtx-env-dump, ACU.
	(rtx-operand-obj): New arg isa-name-list, ACU.
	(rtx-closure-isas, rtx-closure-env-stack, rtx-closure-expr): New
	functions.
	* rtx-funcs.scm (closure): New arg isa-name-list, reorder args, ACU.
	* sem-frags.scm (<sfrag>): Delete member compiled-semantics.
	(/frag-compute-desired-frags): Minor simplification.
	(/frag-pick-best): Ditto.
	* sid-cpu.scm (gen-semantic-code): Require canonical rtl.
	(/gen-sfrag-code): Update.
	* sim-cpu.scm (gen-semantic-code): Require canonical rtl.
	* utils-cgen.scm (sanitize): New arg isa-name-list, ACU.
	* utils.scm (non-null-intersection?): New function.
@
text
@d918 2
a919 1
; Return definition of C macro to get the value of SYM.
d926 14
a939 1
; Return definition of C macro to set the value of SYM.
d949 4
a952 3
; Return definition of C macro to set the value of SYM, version 2.
; EXPR is one or more C statements *without* proper \newline handling,
; we prepend \ to each line.
@


1.20
log
@	* utils-cgen.scm (obj-csv-names): New function.
	* utils-sim.scm (/sfmt-contents): Use it in logging message.
@
text
@d581 1
a581 1
; Usage: (sanitize keyword entry-type entry-name1 [entry-name2 ...])
a582 1
; It's written this way so Hobbit can handle it.
d584 1
a584 1
(define (sanitize keyword entry-type . entry-names)
d594 1
a594 1
		  ((ifield) (set! entry (current-ifld-lookup entry-name)))
d596 3
a598 3
		  ((operand) (set! entry (current-op-lookup entry-name)))
		  ((insn) (set! entry (current-insn-lookup entry-name)))
		  ((macro-insn) (set! entry (current-minsn-lookup entry-name)))
@


1.19
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d239 10
@


1.18
log
@* read.scm (parse-error): Really change error message output format
to match context-owner-error.
* utils-cgen.scm (context-owner-error): Simplify.
@
text
@d720 1
a720 1
(define (-gen-attr-accessors prefix attrs)
@


1.17
log
@	* read.scm (parse-error): Change error message output format
	to match context-owner-error.
	* rtl-c.scm (-rtl-c-get): Call estate-error instead of error.
	(rtl-c-set-quiet, rtl-c-set-trace): Ditto.
	(s-if, s-cond, -gen-non-vm-case-test): Ditto.
	(operand): Call estate-error instead of context-error.
	(local, delay): Ditto.
	(ref, attr): Call estate-error instead of error.
	* rtl-traverse.scm (tstate-error): New function.
	(-rtx-traverse-error): Call tstate-error instead of context-error.
	(-rtx-traverse-operands, -rtx-traverse): Ditto.
	(estate-error): New function.
	* rtl.scm (rtx-lvalue-mode-name): Handle locals.  Call estate-error
	instead of error.
	(e-if): Call estate-error instead of error.
	* rtx-funcs.scm (error): Call estate-error instead of context-error.
	(member): Ditto.
	* utils-cgen.scm (context-error): New arg `intro', all callers updated.
	Rewrite to call context-owner-error.
	(context-owner-error): New function.
@
text
@d372 1
a372 3
	 (text (if prefix
		   (string-append prefix ": " errmsg)
		   errmsg)))
@


1.16
log
@	* ifield.scm (<ifield> constructor): New arg `location',
	all callers updated.
	* insn.scm (<insn> constructor): Ditto.
	(<multi-insn> constructor): Ditto.
	* minsn.scm (<macro-insn> constructor): Ditto.
	* operand.scm (<operand> constructor): Ditto.
	* utils-cgen.scm (builtin-location): New function.
	(<source-ident>): Fix default value of member `location'.
	(source-ident?): New function.
@
text
@d331 1
a331 1
; Call this to issue an error message.
d333 11
a343 1
; ARG is the value that had the error if there is one.
d345 52
a396 13
(define (context-error context errmsg . arg)
  (cond ((and context (context-location context))
	 (let ((msg (string-append
		     "@@ "
		     (location->string (context-location context))
		     ": "
		     (context-prefix context) ": "
		     errmsg ": ")))
	   (apply error (cons msg arg))))
	(context (let ((msg (string-append (context-prefix context) ": "
					   errmsg ": ")))
		   (apply error (cons msg arg))))
	(else (apply error (cons (string-append errmsg ": ") arg))))
@


1.15
log
@	* mach.scm (current-*-add!): Update calls to parse-error.
	* operand.scm (op:new-mode): Update call to parse-error.
	* utils-cgen.scm (make-obj-context): New function.
@
text
@d183 6
d255 1
a255 1
		(location . ())
d274 4
@


1.14
log
@	* ifield.scm (ifld-encode-mode): Add FIXME.
	* opcodes.scm (<ifield> 'gen-insert): Handle encode parameters with
	modes.
	(<ifield> 'gen-extract): Similarly.

	* read.scm (parse-error): Handle #f for context-location.
	* utils-cgen.scm (unspecified-location): Fix building of
	single-location.
@
text
@d302 6
@


1.13
log
@	* pmacros.scm (-pmacro-builtin-internal-test): New function.
	(pmacros-init!): Add .internal-test.
	* testsuite/test-utils.sh.in (post_process): Tweak FAIL output.
	* testsuite/testsuite.cpu (internal-verify): New pmacro.
	* doc/pmacros.text: Document .internal-test.

	* utils-cgen.scm (parse-name): Handle (add 3) -> add3.
	(parse-comment): Allow numbers.
	* doc/porting.texi: Document that names and comments may be lists.

	* insn.scm (-insn-parse): Fix typo.
@
text
@d88 1
d175 3
a177 1
;;; This is for use in debugging utilities.
d180 1
a180 1
  (make <location> (list (cons "unspecified" 1)))
@


1.12
log
@	Clean up cpu file parsing, pass context consistently instead of the
	old "errtxt" argument.
	NOTE: ACU == "All Callers Updated".
	* attr.scm (-parse-simple-attribute): Renamed from
	parse-simple-attribute, ACU.
	(-attr-parse): Change errtxt argument to context, ACU.
	(-attr-read): Ditto.
	(atlist-parse): Ditto.  Put context arg first.
	(attr-parse): Use parse-error instead of context-error.
	* enum.scm (parse-enum-vals): Change errtxt argument to context, ACU.
	(-enum-parse-prefix, -enum-parse, -enum-read): Ditto.
	* hardware.scm (-keyword-parse): Renamed from keyword-parse.
	`context' arg is now a <context> object.  ACU.
	(-keyword-read): `context' arg is now a <context> object.  ACU.
	(-hw-parse-indices): Change errtxt argument to context, ACU.
	(-hw-parse-values, -hw-parse-handlers): Ditto.
	(-hw-parse-getter, -hw-parse-setter, -hw-parse, -hw-read): Ditto.
	(-hw-validate-layout, -hw-create-getter-from-layout,
	-hw-create-setter-from-layout): Ditto.
	(<hw-register>:parse!, <hw-pc>:parse!): Ditto.
	(<hw-memory>:parse!, <hw-immediate>:parse!): Ditto.
	(<hw-address>:parse!): Ditto.
	* ifield.scm (-ifield-parse, ifield-read): Ditto.
	(-ifld-parse-follows, -ifld-parse-encode-decode): Ditto.
	(-ifld-parse-encode, -ifld-parse-decode): Ditto.
	(-multi-ifield-parse, -multi-ifield-read): Ditto.
	* insn.scm (-insn-parse, -insn-read): Ditto.
	(parse-syntax): Ditto.  Put context arg first.
	(-parse-insn-format-symbol): Change errtxt argument to context, ACU.
	(-parse-insn-format-ifield-spec, -parse-insn-format-list): Ditto.
	(-parse-insn-format): Ditto.
	* mach.scm (-arch-parse-alignment, -arch-parse-machs): Ditto.
	(-arch-parse-isas): Ditto.
	(-isa-read): Add context arg, ACU.
	(-cpu-parse, -cpu-read, -mach-read): Ditto.
	* minsn.scm (-minsn-parse-expansion): Change errtxt argument to
	context, ACU.
	(-minsn-parse, -minsn-read, -minsn-compute-iflds): Ditto.
	(minsn-make-alias): Ditto.
	* mode.scm (-mode-parse): Ditto.
	(parse-mode-name): Ditto.  Put context arg first.
	* model.scm (-prefetch-parse, -retire-parse, -pipeline-parse): Change
	errtxt argument to context, ACU.
	(-unit-parse, -model-parse, -model-read): Ditto.
	* operand.scm (-operand-parse-getter): Use parse-error instead of
	context-error.
	(-operand-parse-setter): Ditto.
	(-operand-parse): Change errtxt argument to context, ACU.
	(-operand-read, -derived-operand-parse, -derived-operand-read): Ditto.
	(-anyof-operand-parse, -anyof-operand-read): Ditto.
	* read.scm (reader-error): Delete.  Use parse-error instead.
	(parse-error): Change errtxt argument to context, ACU.  Split args
	argument into expr and maybe-help-text.
	(-reader-process-expanded-1!): Reorganize.
	* rtl.scm (-subr-read): Change errtxt argument to context, ACU.
	* types.scm (parse-type): Ditto.
	* utils-cgen.scm (single-location->simple-string): New function.
	(<context>): Replace members file,lineno with location.
	(make-prefix-context): Renamed from context-make-prefix, ACU.
	(make-current-context): New function.
	(context-append, context-append-name): New functions.
	(context-make-reader): Delete.
	(parse-name): Change errtxt argument to context, ACU.
	Put context arg first.
	(parse-comment): Ditto.
	(parse-number): Change errtxt argument to context, ACU.
	(arg-list-validate-name, arg-list-check-no-args,
	arg-list-symbol-arg): Ditto.

	* read.scm (-cmd-if): Don't assume test is a list.

	* html.scm (get-insn-properties): Delete errtxt, unused.
@
text
@a340 1
      ((list? name) (string-map parse name))
d343 2
d353 4
a356 1
  (cond ((list? comment)
a357 2
	((or (string? comment) (symbol? comment))
	 (->string comment))
@


1.11
log
@	Add -t option for tracing things like commands, pmacro expansion.
	* dev.scm (cload): New arg #:trace.
	* pmacros.scm (-pmacro-expand): Rewrite pmacro tracing.
	(pmacro-trace): New arg `loc'.  Rewrite pmacro tracing.
	(pmacro-debug): Call pmacro-trace instead of -pmacro-expand.
	* read.scm (<reader>): New members trace-commands?, trace-pmacros?.
	(-reader-process-expanded-1!): Trace commands if requested.
	(-reader-process!): Call pmacro-trace of pmacro tracing requested.
	(-set-trace-options!): New function.
	(-init-reader!): New function.
	(cpu-load): New arg trace-options, all callers updated.
	Call -init-reader! and -set-trace-options!.
	(cgen-usage): Improve output formatting.
	(common-arguments): New option -t.
	(-cgen): Process -t.
	* utils-cgen.scm (single-location->string): Renamed from
	pretty-print-single-location.  All callers updated.
	(location->string): Renamed from pretty-print-location.
	All callers updated.
	(source-properties-location->string): New function.
	* doc/running.texi: Document -t.
@
text
@d101 1
d104 1
a104 3
		 ;; +1: numbers are recorded origin-0
		 (number->string (+ (single-location-line sloc)
				    1))
d106 15
a120 4
		 (number->string (+ (single-location-column sloc)
				    1))
		 (if (single-location-end? sloc) "(end)" "")
		 )
d268 2
a269 1
; Parsing context, used to give better error messages.
d274 5
a278 6
		; Name of file containing object being processed.
		(file . #f)
		; Line number in the file.
		(lineno . #f)
		; Error message prefix
		(prefix . "")
d285 1
a285 1
(define-getters <context> context (file lineno prefix))
d289 15
a303 2
(define (context-make-prefix prefix)
  (make <context> #f #f prefix)
d306 1
a306 2
; Create a <context> object for the reader.
; This sets file,lineno from (current-input-port).
d308 2
a309 6
(define (context-make-reader prefix)
  (make <context>
    (or (port-filename (current-input-port))
	"<input>")
    (port-line (current-input-port))
    prefix)
d317 1
a317 1
  (cond ((and context (context-file context))
d319 3
a321 2
		     (context-file context) ":"
		     (number->string (context-lineno context)) ": "
a335 1
; FIXME: Isn't the plan to move ERRTXT to the 1st arg?
d337 1
a337 1
(define (parse-name name errtxt)
d344 1
a344 1
      (else (parse-error errtxt "improper name" name)))))
a349 1
; FIXME: Isn't the plan to move ERRTXT to the 1st arg?
d351 1
a351 1
(define (parse-comment comment errtxt)
d353 1
a353 1
	 (string-map (lambda (elm) (parse-comment elm errtxt)) comment))
d356 1
a356 1
	(else (parse-error errtxt "improper comment" comment)))
d378 1
a378 1
(define (parse-number errtxt value . valid-values)
d380 1
a380 1
      (parse-error errtxt "not a number" value))
d388 1
a388 1
      (parse-error errtxt "invalid number" value valid-values))
d465 1
a465 1
(define (arg-list-validate-name errtxt arg-spec)
d467 1
a467 1
      (parse-error errtxt "empty argument spec"))
d469 1
a469 1
      (parse-error errtxt "argument name not a symbol" arg-spec))
d476 2
a477 2
(define (arg-list-check-no-args errtxt arg-spec)
  (arg-list-validate-name errtxt arg-spec)
d479 2
a480 2
      (parse-error errtxt (string-append (car arg-spec)
					 " takes zero arguments")))
d487 2
a488 2
(define (arg-list-symbol-arg errtxt arg-spec)
  (arg-list-validate-name errtxt arg-spec)
d491 2
a492 2
      (parse-error errtxt (string-append (car arg-spec)
					 ": argument not a symbol")))
d522 2
a523 1
		  (else (parse-error "sanitize" "unknown entry type" entry-type)))
d549 1
a549 1
			(parse-error "sanitize"
@


1.10
log
@	Track source location better, for better error messages.
	* pmacros.scm (-pmacro-eval): Delete, unused.
	(pmacro-expand, -pmacro-expand): New arg `loc', all callers updated.
	(-pmacro-expand-expr-list, -smacro-apply): Ditto.
	(scan-list, scan): Ditto.
	(-pmacro-builtin-pmacro, -pmacro-builtin-let, -pmacro-builtin-if,
	-pmacro-builtin-case, -pmacro-builtin-cond, -pmacro-builtin-begin,
	-pmacro-builtin-andif, -pmacro-builtin-orif): Ditto.
	(scan-list1): New function.
	(-pmacro-build-lambda): New arg `loc', all callers updated.  Rewrite.
	* read.scm (<reader>): New member `location'.
	(-reader-lookup-command): Renamed from reader-lookup-command,
	all callers updated.
	(reader-error): Rewrite to produce better source location info.
	(current-reader-location): New function.
	(-reader-process-expanded-1!): Renamed from -reader-process-expanded-1.
	All callers updated.  Record source location of expression.
	(reader-process-expanded!): Renamed from reader-process-expanded.
	All callers updated.
	(-reader-process!): Renamed from reader-process.  New arg `loc'.
	All callers updated.  Record source location of define-pmacro.
	* utils-cgen.scm (<location>): New class.
	(single-location): New (pseudo) class.
	(pretty-print-single-location, pretty-print-location): New functions.
	(location-top, location-push-single, location-push): New functions.
	(unspecified-location, current-input-location): New functions.
	(location-property): New object property.
	(location-property-set!): New function.
	(<source-ident>): Renamed from <ordered-ident>.  New member `location'.
	All uses updated.
	* testsuite/location-1.test: New testcase.
	* testsuite/run-tests.sh: Fix fail count handling.
	* testsuite/test-utils.sh.in (run_cgen): New option `-f'.  Allow tests
	to expect cgen to fail.

	* pmacros.scm (*): Use "pmacro" instead of "macro" more consistently.

	* read.scm (-cmd-include): Renamed from include.  All callers updated.
	(-cmd-if): Renamed from cmd-if.  All callers updated.
	Use reader-process-expanded! on then/else clauses instead of eval1.
@
text
@d100 1
a100 1
(define (pretty-print-single-location sloc)
d115 1
a115 1
(define (pretty-print-location loc)
d118 1
a118 1
     (- (string-length ref-from))
d123 1
a123 1
				   (pretty-print-single-location sloc)
d129 14
@


1.9
log
@	Use hash tables to record ifields, operands, insns, macro-insns.
	* attr.scm (attr-builtin!): Tweak some comments.
	* hardware.scm (hardware-builtin!): Call all-isas-attr-value.
	* ifield.scm (<ifield>): Subclass from <ordered-ident> instead of
	<ident>.
	(<multi-ifield>): New constructor.
	(ifield-builtin!): Add isa attr to f-nil, f-anyof.
	* insn.scm (<insn>): Subclass from <ordered-ident> instead of
	<ident>.
	(-sub-insn-make!): Add hack to avoid differences in generated code.
	(multi-insn-instantiate!): Add total number of multi-insns to
	logging message.
	* mach.scm (<arch>): Rename members ifld-list, op-list, insn-list,
	minsn-list to foo-table.  New member next-ordinal.
	Update getters/setters.
	(arch-ifld-list, arch-op-list, arch-insn-list, arch-minsn-list):
	New functions.
	(-get-next-ordinal!, -get-lowest-ordinal): New function.
	(-make-ident-object-table, -ident-object-table->list,
	-ident-object-table-add!, -ident-object-table-lookup): New functions.
	(current-ifld-list, current-ifld-add! current-ifld-lookup,
	-ifld-already-defined?): Rewrite.
	(current-op-list, current-op-add! current-op-lookup,
	-op-already-defined?): Rewrite.
	(current-raw-insn-list, insn-list-car, insn-list-splice!): Delete.
	(current-insn-list, current-insn-add! current-insn-lookup,
	-insn-already-defined?): Rewrite.
	(current-minsn-list, current-minsn-add! current-minsn-lookup,
	-minsn-already-defined?): Rewrite.
	(all-isas-attr-value, all-isas-attr, attr-isa-list): New functions.
	(MAX-VIRTUAL-INSNS): Define.
	(arch-analyze-insns!): Add hack to avoid differences in generated code.
	Update use of arch-insn-list.
	(mach-init!): Initialize ifld-table, op-table, insn-table, minsn-table.
	(arch-finish!): Delete references to ifld-table, op-table, insn-table,
	minsn-table.
	* minsn.scm (<macro-insn>): Subclass from <ordered-ident> instead of
	<ident>.  New constructor.
	* operand.scm (<operand>): Subclass from <ordered-ident> instead of
	<ident>.
	* sid.scm (-virtual-insn-add!): New function.
	(-create-virtual-insns!): Call it.
	(-fill-sim-insn-list!): Rewrite.
	* sim.scm (-virtual-insn-add!, -create-virtual-insns!): New functions.
	(sim-finish!): Move contents to -create-virtual-insns!, and call it.
	* utils-cgen.scm (<ordered-ident>): New class.
	(obj-ordinal, obj-set-ordinal!): New functions.
	(add-ident-methods!): Delete.

	* model.scm (parse-insn-timing): Change logging message to level 3.
@
text
@d70 108
d208 2
d215 2
d218 8
a225 4
(define <ordered-ident>
  (class-make '<ordered-ident> '(<ident>)
	      ;; #f for ordinal means "unassigned"
	      '((ordinal . #f))
d228 8
a235 1
(method-make! <ordered-ident> 'get-ordinal
d237 1
a237 1
(method-make! <ordered-ident> 'set-ordinal!
a238 1

d843 1
a843 1
; Sort a list of <ident> objects alphabetically.
@


1.8
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d98 18
a115 2
; Utility to add standard access methods for name, comment, attrs.
; ??? Old.  Using <ident> baseclass now.
d117 2
a118 12
(define (add-ident-methods! class)
  (method-make! class 'get-name (lambda (self) (elm-get self 'name)))
  (method-make! class 'set-name! (lambda (self name) (elm-set! self 'name name)))

  (method-make! class 'get-comment (lambda (self) (elm-get self 'comment)))
  (method-make! class 'set-comment! (lambda (self comment) (elm-set! self 'comment comment)))

  (method-make! class 'get-atlist (lambda (self) (elm-get self 'attrs)))
  (method-make! class 'set-atlist! (lambda (self attrs) (elm-set! self 'attrs attrs)))

  *UNSPECIFIED*
)
@


1.7
log
@2005-10-28  Dave Brolley  <brolley@@redhat.com>

        Contribute the following changes:
        2005-09-19  Dave Brolley  <brolley@@redhat.com>

        * attr.scm (gen-value-for-defn-raw): New methods.
        (gen-value-for-defn): Don't test for 'SID-SIMULATOR. Call
        gen-value-for-defn-raw.
        * sid.scm (gen-obj-attr-sid-defn): Call gen-value-for-defn-raw.

        2002-12-13  Dave Brolley  <brolley@@redhat.com>

        * utils-cgen.scm (gen-attr-type): Moved from sid.scm.
        (-gen-attr-accessors): New function.
        (gen-obj-attr-defn): Update terminating initializer.
        (gen-obj-attr-end-defn): New function.
        * sid.scm (gen-attr-type): Moved to utils-cgen.scm.
        * sid-cpu.scm (cgen-desc.h): Generate code to include
        "opcode/cgen-bitset.h"
        * intrinsics.scm (kept-insn-isas): Correct the extraction of the isa
        name.
        * desc.scm ('gen-defn): Update terminating initializer.
        * desc-cpu.scm (gen-ifld-decls): Call -gen-attr-accessors. Update
        terminatinig initializer.
        (gen-hw-decls): Ditto.
        (gen-operand-decls): Ditto.
        (gen-insn-decls): Ditto.
        (-gen-hash-defines): Generate code to include "opcde/cgen-bitset.h"
        (gen-insn-table): Update terminating initializer.
        (-gen-cpu-open): Update generation of @@arch@@_cgen_rebuild_tables,
        @@arch@@_cgen_cpu_open, @@arch@@_cgen_cpu_close.
        * attr.scm (charmask-bytes): New function.
        (bitset-attr->charmask): New function.
        (<bitset-attribute>): Handle isa-attributes specially. Also handle
        differences for SID-SIMULATOR.
        (<integer-attribute>): Handle differences for SID-SIMULATOR.
        (<enum-attribute>): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2002, 2003 Red Hat, Inc.
@


1.7.6.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2002, 2003, 2009 Red Hat, Inc.
@


1.6
log
@* utils-cgen.scm (parse-name): Don't assume that string-map can be
applied to symbols.  Process everything as strings, and then
convert to a symbol at the end.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
d470 58
d626 21
@


1.5
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@d178 7
a184 5
  (cond ((list? name)
	 (string->symbol (string-map (lambda (elm) (parse-name elm errtxt)) name)))
	((symbol? name) name)
	((string? name) (string->symbol name))
	(else (parse-error errtxt "improper name" name)))
@


1.4
log
@	* Makefile.am (srcroot): New var.
	(html): New rule.
	* Makefile.in: Regenerate.
	* cgen-doc.scm: New file.
	* html.scm: New file.
	* gen-all-doc: New file.
	* dev.scm (cload): Handle DOC application.
	(load-doc): New fn.
	* machs.scm (machs-for-cpu): New fn.
	* model.scm (models-for-cpu): New fn.
	* utils.scm (gen-c-copyright): Renamed from gen-copyright.
	All uses updated.
	(iota): Rewrite to be identical to pmacro version.  All uses updated.
	* utils-cgen.scm (alpha-sort-obj-list): New fn.
@
text
@d73 1
a73 1
(define <ident> (class-make '<ident> () '(name comment attrs) ()))
d94 4
d194 1
a194 1
	 comment)
d202 2
a203 2
      (parse-error context "not a symbol" value))
  value
d210 2
a211 2
      (parse-error context "not a string" value))
  value
d268 1
a268 1
		(char=? (string-ref (car x) 0) #\:))))
d288 1
a288 1
		(char=? (string-ref (car rkl) 0) #\:))
d494 2
a495 1
  (string-upcase (gen-c-symbol (string-append prefix "_" attr-name)))
d639 1
a639 1
	  (string<? (obj:name o1) (obj:name o2))))
@


1.3
log
@* ANSI C fixes

2000-11-20  Frank Ch. Eigler  <fche@@redhat.com>

	* opc-itab.scm (-gen-ifmt-table, -gen-macro-insn-table: Remove
	unneeded "\n\n" from F() macro definition.

2000-11-15  Greg McGary  <greg@@mcgary.org>

	* utils-cgen.scm (gen-define-with-symcat): New function.
	* desc-cpu.scm (gen-ifld-defns): Use it.
	(gen-hw-table-defns): Use it.
	(-gen-hash-defines): Use it.
	(gen-operand-table): Use it.
	(gen-insn-table): Use it.  Remove spurious `#undef MNEM'.
	* opc-itab.scm (-gen-ifmt-table): Use it.
	(-gen-insn-opcode-table): Use it.
	(-gen-macro-insn-table): Use it.
	* opc-opinst.scm (-gen-operand-instance-tables): Use it.
	* sim-cpu.scm (cgen-semantics.c): Use it.
	(cgen-sem-switch.c): Use it.
@
text
@d626 2
d629 7
@


1.2
log
@* cleanup

2000-10-13  matthew green  <mrg@@cygnus.com>

	* utils-cgen.scm (get-ifetch): Move from here ...
	* sim.scm (get-ifetch): ... to here.
@
text
@d639 23
@


1.1
log
@Initial revision
@
text
@a626 16
; Return C code to fetch a value from instruction memory.
; PC-VAR is the C expression containing the address of the start of the
; instruction.
; ??? Aligned/unaligned support?

(define (gen-ifetch pc-var bitoffset bitsize)
  (string-append "GETIMEM"
		 (case bitsize
		   ((8) "UQI")
		   ((16) "UHI")
		   ((32) "USI")
		   (else (error "bad bitsize argument to gen-ifetch" bitsize)))
		 " (current_cpu, "
		 pc-var " + " (number->string (quotient bitoffset 8))
		 ")")
)
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
