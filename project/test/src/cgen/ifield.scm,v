head	1.28;
access;
symbols
	sid-snapshot-20180601:1.28
	cgen-snapshot-20180601:1.28
	sid-snapshot-20180501:1.28
	cgen-snapshot-20180501:1.28
	sid-snapshot-20180401:1.28
	cgen-snapshot-20180401:1.28
	sid-snapshot-20180301:1.28
	cgen-snapshot-20180301:1.28
	sid-snapshot-20180201:1.28
	cgen-snapshot-20180201:1.28
	sid-snapshot-20180101:1.28
	cgen-snapshot-20180101:1.28
	sid-snapshot-20171201:1.28
	cgen-snapshot-20171201:1.28
	sid-snapshot-20171101:1.28
	cgen-snapshot-20171101:1.28
	sid-snapshot-20171001:1.28
	cgen-snapshot-20171001:1.28
	sid-snapshot-20170901:1.28
	cgen-snapshot-20170901:1.28
	sid-snapshot-20170801:1.28
	cgen-snapshot-20170801:1.28
	sid-snapshot-20170701:1.28
	cgen-snapshot-20170701:1.28
	sid-snapshot-20170601:1.28
	cgen-snapshot-20170601:1.28
	sid-snapshot-20170501:1.28
	cgen-snapshot-20170501:1.28
	sid-snapshot-20170401:1.28
	cgen-snapshot-20170401:1.28
	sid-snapshot-20170301:1.28
	cgen-snapshot-20170301:1.28
	sid-snapshot-20170201:1.28
	cgen-snapshot-20170201:1.28
	sid-snapshot-20170101:1.28
	cgen-snapshot-20170101:1.28
	sid-snapshot-20161201:1.28
	cgen-snapshot-20161201:1.28
	sid-snapshot-20161101:1.28
	cgen-snapshot-20161101:1.28
	sid-snapshot-20160901:1.28
	cgen-snapshot-20160901:1.28
	sid-snapshot-20160801:1.28
	cgen-snapshot-20160801:1.28
	sid-snapshot-20160701:1.28
	cgen-snapshot-20160701:1.28
	sid-snapshot-20160601:1.28
	cgen-snapshot-20160601:1.28
	sid-snapshot-20160501:1.28
	cgen-snapshot-20160501:1.28
	sid-snapshot-20160401:1.28
	cgen-snapshot-20160401:1.28
	sid-snapshot-20160301:1.28
	cgen-snapshot-20160301:1.28
	sid-snapshot-20160201:1.28
	cgen-snapshot-20160201:1.28
	sid-snapshot-20160101:1.28
	cgen-snapshot-20160101:1.28
	sid-snapshot-20151201:1.28
	cgen-snapshot-20151201:1.28
	sid-snapshot-20151101:1.28
	cgen-snapshot-20151101:1.28
	sid-snapshot-20151001:1.28
	cgen-snapshot-20151001:1.28
	sid-snapshot-20150901:1.28
	cgen-snapshot-20150901:1.28
	sid-snapshot-20150801:1.28
	cgen-snapshot-20150801:1.28
	sid-snapshot-20150701:1.28
	cgen-snapshot-20150701:1.28
	sid-snapshot-20150601:1.28
	cgen-snapshot-20150601:1.28
	sid-snapshot-20150501:1.28
	cgen-snapshot-20150501:1.28
	sid-snapshot-20150401:1.28
	cgen-snapshot-20150401:1.28
	sid-snapshot-20150301:1.28
	cgen-snapshot-20150301:1.28
	sid-snapshot-20150201:1.28
	cgen-snapshot-20150201:1.28
	sid-snapshot-20150101:1.28
	cgen-snapshot-20150101:1.28
	sid-snapshot-20141201:1.28
	cgen-snapshot-20141201:1.28
	sid-snapshot-20141101:1.28
	cgen-snapshot-20141101:1.28
	sid-snapshot-20141001:1.28
	cgen-snapshot-20141001:1.28
	sid-snapshot-20140901:1.28
	cgen-snapshot-20140901:1.28
	sid-snapshot-20140801:1.28
	cgen-snapshot-20140801:1.28
	sid-snapshot-20140701:1.28
	cgen-snapshot-20140701:1.28
	sid-snapshot-20140601:1.28
	cgen-snapshot-20140601:1.28
	sid-snapshot-20140501:1.28
	cgen-snapshot-20140501:1.28
	sid-snapshot-20140401:1.28
	cgen-snapshot-20140401:1.28
	sid-snapshot-20140301:1.28
	cgen-snapshot-20140301:1.28
	sid-snapshot-20140201:1.28
	cgen-snapshot-20140201:1.28
	sid-snapshot-20140101:1.28
	cgen-snapshot-20140101:1.28
	sid-snapshot-20131201:1.28
	cgen-snapshot-20131201:1.28
	sid-snapshot-20131101:1.28
	cgen-snapshot-20131101:1.28
	sid-snapshot-20131001:1.28
	cgen-snapshot-20131001:1.28
	sid-snapshot-20130901:1.28
	cgen-snapshot-20130901:1.28
	sid-snapshot-20130801:1.28
	cgen-snapshot-20130801:1.28
	sid-snapshot-20130701:1.28
	cgen-snapshot-20130701:1.28
	sid-snapshot-20130601:1.28
	cgen-snapshot-20130601:1.28
	sid-snapshot-20130501:1.28
	cgen-snapshot-20130501:1.28
	sid-snapshot-20130401:1.28
	cgen-snapshot-20130401:1.28
	sid-snapshot-20130301:1.28
	cgen-snapshot-20130301:1.28
	sid-snapshot-20130201:1.28
	cgen-snapshot-20130201:1.28
	sid-snapshot-20130101:1.28
	cgen-snapshot-20130101:1.28
	sid-snapshot-20121201:1.28
	cgen-snapshot-20121201:1.28
	sid-snapshot-20121101:1.28
	cgen-snapshot-20121101:1.28
	sid-snapshot-20121001:1.28
	cgen-snapshot-20121001:1.28
	sid-snapshot-20120901:1.28
	cgen-snapshot-20120901:1.28
	sid-snapshot-20120801:1.28
	cgen-snapshot-20120801:1.28
	sid-snapshot-20120701:1.28
	cgen-snapshot-20120701:1.28
	sid-snapshot-20120601:1.28
	cgen-snapshot-20120601:1.28
	sid-snapshot-20120501:1.28
	cgen-snapshot-20120501:1.28
	sid-snapshot-20120401:1.28
	cgen-snapshot-20120401:1.28
	sid-snapshot-20120301:1.28
	cgen-snapshot-20120301:1.28
	sid-snapshot-20120201:1.28
	cgen-snapshot-20120201:1.28
	sid-snapshot-20120101:1.28
	cgen-snapshot-20120101:1.28
	sid-snapshot-20111201:1.28
	cgen-snapshot-20111201:1.28
	sid-snapshot-20111101:1.28
	cgen-snapshot-20111101:1.28
	sid-snapshot-20111001:1.28
	cgen-snapshot-20111001:1.28
	sid-snapshot-20110901:1.28
	cgen-snapshot-20110901:1.28
	sid-snapshot-20110801:1.28
	cgen-snapshot-20110801:1.28
	sid-snapshot-20110701:1.28
	cgen-snapshot-20110701:1.28
	sid-snapshot-20110601:1.28
	cgen-snapshot-20110601:1.28
	sid-snapshot-20110501:1.28
	cgen-snapshot-20110501:1.28
	sid-snapshot-20110401:1.28
	cgen-snapshot-20110401:1.28
	sid-snapshot-20110301:1.28
	cgen-snapshot-20110301:1.28
	sid-snapshot-20110201:1.28
	cgen-snapshot-20110201:1.28
	sid-snapshot-20110101:1.28
	cgen-snapshot-20110101:1.28
	sid-snapshot-20101201:1.28
	cgen-snapshot-20101201:1.28
	sid-snapshot-20101101:1.28
	cgen-snapshot-20101101:1.28
	sid-snapshot-20101001:1.28
	cgen-snapshot-20101001:1.28
	sid-snapshot-20100901:1.28
	cgen-snapshot-20100901:1.28
	sid-snapshot-20100801:1.28
	cgen-snapshot-20100801:1.28
	sid-snapshot-20100701:1.28
	cgen-snapshot-20100701:1.28
	sid-snapshot-20100601:1.28
	cgen-snapshot-20100601:1.28
	sid-snapshot-20100501:1.28
	cgen-snapshot-20100501:1.28
	sid-snapshot-20100401:1.28
	cgen-snapshot-20100401:1.28
	sid-snapshot-20100301:1.28
	cgen-snapshot-20100301:1.28
	sid-snapshot-20100201:1.28
	cgen-snapshot-20100201:1.28
	sid-snapshot-20100101:1.27
	cgen-snapshot-20100101:1.27
	sid-snapshot-20091201:1.27
	cgen-snapshot-20091201:1.27
	sid-snapshot-20091101:1.25
	cgen-snapshot-20091101:1.25
	sid-snapshot-20091001:1.23
	cgen-snapshot-20091001:1.23
	arc-sim-20090309:1.7
	sid-snapshot-20090901:1.15
	cgen-snapshot-20090901:1.15
	sid-snapshot-20090801:1.11
	cgen-snapshot-20090801:1.11
	sid-snapshot-20090701:1.8
	cgen-snapshot-20090701:1.8
	dje-cgen-play1-branch:1.8.0.2
	dje-cgen-play1-branchpoint:1.8
	cgen-1_1-branch:1.7.0.6
	cgen-1_1-branchpoint:1.7
	sid-snapshot-20090601:1.7
	cgen-snapshot-20090601:1.7
	sid-snapshot-20090501:1.7
	cgen-snapshot-20090501:1.7
	sid-snapshot-20090401:1.7
	cgen-snapshot-20090401:1.7
	arc-insight_6_8-branch:1.7.0.4
	arc-insight_6_8-branchpoint:1.7
	sid-snapshot-20090301:1.7
	cgen-snapshot-20090301:1.7
	sid-snapshot-20090201:1.7
	cgen-snapshot-20090201:1.7
	sid-snapshot-20090101:1.7
	cgen-snapshot-20090101:1.7
	sid-snapshot-20081201:1.7
	cgen-snapshot-20081201:1.7
	sid-snapshot-20081101:1.7
	cgen-snapshot-20081101:1.7
	sid-snapshot-20081001:1.7
	cgen-snapshot-20081001:1.7
	sid-snapshot-20080901:1.7
	cgen-snapshot-20080901:1.7
	sid-snapshot-20080801:1.7
	cgen-snapshot-20080801:1.7
	sid-snapshot-20080701:1.7
	cgen-snapshot-20080701:1.7
	sid-snapshot-20080601:1.7
	cgen-snapshot-20080601:1.7
	sid-snapshot-20080501:1.7
	cgen-snapshot-20080501:1.7
	sid-snapshot-20080403:1.7
	sid-snapshot-20080401:1.7
	cgen-snapshot-20080401:1.7
	sid-snapshot-20080301:1.7
	cgen-snapshot-20080301:1.7
	sid-snapshot-20080201:1.7
	cgen-snapshot-20080201:1.7
	sid-snapshot-20080101:1.7
	cgen-snapshot-20080101:1.7
	sid-snapshot-20071201:1.7
	cgen-snapshot-20071201:1.7
	sid-snapshot-20071101:1.7
	cgen-snapshot-20071101:1.7
	sid-snapshot-20071001:1.7
	cgen-snapshot-20071001:1.7
	msnyder-fork-checkpoint-branch:1.7.0.2
	msnyder-fork-checkpoint-branchpoint:1.7
	sid-20020905-branchpoint:1.4
	sid-20020905-branch:1.4.0.6
	cagney_regbuf-20020515-branch:1.4.0.4
	cagney_regbuf-20020515-branchpoint:1.4
	cygnus_cvs_20020108_pre:1.4
	cgen-1-1-branch:1.4.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.28
date	2010.01.25.00.40.28;	author devans;	state Exp;
branches;
next	1.27;

1.27
date	2009.11.23.09.03.00;	author devans;	state Exp;
branches;
next	1.26;

1.26
date	2009.11.03.16.24.01;	author devans;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.26.00.56.34;	author devans;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.15.05.51.08;	author devans;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.27.18.31.33;	author devans;	state Exp;
branches;
next	1.22;

1.22
date	2009.09.12.17.34.15;	author devans;	state Exp;
branches;
next	1.21;

1.21
date	2009.09.09.20.43.04;	author devans;	state Exp;
branches;
next	1.20;

1.20
date	2009.09.09.17.20.53;	author devans;	state Exp;
branches;
next	1.19;

1.19
date	2009.09.09.17.06.19;	author devans;	state Exp;
branches;
next	1.18;

1.18
date	2009.09.09.08.00.15;	author devans;	state Exp;
branches;
next	1.17;

1.17
date	2009.09.09.03.51.10;	author devans;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.07.22.17.33;	author devans;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.27.04.22.56;	author devans;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.19.04.20.29;	author devans;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.12.22.33.37;	author devans;	state Exp;
branches;
next	1.12;

1.12
date	2009.08.06.16.40.43;	author devans;	state Exp;
branches;
next	1.11;

1.11
date	2009.07.20.00.47.23;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2009.07.18.20.44.58;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2009.07.16.17.48.30;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2003.07.16.05.35.47;	author devans;	state Exp;
branches
	1.7.6.1;
next	1.6;

1.6
date	2002.12.22.19.01.36;	author devans;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.22.02.12.13;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.09.16.07.49;	author geoffk;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.15.15.01.20;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.22.19.14.30;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.7.6.1
date	2009.06.24.14.57.45;	author devans;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.28
log
@	* utils-cgen.scm (<location>): Define using new define-class.
	(<ident>, <source-ident>, <context>): Ditto.

	* cos.scm (/object-string): New function.
	(/object-error): Use it.
	(/object-count-true): New function
	(object-copy-top): Delete.  All callers changed to call object-copy.
	(/parse-member-list, /build-getter-defs, /build-setter-defs): New fns.
	(define-class, define-interface, define-method): New macros.
	(define-getters, define-setters, vmake): Moved here ...
	* utils-cgen.scm: ... from here.
@
text
@; Instruction fields.
; Copyright (C) 2000, 2002, 2009 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.

; The `<ifield>' class.
; (pronounced "I-field")
;
; These describe raw data, little semantic content is attributed to them.
; The goal being to avoid interfering with future applications.
;
; FIXME: Move start, word-offset, word-length into the instruction format?
; - would require proper ordering of fields in insns, but that's ok.
;   (??? though the sparc64 description shows a case where its useful to
;   not have to worry about instruction ordering - different versions of an
;   insn take different fields and these fields are passed via a macro)
;
; ??? One could treat all ifields as being unsigned.  They could be thought of
; as indices into a table of values, be they signed, unsigned, floating point,
; whatever.  Just an idea.
;
; ??? Split into two?  One for definition, and one for value.

(define <ifield>
  (class-make '<ifield>
	      '(<source-ident>)
	      '(
		; The mode the raw value is to be interpreted in.
		; This is a <mode> object.
		mode

		; A <bitrange> object.
		; This contains the field's offset, start, length, word-length,
		; and orientation (msb==0, lsb==0).  The orientation is
		; recorded to keep the <bitrange> object self-contained.
		; Endianness is not recorded.
		bitrange

		; Argument to :follows, as an object.
		; FIXME: wip
		(follows . #f)

		; ENCODE/DECODE operate on the raw value, absent of any context
		; save `pc' and mode of field.
		; If #f, no special processing is required.
		; ??? It's not clear where the best place to process fields is.
		; An earlier version had insert/extract fields in operands to
		; handle more complicated cases.  Following the goal of
		; incremental complication, the special handling for m32r's
		; f-disp8 field is handled entirely here, rather than partially
		; here and partially in the operand.
		encode decode

		; Value of field, if there is one, or #f.
		; Possible types are: integer, <operand>, ???
		(value . #f)
		)
	      nil)
)

; {ordinal} is missing on purpose, it's handled at a higher level.
; {value},{follows} are missing on purpose.
; {value} is handled specially.
; {follows} is rarely used.
(method-make-make! <ifield>
		   '(location name comment attrs mode bitrange encode decode))

; Accessor fns
; ??? `value' is treated specially, needed anymore?

(define-getters <ifield> ifld (mode encode decode follows))

(define-setters <ifield> ifld (follows))

; internal fn
(define /ifld-bitrange (elm-make-getter <ifield> 'bitrange))

(define (ifld-word-offset f) (bitrange-word-offset (/ifld-bitrange f)))
(define (ifld-word-length f) (bitrange-word-length (/ifld-bitrange f)))

; Return the mode of the decoded value of <ifield> F.
; ??? This is made easy because we require the decode expression to have
; an explicit mode.

(define (ifld-decode-mode f)
  (assert (elm-bound? f 'decode))
  (let ((d (ifld-decode f)))
    (if d
	;; FIXME: Does this work with canonicalized rtl?
	(mode:lookup (cadr (cadr d)))
	(ifld-mode f)))
)

; Return start of ifield.

(method-make!
 <ifield> 'field-start
 (lambda (self)
   (bitrange-start (/ifld-bitrange self)))
)

(define (ifld-start ifld)
  (send ifld 'field-start)
)

(method-make!
 <ifield> 'field-length
 (lambda (self)
   (bitrange-length (elm-get self 'bitrange)))
)

(define (ifld-length f) (send f 'field-length))

; FIXME: It might make things more "readable" if enum values were preserved in
; their symbolic form and the get-field-value method did the lookup.

(method-make!
 <ifield> 'get-field-value
 (lambda (self)
   (elm-get self 'value))
)
(define (ifld-get-value self)
  (send self 'get-field-value)
)
(method-make!
 <ifield> 'set-field-value!
 (lambda (self new-val)
   (elm-set! self 'value new-val))
)
(define (ifld-set-value! self new-val)
  (send self 'set-field-value! new-val)
)

; Return a boolean indicating if X is an <ifield>.

(define (ifield? x) (class-instance? <ifield> x))

; Return ilk of field as a string.
; ("ilk" sounds klunky but "type" is too ambiguous.  Here "ilk" means
; the kind of the hardware element, enum, etc.)
; The result is a character string naming the field type.

(define (ifld-ilk fld)
  (let ((value (elm-xget fld 'value)))
    ; ??? One could require that the `value' field always be an object.
    ; I can't get too worked up over it yet.
    (if (object? value)
	(symbol->string (obj:name value)) ; send 'get-name to fetch the name
	"#")) ; # -> "it's a number"
)

; Generate the name of the enum for instruction field ifld.
; If PREFIX? is present and #f, the @@ARCH@@_ prefix is omitted.

(define (ifld-enum ifld . prefix?)
  (string-upcase (string-append (if (or (null? prefix?) (car prefix?))
				    "@@ARCH@@_"
				    "")
				(gen-sym ifld)))
)

; Return a boolean indicating if ifield F is an opcode field
; (has a constant value).

(define (ifld-constant? f)
  (number? (ifld-get-value f))
;  (and (number? (ifld-get-value f))
;       (if option:reserved-as-opcode?
;	   #t
;	   (not (has-attr? f 'RESERVED))))
)

; Return a boolean indicating if ifield F is signed.

(define (ifld-signed? f)
  (eq? (mode:class (ifld-mode f)) 'INT)
)

; Return a boolean indicating if ifield F is an operand.
; FIXME: Should check for operand? or some such.

(define (ifld-operand? f) (not (number? (ifld-get-value f))))

; Return known value table for rtx-simplify of <ifield> list ifld-list.

(define (ifld-known-values ifld-list)
  (let ((constant-iflds (find ifld-constant? (ifields-base-ifields ifld-list))))
    (map (lambda (f)
	   (cons (obj:name f)
		 (rtx-make-const 'INT (ifld-get-value f))))
	 constant-iflds))
)

; Return mask to use for a field in <bitrange> CONTAINER.
; If the bitrange is outside the range of the field, return 0.
; If CONTAINER is #f, use the recorded bitrange.
; BASE-LEN, if non-#f, overrides the base insn length of the insn.
; BASE-LEN is present for architectures like the m32r where there are insns
; smaller than the base insn size (LIW).
;
; Simplifying restrictions [to be relaxed as necessary]:
; - the field must either be totally contained within CONTAINER or totally
;   outside it, partial overlaps aren't handled
; - CONTAINER must be an integral number of bytes, beginning on a
;   byte boundary [simplifies things]
; - both SELF's bitrange and CONTAINER must have the same word length
; - LSB0? of SELF's bitrange and CONTAINER must be the same

(method-make!
 <ifield> 'field-mask
 (lambda (self base-len container)
   (let* ((container (or container (/ifld-bitrange self)))
	  (bitrange (/ifld-bitrange self))
	  (recorded-word-length (bitrange-word-length bitrange))
	  (word-offset (bitrange-word-offset bitrange)))
     (let ((lsb0? (bitrange-lsb0? bitrange))
	   (start (bitrange-start bitrange))
	   (length (bitrange-length bitrange))
	   (word-length (or (and (= word-offset 0) base-len)
			    recorded-word-length))
	   (container-word-offset (bitrange-word-offset container))
	   (container-word-length (bitrange-word-length container)))
       (cond
	; must be same lsb0
	((not (eq? lsb0? (bitrange-lsb0? container)))
	 (error "field-mask: different lsb0? values"))
	((not (= word-length container-word-length))
	 0)
	; container occurs after?
	((<= (+ word-offset word-length) container-word-offset)
	 0)
	; container occurs before?
	((>= word-offset (+ container-word-offset container-word-length))
	 0)
	(else
	 (word-mask start length word-length lsb0? #f))))))
)

(define (ifld-mask ifld base-len container)
  (send ifld 'field-mask base-len container)
)

; Return VALUE inserted into the field's position.
; BASE-LEN, if non-#f, overrides the base insn length of the insn.
; BASE-LEN is present for architectures like the m32r where there are insns
; smaller than the base insn size (LIW).

(method-make!
 <ifield> 'field-value
 (lambda (self base-len value)
   (let* ((bitrange (/ifld-bitrange self))
	  (recorded-word-length (bitrange-word-length bitrange))
	  (word-offset (bitrange-word-offset bitrange))
	  (word-length (or (and (= word-offset 0) base-len)
			   recorded-word-length)))
     (word-value (ifld-start self)
		 (bitrange-length bitrange)
		 word-length
		 (bitrange-lsb0? bitrange) #f
		 value)))
)

; FIXME: confusion with ifld-get-value.
(define (ifld-value f base-len value)
  (send f 'field-value base-len value)
)

; Return a list of ifields required to compute <ifield> F's value.
; Normally this is just F itself.  For multi-ifields it will be more.
; ??? It can also be more if F's value is derived from other fields but
; that isn't supported yet.

(method-make!
 <ifield> 'needed-iflds
 (lambda (self)
   (list self))
)

(define (ifld-needed-iflds f)
  (send f 'needed-iflds)
)

; Extract <ifield> IFLD's value out of VALUE in <insn> INSN.
; VALUE is the entire insn's value if it fits in a word, or is a list
; of values, one per word (not implemented, sigh).
; ??? The instruction's format should specify where the word boundaries are.

(method-make!
 <ifield> 'field-extract
 (lambda (self insn value)
   (let ((base-len (insn-base-mask-length insn)))
     (word-extract (ifld-start self)
		   (ifld-length self)
		   base-len
		   (ifld-lsb0? self)
		   #f ; start is msb
		   value)))
)

(define (ifld-extract ifld value insn)
  (send ifld 'field-extract value insn)
)

; Return a boolean indicating if bit 0 is the least significant bit.

(method-make!
 <ifield> 'field-lsb0?
 (lambda (self)
   (bitrange-lsb0? (/ifld-bitrange self)))
)

(define (ifld-lsb0? f) (send f 'field-lsb0?))

; Return the minimum value of a field.

(method-make!
 <ifield> 'min-value
 (lambda (self)
  (case (mode:class (ifld-mode self))
    ((INT) (- (integer-expt 2 (- (ifld-length self) 1))))
    ((UINT) 0)
    (else (error "unsupported mode class" (mode:class (ifld-mode self))))))
)

; Return the maximum value of a field.

(method-make!
 <ifield> 'max-value
 (lambda (self)
  (case (mode:class (ifld-mode self))
    ((INT) (- (integer-expt 2 (- (ifld-length self) 1)) 1))
    ((UINT) (- (integer-expt 2 (ifld-length self)) 1))
    (else (error "unsupported mode class" (mode:class (ifld-mode self))))))
)

; Create a copy of field F with value VALUE.
; VALUE is either ... ???

(define (ifld-new-value f value)
  (let ((new-f (object-copy f)))
    (ifld-set-value! new-f value)
    new-f)
)

; Change the offset of the word containing an ifield to {word-offset}.

(method-make!
 <ifield> 'set-word-offset!
 (lambda (self word-offset)
   (let ((bitrange (object-copy (/ifld-bitrange self))))
     (bitrange-set-word-offset! bitrange word-offset)
     (elm-set! self 'bitrange bitrange)
     *UNSPECIFIED*))
)
(define (ifld-set-word-offset! f word-offset)
  (send f 'set-word-offset! word-offset)
)

; Return a copy of F with new {word-offset}.

(define (ifld-new-word-offset f word-offset)
  (let ((new-f (object-copy f)))
    (ifld-set-word-offset! new-f word-offset)
    new-f)
)

; Return the bit offset of the word after the word <ifield> F is in.
; What a `word' here is defined by F in its bitrange.

(method-make!
 <ifield> 'next-word
 (lambda (self)
  (let ((br (/ifld-bitrange f)))
    (bitrange-next-word br)))
)

(define (ifld-next-word f) (send f 'next-word))

; Return a boolean indicating if <ifield> F1 precedes <ifield> F2.
; FIXME: Move into a method as different subclasses will need
; different handling.

(define (ifld-precedes? f1 f2)
  (let ((br1 (/ifld-bitrange f1))
	(br2 (/ifld-bitrange f2)))
    (cond ((< (bitrange-word-offset br1) (bitrange-word-offset br2))
	   #t)
	  ((= (bitrange-word-offset br1) (bitrange-word-offset br2))
	   (begin
	     (assert (eq? (bitrange-lsb0? br1) (bitrange-lsb0? br2)))
	     (assert (= (bitrange-word-length br1) (bitrange-word-length br1)))
	     ; ??? revisit
	     (if (bitrange-lsb0? br1)
		 (> (bitrange-start br1) (bitrange-start br2))
		 (< (bitrange-start br1) (bitrange-start br2)))))
	  (else
	   #f)))
)

;; Pretty print an ifield, typically for error messages.

(method-make!
 <ifield> 'pretty-print
 (lambda (self)
   (string-append "(" (obj:str-name self)
		  " " (number->string (ifld-start self))
		  " " (number->string (ifld-length self))
		  ")"))
)

(define (ifld-pretty-print f)
  (send f 'pretty-print)
)

; Parse an ifield definition.
; This is the main routine for building an ifield object from a
; description in the .cpu file.
; All arguments are in raw (non-evaluated) form.
; The result is the parsed object or #f if object isn't for selected mach(s).
;
; Two forms of specification are supported, loosely defined as the RISC way
; and the CISC way.  The reason for the distinction is to simplify ifield
; specification of RISC-like cpus.
; Note that VLIW's are another way.  These are handled like the RISC way, with
; the possible addition of instruction framing (which is, surprise surprise,
; wip).
;
; RISC:
; WORD-OFFSET and WORD-LENGTH are #f.  Insns are assumed to be N copies of
; (isa-default-insn-word-bitsize).  WORD-OFFSET is computed from START.
; START is the offset in bits from the start of the insn.
; FLENGTH is the length of the field in bits.
;
; CISC:
; WORD-OFFSET is the offset in bits from the start to the first byte of the
; word containing the ifield.
; WORD-LENGTH is the length in bits of the word containing the ifield.
; START is the starting bit number in the word.  Bit numbering is taken from
; (current-arch-insn-lsb0?).
; FLENGTH is the length in bits of the ifield.  It is named that way to avoid
; collision with the proc named `length'.
;
; FIXME: More error checking.

(define (/ifield-parse context name comment attrs
		       word-offset word-length start flength follows
		       mode encode decode)
  (logit 2 "Processing ifield " name " ...\n")

  ;; Pick out name first to augment the error context.
  (let* ((name (parse-name context name))
	 (context (context-append-name context name))
	 (atlist (atlist-parse context attrs "cgen_ifld"))
	 (isas (atlist-attr-value atlist 'ISA #f)))

    ; No longer ensure only one isa specified.
    ;(if (!= (length isas) 1)
    ;	(parse-error context "can only specify 1 isa" attrs))

    (if (not (eq? (->bool word-offset)
		  (->bool word-length)))
	(parse-error context "either both or neither of word-offset,word-length can be specified"))

    (if (keep-isa-atlist? atlist #f)

	(let ((isa (current-isa-lookup (car isas)))
	      (word-offset (and word-offset
				(parse-number context word-offset '(0 . 256))))
	      (word-length (and word-length
				(parse-number context word-length '(0 . 128))))
	      ; ??? 0.127 for now
	      (start (parse-number context start '(0 . 127)))
	      ; ??? 0.127 for now
	      (flength (parse-number context flength '(0 . 127)))
	      (lsb0? (current-arch-insn-lsb0?))
	      (mode-obj (parse-mode-name context mode))
	      (follows-obj (/ifld-parse-follows context follows isas))
	      )

	  ; Calculate the <bitrange> object.
	  ; ??? Move positional info to format?
	  (let ((bitrange
		 (if word-offset

		     ; CISC-like. Easy. Everything must be specified.
		     (make <bitrange>
		       word-offset start flength word-length lsb0?)

		     ; RISC-like. Hard. Have to make best choice of start,
		     ; flength. This doesn't have to be perfect, just easily
		     ; explainable.  Cases this doesn't handle can explicitly
		     ; specify word-offset,word-length.
		     ; One can certainly argue the choice of the term
		     ; "RISC-like" is inaccurate.  Perhaps.
		     (let* ((diwb (isa-default-insn-word-bitsize isa))
			    (word-offset (/get-ifld-word-offset start flength diwb lsb0?))
			    (word-length (/get-ifld-word-length start flength diwb lsb0?))
			    (start (- start word-offset))
			    )
		       (make <bitrange>
			 word-offset
			 start
			 flength
			 word-length
			 lsb0?))))
		 )

	    (let ((result
		   (make <ifield>
			 (context-location context)
			 name
			 (parse-comment context comment)
			 atlist
			 mode-obj
			 bitrange
			 (/ifld-parse-encode context encode)
			 (/ifld-parse-decode context decode))))
	      (if follows-obj
		  (ifld-set-follows! result follows-obj))
	      result)))

	; Else ignore entry.
	(begin
	  (logit 2 "Ignoring " name ".\n")
	  #f)))
)

; Subroutine of /ifield-parse to simplify it.
; Given START,FLENGTH, return the "best" choice for the offset to the word
; containing the ifield.
; This is easy to visualize, hard to put into words.
; Imagine several words of size DIWB laid out from the start of the insn.
; On top of that lay the ifield.
; Now pick the minimal set of words that are required to contain the ifield.
; That's what we want.
; No claim is made that this is always the correct choice for any
; particular architecture.  For those where this isn't correct, the ifield
; must be fully specified (i.e. word-offset,word-length explicitly specified).

(define (/get-ifld-word-offset start flength diwb lsb0?)
  (if lsb0?
      ; Convert to non-lsb0 case, then it's easy.
      ; NOTE: The conversion is seemingly wrong because `start' is misnamed.
      ; It's now `end'.
      (set! start (+ (- start flength) 1)))
  (- start (remainder start diwb))
)

; Subroutine of /ifield-parse to simplify it.
; Given START,FLENGTH, return the "best" choice for the length of the word
; containing the ifield.
; DIWB = default insn word bitsize
; See -get-ifld-word-offset for more info.

(define (/get-ifld-word-length start flength diwb lsb0?)
  (if lsb0?
      ; Convert to non-lsb0 case, then it's easy.
      ; NOTE: The conversion is seemingly wrong because `start' is misnamed.
      ; It's now `end'.
      (set! start (+ (- start flength) 1)))
  (* (quotient (+ (remainder start diwb) flength (- diwb 1))
	       diwb)
     diwb)
)

; Read an instruction field description.
; This is the main routine for analyzing instruction fields in the .cpu file.
; CONTEXT is a <context> object for error messages.
; ARG-LIST is an associative list of field name and field value.
; /ifield-parse is invoked to create the <ifield> object.

(define (/ifield-read context . arg-list)
  (let (
	(name #f)
	(comment "")
	(attrs nil)
	(word-offset #f)
	(word-length #f)
	(start 0)
	; FIXME: Hobbit computes the wrong symbol for `length'
	; in the `case' expression below because there is a local var
	; of the same name ("__1" gets appended to the symbol name).
	; As a workaround we name it "length-".
	(length- 0)
	(follows #f)
	(mode 'UINT)
	(encode #f)
	(decode #f)
	)

    ; Loop over each element in ARG-LIST, recording what's found.
    (let loop ((arg-list arg-list))
      (if (null? arg-list)
	  nil
	  (let ((arg (car arg-list))
		(elm-name (caar arg-list)))
	    (case elm-name
	      ((name) (set! name (cadr arg)))
	      ((comment) (set! comment (cadr arg)))
	      ((attrs) (set! attrs (cdr arg)))
	      ((mode) (set! mode (cadr arg)))
	      ((word-offset) (set! word-offset (cadr arg)))
	      ((word-length) (set! word-length (cadr arg)))
	      ((start) (set! start (cadr arg)))
	      ((length) (set! length- (cadr arg)))
	      ((follows) (set! follows (cadr arg)))
	      ((encode) (set! encode (cdr arg)))
	      ((decode) (set! decode (cdr arg)))
	      (else (parse-error context "invalid ifield arg" arg)))
	    (loop (cdr arg-list)))))

    ; See if encode/decode were specified as "unspecified".
    ; This happens with shorthand macros.
    (if (and (pair? encode)
	     (eq? (car encode) #f))
	(set! encode #f))
    (if (and (pair? decode)
	     (eq? (car decode) #f))
	(set! decode #f))

    ; Now that we've identified the elements, build the object.
    (/ifield-parse context name comment attrs
		   word-offset word-length start length- follows
		   mode encode decode))
)

; Parse a `follows' spec.

(define (/ifld-parse-follows context follows isas)
  (if follows
      (let ((follows-obj (current-op-lookup follows isas)))
	(if (not follows-obj)
	    (parse-error context "unknown operand to follow" follows))
	follows-obj)
      #f)
)

; Do common parts of <ifield> encode/decode processing.

(define (/ifld-parse-encode-decode context which value)
  (if value
      (begin
	(if (or (not (list? value))
		(not (= (length value) 2))
		(not (list? (car value)))
		(not (= (length (car value)) 2))
		(not (list? (cadr value))))
	    (parse-error context
			 (string-append "bad ifield " which " spec")
			 value))
	(if (or (not (> (length (cadr value)) 2))
		(not (mode:lookup (cadr (cadr value)))))
	    (parse-error context
			 (string-append which " expression must have a mode")
			 value))))
  value
)

; Parse an <ifield> encode spec.

(define (/ifld-parse-encode context encode)
  (/ifld-parse-encode-decode context "encode" encode)
)

; Parse an <ifield> decode spec.

(define (/ifld-parse-decode context decode)
  (/ifld-parse-encode-decode context "decode" decode)
)

; Define an instruction field object, name/value pair list version.

(define define-ifield
  (lambda arg-list
    (let ((f (apply /ifield-read (cons (make-current-context "define-ifield")
				       arg-list))))
      (if f
	  (current-ifld-add! f))
      f))
)

; Define an instruction field object, all arguments specified.
; ??? Leave out word-offset,word-length,follows for now (RISC version).
; FIXME: Eventually this should be fixed to take *all* arguments.

(define (define-full-ifield name comment attrs start length mode encode decode)
  (let ((f (/ifield-parse (make-current-context "define-full-ifield")
			  name comment attrs
			  #f #f start length #f mode encode decode)))
    (if f
	(current-ifld-add! f))
    f)
)

(define (/ifield-add-commands!)
  (reader-add-command! 'define-ifield
		       "\
Define an instruction field, name/value pair list version.
"
		       nil 'arg-list define-ifield)
  (reader-add-command! 'define-full-ifield
		       "\
Define an instruction field, all arguments specified.
"
		       nil '(name comment attrs start length mode encode decode)
		       define-full-ifield)
  (reader-add-command! 'define-multi-ifield
		       "\
Define an instruction multi-field, name/value pair list version.
"
		       nil 'arg-list define-multi-ifield)
  (reader-add-command! 'define-full-multi-ifield
		       "\
Define an instruction multi-field, all arguments specified.
"
		       nil '(name comment attrs mode subflds insert extract)
		       define-full-multi-ifield)

  *UNSPECIFIED*
)

; Instruction fields consisting of multiple parts.

(define <multi-ifield>
  (class-make '<multi-ifield>
	      '(<ifield>)
	      '(
		; List of <ifield> objects.
		subfields
		; rtl to set SUBFIELDS from self
		insert
		; rtl to set self from SUBFIELDS
		extract
		)
	      nil)
)

(method-make-make! <multi-ifield> '(name comment attrs
				    mode bitrange encode decode
				    subfields insert extract))

; Accessors

(define-getters <multi-ifield> multi-ifld
  (subfields insert extract)
)

; Return a boolean indicating if X is an <ifield>.

(define (multi-ifield? x) (class-instance? <multi-ifield> x))

(define (non-multi-ifields ifld-list)
  (find (lambda (ifld) (not (multi-ifield? ifld))) ifld-list)
)

(define (non-derived-ifields ifld-list)
  (find (lambda (ifld) (not (derived-ifield? ifld))) ifld-list)
)

; Return the starting bit number of the first field.

(method-make!
 <multi-ifield> 'field-start
 (lambda (self)
   (apply min (map (lambda (f) (ifld-start f)) (elm-get self 'subfields))))
)

; Return the total length.

(method-make!
 <multi-ifield> 'field-length
 (lambda (self)
   (apply + (map ifld-length (elm-get self 'subfields))))
)

; Return the bit offset of the word after the last word SELF is in.
; What a `word' here is defined by subfields in their bitranges.

(method-make!
 <multi-ifield> 'next-word
 (lambda (self)
   (apply max (map (lambda (f)
		     (bitrange-next-word (/ifld-bitrange f)))
		   (multi-ifld-subfields self))))
)

; Return mask of field in bitrange CONTAINER.

(method-make!
 <multi-ifield> 'field-mask
 (lambda (self base-len container)
   (apply + (map (lambda (f) (ifld-mask f base-len container)) (elm-get self 'subfields))))
)

; Return VALUE inserted into the field's position.
; The value is spread out over the various subfields in sorted order.
; We assume the subfields have been sorted by starting bit position.

(method-make!
 <multi-ifield> 'field-value
 (lambda (self base-len value)
   (apply + (map (lambda (f) (ifld-value f base-len value)) (elm-get self 'subfields))))
)

; Return a list of ifields required to compute the field's value.

(method-make!
 <multi-ifield> 'needed-iflds
 (lambda (self)
   (cons self (elm-get self 'subfields)))
)

; Extract <ifield> IFLD's value out of VALUE in <insn> INSN.
; VALUE is the entire insn's value if it fits in a word, or is a list
; of values, one per word (not implemented, sigh).
; ??? The instruction's format should specify where the word boundaries are.

(method-make!
 <multi-ifield> 'field-extract
 (lambda (self insn value)
   (let* ((subflds (sort-ifield-list (elm-get self 'subfields)
				     (not (ifld-lsb0? self))))
	  (subvals (map (lambda (subfld)
			  (ifld-extract subfld insn value))
			subflds))
	 )
     ; We have each subfield's value, now concatenate them.
     (letrec ((plus-scan (lambda (lengths current)
			   ; do the -1 drop here as it's easier
			   (if (null? (cdr lengths))
			       nil
			       (cons current
				     (plus-scan (cdr lengths)
						(+ current (car lengths))))))))
       (apply + (map logsll
		     subvals
		     (plus-scan (map ifld-length subflds) 0))))))
)

; Return a boolean indicating if bit 0 is the least significant bit.

(method-make!
 <multi-ifield> 'field-lsb0?
 (lambda (self)
   (ifld-lsb0? (car (elm-get self 'subfields))))
)

;; Pretty print a multi-ifield, typically for error messages.

(method-make!
 <multi-ifield> 'pretty-print
 (lambda (self)
   (string-append "(" (obj:str-name self)
		  (string-map (lambda (f)
				(string-append " " (ifld-pretty-print f)))
			      (elm-get self 'subfields))
		  ")"))
)

; Multi-ifield parsing.

; Subroutine of /multi-ifield-parse to build the default insert expression.

(define (/multi-ifield-make-default-insert container-name subfields)
  (let* ((lengths (map ifld-length subfields))
	 (shifts (list-tail-drop 1 (plus-scan (cons 0 lengths)))))
    ; Build RTL expression to shift and mask each ifield into right spot.
    (let ((exprs (map (lambda (f length shift)
			(rtx-make 'and (rtx-make 'srl container-name shift)
				  (mask length)))
		      subfields lengths shifts)))
      ; Now set each ifield with their respective values.
      (apply rtx-make (cons 'sequence
			    (cons nil
				  (map (lambda (f expr)
					 (rtx-make-set f expr))
				       subfields exprs))))))
)

; Subroutine of /multi-ifield-parse to build the default extract expression.

(define (/multi-ifield-make-default-extract container-name subfields)
  (let* ((lengths (map ifld-length subfields))
	 (shifts (list-tail-drop 1 (plus-scan (cons 0 lengths)))))
    ; Build RTL expression to shift and mask each ifield into right spot.
    (let ((exprs (map (lambda (f length shift)
			(rtx-make 'sll (rtx-make 'and (obj:name f)
						 (mask length))
				  shift))
		      subfields lengths shifts)))
      ; Now set {container-name} with all the values or'd together.
      (rtx-make-set container-name
		    (rtx-combine 'or exprs))))
)

; Parse a multi-ifield spec.
; This is the main routine for building the object from the .cpu file.
; All arguments are in raw (non-evaluated) form.
; The result is the parsed object or #f if object isn't for selected mach(s).

(define (/multi-ifield-parse context name comment attrs mode
			     subfields insert extract encode decode)
  (logit 2 "Processing multi-ifield element " name " ...\n")

  (if (null? subfields)
      (parse-error context "empty subfield list" subfields))

  ;; Pick out name first to augment the error context.
  (let* ((name (parse-name context name))
	 (context (context-append-name context name))
	 (atlist (atlist-parse context attrs "cgen_ifld"))
	 (isas (atlist-attr-value atlist 'ISA #f)))

    ; No longer ensure only one isa specified.
    ; (if (!= (length isas) 1)
    ;     (parse-error context "can only specify 1 isa" attrs))

    (if (keep-isa-atlist? atlist #f)

	(begin
	  (let ((result (new <multi-ifield>))
		(subfields (map (lambda (subfld)
				  (let ((f (current-ifld-lookup subfld)))
				    (if (not f)
					(parse-error context "unknown ifield"
						     subfld))
				    f))
				subfields)))

	    (elm-xset! result 'name name)
	    (elm-xset! result 'comment (parse-comment context comment))
	    (elm-xset! result 'attrs
		       ;; multi-ifields are always VIRTUAL
		       (atlist-parse context (cons 'VIRTUAL attrs)
				     "multi-ifield"))
	    (elm-xset! result 'mode (parse-mode-name context mode))
	    (elm-xset! result 'encode (/ifld-parse-encode context encode))
	    (elm-xset! result 'decode (/ifld-parse-encode context decode))
	    (elm-xset! result 'bitrange "multi-ifields don't have bitranges") ;; FIXME
	    (if insert
		(elm-xset! result 'insert insert)
		(elm-xset! result 'insert
			   (/multi-ifield-make-default-insert name subfields)))
	    (if extract
		(elm-xset! result 'extract extract)
		(elm-xset! result 'extract
			   (/multi-ifield-make-default-extract name subfields)))
	    (elm-xset! result 'subfields subfields)
	    result))

	; else don't keep isa
	#f))
)

; Read an instruction multi-ifield.
; This is the main routine for analyzing multi-ifields in the .cpu file.
; CONTEXT is a <context> object for error messages.
; ARG-LIST is an associative list of field name and field value.
; /multi-ifield-parse is invoked to create the `multi-ifield' object.

(define (/multi-ifield-read context . arg-list)
  (let (
	(name nil)
	(comment "")
	(attrs nil)
	(mode 'UINT)
	(subflds nil)
	(insert #f)
	(extract #f)
	(encode #f)
	(decode #f)
	)

    ; Loop over each element in ARG-LIST, recording what's found.
    (let loop ((arg-list arg-list))
      (if (null? arg-list)
	  nil
	  (let ((arg (car arg-list))
		(elm-name (caar arg-list)))
	    (case elm-name
	      ((name) (set! name (cadr arg)))
	      ((comment) (set! comment (cadr arg)))
	      ((attrs) (set! attrs (cdr arg)))
	      ((mode) (set! mode (cadr arg)))
	      ((subfields) (set! subflds (cdr arg)))
	      ((insert) (set! insert (cadr arg)))
	      ((extract) (set! extract (cadr arg)))
	      ((encode) (set! encode (cdr arg)))
	      ((decode) (set! decode (cdr arg)))
	      (else (parse-error context "invalid ifield arg" arg)))
	    (loop (cdr arg-list)))))

    ; Now that we've identified the elements, build the object.
    (/multi-ifield-parse context name comment attrs mode subflds
			 insert extract encode decode))
)

; Define an instruction multi-field object, name/value pair list version.

(define define-multi-ifield
  (lambda arg-list
    (let ((f (apply /multi-ifield-read (cons (make-current-context "define-multi-ifield")
					     arg-list))))
      (if f
	  (current-ifld-add! f))
      f))
)

; Define an instruction multi-field object, all arguments specified.
; FIXME: encode/decode arguments are missing.

(define (define-full-multi-ifield name comment attrs mode subflds insert extract)
  (let ((f (/multi-ifield-parse (make-current-context "define-full-multi-ifield")
				name comment attrs
				mode subflds insert extract #f #f)))
    (current-ifld-add! f)
    f)
)

; Derived ifields (ifields based on one or more other ifields).
; These support the complicated requirements of CISC instructions
; where one "ifield" is actually a placeholder for an addressing mode
; which can consist of several ifields.
; These are also intended to support other complex ifield usage.
;
; Derived ifields are (currently) always machine generated from other
; elements of the description file so there is no reader support.
;
; ??? experimental and wip!
; ??? These are kind of like multi-ifields but I don't want to disturb them
; while this is still experimental.

(define <derived-ifield>
  (class-make '<derived-ifield>
	      '(<ifield>)
	      '(
		; Operand that uses this ifield.
		; Unlike other ifields, derived ifields have a one-to-one
		; correspondence with the operand that uses them.
		; ??? Not true in -anyof-merge-subchoices.
		owner

		; List of ifields that make up this ifield.
		subfields
		)
	      nil)
)

(method-make!
 <derived-ifield> 'needed-iflds
 (lambda (self)
   (find (lambda (ifld) (not (ifld-constant? ifld)))
	 (elm-get self 'subfields)))
)

(method-make!
 <derived-ifield> 'make!
 (lambda (self name comment attrs owner subfields)
   (elm-set! self 'name name)
   (elm-set! self 'comment comment)
   (elm-set! self 'attrs attrs)
   (elm-set! self 'mode UINT)
   (elm-set! self 'bitrange (make <bitrange> 0 0 0 0 #f))
   (elm-set! self 'encode #f)
   (elm-set! self 'decode #f)
   (elm-set! self 'owner owner)
   (elm-set! self 'subfields subfields)
   self)
)

; Accessors.

(define-getters <derived-ifield> derived-ifield (owner subfields))

(define-setters <derived-ifield> derived-ifield (owner subfields))

(define (derived-ifield? x) (class-instance? <derived-ifield> x))

; Return a boolean indicating if F is a derived ifield with a derived operand
; for a value.
; ??? The former might imply the latter so some simplification may be possible.

(define (ifld-derived-operand? f)
  (and (derived-ifield? f)
       (derived-operand? (ifld-get-value f)))
)

; Return the bit offset of the word after the last word SELF is in.
; What a `word' here is defined by subfields in their bitranges.

(method-make!
 <derived-ifield> 'next-word
 (lambda (self)
   (apply max (map (lambda (f)
		     (bitrange-next-word (/ifld-bitrange f)))
		   (derived-ifield-subfields self))))
)

; Return a list of all base (non-derived) ifields in IFLD.
; NOTE: multi-ifields are *not* reduced to their sub-ifields.

(define (ifld-base-ifields ifld)
  (cond ((derived-ifield? ifld) (ifields-base-ifields (derived-ifield-subfields ifld)))
	;;((multi-ifield? ifld) (ifields-base-ifields (multi-ifld-subfields ifld)))
	(else (list ifld)))
)

; Collect all base (non-derived) ifields in IFLD-LIST.
; NOTE: multi-ifields are *not* reduced to their sub-ifields.

(define (ifields-base-ifields ifld-list)
  (collect ifld-base-ifields ifld-list)
)

; Return a list of all simple ifields in IFLD.
; NOTE: multi-ifields *are* reduced to their sub-ifields.

(define (ifld-simple-ifields ifld)
  (cond ((derived-ifield? ifld) (ifields-simple-ifields (derived-ifield-subfields ifld)))
	((multi-ifield? ifld) (ifields-simple-ifields (multi-ifld-subfields ifld)))
	(else (list ifld)))
)

; Collect all simple ifields in IFLD-LIST.
; NOTE: multi-ifields *are* reduced to their sub-ifields.

(define (ifields-simple-ifields ifld-list)
  (collect ifld-simple-ifields ifld-list)
)

; Misc. utilities.

; Sort a list of fields (sorted by the starting bit number).
; This must be carefully defined to pass through Hobbit.
; (define foo (if x bar baz)) is ok.
; (if x (define foo bar) (define foo baz)) is not ok.
;
; ??? Usually there aren't that many fields and the range of values is fixed,
; so I think this needn't use a general purpose sort routine (should it become
; an issue).

(define sort-ifield-list
  (if (and (defined? 'cgh-qsort) (defined? 'cgh-qsort-int-cmp))
      (lambda (fld-list up?)
	(cgh-qsort fld-list
		   (if up?
		       (lambda (a b)
			 (cgh-qsort-int-cmp (ifld-start a)
					    (ifld-start b)))
		       (lambda (a b)
			 (- (cgh-qsort-int-cmp (ifld-start a)
					       (ifld-start b)))))))
      (lambda (fld-list up?)
	(sort fld-list
	      (if up?
		  (lambda (a b) (< (ifld-start a)
				   (ifld-start b)))
		  (lambda (a b) (> (ifld-start a)
				   (ifld-start b)))))))
)

; Return a boolean indicating if field F extends beyond the base insn.

(define (ifld-beyond-base? f)
  (> (ifld-word-offset f) 0)
)

; Return <hardware> object to use to hold value of <ifield> F.
; i.e. one of h-uint, h-sint.
; NB: Should be defined in terms of `hardware-for-mode'.
(define (ifld-hw-type f)
  (case (mode:class (ifld-mode f))
    ((INT) h-sint)
    ((UINT) h-uint)
    (else (error "unsupported mode class" (mode:class (ifld-mode f)))))
)

; Builtin fields, attributes, init/fini support.

; The f-nil field is a placeholder when building operands out of hardware
; elements that aren't indexed by an instruction field (scalars).
(define f-nil #f)

(define (ifld-nil? f)
  (eq? (obj:name f) 'f-nil)
)

; The f-anyof field is a placeholder when building "anyof" operands.
(define f-anyof #f)

(define (ifld-anyof? f)
  (eq? (obj:name f) 'f-anyof)
)

; Return a boolean indicating if F is an anyof ifield with an anyof operand
; for a value.
; ??? The former implies the latter so some simplification is possible.

(define (ifld-anyof-operand? f)
  (and (ifld-anyof? f)
       (anyof-operand? (ifld-get-value f)))
)

; Called before loading the .cpu file to initialize.

(define (ifield-init!)
  (/ifield-add-commands!)

  *UNSPECIFIED*
)

; Called before loading the .cpu file to create any builtins.

(define (ifield-builtin!)
  ; Standard ifield attributes.
  ; ??? Some of these can be combined into one, booleans are easier to
  ; work with.
  (define-attr '(for ifield operand) '(type boolean) '(name PCREL-ADDR)
    '(comment "pc relative address"))
  (define-attr '(for ifield operand) '(type boolean) '(name ABS-ADDR)
    '(comment "absolute address"))
  (define-attr '(for ifield) '(type boolean) '(name RESERVED)
    '(comment "field is reserved"))
  (define-attr '(for ifield operand) '(type boolean) '(name SIGN-OPT)
    '(comment "value is signed or unsigned"))
  ; ??? This is an internal attribute for implementation purposes only.
  ; To be revisited.
  (define-attr '(for ifield operand) '(type boolean) '(name SIGNED)
    '(comment "value is unsigned"))
  ; Also (defined elsewhere): VIRTUAL

  (set! f-nil (make <ifield> (builtin-location)
		    'f-nil "empty ifield"
		    (atlist-cons (all-isas-attr) nil)
		    UINT
		    (make <bitrange> 0 0 0 0 #f)
		    #f #f)) ; encode/decode
  (current-ifld-add! f-nil)

  (set! f-anyof (make <ifield> (builtin-location)
		      'f-anyof "placeholder for anyof operands"
		      (atlist-cons (all-isas-attr) nil)
		      UINT
		      (make <bitrange> 0 0 0 0 #f)
		      #f #f)) ; encode/decode
  (current-ifld-add! f-anyof)

  *UNSPECIFIED*
)

; Called after the .cpu file has been read in.

(define (ifield-finish!)
  *UNSPECIFIED*
)
@


1.27
log
@	* hardware.scm (hw-pc?): New function.
	* ifield.scm (ifld-signed?): New function.
	* iformat.scm (ifmt-analyze): Call insn-cti-attr? instead of insn-cti?.
	* insn.scm (insn-cti-attr?): Renamed from insn-ctl?.
	(insn-cti?): New function.
	* rtl.scm (/hw): Create <pc> object for pcs.
	* semantics.scm (/build-reg-operand!): New args ref-type, sem-attrs.
	All callers updated.  Watch for sets to the pc.
	(semantic-attrs): Watch for sets to the pc.
	* sid.scm (<pc> cxmake-get): Handle raw-reg.
	* sim.scm (<pc> cxmake-get): Handle raw-reg.
	(<operand> cxmake-get): Add debugging printf.
	* utils-gen.scm (/gen-ifld-extract-base): Emit calls to
	EXTRACT_[LM]SB0_LG[SU]INT for values > 32 bits.
	(/gen-extract-word): Ditto.

	* utils.scm (gen-c-hex-constant): New function.
	* utils-sim.scm (/gen-decode-insn-entry): Call it.
@
text
@d340 1
a340 1
  (let ((new-f (object-copy-top f)))
d350 1
a350 1
   (let ((bitrange (object-copy-top (/ifld-bitrange self))))
d362 1
a362 1
  (let ((new-f (object-copy-top f)))
@


1.26
log
@	Specify isa(s) when doing ifield, operand, insn lookups.
	ACU = all callers updated.
	* attr.scm (/attr-eval): Call rtx-value instead of rtx-eval-with-estate.
	* enum.scm (define-full-insn-enum): Pass isa-name-list to
	current-ifld-lookup.
	* html.scm (get-insn-properties): Pass isa-name-list to
	current-op-lookup.
	* ifield.scm (/ifld-parse-follows): New arg isas, ACU.
	* insn.scm (/parse-insn-format-symbol): New arg isa-name-list, ACU.
	(/parse-insn-format-list, /parse-insn-iformat-iflds): Ditto.
	(/parse-insn-format, syntax-break-out): Ditto.
	* mach.scm (obj-filter-by-isa): New function.
	(current-ifld-lookup): New optional arg maybe-isa-name-list.
	(/ifld-already-defined?, /op-already-defined?): Simplify.
	(current-op-lookup): New optional arg maybe-isa-name-list.
	(current-insn-lookup): New arg isa-name-list, ACU.
	(/insn-already-defined?, /minsn-already-defined?): Simplify.
	(current-minsn-lookup): New arg isa-name-list, ACU.
	* minsn.scm (/minsn-compute-iflds): Pass isa-name-list to
	current-op-lookup.
	* opc-itab.scm (compute-syntax): New arg isa-name-list, ACU.
	(gen-syntax-entry): Ditto.
	* operand.scm (/operand-parse): Pass isa-name-list to
	current-ifld-lookup.
	(/derived-parse-encoding): New arg isa-name-list, ACU.
	(/derived-parse-ifield-assertion): Ditto.
	(/derived-operand-parse): Pass isa-name-list to current-op-lookup.
	(/anyof-parse-choice): Ditto.
	(anyof-satisfies-assertions?): Pass context to rtx-solve.
	(/anyof-merge-syntax): New arg container, ACU.
	(operand-builtin!): Add pc to all isas.
	* rtl-c.scm (estate-make-for-rtl-c): Delete arg extra-vars-alist, ACU.
	(estate-make-for-rtl-c++, rtl-c-expr-parsed): Ditto.
	(rtl-c-parsed, rtl-c++-parsed): Ditto.
	(rtl-c): New arg isa-name-list, ACU.
	(rtl-c-expr, rtl-c++): Ditto.
	(closure): New arg isa-name-list, ACU.
	* rtl-traverse.scm (/make-cstate): New arg isa-name-list, ACU.
	(/cstate-isas): New function.
	(/rtx-canon-symbol-list): New function.
	(/rtx-canon-env-stack): Renamed from /rtx-canon-env, ACU.
	updated.
	(/rtx-make-canon-table): Rename ENV to ENVSTACK, new entry SYMBOLLIST.
	(/rtx-canon-rtx-operand): Pass isa list to current-op-lookup.
	(/rtx-canon-rtx-ref, /rtx-canon): Ditto.
	(rtx-canonicalize): New arg isa-name-list, ACU.
	(rtx-canonicalize-stmt): Delete.
	(tstate-make): New arg isas, ACU.
	(tstate-isas, tstate--set-isas!): New functions.
	(tstate-env-stack): Renamed from tstate-env, ACU.
	(tstate-set-env-stack!): Renamed from tstate-set-env!, ACU.
	(tstate-make-closure): Renamed from tstate-new-env, new arg
	isa-name-list, ACU.
	(/rtx-traverse-env): Delete.
	(/rtx-make-traverser-table): Rename ENV to ENVSTACK, new entry
	SUMBOLLIST.
	(/rtx-traverse): Include conditional flag in dump output.
	Update isa,envstack for closures.  Pass isa list to current-op-lookup.
	(<eval-state>): New member isas.  Rename env to env-stack.
	(<eval-state> vmake!): Handle #:isas.  #:env renamed to #:env-stack.
	(<eval-state>): New getter/setter for isas.  Rename env getter/setter
	to env-stack.
	(estate-make-for-eval): Provide #:isas.
	(estate-make-closure): Renamed from estate-new-env.  New arg
	isa-name-list, ACU.
	* rtl-xform.scm (/rtx-simplify-expr-fn): Handle closures.
	(/rtx-trim-args): ENV renamed to ENVSTACK.  Ad ITERATION, SYMBOLLIST.
	(/rtx-trim-for-doc): Handle closures.
	* rtl.scm (/rtx-valid-types): Rename ENV to ENVSTACK.  Add ITERATION,
	SYMBOLLIST.
	(rtx-env-var-list): Delete.
	(rtx-env-make): Handle already-compiled environments.
	(rtx-var-alist-to-env): New function.
	(rtx-var-alist-to-closure-env-stack, rtx-make-env-stack): New functions.
	(rtx-env-stack-dump): Renamed from rtx-env-dump, ACU.
	(rtx-operand-obj): New arg isa-name-list, ACU.
	(rtx-closure-isas, rtx-closure-env-stack, rtx-closure-expr): New
	functions.
	* rtx-funcs.scm (closure): New arg isa-name-list, reorder args, ACU.
	* sem-frags.scm (<sfrag>): Delete member compiled-semantics.
	(/frag-compute-desired-frags): Minor simplification.
	(/frag-pick-best): Ditto.
	* sid-cpu.scm (gen-semantic-code): Require canonical rtl.
	(/gen-sfrag-code): Update.
	* sim-cpu.scm (gen-semantic-code): Require canonical rtl.
	* utils-cgen.scm (sanitize): New arg isa-name-list, ACU.
	* utils.scm (non-null-intersection?): New function.
@
text
@d173 6
@


1.25
log
@	Record bitset attributes internally as a list.
	Record rtx attribute values internally as ((rtx-expr)).
	* attr.scm (bitset-attr?): Delete, unused.
	(<bitset-attribute> parse-value): Rewrite.
	(/attr-parse): Rewrite bitset default value processing.
	(/attr-read): Pick out values of scalar attributes to distinguish
	them from bitset values which are a list.
	Fix spelling errors for processing of default values.
	Handle string attributes.
	(bitset-attr->list): Delete, all callers updated.
	(/bitset-attr->charmask): Renamed from bitset-attr->charmask.
	All callers updated.
	(atlist-source-form): Rewrite.
	* hardware.scm (<hardware-base> 'get-isas): Update recognition
	of all isas.
	(hardware-builtin!): Update spec of ISA attribute, (ISA foo,bar)
	-> (ISA foo bar).
	* intrinsics.scm (target:belongs-to-group?): Update, bitset attribute
	values are now lists.
	* mach.scm (def-isa-attr!): Update, bitset attribute values,
	including the default, are now lists.
	(all-isas-attr-value): Result is now a list.
	* doc/rtl.texi: Clean up pass over attribute docs.
@
text
@d471 1
a471 1
	      (follows-obj (/ifld-parse-follows context follows))
d623 1
a623 1
(define (/ifld-parse-follows context follows)
d625 1
a625 1
      (let ((follows-obj (current-op-lookup follows)))
@


1.24
log
@	* ifield.scm (<ifield>, value): Provide default initial value.
	(ifield-encode-mode): Delete
	(ifield-decode-mode): Delete duplicate definition.
	(<derived-ifield>, 'make!): Initialize members encode, decode.
@
text
@d448 1
a448 1
	 (isas (bitset-attr->list (atlist-attr-value atlist 'ISA #f))))
d906 1
a906 1
	 (isas (bitset-attr->list (atlist-attr-value atlist 'ISA #f))))
@


1.23
log
@	* cos.scm (/method-lookup): Delete arg virtual?, all callers updated.
	(method-proc): Delete.
	(method-make-virtual!, method-make-virtual-forward!): Delete.
	* ifield.scm (<ifield> field-start): Update.
	(<ifield> field-length, pretty-print): Update.
	(<multi-ifield> field-length, field-start, pretty-print): Update.
	* sid-cpu.scm (/gen-hardware-struct): Use gen-defn instead of gen-decl.
	* sid.scm (<scalar> gen-sym-defn): Renamed from gen-sym-decl.
	(<array> gen-sym-defn): Ditto.
	(<hardware-base> gen-defn): Renamed from gen-defn.
	(<hw-register> gen-type): Update.
	(<hw-register> gen-defn): Renamed from gen-sym-decl, rewrite.
	(<hw-memory>, <hw-address>, <hw-iaddress> gen-type): Update.
	(<hw-memory>, <hw-address> gen-defn): Renamed from gen-sym-decl.
	(<hw-immediate> gen-type): Update.
	(<hw-immediate> gen-defn): Renamed from gen-sym-decl, rewrite.
	* sim-cpu.scm (/gen-hardware-struct): Use gen-defn instead of gen-decl.
	* sim.scm (<scalar> gen-sym-defn): Renamed from gen-sym-decl.
	(<array> gen-sym-defn): Ditto.
	(<hardware-base> gen-defn): Renamed from gen-defn.
	(<hw-register> gen-type): Update.
	(<hw-register> gen-defn): Renamed from gen-sym-decl, rewrite.
	(<hw-memory>, <hw-address>, <hw-iaddress> gen-type): Update.
	(<hw-memory>, <hw-address> gen-defn): Renamed from gen-sym-decl.
	(<hw-immediate> gen-type): Update.
	(<hw-immediate> gen-defn): Renamed from gen-sym-decl, rewrite.
@
text
@d54 1
a54 1
		; Value of field, if there is one.
d56 1
a56 1
		value
d81 3
a83 2
; Return the mode of the value passed to the encode rtl.
; This is the mode of the result of the decode rtl.
d85 7
a91 7
(define (ifld-encode-mode f)
  (if (ifld-decode f)
      ; cadr/cadr gets WI in ((value pc) (sra WI ...))
      ; FIXME: That's wrong for a fully canonical expression like
      ; ((value pc) (sra () WI ...)).
      (mode:lookup (cadr (cadr (ifld-decode f))))
      (ifld-mode f))
a93 5
; Return the mode of the value passed to the decode rtl.
; This is the mode of the field.

(define (ifld-decode-mode f) (ifld-mode f))

d1058 2
a1161 13
; Return the mode of the decoded value of <ifield> F.
; ??? This is made easy because we require the decode expression to have
; an explicit mode.

(define (ifld-decode-mode f)
  (if (not (elm-bound? f 'decode))
      (ifld-mode f)
      (let ((d (ifld-decode f)))
	(if d
	    (mode:lookup (cadr (cadr d)))
	    (ifld-mode f))))
)

@


1.22
log
@	Clean up pass of mode handling.
	Make use of mode name vs <mode> object more consistent and clear.
	* hardware.scm (/keyword-read): Default mode to the mode name,
	not the <mode> object.
	(/hw-parse-indices): Parse mode name and pass mode object to
	<hw-asm> constructor.
	(/hw-parse-values): Ditto.
	(<hw-register> parse!): Pass mode name to /hw-parse-indices
	and /hw-parse-values.
	(<hw-memory> parse!): Ditto.
	(<hw-address> parse!): Ditto.
	* mode.scm (/mode-table): New global, replaces mode-list.
	Modes stored in hashtable instead of list.
	(/mode-class-table): New global.
	(mode-list-non-alias-values): Update.
	(mode:eq?, mode-compatible?, mode:add!): Update.
	(mode:lookup): Restrict arg to the mode's name.  All callers updated.
	(mode-maybe-lookup): New function.
	(mode-real-name): Restrict arg to a <mode> object.  All callers updated.
	(mode-real-mode, mode-sem-mode, mode-bigger?): Ditto.
	(mode-find, mode-set-word-modes!): Update
	(mode-ensure-word-sizes-defined): Update.
	(/sort-mode-classes!): New function.
	(mode-builtin!): Update.  Sort mode classes here.
	(mode-finish!): Sort mode classes here too.
	* rtl-c.scm (/rtl-c-get): Restrict mode arg to a <mode> object.
	All callers updated.
	(rtl-c-set-quiet): Allow mode to be name of object.
	(rtl-c-set-trace): Ditto.
	* rtl-traverse.scm (rtl-eval-with-estate): Restrict mode arg to
	<mode> object.  All callers updated.
	* rtl.scm (rtx-sem-mode): Restrict arg to <mode> object.
	(rtx-lazy-sem-mode): Ditto.
	(<rtx-temp> make!): Assert mode arg is a <mode> object.
	(rtx-env-make): Allow var-list modes to be name or object.
	* sem-frags.scm (/frag-expr-assq-locals): New function.
	(/frag-compute-locals!): Call it.
	(/sfrag-create-cse-mapping): Renamed from sfrag-create-cse-mapping.
	All callers updated.
	* semantics.scm (/build-mem-operand!): Handle mode aliases.
@
text
@d100 1
a100 1
(method-make-virtual!
d110 1
a110 1
(method-make-virtual!
d400 1
a400 1
(method-make-virtual!
d760 1
a760 1
(method-make-virtual!
d768 1
a768 1
(method-make-virtual!
d848 1
a848 1
(method-make-virtual!
@


1.21
log
@	Add support for controlling warnings/errors.
	Add tests for iformat description errors.
	* dev.scm (cload): New option #:diag.
	* read.scm (<reader>): New member verify-iformat?.
	(/parse-diagnostic, parse-warning): New functions.
	(parse-error): Guts moved to /parse-diagnostic.
	(/set-diagnostic-options!): New function.
	(cpu-load): New arg diagnostic-options, all callers updated.
	Recognize -w diagnostic-option-list.
	* ifield.scm (ifields-base-ifields): Move here from iformat.scm.
	(ifld-simple-ifields, ifields-simple-ifields): New function.
	* insn.scm (/parse-insn-format-iflds): New function.
	(/parse-insn-format): Guts moved to /parse-insn-format-iflds.
	New arg isa, all callers updated.  Do some basic validation of the
	ifield list if requested.
	* mach.scm (/sanity-check-insns): Improve error message text.
	* doc/running.text: Document -w option.

	* ifield.scm (/multi-ifield-parse): Initialize bitrange.
@
text
@d29 1
@


1.20
log
@(<ifield> pretty-print): Fix typo.
@
text
@d936 1
d1094 2
a1095 1
; Traverse the ifield to collect all base (non-derived) ifields used in it.
d1102 23
@


1.19
log
@	* dev.scm (*): Change default verbosity level to 2.

	* ifield.scm (<ifield> pretty-print): New method.
	(ifld-pretty-print): New function.
	(<multi-ifield> pretty-print): New method.

	* ifield.scm (<ifield> field-start): Delete word-len arg.
	All callers updated.
	(ifld-start): Ditto.
	(<multi-ifield> field-start): Ditto.
	* operand.scm (<hw-index> field-start): Ditto.
@
text
@d403 2
a404 2
		  " " (number->string (ifld-start f))
		  " " (number->string (ifld-length f))
@


1.18
log
@	* ifield.scm (ifld-beyond-base?): Remove args base-bitsize,
	total-bitsize.  All callers updated.
	* insn.scm (<insn>): Rename member ifld-values to /insn-value.
	New member /insn-base-value.
	(insn-base-value): New function.
	* mach.scm (/sanity-check-insns): New function.
	(arch-analyze-insns!): Call it.
@
text
@d63 1
a63 1
; {follows} is rarely used
d101 1
a101 1
 (lambda (self word-len)
d105 2
a106 2
(define (ifld-start ifld word-len)
  (send ifld 'field-start word-len)
d253 1
a253 1
     (word-value (ifld-start self base-len)
d289 1
a289 1
     (word-extract (ifld-start self base-len)
d396 15
a756 1

d761 2
a762 2
 (lambda (self word-len)
   (apply min (map (lambda (f) (ifld-start f #f)) (elm-get self 'subfields))))
d844 12
d1118 2
a1119 2
			 (cgh-qsort-int-cmp (ifld-start a #f)
					    (ifld-start b #f)))
d1121 2
a1122 2
			 (- (cgh-qsort-int-cmp (ifld-start a #f)
					       (ifld-start b #f)))))))
d1126 4
a1129 4
		  (lambda (a b) (< (ifld-start a #f)
				   (ifld-start b #f)))
		  (lambda (a b) (> (ifld-start a #f)
				   (ifld-start b #f)))))))
@


1.17
log
@	* iformat.scm (ifields-base-ifields): Simplify.
	(compute-insn-length): Simplify, call ifields-base-ifields.
	(compute-insn-base-mask): Ditto.
	* ifield.scm (ifld-known-values): Ditto.
	(ifld-base-ifields): Ditto.
	* insn.scm (insn-value): Ditto.
	* pgmr-tools.scm (pgmr-pretty-print-insn-format): Ditto.
@
text
@d1108 1
a1108 3
(define (ifld-beyond-base? f base-bitsize total-bitsize)
  ; old way
  ;(< base-bitsize (+ (ifld-start f total-bitsize) (ifld-length f)))
@


1.16
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d184 1
a184 1
  (let ((constant-iflds (find ifld-constant? (collect ifld-base-ifields ifld-list))))
d1070 2
a1071 4
  (cond ((derived-ifield? ifld) (collect (lambda (subfield) (ifld-base-ifields subfield))
					 (derived-ifield-subfields ifld)))
	; ((multi-ifield? ifld) (collect (lambda (subfield) (ifld-base-ifields subfield))
	; 			       (multi-ifld-subfields ifld)))
@


1.15
log
@	* ifield.scm (<ifield> constructor): New arg `location',
	all callers updated.
	* insn.scm (<insn> constructor): Ditto.
	(<multi-insn> constructor): Ditto.
	* minsn.scm (<macro-insn> constructor): Ditto.
	* operand.scm (<operand> constructor): Ditto.
	* utils-cgen.scm (builtin-location): New function.
	(<source-ident>): Fix default value of member `location'.
	(source-ident?): New function.
@
text
@d75 1
a75 1
(define -ifld-bitrange (elm-make-getter <ifield> 'bitrange))
d77 2
a78 2
(define (ifld-word-offset f) (bitrange-word-offset (-ifld-bitrange f)))
(define (ifld-word-length f) (bitrange-word-length (-ifld-bitrange f)))
d102 1
a102 1
   (bitrange-start (-ifld-bitrange self)))
d209 2
a210 2
   (let* ((container (or container (-ifld-bitrange self)))
	  (bitrange (-ifld-bitrange self))
d248 1
a248 1
   (let* ((bitrange (-ifld-bitrange self))
d306 1
a306 1
   (bitrange-lsb0? (-ifld-bitrange self)))
d347 1
a347 1
   (let ((bitrange (object-copy-top (-ifld-bitrange self))))
d370 1
a370 1
  (let ((br (-ifld-bitrange f)))
d381 2
a382 2
  (let ((br1 (-ifld-bitrange f1))
	(br2 (-ifld-bitrange f2)))
d427 1
a427 1
(define (-ifield-parse context name comment attrs
d459 1
a459 1
	      (follows-obj (-ifld-parse-follows context follows))
d478 2
a479 2
			    (word-offset (-get-ifld-word-offset start flength diwb lsb0?))
			    (word-length (-get-ifld-word-length start flength diwb lsb0?))
d498 2
a499 2
			 (-ifld-parse-encode context encode)
			 (-ifld-parse-decode context decode))))
d510 1
a510 1
; Subroutine of -ifield-parse to simplify it.
d522 1
a522 1
(define (-get-ifld-word-offset start flength diwb lsb0?)
d531 1
a531 1
; Subroutine of -ifield-parse to simplify it.
d537 1
a537 1
(define (-get-ifld-word-length start flength diwb lsb0?)
d552 1
a552 1
; -ifield-parse is invoked to create the <ifield> object.
d554 1
a554 1
(define (-ifield-read context . arg-list)
d604 1
a604 1
    (-ifield-parse context name comment attrs
d611 1
a611 1
(define (-ifld-parse-follows context follows)
d622 1
a622 1
(define (-ifld-parse-encode-decode context which value)
d643 2
a644 2
(define (-ifld-parse-encode context encode)
  (-ifld-parse-encode-decode context "encode" encode)
d649 2
a650 2
(define (-ifld-parse-decode context decode)
  (-ifld-parse-encode-decode context "decode" decode)
d657 1
a657 1
    (let ((f (apply -ifield-read (cons (make-current-context "define-ifield")
d669 1
a669 1
  (let ((f (-ifield-parse (make-current-context "define-full-ifield")
d677 1
a677 1
(define (-ifield-add-commands!)
d766 1
a766 1
		     (bitrange-next-word (-ifld-bitrange f)))
d833 1
a833 1
; Subroutine of -multi-ifield-parse to build the default insert expression.
d835 1
a835 1
(define (-multi-ifield-make-default-insert container-name subfields)
d851 1
a851 1
; Subroutine of -multi-ifield-parse to build the default extract expression.
d853 1
a853 1
(define (-multi-ifield-make-default-extract container-name subfields)
d872 1
a872 1
(define (-multi-ifield-parse context name comment attrs mode
d908 2
a909 2
	    (elm-xset! result 'encode (-ifld-parse-encode context encode))
	    (elm-xset! result 'decode (-ifld-parse-encode context decode))
d913 1
a913 1
			   (-multi-ifield-make-default-insert name subfields)))
d917 1
a917 1
			   (-multi-ifield-make-default-extract name subfields)))
d929 1
a929 1
; -multi-ifield-parse is invoked to create the `multi-ifield' object.
d931 1
a931 1
(define (-multi-ifield-read context . arg-list)
d964 1
a964 1
    (-multi-ifield-parse context name comment attrs mode subflds
d972 1
a972 1
    (let ((f (apply -multi-ifield-read (cons (make-current-context "define-multi-ifield")
d983 1
a983 1
  (let ((f (-multi-ifield-parse (make-current-context "define-full-multi-ifield")
d1063 1
a1063 1
		     (bitrange-next-word (-ifld-bitrange f)))
d1168 1
a1168 1
  (-ifield-add-commands!)
@


1.14
log
@	* ifield.scm (ifld-encode-mode): Add FIXME.
	* opcodes.scm (<ifield> 'gen-insert): Handle encode parameters with
	modes.
	(<ifield> 'gen-extract): Similarly.

	* read.scm (parse-error): Handle #f for context-location.
	* utils-cgen.scm (unspecified-location): Fix building of
	single-location.
@
text
@d64 2
a65 1
(method-make-make! <ifield> '(name comment attrs mode bitrange encode decode))
d492 1
d1193 2
a1194 1
  (set! f-nil (make <ifield> 'f-nil "empty ifield"
d1201 6
a1206 5
  (set! f-anyof (make <ifield> 'f-anyof "placeholder for anyof operands"
		    (atlist-cons (all-isas-attr) nil)
		    UINT
		    (make <bitrange> 0 0 0 0 #f)
		    #f #f)) ; encode/decode
@


1.13
log
@	Clean up cpu file parsing, pass context consistently instead of the
	old "errtxt" argument.
	NOTE: ACU == "All Callers Updated".
	* attr.scm (-parse-simple-attribute): Renamed from
	parse-simple-attribute, ACU.
	(-attr-parse): Change errtxt argument to context, ACU.
	(-attr-read): Ditto.
	(atlist-parse): Ditto.  Put context arg first.
	(attr-parse): Use parse-error instead of context-error.
	* enum.scm (parse-enum-vals): Change errtxt argument to context, ACU.
	(-enum-parse-prefix, -enum-parse, -enum-read): Ditto.
	* hardware.scm (-keyword-parse): Renamed from keyword-parse.
	`context' arg is now a <context> object.  ACU.
	(-keyword-read): `context' arg is now a <context> object.  ACU.
	(-hw-parse-indices): Change errtxt argument to context, ACU.
	(-hw-parse-values, -hw-parse-handlers): Ditto.
	(-hw-parse-getter, -hw-parse-setter, -hw-parse, -hw-read): Ditto.
	(-hw-validate-layout, -hw-create-getter-from-layout,
	-hw-create-setter-from-layout): Ditto.
	(<hw-register>:parse!, <hw-pc>:parse!): Ditto.
	(<hw-memory>:parse!, <hw-immediate>:parse!): Ditto.
	(<hw-address>:parse!): Ditto.
	* ifield.scm (-ifield-parse, ifield-read): Ditto.
	(-ifld-parse-follows, -ifld-parse-encode-decode): Ditto.
	(-ifld-parse-encode, -ifld-parse-decode): Ditto.
	(-multi-ifield-parse, -multi-ifield-read): Ditto.
	* insn.scm (-insn-parse, -insn-read): Ditto.
	(parse-syntax): Ditto.  Put context arg first.
	(-parse-insn-format-symbol): Change errtxt argument to context, ACU.
	(-parse-insn-format-ifield-spec, -parse-insn-format-list): Ditto.
	(-parse-insn-format): Ditto.
	* mach.scm (-arch-parse-alignment, -arch-parse-machs): Ditto.
	(-arch-parse-isas): Ditto.
	(-isa-read): Add context arg, ACU.
	(-cpu-parse, -cpu-read, -mach-read): Ditto.
	* minsn.scm (-minsn-parse-expansion): Change errtxt argument to
	context, ACU.
	(-minsn-parse, -minsn-read, -minsn-compute-iflds): Ditto.
	(minsn-make-alias): Ditto.
	* mode.scm (-mode-parse): Ditto.
	(parse-mode-name): Ditto.  Put context arg first.
	* model.scm (-prefetch-parse, -retire-parse, -pipeline-parse): Change
	errtxt argument to context, ACU.
	(-unit-parse, -model-parse, -model-read): Ditto.
	* operand.scm (-operand-parse-getter): Use parse-error instead of
	context-error.
	(-operand-parse-setter): Ditto.
	(-operand-parse): Change errtxt argument to context, ACU.
	(-operand-read, -derived-operand-parse, -derived-operand-read): Ditto.
	(-anyof-operand-parse, -anyof-operand-read): Ditto.
	* read.scm (reader-error): Delete.  Use parse-error instead.
	(parse-error): Change errtxt argument to context, ACU.  Split args
	argument into expr and maybe-help-text.
	(-reader-process-expanded-1!): Reorganize.
	* rtl.scm (-subr-read): Change errtxt argument to context, ACU.
	* types.scm (parse-type): Ditto.
	* utils-cgen.scm (single-location->simple-string): New function.
	(<context>): Replace members file,lineno with location.
	(make-prefix-context): Renamed from context-make-prefix, ACU.
	(make-current-context): New function.
	(context-append, context-append-name): New functions.
	(context-make-reader): Delete.
	(parse-name): Change errtxt argument to context, ACU.
	Put context arg first.
	(parse-comment): Ditto.
	(parse-number): Change errtxt argument to context, ACU.
	(arg-list-validate-name, arg-list-check-no-args,
	arg-list-symbol-arg): Ditto.

	* read.scm (-cmd-if): Don't assume test is a list.

	* html.scm (get-insn-properties): Delete errtxt, unused.
@
text
@d85 2
@


1.12
log
@	Track source location better, for better error messages.
	* pmacros.scm (-pmacro-eval): Delete, unused.
	(pmacro-expand, -pmacro-expand): New arg `loc', all callers updated.
	(-pmacro-expand-expr-list, -smacro-apply): Ditto.
	(scan-list, scan): Ditto.
	(-pmacro-builtin-pmacro, -pmacro-builtin-let, -pmacro-builtin-if,
	-pmacro-builtin-case, -pmacro-builtin-cond, -pmacro-builtin-begin,
	-pmacro-builtin-andif, -pmacro-builtin-orif): Ditto.
	(scan-list1): New function.
	(-pmacro-build-lambda): New arg `loc', all callers updated.  Rewrite.
	* read.scm (<reader>): New member `location'.
	(-reader-lookup-command): Renamed from reader-lookup-command,
	all callers updated.
	(reader-error): Rewrite to produce better source location info.
	(current-reader-location): New function.
	(-reader-process-expanded-1!): Renamed from -reader-process-expanded-1.
	All callers updated.  Record source location of expression.
	(reader-process-expanded!): Renamed from reader-process-expanded.
	All callers updated.
	(-reader-process!): Renamed from reader-process.  New arg `loc'.
	All callers updated.  Record source location of define-pmacro.
	* utils-cgen.scm (<location>): New class.
	(single-location): New (pseudo) class.
	(pretty-print-single-location, pretty-print-location): New functions.
	(location-top, location-push-single, location-push): New functions.
	(unspecified-location, current-input-location): New functions.
	(location-property): New object property.
	(location-property-set!): New function.
	(<source-ident>): Renamed from <ordered-ident>.  New member `location'.
	All uses updated.
	* testsuite/location-1.test: New testcase.
	* testsuite/run-tests.sh: Fix fail count handling.
	* testsuite/test-utils.sh.in (run_cgen): New option `-f'.  Allow tests
	to expect cgen to fail.

	* pmacros.scm (*): Use "pmacro" instead of "macro" more consistently.

	* read.scm (-cmd-include): Renamed from include.  All callers updated.
	(-cmd-if): Renamed from cmd-if.  All callers updated.
	Use reader-process-expanded! on then/else clauses instead of eval1.
@
text
@d424 1
a424 1
(define (-ifield-parse errtxt name comment attrs
d429 4
a432 2
  (let* ((name (parse-name name errtxt))
	 (atlist (atlist-parse attrs "cgen_ifld" errtxt))
d437 1
a437 1
    ;	(parse-error errtxt "can only specify 1 isa" attrs))
d441 1
a441 1
	(parse-error errtxt "either both or neither of word-offset,word-length can be specified"))
d447 1
a447 1
				(parse-number errtxt word-offset '(0 . 256))))
d449 1
a449 1
				(parse-number errtxt word-length '(0 . 128))))
d451 1
a451 1
	      (start (parse-number errtxt start '(0 . 127)))
d453 1
a453 1
	      (flength (parse-number errtxt flength '(0 . 127)))
d455 2
a456 2
	      (mode-obj (parse-mode-name mode errtxt))
	      (follows-obj (-ifld-parse-follows errtxt follows))
d490 1
a490 1
			 (parse-comment comment errtxt)
d494 2
a495 2
			 (-ifld-parse-encode errtxt encode)
			 (-ifld-parse-decode errtxt decode))))
d546 1
a546 1
; ERRTXT is prepended to error messages to provide context.
d550 3
a552 3
(define (-ifield-read errtxt . arg-list)
  (let (; Current ifield elements:
	(name nil)
d568 1
d587 1
a587 1
	      (else (parse-error errtxt "invalid ifield arg" arg)))
d600 1
a600 1
    (-ifield-parse errtxt name comment attrs
d602 1
a602 2
		   mode encode decode)
    )
d607 1
a607 1
(define (-ifld-parse-follows errtxt follows)
d611 1
a611 1
	    (parse-error errtxt "unknown operand to follow" follows))
d618 1
a618 1
(define (-ifld-parse-encode-decode errtxt which value)
d626 1
a626 1
	    (parse-error errtxt
d631 1
a631 1
	    (parse-error errtxt
d639 2
a640 2
(define (-ifld-parse-encode errtxt encode)
  (-ifld-parse-encode-decode errtxt "encode" encode)
d645 2
a646 2
(define (-ifld-parse-decode errtxt decode)
  (-ifld-parse-encode-decode errtxt "decode" decode)
d653 2
a654 1
    (let ((f (apply -ifield-read (cons "define-ifield" arg-list))))
d665 2
a666 1
  (let ((f (-ifield-parse "define-full-ifield" name comment attrs
d868 1
a868 1
(define (-multi-ifield-parse errtxt name comment attrs mode
d873 1
a873 1
      (parse-error errtxt "empty subfield list" subfields))
d875 4
a878 2
  (let* ((name (parse-name name errtxt))
	 (atlist (atlist-parse attrs "cgen_ifld" errtxt))
d882 2
a883 2
    ; (if (!= (length isas) 1) 
    ;     (parse-error errtxt "can only specify 1 isa" attrs))
d886 1
d892 2
a893 1
					(parse-error errtxt "unknown ifield" subfld))
d898 1
a898 2
	    (elm-xset! result 'comment (parse-comment comment errtxt))
					; multi-ifields are always VIRTUAL
d900 6
a905 4
		       (atlist-parse (cons 'VIRTUAL attrs) "multi-ifield" errtxt))
	    (elm-xset! result 'mode (parse-mode-name mode errtxt))
	    (elm-xset! result 'encode (-ifld-parse-encode errtxt encode))
	    (elm-xset! result 'decode (-ifld-parse-encode errtxt decode))
d916 1
d922 4
d927 2
a928 2
(define (-multi-ifield-read errtxt . arg-list)
  (let (; Current multi-ifield elements:
d939 1
d956 1
a956 1
	      (else (parse-error errtxt "invalid ifield arg" arg)))
d958 1
d960 2
a961 3
    (-multi-ifield-parse errtxt name comment attrs mode subflds
			 insert extract encode decode)
    )
d968 2
a969 1
    (let ((f (apply -multi-ifield-read (cons "define-multi-ifield" arg-list))))
d979 2
a980 1
  (let ((f (-multi-ifield-parse "define-full-multi-ifield" name comment attrs
a1014 1

a1021 1

@


1.11
log
@	* ifield.scm (-multi-ifield-make-default-insert): Fix shifts
	calculation.
	(-multi-ifield-make-default-extract): Ditto.
@
text
@d26 1
a26 1
	      '(<ordered-ident>)
@


1.10
log
@	Use hash tables to record ifields, operands, insns, macro-insns.
	* attr.scm (attr-builtin!): Tweak some comments.
	* hardware.scm (hardware-builtin!): Call all-isas-attr-value.
	* ifield.scm (<ifield>): Subclass from <ordered-ident> instead of
	<ident>.
	(<multi-ifield>): New constructor.
	(ifield-builtin!): Add isa attr to f-nil, f-anyof.
	* insn.scm (<insn>): Subclass from <ordered-ident> instead of
	<ident>.
	(-sub-insn-make!): Add hack to avoid differences in generated code.
	(multi-insn-instantiate!): Add total number of multi-insns to
	logging message.
	* mach.scm (<arch>): Rename members ifld-list, op-list, insn-list,
	minsn-list to foo-table.  New member next-ordinal.
	Update getters/setters.
	(arch-ifld-list, arch-op-list, arch-insn-list, arch-minsn-list):
	New functions.
	(-get-next-ordinal!, -get-lowest-ordinal): New function.
	(-make-ident-object-table, -ident-object-table->list,
	-ident-object-table-add!, -ident-object-table-lookup): New functions.
	(current-ifld-list, current-ifld-add! current-ifld-lookup,
	-ifld-already-defined?): Rewrite.
	(current-op-list, current-op-add! current-op-lookup,
	-op-already-defined?): Rewrite.
	(current-raw-insn-list, insn-list-car, insn-list-splice!): Delete.
	(current-insn-list, current-insn-add! current-insn-lookup,
	-insn-already-defined?): Rewrite.
	(current-minsn-list, current-minsn-add! current-minsn-lookup,
	-minsn-already-defined?): Rewrite.
	(all-isas-attr-value, all-isas-attr, attr-isa-list): New functions.
	(MAX-VIRTUAL-INSNS): Define.
	(arch-analyze-insns!): Add hack to avoid differences in generated code.
	Update use of arch-insn-list.
	(mach-init!): Initialize ifld-table, op-table, insn-table, minsn-table.
	(arch-finish!): Delete references to ifld-table, op-table, insn-table,
	minsn-table.
	* minsn.scm (<macro-insn>): Subclass from <ordered-ident> instead of
	<ident>.  New constructor.
	* operand.scm (<operand>): Subclass from <ordered-ident> instead of
	<ident>.
	* sid.scm (-virtual-insn-add!): New function.
	(-create-virtual-insns!): Call it.
	(-fill-sim-insn-list!): Rewrite.
	* sim.scm (-virtual-insn-add!, -create-virtual-insns!): New functions.
	(sim-finish!): Move contents to -create-virtual-insns!, and call it.
	* utils-cgen.scm (<ordered-ident>): New class.
	(obj-ordinal, obj-set-ordinal!): New functions.
	(add-ident-methods!): Delete.

	* model.scm (parse-insn-timing): Change logging message to level 3.
@
text
@d60 2
a61 1
; {value},{follows} are missing on purpose
d829 1
a829 1
	 (shifts (cons 0 (list-tail-drop 1 (plus-scan (cons 0 lengths))))))
d847 1
a847 1
	 (shifts (cons 0 (list-tail-drop 1 (plus-scan (cons 0 lengths))))))
@


1.9
log
@	* cpu/play.cpu: Add example of hardware `layout'.
	* doc/porting.tex: Add docs on simplify.inc.
	* doc/rtl.texi: Cleanup pass over "Simplification macros",
	and other things.

	* ifield.scm: Whitespace/formatting cleanup.

	* ifield.scm (-multi-ifield-parse): Watch for missing subfields.
@
text
@d26 1
a26 1
	      '(<ident>)
d711 4
d1174 1
a1174 1
		    atlist-empty
d1181 1
a1181 1
		    atlist-empty
@


1.8
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d658 1
a658 2
; Not sure whether to add another function or leave CISC cpu's to define
; a shorthand macro if they want.
d859 2
a860 1
(define (-multi-ifield-parse errtxt name comment attrs mode subfields insert extract encode decode)
d863 3
d869 1
a869 1
    
d873 1
a873 1
    
d883 1
a883 1
	    
d939 2
a940 1
    (-multi-ifield-parse errtxt name comment attrs mode subflds insert extract encode decode)
d955 1
d1043 1
a1044 1
; Traverse the ifield to collect all base (non-derived) ifields used in it.
a1051 2


@


1.7
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@d2 1
a2 1
; Copyright (C) 2000,2002 Red Hat, Inc.
@


1.7.6.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2002, 2009 Red Hat, Inc.
@


1.6
log
@add some comments
@
text
@d137 1
a137 1
; Return ilk of field.
d147 1
a147 1
	(obj:name value) ; send's message 'get-name to fetch object's `name'
@


1.5
log
@	* ifield.scm (-ifield-parse): Rewrite <bitrange> computation.
	(-get-ifld-word-offset,-get-ifld-word-length): New fns.
@
text
@d509 1
a509 1
; Now pick the set of words that are required to contain the ifield.
d513 1
a513 1
; must be fully specified.
d518 2
d533 2
@


1.4
log
@	* ifield.scm (<ifield> 'field-start): Don't look at word-len.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
d457 1
a457 2
	  ; FIXME: word-offset/word-length computation needs work.
	  ; Move positional info to format?
d460 2
a461 1
		     ; CISC
d464 12
a475 8
		     ; RISC
		     (let* ((default-insn-word-bitsize
			      (isa-default-insn-word-bitsize isa))
			    (word-offset
			     (- start
				(remainder start
					   default-insn-word-bitsize)))
			    (start (remainder start default-insn-word-bitsize)))
d480 1
a480 9
			 (if lsb0?
			     (* (quotient (+ start 1
					     (- default-insn-word-bitsize 1))
					  default-insn-word-bitsize)
				default-insn-word-bitsize)
			     (* (quotient (+ start flength
					     (- default-insn-word-bitsize 1))
					  default-insn-word-bitsize)
				default-insn-word-bitsize))
d501 34
@


1.3
log
@* consistency improvement for isa-filtering in *ifield parsers

2000-09-15  Frank Ch. Eigler  <fche@@redhat.com>

	* enum.scm (define-full-insn-enum): Filter with keep-isa predicate.
	* ifield.scm (-ifield-parse, -multi-ifield-parse): No longer assert
	single-isa predicate, but support keep-isa filtering.
@
text
@a93 11
; WORD-LEN is the length of the word in which to compute the value or
; #f meaning to use the default length (recorded with the bitrange).
; WORD-LEN is present for architectures like the m32r where there are insns
; smaller than the base insn size (LIW).
; ??? Not sure it'll be applicable to other LIW architectures.  The m32r is
; rather easy as the insns are 16 and 32 bits.
; ??? Another way to do this would be to either set the base-insn-size for
; the m32r to be 16 bits, or to add a new field to hold the insn-word-size
; and set it to 16 for the m32r.  The problem here is that there is no
; canonicalization that works regardless of whether a "word" is shortened
; or lengthened.
d98 1
a98 21
   (let* ((bitrange (-ifld-bitrange self))
	  (lsb0? (bitrange-lsb0? bitrange))
	  (recorded-word-len (bitrange-word-length bitrange))
	  (wanted-word-len (or word-len recorded-word-len)))
     ; Note that this is only intended for situations like the m32r.
     ; If it doesn't work elsewhere, it may be that you need to
     ; do things different (use two fields instead of one).
     (cond ((= wanted-word-len recorded-word-len)
	    (bitrange-start bitrange))
	   ((< wanted-word-len recorded-word-len)
	    ; smaller word wanted
	    (if lsb0?
		(- (bitrange-start bitrange) (- recorded-word-len
						wanted-word-len))
		(bitrange-start bitrange)))
	   (else
	    ; larger word wanted
	    (if lsb0?
		(+ (bitrange-start bitrange) (- wanted-word-len
						recorded-word-len))
		(bitrange-start bitrange))))))
@


1.2
log
@* snapshot of work toward more complete support of derived-operands

2000-08-22  Frank Ch. Eigler  <fche@@redhat.com>

	* Makefile.in (DIST_COMMON): Regenerated.
	* ifield.scm (derived-ifield needed-iflds): New method.
	* iformat.scm (-ifmt-lookup-sfmt!): Use base ifields for
	sfmts built from derived-ifields.
	* operand.scm (-derived-parse-encoding): Give derived-ifield a fixed
	type symbol 'derived-ifield, not an unparseable string.
	* utils-sim.scm (op-needed-iflds) Handler 'derived-ifield case.
	(-sfmt-contents): Add tracing.

	From Doug Evans <dje@@transmeta.com>:
	* sim.scm (operand cxmake-get): Result is a <c-expr>, not a string of
	C code.
@
text
@d463 3
a465 3
    ; Ensure only one isa specified.
    (if (!= (length isas) 1)
	(parse-error errtxt "can only specify 1 isa" attrs))
d860 38
a897 28
  (let ((name (parse-name name errtxt))
	(result (new <multi-ifield>))
	(subfields (map (lambda (subfld)
			  (let ((f (current-ifld-lookup subfld)))
			    (if (not f)
				(parse-error errtxt "unknown ifield" subfld))
			    f))
			subfields)))

    (elm-xset! result 'name name)
    (elm-xset! result 'comment (parse-comment comment errtxt))
    ; multi-ifields are always VIRTUAL
    (elm-xset! result 'attrs
	       (atlist-parse (cons 'VIRTUAL attrs) "multi-ifield" errtxt))
    (elm-xset! result 'mode (parse-mode-name mode errtxt))
    (elm-xset! result 'encode (-ifld-parse-encode errtxt encode))
    (elm-xset! result 'decode (-ifld-parse-encode errtxt decode))
    (if insert
	(elm-xset! result 'insert insert)
	(elm-xset! result 'insert
		   (-multi-ifield-make-default-insert name subfields)))
    (if extract
	(elm-xset! result 'extract extract)
	(elm-xset! result 'extract
		   (-multi-ifield-make-default-extract name subfields)))
    (elm-xset! result 'subfields subfields)

    result)
d942 2
a943 1
      (current-ifld-add! f)
@


1.1
log
@Initial revision
@
text
@d974 9
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
