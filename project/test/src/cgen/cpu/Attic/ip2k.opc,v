head	1.8;
access;
symbols
	sid-snapshot-20110801:1.7
	cgen-snapshot-20110801:1.7
	sid-snapshot-20110701:1.7
	cgen-snapshot-20110701:1.7
	sid-snapshot-20110601:1.7
	cgen-snapshot-20110601:1.7
	sid-snapshot-20110501:1.7
	cgen-snapshot-20110501:1.7
	sid-snapshot-20110401:1.7
	cgen-snapshot-20110401:1.7
	sid-snapshot-20110301:1.7
	cgen-snapshot-20110301:1.7
	sid-snapshot-20110201:1.7
	cgen-snapshot-20110201:1.7
	sid-snapshot-20110101:1.7
	cgen-snapshot-20110101:1.7
	sid-snapshot-20101201:1.7
	cgen-snapshot-20101201:1.7
	sid-snapshot-20101101:1.7
	cgen-snapshot-20101101:1.7
	sid-snapshot-20101001:1.7
	cgen-snapshot-20101001:1.7
	sid-snapshot-20100901:1.7
	cgen-snapshot-20100901:1.7
	sid-snapshot-20100801:1.7
	cgen-snapshot-20100801:1.7
	sid-snapshot-20100701:1.7
	cgen-snapshot-20100701:1.7
	sid-snapshot-20100601:1.7
	cgen-snapshot-20100601:1.7
	sid-snapshot-20100501:1.7
	cgen-snapshot-20100501:1.7
	sid-snapshot-20100401:1.7
	cgen-snapshot-20100401:1.7
	sid-snapshot-20100301:1.7
	cgen-snapshot-20100301:1.7
	sid-snapshot-20100201:1.7
	cgen-snapshot-20100201:1.7
	sid-snapshot-20100101:1.7
	cgen-snapshot-20100101:1.7
	sid-snapshot-20091201:1.7
	cgen-snapshot-20091201:1.7
	sid-snapshot-20091101:1.7
	cgen-snapshot-20091101:1.7
	sid-snapshot-20091001:1.7
	cgen-snapshot-20091001:1.7
	arc-sim-20090309:1.7.6.1
	sid-snapshot-20090901:1.7
	cgen-snapshot-20090901:1.7
	sid-snapshot-20090801:1.7
	cgen-snapshot-20090801:1.7
	sid-snapshot-20090701:1.7
	cgen-snapshot-20090701:1.7
	dje-cgen-play1-branch:1.7.0.10
	dje-cgen-play1-branchpoint:1.7
	cgen-1_1-branch:1.7.0.8
	cgen-1_1-branchpoint:1.7
	sid-snapshot-20090601:1.7
	cgen-snapshot-20090601:1.7
	sid-snapshot-20090501:1.7
	cgen-snapshot-20090501:1.7
	sid-snapshot-20090401:1.7
	cgen-snapshot-20090401:1.7
	arc-insight_6_8-branch:1.7.0.6
	arc-insight_6_8-branchpoint:1.7
	sid-snapshot-20090301:1.7
	cgen-snapshot-20090301:1.7
	sid-snapshot-20090201:1.7
	cgen-snapshot-20090201:1.7
	sid-snapshot-20090101:1.7
	cgen-snapshot-20090101:1.7
	sid-snapshot-20081201:1.7
	cgen-snapshot-20081201:1.7
	sid-snapshot-20081101:1.7
	cgen-snapshot-20081101:1.7
	sid-snapshot-20081001:1.7
	cgen-snapshot-20081001:1.7
	sid-snapshot-20080901:1.7
	cgen-snapshot-20080901:1.7
	sid-snapshot-20080801:1.7
	cgen-snapshot-20080801:1.7
	sid-snapshot-20080701:1.7
	cgen-snapshot-20080701:1.7
	sid-snapshot-20080601:1.7
	cgen-snapshot-20080601:1.7
	sid-snapshot-20080501:1.7
	cgen-snapshot-20080501:1.7
	sid-snapshot-20080403:1.7
	sid-snapshot-20080401:1.7
	cgen-snapshot-20080401:1.7
	sid-snapshot-20080301:1.7
	cgen-snapshot-20080301:1.7
	sid-snapshot-20080201:1.7
	cgen-snapshot-20080201:1.7
	sid-snapshot-20080101:1.7
	cgen-snapshot-20080101:1.7
	sid-snapshot-20071201:1.7
	cgen-snapshot-20071201:1.7
	sid-snapshot-20071101:1.7
	cgen-snapshot-20071101:1.7
	sid-snapshot-20071001:1.7
	cgen-snapshot-20071001:1.7
	msnyder-fork-checkpoint-branch:1.7.0.4
	msnyder-fork-checkpoint-branchpoint:1.7
	gdb-csl-arm-20051020-branch:1.7.0.2
	gdb-csl-arm-20051020-branchpoint:1.7
	drow_intercu-merge-20040921:1.2
	drow_intercu-merge-20040915:1.2
	jimb-gdb_6_2-e500-branch:1.2.0.58
	jimb-gdb_6_2-e500-branchpoint:1.2
	gdb_6_2-20040730-release:1.2
	gdb_6_2-branch:1.2.0.54
	gdb_6_2-2004-07-10-gmt-branchpoint:1.2
	gdb_6_1_1-20040616-release:1.2
	gdb_6_1-2004-04-05-release:1.2
	drow_intercu-merge-20040402:1.2
	drow_intercu-merge-20040327:1.2
	ezannoni_pie-20040323-branch:1.2.0.52
	ezannoni_pie-20040323-branchpoint:1.2
	cagney_tramp-20040321-mergepoint:1.2
	cagney_tramp-20040309-branch:1.2.0.50
	cagney_tramp-20040309-branchpoint:1.2
	gdb_6_1-branch:1.2.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.2
	drow_intercu-20040221-branch:1.2.0.46
	drow_intercu-20040221-branchpoint:1.2
	cagney_bfdfile-20040213-branch:1.2.0.44
	cagney_bfdfile-20040213-branchpoint:1.2
	drow-cplus-merge-20040208:1.2
	carlton_dictionary-20040126-merge:1.2
	cagney_bigcore-20040122-branch:1.2.0.42
	cagney_bigcore-20040122-branchpoint:1.2
	drow-cplus-merge-20040113:1.2
	drow-cplus-merge-20031224:1.2
	drow-cplus-merge-20031220:1.2
	carlton_dictionary-20031215-merge:1.2
	drow-cplus-merge-20031214:1.2
	carlton-dictionary-20031111-merge:1.2
	gdb_6_0-2003-10-04-release:1.2
	kettenis_sparc-20030918-branch:1.2.0.40
	kettenis_sparc-20030918-branchpoint:1.2
	carlton_dictionary-20030917-merge:1.2
	ezannoni_pie-20030916-branchpoint:1.2
	ezannoni_pie-20030916-branch:1.2.0.38
	cagney_x86i386-20030821-branch:1.2.0.36
	cagney_x86i386-20030821-branchpoint:1.2
	carlton_dictionary-20030805-merge:1.2
	carlton_dictionary-20030627-merge:1.2
	gdb_6_0-branch:1.2.0.34
	gdb_6_0-2003-06-23-branchpoint:1.2
	jimb-ppc64-linux-20030613-branch:1.2.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.2
	cagney_convert-20030606-branch:1.2.0.30
	cagney_convert-20030606-branchpoint:1.2
	cagney_writestrings-20030508-branch:1.2.0.28
	cagney_writestrings-20030508-branchpoint:1.2
	jimb-ppc64-linux-20030528-branch:1.2.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.2
	carlton_dictionary-20030523-merge:1.2
	cagney_fileio-20030521-branch:1.2.0.24
	cagney_fileio-20030521-branchpoint:1.2
	kettenis_i386newframe-20030517-mergepoint:1.2
	jimb-ppc64-linux-20030509-branch:1.2.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.2
	kettenis_i386newframe-20030504-mergepoint:1.2
	carlton_dictionary-20030430-merge:1.2
	kettenis_i386newframe-20030419-branch:1.2.0.20
	kettenis_i386newframe-20030419-branchpoint:1.2
	carlton_dictionary-20030416-merge:1.2
	cagney_frameaddr-20030409-mergepoint:1.2
	kettenis_i386newframe-20030406-branch:1.2.0.18
	kettenis_i386newframe-20030406-branchpoint:1.2
	cagney_frameaddr-20030403-branchpoint:1.2
	cagney_frameaddr-20030403-branch:1.2.0.16
	cagney_framebase-20030330-mergepoint:1.2
	cagney_framebase-20030326-branch:1.2.0.14
	cagney_framebase-20030326-branchpoint:1.2
	cagney_lazyid-20030317-branch:1.2.0.12
	cagney_lazyid-20030317-branchpoint:1.2
	kettenis-i386newframe-20030316-mergepoint:1.2
	offbyone-20030313-branch:1.2.0.10
	offbyone-20030313-branchpoint:1.2
	kettenis-i386newframe-20030308-branch:1.2.0.8
	kettenis-i386newframe-20030308-branchpoint:1.2
	carlton_dictionary-20030305-merge:1.2
	cagney_offbyone-20030303-branch:1.2.0.6
	cagney_offbyone-20030303-branchpoint:1.2
	carlton_dictionary-20030207-merge:1.2
	interps-20030202-branch:1.2.0.4
	interps-20030202-branchpoint:1.2
	cagney-unwind-20030108-branch:1.2.0.2
	cagney-unwind-20030108-branchpoint:1.2
	carlton_dictionary-20021223-merge:1.2
	gdb_5_3-2002-12-12-release:1.1
	carlton_dictionary-20021115-merge:1.1
	kseitz_interps-20021105-merge:1.1
	kseitz_interps-20021103-merge:1.1
	drow-cplus-merge-20021020:1.1
	drow-cplus-merge-20021025:1.1
	carlton_dictionary-20021025-merge:1.1
	carlton_dictionary-20021011-merge:1.1
	drow-cplus-branch:1.1.0.14
	drow-cplus-branchpoint:1.1
	kseitz_interps-20020930-merge:1.1
	carlton_dictionary-20020927-merge:1.1
	carlton_dictionary-branch:1.1.0.12
	carlton_dictionary-20020920-branchpoint:1.1
	sid-20020905-branchpoint:1.1
	sid-20020905-branch:1.1.0.10
	gdb_5_3-branch:1.1.0.8
	gdb_5_3-2002-09-04-branchpoint:1.1
	kseitz_interps-20020829-merge:1.1
	cagney_sysregs-20020825-branch:1.1.0.6
	cagney_sysregs-20020825-branchpoint:1.1
	readline_4_3-import-branch:1.1.0.4
	readline_4_3-import-branchpoint:1.1
	kseitz_interps-20020528-branch:1.1.0.2;
locks; strict;
comment	@# @;


1.8
date	2011.08.22.15.25.09;	author nickc;	state dead;
branches;
next	1.7;

1.7
date	2005.07.15.13.57.38;	author amodra;	state Exp;
branches
	1.7.6.1;
next	1.6;

1.6
date	2005.07.01.11.16.30;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.18.16.12.36;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.23.16.04.38;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.15.12.52.01;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2002.12.02.21.53.53;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	2002.07.17.14.56.53;	author bje;	state Exp;
branches
	1.1.2.1
	1.1.12.1
	1.1.14.1;
next	;

1.1.2.1
date	2002.07.22.21.46.52;	author kseitz;	state Exp;
branches;
next	;

1.1.12.1
date	2002.12.23.19.38.04;	author carlton;	state Exp;
branches;
next	;

1.1.14.1
date	2003.12.14.20.26.56;	author drow;	state Exp;
branches;
next	;

1.7.6.1
date	2009.03.09.20.36.06;	author amylaar;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Move cpu files from cgen/cpu to top level cpu directory.
@
text
@/* IP2K opcode support.  -*- C -*-
   Copyright (C) 2000 Red Hat, Inc.
   Copyright (C) 2002, 2005 Free Software Foundation, Inc.
   This file is part of CGEN.  */

/*
   Each section is delimited with start and end markers.

   <arch>-opc.h additions use: "-- opc.h"
   <arch>-opc.c additions use: "-- opc.c"
   <arch>-asm.c additions use: "-- asm.c"
   <arch>-dis.c additions use: "-- dis.c"
   <arch>-ibd.h additions use: "-- ibd.h".  */

/* -- opc.h */

/* Check applicability of instructions against machines.  */
#define CGEN_VALIDATE_INSN_SUPPORTED

/* Allows reason codes to be output when assembler errors occur.  */
#define CGEN_VERBOSE_ASSEMBLER_ERRORS

/* Override disassembly hashing - there are variable bits in the top
   byte of these instructions.  */
#define CGEN_DIS_HASH_SIZE 8
#define CGEN_DIS_HASH(buf, value) \
  (((* (unsigned char*) (buf)) >> 5) % CGEN_DIS_HASH_SIZE)

#define CGEN_ASM_HASH_SIZE 127
#define CGEN_ASM_HASH(insn) ip2k_asm_hash (insn)

extern unsigned int ip2k_asm_hash (const char *);
extern int ip2k_cgen_insn_supported (CGEN_CPU_DESC, const CGEN_INSN *);

/* -- opc.c */

#include "safe-ctype.h"

/* A better hash function for instruction mnemonics.  */
unsigned int
ip2k_asm_hash (const char* insn)
{
  unsigned int hash;
  const char* m = insn;

  for (hash = 0; *m && ! ISSPACE (*m); m++)
    hash = (hash * 23) ^ (0x1F & TOLOWER (*m));

  /* printf ("%s %d\n", insn, (hash % CGEN_ASM_HASH_SIZE)); */

  return hash % CGEN_ASM_HASH_SIZE;
}


/* Special check to ensure that instruction exists for given machine.  */

int
ip2k_cgen_insn_supported (CGEN_CPU_DESC cd, const CGEN_INSN *insn)
{
  int machs = CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_MACH);

  /* No mach attribute?  Assume it's supported for all machs.  */
  if (machs == 0)
    return 1;
  
  return (machs & cd->machs) != 0;
}


/* -- asm.c */

static const char *
parse_fr (CGEN_CPU_DESC cd,
	  const char **strp,
	  int opindex,
	  unsigned long *valuep)
{
  const char *errmsg;
  const char *old_strp;
  char *afteroffset; 
  enum cgen_parse_operand_result result_type;
  bfd_vma value;
  extern CGEN_KEYWORD ip2k_cgen_opval_register_names;
  bfd_vma tempvalue;

  old_strp = *strp;
  afteroffset = NULL;

  /* Check here to see if you're about to try parsing a w as the first arg
     and return an error if you are.  */
  if ((strncmp (*strp, "w", 1) == 0) || (strncmp (*strp, "W", 1) == 0))
    {
      (*strp)++;

      if ((strncmp (*strp, ",", 1) == 0) || ISSPACE (**strp))
	{
	  /* We've been passed a w.  Return with an error message so that
	     cgen will try the next parsing option.  */
	  errmsg = _("W keyword invalid in FR operand slot.");
	  return errmsg;
	}
      *strp = old_strp;
    }

  /* Attempt parse as register keyword. */
  errmsg = cgen_parse_keyword (cd, strp, & ip2k_cgen_opval_register_names,
			       (long *) valuep);
  if (*strp != NULL
      && errmsg == NULL)
    return errmsg;

  /* Attempt to parse for "(IP)".  */
  afteroffset = strstr (*strp, "(IP)");

  if (afteroffset == NULL)
    /* Make sure it's not in lower case.  */
    afteroffset = strstr (*strp, "(ip)");

  if (afteroffset != NULL)
    {
      if (afteroffset != *strp)
	{
	  /* Invalid offset present.  */
	  errmsg = _("offset(IP) is not a valid form");
	  return errmsg;
	}
      else
	{
	  *strp += 4; 
	  *valuep = 0;
	  errmsg = NULL;
	  return errmsg;
	}
    }

  /* Attempt to parse for DP. ex: mov w, offset(DP)
                                  mov offset(DP),w   */

  /* Try parsing it as an address and see what comes back.  */
  afteroffset = strstr (*strp, "(DP)");

  if (afteroffset == NULL)
    /* Maybe it's in lower case.  */
    afteroffset = strstr (*strp, "(dp)");

  if (afteroffset != NULL)
    {
      if (afteroffset == *strp)
	{
	  /* No offset present. Use 0 by default.  */
	  tempvalue = 0;
	  errmsg = NULL;
	}
      else
	errmsg = cgen_parse_address (cd, strp, opindex,
				     BFD_RELOC_IP2K_FR_OFFSET,
				     & result_type, & tempvalue);

      if (errmsg == NULL)
	{
	  if (tempvalue <= 127)
	    {
	      /* Value is ok.  Fix up the first 2 bits and return.  */
	      *valuep = 0x0100 | tempvalue;
	      *strp += 4; /* Skip over the (DP) in *strp.  */
	      return errmsg;
	    }
	  else
	    {
	      /* Found something there in front of (DP) but it's out
		 of range.  */
	      errmsg = _("(DP) offset out of range.");
	      return errmsg;
	    }
	}
    }


  /* Attempt to parse for SP. ex: mov w, offset(SP)
                                  mov offset(SP), w.  */
  afteroffset = strstr (*strp, "(SP)");

  if (afteroffset == NULL)
    /* Maybe it's in lower case.  */
    afteroffset = strstr (*strp, "(sp)");

  if (afteroffset != NULL)
    {
      if (afteroffset == *strp)
	{
	  /* No offset present. Use 0 by default.  */
	  tempvalue = 0;
	  errmsg = NULL;
	}
      else
	errmsg = cgen_parse_address (cd, strp, opindex,
				     BFD_RELOC_IP2K_FR_OFFSET,
				     & result_type, & tempvalue);

      if (errmsg == NULL)
	{
	  if (tempvalue <= 127)
	    {
	      /* Value is ok.  Fix up the first 2 bits and return.  */
	      *valuep = 0x0180 | tempvalue;
	      *strp += 4; /* Skip over the (SP) in *strp.  */
	      return errmsg;
	    }
	  else
	    {
	      /* Found something there in front of (SP) but it's out
		 of range.  */
	      errmsg = _("(SP) offset out of range.");
	      return errmsg;
	    }
	}
    }

  /* Attempt to parse as an address.  */
  *strp = old_strp;
  errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_IP2K_FR9,
			       & result_type, & value);
  if (errmsg == NULL)
    {
      *valuep = value;

      /* If a parenthesis is found, warn about invalid form.  */
      if (**strp == '(')
	errmsg = _("illegal use of parentheses");

      /* If a numeric value is specified, ensure that it is between
	 1 and 255.  */
      else if (result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	{
	  if (value < 0x1 || value > 0xff)
	    errmsg = _("operand out of range (not between 1 and 255)");
	}
    }
  return errmsg;
}

static const char *
parse_addr16 (CGEN_CPU_DESC cd,
	      const char **strp,
	      int opindex,
	      unsigned long *valuep)
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type;
  bfd_reloc_code_real_type code = BFD_RELOC_NONE;
  bfd_vma value;

  if (opindex == (CGEN_OPERAND_TYPE) IP2K_OPERAND_ADDR16H)
    code = BFD_RELOC_IP2K_HI8DATA;
  else if (opindex == (CGEN_OPERAND_TYPE) IP2K_OPERAND_ADDR16L)
    code = BFD_RELOC_IP2K_LO8DATA;
  else
    {
      /* Something is very wrong. opindex has to be one of the above.  */
      errmsg = _("parse_addr16: invalid opindex.");
      return errmsg;
    }
  
  errmsg = cgen_parse_address (cd, strp, opindex, code,
			       & result_type, & value);
  if (errmsg == NULL)
    {
      /* We either have a relocation or a number now.  */
      if (result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	{
	  /* We got a number back.  */
	  if (code == BFD_RELOC_IP2K_HI8DATA)
            value >>= 8;
	  else
	    /* code = BFD_RELOC_IP2K_LOW8DATA.  */
	    value &= 0x00FF;
	}   
      *valuep = value;
    }

  return errmsg;
}

static const char *
parse_addr16_cjp (CGEN_CPU_DESC cd,
		  const char **strp,
		  int opindex,
		  unsigned long *valuep)
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type;
  bfd_reloc_code_real_type code = BFD_RELOC_NONE;
  bfd_vma value;
 
  if (opindex == (CGEN_OPERAND_TYPE) IP2K_OPERAND_ADDR16CJP)
    code = BFD_RELOC_IP2K_ADDR16CJP;
  else if (opindex == (CGEN_OPERAND_TYPE) IP2K_OPERAND_ADDR16P)
    code = BFD_RELOC_IP2K_PAGE3;

  errmsg = cgen_parse_address (cd, strp, opindex, code,
			       & result_type, & value);
  if (errmsg == NULL)
    {
      if (result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	{
	  if ((value & 0x1) == 0)  /* If the address is even .... */
	    {
	      if (opindex == (CGEN_OPERAND_TYPE) IP2K_OPERAND_ADDR16CJP)
                *valuep = (value >> 1) & 0x1FFF;  /* Should mask be 1FFF?  */
	      else if (opindex == (CGEN_OPERAND_TYPE) IP2K_OPERAND_ADDR16P)
                *valuep = (value >> 14) & 0x7;
	    }
          else
 	    errmsg = _("Byte address required. - must be even.");
	}
      else if (result_type == CGEN_PARSE_OPERAND_RESULT_QUEUED)
	{
	  /* This will happen for things like (s2-s1) where s2 and s1
	     are labels.  */
	  *valuep = value;
	}
      else 
        errmsg = _("cgen_parse_address returned a symbol. Literal required.");
    }
  return errmsg; 
}

static const char *
parse_lit8 (CGEN_CPU_DESC cd,
	    const char **strp,
	    int opindex,
	    long *valuep)
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type;
  bfd_reloc_code_real_type code = BFD_RELOC_NONE;
  bfd_vma value;

  /* Parse %OP relocating operators.  */
  if (strncmp (*strp, "%bank", 5) == 0)
    {
      *strp += 5;
      code = BFD_RELOC_IP2K_BANK;
    }
  else if (strncmp (*strp, "%lo8data", 8) == 0)
    {
      *strp += 8;
      code = BFD_RELOC_IP2K_LO8DATA;
    }
  else if (strncmp (*strp, "%hi8data", 8) == 0)
    {
      *strp += 8;
      code = BFD_RELOC_IP2K_HI8DATA;
    }
  else if (strncmp (*strp, "%ex8data", 8) == 0)
    {
      *strp += 8;
      code = BFD_RELOC_IP2K_EX8DATA;
    }
  else if (strncmp (*strp, "%lo8insn", 8) == 0)
    {
      *strp += 8;
      code = BFD_RELOC_IP2K_LO8INSN;
    }
  else if (strncmp (*strp, "%hi8insn", 8) == 0)
    {
      *strp += 8;
      code = BFD_RELOC_IP2K_HI8INSN;
    }

  /* Parse %op operand.  */
  if (code != BFD_RELOC_NONE)
    {
      errmsg = cgen_parse_address (cd, strp, opindex, code, 
				   & result_type, & value);
      if ((errmsg == NULL) &&
	  (result_type != CGEN_PARSE_OPERAND_RESULT_QUEUED))
	errmsg = _("percent-operator operand is not a symbol");

      *valuep = value;
    }
  /* Parse as a number.  */
  else
    {
      errmsg = cgen_parse_signed_integer (cd, strp, opindex, valuep);

      /* Truncate to eight bits to accept both signed and unsigned input.  */
      if (errmsg == NULL)
	*valuep &= 0xFF;
    }

  return errmsg;
}

static const char *
parse_bit3 (CGEN_CPU_DESC cd,
	    const char **strp,
	    int opindex,
	    unsigned long *valuep)
{
  const char *errmsg;
  char mode = 0;
  long count = 0;
  unsigned long value;

  if (strncmp (*strp, "%bit", 4) == 0)
    {
      *strp += 4;
      mode = 1;
    }
  else if (strncmp (*strp, "%msbbit", 7) == 0)
    {
      *strp += 7;
      mode = 1;
    }
  else if (strncmp (*strp, "%lsbbit", 7) == 0)
    {
      *strp += 7;
      mode = 2;
    }

  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, valuep);
  if (errmsg)
    return errmsg;

  if (mode)
    {
      value = * valuep;
      if (value == 0)
	{
	  errmsg = _("Attempt to find bit index of 0");
	  return errmsg;
	}
    
      if (mode == 1)
	{
	  count = 31;
	  while ((value & 0x80000000) == 0)
	    {
	      count--;
	      value <<= 1;
	    }
	}
      else if (mode == 2)
	{
	  count = 0;
	  while ((value & 0x00000001) == 0)
	    {
	      count++;
	      value >>= 1;
	    }
	}
    
      *valuep = count;
    }

  return errmsg;
}

/* -- dis.c */

static void
print_fr (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	  void * dis_info,
	  long value,
	  unsigned int attrs ATTRIBUTE_UNUSED,
	  bfd_vma pc ATTRIBUTE_UNUSED,
	  int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = (disassemble_info *) dis_info;
  const CGEN_KEYWORD_ENTRY *ke;
  extern CGEN_KEYWORD ip2k_cgen_opval_register_names;
  long offsettest;
  long offsetvalue;

  if (value == 0) /* This is (IP).  */
    {
      (*info->fprintf_func) (info->stream, "%s", "(IP)");
      return;
    }

  offsettest = value >> 7;
  offsetvalue = value & 0x7F;

  /* Check to see if first two bits are 10 -> (DP).  */
  if (offsettest == 2)
    {
      if (offsetvalue == 0)
	(*info->fprintf_func) (info->stream, "%s","(DP)");
      else
	(*info->fprintf_func) (info->stream, "$%lx%s", offsetvalue, "(DP)");
      return;
    }

  /* Check to see if first two bits are 11 -> (SP).  */
  if (offsettest == 3)
    {
      if (offsetvalue == 0)
	(*info->fprintf_func) (info->stream, "%s", "(SP)");
      else
	(*info->fprintf_func) (info->stream, "$%lx%s", offsetvalue,"(SP)");
      return;
    }

  /* Attempt to print as a register keyword.  */
  ke = cgen_keyword_lookup_value (& ip2k_cgen_opval_register_names, value);

  if (ke != NULL)
    (*info->fprintf_func) (info->stream, "%s", ke->name);
  else
    /* Print as an address literal.  */
    (*info->fprintf_func) (info->stream, "$%02lx", value);
}

static void
print_dollarhex (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
		 void * dis_info,
		 long value,
		 unsigned int attrs ATTRIBUTE_UNUSED,
		 bfd_vma pc ATTRIBUTE_UNUSED,
		 int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = (disassemble_info *) dis_info;

  (*info->fprintf_func) (info->stream, "$%lx", value);
}

static void
print_dollarhex8 (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
		  void * dis_info,
		  long value,
		  unsigned int attrs ATTRIBUTE_UNUSED,
		  bfd_vma pc ATTRIBUTE_UNUSED,
		  int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = (disassemble_info *) dis_info;

  (*info->fprintf_func) (info->stream, "$%02lx", value);
}

static void
print_dollarhex_addr16h (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
			 void * dis_info,
			 long value,
			 unsigned int attrs ATTRIBUTE_UNUSED,
			 bfd_vma pc ATTRIBUTE_UNUSED,
			 int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = (disassemble_info *) dis_info;

  /* This is a loadh instruction. Shift the value to the left
     by 8 bits so that disassembled code will reassemble properly.  */
  value = ((value << 8) & 0xFF00);

  (*info->fprintf_func) (info->stream, "$%04lx", value);
}

static void
print_dollarhex_addr16l (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
			 void * dis_info,
			 long value,
			 unsigned int attrs ATTRIBUTE_UNUSED,
			 bfd_vma pc ATTRIBUTE_UNUSED,
			 int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = (disassemble_info *) dis_info;

  (*info->fprintf_func) (info->stream, "$%04lx", value);
}

static void
print_dollarhex_p (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
		   void * dis_info,
		   long value,
		   unsigned int attrs ATTRIBUTE_UNUSED,
		   bfd_vma pc ATTRIBUTE_UNUSED,
		   int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = (disassemble_info *) dis_info;

  value = ((value << 14) & 0x1C000);
  ;value = (value  & 0x1FFFF);
  (*info->fprintf_func) (info->stream, "$%05lx", value);
}

static void
print_dollarhex_cj (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
		    void * dis_info,
		    long value,
		    unsigned int attrs ATTRIBUTE_UNUSED,
		    bfd_vma pc ATTRIBUTE_UNUSED,
		    int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = (disassemble_info *) dis_info;

  value = ((value << 1) & 0x1FFFF);
  (*info->fprintf_func) (info->stream, "$%05lx", value);
}

static void
print_decimal (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	       void * dis_info,
	       long value,
	       unsigned int attrs ATTRIBUTE_UNUSED,
	       bfd_vma pc ATTRIBUTE_UNUSED,
	       int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = (disassemble_info *) dis_info;

  (*info->fprintf_func) (info->stream, "%ld", value);
}



/* -- */

@


1.7
log
@	* cpu/fr30.opc (print_register_list): Correct format strings.
	* cpu/ip2k.opc: Likewise.
@
text
@@


1.7.6.1
log
@Check in ARCompact simulator.  A valid configuration is arc-elf.
This is not quite finished and has most likely a few files that are
obsolete & not used, but it's good enough to run gcc regression tests.
@
text
@d26 1
a26 1
#define CGEN_DIS_HASH(buf, value, big_p) \
@


1.6
log
@Update function declarations to ISO C90 formatting
@
text
@d491 1
a491 1
	(*info->fprintf_func) (info->stream, "$%x%s",offsetvalue, "(DP)");
d501 1
a501 1
	(*info->fprintf_func) (info->stream, "$%x%s", offsetvalue,"(SP)");
d512 1
a512 1
    (*info->fprintf_func) (info->stream, "$%02x", value);
d525 1
a525 1
  (*info->fprintf_func) (info->stream, "$%x", value);
d538 1
a538 1
  (*info->fprintf_func) (info->stream, "$%02x", value);
d555 1
a555 1
  (*info->fprintf_func) (info->stream, "$%04x", value);
d568 1
a568 1
  (*info->fprintf_func) (info->stream, "$%04x", value);
d583 1
a583 1
  (*info->fprintf_func) (info->stream, "$%05x", value);
d597 1
a597 1
  (*info->fprintf_func) (info->stream, "$%05x", value);
d610 1
a610 1
  (*info->fprintf_func) (info->stream, "%d", value);
@


1.5
log
@Change wording of error message to "percent-operand" from "%operand" as the
latter confuses xgettext into thinking that it is a C printf formating directive,
which	prevents proper translation.
@
text
@d13 1
a13 2
   <arch>-ibd.h additions use: "-- ibd.h"
*/
d26 2
a27 1
#define CGEN_DIS_HASH(buf,value) (((* (unsigned char*) (buf)) >> 5) % CGEN_DIS_HASH_SIZE)
d30 1
a30 1
#define CGEN_ASM_HASH(insn) ip2k_asm_hash(insn)
d32 2
a33 3
extern unsigned int ip2k_asm_hash PARAMS ((const char *insn));
extern int ip2k_cgen_insn_supported
  PARAMS ((CGEN_CPU_DESC, const CGEN_INSN *));
d39 1
a39 1
/* A better hash function for instruction mnemonics. */
d41 1
a41 2
ip2k_asm_hash (insn)
     const char* insn;
d46 2
a47 2
  for (hash = 0; *m && !ISSPACE(*m); m++)
    hash = (hash * 23) ^ (0x1F & TOLOWER(*m));
d55 2
a56 1
/* Special check to ensure that instruction exists for given machine. */
d58 1
a58 3
ip2k_cgen_insn_supported (cd, insn)
     CGEN_CPU_DESC cd;
     const CGEN_INSN *insn;
d66 1
a66 1
  return ((machs & cd->machs) != 0);
a71 12
#define PARSE_FUNC_DECL(name) \
  static const char *name (CGEN_CPU_DESC, const char **, int, long *)
#define PARSE_UFUNC_DECL(name) \
  static const char *name (CGEN_CPU_DESC, const char **, int, unsigned long *)

PARSE_UFUNC_DECL (parse_fr);
PARSE_UFUNC_DECL (parse_addr16);
PARSE_UFUNC_DECL (parse_addr16_cjp);
PARSE_FUNC_DECL (parse_lit8);
PARSE_UFUNC_DECL (parse_bit3);


d73 4
a76 5
parse_fr (cd, strp, opindex, valuep)
     CGEN_CPU_DESC cd;
     const char **strp;
     int opindex;
     unsigned long *valuep;
d87 1
a87 1
  afteroffset = NULL; 
d165 1
a165 1
	      *strp += 4; /* skip over the (DP) in *strp.  */
d206 1
a206 1
	      *strp += 4; /* skip over the (SP) in *strp.  */
d227 1
a227 1
      /* if a parenthesis is found, warn about invalid form.  */
d231 1
a231 1
      /* if a numeric value is specified, ensure that it is between
d243 4
a246 5
parse_addr16 (cd, strp, opindex, valuep)
     CGEN_CPU_DESC cd;
     const char **strp;
     int opindex;
     unsigned long *valuep;
d259 1
a259 1
      /* Something is very wrong. opindex has to be one of the above. */
d268 1
a268 1
      /* We either have a relocation or a number now. */
d271 1
a271 1
	  /* We got a number back. */
d274 2
a275 1
	  else    /* code = BFD_RELOC_IP2K_LOW8DATA */
a283 1

d285 4
a288 5
parse_addr16_cjp (cd, strp, opindex, valuep)
     CGEN_CPU_DESC cd;
     const char **strp;
     int opindex;
     unsigned long *valuep;
d309 1
a309 1
                *valuep = (value >> 1) & 0x1FFF;  /* Should mask be 1FFF? */
a327 1

d329 4
a332 5
parse_lit8 (cd, strp, opindex, valuep)
     CGEN_CPU_DESC cd;
     const char **strp;
     int opindex;
     long *valuep;
d339 1
a339 1
  /* Parse %OP relocating operators. */
a369 1
  
d387 1
a387 1
      /* Truncate to eight bits to accept both signed and unsigned input. */
d396 4
a399 5
parse_bit3 (cd, strp, opindex, valuep)
     CGEN_CPU_DESC cd;
     const char **strp;
     int opindex;
     unsigned long *valuep;
a459 1

a461 12
#define PRINT_FUNC_DECL(name) \
static void name PARAMS ((CGEN_CPU_DESC, PTR, long, unsigned int, bfd_vma, int))

PRINT_FUNC_DECL (print_fr);
PRINT_FUNC_DECL (print_dollarhex);
PRINT_FUNC_DECL (print_dollarhex8);
PRINT_FUNC_DECL (print_dollarhex_addr16h);
PRINT_FUNC_DECL (print_dollarhex_addr16l);
PRINT_FUNC_DECL (print_dollarhex_p);
PRINT_FUNC_DECL (print_dollarhex_cj);
PRINT_FUNC_DECL (print_decimal);

d463 6
a468 7
print_fr (cd, dis_info, value, attrs, pc, length)
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
     PTR dis_info;
     long value;
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
d476 1
a476 1
  if ( value == 0 ) /* This is (IP) */
d485 2
a486 2
  /* Check to see if first two bits are 10 -> (DP) */
  if ( offsettest == 2 )
d488 1
a488 1
      if ( offsetvalue == 0 )
d495 2
a496 2
  /* Check to see if first two bits are 11 -> (SP) */
  if ( offsettest == 3 )
d498 1
a498 1
      if ( offsetvalue == 0 )
d505 1
a505 1
  /* Attempt to print as a register keyword. */
d507 1
d509 4
a512 7
    {
      (*info->fprintf_func) (info->stream, "%s", ke->name);
      return;
    }

  /* Print as an address literal. */
  (*info->fprintf_func) (info->stream, "$%02x", value);
d516 6
a521 7
print_dollarhex (cd, dis_info, value, attrs, pc, length)
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
     PTR dis_info;
     long value;
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
d529 6
a534 7
print_dollarhex8 (cd, dis_info, value, attrs, pc, length)
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
     PTR dis_info;
     long value;
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
d542 6
a547 7
print_dollarhex_addr16h (cd, dis_info, value, attrs, pc, length)
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
     PTR dis_info;
     long value;
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
d551 2
a552 2
  /* This is a loadh instruction. Shift the value to the left      */
  /* by 8 bits so that disassembled code will reassemble properly. */
d559 6
a564 7
print_dollarhex_addr16l (cd, dis_info, value, attrs, pc, length)
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
     PTR dis_info;
     long value;
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
d572 6
a577 7
print_dollarhex_p (cd, dis_info, value, attrs, pc, length)
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
     PTR dis_info;
     long value;
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
d587 6
a592 7
print_dollarhex_cj (cd, dis_info, value, attrs, pc, length)
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
     PTR dis_info;
     long value;
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
a599 1

d601 6
a606 7
print_decimal (cd, dis_info, value, attrs, pc, length)
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
     PTR dis_info;
     long value;
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
@


1.4
log
@Fix compile time warnings generated by gcc 4.0
@
text
@d399 1
a399 1
	errmsg = _("%operator operand is not a symbol");
@


1.3
log
@Fix compile time warning messages
@
text
@d3 1
a3 1
   Copyright (C) 2002 Free Software Foundation, Inc.
d76 7
a82 5
static const char *name PARAMS ((CGEN_CPU_DESC, const char **, int, long *))

PARSE_FUNC_DECL (parse_fr);
PARSE_FUNC_DECL (parse_addr16);
PARSE_FUNC_DECL (parse_addr16_cjp);
d84 1
a84 1
PARSE_FUNC_DECL (parse_bit3);
d92 1
a92 1
     long *valuep;
d105 3
a107 4

  /* Check here to see if you're about to try parsing a w as the first arg */
  /* and return an error if you are.                                       */
  if ( (strncmp(*strp,"w",1)==0) || (strncmp(*strp,"W",1)==0) )
d111 1
a111 1
      if ( (strncmp(*strp,",",1)==0) || ISSPACE(**strp) )
d113 2
a114 2
	  /* We've been passed a w.  Return with an error message so that  */
	  /* cgen will try the next parsing option.                        */
a120 1

a121 2
  /* old_strp = *strp; */

d123 4
a126 4
			       valuep);
  if ( *strp != NULL )
    if (errmsg == NULL)
      return errmsg;
d128 2
a129 2
  /* Attempt to parse for "(IP)" */
  afteroffset = strstr(*strp,"(IP)");
d131 3
a133 5
  if ( afteroffset == NULL)
    {
      /* Make sure it's not in lower case */
      afteroffset = strstr(*strp,"(ip)");
    }
d135 1
a135 1
  if ( afteroffset != NULL )
d137 1
a137 1
      if ( afteroffset != *strp )
d139 1
a139 1
	  /* Invalid offset present.*/
d152 2
a153 2
  /* Attempt to parse for DP. ex: mov w, offset(DP)  */
  /*                              mov offset(DP),w   */
d155 2
a156 1
  /* Try parsing it as an address and see what comes back */
d158 3
a160 1
  afteroffset = strstr(*strp,"(DP)");
d162 1
a162 1
  if ( afteroffset == NULL)
d164 1
a164 7
      /* Maybe it's in lower case */
      afteroffset = strstr(*strp,"(dp)");
    }

  if ( afteroffset != NULL )
    {
      if ( afteroffset == *strp )
d166 1
a166 1
	  /* No offset present. Use 0 by default. */
d171 3
a173 5
	{
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_IP2K_FR_OFFSET,
				       & result_type, & tempvalue);
	}
d179 1
a179 1
	      /* Value is ok.  Fix up the first 2 bits and return */       
d181 1
a181 1
	      *strp += 4; /* skip over the (DP) in *strp */
d187 1
a187 1
		 of range. */
d195 3
a197 5
  /* Attempt to parse for SP. ex: mov w, offset(SP)  */
  /*                              mov offset(SP), w  */


  afteroffset = strstr(*strp,"(SP)");
d200 2
a201 4
    {
      /* Maybe it's in lower case. */
      afteroffset = strstr(*strp, "(sp)");
    }
d203 1
a203 1
  if ( afteroffset != NULL )
d205 1
a205 1
      if ( afteroffset ==  *strp )
d207 1
a207 1
	  /* No offset present. Use 0 by default. */
d212 4
a215 5
	{
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_IP2K_FR_OFFSET,
				       & result_type, & tempvalue);
	}
d220 1
a220 1
	      /* Value is ok.  Fix up the first 2 bits and return */
d222 1
a222 1
	      *strp += 4; /* skip over the (SP) in *strp */
d228 1
a228 1
		 of range. */
a231 1
        
d235 1
a235 2

  /* Attempt to parse as an address. */
d243 3
a245 1
      /* if a parenthesis is found, warn about invalid form */
a246 4
      if (**strp == '(')
	{
	  errmsg = _("illegal use of parentheses");
        }
d248 1
a248 1
	 1 and 255 */
d263 1
a263 1
     long *valuep;
d270 1
a270 1
  if ( opindex == (CGEN_OPERAND_TYPE)IP2K_OPERAND_ADDR16H )
d272 1
a272 1
  else if ( opindex == (CGEN_OPERAND_TYPE)IP2K_OPERAND_ADDR16L )
d286 1
a286 1
      if ( result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER )
d289 1
a289 1
	  if ( code == BFD_RELOC_IP2K_HI8DATA )
d306 1
a306 1
     long *valuep;
d313 1
a313 1
  if ( opindex == (CGEN_OPERAND_TYPE)IP2K_OPERAND_ADDR16CJP )
d315 1
a315 1
  else if ( opindex == (CGEN_OPERAND_TYPE)IP2K_OPERAND_ADDR16P )
d322 1
a322 1
      if ( result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER )
d324 1
a324 1
	  if ( (value & 0x1) == 0)  /* If the address is even .... */
d326 1
a326 1
	      if ( opindex == (CGEN_OPERAND_TYPE)IP2K_OPERAND_ADDR16CJP )
d328 1
a328 1
	      else if ( opindex == (CGEN_OPERAND_TYPE)IP2K_OPERAND_ADDR16P )
d334 1
a334 1
      else if ( result_type == CGEN_PARSE_OPERAND_RESULT_QUEUED )
d421 1
a421 1
     long *valuep;
d444 1
a444 1
  errmsg = cgen_parse_signed_integer (cd, strp, opindex, valuep);
d450 1
a450 1
      value = (unsigned long) *valuep;
@


1.2
log
@	* desc-cpu.scm (gen-maybe-multi-ifld): Remove superfluous parens.
	Add braces and cast for union field.
	(gen-multi-ifield-nodes): Add braces and cast for union field.
	(cgen_operand_table): Similarly fix sentinel.
	(cgen_cpu_close): Constify "insns".  Formatting.
	(cgen-desc.c): Include xregex.h.
	* cpu/ip2k.opc (ip2k_cgen_insn_supported): Move to opc.c section.
	Prototype.
	<opc.c>: Include safe-ctype.h.
	(ip2k_asm_hash): Use ISSPACE and TOLOWER.
	(PARSE_FUNC_DECL): Declare.  Use to prototype parse_fr, parse_addr16,
	parse_addr16_p, parse_addr16_cjp, parse_lit8 and parse_bit3.
	(parse_fr): Constify "old_strp".  Correct type of "tempvalue".
	Don't test it for >= 0.  Use ISSPACE rather than isspace.  Formatting.
	(parse_addr16): Correct type of "value".  Formatting.
	(parse_addr16_p): Likewise.
	(parse_addr16_cjp): Likewise.
	(parse_lit8): Likewise.
	(parse_bit3): Formatting.
	(PRINT_FUNC_DECL): Define.  Use to prototype print_fr, print_dollarhex,
	print_dollarhex8, print_dollarhex16, print_dollarhex_addr16h,
	print_dollarhex_addr16l, print_dollarhex_p, print_dollarhex_cj and
	print_decimal.
	(print_fr): Add ATTRIBUTE_UNUSED on unused args.  Formatting.
	(print_dollarhex): Add ATTRIBUTE_UNUSED on unused args.
	(print_dollarhex8): Likewise.
	(print_dollarhex16): Likewise.
	(print_dollarhex_addr16h): Likewise.
	(print_dollarhex_addr16l): Likewise.
	(print_dollarhex_p): Likewise.
	(print_dollarhex_cj): Likewise.
	(print_decimal): Likewise.
	* cpu/xstormy16.opc (parse_mem8): Use ISALNUM rather than isalnum.
@
text
@a79 1
PARSE_FUNC_DECL (parse_addr16_p);
a319 25
parse_addr16_p (cd, strp, opindex, valuep)
     CGEN_CPU_DESC cd;
     const char **strp;
     int opindex;
     long *valuep;
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type;
  bfd_reloc_code_real_type code = BFD_RELOC_IP2K_PAGE3;
  bfd_vma value;
 
  errmsg = cgen_parse_address (cd, strp, opindex, code,
			       & result_type, & value);
  if (errmsg == NULL)
    {
      if ( result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER )
	*valuep = (value >> 13) & 0x7;
      else if ( result_type == CGEN_PARSE_OPERAND_RESULT_QUEUED )
	*valuep = value;
    }
  return errmsg; 
}


static const char *
a508 1
PRINT_FUNC_DECL (print_dollarhex16);
a599 14
print_dollarhex16 (cd, dis_info, value, attrs, pc, length)
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
     PTR dis_info;
     long value;
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
{
  disassemble_info *info = (disassemble_info *) dis_info;

  (*info->fprintf_func) (info->stream, "$%04x", value);
}

static void
@


1.1
log
@	* cpu/ip2k.cpu: New file.
	* cpu/ip2k.opc: Likewise.
@
text
@d32 3
a34 18
extern unsigned int ip2k_asm_hash (const char *insn);


/* Special check to ensure that instruction exists for given machine. */
static int
ip2k_cgen_insn_supported (cd, insn)
     CGEN_CPU_DESC cd;
     CGEN_INSN *insn;
{
  int machs = CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_MACH);

  /* No mach attribute?  Assume it's supported for all machs.  */
  if (machs == 0)
    return 1;
  
  return ((machs & cd->machs) != 0);
}

d38 2
d48 2
a49 2
  for (hash = 0; *m && !isspace(*m); m++)
    hash = (hash * 23) ^ (0x1F & tolower(*m));
d57 14
d75 11
d94 1
a94 1
  char *old_strp;
d99 1
a99 1
  long tempvalue;
d108 2
a109 2
  {
     (*strp)++;
d111 9
a119 9
     if ( (strncmp(*strp,",",1)==0) || isspace(**strp) )
     {
        /* We've been passed a w.  Return with an error message so that  */
        /* cgen will try the next parsing option.                        */
        errmsg = _("W keyword invalid in FR operand slot.");
        return errmsg;
     }
     *strp = old_strp;
  }
d125 2
a126 1
  errmsg = cgen_parse_keyword (cd, strp, & ip2k_cgen_opval_register_names, valuep);
d128 2
a129 2
  if (errmsg == NULL)
    return errmsg;
d135 4
a138 4
  {
     /* Make sure it's not in lower case */
     afteroffset = strstr(*strp,"(ip)");
  }
d165 4
a168 4
  {
     /* Maybe it's in lower case */
     afteroffset = strstr(*strp,"(dp)");
  }
d171 32
a202 30
  {
     if ( afteroffset == *strp )
     {
        /* No offset present. Use 0 by default. */
        tempvalue = 0;
        errmsg = NULL;
     }
     else
     {
       errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_IP2K_FR_OFFSET,
				    & result_type, & tempvalue);
     }

     if (errmsg == NULL)
     {
        if ( (tempvalue >= 0) && (tempvalue <= 127) )
        {
           /* Value is ok.  Fix up the first 2 bits and return */       
           *valuep = 0x0100 | tempvalue;
           *strp += 4; /* skip over the (DP) in *strp */
           return errmsg;
        } else
        {
           /* Found something there in front of (DP) but it's out of range. */
           errmsg = _("(DP) offset out of range.");
           return errmsg;
        }
        
     }
  }
d212 4
a215 4
  {
     /* Maybe it's in lower case. */
     afteroffset = strstr(*strp, "(sp)");
  }
d218 29
a246 26
  {
     if ( afteroffset ==  *strp )
     {
        /* No offset present. Use 0 by default. */
        tempvalue = 0;
        errmsg = NULL;
     }
     else
     {
       errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_IP2K_FR_OFFSET,
				    & result_type, & tempvalue);
     }
     if (errmsg == NULL)
     {
        if ( (tempvalue >= 0) && (tempvalue <= 127) )
        {
           /* Value is ok.  Fix up the first 2 bits and return */
           *valuep = 0x0180 | tempvalue;
           *strp += 4; /* skip over the (SP) in *strp */
           return errmsg;
        } else
        {
           /* Found something there in front of (SP) but it's out of range. */
           errmsg = _("(SP) offset out of range.");
           return errmsg;
        }
d248 2
a249 2
     }
  }
d266 2
a267 1
      /* if a numeric value is specified, ensure that it is between 1 and 255 */
d287 1
a287 1
  long value;
d290 1
a290 1
      code = BFD_RELOC_IP2K_HI8DATA;
d292 1
a292 1
      code = BFD_RELOC_IP2K_LO8DATA;
d301 1
a301 1
                                  & result_type, & value);
d304 1
a304 1
       /* We either have a relocation or a number now. */
d306 3
a308 3
      {
         /* We got a number back. */
         if ( code == BFD_RELOC_IP2K_HI8DATA )
d310 1
a310 1
         else    /* code = BFD_RELOC_IP2K_LOW8DATA */
d312 3
a314 3
      }   
         *valuep = value;
   }
d320 11
a330 11
 static const char *
 parse_addr16_p (cd, strp, opindex, valuep)
      CGEN_CPU_DESC cd;
      const char **strp;
      int opindex;
      long *valuep;
 {
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
   bfd_reloc_code_real_type code = BFD_RELOC_IP2K_PAGE3;
   long value;
d332 24
a355 24
   errmsg = cgen_parse_address (cd, strp, opindex, code,
                                 & result_type, & value);
   if (errmsg == NULL)
   {
       if ( result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER )
            *valuep = (value >> 13) & 0x7;
       else if ( result_type == CGEN_PARSE_OPERAND_RESULT_QUEUED )
            *valuep = value;
   }
   return errmsg; 
 }


 static const char *
 parse_addr16_cjp (cd, strp, opindex, valuep)
      CGEN_CPU_DESC cd;
      const char **strp;
      int opindex;
      long *valuep;
 {
   const char *errmsg;
   enum cgen_parse_operand_result result_type;
   bfd_reloc_code_real_type code = BFD_RELOC_NONE;
   long value;
d357 14
a370 14
   if ( opindex == (CGEN_OPERAND_TYPE)IP2K_OPERAND_ADDR16CJP )
      code = BFD_RELOC_IP2K_ADDR16CJP;
   else if ( opindex == (CGEN_OPERAND_TYPE)IP2K_OPERAND_ADDR16P )
      code = BFD_RELOC_IP2K_PAGE3;

   errmsg = cgen_parse_address (cd, strp, opindex, code,
                                 & result_type, & value);
   if (errmsg == NULL)
   {
       if ( result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER )
       {
  	 if ( (value & 0x1) == 0)  /* If the address is even .... */
         {
             if ( opindex == (CGEN_OPERAND_TYPE)IP2K_OPERAND_ADDR16CJP )
d372 1
a372 1
             else if ( opindex == (CGEN_OPERAND_TYPE)IP2K_OPERAND_ADDR16P )
d374 1
a374 1
          }
d377 7
a383 6
       }else if ( result_type == CGEN_PARSE_OPERAND_RESULT_QUEUED )
       {
            /* This will happen for things like (s2-s1) where s2 and s1 */
 	    /* are labels.                                	        */
            *valuep = value;
        }
d386 3
a388 3
   }
   return errmsg; 
 }
d401 1
a401 1
  long value;
d489 1
a489 1
  if (errmsg) {
a490 1
  }
d492 27
a518 6
  if (mode) {
    value = (unsigned long) *valuep;
    if (value == 0) {
      errmsg = _("Attempt to find bit index of 0");
      return errmsg;
    }
d520 1
a520 12
    if (mode == 1) {
      count = 31;
      while ((value & 0x80000000) == 0) {
        count--;
        value <<= 1;
      }
    } else if (mode == 2) {
      count = 0;
      while ((value & 0x00000001) == 0) {
        count++;
        value >>= 1;
      }
a521 3
    
    *valuep = count;
  }
d529 13
d544 1
a544 1
     CGEN_CPU_DESC cd;
d547 3
a549 3
     unsigned int attrs;
     bfd_vma pc;
     int length;
d558 1
a558 1
  {
d561 1
a561 1
  }
d568 1
a568 1
  {
d570 1
a570 1
         (*info->fprintf_func) (info->stream, "%s","(DP)");
d572 1
a572 1
         (*info->fprintf_func) (info->stream, "$%x%s",offsetvalue, "(DP)");
d574 1
a574 1
  }
d578 1
a578 1
  {
d580 1
a580 1
         (*info->fprintf_func) (info->stream, "%s", "(SP)");
d582 1
a582 1
         (*info->fprintf_func) (info->stream, "$%x%s", offsetvalue,"(SP)");
d584 1
a584 1
  }
d600 1
a600 1
     CGEN_CPU_DESC cd;
d603 3
a605 3
     unsigned int attrs;
     bfd_vma pc;
     int length;
d614 1
a614 1
     CGEN_CPU_DESC cd;
d617 3
a619 3
     unsigned int attrs;
     bfd_vma pc;
     int length;
d628 1
a628 1
     CGEN_CPU_DESC cd;
d631 3
a633 3
     unsigned int attrs;
     bfd_vma pc;
     int length;
d642 1
a642 1
     CGEN_CPU_DESC cd;
d645 3
a647 3
     unsigned int attrs;
     bfd_vma pc;
     int length;
d660 1
a660 1
     CGEN_CPU_DESC cd;
d663 3
a665 3
     unsigned int attrs;
     bfd_vma pc;
     int length;
d674 1
a674 1
     CGEN_CPU_DESC cd;
d677 3
a679 3
     unsigned int attrs;
     bfd_vma pc;
     int length;
d690 1
a690 1
     CGEN_CPU_DESC cd;
d693 3
a695 3
     unsigned int attrs;
     bfd_vma pc;
     int length;
d706 1
a706 1
     CGEN_CPU_DESC cd;
d709 3
a711 3
     unsigned int attrs;
     bfd_vma pc;
     int length;
@


1.1.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d32 18
a49 3
extern unsigned int ip2k_asm_hash PARAMS ((const char *insn));
extern int ip2k_cgen_insn_supported
  PARAMS ((CGEN_CPU_DESC, const CGEN_INSN *));
a52 2
#include "safe-ctype.h"

d61 2
a62 2
  for (hash = 0; *m && !ISSPACE(*m); m++)
    hash = (hash * 23) ^ (0x1F & TOLOWER(*m));
a69 14
/* Special check to ensure that instruction exists for given machine. */
int
ip2k_cgen_insn_supported (cd, insn)
     CGEN_CPU_DESC cd;
     const CGEN_INSN *insn;
{
  int machs = CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_MACH);

  /* No mach attribute?  Assume it's supported for all machs.  */
  if (machs == 0)
    return 1;
  
  return ((machs & cd->machs) != 0);
}
a73 11
#define PARSE_FUNC_DECL(name) \
static const char *name PARAMS ((CGEN_CPU_DESC, const char **, int, long *))

PARSE_FUNC_DECL (parse_fr);
PARSE_FUNC_DECL (parse_addr16);
PARSE_FUNC_DECL (parse_addr16_p);
PARSE_FUNC_DECL (parse_addr16_cjp);
PARSE_FUNC_DECL (parse_lit8);
PARSE_FUNC_DECL (parse_bit3);


d82 1
a82 1
  const char *old_strp;
d87 1
a87 1
  bfd_vma tempvalue;
d96 2
a97 2
    {
      (*strp)++;
d99 9
a107 9
      if ( (strncmp(*strp,",",1)==0) || ISSPACE(**strp) )
	{
	  /* We've been passed a w.  Return with an error message so that  */
	  /* cgen will try the next parsing option.                        */
	  errmsg = _("W keyword invalid in FR operand slot.");
	  return errmsg;
	}
      *strp = old_strp;
    }
d113 1
a113 2
  errmsg = cgen_parse_keyword (cd, strp, & ip2k_cgen_opval_register_names,
			       valuep);
d115 2
a116 2
    if (errmsg == NULL)
      return errmsg;
d122 4
a125 4
    {
      /* Make sure it's not in lower case */
      afteroffset = strstr(*strp,"(ip)");
    }
d152 4
a155 4
    {
      /* Maybe it's in lower case */
      afteroffset = strstr(*strp,"(dp)");
    }
d158 30
a187 32
    {
      if ( afteroffset == *strp )
	{
	  /* No offset present. Use 0 by default. */
	  tempvalue = 0;
	  errmsg = NULL;
	}
      else
	{
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_IP2K_FR_OFFSET,
				       & result_type, & tempvalue);
	}

      if (errmsg == NULL)
	{
	  if (tempvalue <= 127)
	    {
	      /* Value is ok.  Fix up the first 2 bits and return */       
	      *valuep = 0x0100 | tempvalue;
	      *strp += 4; /* skip over the (DP) in *strp */
	      return errmsg;
	    }
	  else
	    {
	      /* Found something there in front of (DP) but it's out
		 of range. */
	      errmsg = _("(DP) offset out of range.");
	      return errmsg;
	    }
	}
    }
d197 4
a200 4
    {
      /* Maybe it's in lower case. */
      afteroffset = strstr(*strp, "(sp)");
    }
d203 26
a228 29
    {
      if ( afteroffset ==  *strp )
	{
	  /* No offset present. Use 0 by default. */
	  tempvalue = 0;
	  errmsg = NULL;
	}
      else
	{
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_IP2K_FR_OFFSET,
				       & result_type, & tempvalue);
	}
      if (errmsg == NULL)
	{
	  if (tempvalue <= 127)
	    {
	      /* Value is ok.  Fix up the first 2 bits and return */
	      *valuep = 0x0180 | tempvalue;
	      *strp += 4; /* skip over the (SP) in *strp */
	      return errmsg;
	    }
	  else
	    {
	      /* Found something there in front of (SP) but it's out
		 of range. */
	      errmsg = _("(SP) offset out of range.");
	      return errmsg;
	    }
d230 2
a231 2
	}
    }
d248 1
a248 2
      /* if a numeric value is specified, ensure that it is between
	 1 and 255 */
d268 1
a268 1
  bfd_vma value;
d271 1
a271 1
    code = BFD_RELOC_IP2K_HI8DATA;
d273 1
a273 1
    code = BFD_RELOC_IP2K_LO8DATA;
d282 1
a282 1
			       & result_type, & value);
d285 1
a285 1
      /* We either have a relocation or a number now. */
d287 3
a289 3
	{
	  /* We got a number back. */
	  if ( code == BFD_RELOC_IP2K_HI8DATA )
d291 1
a291 1
	  else    /* code = BFD_RELOC_IP2K_LOW8DATA */
d293 3
a295 3
	}   
      *valuep = value;
    }
d301 11
a311 11
static const char *
parse_addr16_p (cd, strp, opindex, valuep)
     CGEN_CPU_DESC cd;
     const char **strp;
     int opindex;
     long *valuep;
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type;
  bfd_reloc_code_real_type code = BFD_RELOC_IP2K_PAGE3;
  bfd_vma value;
d313 24
a336 24
  errmsg = cgen_parse_address (cd, strp, opindex, code,
			       & result_type, & value);
  if (errmsg == NULL)
    {
      if ( result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER )
	*valuep = (value >> 13) & 0x7;
      else if ( result_type == CGEN_PARSE_OPERAND_RESULT_QUEUED )
	*valuep = value;
    }
  return errmsg; 
}


static const char *
parse_addr16_cjp (cd, strp, opindex, valuep)
     CGEN_CPU_DESC cd;
     const char **strp;
     int opindex;
     long *valuep;
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type;
  bfd_reloc_code_real_type code = BFD_RELOC_NONE;
  bfd_vma value;
d338 14
a351 14
  if ( opindex == (CGEN_OPERAND_TYPE)IP2K_OPERAND_ADDR16CJP )
    code = BFD_RELOC_IP2K_ADDR16CJP;
  else if ( opindex == (CGEN_OPERAND_TYPE)IP2K_OPERAND_ADDR16P )
    code = BFD_RELOC_IP2K_PAGE3;

  errmsg = cgen_parse_address (cd, strp, opindex, code,
			       & result_type, & value);
  if (errmsg == NULL)
    {
      if ( result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER )
	{
	  if ( (value & 0x1) == 0)  /* If the address is even .... */
	    {
	      if ( opindex == (CGEN_OPERAND_TYPE)IP2K_OPERAND_ADDR16CJP )
d353 1
a353 1
	      else if ( opindex == (CGEN_OPERAND_TYPE)IP2K_OPERAND_ADDR16P )
d355 1
a355 1
	    }
d358 6
a363 7
	}
      else if ( result_type == CGEN_PARSE_OPERAND_RESULT_QUEUED )
	{
	  /* This will happen for things like (s2-s1) where s2 and s1
	     are labels.  */
	  *valuep = value;
	}
d366 3
a368 3
    }
  return errmsg; 
}
d381 1
a381 1
  bfd_vma value;
d469 1
a469 1
  if (errmsg)
d471 1
d473 6
a478 8
  if (mode)
    {
      value = (unsigned long) *valuep;
      if (value == 0)
	{
	  errmsg = _("Attempt to find bit index of 0");
	  return errmsg;
	}
d480 13
a492 18
      if (mode == 1)
	{
	  count = 31;
	  while ((value & 0x80000000) == 0)
	    {
	      count--;
	      value <<= 1;
	    }
	}
      else if (mode == 2)
	{
	  count = 0;
	  while ((value & 0x00000001) == 0)
	    {
	      count++;
	      value >>= 1;
	    }
	}
d494 2
a495 2
      *valuep = count;
    }
a502 13
#define PRINT_FUNC_DECL(name) \
static void name PARAMS ((CGEN_CPU_DESC, PTR, long, unsigned int, bfd_vma, int))

PRINT_FUNC_DECL (print_fr);
PRINT_FUNC_DECL (print_dollarhex);
PRINT_FUNC_DECL (print_dollarhex8);
PRINT_FUNC_DECL (print_dollarhex16);
PRINT_FUNC_DECL (print_dollarhex_addr16h);
PRINT_FUNC_DECL (print_dollarhex_addr16l);
PRINT_FUNC_DECL (print_dollarhex_p);
PRINT_FUNC_DECL (print_dollarhex_cj);
PRINT_FUNC_DECL (print_decimal);

d505 1
a505 1
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
d508 3
a510 3
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
d519 1
a519 1
    {
d522 1
a522 1
    }
d529 1
a529 1
    {
d531 1
a531 1
	(*info->fprintf_func) (info->stream, "%s","(DP)");
d533 1
a533 1
	(*info->fprintf_func) (info->stream, "$%x%s",offsetvalue, "(DP)");
d535 1
a535 1
    }
d539 1
a539 1
    {
d541 1
a541 1
	(*info->fprintf_func) (info->stream, "%s", "(SP)");
d543 1
a543 1
	(*info->fprintf_func) (info->stream, "$%x%s", offsetvalue,"(SP)");
d545 1
a545 1
    }
d561 1
a561 1
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
d564 3
a566 3
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
d575 1
a575 1
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
d578 3
a580 3
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
d589 1
a589 1
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
d592 3
a594 3
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
d603 1
a603 1
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
d606 3
a608 3
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
d621 1
a621 1
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
d624 3
a626 3
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
d635 1
a635 1
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
d638 3
a640 3
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
d651 1
a651 1
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
d654 3
a656 3
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
d667 1
a667 1
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
d670 3
a672 3
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
@


1.1.12.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d32 18
a49 3
extern unsigned int ip2k_asm_hash PARAMS ((const char *insn));
extern int ip2k_cgen_insn_supported
  PARAMS ((CGEN_CPU_DESC, const CGEN_INSN *));
a52 2
#include "safe-ctype.h"

d61 2
a62 2
  for (hash = 0; *m && !ISSPACE(*m); m++)
    hash = (hash * 23) ^ (0x1F & TOLOWER(*m));
a69 14
/* Special check to ensure that instruction exists for given machine. */
int
ip2k_cgen_insn_supported (cd, insn)
     CGEN_CPU_DESC cd;
     const CGEN_INSN *insn;
{
  int machs = CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_MACH);

  /* No mach attribute?  Assume it's supported for all machs.  */
  if (machs == 0)
    return 1;
  
  return ((machs & cd->machs) != 0);
}
a73 11
#define PARSE_FUNC_DECL(name) \
static const char *name PARAMS ((CGEN_CPU_DESC, const char **, int, long *))

PARSE_FUNC_DECL (parse_fr);
PARSE_FUNC_DECL (parse_addr16);
PARSE_FUNC_DECL (parse_addr16_p);
PARSE_FUNC_DECL (parse_addr16_cjp);
PARSE_FUNC_DECL (parse_lit8);
PARSE_FUNC_DECL (parse_bit3);


d82 1
a82 1
  const char *old_strp;
d87 1
a87 1
  bfd_vma tempvalue;
d96 2
a97 2
    {
      (*strp)++;
d99 9
a107 9
      if ( (strncmp(*strp,",",1)==0) || ISSPACE(**strp) )
	{
	  /* We've been passed a w.  Return with an error message so that  */
	  /* cgen will try the next parsing option.                        */
	  errmsg = _("W keyword invalid in FR operand slot.");
	  return errmsg;
	}
      *strp = old_strp;
    }
d113 1
a113 2
  errmsg = cgen_parse_keyword (cd, strp, & ip2k_cgen_opval_register_names,
			       valuep);
d115 2
a116 2
    if (errmsg == NULL)
      return errmsg;
d122 4
a125 4
    {
      /* Make sure it's not in lower case */
      afteroffset = strstr(*strp,"(ip)");
    }
d152 4
a155 4
    {
      /* Maybe it's in lower case */
      afteroffset = strstr(*strp,"(dp)");
    }
d158 30
a187 32
    {
      if ( afteroffset == *strp )
	{
	  /* No offset present. Use 0 by default. */
	  tempvalue = 0;
	  errmsg = NULL;
	}
      else
	{
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_IP2K_FR_OFFSET,
				       & result_type, & tempvalue);
	}

      if (errmsg == NULL)
	{
	  if (tempvalue <= 127)
	    {
	      /* Value is ok.  Fix up the first 2 bits and return */       
	      *valuep = 0x0100 | tempvalue;
	      *strp += 4; /* skip over the (DP) in *strp */
	      return errmsg;
	    }
	  else
	    {
	      /* Found something there in front of (DP) but it's out
		 of range. */
	      errmsg = _("(DP) offset out of range.");
	      return errmsg;
	    }
	}
    }
d197 4
a200 4
    {
      /* Maybe it's in lower case. */
      afteroffset = strstr(*strp, "(sp)");
    }
d203 26
a228 29
    {
      if ( afteroffset ==  *strp )
	{
	  /* No offset present. Use 0 by default. */
	  tempvalue = 0;
	  errmsg = NULL;
	}
      else
	{
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_IP2K_FR_OFFSET,
				       & result_type, & tempvalue);
	}
      if (errmsg == NULL)
	{
	  if (tempvalue <= 127)
	    {
	      /* Value is ok.  Fix up the first 2 bits and return */
	      *valuep = 0x0180 | tempvalue;
	      *strp += 4; /* skip over the (SP) in *strp */
	      return errmsg;
	    }
	  else
	    {
	      /* Found something there in front of (SP) but it's out
		 of range. */
	      errmsg = _("(SP) offset out of range.");
	      return errmsg;
	    }
d230 2
a231 2
	}
    }
d248 1
a248 2
      /* if a numeric value is specified, ensure that it is between
	 1 and 255 */
d268 1
a268 1
  bfd_vma value;
d271 1
a271 1
    code = BFD_RELOC_IP2K_HI8DATA;
d273 1
a273 1
    code = BFD_RELOC_IP2K_LO8DATA;
d282 1
a282 1
			       & result_type, & value);
d285 1
a285 1
      /* We either have a relocation or a number now. */
d287 3
a289 3
	{
	  /* We got a number back. */
	  if ( code == BFD_RELOC_IP2K_HI8DATA )
d291 1
a291 1
	  else    /* code = BFD_RELOC_IP2K_LOW8DATA */
d293 3
a295 3
	}   
      *valuep = value;
    }
d301 11
a311 11
static const char *
parse_addr16_p (cd, strp, opindex, valuep)
     CGEN_CPU_DESC cd;
     const char **strp;
     int opindex;
     long *valuep;
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type;
  bfd_reloc_code_real_type code = BFD_RELOC_IP2K_PAGE3;
  bfd_vma value;
d313 24
a336 24
  errmsg = cgen_parse_address (cd, strp, opindex, code,
			       & result_type, & value);
  if (errmsg == NULL)
    {
      if ( result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER )
	*valuep = (value >> 13) & 0x7;
      else if ( result_type == CGEN_PARSE_OPERAND_RESULT_QUEUED )
	*valuep = value;
    }
  return errmsg; 
}


static const char *
parse_addr16_cjp (cd, strp, opindex, valuep)
     CGEN_CPU_DESC cd;
     const char **strp;
     int opindex;
     long *valuep;
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type;
  bfd_reloc_code_real_type code = BFD_RELOC_NONE;
  bfd_vma value;
d338 14
a351 14
  if ( opindex == (CGEN_OPERAND_TYPE)IP2K_OPERAND_ADDR16CJP )
    code = BFD_RELOC_IP2K_ADDR16CJP;
  else if ( opindex == (CGEN_OPERAND_TYPE)IP2K_OPERAND_ADDR16P )
    code = BFD_RELOC_IP2K_PAGE3;

  errmsg = cgen_parse_address (cd, strp, opindex, code,
			       & result_type, & value);
  if (errmsg == NULL)
    {
      if ( result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER )
	{
	  if ( (value & 0x1) == 0)  /* If the address is even .... */
	    {
	      if ( opindex == (CGEN_OPERAND_TYPE)IP2K_OPERAND_ADDR16CJP )
d353 1
a353 1
	      else if ( opindex == (CGEN_OPERAND_TYPE)IP2K_OPERAND_ADDR16P )
d355 1
a355 1
	    }
d358 6
a363 7
	}
      else if ( result_type == CGEN_PARSE_OPERAND_RESULT_QUEUED )
	{
	  /* This will happen for things like (s2-s1) where s2 and s1
	     are labels.  */
	  *valuep = value;
	}
d366 3
a368 3
    }
  return errmsg; 
}
d381 1
a381 1
  bfd_vma value;
d469 1
a469 1
  if (errmsg)
d471 1
d473 6
a478 8
  if (mode)
    {
      value = (unsigned long) *valuep;
      if (value == 0)
	{
	  errmsg = _("Attempt to find bit index of 0");
	  return errmsg;
	}
d480 13
a492 18
      if (mode == 1)
	{
	  count = 31;
	  while ((value & 0x80000000) == 0)
	    {
	      count--;
	      value <<= 1;
	    }
	}
      else if (mode == 2)
	{
	  count = 0;
	  while ((value & 0x00000001) == 0)
	    {
	      count++;
	      value >>= 1;
	    }
	}
d494 2
a495 2
      *valuep = count;
    }
a502 13
#define PRINT_FUNC_DECL(name) \
static void name PARAMS ((CGEN_CPU_DESC, PTR, long, unsigned int, bfd_vma, int))

PRINT_FUNC_DECL (print_fr);
PRINT_FUNC_DECL (print_dollarhex);
PRINT_FUNC_DECL (print_dollarhex8);
PRINT_FUNC_DECL (print_dollarhex16);
PRINT_FUNC_DECL (print_dollarhex_addr16h);
PRINT_FUNC_DECL (print_dollarhex_addr16l);
PRINT_FUNC_DECL (print_dollarhex_p);
PRINT_FUNC_DECL (print_dollarhex_cj);
PRINT_FUNC_DECL (print_decimal);

d505 1
a505 1
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
d508 3
a510 3
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
d519 1
a519 1
    {
d522 1
a522 1
    }
d529 1
a529 1
    {
d531 1
a531 1
	(*info->fprintf_func) (info->stream, "%s","(DP)");
d533 1
a533 1
	(*info->fprintf_func) (info->stream, "$%x%s",offsetvalue, "(DP)");
d535 1
a535 1
    }
d539 1
a539 1
    {
d541 1
a541 1
	(*info->fprintf_func) (info->stream, "%s", "(SP)");
d543 1
a543 1
	(*info->fprintf_func) (info->stream, "$%x%s", offsetvalue,"(SP)");
d545 1
a545 1
    }
d561 1
a561 1
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
d564 3
a566 3
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
d575 1
a575 1
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
d578 3
a580 3
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
d589 1
a589 1
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
d592 3
a594 3
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
d603 1
a603 1
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
d606 3
a608 3
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
d621 1
a621 1
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
d624 3
a626 3
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
d635 1
a635 1
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
d638 3
a640 3
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
d651 1
a651 1
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
d654 3
a656 3
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
d667 1
a667 1
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
d670 3
a672 3
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
@


1.1.2.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@@

