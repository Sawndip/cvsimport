head	1.17;
access;
symbols
	sid-snapshot-20110801:1.16
	cgen-snapshot-20110801:1.16
	sid-snapshot-20110701:1.16
	cgen-snapshot-20110701:1.16
	sid-snapshot-20110601:1.16
	cgen-snapshot-20110601:1.16
	sid-snapshot-20110501:1.16
	cgen-snapshot-20110501:1.16
	sid-snapshot-20110401:1.16
	cgen-snapshot-20110401:1.16
	sid-snapshot-20110301:1.16
	cgen-snapshot-20110301:1.16
	sid-snapshot-20110201:1.16
	cgen-snapshot-20110201:1.16
	sid-snapshot-20110101:1.16
	cgen-snapshot-20110101:1.16
	sid-snapshot-20101201:1.16
	cgen-snapshot-20101201:1.16
	sid-snapshot-20101101:1.15
	cgen-snapshot-20101101:1.15
	sid-snapshot-20101001:1.15
	cgen-snapshot-20101001:1.15
	sid-snapshot-20100901:1.15
	cgen-snapshot-20100901:1.15
	sid-snapshot-20100801:1.15
	cgen-snapshot-20100801:1.15
	sid-snapshot-20100701:1.15
	cgen-snapshot-20100701:1.15
	sid-snapshot-20100601:1.14
	cgen-snapshot-20100601:1.14
	sid-snapshot-20100501:1.14
	cgen-snapshot-20100501:1.14
	sid-snapshot-20100401:1.14
	cgen-snapshot-20100401:1.14
	sid-snapshot-20100301:1.14
	cgen-snapshot-20100301:1.14
	sid-snapshot-20100201:1.14
	cgen-snapshot-20100201:1.14
	sid-snapshot-20100101:1.14
	cgen-snapshot-20100101:1.14
	sid-snapshot-20091201:1.14
	cgen-snapshot-20091201:1.14
	sid-snapshot-20091101:1.14
	cgen-snapshot-20091101:1.14
	sid-snapshot-20091001:1.14
	cgen-snapshot-20091001:1.14
	arc-sim-20090309:1.12
	sid-snapshot-20090901:1.14
	cgen-snapshot-20090901:1.14
	sid-snapshot-20090801:1.13
	cgen-snapshot-20090801:1.13
	sid-snapshot-20090701:1.13
	cgen-snapshot-20090701:1.13
	dje-cgen-play1-branch:1.13.0.4
	dje-cgen-play1-branchpoint:1.13
	cgen-1_1-branch:1.13.0.2
	cgen-1_1-branchpoint:1.13
	sid-snapshot-20090601:1.13
	cgen-snapshot-20090601:1.13
	sid-snapshot-20090501:1.13
	cgen-snapshot-20090501:1.13
	sid-snapshot-20090401:1.13
	cgen-snapshot-20090401:1.13
	arc-insight_6_8-branch:1.12.0.6
	arc-insight_6_8-branchpoint:1.12
	sid-snapshot-20090301:1.13
	cgen-snapshot-20090301:1.13
	sid-snapshot-20090201:1.13
	cgen-snapshot-20090201:1.13
	sid-snapshot-20090101:1.13
	cgen-snapshot-20090101:1.13
	sid-snapshot-20081201:1.13
	cgen-snapshot-20081201:1.13
	sid-snapshot-20081101:1.13
	cgen-snapshot-20081101:1.13
	sid-snapshot-20081001:1.13
	cgen-snapshot-20081001:1.13
	sid-snapshot-20080901:1.13
	cgen-snapshot-20080901:1.13
	sid-snapshot-20080801:1.13
	cgen-snapshot-20080801:1.13
	sid-snapshot-20080701:1.13
	cgen-snapshot-20080701:1.13
	sid-snapshot-20080601:1.12
	cgen-snapshot-20080601:1.12
	sid-snapshot-20080501:1.12
	cgen-snapshot-20080501:1.12
	sid-snapshot-20080403:1.12
	sid-snapshot-20080401:1.12
	cgen-snapshot-20080401:1.12
	sid-snapshot-20080301:1.12
	cgen-snapshot-20080301:1.12
	sid-snapshot-20080201:1.12
	cgen-snapshot-20080201:1.12
	sid-snapshot-20080101:1.12
	cgen-snapshot-20080101:1.12
	sid-snapshot-20071201:1.12
	cgen-snapshot-20071201:1.12
	sid-snapshot-20071101:1.12
	cgen-snapshot-20071101:1.12
	sid-snapshot-20071001:1.12
	cgen-snapshot-20071001:1.12
	msnyder-fork-checkpoint-branch:1.12.0.4
	msnyder-fork-checkpoint-branchpoint:1.12
	gdb-csl-arm-20051020-branch:1.12.0.2
	gdb-csl-arm-20051020-branchpoint:1.12
	drow_intercu-merge-20040921:1.12
	drow_intercu-merge-20040915:1.12
	jimb-gdb_6_2-e500-branch:1.11.0.28
	jimb-gdb_6_2-e500-branchpoint:1.11
	gdb_6_2-20040730-release:1.11
	gdb_6_2-branch:1.11.0.24
	gdb_6_2-2004-07-10-gmt-branchpoint:1.11
	gdb_6_1_1-20040616-release:1.11
	gdb_6_1-2004-04-05-release:1.11
	drow_intercu-merge-20040402:1.11
	drow_intercu-merge-20040327:1.11
	ezannoni_pie-20040323-branch:1.11.0.22
	ezannoni_pie-20040323-branchpoint:1.11
	cagney_tramp-20040321-mergepoint:1.11
	cagney_tramp-20040309-branch:1.11.0.20
	cagney_tramp-20040309-branchpoint:1.11
	gdb_6_1-branch:1.11.0.18
	gdb_6_1-2004-03-01-gmt-branchpoint:1.11
	drow_intercu-20040221-branch:1.11.0.16
	drow_intercu-20040221-branchpoint:1.11
	cagney_bfdfile-20040213-branch:1.11.0.14
	cagney_bfdfile-20040213-branchpoint:1.11
	drow-cplus-merge-20040208:1.11
	carlton_dictionary-20040126-merge:1.11
	cagney_bigcore-20040122-branch:1.11.0.12
	cagney_bigcore-20040122-branchpoint:1.11
	drow-cplus-merge-20040113:1.11
	drow-cplus-merge-20031224:1.11
	drow-cplus-merge-20031220:1.11
	carlton_dictionary-20031215-merge:1.11
	drow-cplus-merge-20031214:1.11
	carlton-dictionary-20031111-merge:1.11
	gdb_6_0-2003-10-04-release:1.11
	kettenis_sparc-20030918-branch:1.11.0.10
	kettenis_sparc-20030918-branchpoint:1.11
	carlton_dictionary-20030917-merge:1.11
	ezannoni_pie-20030916-branchpoint:1.11
	ezannoni_pie-20030916-branch:1.11.0.8
	cagney_x86i386-20030821-branch:1.11.0.6
	cagney_x86i386-20030821-branchpoint:1.11
	carlton_dictionary-20030805-merge:1.11
	carlton_dictionary-20030627-merge:1.11
	gdb_6_0-branch:1.11.0.4
	gdb_6_0-2003-06-23-branchpoint:1.11
	jimb-ppc64-linux-20030613-branch:1.11.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.11
	cagney_convert-20030606-branch:1.10.0.2
	cagney_convert-20030606-branchpoint:1.10
	cagney_writestrings-20030508-branch:1.9.0.8
	cagney_writestrings-20030508-branchpoint:1.9
	jimb-ppc64-linux-20030528-branch:1.9.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.9
	carlton_dictionary-20030523-merge:1.9
	cagney_fileio-20030521-branch:1.9.0.4
	cagney_fileio-20030521-branchpoint:1.9
	kettenis_i386newframe-20030517-mergepoint:1.9
	jimb-ppc64-linux-20030509-branch:1.9.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.9
	kettenis_i386newframe-20030504-mergepoint:1.9
	carlton_dictionary-20030430-merge:1.8
	kettenis_i386newframe-20030419-branch:1.8.0.8
	kettenis_i386newframe-20030419-branchpoint:1.8
	carlton_dictionary-20030416-merge:1.8
	cagney_frameaddr-20030409-mergepoint:1.8
	kettenis_i386newframe-20030406-branch:1.8.0.6
	kettenis_i386newframe-20030406-branchpoint:1.8
	cagney_frameaddr-20030403-branchpoint:1.8
	cagney_frameaddr-20030403-branch:1.8.0.4
	cagney_framebase-20030330-mergepoint:1.8
	cagney_framebase-20030326-branch:1.8.0.2
	cagney_framebase-20030326-branchpoint:1.8
	cagney_lazyid-20030317-branch:1.7.0.6
	cagney_lazyid-20030317-branchpoint:1.7
	kettenis-i386newframe-20030316-mergepoint:1.7
	offbyone-20030313-branch:1.7.0.4
	offbyone-20030313-branchpoint:1.7
	kettenis-i386newframe-20030308-branch:1.7.0.2
	kettenis-i386newframe-20030308-branchpoint:1.7
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.2
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.4
	interps-20030202-branchpoint:1.5
	cagney-unwind-20030108-branch:1.5.0.2
	cagney-unwind-20030108-branchpoint:1.5
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.2
	carlton_dictionary-20021115-merge:1.2
	kseitz_interps-20021105-merge:1.2
	kseitz_interps-20021103-merge:1.2
	drow-cplus-merge-20021020:1.2
	drow-cplus-merge-20021025:1.2
	carlton_dictionary-20021025-merge:1.2
	carlton_dictionary-20021011-merge:1.2
	drow-cplus-branch:1.2.0.20
	drow-cplus-branchpoint:1.2
	kseitz_interps-20020930-merge:1.2
	carlton_dictionary-20020927-merge:1.2
	carlton_dictionary-branch:1.2.0.18
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.16
	gdb_5_3-branch:1.2.0.14
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.12
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.10
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.8
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.6
	cagney_regbuf-20020515-branchpoint:1.2
	jimb-macro-020506-branch:1.2.0.4
	jimb-macro-020506-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	cygnus_cvs_20020108_pre:1.1;
locks; strict;
comment	@# @;


1.17
date	2011.08.22.15.25.10;	author nickc;	state dead;
branches;
next	1.16;

1.16
date	2010.11.03.17.02.34;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.01.22.06.50;	author dj;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.24.06.46.16;	author devans;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.17.18.04.42;	author brolley;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.22.01.49.27;	author dj;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.10.21.22.04;	author devans;	state Exp;
branches
	1.11.16.1;
next	1.10;

1.10
date	2003.06.04.20.22.49;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.02.00.09.25;	author dj;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.21.06.15.55;	author dj;	state Exp;
branches
	1.8.8.1;
next	1.7;

1.7
date	2003.03.06.00.34.06;	author dj;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.18.22.57.08;	author dj;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.17.03.54.41;	author dj;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.25.21.14.16;	author dj;	state Exp;
branches;
next	1.3;

1.3
date	2002.11.20.03.14.19;	author dj;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.11.07.24.49;	author mrg;	state Exp;
branches
	1.2.18.1
	1.2.20.1;
next	1.1;

1.1
date	2001.12.07.22.51.28;	author geoffk;	state Exp;
branches;
next	;

1.2.18.1
date	2002.12.23.19.38.05;	author carlton;	state Exp;
branches;
next	1.2.18.2;

1.2.18.2
date	2003.03.06.00.56.19;	author carlton;	state Exp;
branches;
next	1.2.18.3;

1.2.18.3
date	2003.04.16.19.56.47;	author carlton;	state Exp;
branches;
next	1.2.18.4;

1.2.18.4
date	2003.05.23.18.40.30;	author carlton;	state Exp;
branches;
next	1.2.18.5;

1.2.18.5
date	2003.06.27.21.49.35;	author carlton;	state Exp;
branches;
next	;

1.2.20.1
date	2003.12.14.20.26.56;	author drow;	state Exp;
branches;
next	;

1.8.8.1
date	2003.05.04.11.37.37;	author kettenis;	state Exp;
branches;
next	;

1.11.16.1
date	2004.09.16.17.00.41;	author drow;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Move cpu files from cgen/cpu to top level cpu directory.
@
text
@; xstormy16 CPU core description. -*- Scheme -*-
; Copyright (C) 2001, 2002, 2003, 2006, 2009 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.

(define-rtl-version 0 8)

(include "simplify.inc")

(define-arch
  (name xstormy16)
  (comment "Xstormy16 architecture")
  (insn-lsb0? #f)
  (machs xstormy16)
  (isas xstormy16)
)

(define-isa
  (name xstormy16)
  (comment "Xstormy16 instruction set")
  (default-insn-word-bitsize 32)
  (default-insn-bitsize 32)
  ; FIXME base-insn-bitsize should be 16 too, but at present CGEN has
  ; no support for instruction sets with opcode bits past
  ; base-insn-bitsize, so we must set it to at least 20.
  (base-insn-bitsize 32)
)

(define-cpu
  (name xstormy16)
  (comment "Xstormy16 CPU core")
  (endian little)
  (insn-endian little)
  (insn-chunk-bitsize 16)
  (word-bitsize 32)
)

(define-mach
  (name xstormy16)
  (comment "Xstormy16 CPU core")
  (cpu xstormy16)
  (isas xstormy16)
)

(define-model
  (name xstormy16)
  (comment "Xstormy16 CPU core")
  (unit u-exec "Execution Unit" ()
	1 1 ; issue done
	() () () ())
)

; IDOC attribute for instruction documentation.

(define-attr
  (for insn)
  (type enum)
  (name IDOC)
  (comment "insn kind for documentation")
  (attrs META)
  (values
   (MEM - () "Memory")
   (ALU - () "ALU")
   (FPU - () "FPU")
   (BR - () "Branch")
   (PRIV - () "Priviledged")
   (MISC - () "Miscellaneous")
  )
)

; Hardware elements.

(define-hardware
  (name h-pc)
  (comment "program counter")
  (attrs PC)
  (type pc)
  (set (newval) (c-call "h_pc_set_handler" newval))
)

(define-keyword
  (name gr-names)
  (enum-prefix H-GR-)
  (values (r0 0) (r1 1) (r2 2) (r3 3)
	  (r4 4) (r5 5) (r6 6) (r7 7)
	  (r8 8) (r9 9) (r10 10) (r11 11)
	  (r12 12) (r13 13) (r14 14) (r15 15)
	  (psw 14) (sp 15)))

(define-keyword
  (name gr-Rb-names)
  (enum-prefix H-RBJ-)
  (values (r8 0) (r9 1) (r10 2) (r11 3)
	  (r12 4) (r13 5) (r14 6) (r15 7)
	  (psw 6) (sp 7)))

(define-hardware
  (name h-gr)
  (comment "registers")
  (type register WI (16))
  (indices extern-keyword gr-names)
  (get (index) (and #xFFFF (raw-reg h-gr index)))
  (set (index newval) (c-call "h_gr_set_handler" index newval))
)

(define-hardware
  (name h-Rb)
  (comment "Rb registers")
  (attrs VIRTUAL)
  (type register SI(8))
  (indices extern-keyword gr-Rb-names)
  (get (index) (reg h-gr (add index 8)))
  (set (index newval) (set (reg h-gr (add index 8)) newval))
)

(define-hardware
  (name h-Rbj)
  (comment "Rbj registers")
  (attrs VIRTUAL)
  (type register SI(2))
  (indices extern-keyword gr-Rb-names)
  (get (index) (reg h-gr (add index 8)))
  (set (index newval) (set (reg h-gr (add index 8)) newval))
)

(define-hardware
  (name h-Rpsw)
  (comment "Register number field of the PSW")
  (attrs VIRTUAL)
  (type register WI)
  (get () (and #xF (srl psw 12)))
  (set (newval) (set psw (or (and psw #xFFF)
			     (sll HI newval 12)))))

(define-pmacro (define-psw-field fnam hnam index)
  (define-hardware
    (name hnam)
    (attrs VIRTUAL)
    (type register SI)
    (get () (and 1 (srl psw index)))
    (set (newval) (set psw (or (and psw (inv (sll HI 1 index)))
			       (sll HI newval index)))))
  ;(dnop fnam "" (SEM-ONLY) hnam f-nil)
)
(define-psw-field psw-z8  h-z8   0)
(dnop psw-z8 "" (SEM-ONLY) h-z8 f-nil)
(define-psw-field psw-z16 h-z16  1)
(dnop psw-z16 "" (SEM-ONLY) h-z16 f-nil)
(define-psw-field psw-cy  h-cy   2)
(dnop psw-cy "" (SEM-ONLY) h-cy f-nil)
(define-psw-field psw-hc  h-hc   3)
(dnop psw-hc "" (SEM-ONLY) h-hc f-nil)
(define-psw-field psw-ov  h-ov   4)
(dnop psw-ov "" (SEM-ONLY) h-ov f-nil)
(define-psw-field psw-pt  h-pt   5)
(dnop psw-pt "" (SEM-ONLY) h-pt f-nil)
(define-psw-field psw-s   h-s    6)
(dnop psw-s  "" (SEM-ONLY) h-s  f-nil)

(define-hardware
  (name h-branchcond)
  (comment "Condition of a branch instruction")
  (type immediate (UINT 4))
  (values keyword "" 
	  (("ge" 0) ("nc" 1) ("lt" 2) ("c" 3)
	   ("gt" 4) ("hi" 5) ("le" 6) ("ls" 7)
	   ("pl" 8) ("nv" 9) ("mi" 10) ("v" 11)
	   ("nz.b" 12) ("nz" 13) ("z.b" 14) ("z" 15)))
)

(define-hardware
  (name h-wordsize)
  (comment "Data size")
  (type immediate (UINT 1))
  (values keyword "" ((".b" 0) (".w" 1) ("" 1)))
)
	

; Instruction fields, and the corresponding operands.
; Register fields

(dnf f-Rd "general register destination" ()  12 4)
(dnop Rd "general register destination" ()  h-gr f-Rd)

(dnf f-Rdm "general register destination" ()  13 3)
(dnop Rdm "general register destination" ()  h-gr f-Rdm)

(dnf f-Rm "general register for memory" ()  4 3)
(dnop Rm "general register for memory" ()  h-gr f-Rm)

(dnf f-Rs  "general register source" ()  8 4)
(dnop Rs "general register source" ()  h-gr f-Rs)

(dnf f-Rb  "base register" ()  17 3)
(dnop Rb "base register" ()  h-Rb f-Rb)

(dnf f-Rbj "base register for jump" () 11 1)
(dnop Rbj "base register for jump" () h-Rbj f-Rbj)

; Main opcodes in 4 bit chunks

(dnf f-op1 "opcode" ()  0 4)
(define-normal-insn-enum insn-op1 "insn op enums" () OP1_ f-op1
 ( "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F" ))

(dnf f-op2 "opcode" ()  4 4)
(define-normal-insn-enum insn-op2 "insn op enums" () OP2_ f-op2
 ( "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F" ))
(dnop bcond2 "branch condition opcode" () h-branchcond f-op2)

(dnf f-op2a "opcode" ()  4 3)
(define-normal-insn-enum insn-op2a "insn op enums" () OP2A_ f-op2a
 ( "0" "2" "4" "6" "8" "A" "C" "E" ))

(dnf f-op2m "opcode" ()  7 1)
(define-normal-insn-enum insn-op2m "insn op enums" () OP2M_ f-op2m
 ( "0" "1" ))
(dnop ws2 "word size opcode" () h-wordsize f-op2m)

(dnf f-op3 "opcode" ()  8 4)
(define-normal-insn-enum insn-op3 "insn op enums" () OP3_ f-op3
 ( "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F" ))

(dnf f-op3a "opcode" ()  8 2)
(define-normal-insn-enum insn-op3a "insn op enums" () OP3A_ f-op3a
 ( "0" "1" "2" "3" ))

(dnf f-op3b "opcode" ()  8 3)
(define-normal-insn-enum insn-op3b "insn op enums" () OP3B_ f-op3b
 ( "0" "2" "4" "6" "8" "A" "C" "E" ))

(dnf f-op4 "opcode" ()  12 4)
(define-normal-insn-enum insn-op4 "insn op enums" () OP4_ f-op4
 ( "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F" ))

(dnf f-op4m "opcode" () 12 1)
(define-normal-insn-enum insn-op4m "insn op enums" () OP4M_ f-op4m
 ( "0" "1" ))

(dnf f-op4b "opcode" () 15 1)
(define-normal-insn-enum insn-op4b "insn op enums" () OP4B_ f-op4b
 ( "0" "1" ))

(dnf f-op5 "opcode" ()  16 4)
(define-normal-insn-enum insn-op5 "insn op enums" () OP5_ f-op5
 ( "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F" ))
(dnop bcond5 "branch condition opcode" () h-branchcond f-op5)

(dnf f-op5a "opcode" ()  16 1)
(define-normal-insn-enum insn-op5a "insn op enums" () OP5A_ f-op5a
 ( "0" "1" ))

; The whole first word
(dnf f-op "opcode" () 0 16)

; Immediate fields

(dnf f-imm2  "2 bit unsigned" () 10 2)
(dnop imm2 "2 bit unsigned immediate" () h-uint f-imm2)

(dnf f-imm3  "3 bit unsigned" () 4 3)
(dnop imm3 "3 bit unsigned immediate" () h-uint f-imm3)
(dnf f-imm3b  "3 bit unsigned for bit tests" () 17 3)
(dnop imm3b "3 bit unsigned immediate for bit tests" () h-uint f-imm3b)

(dnf f-imm4  "4 bit unsigned" () 8 4)
(define-operand 
  (name imm4)
  (comment "4 bit unsigned immediate")
  (attrs)
  (type h-uint)
  (index f-imm4)
  (handlers (parse "small_immediate"))
)

(dnf f-imm8  "8 bit unsigned" () 8 8)
(dnop imm8 "8 bit unsigned immediate" () h-uint f-imm8)
(define-operand 
  (name imm8small)
  (comment "8 bit unsigned immediate")
  (attrs)
  (type h-uint)
  (index f-imm8)
  (handlers (parse "small_immediate"))
)

(define-ifield
  (name f-imm12)
  (comment "12 bit signed")
  (attrs)
  (start 20)
  (length 12)
  (mode INT)
)
(dnop imm12 "12 bit signed immediate" () h-sint f-imm12)

(dnf f-imm16 "16 bit" (SIGN-OPT) 16 16)
(define-operand
  (name imm16)
  (comment "16 bit immediate")
  (attrs)
  (type h-uint)
  (index f-imm16)
  (handlers (parse "immediate16"))
)

(dnf f-lmem8  "8 bit unsigned low memory" (ABS-ADDR) 8 8)
(define-operand 
  (name lmem8)
  (comment "8 bit unsigned immediate low memory")
  (attrs)
  (type h-uint)
  (index f-lmem8)
  (handlers (parse "mem8"))
)
(define-ifield 
  (name f-hmem8)
  (comment "8 bit unsigned high memory")
  (attrs ABS-ADDR) 
  (start 8)
  (length 8)
  (mode UINT)
  (encode (value pc) (sub HI value #x7F00))
  (decode (value pc) (add HI value #x7F00))
)
(define-operand 
  (name hmem8)
  (comment "8 bit unsigned immediate high memory")
  (attrs)
  (type h-uint)
  (index f-hmem8)
  (handlers (parse "mem8"))
)

(define-ifield
  (name f-rel8-2)
  (comment "8 bit relative address for 2-byte instruction")
  (attrs PCREL-ADDR)
  (start 8)
  (length 8)
  (mode INT)
  (encode (value pc) (sub SI value (add SI pc 2)))
  (decode (value pc) (add SI value (add SI pc 2)))
)
(dnop rel8-2 "8 bit relative address" () h-uint f-rel8-2)

(define-ifield
  (name f-rel8-4)
  (comment "8 bit relative address for 4-byte instruction")
  (attrs PCREL-ADDR)
  (start 8)
  (length 8)
  (mode INT)
  (encode (value pc) (sub SI value (add SI pc 4)))
  (decode (value pc) (add SI value (add SI pc 4)))
)
(dnop rel8-4 "8 bit relative address" () h-uint f-rel8-4)

(define-ifield
  (name f-rel12)
  (comment "12 bit relative address")
  (attrs PCREL-ADDR)
  (start 20)
  (length 12)
  (mode INT)
  (encode (value pc) (sub SI value (add SI pc 4)))
  (decode (value pc) (add SI value (add SI pc 4)))
)
(dnop rel12 "12 bit relative address" () h-uint f-rel12)

(define-ifield
  (name f-rel12a)
  (comment "12 bit relative address")
  (attrs PCREL-ADDR)
  (start 4)
  (length 11)
  (mode INT)
  (encode (value pc) (sra SI (sub SI value (add SI pc 2)) 1))
  (decode (value pc) (add SI (sll value 1) (add SI pc 2)))
)
(dnop rel12a "12 bit relative address" () h-uint f-rel12a)

(dnf f-abs24-1  "abs24 low part" () 8 8)
(dnf f-abs24-2  "abs24 high part" () 16 16)
(define-multi-ifield
  (name f-abs24)
  (comment "Absolute address for jmpf instruction")
  (attrs ABS-ADDR)
  (mode UINT)
  (subfields f-abs24-1 f-abs24-2)
  (insert (sequence ()
		    (set (ifield f-abs24-1) (and (ifield f-abs24) #xFF))
		    (set (ifield f-abs24-2) (srl (ifield f-abs24) 8))))
  (extract (set (ifield f-abs24) (or (sll (ifield f-abs24-2) 8) f-abs24-1)))
)
(dnop abs24 "24 bit absolute address" () h-uint f-abs24)

; Names for registers
(dnop psw "program status word" (SEM-ONLY) h-gr 14)
(dnop Rpsw "N0-N3 of the program status word" (SEM-ONLY) h-Rpsw f-nil)
(dnop sp "stack pointer" (SEM-ONLY) h-gr 15)
(dnop R0 "R0" (SEM-ONLY) h-gr 0)
(dnop R1 "R1" (SEM-ONLY) h-gr 1)
(dnop R2 "R2" (SEM-ONLY) h-gr 2)
(dnop R8 "R8" (SEM-ONLY) h-gr 8)

; Useful macros.

; THe Z8, Z16, PT, and S flags of the PSW.
(define-pmacro (basic-psw value ws)
  (or (or (zflag (and value #xFF))
	  (sll HI (zflag HI value) 1))
      (or (sll HI (c-call BI "parity" value) 5)
	  (sll HI (nflag QI (srl value (mul ws 8))) 6))))


; Update the PSW for destination register Rd, set Rd to value.
(define-pmacro (set-psw Rd index value ws)
  (sequence ((HI nvalue))
    (set nvalue value)
    (set (reg HI h-gr index) nvalue)
    (set psw (or (and psw #x0F9C)
		 (or (sll index 12)
		     (basic-psw nvalue ws))))))

; Update the PSW for destination register Rd.
(define-pmacro (set-psw-nowrite index value ws)
  (sequence ((HI nvalue))
    (set nvalue value)
    (set psw (or (and psw #x0F9C)
		 (or (sll index 12)
		     (basic-psw nvalue ws))))))

; Update the PSW for destination non-register dest, set dest to value.
(define-pmacro (set-mem-psw dest value ws)
  (sequence ((HI nvalue))
    (set nvalue value)
    (set psw (or (and psw #xFF9C)
		 (basic-psw nvalue ws)))
    (set dest nvalue)))

; Update the PSW as with set-psw, but also set the carry flag.
(define-pmacro (set-psw-carry Rd index value carry ws)
  (sequence ((HI nvalue) (HI newpsw))
    (set nvalue value)
    (set newpsw (or (or (and psw #x0F98)
		     (sll (and carry #x1) 2))
		 (or (sll index 12)
		     (basic-psw nvalue ws))))
    (set (reg HI h-gr index) nvalue)
    (set psw newpsw)
    ))

; The all-purpose addition operation.
(define-pmacro (set-psw-add Rd index a b c)
  (sequence ((HI value) (HI newpsw))
    (set value (addc a b c))
    (set newpsw (or (or (and psw #x0F80)
			(basic-psw value 1))
		    (or (or (sll HI (add-oflag HI a b c) 4)
			    (sll HI (add-cflag HI a b c) 2))
			(or (and (srl HI (addc HI (and a #xF) (and b #xF) c) 
				      1) #x8)
			    (sll index 12)))))
    (set (reg HI h-gr index) value)
    (set psw newpsw)
    ))

; Set the PSW for a subtraction of a-b into Rd, but don't actually
; do the subtract.
(define-pmacro (set-psw-cmp Rd index a b)
  (sequence ((HI value))
    (set value (sub a b))
    (set psw (or (or (and psw #x0F80)
		     (basic-psw value 1))
		 (or (or (sll HI (sub-oflag HI a b 0) 4)
			 (sll HI (sub-cflag HI a b 0) 2))
		     (or (and (srl HI (sub HI (and a #xF) (and b #xF))
				   1) #x8)
			 (sll index 12)))))))

; Likewise, for subtraction
; (this chip has a borrow for subtraction, rather than
; just using a carry for both).
(define-pmacro (set-psw-sub Rd index a b c)
  (sequence ((HI value) (HI newpsw))
    (set value (subc a b c))
    (set newpsw (or (or (and psw #x0F80)
		     (basic-psw value 1))
		 (or (or (sll HI (sub-oflag HI a b c) 4)
			 (sll HI (sub-cflag HI a b c) 2))
		     (or (and (srl HI (subc HI (and a #xF) (and b #xF) c)
				   1) #x8)
			 (sll index 12)))))
    (set (reg HI h-gr index) value)
    (set psw newpsw)
    ))

; A 17-bit rotate-left operation
(define-pmacro (set-psw-rotate17 Rd index src c rot)
  (sequence ((SI tmpfoo))
    (set tmpfoo (or (or (and (sll SI src 15) #x7FFE0000) 
		     src)
		 (or (sll SI c 31)
		     (sll SI c 16))))
    (set tmpfoo (rol tmpfoo (and rot #x1F)))
    (set-psw-carry (reg HI h-gr index) index (trunc HI tmpfoo) (and (srl tmpfoo 16) 1) 1)))

; A 17-bit rotate-right operation
(define-pmacro (set-psw-rrotate17 Rd index src c rot)
  (sequence ((SI tmpfoo))
    (set tmpfoo (or (or (and (sll SI src 17) #xFFFE0000) 
		     src)
		 (sll SI c 16)))
    (set tmpfoo (ror tmpfoo (and rot #x0F)))
    (set-psw-carry (reg HI h-gr index) index (trunc HI tmpfoo) (and (srl tmpfoo 16) 1) 1)))


; Move Operations

(define-pmacro (alignfix-mem where)
  (mem HI (and where #xFFFE)))

(define-pmacro (set-alignfix-mem where what)
  (set (mem HI (and where #xFFFE)) what))

(define-pmacro (alignfix-mem-far where)
  (mem HI (and where #xFFFFFFFE)))

(define-pmacro (set-alignfix-mem-far where what)
  (set (mem HI (and where #xFFFFFFFE)) what))

(dni movlmemimm
     "Move immediate to low memory"
     ()
     ("mov$ws2 $lmem8,#$imm16")
     (+ OP1_7 OP2A_8 ws2 lmem8 imm16)
     (if ws2
	 (set-mem-psw (mem HI (and lmem8 #xFFFE)) imm16 ws2)
	 (set-mem-psw (mem QI lmem8) (and imm16 #xFF) ws2))
     ()
)
(dni movhmemimm
     "Move immediate to high memory"
     ()
     ("mov$ws2 $hmem8,#$imm16")
     (+ OP1_7 OP2A_A ws2 hmem8 imm16)
     (if ws2
	 (set-mem-psw (mem HI (and hmem8 #xFFFE)) imm16 ws2)
	 (set-mem-psw (mem QI hmem8) (and imm16 #xFF) ws2))
     ()
)

(dni movlgrmem
     "Move low memory to register"
     ()
     ("mov$ws2 $Rm,$lmem8")
     (+ OP1_8 Rm ws2 lmem8)
     (if ws2 
	 (set-psw Rm (index-of Rm) (alignfix-mem lmem8) ws2)
	 (set-psw Rm (index-of Rm) (mem QI lmem8) ws2))
     ()
)
(dni movhgrmem
     "Move high memory to register"
     ()
     ("mov$ws2 $Rm,$hmem8")
     (+ OP1_A Rm ws2 hmem8)
     (if ws2 
	 (set-psw Rm (index-of Rm) (alignfix-mem hmem8) ws2)
	 (set-psw Rm (index-of Rm) (mem QI hmem8) ws2))
     ()
)

(dni movlmemgr
     "Move low memory register to byte"
     ()
     ("mov$ws2 $lmem8,$Rm")
     (+ OP1_9 Rm ws2 lmem8)
     (if ws2 
	 (set-mem-psw (mem HI (and lmem8 #xFFFE)) Rm ws2)
	 (set-mem-psw (mem QI lmem8) Rm ws2))
     ()
)
(dni movhmemgr
     "Move high memory register to byte"
     ()
     ("mov$ws2 $hmem8,$Rm")
     (+ OP1_B Rm ws2 hmem8)
     (if ws2 
	 (set-mem-psw (mem HI (and hmem8 #xFFFE)) Rm ws2)
	 (set-mem-psw (mem QI hmem8) Rm ws2))
     ()
)

(dni movgrgri
     "Move memory addressed by register to register"
     ()
     ("mov$ws2 $Rdm,($Rs)")
     (+ OP1_7 OP2A_0 ws2 Rs OP4M_0 Rdm)
     (if ws2
	 (set-psw Rdm (index-of Rdm) (alignfix-mem Rs) ws2)
	 (set-psw Rdm (index-of Rdm) (and #xFF (mem QI Rs)) ws2))
     ()
)

(dni movgrgripostinc
     "Move memory addressed by postincrement register to register"
     ()
     ("mov$ws2 $Rdm,($Rs++)")
     (+ OP1_6 OP2A_0 ws2 Rs OP4M_0 Rdm)
     (sequence ()
	       (if ws2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem Rs) ws2)
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI Rs)) ws2))
	       (set Rs (add Rs (add 1 ws2))))
     ()
)

(dni movgrgripredec
     "Move memory addressed by predecrement register to register"
     ()
     ("mov$ws2 $Rdm,(--$Rs)")
     (+ OP1_6 OP2A_8 ws2 Rs OP4M_0 Rdm)
     (sequence ()
	       (set Rs (sub Rs (add 1 ws2)))
	       (if ws2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem Rs) ws2)
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI Rs)) ws2)))
     ()
)

(dni movgrigr
     "Move register to memory addressed by register"
     ()
     ("mov$ws2 ($Rs),$Rdm")
     (+ OP1_7 OP2A_2 ws2 Rs OP4M_0 Rdm)
     (sequence ()
	       (if ws2
		   (set-alignfix-mem Rs Rdm)
		   (set (mem QI Rs) Rdm))
	       (set-psw-nowrite (index-of Rdm) Rdm ws2))
     ()
)

(dni movgripostincgr
     "Move register to memory addressed by postincrement register"
     ()
     ("mov$ws2 ($Rs++),$Rdm")
     (+ OP1_6 OP2A_2 ws2 Rs OP4M_0 Rdm)
     (sequence ()
	       (if ws2
		   (set-alignfix-mem Rs Rdm)
		   (set (mem QI Rs) Rdm))
	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
	       (set Rs (add Rs (add ws2 1))))
     ()
)

(dni movgripredecgr
     "Move register to memory addressed by predecrement register"
     ()
     ("mov$ws2 (--$Rs),$Rdm")
     (+ OP1_6 OP2A_A ws2 Rs OP4M_0 Rdm)
     (sequence ()
	       (set Rs (sub Rs (add ws2 1)))
	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
	       (if ws2
		   (set-alignfix-mem Rs Rdm)
		   (set (mem QI Rs) Rdm)))
     ()
)

(dni movgrgrii
     "Move memory addressed by indexed register to register"
     ()
     ("mov$ws2 $Rdm,($Rs,$imm12)")
     (+ OP1_7 OP2A_0 ws2 Rs OP4M_1 Rdm OP5_0 imm12)
     (if ws2
	 (set-psw Rdm (index-of Rdm) (alignfix-mem (add Rs imm12)) ws2)
	 (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add Rs imm12))) ws2))
     ()
)

(dni movgrgriipostinc
     "Move memory addressed by indexed register postincrement to register"
     ()
     ("mov$ws2 $Rdm,($Rs++,$imm12)")
     (+ OP1_6 OP2A_0 ws2 Rs OP4M_1 Rdm OP5_0 imm12)
     (sequence ()
	       (if ws2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem (add Rs imm12)) ws2)
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add Rs imm12))) ws2))
	       (set Rs (add Rs (add ws2 1))))
     ()
)

(dni movgrgriipredec
     "Move memory addressed by indexed register predecrement to register"
     ()
     ("mov$ws2 $Rdm,(--$Rs,$imm12)")
     (+ OP1_6 OP2A_8 ws2 Rs OP4M_1 Rdm OP5_0 imm12)
     (sequence ()
	       (set Rs (sub Rs (add ws2 1)))
	       (if ws2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem (add Rs imm12)) ws2)
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add Rs imm12))) ws2)))
     ()
)

(dni movgriigr
     "Move register to memory addressed by indexed register"
     ()
     ("mov$ws2 ($Rs,$imm12),$Rdm")
     (+ OP1_7 OP2A_2 ws2 Rs OP4M_1 Rdm OP5_0 imm12)
     (sequence ()
	       (if ws2
		   (set-alignfix-mem (add Rs imm12) Rdm)
		   (set (mem QI (add Rs imm12)) Rdm))
	       (set-psw-nowrite (index-of Rdm) Rdm ws2))
     ()
)

(dni movgriipostincgr
     "Move register to memory addressed by indexed register postincrement"
     ()
     ("mov$ws2 ($Rs++,$imm12),$Rdm")
     (+ OP1_6 OP2A_2 ws2 Rs OP4M_1 Rdm OP5_0 imm12)
     (sequence ()
	       (if ws2
		   (set-alignfix-mem (add Rs imm12) Rdm)
		   (set (mem QI (add Rs imm12)) Rdm))
	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
	       (set Rs (add Rs (add ws2 1))))
     ()
)

(dni movgriipredecgr
     "Move register to memory addressed by indexed register predecrement"
     ()
     ("mov$ws2 (--$Rs,$imm12),$Rdm")
     (+ OP1_6 OP2A_A ws2 Rs OP4M_1 Rdm OP5_0 imm12)
     (sequence ()
	       (set Rs (sub Rs (add ws2 1)))
	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
	       (if ws2
		   (set-alignfix-mem (add Rs imm12) Rdm)
		   (set (mem QI (add Rs imm12)) Rdm)))
     ()
)

(dni movgrgr
     "Move general register to general register"
     ()
     ("mov $Rd,$Rs")
     (+ OP1_4 OP2_6 Rs Rd)
     (set-psw Rd (index-of Rd) Rs 1)
     ()
)

(dnmi movimm8
     "Move 8-bit immediate"
     ()
     ("mov Rx,#$imm8")
     (emit movwimm8 imm8)
)

(dni movwimm8
     "Move 8-bit immediate"
     ()
     ("mov.w Rx,#$imm8")
     (+ OP1_4 OP2_7 imm8)
     (set-psw (reg HI h-gr Rpsw) Rpsw imm8 1)
     ()
)

(dnmi movgrimm8
     "Move 8-bit immediate to general register"
     ()
     ("mov $Rm,#$imm8small")
     (emit movwgrimm8 Rm imm8small)
)

(dni movwgrimm8
     "Move 8-bit immediate to general register"
     ()
     ("mov.w $Rm,#$imm8small")
     (+ OP1_2 Rm OP2M_1 imm8small)
     (set-psw Rm (index-of Rm) imm8small 1)
     ()
)

(dnmi movgrimm16
     "Move 16-bit immediate to general register"
     ()
     ("mov $Rd,#$imm16")
     (emit movwgrimm16 Rd imm16)
)

(dni movwgrimm16
     "Move 16-bit immediate to general register"
     ()
     ("mov.w $Rd,#$imm16")
     (+ OP1_3 OP2_1 OP3_3 Rd imm16)
     (set-psw Rd (index-of Rd) imm16 1)
     ()
)

(dni movlowgr
     "Move 8 low bits to general register"
     ()
     ("mov.b $Rd,RxL")
     (+ OP1_3 OP2_0 OP3_C Rd)
     (set-psw Rd (index-of Rd) (or (and Rd #xFF00) (and (reg HI h-gr Rpsw) #xFF)) 0)
     ()
)

(dni movhighgr
     "Move 8 high bits to general register"
     ()
     ("mov.b $Rd,RxH")
     (+ OP1_3 OP2_0 OP3_D Rd)
     (set-psw Rd (index-of Rd) (or (and Rd #x00FF) (and (reg HI h-gr Rpsw) #xFF00)) 1)
     ()
)

(dni movfgrgri
     "Move far memory addressed by register to register"
     ()
     ("movf$ws2 $Rdm,($Rs)")
     (+ OP1_7 OP2A_4 ws2 Rs OP4M_0 Rdm)
     (if ws2
	 (set-psw Rdm (index-of Rdm) (alignfix-mem-far (or (sll SI R8 16) Rs)) ws2)
	 (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (or (sll SI R8 16) Rs))) ws2))
     ()
)

(dni movfgrgripostinc
     "Move far memory addressed by postincrement register to register"
     ()
     ("movf$ws2 $Rdm,($Rs++)")
     (+ OP1_6 OP2A_4 ws2 Rs OP4M_0 Rdm)
     (sequence ()
	       (if ws2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem-far (join SI HI R8 Rs)) ws2)
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (join SI HI R8 Rs))) ws2))
	       (set Rs (add Rs (add ws2 1))))
     ()
)

(dni movfgrgripredec
     "Move far memory addressed by predecrement register to register"
     ()
     ("movf$ws2 $Rdm,(--$Rs)")
     (+ OP1_6 OP2A_C ws2 Rs OP4M_0 Rdm)
     (sequence ()
	       (set Rs (sub Rs (add ws2 1)))
	       (if ws2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem-far (join SI HI R8 Rs)) ws2)
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (join SI HI R8 Rs))) ws2)))
     ()
)

(dni movfgrigr
     "Move far register to memory addressed by register"
     ()
     ("movf$ws2 ($Rs),$Rdm")
     (+ OP1_7 OP2A_6 ws2 Rs OP4M_0 Rdm)
     (sequence ()
	       (if ws2
		   (set-alignfix-mem-far (join SI HI R8 Rs) Rdm)
		   (set (mem QI (join SI HI R8 Rs)) Rdm))
	       (set-psw-nowrite (index-of Rdm) Rdm ws2))
     ()
)

(dni movfgripostincgr
     "Move far register to memory addressed by postincrement register"
     ()
     ("movf$ws2 ($Rs++),$Rdm")
     (+ OP1_6 OP2A_6 ws2 Rs OP4M_0 Rdm)
     (sequence ()
	       (if ws2
		   (set-alignfix-mem-far (join SI HI R8 Rs) Rdm)
		   (set (mem QI (join SI HI R8 Rs)) Rdm))
	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
	       (set Rs (add Rs (add ws2 1))))
     ()
)

(dni movfgripredecgr
     "Move far register to memory addressed by predecrement register"
     ()
     ("movf$ws2 (--$Rs),$Rdm")
     (+ OP1_6 OP2A_E ws2 Rs OP4M_0 Rdm)
     (sequence ()
	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
	       (set Rs (sub Rs (add ws2 1)))
	       (if ws2
		   (set-alignfix-mem-far (join SI HI R8 Rs) Rdm)
		   (set (mem QI (join SI HI R8 Rs)) Rdm)))
     ()
)

(dni movfgrgrii
     "Move far memory addressed by indexed register to register"
     ()
     ("movf$ws2 $Rdm,($Rb,$Rs,$imm12)")
     (+ OP1_7 OP2A_4 ws2 Rs OP4M_1 Rdm OP5A_0 Rb imm12)
     (if ws2
	 (set-psw Rdm (index-of Rdm) (alignfix-mem-far (add (join SI HI Rb Rs) imm12)) ws2)
	 (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add (join SI HI Rb Rs) imm12))) ws2))
     ()
)

(dni movfgrgriipostinc
 "Move far memory addressed by indexed register postincrement to register"
     ()
     ("movf$ws2 $Rdm,($Rb,$Rs++,$imm12)")
     (+ OP1_6 OP2A_4 ws2 Rs OP4M_1 Rdm OP5A_0 Rb imm12)
     (sequence ()
	       (if ws2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem-far (add (join SI HI Rb Rs) imm12)) ws2)
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add (join SI HI Rb Rs) imm12))) ws2))
	       (set Rs (add Rs (add ws2 1)))
	       ; Note - despite the XStormy16 ISA documentation the
	       ; addition *is* propogated into the base register.
	       (if (eq Rs 0) (set Rb (add Rb 1)))
	       )
     ()
)

(dni movfgrgriipredec
 "Move far memory addressed by indexed register predecrement to register"
     ()
     ("movf$ws2 $Rdm,($Rb,--$Rs,$imm12)")
     (+ OP1_6 OP2A_C ws2 Rs OP4M_1 Rdm OP5A_0 Rb imm12)
     (sequence ()
	       ; Note - despite the XStormy16 ISA documentation the
	       ; subtraction *is* propogated into the base register.
	       (if (eq Rs 0) (set Rb (sub Rb 1)))
	       (set Rs (sub Rs (add ws2 1)))
	       (if ws2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem-far (add (join SI HI Rb Rs) imm12)) ws2)
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add (join SI HI Rb Rs) imm12))) ws2)))
     ()
)

(dni movfgriigr
     "Move far register to memory addressed by indexed register"
     ()
     ("movf$ws2 ($Rb,$Rs,$imm12),$Rdm")
     (+ OP1_7 OP2A_6 ws2 Rs OP4M_1 Rdm OP5A_0 Rb imm12)
     (sequence ()
	       (if ws2
		   (set (mem HI (and (add (join SI HI Rb Rs) imm12) #xFFFFFFFE))
			Rdm)
		   (set (mem QI (add (join SI HI Rb Rs) imm12)) Rdm))
	       (set-psw-nowrite (index-of Rdm) Rdm ws2))
     ()
)


(dni movfgriipostincgr
     "Move far register to memory addressed by indexed register postincrement"
     ()
     ("movf$ws2 ($Rb,$Rs++,$imm12),$Rdm")
     (+ OP1_6 OP2A_6 ws2 Rs OP4M_1 Rdm OP5A_0 Rb imm12)
     (sequence ()
	       (if ws2
		   (set (mem HI (and (add (join SI HI Rb Rs) imm12) #xFFFFFFFE)) Rdm)
		   (set (mem QI (add (join SI HI Rb Rs) imm12)) Rdm))
	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
	       (set Rs (add Rs (add ws2 1)))
	       ; Note - despite the XStormy16 ISA documentation the
	       ; addition *is* propogated into the base register.
	       (if (eq Rs 0) (set Rb (add Rb 1)))
	       )
     ()
)

(dni movfgriipredecgr
  "Move far register to memory addressed by indexed register predecrement"
     ()
     ("movf$ws2 ($Rb,--$Rs,$imm12),$Rdm")
     (+ OP1_6 OP2A_E ws2 Rs OP4M_1 Rdm OP5A_0 Rb imm12)
     (sequence ()
	       ; Note - despite the XStormy16 ISA documentation the
	       ; subtraction *is* propogated into the base register.
	       (if (eq Rs 0) (set Rb (sub Rb 1)))
	       (set Rs (sub Rs (add ws2 1)))
	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
	       (if ws2
		   (set (mem HI (and (add (join SI HI Rb Rs) imm12) #xFFFFFFFE)) Rdm)
		   (set (mem QI (add (join SI HI Rb Rs) imm12)) Rdm)))
     ()
)

(dni maskgrgr
     "Mask insert controlled by general register"
     ()
     ("mask $Rd,$Rs")
     (+ OP1_3 OP2_3 Rs Rd)
     (set-psw Rd (index-of Rd) (or HI (and HI Rd (inv HI Rs)) (and (reg HI h-gr Rpsw) Rs)) 1)
     ()
)

(dni maskgrimm16
     "Mask insert controlled by immediate value"
     ()
     ("mask $Rd,#$imm16")
     (+ OP1_3 OP2_0 OP3_E Rd imm16)
     (set-psw Rd (index-of Rd) (or (and Rd (inv imm16)) (and (reg HI h-gr Rpsw) imm16)) 1)
     ()
)

; Push, Pop
(dni pushgr
     "Push register"
     ()
     ("push $Rd")
     (+ OP1_0 OP2_0 OP3_8 Rd)
     (sequence ()
	       (set (mem HI sp) Rd)
	       (set sp (add sp 2)))
     ()
)

(dni popgr
     "Pop into a register"
     ()
     ("pop $Rd")
     (+ OP1_0 OP2_0 OP3_9 Rd)
     (sequence ()
	       (set sp (add sp -2))
	       (set Rd (mem HI sp)))
     ()
)

; Swap
(dni swpn
     "Swap low nibbles"
     ()
     ("swpn $Rd")
     (+ OP1_3 OP2_0 OP3_9 Rd)
     (set-psw Rd (index-of Rd) (or (or (and (sll Rd 4) #xF0)
			 (and (srl Rd 4) #x0F))
		     (and Rd #xFF00)) 0)
     ()
)

(dni swpb
     "Swap bytes"
     ()
     ("swpb $Rd")
     (+ OP1_3 OP2_0 OP3_8 Rd)
     (set-psw Rd (index-of Rd) (or (sll Rd 8) (srl Rd 8)) 1)
     ()
)

(dni swpw
     "Swap words"
     ()
     ("swpw $Rd,$Rs")
     (+ OP1_3 OP2_2 Rs Rd)
     (sequence ((HI foo))
	       (set foo Rs)
	       (set Rs Rd)
	       (set-psw Rd (index-of Rd) foo 1))
     ()
)

; Logical Operations
(dni andgrgr
     "AND general register with general register"
     ()
     ("and $Rd,$Rs")
     (+ OP1_4 OP2_0 Rs Rd)
     (set-psw Rd (index-of Rd) (and Rd Rs) 1)
     ()
)

(dni andimm8
     "AND with 8-bit immediate"
     ()
     ("and Rx,#$imm8")
     (+ OP1_4 OP2_1 imm8)
     (set-psw (reg HI h-gr Rpsw) Rpsw (and (reg HI h-gr Rpsw) imm8) 1)
     ()
)

(dni andgrimm16
     "AND general register with 16-bit immediate"
     ()
     ("and $Rd,#$imm16")
     (+ OP1_3 OP2_1 OP3_0 Rd imm16)
     (set-psw Rd (index-of Rd) (and Rd imm16) 1)
     ()
)

(dni orgrgr
     "OR general register with general register"
     ()
     ("or $Rd,$Rs")
     (+ OP1_4 OP2_2 Rs Rd)
     (set-psw Rd (index-of Rd) (or Rd Rs) 1)
     ()
)

(dni orimm8
     "OR with 8-bit immediate"
     ()
     ("or Rx,#$imm8")
     (+ OP1_4 OP2_3 imm8)
     (set-psw (reg HI h-gr Rpsw) Rpsw (or (reg HI h-gr Rpsw) imm8) 1)
     ()
)

(dni orgrimm16
     "OR general register with 16-bit immediate"
     ()
     ("or $Rd,#$imm16")
     (+ OP1_3 OP2_1 OP3_1 Rd imm16)
     (set-psw Rd (index-of Rd) (or Rd imm16) 1)
     ()
)

(dni xorgrgr
     "XOR general register with general register"
     ()
     ("xor $Rd,$Rs")
     (+ OP1_4 OP2_4 Rs Rd)
     (set-psw Rd (index-of Rd) (xor Rd Rs) 1)
     ()
)

(dni xorimm8
     "XOR with 8-bit immediate"
     ()
     ("xor Rx,#$imm8")
     (+ OP1_4 OP2_5 imm8)
     (set-psw (reg HI h-gr Rpsw) Rpsw (xor (reg HI h-gr Rpsw) imm8) 1)
     ()
)

(dni xorgrimm16
     "XOR general register with 16-bit immediate"
     ()
     ("xor $Rd,#$imm16")
     (+ OP1_3 OP2_1 OP3_2 Rd imm16)
     (set-psw Rd (index-of Rd) (xor Rd imm16) 1)
     ()
)

(dni notgr
     "NOT general register"
     ()
     ("not $Rd")
     (+ OP1_3 OP2_0 OP3_B Rd)
     (set-psw Rd (index-of Rd) (inv Rd) 1)
     ()
)

; Arithmetic operations
(dni addgrgr
     "ADD general register to general register"
     ()
     ("add $Rd,$Rs")
     (+ OP1_4 OP2_9 Rs Rd)
     (set-psw-add Rd (index-of Rd) Rd Rs 0)
     ()
)

(dni addgrimm4
     "ADD 4-bit immediate to general register"
     ()
     ("add $Rd,#$imm4")
     (+ OP1_5 OP2_1 imm4 Rd)
     (set-psw-add Rd (index-of Rd) Rd imm4 0)
     ()
)

(dni addimm8
     "ADD 8-bit immediate"
     ()
     ("add Rx,#$imm8")
     (+ OP1_5 OP2_9 imm8)
     (set-psw-add (reg HI h-gr Rpsw) Rpsw (reg HI h-gr Rpsw) imm8 0)
     ()
)

(dni addgrimm16
     "ADD 16-bit immediate to general register"
     ()
     ("add $Rd,#$imm16")
     (+ OP1_3 OP2_1 OP3_4 Rd imm16)
     (set-psw-add Rd (index-of Rd) Rd imm16 0)
     ()
)

(dni adcgrgr
     "ADD carry and general register to general register"
     ()
     ("adc $Rd,$Rs")
     (+ OP1_4 OP2_B Rs Rd)
     (set-psw-add Rd (index-of Rd) Rd Rs psw-cy)
     ()
)

(dni adcgrimm4
     "ADD carry and 4-bit immediate to general register"
     ()
     ("adc $Rd,#$imm4")
     (+ OP1_5 OP2_3 imm4 Rd)
     (set-psw-add Rd (index-of Rd) Rd imm4 psw-cy)
     ()
)

(dni adcimm8
     "ADD carry and 8-bit immediate"
     ()
     ("adc Rx,#$imm8")
     (+ OP1_5 OP2_B imm8)
     (set-psw-add (reg HI h-gr Rpsw) Rpsw (reg HI h-gr Rpsw) imm8 psw-cy)
     ()
)

(dni adcgrimm16
     "ADD carry and 16-bit immediate to general register"
     ()
     ("adc $Rd,#$imm16")
     (+ OP1_3 OP2_1 OP3_5 Rd imm16)
     (set-psw-add Rd (index-of Rd) Rd imm16 psw-cy)
     ()
)

(dni subgrgr
     "SUB general register from general register"
     ()
     ("sub $Rd,$Rs")
     (+ OP1_4 OP2_D Rs Rd)
     (set-psw-sub Rd (index-of Rd) Rd Rs 0)
     ()
)

(dni subgrimm4
     "SUB 4-bit immediate from general register"
     ()
     ("sub $Rd,#$imm4")
     (+ OP1_5 OP2_5 imm4 Rd)
     (set-psw-sub Rd (index-of Rd) Rd imm4 0)
     ()
)

(dni subimm8
     "SUB 8-bit immediate"
     ()
     ("sub Rx,#$imm8")
     (+ OP1_5 OP2_D imm8)
     (set-psw-sub (reg HI h-gr Rpsw) Rpsw (reg HI h-gr Rpsw) imm8 0)
     ()
)

(dni subgrimm16
     "SUB 16-bit immediate from general register"
     ()
     ("sub $Rd,#$imm16")
     (+ OP1_3 OP2_1 OP3_6 Rd imm16)
     (set-psw-sub Rd (index-of Rd) Rd imm16 0)
     ()
)

(dni sbcgrgr
     "SUB carry and general register from general register"
     ()
     ("sbc $Rd,$Rs")
     (+ OP1_4 OP2_F Rs Rd)
     (set-psw-sub Rd (index-of Rd) Rd Rs psw-cy)
     ()
)

(dni sbcgrimm4
     "SUB carry and 4-bit immediate from general register"
     ()
     ("sbc $Rd,#$imm4")
     (+ OP1_5 OP2_7 imm4 Rd)
     (set-psw-sub Rd (index-of Rd) Rd imm4 psw-cy)
     ()
)

(dni sbcgrimm8
     "SUB carry and 8-bit immediate"
     ()
     ("sbc Rx,#$imm8")
     (+ OP1_5 OP2_F imm8)
     (set-psw-sub (reg HI h-gr Rpsw) Rpsw (reg HI h-gr Rpsw) imm8 psw-cy)
     ()
)

(dni sbcgrimm16
     "SUB carry and 16-bit immediate from general register"
     ()
     ("sbc $Rd,#$imm16")
     (+ OP1_3 OP2_1 OP3_7 Rd imm16)
     (set-psw-sub Rd (index-of Rd) Rd imm16 psw-cy)
     ()
)

(dnmi incgr
     "Increment general register"
     ()
     ("inc $Rd")
     (emit incgrimm2 Rd (imm2 0))
)

(dni incgrimm2
     "Increment general register by 2-bit immediate"
     ()
     ("inc $Rd,#$imm2")
     (+ OP1_3 OP2_0 OP3A_0 imm2 Rd)
     (set-psw Rd (index-of Rd) (add Rd (add imm2 1)) 1)
     ()
)

(dnmi decgr
     "Decrement general register"
     ()
     ("dec $Rd")
     (emit decgrimm2 Rd (imm2 0))
)

(dni decgrimm2
     "Decrement general register by 2-bit immediate"
     ()
     ("dec $Rd,#$imm2")
     (+ OP1_3 OP2_0 OP3A_1 imm2 Rd)
     (set-psw Rd (index-of Rd) (sub Rd (add imm2 1)) 1)
     ()
)

; Logical Shift
(dni rrcgrgr
     "Rotate right general register by general register"
     ()
     ("rrc $Rd,$Rs")
     (+ OP1_3 OP2_8 Rs Rd)
     (set-psw-rrotate17 Rd (index-of Rd) Rd psw-cy Rs)
     ()
)

(dni rrcgrimm4
     "Rotate right general register by immediate"
     ()
     ("rrc $Rd,#$imm4")
     (+ OP1_3 OP2_9 imm4 Rd)
     (set-psw-rrotate17 Rd (index-of Rd) Rd psw-cy imm4)
     ()
)

(dni rlcgrgr
     "Rotate left general register by general register"
     ()
     ("rlc $Rd,$Rs")
     (+ OP1_3 OP2_A Rs Rd)
     (set-psw-rotate17 Rd (index-of Rd) Rd psw-cy (and Rs #xF))
     ()
)

(dni rlcgrimm4
     "Rotate left general register by immediate"
     ()
     ("rlc $Rd,#$imm4")
     (+ OP1_3 OP2_B imm4 Rd)
     (set-psw-rotate17 Rd (index-of Rd) Rd psw-cy imm4)
     ()
)

(dni shrgrgr
     "Shift right general register by general register"
     ()
     ("shr $Rd,$Rs")
     (+ OP1_3 OP2_C Rs Rd)
     (set-psw-carry Rd (index-of Rd) 
		    (srl Rd (and Rs #xF)) 
		    (and SI (if SI (eq (and Rs #xF) 0)
			     psw-cy
			     (srl Rd (sub (and Rs #xF) 1)))
			 1) 1)
     ()
)

(dni shrgrimm
     "Shift right general register by immediate"
     ()
     ("shr $Rd,#$imm4")
     (+ OP1_3 OP2_D imm4 Rd)
     (set-psw-carry Rd (index-of Rd) 
		    (srl Rd imm4) 
		    (and SI (if SI (eq imm4 0)
			     psw-cy
			     (srl Rd (sub imm4 1)))
			 1) 1)
     ()
)

(dni shlgrgr
     "Shift left general register by general register"
     ()
     ("shl $Rd,$Rs")
     (+ OP1_3 OP2_E Rs Rd)
     (set-psw-carry Rd (index-of Rd) 
		    (sll Rd (and Rs #xF)) 
		    (srl SI (if SI (eq (and Rs #xF) 0)
			     (sll psw-cy 15)
			     (sll Rd (sub (and Rs #xF) 1)))
			 15) 1)
     ()
)

(dni shlgrimm
     "Shift left general register by immediate"
     ()
     ("shl $Rd,#$imm4")
     (+ OP1_3 OP2_F imm4 Rd)
     (set-psw-carry Rd (index-of Rd) 
		    (sll Rd imm4) 
		    (srl SI (if SI (eq imm4 0)
			     (sll psw-cy 15)
			     (sll Rd (sub imm4 1)))
			 15) 1)
     ()
)

(dni asrgrgr
     "Arithmetic shift right general register by general register"
     ()
     ("asr $Rd,$Rs")
     (+ OP1_3 OP2_6 Rs Rd)
     (set-psw-carry Rd (index-of Rd) 
		    (sra HI Rd (and Rs #xF)) 
		    (and SI (if SI (eq (and Rs #xF) 0)
			     psw-cy
			     (srl Rd (sub (and Rs #xF) 1)))
			 1) 1)
     ()
)

(dni asrgrimm
     "Arithmetic shift right general register by immediate"
     ()
     ("asr $Rd,#$imm4")
     (+ OP1_3 OP2_7 imm4 Rd)
     (set-psw-carry Rd (index-of Rd) 
		    (sra HI Rd imm4) 
		    (and SI (if SI (eq imm4 0)
			     psw-cy
			     (srl Rd (sub imm4 1)))
			 1) 1)
     ()
)

; Bitwise operations
(dni set1grimm
     "Set bit in general register by immediate"
     ()
     ("set1 $Rd,#$imm4")
     (+ OP1_0 OP2_9 imm4 Rd)
     (set-psw Rd (index-of Rd) (or Rd (sll 1 imm4)) 1)
     ()
)

(dni set1grgr
     "Set bit in general register by general register"
     ()
     ("set1 $Rd,$Rs")
     (+ OP1_0 OP2_B Rs Rd)
     (set-psw Rd (index-of Rd) (or Rd (sll 1 (and Rs #xF))) 1)
     ()
)

(dni set1lmemimm
     "Set bit in low memory by immediate"
     ()
     ("set1 $lmem8,#$imm3")
     (+ OP1_E imm3 OP2M_1 lmem8)
     (set-mem-psw (mem QI lmem8) (or (mem QI lmem8) (sll 1 imm3)) 0)
     ()
)
(dni set1hmemimm
     "Set bit in high memory by immediate"
     ()
     ("set1 $hmem8,#$imm3")
     (+ OP1_F imm3 OP2M_1 hmem8)
     (set-mem-psw (mem QI hmem8) (or (mem QI hmem8) (sll 1 imm3)) 0)
     ()
)

(dni clr1grimm
     "Clear bit in general register by immediate"
     ()
     ("clr1 $Rd,#$imm4")
     (+ OP1_0 OP2_8 imm4 Rd)
     (set-psw Rd (index-of Rd) (and Rd (inv (sll 1 imm4))) 1)
     ()
)

(dni clr1grgr
     "Clear bit in general register by general register"
     ()
     ("clr1 $Rd,$Rs")
     (+ OP1_0 OP2_A Rs Rd)
     (set-psw Rd (index-of Rd) (and Rd (inv (sll 1 (and Rs #xF)))) 1)
     ()
)

(dni clr1lmemimm
     "Clear bit in low memory"
     ()
     ("clr1 $lmem8,#$imm3")
     (+ OP1_E imm3 OP2M_0 lmem8)
     (set-mem-psw (mem QI lmem8) (and (mem QI lmem8) (inv (sll 1 imm3))) 0)
     ()
)
(dni clr1hmemimm
     "Clear bit in high memory"
     ()
     ("clr1 $hmem8,#$imm3")
     (+ OP1_F imm3 OP2M_0 hmem8)
     (set-mem-psw (mem QI hmem8) (and (mem QI hmem8) (inv (sll 1 imm3))) 0)
     ()
)

; Data conversion

(dni cbwgr
     "Sign-extend byte in general register"
     ()
     ("cbw $Rd")
     (+ OP1_3 OP2_0 OP3_A Rd)
     (set-psw Rd (index-of Rd) (ext HI (trunc QI Rd)) 1)
     ()
)

(dni revgr
     "Reverse bit pattern in general register"
     ()
     ("rev $Rd")
     (+ OP1_3 OP2_0 OP3_F Rd)
     (set-psw Rd (index-of Rd)
       (or (sll (and Rd #x0001) 15)
       (or (sll (and Rd #x0002) 13)
       (or (sll (and Rd #x0004) 11)
       (or (sll (and Rd #x0008) 9)
       (or (sll (and Rd #x0010) 7)
       (or (sll (and Rd #x0020) 5)
       (or (sll (and Rd #x0040) 3)
       (or (sll (and Rd #x0080) 1)
       (or (srl (and Rd #x0100) 1)
       (or (srl (and Rd #x0200) 3)
       (or (srl (and Rd #x0400) 5)
       (or (srl (and Rd #x0800) 7)
       (or (srl (and Rd #x1000) 9)
       (or (srl (and Rd #x2000) 11)
       (or (srl (and Rd #x4000) 13)
           (srl (and Rd #x8000) 15))))))))))))))))
       1)
     ()
)

; Conditional Branches

(define-pmacro (cbranch cond dest)
  (sequence ((BI tmp))
	    (case cond
	      ((0)  (set tmp (not (xor psw-s psw-ov))))			; ge
	      ((1)  (set tmp (not psw-cy)))				; nc
	      ((2)  (set tmp (xor psw-s psw-ov)))			; lt
	      ((3)  (set tmp psw-cy))					; c
	      ((4)  (set tmp (not (or (xor psw-s psw-ov) psw-z16))))	; gt
	      ((5)  (set tmp (not (or psw-cy psw-z16))))		; hi
	      ((6)  (set tmp (or (xor psw-s psw-ov) psw-z16)))		; le
	      ((7)  (set tmp (or psw-cy psw-z16)))			; ls
	      ((8)  (set tmp (not psw-s)))				; pl
	      ((9)  (set tmp (not psw-ov)))				; nv
	      ((10) (set tmp psw-s))					; mi
	      ((11) (set tmp psw-ov))					; v
	      ((12) (set tmp (not psw-z8)))				; nz.b
	      ((13) (set tmp (not psw-z16)))				; nz
	      ((14) (set tmp psw-z8))					; z.b
	      ((15) (set tmp psw-z16)))					; z
	    (if tmp (set pc dest)))
)

(dni bccgrgr
     "Conditional branch comparing general register with general register"
     ()
     ("b$bcond5 $Rd,$Rs,$rel12")
     (+ OP1_0 OP2_D Rs Rd bcond5 rel12)
     (sequence ()
	       (set-psw-cmp Rd (index-of Rd) Rd Rs)
	       (cbranch bcond5 rel12))
     ()
)

; 4 bytes
(dni bccgrimm8
     "Conditional branch comparing general register with 8-bit immediate"
     ()
     ("b$bcond5 $Rm,#$imm8,$rel12")
     (+ OP1_2 OP2M_0 Rm imm8 bcond5 rel12)
     (sequence ()
	       (set-psw-cmp Rm (index-of Rm) Rm imm8)
	       (cbranch bcond5 rel12))
     ()
)

; 4 bytes
(dni bccimm16
     "Conditional branch comparing general register with 16-bit immediate"
     ()
     ("b$bcond2 Rx,#$imm16,${rel8-4}")
     (+ OP1_C bcond2 rel8-4 imm16)
     (sequence ()
	       (set-psw-cmp (reg HI h-gr Rpsw) Rpsw (reg HI h-gr Rpsw) imm16)
	       (cbranch bcond2 rel8-4))
     ()
)

(dni bngrimm4
     "Test bit in general register by immediate and branch if 0"
     ()
     ("bn $Rd,#$imm4,$rel12")
     (+ OP1_0 OP2_4 imm4 Rd OP5_0 rel12)
     (sequence ()
	       (set Rpsw (index-of Rd))
	       (if (eq (and Rd (sll 1 imm4)) 0)
		   (set pc rel12)))
     ()
)

(dni bngrgr
     "Test bit in general register by general register and branch if 0"
     ()
     ("bn $Rd,$Rs,$rel12")
     (+ OP1_0 OP2_6 Rs Rd OP5_0 rel12)
     (sequence ()
	       (set Rpsw (index-of Rd))
	       (if (eq (and Rd (sll 1 Rs)) 0)
		   (set pc rel12)))
     ()
)

(dni bnlmemimm
     "Test bit in memory by immediate and branch if 0"
     ()
     ("bn $lmem8,#$imm3b,$rel12")
     (+ OP1_7 OP2_C lmem8 OP5A_0 imm3b rel12)
     (if (eq (and (mem QI lmem8) (sll 1 imm3b)) 0)
	 (set pc rel12))
     ()
)

(dni bnhmemimm
     "Test bit in memory by immediate and branch if 0"
     ()
     ("bn $hmem8,#$imm3b,$rel12")
     (+ OP1_7 OP2_E hmem8 OP5A_0 imm3b rel12)
     (if (eq (and (mem QI hmem8) (sll 1 imm3b)) 0)
	 (set pc rel12))
     ()
)

(dni bpgrimm4
     "Test bit in general register by immediate and branch if 1"
     ()
     ("bp $Rd,#$imm4,$rel12")
     (+ OP1_0 OP2_5 imm4 Rd OP5_0 rel12)
     (sequence ()
	       (set Rpsw (index-of Rd))
	       (if (ne (and Rd (sll 1 imm4)) 0)
		   (set pc rel12)))
     ()
)

(dni bpgrgr
     "Test bit in general register by general register and branch if 1"
     ()
     ("bp $Rd,$Rs,$rel12")
     (+ OP1_0 OP2_7 Rs Rd OP5_0 rel12)
     (sequence ()
	       (set Rpsw (index-of Rd))
	       (if (ne (and Rd (sll 1 Rs)) 0)
		   (set pc rel12)))
     ()
)

(dni bplmemimm
     "Test bit in memory by immediate and branch if 1"
     ()
     ("bp $lmem8,#$imm3b,$rel12")
     (+ OP1_7 OP2_D lmem8 OP5A_0 imm3b rel12)
     (if (ne (and (mem QI lmem8) (sll 1 imm3b)) 0)
	 (set pc rel12))
     ()
)

(dni bphmemimm
     "Test bit in memory by immediate and branch if 1"
     ()
     ("bp $hmem8,#$imm3b,$rel12")
     (+ OP1_7 OP2_F hmem8 OP5A_0 imm3b rel12)
     (if (ne (and (mem QI hmem8) (sll 1 imm3b)) 0)
	 (set pc rel12))
     ()
)

(dni bcc
     "Conditional branch on flag registers"
     ()
     ("b$bcond2 ${rel8-2}")
     (+ OP1_D bcond2 rel8-2)
     (cbranch bcond2 rel8-2)
     ()
)

; Unconditional Branching

(dni bgr
     "Branch to register"
     ()
     ("br $Rd")
     (+ OP1_0 OP2_0 OP3_2 Rd)
     (set pc (add (add pc 2) Rd))
     ()
)

(dni br
     "Branch"
     ()
     ("br $rel12a")
     (+ OP1_1 rel12a OP4B_0)
     (set pc rel12a)
     ()
)

(dni jmp
     "Jump"
     ()
     ("jmp $Rbj,$Rd")
     (+ OP1_0 OP2_0 OP3B_4 Rbj Rd)
     (set pc (join SI HI Rbj Rd))
     ()
)

(dni jmpf
     "Jump far"
     ()
     ("jmpf $abs24")
     (+ OP1_0 OP2_2 abs24)
     (set pc abs24)
     ()
)

; Call instructions
(define-pmacro (do-call dest ilen)
  (sequence ()
	    (set (mem SI sp) (add pc ilen))
	    (set sp (add sp 4))
	    (set pc dest)))

(dni callrgr
     "Call relative to general register"
     ()
     ("callr $Rd")
     (+ OP1_0 OP2_0 OP3_1 Rd)
     (do-call (add Rd (add pc 2)) 2)
     ()
)

(dni callrimm
     "Call relative to immediate address"
     ()
     ("callr $rel12a")
     (+ OP1_1 rel12a OP4B_1)
     (do-call rel12a 2)
     ()
)

(dni callgr
     "Call to general registers"
     ()
     ("call $Rbj,$Rd")
     (+ OP1_0 OP2_0 OP3B_A Rbj Rd)
     (do-call (join SI HI Rbj Rd) 2)
     ()
)

(dni callfimm
     "Call far to absolute address"
     ()
     ("callf $abs24")
     (+ OP1_0 OP2_1 abs24)
     (do-call abs24 4)
     ()
)

(define-pmacro (do-calli dest ilen)
  (sequence ()
	    (set (mem SI sp) (add pc ilen))
	    (set (mem HI (add sp 4)) psw)
	    (set sp (add sp 6))
	    (set pc dest)))

(dni icallrgr
     "Call interrupt to general registers pc-relative"
     ()
     ("icallr $Rd")
     (+ OP1_0 OP2_0 OP3_3 Rd)
     (do-calli (add Rd (add pc 2)) 2)
     ()
)

(dni icallgr
     "Call interrupt to general registers"
     ()
     ("icall $Rbj,$Rd")
     (+ OP1_0 OP2_0 OP3B_6 Rbj Rd)
     (do-calli (join SI HI Rbj Rd) 2)
     ()
)

(dni icallfimm
     "Call interrupt far to absolute address"
     ()
     ("icallf $abs24")
     (+ OP1_0 OP2_3 abs24)
     (do-calli abs24 4)
     ()
)

; Return instructions
(dni iret
     "Return from interrupt"
     ()
     ("iret")
     (+ (f-op #x0002))
     (sequence ()
	       (set sp (sub sp 6))
	       (set pc (mem SI sp))
	       (set psw (mem HI (add sp 4))))
     ()
)

(dni ret
     "Return"
     ()
     ("ret")
     (+ (f-op #x0003))
     (sequence ()
	       (set sp (sub sp 4))
	       (set pc (mem SI sp)))
     ()
)

; Multiply and Divide instructions

(dni mul
     "Multiply"
     ()
     ("mul")
     (+ (f-op #x00D0))
     (sequence ((SI value))
	       (set value (mul SI (and SI R0 #xFFFF) (and SI R2 #xFFFF)))
	       (set psw (or (and psw #xFF9C)
			    (basic-psw (trunc HI value) 1)))
	       (set R0 (trunc HI value))
	       (set R1 (trunc HI (srl value 16))))
     ()
)
(dni div
     "Divide"
     ()
     ("div")
     (+ (f-op #x00C0))
     (sequence ()
	       (set R1 (umod R0 R2))
	       (set-mem-psw R0 (udiv R0 R2) 1))
     ()
)
(dni sdiv
     "Signed Divide"
     ()
     ("sdiv")
     (+ (f-op #x00C8))
     (sequence ()
	       (set R1 (mod HI R0 R2))
	       (set-mem-psw R0 (div HI R0 R2) 1))
     ()
)
(dni sdivlh
     "Divide 32/16"
     ()
     ("sdivlh")
     (+ (f-op #x00E8))
     (sequence ((SI value))
	       (set value (add SI (sll SI (and SI R1 #xffff) #x10) (and SI R0 #xffff)))
	       (set R1 (mod SI value (ext SI (trunc HI R2))))
	       (set-mem-psw R0 (div SI value (ext SI (trunc HI R2))) 1))
     ()
)
(dni divlh
     "Divide 32/16"
     ()
     ("divlh")
     (+ (f-op #x00E0))
     (sequence ((SI value))
	       (set value (add SI (sll SI (and SI R1 #xffff) #x10) (and SI R0 #xffff)))
	       (set R1 (umod SI value R2))
	       (set-mem-psw R0 (udiv SI value R2) 1))
     ()
)

; System Control

; added per sanyo's req -- eq to nop for the moment, but can 
; add function later
(dni reset "reset" () ("reset") (+ (f-op #x000f)) (nop) ())

(dni nop "nop" () ("nop") (+ (f-op #x0000)) (nop) ())

(dni halt "halt" () ("halt") (+ (f-op #x0008)) (c-call VOID "do_halt") ())

(dni hold "hold" () ("hold") (+ (f-op #x000A)) (c-call VOID "do_hold") ())

(dni holdx "holdx" () ("holdx") (+ (f-op #x000B)) (c-call VOID "do_holdx") ())

(dni brk "brk" () ("brk") (+ (f-op #x0005)) (c-call VOID "do_brk") ())

; An instruction for test instrumentation.
; Using a reserved opcode.
(dni syscall
  "simulator system call"
  ()
  ("--unused--")
  (+ (f-op #x0001))
  (c-call VOID "syscall")
  ()
)
@


1.16
log
@    * cpu/xstormy16.cpu (alignfix-mem-far): New macro.  Like
    alignfix-mem, but works with 32-bit addresses.
    (set-alignfix-mem-far): New macro.  Like set-alignfix-mem but
    works with 32-bit addresses.
    (movfgrgri, movfgrgripostinc, movfgrgripredec, movfgrgrii,
    movfgrgriipostinc, movfgrgriipredec): Use alignfix-mem-far.
    (movfgrigr, movfgripostincgr, movfgripredecgr): Use
    set-alignfix-mem-far.
    (movfgrgriipostinc, movfgriipostincgr): Propagate addition to
    source register into base register.
    (movfgrgriipredec, movfgriipredecgr): Propagate subtraction from
    source register into base register.

    * xstormy16-sem.cxx: Regenerate.

        * testutils.inc (pass): Update parameter layout for write syscall.
        (fail): Likewise.
        * movgrgrii.cgs: Fix endianness typo in assertion.
        * movgrgriipostinc.cgs: Likewise.
        * movgrgriipredec.cgs: Likewise.
        * movgrgripostinc.cgs: Likewise.
        * movgrgripredec.cgs: Likewise.
        * movgrigr.cgs: Likewise.
        * movgriipostincgr.cgs: Likewise.
        * movgripostincgr.cgs: Likewise.
        * movgripredecgr.cgs: Likewise.
        * rrcgrgr.cgs: Rotate only inserts carry flag once.
        * rrcgrimm4.cgs: Likewise.
        * movfgrgriipostinc.cgs: New test.  Checks MOVF load with post increment.
        * movfgrgriipredec.cgs: New test.  Checks MOVF load with pre decrement.
        * movfgriipostincgr.cgs: New test.  Checks MOVF store with post increment.
        * movfgriipostincgr.cgs: New test.  Checks MOVF store with pre decrement.
@
text
@@


1.15
log
@[cgen]
* cpu/xstormy16.cpu (movgriipostincgr, movgriipredecgr,
movfgriipredecgr): Fix increment/decrement amount.
[sid]
* xstormy16-sem.cxx: Regenerate.
@
text
@d527 6
d833 1
a833 1
	 (set-psw Rdm (index-of Rdm) (alignfix-mem (or (sll SI R8 16) Rs)) ws2)
d845 1
a845 1
		   (set-psw Rdm (index-of Rdm) (alignfix-mem (join SI HI R8 Rs)) ws2)
d859 1
a859 1
		   (set-psw Rdm (index-of Rdm) (alignfix-mem (join SI HI R8 Rs)) ws2)
d871 1
a871 1
		   (set-alignfix-mem (join SI HI R8 Rs) Rdm)
d884 1
a884 1
		   (set-alignfix-mem (join SI HI R8 Rs) Rdm)
d900 1
a900 1
		   (set-alignfix-mem (join SI HI R8 Rs) Rdm)
d911 1
a911 1
	 (set-psw Rdm (index-of Rdm) (alignfix-mem (add (join SI HI Rb Rs) imm12)) ws2)
d923 1
a923 1
		   (set-psw Rdm (index-of Rdm) (alignfix-mem (add (join SI HI Rb Rs) imm12)) ws2)
d925 5
a929 1
	       (set Rs (add Rs (add ws2 1))))
d939 3
d944 1
a944 1
		   (set-psw Rdm (index-of Rdm) (alignfix-mem (add (join SI HI Rb Rs) imm12)) ws2)
d974 5
a978 1
	       (set Rs (add Rs (add ws2 1))))
d988 3
@


1.14
log
@	* hardware.scm (<keyword>): Rename member print-name -> enum-prefix.
	Rename member prefix -> name-prefix.
	(<keyword> getters): Update.
	(-keyword-parse): Update.  Default enum-prefix to NAME-.
	(-keyword-read): Update.  Don't compute default value for
	enum-prefix here.
	(define-keyword): Update.
	(-hw-parse-keyword): Pass "UNUSED" for enum-prefix to -keyword-parse.
	* read.scm (cgen-rtl-version): New function.
	(-supported-rtl-versions): Add (0 8).
	* desc-cpu.scm (-gen-hw-decl): Remove cruft.
	* desc.scm (<keyword> gen-defn): prefix -> name-prefix.
	* gas-test.scm (<keyword> test-data): prefix -> name-prefix.
	* cpu/arm.cpu (gr-names, shift-type): Call define-rtl-version.
	Update, print-name -> enum-prefix, make uppercase.
	Remove unnecessary name-prefix spec.
	* cpu/fr30.cpu (gr-names, cr-names, dr-names): Ditto.
	* cpu/ip2k.cpu (register-names): Ditto.
	* cpu/m68k.cpu (dr-names, ar-names): Ditto.
	* cpu/sparc.cpu (gr-names): Ditto.
	* cpu/xc16x.cpu (gr-names, ext-names,psw-names): Ditto.
	(grb-names, conditioncode-names, extconditioncode-names): Ditto.
	(grb8-names, r8-names, regmem8-names, regdiv8-names): Ditto.
	(reg0-name, reg0-name1, regbmem8-names, memgr8-names): Ditto.
	* cpu/ia32.cpu (gr8-names, gr16-names, gr-names): Call
	define-rtl-version.  Update, print-name -> enum-prefix, make uppercase,
	prefix -> name-prefix.
	* cpu/sh64-compact.cpu (frc-names): Call define-rtl-version.
	Update, print-name -> enum-prefix, make uppercase.
	(drc-names, xf-names): Ditto.
	* cpu/xstormy16.cpu (gr-names, gr-Rb-names): Ditto.
	* doc/rtl.texi (Keywords): New section.
	(hardware indices): Update text.
	(rtl versions): Add 0.8.
@
text
@d728 1
a728 1
	       (set Rs (add Rs 1)))
d738 1
a738 1
	       (set Rs (sub Rs 1))
d971 1
a971 1
	       (set Rs (sub Rs 1))
@


1.13
log
@2008-06-17  Dave Brolley  <brolley@@redhat.com>

        * cpu/xstormy16.cpu (h-pc): Add a set handler.
        (h-gr): Likewise.
@
text
@d2 1
a2 1
; Copyright (C) 2001, 2002, 2003, 2006 Red Hat, Inc.
d6 2
d83 1
a83 1
  (print-name h-gr)
d92 1
a92 1
  (print-name h-Rbj)
@


1.12
log
@* cpu/xstormy16.cpu (movhmemgr): Use hmem8, not lmem8.
@
text
@d2 1
a2 1
; Copyright (C) 2001, 2002, 2003 Red Hat, Inc.
d71 7
a77 1
(dsh h-pc "program counter" (PC) (pc))
d101 1
a101 1
  (set (index newval) (set (raw-reg h-gr index) (and #xFFFF newval)))
@


1.11
log
@	* mach.scm (current-*-add!): Disallow redefinition.  Make result
	"unspecified".
	* insn.scm (insn-builtin!): Don't define relaxable here, now defined in
	operand.scm.
	* operand.scm (operand-builtin!): Define RELAXABLE for insns too.
	* cpu/m32r.cpu (disp8,disp24): RELAX renamed to RELAXABLE.

	* gen-all-doc: Split arm and frv docs up a bit.

	* cpu/arm.cpu: Add IDOC attribute.
	* cpu/frv.cpu: Ditto.
	* cpu/i960.cpu: Ditto.
	* cpu/openrisc.cpu: Ditto.
	* cpu/xstormy16.cpu: Ditto.
	* cpu/m32r.cpu: Ditto.
	(all insns): Explicitly specify IDOC attribute.

	* Makefile.am (MACH,ISAS,INSN_FILE_NAME): New vars.
	(desc,opcodes,sim-arch,sim-cpu,gas-test,sim-test): Use MACH,ISAS.
	(html): Use MACH,ISAS,INSN_FILE_NAME.  Generate insn.html separately.
	* Makefile.in: Regenerate.
	* attr.scm (<integer-attribute>:parse-value-def): Implement.
	(-attr-read): Defer computing default value until we know the type.
	(attr-has-attr?): Delete, move contents to <attr-list>:has-attr?.
	(<attr-list>:attr-present?): New method.
	(atlist-attr-present?,obj-attr-present?): New fns.
	(obj-has-attr-value?,obj-has-attr-value-no-default?): New fns.
	(attr-builtin!): New insn attr IDOC.
	* cgen-doc.scm (doc-arguments): New args -I,-N.
	* enum.scm (parse-enum-vals): New arg errtxt, all callers updated.
	Support comment as fourth element of enum value.
	(enum-val-name,enum-val-value,enum-val-attrs,enum-val-comment): New fns.
	* html.scm (gen-html-header): New arg kind, all callers updated.
	(gen-table-of-contents): New arg insn-file, all callers updated.
	(gen-list-entry,gen-doc-header): New fn.
	(get-operands): Delete.
	(gen-iformat-table): Rewrite.
	(gen-insn-doc-1): Print constant-folded and trimmed semantics.
	(gen-insn-doc-list): New args name, comment, insns.  All callers updated.
	(get-insn-properties,guess-insn-idoc-attr!): New fn.
	(insn-sets-pc?,insn-refs-mem?,insn-uses-fpu?): New fns.
	(get-insns-for-category,gen-categories-insn-lists): New fns.
	(gen-insn-docs): Simplify each insn's semantics first.
	Print insn tables sorted by IDOC categories.
	(*insn-html-file-name*): New global.
	(cgen-insn.html): New fn.
	(cgen-all): Update.
	* insn.scm (<insn>): Create a setter for the `tmp' member.
	* semantics.scm (insn-build-known-values): Renamed from
	-build-known-values.  All callers updated.

	* rtl.scm: Move traveral/evaluation support to ...
	* rtl-traverse.scm: New file.
	* read.scm: Maybe-load rtl-traverse.scm.

	* rtl.scm (-rtx-valid-types): Add SETRTX.

	* rtx-funcs.scm (nop,parallel): Fix mode.

	* utils.scm (eqv-lookup-index): New fn.
	(assq-lookup-index): Renamed from lookup-index.  All callers updated.

	* dev.scm (load-doc): Set APPLICATION.
@
text
@d577 2
a578 2
	 (set-mem-psw (mem HI (and lmem8 #xFFFE)) Rm ws2)
	 (set-mem-psw (mem QI lmem8) Rm ws2))
@


1.11.16.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d577 2
a578 2
	 (set-mem-psw (mem HI (and hmem8 #xFFFE)) Rm ws2)
	 (set-mem-psw (mem QI hmem8) Rm ws2))
@


1.10
log
@	Better handling of 64 bit and mixed 32/64 bit architectures.
	* hardware.scm (hw-update-word-modes!): New fn.
	* mach.scm (define-cpu)): Call mode-set-word-modes!,
	hw-update-word-modes!.
	(state-word-bitsize): Replace FIXME with requested check.
	(arch-analyze-insns!): Call mode-ensure-word-sizes-defined.
	* mode.scm (mode-find): Ignore INT,UINT.
	(-mode-word-sizes-kind): New global.
	(mode-set-word-modes!,mode-set-identical-word-bitsizes!,
	mode-set-biggest-word-bitsizes!,mode-ensure-word-sizes-defined): New fns.
	(mode-init!): Initialize -mode-word-sizes-kind.  Move initialization
	of mode-list to ...
	(mode-builtin!): ... here.  Initialize WI/UWI/AI/IAI to something
	unusable, correct values set later.
	(mode-finish!): Remove cruft.
	* html.scm (doc-init!): Call mode-set-biggest-word-bitsizes!.
	* opcodes.scm (opcodes-init!): Ditto.
	* rtx-funcs.scm (annul): Fix mode of pc.
	* cpu/ia64.cpu: Remove cruft that sets word modes.
	* cpu/xstormy16.cpu (define-cpu): Set word-bitsize.
@
text
@d51 18
@


1.9
log
@* cpu/xstormy16.cpu (alignfix-mem): Correct logic for unaligned
word accesses.
(set-alignfix-mem): Likewise.
@
text
@d33 1
@


1.8
log
@* cpu/xstormy16.cpu (basic-psw): New argument ws (wordsize),
which indicates if the sign flag is set from bit 15 or 7.
Adjust all callers.
(set-psw): New argument ws, propogate it.
(set-psw-nowrite): Likewise.
(set-mem-psw): Likewise.
(set-psw-carry): Likewise.  Use temporaries to prevent
prematurely overwriting needed inputs.
(set-psw-rrotate17): Fix logic.
(shrgrgr): Preserve carry for zero-bit shifts.
(shrgrimm): Likewise.
(shlgrgr): Likewise.
(shlgrimm): Likewise.
(asrgrgr): Likewise.
(asrgrimm): Likewise.
(reset): New.
@
text
@d495 1
a495 5
  (if HI (and where 1)
    (or HI
      (and (sll (mem QI (sub where 1)) 8) #xFF00)
      (and (mem QI where) #xFF))
    (mem HI where)))
d498 1
a498 10
  (sequence ((SI nwhere) (HI nwhat))
    (set nwhere where)
    (if (and nwhere 1)
      (sequence ()
	(set nwhat (or HI
		    (and (sll what 8) #xFF00)
		    (and (srl what 8) #xFF)))
        (set nwhere (sub nwhere 1)))
      (set nwhat what))
    (set (mem HI nwhere) what)))
@


1.8.8.1
log
@Merge from mainline.
@
text
@d495 5
a499 1
  (mem HI (and where #xFFFE)))
d502 10
a511 1
  (set (mem HI (and where #xFFFE)) what))
@


1.7
log
@* cpu/xstormy16.cpu (set-psw-add): Use temporaries to prevent
prematurely overwriting needed inputs.
(set-psw-sub): Likewise.
@
text
@d276 1
a276 1
  (index f-imm16) 
d383 1
a383 1
(define-pmacro (basic-psw value)
d387 1
a387 1
	  (sll HI (nflag HI value) 6))))
d391 1
a391 1
(define-pmacro (set-psw Rd index value)
d397 1
a397 1
		     (basic-psw nvalue))))))
d400 1
a400 1
(define-pmacro (set-psw-nowrite index value)
d405 1
a405 1
		     (basic-psw nvalue))))))
d408 1
a408 1
(define-pmacro (set-mem-psw dest value)
d412 1
a412 1
		 (basic-psw nvalue)))
d416 2
a417 2
(define-pmacro (set-psw-carry Rd index value carry)
  (sequence ((HI nvalue))
d419 4
d424 2
a425 4
    (set psw (or (or (and psw #x0F98)
		     (sll carry 2))
		 (or (sll index 12)
		     (basic-psw nvalue))))))
d432 1
a432 1
			(basic-psw value))
d448 1
a448 1
		     (basic-psw value))
d462 1
a462 1
		     (basic-psw value))
d480 1
a480 1
    (set-psw-carry (reg HI h-gr index) index (trunc HI tmpfoo) (and (srl tmpfoo 16) 1))))
d482 1
a482 1
; We have to be careful to get the right group of 16 shifts from the above.
d484 6
a489 2
  (set-psw-rotate17 Rd index src c (sub 47 (mod (add (and rot #xf) 15) 17)))
  )
d519 2
a520 2
	 (set-mem-psw (mem HI (and lmem8 #xFFFE)) imm16)
	 (set-mem-psw (mem QI lmem8) (and imm16 #xFF)))
d529 2
a530 2
	 (set-mem-psw (mem HI (and hmem8 #xFFFE)) imm16)
	 (set-mem-psw (mem QI hmem8) (and imm16 #xFF)))
d540 2
a541 2
	 (set-psw Rm (index-of Rm) (alignfix-mem lmem8))
	 (set-psw Rm (index-of Rm) (mem QI lmem8)))
d550 2
a551 2
	 (set-psw Rm (index-of Rm) (alignfix-mem hmem8))
	 (set-psw Rm (index-of Rm) (mem QI hmem8)))
d561 2
a562 2
	 (set-mem-psw (mem HI (and lmem8 #xFFFE)) Rm)
	 (set-mem-psw (mem QI lmem8) Rm))
d571 2
a572 2
	 (set-mem-psw (mem HI (and lmem8 #xFFFE)) Rm)
	 (set-mem-psw (mem QI lmem8) Rm))
d582 2
a583 2
	 (set-psw Rdm (index-of Rdm) (alignfix-mem Rs))
	 (set-psw Rdm (index-of Rdm) (and #xFF (mem QI Rs))))
d594 2
a595 2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem Rs))
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI Rs))))
d608 2
a609 2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem Rs))
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI Rs)))))
d622 1
a622 1
	       (set-psw-nowrite (index-of Rdm) Rdm))
d635 1
a635 1
	       (set-psw-nowrite (index-of Rdm) Rdm)
d647 1
a647 1
	       (set-psw-nowrite (index-of Rdm) Rdm)
d660 2
a661 2
	 (set-psw Rdm (index-of Rdm) (alignfix-mem (add Rs imm12)))
	 (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add Rs imm12)))))
d672 2
a673 2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem (add Rs imm12)))
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add Rs imm12)))))
d686 2
a687 2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem (add Rs imm12)))
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add Rs imm12))))))
d700 1
a700 1
	       (set-psw-nowrite (index-of Rdm) Rdm))
d713 1
a713 1
	       (set-psw-nowrite (index-of Rdm) Rdm)
d725 1
a725 1
	       (set-psw-nowrite (index-of Rdm) Rdm)
d737 1
a737 1
     (set-psw Rd (index-of Rd) Rs)
d753 1
a753 1
     (set-psw (reg HI h-gr Rpsw) Rpsw imm8)
d769 1
a769 1
     (set-psw Rm (index-of Rm) imm8small)
d785 1
a785 1
     (set-psw Rd (index-of Rd) imm16)
d794 1
a794 1
     (set-psw Rd (index-of Rd) (or (and Rd #xFF00) (and (reg HI h-gr Rpsw) #xFF)))
d803 1
a803 1
     (set-psw Rd (index-of Rd) (or (and Rd #x00FF) (and (reg HI h-gr Rpsw) #xFF00)))
d813 2
a814 2
	 (set-psw Rdm (index-of Rdm) (alignfix-mem (or (sll SI R8 16) Rs)))
	 (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (or (sll SI R8 16) Rs)))))
d825 2
a826 2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem (join SI HI R8 Rs)))
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (join SI HI R8 Rs)))))
d839 2
a840 2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem (join SI HI R8 Rs)))
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (join SI HI R8 Rs))))))
d853 1
a853 1
	       (set-psw-nowrite (index-of Rdm) Rdm))
d866 1
a866 1
	       (set-psw-nowrite (index-of Rdm) Rdm)
d877 1
a877 1
	       (set-psw-nowrite (index-of Rdm) Rdm)
d891 2
a892 2
	 (set-psw Rdm (index-of Rdm) (alignfix-mem (add (join SI HI Rb Rs) imm12)))
	 (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add (join SI HI Rb Rs) imm12)))))
d903 2
a904 2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem (add (join SI HI Rb Rs) imm12)))
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add (join SI HI Rb Rs) imm12)))))
d917 2
a918 2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem (add (join SI HI Rb Rs) imm12)))
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add (join SI HI Rb Rs) imm12))))))
d932 1
a932 1
	       (set-psw-nowrite (index-of Rdm) Rdm))
d946 1
a946 1
	       (set-psw-nowrite (index-of Rdm) Rdm)
d958 1
a958 1
	       (set-psw-nowrite (index-of Rdm) Rdm)
d970 1
a970 1
     (set-psw Rd (index-of Rd) (or HI (and HI Rd (inv HI Rs)) (and (reg HI h-gr Rpsw) Rs)))
d979 1
a979 1
     (set-psw Rd (index-of Rd) (or (and Rd (inv imm16)) (and (reg HI h-gr Rpsw) imm16)))
d1014 1
a1014 1
		     (and Rd #xFF00)))
d1023 1
a1023 1
     (set-psw Rd (index-of Rd) (or (sll Rd 8) (srl Rd 8)))
d1035 1
a1035 1
	       (set-psw Rd (index-of Rd) foo))
d1045 1
a1045 1
     (set-psw Rd (index-of Rd) (and Rd Rs))
d1054 1
a1054 1
     (set-psw (reg HI h-gr Rpsw) Rpsw (and (reg HI h-gr Rpsw) imm8))
d1063 1
a1063 1
     (set-psw Rd (index-of Rd) (and Rd imm16))
d1072 1
a1072 1
     (set-psw Rd (index-of Rd) (or Rd Rs))
d1081 1
a1081 1
     (set-psw (reg HI h-gr Rpsw) Rpsw (or (reg HI h-gr Rpsw) imm8))
d1090 1
a1090 1
     (set-psw Rd (index-of Rd) (or Rd imm16))
d1099 1
a1099 1
     (set-psw Rd (index-of Rd) (xor Rd Rs))
d1108 1
a1108 1
     (set-psw (reg HI h-gr Rpsw) Rpsw (xor (reg HI h-gr Rpsw) imm8))
d1117 1
a1117 1
     (set-psw Rd (index-of Rd) (xor Rd imm16))
d1126 1
a1126 1
     (set-psw Rd (index-of Rd) (inv Rd))
d1287 1
a1287 1
     (set-psw Rd (index-of Rd) (add Rd (add imm2 1)))
d1303 1
a1303 1
     (set-psw Rd (index-of Rd) (sub Rd (add imm2 1)))
d1352 1
a1352 1
			     Rd
d1354 1
a1354 1
			 1))
d1366 1
a1366 1
			     Rd
d1368 1
a1368 1
			 1))
d1380 1
a1380 1
			     Rd
d1382 1
a1382 1
			 15))
d1394 1
a1394 1
			     Rd
d1396 1
a1396 1
			 15))
d1408 1
a1408 1
			     Rd
d1410 1
a1410 1
			 1))
d1422 1
a1422 1
			     Rd
d1424 1
a1424 1
			 1))
d1434 1
a1434 1
     (set-psw Rd (index-of Rd) (or Rd (sll 1 imm4)))
d1443 1
a1443 1
     (set-psw Rd (index-of Rd) (or Rd (sll 1 (and Rs #xF))))
d1452 1
a1452 1
     (set-mem-psw (mem QI lmem8) (or (mem QI lmem8) (sll 1 imm3)))
d1460 1
a1460 1
     (set-mem-psw (mem QI hmem8) (or (mem QI hmem8) (sll 1 imm3)))
d1469 1
a1469 1
     (set-psw Rd (index-of Rd) (and Rd (inv (sll 1 imm4))))
d1478 1
a1478 1
     (set-psw Rd (index-of Rd) (and Rd (inv (sll 1 (and Rs #xF)))))
d1487 1
a1487 1
     (set-mem-psw (mem QI lmem8) (and (mem QI lmem8) (inv (sll 1 imm3))))
d1495 1
a1495 1
     (set-mem-psw (mem QI hmem8) (and (mem QI hmem8) (inv (sll 1 imm3))))
d1506 1
a1506 1
     (set-psw Rd (index-of Rd) (ext HI (trunc QI Rd)))
d1532 1
a1532 1
     )
d1841 1
a1841 1
			    (basic-psw (trunc HI value))))
d1853 1
a1853 1
	       (set-mem-psw R0 (udiv R0 R2)))
d1863 1
a1863 1
	       (set-mem-psw R0 (div HI R0 R2)))
d1874 1
a1874 1
	       (set-mem-psw R0 (div SI value (ext SI (trunc HI R2)))))
d1885 1
a1885 1
	       (set-mem-psw R0 (udiv SI value R2)))
d1890 4
@


1.6
log
@* xstormy16.cpu (set-mem-alignfix-psw): Remove.
(movlmemimm): Just mask the address.
(movhmemimm): Likewise.
(movlmemgr): Likewise.
(movhmemgr): Likewise.
(set-psw): Always set the psw last.
(set-psw-carry): Likewise.
(set-psw-add): Likewise.
(set-psw-sub): Likewise.

* xstormy16.cpu (set-psw-rrotate17): New.  Choose the correct set
of 16 patterns from the set-psw-rotate17 function.
(movgrigr, movgripostincgr, movgripredecgr, movgriigr,
movgriipostincgr, movgriipredecgr): Set psw correctly.
(movfgrigr, movfgripostincgr, movfgripredecgr, movfgriigr,
movfgriipostincgr, movfgriipredecgr): Fix semantics.
(rrcgrgr, rrcgrimm4): Use new set-psw-rrotate17 function.
@
text
@d427 1
a427 1
  (sequence ((HI value))
d429 7
d437 2
a438 7
    (set psw (or (or (and psw #x0F80)
		     (basic-psw value))
		 (or (or (sll HI (add-oflag HI a b c) 4)
			 (sll HI (add-cflag HI a b c) 2))
		     (or (and (srl HI (addc HI (and a #xF) (and b #xF) c) 
				   1) #x8)
			 (sll index 12)))))))
d457 1
a457 1
  (sequence ((HI value))
d459 1
a459 2
    (set (reg HI h-gr index) value)
    (set psw (or (or (and psw #x0F80)
d465 4
a468 1
			 (sll index 12)))))))
@


1.5
log
@* cpu/xstormy16.cpu (imm16): Call handler immediate16.
* cpu/xstormy16.opc (parse_small_immediate): Return on '@@'.
(parse_immediate16): Handle immediate16 values, which now include
@@hi(label) and @@lo(label)
@
text
@d2 1
a2 1
; Copyright (C) 2001, 2002 Red Hat, Inc.
d394 1
d397 1
a397 2
		     (basic-psw nvalue))))
    (set (reg HI h-gr index) nvalue)))
a414 15
; Update the PSW for destination non-register dest, set dest to value,
; ensuring to write the correct (weird) alignment.
(define-pmacro (set-mem-alignfix-psw dest value)
  (sequence ((HI nvalue) (SI ndest))
    (set nvalue value)
    (set ndest dest)
    (set psw (or (and psw #xFF9C)
		 (basic-psw nvalue)))
    (if (and ndest 1)
      (sequence ()
	(set ndest (sub ndest 1))
	(set nvalue (or (and (sll nvalue 8) #xFF00)
			(and (srl nvalue 8) #xFF)))))
    (set dest nvalue)))

d419 1
d423 1
a423 2
		     (basic-psw nvalue))))
    (set (reg HI h-gr index) nvalue)))
d429 1
d436 1
a436 2
			 (sll index 12)))))
    (set (reg HI h-gr index) value)))
d457 1
d464 1
a464 2
			 (sll index 12)))))
    (set (reg HI h-gr index) value)))
d476 5
d509 1
a509 1
	 (set-mem-alignfix-psw (mem HI lmem8) imm16)
d519 1
a519 1
	 (set-mem-alignfix-psw (mem HI hmem8) imm16)
d551 1
a551 1
	 (set-mem-alignfix-psw (mem HI lmem8) Rm)
d561 1
a561 1
	 (set-mem-alignfix-psw (mem HI lmem8) Rm)
d612 1
a612 1
	       (set-psw-nowrite (index-of Rs) Rs))
d625 2
a626 1
	       (set-psw Rs (index-of Rs) (add Rs (add ws2 1))))
d636 2
a637 1
	       (set-psw Rs (index-of Rs) (sub Rs (add ws2 1)))
d690 1
a690 1
	       (set-psw Rs (index-of Rs) Rs))
d703 2
a704 1
	       (set-psw Rs (index-of Rs) (add Rs 1)))
d714 2
a715 1
	       (set-psw Rs (index-of Rs) (sub Rs 1))
d841 3
a843 3
		   (set-psw Rs (index-of Rs) (alignfix-mem (join SI HI R8 Rdm)))
		   (set-psw Rs (index-of Rs) (and #xFF (mem QI (join SI HI R8 Rdm)))))
	       (set-psw Rs (index-of Rs) Rs))
d854 4
a857 3
		   (set-psw Rs (index-of Rs) (alignfix-mem (join SI HI R8 Rdm)))
		   (set-psw Rs (index-of Rs) (and #xFF (mem QI (join SI HI R8 Rdm)))))
	       (set-psw Rs (index-of Rs) (add Rs (add ws2 1))))
d867 2
a868 1
	       (set-psw Rs (index-of Rs) (sub Rs (add ws2 1)))
d870 2
a871 2
		   (set-psw Rs (index-of Rs) (alignfix-mem (join SI HI R8 Rdm)))
		   (set-psw Rs (index-of Rs) (and #xFF (mem QI (join SI HI R8 Rdm))))))
d922 1
a922 1
	       (set-psw Rs (index-of Rs) Rs))
d936 2
a937 1
	       (set-psw Rs (index-of Rs) (add Rs (add ws2 1))))
d947 2
a948 1
	       (set-psw Rs (index-of Rs) (sub Rs 1))
d1303 1
a1303 1
     (set-psw-rotate17 Rd (index-of Rd) Rd psw-cy (neg (and Rs #xF)))
d1312 1
a1312 1
     (set-psw-rotate17 Rd (index-of Rd) Rd psw-cy (neg imm4))
@


1.4
log
@* xstormy16.cpu (sdiv, divlh, sdivlh): Fix sdivlh/divlh encodings.
@
text
@d271 8
a278 1
(dnop imm16 "16 bit immediate" () h-uint f-imm16)
@


1.3
log
@* cpu/xstormy16.cpu (sdiv, divlh, sdivlh): New.
@
text
@d1855 1
a1855 1
     (+ (f-op #x00E0))
d1866 1
a1866 1
     (+ (f-op #x00E8))
@


1.2
log
@[cgen/ChangeLog]
	* cpu/xstormy16.cpu (gr-Rbj-names): Rename this ...
	(gr-Rb-names): ... to this.
	(h-Rb): New hardware peice.
	(h-Rbj): Use gr-Rb-names.
	(Rb): Use h-Rb.

	(holdx): New instruction.

[opcodes/ChangeLog]
	* xstormy16-asm.c: Regenerate.
	* xstormy16-desc.c: Likewise.
	* xstormy16-desc.h: Likewise.
	* xstormy16-dis.c: Likewise.
	* xstormy16-opc.c: Likewise.
	* xstormy16-opc.h: Likewise.

[gas/testsuite/ChangeLog]
	* gas/xstormy16/allinsn.sh (movf, jmp, call, icall): Update.
	* gas/xstormy16/allinsn.d: Regenerate.
	* gas/xstormy16/allinsn.s: Regenerate.

[sid/component/cgen-cpu/xstormy16/ChangeLog]
	* xstormy16.cxx (do_holdx): Define.
	* xstormy16.h (do_holdx): Declare.
@
text
@d2 1
a2 1
; Copyright (C) 2001 Red Hat, Inc.
d1839 32
@


1.2.20.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
; Copyright (C) 2001, 2002, 2003 Red Hat, Inc.
a32 1
  (word-bitsize 32)
a49 18
; IDOC attribute for instruction documentation.

(define-attr
  (for insn)
  (type enum)
  (name IDOC)
  (comment "insn kind for documentation")
  (attrs META)
  (values
   (MEM - () "Memory")
   (ALU - () "ALU")
   (FPU - () "FPU")
   (BR - () "Branch")
   (PRIV - () "Priviledged")
   (MISC - () "Miscellaneous")
  )
)

d271 1
a271 8
(define-operand
  (name imm16)
  (comment "16 bit immediate")
  (attrs)
  (type h-uint)
  (index f-imm16)
  (handlers (parse "immediate16"))
)
d376 1
a376 1
(define-pmacro (basic-psw value ws)
d380 1
a380 1
	  (sll HI (nflag QI (srl value (mul ws 8))) 6))))
d384 1
a384 1
(define-pmacro (set-psw Rd index value ws)
a386 1
    (set (reg HI h-gr index) nvalue)
d389 2
a390 1
		     (basic-psw nvalue ws))))))
d393 1
a393 1
(define-pmacro (set-psw-nowrite index value ws)
d398 1
a398 1
		     (basic-psw nvalue ws))))))
d401 1
a401 1
(define-pmacro (set-mem-psw dest value ws)
d405 16
a420 1
		 (basic-psw nvalue ws)))
d424 2
a425 2
(define-pmacro (set-psw-carry Rd index value carry ws)
  (sequence ((HI nvalue) (HI newpsw))
d427 2
a428 2
    (set newpsw (or (or (and psw #x0F98)
		     (sll (and carry #x1) 2))
d430 2
a431 4
		     (basic-psw nvalue ws))))
    (set (reg HI h-gr index) nvalue)
    (set psw newpsw)
    ))
d435 1
a435 1
  (sequence ((HI value) (HI newpsw))
d437 8
a444 10
    (set newpsw (or (or (and psw #x0F80)
			(basic-psw value 1))
		    (or (or (sll HI (add-oflag HI a b c) 4)
			    (sll HI (add-cflag HI a b c) 2))
			(or (and (srl HI (addc HI (and a #xF) (and b #xF) c) 
				      1) #x8)
			    (sll index 12)))))
    (set (reg HI h-gr index) value)
    (set psw newpsw)
    ))
d452 1
a452 1
		     (basic-psw value 1))
d463 1
a463 1
  (sequence ((HI value) (HI newpsw))
d465 2
a466 2
    (set newpsw (or (or (and psw #x0F80)
		     (basic-psw value 1))
d472 1
a472 3
    (set (reg HI h-gr index) value)
    (set psw newpsw)
    ))
d482 1
a482 10
    (set-psw-carry (reg HI h-gr index) index (trunc HI tmpfoo) (and (srl tmpfoo 16) 1) 1)))

; A 17-bit rotate-right operation
(define-pmacro (set-psw-rrotate17 Rd index src c rot)
  (sequence ((SI tmpfoo))
    (set tmpfoo (or (or (and (sll SI src 17) #xFFFE0000) 
		     src)
		 (sll SI c 16)))
    (set tmpfoo (ror tmpfoo (and rot #x0F)))
    (set-psw-carry (reg HI h-gr index) index (trunc HI tmpfoo) (and (srl tmpfoo 16) 1) 1)))
d488 5
a492 1
  (mem HI (and where #xFFFE)))
d495 10
a504 1
  (set (mem HI (and where #xFFFE)) what))
d512 2
a513 2
	 (set-mem-psw (mem HI (and lmem8 #xFFFE)) imm16 ws2)
	 (set-mem-psw (mem QI lmem8) (and imm16 #xFF) ws2))
d522 2
a523 2
	 (set-mem-psw (mem HI (and hmem8 #xFFFE)) imm16 ws2)
	 (set-mem-psw (mem QI hmem8) (and imm16 #xFF) ws2))
d533 2
a534 2
	 (set-psw Rm (index-of Rm) (alignfix-mem lmem8) ws2)
	 (set-psw Rm (index-of Rm) (mem QI lmem8) ws2))
d543 2
a544 2
	 (set-psw Rm (index-of Rm) (alignfix-mem hmem8) ws2)
	 (set-psw Rm (index-of Rm) (mem QI hmem8) ws2))
d554 2
a555 2
	 (set-mem-psw (mem HI (and lmem8 #xFFFE)) Rm ws2)
	 (set-mem-psw (mem QI lmem8) Rm ws2))
d564 2
a565 2
	 (set-mem-psw (mem HI (and lmem8 #xFFFE)) Rm ws2)
	 (set-mem-psw (mem QI lmem8) Rm ws2))
d575 2
a576 2
	 (set-psw Rdm (index-of Rdm) (alignfix-mem Rs) ws2)
	 (set-psw Rdm (index-of Rdm) (and #xFF (mem QI Rs)) ws2))
d587 2
a588 2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem Rs) ws2)
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI Rs)) ws2))
d601 2
a602 2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem Rs) ws2)
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI Rs)) ws2)))
d615 1
a615 1
	       (set-psw-nowrite (index-of Rdm) Rdm ws2))
d628 1
a628 2
	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
	       (set Rs (add Rs (add ws2 1))))
d638 1
a638 2
	       (set Rs (sub Rs (add ws2 1)))
	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
d651 2
a652 2
	 (set-psw Rdm (index-of Rdm) (alignfix-mem (add Rs imm12)) ws2)
	 (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add Rs imm12))) ws2))
d663 2
a664 2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem (add Rs imm12)) ws2)
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add Rs imm12))) ws2))
d677 2
a678 2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem (add Rs imm12)) ws2)
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add Rs imm12))) ws2)))
d691 1
a691 1
	       (set-psw-nowrite (index-of Rdm) Rdm ws2))
d704 1
a704 2
	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
	       (set Rs (add Rs 1)))
d714 1
a714 2
	       (set Rs (sub Rs 1))
	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
d726 1
a726 1
     (set-psw Rd (index-of Rd) Rs 1)
d742 1
a742 1
     (set-psw (reg HI h-gr Rpsw) Rpsw imm8 1)
d758 1
a758 1
     (set-psw Rm (index-of Rm) imm8small 1)
d774 1
a774 1
     (set-psw Rd (index-of Rd) imm16 1)
d783 1
a783 1
     (set-psw Rd (index-of Rd) (or (and Rd #xFF00) (and (reg HI h-gr Rpsw) #xFF)) 0)
d792 1
a792 1
     (set-psw Rd (index-of Rd) (or (and Rd #x00FF) (and (reg HI h-gr Rpsw) #xFF00)) 1)
d802 2
a803 2
	 (set-psw Rdm (index-of Rdm) (alignfix-mem (or (sll SI R8 16) Rs)) ws2)
	 (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (or (sll SI R8 16) Rs))) ws2))
d814 2
a815 2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem (join SI HI R8 Rs)) ws2)
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (join SI HI R8 Rs))) ws2))
d828 2
a829 2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem (join SI HI R8 Rs)) ws2)
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (join SI HI R8 Rs))) ws2)))
d840 3
a842 3
		   (set-alignfix-mem (join SI HI R8 Rs) Rdm)
		   (set (mem QI (join SI HI R8 Rs)) Rdm))
	       (set-psw-nowrite (index-of Rdm) Rdm ws2))
d853 3
a855 4
		   (set-alignfix-mem (join SI HI R8 Rs) Rdm)
		   (set (mem QI (join SI HI R8 Rs)) Rdm))
	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
	       (set Rs (add Rs (add ws2 1))))
d865 1
a865 2
	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
	       (set Rs (sub Rs (add ws2 1)))
d867 2
a868 2
		   (set-alignfix-mem (join SI HI R8 Rs) Rdm)
		   (set (mem QI (join SI HI R8 Rs)) Rdm)))
d878 2
a879 2
	 (set-psw Rdm (index-of Rdm) (alignfix-mem (add (join SI HI Rb Rs) imm12)) ws2)
	 (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add (join SI HI Rb Rs) imm12))) ws2))
d890 2
a891 2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem (add (join SI HI Rb Rs) imm12)) ws2)
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add (join SI HI Rb Rs) imm12))) ws2))
d904 2
a905 2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem (add (join SI HI Rb Rs) imm12)) ws2)
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add (join SI HI Rb Rs) imm12))) ws2)))
d919 1
a919 1
	       (set-psw-nowrite (index-of Rdm) Rdm ws2))
d933 1
a933 2
	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
	       (set Rs (add Rs (add ws2 1))))
d943 1
a943 2
	       (set Rs (sub Rs 1))
	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
d955 1
a955 1
     (set-psw Rd (index-of Rd) (or HI (and HI Rd (inv HI Rs)) (and (reg HI h-gr Rpsw) Rs)) 1)
d964 1
a964 1
     (set-psw Rd (index-of Rd) (or (and Rd (inv imm16)) (and (reg HI h-gr Rpsw) imm16)) 1)
d999 1
a999 1
		     (and Rd #xFF00)) 0)
d1008 1
a1008 1
     (set-psw Rd (index-of Rd) (or (sll Rd 8) (srl Rd 8)) 1)
d1020 1
a1020 1
	       (set-psw Rd (index-of Rd) foo 1))
d1030 1
a1030 1
     (set-psw Rd (index-of Rd) (and Rd Rs) 1)
d1039 1
a1039 1
     (set-psw (reg HI h-gr Rpsw) Rpsw (and (reg HI h-gr Rpsw) imm8) 1)
d1048 1
a1048 1
     (set-psw Rd (index-of Rd) (and Rd imm16) 1)
d1057 1
a1057 1
     (set-psw Rd (index-of Rd) (or Rd Rs) 1)
d1066 1
a1066 1
     (set-psw (reg HI h-gr Rpsw) Rpsw (or (reg HI h-gr Rpsw) imm8) 1)
d1075 1
a1075 1
     (set-psw Rd (index-of Rd) (or Rd imm16) 1)
d1084 1
a1084 1
     (set-psw Rd (index-of Rd) (xor Rd Rs) 1)
d1093 1
a1093 1
     (set-psw (reg HI h-gr Rpsw) Rpsw (xor (reg HI h-gr Rpsw) imm8) 1)
d1102 1
a1102 1
     (set-psw Rd (index-of Rd) (xor Rd imm16) 1)
d1111 1
a1111 1
     (set-psw Rd (index-of Rd) (inv Rd) 1)
d1272 1
a1272 1
     (set-psw Rd (index-of Rd) (add Rd (add imm2 1)) 1)
d1288 1
a1288 1
     (set-psw Rd (index-of Rd) (sub Rd (add imm2 1)) 1)
d1298 1
a1298 1
     (set-psw-rrotate17 Rd (index-of Rd) Rd psw-cy Rs)
d1307 1
a1307 1
     (set-psw-rrotate17 Rd (index-of Rd) Rd psw-cy imm4)
d1337 1
a1337 1
			     psw-cy
d1339 1
a1339 1
			 1) 1)
d1351 1
a1351 1
			     psw-cy
d1353 1
a1353 1
			 1) 1)
d1365 1
a1365 1
			     (sll psw-cy 15)
d1367 1
a1367 1
			 15) 1)
d1379 1
a1379 1
			     (sll psw-cy 15)
d1381 1
a1381 1
			 15) 1)
d1393 1
a1393 1
			     psw-cy
d1395 1
a1395 1
			 1) 1)
d1407 1
a1407 1
			     psw-cy
d1409 1
a1409 1
			 1) 1)
d1419 1
a1419 1
     (set-psw Rd (index-of Rd) (or Rd (sll 1 imm4)) 1)
d1428 1
a1428 1
     (set-psw Rd (index-of Rd) (or Rd (sll 1 (and Rs #xF))) 1)
d1437 1
a1437 1
     (set-mem-psw (mem QI lmem8) (or (mem QI lmem8) (sll 1 imm3)) 0)
d1445 1
a1445 1
     (set-mem-psw (mem QI hmem8) (or (mem QI hmem8) (sll 1 imm3)) 0)
d1454 1
a1454 1
     (set-psw Rd (index-of Rd) (and Rd (inv (sll 1 imm4))) 1)
d1463 1
a1463 1
     (set-psw Rd (index-of Rd) (and Rd (inv (sll 1 (and Rs #xF)))) 1)
d1472 1
a1472 1
     (set-mem-psw (mem QI lmem8) (and (mem QI lmem8) (inv (sll 1 imm3))) 0)
d1480 1
a1480 1
     (set-mem-psw (mem QI hmem8) (and (mem QI hmem8) (inv (sll 1 imm3))) 0)
d1491 1
a1491 1
     (set-psw Rd (index-of Rd) (ext HI (trunc QI Rd)) 1)
d1517 1
a1517 1
       1)
d1826 1
a1826 1
			    (basic-psw (trunc HI value) 1)))
d1838 1
a1838 33
	       (set-mem-psw R0 (udiv R0 R2) 1))
     ()
)
(dni sdiv
     "Signed Divide"
     ()
     ("sdiv")
     (+ (f-op #x00C8))
     (sequence ()
	       (set R1 (mod HI R0 R2))
	       (set-mem-psw R0 (div HI R0 R2) 1))
     ()
)
(dni sdivlh
     "Divide 32/16"
     ()
     ("sdivlh")
     (+ (f-op #x00E8))
     (sequence ((SI value))
	       (set value (add SI (sll SI (and SI R1 #xffff) #x10) (and SI R0 #xffff)))
	       (set R1 (mod SI value (ext SI (trunc HI R2))))
	       (set-mem-psw R0 (div SI value (ext SI (trunc HI R2))) 1))
     ()
)
(dni divlh
     "Divide 32/16"
     ()
     ("divlh")
     (+ (f-op #x00E0))
     (sequence ((SI value))
	       (set value (add SI (sll SI (and SI R1 #xffff) #x10) (and SI R0 #xffff)))
	       (set R1 (umod SI value R2))
	       (set-mem-psw R0 (udiv SI value R2) 1))
a1842 4

; added per sanyo's req -- eq to nop for the moment, but can 
; add function later
(dni reset "reset" () ("reset") (+ (f-op #x000f)) (nop) ())
@


1.2.18.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d2 1
a2 1
; Copyright (C) 2001, 2002 Red Hat, Inc.
d271 1
a271 8
(define-operand
  (name imm16)
  (comment "16 bit immediate")
  (attrs)
  (type h-uint)
  (index f-imm16) 
  (handlers (parse "immediate16"))
)
a1838 32
     ()
)
(dni sdiv
     "Signed Divide"
     ()
     ("sdiv")
     (+ (f-op #x00C8))
     (sequence ()
	       (set R1 (mod HI R0 R2))
	       (set-mem-psw R0 (div HI R0 R2)))
     ()
)
(dni sdivlh
     "Divide 32/16"
     ()
     ("sdivlh")
     (+ (f-op #x00E8))
     (sequence ((SI value))
	       (set value (add SI (sll SI (and SI R1 #xffff) #x10) (and SI R0 #xffff)))
	       (set R1 (mod SI value (ext SI (trunc HI R2))))
	       (set-mem-psw R0 (div SI value (ext SI (trunc HI R2)))))
     ()
)
(dni divlh
     "Divide 32/16"
     ()
     ("divlh")
     (+ (f-op #x00E0))
     (sequence ((SI value))
	       (set value (add SI (sll SI (and SI R1 #xffff) #x10) (and SI R0 #xffff)))
	       (set R1 (umod SI value R2))
	       (set-mem-psw R0 (udiv SI value R2)))
@


1.2.18.2
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d2 1
a2 1
; Copyright (C) 2001, 2002, 2003 Red Hat, Inc.
a393 1
    (set (reg HI h-gr index) nvalue)
d396 2
a397 1
		     (basic-psw nvalue))))))
d415 15
a433 1
    (set (reg HI h-gr index) nvalue)
d437 2
a438 1
		     (basic-psw nvalue))))))
a443 1
    (set (reg HI h-gr index) value)
d450 2
a451 1
			 (sll index 12)))))))
a471 1
    (set (reg HI h-gr index) value)
d478 2
a479 1
			 (sll index 12)))))))
a490 5
; We have to be careful to get the right group of 16 shifts from the above.
(define-pmacro (set-psw-rrotate17 Rd index src c rot)
  (set-psw-rotate17 Rd index src c (sub 47 (mod (add (and rot #xf) 15) 17)))
  )

d519 1
a519 1
	 (set-mem-psw (mem HI (and lmem8 #xFFFE)) imm16)
d529 1
a529 1
	 (set-mem-psw (mem HI (and hmem8 #xFFFE)) imm16)
d561 1
a561 1
	 (set-mem-psw (mem HI (and lmem8 #xFFFE)) Rm)
d571 1
a571 1
	 (set-mem-psw (mem HI (and lmem8 #xFFFE)) Rm)
d622 1
a622 1
	       (set-psw-nowrite (index-of Rdm) Rdm))
d635 1
a635 2
	       (set-psw-nowrite (index-of Rdm) Rdm)
	       (set Rs (add Rs (add ws2 1))))
d645 1
a645 2
	       (set Rs (sub Rs (add ws2 1)))
	       (set-psw-nowrite (index-of Rdm) Rdm)
d698 1
a698 1
	       (set-psw-nowrite (index-of Rdm) Rdm))
d711 1
a711 2
	       (set-psw-nowrite (index-of Rdm) Rdm)
	       (set Rs (add Rs 1)))
d721 1
a721 2
	       (set Rs (sub Rs 1))
	       (set-psw-nowrite (index-of Rdm) Rdm)
d847 3
a849 3
		   (set-alignfix-mem (join SI HI R8 Rs) Rdm)
		   (set (mem QI (join SI HI R8 Rs)) Rdm))
	       (set-psw-nowrite (index-of Rdm) Rdm))
d860 3
a862 4
		   (set-alignfix-mem (join SI HI R8 Rs) Rdm)
		   (set (mem QI (join SI HI R8 Rs)) Rdm))
	       (set-psw-nowrite (index-of Rdm) Rdm)
	       (set Rs (add Rs (add ws2 1))))
d872 1
a872 2
	       (set-psw-nowrite (index-of Rdm) Rdm)
	       (set Rs (sub Rs (add ws2 1)))
d874 2
a875 2
		   (set-alignfix-mem (join SI HI R8 Rs) Rdm)
		   (set (mem QI (join SI HI R8 Rs)) Rdm)))
d926 1
a926 1
	       (set-psw-nowrite (index-of Rdm) Rdm))
d940 1
a940 2
	       (set-psw-nowrite (index-of Rdm) Rdm)
	       (set Rs (add Rs (add ws2 1))))
d950 1
a950 2
	       (set Rs (sub Rs 1))
	       (set-psw-nowrite (index-of Rdm) Rdm)
d1305 1
a1305 1
     (set-psw-rrotate17 Rd (index-of Rd) Rd psw-cy Rs)
d1314 1
a1314 1
     (set-psw-rrotate17 Rd (index-of Rd) Rd psw-cy imm4)
@


1.2.18.3
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d276 1
a276 1
  (index f-imm16)
d383 1
a383 1
(define-pmacro (basic-psw value ws)
d387 1
a387 1
	  (sll HI (nflag QI (srl value (mul ws 8))) 6))))
d391 1
a391 1
(define-pmacro (set-psw Rd index value ws)
d397 1
a397 1
		     (basic-psw nvalue ws))))))
d400 1
a400 1
(define-pmacro (set-psw-nowrite index value ws)
d405 1
a405 1
		     (basic-psw nvalue ws))))))
d408 1
a408 1
(define-pmacro (set-mem-psw dest value ws)
d412 1
a412 1
		 (basic-psw nvalue ws)))
d416 2
a417 2
(define-pmacro (set-psw-carry Rd index value carry ws)
  (sequence ((HI nvalue) (HI newpsw))
d419 3
a421 2
    (set newpsw (or (or (and psw #x0F98)
		     (sll (and carry #x1) 2))
d423 1
a423 4
		     (basic-psw nvalue ws))))
    (set (reg HI h-gr index) nvalue)
    (set psw newpsw)
    ))
d427 1
a427 1
  (sequence ((HI value) (HI newpsw))
a428 7
    (set newpsw (or (or (and psw #x0F80)
			(basic-psw value 1))
		    (or (or (sll HI (add-oflag HI a b c) 4)
			    (sll HI (add-cflag HI a b c) 2))
			(or (and (srl HI (addc HI (and a #xF) (and b #xF) c) 
				      1) #x8)
			    (sll index 12)))))
d430 7
a436 2
    (set psw newpsw)
    ))
d444 1
a444 1
		     (basic-psw value 1))
d455 1
a455 1
  (sequence ((HI value) (HI newpsw))
d457 3
a459 2
    (set newpsw (or (or (and psw #x0F80)
		     (basic-psw value 1))
d464 1
a464 4
			 (sll index 12)))))
    (set (reg HI h-gr index) value)
    (set psw newpsw)
    ))
d474 1
a474 1
    (set-psw-carry (reg HI h-gr index) index (trunc HI tmpfoo) (and (srl tmpfoo 16) 1) 1)))
d476 1
a476 1
; A 17-bit rotate-right operation
d478 2
a479 6
  (sequence ((SI tmpfoo))
    (set tmpfoo (or (or (and (sll SI src 17) #xFFFE0000) 
		     src)
		 (sll SI c 16)))
    (set tmpfoo (ror tmpfoo (and rot #x0F)))
    (set-psw-carry (reg HI h-gr index) index (trunc HI tmpfoo) (and (srl tmpfoo 16) 1) 1)))
d509 2
a510 2
	 (set-mem-psw (mem HI (and lmem8 #xFFFE)) imm16 ws2)
	 (set-mem-psw (mem QI lmem8) (and imm16 #xFF) ws2))
d519 2
a520 2
	 (set-mem-psw (mem HI (and hmem8 #xFFFE)) imm16 ws2)
	 (set-mem-psw (mem QI hmem8) (and imm16 #xFF) ws2))
d530 2
a531 2
	 (set-psw Rm (index-of Rm) (alignfix-mem lmem8) ws2)
	 (set-psw Rm (index-of Rm) (mem QI lmem8) ws2))
d540 2
a541 2
	 (set-psw Rm (index-of Rm) (alignfix-mem hmem8) ws2)
	 (set-psw Rm (index-of Rm) (mem QI hmem8) ws2))
d551 2
a552 2
	 (set-mem-psw (mem HI (and lmem8 #xFFFE)) Rm ws2)
	 (set-mem-psw (mem QI lmem8) Rm ws2))
d561 2
a562 2
	 (set-mem-psw (mem HI (and lmem8 #xFFFE)) Rm ws2)
	 (set-mem-psw (mem QI lmem8) Rm ws2))
d572 2
a573 2
	 (set-psw Rdm (index-of Rdm) (alignfix-mem Rs) ws2)
	 (set-psw Rdm (index-of Rdm) (and #xFF (mem QI Rs)) ws2))
d584 2
a585 2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem Rs) ws2)
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI Rs)) ws2))
d598 2
a599 2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem Rs) ws2)
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI Rs)) ws2)))
d612 1
a612 1
	       (set-psw-nowrite (index-of Rdm) Rdm ws2))
d625 1
a625 1
	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
d637 1
a637 1
	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
d650 2
a651 2
	 (set-psw Rdm (index-of Rdm) (alignfix-mem (add Rs imm12)) ws2)
	 (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add Rs imm12))) ws2))
d662 2
a663 2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem (add Rs imm12)) ws2)
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add Rs imm12))) ws2))
d676 2
a677 2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem (add Rs imm12)) ws2)
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add Rs imm12))) ws2)))
d690 1
a690 1
	       (set-psw-nowrite (index-of Rdm) Rdm ws2))
d703 1
a703 1
	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
d715 1
a715 1
	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
d727 1
a727 1
     (set-psw Rd (index-of Rd) Rs 1)
d743 1
a743 1
     (set-psw (reg HI h-gr Rpsw) Rpsw imm8 1)
d759 1
a759 1
     (set-psw Rm (index-of Rm) imm8small 1)
d775 1
a775 1
     (set-psw Rd (index-of Rd) imm16 1)
d784 1
a784 1
     (set-psw Rd (index-of Rd) (or (and Rd #xFF00) (and (reg HI h-gr Rpsw) #xFF)) 0)
d793 1
a793 1
     (set-psw Rd (index-of Rd) (or (and Rd #x00FF) (and (reg HI h-gr Rpsw) #xFF00)) 1)
d803 2
a804 2
	 (set-psw Rdm (index-of Rdm) (alignfix-mem (or (sll SI R8 16) Rs)) ws2)
	 (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (or (sll SI R8 16) Rs))) ws2))
d815 2
a816 2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem (join SI HI R8 Rs)) ws2)
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (join SI HI R8 Rs))) ws2))
d829 2
a830 2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem (join SI HI R8 Rs)) ws2)
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (join SI HI R8 Rs))) ws2)))
d843 1
a843 1
	       (set-psw-nowrite (index-of Rdm) Rdm ws2))
d856 1
a856 1
	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
d867 1
a867 1
	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
d881 2
a882 2
	 (set-psw Rdm (index-of Rdm) (alignfix-mem (add (join SI HI Rb Rs) imm12)) ws2)
	 (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add (join SI HI Rb Rs) imm12))) ws2))
d893 2
a894 2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem (add (join SI HI Rb Rs) imm12)) ws2)
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add (join SI HI Rb Rs) imm12))) ws2))
d907 2
a908 2
		   (set-psw Rdm (index-of Rdm) (alignfix-mem (add (join SI HI Rb Rs) imm12)) ws2)
		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add (join SI HI Rb Rs) imm12))) ws2)))
d922 1
a922 1
	       (set-psw-nowrite (index-of Rdm) Rdm ws2))
d936 1
a936 1
	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
d948 1
a948 1
	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
d960 1
a960 1
     (set-psw Rd (index-of Rd) (or HI (and HI Rd (inv HI Rs)) (and (reg HI h-gr Rpsw) Rs)) 1)
d969 1
a969 1
     (set-psw Rd (index-of Rd) (or (and Rd (inv imm16)) (and (reg HI h-gr Rpsw) imm16)) 1)
d1004 1
a1004 1
		     (and Rd #xFF00)) 0)
d1013 1
a1013 1
     (set-psw Rd (index-of Rd) (or (sll Rd 8) (srl Rd 8)) 1)
d1025 1
a1025 1
	       (set-psw Rd (index-of Rd) foo 1))
d1035 1
a1035 1
     (set-psw Rd (index-of Rd) (and Rd Rs) 1)
d1044 1
a1044 1
     (set-psw (reg HI h-gr Rpsw) Rpsw (and (reg HI h-gr Rpsw) imm8) 1)
d1053 1
a1053 1
     (set-psw Rd (index-of Rd) (and Rd imm16) 1)
d1062 1
a1062 1
     (set-psw Rd (index-of Rd) (or Rd Rs) 1)
d1071 1
a1071 1
     (set-psw (reg HI h-gr Rpsw) Rpsw (or (reg HI h-gr Rpsw) imm8) 1)
d1080 1
a1080 1
     (set-psw Rd (index-of Rd) (or Rd imm16) 1)
d1089 1
a1089 1
     (set-psw Rd (index-of Rd) (xor Rd Rs) 1)
d1098 1
a1098 1
     (set-psw (reg HI h-gr Rpsw) Rpsw (xor (reg HI h-gr Rpsw) imm8) 1)
d1107 1
a1107 1
     (set-psw Rd (index-of Rd) (xor Rd imm16) 1)
d1116 1
a1116 1
     (set-psw Rd (index-of Rd) (inv Rd) 1)
d1277 1
a1277 1
     (set-psw Rd (index-of Rd) (add Rd (add imm2 1)) 1)
d1293 1
a1293 1
     (set-psw Rd (index-of Rd) (sub Rd (add imm2 1)) 1)
d1342 1
a1342 1
			     psw-cy
d1344 1
a1344 1
			 1) 1)
d1356 1
a1356 1
			     psw-cy
d1358 1
a1358 1
			 1) 1)
d1370 1
a1370 1
			     (sll psw-cy 15)
d1372 1
a1372 1
			 15) 1)
d1384 1
a1384 1
			     (sll psw-cy 15)
d1386 1
a1386 1
			 15) 1)
d1398 1
a1398 1
			     psw-cy
d1400 1
a1400 1
			 1) 1)
d1412 1
a1412 1
			     psw-cy
d1414 1
a1414 1
			 1) 1)
d1424 1
a1424 1
     (set-psw Rd (index-of Rd) (or Rd (sll 1 imm4)) 1)
d1433 1
a1433 1
     (set-psw Rd (index-of Rd) (or Rd (sll 1 (and Rs #xF))) 1)
d1442 1
a1442 1
     (set-mem-psw (mem QI lmem8) (or (mem QI lmem8) (sll 1 imm3)) 0)
d1450 1
a1450 1
     (set-mem-psw (mem QI hmem8) (or (mem QI hmem8) (sll 1 imm3)) 0)
d1459 1
a1459 1
     (set-psw Rd (index-of Rd) (and Rd (inv (sll 1 imm4))) 1)
d1468 1
a1468 1
     (set-psw Rd (index-of Rd) (and Rd (inv (sll 1 (and Rs #xF)))) 1)
d1477 1
a1477 1
     (set-mem-psw (mem QI lmem8) (and (mem QI lmem8) (inv (sll 1 imm3))) 0)
d1485 1
a1485 1
     (set-mem-psw (mem QI hmem8) (and (mem QI hmem8) (inv (sll 1 imm3))) 0)
d1496 1
a1496 1
     (set-psw Rd (index-of Rd) (ext HI (trunc QI Rd)) 1)
d1522 1
a1522 1
       1)
d1831 1
a1831 1
			    (basic-psw (trunc HI value) 1)))
d1843 1
a1843 1
	       (set-mem-psw R0 (udiv R0 R2) 1))
d1853 1
a1853 1
	       (set-mem-psw R0 (div HI R0 R2) 1))
d1864 1
a1864 1
	       (set-mem-psw R0 (div SI value (ext SI (trunc HI R2))) 1))
d1875 1
a1875 1
	       (set-mem-psw R0 (udiv SI value R2) 1))
a1879 4

; added per sanyo's req -- eq to nop for the moment, but can 
; add function later
(dni reset "reset" () ("reset") (+ (f-op #x000f)) (nop) ())
@


1.2.18.4
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d495 5
a499 1
  (mem HI (and where #xFFFE)))
d502 10
a511 1
  (set (mem HI (and where #xFFFE)) what))
@


1.2.18.5
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a32 1
  (word-bitsize 32)
a49 18
; IDOC attribute for instruction documentation.

(define-attr
  (for insn)
  (type enum)
  (name IDOC)
  (comment "insn kind for documentation")
  (attrs META)
  (values
   (MEM - () "Memory")
   (ALU - () "ALU")
   (FPU - () "FPU")
   (BR - () "Branch")
   (PRIV - () "Priviledged")
   (MISC - () "Miscellaneous")
  )
)

@


1.1
log
@	* cpu/xstormy16.cpu: New file.
	* cpu/xstormy16.opc: New file.
@
text
@d64 1
a64 1
  (name gr-Rbj-names)
d66 3
a68 1
  (values (r8 0) (r9 1)))
d80 10
d94 1
a94 1
  (indices extern-keyword gr-Rbj-names)
d168 1
a168 1
(dnop Rb "base register" ()  h-gr f-Rb)
d1849 2
@

