head	1.46;
access;
symbols
	sid-snapshot-20180601:1.46
	cgen-snapshot-20180601:1.46
	sid-snapshot-20180501:1.46
	cgen-snapshot-20180501:1.46
	sid-snapshot-20180401:1.46
	cgen-snapshot-20180401:1.46
	sid-snapshot-20180301:1.46
	cgen-snapshot-20180301:1.46
	sid-snapshot-20180201:1.46
	cgen-snapshot-20180201:1.46
	sid-snapshot-20180101:1.46
	cgen-snapshot-20180101:1.46
	sid-snapshot-20171201:1.46
	cgen-snapshot-20171201:1.46
	sid-snapshot-20171101:1.46
	cgen-snapshot-20171101:1.46
	sid-snapshot-20171001:1.46
	cgen-snapshot-20171001:1.46
	sid-snapshot-20170901:1.46
	cgen-snapshot-20170901:1.46
	sid-snapshot-20170801:1.46
	cgen-snapshot-20170801:1.46
	sid-snapshot-20170701:1.46
	cgen-snapshot-20170701:1.46
	sid-snapshot-20170601:1.46
	cgen-snapshot-20170601:1.46
	sid-snapshot-20170501:1.46
	cgen-snapshot-20170501:1.46
	sid-snapshot-20170401:1.46
	cgen-snapshot-20170401:1.46
	sid-snapshot-20170301:1.46
	cgen-snapshot-20170301:1.46
	sid-snapshot-20170201:1.46
	cgen-snapshot-20170201:1.46
	sid-snapshot-20170101:1.46
	cgen-snapshot-20170101:1.46
	sid-snapshot-20161201:1.46
	cgen-snapshot-20161201:1.46
	sid-snapshot-20161101:1.46
	cgen-snapshot-20161101:1.46
	sid-snapshot-20160901:1.46
	cgen-snapshot-20160901:1.46
	sid-snapshot-20160801:1.46
	cgen-snapshot-20160801:1.46
	sid-snapshot-20160701:1.46
	cgen-snapshot-20160701:1.46
	sid-snapshot-20160601:1.46
	cgen-snapshot-20160601:1.46
	sid-snapshot-20160501:1.46
	cgen-snapshot-20160501:1.46
	sid-snapshot-20160401:1.46
	cgen-snapshot-20160401:1.46
	sid-snapshot-20160301:1.46
	cgen-snapshot-20160301:1.46
	sid-snapshot-20160201:1.46
	cgen-snapshot-20160201:1.46
	sid-snapshot-20160101:1.46
	cgen-snapshot-20160101:1.46
	sid-snapshot-20151201:1.46
	cgen-snapshot-20151201:1.46
	sid-snapshot-20151101:1.46
	cgen-snapshot-20151101:1.46
	sid-snapshot-20151001:1.46
	cgen-snapshot-20151001:1.46
	sid-snapshot-20150901:1.46
	cgen-snapshot-20150901:1.46
	sid-snapshot-20150801:1.46
	cgen-snapshot-20150801:1.46
	sid-snapshot-20150701:1.46
	cgen-snapshot-20150701:1.46
	sid-snapshot-20150601:1.46
	cgen-snapshot-20150601:1.46
	sid-snapshot-20150501:1.46
	cgen-snapshot-20150501:1.46
	sid-snapshot-20150401:1.46
	cgen-snapshot-20150401:1.46
	sid-snapshot-20150301:1.46
	cgen-snapshot-20150301:1.46
	sid-snapshot-20150201:1.46
	cgen-snapshot-20150201:1.46
	sid-snapshot-20150101:1.46
	cgen-snapshot-20150101:1.46
	sid-snapshot-20141201:1.46
	cgen-snapshot-20141201:1.46
	sid-snapshot-20141101:1.46
	cgen-snapshot-20141101:1.46
	sid-snapshot-20141001:1.46
	cgen-snapshot-20141001:1.46
	sid-snapshot-20140901:1.46
	cgen-snapshot-20140901:1.46
	sid-snapshot-20140801:1.46
	cgen-snapshot-20140801:1.46
	sid-snapshot-20140701:1.46
	cgen-snapshot-20140701:1.46
	sid-snapshot-20140601:1.46
	cgen-snapshot-20140601:1.46
	sid-snapshot-20140501:1.46
	cgen-snapshot-20140501:1.46
	sid-snapshot-20140401:1.46
	cgen-snapshot-20140401:1.46
	sid-snapshot-20140301:1.46
	cgen-snapshot-20140301:1.46
	sid-snapshot-20140201:1.46
	cgen-snapshot-20140201:1.46
	sid-snapshot-20140101:1.46
	cgen-snapshot-20140101:1.46
	sid-snapshot-20131201:1.46
	cgen-snapshot-20131201:1.46
	sid-snapshot-20131101:1.46
	cgen-snapshot-20131101:1.46
	sid-snapshot-20131001:1.46
	cgen-snapshot-20131001:1.46
	sid-snapshot-20130901:1.46
	cgen-snapshot-20130901:1.46
	sid-snapshot-20130801:1.46
	cgen-snapshot-20130801:1.46
	sid-snapshot-20130701:1.46
	cgen-snapshot-20130701:1.46
	sid-snapshot-20130601:1.46
	cgen-snapshot-20130601:1.46
	sid-snapshot-20130501:1.46
	cgen-snapshot-20130501:1.46
	sid-snapshot-20130401:1.46
	cgen-snapshot-20130401:1.46
	sid-snapshot-20130301:1.46
	cgen-snapshot-20130301:1.46
	sid-snapshot-20130201:1.46
	cgen-snapshot-20130201:1.46
	sid-snapshot-20130101:1.46
	cgen-snapshot-20130101:1.46
	sid-snapshot-20121201:1.46
	cgen-snapshot-20121201:1.46
	sid-snapshot-20121101:1.46
	cgen-snapshot-20121101:1.46
	sid-snapshot-20121001:1.46
	cgen-snapshot-20121001:1.46
	sid-snapshot-20120901:1.46
	cgen-snapshot-20120901:1.46
	sid-snapshot-20120801:1.46
	cgen-snapshot-20120801:1.46
	sid-snapshot-20120701:1.46
	cgen-snapshot-20120701:1.46
	sid-snapshot-20120601:1.46
	cgen-snapshot-20120601:1.46
	sid-snapshot-20120501:1.46
	cgen-snapshot-20120501:1.46
	sid-snapshot-20120401:1.46
	cgen-snapshot-20120401:1.46
	sid-snapshot-20120301:1.46
	cgen-snapshot-20120301:1.46
	sid-snapshot-20120201:1.46
	cgen-snapshot-20120201:1.46
	sid-snapshot-20120101:1.46
	cgen-snapshot-20120101:1.46
	sid-snapshot-20111201:1.46
	cgen-snapshot-20111201:1.46
	sid-snapshot-20111101:1.46
	cgen-snapshot-20111101:1.46
	sid-snapshot-20111001:1.46
	cgen-snapshot-20111001:1.46
	sid-snapshot-20110901:1.46
	cgen-snapshot-20110901:1.46
	sid-snapshot-20110801:1.46
	cgen-snapshot-20110801:1.46
	sid-snapshot-20110701:1.46
	cgen-snapshot-20110701:1.46
	sid-snapshot-20110601:1.46
	cgen-snapshot-20110601:1.46
	sid-snapshot-20110501:1.46
	cgen-snapshot-20110501:1.46
	sid-snapshot-20110401:1.46
	cgen-snapshot-20110401:1.46
	sid-snapshot-20110301:1.46
	cgen-snapshot-20110301:1.46
	sid-snapshot-20110201:1.46
	cgen-snapshot-20110201:1.46
	sid-snapshot-20110101:1.46
	cgen-snapshot-20110101:1.46
	sid-snapshot-20101201:1.46
	cgen-snapshot-20101201:1.46
	sid-snapshot-20101101:1.46
	cgen-snapshot-20101101:1.46
	sid-snapshot-20101001:1.46
	cgen-snapshot-20101001:1.46
	sid-snapshot-20100901:1.46
	cgen-snapshot-20100901:1.46
	sid-snapshot-20100801:1.46
	cgen-snapshot-20100801:1.46
	sid-snapshot-20100701:1.46
	cgen-snapshot-20100701:1.46
	sid-snapshot-20100601:1.46
	cgen-snapshot-20100601:1.46
	sid-snapshot-20100501:1.46
	cgen-snapshot-20100501:1.46
	sid-snapshot-20100401:1.46
	cgen-snapshot-20100401:1.46
	sid-snapshot-20100301:1.46
	cgen-snapshot-20100301:1.46
	sid-snapshot-20100201:1.46
	cgen-snapshot-20100201:1.46
	sid-snapshot-20100101:1.41
	cgen-snapshot-20100101:1.41
	sid-snapshot-20091201:1.41
	cgen-snapshot-20091201:1.41
	sid-snapshot-20091101:1.37
	cgen-snapshot-20091101:1.37
	sid-snapshot-20091001:1.36
	cgen-snapshot-20091001:1.36
	arc-sim-20090309:1.14.2.1
	sid-snapshot-20090901:1.33
	cgen-snapshot-20090901:1.33
	sid-snapshot-20090801:1.22
	cgen-snapshot-20090801:1.22
	sid-snapshot-20090701:1.19
	cgen-snapshot-20090701:1.19
	dje-cgen-play1-branch:1.19.0.2
	dje-cgen-play1-branchpoint:1.19
	cgen-1_1-branch:1.17.0.2
	cgen-1_1-branchpoint:1.17
	sid-snapshot-20090601:1.14
	cgen-snapshot-20090601:1.14
	sid-snapshot-20090501:1.14
	cgen-snapshot-20090501:1.14
	sid-snapshot-20090401:1.14
	cgen-snapshot-20090401:1.14
	arc-insight_6_8-branch:1.14.0.2
	arc-insight_6_8-branchpoint:1.14
	sid-snapshot-20090301:1.14
	cgen-snapshot-20090301:1.14
	sid-snapshot-20090201:1.14
	cgen-snapshot-20090201:1.14
	sid-snapshot-20090101:1.14
	cgen-snapshot-20090101:1.14
	sid-snapshot-20081201:1.14
	cgen-snapshot-20081201:1.14
	sid-snapshot-20081101:1.14
	cgen-snapshot-20081101:1.14
	sid-snapshot-20081001:1.14
	cgen-snapshot-20081001:1.14
	sid-snapshot-20080901:1.14
	cgen-snapshot-20080901:1.14
	sid-snapshot-20080801:1.14
	cgen-snapshot-20080801:1.14
	sid-snapshot-20080701:1.14
	cgen-snapshot-20080701:1.14
	sid-snapshot-20080601:1.14
	cgen-snapshot-20080601:1.14
	sid-snapshot-20080501:1.14
	cgen-snapshot-20080501:1.14
	sid-snapshot-20080403:1.14
	sid-snapshot-20080401:1.14
	cgen-snapshot-20080401:1.14
	sid-snapshot-20080301:1.14
	cgen-snapshot-20080301:1.14
	sid-snapshot-20080201:1.14
	cgen-snapshot-20080201:1.14
	sid-snapshot-20080101:1.14
	cgen-snapshot-20080101:1.14
	sid-snapshot-20071201:1.14
	cgen-snapshot-20071201:1.14
	sid-snapshot-20071101:1.14
	cgen-snapshot-20071101:1.14
	sid-snapshot-20071001:1.14
	cgen-snapshot-20071001:1.14
	msnyder-fork-checkpoint-branch:1.11.0.2
	msnyder-fork-checkpoint-branchpoint:1.11
	sid-20020905-branchpoint:1.6
	sid-20020905-branch:1.6.0.6
	cagney_regbuf-20020515-branch:1.6.0.4
	cagney_regbuf-20020515-branchpoint:1.6
	cygnus_cvs_20020108_pre:1.6
	cgen-1-1-branch:1.6.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.46
date	2010.01.29.02.59.01;	author devans;	state Exp;
branches;
next	1.45;

1.45
date	2010.01.29.02.26.57;	author devans;	state Exp;
branches;
next	1.44;

1.44
date	2010.01.28.05.05.47;	author devans;	state Exp;
branches;
next	1.43;

1.43
date	2010.01.25.03.50.43;	author devans;	state Exp;
branches;
next	1.42;

1.42
date	2010.01.20.05.56.59;	author devans;	state Exp;
branches;
next	1.41;

1.41
date	2009.11.23.03.28.31;	author devans;	state Exp;
branches;
next	1.40;

1.40
date	2009.11.21.09.40.26;	author devans;	state Exp;
branches;
next	1.39;

1.39
date	2009.11.21.09.34.06;	author devans;	state Exp;
branches;
next	1.38;

1.38
date	2009.11.03.16.24.02;	author devans;	state Exp;
branches;
next	1.37;

1.37
date	2009.10.26.00.56.34;	author devans;	state Exp;
branches;
next	1.36;

1.36
date	2009.09.21.15.18.54;	author devans;	state Exp;
branches;
next	1.35;

1.35
date	2009.09.09.20.43.04;	author devans;	state Exp;
branches;
next	1.34;

1.34
date	2009.09.07.22.17.34;	author devans;	state Exp;
branches;
next	1.33;

1.33
date	2009.08.27.06.09.02;	author devans;	state Exp;
branches;
next	1.32;

1.32
date	2009.08.27.05.47.12;	author devans;	state Exp;
branches;
next	1.31;

1.31
date	2009.08.24.06.46.16;	author devans;	state Exp;
branches;
next	1.30;

1.30
date	2009.08.23.16.15.53;	author devans;	state Exp;
branches;
next	1.29;

1.29
date	2009.08.20.05.50.48;	author devans;	state Exp;
branches;
next	1.28;

1.28
date	2009.08.19.04.20.29;	author devans;	state Exp;
branches;
next	1.27;

1.27
date	2009.08.16.17.44.22;	author devans;	state Exp;
branches;
next	1.26;

1.26
date	2009.08.12.22.33.37;	author devans;	state Exp;
branches;
next	1.25;

1.25
date	2009.08.07.21.29.20;	author devans;	state Exp;
branches;
next	1.24;

1.24
date	2009.08.06.21.52.08;	author devans;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.06.16.40.43;	author devans;	state Exp;
branches;
next	1.22;

1.22
date	2009.07.21.04.23.59;	author devans;	state Exp;
branches;
next	1.21;

1.21
date	2009.07.16.17.43.49;	author devans;	state Exp;
branches;
next	1.20;

1.20
date	2009.07.13.20.55.21;	author devans;	state Exp;
branches;
next	1.19;

1.19
date	2009.06.22.05.14.09;	author devans;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2009.06.20.21.58.01;	author devans;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.18.18.12.32;	author devans;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2009.06.14.22.07.08;	author devans;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.14.21.58.17;	author devans;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.10.17.49.38;	author brolley;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2006.05.10.16.24.53;	author brolley;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.09.16.17.07;	author brolley;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.15.09.01.35;	author jimb;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.16.21.23.13;	author jimb;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.08.17.17.22;	author brolley;	state Exp;
branches;
next	1.8;

1.8
date	2003.07.16.05.35.47;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.10.21.22.03;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.05.12.45.46;	author bje;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.04.06.49.02;	author bje;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.24.12.22.35;	author bje;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.08.18.44.23;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.21.20.16.23;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.19.2.1
date	2009.07.14.16.08.50;	author devans;	state Exp;
branches;
next	;

1.17.2.1
date	2009.06.20.22.02.05;	author devans;	state Exp;
branches;
next	;

1.14.2.1
date	2009.03.09.20.36.04;	author amylaar;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.46
log
@	* pmacros.scm (pmacros-init!): New arg rtl-version, all callers
	updated.  Use %-prefix if rtl-version >= 0.9.
	* read.scm (/supported-rtl-versions): Add (0 9).
	(/rtl-version-valid?): New function.
	(/cmd-define-rtl-version): If new rtl version, reinvoke pmacros-init!.
	(/reader-expr): New function.
	(reader-process): New function.
	(/reader-process-with-loc!): Renamed from /reader-process!.
	Don't pre-expand `if' commands.
	(/cmd-if): Simplify.  Pmacro-expand test, then, else clauses here.
	Handle rtl-version-equal?, rtl-version-at-least?.
	* testsuite/Makefile.am (clean-test-files): Remove *.test.cpu*.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/pmacros-1.test: Test both . and % as prefixes.
	* testsuite/testsuite.cpu (/begin, /print, /dump): New pmacros.
	(newline, print-match, print-expr, print-thunk): Use them.
	(internal-verify): Update definition.
	* doc/rtl.texi (define-rtl-version): Document rtl version 0.9.
	(Top level conditionals): New node.
@
text
@;; Top level file for reading and recording .cpu file contents.
;; Copyright (C) 2000, 2001, 2006, 2009, 2010 Red Hat, Inc.
;; This file is part of CGEN.
;; See file COPYING.CGEN for details.

;; This file [and its subordinates] contain no C code (well, as little as
;; possible).  That lives at a layer above us.

;; A .cpu file consists of several sections:
;;
;; - basic definitions (e.g. cpu variants, word size, endianness, etc.)
;; - enums (enums are used throughout so by convention there is a special
;;   section in which they're defined)
;; - attributes
;; - instruction fields and formats
;; - hardware descriptions (e.g. registers, allowable immediate values)
;; - model descriptions (e.g. pipelines, latencies, etc.)
;; - instruction operands (mapping of insn fields to associated hardware)
;; - instruction definitions
;; - macro instruction definitions

;; TODO:
;; - memory access, layout, etc.
;; - floating point quirks
;; - ability to describe an ABI
;; - anything else that comes along

;; Notes:
;; - by convention most objects are subclasses of <ident> (having name, comment,
;;   and attrs elements and they are the first three elements of any .cpu file
;;   entry

;; Guidelines:
;; - Try to conform to R5RS, try to limit guile-ness.
;;   The current code is undoubtedly off in many places.

;; Conventions:
;; [I want there to be a plethora of conventions and I want them strictly
;; adhered to.  ??? There's probably a few violations here and there.
;; No big deal - fix them!]
;; These conventions are subject to revision.
;;
;; - procs/vars local to a file are named "-foo"
;; - only routines that emit application code begin with "gen-"
;; - symbols beginning with "c-" are either variables containing C code
;;   or procedures that generate C code, similarily for C++ and "c++-"
;; - variables containing C code begin with "c-"
;; - only routines that emit an entire file begin with "cgen-"
;; - all .cpu file elements shall have -foo-parse and -foo-read procedures
;; - global vars containing class definitions shall be named "<class-name>"
;; - procs related to a particular class shall be named "class-name-proc-name",
;;   class-name may be abbreviated
;; - procs that test whether something is an object of a particular class
;;   shall be named "class-name?"
;; - in keeping with Scheme conventions, predicates shall have a "?" suffix
;; - in keeping with Scheme conventions, methods and procedures that modify an
;;   argument or have other side effects shall have a "!" suffix,
;;   usually these procs return "*UNSPECIFIED*"
;; - all -foo-parse,parse-foo procs shall have `context' as the first arg
;;   [FIXME: not all such procs have been converted]
;; - stay away from non-portable C symbols.

;; Variables representing misc. global constants.

;; A list of three numbers designating the cgen version: major minor fixlevel.
;; The "50" is a generic indicator that we're between 1.1 and 1.2.
(define /CGEN-VERSION '(1 1 50))
(define (cgen-major) (car /CGEN-VERSION))
(define (cgen-minor) (cadr /CGEN-VERSION))
(define (cgen-fixlevel) (caddr /CGEN-VERSION))

;; A list of two numbers designating the description language version.
;; Note that this is different from /CGEN-VERSION.
;; See section "RTL Versions" of the docs.
(define /CGEN-RTL-VERSION #f)
(define /default-rtl-version '(0 7))
(define (cgen-rtl-version) /CGEN-RTL-VERSION)
(define (cgen-rtl-major) (car /CGEN-RTL-VERSION))
(define (cgen-rtl-minor) (cadr /CGEN-RTL-VERSION))

;; Utilities for testing the rtl version.
(define (rtl-version-equal? major minor)
  (equal? (cgen-rtl-version) (list major minor))
)
(define (rtl-version-at-least? major minor)
  (let ((rmajor (cgen-rtl-major))
	(rminor (cgen-rtl-minor)))
    (or (> rmajor major)
	(and (= rmajor major)
	     (>= rminor minor))))
)
(define (rtl-version-older? major minor)
  (not (rtl-version-at-least? major minor))
)

;; List of supported versions
(define /supported-rtl-versions '((0 7) (0 8) (0 9)))

;; Return a boolean indicating if VERSION is valid.

(define (/rtl-version-valid? version) (member version /supported-rtl-versions))

(define (/cmd-define-rtl-version major minor)
  (if (not (non-negative-integer? major))
      (parse-error #f "Invalid major version number" major))
  (if (not (non-negative-integer? minor))
      (parse-error #f "Invalid minor version number" minor))

  (let ((new-version (list major minor)))
    (if (not (member new-version /supported-rtl-versions))
	(parse-error #f "Unsupported/invalid rtl version" new-version))
    (if (not (equal? new-version /CGEN-RTL-VERSION))
	(begin
	  (logit 1 "Setting RTL version to " major "." minor " ...\n")
	  ;; Pmacros are rtl-version-dependent.  If we've changed the RTL
	  ;; version, re-initialize.
	  (pmacros-init! new-version)
	  (set! /CGEN-RTL-VERSION new-version))))
)

;; Which application is in use (UNKNOWN, DESC, OPCODES, SIMULATOR, ???).
;; This is mostly for descriptive purposes.
(define APPLICATION 'UNKNOWN)

;; Load the base cgen files.

(load "pmacros")
(load "cos")
(load "slib/logical")
(load "slib/sort")
;; Used to pretty-print debugging messages.
(load "slib/pp")
;; Used by pretty-print.
(load "slib/random")
(load "slib/genwrite")
(load "utils")
(load "utils-cgen")
(load "attr")
(load "enum")
(load "mach")
(load "model")
(load "types")
(load "mode")
(load "ifield")
(load "iformat")
(load "hardware")
(load "operand")
(load "insn")
(load "minsn")
(load "decode")
(load "rtl")
(load "rtl-traverse")
(load "rtl-xform")
(load "rtx-funcs")
(load "rtl-c")
(load "semantics")
(load "sem-frags")
(load "utils-gen")
(load "pgmr-tools")

;; Reader state data.
;; All state regarding the reading of a .cpu file is kept in an object of
;; class <reader>.

;; Class to record info for each top-level `command' (for lack of a better
;; word) in the description file.
;; Top level commands are things like define-*.

(define <command>
  (class-make '<command>
	      '(<ident>)
	      '(
		;; argument spec to `lambda'
		arg-spec
		;; lambda that processes the entry
		handler
		)
	      nil)
)

(define command-arg-spec (elm-make-getter <command> 'arg-spec))
(define command-handler (elm-make-getter <command> 'handler))

;; Return help text for COMMAND.

(define (command-help cmd)
  (string-append
   (obj:comment cmd)
   "Arguments: "
   (with-output-to-string (lambda () (write (command-arg-spec cmd))))
   "\n")
)

;; A pair of two lists: machs to keep, machs to drop.
;; The default is "keep all machs", "drop none".

(define /keep-all-machs '((all)))

;; Main reader state class.

(define <reader>
  (class-make '<reader>
	      nil
	      (list
	       ;; Selected machs to keep.
	       ;; A pair of two lists: the car lists the machs to keep, the cdr
	       ;; lists the machs to drop.  Two special entries are `all' and
	       ;; `base'.  Both are only valid in the keep list.  `base' is a
	       ;; place holder for objects that are common to all machine
	       ;; variants in the architecture, it is the default value of the
	       ;; MACH attribute.  If `all' is present the drop list is still
	       ;; processed.
	       (cons 'keep-mach /keep-all-machs)

	       ;; Selected isas to keep or `all'.
	       '(keep-isa . (all))

	       ;; Boolean indicating if command tracing is on.
	       (cons 'trace-commands? #f)

	       ;; Boolean indicating if pmacro tracing is on.
	       (cons 'trace-pmacros? #f)

	       ;; Issue diagnostics for instruction format issues.
	       (cons 'verify-iformat? #f)

	       ;; Currently select cpu family, computed from `keep-mach'.
	       ;; Some applications don't care, and this is moderately
	       ;; expensive to compute so we use delay/force.
	       'current-cpu

	       ;; Associative list of file entry commands
	       ;; (e.g. define-insn, etc.).
	       ;; Each entry is (name . command-object).
	       (cons 'commands nil)

	       ;; The current source location.
	       ;; This is recorded here by the higher level reader and is
	       ;; fetched by commands as necessary.
	       'location
	       )
	      nil)
)

;; Accessors.

(define-getters <reader> reader
  (keep-mach keep-isa
   trace-commands? trace-pmacros? verify-iformat?
   current-cpu commands location))
(define-setters <reader> reader
  (keep-mach keep-isa
   trace-commands? trace-pmacros? verify-iformat?
   current-cpu commands location))

(define (reader-add-command! name comment attrs arg-spec handler)
  (reader-set-commands! CURRENT-READER
			(acons name
			       (make <command> name comment attrs
				     arg-spec handler)
			       (reader-commands CURRENT-READER)))
)

(define (/reader-lookup-command name)
  (assq-ref (reader-commands CURRENT-READER) name)
)

;; Reader state for current .cpu file.

(define CURRENT-READER #f)

;; Return the current source location in readable form.
;; FIXME: Currently unused, keep for reference for awhile.

(define (/readable-current-location)
  (let ((loc (current-reader-location)))
    (if loc
	(location->string loc)
	;; Blech, we don't have a current reader location.  That's odd.
	;; Fall back to the current input port's location.
	(string-append (or (port-filename (current-input-port))
			    "<input>")
			":"
			(number->string (port-line (current-input-port)))
			":")))
)

;; Subroutine of parse-error, parse-warning to simplify them.
;; Flag an error or a warning.
;; EMITTER is a function of one argument, the message to print.

(define (/parse-diagnostic emitter context message expr maybe-help-text)
  (if (not context)
      (set! context (make <context> (current-reader-location) #f)))

  (let* ((loc (or (context-location context) (unspecified-location)))
	 (top-sloc (location-top loc))
	 (intro "While reading description")
	 (prefix (or (context-prefix context) "Error"))
	 (text (string-append prefix ": " message)))

    (emitter
     (simple-format
      #f
      "\n~A:\n@@ ~A:\n\n~A: ~A: ~S~A"
      intro
      (location->string loc)
      (single-location->simple-string top-sloc)
      text
      expr
      (if maybe-help-text
	  (string-append "\n\n" maybe-help-text)
	  ""))))
)

;; Signal a parse error while reading a .cpu file.
;; Processing stops immediately.
;; If CONTEXT is #f, use a default context of the current reader location
;; and an empty prefix.
;; If MAYBE-HELP-TEXT is specified, elide the last trailing \n.
;; Multiple lines of help text need embedded newlines, and should be no longer
;; than 79 characters.

(define (parse-error context errmsg expr . maybe-help-text)
  (/parse-diagnostic error
		     context
		     errmsg
		     expr
		     (if (null? maybe-help-text) "" (car maybe-help-text)))
)

;; Same as parse-error, but continue processing.

(define (parse-error-continuable context errmsg expr . maybe-help-text)
  (set! /continuable-error-found? #t)
  (/parse-diagnostic (lambda (text) (message "Error: " text "\n"))
		     context
		     errmsg
		     expr
		     (if (null? maybe-help-text) #f (car maybe-help-text)))
)

;; Signal a parse warning while reading a .cpu file.
;; If CONTEXT is #f, use a default context of the current reader location
;; and an empty prefix.
;; If MAYBE-HELP-TEXT is specified, elide the last trailing \n.
;; Multiple lines of help text need embedded newlines, and should be no longer
;; than 79 characters.

(define (parse-warning context errmsg expr . maybe-help-text)
  (/parse-diagnostic (lambda (text) (message "Warning: " text "\n"))
		     context
		     errmsg
		     expr
		     (if (null? maybe-help-text) #f (car maybe-help-text)))
)

;; Return the current source location.
;;
;; If CURRENT-READER is uninitialized, return "unspecified" location.
;; This is done so that things like define-pmacro work in interactive mode.

(define (current-reader-location)
  (if CURRENT-READER
      (reader-location CURRENT-READER)
      (unspecified-location))
)

;; Pmacro-expand EXPR.

(define (/reader-expand expr loc)
  (if (reader-trace-pmacros? CURRENT-READER)
      (pmacro-trace expr loc)
      (pmacro-expand expr loc))
)

;; Process a pmacro-expanded entry.

(define (/reader-process-expanded-1! entry)
  (let ((location (location-property entry)))

    (if (not (form? entry))
	(parse-error location "improperly formed entry" entry))

    ;; Set the current source location for better diagnostics.
    ;; Access with current-reader-location.
    (reader-set-location! CURRENT-READER location)

    (if (reader-trace-commands? CURRENT-READER)
	(message "Processing command:\n  @@ "
		 (if location (location->string location) "location unknown")
		 "\n"
		 (with-output-to-string (lambda () (pretty-print entry)))))

    (let ((command (/reader-lookup-command (car entry)))
	  (context (make-current-context #f)))

      (if command

	  (let* ((handler (command-handler command))
		 (arg-spec (command-arg-spec command))
		 (num-args (num-args arg-spec)))
	    (if (cdr num-args)
		;; Variable number of trailing arguments.
		(if (< (length (cdr entry)) (car num-args))
		    (parse-error context
				 (string-append "Incorrect number of arguments to "
						(symbol->string (car entry))
						", expecting at least "
						(number->string (car num-args)))
				 entry
				 (command-help command))
		    (apply handler (cdr entry)))
		;; Fixed number of arguments.
		(if (!= (length (cdr entry)) (car num-args))
		    (parse-error context
				 (string-append "Incorrect number of arguments to "
						(symbol->string (car entry))
						", expecting "
						(number->string (car num-args)))
				 entry
				 (command-help command))
		    (apply handler (cdr entry)))))

	  (parse-error context "unknown entry type" entry))))

  *UNSPECIFIED*
)

;; Process one or more pmacro-expanded entries.
;; ENTRY is expected to have a location-property object property.

(define (reader-process-expanded! entry)
  ;; () is used to indicate a no-op
  (cond ((null? entry)
	 #f) ;; nothing to do
	;; `begin' is used to group a collection of entries into one,
	;; since pmacro can only return one expression (borrowed from
	;; Scheme of course).
	;; Recurse in case there are nested begins.
	((eq? (car entry) 'begin)
	 (for-each reader-process-expanded!
		   (cdr entry)))
	(else
	 (/reader-process-expanded-1! entry)))

  *UNSPECIFIED*
)

;; Process ENTRY, which is not yet pmacro-expanded.

(define (reader-process! entry)
  (/reader-process-with-loc! entry
			     (or (location-property entry)
				 (unspecified-location)))
)

;; Process file entry ENTRY.
;; LOC is a <location> object for ENTRY.

(define (/reader-process-with-loc! entry loc)
  ;; () is used to indicate a no-op
  (cond ((null? entry)
	 #f) ;; nothing to do
	;; `begin' is used to group a collection of entries into one,
	;; since pmacro can only return one expression (borrowed from
	;; Scheme of course).
	;; Recurse in case there are nested begins.
	((eq? (car entry) 'begin)
	 (for-each (lambda (e) (/reader-process-with-loc! e loc))
		   (cdr entry)))
	;; Don't do pmacro-expansion for `define-pmacro'.
	;; ??? Singling out define-pmacro this way seems a bit odd.  The way to
	;; look at it, I guess, is to think of define-pmacro as (currently) the
	;; only "syntactic" command (it doesn't pre-evaluate its arguments).
	;; Defer pmacro-expansion for `if' too.
	((memq (car entry) '(define-pmacro if))
	 (location-property-set! entry loc)
	 (/reader-process-expanded-1! entry))
	(else
	 ;; First do pmacro expansion.
	 (let ((expansion (/reader-expand entry loc)))
	   (reader-process-expanded! expansion))))

  *UNSPECIFIED*
)

;; Read in and process FILE.
;;
;; It would be nice to get the line number of the beginning of the object,
;; but that's extra work, so for now we do the simple thing and use
;; port-line after we've read an entry.

(define (reader-read-file! file)
  (let ((readit (lambda ()
		  (let loop ((entry (read)))
		    (if (eof-object? entry)
			#t ;; done
			(begin
			  ;; ??? The location we pass here isn't ideal.
			  ;; Ideally we'd pass the start location of the
			  ;; expression, instead we currently pass the end
			  ;; location (it's easier).
			  ;; ??? Use source-properties of entry, and only if
			  ;; not present fall back on current-input-location.
			  (/reader-process-with-loc! entry (current-input-location #t))
			  (loop (read)))))))
	)

    (with-input-from-file file readit))

  *UNSPECIFIED*
)

;; Cpu data is recorded in an object of class <arch>.
;; This is necessary as we need to allow recording of multiple cpu descriptions
;; simultaneously.
;; Class <arch> is defined in mach.scm.

;; Global containing all data of the currently selected architecture.

(define CURRENT-ARCH #f)

;; `keep-mach' processing.

;; Return the currently selected cpu family.
;; If a specific cpu family has been selected, each machine that is kept must
;; be in that cpu family [so there's no ambiguity in the result].
;; This is a moderately expensive computation so use delay/force.

(define (current-cpu) (force (reader-current-cpu CURRENT-READER)))

;; Return a boolean indicating if CPU-NAME is to be kept.
;; ??? Currently this is always true.  Note that this doesn't necessarily apply
;; to machs in CPU-NAME.

(define (keep-cpu? cpu-name) #t)

;; Cover proc to set `keep-mach'.
;; MACH-NAME-LIST is a comma separated string of machines to keep and drop
;; (if prefixed with !).

(define (/keep-mach-set! mach-name-list)
  (let* ((mach-name-list (string-cut mach-name-list #\,))
	 (keep (find (lambda (name) (not (char=? (string-ref name 0) #\!)))
		     mach-name-list))
	 (drop (map (lambda (name) (string->symbol (string-drop 1 name)))
		    (find (lambda (name) (char=? (string-ref name 0) #\!))
			  mach-name-list))))
    (reader-set-keep-mach! CURRENT-READER
			   (cons (map string->symbol keep)
				 (map string->symbol drop)))
    ;; Reset current-cpu.
    (reader-set-current-cpu!
     CURRENT-READER
     (delay (let ((selected-machs (find (lambda (mach)
					  (keep-mach? (list (obj:name mach))))
					(current-mach-list))))
	      (if (= (length selected-machs) 0)
		  (error "no machs selected"))
	      (if (not (all-true? (map (lambda (mach)
					 (eq? (obj:name (mach-cpu mach))
					      (obj:name (mach-cpu (car selected-machs)))))
				       selected-machs)))
		  (error "machs from different cpu families selected"))
	      (mach-cpu (car selected-machs)))))

    *UNSPECIFIED*)
)

;; Validate the user-provided keep-mach list against the list of machs
;; specified in the .cpu file (in define-arch).

(define (keep-mach-validate!)
  (let ((mach-names (cons 'all (current-arch-mach-name-list)))
	(keep-mach (reader-keep-mach CURRENT-READER)))
    (for-each (lambda (mach)
		(if (not (memq mach mach-names))
		    (error "unknown mach to keep:" mach)))
	      (car keep-mach))
    (for-each (lambda (mach)
		(if (not (memq mach mach-names))
		    (error "unknown mach to drop:" mach)))
	      (cdr keep-mach))
    )
  *UNSPECIFIED*
)

;; Return #t if a machine in MACH-LIST, a list of symbols, is to be kept.
;; If any machine in MACH-LIST is to be kept, the result is #t.
;; If MACH-LIST is the empty list (no particular mach specified, thus the base
;; mach), the result is #t.

(define (keep-mach? mach-list)
  (if (null? mach-list)
      #t
      (let* ((keep-mach (reader-keep-mach CURRENT-READER))
	     (keep (cons 'base (car keep-mach)))
	     (drop (cdr keep-mach))
	     (keep? (map (lambda (m) (memq m keep)) mach-list))
	     (all? (memq 'all keep))
	     (drop? (map (lambda (m) (memq m drop)) mach-list)))
	(any-true? (map (lambda (k d)
			  ;; keep if K(ept) or ALL? and not D(ropped)
			  (->bool (and (or k all?) (not d))))
			keep? drop?))))
)

;; Return non-#f if the object containing ATLIST is to be kept.
;; OBJ is the container object or #f if there is none.
;; The object is kept if its attribute list specifies a `MACH' that is
;; kept (and not dropped) or does not have the `MACH' attribute (which means
;; it has the default value which means it's for use with all machines).

(define (keep-mach-atlist? atlist obj)
  ;; The MACH attribute is not created until the .cpu file is read in which
  ;; is too late for us [we will get called for builtin objects].
  ;; Thus we peek inside the attribute list directly.
  ;; ??? Maybe postpone creation of builtins until after define-arch?
  (let ((machs (atlist-attr-value-no-default atlist 'MACH obj)))
    (if (null? machs)
	#t
	(keep-mach? machs)))
)

;; Return a boolean indicating if the object containing ATLIST is to be kept.
;; OBJ is the container object or #f if there is none.
;; The object is kept if both its isa and its mach are kept.

(define (keep-atlist? atlist obj)
  (and (keep-mach-atlist? atlist obj)
       (keep-isa-atlist? atlist obj))
)

;; Return a boolean indicating if multiple cpu families are being kept.

(define (keep-multiple?)
  (let ((selected-machs (find (lambda (mach)
				(keep-mach? (list (obj:name mach))))
			      (current-mach-list))))
    (not (all-true? (map (lambda (mach)
			   (eq? (obj:name (mach-cpu mach))
				(obj:name (mach-cpu (car selected-machs)))))
			 selected-machs))))
)

;; Return a boolean indicating if everything is kept.

(define (keep-all?)
  (equal? (reader-keep-mach CURRENT-READER) /keep-all-machs)
)

;; Ensure all cpu families were kept, necessary for generating files that
;; encompass the entire architecture.

(define (assert-keep-all)
  (if (not (keep-all?))
      (error "no can do, all cpu families not selected"))
  *UNSPECIFIED*
)

;; Ensure exactly one cpu family was kept, necessary for generating files that
;; are specific to one cpu family.

(define (assert-keep-one)
  (if (keep-multiple?)
      (error "no can do, multiple cpu families selected"))
  *UNSPECIFIED*
)

;; `keep-isa' processing.

;; Cover proc to set `keep-isa'.
;; ISA-NAME-LIST is a comma separated string of isas to keep.
;; ??? We don't support the !drop notation of keep-mach processing.
;; Perhaps we should as otherwise there are two different styles the user
;; has to remember.  On the other hand, !drop support is moderately complicated,
;; and it can be added in an upward compatible manner later.

(define (/keep-isa-set! isa-name-list)
  (let ((isa-name-list (map string->symbol (string-cut isa-name-list #\,))))
    (reader-set-keep-isa! CURRENT-READER isa-name-list)
    )
  *UNSPECIFIED*
)

;; Validate the user-provided keep-isa list against the list of isas
;; specified in the .cpu file (in define-arch).

(define (keep-isa-validate!)
  (let ((isa-names (cons 'all (current-arch-isa-name-list)))
	(keep-isa (reader-keep-isa CURRENT-READER)))
    (for-each (lambda (isa)
		(if (not (memq isa isa-names))
		    (error "unknown isa to keep:" isa)))
	      keep-isa)
    )
  *UNSPECIFIED*
)

;; Return currently selected isa (there must be exactly one).

(define (current-isa)
  (let ((keep-isa (reader-keep-isa CURRENT-READER)))
    (if (equal? keep-isa '(all))
	(let ((isas (current-isa-list)))
	  (if (= (length isas) 1)
	      (car isas)
	      (error "multiple isas selected" keep-isa)))
	(if (= (length keep-isa) 1)
	    (current-isa-lookup (car keep-isa))
	    (error "multiple isas selected" keep-isa))))
)

;; Return #t if an isa in ISA-LIST, a list of symbols, is to be kept.
;; If any isa in ISA-LIST is to be kept, the result is #t.
;; If ISA-LIST is the empty list (no particular isa specified) use the default
;; isa.

(define (keep-isa? isa-list)
  ;; If unspecified, the default is the first one in the list.
  (if (null? isa-list)
      (set! isa-list (list (car (current-arch-isa-name-list)))))

  (let* ((keep (reader-keep-isa CURRENT-READER))
	 (keep? (map (lambda (i)
		       (or (memq i keep)
			   (memq 'all keep)))
		     isa-list)))
    (any-true? keep?))
)

;; Return #t if the object containing ATLIST is to be kept.
;; OBJ is the container object or #f if there is none.
;; The object is kept if its attribute list specifies an `ISA' that is
;; kept or does not have the `ISA' attribute (which means it has the default
;; value) and the default isa is being kept.

(define (keep-isa-atlist? atlist obj)
  (let ((isas (atlist-attr-value atlist 'ISA obj)))
    (keep-isa? isas))
)

;; Return non-#f if object OBJ is to be kept, according to its ISA attribute.

(define (keep-isa-obj? obj)
  (keep-isa-atlist? (obj-atlist obj) obj)
)

;; Return a boolean indicating if multiple isas are being kept.

(define (keep-isa-multiple?)
  (let ((keep (reader-keep-isa CURRENT-READER)))
    (or (> (length keep) 1)
	(and (memq 'all keep)
	     (> (length (current-arch-isa-name-list)) 1))))
)

;; Return list of isa names currently being kept.

(define (current-keep-isa-name-list)
  (reader-keep-isa CURRENT-READER)
)

;; Tracing support.
;; This is akin to the "logit" support, but is for specific things that
;; can be named (whereas logit support is based on a simple integer verbosity
;; level).

;;; Enable the specified tracing.
;;; TRACE-OPTIONS is a comma-separated list of things to trace.
;;;
;;; Currently supported tracing:
;;; commands - trace invocation of description file commands (e.g. define-insn)
;;; pmacros  - trace pmacro expansion
;;; all      - trace everything
;;;
;;; [If we later need to support disabling some tracing, one way is to
;;; recognize an "-" in front of an option.]

(define (/set-trace-options! trace-options)
  (let ((all (list "commands" "pmacros"))
	(requests (string-cut trace-options #\,)))
    (if (member "all" requests)
	(append! requests all))
    (for-each (lambda (item)
	      (cond ((string=? "commands" item)
		     (reader-set-trace-commands?! CURRENT-READER #t))
		    ((string=? "pmacros" item)
		     (reader-set-trace-pmacros?! CURRENT-READER #t))
		    ((string=? "all" item)
		     #t) ;; handled above
		    (else
		     (cgen-usage 'unknown (string-append "-t " item)
				 common-arguments))))
	      requests))

  *UNSPECIFIED*
)

;; Diagnostic support.

;;; Enable the specified diagnostics.
;;; DIAGNOSTIC-OPTIONS is a comma-separated list of things to trace.
;;;
;;; Currently supported diagnostics:
;;; iformat - issue diagnostics for iformat issues
;;; all - turn on all diagnostics
;;;
;;; [If we later need to support disabling some diagnostic, one way is to
;;; recognize an "-" in front of an option.]

(define (/set-diagnostic-options! diagnostic-options)
  (let ((all (list "iformat"))
	(requests (string-cut diagnostic-options #\,)))
    (if (member "all" requests)
	(append! requests all))
    (for-each (lambda (item)
	      (cond ((string=? "iformat" item)
		     (reader-set-verify-iformat?! CURRENT-READER #t))
		    ((string=? "all" item)
		     #t) ;; handled above
		    (else
		     (cgen-usage 'unknown (string-append "-w " item)
				 common-arguments))))
	      requests))

  *UNSPECIFIED*
)

;; If #f, treat reserved fields as operands and extract them with the insn.
;; Code can then be emitted in the extraction routines to validate them.
;; If #t, treat reserved fields as part of the opcode.
;; This complicates the decoding process as these fields have to be
;; checked too.
;; ??? Unimplemented.

(define option:reserved-as-opcode? #f)

;; Process options passed in on the command line.
;; OPTIONS is a space separated string of name=value values.
;; Each application is required to provide: option-init!, option-set!.

(define (set-cgen-options! options)
  (option-init!)
  (for-each (lambda (opt)
	      (if (null? opt)
		  #t ;; ignore extraneous spaces
		  (let ((name (string->symbol (car opt)))
			(value (cdr opt)))
		    (logit 1 "Setting option `" name "' to \""
			   (apply string-append value) "\".\n")
		    (option-set! name value))))
	    (map (lambda (opt) (string-cut opt #\=))
		 (string-cut options #\space)))
)

;; Application specific object creation support.
;;
;; Each entry in the .cpu file has a basic container class.
;; Each application adds functionality by subclassing the container
;; and registering with set-for-new! the proper class to create.
;; ??? Not sure this is the best way to handle this, but it does keep the
;; complexity down while not requiring as dynamic a language as I had before.
;; ??? Class local variables would provide a more efficient way to do this.
;; Assuming one wants to continue on this route.

(define /cpu-new-class-list nil)

(define (set-for-new! parent child)
  (set! /cpu-new-class-list (acons parent child /cpu-new-class-list))
)

;; Lookup the class registered with set-for-new!
;; If none registered, return PARENT.

(define (lookup-for-new parent)
  (let ((child (assq-ref /cpu-new-class-list parent)))
    (if child
	child
	parent))
)

;; .cpu file loader support

;; #t if an error was found (but processing continued)
(define /continuable-error-found? #f)

;; Initialize a new <reader> object.
;; This doesn't add cgen-specific commands, leaving each element (ifield,
;; hardware, etc.) to add their own.
;; The "result" is stored in global CURRENT-READER.

(define (/init-reader!)
  (set! CURRENT-READER (new <reader>))

  (set! /CGEN-RTL-VERSION /default-rtl-version)

  (set! /continuable-error-found? #f)

  (reader-add-command! 'define-rtl-version
		       "Specify the RTL version being used.\n"
		       nil '(major minor) /cmd-define-rtl-version)

  (reader-add-command! 'include
		       "Include a file.\n"
		       nil '(file) /cmd-include)
  (reader-add-command! 'if
		       "(if test then . else)\n"
		       nil '(test then . else) /cmd-if)

  ;; Rather than add cgen-internal specific stuff to pmacros.scm, we create
  ;; the pmacro commands here.
  (pmacros-init! /default-rtl-version)
  (reader-add-command! 'define-pmacro
		       "\
Define a preprocessor-style macro.
"
		       nil '(name arg1 . arg-rest) define-pmacro)

  *UNSPECIFIED*
)

;; Called at the end of .cpu file loading.

(define (/finish-reader! file)
  (if /continuable-error-found?
      (error (string-append "Error loading " file)))
  *UNSPECIFIED*
)

;; Prepare to parse a .cpu file.
;; This initializes the application independent tables.
;; KEEP-MACH specifies what machs to keep.
;; KEEP-ISA specifies what isas to keep.
;; OPTIONS is a list of options to control code generation.
;; The values are application dependent.

(define (/init-parse-cpu! keep-mach keep-isa options)
  (set! /cpu-new-class-list nil)

  (set! CURRENT-ARCH (new <arch>))
  (/keep-mach-set! keep-mach)
  (/keep-isa-set! keep-isa)
  (set-cgen-options! options)

  ;; The order here is important.
  (arch-init!) ;; Must be done first.
  (enum-init!)
  (attr-init!)
  (types-init!)
  (mach-init!)
  (model-init!)
  (mode-init!)
  (ifield-init!)
  (hardware-init!)
  (operand-init!)
  (insn-init!)
  (minsn-init!)
  (rtl-init!)
  (rtl-c-init!)
  (utils-init!)

  *UNSPECIFIED*
)

;; Install any builtin objects.
;; This is deferred until define-arch is read.
;; One reason is that attributes MACH and ISA don't exist until then.

(define (reader-install-builtin!)
  ;; The order here is important.
  (attr-builtin!)
  (enum-builtin!)
  (mode-builtin!)
  (ifield-builtin!)
  (hardware-builtin!)
  (operand-builtin!)
  ;; This is mainly for the insn attributes.
  (insn-builtin!)
  (rtl-builtin!)
  *UNSPECIFIED*
)

;; Do anything necessary for the application independent parts after parsing
;; a .cpu file.
;; The lists get cons'd in reverse order.  One thing this does is change them
;; back to file order, it makes things easier for the human viewer.

(define (/finish-parse-cpu!)
  ;; The order here is generally the reverse of init-parse-cpu!.
  (rtl-finish!)
  (minsn-finish!)
  (insn-finish!)
  (operand-finish!)
  (hardware-finish!)
  (ifield-finish!)
  (mode-finish!)
  (model-finish!)
  (mach-finish!)
  (types-finish!)
  (attr-finish!)
  (enum-finish!)
  (arch-finish!) ;; Must be done last.

  *UNSPECIFIED*
)

;; Perform a global error checking pass after the .cpu file has been read in.

(define (/global-error-checks)
  ;; ??? None yet.
  ;; TODO:
  ;; - all hardware elements with same name must have same rank and
  ;;   compatible modes (which for now means same float mode or all int modes)
  #f
)

;; .cpu file include mechanism
;; If FILE is not an absolute path, prepend ARCH-PATH.

(define (/cmd-include file)
  (let ((full-path (if (eq? (string-ref file 0) #\/)
		       file
		       (string-append arch-path "/" file))))
    (logit 1 "Including file " full-path " ...\n")
    (reader-read-file! full-path)
    (logit 2 "Resuming previous file ...\n"))
  *UNSPECIFIED*
)

;; Version of `if' invokable at the top level of a description file.
;; This is a work-in-progress.  Its presence in the description file is ok,
;; but the implementation will need to evolve.

(define (/cmd-if test then . else)
  (if (> (length else) 1)
      (parse-error #f
		   "wrong number of arguments to `if'"
		   (cons 'if (cons test (cons then else)))))

  (let ((etest (/reader-expand test (or (location-property test)
					(unspecified-location)))))

    ;; ??? rtx-eval etest
    (if (or (not (pair? etest))
	    (not (memq (car etest)
		       '(keep-isa? keep-mach? application-is? rtl-version-equal? rtl-version-at-least?))))
	(parse-error #f
		     "only (if (keep-mach?|keep-isa?|application-is?|rtl-version-equal?|rtl-version-at-least? ...) ...) are currently supported"
		     etest))

    (let ((do-then
	   (case (car etest)
	     ((keep-isa?) (keep-isa? (cadr etest)))
	     ((keep-mach?) (keep-mach? (cadr etest)))
	     ((application-is?) (eq? APPLICATION (cadr etest)))
	     ((rtl-version-equal?)
	      (if (/rtl-version-valid? (cdr etest))
		  (rtl-version-equal? (cadr etest) (caddr etest))
		  (parse-error #f "invalid rtl version" (cdr etest))))
	     ((rtl-version-at-least?)
	      (if (/rtl-version-valid? (cdr etest))
		  (rtl-version-at-least? (cadr etest) (caddr etest))
		  (parse-error #f "invalid rtl version" (cdr etest)))))))

      (if do-then
	  (begin
	    (logit 3 "Processing then clause: " then "\n")
	    (reader-process! then))
	  (if (null? else)
	      *UNSPECIFIED*
	      (begin
		(logit 3 "Processing else clause: " (car else) "\n")
		(reader-process! (car else)))))))
)

;; Top level routine for loading .cpu files.
;; FILE is the name of the .cpu file to load.
;; KEEP-MACH is a string of comma separated machines to keep
;; (or not keep if prefixed with !).
;; KEEP-ISA is a string of comma separated isas to keep.
;; OPTIONS is the OPTIONS argument to -init-parse-cpu!.
;; TRACE-OPTIONS is a random list of things to trace.
;; DIAGNOSTIC-OPTIONS is a random list of things to warn/error about.
;; APP-INITER! is an application specific zero argument proc (thunk)
;; to call after -init-parse-cpu!
;; APP-FINISHER! is an application specific zero argument proc to call after
;; -finish-parse-cpu!
;; ANALYZER! is a zero argument proc to call after loading the .cpu file.
;; It is expected to set up various tables and things useful for the application
;; in question.
;;
;; This function isn't local because it's used by dev.scm.

(define (cpu-load file keep-mach keep-isa options
		  trace-options diagnostic-options
		  app-initer! app-finisher! analyzer!)
  (/init-reader!)
  (/init-parse-cpu! keep-mach keep-isa options)
  (/set-trace-options! trace-options)
  (/set-diagnostic-options! diagnostic-options)
  (app-initer!)
  (logit 1 "Loading cpu description " file " ...\n")
  (logit 1 "machs:   " keep-mach "\n")
  (logit 1 "isas:    " keep-isa "\n")
  (logit 1 "options: " options "\n")
  (logit 1 "trace:   " trace-options "\n")
  (logit 1 "diags:   " diagnostic-options "\n")
  (set! arch-path (dirname file))
  (reader-read-file! file)
  (/finish-parse-cpu!)
  (/finish-reader! file)
  (logit 1 "Processing cpu description " file " ...\n")
  (app-finisher!)
  (/global-error-checks)
  (analyzer!)
  *UNSPECIFIED*
)

;; Argument parsing utilities.

;; Generate a usage message.
;; ERRTYPE is one of 'help, 'unknown, 'missing.
;; OPTION is the option that had the error or "" if ERRTYPE is 'help.

(define (cgen-usage errtype option arguments)
  (let ((cep (current-error-port)))
    (case errtype
      ((help) #f)
      ((unknown) (display (string-append "Unknown option: " option "\n") cep))
      ((missing) (display (string-append "Missing argument: " option "\n") cep))
      (else (display "Unknown error!\n" cep)))
    (display "Usage: cgen arguments ...\n" cep)
    (for-each (lambda (arg)
		(display (string-append
			  (let ((arg-str (string-append (car arg) " "
							(or (cadr arg) ""))))
			    (if (< (string-length arg-str) 16)
				(string-take 16 arg-str)
				arg-str))
			  "  - " (caddr arg)
			  (apply string-append
				 (map (lambda (text)
					(string-append "\n"
						       (string-take 20 "")
						       text))
				      (cdddr arg)))
			  "\n")
			 cep))
	      arguments)
    (display "...\n" cep)
    (case errtype
      ((help) (quit 0))
      ((unknown missing) (quit 1))
      (else (quit 2))))
)

;; Poor man's getopt.
;; [We don't know where to find the real one until we've parsed the args,
;; and this isn't something we need to get too fancy about anyways.]
;; The result is always ((a . b) . c).
;; If the argument is valid, the result is ((opt-spec . arg) . remaining-argv),
;; or (('unknown . option) . remaining-argv) if `option' isn't recognized,
;; or (('missing . option) . remaining argv) if `option' is missing a required
;; argument,
;; or ((#f . #f) . #f) if there are no more arguments.
;; OPT-SPEC is a list of option specs.
;; Each element is an alist of at least 3 elements: option argument help-text.
;; `option' is a string or symbol naming the option.  e.g. -a, --help, "-i".
;; symbols are supported for backward compatibility, -i is a complex number.
;; `argument' is a string naming the argument or #f if the option takes no
;; arguments.
;; `help-text' is a string that is printed with the usage information.
;; Elements beyond `help-text' are ignored.

(define (/getopt argv opt-spec)
  (if (null? argv)
      (cons (cons #f #f) #f)
      (let ((opt (assoc (car argv) opt-spec)))
	(cond ((not opt) (cons (cons 'unknown (car argv)) (cdr argv)))
	      ((and (cadr opt) (null? (cdr argv)))
	       (cons (cons 'missing (car argv)) (cdr argv)))
	      ((cadr opt) (cons (cons opt (cadr argv)) (cddr argv)))
	      (else ;; must be option that doesn't take an argument
	       (cons (cons opt #f) (cdr argv))))))
)

;; Return (cadr args) or print a pretty error message if not possible.

(define (option-arg args)
  (if (and (pair? args) (pair? (cdr args)))
      (cadr args)
      (parse-error (make-prefix-context "option processing")
		   "missing argument to"
		   (car args)))
)

;; List of common arguments.
;;
;; ??? Another useful arg would be one that says "do file generation with
;; arguments specified up til now, then continue with next batch of args".

(define common-arguments
  '(("-a" "arch-file" "specify path of .cpu file to load")
    ("-b" #f          "use debugging evaluator, for backtraces")
    ("-d" #f          "start interactive debugging session")
    ("-f" "flags"     "specify a set of flags to control code generation")
    ("-h" #f          "print usage information")
    ("--help" #f      "print usage information")
    ("-i" "isa-list"  "specify isa-list entries to keep")
    ("-m" "mach-list" "specify mach-list entries to keep")
    ("-s" "srcdir"    "set srcdir")
    ("-t" "trace-options" "specify list of things to trace"
                       "Options:"
                       "commands - trace cgen commands (e.g. define-insn)"
                       "pmacros  - trace pmacro expansion"
		       "all      - trace everything")
    ("-v" #f          "increment verbosity level")
    ("-w" "diagnostic-options" "specify list of things to issue diagnostics about"
                       "Options:"
                       "iformat - verify instruction formats are valid"
		       "all     - turn on all diagnostics")

    ("--version" #f   "print version info")
    )
)

;; Default place to look.
;; This gets overridden to point to the directory of the loaded .cpu file.
;; ??? Ideally this would be local to this file.

(define arch-path (string-append srcdir "/cpu"))

;; Accessors for application option specs

(define (opt-get-first-pass opt)
  (or (list-ref opt 3) (lambda args #f)))
(define (opt-get-second-pass opt)
  (or (list-ref opt 4) (lambda args #f)))

;; Parse options and call generators.
;; ARGS is a #:keyword delimited list of arguments.
;; #:app-name name
;; #:arg-spec optspec ;; FIXME: rename to #:opt-spec
;; #:init init-routine
;; #:finish finish-routine
;; #:analyze analysis-routine
;; #:argv command-line-arguments
;;
;; ARGSPEC is a list of (option option-arg comment option-handler) elements.
;; OPTION-HANDLER is either (lambda () ...) or (lambda (arg) ...) and
;; processes the option.

(define /cgen
  (lambda args
    (let ((app-name "unknown")
	  (opt-spec nil)
	  (app-init! (lambda () #f))
	  (app-finish! (lambda () #f))
	  (app-analyze! (lambda () #f))
	  (argv (list "cgen"))
	  )
      (let loop ((args args))
	(if (not (null? args))
	    (case (car args)
	      ((#:app-name) (begin
			      (set! app-name (option-arg args))
			      (loop (cddr args))))
	      ((#:arg-spec) (begin
			      (set! opt-spec (option-arg args))
			      (loop (cddr args))))
	      ((#:init) (begin
			  (set! app-init! (option-arg args))
			  (loop (cddr args))))
	      ((#:finish) (begin
			    (set! app-finish! (option-arg args))
			    (loop (cddr args))))
	      ((#:analyze) (begin
			     (set! app-analyze! (option-arg args))
			     (loop (cddr args))))
	      ((#:argv) (begin
			  (set! argv (option-arg args))
			  (loop (cddr args))))
	      (else (error "cgen: unknown argument" (car args))))))

      ;; ARGS has been processed, now we can process ARGV.

      (let (
	    (opt-spec (append common-arguments opt-spec))
	    (app-args nil)    ;; application's args are queued here
	    (repl? #f)
	    (arch-file #f)
	    (keep-mach "all") ;; default is all machs
	    (keep-isa "all")  ;; default is all isas
	    (flags "")
	    (moreopts? #t)
	    (debugging #f)    ;; default is off, for speed
	    (trace-options "")
	    (diagnostic-options "")
	    (cep (current-error-port))
	    (str=? string=?)
	    )

	(let loop ((argv (cdr argv)))
	  (let* ((new-argv (/getopt argv opt-spec))
		 (opt (caar new-argv))
		 (arg (cdar new-argv)))
	    (case opt
	      ((#f) (set! moreopts? #f))
	      ((unknown) (cgen-usage 'unknown arg opt-spec))
	      ((missing) (cgen-usage 'missing arg opt-spec))
	      (else
	       (cond ((str=? "-a" (car opt))
		      (set! arch-file arg)
		      )
		     ((str=? "-b" (car opt))
		      (set! debugging #t)
		      )
		     ((str=? "-d" (car opt))
		      (let ((prompt (string-append "cgen-" app-name "> ")))
			(set! repl? #t)
			(set-repl-prompt! prompt)
			(if (feature? 'readline)
			    (set-readline-prompt! prompt))
			))
		     ((str=? "-f" (car opt))
		      (set! flags arg)
		      )
		     ((str=? "-h" (car opt))
		      (cgen-usage 'help "" opt-spec)
		      )
		     ((str=? "--help" (car opt))
		      (cgen-usage 'help "" opt-spec)
		      )
		     ((str=? "-i" (car opt))
		      (set! keep-isa arg)
		      )
		     ((str=? "-m" (car opt))
		      (set! keep-mach arg)
		      )
		     ((str=? "-s" (car opt))
		      #f ;; ignore, already processed by caller
		      )
		     ((str=? "-t" (car opt))
		      (set! trace-options arg)
		      )
		     ((str=? "-v" (car opt))
		      (verbose-inc!)
		      )
		     ((str=? "-w" (car opt))
		      (set! diagnostic-options arg)
		      )
		     ((str=? "--version" (car opt))
		      (begin
			(display "Cpu tools GENerator version ")
			(display (cgen-major))
			(display ".")
			(display (cgen-minor))
			(display ".")
			(display (cgen-fixlevel))
			(newline)
			(display "RTL version ")
			(display (cgen-rtl-major))
			(display ".")
			(display (cgen-rtl-minor))
			(newline)
			(quit 0)
			))
		     ;; Else this is an application specific option.
		     (else
		      ;; Record it for later processing.  Note that they're
		      ;; recorded in reverse order (easier).  This is undone
		      ;; later.
		      (set! app-args (acons opt arg app-args)))
		     )))
	    (if moreopts? (loop (cdr new-argv)))
	    )
	  ) ;; end of loop

	;; All arguments have been parsed.

	(cgen-call-with-debugging
	 debugging
	 (lambda ()

	   (if (not arch-file)
	       (error "-a option missing, no architecture specified"))

	   (if repl?
	       (debug-repl nil))

	   (cpu-load arch-file
		     keep-mach keep-isa flags
		     trace-options diagnostic-options
		     app-init! app-finish! app-analyze!)

	   ;; Start another repl loop if -d.
	   ;; Awkward.  Both places are useful, though this is more useful.
	   (if repl?
	       (debug-repl nil))

	   ;; Done with processing the arguments.  Application arguments
	   ;; are processed in two passes.  This is because the app may
	   ;; have arguments that specify things that affect file
	   ;; generation (e.g. to specify another input file) and we
	   ;; don't want to require an ordering of the options.
	   (for-each (lambda (opt-arg)
		       (let ((opt (car opt-arg))
			     (arg (cdr opt-arg)))
			 (if (cadr opt)
			     ((opt-get-first-pass opt) arg)
			     ((opt-get-first-pass opt)))))
		     (reverse app-args))

	   (for-each (lambda (opt-arg)
		       (let ((opt (car opt-arg))
			     (arg (cdr opt-arg)))
			 (if (cadr opt)
			     ((opt-get-second-pass opt) arg)
			     ((opt-get-second-pass opt)))))
		     (reverse app-args))))
	)
      )
    #f) ;; end of lambda
)

;; Main entry point called by application file generators.

(define cgen
  (lambda args
    (cgen-debugging-stack-start /cgen args))
)
@


1.45
log
@	* read.scm (rtl-version-at-least?): Fix typo.
@
text
@d97 5
a101 1
(define /supported-rtl-versions '((0 7) (0 8)))
d113 6
a118 2
	(logit 1 "Setting RTL version to " major "." minor " ...\n"))
    (set! /CGEN-RTL-VERSION new-version))
d369 9
a377 1
;; Process a macro-expanded entry.
d382 3
d430 1
a430 1
;; Process 1 or more macro-expanded entries.
a432 3
;; NOTE: This is "public" so the .eval pmacro can use it.
;; This is also used by /cmd-if.

d450 8
d461 23
a483 14
(define (/reader-process! entry loc)
  (if (not (form? entry))
      (parse-error loc "improperly formed entry" entry))

  ;; First do macro expansion, but not if define-pmacro of course.
  ;; ??? Singling out define-pmacro this way seems a bit odd.  The way to look
  ;; at it, I guess, is to think of define-pmacro as (currently) the only
  ;; "syntactic" command (it doesn't pre-evaluate its arguments).
  (let ((expansion (if (eq? (car entry) 'define-pmacro)
		       (begin (location-property-set! entry loc) entry)
		       (if (reader-trace-pmacros? CURRENT-READER)
			   (pmacro-trace entry loc)
			   (pmacro-expand entry loc)))))
    (reader-process-expanded! expansion))
d506 1
a506 1
			  (/reader-process! entry (current-input-location #t))
d523 1
a523 1

d914 1
a914 1
  (pmacros-init!)
d1041 35
a1075 25
  ;; ??? rtx-eval test
  (if (or (not (pair? test))
	  (not (memq (car test) '(keep-isa? keep-mach? application-is?))))
      (parse-error #f
		   "only (if (keep-mach?|keep-isa?|application-is? ...) ...) are currently supported"
		   test))
  (case (car test)
    ((keep-isa?)
     (if (keep-isa? (cadr test))
	 (reader-process-expanded! then)
	 (if (null? else)
	     #f
	     (reader-process-expanded! (car else)))))
    ((keep-mach?)
     (if (keep-mach? (cadr test))
	 (reader-process-expanded! then)
	 (if (null? else)
	     #f
	     (reader-process-expanded! (car else)))))
    ((application-is?)
     (if (eq? APPLICATION (cadr test))
	 (reader-process-expanded! then)
	 (if (null? else)
	     #f
	     (reader-process-expanded! (car else))))))
@


1.44
log
@	* read.scm: Follow commenting convention.
@
text
@d87 1
a87 1
	(rminor (cgen-rtl-major)))
@


1.43
log
@	* desc-cpu.scm (cgen-desc.h): Don't print virtual enums.
	* sid-cpu.scm (cgen-desc.h): Ditto.
	* enum.scm (enum-builtin!): New function.
	* read.scm (reader-install-builtin!): Call it.
	* rtl-c.scm (s-convop): Delete, replaced with ...
	(s-int-convop, s-float-convop): ... new fns.
	(ext, zext, trunc): Update.
	(fext, ftrunc, float, ufloat, fix, ufix): Update.
	* rtx-funcs.scm (fext, ftrunc, float, ufloat, fix, ufix): New parameter
	`how'.
	* cpu/mep-fmax.cpu (fcvtsw): Update.
	* cpu/sh.cpu (h-fsd, h-fmov): Update.
	* doc/rtl.texi (float-convop): Update.

	* frv.cpu (floating-point-conversion): Update call to fp conv op.
	(floating-point-dual-conversion, ne-floating-point-dual-conversion,
	conditional-floating-point-conversion, ne-floating-point-conversion,
	float-parallel-mul-add-double-semantics): Ditto.
@
text
@d1 61
a61 61
; Top level file for reading and recording .cpu file contents.
; Copyright (C) 2000, 2001, 2006, 2009, 2010 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.

; This file [and its subordinates] contain no C code (well, as little as
; possible).  That lives at a layer above us.

; A .cpu file consists of several sections:
;
; - basic definitions (e.g. cpu variants, word size, endianness, etc.)
; - enums (enums are used throughout so by convention there is a special
;   section in which they're defined)
; - attributes
; - instruction fields and formats
; - hardware descriptions (e.g. registers, allowable immediate values)
; - model descriptions (e.g. pipelines, latencies, etc.)
; - instruction operands (mapping of insn fields to associated hardware)
; - instruction definitions
; - macro instruction definitions

; TODO:
; - memory access, layout, etc.
; - floating point quirks
; - ability to describe an ABI
; - anything else that comes along

; Notes:
; - by convention most objects are subclasses of <ident> (having name, comment,
;   and attrs elements and they are the first three elements of any .cpu file
;   entry

; Guidelines:
; - Try to conform to R5RS, try to limit guile-ness.
;   The current code is undoubtedly off in many places.

; Conventions:
; [I want there to be a plethora of conventions and I want them strictly
; adhered to.  ??? There's probably a few violations here and there.
; No big deal - fix them!]
; These conventions are subject to revision.
;
; - procs/vars local to a file are named "-foo"
; - only routines that emit application code begin with "gen-"
; - symbols beginning with "c-" are either variables containing C code
;   or procedures that generate C code, similarily for C++ and "c++-"
; - variables containing C code begin with "c-"
; - only routines that emit an entire file begin with "cgen-"
; - all .cpu file elements shall have -foo-parse and -foo-read procedures
; - global vars containing class definitions shall be named "<class-name>"
; - procs related to a particular class shall be named "class-name-proc-name",
;   class-name may be abbreviated
; - procs that test whether something is an object of a particular class
;   shall be named "class-name?"
; - in keeping with Scheme conventions, predicates shall have a "?" suffix
; - in keeping with Scheme conventions, methods and procedures that modify an
;   argument or have other side effects shall have a "!" suffix,
;   usually these procs return "*UNSPECIFIED*"
; - all -foo-parse,parse-foo procs shall have `context' as the first arg
;   [FIXME: not all such procs have been converted]
; - stay away from non-portable C symbols.
d63 1
a63 1
; Variables representing misc. global constants.
d65 2
a66 2
; A list of three numbers designating the cgen version: major minor fixlevel.
; The "50" is a generic indicator that we're between 1.1 and 1.2.
d72 3
a74 3
; A list of two numbers designating the description language version.
; Note that this is different from /CGEN-VERSION.
; See section "RTL Versions" of the docs.
d113 2
a114 2
; Which application is in use (UNKNOWN, DESC, OPCODES, SIMULATOR, ???).
; This is mostly for descriptive purposes.
d123 1
a123 1
; Used to pretty-print debugging messages.
d125 1
a125 1
; Used by pretty-print.
d153 7
a159 7
; Reader state data.
; All state regarding the reading of a .cpu file is kept in an object of
; class <reader>.

; Class to record info for each top-level `command' (for lack of a better
; word) in the description file.
; Top level commands are things like define-*.
d165 1
a165 1
		; argument spec to `lambda'
d167 1
a167 1
		; lambda that processes the entry
d176 1
a176 1
; Return help text for COMMAND.
d186 2
a187 2
; A pair of two lists: machs to keep, machs to drop.
; The default is "keep all machs", "drop none".
d191 1
a191 1
; Main reader state class.
d197 8
a204 8
	       ; Selected machs to keep.
	       ; A pair of two lists: the car lists the machs to keep, the cdr
	       ; lists the machs to drop.  Two special entries are `all' and
	       ; `base'.  Both are only valid in the keep list.  `base' is a
	       ; place holder for objects that are common to all machine
	       ; variants in the architecture, it is the default value of the
	       ; MACH attribute.  If `all' is present the drop list is still
	       ; processed.
d207 1
a207 1
	       ; Selected isas to keep or `all'.
d210 1
a210 1
	       ; Boolean indicating if command tracing is on.
d213 1
a213 1
	       ; Boolean indicating if pmacro tracing is on.
d216 1
a216 1
	       ; Issue diagnostics for instruction format issues.
d219 3
a221 3
	       ; Currently select cpu family, computed from `keep-mach'.
	       ; Some applications don't care, and this is moderately
	       ; expensive to compute so we use delay/force.
d224 3
a226 3
	       ; Associative list of file entry commands
	       ; (e.g. define-insn, etc.).
	       ; Each entry is (name . command-object).
d229 3
a231 3
	       ; The current source location.
	       ; This is recorded here by the higher level reader and is
	       ; fetched by commands as necessary.
d237 1
a237 1
; Accessors.
d260 1
a260 1
; Reader state for current .cpu file.
d264 2
a265 2
; Return the current source location in readable form.
; FIXME: Currently unused, keep for reference for awhile.
d350 4
a353 4
; Return the current source location.
;
; If CURRENT-READER is uninitialized, return "unspecified" location.
; This is done so that things like define-pmacro work in interactive mode.
d361 1
a361 1
; Process a macro-expanded entry.
d434 2
a435 2
; Process file entry ENTRY.
; LOC is a <location> object for ENTRY.
d441 4
a444 4
  ; First do macro expansion, but not if define-pmacro of course.
  ; ??? Singling out define-pmacro this way seems a bit odd.  The way to look
  ; at it, I guess, is to think of define-pmacro as (currently) the only
  ; "syntactic" command (it doesn't pre-evaluate its arguments).
d455 5
a459 5
; Read in and process FILE.
;
; It would be nice to get the line number of the beginning of the object,
; but that's extra work, so for now we do the simple thing and use
; port-line after we've read an entry.
d465 1
a465 1
			#t ; done
d482 4
a485 4
; Cpu data is recorded in an object of class <arch>.
; This is necessary as we need to allow recording of multiple cpu descriptions
; simultaneously.
; Class <arch> is defined in mach.scm.
d487 1
a487 1
; Global containing all data of the currently selected architecture.
d491 1
a491 1
; `keep-mach' processing.
d493 4
a496 4
; Return the currently selected cpu family.
; If a specific cpu family has been selected, each machine that is kept must
; be in that cpu family [so there's no ambiguity in the result].
; This is a moderately expensive computation so use delay/force.
d500 3
a502 3
; Return a boolean indicating if CPU-NAME is to be kept.
; ??? Currently this is always true.  Note that this doesn't necessarily apply
; to machs in CPU-NAME.
d506 3
a508 3
; Cover proc to set `keep-mach'.
; MACH-NAME-LIST is a comma separated string of machines to keep and drop
; (if prefixed with !).
d520 1
a520 1
    ; Reset current-cpu.
d538 2
a539 2
; Validate the user-provided keep-mach list against the list of machs
; specified in the .cpu file (in define-arch).
d556 4
a559 4
; Return #t if a machine in MACH-LIST, a list of symbols, is to be kept.
; If any machine in MACH-LIST is to be kept, the result is #t.
; If MACH-LIST is the empty list (no particular mach specified, thus the base
; mach), the result is #t.
d571 1
a571 1
			  ; keep if K(ept) or ALL? and not D(ropped)
d576 5
a580 5
; Return non-#f if the object containing ATLIST is to be kept.
; OBJ is the container object or #f if there is none.
; The object is kept if its attribute list specifies a `MACH' that is
; kept (and not dropped) or does not have the `MACH' attribute (which means
; it has the default value which means it's for use with all machines).
d583 4
a586 4
  ; The MACH attribute is not created until the .cpu file is read in which
  ; is too late for us [we will get called for builtin objects].
  ; Thus we peek inside the attribute list directly.
  ; ??? Maybe postpone creation of builtins until after define-arch?
d593 3
a595 3
; Return a boolean indicating if the object containing ATLIST is to be kept.
; OBJ is the container object or #f if there is none.
; The object is kept if both its isa and its mach are kept.
d602 1
a602 1
; Return a boolean indicating if multiple cpu families are being kept.
d614 1
a614 1
; Return a boolean indicating if everything is kept.
d620 2
a621 2
; Ensure all cpu families were kept, necessary for generating files that
; encompass the entire architecture.
d629 2
a630 2
; Ensure exactly one cpu family was kept, necessary for generating files that
; are specific to one cpu family.
d638 1
a638 1
; `keep-isa' processing.
d640 6
a645 6
; Cover proc to set `keep-isa'.
; ISA-NAME-LIST is a comma separated string of isas to keep.
; ??? We don't support the !drop notation of keep-mach processing.
; Perhaps we should as otherwise there are two different styles the user
; has to remember.  On the other hand, !drop support is moderately complicated,
; and it can be added in an upward compatible manner later.
d654 2
a655 2
; Validate the user-provided keep-isa list against the list of isas
; specified in the .cpu file (in define-arch).
d668 1
a668 1
; Return currently selected isa (there must be exactly one).
d682 4
a685 4
; Return #t if an isa in ISA-LIST, a list of symbols, is to be kept.
; If any isa in ISA-LIST is to be kept, the result is #t.
; If ISA-LIST is the empty list (no particular isa specified) use the default
; isa.
d700 5
a704 5
; Return #t if the object containing ATLIST is to be kept.
; OBJ is the container object or #f if there is none.
; The object is kept if its attribute list specifies an `ISA' that is
; kept or does not have the `ISA' attribute (which means it has the default
; value) and the default isa is being kept.
d711 1
a711 1
; Return non-#f if object OBJ is to be kept, according to its ISA attribute.
d717 1
a717 1
; Return a boolean indicating if multiple isas are being kept.
d726 1
a726 1
; Return list of isa names currently being kept.
d798 6
a803 6
; If #f, treat reserved fields as operands and extract them with the insn.
; Code can then be emitted in the extraction routines to validate them.
; If #t, treat reserved fields as part of the opcode.
; This complicates the decoding process as these fields have to be
; checked too.
; ??? Unimplemented.
d807 3
a809 3
; Process options passed in on the command line.
; OPTIONS is a space separated string of name=value values.
; Each application is required to provide: option-init!, option-set!.
d815 1
a815 1
		  #t ; ignore extraneous spaces
d825 9
a833 9
; Application specific object creation support.
;
; Each entry in the .cpu file has a basic container class.
; Each application adds functionality by subclassing the container
; and registering with set-for-new! the proper class to create.
; ??? Not sure this is the best way to handle this, but it does keep the
; complexity down while not requiring as dynamic a language as I had before.
; ??? Class local variables would provide a more efficient way to do this.
; Assuming one wants to continue on this route.
d841 2
a842 2
; Lookup the class registered with set-for-new!
; If none registered, return PARENT.
d851 1
a851 1
; .cpu file loader support
d879 2
a880 2
  ; Rather than add cgen-internal specific stuff to pmacros.scm, we create
  ; the pmacro commands here.
d899 6
a904 6
; Prepare to parse a .cpu file.
; This initializes the application independent tables.
; KEEP-MACH specifies what machs to keep.
; KEEP-ISA specifies what isas to keep.
; OPTIONS is a list of options to control code generation.
; The values are application dependent.
d914 2
a915 2
  ; The order here is important.
  (arch-init!) ; Must be done first.
d934 3
a936 3
; Install any builtin objects.
; This is deferred until define-arch is read.
; One reason is that attributes MACH and ISA don't exist until then.
d939 1
a939 1
  ; The order here is important.
d946 1
a946 1
  ; This is mainly for the insn attributes.
d952 4
a955 4
; Do anything necessary for the application independent parts after parsing
; a .cpu file.
; The lists get cons'd in reverse order.  One thing this does is change them
; back to file order, it makes things easier for the human viewer.
d958 1
a958 1
  ; The order here is generally the reverse of init-parse-cpu!.
d971 1
a971 1
  (arch-finish!) ; Must be done last.
d976 1
a976 1
; Perform a global error checking pass after the .cpu file has been read in.
d979 4
a982 4
  ; ??? None yet.
  ; TODO:
  ; - all hardware elements with same name must have same rank and
  ;   compatible modes (which for now means same float mode or all int modes)
d999 3
a1001 3
; Version of `if' invokable at the top level of a description file.
; This is a work-in-progress.  Its presence in the description file is ok,
; but the implementation will need to evolve.
d1008 1
a1008 1
  ; ??? rtx-eval test
d1035 17
a1051 17
; Top level routine for loading .cpu files.
; FILE is the name of the .cpu file to load.
; KEEP-MACH is a string of comma separated machines to keep
; (or not keep if prefixed with !).
; KEEP-ISA is a string of comma separated isas to keep.
; OPTIONS is the OPTIONS argument to -init-parse-cpu!.
; TRACE-OPTIONS is a random list of things to trace.
; DIAGNOSTIC-OPTIONS is a random list of things to warn/error about.
; APP-INITER! is an application specific zero argument proc (thunk)
; to call after -init-parse-cpu!
; APP-FINISHER! is an application specific zero argument proc to call after
; -finish-parse-cpu!
; ANALYZER! is a zero argument proc to call after loading the .cpu file.
; It is expected to set up various tables and things useful for the application
; in question.
;
; This function isn't local because it's used by dev.scm.
d1078 1
a1078 1
; Argument parsing utilities.
d1080 3
a1082 3
; Generate a usage message.
; ERRTYPE is one of 'help, 'unknown, 'missing.
; OPTION is the option that had the error or "" if ERRTYPE is 'help.
d1116 17
a1132 17
; Poor man's getopt.
; [We don't know where to find the real one until we've parsed the args,
; and this isn't something we need to get too fancy about anyways.]
; The result is always ((a . b) . c).
; If the argument is valid, the result is ((opt-spec . arg) . remaining-argv),
; or (('unknown . option) . remaining-argv) if `option' isn't recognized,
; or (('missing . option) . remaining argv) if `option' is missing a required
; argument,
; or ((#f . #f) . #f) if there are no more arguments.
; OPT-SPEC is a list of option specs.
; Each element is an alist of at least 3 elements: option argument help-text.
; `option' is a string or symbol naming the option.  e.g. -a, --help, "-i".
; symbols are supported for backward compatibility, -i is a complex number.
; `argument' is a string naming the argument or #f if the option takes no
; arguments.
; `help-text' is a string that is printed with the usage information.
; Elements beyond `help-text' are ignored.
d1142 1
a1142 1
	      (else ; must be option that doesn't take an argument
d1146 1
a1146 1
; Return (cadr args) or print a pretty error message if not possible.
d1156 4
a1159 4
; List of common arguments.
;
; ??? Another useful arg would be one that says "do file generation with
; arguments specified up til now, then continue with next batch of args".
d1186 3
a1188 3
; Default place to look.
; This gets overridden to point to the directory of the loaded .cpu file.
; ??? Ideally this would be local to this file.
d1192 1
a1192 1
; Accessors for application option specs
d1199 12
a1210 12
; Parse options and call generators.
; ARGS is a #:keyword delimited list of arguments.
; #:app-name name
; #:arg-spec optspec ; FIXME: rename to #:opt-spec
; #:init init-routine
; #:finish finish-routine
; #:analyze analysis-routine
; #:argv command-line-arguments
;
; ARGSPEC is a list of (option option-arg comment option-handler) elements.
; OPTION-HANDLER is either (lambda () ...) or (lambda (arg) ...) and
; processes the option.
d1244 1
a1244 1
      ; ARGS has been processed, now we can process ARGV.
d1248 1
a1248 1
	    (app-args nil)    ; application's args are queued here
d1251 2
a1252 2
	    (keep-mach "all") ; default is all machs
	    (keep-isa "all")  ; default is all isas
d1255 1
a1255 1
	    (debugging #f)    ; default is off, for speed
d1300 1
a1300 1
		      #f ; ignore, already processed by caller
d1327 1
a1327 1
		     ; Else this is an application specific option.
d1329 3
a1331 3
		      ; Record it for later processing.  Note that they're
		      ; recorded in reverse order (easier).  This is undone
		      ; later.
d1336 1
a1336 1
	  ) ; end of loop
d1338 1
a1338 1
	; All arguments have been parsed.
d1382 1
a1382 1
    #f) ; end of lambda
d1385 1
a1385 1
; Main entry point called by application file generators.
@


1.42
log
@	* read.scm (/cmd-include): Fix absolute path handling.
@
text
@d941 1
@


1.41
log
@	* insn.scm (/parse-insn-format): Watch for duplicate ifields.
	* read.scm (parse-error-continuable): New function.
	(define /continuable-error-found?): New variable.
	(/init-reader!): Initialize it.
	(/finish-reader!): New function.
	(cpu-load): Call it.
	* utils-cgen.scm (obj-list-nub): New function.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2001, 2006, 2009 Red Hat, Inc.
d985 2
a986 1
; .cpu file include mechanism
d989 7
a995 3
  (logit 1 "Including file " (string-append arch-path "/" file) " ...\n")
  (reader-read-file! (string-append arch-path "/" file))
  (logit 2 "Resuming previous file ...\n")
@


1.40
log
@	* read.scm (/cmd-define-rtl-version): Only log rtl version if changed.
@
text
@d280 3
a282 3
;;; Subroutine of parse-error, parse-warning to simplify them.
;;; Flag an error or a warning.
;;; EMITTER is a function of one argument, the message to print.
d308 7
a314 6
;;; Signal a parse error while reading a .cpu file.
;;; If CONTEXT is #f, use a default context of the current reader location
;;; and an empty prefix.
;;; If MAYBE-HELP-TEXT is specified, elide the last trailing \n.
;;; Multiple lines of help text need embedded newlines, and should be no longer
;;; than 79 characters.
d324 17
a340 6
;;; Signal a parse warning while reading a .cpu file.
;;; If CONTEXT is #f, use a default context of the current reader location
;;; and an empty prefix.
;;; If MAYBE-HELP-TEXT is specified, elide the last trailing \n.
;;; Multiple lines of help text need embedded newlines, and should be no longer
;;; than 79 characters.
d853 3
d866 2
d891 8
a1062 1
  (logit 2 "Processing cpu description " file " ...\n")
d1064 2
@


1.39
log
@	* dev-utils.scm: New file.
	* dev.scm (srcdir, load-doc, load-opc, load-gtest, load-sid,
	load-sim, load-stest, load-testsuite): Moved to dev-utils.scm.
	* read.scm (CHECK-LOADED?, libcpu.so, /loaded-file-list, /loaded-file?,
	/loaded-file-record!, maybe-load): Delete.
	Load cgen files directly instead of via maybe-load.
@
text
@d108 2
a109 1
    (logit 1 "Setting RTL version to " major "." minor " ...\n")
@


1.38
log
@	Specify isa(s) when doing ifield, operand, insn lookups.
	ACU = all callers updated.
	* attr.scm (/attr-eval): Call rtx-value instead of rtx-eval-with-estate.
	* enum.scm (define-full-insn-enum): Pass isa-name-list to
	current-ifld-lookup.
	* html.scm (get-insn-properties): Pass isa-name-list to
	current-op-lookup.
	* ifield.scm (/ifld-parse-follows): New arg isas, ACU.
	* insn.scm (/parse-insn-format-symbol): New arg isa-name-list, ACU.
	(/parse-insn-format-list, /parse-insn-iformat-iflds): Ditto.
	(/parse-insn-format, syntax-break-out): Ditto.
	* mach.scm (obj-filter-by-isa): New function.
	(current-ifld-lookup): New optional arg maybe-isa-name-list.
	(/ifld-already-defined?, /op-already-defined?): Simplify.
	(current-op-lookup): New optional arg maybe-isa-name-list.
	(current-insn-lookup): New arg isa-name-list, ACU.
	(/insn-already-defined?, /minsn-already-defined?): Simplify.
	(current-minsn-lookup): New arg isa-name-list, ACU.
	* minsn.scm (/minsn-compute-iflds): Pass isa-name-list to
	current-op-lookup.
	* opc-itab.scm (compute-syntax): New arg isa-name-list, ACU.
	(gen-syntax-entry): Ditto.
	* operand.scm (/operand-parse): Pass isa-name-list to
	current-ifld-lookup.
	(/derived-parse-encoding): New arg isa-name-list, ACU.
	(/derived-parse-ifield-assertion): Ditto.
	(/derived-operand-parse): Pass isa-name-list to current-op-lookup.
	(/anyof-parse-choice): Ditto.
	(anyof-satisfies-assertions?): Pass context to rtx-solve.
	(/anyof-merge-syntax): New arg container, ACU.
	(operand-builtin!): Add pc to all isas.
	* rtl-c.scm (estate-make-for-rtl-c): Delete arg extra-vars-alist, ACU.
	(estate-make-for-rtl-c++, rtl-c-expr-parsed): Ditto.
	(rtl-c-parsed, rtl-c++-parsed): Ditto.
	(rtl-c): New arg isa-name-list, ACU.
	(rtl-c-expr, rtl-c++): Ditto.
	(closure): New arg isa-name-list, ACU.
	* rtl-traverse.scm (/make-cstate): New arg isa-name-list, ACU.
	(/cstate-isas): New function.
	(/rtx-canon-symbol-list): New function.
	(/rtx-canon-env-stack): Renamed from /rtx-canon-env, ACU.
	updated.
	(/rtx-make-canon-table): Rename ENV to ENVSTACK, new entry SYMBOLLIST.
	(/rtx-canon-rtx-operand): Pass isa list to current-op-lookup.
	(/rtx-canon-rtx-ref, /rtx-canon): Ditto.
	(rtx-canonicalize): New arg isa-name-list, ACU.
	(rtx-canonicalize-stmt): Delete.
	(tstate-make): New arg isas, ACU.
	(tstate-isas, tstate--set-isas!): New functions.
	(tstate-env-stack): Renamed from tstate-env, ACU.
	(tstate-set-env-stack!): Renamed from tstate-set-env!, ACU.
	(tstate-make-closure): Renamed from tstate-new-env, new arg
	isa-name-list, ACU.
	(/rtx-traverse-env): Delete.
	(/rtx-make-traverser-table): Rename ENV to ENVSTACK, new entry
	SUMBOLLIST.
	(/rtx-traverse): Include conditional flag in dump output.
	Update isa,envstack for closures.  Pass isa list to current-op-lookup.
	(<eval-state>): New member isas.  Rename env to env-stack.
	(<eval-state> vmake!): Handle #:isas.  #:env renamed to #:env-stack.
	(<eval-state>): New getter/setter for isas.  Rename env getter/setter
	to env-stack.
	(estate-make-for-eval): Provide #:isas.
	(estate-make-closure): Renamed from estate-new-env.  New arg
	isa-name-list, ACU.
	* rtl-xform.scm (/rtx-simplify-expr-fn): Handle closures.
	(/rtx-trim-args): ENV renamed to ENVSTACK.  Ad ITERATION, SYMBOLLIST.
	(/rtx-trim-for-doc): Handle closures.
	* rtl.scm (/rtx-valid-types): Rename ENV to ENVSTACK.  Add ITERATION,
	SYMBOLLIST.
	(rtx-env-var-list): Delete.
	(rtx-env-make): Handle already-compiled environments.
	(rtx-var-alist-to-env): New function.
	(rtx-var-alist-to-closure-env-stack, rtx-make-env-stack): New functions.
	(rtx-env-stack-dump): Renamed from rtx-env-dump, ACU.
	(rtx-operand-obj): New arg isa-name-list, ACU.
	(rtx-closure-isas, rtx-closure-env-stack, rtx-closure-expr): New
	functions.
	* rtx-funcs.scm (closure): New arg isa-name-list, reorder args, ACU.
	* sem-frags.scm (<sfrag>): Delete member compiled-semantics.
	(/frag-compute-desired-frags): Minor simplification.
	(/frag-pick-best): Ditto.
	* sid-cpu.scm (gen-semantic-code): Require canonical rtl.
	(/gen-sfrag-code): Update.
	* sim-cpu.scm (gen-semantic-code): Require canonical rtl.
	* utils-cgen.scm (sanitize): New arg isa-name-list, ACU.
	* utils.scm (non-null-intersection?): New function.
@
text
@d116 1
a116 4
; Things are organized so that files can be compiled with Hobbit for
; experimentation.  Thus we need one file that loads all the other files.
; This is that file, though it would make sense to move the code in this
; file to another.
d118 4
a121 65
; If a routine to initialize compiled-in code is defined, run it.
(if (defined? 'cgen-init-c) (cgen-init-c))

; If this is set to #f, the file is always loaded.
; Don't override any current setting, e.g. from dev.scm.
(if (not (defined? 'CHECK-LOADED?))
    (define CHECK-LOADED? #t))

; Unlink file if we're reloaded (say in an interactive session).
; Dynamic loading is enabled by setting LIBCPU.SO to the pathname of the .so.
(if (and (defined? 'libcpu.so) (dynamic-object? libcpu.so))
    (dynamic-unlink libcpu.so))
(define libcpu.so #f)
(if (and (defined? 'LIBCPU.SO)
	 (file-exists? LIBCPU.SO))
    (set! libcpu.so (dynamic-link LIBCPU.SO))
)

; List of loaded files.

(if (not (defined? '/loaded-file-list))
    (define /loaded-file-list '()))

; Return non-zero if FILE was loaded last time through.

(define (/loaded-file? file)
  (->bool (memq (string->symbol file) /loaded-file-list))
)

; Record FILE as compiled in.

(define (/loaded-file-record! file)
  (let ((file (string->symbol file)))
    (if (not (memq file /loaded-file-list))
	(set! /loaded-file-list (cons file /loaded-file-list))))
)

; Load FILE if SYM is not compiled in.

(define (maybe-load file init-func sym)
  ; Return non-#f if FUNC is present in DYNOBJ.
  (define (dynamic-func? func dynobj)
    (catch #t
	   (lambda () (dynamic-func func dynobj))
	   (lambda args #f))
    )

  (let ((init-func (string-append "init_" (if init-func init-func file))))
    (cond ((and libcpu.so
		(dynamic-func? init-func libcpu.so))
	   (dynamic-call init-func libcpu.so)
	   (display (string-append "Skipping " file ", dynamically loaded.\n")))
	  ((or (not CHECK-LOADED?)
	       (not (defined? sym))
	       (/loaded-file? file))
	   (/loaded-file-record! file)
	   (load file))
	  (else
	   (display (string-append "Skipping " file ", already loaded.\n")))))
)

(maybe-load "pmacros" #f 'define-pmacro)
(maybe-load "cos" #f 'make)
(maybe-load "slib/logical" #f 'logical:logand)
(maybe-load "slib/sort" #f 'sort)
d123 1
a123 1
(maybe-load "slib/pp" #f 'pretty-print)
d125 26
a150 26
(maybe-load "slib/random" #f 'random)
(maybe-load "slib/genwrite" #f 'generic-write)
(maybe-load "utils" #f 'logit)
(maybe-load "utils-cgen" "utils_cgen" 'obj:name)
(maybe-load "attr" #f '<attribute>)
(maybe-load "enum" #f '<enum>)
(maybe-load "mach" #f '<mach>)
(maybe-load "model" #f '<model>)
(maybe-load "types" #f '<scalar>)
(maybe-load "mode" #f '<mode>)
(maybe-load "ifield" #f '<ifield>)
(maybe-load "iformat" #f '<iformat>)
(maybe-load "hardware" #f '<hardware-base>)
(maybe-load "operand" #f '<operand>)
(maybe-load "insn" #f '<insn>)
(maybe-load "minsn" #f '<macro-insn>)
(maybe-load "decode" #f 'decode-build-table)
(maybe-load "rtl" "rtl" '<rtx-func>)
(maybe-load "rtl-traverse" "rtl_traverse" 'rtx-traverse)
(maybe-load "rtl-xform" "rtx_simplify" 'rtx-simplify)
(maybe-load "rtx-funcs" "rtx_funcs" 'def-rtx-funcs)
(maybe-load "rtl-c" "rtl_c" '<c-expr>)
(maybe-load "semantics" #f 'semantic-compile)
(maybe-load "sem-frags" "sem_frags" 'gen-threaded-engine)
(maybe-load "utils-gen" "utils_gen" 'attr-gen-decl)
(maybe-load "pgmr-tools" "pgmr_tools" 'pgmr-pretty-print-insn-format)
@


1.37
log
@	Record bitset attributes internally as a list.
	Record rtx attribute values internally as ((rtx-expr)).
	* attr.scm (bitset-attr?): Delete, unused.
	(<bitset-attribute> parse-value): Rewrite.
	(/attr-parse): Rewrite bitset default value processing.
	(/attr-read): Pick out values of scalar attributes to distinguish
	them from bitset values which are a list.
	Fix spelling errors for processing of default values.
	Handle string attributes.
	(bitset-attr->list): Delete, all callers updated.
	(/bitset-attr->charmask): Renamed from bitset-attr->charmask.
	All callers updated.
	(atlist-source-form): Rewrite.
	* hardware.scm (<hardware-base> 'get-isas): Update recognition
	of all isas.
	(hardware-builtin!): Update spec of ISA attribute, (ISA foo,bar)
	-> (ISA foo bar).
	* intrinsics.scm (target:belongs-to-group?): Update, bitset attribute
	values are now lists.
	* mach.scm (def-isa-attr!): Update, bitset attribute values,
	including the default, are now lists.
	(all-isas-attr-value): Result is now a list.
	* doc/rtl.texi: Clean up pass over attribute docs.
@
text
@d739 1
d742 1
@


1.36
log
@	* read.scm (/CGEN-RTL-VERSION): Initialize to #f.
	(init-reader!): Set /CGEN-RTL-VERSION to default.

	* read.scm (cpu-load): Print load parameters.
@
text
@d641 1
a641 1
	(keep-mach? (bitset-attr->list machs))))
d757 1
a757 1
    (keep-isa? (bitset-attr->list isas)))
@


1.35
log
@	Add support for controlling warnings/errors.
	Add tests for iformat description errors.
	* dev.scm (cload): New option #:diag.
	* read.scm (<reader>): New member verify-iformat?.
	(/parse-diagnostic, parse-warning): New functions.
	(parse-error): Guts moved to /parse-diagnostic.
	(/set-diagnostic-options!): New function.
	(cpu-load): New arg diagnostic-options, all callers updated.
	Recognize -w diagnostic-option-list.
	* ifield.scm (ifields-base-ifields): Move here from iformat.scm.
	(ifld-simple-ifields, ifields-simple-ifields): New function.
	* insn.scm (/parse-insn-format-iflds): New function.
	(/parse-insn-format): Guts moved to /parse-insn-format-iflds.
	New arg isa, all callers updated.  Do some basic validation of the
	ifield list if requested.
	* mach.scm (/sanity-check-insns): Improve error message text.
	* doc/running.text: Document -w option.

	* ifield.scm (/multi-ifield-parse): Initialize bitrange.
@
text
@d75 2
a76 1
(define /CGEN-RTL-VERSION '(0 7))
d910 2
d1092 5
@


1.34
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d278 3
d303 1
a303 1
   trace-commands? trace-pmacros?
d307 1
a307 1
   trace-commands? trace-pmacros?
d342 3
a344 6
;;; Signal a parse error while reading a .cpu file.
;;; If CONTEXT is #f, use a default context of the current reader location
;;; and an empty prefix.
;;; If MAYBE-HELP-TEXT is specified, elide the last trailing \n.
;;; Multiple lines of help text need embedded newlines, and should be no longer
;;; than 79 characters.
d346 1
a346 1
(define (parse-error context message expr . maybe-help-text)
d356 1
a356 1
    (error
d365 33
a397 3
      (if (null? maybe-help-text)
	  ""
	  (string-append "\n\n" (car maybe-help-text))))))
d816 30
d1069 1
d1080 2
a1081 1
(define (cpu-load file keep-mach keep-isa options trace-options
d1086 1
d1198 5
d1278 1
d1329 3
d1372 2
a1373 1
		     keep-mach keep-isa flags trace-options
@


1.33
log
@* read.scm (parse-error): Really change error message output format
to match context-owner-error.
* utils-cgen.scm (context-owner-error): Simplify.
@
text
@d67 4
a70 4
(define -CGEN-VERSION '(1 1 50))
(define (cgen-major) (car -CGEN-VERSION))
(define (cgen-minor) (cadr -CGEN-VERSION))
(define (cgen-fixlevel) (caddr -CGEN-VERSION))
d73 1
a73 1
; Note that this is different from -CGEN-VERSION.
d75 19
a93 4
(define -CGEN-RTL-VERSION '(0 7))
(define (cgen-rtl-version) -CGEN-RTL-VERSION)
(define (cgen-rtl-major) (car -CGEN-RTL-VERSION))
(define (cgen-rtl-minor) (cadr -CGEN-RTL-VERSION))
d96 1
a96 1
(define -supported-rtl-versions '((0 7) (0 8)))
d98 1
a98 1
(define (-cmd-define-rtl-version major minor)
d105 1
a105 1
    (if (not (member new-version -supported-rtl-versions))
d108 1
a108 1
    (set! -CGEN-RTL-VERSION new-version))
d140 2
a141 2
(if (not (defined? '-loaded-file-list))
    (define -loaded-file-list '()))
d145 2
a146 2
(define (-loaded-file? file)
  (->bool (memq (string->symbol file) -loaded-file-list))
d151 1
a151 1
(define (-loaded-file-record! file)
d153 2
a154 2
    (if (not (memq file -loaded-file-list))
	(set! -loaded-file-list (cons file -loaded-file-list))))
d174 2
a175 2
	       (-loaded-file? file))
	   (-loaded-file-record! file)
d251 1
a251 1
(define -keep-all-machs '((all)))
d267 1
a267 1
	       (cons 'keep-mach -keep-all-machs)
d315 1
a315 1
(define (-reader-lookup-command name)
d326 1
a326 1
(define (-readable-current-location)
d383 1
a383 1
(define (-reader-process-expanded-1! entry)
d396 1
a396 1
    (let ((command (-reader-lookup-command (car entry)))
d435 1
a435 1
;; This is also used by -cmd-if.
d449 1
a449 1
	 (-reader-process-expanded-1! entry)))
d457 1
a457 1
(define (-reader-process! entry loc)
d493 1
a493 1
			  (-reader-process! entry (current-input-location #t))
d530 1
a530 1
(define (-keep-mach-set! mach-name-list)
d637 1
a637 1
  (equal? (reader-keep-mach CURRENT-READER) -keep-all-machs)
d667 1
a667 1
(define (-keep-isa-set! isa-name-list)
d766 1
a766 1
(define (-set-trace-options! trace-options)
d823 1
a823 1
(define -cpu-new-class-list nil)
d826 1
a826 1
  (set! -cpu-new-class-list (acons parent child -cpu-new-class-list))
d833 1
a833 1
  (let ((child (assq-ref -cpu-new-class-list parent)))
d846 1
a846 1
(define (-init-reader!)
d851 1
a851 1
		       nil '(major minor) -cmd-define-rtl-version)
d855 1
a855 1
		       nil '(file) -cmd-include)
d858 1
a858 1
		       nil '(test then . else) -cmd-if)
d879 2
a880 2
(define (-init-parse-cpu! keep-mach keep-isa options)
  (set! -cpu-new-class-list nil)
d883 2
a884 2
  (-keep-mach-set! keep-mach)
  (-keep-isa-set! keep-isa)
d929 1
a929 1
(define (-finish-parse-cpu!)
d950 1
a950 1
(define (-global-error-checks)
d960 1
a960 1
(define (-cmd-include file)
d970 1
a970 1
(define (-cmd-if test then . else)
d1021 3
a1023 3
  (-init-reader!)
  (-init-parse-cpu! keep-mach keep-isa options)
  (-set-trace-options! trace-options)
d1029 1
a1029 1
  (-finish-parse-cpu!)
d1031 1
a1031 1
  (-global-error-checks)
d1092 1
a1092 1
(define (-getopt argv opt-spec)
d1165 1
a1165 1
(define -cgen
d1215 1
a1215 1
	  (let* ((new-argv (-getopt argv opt-spec))
d1337 1
a1337 1
    (cgen-debugging-stack-start -cgen args))
@


1.32
log
@	* read.scm (parse-error): Change error message output format
	to match context-owner-error.
	* rtl-c.scm (-rtl-c-get): Call estate-error instead of error.
	(rtl-c-set-quiet, rtl-c-set-trace): Ditto.
	(s-if, s-cond, -gen-non-vm-case-test): Ditto.
	(operand): Call estate-error instead of context-error.
	(local, delay): Ditto.
	(ref, attr): Call estate-error instead of error.
	* rtl-traverse.scm (tstate-error): New function.
	(-rtx-traverse-error): Call tstate-error instead of context-error.
	(-rtx-traverse-operands, -rtx-traverse): Ditto.
	(estate-error): New function.
	* rtl.scm (rtx-lvalue-mode-name): Handle locals.  Call estate-error
	instead of error.
	(e-if): Call estate-error instead of error.
	* rtx-funcs.scm (error): Call estate-error instead of context-error.
	(member): Ditto.
	* utils-cgen.scm (context-error): New arg `intro', all callers updated.
	Rewrite to call context-owner-error.
	(context-owner-error): New function.
@
text
@d334 1
d338 3
a340 4
	 (prefix (context-prefix context))
	 (text (if prefix
		   (string-append prefix ": " message)
		   message)))
d344 1
a344 1
      "\n~A:\n~A: ~A: ~S\n\nReference chain:\n~A~A"
d346 1
a349 1
      (location->string loc)
d352 1
a352 1
	  (string-append "\n" (car maybe-help-text))))))
@


1.31
log
@	* hardware.scm (<keyword>): Rename member print-name -> enum-prefix.
	Rename member prefix -> name-prefix.
	(<keyword> getters): Update.
	(-keyword-parse): Update.  Default enum-prefix to NAME-.
	(-keyword-read): Update.  Don't compute default value for
	enum-prefix here.
	(define-keyword): Update.
	(-hw-parse-keyword): Pass "UNUSED" for enum-prefix to -keyword-parse.
	* read.scm (cgen-rtl-version): New function.
	(-supported-rtl-versions): Add (0 8).
	* desc-cpu.scm (-gen-hw-decl): Remove cruft.
	* desc.scm (<keyword> gen-defn): prefix -> name-prefix.
	* gas-test.scm (<keyword> test-data): prefix -> name-prefix.
	* cpu/arm.cpu (gr-names, shift-type): Call define-rtl-version.
	Update, print-name -> enum-prefix, make uppercase.
	Remove unnecessary name-prefix spec.
	* cpu/fr30.cpu (gr-names, cr-names, dr-names): Ditto.
	* cpu/ip2k.cpu (register-names): Ditto.
	* cpu/m68k.cpu (dr-names, ar-names): Ditto.
	* cpu/sparc.cpu (gr-names): Ditto.
	* cpu/xc16x.cpu (gr-names, ext-names,psw-names): Ditto.
	(grb-names, conditioncode-names, extconditioncode-names): Ditto.
	(grb8-names, r8-names, regmem8-names, regdiv8-names): Ditto.
	(reg0-name, reg0-name1, regbmem8-names, memgr8-names): Ditto.
	* cpu/ia32.cpu (gr8-names, gr16-names, gr-names): Call
	define-rtl-version.  Update, print-name -> enum-prefix, make uppercase,
	prefix -> name-prefix.
	* cpu/sh64-compact.cpu (frc-names): Call define-rtl-version.
	Update, print-name -> enum-prefix, make uppercase.
	(drc-names, xf-names): Ditto.
	* cpu/xstormy16.cpu (gr-names, gr-Rb-names): Ditto.
	* doc/rtl.texi (Keywords): New section.
	(hardware indices): Update text.
	(rtl versions): Add 0.8.
@
text
@d336 5
a340 1
	 (prefix (context-prefix context)))
d344 2
a345 1
      "While reading description:\n~A: ~A:\n  ~S\nReference chain:\n~A~A"
d347 1
a347 3
      (if prefix
	  (string-append prefix ": " message)
	  message)
@


1.30
log
@	Add define-rtl-version.
	* read.scm (-CGEN-RTL-VERSION): Renamed from -CGEN-LANG-VERSION.
	(cgen-rtl-major, cgen-rtl-minor): Similarly renamed.
	(cgen-lang-fixlevel): Delete.
	(-supported-rtl-versions): New variable.
	(-cmd-define-rtl-version): New function.
	(init-reader!): New command define-rtl-version.
	(-cgen): Add rtl version to --version output.
	* doc/rtl.texi: Document rtl version support.
	* cpu/play.cpu: Add define-rtl-version.
@
text
@d76 1
d81 1
a81 1
(define -supported-rtl-versions '((0 7)))
@


1.29
log
@	* configure.in (AM_INIT_AUTOMAKE): Change version to 1.1.50 to
	distinguish from 1.1.
	* configure: Regenerate.
	* read.scm (-CGEN-VERSION): Update.
	* doc/version.texi: Update.
@
text
@d72 1
a72 1
; A list of three numbers designating the description language version.
d74 20
a93 4
(define -CGEN-LANG-VERSION '(0 7 2))
(define (cgen-lang-major) (car -CGEN-LANG-VERSION))
(define (cgen-lang-minor) (cadr -CGEN-LANG-VERSION))
(define (cgen-lang-fixlevel) (caddr -CGEN-LANG-VERSION))
d830 4
d1250 5
@


1.28
log
@	* ifield.scm (ifld-encode-mode): Add FIXME.
	* opcodes.scm (<ifield> 'gen-insert): Handle encode parameters with
	modes.
	(<ifield> 'gen-extract): Similarly.

	* read.scm (parse-error): Handle #f for context-location.
	* utils-cgen.scm (unspecified-location): Fix building of
	single-location.
@
text
@d66 2
a67 1
(define -CGEN-VERSION '(1 1 0))
@


1.27
log
@	* read.scm (current-reader-location): Return unspecified location
	if reader hasn't been initialized yet.
@
text
@d316 1
a316 1
  (let* ((loc (context-location context))
@


1.26
log
@	Clean up cpu file parsing, pass context consistently instead of the
	old "errtxt" argument.
	NOTE: ACU == "All Callers Updated".
	* attr.scm (-parse-simple-attribute): Renamed from
	parse-simple-attribute, ACU.
	(-attr-parse): Change errtxt argument to context, ACU.
	(-attr-read): Ditto.
	(atlist-parse): Ditto.  Put context arg first.
	(attr-parse): Use parse-error instead of context-error.
	* enum.scm (parse-enum-vals): Change errtxt argument to context, ACU.
	(-enum-parse-prefix, -enum-parse, -enum-read): Ditto.
	* hardware.scm (-keyword-parse): Renamed from keyword-parse.
	`context' arg is now a <context> object.  ACU.
	(-keyword-read): `context' arg is now a <context> object.  ACU.
	(-hw-parse-indices): Change errtxt argument to context, ACU.
	(-hw-parse-values, -hw-parse-handlers): Ditto.
	(-hw-parse-getter, -hw-parse-setter, -hw-parse, -hw-read): Ditto.
	(-hw-validate-layout, -hw-create-getter-from-layout,
	-hw-create-setter-from-layout): Ditto.
	(<hw-register>:parse!, <hw-pc>:parse!): Ditto.
	(<hw-memory>:parse!, <hw-immediate>:parse!): Ditto.
	(<hw-address>:parse!): Ditto.
	* ifield.scm (-ifield-parse, ifield-read): Ditto.
	(-ifld-parse-follows, -ifld-parse-encode-decode): Ditto.
	(-ifld-parse-encode, -ifld-parse-decode): Ditto.
	(-multi-ifield-parse, -multi-ifield-read): Ditto.
	* insn.scm (-insn-parse, -insn-read): Ditto.
	(parse-syntax): Ditto.  Put context arg first.
	(-parse-insn-format-symbol): Change errtxt argument to context, ACU.
	(-parse-insn-format-ifield-spec, -parse-insn-format-list): Ditto.
	(-parse-insn-format): Ditto.
	* mach.scm (-arch-parse-alignment, -arch-parse-machs): Ditto.
	(-arch-parse-isas): Ditto.
	(-isa-read): Add context arg, ACU.
	(-cpu-parse, -cpu-read, -mach-read): Ditto.
	* minsn.scm (-minsn-parse-expansion): Change errtxt argument to
	context, ACU.
	(-minsn-parse, -minsn-read, -minsn-compute-iflds): Ditto.
	(minsn-make-alias): Ditto.
	* mode.scm (-mode-parse): Ditto.
	(parse-mode-name): Ditto.  Put context arg first.
	* model.scm (-prefetch-parse, -retire-parse, -pipeline-parse): Change
	errtxt argument to context, ACU.
	(-unit-parse, -model-parse, -model-read): Ditto.
	* operand.scm (-operand-parse-getter): Use parse-error instead of
	context-error.
	(-operand-parse-setter): Ditto.
	(-operand-parse): Change errtxt argument to context, ACU.
	(-operand-read, -derived-operand-parse, -derived-operand-read): Ditto.
	(-anyof-operand-parse, -anyof-operand-read): Ditto.
	* read.scm (reader-error): Delete.  Use parse-error instead.
	(parse-error): Change errtxt argument to context, ACU.  Split args
	argument into expr and maybe-help-text.
	(-reader-process-expanded-1!): Reorganize.
	* rtl.scm (-subr-read): Change errtxt argument to context, ACU.
	* types.scm (parse-type): Ditto.
	* utils-cgen.scm (single-location->simple-string): New function.
	(<context>): Replace members file,lineno with location.
	(make-prefix-context): Renamed from context-make-prefix, ACU.
	(make-current-context): New function.
	(context-append, context-append-name): New functions.
	(context-make-reader): Delete.
	(parse-name): Change errtxt argument to context, ACU.
	Put context arg first.
	(parse-comment): Ditto.
	(parse-number): Change errtxt argument to context, ACU.
	(arg-list-validate-name, arg-list-check-no-args,
	arg-list-symbol-arg): Ditto.

	* read.scm (-cmd-if): Don't assume test is a list.

	* html.scm (get-insn-properties): Delete errtxt, unused.
@
text
@d335 3
d340 3
a342 1
  (reader-location CURRENT-READER)
@


1.25
log
@	Add -t option for tracing things like commands, pmacro expansion.
	* dev.scm (cload): New arg #:trace.
	* pmacros.scm (-pmacro-expand): Rewrite pmacro tracing.
	(pmacro-trace): New arg `loc'.  Rewrite pmacro tracing.
	(pmacro-debug): Call pmacro-trace instead of -pmacro-expand.
	* read.scm (<reader>): New members trace-commands?, trace-pmacros?.
	(-reader-process-expanded-1!): Trace commands if requested.
	(-reader-process!): Call pmacro-trace of pmacro tracing requested.
	(-set-trace-options!): New function.
	(-init-reader!): New function.
	(cpu-load): New arg trace-options, all callers updated.
	Call -init-reader! and -set-trace-options!.
	(cgen-usage): Improve output formatting.
	(common-arguments): New option -t.
	(-cgen): Process -t.
	* utils-cgen.scm (single-location->string): Renamed from
	pretty-print-single-location.  All callers updated.
	(location->string): Renamed from pretty-print-location.
	All callers updated.
	(source-properties-location->string): New function.
	* doc/running.texi: Document -t.
@
text
@d306 11
a316 4
; Signal an error while reading a .cpu file.

(define (reader-error msg expr help-text)
  (let* ((loc (current-reader-location))
d318 14
a331 22
	 (errmsg
	  (string-append (single-location->string top-sloc)
			 ": "
			 msg
			 ":\n"
			 (if (string=? help-text "")
			     ""
			     (string-append help-text "\n")))))
    (error (simple-format #f "While reading description:\n~A ~A\nReference chain:\n~A"
			  errmsg expr (location->string loc))))
)

; Signal a parse error while reading a .cpu file.
; FIXME: Add expr arg and change args to optional help text.

(define (parse-error errtxt message . args)
  (cond ((null? args)
	 (reader-error (string-append errtxt ": " message ":") "" ""))
	((= (length args) 1)
	 (reader-error (string-append errtxt ": " message ":") (car args) ""))
	(else
	 (reader-error (string-append errtxt ": " message ":") args "")))
d343 5
a347 3
  ;; Set the current source location for better diagnostics.
  ;; Access with current-reader-location.
  (reader-set-location! CURRENT-READER (location-property entry))
d349 1
a349 2
  (if (reader-trace-commands? CURRENT-READER)
      (let ((loc (location-property entry)))
d351 1
a351 1
		 (if loc (location->string loc) "location unknown")
d353 31
a383 1
		 (with-output-to-string (lambda () (pretty-print entry))))))
d385 1
a385 25
  (let ((command (-reader-lookup-command (car entry))))
    (if command
	(let* ((handler (command-handler command))
	       (arg-spec (command-arg-spec command))
	       (num-args (num-args arg-spec)))
	  (if (cdr num-args)
	      ; Variable number of trailing arguments.
	      (if (< (length (cdr entry)) (car num-args))
		  (reader-error (string-append "Incorrect number of arguments to "
					       (symbol->string (car entry))
					       ", expecting at least "
					       (number->string (car num-args)))
				entry
				(command-help command))
		  (apply handler (cdr entry)))
	      ; Fixed number of arguments.
	      (if (!= (length (cdr entry)) (car num-args))
		  (reader-error (string-append "Incorrect number of arguments to "
					       (symbol->string (car entry))
					       ", expecting "
					       (number->string (car num-args)))
				entry
				(command-help command))
		  (apply handler (cdr entry)))))
	(reader-error "unknown entry type" entry "")))
d418 1
a418 1
      (reader-error "improperly formed entry" entry ""))
d927 3
a929 4
      (reader-error "wrong number of arguments to `if'"
		    (cons 'if (cons test (cons then else)))
		    ""))
  ; FIXME: Assumes TEST is a non-null-list.
d931 5
a935 2
  (if (not (memq (car test) '(keep-isa? keep-mach? application-is?)))
      (reader-error "only (if (keep-mach?|keep-isa?|application-is? ...) ...) are currently supported" test ""))
d1064 3
a1066 1
      (parse-error "option processing" "missing argument to" (car args)))
@


1.24
log
@	* read.scm (debug-env, debug-var-names, debug-var, debug-tty,
	debug-tty-port, debug-repl, debug-quit, debug-repl-env): Move to ...
	* utils.scm: ... here.
@
text
@d239 6
d266 3
a268 1
  (keep-mach keep-isa current-cpu commands location))
d270 3
a272 1
  (keep-mach keep-isa current-cpu commands location))
d296 1
a296 1
	(pretty-print-location loc)
d312 1
a312 1
	  (string-append (pretty-print-single-location top-sloc)
d320 1
a320 1
			  errmsg expr (pretty-print-location loc))))
a343 2
  (logit 4 (with-output-to-string (lambda () (pretty-print entry))))

d348 7
a390 6
  (if (and (verbose? 4)
	   (pair? entry))
      (let ((loc (location-property entry)))
	(logit 4 "reader-process-expanded!: " (source-properties entry))
	(logit 4 "                     loc: " (pretty-print-location loc))))

d416 1
a416 1
  ; at it, I guess, is to think of define-pmacro as the only current
d420 3
a422 1
		       (pmacro-expand entry loc))))
d444 2
d703 36
d794 4
a797 9
; Prepare to parse a .cpu file.
; This initializes the application independent tables.
; KEEP-MACH specifies what machs to keep.
; KEEP-ISA specifies what isas to keep.
; OPTIONS is a list of options to control code generation.
; The values are application dependent.

(define (-init-parse-cpu! keep-mach keep-isa options)
  (set! -cpu-new-class-list nil)
d799 1
a800 4
  (set! CURRENT-ARCH (new <arch>))
  (-keep-mach-set! keep-mach)
  (-keep-isa-set! keep-isa)
  (set-cgen-options! options)
d818 18
d955 1
d966 1
a966 1
(define (cpu-load file keep-mach keep-isa options
d968 1
d970 1
d998 14
a1011 4
		(display (string-append (car arg)
					" " (if (cadr arg) (cadr arg) "")
					"  - " (caddr arg)
					"\n")
d1074 5
d1154 1
d1199 3
d1240 1
a1240 1
		     keep-mach keep-isa flags
@


1.23
log
@	Track source location better, for better error messages.
	* pmacros.scm (-pmacro-eval): Delete, unused.
	(pmacro-expand, -pmacro-expand): New arg `loc', all callers updated.
	(-pmacro-expand-expr-list, -smacro-apply): Ditto.
	(scan-list, scan): Ditto.
	(-pmacro-builtin-pmacro, -pmacro-builtin-let, -pmacro-builtin-if,
	-pmacro-builtin-case, -pmacro-builtin-cond, -pmacro-builtin-begin,
	-pmacro-builtin-andif, -pmacro-builtin-orif): Ditto.
	(scan-list1): New function.
	(-pmacro-build-lambda): New arg `loc', all callers updated.  Rewrite.
	* read.scm (<reader>): New member `location'.
	(-reader-lookup-command): Renamed from reader-lookup-command,
	all callers updated.
	(reader-error): Rewrite to produce better source location info.
	(current-reader-location): New function.
	(-reader-process-expanded-1!): Renamed from -reader-process-expanded-1.
	All callers updated.  Record source location of expression.
	(reader-process-expanded!): Renamed from reader-process-expanded.
	All callers updated.
	(-reader-process!): Renamed from reader-process.  New arg `loc'.
	All callers updated.  Record source location of define-pmacro.
	* utils-cgen.scm (<location>): New class.
	(single-location): New (pseudo) class.
	(pretty-print-single-location, pretty-print-location): New functions.
	(location-top, location-push-single, location-push): New functions.
	(unspecified-location, current-input-location): New functions.
	(location-property): New object property.
	(location-property-set!): New function.
	(<source-ident>): Renamed from <ordered-ident>.  New member `location'.
	All uses updated.
	* testsuite/location-1.test: New testcase.
	* testsuite/run-tests.sh: Fix fail count handling.
	* testsuite/test-utils.sh.in (run_cgen): New option `-f'.  Allow tests
	to expect cgen to fail.

	* pmacros.scm (*): Use "pmacro" instead of "macro" more consistently.

	* read.scm (-cmd-include): Renamed from include.  All callers updated.
	(-cmd-if): Renamed from cmd-if.  All callers updated.
	Use reader-process-expanded! on then/else clauses instead of eval1.
@
text
@a986 69
; Record of arguments passed to debug-repl, so they can be accessed in
; the repl loop.

(define debug-env #f)

; Return list of recorded variables for debugging.

(define (debug-var-names) (map car debug-env))

; Return value of recorded var NAME.

(define (debug-var name) (assq-ref debug-env name))

; A handle on /dev/tty, so we can be sure we're talking with the user.
; We open this the first time we actually need it.

(define debug-tty #f)

; Return the port we should use for interacting with the user,
; opening it if necessary.

(define (debug-tty-port)
  (if (not debug-tty)
      (set! debug-tty (open-file "/dev/tty" "r+")))
  debug-tty)

; Enter a repl loop for debugging purposes.
; Use (quit) to exit cgen completely.
; Use (debug-quit) or (quit 0) to exit the debugging session and
; resume argument processing.
;
; ENV-ALIST can be anything, but it is intended to be an alist of values
; the caller will want to be able to access in the repl loop.
; It is stored in global `debug-env'.
;
; FIXME: Move to utils.scm.

(define (debug-repl env-alist)
  (with-input-and-output-to
   (debug-tty-port)
   (lambda ()
     (set! debug-env env-alist)
     (let loop ()
       (let ((rc (top-repl)))
	 (if (null? rc)
	     (quit 1))			; indicate error to `make'
	 (if (not (equal? rc '(0)))
	     (loop))))))
)

; Utility for debug-repl.

(define (debug-quit)
  ; Keep around for later debugging.
  ;(set! debug-env #f)

  (quit 0)
)

; Macro to simplify calling debug-repl.
; Usage: (debug-repl-env var-name1 var-name2 ...)

(defmacro debug-repl-env var-names
  (let ((env (map (lambda (var-name)
		    (list 'cons (list 'quote var-name) var-name))
		  var-names)))
    (list 'debug-repl (cons 'list env)))
)

d1157 1
@


1.22
log
@	* model.scm (parse-insn-timing): Tweak logging message.
	* operand.scm: Comment and whitespace tweaks.
	(op:type): Tweak error message.
	(op-ifield): Tweak logging message.
	(-derived-operand-parse, anyof-merge-semantics): Ditto.
	* read.scm: Whitespace cleanup.
	* utils.scm: Whitespace cleanup.
@
text
@d216 1
a216 1
; Keep all machs, drop none.
d248 5
d259 4
a262 2
(define-getters <reader> reader (keep-mach keep-isa current-cpu commands))
(define-setters <reader> reader (keep-mach keep-isa current-cpu commands))
d272 1
a272 1
(define (reader-lookup-command name)
d280 2
a281 1
; Signal an error while reading a .cpu file.
d283 7
a289 3
(define (reader-error msg expr help-text)
  (let ((errmsg
	 (string-append (or (port-filename (current-input-port))
a292 2
			": "
			msg
d294 17
a310 2
    (error (string-append errmsg "\n" help-text)
	   expr))
d325 6
d333 1
a333 1
(define (-reader-process-expanded-1 entry)
d335 6
a340 1
  (let ((command (reader-lookup-command (car entry))))
d365 1
d370 11
a381 1
(define (reader-process-expanded entry)
d390 1
a390 1
	 (for-each reader-process-expanded
d393 3
a395 1
	 (-reader-process-expanded-1 entry)))
d399 1
d401 1
a401 1
(define (reader-process entry)
d406 3
d410 5
a414 3
		       entry
		       (pmacro-expand entry))))
    (reader-process-expanded expansion))
d429 5
a433 1
			  (reader-process entry)
d437 3
a439 2
    (with-input-from-file file readit)
    *UNSPECIFIED*)
d763 1
a763 2
		       nil '(file) include
  )
d766 1
a766 2
		       nil '(test then . else) cmd-if
  )
d850 1
a850 1
(define (include file)
d860 1
a860 1
(define (cmd-if test then . else)
d865 1
d872 1
a872 1
	 (eval1 then)
d875 1
a875 1
	     (eval1 (car else)))))
d878 1
a878 1
	 (eval1 then)
d881 1
a881 1
	     (eval1 (car else)))))
d884 1
a884 1
	 (eval1 then)
d887 1
a887 1
	     (eval1 (car else))))))
@


1.21
log
@	* read.scm (parse-error): Don't print single entry args as a list.
	(-reader-process-expanded-1): Convert symbol to string for
	string-append.
@
text
@d943 1
d948 1
d1020 1
d1024 1
@


1.20
log
@	Extend pmacro language, add testsuite.
	* Makefile.am (SUBDIRS): Add testsuite.
	* Makefile.in: Regenerate.
	* configure.in (AC_OUTPUT): Create testsuite/Makefile,
	testsuite/test-utils.sh.
	* configure: Regenerate.
	* dev.scm (cload): Handle testsuite app.
	(load-testsuite): New function.
	* pmacros.scm: (-pmacro-debug?): New global.
	(-smacro-table): New global.
	(-smacro-lookup, -smacro-set!): New functions.
	(-pmacro-make): New argument `syntactic-form?', all callers updated.
	(-pmacro-syntactic-form?): New function.
	(-pmacro-expected-number, -pmacro-verify-number): New functions.
	(-pmacro-expected-integer, -pmacro-verify-integer): New functions.
	(-pmacro-expected-non-negative-integer): New function.
	(-pmacro-verify-non-negative-integer): New function.
	(-pmacro-expand-expr-list): New function.
	(-pmacro-process-args-1): Renamed from -pmacro-process-args.
	(-pmacro-process-args): Renamed from -pmacro-invoke.
	(-pmacro-apply, -smacro-apply): New functions.
	(-pmacro-expand): Rewrite syntactic form processing.
	(-pmacro-build-lambda): Reformat.
	(define-pmacro): Watch for more errors in definition.
	(pmacro-debug): New function.
	(pmacro-trace): Set/reset -pmacro-debug?.
	(all existing builtin pmacro helpers): Rename to -pmacro-builtin-foo.
	(-pmacro-builtin-substring): Fix.  Add support for `end' marker.
	(-pmacro-builtin-for-each, et.al.): New helpers for .for-each, .let,
	.if, .case, .cond, .begin, .print, .dump, .error, .list, .ref,
	.length, .replicate, .equals, .and, .or, .not, .eq, .ne, .lt, .gt,
	.le, .ge, .add, .sub, .mul, .div, .rem, .sll, .srl, .sra, .bitand,
	.bitor, .bitxor, bitinv, .car, .cdr, .caar, .cadr, .cdar, .cddr.
	(pmacros-init!): Initialize -smacro-table.
	Rewrite pmacro initialization.
	* read.scm (reader-process-expanded): Renamed from
	-reader-process-expanded.  All callers updated.
	Recognize () as a no-op.
	(cpu-load): Tweak logging messages.
	* utils.scm (message): Add comment.
	* cpu/play.cpu: Add some instructions to play with .let.
	* doc/cgenint.texi: Move some debugging related docs to here from
	cgen.texi.
	* doc/pmacros.texi: Reorganize.  Add docs for new builtin pmacros.
	* testsuite/Makefile.am: New file.
	* testsuite/Makefile.in: New file.
	* testsuite/test-utils.sh.in: New file.
	* testsuite/run-tests.sh: New file.
	* testsuite/testsuite.cpu: New file.
	* testsuite/pmacros-1.test: New file.
@
text
@d289 1
d292 6
a297 1
  (reader-error (string-append errtxt ": " message ":") args "")
d313 1
a313 1
					       (car entry)
d322 1
a322 1
					       (car entry)
@


1.19
log
@	* semantics.scm (semantic-compile): Change arg sem-code-list to
	sem-code.
	(semantic-attrs): Ditto.
	* iformat.scm (ifmt-analyze): Update.
	(ifmt-compute!): Update.
	* rtl-traverse.scm (-compile-expr-fn, rtx-compile): Move to
	rtl-xform.scm.
	(-rtx-trim-args, -rtx-trim-for-doc, rtx-trim-for-doc): Ditto.
	* rtl.scm (-rtx-canonicalize-expr, rtx-canonicalize): Ditto.
	* semantics.scm (rtx-simplify): Ditto.
	(rtx-const-equal, rtx-const-list-equal): Ditto, and make local.
	(rtx-simplify-eq-attr-mach, rtx-simplify-eq-attr-insn): Ditto.
	(-simplify-expr-fn): Move to rtl-xform.scm.
	(-solve-expr-fn, rtx-solve): Ditto.
	* rtl-xform.c: New file.
	* read.scm: Load it.
@
text
@d326 1
a326 1
; Process 1 or more macro-expanded entries.
d328 13
a340 10
(define (-reader-process-expanded entry)
  ; `begin' is used to group a collection of entries into one, since pmacro
  ; can only return one expression (borrowed from Scheme of course).
  ; ??? Maybe someday (begin ...) will be equivalent to (sequence () ...)
  ; but not yet.
  ; Recurse in case there are nested begins.
  (if (eq? (car entry) 'begin)
      (for-each -reader-process-expanded
		(cdr entry))
      (-reader-process-expanded-1 entry))
d353 1
a353 1
    (-reader-process-expanded expansion))
d704 2
a705 2
  ; Rather than add cgen specific stuff to pmacros.scm, we create
  ; a define-pmacro command here.
d845 1
a845 1
  (logit 1 "Loading cpu description " file "\n")
d848 1
a848 1
  (logit 2 "Processing cpu description " file "\n")
@


1.19.2.1
log
@Copy over from trunk.
	Extend pmacro language, add testsuite.
	* Makefile.am (SUBDIRS): Add testsuite.
	* Makefile.in: Regenerate.
	* configure.in (AC_OUTPUT): Create testsuite/Makefile,
	testsuite/test-utils.sh.
	* configure: Regenerate.
	* dev.scm (cload): Handle testsuite app.
	(load-testsuite): New function.
	* pmacros.scm: (-pmacro-debug?): New global.
	(-smacro-table): New global.
	(-smacro-lookup, -smacro-set!): New functions.
	(-pmacro-make): New argument `syntactic-form?', all callers updated.
	(-pmacro-syntactic-form?): New function.
	(-pmacro-expected-number, -pmacro-verify-number): New functions.
	(-pmacro-expected-integer, -pmacro-verify-integer): New functions.
	(-pmacro-expected-non-negative-integer): New function.
	(-pmacro-verify-non-negative-integer): New function.
	(-pmacro-expand-expr-list): New function.
	(-pmacro-process-args-1): Renamed from -pmacro-process-args.
	(-pmacro-process-args): Renamed from -pmacro-invoke.
	(-pmacro-apply, -smacro-apply): New functions.
	(-pmacro-expand): Rewrite syntactic form processing.
	(-pmacro-build-lambda): Reformat.
	(define-pmacro): Watch for more errors in definition.
	(pmacro-debug): New function.
	(pmacro-trace): Set/reset -pmacro-debug?.
	(all existing builtin pmacro helpers): Rename to -pmacro-builtin-foo.
	(-pmacro-builtin-substring): Fix.  Add support for `end' marker.
	(-pmacro-builtin-for-each, et.al.): New helpers for .for-each, .let,
	.if, .case, .cond, .begin, .print, .dump, .error, .list, .ref,
	.length, .replicate, .equals, .and, .or, .not, .eq, .ne, .lt, .gt,
	.le, .ge, .add, .sub, .mul, .div, .rem, .sll, .srl, .sra, .bitand,
	.bitor, .bitxor, bitinv, .car, .cdr, .caar, .cadr, .cdar, .cddr.
	(pmacros-init!): Initialize -smacro-table.
	Rewrite pmacro initialization.
	* read.scm (reader-process-expanded): Renamed from
	-reader-process-expanded.  All callers updated.
	Recognize () as a no-op.
	(cpu-load): Tweak logging messages.
	* utils.scm (message): Add comment.
	* cpu/play.cpu: Add some instructions to play with .let.
	* doc/cgenint.texi: Move some debugging related docs to here from
	cgen.texi.
	* doc/pmacros.texi: Reorganize.  Add docs for new builtin pmacros.
	* testsuite/Makefile.am: New file.
	* testsuite/Makefile.in: New file.
	* testsuite/test-utils.sh.in: New file.
	* testsuite/run-tests.sh: New file.
	* testsuite/testsuite.cpu: New file.
	* testsuite/pmacros-1.test: New file.
@
text
@d326 1
a326 1
;; Process 1 or more macro-expanded entries.
d328 10
a337 13
(define (reader-process-expanded entry)
  ;; () is used to indicate a no-op
  (cond ((null? entry)
	 #f) ;; nothing to do
	;; `begin' is used to group a collection of entries into one,
	;; since pmacro can only return one expression (borrowed from
	;; Scheme of course).
	;; Recurse in case there are nested begins.
	((eq? (car entry) 'begin)
	 (for-each reader-process-expanded
		   (cdr entry)))
	(else
	 (-reader-process-expanded-1 entry)))
d350 1
a350 1
    (reader-process-expanded expansion))
d701 2
a702 2
  ; Rather than add cgen-internal specific stuff to pmacros.scm, we create
  ; the pmacro commands here.
d842 1
a842 1
  (logit 1 "Loading cpu description " file " ...\n")
d845 1
a845 1
  (logit 2 "Processing cpu description " file " ...\n")
@


1.18
log
@	* configure.in: Update version to 1.1.
	* configure: Regenerate.
	* read.scm (-CGEN-VERSION): Update to 1.1.0.
@
text
@d174 1
@


1.17
log
@	* dev.scm (cload): Change #:arch argument to take the path to the
	.cpu file instead of just the name of the architecture.
	* read.scm (arch-path): Remove trailing '/'.
	(cpu-load): Set `arch-path' to directory of .cpu file.
	(-cgen): Don't set `arch-path' here.
	(include): Update.
	* doc/porting.texi: Update.
@
text
@d66 1
a66 1
(define -CGEN-VERSION '(0 7 2))
@


1.17.2.1
log
@	* configure.in: Update version to 1.1.
	* configure: Regenerate.
	* read.scm (-CGEN-VERSION): Update to 1.1.0.
@
text
@d66 1
a66 1
(define -CGEN-VERSION '(1 1 0))
@


1.16
log
@Back out change in version number.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2001, 2006 Red Hat, Inc.
a697 1

d730 1
a730 1
; This is defered until define-arch is read.
d783 2
a784 2
  (logit 1 "Including file " (string-append arch-path file) " ...\n")
  (reader-read-file! (string-append arch-path file))
d834 2
d842 1
d1005 4
a1008 1
(define arch-path (string-append srcdir "/cpu/"))
a1087 1
		      (set! arch-path (string-append (dirname arg) "/"))
d1188 1
@


1.15
log
@	* read.scm (-CGEN-VERSION): Set version number to 1.1.0.
@
text
@d66 1
a66 1
(define -CGEN-VERSION '(1 1 0))
@


1.14
log
@2006-05-10  Dave Brolley  <brolley@@redhat.com>

        * read.scm (cmd-if): Provide the correct argument to reader-error. Add
        support for (if (application-is? <appname>) (...) (...)).
@
text
@d66 1
a66 1
(define -CGEN-VERSION '(0 7 2))
@


1.14.2.1
log
@Check in ARCompact simulator.  A valid configuration is arc-elf.
This is not quite finished and has most likely a few files that are
obsolete & not used, but it's good enough to run gcc regression tests.
@
text
@a2 1
; Copyright (C) 2007 Free Software Foundation.
a433 4
;(display (string-append "mach names:"))
;(write mach-names) (newline)
;(display (string-append "keep-mach:"))
;(write keep-mach) (newline)
@


1.13
log
@2006-05-10  Dave Brolley  <brolley@@redhat.com>

        * read.scm (-cgen): Add trailing "/" to arch-path.
        * utils.scm (dirname): Removed. dirname is a primitive function.
@
text
@d799 2
a800 2
  (if (not (memq (car test) '(keep-isa? keep-mach?)))
      (reader-error "only (if (keep-mach?|keep-isa? ...) ...) is currently supported"))
d813 6
@


1.12
log
@2006-05-09  Dave Brolley  <brolley@@redhat.com>

        * read.scm (include): Use arch-path as file location.
        (arch-path): Define it with a default setting.
        (-cgen): Update arch-path when "-a" option is specified.
@
text
@d1077 1
a1077 1
		      (set! arch-path (dirname arg))
@


1.11
log
@Make backtraces work more reliably.
* guile.scm: Set up debugging parameters, and enable debugging and
source positions while loading.
(cgen-call-with-debugging, cgen-debugging-stack-start): New
functions.
* read.scm: Don't set debugging parameters here.
(catch-with-backtrace): Function deleted.
(-cgen): Simply note the presence or absence of the -b option.
Pass the flag to cgen-call-with-debugging, so debugging is turned
off here if the user didn't request it, for faster computation.
(cgen): Call cgen-debugging-stack-start here, instead of
catch-with-backtrace.

* Makefile.am (GUILE): Explicitly load guile.scm here, and leave a
trailing -s.
(desc, html, opcodes, sim-arch, sim-cpu, gas-test, sim-test):
Don't write out the trailing -s here.
* Makefile.in: Regenerated.
* cgen-doc.scm, cgen-gas.scm, cgen-stest.scm): Don't load
fixup.scm here; let the caller decide which Scheme's customization
file to preload.
* dev.scm: Load guile.scm, not fixup.scm.
* fixup.scm: Deleted; contents have all moved to guile.scm.
* README: Doc fix.

* guile.scm (debug-write): New function.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2001 Red Hat, Inc.
d784 2
a785 2
  (logit 1 "Including file " file " ...\n")
  (reader-read-file! (string-append srcdir "/cpu/" file))
d997 2
d1077 1
@


1.10
log
@* read.scm (debug-repl): Temporarily redirect input and output to
/dev/tty while we debug, so we don't interfere with whatever CGEN
is reading or writing.
* utils.scm (setter-getter-fluid-let, with-input-and-output-to):
New functions.
@
text
@a89 14
; Don't use the debugging evaluator unless asked for.
(if (not (defined? 'DEBUG-EVAL))
    (define DEBUG-EVAL #f))

(if (and (not DEBUG-EVAL)
	 (memq 'debug-extensions *features*))
    (begin
      (debug-disable 'debug)
      (read-disable 'positions)
      ))

; Extend the default limits of the interpreter stack
(debug-set! stack 100000)

a901 18
; Used to ensure backtraces are printed if an error occurs.

(define (catch-with-backtrace thunk)
  (lazy-catch #t thunk
	      (lambda args
		;(display args (current-error-port))
		;(newline (current-error-port))
		; display-error takes 6 arguments.
		; If `quit' is called from elsewhere, it may not have 6
		; arguments.  Not sure how best to handle this.
		(if (= (length args) 5)
		    (begin
		      (apply display-error #f (current-error-port) (cdr args))
		      (save-stack)
		      (backtrace)))
		(quit 1)))
)

d1059 1
d1077 1
a1077 9
		      (if (memq 'debug-extensions *features*)
			  (begin
			    (debug-enable 'backtrace)
			    (debug-enable 'debug)
			    (debug-enable 'backwards)
			    (debug-set! depth 2000)
			    (debug-set! maxdepth 2000)
			    (debug-set! frames 10)
			    (read-enable 'positions)))
d1131 38
a1168 34
	(if (not arch-file)
	    (error "-a option missing, no architecture specified"))

	(if repl?
	    (debug-repl nil))
	(cpu-load arch-file
		  keep-mach keep-isa flags
		  app-init! app-finish! app-analyze!)
	; Start another repl loop if -d.
	; Awkward.  Both places are useful, though this is more useful.
	(if repl?
	    (debug-repl nil))

	; Done with processing the arguments.
	; Application arguments are processed in two passes.
	; This is because the app may have arguments that specify things
	; that affect file generation (e.g. to specify another input file)
	; and we don't want to require an ordering of the options.

	(for-each (lambda (opt-arg)
		    (let ((opt (car opt-arg))
			  (arg (cdr opt-arg)))
		      (if (cadr opt)
			  ((opt-get-first-pass opt) arg)
			  ((opt-get-first-pass opt)))))
		  (reverse app-args))

	(for-each (lambda (opt-arg)
		    (let ((opt (car opt-arg))
			  (arg (cdr opt-arg)))
		      (if (cadr opt)
			  ((opt-get-second-pass opt) arg)
			  ((opt-get-second-pass opt)))))
		  (reverse app-args))
a1174 4
; Cover fn to -cgen that uses catch-with-backtrace.
; ??? (debug-enable 'backtrace) might also work except I seem to remember
; having problems with it.  They may be fixed now.

d1177 1
a1177 1
    (catch-with-backtrace (lambda () (apply -cgen args))))
@


1.9
log
@2003-09-08  Dave Brolley  <brolley@@redhat.com>

        On behalf of Doug Evans <dje@@sebabeach.org>
        Pass in paths to input files, instead of assuming they live in
        $srcdir/cpu.  Plus misc. option processing cleanup.
        * cgen-doc.scm (doc-arguments): Make options strings not symbols.
        Add pre-process pass to all options.
        * cgen-gas.scm (gas-arguments): Ditto.
        * cgen-sid.scm (sim-arguments): Ditto.
        * cgen-sim.scm (sim-arguments): Ditto.
        * cgen-stest.scm (stest-arguments): Ditto.
        * cgen-opc.scm (opc-arguments): Ditto.  New argument -OPC.
        (-opc-file-path): New global.
        (opc-file-path): New fn.
        * opcodes.scm (read-cpu.opc): Replace srcdir,cpu args with opc-file.
        All callers updated.
        (gen-extra-cpu.h,gen-extra-cpu.c,gen-extra-opc.h,gen-extra-opc.c,
        gen-extra-asm.c,gen-extra-dis.c,gen-extra-ibld.h,gen-extra-ibld.c):
        Replace srcdir arg with opc-file.  All callers updated.
        * read.scm (-opt-spec-update): Delete.
        (opt-get-first-pass,opt-get-second-pass): New fns.
        (-cgen): Process application-specific arguments in two passes.
@
text
@d955 11
d978 10
a987 7
  (set! debug-env env-alist)
  (let loop ()
    (let ((rc (top-repl)))
      (if (null? rc)
	  (quit 1)) ; indicate error to `make'
      (if (not (equal? rc '(0)))
	  (loop))))
@


1.8
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@a915 11
; Convert old style option spec to new style.
; This involves converting a symbol option name to a string.

(define (-opt-spec-update spec-list)
  (map (lambda (spec)
	 (if (symbol? (car spec))
	     (cons (symbol->string (car spec)) (cdr spec))
	     spec))
       spec-list)
)

d1001 1
a1001 1
  '(("-a" "arch"      "set arch, specifies name of .cpu file to load")
d1015 6
d1069 1
a1069 1
	    (opt-spec (append common-arguments (-opt-spec-update opt-spec)))
d1072 1
a1072 1
	    (arch #f)
d1091 1
a1091 1
		      (set! arch arg)
d1156 1
a1156 1
	(if (not arch)
d1161 1
a1161 1
	(cpu-load (string-append srcdir "/cpu/" arch ".cpu")
d1169 13
a1181 2
	; Done with processing the arguments.  Call the application's
	; file generators.
d1187 2
a1188 2
			  ((cadddr opt) arg)
			  ((cadddr opt)))))
@


1.7
log
@	* mach.scm (current-*-add!): Disallow redefinition.  Make result
	"unspecified".
	* insn.scm (insn-builtin!): Don't define relaxable here, now defined in
	operand.scm.
	* operand.scm (operand-builtin!): Define RELAXABLE for insns too.
	* cpu/m32r.cpu (disp8,disp24): RELAX renamed to RELAXABLE.

	* gen-all-doc: Split arm and frv docs up a bit.

	* cpu/arm.cpu: Add IDOC attribute.
	* cpu/frv.cpu: Ditto.
	* cpu/i960.cpu: Ditto.
	* cpu/openrisc.cpu: Ditto.
	* cpu/xstormy16.cpu: Ditto.
	* cpu/m32r.cpu: Ditto.
	(all insns): Explicitly specify IDOC attribute.

	* Makefile.am (MACH,ISAS,INSN_FILE_NAME): New vars.
	(desc,opcodes,sim-arch,sim-cpu,gas-test,sim-test): Use MACH,ISAS.
	(html): Use MACH,ISAS,INSN_FILE_NAME.  Generate insn.html separately.
	* Makefile.in: Regenerate.
	* attr.scm (<integer-attribute>:parse-value-def): Implement.
	(-attr-read): Defer computing default value until we know the type.
	(attr-has-attr?): Delete, move contents to <attr-list>:has-attr?.
	(<attr-list>:attr-present?): New method.
	(atlist-attr-present?,obj-attr-present?): New fns.
	(obj-has-attr-value?,obj-has-attr-value-no-default?): New fns.
	(attr-builtin!): New insn attr IDOC.
	* cgen-doc.scm (doc-arguments): New args -I,-N.
	* enum.scm (parse-enum-vals): New arg errtxt, all callers updated.
	Support comment as fourth element of enum value.
	(enum-val-name,enum-val-value,enum-val-attrs,enum-val-comment): New fns.
	* html.scm (gen-html-header): New arg kind, all callers updated.
	(gen-table-of-contents): New arg insn-file, all callers updated.
	(gen-list-entry,gen-doc-header): New fn.
	(get-operands): Delete.
	(gen-iformat-table): Rewrite.
	(gen-insn-doc-1): Print constant-folded and trimmed semantics.
	(gen-insn-doc-list): New args name, comment, insns.  All callers updated.
	(get-insn-properties,guess-insn-idoc-attr!): New fn.
	(insn-sets-pc?,insn-refs-mem?,insn-uses-fpu?): New fns.
	(get-insns-for-category,gen-categories-insn-lists): New fns.
	(gen-insn-docs): Simplify each insn's semantics first.
	Print insn tables sorted by IDOC categories.
	(*insn-html-file-name*): New global.
	(cgen-insn.html): New fn.
	(cgen-all): Update.
	* insn.scm (<insn>): Create a setter for the `tmp' member.
	* semantics.scm (insn-build-known-values): Renamed from
	-build-known-values.  All callers updated.

	* rtl.scm: Move traveral/evaluation support to ...
	* rtl-traverse.scm: New file.
	* read.scm: Maybe-load rtl-traverse.scm.

	* rtl.scm (-rtx-valid-types): Add SETRTX.

	* rtx-funcs.scm (nop,parallel): Fix mode.

	* utils.scm (eqv-lookup-index): New fn.
	(assq-lookup-index): Renamed from lookup-index.  All callers updated.

	* dev.scm (load-doc): Set APPLICATION.
@
text
@d494 1
a494 1
	(keep-mach? (map string->symbol (string-cut machs #\,)))))
d610 1
a610 1
    (keep-isa? (map string->symbol (string-cut isas #\,))))
d818 1
a818 1
	 (eval then)
d821 1
a821 1
	     (eval (car else)))))
d824 1
a824 1
	 (eval then)
d827 1
a827 1
	     (eval (car else))))))
@


1.6
log
@2001-07-05  Ben Elliston  <bje@@redhat.com>

	* README: Update.

	* read.scm (include): Include files from srcdir/cpu.
	(-cgen): Likewise for loading .cpu files.
	* *.cpu: Move all cpu descriptions into cpu subdirectory.
	* *.opc: Likewise.
	* simplify.inc: Likewise.
@
text
@d187 1
@


1.5
log
@2001-07-04  Ben Elliston  <bje@@redhat.com>

	* read.scm (include): Log "Including file" message at level 1,
	rather than outputting it with (display).
	(cpu-load): Log "Loading cpu description" and "Processing cpu
	description" messages at levels 1 and 2, respectively, rather than
	using (display).
@
text
@d798 1
a798 1
  (reader-read-file! (string-append srcdir "/" file))
d1165 1
a1165 1
	(cpu-load (string-append srcdir "/" arch ".cpu")
@


1.4
log
@2001-03-24  Ben Elliston  <bje@@redhat.com>

	* gas-test.scm (<hw-asm>,test-data): Choose pseudo-random data.
	(<keyword>,test-data): Likewise.
	(<hw-address>,test-data): Likewise.
	(<hw-iaddress>,test-data): Likewise.
	(-collate-test-set): New function.
	(build-test-set): Use it.
	(gen-gas-test): Generate five test cases per instruction.
	(cgen-allinsn.exp): Include "-*- Tcl -*-" in DejaGNU test file.

	* read.scm: Load "slib/random" if random is not defined.
	* slib/random.scm: New file.
@
text
@d797 1
a797 1
  (display (string-append "Including file " file " ...\n"))
a845 1

d847 1
a847 6

  ; This used to be done here, but is now defered until define-arch.
  ;(reader-install-builtin!)

  (display (string-append "Loading cpu file " file " ...\n"))

d849 1
a849 2

  (display (string-append "Processing cpu file " file " ...\n"))
@


1.3
log
@* cleanup

2001-01-08  Frank Ch. Eigler  <fche@@redhat.com>

	* rtl.scm (hw): Copy hw-name to new operand's sem-name, to simplify
	its subsequent gen-pretty-name.

	* read.scm: Increase thread working stack limit and backtrace
	depth limits.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
d61 1
a61 2
; - stay away from non-portable C symbols, it makes using hobbit more difficult
;   e.g. don't have anything named `index', sigh.
d169 1
@


1.2
log
@* fixes to handle 64-bit ints properly

2000-09-21  Frank Ch. Eigler  <fche@@redhat.com>

	* slib/logical.scm: New file from slib.  Provides robust bitwise
	logical operations for large integers.
	* read.scm: maybe-load it.
@
text
@d102 3
d1110 2
a1111 1
			    (debug-set! depth 200)
@


1.1
log
@Initial revision
@
text
@d162 1
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
