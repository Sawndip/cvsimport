head	1.34;
access;
symbols
	sid-snapshot-20180601:1.34
	cgen-snapshot-20180601:1.34
	sid-snapshot-20180501:1.34
	cgen-snapshot-20180501:1.34
	sid-snapshot-20180401:1.34
	cgen-snapshot-20180401:1.34
	sid-snapshot-20180301:1.34
	cgen-snapshot-20180301:1.34
	sid-snapshot-20180201:1.34
	cgen-snapshot-20180201:1.34
	sid-snapshot-20180101:1.34
	cgen-snapshot-20180101:1.34
	sid-snapshot-20171201:1.34
	cgen-snapshot-20171201:1.34
	sid-snapshot-20171101:1.34
	cgen-snapshot-20171101:1.34
	sid-snapshot-20171001:1.34
	cgen-snapshot-20171001:1.34
	sid-snapshot-20170901:1.34
	cgen-snapshot-20170901:1.34
	sid-snapshot-20170801:1.34
	cgen-snapshot-20170801:1.34
	sid-snapshot-20170701:1.34
	cgen-snapshot-20170701:1.34
	sid-snapshot-20170601:1.34
	cgen-snapshot-20170601:1.34
	sid-snapshot-20170501:1.34
	cgen-snapshot-20170501:1.34
	sid-snapshot-20170401:1.34
	cgen-snapshot-20170401:1.34
	sid-snapshot-20170301:1.34
	cgen-snapshot-20170301:1.34
	sid-snapshot-20170201:1.34
	cgen-snapshot-20170201:1.34
	sid-snapshot-20170101:1.34
	cgen-snapshot-20170101:1.34
	sid-snapshot-20161201:1.34
	cgen-snapshot-20161201:1.34
	sid-snapshot-20161101:1.34
	cgen-snapshot-20161101:1.34
	sid-snapshot-20160901:1.34
	cgen-snapshot-20160901:1.34
	sid-snapshot-20160801:1.34
	cgen-snapshot-20160801:1.34
	sid-snapshot-20160701:1.34
	cgen-snapshot-20160701:1.34
	sid-snapshot-20160601:1.34
	cgen-snapshot-20160601:1.34
	sid-snapshot-20160501:1.34
	cgen-snapshot-20160501:1.34
	sid-snapshot-20160401:1.34
	cgen-snapshot-20160401:1.34
	sid-snapshot-20160301:1.34
	cgen-snapshot-20160301:1.34
	sid-snapshot-20160201:1.34
	cgen-snapshot-20160201:1.34
	sid-snapshot-20160101:1.34
	cgen-snapshot-20160101:1.34
	sid-snapshot-20151201:1.34
	cgen-snapshot-20151201:1.34
	sid-snapshot-20151101:1.34
	cgen-snapshot-20151101:1.34
	sid-snapshot-20151001:1.34
	cgen-snapshot-20151001:1.34
	sid-snapshot-20150901:1.34
	cgen-snapshot-20150901:1.34
	sid-snapshot-20150801:1.34
	cgen-snapshot-20150801:1.34
	sid-snapshot-20150701:1.34
	cgen-snapshot-20150701:1.34
	sid-snapshot-20150601:1.34
	cgen-snapshot-20150601:1.34
	sid-snapshot-20150501:1.34
	cgen-snapshot-20150501:1.34
	sid-snapshot-20150401:1.34
	cgen-snapshot-20150401:1.34
	sid-snapshot-20150301:1.34
	cgen-snapshot-20150301:1.34
	sid-snapshot-20150201:1.34
	cgen-snapshot-20150201:1.34
	sid-snapshot-20150101:1.34
	cgen-snapshot-20150101:1.34
	sid-snapshot-20141201:1.34
	cgen-snapshot-20141201:1.34
	sid-snapshot-20141101:1.34
	cgen-snapshot-20141101:1.34
	sid-snapshot-20141001:1.34
	cgen-snapshot-20141001:1.34
	sid-snapshot-20140901:1.34
	cgen-snapshot-20140901:1.34
	sid-snapshot-20140801:1.34
	cgen-snapshot-20140801:1.34
	sid-snapshot-20140701:1.34
	cgen-snapshot-20140701:1.34
	sid-snapshot-20140601:1.34
	cgen-snapshot-20140601:1.34
	sid-snapshot-20140501:1.34
	cgen-snapshot-20140501:1.34
	sid-snapshot-20140401:1.34
	cgen-snapshot-20140401:1.34
	sid-snapshot-20140301:1.34
	cgen-snapshot-20140301:1.34
	sid-snapshot-20140201:1.34
	cgen-snapshot-20140201:1.34
	sid-snapshot-20140101:1.34
	cgen-snapshot-20140101:1.34
	sid-snapshot-20131201:1.34
	cgen-snapshot-20131201:1.34
	sid-snapshot-20131101:1.34
	cgen-snapshot-20131101:1.34
	sid-snapshot-20131001:1.34
	cgen-snapshot-20131001:1.34
	sid-snapshot-20130901:1.34
	cgen-snapshot-20130901:1.34
	sid-snapshot-20130801:1.34
	cgen-snapshot-20130801:1.34
	sid-snapshot-20130701:1.34
	cgen-snapshot-20130701:1.34
	sid-snapshot-20130601:1.34
	cgen-snapshot-20130601:1.34
	sid-snapshot-20130501:1.34
	cgen-snapshot-20130501:1.34
	sid-snapshot-20130401:1.34
	cgen-snapshot-20130401:1.34
	sid-snapshot-20130301:1.34
	cgen-snapshot-20130301:1.34
	sid-snapshot-20130201:1.34
	cgen-snapshot-20130201:1.34
	sid-snapshot-20130101:1.34
	cgen-snapshot-20130101:1.34
	sid-snapshot-20121201:1.34
	cgen-snapshot-20121201:1.34
	sid-snapshot-20121101:1.34
	cgen-snapshot-20121101:1.34
	sid-snapshot-20121001:1.34
	cgen-snapshot-20121001:1.34
	sid-snapshot-20120901:1.34
	cgen-snapshot-20120901:1.34
	sid-snapshot-20120801:1.34
	cgen-snapshot-20120801:1.34
	sid-snapshot-20120701:1.34
	cgen-snapshot-20120701:1.34
	sid-snapshot-20120601:1.34
	cgen-snapshot-20120601:1.34
	sid-snapshot-20120501:1.34
	cgen-snapshot-20120501:1.34
	sid-snapshot-20120401:1.34
	cgen-snapshot-20120401:1.34
	sid-snapshot-20120301:1.34
	cgen-snapshot-20120301:1.34
	sid-snapshot-20120201:1.34
	cgen-snapshot-20120201:1.34
	sid-snapshot-20120101:1.34
	cgen-snapshot-20120101:1.34
	sid-snapshot-20111201:1.34
	cgen-snapshot-20111201:1.34
	sid-snapshot-20111101:1.34
	cgen-snapshot-20111101:1.34
	sid-snapshot-20111001:1.34
	cgen-snapshot-20111001:1.34
	sid-snapshot-20110901:1.34
	cgen-snapshot-20110901:1.34
	sid-snapshot-20110801:1.34
	cgen-snapshot-20110801:1.34
	sid-snapshot-20110701:1.34
	cgen-snapshot-20110701:1.34
	sid-snapshot-20110601:1.34
	cgen-snapshot-20110601:1.34
	sid-snapshot-20110501:1.34
	cgen-snapshot-20110501:1.34
	sid-snapshot-20110401:1.34
	cgen-snapshot-20110401:1.34
	sid-snapshot-20110301:1.34
	cgen-snapshot-20110301:1.34
	sid-snapshot-20110201:1.34
	cgen-snapshot-20110201:1.34
	sid-snapshot-20110101:1.34
	cgen-snapshot-20110101:1.34
	sid-snapshot-20101201:1.34
	cgen-snapshot-20101201:1.34
	sid-snapshot-20101101:1.34
	cgen-snapshot-20101101:1.34
	sid-snapshot-20101001:1.34
	cgen-snapshot-20101001:1.34
	sid-snapshot-20100901:1.34
	cgen-snapshot-20100901:1.34
	sid-snapshot-20100801:1.34
	cgen-snapshot-20100801:1.34
	sid-snapshot-20100701:1.34
	cgen-snapshot-20100701:1.34
	sid-snapshot-20100601:1.34
	cgen-snapshot-20100601:1.34
	sid-snapshot-20100501:1.34
	cgen-snapshot-20100501:1.34
	sid-snapshot-20100401:1.34
	cgen-snapshot-20100401:1.34
	sid-snapshot-20100301:1.34
	cgen-snapshot-20100301:1.34
	sid-snapshot-20100201:1.32
	cgen-snapshot-20100201:1.32
	sid-snapshot-20100101:1.31
	cgen-snapshot-20100101:1.31
	sid-snapshot-20091201:1.31
	cgen-snapshot-20091201:1.31
	sid-snapshot-20091101:1.28
	cgen-snapshot-20091101:1.28
	sid-snapshot-20091001:1.28
	cgen-snapshot-20091001:1.28
	arc-sim-20090309:1.12
	sid-snapshot-20090901:1.20
	cgen-snapshot-20090901:1.20
	sid-snapshot-20090801:1.15
	cgen-snapshot-20090801:1.15
	sid-snapshot-20090701:1.13
	cgen-snapshot-20090701:1.13
	dje-cgen-play1-branch:1.13.0.2
	dje-cgen-play1-branchpoint:1.13
	cgen-1_1-branch:1.12.0.6
	cgen-1_1-branchpoint:1.12
	sid-snapshot-20090601:1.12
	cgen-snapshot-20090601:1.12
	sid-snapshot-20090501:1.12
	cgen-snapshot-20090501:1.12
	sid-snapshot-20090401:1.12
	cgen-snapshot-20090401:1.12
	arc-insight_6_8-branch:1.12.0.4
	arc-insight_6_8-branchpoint:1.12
	sid-snapshot-20090301:1.12
	cgen-snapshot-20090301:1.12
	sid-snapshot-20090201:1.12
	cgen-snapshot-20090201:1.12
	sid-snapshot-20090101:1.12
	cgen-snapshot-20090101:1.12
	sid-snapshot-20081201:1.12
	cgen-snapshot-20081201:1.12
	sid-snapshot-20081101:1.12
	cgen-snapshot-20081101:1.12
	sid-snapshot-20081001:1.12
	cgen-snapshot-20081001:1.12
	sid-snapshot-20080901:1.12
	cgen-snapshot-20080901:1.12
	sid-snapshot-20080801:1.12
	cgen-snapshot-20080801:1.12
	sid-snapshot-20080701:1.12
	cgen-snapshot-20080701:1.12
	sid-snapshot-20080601:1.12
	cgen-snapshot-20080601:1.12
	sid-snapshot-20080501:1.12
	cgen-snapshot-20080501:1.12
	sid-snapshot-20080403:1.12
	sid-snapshot-20080401:1.12
	cgen-snapshot-20080401:1.12
	sid-snapshot-20080301:1.12
	cgen-snapshot-20080301:1.12
	sid-snapshot-20080201:1.12
	cgen-snapshot-20080201:1.12
	sid-snapshot-20080101:1.12
	cgen-snapshot-20080101:1.12
	sid-snapshot-20071201:1.12
	cgen-snapshot-20071201:1.12
	sid-snapshot-20071101:1.12
	cgen-snapshot-20071101:1.12
	sid-snapshot-20071001:1.12
	cgen-snapshot-20071001:1.12
	msnyder-fork-checkpoint-branch:1.12.0.2
	msnyder-fork-checkpoint-branchpoint:1.12
	sid-20020905-branchpoint:1.4
	sid-20020905-branch:1.4.0.6
	cagney_regbuf-20020515-branch:1.4.0.4
	cagney_regbuf-20020515-branchpoint:1.4
	cygnus_cvs_20020108_pre:1.4
	cgen-1-1-branch:1.4.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.34
date	2010.02.13.03.39.15;	author devans;	state Exp;
branches;
next	1.33;

1.33
date	2010.02.12.02.12.12;	author devans;	state Exp;
branches;
next	1.32;

1.32
date	2010.01.25.00.40.29;	author devans;	state Exp;
branches;
next	1.31;

1.31
date	2009.11.21.09.36.47;	author devans;	state Exp;
branches;
next	1.30;

1.30
date	2009.11.05.16.55.33;	author devans;	state Exp;
branches;
next	1.29;

1.29
date	2009.11.03.16.24.02;	author devans;	state Exp;
branches;
next	1.28;

1.28
date	2009.09.28.02.40.49;	author devans;	state Exp;
branches;
next	1.27;

1.27
date	2009.09.25.19.40.08;	author devans;	state Exp;
branches;
next	1.26;

1.26
date	2009.09.23.22.30.19;	author devans;	state Exp;
branches;
next	1.25;

1.25
date	2009.09.12.17.34.15;	author devans;	state Exp;
branches;
next	1.24;

1.24
date	2009.09.10.07.23.29;	author devans;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.09.20.43.04;	author devans;	state Exp;
branches;
next	1.22;

1.22
date	2009.09.09.17.06.19;	author devans;	state Exp;
branches;
next	1.21;

1.21
date	2009.09.07.22.17.34;	author devans;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.27.04.22.56;	author devans;	state Exp;
branches;
next	1.19;

1.19
date	2009.08.22.23.16.01;	author devans;	state Exp;
branches;
next	1.18;

1.18
date	2009.08.18.16.34.41;	author devans;	state Exp;
branches;
next	1.17;

1.17
date	2009.08.12.22.33.37;	author devans;	state Exp;
branches;
next	1.16;

1.16
date	2009.08.06.16.40.43;	author devans;	state Exp;
branches;
next	1.15;

1.15
date	2009.07.21.04.23.59;	author devans;	state Exp;
branches;
next	1.14;

1.14
date	2009.07.18.20.44.58;	author devans;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches;
next	1.12;

1.12
date	2005.10.24.22.56.45;	author dj;	state Exp;
branches
	1.12.6.1;
next	1.11;

1.11
date	2005.07.29.18.51.24;	author brolley;	state Exp;
branches;
next	1.10;

1.10
date	2005.06.15.21.28.18;	author brolley;	state Exp;
branches;
next	1.9;

1.9
date	2005.02.16.19.45.36;	author brolley;	state Exp;
branches;
next	1.8;

1.8
date	2003.07.16.05.35.47;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.10.21.58.33;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.10.21.22.03;	author devans;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.20.06.39.04;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.29.18.56.26;	author fche;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.24.15.35.47;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.22.19.14.30;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.12.6.1
date	2009.06.24.14.57.46;	author devans;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.34
log
@update copyright year
@
text
@; Operands
; Copyright (C) 2000, 2001, 2005, 2009, 2010 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.

; Operands map a set of values (registers, whatever) to an instruction field
; or other indexing mechanism.  Operands are also how the semantic code refers
; to hardware elements.

; The `<operand>' class.
;
; ??? Need a new lighterweight version for instances in semantics.
; This should only contain the static elements from the description file.
;
; ??? Derived operands don't use all the current class members.  Perhaps
; split <operand> into two.

(define <operand>
  (class-make '<operand>
	      '(<source-ident>)
	      '(
		; Name as used in semantic code.
		; Generally this is the same as NAME.  It is changed by the
		; `operand:' rtx function.  One reason is to set a "pretty"
		; name in tracing output (most useful in memory operands).
		; A more important reason is to help match semantic operands
		; with function unit input/output arguments.
		sem-name

		; Pretty name as used in tracing code.
		; Generally this is the same as the hardware element's name.
		pretty-sem-name

		; Semantic name of hardware element refered to by this operand.
		hw-name

		; Hardware type of operand, a subclass of <hardware-base>.
		; This is computed lazily from HW-NAME as many hardware
		; elements can have the same semantic name.  Applications
		; that require a unique hardware element to be refered to are
		; required to ensure duplicates are discarded (usually done
		; by keeping the appropriate machs).
		; All h/w elements with the same semantic name are required
		; to be the same kind (register, immediate, etc.).
		; FIXME: Rename to hw.
		(type . #f)

		; Name of mode, as specified in description file.
		; This needn't be the actual mode, as WI will get coerced
		; to the actual word int mode.
		mode-name

		; The mode TYPE is being referenced in.
		; This is also looked up lazily for the same reasons as TYPE.
		(mode . #f)

		; Selector.
		; A number or #f used to select a variant of the hardware
		; element.  An example is ASI's on sparc.
		; ??? I really need to be better at picking names.
		(selector . #f)

		; Index into type, class <hw-index>.
		; For example in the case of an array of registers
		; it can be an instruction field or in the case of a memory
		; reference it can be a register operand (or general rtx).
		; ??? At present <hw-index> is a facade over the real index
		; type.  Not sure what the best way to do this is.
		(index . #f)

		; Code to run when the operand is read or #f meaning pass
		; the request on to the hardware object.
		(getter . #f)

		; Code to run when the operand is written or #f meaning pass
		; the request on to the hardware object.
		(setter . #f)

		; Associative list of (symbol . "handler") entries.
		; Each entry maps an operation to its handler (which is up to
		; the application but is generally a function name).
		(handlers . ())

		; Ordinal number of the operand in an insn's semantic
		; description.  There is no relation between the number and
		; where in the semantics the operand appears.  An operand that
		; is both read and written are given separate ordinal numbers
		; (inputs are treated separately from outputs).
		(num . -1)

		; Boolean indicating if the operand is conditionally
		; referenced.  #f means the operand is always referenced by
		; the instruction.
		(cond? . #f)
		
		; whether (and by how much) this instance of the operand is
		; delayed.
		(delayed . #f)
		)
	      nil)
)

; The default make! assigns the default h/w selector.

(method-make!
 <operand> 'make!
 (lambda (self location name comment attrs
	       hw-name mode-name index handlers getter setter)
   (elm-set! self 'location location)
   (elm-set! self 'name name)
   (elm-set! self 'sem-name name)
   (elm-set! self 'pretty-sem-name hw-name)
   (elm-set! self 'comment comment)
   (elm-set! self 'attrs attrs)
   (elm-set! self 'hw-name hw-name)
   (elm-set! self 'mode-name mode-name)
   (elm-set! self 'selector hw-selector-default)
   (elm-set! self 'index index)
   (elm-set! self 'handlers handlers)
   (elm-set! self 'getter getter)
   (elm-set! self 'setter setter)
   self)
)

; FIXME: The prefix field- doesn't seem right.  Indices needn't be
; ifields, though for operands defined in .cpu files they usually are.
(method-make-forward! <operand> 'index '(field-start field-length))

; Accessor fns

(define op:sem-name (elm-make-getter <operand> 'sem-name))
(define op:set-sem-name! (elm-make-setter <operand> 'sem-name))
(define op:set-pretty-sem-name! (elm-make-setter <operand> 'pretty-sem-name))
(define op:hw-name (elm-make-getter <operand> 'hw-name))
(define op:mode-name (elm-make-getter <operand> 'mode-name))
(define op:selector (elm-make-getter <operand> 'selector))
; FIXME: op:index should be named op:hwindex.
(define op:index (elm-make-getter <operand> 'index))
(define op:handlers (elm-make-getter <operand> 'handlers))
(define op:getter (elm-make-getter <operand> 'getter))
(define op:setter (elm-make-getter <operand> 'setter))
(define op:num (elm-make-getter <operand> 'num))
(define op:set-num! (elm-make-setter <operand> 'num))
(define op:cond? (elm-make-getter <operand> 'cond?))
(define op:set-cond?! (elm-make-setter <operand> 'cond?))
(define op:delay (elm-make-getter <operand> 'delayed))
(define op:set-delay! (elm-make-setter <operand> 'delayed))

; Compute the hardware type lazily.
; FIXME: op:type should be named op:hwtype or some such.

(define op:type
  (let ((getter (elm-make-getter <operand> 'type)))
    (lambda (op)
      (let ((type (getter op)))
	(if type
	    type
	    (let* ((hw-name (op:hw-name op))
		   (hw-objs (current-hw-sem-lookup hw-name)))
	      (if (!= (length hw-objs) 1)
		  (error "cannot resolve h/w reference" hw-name))
	      ((elm-make-setter <operand> 'type) op (car hw-objs))
	      (car hw-objs))))))
)

; Compute the operand's mode lazily (depends on hardware type which is
; computed lazily).

(define op:mode
  (let ((getter (elm-make-getter <operand> 'mode)))
    (lambda (op)
      (let ((mode (getter op)))
	(if mode
	    mode
	    (let ((mode-name (op:mode-name op))
		  (type (op:type op)))
	      (let ((mode (if (eq? mode-name 'DFLT)
			      (hw-default-mode type)
			      (mode:lookup mode-name))))
		((elm-make-setter <operand> 'mode) op mode)
		mode))))))
)

(method-make! <operand> 'get-mode (lambda (self) (op:mode self)))

; FIXME: wip
; Result is the <ifield> object or #f if there is none.

(define (op-ifield op)
  (logit 4 "  op-ifield op= " (obj:name op)
	 ", indx= " (obj:name (op:index op)) "\n")
  (let ((indx (op:index op)))
    (if indx
	(let ((maybe-ifld (hw-index:value (op:index op))))
	  (logit 4 "  ifld=" (obj:name maybe-ifld) "\n")
	  (cond ((ifield? maybe-ifld) maybe-ifld)
		((derived-ifield? maybe-ifld) maybe-ifld)
		((ifield? indx) indx)
		((derived-ifield? indx) indx)
		(else #f)))
	#f))
)

; Return mode to use for index or #f if scalar.
; This can't use method-make-forward! as we need to call op:type to
; resolve the hardware reference.

(method-make!
 <operand> 'get-index-mode
 (lambda (self) (send (op:type self) 'get-index-mode))
)

; Return the operand's enum.

(define (op-enum op)
  (string-upcase (string-append "@@ARCH@@_OPERAND_" (gen-sym op)))
)

; Return a boolean indicating if X is an operand.

(define (operand? x) (class-instance? <operand> x))

; Default gen-pretty-name method.
; Return a C string of the name intended for users.
;
; FIXME: The current implementation is a quick hack.  Parallel execution
; support can create operands with long names.  e.g. h-memory-add-WI-src2-slo16
; The eventual way this will be handled is to record with each operand the
; entry number (or some such) in the operand instance table so that for
; registers we can compute the register's name.

(method-make!
 <operand> 'gen-pretty-name
 (lambda (self mode)
   (let* ((name (->string (if (elm-bound? self 'pretty-sem-name)
			      (elm-get self 'pretty-sem-name) 
			      (if (elm-bound? self 'sem-name)
				  (elm-get self 'sem-name)
				  (obj:name self)))))
	  (pname (cond ((string=? "h-memory" (string-take 8 name)) "memory")
		       ((string=? "h-" (string-take 2 name)) (string-drop 2 name))
		       (else name))))
     (string-append "\"" pname "\"")))
)

; Mode support.

; Create a copy of operand OP in mode NEW-MODE-NAME.
; NOTE: Even if the mode isn't changing this creates a copy.
; If OP has been subclassed the result must contain the complete class
; (e.g. the behaviour of `object-copy').
; NEW-MODE-NAME must be a valid numeric mode.

(define (op:new-mode op new-mode-name)
  (let ((result (object-copy op)))
    ; (logit 1 "op:new-mode op=" (op:sem-name op) 
    ;   " class=" (object-class-name op)
    ;   " hw-name=" (op:hw-name op)
    ;   " mode=" (op:mode op)
    ;   " newmode=" new-mode-name)
;    (if (or (eq? new-mode-name 'DFLT)
;	    (eq? new-mode-name 'VOID) ; temporary: for upward compatibility
;	    (mode:eq? new-mode-name (op:mode op)))
;	; Mode isn't changing.
;	result
    (if #t ;; FIXME
	; See if new mode is supported by the hardware.
	(if (hw-mode-ok? (op:type op) new-mode-name (op:index op))
	    (let ((new-mode (mode:lookup new-mode-name)))
	      (if (not new-mode)
		  (error "op:new-mode: internal error, bad mode"
			 new-mode-name))
	      (elm-xset! result 'mode-name new-mode-name)
	      (elm-xset! result 'mode new-mode)
	      result)
	    (parse-error (make-obj-context op "op:new-mode")
			 (string-append "invalid mode for operand `"
					(->string (obj:name op))
					"'")
			 new-mode-name))))
)

; Return #t if operand OP references its h/w element in its natural mode.

(define (op-natural-mode? op)
  (or (eq? (op:mode-name op) 'DFLT)
      (mode-compatible? 'samesize (op:mode op) (hw-default-mode (op:type op))))
)

; Ifield support.

; Return list of ifields used by OP.

(define (op-iflds-used op)
  (if (derived-operand? op)
      (collect op-iflds-used (derived-args op))
      ; else
      (let ((indx (op:index op)))
	(if (and (eq? (hw-index:type indx) 'ifield)
		 (not (= (ifld-length (hw-index:value indx)) 0)))
	    (ifld-needed-iflds (hw-index:value indx))
	    nil)))
)

; The `hw-index' class.
; [Was named `index' but that conflicts with the C library function and caused
; problems when using Hobbit.  And `index' is too generic a name anyway.]
;
; An operand combines a hardware object with its index.
; e.g. in an array of registers an operand serves to combine the register bank
; with the instruction field that chooses which one.
; Hardware elements are accessed via other means as well besides instruction
; fields so we need a way to designate something as being an index.
; The `hw-index' class does that.  It serves as a facade to the underlying
; details.
; ??? Not sure whether this is the best way to handle this or not.
;
; NAME is the name of the index or 'anonymous.
; This is used, for example, to give a name to the simulator extraction
; structure member.
; TYPE is a symbol that indicates what VALUE is.
; scalar: the hardware object is a scalar, no index is required
;         [MODE and VALUE are #f to denote "undefined" in this case]
; constant: a (non-negative) integer (FIXME: rename to const)
; enum: an enum value stored as (enum-name . (enum-lookup-val enum-name)),
;       i.e. (name value . enum-obj)
; str-expr: a C expression as a string
; rtx: an rtx to be expanded
; ifield: an <ifield> object
; derived-ifield: a <derived-ifield> object ???
; operand: an <operand> object
; ??? A useful simplification may be to always record the value as an rtx
; [which may require extensions to rtl so is deferred].
; ??? We could use runtime type identification, but doing things this way
; adds more structure.
;
; MODE is the mode of VALUE, as a <mode> object.
; If DFLT, mode must be obtained from VALUE.
; DFLT is only allowable for rtx and operand types.

(define <hw-index> (class-make '<hw-index> nil '(name type mode value) nil))

; Accessors.
; Use obj:name for `name'.
(define hw-index:type (elm-make-getter <hw-index> 'type))
(define hw-index:mode (elm-make-getter <hw-index> 'mode))
(define hw-index:value (elm-make-getter <hw-index> 'value))

; Allow the mode to be specified by its name.
(method-make!
 <hw-index> 'make!
 (lambda (self name type mode value)
   (elm-set! self 'name name)
   (elm-set! self 'type type)
   (elm-set! self 'mode (mode-maybe-lookup mode))
   (elm-set! self 'value value)
   self)
)

; get-name handler
(method-make!
 <hw-index> 'get-name
 (lambda (self)
   (elm-get self 'name))
)

; get-atlist handler
(method-make!
 <hw-index> 'get-atlist
 (lambda (self)
   (case (hw-index:type self)
     ((ifield) (obj-atlist (hw-index:value self)))
     (else atlist-empty)))
)

; ??? Until other things settle.
(method-make!
 <hw-index> 'field-start
 (lambda (self)
   (if (eq? (hw-index:type self) 'ifield)
       (send (hw-index:value self) 'field-start)
       0))
)
(method-make!
 <hw-index> 'field-length
 (lambda (self)
   (if (eq? (hw-index:type self) 'ifield)
       (send (hw-index:value self) 'field-length)
       0))
)

;; Return #t if index is a constant.

(define (hw-index-constant? hw-index)
  (memq (hw-index:type hw-index) '(constant enum))
)

;; Given that (hw-index-constant? hw-index) is true, return the value.

(define (hw-index-constant-value hw-index)
  (case (hw-index:type hw-index)
    ((constant) (hw-index:value hw-index))
    ((enum) (hw-index-enum-value hw-index))
    (else (error "invalid constant hw-index" hw-index)))
)

;; Make an enum <hw-index> given the enum's name.

(define (make-enum-hw-index name enum-name)
  (make <hw-index> name 'enum UINT
	(cons enum-name (enum-lookup-val enum-name)))
)

;; Given an enum <hw-index>, return the enum's name.

(define (hw-index-enum-name hw-index)
  (car (hw-index:value hw-index))
)

;; Given an enum <hw-index>, return the enum's value.

(define (hw-index-enum-value hw-index)
  (cadr (hw-index:value hw-index))
)

;; Given an enum <hw-index>, return the enum's object.

(define (hw-index-enum-obj hw-index)
  (cddr (hw-index:value hw-index))
)

; There only ever needs to be one of these objects, so create one.

(define hw-index-scalar
  ; We can't use `make' here as the make! method calls mode:lookup which
  ; (a) doesn't exist if we're compiled with Hobbit and mode.scm isn't
  ; and (b) will fail anyway since #f isn't a valid mode.
  (let ((scalar-index (new <hw-index>)))
    (elm-xset! scalar-index 'name 'hw-index-scalar)
    (elm-xset! scalar-index 'type 'scalar)
    (elm-xset! scalar-index 'mode #f)
    (elm-xset! scalar-index 'value #f)
    (lambda () scalar-index))
)

; Placeholder for indices of "anyof" operands.
; There only needs to be one of these, so we create one and always use that.

(define hw-index-anyof
  ; We can't use `make' here as the make! method calls mode:lookup which
  ; (a) doesn't exist if we're compiled with Hobbit and mode.scm isn't
  ; and (b) will fail anyway since #f isn't a valid mode.
  (let ((anyof-index (new <hw-index>)))
    (elm-xset! anyof-index 'name 'hw-index-anyof)
    (elm-xset! anyof-index 'type 'scalar)
    (elm-xset! anyof-index 'mode #f)
    (elm-xset! anyof-index 'value #f)
    (lambda () anyof-index))
)

(define hw-index-derived
  ; We can't use `make' here as the make! method calls mode:lookup which
  ; (a) doesn't exist if we're compiled with Hobbit and mode.scm isn't
  ; and (b) will fail anyway since #f isn't a valid mode.
  (let ((derived-index (new <hw-index>)))
    (elm-xset! derived-index 'name 'hw-index-derived)
    (elm-xset! derived-index 'type 'scalar)
    (elm-xset! derived-index 'mode #f)
    (elm-xset! derived-index 'value #f)
    (lambda () derived-index))
)

; Hardware selector support.
;
; A hardware "selector" is like an index except is along an atypical axis
; and thus is rarely used.  It exists to support things like ASI's on Sparc.

; What to pass to indicate "default selector".
; (??? value is temporary choice to be revisited).
(define hw-selector-default '(symbol NONE))

(define (hw-selector-default? sel) (equal? sel hw-selector-default))

; Hardware support.

; Return list of hardware elements refered to in OP-LIST
; with no duplicates.

(define (op-nub-hw op-list)
  ; Build a list of hw elements.
  (let ((hw-list (map (lambda (op)
			(if (hw-ref? op) ; FIXME: hw-ref? is undefined
			    op
			    (op:type op)))
		      op-list)))
    ; Now build an alist of (name . obj) elements, take the nub, then the cdr.
    ; ??? These lists tend to be small so sorting first is probably overkill.
    (map cdr
	 (alist-nub (alist-sort (map (lambda (hw) (cons (obj:name hw) hw))
				     hw-list)))))
)

; Parsing support.

; Utility of /operand-parse-[gs]etter to build the expected syntax,
; for use in error messages.

(define (/operand-g/setter-syntax rank setter?)
  (string-append "("
		 (string-drop1
		  (numbers->string (iota rank) " index"))
		 (if setter?
		     (if (>= rank 1)
			 " newval"
			 "newval")
		     "")
		 ") (expression)")
)

; Parse a getter spec.
; The syntax is (([index-names]) (... code ...)).
; Omit `index-names' for scalar objects.
; {rank} is the required number of elements in {index-names}.

(define (/operand-parse-getter context getter rank)
  (if (null? getter)
      #f ; use default
      (let ()
	(if (or (not (list? getter))
		(!= (length getter) 2)
		(not (and (list? (car getter))
			  (= (length (car getter)) rank))))
	    (parse-error context
			 (string-append "invalid getter, should be "
					(/operand-g/setter-syntax rank #f))
			 getter))
	(if (not (rtx? (cadr getter)))
	    (parse-error context "invalid rtx expression" getter))
	getter))
)

; Parse a setter spec.
; The syntax is (([index-names] newval) (... code ...)).
; Omit `index-names' for scalar objects.
; {rank} is the required number of elements in {index-names}.

(define (/operand-parse-setter context setter rank)
  (if (null? setter)
      #f ; use default
      (let ()
	(if (or (not (list? setter))
		(!= (length setter) 2)
		(not (and (list? (car setter))
			  (= (+ 1 (length (car setter)) rank)))))
	    (parse-error context
			 (string-append "invalid setter, should be "
					(/operand-g/setter-syntax rank #t))
			 setter))
	(if (not (rtx? (cadr setter)))
	    (parse-error context "invalid rtx expression" setter))
	setter))
)

; Parse an operand definition.
; This is the main routine for building an operand object from a
; description in the .cpu file.
; All arguments are in raw (non-evaluated) form.
; The result is the parsed object or #f if object isn't for selected mach(s).
; ??? This only takes insn fields as the index.  May need another proc (or an
; enhancement of this one) that takes other kinds of indices.

(define (/operand-parse context name comment attrs hw mode index handlers getter setter)
  (logit 2 "Processing operand " name " ...\n")

  ;; Pick out name first to augment the error context.
  (let* ((name (parse-name context name))
	 (context (context-append-name context name))
	 (atlist-obj (atlist-parse context attrs "cgen_operand"))
	 (isa-name-list (atlist-attr-value atlist-obj 'ISA #f)))

    ;; Verify all specified ISAs are valid.
    (if (not (all-true? (map current-isa-lookup isa-name-list)))
	(parse-error context "unknown isa in isa list" isa-name-list))

    (if (keep-atlist? atlist-obj #f)

	(let ((hw-objs (current-hw-sem-lookup hw))
	      (mode-obj (parse-mode-name context mode))
	      (index-val (cond ((integer? index)
				index)
			       ((and (symbol? index) (enum-lookup-val index))
				=> (lambda (x) x))
			       ((and (symbol? index) (current-ifld-lookup index isa-name-list))
				=> (lambda (x) x))
			       (else
				(if (symbol? index)
				    (parse-error context "unknown enum or ifield" index)
				    (parse-error context "invalid operand index" index))))))

	  (if (not mode-obj)
	      (parse-error context "unknown mode" mode))
	  ;; Disallow some obviously invalid numeric indices.
	  (if (and (number? index-val)
		   (or (not (integer? index-val))
		       (< index-val 0)))
	      (parse-error context "invalid integer index" index))
	  ;; If an enum is used, it must be non-negative.
	  (if (and (pair? index-val)
		   (< (car index-val) 0))
	      (parse-error context "negative enum value" index))
	  ;; NOTE: Don't validate HW until we know whether this operand
	  ;; will be kept or not.  If not, HW may have been discarded too.
	  (if (null? hw-objs)
	      (parse-error context "unknown hardware element" hw))

	  ;; At this point INDEX-VAL is either an integer, (value . enum-obj),
	  ;; or an <ifield> object.
	  ;; Since we can't look up the hardware element at this time
	  ;; [well, actually we should be able to with a bit of work],
	  ;; we determine scalarness from an index of f-nil.
	  (let ((hw-index
		  (cond ((integer? index-val)
			 (make <hw-index> (symbol-append 'i- name)
			       ;; FIXME: constant -> const
			       'constant UINT index-val))
			((pair? index-val) ;; enum?
			 (make <hw-index> (symbol-append 'i- name)
			       'enum UINT (cons index index-val)))
			((ifld-nil? index-val)
			 (hw-index-scalar))
			(else
			 (make <hw-index> (symbol-append 'i- name)
			       'ifield UINT index-val)))))
	    (make <operand>
	      (context-location context)
	      name
	      (parse-comment context comment)
	      ;; Copy FLD's attributes so one needn't duplicate attrs like
	      ;; PCREL-ADDR, etc.  An operand inherits the attributes of
	      ;; its field.  They are overridable of course, which is why we use
	      ;; `atlist-append' here.
	      (if (ifield? index-val)
		  (atlist-append atlist-obj (obj-atlist index-val))
		  atlist-obj)
	      hw ;; note that this is the hw's name, not an object
	      mode ;; ditto, this is a name, not an object
	      hw-index
	      (parse-handlers context '(parse print) handlers)
	      (/operand-parse-getter context getter (if scalar? 0 1))
	      (/operand-parse-setter context setter (if scalar? 0 1))
	      )))

	(begin
	  (logit 2 "Ignoring " name ".\n")
	  #f)))
)

; Read an operand description.
; This is the main routine for analyzing operands in the .cpu file.
; CONTEXT is a <context> object for error messages.
; ARG-LIST is an associative list of field name and field value.
; /operand-parse is invoked to create the <operand> object.

(define (/operand-read context . arg-list)
  (let (
	(name nil)
	(comment nil)
	(attrs nil)
	(type nil)
	(mode 'DFLT)     ; use default mode of TYPE
	(index nil)
	(handlers nil)
	(getter nil)
	(setter nil)
	)

    (let loop ((arg-list arg-list))
      (if (null? arg-list)
	  nil
	  (let ((arg (car arg-list))
		(elm-name (caar arg-list)))
	    (case elm-name
	      ((name) (set! name (cadr arg)))
	      ((comment) (set! comment (cadr arg)))
	      ((attrs) (set! attrs (cdr arg)))
	      ((type) (set! type (cadr arg)))
	      ((mode) (set! mode (cadr arg)))
	      ((index) (set! index (cadr arg)))
	      ((handlers) (set! handlers (cdr arg)))
	      ((getter) (set! getter (cdr arg)))
	      ((setter) (set! setter (cdr arg)))
	      (else (parse-error context "invalid operand arg" arg)))
	    (loop (cdr arg-list)))))

    ; Now that we've identified the elements, build the object.
    (/operand-parse context name comment attrs type mode index handlers
		    getter setter))
)

; Define an operand object, name/value pair list version.

(define define-operand
  (lambda arg-list
    (let ((op (apply /operand-read (cons (make-current-context "define-operand")
					 arg-list))))
      (if op
	  (current-op-add! op))
      op))
)

; Define an operand object, all arguments specified.

(define (define-full-operand name comment attrs type mode index handlers getter setter)
  (let ((op (/operand-parse (make-current-context "define-full-operand")
			    name comment attrs
			    type mode index handlers getter setter)))
    (if op
	(current-op-add! op))
    op)
)

; Derived operands.
;
; Derived operands are used to implement operands more complex than just
; the mapping of an instruction field to a register bank.  Their present
; raison d'etre is to create a new axis on which to implement the complex
; addressing modes of the i386 and m68k.  The brute force way of describing
; these instruction sets would be to have one `dni' per addressing mode
; per instruction.  What's needed is to abstract away the various addressing
; modes within something like operands.
;
; ??? While internally we end up with the "brute force" approach, in and of
; itself that's ok because it's an internal implementation issue.
; See <multi-insn>.
;
; ??? Another way to go is to have one dni per addressing mode.  That seems
; less clean though as one dni would be any of add, sub, and, or, xor, etc.
;
; ??? Some addressing modes have side-effects (e.g. pre-dec, etc. like insns).
; This can be represented, but if two operands have side-effects special
; trickery may be required to get the order of side-effects right.  Need to
; avoid any "trickery" at all.
;
; ??? Not yet handled are modelling parameters.
; ??? Not yet handled are the handlers,getter,setter spec of normal operands.
;
; ??? Division of class members b/w <operand> and <derived-operand> is wip.
; ??? As is potential introduction of other classes to properly organize
; things.

(define <derived-operand>
  (class-make '<derived-operand>
	      '(<operand>)
	      '(
		; Args (list of <operands> objects).
		args

		; Syntax string.
		syntax

		; Base ifield, common to all choices.
		; ??? experiment
		base-ifield

		; <derived-ifield> object.
		encoding

		; Assertions of any ifield values or #f if none.
		(ifield-assertion . #f)
		)
	      '())
)

;; <derived-operand> constructor.
;; MODE is a <mode> object.

(method-make!
 <derived-operand> 'make!
 (lambda (self name comment attrs mode
	       args syntax base-ifield encoding ifield-assertion
	       getter setter)
   (elm-set! self 'name name)
   (elm-set! self 'comment comment)
   (elm-set! self 'attrs attrs)
   (elm-set! self 'sem-name name)
   (elm-set! self 'pretty-sem-name #f) ;; FIXME
   (elm-set! self 'hw-name #f) ;; FIXME
   (elm-set! self 'mode mode)
   (elm-set! self 'mode-name (obj:name mode))
   (elm-set! self 'getter getter)
   (elm-set! self 'setter setter)
   ;; These are the additional fields in <derived-operand>.
   (elm-set! self 'args args)
   (elm-set! self 'syntax syntax)
   (elm-set! self 'base-ifield base-ifield)
   (elm-set! self 'encoding encoding)
   (elm-set! self 'ifield-assertion ifield-assertion)
   self)
)

(define (derived-operand? x) (class-instance? <derived-operand> x))

(define-getters <derived-operand> derived
  (args syntax base-ifield encoding ifield-assertion)
)

; "anyof" operands are subclassed from derived operands.
; They typically handle multiple addressing modes of CISC architectures.

(define <anyof-operand>
  (class-make '<anyof-operand>
	      '(<operand>)
	      '(
		; Base ifield, common to all choices.
		; FIXME: wip
		base-ifield

		; List of <derived-operand> objects.
		; ??? Maybe allow <operand>'s too?
		choices
		)
	      '())
)

(define (anyof-operand? x) (class-instance? <anyof-operand> x))

(method-make!
 <anyof-operand> 'make!
 (lambda (self name comment attrs mode-name base-ifield choices)
   (elm-set! self 'name name)
   (elm-set! self 'comment comment)
   (elm-set! self 'attrs attrs)
   (elm-set! self 'sem-name name)
   (elm-set! self 'pretty-sem-name #f) ;; FIXME
   (elm-set! self 'hw-name #f) ;; FIXME
   (elm-set! self 'mode-name mode-name)
   (elm-set! self 'base-ifield base-ifield)
   (elm-set! self 'choices choices)
   ; Set index to a special marker value.
   (elm-set! self 'index (hw-index-anyof))
   self)
)

(define-getters <anyof-operand> anyof (choices))

; Derived/Anyof parsing support.

; Subroutine of /derived-operand-parse to parse the encoding.
; The result is a <derived-ifield> object.
; The {owner} member still needs to be set!

(define (/derived-parse-encoding context isa-name-list operand-name encoding)
  (if (or (null? encoding)
	  (not (list? encoding)))
      (parse-error context "encoding not a list" encoding))
  (if (not (eq? (car encoding) '+))
      (parse-error context "encoding must begin with `+'" encoding))

  ; ??? Calling /parse-insn-format is a quick hack.
  ; It's an internal routine of some other file.
  (let ((iflds (/parse-insn-format context #f isa-name-list encoding)))
    (make <derived-ifield>
	  operand-name
	  'derived-ifield ; (string-append "<derived-ifield> for " operand-name)
	  atlist-empty
	  #f ; owner
	  iflds ; subfields
	  ))
)

;; Subroutine of /derived-operand-parse to parse the ifield assertion.
;; The ifield assertion is either () or a (restricted) RTL expression
;; asserting something about the ifield values of the containing insn.
;; The result is #f if the assertion is (), or the canonical rtl.

(define (/derived-parse-ifield-assertion context isa-name-list ifield-assertion)
  (if (null? ifield-assertion)
      #f
      (rtx-canonicalize context 'INT isa-name-list nil ifield-assertion))
)

; Parse a derived operand definition.
; This is the main routine for building a derived operand object from a
; description in the .cpu file.
; All arguments are in raw (non-evaluated) form.
; The result is the parsed object or #f if object isn't for selected mach(s).
;
; ??? Currently no support for handlers(,???) found in normal operands.
; Later, when necessary.

(define (/derived-operand-parse context name comment attrs mode
				args syntax
				base-ifield encoding ifield-assertion
				getter setter)
  (logit 2 "Processing derived operand " name " ...\n")

  ;; Pick out name first to augment the error context.
  (let* ((name (parse-name context name))
	 (context (context-append-name context name))
	 (atlist-obj (atlist-parse context attrs "cgen_operand"))
	 (isa-name-list (atlist-attr-value atlist-obj 'ISA #f)))

    ;; Verify all specified ISAs are valid.
    (if (not (all-true? (map current-isa-lookup isa-name-list)))
	(parse-error context "unknown isa in isa list" isa-name-list))

    (if (keep-atlist? atlist-obj #f)

	(let* ((mode-obj (parse-mode-name context mode))
	       (parsed-encoding (/derived-parse-encoding context isa-name-list
							 name encoding)))

	  (if (not mode-obj)
	      (parse-error context "unknown mode" mode))

	  (let ((result
		 (make <derived-operand>
		       name
		       (parse-comment context comment)
		       atlist-obj
		       mode-obj
		       (map (lambda (a)
			      (if (not (symbol? a))
				  (parse-error context "arg not a symbol" a))
			      (let ((op (current-op-lookup a isa-name-list)))
				(if (not op)
				    (parse-error context "not an operand" a))
				op))
			    args)
		       syntax
		       base-ifield ; FIXME: validate
		       parsed-encoding
		       (/derived-parse-ifield-assertion context isa-name-list
							ifield-assertion)
		       (if (null? getter)
			   #f
			   (/operand-parse-getter
			    context
			    (list args
				  (rtx-canonicalize context mode
						    isa-name-list nil
						    getter))
			    (length args)))
		       (if (null? setter)
			   #f
			   (/operand-parse-setter
			    context
			    (list (append args '(newval))
				  (rtx-canonicalize context 'VOID
						    isa-name-list
						    (list (list 'newval mode #f))
						    setter))
			    (length args)))
		       )))
	    (elm-set! result 'hw-name (obj:name (hardware-for-mode mode-obj)))
	    ;(elm-set! result 'hw-name (obj:name parsed-encoding))
	    ;(elm-set! result 'hw-name base-ifield)
	    (elm-set! result 'index parsed-encoding)
	    ; (elm-set! result 'index (hw-index-derived)) ; A temporary dummy
	    (logit 2 "  new derived-operand; name= " name
		   ", hw-name= " (op:hw-name result) 
		   ", index=" (obj:name parsed-encoding) "\n")
	    (derived-ifield-set-owner! parsed-encoding result)
	    result))

	(begin
	  (logit 2 "Ignoring " name ".\n")
	  #f)))
)

; Read a derived operand description.
; This is the main routine for analyzing derived operands in the .cpu file.
; CONTEXT is a <context> object for error messages.
; ARG-LIST is an associative list of field name and field value.
; /derived-operand-parse is invoked to create the <derived-operand> object.

(define (/derived-operand-read context . arg-list)
  (let (
	(name nil)
	(comment nil)
	(attrs nil)
	(mode 'DFLT)     ; use default mode of TYPE
	(args nil)
	(syntax nil)
	(base-ifield nil)
	(encoding nil)
	(ifield-assertion nil)
	(getter nil)
	(setter nil)
	)

    (let loop ((arg-list arg-list))
      (if (null? arg-list)
	  nil
	  (let ((arg (car arg-list))
		(elm-name (caar arg-list)))
	    (case elm-name
	      ((name) (set! name (cadr arg)))
	      ((comment) (set! comment (cadr arg)))
	      ((attrs) (set! attrs (cdr arg)))
	      ((mode) (set! mode (cadr arg)))
	      ((args) (set! args (cadr arg)))
	      ((syntax) (set! syntax (cadr arg)))
	      ((base-ifield) (set! base-ifield (cadr arg)))
	      ((encoding) (set! encoding (cadr arg)))
	      ((ifield-assertion) (set! ifield-assertion (cadr arg)))
	      ((getter) (set! getter (cadr arg)))
	      ((setter) (set! setter (cadr arg)))
	      (else (parse-error context "invalid derived-operand arg" arg)))
	    (loop (cdr arg-list)))))

    ; Now that we've identified the elements, build the object.
    (/derived-operand-parse context name comment attrs mode args
			    syntax base-ifield encoding ifield-assertion
			    getter setter))
)

; Define a derived operand object, name/value pair list version.

(define define-derived-operand
  (lambda arg-list
    (let ((op (apply /derived-operand-read
		     (cons (make-current-context "define-derived-operand")
			   arg-list))))
      (if op
	  (current-op-add! op))
      op))
)

; Define a derived operand object, all arguments specified.
; ??? Not supported (yet).
;
;(define (define-full-derived-operand name comment attrs mode ...)
;  (let ((op (/derived-operand-parse (make-current-context "define-full-derived-operand")
;				    name comment attrs
;				    mode ...)))
;    (if op
;	(current-op-add! op))
;    op)
;)

; Parse an "anyof" choice, which is a derived-operand name.
; The result is {choice} unchanged.

(define (/anyof-parse-choice context choice isa-name-list)
  (if (not (symbol? choice))
      (parse-error context "anyof choice not a symbol" choice))
  (let ((op (current-op-lookup choice isa-name-list)))
    (if (not (derived-operand? op))
	(parse-error context "anyof choice not a derived-operand" choice))
    op)
)

; Parse an "anyof" derived operand.
; This is the main routine for building a derived operand object from a
; description in the .cpu file.
; All arguments are in raw (non-evaluated) form.
; The result is the parsed object or #f if object isn't for selected mach(s).
;
; ??? Currently no support for handlers(,???) found in normal operands.
; Later, when necessary.

(define (/anyof-operand-parse context name comment attrs mode
			      base-ifield choices)
  (logit 2 "Processing anyof operand " name " ...\n")

  ;; Pick out name first to augment the error context.
  (let* ((name (parse-name context name))
	 (context (context-append-name context name))
	 (atlist-obj (atlist-parse context attrs "cgen_operand")))

    (if (keep-atlist? atlist-obj #f)

	(let ((mode-obj (parse-mode-name context mode))
	      (isa-name-list (atlist-attr-value atlist-obj 'ISA #f)))
	  (if (not mode-obj)
	      (parse-error context "unknown mode" mode))

	  (make <anyof-operand>
		name
		(parse-comment context comment)
		atlist-obj
		mode
		base-ifield
		(map (lambda (c)
		       (/anyof-parse-choice context c isa-name-list))
		     choices)))

	(begin
	  (logit 2 "Ignoring " name ".\n")
	  #f)))
)

; Read an anyof operand description.
; This is the main routine for analyzing anyof operands in the .cpu file.
; CONTEXT is a <context> object for error messages.
; ARG-LIST is an associative list of field name and field value.
; /anyof-operand-parse is invoked to create the <anyof-operand> object.

(define (/anyof-operand-read context . arg-list)
  (let (
	(name nil)
	(comment nil)
	(attrs nil)
	(mode 'DFLT)     ; use default mode of TYPE
	(base-ifield nil)
	(choices nil)
	)

    (let loop ((arg-list arg-list))
      (if (null? arg-list)
	  nil
	  (let ((arg (car arg-list))
		(elm-name (caar arg-list)))
	    (case elm-name
	      ((name) (set! name (cadr arg)))
	      ((comment) (set! comment (cadr arg)))
	      ((attrs) (set! attrs (cdr arg)))
	      ((mode) (set! mode (cadr arg)))
	      ((base-ifield) (set! base-ifield (cadr arg)))
	      ((choices) (set! choices (cdr arg)))
	      (else (parse-error context "invalid anyof-operand arg" arg)))
	    (loop (cdr arg-list)))))

    ; Now that we've identified the elements, build the object.
    (/anyof-operand-parse context name comment attrs mode base-ifield choices))
)

; Define an anyof operand object, name/value pair list version.

(define define-anyof-operand
  (lambda arg-list
    (let ((op (apply /anyof-operand-read
		     (cons (make-current-context "define-anyof-operand")
			   arg-list))))
      (if op
	  (current-op-add! op))
      op))
)

; Utilities to flatten out the <anyof-operand> derivation heirarchy.

; Utility class used when instantiating insns with derived operands.
; This collects together in one place all the appropriate data of an
; instantiated "anyof" operand.

(define <anyof-instance>
  (class-make '<anyof-instance>
	      '(<derived-operand>)
	      '(
		; <anyof-operand> object we were instantiated from.
		parent
		)
	      nil)
)

(method-make-make! <anyof-instance>
		   '(name comment attrs mode
			  args syntax base-ifield encoding ifield-assertion
			  getter setter parent)
)

(define-getters <anyof-instance> anyof-instance (parent))

(define (anyof-instance? x) (class-instance? <anyof-instance> x))

; Return initial list of known ifield values in {anyof-instance}.

(define (/anyof-initial-known anyof-instance)
  (assert (derived-operand? anyof-instance))
  (let ((encoding (derived-encoding anyof-instance)))
    (assert (derived-ifield? encoding))
    (ifld-known-values (derived-ifield-subfields encoding)))
)

; Return true if {anyof-instance} satisfies its ifield assertions.
; {known-values} is the {known} argument to rtx-solve.

(define (anyof-satisfies-assertions? anyof-instance known-values)
  (assert (derived-operand? anyof-instance))
  (let ((assertion (derived-ifield-assertion anyof-instance)))
    (if assertion
	(rtx-solve (make-obj-context anyof-instance #f)
		   anyof-instance ; owner
		   assertion
		   known-values)
	#t))
)

; Subroutine of /anyof-merge-subchoices.
; Merge syntaxes of VALUE-NAMES/VALUES into SYNTAX.
;
; Example:
; If SYNTAX is "$a+$b", and VALUE-NAMES is (b), and VALUES is
; ("$c+$d"-object), then return "$a+$c+$d".

(define (/anyof-syntax anyof-instance)
  (elm-get anyof-instance 'syntax)
)

(define (/anyof-name anyof-instance)
  (elm-get anyof-instance 'name)
)

; CONTAINER is the <anyof-operand> containing SYNTAX.

(define (/anyof-merge-syntax syntax value-names values container)
  (let* ((isa-name-list (obj-isa-list container))
	 (syntax-elements (syntax-break-out syntax isa-name-list)))
    (syntax-make (map (lambda (e)
			(if (anyof-operand? e)
			    (let* ((name (obj:name e))
				   (indx (element-lookup-index name value-names 0)))
			      (if (not indx)
				(error "Name " name " not one of " values)
				)
			      (/anyof-syntax (list-ref values indx)))
			    e))
		      syntax-elements)))
)

; Subroutine of /anyof-merge-subchoices.
; Merge syntaxes of {value-names}/{values} into <derived-ifield> {encoding}.
; The result is a new <derived-ifield> object with subfields matching
; {value-names} replaced with {values}.
; {container} is the containing <anyof-operand>.
;
; Example:
; If {encoding} is (a-ifield-object b-anyof-ifield-object), and {value-names}
; is (b), and {values} is (c-choice-of-b-object), then return
; (a-ifield-object c-choice-of-b-ifield-object).

(define (/anyof-merge-encoding container encoding value-names values)
  (assert (derived-ifield? encoding))
  (let ((subfields (derived-ifield-subfields encoding))
	(result (object-copy encoding)))
    ; Delete all the elements that are being replaced with ifields from
    ; {values} and add the new ifields.
    (derived-ifield-set-subfields! result
				   (append
				    (find (lambda (f)
					    (not (memq (obj:name f) value-names)))
					  subfields)
				    (map derived-encoding values)))
    result)
)

; Subroutine of /anyof-merge-subchoices.
; Merge semantics of VALUE-NAMES/VALUES into GETTER.
;
; Example:
; If GETTER is (mem QI foo), and VALUE-NAMES is (foo), and VALUES is
; ((add a b)-object), then return (mem QI (add a b)).

(define (/anyof-merge-getter getter value-names values)
  ; ??? This implementation is a quick hack, intended to evolve or be replaced.
  (cond ((not getter)
	 #f)
	(else
	 (map (lambda (e)
		(cond ((symbol? e)
		       (let ((indx (element-lookup-index e value-names 0)))
			 (if indx
			     (op:getter (list-ref values indx))
			     e)))
		      ((pair? e) ; pair? -> cheap non-null-list?
		       (/anyof-merge-getter e value-names values))
		      (else
		       e)))
	      getter)))
)

; Subroutine of /anyof-merge-subchoices.
; Merge semantics of VALUE-NAMES/VALUES into SETTER.
;
; Example:
; If SETTER is (set (mem QI foo) newval), and VALUE-NAMES is (foo),
; and VALUES is ((add a b)-object), then return
; (set (mem QI (add a b)) newval).
;
; ??? `newval' in this context is a reserved word.

(define (/anyof-merge-setter setter value-names values)
  ; ??? This implementation is a quick hack, intended to evolve or be replaced.
  (cond ((not setter)
	 #f)
	((rtx-single-set? setter)
	 (let ((src (rtx-set-src setter))
	       (dest (rtx-set-dest setter))
	       (mode (rtx-mode setter))
	       (options (rtx-options setter))
	       (name (rtx-name setter)))
	   (if (rtx-kind 'mem dest)
	       (set! dest
		     (rtx-change-address dest
					 (/anyof-merge-getter
					  (rtx-mem-addr dest)
					  value-names values))))
	   (set! src (/anyof-merge-getter src value-names values))
	   (rtx-make name options mode dest src)))
	(else
	 (error "/anyof-merge-setter: unsupported form" (car setter))))
)

; Subroutine of -sub-insn-make!.
; Merge semantics of VALUE-NAMES/VALUES into SEMANTICS.
; Defined here and not in insn.scm to keep it with the getter/setter mergers.
;
; Example:
; If SEMANTICS is (mem QI foo), and VALUE-NAMES is (foo), and VALUES is
; ((add a b)-object), then return (mem QI (add a b)).

(define (anyof-merge-semantics semantics value-names values)
  ; ??? This implementation is a quick hack, intended to evolve or be replaced.
  (let ((result
	 (cond ((not semantics)
		#f)
	       (else
		(map (lambda (e)
		       (cond ((symbol? e)
			      (let ((indx (element-lookup-index e value-names 0)))
				(if indx
				    (/anyof-name (list-ref values indx))
				    ; (op:sem-name (list-ref values indx))
				    e)))
			     ((pair? e) ; pair? -> cheap non-null-list?
			      (anyof-merge-semantics e value-names values))
			     (else
			      e)))
		     semantics)))))
    (logit 4 "  merged semantics: [" semantics "] -> [" result "]\n")
    result)
)

; Subroutine of /anyof-merge-subchoices.
; Merge assertion of VALUE-NAMES/VALUES into ASSERTION.
;
; Example:
; If ASSERTION is (ne f-base-reg 5), and VALUE-NAMES is
; (foo), and VALUES is ((ne f-mod 0)), then return
; (andif (ne f-base-reg 5) (ne f-mod 0)).
;
; FIXME: Perform simplification pass, based on combined set of known
; ifield values.

(define (/anyof-merge-ifield-assertion assertion value-names values)
  (let ((assertions (find identity
			  (cons assertion
				(map derived-ifield-assertion values)))))
    (if (null? assertions)
	#f
	(rtx-combine 'andif assertions)))
)

; Subroutine of /anyof-all-subchoices.
; Return a copy of <derived-operand> CHOICE with NEW-ARGS from ANYOF-ARGS
; merged in.  This is for when a derived operand is itself composed of
; anyof operands.
; ANYOF-ARGS is a list of <anyof-operand>'s to be replaced in CHOICE.
; NEW-ARGS is a corresponding list of values (<derived-operands>'s) of each
; element in ANYOF-ARGS.
; CONTAINER is the <anyof-operand> containing CHOICE.

(define (/anyof-merge-subchoices container choice anyof-args new-args)
  (assert (all-true? (map anyof-operand? anyof-args)))
  (assert (all-true? (map derived-operand? new-args)))

  (let* ((arg-names (map obj:name anyof-args))
	 (encoding (/anyof-merge-encoding container (derived-encoding choice)
					  arg-names new-args))
	 (result
	  (make <anyof-instance>
		(apply symbol-append
		       (cons (obj:name choice)
			     (map (lambda (anyof)
				    (symbol-append '- (obj:name anyof)))
				  new-args)))
		(obj:comment choice)
		(obj-atlist choice)
		(op:mode choice)
		(derived-args choice)
		(/anyof-merge-syntax (derived-syntax choice)
				     arg-names new-args
				     container)
		(derived-base-ifield choice)
		encoding
		(/anyof-merge-ifield-assertion (derived-ifield-assertion choice)
					       anyof-args new-args)
		(/anyof-merge-getter (op:getter choice)
				     arg-names new-args)
		(/anyof-merge-setter (op:setter choice)
				     arg-names new-args)
		container)))

    (elm-set! result 'index encoding)
    ; Creating the link from {encoding} to {result}.
    (derived-ifield-set-owner! encoding result)
    result)
)

; Subroutine of /anyof-all-choices-1.
; Return a list of all possible subchoices of <derived-operand> ANYOF-CHOICE,
; known to use <anyof-operand>'s itself.
; CONTAINER is the containing <anyof-operand>.

(define (/anyof-all-subchoices container anyof-choice)
  ; Split args into anyof and non-anyof elements.
  (let* ((args (derived-args anyof-choice))
	 (anyof-args (find anyof-operand? args)))

    (assert (not (null? anyof-args)))

    ; Iterate over all combinations.
    ; {todo} is a list with one element for each anyof argument.
    ; Each element is in turn a list of all <derived-operand> choices for the
    ; <anyof-operand>.  The result we want is every possible combination.
    ; Example:
    ; If {todo} is ((1 2 3) (a) (B C)) the result we want is
    ; ((1 a B) (1 a C) (2 a B) (2 a C) (3 a B) (3 a C)).
    ;
    ; Note that some of these values may be derived from nested
    ; <anyof-operand>'s which is why we recursively call /anyof-all-choices-1.
    ; ??? /anyof-all-choices-1 should cache the results.

    (let* ((todo (map /anyof-all-choices-1 anyof-args))
	   (lengths (map length todo))
	   (total (apply * lengths))
	   (result nil))

      ; ??? One might prefer a `do' loop here, but every time I see one I
      ; have to spend too long remembering its syntax.
      (let loop ((i 0))
	(if (< i total)
	    (let* ((indices (split-value lengths i))
		   (new-args (map list-ref todo indices)))
	      ;(display "new-args: " (current-error-port))
	      ;(display (map obj:name new-args) (current-error-port))
	      ;(newline (current-error-port))
	      (set! result
		    (cons (/anyof-merge-subchoices container
						   anyof-choice
						   anyof-args
						   new-args)
			  result))
	      (loop (+ i 1)))))

      result))
)

; Return an <anyof-instance> object from <derived-operand> {derop}, which is a
; choice of {anyof-operand}.

(define (/anyof-instance-from-derived anyof-operand derop)
  (let* ((encoding (object-copy (derived-encoding derop)))
	 (result
	  (make <anyof-instance>
		(obj:name derop)
		(obj:comment derop)
		(obj-atlist derop)
		(op:mode derop)
		(derived-args derop)
		(derived-syntax derop)
		(derived-base-ifield derop)
		encoding
		(derived-ifield-assertion derop)
		(op:getter derop)
		(op:setter derop)
		anyof-operand)))
    ; Creating the link from {encoding} to {result}.
    (derived-ifield-set-owner! encoding result)
    result)
)

; Return list of <anyof-instance> objects, one for each possible variant of
; ANYOF-OPERAND.
;
; One could move this up into the cpu description file using pmacros.
; However, that's not the right way to go.  How we currently implement
; the notion of derived operands is separate from the notion of having them
; in the description language.  pmacros are not "in" the language (to the
; extent that the cpu description file reader "sees" them), they live
; above it.  And the right way to do this is with something "in" the language.
; Derived operands are the first cut at it.  They'll evolve or be replaced
; (and it's the implementation of them that will evolve first).

(define (/anyof-all-choices-1 anyof-operand)
  (assert (anyof-operand? anyof-operand))

  (let ((result nil))

    ; For each choice, scan the operands for further derived operands.
    ; If found, replace the choice with the list of its subchoices.
    ; If not found, create an <anyof-instance> object for it.  This is
    ; basically just a copy of the object, but {anyof-operand} is recorded
    ; with it so that we can later resolve `follows' specs.

    (let loop ((choices (anyof-choices anyof-operand)))
      (if (not (null? choices))
	  (let* ((this (car choices))
		 (args (derived-args this)))

	    (if (any-true? (map anyof-operand? args))

		; This operand has "anyof" operands so we need to turn this
		; choice into a list of all possible subchoices.
		(let ((subchoices (/anyof-all-subchoices anyof-operand this)))
		  (set! result
			(append subchoices result)))

		; No <anyof-operand> arguments.
		(set! result
		      (cons (/anyof-instance-from-derived anyof-operand this)
			    result)))

	    (loop (cdr choices)))))

    (assert (all-true? (map anyof-instance? result)))
    result)
)

; Cover fn of /anyof-all-choices-1.
; Return list of <anyof-instance> objects, one for each possible variant of
; ANYOF-OPERAND.
; We want to delete choices that fail their ifield assertions, but since
; /anyof-all-choices-1 can recursively call itself, assertion checking is
; defered until it returns.

(define (anyof-all-choices anyof-operand)
  (let ((all-choices (/anyof-all-choices-1 anyof-operand)))

    ; Delete ones that fail their ifield assertions.
    ; Sometimes there isn't enough information yet to completely do this.
    ; When that happens it is the caller's responsibility to deal with it.
    ; However, it is our responsibility to assert as much as we can.
    (find (lambda (op)
	    (anyof-satisfies-assertions? op
					 (/anyof-initial-known op)))
	  all-choices))
)

; Operand utilities.

; Look up operand NAME in the operand table.
; This proc isolates the strategy we use to record operand objects.

; Look up an operand via SEM-NAME.

(define (op:lookup-sem-name op-list sem-name)
  (let loop ((op-list op-list))
    (cond ((null? op-list) #f)
	  ((eq? sem-name (op:sem-name (car op-list))) (car op-list))
	  (else (loop (cdr op-list)))))
)

; Given an operand, return the starting bit number.
; Note that the field isn't necessarily contiguous.

(define (op:start operand) (send operand 'field-start))

; Given an operand, return the total length in bits.
; Note that the field isn't necessarily contiguous.

(define (op:length operand) (send operand 'field-length))

; Return a sorted list of operand lists.
; Each element in the inner list is an operand with the same name, but for
; whatever reason were defined separately.
; The outer list is sorted by name.

(define (op-sort op-list)
  ; We assume there is at least one operand.
  (if (null? op-list)
      (error "op-sort: no operands!"))
  ; First sort by name.
  (let ((sorted-ops (alpha-sort-obj-list op-list)))
    (let loop ((result nil)
	       ; Current set of operands with same name.
	       (this-elm (list (car sorted-ops)))
	       (ops (cdr sorted-ops))
	       )
      (if (null? ops)
	  ; Reverse things to keep them in file order (minimizes random
	  ; changes in generated files).
	  (reverse! (cons (reverse! this-elm) result))
	  ; Not done.  Check for new set.
	  (if (eq? (obj:name (car ops)) (obj:name (car this-elm)))
	      (loop result (cons (car ops) this-elm) (cdr ops))
	      (loop (cons (reverse! this-elm) result) (list (car ops))
		    (cdr ops))))))
)

; FIXME: Not used anymore but leave in for now.
; Objects used in assembler syntax ($0, $1, ...).
;
;(define <syntax-operand>
;  (class-make '<syntax-operand> nil '(number value) nil))
;(method-make-make! <syntax-operand> '(number))
;
;(define $0 (make <syntax-operand> 0))
;(define $1 (make <syntax-operand> 1))
;(define $2 (make <syntax-operand> 2))
;(define $3 (make <syntax-operand> 3))

;; PC support.
;; This is a subclass of <operand>, used to give the simulator a place to
;; hang a couple of methods.
;; At the moment we only support one pc, a reasonable place to stop for now.

(define <pc> (class-make '<pc> '(<operand>) nil nil))

(method-make!
 <pc> 'make!
 (lambda (self)
   (send-next self '<pc> 'make!
	      (builtin-location) 'pc "program counter"
	      (atlist-parse (make-prefix-context "make! of pc")
			    '(SEM-ONLY) "cgen_operand")
	      'h-pc ;; FIXME: keep name h-pc hardwired?
	      'DFLT
	      ;;(hw-index-scalar) ;; FIXME: change to this
	      (make <hw-index> 'anonymous
		    'ifield 'UINT (current-ifld-lookup 'f-nil))
	      nil ;; handlers
	      #f #f) ;; getter setter
   self)
)

; Return a boolean indicating if operand op is the pc.
; This must not call op:type.  op:type will try to resolve a hardware
; element that may be multiply specified, and this is used in contexts
; where that's not possible.

(define (pc? op) (class-instance? <pc> op))

; Called before/after loading the .cpu file to initialize/finalize.

; Builtins.
; The pc operand used in rtl expressions.
(define pc nil)

; Called before reading a .cpu file in.

(define (operand-init!)
  (reader-add-command! 'define-operand
		       "\
Define an operand, name/value pair list version.
"
		       nil 'arg-list define-operand)
  (reader-add-command! 'define-full-operand
		       "\
Define an operand, all arguments specified.
"
		       nil '(name comment attrs hw-type mode hw-index handlers getter setter)
		       define-full-operand)

  (reader-add-command! 'define-derived-operand
		       "\
Define a derived operand, name/value pair list version.
"
		       nil 'arg-list define-derived-operand)

  (reader-add-command! 'define-anyof-operand
		       "\
Define an anyof operand, name/value pair list version.
"
		       nil 'arg-list define-anyof-operand)

  *UNSPECIFIED*
)

; Install builtin operands.

(define (operand-builtin!)
  ; Standard operand attributes.
  ; ??? Some of these can be combined into one.

  (define-attr '(for operand) '(type boolean) '(name NEGATIVE)
    '(comment "value is negative"))

  ; Operand plays a part in RELAXABLE/RELAXED insns.
  (define-attr '(for operand) '(type boolean) '(name RELAX)
    '(comment "operand is the relax participant"))

  ; ??? Might be able to make SEM-ONLY go away (or machine compute it)
  ; by scanning which operands are refered to by the insn syntax strings.
  (define-attr '(for operand) '(type boolean) '(name SEM-ONLY)
    '(comment "operand is for semantic use only"))

  ; Also (defined elsewhere): PCREL-ADDR ABS-ADDR.

  (set! pc (make <pc>))
  (obj-cons-attr! pc (all-isas-attr))
  (current-op-add! pc)

  *UNSPECIFIED*
)

; Called after a .cpu file has been read in.

(define (operand-finish!)
  *UNSPECIFIED*
)
@


1.33
log
@	* desc-cpu.scm (/gen-cpu-open): Remove comment on K&R support.
	* utils-cgen.scm (gen-define-with-symcat): Remove K&R support.

	* utils-sim.scm (compute-sformat-argbufs!): Use more consistent name
	for name of empty sbuf.

	* iformat.scm (/sfmt-search-key, /ifmt-lookup-sfmt!): Add assert.

	* insn.scm (<insn>): Add initial value for members fmt-desc, ifmt,
	sfmt, tmp.
	(/sub-insn-ifields): Delete old commented out code.
	(/sub-insn-make!, /parse-insn-format-symbol): Ditto.
	* operand.scm (/anyof-merge-setter, anyof-merge-semantics): Ditto.

	* sim-decode.scm (/gen-decode-insn-globals): Tweak formatting of
	generated code.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2001, 2005, 2009 Red Hat, Inc.
@


1.32
log
@	* utils-cgen.scm (<location>): Define using new define-class.
	(<ident>, <source-ident>, <context>): Ditto.

	* cos.scm (/object-string): New function.
	(/object-error): Use it.
	(/object-count-true): New function
	(object-copy-top): Delete.  All callers changed to call object-copy.
	(/parse-member-list, /build-getter-defs, /build-setter-defs): New fns.
	(define-class, define-interface, define-method): New macros.
	(define-getters, define-setters, vmake): Moved here ...
	* utils-cgen.scm: ... from here.
@
text
@a1255 1
  ;(debug-repl-env getter value-names values)
a1283 1
  ;(debug-repl-env setter value-names values)
a1313 1
  ;(debug-repl-env semantics value-names values)
@


1.31
log
@	* operand.scm (op-nub): Delete.
@
text
@d251 1
a251 1
; (e.g. the behaviour of `object-copy-top').
d255 1
a255 1
  (let ((result (object-copy-top op)))
d1236 1
a1236 1
	(result (object-copy-top encoding)))
d1457 1
a1457 1
  (let* ((encoding (object-copy-top (derived-encoding derop)))
@


1.30
log
@	* utils.scm (reduce): Delete.

	* rtl-traverse.scm (/rtx-canon-rtx-enum): Tweak local name.

	* enum.scm (gen-enum-sym): Make consistent with gen-enum-decl
	regarding PREFIX attribute handling.

	* operand.scm (<hw-index>): Add enum to possible types, all uses
	updated.
	(hw-index-constant?, hw-index-constant-value): New functions.
	(make-enum-hw-index, hw-index-enum-name, hw-index-enum-value,
	hw-index-enum-obj): New functions.
	(/operand-parse): Handle enum indices.
	* intrinsics.scm (md-operand:fixed-register): Use hw-index-constant?,
	hw-index-constant-value.
	* rtl.scm (rtx-constant-value): Fix handling of enums.
	* rtx-funcs.scm (enum): Ditto.
	* sid.scm (<hardware-base> cxmake-get): Only ifield indices are
	currently supported here.
@
text
@a1567 6
; Return the nub of a list of operands, base on their names.

(define (op-nub op-list)
  (nub op-list obj:name)
)

d1621 1
a1621 1
	      'h-pc
@


1.29
log
@	Specify isa(s) when doing ifield, operand, insn lookups.
	ACU = all callers updated.
	* attr.scm (/attr-eval): Call rtx-value instead of rtx-eval-with-estate.
	* enum.scm (define-full-insn-enum): Pass isa-name-list to
	current-ifld-lookup.
	* html.scm (get-insn-properties): Pass isa-name-list to
	current-op-lookup.
	* ifield.scm (/ifld-parse-follows): New arg isas, ACU.
	* insn.scm (/parse-insn-format-symbol): New arg isa-name-list, ACU.
	(/parse-insn-format-list, /parse-insn-iformat-iflds): Ditto.
	(/parse-insn-format, syntax-break-out): Ditto.
	* mach.scm (obj-filter-by-isa): New function.
	(current-ifld-lookup): New optional arg maybe-isa-name-list.
	(/ifld-already-defined?, /op-already-defined?): Simplify.
	(current-op-lookup): New optional arg maybe-isa-name-list.
	(current-insn-lookup): New arg isa-name-list, ACU.
	(/insn-already-defined?, /minsn-already-defined?): Simplify.
	(current-minsn-lookup): New arg isa-name-list, ACU.
	* minsn.scm (/minsn-compute-iflds): Pass isa-name-list to
	current-op-lookup.
	* opc-itab.scm (compute-syntax): New arg isa-name-list, ACU.
	(gen-syntax-entry): Ditto.
	* operand.scm (/operand-parse): Pass isa-name-list to
	current-ifld-lookup.
	(/derived-parse-encoding): New arg isa-name-list, ACU.
	(/derived-parse-ifield-assertion): Ditto.
	(/derived-operand-parse): Pass isa-name-list to current-op-lookup.
	(/anyof-parse-choice): Ditto.
	(anyof-satisfies-assertions?): Pass context to rtx-solve.
	(/anyof-merge-syntax): New arg container, ACU.
	(operand-builtin!): Add pc to all isas.
	* rtl-c.scm (estate-make-for-rtl-c): Delete arg extra-vars-alist, ACU.
	(estate-make-for-rtl-c++, rtl-c-expr-parsed): Ditto.
	(rtl-c-parsed, rtl-c++-parsed): Ditto.
	(rtl-c): New arg isa-name-list, ACU.
	(rtl-c-expr, rtl-c++): Ditto.
	(closure): New arg isa-name-list, ACU.
	* rtl-traverse.scm (/make-cstate): New arg isa-name-list, ACU.
	(/cstate-isas): New function.
	(/rtx-canon-symbol-list): New function.
	(/rtx-canon-env-stack): Renamed from /rtx-canon-env, ACU.
	updated.
	(/rtx-make-canon-table): Rename ENV to ENVSTACK, new entry SYMBOLLIST.
	(/rtx-canon-rtx-operand): Pass isa list to current-op-lookup.
	(/rtx-canon-rtx-ref, /rtx-canon): Ditto.
	(rtx-canonicalize): New arg isa-name-list, ACU.
	(rtx-canonicalize-stmt): Delete.
	(tstate-make): New arg isas, ACU.
	(tstate-isas, tstate--set-isas!): New functions.
	(tstate-env-stack): Renamed from tstate-env, ACU.
	(tstate-set-env-stack!): Renamed from tstate-set-env!, ACU.
	(tstate-make-closure): Renamed from tstate-new-env, new arg
	isa-name-list, ACU.
	(/rtx-traverse-env): Delete.
	(/rtx-make-traverser-table): Rename ENV to ENVSTACK, new entry
	SUMBOLLIST.
	(/rtx-traverse): Include conditional flag in dump output.
	Update isa,envstack for closures.  Pass isa list to current-op-lookup.
	(<eval-state>): New member isas.  Rename env to env-stack.
	(<eval-state> vmake!): Handle #:isas.  #:env renamed to #:env-stack.
	(<eval-state>): New getter/setter for isas.  Rename env getter/setter
	to env-stack.
	(estate-make-for-eval): Provide #:isas.
	(estate-make-closure): Renamed from estate-new-env.  New arg
	isa-name-list, ACU.
	* rtl-xform.scm (/rtx-simplify-expr-fn): Handle closures.
	(/rtx-trim-args): ENV renamed to ENVSTACK.  Ad ITERATION, SYMBOLLIST.
	(/rtx-trim-for-doc): Handle closures.
	* rtl.scm (/rtx-valid-types): Rename ENV to ENVSTACK.  Add ITERATION,
	SYMBOLLIST.
	(rtx-env-var-list): Delete.
	(rtx-env-make): Handle already-compiled environments.
	(rtx-var-alist-to-env): New function.
	(rtx-var-alist-to-closure-env-stack, rtx-make-env-stack): New functions.
	(rtx-env-stack-dump): Renamed from rtx-env-dump, ACU.
	(rtx-operand-obj): New arg isa-name-list, ACU.
	(rtx-closure-isas, rtx-closure-env-stack, rtx-closure-expr): New
	functions.
	* rtx-funcs.scm (closure): New arg isa-name-list, reorder args, ACU.
	* sem-frags.scm (<sfrag>): Delete member compiled-semantics.
	(/frag-compute-desired-frags): Minor simplification.
	(/frag-pick-best): Ditto.
	* sid-cpu.scm (gen-semantic-code): Require canonical rtl.
	(/gen-sfrag-code): Update.
	* sim-cpu.scm (gen-semantic-code): Require canonical rtl.
	* utils-cgen.scm (sanitize): New arg isa-name-list, ACU.
	* utils.scm (non-null-intersection?): New function.
@
text
@a245 30
; PC support.
; This is a subclass of <operand>, used to give the simulator a place to
; hang a couple of methods.
; At the moment we only support one pc, a reasonable place to stop for now.

(define <pc> (class-make '<pc> '(<operand>) nil nil))

(method-make!
 <pc> 'make!
 (lambda (self)
   (send-next self '<pc> 'make!
	      (builtin-location) 'pc "program counter"
	      (atlist-parse (make-prefix-context "make! of pc")
			    '(SEM-ONLY) "cgen_operand")
	      'h-pc
	      'DFLT
	      (make <hw-index> 'anonymous
		    'ifield 'UINT (current-ifld-lookup 'f-nil))
	      nil ; handlers
	      #f #f) ; getter setter
   self)
)

; Return a boolean indicating if operand op is the pc.
; This must not call op:type.  op:type will try to resolve a hardware
; element that may be multiply specified, and this is used in contexts
; where that's not possible.

(define (pc? op) (class-instance? <pc> op))

d324 3
a326 1
; constant: a (non-negative) integer
d329 3
a331 2
; ifield: an ifield object
; operand: an operand object
d337 2
a338 1
; MODE is the mode of VALUE.  If DFLT, mode must be obtained from VALUE.
d392 40
d572 1
a572 1
(define (/operand-parse context name comment attrs hw mode ifld handlers getter setter)
d589 10
a598 3
	      (ifld-val (if (integer? ifld)
			    ifld
			    (current-ifld-lookup ifld isa-name-list))))
d602 11
a612 8
	  (if (not ifld-val)
	      (parse-error context "unknown insn field" ifld))
	  ; Disallow some obviously invalid numeric indices.
	  (if (and (integer? ifld-val)
		   (< ifld-val 0))
	      (parse-error context "invalid integer index" ifld-val))
	  ; Don't validate HW until we know whether this operand will be kept
	  ; or not.  If not, HW may have been discarded too.
d616 18
a633 14
	  ; At this point IFLD-VAL is either an integer or an <ifield> object.
	  ; Since we can't look up the hardware element at this time
	  ; [well, actually we should be able to with a bit of work],
	  ; we determine scalarness from the index.
	  (let* ((scalar? (or (integer? ifld-val) (ifld-nil? ifld-val)))
		 (hw-index
		  (if (integer? ifld-val)
		      (make <hw-index> (symbol-append 'i- name)
			    ; FIXME: constant -> const
			    'constant 'UINT ifld-val)
		      (if scalar?
			  (hw-index-scalar)
			  (make <hw-index> (symbol-append 'i- name)
				'ifield 'UINT ifld-val)))))
d638 9
a646 9
	      ; Copy FLD's attributes so one needn't duplicate attrs like
	      ; PCREL-ADDR, etc.  An operand inherits the attributes of
	      ; its field.  They are overridable of course, which is why we use
	      ; `atlist-append' here.
	      (if (integer? ifld-val)
		  atlist-obj
		  (atlist-append atlist-obj (obj-atlist ifld-val)))
	      hw   ; note that this is the hw's name, not an object
	      mode ; ditto, this is a name, not an object
d1613 31
@


1.28
log
@	* cos.scm (/class-table): New global.
	(/class-uid, /class-set-uid!): New functions.
	(/class-parent-name): Renamed from /class-parents.
	(/class-make!): Change parents arg to parent-name, all callers updated.
	Assign uid to class.
	(/class-lookup-uid): New function.
	(/class-parent-classes): Rewrite.
	(/class-mi?): Delete.
	(/class-desc-mi?, /class-desc-offset-case, /class-desc-offset-case):
	Delete.
	(/class-desc-offset, /class-desc-child, /class-desc-parents): Update.
	(/class-compute-class-desc, class-desc-dump): Update.
	(/object-make!): Update.
	(/object-make-with-values!): Delete arg class-desc, all callers
	updated.
	(/object-copy): Delete arg top?, all callers updated.
	(/object-specialize): Delete.
	(/object-elements, /object-top-class): Delete.
	(/object-class-name, /object-class-desc): Update.
	(/object-class-uid): New function.
	(/object-elm-get, /object-elm-set!, object?, /class-check-init!,
	class-make, /class-subclass? /class-lookup-element,
	Update.
	(/elm-delta, elm-list): Delete.
	(/elm-make-method-getter, elm-get, elm-xget): Update.
	(/elm-make-method-setter, elm-set!, elm-xset!): Update.
	(elm-make-getter, elm-make-setter): Update.
	(/method-lookup-next): Update.
	(send): Don't specialize class passed to method.
	(send-next): New arg class-name, all callers updated.
	(/class-parent, /class-parent-via-path, object-parent): Delete.
	(class-cons-parent!, class-append-parent!): Delete.
	(object-reset!): Init /class-table.
@
text
@d564 6
a569 1
	 (atlist-obj (atlist-parse context attrs "cgen_operand")))
d577 1
a577 1
			    (current-ifld-lookup ifld))))
d824 1
a824 1
(define (/derived-parse-encoding context operand-name encoding)
d833 1
a833 1
  (let ((iflds (/parse-insn-format context #f #f encoding)))
d848 1
a848 1
(define (/derived-parse-ifield-assertion context ifield-assertion)
d851 1
a851 1
      (rtx-canonicalize context 'INT ifield-assertion nil))
d872 6
a877 1
	 (atlist-obj (atlist-parse context attrs "cgen_operand")))
d881 3
a883 2
	(let ((mode-obj (parse-mode-name context mode))
	      (parsed-encoding (/derived-parse-encoding context name encoding)))
d897 1
a897 1
			      (let ((op (current-op-lookup a)))
d905 2
a906 1
		       (/derived-parse-ifield-assertion context ifield-assertion)
d909 7
a915 4
			   (/operand-parse-getter context
						  (list args
							(rtx-canonicalize context mode getter nil))
						  (length args)))
d918 8
a925 5
			   (/operand-parse-setter context
						  (list (append args '(newval))
							(rtx-canonicalize context 'VOID setter
									  (list (list 'newval mode #f))))
						  (length args)))
d1017 1
a1017 1
(define (/anyof-parse-choice context choice)
d1020 1
a1020 1
  (let ((op (current-op-lookup choice)))
d1046 2
a1047 1
	(let ((mode-obj (parse-mode-name context mode)))
d1058 1
a1058 1
		       (/anyof-parse-choice context c))
d1155 1
a1155 1
	(rtx-solve #f ; FIXME: context
d1177 5
a1181 2
(define (/anyof-merge-syntax syntax value-names values)
  (let ((syntax-elements (syntax-break-out syntax)))
d1358 2
a1359 1
				     arg-names new-args)
d1642 1
@


1.27
log
@	* operand.scm (/anyof-merge-setter): Handle set-quiet.

	* rtl-c.scm (estate-make-for-rtl-c): Delete args context, owner,
	rtl-cover-fns?, macro?.  All callers updated.
	(estate-make-for-normal-rtl-c): Delete, have all callers call
	estate-make-for-rtl-c directly.
	(rtl-c-parsed): Pass #:outer-expr to estate-make-for-rtl-c.
	(rtl-c, rtl-c-expr-parsed, rtl-c-expr, rtl-c++-parsed, rtl-c++): Ditto.

	* rtl-c.scm (/par-replace-set-dest-expr-fn): New function,
	replaces /par-replace-set-dests.
	(/par-replace-set-src-expr-fn): New function, replaces
	/par-replace-set-srcs.
	(s-parallel): Rewrite.

	* rtl.scm (rtx-pretty-strdump): New function.
	* rtl-traverse.scm (/rtx-canon-error): Use it.
	(<eval-state>): New member outer-expr.
	(estate-error): Include outer expression in error message if present.

	* rtl.scm (rtx-single-set?): Handle set-quiet.
@
text
@d256 2
a257 1
   (send-next self 'make! (builtin-location) 'pc "program counter"
@


1.26
log
@	* xc16x.cpu (h-cr): New hardware.
	(muls): Comment out parts that won't compile, add fixme.
	(mulu, divl, divlu, jmpabs, jmpa-, jmprel, jbc, jnbs, callr): Ditto.
	(scxti, scxtmg, scxtm, bclear, bclr18, bset19, bitset, bmov): Ditto.
	(bmovn, band, bor, bxor, bcmp, bfldl, bfldh): Ditto.

	Rewrite rtl processing to require it to be "canonicalized" first,
	and write a full canonicalizer / expression checker.
	Remove all appearances of DFLT in canonical rtl.
	* attr.scm (/attr-eval atval owner): Call rtx-canonicalize,
	then rtx-simplify.
	* iformat.scm (ifmt-analyze) Use canonical semantics.
	* insn (<insn>): New member canonical-semantics.
	* mach.scm (<arch>): New member multi-insns-instantiated?.
	(/instantiate-multi-insns!): New function.
	(/canonicalize-insns!): New function.
	(arch-analyze-insns!): Canonicalize insn semantics before processing
	them.
	* mode.scm (/mode-set-word-params!): New function.
	(mode-void?): New function.
	(mode-compatible?): VOID is compatible with VOID.
	(/mode-word-sizes-defined?): New global.
	(mode-set-word-modes!): Use/set it.
	(mode-ensure-word-sizes-defined): Update.
	(mode-builtin!): New builtin "modes" SYM, INSN, MACH.
	Redo WI/UWI/AI/IAI handling.
	(op:new-mode): No longer accept DFLT.
	(<derived-operand> constructor): Ensure all fields are initialized.
	(<anyof-operand> constructor): Ditto.
	(/derived-parse-ifield-assertion): Delete arg `args'.
	All callers updated.
	* rtl-c.scm (<rtl-c-eval-state>): New member `for-insn?'.
	(rtl-c): Call rtx-canonicalize instead of rtx-compile.
	(rtl-c-expr, rtl-c++): Ditto.
	(/rtl-c-get): Use mode of operand, not containing expression.
	(rtl-c-set-quiet, rtl-c-set-trace): Remove DFLT support.
	(/rtx-use-sem-fn?): Don't check for (insn? owner), check
	estate-for-insn? instead.
	(s-unop): Use mode of expression, not first operand.
	(s-binop, s-binop-with-bit, s-shop, s-cmpop): Ditto.
	(s-sequence): Remove DFLT support.
	(ifield): Use mode of expression, not UINT.
	(pc): Comment out, unused.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	(set, set-quiet): Pass src to rtl-c-set-{trace,quiet} for expansion.
	* rtl-traverse.scm (/rtx-canon-debug?): New global.
	(/make-cstate): New function.
	(/cstate-context, /cstate-outer-expr): New functions.
	(/rtx-canon-error): New function.
	(/rtx-lookup-hw, /rtx-pick-mode, /rtx-pick-mode3, /rtx-pick-op-mode,
	/rtx-get-last-cond-case-rtx): New functions.
	(/rtx-canon-*): New functions.
	(/rtx-canner-table, /rtx-operand-canoners): New globals.
	(/rtx-make-canon-table, /rtx-special-expr-canoners): New functions.
	(/rtx-option, /rtx-option-list?): Rewrite.
	(rtx-munge-mode&options): Replaces /rtx-munge-mode&options.
	Rewritten, all callers updated.
	(/rtx-canon-expr, /rtx-canon): New functions.
	(rtx-canonicalize): Move here from rtl-xform.scm and rewrite.
	(rtx-canonicalize-stmt): New function.
	(tstate-make): Remove arg `set?'.  All callers updated.
	(tstate-new-set?): Delete.
	(/rtx-traverse-options, /rtx-traverse-*mode): Delete,
	moved to /rtx-canon-*.
	(/rtx-traverse-normal-operand): New function.
	(/rtx-traverse-rtx-list): Delete arg `mode', all callers updated.
	(/rtx-traverse-rtx, /rtx-traverse-setrtx,, /rtx-traverse-testrtx,
	/rtx-traverse-condrtx, /rtx-traverse-casertx, /rtx-traverse-locals,
	/rtx-traverse-iteration, /rtx-traverse-env, /rtx-traverse-attrs):
	Ditto.
	(/rtx-traverse-symbol, /rtx-traverse-string, /rtx-traverse-number,
	/rtx-traverse-symornum, /rtx-traverse-object): Delete.
	(/rtx-make-traverser-table): Update.
	(/rtx-traverse-operands): Remove mode processing, now done during
	canonicalization.
	(/rtx-traverse-expr): Delete arg `mode', all callers updated.
	(/rtx-traverse): Ditto.
	(rtx-init-traverser-tables!): New function.
	* rtl-xform (/rtx-verify-no-dflt-modes-expr-fn): New function.
	(rtx-verify-no-dflt-modes): New function.
	(/rtx-simplify-expr-fn): Update, `arg' mode deleted.
	(rtx-simplify-insn): Use insn-canonical-semantics.
	(rtx-canonicalize): Moved to rtl-traverse.scm.
	(/compile-expr-fn, rtx-compile): Delete.
	(/rtx-trim-rtx-list): New function.
	(/rtx-trim-for-doc): Handle set, if.
	* rtl.scm (<rtx-func>): New members result-mode, matchexpr-index.
	(/rtx-valid-mode-types): Update.
	(/rtx-valid-matches): Update.
	(/rtx-find-matchexpr-index): New function.
	(rtx-lookup): Require rtx-kind to be the rtx name.
	(def-rtx-node): New arg result-mode, all callers updated.
	(def-rtx-syntax-node, def-rtx-operand-node): Ditto.
	(rtx-lazy-sem-mode): Delete.
	(/rtx-closure-make): New arg `mode', all callers updated.
	(rtx-make-ifield, rtx-make-operand, rtx-make-local): Ditto.
	(rtx-operand-obj): Rewrite.
	(rtx-make-xop): New functions.
	(/hw): Renamed from `hw', all callers updated.
	Use the correct mode instead of DFLT for the index.
	(rtl-builtin!): Call rtx-init-traversal-tables!.
	(rtl-finish!): Update.
	* rtx-funcs.scm (all rtx functions): New parameter: result-mode.
	Update mode arg-type.
	(pc): Comment out.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	* sem-frags.scm (/frag-hash-compute!): Update, mode arg deleted.
	(/frag-cost-compute!): Ditto.
	* semantics.scm (/build-operand!): Delete args op-name, op.
	New arg op-expr.  All callers updated.
	(/build-mem-operand!): Remove DFLT support.
	(semantic-compile): Update process-expr!, mode arg deleted.
	* sid-cpu.scm (gen-semantic-code): Specify #:for-insn? in
	rtl-c++ calls.
	(/gen-sem-case, /gen-sfrag-code): Ditto.
	* sid.scm (/op-gen-set-trace1): Renamed from /op-gen-set-trace.
	(/op-gen-set-trace): New function.  If not doing profiling,
	call /op-gen-set-quiet.
	* sim-cpu.scm (gen-semantic-code): Specify #:for-insn? in rtl-c calls.
	* utils-gen.scm (/gen-ifld-extract-base): Update call to rtl-c.
	(/gen-ifld-extract-beyond, gen-multi-ifld-extract): Ditto.
	* utils.scm (find-first-index): New function.
	* doc/rtl.texi: Delete docs for `attr'.  Add `int-attr'.
@
text
@d1242 2
a1243 1
	       (options (rtx-options setter)))
d1251 1
a1251 1
	   (rtx-make 'set options mode dest src)))
@


1.25
log
@	Clean up pass of mode handling.
	Make use of mode name vs <mode> object more consistent and clear.
	* hardware.scm (/keyword-read): Default mode to the mode name,
	not the <mode> object.
	(/hw-parse-indices): Parse mode name and pass mode object to
	<hw-asm> constructor.
	(/hw-parse-values): Ditto.
	(<hw-register> parse!): Pass mode name to /hw-parse-indices
	and /hw-parse-values.
	(<hw-memory> parse!): Ditto.
	(<hw-address> parse!): Ditto.
	* mode.scm (/mode-table): New global, replaces mode-list.
	Modes stored in hashtable instead of list.
	(/mode-class-table): New global.
	(mode-list-non-alias-values): Update.
	(mode:eq?, mode-compatible?, mode:add!): Update.
	(mode:lookup): Restrict arg to the mode's name.  All callers updated.
	(mode-maybe-lookup): New function.
	(mode-real-name): Restrict arg to a <mode> object.  All callers updated.
	(mode-real-mode, mode-sem-mode, mode-bigger?): Ditto.
	(mode-find, mode-set-word-modes!): Update
	(mode-ensure-word-sizes-defined): Update.
	(/sort-mode-classes!): New function.
	(mode-builtin!): Update.  Sort mode classes here.
	(mode-finish!): Sort mode classes here too.
	* rtl-c.scm (/rtl-c-get): Restrict mode arg to a <mode> object.
	All callers updated.
	(rtl-c-set-quiet): Allow mode to be name of object.
	(rtl-c-set-trace): Ditto.
	* rtl-traverse.scm (rtl-eval-with-estate): Restrict mode arg to
	<mode> object.  All callers updated.
	* rtl.scm (rtx-sem-mode): Restrict arg to <mode> object.
	(rtx-lazy-sem-mode): Ditto.
	(<rtx-temp> make!): Assert mode arg is a <mode> object.
	(rtx-env-make): Allow var-list modes to be name or object.
	* sem-frags.scm (/frag-expr-assq-locals): New function.
	(/frag-compute-locals!): Call it.
	(/sfrag-create-cse-mapping): Renamed from sfrag-create-cse-mapping.
	All callers updated.
	* semantics.scm (/build-mem-operand!): Handle mode aliases.
@
text
@d43 2
d281 1
d290 6
a295 5
    (if (or (eq? new-mode-name 'DFLT)
	    (eq? new-mode-name 'VOID) ; temporary: for upward compatibility
	    (mode:eq? new-mode-name (op:mode op)))
	; Mode isn't changing.
	result
d740 25
a764 4
(method-make-make! <derived-operand>
		   '(name comment attrs mode
			  args syntax base-ifield encoding ifield-assertion
			  getter setter)
d795 1
a795 1
 (lambda (self name comment attrs mode base-ifield choices)
d799 4
a802 1
   (elm-set! self 'mode-name mode)
d837 4
a840 5
; Subroutine of /derived-operand-parse to parse the ifield assertion.
; The ifield assertion is either () or an RTL expression asserting something
; about the ifield values of the containing insn.
; Operands are specified by name, but what is used is their indices (there's
; an implicit `index-of' going on).
d842 1
a842 2
(define (/derived-parse-ifield-assertion context args ifield-assertion)
  ; FIXME: for now
d845 1
a845 1
      ifield-assertion)
d893 1
a893 1
		       (/derived-parse-ifield-assertion context args ifield-assertion)
d898 1
a898 1
							(rtx-canonicalize context getter))
d904 2
a905 1
							(rtx-canonicalize context setter))
@


1.24
log
@	* insn.scm (/parse-insn-format): New arg `verify?', all callers updated.
	(/insn-parse): Don't verify iformat for virtual insns.

	* sid-decode.scm (cgen-decode.cxx): Remove redundant call to
	non-multi-insns.
	* sid-model.scm (/gen-model-insn-fn-decls): Ditto.
	(/gen-model-insn-fns, /gen-model-class-decls): Ditto.
	* sid.scm (pbb-engine-insns): Ditto.
	* sim-decode.scm (cgen-decode.c): Ditto.
@
text
@d376 1
a376 1
   (elm-set! self 'mode (mode:lookup mode))
@


1.23
log
@	Add support for controlling warnings/errors.
	Add tests for iformat description errors.
	* dev.scm (cload): New option #:diag.
	* read.scm (<reader>): New member verify-iformat?.
	(/parse-diagnostic, parse-warning): New functions.
	(parse-error): Guts moved to /parse-diagnostic.
	(/set-diagnostic-options!): New function.
	(cpu-load): New arg diagnostic-options, all callers updated.
	Recognize -w diagnostic-option-list.
	* ifield.scm (ifields-base-ifields): Move here from iformat.scm.
	(ifld-simple-ifields, ifields-simple-ifields): New function.
	* insn.scm (/parse-insn-format-iflds): New function.
	(/parse-insn-format): Guts moved to /parse-insn-format-iflds.
	New arg isa, all callers updated.  Do some basic validation of the
	ifield list if requested.
	* mach.scm (/sanity-check-insns): Improve error message text.
	* doc/running.text: Document -w option.

	* ifield.scm (/multi-ifield-parse): Initialize bitrange.
@
text
@d799 1
a799 1
  (let ((iflds (/parse-insn-format context #f encoding)))
@


1.22
log
@	* dev.scm (*): Change default verbosity level to 2.

	* ifield.scm (<ifield> pretty-print): New method.
	(ifld-pretty-print): New function.
	(<multi-ifield> pretty-print): New method.

	* ifield.scm (<ifield> field-start): Delete word-len arg.
	All callers updated.
	(ifld-start): Ditto.
	(<multi-ifield> field-start): Ditto.
	* operand.scm (<hw-index> field-start): Ditto.
@
text
@d799 1
a799 1
  (let ((iflds (/parse-insn-format context encoding)))
@


1.21
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d400 1
a400 1
 (lambda (self word-len)
d402 1
a402 1
       (send (hw-index:value self) 'field-start #f)
d1481 1
a1481 1
(define (op:start operand) (send operand 'field-start #f))
@


1.20
log
@	* ifield.scm (<ifield> constructor): New arg `location',
	all callers updated.
	* insn.scm (<insn> constructor): Ditto.
	(<multi-insn> constructor): Ditto.
	* minsn.scm (<macro-insn> constructor): Ditto.
	* operand.scm (<operand> constructor): Ditto.
	* utils-cgen.scm (builtin-location): New function.
	(<source-ident>): Fix default value of member `location'.
	(source-ident?): New function.
@
text
@d486 1
a486 1
; Utility of -operand-parse-[gs]etter to build the expected syntax,
d489 1
a489 1
(define (-operand-g/setter-syntax rank setter?)
d506 1
a506 1
(define (-operand-parse-getter context getter rank)
d516 1
a516 1
					(-operand-g/setter-syntax rank #f))
d528 1
a528 1
(define (-operand-parse-setter context setter rank)
d538 1
a538 1
					(-operand-g/setter-syntax rank #t))
d553 1
a553 1
(define (-operand-parse context name comment attrs hw mode ifld handlers getter setter)
d611 2
a612 2
	      (-operand-parse-getter context getter (if scalar? 0 1))
	      (-operand-parse-setter context setter (if scalar? 0 1))
d624 1
a624 1
; -operand-parse is invoked to create the <operand> object.
d626 1
a626 1
(define (-operand-read context . arg-list)
d658 1
a658 1
    (-operand-parse context name comment attrs type mode index handlers
d666 1
a666 1
    (let ((op (apply -operand-read (cons (make-current-context "define-operand")
d676 1
a676 1
  (let ((op (-operand-parse (make-current-context "define-full-operand")
d786 1
a786 1
; Subroutine of -derived-operand-parse to parse the encoding.
d790 1
a790 1
(define (-derived-parse-encoding context operand-name encoding)
d797 1
a797 1
  ; ??? Calling -parse-insn-format is a quick hack.
d799 1
a799 1
  (let ((iflds (-parse-insn-format context encoding)))
d809 1
a809 1
; Subroutine of -derived-operand-parse to parse the ifield assertion.
d815 1
a815 1
(define (-derived-parse-ifield-assertion context args ifield-assertion)
d831 1
a831 1
(define (-derived-operand-parse context name comment attrs mode
d845 1
a845 1
	      (parsed-encoding (-derived-parse-encoding context name encoding)))
d867 1
a867 1
		       (-derived-parse-ifield-assertion context args ifield-assertion)
d870 1
a870 1
			   (-operand-parse-getter context
d876 1
a876 1
			   (-operand-parse-setter context
d901 1
a901 1
; -derived-operand-parse is invoked to create the <derived-operand> object.
d903 1
a903 1
(define (-derived-operand-read context . arg-list)
d939 1
a939 1
    (-derived-operand-parse context name comment attrs mode args
d948 1
a948 1
    (let ((op (apply -derived-operand-read
d960 1
a960 1
;  (let ((op (-derived-operand-parse (make-current-context "define-full-derived-operand")
d971 1
a971 1
(define (-anyof-parse-choice context choice)
d989 1
a989 1
(define (-anyof-operand-parse context name comment attrs mode
d1011 1
a1011 1
		       (-anyof-parse-choice context c))
d1023 1
a1023 1
; -anyof-operand-parse is invoked to create the <anyof-operand> object.
d1025 1
a1025 1
(define (-anyof-operand-read context . arg-list)
d1051 1
a1051 1
    (-anyof-operand-parse context name comment attrs mode base-ifield choices))
d1058 1
a1058 1
    (let ((op (apply -anyof-operand-read
d1094 1
a1094 1
(define (-anyof-initial-known anyof-instance)
d1115 1
a1115 1
; Subroutine of -anyof-merge-subchoices.
d1122 1
a1122 1
(define (-anyof-syntax anyof-instance)
d1126 1
a1126 1
(define (-anyof-name anyof-instance)
d1130 1
a1130 1
(define (-anyof-merge-syntax syntax value-names values)
d1139 1
a1139 1
			      (-anyof-syntax (list-ref values indx)))
d1144 1
a1144 1
; Subroutine of -anyof-merge-subchoices.
d1155 1
a1155 1
(define (-anyof-merge-encoding container encoding value-names values)
d1170 1
a1170 1
; Subroutine of -anyof-merge-subchoices.
d1177 1
a1177 1
(define (-anyof-merge-getter getter value-names values)
d1190 1
a1190 1
		       (-anyof-merge-getter e value-names values))
d1196 1
a1196 1
; Subroutine of -anyof-merge-subchoices.
d1206 1
a1206 1
(define (-anyof-merge-setter setter value-names values)
d1219 1
a1219 1
					 (-anyof-merge-getter
d1222 1
a1222 1
	   (set! src (-anyof-merge-getter src value-names values))
d1225 1
a1225 1
	 (error "-anyof-merge-setter: unsupported form" (car setter))))
d1247 1
a1247 1
				    (-anyof-name (list-ref values indx))
d1259 1
a1259 1
; Subroutine of -anyof-merge-subchoices.
d1270 1
a1270 1
(define (-anyof-merge-ifield-assertion assertion value-names values)
d1279 1
a1279 1
; Subroutine of -anyof-all-subchoices.
d1288 1
a1288 1
(define (-anyof-merge-subchoices container choice anyof-args new-args)
d1293 1
a1293 1
	 (encoding (-anyof-merge-encoding container (derived-encoding choice)
d1306 1
a1306 1
		(-anyof-merge-syntax (derived-syntax choice)
d1310 1
a1310 1
		(-anyof-merge-ifield-assertion (derived-ifield-assertion choice)
d1312 1
a1312 1
		(-anyof-merge-getter (op:getter choice)
d1314 1
a1314 1
		(-anyof-merge-setter (op:setter choice)
d1324 1
a1324 1
; Subroutine of -anyof-all-choices-1.
d1329 1
a1329 1
(define (-anyof-all-subchoices container anyof-choice)
d1345 2
a1346 2
    ; <anyof-operand>'s which is why we recursively call -anyof-all-choices-1.
    ; ??? -anyof-all-choices-1 should cache the results.
d1348 1
a1348 1
    (let* ((todo (map -anyof-all-choices-1 anyof-args))
d1363 1
a1363 1
		    (cons (-anyof-merge-subchoices container
d1376 1
a1376 1
(define (-anyof-instance-from-derived anyof-operand derop)
d1409 1
a1409 1
(define (-anyof-all-choices-1 anyof-operand)
d1429 1
a1429 1
		(let ((subchoices (-anyof-all-subchoices anyof-operand this)))
d1435 1
a1435 1
		      (cons (-anyof-instance-from-derived anyof-operand this)
d1444 1
a1444 1
; Cover fn of -anyof-all-choices-1.
d1448 1
a1448 1
; -anyof-all-choices-1 can recursively call itself, assertion checking is
d1452 1
a1452 1
  (let ((all-choices (-anyof-all-choices-1 anyof-operand)))
d1460 1
a1460 1
					 (-anyof-initial-known op)))
@


1.19
log
@	* mach.scm (current-*-add!): Update calls to parse-error.
	* operand.scm (op:new-mode): Update call to parse-error.
	* utils-cgen.scm (make-obj-context): New function.
@
text
@d105 3
a107 1
 (lambda (self name comment attrs hw-name mode-name index handlers getter setter)
d254 1
a254 1
   (send-next self 'make! 'pc "program counter"
d597 1
@


1.18
log
@	* gas-test.scm (<hw-asm>, test-data): Handle () values.
	(<keyword>, test-data): Convert symbols to strings before passing
	to string-append.
	(<hw-index>, test-data): Enumerate all cases.  Emit correctly sized
	result for scalars.

	* operand.scm (hw-index-scalar): Set `name'.
	(hw-index-anyof, hw-index-derived): Ditto.
@
text
@d299 1
a299 1
	    (parse-error "op:new-mode"
@


1.17
log
@	Clean up cpu file parsing, pass context consistently instead of the
	old "errtxt" argument.
	NOTE: ACU == "All Callers Updated".
	* attr.scm (-parse-simple-attribute): Renamed from
	parse-simple-attribute, ACU.
	(-attr-parse): Change errtxt argument to context, ACU.
	(-attr-read): Ditto.
	(atlist-parse): Ditto.  Put context arg first.
	(attr-parse): Use parse-error instead of context-error.
	* enum.scm (parse-enum-vals): Change errtxt argument to context, ACU.
	(-enum-parse-prefix, -enum-parse, -enum-read): Ditto.
	* hardware.scm (-keyword-parse): Renamed from keyword-parse.
	`context' arg is now a <context> object.  ACU.
	(-keyword-read): `context' arg is now a <context> object.  ACU.
	(-hw-parse-indices): Change errtxt argument to context, ACU.
	(-hw-parse-values, -hw-parse-handlers): Ditto.
	(-hw-parse-getter, -hw-parse-setter, -hw-parse, -hw-read): Ditto.
	(-hw-validate-layout, -hw-create-getter-from-layout,
	-hw-create-setter-from-layout): Ditto.
	(<hw-register>:parse!, <hw-pc>:parse!): Ditto.
	(<hw-memory>:parse!, <hw-immediate>:parse!): Ditto.
	(<hw-address>:parse!): Ditto.
	* ifield.scm (-ifield-parse, ifield-read): Ditto.
	(-ifld-parse-follows, -ifld-parse-encode-decode): Ditto.
	(-ifld-parse-encode, -ifld-parse-decode): Ditto.
	(-multi-ifield-parse, -multi-ifield-read): Ditto.
	* insn.scm (-insn-parse, -insn-read): Ditto.
	(parse-syntax): Ditto.  Put context arg first.
	(-parse-insn-format-symbol): Change errtxt argument to context, ACU.
	(-parse-insn-format-ifield-spec, -parse-insn-format-list): Ditto.
	(-parse-insn-format): Ditto.
	* mach.scm (-arch-parse-alignment, -arch-parse-machs): Ditto.
	(-arch-parse-isas): Ditto.
	(-isa-read): Add context arg, ACU.
	(-cpu-parse, -cpu-read, -mach-read): Ditto.
	* minsn.scm (-minsn-parse-expansion): Change errtxt argument to
	context, ACU.
	(-minsn-parse, -minsn-read, -minsn-compute-iflds): Ditto.
	(minsn-make-alias): Ditto.
	* mode.scm (-mode-parse): Ditto.
	(parse-mode-name): Ditto.  Put context arg first.
	* model.scm (-prefetch-parse, -retire-parse, -pipeline-parse): Change
	errtxt argument to context, ACU.
	(-unit-parse, -model-parse, -model-read): Ditto.
	* operand.scm (-operand-parse-getter): Use parse-error instead of
	context-error.
	(-operand-parse-setter): Ditto.
	(-operand-parse): Change errtxt argument to context, ACU.
	(-operand-read, -derived-operand-parse, -derived-operand-read): Ditto.
	(-anyof-operand-parse, -anyof-operand-read): Ditto.
	* read.scm (reader-error): Delete.  Use parse-error instead.
	(parse-error): Change errtxt argument to context, ACU.  Split args
	argument into expr and maybe-help-text.
	(-reader-process-expanded-1!): Reorganize.
	* rtl.scm (-subr-read): Change errtxt argument to context, ACU.
	* types.scm (parse-type): Ditto.
	* utils-cgen.scm (single-location->simple-string): New function.
	(<context>): Replace members file,lineno with location.
	(make-prefix-context): Renamed from context-make-prefix, ACU.
	(make-current-context): New function.
	(context-append, context-append-name): New functions.
	(context-make-reader): Delete.
	(parse-name): Change errtxt argument to context, ACU.
	Put context arg first.
	(parse-comment): Ditto.
	(parse-number): Change errtxt argument to context, ACU.
	(arg-list-validate-name, arg-list-check-no-args,
	arg-list-symbol-arg): Ditto.

	* read.scm (-cmd-if): Don't assume test is a list.

	* html.scm (get-insn-properties): Delete errtxt, unused.
@
text
@d418 1
d433 1
d445 1
@


1.16
log
@	Track source location better, for better error messages.
	* pmacros.scm (-pmacro-eval): Delete, unused.
	(pmacro-expand, -pmacro-expand): New arg `loc', all callers updated.
	(-pmacro-expand-expr-list, -smacro-apply): Ditto.
	(scan-list, scan): Ditto.
	(-pmacro-builtin-pmacro, -pmacro-builtin-let, -pmacro-builtin-if,
	-pmacro-builtin-case, -pmacro-builtin-cond, -pmacro-builtin-begin,
	-pmacro-builtin-andif, -pmacro-builtin-orif): Ditto.
	(scan-list1): New function.
	(-pmacro-build-lambda): New arg `loc', all callers updated.  Rewrite.
	* read.scm (<reader>): New member `location'.
	(-reader-lookup-command): Renamed from reader-lookup-command,
	all callers updated.
	(reader-error): Rewrite to produce better source location info.
	(current-reader-location): New function.
	(-reader-process-expanded-1!): Renamed from -reader-process-expanded-1.
	All callers updated.  Record source location of expression.
	(reader-process-expanded!): Renamed from reader-process-expanded.
	All callers updated.
	(-reader-process!): Renamed from reader-process.  New arg `loc'.
	All callers updated.  Record source location of define-pmacro.
	* utils-cgen.scm (<location>): New class.
	(single-location): New (pseudo) class.
	(pretty-print-single-location, pretty-print-location): New functions.
	(location-top, location-push-single, location-push): New functions.
	(unspecified-location, current-input-location): New functions.
	(location-property): New object property.
	(location-property-set!): New function.
	(<source-ident>): Renamed from <ordered-ident>.  New member `location'.
	All uses updated.
	* testsuite/location-1.test: New testcase.
	* testsuite/run-tests.sh: Fix fail count handling.
	* testsuite/test-utils.sh.in (run_cgen): New option `-f'.  Allow tests
	to expect cgen to fail.

	* pmacros.scm (*): Use "pmacro" instead of "macro" more consistently.

	* read.scm (-cmd-include): Renamed from include.  All callers updated.
	(-cmd-if): Renamed from cmd-if.  All callers updated.
	Use reader-process-expanded! on then/else clauses instead of eval1.
@
text
@d253 2
a254 1
	      (atlist-parse '(SEM-ONLY) "cgen_operand" "make! of pc")
d509 4
a512 4
	    (context-error context
			   (string-append "invalid getter, should be "
					  (-operand-g/setter-syntax rank #f))
			   getter))
d514 1
a514 1
	    (context-error context "invalid rtx expression" getter))
d531 4
a534 4
	    (context-error context
			   (string-append "invalid setter, should be "
					  (-operand-g/setter-syntax rank #t))
			   setter))
d536 1
a536 1
	    (context-error context "invalid rtx expression" setter))
d548 1
a548 1
(define (-operand-parse errtxt name comment attrs hw mode ifld handlers getter setter)
d551 4
a554 2
  (let ((name (parse-name name errtxt))
	(atlist-obj (atlist-parse attrs "cgen_operand" errtxt)))
d559 1
a559 1
	      (mode-obj (parse-mode-name mode errtxt))
d562 1
a562 3
			    (current-ifld-lookup ifld)))
	      ; FIXME: quick hack
	      (context (context-make-reader errtxt)))
d565 1
a565 1
	      (parse-error errtxt "unknown mode" mode))
d567 1
a567 1
	      (parse-error errtxt "unknown insn field" ifld))
d571 1
a571 1
	      (parse-error errtxt "invalid integer index" ifld-val))
d575 1
a575 1
	      (parse-error errtxt "unknown hardware element" hw))
d593 1
a593 1
	      (parse-comment comment errtxt)
d604 1
a604 1
	      (parse-handlers errtxt '(parse print) handlers)
d616 1
a616 1
; ERRTXT is prepended to error messages to provide context.
d620 2
a621 2
(define (-operand-read errtxt . arg-list)
  (let (; Current operand elements:
d632 1
d648 1
a648 1
	      (else (parse-error errtxt "invalid operand arg" arg)))
d650 1
d652 2
a653 3
    (-operand-parse errtxt name comment attrs type mode index handlers
		    getter setter)
    )
d660 2
a661 1
    (let ((op (apply -operand-read (cons "define-operand" arg-list))))
d670 2
a671 1
  (let ((op (-operand-parse "define-full-operand" name comment attrs
d787 1
a787 1
      (context-error context "encoding not a list" encoding))
d789 1
a789 1
      (context-error context "encoding must begin with `+'" encoding))
d793 1
a793 1
  (let ((iflds (-parse-insn-format "anyof encoding" encoding)))
d825 1
a825 1
(define (-derived-operand-parse errtxt name comment attrs mode
d831 4
a834 2
  (let ((name (parse-name name errtxt))
	(atlist-obj (atlist-parse attrs "cgen_operand" errtxt)))
d838 3
a840 5
	(let* ((mode-obj (parse-mode-name mode errtxt))
	      ; FIXME: quick hack
	      (context (context-make-reader errtxt))
	      (parsed-encoding (-derived-parse-encoding context name encoding))
	      )
d842 1
a842 1
	      (parse-error errtxt "unknown mode" mode))
d847 1
a847 1
		       (parse-comment comment errtxt)
d852 1
a852 1
				  (parse-error errtxt "arg not a symbol" a))
d855 1
a855 1
				    (parse-error errtxt "not an operand" a))
d893 1
a893 1
; ERRTXT is prepended to error messages to provide context.
d897 2
a898 2
(define (-derived-operand-read errtxt . arg-list)
  (let (; Current derived-operand elements:
d911 1
d929 1
a929 1
	      (else (parse-error errtxt "invalid derived-operand arg" arg)))
d931 1
d933 1
a933 1
    (-derived-operand-parse errtxt name comment attrs mode args
d935 1
a935 2
			    getter setter)
    )
d943 2
a944 1
		     (cons "define-derived-operand" arg-list))))
d954 1
a954 1
;  (let ((op (-derived-operand-parse "define-full-derived-operand"
d967 1
a967 1
      (context-error context "anyof choice not a symbol" choice))
d970 1
a970 1
	(context-error context "anyof choice not a derived-operand" choice))
d983 1
a983 1
(define (-anyof-operand-parse errtxt name comment attrs mode
d987 4
a990 2
  (let ((name (parse-name name errtxt))
	(atlist-obj (atlist-parse attrs "cgen_operand" errtxt)))
d994 1
a994 3
	(let ((mode-obj (parse-mode-name mode errtxt))
	      ; FIXME: quick hack
	      (context (context-make-reader errtxt)))
d996 1
a996 1
	      (parse-error errtxt "unknown mode" mode))
d1000 1
a1000 1
		(parse-comment comment errtxt)
d1015 1
a1015 1
; ERRTXT is prepended to error messages to provide context.
d1019 2
a1020 2
(define (-anyof-operand-read errtxt . arg-list)
  (let (; Current operand elements:
d1028 1
d1041 1
a1041 1
	      (else (parse-error errtxt "invalid anyof-operand arg" arg)))
d1043 1
d1045 1
a1045 2
    (-anyof-operand-parse errtxt name comment attrs mode base-ifield choices)
    )
d1053 2
a1054 1
		     (cons "define-anyof-operand" arg-list))))
@


1.15
log
@	* model.scm (parse-insn-timing): Tweak logging message.
	* operand.scm: Comment and whitespace tweaks.
	(op:type): Tweak error message.
	(op-ifield): Tweak logging message.
	(-derived-operand-parse, anyof-merge-semantics): Ditto.
	* read.scm: Whitespace cleanup.
	* utils.scm: Whitespace cleanup.
@
text
@d20 1
a20 1
	      '(<ordered-ident>)
@


1.14
log
@	Use hash tables to record ifields, operands, insns, macro-insns.
	* attr.scm (attr-builtin!): Tweak some comments.
	* hardware.scm (hardware-builtin!): Call all-isas-attr-value.
	* ifield.scm (<ifield>): Subclass from <ordered-ident> instead of
	<ident>.
	(<multi-ifield>): New constructor.
	(ifield-builtin!): Add isa attr to f-nil, f-anyof.
	* insn.scm (<insn>): Subclass from <ordered-ident> instead of
	<ident>.
	(-sub-insn-make!): Add hack to avoid differences in generated code.
	(multi-insn-instantiate!): Add total number of multi-insns to
	logging message.
	* mach.scm (<arch>): Rename members ifld-list, op-list, insn-list,
	minsn-list to foo-table.  New member next-ordinal.
	Update getters/setters.
	(arch-ifld-list, arch-op-list, arch-insn-list, arch-minsn-list):
	New functions.
	(-get-next-ordinal!, -get-lowest-ordinal): New function.
	(-make-ident-object-table, -ident-object-table->list,
	-ident-object-table-add!, -ident-object-table-lookup): New functions.
	(current-ifld-list, current-ifld-add! current-ifld-lookup,
	-ifld-already-defined?): Rewrite.
	(current-op-list, current-op-add! current-op-lookup,
	-op-already-defined?): Rewrite.
	(current-raw-insn-list, insn-list-car, insn-list-splice!): Delete.
	(current-insn-list, current-insn-add! current-insn-lookup,
	-insn-already-defined?): Rewrite.
	(current-minsn-list, current-minsn-add! current-minsn-lookup,
	-minsn-already-defined?): Rewrite.
	(all-isas-attr-value, all-isas-attr, attr-isa-list): New functions.
	(MAX-VIRTUAL-INSNS): Define.
	(arch-analyze-insns!): Add hack to avoid differences in generated code.
	Update use of arch-insn-list.
	(mach-init!): Initialize ifld-table, op-table, insn-table, minsn-table.
	(arch-finish!): Delete references to ifld-table, op-table, insn-table,
	minsn-table.
	* minsn.scm (<macro-insn>): Subclass from <ordered-ident> instead of
	<ident>.  New constructor.
	* operand.scm (<operand>): Subclass from <ordered-ident> instead of
	<ident>.
	* sid.scm (-virtual-insn-add!): New function.
	(-create-virtual-insns!): Call it.
	(-fill-sim-insn-list!): Rewrite.
	* sim.scm (-virtual-insn-add!, -create-virtual-insns!): New functions.
	(sim-finish!): Move contents to -create-virtual-insns!, and call it.
	* utils-cgen.scm (<ordered-ident>): New class.
	(obj-ordinal, obj-set-ordinal!): New functions.
	(add-ident-methods!): Delete.

	* model.scm (parse-insn-timing): Change logging message to level 3.
@
text
@d94 2
a95 1
		; whether (and by how much) this instance of the operand is delayed.
d157 1
a157 1
		  (error "can't resolve h/w reference" hw-name))
d186 2
a187 1
  (logit 4 "op-ifield op=" (obj:name op) " indx=" (obj:name (op:index op)) "\n")
d191 1
a191 1
	  (logit 4 " ifld=" (obj:name maybe-ifld) "\n")
a422 1

a446 2


d876 3
a878 2
	    (logit 2 "new derived-operand; name=" name " hw-name= " (op:hw-name result) 
		   " index=" (obj:name parsed-encoding) "\n")
a1115 1

d1241 1
a1241 1
    (logit 4 "Merged semantics [" semantics "] -> [" result "]\n")
d1303 1
a1303 1
    ;
d1402 3
a1404 3
    ; If not found, create an <anyof-instance> object for it.  This is basically
    ; just a copy of the object, but {anyof-operand} is recorded with it so
    ; that we can later resolve `follows' specs.
@


1.13
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d20 1
a20 1
	      '(<ident>)
@


1.12
log
@* operand.scm (-anyof-merge-syntax): Print a more useful error
message.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2001, 2005 Red Hat, Inc.
@


1.12.6.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2001, 2005, 2009 Red Hat, Inc.
@


1.11
log
@2005-07-29  Dave Brolley  <brolley@@redhat.com>

        * operand.scm (op:new-mode): Convert (obj:name op) to a string for
        string-append.
@
text
@d1123 3
a1125 1
			      (assert indx)
@


1.10
log
@2005-06-15  Dave Brolley  <brolley@@redhat.com>

        * sid-cpu.scm (-gen-hw-stream-and-destream-fns): New function.
        (cgen-cpu.h): Call it.

        Contributed on behalf of Graydon Hoare
        2001-06-05  graydon hoare  <graydon@@redhat.com>

        * utils.scm (foldl): Define.
        (foldr): Define.
        (filter): Define.
        (union): Define.
        (intersection): Simplify.
        * sid.scm : Set APPLICATION to SID-SIMULATOR.
        (-op-gen-delayed-set-maybe-trace): Define.
        (<operand> 'gen-set-{quiet,trace}): Delegate to
        op-gen-delayed-set-quiet etc. Note: this is still a little tangled
        up and needs cleaning.
        (-with-parallel?): Hardwire with-parallel to #t.
        (<operand> 'cxmake-get): Replace with lookahead-aware code
        * sid-decode.scm: Remove per-insn writeback fns.
        (-gen-idesc-decls): Redefine sem_fn type.
        * sid-cpu.scm (gen-write-stack-structure): Replace parexec stuff
        with write stack stuff.
        (cgen-write.cxx): Replace per-insn writebacks with single write
        stack writeback. Add write stack reset function.
        (-gen-scache-semantic-fn insn): Replace parexec stuff with write
        stack stuff.
        * rtl-c.scm (xop): Clone operand into delayed operand if #:delayed
        estate attribute set.
        (delay): Set #:delayed attribute to calculated delay, update
        maximum delay of cpu, check (delay ...) usage.
        * operand.scm (<operand>): Add delayed slot to <operand>.
        * mach.scm (<cpu>): Add max-delay slot to <cpu>.
        * dev.scm (load-sid): Set APPLICATION to SID-SIMULATOR.
        * doc/rtl.texi (Expressions): Add section on (delay ...).
@
text
@d298 1
a298 1
					(obj:name op)
@


1.9
log
@2005-02-16  Dave Brolley  <brolley@@redhat.com>

        * operand.scm (-derived-operand-parse): Move logit message from level 1
        to level 2.
@
text
@d93 3
d141 2
@


1.8
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2001 Red Hat, Inc.
d872 1
a872 1
	    (logit 1 "new derived-operand; name=" name " hw-name= " (op:hw-name result) 
@


1.7
log
@back out RELAX part of previous patch and instead implement FIXME:
rename insn RELAX to RELAXED.

	* insn.scm (insn-builtin!): RELAX renamed to RELAXABLE.
	* cpu/m32r.cpu (all insns): Ditto.
@
text
@d224 5
a228 3
   (let* ((name (if (elm-bound? self 'pretty-sem-name) (elm-get self 'pretty-sem-name) 
		    (if (elm-bound? self 'sem-name) (elm-get self 'sem-name)
			(obj:name self))))
d719 1
a719 1
	      ())
d749 1
a749 1
	      ())
d1484 1
a1484 4
  (let ((sorted-ops (sort op-list
			  (lambda (a b)
			     (string<? (obj:name a) (obj:name b)))))
	)
@


1.6
log
@	* mach.scm (current-*-add!): Disallow redefinition.  Make result
	"unspecified".
	* insn.scm (insn-builtin!): Don't define relaxable here, now defined in
	operand.scm.
	* operand.scm (operand-builtin!): Define RELAXABLE for insns too.
	* cpu/m32r.cpu (disp8,disp24): RELAX renamed to RELAXABLE.

	* gen-all-doc: Split arm and frv docs up a bit.

	* cpu/arm.cpu: Add IDOC attribute.
	* cpu/frv.cpu: Ditto.
	* cpu/i960.cpu: Ditto.
	* cpu/openrisc.cpu: Ditto.
	* cpu/xstormy16.cpu: Ditto.
	* cpu/m32r.cpu: Ditto.
	(all insns): Explicitly specify IDOC attribute.

	* Makefile.am (MACH,ISAS,INSN_FILE_NAME): New vars.
	(desc,opcodes,sim-arch,sim-cpu,gas-test,sim-test): Use MACH,ISAS.
	(html): Use MACH,ISAS,INSN_FILE_NAME.  Generate insn.html separately.
	* Makefile.in: Regenerate.
	* attr.scm (<integer-attribute>:parse-value-def): Implement.
	(-attr-read): Defer computing default value until we know the type.
	(attr-has-attr?): Delete, move contents to <attr-list>:has-attr?.
	(<attr-list>:attr-present?): New method.
	(atlist-attr-present?,obj-attr-present?): New fns.
	(obj-has-attr-value?,obj-has-attr-value-no-default?): New fns.
	(attr-builtin!): New insn attr IDOC.
	* cgen-doc.scm (doc-arguments): New args -I,-N.
	* enum.scm (parse-enum-vals): New arg errtxt, all callers updated.
	Support comment as fourth element of enum value.
	(enum-val-name,enum-val-value,enum-val-attrs,enum-val-comment): New fns.
	* html.scm (gen-html-header): New arg kind, all callers updated.
	(gen-table-of-contents): New arg insn-file, all callers updated.
	(gen-list-entry,gen-doc-header): New fn.
	(get-operands): Delete.
	(gen-iformat-table): Rewrite.
	(gen-insn-doc-1): Print constant-folded and trimmed semantics.
	(gen-insn-doc-list): New args name, comment, insns.  All callers updated.
	(get-insn-properties,guess-insn-idoc-attr!): New fn.
	(insn-sets-pc?,insn-refs-mem?,insn-uses-fpu?): New fns.
	(get-insns-for-category,gen-categories-insn-lists): New fns.
	(gen-insn-docs): Simplify each insn's semantics first.
	Print insn tables sorted by IDOC categories.
	(*insn-html-file-name*): New global.
	(cgen-insn.html): New fn.
	(cgen-all): Update.
	* insn.scm (<insn>): Create a setter for the `tmp' member.
	* semantics.scm (insn-build-known-values): Renamed from
	-build-known-values.  All callers updated.

	* rtl.scm: Move traveral/evaluation support to ...
	* rtl-traverse.scm: New file.
	* read.scm: Maybe-load rtl-traverse.scm.

	* rtl.scm (-rtx-valid-types): Add SETRTX.

	* rtx-funcs.scm (nop,parallel): Fix mode.

	* utils.scm (eqv-lookup-index): New fn.
	(assq-lookup-index): Renamed from lookup-index.  All callers updated.

	* dev.scm (load-doc): Set APPLICATION.
@
text
@d1559 3
a1561 4
  ; Also used for insns, and we can't define it twice, so we specify
  ; for insn here.
  (define-attr '(for operand insn) '(type boolean) '(name RELAXABLE)
    '(comment "operand/insn is relaxable"))
@


1.5
log
@	* mode.scm (mode-sem-mode): New fn.
	* operand.scm (op:new-mode): Update. mode-name.
	(op-natural-mode?) New fn.
	* rtl.scm (hw): Set hw-name,mode-name.
plus some comment tweaks
@
text
@d1558 5
a1562 2
  (define-attr '(for operand) '(type boolean) '(name RELAX)
    '(comment "operand is relaxable"))
@


1.4
log
@* belated outward merge

2001-01-26  Frank Ch. Eigler  <fche@@redhat.com>

	* sid-cpu.scm (gen-parallel-exec-type): Use unsigned long long for
	writeback tracking.
	(-gen-write-fn, -gen-sem-case, -gen-sfrag-case): Ditto.
	* sid-decode.scm (-gen-scache-decls): Exclude writeback tracking field
	if unnecessary.
	* sid.scm (<operand> gen-write): Use unsigned long long expression
	for writeback.
	(-op-gen-set-trace, -op-gen-set-trace-parallel): Ditto.
	(<unit> gen-profile-code): Ditto.

2001-01-08  Frank Ch. Eigler  <fche@@redhat.com>

	* operand.scm (<operand> pretty-sem-name): New field.
	(<operand> make): Initialize it from hw-name.
	(op:set-pretty-sem-name!): New function.
	(<operand> gen-pretty-name): Default to fetching new field.
	* rtl.scm (hw): Copy hw-name to pretty-sem-name instead.  Restore
	sem-name setting from -rtx-hw-name.
@
text
@d264 1
d286 1
d294 7
@


1.3
log
@2000-08-24  Frank Ch. Eigler  <fche@@redhat.com>

	* hardware.scm (<hw-immediate> get-index-mode): Define method.
	* operand.scm (<operand> gen-pretty-name): Tolerate no op:sem-name.
	* rtl-c.scm (-c-rtl-get): Improve an error message.
	* sim.scm (-op-gen-set-trace): Support <derived-operand> lvalues.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
d30 4
d104 1
d125 1
d224 3
a226 1
   (let* ((name (if (elm-bound? self 'sem-name) (elm-get self 'sem-name) (obj:name self)))
@


1.2
log
@* snapshot of work toward more complete support of derived-operands

2000-08-22  Frank Ch. Eigler  <fche@@redhat.com>

	* Makefile.in (DIST_COMMON): Regenerated.
	* ifield.scm (derived-ifield needed-iflds): New method.
	* iformat.scm (-ifmt-lookup-sfmt!): Use base ifields for
	sfmts built from derived-ifields.
	* operand.scm (-derived-parse-encoding): Give derived-ifield a fixed
	type symbol 'derived-ifield, not an unparseable string.
	* utils-sim.scm (op-needed-iflds) Handler 'derived-ifield case.
	(-sfmt-contents): Add tracing.

	From Doug Evans <dje@@transmeta.com>:
	* sim.scm (operand cxmake-get): Result is a <c-expr>, not a string of
	C code.
@
text
@d218 1
a218 1
   (let* ((name (op:sem-name self))
@


1.1
log
@Initial revision
@
text
@d769 1
a769 1
	  (string-append "<derived-ifield> for " operand-name)
d849 2
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
