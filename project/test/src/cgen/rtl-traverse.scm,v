head	1.22;
access;
symbols
	sid-snapshot-20180601:1.22
	cgen-snapshot-20180601:1.22
	sid-snapshot-20180501:1.22
	cgen-snapshot-20180501:1.22
	sid-snapshot-20180401:1.22
	cgen-snapshot-20180401:1.22
	sid-snapshot-20180301:1.22
	cgen-snapshot-20180301:1.22
	sid-snapshot-20180201:1.22
	cgen-snapshot-20180201:1.22
	sid-snapshot-20180101:1.22
	cgen-snapshot-20180101:1.22
	sid-snapshot-20171201:1.22
	cgen-snapshot-20171201:1.22
	sid-snapshot-20171101:1.22
	cgen-snapshot-20171101:1.22
	sid-snapshot-20171001:1.22
	cgen-snapshot-20171001:1.22
	sid-snapshot-20170901:1.22
	cgen-snapshot-20170901:1.22
	sid-snapshot-20170801:1.22
	cgen-snapshot-20170801:1.22
	sid-snapshot-20170701:1.22
	cgen-snapshot-20170701:1.22
	sid-snapshot-20170601:1.22
	cgen-snapshot-20170601:1.22
	sid-snapshot-20170501:1.22
	cgen-snapshot-20170501:1.22
	sid-snapshot-20170401:1.22
	cgen-snapshot-20170401:1.22
	sid-snapshot-20170301:1.22
	cgen-snapshot-20170301:1.22
	sid-snapshot-20170201:1.22
	cgen-snapshot-20170201:1.22
	sid-snapshot-20170101:1.22
	cgen-snapshot-20170101:1.22
	sid-snapshot-20161201:1.22
	cgen-snapshot-20161201:1.22
	sid-snapshot-20161101:1.22
	cgen-snapshot-20161101:1.22
	sid-snapshot-20160901:1.22
	cgen-snapshot-20160901:1.22
	sid-snapshot-20160801:1.22
	cgen-snapshot-20160801:1.22
	sid-snapshot-20160701:1.22
	cgen-snapshot-20160701:1.22
	sid-snapshot-20160601:1.22
	cgen-snapshot-20160601:1.22
	sid-snapshot-20160501:1.22
	cgen-snapshot-20160501:1.22
	sid-snapshot-20160401:1.22
	cgen-snapshot-20160401:1.22
	sid-snapshot-20160301:1.22
	cgen-snapshot-20160301:1.22
	sid-snapshot-20160201:1.22
	cgen-snapshot-20160201:1.22
	sid-snapshot-20160101:1.22
	cgen-snapshot-20160101:1.22
	sid-snapshot-20151201:1.22
	cgen-snapshot-20151201:1.22
	sid-snapshot-20151101:1.22
	cgen-snapshot-20151101:1.22
	sid-snapshot-20151001:1.22
	cgen-snapshot-20151001:1.22
	sid-snapshot-20150901:1.22
	cgen-snapshot-20150901:1.22
	sid-snapshot-20150801:1.22
	cgen-snapshot-20150801:1.22
	sid-snapshot-20150701:1.22
	cgen-snapshot-20150701:1.22
	sid-snapshot-20150601:1.22
	cgen-snapshot-20150601:1.22
	sid-snapshot-20150501:1.22
	cgen-snapshot-20150501:1.22
	sid-snapshot-20150401:1.22
	cgen-snapshot-20150401:1.22
	sid-snapshot-20150301:1.22
	cgen-snapshot-20150301:1.22
	sid-snapshot-20150201:1.22
	cgen-snapshot-20150201:1.22
	sid-snapshot-20150101:1.22
	cgen-snapshot-20150101:1.22
	sid-snapshot-20141201:1.22
	cgen-snapshot-20141201:1.22
	sid-snapshot-20141101:1.22
	cgen-snapshot-20141101:1.22
	sid-snapshot-20141001:1.22
	cgen-snapshot-20141001:1.22
	sid-snapshot-20140901:1.22
	cgen-snapshot-20140901:1.22
	sid-snapshot-20140801:1.22
	cgen-snapshot-20140801:1.22
	sid-snapshot-20140701:1.22
	cgen-snapshot-20140701:1.22
	sid-snapshot-20140601:1.22
	cgen-snapshot-20140601:1.22
	sid-snapshot-20140501:1.22
	cgen-snapshot-20140501:1.22
	sid-snapshot-20140401:1.22
	cgen-snapshot-20140401:1.22
	sid-snapshot-20140301:1.22
	cgen-snapshot-20140301:1.22
	sid-snapshot-20140201:1.22
	cgen-snapshot-20140201:1.22
	sid-snapshot-20140101:1.22
	cgen-snapshot-20140101:1.22
	sid-snapshot-20131201:1.22
	cgen-snapshot-20131201:1.22
	sid-snapshot-20131101:1.22
	cgen-snapshot-20131101:1.22
	sid-snapshot-20131001:1.22
	cgen-snapshot-20131001:1.22
	sid-snapshot-20130901:1.22
	cgen-snapshot-20130901:1.22
	sid-snapshot-20130801:1.22
	cgen-snapshot-20130801:1.22
	sid-snapshot-20130701:1.22
	cgen-snapshot-20130701:1.22
	sid-snapshot-20130601:1.22
	cgen-snapshot-20130601:1.22
	sid-snapshot-20130501:1.22
	cgen-snapshot-20130501:1.22
	sid-snapshot-20130401:1.22
	cgen-snapshot-20130401:1.22
	sid-snapshot-20130301:1.22
	cgen-snapshot-20130301:1.22
	sid-snapshot-20130201:1.22
	cgen-snapshot-20130201:1.22
	sid-snapshot-20130101:1.22
	cgen-snapshot-20130101:1.22
	sid-snapshot-20121201:1.22
	cgen-snapshot-20121201:1.22
	sid-snapshot-20121101:1.22
	cgen-snapshot-20121101:1.22
	sid-snapshot-20121001:1.22
	cgen-snapshot-20121001:1.22
	sid-snapshot-20120901:1.22
	cgen-snapshot-20120901:1.22
	sid-snapshot-20120801:1.22
	cgen-snapshot-20120801:1.22
	sid-snapshot-20120701:1.22
	cgen-snapshot-20120701:1.22
	sid-snapshot-20120601:1.22
	cgen-snapshot-20120601:1.22
	sid-snapshot-20120501:1.22
	cgen-snapshot-20120501:1.22
	sid-snapshot-20120401:1.22
	cgen-snapshot-20120401:1.22
	sid-snapshot-20120301:1.22
	cgen-snapshot-20120301:1.22
	sid-snapshot-20120201:1.22
	cgen-snapshot-20120201:1.22
	sid-snapshot-20120101:1.22
	cgen-snapshot-20120101:1.22
	sid-snapshot-20111201:1.22
	cgen-snapshot-20111201:1.22
	sid-snapshot-20111101:1.22
	cgen-snapshot-20111101:1.22
	sid-snapshot-20111001:1.22
	cgen-snapshot-20111001:1.22
	sid-snapshot-20110901:1.22
	cgen-snapshot-20110901:1.22
	sid-snapshot-20110801:1.22
	cgen-snapshot-20110801:1.22
	sid-snapshot-20110701:1.22
	cgen-snapshot-20110701:1.22
	sid-snapshot-20110601:1.22
	cgen-snapshot-20110601:1.22
	sid-snapshot-20110501:1.22
	cgen-snapshot-20110501:1.22
	sid-snapshot-20110401:1.22
	cgen-snapshot-20110401:1.22
	sid-snapshot-20110301:1.22
	cgen-snapshot-20110301:1.22
	sid-snapshot-20110201:1.22
	cgen-snapshot-20110201:1.22
	sid-snapshot-20110101:1.22
	cgen-snapshot-20110101:1.22
	sid-snapshot-20101201:1.22
	cgen-snapshot-20101201:1.22
	sid-snapshot-20101101:1.22
	cgen-snapshot-20101101:1.22
	sid-snapshot-20101001:1.22
	cgen-snapshot-20101001:1.22
	sid-snapshot-20100901:1.22
	cgen-snapshot-20100901:1.22
	sid-snapshot-20100801:1.22
	cgen-snapshot-20100801:1.22
	sid-snapshot-20100701:1.22
	cgen-snapshot-20100701:1.22
	sid-snapshot-20100601:1.22
	cgen-snapshot-20100601:1.22
	sid-snapshot-20100501:1.22
	cgen-snapshot-20100501:1.22
	sid-snapshot-20100401:1.22
	cgen-snapshot-20100401:1.22
	sid-snapshot-20100301:1.22
	cgen-snapshot-20100301:1.22
	sid-snapshot-20100201:1.22
	cgen-snapshot-20100201:1.22
	sid-snapshot-20100101:1.20
	cgen-snapshot-20100101:1.20
	sid-snapshot-20091201:1.20
	cgen-snapshot-20091201:1.20
	sid-snapshot-20091101:1.15
	cgen-snapshot-20091101:1.15
	sid-snapshot-20091001:1.15
	cgen-snapshot-20091001:1.15
	arc-sim-20090309:1.2
	sid-snapshot-20090901:1.10
	cgen-snapshot-20090901:1.10
	sid-snapshot-20090801:1.5
	cgen-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	cgen-snapshot-20090701:1.5
	dje-cgen-play1-branch:1.5.0.2
	dje-cgen-play1-branchpoint:1.5
	cgen-1_1-branch:1.2.0.6
	cgen-1_1-branchpoint:1.2
	sid-snapshot-20090601:1.2
	cgen-snapshot-20090601:1.2
	sid-snapshot-20090501:1.2
	cgen-snapshot-20090501:1.2
	sid-snapshot-20090401:1.2
	cgen-snapshot-20090401:1.2
	arc-insight_6_8-branch:1.2.0.4
	arc-insight_6_8-branchpoint:1.2
	sid-snapshot-20090301:1.2
	cgen-snapshot-20090301:1.2
	sid-snapshot-20090201:1.2
	cgen-snapshot-20090201:1.2
	sid-snapshot-20090101:1.2
	cgen-snapshot-20090101:1.2
	sid-snapshot-20081201:1.2
	cgen-snapshot-20081201:1.2
	sid-snapshot-20081101:1.2
	cgen-snapshot-20081101:1.2
	sid-snapshot-20081001:1.2
	cgen-snapshot-20081001:1.2
	sid-snapshot-20080901:1.2
	cgen-snapshot-20080901:1.2
	sid-snapshot-20080801:1.2
	cgen-snapshot-20080801:1.2
	sid-snapshot-20080701:1.2
	cgen-snapshot-20080701:1.2
	sid-snapshot-20080601:1.2
	cgen-snapshot-20080601:1.2
	sid-snapshot-20080501:1.2
	cgen-snapshot-20080501:1.2
	sid-snapshot-20080403:1.2
	sid-snapshot-20080401:1.2
	cgen-snapshot-20080401:1.2
	sid-snapshot-20080301:1.2
	cgen-snapshot-20080301:1.2
	sid-snapshot-20080201:1.2
	cgen-snapshot-20080201:1.2
	sid-snapshot-20080101:1.2
	cgen-snapshot-20080101:1.2
	sid-snapshot-20071201:1.2
	cgen-snapshot-20071201:1.2
	sid-snapshot-20071101:1.2
	cgen-snapshot-20071101:1.2
	sid-snapshot-20071001:1.2
	cgen-snapshot-20071001:1.2
	msnyder-fork-checkpoint-branch:1.2.0.2
	msnyder-fork-checkpoint-branchpoint:1.2;
locks; strict;
comment	@# @;


1.22
date	2010.01.25.00.40.29;	author devans;	state Exp;
branches;
next	1.21;

1.21
date	2010.01.21.07.34.56;	author devans;	state Exp;
branches;
next	1.20;

1.20
date	2009.11.14.20.16.34;	author devans;	state Exp;
branches;
next	1.19;

1.19
date	2009.11.05.16.55.33;	author devans;	state Exp;
branches;
next	1.18;

1.18
date	2009.11.03.16.24.02;	author devans;	state Exp;
branches;
next	1.17;

1.17
date	2009.11.01.21.09.57;	author devans;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.01.20.58.40;	author devans;	state Exp;
branches;
next	1.15;

1.15
date	2009.09.25.19.40.08;	author devans;	state Exp;
branches;
next	1.14;

1.14
date	2009.09.23.22.30.19;	author devans;	state Exp;
branches;
next	1.13;

1.13
date	2009.09.12.17.34.15;	author devans;	state Exp;
branches;
next	1.12;

1.12
date	2009.09.10.06.23.24;	author devans;	state Exp;
branches;
next	1.11;

1.11
date	2009.09.07.22.17.34;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2009.08.27.21.28.48;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2009.08.27.05.47.12;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2009.08.27.02.47.11;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2009.08.24.06.46.16;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	2009.08.12.22.33.37;	author devans;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.22.05.14.09;	author devans;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.21.17.53.17;	author devans;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.16.05.35.47;	author devans;	state Exp;
branches
	1.2.6.1;
next	1.1;

1.1
date	2003.06.10.21.22.03;	author devans;	state Exp;
branches;
next	;

1.2.6.1
date	2009.06.24.14.57.46;	author devans;	state Exp;
branches;
next	;


desc
@@


1.22
log
@	* utils-cgen.scm (<location>): Define using new define-class.
	(<ident>, <source-ident>, <context>): Ditto.

	* cos.scm (/object-string): New function.
	(/object-error): Use it.
	(/object-count-true): New function
	(object-copy-top): Delete.  All callers changed to call object-copy.
	(/parse-member-list, /build-getter-defs, /build-setter-defs): New fns.
	(define-class, define-interface, define-method): New macros.
	(define-getters, define-setters, vmake): Moved here ...
	* utils-cgen.scm: ... from here.
@
text
@;; RTL traversing support.
;; Copyright (C) 2000, 2001, 2009, 2010 Red Hat, Inc.
;; This file is part of CGEN.
;; See file COPYING.CGEN for details.

;; Canonicalization support.
;; Canonicalizing an rtl expression involves adding possibly missing options
;; and mode, and converting occurrences of DFLT into usable modes.
;; Various error checks are done as well.
;; This is done differently than traversal support because it has a more
;; specific purpose, it doesn't need to support arbitrary "expr-fns".
;; ??? At present the internal form is also the source form (easier debugging).

(define /rtx-canon-debug? #f)

;; Canonicalization state.
;; This carries the immutable elements only!
;; OUTER-EXPR is the EXPR argument to rtx-canonicalize.

(define (/make-cstate context isa-name-list outer-expr)
  (vector context isa-name-list outer-expr)
)

(define (/cstate-context cstate) (vector-ref cstate 0))
(define (/cstate-isas cstate) (vector-ref cstate 1))
(define (/cstate-outer-expr cstate) (vector-ref cstate 2))

;; Flag an error while canonicalizing rtl.

(define (/rtx-canon-error cstate errmsg expr parent-expr op-num)
  (let* ((pretty-parent-expr (rtx-pretty-strdump (/cstate-outer-expr cstate)))
	 (intro (if parent-expr
		    (string-append "While canonicalizing "
				   (rtx-strdump parent-expr)
				   (if op-num
				       (string-append ", operand #"
						      (number->string op-num))
				       "")
				   " of:\n"
				   pretty-parent-expr)
		    (string-append "While canonicalizing:\n" pretty-parent-expr))))
    (context-error (/cstate-context cstate) intro errmsg (rtx-dump expr)))
)

;; Lookup h/w object HW-NAME and return it (as a <hardware-base> object).
;; If multiple h/w objects with the same name are defined, require
;; all to have the same mode.
;; CHECK-KIND is a function of one argument to verify the h/w objects
;; are valid and if not flag an error.

(define (/rtx-lookup-hw cstate hw-name parent-expr check-kind)
  (let ((hw-objs (current-hw-sem-lookup hw-name)))

    (if (null? hw-objs)
	(/rtx-canon-error cstate "unknown h/w object"
			  hw-name parent-expr #f))

    ;; Just check the first one with CHECK-KIND.
    (check-kind (car hw-objs))

    (let* ((hw1 (car hw-objs))
	   (hw1-mode (hw-mode hw1))
	   (hw1-mode-name (obj:name hw1-mode)))

      ;; Allow multiple h/w objects with the same name
      ;; as long has they have the same mode.
      (if (> (length hw-objs) 1)
	  (let ((other-hw-mode-names (map (lambda (hw)
					    (obj:name (hw-mode hw)))
					  (cdr hw-objs))))
	    (if (not (all-true? (map (lambda (mode-name)
				       (eq? mode-name hw1-mode-name))
				     other-hw-mode-names)))
		(/rtx-canon-error cstate "multiple h/w objects with different modes selected"
				  hw-name parent-expr #f))))

      hw1))
)

;; Return the mode name to use in an expression given the requested mode
;; and the mode used in the expression.
;; If both are DFLT, leave it alone and hope the expression provides
;; enough info to pick a usable mode.
;; If both are provided, prefer the mode used in the expression.
;; If the modes are incompatible, return #f.

(define (/rtx-pick-mode cstate requested-mode-name expr-mode-name)
  (cond ((eq? requested-mode-name 'DFLT)
	 expr-mode-name)
	((eq? expr-mode-name 'DFLT)
	 requested-mode-name)
	(else
	 (let ((requested-mode (mode:lookup requested-mode-name))
	       (expr-mode (mode:lookup expr-mode-name)))
	   (if (not requested-mode)
	       (/rtx-canon-error cstate "invalid mode" requested-mode-name #f #f))
	   (if (not expr-mode)
	       (/rtx-canon-error cstate "invalid mode" expr-mode-name #f #f))
	   ;; FIXME: 'would prefer samesize or "no precision lost", sigh
	   (if (mode-compatible? 'sameclass requested-mode expr-mode)
	       expr-mode-name
	       expr-mode-name)))) ;; FIXME: should be #f, disabled pending completion of rtl mode handling rewrite
)

;; Return the mode name (as a symbol) to use in an object's rtl given
;; the requested mode, the mode used in the expression, and the object's
;; real mode.
;; If both requested mode and expr mode are DFLT, use the real mode.
;; If requested mode is DFLT, prefer expr mode.
;; If expr mode is DFLT, prefer the real mode.
;; If both requested mode and expr mode are specified, prefer expr-mode.
;; If there's an error the result is the error message (as a string).
;;
;; E.g. in (set SI dest (ifield DFLT f-r1)), the mode of the ifield's
;; expression is DFLT, the requested mode is SI, and the real mode of f-r1
;; may be INT.
;;
;; REAL-MODE is a <mode> object.

(define (/rtx-pick-mode3 requested-mode-name expr-mode-name real-mode)
  ;; Leave checking for (symbol? requested-mode-name) to caller (or higher).
  (let ((expr-mode (mode:lookup expr-mode-name)))
    (cond ((not expr-mode)
	   "unknown mode")
	  ((eq? requested-mode-name 'DFLT)
	   (if (eq? expr-mode-name 'DFLT)
	       (obj:name real-mode)
	       (if (rtx-mode-compatible? expr-mode real-mode)
		   expr-mode-name
		   (string-append "expression mode "
				  (symbol->string expr-mode-name)
				  " is incompatible with real mode "
				  (obj:str-name real-mode)))))
	  ((eq? expr-mode-name 'DFLT)
	   (if (rtx-mode-compatible? (mode:lookup requested-mode-name)
				     real-mode)
	       (obj:name real-mode)
	       (string-append "mode of containing expression "
			      (symbol->string requested-mode-name)
			      " is incompatible with real mode "
			      (obj:str-name real-mode))))
	  (else
	   (let ((requested-mode (mode:lookup requested-mode-name)))
	     (cond ((not (rtx-mode-compatible? requested-mode expr-mode))
		    (string-append "mode of containing expression "
				   (symbol->string requested-mode-name)
				   " is incompatible with expression mode "
				   (symbol->string expr-mode-name)))
		   ((not (rtx-mode-compatible? expr-mode real-mode))
		    (string-append "expression mode "
				   (symbol->string expr-mode-name)
				   " is incompatible with real mode "
				   (obj:str-name real-mode)))
		   (else
		    expr-mode-name))))))
)

;; Return the mode name (as a symbol) to use in an operand's rtl given
;; the requested mode, the mode used in the expression, and the operand's
;; real mode.
;; If both requested mode and expr mode are DFLT, use the real mode.
;; If requested mode is DFLT, prefer expr mode.
;; If expr mode is DFLT, prefer the real mode.
;; If both requested mode and expr mode are specified, prefer expr-mode.
;; If the modes are incompatible an error is signalled.
;;
;; E.g. in (set QI (mem QI src2) src1), the mode to set is QI, but if src1
;; is a 32-bit (SI) register we want QI.
;; OTOH, in (set QI (mem QI src2) uimm8), the mode to set is QI, but we want
;; the real mode of uimm8.
;;
;; ??? This is different from /rtx-pick-mode3 for compatibility with
;; pre-full-canonicalization versions.
;  It's currently a toss-up on whether it improves things.
;;
;; OP is an <operand> object.
;;
;; Things are complicated because multiple versions of a h/w object can be
;; defined, and the operand refers to the h/w by name.
;; op:type, which op:mode calls, will flag an error if multiple versions of
;; a h/w object are defined - only one should have been kept during .cpu
;; file loading.  This is for semantic code generation, but for generating
;; files covering the entire architecture we need to keep all the versions.
;; Things are ok, as far as canonicalization is concerned, if all h/w versions
;; have the same mode (which could be WI for 32/64 arches).

(define (/rtx-pick-op-mode cstate requested-mode-name expr-mode-name op
			   parent-expr)
  ;; Leave checking for (symbol? requested-mode-name) to caller (or higher).
  (let* ((op-mode-name (op:mode-name op))
	 (hw (/rtx-lookup-hw cstate (op:hw-name op) parent-expr
			     (lambda (hw) *UNSPECIFIED*)))
	 (op-mode (if (eq? op-mode-name 'DFLT)
		      (hw-mode hw)
		      (mode:lookup op-mode-name)))
	 (expr-mode (mode:lookup expr-mode-name)))
    (cond ((not expr-mode)
	   (/rtx-canon-error cstate "unknown mode" expr-mode-name
			     parent-expr #f))
	  ((eq? requested-mode-name 'DFLT)
	   (if (eq? expr-mode-name 'DFLT)
	       (obj:name op-mode)
	       (if (rtx-mode-compatible? expr-mode op-mode)
		   expr-mode-name
		   (/rtx-canon-error cstate
				     (string-append
				      "expression mode "
				      (symbol->string expr-mode-name)
				      " is incompatible with operand mode "
				      (obj:str-name op-mode))
				     expr-mode-name parent-expr #f))))
	  ((eq? expr-mode-name 'DFLT)
	   (if (rtx-mode-compatible? (mode:lookup requested-mode-name)
				     op-mode)
; FIXME: Experiment.  It's currently a toss-up on whether it improves things.
;	       (cond ((pc? op)
;		      (obj:name op-mode))
;		     ((register? hw)
;		      requested-mode-name)
;		     (else
;		      (obj:name op-mode)))
	       (obj:name op-mode)
	       (/rtx-canon-error cstate
				 (string-append
				  "mode of containing expression "
				  (symbol->string requested-mode-name)
				  " is incompatible with operand mode "
				  (obj:str-name op-mode))
				 requested-mode-name parent-expr #f)))
	  (else
	   (let ((requested-mode (mode:lookup requested-mode-name)))
	     (cond ((not (rtx-mode-compatible? requested-mode expr-mode))
		    (/rtx-canon-error cstate
				      (string-append
				       "mode of containing expression "
				       (symbol->string requested-mode-name)
				       " is incompatible with expression mode "
				       (symbol->string expr-mode-name))
				      requested-mode-name parent-expr #f))
		   ((not (rtx-mode-compatible? expr-mode op-mode))
		    (/rtx-canon-error cstate
				      (string-append
				       "expression mode "
				       (symbol->string expr-mode-name)
				       " is incompatible with operand mode "
				       (obj:str-name op-mode))
				      expr-mode-name parent-expr #f))
		   (else
		    expr-mode-name))))))
)

;; Return the last rtx in cond or case expression EXPR.

(define (/rtx-get-last-cond-case-rtx expr)
  (let ((len (length expr)))
    (list-ref expr (- len 1)))
)

;; Canonicalize a list of rtx's.
;; The mode of rtxes prior to the last one must be VOID.

(define (/rtx-canon-rtx-list rtx-list mode parent-expr op-num cstate env depth)
  (let* ((nr-rtxes (length rtx-list))
	 (last-op-num (- nr-rtxes 1)))
    (map (lambda (rtx op-num)
	   (/rtx-canon rtx 'RTX
		       (if (= op-num last-op-num) mode 'VOID)
		       parent-expr op-num cstate env depth))
	 rtx-list (iota nr-rtxes)))
)

;; Rtx canonicalizers.
;; These are defined as individual functions that are then built into a table
;; mostly for simplicity.
;
;; The result is either a pair of the parsed VAL and new environment,
;; or #f meaning there is no change (saves lots of unnecessarying cons'ing).

(define (/rtx-canon-options val mode parent-expr op-num cstate env depth)
  #f
)

(define (/rtx-canon-anyintmode val mode parent-expr op-num cstate env depth)
  (let ((val-obj (mode:lookup val)))
    (if (and val-obj
	     (or (memq (mode:class val-obj) '(INT UINT))
		 (eq? val 'DFLT)))
	#f
	(/rtx-canon-error cstate "expecting an integer mode"
			  val parent-expr op-num)))
)

(define (/rtx-canon-anyfloatmode val mode parent-expr op-num cstate env depth)
  (let ((val-obj (mode:lookup val)))
    (if (and val-obj
	     (or (memq (mode:class val-obj) '(FLOAT))
		 (eq? val 'DFLT)))
	#f
	(/rtx-canon-error cstate "expecting a float mode"
			  val parent-expr op-num)))
)

(define (/rtx-canon-anynummode val mode parent-expr op-num cstate env depth)
  (let ((val-obj (mode:lookup val)))
    (if (and val-obj
	     (or (memq (mode:class val-obj) '(INT UINT FLOAT))
		 (eq? val 'DFLT)))
	#f
	(/rtx-canon-error cstate "expecting a numeric mode"
			  val parent-expr op-num)))
)

(define (/rtx-canon-anyexprmode val mode parent-expr op-num cstate env depth)
  (let ((val-obj (mode:lookup val)))
    (if (and val-obj
	     (or (memq (mode:class val-obj) '(INT UINT FLOAT))
		 (memq val '(DFLT PTR VOID SYM))))
	#f
	(/rtx-canon-error cstate "expecting a numeric mode, PTR, VOID, or SYM"
			  val parent-expr op-num)))
)

(define (/rtx-canon-anycexprmode val mode parent-expr op-num cstate env depth)
  (let ((val-obj (mode:lookup val)))
    (if (and val-obj
	     (or (memq (mode:class val-obj) '(INT UINT FLOAT))
		 (memq val '(DFLT PTR VOID))))
	#f
	(/rtx-canon-error cstate "expecting a numeric mode, PTR, or VOID"
			  val parent-expr op-num)))
)

(define (/rtx-canon-explnummode val mode parent-expr op-num cstate env depth)
  (let ((val-obj (mode:lookup val)))
    (if (and val-obj
	     (memq (mode:class val-obj) '(INT UINT FLOAT)))
	#f
	(/rtx-canon-error cstate "expecting an explicit numeric mode"
			  val parent-expr op-num)))
)

(define (/rtx-canon-voidornummode val mode parent-expr op-num cstate env depth)
  (let ((val-obj (mode:lookup val)))
    (if (and val-obj
	     (or (memq (mode:class val-obj) '(INT UINT FLOAT))
		 (memq val '(DFLT VOID))))
	#f
	(/rtx-canon-error cstate "expecting void or a numeric mode"
			  val parent-expr op-num)))
)

(define (/rtx-canon-voidmode val mode parent-expr op-num cstate env depth)
  (if (memq val '(DFLT VOID))
      (cons 'VOID env)
      (/rtx-canon-error cstate "expecting VOID mode"
			val parent-expr op-num))
)

(define (/rtx-canon-bimode val mode parent-expr op-num cstate env depth)
  (if (memq val '(DFLT BI))
      (cons 'BI env)
      (/rtx-canon-error cstate "expecting BI mode"
			val parent-expr op-num))
)

(define (/rtx-canon-intmode val mode parent-expr op-num cstate env depth)
  (if (memq val '(DFLT INT))
      (cons 'INT env)
      (/rtx-canon-error cstate "expecting INT mode"
			val parent-expr op-num))
)

(define (/rtx-canon-symmode val mode parent-expr op-num cstate env depth)
  (if (memq val '(DFLT SYM))
      (cons 'SYM env)
      (/rtx-canon-error cstate "expecting SYM mode"
			val parent-expr op-num))
)

(define (/rtx-canon-insnmode val mode parent-expr op-num cstate env depth)
  (if (memq val '(DFLT INSN))
      (cons 'INSN env)
      (/rtx-canon-error cstate "expecting INSN mode"
			val parent-expr op-num))
)

(define (/rtx-canon-machmode val mode parent-expr op-num cstate env depth)
  (if (memq val '(DFLT MACH))
      (cons 'MACH env)
      (/rtx-canon-error cstate "expecting MACH mode"
			val parent-expr op-num))
)

(define (/rtx-canon-rtx val mode parent-expr op-num cstate env depth)
; Commented out 'cus it doesn't quite work yet.
; (if (not (rtx? val))
;     (/rtx-canon-error cstate "expecting an rtx" val parent-expr op-num))
  (cons (/rtx-canon val 'RTX mode parent-expr op-num cstate env depth)
	env)
)

(define (/rtx-canon-setrtx val mode parent-expr op-num cstate env depth)
; Commented out 'cus it doesn't quite work yet.
; (if (not (rtx? val))
;     (/rtx-canon-error cstate "expecting an rtx" val parent-expr op-num))
  (let ((dest (/rtx-canon val 'SETRTX mode parent-expr op-num cstate env depth)))
    (cons dest env))
)

;; This is the test of an `if'.

(define (/rtx-canon-testrtx val mode parent-expr op-num cstate env depth)
; Commented out 'cus it doesn't quite work yet.
; (if (not (rtx? val))
;     (/rtx-canon-error cstate "expecting an rtx"
;			  val parent-expr op-num))
  (cons (/rtx-canon val 'RTX mode parent-expr op-num cstate env depth)
	env)
)

(define (/rtx-canon-condrtx val mode parent-expr op-num cstate env depth)
  (if (not (pair? val))
      (/rtx-canon-error cstate "expecting an expression"
			  val parent-expr op-num))
  (if (eq? (car val) 'else)
      (begin
	(if (!= (+ op-num 2) (length parent-expr))
	    (/rtx-canon-error cstate "`else' clause not last"
			      val parent-expr op-num))
	(cons (cons 'else
		    (/rtx-canon-rtx-list
		     (cdr val) mode parent-expr op-num cstate env depth))
	      env))
      (cons (cons
	     ;; ??? Entries after the first are conditional.
	     (/rtx-canon (car val) 'RTX 'INT parent-expr op-num cstate env depth)
	     (/rtx-canon-rtx-list
	      (cdr val) mode parent-expr op-num cstate env depth))
	    env))
)

(define (/rtx-canon-casertx val mode parent-expr op-num cstate env depth)
  (if (or (not (list? val))
	  (< (length val) 2))
      (/rtx-canon-error cstate "invalid `case' expression"
			val parent-expr op-num))
  ;; car is either 'else or list of symbols/numbers
  (if (not (or (eq? (car val) 'else)
	       (and (list? (car val))
		    (not (null? (car val)))
		    (all-true? (map /rtx-symornum?
				    (car val))))))
      (/rtx-canon-error cstate "invalid `case' choice"
			val parent-expr op-num))
  (if (and (eq? (car val) 'else)
	   (!= (+ op-num 2) (length parent-expr)))
      (/rtx-canon-error cstate "`else' clause not last"
			val parent-expr op-num))
  (cons (cons (car val)
	      (/rtx-canon-rtx-list
	       (cdr val) mode parent-expr op-num cstate env depth))
	env)
)

(define (/rtx-canon-locals val mode parent-expr op-num cstate env depth)
  (if (not (list? val))
      (/rtx-canon-error cstate "bad locals list"
			val parent-expr op-num))
  (for-each (lambda (var)
	      (if (or (not (list? var))
		      (!= (length var) 2)
		      (not (/rtx-any-mode? (car var)))
		      (not (symbol? (cadr var))))
		  (/rtx-canon-error cstate "bad locals list"
				    val parent-expr op-num)))
	    val)
  (let ((new-env (rtx-env-make-locals val)))
    (cons val (cons new-env env)))
)

(define (/rtx-canon-iteration val mode parent-expr op-num cstate env depth)
  (if (not (symbol? val))
      (/rtx-canon-error cstate "bad iteration variable name"
			val parent-expr op-num))
  (let ((new-env (rtx-env-make-iteration-locals val)))
    (cons val (cons new-env env)))
)

(define (/rtx-canon-symbol-list val mode parent-expr op-num cstate env depth)
  (if (or (not (list? val))
	  (not (all-true? (map symbol? val))))
      (/rtx-canon-error cstate "bad symbol list"
			val parent-expr op-num))
  #f
)

(define (/rtx-canon-env-stack val mode parent-expr op-num cstate env depth)
  ;; VAL is an environment stack.
  (if (not (list? val))
      (/rtx-canon-error cstate "environment not a list"
			val parent-expr op-num))
  ;; FIXME: Shouldn't this push VAL onto ENV?
  (cons val env)
)

(define (/rtx-canon-attrs val mode parent-expr op-num cstate env depth)
;  (cons val ; (atlist-source-form (atlist-parse (make-prefix-cstate "with-attr") val ""))
;	env)
  #f
)

(define (/rtx-canon-symbol val mode parent-expr op-num cstate env depth)
  (if (not (symbol? val))
      (/rtx-canon-error cstate "expecting a symbol"
			val parent-expr op-num))
  #f
)

(define (/rtx-canon-string val mode parent-expr op-num cstate env depth)
  (if (not (string? val))
      (/rtx-canon-error cstate "expecting a string"
			val parent-expr op-num))
  #f
)

(define (/rtx-canon-number val mode parent-expr op-num cstate env depth)
  (if (not (number? val))
      (/rtx-canon-error cstate "expecting a number"
			val parent-expr op-num))
  #f
)

(define (/rtx-canon-symornum val mode parent-expr op-num cstate env depth)
  (if (not (or (symbol? val) (number? val)))
      (/rtx-canon-error cstate "expecting a symbol or number"
			val parent-expr op-num))
  #f
)

(define (/rtx-canon-object val mode parent-expr op-num cstate env depth)
  #f
)

;; Table of rtx canonicalizers.
;; This is a vector of size rtx-max-num.
;; Each entry is a list of (arg-type-name . canonicalizer) elements
;; for rtx-arg-types.
;; FIXME: Initialized in rtl.scm (i.e. outside this file).

(define /rtx-canoner-table #f)

;; Return a hash table of standard operand canonicalizers.
;; The result of each canonicalizer is a pair of the canonical form
;; of `val' and a possibly new environment or #f if there is no change.

(define (/rtx-make-canon-table)
  (let ((hash-tab (make-hash-table 31))
	(canoners
	 (list
	  (cons 'OPTIONS /rtx-canon-options)
	  (cons 'ANYINTMODE /rtx-canon-anyintmode)
	  (cons 'ANYFLOATMODE /rtx-canon-anyfloatmode)
	  (cons 'ANYNUMMODE /rtx-canon-anynummode)
	  (cons 'ANYEXPRMODE /rtx-canon-anyexprmode)
	  (cons 'ANYCEXPRMODE /rtx-canon-anycexprmode)
	  (cons 'EXPLNUMMODE /rtx-canon-explnummode)
	  (cons 'VOIDORNUMMODE /rtx-canon-voidornummode)
	  (cons 'VOIDMODE /rtx-canon-voidmode)
	  (cons 'BIMODE /rtx-canon-bimode)
	  (cons 'INTMODE /rtx-canon-intmode)
	  (cons 'SYMMODE /rtx-canon-symmode)
	  (cons 'INSNMODE /rtx-canon-insnmode)
	  (cons 'MACHMODE /rtx-canon-machmode)
	  (cons 'RTX /rtx-canon-rtx)
	  (cons 'SETRTX /rtx-canon-setrtx)
	  (cons 'TESTRTX /rtx-canon-testrtx)
	  (cons 'CONDRTX /rtx-canon-condrtx)
	  (cons 'CASERTX /rtx-canon-casertx)
	  (cons 'LOCALS /rtx-canon-locals)
	  (cons 'ITERATION /rtx-canon-iteration)
	  (cons 'SYMBOLLIST /rtx-canon-symbol-list)
	  (cons 'ENVSTACK /rtx-canon-env-stack)
	  (cons 'ATTRS /rtx-canon-attrs)
	  (cons 'SYMBOL /rtx-canon-symbol)
	  (cons 'STRING /rtx-canon-string)
	  (cons 'NUMBER /rtx-canon-number)
	  (cons 'SYMORNUM /rtx-canon-symornum)
	  (cons 'OBJECT /rtx-canon-object)
	  )))

    (for-each (lambda (canoner)
		(hashq-set! hash-tab (car canoner) (cdr canoner)))
	      canoners)

    hash-tab)
)

;; Standard expression operand canonicalizer.
;; Loop over the operands, verifying them according to the argument type
;; and mode matcher, and replace DFLT with a usable mode.

(define (/rtx-canon-operands rtx-obj requested-mode-name
			     func args parent-expr parent-op-num
			     cstate env depth)
  ;; ??? Might want to just leave operands as a list.
  (let* ((operands (list->vector args))
	 (nr-operands (vector-length operands))
	 (this-expr (cons func args)) ;; For error messages.
	 (expr-mode 
	  ;; For sets, the requested mode is DFLT or VOID (the mode of the
	  ;; result), but the mode we want is the mode of the set destination.
	  (if (rtx-result-mode rtx-obj)
	      (cadr args) ;; mode of arg2 doesn't come from containing expr
	      (/rtx-pick-mode cstate requested-mode-name (cadr args))))
	 (all-arg-types (vector-ref /rtx-canoner-table (rtx-num rtx-obj))))

    (if (not expr-mode)
	(/rtx-canon-error cstate
			  (string-append "requested mode "
					 (symbol->string requested-mode-name)
					 " is incompatible with expression mode "
					 (symbol->string (cadr args)))
			  this-expr parent-expr #f))

    (if /rtx-canon-debug?
	(begin
	  (display (spaces (* 4 depth)))
	  (display "expr-mode ")
	  (display expr-mode)
	  (newline)
	  (force-output)))

    (let loop ((env env)
	       (op-num 0)
	       (arg-types all-arg-types)
	       (arg-modes (rtx-arg-modes rtx-obj)))

      (let ((varargs? (and (pair? arg-types) (symbol? (car arg-types)))))

	(if /rtx-canon-debug?
	    (begin
	      (display (spaces (* 4 depth)))
	      (if (= op-num nr-operands)
		  (display "end of operands")
		  (begin
		    (display "op-num ") (display op-num) (display ": ")
		    (display (rtx-dump (vector-ref operands op-num)))
		    (display ", ")
		    (display (if varargs? (car arg-types) (caar arg-types)))
		    (display ", ")
		    (display (if varargs? arg-modes (car arg-modes)))
		    ))
	      (newline)
	      (force-output)))

	(cond ((= op-num nr-operands)

	       ;; Out of operands, check if we have the expected number.
	       (if (or (null? arg-types)
		       varargs?)

		   ;; We're theoretically done.
		   (let ((set-mode-from-arg!
			  (lambda (arg-num)
			    (if /rtx-canon-debug?
				(begin
				  (display (spaces (* 4 depth)))
				  (display "Computing expr mode from arguments.")
				  (newline)))
			    (let* ((expr-to-match 
				    (case func
				      ((cond case)
				       (/rtx-get-last-cond-case-rtx (vector-ref operands arg-num)))
				      (else
				       (vector-ref operands arg-num))))
				   (expr-to-match-obj (rtx-lookup (rtx-name expr-to-match)))
				   (new-expr-mode (or (rtx-result-mode expr-to-match-obj)
						      (let ((expr-mode (rtx-mode expr-to-match)))
							(if (eq? expr-mode 'DFLT)
							    (if (eq? requested-mode-name 'DFLT)
								(/rtx-canon-error cstate
										  "unable to determine mode of expression from arguments, please specify a mode"
										  this-expr parent-expr #f)
								requested-mode-name)
							    expr-mode)))))
			      ;; Verify the mode to be recorded matches the spec.
			      (let* ((expr-mode-spec (cadr all-arg-types))
				     (canoner (cdr expr-mode-spec)))
				;; Ignore the result of the canoner, we just
				;; want the error checking.
				(canoner new-expr-mode #f this-expr 1
					 cstate env depth))
			      (vector-set! operands 1 new-expr-mode)))))

		     ;; The expression's mode might still be DFLT.
		     ;; If it is, fetch the mode of the MATCHEXPR operand,
		     ;; or MATCHSEQ operand, or containing expression.
		     ;; If it's still DFLT, flag an error.
		     (if (eq? (vector-ref operands 1) 'DFLT)
			 (cond ((rtx-matchexpr-index rtx-obj)
				=> (lambda (matchexpr-index)
				     (set-mode-from-arg! matchexpr-index)))
			       ((eq? func 'sequence)
				(set-mode-from-arg! (- nr-operands 1)))
			       (else
				(if /rtx-canon-debug?
				    (begin
				      (display (spaces (* 4 depth)))
				      (display "Computing expr mode from containing expression.")
				      (newline)))
				(if (or (eq? requested-mode-name 'DFLT)
					(rtx-result-mode rtx-obj))
				    (/rtx-canon-error cstate
						      "unable to determine mode of expression, please specify a mode"
						      this-expr parent-expr #f)
				    (vector-set! operands 1 requested-mode-name)))))
		     (vector->list operands))

		   (/rtx-canon-error cstate "missing operands"
				     this-expr parent-expr #f)))

	      ((null? arg-types)
	       (/rtx-canon-error cstate "too many operands"
				 this-expr parent-expr #f))

	      (else
	       (let ((type (if varargs? arg-types (car arg-types)))
		     (mode (let ((mode-spec (if varargs?
						arg-modes
						(car arg-modes))))
			     ;; We don't necessarily have enough information
			     ;; at this point.  Just propagate what we do know,
			     ;; and leave it for final processing to fix up what
			     ;; we missed.
			     ;; This is small enough that case is fast enough,
			     ;; and the number of entries should be stable.
			     (case mode-spec
			       ((ANY) 'DFLT)
			       ((ANYINT) 'DFLT) ;; FIXME
			       ((NA) #f)
			       ((MATCHEXPR) expr-mode)
			       ((MATCHSEQ)
				(if (= (+ op-num 1) nr-operands) ;; last one?
				    expr-mode
				    'VOID))
			       ((MATCH2)
				;; This is complicated by the fact that some
				;; rtx have a different result mode than what
				;; is specified in the rtl (e.g. set, eq).
				;; ??? Make these rtx specify both modes?
				(let* ((op2 (vector-ref operands 2))
				       (op2-obj (rtx-lookup (rtx-name op2))))
				  (or (rtx-result-mode op2-obj)
				      (rtx-mode op2))))
			       ((MATCH3)
				;; This is complicated by the fact that some
				;; rtx have a different result mode than what
				;; is specified in the rtl (e.g. set, eq).
				;; ??? Make these rtx specify both modes?
				(let* ((op2 (vector-ref operands 3))
				       (op2-obj (rtx-lookup (rtx-name op2))))
				  (or (rtx-result-mode op2-obj)
				      (rtx-mode op2))))
			       ;; Otherwise mode-spec is the mode to use.
			       (else mode-spec))))
		     (val (vector-ref operands op-num))
		     )

		 ;; Look up the canoner for this operand and perform it.
		 ;; FIXME: This would benefit from returning multiple values.
		 (let ((canoner (cdr type)))
		   (let ((canon-val (canoner val mode this-expr op-num
					     cstate env depth)))
		     (if canon-val
			 (begin
			   (set! val (car canon-val))
			   (set! env (cdr canon-val))))))

		 (vector-set! operands op-num val)

		 ;; Done with this operand, proceed to the next.
		 (loop env
		       (+ op-num 1)
		       (if varargs? arg-types (cdr arg-types))
		       (if varargs? arg-modes (cdr arg-modes)))))))))
)

(define (/rtx-canon-rtx-enum rtx-obj requested-mode-name
			     func args parent-expr parent-op-num
			     cstate env depth)
  (if (!= (length args) 3)
      (/rtx-canon-error cstate "wrong number of operands to enum, expecting 3"
			(cons func args) parent-expr #f))

  (let ((mode-name (cadr args))
	(enum-name (caddr args)))
    (let ((mode-obj (mode:lookup mode-name))
	  (enum-val-and-obj (enum-lookup-val enum-name)))

      (if (not enum-val-and-obj)
	  (/rtx-canon-error cstate "unknown enum value"
			    enum-name parent-expr #f))

      (let ((expr-mode-or-errmsg (/rtx-pick-mode3 requested-mode-name mode-name INT)))
	(if (symbol? expr-mode-or-errmsg)
	    (list (car args) expr-mode-or-errmsg enum-name)
	    (/rtx-canon-error cstate expr-mode-or-errmsg
			      enum-name parent-expr #f)))))
)

(define (/rtx-canon-rtx-ifield rtx-obj requested-mode-name
			       func args parent-expr parent-op-num
			       cstate env depth)
  (if (!= (length args) 3)
      (/rtx-canon-error cstate "wrong number of operands to ifield, expecting 3"
			(cons func args) parent-expr #f))

  (let ((expr-mode-name (cadr args))
	(ifld-name (caddr args)))
    (let ((ifld-obj (current-ifld-lookup ifld-name)))

      (if ifld-obj

	  (let ((mode-or-errmsg (/rtx-pick-mode3 requested-mode-name
						 expr-mode-name
						 (ifld-mode ifld-obj))))
	    (if (symbol? mode-or-errmsg)
		(list (car args) mode-or-errmsg ifld-name)
		(/rtx-canon-error cstate mode-or-errmsg expr-mode-name
				  parent-expr parent-op-num)))

	  (/rtx-canon-error cstate "unknown ifield"
			    ifld-name parent-expr #f))))
)

(define (/rtx-canon-rtx-operand rtx-obj requested-mode-name
				func args parent-expr parent-op-num
				cstate env depth)
  (if (!= (length args) 3)
      (/rtx-canon-error cstate "wrong number of operands to operand, expecting 3"
			(cons func args) parent-expr #f))

  (let ((expr-mode-name (cadr args))
	(op-name (caddr args)))
    (let ((op-obj (current-op-lookup op-name (/cstate-isas cstate))))

      (if op-obj

	  (let ((mode (/rtx-pick-op-mode cstate requested-mode-name
					 expr-mode-name op-obj parent-expr)))
	    (list (car args) mode op-name))

	  (/rtx-canon-error cstate "unknown operand"
			    op-name parent-expr #f))))
)

(define (/rtx-canon-rtx-xop rtx-obj requested-mode-name
			    func args parent-expr parent-op-num
			    cstate env depth)
  (if (!= (length args) 3)
      (/rtx-canon-error cstate "wrong number of operands to xop, expecting 3"
			(cons func args) parent-expr #f))

  (let ((expr-mode-name (cadr args))
	(xop-obj (caddr args)))

    (if (operand? xop-obj)

	(let ((mode-or-errmsg (/rtx-pick-mode3 requested-mode-name
					       expr-mode-name
					       (op:mode xop-obj))))
	  (if (symbol? mode-or-errmsg)
	      (list (car args) mode-or-errmsg xop-obj)
	      (/rtx-canon-error cstate mode-or-errmsg expr-mode-name
				parent-expr parent-op-num)))

	(/rtx-canon-error cstate "xop operand #2 not an operand"
			  (obj:name xop-obj) parent-expr #f)))
)

(define (/rtx-canon-rtx-local rtx-obj requested-mode-name
			      func args parent-expr parent-op-num
			      cstate env depth)
  (if (!= (length args) 3)
      (/rtx-canon-error cstate "wrong number of operands to local, expecting 3"
			(cons func args) parent-expr #f))

  (let ((expr-mode-name (cadr args))
	(local-name (caddr args)))
    (let ((local-obj (rtx-temp-lookup env local-name)))

      (if local-obj

	  (let ((mode-or-errmsg (/rtx-pick-mode3 requested-mode-name
						 expr-mode-name
						 (rtx-temp-mode local-obj))))
	    (if (symbol? mode-or-errmsg)
		(list (car args) mode-or-errmsg local-name)
		(/rtx-canon-error cstate mode-or-errmsg expr-mode-name
				  parent-expr parent-op-num)))

	  (/rtx-canon-error cstate "unknown local"
			    local-name parent-expr #f))))
)

(define (/rtx-canon-rtx-ref rtx-obj requested-mode-name
			    func args parent-expr parent-op-num
			    cstate env depth)
  (if (!= (length args) 3)
      (/rtx-canon-error cstate "wrong number of operands to ref, expecting 3"
			(cons func args) parent-expr #f))

  (let ((expr-mode-name (cadr args))
	(ref-name (caddr args)))
    ;; FIXME: Will current-op-lookup find named operands?
    (let ((op-obj (current-op-lookup ref-name (/cstate-isas cstate))))

      (if op-obj

	  ;; The result of "ref" is canonically an INT.
	  (let ((mode-or-errmsg (/rtx-pick-mode3 requested-mode-name
						 expr-mode-name
						 INT)))
	    (if (symbol? mode-or-errmsg)
		(list (car args) mode-or-errmsg ref-name)
		(/rtx-canon-error cstate mode-or-errmsg expr-mode-name
				  parent-expr parent-op-num)))

	  (/rtx-canon-error cstate "unknown operand"
			    ref-name parent-expr #f))))
)

(define (/rtx-canon-rtx-reg rtx-obj requested-mode-name
			    func args parent-expr parent-op-num
			    cstate env depth)
  (let ((len (length args)))
    (if (or (< len 3) (> len 5))
	(/rtx-canon-error cstate
			  ;; TODO: be more firm on expected number of args
			  (string-append
			   "wrong number of operands to "
			   (symbol->string func)
			   ", expecting 3 (or possibly 4,5)")
			  (cons func args) parent-expr #f))

    (let ((expr-mode-name (cadr args))
	  (hw-name (caddr args))
	  (this-expr (cons func args)))
      (let* ((hw (/rtx-lookup-hw cstate hw-name parent-expr
				 (lambda (hw)
				   (if (not (register? hw))
				       (/rtx-canon-error cstate "not a register" hw-name
							 parent-expr parent-op-num))
				   *UNSPECIFIED*)))
	     (hw-mode-obj (hw-mode hw)))

	(let ((mode-or-errmsg (/rtx-pick-mode3 requested-mode-name
					       expr-mode-name
					       hw-mode-obj)))

	  (if (symbol? mode-or-errmsg)

	      ;; Canonicalizing optional index/selector.
	      (let ((index (if (>= len 4)
			       (let ((canon (/rtx-canon-rtx
					     (list-ref args 3) 'INT
					     this-expr 3 cstate env depth)))
				 (car canon)) ;; discard env
			       #f))
		    (sel (if (= len 5)
			     (let ((canon (/rtx-canon-rtx
					   (list-ref args 4) 'INT
					   this-expr 4 cstate env depth)))
			       (car canon)) ;; discard env
			     #f)))
		(if sel
		    (begin
		      (assert index)
		      (list (car args) mode-or-errmsg hw-name index sel))
		    (if index
			(list (car args) mode-or-errmsg hw-name index)
			(list (car args) mode-or-errmsg hw-name))))

	      (/rtx-canon-error cstate mode-or-errmsg expr-mode-name
				parent-expr parent-op-num))))))
)

(define (/rtx-canon-rtx-mem rtx-obj requested-mode-name
			    func args parent-expr parent-op-num
			    cstate env depth)
  (let ((len (length args)))
    (if (or (< len 3) (> len 4))
	(/rtx-canon-error cstate
			  "wrong number of operands to mem, expecting 3 (or possibly 4)"
			  (cons func args) parent-expr #f))

    (let ((expr-mode-name (cadr args))
	  (addr-expr (caddr args))
	  (this-expr (cons func args)))

      ;; Call /rtx-canon-explnummode just for the error checking.
      (/rtx-canon-explnummode expr-mode-name #f this-expr 1 cstate env depth)

      (if (and (not (eq? requested-mode-name 'DFLT))
	       ;; FIXME: 'would prefer samesize or "no precision lost", sigh
	       (not (mode-compatible? 'sameclass
				      requested-mode-name expr-mode-name)))
	  (/rtx-canon-error cstate
			    (string-append "requested mode "
					   (symbol->string requested-mode-name)
					   " is incompatible with expression mode "
					   (symbol->string expr-mode-name))
			    this-expr parent-expr #f))

      (let ((addr (car ;; discard env
		   (/rtx-canon-rtx (list-ref args 2) 'AI
				   this-expr 2 cstate env depth)))
	    (sel (if (= len 4)
		     (let ((canon (/rtx-canon-rtx (list-ref args 3) 'INT
						  this-expr 3 cstate env depth)))
		       (car canon)) ;; discard env
		     #f)))
	(if sel
	    (list (car args) expr-mode-name addr sel)
	    (list (car args) expr-mode-name addr)))))
)

(define (/rtx-canon-rtx-const rtx-obj requested-mode-name
			      func args parent-expr parent-op-num
			      cstate env depth)
  (if (!= (length args) 3)
      (/rtx-canon-error cstate "wrong number of operands to const, expecting 3"
			(cons func args) parent-expr #f))

  ;; ??? floating point support is wip
  ;; NOTE: (integer? 1.0) == #t, but (inexact? 1.0) ==> #t too.

  (let ((expr-mode-name1 (if (and (eq? requested-mode-name 'DFLT)
				  (eq? (cadr args) 'DFLT))
			     'INT
			     (cadr args)))
	(value (caddr args))
	(this-expr (cons func args)))

    (let ((expr-mode-name (/rtx-pick-mode cstate requested-mode-name
					  expr-mode-name1)))

      (if (not expr-mode-name)
	  (/rtx-canon-error cstate
			    (string-append "requested mode "
					   (symbol->string requested-mode-name)
					   " is incompatible with expression mode "
					   (symbol->string expr-mode-name1))
			    this-expr parent-expr #f))

      (let ((expr-mode (mode:lookup expr-mode-name)))

	(cond ((integer? value)
	       (if (not (memq (mode:class expr-mode) '(INT UINT FLOAT)))
		   (/rtx-canon-error cstate "integer value incompatible with mode"
				     value this-expr 2)))
	      ((inexact? value)
	       (if (not (memq (mode:class expr-mode) '(FLOAT)))
		   (/rtx-canon-error cstate "floating point value incompatible with mode"
				     value this-expr 2)))
	      (else
	       (/rtx-canon-error cstate
				 (string-append "expecting a"
						(if (eq? (mode:class expr-mode) 'FLOAT)
						    " floating point"
						    "n integer")
						" constant")
				 value this-expr 2)))

	(list (car args) expr-mode-name value))))
)

;; Table of operand canonicalizers.
;; The main one is /rtx-traverse-operands, but a few rtx functions are simple
;; and special-purpose enough that it's simpler to have specific traversers.

(define /rtx-operand-canoners #f)

;; Return list of rtx functions that have special purpose canoners.

(define (/rtx-special-expr-canoners)
  (list
   (cons 'enum /rtx-canon-rtx-enum)
   (cons 'ifield /rtx-canon-rtx-ifield)
   (cons 'operand /rtx-canon-rtx-operand)
   ;;(cons 'name /rtx-canon-rtx-name) ;; ??? needed?
   (cons 'xop /rtx-canon-rtx-xop) ;; yes, it can appear
   (cons 'local /rtx-canon-rtx-local)
   (cons 'ref /rtx-canon-rtx-ref)
   ;;(cons 'index-of /rtx-canon-rtx-index-of) ;; ??? needed?
   (cons 'reg /rtx-canon-rtx-reg)
   (cons 'raw-reg /rtx-canon-rtx-reg)
   (cons 'mem /rtx-canon-rtx-mem)
   (cons 'const /rtx-canon-rtx-const)
   )
)

;; Subroutine of rtx-munge-mode&options.
;; Return boolean indicating if X is an rtx option.

(define (/rtx-option? x)
  (keyword? x)
)

;; Subroutine of rtx-munge-mode&options.
;; Return boolean indicating if X is an rtx option list.

(define (/rtx-option-list? x)
  (or (null? x)
      (and (pair? x)
	   (/rtx-option? (car x))))
)

;; Subroutine of /rtx-canon-expr to fill in the options and mode if absent.
;; The result is the canonical form of ARGS.
;;
;; "munge" is an awkward name to use here, but I like it for now because
;; it's easy to grep for.
;; An empty option list requires a mode to be present so that the empty
;; list in `(sequence () foo bar)' is unambiguously recognized as the locals
;; list.  Icky, sure, but less icky than the alternatives thus far.

(define (rtx-munge-mode&options rtx-obj requested-mode-name func args)
  (let ((orig-args args)
	(options #f)
	(mode-name #f)
	;; The mode in a `set' is the mode of the destination,
	;; whereas the mode of the result is VOID.
	;; The mode in a compare (e.g. `eq') is the mode of the operands,
	;; but the mode of the result is BI.
	(requested-mode-name (if (rtx-result-mode rtx-obj)
				 'DFLT ;; mode of args doesn't come from containing expr
				 'DFLT))) ;; FIXME: requested-mode-name)))

    ;; Pick off the option list if present.
    (if (and (pair? args)
	     (/rtx-option-list? (car args))
	     ;; Handle `(sequence () foo bar)'.  If empty list isn't followed
	     ;; by a mode, it is not an option list.
	     (or (not (null? (car args)))
		 (and (pair? (cdr args))
		      (mode-name? (cadr args)))))
	(begin
	  (set! options (car args))
	  (set! args (cdr args))))

    ;; Pick off the mode if present.
    (if (and (pair? args)
	     (mode-name? (car args)))
	(begin
	  (set! mode-name (car args))
	  (set! args (cdr args))))

    ;; Now put option list and mode back.
    ;; But don't do unnecessary consing.
    (if options
	(if (and mode-name (not (eq? mode-name 'DFLT)))
	    orig-args ;; can return ARGS unchanged
	    (cons options (cons requested-mode-name args)))
	(if (and mode-name (not (eq? mode-name 'DFLT)))
	    (cons nil orig-args) ;; just need to insert options
	    (cons nil (cons requested-mode-name args)))))
)

;; Subroutine of /rtx-canon to simplify it.

(define (/rtx-canon-expr rtx-obj requested-mode-name
			 func args parent-expr op-num cstate env depth)
  (let ((args2 (rtx-munge-mode&options rtx-obj requested-mode-name func args)))

    (if /rtx-canon-debug?
	(begin
	  (display (spaces (* 4 depth)))
	  (display "Traversing operands of: ")
	  (display (rtx-dump (cons func args)))
	  (newline)
	  (display (spaces (* 4 depth)))
	  (display "Requested mode: ")
	  (display requested-mode-name)
	  (newline)
	  (display (spaces (* 4 depth)))
	  (rtx-env-stack-dump env)
	  (force-output)))

    (let* ((canoner (vector-ref /rtx-operand-canoners (rtx-num rtx-obj)))
	   (operands (canoner rtx-obj requested-mode-name
			      func args2 parent-expr op-num
			      cstate env (+ depth 1))))
      (cons func operands)))
)

;; Convert rtl expression EXPR from source form to canonical form.
;; The expression is validated and rtx macros are expanded as well.
;; Plus DFLT mode is converted to a useful mode.
;; The result is EXPR in canonical form.
;;
;; CSTATE is a <cstate> object or #f if there is none.
;; It is used in error messages.

(define (/rtx-canon expr expected mode parent-expr op-num cstate env depth)
  (if /rtx-canon-debug?
      (begin
	(display (spaces (* 4 depth)))
	(display "Canonicalizing (")
	(display mode)
	(display "): ")
	(display (rtx-dump expr))
	(newline)
	(display (spaces (* 4 depth)))
	(rtx-env-stack-dump env)
	(force-output)
	))

  (let ((result
	 (if (pair? expr) ;; pair? -> cheap non-null-list?

	     (let ((rtx-name (car expr)))
	       (if (not (symbol? rtx-name))
		   (/rtx-canon-error cstate "invalid rtx function name"
				     expr parent-expr op-num))
	       (let ((rtx-obj (rtx-lookup rtx-name)))
		 (if rtx-obj
		     (let ((canon-expr
			    (/rtx-canon-expr rtx-obj mode rtx-name (cdr expr)
					     parent-expr op-num cstate env depth)))
		       (if (eq? mode 'VOID)
			   (let ((expr-mode (or (rtx-result-mode rtx-obj)
						(rtx-mode canon-expr))))
			     (if (not (eq? expr-mode 'VOID))
				 (/rtx-canon-error cstate "non-VOID-mode expression"
						   expr parent-expr op-num))))
		       canon-expr)
		     (let ((rtx-obj (/rtx-macro-lookup rtx-name)))
		       (if rtx-obj
			   (/rtx-canon (/rtx-macro-expand expr rtx-evaluator)
				       expected mode parent-expr op-num cstate env (+ depth 1))
			   (/rtx-canon-error cstate "unknown rtx function"
					     expr parent-expr op-num))))))

	     ;; EXPR is not a list.
	     ;; See if it's an operand shortcut.
	     (if (memq expected '(RTX SETRTX))

		 (begin
		   (if (eq? mode 'VOID)
		       (/rtx-canon-error cstate "non-VOID-mode expression"
					 expr parent-expr op-num))
		   (cond ((symbol? expr)
			  (cond ((current-op-lookup expr (/cstate-isas cstate))
				 => (lambda (op)
				      ;; NOTE: We can't simply call
				      ;; op:mode-name here, we need the real
				      ;; mode, not (potentially) DFLT.
				      ;; See /rtx-pick-op-mode.
				      (rtx-make-operand (/rtx-pick-op-mode cstate mode 'DFLT op parent-expr)
							expr)))
				((rtx-temp-lookup env expr)
				 => (lambda (tmp)
				      (rtx-make-local (obj:name (rtx-temp-mode tmp)) expr)))
				((current-ifld-lookup expr)
				 => (lambda (f)
				      (rtx-make-ifield (obj:name (ifld-mode f)) expr)))
				((enum-lookup-val expr)
				 ;; ??? If enums could have modes other than INT,
				 ;; we'd want to propagate that mode here.
				 (rtx-make-enum 'INT expr))
				(else
				 (/rtx-canon-error cstate "unknown operand"
						   expr parent-expr op-num))))
			 ((integer? expr)
			  (rtx-make-const 'INT expr))
			 (else
			  (/rtx-canon-error cstate "unexpected operand"
					    expr parent-expr op-num))))

		 ;; Not expecting RTX or SETRTX.
		 (/rtx-canon-error cstate "unexpected operand"
				   expr parent-expr op-num)))))

    (if /rtx-canon-debug?
	(begin
	  (display (spaces (* 4 depth)))
	  (display "Result: ")
	  (display (rtx-dump result))
	  (newline)
	  (force-output)
	  ))

    result)
)

;; Public entry point.
;; Convert rtl expression EXPR from source form to canonical form.
;; The expression is validated and rtx macros are expanded as well.
;; Plus operand shortcuts are expanded:
;;   - numbers -> (const number)
;;   - operand-name -> (operand operand-name)
;;   - ifield-name -> (ifield ifield-name)
;; Plus an absent option list is replaced with ().
;; Plus DFLT mode is converted to a useful mode.
;; Plus the specified isa-name-list is recorded in the RTL.
;;
;; The result is EXPR in canonical form.
;;
;; CONTEXT is a <context> object or #f if there is none.
;; It is used in error messages.
;;
;; ISA-NAME-LIST is a list of ISAs in which to evaluate the expression,
;; e.g. to do operand lookups.
;; The ISAs must be compatible, e.g. operand lookups must be unambiguous.
;;
;; MODE-NAME is the requested mode of the result, or DFLT.
;;
;; EXTRA-VARS-ALIST is an association list of extra (symbol <mode> value)
;; elements to be used during value lookup.
;; VALUE can be #f which means the value is assumed to be known, but is
;; currently unrepresentable.  This is used, for example, when representing
;; ifield setters: we don't know the new value, but it will be known when the
;; rtx is evaluated (??? Sigh, this is a bit of a cheat, closures have no
;; such thing, but it's useful here because we don't necessarily know what
;; the value will be in the application side of things).

(define (rtx-canonicalize context mode-name isa-name-list extra-vars-alist expr)
  (let ((result
	 (/rtx-canon expr 'RTX mode-name #f 0
		     (/make-cstate context isa-name-list expr)
		     (rtx-env-init-stack1 extra-vars-alist) 0)))
    (rtx-verify-no-dflt-modes context result)
    (rtx-make 'closure mode-name isa-name-list
	      (rtx-var-alist-to-closure-env-stack extra-vars-alist)
	      result))
)

;; RTL expression traversal support.
;; This is for analyzing the semantics in some way.
;; The rtl must already be in canonical form.

;; Set to #t to debug rtx traversal.

(define /rtx-traverse-debug? #f)

; Container to record the current state of traversal.
; This is initialized before traversal, and modified (in a copy) as the
; traversal state changes.
; This doesn't record all traversal state, just the more static elements.
; There's no point in recording things like the parent expression and operand
; position as they change for every sub-traversal.
; The main raison d'etre for this class is so we can add more state without
; having to modify all the traversal handlers.
; ??? At present it's not a proper "class" as there's no real need.
;
; CONTEXT is a <context> object or #f if there is none.
; It is used for error messages.
;
; EXPR-FN is a dual-purpose beast.  The first purpose is to just process
; the current expression and return the result.  The second purpose is to
; lookup the function which will then process the expression.
; It is applied recursively to the expression and each sub-expression.
; It must be defined as
; (lambda (rtx-obj expr parent-expr op-pos tstate appstuff) ...).
; If the result of EXPR-FN is a lambda, it is applied to
; (cons TSTATE EXPR), TSTATE is prepended to the arguments.
; For syntax expressions if the result of EXPR-FN is #f, the operands are
; processed using the builtin traverser.
; So to repeat: EXPR-FN can process the expression, and if its result is a
; lambda then it also processes the expression.  The arguments to EXPR-FN
; are (rtx-obj expr parent-expr op-pos tstate appstuff).  The format
; of the result of EXPR-FN are (cons TSTATE EXPR).
; The reason for the duality is that when trying to understand EXPR (e.g. when
; computing the insn format) EXPR-FN processes the expression itself, and
; when evaluating EXPR it's the result of EXPR-FN that computes the value.
;
; ISAS is a list of ISA name(s) in which to evaluate the expression.
;
; ENV is the current environment.  This is a stack of sequence locals.
;
; COND? is a boolean indicating if the current expression is on a conditional
; execution path.  This is for optimization purposes only and it is always ok
; to pass #t, except for the top-level caller which must pass #f (since the top
; level expression obviously isn't subject to any condition).
; It is used, for example, to speed up the simulator: there's no need to keep
; track of whether an operand has been assigned to (or potentially read from)
; if it's known it's always assigned to.
;
; OWNER is the owner of the expression or #f if there is none.
; Typically it is an <insn> object.
;
; KNOWN is an alist of known values.  This is used by rtx-simplify.
; Each element is (name . value) where
; NAME is a scalar ifield name (in the future it might be an operand name or
; sequence local name), and
; VALUE is a const rtx, (const () mode value),
; or a number-list rtx, (number-list () mode value1 [value2 ...]).
; A "scalar ifield" is a simple ifield (not a multi or derived ifield),
; or a multi-ifield consisting of only simple ifields.
;
; DEPTH is the current traversal depth.

(define (tstate-make context owner expr-fn isas env cond? known depth)
  (vector context owner expr-fn isas env cond? known depth)
)

(define (tstate-context state)               (vector-ref state 0))
(define (tstate-set-context! state newval)   (vector-set! state 0 newval))
(define (tstate-owner state)                 (vector-ref state 1))
(define (tstate-set-owner! state newval)     (vector-set! state 1 newval))
(define (tstate-expr-fn state)               (vector-ref state 2))
(define (tstate-set-expr-fn! state newval)   (vector-set! state 2 newval))
(define (tstate-isas state)                  (vector-ref state 3))
(define (tstate-set-isas! state newval)      (vector-set! state 3 newval))
(define (tstate-env-stack state)             (vector-ref state 4))
(define (tstate-set-env-stack! state newval) (vector-set! state 4 newval))
(define (tstate-cond? state)                 (vector-ref state 5))
(define (tstate-set-cond?! state newval)     (vector-set! state 5 newval))
(define (tstate-known state)                 (vector-ref state 6))
(define (tstate-set-known! state newval)     (vector-set! state 6 newval))
(define (tstate-depth state)                 (vector-ref state 7))
(define (tstate-set-depth! state newval)     (vector-set! state 7 newval))

; Create a copy of STATE.

(define (tstate-copy state)
  ; A fast vector-copy would be nice, but this is simple and portable.
  (list->vector (vector->list state))
)

;; Create a copy of STATE with environment stack ENV-STACK added,
;; and the ISA(s) set to ISA-NAME-LIST.

(define (tstate-make-closure state isa-name-list env-stack)
  (let ((result (tstate-copy state)))
    (tstate-set-isas! result isa-name-list)
    (tstate-set-env-stack! result (append env-stack (tstate-env-stack result)))
    result)
)

; Create a copy of STATE with environment ENV pushed onto the existing
; environment list.
; There's no routine to pop the environment list as there's no current
; need for it: we make a copy of the state when we push.

(define (tstate-push-env state env)
  (let ((result (tstate-copy state)))
    (tstate-set-env-stack! result (cons env (tstate-env-stack result)))
    result)
)

; Create a copy of STATE with a new COND? value.

(define (tstate-new-cond? state cond?)
  (let ((result (tstate-copy state)))
    (tstate-set-cond?! result cond?)
    result)
)

; Lookup NAME in the known value table.
; Returns the value or #f if not found.
; The value is either a const rtx or a number-list rtx.

(define (tstate-known-lookup tstate name)
  (let ((known (tstate-known tstate)))
    (assq-ref known name))
)

; Increment the recorded traversal depth of TSTATE.

(define (tstate-incr-depth! tstate)
  (tstate-set-depth! tstate (1+ (tstate-depth tstate)))
)

; Decrement the recorded traversal depth of TSTATE.

(define (tstate-decr-depth! tstate)
  (tstate-set-depth! tstate (1- (tstate-depth tstate)))
)

; Issue an error given a tstate.

(define (tstate-error tstate errmsg . expr)
  (apply context-owner-error
	 (cons (tstate-context tstate)
	       (cons (tstate-owner tstate)
		     (cons "During rtx traversal"
			   (cons errmsg expr)))))
)

; Traversal support.

; Return a boolean indicating if X is a mode.

(define (/rtx-any-mode? x)
  (->bool (mode:lookup x))
)

; Return a boolean indicating if X is a symbol or rtx.

(define (/rtx-symornum? x)
  (or (symbol? x) (number? x))
)

; Traverse a list of rtx's.

(define (/rtx-traverse-rtx-list rtx-list expr op-num tstate appstuff)
  (map (lambda (rtx)
	 ; ??? Shouldn't OP-NUM change for each element?
	 (/rtx-traverse rtx 'RTX expr op-num tstate appstuff))
       rtx-list)
)

; Cover-fn to tstate-error for signalling an error during rtx traversal
; of operand OP-NUM.
; RTL-EXPR must be an rtl expression.

(define (/rtx-traverse-error tstate errmsg rtl-expr op-num)
  (tstate-error tstate
		(string-append errmsg ", operand #" (number->string op-num))
		(rtx-dump rtl-expr))
)

; Rtx traversers.
;
; The result is either a pair of the parsed VAL and new TSTATE,
; or #f meaning there is no change (saves lots of unnecessarying cons'ing).

(define (/rtx-traverse-normal-operand val expr op-num tstate appstuff)
  #f
)

(define (/rtx-traverse-rtx val expr op-num tstate appstuff)
  (cons (/rtx-traverse val 'RTX expr op-num tstate appstuff)
	tstate)
)

(define (/rtx-traverse-setrtx val expr op-num tstate appstuff)
  (cons (/rtx-traverse val 'SETRTX expr op-num tstate appstuff)
	tstate)
)

; This is the test of an `if'.

(define (/rtx-traverse-testrtx val expr op-num tstate appstuff)
  (cons (/rtx-traverse val 'RTX expr op-num tstate appstuff)
	(tstate-new-cond?
	 tstate
	 (not (rtx-compile-time-constant? val))))
)

(define (/rtx-traverse-condrtx val expr op-num tstate appstuff)
  (if (eq? (car val) 'else)
      (cons (cons 'else
		  (/rtx-traverse-rtx-list
		   (cdr val) expr op-num
		   (tstate-new-cond? tstate #t)
		   appstuff))
	    (tstate-new-cond? tstate #t))
      (cons (cons
	     ; ??? Entries after the first are conditional.
	     (/rtx-traverse (car val) 'RTX expr op-num tstate appstuff)
	     (/rtx-traverse-rtx-list
	      (cdr val) expr op-num
	      (tstate-new-cond? tstate #t)
	      appstuff))
	    (tstate-new-cond? tstate #t)))
)

(define (/rtx-traverse-casertx val expr op-num tstate appstuff)
  (cons (cons (car val)
	      (/rtx-traverse-rtx-list
	       (cdr val) expr op-num
	       (tstate-new-cond? tstate #t)
	       appstuff))
	(tstate-new-cond? tstate #t))
)

(define (/rtx-traverse-locals val expr op-num tstate appstuff)
  (let ((env (rtx-env-make-locals val)))
    (cons val (tstate-push-env tstate env)))
)

(define (/rtx-traverse-iteration val expr op-num tstate appstuff)
  (let ((env (rtx-env-make-iteration-locals val)))
    (cons val (tstate-push-env tstate env)))
)

(define (/rtx-traverse-attrs val expr op-num tstate appstuff)
;  (cons val ; (atlist-source-form (atlist-parse (make-prefix-context "with-attr") val ""))
;	tstate)
  #f
)

; Table of rtx traversers.
; This is a vector of size rtx-max-num.
; Each entry is a list of (arg-type-name . traverser) elements
; for rtx-arg-types.
; FIXME: Initialized in rtl.scm (i.e. outside this file).

(define /rtx-traverser-table #f)

; Return a hash table of standard operand traversers.
; The result of each traverser is a pair of the compiled form of `val' and
; a possibly new traversal state or #f if there is no change.

(define (/rtx-make-traverser-table)
  (let ((hash-tab (make-hash-table 31))
	(traversers
	 (list
	  (cons 'OPTIONS /rtx-traverse-normal-operand)
	  (cons 'ANYINTMODE /rtx-traverse-normal-operand)
	  (cons 'ANYFLOATMODE /rtx-traverse-normal-operand)
	  (cons 'ANYNUMMODE /rtx-traverse-normal-operand)
	  (cons 'ANYEXPRMODE /rtx-traverse-normal-operand)
	  (cons 'ANYCEXPRMODE /rtx-traverse-normal-operand)
	  (cons 'EXPLNUMMODE /rtx-traverse-normal-operand)
	  (cons 'VOIDORNUMMODE /rtx-traverse-normal-operand)
	  (cons 'VOIDMODE /rtx-traverse-normal-operand)
	  (cons 'BIMODE /rtx-traverse-normal-operand)
	  (cons 'INTMODE /rtx-traverse-normal-operand)
	  (cons 'SYMMODE /rtx-traverse-normal-operand)
	  (cons 'INSNMODE /rtx-traverse-normal-operand)
	  (cons 'MACHMODE /rtx-traverse-normal-operand)
	  (cons 'RTX /rtx-traverse-rtx)
	  (cons 'SETRTX /rtx-traverse-setrtx)
	  (cons 'TESTRTX /rtx-traverse-testrtx)
	  (cons 'CONDRTX /rtx-traverse-condrtx)
	  (cons 'CASERTX /rtx-traverse-casertx)
	  (cons 'LOCALS /rtx-traverse-locals)
	  (cons 'ITERATION /rtx-traverse-iteration)
	  ;; NOTE: Closure isas and env are handled in /rtx-traverse.
	  (cons 'SYMBOLLIST /rtx-traverse-normal-operand)
	  (cons 'ENVSTACK /rtx-traverse-normal-operand)
	  (cons 'ATTRS /rtx-traverse-attrs)
	  (cons 'SYMBOL /rtx-traverse-normal-operand)
	  (cons 'STRING /rtx-traverse-normal-operand)
	  (cons 'NUMBER /rtx-traverse-normal-operand)
	  (cons 'SYMORNUM /rtx-traverse-normal-operand)
	  (cons 'OBJECT /rtx-traverse-normal-operand)
	  )))

    (for-each (lambda (traverser)
		(hashq-set! hash-tab (car traverser) (cdr traverser)))
	      traversers)

    hash-tab)
)

; Traverse the operands of EXPR, a canonicalized RTL expression.
; Here "canonicalized" means that EXPR has been run through rtx-canonicalize.
; Note that this means that, yes, the options and mode are "traversed" too.

(define (/rtx-traverse-operands rtx-obj expr tstate appstuff)
  (if /rtx-traverse-debug?
      (begin
	(display (spaces (* 4 (tstate-depth tstate))))
	(display "Traversing operands of: ")
	(display (rtx-dump expr))
	(newline)
	(rtx-env-stack-dump (tstate-env-stack tstate))
	(force-output)))

  (let loop ((operands (cdr expr))
	     (op-num 0)
	     (arg-types (vector-ref /rtx-traverser-table (rtx-num rtx-obj)))
	     (arg-modes (rtx-arg-modes rtx-obj))
	     (result nil))

    (let ((varargs? (and (pair? arg-types) (symbol? (car arg-types)))))

      (if /rtx-traverse-debug?
	  (begin
	    (display (spaces (* 4 (tstate-depth tstate))))
	    (if (null? operands)
		(display "end of operands")
		(begin
		  (display "op-num ") (display op-num) (display ": ")
		  (display (rtx-dump (car operands)))
		  (display ", ")
		  (display (if varargs? (car arg-types) (caar arg-types)))
		  (display ", ")
		  (display (if varargs? arg-modes (car arg-modes)))
		  ))
	    (newline)
	    (force-output)))

      (cond ((null? operands)
	     ;; Out of operands, check if we have the expected number.
	     (if (or (null? arg-types)
		     varargs?)
		 (reverse! result)
		 (tstate-error tstate "missing operands" (rtx-dump expr))))

	    ((null? arg-types)
	     (tstate-error tstate "too many operands" (rtx-dump expr)))

	    (else
	     (let* ((val (car operands))
		    (type (if varargs? arg-types (car arg-types))))

	       ;; Look up the traverser for this kind of operand and perform it.
	       ;; FIXME: This would benefit from returning multiple values.
	       (let ((traverser (cdr type)))
		 (let ((traversed-val (traverser val expr op-num tstate appstuff)))
		   (if traversed-val
		       (begin
			 (set! val (car traversed-val))
			 (set! tstate (cdr traversed-val))))))

	       ;; Done with this operand, proceed to the next.
	       (loop (cdr operands)
		     (+ op-num 1)
		     (if varargs? arg-types (cdr arg-types))
		     (if varargs? arg-modes (cdr arg-modes))
		     (cons val result)))))))
)

; Publically accessible version of /rtx-traverse-operands as EXPR-FN may
; need to call it.

(define rtx-traverse-operands /rtx-traverse-operands)

; Subroutine of /rtx-traverse to traverse an expression.
;
; RTX-OBJ is the <rtx-func> object of the (outer) expression being traversed.
;
; EXPR is the expression to be traversed.
; It must be fully canonical.
;
; PARENT-EXPR is the expression EXPR is contained in.  The top-level
; caller must pass #f for it.
;
; OP-POS is the position EXPR appears in PARENT-EXPR.  The
; top-level caller must pass 0 for it.
;
; TSTATE is the current traversal state.
;
; APPSTUFF is for application specific use.
;
; For syntax expressions arguments are not pre-evaluated before calling the
; user's expression handler.  Otherwise they are.
;
; If (tstate-expr-fn TSTATE) wants to just scan the operands, rather than
; evaluating them, one thing it can do is call back to rtx-traverse-operands.
; If (tstate-expr-fn TSTATE) returns #f, traverse the operands normally and
; return (rtx's-name ([options]) mode traversed-operand1 ...),
; i.e., the canonicalized form.
; This is for semantic-compile's sake and all traversal handlers are
; required to do this if the expr-fn returns #f.

(define (/rtx-traverse-expr rtx-obj expr parent-expr op-pos tstate appstuff)
  (let ((fn ((tstate-expr-fn tstate)
	     rtx-obj expr parent-expr op-pos tstate appstuff)))
    (if fn
	(if (procedure? fn)
	    ; Don't traverse operands for syntax expressions.
	    (if (eq? (rtx-style rtx-obj) 'SYNTAX)
		(apply fn (cons tstate cdr expr))
		(let ((operands (/rtx-traverse-operands rtx-obj expr tstate appstuff)))
		  (apply fn (cons tstate operands))))
	    fn)
	(let ((operands (/rtx-traverse-operands rtx-obj expr tstate appstuff)))
	  (cons (car expr) operands))))
)

; Main entry point for expression traversal.
; (Actually rtx-traverse is, but it's just a cover function for this.)
;
; The result is the result of the lambda (tstate-expr-fn TSTATE) looks up
; in the case of expressions, or an operand object (usually <operand>)
; in the case of operands.
;
; EXPR is the expression to be traversed.
; It must be fully canonical.
;
; EXPECTED is one of `-rtx-valid-types' and indicates the expected rtx type
; or #f if it doesn't matter.
;
; PARENT-EXPR is the expression EXPR is contained in.  The top-level
; caller must pass #f for it.
;
; OP-POS is the position EXPR appears in PARENT-EXPR.  The
; top-level caller must pass 0 for it.
;
; TSTATE is the current traversal state.
;
; APPSTUFF is for application specific use.

(define (/rtx-traverse expr expected parent-expr op-pos tstate appstuff)
  (if /rtx-traverse-debug?
      (begin
	(display (spaces (* 4 (tstate-depth tstate))))
	(display "Traversing expr: ")
	(display expr)
	(newline)
	(display (spaces (* 4 (tstate-depth tstate))))
	(display "-expected:       ")
	(display expected)
	(newline)
	(display (spaces (* 4 (tstate-depth tstate))))
	(display "-conditional:    ")
	(display (tstate-cond? tstate))
	(newline)
	(force-output)
	))

  ;; FIXME: error checking here should be deleteable.

  (if (pair? expr) ; pair? -> cheap non-null-list?

      (let* ((rtx-name (car expr))
	     (rtx-obj (rtx-lookup rtx-name))
	     ;; If this is a closure, update tstate.
	     ;; ??? This is a bit of a wart.  All other rtxes handle their
	     ;; special args/needs via rtx-arg-types.  Left as is to simmer.
	     (tstate (if (eq? rtx-name 'closure)
			 (tstate-make-closure tstate
					      (rtx-closure-isas expr)
					      (rtx-make-env-stack (rtx-closure-env-stack expr)))
			 tstate)))
	(tstate-incr-depth! tstate)
	(let ((result
	       (if rtx-obj
		   (/rtx-traverse-expr rtx-obj expr parent-expr op-pos tstate appstuff)
		   (let ((rtx-obj (/rtx-macro-lookup rtx-name)))
		     (if rtx-obj
			 (/rtx-traverse (/rtx-macro-expand expr rtx-evaluator)
					expected parent-expr op-pos tstate appstuff)
			 (tstate-error tstate "unknown rtx function" expr))))))
	  (tstate-decr-depth! tstate)
	  result))

      ; EXPR is not a list.
      ; See if it's an operand shortcut.
      ; FIXME: Can we get here any more? [now that EXPR is already canonical]
      (if (memq expected '(RTX SETRTX))

	  (cond ((symbol? expr)
		 (cond ((current-op-lookup expr (tstate-isas tstate))
			=> (lambda (op)
			     (/rtx-traverse
			      ;; NOTE: Can't call op:mode-name here, we need
			      ;; the real mode, not (potentially) DFLT.
			      (rtx-make-operand (obj:name (op:mode op)) expr)
			      expected parent-expr op-pos tstate appstuff)))
		       ((rtx-temp-lookup (tstate-env-stack tstate) expr)
			=> (lambda (tmp)
			     (/rtx-traverse
			      (rtx-make-local (rtx-temp-mode tmp) expr)
			      expected parent-expr op-pos tstate appstuff)))
		       ((current-ifld-lookup expr)
			=> (lambda (f)
			     (/rtx-traverse
			      (rtx-make-ifield (obj:name (ifld-mode f)) expr)
			      expected parent-expr op-pos tstate appstuff)))
		       ((enum-lookup-val expr)
			;; ??? If enums could have modes other than INT,
			;; we'd want to propagate that mode here.
			(/rtx-traverse
			 (rtx-make-enum 'INT expr)
			 expected parent-expr op-pos tstate appstuff))
		       (else
			(tstate-error tstate "unknown operand" expr))))
		((integer? expr)
		 (/rtx-traverse (rtx-make-const 'INT expr)
				expected parent-expr op-pos tstate appstuff))
		(else
		 (tstate-error tstate "unexpected operand" expr)))

	  ; Not expecting RTX or SETRTX.
	  (tstate-error tstate "unexpected operand" expr)))
)

; User visible procedures to traverse an rtl expression.
; EXPR must be fully canonical.
; These calls /rtx-traverse to do most of the work.
; See tstate-make for explanations of OWNER, EXPR-FN.
; CONTEXT is a <context> object or #f if there is none.
; LOCALS is a list of (mode . name) elements (the locals arg to `sequence').
; APPSTUFF is for application specific use.

(define (rtx-traverse context owner expr expr-fn appstuff)
  (/rtx-traverse expr #f #f 0
		 (tstate-make context owner expr-fn
			      #f ;; ok since EXPR is fully canonical
			      (rtx-env-empty-stack)
			      #f nil 0)
		 appstuff)
)

(define (rtx-traverse-with-locals context owner expr expr-fn locals appstuff)
  (/rtx-traverse expr #f #f 0
		 (tstate-make context owner expr-fn
			      #f ;; ok since EXPR is fully canonical
			      (rtx-env-push (rtx-env-empty-stack)
					    (rtx-env-make-locals locals))
			      #f nil 0)
		 appstuff)
)

; Traverser debugger.
; This just traverses EXPR printing everything it sees.

(define (rtx-traverse-debug expr)
  (rtx-traverse
   #f #f expr
   (lambda (rtx-obj expr parent-expr op-pos tstate appstuff)
     (display "-expr:    ")
     (display (string-append "rtx=" (obj:str-name rtx-obj)))
     (display " expr=")
     (display expr)
     (display " parent=")
     (display parent-expr)
     (display " op-pos=")
     (display op-pos)
     (display " cond?=")
     (display (tstate-cond? tstate))
     (newline)
     #f)
   #f
   )
)

; RTL evaluation state.
; Applications may subclass <eval-state> if they need to add things.
;
; This is initialized before evaluation, and modified (in a copy) as the
; evaluation state changes.
; This doesn't record all evaluation state, just the less dynamic elements.
; There's no point in recording things like the parent expression and operand
; position as they change for every sub-eval.
; The main raison d'etre for this class is so we can add more state without
; having to modify all the eval handlers.

(define <eval-state>
  (class-make '<eval-state> nil
	      '(
		; <context> object or #f if there is none
		(context . #f)

		; Current object rtl is being evaluated for.
		; We need to be able to access the current instruction while
		; generating semantic code.  However, the semantic description
		; doesn't specify it as an argument to anything (and we don't
		; want it to).  So we record the value here.
		(owner . #f)

		;; The outer expr being evaluated, for error messages.
		;; #f if there is none.
		(outer-expr . #f)

		; EXPR-FN is a dual-purpose beast.  The first purpose is to
		; just process the current expression and return the result.
		; The second purpose is to lookup the function which will then
		; process the expression.  It is applied recursively to the
		; expression and each sub-expression.  It must be defined as
		; (lambda (rtx-obj expr mode estate) ...).
		; If the result of EXPR-FN is a lambda, it is applied to
		; (cons ESTATE (cdr EXPR)).  ESTATE is prepended to the
		; arguments.
		; For syntax expressions if the result of EXPR-FN is #f,
		; the operands are processed using the builtin evaluator.
		; FIXME: This special handling of syntax expressions is
		; not currently done.
		; So to repeat: EXPR-FN can process the expression, and if its
		; result is a lambda then it also processes the expression.
		; The arguments to EXPR-FN are
		; (rtx-obj expr mode estate).
		; The arguments to the result of EXPR-FN are
		; (cons ESTATE (cdr EXPR)).
		; The reason for the duality is mostly history.
		; In time things should be simplified.
		(expr-fn . #f)

		; List of ISA name(s) in which to evaluate the expression.
		; This is used for example during operand lookups.
		; All specified ISAs must be compatible,
		; e.g. operand lookups must be unambiguous.
		; A value of #f means "all ISAs".
		(isas . #f)

		; Current environment.  This is a stack of sequence locals,
		; e.g. made with rtx-env-init-stack1.
		(env-stack . ())

		; Current evaluation depth.  This is used, for example, to
		; control indentation in generated output.
		(depth . 0)

		; Associative list of modifiers.
		; This is here to support things like `delay'.
		(modifiers . ())
		)
	      nil)
)

; Create an <eval-state> object using a list of keyword/value elements.
; ARGS is a list of #:keyword/value elements.
; The result is a list of the unrecognized elements.
; Subclasses should override this method and send-next it first, then
; see if they recognize anything in the result, returning what isn't
; recognized.

(method-make!
 <eval-state> 'vmake!
 (lambda (self args)
   (let loop ((args args) (unrecognized nil))
     (if (null? args)
	 (reverse! unrecognized) ; ??? Could invoke method to initialize here.
	 (begin
	   (case (car args)
	     ((#:context)
	      (elm-set! self 'context (cadr args)))
	     ((#:owner)
	      (elm-set! self 'owner (cadr args)))
	     ((#:outer-expr)
	      (elm-set! self 'outer-expr (cadr args)))
	     ((#:expr-fn)
	      (elm-set! self 'expr-fn (cadr args)))
	     ((#:env-stack)
	      (elm-set! self 'env-stack (cadr args)))
	     ((#:isas)
	      (elm-set! self 'isas (cadr args)))
	     ((#:depth)
	      (elm-set! self 'depth (cadr args)))
	     ((#:modifiers)
	      (elm-set! self 'modifiers (cadr args)))
	     (else
	      ; Build in reverse order, as we reverse it back when we're done.
	      (set! unrecognized
		    (cons (cadr args) (cons (car args) unrecognized)))))
	   (loop (cddr args) unrecognized)))))
)

; Accessors.

(define-getters <eval-state> estate
  (context owner outer-expr expr-fn isas env-stack depth modifiers)
)
(define-setters <eval-state> estate
  (isas env-stack depth modifiers)
)

; Build an estate for use in producing a value from rtl.
; CONTEXT is a <context> object or #f if there is none.
; OWNER is the owner of the expression or #f if there is none.

(define (estate-make-for-eval context owner)
  (vmake <eval-state>
	 #:context context
	 #:owner owner
	 #:expr-fn (lambda (rtx-obj expr mode estate)
		     (rtx-evaluator rtx-obj))
	 #:isas (and owner (obj-isa-list owner)))
)

; Create a copy of ESTATE.

(define (estate-copy estate)
  (object-copy estate)
)

;; Create a copy of ESTATE with environment stack ENV-STACK added,
;; and the ISA(s) set to ISA-NAME-LIST.

(define (estate-make-closure estate isa-name-list env-stack)
  (let ((result (estate-copy estate)))
    (estate-set-isas! result isa-name-list)
    (estate-set-env-stack! result (append env-stack (estate-env-stack result)))
    result)
)

; Create a copy of ESTATE with environment ENV pushed onto the existing
; environment list.
; There's no routine to pop the environment list as there's no current
; need for it: we make a copy of the state when we push.

(define (estate-push-env estate env)
  (let ((result (estate-copy estate)))
    (estate-set-env-stack! result (cons env (estate-env-stack result)))
    result)
)

; Create a copy of ESTATE with the depth incremented by one.

(define (estate-deepen estate)
  (let ((result (estate-copy estate)))
    (estate-set-depth! result (1+ (estate-depth estate)))
    result)
)

; Create a copy of ESTATE with modifiers MODS.

(define (estate-with-modifiers estate mods)
  (let ((result (estate-copy estate)))
    (estate-set-modifiers! result (append mods (estate-modifiers result)))
    result)
)

; Convert a tstate to an estate.

(define (tstate->estate t)
  (vmake <eval-state>
	 #:context (tstate-context t)
	 #:env-stack (tstate-env-stack t))
)

; Issue an error given an estate.

(define (estate-error estate errmsg . expr)
  (apply context-owner-error
	 (cons (estate-context estate)
	       (cons (estate-owner estate)
		     (cons (string-append "During rtx evalution"
					  (if (estate-outer-expr estate)
					      (string-append " of\n"
							     (rtx-pretty-strdump (estate-outer-expr estate))
							     "\n")
					      ""))
			   (cons errmsg expr)))))
)

; RTL expression evaluation.
;
; ??? These used eval2 at one point.  Not sure which is faster but I suspect
; eval2 is by far.  On the otherhand this has yet to be compiled.  And this way
; is more portable, more flexible, and works with guile 1.2 (which has
; problems with eval'ing self referential vectors, though that's one reason to
; use smobs).

; Set to #t to debug rtx evaluation.

(define /rtx-eval-debug? #f)

; RTX expression evaluator.
;
; EXPR is the expression to be eval'd.  It must be in compiled(canonical) form.
; MODE is the desired mode of EXPR, a <mode> object.
; ESTATE is the current evaluation state.

(define (rtx-eval-with-estate expr mode estate)
  (if /rtx-eval-debug?
      (begin
	(display "Evaluating expr with mode ")
	(display (if (symbol? mode) mode (obj:name mode)))
	(newline)
	(display (rtx-dump expr))
	(newline)
	(rtx-env-stack-dump (estate-env-stack estate))
	))

  (if (pair? expr) ; pair? -> cheap non-null-list?

      (let* ((rtx-obj (rtx-lookup (car expr)))
	     (fn ((estate-expr-fn estate) rtx-obj expr mode estate)))
	(if fn
	    (if (procedure? fn)
		(apply fn (cons estate (cdr expr)))
;		; Don't eval operands for syntax expressions.
;		(if (eq? (rtx-style rtx-obj) 'SYNTAX)
;		    (apply fn (cons estate (cdr expr)))
;		    (let ((operands
;			   (/rtx-eval-operands rtx-obj expr estate)))
;		      (apply fn (cons estate operands))))
		fn)
	    ; Leave expr unchanged.
	    expr))
;	    (let ((operands
;		   (/rtx-traverse-operands rtx-obj expr estate)))
;	      (cons rtx-obj operands))))

      ; EXPR is not a list
      (error "argument to rtx-eval-with-estate is not a list" expr))
)

; Evaluate rtx expression EXPR and return the computed value.
; EXPR must already be in canonical form (the result of rtx-canonicalize).
; OWNER is the owner of the value, used for attribute computation
; and to get the ISA name list.
; OWNER is #f if there isn't one.
; FIXME: context?

(define (rtx-value expr owner)
  (rtx-eval-with-estate expr DFLT (estate-make-for-eval #f owner))
)

;; Initialize the tables.

(define (rtx-init-traversal-tables!)
  (let ((compiler-hash-table (/rtx-make-canon-table))
	(traverser-hash-table (/rtx-make-traverser-table)))

    (set! /rtx-canoner-table (make-vector (rtx-max-num) #f))
    (set! /rtx-traverser-table (make-vector (rtx-max-num) #f))

    (for-each (lambda (rtx-name)
		(let ((rtx (rtx-lookup rtx-name)))
		  (if rtx
		      (let ((num (rtx-num rtx))
			    (arg-types (rtx-arg-types rtx)))
			(vector-set! /rtx-canoner-table num
				     (map1-improper
				      (lambda (arg-type)
					(cons arg-type
					      (hashq-ref compiler-hash-table arg-type)))
				      arg-types))
			(vector-set! /rtx-traverser-table num
				     (map1-improper
				      (lambda (arg-type)
					(cons arg-type
					      (hashq-ref traverser-hash-table arg-type)))
				      arg-types))))))
	      (rtx-name-list)))

  (set! /rtx-operand-canoners (make-vector (rtx-max-num) /rtx-canon-operands))
  (for-each (lambda (rtx-canoner)
	      (let ((rtx-obj (rtx-lookup (car rtx-canoner))))
		(vector-set! /rtx-operand-canoners (rtx-num rtx-obj) (cdr rtx-canoner))))
	    (/rtx-special-expr-canoners))
)
@


1.21
log
@	* rtl-traverse.scm (/rtx-canon-anycexprmode): New function.
	(/rtx-make-canon-table): Add entry for ANYCEXPRMODE.
	(/rtx-canon-operands): Print expr-mode if /rtx-canon-debug?
	Do final error check on mode assigned to expression.
	(/rtx-make-traverser-table): Add entry for ANYCEXPRMODE.
	* rtl-xform.scm (/rtx-trim-args): Handle ANYCEXPRMODE.
	* rtl.scm (/rtx-valid-mode-types): Add ANYCEXPRMODE.
	* rtx-funcs.scm (c-code, c-call, c-raw-call): Use ANYCEXPRMODE.
	(if, cond, case): Use ANYEXPRMODE.
@
text
@d2062 1
a2062 1
  (object-copy-top estate)
@


1.20
log
@	* rtl-traverse.scm (/rtx-canon): Flag an error for non-void
	expressions used in a void context.
@
text
@d2 1
a2 1
;; Copyright (C) 2000, 2001, 2009 Red Hat, Inc.
d317 10
d565 1
d625 8
d677 18
a694 10
				   (result-mode (or (rtx-result-mode expr-to-match-obj)
						    (let ((expr-mode (rtx-mode expr-to-match)))
						      (if (eq? expr-mode 'DFLT)
							  (if (eq? requested-mode-name 'DFLT)
							      (/rtx-canon-error cstate
										"unable to determine mode of expression from arguments, please specify a mode"
										this-expr parent-expr #f)
							      requested-mode-name)
							  expr-mode)))))
			      (vector-set! operands 1 result-mode)))))
d1617 1
@


1.19
log
@	* utils.scm (reduce): Delete.

	* rtl-traverse.scm (/rtx-canon-rtx-enum): Tweak local name.

	* enum.scm (gen-enum-sym): Make consistent with gen-enum-decl
	regarding PREFIX attribute handling.

	* operand.scm (<hw-index>): Add enum to possible types, all uses
	updated.
	(hw-index-constant?, hw-index-constant-value): New functions.
	(make-enum-hw-index, hw-index-enum-name, hw-index-enum-value,
	hw-index-enum-obj): New functions.
	(/operand-parse): Handle enum indices.
	* intrinsics.scm (md-operand:fixed-register): Use hw-index-constant?,
	hw-index-constant-value.
	* rtl.scm (rtx-constant-value): Fix handling of enums.
	* rtx-funcs.scm (enum): Ditto.
	* sid.scm (<hardware-base> cxmake-get): Only ifield indices are
	currently supported here.
@
text
@d1201 10
a1210 2
		     (/rtx-canon-expr rtx-obj mode rtx-name (cdr expr)
				      parent-expr op-num cstate env depth)
d1222 31
a1252 27
		 (cond ((symbol? expr)
			(cond ((current-op-lookup expr (/cstate-isas cstate))
			       => (lambda (op)
				    ;; NOTE: We can't simply call
				    ;; op:mode-name here, we need the real
				    ;; mode, not (potentially) DFLT.
				    ;; See /rtx-pick-op-mode.
				    (rtx-make-operand (/rtx-pick-op-mode cstate mode 'DFLT op parent-expr)
						      expr)))
			      ((rtx-temp-lookup env expr)
			       => (lambda (tmp)
				    (rtx-make-local (obj:name (rtx-temp-mode tmp)) expr)))
			      ((current-ifld-lookup expr)
			       => (lambda (f)
				    (rtx-make-ifield (obj:name (ifld-mode f)) expr)))
			      ((enum-lookup-val expr)
			       ;; ??? If enums could have modes other than INT,
			       ;; we'd want to propagate that mode here.
			       (rtx-make-enum 'INT expr))
			      (else
			       (/rtx-canon-error cstate "unknown operand"
						 expr parent-expr op-num))))
		       ((integer? expr)
			(rtx-make-const 'INT expr))
		       (else
			(/rtx-canon-error cstate "unexpected operand"
					  expr parent-expr op-num)))
@


1.18
log
@	Specify isa(s) when doing ifield, operand, insn lookups.
	ACU = all callers updated.
	* attr.scm (/attr-eval): Call rtx-value instead of rtx-eval-with-estate.
	* enum.scm (define-full-insn-enum): Pass isa-name-list to
	current-ifld-lookup.
	* html.scm (get-insn-properties): Pass isa-name-list to
	current-op-lookup.
	* ifield.scm (/ifld-parse-follows): New arg isas, ACU.
	* insn.scm (/parse-insn-format-symbol): New arg isa-name-list, ACU.
	(/parse-insn-format-list, /parse-insn-iformat-iflds): Ditto.
	(/parse-insn-format, syntax-break-out): Ditto.
	* mach.scm (obj-filter-by-isa): New function.
	(current-ifld-lookup): New optional arg maybe-isa-name-list.
	(/ifld-already-defined?, /op-already-defined?): Simplify.
	(current-op-lookup): New optional arg maybe-isa-name-list.
	(current-insn-lookup): New arg isa-name-list, ACU.
	(/insn-already-defined?, /minsn-already-defined?): Simplify.
	(current-minsn-lookup): New arg isa-name-list, ACU.
	* minsn.scm (/minsn-compute-iflds): Pass isa-name-list to
	current-op-lookup.
	* opc-itab.scm (compute-syntax): New arg isa-name-list, ACU.
	(gen-syntax-entry): Ditto.
	* operand.scm (/operand-parse): Pass isa-name-list to
	current-ifld-lookup.
	(/derived-parse-encoding): New arg isa-name-list, ACU.
	(/derived-parse-ifield-assertion): Ditto.
	(/derived-operand-parse): Pass isa-name-list to current-op-lookup.
	(/anyof-parse-choice): Ditto.
	(anyof-satisfies-assertions?): Pass context to rtx-solve.
	(/anyof-merge-syntax): New arg container, ACU.
	(operand-builtin!): Add pc to all isas.
	* rtl-c.scm (estate-make-for-rtl-c): Delete arg extra-vars-alist, ACU.
	(estate-make-for-rtl-c++, rtl-c-expr-parsed): Ditto.
	(rtl-c-parsed, rtl-c++-parsed): Ditto.
	(rtl-c): New arg isa-name-list, ACU.
	(rtl-c-expr, rtl-c++): Ditto.
	(closure): New arg isa-name-list, ACU.
	* rtl-traverse.scm (/make-cstate): New arg isa-name-list, ACU.
	(/cstate-isas): New function.
	(/rtx-canon-symbol-list): New function.
	(/rtx-canon-env-stack): Renamed from /rtx-canon-env, ACU.
	updated.
	(/rtx-make-canon-table): Rename ENV to ENVSTACK, new entry SYMBOLLIST.
	(/rtx-canon-rtx-operand): Pass isa list to current-op-lookup.
	(/rtx-canon-rtx-ref, /rtx-canon): Ditto.
	(rtx-canonicalize): New arg isa-name-list, ACU.
	(rtx-canonicalize-stmt): Delete.
	(tstate-make): New arg isas, ACU.
	(tstate-isas, tstate--set-isas!): New functions.
	(tstate-env-stack): Renamed from tstate-env, ACU.
	(tstate-set-env-stack!): Renamed from tstate-set-env!, ACU.
	(tstate-make-closure): Renamed from tstate-new-env, new arg
	isa-name-list, ACU.
	(/rtx-traverse-env): Delete.
	(/rtx-make-traverser-table): Rename ENV to ENVSTACK, new entry
	SUMBOLLIST.
	(/rtx-traverse): Include conditional flag in dump output.
	Update isa,envstack for closures.  Pass isa list to current-op-lookup.
	(<eval-state>): New member isas.  Rename env to env-stack.
	(<eval-state> vmake!): Handle #:isas.  #:env renamed to #:env-stack.
	(<eval-state>): New getter/setter for isas.  Rename env getter/setter
	to env-stack.
	(estate-make-for-eval): Provide #:isas.
	(estate-make-closure): Renamed from estate-new-env.  New arg
	isa-name-list, ACU.
	* rtl-xform.scm (/rtx-simplify-expr-fn): Handle closures.
	(/rtx-trim-args): ENV renamed to ENVSTACK.  Ad ITERATION, SYMBOLLIST.
	(/rtx-trim-for-doc): Handle closures.
	* rtl.scm (/rtx-valid-types): Rename ENV to ENVSTACK.  Add ITERATION,
	SYMBOLLIST.
	(rtx-env-var-list): Delete.
	(rtx-env-make): Handle already-compiled environments.
	(rtx-var-alist-to-env): New function.
	(rtx-var-alist-to-closure-env-stack, rtx-make-env-stack): New functions.
	(rtx-env-stack-dump): Renamed from rtx-env-dump, ACU.
	(rtx-operand-obj): New arg isa-name-list, ACU.
	(rtx-closure-isas, rtx-closure-env-stack, rtx-closure-expr): New
	functions.
	* rtx-funcs.scm (closure): New arg isa-name-list, reorder args, ACU.
	* sem-frags.scm (<sfrag>): Delete member compiled-semantics.
	(/frag-compute-desired-frags): Minor simplification.
	(/frag-pick-best): Ditto.
	* sid-cpu.scm (gen-semantic-code): Require canonical rtl.
	(/gen-sfrag-code): Update.
	* sim-cpu.scm (gen-semantic-code): Require canonical rtl.
	* utils-cgen.scm (sanitize): New arg isa-name-list, ACU.
	* utils.scm (non-null-intersection?): New function.
@
text
@d771 1
a771 1
	  (enum-obj (enum-lookup-val enum-name)))
d773 1
a773 1
      (if (not enum-obj)
@


1.17
log
@(/rtx-canon): Minor simplification of previous patch.
@
text
@d20 2
a21 2
(define (/make-cstate context outer-expr)
  (vector context outer-expr)
d25 2
a26 1
(define (/cstate-outer-expr cstate) (vector-ref cstate 1))
d479 9
a487 1
(define (/rtx-canon-env val mode parent-expr op-num cstate env depth)
d570 2
a571 1
	  (cons 'ENV /rtx-canon-env)
d818 1
a818 1
    (let ((op-obj (current-op-lookup op-name)))
d889 1
a889 1
    (let ((op-obj (current-op-lookup env ref-name)))
d1160 1
a1160 1
	  (rtx-env-dump env)
d1188 1
a1188 1
	(rtx-env-dump env)
d1215 1
a1215 1
			(cond ((current-op-lookup expr)
d1267 1
d1274 4
d1282 6
a1287 4
;; VALUE can be #f which means "unknown".
;;
;; ??? If EXTRA-VARS-ALIST is non-null, it might be nice to return a closure.
;; It might simplify subsequent uses of the canonicalized code.
d1289 1
a1289 1
(define (rtx-canonicalize context mode-name expr extra-vars-alist)
d1292 1
a1292 1
		     (/make-cstate context expr)
d1295 3
a1297 9
    result)
)

;; Utility for a common case.
;; Canonicalize rtl expression STMT which has a VOID result,
;; and no external environment.

(define (rtx-canonicalize-stmt context stmt)
  (rtx-canonicalize context 'VOID stmt nil)
d1339 2
d1365 2
a1366 2
(define (tstate-make context owner expr-fn env cond? known depth)
  (vector context owner expr-fn env cond? known depth)
d1369 16
a1384 14
(define (tstate-context state)             (vector-ref state 0))
(define (tstate-set-context! state newval) (vector-set! state 0 newval))
(define (tstate-owner state)               (vector-ref state 1))
(define (tstate-set-owner! state newval)   (vector-set! state 1 newval))
(define (tstate-expr-fn state)             (vector-ref state 2))
(define (tstate-set-expr-fn! state newval) (vector-set! state 2 newval))
(define (tstate-env state)                 (vector-ref state 3))
(define (tstate-set-env! state newval)     (vector-set! state 3 newval))
(define (tstate-cond? state)               (vector-ref state 4))
(define (tstate-set-cond?! state newval)   (vector-set! state 4 newval))
(define (tstate-known state)               (vector-ref state 5))
(define (tstate-set-known! state newval)   (vector-set! state 5 newval))
(define (tstate-depth state)               (vector-ref state 6))
(define (tstate-set-depth! state newval)   (vector-set! state 6 newval))
d1393 2
a1394 1
; Create a copy of STATE with a new environment ENV.
d1396 1
a1396 1
(define (tstate-new-env state env)
d1398 2
a1399 1
    (tstate-set-env! result env)
d1410 1
a1410 1
    (tstate-set-env! result (cons env (tstate-env result)))
a1550 5
(define (/rtx-traverse-env val expr op-num tstate appstuff)
  ;; VAL is an environment stack.
  (cons val (tstate-new-env tstate val))
)

d1593 3
a1595 1
	  (cons 'ENV /rtx-traverse-env)
d1622 1
a1622 1
	(rtx-env-dump (tstate-env tstate))
a1749 6
;
; All macros are expanded here.  User code never sees them.
; All operand shortcuts are also expand here.  User code never sees them.
; These are:
; - operands, ifields, and numbers appearing where an rtx is expected are
;   converted to use `operand', `ifield', or `const'.
d1762 4
d1773 10
a1782 1
      (let ((rtx-obj (rtx-lookup (car expr))))
d1787 1
a1787 1
		   (let ((rtx-obj (/rtx-macro-lookup (car expr))))
d1797 1
d1801 1
a1801 1
		 (cond ((current-op-lookup expr)
d1808 1
a1808 1
		       ((rtx-temp-lookup (tstate-env tstate) expr)
d1837 1
a1837 1
; EXPR must be fully canonical (i.e. compiled).
d1846 3
a1848 1
		 (tstate-make context owner expr-fn (rtx-env-empty-stack)
d1856 1
d1937 10
a1946 2
		; Current environment.  This is a stack of sequence locals.
		(env . ())
d1982 4
a1985 2
	     ((#:env)
	      (elm-set! self 'env (cadr args)))
d2000 1
a2000 1
  (context owner outer-expr expr-fn env depth modifiers)
d2003 1
a2003 1
  (env depth modifiers)
d2015 2
a2016 1
		     (rtx-evaluator rtx-obj)))
d2025 2
a2026 1
; Create a copy of ESTATE with a new environment ENV.
d2028 1
a2028 1
(define (estate-new-env estate env)
d2030 2
a2031 1
    (estate-set-env! result env)
d2042 1
a2042 1
    (estate-set-env! result (cons env (estate-env result)))
d2067 1
a2067 1
	 #:env (tstate-env t))
d2111 1
a2111 1
	(rtx-env-dump (estate-env estate))
d2140 3
a2142 2
; OWNER is the owner of the value, used for attribute computation,
; or #f if there isn't one.
@


1.16
log
@	* rtl-traverse.scm (/rtx-canon): Issue better error message for
	invalid rtx function names.
@
text
@d1185 2
a1186 2
	     (begin
	       (if (not (symbol? (car expr)))
d1189 1
a1189 1
	       (let ((rtx-obj (rtx-lookup (car expr))))
d1191 1
a1191 1
		     (/rtx-canon-expr rtx-obj mode (car expr) (cdr expr)
d1193 1
a1193 1
		     (let ((rtx-obj (/rtx-macro-lookup (car expr))))
@


1.15
log
@	* operand.scm (/anyof-merge-setter): Handle set-quiet.

	* rtl-c.scm (estate-make-for-rtl-c): Delete args context, owner,
	rtl-cover-fns?, macro?.  All callers updated.
	(estate-make-for-normal-rtl-c): Delete, have all callers call
	estate-make-for-rtl-c directly.
	(rtl-c-parsed): Pass #:outer-expr to estate-make-for-rtl-c.
	(rtl-c, rtl-c-expr-parsed, rtl-c-expr, rtl-c++-parsed, rtl-c++): Ditto.

	* rtl-c.scm (/par-replace-set-dest-expr-fn): New function,
	replaces /par-replace-set-dests.
	(/par-replace-set-src-expr-fn): New function, replaces
	/par-replace-set-srcs.
	(s-parallel): Rewrite.

	* rtl.scm (rtx-pretty-strdump): New function.
	* rtl-traverse.scm (/rtx-canon-error): Use it.
	(<eval-state>): New member outer-expr.
	(estate-error): Include outer expression in error message if present.

	* rtl.scm (rtx-single-set?): Handle set-quiet.
@
text
@d1185 14
a1198 10
	     (let ((rtx-obj (rtx-lookup (car expr))))
	       (if rtx-obj
		   (/rtx-canon-expr rtx-obj mode (car expr) (cdr expr)
				    parent-expr op-num cstate env depth)
		   (let ((rtx-obj (/rtx-macro-lookup (car expr))))
		     (if rtx-obj
			 (/rtx-canon (/rtx-macro-expand expr rtx-evaluator)
				     expected mode parent-expr op-num cstate env (+ depth 1))
			 (/rtx-canon-error cstate "unknown rtx function"
					   expr parent-expr op-num)))))
@


1.14
log
@	* xc16x.cpu (h-cr): New hardware.
	(muls): Comment out parts that won't compile, add fixme.
	(mulu, divl, divlu, jmpabs, jmpa-, jmprel, jbc, jnbs, callr): Ditto.
	(scxti, scxtmg, scxtm, bclear, bclr18, bset19, bitset, bmov): Ditto.
	(bmovn, band, bor, bxor, bcmp, bfldl, bfldh): Ditto.

	Rewrite rtl processing to require it to be "canonicalized" first,
	and write a full canonicalizer / expression checker.
	Remove all appearances of DFLT in canonical rtl.
	* attr.scm (/attr-eval atval owner): Call rtx-canonicalize,
	then rtx-simplify.
	* iformat.scm (ifmt-analyze) Use canonical semantics.
	* insn (<insn>): New member canonical-semantics.
	* mach.scm (<arch>): New member multi-insns-instantiated?.
	(/instantiate-multi-insns!): New function.
	(/canonicalize-insns!): New function.
	(arch-analyze-insns!): Canonicalize insn semantics before processing
	them.
	* mode.scm (/mode-set-word-params!): New function.
	(mode-void?): New function.
	(mode-compatible?): VOID is compatible with VOID.
	(/mode-word-sizes-defined?): New global.
	(mode-set-word-modes!): Use/set it.
	(mode-ensure-word-sizes-defined): Update.
	(mode-builtin!): New builtin "modes" SYM, INSN, MACH.
	Redo WI/UWI/AI/IAI handling.
	(op:new-mode): No longer accept DFLT.
	(<derived-operand> constructor): Ensure all fields are initialized.
	(<anyof-operand> constructor): Ditto.
	(/derived-parse-ifield-assertion): Delete arg `args'.
	All callers updated.
	* rtl-c.scm (<rtl-c-eval-state>): New member `for-insn?'.
	(rtl-c): Call rtx-canonicalize instead of rtx-compile.
	(rtl-c-expr, rtl-c++): Ditto.
	(/rtl-c-get): Use mode of operand, not containing expression.
	(rtl-c-set-quiet, rtl-c-set-trace): Remove DFLT support.
	(/rtx-use-sem-fn?): Don't check for (insn? owner), check
	estate-for-insn? instead.
	(s-unop): Use mode of expression, not first operand.
	(s-binop, s-binop-with-bit, s-shop, s-cmpop): Ditto.
	(s-sequence): Remove DFLT support.
	(ifield): Use mode of expression, not UINT.
	(pc): Comment out, unused.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	(set, set-quiet): Pass src to rtl-c-set-{trace,quiet} for expansion.
	* rtl-traverse.scm (/rtx-canon-debug?): New global.
	(/make-cstate): New function.
	(/cstate-context, /cstate-outer-expr): New functions.
	(/rtx-canon-error): New function.
	(/rtx-lookup-hw, /rtx-pick-mode, /rtx-pick-mode3, /rtx-pick-op-mode,
	/rtx-get-last-cond-case-rtx): New functions.
	(/rtx-canon-*): New functions.
	(/rtx-canner-table, /rtx-operand-canoners): New globals.
	(/rtx-make-canon-table, /rtx-special-expr-canoners): New functions.
	(/rtx-option, /rtx-option-list?): Rewrite.
	(rtx-munge-mode&options): Replaces /rtx-munge-mode&options.
	Rewritten, all callers updated.
	(/rtx-canon-expr, /rtx-canon): New functions.
	(rtx-canonicalize): Move here from rtl-xform.scm and rewrite.
	(rtx-canonicalize-stmt): New function.
	(tstate-make): Remove arg `set?'.  All callers updated.
	(tstate-new-set?): Delete.
	(/rtx-traverse-options, /rtx-traverse-*mode): Delete,
	moved to /rtx-canon-*.
	(/rtx-traverse-normal-operand): New function.
	(/rtx-traverse-rtx-list): Delete arg `mode', all callers updated.
	(/rtx-traverse-rtx, /rtx-traverse-setrtx,, /rtx-traverse-testrtx,
	/rtx-traverse-condrtx, /rtx-traverse-casertx, /rtx-traverse-locals,
	/rtx-traverse-iteration, /rtx-traverse-env, /rtx-traverse-attrs):
	Ditto.
	(/rtx-traverse-symbol, /rtx-traverse-string, /rtx-traverse-number,
	/rtx-traverse-symornum, /rtx-traverse-object): Delete.
	(/rtx-make-traverser-table): Update.
	(/rtx-traverse-operands): Remove mode processing, now done during
	canonicalization.
	(/rtx-traverse-expr): Delete arg `mode', all callers updated.
	(/rtx-traverse): Ditto.
	(rtx-init-traverser-tables!): New function.
	* rtl-xform (/rtx-verify-no-dflt-modes-expr-fn): New function.
	(rtx-verify-no-dflt-modes): New function.
	(/rtx-simplify-expr-fn): Update, `arg' mode deleted.
	(rtx-simplify-insn): Use insn-canonical-semantics.
	(rtx-canonicalize): Moved to rtl-traverse.scm.
	(/compile-expr-fn, rtx-compile): Delete.
	(/rtx-trim-rtx-list): New function.
	(/rtx-trim-for-doc): Handle set, if.
	* rtl.scm (<rtx-func>): New members result-mode, matchexpr-index.
	(/rtx-valid-mode-types): Update.
	(/rtx-valid-matches): Update.
	(/rtx-find-matchexpr-index): New function.
	(rtx-lookup): Require rtx-kind to be the rtx name.
	(def-rtx-node): New arg result-mode, all callers updated.
	(def-rtx-syntax-node, def-rtx-operand-node): Ditto.
	(rtx-lazy-sem-mode): Delete.
	(/rtx-closure-make): New arg `mode', all callers updated.
	(rtx-make-ifield, rtx-make-operand, rtx-make-local): Ditto.
	(rtx-operand-obj): Rewrite.
	(rtx-make-xop): New functions.
	(/hw): Renamed from `hw', all callers updated.
	Use the correct mode instead of DFLT for the index.
	(rtl-builtin!): Call rtx-init-traversal-tables!.
	(rtl-finish!): Update.
	* rtx-funcs.scm (all rtx functions): New parameter: result-mode.
	Update mode arg-type.
	(pc): Comment out.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	* sem-frags.scm (/frag-hash-compute!): Update, mode arg deleted.
	(/frag-cost-compute!): Ditto.
	* semantics.scm (/build-operand!): Delete args op-name, op.
	New arg op-expr.  All callers updated.
	(/build-mem-operand!): Remove DFLT support.
	(semantic-compile): Update process-expr!, mode arg deleted.
	* sid-cpu.scm (gen-semantic-code): Specify #:for-insn? in
	rtl-c++ calls.
	(/gen-sem-case, /gen-sfrag-code): Ditto.
	* sid.scm (/op-gen-set-trace1): Renamed from /op-gen-set-trace.
	(/op-gen-set-trace): New function.  If not doing profiling,
	call /op-gen-set-quiet.
	* sim-cpu.scm (gen-semantic-code): Specify #:for-insn? in rtl-c calls.
	* utils-gen.scm (/gen-ifld-extract-base): Update call to rtl-c.
	(/gen-ifld-extract-beyond, gen-multi-ifld-extract): Ditto.
	* utils.scm (find-first-index): New function.
	* doc/rtl.texi: Delete docs for `attr'.  Add `int-attr'.
@
text
@d30 1
a30 4
  (let* ((pretty-parent-expr
	  (with-output-to-string
	    (lambda ()
	      (pretty-print (rtx-dump (/cstate-outer-expr cstate))))))
d1881 4
d1941 2
d1961 1
a1961 1
  (context owner expr-fn env depth modifiers)
d1964 1
a1964 1
  (context owner expr-fn env depth modifiers)
d2034 6
a2039 1
		     (cons "During rtx evalution"
@


1.13
log
@	Clean up pass of mode handling.
	Make use of mode name vs <mode> object more consistent and clear.
	* hardware.scm (/keyword-read): Default mode to the mode name,
	not the <mode> object.
	(/hw-parse-indices): Parse mode name and pass mode object to
	<hw-asm> constructor.
	(/hw-parse-values): Ditto.
	(<hw-register> parse!): Pass mode name to /hw-parse-indices
	and /hw-parse-values.
	(<hw-memory> parse!): Ditto.
	(<hw-address> parse!): Ditto.
	* mode.scm (/mode-table): New global, replaces mode-list.
	Modes stored in hashtable instead of list.
	(/mode-class-table): New global.
	(mode-list-non-alias-values): Update.
	(mode:eq?, mode-compatible?, mode:add!): Update.
	(mode:lookup): Restrict arg to the mode's name.  All callers updated.
	(mode-maybe-lookup): New function.
	(mode-real-name): Restrict arg to a <mode> object.  All callers updated.
	(mode-real-mode, mode-sem-mode, mode-bigger?): Ditto.
	(mode-find, mode-set-word-modes!): Update
	(mode-ensure-word-sizes-defined): Update.
	(/sort-mode-classes!): New function.
	(mode-builtin!): Update.  Sort mode classes here.
	(mode-finish!): Sort mode classes here too.
	* rtl-c.scm (/rtl-c-get): Restrict mode arg to a <mode> object.
	All callers updated.
	(rtl-c-set-quiet): Allow mode to be name of object.
	(rtl-c-set-trace): Ditto.
	* rtl-traverse.scm (rtl-eval-with-estate): Restrict mode arg to
	<mode> object.  All callers updated.
	* rtl.scm (rtx-sem-mode): Restrict arg to <mode> object.
	(rtx-lazy-sem-mode): Ditto.
	(<rtx-temp> make!): Assert mode arg is a <mode> object.
	(rtx-env-make): Allow var-list modes to be name or object.
	* sem-frags.scm (/frag-expr-assq-locals): New function.
	(/frag-compute-locals!): Call it.
	(/sfrag-create-cse-mapping): Renamed from sfrag-create-cse-mapping.
	All callers updated.
	* semantics.scm (/build-mem-operand!): Handle mode aliases.
@
text
@d1 293
a293 9
; RTL traversing support.
; Copyright (C) 2000, 2001, 2009 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.

; RTL expression traversal support.
; Traversal (and compilation) involves validating the source form and
; converting it to internal form.
; ??? At present the internal form is also the source form (easier debugging).
d295 998
a1292 1
; Set to #t to debug rtx traversal.
d1314 1
a1314 2
; (lambda (rtx-obj expr mode parent-expr op-pos tstate appstuff) ...).
; MODE is the name of the mode.
d1316 1
a1316 1
; (cons TSTATE (cdr EXPR)).  TSTATE is prepended to the arguments.
d1321 2
a1322 2
; are (rtx-obj expr mode parent-expr op-pos tstate appstuff).  The format
; of the result of EXPR-FN are (cons TSTATE (cdr EXPR)).
a1336 3
; SET? is a boolean indicating if the current expression is an operand being
; set.
;
d1351 2
a1352 2
(define (tstate-make context owner expr-fn env cond? set? known depth)
  (vector context owner expr-fn env cond? set? known depth)
d1365 4
a1368 6
(define (tstate-set? state)                (vector-ref state 5))
(define (tstate-set-set?! state newval)    (vector-set! state 5 newval))
(define (tstate-known state)               (vector-ref state 6))
(define (tstate-set-known! state newval)   (vector-set! state 6 newval))
(define (tstate-depth state)               (vector-ref state 7))
(define (tstate-set-depth! state newval)   (vector-set! state 7 newval))
a1403 8
; Create a copy of STATE with a new SET? value.

(define (tstate-new-set? state set?)
  (let ((result (tstate-copy state)))
    (tstate-set-set?! result set?)
    result)
)

d1435 1
a1435 1
; Traversal/compilation support.
d1451 1
a1451 1
(define (/rtx-traverse-rtx-list rtx-list mode expr op-num tstate appstuff)
d1454 1
a1454 1
	 (/rtx-traverse rtx 'RTX mode expr op-num tstate appstuff))
d1465 1
a1465 1
		(rtx-strdump rtl-expr))
a1468 2
; These are defined as individual functions that are then built into a table
; so that we can use Hobbit's "fastcall" support.
d1473 1
a1473 57
(define (/rtx-traverse-options val mode expr op-num tstate appstuff)
  #f
)

(define (/rtx-traverse-anymode val mode expr op-num tstate appstuff)
  (let ((val-obj (mode:lookup val)))
    (if (not val-obj)
	(/rtx-traverse-error tstate "expecting a mode"
			     expr op-num))
    #f)
)

(define (/rtx-traverse-intmode val mode expr op-num tstate appstuff)
  (let ((val-obj (mode:lookup val)))
    (if (and val-obj
	     (or (memq (mode:class val-obj) '(INT UINT))
		 (eq? val 'DFLT)))
	#f
	(/rtx-traverse-error tstate "expecting an integer mode"
			     expr op-num)))
)

(define (/rtx-traverse-floatmode val mode expr op-num tstate appstuff)
  (let ((val-obj (mode:lookup val)))
    (if (and val-obj
	     (or (memq (mode:class val-obj) '(FLOAT))
		 (eq? val 'DFLT)))
	#f
	(/rtx-traverse-error tstate "expecting a float mode"
			     expr op-num)))
)

(define (/rtx-traverse-nummode val mode expr op-num tstate appstuff)
  (let ((val-obj (mode:lookup val)))
    (if (and val-obj
	     (or (memq (mode:class val-obj) '(INT UINT FLOAT))
		 (eq? val 'DFLT)))
	#f
	(/rtx-traverse-error tstate "expecting a numeric mode"
			     expr op-num)))
)

(define (/rtx-traverse-explnummode val mode expr op-num tstate appstuff)
  (let ((val-obj (mode:lookup val)))
    (if (not val-obj)
	(/rtx-traverse-error tstate "expecting a mode"
			     expr op-num))
    (if (memq val '(DFLT VOID))
	(/rtx-traverse-error tstate "DFLT and VOID not allowed here"
			     expr op-num))
    #f)
)

(define (/rtx-traverse-nonvoidmode val mode expr op-num tstate appstuff)
  (if (eq? val 'VOID)
      (/rtx-traverse-error tstate "mode can't be VOID"
			   expr op-num))
d1477 2
a1478 20
(define (/rtx-traverse-voidmode val mode expr op-num tstate appstuff)
  (if (memq val '(DFLT VOID))
      #f
      (/rtx-traverse-error tstate "expecting mode VOID"
			   expr op-num))
)

(define (/rtx-traverse-dfltmode val mode expr op-num tstate appstuff)
  (if (eq? val 'DFLT)
      #f
      (/rtx-traverse-error tstate "expecting mode DFLT"
			   expr op-num))
)

(define (/rtx-traverse-rtx val mode expr op-num tstate appstuff)
; Commented out 'cus it doesn't quite work yet.
; (if (not (rtx? val))
;     (/rtx-traverse-error tstate "expecting an rtx"
;			   expr op-num))
  (cons (/rtx-traverse val 'RTX mode expr op-num tstate appstuff)
d1482 2
a1483 10
(define (/rtx-traverse-setrtx val mode expr op-num tstate appstuff)
  ; FIXME: Still need to turn it off for sub-exprs.
  ; e.g. (mem (reg ...))
; Commented out 'cus it doesn't quite work yet.
; (if (not (rtx? val))
;     (/rtx-traverse-error tstate "expecting an rtx"
;				  expr op-num))
  (cons (/rtx-traverse val 'SETRTX mode expr op-num
		       (tstate-new-set? tstate #t)
		       appstuff)
d1489 2
a1490 6
(define (/rtx-traverse-testrtx val mode expr op-num tstate appstuff)
; Commented out 'cus it doesn't quite work yet.
; (if (not (rtx? val))
;     (/rtx-traverse-error tstate "expecting an rtx"
;				  expr op-num))
  (cons (/rtx-traverse val 'RTX mode expr op-num tstate appstuff)
d1496 1
a1496 4
(define (/rtx-traverse-condrtx val mode expr op-num tstate appstuff)
  (if (not (pair? val))
      (/rtx-traverse-error tstate "expecting an expression"
			   expr op-num))
d1498 6
a1503 11
      (begin
	(if (!= (+ op-num 2) (length expr))
	    (/rtx-traverse-error tstate
				 "`else' clause not last"
				 expr op-num))
	(cons (cons 'else
		    (/rtx-traverse-rtx-list
		     (cdr val) mode expr op-num
		     (tstate-new-cond? tstate #t)
		     appstuff))
	      (tstate-new-cond? tstate #t)))
d1506 1
a1506 1
	     (/rtx-traverse (car val) 'RTX 'ANY expr op-num tstate appstuff)
d1508 1
a1508 1
	      (cdr val) mode expr op-num
d1514 1
a1514 19
(define (/rtx-traverse-casertx val mode expr op-num tstate appstuff)
  (if (or (not (list? val))
	  (< (length val) 2))
      (/rtx-traverse-error tstate
			   "invalid `case' expression"
			   expr op-num))
  ; car is either 'else or list of symbols/numbers
  (if (not (or (eq? (car val) 'else)
	       (and (list? (car val))
		    (not (null? (car val)))
		    (all-true? (map /rtx-symornum?
				    (car val))))))
      (/rtx-traverse-error tstate
			   "invalid `case' choice"
			   expr op-num))
  (if (and (eq? (car val) 'else)
	   (!= (+ op-num 2) (length expr)))
      (/rtx-traverse-error tstate "`else' clause not last"
			   expr op-num))
d1517 1
a1517 1
	       (cdr val) mode expr op-num
d1523 1
a1523 13
(define (/rtx-traverse-locals val mode expr op-num tstate appstuff)
  (if (not (list? val))
      (/rtx-traverse-error tstate "bad locals list"
			   expr op-num))
  (for-each (lambda (var)
	      (if (or (not (list? var))
		      (!= (length var) 2)
		      (not (/rtx-any-mode? (car var)))
		      (not (symbol? (cadr var))))
		  (/rtx-traverse-error tstate
				       "bad locals list"
				       expr op-num)))
	    val)
d1528 1
a1528 4
(define (/rtx-traverse-iteration val mode expr op-num tstate appstuff)
  (if (not (symbol? val))
      (/rtx-traverse-error tstate "bad iteration variable name"
			   expr op-num))
d1533 2
a1534 5
(define (/rtx-traverse-env val mode expr op-num tstate appstuff)
  ; VAL is an environment stack.
  (if (not (list? val))
      (/rtx-traverse-error tstate "environment not a list"
			   expr op-num))
d1538 1
a1538 1
(define (/rtx-traverse-attrs val mode expr op-num tstate appstuff)
a1543 33
(define (/rtx-traverse-symbol val mode expr op-num tstate appstuff)
  (if (not (symbol? val))
      (/rtx-traverse-error tstate "expecting a symbol"
			   expr op-num))
  #f
)

(define (/rtx-traverse-string val mode expr op-num tstate appstuff)
  (if (not (string? val))
      (/rtx-traverse-error tstate "expecting a string"
			   expr op-num))
  #f
)

(define (/rtx-traverse-number val mode expr op-num tstate appstuff)
  (if (not (number? val))
      (/rtx-traverse-error tstate "expecting a number"
			   expr op-num))
  #f
)

(define (/rtx-traverse-symornum val mode expr op-num tstate appstuff)
  (if (not (or (symbol? val) (number? val)))
      (/rtx-traverse-error tstate
			   "expecting a symbol or number"
			   expr op-num))
  #f
)

(define (/rtx-traverse-object val mode expr op-num tstate appstuff)
  #f
)

d1560 27
a1586 25
	  ; /fastcall-make is recognized by Hobbit and handled specially.
	  ; When not using Hobbit it is a macro that returns its argument.
	  (cons 'OPTIONS (/fastcall-make /rtx-traverse-options))
	  (cons 'ANYMODE (/fastcall-make /rtx-traverse-anymode))
	  (cons 'INTMODE (/fastcall-make /rtx-traverse-intmode))
	  (cons 'FLOATMODE (/fastcall-make /rtx-traverse-floatmode))
	  (cons 'NUMMODE (/fastcall-make /rtx-traverse-nummode))
	  (cons 'EXPLNUMMODE (/fastcall-make /rtx-traverse-explnummode))
	  (cons 'NONVOIDMODE (/fastcall-make /rtx-traverse-nonvoidmode))
	  (cons 'VOIDMODE (/fastcall-make /rtx-traverse-voidmode))
	  (cons 'DFLTMODE (/fastcall-make /rtx-traverse-dfltmode))
	  (cons 'RTX (/fastcall-make /rtx-traverse-rtx))
	  (cons 'SETRTX (/fastcall-make /rtx-traverse-setrtx))
	  (cons 'TESTRTX (/fastcall-make /rtx-traverse-testrtx))
	  (cons 'CONDRTX (/fastcall-make /rtx-traverse-condrtx))
	  (cons 'CASERTX (/fastcall-make /rtx-traverse-casertx))
	  (cons 'LOCALS (/fastcall-make /rtx-traverse-locals))
	  (cons 'ITERATION (/fastcall-make /rtx-traverse-iteration))
	  (cons 'ENV (/fastcall-make /rtx-traverse-env))
	  (cons 'ATTRS (/fastcall-make /rtx-traverse-attrs))
	  (cons 'SYMBOL (/fastcall-make /rtx-traverse-symbol))
	  (cons 'STRING (/fastcall-make /rtx-traverse-string))
	  (cons 'NUMBER (/fastcall-make /rtx-traverse-number))
	  (cons 'SYMORNUM (/fastcall-make /rtx-traverse-symornum))
	  (cons 'OBJECT (/fastcall-make /rtx-traverse-object))
d1597 1
a1597 3
; Here "canonicalized" means that /rtx-munge-mode&options has been called to
; insert an option list and mode if they were absent in the original
; expression.
d1608 1
a1608 2
	(force-output)
	))
d1614 1
a1614 2
	     (result nil)
	     )
d1632 1
a1632 2
	    (force-output)
	    ))
d1635 1
a1635 1
	     ; Out of operands, check if we have the expected number.
d1639 1
a1639 1
		 (tstate-error tstate "missing operands" (rtx-strdump expr))))
d1642 1
a1642 1
	     (tstate-error tstate "too many operands" (rtx-strdump expr)))
d1645 2
a1646 26
	     (let ((type (if varargs? arg-types (car arg-types)))
		   (mode (let ((mode-spec (if varargs?
					      arg-modes
					      (car arg-modes))))
			   ; This is small enough that this is fast enough,
			   ; and the number of entries should be stable.
			   ; FIXME: for now
			   (case mode-spec
			     ((ANY) 'DFLT)
			     ((NA) #f)
			     ((OP0) (rtx-mode expr))
			     ((MATCH1)
			      ; If there is an explicit mode, use it.
			      ; Otherwise we have to look at operand 1.
			      (if (eq? (rtx-mode expr) 'DFLT)
				  'DFLT
				  (rtx-mode expr)))
			     ((MATCH2)
			      ; If there is an explicit mode, use it.
			      ; Otherwise we have to look at operand 2.
			      (if (eq? (rtx-mode expr) 'DFLT)
				  'DFLT
				  (rtx-mode expr)))
			     (else mode-spec))))
		   (val (car operands))
		   )
d1648 2
a1649 1
	       ; Look up the traverser for this kind of operand and perform it.
d1651 1
a1651 1
		 (let ((traversed-val (fastcall6 traverser val mode expr op-num tstate appstuff)))
d1657 1
a1657 1
	       ; Done with this operand, proceed to the next.
a1669 52
; Subroutine of /rtx-munge-mode&options.
; Return boolean indicating if X is an rtx option.

(define (/rtx-option? x)
  (and (symbol? x)
       (char=? (string-ref (symbol->string x) 0) #\:))
)

; Subroutine of /rtx-munge-mode&options.
; Return boolean indicating if X is an rtx option list.

(define (/rtx-option-list? x)
  (or (null? x)
      (and (pair? x)
	   (/rtx-option? (car x))))
)

; Subroutine of /rtx-traverse-expr to fill in the mode if absent and to
; collect the options into one list.
;
; ARGS is the list of arguments to the rtx function
; (e.g. (1 2) in (add 1 2)).
; ??? "munge" is an awkward name to use here, but I like it for now because
; it's easy to grep for.
; ??? An empty option list requires a mode to be present so that the empty
; list in `(sequence () foo bar)' is unambiguously recognized as the locals
; list.  Icky, sure, but less icky than the alternatives thus far.

(define (/rtx-munge-mode&options args)
  (let ((options nil)
	(mode-name 'DFLT))
    ; Pick off the option list if present.
    (if (and (pair? args)
	     (/rtx-option-list? (car args))
	     ; Handle `(sequence () foo bar)'.  If empty list isn't followed
	     ; by a mode, it is not an option list.
	     (or (not (null? (car args)))
		 (and (pair? (cdr args))
		      (mode-name? (cadr args)))))
	(begin
	  (set! options (car args))
	  (set! args (cdr args))))
    ; Pick off the mode if present.
    (if (and (pair? args)
	     (mode-name? (car args)))
	(begin
	  (set! mode-name (car args))
	  (set! args (cdr args))))
    ; Now put option list and mode back.
    (cons options (cons mode-name args)))
)

d1675 1
a1675 2
;
; MODE is the name of the mode of EXPR.
d1698 3
a1700 5
(define (/rtx-traverse-expr rtx-obj expr mode parent-expr op-pos tstate appstuff)
  (let* ((expr2 (cons (car expr)
		      (/rtx-munge-mode&options (cdr expr))))
	 (fn (fastcall7 (tstate-expr-fn tstate)
			rtx-obj expr2 mode parent-expr op-pos tstate appstuff)))
d1704 3
a1706 3
	    (if (rtx-style-syntax? rtx-obj)
		(apply fn (cons tstate (cdr expr2)))
		(let ((operands (/rtx-traverse-operands rtx-obj expr2 tstate appstuff)))
d1709 2
a1710 2
	(let ((operands (/rtx-traverse-operands rtx-obj expr2 tstate appstuff)))
	  (cons (car expr2) operands))))
d1721 1
a1725 2
; MODE is the name of the mode of EXPR.
;
d1742 1
a1742 1
(define (/rtx-traverse expr expected mode parent-expr op-pos tstate appstuff)
a1752 4
	(display (spaces (* 4 (tstate-depth tstate))))
	(display "-mode:           ")
	(display mode)
	(newline)
d1756 2
d1764 1
a1764 1
		   (/rtx-traverse-expr rtx-obj expr mode parent-expr op-pos tstate appstuff)
d1768 1
a1768 1
					expected mode parent-expr op-pos tstate appstuff)
d1779 6
a1784 3
			(/rtx-traverse
			 (rtx-make-operand expr) ; (current-op-lookup expr))
			 expected mode parent-expr op-pos tstate appstuff))
d1786 4
a1789 3
			(/rtx-traverse
			 (rtx-make-local expr) ; (rtx-temp-lookup (tstate-env tstate) expr))
			 expected mode parent-expr op-pos tstate appstuff))
d1791 4
a1794 3
			(/rtx-traverse
			 (rtx-make-ifield expr)
			 expected mode parent-expr op-pos tstate appstuff))
d1800 1
a1800 1
			 expected mode parent-expr op-pos tstate appstuff))
d1805 1
a1805 1
				expected mode parent-expr op-pos tstate appstuff))
d1814 1
d1822 1
a1822 1
  (/rtx-traverse expr #f 'DFLT #f 0
d1824 1
a1824 1
			      #f #f nil 0)
d1829 1
a1829 1
  (/rtx-traverse expr #f 'DFLT #f 0
d1833 1
a1833 1
			      #f #f nil 0)
d1838 1
d1843 1
a1843 1
   (lambda (rtx-obj expr mode parent-expr op-pos tstate appstuff)
a1847 2
     (display " mode=")
     (display mode)
d2049 2
a2050 2
; EXPR is the expression to be eval'd.  It must be in compiled form.
; MODE is the mode of EXPR, a <mode> object.
d2056 4
a2059 2
	(display "Traversing ")
	(display expr)
d2072 1
a2072 1
;		(if (rtx-style-syntax? rtx-obj)
d2089 1
a2089 1
; EXPR must already be in compiled form (the result of rtx-compile).
d2097 35
@


1.12
log
@	* rtl-traverse.scm: Comment tweaks.
	* rtl-xform.scm: Comment and reformatting tweaks.
	* doc/rtl.texi: Add text to docs on ifield-assertions.
@
text
@d34 1
d1027 1
a1027 1
; MODE is the mode of EXPR, a <mode> object or its name.
d1070 1
a1070 1
  (rtx-eval-with-estate expr 'DFLT (estate-make-for-eval #f owner))
@


1.11
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d64 1
a64 1
; NAME is either an ifield or operand name (in the future it might be a
d66 4
a69 1
; VALUE is either (const mode value) or (numlist mode value1 value2 ...).
d136 3
a138 1
; Lookup NAME in the known value table.  Returns the value or #f if not found.
@


1.10
log
@	Add do-count rtl function.
	* rtl-c.scm (s-do-count): New function.
	(do-count): New rtl handler.
	* rtl-traverse.scm (-rtx-traverse-iteration): New function.
	(-rtx-make-traverser-table): Add ITERATION.
	* rtl.scm (rtx-env-make-iteration-locals): New function.
	* rtx-funcs.scm (do-count): New rtl function.
	* cpu/play.cpu: Add do-count-test insn.
	* doc/rtl.texi: Add docs on do-count.
@
text
@d13 1
a13 1
(define -rtx-traverse-debug? #f)
d166 1
a166 1
(define (-rtx-any-mode? x)
d172 1
a172 1
(define (-rtx-symornum? x)
d178 1
a178 1
(define (-rtx-traverse-rtx-list rtx-list mode expr op-num tstate appstuff)
d181 1
a181 1
	 (-rtx-traverse rtx 'RTX mode expr op-num tstate appstuff))
d189 1
a189 1
(define (-rtx-traverse-error tstate errmsg rtl-expr op-num)
d202 1
a202 1
(define (-rtx-traverse-options val mode expr op-num tstate appstuff)
d206 1
a206 1
(define (-rtx-traverse-anymode val mode expr op-num tstate appstuff)
d209 1
a209 1
	(-rtx-traverse-error tstate "expecting a mode"
d214 1
a214 1
(define (-rtx-traverse-intmode val mode expr op-num tstate appstuff)
d220 1
a220 1
	(-rtx-traverse-error tstate "expecting an integer mode"
d224 1
a224 1
(define (-rtx-traverse-floatmode val mode expr op-num tstate appstuff)
d230 1
a230 1
	(-rtx-traverse-error tstate "expecting a float mode"
d234 1
a234 1
(define (-rtx-traverse-nummode val mode expr op-num tstate appstuff)
d240 1
a240 1
	(-rtx-traverse-error tstate "expecting a numeric mode"
d244 1
a244 1
(define (-rtx-traverse-explnummode val mode expr op-num tstate appstuff)
d247 1
a247 1
	(-rtx-traverse-error tstate "expecting a mode"
d250 1
a250 1
	(-rtx-traverse-error tstate "DFLT and VOID not allowed here"
d255 1
a255 1
(define (-rtx-traverse-nonvoidmode val mode expr op-num tstate appstuff)
d257 1
a257 1
      (-rtx-traverse-error tstate "mode can't be VOID"
d262 1
a262 1
(define (-rtx-traverse-voidmode val mode expr op-num tstate appstuff)
d265 1
a265 1
      (-rtx-traverse-error tstate "expecting mode VOID"
d269 1
a269 1
(define (-rtx-traverse-dfltmode val mode expr op-num tstate appstuff)
d272 1
a272 1
      (-rtx-traverse-error tstate "expecting mode DFLT"
d276 1
a276 1
(define (-rtx-traverse-rtx val mode expr op-num tstate appstuff)
d279 1
a279 1
;     (-rtx-traverse-error tstate "expecting an rtx"
d281 1
a281 1
  (cons (-rtx-traverse val 'RTX mode expr op-num tstate appstuff)
d285 1
a285 1
(define (-rtx-traverse-setrtx val mode expr op-num tstate appstuff)
d290 1
a290 1
;     (-rtx-traverse-error tstate "expecting an rtx"
d292 1
a292 1
  (cons (-rtx-traverse val 'SETRTX mode expr op-num
d300 1
a300 1
(define (-rtx-traverse-testrtx val mode expr op-num tstate appstuff)
d303 1
a303 1
;     (-rtx-traverse-error tstate "expecting an rtx"
d305 1
a305 1
  (cons (-rtx-traverse val 'RTX mode expr op-num tstate appstuff)
d311 1
a311 1
(define (-rtx-traverse-condrtx val mode expr op-num tstate appstuff)
d313 1
a313 1
      (-rtx-traverse-error tstate "expecting an expression"
d318 1
a318 1
	    (-rtx-traverse-error tstate
d322 1
a322 1
		    (-rtx-traverse-rtx-list
d329 2
a330 2
	     (-rtx-traverse (car val) 'RTX 'ANY expr op-num tstate appstuff)
	     (-rtx-traverse-rtx-list
d337 1
a337 1
(define (-rtx-traverse-casertx val mode expr op-num tstate appstuff)
d340 1
a340 1
      (-rtx-traverse-error tstate
d347 1
a347 1
		    (all-true? (map -rtx-symornum?
d349 1
a349 1
      (-rtx-traverse-error tstate
d354 1
a354 1
      (-rtx-traverse-error tstate "`else' clause not last"
d357 1
a357 1
	      (-rtx-traverse-rtx-list
d364 1
a364 1
(define (-rtx-traverse-locals val mode expr op-num tstate appstuff)
d366 1
a366 1
      (-rtx-traverse-error tstate "bad locals list"
d371 1
a371 1
		      (not (-rtx-any-mode? (car var)))
d373 1
a373 1
		  (-rtx-traverse-error tstate
d381 1
a381 1
(define (-rtx-traverse-iteration val mode expr op-num tstate appstuff)
d383 1
a383 1
      (-rtx-traverse-error tstate "bad iteration variable name"
d389 1
a389 1
(define (-rtx-traverse-env val mode expr op-num tstate appstuff)
d392 1
a392 1
      (-rtx-traverse-error tstate "environment not a list"
d397 1
a397 1
(define (-rtx-traverse-attrs val mode expr op-num tstate appstuff)
d403 1
a403 1
(define (-rtx-traverse-symbol val mode expr op-num tstate appstuff)
d405 1
a405 1
      (-rtx-traverse-error tstate "expecting a symbol"
d410 1
a410 1
(define (-rtx-traverse-string val mode expr op-num tstate appstuff)
d412 1
a412 1
      (-rtx-traverse-error tstate "expecting a string"
d417 1
a417 1
(define (-rtx-traverse-number val mode expr op-num tstate appstuff)
d419 1
a419 1
      (-rtx-traverse-error tstate "expecting a number"
d424 1
a424 1
(define (-rtx-traverse-symornum val mode expr op-num tstate appstuff)
d426 1
a426 1
      (-rtx-traverse-error tstate
d432 1
a432 1
(define (-rtx-traverse-object val mode expr op-num tstate appstuff)
d440 1
d442 1
a442 1
(define -rtx-traverser-table #f)
d448 1
a448 1
(define (-rtx-make-traverser-table)
d454 23
a476 23
	  (cons 'OPTIONS (/fastcall-make -rtx-traverse-options))
	  (cons 'ANYMODE (/fastcall-make -rtx-traverse-anymode))
	  (cons 'INTMODE (/fastcall-make -rtx-traverse-intmode))
	  (cons 'FLOATMODE (/fastcall-make -rtx-traverse-floatmode))
	  (cons 'NUMMODE (/fastcall-make -rtx-traverse-nummode))
	  (cons 'EXPLNUMMODE (/fastcall-make -rtx-traverse-explnummode))
	  (cons 'NONVOIDMODE (/fastcall-make -rtx-traverse-nonvoidmode))
	  (cons 'VOIDMODE (/fastcall-make -rtx-traverse-voidmode))
	  (cons 'DFLTMODE (/fastcall-make -rtx-traverse-dfltmode))
	  (cons 'RTX (/fastcall-make -rtx-traverse-rtx))
	  (cons 'SETRTX (/fastcall-make -rtx-traverse-setrtx))
	  (cons 'TESTRTX (/fastcall-make -rtx-traverse-testrtx))
	  (cons 'CONDRTX (/fastcall-make -rtx-traverse-condrtx))
	  (cons 'CASERTX (/fastcall-make -rtx-traverse-casertx))
	  (cons 'LOCALS (/fastcall-make -rtx-traverse-locals))
	  (cons 'ITERATION (/fastcall-make -rtx-traverse-iteration))
	  (cons 'ENV (/fastcall-make -rtx-traverse-env))
	  (cons 'ATTRS (/fastcall-make -rtx-traverse-attrs))
	  (cons 'SYMBOL (/fastcall-make -rtx-traverse-symbol))
	  (cons 'STRING (/fastcall-make -rtx-traverse-string))
	  (cons 'NUMBER (/fastcall-make -rtx-traverse-number))
	  (cons 'SYMORNUM (/fastcall-make -rtx-traverse-symornum))
	  (cons 'OBJECT (/fastcall-make -rtx-traverse-object))
d487 1
a487 1
; Here "canonicalized" means that -rtx-munge-mode&options has been called to
d492 2
a493 2
(define (-rtx-traverse-operands rtx-obj expr tstate appstuff)
  (if -rtx-traverse-debug?
d505 1
a505 1
	     (arg-types (vector-ref -rtx-traverser-table (rtx-num rtx-obj)))
d512 1
a512 1
      (if -rtx-traverse-debug?
d583 1
a583 1
; Publically accessible version of -rtx-traverse-operands as EXPR-FN may
d586 1
a586 1
(define rtx-traverse-operands -rtx-traverse-operands)
d588 1
a588 1
; Subroutine of -rtx-munge-mode&options.
d591 1
a591 1
(define (-rtx-option? x)
d596 1
a596 1
; Subroutine of -rtx-munge-mode&options.
d599 1
a599 1
(define (-rtx-option-list? x)
d602 1
a602 1
	   (-rtx-option? (car x))))
d605 1
a605 1
; Subroutine of -rtx-traverse-expr to fill in the mode if absent and to
d616 1
a616 1
(define (-rtx-munge-mode&options args)
d621 1
a621 1
	     (-rtx-option-list? (car args))
d640 1
a640 1
; Subroutine of -rtx-traverse to traverse an expression.
d669 1
a669 1
(define (-rtx-traverse-expr rtx-obj expr mode parent-expr op-pos tstate appstuff)
d671 1
a671 1
		      (-rtx-munge-mode&options (cdr expr))))
d679 1
a679 1
		(let ((operands (-rtx-traverse-operands rtx-obj expr2 tstate appstuff)))
d682 1
a682 1
	(let ((operands (-rtx-traverse-operands rtx-obj expr2 tstate appstuff)))
d716 2
a717 2
(define (-rtx-traverse expr expected mode parent-expr op-pos tstate appstuff)
  (if -rtx-traverse-debug?
d740 2
a741 2
		   (-rtx-traverse-expr rtx-obj expr mode parent-expr op-pos tstate appstuff)
		   (let ((rtx-obj (-rtx-macro-lookup (car expr))))
d743 1
a743 1
			 (-rtx-traverse (-rtx-macro-expand expr rtx-evaluator)
d755 1
a755 1
			(-rtx-traverse
d759 1
a759 1
			(-rtx-traverse
d763 1
a763 1
			(-rtx-traverse
d769 1
a769 1
			(-rtx-traverse
d775 1
a775 1
		 (-rtx-traverse (rtx-make-const 'INT expr)
d785 1
a785 1
; These calls -rtx-traverse to do most of the work.
d792 1
a792 1
  (-rtx-traverse expr #f 'DFLT #f 0
d799 1
a799 1
  (-rtx-traverse expr #f 'DFLT #f 0
d1016 1
a1016 1
(define -rtx-eval-debug? #f)
d1025 1
a1025 1
  (if -rtx-eval-debug?
d1044 1
a1044 1
;			   (-rtx-eval-operands rtx-obj expr estate)))
d1050 1
a1050 1
;		   (-rtx-traverse-operands rtx-obj expr estate)))
@


1.9
log
@	* read.scm (parse-error): Change error message output format
	to match context-owner-error.
	* rtl-c.scm (-rtl-c-get): Call estate-error instead of error.
	(rtl-c-set-quiet, rtl-c-set-trace): Ditto.
	(s-if, s-cond, -gen-non-vm-case-test): Ditto.
	(operand): Call estate-error instead of context-error.
	(local, delay): Ditto.
	(ref, attr): Call estate-error instead of error.
	* rtl-traverse.scm (tstate-error): New function.
	(-rtx-traverse-error): Call tstate-error instead of context-error.
	(-rtx-traverse-operands, -rtx-traverse): Ditto.
	(estate-error): New function.
	* rtl.scm (rtx-lvalue-mode-name): Handle locals.  Call estate-error
	instead of error.
	(e-if): Call estate-error instead of error.
	* rtx-funcs.scm (error): Call estate-error instead of context-error.
	(member): Ditto.
	* utils-cgen.scm (context-error): New arg `intro', all callers updated.
	Rewrite to call context-owner-error.
	(context-owner-error): New function.
@
text
@d381 8
d468 1
@


1.8
log
@	* rtl-traverse.scm (estate-new-env): Rename arg state -> estate.
	(estate-push-env, estate-with-modifiers): Ditto.
	(estate-deepen): New function.
@
text
@d151 10
d185 8
a192 10
; Cover-fn to context-error for signalling an error during rtx traversal.

(define (-rtx-traverse-error tstate errmsg expr op-num)
;  (parse-error (tstate-context context)
;               (string-append errmsg ", operand number "
;                              (number->string op-num))
;               (rtx-dump expr))
  (context-error (tstate-context tstate)
		 (string-append errmsg ", operand #" (number->string op-num))
		 (rtx-strdump expr))
d524 1
a524 2
		 (context-error (tstate-context tstate)
				"missing operands" (rtx-strdump expr))))
d527 1
a527 2
	     (context-error (tstate-context tstate)
			    "too many operands" (rtx-strdump expr)))
d735 1
a735 2
			 (context-error (tstate-context tstate) "unknown rtx function"
					expr))))))
d763 1
a763 2
			(context-error (tstate-context tstate)
				       "unknown operand" expr))))
d768 1
a768 3
		 (context-error (tstate-context tstate)
				"unexpected operand"
				expr)))
d771 1
a771 3
	  (context-error (tstate-context tstate)
			 "unexpected operand"
			 expr)))
d985 10
@


1.7
log
@	* hardware.scm (<keyword>): Rename member print-name -> enum-prefix.
	Rename member prefix -> name-prefix.
	(<keyword> getters): Update.
	(-keyword-parse): Update.  Default enum-prefix to NAME-.
	(-keyword-read): Update.  Don't compute default value for
	enum-prefix here.
	(define-keyword): Update.
	(-hw-parse-keyword): Pass "UNUSED" for enum-prefix to -keyword-parse.
	* read.scm (cgen-rtl-version): New function.
	(-supported-rtl-versions): Add (0 8).
	* desc-cpu.scm (-gen-hw-decl): Remove cruft.
	* desc.scm (<keyword> gen-defn): prefix -> name-prefix.
	* gas-test.scm (<keyword> test-data): prefix -> name-prefix.
	* cpu/arm.cpu (gr-names, shift-type): Call define-rtl-version.
	Update, print-name -> enum-prefix, make uppercase.
	Remove unnecessary name-prefix spec.
	* cpu/fr30.cpu (gr-names, cr-names, dr-names): Ditto.
	* cpu/ip2k.cpu (register-names): Ditto.
	* cpu/m68k.cpu (dr-names, ar-names): Ditto.
	* cpu/sparc.cpu (gr-names): Ditto.
	* cpu/xc16x.cpu (gr-names, ext-names,psw-names): Ditto.
	(grb-names, conditioncode-names, extconditioncode-names): Ditto.
	(grb8-names, r8-names, regmem8-names, regdiv8-names): Ditto.
	(reg0-name, reg0-name1, regbmem8-names, memgr8-names): Ditto.
	* cpu/ia32.cpu (gr8-names, gr16-names, gr-names): Call
	define-rtl-version.  Update, print-name -> enum-prefix, make uppercase,
	prefix -> name-prefix.
	* cpu/sh64-compact.cpu (frc-names): Call define-rtl-version.
	Update, print-name -> enum-prefix, make uppercase.
	(drc-names, xf-names): Ditto.
	* cpu/xstormy16.cpu (gr-names, gr-Rb-names): Ditto.
	* doc/rtl.texi (Keywords): New section.
	(hardware indices): Update text.
	(rtl versions): Add 0.8.
@
text
@d943 1
a943 1
; Create a copy of STATE with a new environment ENV.
d945 2
a946 2
(define (estate-new-env state env)
  (let ((result (estate-copy state)))
d951 1
a951 1
; Create a copy of STATE with environment ENV pushed onto the existing
d956 2
a957 2
(define (estate-push-env state env)
  (let ((result (estate-copy state)))
d962 1
a962 1
; Create a copy of STATE with modifiers MODS.
d964 10
a973 2
(define (estate-with-modifiers state mods)
  (let ((result (estate-copy state)))
@


1.6
log
@	Clean up cpu file parsing, pass context consistently instead of the
	old "errtxt" argument.
	NOTE: ACU == "All Callers Updated".
	* attr.scm (-parse-simple-attribute): Renamed from
	parse-simple-attribute, ACU.
	(-attr-parse): Change errtxt argument to context, ACU.
	(-attr-read): Ditto.
	(atlist-parse): Ditto.  Put context arg first.
	(attr-parse): Use parse-error instead of context-error.
	* enum.scm (parse-enum-vals): Change errtxt argument to context, ACU.
	(-enum-parse-prefix, -enum-parse, -enum-read): Ditto.
	* hardware.scm (-keyword-parse): Renamed from keyword-parse.
	`context' arg is now a <context> object.  ACU.
	(-keyword-read): `context' arg is now a <context> object.  ACU.
	(-hw-parse-indices): Change errtxt argument to context, ACU.
	(-hw-parse-values, -hw-parse-handlers): Ditto.
	(-hw-parse-getter, -hw-parse-setter, -hw-parse, -hw-read): Ditto.
	(-hw-validate-layout, -hw-create-getter-from-layout,
	-hw-create-setter-from-layout): Ditto.
	(<hw-register>:parse!, <hw-pc>:parse!): Ditto.
	(<hw-memory>:parse!, <hw-immediate>:parse!): Ditto.
	(<hw-address>:parse!): Ditto.
	* ifield.scm (-ifield-parse, ifield-read): Ditto.
	(-ifld-parse-follows, -ifld-parse-encode-decode): Ditto.
	(-ifld-parse-encode, -ifld-parse-decode): Ditto.
	(-multi-ifield-parse, -multi-ifield-read): Ditto.
	* insn.scm (-insn-parse, -insn-read): Ditto.
	(parse-syntax): Ditto.  Put context arg first.
	(-parse-insn-format-symbol): Change errtxt argument to context, ACU.
	(-parse-insn-format-ifield-spec, -parse-insn-format-list): Ditto.
	(-parse-insn-format): Ditto.
	* mach.scm (-arch-parse-alignment, -arch-parse-machs): Ditto.
	(-arch-parse-isas): Ditto.
	(-isa-read): Add context arg, ACU.
	(-cpu-parse, -cpu-read, -mach-read): Ditto.
	* minsn.scm (-minsn-parse-expansion): Change errtxt argument to
	context, ACU.
	(-minsn-parse, -minsn-read, -minsn-compute-iflds): Ditto.
	(minsn-make-alias): Ditto.
	* mode.scm (-mode-parse): Ditto.
	(parse-mode-name): Ditto.  Put context arg first.
	* model.scm (-prefetch-parse, -retire-parse, -pipeline-parse): Change
	errtxt argument to context, ACU.
	(-unit-parse, -model-parse, -model-read): Ditto.
	* operand.scm (-operand-parse-getter): Use parse-error instead of
	context-error.
	(-operand-parse-setter): Ditto.
	(-operand-parse): Change errtxt argument to context, ACU.
	(-operand-read, -derived-operand-parse, -derived-operand-read): Ditto.
	(-anyof-operand-parse, -anyof-operand-read): Ditto.
	* read.scm (reader-error): Delete.  Use parse-error instead.
	(parse-error): Change errtxt argument to context, ACU.  Split args
	argument into expr and maybe-help-text.
	(-reader-process-expanded-1!): Reorganize.
	* rtl.scm (-subr-read): Change errtxt argument to context, ACU.
	* types.scm (parse-type): Ditto.
	* utils-cgen.scm (single-location->simple-string): New function.
	(<context>): Replace members file,lineno with location.
	(make-prefix-context): Renamed from context-make-prefix, ACU.
	(make-current-context): New function.
	(context-append, context-append-name): New functions.
	(context-make-reader): Delete.
	(parse-name): Change errtxt argument to context, ACU.
	Put context arg first.
	(parse-comment): Ditto.
	(parse-number): Change errtxt argument to context, ACU.
	(arg-list-validate-name, arg-list-check-no-args,
	arg-list-symbol-arg): Ditto.

	* read.scm (-cmd-if): Don't assume test is a list.

	* html.scm (get-insn-properties): Delete errtxt, unused.
@
text
@d752 2
@


1.5
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d178 4
a181 3
;  (parse-error context (string-append errmsg ", operand number "
;				      (number->string op-num))
;	       (rtx-dump expr))
d382 1
a382 1
;  (cons val ; (atlist-source-form (atlist-parse val "" "with-attr"))
@


1.4
log
@	* semantics.scm (semantic-compile): Change arg sem-code-list to
	sem-code.
	(semantic-attrs): Ditto.
	* iformat.scm (ifmt-analyze): Update.
	(ifmt-compute!): Update.
	* rtl-traverse.scm (-compile-expr-fn, rtx-compile): Move to
	rtl-xform.scm.
	(-rtx-trim-args, -rtx-trim-for-doc, rtx-trim-for-doc): Ditto.
	* rtl.scm (-rtx-canonicalize-expr, rtx-canonicalize): Ditto.
	* semantics.scm (rtx-simplify): Ditto.
	(rtx-const-equal, rtx-const-list-equal): Ditto, and make local.
	(rtx-simplify-eq-attr-mach, rtx-simplify-eq-attr-insn): Ditto.
	(-simplify-expr-fn): Move to rtl-xform.scm.
	(-solve-expr-fn, rtx-solve): Ditto.
	* rtl-xform.c: New file.
	* read.scm: Load it.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2001 Red Hat, Inc.
@


1.3
log
@	* rtl-traverse.scm (-rtx-traverse-expr): Tweak comments.
	(-rtx-traverse, rtx-traverse): Ditto.
@
text
@d471 1
d590 1
d623 1
a623 1
; Traverse an expression.
d678 3
a688 3
; EXPECTED is one of `-rtx-valid-types' and indicates the expected rtx type
; or #f if it doesn't matter.
;
a816 33

; Convert rtl expression EXPR from source form to compiled form.
; The expression is validated and rtx macros are expanded as well.
; CONTEXT is a <context> object or #f if there is none.
; It is used in error messages.
; EXTRA-VARS-ALIST is an association list of extra (symbol <mode> value)
; elements to be used during value lookup.
;
; This does the same operation that rtx-traverse does, except that it provides
; a standard value for EXPR-FN.
;
; ??? In the future the compiled form may be the same as the source form
; except that all elements would be converted to their respective objects.

(define (-compile-expr-fn rtx-obj expr mode parent-expr op-pos tstate appstuff)
; (cond 
; The intent of this is to handle sequences/closures, but is it needed?
;  ((rtx-style-syntax? rtx-obj)
;   ((rtx-evaluator rtx-obj) rtx-obj expr mode
;			     parent-expr op-pos tstate))
;  (else
  (cons (car expr) ; rtx-obj
	(-rtx-traverse-operands rtx-obj expr tstate appstuff))
)

(define (rtx-compile context expr extra-vars-alist)
  (-rtx-traverse expr #f 'DFLT #f 0
		 (tstate-make context #f
			      (/fastcall-make -compile-expr-fn)
			      (rtx-env-init-stack1 extra-vars-alist)
			      #f #f nil 0)
		 #f)
)
a1034 131

; RTX trimming (removing fluff not normally needed for the human viewer).

; Subroutine of -rtx-trim-for-doc to simplify it.
; Trim all the arguments of rtx NAME.

(define (-rtx-trim-args name args)
  (let* ((rtx-obj (rtx-lookup name))
	 (arg-types (rtx-arg-types rtx-obj)))

    (let loop ((args args)
	       (types (cddr arg-types)) ; skip options, mode
	       (result nil))

      (if (null? args)

	  (reverse! result)

	  (let ((arg (car args))
		; Remember, types may be an improper list.
		(type (if (pair? types) (car types) types))
		(new-arg (car args)))

	    ;(display arg (current-error-port)) (newline (current-error-port))
	    ;(display type (current-error-port)) (newline (current-error-port))

	    (case type
	      ((OPTIONS)
	       (assert #f)) ; shouldn't get here

	      ((ANYMODE INTMODE FLOATMODE NUMMODE EXPLNUMMODE NONVOIDMODE VOIDMODE DFLTMODE)
	       #f) ; leave arg untouched

	      ((RTX SETRTX TESTRTX)
	       (set! new-arg (-rtx-trim-for-doc arg)))

	      ((CONDRTX)
	       (assert (= (length arg) 2))
	       (if (eq? (car arg) 'else)
		   (set! new-arg (cons 'else (-rtx-trim-for-doc (cadr arg))))
		   (set! new-arg (list (-rtx-trim-for-doc (car arg))
				       (-rtx-trim-for-doc (cadr arg)))))
	       )

	      ((CASERTX)
	       (assert (= (length arg) 2))
	       (set! new-arg (list (car arg) (-rtx-trim-for-doc (cadr arg))))
	       )

	      ((LOCALS)
	       #f) ; leave arg untouched

	      ((ENV)
	       #f) ; leave arg untouched for now

	      ((ATTRS)
	       #f) ; leave arg untouched for now

	      ((SYMBOL STRING NUMBER SYMORNUM)
	       #f) ; leave arg untouched

	      ((OBJECT)
	       (assert #f)) ; hopefully(wip!) shouldn't get here

	      (else
	       (assert #f))) ; unknown arg type

	    (loop (cdr args)
		  (if (pair? types) (cdr types) types)
		  (cons new-arg result))))))
)

; Given a fully specified rtx expression, usually the result of rtx-simplify,
; remove bits unnecessary for documentation purposes.
; rtx-simplify adds a lot of verbosity because in the process of
; simplifying the rtl it produces fully-specified rtl.
; Examples of things to remove: empty options list, DFLT mode.
;
; NOTE: While having to trim the result of rtx-simplify may seem ironical,
; it isn't.  You need to keep separate the notions of simplifying "1+1" to "2"
; and trimming the clutter from "(const () BI 0)" yielding "0".

(define (-rtx-trim-for-doc rtx)
  (if (pair? rtx) ; ??? cheap rtx?
      (let ((name (car rtx))
	    (options (cadr rtx))
	    (mode (caddr rtx))
	    (rest (cdddr rtx)))

	(case name

	  ((const) (car rest))

	  ((ifield operand local)
	   (if (null? options)
	       (if (eq? mode 'DFLT)
		   (car rest)
		   (cons name (cons mode rest)))
	       rtx))

	  ((sequence parallel)
	   ; No special support is needed, except it's nice to remove nop
	   ; statements.  These can be created when an `if' get simplified.
	   (let ((trimmed-args (-rtx-trim-args name rest))
		 (result nil))
	     (for-each (lambda (rtx)
			 (if (equal? rtx '(nop))
			     #f ; ignore
			     (set! result (cons rtx result))))
		       trimmed-args)
	     (if (null? options)
		 (if (eq? mode 'DFLT)
		     (cons name (reverse result))
		     (cons name (cons mode (reverse result))))
		 (cons name (cons options (cons mode (reverse result)))))))

	  (else
	   (let ((trimmed-args (-rtx-trim-args name rest)))
	     (if (null? options)
		 (if (eq? mode 'DFLT)
		     (cons name trimmed-args)
		     (cons name (cons mode trimmed-args)))
		 (cons name (cons options (cons mode trimmed-args))))))))

      ; Not an rtx expression, must be number, symbol, string.
      rtx)
)

(define (rtx-trim-for-doc rtx)
  (-rtx-trim-for-doc rtx)
)
@


1.2
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@d622 17
d641 6
a646 4
; If EXPR-FN wants to just scan the operands, rather than evaluating them,
; one thing it can do is call back to rtx-traverse-operands.
; If EXPR-FN returns #f, traverse the operands normally and return
; (rtx's-name traversed-operand1 ...).
d648 1
a648 1
; required to do this if EXPR-FN returns #f.
d670 3
a672 2
; The result is the result of the lambda EXPR-FN looks up in the case of
; expressions or an operand object (usually <operand>) in the case of operands.
d771 1
a771 1
; See tstate-make for an explanation of EXPR-FN.
@


1.2.6.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2001, 2009 Red Hat, Inc.
@


1.1
log
@	* mach.scm (current-*-add!): Disallow redefinition.  Make result
	"unspecified".
	* insn.scm (insn-builtin!): Don't define relaxable here, now defined in
	operand.scm.
	* operand.scm (operand-builtin!): Define RELAXABLE for insns too.
	* cpu/m32r.cpu (disp8,disp24): RELAX renamed to RELAXABLE.

	* gen-all-doc: Split arm and frv docs up a bit.

	* cpu/arm.cpu: Add IDOC attribute.
	* cpu/frv.cpu: Ditto.
	* cpu/i960.cpu: Ditto.
	* cpu/openrisc.cpu: Ditto.
	* cpu/xstormy16.cpu: Ditto.
	* cpu/m32r.cpu: Ditto.
	(all insns): Explicitly specify IDOC attribute.

	* Makefile.am (MACH,ISAS,INSN_FILE_NAME): New vars.
	(desc,opcodes,sim-arch,sim-cpu,gas-test,sim-test): Use MACH,ISAS.
	(html): Use MACH,ISAS,INSN_FILE_NAME.  Generate insn.html separately.
	* Makefile.in: Regenerate.
	* attr.scm (<integer-attribute>:parse-value-def): Implement.
	(-attr-read): Defer computing default value until we know the type.
	(attr-has-attr?): Delete, move contents to <attr-list>:has-attr?.
	(<attr-list>:attr-present?): New method.
	(atlist-attr-present?,obj-attr-present?): New fns.
	(obj-has-attr-value?,obj-has-attr-value-no-default?): New fns.
	(attr-builtin!): New insn attr IDOC.
	* cgen-doc.scm (doc-arguments): New args -I,-N.
	* enum.scm (parse-enum-vals): New arg errtxt, all callers updated.
	Support comment as fourth element of enum value.
	(enum-val-name,enum-val-value,enum-val-attrs,enum-val-comment): New fns.
	* html.scm (gen-html-header): New arg kind, all callers updated.
	(gen-table-of-contents): New arg insn-file, all callers updated.
	(gen-list-entry,gen-doc-header): New fn.
	(get-operands): Delete.
	(gen-iformat-table): Rewrite.
	(gen-insn-doc-1): Print constant-folded and trimmed semantics.
	(gen-insn-doc-list): New args name, comment, insns.  All callers updated.
	(get-insn-properties,guess-insn-idoc-attr!): New fn.
	(insn-sets-pc?,insn-refs-mem?,insn-uses-fpu?): New fns.
	(get-insns-for-category,gen-categories-insn-lists): New fns.
	(gen-insn-docs): Simplify each insn's semantics first.
	Print insn tables sorted by IDOC categories.
	(*insn-html-file-name*): New global.
	(cgen-insn.html): New fn.
	(cgen-all): Update.
	* insn.scm (<insn>): Create a setter for the `tmp' member.
	* semantics.scm (insn-build-known-values): Renamed from
	-build-known-values.  All callers updated.

	* rtl.scm: Move traveral/evaluation support to ...
	* rtl-traverse.scm: New file.
	* read.scm: Maybe-load rtl-traverse.scm.

	* rtl.scm (-rtx-valid-types): Add SETRTX.

	* rtx-funcs.scm (nop,parallel): Fix mode.

	* utils.scm (eqv-lookup-index): New fn.
	(assq-lookup-index): Renamed from lookup-index.  All callers updated.

	* dev.scm (load-doc): Set APPLICATION.
@
text
@d575 1
a575 1
       (char=? (string-ref x 0) #\:))
d779 1
a779 1
     (display (string-append "rtx=" (obj:name rtx-obj)))
@

