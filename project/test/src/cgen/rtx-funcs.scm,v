head	1.21;
access;
symbols
	sid-snapshot-20180601:1.21
	cgen-snapshot-20180601:1.21
	sid-snapshot-20180501:1.21
	cgen-snapshot-20180501:1.21
	sid-snapshot-20180401:1.21
	cgen-snapshot-20180401:1.21
	sid-snapshot-20180301:1.21
	cgen-snapshot-20180301:1.21
	sid-snapshot-20180201:1.21
	cgen-snapshot-20180201:1.21
	sid-snapshot-20180101:1.21
	cgen-snapshot-20180101:1.21
	sid-snapshot-20171201:1.21
	cgen-snapshot-20171201:1.21
	sid-snapshot-20171101:1.21
	cgen-snapshot-20171101:1.21
	sid-snapshot-20171001:1.21
	cgen-snapshot-20171001:1.21
	sid-snapshot-20170901:1.21
	cgen-snapshot-20170901:1.21
	sid-snapshot-20170801:1.21
	cgen-snapshot-20170801:1.21
	sid-snapshot-20170701:1.21
	cgen-snapshot-20170701:1.21
	sid-snapshot-20170601:1.21
	cgen-snapshot-20170601:1.21
	sid-snapshot-20170501:1.21
	cgen-snapshot-20170501:1.21
	sid-snapshot-20170401:1.21
	cgen-snapshot-20170401:1.21
	sid-snapshot-20170301:1.21
	cgen-snapshot-20170301:1.21
	sid-snapshot-20170201:1.21
	cgen-snapshot-20170201:1.21
	sid-snapshot-20170101:1.21
	cgen-snapshot-20170101:1.21
	sid-snapshot-20161201:1.21
	cgen-snapshot-20161201:1.21
	sid-snapshot-20161101:1.21
	cgen-snapshot-20161101:1.21
	sid-snapshot-20160901:1.21
	cgen-snapshot-20160901:1.21
	sid-snapshot-20160801:1.21
	cgen-snapshot-20160801:1.21
	sid-snapshot-20160701:1.21
	cgen-snapshot-20160701:1.21
	sid-snapshot-20160601:1.21
	cgen-snapshot-20160601:1.21
	sid-snapshot-20160501:1.21
	cgen-snapshot-20160501:1.21
	sid-snapshot-20160401:1.21
	cgen-snapshot-20160401:1.21
	sid-snapshot-20160301:1.21
	cgen-snapshot-20160301:1.21
	sid-snapshot-20160201:1.21
	cgen-snapshot-20160201:1.21
	sid-snapshot-20160101:1.21
	cgen-snapshot-20160101:1.21
	sid-snapshot-20151201:1.21
	cgen-snapshot-20151201:1.21
	sid-snapshot-20151101:1.21
	cgen-snapshot-20151101:1.21
	sid-snapshot-20151001:1.21
	cgen-snapshot-20151001:1.21
	sid-snapshot-20150901:1.21
	cgen-snapshot-20150901:1.21
	sid-snapshot-20150801:1.21
	cgen-snapshot-20150801:1.21
	sid-snapshot-20150701:1.21
	cgen-snapshot-20150701:1.21
	sid-snapshot-20150601:1.21
	cgen-snapshot-20150601:1.21
	sid-snapshot-20150501:1.21
	cgen-snapshot-20150501:1.21
	sid-snapshot-20150401:1.21
	cgen-snapshot-20150401:1.21
	sid-snapshot-20150301:1.21
	cgen-snapshot-20150301:1.21
	sid-snapshot-20150201:1.21
	cgen-snapshot-20150201:1.21
	sid-snapshot-20150101:1.21
	cgen-snapshot-20150101:1.21
	sid-snapshot-20141201:1.21
	cgen-snapshot-20141201:1.21
	sid-snapshot-20141101:1.21
	cgen-snapshot-20141101:1.21
	sid-snapshot-20141001:1.21
	cgen-snapshot-20141001:1.21
	sid-snapshot-20140901:1.21
	cgen-snapshot-20140901:1.21
	sid-snapshot-20140801:1.21
	cgen-snapshot-20140801:1.21
	sid-snapshot-20140701:1.21
	cgen-snapshot-20140701:1.21
	sid-snapshot-20140601:1.21
	cgen-snapshot-20140601:1.21
	sid-snapshot-20140501:1.20
	cgen-snapshot-20140501:1.20
	sid-snapshot-20140401:1.20
	cgen-snapshot-20140401:1.20
	sid-snapshot-20140301:1.20
	cgen-snapshot-20140301:1.20
	sid-snapshot-20140201:1.20
	cgen-snapshot-20140201:1.20
	sid-snapshot-20140101:1.20
	cgen-snapshot-20140101:1.20
	sid-snapshot-20131201:1.20
	cgen-snapshot-20131201:1.20
	sid-snapshot-20131101:1.20
	cgen-snapshot-20131101:1.20
	sid-snapshot-20131001:1.20
	cgen-snapshot-20131001:1.20
	sid-snapshot-20130901:1.20
	cgen-snapshot-20130901:1.20
	sid-snapshot-20130801:1.20
	cgen-snapshot-20130801:1.20
	sid-snapshot-20130701:1.20
	cgen-snapshot-20130701:1.20
	sid-snapshot-20130601:1.20
	cgen-snapshot-20130601:1.20
	sid-snapshot-20130501:1.20
	cgen-snapshot-20130501:1.20
	sid-snapshot-20130401:1.20
	cgen-snapshot-20130401:1.20
	sid-snapshot-20130301:1.20
	cgen-snapshot-20130301:1.20
	sid-snapshot-20130201:1.20
	cgen-snapshot-20130201:1.20
	sid-snapshot-20130101:1.20
	cgen-snapshot-20130101:1.20
	sid-snapshot-20121201:1.20
	cgen-snapshot-20121201:1.20
	sid-snapshot-20121101:1.20
	cgen-snapshot-20121101:1.20
	sid-snapshot-20121001:1.20
	cgen-snapshot-20121001:1.20
	sid-snapshot-20120901:1.20
	cgen-snapshot-20120901:1.20
	sid-snapshot-20120801:1.20
	cgen-snapshot-20120801:1.20
	sid-snapshot-20120701:1.20
	cgen-snapshot-20120701:1.20
	sid-snapshot-20120601:1.20
	cgen-snapshot-20120601:1.20
	sid-snapshot-20120501:1.20
	cgen-snapshot-20120501:1.20
	sid-snapshot-20120401:1.20
	cgen-snapshot-20120401:1.20
	sid-snapshot-20120301:1.20
	cgen-snapshot-20120301:1.20
	sid-snapshot-20120201:1.20
	cgen-snapshot-20120201:1.20
	sid-snapshot-20120101:1.20
	cgen-snapshot-20120101:1.20
	sid-snapshot-20111201:1.20
	cgen-snapshot-20111201:1.20
	sid-snapshot-20111101:1.20
	cgen-snapshot-20111101:1.20
	sid-snapshot-20111001:1.20
	cgen-snapshot-20111001:1.20
	sid-snapshot-20110901:1.20
	cgen-snapshot-20110901:1.20
	sid-snapshot-20110801:1.20
	cgen-snapshot-20110801:1.20
	sid-snapshot-20110701:1.20
	cgen-snapshot-20110701:1.20
	sid-snapshot-20110601:1.20
	cgen-snapshot-20110601:1.20
	sid-snapshot-20110501:1.20
	cgen-snapshot-20110501:1.20
	sid-snapshot-20110401:1.20
	cgen-snapshot-20110401:1.20
	sid-snapshot-20110301:1.20
	cgen-snapshot-20110301:1.20
	sid-snapshot-20110201:1.20
	cgen-snapshot-20110201:1.20
	sid-snapshot-20110101:1.20
	cgen-snapshot-20110101:1.20
	sid-snapshot-20101201:1.20
	cgen-snapshot-20101201:1.20
	sid-snapshot-20101101:1.20
	cgen-snapshot-20101101:1.20
	sid-snapshot-20101001:1.20
	cgen-snapshot-20101001:1.20
	sid-snapshot-20100901:1.20
	cgen-snapshot-20100901:1.20
	sid-snapshot-20100801:1.20
	cgen-snapshot-20100801:1.20
	sid-snapshot-20100701:1.20
	cgen-snapshot-20100701:1.20
	sid-snapshot-20100601:1.20
	cgen-snapshot-20100601:1.20
	sid-snapshot-20100501:1.20
	cgen-snapshot-20100501:1.20
	sid-snapshot-20100401:1.20
	cgen-snapshot-20100401:1.20
	sid-snapshot-20100301:1.20
	cgen-snapshot-20100301:1.20
	sid-snapshot-20100201:1.20
	cgen-snapshot-20100201:1.20
	sid-snapshot-20100101:1.17
	cgen-snapshot-20100101:1.17
	sid-snapshot-20091201:1.17
	cgen-snapshot-20091201:1.17
	sid-snapshot-20091101:1.14
	cgen-snapshot-20091101:1.14
	sid-snapshot-20091001:1.14
	cgen-snapshot-20091001:1.14
	arc-sim-20090309:1.4
	sid-snapshot-20090901:1.10
	cgen-snapshot-20090901:1.10
	sid-snapshot-20090801:1.6
	cgen-snapshot-20090801:1.6
	sid-snapshot-20090701:1.5
	cgen-snapshot-20090701:1.5
	dje-cgen-play1-branch:1.5.0.2
	dje-cgen-play1-branchpoint:1.5
	cgen-1_1-branch:1.4.0.6
	cgen-1_1-branchpoint:1.4
	sid-snapshot-20090601:1.4
	cgen-snapshot-20090601:1.4
	sid-snapshot-20090501:1.4
	cgen-snapshot-20090501:1.4
	sid-snapshot-20090401:1.4
	cgen-snapshot-20090401:1.4
	arc-insight_6_8-branch:1.4.0.4
	arc-insight_6_8-branchpoint:1.4
	sid-snapshot-20090301:1.4
	cgen-snapshot-20090301:1.4
	sid-snapshot-20090201:1.4
	cgen-snapshot-20090201:1.4
	sid-snapshot-20090101:1.4
	cgen-snapshot-20090101:1.4
	sid-snapshot-20081201:1.4
	cgen-snapshot-20081201:1.4
	sid-snapshot-20081101:1.4
	cgen-snapshot-20081101:1.4
	sid-snapshot-20081001:1.4
	cgen-snapshot-20081001:1.4
	sid-snapshot-20080901:1.4
	cgen-snapshot-20080901:1.4
	sid-snapshot-20080801:1.4
	cgen-snapshot-20080801:1.4
	sid-snapshot-20080701:1.4
	cgen-snapshot-20080701:1.4
	sid-snapshot-20080601:1.4
	cgen-snapshot-20080601:1.4
	sid-snapshot-20080501:1.4
	cgen-snapshot-20080501:1.4
	sid-snapshot-20080403:1.4
	sid-snapshot-20080401:1.4
	cgen-snapshot-20080401:1.4
	sid-snapshot-20080301:1.4
	cgen-snapshot-20080301:1.4
	sid-snapshot-20080201:1.4
	cgen-snapshot-20080201:1.4
	sid-snapshot-20080101:1.4
	cgen-snapshot-20080101:1.4
	sid-snapshot-20071201:1.4
	cgen-snapshot-20071201:1.4
	sid-snapshot-20071101:1.4
	cgen-snapshot-20071101:1.4
	sid-snapshot-20071001:1.4
	cgen-snapshot-20071001:1.4
	msnyder-fork-checkpoint-branch:1.4.0.2
	msnyder-fork-checkpoint-branchpoint:1.4
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	cygnus_cvs_20020108_pre:1.2
	cgen-1-1-branch:1.2.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.21
date	2014.05.19.01.24.00;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2010.01.25.03.50.43;	author devans;	state Exp;
branches;
next	1.19;

1.19
date	2010.01.21.07.56.41;	author devans;	state Exp;
branches;
next	1.18;

1.18
date	2010.01.21.07.34.56;	author devans;	state Exp;
branches;
next	1.17;

1.17
date	2009.11.05.16.55.33;	author devans;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.05.16.53.40;	author devans;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.03.16.24.02;	author devans;	state Exp;
branches;
next	1.14;

1.14
date	2009.09.30.06.21.06;	author devans;	state Exp;
branches;
next	1.13;

1.13
date	2009.09.23.22.30.19;	author devans;	state Exp;
branches;
next	1.12;

1.12
date	2009.09.23.17.19.24;	author devans;	state Exp;
branches;
next	1.11;

1.11
date	2009.09.12.17.34.15;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2009.08.28.06.20.28;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2009.08.27.21.28.48;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2009.08.27.05.47.12;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2009.08.27.04.22.56;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	2009.07.19.19.19.42;	author devans;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.10.21.22.03;	author devans;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	2003.06.04.20.22.49;	author devans;	state Exp;
branches;
next	1.2;

1.2
date	2000.11.09.18.09.35;	author devans;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.4.6.1
date	2009.06.24.14.57.46;	author devans;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.21
log
@or1k support
        * sim-arch.scm (WI, UWI, AI, IAI): Define.
        * rtl-c.scm (mul-o1flag, mul-o2flag, rem): New.
        * rtx-funcs.scn (mul-o1flag, mul-o2flag, rem): New.
@
text
@; Standard RTL functions.
; Copyright (C) 2000, 2009, 2010, 2014 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.

; THIS FILE CONTAINS ONE BIG FUNCTION: def-rtx-funcs.
;
; It is ok for this file to use procs "internal" to rtl.scm.
;
; Each rtx functions has two leading operands: &options, &mode;
; though `&mode' may be spelled differently.
; The "&" prefix is to indicate that the parsing of these operands is handled
; differently.  They are optional and are written with leading colons
; (e.g. :SI).  The leading ":" is to help the parser - all leading optional
; operands begin with ":".  The order of the arguments is &options then &mode
; though there is no imposed order in written RTL.

(define (def-rtx-funcs)

; Do not change the indentation here.
(let
(
 ; These are defined in rtl.scm.
 (drn define-rtx-node)
 (drsn define-rtx-syntax-node)
 (dron define-rtx-operand-node)
 (drmn define-rtx-macro-node)
)

; The reason for the odd indenting above is so that emacs begins indenting the
; following code at column 1.

; Error reporting.
; MODE is present for use in situations like non-VOID mode cond's.
; The code will expect the mode to be compatible even though `error'
; "doesn't return".  A small concession for simpler code.

(drn (error &options &mode message)
     #f
     (OPTIONS VOIDORNUMMODE STRING) (NA NA NA)
     MISC
     (estate-error *estate* "error in rtl" message)
)

; Enums
; Default mode is INT.

(drn (enum &options &mode enum-name)
     #f
     (OPTIONS ANYINTMODE SYMBOL) (NA NA NA) ;; ??? s/SYMBOL/ENUM-NAME/ ?
     ARG
     ;; When computing a value, return the enum's value.
     ;; Canonicalization should have already caught bad values.
     (car (enum-lookup-val enum-name))
)

; Instruction fields
; These are used in the encode/decode specs of other ifields as well as in
; instruction semantics.
; Ifields are normally specified by name, but they are subsequently wrapped
; in this.

(dron (ifield &options &mode ifld-name)
      #f
      (OPTIONS ANYNUMMODE SYMBOL) (NA NA NA) ;; ??? s/SYMBOL/IFIELD-NAME/ ?
      ARG
      (let ((f (current-ifld-lookup ifld-name)))
	(make <operand> (obj-location f)
	      ifld-name (string-append ifld-name " used as operand")
	      (atlist-cons (bool-attr-make 'SEM-ONLY #t)
			   (obj-atlist f))
	      (obj:name (ifld-hw-type f))
	      (obj:name (ifld-mode f))
	      (make <hw-index> 'anonymous 'ifield (ifld-mode f) f)
	      nil #f #f))
)

; Specify an operand.
; Operands are normally specified by name, but they are subsequently wrapped
; in this.

(dron (operand &options &mode op-name)
      #f
      (OPTIONS ANYNUMMODE SYMBOL) (NA NA NA) ;; ??? s/SYMBOL/OPERAND-NAME/ ?
      ARG
      (current-op-lookup op-name)
)

; Operand naming/numbering.
; Operands are given names so that the operands as used in the semantics can
; be matched with arguments of function units.  With good name choices of
; operands and function unit arguments, this is rarely necessary, but
; sometimes it is.
;
; ??? This obfuscates the semantic code a fair bit.  Another way to do this
; would be to add new elements to <insn> to specify operands outside of
; the semantic code.  E.g.
; (define-insn ...
;   (inputs (in-gr1 src1) (in-gr2 src2))
;   (outputs (out-pc pc) (out-gr dr) (reg-14 (reg WI h-gr 14)))
;   ...)
; The intent here is to continue to allow the semantic code to use names
; of operands, and not overly complicate the input/output description.
;
; In instructions, operand numbers are recorded as well, to implement
; profiling and result writeback of parallel insns.

; Rename operand VALUE to NEW-NAME.
; VALUE is an expression whose result is an object of type <operand>.
; It can be the name of an existing operand.
; ??? Might also support numbering by allowing NEW-NAME to be a number.

(drsn (name &options &mode new-name value)
      #f
      (OPTIONS ANYNUMMODE SYMBOL RTX) (NA NA NA ANY)
      ARG
      ;; FIXME: s/DFLT/&mode/ ?
      (let ((result (object-copy (rtx-get 'DFLT value))))
	(op:set-sem-name! result new-name)
	result)
)

; Operands are generally compiled to an internal form first.
; There is a fair bit of state associated with them, and it's easier to
; work with an object than source [which might get fairly complicated if
; it expresses all the state].
; Compiled operands are wrapped in this so that they still look like rtx.

(dron (xop &options &mode object)
      #f
      (OPTIONS ANYNUMMODE OBJECT) (NA NA NA) ;; ??? s/OBJECT/OPERAND/ ?
      ARG
      object
)

;(dron (opspec: &options &mode op-name op-num hw-ref attrs)
;      (OPTIONS ANYNUMMODE SYMBOL NUMBER RTX ATTRS) (NA NA NA NA ANY NA)
;      ARG
;      (let ((opval (rtx-eval-with-estate hw-ref (mode:lookup &mode) *estate*)))
;	(assert (operand? opval))
;	; Set the specified mode, ensuring it's ok.
;	; This also makes a copy as we don't want to modify predefined
;	; operands.
;	(let ((operand (op:new-mode opval mode)))
;	  (op:set-sem-name! operand op-name)
;	  (op:set-num! operand op-num)
;	  (op:set-cond?! operand (attr-value attrs 'COND-REF #f))
;	  operand))
;)

; Specify a reference to a local variable.
; Local variables are normally specified by name, but they are subsequently
; wrapped in this.

(dron (local &options &mode local-name)
      #f
      (OPTIONS ANYNUMMODE SYMBOL) (NA NA NA) ;; ??? s/SYMBOL/LOCAL-NAME/ ?
      ARG
      (rtx-temp-lookup (tstate-env *tstate*) local-name)
)

; FIXME: This doesn't work.  See s-operand.
;(define (s-dup estate op-name)
;  (if (not (insn? (estate-owner estate)))
;      (error "dup: not processing an insn"))
;  (vector-ref (insn:operands (current-current-context))
;	       (op:lookup-num (insn:operands (estate-owner estate)) op-name))
;)
;
; ??? Since operands are given names and not numbers this isn't currently used.
;
;(drsn (dup &options &mode op-name)
;     #f
;     (OPTIONS ANYNUMMODE SYMBOL) (NA NA NA)
;     ;(s-dup *estate* op-name)
;     (begin
;       (if (not (insn? (estate-owner *estate*)))
;	   (error "dup: not processing an insn"))
;       (vector-ref (insn:operands (estate-owner *estate*))
;		   (op:lookup-num (insn:operands (estate-owner *estate*)) op-name)))
;     #f
;)

; Returns non-zero if operand NAME was referenced (read if input operand
; and written if output operand).
; ??? What about input/output operands.

(drsn (ref &options &mode name)
      BI
      (OPTIONS BIMODE SYMBOL) (NA NA NA) ;; ??? s/SYMBOL/OPERAND-NAME/ ?
      ARG
      #f
)

; Return the index of an operand.
; For registers this is the register number.
; ??? Mode handling incomplete, this doesn't handle mem, which it could.
; Until then we fix the mode of the result to INT.

(dron (index-of &options &mode op-rtx)
      INT
      (OPTIONS INTMODE RTX) (NA NA ANY)
      ARG
      ;; FIXME: s/DFLT/&mode/ ?
      (let* ((operand (rtx-eval-with-estate op-rtx DFLT *estate*))
	     (f (hw-index:value (op:index operand)))
	     (f-name (obj:name f)))
	(make <operand> (if (source-ident? f) (obj-location f) #f)
	      f-name f-name
	      (atlist-cons (bool-attr-make 'SEM-ONLY #t)
			   (obj-atlist f))
	      (obj:name (ifld-hw-type f))
	      (obj:name (ifld-mode f))
	      (make <hw-index> 'anonymous
		    'ifield
		    (ifld-mode f)
		    ; (send (op:type op) 'get-index-mode)
		    f)
	      nil #f #f))
)

; Same as index-of, but improves readability for registers.

(drmn (regno reg)
      (list 'index-of reg)
)

; Hardware elements.

; Describe a random hardware object.
; If INDX is missing, assume the element is a scalar.  We pass 0 so s-hw
; doesn't have to unpack the list that would be passed if it were defined as
; (hw mode hw-name . indx).  This is an internal implementation detail
; and thus harmless to the description language.
; These are implemented as syntax nodes as we must pass INDX to `s-hw'
; unevaluated.
; ??? Not currently supported.  Not sure whether it should be.
;(drsn (hw &options &mode hw-elm . indx-sel)
;      (OPTIONS ANYNUMMODE SYMBOL . RTX) (NA NA NA . INT)
;      ARG
;      (let ((indx (if (pair? indx-sel) (car indx-sel) 0))
;            (selector (if (and (pair? indx-sel) (pair? (cdr indx-sel)))
;                          (cadr indx-sel)
;                          hw-selector-default))))
;      (s-hw *estate* mode hw-elm indx selector)
;)

; Register accesses.
; INDX-SEL is an optional index and possible selector.
(dron (reg &options &mode hw-elm . indx-sel)
      #f
      (OPTIONS ANYNUMMODE SYMBOL . RTX) (NA NA NA . INT) ;; ??? s/SYMBOL/HW-NAME/ ?
      ARG
      (let ((indx (if (pair? indx-sel) (car indx-sel) 0))
	    (selector (if (and (pair? indx-sel) (pair? (cdr indx-sel)))
			  (cadr indx-sel)
			  hw-selector-default)))
	(s-hw *estate* mode hw-elm indx selector))	    
)

; A raw-reg bypasses the getter/setter stuff.  It's usually used in
; getter/setter definitions.

(dron (raw-reg &options &mode hw-elm . indx-sel)
      #f
      (OPTIONS ANYNUMMODE SYMBOL . RTX) (NA NA NA . INT) ;; ??? s/SYMBOL/HW-NAME/ ?
      ARG
      (let ((indx (if (pair? indx-sel) (car indx-sel) 0))
	    (selector (if (and (pair? indx-sel) (pair? (cdr indx-sel)))
			  (cadr indx-sel)
			  hw-selector-default)))
	(let ((result (s-hw *estate* mode hw-elm indx selector)))
	  (obj-cons-attr! result (bool-attr-make 'RAW #t))
	  result))
)

; Memory accesses.
(dron (mem &options &mode addr . sel)
      #f
      (OPTIONS EXPLNUMMODE RTX . RTX) (NA NA AI . INT)
      ARG
      (s-hw *estate* mode 'h-memory addr
	    (if (pair? sel) (car sel) hw-selector-default))
)

; Instruction execution support.
; There are no jumps, per se.  A jump is a set of `pc'.

; The program counter.
; ??? Hmmm... needed?  The pc is usually specified as `pc' which is shorthand
; for (operand pc).
;(dron (pc) () () ARG s-pc)

; Fetch bytes from the instruction stream of size MODE.
; FIXME: Later need to augment this by passing an indicator to the mem-fetch
; routines that we're doing an ifetch.
; ??? wip!

(drmn (ifetch mode pc)
      (list 'mem mode pc) ; hw-selector-ispace
)

; NUM is the instruction number.  Generally it is zero but if more than one
; insn is decoded at a time, it is non-zero.  This is used, for example, to
; index into the scache [as an offset from the first insn].
; ??? wip!

(drmn (decode mode pc insn num)
      (list 'c-call mode 'EXTRACT pc insn num)
)

; NUM is the same number passed to `decode'.
; ??? wip!

(drmn (execute mode num)
      (list 'c-call mode 'EXECUTE num)
)

; Control Transfer Instructions

; Sets of pc are handled like other sets so there are no branch rtx's.

; Indicate there are N delay slots in the processing of RTX.
; N is a `const' node.
; The mode of the result is the mode of RTX.
; ??? wip!

(drn (delay &options &mode n rtx)
     #f
     (OPTIONS VOIDORNUMMODE RTX RTX) (NA NA INT MATCHEXPR)
     MISC
     #f ; (s-sequence *estate* VOID '() rtx) ; wip!
)

; Annul the following insn if YES? is non-zero.
; PC is the address of the annuling insn.
; The target is required to define SEM_ANNUL_INSN.
; ??? wip!

(drmn (annul yes?)
      ; The pc reference here is hidden in c-code to not generate a spurious
      ; pc input operand.
      (list 'c-call 'VOID "SEM_ANNUL_INSN" (list 'c-code 'IAI "pc") yes?)
)

; Skip the following insn if YES? is non-zero.
; The target is required to define SEM_SKIP_INSN.
; ??? This is similar to annul.  Deletion of one of them defered.
; ??? wip!

(drn (skip &options &mode yes?)
     VOID
     (OPTIONS VOIDMODE RTX) (NA NA INT)
     MISC
     #f
)

; Attribute support.

; Return a boolean indicating if attribute named ATTR is VALUE in OWNER.
; If VALUE is a list, return "true" if ATTR is any of the listed values.
; ??? Don't yet support !VALUE.
; OWNER is the result of either (current-insn) or (current-mach)
; [note that canonicalization will turn them into
; (current-{insn,mach} () DFLT)].
; The result is always of mode BI.
; FIXME: wip
;
; This is a syntax node so the args are not pre-evaluated.
; We just want the symbols.
; FIXME: Hmmm... it currently isn't a syntax node.

(drn (eq-attr &options &mode owner attr value)
     BI
      (OPTIONS BIMODE RTX SYMBOL SYMORNUM) (NA NA ANY NA NA)
      MISC
      (let ((atval (if owner
		       (obj-attr-value owner attr)
		       (attr-lookup-default attr #f))))
	(if (list? value)
	    (->bool (memq atval value))
	    (eq? atval value)))
)

; Get the value of attribute ATTR-NAME, expressable as an integer.
; OBJ is the result of either (current-insn) or (current-mach).
; Note that canonicalization will turn them into
; (current-{insn,mach} () {INSN,MACH}MODE).
; FIXME:wip
; This uses INTMODE because we can't otherwise determine the
; mode of the result (if elided).

(drn (int-attr &options &mode obj attr-name)
     #f
     (OPTIONS INTMODE RTX SYMBOL) (NA NA ANY NA)
     MISC
     #f
)

;; Deprecated alias for int-attr.

(drmn (attr arg1 . rest)
      (cons 'int-attr (cons arg1 rest))
)

; Same as `quote', for use in attributes cus "quote" sounds too jargonish.
; [Ok, not a strong argument for using "symbol", but so what?]

(drsn (symbol &options &mode name)
      SYM
      (OPTIONS SYMMODE SYMBOL) (NA NA NA)
      ARG
      name
)

; Return the current instruction.

(drn (current-insn &options &mode)
     INSN
     (OPTIONS INSNMODE) (NA NA)
     MISC
     (let ((obj (estate-owner *estate*)))
       (if (not (insn? obj))
	   (error "current context not an insn"))
       obj)
)

; Return the currently selected machine.
; This can either be a compile-time or run-time value.

(drn (current-mach &options &mode)
     MACH
     (OPTIONS MACHMODE) (NA NA)
     MISC
     -rtx-current-mach
)

; Constants.

; FIXME: Need to consider 64 bit hosts.
(drn (const &options &mode c)
     #f
     (OPTIONS ANYNUMMODE NUMBER) (NA NA NA)
     ARG
     ; When computing a value, just return the constant unchanged.
     c
)

; Large mode support.

; Combine smaller modes into a larger one.
; Arguments are specified most significant to least significant.
; ??? Not all of the combinations are supported in the simulator.
; They'll get added as necessary.
(drn (join &options &out-mode in-mode arg1 . arg-rest)
     #f
     (OPTIONS ANYNUMMODE ANYNUMMODE RTX . RTX) (NA NA NA ANY . ANY)
     MISC
     ; FIXME: Ensure correct number of args for in/out modes.
     ; FIXME: Ensure compatible modes.
     #f
)

; GCC's subreg.
; Called subword 'cus it's not exactly subreg.
; Word numbering is word-order dependent.
; Word number 0 is the most significant word if big-endian-words.
; Word number 0 is the least significant word if little-endian-words.
; ??? GCC plans to switch to SUBREG_BYTE.  Keep an eye out for the switch
; (which is extensive so probably won't happen anytime soon).
; MODE is the mode of the result, not operand0.
;
; The mode spec of operand0 use to be MATCHEXPR, but subword is not a normal rtx.
; The mode of operand0 is not necessarily the same as the mode of the result,
; and code which analyzes it would otherwise use the result mode (specified by
; `&mode') for the mode of operand0.

(drn (subword &options &mode value word-num)
     #f
     (OPTIONS ANYNUMMODE RTX RTX) (NA NA ANY INT)
     ARG
     #f
)

; ??? The split and concat stuff is just an experiment and should not be used.
; What's there now is just "thoughts put down on paper."

(drmn (split split-mode in-mode di)
      ; FIXME: Ensure compatible modes
      ;(list 'c-raw-call 'BLK (string-append "SPLIT" in-mode split-mode) di)
      '(const 0)
)

(drmn (concat modes arg1 . arg-rest)
      ; FIXME: Here might be the place to ensure
      ; (= (length modes) (length (cons arg1 arg-rest))).
      ;(cons 'c-raw-call (cons modes (cons "CONCAT" (cons arg1 arg-rest))))
      '(const 0)
)

; Support for explicit C code.
; ??? GCC RTL calls this "unspec" which is arguably a more application
; independent name.

(drn (c-code &options &mode text)
     #f
     (OPTIONS ANYCEXPRMODE STRING) (NA NA NA)
     UNSPEC
     #f
)

; Invoke C functions passing them arguments from the semantic code.
; The arguments are passed as is, no conversion is done here.
; Usage is:
;           (c-call mode name arg1 arg2 ...)
; which is converted into a C function call:
;           name (current_cpu, arg1, arg2, ...)
; MODE is the mode of the result.
; If it is VOID this call is a statement and ';' is appended.
; Otherwise it is part of an expression.

(drn (c-call &options &mode name . args)
     #f
     (OPTIONS ANYCEXPRMODE STRING . RTX) (NA NA NA . ANY)
     UNSPEC
     #f
)

; Same as c-call but without implicit first arg of `current_cpu'.

(drn (c-raw-call &options &mode name . args)
     #f
     (OPTIONS ANYCEXPRMODE STRING . RTX) (NA NA NA . ANY)
     UNSPEC
     #f
)

; Set/get/miscellaneous

(drn (nop &options &mode)
     VOID
     (OPTIONS VOIDMODE) (NA NA)
     MISC
     #f
)

; Clobber - mark an object as modified without explaining why or how.

(drn (clobber &options &mode object)
     VOID
     (OPTIONS VOIDORNUMMODE RTX) (NA NA MATCHEXPR)
     MISC
     #f
)

; The `set' rtx.
; MODE is the mode of DST.  If DFLT, use DST's default mode.
; The mode of the result is always VOID.
;
; ??? It might be more consistent to rename set -> set-trace, but that's
; too wordy.  The `set' rtx is the normal one and we want the normal one to
; be the verbose one (prints result tracing messages).  `set-quiet' is the
; atypical one, it doesn't print tracing messages.  It may also turn out that
; a different mechanism (rather than the name "set-quiet") is used some day.
; One way would be to record the "quietness" state with the traversal state and
; use something like (with-quiet (set foo bar)) akin to with-output-to-string
; in Guile.
;
; i.e. set -> gen-set-trace
;      set-quiet -> gen-set-quiet
;
; ??? One might want a `!' suffix as in `set!', but methinks that's following
; Scheme too closely.

(drn (set &options &mode dst src)
     VOID
     (OPTIONS ANYNUMMODE SETRTX RTX) (NA NA MATCHEXPR MATCH2)
     SET
     #f
)

(drn (set-quiet &options &mode dst src)
     VOID
     (OPTIONS ANYNUMMODE SETRTX RTX) (NA NA MATCHEXPR MATCH2)
     SET
     #f
)

; Standard arithmetic operations.

; It's nice emitting macro calls to the actual C operation in that the RTX
; expression is preserved, albeit in C.  On the one hand it's one extra thing
; the programmer has to know when looking at the code.  But on the other it's
; trivial stuff, and having a layer between RTX and C allows the
; macros/functions to be modified to handle unexpected situations.
; 
; We do emit C directly for cases other than cpu semantics
; (e.g. the assembler).
;
; The language is defined such that we assume ANSI C semantics while avoiding
; implementation defined areas, with as few exceptions as possible.
;
; Current exceptions:
; - signed shift right assumes the sign bit is replicated.
;
; Additional notes [perhaps repeating what's in ANSI C for emphasis]:
; - callers of division and modulus fns must test for 0 beforehand
;   if necessary
; - division and modulus fns have unspecified behavior for negative args
;   [yes I know the C standard says implementation defined, here its
;   unspecified]
; - later add versions of div/mod that have an explicit behaviour for -ve args
; - signedness is part of the rtx operation name, and is not determined
;   from the arguments [elsewhere is a description of the tradeoffs]
; - ???

(drn (neg &options &mode s1)
     #f
     (OPTIONS ANYNUMMODE RTX) (NA NA MATCHEXPR)
     UNARY
     #f
)

(drn (abs &options &mode s1)
     #f
     (OPTIONS ANYNUMMODE RTX) (NA NA MATCHEXPR)
     UNARY
     #f
)

; For integer values this is a bitwise operation (each bit inverted).
; For floating point values this produces 1/x.
; ??? Might want different names.
(drn (inv &options &mode s1)
     #f
     (OPTIONS ANYINTMODE RTX) (NA NA MATCHEXPR)
     UNARY
     #f
)

; This is a boolean operation.
; MODE is the mode of S1.  The result always has mode BI.
; ??? Perhaps `mode' shouldn't be here.
(drn (not &options &mode s1)
     BI
     (OPTIONS ANYINTMODE RTX) (NA NA MATCHEXPR)
     UNARY
     #f
)

(drn (add &options &mode s1 s2)
     #f
     (OPTIONS ANYNUMMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     BINARY
     #f
)
(drn (sub &options &mode s1 s2)
     #f
     (OPTIONS ANYNUMMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     BINARY
     #f
)

; "OF" for "overflow flag", "CF" for "carry flag",
; "s3" here must have type BI.
; For the *flag rtx's, MODE is the mode of S1,S2; the result always has
; mode BI.
(drn (addc &options &mode s1 s2 s3)
     #f
     (OPTIONS ANYINTMODE RTX RTX RTX) (NA NA MATCHEXPR MATCH2 BI)
     TRINARY
     #f
)
(drn (addc-cflag &options &mode s1 s2 s3)
     BI
     (OPTIONS ANYINTMODE RTX RTX RTX) (NA NA MATCHEXPR MATCH2 BI)
     TRINARY
     #f
)
(drn (addc-oflag &options &mode s1 s2 s3)
     BI
     (OPTIONS ANYINTMODE RTX RTX RTX) (NA NA MATCHEXPR MATCH2 BI)
     TRINARY
     #f
)
(drn (subc &options &mode s1 s2 s3)
     #f
     (OPTIONS ANYINTMODE RTX RTX RTX) (NA NA MATCHEXPR MATCH2 BI)
     TRINARY
     #f
)
(drn (subc-cflag &options &mode s1 s2 s3)
     BI
     (OPTIONS ANYINTMODE RTX RTX RTX) (NA NA MATCHEXPR MATCH2 BI)
     TRINARY
     #f
)
(drn (subc-oflag &options &mode s1 s2 s3)
     BI
     (OPTIONS ANYINTMODE RTX RTX RTX) (NA NA MATCHEXPR MATCH2 BI)
     TRINARY
     #f
)

;; ??? These are deprecated.  Delete in time.
(drn (add-cflag &options &mode s1 s2 s3)
     BI
     (OPTIONS ANYINTMODE RTX RTX RTX) (NA NA MATCHEXPR MATCH2 BI)
     TRINARY
     #f
)
(drn (add-oflag &options &mode s1 s2 s3)
     BI
     (OPTIONS ANYINTMODE RTX RTX RTX) (NA NA MATCHEXPR MATCH2 BI)
     TRINARY
     #f
)
(drn (sub-cflag &options &mode s1 s2 s3)
     BI
     (OPTIONS ANYINTMODE RTX RTX RTX) (NA NA MATCHEXPR MATCH2 BI)
     TRINARY
     #f
)
(drn (sub-oflag &options &mode s1 s2 s3)
     BI
     (OPTIONS ANYINTMODE RTX RTX RTX) (NA NA MATCHEXPR MATCH2 BI)
     TRINARY
     #f
)

; Usurp these names so that we have consistent rtl should a program generator
; ever want to infer more about what the semantics are doing.
; For now these are just macros that expand to real rtl to perform the
; operation.

; Return bit indicating if VALUE is zero/non-zero.
(drmn (zflag arg1 . rest) ; mode value)
      (if (null? rest) ; mode missing?
	  (list 'eq 'DFLT arg1 0)
	  (list 'eq arg1 (car rest) 0))
)

; Return bit indicating if VALUE is negative/non-negative.
(drmn (nflag arg1 . rest) ; mode value)
      (if (null? rest) ; mode missing?
	  (list 'lt 'DFLT arg1 0)
	  (list 'lt arg1 (car rest) 0))
)

; Multiply/divide.

(drn (mul &options &mode s1 s2)
     #f
     (OPTIONS ANYNUMMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     BINARY
     #f
)
; 1's complement overflow
(drn (mul-o1flag &options &mode s1 s2)
     BI
     (OPTIONS ANYINTMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     BINARY
     #f
)
; 2's complement overflow
(drn (mul-o2flag &options &mode s1 s2)
     BI
     (OPTIONS ANYINTMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     BINARY
     #f
)
; ??? In non-sim case, ensure s1,s2 is in right C type for right result.
; ??? Need two variants, one that avoids implementation defined situations
; [both host and target], and one that specifies implementation defined
; situations [target].
(drn (div &options &mode s1 s2)
     #f
     (OPTIONS ANYNUMMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     BINARY
     #f
)
(drn (udiv &options &mode s1 s2)
     #f
     (OPTIONS ANYINTMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     BINARY
     #f
)
(drn (mod &options &mode s1 s2)
     #f
     (OPTIONS ANYNUMMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     BINARY
     #f
)
(drn (umod &options &mode s1 s2)
     #f
     (OPTIONS ANYINTMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     BINARY
     #f
)
(drn (rem &options &mode s1 s2)
     #f
     (OPTIONS ANYFLOATMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     BINARY
     #f
)

; wip: mixed mode mul/div

; various floating point routines

(drn (sqrt &options &mode s1)
     #f
     (OPTIONS ANYFLOATMODE RTX) (NA NA MATCHEXPR)
     UNARY
     #f
)

(drn (cos &options &mode s1)
     #f
     (OPTIONS ANYFLOATMODE RTX) (NA NA MATCHEXPR)
     UNARY
     #f
)

(drn (sin &options &mode s1)
     #f
     (OPTIONS ANYFLOATMODE RTX) (NA NA MATCHEXPR)
     UNARY
     #f
)

(drn (nan &options &mode s1)
     BI
     (OPTIONS ANYFLOATMODE RTX) (NA NA MATCHEXPR)
     UNARY
     #f
)
(drn (qnan &options &mode s1)
     BI
     (OPTIONS ANYFLOATMODE RTX) (NA NA MATCHEXPR)
     UNARY
     #f
)
(drn (snan &options &mode s1)
     BI
     (OPTIONS ANYFLOATMODE RTX) (NA NA MATCHEXPR)
     UNARY
     #f
)

; min/max

(drn (min &options &mode s1 s2)
     #f
     (OPTIONS ANYNUMMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     BINARY
     #f
)

(drn (max &options &mode s1 s2)
     #f
     (OPTIONS ANYNUMMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     BINARY
     #f
)

(drn (umin &options &mode s1 s2)
     #f
     (OPTIONS ANYINTMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     BINARY
     #f
)

(drn (umax &options &mode s1 s2)
     #f
     (OPTIONS ANYINTMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     BINARY
     #f
)

; These are bitwise operations.
(drn (and &options &mode s1 s2)
     #f
     (OPTIONS ANYINTMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     BINARY
     #f
)
(drn (or &options &mode s1 s2)
     #f
     (OPTIONS ANYINTMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     BINARY
     #f
)
(drn (xor &options &mode s1 s2)
     #f
     (OPTIONS ANYINTMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     BINARY
     #f
)

; Shift operations.

(drn (sll &options &mode s1 s2)
     #f
     (OPTIONS ANYINTMODE RTX RTX) (NA NA MATCHEXPR INT)
     BINARY
     #f
)
(drn (srl &options &mode s1 s2)
     #f
     (OPTIONS ANYINTMODE RTX RTX) (NA NA MATCHEXPR INT)
     BINARY
     #f
)
; ??? In non-sim case, ensure s1 is in right C type for right result.
(drn (sra &options &mode s1 s2)
     #f
     (OPTIONS ANYINTMODE RTX RTX) (NA NA MATCHEXPR INT)
     BINARY
     #f
)
; Rotates don't really have a sign, so doesn't matter what we say.
(drn (ror &options &mode s1 s2)
     #f
     (OPTIONS ANYINTMODE RTX RTX) (NA NA MATCHEXPR INT)
     BINARY
     #f
)
(drn (rol &options &mode s1 s2)
     #f
     (OPTIONS ANYINTMODE RTX RTX) (NA NA MATCHEXPR INT)
     BINARY
     #f
)
; ??? Will also need rotate-with-carry [duh...].

; These are boolean operations (e.g. C &&, ||).
; The result always has mode BI.
; ??? 'twould be more Schemey to take a variable number of args.
; ??? 'twould also simplify several .cpu description entries.
; On the other hand, handling an arbitrary number of args isn't supported by
; ISA's, which the main goal of what we're trying to represent.
(drn (andif &options &mode s1 s2)
     BI
     (OPTIONS BIMODE RTX RTX) (NA NA ANYINT ANYINT)
     BINARY ; IF?
     #f
)
(drn (orif &options &mode s1 s2)
     BI
     (OPTIONS BIMODE RTX RTX) (NA NA ANYINT ANYINT)
     BINARY ; IF?
     #f
)

; `bitfield' is an experimental operation.
; It's not really needed but it might help simplify some things.
;
;(drn (bitfield mode src start length)
;     ...
;     ...
;)

;; Integer conversions.

(drn (ext &options &mode s1)
     #f
     (OPTIONS ANYINTMODE RTX) (NA NA ANY)
     UNARY
     #f
)
(drn (zext &options &mode s1)
     #f
     (OPTIONS ANYINTMODE RTX) (NA NA ANY)
     UNARY
     #f
)
(drn (trunc &options &mode s1)
     #f
     (OPTIONS ANYINTMODE RTX) (NA NA ANY)
     UNARY
     #f
)

;; Conversions involving floating point values.

(drn (fext &options &mode how s1)
     #f
     (OPTIONS ANYFLOATMODE RTX RTX) (NA NA INT ANY)
     UNARY
     #f
)
(drn (ftrunc &options &mode how s1)
     #f
     (OPTIONS ANYFLOATMODE RTX RTX) (NA NA INT ANY)
     UNARY
     #f
)
(drn (float &options &mode how s1)
     #f
     (OPTIONS ANYFLOATMODE RTX RTX) (NA NA INT ANY)
     UNARY
     #f
)
(drn (ufloat &options &mode how s1)
     #f
     (OPTIONS ANYFLOATMODE RTX RTX) (NA NA INT ANY)
     UNARY
     #f
)
(drn (fix &options &mode how s1)
     #f
     (OPTIONS ANYINTMODE RTX RTX) (NA NA INT ANY)
     UNARY
     #f
)
(drn (ufix &options &mode how s1)
     #f
     (OPTIONS ANYINTMODE RTX RTX) (NA NA INT ANY)
     UNARY
     #f
)

; Comparisons.
; MODE is the mode of S1,S2.  The result always has mode BI.

(drn (eq &options &mode s1 s2)
     BI
     (OPTIONS ANYNUMMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     COMPARE
     #f
)
(drn (ne &options &mode s1 s2)
     BI
     (OPTIONS ANYNUMMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     COMPARE
     #f
)
; ??? In non-sim case, ensure s1,s2 is in right C type for right result.
(drn (lt &options &mode s1 s2)
     BI
     (OPTIONS ANYNUMMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     COMPARE
     #f
)
(drn (le &options &mode s1 s2)
     BI
     (OPTIONS ANYNUMMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     COMPARE
     #f
)
(drn (gt &options &mode s1 s2)
     BI
     (OPTIONS ANYNUMMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     COMPARE
     #f
)
(drn (ge &options &mode s1 s2)
     BI
     (OPTIONS ANYNUMMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     COMPARE
     #f
)
; ??? In non-sim case, ensure s1,s2 is in right C type for right result.
(drn (ltu &options &mode s1 s2)
     BI
     (OPTIONS ANYNUMMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     COMPARE
     #f
)
(drn (leu &options &mode s1 s2)
     BI
     (OPTIONS ANYNUMMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     COMPARE
     #f
)
(drn (gtu &options &mode s1 s2)
     BI
     (OPTIONS ANYNUMMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     COMPARE
     #f
)
(drn (geu &options &mode s1 s2)
     BI
     (OPTIONS ANYNUMMODE RTX RTX) (NA NA MATCHEXPR MATCH2)
     COMPARE
     #f
)

; Set membership.
; Useful in ifield assertions.

; Return a boolean (BI mode) indicating if VALUE is in SET.
; VALUE is any constant rtx.  SET is a `number-list' rtx.

(drn (member &options &mode value set)
     #f
     (OPTIONS BIMODE RTX RTX) (NA NA INT INT)
     MISC
     (begin
       (if (not (rtx-constant? value))
	   (estate-error *estate* "`member rtx'"
			 "value is not a constant" value))
       (if (not (rtx-kind? 'number-list set))
	   (estate-error *estate* "`member' rtx"
			 "set is not a `number-list' rtx" set))
       (if (memq (rtx-constant-value value) (rtx-number-list-values set))
	   (rtx-true)
	   (rtx-false)))
)

;; FIXME: "number" in "number-list" implies floats are ok.
;; Rename to integer-list, int-list, or some such.

(drn (number-list &options &mode value-list)
     #f
     (OPTIONS INTMODE NUMBER . NUMBER) (NA NA NA . NA)
     MISC
     #f
)

; Conditional execution.

; FIXME: make syntax node?
(drn (if &options &mode cond then . else)
     #f
     ;; ??? It would be cleaner if TESTRTX had to have BI mode.
     (OPTIONS ANYEXPRMODE TESTRTX RTX . RTX) (NA NA ANYINT MATCHEXPR . MATCH3)
     IF
     (apply e-if (append! (list *estate* mode cond then) else))
)

; ??? The syntax here isn't quite that of Scheme.  A condition must be
; followed by a result expression.
; ??? The syntax here isn't quite right, there must be at least one cond rtx.
; ??? Intermediate expressions (the ones before the last one) needn't have
; the same mode as the result.
(drsn (cond &options &mode . cond-code-list)
     #f
      (OPTIONS ANYEXPRMODE . CONDRTX) (NA NA . MATCHEXPR)
      COND
      #f
)

; ??? The syntax here isn't quite right, there must be at least one case.
; ??? Intermediate expressions (the ones before the last one) needn't have
; the same mode as the result.
(drn (case &options &mode test . case-list)
     #f
     (OPTIONS ANYEXPRMODE RTX . CASERTX) (NA NA ANY . MATCHEXPR)
     COND
     #f
)

; parallel, sequence, do-count, closure

; This has to be a syntax node as we don't want EXPRS to be pre-evaluated.
; All semantic ops must have a mode, though here it must be VOID.
; IGNORE is for consistency with sequence.  ??? Delete some day.
; ??? There's no real need for mode either, but convention requires it.

(drsn (parallel &options &mode ignore expr . exprs)
     #f
      (OPTIONS VOIDMODE LOCALS RTX . RTX) (NA NA NA VOID . VOID)
      SEQUENCE
      #f
)

; This has to be a syntax node to handle locals properly: they're not defined
; yet and thus pre-evaluating the expressions doesn't work.

(drsn (sequence &options &mode locals expr . exprs)
     #f
      (OPTIONS VOIDORNUMMODE LOCALS RTX . RTX) (NA NA NA MATCHSEQ . MATCHSEQ)
      SEQUENCE
      #f
)

; This has to be a syntax node to handle iter-var properly: it's not defined
; yet and thus pre-evaluating the expressions doesn't work.

(drsn (do-count &options &mode iter-var nr-times expr . exprs)
     #f
      (OPTIONS VOIDMODE ITERATION RTX RTX . RTX) (NA NA NA INT VOID . VOID)
      SEQUENCE
      #f
)

; Internal rtx to create a closure.
; Internal, so it does not appear in rtl.texi (at least not yet).
; ??? Maybe closures shouldn't be separate from sequences,
; but I'm less convinced these days.

(drsn (closure &options &mode isa-name-list env-stack expr)
     #f
      (OPTIONS VOIDORNUMMODE SYMBOLLIST ENVSTACK RTX) (NA NA NA NA MATCHEXPR)
      MISC
      #f
)

)) ; End of def-rtx-funcs
@


1.20
log
@	* desc-cpu.scm (cgen-desc.h): Don't print virtual enums.
	* sid-cpu.scm (cgen-desc.h): Ditto.
	* enum.scm (enum-builtin!): New function.
	* read.scm (reader-install-builtin!): Call it.
	* rtl-c.scm (s-convop): Delete, replaced with ...
	(s-int-convop, s-float-convop): ... new fns.
	(ext, zext, trunc): Update.
	(fext, ftrunc, float, ufloat, fix, ufix): Update.
	* rtx-funcs.scm (fext, ftrunc, float, ufloat, fix, ufix): New parameter
	`how'.
	* cpu/mep-fmax.cpu (fcvtsw): Update.
	* cpu/sh.cpu (h-fsd, h-fmov): Update.
	* doc/rtl.texi (float-convop): Update.

	* frv.cpu (floating-point-conversion): Update call to fp conv op.
	(floating-point-dual-conversion, ne-floating-point-dual-conversion,
	conditional-floating-point-conversion, ne-floating-point-conversion,
	float-parallel-mul-add-double-semantics): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2009, 2010 Red Hat, Inc.
d758 14
d800 6
@


1.19
log
@	* rtx-funcs.scm (nan,qnan,snan): New rtl functions.
	* rtl-c.scm (nan,qnan,snan): New rtl functions.
	* doc/rtl.texi (Expressions): Add docs for them.
@
text
@d944 1
a944 1
; Conversions.
d964 4
a967 1
(drn (fext &options &mode s1)
d969 1
a969 1
     (OPTIONS ANYFLOATMODE RTX) (NA NA ANY)
d973 1
a973 1
(drn (ftrunc &options &mode s1)
d975 1
a975 1
     (OPTIONS ANYFLOATMODE RTX) (NA NA ANY)
d979 1
a979 1
(drn (float &options &mode s1)
d981 1
a981 1
     (OPTIONS ANYFLOATMODE RTX) (NA NA ANY)
d985 1
a985 1
(drn (ufloat &options &mode s1)
d987 1
a987 1
     (OPTIONS ANYFLOATMODE RTX) (NA NA ANY)
d991 1
a991 1
(drn (fix &options &mode s1)
d993 1
a993 1
     (OPTIONS ANYINTMODE RTX) (NA NA ANY)
d997 1
a997 1
(drn (ufix &options &mode s1)
d999 1
a999 1
     (OPTIONS ANYINTMODE RTX) (NA NA ANY)
@


1.18
log
@	* rtl-traverse.scm (/rtx-canon-anycexprmode): New function.
	(/rtx-make-canon-table): Add entry for ANYCEXPRMODE.
	(/rtx-canon-operands): Print expr-mode if /rtx-canon-debug?
	Do final error check on mode assigned to expression.
	(/rtx-make-traverser-table): Add entry for ANYCEXPRMODE.
	* rtl-xform.scm (/rtx-trim-args): Handle ANYCEXPRMODE.
	* rtl.scm (/rtx-valid-mode-types): Add ANYCEXPRMODE.
	* rtx-funcs.scm (c-code, c-call, c-raw-call): Use ANYCEXPRMODE.
	(if, cond, case): Use ANYEXPRMODE.
@
text
@d812 19
@


1.17
log
@	* utils.scm (reduce): Delete.

	* rtl-traverse.scm (/rtx-canon-rtx-enum): Tweak local name.

	* enum.scm (gen-enum-sym): Make consistent with gen-enum-decl
	regarding PREFIX attribute handling.

	* operand.scm (<hw-index>): Add enum to possible types, all uses
	updated.
	(hw-index-constant?, hw-index-constant-value): New functions.
	(make-enum-hw-index, hw-index-enum-name, hw-index-enum-value,
	hw-index-enum-obj): New functions.
	(/operand-parse): Handle enum indices.
	* intrinsics.scm (md-operand:fixed-register): Use hw-index-constant?,
	hw-index-constant-value.
	* rtl.scm (rtx-constant-value): Fix handling of enums.
	* rtx-funcs.scm (enum): Ditto.
	* sid.scm (<hardware-base> cxmake-get): Only ifield indices are
	currently supported here.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2009 Red Hat, Inc.
d507 1
a507 1
     (OPTIONS ANYEXPRMODE STRING) (NA NA NA)
d524 1
a524 1
     (OPTIONS ANYEXPRMODE STRING . RTX) (NA NA NA . ANY)
d533 1
a533 1
     (OPTIONS ANYEXPRMODE STRING . RTX) (NA NA NA . ANY)
d1086 1
a1086 1
     (OPTIONS VOIDORNUMMODE TESTRTX RTX . RTX) (NA NA ANYINT MATCHEXPR . MATCH3)
d1098 1
a1098 1
      (OPTIONS VOIDORNUMMODE . CONDRTX) (NA NA . MATCHEXPR)
d1108 1
a1108 1
     (OPTIONS VOIDORNUMMODE RTX . CASERTX) (NA NA ANY . MATCHEXPR)
@


1.16
log
@downgrade some fixmes -> ???
@
text
@d52 3
a54 2
     ; When computing a value, return the enum's value.
     (enum-lookup-val enum-name)
@


1.15
log
@	Specify isa(s) when doing ifield, operand, insn lookups.
	ACU = all callers updated.
	* attr.scm (/attr-eval): Call rtx-value instead of rtx-eval-with-estate.
	* enum.scm (define-full-insn-enum): Pass isa-name-list to
	current-ifld-lookup.
	* html.scm (get-insn-properties): Pass isa-name-list to
	current-op-lookup.
	* ifield.scm (/ifld-parse-follows): New arg isas, ACU.
	* insn.scm (/parse-insn-format-symbol): New arg isa-name-list, ACU.
	(/parse-insn-format-list, /parse-insn-iformat-iflds): Ditto.
	(/parse-insn-format, syntax-break-out): Ditto.
	* mach.scm (obj-filter-by-isa): New function.
	(current-ifld-lookup): New optional arg maybe-isa-name-list.
	(/ifld-already-defined?, /op-already-defined?): Simplify.
	(current-op-lookup): New optional arg maybe-isa-name-list.
	(current-insn-lookup): New arg isa-name-list, ACU.
	(/insn-already-defined?, /minsn-already-defined?): Simplify.
	(current-minsn-lookup): New arg isa-name-list, ACU.
	* minsn.scm (/minsn-compute-iflds): Pass isa-name-list to
	current-op-lookup.
	* opc-itab.scm (compute-syntax): New arg isa-name-list, ACU.
	(gen-syntax-entry): Ditto.
	* operand.scm (/operand-parse): Pass isa-name-list to
	current-ifld-lookup.
	(/derived-parse-encoding): New arg isa-name-list, ACU.
	(/derived-parse-ifield-assertion): Ditto.
	(/derived-operand-parse): Pass isa-name-list to current-op-lookup.
	(/anyof-parse-choice): Ditto.
	(anyof-satisfies-assertions?): Pass context to rtx-solve.
	(/anyof-merge-syntax): New arg container, ACU.
	(operand-builtin!): Add pc to all isas.
	* rtl-c.scm (estate-make-for-rtl-c): Delete arg extra-vars-alist, ACU.
	(estate-make-for-rtl-c++, rtl-c-expr-parsed): Ditto.
	(rtl-c-parsed, rtl-c++-parsed): Ditto.
	(rtl-c): New arg isa-name-list, ACU.
	(rtl-c-expr, rtl-c++): Ditto.
	(closure): New arg isa-name-list, ACU.
	* rtl-traverse.scm (/make-cstate): New arg isa-name-list, ACU.
	(/cstate-isas): New function.
	(/rtx-canon-symbol-list): New function.
	(/rtx-canon-env-stack): Renamed from /rtx-canon-env, ACU.
	updated.
	(/rtx-make-canon-table): Rename ENV to ENVSTACK, new entry SYMBOLLIST.
	(/rtx-canon-rtx-operand): Pass isa list to current-op-lookup.
	(/rtx-canon-rtx-ref, /rtx-canon): Ditto.
	(rtx-canonicalize): New arg isa-name-list, ACU.
	(rtx-canonicalize-stmt): Delete.
	(tstate-make): New arg isas, ACU.
	(tstate-isas, tstate--set-isas!): New functions.
	(tstate-env-stack): Renamed from tstate-env, ACU.
	(tstate-set-env-stack!): Renamed from tstate-set-env!, ACU.
	(tstate-make-closure): Renamed from tstate-new-env, new arg
	isa-name-list, ACU.
	(/rtx-traverse-env): Delete.
	(/rtx-make-traverser-table): Rename ENV to ENVSTACK, new entry
	SUMBOLLIST.
	(/rtx-traverse): Include conditional flag in dump output.
	Update isa,envstack for closures.  Pass isa list to current-op-lookup.
	(<eval-state>): New member isas.  Rename env to env-stack.
	(<eval-state> vmake!): Handle #:isas.  #:env renamed to #:env-stack.
	(<eval-state>): New getter/setter for isas.  Rename env getter/setter
	to env-stack.
	(estate-make-for-eval): Provide #:isas.
	(estate-make-closure): Renamed from estate-new-env.  New arg
	isa-name-list, ACU.
	* rtl-xform.scm (/rtx-simplify-expr-fn): Handle closures.
	(/rtx-trim-args): ENV renamed to ENVSTACK.  Ad ITERATION, SYMBOLLIST.
	(/rtx-trim-for-doc): Handle closures.
	* rtl.scm (/rtx-valid-types): Rename ENV to ENVSTACK.  Add ITERATION,
	SYMBOLLIST.
	(rtx-env-var-list): Delete.
	(rtx-env-make): Handle already-compiled environments.
	(rtx-var-alist-to-env): New function.
	(rtx-var-alist-to-closure-env-stack, rtx-make-env-stack): New functions.
	(rtx-env-stack-dump): Renamed from rtx-env-dump, ACU.
	(rtx-operand-obj): New arg isa-name-list, ACU.
	(rtx-closure-isas, rtx-closure-env-stack, rtx-closure-expr): New
	functions.
	* rtx-funcs.scm (closure): New arg isa-name-list, reorder args, ACU.
	* sem-frags.scm (<sfrag>): Delete member compiled-semantics.
	(/frag-compute-desired-frags): Minor simplification.
	(/frag-pick-best): Ditto.
	* sid-cpu.scm (gen-semantic-code): Require canonical rtl.
	(/gen-sfrag-code): Update.
	* sim-cpu.scm (gen-semantic-code): Require canonical rtl.
	* utils-cgen.scm (sanitize): New arg isa-name-list, ACU.
	* utils.scm (non-null-intersection?): New function.
@
text
@d50 1
a50 1
     (OPTIONS ANYINTMODE SYMBOL) (NA NA NA) ;; FIXME: s/SYMBOL/ENUM-NAME/ ?
d64 1
a64 1
      (OPTIONS ANYNUMMODE SYMBOL) (NA NA NA) ;; FIXME: s/SYMBOL/IFIELD-NAME/ ?
d83 1
a83 1
      (OPTIONS ANYNUMMODE SYMBOL) (NA NA NA) ;; FIXME: s/SYMBOL/OPERAND-NAME/ ?
d130 1
a130 1
      (OPTIONS ANYNUMMODE OBJECT) (NA NA NA) ;; FIXME: s/OBJECT/OPERAND/ ?
d156 1
a156 1
      (OPTIONS ANYNUMMODE SYMBOL) (NA NA NA) ;; FIXME: s/SYMBOL/LOCAL-NAME/ ?
d189 1
a189 1
      (OPTIONS BIMODE SYMBOL) (NA NA NA) ;; FIXME: s/SYMBOL/OPERAND-NAME/ ?
d251 1
a251 1
      (OPTIONS ANYNUMMODE SYMBOL . RTX) (NA NA NA . INT) ;; FIXME: s/SYMBOL/HW-NAME/ ?
d265 1
a265 1
      (OPTIONS ANYNUMMODE SYMBOL . RTX) (NA NA NA . INT) ;; FIXME: s/SYMBOL/HW-NAME/ ?
@


1.14
log
@comment tweaks
@
text
@a1127 1
; ??? This should create a closure.
d1147 3
a1149 1
; Internal, so it does not appear in rtl.texi.
d1151 1
a1151 1
(drsn (closure &options &mode expr env)
d1153 1
a1153 1
      (OPTIONS VOIDORNUMMODE RTX ENV) (NA NA MATCHEXPR NA)
@


1.13
log
@	* xc16x.cpu (h-cr): New hardware.
	(muls): Comment out parts that won't compile, add fixme.
	(mulu, divl, divlu, jmpabs, jmpa-, jmprel, jbc, jnbs, callr): Ditto.
	(scxti, scxtmg, scxtm, bclear, bclr18, bset19, bitset, bmov): Ditto.
	(bmovn, band, bor, bxor, bcmp, bfldl, bfldh): Ditto.

	Rewrite rtl processing to require it to be "canonicalized" first,
	and write a full canonicalizer / expression checker.
	Remove all appearances of DFLT in canonical rtl.
	* attr.scm (/attr-eval atval owner): Call rtx-canonicalize,
	then rtx-simplify.
	* iformat.scm (ifmt-analyze) Use canonical semantics.
	* insn (<insn>): New member canonical-semantics.
	* mach.scm (<arch>): New member multi-insns-instantiated?.
	(/instantiate-multi-insns!): New function.
	(/canonicalize-insns!): New function.
	(arch-analyze-insns!): Canonicalize insn semantics before processing
	them.
	* mode.scm (/mode-set-word-params!): New function.
	(mode-void?): New function.
	(mode-compatible?): VOID is compatible with VOID.
	(/mode-word-sizes-defined?): New global.
	(mode-set-word-modes!): Use/set it.
	(mode-ensure-word-sizes-defined): Update.
	(mode-builtin!): New builtin "modes" SYM, INSN, MACH.
	Redo WI/UWI/AI/IAI handling.
	(op:new-mode): No longer accept DFLT.
	(<derived-operand> constructor): Ensure all fields are initialized.
	(<anyof-operand> constructor): Ditto.
	(/derived-parse-ifield-assertion): Delete arg `args'.
	All callers updated.
	* rtl-c.scm (<rtl-c-eval-state>): New member `for-insn?'.
	(rtl-c): Call rtx-canonicalize instead of rtx-compile.
	(rtl-c-expr, rtl-c++): Ditto.
	(/rtl-c-get): Use mode of operand, not containing expression.
	(rtl-c-set-quiet, rtl-c-set-trace): Remove DFLT support.
	(/rtx-use-sem-fn?): Don't check for (insn? owner), check
	estate-for-insn? instead.
	(s-unop): Use mode of expression, not first operand.
	(s-binop, s-binop-with-bit, s-shop, s-cmpop): Ditto.
	(s-sequence): Remove DFLT support.
	(ifield): Use mode of expression, not UINT.
	(pc): Comment out, unused.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	(set, set-quiet): Pass src to rtl-c-set-{trace,quiet} for expansion.
	* rtl-traverse.scm (/rtx-canon-debug?): New global.
	(/make-cstate): New function.
	(/cstate-context, /cstate-outer-expr): New functions.
	(/rtx-canon-error): New function.
	(/rtx-lookup-hw, /rtx-pick-mode, /rtx-pick-mode3, /rtx-pick-op-mode,
	/rtx-get-last-cond-case-rtx): New functions.
	(/rtx-canon-*): New functions.
	(/rtx-canner-table, /rtx-operand-canoners): New globals.
	(/rtx-make-canon-table, /rtx-special-expr-canoners): New functions.
	(/rtx-option, /rtx-option-list?): Rewrite.
	(rtx-munge-mode&options): Replaces /rtx-munge-mode&options.
	Rewritten, all callers updated.
	(/rtx-canon-expr, /rtx-canon): New functions.
	(rtx-canonicalize): Move here from rtl-xform.scm and rewrite.
	(rtx-canonicalize-stmt): New function.
	(tstate-make): Remove arg `set?'.  All callers updated.
	(tstate-new-set?): Delete.
	(/rtx-traverse-options, /rtx-traverse-*mode): Delete,
	moved to /rtx-canon-*.
	(/rtx-traverse-normal-operand): New function.
	(/rtx-traverse-rtx-list): Delete arg `mode', all callers updated.
	(/rtx-traverse-rtx, /rtx-traverse-setrtx,, /rtx-traverse-testrtx,
	/rtx-traverse-condrtx, /rtx-traverse-casertx, /rtx-traverse-locals,
	/rtx-traverse-iteration, /rtx-traverse-env, /rtx-traverse-attrs):
	Ditto.
	(/rtx-traverse-symbol, /rtx-traverse-string, /rtx-traverse-number,
	/rtx-traverse-symornum, /rtx-traverse-object): Delete.
	(/rtx-make-traverser-table): Update.
	(/rtx-traverse-operands): Remove mode processing, now done during
	canonicalization.
	(/rtx-traverse-expr): Delete arg `mode', all callers updated.
	(/rtx-traverse): Ditto.
	(rtx-init-traverser-tables!): New function.
	* rtl-xform (/rtx-verify-no-dflt-modes-expr-fn): New function.
	(rtx-verify-no-dflt-modes): New function.
	(/rtx-simplify-expr-fn): Update, `arg' mode deleted.
	(rtx-simplify-insn): Use insn-canonical-semantics.
	(rtx-canonicalize): Moved to rtl-traverse.scm.
	(/compile-expr-fn, rtx-compile): Delete.
	(/rtx-trim-rtx-list): New function.
	(/rtx-trim-for-doc): Handle set, if.
	* rtl.scm (<rtx-func>): New members result-mode, matchexpr-index.
	(/rtx-valid-mode-types): Update.
	(/rtx-valid-matches): Update.
	(/rtx-find-matchexpr-index): New function.
	(rtx-lookup): Require rtx-kind to be the rtx name.
	(def-rtx-node): New arg result-mode, all callers updated.
	(def-rtx-syntax-node, def-rtx-operand-node): Ditto.
	(rtx-lazy-sem-mode): Delete.
	(/rtx-closure-make): New arg `mode', all callers updated.
	(rtx-make-ifield, rtx-make-operand, rtx-make-local): Ditto.
	(rtx-operand-obj): Rewrite.
	(rtx-make-xop): New functions.
	(/hw): Renamed from `hw', all callers updated.
	Use the correct mode instead of DFLT for the index.
	(rtl-builtin!): Call rtx-init-traversal-tables!.
	(rtl-finish!): Update.
	* rtx-funcs.scm (all rtx functions): New parameter: result-mode.
	Update mode arg-type.
	(pc): Comment out.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	* sem-frags.scm (/frag-hash-compute!): Update, mode arg deleted.
	(/frag-cost-compute!): Ditto.
	* semantics.scm (/build-operand!): Delete args op-name, op.
	New arg op-expr.  All callers updated.
	(/build-mem-operand!): Remove DFLT support.
	(semantic-compile): Update process-expr!, mode arg deleted.
	* sid-cpu.scm (gen-semantic-code): Specify #:for-insn? in
	rtl-c++ calls.
	(/gen-sem-case, /gen-sfrag-code): Ditto.
	* sid.scm (/op-gen-set-trace1): Renamed from /op-gen-set-trace.
	(/op-gen-set-trace): New function.  If not doing profiling,
	call /op-gen-set-quiet.
	* sim-cpu.scm (gen-semantic-code): Specify #:for-insn? in rtl-c calls.
	* utils-gen.scm (/gen-ifld-extract-base): Update call to rtl-c.
	(/gen-ifld-extract-beyond, gen-multi-ifld-extract): Ditto.
	* utils.scm (find-first-index): New function.
	* doc/rtl.texi: Delete docs for `attr'.  Add `int-attr'.
@
text
@a451 2
; ??? May also want an endian dependent argument order.  That can be
; implemented on top of or beside this.
d465 3
a467 3
; Word numbering is from most significant (word 0) to least (word N-1).
; ??? May also want an endian dependent word ordering.  That can be
; implemented on top of or beside this.
d470 1
d517 1
a517 1
; Mode is the mode of the result.
@


1.12
log
@	* rtx-funcs.scm (eq,ne,lt,gt,le,ge,ltu,leu,gtu,geu): Change class
	to COMPARE.
	* sem-frags.scm (/frag-cost-compute!): Add COMPARE.
@
text
@d35 2
d39 2
a40 1
     (OPTIONS ANYMODE STRING) (NA NA NA)
d49 2
a50 1
     (OPTIONS NUMMODE SYMBOL) (NA NA NA)
d63 2
a64 1
      (OPTIONS DFLTMODE SYMBOL) (NA NA NA)
d82 2
a83 1
      (OPTIONS DFLTMODE SYMBOL) (NA NA NA)
d113 2
a114 1
      (OPTIONS DFLTMODE SYMBOL RTX) (NA NA NA ANY)
d116 1
d129 2
a130 1
      (OPTIONS DFLTMODE OBJECT) (NA NA NA)
d136 1
a136 1
;      (OPTIONS ANYMODE SYMBOL NUMBER RTX ATTRS) (NA NA NA NA ANY NA)
d155 2
a156 1
      (OPTIONS DFLTMODE SYMBOL) (NA NA NA)
d172 2
a173 1
;     (OPTIONS DFLTMODE SYMBOL) (NA NA NA)
d188 2
a189 1
      (OPTIONS DFLTMODE SYMBOL) (NA NA NA)
d196 2
a197 1
; ??? Mode handling incomplete.
d200 2
a201 1
      (OPTIONS DFLTMODE RTX) (NA NA ANY)
d203 1
d238 1
a238 1
;      (OPTIONS ANYMODE SYMBOL . RTX) (NA NA NA . INT)
d250 2
a251 1
      (OPTIONS ANYMODE SYMBOL . RTX) (NA NA NA . INT)
d264 2
a265 1
      (OPTIONS ANYMODE SYMBOL . RTX) (NA NA NA . INT)
d278 1
d291 1
a291 1
(dron (pc) () () ARG s-pc)
d324 1
d328 2
a329 1
     (OPTIONS DFLTMODE RTX RTX) (NA NA INT ANY)
d351 2
a352 1
     (OPTIONS DFLTMODE RTX) (NA NA INT)
d365 1
a365 1
; The result is always of mode INT.
d373 2
a374 1
      (OPTIONS DFLTMODE RTX SYMBOL SYMORNUM) (NA NA ANY NA NA)
d384 4
a387 4
; Get the value of attribute ATTR-NAME.
; OBJ is the result of either (current-insn) or (current-mach)
; [note that canonicalization will turn them into
; (current-{insn,mach} () DFLT)].
d389 2
d392 3
a394 2
(drn (attr &options &mode obj attr-name)
     (OPTIONS DFLTMODE RTX SYMBOL) (NA NA NA NA)
d399 6
d409 2
a410 1
      (OPTIONS DFLTMODE SYMBOL) (NA NA NA)
d418 2
a419 1
     (OPTIONS DFLTMODE) (NA NA)
d431 2
a432 1
     (OPTIONS DFLTMODE) (NA NA)
d441 2
a442 1
     (OPTIONS NUMMODE NUMBER) (NA NA NA)
d457 2
a458 1
     (OPTIONS NUMMODE NUMMODE RTX . RTX) (NA NA NA ANY . ANY)
d473 1
a473 1
; The mode spec of operand0 use to be OP0, but subword is not a normal rtx.
d479 2
a480 1
     (OPTIONS NUMMODE RTX RTX) (NA NA ANY INT)
d506 2
a507 1
     (OPTIONS ANYMODE STRING) (NA NA NA)
d523 2
a524 1
     (OPTIONS ANYMODE STRING . RTX) (NA NA NA . ANY)
d532 2
a533 1
     (OPTIONS ANYMODE STRING . RTX) (NA NA NA . ANY)
d541 1
d550 2
a551 1
     (OPTIONS ANYMODE RTX) (NA NA OP0)
d576 2
a577 1
     (OPTIONS ANYMODE SETRTX RTX) (NA NA OP0 MATCH1)
d583 2
a584 1
     (OPTIONS ANYMODE SETRTX RTX) (NA NA OP0 MATCH1)
d618 2
a619 1
     (OPTIONS ANYMODE RTX) (NA NA OP0)
d625 2
a626 1
     (OPTIONS ANYMODE RTX) (NA NA OP0)
d635 2
a636 1
     (OPTIONS ANYMODE RTX) (NA NA OP0)
d645 2
a646 1
     (OPTIONS ANYMODE RTX) (NA NA OP0)
d652 2
a653 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 MATCH1)
d658 2
a659 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 MATCH1)
d669 2
a670 1
     (OPTIONS ANYMODE RTX RTX RTX) (NA NA OP0 MATCH1 BI)
d675 2
a676 1
     (OPTIONS ANYMODE RTX RTX RTX) (NA NA OP0 MATCH1 BI)
d681 2
a682 1
     (OPTIONS ANYMODE RTX RTX RTX) (NA NA OP0 MATCH1 BI)
d687 2
a688 1
     (OPTIONS ANYMODE RTX RTX RTX) (NA NA OP0 MATCH1 BI)
d693 2
a694 1
     (OPTIONS ANYMODE RTX RTX RTX) (NA NA OP0 MATCH1 BI)
d699 2
a700 1
     (OPTIONS ANYMODE RTX RTX RTX) (NA NA OP0 MATCH1 BI)
d707 2
a708 1
     (OPTIONS ANYMODE RTX RTX RTX) (NA NA OP0 MATCH1 BI)
d713 2
a714 1
     (OPTIONS ANYMODE RTX RTX RTX) (NA NA OP0 MATCH1 BI)
d719 2
a720 1
     (OPTIONS ANYMODE RTX RTX RTX) (NA NA OP0 MATCH1 BI)
d725 2
a726 1
     (OPTIONS ANYMODE RTX RTX RTX) (NA NA OP0 MATCH1 BI)
d753 2
a754 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 MATCH1)
d763 2
a764 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 MATCH1)
d769 2
a770 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 MATCH1)
d775 2
a776 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 MATCH1)
d781 2
a782 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 MATCH1)
d792 2
a793 1
     (OPTIONS FLOATMODE RTX) (NA NA OP0)
d799 2
a800 1
     (OPTIONS FLOATMODE RTX) (NA NA OP0)
d806 2
a807 1
     (OPTIONS FLOATMODE RTX) (NA NA OP0)
d815 2
a816 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 MATCH1)
d822 2
a823 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 MATCH1)
d829 2
a830 1
     (OPTIONS INTMODE RTX RTX) (NA NA OP0 MATCH1)
d836 2
a837 1
     (OPTIONS INTMODE RTX RTX) (NA NA OP0 MATCH1)
d844 2
a845 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 MATCH1)
d850 2
a851 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 MATCH1)
d856 2
a857 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 MATCH1)
d865 2
a866 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 INT)
d871 2
a872 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 INT)
d878 2
a879 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 INT)
d885 2
a886 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 INT)
d891 2
a892 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 INT)
d905 2
a906 1
     (OPTIONS DFLTMODE RTX RTX) (NA NA ANY ANY)
d911 2
a912 1
     (OPTIONS DFLTMODE RTX RTX) (NA NA ANY ANY)
d928 2
a929 1
     (OPTIONS INTMODE RTX) (NA NA ANY)
d934 2
a935 1
     (OPTIONS INTMODE RTX) (NA NA ANY)
d940 2
a941 1
     (OPTIONS INTMODE RTX) (NA NA ANY)
d946 2
a947 1
     (OPTIONS FLOATMODE RTX) (NA NA ANY)
d952 2
a953 1
     (OPTIONS FLOATMODE RTX) (NA NA ANY)
d958 2
a959 1
     (OPTIONS FLOATMODE RTX) (NA NA ANY)
d964 2
a965 1
     (OPTIONS FLOATMODE RTX) (NA NA ANY)
d970 2
a971 1
     (OPTIONS INTMODE RTX) (NA NA ANY)
d976 2
a977 1
     (OPTIONS INTMODE RTX) (NA NA ANY)
d986 2
a987 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 MATCH1)
d992 2
a993 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 MATCH1)
d999 2
a1000 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 MATCH1)
d1005 2
a1006 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 MATCH1)
d1011 2
a1012 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 MATCH1)
d1017 2
a1018 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 MATCH1)
d1024 2
a1025 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 MATCH1)
d1030 2
a1031 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 MATCH1)
d1036 2
a1037 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 MATCH1)
d1042 2
a1043 1
     (OPTIONS ANYMODE RTX RTX) (NA NA OP0 MATCH1)
d1055 2
a1056 1
     (OPTIONS DFLTMODE RTX RTX) (NA NA INT INT)
d1070 3
d1074 1
d1084 3
a1086 1
     (OPTIONS ANYMODE TESTRTX RTX . RTX) (NA NA ANY OP0 . MATCH2)
d1093 1
d1097 2
a1098 1
      (OPTIONS ANYMODE . CONDRTX) (NA NA . OP0)
d1103 1
d1107 2
a1108 1
     (OPTIONS ANYMODE RTX . CASERTX) (NA NA ANY . OP0)
d1113 1
a1113 1
; parallel, sequence, do-count
d1121 1
d1132 2
a1133 1
      (OPTIONS ANYMODE LOCALS RTX . RTX) (NA NA NA OP0 . OP0)
d1142 1
d1147 1
a1147 1

d1152 2
a1153 1
      (OPTIONS DFLTMODE RTX ENV) (NA NA NA NA)
@


1.11
log
@	Clean up pass of mode handling.
	Make use of mode name vs <mode> object more consistent and clear.
	* hardware.scm (/keyword-read): Default mode to the mode name,
	not the <mode> object.
	(/hw-parse-indices): Parse mode name and pass mode object to
	<hw-asm> constructor.
	(/hw-parse-values): Ditto.
	(<hw-register> parse!): Pass mode name to /hw-parse-indices
	and /hw-parse-values.
	(<hw-memory> parse!): Ditto.
	(<hw-address> parse!): Ditto.
	* mode.scm (/mode-table): New global, replaces mode-list.
	Modes stored in hashtable instead of list.
	(/mode-class-table): New global.
	(mode-list-non-alias-values): Update.
	(mode:eq?, mode-compatible?, mode:add!): Update.
	(mode:lookup): Restrict arg to the mode's name.  All callers updated.
	(mode-maybe-lookup): New function.
	(mode-real-name): Restrict arg to a <mode> object.  All callers updated.
	(mode-real-mode, mode-sem-mode, mode-bigger?): Ditto.
	(mode-find, mode-set-word-modes!): Update
	(mode-ensure-word-sizes-defined): Update.
	(/sort-mode-classes!): New function.
	(mode-builtin!): Update.  Sort mode classes here.
	(mode-finish!): Sort mode classes here too.
	* rtl-c.scm (/rtl-c-get): Restrict mode arg to a <mode> object.
	All callers updated.
	(rtl-c-set-quiet): Allow mode to be name of object.
	(rtl-c-set-trace): Ditto.
	* rtl-traverse.scm (rtl-eval-with-estate): Restrict mode arg to
	<mode> object.  All callers updated.
	* rtl.scm (rtx-sem-mode): Restrict arg to <mode> object.
	(rtx-lazy-sem-mode): Ditto.
	(<rtx-temp> make!): Assert mode arg is a <mode> object.
	(rtx-env-make): Allow var-list modes to be name or object.
	* sem-frags.scm (/frag-expr-assq-locals): New function.
	(/frag-compute-locals!): Call it.
	(/sfrag-create-cse-mapping): Renamed from sfrag-create-cse-mapping.
	All callers updated.
	* semantics.scm (/build-mem-operand!): Handle mode aliases.
@
text
@d896 1
a896 1
     BINARY
d901 1
a901 1
     BINARY
d907 1
a907 1
     BINARY
d912 1
a912 1
     BINARY
d917 1
a917 1
     BINARY
d922 1
a922 1
     BINARY
d928 1
a928 1
     BINARY
d933 1
a933 1
     BINARY
d938 1
a938 1
     BINARY
d943 1
a943 1
     BINARY
@


1.10
log
@Rework do-count to take an expression for the iteration count,
and swap the iteration-variable/#iterations arguments.
@
text
@d129 1
a129 1
;      (let ((opval (rtx-eval-with-estate hw-ref mode *estate*)))
d189 1
a189 1
      (let* ((operand (rtx-eval-with-estate op-rtx 'DFLT *estate*))
@


1.9
log
@	Add do-count rtl function.
	* rtl-c.scm (s-do-count): New function.
	(do-count): New rtl handler.
	* rtl-traverse.scm (-rtx-traverse-iteration): New function.
	(-rtx-make-traverser-table): Add ITERATION.
	* rtl.scm (rtx-env-make-iteration-locals): New function.
	* rtx-funcs.scm (do-count): New rtl function.
	* cpu/play.cpu: Add do-count-test insn.
	* doc/rtl.texi: Add docs on do-count.
@
text
@d1027 2
a1028 2
(drsn (do-count &options &mode nr-times iter-var expr . exprs)
      (OPTIONS VOIDMODE NUMBER ITERATION RTX . RTX) (NA NA NA NA VOID . VOID)
@


1.8
log
@	* read.scm (parse-error): Change error message output format
	to match context-owner-error.
	* rtl-c.scm (-rtl-c-get): Call estate-error instead of error.
	(rtl-c-set-quiet, rtl-c-set-trace): Ditto.
	(s-if, s-cond, -gen-non-vm-case-test): Ditto.
	(operand): Call estate-error instead of context-error.
	(local, delay): Ditto.
	(ref, attr): Call estate-error instead of error.
	* rtl-traverse.scm (tstate-error): New function.
	(-rtx-traverse-error): Call tstate-error instead of context-error.
	(-rtx-traverse-operands, -rtx-traverse): Ditto.
	(estate-error): New function.
	* rtl.scm (rtx-lvalue-mode-name): Handle locals.  Call estate-error
	instead of error.
	(e-if): Call estate-error instead of error.
	* rtx-funcs.scm (error): Call estate-error instead of context-error.
	(member): Ditto.
	* utils-cgen.scm (context-error): New arg `intro', all callers updated.
	Rewrite to call context-owner-error.
	(context-owner-error): New function.
@
text
@d1001 1
a1001 1
; Parallels and Sequences
d1023 9
@


1.7
log
@	* ifield.scm (<ifield> constructor): New arg `location',
	all callers updated.
	* insn.scm (<insn> constructor): Ditto.
	(<multi-insn> constructor): Ditto.
	* minsn.scm (<macro-insn> constructor): Ditto.
	* operand.scm (<operand> constructor): Ditto.
	* utils-cgen.scm (builtin-location): New function.
	(<source-ident>): Fix default value of member `location'.
	(source-ident?): New function.
@
text
@d39 1
a39 1
     (context-error (estate-context *estate*) message)
d958 2
a959 1
	   (context-error (estate-context *estate*) "value is not a constant" value))
d961 2
a962 1
	   (context-error (estate-context *estate*) "set is not a `number-list' rtx" set))
d1006 1
a1006 1
; ??? There's no real need for mode either.
@


1.6
log
@	* rtl-c.scm (addc-cflag, addc-oflag, subc-cflag, subc-oflag): Define.
	(add-cflag, add-oflag, sub-cflag, sub-oflag): Deprecate.
	* rtx-funcs.scm (addc-cflag, addc-oflag, subc-cflag, subc-oflag):
	Define.
	(add-cflag, add-oflag, sub-cflag, sub-oflag): Deprecate.
	* doc/rtl.texi: Update.
@
text
@d62 2
a63 1
	(make <operand> ifld-name (string-append ifld-name " used as operand")
d192 2
a193 1
	(make <operand> f-name f-name
@


1.5
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d621 1
a621 1
(drn (add-cflag &options &mode s1 s2 s3) ; FIXME: rename to addc-cflag
d626 1
a626 1
(drn (add-oflag &options &mode s1 s2 s3) ; FIXME: rename to addc-vflag
d636 1
a636 1
(drn (sub-cflag &options &mode s1 s2 s3) ; FIXME: rename to subc-cflag
d641 23
a663 1
(drn (sub-oflag &options &mode s1 s2 s3) ; FIXME: rename to subc-vflag
@


1.4
log
@	* mach.scm (current-*-add!): Disallow redefinition.  Make result
	"unspecified".
	* insn.scm (insn-builtin!): Don't define relaxable here, now defined in
	operand.scm.
	* operand.scm (operand-builtin!): Define RELAXABLE for insns too.
	* cpu/m32r.cpu (disp8,disp24): RELAX renamed to RELAXABLE.

	* gen-all-doc: Split arm and frv docs up a bit.

	* cpu/arm.cpu: Add IDOC attribute.
	* cpu/frv.cpu: Ditto.
	* cpu/i960.cpu: Ditto.
	* cpu/openrisc.cpu: Ditto.
	* cpu/xstormy16.cpu: Ditto.
	* cpu/m32r.cpu: Ditto.
	(all insns): Explicitly specify IDOC attribute.

	* Makefile.am (MACH,ISAS,INSN_FILE_NAME): New vars.
	(desc,opcodes,sim-arch,sim-cpu,gas-test,sim-test): Use MACH,ISAS.
	(html): Use MACH,ISAS,INSN_FILE_NAME.  Generate insn.html separately.
	* Makefile.in: Regenerate.
	* attr.scm (<integer-attribute>:parse-value-def): Implement.
	(-attr-read): Defer computing default value until we know the type.
	(attr-has-attr?): Delete, move contents to <attr-list>:has-attr?.
	(<attr-list>:attr-present?): New method.
	(atlist-attr-present?,obj-attr-present?): New fns.
	(obj-has-attr-value?,obj-has-attr-value-no-default?): New fns.
	(attr-builtin!): New insn attr IDOC.
	* cgen-doc.scm (doc-arguments): New args -I,-N.
	* enum.scm (parse-enum-vals): New arg errtxt, all callers updated.
	Support comment as fourth element of enum value.
	(enum-val-name,enum-val-value,enum-val-attrs,enum-val-comment): New fns.
	* html.scm (gen-html-header): New arg kind, all callers updated.
	(gen-table-of-contents): New arg insn-file, all callers updated.
	(gen-list-entry,gen-doc-header): New fn.
	(get-operands): Delete.
	(gen-iformat-table): Rewrite.
	(gen-insn-doc-1): Print constant-folded and trimmed semantics.
	(gen-insn-doc-list): New args name, comment, insns.  All callers updated.
	(get-insn-properties,guess-insn-idoc-attr!): New fn.
	(insn-sets-pc?,insn-refs-mem?,insn-uses-fpu?): New fns.
	(get-insns-for-category,gen-categories-insn-lists): New fns.
	(gen-insn-docs): Simplify each insn's semantics first.
	Print insn tables sorted by IDOC categories.
	(*insn-html-file-name*): New global.
	(cgen-insn.html): New fn.
	(cgen-all): Update.
	* insn.scm (<insn>): Create a setter for the `tmp' member.
	* semantics.scm (insn-build-known-values): Renamed from
	-build-known-values.  All callers updated.

	* rtl.scm: Move traveral/evaluation support to ...
	* rtl-traverse.scm: New file.
	* read.scm: Maybe-load rtl-traverse.scm.

	* rtl.scm (-rtx-valid-types): Add SETRTX.

	* rtx-funcs.scm (nop,parallel): Fix mode.

	* utils.scm (eqv-lookup-index): New fn.
	(assq-lookup-index): Renamed from lookup-index.  All callers updated.

	* dev.scm (load-doc): Set APPLICATION.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
@


1.4.6.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2009 Red Hat, Inc.
@


1.3
log
@	Better handling of 64 bit and mixed 32/64 bit architectures.
	* hardware.scm (hw-update-word-modes!): New fn.
	* mach.scm (define-cpu)): Call mode-set-word-modes!,
	hw-update-word-modes!.
	(state-word-bitsize): Replace FIXME with requested check.
	(arch-analyze-insns!): Call mode-ensure-word-sizes-defined.
	* mode.scm (mode-find): Ignore INT,UINT.
	(-mode-word-sizes-kind): New global.
	(mode-set-word-modes!,mode-set-identical-word-bitsizes!,
	mode-set-biggest-word-bitsizes!,mode-ensure-word-sizes-defined): New fns.
	(mode-init!): Initialize -mode-word-sizes-kind.  Move initialization
	of mode-list to ...
	(mode-builtin!): ... here.  Initialize WI/UWI/AI/IAI to something
	unusable, correct values set later.
	(mode-finish!): Remove cruft.
	* html.scm (doc-init!): Call mode-set-biggest-word-bitsizes!.
	* opcodes.scm (opcodes-init!): Ditto.
	* rtx-funcs.scm (annul): Fix mode of pc.
	* cpu/ia64.cpu: Remove cruft that sets word modes.
	* cpu/xstormy16.cpu (define-cpu): Set word-bitsize.
@
text
@d499 1
a499 1
     (OPTIONS VOIDFLTODE) (NA NA)
d983 1
a983 1
      (OPTIONS VOIDFLTODE LOCALS RTX . RTX) (NA NA NA VOID . VOID)
@


1.2
log
@	* dev.scm: Add srcdir to %load-path.

	* rtx-funcs.scm (subword): Mode of argument can be different
	than mode of result, so don't use OP0 to specify argument's mode.
@
text
@d320 1
a320 1
      (list 'c-call 'VOID "SEM_ANNUL_INSN" (list 'c-code 'AI "pc") yes?)
@


1.1
log
@Initial revision
@
text
@d429 1
a429 1
; Word numbering is from most signficant (word 0) to least (word N-1).
d434 5
d441 1
a441 1
     (OPTIONS NUMMODE RTX RTX) (NA NA OP0 INT)
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
