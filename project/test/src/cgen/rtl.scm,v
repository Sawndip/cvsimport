head	1.29;
access;
symbols
	sid-snapshot-20180601:1.29
	cgen-snapshot-20180601:1.29
	sid-snapshot-20180501:1.29
	cgen-snapshot-20180501:1.29
	sid-snapshot-20180401:1.29
	cgen-snapshot-20180401:1.29
	sid-snapshot-20180301:1.29
	cgen-snapshot-20180301:1.29
	sid-snapshot-20180201:1.29
	cgen-snapshot-20180201:1.29
	sid-snapshot-20180101:1.29
	cgen-snapshot-20180101:1.29
	sid-snapshot-20171201:1.29
	cgen-snapshot-20171201:1.29
	sid-snapshot-20171101:1.29
	cgen-snapshot-20171101:1.29
	sid-snapshot-20171001:1.29
	cgen-snapshot-20171001:1.29
	sid-snapshot-20170901:1.29
	cgen-snapshot-20170901:1.29
	sid-snapshot-20170801:1.29
	cgen-snapshot-20170801:1.29
	sid-snapshot-20170701:1.29
	cgen-snapshot-20170701:1.29
	sid-snapshot-20170601:1.29
	cgen-snapshot-20170601:1.29
	sid-snapshot-20170501:1.29
	cgen-snapshot-20170501:1.29
	sid-snapshot-20170401:1.29
	cgen-snapshot-20170401:1.29
	sid-snapshot-20170301:1.29
	cgen-snapshot-20170301:1.29
	sid-snapshot-20170201:1.29
	cgen-snapshot-20170201:1.29
	sid-snapshot-20170101:1.29
	cgen-snapshot-20170101:1.29
	sid-snapshot-20161201:1.29
	cgen-snapshot-20161201:1.29
	sid-snapshot-20161101:1.29
	cgen-snapshot-20161101:1.29
	sid-snapshot-20160901:1.29
	cgen-snapshot-20160901:1.29
	sid-snapshot-20160801:1.29
	cgen-snapshot-20160801:1.29
	sid-snapshot-20160701:1.29
	cgen-snapshot-20160701:1.29
	sid-snapshot-20160601:1.29
	cgen-snapshot-20160601:1.29
	sid-snapshot-20160501:1.29
	cgen-snapshot-20160501:1.29
	sid-snapshot-20160401:1.29
	cgen-snapshot-20160401:1.29
	sid-snapshot-20160301:1.29
	cgen-snapshot-20160301:1.29
	sid-snapshot-20160201:1.29
	cgen-snapshot-20160201:1.29
	sid-snapshot-20160101:1.29
	cgen-snapshot-20160101:1.29
	sid-snapshot-20151201:1.29
	cgen-snapshot-20151201:1.29
	sid-snapshot-20151101:1.29
	cgen-snapshot-20151101:1.29
	sid-snapshot-20151001:1.29
	cgen-snapshot-20151001:1.29
	sid-snapshot-20150901:1.29
	cgen-snapshot-20150901:1.29
	sid-snapshot-20150801:1.29
	cgen-snapshot-20150801:1.29
	sid-snapshot-20150701:1.29
	cgen-snapshot-20150701:1.29
	sid-snapshot-20150601:1.29
	cgen-snapshot-20150601:1.29
	sid-snapshot-20150501:1.29
	cgen-snapshot-20150501:1.29
	sid-snapshot-20150401:1.29
	cgen-snapshot-20150401:1.29
	sid-snapshot-20150301:1.29
	cgen-snapshot-20150301:1.29
	sid-snapshot-20150201:1.29
	cgen-snapshot-20150201:1.29
	sid-snapshot-20150101:1.29
	cgen-snapshot-20150101:1.29
	sid-snapshot-20141201:1.29
	cgen-snapshot-20141201:1.29
	sid-snapshot-20141101:1.29
	cgen-snapshot-20141101:1.29
	sid-snapshot-20141001:1.29
	cgen-snapshot-20141001:1.29
	sid-snapshot-20140901:1.29
	cgen-snapshot-20140901:1.29
	sid-snapshot-20140801:1.29
	cgen-snapshot-20140801:1.29
	sid-snapshot-20140701:1.29
	cgen-snapshot-20140701:1.29
	sid-snapshot-20140601:1.29
	cgen-snapshot-20140601:1.29
	sid-snapshot-20140501:1.29
	cgen-snapshot-20140501:1.29
	sid-snapshot-20140401:1.29
	cgen-snapshot-20140401:1.29
	sid-snapshot-20140301:1.29
	cgen-snapshot-20140301:1.29
	sid-snapshot-20140201:1.29
	cgen-snapshot-20140201:1.29
	sid-snapshot-20140101:1.29
	cgen-snapshot-20140101:1.29
	sid-snapshot-20131201:1.29
	cgen-snapshot-20131201:1.29
	sid-snapshot-20131101:1.29
	cgen-snapshot-20131101:1.29
	sid-snapshot-20131001:1.29
	cgen-snapshot-20131001:1.29
	sid-snapshot-20130901:1.29
	cgen-snapshot-20130901:1.29
	sid-snapshot-20130801:1.29
	cgen-snapshot-20130801:1.29
	sid-snapshot-20130701:1.29
	cgen-snapshot-20130701:1.29
	sid-snapshot-20130601:1.29
	cgen-snapshot-20130601:1.29
	sid-snapshot-20130501:1.29
	cgen-snapshot-20130501:1.29
	sid-snapshot-20130401:1.29
	cgen-snapshot-20130401:1.29
	sid-snapshot-20130301:1.29
	cgen-snapshot-20130301:1.29
	sid-snapshot-20130201:1.29
	cgen-snapshot-20130201:1.29
	sid-snapshot-20130101:1.29
	cgen-snapshot-20130101:1.29
	sid-snapshot-20121201:1.29
	cgen-snapshot-20121201:1.29
	sid-snapshot-20121101:1.29
	cgen-snapshot-20121101:1.29
	sid-snapshot-20121001:1.29
	cgen-snapshot-20121001:1.29
	sid-snapshot-20120901:1.29
	cgen-snapshot-20120901:1.29
	sid-snapshot-20120801:1.29
	cgen-snapshot-20120801:1.29
	sid-snapshot-20120701:1.29
	cgen-snapshot-20120701:1.29
	sid-snapshot-20120601:1.29
	cgen-snapshot-20120601:1.29
	sid-snapshot-20120501:1.29
	cgen-snapshot-20120501:1.29
	sid-snapshot-20120401:1.29
	cgen-snapshot-20120401:1.29
	sid-snapshot-20120301:1.29
	cgen-snapshot-20120301:1.29
	sid-snapshot-20120201:1.29
	cgen-snapshot-20120201:1.29
	sid-snapshot-20120101:1.29
	cgen-snapshot-20120101:1.29
	sid-snapshot-20111201:1.29
	cgen-snapshot-20111201:1.29
	sid-snapshot-20111101:1.29
	cgen-snapshot-20111101:1.29
	sid-snapshot-20111001:1.29
	cgen-snapshot-20111001:1.29
	sid-snapshot-20110901:1.29
	cgen-snapshot-20110901:1.29
	sid-snapshot-20110801:1.29
	cgen-snapshot-20110801:1.29
	sid-snapshot-20110701:1.29
	cgen-snapshot-20110701:1.29
	sid-snapshot-20110601:1.29
	cgen-snapshot-20110601:1.29
	sid-snapshot-20110501:1.29
	cgen-snapshot-20110501:1.29
	sid-snapshot-20110401:1.29
	cgen-snapshot-20110401:1.29
	sid-snapshot-20110301:1.29
	cgen-snapshot-20110301:1.29
	sid-snapshot-20110201:1.29
	cgen-snapshot-20110201:1.29
	sid-snapshot-20110101:1.29
	cgen-snapshot-20110101:1.29
	sid-snapshot-20101201:1.29
	cgen-snapshot-20101201:1.29
	sid-snapshot-20101101:1.29
	cgen-snapshot-20101101:1.29
	sid-snapshot-20101001:1.29
	cgen-snapshot-20101001:1.29
	sid-snapshot-20100901:1.29
	cgen-snapshot-20100901:1.29
	sid-snapshot-20100801:1.29
	cgen-snapshot-20100801:1.29
	sid-snapshot-20100701:1.29
	cgen-snapshot-20100701:1.29
	sid-snapshot-20100601:1.29
	cgen-snapshot-20100601:1.29
	sid-snapshot-20100501:1.29
	cgen-snapshot-20100501:1.29
	sid-snapshot-20100401:1.29
	cgen-snapshot-20100401:1.29
	sid-snapshot-20100301:1.29
	cgen-snapshot-20100301:1.29
	sid-snapshot-20100201:1.29
	cgen-snapshot-20100201:1.29
	sid-snapshot-20100101:1.28
	cgen-snapshot-20100101:1.28
	sid-snapshot-20091201:1.28
	cgen-snapshot-20091201:1.28
	sid-snapshot-20091101:1.25
	cgen-snapshot-20091101:1.25
	sid-snapshot-20091001:1.25
	cgen-snapshot-20091001:1.25
	arc-sim-20090309:1.9
	sid-snapshot-20090901:1.16
	cgen-snapshot-20090901:1.16
	sid-snapshot-20090801:1.12
	cgen-snapshot-20090801:1.12
	sid-snapshot-20090701:1.11
	cgen-snapshot-20090701:1.11
	dje-cgen-play1-branch:1.11.0.2
	dje-cgen-play1-branchpoint:1.11
	cgen-1_1-branch:1.9.0.6
	cgen-1_1-branchpoint:1.9
	sid-snapshot-20090601:1.9
	cgen-snapshot-20090601:1.9
	sid-snapshot-20090501:1.9
	cgen-snapshot-20090501:1.9
	sid-snapshot-20090401:1.9
	cgen-snapshot-20090401:1.9
	arc-insight_6_8-branch:1.9.0.4
	arc-insight_6_8-branchpoint:1.9
	sid-snapshot-20090301:1.9
	cgen-snapshot-20090301:1.9
	sid-snapshot-20090201:1.9
	cgen-snapshot-20090201:1.9
	sid-snapshot-20090101:1.9
	cgen-snapshot-20090101:1.9
	sid-snapshot-20081201:1.9
	cgen-snapshot-20081201:1.9
	sid-snapshot-20081101:1.9
	cgen-snapshot-20081101:1.9
	sid-snapshot-20081001:1.9
	cgen-snapshot-20081001:1.9
	sid-snapshot-20080901:1.9
	cgen-snapshot-20080901:1.9
	sid-snapshot-20080801:1.9
	cgen-snapshot-20080801:1.9
	sid-snapshot-20080701:1.9
	cgen-snapshot-20080701:1.9
	sid-snapshot-20080601:1.9
	cgen-snapshot-20080601:1.9
	sid-snapshot-20080501:1.9
	cgen-snapshot-20080501:1.9
	sid-snapshot-20080403:1.9
	sid-snapshot-20080401:1.9
	cgen-snapshot-20080401:1.9
	sid-snapshot-20080301:1.9
	cgen-snapshot-20080301:1.9
	sid-snapshot-20080201:1.9
	cgen-snapshot-20080201:1.9
	sid-snapshot-20080101:1.9
	cgen-snapshot-20080101:1.9
	sid-snapshot-20071201:1.9
	cgen-snapshot-20071201:1.9
	sid-snapshot-20071101:1.9
	cgen-snapshot-20071101:1.9
	sid-snapshot-20071001:1.9
	cgen-snapshot-20071001:1.9
	msnyder-fork-checkpoint-branch:1.9.0.2
	msnyder-fork-checkpoint-branchpoint:1.9
	sid-20020905-branchpoint:1.4
	sid-20020905-branch:1.4.0.6
	cagney_regbuf-20020515-branch:1.4.0.4
	cagney_regbuf-20020515-branchpoint:1.4
	cygnus_cvs_20020108_pre:1.4
	cgen-1-1-branch:1.4.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.29
date	2010.01.21.07.34.56;	author devans;	state Exp;
branches;
next	1.28;

1.28
date	2009.11.23.09.03.01;	author devans;	state Exp;
branches;
next	1.27;

1.27
date	2009.11.05.16.55.33;	author devans;	state Exp;
branches;
next	1.26;

1.26
date	2009.11.03.16.24.02;	author devans;	state Exp;
branches;
next	1.25;

1.25
date	2009.09.30.06.21.20;	author devans;	state Exp;
branches;
next	1.24;

1.24
date	2009.09.25.19.40.08;	author devans;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.23.22.30.19;	author devans;	state Exp;
branches;
next	1.22;

1.22
date	2009.09.23.17.19.23;	author devans;	state Exp;
branches;
next	1.21;

1.21
date	2009.09.21.15.24.20;	author devans;	state Exp;
branches;
next	1.20;

1.20
date	2009.09.20.21.22.03;	author devans;	state Exp;
branches;
next	1.19;

1.19
date	2009.09.12.17.34.15;	author devans;	state Exp;
branches;
next	1.18;

1.18
date	2009.09.07.22.17.34;	author devans;	state Exp;
branches;
next	1.17;

1.17
date	2009.09.03.17.13.02;	author devans;	state Exp;
branches;
next	1.16;

1.16
date	2009.08.28.06.20.28;	author devans;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.27.21.28.48;	author devans;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.27.05.47.12;	author devans;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.12.22.33.37;	author devans;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.21.05.44.41;	author devans;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.22.05.14.09;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.27.20.31.12;	author jimb;	state Exp;
branches
	1.9.6.1;
next	1.8;

1.8
date	2005.01.20.22.57.10;	author jimb;	state Exp;
branches;
next	1.7;

1.7
date	2003.07.16.05.35.47;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.10.21.22.03;	author devans;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.20.06.39.04;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.01.21.21.30;	author fche;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.29.18.56.26;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.08.18.44.23;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.9.6.1
date	2009.06.24.14.57.46;	author devans;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.29
log
@	* rtl-traverse.scm (/rtx-canon-anycexprmode): New function.
	(/rtx-make-canon-table): Add entry for ANYCEXPRMODE.
	(/rtx-canon-operands): Print expr-mode if /rtx-canon-debug?
	Do final error check on mode assigned to expression.
	(/rtx-make-traverser-table): Add entry for ANYCEXPRMODE.
	* rtl-xform.scm (/rtx-trim-args): Handle ANYCEXPRMODE.
	* rtl.scm (/rtx-valid-mode-types): Add ANYCEXPRMODE.
	* rtx-funcs.scm (c-code, c-call, c-raw-call): Use ANYCEXPRMODE.
	(if, cond, case): Use ANYEXPRMODE.
@
text
@; Basic RTL support.
; Copyright (C) 2000, 2001, 2009, 2010 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.

; The name for the description language has been changed a couple of times.
; RTL isn't my favorite because of perceived confusion with GCC
; (and perceived misinterpretation of intentions!).
; On the other hand my other choices were taken (and believed to be
; more confusing).
;
; RTL functions are described by class <rtx-func>.
; The complete list of rtl functions is defined in doc/rtl.texi.

; Conventions used in this file:
; - procs that perform the basic rtl or semantic expression manipulation that
;   is for public use shall be prefixed with "s-" or "rtl-" or "rtx-"
; - no other procs shall be so prefixed
; - rtl globals and other rtx-func object support shall be prefixed with
;   "-rtx[-:]"
; - no other procs shall be so prefixed

; Class for defining rtx nodes.

; FIXME: Add new members that are lambda's to perform the argument checking
; specified by `arg-types' and `arg-modes'.  This will save a lookup during
; traversing.  It will also allow custom versions for oddballs (e.g. for
; `member' we want to verify the 2nd arg is a `number-list' rtx).
; ??? Still useful?

(define <rtx-func>
  (class-make '<rtx-func> nil
	      '(
		; name as it appears in RTL
		; must be accessed via obj:name
		name

		; argument list
		; ??? Not used I think, but keep.
		args

		; result mode, or #f if from arg 2
		; (or the containing expression when canonicalizing)
		result-mode

		; types of each argument, as symbols
		; This is #f for macros.
		; Possible values:
		; OPTIONS - optional list of keyword-prefixed options
		; ANYINTMODE - any integer mode
		; ANYFLOATMODE - any floating point mode
		; ANYNUMMODE - any numeric mode
		; ANYEXPRMODE - VOID, PTR, SYM, or any numeric mode
		; ANYCEXPRMODE - VOID, PTR, or any numeric mode
		; EXPLNUMMODE - explicit numeric mode, can't be DFLT or VOID
		; VOIDORNUMMODE - VOID or any numeric mode
		; VOIDMODE - must be `VOID'
		; BIMODE - BI (boolean or bit int)
		; INTMODE - must be `INT'
		; SYMMODE - must be SYM
		; INSNMODE - must be INSN
		; MACHMODE - must be MACH
		; RTX - any rtx
		; SETRTX - any rtx allowed to be `set'
		; TESTRTX - the test of an `if'
		; CONDRTX - a cond expression ((test) rtx ... rtx)
		; CASERTX - a case expression ((symbol .. symbol) rtx ... rtx)
		; LOCALS - the locals list of a sequence
		; ITERATION - the iteration 
		; SYMBOLLIST - used for ISA name lists
		; ENVSTACK - environment stack
		; ATTRS - attribute list
		; SYMBOL - arg must be a symbol
		; STRING - arg must be a string
		; NUMBER - arg must be a number
		; SYMORNUM - arg must be a symbol or number
		; OBJECT - arg is an object (FIXME: restrict to <operand>?)
		arg-types

		; required mode of each argument
		; This is #f for macros.
		; Possible values include any mode name and:
		; ANY - any mode
		; ANYINT - any integer mode
		; NA - not applicable
		; MATCHEXPR - mode has to match the mode specified in the
		;             containing expression
		;             NOTE: This isn't necessarily the mode of the
		;             result of the expression.  E.g. in `set', the
		;             result always has mode VOID, but the mode
		;             specified in the expression is the mode of the
		;             set destination.
		; MATCHSEQ - for sequences
		;            last expression has to match mode of sequence,
		;            preceding expressions must be VOID
		; MATCH2 - must match mode of arg 2
		; MATCH3 - must match mode of arg 3
		; <MODE-NAME> - must match specified mode
		arg-modes

		; arg number of the MATCHEXPR arg,
		; or #f if there is none
		matchexpr-index

		; The class of rtx.
		; This is #f for macros.
		; ARG - operand, local, const
		; SET - set, set-quiet
		; UNARY - not, inv, etc.
		; BINARY - add, sub, etc.
		; TRINARY - addc, subc, etc.
		; COMPARE - eq, ne, etc.
		; IF - if
		; COND - cond, case
		; SEQUENCE - sequence, parallel
		; UNSPEC - c-call
		; MISC - everything else
		class

		; A symbol indicating the flavour of rtx node this is.
		; FUNCTION - normal function
		; SYNTAX - don't pre-eval arguments
		; OPERAND - result is an operand
		; MACRO - converts one rtx expression to another
		; The word "style" was chosen to be sufficiently different
		; from "type", "kind", and "class".
		style

		; A function to perform the rtx.
		evaluator

		; Ordinal number of rtx.  Used to index into tables.
		num
		)
	      nil)
)

; Predicate.

(define (rtx-func? x) (class-instance? <rtx-func> x))

; Accessor fns

(define-getters <rtx-func> rtx
  (result-mode arg-types arg-modes matchexpr-index class style evaluator num)
)

(define (rtx-style-syntax? rtx) (eq? (rtx-style rtx) 'syntax))

; Add standard `get-name' method since this isn't a subclass of <ident>.

(method-make! <rtx-func> 'get-name (lambda (self) (elm-get self 'name)))

; List of mode types for arg-types.

(define /rtx-valid-mode-types
  '(
    ANYINTMODE ANYFLOATMODE ANYNUMMODE ANYEXPRMODE ANYCEXPRMODE EXPLNUMMODE
    VOIDORNUMMODE VOIDMODE BIMODE INTMODE SYMMODE INSNMODE MACHMODE
   )
)

; List of valid values for arg-types, not including mode names.

(define /rtx-valid-types
  (append
   '(OPTIONS)
    /rtx-valid-mode-types
    '(RTX SETRTX TESTRTX CONDRTX CASERTX)
    '(LOCALS ITERATION SYMBOLLIST ENVSTACK ATTRS)
    '(SYMBOL STRING NUMBER SYMORNUM OBJECT)
    )
)

; List of valid mode matchers, excluding mode names.

(define /rtx-valid-matches
  '(ANY ANYINT NA MATCHEXPR MATCHSEQ MATCH2 MATCH3)
)

;; Return arg number of MATCHEXPR in ARG-MODES or #f if not present.

(define (/rtx-find-matchexpr-index arg-modes)
  ;; We can't use find-first-index here because arg-modes can be an
  ;; improper list (a b c . d).
  ;;(find-first-index 0 (lambda (t) (eq? t 'MATCHEXPR)) arg-modes)
  (define (improper-find-first-index i pred l)
    (cond ((null? l) #f)
	  ((pair? l)
	   (cond ((pred (car l)) i)
		 (else (improper-find-first-index (+ 1 i) pred (cdr l)))))
	  ((pred l) i)
	  (else #f)))
  (improper-find-first-index 0 (lambda (t) (eq? t 'MATCHEXPR)) arg-modes)
)

; List of all defined rtx names.  This can be map'd over without having
; to know the innards of /rtx-func-table (which is a hash table).

(define /rtx-name-list nil)
(define (rtx-name-list) /rtx-name-list)

; Table of rtx function objects.
; This is set in rtl-init!.

(define /rtx-func-table nil)

; Look up the <rtx-func> object for RTX-KIND.
; Returns the object or #f if not found.
; RTX-KIND is the name of the rtx function.

(define (rtx-lookup rtx-kind)
  (assert (symbol? rtx-kind))
  (hashq-ref /rtx-func-table rtx-kind)
)

; Table of rtx macro objects.
; This is set in rtl-init!.

(define /rtx-macro-table nil)

; Table of operands, modes, and other non-functional aspects of RTL.
; This is defined in rtl-finish!, after all operands have been read in.

(define /rtx-operand-table nil)

; Number of next rtx to be defined.

(define /rtx-num-next #f)

; Return the number of rtx's.

(define (rtx-max-num)
  /rtx-num-next
)

; Define Rtx Node
;
; Add an entry to the rtx function table.
; NAME-ARGS is a list of the operation name and arguments.
; The mode of the result must be the first element in `args' (if there are
; any arguments).
; ARG-TYPES is a list of argument types (/rtx-valid-types).
; ARG-MODES is a list of mode matchers (/rtx-valid-matches).
; CLASS is the class of the rtx to be created.
; ACTION is a list of Scheme expressions to perform the operation.
;
; ??? Note that we can support variables.  Not sure it should be done.

(define (def-rtx-node name-args result-mode arg-types arg-modes class action)
  (let* ((name (car name-args))
	 (args (cdr name-args))
	 (context (make-prefix-context (string-append "defining rtx "
						      (symbol->string name))))
	 (matchexpr-index (/rtx-find-matchexpr-index arg-modes)))

;    (map1-improper (lambda (arg-type)
;		     (if (not (memq arg-type /rtx-valid-types))
;			 (context-error context "While defining rtx functions"
;					"invalid arg type" arg-type)))
;		   arg-types)
;    (map1-improper (lambda (arg-mode)
;		     (if (and (not (memq arg-mode /rtx-valid-matches))
;			      (not (symbol? arg-mode))) ;; FIXME: mode-name?
;			 (context-error context "While defining rtx functions"
;					"invalid arg mode match" arg-mode)))
;		   arg-modes)

    (let ((rtx (make <rtx-func> name args
		     result-mode arg-types arg-modes matchexpr-index
		     class
		     'function
		     (if action
			 (eval1 (list 'lambda
				      (cons '*estate* args)
				      action))
			 #f)
		     /rtx-num-next)))
      ; Add it to the table of rtx handlers.
      (hashq-set! /rtx-func-table name rtx)
      (set! /rtx-num-next (+ /rtx-num-next 1))
      (set! /rtx-name-list (cons name /rtx-name-list))
      *UNSPECIFIED*))
)

(define define-rtx-node
  ; Written this way so Hobbit can handle it.
  (defmacro:syntax-transformer (lambda arg-list
				 (apply def-rtx-node arg-list)
				 nil))
)

; Same as define-rtx-node but don't pre-evaluate the arguments.
; Remember that `mode' must be the first argument.

(define (def-rtx-syntax-node name-args result-mode arg-types arg-modes class action)
  (let ((name (car name-args))
	(args (cdr name-args))
	(matchexpr-index (/rtx-find-matchexpr-index arg-modes)))
    (let ((rtx (make <rtx-func> name args
		     result-mode arg-types arg-modes matchexpr-index
		     class
		     'syntax
		     (if action
			 (eval1 (list 'lambda
				      (cons '*estate* args)
				      action))
			 #f)
		     /rtx-num-next)))
      ; Add it to the table of rtx handlers.
      (hashq-set! /rtx-func-table name rtx)
      (set! /rtx-num-next (+ /rtx-num-next 1))
      (set! /rtx-name-list (cons name /rtx-name-list))
      *UNSPECIFIED*))
)

(define define-rtx-syntax-node
  ; Written this way so Hobbit can handle it.
  (defmacro:syntax-transformer (lambda arg-list
				 (apply def-rtx-syntax-node arg-list)
				 nil))
)

; Same as define-rtx-node but return an operand (usually an <operand> object).
; ??? `mode' must be the first argument?

(define (def-rtx-operand-node name-args result-mode arg-types arg-modes class action)
  ; Operand nodes must specify an action.
  (assert action)
  (let ((name (car name-args))
	(args (cdr name-args))
	(matchexpr-index (/rtx-find-matchexpr-index arg-modes)))
    (let ((rtx (make <rtx-func> name args
		     result-mode arg-types arg-modes matchexpr-index
		     class
		     'operand
		     (eval1 (list 'lambda
				  (cons '*estate* args)
				  action))
		     /rtx-num-next)))
      ; Add it to the table of rtx handlers.
      (hashq-set! /rtx-func-table name rtx)
      (set! /rtx-num-next (+ /rtx-num-next 1))
      (set! /rtx-name-list (cons name /rtx-name-list))
      *UNSPECIFIED*))
)

(define define-rtx-operand-node
  ; Written this way so Hobbit can handle it.
  (defmacro:syntax-transformer (lambda arg-list
				 (apply def-rtx-operand-node arg-list)
				 nil))
)

; Convert one rtx expression into another.
; NAME-ARGS is a list of the operation name and arguments.
; ACTION is a list of Scheme expressions to perform the operation.
; The result of ACTION must be another rtx expression (a list).

(define (def-rtx-macro-node name-args action)
  ; macro nodes must specify an action
  (assert action)
  (let ((name (car name-args))
	(args (cdr name-args)))
    (let ((rtx (make <rtx-func> name args #f #f #f #f
		     #f ; class
		     'macro
		     (eval1 (list 'lambda args action))
		     /rtx-num-next)))
      ; Add it to the table of rtx macros.
      (hashq-set! /rtx-macro-table name rtx)
      (set! /rtx-num-next (+ /rtx-num-next 1))
      (set! /rtx-name-list (cons name /rtx-name-list))
      *UNSPECIFIED*))
)

(define define-rtx-macro-node
  ; Written this way so Hobbit can handle it.
  (defmacro:syntax-transformer (lambda arg-list
				 (apply def-rtx-macro-node arg-list)
				 nil))
)

; RTL macro expansion.
; RTL macros are different than pmacros.  The difference is that the expansion
; happens internally, RTL macros are part of the language.

; Lookup MACRO-NAME and return its <rtx-func> object or #f if not found.

(define (/rtx-macro-lookup macro-name)
  (hashq-ref /rtx-macro-table macro-name)
)

; Lookup (car exp) and return the macro's lambda if it is one or #f.

(define (/rtx-macro-check exp fn-getter)
  (let ((macro (hashq-ref /rtx-macro-table (car exp))))
    (if macro
	(fn-getter macro)
	#f))
)

; Expand a list.

(define (/rtx-macro-expand-list exp fn-getter)
  (let ((macro (/rtx-macro-check exp fn-getter)))
    (if macro
	(apply macro (map (lambda (x) (/rtx-macro-expand x fn-getter))
			  (cdr exp)))
	(map (lambda (x) (/rtx-macro-expand x fn-getter))
	     exp)))
)

; Main entry point to expand a macro invocation.

(define (/rtx-macro-expand exp fn-getter)
  (if (pair? exp) ; pair? -> cheap (and (not (null? exp)) (list? exp))
      (let ((result (/rtx-macro-expand-list exp fn-getter)))
	; If the result is a new macro invocation, recurse.
	(if (pair? result)
	    (let ((macro (/rtx-macro-check result fn-getter)))
	      (if macro
		  (/rtx-macro-expand (apply macro (cdr result)) fn-getter)
		  result))
	    result))
      exp)
)

; Publically accessible version.

(define rtx-macro-expand /rtx-macro-expand)

; RTX mode support.

; Get implied mode of X, either an operand expression, sequence temp, or
; a hardware reference expression.
; The result is the name of the mode.

(define (rtx-lvalue-mode-name estate x)
  (assert (rtx? x))
  (case (car x)
;    ((operand) (obj:name (op:mode (current-op-lookup (cadr x) (obj-isa-list (estate-owner estate))))))
    ((xop) (obj:name (send (rtx-xop-obj x) 'get-mode)))
;    ((opspec)
;     (if (eq? (rtx-opspec-mode x) 'VOID)
;	 (rtx-lvalue-mode-name estate (rtx-opspec-hw-ref x))
;	 (rtx-opspec-mode x)))
;    ((reg mem) (cadr x))
    ((local) ;; (local options mode name)
     (let* ((name (cadddr x))
	    (temp (rtx-temp-lookup (estate-env-stack estate) name)))
       (if (not temp)
	   (estate-error estate "unknown local" name))
       (obj:name (rtx-temp-mode temp))))
    (else
     (estate-error error
		   "rtx-lvalue-mode-name: not an operand or hardware reference:"
		   x)))
)

; Lookup the mode to use for semantic operations (unsigned modes aren't
; allowed since we don't have ANDUSI, etc.).
; MODE is a <mode> object.
; ??? I have actually implemented both ways (full use of unsigned modes
; and mostly hidden use of unsigned modes).  Neither makes me real
; comfortable, though I liked bringing unsigned modes out into the open
; even if it doubled the number of semantic operations.

(define (rtx-sem-mode mode) (or (mode:sem-mode mode) mode))

; Return the mode of object OBJ.

(define (rtx-obj-mode obj) (send obj 'get-mode))

; Return a boolean indicating of modes M1,M2 are compatible.
; M1,M2 are <mode> objects.

(define (rtx-mode-compatible? m1 m2)
  ;; ??? This is more permissive than is perhaps proper.
  (let ((mode1 (rtx-sem-mode m1))
	(mode2 (rtx-sem-mode m2)))
    ;;(eq? (obj:name mode1) (obj:name mode2)))
    (mode-compatible? 'sameclass mode1 mode2))
)

; Environments (sequences with local variables).

; Temporaries are created within a sequence.
; MODE is a <mode> object.
; VALUE is #f if not set yet.
; e.g. (sequence ((WI tmp)) (set tmp reg0) ...)
; ??? Perhaps what we want here is `let' but for now I prefer `sequence'.
; This isn't exactly `let' either as no initial value is specified.
; Environments are also used to specify incoming values from the top level.

(define <rtx-temp> (class-make '<rtx-temp> nil '(name mode value) nil))

;(define cx-temp:name (elm-make-getter <c-expr-temp> 'name))
;(define cx-temp:mode (elm-make-getter <c-expr-temp> 'mode))
;(define cx-temp:value (elm-make-getter <c-expr-temp> 'value))

(define-getters <rtx-temp> rtx-temp (name mode value))

(method-make!
 <rtx-temp> 'make!
 (lambda (self name mode value)
   (assert (mode? mode))
   (elm-set! self 'name name)
   (elm-set! self 'mode mode)
   (elm-set! self 'value (if value value (gen-temp name)))
   self)
)

(define (gen-temp name)
  ; ??? calls to gen-c-symbol don't belong here
  (string-append "tmp_" (gen-c-symbol name))
)

; Return a boolean indicating if X is an <rtx-temp>.

(define (rtx-temp? x) (class-instance? <rtx-temp> x))

; Respond to 'get-mode messages.

(method-make! <rtx-temp> 'get-mode (lambda (self) (elm-get self 'mode)))

; Respond to 'get-name messages.

(method-make! <rtx-temp> 'get-name (lambda (self) (elm-get self 'name)))

; An environment is a list of <rtx-temp> objects.
; An environment stack is a list of environments.

(define (rtx-env-stack-empty? env-stack) (null? env-stack))
(define (rtx-env-stack-head env-stack) (car env-stack))
(define (rtx-env-empty-stack) nil)
(define (rtx-env-init-stack1 vars-alist)
  (if (null? vars-alist)
      nil
      (cons (rtx-env-make vars-alist) nil))
)
(define (rtx-env-empty? env) (null? env))

;; Create an environment from VAR-ALIST,
;; an alist of (name <mode>-or-mode-name value) elements,
;; or, in the case of /rtx-closure-make, a list of (name . <rtx-temp>).

(define (rtx-env-make var-alist)
  ;; Check for an already-compiled environment, for /rtx-closure-make's sake.
  (if (and (pair? var-alist)
	   (rtx-temp? (cdar var-alist)))
      var-alist
      ;; Convert VAR-ALIST to an associative list of <rtx-temp> objects.
      (map (lambda (var-spec)
	     (cons (car var-spec)
		   (make <rtx-temp>
		     (car var-spec)
		     (mode-maybe-lookup (cadr var-spec))
		     (caddr var-spec))))
	   var-alist))
)

; Create an initial environment with local variables.
; VAR-LIST is a list of (mode-name name) elements, i.e. the locals argument to
; `sequence' or equivalent thereof.

(define (rtx-env-make-locals var-list)
  ; Convert VAR-LIST to an associative list of <rtx-temp> objects.
  (map (lambda (var-spec)
	 (cons (cadr var-spec)
	       (make <rtx-temp>
		 (cadr var-spec) (mode:lookup (car var-spec)) #f)))
       var-list)
)

; Return the symbol name of the limit variable of `do-count'
; given iteration-variable ITER-VAR.
; ??? We don't publish that this variable is available to use, but we could.

(define (rtx-make-iteration-limit-var iter-var)
  (symbol-append iter-var '-limit)
)

; Create an environment with the iteration local variables of `do-count'.

(define (rtx-env-make-iteration-locals iter-var)
  (rtx-env-make-locals (list (list 'INT iter-var)
			     (list 'INT (rtx-make-iteration-limit-var iter-var))))
)

;; Convert an alist of (name <mode>-object-or-name value) to
;; an environment.

(define (rtx-var-alist-to-env var-alist) var-alist)

;; Convert an alist of (name <mode>-object-or-name value) to
;; an environment stack.

(define (rtx-var-alist-to-closure-env-stack var-alist)
  ;; Preserve emptiness so (null? env-stack) works.
  (if (null? var-alist)
      nil
      (list var-alist))
)

;; Convert the source form of an env-stack, e.g. as used in a closure,
;; to the internal form, which is (name <rtx-temp>-object).

(define (rtx-make-env-stack closure-env-stack)
  (map rtx-env-make closure-env-stack)
)

; Push environment ENV onto the front of environment stack ENV-STACK,
; returning a new object.  ENV-STACK is not modified.

(define (rtx-env-push env-stack env)
  (cons env env-stack)
)

; Lookup variable NAME in environment stack ENV-STACK.
; The result is the <rtx-temp> object.

(define (rtx-temp-lookup env-stack name)
  (let loop ((stack env-stack))
    (if (null? stack)
	#f
	(let ((temp (assq-ref (car stack) name)))
	  (if temp
	      temp
	      (loop (cdr stack))))))
)

; Create a "closure" of EXPR using the current ISA list and temp stack.
; MODE is the mode name.

(define (/rtx-closure-make estate mode expr)
  ;; NOTE: This records the "compiled" environment stack in the closure.
  (rtx-make 'closure mode (estate-isas estate) (estate-env-stack estate)
	    expr)
)

(define (rtx-env-stack-dump env-stack)
  (let ((stack env-stack))
    (if (rtx-env-stack-empty? stack)
	(display "rtx-env stack (empty):\n")
	(let loop ((stack stack) (level 0))
	  (if (null? stack)
	      #f ; done
	      (begin
		(display "rtx-env stack, level ")
		(display level)
		(display ":\n")
		(for-each (lambda (var)
			    (display "  ")
			    ;(display (obj:name (rtx-temp-mode (cdr var))))
			    ;(display " ")
			    (display (rtx-temp-name (cdr var)))
			    (newline))
			  (car stack))
		(loop (cdr stack) (+ level 1)))))))
)

; Build, test, and analyze various kinds of rtx's.
; ??? A lot of this could be machine generated except that I don't yet need
; that much.

(define (rtx-make kind . args)
  (cons kind (rtx-munge-mode&options (rtx-lookup kind) 'DFLT kind args))
)

(define rtx-name car)
(define (rtx-kind? kind rtx) (eq? kind (rtx-name rtx)))

(define (rtx-make-const mode value) (rtx-make 'const mode value))
(define (rtx-make-enum mode value) (rtx-make 'enum mode value))

(define (rtx-constant? rtx) (memq (rtx-name rtx) '(const enum)))

; Return value of constant RTX (either const or enum).
(define (rtx-constant-value rtx)
  (case (rtx-name rtx)
    ((const) (rtx-const-value rtx))
    ((enum) (car (enum-lookup-val (rtx-enum-value rtx))))
    (else (error "rtx-constant-value: not const or enum" rtx)))
)

(define rtx-options cadr)
(define rtx-mode caddr)
(define rtx-args cdddr)
(define rtx-arg1 cadddr)
(define (rtx-arg2 rtx) (car (cddddr rtx)))

(define rtx-const-value rtx-arg1)
(define rtx-enum-value rtx-arg1)

(define rtx-reg-name rtx-arg1)

; Return register number or #f if absent.
; (reg options mode hw-name [regno [selector]])
(define (rtx-reg-number rtx) (list-maybe-ref rtx 4))

; Return register selector or #f if absent.
(define (rtx-reg-selector rtx) (list-maybe-ref rtx 5))

; Return both register number and selector.
(define rtx-reg-index-sel cddddr)

; Return memory address.
(define rtx-mem-addr rtx-arg1)

; Return memory selector or #f if absent.
(define (rtx-mem-sel mem) (list-maybe-ref mem 4))

; Return both memory address and selector.
(define rtx-mem-index-sel cdddr)

; Return MEM with new address NEW-ADDR.
; ??? Complicate as necessary.
(define (rtx-change-address mem new-addr)
  (rtx-make 'mem
	    (rtx-options mem)
	    (rtx-mode mem)
	    new-addr
	    (rtx-mem-sel mem))
)

; Return argument to `symbol' rtx.
(define rtx-symbol-name rtx-arg1)

(define (rtx-make-ifield mode-name ifield-name)
  (rtx-make 'ifield mode-name ifield-name)
)
(define (rtx-ifield? rtx) (eq? 'ifield (rtx-name rtx)))
(define (rtx-ifield-name rtx)
  (let ((ifield (rtx-arg1 rtx)))
    (if (symbol? ifield)
	ifield
	(obj:name ifield)))
)
(define (rtx-ifield-obj rtx)
  (let ((ifield (rtx-arg1 rtx)))
    (if (symbol? ifield)
	(current-ifld-lookup ifield)
	ifield))
)

(define (rtx-make-operand mode-name op-name)
  (rtx-make 'operand mode-name op-name)
)
(define (rtx-operand? rtx) (eq? 'operand (rtx-name rtx)))
;; FIXME: This should just fetch rtx-arg1,
;; operand rtxes shouldn't have objects, that's what xop is for.
(define (rtx-operand-name rtx)
  (let ((operand (rtx-arg1 rtx)))
    (if (symbol? operand)
	operand
	(obj:name operand)))
)

;; Given an operand rtx, return the <operand> object.
;; RTX must be canonical rtl.
;; ISA-NAME-LIST is the list of ISAs to look the operand up in.
;;
;; NOTE: op:mode-name can be DFLT, which means use the mode of the type.
;; It is up to the caller to deal with it.

(define (rtx-operand-obj rtx isa-name-list)
  (let ((op (current-op-lookup (rtx-arg1 rtx) isa-name-list))
	(mode-name (rtx-mode rtx)))
    (assert op)
    (assert (not (eq? mode-name 'DFLT)))
    ;; Ensure requested mode is supported by the hardware.
    ;; rtx-canonicalize should have verified this already (I think).
    (assert (hw-mode-ok? (op:type op) mode-name (op:index op)))
    op)
)

(define (rtx-make-local mode-name local-name)
  (rtx-make 'local mode-name local-name)
)
(define (rtx-local? rtx) (eq? 'local (rtx-name rtx)))
(define (rtx-local-name rtx)
  (let ((local (rtx-arg1 rtx)))
    (if (symbol? local)
	local
	(obj:name local)))
)
(define (rtx-local-obj rtx)
  (let ((local (rtx-arg1 rtx)))
    (if (symbol? local)
	(error "can't use rtx-local-obj on local name")
	local))
)

(define (rtx-make-xop op)
  (rtx-make 'xop (op:mode-name op) op)
)
(define rtx-xop-obj rtx-arg1)

;(define (rtx-opspec? rtx) (eq? 'opspec (rtx-name rtx)))
;(define (rtx-opspec-mode rtx) (rtx-mode rtx))
;(define (rtx-opspec-hw-ref rtx) (list-ref rtx 5))
;(define (rtx-opspec-set-op-num! rtx num) (set-car! (cddddr rtx) num))

(define rtx-index-of-value rtx-arg1)

(define (rtx-make-set dest src) (rtx-make 'set dest src))
(define rtx-set-dest rtx-arg1)
(define rtx-set-src rtx-arg2)
(define (rtx-single-set? rtx) (memq (car rtx) '(set set-quiet)))

(define rtx-alu-op-mode rtx-mode)
(define (rtx-alu-op-arg rtx n) (list-ref rtx (+ n 3)))

(define (rtx-boolif-op-arg rtx n) (list-ref rtx (+ n 3)))

(define rtx-cmp-op-mode rtx-mode)
(define (rtx-cmp-op-arg rtx n) (list-ref rtx (+ n 3)))

(define rtx-number-list-values cdddr)

(define rtx-member-value rtx-arg1)
(define (rtx-member-set rtx) (list-ref rtx 4))

(define rtx-if-mode rtx-mode)
(define (rtx-if-test rtx) (rtx-arg1 rtx))
(define (rtx-if-then rtx) (list-ref rtx 4))
; If `else' clause is missing the result is #f.
(define (rtx-if-else rtx) (list-maybe-ref rtx 5))

(define (rtx-eq-attr-owner rtx) (list-ref rtx 3))
(define (rtx-eq-attr-attr rtx) (list-ref rtx 4))
(define (rtx-eq-attr-value rtx) (list-ref rtx 5))

(define (rtx-sequence-locals rtx) (cadddr rtx))
(define (rtx-sequence-exprs rtx) (cddddr rtx))

; Same as rtx-sequence-locals except return in assq'able form.
; ??? Sometimes I think it should have been (sequence ((name MODE)) ...)
; instead of (sequence ((MODE name)) ...) from the beginning, sigh.

(define (rtx-sequence-assq-locals rtx)
  (let ((locals (rtx-sequence-locals rtx)))
    (map (lambda (local)
	   (list (cadr local) (car local)))
	 locals))
)

(define (rtx-closure-isas rtx) (list-ref rtx 3))
(define (rtx-closure-env-stack rtx) (list-ref rtx 4))
(define (rtx-closure-expr rtx) (list-ref rtx 5))

; Return a semi-pretty string describing RTX.
; This is used by hw to include the index in the element's name.

(define (rtx-pretty-name rtx)
  (if (pair? rtx)
      (case (car rtx)
	((const) (number->string (rtx-const-value rtx)))
	((operand) (symbol->string (rtx-operand-name rtx)))
	((local) (symbol->string (rtx-local-name rtx)))
	((xop) (symbol->string (obj:name (rtx-xop-obj rtx))))
	(else
	 (if (null? (cdr rtx))
	     (rtx-pretty-name (car rtx))
	     (apply stringsym-append
		    (cons (rtx-pretty-name (car rtx))
			  (map (lambda (elm)
				 (string-append "-" (rtx-pretty-name elm)))
			       (cdr rtx)))))))
      (stringize rtx "-"))
)

; Various rtx utilities.

; Dump an rtx expression.

(define (rtx-dump rtx)
  (cond ((list? rtx) (map rtx-dump rtx))
	((object? rtx) (string/symbol-append "#<object "
					     (object-class-name rtx)
					     " "
					     (obj:name rtx)
					     ">"))
	(else rtx))
)

; Dump an expression to a string.

(define (rtx-strdump rtx)
  (with-output-to-string
    (lambda ()
      ;; Use write instead of display, we want strings displayed with quotes.
      (write (rtx-dump rtx))))
)

;; Return the pretty-printed from of RTX.

(define (rtx-pretty-strdump rtx)
  (with-output-to-string
    (lambda ()
      (pretty-print (rtx-dump rtx))))
)

; Return a boolean indicating if EXPR is known to be a compile-time constant.

(define (rtx-compile-time-constant? expr)
  (cond ((pair? expr)
	 (case (car expr)
	   ((const enum) #t)
	   (else #f)))
	((memq expr '(FALSE TRUE)) #t)
	(else #f))
)

; Return boolean indicating if EXPR has side-effects.
; FIXME: for now punt.

(define (rtx-side-effects? expr)
  #f
)

; Return a boolean indicating if EXPR is a "true" boolean value.
;
; ??? In RTL, #t is a synonym for (const 1).  This is confusing for Schemers,
; so maybe RTL's #t should be renamed to TRUE.

(define (rtx-true? expr)
  (cond ((pair? expr)
	 (case (car expr)
	   ((const enum) (!= (rtx-constant-value expr) 0))
	   (else #f)))
	((eq? expr 'TRUE) #t)
	(else #f))
)

; Return a boolean indicating if EXPR is a "false" boolean value.
;
; ??? In RTL, #f is a synonym for (const 0).  This is confusing for Schemers,
; so maybe RTL's #f should be renamed to FALSE.

(define (rtx-false? expr)
  (cond ((pair? expr)
	 (case (car expr)
	   ((const enum) (= (rtx-constant-value expr) 0))
	   (else #f)))
	((eq? expr 'FALSE) #t)
	(else #f))
)

; Return canonical boolean values.

(define (rtx-false) (rtx-make-const 'BI 0))
(define (rtx-true) (rtx-make-const 'BI 1))

; Convert EXPR to a canonical boolean if possible.

(define (rtx-canonical-bool expr)
  (cond ((rtx-side-effects? expr) expr)
	((rtx-false? expr) (rtx-false))
	((rtx-true? expr) (rtx-true))
	(else expr))
)

; Return rtx values for #f/#t.

(define (rtx-make-bool value)
  (if value
      (rtx-true)
      (rtx-false))
)

; Return #t if X is an rtl expression.
; e.g. '(add WI dr simm8);

(define (rtx? x)
  (->bool
   (and (pair? x) ; pair? -> cheap non-null-list?
	(or (hashq-ref /rtx-func-table (car x))
	    (hashq-ref /rtx-macro-table (car x)))))
)

; Instruction field support.

; Return list of ifield names refered to in EXPR.
; Assumes EXPR is more than just (ifield x).

(define (rtl-find-ifields expr)
  (let ((ifields nil))
    (letrec ((scan! (lambda (arg-list)
		      (for-each (lambda (arg)
				  (if (pair? arg)
				      (if (eq? (car arg) 'ifield)
					  (set! ifields
						(cons (rtx-ifield-name arg)
						      ifields))
					  (scan! (cdr arg)))))
				arg-list))))
      (scan! (cdr expr))
      (nub ifields identity)))
)

; Hardware rtx handlers.

; Subroutine of hw to compute the object's name.
; The name of the operand must include the index so that multiple copies
; of a hardware object (e.g. h-gr[0], h-gr[14]) can be distinguished.
; We make some attempt to make the name pretty as it appears in generated
; files.

(define (/rtx-hw-name hw hw-name index-arg)
  (cond ((hw-scalar? hw)
	 hw-name)
	((rtx? index-arg)
	 (symbolstr-append hw-name '- (rtx-pretty-name index-arg)))
	(else
	 (symbolstr-append hw-name ; (obj:name (op:type self))
			   '-
			   ; (obj:name (op:index self)))))
			   (stringize index-arg "-"))))
)

; Return the <operand> object described by
; HW-NAME/MODE-NAME/SELECTOR/INDEX-ARG.
;
; HW-NAME is the name of the hardware element.
; MODE-NAME is the name of the mode.
; INDEX-ARG is an rtx or number of the index.
; In the case of scalar hardware elements, pass 0 for INDEX-ARG.
; In the case of a vector of registers, INDEX-ARG is the vector index.
; SELECTOR is an rtx or number and is passed to HW-NAME to allow selection of a
; particular variant of the hardware.  It's kind of like an INDEX, but along
; an atypical axis.  An example is memory ASI's on Sparc.  Pass
; hw-selector-default if there is no selector.
; ESTATE is the current rtx evaluation state.
;
; *** The index is passed unevaluated because for parallel execution support
; *** a variable is created with a name based on the hardware element and
; *** index, and we want a reasonably simple and stable name.  We get this by
; *** stringize-ing it.
; *** ??? Though this needs to be redone anyway.
;
; ??? The specified hardware element must be either a scalar or a vector.
; Maybe in the future allow arrays although there's significant utility in
; allowing only at most a scalar index.

(define (/hw estate mode-name hw-name index-arg selector)
  ; Enforce some rules to keep things in line with the current design.
  (if (not (symbol? mode-name))
      (parse-error (estate-context estate) "invalid mode name" mode-name))
  (if (not (symbol? hw-name))
      (parse-error (estate-context estate) "invalid hw name" hw-name))
  (if (not (or (number? index-arg)
	       (rtx? index-arg)))
      (parse-error (estate-context estate) "invalid index" index-arg))
  (if (not (or (number? selector)
	       (rtx? selector)))
      (parse-error (estate-context estate) "invalid selector" selector))

  (let ((hw (current-hw-sem-lookup-1 hw-name)))
    (if (not hw)
	(parse-error (estate-context estate) "invalid hardware element" hw-name))

    (let* ((mode (if (eq? mode-name 'DFLT) (hw-mode hw) (mode:lookup mode-name)))
	   (hw-name-with-mode (symbol-append hw-name '- (obj:name mode)))
	   (index-mode (if (eq? hw-name 'h-memory) 'AI 'INT))
	   (result (if (hw-pc? hw)
		       (new <pc>)
		       (new <operand>)))) ; ??? lookup-for-new?

      (if (not mode)
	  (parse-error (estate-context estate) "invalid mode" mode-name))

      ; Record the selector.
      (elm-xset! result 'selector selector)

      ; Create the index object.
      (elm-xset! result 'index
		 (cond ((number? index-arg)
			(make <hw-index> 'anonymous 'constant UINT index-arg))
		       ((rtx? index-arg)
			; Make sure constant indices are recorded as such.
			(case (rtx-name index-arg)
			  ((const)
			   (make <hw-index> 'anonymous 'constant UINT
				 (rtx-constant-value index-arg)))
			  ((enum)
			   (make-enum-hw-index 'anonymous (rtx-enum-value index-arg)))
			  (else
			   (make <hw-index> 'anonymous 'rtx (mode:lookup index-mode)
				 (/rtx-closure-make estate index-mode index-arg)))))
		       (else (parse-error (estate-context estate)
					  "invalid index" index-arg))))

      (if (not (hw-mode-ok? hw (obj:name mode) (elm-xget result 'index)))
	  (parse-error (estate-context estate)
		       "invalid mode for hardware" mode-name))

      (elm-xset! result 'hw-name hw-name)
      (elm-xset! result 'type hw)
      (elm-xset! result 'mode-name mode-name)
      (elm-xset! result 'mode mode)

      (op:set-pretty-sem-name! result hw-name)

      ; The name of the operand must include the index so that multiple copies
      ; of a hardware object (e.g. h-gr[0], h-gr[14]) can be distinguished.
      (let ((name (if (hw-pc? hw)
		      'pc
		      (/rtx-hw-name hw hw-name-with-mode index-arg))))
	(send result 'set-name! name)
	(op:set-sem-name! result name))

      ; Empty comment and attribute.
      ; ??? Stick the arguments in the comment for debugging purposes?
      (send result 'set-comment! "")
      (send result 'set-atlist! atlist-empty)

      result))
)

; This is shorthand for (hw estate mode hw-name regno selector).
; ESTATE is the current rtx evaluation state.
; INDX-SEL is an optional register number and possible selector.
; The register number, if present, is (car indx-sel) and must be a number or
; unevaluated canonical RTX expression.
; The selector, if present, is (cadr indx-sel) and must be a number or
; unevaluated canonical RTX expression.
; ??? A register selector isn't supported yet.  It's just an idea that's
; been put down on paper for future reference.

(define (reg estate mode-name hw-name . indx-sel)
  (s-hw estate mode-name hw-name
	(if (pair? indx-sel) (car indx-sel) 0)
	(if (and (pair? indx-sel) (pair? (cdr indx-sel)))
	    (cadr indx-sel)
	    hw-selector-default))
)

; This is shorthand for (hw estate mode-name h-memory addr selector).
; ADDR must be an unevaluated canonical RTX expression.
; If present (car sel) must be a number or unevaluated canonical
; RTX expression.

(define (mem estate mode-name addr . sel)
  (s-hw estate mode-name 'h-memory addr
	(if (pair? sel) (car sel) hw-selector-default))
)

; For the rtx nodes to use.

(define s-hw /hw)

; The program counter.
; When this code is loaded, global `pc' is nil, it hasn't been set to the
; pc operand yet (see operand-init!).  We can't use `pc' inside the drn as the
; value is itself.  So we use s-pc.  rtl-finish! must be called after
; operand-init!.

(define s-pc pc)

; Conditional execution.

; `if' in RTL has a result, like ?: in C.
; We support both: one with a result (non VOID mode), and one without (VOID mode).
; The non-VOID case must have an else part.
; MODE is the mode of the result, not the comparison.
; The comparison is expected to return a zero/non-zero value.
; ??? Perhaps this should be a syntax-expr.  Later.

(define (e-if estate mode cond then . else)
  (if (> (length else) 1)
      (estate-error estate "if: too many elements in `else' part" else))
  (if (null? else)
      (if cond then)
      (if cond then (car else)))
)

; Subroutines.
; ??? Not sure this should live here.

(define (/subr-read context . arg-list)
  #f
)

(define define-subr
  (lambda arg-list
    (let ((s (apply /subr-read (cons "define-subr" arg-list))))
      (if s
	  (current-subr-add! s))
      s))
)

; Misc. utilities.

; The argument to drn,drmn,drsn must be Scheme code (or a fixed subset
; thereof).  .str/.sym are used in pmacros so it makes sense to include them
; in the subset.
; FIXME: Huh?
(define .str string-append)
(define .sym symbol-append)

; Given (expr1 expr2 expr3 expr4), for example,
; return (fn (fn (fn expr1 expr2) expr3) expr4).

(define (rtx-combine fn exprs)
  (assert (not (null? exprs)))
  (letrec ((-rtx-combine (lambda (fn exprs result)
			   (if (null? exprs)
			       result
			       (-rtx-combine fn
					     (cdr exprs)
					     (rtx-make fn
						       result
						       (car exprs)))))))
    (-rtx-combine fn (cdr exprs) (car exprs)))
)

; Called before a .cpu file is read in.

(define (rtl-init!)
  (set! /rtx-func-table (make-hash-table 127))
  (set! /rtx-macro-table (make-hash-table 127))
  (set! /rtx-num-next 0)
  (def-rtx-funcs)

  ; Sanity checks.
  ; All rtx take options for the first arg and a mode for the second.
  (for-each (lambda (rtx-name)
	      (let ((rtx (rtx-lookup rtx-name)))
		(if rtx
		    (begin
		      (if (null? (rtx-arg-types rtx))
			  #f ; pc is the one exception, blech
			  (begin
			    (assert (eq? (car (rtx-arg-types rtx)) 'OPTIONS))
			    (assert (memq (cadr (rtx-arg-types rtx)) /rtx-valid-mode-types)))))
		    #f) ; else a macro
		))
	    /rtx-name-list)

  (reader-add-command! 'define-subr
		       "\
Define an rtx subroutine, name/value pair list version.
"
		       nil 'arg-list define-subr)

  *UNSPECIFIED*
)

;; Install builtins

(define (rtl-builtin!)
  (rtx-init-traversal-tables!)

  *UNSPECIFIED*
)

; Called after cpu files are loaded to add misc. remaining entries to the
; rtx handler table for use during evaluation.
; rtl-finish! must be done before ifmt-compute!, the latter will
; construct hardware objects which is done by rtx evaluation.

(define (rtl-finish!)
  (logit 2 "Building rtx operand table ...\n")

  ; Update s-pc, must be called after operand-init!.
  (set! s-pc pc)

  ; Initialize the operand hash table.
  (set! /rtx-operand-table (make-hash-table 127))

  ; Add the operands to the eval symbol table.
  (for-each (lambda (op)
	      (hashq-set! /rtx-operand-table (obj:name op) op))
	    (current-op-list))

  ; Add ifields to the eval symbol table.
  (for-each (lambda (f)
	      (hashq-set! /rtx-operand-table (obj:name f) f))
	    (non-derived-ifields (current-ifld-list)))

  *UNSPECIFIED*
)
@


1.28
log
@	* hardware.scm (hw-pc?): New function.
	* ifield.scm (ifld-signed?): New function.
	* iformat.scm (ifmt-analyze): Call insn-cti-attr? instead of insn-cti?.
	* insn.scm (insn-cti-attr?): Renamed from insn-ctl?.
	(insn-cti?): New function.
	* rtl.scm (/hw): Create <pc> object for pcs.
	* semantics.scm (/build-reg-operand!): New args ref-type, sem-attrs.
	All callers updated.  Watch for sets to the pc.
	(semantic-attrs): Watch for sets to the pc.
	* sid.scm (<pc> cxmake-get): Handle raw-reg.
	* sim.scm (<pc> cxmake-get): Handle raw-reg.
	(<operand> cxmake-get): Add debugging printf.
	* utils-gen.scm (/gen-ifld-extract-base): Emit calls to
	EXTRACT_[LM]SB0_LG[SU]INT for values > 32 bits.
	(/gen-extract-word): Ditto.

	* utils.scm (gen-c-hex-constant): New function.
	* utils-sim.scm (/gen-decode-insn-entry): Call it.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2001, 2009 Red Hat, Inc.
d53 2
a54 1
		; ANYEXPRMODE - VOID, PTR, or any numeric mode
d158 2
a159 2
    ANYINTMODE ANYFLOATMODE ANYNUMMODE ANYEXPRMODE EXPLNUMMODE VOIDORNUMMODE
    VOIDMODE BIMODE INTMODE SYMMODE INSNMODE MACHMODE
@


1.27
log
@	* utils.scm (reduce): Delete.

	* rtl-traverse.scm (/rtx-canon-rtx-enum): Tweak local name.

	* enum.scm (gen-enum-sym): Make consistent with gen-enum-decl
	regarding PREFIX attribute handling.

	* operand.scm (<hw-index>): Add enum to possible types, all uses
	updated.
	(hw-index-constant?, hw-index-constant-value): New functions.
	(make-enum-hw-index, hw-index-enum-name, hw-index-enum-value,
	hw-index-enum-obj): New functions.
	(/operand-parse): Handle enum indices.
	* intrinsics.scm (md-operand:fixed-register): Use hw-index-constant?,
	hw-index-constant-value.
	* rtl.scm (rtx-constant-value): Fix handling of enums.
	* rtx-funcs.scm (enum): Ditto.
	* sid.scm (<hardware-base> cxmake-get): Only ifield indices are
	currently supported here.
@
text
@d1066 3
a1068 1
	   (result (new <operand>))) ; ??? lookup-for-new?
d1107 3
a1109 1
      (let ((name (/rtx-hw-name hw hw-name-with-mode index-arg)))
@


1.26
log
@	Specify isa(s) when doing ifield, operand, insn lookups.
	ACU = all callers updated.
	* attr.scm (/attr-eval): Call rtx-value instead of rtx-eval-with-estate.
	* enum.scm (define-full-insn-enum): Pass isa-name-list to
	current-ifld-lookup.
	* html.scm (get-insn-properties): Pass isa-name-list to
	current-op-lookup.
	* ifield.scm (/ifld-parse-follows): New arg isas, ACU.
	* insn.scm (/parse-insn-format-symbol): New arg isa-name-list, ACU.
	(/parse-insn-format-list, /parse-insn-iformat-iflds): Ditto.
	(/parse-insn-format, syntax-break-out): Ditto.
	* mach.scm (obj-filter-by-isa): New function.
	(current-ifld-lookup): New optional arg maybe-isa-name-list.
	(/ifld-already-defined?, /op-already-defined?): Simplify.
	(current-op-lookup): New optional arg maybe-isa-name-list.
	(current-insn-lookup): New arg isa-name-list, ACU.
	(/insn-already-defined?, /minsn-already-defined?): Simplify.
	(current-minsn-lookup): New arg isa-name-list, ACU.
	* minsn.scm (/minsn-compute-iflds): Pass isa-name-list to
	current-op-lookup.
	* opc-itab.scm (compute-syntax): New arg isa-name-list, ACU.
	(gen-syntax-entry): Ditto.
	* operand.scm (/operand-parse): Pass isa-name-list to
	current-ifld-lookup.
	(/derived-parse-encoding): New arg isa-name-list, ACU.
	(/derived-parse-ifield-assertion): Ditto.
	(/derived-operand-parse): Pass isa-name-list to current-op-lookup.
	(/anyof-parse-choice): Ditto.
	(anyof-satisfies-assertions?): Pass context to rtx-solve.
	(/anyof-merge-syntax): New arg container, ACU.
	(operand-builtin!): Add pc to all isas.
	* rtl-c.scm (estate-make-for-rtl-c): Delete arg extra-vars-alist, ACU.
	(estate-make-for-rtl-c++, rtl-c-expr-parsed): Ditto.
	(rtl-c-parsed, rtl-c++-parsed): Ditto.
	(rtl-c): New arg isa-name-list, ACU.
	(rtl-c-expr, rtl-c++): Ditto.
	(closure): New arg isa-name-list, ACU.
	* rtl-traverse.scm (/make-cstate): New arg isa-name-list, ACU.
	(/cstate-isas): New function.
	(/rtx-canon-symbol-list): New function.
	(/rtx-canon-env-stack): Renamed from /rtx-canon-env, ACU.
	updated.
	(/rtx-make-canon-table): Rename ENV to ENVSTACK, new entry SYMBOLLIST.
	(/rtx-canon-rtx-operand): Pass isa list to current-op-lookup.
	(/rtx-canon-rtx-ref, /rtx-canon): Ditto.
	(rtx-canonicalize): New arg isa-name-list, ACU.
	(rtx-canonicalize-stmt): Delete.
	(tstate-make): New arg isas, ACU.
	(tstate-isas, tstate--set-isas!): New functions.
	(tstate-env-stack): Renamed from tstate-env, ACU.
	(tstate-set-env-stack!): Renamed from tstate-set-env!, ACU.
	(tstate-make-closure): Renamed from tstate-new-env, new arg
	isa-name-list, ACU.
	(/rtx-traverse-env): Delete.
	(/rtx-make-traverser-table): Rename ENV to ENVSTACK, new entry
	SUMBOLLIST.
	(/rtx-traverse): Include conditional flag in dump output.
	Update isa,envstack for closures.  Pass isa list to current-op-lookup.
	(<eval-state>): New member isas.  Rename env to env-stack.
	(<eval-state> vmake!): Handle #:isas.  #:env renamed to #:env-stack.
	(<eval-state>): New getter/setter for isas.  Rename env getter/setter
	to env-stack.
	(estate-make-for-eval): Provide #:isas.
	(estate-make-closure): Renamed from estate-new-env.  New arg
	isa-name-list, ACU.
	* rtl-xform.scm (/rtx-simplify-expr-fn): Handle closures.
	(/rtx-trim-args): ENV renamed to ENVSTACK.  Ad ITERATION, SYMBOLLIST.
	(/rtx-trim-for-doc): Handle closures.
	* rtl.scm (/rtx-valid-types): Rename ENV to ENVSTACK.  Add ITERATION,
	SYMBOLLIST.
	(rtx-env-var-list): Delete.
	(rtx-env-make): Handle already-compiled environments.
	(rtx-var-alist-to-env): New function.
	(rtx-var-alist-to-closure-env-stack, rtx-make-env-stack): New functions.
	(rtx-env-stack-dump): Renamed from rtx-env-dump, ACU.
	(rtx-operand-obj): New arg isa-name-list, ACU.
	(rtx-closure-isas, rtx-closure-env-stack, rtx-closure-expr): New
	functions.
	* rtx-funcs.scm (closure): New arg isa-name-list, reorder args, ACU.
	* sem-frags.scm (<sfrag>): Delete member compiled-semantics.
	(/frag-compute-desired-frags): Minor simplification.
	(/frag-pick-best): Ditto.
	* sid-cpu.scm (gen-semantic-code): Require canonical rtl.
	(/gen-sfrag-code): Update.
	* sim-cpu.scm (gen-semantic-code): Require canonical rtl.
	* utils-cgen.scm (sanitize): New arg isa-name-list, ACU.
	* utils.scm (non-null-intersection?): New function.
@
text
@d682 1
a682 1
    ((enum) (enum-lookup-val (rtx-enum-value rtx)))
d1080 9
a1088 5
			(if (rtx-constant? index-arg)
			    (make <hw-index> 'anonymous 'constant UINT
				  (rtx-constant-value index-arg))
			    (make <hw-index> 'anonymous 'rtx (mode:lookup index-mode)
				  (/rtx-closure-make estate index-mode index-arg))))
@


1.25
log
@comment tweak
@
text
@d69 2
a70 1
		; ENV - environment stack
d169 2
a170 1
    '(LOCALS ENV ATTRS SYMBOL STRING NUMBER SYMORNUM OBJECT)
d441 1
a441 1
;    ((operand) (obj:name (op:mode (current-op-lookup (cadr x)))))
d450 1
a450 1
	    (temp (rtx-temp-lookup (estate-env estate) name)))
a534 1
(define (rtx-env-var-list env) env)
d543 17
a559 12
; Create an initial environment.
; VAR-LIST is a list of (name <mode>-or-mode-name value) elements.

(define (rtx-env-make var-list)
  ; Convert VAR-LIST to an associative list of <rtx-temp> objects.
  (map (lambda (var-spec)
	 (cons (car var-spec)
	       (make <rtx-temp>
		 (car var-spec)
		 (mode-maybe-lookup (cadr var-spec))
		 (caddr var-spec))))
       var-list)
d590 22
d619 1
a619 1
; Lookup variable NAME in environment ENV.
a620 1
; ??? Should environments only have rtx-temps?
d622 2
a623 2
(define (rtx-temp-lookup env name)
  (let loop ((stack (rtx-env-var-list env)))
d632 2
a633 1
; Create a "closure" of EXPR using the current temp stack.
d636 3
a638 1
  (rtx-make 'closure mode expr (estate-env estate))
d641 2
a642 2
(define (rtx-env-dump env)
  (let ((stack env))
d742 1
a742 1
	(current-ifield-lookup ifield)
d759 1
a759 1
;; Given an operand rtx, construct the <operand> object.
d761 8
a768 4

(define (rtx-operand-obj rtx)
  (let ((op (current-op-lookup (rtx-arg1 rtx)))
	(mode (rtx-mode rtx)))
d770 5
a774 6
    (assert (not (eq? mode 'DFLT)))
    ;; NOTE: op:mode-name can be DFLT, which means use the mode of the type.
    ;; But we can't propagate DFLT here, in canonical rtl DFLT is not allowed.
    (if (mode:eq? (op:mode-name op) mode)
	op
	(op:new-mode op mode)))
d838 1
a838 1
; ??? Sometimes I should it should have been (sequence ((name MODE)) ...)
d848 4
d1026 1
a1028 1
; MODE-NAME is the name of the mode.
a1029 1
; In the case of a scalar register, the value is ignored, but pass 0 (??? #f?).
a1035 3
; e.g. (hw estate WI h-gr #f (const INT 14))
; selects register 14 of the h-gr set of registers.
;
a1078 7
			; For the simulator the following could be done which
			; would save having to create a closure.
			; ??? Old code, left in for now.
			; (rtx-get estate DFLT
			;          (rtx-eval (estate-context estate)
			;                    (estate-econfig estate)
			;                    index-arg rtx-evaluator))
@


1.24
log
@	* operand.scm (/anyof-merge-setter): Handle set-quiet.

	* rtl-c.scm (estate-make-for-rtl-c): Delete args context, owner,
	rtl-cover-fns?, macro?.  All callers updated.
	(estate-make-for-normal-rtl-c): Delete, have all callers call
	estate-make-for-rtl-c directly.
	(rtl-c-parsed): Pass #:outer-expr to estate-make-for-rtl-c.
	(rtl-c, rtl-c-expr-parsed, rtl-c-expr, rtl-c++-parsed, rtl-c++): Ditto.

	* rtl-c.scm (/par-replace-set-dest-expr-fn): New function,
	replaces /par-replace-set-dests.
	(/par-replace-set-src-expr-fn): New function, replaces
	/par-replace-set-srcs.
	(s-parallel): Rewrite.

	* rtl.scm (rtx-pretty-strdump): New function.
	* rtl-traverse.scm (/rtx-canon-error): Use it.
	(<eval-state>): New member outer-expr.
	(estate-error): Include outer expression in error message if present.

	* rtl.scm (rtx-single-set?): Handle set-quiet.
@
text
@d68 1
@


1.23
log
@	* xc16x.cpu (h-cr): New hardware.
	(muls): Comment out parts that won't compile, add fixme.
	(mulu, divl, divlu, jmpabs, jmpa-, jmprel, jbc, jnbs, callr): Ditto.
	(scxti, scxtmg, scxtm, bclear, bclr18, bset19, bitset, bmov): Ditto.
	(bmovn, band, bor, bxor, bcmp, bfldl, bfldh): Ditto.

	Rewrite rtl processing to require it to be "canonicalized" first,
	and write a full canonicalizer / expression checker.
	Remove all appearances of DFLT in canonical rtl.
	* attr.scm (/attr-eval atval owner): Call rtx-canonicalize,
	then rtx-simplify.
	* iformat.scm (ifmt-analyze) Use canonical semantics.
	* insn (<insn>): New member canonical-semantics.
	* mach.scm (<arch>): New member multi-insns-instantiated?.
	(/instantiate-multi-insns!): New function.
	(/canonicalize-insns!): New function.
	(arch-analyze-insns!): Canonicalize insn semantics before processing
	them.
	* mode.scm (/mode-set-word-params!): New function.
	(mode-void?): New function.
	(mode-compatible?): VOID is compatible with VOID.
	(/mode-word-sizes-defined?): New global.
	(mode-set-word-modes!): Use/set it.
	(mode-ensure-word-sizes-defined): Update.
	(mode-builtin!): New builtin "modes" SYM, INSN, MACH.
	Redo WI/UWI/AI/IAI handling.
	(op:new-mode): No longer accept DFLT.
	(<derived-operand> constructor): Ensure all fields are initialized.
	(<anyof-operand> constructor): Ditto.
	(/derived-parse-ifield-assertion): Delete arg `args'.
	All callers updated.
	* rtl-c.scm (<rtl-c-eval-state>): New member `for-insn?'.
	(rtl-c): Call rtx-canonicalize instead of rtx-compile.
	(rtl-c-expr, rtl-c++): Ditto.
	(/rtl-c-get): Use mode of operand, not containing expression.
	(rtl-c-set-quiet, rtl-c-set-trace): Remove DFLT support.
	(/rtx-use-sem-fn?): Don't check for (insn? owner), check
	estate-for-insn? instead.
	(s-unop): Use mode of expression, not first operand.
	(s-binop, s-binop-with-bit, s-shop, s-cmpop): Ditto.
	(s-sequence): Remove DFLT support.
	(ifield): Use mode of expression, not UINT.
	(pc): Comment out, unused.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	(set, set-quiet): Pass src to rtl-c-set-{trace,quiet} for expansion.
	* rtl-traverse.scm (/rtx-canon-debug?): New global.
	(/make-cstate): New function.
	(/cstate-context, /cstate-outer-expr): New functions.
	(/rtx-canon-error): New function.
	(/rtx-lookup-hw, /rtx-pick-mode, /rtx-pick-mode3, /rtx-pick-op-mode,
	/rtx-get-last-cond-case-rtx): New functions.
	(/rtx-canon-*): New functions.
	(/rtx-canner-table, /rtx-operand-canoners): New globals.
	(/rtx-make-canon-table, /rtx-special-expr-canoners): New functions.
	(/rtx-option, /rtx-option-list?): Rewrite.
	(rtx-munge-mode&options): Replaces /rtx-munge-mode&options.
	Rewritten, all callers updated.
	(/rtx-canon-expr, /rtx-canon): New functions.
	(rtx-canonicalize): Move here from rtl-xform.scm and rewrite.
	(rtx-canonicalize-stmt): New function.
	(tstate-make): Remove arg `set?'.  All callers updated.
	(tstate-new-set?): Delete.
	(/rtx-traverse-options, /rtx-traverse-*mode): Delete,
	moved to /rtx-canon-*.
	(/rtx-traverse-normal-operand): New function.
	(/rtx-traverse-rtx-list): Delete arg `mode', all callers updated.
	(/rtx-traverse-rtx, /rtx-traverse-setrtx,, /rtx-traverse-testrtx,
	/rtx-traverse-condrtx, /rtx-traverse-casertx, /rtx-traverse-locals,
	/rtx-traverse-iteration, /rtx-traverse-env, /rtx-traverse-attrs):
	Ditto.
	(/rtx-traverse-symbol, /rtx-traverse-string, /rtx-traverse-number,
	/rtx-traverse-symornum, /rtx-traverse-object): Delete.
	(/rtx-make-traverser-table): Update.
	(/rtx-traverse-operands): Remove mode processing, now done during
	canonicalization.
	(/rtx-traverse-expr): Delete arg `mode', all callers updated.
	(/rtx-traverse): Ditto.
	(rtx-init-traverser-tables!): New function.
	* rtl-xform (/rtx-verify-no-dflt-modes-expr-fn): New function.
	(rtx-verify-no-dflt-modes): New function.
	(/rtx-simplify-expr-fn): Update, `arg' mode deleted.
	(rtx-simplify-insn): Use insn-canonical-semantics.
	(rtx-canonicalize): Moved to rtl-traverse.scm.
	(/compile-expr-fn, rtx-compile): Delete.
	(/rtx-trim-rtx-list): New function.
	(/rtx-trim-for-doc): Handle set, if.
	* rtl.scm (<rtx-func>): New members result-mode, matchexpr-index.
	(/rtx-valid-mode-types): Update.
	(/rtx-valid-matches): Update.
	(/rtx-find-matchexpr-index): New function.
	(rtx-lookup): Require rtx-kind to be the rtx name.
	(def-rtx-node): New arg result-mode, all callers updated.
	(def-rtx-syntax-node, def-rtx-operand-node): Ditto.
	(rtx-lazy-sem-mode): Delete.
	(/rtx-closure-make): New arg `mode', all callers updated.
	(rtx-make-ifield, rtx-make-operand, rtx-make-local): Ditto.
	(rtx-operand-obj): Rewrite.
	(rtx-make-xop): New functions.
	(/hw): Renamed from `hw', all callers updated.
	Use the correct mode instead of DFLT for the index.
	(rtl-builtin!): Call rtx-init-traversal-tables!.
	(rtl-finish!): Update.
	* rtx-funcs.scm (all rtx functions): New parameter: result-mode.
	Update mode arg-type.
	(pc): Comment out.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	* sem-frags.scm (/frag-hash-compute!): Update, mode arg deleted.
	(/frag-cost-compute!): Ditto.
	* semantics.scm (/build-operand!): Delete args op-name, op.
	New arg op-expr.  All callers updated.
	(/build-mem-operand!): Remove DFLT support.
	(semantic-compile): Update process-expr!, mode arg deleted.
	* sid-cpu.scm (gen-semantic-code): Specify #:for-insn? in
	rtl-c++ calls.
	(/gen-sem-case, /gen-sfrag-code): Ditto.
	* sid.scm (/op-gen-set-trace1): Renamed from /op-gen-set-trace.
	(/op-gen-set-trace): New function.  If not doing profiling,
	call /op-gen-set-quiet.
	* sim-cpu.scm (gen-semantic-code): Specify #:for-insn? in rtl-c calls.
	* utils-gen.scm (/gen-ifld-extract-base): Update call to rtl-c.
	(/gen-ifld-extract-beyond, gen-multi-ifld-extract): Ditto.
	* utils.scm (find-first-index): New function.
	* doc/rtl.texi: Delete docs for `attr'.  Add `int-attr'.
@
text
@a762 1

d775 1
a775 1
(define (rtx-single-set? rtx) (eq? (car rtx) 'set))
d858 8
@


1.22
log
@	* rtx-funcs.scm (eq,ne,lt,gt,le,ge,ltu,leu,gtu,geu): Change class
	to COMPARE.
	* sem-frags.scm (/frag-cost-compute!): Add COMPARE.
@
text
@d35 1
d39 1
d42 4
d49 5
a53 5
		; OPTIONS - optional list of :-prefixed options.
		; ANYMODE - any mode
		; INTMODE - any integer mode
		; FLOATMODE - any floating point mode
		; NUMMODE - any numeric mode
d55 1
a55 1
		; NONVOIDMODE - can't be `VOID'
d57 5
a61 1
		; DFLTMODE - must be `DFLT', used when any mode is inappropriate
d70 5
a74 5
		; SYMBOL - operand must be a symbol
		; STRING - operand must be a string
		; NUMBER - operand must be a number
		; SYMORNUM - operand must be a symbol or number
		; OBJECT - operand is an object
d81 1
d83 12
a94 7
		; OP0 - mode is specified in operand 0
		;       unless it is DFLT in which case use the default mode
		;       of the operand
		; MATCH1 - must match mode of operand 1
		;          which will have OP0 for its mode spec
		; MATCH2 - must match mode of operand 2
		;          which will have OP0 for its mode spec
d98 4
d105 1
a105 1
		; SET - set
d118 4
a121 4
		; function - normal function
		; syntax - don't pre-eval arguments
		; operand - result is an operand
		; macro - converts one rtx expression to another
d142 1
a142 1
  (name args arg-types arg-modes class style evaluator num)
d155 2
a156 1
    ANYMODE INTMODE FLOATMODE NUMMODE EXPLNUMMODE NONVOIDMODE VOIDMODE DFLTMODE
d174 17
a190 1
  '(ANY NA OP0 MATCH1 MATCH2)
d206 1
a206 1
; RTX-KIND may already be an <rtx-func> object.  FIXME: delete?
d209 2
a210 5
  (cond ((symbol? rtx-kind)
	 (hashq-ref /rtx-func-table rtx-kind))
	((rtx-func? rtx-kind)
	 rtx-kind)
	(else #f))
d246 19
a264 3
(define (def-rtx-node name-args arg-types arg-modes class action)
  (let ((name (car name-args))
	(args (cdr name-args)))
d266 1
a266 1
		     arg-types arg-modes
d270 3
a272 1
			 (eval1 (list 'lambda (cons '*estate* args) action))
d292 1
a292 1
(define (def-rtx-syntax-node name-args arg-types arg-modes class action)
d294 2
a295 1
	(args (cdr name-args)))
d297 1
a297 1
		     arg-types arg-modes
d301 3
a303 1
			 (eval1 (list 'lambda (cons '*estate* args) action))
d323 1
a323 1
(define (def-rtx-operand-node name-args arg-types arg-modes class action)
d327 2
a328 1
	(args (cdr name-args)))
d330 1
a330 1
		     arg-types arg-modes
d333 3
a335 1
		     (eval1 (list 'lambda (cons '*estate* args) action))
d361 1
a361 1
    (let ((rtx (make <rtx-func> name args #f #f
a466 4
; MODE is a <mode> object.

(define (rtx-lazy-sem-mode mode) (rtx-sem-mode mode))

d475 4
a478 4
  (let ((mode1 (rtx-lazy-sem-mode m1))
	(mode2 (rtx-lazy-sem-mode m2)))
    ;(eq? (obj:name mode1) (obj:name mode2)))
    ; ??? This is more permissive than is perhaps proper.
d486 1
a594 1
  ;(display "looking up:") (display name) (newline)
d606 2
a607 2
(define (/rtx-closure-make estate expr)
  (rtx-make 'closure expr (estate-env estate))
d636 1
a636 1
  (cons kind (/rtx-munge-mode&options args))
d698 3
a700 1
(define (rtx-make-ifield ifield-name) (rtx-make 'ifield ifield-name))
d715 3
a717 1
(define (rtx-make-operand op-name) (rtx-make 'operand op-name))
d719 2
d727 4
d732 9
a740 4
  (let ((operand (rtx-arg1 rtx)))
    (if (symbol? operand)
	(current-op-lookup operand)
	operand))
d743 3
a745 1
(define (rtx-make-local local-name) (rtx-make 'local local-name))
d760 4
d822 1
a822 1
	((operand) (symbol->string (obj:name (rtx-operand-obj rtx))))
d1005 1
a1005 1
(define (hw estate mode-name hw-name index-arg selector)
d1024 1
d1049 2
a1050 2
			    (make <hw-index> 'anonymous 'rtx DFLT
				  (/rtx-closure-make estate index-arg))))
d1083 1
a1083 1
; unevaluated RTX expression.
d1085 1
a1085 1
; unevaluated RTX expression.
d1098 3
a1100 2
; ADDR must be an unevaluated RTX expression.
; If present (car sel) must be a number or unevaluated RTX expression.
d1109 1
a1109 1
(define s-hw hw)
d1156 1
d1204 1
d1208 1
a1208 1
; Install builtins
d1211 2
a1226 14
  ; Table of traversers for the various rtx elements.
  (let ((hash-table (/rtx-make-traverser-table)))
    (set! /rtx-traverser-table (make-vector (rtx-max-num) #f))
    (for-each (lambda (rtx-name)
		(let ((rtx (rtx-lookup rtx-name)))
		  (if rtx
		      (vector-set! /rtx-traverser-table (rtx-num rtx)
				   (map1-improper
				    (lambda (arg-type)
				      (cons arg-type
					    (hashq-ref hash-table arg-type)))
				    (rtx-arg-types rtx))))))
	      (rtx-name-list)))

@


1.21
log
@	* rtl.scm (rtx-class-*?): Delete, unused.
	(rtx-style-function?, rtx-style-operand?, rtx-style-macro?): Ditto.
@
text
@d89 1
@


1.20
log
@	* rtl.scm (rtx-strdump): Use write instead of display.
@
text
@a123 12
(define (rtx-class-arg? rtx) (eq? (rtx-class rtx) 'ARG))
(define (rtx-class-set? rtx) (eq? (rtx-class rtx) 'SET)) 
(define (rtx-class-unary? rtx) (eq? (rtx-class rtx) 'UNARY))
(define (rtx-class-binary? rtx) (eq? (rtx-class rtx) 'BINARY))
(define (rtx-class-trinary? rtx) (eq? (rtx-class rtx) 'TRINARY))
(define (rtx-class-if? rtx) (eq? (rtx-class rtx) 'IF))
(define (rtx-class-cond? rtx) (eq? (rtx-class rtx) 'COND))
(define (rtx-class-sequence? rtx) (eq? (rtx-class rtx) 'SEQUENCE))
(define (rtx-class-unspec? rtx) (eq? (rtx-class rtx) 'UNSPEC))
(define (rtx-class-misc? rtx) (eq? (rtx-class rtx) 'MISC))

(define (rtx-style-function? rtx) (eq? (rtx-style rtx) 'function))
a124 2
(define (rtx-style-operand? rtx) (eq? (rtx-style rtx) 'operand))
(define (rtx-style-macro? rtx) (eq? (rtx-style rtx) 'macro))
@


1.19
log
@	Clean up pass of mode handling.
	Make use of mode name vs <mode> object more consistent and clear.
	* hardware.scm (/keyword-read): Default mode to the mode name,
	not the <mode> object.
	(/hw-parse-indices): Parse mode name and pass mode object to
	<hw-asm> constructor.
	(/hw-parse-values): Ditto.
	(<hw-register> parse!): Pass mode name to /hw-parse-indices
	and /hw-parse-values.
	(<hw-memory> parse!): Ditto.
	(<hw-address> parse!): Ditto.
	* mode.scm (/mode-table): New global, replaces mode-list.
	Modes stored in hashtable instead of list.
	(/mode-class-table): New global.
	(mode-list-non-alias-values): Update.
	(mode:eq?, mode-compatible?, mode:add!): Update.
	(mode:lookup): Restrict arg to the mode's name.  All callers updated.
	(mode-maybe-lookup): New function.
	(mode-real-name): Restrict arg to a <mode> object.  All callers updated.
	(mode-real-mode, mode-sem-mode, mode-bigger?): Ditto.
	(mode-find, mode-set-word-modes!): Update
	(mode-ensure-word-sizes-defined): Update.
	(/sort-mode-classes!): New function.
	(mode-builtin!): Update.  Sort mode classes here.
	(mode-finish!): Sort mode classes here too.
	* rtl-c.scm (/rtl-c-get): Restrict mode arg to a <mode> object.
	All callers updated.
	(rtl-c-set-quiet): Allow mode to be name of object.
	(rtl-c-set-trace): Ditto.
	* rtl-traverse.scm (rtl-eval-with-estate): Restrict mode arg to
	<mode> object.  All callers updated.
	* rtl.scm (rtx-sem-mode): Restrict arg to <mode> object.
	(rtx-lazy-sem-mode): Ditto.
	(<rtx-temp> make!): Assert mode arg is a <mode> object.
	(rtx-env-make): Allow var-list modes to be name or object.
	* sem-frags.scm (/frag-expr-assq-locals): New function.
	(/frag-compute-locals!): Call it.
	(/sfrag-create-cse-mapping): Renamed from sfrag-create-cse-mapping.
	All callers updated.
	* semantics.scm (/build-mem-operand!): Handle mode aliases.
@
text
@d793 2
a794 1
      (display (rtx-dump rtx))))
@


1.18
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d414 1
d420 1
a420 1
(define (rtx-sem-mode m) (or (mode:sem-mode m) m))
d422 1
a422 1
; MODE is a mode name or <mode> object.
d424 1
a424 1
(define (rtx-lazy-sem-mode mode) (rtx-sem-mode (mode:lookup mode)))
d431 1
d444 1
d461 1
d500 1
a500 1
; VAR-LIST is a list of (name <mode> value) elements.
d507 3
a509 1
		 (car var-spec) (cadr var-spec) (caddr var-spec))))
d743 2
d1025 2
a1026 2
(define (reg estate mode hw-name . indx-sel)
  (s-hw estate mode hw-name
d1033 1
a1033 1
; This is shorthand for (hw estate mode h-memory addr selector).
d1037 2
a1038 2
(define (mem estate mode addr . sel)
  (s-hw estate mode 'h-memory addr
@


1.17
log
@* rtl.scm (rtx-pretty-name): Fix thinko, don't assume (car rtx) is simple.
@
text
@d146 1
a146 1
(define -rtx-valid-mode-types
d154 1
a154 1
(define -rtx-valid-types
d157 1
a157 1
    -rtx-valid-mode-types
d165 1
a165 1
(define -rtx-valid-matches
d170 1
a170 1
; to know the innards of -rtx-func-table (which is a hash table).
d172 2
a173 2
(define -rtx-name-list nil)
(define (rtx-name-list) -rtx-name-list)
d178 1
a178 1
(define -rtx-func-table nil)
d186 1
a186 1
	 (hashq-ref -rtx-func-table rtx-kind))
d195 1
a195 1
(define -rtx-macro-table nil)
d200 1
a200 1
(define -rtx-operand-table nil)
d204 1
a204 1
(define -rtx-num-next #f)
d209 1
a209 1
  -rtx-num-next
d218 2
a219 2
; ARG-TYPES is a list of argument types (-rtx-valid-types).
; ARG-MODES is a list of mode matchers (-rtx-valid-matches).
d235 1
a235 1
		     -rtx-num-next)))
d237 3
a239 3
      (hashq-set! -rtx-func-table name rtx)
      (set! -rtx-num-next (+ -rtx-num-next 1))
      (set! -rtx-name-list (cons name -rtx-name-list))
d263 1
a263 1
		     -rtx-num-next)))
d265 3
a267 3
      (hashq-set! -rtx-func-table name rtx)
      (set! -rtx-num-next (+ -rtx-num-next 1))
      (set! -rtx-name-list (cons name -rtx-name-list))
d291 1
a291 1
		     -rtx-num-next)))
d293 3
a295 3
      (hashq-set! -rtx-func-table name rtx)
      (set! -rtx-num-next (+ -rtx-num-next 1))
      (set! -rtx-name-list (cons name -rtx-name-list))
d320 1
a320 1
		     -rtx-num-next)))
d322 3
a324 3
      (hashq-set! -rtx-macro-table name rtx)
      (set! -rtx-num-next (+ -rtx-num-next 1))
      (set! -rtx-name-list (cons name -rtx-name-list))
d341 2
a342 2
(define (-rtx-macro-lookup macro-name)
  (hashq-ref -rtx-macro-table macro-name)
d347 2
a348 2
(define (-rtx-macro-check exp fn-getter)
  (let ((macro (hashq-ref -rtx-macro-table (car exp))))
d356 2
a357 2
(define (-rtx-macro-expand-list exp fn-getter)
  (let ((macro (-rtx-macro-check exp fn-getter)))
d359 1
a359 1
	(apply macro (map (lambda (x) (-rtx-macro-expand x fn-getter))
d361 1
a361 1
	(map (lambda (x) (-rtx-macro-expand x fn-getter))
d367 1
a367 1
(define (-rtx-macro-expand exp fn-getter)
d369 1
a369 1
      (let ((result (-rtx-macro-expand-list exp fn-getter)))
d372 1
a372 1
	    (let ((macro (-rtx-macro-check result fn-getter)))
d374 1
a374 1
		  (-rtx-macro-expand (apply macro (cdr result)) fn-getter)
d382 1
a382 1
(define rtx-macro-expand -rtx-macro-expand)
d419 1
a419 1
(define (-rtx-sem-mode m) (or (mode:sem-mode m) m))
d422 2
a423 1
(define (-rtx-lazy-sem-mode mode) (-rtx-sem-mode (mode:lookup mode)))
d427 1
a427 1
(define (-rtx-obj-mode obj) (send obj 'get-mode))
d431 3
a433 3
(define (-rtx-mode-compatible? m1 m2)
  (let ((mode1 (-rtx-lazy-sem-mode m1))
	(mode2 (-rtx-lazy-sem-mode m2)))
d559 1
a559 1
(define (-rtx-closure-make estate expr)
d589 1
a589 1
  (cons kind (-rtx-munge-mode&options args))
d862 2
a863 2
	(or (hashq-ref -rtx-func-table (car x))
	    (hashq-ref -rtx-macro-table (car x)))))
d894 1
a894 1
(define (-rtx-hw-name hw hw-name index-arg)
d978 1
a978 1
				  (-rtx-closure-make estate index-arg))))
d995 1
a995 1
      (let ((name (-rtx-hw-name hw hw-name-with-mode index-arg)))
d1066 1
a1066 1
(define (-subr-read context . arg-list)
d1072 1
a1072 1
    (let ((s (apply -subr-read (cons "define-subr" arg-list))))
d1105 3
a1107 3
  (set! -rtx-func-table (make-hash-table 127))
  (set! -rtx-macro-table (make-hash-table 127))
  (set! -rtx-num-next 0)
d1120 1
a1120 1
			    (assert (memq (cadr (rtx-arg-types rtx)) -rtx-valid-mode-types)))))
d1123 1
a1123 1
	    -rtx-name-list)
d1151 2
a1152 2
  (let ((hash-table (-rtx-make-traverser-table)))
    (set! -rtx-traverser-table (make-vector (rtx-max-num) #f))
d1156 1
a1156 1
		      (vector-set! -rtx-traverser-table (rtx-num rtx)
d1165 1
a1165 1
  (set! -rtx-operand-table (make-hash-table 127))
d1169 1
a1169 1
	      (hashq-set! -rtx-operand-table (obj:name op) op))
d1174 1
a1174 1
	      (hashq-set! -rtx-operand-table (obj:name f) f))
@


1.16
log
@Rework do-count to take an expression for the iteration count,
and swap the iteration-variable/#iterations arguments.
@
text
@d756 1
a756 1
	     (car rtx)
d758 1
a758 1
		    (cons (car rtx)
@


1.15
log
@	Add do-count rtl function.
	* rtl-c.scm (s-do-count): New function.
	(do-count): New rtl handler.
	* rtl-traverse.scm (-rtx-traverse-iteration): New function.
	(-rtx-make-traverser-table): Add ITERATION.
	* rtl.scm (rtx-env-make-iteration-locals): New function.
	* rtx-funcs.scm (do-count): New rtl function.
	* cpu/play.cpu: Add do-count-test insn.
	* doc/rtl.texi: Add docs on do-count.
@
text
@d519 9
a527 1
; Create an environment with the iteration local variable of `do-count'.
d530 2
a531 1
  (rtx-env-make-locals (list (list 'INT iter-var)))
@


1.14
log
@	* read.scm (parse-error): Change error message output format
	to match context-owner-error.
	* rtl-c.scm (-rtl-c-get): Call estate-error instead of error.
	(rtl-c-set-quiet, rtl-c-set-trace): Ditto.
	(s-if, s-cond, -gen-non-vm-case-test): Ditto.
	(operand): Call estate-error instead of context-error.
	(local, delay): Ditto.
	(ref, attr): Call estate-error instead of error.
	* rtl-traverse.scm (tstate-error): New function.
	(-rtx-traverse-error): Call tstate-error instead of context-error.
	(-rtx-traverse-operands, -rtx-traverse): Ditto.
	(estate-error): New function.
	* rtl.scm (rtx-lvalue-mode-name): Handle locals.  Call estate-error
	instead of error.
	(e-if): Call estate-error instead of error.
	* rtx-funcs.scm (error): Call estate-error instead of context-error.
	(member): Ditto.
	* utils-cgen.scm (context-error): New arg `intro', all callers updated.
	Rewrite to call context-owner-error.
	(context-owner-error): New function.
@
text
@d519 6
@


1.13
log
@	Clean up cpu file parsing, pass context consistently instead of the
	old "errtxt" argument.
	NOTE: ACU == "All Callers Updated".
	* attr.scm (-parse-simple-attribute): Renamed from
	parse-simple-attribute, ACU.
	(-attr-parse): Change errtxt argument to context, ACU.
	(-attr-read): Ditto.
	(atlist-parse): Ditto.  Put context arg first.
	(attr-parse): Use parse-error instead of context-error.
	* enum.scm (parse-enum-vals): Change errtxt argument to context, ACU.
	(-enum-parse-prefix, -enum-parse, -enum-read): Ditto.
	* hardware.scm (-keyword-parse): Renamed from keyword-parse.
	`context' arg is now a <context> object.  ACU.
	(-keyword-read): `context' arg is now a <context> object.  ACU.
	(-hw-parse-indices): Change errtxt argument to context, ACU.
	(-hw-parse-values, -hw-parse-handlers): Ditto.
	(-hw-parse-getter, -hw-parse-setter, -hw-parse, -hw-read): Ditto.
	(-hw-validate-layout, -hw-create-getter-from-layout,
	-hw-create-setter-from-layout): Ditto.
	(<hw-register>:parse!, <hw-pc>:parse!): Ditto.
	(<hw-memory>:parse!, <hw-immediate>:parse!): Ditto.
	(<hw-address>:parse!): Ditto.
	* ifield.scm (-ifield-parse, ifield-read): Ditto.
	(-ifld-parse-follows, -ifld-parse-encode-decode): Ditto.
	(-ifld-parse-encode, -ifld-parse-decode): Ditto.
	(-multi-ifield-parse, -multi-ifield-read): Ditto.
	* insn.scm (-insn-parse, -insn-read): Ditto.
	(parse-syntax): Ditto.  Put context arg first.
	(-parse-insn-format-symbol): Change errtxt argument to context, ACU.
	(-parse-insn-format-ifield-spec, -parse-insn-format-list): Ditto.
	(-parse-insn-format): Ditto.
	* mach.scm (-arch-parse-alignment, -arch-parse-machs): Ditto.
	(-arch-parse-isas): Ditto.
	(-isa-read): Add context arg, ACU.
	(-cpu-parse, -cpu-read, -mach-read): Ditto.
	* minsn.scm (-minsn-parse-expansion): Change errtxt argument to
	context, ACU.
	(-minsn-parse, -minsn-read, -minsn-compute-iflds): Ditto.
	(minsn-make-alias): Ditto.
	* mode.scm (-mode-parse): Ditto.
	(parse-mode-name): Ditto.  Put context arg first.
	* model.scm (-prefetch-parse, -retire-parse, -pipeline-parse): Change
	errtxt argument to context, ACU.
	(-unit-parse, -model-parse, -model-read): Ditto.
	* operand.scm (-operand-parse-getter): Use parse-error instead of
	context-error.
	(-operand-parse-setter): Ditto.
	(-operand-parse): Change errtxt argument to context, ACU.
	(-operand-read, -derived-operand-parse, -derived-operand-read): Ditto.
	(-anyof-operand-parse, -anyof-operand-read): Ditto.
	* read.scm (reader-error): Delete.  Use parse-error instead.
	(parse-error): Change errtxt argument to context, ACU.  Split args
	argument into expr and maybe-help-text.
	(-reader-process-expanded-1!): Reorganize.
	* rtl.scm (-subr-read): Change errtxt argument to context, ACU.
	* types.scm (parse-type): Ditto.
	* utils-cgen.scm (single-location->simple-string): New function.
	(<context>): Replace members file,lineno with location.
	(make-prefix-context): Renamed from context-make-prefix, ACU.
	(make-current-context): New function.
	(context-append, context-append-name): New functions.
	(context-make-reader): Delete.
	(parse-name): Change errtxt argument to context, ACU.
	Put context arg first.
	(parse-comment): Ditto.
	(parse-number): Change errtxt argument to context, ACU.
	(arg-list-validate-name, arg-list-check-no-args,
	arg-list-symbol-arg): Ditto.

	* read.scm (-cmd-if): Don't assume test is a list.

	* html.scm (get-insn-properties): Delete errtxt, unused.
@
text
@d400 6
a405 2
;    ((local) (obj:name (rtx-temp-mode (rtx-temp-lookup (estate-env estate)
;						       (cadr x)))))
d407 3
a409 1
     (error "rtx-lvalue-mode-name: not an operand or hardware reference:" x)))
d507 2
a508 1
; VAR-LIST is a list of (mode-name name) elements (the argument to `sequence').
d526 4
d1041 1
a1041 1
      (error "if: too many elements in `else' part" else))
@


1.12
log
@	* insn.scm (multi-insn-instantiate!): Use logging messages instead of
	commented out printfs.
	* rtl.scm (rtl-finish!): Whitespace tweaks.
@
text
@d910 1
a910 1
      (parse-error "hw" "invalid mode name" mode-name))
d912 1
a912 1
      (parse-error "hw" "invalid hw name" hw-name))
d915 1
a915 1
      (parse-error "hw" "invalid index" index-arg))
d918 1
a918 1
      (parse-error "hw" "invalid selector" selector))
d922 1
a922 1
	(parse-error "hw" "invalid hardware element" hw-name))
d929 1
a929 1
	  (parse-error "hw" "invalid mode" mode-name))
d952 2
a953 1
		       (else (parse-error "hw" "invalid index" index-arg))))
d956 2
a957 1
	  (parse-error "hw" "invalid mode for hardware" mode-name))
d1039 1
a1039 1
(define (-subr-read errtxt . arg-list)
@


1.11
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d220 1
d1140 1
a1140 2
	      (hashq-set! -rtx-operand-table (obj:name op) op)
	      )
d1145 1
a1145 2
	      (hashq-set! -rtx-operand-table (obj:name f) f)
	      )
@


1.10
log
@	* semantics.scm (semantic-compile): Change arg sem-code-list to
	sem-code.
	(semantic-attrs): Ditto.
	* iformat.scm (ifmt-analyze): Update.
	(ifmt-compute!): Update.
	* rtl-traverse.scm (-compile-expr-fn, rtx-compile): Move to
	rtl-xform.scm.
	(-rtx-trim-args, -rtx-trim-for-doc, rtx-trim-for-doc): Ditto.
	* rtl.scm (-rtx-canonicalize-expr, rtx-canonicalize): Ditto.
	* semantics.scm (rtx-simplify): Ditto.
	(rtx-const-equal, rtx-const-list-equal): Ditto, and make local.
	(rtx-simplify-eq-attr-mach, rtx-simplify-eq-attr-insn): Ditto.
	(-simplify-expr-fn): Move to rtl-xform.scm.
	(-solve-expr-fn, rtx-solve): Ditto.
	* rtl-xform.c: New file.
	* read.scm: Load it.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2001 Red Hat, Inc.
@


1.9
log
@* utils.scm (string/symbol->append): Renamed from 'concat'.
* opcodes.scm (gen-switch): Use new name.
* insn.scm (-sub-insn-make!): Same.
* rtl.scm (rtx-dump): Same.
* semantics.scm (semantic-compile): Same.
@
text
@a382 45
; RTX canonicalization.
; ??? wip

; Subroutine of rtx-canonicalize.
; Return canonical form of rtx expression EXPR.
; CONTEXT is a <context> object or #f if there is none.
; It is used for error message.
; RTX-OBJ is the <rtx-func> object of (car expr).

(define (-rtx-canonicalize-expr context rtx-obj expr)
  #f
)

; Return canonical form of EXPR.
; CONTEXT is a <context> object or #f if there is none.
; It is used for error message.
;
; Does:
; - operand shortcuts expanded
;   - numbers -> (const number)
;   - operand-name -> (operand operand-name)
;   - ifield-name -> (ifield ifield-name)
; - no options -> null option list
; - absent result mode of those that require a mode -> DFLT
; - rtx macros are expanded
;
; EXPR is returned in source form.  We could speed up future processing by
; transforming it into a more compiled form, but that makes debugging more
; difficult, so for now we don't.

(define (rtx-canonicalize context expr)
  ; FIXME: wip
  (cond ((integer? expr)
	 (rtx-make-const 'INT expr))
	((symbol? expr)
	 (let ((op (current-op-lookup expr)))
	   (if op
	       (rtx-make-operand expr)
	       (context-error context "can't canonicalize" expr))))
	((pair? expr)
	 expr)
	(else
	 (context-error context "can't canonicalize" expr)))
)

@


1.9.6.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2001, 2009 Red Hat, Inc.
@


1.8
log
@* utils.scm (concat): New function.
* insn.scm (-sub-insn-make!): Use concat instead of string-map.
* rtl.scm (rtx-dump): Same.
* semantics.scm (semantic-compile): Same.
@
text
@d789 5
a793 5
	((object? rtx) (concat "#<object "
			       (object-class-name rtx)
			       " "
			       (obj:name rtx)
			       ">"))
@


1.7
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@d789 5
a793 5
	((object? rtx) (string-append "#<object "
				      (object-class-name rtx)
				      " "
				      (obj:name rtx)
				      ">"))
@


1.6
log
@	* mach.scm (current-*-add!): Disallow redefinition.  Make result
	"unspecified".
	* insn.scm (insn-builtin!): Don't define relaxable here, now defined in
	operand.scm.
	* operand.scm (operand-builtin!): Define RELAXABLE for insns too.
	* cpu/m32r.cpu (disp8,disp24): RELAX renamed to RELAXABLE.

	* gen-all-doc: Split arm and frv docs up a bit.

	* cpu/arm.cpu: Add IDOC attribute.
	* cpu/frv.cpu: Ditto.
	* cpu/i960.cpu: Ditto.
	* cpu/openrisc.cpu: Ditto.
	* cpu/xstormy16.cpu: Ditto.
	* cpu/m32r.cpu: Ditto.
	(all insns): Explicitly specify IDOC attribute.

	* Makefile.am (MACH,ISAS,INSN_FILE_NAME): New vars.
	(desc,opcodes,sim-arch,sim-cpu,gas-test,sim-test): Use MACH,ISAS.
	(html): Use MACH,ISAS,INSN_FILE_NAME.  Generate insn.html separately.
	* Makefile.in: Regenerate.
	* attr.scm (<integer-attribute>:parse-value-def): Implement.
	(-attr-read): Defer computing default value until we know the type.
	(attr-has-attr?): Delete, move contents to <attr-list>:has-attr?.
	(<attr-list>:attr-present?): New method.
	(atlist-attr-present?,obj-attr-present?): New fns.
	(obj-has-attr-value?,obj-has-attr-value-no-default?): New fns.
	(attr-builtin!): New insn attr IDOC.
	* cgen-doc.scm (doc-arguments): New args -I,-N.
	* enum.scm (parse-enum-vals): New arg errtxt, all callers updated.
	Support comment as fourth element of enum value.
	(enum-val-name,enum-val-value,enum-val-attrs,enum-val-comment): New fns.
	* html.scm (gen-html-header): New arg kind, all callers updated.
	(gen-table-of-contents): New arg insn-file, all callers updated.
	(gen-list-entry,gen-doc-header): New fn.
	(get-operands): Delete.
	(gen-iformat-table): Rewrite.
	(gen-insn-doc-1): Print constant-folded and trimmed semantics.
	(gen-insn-doc-list): New args name, comment, insns.  All callers updated.
	(get-insn-properties,guess-insn-idoc-attr!): New fn.
	(insn-sets-pc?,insn-refs-mem?,insn-uses-fpu?): New fns.
	(get-insns-for-category,gen-categories-insn-lists): New fns.
	(gen-insn-docs): Simplify each insn's semantics first.
	Print insn tables sorted by IDOC categories.
	(*insn-html-file-name*): New global.
	(cgen-insn.html): New fn.
	(cgen-all): Update.
	* insn.scm (<insn>): Create a setter for the `tmp' member.
	* semantics.scm (insn-build-known-values): Renamed from
	-build-known-values.  All callers updated.

	* rtl.scm: Move traveral/evaluation support to ...
	* rtl-traverse.scm: New file.
	* read.scm: Maybe-load rtl-traverse.scm.

	* rtl.scm (-rtx-valid-types): Add SETRTX.

	* rtx-funcs.scm (nop,parallel): Fix mode.

	* utils.scm (eqv-lookup-index): New fn.
	(assq-lookup-index): Renamed from lookup-index.  All callers updated.

	* dev.scm (load-doc): Set APPLICATION.
@
text
@d232 1
a232 1
			 (eval (list 'lambda (cons '*estate* args) action))
d260 1
a260 1
			 (eval (list 'lambda (cons '*estate* args) action))
d289 1
a289 1
		     (eval (list 'lambda (cons '*estate* args) action))
d318 1
a318 1
		     (eval (list 'lambda args action))
d762 1
a762 1
; Return a semi-pretty symbol describing RTX.
d769 3
a771 3
	((operand) (obj:name (rtx-operand-obj rtx)))
	((local) (rtx-local-name rtx))
	((xop) (obj:name (rtx-xop-obj rtx)))
d775 1
a775 1
	     (apply string-append
d915 1
a915 1
	 (symbol-append hw-name '- (rtx-pretty-name index-arg)))
d917 4
a920 4
	 (symbol-append hw-name ; (obj:name (op:type self))
			'-
			; (obj:name (op:index self)))))
			(stringize index-arg "-"))))
@


1.5
log
@	* mode.scm (mode-sem-mode): New fn.
	* operand.scm (op:new-mode): Update. mode-name.
	(op-natural-mode?) New fn.
	* rtl.scm (hw): Set hw-name,mode-name.
plus some comment tweaks
@
text
@d144 8
d155 6
a160 4
  '(OPTIONS
    ANYMODE INTMODE FLOATMODE NUMMODE EXPLNUMMODE NONVOIDMODE VOIDMODE DFLTMODE
    RTX TESTRTX CONDRTX CASERTX
    LOCALS ENV ATTRS SYMBOL STRING NUMBER SYMORNUM OBJECT)
a782 823
; RTL expression traversal support.
; Traversal (and compilation) involves validating the source form and
; converting it to internal form.
; ??? At present the internal form is also the source form (easier debugging).

; Set to #t to debug rtx traversal.

(define -rtx-traverse-debug? #f)

; Container to record the current state of traversal.
; This is initialized before traversal, and modified (in a copy) as the
; traversal state changes.
; This doesn't record all traversal state, just the more static elements.
; There's no point in recording things like the parent expression and operand
; position as they change for every sub-traversal.
; The main raison d'etre for this class is so we can add more state without
; having to modify all the traversal handlers.
; ??? At present it's not a proper "class" as there's no real need.
;
; CONTEXT is a <context> object or #f if there is none.
; It is used for error messages.
;
; EXPR-FN is a dual-purpose beast.  The first purpose is to just process
; the current expression and return the result.  The second purpose is to
; lookup the function which will then process the expression.
; It is applied recursively to the expression and each sub-expression.
; It must be defined as
; (lambda (rtx-obj expr mode parent-expr op-pos tstate appstuff) ...).
; If the result of EXPR-FN is a lambda, it is applied to
; (cons TSTATE (cdr EXPR)).  TSTATE is prepended to the arguments.
; For syntax expressions if the result of EXPR-FN is #f, the operands are
; processed using the builtin traverser.
; So to repeat: EXPR-FN can process the expression, and if its result is a
; lambda then it also processes the expression.  The arguments to EXPR-FN
; are (rtx-obj expr mode parent-expr op-pos tstate appstuff).  The format
; of the result of EXPR-FN are (cons TSTATE (cdr EXPR)).
; The reason for the duality is that when trying to understand EXPR (e.g. when
; computing the insn format) EXPR-FN processes the expression itself, and
; when evaluating EXPR it's the result of EXPR-FN that computes the value.
;
; ENV is the current environment.  This is a stack of sequence locals.
;
; COND? is a boolean indicating if the current expression is on a conditional
; execution path.  This is for optimization purposes only and it is always ok
; to pass #t, except for the top-level caller which must pass #f (since the top
; level expression obviously isn't subject to any condition).
; It is used, for example, to speed up the simulator: there's no need to keep
; track of whether an operand has been assigned to (or potentially read from)
; if it's known it's always assigned to.
;
; SET? is a boolean indicating if the current expression is an operand being
; set.
;
; OWNER is the owner of the expression or #f if there is none.
; Typically it is an <insn> object.
;
; KNOWN is an alist of known values.  This is used by rtx-simplify.
; Each element is (name . value) where
; NAME is either an ifield or operand name (in the future it might be a
; sequence local name), and
; VALUE is either (const mode value) or (numlist mode value1 value2 ...).
;
; DEPTH is the current traversal depth.

(define (tstate-make context owner expr-fn env cond? set? known depth)
  (vector context owner expr-fn env cond? set? known depth)
)

(define (tstate-context state)             (vector-ref state 0))
(define (tstate-set-context! state newval) (vector-set! state 0 newval))
(define (tstate-owner state)               (vector-ref state 1))
(define (tstate-set-owner! state newval)   (vector-set! state 1 newval))
(define (tstate-expr-fn state)             (vector-ref state 2))
(define (tstate-set-expr-fn! state newval) (vector-set! state 2 newval))
(define (tstate-env state)                 (vector-ref state 3))
(define (tstate-set-env! state newval)     (vector-set! state 3 newval))
(define (tstate-cond? state)               (vector-ref state 4))
(define (tstate-set-cond?! state newval)   (vector-set! state 4 newval))
(define (tstate-set? state)                (vector-ref state 5))
(define (tstate-set-set?! state newval)    (vector-set! state 5 newval))
(define (tstate-known state)               (vector-ref state 6))
(define (tstate-set-known! state newval)   (vector-set! state 6 newval))
(define (tstate-depth state)               (vector-ref state 7))
(define (tstate-set-depth! state newval)   (vector-set! state 7 newval))

; Create a copy of STATE.

(define (tstate-copy state)
  ; A fast vector-copy would be nice, but this is simple and portable.
  (list->vector (vector->list state))
)

; Create a copy of STATE with a new environment ENV.

(define (tstate-new-env state env)
  (let ((result (tstate-copy state)))
    (tstate-set-env! result env)
    result)
)

; Create a copy of STATE with environment ENV pushed onto the existing
; environment list.
; There's no routine to pop the environment list as there's no current
; need for it: we make a copy of the state when we push.

(define (tstate-push-env state env)
  (let ((result (tstate-copy state)))
    (tstate-set-env! result (cons env (tstate-env result)))
    result)
)

; Create a copy of STATE with a new COND? value.

(define (tstate-new-cond? state cond?)
  (let ((result (tstate-copy state)))
    (tstate-set-cond?! result cond?)
    result)
)

; Create a copy of STATE with a new SET? value.

(define (tstate-new-set? state set?)
  (let ((result (tstate-copy state)))
    (tstate-set-set?! result set?)
    result)
)

; Lookup NAME in the known value table.  Returns the value or #f if not found.

(define (tstate-known-lookup tstate name)
  (let ((known (tstate-known tstate)))
    (assq-ref known name))
)

; Increment the recorded traversal depth of TSTATE.

(define (tstate-incr-depth! tstate)
  (tstate-set-depth! tstate (1+ (tstate-depth tstate)))
)

; Decrement the recorded traversal depth of TSTATE.

(define (tstate-decr-depth! tstate)
  (tstate-set-depth! tstate (1- (tstate-depth tstate)))
)

; Traversal/compilation support.

; Return a boolean indicating if X is a mode.

(define (-rtx-any-mode? x)
  (->bool (mode:lookup x))
)

; Return a boolean indicating if X is a symbol or rtx.

(define (-rtx-symornum? x)
  (or (symbol? x) (number? x))
)

; Traverse a list of rtx's.

(define (-rtx-traverse-rtx-list rtx-list mode expr op-num tstate appstuff)
  (map (lambda (rtx)
	 ; ??? Shouldn't OP-NUM change for each element?
	 (-rtx-traverse rtx 'RTX mode expr op-num tstate appstuff))
       rtx-list)
)

; Cover-fn to context-error for signalling an error during rtx traversal.

(define (-rtx-traverse-error tstate errmsg expr op-num)
;  (parse-error context (string-append errmsg ", operand number "
;				      (number->string op-num))
;	       (rtx-dump expr))
  (context-error (tstate-context tstate)
		 (string-append errmsg ", operand #" (number->string op-num))
		 (rtx-strdump expr))
)

; Rtx traversers.
; These are defined as individual functions that are then built into a table
; so that we can use Hobbit's "fastcall" support.
;
; The result is either a pair of the parsed VAL and new TSTATE,
; or #f meaning there is no change (saves lots of unnecessarying cons'ing).

(define (-rtx-traverse-options val mode expr op-num tstate appstuff)
  #f
)

(define (-rtx-traverse-anymode val mode expr op-num tstate appstuff)
  (let ((val-obj (mode:lookup val)))
    (if (not val-obj)
	(-rtx-traverse-error tstate "expecting a mode"
			     expr op-num))
    #f)
)

(define (-rtx-traverse-intmode val mode expr op-num tstate appstuff)
  (let ((val-obj (mode:lookup val)))
    (if (and val-obj
	     (or (memq (mode:class val-obj) '(INT UINT))
		 (eq? val 'DFLT)))
	#f
	(-rtx-traverse-error tstate "expecting an integer mode"
			     expr op-num)))
)

(define (-rtx-traverse-floatmode val mode expr op-num tstate appstuff)
  (let ((val-obj (mode:lookup val)))
    (if (and val-obj
	     (or (memq (mode:class val-obj) '(FLOAT))
		 (eq? val 'DFLT)))
	#f
	(-rtx-traverse-error tstate "expecting a float mode"
			     expr op-num)))
)

(define (-rtx-traverse-nummode val mode expr op-num tstate appstuff)
  (let ((val-obj (mode:lookup val)))
    (if (and val-obj
	     (or (memq (mode:class val-obj) '(INT UINT FLOAT))
		 (eq? val 'DFLT)))
	#f
	(-rtx-traverse-error tstate "expecting a numeric mode"
			     expr op-num)))
)

(define (-rtx-traverse-explnummode val mode expr op-num tstate appstuff)
  (let ((val-obj (mode:lookup val)))
    (if (not val-obj)
	(-rtx-traverse-error tstate "expecting a mode"
			     expr op-num))
    (if (memq val '(DFLT VOID))
	(-rtx-traverse-error tstate "DFLT and VOID not allowed here"
			     expr op-num))
    #f)
)

(define (-rtx-traverse-nonvoidmode val mode expr op-num tstate appstuff)
  (if (eq? val 'VOID)
      (-rtx-traverse-error tstate "mode can't be VOID"
			   expr op-num))
  #f
)

(define (-rtx-traverse-voidmode val mode expr op-num tstate appstuff)
  (if (memq val '(DFLT VOID))
      #f
      (-rtx-traverse-error tstate "expecting mode VOID"
			   expr op-num))
)

(define (-rtx-traverse-dfltmode val mode expr op-num tstate appstuff)
  (if (eq? val 'DFLT)
      #f
      (-rtx-traverse-error tstate "expecting mode DFLT"
			   expr op-num))
)

(define (-rtx-traverse-rtx val mode expr op-num tstate appstuff)
; Commented out 'cus it doesn't quite work yet.
; (if (not (rtx? val))
;     (-rtx-traverse-error tstate "expecting an rtx"
;			   expr op-num))
  (cons (-rtx-traverse val 'RTX mode expr op-num tstate appstuff)
	tstate)
)

(define (-rtx-traverse-setrtx val mode expr op-num tstate appstuff)
  ; FIXME: Still need to turn it off for sub-exprs.
  ; e.g. (mem (reg ...))
; Commented out 'cus it doesn't quite work yet.
; (if (not (rtx? val))
;     (-rtx-traverse-error tstate "expecting an rtx"
;				  expr op-num))
  (cons (-rtx-traverse val 'SETRTX mode expr op-num
		       (tstate-new-set? tstate #t)
		       appstuff)
	tstate)
)

; This is the test of an `if'.

(define (-rtx-traverse-testrtx val mode expr op-num tstate appstuff)
; Commented out 'cus it doesn't quite work yet.
; (if (not (rtx? val))
;     (-rtx-traverse-error tstate "expecting an rtx"
;				  expr op-num))
  (cons (-rtx-traverse val 'RTX mode expr op-num tstate appstuff)
	(tstate-new-cond?
	 tstate
	 (not (rtx-compile-time-constant? val))))
)

(define (-rtx-traverse-condrtx val mode expr op-num tstate appstuff)
  (if (not (pair? val))
      (-rtx-traverse-error tstate "expecting an expression"
			   expr op-num))
  (if (eq? (car val) 'else)
      (begin
	(if (!= (+ op-num 2) (length expr))
	    (-rtx-traverse-error tstate
				 "`else' clause not last"
				 expr op-num))
	(cons (cons 'else
		    (-rtx-traverse-rtx-list
		     (cdr val) mode expr op-num
		     (tstate-new-cond? tstate #t)
		     appstuff))
	      (tstate-new-cond? tstate #t)))
      (cons (cons
	     ; ??? Entries after the first are conditional.
	     (-rtx-traverse (car val) 'RTX 'ANY expr op-num tstate appstuff)
	     (-rtx-traverse-rtx-list
	      (cdr val) mode expr op-num
	      (tstate-new-cond? tstate #t)
	      appstuff))
	    (tstate-new-cond? tstate #t)))
)

(define (-rtx-traverse-casertx val mode expr op-num tstate appstuff)
  (if (or (not (list? val))
	  (< (length val) 2))
      (-rtx-traverse-error tstate
			   "invalid `case' expression"
			   expr op-num))
  ; car is either 'else or list of symbols/numbers
  (if (not (or (eq? (car val) 'else)
	       (and (list? (car val))
		    (not (null? (car val)))
		    (all-true? (map -rtx-symornum?
				    (car val))))))
      (-rtx-traverse-error tstate
			   "invalid `case' choice"
			   expr op-num))
  (if (and (eq? (car val) 'else)
	   (!= (+ op-num 2) (length expr)))
      (-rtx-traverse-error tstate "`else' clause not last"
			   expr op-num))
  (cons (cons (car val)
	      (-rtx-traverse-rtx-list
	       (cdr val) mode expr op-num
	       (tstate-new-cond? tstate #t)
	       appstuff))
	(tstate-new-cond? tstate #t))
)

(define (-rtx-traverse-locals val mode expr op-num tstate appstuff)
  (if (not (list? val))
      (-rtx-traverse-error tstate "bad locals list"
			   expr op-num))
  (for-each (lambda (var)
	      (if (or (not (list? var))
		      (!= (length var) 2)
		      (not (-rtx-any-mode? (car var)))
		      (not (symbol? (cadr var))))
		  (-rtx-traverse-error tstate
				       "bad locals list"
				       expr op-num)))
	    val)
  (let ((env (rtx-env-make-locals val)))
    (cons val (tstate-push-env tstate env)))
)

(define (-rtx-traverse-env val mode expr op-num tstate appstuff)
  ; VAL is an environment stack.
  (if (not (list? val))
      (-rtx-traverse-error tstate "environment not a list"
			   expr op-num))
  (cons val (tstate-new-env tstate val))
)

(define (-rtx-traverse-attrs val mode expr op-num tstate appstuff)
;  (cons val ; (atlist-source-form (atlist-parse val "" "with-attr"))
;	tstate)
  #f
)

(define (-rtx-traverse-symbol val mode expr op-num tstate appstuff)
  (if (not (symbol? val))
      (-rtx-traverse-error tstate "expecting a symbol"
			   expr op-num))
  #f
)

(define (-rtx-traverse-string val mode expr op-num tstate appstuff)
  (if (not (string? val))
      (-rtx-traverse-error tstate "expecting a string"
			   expr op-num))
  #f
)

(define (-rtx-traverse-number val mode expr op-num tstate appstuff)
  (if (not (number? val))
      (-rtx-traverse-error tstate "expecting a number"
			   expr op-num))
  #f
)

(define (-rtx-traverse-symornum val mode expr op-num tstate appstuff)
  (if (not (or (symbol? val) (number? val)))
      (-rtx-traverse-error tstate
			   "expecting a symbol or number"
			   expr op-num))
  #f
)

(define (-rtx-traverse-object val mode expr op-num tstate appstuff)
  #f
)

; Table of rtx traversers.
; This is a vector of size rtx-max-num.
; Each entry is a list of (arg-type-name . traverser) elements
; for rtx-arg-types.

(define -rtx-traverser-table #f)

; Return a hash table of standard operand traversers.
; The result of each traverser is a pair of the compiled form of `val' and
; a possibly new traversal state or #f if there is no change.

(define (-rtx-make-traverser-table)
  (let ((hash-tab (make-hash-table 31))
	(traversers
	 (list
	  ; /fastcall-make is recognized by Hobbit and handled specially.
	  ; When not using Hobbit it is a macro that returns its argument.
	  (cons 'OPTIONS (/fastcall-make -rtx-traverse-options))
	  (cons 'ANYMODE (/fastcall-make -rtx-traverse-anymode))
	  (cons 'INTMODE (/fastcall-make -rtx-traverse-intmode))
	  (cons 'FLOATMODE (/fastcall-make -rtx-traverse-floatmode))
	  (cons 'NUMMODE (/fastcall-make -rtx-traverse-nummode))
	  (cons 'EXPLNUMMODE (/fastcall-make -rtx-traverse-explnummode))
	  (cons 'NONVOIDFLTODE (/fastcall-make -rtx-traverse-nonvoidmode))
	  (cons 'VOIDFLTODE (/fastcall-make -rtx-traverse-voidmode))
	  (cons 'DFLTMODE (/fastcall-make -rtx-traverse-dfltmode))
	  (cons 'RTX (/fastcall-make -rtx-traverse-rtx))
	  (cons 'SETRTX (/fastcall-make -rtx-traverse-setrtx))
	  (cons 'TESTRTX (/fastcall-make -rtx-traverse-testrtx))
	  (cons 'CONDRTX (/fastcall-make -rtx-traverse-condrtx))
	  (cons 'CASERTX (/fastcall-make -rtx-traverse-casertx))
	  (cons 'LOCALS (/fastcall-make -rtx-traverse-locals))
	  (cons 'ENV (/fastcall-make -rtx-traverse-env))
	  (cons 'ATTRS (/fastcall-make -rtx-traverse-attrs))
	  (cons 'SYMBOL (/fastcall-make -rtx-traverse-symbol))
	  (cons 'STRING (/fastcall-make -rtx-traverse-string))
	  (cons 'NUMBER (/fastcall-make -rtx-traverse-number))
	  (cons 'SYMORNUM (/fastcall-make -rtx-traverse-symornum))
	  (cons 'OBJECT (/fastcall-make -rtx-traverse-object))
	  )))

    (for-each (lambda (traverser)
		(hashq-set! hash-tab (car traverser) (cdr traverser)))
	      traversers)

    hash-tab)
)

; Traverse the operands of EXPR, a canonicalized RTL expression.
; Here "canonicalized" means that -rtx-munge-mode&options has been called to
; insert an option list and mode if they were absent in the original
; expression.

(define (-rtx-traverse-operands rtx-obj expr tstate appstuff)
  (if -rtx-traverse-debug?
      (begin
	(display (spaces (* 4 (tstate-depth tstate))))
	(display "Traversing operands of: ")
	(display (rtx-dump expr))
	(newline)
	(rtx-env-dump (tstate-env tstate))
	(force-output)
	))

  (let loop ((operands (cdr expr))
	     (op-num 0)
	     (arg-types (vector-ref -rtx-traverser-table (rtx-num rtx-obj)))
	     (arg-modes (rtx-arg-modes rtx-obj))
	     (result nil)
	     )

    (let ((varargs? (and (pair? arg-types) (symbol? (car arg-types)))))

      (if -rtx-traverse-debug?
	  (begin
	    (display (spaces (* 4 (tstate-depth tstate))))
	    (if (null? operands)
		(display "end of operands")
		(begin
		  (display "op-num ") (display op-num) (display ": ")
		  (display (rtx-dump (car operands)))
		  (display ", ")
		  (display (if varargs? (car arg-types) (caar arg-types)))
		  (display ", ")
		  (display (if varargs? arg-modes (car arg-modes)))
		  ))
	    (newline)
	    (force-output)
	    ))

      (cond ((null? operands)
	     ; Out of operands, check if we have the expected number.
	     (if (or (null? arg-types)
		     varargs?)
		 (reverse! result)
		 (context-error (tstate-context tstate)
				"missing operands" (rtx-strdump expr))))

	    ((null? arg-types)
	     (context-error (tstate-context tstate)
			    "too many operands" (rtx-strdump expr)))

	    (else
	     (let ((type (if varargs? arg-types (car arg-types)))
		   (mode (let ((mode-spec (if varargs?
					      arg-modes
					      (car arg-modes))))
			   ; This is small enough that this is fast enough,
			   ; and the number of entries should be stable.
			   ; FIXME: for now
			   (case mode-spec
			     ((ANY) 'DFLT)
			     ((NA) #f)
			     ((OP0) (rtx-mode expr))
			     ((MATCH1)
			      ; If there is an explicit mode, use it.
			      ; Otherwise we have to look at operand 1.
			      (if (eq? (rtx-mode expr) 'DFLT)
				  'DFLT
				  (rtx-mode expr)))
			     ((MATCH2)
			      ; If there is an explicit mode, use it.
			      ; Otherwise we have to look at operand 2.
			      (if (eq? (rtx-mode expr) 'DFLT)
				  'DFLT
				  (rtx-mode expr)))
			     (else mode-spec))))
		   (val (car operands))
		   )

	       ; Look up the traverser for this kind of operand and perform it.
	       (let ((traverser (cdr type)))
		 (let ((traversed-val (fastcall6 traverser val mode expr op-num tstate appstuff)))
		   (if traversed-val
		       (begin
			 (set! val (car traversed-val))
			 (set! tstate (cdr traversed-val))))))

	       ; Done with this operand, proceed to the next.
	       (loop (cdr operands)
		     (+ op-num 1)
		     (if varargs? arg-types (cdr arg-types))
		     (if varargs? arg-modes (cdr arg-modes))
		     (cons val result)))))))
)

; Publically accessible version of -rtx-traverse-operands as EXPR-FN may
; need to call it.

(define rtx-traverse-operands -rtx-traverse-operands)

; Subroutine of -rtx-munge-mode&options.
; Return boolean indicating if X is an rtx option.

(define (-rtx-option? x)
  (and (symbol? x)
       (char=? (string-ref x 0) #\:))
)

; Subroutine of -rtx-munge-mode&options.
; Return boolean indicating if X is an rtx option list.

(define (-rtx-option-list? x)
  (or (null? x)
      (and (pair? x)
	   (-rtx-option? (car x))))
)

; Subroutine of -rtx-traverse-expr to fill in the mode if absent and to
; collect the options into one list.
; ARGS is the list of arguments to the rtx function
; (e.g. (1 2) in (add 1 2)).
; ??? "munge" is an awkward name to use here, but I like it for now because
; it's easy to grep for.
; ??? An empty option list requires a mode to be present so that the empty
; list in `(sequence () foo bar)' is unambiguously recognized as the locals
; list.  Icky, sure, but less icky than the alternatives thus far.

(define (-rtx-munge-mode&options args)
  (let ((options nil)
	(mode-name 'DFLT))
    ; Pick off the option list if present.
    (if (and (pair? args)
	     (-rtx-option-list? (car args))
	     ; Handle `(sequence () foo bar)'.  If empty list isn't followed
	     ; by a mode, it is not an option list.
	     (or (not (null? (car args)))
		 (and (pair? (cdr args))
		      (mode-name? (cadr args)))))
	(begin
	  (set! options (car args))
	  (set! args (cdr args))))
    ; Pick off the mode if present.
    (if (and (pair? args)
	     (mode-name? (car args)))
	(begin
	  (set! mode-name (car args))
	  (set! args (cdr args))))
    ; Now put option list and mode back.
    (cons options (cons mode-name args)))
)

; Traverse an expression.
; For syntax expressions arguments are not pre-evaluated before calling the
; user's expression handler.  Otherwise they are.
; If EXPR-FN wants to just scan the operands, rather than evaluating them,
; one thing it can do is call back to rtx-traverse-operands.
; If EXPR-FN returns #f, traverse the operands normally and return
; (rtx's-name traversed-operand1 ...).
; This is for semantic-compile's sake and all traversal handlers are
; required to do this if EXPR-FN returns #f.

(define (-rtx-traverse-expr rtx-obj expr mode parent-expr op-pos tstate appstuff)
  (let* ((expr2 (cons (car expr)
		      (-rtx-munge-mode&options (cdr expr))))
	 (fn (fastcall7 (tstate-expr-fn tstate)
			rtx-obj expr2 mode parent-expr op-pos tstate appstuff)))
    (if fn
	(if (procedure? fn)
	    ; Don't traverse operands for syntax expressions.
	    (if (rtx-style-syntax? rtx-obj)
		(apply fn (cons tstate (cdr expr2)))
		(let ((operands (-rtx-traverse-operands rtx-obj expr2 tstate appstuff)))
		  (apply fn (cons tstate operands))))
	    fn)
	(let ((operands (-rtx-traverse-operands rtx-obj expr2 tstate appstuff)))
	  (cons (car expr2) operands))))
)

; Main entry point for expression traversal.
; (Actually rtx-traverse is, but it's just a cover function for this.)
;
; The result is the result of the lambda EXPR-FN looks up in the case of
; expressions or an operand object (usually <operand>) in the case of operands.
;
; EXPR is the expression to be traversed.
;
; MODE is the name of the mode of EXPR.
;
; PARENT-EXPR is the expression EXPR is contained in.  The top-level
; caller must pass #f for it.
;
; OP-POS is the position EXPR appears in PARENT-EXPR.  The
; top-level caller must pass 0 for it.
;
; EXPECTED is one of `-rtx-valid-types' and indicates the expected rtx type
; or #f if it doesn't matter.
;
; TSTATE is the current traversal state.
;
; APPSTUFF is for application specific use.
;
; All macros are expanded here.  User code never sees them.
; All operand shortcuts are also expand here.  User code never sees them.
; These are:
; - operands, ifields, and numbers appearing where an rtx is expected are
;   converted to use `operand', `ifield', or `const'.

(define (-rtx-traverse expr expected mode parent-expr op-pos tstate appstuff)
  (if -rtx-traverse-debug?
      (begin
	(display (spaces (* 4 (tstate-depth tstate))))
	(display "Traversing expr: ")
	(display expr)
	(newline)
	(display (spaces (* 4 (tstate-depth tstate))))
	(display "-expected:       ")
	(display expected)
	(newline)
	(display (spaces (* 4 (tstate-depth tstate))))
	(display "-mode:           ")
	(display mode)
	(newline)
	(force-output)
	))

  (if (pair? expr) ; pair? -> cheap non-null-list?

      (let ((rtx-obj (rtx-lookup (car expr))))
	(tstate-incr-depth! tstate)
	(let ((result
	       (if rtx-obj
		   (-rtx-traverse-expr rtx-obj expr mode parent-expr op-pos tstate appstuff)
		   (let ((rtx-obj (-rtx-macro-lookup (car expr))))
		     (if rtx-obj
			 (-rtx-traverse (-rtx-macro-expand expr rtx-evaluator)
					expected mode parent-expr op-pos tstate appstuff)
			 (context-error (tstate-context tstate) "unknown rtx function"
					expr))))))
	  (tstate-decr-depth! tstate)
	  result))

      ; EXPR is not a list.
      ; See if it's an operand shortcut.
      (if (memq expected '(RTX SETRTX))

	  (cond ((symbol? expr)
		 (cond ((current-op-lookup expr)
			(-rtx-traverse
			 (rtx-make-operand expr) ; (current-op-lookup expr))
			 expected mode parent-expr op-pos tstate appstuff))
		       ((rtx-temp-lookup (tstate-env tstate) expr)
			(-rtx-traverse
			 (rtx-make-local expr) ; (rtx-temp-lookup (tstate-env tstate) expr))
			 expected mode parent-expr op-pos tstate appstuff))
		       ((current-ifld-lookup expr)
			(-rtx-traverse
			 (rtx-make-ifield expr)
			 expected mode parent-expr op-pos tstate appstuff))
		       ((enum-lookup-val expr)
			(-rtx-traverse
			 (rtx-make-enum 'INT expr)
			 expected mode parent-expr op-pos tstate appstuff))
		       (else
			(context-error (tstate-context tstate)
				       "unknown operand" expr))))
		((integer? expr)
		 (-rtx-traverse (rtx-make-const 'INT expr)
				expected mode parent-expr op-pos tstate appstuff))
		(else
		 (context-error (tstate-context tstate)
				"unexpected operand"
				expr)))

	  ; Not expecting RTX or SETRTX.
	  (context-error (tstate-context tstate)
			 "unexpected operand"
			 expr)))
)

; User visible procedures to traverse an rtl expression.
; These calls -rtx-traverse to do most of the work.
; See tstate-make for an explanation of EXPR-FN.
; CONTEXT is a <context> object or #f if there is none.
; LOCALS is a list of (mode . name) elements (the locals arg to `sequence').
; APPSTUFF is for application specific use.

(define (rtx-traverse context owner expr expr-fn appstuff)
  (-rtx-traverse expr #f 'DFLT #f 0
		 (tstate-make context owner expr-fn (rtx-env-empty-stack)
			      #f #f nil 0)
		 appstuff)
)

(define (rtx-traverse-with-locals context owner expr expr-fn locals appstuff)
  (-rtx-traverse expr #f 'DFLT #f 0
		 (tstate-make context owner expr-fn
			      (rtx-env-push (rtx-env-empty-stack)
					    (rtx-env-make-locals locals))
			      #f #f nil 0)
		 appstuff)
)

; Traverser debugger.

(define (rtx-traverse-debug expr)
  (rtx-traverse
   #f #f expr
   (lambda (rtx-obj expr mode parent-expr op-pos tstate appstuff)
     (display "-expr:    ")
     (display (string-append "rtx=" (obj:name rtx-obj)))
     (display " expr=")
     (display expr)
     (display " mode=")
     (display mode)
     (display " parent=")
     (display parent-expr)
     (display " op-pos=")
     (display op-pos)
     (display " cond?=")
     (display (tstate-cond? tstate))
     (newline)
     #f)
   #f
   )
)

; Convert rtl expression EXPR from source form to compiled form.
; The expression is validated and rtx macros are expanded as well.
; CONTEXT is a <context> object or #f if there is none.
; It is used in error messages.
; EXTRA-VARS-ALIST is an association list of extra (symbol <mode> value)
; elements to be used during value lookup.
;
; This does the same operation that rtx-traverse does, except that it provides
; a standard value for EXPR-FN.
;
; ??? In the future the compiled form may be the same as the source form
; except that all elements would be converted to their respective objects.

(define (-compile-expr-fn rtx-obj expr mode parent-expr op-pos tstate appstuff)
; (cond 
; The intent of this is to handle sequences/closures, but is it needed?
;  ((rtx-style-syntax? rtx-obj)
;   ((rtx-evaluator rtx-obj) rtx-obj expr mode
;			     parent-expr op-pos tstate))
;  (else
  (cons (car expr) ; rtx-obj
	(-rtx-traverse-operands rtx-obj expr tstate appstuff))
)

(define (rtx-compile context expr extra-vars-alist)
  (-rtx-traverse expr #f 'DFLT #f 0
		 (tstate-make context #f
			      (/fastcall-make -compile-expr-fn)
			      (rtx-env-init-stack1 extra-vars-alist)
			      #f #f nil 0)
		 #f)
)

a882 218
; RTL evaluation state.
; Applications may subclass <eval-state> if they need to add things.
;
; This is initialized before evaluation, and modified (in a copy) as the
; evaluation state changes.
; This doesn't record all evaluation state, just the less dynamic elements.
; There's no point in recording things like the parent expression and operand
; position as they change for every sub-eval.
; The main raison d'etre for this class is so we can add more state without
; having to modify all the eval handlers.

(define <eval-state>
  (class-make '<eval-state> nil
	      '(
		; <context> object or #f if there is none
		(context . #f)

		; Current object rtl is being evaluated for.
		; We need to be able to access the current instruction while
		; generating semantic code.  However, the semantic description
		; doesn't specify it as an argument to anything (and we don't
		; want it to).  So we record the value here.
		(owner . #f)

		; EXPR-FN is a dual-purpose beast.  The first purpose is to
		; just process the current expression and return the result.
		; The second purpose is to lookup the function which will then
		; process the expression.  It is applied recursively to the
		; expression and each sub-expression.  It must be defined as
		; (lambda (rtx-obj expr mode estate) ...).
		; If the result of EXPR-FN is a lambda, it is applied to
		; (cons ESTATE (cdr EXPR)).  ESTATE is prepended to the
		; arguments.
		; For syntax expressions if the result of EXPR-FN is #f,
		; the operands are processed using the builtin evaluator.
		; FIXME: This special handling of syntax expressions is
		; not currently done.
		; So to repeat: EXPR-FN can process the expression, and if its
		; result is a lambda then it also processes the expression.
		; The arguments to EXPR-FN are
		; (rtx-obj expr mode estate).
		; The arguments to the result of EXPR-FN are
		; (cons ESTATE (cdr EXPR)).
		; The reason for the duality is mostly history.
		; In time things should be simplified.
		(expr-fn . #f)

		; Current environment.  This is a stack of sequence locals.
		(env . ())

		; Current evaluation depth.  This is used, for example, to
		; control indentation in generated output.
		(depth . 0)

		; Associative list of modifiers.
		; This is here to support things like `delay'.
		(modifiers . ())
		)
	      nil)
)

; Create an <eval-state> object using a list of keyword/value elements.
; ARGS is a list of #:keyword/value elements.
; The result is a list of the unrecognized elements.
; Subclasses should override this method and send-next it first, then
; see if they recognize anything in the result, returning what isn't
; recognized.

(method-make!
 <eval-state> 'vmake!
 (lambda (self args)
   (let loop ((args args) (unrecognized nil))
     (if (null? args)
	 (reverse! unrecognized) ; ??? Could invoke method to initialize here.
	 (begin
	   (case (car args)
	     ((#:context)
	      (elm-set! self 'context (cadr args)))
	     ((#:owner)
	      (elm-set! self 'owner (cadr args)))
	     ((#:expr-fn)
	      (elm-set! self 'expr-fn (cadr args)))
	     ((#:env)
	      (elm-set! self 'env (cadr args)))
	     ((#:depth)
	      (elm-set! self 'depth (cadr args)))
	     ((#:modifiers)
	      (elm-set! self 'modifiers (cadr args)))
	     (else
	      ; Build in reverse order, as we reverse it back when we're done.
	      (set! unrecognized
		    (cons (cadr args) (cons (car args) unrecognized)))))
	   (loop (cddr args) unrecognized)))))
)

; Accessors.

(define-getters <eval-state> estate
  (context owner expr-fn env depth modifiers)
)
(define-setters <eval-state> estate
  (context owner expr-fn env depth modifiers)
)

; Build an estate for use in producing a value from rtl.
; CONTEXT is a <context> object or #f if there is none.
; OWNER is the owner of the expression or #f if there is none.

(define (estate-make-for-eval context owner)
  (vmake <eval-state>
	 #:context context
	 #:owner owner
	 #:expr-fn (lambda (rtx-obj expr mode estate)
		     (rtx-evaluator rtx-obj)))
)

; Create a copy of ESTATE.

(define (estate-copy estate)
  (object-copy-top estate)
)

; Create a copy of STATE with a new environment ENV.

(define (estate-new-env state env)
  (let ((result (estate-copy state)))
    (estate-set-env! result env)
    result)
)

; Create a copy of STATE with environment ENV pushed onto the existing
; environment list.
; There's no routine to pop the environment list as there's no current
; need for it: we make a copy of the state when we push.

(define (estate-push-env state env)
  (let ((result (estate-copy state)))
    (estate-set-env! result (cons env (estate-env result)))
    result)
)

; Create a copy of STATE with modifiers MODS.

(define (estate-with-modifiers state mods)
  (let ((result (estate-copy state)))
    (estate-set-modifiers! result (append mods (estate-modifiers result)))
    result)
)

; Convert a tstate to an estate.

(define (tstate->estate t)
  (vmake <eval-state>
	 #:context (tstate-context t)
	 #:env (tstate-env t))
)

; RTL expression evaluation.
;
; ??? These used eval2 at one point.  Not sure which is faster but I suspect
; eval2 is by far.  On the otherhand this has yet to be compiled.  And this way
; is more portable, more flexible, and works with guile 1.2 (which has
; problems with eval'ing self referential vectors, though that's one reason to
; use smobs).

; Set to #t to debug rtx evaluation.

(define -rtx-eval-debug? #f)

; RTX expression evaluator.
;
; EXPR is the expression to be eval'd.  It must be in compiled form.
; MODE is the mode of EXPR, a <mode> object or its name.
; ESTATE is the current evaluation state.

(define (rtx-eval-with-estate expr mode estate)
  (if -rtx-eval-debug?
      (begin
	(display "Traversing ")
	(display expr)
	(newline)
	(rtx-env-dump (estate-env estate))
	))

  (if (pair? expr) ; pair? -> cheap non-null-list?

      (let* ((rtx-obj (rtx-lookup (car expr)))
	     (fn ((estate-expr-fn estate) rtx-obj expr mode estate)))
	(if fn
	    (if (procedure? fn)
		(apply fn (cons estate (cdr expr)))
;		; Don't eval operands for syntax expressions.
;		(if (rtx-style-syntax? rtx-obj)
;		    (apply fn (cons estate (cdr expr)))
;		    (let ((operands
;			   (-rtx-eval-operands rtx-obj expr estate)))
;		      (apply fn (cons estate operands))))
		fn)
	    ; Leave expr unchanged.
	    expr))
;	    (let ((operands
;		   (-rtx-traverse-operands rtx-obj expr estate)))
;	      (cons rtx-obj operands))))

      ; EXPR is not a list
      (error "argument to rtx-eval-with-estate is not a list" expr))
)

; Evaluate rtx expression EXPR and return the computed value.
; EXPR must already be in compiled form (the result of rtx-compile).
; OWNER is the owner of the value, used for attribute computation,
; or #f if there isn't one.
; FIXME: context?

(define (rtx-value expr owner)
  (rtx-eval-with-estate expr 'DFLT (estate-make-for-eval #f owner))
)

d1124 16
@


1.4
log
@* sfmt optimism fix

2001-06-01  Frank Ch. Eigler  <fche@@redhat.com>

	* rtl.scm (hw): Encode hw access mode into <operand> name, since this
	is required for multi-mode hw types (memory).
@
text
@d2032 1
d2034 1
@


1.3
log
@* belated outward merge

2001-01-26  Frank Ch. Eigler  <fche@@redhat.com>

	* sid-cpu.scm (gen-parallel-exec-type): Use unsigned long long for
	writeback tracking.
	(-gen-write-fn, -gen-sem-case, -gen-sfrag-case): Ditto.
	* sid-decode.scm (-gen-scache-decls): Exclude writeback tracking field
	if unnecessary.
	* sid.scm (<operand> gen-write): Use unsigned long long expression
	for writeback.
	(-op-gen-set-trace, -op-gen-set-trace-parallel): Ditto.
	(<unit> gen-profile-code): Ditto.

2001-01-08  Frank Ch. Eigler  <fche@@redhat.com>

	* operand.scm (<operand> pretty-sem-name): New field.
	(<operand> make): Initialize it from hw-name.
	(op:set-pretty-sem-name!): New function.
	(<operand> gen-pretty-name): Default to fetching new field.
	* rtl.scm (hw): Copy hw-name to pretty-sem-name instead.  Restore
	sem-name setting from -rtx-hw-name.
@
text
@d1999 3
a2001 2
    (let ((mode (if (eq? mode-name 'DFLT) (hw-mode hw) (mode:lookup mode-name)))
	  (result (new <operand>))) ; ??? lookup-for-new?
d2039 1
a2039 1
      (let ((name (-rtx-hw-name hw hw-name index-arg)))
@


1.2
log
@* cleanup

2001-01-08  Frank Ch. Eigler  <fche@@redhat.com>

	* rtl.scm (hw): Copy hw-name to new operand's sem-name, to simplify
	its subsequent gen-pretty-name.

	* read.scm: Increase thread working stack limit and backtrace
	depth limits.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
d2034 2
d2040 1
a2040 1
	(op:set-sem-name! result hw-name))
@


1.1
log
@Initial revision
@
text
@d2038 1
a2038 1
	(op:set-sem-name! result name))
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
