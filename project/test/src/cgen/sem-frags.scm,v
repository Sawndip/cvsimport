head	1.10;
access;
symbols
	sid-snapshot-20180601:1.10
	cgen-snapshot-20180601:1.10
	sid-snapshot-20180501:1.10
	cgen-snapshot-20180501:1.10
	sid-snapshot-20180401:1.10
	cgen-snapshot-20180401:1.10
	sid-snapshot-20180301:1.10
	cgen-snapshot-20180301:1.10
	sid-snapshot-20180201:1.10
	cgen-snapshot-20180201:1.10
	sid-snapshot-20180101:1.10
	cgen-snapshot-20180101:1.10
	sid-snapshot-20171201:1.10
	cgen-snapshot-20171201:1.10
	sid-snapshot-20171101:1.10
	cgen-snapshot-20171101:1.10
	sid-snapshot-20171001:1.10
	cgen-snapshot-20171001:1.10
	sid-snapshot-20170901:1.10
	cgen-snapshot-20170901:1.10
	sid-snapshot-20170801:1.10
	cgen-snapshot-20170801:1.10
	sid-snapshot-20170701:1.10
	cgen-snapshot-20170701:1.10
	sid-snapshot-20170601:1.10
	cgen-snapshot-20170601:1.10
	sid-snapshot-20170501:1.10
	cgen-snapshot-20170501:1.10
	sid-snapshot-20170401:1.10
	cgen-snapshot-20170401:1.10
	sid-snapshot-20170301:1.10
	cgen-snapshot-20170301:1.10
	sid-snapshot-20170201:1.10
	cgen-snapshot-20170201:1.10
	sid-snapshot-20170101:1.10
	cgen-snapshot-20170101:1.10
	sid-snapshot-20161201:1.10
	cgen-snapshot-20161201:1.10
	sid-snapshot-20161101:1.10
	cgen-snapshot-20161101:1.10
	sid-snapshot-20160901:1.10
	cgen-snapshot-20160901:1.10
	sid-snapshot-20160801:1.10
	cgen-snapshot-20160801:1.10
	sid-snapshot-20160701:1.10
	cgen-snapshot-20160701:1.10
	sid-snapshot-20160601:1.10
	cgen-snapshot-20160601:1.10
	sid-snapshot-20160501:1.10
	cgen-snapshot-20160501:1.10
	sid-snapshot-20160401:1.10
	cgen-snapshot-20160401:1.10
	sid-snapshot-20160301:1.10
	cgen-snapshot-20160301:1.10
	sid-snapshot-20160201:1.10
	cgen-snapshot-20160201:1.10
	sid-snapshot-20160101:1.10
	cgen-snapshot-20160101:1.10
	sid-snapshot-20151201:1.10
	cgen-snapshot-20151201:1.10
	sid-snapshot-20151101:1.10
	cgen-snapshot-20151101:1.10
	sid-snapshot-20151001:1.10
	cgen-snapshot-20151001:1.10
	sid-snapshot-20150901:1.10
	cgen-snapshot-20150901:1.10
	sid-snapshot-20150801:1.10
	cgen-snapshot-20150801:1.10
	sid-snapshot-20150701:1.10
	cgen-snapshot-20150701:1.10
	sid-snapshot-20150601:1.10
	cgen-snapshot-20150601:1.10
	sid-snapshot-20150501:1.10
	cgen-snapshot-20150501:1.10
	sid-snapshot-20150401:1.10
	cgen-snapshot-20150401:1.10
	sid-snapshot-20150301:1.10
	cgen-snapshot-20150301:1.10
	sid-snapshot-20150201:1.10
	cgen-snapshot-20150201:1.10
	sid-snapshot-20150101:1.10
	cgen-snapshot-20150101:1.10
	sid-snapshot-20141201:1.10
	cgen-snapshot-20141201:1.10
	sid-snapshot-20141101:1.10
	cgen-snapshot-20141101:1.10
	sid-snapshot-20141001:1.10
	cgen-snapshot-20141001:1.10
	sid-snapshot-20140901:1.10
	cgen-snapshot-20140901:1.10
	sid-snapshot-20140801:1.10
	cgen-snapshot-20140801:1.10
	sid-snapshot-20140701:1.10
	cgen-snapshot-20140701:1.10
	sid-snapshot-20140601:1.10
	cgen-snapshot-20140601:1.10
	sid-snapshot-20140501:1.10
	cgen-snapshot-20140501:1.10
	sid-snapshot-20140401:1.10
	cgen-snapshot-20140401:1.10
	sid-snapshot-20140301:1.10
	cgen-snapshot-20140301:1.10
	sid-snapshot-20140201:1.10
	cgen-snapshot-20140201:1.10
	sid-snapshot-20140101:1.10
	cgen-snapshot-20140101:1.10
	sid-snapshot-20131201:1.10
	cgen-snapshot-20131201:1.10
	sid-snapshot-20131101:1.10
	cgen-snapshot-20131101:1.10
	sid-snapshot-20131001:1.10
	cgen-snapshot-20131001:1.10
	sid-snapshot-20130901:1.10
	cgen-snapshot-20130901:1.10
	sid-snapshot-20130801:1.10
	cgen-snapshot-20130801:1.10
	sid-snapshot-20130701:1.10
	cgen-snapshot-20130701:1.10
	sid-snapshot-20130601:1.10
	cgen-snapshot-20130601:1.10
	sid-snapshot-20130501:1.10
	cgen-snapshot-20130501:1.10
	sid-snapshot-20130401:1.10
	cgen-snapshot-20130401:1.10
	sid-snapshot-20130301:1.10
	cgen-snapshot-20130301:1.10
	sid-snapshot-20130201:1.10
	cgen-snapshot-20130201:1.10
	sid-snapshot-20130101:1.10
	cgen-snapshot-20130101:1.10
	sid-snapshot-20121201:1.10
	cgen-snapshot-20121201:1.10
	sid-snapshot-20121101:1.10
	cgen-snapshot-20121101:1.10
	sid-snapshot-20121001:1.10
	cgen-snapshot-20121001:1.10
	sid-snapshot-20120901:1.10
	cgen-snapshot-20120901:1.10
	sid-snapshot-20120801:1.10
	cgen-snapshot-20120801:1.10
	sid-snapshot-20120701:1.10
	cgen-snapshot-20120701:1.10
	sid-snapshot-20120601:1.10
	cgen-snapshot-20120601:1.10
	sid-snapshot-20120501:1.10
	cgen-snapshot-20120501:1.10
	sid-snapshot-20120401:1.10
	cgen-snapshot-20120401:1.10
	sid-snapshot-20120301:1.10
	cgen-snapshot-20120301:1.10
	sid-snapshot-20120201:1.10
	cgen-snapshot-20120201:1.10
	sid-snapshot-20120101:1.10
	cgen-snapshot-20120101:1.10
	sid-snapshot-20111201:1.10
	cgen-snapshot-20111201:1.10
	sid-snapshot-20111101:1.10
	cgen-snapshot-20111101:1.10
	sid-snapshot-20111001:1.10
	cgen-snapshot-20111001:1.10
	sid-snapshot-20110901:1.10
	cgen-snapshot-20110901:1.10
	sid-snapshot-20110801:1.10
	cgen-snapshot-20110801:1.10
	sid-snapshot-20110701:1.10
	cgen-snapshot-20110701:1.10
	sid-snapshot-20110601:1.10
	cgen-snapshot-20110601:1.10
	sid-snapshot-20110501:1.10
	cgen-snapshot-20110501:1.10
	sid-snapshot-20110401:1.10
	cgen-snapshot-20110401:1.10
	sid-snapshot-20110301:1.10
	cgen-snapshot-20110301:1.10
	sid-snapshot-20110201:1.10
	cgen-snapshot-20110201:1.10
	sid-snapshot-20110101:1.10
	cgen-snapshot-20110101:1.10
	sid-snapshot-20101201:1.10
	cgen-snapshot-20101201:1.10
	sid-snapshot-20101101:1.10
	cgen-snapshot-20101101:1.10
	sid-snapshot-20101001:1.10
	cgen-snapshot-20101001:1.10
	sid-snapshot-20100901:1.10
	cgen-snapshot-20100901:1.10
	sid-snapshot-20100801:1.10
	cgen-snapshot-20100801:1.10
	sid-snapshot-20100701:1.10
	cgen-snapshot-20100701:1.10
	sid-snapshot-20100601:1.10
	cgen-snapshot-20100601:1.10
	sid-snapshot-20100501:1.10
	cgen-snapshot-20100501:1.10
	sid-snapshot-20100401:1.10
	cgen-snapshot-20100401:1.10
	sid-snapshot-20100301:1.10
	cgen-snapshot-20100301:1.10
	sid-snapshot-20100201:1.10
	cgen-snapshot-20100201:1.10
	sid-snapshot-20100101:1.10
	cgen-snapshot-20100101:1.10
	sid-snapshot-20091201:1.10
	cgen-snapshot-20091201:1.10
	sid-snapshot-20091101:1.9
	cgen-snapshot-20091101:1.9
	sid-snapshot-20091001:1.9
	cgen-snapshot-20091001:1.9
	arc-sim-20090309:1.2
	sid-snapshot-20090901:1.5
	cgen-snapshot-20090901:1.5
	sid-snapshot-20090801:1.4
	cgen-snapshot-20090801:1.4
	sid-snapshot-20090701:1.4
	cgen-snapshot-20090701:1.4
	dje-cgen-play1-branch:1.4.0.2
	dje-cgen-play1-branchpoint:1.4
	cgen-1_1-branch:1.2.0.6
	cgen-1_1-branchpoint:1.2
	sid-snapshot-20090601:1.2
	cgen-snapshot-20090601:1.2
	sid-snapshot-20090501:1.2
	cgen-snapshot-20090501:1.2
	sid-snapshot-20090401:1.2
	cgen-snapshot-20090401:1.2
	arc-insight_6_8-branch:1.2.0.4
	arc-insight_6_8-branchpoint:1.2
	sid-snapshot-20090301:1.2
	cgen-snapshot-20090301:1.2
	sid-snapshot-20090201:1.2
	cgen-snapshot-20090201:1.2
	sid-snapshot-20090101:1.2
	cgen-snapshot-20090101:1.2
	sid-snapshot-20081201:1.2
	cgen-snapshot-20081201:1.2
	sid-snapshot-20081101:1.2
	cgen-snapshot-20081101:1.2
	sid-snapshot-20081001:1.2
	cgen-snapshot-20081001:1.2
	sid-snapshot-20080901:1.2
	cgen-snapshot-20080901:1.2
	sid-snapshot-20080801:1.2
	cgen-snapshot-20080801:1.2
	sid-snapshot-20080701:1.2
	cgen-snapshot-20080701:1.2
	sid-snapshot-20080601:1.2
	cgen-snapshot-20080601:1.2
	sid-snapshot-20080501:1.2
	cgen-snapshot-20080501:1.2
	sid-snapshot-20080403:1.2
	sid-snapshot-20080401:1.2
	cgen-snapshot-20080401:1.2
	sid-snapshot-20080301:1.2
	cgen-snapshot-20080301:1.2
	sid-snapshot-20080201:1.2
	cgen-snapshot-20080201:1.2
	sid-snapshot-20080101:1.2
	cgen-snapshot-20080101:1.2
	sid-snapshot-20071201:1.2
	cgen-snapshot-20071201:1.2
	sid-snapshot-20071101:1.2
	cgen-snapshot-20071101:1.2
	sid-snapshot-20071001:1.2
	cgen-snapshot-20071001:1.2
	msnyder-fork-checkpoint-branch:1.2.0.2
	msnyder-fork-checkpoint-branchpoint:1.2
	sid-20020905-branchpoint:1.1.1.1
	sid-20020905-branch:1.1.1.1.0.6
	cagney_regbuf-20020515-branch:1.1.1.1.0.4
	cagney_regbuf-20020515-branchpoint:1.1.1.1
	cygnus_cvs_20020108_pre:1.1.1.1
	cgen-1-1-branch:1.1.1.1.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.10
date	2009.11.03.16.24.02;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.23.22.30.19;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2009.09.23.17.19.24;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2009.09.12.17.34.15;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	2009.09.07.22.17.34;	author devans;	state Exp;
branches;
next	1.5;

1.5
date	2009.08.12.22.33.37;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.22.07.02.36;	author devans;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.10.21.22.03;	author devans;	state Exp;
branches
	1.2.6.1;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.2.6.1
date	2009.06.24.14.57.46;	author devans;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.10
log
@	Specify isa(s) when doing ifield, operand, insn lookups.
	ACU = all callers updated.
	* attr.scm (/attr-eval): Call rtx-value instead of rtx-eval-with-estate.
	* enum.scm (define-full-insn-enum): Pass isa-name-list to
	current-ifld-lookup.
	* html.scm (get-insn-properties): Pass isa-name-list to
	current-op-lookup.
	* ifield.scm (/ifld-parse-follows): New arg isas, ACU.
	* insn.scm (/parse-insn-format-symbol): New arg isa-name-list, ACU.
	(/parse-insn-format-list, /parse-insn-iformat-iflds): Ditto.
	(/parse-insn-format, syntax-break-out): Ditto.
	* mach.scm (obj-filter-by-isa): New function.
	(current-ifld-lookup): New optional arg maybe-isa-name-list.
	(/ifld-already-defined?, /op-already-defined?): Simplify.
	(current-op-lookup): New optional arg maybe-isa-name-list.
	(current-insn-lookup): New arg isa-name-list, ACU.
	(/insn-already-defined?, /minsn-already-defined?): Simplify.
	(current-minsn-lookup): New arg isa-name-list, ACU.
	* minsn.scm (/minsn-compute-iflds): Pass isa-name-list to
	current-op-lookup.
	* opc-itab.scm (compute-syntax): New arg isa-name-list, ACU.
	(gen-syntax-entry): Ditto.
	* operand.scm (/operand-parse): Pass isa-name-list to
	current-ifld-lookup.
	(/derived-parse-encoding): New arg isa-name-list, ACU.
	(/derived-parse-ifield-assertion): Ditto.
	(/derived-operand-parse): Pass isa-name-list to current-op-lookup.
	(/anyof-parse-choice): Ditto.
	(anyof-satisfies-assertions?): Pass context to rtx-solve.
	(/anyof-merge-syntax): New arg container, ACU.
	(operand-builtin!): Add pc to all isas.
	* rtl-c.scm (estate-make-for-rtl-c): Delete arg extra-vars-alist, ACU.
	(estate-make-for-rtl-c++, rtl-c-expr-parsed): Ditto.
	(rtl-c-parsed, rtl-c++-parsed): Ditto.
	(rtl-c): New arg isa-name-list, ACU.
	(rtl-c-expr, rtl-c++): Ditto.
	(closure): New arg isa-name-list, ACU.
	* rtl-traverse.scm (/make-cstate): New arg isa-name-list, ACU.
	(/cstate-isas): New function.
	(/rtx-canon-symbol-list): New function.
	(/rtx-canon-env-stack): Renamed from /rtx-canon-env, ACU.
	updated.
	(/rtx-make-canon-table): Rename ENV to ENVSTACK, new entry SYMBOLLIST.
	(/rtx-canon-rtx-operand): Pass isa list to current-op-lookup.
	(/rtx-canon-rtx-ref, /rtx-canon): Ditto.
	(rtx-canonicalize): New arg isa-name-list, ACU.
	(rtx-canonicalize-stmt): Delete.
	(tstate-make): New arg isas, ACU.
	(tstate-isas, tstate--set-isas!): New functions.
	(tstate-env-stack): Renamed from tstate-env, ACU.
	(tstate-set-env-stack!): Renamed from tstate-set-env!, ACU.
	(tstate-make-closure): Renamed from tstate-new-env, new arg
	isa-name-list, ACU.
	(/rtx-traverse-env): Delete.
	(/rtx-make-traverser-table): Rename ENV to ENVSTACK, new entry
	SUMBOLLIST.
	(/rtx-traverse): Include conditional flag in dump output.
	Update isa,envstack for closures.  Pass isa list to current-op-lookup.
	(<eval-state>): New member isas.  Rename env to env-stack.
	(<eval-state> vmake!): Handle #:isas.  #:env renamed to #:env-stack.
	(<eval-state>): New getter/setter for isas.  Rename env getter/setter
	to env-stack.
	(estate-make-for-eval): Provide #:isas.
	(estate-make-closure): Renamed from estate-new-env.  New arg
	isa-name-list, ACU.
	* rtl-xform.scm (/rtx-simplify-expr-fn): Handle closures.
	(/rtx-trim-args): ENV renamed to ENVSTACK.  Ad ITERATION, SYMBOLLIST.
	(/rtx-trim-for-doc): Handle closures.
	* rtl.scm (/rtx-valid-types): Rename ENV to ENVSTACK.  Add ITERATION,
	SYMBOLLIST.
	(rtx-env-var-list): Delete.
	(rtx-env-make): Handle already-compiled environments.
	(rtx-var-alist-to-env): New function.
	(rtx-var-alist-to-closure-env-stack, rtx-make-env-stack): New functions.
	(rtx-env-stack-dump): Renamed from rtx-env-dump, ACU.
	(rtx-operand-obj): New arg isa-name-list, ACU.
	(rtx-closure-isas, rtx-closure-env-stack, rtx-closure-expr): New
	functions.
	* rtx-funcs.scm (closure): New arg isa-name-list, reorder args, ACU.
	* sem-frags.scm (<sfrag>): Delete member compiled-semantics.
	(/frag-compute-desired-frags): Minor simplification.
	(/frag-pick-best): Ditto.
	* sid-cpu.scm (gen-semantic-code): Require canonical rtl.
	(/gen-sfrag-code): Update.
	* sim-cpu.scm (gen-semantic-code): Require canonical rtl.
	* utils-cgen.scm (sanitize): New arg isa-name-list, ACU.
	* utils.scm (non-null-intersection?): New function.
@
text
@; Semantic fragments.
; Copyright (C) 2000, 2009 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.

; Background info:
; Some improvement in pbb simulator efficiency is obtained in cases like
; the ARM where for example operand2 computation is expensive in terms of
; cpu cost, code size, and subroutine call overhead if the code is put in
; a subroutine.  It could be inlined, but there are numerous occurences
; resulting in poor icache usage.
; If the computation is put in its own fragment then code size is reduced
; [improving icache usage] and subroutine call overhead is removed in a
; computed-goto simulator [arguments are passed in machine generated local
; variables].
;
; The basic procedure here is to:
; - break all insns up into a set of statements
;   This is either one statement in the case of insns that don't begin with a
;   sequence, or a list of statements, one for each element in the sequence.
; - find a profitable set of common leading statements (called the "header")
;   and a profitable set of common trailing statements (called the "trailer")
;   What is "profitable" depends on
;   - how expensive the statement is
;   - how long the statement is
;   - the number of insns using the statement
;   - what fraction of the total insn the statement is
; - rewrite insn semantics in terms of the new header and trailer fragments
;   plus a "middle" part that is whatever is left over
;   - there is always a header, the middle and trailer parts are optional
;   - cti insns require a header and trailer, though they can be the same
;     fragment
;
; TODO:
; - check ARM orr insns which come out as header, tiny middle, trailer
;   - the tiny middle seems like a waste (combine with trailer?)
; - there are 8 trailers consisting of just `nop' for ARM
; - rearranging statements to increase number and length of common sets
; - combine common middle fragments
; - parallel's not handled yet (only have to handle parallel's at the
;   top level)
; - insns can also be split on timing-sensitive boundaries (pipeline, memory,
;   whatever) though that is not implemented yet.  This may involve rtl
;   additions.
;
; Usage:
; - call sim-sfrag-init! first, to initialize
; - call sim-sfrag-analyze-insns! to create the semantic fragments
; - afterwards, call
;   - sim-sfrag-insn-list
;   - sim-sfrag-frag-table
;   - sim-sfrag-usage-table
;   - sim-sfrag-locals-list

; Statement computation.

; Set to #t to collect various statistics.

(define /stmt-stats? #f)

; Collection of computed stats.  Only set if /stmt-stats? = #t.

(define /stmt-stats #f)

; Collection of computed statement data.  Only set if /stmt-stats? = #t.

(define /stmt-stats-data #f)

; Create a structure recording data of all statements.
; A pair of (next-ordinal . table).

(define (/stmt-data-make hash-size)
  (cons 0 (make-vector hash-size nil))
)

; Accessors.

(define (/stmt-data-table data) (cdr data))
(define (/stmt-data-next-num data) (car data))
(define (/stmt-data-set-next-num! data newval) (set-car! data newval))
(define (/stmt-data-hash-size data) (vector-length (cdr data)))

; A single statement.
; INSN semantics either consist of a single statement or a sequence of them.

(define <statement>
  (class-make '<statement> nil
	      '(
		; RTL code
		expr

		; Local variables of the sequence `expr' is in.
		; This is recorded in the same form as the sequence,
		; i.e. (MODE name).
		locals

		; Ordinal of the statement.
		num

		; Costs.
		; SPEED-COST is the cost of executing fragment, relative to a
		; simple add.
		; SIZE-COST is the size of the fragment, relative to a simple
		; add.
		; ??? The cost numbers are somewhat arbitrary and subject to
		; review.
		speed-cost
		size-cost

		; Users of this statement.
		; Each element is (owner-number . owner-object),
		; where owner-number is an index into the initial insn table
		; (e.g. insn-list arg of /sfrag-create-cse-mapping), and
		; owner-object is the corresponding object.
		users
		)
	      nil)
)

(define-getters <statement> -stmt (expr locals num speed-cost size-cost users))

(define-setters <statement> -stmt (users))

; Make a <statement> object of EXPR.
; LOCALS is a list of local variables of the sequence EXPR is in.
; NUM is the ordinal of EXPR.
; SPEED-COST is the cost of executing the statement, relative to a simple add.
; SIZE-COST is the size of the fragment, relative to a simple add.
; ??? The cost numbers are somewhat arbitrary and subject to review.
;
; The user list is set to nil.

(define (/stmt-make expr locals num speed-cost size-cost)
  (make <statement> expr locals num speed-cost size-cost nil)
)

; Add a user of STMT.

(define (/stmt-add-user! stmt user-num user-obj)
  (-stmt-set-users! stmt (cons (cons user-num user-obj) (-stmt-users stmt)))
  *UNSPECIFIED*
)

; Lookup STMT in DATA.
; CHAIN-NUM is an argument so it need only be computed once.
; The result is the found <statement> object or #f.

(define (/frag-lookup-stmt data chain-num stmt)
  (let ((table (/stmt-data-table data)))
    (let loop ((stmts (vector-ref table chain-num)))
      (cond ((null? stmts)
	     #f)
	    ; ??? equal? should be appropriate rtx-equal?, blah blah blah.
	    ((equal? (-stmt-expr (car stmts)) stmt)
	     (car stmts))
	    (else
	     (loop (cdr stmts))))))
)

; Hash a statement.

; Computed hash value.
; Global 'cus /frag-hash-compute! is defined globally so we can use
; /fastcall (FIXME: Need /fastcall to work on non-global procs).

(define /frag-hash-value-tmp 0)

(define (/frag-hash-string str)
  (let loop ((chars (map char->integer (string->list str))) (result 0))
    (if (null? chars)
	result
	(loop (cdr chars) (modulo (+ (* result 7) (car chars)) #xfffffff))))
)

;; MODE is the name of the mode.

(define (/frag-hash-compute! rtx-obj expr parent-expr op-pos tstate appstuff)
  (let ((h 0))
    (case (rtx-name expr)
      ((operand)
       (set! h (/frag-hash-string (symbol->string (rtx-operand-name expr)))))
      ((local)
       (set! h (/frag-hash-string (symbol->string (rtx-local-name expr)))))
      ((const)
       (set! h (rtx-const-value expr)))
      (else
       (set! h (rtx-num rtx-obj))))
    (set! /frag-hash-value-tmp
	  ; Keep number small.
	  (modulo (+ (* /frag-hash-value-tmp 3) h op-pos)
		  #xfffffff)))

  ; #f -> "continue with normal traversing"
  #f
)

(define (/frag-hash-stmt stmt locals size)
  (set! /frag-hash-value-tmp 0)
  (rtx-traverse-with-locals #f #f stmt /frag-hash-compute! locals #f)
  (modulo /frag-hash-value-tmp size)
)

; Compute the speed/size costs of a statement.

; Compute speed/size costs.
; Global 'cus /frag-cost-compute! is defined globally so we can use
; /fastcall (FIXME: Need /fastcall to work on non-global procs).

(define /frag-speed-cost-tmp 0)
(define /frag-size-cost-tmp 0)

;; MODE is the name of the mode.

(define (/frag-cost-compute! rtx-obj expr parent-expr op-pos tstate appstuff)
  ; FIXME: wip
  (let ((speed 0)
	(size 0))
    (case (rtx-class rtx-obj)
      ((ARG)
       #f) ; these don't contribute to costs (at least for now)
      ((SET)
       ; FIXME: speed/size = 0?
       (set! speed 1)
       (set! size 1))
      ((UNARY BINARY TRINARY COMPARE)
       (set! speed 1)
       (set! size 1))
      ((IF)
       (set! speed 2)
       (set! size 2))
      (else
       (set! speed 4)
       (set! size 4)))
    (set! /frag-speed-cost-tmp (+ /frag-speed-cost-tmp speed))
    (set! /frag-size-cost-tmp (+ /frag-size-cost-tmp size)))

  ; #f -> "continue with normal traversing"
  #f
)

(define (/frag-stmt-cost stmt locals)
  (set! /frag-speed-cost-tmp 0)
  (set! /frag-size-cost-tmp 0)
  (rtx-traverse-with-locals #f #f stmt /frag-cost-compute! locals #f)
  (cons /frag-speed-cost-tmp /frag-size-cost-tmp)
)

; Add STMT to statement table DATA.
; CHAIN-NUM is the chain in the hash table to add STMT to.
; {SPEED,SIZE}-COST are passed through to /stmt-make.
; The result is the newly created <statement> object.

(define (/frag-add-stmt! data chain-num stmt locals speed-cost size-cost)
  (let ((stmt (/stmt-make stmt locals (/stmt-data-next-num data) speed-cost size-cost))
	(table (/stmt-data-table data)))
    (vector-set! table chain-num (cons stmt (vector-ref table chain-num)))
    (/stmt-data-set-next-num! data (+ 1 (/stmt-data-next-num data)))
    stmt)
)

; Return the locals in EXPR.
; If a sequence, return locals.
; Otherwise, return nil.
; The result is in assq'able form.

(define (/frag-expr-locals expr)
  (if (rtx-kind? 'sequence expr)
      (rtx-sequence-locals expr)
      nil)
)

; Return the locals in EXPR in assq-able form, i.e. (name MODE).
; If a sequence, return locals.
; Otherwise, return nil.
; The result is in assq'able form.

(define (/frag-expr-assq-locals expr)
  (if (rtx-kind? 'sequence expr)
      (rtx-sequence-assq-locals expr)
      nil)
)

; Return the statements in EXPR.
; If a sequence, return the sequence's expressions.
; Otherwise, return (list expr).

(define (/frag-expr-stmts expr)
  (if (rtx-kind? 'sequence expr)
      (rtx-sequence-exprs expr)
      (list expr))
)

; Analyze statement STMT.
; If STMT is already in STMT-DATA increment its frequency count.
; Otherwise add it.
; LOCALS are locals of the sequence STMT is in.
; USAGE-TABLE is a vector of statement index lists for each expression.
; USAGE-INDEX is the index of USAGE-TABLE to use.
; OWNER is the object of the owner of the statement.

(define (/frag-analyze-expr-stmt! locals stmt stmt-data usage-table expr-num owner)
  (logit 3 "Analyzing statement: " (rtx-strdump stmt) "\n")
  (let* ((chain-num
	  (/frag-hash-stmt stmt locals (/stmt-data-hash-size stmt-data)))
	 (stmt-obj (/frag-lookup-stmt stmt-data chain-num stmt)))

    (logit 3 "  chain #" chain-num  "\n")

    (if (not stmt-obj)
	(let* ((costs (/frag-stmt-cost stmt locals))
	       (speed-cost (car costs))
	       (size-cost (cdr costs)))
	  (set! stmt-obj (/frag-add-stmt! stmt-data chain-num stmt locals
					  speed-cost size-cost))
	  (logit 3 "  new statement, #" (-stmt-num stmt-obj) "\n"))
	(logit 3   "  existing statement, #" (-stmt-num stmt-obj) "\n"))

    (/stmt-add-user! stmt-obj expr-num owner)

    ; If first entry, initialize list, otherwise append to existing list.
    (if (null? (vector-ref usage-table expr-num))
	(vector-set! usage-table expr-num (list (-stmt-num stmt-obj)))
	(append! (vector-ref usage-table expr-num)
		 (list (-stmt-num stmt-obj)))))

  *UNSPECIFIED*
)

; Analyze each statement in EXPR and add it to STMT-DATA.
; OWNER is the object of the owner of the expression.
; USAGE-TABLE is a vector of statement index lists for each expression.
; USAGE-INDEX is the index of the USAGE-TABLE entry to use.
; As each statement's ordinal is computed it is added to the usage list.

(define (/frag-analyze-expr! expr owner stmt-data usage-table usage-index)
  (logit 3 "Analyzing " (obj:name owner) ": " (rtx-strdump expr) "\n")
  (let ((locals (/frag-expr-locals expr))
	(stmt-list (/frag-expr-stmts expr)))
    (for-each (lambda (stmt)
		(/frag-analyze-expr-stmt! locals stmt stmt-data
					  usage-table usage-index owner))
	      stmt-list))
  *UNSPECIFIED*
)

; Compute statement data from EXPRS, a list of expressions.
; OWNERS is a vector of objects that "own" each corresponding element in EXPRS.
; The owner is usually an <insn> object.  Actually it'll probably always be
; an <insn> object but for now I want the disassociation.
;
; The result contains:
; - vector of statement lists of each expression
;   - each element is (stmt1-index stmt2-index ...) where each stmtN-index is
;     an index into the statement table
; - vector of statements (the statement table of the previous item)
;   - each element is a <statement> object

(define (/frag-compute-statements exprs owners)
  (logit 2 "Computing statement table ...\n")
  (let* ((num-exprs (length exprs))
	 (hash-size
	  ; FIXME: This is just a quick hack to put something down on paper.
	  ; blah blah blah.  Revisit as necessary.
	  (cond ((> num-exprs 300) 1019)
		((> num-exprs 100) 511)
		(else 127))))

    (let (; Hash table of expressions.
	  (stmt-data (/stmt-data-make hash-size))
	  ; Statement index lists for each expression.
	  (usage-table (make-vector num-exprs nil)))

      ; Scan each expr, filling in stmt-data and usage-table.
      (let loop ((exprs exprs) (exprnum 0))
	(if (not (null? exprs))
	    (let ((expr (car exprs))
		  (owner (vector-ref owners exprnum)))
	      (/frag-analyze-expr! expr owner stmt-data usage-table exprnum)
	      (loop (cdr exprs) (+ exprnum 1)))))

      ; Convert statement hash table to vector.
      (let ((stmt-hash-table (/stmt-data-table stmt-data))
	    (end (vector-length (/stmt-data-table stmt-data)))
	    (stmt-table (make-vector (/stmt-data-next-num stmt-data) #f)))
	(let loop ((i 0))
	  (if (< i end)
	      (begin
		(map (lambda (stmt)
		       (vector-set! stmt-table (-stmt-num stmt) stmt))
		     (vector-ref stmt-hash-table i))
		(loop (+ i 1)))))

	; All done.  Compute stats if asked to.
	(if /stmt-stats?
	    (begin
	      ; See how well the hashing worked.
	      (set! /stmt-stats-data stmt-data)
	      (set! /stmt-stats
		    (make-vector (vector-length stmt-hash-table) #f))
	      (let loop ((i 0))
		(if (< i end)
		    (begin
		      (vector-set! /stmt-stats i
				   (length (vector-ref stmt-hash-table i)))
		      (loop (+ i 1)))))))

	; Result.
	(cons usage-table stmt-table))))
)

; Semantic fragment selection.
;
; "semantic fragment" is the name assigned to each header/middle/trailer
; "fragment" as each may consist of more than one statement, though not
; necessarily all statements of the original sequence.

(define <sfrag>
  (class-make '<sfrag> '(<ident>)
	      '(
		; List of insn's using this frag.
		users

		; Ordinal's of each element of `users'.
		user-nums

		; Semantic format of insns using this fragment.
		sfmt

		; List of statement numbers that make up `semantics'.
		; Each element is an index into the stmt-table arg of
		; /frag-pick-best.
		; This is #f if the sfrag wasn't derived from some set of
		; statements.
		stmt-numbers

		; rtl source of fragment.
		semantics

		; Boolean indicating if this frag is for parallel exec support.
		parallel?

		; Boolean indicating if this is a header frag.
		; This includes all frags that begin a sequence.
		header?

		; Boolean indicating if this is a trailer frag.
		; This includes all frags that end a sequence.
		trailer?
		)
	      nil)
)

(define-getters <sfrag> sfrag
  (users user-nums sfmt stmt-numbers semantics
	 parallel? header? trailer?)
)

(define-setters <sfrag> sfrag
  (header? trailer?)
)

; Sorter to merge common fragments together.
; A and B are lists of statement numbers.

(define (/frag-sort a b)
  (cond ((null? a)
	 (not (null? b)))
	((null? b)
	 #f)
	((< (car a) (car b))
	 #t)
	((> (car a) (car b))
	 #f)
	(else ; =
	 (/frag-sort (cdr a) (cdr b))))
)

; Return a boolean indicating if L1,L2 match in the first LEN elements.
; Each element is an integer.

(define (/frag-list-match? l1 l2 len)
  (cond ((= len 0)
	 #t)
	((or (null? l1) (null? l2))
	 #f)
	((= (car l1) (car l2))
	 (/frag-list-match? (cdr l1) (cdr l2) (- len 1)))
	(else
	 #f))
)

; Return the number of expressions that match in the first LEN statements.

(define (/frag-find-matching expr-table indices stmt-list len)
  (let loop ((num-exprs 0) (indices indices))
    (cond ((null? indices)
	   num-exprs)
	  ((/frag-list-match? stmt-list
			      (vector-ref expr-table (car indices)) len)
	   (loop (+ num-exprs 1) (cdr indices)))
	  (else
	   num-exprs)))
)

; Return a boolean indicating if making STMT-LIST a common fragment
; among several owners is profitable.
; STMT-LIST is a list of statement numbers, indices into STMT-TABLE.
; NUM-EXPRS is the number of expressions with STMT-LIST in common.

(define (/frag-merge-profitable? stmt-table stmt-list num-exprs)
  ; FIXME: wip
  (and (>= num-exprs 2)
       (or ; No need to include speed costs yet.
	   ;(>= (/frag-list-speed-cost stmt-table stmt-list) 10)
	   (>= (/frag-list-size-cost stmt-table stmt-list) 4)))
)

; Return the cost of executing STMT-LIST.
; STMT-LIST is a list of statment numbers, indices into STMT-TABLE.
;
; FIXME: The yardstick to use is wip.  Currently we measure things relative
; to a simple add insn which is given the value 1.

(define (/frag-list-speed-cost stmt-table stmt-list)
  ; FIXME: wip
  (apply + (map (lambda (stmt-num)
		  (-stmt-speed-cost (vector-ref stmt-table stmt-num)))
		stmt-list))
)

(define (/frag-list-size-cost stmt-table stmt-list)
  ; FIXME: wip
  (apply + (map (lambda (stmt-num)
		  (-stmt-size-cost (vector-ref stmt-table stmt-num)))
		stmt-list))
)

; Compute the longest set of fragments it is desirable/profitable to create.
; The result is (number-of-matching-exprs . stmt-number-list)
; or #f if there isn't one (the longest set is the empty set).
;
; What is desirable depends on a few things:
; - how often is it used?
; - how expensive is it (size-wise and speed-wise)
; - relationship to other frags
;
; STMT-TABLE is a vector of all statements.
; STMT-USAGE-TABLE is a vector of all expressions.  Each element is a list of
; statement numbers (indices into STMT-TABLE).
; INDICES is a sorted list of indices into STMT-USAGE-TABLE.
; STMT-USAGE-TABLE is processed in the order specified by INDICES.
;
; FIXME: Choosing a statement list should depend on whether there are existing
; chosen statement lists only slightly shorter.

(define (/frag-longest-desired stmt-table stmt-usage-table indices)
  ; STMT-LIST is the list of statements in the first expression.
  (let ((stmt-list (vector-ref stmt-usage-table (car indices))))

    (let loop ((len 1) (prev-num-exprs 0))

      ; See how many subsequent expressions match at length LEN.
      (let ((num-exprs (/frag-find-matching stmt-usage-table (cdr indices)
					    stmt-list len)))
	; If there aren't any, we're done.
	; If LEN-1 is usable, return that.
	; Otherwise there is no profitable list of fragments.
	(if (= num-exprs 0)

	    (let ((matching-stmt-list (list-take (- len 1) stmt-list)))
	      (if (/frag-merge-profitable? stmt-table matching-stmt-list
					   prev-num-exprs)
		  (cons prev-num-exprs matching-stmt-list)
		  #f))

	    ; Found at least 1 subsequent matching expression.
	    ; Extend LEN and see if we still find matching expressions.
	    (loop (+ len 1) num-exprs)))))
)

; Return list of lists of objects for each unique <sformat-argbuf> in
; USER-LIST.
; Each element of USER-LIST is (insn-num . <insn> object).
; The result is a list of lists.  Each element in the top level list is
; a list of elements of USER-LIST that have the same <sformat-argbuf>.
; Insns are also distinguished by being a CTI insn vs a non-CTI insn.
; CTI insns require special handling in the semantics.

(define (/frag-split-by-sbuf user-list)
  ; Sanity check.
  (if (not (elm-bound? (cdar user-list) 'sfmt))
      (error "sformats not computed"))
  (if (not (elm-bound? (insn-sfmt (cdar user-list)) 'sbuf))
      (error "sformat argbufs not computed"))

  (let ((result nil)
	; Find INSN in SFMT-LIST.  The result is the list INSN belongs in
	; or #f.
	(find-obj (lambda (sbuf-list insn)
		    (let ((name (obj:name (sfmt-sbuf (insn-sfmt insn)))))
		      (let loop ((sbuf-list sbuf-list))
			(cond ((null? sbuf-list)
			       #f)
			      ((and (eq? name
					 (obj:name (sfmt-sbuf (insn-sfmt (cdaar sbuf-list)))))
				    (eq? (insn-cti? insn)
					 (insn-cti? (cdaar sbuf-list))))
			       (car sbuf-list))
			      (else
			       (loop (cdr sbuf-list))))))))
	)
    (let loop ((users user-list))
      (if (not (null? users))
	  (let ((try (find-obj result (cdar users))))
	    (if try
		(append! try (list (car users)))
		(set! result (cons (list (car users)) result)))
	    (loop (cdr users)))))

    ; Done
    result)
)

; Return a list of desired fragments to create.
; These consist of the longest set of profitable leading statements in EXPRS.
; Each element of the result is an <sfrag> object.
;
; STMT-TABLE is a vector of all statements.
; STMT-USAGE-TABLE is a vector of statement number lists of each expression.
; OWNER-TABLE is a vector of owner objects of each corresponding expression
; in STMT-USAGE-TABLE.
; KIND is one of 'header or 'trailer.
;
; This works for trailing fragments too as we do the computation based on the
; reversed statement lists.

(define (/frag-compute-desired-frags stmt-table stmt-usage-table owner-table kind)
  (logit 2 "Computing desired " kind " frags ...\n")

  (let* (
	 (stmt-usage-list
	  (if (eq? kind 'header)
	      (vector->list stmt-usage-table)
	      (map reverse (vector->list stmt-usage-table))))
	 ; Sort STMT-USAGE-TABLE.  That will bring exprs with common fragments
	 ; together.
	 (sorted-indices (sort-grade stmt-usage-list /frag-sort))
	 ; List of statement lists that together yield the fragment to create,
	 ; plus associated users.
	 (desired-frags nil)
	 )

    ; Update STMT-USAGE-TABLE in case we reversed the contents.
    (set! stmt-usage-table (list->vector stmt-usage-list))

    (let loop ((indices sorted-indices) (iteration 1))
      (logit 3 "Iteration " iteration "\n")
      (if (not (null? indices))
	  (let ((longest (/frag-longest-desired stmt-table stmt-usage-table indices)))

	    (if longest

		; Found an acceptable frag to create.
		(let* ((num-exprs (car longest))
		       ; Reverse statement numbers back if trailer.
		       (stmt-list (if (eq? kind 'header)
				      (cdr longest)
				      (reverse (cdr longest))))
		       (picked-indices (list-take num-exprs indices))
		       ; Need one copy of the frag for each sbuf, as structure
		       ; offsets will be different in generated C/C++ code.
		       (sfmt-users (/frag-split-by-sbuf
				    (map (lambda (expr-num)
					   (cons expr-num
						 (vector-ref owner-table
							     expr-num)))
					 picked-indices))))

		  (logit 3 "Creating frag of length " (length stmt-list) ", " num-exprs " users\n")
		  (logit 3 "Indices: " picked-indices "\n")

		  ; Create an sfrag for each sbuf.
		  (for-each
		   (lambda (users)
		     (let* ((first-owner (cdar users))
			    (context (make-obj-context first-owner "While building sfrags"))
			    (rtl (apply
				  rtx-make
				  (cons 'sequence
					(cons 'VOID
					      (cons nil
						    (map (lambda (stmt-num)
							   (-stmt-expr
							    (vector-ref stmt-table
									stmt-num)))
							 stmt-list))))))
			    (sfrag
			     (make <sfrag>
			       (symbol-append (obj:name first-owner)
					      (if (eq? kind 'header)
						  '-hdr
						  '-trlr))
			       ""
			       atlist-empty
			       (map cdr users)
			       (map car users)
			       (insn-sfmt first-owner)
			       stmt-list
			       rtl
			       #f ; parallel?
			       (eq? kind 'header)
			       (eq? kind 'trailer)
			       )))
		       (set! desired-frags (cons sfrag desired-frags))))
		   sfmt-users)

		  ; Continue, dropping statements we've put into the frag.
		  (loop (list-drop num-exprs indices) (+ iteration 1)))

		; Couldn't find an acceptable statement list.
		; Try again with next one.
		(begin
		  (logit 3 "No acceptable frag found.\n")
		  (loop (cdr indices) (+ iteration 1)))))))

    ; Done.
    desired-frags)
)

; Return the set of desired fragments to create.
; STMT-TABLE is a vector of each statement.
; STMT-USAGE-TABLE is a vector of (stmt1-index stmt2-index ...) elements for
; each expression, where each stmtN-index is an index into STMT-TABLE.
; OWNER-TABLE is a vector of owner objects of each corresponding expression
; in STMT-USAGE-TABLE.
;
; Each expression is split in up to three pieces: header, middle, trailer.
; This computes pseudo-optimal headers and trailers (if they exist).
; The "middle" part is whatever is leftover.
;
; The result is a vector of 4 elements:
; - vector of (header middle trailer) semantic fragments for each expression
;   - each element is an index into the respective table or #f if not present
; - list of header fragments, each element is an <sfrag> object
; - same but for trailer fragments
; - same but for middle fragments
;
; ??? While this is a big function, each piece is simple and straightforward.
; It's kept as one big function so we can compute each expression's sfrag list
; as we go.  Though it's not much extra expense to not do this.

(define (/frag-pick-best stmt-table stmt-usage-table owner-table)
  (let (
	(num-stmts (vector-length stmt-table))
	(num-exprs (vector-length stmt-usage-table))
	; FIXME: Shouldn't have to do vector->list.
	(stmt-usage-list (vector->list stmt-usage-table))
	; Specify result holders here, simplifies code.
	(desired-header-frags #f)
	(desired-trailer-frags #f)
	(middle-frags #f)
	; Also allocate space for expression sfrag usage table.
	; We compute it as we go to save scanning the header and trailer
	; lists twice.
	; copy-tree is needed to avoid shared storage.
	(expr-sfrags (copy-tree (make-vector (vector-length stmt-usage-table)
					     #(#f #f #f))))
	)

    ; Compute desired headers.
    (set! desired-header-frags
	  (/frag-compute-desired-frags stmt-table stmt-usage-table owner-table
				       'header))

    ; Compute the header used by each expression.
    (let ((expr-hdrs-v (make-vector num-exprs #f))
	  (num-hdrs (length desired-header-frags)))
      (let loop ((hdrs desired-header-frags) (hdrnum 0))
	(if (< hdrnum num-hdrs)
	    (let ((hdr (car hdrs)))
	      (for-each (lambda (expr-num)
			  (vector-set! (vector-ref expr-sfrags expr-num) 0
				       hdrnum)
			  (vector-set! expr-hdrs-v expr-num hdr))
			(sfrag-user-nums hdr))
	      (loop (cdr hdrs) (+ hdrnum 1)))))

      ; Truncate each expression by the header it will use and then find
      ; the set of desired trailers.
      (let ((expr-hdrs (vector->list expr-hdrs-v)))

	(set! desired-trailer-frags
	      (/frag-compute-desired-frags
	       stmt-table
	       ; FIXME: Shouldn't have to use list->vector.
	       ; [still pass a vector, but use vector-map here instead of map]
	       (list->vector
		(map (lambda (expr hdr)
		       (if hdr
			   (list-drop (length (sfrag-stmt-numbers hdr)) expr)
			   expr))
		     stmt-usage-list expr-hdrs))
	       owner-table
	       'trailer))

	; Record the trailer used by each expression.
	(let ((expr-trlrs-v (make-vector num-exprs #f))
	      (num-trlrs (length desired-trailer-frags)))
	  (let loop ((trlrs desired-trailer-frags) (trlrnum 0))
	    (if (< trlrnum num-trlrs)
		(let ((trlr (car trlrs)))
		  (for-each (lambda (expr-num)
			      (vector-set! (vector-ref expr-sfrags expr-num) 2
					   trlrnum)
			      (vector-set! expr-trlrs-v expr-num trlr))
			    (sfrag-user-nums trlr))
		  (loop (cdr trlrs) (+ trlrnum 1)))))

	  ; We have the desired headers and trailers, now compute the middle
	  ; part for each expression.  This is just what's left over.
	  ; ??? We don't try to cse the middle part.  Though we can in the
	  ; future should it prove useful enough.
	  (logit 2 "Computing middle frags ...\n")
	  (let* ((expr-trlrs (vector->list expr-trlrs-v))
		 (expr-middle-stmts
		  (map (lambda (expr hdr trlr)
			 (list-tail-drop
			  (if trlr (length (sfrag-stmt-numbers trlr)) 0)
			  (list-drop
			   (if hdr (length (sfrag-stmt-numbers hdr)) 0)
			   expr)))
		       stmt-usage-list expr-hdrs expr-trlrs)))

	    ; Finally, record the middle sfrags used by each expression.
	    (let loop ((tmp-middle-frags nil)
		       (next-middle-frag-num 0)
		       (expr-num 0)
		       (expr-middle-stmts expr-middle-stmts))

	      (if (null? expr-middle-stmts)

		  ; Done!
		  ; [The next statement executed after this is the one at the
		  ; end that builds the result.  Maybe it should be built here
		  ; and this should be the last statement, but I'm trying this
		  ; style out for awhile.]
		  (set! middle-frags (reverse! tmp-middle-frags))

		  ; Does this expr have a middle sfrag?
		  (if (null? (car expr-middle-stmts))
		      ; Nope.
		      (loop tmp-middle-frags
			    next-middle-frag-num
			    (+ expr-num 1)
			    (cdr expr-middle-stmts))
		      ; Yep.
		      (let* ((owner (vector-ref owner-table expr-num))
			     (context (make-obj-context owner "While building sfrags"))
			     (rtl (apply
				   rtx-make
				   (cons 'sequence
					 (cons 'VOID
					       (cons nil
						     (map (lambda (stmt-num)
							    (-stmt-expr
							     (vector-ref stmt-table stmt-num)))
							  (car expr-middle-stmts))))))))
			(vector-set! (vector-ref expr-sfrags expr-num)
				     1 next-middle-frag-num)
			(loop (cons (make <sfrag>
				      (symbol-append (obj:name owner) '-mid)
				      (string-append (obj:comment owner)
						     ", middle part")
				      (obj-atlist owner)
				      (list owner)
				      (list expr-num)
				      (insn-sfmt owner)
				      (car expr-middle-stmts)
				      rtl
				      #f ; parallel?
				      #f ; header?
				      #f ; trailer?
				      )
				    tmp-middle-frags)
			      (+ next-middle-frag-num 1)
			      (+ expr-num 1)
			      (cdr expr-middle-stmts))))))))))

    ; Result.
    (vector expr-sfrags
	    desired-header-frags
	    desired-trailer-frags
	    middle-frags))
)

; Given a list of expressions, return list of locals in top level sequences.
; ??? Collisions will be handled by rewriting rtl (renaming locals).
;
; This has to be done now as the cse pass must (currently) take into account
; the rewritten rtl.
; ??? This can be done later, with an appropriate enhancement to rtx-equal?
; ??? cse can be improved by ignoring local variable name (of course).

(define (/frag-compute-locals! expr-list)
  (logit 2 "Computing common locals ...\n")
  (let ((result nil)
	(lookup-local (lambda (local local-list)
			(assq (car local) local-list)))
	(local-equal? (lambda (l1 l2)
			(and (eq? (car l1) (car l2))
			     (mode:eq? (cadr l1) (cadr l2)))))
	)
    (for-each (lambda (expr)
		(let ((locals (/frag-expr-assq-locals expr)))
		  (for-each (lambda (local)
			      (let ((entry (lookup-local local result)))
				(if (and entry
					 (local-equal? local entry))
				    #f ; already present
				    (set! result (cons local result)))))
			    locals)))
	      expr-list)
    ; Done.
    result)
)

; Common subexpression computation.

; Given a list of rtl expressions and their owners, return a pseudo-optimal
; set of fragments and a usage list for each owner.
; Common fragments are combined and the original expressions become a sequence
; of these fragments.  The result is "pseudo-optimal" in the sense that the
; desired result is somewhat optimal, though no attempt is made at precise
; optimality.
;
; OWNERS is a list of objects that "own" each corresponding element in EXPRS.
; The owner is usually an <insn> object.  Actually it'll probably always be
; an <insn> object but for now I want the disassociation.
;
; The result is a vector of six elements:
; - sfrag usage table for each owner #(header middle trailer)
; - statement table (vector of all statements, made with /stmt-make)
; - list of sequence locals used by header sfrags
;   - these locals are defined at the top level so that all fragments have
;     access to them
;   - ??? Need to handle collisions among incompatible types.
; - header sfrags
; - trailer sfrags
; - middle sfrags

(define (/sem-find-common-frags-1 exprs owners)
  ; Sanity check.
  (if (not (elm-bound? (car owners) 'sfmt))
      (error "sformats not computed"))

  ; A simple procedure that calls, in order:
  ; /frag-compute-locals!
  ; /frag-compute-statements
  ; /frag-pick-best
  ; The rest is shuffling of results.

  ; Internally it's easier if OWNERS is a vector.
  (let ((owners (list->vector owners))
	(locals (/frag-compute-locals! exprs)))

    ; Collect statement usage data.
    (let ((stmt-usage (/frag-compute-statements exprs owners)))
      (let ((stmt-usage-table (car stmt-usage))
	    (stmt-table (cdr stmt-usage)))

	; Compute the frags we want to create.
	; These are in general sequences of statements.
	(let ((desired-frags
	       (/frag-pick-best stmt-table stmt-usage-table owners)))
	  (let (
		(expr-sfrags (vector-ref desired-frags 0))
		(headers (vector-ref desired-frags 1))
		(trailers (vector-ref desired-frags 2))
		(middles (vector-ref desired-frags 3))
		)
	    ; Result.
	    (vector expr-sfrags stmt-table locals
		    headers trailers middles))))))
)

; Cover proc of /sem-find-common-frags-1.
; See its documentation.

(define (sem-find-common-frags insn-list)
  (/sem-find-common-frags-1
   (begin
     (logit 2 "Simplifying rtl ...\n")
     (map (lambda (insn)
	    (rtx-simplify-insn #f insn))
	  insn-list))
   insn-list)
)

; Subroutine of /sfrag-create-cse-mapping to compute INSN's fragment list.
; FRAG-USAGE is a vector of 3 elements: #(header middle trailer).
; Each element is a fragment number or #f if not present.
; Numbers in FRAG-USAGE are indices relative to their respective subtables
; of FRAG-TABLE (which is a vector of all 3 tables concatenated together).
; NUM-HEADERS,NUM-TRAILERS are used to compute absolute indices.
;
; No header may have been created.  This happens when
; it's not profitable (or possible) to merge this insn's
; leading statements with other insns.  Ditto for
; trailer.  However, each cti insn must have a header
; and a trailer (for pc handling setup and change).
; Try to use the middle fragment if present.  Otherwise,
; use the x-header,x-trailer virtual insns.

(define (/sfrag-compute-frag-list! insn frag-usage frag-table num-headers num-trailers x-header-relnum x-trailer-relnum)
  ; `(list #f)' is so append! works.  The #f is deleted before returning.
  (let ((result (list #f))
	(header (vector-ref frag-usage 0))
	(middle (and (vector-ref frag-usage 1)
		     (+ (vector-ref frag-usage 1)
			num-headers num-trailers)))
	(trailer (and (vector-ref frag-usage 2)
		      (+ (vector-ref frag-usage 2)
			 num-headers)))
	(x-header-num x-header-relnum)
	(x-trailer-num (+ x-trailer-relnum num-headers))
	)

    ; cse'd header created?
    (if header
	; Yep.
	(append! result (list header))
	; Nope.  Use the middle frag if present, otherwise use x-header.
	; Can't use the trailer fragment because by definition it is shared
	; among several insns.
	(if middle
	    ; Mark the middle frag as the header frag.
	    (sfrag-set-header?! (vector-ref frag-table middle) #t)
	    ; No middle, use x-header.
	    (append! result (list x-header-num))))

    ; middle fragment present?
    (if middle
	(append! result (list middle)))

    ; cse'd trailer created?
    (if trailer
	; Yep.
	(append! result (list trailer))
	; Nope.  Use the middle frag if present, otherwise use x-trailer.
	; Can't use the header fragment because by definition it is shared
	; among several insns.
	(if middle
	    ; Mark the middle frag as the trailer frag.
	    (sfrag-set-trailer?! (vector-ref frag-table middle) #t)
	    ; No middle, use x-trailer.
	    (append! result (list x-trailer-num))))

    ; Done.
    (cdr result))
)

; Subroutine of /sfrag-create-cse-mapping to find the fragment number of the
; x-header/x-trailer virtual frags.

(define (/frag-lookup-virtual frag-list name)
  (let loop ((i 0) (frag-list frag-list))
    (if (null? frag-list)
	(assert (not "expected virtual insn not present"))
	(if (eq? name (obj:name (car frag-list)))
	    i
	    (loop (+ i 1) (cdr frag-list)))))
)

; Handle complex case, find set of common header and trailer fragments.
; The result is a vector of:
; - fragment table (a vector)
; - table mapping used fragments for each insn (a list)
; - locals list

(define (/sfrag-create-cse-mapping insn-list)
  (logit 1 "Creating semantic fragments for pbb engine ...\n")

  (let ((cse-data (sem-find-common-frags insn-list)))

    ; Extract the results of sem-find-common-frags.
    (let ((sfrag-usage-table (vector-ref cse-data 0))
	  (stmt-table (vector-ref cse-data 1))
	  (locals-list (vector-ref cse-data 2))
	  (header-list1 (vector-ref cse-data 3))
	  (trailer-list1 (vector-ref cse-data 4))
	  (middle-list (vector-ref cse-data 5)))

      ; Create two special frags: x-header, x-trailer.
      ; These are used by insns that don't have one or the other.
      ; Header/trailer table indices are already computed for each insn
      ; so append x-header/x-trailer to the end.
      (let ((header-list
	     (append header-list1
		     (list
		      (make <sfrag>
			'x-header
			"header fragment for insns without one"
			(atlist-parse (make-prefix-context "semantic frag computation")
				      '(VIRTUAL) "")
			nil ; users
			nil ; user ordinals
			(insn-sfmt (current-insn-lookup 'x-before #f))
			#f ; stmt-numbers
			(rtx-make 'nop)
			#f ; parallel?
			#t ; header?
			#f ; trailer?
			))))
	    (trailer-list
	     (append trailer-list1
		     (list
		      (make <sfrag>
			'x-trailer
			"trailer fragment for insns without one"
			(atlist-parse (make-prefix-context "semantic frag computation")
				      '(VIRTUAL) "")
			nil ; users
			nil ; user ordinals
			(insn-sfmt (current-insn-lookup 'x-before #f))
			#f ; stmt-numbers
			(rtx-make 'nop)
			#f ; parallel?
			#f ; header?
			#t ; trailer?
			)))))

	(let ((num-headers (length header-list))
	      (num-trailers (length trailer-list))
	      (num-middles (length middle-list)))

	  ; Combine the three sfrag tables (headers, trailers, middles) into
	  ; one big one.
	  (let ((frag-table (list->vector (append header-list
						  trailer-list
						  middle-list)))
		(x-header-relnum (/frag-lookup-virtual header-list 'x-header))
		(x-trailer-relnum (/frag-lookup-virtual trailer-list 'x-trailer))
		)
	    ; Convert sfrag-usage-table to one that refers to the one big
	    ; sfrag table.
	    (logit 2 "Computing insn frag usage ...\n")
	    (let ((insn-frags
		   (map (lambda (insn frag-usage)
			  (/sfrag-compute-frag-list! insn frag-usage
						     frag-table
						     num-headers num-trailers
						     x-header-relnum
						     x-trailer-relnum))
			insn-list
		        ; FIXME: vector->list
			(vector->list sfrag-usage-table)))
		  )
	      (logit 1 "Done fragment creation.\n")
	      (vector frag-table insn-frags locals-list)))))))
)

; Data analysis interface.

(define /sim-sfrag-init? #f)
(define (sim-sfrag-init?) /sim-sfrag-init?)

; Keep in globals for now, simplifies debugging.
; evil globals, blah blah blah.
(define /sim-sfrag-insn-list #f)
(define /sim-sfrag-frag-table #f)
(define /sim-sfrag-usage-table #f)
(define /sim-sfrag-locals-list #f)

(define (sim-sfrag-insn-list)
  (assert /sim-sfrag-init?)
  /sim-sfrag-insn-list
)
(define (sim-sfrag-frag-table)
  (assert /sim-sfrag-init?)
  /sim-sfrag-frag-table
)
(define (sim-sfrag-usage-table)
  (assert /sim-sfrag-init?)
  /sim-sfrag-usage-table
)
(define (sim-sfrag-locals-list)
  (assert /sim-sfrag-init?)
  /sim-sfrag-locals-list
)

(define (sim-sfrag-init!)
  (set! /sim-sfrag-init? #f)
  (set! /sim-sfrag-insn-list #f)
  (set! /sim-sfrag-frag-table #f)
  (set! /sim-sfrag-usage-table #f)
  (set! /sim-sfrag-locals-list #f)
)

(define (sim-sfrag-analyze-insns!)
  (if (not /sim-sfrag-init?)
      (begin
	(set! /sim-sfrag-insn-list (non-multi-insns (non-alias-insns (current-insn-list))))
	(let ((frag-data (/sfrag-create-cse-mapping /sim-sfrag-insn-list)))
	  (set! /sim-sfrag-frag-table (vector-ref frag-data 0))
	  (set! /sim-sfrag-usage-table (vector-ref frag-data 1))
	  (set! /sim-sfrag-locals-list (vector-ref frag-data 2)))
	(set! /sim-sfrag-init? #t)))

  *UNSPECIFIED*
)

; Testing support.

(define (/frag-small-test-data)
  '(
    (a . (sequence VOID ((SI tmp)) (set DFLT tmp rm) (set DFLT rd rm)))
    (b . (sequence VOID ((SI tmp)) (set DFLT tmp rm) (set DFLT rd rm)))
    (c . (set DFLT rd rm))
    )
)

(define (/frag-test-data)
  (cons
   (map (lambda (insn)
	  (rtx-simplify-insn #f insn))
	(non-multi-insns (non-alias-insns (current-insn-list))))
   (non-multi-insns (non-alias-insns (current-insn-list))))
)

(define test-sfrag-table #f)
(define test-stmt-table #f)
(define test-locals-list #f)
(define test-header-list #f)
(define test-trailer-list #f)
(define test-middle-list #f)

(define (frag-test-run)
  (let* ((test-data (/frag-test-data))
	 (frag-data (sem-find-common-frags (car test-data) (cdr test-data))))
    (set! test-sfrag-table (vector-ref frag-data 0))
    (set! test-stmt-table (vector-ref frag-data 1))
    (set! test-locals-list (vector-ref frag-data 2))
    (set! test-header-list (vector-ref frag-data 3))
    (set! test-trailer-list (vector-ref frag-data 4))
    (set! test-middle-list (vector-ref frag-data 5))
    )
  *UNSPECIFIED*
)
@


1.9
log
@	* xc16x.cpu (h-cr): New hardware.
	(muls): Comment out parts that won't compile, add fixme.
	(mulu, divl, divlu, jmpabs, jmpa-, jmprel, jbc, jnbs, callr): Ditto.
	(scxti, scxtmg, scxtm, bclear, bclr18, bset19, bitset, bmov): Ditto.
	(bmovn, band, bor, bxor, bcmp, bfldl, bfldh): Ditto.

	Rewrite rtl processing to require it to be "canonicalized" first,
	and write a full canonicalizer / expression checker.
	Remove all appearances of DFLT in canonical rtl.
	* attr.scm (/attr-eval atval owner): Call rtx-canonicalize,
	then rtx-simplify.
	* iformat.scm (ifmt-analyze) Use canonical semantics.
	* insn (<insn>): New member canonical-semantics.
	* mach.scm (<arch>): New member multi-insns-instantiated?.
	(/instantiate-multi-insns!): New function.
	(/canonicalize-insns!): New function.
	(arch-analyze-insns!): Canonicalize insn semantics before processing
	them.
	* mode.scm (/mode-set-word-params!): New function.
	(mode-void?): New function.
	(mode-compatible?): VOID is compatible with VOID.
	(/mode-word-sizes-defined?): New global.
	(mode-set-word-modes!): Use/set it.
	(mode-ensure-word-sizes-defined): Update.
	(mode-builtin!): New builtin "modes" SYM, INSN, MACH.
	Redo WI/UWI/AI/IAI handling.
	(op:new-mode): No longer accept DFLT.
	(<derived-operand> constructor): Ensure all fields are initialized.
	(<anyof-operand> constructor): Ditto.
	(/derived-parse-ifield-assertion): Delete arg `args'.
	All callers updated.
	* rtl-c.scm (<rtl-c-eval-state>): New member `for-insn?'.
	(rtl-c): Call rtx-canonicalize instead of rtx-compile.
	(rtl-c-expr, rtl-c++): Ditto.
	(/rtl-c-get): Use mode of operand, not containing expression.
	(rtl-c-set-quiet, rtl-c-set-trace): Remove DFLT support.
	(/rtx-use-sem-fn?): Don't check for (insn? owner), check
	estate-for-insn? instead.
	(s-unop): Use mode of expression, not first operand.
	(s-binop, s-binop-with-bit, s-shop, s-cmpop): Ditto.
	(s-sequence): Remove DFLT support.
	(ifield): Use mode of expression, not UINT.
	(pc): Comment out, unused.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	(set, set-quiet): Pass src to rtl-c-set-{trace,quiet} for expansion.
	* rtl-traverse.scm (/rtx-canon-debug?): New global.
	(/make-cstate): New function.
	(/cstate-context, /cstate-outer-expr): New functions.
	(/rtx-canon-error): New function.
	(/rtx-lookup-hw, /rtx-pick-mode, /rtx-pick-mode3, /rtx-pick-op-mode,
	/rtx-get-last-cond-case-rtx): New functions.
	(/rtx-canon-*): New functions.
	(/rtx-canner-table, /rtx-operand-canoners): New globals.
	(/rtx-make-canon-table, /rtx-special-expr-canoners): New functions.
	(/rtx-option, /rtx-option-list?): Rewrite.
	(rtx-munge-mode&options): Replaces /rtx-munge-mode&options.
	Rewritten, all callers updated.
	(/rtx-canon-expr, /rtx-canon): New functions.
	(rtx-canonicalize): Move here from rtl-xform.scm and rewrite.
	(rtx-canonicalize-stmt): New function.
	(tstate-make): Remove arg `set?'.  All callers updated.
	(tstate-new-set?): Delete.
	(/rtx-traverse-options, /rtx-traverse-*mode): Delete,
	moved to /rtx-canon-*.
	(/rtx-traverse-normal-operand): New function.
	(/rtx-traverse-rtx-list): Delete arg `mode', all callers updated.
	(/rtx-traverse-rtx, /rtx-traverse-setrtx,, /rtx-traverse-testrtx,
	/rtx-traverse-condrtx, /rtx-traverse-casertx, /rtx-traverse-locals,
	/rtx-traverse-iteration, /rtx-traverse-env, /rtx-traverse-attrs):
	Ditto.
	(/rtx-traverse-symbol, /rtx-traverse-string, /rtx-traverse-number,
	/rtx-traverse-symornum, /rtx-traverse-object): Delete.
	(/rtx-make-traverser-table): Update.
	(/rtx-traverse-operands): Remove mode processing, now done during
	canonicalization.
	(/rtx-traverse-expr): Delete arg `mode', all callers updated.
	(/rtx-traverse): Ditto.
	(rtx-init-traverser-tables!): New function.
	* rtl-xform (/rtx-verify-no-dflt-modes-expr-fn): New function.
	(rtx-verify-no-dflt-modes): New function.
	(/rtx-simplify-expr-fn): Update, `arg' mode deleted.
	(rtx-simplify-insn): Use insn-canonical-semantics.
	(rtx-canonicalize): Moved to rtl-traverse.scm.
	(/compile-expr-fn, rtx-compile): Delete.
	(/rtx-trim-rtx-list): New function.
	(/rtx-trim-for-doc): Handle set, if.
	* rtl.scm (<rtx-func>): New members result-mode, matchexpr-index.
	(/rtx-valid-mode-types): Update.
	(/rtx-valid-matches): Update.
	(/rtx-find-matchexpr-index): New function.
	(rtx-lookup): Require rtx-kind to be the rtx name.
	(def-rtx-node): New arg result-mode, all callers updated.
	(def-rtx-syntax-node, def-rtx-operand-node): Ditto.
	(rtx-lazy-sem-mode): Delete.
	(/rtx-closure-make): New arg `mode', all callers updated.
	(rtx-make-ifield, rtx-make-operand, rtx-make-local): Ditto.
	(rtx-operand-obj): Rewrite.
	(rtx-make-xop): New functions.
	(/hw): Renamed from `hw', all callers updated.
	Use the correct mode instead of DFLT for the index.
	(rtl-builtin!): Call rtx-init-traversal-tables!.
	(rtl-finish!): Update.
	* rtx-funcs.scm (all rtx functions): New parameter: result-mode.
	Update mode arg-type.
	(pc): Comment out.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	* sem-frags.scm (/frag-hash-compute!): Update, mode arg deleted.
	(/frag-cost-compute!): Ditto.
	* semantics.scm (/build-operand!): Delete args op-name, op.
	New arg op-expr.  All callers updated.
	(/build-mem-operand!): Remove DFLT support.
	(semantic-compile): Update process-expr!, mode arg deleted.
	* sid-cpu.scm (gen-semantic-code): Specify #:for-insn? in
	rtl-c++ calls.
	(/gen-sem-case, /gen-sfrag-code): Ditto.
	* sid.scm (/op-gen-set-trace1): Renamed from /op-gen-set-trace.
	(/op-gen-set-trace): New function.  If not doing profiling,
	call /op-gen-set-quiet.
	* sim-cpu.scm (gen-semantic-code): Specify #:for-insn? in rtl-c calls.
	* utils-gen.scm (/gen-ifld-extract-base): Update call to rtl-c.
	(/gen-ifld-extract-beyond, gen-multi-ifld-extract): Ditto.
	* utils.scm (find-first-index): New function.
	* doc/rtl.texi: Delete docs for `attr'.  Add `int-attr'.
@
text
@d199 1
a199 1
  (rtx-traverse-with-locals #f #f stmt /frag-hash-compute! locals #f) ; FIXME: (/fastcall-make /frag-hash-compute!))
d244 1
a244 1
  (rtx-traverse-with-locals #f #f stmt /frag-cost-compute! locals #f) ; FIXME: (/fastcall-make /frag-cost-compute!))
d436 1
a436 1
		; Raw rtl source of fragment.
a438 3
		; Compiled source.
		compiled-semantics

d454 1
a454 1
  (users user-nums sfmt stmt-numbers semantics compiled-semantics
d686 11
d709 1
a709 11
			       (apply
				rtx-make
				(cons 'sequence
				      (cons 'VOID
					    (cons nil
						  (map (lambda (stmt-num)
							 (-stmt-expr
							  (vector-ref stmt-table
								      stmt-num)))
						       stmt-list)))))
			       #f ; compiled-semantics
d857 11
a867 1
		      (let ((owner (vector-ref owner-table expr-num)))
d879 1
a879 10
				      (apply
				       rtx-make
				       (cons 'sequence
					     (cons 'VOID
						   (cons nil
							 (map (lambda (stmt-num)
								(-stmt-expr
								 (vector-ref stmt-table stmt-num)))
							      (car expr-middle-stmts))))))
				      #f ; compiled-semantics
d1107 1
a1107 1
			(insn-sfmt (current-insn-lookup 'x-before))
a1109 1
			#f ; compiled-semantics
d1124 1
a1124 1
			(insn-sfmt (current-insn-lookup 'x-before))
a1126 1
			#f ; compiled-semantics
@


1.8
log
@	* rtx-funcs.scm (eq,ne,lt,gt,le,ge,ltu,leu,gtu,geu): Change class
	to COMPARE.
	* sem-frags.scm (/frag-cost-compute!): Add COMPARE.
@
text
@d177 1
a177 1
(define (/frag-hash-compute! rtx-obj expr mode parent-expr op-pos tstate appstuff)
d214 1
a214 1
(define (/frag-cost-compute! rtx-obj expr mode parent-expr op-pos tstate appstuff)
d993 1
a993 1
     (logit 2 "Simplifying/canonicalizing rtl ...\n")
@


1.7
log
@	Clean up pass of mode handling.
	Make use of mode name vs <mode> object more consistent and clear.
	* hardware.scm (/keyword-read): Default mode to the mode name,
	not the <mode> object.
	(/hw-parse-indices): Parse mode name and pass mode object to
	<hw-asm> constructor.
	(/hw-parse-values): Ditto.
	(<hw-register> parse!): Pass mode name to /hw-parse-indices
	and /hw-parse-values.
	(<hw-memory> parse!): Ditto.
	(<hw-address> parse!): Ditto.
	* mode.scm (/mode-table): New global, replaces mode-list.
	Modes stored in hashtable instead of list.
	(/mode-class-table): New global.
	(mode-list-non-alias-values): Update.
	(mode:eq?, mode-compatible?, mode:add!): Update.
	(mode:lookup): Restrict arg to the mode's name.  All callers updated.
	(mode-maybe-lookup): New function.
	(mode-real-name): Restrict arg to a <mode> object.  All callers updated.
	(mode-real-mode, mode-sem-mode, mode-bigger?): Ditto.
	(mode-find, mode-set-word-modes!): Update
	(mode-ensure-word-sizes-defined): Update.
	(/sort-mode-classes!): New function.
	(mode-builtin!): Update.  Sort mode classes here.
	(mode-finish!): Sort mode classes here too.
	* rtl-c.scm (/rtl-c-get): Restrict mode arg to a <mode> object.
	All callers updated.
	(rtl-c-set-quiet): Allow mode to be name of object.
	(rtl-c-set-trace): Ditto.
	* rtl-traverse.scm (rtl-eval-with-estate): Restrict mode arg to
	<mode> object.  All callers updated.
	* rtl.scm (rtx-sem-mode): Restrict arg to <mode> object.
	(rtx-lazy-sem-mode): Ditto.
	(<rtx-temp> make!): Assert mode arg is a <mode> object.
	(rtx-env-make): Allow var-list modes to be name or object.
	* sem-frags.scm (/frag-expr-assq-locals): New function.
	(/frag-compute-locals!): Call it.
	(/sfrag-create-cse-mapping): Renamed from sfrag-create-cse-mapping.
	All callers updated.
	* semantics.scm (/build-mem-operand!): Handle mode aliases.
@
text
@d225 1
a225 1
      ((UNARY BINARY TRINARY)
@


1.6
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d93 2
d113 1
a113 1
		; (e.g. insn-list arg of sfrag-create-cse-mapping), and
d175 2
d212 2
d268 11
d915 1
a915 1
		(let ((locals (/frag-expr-locals expr)))
d1000 1
a1000 1
; Subroutine of sfrag-create-cse-mapping to compute INSN's fragment list.
d1063 1
a1063 1
; Subroutine of sfrag-create-cse-mapping to find the fragment number of the
d1081 1
a1081 1
(define (sfrag-create-cse-mapping insn-list)
d1206 1
a1206 1
	(let ((frag-data (sfrag-create-cse-mapping /sim-sfrag-insn-list)))
@


1.5
log
@	Clean up cpu file parsing, pass context consistently instead of the
	old "errtxt" argument.
	NOTE: ACU == "All Callers Updated".
	* attr.scm (-parse-simple-attribute): Renamed from
	parse-simple-attribute, ACU.
	(-attr-parse): Change errtxt argument to context, ACU.
	(-attr-read): Ditto.
	(atlist-parse): Ditto.  Put context arg first.
	(attr-parse): Use parse-error instead of context-error.
	* enum.scm (parse-enum-vals): Change errtxt argument to context, ACU.
	(-enum-parse-prefix, -enum-parse, -enum-read): Ditto.
	* hardware.scm (-keyword-parse): Renamed from keyword-parse.
	`context' arg is now a <context> object.  ACU.
	(-keyword-read): `context' arg is now a <context> object.  ACU.
	(-hw-parse-indices): Change errtxt argument to context, ACU.
	(-hw-parse-values, -hw-parse-handlers): Ditto.
	(-hw-parse-getter, -hw-parse-setter, -hw-parse, -hw-read): Ditto.
	(-hw-validate-layout, -hw-create-getter-from-layout,
	-hw-create-setter-from-layout): Ditto.
	(<hw-register>:parse!, <hw-pc>:parse!): Ditto.
	(<hw-memory>:parse!, <hw-immediate>:parse!): Ditto.
	(<hw-address>:parse!): Ditto.
	* ifield.scm (-ifield-parse, ifield-read): Ditto.
	(-ifld-parse-follows, -ifld-parse-encode-decode): Ditto.
	(-ifld-parse-encode, -ifld-parse-decode): Ditto.
	(-multi-ifield-parse, -multi-ifield-read): Ditto.
	* insn.scm (-insn-parse, -insn-read): Ditto.
	(parse-syntax): Ditto.  Put context arg first.
	(-parse-insn-format-symbol): Change errtxt argument to context, ACU.
	(-parse-insn-format-ifield-spec, -parse-insn-format-list): Ditto.
	(-parse-insn-format): Ditto.
	* mach.scm (-arch-parse-alignment, -arch-parse-machs): Ditto.
	(-arch-parse-isas): Ditto.
	(-isa-read): Add context arg, ACU.
	(-cpu-parse, -cpu-read, -mach-read): Ditto.
	* minsn.scm (-minsn-parse-expansion): Change errtxt argument to
	context, ACU.
	(-minsn-parse, -minsn-read, -minsn-compute-iflds): Ditto.
	(minsn-make-alias): Ditto.
	* mode.scm (-mode-parse): Ditto.
	(parse-mode-name): Ditto.  Put context arg first.
	* model.scm (-prefetch-parse, -retire-parse, -pipeline-parse): Change
	errtxt argument to context, ACU.
	(-unit-parse, -model-parse, -model-read): Ditto.
	* operand.scm (-operand-parse-getter): Use parse-error instead of
	context-error.
	(-operand-parse-setter): Ditto.
	(-operand-parse): Change errtxt argument to context, ACU.
	(-operand-read, -derived-operand-parse, -derived-operand-read): Ditto.
	(-anyof-operand-parse, -anyof-operand-read): Ditto.
	* read.scm (reader-error): Delete.  Use parse-error instead.
	(parse-error): Change errtxt argument to context, ACU.  Split args
	argument into expr and maybe-help-text.
	(-reader-process-expanded-1!): Reorganize.
	* rtl.scm (-subr-read): Change errtxt argument to context, ACU.
	* types.scm (parse-type): Ditto.
	* utils-cgen.scm (single-location->simple-string): New function.
	(<context>): Replace members file,lineno with location.
	(make-prefix-context): Renamed from context-make-prefix, ACU.
	(make-current-context): New function.
	(context-append, context-append-name): New functions.
	(context-make-reader): Delete.
	(parse-name): Change errtxt argument to context, ACU.
	Put context arg first.
	(parse-comment): Ditto.
	(parse-number): Change errtxt argument to context, ACU.
	(arg-list-validate-name, arg-list-check-no-args,
	arg-list-symbol-arg): Ditto.

	* read.scm (-cmd-if): Don't assume test is a list.

	* html.scm (get-insn-properties): Delete errtxt, unused.
@
text
@d59 1
a59 1
(define -stmt-stats? #f)
d61 1
a61 1
; Collection of computed stats.  Only set if -stmt-stats? = #t.
d63 1
a63 1
(define -stmt-stats #f)
d65 1
a65 1
; Collection of computed statement data.  Only set if -stmt-stats? = #t.
d67 1
a67 1
(define -stmt-stats-data #f)
d72 1
a72 1
(define (-stmt-data-make hash-size)
d78 4
a81 4
(define (-stmt-data-table data) (cdr data))
(define (-stmt-data-next-num data) (car data))
(define (-stmt-data-set-next-num! data newval) (set-car! data newval))
(define (-stmt-data-hash-size data) (vector-length (cdr data)))
d131 1
a131 1
(define (-stmt-make expr locals num speed-cost size-cost)
d137 1
a137 1
(define (-stmt-add-user! stmt user-num user-obj)
d146 2
a147 2
(define (-frag-lookup-stmt data chain-num stmt)
  (let ((table (-stmt-data-table data)))
d161 1
a161 1
; Global 'cus -frag-hash-compute! is defined globally so we can use
d164 1
a164 1
(define -frag-hash-value-tmp 0)
d166 1
a166 1
(define (-frag-hash-string str)
d173 1
a173 1
(define (-frag-hash-compute! rtx-obj expr mode parent-expr op-pos tstate appstuff)
d177 1
a177 1
       (set! h (-frag-hash-string (symbol->string (rtx-operand-name expr)))))
d179 1
a179 1
       (set! h (-frag-hash-string (symbol->string (rtx-local-name expr)))))
d184 1
a184 1
    (set! -frag-hash-value-tmp
d186 1
a186 1
	  (modulo (+ (* -frag-hash-value-tmp 3) h op-pos)
d193 4
a196 4
(define (-frag-hash-stmt stmt locals size)
  (set! -frag-hash-value-tmp 0)
  (rtx-traverse-with-locals #f #f stmt -frag-hash-compute! locals #f) ; FIXME: (/fastcall-make -frag-hash-compute!))
  (modulo -frag-hash-value-tmp size)
d202 1
a202 1
; Global 'cus -frag-cost-compute! is defined globally so we can use
d205 2
a206 2
(define -frag-speed-cost-tmp 0)
(define -frag-size-cost-tmp 0)
d208 1
a208 1
(define (-frag-cost-compute! rtx-obj expr mode parent-expr op-pos tstate appstuff)
d228 2
a229 2
    (set! -frag-speed-cost-tmp (+ -frag-speed-cost-tmp speed))
    (set! -frag-size-cost-tmp (+ -frag-size-cost-tmp size)))
d235 5
a239 5
(define (-frag-stmt-cost stmt locals)
  (set! -frag-speed-cost-tmp 0)
  (set! -frag-size-cost-tmp 0)
  (rtx-traverse-with-locals #f #f stmt -frag-cost-compute! locals #f) ; FIXME: (/fastcall-make -frag-cost-compute!))
  (cons -frag-speed-cost-tmp -frag-size-cost-tmp)
d244 1
a244 1
; {SPEED,SIZE}-COST are passed through to -stmt-make.
d247 3
a249 3
(define (-frag-add-stmt! data chain-num stmt locals speed-cost size-cost)
  (let ((stmt (-stmt-make stmt locals (-stmt-data-next-num data) speed-cost size-cost))
	(table (-stmt-data-table data)))
d251 1
a251 1
    (-stmt-data-set-next-num! data (+ 1 (-stmt-data-next-num data)))
d260 1
a260 1
(define (-frag-expr-locals expr)
d270 1
a270 1
(define (-frag-expr-stmts expr)
d284 1
a284 1
(define (-frag-analyze-expr-stmt! locals stmt stmt-data usage-table expr-num owner)
d287 2
a288 2
	  (-frag-hash-stmt stmt locals (-stmt-data-hash-size stmt-data)))
	 (stmt-obj (-frag-lookup-stmt stmt-data chain-num stmt)))
d293 1
a293 1
	(let* ((costs (-frag-stmt-cost stmt locals))
d296 1
a296 1
	  (set! stmt-obj (-frag-add-stmt! stmt-data chain-num stmt locals
d301 1
a301 1
    (-stmt-add-user! stmt-obj expr-num owner)
d318 1
a318 1
(define (-frag-analyze-expr! expr owner stmt-data usage-table usage-index)
d320 2
a321 2
  (let ((locals (-frag-expr-locals expr))
	(stmt-list (-frag-expr-stmts expr)))
d323 1
a323 1
		(-frag-analyze-expr-stmt! locals stmt stmt-data
d341 1
a341 1
(define (-frag-compute-statements exprs owners)
d352 1
a352 1
	  (stmt-data (-stmt-data-make hash-size))
d361 1
a361 1
	      (-frag-analyze-expr! expr owner stmt-data usage-table exprnum)
d365 3
a367 3
      (let ((stmt-hash-table (-stmt-data-table stmt-data))
	    (end (vector-length (-stmt-data-table stmt-data)))
	    (stmt-table (make-vector (-stmt-data-next-num stmt-data) #f)))
d377 1
a377 1
	(if -stmt-stats?
d380 2
a381 2
	      (set! -stmt-stats-data stmt-data)
	      (set! -stmt-stats
d386 1
a386 1
		      (vector-set! -stmt-stats i
d414 1
a414 1
		; -frag-pick-best.
d451 1
a451 1
(define (-frag-sort a b)
d461 1
a461 1
	 (-frag-sort (cdr a) (cdr b))))
d467 1
a467 1
(define (-frag-list-match? l1 l2 len)
d473 1
a473 1
	 (-frag-list-match? (cdr l1) (cdr l2) (- len 1)))
d480 1
a480 1
(define (-frag-find-matching expr-table indices stmt-list len)
d484 1
a484 1
	  ((-frag-list-match? stmt-list
d496 1
a496 1
(define (-frag-merge-profitable? stmt-table stmt-list num-exprs)
d500 2
a501 2
	   ;(>= (-frag-list-speed-cost stmt-table stmt-list) 10)
	   (>= (-frag-list-size-cost stmt-table stmt-list) 4)))
d510 1
a510 1
(define (-frag-list-speed-cost stmt-table stmt-list)
d517 1
a517 1
(define (-frag-list-size-cost stmt-table stmt-list)
d542 1
a542 1
(define (-frag-longest-desired stmt-table stmt-usage-table indices)
d549 1
a549 1
      (let ((num-exprs (-frag-find-matching stmt-usage-table (cdr indices)
d557 1
a557 1
	      (if (-frag-merge-profitable? stmt-table matching-stmt-list
d575 1
a575 1
(define (-frag-split-by-sbuf user-list)
d623 1
a623 1
(define (-frag-compute-desired-frags stmt-table stmt-usage-table owner-table kind)
d633 1
a633 1
	 (sorted-indices (sort-grade stmt-usage-list -frag-sort))
d645 1
a645 1
	  (let ((longest (-frag-longest-desired stmt-table stmt-usage-table indices)))
d658 1
a658 1
		       (sfmt-users (-frag-split-by-sbuf
d737 1
a737 1
(define (-frag-pick-best stmt-table stmt-usage-table owner-table)
d757 1
a757 1
	  (-frag-compute-desired-frags stmt-table stmt-usage-table owner-table
d778 1
a778 1
	      (-frag-compute-desired-frags
d888 1
a888 1
(define (-frag-compute-locals! expr-list)
d898 1
a898 1
		(let ((locals (-frag-expr-locals expr)))
d926 1
a926 1
; - statement table (vector of all statements, made with -stmt-make)
d935 1
a935 1
(define (-sem-find-common-frags-1 exprs owners)
d941 3
a943 3
  ; -frag-compute-locals!
  ; -frag-compute-statements
  ; -frag-pick-best
d948 1
a948 1
	(locals (-frag-compute-locals! exprs)))
d951 1
a951 1
    (let ((stmt-usage (-frag-compute-statements exprs owners)))
d958 1
a958 1
	       (-frag-pick-best stmt-table stmt-usage-table owners)))
d970 1
a970 1
; Cover proc of -sem-find-common-frags-1.
d974 1
a974 1
  (-sem-find-common-frags-1
d998 1
a998 1
(define (-sfrag-compute-frag-list! insn frag-usage frag-table num-headers num-trailers x-header-relnum x-trailer-relnum)
d1049 1
a1049 1
(define (-frag-lookup-virtual frag-list name)
d1127 2
a1128 2
		(x-header-relnum (-frag-lookup-virtual header-list 'x-header))
		(x-trailer-relnum (-frag-lookup-virtual trailer-list 'x-trailer))
d1135 1
a1135 1
			  (-sfrag-compute-frag-list! insn frag-usage
d1150 2
a1151 2
(define -sim-sfrag-init? #f)
(define (sim-sfrag-init?) -sim-sfrag-init?)
d1155 4
a1158 4
(define -sim-sfrag-insn-list #f)
(define -sim-sfrag-frag-table #f)
(define -sim-sfrag-usage-table #f)
(define -sim-sfrag-locals-list #f)
d1161 2
a1162 2
  (assert -sim-sfrag-init?)
  -sim-sfrag-insn-list
d1165 2
a1166 2
  (assert -sim-sfrag-init?)
  -sim-sfrag-frag-table
d1169 2
a1170 2
  (assert -sim-sfrag-init?)
  -sim-sfrag-usage-table
d1173 2
a1174 2
  (assert -sim-sfrag-init?)
  -sim-sfrag-locals-list
d1178 5
a1182 5
  (set! -sim-sfrag-init? #f)
  (set! -sim-sfrag-insn-list #f)
  (set! -sim-sfrag-frag-table #f)
  (set! -sim-sfrag-usage-table #f)
  (set! -sim-sfrag-locals-list #f)
d1186 1
a1186 1
  (if (not -sim-sfrag-init?)
d1188 6
a1193 6
	(set! -sim-sfrag-insn-list (non-multi-insns (non-alias-insns (current-insn-list))))
	(let ((frag-data (sfrag-create-cse-mapping -sim-sfrag-insn-list)))
	  (set! -sim-sfrag-frag-table (vector-ref frag-data 0))
	  (set! -sim-sfrag-usage-table (vector-ref frag-data 1))
	  (set! -sim-sfrag-locals-list (vector-ref frag-data 2)))
	(set! -sim-sfrag-init? #t)))
d1200 1
a1200 1
(define (-frag-small-test-data)
d1208 1
a1208 1
(define (-frag-test-data)
d1224 1
a1224 1
  (let* ((test-data (-frag-test-data))
@


1.4
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d1087 2
a1088 1
			(atlist-parse '(VIRTUAL) "" "semantic frag computation")
d1105 2
a1106 1
			(atlist-parse '(VIRTUAL) "" "semantic frag computation")
@


1.3
log
@	* rtl-xform.scm (rtx-simplify-insn): New function.
	* html.scm (gen-insn-docs): Call it.
	* sem-frags.scm (sem-find-common-frags, -frag-test-data): Ditto.
	* iformat.scm (ifmt-analyze): Minor simplification.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
@


1.2
log
@	* mach.scm (current-*-add!): Disallow redefinition.  Make result
	"unspecified".
	* insn.scm (insn-builtin!): Don't define relaxable here, now defined in
	operand.scm.
	* operand.scm (operand-builtin!): Define RELAXABLE for insns too.
	* cpu/m32r.cpu (disp8,disp24): RELAX renamed to RELAXABLE.

	* gen-all-doc: Split arm and frv docs up a bit.

	* cpu/arm.cpu: Add IDOC attribute.
	* cpu/frv.cpu: Ditto.
	* cpu/i960.cpu: Ditto.
	* cpu/openrisc.cpu: Ditto.
	* cpu/xstormy16.cpu: Ditto.
	* cpu/m32r.cpu: Ditto.
	(all insns): Explicitly specify IDOC attribute.

	* Makefile.am (MACH,ISAS,INSN_FILE_NAME): New vars.
	(desc,opcodes,sim-arch,sim-cpu,gas-test,sim-test): Use MACH,ISAS.
	(html): Use MACH,ISAS,INSN_FILE_NAME.  Generate insn.html separately.
	* Makefile.in: Regenerate.
	* attr.scm (<integer-attribute>:parse-value-def): Implement.
	(-attr-read): Defer computing default value until we know the type.
	(attr-has-attr?): Delete, move contents to <attr-list>:has-attr?.
	(<attr-list>:attr-present?): New method.
	(atlist-attr-present?,obj-attr-present?): New fns.
	(obj-has-attr-value?,obj-has-attr-value-no-default?): New fns.
	(attr-builtin!): New insn attr IDOC.
	* cgen-doc.scm (doc-arguments): New args -I,-N.
	* enum.scm (parse-enum-vals): New arg errtxt, all callers updated.
	Support comment as fourth element of enum value.
	(enum-val-name,enum-val-value,enum-val-attrs,enum-val-comment): New fns.
	* html.scm (gen-html-header): New arg kind, all callers updated.
	(gen-table-of-contents): New arg insn-file, all callers updated.
	(gen-list-entry,gen-doc-header): New fn.
	(get-operands): Delete.
	(gen-iformat-table): Rewrite.
	(gen-insn-doc-1): Print constant-folded and trimmed semantics.
	(gen-insn-doc-list): New args name, comment, insns.  All callers updated.
	(get-insn-properties,guess-insn-idoc-attr!): New fn.
	(insn-sets-pc?,insn-refs-mem?,insn-uses-fpu?): New fns.
	(get-insns-for-category,gen-categories-insn-lists): New fns.
	(gen-insn-docs): Simplify each insn's semantics first.
	Print insn tables sorted by IDOC categories.
	(*insn-html-file-name*): New global.
	(cgen-insn.html): New fn.
	(cgen-all): Update.
	* insn.scm (<insn>): Create a setter for the `tmp' member.
	* semantics.scm (insn-build-known-values): Renamed from
	-build-known-values.  All callers updated.

	* rtl.scm: Move traveral/evaluation support to ...
	* rtl-traverse.scm: New file.
	* read.scm: Maybe-load rtl-traverse.scm.

	* rtl.scm (-rtx-valid-types): Add SETRTX.

	* rtx-funcs.scm (nop,parallel): Fix mode.

	* utils.scm (eqv-lookup-index): New fn.
	(assq-lookup-index): Renamed from lookup-index.  All callers updated.

	* dev.scm (load-doc): Set APPLICATION.
@
text
@d978 1
a978 3
	    ; Must pass canonicalized and macro-expanded rtl.
	    (rtx-simplify #f insn (insn-semantics insn)
			  (insn-build-known-values insn)))
d1209 1
a1209 3
	  ; Must pass canonicalized and macro-expanded rtl.
	  (rtx-simplify #f insn (insn-semantics insn)
			(insn-build-known-values insn)))
@


1.2.6.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2009 Red Hat, Inc.
@


1.1
log
@Initial revision
@
text
@d980 1
a980 1
			  (-build-known-values insn)))
d1213 1
a1213 1
			(-build-known-values insn)))
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
