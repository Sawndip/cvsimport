head	1.20;
access;
symbols
	sid-snapshot-20180601:1.20
	cgen-snapshot-20180601:1.20
	sid-snapshot-20180501:1.20
	cgen-snapshot-20180501:1.20
	sid-snapshot-20180401:1.20
	cgen-snapshot-20180401:1.20
	sid-snapshot-20180301:1.20
	cgen-snapshot-20180301:1.20
	sid-snapshot-20180201:1.20
	cgen-snapshot-20180201:1.20
	sid-snapshot-20180101:1.20
	cgen-snapshot-20180101:1.20
	sid-snapshot-20171201:1.20
	cgen-snapshot-20171201:1.20
	sid-snapshot-20171101:1.20
	cgen-snapshot-20171101:1.20
	sid-snapshot-20171001:1.20
	cgen-snapshot-20171001:1.20
	sid-snapshot-20170901:1.20
	cgen-snapshot-20170901:1.20
	sid-snapshot-20170801:1.20
	cgen-snapshot-20170801:1.20
	sid-snapshot-20170701:1.20
	cgen-snapshot-20170701:1.20
	sid-snapshot-20170601:1.20
	cgen-snapshot-20170601:1.20
	sid-snapshot-20170501:1.20
	cgen-snapshot-20170501:1.20
	sid-snapshot-20170401:1.20
	cgen-snapshot-20170401:1.20
	sid-snapshot-20170301:1.20
	cgen-snapshot-20170301:1.20
	sid-snapshot-20170201:1.20
	cgen-snapshot-20170201:1.20
	sid-snapshot-20170101:1.20
	cgen-snapshot-20170101:1.20
	sid-snapshot-20161201:1.20
	cgen-snapshot-20161201:1.20
	sid-snapshot-20161101:1.20
	cgen-snapshot-20161101:1.20
	sid-snapshot-20160901:1.20
	cgen-snapshot-20160901:1.20
	sid-snapshot-20160801:1.20
	cgen-snapshot-20160801:1.20
	sid-snapshot-20160701:1.20
	cgen-snapshot-20160701:1.20
	sid-snapshot-20160601:1.20
	cgen-snapshot-20160601:1.20
	sid-snapshot-20160501:1.19
	cgen-snapshot-20160501:1.19
	sid-snapshot-20160401:1.19
	cgen-snapshot-20160401:1.19
	sid-snapshot-20160301:1.19
	cgen-snapshot-20160301:1.19
	sid-snapshot-20160201:1.19
	cgen-snapshot-20160201:1.19
	sid-snapshot-20160101:1.19
	cgen-snapshot-20160101:1.19
	sid-snapshot-20151201:1.19
	cgen-snapshot-20151201:1.19
	sid-snapshot-20151101:1.19
	cgen-snapshot-20151101:1.19
	sid-snapshot-20151001:1.19
	cgen-snapshot-20151001:1.19
	sid-snapshot-20150901:1.19
	cgen-snapshot-20150901:1.19
	sid-snapshot-20150801:1.19
	cgen-snapshot-20150801:1.19
	sid-snapshot-20150701:1.19
	cgen-snapshot-20150701:1.19
	sid-snapshot-20150601:1.19
	cgen-snapshot-20150601:1.19
	sid-snapshot-20150501:1.19
	cgen-snapshot-20150501:1.19
	sid-snapshot-20150401:1.19
	cgen-snapshot-20150401:1.19
	sid-snapshot-20150301:1.19
	cgen-snapshot-20150301:1.19
	sid-snapshot-20150201:1.19
	cgen-snapshot-20150201:1.19
	sid-snapshot-20150101:1.19
	cgen-snapshot-20150101:1.19
	sid-snapshot-20141201:1.19
	cgen-snapshot-20141201:1.19
	sid-snapshot-20141101:1.19
	cgen-snapshot-20141101:1.19
	sid-snapshot-20141001:1.19
	cgen-snapshot-20141001:1.19
	sid-snapshot-20140901:1.19
	cgen-snapshot-20140901:1.19
	sid-snapshot-20140801:1.19
	cgen-snapshot-20140801:1.19
	sid-snapshot-20140701:1.19
	cgen-snapshot-20140701:1.19
	sid-snapshot-20140601:1.19
	cgen-snapshot-20140601:1.19
	sid-snapshot-20140501:1.19
	cgen-snapshot-20140501:1.19
	sid-snapshot-20140401:1.19
	cgen-snapshot-20140401:1.19
	sid-snapshot-20140301:1.19
	cgen-snapshot-20140301:1.19
	sid-snapshot-20140201:1.19
	cgen-snapshot-20140201:1.19
	sid-snapshot-20140101:1.19
	cgen-snapshot-20140101:1.19
	sid-snapshot-20131201:1.19
	cgen-snapshot-20131201:1.19
	sid-snapshot-20131101:1.19
	cgen-snapshot-20131101:1.19
	sid-snapshot-20131001:1.19
	cgen-snapshot-20131001:1.19
	sid-snapshot-20130901:1.19
	cgen-snapshot-20130901:1.19
	sid-snapshot-20130801:1.19
	cgen-snapshot-20130801:1.19
	sid-snapshot-20130701:1.19
	cgen-snapshot-20130701:1.19
	sid-snapshot-20130601:1.19
	cgen-snapshot-20130601:1.19
	sid-snapshot-20130501:1.19
	cgen-snapshot-20130501:1.19
	sid-snapshot-20130401:1.19
	cgen-snapshot-20130401:1.19
	sid-snapshot-20130301:1.19
	cgen-snapshot-20130301:1.19
	sid-snapshot-20130201:1.19
	cgen-snapshot-20130201:1.19
	sid-snapshot-20130101:1.19
	cgen-snapshot-20130101:1.19
	sid-snapshot-20121201:1.19
	cgen-snapshot-20121201:1.19
	sid-snapshot-20121101:1.19
	cgen-snapshot-20121101:1.19
	sid-snapshot-20121001:1.19
	cgen-snapshot-20121001:1.19
	sid-snapshot-20120901:1.19
	cgen-snapshot-20120901:1.19
	sid-snapshot-20120801:1.19
	cgen-snapshot-20120801:1.19
	sid-snapshot-20120701:1.19
	cgen-snapshot-20120701:1.19
	sid-snapshot-20120601:1.19
	cgen-snapshot-20120601:1.19
	sid-snapshot-20120501:1.19
	cgen-snapshot-20120501:1.19
	sid-snapshot-20120401:1.19
	cgen-snapshot-20120401:1.19
	sid-snapshot-20120301:1.19
	cgen-snapshot-20120301:1.19
	sid-snapshot-20120201:1.19
	cgen-snapshot-20120201:1.19
	sid-snapshot-20120101:1.19
	cgen-snapshot-20120101:1.19
	sid-snapshot-20111201:1.19
	cgen-snapshot-20111201:1.19
	sid-snapshot-20111101:1.19
	cgen-snapshot-20111101:1.19
	sid-snapshot-20111001:1.19
	cgen-snapshot-20111001:1.19
	sid-snapshot-20110901:1.19
	cgen-snapshot-20110901:1.19
	sid-snapshot-20110801:1.19
	cgen-snapshot-20110801:1.19
	sid-snapshot-20110701:1.19
	cgen-snapshot-20110701:1.19
	sid-snapshot-20110601:1.19
	cgen-snapshot-20110601:1.19
	sid-snapshot-20110501:1.19
	cgen-snapshot-20110501:1.19
	sid-snapshot-20110401:1.19
	cgen-snapshot-20110401:1.19
	sid-snapshot-20110301:1.19
	cgen-snapshot-20110301:1.19
	sid-snapshot-20110201:1.19
	cgen-snapshot-20110201:1.19
	sid-snapshot-20110101:1.19
	cgen-snapshot-20110101:1.19
	sid-snapshot-20101201:1.19
	cgen-snapshot-20101201:1.19
	sid-snapshot-20101101:1.19
	cgen-snapshot-20101101:1.19
	sid-snapshot-20101001:1.19
	cgen-snapshot-20101001:1.19
	sid-snapshot-20100901:1.19
	cgen-snapshot-20100901:1.19
	sid-snapshot-20100801:1.19
	cgen-snapshot-20100801:1.19
	sid-snapshot-20100701:1.19
	cgen-snapshot-20100701:1.19
	sid-snapshot-20100601:1.19
	cgen-snapshot-20100601:1.19
	sid-snapshot-20100501:1.19
	cgen-snapshot-20100501:1.19
	sid-snapshot-20100401:1.19
	cgen-snapshot-20100401:1.19
	sid-snapshot-20100301:1.19
	cgen-snapshot-20100301:1.19
	sid-snapshot-20100201:1.19
	cgen-snapshot-20100201:1.19
	sid-snapshot-20100101:1.19
	cgen-snapshot-20100101:1.19
	sid-snapshot-20091201:1.19
	cgen-snapshot-20091201:1.19
	sid-snapshot-20091101:1.16
	cgen-snapshot-20091101:1.16
	sid-snapshot-20091001:1.14
	cgen-snapshot-20091001:1.14
	arc-sim-20090309:1.9.4.1
	sid-snapshot-20090901:1.11
	cgen-snapshot-20090901:1.11
	sid-snapshot-20090801:1.11
	cgen-snapshot-20090801:1.11
	sid-snapshot-20090701:1.11
	cgen-snapshot-20090701:1.11
	dje-cgen-play1-branch:1.11.0.2
	dje-cgen-play1-branchpoint:1.11
	cgen-1_1-branch:1.10.0.2
	cgen-1_1-branchpoint:1.10
	sid-snapshot-20090601:1.9
	cgen-snapshot-20090601:1.9
	sid-snapshot-20090501:1.9
	cgen-snapshot-20090501:1.9
	sid-snapshot-20090401:1.9
	cgen-snapshot-20090401:1.9
	arc-insight_6_8-branch:1.9.0.4
	arc-insight_6_8-branchpoint:1.9
	sid-snapshot-20090301:1.9
	cgen-snapshot-20090301:1.9
	sid-snapshot-20090201:1.9
	cgen-snapshot-20090201:1.9
	sid-snapshot-20090101:1.9
	cgen-snapshot-20090101:1.9
	sid-snapshot-20081201:1.9
	cgen-snapshot-20081201:1.9
	sid-snapshot-20081101:1.9
	cgen-snapshot-20081101:1.9
	sid-snapshot-20081001:1.9
	cgen-snapshot-20081001:1.9
	sid-snapshot-20080901:1.9
	cgen-snapshot-20080901:1.9
	sid-snapshot-20080801:1.9
	cgen-snapshot-20080801:1.9
	sid-snapshot-20080701:1.9
	cgen-snapshot-20080701:1.9
	sid-snapshot-20080601:1.9
	cgen-snapshot-20080601:1.9
	sid-snapshot-20080501:1.9
	cgen-snapshot-20080501:1.9
	sid-snapshot-20080403:1.9
	sid-snapshot-20080401:1.9
	cgen-snapshot-20080401:1.9
	sid-snapshot-20080301:1.9
	cgen-snapshot-20080301:1.9
	sid-snapshot-20080201:1.9
	cgen-snapshot-20080201:1.9
	sid-snapshot-20080101:1.9
	cgen-snapshot-20080101:1.9
	sid-snapshot-20071201:1.9
	cgen-snapshot-20071201:1.9
	sid-snapshot-20071101:1.9
	cgen-snapshot-20071101:1.9
	sid-snapshot-20071001:1.9
	cgen-snapshot-20071001:1.9
	msnyder-fork-checkpoint-branch:1.9.0.2
	msnyder-fork-checkpoint-branchpoint:1.9
	sid-20020905-branchpoint:1.7
	sid-20020905-branch:1.7.0.2
	cagney_regbuf-20020515-branch:1.6.0.4
	cagney_regbuf-20020515-branchpoint:1.6
	cygnus_cvs_20020108_pre:1.6
	cgen-1-1-branch:1.6.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.20
date	2016.05.09.21.50.25;	author vapier;	state Exp;
branches;
next	1.19;

1.19
date	2009.11.23.04.18.05;	author devans;	state Exp;
branches;
next	1.18;

1.18
date	2009.11.23.00.59.57;	author devans;	state Exp;
branches;
next	1.17;

1.17
date	2009.11.03.16.24.02;	author devans;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.26.00.56.34;	author devans;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.24.18.03.43;	author devans;	state Exp;
branches;
next	1.14;

1.14
date	2009.09.27.18.31.33;	author devans;	state Exp;
branches;
next	1.13;

1.13
date	2009.09.23.22.30.19;	author devans;	state Exp;
branches;
next	1.12;

1.12
date	2009.09.07.22.17.34;	author devans;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.20.21.34.28;	author devans;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2003.07.16.05.35.48;	author devans;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2003.05.15.07.25.02;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.19.22.43.23;	author hp;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.06.12.11.09;	author bje;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2000.12.04.18.34.45;	author fche;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.01.04.45.20;	author bje;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.24.04.25.32;	author bje;	state Exp;
branches;
next	1.2;

1.2
date	2000.11.20.19.03.33;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.10.2.1
date	2009.06.24.14.57.46;	author devans;	state Exp;
branches;
next	;

1.9.4.1
date	2009.03.09.20.36.04;	author amylaar;	state Exp;
branches;
next	;

1.6.4.1
date	2002.06.21.16.18.47;	author cagney;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.20
log
@cgen: sim: Updates to sim files to match gdb types

The types like MACH and MODEL have changes to SIM_MACH and SIM_MODEL
make updates to match these changes.  This way people dont have to
manually update the generated files in GDB.
@
text
@; CPU family related simulator generator, excluding decoding and model support.
; Copyright (C) 2000, 2001, 2009 Red Hat, Inc.
; This file is part of CGEN.

; Notes:
; - Add support to generate copies of semantic code and perform constant
;   folding based on selected mach.  This would collapse out untaken branches
;   of tests on (current-mach).

; Utilities of cgen-cpu.h.

; Print various parameters of the cpu family.
; A "cpu family" here is a collection of variants of a particular architecture
; that share sufficient commonality that they can be handled together.

(define (/gen-cpu-defines)
  (string-append
   "\
/* Maximum number of instructions that are fetched at a time.
   This is for LIW type instructions sets (e.g. m32r).  */
#define MAX_LIW_INSNS " (number->string (state-liw-insns))
   "\n\

/* Maximum number of instructions that can be executed in parallel.  */
#define MAX_PARALLEL_INSNS " (number->string (state-parallel-insns))
   "\n\

/* The size of an \"int\" needed to hold an instruction word.
   This is usually 32 bits, but some architectures needs 64 bits.  */
typedef "
   (if (adata-large-insn-word? CURRENT-ARCH)
       "CGEN_INSN_LGUINT"
       "CGEN_INSN_INT")
   " CGEN_INSN_WORD;\n\n"
;   (gen-enum-decl '@@cpu@@_virtual
;		  "@@cpu@@ virtual insns"
;		  "@@ARCH@@_INSN_" ; not @@CPU@@ to match CGEN_INSN_TYPE in opc.h
;		  '((x-invalid 0)
;		    (x-before -1) (x-after -2)
;		    (x-begin -3) (x-chain -4) (x-cti-chain -5)))
   )
)

; Return a boolean indicating if hardware element HW needs storage allocated
; for it in the SIM_CPU struct.

(define (hw-need-storage? hw)
  (and (register? hw) (not (obj-has-attr? hw 'VIRTUAL)))
)

; Subroutine of /gen-hardware-types to generate the struct containing
; hardware elements of one isa.

(define (/gen-hardware-struct hw-list)
  (if (null? hw-list)
      ; If struct is empty, leave it out to simplify generated code.
      ""
      (string-list-map (lambda (hw)
			 (string-list
			  (gen-defn hw)
			  (gen-obj-sanitize hw
					    (string-list
					     (send hw 'gen-get-macro)
					     (send hw 'gen-set-macro)))))
		       (find hw-need-storage? hw-list)))
  )

; Return C type declarations of all of the hardware elements.
; The name of the type is prepended with the cpu family name.

(define (/gen-hardware-types)
  (string-list
   "/* CPU state information.  */\n"
   "typedef struct {\n"
   "  /* Hardware elements.  */\n"
   "  struct {\n"
   (/gen-hardware-struct 
    (find (lambda (hw)
	    (or (not (with-multiple-isa?))
		(>= (count-common
		     (current-keep-isa-name-list)
		     (obj-attr-value hw 'ISA))
		    1)))
	  (current-hw-list))
    )
   "  } hardware;\n"
   "#define CPU_CGEN_HW(cpu) (& (cpu)->cpu_data.hardware)\n"
   ;"  /* CPU profiling state information.  */\n"
   ;"  struct {\n"
   ;(string-list-map (lambda (hw) (send hw 'gen-profile-decl))
   ;		    (find hw-profilable? (current-hw-list)))
   ;"  } profile;\n"
   ;"#define CPU_CGEN_PROFILE(cpu) (& (cpu)->cpu_data.profile)\n"
   "} @@CPU@@_CPU_DATA;\n\n"
   ; If there are any virtual regs, output get/set macros for them.
   (let ((virtual-regs (find (lambda (hw)
			       (and (register? hw)
				    (obj-has-attr? hw 'VIRTUAL)))
			     (current-hw-list)))
	 (orig-with-parallel? (with-parallel?))
	 (result ""))
     (set-with-parallel?! #f)
     (if (not (null? virtual-regs))
	 (set! result
	       (string-list
		"/* Virtual regs.  */\n\n"
		(string-list-map (lambda (hw)
				   (logit 3 "Generating get/set for " (obj:name hw)
					  " ...\n")
				   (gen-obj-sanitize hw
						     (string-list
						      (send hw 'gen-get-macro)
						      (send hw 'gen-set-macro))))
				 virtual-regs)
		"\n"
		)))
     (set-with-parallel?! orig-with-parallel?)
     result)
   )
)

; Return the declaration of register access functions.

(define (/gen-cpu-reg-access-decls)
  (string-list
   "/* Cover fns for register access.  */\n"
   (string-list-map (lambda (hw)
		      (gen-reg-access-decl hw
					   "@@cpu@@"
					   (gen-type hw)
					   (hw-scalar? hw)))
		    (find register? (current-hw-list)))
   "\n"
   "/* These must be hand-written.  */\n"
   "extern CPUREG_FETCH_FN @@cpu@@_fetch_register;\n"
   "extern CPUREG_STORE_FN @@cpu@@_store_register;\n"
   "\n")
)

; Generate type of struct holding model state while executing.

(define (/gen-model-decls)
  (logit 2 "Generating model decls ...\n")
  (string-list
   (string-list-map
    (lambda (model)
      (string-list
       "typedef struct {\n"
       (if (null? (model:state model))
	   "  int empty;\n" ; ensure struct isn't empty so it compiles
	   (string-map (lambda (var)
			 (string-append "  "
					(mode:c-type (mode:lookup (cadr var)))
					" "
					(gen-c-symbol (car var))
					";\n"))
		       (model:state model)))
       "} MODEL_" (string-upcase (gen-sym model)) "_DATA;\n\n"
       ))
    (current-model-list))
   )
)

; Utility of /gen-extract-macros to generate a macro to define the local
; vars to contain extracted field values and the code to assign them
; for <iformat> IFMT.

(define (/gen-extract-ifmt-macro ifmt)
  (logit 2 "Processing format " (obj:name ifmt) " ...\n")
  (string-list
   (gen-define-ifmt-ifields ifmt "" #t #f)
   (gen-extract-ifmt-ifields ifmt "" #t #f)
   ; We don't need an extra blank line here as gen-extract-ifields adds one.
   )
)

; Generate macros to extract instruction fields.

(define (/gen-extract-macros)
  (logit 2 "Generating extraction macros ...\n")
  (string-list
   "\
/* Macros to simplify extraction, reading and semantic code.
   These define and assign the local vars that contain the insn's fields.  */
\n"
   (string-list-map /gen-extract-ifmt-macro (current-ifmt-list))
   )
)

; Utility of /gen-parallel-exec-type to generate the definition of one
; structure in PAREXEC.
; SFMT is an <sformat> object.

(define (/gen-parallel-exec-elm sfmt)
  (string-append
   "    struct { /* " (obj:comment sfmt) " */\n"
   (let ((sem-ops
	  ((if (with-parallel-write?) sfmt-out-ops sfmt-in-ops) sfmt)))
     (if (null? sem-ops)
	 "      int empty;\n" ; ensure struct isn't empty so it compiles
	 (string-map
	  (lambda (op)
	    (logit 2 "Processing operand " (obj:name op) " of format "
		   (obj:name sfmt) " ...\n")
	      (if (with-parallel-write?)
		  (let ((index-type (and (op-save-index? op)
					 (gen-index-type op sfmt))))
		    (string-append "      " (gen-type op)
				   " " (gen-sym op) ";\n"
				   (if index-type
				       (string-append "      " index-type 
						      " " (gen-sym op) "_idx;\n")
				       "")))
		  (string-append "      "
				 (gen-type op)
				 " "
				 (gen-sym op)
				 ";\n")))
	  sem-ops)))
   "    } " (gen-sym sfmt) ";\n"
   )
)

; Generate the definition of the structure that holds register values, etc.
; for use during parallel execution.  When instructions are executed parallelly
; either
; - their inputs are read before their outputs are written.  Thus we have to
; fetch the input values of several instructions before executing any of them.
; - or their outputs are queued here first and then written out after all insns
; have executed.
; The fetched/queued values are stored in an array of PAREXEC structs, one
; element per instruction.

(define (/gen-parallel-exec-type)
  (logit 2 "Generating PAREXEC type ...\n")
  (string-append
   (if (with-parallel-write?)
       "/* Queued output values of an instruction.  */\n"
       "/* Fetched input values of an instruction.  */\n")
   "\

struct parexec {
  union {\n"
   (string-map /gen-parallel-exec-elm (current-sfmt-list))
   "\
  } operands;
  /* For conditionally written operands, bitmask of which ones were.  */
  int written;
};\n\n"
   )
)

; Generate the TRACE_RECORD struct definition.
; This struct will hold all necessary data for doing tracing and profiling
; (e.g. register numbers).  The goal is to remove all tracing code from the
; semantic code.  Then the fast/full distinction needn't use conditionals to
; discard/include the tracing/profiling code.

(define (/gen-trace-record-type)
  (string-list
   "\
/* Collection of various things for the trace handler to use.  */

typedef struct trace_record {
  IADDR pc;
  /* FIXME:wip */
} TRACE_RECORD;
\n"
   )
)

; Utilities of cgen-cpu.c

; Get/set fns for every register.

(define (/gen-cpu-reg-access-defns)
  (string-list-map
   (lambda (hw)
     (let ((scalar? (hw-scalar? hw))
	   (name (obj:name hw))
	   (getter (hw-getter hw))
	   (setter (hw-setter hw)))
       (gen-reg-access-defn hw
			    "@@cpu@@"
			    (gen-type hw)
			    scalar?
			    (if getter
				(string-append
				 "  return GET_"
				 (string-upcase (gen-c-symbol name))
				 " ("
				 (if scalar? "" "regno")
				 ");\n")
				(string-append
				 "  return CPU ("
				 (gen-c-symbol name)
				 (if scalar? "" "[regno]")
				 ");\n"))
			    (if setter
				(string-append
				 "  SET_"
				 (string-upcase (gen-c-symbol name))
				 " ("
				 (if scalar? "" "regno, ")
				 "newval);\n")
				(string-append
				 "  CPU ("
				 (gen-c-symbol name)
				 (if scalar? "" "[regno]")
				 ") = newval;\n")))))
   (find (lambda (hw) (register? hw))
	 (current-hw-list)))
)

; Generate a function to record trace results in a trace record.

(define (/gen-cpu-record-results)
  (string-list
   "\
/* Record trace results for INSN.  */

void
@@cpu@@_record_trace_results (SIM_CPU *current_cpu, CGEN_INSN *insn,
			    int *indices, TRACE_RECORD *tr)
{\n"
   "}\n"
   )
)

; Utilities of cgen-read.c.
; Parallel-read support is not currently used by any port and this code
; has been left to bitrot.  Don't delete it just yet.

; Return C code to fetch and save all input operands to instructions with
; <sformat> SFMT.

(define (/gen-read-args sfmt)
  (string-map (lambda (op) (op:read op sfmt))
	      (sfmt-in-ops sfmt))
)

; Utility of /gen-read-switch to generate a switch case for <sformat> SFMT.

(define (/gen-read-case sfmt)
  (logit 2 "Processing read switch case for \"" (obj:name sfmt) "\" ...\n")
  (string-list
   "    CASE (read, READ_" (string-upcase (gen-sym sfmt)) ") : "
   "/* " (obj:comment sfmt) " */\n"
   "    {\n"
   (gen-define-field-macro (if (with-scache?) sfmt #f))
   (gen-define-parallel-operand-macro sfmt)
   (gen-define-ifields (sfmt-iflds sfmt) (sfmt-length sfmt) "      " #f)
   (gen-extract-ifields (sfmt-iflds sfmt) (sfmt-length sfmt) "      " #f)
   (/gen-read-args sfmt)
   (gen-undef-parallel-operand-macro sfmt)
   (gen-undef-field-macro sfmt)
   "    }\n"
   "    BREAK (read);\n\n"
   )
)

; Generate the guts of a C switch statement to read insn operands.
; The switch is based on instruction formats.

(define (/gen-read-switch)
  (logit 2 "Processing readers ...\n")
  (string-write-map /gen-read-case (current-sfmt-list))
)

; Utilities of cgen-write.c.

; This is the other way of implementing parallel execution support.
; Instead of fetching all the input operands first, write all the output
; operands and their addresses to holding variables, and then run a
; post-processing pass to update the cpu state.
;
; There are separate implementations for semantics as functions and semantics
; as one big switch.  For the function case we create a function that is a
; switch on each semantic format and loops writing each insn's results back.
; For the switch case we add cases to the switch to handle the write back,
; and it is up to the pbb compiler to include them in the generated "code".

; Return C code to fetch and save all output operands to instructions with
; <sformat> SFMT.

(define (/gen-write-args sfmt)
  (string-map (lambda (op) (op:write op sfmt))
	      (sfmt-out-ops sfmt))
)

; Utility of gen-write-switch to generate a switch case for <sformat> SFMT.
; If INSN is non-#f, it is the <insn> object of the insn in which case
; the case is named after the insn not the format.  This is done because
; current sem-switch support emits one handler per insn instead of per sfmt.

(define (/gen-write-case sfmt insn)
  (logit 2 "Processing write switch case for \"" (obj:name sfmt) "\" ...\n")
  (string-list
   (if insn
       (string-list /indent
		    "CASE (sem, INSN_WRITE_"
		    (string-upcase (gen-sym insn)) ") : ")
       (string-list /indent
		    "case @@CPU@@_"
		    (string-upcase (gen-sym sfmt)) " : "))
   "/* "
   (if insn
       (string-list (insn-syntax insn))
       (obj:comment sfmt))
   " */\n"
   /indent "  {\n"
   (if insn
       (string-list
	/indent
	"    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);\n"
	/indent
	"    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;\n")
       "")
   (gen-define-field-macro (if (with-scache?) sfmt #f))
   (gen-define-parallel-operand-macro sfmt)
   /indent
   "    int UNUSED written = abuf->written;\n"
   ;(gen-define-ifields (sfmt-iflds sfmt) (sfmt-length sfmt) "  " #f) - used by cgen-read.c
   ;(gen-extract-ifields (sfmt-iflds sfmt) (sfmt-length sfmt) "  " #f) - used by cgen-read.c
   (if insn
       (string-list /indent "    IADDR UNUSED pc = abuf->addr;\n")
       "")
   (if (and insn (insn-cti? insn))
       (string-list /indent
		    "    SEM_BRANCH_INIT\n") ; no trailing `;' on purpose
       "")
   (if insn
       (string-list /indent "    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);\n")
       "")
   "\n"
   (/indent-add 4)
   (/gen-write-args sfmt)
   (/indent-add -4)
   "\n"
   (if (and insn (insn-cti? insn))
       (string-list /indent "  SEM_BRANCH_FINI (vpc);\n")
       "")
   (gen-undef-parallel-operand-macro sfmt)
   (gen-undef-field-macro sfmt)
   /indent "  }\n"
   (if insn
       (string-list /indent "  NEXT (vpc);\n")
       (string-list /indent "  break;\n"))
   "\n"
   )
)

; Generate the guts of a C switch statement to write insn operands.
; The switch is based on instruction formats.
; ??? This will generate cases for formats that don't need it.
; E.g. on the m32r all 32 bit insns can't be executed in parallel.
; It's easier to generate the code anyway so we do.

(define (/gen-write-switch)
  (logit 2 "Processing writers ...\n")
  (string-write-map (lambda (sfmt)
		      (/gen-write-case sfmt #f))
		    (current-sfmt-list))
)

; Utilities of cgen-semantics.c.

; Return name of semantic fn for INSN.

(define (/gen-sem-fn-name insn)
  ;(string-append "sem_" (gen-sym insn))
  (gen-sym insn)
)

; Return semantic fn table entry for INSN.

(define (/gen-sem-fn-table-entry insn)
  (string-list
   "  { "
   "@@PREFIX@@_INSN_"
   (string-upcase (gen-sym insn))
   ", "
   "SEM_FN_NAME (@@prefix@@," (/gen-sem-fn-name insn) ")"
   " },\n"
   )
)

; Return C code to define a table of all semantic fns and a function to
; add the info to the insn descriptor table.

(define (/gen-semantic-fn-table)
  (string-write
   "\
/* Table of all semantic fns.  */

static const struct sem_fn_desc sem_fns[] = {\n"

   (lambda ()
     (string-write-map /gen-sem-fn-table-entry
		       (non-alias-insns (current-insn-list))))

   "\
  { 0, 0 }
};

/* Add the semantic fns to IDESC_TABLE.  */

void
SEM_FN_NAME (@@prefix@@,init_idesc_table) (SIM_CPU *current_cpu)
{
  IDESC *idesc_table = CPU_IDESC (current_cpu);
  const struct sem_fn_desc *sf;
  int mach_num = MACH_NUM (CPU_MACH (current_cpu));

  for (sf = &sem_fns[0]; sf->fn != 0; ++sf)
    {
      const CGEN_INSN *insn = idesc_table[sf->index].idata;
      int valid_p = (CGEN_INSN_VIRTUAL_P (insn)
		     || CGEN_INSN_MACH_HAS_P (insn, mach_num));
#if FAST_P
      if (valid_p)
	idesc_table[sf->index].sem_fast = sf->fn;
      else
	idesc_table[sf->index].sem_fast = SEM_FN_NAME (@@prefix@@,x_invalid);
#else
      if (valid_p)
	idesc_table[sf->index].sem_full = sf->fn;
      else
	idesc_table[sf->index].sem_full = SEM_FN_NAME (@@prefix@@,x_invalid);
#endif
    }
}
\n"
   )
)

; Return C code to perform the semantics of INSN.

(define (gen-semantic-code insn)
  (string-append
   (if (and (insn-real? insn)
	    (isa-setup-semantics (current-isa)))
       (string-append
	"  "
	(rtl-c VOID (obj-isa-list insn) nil
	       (isa-setup-semantics (current-isa))
	       #:for-insn? #t
	       #:rtl-cover-fns? #t
	       #:owner insn)
	"\n")
       "")

   ; Indicate generating code for INSN.
   ; Use the compiled form if available.
   ; The case when they're not available is for virtual insns. xxx Still true?
   (cond ((insn-compiled-semantics insn)
	  => (lambda (sem)
	       (rtl-c-parsed VOID sem
			     #:for-insn? #t
			     #:rtl-cover-fns? #t
			     #:owner insn)))
	 ((insn-canonical-semantics insn)
	  => (lambda (sem)
	       (rtl-c-parsed VOID sem
			     #:for-insn? #t
			     #:rtl-cover-fns? #t
			     #:owner insn)))
	 (else
	  (context-error (make-obj-context insn #f)
			 "While generating semantic code"
			 "semantics of insn are not canonicalized"))))
)

; Return definition of C function to perform INSN.
; This version handles the with-scache case.

(define (/gen-scache-semantic-fn insn)
  (logit 2 "Processing semantics for " (obj:name insn) ": \"" (insn-syntax insn) "\" ...\n")
  (set! /with-profile? /with-profile-fn?)
  (let ((profile? (and (with-profile?)
		       (not (obj-has-attr? insn 'VIRTUAL))))
	(parallel? (with-parallel?))
	(cti? (insn-cti? insn))
	(insn-len (insn-length-bytes insn)))
    (string-list
     "/* " (obj:str-name insn) ": " (insn-syntax insn) " */\n\n"
     "static SEM_PC\n"
     "SEM_FN_NAME (@@prefix@@," (gen-sym insn) ")"
     (if (and parallel? (not (with-generic-write?)))
	 " (SIM_CPU *current_cpu, SEM_ARG sem_arg, PAREXEC *par_exec)\n"
	 " (SIM_CPU *current_cpu, SEM_ARG sem_arg)\n")
     "{\n"
     (gen-define-field-macro (insn-sfmt insn))
     (if (and parallel? (not (with-generic-write?)))
	 (gen-define-parallel-operand-macro (insn-sfmt insn))
	 "")
     "  ARGBUF *abuf = SEM_ARGBUF (sem_arg);\n"
     ; Unconditionally written operands are not recorded here.
     "  int UNUSED written = 0;\n"
     ; The address of this insn, needed by extraction and semantic code.
     ; Note that the address recorded in the cpu state struct is not used.
     ; For faster engines that copy will be out of date.
     "  IADDR UNUSED pc = abuf->addr;\n"
     (if (and cti? (not parallel?))
	 "  SEM_BRANCH_INIT\n" ; no trailing `;' on purpose
	 "")
     (string-list "  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, "
		  (number->string insn-len)
		  ");\n")
     "\n"
     (gen-semantic-code insn) "\n"
     ; Only update what's been written if some are conditionally written.
     ; Otherwise we know they're all written so there's no point in
     ; keeping track.
     (if (/any-cond-written? (insn-sfmt insn))
	 "  abuf->written = written;\n"
	 "")
     (if (and cti? (not parallel?))
	 "  SEM_BRANCH_FINI (vpc);\n"
	 "")
     "  return vpc;\n"
     (if (and parallel? (not (with-generic-write?)))
	 (gen-undef-parallel-operand-macro (insn-sfmt insn))
	 "")
     (gen-undef-field-macro (insn-sfmt insn))
     "}\n\n"
     ))
)

; Return definition of C function to perform INSN.
; This version handles the without-scache case.
; ??? TODO: multiword insns.

(define (/gen-no-scache-semantic-fn insn)
  (logit 2 "Processing semantics for " (obj:name insn) ": \"" (insn-syntax insn) "\" ...\n")
  (set! /with-profile? /with-profile-fn?)
  (let ((profile? (and (with-profile?)
		       (not (obj-has-attr? insn 'VIRTUAL))))
	(parallel? (with-parallel?))
	(cti? (insn-cti? insn))
	(insn-len (insn-length-bytes insn)))
    (string-list
     "/* " (obj:str-name insn) ": " (insn-syntax insn) " */\n\n"
     "static SEM_STATUS\n"
     "SEM_FN_NAME (@@prefix@@," (gen-sym insn) ")"
     (if (and parallel? (not (with-generic-write?)))
	 " (SIM_CPU *current_cpu, SEM_ARG sem_arg, PAREXEC *par_exec, CGEN_INSN_WORD insn)\n"
	 " (SIM_CPU *current_cpu, SEM_ARG sem_arg, CGEN_INSN_WORD insn)\n")
     "{\n"
     (if (and parallel? (not (with-generic-write?)))
	 (gen-define-parallel-operand-macro (insn-sfmt insn))
	 "")
     "  SEM_STATUS status = 0;\n" ; ??? wip
     "  ARGBUF *abuf = SEM_ARGBUF (sem_arg);\n"
     (gen-define-field-macro (if (with-scache?) (insn-sfmt insn) #f))
     ; Unconditionally written operands are not recorded here.
     "  int UNUSED written = 0;\n"
     "  IADDR UNUSED pc = GET_H_PC ();\n"
     (if (and cti? (not parallel?))
	 "  SEM_BRANCH_INIT\n" ; no trailing `;' on purpose
	 "")
     (string-list "  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, "
		  (number->string insn-len)
		  ");\n")
     (string-list (gen-define-ifmt-ifields (insn-ifmt insn) "  " #f #t)
		  (gen-sfmt-op-argbuf-defns (insn-sfmt insn))
		  (gen-extract-ifmt-ifields (insn-ifmt insn) "  " #f #t)
		  (gen-sfmt-op-argbuf-assigns (insn-sfmt insn)))
     "\n"
     (gen-semantic-code insn) "\n"
     ; Only update what's been written if some are conditionally written.
     ; Otherwise we know they're all written so there's no point in
     ; keeping track.
     (if (/any-cond-written? (insn-sfmt insn))
	 "  abuf->written = written;\n"
	 "")
     ; SEM_{,N}BRANCH_FINI are user-supplied macros.
     (if (not parallel?)
	 (string-list
	  (if cti?
	      "  SEM_BRANCH_FINI (vpc, "
	      "  SEM_NBRANCH_FINI (vpc, ")
	  (gen-bool-attrs (obj-atlist insn) gen-attr-mask)
	  ");\n")
	 "")
     (gen-undef-field-macro (insn-sfmt insn))
     "  return status;\n"
     (if (and parallel? (not (with-generic-write?)))
	 (gen-undef-parallel-operand-macro (insn-sfmt insn))
	 "")
     "}\n\n"
     ))
)

(define (/gen-all-semantic-fns)
  (logit 2 "Processing semantics ...\n")
  (let ((insns (non-alias-insns (current-insn-list))))
    (if (with-scache?)
	(string-write-map /gen-scache-semantic-fn insns)
	(string-write-map /gen-no-scache-semantic-fn insns)))
)

; Utility of /gen-sem-case to return the mask of operands always written
; to in <sformat> SFMT.
; ??? Not currently used.

(define (/uncond-written-mask sfmt)
  (apply + (map (lambda (op)
		  (if (op:cond? op)
		      0
		      (logsll 1 (op:num op))))
		(sfmt-out-ops sfmt)))
)

; Utility of /gen-sem-case to return #t if any operand in <sformat> SFMT is
; conditionally written to.

(define (/any-cond-written? sfmt)
  (any-true? (map op:cond? (sfmt-out-ops sfmt)))
)

; Generate a switch case to perform INSN.

(define (/gen-sem-case insn parallel?)
  (logit 2 "Processing "
	 (if parallel? "parallel " "")
	 "semantic switch case for " (obj:name insn) ": \""
	 (insn-syntax insn) "\" ...\n")
  (set! /with-profile? /with-profile-sw?)
  (let ((cti? (insn-cti? insn))
	(insn-len (insn-length-bytes insn)))
    (string-list
     ; INSN_ is prepended here and not elsewhere to avoid name collisions
     ; with symbols like AND, etc.
     "  CASE (sem, "
     "INSN_"
     (if parallel? "PAR_" "")
     (string-upcase (gen-sym insn)) ") : "
     "/* " (insn-syntax insn) " */\n"
     "{\n"
     "  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);\n"
     "  ARGBUF *abuf = SEM_ARGBUF (sem_arg);\n"
     (gen-define-field-macro (if (with-scache?) (insn-sfmt insn) #f))
     (if (and parallel? (not (with-generic-write?)))
	 (gen-define-parallel-operand-macro (insn-sfmt insn))
	 "")
     ; Unconditionally written operands are not recorded here.
     "  int UNUSED written = 0;\n"
     ; The address of this insn, needed by extraction and semantic code.
     ; Note that the address recorded in the cpu state struct is not used.
     "  IADDR UNUSED pc = abuf->addr;\n"
     (if (and cti? (not parallel?))
	 "  SEM_BRANCH_INIT\n" ; no trailing `;' on purpose
	 "")
     (if (with-scache?)
	 ""
	 (string-list (gen-define-ifmt-ifields (insn-ifmt insn) "  " #f #t)
		      (gen-extract-ifmt-ifields (insn-ifmt insn) "  " #f #t)
		      "\n"))
     (string-list "  vpc = SEM_NEXT_VPC (sem_arg, pc, "
		  (number->string insn-len)
		  ");\n")
     "\n"
     (gen-semantic-code insn) "\n"
     ; Only update what's been written if some are conditionally written.
     ; Otherwise we know they're all written so there's no point in
     ; keeping track.
     (if (/any-cond-written? (insn-sfmt insn))
	 "  abuf->written = written;\n"
	 "")
     (if (and cti? (not parallel?))
	 "  SEM_BRANCH_FINI (vpc);\n"
	 "")
     (if (and parallel? (not (with-generic-write?)))
	 (gen-undef-parallel-operand-macro (insn-sfmt insn))
	 "")
     (gen-undef-field-macro (insn-sfmt insn))
     "}\n"
     "  NEXT (vpc);\n\n"
     ))
)

(define (/gen-sem-switch)
  (logit 2 "Processing semantic switch ...\n")
  ; Turn parallel execution support off.
  (let ((orig-with-parallel? (with-parallel?)))
    (set-with-parallel?! #f)
    (let ((result
	   (string-write-map (lambda (insn) (/gen-sem-case insn #f))
			     (non-alias-insns (current-insn-list)))))
      (set-with-parallel?! orig-with-parallel?)
      result))
)

; Generate the guts of a C switch statement to execute parallel instructions.
; This switch is included after the non-parallel instructions in the semantic
; switch.
;
; ??? We duplicate the writeback case for each insn, even though we only need
; one case per insn format.  The former keeps the code for each insn
; together and might improve cache usage.  On the other hand the latter
; reduces the amount of code, though it is believed that in this particular
; instance the win isn't big enough.

(define (/gen-parallel-sem-switch)
  (logit 2 "Processing parallel insn semantic switch ...\n")
  ; Turn parallel execution support on.
  (let ((orig-with-parallel? (with-parallel?)))
    (set-with-parallel?! #t)
    (let ((result
	   (string-write-map (lambda (insn)
			       (string-list (/gen-sem-case insn #t)
					    (/gen-write-case (insn-sfmt insn) insn)))
			     (parallel-insns (current-insn-list)))))
      (set-with-parallel?! orig-with-parallel?)
      result))
)

; Top level file generators.

; Generate cpu-<cpu>.h

(define (cgen-cpu.h)
  (logit 1 "Generating " (gen-cpu-name) "'s cpu.h ...\n")

  (sim-analyze-insns!)

  ; Turn parallel execution support on if cpu needs it.
  (set-with-parallel?! (state-parallel-exec?))

  ; Tell the rtl->c translator we're not the simulator.
  ; ??? Minimizes changes in generated code until this is changed.
  ; RTL->C happens for field decoding.
  (rtl-c-config! #:rtl-cover-fns? #f)

  (string-write
   (gen-c-copyright "CPU family header for @@cpu@@."
		  CURRENT-COPYRIGHT CURRENT-PACKAGE)
   "\
#ifndef CPU_@@CPU@@_H
#define CPU_@@CPU@@_H

"
   /gen-cpu-defines
   ;; After CGEN_INSN_WORD is defined we can include cgen-engine.h.
   ;; We need to include it here (or thereabouts) because cgen-engine.h
   ;; needs CGEN_INSN_WORD and parts of the remainder of this file need
   ;; cgen-engine.h.
   "#include \"cgen-engine.h\"\n\n"
   /gen-hardware-types
   /gen-cpu-reg-access-decls
   /gen-model-decls

   (if (not (with-multiple-isa?))
     (string-list
       (lambda () (gen-argbuf-type #t))
       (lambda () (gen-scache-type #t))
       /gen-extract-macros)
     "")

   (if (and (with-parallel?) (not (with-generic-write?)))
       /gen-parallel-exec-type
       "")
   /gen-trace-record-type
   "#endif /* CPU_@@CPU@@_H */\n"
   )
)

; Generate defs-<isa>.h.

(define (cgen-defs.h)
  (logit 1 "Generating " (obj:name (current-isa)) "'s defs.h ...\n")

  (sim-analyze-insns!)

  ; Tell the rtl->c translator we're not the simulator.
  ; ??? Minimizes changes in generated code until this is changed.
  ; RTL->C happens for field decoding.
  (rtl-c-config! #:rtl-cover-fns? #f)

  (string-write
   (gen-c-copyright (string-append
                  "ISA definitions header for "
                  (obj:str-name (current-isa))
                  ".")
                 CURRENT-COPYRIGHT CURRENT-PACKAGE)
   "\
#ifndef DEFS_@@PREFIX@@_H
#define DEFS_@@PREFIX@@_H

"
   (lambda () (gen-argbuf-type #t))
   (lambda () (gen-scache-type #t))
   /gen-extract-macros

   "#endif /* DEFS_@@PREFIX@@_H */\n"
   )
)

; Generate cpu-<cpu>.c

(define (cgen-cpu.c)
  (logit 1 "Generating " (gen-cpu-name) "'s cpu.c ...\n")

  (sim-analyze-insns!)

  ; Turn parallel execution support on if cpu needs it.
  (set-with-parallel?! (state-parallel-exec?))

  ; Initialize rtl generation.
  (rtl-c-config! #:rtl-cover-fns? #t)

  (string-write
   (gen-c-copyright "Misc. support for CPU family @@cpu@@."
		  CURRENT-COPYRIGHT CURRENT-PACKAGE)
   "\
#define WANT_CPU @@cpu@@
#define WANT_CPU_@@CPU@@

#include \"sim-main.h\"
#include \"cgen-ops.h\"

"
   /gen-cpu-reg-access-defns
   /gen-cpu-record-results
   )
)

; Generate read.c

(define (cgen-read.c)
  (logit 1 "Generating " (gen-cpu-name) "'s read.c ...\n")

  (sim-analyze-insns!)

  ; Turn parallel execution support off.
  (set-with-parallel?! #f)

  ; Tell the rtx->c translator we are the simulator.
  (rtl-c-config! #:rtl-cover-fns? #t)

  (string-write
   (gen-c-copyright (string-append "Simulator instruction operand reader for "
				   (symbol->string (current-arch-name)) ".")
		  CURRENT-COPYRIGHT CURRENT-PACKAGE)
   "\
#ifdef DEFINE_LABELS

  /* The labels have the case they have because the enum of insn types
     is all uppercase and in the non-stdc case the fmt symbol is built
     into the enum name.  */

  static struct {
    int index;
    void *label;
  } labels[] = {\n"

   (lambda ()
     (string-write-map (lambda (insn)
			 (string-append "    { "
					"@@PREFIX@@_INSN_"
					(string-upcase (gen-sym insn))
					", && case_read_READ_"
					(string-upcase (gen-sym (insn-sfmt insn)))
					" },\n"))
		       (non-alias-insns (current-insn-list))))

   "    { 0, 0 }
  };
  int i;

  for (i = 0; labels[i].label != 0; ++i)
    CPU_IDESC (current_cpu) [labels[i].index].read = labels[i].label;

#undef DEFINE_LABELS
#endif /* DEFINE_LABELS */

#ifdef DEFINE_SWITCH

{\n"
   (if (with-scache?)
       "\
  SEM_ARG sem_arg = sc;
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);

  SWITCH (read, sem_arg->read)\n"
       "\
  SWITCH (read, decode->read)\n")
   "\
    {

"

   /gen-read-switch

   "\
    }
  ENDSWITCH (read) /* End of read switch.  */
}

#undef DEFINE_SWITCH
#endif /* DEFINE_SWITCH */
"
   )
)

; Generate write.c

(define (cgen-write.c)
  (logit 1 "Generating " (gen-cpu-name) "'s write.c ...\n")

  (sim-analyze-insns!)

  ; Turn parallel execution support off.
  (set-with-parallel?! #f)

  ; Tell the rtx->c translator we are the simulator.
  (rtl-c-config! #:rtl-cover-fns? #t)

  (string-write
   (gen-c-copyright (string-append "Simulator instruction operand writer for "
				   (symbol->string (current-arch-name)) ".")
		  CURRENT-COPYRIGHT CURRENT-PACKAGE)
   "\
/* Write cached results of 1 or more insns executed in parallel.  */

void
@@cpu@@_parallel_write (SIM_CPU *cpu, SCACHE *sbufs, PAREXEC *pbufs, int ninsns)
{\n"
   (if (with-scache?)
       "\
  SEM_ARG sem_arg = sc;
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);\n"
       "")
   "\

  do
    {
      ARGBUF *abuf = SEM_ARGBUF (sbufs);

      switch (abuf->idesc->write)
	{
\n"

   ;(/indent-add 8)
   /gen-write-switch
   ;(/indent-add -8)

   "\
	}
    }
  while (--ninsns > 0);
}
"
   )
)

; Generate semantics.c
; Each instruction is implemented in its own function.

(define (cgen-semantics.c)
  (logit 1 "Generating " (gen-cpu-name) "'s semantics.c ...\n")

  (sim-analyze-insns!)

  ; Turn parallel execution support on if cpu needs it.
  (set-with-parallel?! (state-parallel-exec?))

  ; Tell the rtx->c translator we are the simulator.
  (rtl-c-config! #:rtl-cover-fns? #t)

  (string-write
   (gen-c-copyright "Simulator instruction semantics for @@cpu@@."
		  CURRENT-COPYRIGHT CURRENT-PACKAGE)
   "\
#define WANT_CPU @@cpu@@
#define WANT_CPU_@@CPU@@

#include \"sim-main.h\"
#include \"cgen-mem.h\"
#include \"cgen-ops.h\"

#undef GET_ATTR
"
   (gen-define-with-symcat "GET_ATTR(cpu, num, attr) \
CGEN_ATTR_VALUE (NULL, abuf->idesc->attrs, CGEN_INSN_" "attr)")
"
/* This is used so that we can compile two copies of the semantic code,
   one with full feature support and one without that runs fast(er).
   FAST_P, when desired, is defined on the command line, -DFAST_P=1.  */
#if FAST_P
#define SEM_FN_NAME(cpu,fn) XCONCAT3 (cpu,_semf_,fn)
#undef CGEN_TRACE_RESULT
#define CGEN_TRACE_RESULT(cpu, abuf, name, type, val)
#else
#define SEM_FN_NAME(cpu,fn) XCONCAT3 (cpu,_sem_,fn)
#endif
\n"

   /gen-all-semantic-fns
   ; Put the table at the end so we don't have to declare all the sem fns.
   /gen-semantic-fn-table
   )
)

; Generate sem-switch.c.
; Each instruction is a case in a switch().
; This file consists of just the switch().  It is included by mainloop.c.

(define (cgen-sem-switch.c)
  (logit 1 "Generating " (gen-cpu-name) "'s sem-switch.c ...\n")

  (sim-analyze-insns!)

  ; Turn parallel execution support off.
  ; It is later turned on/off when generating the actual semantic code.
  (set-with-parallel?! #f)

  ; Tell the rtx->c translator we are the simulator.
  (rtl-c-config! #:rtl-cover-fns? #t)

  (string-write
   (gen-c-copyright "Simulator instruction semantics for @@cpu@@."
		  CURRENT-COPYRIGHT CURRENT-PACKAGE)

   "\
#ifdef DEFINE_LABELS

  /* The labels have the case they have because the enum of insn types
     is all uppercase and in the non-stdc case the insn symbol is built
     into the enum name.  */

  static struct {
    int index;
    void *label;
  } labels[] = {\n"

   (lambda ()
     (string-write-map (lambda (insn)
			 (string-append "    { "
					"@@PREFIX@@_INSN_"
					(string-upcase (gen-sym insn))
					", && case_sem_INSN_"
					(string-upcase (gen-sym insn))
					" },\n"))
		       (non-alias-insns (current-insn-list))))

   (if (state-parallel-exec?)
       (lambda ()
	 (string-write-map (lambda (insn)
			     (string-append "    { "
					    "@@CPU@@_INSN_PAR_"
					    (string-upcase (gen-sym insn))
					    ", && case_sem_INSN_PAR_"
					    (string-upcase (gen-sym insn))
					    " },\n"
					    "    { "
					    "@@CPU@@_INSN_WRITE_"
					    (string-upcase (gen-sym insn))
					    ", && case_sem_INSN_WRITE_"
					    (string-upcase (gen-sym insn))
					    " },\n"))
			   (parallel-insns (current-insn-list))))
       "")

   "    { 0, 0 }
  };
  int i;

  for (i = 0; labels[i].label != 0; ++i)
    {
#if FAST_P
      CPU_IDESC (current_cpu) [labels[i].index].sem_fast_lab = labels[i].label;
#else
      CPU_IDESC (current_cpu) [labels[i].index].sem_full_lab = labels[i].label;
#endif
    }

#undef DEFINE_LABELS
#endif /* DEFINE_LABELS */

#ifdef DEFINE_SWITCH

/* If hyper-fast [well not unnecessarily slow] execution is selected, turn
   off frills like tracing and profiling.  */
/* FIXME: A better way would be to have TRACE_RESULT check for something
   that can cause it to be optimized out.  Another way would be to emit
   special handlers into the instruction \"stream\".  */

#if FAST_P
#undef CGEN_TRACE_RESULT
#define CGEN_TRACE_RESULT(cpu, abuf, name, type, val)
#endif

#undef GET_ATTR
"
   (gen-define-with-symcat "GET_ATTR(cpu, num, attr) \
CGEN_ATTR_VALUE (NULL, abuf->idesc->attrs, CGEN_INSN_" "attr)")
"
{

#if WITH_SCACHE_PBB

/* Branch to next handler without going around main loop.  */
#define NEXT(vpc) goto * SEM_ARGBUF (vpc) -> semantic.sem_case
SWITCH (sem, SEM_ARGBUF (vpc) -> semantic.sem_case)

#else /* ! WITH_SCACHE_PBB */

#define NEXT(vpc) BREAK (sem)
#ifdef __GNUC__
#if FAST_P
  SWITCH (sem, SEM_ARGBUF (sc) -> idesc->sem_fast_lab)
#else
  SWITCH (sem, SEM_ARGBUF (sc) -> idesc->sem_full_lab)
#endif
#else
  SWITCH (sem, SEM_ARGBUF (sc) -> idesc->num)
#endif

#endif /* ! WITH_SCACHE_PBB */

    {

"

   /gen-sem-switch

   (if (state-parallel-exec?)
       /gen-parallel-sem-switch
       "")

   "
    }
  ENDSWITCH (sem) /* End of semantic switch.  */

  /* At this point `vpc' contains the next insn to execute.  */
}

#undef DEFINE_SWITCH
#endif /* DEFINE_SWITCH */
"
   )
)

; Generate mainloop.in.
; ??? Not currently used.

(define (cgen-mainloop.in)
  (logit 1 "Generating mainloop.in ...\n")

  (string-write
   "cat <<EOF >/dev/null\n"
   (gen-c-copyright "Simulator main loop for @@arch@@."
		  CURRENT-COPYRIGHT CURRENT-PACKAGE)
   "EOF\n"
   "\

# Syntax:
# /bin/sh mainloop.in init|support|{full,fast}-{extract,exec}-{scache,nocache}

# ??? There's lots of conditional compilation here.
# After a few more ports are done, revisit.

case \"x$1\" in

xsupport)

cat <<EOF
/*xsupport*/
EOF

;;

xinit)

cat <<EOF
/*xinit*/
EOF

;;

xfull-extract-* | xfast-extract-*)

cat <<EOF
{
"
   (rtl-c VOID #f nil insn-extract #:rtl-cover-fns? #t)
"}
EOF

;;

xfull-exec-* | xfast-exec-*)

cat <<EOF
{
"
   (rtl-c VOID #f nil insn-execute #:rtl-cover-fns? #t)
"}
EOF

;;

*)
  echo \"Invalid argument to mainloop.in: $1\" >&2
  exit 1
  ;;

esac
"
   )
)
@


1.19
log
@remove unnecessary comment in generated code
@
text
@d1093 2
a1094 2
#undef TRACE_RESULT
#define TRACE_RESULT(cpu, abuf, name, type, val)
d1191 2
a1192 2
#undef TRACE_RESULT
#define TRACE_RESULT(cpu, abuf, name, type, val)
@


1.18
log
@	* mach.scm (<derived-arch-data>): New member large-insn-word?.
	(/adata-set-derived!): Set it.
	(adata-large-insn-word?): New function.
	* sim-arch.scm (/gen-cpuall-includes): Don't #include cgen-engine.h
	here.
	* sim-cpu.scm (cgen-cpu.h): #include it here.
	(/gen-cpu-defines): Define CGEN_INSN_WORD.
	(/gen-no-scache-semantic-fn): Use CGEN_INSN_WORD instead of
	CGEN_INSN_INT.
	* sim-decode.scm (/gen-idesc-decls): Ditto.
	(/gen-extract-case, /gen-decode-fn): Ditto.
	* sim-model.scm (/gen-model-insn-fn): Ditto.
	* sim.scm (gen-argbuf-type): Ditto.
@
text
@a848 1
   "/* cgen-engine.h needs CGEN_INSN_WORD that we just defined.  */\n"
@


1.17
log
@	Specify isa(s) when doing ifield, operand, insn lookups.
	ACU = all callers updated.
	* attr.scm (/attr-eval): Call rtx-value instead of rtx-eval-with-estate.
	* enum.scm (define-full-insn-enum): Pass isa-name-list to
	current-ifld-lookup.
	* html.scm (get-insn-properties): Pass isa-name-list to
	current-op-lookup.
	* ifield.scm (/ifld-parse-follows): New arg isas, ACU.
	* insn.scm (/parse-insn-format-symbol): New arg isa-name-list, ACU.
	(/parse-insn-format-list, /parse-insn-iformat-iflds): Ditto.
	(/parse-insn-format, syntax-break-out): Ditto.
	* mach.scm (obj-filter-by-isa): New function.
	(current-ifld-lookup): New optional arg maybe-isa-name-list.
	(/ifld-already-defined?, /op-already-defined?): Simplify.
	(current-op-lookup): New optional arg maybe-isa-name-list.
	(current-insn-lookup): New arg isa-name-list, ACU.
	(/insn-already-defined?, /minsn-already-defined?): Simplify.
	(current-minsn-lookup): New arg isa-name-list, ACU.
	* minsn.scm (/minsn-compute-iflds): Pass isa-name-list to
	current-op-lookup.
	* opc-itab.scm (compute-syntax): New arg isa-name-list, ACU.
	(gen-syntax-entry): Ditto.
	* operand.scm (/operand-parse): Pass isa-name-list to
	current-ifld-lookup.
	(/derived-parse-encoding): New arg isa-name-list, ACU.
	(/derived-parse-ifield-assertion): Ditto.
	(/derived-operand-parse): Pass isa-name-list to current-op-lookup.
	(/anyof-parse-choice): Ditto.
	(anyof-satisfies-assertions?): Pass context to rtx-solve.
	(/anyof-merge-syntax): New arg container, ACU.
	(operand-builtin!): Add pc to all isas.
	* rtl-c.scm (estate-make-for-rtl-c): Delete arg extra-vars-alist, ACU.
	(estate-make-for-rtl-c++, rtl-c-expr-parsed): Ditto.
	(rtl-c-parsed, rtl-c++-parsed): Ditto.
	(rtl-c): New arg isa-name-list, ACU.
	(rtl-c-expr, rtl-c++): Ditto.
	(closure): New arg isa-name-list, ACU.
	* rtl-traverse.scm (/make-cstate): New arg isa-name-list, ACU.
	(/cstate-isas): New function.
	(/rtx-canon-symbol-list): New function.
	(/rtx-canon-env-stack): Renamed from /rtx-canon-env, ACU.
	updated.
	(/rtx-make-canon-table): Rename ENV to ENVSTACK, new entry SYMBOLLIST.
	(/rtx-canon-rtx-operand): Pass isa list to current-op-lookup.
	(/rtx-canon-rtx-ref, /rtx-canon): Ditto.
	(rtx-canonicalize): New arg isa-name-list, ACU.
	(rtx-canonicalize-stmt): Delete.
	(tstate-make): New arg isas, ACU.
	(tstate-isas, tstate--set-isas!): New functions.
	(tstate-env-stack): Renamed from tstate-env, ACU.
	(tstate-set-env-stack!): Renamed from tstate-set-env!, ACU.
	(tstate-make-closure): Renamed from tstate-new-env, new arg
	isa-name-list, ACU.
	(/rtx-traverse-env): Delete.
	(/rtx-make-traverser-table): Rename ENV to ENVSTACK, new entry
	SUMBOLLIST.
	(/rtx-traverse): Include conditional flag in dump output.
	Update isa,envstack for closures.  Pass isa list to current-op-lookup.
	(<eval-state>): New member isas.  Rename env to env-stack.
	(<eval-state> vmake!): Handle #:isas.  #:env renamed to #:env-stack.
	(<eval-state>): New getter/setter for isas.  Rename env getter/setter
	to env-stack.
	(estate-make-for-eval): Provide #:isas.
	(estate-make-closure): Renamed from estate-new-env.  New arg
	isa-name-list, ACU.
	* rtl-xform.scm (/rtx-simplify-expr-fn): Handle closures.
	(/rtx-trim-args): ENV renamed to ENVSTACK.  Ad ITERATION, SYMBOLLIST.
	(/rtx-trim-for-doc): Handle closures.
	* rtl.scm (/rtx-valid-types): Rename ENV to ENVSTACK.  Add ITERATION,
	SYMBOLLIST.
	(rtx-env-var-list): Delete.
	(rtx-env-make): Handle already-compiled environments.
	(rtx-var-alist-to-env): New function.
	(rtx-var-alist-to-closure-env-stack, rtx-make-env-stack): New functions.
	(rtx-env-stack-dump): Renamed from rtx-env-dump, ACU.
	(rtx-operand-obj): New arg isa-name-list, ACU.
	(rtx-closure-isas, rtx-closure-env-stack, rtx-closure-expr): New
	functions.
	* rtx-funcs.scm (closure): New arg isa-name-list, reorder args, ACU.
	* sem-frags.scm (<sfrag>): Delete member compiled-semantics.
	(/frag-compute-desired-frags): Minor simplification.
	(/frag-pick-best): Ditto.
	* sid-cpu.scm (gen-semantic-code): Require canonical rtl.
	(/gen-sfrag-code): Update.
	* sim-cpu.scm (gen-semantic-code): Require canonical rtl.
	* utils-cgen.scm (sanitize): New arg isa-name-list, ACU.
	* utils.scm (non-null-intersection?): New function.
@
text
@d26 9
a34 1
   "\n\n"
d647 2
a648 2
	 " (SIM_CPU *current_cpu, SEM_ARG sem_arg, PAREXEC *par_exec, CGEN_INSN_INT insn)\n"
	 " (SIM_CPU *current_cpu, SEM_ARG sem_arg, CGEN_INSN_INT insn)\n")
d845 6
@


1.16
log
@	Record bitset attributes internally as a list.
	Record rtx attribute values internally as ((rtx-expr)).
	* attr.scm (bitset-attr?): Delete, unused.
	(<bitset-attribute> parse-value): Rewrite.
	(/attr-parse): Rewrite bitset default value processing.
	(/attr-read): Pick out values of scalar attributes to distinguish
	them from bitset values which are a list.
	Fix spelling errors for processing of default values.
	Handle string attributes.
	(bitset-attr->list): Delete, all callers updated.
	(/bitset-attr->charmask): Renamed from bitset-attr->charmask.
	All callers updated.
	(atlist-source-form): Rewrite.
	* hardware.scm (<hardware-base> 'get-isas): Update recognition
	of all isas.
	(hardware-builtin!): Update spec of ISA attribute, (ISA foo,bar)
	-> (ISA foo bar).
	* intrinsics.scm (target:belongs-to-group?): Update, bitset attribute
	values are now lists.
	* mach.scm (def-isa-attr!): Update, bitset attribute values,
	including the default, are now lists.
	(all-isas-attr-value): Result is now a list.
	* doc/rtl.texi: Clean up pass over attribute docs.
@
text
@d537 2
a538 1
	(rtl-c VOID (isa-setup-semantics (current-isa)) nil
d547 1
a547 1
   ; The case when they're not available is for virtual insns. (??? Still true?)
d550 1
a550 1
	       (rtl-c-parsed VOID sem nil
d556 1
a556 1
	       (rtl-c-parsed VOID sem nil
d561 3
a563 4
	  (rtl-c VOID (insn-semantics insn) nil
		 #:for-insn? #t
		 #:rtl-cover-fns? #t
		 #:owner insn))))
d1275 1
a1275 1
   (rtl-c VOID insn-extract nil #:rtl-cover-fns? #t)
d1286 1
a1286 1
   (rtl-c VOID insn-execute nil #:rtl-cover-fns? #t)
@


1.15
log
@	* sid-cpu.scm (/gen-sem-case): Tweaking debugging printf.
	(/gen-sfrag-case): Ditto.
	* sim-cpu.scm (/gen-sem-case): Ditto.
@
text
@d74 1
a74 1
		     (bitset-attr->list (obj-attr-value hw 'ISA)))
@


1.14
log
@	* cos.scm (/method-lookup): Delete arg virtual?, all callers updated.
	(method-proc): Delete.
	(method-make-virtual!, method-make-virtual-forward!): Delete.
	* ifield.scm (<ifield> field-start): Update.
	(<ifield> field-length, pretty-print): Update.
	(<multi-ifield> field-length, field-start, pretty-print): Update.
	* sid-cpu.scm (/gen-hardware-struct): Use gen-defn instead of gen-decl.
	* sid.scm (<scalar> gen-sym-defn): Renamed from gen-sym-decl.
	(<array> gen-sym-defn): Ditto.
	(<hardware-base> gen-defn): Renamed from gen-defn.
	(<hw-register> gen-type): Update.
	(<hw-register> gen-defn): Renamed from gen-sym-decl, rewrite.
	(<hw-memory>, <hw-address>, <hw-iaddress> gen-type): Update.
	(<hw-memory>, <hw-address> gen-defn): Renamed from gen-sym-decl.
	(<hw-immediate> gen-type): Update.
	(<hw-immediate> gen-defn): Renamed from gen-sym-decl, rewrite.
	* sim-cpu.scm (/gen-hardware-struct): Use gen-defn instead of gen-decl.
	* sim.scm (<scalar> gen-sym-defn): Renamed from gen-sym-decl.
	(<array> gen-sym-defn): Ditto.
	(<hardware-base> gen-defn): Renamed from gen-defn.
	(<hw-register> gen-type): Update.
	(<hw-register> gen-defn): Renamed from gen-sym-decl, rewrite.
	(<hw-memory>, <hw-address>, <hw-iaddress> gen-type): Update.
	(<hw-memory>, <hw-address> gen-defn): Renamed from gen-sym-decl.
	(<hw-immediate> gen-type): Update.
	(<hw-immediate> gen-defn): Renamed from gen-sym-decl, rewrite.
@
text
@d719 2
a720 1
	 "semantic switch case for \"" (insn-syntax insn) "\" ...\n")
@


1.13
log
@	* xc16x.cpu (h-cr): New hardware.
	(muls): Comment out parts that won't compile, add fixme.
	(mulu, divl, divlu, jmpabs, jmpa-, jmprel, jbc, jnbs, callr): Ditto.
	(scxti, scxtmg, scxtm, bclear, bclr18, bset19, bitset, bmov): Ditto.
	(bmovn, band, bor, bxor, bcmp, bfldl, bfldh): Ditto.

	Rewrite rtl processing to require it to be "canonicalized" first,
	and write a full canonicalizer / expression checker.
	Remove all appearances of DFLT in canonical rtl.
	* attr.scm (/attr-eval atval owner): Call rtx-canonicalize,
	then rtx-simplify.
	* iformat.scm (ifmt-analyze) Use canonical semantics.
	* insn (<insn>): New member canonical-semantics.
	* mach.scm (<arch>): New member multi-insns-instantiated?.
	(/instantiate-multi-insns!): New function.
	(/canonicalize-insns!): New function.
	(arch-analyze-insns!): Canonicalize insn semantics before processing
	them.
	* mode.scm (/mode-set-word-params!): New function.
	(mode-void?): New function.
	(mode-compatible?): VOID is compatible with VOID.
	(/mode-word-sizes-defined?): New global.
	(mode-set-word-modes!): Use/set it.
	(mode-ensure-word-sizes-defined): Update.
	(mode-builtin!): New builtin "modes" SYM, INSN, MACH.
	Redo WI/UWI/AI/IAI handling.
	(op:new-mode): No longer accept DFLT.
	(<derived-operand> constructor): Ensure all fields are initialized.
	(<anyof-operand> constructor): Ditto.
	(/derived-parse-ifield-assertion): Delete arg `args'.
	All callers updated.
	* rtl-c.scm (<rtl-c-eval-state>): New member `for-insn?'.
	(rtl-c): Call rtx-canonicalize instead of rtx-compile.
	(rtl-c-expr, rtl-c++): Ditto.
	(/rtl-c-get): Use mode of operand, not containing expression.
	(rtl-c-set-quiet, rtl-c-set-trace): Remove DFLT support.
	(/rtx-use-sem-fn?): Don't check for (insn? owner), check
	estate-for-insn? instead.
	(s-unop): Use mode of expression, not first operand.
	(s-binop, s-binop-with-bit, s-shop, s-cmpop): Ditto.
	(s-sequence): Remove DFLT support.
	(ifield): Use mode of expression, not UINT.
	(pc): Comment out, unused.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	(set, set-quiet): Pass src to rtl-c-set-{trace,quiet} for expansion.
	* rtl-traverse.scm (/rtx-canon-debug?): New global.
	(/make-cstate): New function.
	(/cstate-context, /cstate-outer-expr): New functions.
	(/rtx-canon-error): New function.
	(/rtx-lookup-hw, /rtx-pick-mode, /rtx-pick-mode3, /rtx-pick-op-mode,
	/rtx-get-last-cond-case-rtx): New functions.
	(/rtx-canon-*): New functions.
	(/rtx-canner-table, /rtx-operand-canoners): New globals.
	(/rtx-make-canon-table, /rtx-special-expr-canoners): New functions.
	(/rtx-option, /rtx-option-list?): Rewrite.
	(rtx-munge-mode&options): Replaces /rtx-munge-mode&options.
	Rewritten, all callers updated.
	(/rtx-canon-expr, /rtx-canon): New functions.
	(rtx-canonicalize): Move here from rtl-xform.scm and rewrite.
	(rtx-canonicalize-stmt): New function.
	(tstate-make): Remove arg `set?'.  All callers updated.
	(tstate-new-set?): Delete.
	(/rtx-traverse-options, /rtx-traverse-*mode): Delete,
	moved to /rtx-canon-*.
	(/rtx-traverse-normal-operand): New function.
	(/rtx-traverse-rtx-list): Delete arg `mode', all callers updated.
	(/rtx-traverse-rtx, /rtx-traverse-setrtx,, /rtx-traverse-testrtx,
	/rtx-traverse-condrtx, /rtx-traverse-casertx, /rtx-traverse-locals,
	/rtx-traverse-iteration, /rtx-traverse-env, /rtx-traverse-attrs):
	Ditto.
	(/rtx-traverse-symbol, /rtx-traverse-string, /rtx-traverse-number,
	/rtx-traverse-symornum, /rtx-traverse-object): Delete.
	(/rtx-make-traverser-table): Update.
	(/rtx-traverse-operands): Remove mode processing, now done during
	canonicalization.
	(/rtx-traverse-expr): Delete arg `mode', all callers updated.
	(/rtx-traverse): Ditto.
	(rtx-init-traverser-tables!): New function.
	* rtl-xform (/rtx-verify-no-dflt-modes-expr-fn): New function.
	(rtx-verify-no-dflt-modes): New function.
	(/rtx-simplify-expr-fn): Update, `arg' mode deleted.
	(rtx-simplify-insn): Use insn-canonical-semantics.
	(rtx-canonicalize): Moved to rtl-traverse.scm.
	(/compile-expr-fn, rtx-compile): Delete.
	(/rtx-trim-rtx-list): New function.
	(/rtx-trim-for-doc): Handle set, if.
	* rtl.scm (<rtx-func>): New members result-mode, matchexpr-index.
	(/rtx-valid-mode-types): Update.
	(/rtx-valid-matches): Update.
	(/rtx-find-matchexpr-index): New function.
	(rtx-lookup): Require rtx-kind to be the rtx name.
	(def-rtx-node): New arg result-mode, all callers updated.
	(def-rtx-syntax-node, def-rtx-operand-node): Ditto.
	(rtx-lazy-sem-mode): Delete.
	(/rtx-closure-make): New arg `mode', all callers updated.
	(rtx-make-ifield, rtx-make-operand, rtx-make-local): Ditto.
	(rtx-operand-obj): Rewrite.
	(rtx-make-xop): New functions.
	(/hw): Renamed from `hw', all callers updated.
	Use the correct mode instead of DFLT for the index.
	(rtl-builtin!): Call rtx-init-traversal-tables!.
	(rtl-finish!): Update.
	* rtx-funcs.scm (all rtx functions): New parameter: result-mode.
	Update mode arg-type.
	(pc): Comment out.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	* sem-frags.scm (/frag-hash-compute!): Update, mode arg deleted.
	(/frag-cost-compute!): Ditto.
	* semantics.scm (/build-operand!): Delete args op-name, op.
	New arg op-expr.  All callers updated.
	(/build-mem-operand!): Remove DFLT support.
	(semantic-compile): Update process-expr!, mode arg deleted.
	* sid-cpu.scm (gen-semantic-code): Specify #:for-insn? in
	rtl-c++ calls.
	(/gen-sem-case, /gen-sfrag-code): Ditto.
	* sid.scm (/op-gen-set-trace1): Renamed from /op-gen-set-trace.
	(/op-gen-set-trace): New function.  If not doing profiling,
	call /op-gen-set-quiet.
	* sim-cpu.scm (gen-semantic-code): Specify #:for-insn? in rtl-c calls.
	* utils-gen.scm (/gen-ifld-extract-base): Update call to rtl-c.
	(/gen-ifld-extract-beyond, gen-multi-ifld-extract): Ditto.
	* utils.scm (find-first-index): New function.
	* doc/rtl.texi: Delete docs for `attr'.  Add `int-attr'.
@
text
@d52 1
a52 1
			  (gen-decl hw)
@


1.12
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d538 1
d546 18
a563 7
   ; The case when they're not available is for virtual insns.
   (let ((sem (insn-compiled-semantics insn)))
     (if sem
	 (rtl-c-parsed VOID sem nil
		       #:rtl-cover-fns? #t #:owner insn)
	 (rtl-c VOID (insn-semantics insn) nil
		#:rtl-cover-fns? #t #:owner insn))))
@


1.11
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d16 1
a16 1
(define (-gen-cpu-defines)
d43 1
a43 1
; Subroutine of -gen-hardware-types to generate the struct containing
d46 1
a46 1
(define (-gen-hardware-struct hw-list)
d63 1
a63 1
(define (-gen-hardware-types)
d69 1
a69 1
   (-gen-hardware-struct 
d116 1
a116 1
(define (-gen-cpu-reg-access-decls)
d134 1
a134 1
(define (-gen-model-decls)
d156 1
a156 1
; Utility of -gen-extract-macros to generate a macro to define the local
d160 1
a160 1
(define (-gen-extract-ifmt-macro ifmt)
d171 1
a171 1
(define (-gen-extract-macros)
d178 1
a178 1
   (string-list-map -gen-extract-ifmt-macro (current-ifmt-list))
d182 1
a182 1
; Utility of -gen-parallel-exec-type to generate the definition of one
d186 1
a186 1
(define (-gen-parallel-exec-elm sfmt)
d226 1
a226 1
(define (-gen-parallel-exec-type)
d236 1
a236 1
   (string-map -gen-parallel-exec-elm (current-sfmt-list))
d251 1
a251 1
(define (-gen-trace-record-type)
d268 1
a268 1
(define (-gen-cpu-reg-access-defns)
d309 1
a309 1
(define (-gen-cpu-record-results)
d329 1
a329 1
(define (-gen-read-args sfmt)
d334 1
a334 1
; Utility of -gen-read-switch to generate a switch case for <sformat> SFMT.
d336 1
a336 1
(define (-gen-read-case sfmt)
d346 1
a346 1
   (-gen-read-args sfmt)
d357 1
a357 1
(define (-gen-read-switch)
d359 1
a359 1
  (string-write-map -gen-read-case (current-sfmt-list))
d378 1
a378 1
(define (-gen-write-args sfmt)
d388 1
a388 1
(define (-gen-write-case sfmt insn)
d429 1
a429 1
   (-gen-write-args sfmt)
d451 1
a451 1
(define (-gen-write-switch)
d454 1
a454 1
		      (-gen-write-case sfmt #f))
d462 1
a462 1
(define (-gen-sem-fn-name insn)
d469 1
a469 1
(define (-gen-sem-fn-table-entry insn)
d475 1
a475 1
   "SEM_FN_NAME (@@prefix@@," (-gen-sem-fn-name insn) ")"
d483 1
a483 1
(define (-gen-semantic-fn-table)
d491 1
a491 1
     (string-write-map -gen-sem-fn-table-entry
d557 1
a557 1
(define (-gen-scache-semantic-fn insn)
d559 1
a559 1
  (set! -with-profile? -with-profile-fn?)
d595 1
a595 1
     (if (-any-cond-written? (insn-sfmt insn))
d614 1
a614 1
(define (-gen-no-scache-semantic-fn insn)
d616 1
a616 1
  (set! -with-profile? -with-profile-fn?)
d654 1
a654 1
     (if (-any-cond-written? (insn-sfmt insn))
d675 1
a675 1
(define (-gen-all-semantic-fns)
d679 2
a680 2
	(string-write-map -gen-scache-semantic-fn insns)
	(string-write-map -gen-no-scache-semantic-fn insns)))
d683 1
a683 1
; Utility of -gen-sem-case to return the mask of operands always written
d687 1
a687 1
(define (-uncond-written-mask sfmt)
d695 1
a695 1
; Utility of -gen-sem-case to return #t if any operand in <sformat> SFMT is
d698 1
a698 1
(define (-any-cond-written? sfmt)
d704 1
a704 1
(define (-gen-sem-case insn parallel?)
d708 1
a708 1
  (set! -with-profile? -with-profile-sw?)
d747 1
a747 1
     (if (-any-cond-written? (insn-sfmt insn))
d762 1
a762 1
(define (-gen-sem-switch)
d768 1
a768 1
	   (string-write-map (lambda (insn) (-gen-sem-case insn #f))
d784 1
a784 1
(define (-gen-parallel-sem-switch)
d791 2
a792 2
			       (string-list (-gen-sem-case insn #t)
					    (-gen-write-case (insn-sfmt insn) insn)))
d823 4
a826 4
   -gen-cpu-defines
   -gen-hardware-types
   -gen-cpu-reg-access-decls
   -gen-model-decls
d832 1
a832 1
       -gen-extract-macros)
d836 1
a836 1
       -gen-parallel-exec-type
d838 1
a838 1
   -gen-trace-record-type
d868 1
a868 1
   -gen-extract-macros
d898 2
a899 2
   -gen-cpu-reg-access-defns
   -gen-cpu-record-results
d968 1
a968 1
   -gen-read-switch
d1020 1
a1020 1
   -gen-write-switch
d1074 1
a1074 1
   -gen-all-semantic-fns
d1076 1
a1076 1
   -gen-semantic-fn-table
d1201 1
a1201 1
   -gen-sem-switch
d1204 1
a1204 1
       -gen-parallel-sem-switch
@


1.10
log
@	* desc-cpu.scm (cgen-desc.h): Tweak logit message for consistency.
	(cgen-desc.c): Ditto.
	* sid-cpu.scm (cgen-desc.h, cgen-cpu.h, cgen-defs.h): Ditto.
	(cgen-write.cxx, cgen-semantics.cxx, cgen-sem-switch.cxx): Ditto.
	* sid-decode.scm (cgen-decode.h, cgen-decode.cxx): Ditto.
	* sid-model.scm (cgen-model.cxx, cgen-model.h): Ditto.
	* sim-arch.scm (cgen-arch.h, cgen-arch.c): Ditto.
	(cgen-cpuall.h, cgen-ops.c): Ditto.
	* sim-cpu.scm (cgen-cpu.h, cgen-defs.h, cgen-cpu.c): Ditto.
	(cgen-read.c, cgen-write.c, cgen-semantics.c): Ditto.
	(cgen-sem-switch.c): Ditto.
	* sim-decode.scm (cgen-decode.h, cgen-decode.c): Ditto.
	* sim-model.c (cgen-model.c): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2001 Red Hat, Inc.
@


1.10.2.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2001, 2009 Red Hat, Inc.
@


1.9
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@d803 1
a803 1
  (logit 1 "Generating " (gen-cpu-name) " cpu.h ...\n")
d846 1
a846 1
  (logit 1 "Generating " (obj:name (current-isa)) " defs.h ...\n")
d877 1
a877 1
  (logit 1 "Generating " (gen-cpu-name) " cpu.c ...\n")
d906 1
a906 1
  (logit 1 "Generating " (gen-cpu-name) " read.c ...\n")
d984 1
a984 1
  (logit 1 "Generating " (gen-cpu-name) " write.c ...\n")
d1036 1
a1036 1
  (logit 1 "Generating " (gen-cpu-name) " semantics.c ...\n")
d1085 1
a1085 1
  (logit 1 "Generating " (gen-cpu-name) " sem-switch.c ...\n")
@


1.9.4.1
log
@Check in ARCompact simulator.  A valid configuration is arc-elf.
This is not quite finished and has most likely a few files that are
obsolete & not used, but it's good enough to run gcc regression tests.
@
text
@a2 1
; Copyright (C) 2007 Free Software Foundation, Inc.
a803 1
  ;(logit 1 "with-parallel:" (with-parallel?) "with-generic-write?:" (with-generic-write?) "\n")
@


1.8
log
@	* Makefile.am (srcroot): New var.
	(html): New rule.
	* Makefile.in: Regenerate.
	* cgen-doc.scm: New file.
	* html.scm: New file.
	* gen-all-doc: New file.
	* dev.scm (cload): Handle DOC application.
	(load-doc): New fn.
	* machs.scm (machs-for-cpu): New fn.
	* model.scm (models-for-cpu): New fn.
	* utils.scm (gen-c-copyright): Renamed from gen-copyright.
	All uses updated.
	(iota): Rewrite to be identical to pmacro version.  All uses updated.
	* utils-cgen.scm (alpha-sort-obj-list): New fn.
@
text
@d566 1
a566 1
     "/* " (obj:name insn) ": " (insn-syntax insn) " */\n\n"
d623 1
a623 1
     "/* " (obj:name insn) ": " (insn-syntax insn) " */\n\n"
d858 1
a858 1
                  (obj:name (current-isa))
d918 1
a918 1
				 (current-arch-name) ".")
d996 1
a996 1
				 (current-arch-name) ".")
@


1.7
log
@	* sim-cpu.scm (gen-semantic-code): Prepend with setup-semantics
	code.
@
text
@d816 1
a816 1
   (gen-copyright "CPU family header for @@cpu@@."
d856 1
a856 1
   (gen-copyright (string-append
d888 1
a888 1
   (gen-copyright "Misc. support for CPU family @@cpu@@."
d917 1
a917 1
   (gen-copyright (string-append "Simulator instruction operand reader for "
d995 1
a995 1
   (gen-copyright (string-append "Simulator instruction operand writer for "
d1047 1
a1047 1
   (gen-copyright "Simulator instruction semantics for @@cpu@@."
d1097 1
a1097 1
   (gen-copyright "Simulator instruction semantics for @@cpu@@."
d1228 1
a1228 1
   (gen-copyright "Simulator main loop for @@arch@@."
@


1.6
log
@2001-01-06  Ben Elliston  <bje@@redhat.com>

	* utils-gen.scm (gen-sfmt-enum-decl): Use @@prefix@@ and @@PREFIX@@
	instead of @@cpu@@ and @@CPU@@ to generically prefix symbol names.
	* sim-cpu.scm (-gen-sem-fn-table-entry): Likewise.
	(-gen-semantic-fn-table): Likewise.
	(-gen-scache-semantic-fn): Likewise.
	(-gen-no-scache-semantic-fn): Likewise.
	(cgen-read.c): Likewise.
	(cgen-sem-switch.c): Likewise.
	* desc-cpu.scm (cgen-desc.c): Use @@arch@@, not @@prefix@@, since this
	is a filename prefix.
	* sim-decode.scm (IDESC-TABLE-VAR): Use @@prefix@@, et al.
	(-gen-decode-insn-globals): Likewise.
	(-gen-idesc-decls): Likewise.
	(cgen-decode.h): Likewise.
	(cgen-decode.c): Likewise.
	* sim.scm (gen-cpu-insn-enum-decl): Likewise.
	(gen-cpu-insn-enum): Likewise.
	(sim-finish!): Likewise.
@
text
@d532 20
a551 9
  ; Indicate generating code for INSN.
  ; Use the compiled form if available.
  ; The case when they're not available is for virtual insns.
  (let ((sem (insn-compiled-semantics insn)))
    (if sem
	(rtl-c-parsed VOID sem nil
		      #:rtl-cover-fns? #t #:owner insn)
	(rtl-c VOID (insn-semantics insn) nil
	       #:rtl-cover-fns? #t #:owner insn)))
@


1.6.4.1
log
@Merge with trunk.
@
text
@d532 9
a540 20
  (string-append
   (if (and (insn-real? insn)
	    (isa-setup-semantics (current-isa)))
       (string-append
	"  "
	(rtl-c VOID (isa-setup-semantics (current-isa)) nil
	       #:rtl-cover-fns? #t
	       #:owner insn)
	"\n")
       "")

   ; Indicate generating code for INSN.
   ; Use the compiled form if available.
   ; The case when they're not available is for virtual insns.
   (let ((sem (insn-compiled-semantics insn)))
     (if sem
	 (rtl-c-parsed VOID sem nil
		       #:rtl-cover-fns? #t #:owner insn)
	 (rtl-c VOID (insn-semantics insn) nil
		#:rtl-cover-fns? #t #:owner insn))))
@


1.5
log
@* simple sim fix

2000-12-04  Frank Ch. Eigler  <fche@@redhat.com>

	* utils-sim.scm (gen-define-argbuf-macro): Handle sfmt=#f case, to be
	used by simple/non-scache simulators.
	* sim-cpu.scm (-gen-read-case): Call gen-define/undef-field-macro
	regardless of with-scache?.
	(-gen-write-case, -gen-no-scache-semantic-fn, -gen-sem-case): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
d472 1
a472 1
   "@@CPU@@_INSN_"
d475 1
a475 1
   "SEM_FN_NAME (@@cpu@@," (-gen-sem-fn-name insn) ")"
d501 1
a501 1
SEM_FN_NAME (@@cpu@@,init_idesc_table) (SIM_CPU *current_cpu)
d516 1
a516 1
	idesc_table[sf->index].sem_fast = SEM_FN_NAME (@@cpu@@,x_invalid);
d521 1
a521 1
	idesc_table[sf->index].sem_full = SEM_FN_NAME (@@cpu@@,x_invalid);
d557 1
a557 1
     "SEM_FN_NAME (@@cpu@@," (gen-sym insn) ")"
d614 1
a614 1
     "SEM_FN_NAME (@@cpu@@," (gen-sym insn) ")"
d924 1
a924 1
					"@@CPU@@_INSN_"
d1104 1
a1104 1
					"@@CPU@@_INSN_"
@


1.4
log
@2000-12-01  Ben Elliston  <bje@@redhat.com>

	* sim-cpu.scm (cgen-cpu.h): Only emit argbuf, scache and extract
	definitions if run without with-multipla-isa?.
	(cgen-defs.h): New function. Emit an ISA-specific defs file.
	* cgen-sim.scm (sim-arguments): Accept -G option to generate defs.
@
text
@d342 1
a342 3
   (if (with-scache?)
       (gen-define-field-macro sfmt)
       "")
d348 1
a348 3
   (if (with-scache?)
       (gen-undef-field-macro sfmt)
       "")
d411 1
a411 3
   (if (with-scache?)
       (gen-define-field-macro sfmt)
       "")
d436 1
a436 3
   (if (with-scache?)
       (gen-undef-field-macro sfmt)
       "")
d624 1
d655 1
d711 1
a711 3
     (if (with-scache?)
	 (gen-define-field-macro (insn-sfmt insn))
	 "")
d745 1
a745 3
     (if (with-scache?)
	 (gen-undef-field-macro (insn-sfmt insn))
	 "")
@


1.3
log
@2000-11-24  Ben Elliston  <bje@@redhat.com>

	* sim-cpu.scm (-gen-hardware-struct): New function.
	(-gen-hardware-types): If with-multiple-isa is specified, emit all
	hardware elements wich have share one or more ISAs with the ISAs
	being kept.
@
text
@d826 8
a833 3
   (lambda () (gen-argbuf-type #t))
   (lambda () (gen-scache-type #t))
   -gen-extract-macros
d839 31
@


1.2
log
@* ANSI C fixes

2000-11-20  Frank Ch. Eigler  <fche@@redhat.com>

	* opc-itab.scm (-gen-ifmt-table, -gen-macro-insn-table: Remove
	unneeded "\n\n" from F() macro definition.

2000-11-15  Greg McGary  <greg@@mcgary.org>

	* utils-cgen.scm (gen-define-with-symcat): New function.
	* desc-cpu.scm (gen-ifld-defns): Use it.
	(gen-hw-table-defns): Use it.
	(-gen-hash-defines): Use it.
	(gen-operand-table): Use it.
	(gen-insn-table): Use it.  Remove spurious `#undef MNEM'.
	* opc-itab.scm (-gen-ifmt-table): Use it.
	(-gen-insn-opcode-table): Use it.
	(-gen-macro-insn-table): Use it.
	* opc-opinst.scm (-gen-operand-instance-tables): Use it.
	* sim-cpu.scm (cgen-semantics.c): Use it.
	(cgen-sem-switch.c): Use it.
@
text
@d43 17
d69 9
a77 9
   (string-list-map (lambda (hw)
		      (string-list
		       (gen-decl hw)
		       (gen-obj-sanitize hw
					 (string-list
					  (send hw 'gen-get-macro)
					  (send hw 'gen-set-macro)))
		       ))
		    (find hw-need-storage? (current-hw-list)))
@


1.1
log
@Initial revision
@
text
@d1004 4
a1007 3
#define GET_ATTR(cpu, num, attr) \
CGEN_ATTR_VALUE (NULL, abuf->idesc->attrs, CGEN_INSN_##attr)

d1116 4
a1119 3
#define GET_ATTR(cpu, num, attr) \
CGEN_ATTR_VALUE (NULL, abuf->idesc->attrs, CGEN_INSN_##attr)

@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
