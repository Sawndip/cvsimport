head	1.18;
access;
symbols
	sid-snapshot-20180601:1.18
	cgen-snapshot-20180601:1.18
	sid-snapshot-20180501:1.18
	cgen-snapshot-20180501:1.18
	sid-snapshot-20180401:1.18
	cgen-snapshot-20180401:1.18
	sid-snapshot-20180301:1.18
	cgen-snapshot-20180301:1.18
	sid-snapshot-20180201:1.18
	cgen-snapshot-20180201:1.18
	sid-snapshot-20180101:1.18
	cgen-snapshot-20180101:1.18
	sid-snapshot-20171201:1.18
	cgen-snapshot-20171201:1.18
	sid-snapshot-20171101:1.18
	cgen-snapshot-20171101:1.18
	sid-snapshot-20171001:1.18
	cgen-snapshot-20171001:1.18
	sid-snapshot-20170901:1.18
	cgen-snapshot-20170901:1.18
	sid-snapshot-20170801:1.18
	cgen-snapshot-20170801:1.18
	sid-snapshot-20170701:1.18
	cgen-snapshot-20170701:1.18
	sid-snapshot-20170601:1.18
	cgen-snapshot-20170601:1.18
	sid-snapshot-20170501:1.18
	cgen-snapshot-20170501:1.18
	sid-snapshot-20170401:1.18
	cgen-snapshot-20170401:1.18
	sid-snapshot-20170301:1.18
	cgen-snapshot-20170301:1.18
	sid-snapshot-20170201:1.18
	cgen-snapshot-20170201:1.18
	sid-snapshot-20170101:1.18
	cgen-snapshot-20170101:1.18
	sid-snapshot-20161201:1.18
	cgen-snapshot-20161201:1.18
	sid-snapshot-20161101:1.18
	cgen-snapshot-20161101:1.18
	sid-snapshot-20160901:1.18
	cgen-snapshot-20160901:1.18
	sid-snapshot-20160801:1.18
	cgen-snapshot-20160801:1.18
	sid-snapshot-20160701:1.18
	cgen-snapshot-20160701:1.18
	sid-snapshot-20160601:1.18
	cgen-snapshot-20160601:1.18
	sid-snapshot-20160501:1.18
	cgen-snapshot-20160501:1.18
	sid-snapshot-20160401:1.18
	cgen-snapshot-20160401:1.18
	sid-snapshot-20160301:1.18
	cgen-snapshot-20160301:1.18
	sid-snapshot-20160201:1.18
	cgen-snapshot-20160201:1.18
	sid-snapshot-20160101:1.18
	cgen-snapshot-20160101:1.18
	sid-snapshot-20151201:1.18
	cgen-snapshot-20151201:1.18
	sid-snapshot-20151101:1.18
	cgen-snapshot-20151101:1.18
	sid-snapshot-20151001:1.18
	cgen-snapshot-20151001:1.18
	sid-snapshot-20150901:1.18
	cgen-snapshot-20150901:1.18
	sid-snapshot-20150801:1.18
	cgen-snapshot-20150801:1.18
	sid-snapshot-20150701:1.18
	cgen-snapshot-20150701:1.18
	sid-snapshot-20150601:1.18
	cgen-snapshot-20150601:1.18
	sid-snapshot-20150501:1.18
	cgen-snapshot-20150501:1.18
	sid-snapshot-20150401:1.18
	cgen-snapshot-20150401:1.18
	sid-snapshot-20150301:1.18
	cgen-snapshot-20150301:1.18
	sid-snapshot-20150201:1.18
	cgen-snapshot-20150201:1.18
	sid-snapshot-20150101:1.18
	cgen-snapshot-20150101:1.18
	sid-snapshot-20141201:1.18
	cgen-snapshot-20141201:1.18
	sid-snapshot-20141101:1.18
	cgen-snapshot-20141101:1.18
	sid-snapshot-20141001:1.18
	cgen-snapshot-20141001:1.18
	sid-snapshot-20140901:1.18
	cgen-snapshot-20140901:1.18
	sid-snapshot-20140801:1.18
	cgen-snapshot-20140801:1.18
	sid-snapshot-20140701:1.18
	cgen-snapshot-20140701:1.18
	sid-snapshot-20140601:1.18
	cgen-snapshot-20140601:1.18
	sid-snapshot-20140501:1.18
	cgen-snapshot-20140501:1.18
	sid-snapshot-20140401:1.18
	cgen-snapshot-20140401:1.18
	sid-snapshot-20140301:1.18
	cgen-snapshot-20140301:1.18
	sid-snapshot-20140201:1.18
	cgen-snapshot-20140201:1.18
	sid-snapshot-20140101:1.18
	cgen-snapshot-20140101:1.18
	sid-snapshot-20131201:1.18
	cgen-snapshot-20131201:1.18
	sid-snapshot-20131101:1.18
	cgen-snapshot-20131101:1.18
	sid-snapshot-20131001:1.18
	cgen-snapshot-20131001:1.18
	sid-snapshot-20130901:1.18
	cgen-snapshot-20130901:1.18
	sid-snapshot-20130801:1.18
	cgen-snapshot-20130801:1.18
	sid-snapshot-20130701:1.18
	cgen-snapshot-20130701:1.18
	sid-snapshot-20130601:1.18
	cgen-snapshot-20130601:1.18
	sid-snapshot-20130501:1.18
	cgen-snapshot-20130501:1.18
	sid-snapshot-20130401:1.18
	cgen-snapshot-20130401:1.18
	sid-snapshot-20130301:1.18
	cgen-snapshot-20130301:1.18
	sid-snapshot-20130201:1.18
	cgen-snapshot-20130201:1.18
	sid-snapshot-20130101:1.18
	cgen-snapshot-20130101:1.18
	sid-snapshot-20121201:1.18
	cgen-snapshot-20121201:1.18
	sid-snapshot-20121101:1.18
	cgen-snapshot-20121101:1.18
	sid-snapshot-20121001:1.18
	cgen-snapshot-20121001:1.18
	sid-snapshot-20120901:1.18
	cgen-snapshot-20120901:1.18
	sid-snapshot-20120801:1.18
	cgen-snapshot-20120801:1.18
	sid-snapshot-20120701:1.18
	cgen-snapshot-20120701:1.18
	sid-snapshot-20120601:1.18
	cgen-snapshot-20120601:1.18
	sid-snapshot-20120501:1.18
	cgen-snapshot-20120501:1.18
	sid-snapshot-20120401:1.18
	cgen-snapshot-20120401:1.18
	sid-snapshot-20120301:1.18
	cgen-snapshot-20120301:1.18
	sid-snapshot-20120201:1.18
	cgen-snapshot-20120201:1.18
	sid-snapshot-20120101:1.18
	cgen-snapshot-20120101:1.18
	sid-snapshot-20111201:1.18
	cgen-snapshot-20111201:1.18
	sid-snapshot-20111101:1.18
	cgen-snapshot-20111101:1.18
	sid-snapshot-20111001:1.18
	cgen-snapshot-20111001:1.18
	sid-snapshot-20110901:1.18
	cgen-snapshot-20110901:1.18
	sid-snapshot-20110801:1.18
	cgen-snapshot-20110801:1.18
	sid-snapshot-20110701:1.18
	cgen-snapshot-20110701:1.18
	sid-snapshot-20110601:1.18
	cgen-snapshot-20110601:1.18
	sid-snapshot-20110501:1.18
	cgen-snapshot-20110501:1.18
	sid-snapshot-20110401:1.18
	cgen-snapshot-20110401:1.18
	sid-snapshot-20110301:1.18
	cgen-snapshot-20110301:1.18
	sid-snapshot-20110201:1.18
	cgen-snapshot-20110201:1.18
	sid-snapshot-20110101:1.18
	cgen-snapshot-20110101:1.18
	sid-snapshot-20101201:1.18
	cgen-snapshot-20101201:1.18
	sid-snapshot-20101101:1.18
	cgen-snapshot-20101101:1.18
	sid-snapshot-20101001:1.18
	cgen-snapshot-20101001:1.18
	sid-snapshot-20100901:1.18
	cgen-snapshot-20100901:1.18
	sid-snapshot-20100801:1.18
	cgen-snapshot-20100801:1.18
	sid-snapshot-20100701:1.18
	cgen-snapshot-20100701:1.18
	sid-snapshot-20100601:1.18
	cgen-snapshot-20100601:1.18
	sid-snapshot-20100501:1.18
	cgen-snapshot-20100501:1.18
	sid-snapshot-20100401:1.18
	cgen-snapshot-20100401:1.18
	sid-snapshot-20100301:1.18
	cgen-snapshot-20100301:1.18
	sid-snapshot-20100201:1.15
	cgen-snapshot-20100201:1.15
	sid-snapshot-20100101:1.15
	cgen-snapshot-20100101:1.15
	sid-snapshot-20091201:1.15
	cgen-snapshot-20091201:1.15
	sid-snapshot-20091101:1.13
	cgen-snapshot-20091101:1.13
	sid-snapshot-20091001:1.12
	cgen-snapshot-20091001:1.12
	arc-sim-20090309:1.4
	sid-snapshot-20090901:1.7
	cgen-snapshot-20090901:1.7
	sid-snapshot-20090801:1.7
	cgen-snapshot-20090801:1.7
	sid-snapshot-20090701:1.7
	cgen-snapshot-20090701:1.7
	dje-cgen-play1-branch:1.7.0.2
	dje-cgen-play1-branchpoint:1.7
	cgen-1_1-branch:1.4.0.6
	cgen-1_1-branchpoint:1.4
	sid-snapshot-20090601:1.4
	cgen-snapshot-20090601:1.4
	sid-snapshot-20090501:1.4
	cgen-snapshot-20090501:1.4
	sid-snapshot-20090401:1.4
	cgen-snapshot-20090401:1.4
	arc-insight_6_8-branch:1.4.0.4
	arc-insight_6_8-branchpoint:1.4
	sid-snapshot-20090301:1.4
	cgen-snapshot-20090301:1.4
	sid-snapshot-20090201:1.4
	cgen-snapshot-20090201:1.4
	sid-snapshot-20090101:1.4
	cgen-snapshot-20090101:1.4
	sid-snapshot-20081201:1.4
	cgen-snapshot-20081201:1.4
	sid-snapshot-20081101:1.4
	cgen-snapshot-20081101:1.4
	sid-snapshot-20081001:1.4
	cgen-snapshot-20081001:1.4
	sid-snapshot-20080901:1.4
	cgen-snapshot-20080901:1.4
	sid-snapshot-20080801:1.4
	cgen-snapshot-20080801:1.4
	sid-snapshot-20080701:1.4
	cgen-snapshot-20080701:1.4
	sid-snapshot-20080601:1.4
	cgen-snapshot-20080601:1.4
	sid-snapshot-20080501:1.4
	cgen-snapshot-20080501:1.4
	sid-snapshot-20080403:1.4
	sid-snapshot-20080401:1.4
	cgen-snapshot-20080401:1.4
	sid-snapshot-20080301:1.4
	cgen-snapshot-20080301:1.4
	sid-snapshot-20080201:1.4
	cgen-snapshot-20080201:1.4
	sid-snapshot-20080101:1.4
	cgen-snapshot-20080101:1.4
	sid-snapshot-20071201:1.4
	cgen-snapshot-20071201:1.4
	sid-snapshot-20071101:1.4
	cgen-snapshot-20071101:1.4
	sid-snapshot-20071001:1.4
	cgen-snapshot-20071001:1.4
	msnyder-fork-checkpoint-branch:1.4.0.2
	msnyder-fork-checkpoint-branchpoint:1.4
	sid-20020905-branchpoint:1.3
	sid-20020905-branch:1.3.0.6
	cagney_regbuf-20020515-branch:1.3.0.4
	cagney_regbuf-20020515-branchpoint:1.3
	cygnus_cvs_20020108_pre:1.3
	cgen-1-1-branch:1.3.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.18
date	2010.02.13.04.34.49;	author devans;	state Exp;
branches;
next	1.17;

1.17
date	2010.02.13.03.39.15;	author devans;	state Exp;
branches;
next	1.16;

1.16
date	2010.02.12.02.12.12;	author devans;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.23.09.03.00;	author devans;	state Exp;
branches;
next	1.14;

1.14
date	2009.11.03.07.03.35;	author devans;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.26.00.56.34;	author devans;	state Exp;
branches;
next	1.12;

1.12
date	2009.09.23.22.30.19;	author devans;	state Exp;
branches;
next	1.11;

1.11
date	2009.09.09.20.43.04;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2009.09.09.08.00.16;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.09.03.51.11;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2009.09.07.22.17.34;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.22.07.02.36;	author devans;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.22.05.14.09;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.16.05.35.47;	author devans;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	2001.05.07.17.55.20;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.22.19.14.30;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.4.6.1
date	2009.06.24.14.57.45;	author devans;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.18
log
@	* iformat.scm (/sfmt-search-key): Use iformat key instead of list
	of ifields.
@
text
@; Instruction formats.
; Copyright (C) 2000, 2009, 2010 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.

; Instruction formats are computed after the .cpu file has been read in.
; ??? May also wish to allow programmer to specify formats, but not sure this
; will complicate things more than it simplifies them, so it's defered.
;
; Two kinds of formats are defined here: iformat and sformat.
; (pronounced "I-format" and "S-format")
;
; Iformats are the instruction format as specified by the instructions' fields,
; and are the machine computed version of the generally known notion of an
; "instruction format".  No semantic information is attributed to iformats.
;
; Sformats are the same as iformats except that semantics are used to
; distinguish them.  For example, if an operand is refered to in one mode by
; one instruction and in a different mode by another instruction, then these
; two insns would have different sformats but the same iformat.  Sformats
; are used in simulator extraction code to collapse the number of cases that
; must be handled.  They can also be used to collapse the number of cases
; in the modeling code.
;
; The "base length" is the length of the insn that is initially fetched for
; decoding purposes.
; Formats are fixed in length.  For variable instruction length architectures
; there are separate formats for each insn's possible length.

(define <iformat>
  (class-make '<iformat>
	      '(<ident>)
		; From <ident>:
		; - NAME is derived from number, but we might have user
		;   specified formats someday [though I wouldn't add them
		;   without a clear need].
		; - COMMENT is the assembler syntax of an example insn that
		;   uses the format.
	      '(
		; Index into the iformat table.
		number

		; Sort key, used to determine insns with identical formats.
		key

		; List of <ifield> objects.
		ifields

		; min (insn-length, base-insn-size)
		mask-length

		; total length of insns with this format
		length

		; mask of base part
		mask

		; An example insn that uses the format.
		eg-insn
		)
	      nil)
)

; Accessor fns.

(define-getters <iformat> ifmt
  (number key ifields mask-length length mask eg-insn)
)

; Return enum cgen_fmt_type value for FMT.
; ??? Not currently used.

(define (ifmt-enum fmt)
  (string-append "@@CPU@@_" (string-upcase (gen-sym fmt)))
)

; Given FLD-LIST, compute the length of the insn in bits.
; This is done by adding up all the field sizes.
; All bits must be represent exactly once.

(define (compute-insn-length fld-list)
  (apply + (map ifld-length (ifields-base-ifields fld-list)))
)

; Given FLD-LIST, compute the base length in bits.
;
; For variable length instruction sets, or with cpus with multiple
; instruction sets, compute the base appropriate for this set of
; ifields.  Check that ifields are not shared among isas with
; inconsistent base insn lengths.
;
; ??? The algorithm here is a bit odd.  [Though there is value in verifying
; ifields are from consistent ISAs.]

(define (compute-insn-base-mask-length fld-list)
  (let* ((isa-base-bitsizes
	  (remove-duplicates
	   (map isa-base-insn-bitsize
		(map current-isa-lookup
		     (collect (lambda (ifld) 
				(atlist-attr-value (obj-atlist ifld) 'ISA #f))
			      fld-list))))))
    (if (= 1 (length isa-base-bitsizes))
	(min (car isa-base-bitsizes) (compute-insn-length fld-list))
	(error "ifields have inconsistent isa/base-insn-size values:" isa-base-bitsizes)))
)

; Given FLD-LIST, compute the bitmask of constant values in the base part
; of the insn (i.e. the opcode field).
;
; FIXME: Need to add support for constant fields appearing outside the base
; insn.  One way would be to record with each insn the value for each constant
; field.  That would allow code to straightforwardly fetch it.  Another would
; be to only record constant values appearing outside the base insn.
;
; See also (insn-value).
;
(define (compute-insn-base-mask fld-list)
  (let* ((mask-len (compute-insn-base-mask-length fld-list))
	 (lsb0? (ifld-lsb0? (car fld-list)))
	 (mask-bitrange (make <bitrange>
			      0 ; word-offset
			      (if lsb0? (- mask-len 1) 0) ; start
			      mask-len ; length
			      mask-len ; word-length
			      lsb0?)))
    (apply +
	   (map (lambda (fld) (ifld-mask fld mask-len mask-bitrange))
		; Find the fields that have constant values.
		(find ifld-constant? (ifields-base-ifields fld-list)))))
)

; Return the <iformat> search key for a sorted field list.
; This determines how iformats differ from each other.
; It also speeds up searching as the search key can be anything
; (though at present searching isn't as fast as it could be).
; INSN is passed so that we can include its sanytize attribute, if present,
; so sanytized sources work (needed formats don't disappear).

(define (/ifmt-search-key insn sorted-ifld-list)
  (string-map (lambda (ifld)
		(string-append " ("
			       (or (->string (obj-attr-value insn 'sanitize))
				   "-nosan-")
			       " "
			       (obj:str-name ifld)
			       " "
			       (ifld-ilk ifld)
			       ")"))
	      sorted-ifld-list)
)

; Create an <iformat> object for INSN.
; INDEX is the ordinal to assign to the result or -1 if unknown.
; SEARCH-KEY is the search key used to determine the iformat's uniqueness.
; IFLDS is a sorted list of INSN's ifields.

(define (ifmt-build insn index search-key iflds)
  (make <iformat>
    (symbol-append 'ifmt- (obj:name insn))
    (string-append "e.g. " (insn-syntax insn))
    atlist-empty
    index
    search-key
    iflds
    (compute-insn-base-mask-length iflds)
    (compute-insn-length iflds)
    (compute-insn-base-mask iflds)
    insn)
)

; Sformats.

(define <sformat>
  (class-make '<sformat>
	      '(<ident>)
	      ; From <ident>:
	      ; - NAME is derived from number.
	      ; - COMMENT is the assembler syntax of an example insn that
	      ;   uses the format.
	      '(
		; Index into the sformat table.
		number

		; Sort key, used to determine insns with identical formats.
		key

		; Non-#f if insns with this format are cti insns.
		cti?

		; IN-OPS is a list of input operands.
		; OUT-OPS is a list of output operands.
		; These are used to distinguish the format from others,
		; so that the extract and read operations can be based on the
		; sformat.
		; The extract fns use this data to record the necessary
		; information for profiling [which isn't necessarily a property
		; of the field list].  We could have one extraction function
		; per instruction, but there's a *lot* of duplicated code, and
		; the semantic operands rarely contribute to extra formats.
		; The parallel execution support uses this data to record the
		; input (or output) values based on the instruction format,
		; again cutting down on duplicated code.
		in-ops
		out-ops

		; Length of all insns with this format.
		; Since insns with different iformats can have the same sformat
		; we need to ensure ifield extraction works among the various
		; iformats.  We do this by ensuring all insns with the same
		; sformat have the same length.
		length

		; Cached list of all ifields used.
		; This can be derived from IN-OPS/OUT-OPS but is computed once
		; and cached here for speed.
		iflds

		; An example insn that uses the format.
		; This is used for debugging purposes, but also to help get
		; sanytization (spelled wrong on purpose) right.
		eg-insn

		; <sformat-argbuf> entry
		; FIXME: Temporary location, to be moved elsewhere
		(sbuf . #f)
		)
	      nil)
)

; Accessor fns.

(define-getters <sformat> sfmt
  (number key cti? in-ops out-ops length iflds eg-insn sbuf)
)

(define-setters <sformat> sfmt (sbuf))

(method-make-make! <sformat>
		   '(name comment attrs
		     number key cti? in-ops out-ops length iflds eg-insn)
)

; Return the <sformat> search key for a sorted field list and semantic
; operands.
; This determines how sformats differ from each other.
; It also speeds up searching as the search key can be anything
; (though at present searching isn't as fast as it could be).
;
; INSN is passed so that we can include its sanytize attribute, if present,
; so sanytized sources work (needed formats don't disappear).
; SORTED-USED-IFLDS is a sorted list of ifields used by SEM-{IN,OUT}-OPS.
; Note that it is not the complete set of ifields used by INSN.
;
; We assume INSN's <iformat> has been recorded.
;
; Note: It's important to minimize the number of created sformats.  It keeps
; the generated code smaller (and sometimes faster - more usable common
; fragments in pbb simulators).  Don't cause spurious differences.

(define (/sfmt-search-key insn cti? sorted-used-iflds sem-in-ops sem-out-ops)
  (assert (insn-ifmt insn))

  (let ((op-key (lambda (op)
		  (string-append " ("
				 (or (->string (obj-attr-value insn 'sanitize))
				     "-nosan-")
				 " "
				 (obj:str-name op)
				 ; ??? Including memory operands currently
				 ; isn't necessary and it can account for some
				 ; spurious differences.  On the other hand
				 ; leaving it out doesn't seem like the right
				 ; thing to do.
				 (if (memory? (op:type op))
				     ""
				     (string-append " "
						    (obj:str-name (op:mode op))))
				 ; CGEN_OPERAND_INSTANCE_COND_REF is stored
				 ; with the operand in the operand instance
				 ; table thus formats must be distinguished
				 ; by this.
				 (if (op:cond? op) " cond" "")
				 ")")))
	)
    (list
     ;; Use the iformat key so that each sformat maps to only one iformat.
     (if (= (length sorted-used-iflds) 0)
	 "no-used-ifields"
	 (ifmt-key (insn-ifmt insn)))
     cti?
     (string-map op-key
		 sem-in-ops)
     (string-map op-key
		 sem-out-ops)
     ))
)

; Create an <sformat> object for INSN.
; INDEX is the ordinal to assign to the result or -1 if unknown.
; SEARCH-KEY is the search key used to determine the sformat's uniqueness.
; {IN,OUT}-OPS are lists of INSN's input/output operands.
; SORTED-USED-IFLDS is a sorted list of ifields used by {IN,OUT}-OPS.
; Note that it is not the complete set of ifields used by INSN.
;
; We assume INSN's <iformat> has already been recorded.

(define (sfmt-build insn index search-key cti? in-ops out-ops sorted-used-iflds)
  (make <sformat>
    (symbol-append 'sfmt- (obj:name insn))
    (string-append "e.g. " (insn-syntax insn))
    atlist-empty
    index
    search-key
    cti?
    in-ops
    out-ops
    (insn-length insn)
    sorted-used-iflds
    insn)
)

; Sort IFLDS by dependencies and then by starting bit number.

(define (/sfmt-order-iflds iflds)
  (let ((up? 
	 ; ??? Something like this is preferable.
	 ;(not (ifld-lsb0? (car ifld-list)))
	 (not (current-arch-insn-lsb0?))))
    (let loop ((independent nil) (dependent nil) (iflds iflds))
      (cond ((null? iflds)
	     (append (sort-ifield-list independent up?)
		     (sort-ifield-list dependent up?)))
	    ; FIXME: quick hack.
	    ((multi-ifield? (car iflds))
	     (loop independent (cons (car iflds) dependent) (cdr iflds)))
	    (else
	     (loop (cons (car iflds) independent) dependent (cdr iflds))))))
)

; Return a sorted list of ifields used by IN-OPS, OUT-OPS.
; The ifields are sorted by dependencies and then by start bit.
; The important points are to help distinguish sformat's by the ifields used
; and to put ifields that others depend on first.

(define (/sfmt-used-iflds in-ops out-ops)
  (let ((in-iflds (map op-iflds-used in-ops))
	(out-iflds (map op-iflds-used out-ops)))
    (let ((all-iflds (nub (append (apply append in-iflds)
				  (apply append out-iflds))
			  obj:name)))
      (/sfmt-order-iflds all-iflds)))
)

; The format descriptor is used to sort formats.
; This is a utility class internal to this file.
; There is one instance per insn.

(define <fmt-desc>
  (class-make '<fmt-desc>
	      nil
	      '(
		; #t if insn is a cti insn
		cti?

		; sorted list of insn's ifields
		iflds

		; computed set of input/output operands
		in-ops out-ops

		; set of ifields used by IN-OPS,OUT-OPS.
		used-iflds

		; computed set of attributes
		attrs
		)
	      nil)
)

; Accessors.

(define-getters <fmt-desc> -fmt-desc
  (cti? iflds in-ops out-ops used-iflds attrs)
)

; Compute an iformat descriptor used to build an <iformat> object for INSN.
;
; If COMPUTE-SFORMAT? is #t compute the semantic format
; (same as instruction format except that operands are used to
; distinguish insns).
; Attributes derivable from the semantics are also computed.
; This is all done at the same time to minimize the number of times the
; semantic code is traversed.
; The semantics of INSN must already be canonicalized and stored in
; canonical-semantics.
;
; The result is (descriptor compiled-semantics attrs).
; `descriptor' and `compiled-semantics' are #f for insns with an empty
; field list.  This happens for virtual insns.
; `attrs' is an <attr-list> object of attributes derived from the semantics.
;
; ??? We never traverse the semantics of virtual insns.

(define (ifmt-analyze insn compute-sformat?)
  ; First sort by starting bit number the list of fields in INSN.
  (let ((sorted-ifields
	 (sort-ifield-list (insn-iflds insn)
			   ; ??? Something like this is preferable, but
			   ; if the first insn is a virtual insn there are
			   ; no fields.
			   ;(not (ifld-lsb0? (car (insn-iflds insn))))
			   (not (current-arch-insn-lsb0?))
			   )))

    (if (null? sorted-ifields)

	; Field list is unspecified.
	(list #f #f atlist-empty)

	(let* ((sem (insn-canonical-semantics insn))
	       ; Compute list of input and output operands if asked for.
	       (sem-ops (if compute-sformat?
			    (semantic-compile #f ; FIXME: context
					      insn sem)
			    (csem-make #f #f #f
				       (if sem
					   (semantic-attrs #f ; FIXME: context
							   insn sem)
					   atlist-empty)))))

	  (let ((compiled-sem (csem-code sem-ops))
		(in-ops (csem-inputs sem-ops))
		(out-ops (csem-outputs sem-ops))
		(attrs (csem-attrs sem-ops))
		(cti? (or (atlist-cti? (csem-attrs sem-ops))
			  (insn-cti-attr? insn))))

	    (list (make <fmt-desc>
		    cti? sorted-ifields in-ops out-ops
		    (if (and in-ops out-ops)
			(/sfmt-used-iflds in-ops out-ops)
			#f)
		    attrs)
		  compiled-sem
		  attrs)))))
)

; Subroutine of ifmt-compute!, to simplify it.
; Lookup INSN's iformat in IFMT-LIST and if not found add it.
; FMT-DESC is INSN's <fmt-desc> object.
; IFMT-LIST is append!'d to and the found iformat is stored in INSN.

(define (/ifmt-lookup-ifmt! insn fmt-desc ifmt-list)
  (let* ((search-key (/ifmt-search-key insn (-fmt-desc-iflds fmt-desc)))
	 (ifmt (find-first (lambda (elm)
			     (equal? (ifmt-key elm) search-key))
			   ifmt-list)))

    (if ifmt

	; Format was found, use it.
	(begin
	  (logit 3 "Using iformat " (number->string (ifmt-number ifmt)) ".\n")
	  (insn-set-ifmt! insn ifmt)
	  )

	; Format wasn't found, create new entry.
	(let* ((ifmt-index (length ifmt-list))
	       (ifmt (ifmt-build insn ifmt-index search-key
				 (ifields-base-ifields (-fmt-desc-iflds fmt-desc)))))
	  (logit 3 "Creating iformat " (number->string ifmt-index) ".\n")
	  (insn-set-ifmt! insn ifmt)
	  (append! ifmt-list (list ifmt))
	  )
	))

  *UNSPECIFIED*
)

; Subroutine of ifmt-compute!, to simplify it.
; Lookup INSN's sformat in SFMT-LIST and if not found add it.
; FMT-DESC is INSN's <fmt-desc> object.
; SFMT-LIST is append!'d to and the found sformat is stored in INSN.
;
; We assume INSN's <iformat> has already been recorded.

(define (/ifmt-lookup-sfmt! insn fmt-desc sfmt-list)
  (assert (insn-ifmt insn))

  (let* ((search-key (/sfmt-search-key insn (-fmt-desc-cti? fmt-desc)
				       (-fmt-desc-used-iflds fmt-desc)
				       (-fmt-desc-in-ops fmt-desc)
				       (-fmt-desc-out-ops fmt-desc)))
	 (sfmt (find-first (lambda (elm)
			     (equal? (sfmt-key elm) search-key))
			   sfmt-list)))

    (if sfmt

	; Format was found, use it.
	(begin
	  (logit 3 "Using sformat " (number->string (sfmt-number sfmt)) ".\n")
	  (insn-set-sfmt! insn sfmt)
	  )

	; Format wasn't found, create new entry.
	(let* ((sfmt-index (length sfmt-list))
	       (sfmt (sfmt-build insn sfmt-index search-key
				 (-fmt-desc-cti? fmt-desc)
				 (-fmt-desc-in-ops fmt-desc)
				 (-fmt-desc-out-ops fmt-desc)
				 (ifields-base-ifields (-fmt-desc-used-iflds fmt-desc)))))
	  (logit 3 "Creating sformat " (number->string sfmt-index) ".\n")
	  (insn-set-sfmt! insn sfmt)
	  (append! sfmt-list (list sfmt))
	  )
	))

  *UNSPECIFIED*
)

; Main entry point.

; Given a list of insns, compute the set of instruction formats, semantic
; formats, semantic attributes, and compiled semantics for each insn.
;
; The computed <iformat> object is stored in the `ifmt' field of each insn.
;
; Attributes derived from the semantic code are added to the insn's attributes,
; but they don't override any prespecified values.
;
; If COMPUTE-SFORMAT? is #t, the computed <sformat> object is stored in the
; `sfmt' field of each insn, and the processed semantic code is stored in the
; `compiled-semantics' field of each insn.
;
; The `fmt-desc' field of each insn is used to store an <fmt-desc> object
; which contains the search keys, sorted field list, input-operands, and
; output-operands, and is not used outside this procedure.
;
; The result is a list of two lists: the set of computed iformats, and the
; set of computed sformats.
;
; *** This is the most expensive calculation in CGEN.   ***
; *** (mainly because of the detailed semantic parsing) ***

(define (ifmt-compute! insn-list compute-sformat?)
  (logit 2 "Computing instruction formats and analyzing semantics ...\n")

  ; First analyze each insn, storing the result in fmt-desc.
  ; If asked to, convert the semantic code to a compiled form to simplify more
  ; intelligent processing of it later.

  (for-each (lambda (insn)
	      (logit 2 "Scanning operands of " (obj:name insn) ": "
		     (insn-syntax insn) " ...\n")
	      (let ((sem-ops (ifmt-analyze insn compute-sformat?)))
		(insn-set-fmt-desc! insn (car sem-ops))
		(if (and compute-sformat? (cadr sem-ops))
		    (let ((compiled-sem (cadr sem-ops)))
		      (insn-set-compiled-semantics! insn compiled-sem)))
		(obj-set-atlist! insn
				 (atlist-append (obj-atlist insn)
						(caddr sem-ops)))
		))
	    insn-list)

  ; Now for each insn, look up the ifield list in the format table (and if not
  ; found add it), and set the ifmt/sfmt elements of the insn.

  (let* ((empty-ifmt (make <iformat>
			  'ifmt-empty
			  "empty iformat for unspecified field list"
			  atlist-empty ; attrs
			  -1 ; number
			  #f ; key
			  nil ; fields
			  0 ; mask-length
			  0 ; length
			  0 ; mask
			  #f)) ; eg-insn
	 (empty-sfmt (make <sformat>
			  'sfmt-empty
			  "empty sformat for unspecified field list"
			  atlist-empty ; attrs
			  -1 ; number
			  #f ; key
			  #f ; cti?
			  nil ; sem-in-ops
			  nil ; sem-out-ops
			  0 ; length
			  nil ; used iflds
			  #f)) ; eg-insn
	 (ifmt-list (list empty-ifmt))
	 (sfmt-list (list empty-sfmt))
	 )

    (for-each (lambda (insn)
		(logit 2 "Processing format for " (obj:name insn) ": "
		       (insn-syntax insn) " ...\n")

		(let ((fmt-desc (insn-fmt-desc insn)))

		  (if fmt-desc

		      (begin
			; Must compute <iformat> before <sformat>, the latter
			; needs the former.
			(/ifmt-lookup-ifmt! insn fmt-desc ifmt-list)
			(if compute-sformat?
			    (/ifmt-lookup-sfmt! insn fmt-desc sfmt-list)))

		      ; No field list present, use empty format.
		      (begin
			(insn-set-ifmt! insn empty-ifmt)
			(if compute-sformat?
			    (insn-set-sfmt! insn empty-sfmt))))))

	      (non-multi-insns insn-list))

    ; Done.  Return the computed iformat and sformat lists.
    (list ifmt-list sfmt-list)
    )
)
@


1.17
log
@update copyright year
@
text
@d287 4
a291 4
     (insn-length insn)
     (string-map (lambda (ifld)
		   (string-append " (" (obj:str-name ifld) " " (ifld-ilk ifld) ")"))
		 sorted-used-iflds)
@


1.16
log
@	* desc-cpu.scm (/gen-cpu-open): Remove comment on K&R support.
	* utils-cgen.scm (gen-define-with-symcat): Remove K&R support.

	* utils-sim.scm (compute-sformat-argbufs!): Use more consistent name
	for name of empty sbuf.

	* iformat.scm (/sfmt-search-key, /ifmt-lookup-sfmt!): Add assert.

	* insn.scm (<insn>): Add initial value for members fmt-desc, ifmt,
	sfmt, tmp.
	(/sub-insn-ifields): Delete old commented out code.
	(/sub-insn-make!, /parse-insn-format-symbol): Ditto.
	* operand.scm (/anyof-merge-setter, anyof-merge-semantics): Ditto.

	* sim-decode.scm (/gen-decode-insn-globals): Tweak formatting of
	generated code.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2009 Red Hat, Inc.
@


1.15
log
@	* hardware.scm (hw-pc?): New function.
	* ifield.scm (ifld-signed?): New function.
	* iformat.scm (ifmt-analyze): Call insn-cti-attr? instead of insn-cti?.
	* insn.scm (insn-cti-attr?): Renamed from insn-ctl?.
	(insn-cti?): New function.
	* rtl.scm (/hw): Create <pc> object for pcs.
	* semantics.scm (/build-reg-operand!): New args ref-type, sem-attrs.
	All callers updated.  Watch for sets to the pc.
	(semantic-attrs): Watch for sets to the pc.
	* sid.scm (<pc> cxmake-get): Handle raw-reg.
	* sim.scm (<pc> cxmake-get): Handle raw-reg.
	(<operand> cxmake-get): Add debugging printf.
	* utils-gen.scm (/gen-ifld-extract-base): Emit calls to
	EXTRACT_[LM]SB0_LG[SU]INT for values > 32 bits.
	(/gen-extract-word): Ditto.

	* utils.scm (gen-c-hex-constant): New function.
	* utils-sim.scm (/gen-decode-insn-entry): Call it.
@
text
@d262 2
d489 2
@


1.14
log
@comment tweaks
@
text
@d435 1
a435 1
			  (insn-cti? insn))))
@


1.13
log
@	Record bitset attributes internally as a list.
	Record rtx attribute values internally as ((rtx-expr)).
	* attr.scm (bitset-attr?): Delete, unused.
	(<bitset-attribute> parse-value): Rewrite.
	(/attr-parse): Rewrite bitset default value processing.
	(/attr-read): Pick out values of scalar attributes to distinguish
	them from bitset values which are a list.
	Fix spelling errors for processing of default values.
	Handle string attributes.
	(bitset-attr->list): Delete, all callers updated.
	(/bitset-attr->charmask): Renamed from bitset-attr->charmask.
	All callers updated.
	(atlist-source-form): Rewrite.
	* hardware.scm (<hardware-base> 'get-isas): Update recognition
	of all isas.
	(hardware-builtin!): Update spec of ISA attribute, (ISA foo,bar)
	-> (ISA foo bar).
	* intrinsics.scm (target:belongs-to-group?): Update, bitset attribute
	values are now lists.
	* mach.scm (def-isa-attr!): Update, bitset attribute values,
	including the default, are now lists.
	(all-isas-attr-value): Result is now a list.
	* doc/rtl.texi: Clean up pass over attribute docs.
@
text
@d393 2
a394 2
; The semantics of INSN must already be compiled and stored in
; compiled-semantics.
d396 3
a398 3
; The result is (descriptor attrs).
; `descriptor' is #f for insns with an empty field list
; (this happens for virtual insns).
@


1.12
log
@	* xc16x.cpu (h-cr): New hardware.
	(muls): Comment out parts that won't compile, add fixme.
	(mulu, divl, divlu, jmpabs, jmpa-, jmprel, jbc, jnbs, callr): Ditto.
	(scxti, scxtmg, scxtm, bclear, bclr18, bset19, bitset, bmov): Ditto.
	(bmovn, band, bor, bxor, bcmp, bfldl, bfldh): Ditto.

	Rewrite rtl processing to require it to be "canonicalized" first,
	and write a full canonicalizer / expression checker.
	Remove all appearances of DFLT in canonical rtl.
	* attr.scm (/attr-eval atval owner): Call rtx-canonicalize,
	then rtx-simplify.
	* iformat.scm (ifmt-analyze) Use canonical semantics.
	* insn (<insn>): New member canonical-semantics.
	* mach.scm (<arch>): New member multi-insns-instantiated?.
	(/instantiate-multi-insns!): New function.
	(/canonicalize-insns!): New function.
	(arch-analyze-insns!): Canonicalize insn semantics before processing
	them.
	* mode.scm (/mode-set-word-params!): New function.
	(mode-void?): New function.
	(mode-compatible?): VOID is compatible with VOID.
	(/mode-word-sizes-defined?): New global.
	(mode-set-word-modes!): Use/set it.
	(mode-ensure-word-sizes-defined): Update.
	(mode-builtin!): New builtin "modes" SYM, INSN, MACH.
	Redo WI/UWI/AI/IAI handling.
	(op:new-mode): No longer accept DFLT.
	(<derived-operand> constructor): Ensure all fields are initialized.
	(<anyof-operand> constructor): Ditto.
	(/derived-parse-ifield-assertion): Delete arg `args'.
	All callers updated.
	* rtl-c.scm (<rtl-c-eval-state>): New member `for-insn?'.
	(rtl-c): Call rtx-canonicalize instead of rtx-compile.
	(rtl-c-expr, rtl-c++): Ditto.
	(/rtl-c-get): Use mode of operand, not containing expression.
	(rtl-c-set-quiet, rtl-c-set-trace): Remove DFLT support.
	(/rtx-use-sem-fn?): Don't check for (insn? owner), check
	estate-for-insn? instead.
	(s-unop): Use mode of expression, not first operand.
	(s-binop, s-binop-with-bit, s-shop, s-cmpop): Ditto.
	(s-sequence): Remove DFLT support.
	(ifield): Use mode of expression, not UINT.
	(pc): Comment out, unused.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	(set, set-quiet): Pass src to rtl-c-set-{trace,quiet} for expansion.
	* rtl-traverse.scm (/rtx-canon-debug?): New global.
	(/make-cstate): New function.
	(/cstate-context, /cstate-outer-expr): New functions.
	(/rtx-canon-error): New function.
	(/rtx-lookup-hw, /rtx-pick-mode, /rtx-pick-mode3, /rtx-pick-op-mode,
	/rtx-get-last-cond-case-rtx): New functions.
	(/rtx-canon-*): New functions.
	(/rtx-canner-table, /rtx-operand-canoners): New globals.
	(/rtx-make-canon-table, /rtx-special-expr-canoners): New functions.
	(/rtx-option, /rtx-option-list?): Rewrite.
	(rtx-munge-mode&options): Replaces /rtx-munge-mode&options.
	Rewritten, all callers updated.
	(/rtx-canon-expr, /rtx-canon): New functions.
	(rtx-canonicalize): Move here from rtl-xform.scm and rewrite.
	(rtx-canonicalize-stmt): New function.
	(tstate-make): Remove arg `set?'.  All callers updated.
	(tstate-new-set?): Delete.
	(/rtx-traverse-options, /rtx-traverse-*mode): Delete,
	moved to /rtx-canon-*.
	(/rtx-traverse-normal-operand): New function.
	(/rtx-traverse-rtx-list): Delete arg `mode', all callers updated.
	(/rtx-traverse-rtx, /rtx-traverse-setrtx,, /rtx-traverse-testrtx,
	/rtx-traverse-condrtx, /rtx-traverse-casertx, /rtx-traverse-locals,
	/rtx-traverse-iteration, /rtx-traverse-env, /rtx-traverse-attrs):
	Ditto.
	(/rtx-traverse-symbol, /rtx-traverse-string, /rtx-traverse-number,
	/rtx-traverse-symornum, /rtx-traverse-object): Delete.
	(/rtx-make-traverser-table): Update.
	(/rtx-traverse-operands): Remove mode processing, now done during
	canonicalization.
	(/rtx-traverse-expr): Delete arg `mode', all callers updated.
	(/rtx-traverse): Ditto.
	(rtx-init-traverser-tables!): New function.
	* rtl-xform (/rtx-verify-no-dflt-modes-expr-fn): New function.
	(rtx-verify-no-dflt-modes): New function.
	(/rtx-simplify-expr-fn): Update, `arg' mode deleted.
	(rtx-simplify-insn): Use insn-canonical-semantics.
	(rtx-canonicalize): Moved to rtl-traverse.scm.
	(/compile-expr-fn, rtx-compile): Delete.
	(/rtx-trim-rtx-list): New function.
	(/rtx-trim-for-doc): Handle set, if.
	* rtl.scm (<rtx-func>): New members result-mode, matchexpr-index.
	(/rtx-valid-mode-types): Update.
	(/rtx-valid-matches): Update.
	(/rtx-find-matchexpr-index): New function.
	(rtx-lookup): Require rtx-kind to be the rtx name.
	(def-rtx-node): New arg result-mode, all callers updated.
	(def-rtx-syntax-node, def-rtx-operand-node): Ditto.
	(rtx-lazy-sem-mode): Delete.
	(/rtx-closure-make): New arg `mode', all callers updated.
	(rtx-make-ifield, rtx-make-operand, rtx-make-local): Ditto.
	(rtx-operand-obj): Rewrite.
	(rtx-make-xop): New functions.
	(/hw): Renamed from `hw', all callers updated.
	Use the correct mode instead of DFLT for the index.
	(rtl-builtin!): Call rtx-init-traversal-tables!.
	(rtl-finish!): Update.
	* rtx-funcs.scm (all rtx functions): New parameter: result-mode.
	Update mode arg-type.
	(pc): Comment out.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	* sem-frags.scm (/frag-hash-compute!): Update, mode arg deleted.
	(/frag-cost-compute!): Ditto.
	* semantics.scm (/build-operand!): Delete args op-name, op.
	New arg op-expr.  All callers updated.
	(/build-mem-operand!): Remove DFLT support.
	(semantic-compile): Update process-expr!, mode arg deleted.
	* sid-cpu.scm (gen-semantic-code): Specify #:for-insn? in
	rtl-c++ calls.
	(/gen-sem-case, /gen-sfrag-code): Ditto.
	* sid.scm (/op-gen-set-trace1): Renamed from /op-gen-set-trace.
	(/op-gen-set-trace): New function.  If not doing profiling,
	call /op-gen-set-quiet.
	* sim-cpu.scm (gen-semantic-code): Specify #:for-insn? in rtl-c calls.
	* utils-gen.scm (/gen-ifld-extract-base): Update call to rtl-c.
	(/gen-ifld-extract-beyond, gen-multi-ifld-extract): Ditto.
	* utils.scm (find-first-index): New function.
	* doc/rtl.texi: Delete docs for `attr'.  Add `int-attr'.
@
text
@d101 1
a101 1
				(bitset-attr->list (atlist-attr-value (obj-atlist ifld) 'ISA #f)))
@


1.11
log
@	Add support for controlling warnings/errors.
	Add tests for iformat description errors.
	* dev.scm (cload): New option #:diag.
	* read.scm (<reader>): New member verify-iformat?.
	(/parse-diagnostic, parse-warning): New functions.
	(parse-error): Guts moved to /parse-diagnostic.
	(/set-diagnostic-options!): New function.
	(cpu-load): New arg diagnostic-options, all callers updated.
	Recognize -w diagnostic-option-list.
	* ifield.scm (ifields-base-ifields): Move here from iformat.scm.
	(ifld-simple-ifields, ifields-simple-ifields): New function.
	* insn.scm (/parse-insn-format-iflds): New function.
	(/parse-insn-format): Guts moved to /parse-insn-format-iflds.
	New arg isa, all callers updated.  Do some basic validation of the
	ifield list if requested.
	* mach.scm (/sanity-check-insns): Improve error message text.
	* doc/running.text: Document -w option.

	* ifield.scm (/multi-ifield-parse): Initialize bitrange.
@
text
@d387 2
a388 2
; If COMPUTE-SFORMAT? is #t compile the semantics and compute the semantic
; format (same as instruction format except that operands are used to
d393 2
d396 1
a396 1
; The result is (descriptor compiled-semantics attrs).
a398 1
; `compiled-semantics' is #f if COMPUTE-SFORMAT? is #f.
d419 1
a419 2
	; FIXME: error checking (e.g. missing or overlapping bits)
	(let* ((sem (insn-semantics insn))
d428 2
a429 2
					   atlist-empty))))
	       )
d436 1
@


1.10
log
@	* ifield.scm (ifld-beyond-base?): Remove args base-bitsize,
	total-bitsize.  All callers updated.
	* insn.scm (<insn>): Rename member ifld-values to /insn-value.
	New member /insn-base-value.
	(insn-base-value): New function.
	* mach.scm (/sanity-check-insns): New function.
	(arch-analyze-insns!): Call it.
@
text
@a69 7
; Traverse the ifield list to collect all base (non-derived) ifields
; used in it.

(define (ifields-base-ifields ifld-list)
  (collect ifld-base-ifields ifld-list)
)

d550 1
a550 1
	      (logit 3 "Scanning operands of " (obj:name insn) ": "
d594 1
a594 1
		(logit 3 "Processing format for " (obj:name insn) ": "
@


1.9
log
@	* iformat.scm (ifields-base-ifields): Simplify.
	(compute-insn-length): Simplify, call ifields-base-ifields.
	(compute-insn-base-mask): Ditto.
	* ifield.scm (ifld-known-values): Ditto.
	(ifld-base-ifields): Ditto.
	* insn.scm (insn-value): Ditto.
	* pgmr-tools.scm (pgmr-pretty-print-insn-format): Ditto.
@
text
@d98 3
@


1.8
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d70 3
a72 1
; Traverse the ifield list to collect all base (non-derived) ifields used in it.
d74 1
a74 3
  (collect (lambda (ifld)
	     (ifld-base-ifields ifld))
	   ifld-list)
d89 1
a89 1
  (apply + (map ifld-length (collect ifld-base-ifields fld-list)))
d134 1
a134 3
		(find ifld-constant? (collect ifld-base-ifields fld-list)))
	   )
    )
@


1.7
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d146 1
a146 1
(define (-ifmt-search-key insn sorted-ifld-list)
d267 1
a267 1
(define (-sfmt-search-key insn cti? sorted-used-iflds sem-in-ops sem-out-ops)
d329 1
a329 1
(define (-sfmt-order-iflds iflds)
d350 1
a350 1
(define (-sfmt-used-iflds in-ops out-ops)
d356 1
a356 1
      (-sfmt-order-iflds all-iflds)))
d445 1
a445 1
			(-sfmt-used-iflds in-ops out-ops)
d457 2
a458 2
(define (-ifmt-lookup-ifmt! insn fmt-desc ifmt-list)
  (let* ((search-key (-ifmt-search-key insn (-fmt-desc-iflds fmt-desc)))
d491 2
a492 2
(define (-ifmt-lookup-sfmt! insn fmt-desc sfmt-list)
  (let* ((search-key (-sfmt-search-key insn (-fmt-desc-cti? fmt-desc)
d610 1
a610 1
			(-ifmt-lookup-ifmt! insn fmt-desc ifmt-list)
d612 1
a612 1
			    (-ifmt-lookup-sfmt! insn fmt-desc sfmt-list)))
@


1.6
log
@	* rtl-xform.scm (rtx-simplify-insn): New function.
	* html.scm (gen-insn-docs): Call it.
	* sem-frags.scm (sem-find-common-frags, -frag-test-data): Ditto.
	* iformat.scm (ifmt-analyze): Minor simplification.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
@


1.5
log
@	* semantics.scm (semantic-compile): Change arg sem-code-list to
	sem-code.
	(semantic-attrs): Ditto.
	* iformat.scm (ifmt-analyze): Update.
	(ifmt-compute!): Update.
	* rtl-traverse.scm (-compile-expr-fn, rtx-compile): Move to
	rtl-xform.scm.
	(-rtx-trim-args, -rtx-trim-for-doc, rtx-trim-for-doc): Ditto.
	* rtl.scm (-rtx-canonicalize-expr, rtx-canonicalize): Ditto.
	* semantics.scm (rtx-simplify): Ditto.
	(rtx-const-equal, rtx-const-list-equal): Ditto, and make local.
	(rtx-simplify-eq-attr-mach, rtx-simplify-eq-attr-insn): Ditto.
	(-simplify-expr-fn): Move to rtl-xform.scm.
	(-solve-expr-fn, rtx-solve): Ditto.
	* rtl-xform.c: New file.
	* read.scm: Load it.
@
text
@d425 1
a425 2
	(let* (; A list of the various bits of semantic code.
	       (sem (insn-semantics insn))
d431 1
a431 1
				       (if (insn-semantics insn)
@


1.4
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@d426 1
a426 1
	       (sems (list (insn-semantics insn)))
d430 1
a430 1
					      insn sems)
d434 1
a434 1
							   insn sems)
d437 1
a437 1
	  (let ((compiled-sems (csem-code sem-ops))
d449 1
a449 1
		  compiled-sems
d562 2
a563 2
		    (let ((compiled-sems (cadr sem-ops)))
		      (insn-set-compiled-semantics! insn (car compiled-sems))))
@


1.4.6.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2009 Red Hat, Inc.
@


1.3
log
@* cgen asm/disasm

[opcodes/ChangeLog]
2001-05-07  Frank Ch. Eigler  <fche@@redhat.com>

        * cgen-dis.in (default_print_insn): Tolerate min<base instructions
        even at end of a section.
        * cgen-ibld.in (extract_normal): Tolerate min!=base!=max instructions
        by ignoring precariously-unpacked insn_value in favor of raw buffer.

[cgen/ChangeLog]
2001-05-07  Frank Ch. Eigler  <fche@@redhat.com>

        * iformat.scm (compute-insn-base-mask-length): Rewrite to tolerate
        various-base-length instruction sets.
@
text
@d149 1
a149 1
			       (or (obj-attr-value insn 'sanitize)
d152 1
a152 1
			       (obj:name ifld)
d270 1
a270 1
				 (or (obj-attr-value insn 'sanitize)
d273 1
a273 1
				 (obj:name op)
d282 1
a282 1
						    (obj:name (op:mode op))))
d294 1
a294 1
		   (string-append " (" (obj:name ifld) " " (ifld-ilk ifld) ")"))
@


1.2
log
@* snapshot of work toward more complete support of derived-operands

2000-08-22  Frank Ch. Eigler  <fche@@redhat.com>

	* Makefile.in (DIST_COMMON): Regenerated.
	* ifield.scm (derived-ifield needed-iflds): New method.
	* iformat.scm (-ifmt-lookup-sfmt!): Use base ifields for
	sfmts built from derived-ifields.
	* operand.scm (-derived-parse-encoding): Give derived-ifield a fixed
	type symbol 'derived-ifield, not an unparseable string.
	* utils-sim.scm (op-needed-iflds) Handler 'derived-ifield case.
	(-sfmt-contents): Add tracing.

	From Doug Evans <dje@@transmeta.com>:
	* sim.scm (operand cxmake-get): Result is a <c-expr>, not a string of
	C code.
@
text
@d93 5
a97 2
; Computing the min of state-base-insn-bitsize and the total-length
; is for [V]LIW instruction sets.
d100 10
a109 1
  (min (state-base-insn-bitsize) (compute-insn-length fld-list))
@


1.1
log
@Initial revision
@
text
@d503 1
a503 1
				 (-fmt-desc-used-iflds fmt-desc))))
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
