head	1.12;
access;
symbols
	sid-snapshot-20180601:1.12
	cgen-snapshot-20180601:1.12
	sid-snapshot-20180501:1.12
	cgen-snapshot-20180501:1.12
	sid-snapshot-20180401:1.12
	cgen-snapshot-20180401:1.12
	sid-snapshot-20180301:1.12
	cgen-snapshot-20180301:1.12
	sid-snapshot-20180201:1.12
	cgen-snapshot-20180201:1.12
	sid-snapshot-20180101:1.12
	cgen-snapshot-20180101:1.12
	sid-snapshot-20171201:1.12
	cgen-snapshot-20171201:1.12
	sid-snapshot-20171101:1.12
	cgen-snapshot-20171101:1.12
	sid-snapshot-20171001:1.12
	cgen-snapshot-20171001:1.12
	sid-snapshot-20170901:1.12
	cgen-snapshot-20170901:1.12
	sid-snapshot-20170801:1.12
	cgen-snapshot-20170801:1.12
	sid-snapshot-20170701:1.12
	cgen-snapshot-20170701:1.12
	sid-snapshot-20170601:1.12
	cgen-snapshot-20170601:1.12
	sid-snapshot-20170501:1.12
	cgen-snapshot-20170501:1.12
	sid-snapshot-20170401:1.12
	cgen-snapshot-20170401:1.12
	sid-snapshot-20170301:1.12
	cgen-snapshot-20170301:1.12
	sid-snapshot-20170201:1.12
	cgen-snapshot-20170201:1.12
	sid-snapshot-20170101:1.12
	cgen-snapshot-20170101:1.12
	sid-snapshot-20161201:1.12
	cgen-snapshot-20161201:1.12
	sid-snapshot-20161101:1.12
	cgen-snapshot-20161101:1.12
	sid-snapshot-20160901:1.12
	cgen-snapshot-20160901:1.12
	sid-snapshot-20160801:1.12
	cgen-snapshot-20160801:1.12
	sid-snapshot-20160701:1.12
	cgen-snapshot-20160701:1.12
	sid-snapshot-20160601:1.12
	cgen-snapshot-20160601:1.12
	sid-snapshot-20160501:1.12
	cgen-snapshot-20160501:1.12
	sid-snapshot-20160401:1.12
	cgen-snapshot-20160401:1.12
	sid-snapshot-20160301:1.12
	cgen-snapshot-20160301:1.12
	sid-snapshot-20160201:1.12
	cgen-snapshot-20160201:1.12
	sid-snapshot-20160101:1.12
	cgen-snapshot-20160101:1.12
	sid-snapshot-20151201:1.12
	cgen-snapshot-20151201:1.12
	sid-snapshot-20151101:1.12
	cgen-snapshot-20151101:1.12
	sid-snapshot-20151001:1.12
	cgen-snapshot-20151001:1.12
	sid-snapshot-20150901:1.12
	cgen-snapshot-20150901:1.12
	sid-snapshot-20150801:1.12
	cgen-snapshot-20150801:1.12
	sid-snapshot-20150701:1.12
	cgen-snapshot-20150701:1.12
	sid-snapshot-20150601:1.12
	cgen-snapshot-20150601:1.12
	sid-snapshot-20150501:1.12
	cgen-snapshot-20150501:1.12
	sid-snapshot-20150401:1.12
	cgen-snapshot-20150401:1.12
	sid-snapshot-20150301:1.12
	cgen-snapshot-20150301:1.12
	sid-snapshot-20150201:1.12
	cgen-snapshot-20150201:1.12
	sid-snapshot-20150101:1.12
	cgen-snapshot-20150101:1.12
	sid-snapshot-20141201:1.12
	cgen-snapshot-20141201:1.12
	sid-snapshot-20141101:1.12
	cgen-snapshot-20141101:1.12
	sid-snapshot-20141001:1.12
	cgen-snapshot-20141001:1.12
	sid-snapshot-20140901:1.12
	cgen-snapshot-20140901:1.12
	sid-snapshot-20140801:1.12
	cgen-snapshot-20140801:1.12
	sid-snapshot-20140701:1.12
	cgen-snapshot-20140701:1.12
	sid-snapshot-20140601:1.12
	cgen-snapshot-20140601:1.12
	sid-snapshot-20140501:1.12
	cgen-snapshot-20140501:1.12
	sid-snapshot-20140401:1.12
	cgen-snapshot-20140401:1.12
	sid-snapshot-20140301:1.12
	cgen-snapshot-20140301:1.12
	sid-snapshot-20140201:1.12
	cgen-snapshot-20140201:1.12
	sid-snapshot-20140101:1.12
	cgen-snapshot-20140101:1.12
	sid-snapshot-20131201:1.12
	cgen-snapshot-20131201:1.12
	sid-snapshot-20131101:1.12
	cgen-snapshot-20131101:1.12
	sid-snapshot-20131001:1.12
	cgen-snapshot-20131001:1.12
	sid-snapshot-20130901:1.12
	cgen-snapshot-20130901:1.12
	sid-snapshot-20130801:1.12
	cgen-snapshot-20130801:1.12
	sid-snapshot-20130701:1.12
	cgen-snapshot-20130701:1.12
	sid-snapshot-20130601:1.12
	cgen-snapshot-20130601:1.12
	sid-snapshot-20130501:1.12
	cgen-snapshot-20130501:1.12
	sid-snapshot-20130401:1.12
	cgen-snapshot-20130401:1.12
	sid-snapshot-20130301:1.12
	cgen-snapshot-20130301:1.12
	sid-snapshot-20130201:1.12
	cgen-snapshot-20130201:1.12
	sid-snapshot-20130101:1.12
	cgen-snapshot-20130101:1.12
	sid-snapshot-20121201:1.12
	cgen-snapshot-20121201:1.12
	sid-snapshot-20121101:1.12
	cgen-snapshot-20121101:1.12
	sid-snapshot-20121001:1.12
	cgen-snapshot-20121001:1.12
	sid-snapshot-20120901:1.12
	cgen-snapshot-20120901:1.12
	sid-snapshot-20120801:1.12
	cgen-snapshot-20120801:1.12
	sid-snapshot-20120701:1.12
	cgen-snapshot-20120701:1.12
	sid-snapshot-20120601:1.12
	cgen-snapshot-20120601:1.12
	sid-snapshot-20120501:1.12
	cgen-snapshot-20120501:1.12
	sid-snapshot-20120401:1.12
	cgen-snapshot-20120401:1.12
	sid-snapshot-20120301:1.12
	cgen-snapshot-20120301:1.12
	sid-snapshot-20120201:1.12
	cgen-snapshot-20120201:1.12
	sid-snapshot-20120101:1.12
	cgen-snapshot-20120101:1.12
	sid-snapshot-20111201:1.12
	cgen-snapshot-20111201:1.12
	sid-snapshot-20111101:1.12
	cgen-snapshot-20111101:1.12
	sid-snapshot-20111001:1.12
	cgen-snapshot-20111001:1.12
	sid-snapshot-20110901:1.12
	cgen-snapshot-20110901:1.12
	sid-snapshot-20110801:1.12
	cgen-snapshot-20110801:1.12
	sid-snapshot-20110701:1.12
	cgen-snapshot-20110701:1.12
	sid-snapshot-20110601:1.12
	cgen-snapshot-20110601:1.12
	sid-snapshot-20110501:1.12
	cgen-snapshot-20110501:1.12
	sid-snapshot-20110401:1.12
	cgen-snapshot-20110401:1.12
	sid-snapshot-20110301:1.12
	cgen-snapshot-20110301:1.12
	sid-snapshot-20110201:1.12
	cgen-snapshot-20110201:1.12
	sid-snapshot-20110101:1.12
	cgen-snapshot-20110101:1.12
	sid-snapshot-20101201:1.12
	cgen-snapshot-20101201:1.12
	sid-snapshot-20101101:1.12
	cgen-snapshot-20101101:1.12
	sid-snapshot-20101001:1.12
	cgen-snapshot-20101001:1.12
	sid-snapshot-20100901:1.12
	cgen-snapshot-20100901:1.12
	sid-snapshot-20100801:1.12
	cgen-snapshot-20100801:1.12
	sid-snapshot-20100701:1.12
	cgen-snapshot-20100701:1.12
	sid-snapshot-20100601:1.12
	cgen-snapshot-20100601:1.12
	sid-snapshot-20100501:1.12
	cgen-snapshot-20100501:1.12
	sid-snapshot-20100401:1.12
	cgen-snapshot-20100401:1.12
	sid-snapshot-20100301:1.12
	cgen-snapshot-20100301:1.12
	sid-snapshot-20100201:1.12
	cgen-snapshot-20100201:1.12
	sid-snapshot-20100101:1.11
	cgen-snapshot-20100101:1.11
	sid-snapshot-20091201:1.11
	cgen-snapshot-20091201:1.11
	sid-snapshot-20091101:1.8
	cgen-snapshot-20091101:1.8
	sid-snapshot-20091001:1.8
	cgen-snapshot-20091001:1.8
	sid-snapshot-20090901:1.3
	cgen-snapshot-20090901:1.3
	sid-snapshot-20090801:1.2
	cgen-snapshot-20090801:1.2
	sid-snapshot-20090701:1.2
	cgen-snapshot-20090701:1.2
	dje-cgen-play1-branch:1.2.0.2
	dje-cgen-play1-branchpoint:1.2;
locks; strict;
comment	@# @;


1.12
date	2010.01.21.07.34.56;	author devans;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.12.16.05.29;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.03.16.24.02;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.01.22.53.32;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2009.09.23.22.30.19;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2009.09.12.17.34.15;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	2009.09.10.06.23.24;	author devans;	state Exp;
branches;
next	1.5;

1.5
date	2009.09.09.22.21.11;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.07.22.17.34;	author devans;	state Exp;
branches;
next	1.3;

1.3
date	2009.08.27.05.47.12;	author devans;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.22.07.02.36;	author devans;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.22.05.14.09;	author devans;	state Exp;
branches;
next	;


desc
@@


1.12
log
@	* rtl-traverse.scm (/rtx-canon-anycexprmode): New function.
	(/rtx-make-canon-table): Add entry for ANYCEXPRMODE.
	(/rtx-canon-operands): Print expr-mode if /rtx-canon-debug?
	Do final error check on mode assigned to expression.
	(/rtx-make-traverser-table): Add entry for ANYCEXPRMODE.
	* rtl-xform.scm (/rtx-trim-args): Handle ANYCEXPRMODE.
	* rtl.scm (/rtx-valid-mode-types): Add ANYCEXPRMODE.
	* rtx-funcs.scm (c-code, c-call, c-raw-call): Use ANYCEXPRMODE.
	(if, cond, case): Use ANYEXPRMODE.
@
text
@;; Various RTL transformations.
;;
;; Copyright (C) 2000, 2009, 2010 Red Hat, Inc.
;; This file is part of CGEN.
;; See file COPYING.CGEN for details.
;;
;; In particular:
;; rtx-simplify
;; rtx-solve
;; rtx-trim-for-doc

;; Utility to verify there are no DFLT modes present in EXPR

;; Subroutine of rtx-verify-no-dflt-modes to simplify it.
;; This is the EXPR-FN argument to rtl-traverse.

(define (/rtx-verify-no-dflt-modes-expr-fn rtx-obj expr parent-expr op-pos
					   tstate appstuff)
  (if (eq? (rtx-mode expr) 'DFLT)
      (tstate-error tstate "DFLT mode present" expr))

  ;; Leave EXPR unchanged and continue.
  #f
)

;; Entry point.  Verify there are no DFLT modes in EXPR.

(define (rtx-verify-no-dflt-modes context expr)
  (rtx-traverse context #f expr /rtx-verify-no-dflt-modes-expr-fn #f)
)

;; rtx-simplify (and supporting cast)

; Subroutine of /rtx-simplify-expr-fn to compare two values for equality.
; If both are constants and they're equal return #f/#t.
; INVERT? = #f -> return #t if equal, #t -> return #f if equal.
; Returns 'unknown if either argument is not a constant.

(define (/rtx-const-equal arg0 arg1 invert?)
  (if (and (rtx-constant? arg0)
	   (rtx-constant? arg1))
      (if invert?
	  (!= (rtx-constant-value arg0)
	      (rtx-constant-value arg1))
	  (= (rtx-constant-value arg0)
	     (rtx-constant-value arg1)))
      'unknown)
)

; Subroutine of /rtx-simplify-expr-fn to see if MAYBE-CONST is
; an element of NUMBER-LIST.
; NUMBER-LIST is a `number-list' rtx.
; INVERT? is #t if looking for non-membership.
; #f/#t is only returned for definitive answers.
; If INVERT? is #f:
; - return #f if MAYBE-CONST is not in NUMBER-LIST
; - return #t if MAYBE-CONST is in NUMBER-LIST and it has only one member
; - return 'member if MAYBE-CONST is in NUMBER-LIST and it has many members
; - otherwise return 'unknown
; If INVERT? is #t:
; - return #t if MAYBE-CONST is not in NUMBER-LIST
; - return #f if MAYBE-CONST is in NUMBER-LIST and it has only one member
; - return 'member if MAYBE-CONST is in NUMBER-LIST and it has many members
; - otherwise return 'unknown

(define (/rtx-const-list-equal maybe-const number-list invert?)
  (assert (rtx-kind? 'number-list number-list))
  (if (rtx-constant? maybe-const)
      (let ((values (rtx-number-list-values number-list)))
	(if invert?
	    (if (memq (rtx-constant-value maybe-const) values)
		(if (= (length values) 1)
		    #f
		    'member)
		#t)
	    (if (memq (rtx-constant-value maybe-const) values)
		(if (= (length values) 1)
		    #t
		    'member)
		#f)))
      'unknown)
)

; Subroutine of /rtx-simplify-expr-fn to simplify an eq-attr of (current-mach).
; CONTEXT is a <context> object or #f if there is none.

(define (/rtx-simplify-eq-attr-mach rtx context)
  (let ((attr (rtx-eq-attr-attr rtx))
	(value (rtx-eq-attr-value rtx)))
    ; If all currently selected machs will yield the same value
    ; for the attribute, we can simplify.
    (let ((values (map (lambda (m)
			 (obj-attr-value m attr))
		       (current-mach-list))))
      ; Ensure at least one mach is selected.
      (if (null? values)
	  (context-error context
			 "While simplifying rtl"
			 "no machs selected"
			 (rtx-strdump rtx)))
      ; All values equal to the first one?
      (if (all-true? (map (lambda (val)
			    (equal? val (car values)))
			  values))
	  (if (equal? value
		      ; Convert internal boolean attribute value
		      ; #f/#t to external value FALSE/TRUE.
		      ; FIXME:revisit.
		      (case (car values)
			((#f) 'FALSE)
			((#t) 'TRUE)
			(else (car values))))
	      (rtx-true)
	      (rtx-false))
	  ; couldn't simplify
	  rtx)))
)

; Subroutine of /rtx-simplify-expr-fn to simplify an eq-attr of (current-insn).

(define (/rtx-simplify-eq-attr-insn rtx insn context)
  (let ((attr (rtx-eq-attr-attr rtx))
	(value (rtx-eq-attr-value rtx)))
    (if (not (insn? insn))
	(context-error context
		       "While simplifying rtl"
		       "No current insn for `(current-insn)'"
		       (rtx-strdump rtx)))
    (let ((attr-value (obj-attr-value insn attr)))
      (if (eq? value attr-value)
	  (rtx-true)
	  (rtx-false))))
)

; Subroutine of rtx-simplify.
; This is the EXPR-FN argument to rtx-traverse.

(define (/rtx-simplify-expr-fn rtx-obj expr parent-expr op-pos
			       tstate appstuff)

  ;(display "Processing ") (display (rtx-dump expr)) (newline)

  (case (rtx-name expr)

    ((not)
     (let* ((arg (/rtx-traverse (rtx-alu-op-arg expr 0)
				'RTX expr 1 tstate appstuff))
	    (no-side-effects? (not (rtx-side-effects? arg))))
       (cond ((and no-side-effects? (rtx-false? arg))
	      (rtx-true))
	     ((and no-side-effects? (rtx-true? arg))
	      (rtx-false))
	     (else (rtx-make 'not (rtx-alu-op-mode expr) arg)))))

    ((orif)
     (let ((arg0 (/rtx-traverse (rtx-boolif-op-arg expr 0)
				'RTX expr 0 tstate appstuff))
	   (arg1 (/rtx-traverse (rtx-boolif-op-arg expr 1)
				'RTX expr 1 tstate appstuff)))
       (let ((no-side-effects-0? (not (rtx-side-effects? arg0)))
	     (no-side-effects-1? (not (rtx-side-effects? arg1))))
	 (cond ((and no-side-effects-0? (rtx-true? arg0))
		(rtx-true))
	       ((and no-side-effects-0? (rtx-false? arg0))
		(rtx-canonical-bool arg1))
	       ; Value of arg0 is unknown or has side-effects.
	       ((and no-side-effects-1? (rtx-true? arg1))
		(if no-side-effects-0?
		    (rtx-true)
		    (rtx-make 'orif arg0 (rtx-true))))
	       ((and no-side-effects-1? (rtx-false? arg1))
		arg0)
	       (else
		(rtx-make 'orif arg0 arg1))))))

    ((andif)
     (let ((arg0 (/rtx-traverse (rtx-boolif-op-arg expr 0)
				'RTX expr 0 tstate appstuff))
	   (arg1 (/rtx-traverse (rtx-boolif-op-arg expr 1)
				'RTX expr 1 tstate appstuff)))
       (let ((no-side-effects-0? (not (rtx-side-effects? arg0)))
	     (no-side-effects-1? (not (rtx-side-effects? arg1))))
	 (cond ((and no-side-effects-0? (rtx-false? arg0))
		(rtx-false))
	       ((and no-side-effects-0? (rtx-true? arg0))
		(rtx-canonical-bool arg1))
	       ; Value of arg0 is unknown or has side-effects.
	       ((and no-side-effects-1? (rtx-false? arg1))
		(if no-side-effects-0?
		    (rtx-false)
		    (rtx-make 'andif arg0 (rtx-false))))
	       ((and no-side-effects-1? (rtx-true? arg1))
		arg0)
	       (else
		(rtx-make 'andif arg0 arg1))))))

    ; Fold if's to their then or else part if we can determine the
    ; result of the test.
    ((if)
     (let ((test
	    ; ??? Was this but that calls rtx-traverse again which
	    ; resets the temp stack!
	    ; (rtx-simplify context (caddr expr))))
	    (/rtx-traverse (rtx-if-test expr) 'RTX expr 1 tstate appstuff)))
       (cond ((rtx-true? test)
	      (/rtx-traverse (rtx-if-then expr) 'RTX expr 2 tstate appstuff))
	     ((rtx-false? test)
	      (if (rtx-if-else expr)
		  (/rtx-traverse (rtx-if-else expr) 'RTX expr 3 tstate appstuff)
		  ; Sanity check, mode must be VOID.
		  ; FIXME: DFLT can no longer appear
		  (if (or (mode:eq? 'DFLT (rtx-mode expr))
			  (mode:eq? 'VOID (rtx-mode expr)))
		      (rtx-make 'nop 'VOID)
		      (error "rtx-simplify: non-void-mode `if' missing `else' part" expr))))
	     ; Can't simplify.
	     ; We could traverse the then/else clauses here, but it's simpler
	     ; to have our caller do it (by returning #f).
	     ; The cost is retraversing `test'.
	     (else #f))))

    ((eq ne)
     (let ((name (rtx-name expr))
	   (cmp-mode (rtx-cmp-op-mode expr))
	   (arg0 (/rtx-traverse (rtx-cmp-op-arg expr 0) 'RTX
				expr 1 tstate appstuff))
	   (arg1 (/rtx-traverse (rtx-cmp-op-arg expr 1) 'RTX
				expr 2 tstate appstuff)))
       (if (or (rtx-side-effects? arg0) (rtx-side-effects? arg1))
	   (rtx-make name cmp-mode arg0 arg1)
	   (case (/rtx-const-equal arg0 arg1 (rtx-kind? 'ne expr))
	     ((#f) (rtx-false))
	     ((#t) (rtx-true))
	     (else
	      ; That didn't work.  See if we have an ifield/operand with a
	      ; known range of values.  We don't need to check for a known
	      ; single value, that is handled below.
	      (case (rtx-name arg0)
		((ifield)
		 (let ((known-val (tstate-known-lookup tstate
						       (rtx-ifield-name arg0))))
		   (if (and known-val (rtx-kind? 'number-list known-val))
		       (case (/rtx-const-list-equal arg1 known-val
						    (rtx-kind? 'ne expr))
			 ((#f) (rtx-false))
			 ((#t) (rtx-true))
			 (else
			  (rtx-make name cmp-mode arg0 arg1)))
		       (rtx-make name cmp-mode arg0 arg1))))
		((operand)
		 (let ((known-val (tstate-known-lookup tstate
						       (rtx-operand-name arg0))))
		   (if (and known-val (rtx-kind? 'number-list known-val))
		       (case (/rtx-const-list-equal arg1 known-val
						    (rtx-kind? 'ne expr))
			 ((#f) (rtx-false))
			 ((#t) (rtx-true))
			 (else
			  (rtx-make name cmp-mode arg0 arg1)))
		       (rtx-make name cmp-mode arg0 arg1))))
		(else
		 (rtx-make name cmp-mode arg0 arg1))))))))

    ; Recognize attribute requests of current-insn, current-mach.
    ((eq-attr)
     (cond ((rtx-kind? 'current-mach (rtx-eq-attr-owner expr))
	    (/rtx-simplify-eq-attr-mach expr (tstate-context tstate)))
	   ((rtx-kind? 'current-insn (rtx-eq-attr-owner expr))
	    (/rtx-simplify-eq-attr-insn expr (tstate-owner tstate) (tstate-context tstate)))
	   (else expr)))

    ((ifield)
     (let ((known-val (tstate-known-lookup tstate (rtx-ifield-name expr))))
       ; If the value is a single number, return that.
       ; It can be one of several, represented as a number list.
       (if (and known-val (rtx-constant? known-val))
	   known-val ; (rtx-make 'const 'INT known-val)
	   #f)))

    ((operand)
     (let ((known-val (tstate-known-lookup tstate (rtx-operand-name expr))))
       ; If the value is a single number, return that.
       ; It can be one of several, represented as a number list.
       (if (and known-val (rtx-constant? known-val))
	   known-val ; (rtx-make 'const 'INT known-val)
	   #f)))

    ((closure)
     (let ((simplified-expr (/rtx-traverse (rtx-closure-expr expr)
					   'RTX expr 2 tstate appstuff)))
       simplified-expr))

    ; Leave EXPR unchanged and continue.
    (else #f))
)

; Simplify an rtl expression.
;
; EXPR must be in canonical source form.
; The result is a possibly simplified EXPR, still in source form.
;
; CONTEXT is a <context> object or #f, used for error messages.
; OWNER is the owner of the expression (e.g. <insn>) or #f if there is none.
;
; KNOWN is an alist of known values.  Each element is (name . value) where
; NAME is an ifield/operand name and VALUE is a const/number-list rtx.
; FIXME: Need ranges, later.
;
; The following operations are performed:
; - unselected machine dependent code is removed (eq-attr of (current-mach))
; - if's are reduced to either then/else if we can determine that the test is
;   a compile-time constant
; - orif/andif
; - eq/ne
; - not
;
; ??? Will become more intelligent as needed.

(define (rtx-simplify context owner expr known)
  (/rtx-traverse expr #f #f 0
		 (tstate-make context owner
			      /rtx-simplify-expr-fn
			      #f ;; ok since EXPR is fully canonical
			      (rtx-env-empty-stack)
			      #f known 0)
		 #f)
)

;; Return an insn's semantics simplified.
;; CONTEXT is a <context> object or #f, used for error messages.

(define (rtx-simplify-insn context insn)
  (rtx-simplify context insn (insn-canonical-semantics insn)
		(insn-build-known-values insn))
)

;; rtx-solve (and supporting cast)

; Utilities for equation solving.
; ??? At the moment this is only focused on ifield assertions.
; ??? That there exist more sophisticated versions than this one can take
; as a given.  This works for the task at hand and will evolve or be replaced
; as necessary.
; ??? This makes the simplifying assumption that no expr has side-effects.

; Subroutine of rtx-solve.
; This is the EXPR-FN argument to rtx-traverse.

(define (/solve-expr-fn rtx-obj expr parent-expr op-pos tstate appstuff)
  #f ; wip
)

; Return a boolean indicating if {expr} equates to "true".
; If the expression can't be reduced to #f/#t, return '?.
; ??? Use rtx-eval instead of rtx-traverse?
;
; EXPR must be in source form.
; CONTEXT is a <context> object, used for error messages.
; OWNER is the owner of the expression (e.g. <insn>) or #f if there is none.
; KNOWN is an alist of known values.  Each element is (name . value) where
; NAME is an ifield/operand name and VALUE is a const/number-list rtx.
; FIXME: Need ranges, later.
;
; This is akin to rtx-simplify except it's geared towards solving ifield
; assertions.  It's not unreasonable to combine them.  The worry is the
; efficiency lost.
; ??? Will become more intelligent as needed.

(define (rtx-solve context owner expr known)
  ; First simplify, then solve.
  (let* ((simplified-expr (rtx-simplify context owner expr known))
	 (maybe-solved-expr
	  simplified-expr) ; FIXME: for now
;	  (/rtx-traverse simplified-expr #f #f 0
;			 (tstate-make context owner
;				      /solve-expr-fn
;				      #f (rtx-env-empty-stack)
;				      #f known 0)
;			 #f))
	 )
    (cond ((rtx-true? maybe-solved-expr) #t)
	  ((rtx-false? maybe-solved-expr) #f)
	  (else '?)))
)

;; rtx-trim-for-doc (and supporting cast)
;; RTX trimming (removing fluff not normally needed for the human viewer).

;; Subroutine of /rtx-trim-args to simplify it.
;; Trim a list of rtxes.

(define (/rtx-trim-rtx-list rtx-list)
  (map /rtx-rtim-for-doc rtx-list)
)

; Subroutine of /rtx-trim-for-doc to simplify it.
; Trim the arguments of rtx NAME.
; ARGS has already had options,mode removed.

(define (/rtx-trim-args name args)
  (logit 4 "Trimming args of " name ": " args "\n")
  (let* ((rtx-obj (rtx-lookup name))
	 (arg-types (rtx-arg-types rtx-obj)))

    (let loop ((args args)
	       (types (cddr arg-types)) ; skip options, mode
	       (result nil))

      (if (null? args)

	  (reverse! result)

	  (let ((arg (car args))
		; Remember, types may be an improper list.
		(type (if (pair? types) (car types) types))
		(new-arg (car args)))

	    ;(display arg (current-error-port)) (newline (current-error-port))
	    ;(display type (current-error-port)) (newline (current-error-port))

	    (case type
	      ((OPTIONS)
	       (assert #f)) ; shouldn't get here

	      ((ANYINTMODE ANYFLOATMODE ANYNUMMODE ANYEXPRMODE ANYCEXPRMODE
		EXPLNUMMODE VOIDORNUMMODE VOIDMODE BIMODE INTMODE
		SYMMODE INSNMODE MACHMODE)
	       #f) ; leave arg untouched

	      ((RTX SETRTX TESTRTX)
	       (set! new-arg (/rtx-trim-for-doc arg)))

	      ((CONDRTX)
	       (assert (= (length arg) 2))
	       (if (eq? (car arg) 'else)
		   (set! new-arg (cons 'else (/rtx-trim-for-doc (cadr arg))))
		   (set! new-arg (list (/rtx-trim-for-doc (car arg))
				       (/rtx-trim-for-doc (cadr arg)))))
	       )

	      ((CASERTX)
	       (assert (= (length arg) 2))
	       (set! new-arg (list (car arg) (/rtx-trim-for-doc (cadr arg))))
	       )

	      ((LOCALS)
	       #f) ; leave arg untouched

	      ((ITERATION SYMBOLLIST ENVSTACK)
	       #f) ; leave arg untouched for now

	      ((ATTRS)
	       #f) ; leave arg untouched for now

	      ((SYMBOL STRING NUMBER SYMORNUM)
	       #f) ; leave arg untouched

	      ((OBJECT)
	       (assert #f)) ; hopefully(wip!) shouldn't get here

	      (else
	       (assert #f))) ; unknown arg type

	    (loop (cdr args)
		  (if (pair? types) (cdr types) types)
		  (cons new-arg result))))))
)

; Given a canonical rtl expression, usually the result of rtx-simplify,
; remove bits unnecessary for documentation purposes.
; Canonical rtl too verbose for docs.
; Examples of things to remove:
; - empty options list
; - ifield/operand/local/const wrappers
; - modes of operations that don't need them to convey meaning
;
; NOTE: While having to trim the result of rtx-simplify may seem ironic,
; it isn't.  You need to keep separate the notions of simplifying "1+1" to "2"
; and trimming the clutter from "(const () BI 0)" yielding "0".

(define (/rtx-trim-for-doc rtx)
  (if (pair? rtx) ; ??? cheap rtx?

      (let ((name (car rtx))
	    (options (cadr rtx))
	    (mode (caddr rtx))
	    (rest (cdddr rtx)))

	(case name

	  ((const ifield operand local)
	   (if (null? options)
	       (car rest)
	       rtx))

	  ((set set-quiet)
	   (let ((trimmed-args (/rtx-trim-args name rest)))
	     (if (null? options)
		 (cons name trimmed-args)
		 (cons name (cons options (cons mode trimmed-args))))))

	  ((eq ne lt le gt ge ltu leu gtu geu index-of)
	   (let ((trimmed-args (/rtx-trim-args name rest)))
	     (if (null? options)
		 (cons name trimmed-args)
		 (cons name (cons options (cons mode trimmed-args))))))

	  ((if)
	   (let ((trimmed-args (/rtx-trim-args name rest)))
	     (if (null? options)
		 (if (eq? mode 'VOID)
		     (cons name trimmed-args)
		     (cons name (cons mode trimmed-args)))
		 (cons name (cons options (cons mode trimmed-args))))))

	  ((sequence parallel)
	   ; No special support is needed, except it's nice to remove nop
	   ; statements.  These can be created when an `if' get simplified.
	   (let ((trimmed-args (/rtx-trim-args name rest))
		 (result nil))
	     (for-each (lambda (rtx)
			 (if (equal? rtx '(nop))
			     #f ; ignore
			     (set! result (cons rtx result))))
		       trimmed-args)
	     (if (null? options)
		 (if (eq? mode 'VOID)
		     (cons name (reverse result))
		     (cons name (cons mode (reverse result))))
		 (cons name (cons options (cons mode (reverse result)))))))

	  ((nop)
	   (list 'nop))

	  ((closure)
	   ;; Remove outer closures, they are artificially added, and are
	   ;; basically noise to the human trying to understand the semantics.
	   ;; ??? Since we currently can't distinguish outer closures,
	   ;; just remove them all.
	   (let ((trimmed-expr (/rtx-trim-for-doc (rtx-closure-expr rtx))))
	     (if (and (null? options) (null? (rtx-closure-env-stack rtx)))
		 trimmed-expr
		 (rtx-make 'closure options mode
			   (rtx-closure-isas rtx)
			   (rtx-closure-env-stack rtx)
			   trimmed-expr))))

	  (else
	   (let ((trimmed-args (/rtx-trim-args name rest)))
	     (if (null? options)
		 (if (eq? mode 'DFLT) ;; FIXME: DFLT can no longer appear
		     (cons name trimmed-args)
		     (cons name (cons mode trimmed-args)))
		 (cons name (cons options (cons mode trimmed-args))))))))

      ; Not an rtx expression, must be number, symbol, string.
      rtx)
)

(define (rtx-trim-for-doc rtx)
  (/rtx-trim-for-doc rtx)
)
@


1.11
log
@	* rtl-c.scm (s-parallel): Use map-in-order instead of map.
	* rtl-xform.scm (/rtx-trim-for-doc): Handle set-quiet, nop,
	eq, ne, lt, le, gt, ge, ltu, leu, gtu, geu, index-of.
@
text
@d3 1
a3 1
;; Copyright (C) 2000, 2009 Red Hat, Inc.
d425 2
a426 2
	      ((ANYINTMODE ANYFLOATMODE ANYNUMMODE ANYEXPRMODE EXPLNUMMODE
		VOIDORNUMMODE VOIDMODE BIMODE INTMODE
@


1.10
log
@	Specify isa(s) when doing ifield, operand, insn lookups.
	ACU = all callers updated.
	* attr.scm (/attr-eval): Call rtx-value instead of rtx-eval-with-estate.
	* enum.scm (define-full-insn-enum): Pass isa-name-list to
	current-ifld-lookup.
	* html.scm (get-insn-properties): Pass isa-name-list to
	current-op-lookup.
	* ifield.scm (/ifld-parse-follows): New arg isas, ACU.
	* insn.scm (/parse-insn-format-symbol): New arg isa-name-list, ACU.
	(/parse-insn-format-list, /parse-insn-iformat-iflds): Ditto.
	(/parse-insn-format, syntax-break-out): Ditto.
	* mach.scm (obj-filter-by-isa): New function.
	(current-ifld-lookup): New optional arg maybe-isa-name-list.
	(/ifld-already-defined?, /op-already-defined?): Simplify.
	(current-op-lookup): New optional arg maybe-isa-name-list.
	(current-insn-lookup): New arg isa-name-list, ACU.
	(/insn-already-defined?, /minsn-already-defined?): Simplify.
	(current-minsn-lookup): New arg isa-name-list, ACU.
	* minsn.scm (/minsn-compute-iflds): Pass isa-name-list to
	current-op-lookup.
	* opc-itab.scm (compute-syntax): New arg isa-name-list, ACU.
	(gen-syntax-entry): Ditto.
	* operand.scm (/operand-parse): Pass isa-name-list to
	current-ifld-lookup.
	(/derived-parse-encoding): New arg isa-name-list, ACU.
	(/derived-parse-ifield-assertion): Ditto.
	(/derived-operand-parse): Pass isa-name-list to current-op-lookup.
	(/anyof-parse-choice): Ditto.
	(anyof-satisfies-assertions?): Pass context to rtx-solve.
	(/anyof-merge-syntax): New arg container, ACU.
	(operand-builtin!): Add pc to all isas.
	* rtl-c.scm (estate-make-for-rtl-c): Delete arg extra-vars-alist, ACU.
	(estate-make-for-rtl-c++, rtl-c-expr-parsed): Ditto.
	(rtl-c-parsed, rtl-c++-parsed): Ditto.
	(rtl-c): New arg isa-name-list, ACU.
	(rtl-c-expr, rtl-c++): Ditto.
	(closure): New arg isa-name-list, ACU.
	* rtl-traverse.scm (/make-cstate): New arg isa-name-list, ACU.
	(/cstate-isas): New function.
	(/rtx-canon-symbol-list): New function.
	(/rtx-canon-env-stack): Renamed from /rtx-canon-env, ACU.
	updated.
	(/rtx-make-canon-table): Rename ENV to ENVSTACK, new entry SYMBOLLIST.
	(/rtx-canon-rtx-operand): Pass isa list to current-op-lookup.
	(/rtx-canon-rtx-ref, /rtx-canon): Ditto.
	(rtx-canonicalize): New arg isa-name-list, ACU.
	(rtx-canonicalize-stmt): Delete.
	(tstate-make): New arg isas, ACU.
	(tstate-isas, tstate--set-isas!): New functions.
	(tstate-env-stack): Renamed from tstate-env, ACU.
	(tstate-set-env-stack!): Renamed from tstate-set-env!, ACU.
	(tstate-make-closure): Renamed from tstate-new-env, new arg
	isa-name-list, ACU.
	(/rtx-traverse-env): Delete.
	(/rtx-make-traverser-table): Rename ENV to ENVSTACK, new entry
	SUMBOLLIST.
	(/rtx-traverse): Include conditional flag in dump output.
	Update isa,envstack for closures.  Pass isa list to current-op-lookup.
	(<eval-state>): New member isas.  Rename env to env-stack.
	(<eval-state> vmake!): Handle #:isas.  #:env renamed to #:env-stack.
	(<eval-state>): New getter/setter for isas.  Rename env getter/setter
	to env-stack.
	(estate-make-for-eval): Provide #:isas.
	(estate-make-closure): Renamed from estate-new-env.  New arg
	isa-name-list, ACU.
	* rtl-xform.scm (/rtx-simplify-expr-fn): Handle closures.
	(/rtx-trim-args): ENV renamed to ENVSTACK.  Ad ITERATION, SYMBOLLIST.
	(/rtx-trim-for-doc): Handle closures.
	* rtl.scm (/rtx-valid-types): Rename ENV to ENVSTACK.  Add ITERATION,
	SYMBOLLIST.
	(rtx-env-var-list): Delete.
	(rtx-env-make): Handle already-compiled environments.
	(rtx-var-alist-to-env): New function.
	(rtx-var-alist-to-closure-env-stack, rtx-make-env-stack): New functions.
	(rtx-env-stack-dump): Renamed from rtx-env-dump, ACU.
	(rtx-operand-obj): New arg isa-name-list, ACU.
	(rtx-closure-isas, rtx-closure-env-stack, rtx-closure-expr): New
	functions.
	* rtx-funcs.scm (closure): New arg isa-name-list, reorder args, ACU.
	* sem-frags.scm (<sfrag>): Delete member compiled-semantics.
	(/frag-compute-desired-frags): Minor simplification.
	(/frag-pick-best): Ditto.
	* sid-cpu.scm (gen-semantic-code): Require canonical rtl.
	(/gen-sfrag-code): Update.
	* sim-cpu.scm (gen-semantic-code): Require canonical rtl.
	* utils-cgen.scm (sanitize): New arg isa-name-list, ACU.
	* utils.scm (non-null-intersection?): New function.
@
text
@d397 2
a398 1
; Trim all the arguments of rtx NAME.
d401 1
d475 1
d496 7
a502 1
	  ((set)
d532 3
@


1.9
log
@minor spelling tweak
@
text
@d288 5
d323 1
d377 1
a377 1
;				      (rtx-env-empty-stack)
d447 1
a447 1
	      ((ENV)
d480 1
d523 13
@


1.8
log
@	* xc16x.cpu (h-cr): New hardware.
	(muls): Comment out parts that won't compile, add fixme.
	(mulu, divl, divlu, jmpabs, jmpa-, jmprel, jbc, jnbs, callr): Ditto.
	(scxti, scxtmg, scxtm, bclear, bclr18, bset19, bitset, bmov): Ditto.
	(bmovn, band, bor, bxor, bcmp, bfldl, bfldh): Ditto.

	Rewrite rtl processing to require it to be "canonicalized" first,
	and write a full canonicalizer / expression checker.
	Remove all appearances of DFLT in canonical rtl.
	* attr.scm (/attr-eval atval owner): Call rtx-canonicalize,
	then rtx-simplify.
	* iformat.scm (ifmt-analyze) Use canonical semantics.
	* insn (<insn>): New member canonical-semantics.
	* mach.scm (<arch>): New member multi-insns-instantiated?.
	(/instantiate-multi-insns!): New function.
	(/canonicalize-insns!): New function.
	(arch-analyze-insns!): Canonicalize insn semantics before processing
	them.
	* mode.scm (/mode-set-word-params!): New function.
	(mode-void?): New function.
	(mode-compatible?): VOID is compatible with VOID.
	(/mode-word-sizes-defined?): New global.
	(mode-set-word-modes!): Use/set it.
	(mode-ensure-word-sizes-defined): Update.
	(mode-builtin!): New builtin "modes" SYM, INSN, MACH.
	Redo WI/UWI/AI/IAI handling.
	(op:new-mode): No longer accept DFLT.
	(<derived-operand> constructor): Ensure all fields are initialized.
	(<anyof-operand> constructor): Ditto.
	(/derived-parse-ifield-assertion): Delete arg `args'.
	All callers updated.
	* rtl-c.scm (<rtl-c-eval-state>): New member `for-insn?'.
	(rtl-c): Call rtx-canonicalize instead of rtx-compile.
	(rtl-c-expr, rtl-c++): Ditto.
	(/rtl-c-get): Use mode of operand, not containing expression.
	(rtl-c-set-quiet, rtl-c-set-trace): Remove DFLT support.
	(/rtx-use-sem-fn?): Don't check for (insn? owner), check
	estate-for-insn? instead.
	(s-unop): Use mode of expression, not first operand.
	(s-binop, s-binop-with-bit, s-shop, s-cmpop): Ditto.
	(s-sequence): Remove DFLT support.
	(ifield): Use mode of expression, not UINT.
	(pc): Comment out, unused.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	(set, set-quiet): Pass src to rtl-c-set-{trace,quiet} for expansion.
	* rtl-traverse.scm (/rtx-canon-debug?): New global.
	(/make-cstate): New function.
	(/cstate-context, /cstate-outer-expr): New functions.
	(/rtx-canon-error): New function.
	(/rtx-lookup-hw, /rtx-pick-mode, /rtx-pick-mode3, /rtx-pick-op-mode,
	/rtx-get-last-cond-case-rtx): New functions.
	(/rtx-canon-*): New functions.
	(/rtx-canner-table, /rtx-operand-canoners): New globals.
	(/rtx-make-canon-table, /rtx-special-expr-canoners): New functions.
	(/rtx-option, /rtx-option-list?): Rewrite.
	(rtx-munge-mode&options): Replaces /rtx-munge-mode&options.
	Rewritten, all callers updated.
	(/rtx-canon-expr, /rtx-canon): New functions.
	(rtx-canonicalize): Move here from rtl-xform.scm and rewrite.
	(rtx-canonicalize-stmt): New function.
	(tstate-make): Remove arg `set?'.  All callers updated.
	(tstate-new-set?): Delete.
	(/rtx-traverse-options, /rtx-traverse-*mode): Delete,
	moved to /rtx-canon-*.
	(/rtx-traverse-normal-operand): New function.
	(/rtx-traverse-rtx-list): Delete arg `mode', all callers updated.
	(/rtx-traverse-rtx, /rtx-traverse-setrtx,, /rtx-traverse-testrtx,
	/rtx-traverse-condrtx, /rtx-traverse-casertx, /rtx-traverse-locals,
	/rtx-traverse-iteration, /rtx-traverse-env, /rtx-traverse-attrs):
	Ditto.
	(/rtx-traverse-symbol, /rtx-traverse-string, /rtx-traverse-number,
	/rtx-traverse-symornum, /rtx-traverse-object): Delete.
	(/rtx-make-traverser-table): Update.
	(/rtx-traverse-operands): Remove mode processing, now done during
	canonicalization.
	(/rtx-traverse-expr): Delete arg `mode', all callers updated.
	(/rtx-traverse): Ditto.
	(rtx-init-traverser-tables!): New function.
	* rtl-xform (/rtx-verify-no-dflt-modes-expr-fn): New function.
	(rtx-verify-no-dflt-modes): New function.
	(/rtx-simplify-expr-fn): Update, `arg' mode deleted.
	(rtx-simplify-insn): Use insn-canonical-semantics.
	(rtx-canonicalize): Moved to rtl-traverse.scm.
	(/compile-expr-fn, rtx-compile): Delete.
	(/rtx-trim-rtx-list): New function.
	(/rtx-trim-for-doc): Handle set, if.
	* rtl.scm (<rtx-func>): New members result-mode, matchexpr-index.
	(/rtx-valid-mode-types): Update.
	(/rtx-valid-matches): Update.
	(/rtx-find-matchexpr-index): New function.
	(rtx-lookup): Require rtx-kind to be the rtx name.
	(def-rtx-node): New arg result-mode, all callers updated.
	(def-rtx-syntax-node, def-rtx-operand-node): Ditto.
	(rtx-lazy-sem-mode): Delete.
	(/rtx-closure-make): New arg `mode', all callers updated.
	(rtx-make-ifield, rtx-make-operand, rtx-make-local): Ditto.
	(rtx-operand-obj): Rewrite.
	(rtx-make-xop): New functions.
	(/hw): Renamed from `hw', all callers updated.
	Use the correct mode instead of DFLT for the index.
	(rtl-builtin!): Call rtx-init-traversal-tables!.
	(rtl-finish!): Update.
	* rtx-funcs.scm (all rtx functions): New parameter: result-mode.
	Update mode arg-type.
	(pc): Comment out.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	* sem-frags.scm (/frag-hash-compute!): Update, mode arg deleted.
	(/frag-cost-compute!): Ditto.
	* semantics.scm (/build-operand!): Delete args op-name, op.
	New arg op-expr.  All callers updated.
	(/build-mem-operand!): Remove DFLT support.
	(semantic-compile): Update process-expr!, mode arg deleted.
	* sid-cpu.scm (gen-semantic-code): Specify #:for-insn? in
	rtl-c++ calls.
	(/gen-sem-case, /gen-sfrag-code): Ditto.
	* sid.scm (/op-gen-set-trace1): Renamed from /op-gen-set-trace.
	(/op-gen-set-trace): New function.  If not doing profiling,
	call /op-gen-set-quiet.
	* sim-cpu.scm (gen-semantic-code): Specify #:for-insn? in rtl-c calls.
	* utils-gen.scm (/gen-ifld-extract-base): Update call to rtl-c.
	(/gen-ifld-extract-beyond, gen-multi-ifld-extract): Ditto.
	* utils.scm (find-first-index): New function.
	* doc/rtl.texi: Delete docs for `attr'.  Add `int-attr'.
@
text
@d468 1
a468 1
; NOTE: While having to trim the result of rtx-simplify may seem ironical,
@


1.7
log
@	Clean up pass of mode handling.
	Make use of mode name vs <mode> object more consistent and clear.
	* hardware.scm (/keyword-read): Default mode to the mode name,
	not the <mode> object.
	(/hw-parse-indices): Parse mode name and pass mode object to
	<hw-asm> constructor.
	(/hw-parse-values): Ditto.
	(<hw-register> parse!): Pass mode name to /hw-parse-indices
	and /hw-parse-values.
	(<hw-memory> parse!): Ditto.
	(<hw-address> parse!): Ditto.
	* mode.scm (/mode-table): New global, replaces mode-list.
	Modes stored in hashtable instead of list.
	(/mode-class-table): New global.
	(mode-list-non-alias-values): Update.
	(mode:eq?, mode-compatible?, mode:add!): Update.
	(mode:lookup): Restrict arg to the mode's name.  All callers updated.
	(mode-maybe-lookup): New function.
	(mode-real-name): Restrict arg to a <mode> object.  All callers updated.
	(mode-real-mode, mode-sem-mode, mode-bigger?): Ditto.
	(mode-find, mode-set-word-modes!): Update
	(mode-ensure-word-sizes-defined): Update.
	(/sort-mode-classes!): New function.
	(mode-builtin!): Update.  Sort mode classes here.
	(mode-finish!): Sort mode classes here too.
	* rtl-c.scm (/rtl-c-get): Restrict mode arg to a <mode> object.
	All callers updated.
	(rtl-c-set-quiet): Allow mode to be name of object.
	(rtl-c-set-trace): Ditto.
	* rtl-traverse.scm (rtl-eval-with-estate): Restrict mode arg to
	<mode> object.  All callers updated.
	* rtl.scm (rtx-sem-mode): Restrict arg to <mode> object.
	(rtx-lazy-sem-mode): Ditto.
	(<rtx-temp> make!): Assert mode arg is a <mode> object.
	(rtx-env-make): Allow var-list modes to be name or object.
	* sem-frags.scm (/frag-expr-assq-locals): New function.
	(/frag-compute-locals!): Call it.
	(/sfrag-create-cse-mapping): Renamed from sfrag-create-cse-mapping.
	All callers updated.
	* semantics.scm (/build-mem-operand!): Handle mode aliases.
@
text
@a9 2
;; rtx-canonicalize
;; rtx-compile
d12 20
a136 1
; MODE is the name of the mode.
d138 1
a138 1
(define (/rtx-simplify-expr-fn rtx-obj expr mode parent-expr op-pos
d147 1
a147 3
				'RTX
				(rtx-alu-op-mode expr)
				expr 1 tstate appstuff))
d157 1
a157 1
				'RTX 'DFLT expr 0 tstate appstuff))
d159 1
a159 1
				'RTX 'DFLT expr 1 tstate appstuff)))
d178 1
a178 1
				'RTX 'DFLT expr 0 tstate appstuff))
d180 1
a180 1
				'RTX 'DFLT expr 1 tstate appstuff)))
d204 1
a204 1
	    (/rtx-traverse (rtx-if-test expr) 'RTX 'DFLT expr 1 tstate appstuff)))
d206 1
a206 1
	      (/rtx-traverse (rtx-if-then expr) 'RTX mode expr 2 tstate appstuff))
d209 1
a209 1
		  (/rtx-traverse (rtx-if-else expr) 'RTX mode expr 3 tstate appstuff)
d211 1
d214 1
a214 1
		      (rtx-make 'nop)
a225 1
				(rtx-cmp-op-mode expr)
a227 1
				(rtx-cmp-op-mode expr)
d294 1
a294 1
; EXPR must be in source form.
d315 1
a315 1
  (/rtx-traverse expr #f 'DFLT #f 0
d317 1
a317 1
			      (/fastcall-make /rtx-simplify-expr-fn)
d319 1
a319 1
			      #f #f known 0)
d327 1
a327 1
  (rtx-simplify context insn (insn-semantics insn)
a341 1
; MODE is the name of the mode.
d343 1
a343 1
(define (/solve-expr-fn rtx-obj expr mode parent-expr op-pos tstate appstuff)
d368 1
a368 1
;	  (/rtx-traverse simplified-expr #f 'DFLT #f 0
d370 1
a370 1
;				      (/fastcall-make /solve-expr-fn)
d372 1
a372 1
;				      #f #f known 0)
d380 2
a381 54
;; rtx-canonicalize (and supporting cast)

; RTX canonicalization.
; ??? wip

; Subroutine of rtx-canonicalize.
; Return canonical form of rtx expression EXPR.
; CONTEXT is a <context> object or #f if there is none.
; It is used for error message.
; RTX-OBJ is the <rtx-func> object of (car expr).

(define (/rtx-canonicalize-expr context rtx-obj expr)
  #f
)

; Return canonical form of EXPR.
; CONTEXT is a <context> object or #f if there is none.
; It is used for error message.
;
; Does:
; - operand shortcuts expanded
;   - numbers -> (const number)
;   - operand-name -> (operand operand-name)
;   - ifield-name -> (ifield ifield-name)
; - no options -> null option list
; - absent result mode of those that require a mode -> DFLT
; - rtx macros are expanded
;
; EXPR is returned in source form.  We could speed up future processing by
; transforming it into a more compiled form, but that makes debugging more
; difficult, so for now we don't.

(define (rtx-canonicalize context expr)
  ; FIXME: wip
  (cond ((integer? expr)
	 (rtx-make-const 'INT expr))
	((symbol? expr)
	 (let ((op (current-op-lookup expr)))
	   (if op
	       (rtx-make-operand expr)
	       (context-error context
			      "While canonicalizing rtl"
			      "can't canonicalize, unknown symbol"
			      expr))))
	((pair? expr)
	 expr)
	(else
	 (context-error context
			"While canonicalizing rtl"
			"can't canonicalize, syntax error"
			expr)))
)

;; rtx-compile (and supporting cast)
d383 2
a384 14
;; Subroutine of rtx-compile.
;; This is the tstate-expr-fn.
;; MODE is the name of the mode.

(define (/compile-expr-fn rtx-obj expr mode parent-expr op-pos tstate appstuff)
; (cond 
; The intent of this is to handle sequences/closures, but is it needed?
;  ((rtx-style-syntax? rtx-obj)
;   ((rtx-evaluator rtx-obj) rtx-obj expr mode
;			     parent-expr op-pos tstate))
;  (else
  (cons (car expr) ; rtx-obj
	(/rtx-traverse-operands rtx-obj expr tstate appstuff))
)
d386 2
a387 20
; Convert rtl expression EXPR from source form to compiled form.
; The expression is validated and rtx macros are expanded as well.
; CONTEXT is a <context> object or #f if there is none.
; It is used in error messages.
; EXTRA-VARS-ALIST is an association list of extra (symbol <mode> value)
; elements to be used during value lookup.
;
; This does the same operation that rtx-traverse does, except that it provides
; a standard value for EXPR-FN.
;
; ??? In the future the compiled form may be the same as the source form
; except that all elements would be converted to their respective objects.

(define (rtx-compile context expr extra-vars-alist)
  (/rtx-traverse expr #f 'DFLT #f 0
		 (tstate-make context #f
			      (/fastcall-make /compile-expr-fn)
			      (rtx-env-init-stack1 extra-vars-alist)
			      #f #f nil 0)
		 #f)
a388 4

;; rtx-trim-for-doc (and supporting cast)

; RTX trimming (removing fluff not normally needed for the human viewer).
d417 3
a419 1
	      ((ANYMODE INTMODE FLOATMODE NUMMODE EXPLNUMMODE NONVOIDMODE VOIDMODE DFLTMODE)
d461 1
a461 1
; Given a fully specified rtx expression, usually the result of rtx-simplify,
d463 4
a466 3
; rtx-simplify adds a lot of verbosity because in the process of
; simplifying the rtl it produces fully-specified rtl.
; Examples of things to remove: empty options list, DFLT mode.
d481 1
a481 3
	  ((const) (car rest))

	  ((ifield operand local)
d483 1
a483 3
	       (if (eq? mode 'DFLT)
		   (car rest)
		   (cons name (cons mode rest)))
d486 14
d511 1
a511 1
		 (if (eq? mode 'DFLT)
d519 1
a519 1
		 (if (eq? mode 'DFLT)
@


1.6
log
@	* rtl-traverse.scm: Comment tweaks.
	* rtl-xform.scm: Comment and reformatting tweaks.
	* doc/rtl.texi: Add text to docs on ifield-assertions.
@
text
@d119 1
d328 1
d422 15
a449 11
(define (/compile-expr-fn rtx-obj expr mode parent-expr op-pos tstate appstuff)
; (cond 
; The intent of this is to handle sequences/closures, but is it needed?
;  ((rtx-style-syntax? rtx-obj)
;   ((rtx-evaluator rtx-obj) rtx-obj expr mode
;			     parent-expr op-pos tstate))
;  (else
  (cons (car expr) ; rtx-obj
	(/rtx-traverse-operands rtx-obj expr tstate appstuff))
)

@


1.5
log
@tweak error message
@
text
@d201 2
a202 1
	     ; to have our caller do it.  The cost is retraversing `test'.
d221 2
a222 1
	      ; known range of values.
d228 2
a229 1
		       (case (/rtx-const-list-equal arg1 known-val (rtx-kind? 'ne expr))
d239 2
a240 1
		       (case (/rtx-const-list-equal arg1 known-val (rtx-kind? 'ne expr))
@


1.4
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d403 1
a403 1
			      "can't canonicalize"
d410 1
a410 1
			"can't canonicalize"
@


1.3
log
@	* read.scm (parse-error): Change error message output format
	to match context-owner-error.
	* rtl-c.scm (-rtl-c-get): Call estate-error instead of error.
	(rtl-c-set-quiet, rtl-c-set-trace): Ditto.
	(s-if, s-cond, -gen-non-vm-case-test): Ditto.
	(operand): Call estate-error instead of context-error.
	(local, delay): Ditto.
	(ref, attr): Call estate-error instead of error.
	* rtl-traverse.scm (tstate-error): New function.
	(-rtx-traverse-error): Call tstate-error instead of context-error.
	(-rtx-traverse-operands, -rtx-traverse): Ditto.
	(estate-error): New function.
	* rtl.scm (rtx-lvalue-mode-name): Handle locals.  Call estate-error
	instead of error.
	(e-if): Call estate-error instead of error.
	* rtx-funcs.scm (error): Call estate-error instead of context-error.
	(member): Ditto.
	* utils-cgen.scm (context-error): New arg `intro', all callers updated.
	Rewrite to call context-owner-error.
	(context-owner-error): New function.
@
text
@d16 1
a16 1
; Subroutine of -rtx-simplify-expr-fn to compare two values for equality.
d21 1
a21 1
(define (-rtx-const-equal arg0 arg1 invert?)
d32 1
a32 1
; Subroutine of -rtx-simplify-expr-fn to see if MAYBE-CONST is
d48 1
a48 1
(define (-rtx-const-list-equal maybe-const number-list invert?)
d66 1
a66 1
; Subroutine of -rtx-simplify-expr-fn to simplify an eq-attr of (current-mach).
d69 1
a69 1
(define (-rtx-simplify-eq-attr-mach rtx context)
d101 1
a101 1
; Subroutine of -rtx-simplify-expr-fn to simplify an eq-attr of (current-insn).
d103 1
a103 1
(define (-rtx-simplify-eq-attr-insn rtx insn context)
d120 1
a120 1
(define (-rtx-simplify-expr-fn rtx-obj expr mode parent-expr op-pos
d128 1
a128 1
     (let* ((arg (-rtx-traverse (rtx-alu-op-arg expr 0)
d140 1
a140 1
     (let ((arg0 (-rtx-traverse (rtx-boolif-op-arg expr 0)
d142 1
a142 1
	   (arg1 (-rtx-traverse (rtx-boolif-op-arg expr 1)
d161 1
a161 1
     (let ((arg0 (-rtx-traverse (rtx-boolif-op-arg expr 0)
d163 1
a163 1
	   (arg1 (-rtx-traverse (rtx-boolif-op-arg expr 1)
d188 1
a188 1
	    (-rtx-traverse (rtx-if-test expr) 'RTX 'DFLT expr 1 tstate appstuff)))
d190 1
a190 1
	      (-rtx-traverse (rtx-if-then expr) 'RTX mode expr 2 tstate appstuff))
d193 1
a193 1
		  (-rtx-traverse (rtx-if-else expr) 'RTX mode expr 3 tstate appstuff)
d207 1
a207 1
	   (arg0 (-rtx-traverse (rtx-cmp-op-arg expr 0) 'RTX
d210 1
a210 1
	   (arg1 (-rtx-traverse (rtx-cmp-op-arg expr 1) 'RTX
d215 1
a215 1
	   (case (-rtx-const-equal arg0 arg1 (rtx-kind? 'ne expr))
d226 1
a226 1
		       (case (-rtx-const-list-equal arg1 known-val (rtx-kind? 'ne expr))
d236 1
a236 1
		       (case (-rtx-const-list-equal arg1 known-val (rtx-kind? 'ne expr))
d248 1
a248 1
	    (-rtx-simplify-eq-attr-mach expr (tstate-context tstate)))
d250 1
a250 1
	    (-rtx-simplify-eq-attr-insn expr (tstate-owner tstate) (tstate-context tstate)))
d296 1
a296 1
  (-rtx-traverse expr #f 'DFLT #f 0
d298 1
a298 1
			      (/fastcall-make -rtx-simplify-expr-fn)
d324 1
a324 1
(define (-solve-expr-fn rtx-obj expr mode parent-expr op-pos tstate appstuff)
d349 1
a349 1
;	  (-rtx-traverse simplified-expr #f 'DFLT #f 0
d351 1
a351 1
;				      (/fastcall-make -solve-expr-fn)
d372 1
a372 1
(define (-rtx-canonicalize-expr context rtx-obj expr)
d429 1
a429 1
(define (-compile-expr-fn rtx-obj expr mode parent-expr op-pos tstate appstuff)
d437 1
a437 1
	(-rtx-traverse-operands rtx-obj expr tstate appstuff))
d441 1
a441 1
  (-rtx-traverse expr #f 'DFLT #f 0
d443 1
a443 1
			      (/fastcall-make -compile-expr-fn)
d453 1
a453 1
; Subroutine of -rtx-trim-for-doc to simplify it.
d456 1
a456 1
(define (-rtx-trim-args name args)
d484 1
a484 1
	       (set! new-arg (-rtx-trim-for-doc arg)))
d489 3
a491 3
		   (set! new-arg (cons 'else (-rtx-trim-for-doc (cadr arg))))
		   (set! new-arg (list (-rtx-trim-for-doc (car arg))
				       (-rtx-trim-for-doc (cadr arg)))))
d496 1
a496 1
	       (set! new-arg (list (car arg) (-rtx-trim-for-doc (cadr arg))))
d532 1
a532 1
(define (-rtx-trim-for-doc rtx)
d553 1
a553 1
	   (let ((trimmed-args (-rtx-trim-args name rest))
d567 1
a567 1
	   (let ((trimmed-args (-rtx-trim-args name rest)))
d579 1
a579 1
  (-rtx-trim-for-doc rtx)
@


1.2
log
@	* rtl-xform.scm (rtx-simplify-insn): New function.
	* html.scm (gen-insn-docs): Call it.
	* sem-frags.scm (sem-find-common-frags, -frag-test-data): Ditto.
	* iformat.scm (ifmt-analyze): Minor simplification.
@
text
@d79 3
a81 1
	  (context-error context "rtx simplification, no machs selected"
d108 1
d401 4
a404 1
	       (context-error context "can't canonicalize" expr))))
d408 4
a411 1
	 (context-error context "can't canonicalize" expr)))
@


1.1
log
@	* semantics.scm (semantic-compile): Change arg sem-code-list to
	sem-code.
	(semantic-attrs): Ditto.
	* iformat.scm (ifmt-analyze): Update.
	(ifmt-compute!): Update.
	* rtl-traverse.scm (-compile-expr-fn, rtx-compile): Move to
	rtl-xform.scm.
	(-rtx-trim-args, -rtx-trim-for-doc, rtx-trim-for-doc): Ditto.
	* rtl.scm (-rtx-canonicalize-expr, rtx-canonicalize): Ditto.
	* semantics.scm (rtx-simplify): Ditto.
	(rtx-const-equal, rtx-const-list-equal): Ditto, and make local.
	(rtx-simplify-eq-attr-mach, rtx-simplify-eq-attr-insn): Ditto.
	(-simplify-expr-fn): Move to rtl-xform.scm.
	(-solve-expr-fn, rtx-solve): Ditto.
	* rtl-xform.c: New file.
	* read.scm: Load it.
@
text
@d271 1
d275 1
a275 1
; CONTEXT is a <context> object, used for error messages.
d300 8
@

