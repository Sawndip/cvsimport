head	1.20;
access;
symbols
	sid-snapshot-20180601:1.20
	cgen-snapshot-20180601:1.20
	sid-snapshot-20180501:1.20
	cgen-snapshot-20180501:1.20
	sid-snapshot-20180401:1.20
	cgen-snapshot-20180401:1.20
	sid-snapshot-20180301:1.20
	cgen-snapshot-20180301:1.20
	sid-snapshot-20180201:1.20
	cgen-snapshot-20180201:1.20
	sid-snapshot-20180101:1.20
	cgen-snapshot-20180101:1.20
	sid-snapshot-20171201:1.20
	cgen-snapshot-20171201:1.20
	sid-snapshot-20171101:1.20
	cgen-snapshot-20171101:1.20
	sid-snapshot-20171001:1.20
	cgen-snapshot-20171001:1.20
	sid-snapshot-20170901:1.20
	cgen-snapshot-20170901:1.20
	sid-snapshot-20170801:1.20
	cgen-snapshot-20170801:1.20
	sid-snapshot-20170701:1.20
	cgen-snapshot-20170701:1.20
	sid-snapshot-20170601:1.20
	cgen-snapshot-20170601:1.20
	sid-snapshot-20170501:1.20
	cgen-snapshot-20170501:1.20
	sid-snapshot-20170401:1.20
	cgen-snapshot-20170401:1.20
	sid-snapshot-20170301:1.20
	cgen-snapshot-20170301:1.20
	sid-snapshot-20170201:1.20
	cgen-snapshot-20170201:1.20
	sid-snapshot-20170101:1.20
	cgen-snapshot-20170101:1.20
	sid-snapshot-20161201:1.20
	cgen-snapshot-20161201:1.20
	sid-snapshot-20161101:1.20
	cgen-snapshot-20161101:1.20
	sid-snapshot-20160901:1.20
	cgen-snapshot-20160901:1.20
	sid-snapshot-20160801:1.20
	cgen-snapshot-20160801:1.20
	sid-snapshot-20160701:1.20
	cgen-snapshot-20160701:1.20
	sid-snapshot-20160601:1.20
	cgen-snapshot-20160601:1.20
	sid-snapshot-20160501:1.20
	cgen-snapshot-20160501:1.20
	sid-snapshot-20160401:1.20
	cgen-snapshot-20160401:1.20
	sid-snapshot-20160301:1.20
	cgen-snapshot-20160301:1.20
	sid-snapshot-20160201:1.20
	cgen-snapshot-20160201:1.20
	sid-snapshot-20160101:1.20
	cgen-snapshot-20160101:1.20
	sid-snapshot-20151201:1.20
	cgen-snapshot-20151201:1.20
	sid-snapshot-20151101:1.20
	cgen-snapshot-20151101:1.20
	sid-snapshot-20151001:1.20
	cgen-snapshot-20151001:1.20
	sid-snapshot-20150901:1.20
	cgen-snapshot-20150901:1.20
	sid-snapshot-20150801:1.20
	cgen-snapshot-20150801:1.20
	sid-snapshot-20150701:1.20
	cgen-snapshot-20150701:1.20
	sid-snapshot-20150601:1.20
	cgen-snapshot-20150601:1.20
	sid-snapshot-20150501:1.20
	cgen-snapshot-20150501:1.20
	sid-snapshot-20150401:1.20
	cgen-snapshot-20150401:1.20
	sid-snapshot-20150301:1.20
	cgen-snapshot-20150301:1.20
	sid-snapshot-20150201:1.20
	cgen-snapshot-20150201:1.20
	sid-snapshot-20150101:1.20
	cgen-snapshot-20150101:1.20
	sid-snapshot-20141201:1.20
	cgen-snapshot-20141201:1.20
	sid-snapshot-20141101:1.20
	cgen-snapshot-20141101:1.20
	sid-snapshot-20141001:1.20
	cgen-snapshot-20141001:1.20
	sid-snapshot-20140901:1.20
	cgen-snapshot-20140901:1.20
	sid-snapshot-20140801:1.20
	cgen-snapshot-20140801:1.20
	sid-snapshot-20140701:1.20
	cgen-snapshot-20140701:1.20
	sid-snapshot-20140601:1.20
	cgen-snapshot-20140601:1.20
	sid-snapshot-20140501:1.20
	cgen-snapshot-20140501:1.20
	sid-snapshot-20140401:1.20
	cgen-snapshot-20140401:1.20
	sid-snapshot-20140301:1.20
	cgen-snapshot-20140301:1.20
	sid-snapshot-20140201:1.20
	cgen-snapshot-20140201:1.20
	sid-snapshot-20140101:1.20
	cgen-snapshot-20140101:1.20
	sid-snapshot-20131201:1.20
	cgen-snapshot-20131201:1.20
	sid-snapshot-20131101:1.20
	cgen-snapshot-20131101:1.20
	sid-snapshot-20131001:1.20
	cgen-snapshot-20131001:1.20
	sid-snapshot-20130901:1.20
	cgen-snapshot-20130901:1.20
	sid-snapshot-20130801:1.20
	cgen-snapshot-20130801:1.20
	sid-snapshot-20130701:1.20
	cgen-snapshot-20130701:1.20
	sid-snapshot-20130601:1.20
	cgen-snapshot-20130601:1.20
	sid-snapshot-20130501:1.20
	cgen-snapshot-20130501:1.20
	sid-snapshot-20130401:1.20
	cgen-snapshot-20130401:1.20
	sid-snapshot-20130301:1.20
	cgen-snapshot-20130301:1.20
	sid-snapshot-20130201:1.20
	cgen-snapshot-20130201:1.20
	sid-snapshot-20130101:1.20
	cgen-snapshot-20130101:1.20
	sid-snapshot-20121201:1.20
	cgen-snapshot-20121201:1.20
	sid-snapshot-20121101:1.20
	cgen-snapshot-20121101:1.20
	sid-snapshot-20121001:1.20
	cgen-snapshot-20121001:1.20
	sid-snapshot-20120901:1.20
	cgen-snapshot-20120901:1.20
	sid-snapshot-20120801:1.20
	cgen-snapshot-20120801:1.20
	sid-snapshot-20120701:1.20
	cgen-snapshot-20120701:1.20
	sid-snapshot-20120601:1.20
	cgen-snapshot-20120601:1.20
	sid-snapshot-20120501:1.20
	cgen-snapshot-20120501:1.20
	sid-snapshot-20120401:1.20
	cgen-snapshot-20120401:1.20
	sid-snapshot-20120301:1.20
	cgen-snapshot-20120301:1.20
	sid-snapshot-20120201:1.20
	cgen-snapshot-20120201:1.20
	sid-snapshot-20120101:1.20
	cgen-snapshot-20120101:1.20
	sid-snapshot-20111201:1.20
	cgen-snapshot-20111201:1.20
	sid-snapshot-20111101:1.20
	cgen-snapshot-20111101:1.20
	sid-snapshot-20111001:1.20
	cgen-snapshot-20111001:1.20
	sid-snapshot-20110901:1.20
	cgen-snapshot-20110901:1.20
	sid-snapshot-20110801:1.20
	cgen-snapshot-20110801:1.20
	sid-snapshot-20110701:1.20
	cgen-snapshot-20110701:1.20
	sid-snapshot-20110601:1.20
	cgen-snapshot-20110601:1.20
	sid-snapshot-20110501:1.20
	cgen-snapshot-20110501:1.20
	sid-snapshot-20110401:1.20
	cgen-snapshot-20110401:1.20
	sid-snapshot-20110301:1.20
	cgen-snapshot-20110301:1.20
	sid-snapshot-20110201:1.20
	cgen-snapshot-20110201:1.20
	sid-snapshot-20110101:1.20
	cgen-snapshot-20110101:1.20
	sid-snapshot-20101201:1.20
	cgen-snapshot-20101201:1.20
	sid-snapshot-20101101:1.20
	cgen-snapshot-20101101:1.20
	sid-snapshot-20101001:1.20
	cgen-snapshot-20101001:1.20
	sid-snapshot-20100901:1.20
	cgen-snapshot-20100901:1.20
	sid-snapshot-20100801:1.20
	cgen-snapshot-20100801:1.20
	sid-snapshot-20100701:1.20
	cgen-snapshot-20100701:1.20
	sid-snapshot-20100601:1.20
	cgen-snapshot-20100601:1.20
	sid-snapshot-20100501:1.20
	cgen-snapshot-20100501:1.20
	sid-snapshot-20100401:1.20
	cgen-snapshot-20100401:1.20
	sid-snapshot-20100301:1.20
	cgen-snapshot-20100301:1.20
	sid-snapshot-20100201:1.20
	cgen-snapshot-20100201:1.20
	sid-snapshot-20100101:1.20
	cgen-snapshot-20100101:1.20
	sid-snapshot-20091201:1.20
	cgen-snapshot-20091201:1.20
	sid-snapshot-20091101:1.18
	cgen-snapshot-20091101:1.18
	sid-snapshot-20091001:1.18
	cgen-snapshot-20091001:1.18
	arc-sim-20090309:1.13
	sid-snapshot-20090901:1.14
	cgen-snapshot-20090901:1.14
	sid-snapshot-20090801:1.14
	cgen-snapshot-20090801:1.14
	sid-snapshot-20090701:1.14
	cgen-snapshot-20090701:1.14
	dje-cgen-play1-branch:1.14.0.2
	dje-cgen-play1-branchpoint:1.14
	cgen-1_1-branch:1.13.0.6
	cgen-1_1-branchpoint:1.13
	sid-snapshot-20090601:1.13
	cgen-snapshot-20090601:1.13
	sid-snapshot-20090501:1.13
	cgen-snapshot-20090501:1.13
	sid-snapshot-20090401:1.13
	cgen-snapshot-20090401:1.13
	arc-insight_6_8-branch:1.13.0.4
	arc-insight_6_8-branchpoint:1.13
	sid-snapshot-20090301:1.13
	cgen-snapshot-20090301:1.13
	sid-snapshot-20090201:1.13
	cgen-snapshot-20090201:1.13
	sid-snapshot-20090101:1.13
	cgen-snapshot-20090101:1.13
	sid-snapshot-20081201:1.13
	cgen-snapshot-20081201:1.13
	sid-snapshot-20081101:1.13
	cgen-snapshot-20081101:1.13
	sid-snapshot-20081001:1.13
	cgen-snapshot-20081001:1.13
	sid-snapshot-20080901:1.13
	cgen-snapshot-20080901:1.13
	sid-snapshot-20080801:1.13
	cgen-snapshot-20080801:1.13
	sid-snapshot-20080701:1.13
	cgen-snapshot-20080701:1.13
	sid-snapshot-20080601:1.13
	cgen-snapshot-20080601:1.13
	sid-snapshot-20080501:1.13
	cgen-snapshot-20080501:1.13
	sid-snapshot-20080403:1.13
	sid-snapshot-20080401:1.13
	cgen-snapshot-20080401:1.13
	sid-snapshot-20080301:1.13
	cgen-snapshot-20080301:1.13
	sid-snapshot-20080201:1.13
	cgen-snapshot-20080201:1.13
	sid-snapshot-20080101:1.13
	cgen-snapshot-20080101:1.13
	sid-snapshot-20071201:1.13
	cgen-snapshot-20071201:1.13
	sid-snapshot-20071101:1.13
	cgen-snapshot-20071101:1.13
	sid-snapshot-20071001:1.13
	cgen-snapshot-20071001:1.13
	msnyder-fork-checkpoint-branch:1.13.0.2
	msnyder-fork-checkpoint-branchpoint:1.13
	sid-20020905-branchpoint:1.7
	sid-20020905-branch:1.7.0.2
	cagney_regbuf-20020515-branch:1.6.0.2
	cagney_regbuf-20020515-branchpoint:1.6
	cygnus_cvs_20020108_pre:1.6
	cgen-1-1-branch:1.5.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.20
date	2009.11.23.09.03.01;	author devans;	state Exp;
branches;
next	1.19;

1.19
date	2009.11.03.16.24.02;	author devans;	state Exp;
branches;
next	1.18;

1.18
date	2009.09.23.22.30.19;	author devans;	state Exp;
branches;
next	1.17;

1.17
date	2009.09.09.17.06.19;	author devans;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.09.08.00.16;	author devans;	state Exp;
branches;
next	1.15;

1.15
date	2009.09.07.22.17.34;	author devans;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.17.01.47.16;	author jimb;	state Exp;
branches
	1.13.6.1;
next	1.12;

1.12
date	2005.02.16.21.52.33;	author brolley;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.15.12.52.00;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.16.05.35.48;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.15.07.25.03;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.09.03.15.42;	author bje;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.30.22.48.48;	author hp;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.14.19.46.43;	author brolley;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.06.12.11.09;	author bje;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.06.16.55.16;	author brolley;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.06.19.24.45;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.29.15.25.37;	author brolley;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.13.6.1
date	2009.06.24.14.57.46;	author devans;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.20
log
@	* hardware.scm (hw-pc?): New function.
	* ifield.scm (ifld-signed?): New function.
	* iformat.scm (ifmt-analyze): Call insn-cti-attr? instead of insn-cti?.
	* insn.scm (insn-cti-attr?): Renamed from insn-ctl?.
	(insn-cti?): New function.
	* rtl.scm (/hw): Create <pc> object for pcs.
	* semantics.scm (/build-reg-operand!): New args ref-type, sem-attrs.
	All callers updated.  Watch for sets to the pc.
	(semantic-attrs): Watch for sets to the pc.
	* sid.scm (<pc> cxmake-get): Handle raw-reg.
	* sim.scm (<pc> cxmake-get): Handle raw-reg.
	(<operand> cxmake-get): Add debugging printf.
	* utils-gen.scm (/gen-ifld-extract-base): Emit calls to
	EXTRACT_[LM]SB0_LG[SU]INT for values > 32 bits.
	(/gen-extract-word): Ditto.

	* utils.scm (gen-c-hex-constant): New function.
	* utils-sim.scm (/gen-decode-insn-entry): Call it.
@
text
@; Application independent utilities for C/C++ code generation.
; Copyright (C) 2000, 2001, 2005, 2009 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.

; Attributes.

(define (attr-bool-gen-decl attr) "")

(define (attr-bool-gen-defn attr) "")

(define (attr-int-gen-decl attr) "")

(define (attr-int-gen-defn attr) 
  (string-append
   "static const CGEN_ATTR_ENTRY " (gen-sym attr)
   "_attr [] ATTRIBUTE_UNUSED = \n{\n  {\"integer\", " (number->string (attr-default attr)) "},\n  { 0, 0 }\n};\n\n" ))

(define (attr-gen-decl attr)
  (gen-enum-decl (symbol-append (obj:name attr) '-attr)
		 (obj:comment attr)
		 (string-append (obj:str-name attr) "_")
		 (attr-values attr))
)

(define (attr-gen-defn attr)
  (string-append
   "static const CGEN_ATTR_ENTRY "
   (gen-sym attr) "_attr"
   "[] ATTRIBUTE_UNUSED =\n{\n"
   (string-map (lambda (elm)
		 (let* ((san (and (pair? elm) (pair? (cdr elm))
				  (attr-value (cddr elm) 'sanitize #f))))
		   (gen-sanitize
		    (if (and san (not (eq? san 'none)))
			san
			#f)
		    (string-append "  { "
				   "\""
				   (gen-c-symbol (car elm))
				   "\", "
				   (string-upcase (gen-sym attr))
				   "_"
				   (string-upcase (gen-c-symbol (car elm)))
				   " },\n"))))
	       (attr-values attr))
   "  { 0, 0 }\n"
   "};\n\n")
)

(method-make! <boolean-attribute> 'gen-decl attr-bool-gen-decl)
(method-make! <bitset-attribute> 'gen-decl attr-gen-decl)
(method-make! <integer-attribute> 'gen-decl attr-int-gen-decl)
(method-make! <enum-attribute> 'gen-decl attr-gen-decl)

(method-make! <boolean-attribute> 'gen-defn attr-bool-gen-defn)
(method-make! <bitset-attribute> 'gen-defn attr-gen-defn)
(method-make! <integer-attribute> 'gen-defn attr-int-gen-defn)
(method-make! <enum-attribute> 'gen-defn attr-gen-defn)

; Ifield extraction utilities.

; Return the C data type to use to hold an extracted and decoded
; <ifield> from an insn.  Usually this is just an int, but for register
; numbers or large unsigned immediates, an unsigned int may be preferable.
; Then there's floats (??? which aren't handled yet).

(define (gen-ifld-type f)
  (mode:c-type (ifld-decode-mode f))
)

; Return C declaration of variable(s) to hold <ifield> F.
; MACRO? is #t if the result is part of a macro.

(define (gen-ifld-extract-decl f indent macro?)
  (string-append indent (gen-ifld-type f) " " (gen-sym f) ";"
		 (if macro? " \\\n" "\n"))
)

; Return C code to extract a field from the base part of an insn.
;
; TOTAL-LENGTH is the total length of the value in VAL.
; BASE-VALUE is a C expression (string) containing the base part of the insn.

(define (/gen-ifld-extract-base f total-length base-value)
  (let ((extraction
	 (string-append "EXTRACT_"
			(if (current-arch-insn-lsb0?) "LSB0_" "MSB0_")
			(if (> total-length 32) "LG" "")
			(case (mode:class (ifld-mode f))
			  ((INT) "SINT")
			  ((UINT) "UINT")
			  (else (error "unsupported mode class"
				       (mode:class (ifld-mode f)))))
			" ("
			base-value ", "
			(number->string total-length) ", "
			(number->string (+ (ifld-start f)
					   (ifld-word-offset f))) ", "
			(number->string (ifld-length f))
			")"))
	(decode (ifld-decode f)))
    ; If the field doesn't have a special decode expression,
    ; just return the raw extracted value.  Otherwise, emit
    ; the expression.
    (if (not decode)
	extraction
	; cadr: fetches expression to be evaluated
	; caar: fetches symbol in arglist
	; cadar: fetches `pc' symbol in arglist
	(rtl-c DFLT
	       (obj-isa-list f)
	       (list (list (caar decode) 'UINT extraction)
		     (list (cadar decode) 'IAI "pc"))
	       (cadr decode)
	       #:rtl-cover-fns? #f #:ifield-var? #t)))
)

; Subroutine of /gen-ifld-extract-beyond to extract the relevant value
; from WORD-NAME and move it into place.

(define (/gen-extract-word word-name word-start word-length
			   field-start field-length
			   unsigned? lsb0?)
  (let* ((word-end (+ word-start word-length))
	 (start (if lsb0? (+ 1 (- field-start field-length)) field-start))
	 (end (+ start field-length))
	 (base (if (< start word-start) word-start start)))
    (string-append "("
		   "EXTRACT_"
		   (if lsb0? "LSB0_" "MSB0_")
		   (if (> word-length 32) "LG" "")
		   (if (and (not unsigned?)
			    ; Only want sign extension for word with sign bit.
			    (bitrange-overlap? field-start 1
					       word-start word-length
					       lsb0?))
		       "SINT"
		       "UINT")
		   " ("
		   ; What to extract from.
		   word-name
		   ", "
		   ; Size of this chunk.
		   (number->string word-length)
		   ", "
		   ; MSB of this chunk.
		   (number->string
		    (if lsb0?
			(if (> end word-end)
			    (- word-end 1)
			    (- end word-start 1))
			(if (< start word-start)
			    0
			    (- start word-start))))
		   ", "
		   ; Length of field within this chunk.
		   (number->string (if (< end word-end)
				       (- end base)
				       (- word-end base)))
		   ") << "
		   ; Adjustment for this chunk within a full field.
		   (number->string (if (> end word-end)
				       (- end word-end)
				       0))
		   ")"))
)

; Return C code to extract a field that extends beyond the base insn.
;
; Things get tricky in the non-integral-insn case (no kidding).
; This case includes every architecture with at least one insn larger
; than 32 bits, and all architectures where insns smaller than 32 bits
; can't be interpreted as an int.
; ??? And maybe other architectures not considered yet.
; We want to handle these reasonably fast as this includes architectures like
; the ARC and I960 where 99% of the insns are 32 bits, with a few insns that
; take a 32 bit immediate.  It would be a real shame to unnecessarily slow down
; handling of 99% of the instruction set just for a few insns.  Fortunately
; for these chips base-insn includes these insns, so things fall out naturally.
;
; BASE-LENGTH is base-insn-bitsize.
; TOTAL-LENGTH is the total length of the insn.
; VAR-LIST is a list of variables containing the insn.
; Each element in VAR-LIST is (name start length).
; The contents of the insn are in several variables: insn, word_[123...],
; where `insn' contains the "base insn" and `word_N' is a set of variables
; recording the rest of the insn, 32 bits at a time (with the last one
; containing whatever is left over).

(define (/gen-ifld-extract-beyond f base-length total-length var-list)
   ; First compute the list of variables that contains pieces of the
   ; desired value.
   (let ((start (+ (ifld-start f) (ifld-word-offset f)))
	 (length (ifld-length f))
	 ;(word-start (ifld-word-offset f))
	 ;(word-length (ifld-word-length f))
	 ; extraction code
	 (extraction #f)
         ; extra processing to perform on extracted value
	 (decode (ifld-decode f))
	 (lsb0? (current-arch-insn-lsb0?)))
     ; Find which vars are needed and move the value into place.
     (let loop ((var-list var-list) (result (list ")")))
       (if (null? var-list)
	   (set! extraction (apply string-append (cons "(0" result)))
	   (let ((var-name (caar var-list))
		 (var-start (cadar var-list))
		 (var-length (caddar var-list)))
	     (if (bitrange-overlap? start length
				    var-start var-length
				    lsb0?)
		 (loop (cdr var-list)
		       (cons "|"
			     (cons (/gen-extract-word var-name
						      var-start
						      var-length
						      start length
						      (eq? (mode:class (ifld-mode f))
							   'UINT)
						      lsb0?)
				   result)))
		 (loop (cdr var-list) result)))))
     ; If the field doesn't have a special decode expression, just return the
     ; raw extracted value.  Otherwise, emit the expression.
     (if (not decode)
	 extraction
	 ; cadr: fetches expression to be evaluated
	 ; caar: fetches symbol in arglist
	 ; cadar: fetches `pc' symbol in arglist
	 (rtl-c DFLT
		(obj-isa-list f)
		(list (list (caar decode) 'UINT extraction)
		      (list (cadar decode) 'IAI "pc"))
		(cadr decode)
		#:rtl-cover-fns? #f #:ifield-var? #t)))
)

; Return C code to extract <ifield> F.

(define (gen-ifld-extract f indent base-length total-length base-value var-list macro?)
  (string-append
   indent
   (gen-sym f)
   " = "
   (if (adata-integral-insn? CURRENT-ARCH)
       (/gen-ifld-extract-base f total-length base-value)
       (if (ifld-beyond-base? f)
	   (/gen-ifld-extract-beyond f base-length total-length var-list)
	   (/gen-ifld-extract-base f base-length base-value)))
   ";"
   (if macro? " \\\n" "\n")
   )
)

; Return C code to extract a <multi-ifield> from an insn.
; This must have the same signature as gen-ifld-extract as both can be
; made methods in application code.

(define (gen-multi-ifld-extract f indent base-length total-length base-value var-list macro?)
  ; The subfields must have already been extracted.
  (let* ((decode-proc (ifld-decode f))
	 (varname (gen-sym f))
	 (decode (string-list
		  ;; First, the block that extract the multi-ifield into the ifld variable.
		  (rtl-c VOID (obj-isa-list f) nil
			 (multi-ifld-extract f)
			 #:rtl-cover-fns? #f #:ifield-var? #t)
		  ;; Next, the decode routine that modifies it.
		  (if decode-proc
		      (string-append
		       "  " varname " = "
		       (rtl-c DFLT
			      (obj-isa-list f)
			      (list (list (caar decode-proc) 'UINT varname)
				    (list (cadar decode-proc) 'IAI "pc"))
			      (cadr decode-proc)
			      #:rtl-cover-fns? #f #:ifield-var? #t)
		       ";\n")
		      "")
		 )))
    (if macro?
	(backslash "\n" decode)
	decode))
)

; Return C symbol of variable containing the extracted field value
; in the extraction code.  E.g. f_rd = EXTRACT_UINT (insn, ...).

(define (gen-extracted-ifld-value f)
  (gen-sym f)
)

; Subroutine of gen-extract-ifields to compute arguments for /extract-chunk
; to extract values beyond the base insn.
; This is also used by gen-define-ifields to know how many vars are needed.
;
; The result is a list of (offset . length) pairs.
;
; ??? Here's a case where explicitly defined instruction formats can
; help - without them we can only use heuristics (which must evolve).
; At least all the details are tucked away here.

(define (/extract-chunk-specs base-length total-length alignment)
  (let ((chunk-length
	 (case alignment
	   ; For the aligned and forced case split the insn up into base-insn
	   ; sized chunks.  For the unaligned case, use a chunk-length of 32.
	   ; 32 was chosen because the values are extracted into portable ints.
	   ((aligned forced) (min base-length 32))
	   ((unaligned) 32)
	   (else (error "unknown alignment" alignment)))))
    (let loop ((start base-length)
	       (remaining (- total-length base-length))
	       (result nil))
      (if (<= remaining 0)
	  (reverse! result)
	  (loop (+ start chunk-length)
		(- remaining chunk-length)
		; Always fetch full CHUNK-LENGTH-sized chunks here,
		; even if we don't actually need that many bytes.
		; gen-ifetch only handles "normal" fetch sizes,
		; and /gen-extract-word already knows how to find what
		; it needs if we give it too much.
		(cons (cons start chunk-length)
		      result)))))
)

; Subroutine of gen-define-ifmt-ifields and gen-extract-ifmt-ifields to
; insert the subfields of any multi-ifields present into IFLDS.
; Subfields are inserted before their corresponding multi-ifield as they
; are initialized in order.

(define (/extract-insert-subfields iflds)
  (let loop ((result nil) (iflds iflds))
    (cond ((null? iflds)
	   (reverse! result))
	  ((multi-ifield? (car iflds))
	   (loop (cons (car iflds)
		       ; There's no real need to reverse the subfields here
		       ; other than to keep them in order.
		       (append (reverse (multi-ifld-subfields (car iflds)))
			       result))
		 (cdr iflds)))
	  (else
	   (loop (cons (car iflds) result) (cdr iflds)))))
)

; Return C code to define local vars to contain IFIELDS.
; All insns using the result have the same TOTAL-LENGTH (in bits).
; INDENT is a string prepended to each line.
; MACRO? is #t if the code is part of a macro (and thus '\\' must be appended
; to each line).

(define (gen-define-ifields ifields total-length indent macro?)
  (let* ((base-length (if (adata-integral-insn? CURRENT-ARCH)
			  32
			  (state-base-insn-bitsize)))
	 (chunk-specs (/extract-chunk-specs base-length total-length
					    (current-arch-default-alignment))))
    (string-list
     (string-list-map (lambda (f)
			(gen-ifld-extract-decl f indent macro?))
		      ifields)
     ; Define enough ints to hold the trailing part of the insn,
     ; N bits at a time.
     ; ??? This could be more intelligent of course.  Later.
     ; ??? Making these global to us would allow filling them during
     ; decoding.
     (if (> total-length base-length)
	 (string-list
	  indent
	  "/* Contents of trailing part of insn.  */"
	  (if macro? " \\\n" "\n")
	  (string-list-map (lambda (chunk-num)
			     (string-list indent
					  "UINT word_"
					  (number->string chunk-num)
					  (if macro? "; \\\n" ";\n")))
			   (iota (length chunk-specs) 1)))
	 "")))
)

; Return C code to define local vars to contain IFIELDS of <iformat> IFMT.
; INDENT is a string prepended to each line.
; MACRO? is #t if the code is part of a macro (and thus '\\' must be appended
; to each line).
; USE-MACRO? is #t if instead of generating the fields, we return the macro
; that does that.

(define (gen-define-ifmt-ifields ifmt indent macro? use-macro?)
  (let ((macro-name (string-append
		     "EXTRACT_" (string-upcase (gen-sym ifmt))
		     "_VARS"))
	(ifields (/extract-insert-subfields (ifmt-ifields ifmt))))
    (if use-macro?
	(string-list indent macro-name
		     " /*"
		     (string-list-map (lambda (fld)
					(string-append " " (obj:str-name fld)))
				      ifields)
		     " */\n")
	(let ((indent (if macro? (string-append indent "  ") indent)))
	  (string-list
	   (if macro?
	       (string-list "#define " macro-name " \\\n")
	       (string-list indent "/* Instruction fields.  */\n"))
	   (gen-define-ifields ifields (ifmt-length ifmt) indent macro?)
	   indent "unsigned int length;"
	   ; The last line doesn't have a trailing '\\'.
	   "\n"
	   ))))
)

; Subroutine of gen-extract-ifields to fetch one value into VAR-NAME.

(define (/extract-chunk offset bits var-name macro?)
  (string-append
   "  "
   var-name
   " = "
   (gen-ifetch "pc" offset bits)
   ";"
   (if macro? " \\\n" "\n"))
)

; Subroutine of gen-extract-ifields to compute the var-list arg to
; gen-ifld-extract-beyond.
; The result is a list of `(name start length)' elements describing the
; variables holding the parts of the insn.
; CHUNK-SPECS is a list of (offset . length) pairs.

(define (/gen-extract-beyond-var-list base-length var-prefix chunk-specs lsb0?)
  ; ??? lsb0? support ok?
  (cons (list "insn" 0 base-length)
	(map (lambda (chunk-num chunk-spec)
	       (list (string-append var-prefix (number->string chunk-num))
		     (car chunk-spec)
		     (cdr chunk-spec)))
	     (iota (length chunk-specs) 1)
	     chunk-specs))
)

; Return C code to extract IFIELDS.
; All insns using the result have the same TOTAL-LENGTH (in bits).
; MACRO? is #t if the code is part of a macro (and thus '\\' must be appended
; to each line).
;
; Here is where we handle integral-insn vs non-integeral-insn architectures.
;
; Examples of architectures that can be handled as integral-insns are:
; sparc, m32r, mips, etc.
;
; Examples of architectures that can't be handled as integral insns are:
; arc, i960, fr30, i386, m68k.
; [i386,m68k are only mentioned for completeness.  cgen ports of these
; would be great, but more thought is needed first]
;
; C variable `insn' is assumed to contain the base part of the insn
; (max base-insn-bitsize insn-bitsize).  In the m32r case insn-bitsize
; can be less than base-insn-bitsize.
;
; ??? Need to see how well gcc optimizes this.
;
; ??? Another way to do this is to put this code in an inline function that
; gets passed pointers to each ifield variable.  GCC is smart enough to
; produce optimal code for this, but other compilers may not have inlining
; or the indirection removal.  I think the slowdown for a non-scache simulator
; would be phenomenal and while one can say "too bad, use gcc", I'm defering
; doing this for now.

(define (gen-extract-ifields ifields total-length indent macro?)
  (let* ((base-length (if (adata-integral-insn? CURRENT-ARCH)
			  32
			  (state-base-insn-bitsize)))
	 (chunk-specs (/extract-chunk-specs base-length total-length
					    (current-arch-default-alignment))))
    (string-list
     ; If the insn has a trailing part, fetch it.
     ; ??? Could have more intelligence here.  Later.
     (if (> total-length base-length)
	 (let ()
	   (string-list-map (lambda (chunk-spec chunk-num)
			      (/extract-chunk (car chunk-spec)
					      (cdr chunk-spec)
					      (string-append
					       "word_"
					       (number->string chunk-num))
					      macro?))
			    chunk-specs
			    (iota (length chunk-specs) 1)))
	 "")
     (string-list-map
      (lambda (f)
	; Dispatching on a method works better, as would a generic fn.
	; ??? Written this way to pass through Hobbit, doesn't handle
	; ((if foo a b) (arg1 arg2)).
	(if (multi-ifield? f)
	    (gen-multi-ifld-extract
	     f indent base-length total-length "insn"
	     (/gen-extract-beyond-var-list base-length "word_"
					   chunk-specs
					   (current-arch-insn-lsb0?))
	     macro?)
	    (gen-ifld-extract
	     f indent base-length total-length "insn"
	     (/gen-extract-beyond-var-list base-length "word_"
					   chunk-specs
					   (current-arch-insn-lsb0?))
	     macro?)))
      ifields)
     ))
)

; Return C code to extract the fields of <iformat> IFMT.
; MACRO? is #t if the code is part of a macro (and thus '\\' must be appended
; to each line).
; USE-MACRO? is #t if instead of generating the fields, we return the macro
; that does that.

(define (gen-extract-ifmt-ifields ifmt indent macro? use-macro?)
  (let ((macro-name (string-append
		     "EXTRACT_" (string-upcase (gen-sym ifmt))
		     "_CODE"))
	(ifields (/extract-insert-subfields (ifmt-ifields ifmt))))
    (if use-macro?
	(string-list indent macro-name "\n")
	(let ((indent (if macro? (string-append indent "  ") indent)))
	  (string-list
	   (if macro?
	       (string-list "#define " macro-name " \\\n")
	       "")
	   indent "length = "
	   (number->string (bits->bytes (ifmt-length ifmt)))
	   ";"
	   (if macro? " \\\n" "\n")
	   (gen-extract-ifields ifields (ifmt-length ifmt) indent macro?)
	   ; The last line doesn't have a trailing '\\'.
	   "\n"
	   ))))
)

; Instruction format utilities.

(define (gen-sfmt-enum-decl sfmt-list)
  (gen-enum-decl "@@prefix@@_sfmt_type"
		 "semantic formats in cpu family @@cpu@@"
		 "@@PREFIX@@_"
		 (map (lambda (sfmt) (cons (obj:name sfmt) nil))
		      sfmt-list))
)
@


1.19
log
@	Specify isa(s) when doing ifield, operand, insn lookups.
	ACU = all callers updated.
	* attr.scm (/attr-eval): Call rtx-value instead of rtx-eval-with-estate.
	* enum.scm (define-full-insn-enum): Pass isa-name-list to
	current-ifld-lookup.
	* html.scm (get-insn-properties): Pass isa-name-list to
	current-op-lookup.
	* ifield.scm (/ifld-parse-follows): New arg isas, ACU.
	* insn.scm (/parse-insn-format-symbol): New arg isa-name-list, ACU.
	(/parse-insn-format-list, /parse-insn-iformat-iflds): Ditto.
	(/parse-insn-format, syntax-break-out): Ditto.
	* mach.scm (obj-filter-by-isa): New function.
	(current-ifld-lookup): New optional arg maybe-isa-name-list.
	(/ifld-already-defined?, /op-already-defined?): Simplify.
	(current-op-lookup): New optional arg maybe-isa-name-list.
	(current-insn-lookup): New arg isa-name-list, ACU.
	(/insn-already-defined?, /minsn-already-defined?): Simplify.
	(current-minsn-lookup): New arg isa-name-list, ACU.
	* minsn.scm (/minsn-compute-iflds): Pass isa-name-list to
	current-op-lookup.
	* opc-itab.scm (compute-syntax): New arg isa-name-list, ACU.
	(gen-syntax-entry): Ditto.
	* operand.scm (/operand-parse): Pass isa-name-list to
	current-ifld-lookup.
	(/derived-parse-encoding): New arg isa-name-list, ACU.
	(/derived-parse-ifield-assertion): Ditto.
	(/derived-operand-parse): Pass isa-name-list to current-op-lookup.
	(/anyof-parse-choice): Ditto.
	(anyof-satisfies-assertions?): Pass context to rtx-solve.
	(/anyof-merge-syntax): New arg container, ACU.
	(operand-builtin!): Add pc to all isas.
	* rtl-c.scm (estate-make-for-rtl-c): Delete arg extra-vars-alist, ACU.
	(estate-make-for-rtl-c++, rtl-c-expr-parsed): Ditto.
	(rtl-c-parsed, rtl-c++-parsed): Ditto.
	(rtl-c): New arg isa-name-list, ACU.
	(rtl-c-expr, rtl-c++): Ditto.
	(closure): New arg isa-name-list, ACU.
	* rtl-traverse.scm (/make-cstate): New arg isa-name-list, ACU.
	(/cstate-isas): New function.
	(/rtx-canon-symbol-list): New function.
	(/rtx-canon-env-stack): Renamed from /rtx-canon-env, ACU.
	updated.
	(/rtx-make-canon-table): Rename ENV to ENVSTACK, new entry SYMBOLLIST.
	(/rtx-canon-rtx-operand): Pass isa list to current-op-lookup.
	(/rtx-canon-rtx-ref, /rtx-canon): Ditto.
	(rtx-canonicalize): New arg isa-name-list, ACU.
	(rtx-canonicalize-stmt): Delete.
	(tstate-make): New arg isas, ACU.
	(tstate-isas, tstate--set-isas!): New functions.
	(tstate-env-stack): Renamed from tstate-env, ACU.
	(tstate-set-env-stack!): Renamed from tstate-set-env!, ACU.
	(tstate-make-closure): Renamed from tstate-new-env, new arg
	isa-name-list, ACU.
	(/rtx-traverse-env): Delete.
	(/rtx-make-traverser-table): Rename ENV to ENVSTACK, new entry
	SUMBOLLIST.
	(/rtx-traverse): Include conditional flag in dump output.
	Update isa,envstack for closures.  Pass isa list to current-op-lookup.
	(<eval-state>): New member isas.  Rename env to env-stack.
	(<eval-state> vmake!): Handle #:isas.  #:env renamed to #:env-stack.
	(<eval-state>): New getter/setter for isas.  Rename env getter/setter
	to env-stack.
	(estate-make-for-eval): Provide #:isas.
	(estate-make-closure): Renamed from estate-new-env.  New arg
	isa-name-list, ACU.
	* rtl-xform.scm (/rtx-simplify-expr-fn): Handle closures.
	(/rtx-trim-args): ENV renamed to ENVSTACK.  Ad ITERATION, SYMBOLLIST.
	(/rtx-trim-for-doc): Handle closures.
	* rtl.scm (/rtx-valid-types): Rename ENV to ENVSTACK.  Add ITERATION,
	SYMBOLLIST.
	(rtx-env-var-list): Delete.
	(rtx-env-make): Handle already-compiled environments.
	(rtx-var-alist-to-env): New function.
	(rtx-var-alist-to-closure-env-stack, rtx-make-env-stack): New functions.
	(rtx-env-stack-dump): Renamed from rtx-env-dump, ACU.
	(rtx-operand-obj): New arg isa-name-list, ACU.
	(rtx-closure-isas, rtx-closure-env-stack, rtx-closure-expr): New
	functions.
	* rtx-funcs.scm (closure): New arg isa-name-list, reorder args, ACU.
	* sem-frags.scm (<sfrag>): Delete member compiled-semantics.
	(/frag-compute-desired-frags): Minor simplification.
	(/frag-pick-best): Ditto.
	* sid-cpu.scm (gen-semantic-code): Require canonical rtl.
	(/gen-sfrag-code): Update.
	* sim-cpu.scm (gen-semantic-code): Require canonical rtl.
	* utils-cgen.scm (sanitize): New arg isa-name-list, ACU.
	* utils.scm (non-null-intersection?): New function.
@
text
@d89 1
d91 1
a91 1
			  ((INT) "INT")
d131 2
a132 1
		   (if lsb0? "LSB0" "MSB0")
d138 3
a140 2
		       "_INT ("
		       "_UINT (")
@


1.18
log
@	* xc16x.cpu (h-cr): New hardware.
	(muls): Comment out parts that won't compile, add fixme.
	(mulu, divl, divlu, jmpabs, jmpa-, jmprel, jbc, jnbs, callr): Ditto.
	(scxti, scxtmg, scxtm, bclear, bclr18, bset19, bitset, bmov): Ditto.
	(bmovn, band, bor, bxor, bcmp, bfldl, bfldh): Ditto.

	Rewrite rtl processing to require it to be "canonicalized" first,
	and write a full canonicalizer / expression checker.
	Remove all appearances of DFLT in canonical rtl.
	* attr.scm (/attr-eval atval owner): Call rtx-canonicalize,
	then rtx-simplify.
	* iformat.scm (ifmt-analyze) Use canonical semantics.
	* insn (<insn>): New member canonical-semantics.
	* mach.scm (<arch>): New member multi-insns-instantiated?.
	(/instantiate-multi-insns!): New function.
	(/canonicalize-insns!): New function.
	(arch-analyze-insns!): Canonicalize insn semantics before processing
	them.
	* mode.scm (/mode-set-word-params!): New function.
	(mode-void?): New function.
	(mode-compatible?): VOID is compatible with VOID.
	(/mode-word-sizes-defined?): New global.
	(mode-set-word-modes!): Use/set it.
	(mode-ensure-word-sizes-defined): Update.
	(mode-builtin!): New builtin "modes" SYM, INSN, MACH.
	Redo WI/UWI/AI/IAI handling.
	(op:new-mode): No longer accept DFLT.
	(<derived-operand> constructor): Ensure all fields are initialized.
	(<anyof-operand> constructor): Ditto.
	(/derived-parse-ifield-assertion): Delete arg `args'.
	All callers updated.
	* rtl-c.scm (<rtl-c-eval-state>): New member `for-insn?'.
	(rtl-c): Call rtx-canonicalize instead of rtx-compile.
	(rtl-c-expr, rtl-c++): Ditto.
	(/rtl-c-get): Use mode of operand, not containing expression.
	(rtl-c-set-quiet, rtl-c-set-trace): Remove DFLT support.
	(/rtx-use-sem-fn?): Don't check for (insn? owner), check
	estate-for-insn? instead.
	(s-unop): Use mode of expression, not first operand.
	(s-binop, s-binop-with-bit, s-shop, s-cmpop): Ditto.
	(s-sequence): Remove DFLT support.
	(ifield): Use mode of expression, not UINT.
	(pc): Comment out, unused.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	(set, set-quiet): Pass src to rtl-c-set-{trace,quiet} for expansion.
	* rtl-traverse.scm (/rtx-canon-debug?): New global.
	(/make-cstate): New function.
	(/cstate-context, /cstate-outer-expr): New functions.
	(/rtx-canon-error): New function.
	(/rtx-lookup-hw, /rtx-pick-mode, /rtx-pick-mode3, /rtx-pick-op-mode,
	/rtx-get-last-cond-case-rtx): New functions.
	(/rtx-canon-*): New functions.
	(/rtx-canner-table, /rtx-operand-canoners): New globals.
	(/rtx-make-canon-table, /rtx-special-expr-canoners): New functions.
	(/rtx-option, /rtx-option-list?): Rewrite.
	(rtx-munge-mode&options): Replaces /rtx-munge-mode&options.
	Rewritten, all callers updated.
	(/rtx-canon-expr, /rtx-canon): New functions.
	(rtx-canonicalize): Move here from rtl-xform.scm and rewrite.
	(rtx-canonicalize-stmt): New function.
	(tstate-make): Remove arg `set?'.  All callers updated.
	(tstate-new-set?): Delete.
	(/rtx-traverse-options, /rtx-traverse-*mode): Delete,
	moved to /rtx-canon-*.
	(/rtx-traverse-normal-operand): New function.
	(/rtx-traverse-rtx-list): Delete arg `mode', all callers updated.
	(/rtx-traverse-rtx, /rtx-traverse-setrtx,, /rtx-traverse-testrtx,
	/rtx-traverse-condrtx, /rtx-traverse-casertx, /rtx-traverse-locals,
	/rtx-traverse-iteration, /rtx-traverse-env, /rtx-traverse-attrs):
	Ditto.
	(/rtx-traverse-symbol, /rtx-traverse-string, /rtx-traverse-number,
	/rtx-traverse-symornum, /rtx-traverse-object): Delete.
	(/rtx-make-traverser-table): Update.
	(/rtx-traverse-operands): Remove mode processing, now done during
	canonicalization.
	(/rtx-traverse-expr): Delete arg `mode', all callers updated.
	(/rtx-traverse): Ditto.
	(rtx-init-traverser-tables!): New function.
	* rtl-xform (/rtx-verify-no-dflt-modes-expr-fn): New function.
	(rtx-verify-no-dflt-modes): New function.
	(/rtx-simplify-expr-fn): Update, `arg' mode deleted.
	(rtx-simplify-insn): Use insn-canonical-semantics.
	(rtx-canonicalize): Moved to rtl-traverse.scm.
	(/compile-expr-fn, rtx-compile): Delete.
	(/rtx-trim-rtx-list): New function.
	(/rtx-trim-for-doc): Handle set, if.
	* rtl.scm (<rtx-func>): New members result-mode, matchexpr-index.
	(/rtx-valid-mode-types): Update.
	(/rtx-valid-matches): Update.
	(/rtx-find-matchexpr-index): New function.
	(rtx-lookup): Require rtx-kind to be the rtx name.
	(def-rtx-node): New arg result-mode, all callers updated.
	(def-rtx-syntax-node, def-rtx-operand-node): Ditto.
	(rtx-lazy-sem-mode): Delete.
	(/rtx-closure-make): New arg `mode', all callers updated.
	(rtx-make-ifield, rtx-make-operand, rtx-make-local): Ditto.
	(rtx-operand-obj): Rewrite.
	(rtx-make-xop): New functions.
	(/hw): Renamed from `hw', all callers updated.
	Use the correct mode instead of DFLT for the index.
	(rtl-builtin!): Call rtx-init-traversal-tables!.
	(rtl-finish!): Update.
	* rtx-funcs.scm (all rtx functions): New parameter: result-mode.
	Update mode arg-type.
	(pc): Comment out.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	* sem-frags.scm (/frag-hash-compute!): Update, mode arg deleted.
	(/frag-cost-compute!): Ditto.
	* semantics.scm (/build-operand!): Delete args op-name, op.
	New arg op-expr.  All callers updated.
	(/build-mem-operand!): Remove DFLT support.
	(semantic-compile): Update process-expr!, mode arg deleted.
	* sid-cpu.scm (gen-semantic-code): Specify #:for-insn? in
	rtl-c++ calls.
	(/gen-sem-case, /gen-sfrag-code): Ditto.
	* sid.scm (/op-gen-set-trace1): Renamed from /op-gen-set-trace.
	(/op-gen-set-trace): New function.  If not doing profiling,
	call /op-gen-set-quiet.
	* sim-cpu.scm (gen-semantic-code): Specify #:for-insn? in rtl-c calls.
	* utils-gen.scm (/gen-ifld-extract-base): Update call to rtl-c.
	(/gen-ifld-extract-beyond, gen-multi-ifld-extract): Ditto.
	* utils.scm (find-first-index): New function.
	* doc/rtl.texi: Delete docs for `attr'.  Add `int-attr'.
@
text
@d110 2
a111 1
	(rtl-c DFLT (cadr decode)
d114 1
d228 2
a229 1
	 (rtl-c DFLT (cadr decode)
d232 1
d263 2
a264 1
		  (rtl-c VOID (multi-ifld-extract f) nil
d270 2
a271 1
		       (rtl-c DFLT (cadr decode-proc)
d274 1
@


1.17
log
@	* dev.scm (*): Change default verbosity level to 2.

	* ifield.scm (<ifield> pretty-print): New method.
	(ifld-pretty-print): New function.
	(<multi-ifield> pretty-print): New method.

	* ifield.scm (<ifield> field-start): Delete word-len arg.
	All callers updated.
	(ifld-start): Ditto.
	(<multi-ifield> field-start): Ditto.
	* operand.scm (<hw-index> field-start): Ditto.
@
text
@d110 1
a110 1
	(rtl-c VOID (cadr decode)
d226 1
a226 1
	 (rtl-c VOID (cadr decode)
d258 1
a258 1
		  ;; First, the block that extract the multi-ifield into the ifld variable
d261 1
a261 1
		  ;; Next, the decode routine that modifies it
d265 1
a265 1
		       (rtl-c VOID (cadr decode-proc)
@


1.16
log
@	* ifield.scm (ifld-beyond-base?): Remove args base-bitsize,
	total-bitsize.  All callers updated.
	* insn.scm (<insn>): Rename member ifld-values to /insn-value.
	New member /insn-base-value.
	(insn-base-value): New function.
	* mach.scm (/sanity-check-insns): New function.
	(arch-analyze-insns!): Call it.
@
text
@d97 1
a97 2
			; ??? Is passing total-length right here?
			(number->string (+ (ifld-start f total-length)
d189 1
a189 1
   (let ((start (+ (ifld-start f total-length) (ifld-word-offset f)))
@


1.15
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d242 1
a242 1
       (if (ifld-beyond-base? f base-length total-length)
@


1.14
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d85 1
a85 1
(define (-gen-ifld-extract-base f total-length base-value)
d117 1
a117 1
; Subroutine of -gen-ifld-extract-beyond to extract the relevant value
d120 1
a120 1
(define (-gen-extract-word word-name word-start word-length
d187 1
a187 1
(define (-gen-ifld-extract-beyond f base-length total-length var-list)
d211 1
a211 1
			     (cons (-gen-extract-word var-name
d241 1
a241 1
       (-gen-ifld-extract-base f total-length base-value)
d243 2
a244 2
	   (-gen-ifld-extract-beyond f base-length total-length var-list)
	   (-gen-ifld-extract-base f base-length base-value)))
d285 1
a285 1
; Subroutine of gen-extract-ifields to compute arguments for -extract-chunk
d295 1
a295 1
(define (-extract-chunk-specs base-length total-length alignment)
d314 1
a314 1
		; and -gen-extract-word already knows how to find what
d325 1
a325 1
(define (-extract-insert-subfields iflds)
d350 1
a350 1
	 (chunk-specs (-extract-chunk-specs base-length total-length
d386 1
a386 1
	(ifields (-extract-insert-subfields (ifmt-ifields ifmt))))
d408 1
a408 1
(define (-extract-chunk offset bits var-name macro?)
d424 1
a424 1
(define (-gen-extract-beyond-var-list base-length var-prefix chunk-specs lsb0?)
d467 1
a467 1
	 (chunk-specs (-extract-chunk-specs base-length total-length
d475 1
a475 1
			      (-extract-chunk (car chunk-spec)
d492 1
a492 1
	     (-gen-extract-beyond-var-list base-length "word_"
d498 1
a498 1
	     (-gen-extract-beyond-var-list base-length "word_"
d516 1
a516 1
	(ifields (-extract-insert-subfields (ifmt-ifields ifmt))))
@


1.13
log
@* sid.scm (gen-ifetch): Require BITSIZE to be exactly the size
fetched by one of our GETIMEM* methods.
* utils-gen.scm (-extract-chunk-specs): Always fetch full
base-insn-sized chunks.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2001, 2005 Red Hat, Inc.
@


1.13.6.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2001, 2005, 2009 Red Hat, Inc.
@


1.12
log
@2005-02-16  Dave Brolley  <brolley@@redhat.com>

        * utils.scm: Update copyright years.
        * utils-gen.scm (gen-ifld-extract): Pass base-length to -gen-ifld-extrac
t-base.
        * sid.scm (gen-ifetch): Handle the case where bitsize == 24.
@
text
@d311 6
a316 1
		(cons (cons start (min chunk-length remaining))
@


1.11
log
@Fix compile time warning messages
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2001 Red Hat, Inc.
d244 1
a244 2
	   (-gen-ifld-extract-base f (min base-length total-length)
				   base-value)))
@


1.10
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@d17 1
a17 1
   "_attr [] = \n{\n  {\"integer\", " (number->string (attr-default attr)) "},\n  { 0, 0 }\n};\n\n" ))
d30 1
a30 1
   "[] =\n{\n"
@


1.9
log
@	* Makefile.am (srcroot): New var.
	(html): New rule.
	* Makefile.in: Regenerate.
	* cgen-doc.scm: New file.
	* html.scm: New file.
	* gen-all-doc: New file.
	* dev.scm (cload): Handle DOC application.
	(load-doc): New fn.
	* machs.scm (machs-for-cpu): New fn.
	* model.scm (models-for-cpu): New fn.
	* utils.scm (gen-c-copyright): Renamed from gen-copyright.
	All uses updated.
	(iota): Rewrite to be identical to pmacro version.  All uses updated.
	* utils-cgen.scm (alpha-sort-obj-list): New fn.
@
text
@d22 1
a22 1
		 (string-append (obj:name attr) "_")
d387 1
a387 1
					(string-append " " (obj:name fld)))
@


1.8
log
@2003-01-07  Graydon Hoare  <graydon@@redhat.com>

	* utils-gen.scm (attr-int-gen-defn): Define.
@
text
@d367 1
a367 1
			   (iota 1 (length chunk-specs))))
d427 1
a427 1
	     (iota 1 (length chunk-specs))
d478 1
a478 1
			    (iota 1 (length chunk-specs))))
@


1.7
log
@	* utils-gen.scm (-gen-extract-word): Handle lsb0?.
@
text
@d14 4
a17 1
(define (attr-int-gen-defn attr) "")
@


1.6
log
@2001-11-14  Dave Brolley  <brolley@@redhat.com>

	* utils-gen.scm (-gen-extract-word): Correct computation of the length
	of the field being extracted.
@
text
@d117 2
a118 1
(define (-gen-extract-word word-name word-start word-length start length
d120 4
a123 4
  ; ??? lsb0?
  (let ((word-end (+ word-start word-length))
	(end (+ start length))
	(base (if (< start word-start) word-start start)))
d126 1
a126 1
		   (if (current-arch-insn-lsb0?) "LSB0" "MSB0")
d129 2
a130 1
			    (bitrange-overlap? start 1 word-start word-length
d134 1
d137 1
d140 9
a148 3
		   (number->string (if (< start word-start)
				       0
				       (- start word-start)))
d150 1
d155 1
@


1.5
log
@2001-01-06  Ben Elliston  <bje@@redhat.com>

	* utils-gen.scm (gen-sfmt-enum-decl): Use @@prefix@@ and @@PREFIX@@
	instead of @@cpu@@ and @@CPU@@ to generically prefix symbol names.
	* sim-cpu.scm (-gen-sem-fn-table-entry): Likewise.
	(-gen-semantic-fn-table): Likewise.
	(-gen-scache-semantic-fn): Likewise.
	(-gen-no-scache-semantic-fn): Likewise.
	(cgen-read.c): Likewise.
	(cgen-sem-switch.c): Likewise.
	* desc-cpu.scm (cgen-desc.c): Use @@arch@@, not @@prefix@@, since this
	is a filename prefix.
	* sim-decode.scm (IDESC-TABLE-VAR): Use @@prefix@@, et al.
	(-gen-decode-insn-globals): Likewise.
	(-gen-idesc-decls): Likewise.
	(cgen-decode.h): Likewise.
	(cgen-decode.c): Likewise.
	* sim.scm (gen-cpu-insn-enum-decl): Likewise.
	(gen-cpu-insn-enum): Likewise.
	(sim-finish!): Likewise.
@
text
@d121 2
a122 1
	(end (+ start length)))
d141 2
a142 2
				       (- word-end end)
				       word-length))
@


1.4
log
@2000-10-06  Dave Brolley  <brolley@@redhat.com>

	* utils-gen.scm (-gen-ifld-extract-base): Compute start position as
	ifld-start + ifld-word-offset.
	(gen-ifld-extract): Check adata-integral-insn? before checking whether
	the field is beyond the base number of bits.
	(gen-define-ifields): Use a base-length of 32 if adata-integral-insn?.
	(gen-extract-ifields): Ditto.
	* gas-test.scm (gentest): Generate backslashes before '[' and ']'
	characters in the regular expression.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
d517 1
a517 1
  (gen-enum-decl "@@cpu@@_sfmt_type"
d519 1
a519 1
		 "@@CPU@@_"
@


1.3
log
@* multi-ifields support in simulators

2000-09-06  Frank Ch. Eigler  <fche@@redhat.com>

	* utils-gen.scm (gen-multi-ifld-extract): Handle case of multi-ifield
	with decode proc.
@
text
@d95 2
a96 1
			(number->string (ifld-start f total-length)) ", "
d224 6
a229 7
   (if (ifld-beyond-base? f base-length total-length)
       (-gen-ifld-extract-beyond f base-length total-length var-list)
       (-gen-ifld-extract-base f 
			       (if (adata-integral-insn? CURRENT-ARCH)
				   total-length
				   (min base-length total-length))
			       base-value))
d327 3
a329 1
  (let* ((base-length (state-base-insn-bitsize))
d444 3
a446 1
  (let* ((base-length (state-base-insn-bitsize))
@


1.2
log
@2000-08-29  Dave Brolley  <brolley@@redhat.com>

	* utils-gen.scm (gen-ifld-extract): Pass total-len if
	adata-integral-insn is true for this architecture.
@
text
@d241 17
a257 9
  (let* ((extract (rtl-c VOID (multi-ifld-extract f) nil
			 #:rtl-cover-fns? #f #:ifield-var? #t))
	 (decode-proc (ifld-decode f))
	 (decode (if decode-proc
		     (rtl-c VOID (cadr decode-proc)
			    (list (list (caar decode-proc) 'UINT extract)
				  (list (cadar decode-proc) 'IAI "pc"))
			    #:rtl-cover-fns? #f #:ifield-var? #t)
		     extract)))
@


1.1
log
@Initial revision
@
text
@d225 5
a229 1
       (-gen-ifld-extract-base f (min base-length total-length) base-value))
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
