head	1.18;
access;
symbols
	sid-snapshot-20180601:1.18
	cgen-snapshot-20180601:1.18
	sid-snapshot-20180501:1.18
	cgen-snapshot-20180501:1.18
	sid-snapshot-20180401:1.18
	cgen-snapshot-20180401:1.18
	sid-snapshot-20180301:1.18
	cgen-snapshot-20180301:1.18
	sid-snapshot-20180201:1.18
	cgen-snapshot-20180201:1.18
	sid-snapshot-20180101:1.18
	cgen-snapshot-20180101:1.18
	sid-snapshot-20171201:1.18
	cgen-snapshot-20171201:1.18
	sid-snapshot-20171101:1.18
	cgen-snapshot-20171101:1.18
	sid-snapshot-20171001:1.18
	cgen-snapshot-20171001:1.18
	sid-snapshot-20170901:1.18
	cgen-snapshot-20170901:1.18
	sid-snapshot-20170801:1.18
	cgen-snapshot-20170801:1.18
	sid-snapshot-20170701:1.18
	cgen-snapshot-20170701:1.18
	sid-snapshot-20170601:1.18
	cgen-snapshot-20170601:1.18
	sid-snapshot-20170501:1.18
	cgen-snapshot-20170501:1.18
	sid-snapshot-20170401:1.18
	cgen-snapshot-20170401:1.18
	sid-snapshot-20170301:1.18
	cgen-snapshot-20170301:1.18
	sid-snapshot-20170201:1.18
	cgen-snapshot-20170201:1.18
	sid-snapshot-20170101:1.18
	cgen-snapshot-20170101:1.18
	sid-snapshot-20161201:1.18
	cgen-snapshot-20161201:1.18
	sid-snapshot-20161101:1.18
	cgen-snapshot-20161101:1.18
	sid-snapshot-20160901:1.18
	cgen-snapshot-20160901:1.18
	sid-snapshot-20160801:1.18
	cgen-snapshot-20160801:1.18
	sid-snapshot-20160701:1.18
	cgen-snapshot-20160701:1.18
	sid-snapshot-20160601:1.18
	cgen-snapshot-20160601:1.18
	sid-snapshot-20160501:1.18
	cgen-snapshot-20160501:1.18
	sid-snapshot-20160401:1.18
	cgen-snapshot-20160401:1.18
	sid-snapshot-20160301:1.18
	cgen-snapshot-20160301:1.18
	sid-snapshot-20160201:1.18
	cgen-snapshot-20160201:1.18
	sid-snapshot-20160101:1.18
	cgen-snapshot-20160101:1.18
	sid-snapshot-20151201:1.18
	cgen-snapshot-20151201:1.18
	sid-snapshot-20151101:1.18
	cgen-snapshot-20151101:1.18
	sid-snapshot-20151001:1.18
	cgen-snapshot-20151001:1.18
	sid-snapshot-20150901:1.18
	cgen-snapshot-20150901:1.18
	sid-snapshot-20150801:1.18
	cgen-snapshot-20150801:1.18
	sid-snapshot-20150701:1.18
	cgen-snapshot-20150701:1.18
	sid-snapshot-20150601:1.18
	cgen-snapshot-20150601:1.18
	sid-snapshot-20150501:1.18
	cgen-snapshot-20150501:1.18
	sid-snapshot-20150401:1.18
	cgen-snapshot-20150401:1.18
	sid-snapshot-20150301:1.18
	cgen-snapshot-20150301:1.18
	sid-snapshot-20150201:1.18
	cgen-snapshot-20150201:1.18
	sid-snapshot-20150101:1.18
	cgen-snapshot-20150101:1.18
	sid-snapshot-20141201:1.18
	cgen-snapshot-20141201:1.18
	sid-snapshot-20141101:1.18
	cgen-snapshot-20141101:1.18
	sid-snapshot-20141001:1.18
	cgen-snapshot-20141001:1.18
	sid-snapshot-20140901:1.18
	cgen-snapshot-20140901:1.18
	sid-snapshot-20140801:1.18
	cgen-snapshot-20140801:1.18
	sid-snapshot-20140701:1.18
	cgen-snapshot-20140701:1.18
	sid-snapshot-20140601:1.18
	cgen-snapshot-20140601:1.18
	sid-snapshot-20140501:1.18
	cgen-snapshot-20140501:1.18
	sid-snapshot-20140401:1.18
	cgen-snapshot-20140401:1.18
	sid-snapshot-20140301:1.18
	cgen-snapshot-20140301:1.18
	sid-snapshot-20140201:1.18
	cgen-snapshot-20140201:1.18
	sid-snapshot-20140101:1.18
	cgen-snapshot-20140101:1.18
	sid-snapshot-20131201:1.18
	cgen-snapshot-20131201:1.18
	sid-snapshot-20131101:1.18
	cgen-snapshot-20131101:1.18
	sid-snapshot-20131001:1.18
	cgen-snapshot-20131001:1.18
	sid-snapshot-20130901:1.18
	cgen-snapshot-20130901:1.18
	sid-snapshot-20130801:1.18
	cgen-snapshot-20130801:1.18
	sid-snapshot-20130701:1.18
	cgen-snapshot-20130701:1.18
	sid-snapshot-20130601:1.18
	cgen-snapshot-20130601:1.18
	sid-snapshot-20130501:1.18
	cgen-snapshot-20130501:1.18
	sid-snapshot-20130401:1.18
	cgen-snapshot-20130401:1.18
	sid-snapshot-20130301:1.18
	cgen-snapshot-20130301:1.18
	sid-snapshot-20130201:1.18
	cgen-snapshot-20130201:1.18
	sid-snapshot-20130101:1.18
	cgen-snapshot-20130101:1.18
	sid-snapshot-20121201:1.18
	cgen-snapshot-20121201:1.18
	sid-snapshot-20121101:1.18
	cgen-snapshot-20121101:1.18
	sid-snapshot-20121001:1.18
	cgen-snapshot-20121001:1.18
	sid-snapshot-20120901:1.18
	cgen-snapshot-20120901:1.18
	sid-snapshot-20120801:1.18
	cgen-snapshot-20120801:1.18
	sid-snapshot-20120701:1.18
	cgen-snapshot-20120701:1.18
	sid-snapshot-20120601:1.18
	cgen-snapshot-20120601:1.18
	sid-snapshot-20120501:1.18
	cgen-snapshot-20120501:1.18
	sid-snapshot-20120401:1.18
	cgen-snapshot-20120401:1.18
	sid-snapshot-20120301:1.18
	cgen-snapshot-20120301:1.18
	sid-snapshot-20120201:1.18
	cgen-snapshot-20120201:1.18
	sid-snapshot-20120101:1.18
	cgen-snapshot-20120101:1.18
	sid-snapshot-20111201:1.18
	cgen-snapshot-20111201:1.18
	sid-snapshot-20111101:1.18
	cgen-snapshot-20111101:1.18
	sid-snapshot-20111001:1.18
	cgen-snapshot-20111001:1.18
	sid-snapshot-20110901:1.18
	cgen-snapshot-20110901:1.18
	sid-snapshot-20110801:1.18
	cgen-snapshot-20110801:1.18
	sid-snapshot-20110701:1.18
	cgen-snapshot-20110701:1.18
	sid-snapshot-20110601:1.18
	cgen-snapshot-20110601:1.18
	sid-snapshot-20110501:1.18
	cgen-snapshot-20110501:1.18
	sid-snapshot-20110401:1.18
	cgen-snapshot-20110401:1.18
	sid-snapshot-20110301:1.18
	cgen-snapshot-20110301:1.18
	sid-snapshot-20110201:1.18
	cgen-snapshot-20110201:1.18
	sid-snapshot-20110101:1.18
	cgen-snapshot-20110101:1.18
	sid-snapshot-20101201:1.18
	cgen-snapshot-20101201:1.18
	sid-snapshot-20101101:1.18
	cgen-snapshot-20101101:1.18
	sid-snapshot-20101001:1.18
	cgen-snapshot-20101001:1.18
	sid-snapshot-20100901:1.18
	cgen-snapshot-20100901:1.18
	sid-snapshot-20100801:1.18
	cgen-snapshot-20100801:1.18
	sid-snapshot-20100701:1.18
	cgen-snapshot-20100701:1.18
	sid-snapshot-20100601:1.18
	cgen-snapshot-20100601:1.18
	sid-snapshot-20100501:1.18
	cgen-snapshot-20100501:1.18
	sid-snapshot-20100401:1.18
	cgen-snapshot-20100401:1.18
	sid-snapshot-20100301:1.18
	cgen-snapshot-20100301:1.18
	sid-snapshot-20100201:1.18
	cgen-snapshot-20100201:1.18
	sid-snapshot-20100101:1.18
	cgen-snapshot-20100101:1.18
	sid-snapshot-20091201:1.18
	cgen-snapshot-20091201:1.18
	sid-snapshot-20091101:1.16
	cgen-snapshot-20091101:1.16
	sid-snapshot-20091001:1.16
	cgen-snapshot-20091001:1.16
	arc-sim-20090309:1.7
	sid-snapshot-20090901:1.13
	cgen-snapshot-20090901:1.13
	sid-snapshot-20090801:1.11
	cgen-snapshot-20090801:1.11
	sid-snapshot-20090701:1.11
	cgen-snapshot-20090701:1.11
	dje-cgen-play1-branch:1.11.0.2
	dje-cgen-play1-branchpoint:1.11
	cgen-1_1-branch:1.7.0.6
	cgen-1_1-branchpoint:1.7
	sid-snapshot-20090601:1.7
	cgen-snapshot-20090601:1.7
	sid-snapshot-20090501:1.7
	cgen-snapshot-20090501:1.7
	sid-snapshot-20090401:1.7
	cgen-snapshot-20090401:1.7
	arc-insight_6_8-branch:1.7.0.4
	arc-insight_6_8-branchpoint:1.7
	sid-snapshot-20090301:1.7
	cgen-snapshot-20090301:1.7
	sid-snapshot-20090201:1.7
	cgen-snapshot-20090201:1.7
	sid-snapshot-20090101:1.7
	cgen-snapshot-20090101:1.7
	sid-snapshot-20081201:1.7
	cgen-snapshot-20081201:1.7
	sid-snapshot-20081101:1.7
	cgen-snapshot-20081101:1.7
	sid-snapshot-20081001:1.7
	cgen-snapshot-20081001:1.7
	sid-snapshot-20080901:1.7
	cgen-snapshot-20080901:1.7
	sid-snapshot-20080801:1.7
	cgen-snapshot-20080801:1.7
	sid-snapshot-20080701:1.7
	cgen-snapshot-20080701:1.7
	sid-snapshot-20080601:1.7
	cgen-snapshot-20080601:1.7
	sid-snapshot-20080501:1.7
	cgen-snapshot-20080501:1.7
	sid-snapshot-20080403:1.7
	sid-snapshot-20080401:1.7
	cgen-snapshot-20080401:1.7
	sid-snapshot-20080301:1.7
	cgen-snapshot-20080301:1.7
	sid-snapshot-20080201:1.7
	cgen-snapshot-20080201:1.7
	sid-snapshot-20080101:1.7
	cgen-snapshot-20080101:1.7
	sid-snapshot-20071201:1.7
	cgen-snapshot-20071201:1.7
	sid-snapshot-20071101:1.7
	cgen-snapshot-20071101:1.7
	sid-snapshot-20071001:1.7
	cgen-snapshot-20071001:1.7
	msnyder-fork-checkpoint-branch:1.7.0.2
	msnyder-fork-checkpoint-branchpoint:1.7
	sid-20020905-branchpoint:1.1.1.1
	sid-20020905-branch:1.1.1.1.0.6
	cagney_regbuf-20020515-branch:1.1.1.1.0.4
	cagney_regbuf-20020515-branchpoint:1.1.1.1
	cygnus_cvs_20020108_pre:1.1.1.1
	cgen-1-1-branch:1.1.1.1.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.18
date	2009.11.23.09.03.01;	author devans;	state Exp;
branches;
next	1.17;

1.17
date	2009.11.03.16.24.02;	author devans;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.23.22.30.19;	author devans;	state Exp;
branches;
next	1.15;

1.15
date	2009.09.12.17.34.15;	author devans;	state Exp;
branches;
next	1.14;

1.14
date	2009.09.07.22.17.34;	author devans;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.27.04.22.56;	author devans;	state Exp;
branches;
next	1.12;

1.12
date	2009.08.12.22.33.37;	author devans;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.22.15.46.18;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.22.06.58.59;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.22.05.14.09;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.27.20.31.12;	author jimb;	state Exp;
branches
	1.7.6.1;
next	1.6;

1.6
date	2005.01.20.22.57.10;	author jimb;	state Exp;
branches;
next	1.5;

1.5
date	2003.07.16.05.35.47;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.10.21.22.03;	author devans;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.15.07.25.02;	author devans;	state Exp;
branches;
next	1.2;

1.2
date	2002.12.20.06.39.04;	author devans;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.7.6.1
date	2009.06.24.14.57.46;	author devans;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.18
log
@	* hardware.scm (hw-pc?): New function.
	* ifield.scm (ifld-signed?): New function.
	* iformat.scm (ifmt-analyze): Call insn-cti-attr? instead of insn-cti?.
	* insn.scm (insn-cti-attr?): Renamed from insn-ctl?.
	(insn-cti?): New function.
	* rtl.scm (/hw): Create <pc> object for pcs.
	* semantics.scm (/build-reg-operand!): New args ref-type, sem-attrs.
	All callers updated.  Watch for sets to the pc.
	(semantic-attrs): Watch for sets to the pc.
	* sid.scm (<pc> cxmake-get): Handle raw-reg.
	* sim.scm (<pc> cxmake-get): Handle raw-reg.
	(<operand> cxmake-get): Add debugging printf.
	* utils-gen.scm (/gen-ifld-extract-base): Emit calls to
	EXTRACT_[LM]SB0_LG[SU]INT for values > 32 bits.
	(/gen-extract-word): Ditto.

	* utils.scm (gen-c-hex-constant): New function.
	* utils-sim.scm (/gen-decode-insn-entry): Call it.
@
text
@; Routines for instruction semantic analysis.
; Copyright (C) 2000, 2009 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.
;
; Semantic expression compilation.
; This is more involved than normal rtx compilation as we need to keep
; track of the inputs and outputs.  Various attributes that can be derived
; from the code are also computed.

; Subroutine of -rtx-find-op to determine if two modes are equivalent.
; Two modes are equivalent if they're equal, or if their sem-mode fields
; are equal.
; M1 and M2 are mode names.

(define (/rtx-mode-equiv? m1 m2)
  (or (eq? m1 m2)
      (let ((mode1 (mode:lookup m1))
	    (mode2 (mode:lookup m2)))
	(let ((s1 (mode:sem-mode mode1))
	      (s2 (mode:sem-mode mode2)))
	  (eq? (if s1 (obj:name s1) m1) (if s2 (obj:name s2) m2)))))
)

; Subroutine of semantic-compile to find OP in OP-LIST.
; OP-LIST is a list of operand expressions: (type expr mode name indx-sel).
; The result is the list element or #f if not found.
; TYPE is one of -op- reg mem.
; EXPR is the constructed `xop' rtx expression for the operand,
;   ignored in the search.
; MODE must match, as defined by /rtx-mode-equiv?.
; NAME is the hardware element name, ifield name, or '-op-'.
; INDX-SEL must match if present in either.
;
; ??? Does this need to take "conditionally-referenced" into account?

(define (/rtx-find-op op op-list)
  (let ((type (car op))
	(mode (caddr op))
	(name (cadddr op))
	(indx-sel (car (cddddr op))))
    ; The first cdr is to drop the dummy first arg.
    (let loop ((op-list (cdr op-list)))
      (cond ((null? op-list) #f)
	    ((eq? type (caar op-list))
	     (let ((try (car op-list)))
	       (if (and (eq? name (cadddr try))
			(/rtx-mode-equiv? mode (caddr try))
			(equal? indx-sel (car (cddddr try))))
		   try
		   (loop (cdr op-list)))))
	    (else (loop (cdr op-list))))))
)

; Subroutine of semantic-compile to determine how the operand in
; position OP-POS of EXPR is used.
; The result is one of 'use, 'set, 'set-quiet.
; "use" means "input operand".

(define (/rtx-ref-type expr op-pos)
  ; operand 0 is the option list, operand 1 is the mode
  ; (if you want to complain, fine, it's not like it would be unexpected)
  (if (= op-pos 2)
      (case (car expr)
	((set) 'set)
	((set-quiet clobber) 'set-quiet)
	(else 'use))
      'use)
)

; Subroutine of semantic-compile:process-expr!, to simplify it.
; Looks up the operand in the current set, returns it if found,
; otherwise adds it.
; REF-TYPE is one of 'use, 'set, 'set-quiet.
; Adds COND-CTI/UNCOND-CTI to SEM-ATTRS if the operand is a set of the pc.

(define (/build-operand! op-expr tstate ref-type op-list sem-attrs)
  (let* ((orig-op (rtx-operand-obj op-expr (obj-isa-list (tstate-owner tstate))))
	 (mode (rtx-mode op-expr))
	 ;; We need a copy as we'll be modifying it.
	 (op (op:new-mode orig-op mode))
	 ;; The first #f is a placeholder for the object.
	 (try (list '-op- #f mode (rtx-arg1 op-expr) #f))
	 (existing-op (/rtx-find-op try op-list)))

    (assert (not (eq? (op:mode-name op) 'DFLT)))

    (if (and (pc? op)
	     (memq ref-type '(set set-quiet)))
	(append! sem-attrs
		 (list (if (tstate-cond? tstate) 'COND-CTI 'UNCOND-CTI))))

    ; If already present, return the object, otherwise add it.
    (if existing-op

	(cadr existing-op)

	; We can't set the operand number yet 'cus we don't know it.
	; However, when it's computed we'll need to set all associated
	; operands.  This is done by creating shared rtx (a la gcc) - the
	; operand number then need only be updated in one place.

	(begin
	  (op:set-cond?! op (tstate-cond? tstate))
	  ; Set the object rtx in `try', now that we have it.
	  (set-car! (cdr try) (rtx-make-xop op))
	  ; Add the operand to in/out-ops.
	  (append! op-list (list try))
	  (cadr try))))
)

; Subroutine of semantic-compile:process-expr!, to simplify it.
; REF-TYPE is one of 'use, 'set, 'set-quiet.
; Adds COND-CTI/UNCOND-CTI to SEM-ATTRS if the operand is a set of the pc.

(define (/build-reg-operand! expr tstate ref-type op-list sem-attrs)
  (let* ((hw-name (rtx-reg-name expr))
	 (hw (current-hw-sem-lookup-1 hw-name)))

    (if hw

	(let* ((mode (rtx-mode expr))
	       (indx-sel (rtx-reg-index-sel expr))
	       ; #f is a place-holder for the object (filled in later)
	       (try (list 'reg #f mode hw-name indx-sel))
	       (existing-op (/rtx-find-op try op-list)))

	  ;; FIXME: keep name h-pc hardwired?
	  (if (and (eq? 'h-pc hw-name)
		   (memq ref-type '(set set-quiet)))
	      (append! sem-attrs
		       (list (if (tstate-cond? tstate) 'COND-CTI 'UNCOND-CTI))))

	  ; If already present, return the object, otherwise add it.
	  (if existing-op

	      (cadr existing-op)

	      (let ((xop (apply reg (cons (tstate->estate tstate)
					  (cons mode
						(cons hw-name indx-sel))))))
		(op:set-cond?! xop (tstate-cond? tstate))
		; Set the object rtx in `try', now that we have it.
		(set-car! (cdr try) (rtx-make-xop xop))
		; Add the operand to in/out-ops.
		(append! op-list (list try))
		(cadr try))))

	(parse-error (tstate-context tstate) "unknown reg" expr)))
)

; Subroutine of semantic-compile:process-expr!, to simplify it.

(define (/build-mem-operand! expr tstate op-list)
  (let ((mode (rtx-mode expr))
	(indx-sel (rtx-mem-index-sel expr)))

    (let* ((try (list 'mem #f mode 'h-memory indx-sel))
	   (existing-op (/rtx-find-op try op-list)))

      ; If already present, return the object, otherwise add it.
      (if existing-op

	  (cadr existing-op)

	  (let ((xop (apply mem (cons (tstate->estate tstate)
				      (cons mode indx-sel)))))
	    (op:set-cond?! xop (tstate-cond? tstate))
	    ; Set the object in `try', now that we have it.
	    (set-car! (cdr try) (rtx-make-xop xop))
	    ; Add the operand to in/out-ops.
	    (append! op-list (list try))
	    (cadr try)))))
)

; Subroutine of semantic-compile:process-expr!, to simplify it.

(define (/build-ifield-operand! expr tstate op-list)
  (let* ((f-name (rtx-ifield-name expr))
	 (f (current-ifld-lookup f-name)))

    (if (not f)
	(parse-error (tstate-context tstate) "unknown ifield" f-name))

    (let* ((mode (obj:name (ifld-mode f)))
	   (try (list '-op- #f mode f-name #f))
	   (existing-op (/rtx-find-op try op-list)))

      ; If already present, return the object, otherwise add it.
      (if existing-op

	  (cadr existing-op)

	  (let ((xop (make <operand> (obj-location f)
			   f-name f-name
			   (atlist-cons (bool-attr-make 'SEM-ONLY #t)
					(obj-atlist f))
			   (obj:name (ifld-hw-type f))
			   mode
			   (make <hw-index> 'anonymous
				 'ifield (ifld-mode f) f)
			   nil #f #f)))
	    (set-car! (cdr try) (rtx-make-xop xop))
	    (append! op-list (list try))
	    (cadr try)))))
)

; Subroutine of semantic-compile:process-expr!, to simplify it.
;
; ??? There are various optimizations (both space usage in ARGBUF and time
; spent in semantic code) that can be done on code that uses index-of
; (see i960's movq insn).  Later.

(define (/build-index-of-operand! expr tstate op-list)
  (if (not (and (rtx? (rtx-index-of-value expr))
		(rtx-kind? 'operand (rtx-index-of-value expr))))
      (parse-error (tstate-context tstate)
		   "only `(index-of operand)' is currently supported"
		   expr))

  (let ((op (rtx-operand-obj (rtx-index-of-value expr)
			     (obj-isa-list (tstate-owner tstate)))))
    (let ((indx (op:index op)))
      (if (not (eq? (hw-index:type indx) 'ifield))
	  (parse-error (tstate-context tstate)
		       "only ifield indices are currently supported"
		       expr))
      (let* ((f (hw-index:value indx))
	     (f-name (obj:name f)))
	; The rest of this is identical to /build-ifield-operand!.
	(let* ((mode (obj:name (ifld-mode f)))
	       (try (list '-op- #f mode f-name #f))
	       (existing-op (/rtx-find-op try op-list)))

	  ; If already present, return the object, otherwise add it.
	  (if existing-op

	      (cadr existing-op)

	      (let ((xop (make <operand> (if (source-ident? f) (obj-location f) #f)
			       f-name f-name
			       (atlist-cons (bool-attr-make 'SEM-ONLY #t)
					    (obj-atlist f))
			       (obj:name (ifld-hw-type f))
			       mode
			       (make <hw-index> 'anonymous
				     'ifield
				     (ifld-mode f)
				     ; (send (op:type op) 'get-index-mode)
				     f)
			       nil #f #f)))
		(set-car! (cdr try) (rtx-make-xop xop))
		(append! op-list (list try))
		(cadr try)))))))
)

; Build the tstate known value list for INSN.
; This is built from the ifield-assertion list.

(define (insn-build-known-values insn)
  (let ((expr (insn-ifield-assertion insn)))
    (if expr
	(case (rtx-name expr)
	  ((eq)
	   (if (and (rtx-kind? 'ifield (rtx-cmp-op-arg expr 0))
		    (rtx-constant? (rtx-cmp-op-arg expr 1)))
	       (list (cons (rtx-ifield-name (rtx-cmp-op-arg expr 0))
			   (rtx-cmp-op-arg expr 1)))
	       nil))
	  ((member)
	   (if (rtx-kind? 'ifield (rtx-member-value expr))
	       (list (cons (rtx-ifield-name (rtx-member-value expr))
			   (rtx-member-set expr)))
	       nil))
	  (else nil))
	nil))
)

; Structure to record the result of semantic-compile.

(define (csem-make compiled-code inputs outputs attributes)
  (vector compiled-code inputs outputs attributes)
)

; Accessors.

(define (csem-code csem) (vector-ref csem 0))
(define (csem-inputs csem) (vector-ref csem 1))
(define (csem-outputs csem) (vector-ref csem 2))
(define (csem-attrs csem) (vector-ref csem 3))

; Traverse SEM-CODE, computing the input and output operands.
; The result is an object of four elements (built with csem-make).
; The first is a list of the canonical form of each element in SEM-CODE:
; operand and ifield elements specified without `operand' or `ifield' have it
; prepended, and operand numbers are computed for each operand.
; Operand numbers are needed when emitting "write" handlers for LIW cpus.
; Having the operand numbers available is also useful for efficient
; modeling: recording operand references can be done with a bitmask (one host
; insn), and the code to do the modeling can be kept out of the code that
; performs the insn.
; The second is the list of input <operand> objects.
; The third is the list of output <operand> objects.
; The fourth is an <attr-list> object of attributes that can be computed from
; the semantics.
; The possibilities are: UNCOND-CTI, COND-CTI, SKIP-CTI, DELAY-SLOT.
; ??? Combine *-CTI into an enum attribute.
;
; CONTEXT is a <context> object or #f if there is none.
; INSN is the <insn> object.
; SEM-CODE must be canonicalized rtl.
;
; ??? Specifying operand ordinals in the source would simplify this and speed
; it up.  On the other hand that makes the source form more complex.  Maybe the
; complexity will prove necessary, but following the goal of "incremental
; complication", we don't do this yet.
; Another way to simplify this and speed it up would be to add lists of
; input/output operands to the instruction description.
;
; ??? This calls rtx-simplify which calls rtx-traverse as it's simpler to
; simplify EXPR first, and then compile it.  On the other hand it's slower
; (two calls to rtx-traverse!).

(define (semantic-compile context insn sem-code)
  (assert (rtx? sem-code))

  (let*
      (
       ; These record the result of traversing SEM-CODE.
       ; They're lists of (type object mode name [args ...]).
       ; TYPE is one of: -op- reg mem.
       ; `-op-' is just something unique and is only used internally.
       ; OBJECT is the constructed <operand> object.
       ; The first element is just a dummy so that append! always works.
       (in-ops (list (list #f)))
       (out-ops (list (list #f)))

       ; List of attributes computed from SEM-CODE.
       ; The first element is just a dummy so that append! always works.
       (sem-attrs (list #f))

       ; Called for expressions encountered in SEM-CODE.
       ; Don't waste cpu here, this is part of the slowest piece in CGEN.
       (process-expr!
	(lambda (rtx-obj expr parent-expr op-pos tstate appstuff)
	  (case (car expr)

	    ;; NOTE: Despite the ! in, e.g., /build-reg-operand!,
	    ;; it does return a result.

	    ; Registers.
	    ((reg) (let ((ref-type (/rtx-ref-type parent-expr op-pos))
			 ; ??? could verify reg is a scalar
			 (regno (or (rtx-reg-number expr) 0)))
		     ; The register number is either a number or an
		     ; expression.
		     ; ??? This is a departure from GCC RTL that might have
		     ; significant ramifications.  On the other hand in cases
		     ; where it matters the expression could always be
		     ; required to reduce to a constant (or some such).
		     (cond ((number? regno) #t)
			   ((form? regno)
			    (rtx-traverse-operands rtx-obj expr tstate appstuff))
			   (else (parse-error (tstate-context tstate)
					      "invalid register number"
					      regno)))
		     (/build-reg-operand! expr tstate ref-type
					  (if (eq? ref-type 'use)
					      in-ops
					      out-ops)
					  sem-attrs)))

	    ; Memory.
	    ((mem) (let ((ref-type (/rtx-ref-type parent-expr op-pos)))
		     (rtx-traverse-operands rtx-obj expr tstate appstuff)
		     (/build-mem-operand! expr tstate
					  (if (eq? ref-type 'use)
					      in-ops
					      out-ops))))

	    ; Operands.
	    ((operand) (let ((ref-type (/rtx-ref-type parent-expr op-pos)))
			 (/build-operand! expr tstate ref-type
					  (if (eq? ref-type 'use)
					      in-ops
					      out-ops)
					  sem-attrs)))

	    ; Give operand new name.
	    ((name) (let ((result (/rtx-traverse (caddr expr) 'RTX
						 parent-expr op-pos tstate appstuff)))
		      (if (not (operand? result))
			  (error "name: invalid argument:" expr result))
		      (op:set-sem-name! result (cadr expr))
		      ; (op:set-num! result (caddr expr))
		      result))

	    ; Specify a reference to a local variable
	    ((local) expr) ; nothing to do

	    ; Instruction fields.
	    ((ifield) (let ((ref-type (/rtx-ref-type parent-expr op-pos)))
			(if (not (eq? ref-type 'use))
			    (parse-error (tstate-context tstate)
					 "can't set an `ifield'" expr))
			(/build-ifield-operand! expr tstate in-ops)))

	    ; Hardware indices.
	    ; For registers this is the register number.
	    ; For memory this is the address.
	    ; For constants, this is the constant.
	    ((index-of) (let ((ref-type (/rtx-ref-type parent-expr op-pos)))
			  (if (not (eq? ref-type 'use))
			      (parse-error (tstate-context tstate)
					   "can't set an `index-of'" expr))
			  (/build-index-of-operand! expr tstate in-ops)))

	    ; Machine generate the SKIP-CTI attribute.
	    ((skip) (append! sem-attrs (list 'SKIP-CTI)) #f)

	    ; Machine generate the DELAY-SLOT attribute.
	    ((delay) (append! sem-attrs (list 'DELAY-SLOT)) #f)

	    ; If this is a syntax expression, the operands won't have been
	    ; processed, so tell our caller we want it to by returning #f.
	    ; We do the same for non-syntax expressions to keep things
	    ; simple.  This requires collaboration with the traversal
	    ; handlers which are defined to do what we want if we return #f.
	    (else #f))))

       ; Whew.  We're now ready to traverse the expression.
       ; Traverse the expression recording the operands and building objects
       ; for most elements in the source representation.
       ; This also performs various simplifications.
       ; In particular machine dependent code for non-selected machines
       ; is discarded.
       (compiled-expr (rtx-traverse
		       context
		       insn
		       (rtx-simplify context insn sem-code
				     (insn-build-known-values insn))
		       process-expr!
		       #f))
       )

    ;(display "in:  ") (display in-ops) (newline)
    ;(display "out: ") (display out-ops) (newline)
    ;(force-output)

    ; Now that we have the nub of all input and output operands,
    ; we can assign operand numbers.  Inputs and outputs are not defined
    ; separately, output operand numbers follow inputs.  This simplifies the
    ; code which keeps track of such things: it can use one variable.
    ; The assignment is defined to be arbitrary.  If there comes a day
    ; when we need to prespecify operand numbers, revisit.
    ; The operand lists are sorted to avoid spurious differences in generated
    ; code (for example unnecessary extra entries can be created in the
    ; ARGBUF struct).

    ; Drop dummy first arg and sort operand lists.
    (let ((sorted-ins
	   (alpha-sort-obj-list (map (lambda (op)
				       (rtx-xop-obj (cadr op)))
				     (cdr in-ops))))
	  (sorted-outs
	   (alpha-sort-obj-list (map (lambda (op)
				       (rtx-xop-obj (cadr op)))
				     (cdr out-ops))))
	  (sem-attrs (cdr sem-attrs)))

      (let ((in-op-nums (iota (length sorted-ins)))
	    (out-op-nums (iota (length sorted-outs) (length sorted-ins))))

	(for-each (lambda (op num) (op:set-num! op num))
		  sorted-ins in-op-nums)
	(for-each (lambda (op num) (op:set-num! op num))
		  sorted-outs out-op-nums)

	(let ((dump (lambda (op)
		      (string/symbol-append "  "
					    (obj:name op)
					    " "
					    (number->string (op:num op))
					    "\n"))))
	  (logit 4
		 "Input operands:\n"
		 (map dump sorted-ins)
		 "Output operands:\n"
		 (map dump sorted-outs)
		 "End of operands.\n"))

	(csem-make compiled-expr sorted-ins sorted-outs
		   (atlist-parse context sem-attrs "")))))
)

; Traverse SEM-CODE, computing attributes derivable from it.
; The result is an <attr-list> object of attributes that can be computed from
; the semantics.
; The possibilities are: UNCOND-CTI, COND-CTI, SKIP-CTI, DELAY-SLOT.
; This computes the same values as semantic-compile, but for speed is
; focused on attributes only.
; ??? Combine *-CTI into an enum attribute.
;
; CONTEXT is a <context> object or #f if there is none.
; INSN is the <insn> object.
; SEM-CODE must be canonicalized rtl.

(define (semantic-attrs context insn sem-code)
  (assert (rtx? sem-code))

  (let*
      (
       ; List of attributes computed from SEM-CODE.
       ; The first element is just a dummy so that append! always works.
       (sem-attrs (list #f))

       ; Called for expressions encountered in SEM-CODE.
       (process-expr!
	(lambda (rtx-obj expr parent-expr op-pos tstate appstuff)
	  (case (car expr)

	    ;; FIXME: What's the result for the operand case?
	    ((operand) (if (and (eq? 'pc (rtx-operand-name expr))
				(memq (/rtx-ref-type parent-expr op-pos)
				      '(set set-quiet)))
			   (append! sem-attrs
				    (if (tstate-cond? tstate)
					;; Don't change these to '(FOO), since
					;; we use append!.
					(list 'COND-CTI)
					(list 'UNCOND-CTI)))))

	    ;; FIXME: keep name h-pc hardwired?
	    ((reg) (if (and (eq? 'h-pc (rtx-reg-name expr))
			    (memq (/rtx-ref-type parent-expr op-pos)
				  '(set set-quiet)))
		       (append! sem-attrs
				(if (tstate-cond? tstate)
				    ;; Don't change these to '(FOO), since
				    ;; we use append!.
				    (list 'COND-CTI)
				    (list 'UNCOND-CTI)))))

	    ((skip) (append! sem-attrs (list 'SKIP-CTI)) #f)

	    ((delay) (append! sem-attrs (list 'DELAY-SLOT)) #f)

	    ; If this is a syntax expression, the operands won't have been
	    ; processed, so tell our caller we want it to by returning #f.
	    ; We do the same for non-syntax expressions to keep things
	    ; simple.  This requires collaboration with the traversal
	    ; handlers which are defined to do what we want if we return #f.
	    (else #f))))

       ; Traverse the expression recording the attributes.
       (traversed-expr (rtx-traverse
			context
			insn
			(rtx-simplify context insn sem-code
				      (insn-build-known-values insn))
			process-expr!
			#f))
       )

    (let
	; Drop dummy first arg.
	((sem-attrs (cdr sem-attrs)))
      (atlist-parse context sem-attrs "")))
)
@


1.17
log
@	Specify isa(s) when doing ifield, operand, insn lookups.
	ACU = all callers updated.
	* attr.scm (/attr-eval): Call rtx-value instead of rtx-eval-with-estate.
	* enum.scm (define-full-insn-enum): Pass isa-name-list to
	current-ifld-lookup.
	* html.scm (get-insn-properties): Pass isa-name-list to
	current-op-lookup.
	* ifield.scm (/ifld-parse-follows): New arg isas, ACU.
	* insn.scm (/parse-insn-format-symbol): New arg isa-name-list, ACU.
	(/parse-insn-format-list, /parse-insn-iformat-iflds): Ditto.
	(/parse-insn-format, syntax-break-out): Ditto.
	* mach.scm (obj-filter-by-isa): New function.
	(current-ifld-lookup): New optional arg maybe-isa-name-list.
	(/ifld-already-defined?, /op-already-defined?): Simplify.
	(current-op-lookup): New optional arg maybe-isa-name-list.
	(current-insn-lookup): New arg isa-name-list, ACU.
	(/insn-already-defined?, /minsn-already-defined?): Simplify.
	(current-minsn-lookup): New arg isa-name-list, ACU.
	* minsn.scm (/minsn-compute-iflds): Pass isa-name-list to
	current-op-lookup.
	* opc-itab.scm (compute-syntax): New arg isa-name-list, ACU.
	(gen-syntax-entry): Ditto.
	* operand.scm (/operand-parse): Pass isa-name-list to
	current-ifld-lookup.
	(/derived-parse-encoding): New arg isa-name-list, ACU.
	(/derived-parse-ifield-assertion): Ditto.
	(/derived-operand-parse): Pass isa-name-list to current-op-lookup.
	(/anyof-parse-choice): Ditto.
	(anyof-satisfies-assertions?): Pass context to rtx-solve.
	(/anyof-merge-syntax): New arg container, ACU.
	(operand-builtin!): Add pc to all isas.
	* rtl-c.scm (estate-make-for-rtl-c): Delete arg extra-vars-alist, ACU.
	(estate-make-for-rtl-c++, rtl-c-expr-parsed): Ditto.
	(rtl-c-parsed, rtl-c++-parsed): Ditto.
	(rtl-c): New arg isa-name-list, ACU.
	(rtl-c-expr, rtl-c++): Ditto.
	(closure): New arg isa-name-list, ACU.
	* rtl-traverse.scm (/make-cstate): New arg isa-name-list, ACU.
	(/cstate-isas): New function.
	(/rtx-canon-symbol-list): New function.
	(/rtx-canon-env-stack): Renamed from /rtx-canon-env, ACU.
	updated.
	(/rtx-make-canon-table): Rename ENV to ENVSTACK, new entry SYMBOLLIST.
	(/rtx-canon-rtx-operand): Pass isa list to current-op-lookup.
	(/rtx-canon-rtx-ref, /rtx-canon): Ditto.
	(rtx-canonicalize): New arg isa-name-list, ACU.
	(rtx-canonicalize-stmt): Delete.
	(tstate-make): New arg isas, ACU.
	(tstate-isas, tstate--set-isas!): New functions.
	(tstate-env-stack): Renamed from tstate-env, ACU.
	(tstate-set-env-stack!): Renamed from tstate-set-env!, ACU.
	(tstate-make-closure): Renamed from tstate-new-env, new arg
	isa-name-list, ACU.
	(/rtx-traverse-env): Delete.
	(/rtx-make-traverser-table): Rename ENV to ENVSTACK, new entry
	SUMBOLLIST.
	(/rtx-traverse): Include conditional flag in dump output.
	Update isa,envstack for closures.  Pass isa list to current-op-lookup.
	(<eval-state>): New member isas.  Rename env to env-stack.
	(<eval-state> vmake!): Handle #:isas.  #:env renamed to #:env-stack.
	(<eval-state>): New getter/setter for isas.  Rename env getter/setter
	to env-stack.
	(estate-make-for-eval): Provide #:isas.
	(estate-make-closure): Renamed from estate-new-env.  New arg
	isa-name-list, ACU.
	* rtl-xform.scm (/rtx-simplify-expr-fn): Handle closures.
	(/rtx-trim-args): ENV renamed to ENVSTACK.  Ad ITERATION, SYMBOLLIST.
	(/rtx-trim-for-doc): Handle closures.
	* rtl.scm (/rtx-valid-types): Rename ENV to ENVSTACK.  Add ITERATION,
	SYMBOLLIST.
	(rtx-env-var-list): Delete.
	(rtx-env-make): Handle already-compiled environments.
	(rtx-var-alist-to-env): New function.
	(rtx-var-alist-to-closure-env-stack, rtx-make-env-stack): New functions.
	(rtx-env-stack-dump): Renamed from rtx-env-dump, ACU.
	(rtx-operand-obj): New arg isa-name-list, ACU.
	(rtx-closure-isas, rtx-closure-env-stack, rtx-closure-expr): New
	functions.
	* rtx-funcs.scm (closure): New arg isa-name-list, reorder args, ACU.
	* sem-frags.scm (<sfrag>): Delete member compiled-semantics.
	(/frag-compute-desired-frags): Minor simplification.
	(/frag-pick-best): Ditto.
	* sid-cpu.scm (gen-semantic-code): Require canonical rtl.
	(/gen-sfrag-code): Update.
	* sim-cpu.scm (gen-semantic-code): Require canonical rtl.
	* utils-cgen.scm (sanitize): New arg isa-name-list, ACU.
	* utils.scm (non-null-intersection?): New function.
@
text
@d113 2
d116 1
a116 1
(define (/build-reg-operand! expr tstate op-list)
d128 6
d367 1
a367 1
		     (/build-reg-operand! expr tstate
d370 2
a371 1
					      out-ops))))
d506 1
d528 2
a529 2
					; Don't change these to '(FOO), since
					; we use append!.
d532 12
d545 1
@


1.16
log
@	* xc16x.cpu (h-cr): New hardware.
	(muls): Comment out parts that won't compile, add fixme.
	(mulu, divl, divlu, jmpabs, jmpa-, jmprel, jbc, jnbs, callr): Ditto.
	(scxti, scxtmg, scxtm, bclear, bclr18, bset19, bitset, bmov): Ditto.
	(bmovn, band, bor, bxor, bcmp, bfldl, bfldh): Ditto.

	Rewrite rtl processing to require it to be "canonicalized" first,
	and write a full canonicalizer / expression checker.
	Remove all appearances of DFLT in canonical rtl.
	* attr.scm (/attr-eval atval owner): Call rtx-canonicalize,
	then rtx-simplify.
	* iformat.scm (ifmt-analyze) Use canonical semantics.
	* insn (<insn>): New member canonical-semantics.
	* mach.scm (<arch>): New member multi-insns-instantiated?.
	(/instantiate-multi-insns!): New function.
	(/canonicalize-insns!): New function.
	(arch-analyze-insns!): Canonicalize insn semantics before processing
	them.
	* mode.scm (/mode-set-word-params!): New function.
	(mode-void?): New function.
	(mode-compatible?): VOID is compatible with VOID.
	(/mode-word-sizes-defined?): New global.
	(mode-set-word-modes!): Use/set it.
	(mode-ensure-word-sizes-defined): Update.
	(mode-builtin!): New builtin "modes" SYM, INSN, MACH.
	Redo WI/UWI/AI/IAI handling.
	(op:new-mode): No longer accept DFLT.
	(<derived-operand> constructor): Ensure all fields are initialized.
	(<anyof-operand> constructor): Ditto.
	(/derived-parse-ifield-assertion): Delete arg `args'.
	All callers updated.
	* rtl-c.scm (<rtl-c-eval-state>): New member `for-insn?'.
	(rtl-c): Call rtx-canonicalize instead of rtx-compile.
	(rtl-c-expr, rtl-c++): Ditto.
	(/rtl-c-get): Use mode of operand, not containing expression.
	(rtl-c-set-quiet, rtl-c-set-trace): Remove DFLT support.
	(/rtx-use-sem-fn?): Don't check for (insn? owner), check
	estate-for-insn? instead.
	(s-unop): Use mode of expression, not first operand.
	(s-binop, s-binop-with-bit, s-shop, s-cmpop): Ditto.
	(s-sequence): Remove DFLT support.
	(ifield): Use mode of expression, not UINT.
	(pc): Comment out, unused.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	(set, set-quiet): Pass src to rtl-c-set-{trace,quiet} for expansion.
	* rtl-traverse.scm (/rtx-canon-debug?): New global.
	(/make-cstate): New function.
	(/cstate-context, /cstate-outer-expr): New functions.
	(/rtx-canon-error): New function.
	(/rtx-lookup-hw, /rtx-pick-mode, /rtx-pick-mode3, /rtx-pick-op-mode,
	/rtx-get-last-cond-case-rtx): New functions.
	(/rtx-canon-*): New functions.
	(/rtx-canner-table, /rtx-operand-canoners): New globals.
	(/rtx-make-canon-table, /rtx-special-expr-canoners): New functions.
	(/rtx-option, /rtx-option-list?): Rewrite.
	(rtx-munge-mode&options): Replaces /rtx-munge-mode&options.
	Rewritten, all callers updated.
	(/rtx-canon-expr, /rtx-canon): New functions.
	(rtx-canonicalize): Move here from rtl-xform.scm and rewrite.
	(rtx-canonicalize-stmt): New function.
	(tstate-make): Remove arg `set?'.  All callers updated.
	(tstate-new-set?): Delete.
	(/rtx-traverse-options, /rtx-traverse-*mode): Delete,
	moved to /rtx-canon-*.
	(/rtx-traverse-normal-operand): New function.
	(/rtx-traverse-rtx-list): Delete arg `mode', all callers updated.
	(/rtx-traverse-rtx, /rtx-traverse-setrtx,, /rtx-traverse-testrtx,
	/rtx-traverse-condrtx, /rtx-traverse-casertx, /rtx-traverse-locals,
	/rtx-traverse-iteration, /rtx-traverse-env, /rtx-traverse-attrs):
	Ditto.
	(/rtx-traverse-symbol, /rtx-traverse-string, /rtx-traverse-number,
	/rtx-traverse-symornum, /rtx-traverse-object): Delete.
	(/rtx-make-traverser-table): Update.
	(/rtx-traverse-operands): Remove mode processing, now done during
	canonicalization.
	(/rtx-traverse-expr): Delete arg `mode', all callers updated.
	(/rtx-traverse): Ditto.
	(rtx-init-traverser-tables!): New function.
	* rtl-xform (/rtx-verify-no-dflt-modes-expr-fn): New function.
	(rtx-verify-no-dflt-modes): New function.
	(/rtx-simplify-expr-fn): Update, `arg' mode deleted.
	(rtx-simplify-insn): Use insn-canonical-semantics.
	(rtx-canonicalize): Moved to rtl-traverse.scm.
	(/compile-expr-fn, rtx-compile): Delete.
	(/rtx-trim-rtx-list): New function.
	(/rtx-trim-for-doc): Handle set, if.
	* rtl.scm (<rtx-func>): New members result-mode, matchexpr-index.
	(/rtx-valid-mode-types): Update.
	(/rtx-valid-matches): Update.
	(/rtx-find-matchexpr-index): New function.
	(rtx-lookup): Require rtx-kind to be the rtx name.
	(def-rtx-node): New arg result-mode, all callers updated.
	(def-rtx-syntax-node, def-rtx-operand-node): Ditto.
	(rtx-lazy-sem-mode): Delete.
	(/rtx-closure-make): New arg `mode', all callers updated.
	(rtx-make-ifield, rtx-make-operand, rtx-make-local): Ditto.
	(rtx-operand-obj): Rewrite.
	(rtx-make-xop): New functions.
	(/hw): Renamed from `hw', all callers updated.
	Use the correct mode instead of DFLT for the index.
	(rtl-builtin!): Call rtx-init-traversal-tables!.
	(rtl-finish!): Update.
	* rtx-funcs.scm (all rtx functions): New parameter: result-mode.
	Update mode arg-type.
	(pc): Comment out.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	* sem-frags.scm (/frag-hash-compute!): Update, mode arg deleted.
	(/frag-cost-compute!): Ditto.
	* semantics.scm (/build-operand!): Delete args op-name, op.
	New arg op-expr.  All callers updated.
	(/build-mem-operand!): Remove DFLT support.
	(semantic-compile): Update process-expr!, mode arg deleted.
	* sid-cpu.scm (gen-semantic-code): Specify #:for-insn? in
	rtl-c++ calls.
	(/gen-sem-case, /gen-sfrag-code): Ditto.
	* sid.scm (/op-gen-set-trace1): Renamed from /op-gen-set-trace.
	(/op-gen-set-trace): New function.  If not doing profiling,
	call /op-gen-set-quiet.
	* sim-cpu.scm (gen-semantic-code): Specify #:for-insn? in rtl-c calls.
	* utils-gen.scm (/gen-ifld-extract-base): Update call to rtl-c.
	(/gen-ifld-extract-beyond, gen-multi-ifld-extract): Ditto.
	* utils.scm (find-first-index): New function.
	* doc/rtl.texi: Delete docs for `attr'.  Add `int-attr'.
@
text
@d78 1
a78 1
  (let* ((op (rtx-operand-obj op-expr))
d80 2
d213 2
a214 1
  (let ((op (rtx-operand-obj (rtx-index-of-value expr))))
d284 1
a284 2
; Traverse each element in SEM-CODE, converting them to canonical form,
; and computing the input and output operands.
d303 1
@


1.15
log
@	Clean up pass of mode handling.
	Make use of mode name vs <mode> object more consistent and clear.
	* hardware.scm (/keyword-read): Default mode to the mode name,
	not the <mode> object.
	(/hw-parse-indices): Parse mode name and pass mode object to
	<hw-asm> constructor.
	(/hw-parse-values): Ditto.
	(<hw-register> parse!): Pass mode name to /hw-parse-indices
	and /hw-parse-values.
	(<hw-memory> parse!): Ditto.
	(<hw-address> parse!): Ditto.
	* mode.scm (/mode-table): New global, replaces mode-list.
	Modes stored in hashtable instead of list.
	(/mode-class-table): New global.
	(mode-list-non-alias-values): Update.
	(mode:eq?, mode-compatible?, mode:add!): Update.
	(mode:lookup): Restrict arg to the mode's name.  All callers updated.
	(mode-maybe-lookup): New function.
	(mode-real-name): Restrict arg to a <mode> object.  All callers updated.
	(mode-real-mode, mode-sem-mode, mode-bigger?): Ditto.
	(mode-find, mode-set-word-modes!): Update
	(mode-ensure-word-sizes-defined): Update.
	(/sort-mode-classes!): New function.
	(mode-builtin!): Update.  Sort mode classes here.
	(mode-finish!): Sort mode classes here too.
	* rtl-c.scm (/rtl-c-get): Restrict mode arg to a <mode> object.
	All callers updated.
	(rtl-c-set-quiet): Allow mode to be name of object.
	(rtl-c-set-trace): Ditto.
	* rtl-traverse.scm (rtl-eval-with-estate): Restrict mode arg to
	<mode> object.  All callers updated.
	* rtl.scm (rtx-sem-mode): Restrict arg to <mode> object.
	(rtx-lazy-sem-mode): Ditto.
	(<rtx-temp> make!): Assert mode arg is a <mode> object.
	(rtx-env-make): Allow var-list modes to be name or object.
	* sem-frags.scm (/frag-expr-assq-locals): New function.
	(/frag-compute-locals!): Call it.
	(/sfrag-create-cse-mapping): Renamed from sfrag-create-cse-mapping.
	All callers updated.
	* semantics.scm (/build-mem-operand!): Handle mode aliases.
@
text
@a73 1
; MODE is the mode name.
d77 5
a81 7
(define (/build-operand! op-name op mode tstate ref-type op-list sem-attrs)
  ;(display (list op-name mode ref-type)) (newline) (force-output)
  (let* ((mode (mode-real-name (if (eq? mode 'DFLT)
				   (op:mode op)
				   (mode:lookup mode))))
         ; The first #f is a placeholder for the object.
	 (try (list '-op- #f mode op-name #f))
d84 2
d101 2
a102 2
	(let ((xop (op:new-mode op mode)))
	  (op:set-cond?! xop (tstate-cond? tstate))
d104 1
a104 1
	  (set-car! (cdr try) (rtx-make 'xop xop))
d118 1
a118 4
	; If the mode is DFLT, use the object's natural mode.
	(let* ((mode (mode-real-name (if (eq? (rtx-mode expr) 'DFLT)
					 (hw-mode hw)
					 (mode:lookup (rtx-mode expr)))))
d134 1
a134 1
		(set-car! (cdr try) (rtx-make 'xop xop))
d145 1
a145 1
  (let ((mode (mode-real-name (mode:lookup (rtx-mode expr))))
a147 4
    (if (memq mode '(DFLT VOID))
	(parse-error (tstate-context tstate)
		     "memory must have explicit mode" expr))

d160 1
a160 1
	    (set-car! (cdr try) (rtx-make 'xop xop))
d193 1
a193 1
	    (set-car! (cdr try) (rtx-make 'xop xop))
d241 1
a241 1
		(set-car! (cdr try) (rtx-make 'xop xop))
a331 1
       ; MODE is the name of the mode.
d334 1
a334 1
	(lambda (rtx-obj expr mode parent-expr op-pos tstate appstuff)
d337 3
d370 2
a371 3
	    ((operand) (let ((op (rtx-operand-obj expr))
			     (ref-type (/rtx-ref-type parent-expr op-pos)))
			 (/build-operand! (obj:name op) op mode tstate ref-type
d378 1
a378 1
	    ((name) (let ((result (/rtx-traverse (caddr expr) 'RTX mode
a504 1
       ; MODE is the name of the mode.
d506 1
a506 1
	(lambda (rtx-obj expr mode parent-expr op-pos tstate appstuff)
d509 2
a510 1
	    ((operand) (if (and (eq? 'pc (obj:name (rtx-operand-obj expr)))
@


1.14
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d14 1
d74 1
d82 1
a82 1
				   mode)))
d118 1
d121 2
a122 2
					 (obj:name (hw-mode hw))
					 (rtx-mode expr))))
d149 1
a149 1
  (let ((mode (rtx-mode expr))
d340 1
d512 1
@


1.13
log
@	* ifield.scm (<ifield> constructor): New arg `location',
	all callers updated.
	* insn.scm (<insn> constructor): Ditto.
	(<multi-insn> constructor): Ditto.
	* minsn.scm (<macro-insn> constructor): Ditto.
	* operand.scm (<operand> constructor): Ditto.
	* utils-cgen.scm (builtin-location): New function.
	(<source-ident>): Fix default value of member `location'.
	(source-ident?): New function.
@
text
@d15 1
a15 1
(define (-rtx-mode-equiv? m1 m2)
d30 1
a30 1
; MODE must match, as defined by -rtx-mode-equiv?.
d36 1
a36 1
(define (-rtx-find-op op op-list)
d47 1
a47 1
			(-rtx-mode-equiv? mode (caddr try))
d59 1
a59 1
(define (-rtx-ref-type expr op-pos)
d76 1
a76 1
(define (-build-operand! op-name op mode tstate ref-type op-list sem-attrs)
d83 1
a83 1
	 (existing-op (-rtx-find-op try op-list)))
d111 1
a111 1
(define (-build-reg-operand! expr tstate op-list)
d123 1
a123 1
	       (existing-op (-rtx-find-op try op-list)))
d145 1
a145 1
(define (-build-mem-operand! expr tstate op-list)
d154 1
a154 1
	   (existing-op (-rtx-find-op try op-list)))
d173 1
a173 1
(define (-build-ifield-operand! expr tstate op-list)
d182 1
a182 1
	   (existing-op (-rtx-find-op try op-list)))
d209 1
a209 1
(define (-build-index-of-operand! expr tstate op-list)
d224 1
a224 1
	; The rest of this is identical to -build-ifield-operand!.
d227 1
a227 1
	       (existing-op (-rtx-find-op try op-list)))
d343 1
a343 1
	    ((reg) (let ((ref-type (-rtx-ref-type parent-expr op-pos))
d358 1
a358 1
		     (-build-reg-operand! expr tstate
d364 1
a364 1
	    ((mem) (let ((ref-type (-rtx-ref-type parent-expr op-pos)))
d366 1
a366 1
		     (-build-mem-operand! expr tstate
d373 2
a374 2
			     (ref-type (-rtx-ref-type parent-expr op-pos)))
			 (-build-operand! (obj:name op) op mode tstate ref-type
d381 1
a381 1
	    ((name) (let ((result (-rtx-traverse (caddr expr) 'RTX mode
d393 1
a393 1
	    ((ifield) (let ((ref-type (-rtx-ref-type parent-expr op-pos)))
d397 1
a397 1
			(-build-ifield-operand! expr tstate in-ops)))
d403 1
a403 1
	    ((index-of) (let ((ref-type (-rtx-ref-type parent-expr op-pos)))
d407 1
a407 1
			  (-build-index-of-operand! expr tstate in-ops)))
d513 1
a513 1
				(memq (-rtx-ref-type parent-expr op-pos)
@


1.12
log
@	Clean up cpu file parsing, pass context consistently instead of the
	old "errtxt" argument.
	NOTE: ACU == "All Callers Updated".
	* attr.scm (-parse-simple-attribute): Renamed from
	parse-simple-attribute, ACU.
	(-attr-parse): Change errtxt argument to context, ACU.
	(-attr-read): Ditto.
	(atlist-parse): Ditto.  Put context arg first.
	(attr-parse): Use parse-error instead of context-error.
	* enum.scm (parse-enum-vals): Change errtxt argument to context, ACU.
	(-enum-parse-prefix, -enum-parse, -enum-read): Ditto.
	* hardware.scm (-keyword-parse): Renamed from keyword-parse.
	`context' arg is now a <context> object.  ACU.
	(-keyword-read): `context' arg is now a <context> object.  ACU.
	(-hw-parse-indices): Change errtxt argument to context, ACU.
	(-hw-parse-values, -hw-parse-handlers): Ditto.
	(-hw-parse-getter, -hw-parse-setter, -hw-parse, -hw-read): Ditto.
	(-hw-validate-layout, -hw-create-getter-from-layout,
	-hw-create-setter-from-layout): Ditto.
	(<hw-register>:parse!, <hw-pc>:parse!): Ditto.
	(<hw-memory>:parse!, <hw-immediate>:parse!): Ditto.
	(<hw-address>:parse!): Ditto.
	* ifield.scm (-ifield-parse, ifield-read): Ditto.
	(-ifld-parse-follows, -ifld-parse-encode-decode): Ditto.
	(-ifld-parse-encode, -ifld-parse-decode): Ditto.
	(-multi-ifield-parse, -multi-ifield-read): Ditto.
	* insn.scm (-insn-parse, -insn-read): Ditto.
	(parse-syntax): Ditto.  Put context arg first.
	(-parse-insn-format-symbol): Change errtxt argument to context, ACU.
	(-parse-insn-format-ifield-spec, -parse-insn-format-list): Ditto.
	(-parse-insn-format): Ditto.
	* mach.scm (-arch-parse-alignment, -arch-parse-machs): Ditto.
	(-arch-parse-isas): Ditto.
	(-isa-read): Add context arg, ACU.
	(-cpu-parse, -cpu-read, -mach-read): Ditto.
	* minsn.scm (-minsn-parse-expansion): Change errtxt argument to
	context, ACU.
	(-minsn-parse, -minsn-read, -minsn-compute-iflds): Ditto.
	(minsn-make-alias): Ditto.
	* mode.scm (-mode-parse): Ditto.
	(parse-mode-name): Ditto.  Put context arg first.
	* model.scm (-prefetch-parse, -retire-parse, -pipeline-parse): Change
	errtxt argument to context, ACU.
	(-unit-parse, -model-parse, -model-read): Ditto.
	* operand.scm (-operand-parse-getter): Use parse-error instead of
	context-error.
	(-operand-parse-setter): Ditto.
	(-operand-parse): Change errtxt argument to context, ACU.
	(-operand-read, -derived-operand-parse, -derived-operand-read): Ditto.
	(-anyof-operand-parse, -anyof-operand-read): Ditto.
	* read.scm (reader-error): Delete.  Use parse-error instead.
	(parse-error): Change errtxt argument to context, ACU.  Split args
	argument into expr and maybe-help-text.
	(-reader-process-expanded-1!): Reorganize.
	* rtl.scm (-subr-read): Change errtxt argument to context, ACU.
	* types.scm (parse-type): Ditto.
	* utils-cgen.scm (single-location->simple-string): New function.
	(<context>): Replace members file,lineno with location.
	(make-prefix-context): Renamed from context-make-prefix, ACU.
	(make-current-context): New function.
	(context-append, context-append-name): New functions.
	(context-make-reader): Delete.
	(parse-name): Change errtxt argument to context, ACU.
	Put context arg first.
	(parse-comment): Ditto.
	(parse-number): Change errtxt argument to context, ACU.
	(arg-list-validate-name, arg-list-check-no-args,
	arg-list-symbol-arg): Ditto.

	* read.scm (-cmd-if): Don't assume test is a list.

	* html.scm (get-insn-properties): Delete errtxt, unused.
@
text
@d189 2
a190 1
	  (let ((xop (make <operand> f-name f-name
d234 2
a235 1
	      (let ((xop (make <operand> f-name f-name
@


1.11
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d140 1
a140 1
	(parse-error "FIXME" "unknown reg" expr)))
d150 2
a151 1
	(parse-error "FIXME" "memory must have explicit mode" expr))
d178 1
a178 1
	(parse-error "FIXME" "unknown ifield" f-name))
d211 2
a212 1
      (parse-error "FIXME" "only `(index-of operand)' is currently supported"
d218 2
a219 1
	  (parse-error "FIXME" "only ifield indices are currently supported"
d320 1
a320 3
      ; String for error messages.
      ((errtxt "semantic compilation")

d353 1
a353 1
			   (else (parse-error errtxt
d393 2
a394 1
			    (parse-error errtxt "can't set an `ifield'" expr))
d403 2
a404 1
			      (parse-error errtxt "can't set an `index-of'" expr))
d482 1
a482 1
		   (atlist-parse sem-attrs "" "semantic attributes")))))
d500 1
a500 3
      ; String for error messages.
      ((errtxt "semantic attribute computation")

d542 1
a542 1
      (atlist-parse sem-attrs "" "semantic attributes")))
@


1.10
log
@	* semantics.scm (insn-build-known-values): Fix typo in comment.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
@


1.9
log
@Remove now outdated comment.
@
text
@d247 1
a247 1
; This built from the ifield-assertion list.
@


1.8
log
@	* semantics.scm (semantic-compile): Change arg sem-code-list to
	sem-code.
	(semantic-attrs): Ditto.
	* iformat.scm (ifmt-analyze): Update.
	(ifmt-compute!): Update.
	* rtl-traverse.scm (-compile-expr-fn, rtx-compile): Move to
	rtl-xform.scm.
	(-rtx-trim-args, -rtx-trim-for-doc, rtx-trim-for-doc): Ditto.
	* rtl.scm (-rtx-canonicalize-expr, rtx-canonicalize): Ditto.
	* semantics.scm (rtx-simplify): Ditto.
	(rtx-const-equal, rtx-const-list-equal): Ditto, and make local.
	(rtx-simplify-eq-attr-mach, rtx-simplify-eq-attr-insn): Ditto.
	(-simplify-expr-fn): Move to rtl-xform.scm.
	(-solve-expr-fn, rtx-solve): Ditto.
	* rtl-xform.c: New file.
	* read.scm: Load it.
@
text
@d1 1
a1 1
; Routines for instruction semantic analysis (including rtx-simplify).
@


1.7
log
@* utils.scm (string/symbol->append): Renamed from 'concat'.
* opcodes.scm (gen-switch): Use new name.
* insn.scm (-sub-insn-make!): Same.
* rtl.scm (rtx-dump): Same.
* semantics.scm (semantic-compile): Same.
@
text
@d5 1
a5 1

a9 52

; Subroutine of -simplify-expr-fn to compare two values for equality.
; If both are constants and they're equal return #f/#t.
; INVERT? = #f -> return #t if equal, #t -> return #f if equal.
; Returns 'unknown if either argument is not a constant.

(define (rtx-const-equal arg0 arg1 invert?)
  (if (and (rtx-constant? arg0)
	   (rtx-constant? arg1))
      (if invert?
	  (!= (rtx-constant-value arg0)
	      (rtx-constant-value arg1))
	  (= (rtx-constant-value arg0)
	     (rtx-constant-value arg1)))
      'unknown)
)

; Subroutine of -simplify-expr-fn to see if MAYBE-CONST is one of NUMBER-LIST.
; NUMBER-LIST is a `number-list' rtx.
; INVERT? is #t if looking for non-membership.
; #f/#t is only returned for definitive answers.
; If INVERT? is #f:
; - return #f if MAYBE-CONST is not in NUMBER-LIST
; - return #t if MAYBE-CONST is in NUMBER-LIST and it has only one member
; - return 'member if MAYBE-CONST is in NUMBER-LIST and it has many members
; - otherwise return 'unknown
; If INVERT? is #t:
; - return #t if MAYBE-CONST is not in NUMBER-LIST
; - return #f if MAYBE-CONST is in NUMBER-LIST and it has only one member
; - return 'member if MAYBE-CONST is in NUMBER-LIST and it has many members
; - otherwise return 'unknown

(define (rtx-const-list-equal maybe-const number-list invert?)
  (assert (rtx-kind? 'number-list number-list))
  (if (rtx-constant? maybe-const)
      (let ((values (rtx-number-list-values number-list)))
	(if invert?
	    (if (memq (rtx-constant-value maybe-const) values)
		(if (= (length values) 1)
		    #f
		    'member)
		#t)
	    (if (memq (rtx-constant-value maybe-const) values)
		(if (= (length values) 1)
		    #t
		    'member)
		#f)))
      'unknown)
)

; Subroutine of -simplify-expr-fn to simplify an eq-attr of (current-mach).
; CONTEXT is a <context> object or #f if there is none.
a10 277
(define (rtx-simplify-eq-attr-mach rtx context)
  (let ((attr (rtx-eq-attr-attr rtx))
	(value (rtx-eq-attr-value rtx)))
    ; If all currently selected machs will yield the same value
    ; for the attribute, we can simplify.
    (let ((values (map (lambda (m)
			 (obj-attr-value m attr))
		       (current-mach-list))))
      ; Ensure at least one mach is selected.
      (if (null? values)
	  (context-error context "rtx simplification, no machs selected"
			 (rtx-strdump rtx)))
      ; All values equal to the first one?
      (if (all-true? (map (lambda (val)
			    (equal? val (car values)))
			  values))
	  (if (equal? value
		      ; Convert internal boolean attribute value
		      ; #f/#t to external value FALSE/TRUE.
		      ; FIXME:revisit.
		      (case (car values)
			((#f) 'FALSE)
			((#t) 'TRUE)
			(else (car values))))
	      (rtx-true)
	      (rtx-false))
	  ; couldn't simplify
	  rtx)))
)

; Subroutine of -simplify-expr-fn to simplify an eq-attr of (current-insn).

(define (rtx-simplify-eq-attr-insn rtx insn context)
  (let ((attr (rtx-eq-attr-attr rtx))
	(value (rtx-eq-attr-value rtx)))
    (if (not (insn? insn))
	(context-error context
		       "No current insn for `(current-insn)'"
		       (rtx-strdump rtx)))
    (let ((attr-value (obj-attr-value insn attr)))
      (if (eq? value attr-value)
	  (rtx-true)
	  (rtx-false))))
)

; Subroutine of rtx-simplify.
; This is the EXPR-FN argument to rtx-traverse.

(define (-simplify-expr-fn rtx-obj expr mode parent-expr op-pos tstate appstuff)

  ;(display "Processing ") (display (rtx-dump expr)) (newline)

  (case (rtx-name expr)

    ((not)
     (let* ((arg (-rtx-traverse (rtx-alu-op-arg expr 0)
				'RTX
				(rtx-alu-op-mode expr)
				expr 1 tstate appstuff))
	    (no-side-effects? (not (rtx-side-effects? arg))))
       (cond ((and no-side-effects? (rtx-false? arg))
	      (rtx-true))
	     ((and no-side-effects? (rtx-true? arg))
	      (rtx-false))
	     (else (rtx-make 'not (rtx-alu-op-mode expr) arg)))))

    ((orif)
     (let ((arg0 (-rtx-traverse (rtx-boolif-op-arg expr 0)
				'RTX 'DFLT expr 0 tstate appstuff))
	   (arg1 (-rtx-traverse (rtx-boolif-op-arg expr 1)
				'RTX 'DFLT expr 1 tstate appstuff)))
       (let ((no-side-effects-0? (not (rtx-side-effects? arg0)))
	     (no-side-effects-1? (not (rtx-side-effects? arg1))))
	 (cond ((and no-side-effects-0? (rtx-true? arg0))
		(rtx-true))
	       ((and no-side-effects-0? (rtx-false? arg0))
		(rtx-canonical-bool arg1))
	       ; Value of arg0 is unknown or has side-effects.
	       ((and no-side-effects-1? (rtx-true? arg1))
		(if no-side-effects-0?
		    (rtx-true)
		    (rtx-make 'orif arg0 (rtx-true))))
	       ((and no-side-effects-1? (rtx-false? arg1))
		arg0)
	       (else
		(rtx-make 'orif arg0 arg1))))))

    ((andif)
     (let ((arg0 (-rtx-traverse (rtx-boolif-op-arg expr 0)
				'RTX 'DFLT expr 0 tstate appstuff))
	   (arg1 (-rtx-traverse (rtx-boolif-op-arg expr 1)
				'RTX 'DFLT expr 1 tstate appstuff)))
       (let ((no-side-effects-0? (not (rtx-side-effects? arg0)))
	     (no-side-effects-1? (not (rtx-side-effects? arg1))))
	 (cond ((and no-side-effects-0? (rtx-false? arg0))
		(rtx-false))
	       ((and no-side-effects-0? (rtx-true? arg0))
		(rtx-canonical-bool arg1))
	       ; Value of arg0 is unknown or has side-effects.
	       ((and no-side-effects-1? (rtx-false? arg1))
		(if no-side-effects-0?
		    (rtx-false)
		    (rtx-make 'andif arg0 (rtx-false))))
	       ((and no-side-effects-1? (rtx-true? arg1))
		arg0)
	       (else
		(rtx-make 'andif arg0 arg1))))))

    ; Fold if's to their then or else part if we can determine the
    ; result of the test.
    ((if)
     (let ((test
	    ; ??? Was this but that calls rtx-traverse again which
	    ; resets the temp stack!
	    ; (rtx-simplify context (caddr expr))))
	    (-rtx-traverse (rtx-if-test expr) 'RTX 'DFLT expr 1 tstate appstuff)))
       (cond ((rtx-true? test)
	      (-rtx-traverse (rtx-if-then expr) 'RTX mode expr 2 tstate appstuff))
	     ((rtx-false? test)
	      (if (rtx-if-else expr)
		  (-rtx-traverse (rtx-if-else expr) 'RTX mode expr 3 tstate appstuff)
		  ; Sanity check, mode must be VOID.
		  (if (or (mode:eq? 'DFLT (rtx-mode expr))
			  (mode:eq? 'VOID (rtx-mode expr)))
		      (rtx-make 'nop)
		      (error "rtx-simplify: non-void-mode `if' missing `else' part" expr))))
	     ; Can't simplify.
	     ; We could traverse the then/else clauses here, but it's simpler
	     ; to have our caller do it.  The cost is retraversing `test'.
	     (else #f))))

    ((eq ne)
     (let ((name (rtx-name expr))
	   (cmp-mode (rtx-cmp-op-mode expr))
	   (arg0 (-rtx-traverse (rtx-cmp-op-arg expr 0) 'RTX
				(rtx-cmp-op-mode expr)
				expr 1 tstate appstuff))
	   (arg1 (-rtx-traverse (rtx-cmp-op-arg expr 1) 'RTX
				(rtx-cmp-op-mode expr)
				expr 2 tstate appstuff)))
       (if (or (rtx-side-effects? arg0) (rtx-side-effects? arg1))
	   (rtx-make name cmp-mode arg0 arg1)
	   (case (rtx-const-equal arg0 arg1 (rtx-kind? 'ne expr))
	     ((#f) (rtx-false))
	     ((#t) (rtx-true))
	     (else
	      ; That didn't work.  See if we have an ifield/operand with a
	      ; known range of values.
	      (case (rtx-name arg0)
		((ifield)
		 (let ((known-val (tstate-known-lookup tstate
						       (rtx-ifield-name arg0))))
		   (if (and known-val (rtx-kind? 'number-list known-val))
		       (case (rtx-const-list-equal arg1 known-val (rtx-kind? 'ne expr))
			 ((#f) (rtx-false))
			 ((#t) (rtx-true))
			 (else
			  (rtx-make name cmp-mode arg0 arg1)))
		       (rtx-make name cmp-mode arg0 arg1))))
		((operand)
		 (let ((known-val (tstate-known-lookup tstate
						       (rtx-operand-name arg0))))
		   (if (and known-val (rtx-kind? 'number-list known-val))
		       (case (rtx-const-list-equal arg1 known-val (rtx-kind? 'ne expr))
			 ((#f) (rtx-false))
			 ((#t) (rtx-true))
			 (else
			  (rtx-make name cmp-mode arg0 arg1)))
		       (rtx-make name cmp-mode arg0 arg1))))
		(else
		 (rtx-make name cmp-mode arg0 arg1))))))))

    ; Recognize attribute requests of current-insn, current-mach.
    ((eq-attr)
     (cond ((rtx-kind? 'current-mach (rtx-eq-attr-owner expr))
	    (rtx-simplify-eq-attr-mach expr (tstate-context tstate)))
	   ((rtx-kind? 'current-insn (rtx-eq-attr-owner expr))
	    (rtx-simplify-eq-attr-insn expr (tstate-owner tstate) (tstate-context tstate)))
	   (else expr)))

    ((ifield)
     (let ((known-val (tstate-known-lookup tstate (rtx-ifield-name expr))))
       ; If the value is a single number, return that.
       ; It can be one of several, represented as a number list.
       (if (and known-val (rtx-constant? known-val))
	   known-val ; (rtx-make 'const 'INT known-val)
	   #f)))

    ((operand)
     (let ((known-val (tstate-known-lookup tstate (rtx-operand-name expr))))
       ; If the value is a single number, return that.
       ; It can be one of several, represented as a number list.
       (if (and known-val (rtx-constant? known-val))
	   known-val ; (rtx-make 'const 'INT known-val)
	   #f)))

    ; Leave EXPR unchanged and continue.
    (else #f))
)

; Simplify an rtl expression.
; EXPR must be in source form.
; The result is a possibly simplified EXPR, still in source form.
;
; CONTEXT is a <context> object, used for error messages.
; OWNER is the owner of the expression (e.g. <insn>) or #f if there is none.
;
; KNOWN is an alist of known values.  Each element is (name . value) where
; NAME is an ifield/operand name and VALUE is a const/number-list rtx.
; FIXME: Need ranges, later.
;
; The following operations are performed:
; - unselected machine dependent code is removed (eq-attr of (current-mach))
; - if's are reduced to either then/else if we can determine that the test is
;   a compile-time constant
; - orif/andif
; - eq/ne
; - not
;
; ??? Will become more intelligent as needed.

(define (rtx-simplify context owner expr known)
  (-rtx-traverse expr #f 'DFLT #f 0
		 (tstate-make context owner
			      (/fastcall-make -simplify-expr-fn)
			      (rtx-env-empty-stack)
			      #f #f known 0)
		 #f)
)

; Utilities for equation solving.
; ??? At the moment this is only focused on ifield assertions.
; ??? That there exist more sophisticated versions than this one can take
; as a given.  This works for the task at hand and will evolve or be replaced
; as necessary.
; ??? This makes the simplifying assumption that no expr has side-effects.

; Subroutine of rtx-solve.
; This is the EXPR-FN argument to rtx-traverse.

(define (-solve-expr-fn rtx-obj expr mode parent-expr op-pos tstate appstuff)
  #f ; wip
)

; Return a boolean indicating if {expr} equates to "true".
; If the expression can't be reduced to #f/#t, return '?.
; ??? Use rtx-eval instead of rtx-traverse?
;
; EXPR must be in source form.
; CONTEXT is a <context> object, used for error messages.
; OWNER is the owner of the expression (e.g. <insn>) or #f if there is none.
; KNOWN is an alist of known values.  Each element is (name . value) where
; NAME is an ifield/operand name and VALUE is a const/number-list rtx.
; FIXME: Need ranges, later.
;
; This is akin to rtx-simplify except it's geared towards solving ifield
; assertions.  It's not unreasonable to combine them.  The worry is the
; efficiency lost.
; ??? Will become more intelligent as needed.

(define (rtx-solve context owner expr known)
  ; First simplify, then solve.
  (let* ((simplified-expr (rtx-simplify context owner expr known))
	 (maybe-solved-expr
	  simplified-expr) ; FIXME: for now
;	  (-rtx-traverse simplified-expr #f 'DFLT #f 0
;			 (tstate-make context owner
;				      (/fastcall-make -solve-expr-fn)
;				      (rtx-env-empty-stack)
;				      #f #f known 0)
;			 #f))
	 )
    (cond ((rtx-true? maybe-solved-expr) #t)
	  ((rtx-false? maybe-solved-expr) #f)
	  (else '?)))
)

d281 1
a281 1
; Traverse each element in SEM-CODE-LIST, converting them to canonical form,
d284 1
a284 1
; The first is a list of the canonical form of each element in SEM-CODE-LIST:
a311 3
;
; FIXME: There's no need for sem-code-list to be a list.
; The caller always passes (list (insn-semantics insn)).
d313 2
a314 3
(define (semantic-compile context insn sem-code-list)
  (for-each (lambda (rtx) (assert (rtx? rtx)))
	    sem-code-list)
d320 1
a320 1
       ; These record the result of traversing SEM-CODE-LIST.
d329 1
a329 1
       ; List of attributes computed from SEM-CODE-LIST.
d333 1
a333 1
       ; Called for expressions encountered in SEM-CODE-LIST.
d423 7
a429 9
       (compiled-exprs (map (lambda (expr)
			      (rtx-traverse
			       context
			       insn
			       (rtx-simplify context insn expr
					     (insn-build-known-values insn))
			       process-expr!
			       #f))
			    sem-code-list))
d478 1
a478 1
	(csem-make compiled-exprs sorted-ins sorted-outs
d482 1
a482 1
; Traverse SEM-CODE-LIST, computing attributes derivable from it.
a491 3
;
; FIXME: There's no need for sem-code-list to be a list.
; The caller always passes (list (insn-semantics insn)).
d493 2
a494 3
(define (semantic-attrs context insn sem-code-list)
  (for-each (lambda (rtx) (assert (rtx? rtx)))
	    sem-code-list)
d500 1
a500 1
       ; List of attributes computed from SEM-CODE-LIST.
d504 1
a504 1
       ; Called for expressions encountered in SEM-CODE-LIST.
d529 7
a535 9
       (traversed-exprs (map (lambda (expr)
			       (rtx-traverse
				context
				insn
				(rtx-simplify context insn expr
					      (insn-build-known-values insn))
				process-expr!
				#f))
			     sem-code-list))
@


1.7.6.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2009 Red Hat, Inc.
@


1.6
log
@* utils.scm (concat): New function.
* insn.scm (-sub-insn-make!): Use concat instead of string-map.
* rtl.scm (rtx-dump): Same.
* semantics.scm (semantic-compile): Same.
@
text
@d801 5
a805 5
		      (concat "  "
			      (obj:name op)
			      " "
			      (number->string (op:num op))
			      "\n"))))
@


1.5
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@d801 5
a805 5
		      (string-append "  "
				     (obj:name op)
				     " "
				     (number->string (op:num op))
				     "\n"))))
@


1.4
log
@	* mach.scm (current-*-add!): Disallow redefinition.  Make result
	"unspecified".
	* insn.scm (insn-builtin!): Don't define relaxable here, now defined in
	operand.scm.
	* operand.scm (operand-builtin!): Define RELAXABLE for insns too.
	* cpu/m32r.cpu (disp8,disp24): RELAX renamed to RELAXABLE.

	* gen-all-doc: Split arm and frv docs up a bit.

	* cpu/arm.cpu: Add IDOC attribute.
	* cpu/frv.cpu: Ditto.
	* cpu/i960.cpu: Ditto.
	* cpu/openrisc.cpu: Ditto.
	* cpu/xstormy16.cpu: Ditto.
	* cpu/m32r.cpu: Ditto.
	(all insns): Explicitly specify IDOC attribute.

	* Makefile.am (MACH,ISAS,INSN_FILE_NAME): New vars.
	(desc,opcodes,sim-arch,sim-cpu,gas-test,sim-test): Use MACH,ISAS.
	(html): Use MACH,ISAS,INSN_FILE_NAME.  Generate insn.html separately.
	* Makefile.in: Regenerate.
	* attr.scm (<integer-attribute>:parse-value-def): Implement.
	(-attr-read): Defer computing default value until we know the type.
	(attr-has-attr?): Delete, move contents to <attr-list>:has-attr?.
	(<attr-list>:attr-present?): New method.
	(atlist-attr-present?,obj-attr-present?): New fns.
	(obj-has-attr-value?,obj-has-attr-value-no-default?): New fns.
	(attr-builtin!): New insn attr IDOC.
	* cgen-doc.scm (doc-arguments): New args -I,-N.
	* enum.scm (parse-enum-vals): New arg errtxt, all callers updated.
	Support comment as fourth element of enum value.
	(enum-val-name,enum-val-value,enum-val-attrs,enum-val-comment): New fns.
	* html.scm (gen-html-header): New arg kind, all callers updated.
	(gen-table-of-contents): New arg insn-file, all callers updated.
	(gen-list-entry,gen-doc-header): New fn.
	(get-operands): Delete.
	(gen-iformat-table): Rewrite.
	(gen-insn-doc-1): Print constant-folded and trimmed semantics.
	(gen-insn-doc-list): New args name, comment, insns.  All callers updated.
	(get-insn-properties,guess-insn-idoc-attr!): New fn.
	(insn-sets-pc?,insn-refs-mem?,insn-uses-fpu?): New fns.
	(get-insns-for-category,gen-categories-insn-lists): New fns.
	(gen-insn-docs): Simplify each insn's semantics first.
	Print insn tables sorted by IDOC categories.
	(*insn-html-file-name*): New global.
	(cgen-insn.html): New fn.
	(cgen-all): Update.
	* insn.scm (<insn>): Create a setter for the `tmp' member.
	* semantics.scm (insn-build-known-values): Renamed from
	-build-known-values.  All callers updated.

	* rtl.scm: Move traveral/evaluation support to ...
	* rtl-traverse.scm: New file.
	* read.scm: Maybe-load rtl-traverse.scm.

	* rtl.scm (-rtx-valid-types): Add SETRTX.

	* rtx-funcs.scm (nop,parallel): Fix mode.

	* utils.scm (eqv-lookup-index): New fn.
	(assq-lookup-index): Renamed from lookup-index.  All callers updated.

	* dev.scm (load-doc): Set APPLICATION.
@
text
@d783 3
a785 4
	   (sort (map (lambda (op)
			(rtx-xop-obj (cadr op)))
		      (cdr in-ops))
		 (lambda (a b) (string<? (obj:name a) (obj:name b)))))
d787 3
a789 4
	   (sort (map (lambda (op)
			(rtx-xop-obj (cadr op)))
		      (cdr out-ops))
		 (lambda (a b) (string<? (obj:name a) (obj:name b)))))
@


1.3
log
@	* Makefile.am (srcroot): New var.
	(html): New rule.
	* Makefile.in: Regenerate.
	* cgen-doc.scm: New file.
	* html.scm: New file.
	* gen-all-doc: New file.
	* dev.scm (cload): Handle DOC application.
	(load-doc): New fn.
	* machs.scm (machs-for-cpu): New fn.
	* model.scm (models-for-cpu): New fn.
	* utils.scm (gen-c-copyright): Renamed from gen-copyright.
	All uses updated.
	(iota): Rewrite to be identical to pmacro version.  All uses updated.
	* utils-cgen.scm (alpha-sort-obj-list): New fn.
@
text
@d578 1
a578 1
(define (-build-known-values insn)
d641 3
d761 1
a761 1
					     (-build-known-values insn))
d829 3
d875 1
a875 1
					      (-build-known-values insn))
@


1.2
log
@	* mode.scm (mode-sem-mode): New fn.
	* operand.scm (op:new-mode): Update. mode-name.
	(op-natural-mode?) New fn.
	* rtl.scm (hw): Set hw-name,mode-name.
plus some comment tweaks
@
text
@d792 1
a792 1
	    (out-op-nums (iota (length sorted-ins) (length sorted-outs))))
@


1.1
log
@Initial revision
@
text
@d263 1
a263 1
; Simplify an rtl expresion.
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
