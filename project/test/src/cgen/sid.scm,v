head	1.30;
access;
symbols
	sid-snapshot-20180601:1.30
	cgen-snapshot-20180601:1.30
	sid-snapshot-20180501:1.30
	cgen-snapshot-20180501:1.30
	sid-snapshot-20180401:1.30
	cgen-snapshot-20180401:1.30
	sid-snapshot-20180301:1.30
	cgen-snapshot-20180301:1.30
	sid-snapshot-20180201:1.30
	cgen-snapshot-20180201:1.30
	sid-snapshot-20180101:1.30
	cgen-snapshot-20180101:1.30
	sid-snapshot-20171201:1.30
	cgen-snapshot-20171201:1.30
	sid-snapshot-20171101:1.30
	cgen-snapshot-20171101:1.30
	sid-snapshot-20171001:1.30
	cgen-snapshot-20171001:1.30
	sid-snapshot-20170901:1.30
	cgen-snapshot-20170901:1.30
	sid-snapshot-20170801:1.30
	cgen-snapshot-20170801:1.30
	sid-snapshot-20170701:1.30
	cgen-snapshot-20170701:1.30
	sid-snapshot-20170601:1.30
	cgen-snapshot-20170601:1.30
	sid-snapshot-20170501:1.30
	cgen-snapshot-20170501:1.30
	sid-snapshot-20170401:1.30
	cgen-snapshot-20170401:1.30
	sid-snapshot-20170301:1.30
	cgen-snapshot-20170301:1.30
	sid-snapshot-20170201:1.30
	cgen-snapshot-20170201:1.30
	sid-snapshot-20170101:1.30
	cgen-snapshot-20170101:1.30
	sid-snapshot-20161201:1.30
	cgen-snapshot-20161201:1.30
	sid-snapshot-20161101:1.30
	cgen-snapshot-20161101:1.30
	sid-snapshot-20160901:1.30
	cgen-snapshot-20160901:1.30
	sid-snapshot-20160801:1.30
	cgen-snapshot-20160801:1.30
	sid-snapshot-20160701:1.30
	cgen-snapshot-20160701:1.30
	sid-snapshot-20160601:1.30
	cgen-snapshot-20160601:1.30
	sid-snapshot-20160501:1.30
	cgen-snapshot-20160501:1.30
	sid-snapshot-20160401:1.30
	cgen-snapshot-20160401:1.30
	sid-snapshot-20160301:1.30
	cgen-snapshot-20160301:1.30
	sid-snapshot-20160201:1.30
	cgen-snapshot-20160201:1.30
	sid-snapshot-20160101:1.30
	cgen-snapshot-20160101:1.30
	sid-snapshot-20151201:1.30
	cgen-snapshot-20151201:1.30
	sid-snapshot-20151101:1.30
	cgen-snapshot-20151101:1.30
	sid-snapshot-20151001:1.30
	cgen-snapshot-20151001:1.30
	sid-snapshot-20150901:1.30
	cgen-snapshot-20150901:1.30
	sid-snapshot-20150801:1.30
	cgen-snapshot-20150801:1.30
	sid-snapshot-20150701:1.30
	cgen-snapshot-20150701:1.30
	sid-snapshot-20150601:1.30
	cgen-snapshot-20150601:1.30
	sid-snapshot-20150501:1.30
	cgen-snapshot-20150501:1.30
	sid-snapshot-20150401:1.30
	cgen-snapshot-20150401:1.30
	sid-snapshot-20150301:1.30
	cgen-snapshot-20150301:1.30
	sid-snapshot-20150201:1.30
	cgen-snapshot-20150201:1.30
	sid-snapshot-20150101:1.30
	cgen-snapshot-20150101:1.30
	sid-snapshot-20141201:1.30
	cgen-snapshot-20141201:1.30
	sid-snapshot-20141101:1.30
	cgen-snapshot-20141101:1.30
	sid-snapshot-20141001:1.30
	cgen-snapshot-20141001:1.30
	sid-snapshot-20140901:1.30
	cgen-snapshot-20140901:1.30
	sid-snapshot-20140801:1.30
	cgen-snapshot-20140801:1.30
	sid-snapshot-20140701:1.30
	cgen-snapshot-20140701:1.30
	sid-snapshot-20140601:1.30
	cgen-snapshot-20140601:1.30
	sid-snapshot-20140501:1.30
	cgen-snapshot-20140501:1.30
	sid-snapshot-20140401:1.30
	cgen-snapshot-20140401:1.30
	sid-snapshot-20140301:1.30
	cgen-snapshot-20140301:1.30
	sid-snapshot-20140201:1.30
	cgen-snapshot-20140201:1.30
	sid-snapshot-20140101:1.30
	cgen-snapshot-20140101:1.30
	sid-snapshot-20131201:1.30
	cgen-snapshot-20131201:1.30
	sid-snapshot-20131101:1.30
	cgen-snapshot-20131101:1.30
	sid-snapshot-20131001:1.30
	cgen-snapshot-20131001:1.30
	sid-snapshot-20130901:1.30
	cgen-snapshot-20130901:1.30
	sid-snapshot-20130801:1.30
	cgen-snapshot-20130801:1.30
	sid-snapshot-20130701:1.30
	cgen-snapshot-20130701:1.30
	sid-snapshot-20130601:1.30
	cgen-snapshot-20130601:1.30
	sid-snapshot-20130501:1.30
	cgen-snapshot-20130501:1.30
	sid-snapshot-20130401:1.30
	cgen-snapshot-20130401:1.30
	sid-snapshot-20130301:1.30
	cgen-snapshot-20130301:1.30
	sid-snapshot-20130201:1.30
	cgen-snapshot-20130201:1.30
	sid-snapshot-20130101:1.30
	cgen-snapshot-20130101:1.30
	sid-snapshot-20121201:1.30
	cgen-snapshot-20121201:1.30
	sid-snapshot-20121101:1.30
	cgen-snapshot-20121101:1.30
	sid-snapshot-20121001:1.30
	cgen-snapshot-20121001:1.30
	sid-snapshot-20120901:1.30
	cgen-snapshot-20120901:1.30
	sid-snapshot-20120801:1.30
	cgen-snapshot-20120801:1.30
	sid-snapshot-20120701:1.30
	cgen-snapshot-20120701:1.30
	sid-snapshot-20120601:1.30
	cgen-snapshot-20120601:1.30
	sid-snapshot-20120501:1.30
	cgen-snapshot-20120501:1.30
	sid-snapshot-20120401:1.30
	cgen-snapshot-20120401:1.30
	sid-snapshot-20120301:1.30
	cgen-snapshot-20120301:1.30
	sid-snapshot-20120201:1.30
	cgen-snapshot-20120201:1.30
	sid-snapshot-20120101:1.30
	cgen-snapshot-20120101:1.30
	sid-snapshot-20111201:1.30
	cgen-snapshot-20111201:1.30
	sid-snapshot-20111101:1.30
	cgen-snapshot-20111101:1.30
	sid-snapshot-20111001:1.30
	cgen-snapshot-20111001:1.30
	sid-snapshot-20110901:1.30
	cgen-snapshot-20110901:1.30
	sid-snapshot-20110801:1.29
	cgen-snapshot-20110801:1.29
	sid-snapshot-20110701:1.29
	cgen-snapshot-20110701:1.29
	sid-snapshot-20110601:1.29
	cgen-snapshot-20110601:1.29
	sid-snapshot-20110501:1.29
	cgen-snapshot-20110501:1.29
	sid-snapshot-20110401:1.29
	cgen-snapshot-20110401:1.29
	sid-snapshot-20110301:1.29
	cgen-snapshot-20110301:1.29
	sid-snapshot-20110201:1.29
	cgen-snapshot-20110201:1.29
	sid-snapshot-20110101:1.29
	cgen-snapshot-20110101:1.29
	sid-snapshot-20101201:1.29
	cgen-snapshot-20101201:1.29
	sid-snapshot-20101101:1.29
	cgen-snapshot-20101101:1.29
	sid-snapshot-20101001:1.29
	cgen-snapshot-20101001:1.29
	sid-snapshot-20100901:1.29
	cgen-snapshot-20100901:1.29
	sid-snapshot-20100801:1.29
	cgen-snapshot-20100801:1.29
	sid-snapshot-20100701:1.29
	cgen-snapshot-20100701:1.29
	sid-snapshot-20100601:1.29
	cgen-snapshot-20100601:1.29
	sid-snapshot-20100501:1.29
	cgen-snapshot-20100501:1.29
	sid-snapshot-20100401:1.29
	cgen-snapshot-20100401:1.29
	sid-snapshot-20100301:1.29
	cgen-snapshot-20100301:1.29
	sid-snapshot-20100201:1.29
	cgen-snapshot-20100201:1.29
	sid-snapshot-20100101:1.28
	cgen-snapshot-20100101:1.28
	sid-snapshot-20091201:1.28
	cgen-snapshot-20091201:1.28
	sid-snapshot-20091101:1.25
	cgen-snapshot-20091101:1.25
	sid-snapshot-20091001:1.25
	cgen-snapshot-20091001:1.25
	arc-sim-20090309:1.18
	sid-snapshot-20090901:1.21
	cgen-snapshot-20090901:1.21
	sid-snapshot-20090801:1.20
	cgen-snapshot-20090801:1.20
	sid-snapshot-20090701:1.19
	cgen-snapshot-20090701:1.19
	dje-cgen-play1-branch:1.19.0.2
	dje-cgen-play1-branchpoint:1.19
	cgen-1_1-branch:1.18.0.4
	cgen-1_1-branchpoint:1.18
	sid-snapshot-20090601:1.18
	cgen-snapshot-20090601:1.18
	sid-snapshot-20090501:1.18
	cgen-snapshot-20090501:1.18
	sid-snapshot-20090401:1.18
	cgen-snapshot-20090401:1.18
	arc-insight_6_8-branch:1.18.0.2
	arc-insight_6_8-branchpoint:1.18
	sid-snapshot-20090301:1.18
	cgen-snapshot-20090301:1.18
	sid-snapshot-20090201:1.18
	cgen-snapshot-20090201:1.18
	sid-snapshot-20090101:1.18
	cgen-snapshot-20090101:1.18
	sid-snapshot-20081201:1.18
	cgen-snapshot-20081201:1.18
	sid-snapshot-20081101:1.18
	cgen-snapshot-20081101:1.18
	sid-snapshot-20081001:1.18
	cgen-snapshot-20081001:1.18
	sid-snapshot-20080901:1.18
	cgen-snapshot-20080901:1.18
	sid-snapshot-20080801:1.18
	cgen-snapshot-20080801:1.18
	sid-snapshot-20080701:1.18
	cgen-snapshot-20080701:1.18
	sid-snapshot-20080601:1.18
	cgen-snapshot-20080601:1.18
	sid-snapshot-20080501:1.18
	cgen-snapshot-20080501:1.18
	sid-snapshot-20080403:1.18
	sid-snapshot-20080401:1.18
	cgen-snapshot-20080401:1.18
	sid-snapshot-20080301:1.18
	cgen-snapshot-20080301:1.18
	sid-snapshot-20080201:1.18
	cgen-snapshot-20080201:1.18
	sid-snapshot-20080101:1.18
	cgen-snapshot-20080101:1.18
	sid-snapshot-20071201:1.18
	cgen-snapshot-20071201:1.18
	sid-snapshot-20071101:1.18
	cgen-snapshot-20071101:1.18
	sid-snapshot-20071001:1.18
	cgen-snapshot-20071001:1.18
	msnyder-fork-checkpoint-branch:1.16.0.2
	msnyder-fork-checkpoint-branchpoint:1.16
	sid-20020905-branchpoint:1.7
	sid-20020905-branch:1.7.0.4
	cagney_regbuf-20020515-branch:1.7.0.2
	cagney_regbuf-20020515-branchpoint:1.7
	cygnus_cvs_20020108_pre:1.7
	cgen-1-1-branch:1.5.0.2;
locks; strict;
comment	@# @;


1.30
date	2011.08.29.17.31.16;	author fche;	state Exp;
branches;
next	1.29;

1.29
date	2010.01.25.00.40.29;	author devans;	state Exp;
branches;
next	1.28;

1.28
date	2009.11.23.09.03.01;	author devans;	state Exp;
branches;
next	1.27;

1.27
date	2009.11.05.16.55.33;	author devans;	state Exp;
branches;
next	1.26;

1.26
date	2009.11.03.16.24.02;	author devans;	state Exp;
branches;
next	1.25;

1.25
date	2009.09.27.18.31.33;	author devans;	state Exp;
branches;
next	1.24;

1.24
date	2009.09.23.22.30.19;	author devans;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.10.07.23.29;	author devans;	state Exp;
branches;
next	1.22;

1.22
date	2009.09.07.22.17.34;	author devans;	state Exp;
branches;
next	1.21;

1.21
date	2009.08.12.22.33.37;	author devans;	state Exp;
branches;
next	1.20;

1.20
date	2009.07.18.20.44.58;	author devans;	state Exp;
branches;
next	1.19;

1.19
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches;
next	1.18;

1.18
date	2006.07.14.18.49.32;	author brolley;	state Exp;
branches
	1.18.4.1;
next	1.17;

1.17
date	2006.06.20.19.51.11;	author brolley;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.28.19.30.02;	author brolley;	state Exp;
branches;
next	1.15;

1.15
date	2005.06.15.21.28.19;	author brolley;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.17.01.47.16;	author jimb;	state Exp;
branches;
next	1.13;

1.13
date	2005.02.16.21.52.33;	author brolley;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.22.20.44.16;	author brolley;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.16.05.35.47;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.15.07.25.02;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.16.18.09.06;	author brolley;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.12.17.17.14;	author fche;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.07.08.23.59;	author bje;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.07.07.05.05;	author bje;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.05.12.54.36;	author bje;	state Exp;
branches;
next	1.4;

1.4
date	2001.04.02.21.18.27;	author bje;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.01.19.15.30;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.29.18.56.26;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.08.22.34.20;	author bje;	state Exp;
branches;
next	;

1.18.4.1
date	2009.06.24.14.57.46;	author devans;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Patch for sid/cgen setter error.

http://sourceware.org/ml/cgen/2011-q3/msg00008.html

Author: John Wehle <john@@cybersashi.com>

* sid.scm (/op-gen-set-trace1): Use rtl-c VOID instead of 'VOID.
@
text
@; Simulator generator support routines.
; Copyright (C) 2000, 2005, 2009 Red Hat, Inc.
; This file is part of CGEN.

; One goal of this file is to provide cover functions for all methods.
; i.e. this file fills in the missing pieces of the interface between
; the application independent part of CGEN (i.e. the code loaded by read.scm)
; and the application dependent part (i.e. sim-*.scm).
; `send' is not intended to appear in sim-*.scm.
; [It still does but that's to be fixed.]

; Specify which application.
(set! APPLICATION 'SID-SIMULATOR)

; Misc. state info.

; Currently supported options:
; with-scache
;	generate code to use the scache engine
; with-pbb
;	generate code to use the pbb engine
; with-sem-frags
;	generate semantic fragment engine (requires with-pbb)
; with-profile fn|sw
;	generate code to do profiling in the semantic function
;	code (fn) or in the semantic switch (sw)
; with-multiple-isa
;	enable multiple-isa support (e.g. arm+thumb)
;	??? wip.
; copyright fsf|redhat
;	emit an FSF or Red Hat copyright (temporary, pending decision)
; package gnusim|cygsim
;	indicate the software package

; #t if the scache is being used
(define /with-scache? #f)
(define (with-scache?) /with-scache?)

; #t if we're generating profiling code
; Each of the function and switch semantic code can have profiling.
; The options as passed are stored in /with-profile-{fn,sw}?, and
; /with-profile? is set at code generation time.
(define /with-profile-fn? #f)
(define /with-profile-sw? #f)
(define /with-profile? #f)
(define (with-profile?) /with-profile?)
(define (with-any-profile?) (or /with-profile-fn? /with-profile-sw?))

; #t if multiple isa support is enabled
(define /with-multiple-isa? #f)
(define (with-multiple-isa?) /with-multiple-isa?)

; #t if semantics are generated as pbb computed-goto engine
(define /with-pbb? #f)
(define (with-pbb?) /with-pbb?)

; #t if the semantic fragment engine is to be used.
; This involves combining common fragments of each insn into one.
(define /with-sem-frags? #f)
(define (with-sem-frags?) /with-sem-frags?)

; String containing copyright text.
(define CURRENT-COPYRIGHT #f)

; String containing text defining the package we're generating code for.
(define CURRENT-PACKAGE #f)

; Initialize the options.

(define (option-init!)
  (set! /with-scache? #f)
  (set! /with-pbb? #f)
  (set! /with-sem-frags? #f)
  (set! /with-profile-fn? #f)
  (set! /with-profile-sw? #f)
  (set! /with-multiple-isa? #f)
  (set! CURRENT-COPYRIGHT copyright-fsf)
  (set! CURRENT-PACKAGE package-gnu-simulators)
  *UNSPECIFIED*
)

; Handle an option passed in from the command line.

(define (option-set! name value)
  (case name
    ((with-scache) (set! /with-scache? #t))
    ((with-pbb) (set! /with-pbb? #t))
    ((with-sem-frags) (set! /with-sem-frags? #t))
    ((with-profile) (cond ((equal? value '("fn"))
			   (set! /with-profile-fn? #t))
			  ((equal? value '("sw"))
			   (set! /with-profile-sw? #t))
			  (else (error "invalid with-profile value" value))))
    ((with-multiple-isa) (set! /with-multiple-isa? #t))
    ((copyright) (cond ((equal?  value '("fsf"))
			(set! CURRENT-COPYRIGHT copyright-fsf))
		       ((equal? value '("redhat"))
			(set! CURRENT-COPYRIGHT copyright-red-hat))
		       (else (error "invalid copyright value" value))))
    ((package) (cond ((equal?  value '("gnusim"))
		      (set! CURRENT-PACKAGE package-gnu-simulators))
		     ((equal? value '("cygsim"))
		      (set! CURRENT-PACKAGE package-red-hat-simulators))
		     (else (error "invalid package value" value))))
    (else (error "unknown option" name))
    )
  *UNSPECIFIED*
)

; #t if we're currently generating a pbb engine.
(define /current-pbb-engine? #f)
(define (current-pbb-engine?) /current-pbb-engine?)
(define (set-current-pbb-engine?! flag) (set! /current-pbb-engine? flag))

; #t if the cpu can execute insns parallely.
; This one isn't passed on the command line, but we follow the convention
; of prefixing these things with `with-'.
; While processing operand reading (or writing), parallel execution support
; needs to be turned off, so it is up to the appropriate cgen-foo.c proc to
; set-with-parallel?! appropriately.
(define /with-parallel? #f)
(define (with-parallel?) /with-parallel?)
(define (set-with-parallel?! flag) (set! /with-parallel? flag))

; Kind of parallel support.
; If 'read, read pre-processing is done.
; If 'write, write post-processing is done.
; ??? At present we always use write post-processing, though the previous
; version used read pre-processing.  Not sure supporting both is useful
; in the long run.
(define /with-parallel-kind 'write)
; #t if parallel support is provided by read pre-processing.
(define (with-parallel-read?)
  (and /with-parallel? (eq? /with-parallel-kind 'read))
)
; #t if parallel support is provided by write post-processing.
(define (with-parallel-write?)
  (and /with-parallel? (eq? /with-parallel-kind 'write))
)

; Cover functions for various methods.

; Return the C type of something.  This isn't always a mode.

(define (gen-type self) (send self 'gen-type))

; Return the C type of an index's value or #f if not needed (scalar).

(define (gen-index-type op sfmt)
  (let ((index-mode (send op 'get-index-mode)))
    (if index-mode
	(mode:c-type index-mode)
	#f))
)

; Misc. utilities.

; Return reference to hardware element SYM.
; ISAS is a list of <isa> objects.
; The idea is that in multiple isa architectures (e.g. arm) the elements
; common to all isas are kept in one class and the elements specific to each
; isa are kept in separate classes.

(define (gen-cpu-ref isas sym)
  (if (and (with-multiple-isa?)
	   (= (length isas) 1))
      (string-append "current_cpu->@@cpu@@_hardware." sym)
      (string-append "current_cpu->hardware." sym))
)

; Attribute support.

; Return C code to fetch a value from instruction memory.
; PC-VAR is the C expression containing the address of the start of the
; instruction.
;
; We don't bother trying to handle bitsizes that don't have a
; corresponding GETIMEM method.  Doing so would require us to take
; endianness into account just to ensure that the requested bits end
; up at the proper place in the result.  It's easier just to make the
; caller ask us for something we can do directly.
;
; ??? Aligned/unaligned support?

(define (gen-ifetch pc-var bitoffset bitsize)
  (string-append "current_cpu->GETIMEM"
		 (case bitsize
		   ((8) "UQI")
		   ((16) "UHI")
		   ((32) "USI")
		   (else (error "bad bitsize argument to gen-ifetch" bitsize)))
		 " (pc, "
		 pc-var " + " (number->string (quotient bitoffset 8))
		 ")")
)

; Return definition of an object's attributes.
; This is like gen-obj-attr-defn, except split for sid.
; TYPE is one of 'ifld, 'hw, 'operand, 'insn.
; [Only 'insn is currently needed.]
; ALL-ATTRS is an ordered alist of all attributes.
; "ordered" means all the non-boolean attributes are at the front and
; duplicate entries have been removed.

(define (gen-obj-attr-sid-defn type obj all-attrs)
  (let* ((attrs (obj-atlist obj))
	 (non-bools (attr-non-bool-attrs (atlist-attrs attrs)))
	 (all-non-bools (list-take (attr-count-non-bools all-attrs) all-attrs))
	 )
    (string-append
     "{ "
     (gen-bool-attrs attrs gen-attr-mask)
     ","
     (if (null? all-non-bools)
	 " 0"
	 (string-drop1 ; drop the leading ","
	  (string-map (lambda (attr)
			(let ((val (or (assq-ref non-bools (obj:name attr))
				       (attr-default attr))))
			  ; FIXME: Are we missing attr-prefix here?
			  (string-append ", "
					 (send attr 'gen-value-for-defn-raw val))))
		      all-non-bools)))
     " }"))
)

; Instruction field support code.

; Return a <c-expr> object of the value of an ifield.

(define (/cxmake-ifld-val mode f)
  (if (with-scache?)
      ; ??? Perhaps a better way would be to defer evaluating the src of a
      ; set until the method processing the dest.
      (cx:make-with-atlist mode (gen-ifld-argbuf-ref f)
			   (atlist-make "" (bool-attr-make 'CACHED #t)))
      (cx:make mode (gen-extracted-ifld-value f)))
)

; Type system.

; Methods:
; gen-type - return C code representing the type
; gen-sym-defn - generate definition using the provided symbol
; gen-sym-get-macro - generate GET macro for accessing CPU elements
; gen-sym-set-macro - generate SET macro for accessing CPU elements

; Scalar type

(method-make!
 <scalar> 'gen-type
 (lambda (self) (mode:c-type (elm-get self 'mode)))
)

(method-make!
 <scalar> 'gen-sym-defn
 (lambda (self sym comment)
   (string-append
    "  /* " comment " */\n"
    "  " (send self 'gen-type) " "
    (gen-c-symbol sym) ";\n"))
)

(method-make! <scalar> 'gen-ref (lambda (self sym index estate) sym))

; Array type

(method-make!
 <array> 'gen-type
 (lambda (self) (mode:c-type (elm-get self 'mode)))
)

(method-make!
 <array> 'gen-sym-defn
 (lambda (self sym comment)
   (string-append
    "  /* " comment " */\n"
    "  " (send self 'gen-type) " "
    (gen-c-symbol sym)
    (gen-array-ref (elm-get self 'dimensions))
    ";\n")
   )
)

; Return a reference to the array.
; SYM is the name of the array.
; INDEX is either a single index object or a (possibly empty) list of objects,
; one object per dimension.

(method-make!
 <array> 'gen-ref
 (lambda (self sym index estate)
   (let ((gen-index1 (lambda (idx)
		       (string-append "["
				      (/gen-hw-index idx estate)
				      "]"))))
     (string-append sym
		    (cond ((list? index) (string-map gen-index1 index))
			  (else (gen-index1 index))))))
)

; Integers
;
;(method-make!
; <integer> 'gen-type
; (lambda (self)
;   (mode:c-type (mode-find (elm-get self 'bits)
;			   (if (has-attr? self 'UNSIGNED)
;			       'UINT 'INT)))
;   )
;)
;
;(method-make! <integer> 'gen-sym-defn (lambda (self sym comment) ""))
;(method-make! <integer> 'gen-sym-get-macro (lambda (self sym comment) ""))
;(method-make! <integer> 'gen-sym-set-macro (lambda (self sym comment) ""))

; Hardware descriptions support code.
;
; Various operations are required for each h/w object to support the various
; things the simulator will want to do with it.
;
; Methods:
; gen-type      - C type to use to record value.
;                 ??? Delete and just use get-mode?
; gen-defn      - generate a definition of the h/w element
; gen-write     - Same as gen-read except done on output operands
; cxmake-get    - Return a <c-expr> object to fetch the value.
; gen-set-quiet - Set the value.
;                 ??? Could just call this gen-set as there is no gen-set-trace
;                 but for consistency with the messages passed to operands
;                 we use this same.
; save-index?   - return #t if an index needs to be saved for parallel
;                 execution post-write processing
; gen-profile-decl
; gen-record-profile
; get-mode
; gen-profile-locals
; gen-sym-get-macro - Generate default GET access macro.
; gen-sym-set-macro - Generate default SET access macro.
; gen-ref       - Return a C reference to the object.

; gen-type handler, must be overridden

(method-make!
 <hardware-base> 'gen-type
 (lambda (self) (error "gen-type not overridden:" self))
)

; Generate CPU state struct entries, must be overridden.

(method-make!
 <hardware-base> 'gen-defn
 (lambda (self) (error "gen-defn not overridden:" self))
)

; Return a C reference to a hardware object.

(method-make! <hardware-base> 'gen-ref (lambda (self sym index estate) sym))

; Each hardware type must provide its own gen-write method.

(method-make!
 <hardware-base> 'gen-write
 (lambda (self estate index mode sfmt op access-macro)
   (error "gen-write method not overridden:" self))
)

(method-make! <hardware-base> 'gen-profile-decl (lambda (self) ""))

; Default gen-record-profile method.

(method-make!
 <hardware-base> 'gen-record-profile
 (lambda (self index sfmt estate)
   "") ; nothing to do
)

; Default cxmake-get method.
; Return a <c-expr> object of the value of SELF.
; ESTATE is the current rtl evaluator state.
; INDEX is a <hw-index> object.  It must be an ifield.
; SELECTOR is a hardware selector RTX.

(method-make!
 <hardware-base> 'cxmake-get
 (lambda (self estate mode index selector)
   (if (not (eq? 'ifield (hw-index:type index)))
       (error "not an ifield hw-index" index))
   (/cxmake-ifld-val mode (hw-index:value index)))
)

; PC support

; 'gen-set-quiet helper for PC values.
; NEWVAL is a <c-expr> object of the value to be assigned.
; If OPTIONS contains #:direct, set the PC directly, bypassing semantic
; code considerations.
; ??? OPTIONS support wip.  Probably want a new form (or extend existing form)
; of rtx: that takes a variable number of named arguments.
; ??? Another way to get #:direct might be (raw-reg h-pc).

(define (/hw-gen-set-quiet-pc self estate mode index selector newval . options)
  (if (not (send self 'pc?)) (error "Not a PC:" self))
  (cond ((memq #:direct options)
	 (/hw-gen-set-quiet self estate mode index selector newval))
	((current-pbb-engine?)
	 (string-append "npc = " (cx:c newval) ";"
			(if (obj-has-attr? newval 'CACHED)
			    " br_status = BRANCH_CACHEABLE;"
			    " br_status = BRANCH_UNCACHEABLE;")
			(if (assq #:delay (estate-modifiers estate))
			    (string-append " current_cpu->delay_slot_p = true;"
					   " current_cpu->delayed_branch_address = npc;\n")
			    "\n")
			))
	((assq #:delay (estate-modifiers estate))
	 (string-append "current_cpu->delayed_branch (" (cx:c newval) ", npc, status);\n"))
	(else
	 (string-append "current_cpu->branch (" (cx:c newval) ", npc, status);\n")))
)

(method-make! <hw-pc> 'gen-set-quiet /hw-gen-set-quiet-pc)

; Handle updates of the pc during parallel execution.
; This is done in a post-processing pass after semantic evaluation.
; SFMT is the <sformat>.
; OP is the operand.
; ACCESS-MACRO is the runtime C macro to use to fetch indices computed
; during semantic evaluation.
;
; ??? This wouldn't be necessary if gen-set-quiet were a virtual method.
; At this point I'm reluctant to willy nilly make methods virtual.

(method-make!
 <hw-pc> 'gen-write
 (lambda (self estate index mode sfmt op access-macro)
   (string-append "  "
		  (send self 'gen-set-quiet estate VOID index hw-selector-default
			(cx:make VOID (string-append access-macro
						   " (" (gen-sym op) ")")))))
)

(method-make!
 <hw-pc> 'cxmake-skip
 (lambda (self estate yes?)
   (cx:make VOID
	    (string-append "if ("
			   yes?
			   ") {\n"
			   (if (current-pbb-engine?)
			       (string-append "  vpc = current_cpu->skip (vpc);\n")
			       (string-append "  npc = current_cpu->skip (pc);\n"))
			   "}\n")))
)

; Registers.

(method-make-forward! <hw-register> 'type '(gen-type))

(method-make!
 <hw-register> 'gen-defn
 (lambda (self)
   (send (elm-get self 'type) 'gen-sym-defn (obj:name self) (obj:comment self)))
)

(method-make-forward! <hw-register> 'type '(gen-ref
					    gen-sym-get-macro
					    gen-sym-set-macro))

; For parallel instructions supported by queueing outputs for later update,
; return a boolean indicating if an index needs to be recorded.
; An example of when the index isn't needed is if the index can be determined
; during extraction.

(method-make!
 <hw-register> 'save-index?
 (lambda (self op)
   ; For array registers, we need to store away the index. 
   (if (hw-scalar? (op:type op))
       #f
       UINT))
)

; Handle updates of registers during parallel execution.
; This is done in a post-processing pass after semantic evaluation.
; SFMT is the <sformat>.
; OP is the <operand>.
; ACCESS-MACRO is the runtime C macro to use to fetch indices computed
; during semantic evaluation.
; FIXME: May need mode of OP.

(method-make!
 <hw-register> 'gen-write
 (lambda (self estate index mode sfmt op access-macro)
   ; First get a hw-index object to use during indexing.
   ; Some indices, e.g. memory addresses, are computed during semantic
   ; evaluation.  Others are computed during the extraction phase.
   (let ((index (send index 'get-write-index self sfmt op access-macro)))
     (string-append "  "
		    (send self 'gen-set-quiet estate mode index hw-selector-default
			  (cx:make VOID (string-append access-macro
						     " (" (gen-sym op) ")"))))))
)

(method-make!
 <hw-register> 'gen-profile-decl
 (lambda (self)
   (string-append
    "  /* " (obj:comment self) " */\n"
    "  unsigned long " (gen-c-symbol (obj:name self)) ";\n"))
)

(method-make!
 <hw-register> 'gen-record-profile
 (lambda (self index sfmt estate)
   ; FIXME: Need to handle scalars.
   (/gen-hw-index-raw index estate)
   ;(send index 'gen-extracted-field-value)
   )
)

; Utilities to generate register accesses via cover functions.

(define (/hw-gen-fun-get reg estate mode index)
  (let ((scalar? (hw-scalar? reg))
	(c-index (/gen-hw-index index estate)))
    (string-append "current_cpu->"
		   (gen-reg-get-fun-name reg)
		   " ("
		   (if scalar? "" (string-drop 2 (gen-c-args c-index)))
		   ")"))
)

(define (/hw-gen-fun-set reg estate mode index newval)
  (let ((scalar? (hw-scalar? reg))
	(c-index (/gen-hw-index index estate)))
    (string-append "current_cpu->"
		   (gen-reg-set-fun-name reg)
		   " ("
		   (if scalar? "" (string-append (string-drop 2 (gen-c-args c-index)) ", "))
		   (cx:c newval)
		   ");\n"))
)

; Utility to build a <c-expr> object to fetch the value of a register.

(define (/hw-cxmake-get hw estate mode index selector)
  (let ((mode (if (mode:eq? 'DFLT mode)
		  (send hw 'get-mode)
		  mode)))
    ; If the register is accessed via a cover function/macro, do it.
    ; Otherwise fetch the value from the cached address or from the CPU struct.
    (cx:make mode
	     (cond ((or (hw-getter hw)
			(obj-has-attr? hw 'FUN-GET))
		    (/hw-gen-fun-get hw estate mode index))
		   ((and (hw-cache-addr? hw) ; FIXME: redo test
			 (eq? 'ifield (hw-index:type index)))
		    (string-append
		     "* "
		     (if (with-scache?)
			 (gen-hw-index-argbuf-ref index)
			 (gen-hw-index-argbuf-name index))))
		   (else (gen-cpu-ref (hw-isas hw)
				      (send hw 'gen-ref
					    (gen-sym hw) index estate))))))
)

(method-make! <hw-register> 'cxmake-get /hw-cxmake-get)

; raw-reg: support
; ??? raw-reg: support is wip

(method-make!
 <hw-register> 'cxmake-get-raw
 (lambda (self estate mode index selector)
  (let ((mode (if (mode:eq? 'DFLT mode)
		  (send self 'get-mode)
		  mode)))
    (cx:make mode (gen-cpu-ref (hw-isas self)
			       (send self 'gen-ref
				     (gen-sym self) index estate)))))
)

; Utilities to generate C code to assign a variable to a register.

(define (/hw-gen-set-quiet hw estate mode index selector newval)
  (cond ((or (hw-setter hw)
	     (obj-has-attr? hw 'FUN-SET))
	 (/hw-gen-fun-set hw estate mode index newval))
	((and (hw-cache-addr? hw) ; FIXME: redo test
	      (eq? 'ifield (hw-index:type index)))
	 (string-append "* "
			(if (with-scache?)
			    (gen-hw-index-argbuf-ref index)
			    (gen-hw-index-argbuf-name index))
			" = " (cx:c newval) ";\n"))
	(else (string-append (gen-cpu-ref (hw-isas hw)
					  (send hw 'gen-ref
						(gen-sym hw) index estate))
			     " = " (cx:c newval) ";\n")))
)

(method-make! <hw-register> 'gen-set-quiet /hw-gen-set-quiet)

; raw-reg: support
; ??? wip

(method-make!
 <hw-register> 'gen-set-quiet-raw
 (lambda (self estate mode index selector newval)
   (string-append (gen-cpu-ref (hw-isas self)
			       (send self 'gen-ref
				     (gen-sym self) index estate))
		  " = " (cx:c newval) ";\n"))
)

; Return method name of access function.
; Common elements have no prefix.
; Elements specific to a particular isa are prefixed with @@prefix@@_.

(define (gen-reg-get-fun-name hw)
  (string-append (if (and (with-multiple-isa?)
			  (= (length (hw-isas hw)) 1))
		     (string-append (gen-sym (car (hw-isas hw))) "_")
		     "")
		 (gen-sym hw)
		 "_get")
)

(define (gen-reg-set-fun-name hw)
  (string-append (if (and (with-multiple-isa?)
			  (= (length (hw-isas hw)) 1))
		     (string-append (gen-sym (car (hw-isas hw))) "_")
		     "")
		 (gen-sym hw)
		 "_set")
)

; Memory support.

(method-make!
 <hw-memory> 'cxmake-get
 (lambda (self estate mode index selector)
   (let ((mode (if (mode:eq? 'DFLT mode) ;; FIXME: delete, DFLT
		   (hw-mode self)
		   mode))
	 (default-selector? (hw-selector-default? selector)))
     (cx:make mode
	      (string-append "current_cpu->GETMEM" (obj:str-name mode)
			     (if default-selector? "" "ASI")
			     " ("
			     "pc, "
			     (/gen-hw-index index estate)
			     (if default-selector?
				 ""
				 (string-append ", "
						(/gen-hw-selector selector)))
			     ")"))))
)

(method-make!
 <hw-memory> 'gen-set-quiet
 (lambda (self estate mode index selector newval)
   (let ((mode (if (mode:eq? 'DFLT mode)
		   (hw-mode self)
		   mode))
	 (default-selector? (hw-selector-default? selector)))
     (string-append "current_cpu->SETMEM" (obj:str-name mode)
		    (if default-selector? "" "ASI")
		    " ("
		    "pc, "
		    (/gen-hw-index index estate)
		    (if default-selector?
			""
			(string-append ", "
				       (/gen-hw-selector selector)))
		    ", " (cx:c newval) ");\n")))
)

(method-make-forward! <hw-memory> 'type '(gen-type))
(method-make! <hw-memory> 'gen-defn (lambda (self) ""))
(method-make! <hw-memory> 'gen-sym-get-macro (lambda (self sym comment) ""))
(method-make! <hw-memory> 'gen-sym-set-macro (lambda (self sym comment) ""))

; For parallel instructions supported by queueing outputs for later update,
; return the type of the index or #f if not needed.

(method-make!
 <hw-memory> 'save-index?
 (lambda (self op)
   ; In the case of the complete memory address being an immediate
   ; argument, we can return #f (later).
   AI)
)

(method-make!
 <hw-memory> 'gen-write
 (lambda (self estate index mode sfmt op access-macro)
   (let ((index (send index 'get-write-index self sfmt op access-macro)))
     (string-append "  "
		    (send self 'gen-set-quiet estate mode index
			  hw-selector-default
			  (cx:make DFLT (string-append access-macro " ("
						     (gen-sym op)
						     ")"))))))
)

; Immediates, addresses.

(method-make-forward! <hw-immediate> 'type '(gen-type))

(method-make!
 <hw-immediate> 'gen-defn
 (lambda (self)
   (send (elm-get self 'type) 'gen-sym-defn (obj:name self) (obj:comment self)))
)

(method-make-forward! <hw-immediate> 'type '(gen-sym-get-macro
					     gen-sym-set-macro))

(method-make!
 <hw-immediate> 'gen-write
 (lambda (self estate index mode sfmt op access-macro)
   (error "gen-write of <hw-immediate> shouldn't happen"))
)

;; FIXME
(method-make! <hw-address> 'gen-type (lambda (self) "ADDR"))
(method-make! <hw-address> 'gen-defn (lambda (self) ""))
(method-make! <hw-address> 'gen-sym-get-macro (lambda (self sym comment) ""))
(method-make! <hw-address> 'gen-sym-set-macro (lambda (self sym comment) ""))

; Return a <c-expr> object of the value of SELF.
; ESTATE is the current rtl evaluator state.
; INDEX is a hw-index object.  It must be an ifield.
; Needed because we record our own copy of the ifield in ARGBUF.
; SELECTOR is a hardware selector RTX.

(method-make!
 <hw-address> 'cxmake-get
 (lambda (self estate mode index selector)
   (if (not (eq? 'ifield (hw-index:type index)))
       (error "not an ifield hw-index" index))
   (if (with-scache?)
       (cx:make mode (gen-hw-index-argbuf-ref index))
       (cx:make mode (gen-hw-index-argbuf-name index))))
)

(method-make!
 <hw-address> 'gen-write
 (lambda (self estate index mode sfmt op access-macro)
   (error "gen-write of <hw-address> shouldn't happen"))
)

;; FIXME: consistency says there should be gen-defn, gen-sym-[gs]et-macro
(method-make! <hw-iaddress> 'gen-type (lambda (self) "IADDR"))

; Return a <c-expr> object of the value of SELF.
; ESTATE is the current rtl evaluator state.
; INDEX is a <hw-index> object.  It must be an ifield.
; Needed because we record our own copy of the ifield in ARGBUF,
; *and* because we want to record in the result the 'CACHED attribute
; since instruction addresses based on ifields are fixed [and thus cacheable].
; SELECTOR is a hardware selector RTX.

(method-make!
 <hw-iaddress> 'cxmake-get
 (lambda (self estate mode index selector)
   (if (not (eq? 'ifield (hw-index:type index)))
       (error "not an ifield hw-index" index))
   (if (with-scache?)
       ; ??? Perhaps a better way would be to defer evaluating the src of a
       ; set until the method processing the dest.
       (cx:make-with-atlist mode (gen-hw-index-argbuf-ref index)
			    (atlist-make "" (bool-attr-make 'CACHED #t)))
       (cx:make mode (gen-hw-index-argbuf-name index))))
)

; Hardware index support code.

; Return the index to use by the gen-write method.
; In the cases where this is needed (the index isn't known until insn
; execution time), the index is computed along with the value to be stored,
; so this is easy.

(method-make!
 <hw-index> 'get-write-index
 (lambda (self hw sfmt op access-macro)
   (if (memq (hw-index:type self) '(scalar constant enum str-expr ifield))
       self
       (let ((index-mode (send hw 'get-index-mode)))
	 (if index-mode
	     (make <hw-index> 'anonymous 'str-expr index-mode
		   (string-append access-macro " (" (/op-index-name op) ")"))
	     (hw-index-scalar)))))
)

; Return the name of the PAREXEC structure member holding a hardware index
; for operand OP.

(define (/op-index-name op)
  (string-append (gen-sym op) "_idx")
)

; Cover fn to hardware indices to generate the actual C code.
; INDEX is the hw-index object (i.e. op:index).
; The result is a string of C code.
; FIXME:wip

(define (/gen-hw-index-raw index estate)
  (let ((type (hw-index:type index))
	(mode (hw-index:mode index))
	(value (hw-index:value index)))
    (case type
      ((scalar) "")
      ; special case UINT to cut down on unnecessary verbosity.
      ; ??? May wish to handle more similarily.
      ((constant) (if (mode:eq? 'UINT mode)
		      (number->string value)
		      (string-append "((" (mode:c-type mode) ") "
				     (number->string value)
				     ")")))
      ((enum) (let ((sym (hw-index-enum-name index))
		    (obj (hw-index-enum-obj index)))
		(gen-enum-sym obj sym)))
      ((str-expr) value)
      ((rtx) (rtl-c-with-estate estate mode value))
      ((ifield) (if (= (ifld-length value) 0)
		    ""
		    (gen-extracted-ifld-value value)))
      ((operand) (cx:c (send value 'cxmake-get estate mode (op:index value)
			     (op:selector value) #f)))
      (else (error "/gen-hw-index-raw: invalid index:" index))))
)

; Same as /gen-hw-index-raw except used where speedups are possible.
; e.g. doing array index calcs at extraction time.

(define (/gen-hw-index index estate)
  (let ((type (hw-index:type index))
	(mode (hw-index:mode index))
	(value (hw-index:value index)))
    (case type
      ((scalar) "")
      ((constant) (string-append "((" (mode:c-type mode) ") "
				 (number->string value)
				 ")"))
      ((enum) (let ((sym (hw-index-enum-name index))
		    (obj (hw-index-enum-obj index)))
		(gen-enum-sym obj sym)))
      ((str-expr) value)
      ((rtx) (rtl-c-with-estate estate mode value))
      ((ifield) (if (= (ifld-length value) 0)
		    ""
		    (cx:c (/cxmake-ifld-val mode value))))
      ((operand) (cx:c (send value 'cxmake-get estate mode (op:index value)
			     (op:selector value))))
      (else (error "/gen-hw-index: invalid index:" index))))
)

; Return a <c-expr> object of the value of a hardware index.

(method-make!
 <hw-index> 'cxmake-get
 (lambda (self estate mode)
   (let ((mode (if (mode:eq? 'DFLT mode) (elm-get self 'mode) mode)))
     ; If MODE is VOID, abort.
     (if (mode:eq? 'VOID mode)
	 (error "hw-index:cxmake-get: result needs a mode" self))
     (cx:make (if (mode:host? mode)
		  ; FIXME: Temporary hack to generate same code as before.
		  (let ((xmode (object-copy mode)))
		    (obj-cons-attr! xmode (bool-attr-make 'FORCE-C #t))
		    xmode)
		  mode)
	      (/gen-hw-index self estate))))
)

; Hardware selector support code.

; Generate C code for SEL.

(define (/gen-hw-selector sel)
  (rtl-c++ INT #f nil sel)
)

; Instruction operand support code.

; Methods:
; gen-type      - Return C type to use to hold operand's value.
; gen-read      - Record an operand's value prior to parallely executing
;                 several instructions.  Not used if gen-write used.
; gen-write     - Write back an operand's value after parallely executing
;                 several instructions.  Not used if gen-read used.
; cxmake-get    - Return C code to fetch the value of an operand.
; gen-set-quiet - Return C code to set the value of an operand.
; gen-set-trace - Return C code to set the value of an operand, and print
;                 a result trace message.  ??? Ideally this will go away when
;                 trace record support is complete.

; Return the C type of an operand.
; Generally we forward things on to TYPE, but for the actual type we need to
; use the get-mode method.

;(method-make-forward! <operand> 'type '(gen-type))
(method-make!
 <operand> 'gen-type
 (lambda (self)
   ; First get the mode.
   (let ((mode (send self 'get-mode)))
     ; If default mode, use the type's type.
     (if (mode:eq? 'DFLT mode)
	 (send (op:type self) 'gen-type)
	 (mode:c-type mode))))
)

; Extra pc operand methods.

(method-make!
 <pc> 'cxmake-get
 (lambda (self estate mode index selector)
   (let ((mode (if (mode:eq? 'DFLT mode)
		   (send self 'get-mode)
		   mode)))

     (logit 4 "<pc> cxmake-get self=" (obj:name self) " mode=" (obj:name mode) "\n")

     (if (obj-has-attr? self 'RAW)
	 (let ((hw (op:type self))
	       ;; For consistency with <operand> process index,selector similarly.
	       (index (if index index (op:index self)))
	       (selector (if selector selector (op:selector self))))
	   (send hw 'cxmake-get-raw estate mode index selector))
	 ;; The enclosing function must set `pc' to the correct value.
	 (cx:make mode "pc"))))
)

(method-make!
 <pc> 'cxmake-skip
 (lambda (self estate yes?)
   (send (op:type self) 'cxmake-skip estate
	 (rtl-c++ INT (obj-isa-list self) nil yes? #:rtl-cover-fns? #t)))
)

; Default gen-read method.
; This is used to help support targets with parallel insns.
; Either this or gen-write (but not both) is used.

(method-make!
 <operand> 'gen-read
 (lambda (self estate sfmt access-macro)
   (string-append "  "
		  access-macro " ("
		  (gen-sym self)
		  ") = "
		  ; Pass #f for the index -> use the operand's builtin index.
		  ; Ditto for the selector.
		  (cx:c (send self 'cxmake-get estate DFLT #f #f))
		  ";\n"))
)

; Forward gen-write onto the <hardware> object.

(method-make!
 <operand> 'gen-write
 (lambda (self estate sfmt access-macro)
   (let ((write-back-code (send (op:type self) 'gen-write estate
				(op:index self) (op:mode self)
				sfmt self access-macro)))
     ; If operand is conditionally written, we have to check that first.
     ; ??? If two (or more) operands are written based on the same condition,
     ; all the tests can be collapsed together.  Not sure that's a big
     ; enough win yet.
     (if (op:cond? self)
	 (string-append "  if (written & (1ULL << "
			(number->string (op:num self))
			"))\n"
			"    {\n"
			"    " write-back-code
			"    }\n")
	 write-back-code)))
)

; Return <c-expr> object to get the value of an operand.
; ESTATE is the current rtl evaluator state.
; If INDEX is non-#f use it, otherwise use (op:index self).
; This special handling of #f for INDEX is *only* supported for operands
; in cxmake-get, gen-set-quiet, and gen-set-trace.
; Ditto for SELECTOR.

(method-make!
 <operand> 'cxmake-get
 (lambda (self estate mode index selector)
   (let* ((mode (if (mode:eq? 'DFLT mode)
		    (send self 'get-mode)
		    mode))
	  (hw (op:type self))
	  (index (if index index (op:index self)))
	  (idx (if index (/gen-hw-index index estate) ""))
	  (idx-args (if (equal? idx "") "" (string-append ", " idx)))
	  (selector (if selector selector (op:selector self)))
	  (delayval (op:delay self))
	  (md (mode:c-type mode))
	  (name (if 
		 (eq? (obj:name hw) 'h-memory)
		 (string-append md "_memory")
		 (gen-c-symbol (obj:name hw))))
	  (getter (op:getter self))
	  (def-val (cond ((obj-has-attr? self 'RAW)
			  (send hw 'cxmake-get-raw estate mode index selector))
			 (getter
			  (let ((args (car getter))
				(expr (cadr getter)))
			    (rtl-c-expr mode
					(obj-isa-list self)
					(if (= (length args) 0) nil
					    (list (list (car args) 'UINT index)))
					expr
					#:rtl-cover-fns? #t
					#:output-language (estate-output-language estate))))
			 (else
			  (send hw 'cxmake-get estate mode index selector)))))

     (logit 4 "<operand> cxmake-get self=" (obj:name self) " mode=" (obj:name mode)
	    " index=" (obj:name index) " selector=" selector "\n")

     (if delayval
	 (cx:make mode (string-append "lookahead ("
				      (number->string delayval)
				      ", tick, " 
				      "buf." name "_writes, " 
				      (cx:c def-val) 
				      idx-args ")"))
	 def-val)))
)


; Utilities to implement gen-set-quiet/gen-set-trace.

(define (/op-gen-set-quiet op estate mode index selector newval)
  (send (op:type op) 'gen-set-quiet estate mode index selector newval)
)

(define (/op-gen-delayed-set-quiet op estate mode index selector newval)
  (/op-gen-delayed-set-maybe-trace op estate mode index selector newval #f))


(define (/op-gen-set-trace1 op estate mode index selector newval)
  (string-append
   "  {\n"
   "    " (mode:c-type mode) " opval = " (cx:c newval) ";\n"
   (if (and (with-profile?)
	    (op:cond? op))
       (string-append "    written |= (1ULL << "
		      (number->string (op:num op))
		      ");\n")
       "")
; TRACE_RESULT_<MODE> (cpu, abuf, hwnum, opnum, value);
; For each insn record array of operand numbers [or indices into
; operand instance table].
; Could just scan the operand table for the operand or hardware number,
; assuming the operand number is stored in `op'.
   (if (current-pbb-engine?)
       ""
       (string-append
	"    if (UNLIKELY(current_cpu->trace_result_p))\n"
	"      current_cpu->trace_stream << "
	(send op 'gen-pretty-name mode)
	(if (send op 'get-index-mode)
	    (string-append
	     " << '['"
	     " << " 
	     ; print memory addresses in hex
	     (if (string=? (send op 'gen-pretty-name mode) "\"memory\"")
		 " \"0x\" << hex << (UDI) "
		 "")
	     (/gen-hw-index index estate)
	     (if (string=? (send op 'gen-pretty-name mode) "\"memory\"")
		 " << dec"
		 "")
	     " << ']'")
	    "")
	" << \":=0x\" << hex << "
	; Add (SI) or (USI) cast for byte-wide data, to prevent C++ iostreams
	; from printing byte as plain raw char.
	(if (mode:eq? 'QI mode)
	    "(SI) "
	    (if (mode:eq? 'UQI mode)
		"(USI) "
		""))
	"opval << dec << \"  \";\n"))
   ; Dispatch to setter code if appropriate
   "    "
   (if (op:setter op)
       (let ((args (car (op:setter op)))
	     (expr (cadr (op:setter op))))
	 (rtl-c VOID
		(obj-isa-list op)
		(if (= (length args) 0)
		    (list (list 'newval mode "opval"))
		    (list (list (car args) 'UINT index)
			  (list 'newval mode "opval")))
		expr
		#:rtl-cover-fns? #t
		#:output-language (estate-output-language estate)))
       ;else
       (send (op:type op) 'gen-set-quiet estate mode index selector
		(cx:make-with-atlist mode "opval" (cx:atlist newval))))
   "  }\n")
)

(define (/op-gen-set-trace op estate mode index selector newval)
  ;; If tracing hasn't been enabled, use gen-set-quiet, mostly to reduce
  ;; diffs in the generated source from pre-full-canonicalization cgen.
   (if (or (and (with-profile?)
		(op:cond? op))
	   (not (current-pbb-engine?))
	   ;; FIXME: Why doesn't gen-set-quiet check op:setter?
	   (op:setter op))
       (/op-gen-set-trace1 op estate mode index selector newval)
       (/op-gen-set-quiet op estate mode index selector newval))
)

(define (/op-gen-delayed-set-trace op estate mode index selector newval)
  (/op-gen-delayed-set-maybe-trace op estate mode index selector newval #t))

(define (/op-gen-delayed-set-maybe-trace op estate mode index selector newval do-trace?)
  (let* ((pad "    ")
	 (hw (op:type op))
	 (delayval (op:delay op))
	 (md (mode:c-type mode))
	 (name (if 
		(eq? (obj:name hw) 'h-memory)
		(string-append md "_memory")
		(gen-c-symbol (obj:name hw))))
	 (val (cx:c newval))
	 (idx (if index (/gen-hw-index index estate) ""))
	 (idx-args (if (equal? idx "") "" (string-append ", " idx)))
	 )
    
    (if delayval
	(if (eq? (obj:name hw) 'h-memory)
	    (set write-stack-memory-mode-names (cons md write-stack-memory-mode-names))
	    (elm-set! hw 'used-in-delay-rtl? #t)))

    (string-append
     "  {\n"

     (if delayval 

	 ;; delayed write: push it to the appropriate buffer
	 (string-append	    
	  pad md " opval = " val ";\n"
	  pad "buf." name "_writes [(tick + " (number->string delayval)
	  ") % @@prefix@@::pipe_sz].push (@@prefix@@::write<" md ">(pc, opval" idx-args "));\n")

	 ;; else, uh, we should never have been called!
	 (error "/op-gen-delayed-set-maybe-trace called on non-delayed operand"))       
     
     
     (if do-trace?

	 (string-append
; TRACE_RESULT_<MODE> (cpu, abuf, hwnum, opnum, value);
; For each insn record array of operand numbers [or indices into
; operand instance table].
; Could just scan the operand table for the operand or hardware number,
; assuming the operand number is stored in `op'.
   "    if (UNLIKELY(current_cpu->trace_result_p))\n"
   "      current_cpu->trace_stream << "
   (send op 'gen-pretty-name mode)
   (if (send op 'get-index-mode)
       (string-append
	" << '['"
	" << " 
					; print memory addresses in hex
	(if (string=? (send op 'gen-pretty-name mode) "\"memory\"")
	    " \"0x\" << hex << (UDI) "
	    "")
	(/gen-hw-index index estate)
	(if (string=? (send op 'gen-pretty-name mode) "\"memory\"")
	    " << dec"
	    "")
	" << ']'")
       "")
   " << \":=0x\" << hex << "
   ;; Add (SI) or (USI) cast for byte-wide data, to prevent C++ iostreams
   ;; from printing byte as plain raw char.
   (if (mode:eq? 'QI mode)
       "(SI) "
       (if (mode:eq? 'UQI mode)
	   "(USI) "
	   ""))
   "opval << dec << \"  \";\n"
   "  }\n")
	 ;; else no tracing is emitted
	 ""))))

; Return C code to set the value of an operand.
; NEWVAL is a <c-expr> object of the value to store.
; If INDEX is non-#f use it, otherwise use (op:index self).
; This special handling of #f for INDEX is *only* supported for operands
; in cxmake-get, gen-set-quiet, and gen-set-trace.
; Ditto for SELECTOR.

(method-make!
 <operand> 'gen-set-quiet
 (lambda (self estate mode index selector newval)
   (let ((mode (if (mode:eq? 'DFLT mode)
		   (send self 'get-mode)
		   mode))
	 (index (if index index (op:index self)))
	 (selector (if selector selector (op:selector self))))
     (cond ((obj-has-attr? self 'RAW)
	    (send (op:type self) 'gen-set-quiet-raw estate mode index selector newval))
	   ((op:delay self)
	    (/op-gen-delayed-set-quiet self estate mode index selector newval))
	   (else
	    (/op-gen-set-quiet self estate mode index selector newval)))))
)

; Return C code to set the value of an operand and print TRACE_RESULT message.
; NEWVAL is a <c-expr> object of the value to store.
; If INDEX is non-#f use it, otherwise use (op:index self).
; This special handling of #f for INDEX is *only* supported for operands
; in cxmake-get, gen-set-quiet, and gen-set-trace.
; Ditto for SELECTOR.

(method-make!
 <operand> 'gen-set-trace
 (lambda (self estate mode index selector newval)
   (let ((mode (if (mode:eq? 'DFLT mode)
		   (send self 'get-mode)
		   mode))
	 (index (if index index (op:index self)))
	 (selector (if selector selector (op:selector self))))
     (cond ((obj-has-attr? self 'RAW)
	    (send (op:type self) 'gen-set-quiet-raw estate mode index selector newval))
	   ((op:delay self)
	    (/op-gen-delayed-set-trace self estate mode index selector newval))
	   (else
	    (/op-gen-set-trace self estate mode index selector newval)))))
)


; Operand profiling and parallel execution support.

(method-make!
 <operand> 'save-index?
 (lambda (self) (send (op:type self) 'save-index? self))
)

; Return boolean indicating if operand OP needs its index saved
; (for parallel write post-processing support).

(define (op-save-index? op)
  (send op 'save-index?)
)

; Return C code to record profile data for modeling use.
; In the case of a register, this is usually the register's number.
; This shouldn't be called in the case of a scalar, the code should be
; smart enough to know there is no need.

(define (op:record-profile op sfmt out?)
  (let ((estate (vmake <rtl-c-eval-state>
		       #:rtl-cover-fns? #t
		       #:output-language "c++")))
    (send op 'gen-record-profile sfmt out? estate))
)

; Return C code to record the data needed for profiling operand SELF.
; This is done during extraction.

(method-make!
 <operand> 'gen-record-profile
 (lambda (self sfmt out? estate)
   (if (hw-scalar? (op:type self))
       ""
       (string-append "      "
		      (gen-argbuf-ref (string-append (if out? "out_" "in_")
						     (gen-sym self)))
		      " = "
		      (send (op:type self) 'gen-record-profile
			    (op:index self) sfmt estate)
		      ";\n")))
)

; Return C code to track profiling of operand SELF.
; This is usually called by the x-after handler.

(method-make!
 <operand> 'gen-profile-code
 (lambda (self insn when out?)
   (string-append "  "
		  "@@prefix@@_model_mark_"
		  (if out? "set_" "get_")
		  (gen-sym (op:type self))
		  "_" when
		  " (current_cpu"
		  (if (hw-scalar? (op:type self))
		      ""
		      (string-append ", "
				     (gen-argbuf-ref
				      (string-append (if out? "out_" "in_")
						     (gen-sym self)))))
		  ");\n"))
)

; CPU, mach, model support.

; Return the declaration of the cpu/insn enum.

(define (gen-cpu-insn-enum-decl cpu insn-list)
  (gen-enum-decl "@@prefix@@_insn_type"
		 "instructions in cpu family @@prefix@@"
		 "@@PREFIX@@_INSN_"
		 (append (map (lambda (i)
				(cons (obj:name i)
				      (cons '-
					    (atlist-attrs (obj-atlist i)))))
			      insn-list)
			 (if (with-parallel?)
			     (apply append
				    (map (lambda (i)
					   (list
					    (cons (symbol-append 'par- (obj:name i))
						  (cons '-
							(atlist-attrs (obj-atlist i))))
					    (cons (symbol-append 'write- (obj:name i))
						  (cons '-
							(atlist-attrs (obj-atlist i))))))
					 (parallel-insns insn-list)))
			     nil)))
)

; Return the enum of INSN in cpu family CPU.
; In addition to CGEN_INSN_TYPE, an enum is created for each insn in each
; cpu family.  This collapses the insn enum space for each cpu to increase
; cache efficiently (since the IDESC table is similarily collapsed).

(define (gen-cpu-insn-enum cpu insn)
  (string-append "@@PREFIX@@_INSN_" (string-upcase (gen-sym insn)))
)

; Return C code to declare the machine data.

(define (/gen-mach-decls)
  (string-append
   (string-map (lambda (mach)
		 (gen-obj-sanitize mach
				   (string-append "extern const MACH "
						  (gen-sym mach)
						  "_mach;\n")))
	       (current-mach-list))
   "\n")
)

; Return C code to define the machine data.

(define (/gen-mach-data)
  (string-append
   "const MACH *sim_machs[] =\n{\n"
   (string-map (lambda (mach)
		 (gen-obj-sanitize
		  mach
		  (string-append "#ifdef " (gen-have-cpu (mach-cpu mach)) "\n"
				 "  & " (gen-sym mach) "_mach,\n"
				 "#endif\n")))
	       (current-mach-list))
   "  0\n"
   "};\n\n"
   )
)

; Return C declarations of cpu model support stuff.
; ??? This goes in arch.h but a better place is each cpu.h.

(define (/gen-arch-model-decls)
  (string-append
   (gen-enum-decl 'model_type "model types"
		  "MODEL_"
		  (append (map (lambda (model)
				 (cons (obj:name model)
				       (cons '-
					     (atlist-attrs (obj-atlist model)))))
			       (current-model-list))
			  '((max))))
   "#define MAX_MODELS ((int) MODEL_MAX)\n\n"
  )
)

; Function units.

(method-make! <unit> 'gen-decl (lambda (self) ""))

; Lookup operand named OP-NAME in INSN.
; Returns #f if OP-NAME is not an operand of INSN.
; IN-OUT is 'in to request an input operand, 'out to request an output operand,
; and 'in-out to request either (though if an operand is used for input and
; output then the input version is returned).
; FIXME: Move elsewhere.

(define (insn-op-lookup op-name insn in-out)
  (letrec ((lookup (lambda (op-list)
		     (cond ((null? op-list) #f)
			   ((eq? op-name (op:sem-name (car op-list))) (car op-list))
			   (else (lookup (cdr op-list)))))))
    (case in-out
      ((in) (lookup (sfmt-in-ops (insn-sfmt insn))))
      ((out) (lookup (sfmt-out-ops (insn-sfmt insn))))
      ((in-out) (or (lookup (sfmt-in-ops (insn-sfmt insn)))
		    (lookup (sfmt-out-ops (insn-sfmt insn)))))
      (else (error "insn-op-lookup: bad arg:" in-out))))
)

; Return C code to profile a unit's usage.
; UNIT-NUM is number of the unit in INSN.
; OVERRIDES is a list of (name value) pairs, where
; - NAME is a spec name, one of cycles, pred, in, out.
;   The only ones we're concerned with are in,out.  They map operand names
;   as they appear in the semantic code to operand names as they appear in
;   the function unit spec.
; - VALUE is the operand to NAME.  For in,out it is (NAME VALUE) where
;   - NAME is the name of an input/output arg of the unit.
;   - VALUE is the name of the operand as it appears in semantic code.
;
; ??? This is a big sucker, though half of it is just the definitions
; of utility fns.

(method-make!
 <unit> 'gen-profile-code
 (lambda (self unit-num insn when overrides cycles-var-name)
   (logit 3 "  'gen-profile-code\n")
   (let (
	 (inputs (unit:inputs self))
	 (outputs (unit:outputs self))

	  ; Return C code to initialize UNIT-REFERENCED-VAR to be a bit mask
	  ; of operands of UNIT that were read/written by INSN.
	  ; INSN-REFERENCED-VAR is a bitmask of operands read/written by INSN.
	  ; All we have to do is map INSN-REFERENCED-VAR to
	  ; UNIT-REFERENCED-VAR.
	  ; ??? For now we assume all input operands are read.
	  (gen-ref-arg (lambda (arg num in-out)
			 (logit 3 "    gen-ref-arg\n")
			 (let* ((op-name (assq-ref overrides (car arg)))
				(op (insn-op-lookup (if op-name
							(car op-name)
							(car arg))
						    insn in-out))
				(insn-referenced-var "insn_referenced")
				(unit-referenced-var "referenced"))
			   (if op
			       (if (op:cond? op)
				   (string-append "    "
						  "if ("
						  insn-referenced-var
						  " & (1 << "
						  (number->string (op:num op))
						  ")) "
						  unit-referenced-var
						  " |= 1 << "
						  (number->string num)
						  ";\n")
				   (string-append "    "
						  unit-referenced-var
						  " |= 1 << "
						  (number->string num)
						  ";\n"))
			       ""))))

	  ; Initialize unit argument ARG.
	  ; OUT? is #f for input args, #t for output args.
	  (gen-arg-init (lambda (arg out?)
			 (logit 3 "    gen-arg-unit\n")
			  (if (or
			       ; Ignore scalars.
			       (null? (cdr arg))
			       ; Ignore remapped arg, handled elsewhere.
			       (assq (car arg) overrides)
			       ; Ignore operands not in INSN.
			       (not (insn-op-lookup (car arg) insn
						    (if out? 'out 'in))))
			      ""
			      (string-append "    "
					     (if out? "out_" "in_")
					     (gen-c-symbol (car arg))
					     " = "
					     (gen-argbuf-ref
					      (string-append (if out? "out_" "in_")
							     (gen-c-symbol (car arg))))
					     ";\n"))))

	  ; Return C code to declare variable to hold unit argument ARG.
	  ; OUT? is #f for input args, #t for output args.
	  (gen-arg-decl (lambda (arg out?)
			 (logit 3 "    gen-arg-decl " arg out? "\n")
			  (if (null? (cdr arg)) ; ignore scalars
			      ""
			      (string-append "    "
					     (mode:c-type (mode:lookup (cadr arg)))
					     " "
					     (if out? "out_" "in_")
					     (gen-c-symbol (car arg))
					     " = "
					     (if (null? (cddr arg))
						 "0"
						 (number->string (caddr arg)))
					     ";\n"))))

	  ; Return C code to pass unit argument ARG to the handler.
	  ; OUT? is #f for input args, #t for output args.
	  (gen-arg-arg (lambda (arg out?)
			 (logit 3 "    gen-arg-arg\n")
			 (if (null? (cdr arg)) ; ignore scalars
			     ""
			     (string-append ", "
					    (if out? "out_" "in_")
					    (gen-c-symbol (car arg))))))
	  )

     (string-append
      "  {\n"
      (if (equal? when 'after)
	  (string-append
	   "    int referenced = 0;\n"
	   "    unsigned long long insn_referenced = abuf->written;\n")
	  "")
      ; Declare variables to hold unit arguments.
      (string-map (lambda (arg) (gen-arg-decl arg #f))
		  inputs)
      (string-map (lambda (arg) (gen-arg-decl arg #t))
		  outputs)
      ; Initialize 'em, being careful not to initialize an operand that
      ; has an override.
      (let (; Make a list of names of in/out overrides.
	    (in-overrides (find-apply cadr
				      (lambda (elm) (eq? (car elm) 'in))
				      overrides))
	    (out-overrides (find-apply cadr
				      (lambda (elm) (eq? (car elm) 'out))
				      overrides)))
	(string-append
	 (string-map (lambda (arg)
		       (if (memq (car arg) in-overrides)
			   ""
			   (gen-arg-init arg #f)))
		     inputs)
	 (string-map (lambda (arg)
		       (if (memq (car arg) out-overrides)
			   ""
			   (gen-arg-init arg #t)))
		     outputs)))
      (string-map (lambda (arg)
		    (case (car arg)
		      ((pred) "")
		      ((cycles) "")
		      ((in)
		       (if (caddr arg)
			   (string-append "    in_"
					  (gen-c-symbol (cadr arg))
					  " = "
					  (gen-argbuf-ref
					   (string-append
					    "in_"
					    (gen-c-symbol (caddr arg))))
					  ";\n")
			   ""))
		      ((out)
		       (if (caddr arg)
			   (string-append "    out_"
					  (gen-c-symbol (cadr arg))
					  " = "
					  (gen-argbuf-ref
					   (string-append
					    "out_"
					    (gen-c-symbol (caddr arg))))
					  ";\n")
			   ""))
		      (else
		       (parse-error (make-prefix-context "insn function unit spec")
				    "invalid spec" arg))))
		  overrides)
      ; Create bitmask indicating which args were referenced.
      (if (equal? when 'after)
	  (string-append
	   (string-map (lambda (arg num) (gen-ref-arg arg num 'in))
		       inputs
		       (iota (length inputs)))
	   (string-map (lambda (arg num) (gen-ref-arg arg num 'out))
		       outputs
		       (iota (length outputs)
			     (length inputs))))
	  "")
      ; Emit the call to the handler.
      "    " cycles-var-name " += "
      (gen-model-unit-fn-name (unit:model self) self when)
      " (current_cpu, idesc"
      ", " (number->string unit-num)
      (if (equal? when 'after) ", referenced" "")
      (string-map (lambda (arg) (gen-arg-arg arg #f))
		  inputs)
      (string-map (lambda (arg) (gen-arg-arg arg #t))
		  outputs)
      ");\n"
      "  }\n"
      )))
)

; Return C code to profile an insn-specific unit's usage.
; UNIT-NUM is number of the unit in INSN.

(method-make!
 <iunit> 'gen-profile-code
 (lambda (self unit-num insn when cycles-var-name)
   (let ((args (iunit:args self))
	 (unit (iunit:unit self)))
     (send unit 'gen-profile-code unit-num insn when args cycles-var-name)))
)

; Mode support.

; Generate a table of mode data.
; For now all we need is the names.

(define (gen-mode-defs)
  (string-append
   "const char *mode_names[] = {\n"
   (string-map (lambda (m)
		 (string-append "  \"" (string-upcase (obj:str-name m)) "\",\n"))
	       ; We don't treat aliases as being different from the real
	       ; mode here, so ignore them.
	       (mode-list-non-alias-values))
   "};\n\n"
   )
)

; Insn profiling support.

; Generate declarations for local variables needed for modelling code.

(method-make!
 <insn> 'gen-profile-locals
 (lambda (self model)
;   (let ((cti? (or (has-attr? self 'UNCOND-CTI)
;		   (has-attr? self 'COND-CTI))))
;     (string-append
;      (if cti? "  int UNUSED taken_p = 0;\n" "")
;      ))
   "")
)

; Generate C code to profile INSN.

(method-make!
 <insn> 'gen-profile-code
 (lambda (self model when cycles-var-name)
   (string-append
    (let ((timing (assq-ref (insn-timing self) (obj:name model))))
      (if timing
	  (string-map (lambda (iunit unit-num)
			(send iunit 'gen-profile-code unit-num self when cycles-var-name))
		      (timing:units timing)
		      (iota (length (timing:units timing))))
	  (send (model-default-unit model) 'gen-profile-code 0 self when nil cycles-var-name)))
    ))
)

; Instruction support.

; Return list of all instructions to use for scache engine.
; This is all real insns plus the `invalid' and `cond' virtual insns.
; It does not include the pbb virtual insns.

(define (scache-engine-insns)
  (non-multi-insns (non-alias-pbb-insns (current-insn-list)))
)

; Return list of all instructions to use for pbb engine.
; This is all real insns plus the `invalid' and `cond' virtual insns.

(define (pbb-engine-insns)
  (real-insns (current-insn-list))
)

;; Subroutine of /create-virtual-insns!.
;; Add virtual insn INSN to the database.
;; We put virtual insns ahead of normal insns because they're kind of special,
;; and it helps to see them first in lists.
;; ORDINAL is a used to place the insn ahead of normal insns;
;; it is a pair so we can do the update for the next virtual insn here.

(define (/virtual-insn-add! ordinal insn)
  (obj-set-ordinal! insn (cdr ordinal))
  (current-insn-add! insn)
  (set-cdr! ordinal (- (cdr ordinal) 1))
)

; Create the virtual insns.

(define (/create-virtual-insns! isa)
  (let ((isa-name (obj:name isa))
	(context (make-prefix-context "virtual insns"))
	;; Record as a pair so /virtual-insn-add! can update it.
	(ordinal (cons #f -1)))

    (/virtual-insn-add!
     ordinal
     (insn-read context
		'(name x-invalid)
		'(comment "invalid insn handler")
		`(attrs VIRTUAL (ISA ,isa-name))
		'(syntax "--invalid--")
		'(semantics (c-code VOID "\
  {
    current_cpu->invalid_insn (pc);
    assert (0);
    /* NOTREACHED */
  }
"))
		))

    (if (with-pbb?)
	(begin
	  (/virtual-insn-add!
	   ordinal
	   (insn-read context
		      '(name x-begin)
		      '(comment "pbb begin handler")
		      `(attrs VIRTUAL PBB (ISA ,isa-name))
		      '(syntax "--begin--")
		      '(semantics (c-code VOID "\
  {
    vpc = current_cpu->@@prefix@@_pbb_begin (current_cpu->h_pc_get ());
  }
"))
		      ))

	  (/virtual-insn-add!
	   ordinal
	   (insn-read context
		      '(name x-chain)
		      '(comment "pbb chain handler")
		      `(attrs VIRTUAL PBB (ISA ,isa-name))
		      '(syntax "--chain--")
		      '(semantics (c-code VOID "\
  {
    vpc = current_cpu->@@prefix@@_engine.pbb_chain (current_cpu, abuf);
    // If we don't have to give up control, don't.
    // Note that we may overrun step_insn_count since we do the test at the
    // end of the block.  This is defined to be ok.
    if (UNLIKELY(current_cpu->stop_after_insns_p (abuf->fields.chain.insn_count)))
      BREAK (vpc);
  }
"))
		      ))

	  (/virtual-insn-add!
	   ordinal
	   (insn-read context
		      '(name x-cti-chain)
		      '(comment "pbb cti-chain handler")
		      `(attrs VIRTUAL PBB (ISA ,isa-name))
		      '(syntax "--cti-chain--")
		      '(semantics (c-code VOID "\
  {
    vpc = current_cpu->@@prefix@@_engine.pbb_cti_chain (current_cpu, abuf, pbb_br_status, pbb_br_npc);
    // If we don't have to give up control, don't.
    // Note that we may overrun step_insn_count since we do the test at the
    // end of the block.  This is defined to be ok.
    if (UNLIKELY(current_cpu->stop_after_insns_p (abuf->fields.chain.insn_count)))
      BREAK (vpc);
  }
"))
		      ))

	  (/virtual-insn-add!
	   ordinal
	   (insn-read context
		      '(name x-before)
		      '(comment "pbb before handler")
		      `(attrs VIRTUAL PBB (ISA ,isa-name))
		      '(syntax "--before--")
		      '(semantics (c-code VOID "\
  {
    current_cpu->@@prefix@@_engine.pbb_before (current_cpu, abuf);
  }
"))
		      ))

	  (/virtual-insn-add!
	   ordinal
	   (insn-read context
		      '(name x-after)
		      '(comment "pbb after handler")
		      `(attrs VIRTUAL PBB (ISA ,isa-name))
		      '(syntax "--after--")
		      '(semantics (c-code VOID "\
  {
    current_cpu->@@prefix@@_engine.pbb_after (current_cpu, abuf);
  }
"))
		      ))

	  ))

    ; If entire instruction set is conditionally executed, create a virtual
    ; insn to handle that.
    (if (and (with-pbb?)
	     (isa-conditional-exec? isa))
	(/virtual-insn-add!
	 ordinal
	 (insn-read context
		    '(name x-cond)
		    '(syntax "conditional exec test")
		    `(attrs VIRTUAL PBB (ISA ,isa-name))
		    '(syntax "--cond--")
		    (list 'semantics (list 'c-code 'VOID
					   (string-append "\
  {
    // Assume branch not taken.
    pbb_br_status = BRANCH_UNTAKEN;
    UINT cond_code = abuf->cond;
    BI exec_p = "
    (rtl-c++ DFLT
	     (list (obj:name isa))
	     '((cond-code UINT "cond_code"))
	     (cadr (isa-condition isa))
	     #:rtl-cover-fns? #t)
    ";
    if (! exec_p)
      ++vpc;
  }
")))
		    )))
    )
)

; Return a boolean indicating if INSN should be split.

(define (/decode-split-insn? insn isa)
  (let loop ((split-specs (isa-decode-splits isa)))
    (cond ((null? split-specs)
	   #f)
	  ((let ((f-name (decode-split-name (car split-specs))))
	     (and (insn-has-ifield? insn f-name)
		  (let ((constraint
			 (decode-split-constraint (car split-specs))))
		    (or (not constraint)
			(rtl-eval -FIXME-unfinished-)))))
	   #t)
	  (else (loop (cdr split-specs)))))		  
)

; Subroutine of /decode-split-insn-1.
; Build the ifield-assertion for ifield F-NAME.
; VALUE is either a number or a non-empty list of numbers.

(define (/decode-split-build-assertion f-name value)
  (if (number? value)
      (rtx-make 'eq 'INT (rtx-make 'ifield f-name) (rtx-make 'const 'INT value))
      (rtx-make 'member (rtx-make 'ifield f-name)
		(apply rtx-make (cons 'number-list (cons 'INT value)))))
)

; Subroutine of /decode-split-insn.
; Specialize INSN according to <decode-split> dspec.

(define (/decode-split-insn-1 insn dspec)
  (let ((f-name (decode-split-name dspec))
	(values (decode-split-values dspec)))
    (let ((result (map object-copy (make-list (length values) insn))))
      (for-each (lambda (insn-copy value)
		  (obj-set-name! insn-copy
				 (symbol-append (obj:name insn-copy)
						'-
						(car value)))
		  (obj-cons-attr! insn-copy (bool-attr-make 'DECODE-SPLIT #t))
		  (let ((existing-assertion (insn-ifield-assertion insn-copy))
			(split-assertion 
			 (/decode-split-build-assertion f-name (cadr value))))
		    (insn-set-ifield-assertion!
		     insn-copy
		     (if existing-assertion
			 (rtx-make 'andif split-assertion existing-assertion)
			 split-assertion)))
		  )
		result values)
      result))
)

; Split INSN.
; The result is a list of the split copies of INSN.

(define (/decode-split-insn insn isa)
  (logit 3 "Splitting " (obj:name insn) " ...\n")
  (let loop ((splits (isa-decode-splits isa)) (result nil))
    (cond ((null? splits)
	   result)
	  ; FIXME: check constraint
	  ((insn-has-ifield? insn (decode-split-name (car splits)))
	   ; At each iteration, split the result of the previous.
	   (loop (cdr splits)
		 (if (null? result)
		     (/decode-split-insn-1 insn (car splits))
		     (apply append
			    (map (lambda (insn)
				   (/decode-split-insn-1 insn (car splits)))
				 result)))))
	  (else
	   (loop (cdr splits) result))))
)

; Create copies of insns to be split.
; ??? better phrase needed?  Possible confusion with gcc's define-split.
; The original insns are then marked as aliases so the simulator ignores them.

(define (/fill-sim-insn-list!)
  (let ((isa (current-isa)))

    (if (not (null? (isa-decode-splits isa)))

	(begin
	  (logit 1 "Splitting instructions ...\n")
	  (for-each (lambda (insn)
		      (if (and (insn-real? insn)
			       (insn-semantics insn)
			       (/decode-split-insn? insn isa))
			  (let ((ord (obj-ordinal insn))
				(sub-ord 1))
			    (for-each (lambda (new-insn)
					;; Splice new insns next to original.
					;; Keeps things tidy and generated code
					;; easier to read for human viewer.
					;; This is done by using an ordinal of
					;; (major . minor).
					(obj-set-ordinal! new-insn
							  (cons ord sub-ord))
					(current-insn-add! new-insn)
					(set! sub-ord (+ sub-ord 1)))
				      (/decode-split-insn insn isa))
			    (obj-cons-attr! insn (bool-attr-make 'ALIAS #t)))))
		    (current-insn-list))
	  (logit 1 "Done splitting.\n"))
	))

  *UNSPECIFIED*
)

; .cpu file loading support

; Only run sim-analyze-insns! once.
(define /sim-insns-analyzed? #f)

; List of computed sformat argument buffers.
(define /sim-sformat-argbuf-list #f)
(define (current-sbuf-list) /sim-sformat-argbuf-list)

; Called before the .cpu file has been read in.

(define (sim-init!)
  (set! /sim-insns-analyzed? #f)
  (set! /sim-sformat-argbuf-list #f)
  (if (with-sem-frags?)
      (sim-sfrag-init!))
  *UNSPECIFIED*
)

; Called after the .cpu file has been read in.

(define (sim-finish!)
  ; Specify FUN-GET/SET in the .sim file to cause all hardware references to
  ; go through methods, thus allowing the programmer to override them.
  (define-attr '(for hardware) '(type boolean) '(name FUN-GET)
    '(comment "read hardware elements via cover functions/methods"))
  (define-attr '(for hardware) '(type boolean) '(name FUN-SET)
    '(comment "write hardware elements via cover functions/methods"))

  ; If there is a .sim file, load it.
  (let ((sim-file (string-append srcdir "/cpu/"
				 (symbol->string (current-arch-name))
				 ".sim")))
    (if (file-exists? sim-file)
	(begin
	  (display (string-append "Loading sim file " sim-file " ...\n"))
	  (reader-read-file! sim-file))))

  ; If we're building files for an isa, create the virtual insns.
  (if (not (keep-isa-multiple?))
      (/create-virtual-insns! (current-isa)))

  *UNSPECIFIED*
)

; Called after file is read in and global error checks are done
; to initialize tables.

(define (sim-analyze!)
  *UNSPECIFIED*
)

; Scan insns, copying them to the simulator insn list, splitting the
; requested insns, then analyze the semantics and compute instruction formats.
; 'twould be nice to do this in sim-analyze! but it doesn't know whether this
; needs to be done or not (which is determined by what files are being
; generated).  Since this is an expensive operation, we defer doing this
; to the files that need it.

(define (sim-analyze-insns!)
  ; This can only be done if one isa and one cpu family is being kept.
  (assert-keep-one)

  (if (not /sim-insns-analyzed?)

      (begin
	(/fill-sim-insn-list!)

	(arch-analyze-insns! CURRENT-ARCH
			     #f ; don't include aliases
			     #t) ; do analyze the semantics

	; Compute the set of sformat argument buffers.
	(set! /sim-sformat-argbuf-list
	      (compute-sformat-argbufs! (current-sfmt-list)))

	(set! /sim-insns-analyzed? #t)
	))

  ; Do our own error checking.
  (assert (current-insn-lookup 'x-invalid #f))

  *UNSPECIFIED*
)
@


1.29
log
@	* utils-cgen.scm (<location>): Define using new define-class.
	(<ident>, <source-ident>, <context>): Ditto.

	* cos.scm (/object-string): New function.
	(/object-error): Use it.
	(/object-count-true): New function
	(object-copy-top): Delete.  All callers changed to call object-copy.
	(/parse-member-list, /build-getter-defs, /build-setter-defs): New fns.
	(define-class, define-interface, define-method): New macros.
	(define-getters, define-setters, vmake): Moved here ...
	* utils-cgen.scm: ... from here.
@
text
@d1098 1
a1098 1
	 (rtl-c 'VOID
@


1.28
log
@	* hardware.scm (hw-pc?): New function.
	* ifield.scm (ifld-signed?): New function.
	* iformat.scm (ifmt-analyze): Call insn-cti-attr? instead of insn-cti?.
	* insn.scm (insn-cti-attr?): Renamed from insn-ctl?.
	(insn-cti?): New function.
	* rtl.scm (/hw): Create <pc> object for pcs.
	* semantics.scm (/build-reg-operand!): New args ref-type, sem-attrs.
	All callers updated.  Watch for sets to the pc.
	(semantic-attrs): Watch for sets to the pc.
	* sid.scm (<pc> cxmake-get): Handle raw-reg.
	* sim.scm (<pc> cxmake-get): Handle raw-reg.
	(<operand> cxmake-get): Add debugging printf.
	* utils-gen.scm (/gen-ifld-extract-base): Emit calls to
	EXTRACT_[LM]SB0_LG[SU]INT for values > 32 bits.
	(/gen-extract-word): Ditto.

	* utils.scm (gen-c-hex-constant): New function.
	* utils-sim.scm (/gen-decode-insn-entry): Call it.
@
text
@d873 1
a873 1
		  (let ((xmode (object-copy-top mode)))
d1874 1
a1874 1
    (let ((result (map object-copy-top (make-list (length values) insn))))
@


1.27
log
@	* utils.scm (reduce): Delete.

	* rtl-traverse.scm (/rtx-canon-rtx-enum): Tweak local name.

	* enum.scm (gen-enum-sym): Make consistent with gen-enum-decl
	regarding PREFIX attribute handling.

	* operand.scm (<hw-index>): Add enum to possible types, all uses
	updated.
	(hw-index-constant?, hw-index-constant-value): New functions.
	(make-enum-hw-index, hw-index-enum-name, hw-index-enum-value,
	hw-index-enum-obj): New functions.
	(/operand-parse): Handle enum indices.
	* intrinsics.scm (md-operand:fixed-register): Use hw-index-constant?,
	hw-index-constant-value.
	* rtl.scm (rtx-constant-value): Fix handling of enums.
	* rtx-funcs.scm (enum): Ditto.
	* sid.scm (<hardware-base> cxmake-get): Only ifield indices are
	currently supported here.
@
text
@d926 11
a936 2
     ; The enclosing function must set `pc' to the correct value.
     (cx:make mode "pc")))
d1024 1
a1024 1
     
d1027 1
a1027 1
     
@


1.26
log
@	Specify isa(s) when doing ifield, operand, insn lookups.
	ACU = all callers updated.
	* attr.scm (/attr-eval): Call rtx-value instead of rtx-eval-with-estate.
	* enum.scm (define-full-insn-enum): Pass isa-name-list to
	current-ifld-lookup.
	* html.scm (get-insn-properties): Pass isa-name-list to
	current-op-lookup.
	* ifield.scm (/ifld-parse-follows): New arg isas, ACU.
	* insn.scm (/parse-insn-format-symbol): New arg isa-name-list, ACU.
	(/parse-insn-format-list, /parse-insn-iformat-iflds): Ditto.
	(/parse-insn-format, syntax-break-out): Ditto.
	* mach.scm (obj-filter-by-isa): New function.
	(current-ifld-lookup): New optional arg maybe-isa-name-list.
	(/ifld-already-defined?, /op-already-defined?): Simplify.
	(current-op-lookup): New optional arg maybe-isa-name-list.
	(current-insn-lookup): New arg isa-name-list, ACU.
	(/insn-already-defined?, /minsn-already-defined?): Simplify.
	(current-minsn-lookup): New arg isa-name-list, ACU.
	* minsn.scm (/minsn-compute-iflds): Pass isa-name-list to
	current-op-lookup.
	* opc-itab.scm (compute-syntax): New arg isa-name-list, ACU.
	(gen-syntax-entry): Ditto.
	* operand.scm (/operand-parse): Pass isa-name-list to
	current-ifld-lookup.
	(/derived-parse-encoding): New arg isa-name-list, ACU.
	(/derived-parse-ifield-assertion): Ditto.
	(/derived-operand-parse): Pass isa-name-list to current-op-lookup.
	(/anyof-parse-choice): Ditto.
	(anyof-satisfies-assertions?): Pass context to rtx-solve.
	(/anyof-merge-syntax): New arg container, ACU.
	(operand-builtin!): Add pc to all isas.
	* rtl-c.scm (estate-make-for-rtl-c): Delete arg extra-vars-alist, ACU.
	(estate-make-for-rtl-c++, rtl-c-expr-parsed): Ditto.
	(rtl-c-parsed, rtl-c++-parsed): Ditto.
	(rtl-c): New arg isa-name-list, ACU.
	(rtl-c-expr, rtl-c++): Ditto.
	(closure): New arg isa-name-list, ACU.
	* rtl-traverse.scm (/make-cstate): New arg isa-name-list, ACU.
	(/cstate-isas): New function.
	(/rtx-canon-symbol-list): New function.
	(/rtx-canon-env-stack): Renamed from /rtx-canon-env, ACU.
	updated.
	(/rtx-make-canon-table): Rename ENV to ENVSTACK, new entry SYMBOLLIST.
	(/rtx-canon-rtx-operand): Pass isa list to current-op-lookup.
	(/rtx-canon-rtx-ref, /rtx-canon): Ditto.
	(rtx-canonicalize): New arg isa-name-list, ACU.
	(rtx-canonicalize-stmt): Delete.
	(tstate-make): New arg isas, ACU.
	(tstate-isas, tstate--set-isas!): New functions.
	(tstate-env-stack): Renamed from tstate-env, ACU.
	(tstate-set-env-stack!): Renamed from tstate-set-env!, ACU.
	(tstate-make-closure): Renamed from tstate-new-env, new arg
	isa-name-list, ACU.
	(/rtx-traverse-env): Delete.
	(/rtx-make-traverser-table): Rename ENV to ENVSTACK, new entry
	SUMBOLLIST.
	(/rtx-traverse): Include conditional flag in dump output.
	Update isa,envstack for closures.  Pass isa list to current-op-lookup.
	(<eval-state>): New member isas.  Rename env to env-stack.
	(<eval-state> vmake!): Handle #:isas.  #:env renamed to #:env-stack.
	(<eval-state>): New getter/setter for isas.  Rename env getter/setter
	to env-stack.
	(estate-make-for-eval): Provide #:isas.
	(estate-make-closure): Renamed from estate-new-env.  New arg
	isa-name-list, ACU.
	* rtl-xform.scm (/rtx-simplify-expr-fn): Handle closures.
	(/rtx-trim-args): ENV renamed to ENVSTACK.  Ad ITERATION, SYMBOLLIST.
	(/rtx-trim-for-doc): Handle closures.
	* rtl.scm (/rtx-valid-types): Rename ENV to ENVSTACK.  Add ITERATION,
	SYMBOLLIST.
	(rtx-env-var-list): Delete.
	(rtx-env-make): Handle already-compiled environments.
	(rtx-var-alist-to-env): New function.
	(rtx-var-alist-to-closure-env-stack, rtx-make-env-stack): New functions.
	(rtx-env-stack-dump): Renamed from rtx-env-dump, ACU.
	(rtx-operand-obj): New arg isa-name-list, ACU.
	(rtx-closure-isas, rtx-closure-env-stack, rtx-closure-expr): New
	functions.
	* rtx-funcs.scm (closure): New arg isa-name-list, reorder args, ACU.
	* sem-frags.scm (<sfrag>): Delete member compiled-semantics.
	(/frag-compute-desired-frags): Minor simplification.
	(/frag-pick-best): Ditto.
	* sid-cpu.scm (gen-semantic-code): Require canonical rtl.
	(/gen-sfrag-code): Update.
	* sim-cpu.scm (gen-semantic-code): Require canonical rtl.
	* utils-cgen.scm (sanitize): New arg isa-name-list, ACU.
	* utils.scm (non-null-intersection?): New function.
@
text
@d387 2
a388 2
   ;(if (not (eq? 'ifield (hw-index:type index)))
   ;    (error "not an ifield hw-index" index))
d790 1
a790 1
   (if (memq (hw-index:type self) '(scalar constant str-expr ifield))
d824 3
d849 3
@


1.25
log
@	* cos.scm (/method-lookup): Delete arg virtual?, all callers updated.
	(method-proc): Delete.
	(method-make-virtual!, method-make-virtual-forward!): Delete.
	* ifield.scm (<ifield> field-start): Update.
	(<ifield> field-length, pretty-print): Update.
	(<multi-ifield> field-length, field-start, pretty-print): Update.
	* sid-cpu.scm (/gen-hardware-struct): Use gen-defn instead of gen-decl.
	* sid.scm (<scalar> gen-sym-defn): Renamed from gen-sym-decl.
	(<array> gen-sym-defn): Ditto.
	(<hardware-base> gen-defn): Renamed from gen-defn.
	(<hw-register> gen-type): Update.
	(<hw-register> gen-defn): Renamed from gen-sym-decl, rewrite.
	(<hw-memory>, <hw-address>, <hw-iaddress> gen-type): Update.
	(<hw-memory>, <hw-address> gen-defn): Renamed from gen-sym-decl.
	(<hw-immediate> gen-type): Update.
	(<hw-immediate> gen-defn): Renamed from gen-sym-decl, rewrite.
	* sim-cpu.scm (/gen-hardware-struct): Use gen-defn instead of gen-decl.
	* sim.scm (<scalar> gen-sym-defn): Renamed from gen-sym-decl.
	(<array> gen-sym-defn): Ditto.
	(<hardware-base> gen-defn): Renamed from gen-defn.
	(<hw-register> gen-type): Update.
	(<hw-register> gen-defn): Renamed from gen-sym-decl, rewrite.
	(<hw-memory>, <hw-address>, <hw-iaddress> gen-type): Update.
	(<hw-memory>, <hw-address> gen-defn): Renamed from gen-sym-decl.
	(<hw-immediate> gen-type): Update.
	(<hw-immediate> gen-defn): Renamed from gen-sym-decl, rewrite.
@
text
@d879 1
a879 1
  (rtl-c++ 'INT sel nil)
d928 1
a928 1
	 (rtl-c++ INT yes? nil #:rtl-cover-fns? #t)))
d1000 2
a1001 1
			    (rtl-c-expr mode expr
d1004 1
d1083 2
a1084 1
	 (rtl-c 'VOID expr
d1089 1
d1812 4
a1815 1
    (rtl-c++ DFLT (cadr (isa-condition isa)) '((cond-code UINT "cond_code"))
d2017 1
a2017 1
  (assert (current-insn-lookup 'x-invalid))
@


1.24
log
@	* xc16x.cpu (h-cr): New hardware.
	(muls): Comment out parts that won't compile, add fixme.
	(mulu, divl, divlu, jmpabs, jmpa-, jmprel, jbc, jnbs, callr): Ditto.
	(scxti, scxtmg, scxtm, bclear, bclr18, bset19, bitset, bmov): Ditto.
	(bmovn, band, bor, bxor, bcmp, bfldl, bfldh): Ditto.

	Rewrite rtl processing to require it to be "canonicalized" first,
	and write a full canonicalizer / expression checker.
	Remove all appearances of DFLT in canonical rtl.
	* attr.scm (/attr-eval atval owner): Call rtx-canonicalize,
	then rtx-simplify.
	* iformat.scm (ifmt-analyze) Use canonical semantics.
	* insn (<insn>): New member canonical-semantics.
	* mach.scm (<arch>): New member multi-insns-instantiated?.
	(/instantiate-multi-insns!): New function.
	(/canonicalize-insns!): New function.
	(arch-analyze-insns!): Canonicalize insn semantics before processing
	them.
	* mode.scm (/mode-set-word-params!): New function.
	(mode-void?): New function.
	(mode-compatible?): VOID is compatible with VOID.
	(/mode-word-sizes-defined?): New global.
	(mode-set-word-modes!): Use/set it.
	(mode-ensure-word-sizes-defined): Update.
	(mode-builtin!): New builtin "modes" SYM, INSN, MACH.
	Redo WI/UWI/AI/IAI handling.
	(op:new-mode): No longer accept DFLT.
	(<derived-operand> constructor): Ensure all fields are initialized.
	(<anyof-operand> constructor): Ditto.
	(/derived-parse-ifield-assertion): Delete arg `args'.
	All callers updated.
	* rtl-c.scm (<rtl-c-eval-state>): New member `for-insn?'.
	(rtl-c): Call rtx-canonicalize instead of rtx-compile.
	(rtl-c-expr, rtl-c++): Ditto.
	(/rtl-c-get): Use mode of operand, not containing expression.
	(rtl-c-set-quiet, rtl-c-set-trace): Remove DFLT support.
	(/rtx-use-sem-fn?): Don't check for (insn? owner), check
	estate-for-insn? instead.
	(s-unop): Use mode of expression, not first operand.
	(s-binop, s-binop-with-bit, s-shop, s-cmpop): Ditto.
	(s-sequence): Remove DFLT support.
	(ifield): Use mode of expression, not UINT.
	(pc): Comment out, unused.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	(set, set-quiet): Pass src to rtl-c-set-{trace,quiet} for expansion.
	* rtl-traverse.scm (/rtx-canon-debug?): New global.
	(/make-cstate): New function.
	(/cstate-context, /cstate-outer-expr): New functions.
	(/rtx-canon-error): New function.
	(/rtx-lookup-hw, /rtx-pick-mode, /rtx-pick-mode3, /rtx-pick-op-mode,
	/rtx-get-last-cond-case-rtx): New functions.
	(/rtx-canon-*): New functions.
	(/rtx-canner-table, /rtx-operand-canoners): New globals.
	(/rtx-make-canon-table, /rtx-special-expr-canoners): New functions.
	(/rtx-option, /rtx-option-list?): Rewrite.
	(rtx-munge-mode&options): Replaces /rtx-munge-mode&options.
	Rewritten, all callers updated.
	(/rtx-canon-expr, /rtx-canon): New functions.
	(rtx-canonicalize): Move here from rtl-xform.scm and rewrite.
	(rtx-canonicalize-stmt): New function.
	(tstate-make): Remove arg `set?'.  All callers updated.
	(tstate-new-set?): Delete.
	(/rtx-traverse-options, /rtx-traverse-*mode): Delete,
	moved to /rtx-canon-*.
	(/rtx-traverse-normal-operand): New function.
	(/rtx-traverse-rtx-list): Delete arg `mode', all callers updated.
	(/rtx-traverse-rtx, /rtx-traverse-setrtx,, /rtx-traverse-testrtx,
	/rtx-traverse-condrtx, /rtx-traverse-casertx, /rtx-traverse-locals,
	/rtx-traverse-iteration, /rtx-traverse-env, /rtx-traverse-attrs):
	Ditto.
	(/rtx-traverse-symbol, /rtx-traverse-string, /rtx-traverse-number,
	/rtx-traverse-symornum, /rtx-traverse-object): Delete.
	(/rtx-make-traverser-table): Update.
	(/rtx-traverse-operands): Remove mode processing, now done during
	canonicalization.
	(/rtx-traverse-expr): Delete arg `mode', all callers updated.
	(/rtx-traverse): Ditto.
	(rtx-init-traverser-tables!): New function.
	* rtl-xform (/rtx-verify-no-dflt-modes-expr-fn): New function.
	(rtx-verify-no-dflt-modes): New function.
	(/rtx-simplify-expr-fn): Update, `arg' mode deleted.
	(rtx-simplify-insn): Use insn-canonical-semantics.
	(rtx-canonicalize): Moved to rtl-traverse.scm.
	(/compile-expr-fn, rtx-compile): Delete.
	(/rtx-trim-rtx-list): New function.
	(/rtx-trim-for-doc): Handle set, if.
	* rtl.scm (<rtx-func>): New members result-mode, matchexpr-index.
	(/rtx-valid-mode-types): Update.
	(/rtx-valid-matches): Update.
	(/rtx-find-matchexpr-index): New function.
	(rtx-lookup): Require rtx-kind to be the rtx name.
	(def-rtx-node): New arg result-mode, all callers updated.
	(def-rtx-syntax-node, def-rtx-operand-node): Ditto.
	(rtx-lazy-sem-mode): Delete.
	(/rtx-closure-make): New arg `mode', all callers updated.
	(rtx-make-ifield, rtx-make-operand, rtx-make-local): Ditto.
	(rtx-operand-obj): Rewrite.
	(rtx-make-xop): New functions.
	(/hw): Renamed from `hw', all callers updated.
	Use the correct mode instead of DFLT for the index.
	(rtl-builtin!): Call rtx-init-traversal-tables!.
	(rtl-finish!): Update.
	* rtx-funcs.scm (all rtx functions): New parameter: result-mode.
	Update mode arg-type.
	(pc): Comment out.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	* sem-frags.scm (/frag-hash-compute!): Update, mode arg deleted.
	(/frag-cost-compute!): Ditto.
	* semantics.scm (/build-operand!): Delete args op-name, op.
	New arg op-expr.  All callers updated.
	(/build-mem-operand!): Remove DFLT support.
	(semantic-compile): Update process-expr!, mode arg deleted.
	* sid-cpu.scm (gen-semantic-code): Specify #:for-insn? in
	rtl-c++ calls.
	(/gen-sem-case, /gen-sfrag-code): Ditto.
	* sid.scm (/op-gen-set-trace1): Renamed from /op-gen-set-trace.
	(/op-gen-set-trace): New function.  If not doing profiling,
	call /op-gen-set-quiet.
	* sim-cpu.scm (gen-semantic-code): Specify #:for-insn? in rtl-c calls.
	* utils-gen.scm (/gen-ifld-extract-base): Update call to rtl-c.
	(/gen-ifld-extract-beyond, gen-multi-ifld-extract): Ditto.
	* utils.scm (find-first-index): New function.
	* doc/rtl.texi: Delete docs for `attr'.  Add `int-attr'.
@
text
@d244 1
a244 1
; gen-sym-decl - generate decl using the provided symbol
d256 1
a256 1
 <scalar> 'gen-sym-decl
d274 1
a274 1
 <array> 'gen-sym-decl
d313 1
a313 1
;(method-make! <integer> 'gen-sym-decl (lambda (self sym comment) ""))
d323 3
a325 1
; gen-decl
a331 2
; gen-type      - C type to use to record value.
;                 ??? Delete and just use get-mode?
a337 1
; gen-sym-decl  - Return a C declaration using the provided symbol.
d342 1
a342 1
; Generate CPU state struct entries.
d345 2
a346 3
 <hardware-base> 'gen-decl
 (lambda (self)
   (send self 'gen-sym-decl (obj:name self) (obj:comment self)))
d349 6
a354 1
(method-make-virtual! <hardware-base> 'gen-sym-decl (lambda (self sym comment) ""))
a367 7
; gen-type handler, must be overridden

(method-make-virtual!
 <hardware-base> 'gen-type
 (lambda (self) (error "gen-type not overridden:" self))
)

d458 8
a465 2
; Forward these methods onto TYPE.
(method-make-virtual-forward! <hw-register> 'type '(gen-type gen-sym-decl))
d681 2
a682 2
(method-make-virtual-forward! <hw-memory> 'type '(gen-type))
(method-make-virtual! <hw-memory> 'gen-sym-decl (lambda (self sym comment) ""))
d711 8
a718 2
; Forward these methods onto TYPE.
(method-make-virtual-forward! <hw-immediate> 'type '(gen-type gen-sym-decl))
d728 3
a730 3
; FIXME.
(method-make-virtual! <hw-address> 'gen-type (lambda (self) "ADDR"))
(method-make-virtual! <hw-address> 'gen-sym-decl (lambda (self sym comment) ""))
d756 2
a757 2
; FIXME: revisit.
(method-make-virtual! <hw-iaddress> 'gen-type (lambda (self) "IADDR"))
@


1.23
log
@	* insn.scm (/parse-insn-format): New arg `verify?', all callers updated.
	(/insn-parse): Don't verify iformat for virtual insns.

	* sid-decode.scm (cgen-decode.cxx): Remove redundant call to
	non-multi-insns.
	* sid-model.scm (/gen-model-insn-fn-decls): Ditto.
	(/gen-model-insn-fns, /gen-model-class-decls): Ditto.
	* sid.scm (pbb-engine-insns): Ditto.
	* sim-decode.scm (cgen-decode.c): Ditto.
@
text
@d643 1
a643 1
   (let ((mode (if (mode:eq? 'DFLT mode)
d1024 1
a1024 1
(define (/op-gen-set-trace op estate mode index selector newval)
d1086 12
@


1.22
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d1646 1
a1646 1
  (non-multi-insns (real-insns (current-insn-list)))
@


1.21
log
@	Clean up cpu file parsing, pass context consistently instead of the
	old "errtxt" argument.
	NOTE: ACU == "All Callers Updated".
	* attr.scm (-parse-simple-attribute): Renamed from
	parse-simple-attribute, ACU.
	(-attr-parse): Change errtxt argument to context, ACU.
	(-attr-read): Ditto.
	(atlist-parse): Ditto.  Put context arg first.
	(attr-parse): Use parse-error instead of context-error.
	* enum.scm (parse-enum-vals): Change errtxt argument to context, ACU.
	(-enum-parse-prefix, -enum-parse, -enum-read): Ditto.
	* hardware.scm (-keyword-parse): Renamed from keyword-parse.
	`context' arg is now a <context> object.  ACU.
	(-keyword-read): `context' arg is now a <context> object.  ACU.
	(-hw-parse-indices): Change errtxt argument to context, ACU.
	(-hw-parse-values, -hw-parse-handlers): Ditto.
	(-hw-parse-getter, -hw-parse-setter, -hw-parse, -hw-read): Ditto.
	(-hw-validate-layout, -hw-create-getter-from-layout,
	-hw-create-setter-from-layout): Ditto.
	(<hw-register>:parse!, <hw-pc>:parse!): Ditto.
	(<hw-memory>:parse!, <hw-immediate>:parse!): Ditto.
	(<hw-address>:parse!): Ditto.
	* ifield.scm (-ifield-parse, ifield-read): Ditto.
	(-ifld-parse-follows, -ifld-parse-encode-decode): Ditto.
	(-ifld-parse-encode, -ifld-parse-decode): Ditto.
	(-multi-ifield-parse, -multi-ifield-read): Ditto.
	* insn.scm (-insn-parse, -insn-read): Ditto.
	(parse-syntax): Ditto.  Put context arg first.
	(-parse-insn-format-symbol): Change errtxt argument to context, ACU.
	(-parse-insn-format-ifield-spec, -parse-insn-format-list): Ditto.
	(-parse-insn-format): Ditto.
	* mach.scm (-arch-parse-alignment, -arch-parse-machs): Ditto.
	(-arch-parse-isas): Ditto.
	(-isa-read): Add context arg, ACU.
	(-cpu-parse, -cpu-read, -mach-read): Ditto.
	* minsn.scm (-minsn-parse-expansion): Change errtxt argument to
	context, ACU.
	(-minsn-parse, -minsn-read, -minsn-compute-iflds): Ditto.
	(minsn-make-alias): Ditto.
	* mode.scm (-mode-parse): Ditto.
	(parse-mode-name): Ditto.  Put context arg first.
	* model.scm (-prefetch-parse, -retire-parse, -pipeline-parse): Change
	errtxt argument to context, ACU.
	(-unit-parse, -model-parse, -model-read): Ditto.
	* operand.scm (-operand-parse-getter): Use parse-error instead of
	context-error.
	(-operand-parse-setter): Ditto.
	(-operand-parse): Change errtxt argument to context, ACU.
	(-operand-read, -derived-operand-parse, -derived-operand-read): Ditto.
	(-anyof-operand-parse, -anyof-operand-read): Ditto.
	* read.scm (reader-error): Delete.  Use parse-error instead.
	(parse-error): Change errtxt argument to context, ACU.  Split args
	argument into expr and maybe-help-text.
	(-reader-process-expanded-1!): Reorganize.
	* rtl.scm (-subr-read): Change errtxt argument to context, ACU.
	* types.scm (parse-type): Ditto.
	* utils-cgen.scm (single-location->simple-string): New function.
	(<context>): Replace members file,lineno with location.
	(make-prefix-context): Renamed from context-make-prefix, ACU.
	(make-current-context): New function.
	(context-append, context-append-name): New functions.
	(context-make-reader): Delete.
	(parse-name): Change errtxt argument to context, ACU.
	Put context arg first.
	(parse-comment): Ditto.
	(parse-number): Change errtxt argument to context, ACU.
	(arg-list-validate-name, arg-list-check-no-args,
	arg-list-symbol-arg): Ditto.

	* read.scm (-cmd-if): Don't assume test is a list.

	* html.scm (get-insn-properties): Delete errtxt, unused.
@
text
@d36 2
a37 2
(define -with-scache? #f)
(define (with-scache?) -with-scache?)
d41 7
a47 7
; The options as passed are stored in -with-profile-{fn,sw}?, and
; -with-profile? is set at code generation time.
(define -with-profile-fn? #f)
(define -with-profile-sw? #f)
(define -with-profile? #f)
(define (with-profile?) -with-profile?)
(define (with-any-profile?) (or -with-profile-fn? -with-profile-sw?))
d50 2
a51 2
(define -with-multiple-isa? #f)
(define (with-multiple-isa?) -with-multiple-isa?)
d54 2
a55 2
(define -with-pbb? #f)
(define (with-pbb?) -with-pbb?)
d59 2
a60 2
(define -with-sem-frags? #f)
(define (with-sem-frags?) -with-sem-frags?)
d71 6
a76 6
  (set! -with-scache? #f)
  (set! -with-pbb? #f)
  (set! -with-sem-frags? #f)
  (set! -with-profile-fn? #f)
  (set! -with-profile-sw? #f)
  (set! -with-multiple-isa? #f)
d86 3
a88 3
    ((with-scache) (set! -with-scache? #t))
    ((with-pbb) (set! -with-pbb? #t))
    ((with-sem-frags) (set! -with-sem-frags? #t))
d90 1
a90 1
			   (set! -with-profile-fn? #t))
d92 1
a92 1
			   (set! -with-profile-sw? #t))
d94 1
a94 1
    ((with-multiple-isa) (set! -with-multiple-isa? #t))
d111 3
a113 3
(define -current-pbb-engine? #f)
(define (current-pbb-engine?) -current-pbb-engine?)
(define (set-current-pbb-engine?! flag) (set! -current-pbb-engine? flag))
d121 3
a123 3
(define -with-parallel? #f)
(define (with-parallel?) -with-parallel?)
(define (set-with-parallel?! flag) (set! -with-parallel? flag))
d131 1
a131 1
(define -with-parallel-kind 'write)
d134 1
a134 1
  (and -with-parallel? (eq? -with-parallel-kind 'read))
d138 1
a138 1
  (and -with-parallel? (eq? -with-parallel-kind 'write))
d231 1
a231 1
(define (-cxmake-ifld-val mode f)
d295 1
a295 1
				      (-gen-hw-index idx estate)
d393 1
a393 1
   (-cxmake-ifld-val mode (hw-index:value index)))
d406 1
a406 1
(define (-hw-gen-set-quiet-pc self estate mode index selector newval . options)
d409 1
a409 1
	 (-hw-gen-set-quiet self estate mode index selector newval))
d426 1
a426 1
(method-make! <hw-pc> 'gen-set-quiet -hw-gen-set-quiet-pc)
d515 1
a515 1
   (-gen-hw-index-raw index estate)
d522 1
a522 1
(define (-hw-gen-fun-get reg estate mode index)
d524 1
a524 1
	(c-index (-gen-hw-index index estate)))
d532 1
a532 1
(define (-hw-gen-fun-set reg estate mode index newval)
d534 1
a534 1
	(c-index (-gen-hw-index index estate)))
d545 1
a545 1
(define (-hw-cxmake-get hw estate mode index selector)
d554 1
a554 1
		    (-hw-gen-fun-get hw estate mode index))
d567 1
a567 1
(method-make! <hw-register> 'cxmake-get -hw-cxmake-get)
d585 1
a585 1
(define (-hw-gen-set-quiet hw estate mode index selector newval)
d588 1
a588 1
	 (-hw-gen-fun-set hw estate mode index newval))
d602 1
a602 1
(method-make! <hw-register> 'gen-set-quiet -hw-gen-set-quiet)
d652 1
a652 1
			     (-gen-hw-index index estate)
d656 1
a656 1
						(-gen-hw-selector selector)))
d671 1
a671 1
		    (-gen-hw-index index estate)
d675 1
a675 1
				       (-gen-hw-selector selector)))
d787 1
a787 1
		   (string-append access-macro " (" (-op-index-name op) ")"))
d794 1
a794 1
(define (-op-index-name op)
d803 1
a803 1
(define (-gen-hw-index-raw index estate)
d823 1
a823 1
      (else (error "-gen-hw-index-raw: invalid index:" index))))
d826 1
a826 1
; Same as -gen-hw-index-raw except used where speedups are possible.
d829 1
a829 1
(define (-gen-hw-index index estate)
d842 1
a842 1
		    (cx:c (-cxmake-ifld-val mode value))))
d845 1
a845 1
      (else (error "-gen-hw-index: invalid index:" index))))
d863 1
a863 1
	      (-gen-hw-index self estate))))
d870 1
a870 1
(define (-gen-hw-selector sel)
d977 1
a977 1
	  (idx (if index (-gen-hw-index index estate) ""))
d1016 1
a1016 1
(define (-op-gen-set-quiet op estate mode index selector newval)
d1020 2
a1021 2
(define (-op-gen-delayed-set-quiet op estate mode index selector newval)
  (-op-gen-delayed-set-maybe-trace op estate mode index selector newval #f))
d1024 1
a1024 1
(define (-op-gen-set-trace op estate mode index selector newval)
d1053 1
a1053 1
	     (-gen-hw-index index estate)
d1086 2
a1087 2
(define (-op-gen-delayed-set-trace op estate mode index selector newval)
  (-op-gen-delayed-set-maybe-trace op estate mode index selector newval #t))
d1089 1
a1089 1
(define (-op-gen-delayed-set-maybe-trace op estate mode index selector newval do-trace?)
d1099 1
a1099 1
	 (idx (if index (-gen-hw-index index estate) ""))
d1120 1
a1120 1
	 (error "-op-gen-delayed-set-maybe-trace called on non-delayed operand"))       
d1142 1
a1142 1
	(-gen-hw-index index estate)
d1179 1
a1179 1
	    (-op-gen-delayed-set-quiet self estate mode index selector newval))
d1181 1
a1181 1
	    (-op-gen-set-quiet self estate mode index selector newval)))))
d1202 1
a1202 1
	    (-op-gen-delayed-set-trace self estate mode index selector newval))
d1204 1
a1204 1
	    (-op-gen-set-trace self estate mode index selector newval)))))
d1310 1
a1310 1
(define (-gen-mach-decls)
d1323 1
a1323 1
(define (-gen-mach-data)
d1341 1
a1341 1
(define (-gen-arch-model-decls)
d1649 1
a1649 1
;; Subroutine of -create-virtual-insns!.
d1656 1
a1656 1
(define (-virtual-insn-add! ordinal insn)
d1664 1
a1664 1
(define (-create-virtual-insns! isa)
d1667 1
a1667 1
	;; Record as a pair so -virtual-insn-add! can update it.
d1670 1
a1670 1
    (-virtual-insn-add!
d1688 1
a1688 1
	  (-virtual-insn-add!
d1702 1
a1702 1
	  (-virtual-insn-add!
d1721 1
a1721 1
	  (-virtual-insn-add!
d1740 1
a1740 1
	  (-virtual-insn-add!
d1754 1
a1754 1
	  (-virtual-insn-add!
d1774 1
a1774 1
	(-virtual-insn-add!
d1801 1
a1801 1
(define (-decode-split-insn? insn isa)
d1815 1
a1815 1
; Subroutine of -decode-split-insn-1.
d1819 1
a1819 1
(define (-decode-split-build-assertion f-name value)
d1826 1
a1826 1
; Subroutine of -decode-split-insn.
d1829 1
a1829 1
(define (-decode-split-insn-1 insn dspec)
d1841 1
a1841 1
			 (-decode-split-build-assertion f-name (cadr value))))
d1855 1
a1855 1
(define (-decode-split-insn insn isa)
d1865 1
a1865 1
		     (-decode-split-insn-1 insn (car splits))
d1868 1
a1868 1
				   (-decode-split-insn-1 insn (car splits)))
d1878 1
a1878 1
(define (-fill-sim-insn-list!)
d1888 1
a1888 1
			       (-decode-split-insn? insn isa))
d1901 1
a1901 1
				      (-decode-split-insn insn isa))
d1913 1
a1913 1
(define -sim-insns-analyzed? #f)
d1916 2
a1917 2
(define -sim-sformat-argbuf-list #f)
(define (current-sbuf-list) -sim-sformat-argbuf-list)
d1922 2
a1923 2
  (set! -sim-insns-analyzed? #f)
  (set! -sim-sformat-argbuf-list #f)
d1950 1
a1950 1
      (-create-virtual-insns! (current-isa)))
d1973 1
a1973 1
  (if (not -sim-insns-analyzed?)
d1976 1
a1976 1
	(-fill-sim-insn-list!)
d1983 1
a1983 1
	(set! -sim-sformat-argbuf-list
d1986 1
a1986 1
	(set! -sim-insns-analyzed? #t)
@


1.20
log
@	Use hash tables to record ifields, operands, insns, macro-insns.
	* attr.scm (attr-builtin!): Tweak some comments.
	* hardware.scm (hardware-builtin!): Call all-isas-attr-value.
	* ifield.scm (<ifield>): Subclass from <ordered-ident> instead of
	<ident>.
	(<multi-ifield>): New constructor.
	(ifield-builtin!): Add isa attr to f-nil, f-anyof.
	* insn.scm (<insn>): Subclass from <ordered-ident> instead of
	<ident>.
	(-sub-insn-make!): Add hack to avoid differences in generated code.
	(multi-insn-instantiate!): Add total number of multi-insns to
	logging message.
	* mach.scm (<arch>): Rename members ifld-list, op-list, insn-list,
	minsn-list to foo-table.  New member next-ordinal.
	Update getters/setters.
	(arch-ifld-list, arch-op-list, arch-insn-list, arch-minsn-list):
	New functions.
	(-get-next-ordinal!, -get-lowest-ordinal): New function.
	(-make-ident-object-table, -ident-object-table->list,
	-ident-object-table-add!, -ident-object-table-lookup): New functions.
	(current-ifld-list, current-ifld-add! current-ifld-lookup,
	-ifld-already-defined?): Rewrite.
	(current-op-list, current-op-add! current-op-lookup,
	-op-already-defined?): Rewrite.
	(current-raw-insn-list, insn-list-car, insn-list-splice!): Delete.
	(current-insn-list, current-insn-add! current-insn-lookup,
	-insn-already-defined?): Rewrite.
	(current-minsn-list, current-minsn-add! current-minsn-lookup,
	-minsn-already-defined?): Rewrite.
	(all-isas-attr-value, all-isas-attr, attr-isa-list): New functions.
	(MAX-VIRTUAL-INSNS): Define.
	(arch-analyze-insns!): Add hack to avoid differences in generated code.
	Update use of arch-insn-list.
	(mach-init!): Initialize ifld-table, op-table, insn-table, minsn-table.
	(arch-finish!): Delete references to ifld-table, op-table, insn-table,
	minsn-table.
	* minsn.scm (<macro-insn>): Subclass from <ordered-ident> instead of
	<ident>.  New constructor.
	* operand.scm (<operand>): Subclass from <ordered-ident> instead of
	<ident>.
	* sid.scm (-virtual-insn-add!): New function.
	(-create-virtual-insns!): Call it.
	(-fill-sim-insn-list!): Rewrite.
	* sim.scm (-virtual-insn-add!, -create-virtual-insns!): New functions.
	(sim-finish!): Move contents to -create-virtual-insns!, and call it.
	* utils-cgen.scm (<ordered-ident>): New class.
	(obj-ordinal, obj-set-ordinal!): New functions.
	(add-ident-methods!): Delete.

	* model.scm (parse-insn-timing): Change logging message to level 3.
@
text
@d1544 1
a1544 1
		       (parse-error "insn function unit spec"
d1666 1
a1666 1
	(context "virtual insns")
@


1.19
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d1649 13
d1666 3
a1668 1
	(context "virtual insns"))
d1670 2
a1671 1
    (current-insn-add!
d1688 2
a1689 1
	  (current-insn-add!
d1702 2
a1703 1
	  (current-insn-add!
d1721 2
a1722 1
	  (current-insn-add!
d1740 2
a1741 1
	  (current-insn-add!
d1754 2
a1755 1
	  (current-insn-add!
d1774 2
a1775 1
	(current-insn-add!
d1885 19
a1903 22
	  ; FIXME: We shouldn't need to know the innards of how insn lists
	  ; are recorded.
	  (let loop ((insns (current-raw-insn-list)))
	    (if (null? insns)
		#f ; done
		(let ((insn (insn-list-car insns)))
		  (if (and (insn-real? insn)
			   (insn-semantics insn)
			   (-decode-split-insn? insn isa))
		      (begin
			(for-each (lambda (new-insn)
				    ; Splice new insns next to original.
				    ; Keeps things tidy and generated code
				    ; easier to read for human viewer.
				    (let ((new-list (insn-list-splice! insns new-insn)))
				      ; Assign insns separately.  Paranoia,
				      ; insn-list-splice! modifies the list.
				      (set! insns new-list))
				    )
				  (-decode-split-insn insn isa))
			(obj-cons-attr! insn (bool-attr-make 'ALIAS #t))))
		  (loop (cdr insns)))))
@


1.18
log
@2006-07-14  Dave Brolley  <brolley@@redhat.com>

        * sid.scm (-op-gen-delayed-set-maybe-trace): If delay used, note the
        hardware or memory mode which was used.
        * sid-cpu.scm (hw-need-write-stack?): New function.
        (-gen-hw-stream-and-destream-fns): Compute stack-regs. Use it to
        identify hardware which uses write stacks.
        (useful-mode-names): Renamed to write-stack-memory-mode-names.
        Initialized to an empty list.
        (-gen-writestacks, -gen-reset-fn, -gen-unified-write-fn): Use
        hw-need-write-stack?.
        * hardware.scm (used-in-delay-rtl?): New member of <hardware-base>.
        (define-getters <hardware-base>): Define used-in-delay-rtl?.
        (used-in-delay-rtl?): New method of <hardware-base>.
        (hw-used-in-delay-rtl?): New function.
@
text
@d2 1
a2 1
; Copyright (C) 2000-2005 Red Hat, Inc.
@


1.18.4.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2005, 2009 Red Hat, Inc.
@


1.17
log
@2006-06-20  Dave Brolley  <brolley@@redhat.com>

        * sid.scm (gen-attr-type): Removed.
@
text
@d1103 5
@


1.16
log
@2005-10-28  Dave Brolley  <brolley@@redhat.com>

        Contribute the following changes:
        2005-09-19  Dave Brolley  <brolley@@redhat.com>

        * attr.scm (gen-value-for-defn-raw): New methods.
        (gen-value-for-defn): Don't test for 'SID-SIMULATOR. Call
        gen-value-for-defn-raw.
        * sid.scm (gen-obj-attr-sid-defn): Call gen-value-for-defn-raw.

        2002-12-13  Dave Brolley  <brolley@@redhat.com>

        * utils-cgen.scm (gen-attr-type): Moved from sid.scm.
        (-gen-attr-accessors): New function.
        (gen-obj-attr-defn): Update terminating initializer.
        (gen-obj-attr-end-defn): New function.
        * sid.scm (gen-attr-type): Moved to utils-cgen.scm.
        * sid-cpu.scm (cgen-desc.h): Generate code to include
        "opcode/cgen-bitset.h"
        * intrinsics.scm (kept-insn-isas): Correct the extraction of the isa
        name.
        * desc.scm ('gen-defn): Update terminating initializer.
        * desc-cpu.scm (gen-ifld-decls): Call -gen-attr-accessors. Update
        terminatinig initializer.
        (gen-hw-decls): Ditto.
        (gen-operand-decls): Ditto.
        (gen-insn-decls): Ditto.
        (-gen-hash-defines): Generate code to include "opcde/cgen-bitset.h"
        (gen-insn-table): Update terminating initializer.
        (-gen-cpu-open): Update generation of @@arch@@_cgen_rebuild_tables,
        @@arch@@_cgen_cpu_open, @@arch@@_cgen_cpu_close.
        * attr.scm (charmask-bytes): New function.
        (bitset-attr->charmask): New function.
        (<bitset-attribute>): Handle isa-attributes specially. Also handle
        differences for SID-SIMULATOR.
        (<integer-attribute>): Handle differences for SID-SIMULATOR.
        (<enum-attribute>): Ditto.
@
text
@a172 11
; Return the C++ type to use to hold a value for attribute ATTR.

(define (gen-attr-type attr)
  (case (attr-kind attr)
    ((boolean) "int")
    ((bitset)  "unsigned int")
    ((integer) "int")
    ((enum)    (string-append "enum " (string-downcase (gen-sym attr)) "_attr"))
    )
)

@


1.15
log
@2005-06-15  Dave Brolley  <brolley@@redhat.com>

        * sid-cpu.scm (-gen-hw-stream-and-destream-fns): New function.
        (cgen-cpu.h): Call it.

        Contributed on behalf of Graydon Hoare
        2001-06-05  graydon hoare  <graydon@@redhat.com>

        * utils.scm (foldl): Define.
        (foldr): Define.
        (filter): Define.
        (union): Define.
        (intersection): Simplify.
        * sid.scm : Set APPLICATION to SID-SIMULATOR.
        (-op-gen-delayed-set-maybe-trace): Define.
        (<operand> 'gen-set-{quiet,trace}): Delegate to
        op-gen-delayed-set-quiet etc. Note: this is still a little tangled
        up and needs cleaning.
        (-with-parallel?): Hardwire with-parallel to #t.
        (<operand> 'cxmake-get): Replace with lookahead-aware code
        * sid-decode.scm: Remove per-insn writeback fns.
        (-gen-idesc-decls): Redefine sem_fn type.
        * sid-cpu.scm (gen-write-stack-structure): Replace parexec stuff
        with write stack stuff.
        (cgen-write.cxx): Replace per-insn writebacks with single write
        stack writeback. Add write stack reset function.
        (-gen-scache-semantic-fn insn): Replace parexec stuff with write
        stack stuff.
        * rtl-c.scm (xop): Clone operand into delayed operand if #:delayed
        estate attribute set.
        (delay): Set #:delayed attribute to calculated delay, update
        maximum delay of cpu, check (delay ...) usage.
        * operand.scm (<operand>): Add delayed slot to <operand>.
        * mach.scm (<cpu>): Add max-delay slot to <cpu>.
        * dev.scm (load-sid): Set APPLICATION to SID-SIMULATOR.
        * doc/rtl.texi (Expressions): Add section on (delay ...).
@
text
@d233 1
a233 1
					 (send attr 'gen-value-for-defn val))))
@


1.14
log
@* sid.scm (gen-ifetch): Require BITSIZE to be exactly the size
fetched by one of our GETIMEM* methods.
* utils-gen.scm (-extract-chunk-specs): Always fetch full
base-insn-sized chunks.
@
text
@a933 37
; For parallel write post-processing, we don't want to defer setting the pc.
; ??? Not sure anymore.
;(method-make!
; <pc> 'gen-set-quiet
; (lambda (self estate mode index selector newval)
;   (-op-gen-set-quiet self estate mode index selector newval)))
;(method-make!
; <pc> 'gen-set-trace
; (lambda (self estate mode index selector newval)
;   (-op-gen-set-trace self estate mode index selector newval)))

; Name of C macro to access parallel execution operand support.

(define -par-operand-macro "OPRND")

; Return C code to fetch an operand's value and save it away for the
; semantic handler.  This is used to handle parallel execution of several
; instructions where all inputs of all insns are read before any outputs are
; written.
; For operands, the word `read' is only used in this context.

(define (op:read op sfmt)
  (let ((estate (estate-make-for-normal-rtl-c++ nil nil)))
    (send op 'gen-read estate sfmt -par-operand-macro))
)

; Return C code to write an operand's value.
; This is used to handle parallel execution of several instructions where all
; outputs are written to temporary spots first, and then a final
; post-processing pass is run to update cpu state.
; For operands, the word `write' is only used in this context.

(define (op:write op sfmt)
  (let ((estate (estate-make-for-normal-rtl-c++ nil nil)))
    (send op 'gen-write estate sfmt -par-operand-macro))
)

d983 28
a1010 7
   (let ((mode (if (mode:eq? 'DFLT mode)
		   (send self 'get-mode)
		   mode))
	 (index (if index index (op:index self)))
	 (selector (if selector selector (op:selector self))))
     ; If the object is marked with the RAW attribute, access the hardware
     ; object directly.
d1013 9
a1021 21
     (cond ((obj-has-attr? self 'RAW)
	    (send (op:type self) 'cxmake-get-raw estate mode index selector))
	   ; If the instruction could be parallely executed with others and
	   ; we're doing read pre-processing, the operand has already been
	   ; fetched, we just have to grab the cached value.
	   ((with-parallel-read?)
	    (cx:make-with-atlist mode
				 (string-append -par-operand-macro
						" (" (gen-sym self) ")")
				 nil)) ; FIXME: want CACHED attr if present
	   ((op:getter self)
	    (let ((args (car (op:getter self)))
		  (expr (cadr (op:getter self))))
	      (rtl-c-expr mode expr
			  (if (= (length args) 0)
			      nil
			      (list (list (car args) 'UINT index)))
			  #:rtl-cover-fns? #t
			  #:output-language (estate-output-language estate))))
	   (else
	    (send (op:type self) 'cxmake-get estate mode index selector)))))
d1031 3
a1033 10
(define (-op-gen-set-quiet-parallel op estate mode index selector newval)
  (string-append
   (if (op-save-index? op)
       (string-append "    " -par-operand-macro " (" (-op-index-name op) ")"
		      " = " (-gen-hw-index index estate) ";\n")
       "")
   "    "
   -par-operand-macro " (" (gen-sym op) ")"
   " = " (cx:c newval) ";\n")
)
d1097 35
a1131 9
(define (-op-gen-set-trace-parallel op estate mode index selector newval)
  (string-append
   "  {\n"
   "    " (mode:c-type mode) " opval = " (cx:c newval) ";\n"
   (if (op:cond? op)
       (string-append "    written |= (1ULL << "
		      (number->string (op:num op))
		      ");\n")
       "")
a1162 6
   (if (op-save-index? op)
       (string-append "    " -par-operand-macro " (" (-op-index-name op) ")"
		      " = " (-gen-hw-index index estate) ";\n")
       "")
   "    " -par-operand-macro " (" (gen-sym op) ")"
   " = opval;\n"
d1164 2
a1165 2
)

d1184 2
a1185 2
	   ((with-parallel-write?)
	    (-op-gen-set-quiet-parallel self estate mode index selector newval))
d1207 2
a1208 2
	   ((with-parallel-write?)
	    (-op-gen-set-trace-parallel self estate mode index selector newval))
a1212 14
; Define and undefine C macros to tuck away details of instruction format used
; in the parallel execution functions.  See gen-define-field-macro for a
; similar thing done for extraction/semantic functions.

(define (gen-define-parallel-operand-macro sfmt)
  (string-append "#define " -par-operand-macro "(f) "
		 "par_exec->operands."
		 (gen-sym sfmt)
		 ".f\n")
)

(define (gen-undef-parallel-operand-macro sfmt)
  (string-append "#undef " -par-operand-macro "\n")
)
@


1.13
log
@2005-02-16  Dave Brolley  <brolley@@redhat.com>

        * utils.scm: Update copyright years.
        * utils-gen.scm (gen-ifld-extract): Pass base-length to -gen-ifld-extrac
t-base.
        * sid.scm (gen-ifetch): Handle the case where bitsize == 24.
@
text
@d187 7
a200 1
		   ((24) "USI")
@


1.12
log
@2004-03-22  Dave Brolley  <brolley@@redhat.com>

        * utils.scm (copyright-fsf): Update copyright years.
        (copyright-red-hat): Ditto.
        * sid.scm (-op-gen-set-trace): Generate trace code before semantic
        code.
        (-op-gen-set-trace-parallel): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000-2004 Red Hat, Inc.
d194 1
@


1.11
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2002, 2003 Red Hat, Inc.
a1066 15
   ; Dispatch to setter code if appropriate
   "    "
   (if (op:setter op)
       (let ((args (car (op:setter op)))
	     (expr (cadr (op:setter op))))
	 (rtl-c 'VOID expr
		(if (= (length args) 0)
		    (list (list 'newval mode "opval"))
		    (list (list (car args) 'UINT index)
			  (list 'newval mode "opval")))
		#:rtl-cover-fns? #t
		#:output-language (estate-output-language estate)))
       ;else
       (send (op:type op) 'gen-set-quiet estate mode index selector
		(cx:make-with-atlist mode "opval" (cx:atlist newval))))
d1107 15
a1128 6
   (if (op-save-index? op)
       (string-append "    " -par-operand-macro " (" (-op-index-name op) ")"
		      " = " (-gen-hw-index index estate) ";\n")
       "")
   "    " -par-operand-macro " (" (gen-sym op) ")"
   " = opval;\n"
d1165 6
@


1.10
log
@	* Makefile.am (srcroot): New var.
	(html): New rule.
	* Makefile.in: Regenerate.
	* cgen-doc.scm: New file.
	* html.scm: New file.
	* gen-all-doc: New file.
	* dev.scm (cload): Handle DOC application.
	(load-doc): New fn.
	* machs.scm (machs-for-cpu): New fn.
	* model.scm (models-for-cpu): New fn.
	* utils.scm (gen-c-copyright): Renamed from gen-copyright.
	All uses updated.
	(iota): Rewrite to be identical to pmacro version.  All uses updated.
	* utils-cgen.scm (alpha-sort-obj-list): New fn.
@
text
@d652 1
a652 1
	      (string-append "current_cpu->GETMEM" (obj:name mode)
d671 1
a671 1
     (string-append "current_cpu->SETMEM" (obj:name mode)
d1621 1
a1621 1
		 (string-append "  \"" (string-upcase (obj:name m)) "\",\n"))
d1949 3
a1951 1
  (let ((sim-file (string-append srcdir "/cpu/" (current-arch-name) ".sim")))
@


1.9
log
@2003-04-16  Dave Brolley  <brolley@@redhat.com>

        * doc/rtl.texi (Iiming): Correct example to use 'model-name'.
        * utils.scm (copyright-fsf): Update generate copyright years.
        (copyright-cygnus): Ditto.
        * sid.scm (-op-gen-set-trace): Generate code to fill in bitmask of modified
        operands.
        (-gen-arch-model-decls): Don't generate unit enum declaration or MAX_UNITS
        here.
        (<operand>'gen-profile-code): New parameter 'when'.
        (<iunit>'gen-profile-code): Ditto.
        (<insn>'gen-profile-code): Ditto.
        (<unit>'gen-profile-code): Ditto. Only generate 'referenced' and
        'insn_reference' for the 'after' function.
        * model.scm (unit:enum): Moved to sim-model.scm.
        * sim-model.scm (unit:enum): Moved from model.scm.
        * sid-decode.scm (-gen-scache-decls): Generate the 'written' field.
        * cgen-sid.scm (sim-arguments): Document the generation of model.h.
        * sid-model.scm (unit:enum): New version for sid.
        (gen-model-class-name): New function.
        (gen-model-unit-fn-decl): New function.
        (gen-model-fn-decls): Call gen-model-unit-fn-decl.
        (gen-model-unit-fn-name): New parameter 'when'.
        (-gen-model-insn-fn-name): Ditto.
        (-gen-model-insn-qualified-fn-name): New function.
        (-gen-model-insn-fn-decl): New function.
        (-gen-model-insn-fn-decls): New function.
        (-gen-model-insn-fn): New parameter 'when'. Call
        -gen-model-insn-qualified-fn-name.
        (-gen-model-insn-fns): Generate the constructor for the model. Generate
        functions for modelling insn before and after execution.
        (-gen-model-class-decls): New function.
        (" (gen-model-class-name model) "): New function.
        (gen-model-classes): New function.
        (-gen-insn-timing): Generate functions for modelling insn before and after
        execution.
        (-gen-insn-unit-timing): Generate class-qualified names.
        (-gen-model-timing-table): Ditto.
        (cgen-model.cxx): Generate #include for @@cpu@@.h. Omit generation of code
        not needed (yet) by sid.
        (cgen-model.h): New function.
@
text
@d1583 2
a1584 2
		       (iota (length inputs)
			     (length outputs))))
@


1.8
log
@2003-03-12  Frank Ch. Eigler  <fche@@redhat.com>

        * sid.scm: Set APPLICATION to SID-SIMULATOR.

2003-03-12  Frank Ch. Eigler  <fche@@redhat.com>

        * xstormy16-decode.cxx: Regenerate with fixed cgen SID-SIMULATOR.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2002 Red Hat, Inc.
d1284 1
a1284 1
 (lambda (self insn out?)
d1289 1
d1380 1
a1380 33
   (gen-enum-decl 'unit_type "unit types"
		  "UNIT_"
		  (cons '(none)
			(append
			 ; "apply append" squeezes out nils.
			 (apply append
				; create <model_name>-<unit-name> for each unit
				(map (lambda (model)
				       (let ((units (model:units model)))
					 (if (null? units)
					     nil
					     (map (lambda (unit)
						    (cons (symbol-append (obj:name model) '-
									 (obj:name unit))
							  (cons '- (atlist-attrs (obj-atlist model)))))
						  units))))
				     (current-model-list)))
			 '((max)))))
   ; FIXME: revisit MAX_UNITS
   "#define MAX_UNITS ("
   (number->string
    (apply max
	   (map (lambda (lengths) (apply max lengths))
		(map (lambda (insn)
		       (let ((timing (insn-timing insn)))
			 (if (null? timing)
			     '(1)
			     (map (lambda (insn-timing)
				    (length (timing:units (cdr insn-timing))))
				  timing))))
		     (non-multi-insns (real-insns (current-insn-list)))))))
   ")\n\n"
   )
d1423 2
a1424 1
 (lambda (self unit-num insn overrides cycles-var-name)
d1436 1
d1466 1
d1488 1
d1505 1
d1515 5
a1519 2
      "    int referenced = 0;\n"
      "    unsigned long long UNUSED insn_referenced = abuf->written;\n"
d1576 10
a1585 7
      (string-map (lambda (arg num) (gen-ref-arg arg num 'in))
		  inputs
		  (iota (length inputs)))
      (string-map (lambda (arg num) (gen-ref-arg arg num 'out))
		  outputs
		  (iota (length inputs)
			(length outputs)))
d1588 2
a1589 2
      (gen-model-unit-fn-name (unit:model self) self)
      " (current_cpu, abuf->idesc"
d1591 1
a1591 1
      ", referenced"
d1606 1
a1606 1
 (lambda (self unit-num insn cycles-var-name)
d1609 1
a1609 1
     (send unit 'gen-profile-code unit-num insn args cycles-var-name)))
d1648 1
a1648 1
 (lambda (self model cycles-var-name)
d1653 1
a1653 1
			(send iunit 'gen-profile-code unit-num self cycles-var-name))
d1656 1
a1656 1
	  (send (model-default-unit model) 'gen-profile-code 0 self nil cycles-var-name)))
@


1.7
log
@2002-01-07  Ben Elliston  <bje@@redhat.com>

	* utils.scm (package-cygnus-simulators): Rename from this ..
	(package-red-hat-simulators): .. to this.
	* opcodes.scm (option-set!): Use package-red-hat-simulators.
	* sid-cpu.scm (cgen-desc.h): Likewise.
	(cgen-cpu.h): Likewise.
	(cgen-defs.h): Likewise.
	(cgen-write.cxx): Likewise.
	(cgen-semantics.cxx): Likewise.
	(cgen-sem-switch.cxx): Likewise.
	* sid-decode.scm (cgen-decode.h): Likewise.
	(cgen-decode.cxx): Likewise.
	* sid-model.scm (cgen-model.cxx): Likewise.
	* sid.scm (option-set!): Likewise.
	* sim.scm (option-set!): Likewise.
@
text
@d13 1
a13 1
(set! APPLICATION 'SIMULATOR)
@


1.6
log
@2002-01-07  Ben Elliston  <bje@@redhat.com>

	* utils.scm (copyright-fsf): Add 2002.
	(copyright-cygnus): Rename to copyright-red-hat.
	(copyright-red-hat): Add 2002.
	(CURRENT-COPYRIGHT): Update comment.
	* opcodes.scm (option-set!): Update callers.
	* sid-model.scm (cgen-model.cxx): Likewise.
	* sid-cpu.scm: Likewise.
	* sid-decode.scm: Likewise.
	* sid.scm (option-set!): Handle "redhat" as an option for
	"copyright"; use copyright-red-hat.
	* sim.scm (option-set!): Likewise.
@
text
@d103 1
a103 1
		      (set! CURRENT-PACKAGE package-cygnus-simulators))
@


1.5
log
@2001-07-05  Ben Elliston  <bje@@redhat.com>

	* sid.scm (sim-finish!): Read .sim files from srcdir/cpu.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
d30 2
a31 2
; copyright fsf|cygnus
;	emit an FSF or Cygnus copyright (temporary, pending decision)
d97 2
a98 2
		       ((equal? value '("cygnus"))
			(set! CURRENT-COPYRIGHT copyright-cygnus))
@


1.4
log
@2001-04-02  Ben Elliston  <bje@@redhat.com>

	* sid-cpu.scm (-last-insn): New function.
	(-gen-sem-switch-engine): Loop through idesc while less than or
	equal to the last instruction enum, not less than the MAX enum.
	(-gen-sfrag-engine-fn): Clean up frag_label_table initialisation.
	* sid-decode.scm (-gen-decode-insn-globals): Define the idesc
	table's size to be the last instruction enum plus one, not
	@@PREFIX@@_INSN_MAX.
	* sid.scm (gen-cpu-insn-enum-decl): Do not append a dummy `max'
	instruction onto the instruction list.
@
text
@d1969 1
a1969 1
  (let ((sim-file (string-append srcdir "/" (current-arch-name) ".sim")))
@


1.3
log
@* branch probability hinting

[cgen/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* sid.cpu (-op-gen-set-trace[-parallel], -create-virtual-insns!):
	Emit LIKELY/UNLIKELY branch probability hints.
	* sid-decode.cpu (-gen-record-args): Ditto.

[sid/include/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* sidconfig.h (LIKELY, UNLIKELY): New conditional cover macros
	for gcc's __builtin_expect branch probability hinting function.
	* sidbusutil.h (passthrough_bus, mux_password_bus, harvard_bus):
	Add some branch probability hints.
	* sidcpuutil.h (step_pin_handler, stop_after_insns_p,
	{read,write}_{insn,data}_memory): Ditto.
	* sidpinutil.h (callback_pin::driven): Remove unnecessary assert
	from critical path.

[eg. sid/component/mapper/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* compMapper.cxx ({read,write}_strideoffset_any): Added b.p. hints.
	(write_any, read_any, locate): Ditto.

[sid/component/cgen-cpu/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* cgen-engine.h (set_pbb_engine, chain, get_next_vpc, pbb_find,
	pbb_find_or_alloc, pbb_before, pbb_after): Add branch probability
	hints.

[eg. sid/component/cgen-cpu/arm7t/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* arm-decode.cxx, -sem.cxx, -semsw.cxx: Regenerated w/ b.p. hints.
	* thumb-decode.cxx, -sem.cxx, -semsw.cxx: Ditto.
@
text
@d1323 1
a1323 2
			     nil)
			 '((max))))
@


1.2
log
@* belated outward merge

2001-01-26  Frank Ch. Eigler  <fche@@redhat.com>

	* sid-cpu.scm (gen-parallel-exec-type): Use unsigned long long for
	writeback tracking.
	(-gen-write-fn, -gen-sem-case, -gen-sfrag-case): Ditto.
	* sid-decode.scm (-gen-scache-decls): Exclude writeback tracking field
	if unnecessary.
	* sid.scm (<operand> gen-write): Use unsigned long long expression
	for writeback.
	(-op-gen-set-trace, -op-gen-set-trace-parallel): Ditto.
	(<unit> gen-profile-code): Ditto.

2001-01-08  Frank Ch. Eigler  <fche@@redhat.com>

	* operand.scm (<operand> pretty-sem-name): New field.
	(<operand> make): Initialize it from hw-name.
	(op:set-pretty-sem-name!): New function.
	(<operand> gen-pretty-name): Default to fetching new field.
	* rtl.scm (hw): Copy hw-name to pretty-sem-name instead.  Restore
	sem-name setting from -rtx-hw-name.
@
text
@d1096 1
a1096 1
	"    if (current_cpu->trace_result_p)\n"
d1145 1
a1145 1
   "    if (current_cpu->trace_result_p)\n"
d1746 1
a1746 1
    if (current_cpu->stop_after_insns_p (abuf->fields.chain.insn_count))
d1764 1
a1764 1
    if (current_cpu->stop_after_insns_p (abuf->fields.chain.insn_count))
@


1.1
log
@2000-12-08  Ben Elliston  <bje@@redhat.com>

	* dev.scm (load-sid): New function.
	* cgen-sid.scm: New file.
	* sid-cpu.scm: Likeiwse.
	* sid-decode.scm: Likewise.
	* sid-model.scm: Likewise.
	* sid.scm: Likewise.
@
text
@d994 1
a994 1
	 (string-append "  if (written & (1 << "
d1084 1
a1084 1
       (string-append "    written |= (1 << "
d1136 1
a1136 1
       (string-append "    written |= (1 << "
d1543 1
a1543 1
      "    int UNUSED insn_referenced = abuf->written;\n"
@

