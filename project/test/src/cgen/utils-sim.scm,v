head	1.23;
access;
symbols
	sid-snapshot-20180601:1.23
	cgen-snapshot-20180601:1.23
	sid-snapshot-20180501:1.23
	cgen-snapshot-20180501:1.23
	sid-snapshot-20180401:1.23
	cgen-snapshot-20180401:1.23
	sid-snapshot-20180301:1.23
	cgen-snapshot-20180301:1.23
	sid-snapshot-20180201:1.23
	cgen-snapshot-20180201:1.23
	sid-snapshot-20180101:1.23
	cgen-snapshot-20180101:1.23
	sid-snapshot-20171201:1.23
	cgen-snapshot-20171201:1.23
	sid-snapshot-20171101:1.23
	cgen-snapshot-20171101:1.23
	sid-snapshot-20171001:1.23
	cgen-snapshot-20171001:1.23
	sid-snapshot-20170901:1.23
	cgen-snapshot-20170901:1.23
	sid-snapshot-20170801:1.23
	cgen-snapshot-20170801:1.23
	sid-snapshot-20170701:1.23
	cgen-snapshot-20170701:1.23
	sid-snapshot-20170601:1.23
	cgen-snapshot-20170601:1.23
	sid-snapshot-20170501:1.23
	cgen-snapshot-20170501:1.23
	sid-snapshot-20170401:1.23
	cgen-snapshot-20170401:1.23
	sid-snapshot-20170301:1.23
	cgen-snapshot-20170301:1.23
	sid-snapshot-20170201:1.23
	cgen-snapshot-20170201:1.23
	sid-snapshot-20170101:1.23
	cgen-snapshot-20170101:1.23
	sid-snapshot-20161201:1.23
	cgen-snapshot-20161201:1.23
	sid-snapshot-20161101:1.23
	cgen-snapshot-20161101:1.23
	sid-snapshot-20160901:1.23
	cgen-snapshot-20160901:1.23
	sid-snapshot-20160801:1.23
	cgen-snapshot-20160801:1.23
	sid-snapshot-20160701:1.23
	cgen-snapshot-20160701:1.23
	sid-snapshot-20160601:1.23
	cgen-snapshot-20160601:1.23
	sid-snapshot-20160501:1.23
	cgen-snapshot-20160501:1.23
	sid-snapshot-20160401:1.23
	cgen-snapshot-20160401:1.23
	sid-snapshot-20160301:1.23
	cgen-snapshot-20160301:1.23
	sid-snapshot-20160201:1.23
	cgen-snapshot-20160201:1.23
	sid-snapshot-20160101:1.23
	cgen-snapshot-20160101:1.23
	sid-snapshot-20151201:1.23
	cgen-snapshot-20151201:1.23
	sid-snapshot-20151101:1.23
	cgen-snapshot-20151101:1.23
	sid-snapshot-20151001:1.23
	cgen-snapshot-20151001:1.23
	sid-snapshot-20150901:1.23
	cgen-snapshot-20150901:1.23
	sid-snapshot-20150801:1.23
	cgen-snapshot-20150801:1.23
	sid-snapshot-20150701:1.23
	cgen-snapshot-20150701:1.23
	sid-snapshot-20150601:1.23
	cgen-snapshot-20150601:1.23
	sid-snapshot-20150501:1.23
	cgen-snapshot-20150501:1.23
	sid-snapshot-20150401:1.23
	cgen-snapshot-20150401:1.23
	sid-snapshot-20150301:1.23
	cgen-snapshot-20150301:1.23
	sid-snapshot-20150201:1.23
	cgen-snapshot-20150201:1.23
	sid-snapshot-20150101:1.23
	cgen-snapshot-20150101:1.23
	sid-snapshot-20141201:1.23
	cgen-snapshot-20141201:1.23
	sid-snapshot-20141101:1.23
	cgen-snapshot-20141101:1.23
	sid-snapshot-20141001:1.23
	cgen-snapshot-20141001:1.23
	sid-snapshot-20140901:1.23
	cgen-snapshot-20140901:1.23
	sid-snapshot-20140801:1.23
	cgen-snapshot-20140801:1.23
	sid-snapshot-20140701:1.23
	cgen-snapshot-20140701:1.23
	sid-snapshot-20140601:1.23
	cgen-snapshot-20140601:1.23
	sid-snapshot-20140501:1.23
	cgen-snapshot-20140501:1.23
	sid-snapshot-20140401:1.23
	cgen-snapshot-20140401:1.23
	sid-snapshot-20140301:1.23
	cgen-snapshot-20140301:1.23
	sid-snapshot-20140201:1.23
	cgen-snapshot-20140201:1.23
	sid-snapshot-20140101:1.23
	cgen-snapshot-20140101:1.23
	sid-snapshot-20131201:1.23
	cgen-snapshot-20131201:1.23
	sid-snapshot-20131101:1.23
	cgen-snapshot-20131101:1.23
	sid-snapshot-20131001:1.23
	cgen-snapshot-20131001:1.23
	sid-snapshot-20130901:1.23
	cgen-snapshot-20130901:1.23
	sid-snapshot-20130801:1.23
	cgen-snapshot-20130801:1.23
	sid-snapshot-20130701:1.23
	cgen-snapshot-20130701:1.23
	sid-snapshot-20130601:1.23
	cgen-snapshot-20130601:1.23
	sid-snapshot-20130501:1.23
	cgen-snapshot-20130501:1.23
	sid-snapshot-20130401:1.23
	cgen-snapshot-20130401:1.23
	sid-snapshot-20130301:1.23
	cgen-snapshot-20130301:1.23
	sid-snapshot-20130201:1.23
	cgen-snapshot-20130201:1.23
	sid-snapshot-20130101:1.23
	cgen-snapshot-20130101:1.23
	sid-snapshot-20121201:1.23
	cgen-snapshot-20121201:1.23
	sid-snapshot-20121101:1.23
	cgen-snapshot-20121101:1.23
	sid-snapshot-20121001:1.23
	cgen-snapshot-20121001:1.23
	sid-snapshot-20120901:1.23
	cgen-snapshot-20120901:1.23
	sid-snapshot-20120801:1.23
	cgen-snapshot-20120801:1.23
	sid-snapshot-20120701:1.23
	cgen-snapshot-20120701:1.23
	sid-snapshot-20120601:1.23
	cgen-snapshot-20120601:1.23
	sid-snapshot-20120501:1.23
	cgen-snapshot-20120501:1.23
	sid-snapshot-20120401:1.23
	cgen-snapshot-20120401:1.23
	sid-snapshot-20120301:1.23
	cgen-snapshot-20120301:1.23
	sid-snapshot-20120201:1.23
	cgen-snapshot-20120201:1.23
	sid-snapshot-20120101:1.23
	cgen-snapshot-20120101:1.23
	sid-snapshot-20111201:1.23
	cgen-snapshot-20111201:1.23
	sid-snapshot-20111101:1.23
	cgen-snapshot-20111101:1.23
	sid-snapshot-20111001:1.23
	cgen-snapshot-20111001:1.23
	sid-snapshot-20110901:1.23
	cgen-snapshot-20110901:1.23
	sid-snapshot-20110801:1.23
	cgen-snapshot-20110801:1.23
	sid-snapshot-20110701:1.23
	cgen-snapshot-20110701:1.23
	sid-snapshot-20110601:1.23
	cgen-snapshot-20110601:1.23
	sid-snapshot-20110501:1.23
	cgen-snapshot-20110501:1.23
	sid-snapshot-20110401:1.23
	cgen-snapshot-20110401:1.23
	sid-snapshot-20110301:1.23
	cgen-snapshot-20110301:1.23
	sid-snapshot-20110201:1.23
	cgen-snapshot-20110201:1.23
	sid-snapshot-20110101:1.23
	cgen-snapshot-20110101:1.23
	sid-snapshot-20101201:1.23
	cgen-snapshot-20101201:1.23
	sid-snapshot-20101101:1.23
	cgen-snapshot-20101101:1.23
	sid-snapshot-20101001:1.23
	cgen-snapshot-20101001:1.23
	sid-snapshot-20100901:1.23
	cgen-snapshot-20100901:1.23
	sid-snapshot-20100801:1.23
	cgen-snapshot-20100801:1.23
	sid-snapshot-20100701:1.23
	cgen-snapshot-20100701:1.23
	sid-snapshot-20100601:1.23
	cgen-snapshot-20100601:1.23
	sid-snapshot-20100501:1.23
	cgen-snapshot-20100501:1.23
	sid-snapshot-20100401:1.23
	cgen-snapshot-20100401:1.23
	sid-snapshot-20100301:1.23
	cgen-snapshot-20100301:1.23
	sid-snapshot-20100201:1.21
	cgen-snapshot-20100201:1.21
	sid-snapshot-20100101:1.21
	cgen-snapshot-20100101:1.21
	sid-snapshot-20091201:1.21
	cgen-snapshot-20091201:1.21
	sid-snapshot-20091101:1.20
	cgen-snapshot-20091101:1.20
	sid-snapshot-20091001:1.19
	cgen-snapshot-20091001:1.19
	arc-sim-20090309:1.15.2.1
	sid-snapshot-20090901:1.17
	cgen-snapshot-20090901:1.17
	sid-snapshot-20090801:1.17
	cgen-snapshot-20090801:1.17
	sid-snapshot-20090701:1.16
	cgen-snapshot-20090701:1.16
	dje-cgen-play1-branch:1.16.0.2
	dje-cgen-play1-branchpoint:1.16
	cgen-1_1-branch:1.15.0.4
	cgen-1_1-branchpoint:1.15
	sid-snapshot-20090601:1.15
	cgen-snapshot-20090601:1.15
	sid-snapshot-20090501:1.15
	cgen-snapshot-20090501:1.15
	sid-snapshot-20090401:1.15
	cgen-snapshot-20090401:1.15
	arc-insight_6_8-branch:1.15.0.2
	arc-insight_6_8-branchpoint:1.15
	sid-snapshot-20090301:1.15
	cgen-snapshot-20090301:1.15
	sid-snapshot-20090201:1.15
	cgen-snapshot-20090201:1.15
	sid-snapshot-20090101:1.15
	cgen-snapshot-20090101:1.15
	sid-snapshot-20081201:1.15
	cgen-snapshot-20081201:1.15
	sid-snapshot-20081101:1.15
	cgen-snapshot-20081101:1.15
	sid-snapshot-20081001:1.15
	cgen-snapshot-20081001:1.15
	sid-snapshot-20080901:1.15
	cgen-snapshot-20080901:1.15
	sid-snapshot-20080801:1.15
	cgen-snapshot-20080801:1.15
	sid-snapshot-20080701:1.15
	cgen-snapshot-20080701:1.15
	sid-snapshot-20080601:1.15
	cgen-snapshot-20080601:1.15
	sid-snapshot-20080501:1.15
	cgen-snapshot-20080501:1.15
	sid-snapshot-20080403:1.15
	sid-snapshot-20080401:1.15
	cgen-snapshot-20080401:1.15
	sid-snapshot-20080301:1.15
	cgen-snapshot-20080301:1.15
	sid-snapshot-20080201:1.15
	cgen-snapshot-20080201:1.15
	sid-snapshot-20080101:1.15
	cgen-snapshot-20080101:1.15
	sid-snapshot-20071201:1.15
	cgen-snapshot-20071201:1.15
	sid-snapshot-20071101:1.15
	cgen-snapshot-20071101:1.15
	sid-snapshot-20071001:1.15
	cgen-snapshot-20071001:1.15
	msnyder-fork-checkpoint-branch:1.13.0.2
	msnyder-fork-checkpoint-branchpoint:1.13
	sid-20020905-branchpoint:1.6
	sid-20020905-branch:1.6.0.6
	cagney_regbuf-20020515-branch:1.6.0.4
	cagney_regbuf-20020515-branchpoint:1.6
	cygnus_cvs_20020108_pre:1.6
	cgen-1-1-branch:1.6.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.23
date	2010.02.13.03.39.15;	author devans;	state Exp;
branches;
next	1.22;

1.22
date	2010.02.12.02.12.12;	author devans;	state Exp;
branches;
next	1.21;

1.21
date	2009.11.23.09.03.01;	author devans;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.24.00.01.26;	author devans;	state Exp;
branches;
next	1.19;

1.19
date	2009.09.17.16.49.12;	author devans;	state Exp;
branches;
next	1.18;

1.18
date	2009.09.07.22.17.34;	author devans;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.10.03.32.31;	author devans;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2006.05.09.18.41.13;	author brolley;	state Exp;
branches
	1.15.2.1
	1.15.4.1;
next	1.14;

1.14
date	2005.12.05.01.27.23;	author hp;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.18.21.52.57;	author brolley;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.16.05.35.48;	author devans;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.15.07.25.03;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.15.07.16.52;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.09.03.08.32;	author bje;	state Exp;
branches;
next	1.8;

1.8
date	2002.12.20.07.58.32;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.20.02.22.22;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.12.02.54.39;	author fche;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.04.18.34.45;	author fche;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.11.17.26.22;	author fche;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.10.16.43.21;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.22.19.14.30;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.16.2.1
date	2009.07.14.16.19.51;	author devans;	state Exp;
branches;
next	;

1.15.2.1
date	2009.03.09.20.36.04;	author amylaar;	state Exp;
branches;
next	;

1.15.4.1
date	2009.06.24.14.57.46;	author devans;	state Exp;
branches;
next	1.15.4.2;

1.15.4.2
date	2009.07.10.03.25.56;	author devans;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.23
log
@update copyright year
@
text
@; Generic simulator application utilities.
; Copyright (C) 2000, 2005, 2006, 2009, 2010 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.

; The cache-addr? method.
; Return #t if the hardware element's address is stored in the scache buffer.
; This saves doing the index calculation during semantic processing.

(method-make!
 <hardware-base> 'cache-addr?
 (lambda (self)
   (and (with-scache?)
	(has-attr? self 'CACHE-ADDR)))
)

(define (hw-cache-addr? hw) (send hw 'cache-addr?))

; The needed-iflds method.
; Return list of ifields needed during semantic execution by hardware element
; SELF referenced by <operand> OP in <sformat> SFMT.

(method-make!
 <hardware-base> 'needed-iflds
 (lambda (self op sfmt)
   (list (op-ifield op)))
)

(method-make!
 <hw-register> 'needed-iflds
 (lambda (self op sfmt)
   (list (op-ifield op)))
; Instead of the following, we now arrange to store the ifield in the
; argbuf, even for CACHE-ADDR operands.  This way, the ifield values 
; (register numbers, etc.) remain available during semantics tracing.
;   (if (hw-cache-addr? self)
;       nil
;       (list (op-ifield op))))
)

; For addresses this is none because we make our own copy of the ifield
; [because we want to use a special type].

(method-make!
 <hw-address> 'needed-iflds
 (lambda (self op sfmt)
   nil)
)

(define (hw-needed-iflds hw op sfmt) (send hw 'needed-iflds op sfmt))

; Return a list of ifields of <operand> OP that must be recorded in ARGBUF
; for <sformat> SFMT.
; ??? At the moment there can only be at most one, but callers must not
; assume this.

(define (op-needed-iflds op sfmt)
  (let ((indx (op:index op)))
    (logit 4 "op-needed-iflds op=" (obj:name op) " indx=" (obj:name indx)
	   " indx-type=" (hw-index:type indx) " sfmt=" (obj:name sfmt) "\n")
    (cond
     ((and 
       (eq? (hw-index:type indx) 'ifield)
       (not (= (ifld-length (hw-index:value indx)) 0)))
      (hw-needed-iflds (op:type op) op sfmt))
     ((eq? (hw-index:type indx) 'derived-ifield)
      (ifld-needed-iflds indx))
     (else nil)))
  )

; Operand extraction (ARGBUF) support code.
;
; Any operand that uses a non-empty ifield needs extraction support.
; Normally we just record the ifield's value.  However, in cases where
; hardware elements have CACHE-ADDR specified or where the mode of the
; hardware index isn't compatible with the mode of the decoded ifield
; (this can happen for pc-relative instruction address), we need to record
; something else.

; Return a boolean indicating if <operand> OP needs any extraction processing.

(define (op-extract? op)
  (let* ((indx (op:index op))
	 (extract?
	  (if (derived-operand? op)
	      (any-true? (map op-extract? (derived-args op)))
	      (and (eq? (hw-index:type indx) 'ifield)
		   (not (= (ifld-length (hw-index:value indx)) 0))))))
    (logit 4 "op-extract? op=" (obj:name op) " =>" extract? "\n")
    extract?)
)

; Return a list of operands that need special extraction processing.
; SFMT is an <sformat> object.

(define (sfmt-extracted-operands sfmt)
  (let ((in-ops (sfmt-in-ops sfmt))
	(out-ops (sfmt-out-ops sfmt)))
    (let ((ops (append (find op-extract? in-ops)
		       (find op-extract? out-ops))))
      (nub ops obj:name)))
)

; Return a list of ifields that are needed by the semantic code.
; SFMT is an <sformat> object.
; ??? This redoes a lot of the calculation that sfmt-extracted-operands does.

(define (sfmt-needed-iflds sfmt)
  (let ((in-ops (sfmt-in-ops sfmt))
	(out-ops (sfmt-out-ops sfmt)))
    (let ((ops (append (find op-extract? in-ops)
		       (find op-extract? out-ops))))
      (nub (apply append (map (lambda (op)
				(op-needed-iflds op sfmt))
			      ops))
	   obj:name)))
)

; Sformat argument buffer.
;
; This contains the details needed to create an argument buffer `fields' union
; entry for the containing sformats.

(define <sformat-argbuf>
  (class-make '<sformat-argbuf>
	      '(<ident>)
	      ; From <ident>:
	      ; - NAME is derived from one of the containing sformats.
	      '(
		; List of structure elements.
		; Each element is ("var name" "C type" bitsize).
		; The list is sorted by decreasing size, then C type,
		; then var name.
		elms
		)
	      nil)
)

(define-getters <sformat-argbuf> sbuf (sfmts elms))

; Subroutine of /sfmt-contents to return an ifield element.
; The result is ("var-name" "C-type" bitsize).

(define (/sfmt-ifld-elm f sfmt)
  (let ((real-mode (mode-real-mode (ifld-decode-mode f))))
    (list (gen-sym f)
	  (mode:c-type real-mode)
	  (mode:bits real-mode)))
)

; sbuf-elm method.
; The result is ("var-name" "C-type" approx-bitsize) or #f if unneeded.
; For the default case we use the ifield as is, which is computed elsewhere.

(method-make!
 <hardware-base> 'sbuf-elm
 (lambda (self op ifmt)
   #f)
)

(method-make!
 <hw-register> 'sbuf-elm
 (lambda (self op ifmt)
   (if (hw-cache-addr? self)
       (list (gen-sym (op:index op))
	     (string-append (gen-type self) "*")
	     ; Use 64 bits for size.  Doesn't really matter, just put them
	     ; near the front.
	     64)
       #f))
)

; We want to use ADDR/IADDR in ARGBUF for addresses

(method-make!
 <hw-address> 'sbuf-elm
 (lambda (self op ifmt)
   (list (gen-sym (op:index op))
	 "ADDR"
	 ; Use 64 bits for size.  Doesn't really matter, just put them
	 ; near the front.
	 64))
)

(method-make!
 <hw-iaddress> 'sbuf-elm
 (lambda (self op ifmt)
   (list (gen-sym (op:index op))
	 "IADDR"
	 ; Use 64 bits for size.  Doesn't really matter, just put them
	 ; near the front.
	 64))
)

; Subroutine of /sfmt-contents to return an operand element.
; These are in addition (or instead of) the actual ifields.
; This is also used to compute definitions of local vars needed in the
; !with-scache case.
; The result is ("var-name" "C-type" approx-bitsize) or #f if unneeded.

(define (sfmt-op-sbuf-elm op sfmt)
  (send (op:type op) 'sbuf-elm op sfmt)
)

; Subroutine of compute-sformat-bufs! to compute list of structure elements
; needed by <sformat> SFMT.
; The result is
; (SFMT ("var-name1" "C-type1" size1) ("var-name2" "C-type2" size2) ...)
; and is sorted by decreasing size, then C type, then variable name
; (as <sformat-argbuf> wants it).

(define (/sfmt-contents sfmt)
  (let ((needed-iflds (sfmt-needed-iflds sfmt))
	(extracted-ops (sfmt-extracted-operands sfmt))
	(in-ops (sfmt-in-ops sfmt))
	(out-ops (sfmt-out-ops sfmt))
	(sort-elms (lambda (a b)
		     ; Sort by descending size, then ascending C type name,
		     ; then ascending name.
		     (cond ((> (caddr a) (caddr b))
			    #t)
			   ((= (caddr a) (caddr b))
			    (cond ((string<? (cadr a) (cadr b))
				   #t)
				  ((string=? (cadr a) (cadr b))
				   (string<? (car a) (car b)))
				  (else
				   #f)))
			   (else
			    #f))))
	)
    (logit 4 
	   "/sfmt-contents sfmt=" (obj:name sfmt) 
	   " needed-iflds=" (obj-csv-names needed-iflds)
	   " extracted-ops=" (obj-csv-names extracted-ops)
	   " in-ops=" (obj-csv-names in-ops)
	   " out-ops=" (obj-csv-names out-ops)
	   "\n")
    (cons sfmt
	  (sort
	   ; Compute list of all things we need to record at extraction time.
	   (find (lambda (x)
		   ; Discard #f entries, they indicate "unneeded".
		   x)
		 (append
		  (map (lambda (f)
			 (/sfmt-ifld-elm f sfmt))
		       needed-iflds)
		  (map (lambda (op)
			 (sfmt-op-sbuf-elm op sfmt))
		       extracted-ops)
		  (cond ((with-any-profile?)
			 (append
			  ; Profiling support.  ??? This stuff is in flux.
			  (map (lambda (op)
				 (sfmt-op-profile-elm op sfmt #f))
			       (find op-profilable? in-ops))
			  (map (lambda (op)
				 (sfmt-op-profile-elm op sfmt #t))
			       (find op-profilable? out-ops))))
			(else 
			 (append)))))
	   sort-elms)))
)

; Return #t if ELM-LIST is a subset of SBUF.
; SBUF is an <sformat-argbuf> object.

(define (/sbuf-subset? elm-list sbuf)
  ; We take advantage of the fact that elements in each are already sorted.
  ; FIXME: Can speed up.
  (let loop ((elm-list elm-list) (sbuf-elm-list (sbuf-elms sbuf)))
    (cond ((null? elm-list)
	   #t)
	  ((null? sbuf-elm-list)
	   #f)
	  ((equal? (car elm-list) (car sbuf-elm-list))
	   (loop (cdr elm-list) (cdr sbuf-elm-list)))
	  (else
	   (loop elm-list (cdr sbuf-elm-list)))))
)

; Subroutine of compute-sformat-bufs!.
; Lookup ELM-LIST in SBUF-LIST.  A match is found if ELM-LIST
; is a subset of one in SBUF-LIST.
; Return the containing <sformat-argbuf> object if found, otherwise return #f.
; SBUF-LIST is a list of <sformat-argbuf> objects.
; ELM-LIST is (elm1 elm2 ...).

(define (/sbuf-lookup elm-list sbuf-list)
  (let loop ((sbuf-list sbuf-list))
    (cond ((null? sbuf-list)
	   #f)
	  ((/sbuf-subset? elm-list (car sbuf-list))
	   (car sbuf-list))
	  (else
	   (loop (cdr sbuf-list)))))
)

; Compute and record the set of <sformat-argbuf> objects needed for SFMT-LIST,
; a list of all sformats.
; The result is the computed list of <sformat-argbuf> objects.
;
; This is used to further reduce the number of entries in the argument buffer's
; `fields' union.  Some sformats have structs with the same contents or one is
; a subset of another's, thus there is no need to distinguish them as far as
; the struct is concerned (there may be other reasons to distinguish them of
; course).
; The consequence of this is fewer semantic fragments created in with-sem-frags
; pbb engines.

(define (compute-sformat-argbufs! sfmt-list)
  (logit 1 "Computing sformat argument buffers ...\n")

  (let ((sfmt-contents
	 ; Sort by descending length.  This helps building the result: while
	 ; iterating over each element, its sbuf is either a subset of a
	 ; previous entry or requires a new entry.
	 (sort (map /sfmt-contents sfmt-list)
	       (lambda (a b)
		 (> (length a) (length b)))))
	; Build an <sformat-argbuf> object.
	(build-sbuf (lambda (sfmt-data)
		      (make <sformat-argbuf>
			(obj:name (car sfmt-data))
			""
			atlist-empty
			(cdr sfmt-data))))
	)
    ; Start off with the first sfmt.
    ; Also build an empty sbuf.  Which sbuf to use for an empty argument list
    ; is rather arbitrary.  Rather than pick one, keep the empty sbuf unto
    ; itself.
    (let ((nub-sbufs (list (build-sbuf (car sfmt-contents))))
	  (empty-sbuf (make <sformat-argbuf>
			'sfmt-empty "no operands" atlist-empty
			nil))
	  )
      (sfmt-set-sbuf! (caar sfmt-contents) (car nub-sbufs))

      ; Now loop over the remaining sfmts.
      (let loop ((sfmt-contents (cdr sfmt-contents)))
	(if (not (null? sfmt-contents))
	    (let ((sfmt-data (car sfmt-contents)))
	      (if (null? (cdr sfmt-data))
		  (sfmt-set-sbuf! (car sfmt-data) empty-sbuf)
		  (let ((sbuf (/sbuf-lookup (cdr sfmt-data) nub-sbufs)))
		    (if (not sbuf)
			(begin
			  (set! sbuf (build-sbuf sfmt-data))
			  (set! nub-sbufs (cons sbuf nub-sbufs))))
		    (sfmt-set-sbuf! (car sfmt-data) sbuf)))
	      (loop (cdr sfmt-contents)))))

      ; Done.
      ; Note that the result will be sorted by ascending number of elements
      ; (because the search list was sorted by descending length and the result
      ; is built up in reverse order of that).
      ; Not that it matters, but that's kinda nice.
      (cons empty-sbuf nub-sbufs)))
)

; Profiling support.

; By default hardware elements are not profilable.

(method-make! <hardware-base> 'profilable? (lambda (self) #f))

(method-make!
 <hw-register> 'profilable?
 (lambda (self) (has-attr? self 'PROFILE))
)

; Return boolean indicating if HW is profilable.

(define (hw-profilable? hw) (send hw 'profilable?))

; Return a boolean indicating if OP is profilable.

(define (op-profilable? op)
  (hw-profilable? (op:type op))
)

; sbuf-profile-data method.
; Return a list of C type and size to use in an sformat's argument buffer.

(method-make!
 <hardware-base> 'sbuf-profile-data
 (lambda (self)
   (error "sbuf-profile-elm not supported for this hw type"))
)

(method-make!
 <hw-register> 'sbuf-profile-data
 (lambda (self)
   ; Don't unnecessarily bloat size of argument buffer.
   (if (<= (hw-num-elms self) 255)
       (list "unsigned char" 8)
       (list "unsigned short" 16)))
)

; Utility to return name of variable/structure-member to use to record
; profiling data for SYM.

(define (gen-profile-sym sym out?)
  (string-append (if out? "out_" "in_")
		 (if (symbol? sym) (symbol->string sym) sym))
)

; Return name of variable/structure-member to use to record data needed for
; profiling operand SELF.

(method-make!
 <operand> 'sbuf-profile-sym
 (lambda (self out?)
   (gen-profile-sym (gen-sym self) out?))
)

; sbuf-profile-elm method.
; Return the ARGBUF member needed for profiling SELF in <sformat> SFMT.
; The result is (var-name "C-type" approx-bitsize) or #f if unneeded.

(method-make!
 <operand> 'sbuf-profile-elm
 (lambda (self sfmt out?)
   (if (hw-scalar? (op:type self))
       #f
       (cons (send self 'sbuf-profile-sym out?)
	     (send (op:type self) 'sbuf-profile-data))))
)

; Subroutine of /sfmt-contents to return an operand's profile element.
; The result is (var-name "C-type" approx-bitsize) or #f if unneeded.

(define (sfmt-op-profile-elm op sfmt out?)
  (send op 'sbuf-profile-elm sfmt out?)
)

; ARGBUF accessor support.

; Define and undefine C macros to tuck away details of instruction format used
; in the extraction and semantic code.  Instruction format names can
; change frequently and this can result in unnecessarily large diffs from one
; generated version of the file to the next.  Secondly, tucking away details of
; the extracted argument structure from the extraction code is a good thing.

; Name of macro to access fields in ARGBUF.
(define c-argbuf-macro "FLD")

; NB: If sfmt is #f, then define the macro to pass through the argument
; symbol.  This is appropriate for "simple" (non-scache) simulators
; that have no abuf/scache in the sem.c routines, but rather plain
; local variables.
(define (gen-define-argbuf-macro sfmt)
  (string-append "#define " c-argbuf-macro "(f) "
		 (if sfmt
		     (string-append
		      "abuf->fields."
		      (gen-sym (sfmt-sbuf sfmt))
		      ".f\n")
		     "f\n"))
)

(define (gen-undef-argbuf-macro sfmt)
  (string-append "#undef " c-argbuf-macro "\n")
)

; For old code.  Delete in time.
(define gen-define-field-macro gen-define-argbuf-macro)
(define gen-undef-field-macro gen-undef-argbuf-macro)

; Return a C reference to an ARGBUF field value.

(define (gen-argbuf-ref name)
  (string-append c-argbuf-macro " (" name ")")
)

; Return name of ARGBUF member for extracted <field> F.

(define (gen-ifld-argbuf-name f)
  (gen-sym f)
)

; Return the C reference to a cached ifield.

(define (gen-ifld-argbuf-ref f)
  (gen-argbuf-ref (gen-ifld-argbuf-name f))
)

; Return name of ARGBUF member holding processed from of extracted
; ifield value for <hw-index> index.

(define (gen-hw-index-argbuf-name index)
  (gen-sym index)
)

; Return C reference to a processed <hw-index> in ARGBUF.

(define (gen-hw-index-argbuf-ref index)
  (gen-argbuf-ref (gen-hw-index-argbuf-name index))
)

; Decode support.

; Main procedure call tree:
; cgen-decode.{c,cxx}
;     /gen-decode-fn
;         gen-decoder [our entry point]
;             decode-build-table
;             /gen-decoder-switch
;                 /gen-decode-table-entry
;                     /gen-decoder-switch
;
; decode-build-table is called to construct a tree of "table-guts" elements
; (??? Need better name obviously),
; and then gen-decoder is recursively called on each of these elements.

; Return C/C++ code that fetches the desired decode bits from C value VAL.
; SIZE is the size in bits of val (the MSB is 1 << (size - 1)) which we
; treat as bitnum 0.
; BITNUMS must be monotonically increasing.
; LSB0? is non-#f if bit number 0 is the least significant bit.
; FIXME: START may not be handled right in words beyond first.
;
; ENTIRE-VAL is passed as a hack for cgen 1.1 which would previously generate
; negative shifts.  FIXME: Revisit for 1.2.
;
; e.g. (/gen-decode-bits '(0 1 2 3 8 9 10 11) 0 16 "insn" #f)
; --> "(((insn >> 8) & 0xf0) | ((insn >> 4) & 0xf))"
; FIXME: The generated code has some inefficiencies in edge cases.  Later.

(define (/gen-decode-bits bitnums start size val entire-val lsb0?)

  ; Compute a list of lists of three numbers:
  ; (first bitnum in group, position in result (0=LSB), bits in result)

  (let ((groups
	 ; POS = starting bit position of current group.
	 ; COUNT = number of bits in group.
	 ; Work from least to most significant bit so reverse bitnums.
	 (let loop ((result nil) (pos 0) (count 0) (bitnums (reverse bitnums)))
	   ;(display (list result pos count bitnums)) (newline)
	   (if (null? bitnums)
	       result
	       (if (or (= (length bitnums) 1)
		       ; Are numbers not next to each other?
		       (not (= (- (car bitnums) (if lsb0? -1 1))
			       (cadr bitnums))))
		   (loop (cons (list (car bitnums) pos (+ 1 count))
			       result)
			 (+ pos count 1) 0
			 (cdr bitnums))
		   (loop result
			 pos (+ 1 count)
			 (cdr bitnums)))))))
    (string-append
     ; While we could just always emit "(0" to handle the case of an empty set,
     ; keeping the code more readable for the normal case is important.
     (if (< (length groups) 1)
	 "(0"
	 "(")
     (string-drop 3
		  (string-map
		   (lambda (group)
		     (let* ((first (car group))
			    (pos (cadr group))
			    (bits (caddr group))
			    ; Difference between where value is and where
			    ; it needs to be.
			    (shift (- (if lsb0?
					  (- first bits -1)
					  (- (+ start size) (+ first bits)))
				      pos)))
		       ; FIXME: There should never be a -ve shift here,
		       ; but it can occur on the m32r.  Compensate here
		       ; with hack and fix in 1.2.
		       (if (< shift 0)
			   (begin
			     (set! val entire-val)
			     (set! shift (+ shift size))))
		       ; END-FIXME
		       (string-append
			" | ((" val " >> " (number->string shift)
			") & ("
			(number->string (- (integer-expt 2 bits) 1))
			" << " (number->string pos) "))")))
		   groups))
     ")"))
)

; Return code to set `itype' and branch to the extraction phase.

(define (/gen-set-itype-and-extract insn-enum fmt-name fn?)
  (string-append
   "itype = "
   insn-enum
   "; "
   (if (with-scache?)
       (if fn?
	   (string-append "@@prefix@@_extract_" fmt-name
			  " (this, current_cpu, pc, base_insn, entire_insn);"
			  " goto done;")
	   (string-append "goto extract_" fmt-name ";"))
       "goto done;"))
)

;; Return code to set `itype' and branch to the extraction phase,
;; bracketed in { } and indented by INDENT.

(define (/gen-bracketed-set-itype-and-extract indent insn-enum fmt-name fn?)
  (string-append
   indent "{ "
   (/gen-set-itype-and-extract insn-enum fmt-name fn?)
   " }\n")
)

; Return code for the default entry of each switch table

(define (/gen-decode-default-entry invalid-insn fn?)
  (/gen-set-itype-and-extract (gen-cpu-insn-enum (current-cpu) invalid-insn)
			      "sfmt_empty"
			      fn?)
)

;; Subroutine of /all-opcode-bits-used? to simplify it.
;; Given TABLE-GUTS-THUS-FAR return the mask of base its that have been
;; examined.
;; TABLE-GUTS-THUS-FAR is a list of dtable-guts objects.
;; PERF: Don't compute this for each insn, but that has to wait on the
;; base-insn-bitsize cleanup (m32r).

(define (/table-guts-to-mask table-guts-thus-far base-bitsize lsb0?)
  ;;(logit 2 "/table-guts-to-mask " (map dtable-guts-bitnums table-guts-thus-far) "\n")
  (let guts-loop ((mask 0) (guts-list table-guts-thus-far))
    (if (null? guts-list)
	mask
	(let bits-loop ((mask mask) (bits (dtable-guts-bitnums (car guts-list))))
	  (if (null? bits)
	      (guts-loop mask (cdr guts-list))
	      (bits-loop (+ mask (word-bit-value (car bits) base-bitsize lsb0?))
			 (cdr bits))))))
)

;; Subroutine of /gen-decode-insn-entry to simplify it.
;; Return a boolean indicating if all opcode bits of INSN have been
;; examined given TABLE-GUTS-THUS-FAR.
;; FIXME: Examine entire insn's opcode bits.

(define (/all-opcode-bits-used? insn table-guts-thus-far lsb0?)
  (let* ((base-mask (insn-base-mask insn))
	 ;; FIXME: This can go away when base-insn-bitsize is fixed (m32r).
	 (base-bitsize (min (insn-base-mask-length insn) (state-base-insn-bitsize)))
	 (table-guts-base-mask (/table-guts-to-mask table-guts-thus-far
						    base-bitsize
						    lsb0?)))
    (= (cg-logand base-mask table-guts-base-mask) base-mask))
)

; Return code for one insn entry, ENTRY.
; REST is the remaining entries.
; TABLE-GUTS-THUS-FAR is the list of dtable-guts objects that led to this insn.

(define (/gen-decode-insn-entry entry rest table-guts-thus-far
				indent lsb0? invalid-insn fn?)
  (assert (eq? 'insn (dtable-entry-type entry)))
  (logit 3 "Generating decode insn entry for " (obj:name (dtable-entry-value entry)) " ...\n")

  (let* ((insn (dtable-entry-value entry))
	 (fmt-name (gen-sym (insn-sfmt insn))))

    (cond

     ; Leave invalids to the default case.
     ((eq? (obj:name insn) 'x-invalid)
      "")

     ; If same contents as next case, fall through.
     ; FIXME: Can reduce more by sorting cases.  Much later.
     ((and (not (null? rest))
	   ; Ensure both insns.
	   (eq? 'insn (dtable-entry-type (car rest)))
	   ; Ensure same insn.
	   (eq? (obj:name insn)
		(obj:name (dtable-entry-value (car rest)))))
      (string-append indent "  case "
		     (number->string (dtable-entry-index entry))
		     " : /* fall through */\n"))

     (else
      (let ((consistent-base-insn? (and (equal? APPLICATION 'SID-SIMULATOR)
					(> (state-base-insn-bitsize)
					   (insn-length insn)))))
	(string-append indent "  case "
		       (number->string (dtable-entry-index entry)) " :"
		       ;; Compensate for base-insn-size > current-insn-size by
		       ;; adjusting entire_insn.
		       ;; Activate this logic only for sid simulators; they are
		       ;; consistent in interpreting base-insn-bitsize this way.
		       (if consistent-base-insn?
			   (string-append
			    "\n"
			    indent "    entire_insn = entire_insn >> "
			    (number->string (- (state-base-insn-bitsize) (insn-length insn)))
			    ";\n")
			   "")
		       ;; If necessary, generate code to check that all of the
		       ;; opcode bits for this insn match.
		       (if (/all-opcode-bits-used? insn table-guts-thus-far lsb0?)
			   (string-append
			    (if consistent-base-insn?
				(string-append indent "    ")
				" ")
			    (/gen-set-itype-and-extract (gen-cpu-insn-enum (current-cpu) insn)
							fmt-name fn?)
			    "\n")
			   (string-append
			    (if consistent-base-insn?
				""
				"\n")
			    indent "    if (("
			    (if (adata-integral-insn? CURRENT-ARCH) "entire_insn" "base_insn")
			    " & " (gen-c-hex-constant (insn-base-mask insn) "CGEN_INSN_LGUINT")
			    ") == " (gen-c-hex-constant (insn-value insn) "CGEN_INSN_LGUINT") ")\n"
			    (/gen-bracketed-set-itype-and-extract (string-append indent "      ")
								  (gen-cpu-insn-enum (current-cpu) insn)
								  fmt-name fn?)
			    indent "    "
			    (/gen-decode-default-entry invalid-insn fn?)
			    "\n")))))))
)

; Subroutine of /decode-expr-ifield-tracking.
; Return a list of all possible values for ifield IFLD-NAME.
; FIXME: Quick-n-dirty implementation.  Should use bit arrays.

(define (/decode-expr-ifield-values ifld-name)
  (let* ((ifld (current-ifld-lookup ifld-name))
	 (bits (ifld-length ifld)))
    (if (mode-unsigned? (ifld-mode ifld))
	(iota (logsll 1 bits))
	(iota (logsll 1 bits) (- (logsll 1 (- bits 1))))))
)

; Subroutine of /decode-expr-ifield-tracking,/decode-expr-ifield-mark-used.
; Create the search key for tracking table lookup.

(define (/decode-expr-ifield-tracking-key insn ifld-name)
  (symbol-append (obj:name (insn-ifmt insn)) '-x- ifld-name)
)

; Subroutine of /gen-decode-expr-entry.
; Return a table to track used ifield values.
; The table is an associative list of (key . value-list).
; KEY is "iformat-name-x-ifield-name".
; VALUE-LIST is a list of the unused values.

(define (/decode-expr-ifield-tracking expr-list)
  (let ((table1
	 (apply append
		(map (lambda (entry)
		       (map (lambda (ifld-name)
			      (cons (exprtable-entry-insn entry)
				    (cons ifld-name
					  (/decode-expr-ifield-values ifld-name))))
			    (exprtable-entry-iflds entry)))
		     expr-list))))
    ; TABLE1 is a list of (insn ifld-name value1 value2 ...).
    (nub (map (lambda (elm)
		(cons
		 (/decode-expr-ifield-tracking-key (car elm) (cadr elm))
		 (cddr elm)))
	      table1)
	 car))
)

; Subroutine of /decode-expr-ifield-mark-used!.
; Return list of values completely used for ifield IFLD-NAME in EXPR.
; "completely used" here means the value won't appear elsewhere.
; e.g. in (andif (eq f-rd 15) (eq f-rx 14)) we don't know what happens
; for the (ne f-rx 14) case.

(define (/decode-expr-ifield-values-used ifld-name expr)
  (case (rtx-name expr)
    ((eq)
     (if (and (rtx-kind? 'ifield (rtx-cmp-op-arg expr 0))
	      (rtx-constant? (rtx-cmp-op-arg expr 1)))
	 (list (rtx-constant-value (rtx-cmp-op-arg expr 1)))
	 nil))
    ((member)
     (if (rtx-kind? 'ifield (rtx-member-value expr))
	 (rtx-member-set expr)
	 nil))
    ; FIXME: more needed
    (else nil))
)

; Subroutine of /gen-decode-expr-entry.
; Mark ifield values used by EXPR-ENTRY in TRACKING-TABLE.

(define (/decode-expr-ifield-mark-used! tracking-table expr-entry)
  (let ((insn (exprtable-entry-insn expr-entry))
	(expr (exprtable-entry-expr expr-entry))
	(ifld-names (exprtable-entry-iflds expr-entry)))
    (for-each (lambda (ifld-name)
		(let ((table-entry
		       (assq (/decode-expr-ifield-tracking-key insn ifld-name)
			     tracking-table))
		      (used (/decode-expr-ifield-values-used ifld-name expr)))
		  (for-each (lambda (value)
			      (delq! value table-entry))
			    used)
		  ))
	      ifld-names))
  *UNSPECIFIED*
)

; Generate code to decode the expression table in ENTRY.
; INVALID-INSN is the <insn> object of the pseudo insn to handle invalid ones.

(define (/gen-decode-expr-entry entry indent invalid-insn fn?)
  (assert (eq? 'expr (dtable-entry-type entry)))
  (logit 3 "Generating decode expr entry for " (exprtable-name (dtable-entry-value entry)) " ...\n")

  (let ((expr-list (exprtable-insns (dtable-entry-value entry))))
    (string-list
     indent "  case "
     (number->string (dtable-entry-index entry))
     " :\n"

     (let ((iflds-tracking (/decode-expr-ifield-tracking expr-list))
	   (indent (string-append indent "    ")))

       (let loop ((expr-list expr-list) (code nil))

	 (if (null? expr-list)

	     ; All done.  If we used up all field values we don't need to
	     ; "fall through" and select the invalid insn marker.

	     (if (all-true? (map null? (map cdr iflds-tracking)))
		 code
		 (append! code
			  (list
			   (/gen-bracketed-set-itype-and-extract
			    indent
			    (gen-cpu-insn-enum (current-cpu) invalid-insn)
			    "sfmt_empty"
			    fn?))))

	     ; Not all done, process next expr.

	     (let ((insn (exprtable-entry-insn (car expr-list)))
		   (expr (exprtable-entry-expr (car expr-list)))
		   (ifld-names (exprtable-entry-iflds (car expr-list))))

	       ; Mark of those ifield values we use first.
	       ; If there are none left afterwards, we can unconditionally
	       ; choose this insn.
	       (/decode-expr-ifield-mark-used! iflds-tracking (car expr-list))

	       (let ((next-code
		      ; If this is the last expression, and it uses up all
		      ; remaining ifield values, there's no need to perform any
		      ; test.
		      (if (and (null? (cdr expr-list))
			       (all-true? (map null? (map cdr iflds-tracking))))

			  ; Need this in a list for a later append!.
			  (string-list
			   (/gen-bracketed-set-itype-and-extract
			    indent
			    (gen-cpu-insn-enum (current-cpu) insn)
			    (gen-sym (insn-sfmt insn))
			    fn?))

			  ; We don't use up all ifield values, so emit a test.
			  (let ((iflds (map current-ifld-lookup ifld-names)))
			    (string-list
			     indent "{\n"
			     (gen-define-ifields iflds
						 (insn-length insn)
						 (string-append indent "  ")
						 #f)
			     (gen-extract-ifields iflds
						  (insn-length insn)
						  (string-append indent "  ")
						  #f)
			     indent "  if ("
			     (rtl-c 'BI expr nil #:ifield-var? #t)
			     ")\n"
			     (/gen-bracketed-set-itype-and-extract
			      (string-append indent "    ")
			      (gen-cpu-insn-enum (current-cpu) insn)
			      (gen-sym (insn-sfmt insn))
			      fn?)
			     indent "}\n")))))

		 (loop (cdr expr-list)
		       (append! code next-code)))))))
     ))
)

; Generate code to decode TABLE.
; REST is the remaining entries.
; SWITCH-NUM, STARTBIT, DECODE-BITSIZE, TABLE-GUTS-THUS-FAR,
; INDENT, LSB0?, INVALID-INSN are the same as for /gen-decoder-switch.

(define (/gen-decode-table-entry table rest switch-num startbit decode-bitsize
				 table-guts-thus-far
				 indent lsb0? invalid-insn fn?)
  (assert (eq? 'table (dtable-entry-type table)))
  (logit 3 "Generating decode table entry for case " (dtable-entry-index table) " ...\n")

  (string-list
   indent "  case "
   (number->string (dtable-entry-index table))
   " :"
   ; If table is same as next, just emit a "fall through" to cut down on
   ; generated code.
   (if (and (not (null? rest))
	    ; Ensure both tables.
	    (eq? 'table (dtable-entry-type (car rest)))
	    ; Ensure same table.
	    (eqv? (subdtable-key (dtable-entry-value table))
		  (subdtable-key (dtable-entry-value (car rest)))))
       " /* fall through */\n"
       (string-list
	"\n"
	(/gen-decoder-switch switch-num
			     startbit
			     decode-bitsize
			     (subdtable-table (dtable-entry-value table))
			     table-guts-thus-far
			     (string-append indent "    ")
			     lsb0?
			     invalid-insn
			     fn?))))
)

; Subroutine of /decode-sort-entries.
; Return a boolean indicating if A,B are equivalent entries.

(define (/decode-equiv-entries? a b)
  (let ((a-type (dtable-entry-type a))
	(b-type (dtable-entry-type b)))
    (if (eq? a-type b-type)
	(case a-type
	  ((insn)
	   (let ((a-name (obj:name (dtable-entry-value a)))
		 (b-name (obj:name (dtable-entry-value b))))
	    (eq? a-name b-name)))
	  ((expr)
	   ; Ignore expr entries for now.
	   #f)
	  ((table)
	   (let ((a-name (subdtable-key (dtable-entry-value a)))
		 (b-name (subdtable-key (dtable-entry-value b))))
	     (eq? a-name b-name))))
	; A and B are not the same type.
	#f))
)

; Subroutine of /gen-decoder-switch, sort ENTRIES according to desired
; print order (maximizes amount of fall-throughs, but maintains numerical
; order as much as possible).
; ??? This is an O(n^2) algorithm.  An O(n Log(n)) algorithm can be done
; but it seemed more complicated than necessary for now.

(define (/decode-sort-entries entries)
  (let ((find-equiv!
	 ; Return list of entries in non-empty list L that have the same decode
	 ; entry as the first entry.  Entries found are marked with #f so
	 ; they're not processed again.
	 (lambda (l)
	   ; Start off the result with the first entry, then see if the
	   ; remaining ones match it.
	   (let ((first (car l)))
	     (let loop ((l (cdr l)) (result (cons first nil)))
	       (if (null? l)
		   (reverse! result)
		   (if (and (car l) (/decode-equiv-entries? first (car l)))
		       (let ((lval (car l)))
			 (set-car! l #f)
			 (loop (cdr l) (cons lval result)))
		       (loop (cdr l) result)))))))
	)
    (let loop ((entries (list-copy entries)) (result nil))
      (if (null? entries)
	  (apply append (reverse! result))
	  (if (car entries)
	      (loop (cdr entries)
		    (cons (find-equiv! entries)
			  result))
	      (loop (cdr entries) result)))))
)

; Generate switch statement to decode TABLE-GUTS.
; SWITCH-NUM is for compatibility with the computed goto decoder and
; isn't used.
; STARTBIT is the bit offset of the instruction value that C variable `insn'
; holds (note that this is independent of LSB0?).
; DECODE-BITSIZE is the number of bits of the insn that `insn' holds.
; TABLE-GUTS-THUS-FAR is a list of the table-guts that got us here,
; excluding TABLE-GUTS.  It is used to decide whether insns have been
; fully decoded (i.e. all opcode bits have been examined).
; LSB0? is non-#f if bit number 0 is the least significant bit.
; INVALID-INSN is the <insn> object of the pseudo insn to handle invalid ones.

; FIXME: for the few-alternative case (say, 2), generating
; if (0) {}
; else if (val == 0) { ... }
; else if (val == 1) { ... }
; else {}
; may well be less stressful on the compiler to optimize than small switch() stmts.

(define (/gen-decoder-switch switch-num startbit decode-bitsize
			     table-guts table-guts-thus-far
			     indent lsb0? invalid-insn fn?)

  (let ((new-table-guts-thus-far (append table-guts-thus-far (list table-guts))))

    (string-list
     indent "{\n"
     ;; Are we at the next word?
     (if (not (= startbit (dtable-guts-startbit table-guts)))
	 (begin
	   (set! startbit (dtable-guts-startbit table-guts))
	   (set! decode-bitsize (dtable-guts-bitsize table-guts))
	 ;; FIXME: Bits may get fetched again during extraction.
	   (string-append indent "  unsigned int val;\n"
			  indent "  /* Must fetch more bits.  */\n"
			  indent "  insn = "
			  (gen-ifetch "pc" startbit decode-bitsize)
			  ";\n"
			  indent "  val = "))
	 (string-append indent "  unsigned int val = "))
     (/gen-decode-bits (dtable-guts-bitnums table-guts)
		       (dtable-guts-startbit table-guts)
		       (dtable-guts-bitsize table-guts)
		       "insn" "entire_insn" lsb0?)
     ";\n"
     indent "  switch (val)\n"
     indent "  {\n"

     ;; The code is more readable, and icache use is improved, if we collapse
     ;; common code into one case and use "fall throughs" for all but the last
     ;; of a set of common cases.
     ;; FIXME: We currently rely on /gen-decode-foo-entry to recognize the fall
     ;; through.  We should take care of it ourselves.

     (let loop ((entries (/decode-sort-entries (dtable-guts-entries table-guts)))
		(result nil))

       (if (null? entries)

	   (reverse! result)

	   (loop
	    (cdr entries)
	    ;; For entries that are a single insn, we're done, otherwise recurse.
	    (cons (case (dtable-entry-type (car entries))
		    ((insn)
		     (/gen-decode-insn-entry (car entries) (cdr entries)
					     new-table-guts-thus-far
					     indent lsb0? invalid-insn fn?))
		    ((expr)
		     (/gen-decode-expr-entry (car entries) indent invalid-insn fn?))
		    ((table)
		     (/gen-decode-table-entry (car entries) (cdr entries)
					      switch-num startbit decode-bitsize
					      new-table-guts-thus-far
					      indent lsb0? invalid-insn fn?))
		    )
		  result))))

     ;; ??? Can delete if all cases are present.
     indent "  default : "
     (/gen-decode-default-entry invalid-insn fn?) "\n"
     indent "  }\n"
     indent "}\n"
     ))
)

; Decoder generation entry point.
; Generate code to decode INSN-LIST.
; BITNUMS is the set of bits to initially key off of.
; DECODE-BITSIZE is the number of bits of the instruction that `insn' holds.
; LSB0? is non-#f if bit number 0 is the least significant bit.
; INVALID-INSN is the <insn> object of the pseudo insn to handle invalid ones.
; FN? is non-#f if the extractors are functions rather than inline code

(define (gen-decoder insn-list bitnums decode-bitsize indent lsb0? invalid-insn fn?)
  (logit 3 "Building decode tree.\n"
	 "bitnums = " (stringize bitnums " ") "\n"
	 "decode-bitsize = " (number->string decode-bitsize) "\n"
	 "lsb0? = " (if lsb0? "#t" "#f") "\n"
	 "fn? = " (if fn? "#t" "#f") "\n"
	 )

  ; First build a table that decodes the instruction set.

  (let ((table-guts (decode-build-table insn-list bitnums
					decode-bitsize lsb0?
					invalid-insn)))

    ; Now print it out.

    (/gen-decoder-switch "0" 0 decode-bitsize
			 table-guts nil
			 indent lsb0? invalid-insn fn?))
)
@


1.22
log
@	* desc-cpu.scm (/gen-cpu-open): Remove comment on K&R support.
	* utils-cgen.scm (gen-define-with-symcat): Remove K&R support.

	* utils-sim.scm (compute-sformat-argbufs!): Use more consistent name
	for name of empty sbuf.

	* iformat.scm (/sfmt-search-key, /ifmt-lookup-sfmt!): Add assert.

	* insn.scm (<insn>): Add initial value for members fmt-desc, ifmt,
	sfmt, tmp.
	(/sub-insn-ifields): Delete old commented out code.
	(/sub-insn-make!, /parse-insn-format-symbol): Ditto.
	* operand.scm (/anyof-merge-setter, anyof-merge-semantics): Ditto.

	* sim-decode.scm (/gen-decode-insn-globals): Tweak formatting of
	generated code.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2005, 2006, 2009 Red Hat, Inc.
@


1.21
log
@	* hardware.scm (hw-pc?): New function.
	* ifield.scm (ifld-signed?): New function.
	* iformat.scm (ifmt-analyze): Call insn-cti-attr? instead of insn-cti?.
	* insn.scm (insn-cti-attr?): Renamed from insn-ctl?.
	(insn-cti?): New function.
	* rtl.scm (/hw): Create <pc> object for pcs.
	* semantics.scm (/build-reg-operand!): New args ref-type, sem-attrs.
	All callers updated.  Watch for sets to the pc.
	(semantic-attrs): Watch for sets to the pc.
	* sid.scm (<pc> cxmake-get): Handle raw-reg.
	* sim.scm (<pc> cxmake-get): Handle raw-reg.
	(<operand> cxmake-get): Add debugging printf.
	* utils-gen.scm (/gen-ifld-extract-base): Emit calls to
	EXTRACT_[LM]SB0_LG[SU]INT for values > 32 bits.
	(/gen-extract-word): Ditto.

	* utils.scm (gen-c-hex-constant): New function.
	* utils-sim.scm (/gen-decode-insn-entry): Call it.
@
text
@d336 1
a336 1
			'fmt-empty "no operands" atlist-empty
@


1.20
log
@	* decode.scm: Tweak various comments.
	(/opcode-slots): Add FIXME.
	(/build-decode-table-guts): Add assert.
	* utils-sim.scm (/gen-set-itype-and-extract): New function.
	(/gen-bracketed-set-itype-and-extract): New function.
	(/gen-decode-default-entry): Rewrite.
	(/table-guts-to-mask, /all-opcode-bits-used?): New functions.
	(/gen-decode-insn-entry): New arg table-guts-thus-far, all callers
	updated.  Don't unnecessarily emit check for whether all opcode bits
	have been examined.
	(/gen-decode-expr-set-itype): Delete.
	(/gen-decode-expr-entry): Update.
	(/gen-decode-table-entry): New arg table-guts-thus-far, all callers
	updated.  Keep track of decoder tables used thus far.
	(/gen-decoder-switch): Ditto.
	* utils.scm (word-bit-value): New function.
@
text
@d722 2
a723 2
			    " & 0x" (number->hex (insn-base-mask insn))
			    ") == 0x" (number->hex (insn-value insn)) ")\n" 
@


1.19
log
@	* utils-cgen.scm (obj-csv-names): New function.
	* utils-sim.scm (/sfmt-contents): Use it in logging message.
@
text
@d511 2
a512 1
;                 /gen-decoder-switch
d591 1
a591 1
; Convert decoder table into C code.
d593 1
a593 3
; Return code for the default entry of each switch table
;
(define (/gen-decode-default-entry indent invalid-insn fn?)
d596 2
a597 2
   (gen-cpu-insn-enum (current-cpu) invalid-insn)
   ";"
d600 5
a604 4
	   " @@prefix@@_extract_sfmt_empty (this, current_cpu, pc, base_insn, entire_insn); goto done;\n"
	   " goto extract_sfmt_empty;\n")
       " goto done;\n")
  )
d607 53
a659 1
; Return code for one insn entry.
d661 1
d663 2
a664 1
(define (/gen-decode-insn-entry entry rest indent invalid-insn fn?)
d690 40
a729 24
      (string-append indent "  case "
		     (number->string (dtable-entry-index entry)) " :\n"
		     ; Compensate for base-insn-size > current-insn-size by adjusting entire_insn.
		     ; Activate this logic only for sid simulators; they are consistent in
		     ; interpreting base-insn-bitsize this way.
		     (if (and (equal? APPLICATION 'SID-SIMULATOR)
			      (> (state-base-insn-bitsize) (insn-length insn)))
			 (string-append
			  indent "    entire_insn = entire_insn >> "
			  (number->string (- (state-base-insn-bitsize) (insn-length insn)))
			  ";\n")
			 "")
		     ; Generate code to check that all of the opcode bits for this insn match
		     indent "    if (("
		     (if (adata-integral-insn? CURRENT-ARCH) "entire_insn" "base_insn")
		     " & 0x" (number->hex (insn-base-mask insn)) ") == 0x" (number->hex (insn-value insn)) ")\n" 
		     indent "      { itype = " (gen-cpu-insn-enum (current-cpu) insn) ";"
		     (if (with-scache?)
			 (if fn?
			     (string-append " @@prefix@@_extract_" fmt-name " (this, current_cpu, pc, base_insn, entire_insn); goto done;")
			     (string-append " goto extract_" fmt-name ";"))
			 " goto done;")
		     " }\n"
		     indent "    " (/gen-decode-default-entry indent invalid-insn fn?)))))
a816 18
; Subroutine of /gen-decode-expr-entry.
; Return code to set `itype' and branch to the extraction phase.

(define (/gen-decode-expr-set-itype indent insn-enum fmt-name fn?)
  (string-append
   indent
   "{ itype = "
   insn-enum
   "; "
   (if (with-scache?)
       (if fn?
	   (string-append "@@prefix@@_extract_" fmt-name " (this, current_cpu, pc, base_insn, entire_insn);  goto done;")
	   (string-append "goto extract_" fmt-name ";"))
       "goto done;")
   " }\n"
   )
)

d844 1
a844 1
			   (/gen-decode-expr-set-itype
d870 1
a870 1
			   (/gen-decode-expr-set-itype
d877 8
a884 4
			   (let ((iflds (map current-ifld-lookup ifld-names)))
			     (string-list
			      indent "{\n"
			      (gen-define-ifields iflds
d888 9
a896 13
			      (gen-extract-ifields iflds
						   (insn-length insn)
						   (string-append indent "  ")
						   #f)
			      indent "  if ("
			      (rtl-c 'BI expr nil #:ifield-var? #t)
			      ")\n"
			      (/gen-decode-expr-set-itype
			       (string-append indent "    ")
			       (gen-cpu-insn-enum (current-cpu) insn)
			       (gen-sym (insn-sfmt insn))
			       fn?)
			      indent "}\n")))))
d905 2
a906 2
; SWITCH-NUM, STARTBIT, DECODE-BITSIZE, INDENT, LSB0?, INVALID-INSN are same
; as for /gen-decoder-switch.
d908 3
a910 1
(define (/gen-decode-table-entry table rest switch-num startbit decode-bitsize indent lsb0? invalid-insn fn?)
d933 1
d1003 3
d1016 2
a1017 1
(define (/gen-decoder-switch switch-num startbit decode-bitsize table-guts
a1018 1
  ; For entries that are a single insn, we're done, otherwise recurse.
d1020 62
a1081 53
  (string-list
   indent "{\n"
   ; Are we at the next word?
   (if (not (= startbit (dtable-guts-startbit table-guts)))
       (begin
	 (set! startbit (dtable-guts-startbit table-guts))
	 (set! decode-bitsize (dtable-guts-bitsize table-guts))
	 ; FIXME: Bits may get fetched again during extraction.
	 (string-append indent "  unsigned int val;\n"
			indent "  /* Must fetch more bits.  */\n"
			indent "  insn = "
			(gen-ifetch "pc" startbit decode-bitsize)
			";\n"
			indent "  val = "))
       (string-append indent "  unsigned int val = "))
   (/gen-decode-bits (dtable-guts-bitnums table-guts)
		     (dtable-guts-startbit table-guts)
		     (dtable-guts-bitsize table-guts)
		     "insn" "entire_insn" lsb0?)
   ";\n"
   indent "  switch (val)\n"
   indent "  {\n"

   ; The code is more readable, and icache use is improved, if we collapse
   ; common code into one case and use "fall throughs" for all but the last of
   ; a set of common cases.
   ; FIXME: We currently rely on /gen-decode-foo-entry to recognize the fall
   ; through.  We should take care of it ourselves.

   (let loop ((entries (/decode-sort-entries (dtable-guts-entries table-guts)))
	      (result nil))
     (if (null? entries)
	 (reverse! result)
	 (loop
	  (cdr entries)
	  (cons (case (dtable-entry-type (car entries))
		  ((insn)
		   (/gen-decode-insn-entry (car entries) (cdr entries) indent invalid-insn fn?))
		  ((expr)
		   (/gen-decode-expr-entry (car entries) indent invalid-insn fn?))
		  ((table)
		   (/gen-decode-table-entry (car entries) (cdr entries)
					    switch-num startbit decode-bitsize
					    indent lsb0? invalid-insn fn?))
		  )
		result))))

   ; ??? Can delete if all cases are present.
   indent "  default : "
   (/gen-decode-default-entry indent invalid-insn fn?)
   indent "  }\n"
   indent "}\n"
   )
d1108 3
a1110 3
    (/gen-decoder-switch "0" 0 decode-bitsize table-guts indent lsb0?
			 invalid-insn fn?)
    )
@


1.18
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d234 4
a237 4
	   " needed-iflds=" (string-map obj:str-name needed-iflds)
	   " extracted-ops=" (string-map obj:str-name extracted-ops)
	   " in-ops=" (string-map obj:str-name in-ops)
	   " out-ops=" (string-map obj:str-name out-ops)
@


1.17
log
@	* utils-sim.scm (-gen-decode-bits): New argument `entire-val'.
	All callers updated.  Work around -ve shifts by referencing the
	entire value.
@
text
@d141 1
a141 1
; Subroutine of -sfmt-contents to return an ifield element.
d144 1
a144 1
(define (-sfmt-ifld-elm f sfmt)
d195 1
a195 1
; Subroutine of -sfmt-contents to return an operand element.
d212 1
a212 1
(define (-sfmt-contents sfmt)
d233 1
a233 1
	   "-sfmt-contents sfmt=" (obj:name sfmt) 
d247 1
a247 1
			 (-sfmt-ifld-elm f sfmt))
d269 1
a269 1
(define (-sbuf-subset? elm-list sbuf)
d290 1
a290 1
(define (-sbuf-lookup elm-list sbuf-list)
d294 1
a294 1
	  ((-sbuf-subset? elm-list (car sbuf-list))
d319 1
a319 1
	 (sort (map -sfmt-contents sfmt-list)
d347 1
a347 1
		  (let ((sbuf (-sbuf-lookup (cdr sfmt-data) nub-sbufs)))
d432 1
a432 1
; Subroutine of -sfmt-contents to return an operand's profile element.
d507 1
a507 1
;     -gen-decode-fn
d510 2
a511 2
;             -gen-decoder-switch
;                 -gen-decoder-switch
d527 1
a527 1
; e.g. (-gen-decode-bits '(0 1 2 3 8 9 10 11) 0 16 "insn" #f)
d531 1
a531 1
(define (-gen-decode-bits bitnums start size val entire-val lsb0?)
d594 1
a594 1
(define (-gen-decode-default-entry indent invalid-insn fn?)
d610 1
a610 1
(define (-gen-decode-insn-entry entry rest indent invalid-insn fn?)
d659 1
a659 1
		     indent "    " (-gen-decode-default-entry indent invalid-insn fn?)))))
d662 1
a662 1
; Subroutine of -decode-expr-ifield-tracking.
d666 1
a666 1
(define (-decode-expr-ifield-values ifld-name)
d674 1
a674 1
; Subroutine of -decode-expr-ifield-tracking,-decode-expr-ifield-mark-used.
d677 1
a677 1
(define (-decode-expr-ifield-tracking-key insn ifld-name)
d681 1
a681 1
; Subroutine of -gen-decode-expr-entry.
d687 1
a687 1
(define (-decode-expr-ifield-tracking expr-list)
d694 1
a694 1
					  (-decode-expr-ifield-values ifld-name))))
d700 1
a700 1
		 (-decode-expr-ifield-tracking-key (car elm) (cadr elm))
d706 1
a706 1
; Subroutine of -decode-expr-ifield-mark-used!.
d712 1
a712 1
(define (-decode-expr-ifield-values-used ifld-name expr)
d727 1
a727 1
; Subroutine of -gen-decode-expr-entry.
d730 1
a730 1
(define (-decode-expr-ifield-mark-used! tracking-table expr-entry)
d736 1
a736 1
		       (assq (-decode-expr-ifield-tracking-key insn ifld-name)
d738 1
a738 1
		      (used (-decode-expr-ifield-values-used ifld-name expr)))
d747 1
a747 1
; Subroutine of -gen-decode-expr-entry.
d750 1
a750 1
(define (-gen-decode-expr-set-itype indent insn-enum fmt-name fn?)
d768 1
a768 1
(define (-gen-decode-expr-entry entry indent invalid-insn fn?)
d778 1
a778 1
     (let ((iflds-tracking (-decode-expr-ifield-tracking expr-list))
d792 1
a792 1
			   (-gen-decode-expr-set-itype
d807 1
a807 1
	       (-decode-expr-ifield-mark-used! iflds-tracking (car expr-list))
d818 1
a818 1
			   (-gen-decode-expr-set-itype
d839 1
a839 1
			      (-gen-decode-expr-set-itype
d854 1
a854 1
; as for -gen-decoder-switch.
d856 1
a856 1
(define (-gen-decode-table-entry table rest switch-num startbit decode-bitsize indent lsb0? invalid-insn fn?)
d875 1
a875 1
	(-gen-decoder-switch switch-num
d885 1
a885 1
; Subroutine of -decode-sort-entries.
d888 1
a888 1
(define (-decode-equiv-entries? a b)
d908 1
a908 1
; Subroutine of -gen-decoder-switch, sort ENTRIES according to desired
d914 1
a914 1
(define (-decode-sort-entries entries)
d926 1
a926 1
		   (if (and (car l) (-decode-equiv-entries? first (car l)))
d958 1
a958 1
(define (-gen-decoder-switch switch-num startbit decode-bitsize table-guts
d977 1
a977 1
   (-gen-decode-bits (dtable-guts-bitnums table-guts)
d988 1
a988 1
   ; FIXME: We currently rely on -gen-decode-foo-entry to recognize the fall
d991 1
a991 1
   (let loop ((entries (-decode-sort-entries (dtable-guts-entries table-guts)))
d999 1
a999 1
		   (-gen-decode-insn-entry (car entries) (cdr entries) indent invalid-insn fn?))
d1001 1
a1001 1
		   (-gen-decode-expr-entry (car entries) indent invalid-insn fn?))
d1003 1
a1003 1
		   (-gen-decode-table-entry (car entries) (cdr entries)
d1011 1
a1011 1
   (-gen-decode-default-entry indent invalid-insn fn?)
d1041 1
a1041 1
    (-gen-decoder-switch "0" 0 decode-bitsize table-guts indent lsb0?
@


1.16
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d524 3
d531 1
a531 1
(define (-gen-decode-bits bitnums start size val lsb0?)
a568 1
			    ; FIXME: Need to handle left (-ve) shift.
d573 13
a585 5
		     (string-append
		      " | ((" val " >> " (number->string shift)
		      ") & ("
		      (number->string (- (integer-expt 2 bits) 1))
		      " << " (number->string pos) "))")))
d958 2
a959 1
(define (-gen-decoder-switch switch-num startbit decode-bitsize table-guts indent lsb0? invalid-insn fn?)
d979 2
a980 1
		     (dtable-guts-bitsize table-guts) "insn" lsb0?)
@


1.16.2.1
log
@Bring over various patches from the trunk.
@
text
@a523 3
; ENTIRE-VAL is passed as a hack for cgen 1.1 which would previously generate
; negative shifts.  FIXME: Revisit for 1.2.
;
d528 1
a528 1
(define (-gen-decode-bits bitnums start size val entire-val lsb0?)
d566 1
d571 5
a575 13
		       ; FIXME: There should never be a -ve shift here,
		       ; but it can occur on the m32r.  Compensate here
		       ; with hack and fix in 1.2.
		       (if (< shift 0)
			   (begin
			     (set! val entire-val)
			     (set! shift (+ shift size))))
		       ; END-FIXME
		       (string-append
			" | ((" val " >> " (number->string shift)
			") & ("
			(number->string (- (integer-expt 2 bits) 1))
			" << " (number->string pos) "))")))
d948 1
a948 2
(define (-gen-decoder-switch switch-num startbit decode-bitsize table-guts
			     indent lsb0? invalid-insn fn?)
d968 1
a968 2
		     (dtable-guts-bitsize table-guts)
		     "insn" "entire_insn" lsb0?)
@


1.15
log
@2006-05-09  Dave Brolley  <brolley@@redhat.com>

        * utils-sim.scm (-gen-decode-insn-entry): Generated code should shift
        'entire_insn' not 'base_insn'.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2005, 2006 Red Hat, Inc.
@


1.15.4.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2005, 2006, 2009 Red Hat, Inc.
@


1.15.4.2
log
@	* utils-sim.scm (-gen-decode-bits): New argument `entire-val'.
	All callers updated.  Work around -ve shifts by referencing the
	entire value.
@
text
@a523 3
; ENTIRE-VAL is passed as a hack for cgen 1.1 which would previously generate
; negative shifts.  FIXME: Revisit for 1.2.
;
d528 1
a528 1
(define (-gen-decode-bits bitnums start size val entire-val lsb0?)
d566 1
d571 5
a575 13
		       ; FIXME: There should never be a -ve shift here,
		       ; but it can occur on the m32r.  Compensate here
		       ; with hack and fix in 1.2.
		       (if (< shift 0)
			   (begin
			     (set! val entire-val)
			     (set! shift (+ shift size))))
		       ; END-FIXME
		       (string-append
			" | ((" val " >> " (number->string shift)
			") & ("
			(number->string (- (integer-expt 2 bits) 1))
			" << " (number->string pos) "))")))
d948 1
a948 2
(define (-gen-decoder-switch switch-num startbit decode-bitsize table-guts
			     indent lsb0? invalid-insn fn?)
d968 1
a968 2
		     (dtable-guts-bitsize table-guts)
		     "insn" "entire_insn" lsb0?)
@


1.15.2.1
log
@Check in ARCompact simulator.  A valid configuration is arc-elf.
This is not quite finished and has most likely a few files that are
obsolete & not used, but it's good enough to run gcc regression tests.
@
text
@a2 1
; Copyright (C) 2007 Free Software Foundation, Inc.
a954 1
   ;(if (not (= 0 1))
a1028 2
    ;(write "size:")
    ;(write (dtable-guts-bitsize table-guts)) (newline)
@


1.14
log
@	* utils-sim.scm (-gen-decode-insn-entry): Correct last change for
	non-(adata-integral-insn? CURRENT-ARCH) case.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2005 Red Hat, Inc.
d634 1
a634 1
			  indent "    entire_insn = base_insn >> "
@


1.13
log
@2005-05-18  Dave Brolley  <brolley@@redhat.com>

        * utils-sim.scm (-gen-decode-default-entry): New function.
        (-gen-decode-insn-entry): Now takes 'invalid-insn' argument. Generate
        code to check that all opcodes bits match.
        (-gen-decoder-switch): Use -gen-decode-default-entry.
@
text
@d639 3
a641 1
		     indent "    if ((entire_insn & 0x" (number->hex (insn-base-mask insn)) ") == 0x" (number->hex (insn-value insn)) ")\n" 
@


1.12
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
d582 15
d600 1
a600 1
(define (-gen-decode-insn-entry entry rest indent fn?)
d627 1
a627 2
		     (number->string (dtable-entry-index entry)) " : "
		     "itype = " (gen-cpu-insn-enum (current-cpu) insn) ";"
d634 1
a634 1
			  " entire_insn = base_insn >> "
d636 1
a636 1
			  ";")
d638 3
d643 5
a647 3
			     (string-append " @@prefix@@_extract_" fmt-name " (this, current_cpu, pc, base_insn, entire_insn); goto done;\n")
			     (string-append " goto extract_" fmt-name ";\n"))
			 " goto done;\n")))))
d985 1
a985 1
		   (-gen-decode-insn-entry (car entries) (cdr entries) indent fn?))
d996 2
a997 8
   indent "  default : itype = "
   (gen-cpu-insn-enum (current-cpu) invalid-insn)
   ";"
   (if (with-scache?)
       (if fn?
	   " @@prefix@@_extract_sfmt_empty (this, current_cpu, pc, base_insn, entire_insn);  goto done;\n"
	   " goto extract_sfmt_empty;\n")
       " goto done;\n")
@


1.11
log
@	* Makefile.am (srcroot): New var.
	(html): New rule.
	* Makefile.in: Regenerate.
	* cgen-doc.scm: New file.
	* html.scm: New file.
	* gen-all-doc: New file.
	* dev.scm (cload): Handle DOC application.
	(load-doc): New fn.
	* machs.scm (machs-for-cpu): New fn.
	* model.scm (models-for-cpu): New fn.
	* utils.scm (gen-c-copyright): Renamed from gen-copyright.
	All uses updated.
	(iota): Rewrite to be identical to pmacro version.  All uses updated.
	* utils-cgen.scm (alpha-sort-obj-list): New fn.
@
text
@d218 2
a219 2
		     ; Sort by descending size, then ascending C type, then
		     ; ascending name.
d234 4
a237 4
	   " needed-iflds=" (string-map obj:name needed-iflds)
	   " extracted-ops=" (string-map obj:name extracted-ops)
	   " in-ops=" (string-map obj:name in-ops)
	   " out-ops=" (string-map obj:name out-ops)
@


1.10
log
@	* utils-sim.scm (-gen-decoder-switch): Back out patch of 2003-01-09.
	(-gen-decode-bits): Instead put in better fix here.
@
text
@d640 1
a640 1
	(iota (- (logsll 1 (- bits 1))) (logsll 1 bits))))
@


1.9
log
@2003-01-09  Ben Elliston  <bje@@redhat.com>

        From Graydon Hoare <graydon@@redhat.com>:
	* utils-sim.scm (-gen-decoder-switch): Fix edge condition for
	empty ISAs.
@
text
@d553 5
a557 1
     "("
d945 3
a947 5
   (if (< (length (dtable-guts-bitnums table-guts)) 1)
       "0"
       (-gen-decode-bits (dtable-guts-bitnums table-guts)
			 (dtable-guts-startbit table-guts)
			 (dtable-guts-bitsize table-guts) "insn" lsb0?))
@


1.8
log
@	* utils-sim.scm (gen-profile-sym): New fn.
	(<operand>,sbuf-profile-sym): New method.
	(<operand>,sbuf-profile-elm): Use it.
	* sim.scm (<operand>,gen-record-profile): Use sbuf-profile-sym instead
	of hardcoding symbol name.
	(<operand>,gen-profile-code): Ditto.
	(<unit>,gen-profile-code): Use gen-profile-sym instead of hardcoding
	symbol name.
@
text
@d941 5
a945 3
   (-gen-decode-bits (dtable-guts-bitnums table-guts)
		     (dtable-guts-startbit table-guts)
		     (dtable-guts-bitsize table-guts) "insn" lsb0?)
@


1.7
log
@	Back out sim*.scm changes of 2001-04-02  Ben Elliston  <bje@@redhat.com>
	Instead do:
	* sim-decode.scm (-gen-decode-insn-globals): Use @@PREFIX@@_INSN__MAX
	as size of IDESC-TABLE-VAR.
	(@@prefix@@_init_idesc_table): Ditto.
	* sim-model.scm (-gen-mach-defns): Ditto.
	* sim.scm (gen-cpu-insn-enum-decl): Rename last elm from max to -max.

	* utils-scm.scm (-gen-decode-insn-entry): Fix some spacing in output.

	* insn.scm (-parse-insn-format-symbol): Improve error message.
	(-parse-insn-format): Ditto.
@
text
@d402 17
d428 1
a428 2
       (cons (string-append (if out? "out_" "in_")
			    (gen-sym self))
@


1.6
log
@* more 16/32-bit insn set support; simulator (sid)

2001-07-11  Frank Ch. Eigler  <fche@@redhat.com>

	* sid-cpu.scm (-gen-mach-params): New proc to emit ...CHUNK_BITSIZE...
	(cgen-desc.h): Call it.
	* sid-decode.scm (-gen-decode-fn): Use base-insn-bitsize as
	decode-size.
	* utils-sim.scm (-gen-decode-insn-entry): For SID only, prepare
	entire_insn for extraction, if it's shorter than base-insn-bitsize.
@
text
@d607 2
a608 2
			     (string-append "goto extract_" fmt-name ";\n"))
			 "goto done;\n")))))
@


1.5
log
@* simple sim fix

2000-12-04  Frank Ch. Eigler  <fche@@redhat.com>

	* utils-sim.scm (gen-define-argbuf-macro): Handle sfmt=#f case, to be
	used by simple/non-scache simulators.
	* sim-cpu.scm (-gen-read-case): Call gen-define/undef-field-macro
	regardless of with-scache?.
	(-gen-write-case, -gen-no-scache-semantic-fn, -gen-sem-case): Ditto.
@
text
@d592 12
a603 4
		     (number->string (dtable-entry-index entry))
		     " : itype = "
		     (gen-cpu-insn-enum (current-cpu) insn)
		     "; "
d606 2
a607 2
			     (string-append "@@prefix@@_extract_" fmt-name " (this, current_cpu, pc, base_insn, entire_insn);  goto done;\n")
			     (string-append "goto extract_" fmt-name ";"))
@


1.4
log
@* parameter to enable sim decode/extract separation

2000-11-10  Frank Ch. Eigler  <fche@@redhat.com>

	* utils-sim.scm (-gen-decode-insn-entry): Add fn? parameter to signal
	request to emit calls to insn extractors as functions rather than
	branches to inline blocks.
	(-gen-decode-expr-set-itype, -gen-decode-expr-entry): Ditto.
	(-gen-decode-table-entry, -gen-decoder-switch, gen-decoder): Ditto.

	* sim-decode.c (-gen-decode-fn): Tell (gen-decode) to emit branches
	to extractor clauses.
@
text
@d434 4
d440 6
a445 3
		 "abuf->fields."
		 (gen-sym (sfmt-sbuf sfmt))
		 ".f\n")
@


1.3
log
@* major sim decoder improvement
* minor diagnostic tweaks

2000-11-10  Frank Ch. Eigler  <fche@@redhat.com>

	* decode.scm (-distinguishing-bit-population): Significantly
	improve popularity heuristic.  Renamed from
	(-mask-bit-population): Gone.
	(-population-above-threshold): Sort new bit numbers in order of
	popularity.
	(-population-top-few): Allow up to three more bits to be selected
	than requested.  Correct selection order to prefer better bits.
	Correct bug in fewer-than-requested case.  Keep threshold as
	floating-point.
	(decode-best-get-bits): Pass also the insn-values.

	* utils-sim.scm (-gen-decoder-switch): Add comment suggesting a
	future optimization.

	* utils.scm (message): Format nested lists better.
@
text
@a68 1
  ;;;; EUREKA ******
d558 1
a558 1
(define (-gen-decode-insn-entry entry rest indent)
d562 2
a563 1
  (let ((insn (dtable-entry-value entry)))
d590 3
a592 4
			 (string-append "goto "
					"extract_"
					(gen-sym (insn-sfmt insn))
					";\n")
d684 1
a684 1
(define (-gen-decode-expr-set-itype indent insn-enum fmt-name)
d691 3
a693 4
       (string-append "goto "
		      "extract_"
		      fmt-name
		      ";")
d702 1
a702 1
(define (-gen-decode-expr-entry entry indent invalid-insn)
d729 2
a730 1
			    "sfmt_empty"))))
d755 2
a756 1
			    (gen-sym (insn-sfmt insn))))
d776 2
a777 1
			       (gen-sym (insn-sfmt insn)))
d790 1
a790 1
(define (-gen-decode-table-entry table rest switch-num startbit decode-bitsize indent lsb0? invalid-insn)
d815 2
a816 1
			     invalid-insn))))
d884 1
d892 1
a892 2

(define (-gen-decoder-switch switch-num startbit decode-bitsize table-guts indent lsb0? invalid-insn)
d931 1
a931 1
		   (-gen-decode-insn-entry (car entries) (cdr entries) indent))
d933 1
a933 1
		   (-gen-decode-expr-entry (car entries) indent invalid-insn))
d937 1
a937 1
					    indent lsb0? invalid-insn))
d946 3
a948 1
       " goto extract_sfmt_empty;\n"
d961 1
d963 1
a963 1
(define (gen-decoder insn-list bitnums decode-bitsize indent lsb0? invalid-insn)
d968 1
d980 1
a980 1
			 invalid-insn)
@


1.2
log
@* snapshot of work toward more complete support of derived-operands

2000-08-22  Frank Ch. Eigler  <fche@@redhat.com>

	* Makefile.in (DIST_COMMON): Regenerated.
	* ifield.scm (derived-ifield needed-iflds): New method.
	* iformat.scm (-ifmt-lookup-sfmt!): Use base ifields for
	sfmts built from derived-ifields.
	* operand.scm (-derived-parse-encoding): Give derived-ifield a fixed
	type symbol 'derived-ifield, not an unparseable string.
	* utils-sim.scm (op-needed-iflds) Handler 'derived-ifield case.
	(-sfmt-contents): Add tracing.

	From Doug Evans <dje@@transmeta.com>:
	* sim.scm (operand cxmake-get): Result is a <c-expr>, not a string of
	C code.
@
text
@d882 7
@


1.1
log
@Initial revision
@
text
@d59 12
a70 5
    (if (and (eq? (hw-index:type indx) 'ifield)
	     (not (= (ifld-length (hw-index:value indx)) 0)))
	(hw-needed-iflds (op:type op) op sfmt)
	nil))
)
d233 7
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
