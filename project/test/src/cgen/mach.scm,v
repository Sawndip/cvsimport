head	1.28;
access;
symbols
	sid-snapshot-20180601:1.28
	cgen-snapshot-20180601:1.28
	sid-snapshot-20180501:1.28
	cgen-snapshot-20180501:1.28
	sid-snapshot-20180401:1.28
	cgen-snapshot-20180401:1.28
	sid-snapshot-20180301:1.28
	cgen-snapshot-20180301:1.28
	sid-snapshot-20180201:1.28
	cgen-snapshot-20180201:1.28
	sid-snapshot-20180101:1.28
	cgen-snapshot-20180101:1.28
	sid-snapshot-20171201:1.28
	cgen-snapshot-20171201:1.28
	sid-snapshot-20171101:1.28
	cgen-snapshot-20171101:1.28
	sid-snapshot-20171001:1.28
	cgen-snapshot-20171001:1.28
	sid-snapshot-20170901:1.28
	cgen-snapshot-20170901:1.28
	sid-snapshot-20170801:1.28
	cgen-snapshot-20170801:1.28
	sid-snapshot-20170701:1.28
	cgen-snapshot-20170701:1.28
	sid-snapshot-20170601:1.28
	cgen-snapshot-20170601:1.28
	sid-snapshot-20170501:1.28
	cgen-snapshot-20170501:1.28
	sid-snapshot-20170401:1.28
	cgen-snapshot-20170401:1.28
	sid-snapshot-20170301:1.28
	cgen-snapshot-20170301:1.28
	sid-snapshot-20170201:1.28
	cgen-snapshot-20170201:1.28
	sid-snapshot-20170101:1.28
	cgen-snapshot-20170101:1.28
	sid-snapshot-20161201:1.28
	cgen-snapshot-20161201:1.28
	sid-snapshot-20161101:1.28
	cgen-snapshot-20161101:1.28
	sid-snapshot-20160901:1.28
	cgen-snapshot-20160901:1.28
	sid-snapshot-20160801:1.28
	cgen-snapshot-20160801:1.28
	sid-snapshot-20160701:1.28
	cgen-snapshot-20160701:1.28
	sid-snapshot-20160601:1.28
	cgen-snapshot-20160601:1.28
	sid-snapshot-20160501:1.28
	cgen-snapshot-20160501:1.28
	sid-snapshot-20160401:1.28
	cgen-snapshot-20160401:1.28
	sid-snapshot-20160301:1.28
	cgen-snapshot-20160301:1.28
	sid-snapshot-20160201:1.28
	cgen-snapshot-20160201:1.28
	sid-snapshot-20160101:1.28
	cgen-snapshot-20160101:1.28
	sid-snapshot-20151201:1.28
	cgen-snapshot-20151201:1.28
	sid-snapshot-20151101:1.28
	cgen-snapshot-20151101:1.28
	sid-snapshot-20151001:1.28
	cgen-snapshot-20151001:1.28
	sid-snapshot-20150901:1.28
	cgen-snapshot-20150901:1.28
	sid-snapshot-20150801:1.28
	cgen-snapshot-20150801:1.28
	sid-snapshot-20150701:1.28
	cgen-snapshot-20150701:1.28
	sid-snapshot-20150601:1.28
	cgen-snapshot-20150601:1.28
	sid-snapshot-20150501:1.28
	cgen-snapshot-20150501:1.28
	sid-snapshot-20150401:1.28
	cgen-snapshot-20150401:1.28
	sid-snapshot-20150301:1.28
	cgen-snapshot-20150301:1.28
	sid-snapshot-20150201:1.28
	cgen-snapshot-20150201:1.28
	sid-snapshot-20150101:1.28
	cgen-snapshot-20150101:1.28
	sid-snapshot-20141201:1.28
	cgen-snapshot-20141201:1.28
	sid-snapshot-20141101:1.28
	cgen-snapshot-20141101:1.28
	sid-snapshot-20141001:1.28
	cgen-snapshot-20141001:1.28
	sid-snapshot-20140901:1.28
	cgen-snapshot-20140901:1.28
	sid-snapshot-20140801:1.28
	cgen-snapshot-20140801:1.28
	sid-snapshot-20140701:1.28
	cgen-snapshot-20140701:1.28
	sid-snapshot-20140601:1.28
	cgen-snapshot-20140601:1.28
	sid-snapshot-20140501:1.28
	cgen-snapshot-20140501:1.28
	sid-snapshot-20140401:1.28
	cgen-snapshot-20140401:1.28
	sid-snapshot-20140301:1.28
	cgen-snapshot-20140301:1.28
	sid-snapshot-20140201:1.28
	cgen-snapshot-20140201:1.28
	sid-snapshot-20140101:1.28
	cgen-snapshot-20140101:1.28
	sid-snapshot-20131201:1.28
	cgen-snapshot-20131201:1.28
	sid-snapshot-20131101:1.28
	cgen-snapshot-20131101:1.28
	sid-snapshot-20131001:1.28
	cgen-snapshot-20131001:1.28
	sid-snapshot-20130901:1.28
	cgen-snapshot-20130901:1.28
	sid-snapshot-20130801:1.28
	cgen-snapshot-20130801:1.28
	sid-snapshot-20130701:1.28
	cgen-snapshot-20130701:1.28
	sid-snapshot-20130601:1.28
	cgen-snapshot-20130601:1.28
	sid-snapshot-20130501:1.28
	cgen-snapshot-20130501:1.28
	sid-snapshot-20130401:1.28
	cgen-snapshot-20130401:1.28
	sid-snapshot-20130301:1.28
	cgen-snapshot-20130301:1.28
	sid-snapshot-20130201:1.28
	cgen-snapshot-20130201:1.28
	sid-snapshot-20130101:1.28
	cgen-snapshot-20130101:1.28
	sid-snapshot-20121201:1.28
	cgen-snapshot-20121201:1.28
	sid-snapshot-20121101:1.28
	cgen-snapshot-20121101:1.28
	sid-snapshot-20121001:1.28
	cgen-snapshot-20121001:1.28
	sid-snapshot-20120901:1.28
	cgen-snapshot-20120901:1.28
	sid-snapshot-20120801:1.28
	cgen-snapshot-20120801:1.28
	sid-snapshot-20120701:1.28
	cgen-snapshot-20120701:1.28
	sid-snapshot-20120601:1.28
	cgen-snapshot-20120601:1.28
	sid-snapshot-20120501:1.28
	cgen-snapshot-20120501:1.28
	sid-snapshot-20120401:1.28
	cgen-snapshot-20120401:1.28
	sid-snapshot-20120301:1.28
	cgen-snapshot-20120301:1.28
	sid-snapshot-20120201:1.28
	cgen-snapshot-20120201:1.28
	sid-snapshot-20120101:1.28
	cgen-snapshot-20120101:1.28
	sid-snapshot-20111201:1.28
	cgen-snapshot-20111201:1.28
	sid-snapshot-20111101:1.28
	cgen-snapshot-20111101:1.28
	sid-snapshot-20111001:1.28
	cgen-snapshot-20111001:1.28
	sid-snapshot-20110901:1.28
	cgen-snapshot-20110901:1.28
	sid-snapshot-20110801:1.28
	cgen-snapshot-20110801:1.28
	sid-snapshot-20110701:1.28
	cgen-snapshot-20110701:1.28
	sid-snapshot-20110601:1.28
	cgen-snapshot-20110601:1.28
	sid-snapshot-20110501:1.28
	cgen-snapshot-20110501:1.28
	sid-snapshot-20110401:1.28
	cgen-snapshot-20110401:1.28
	sid-snapshot-20110301:1.28
	cgen-snapshot-20110301:1.28
	sid-snapshot-20110201:1.28
	cgen-snapshot-20110201:1.28
	sid-snapshot-20110101:1.28
	cgen-snapshot-20110101:1.28
	sid-snapshot-20101201:1.28
	cgen-snapshot-20101201:1.28
	sid-snapshot-20101101:1.28
	cgen-snapshot-20101101:1.28
	sid-snapshot-20101001:1.28
	cgen-snapshot-20101001:1.28
	sid-snapshot-20100901:1.28
	cgen-snapshot-20100901:1.28
	sid-snapshot-20100801:1.28
	cgen-snapshot-20100801:1.28
	sid-snapshot-20100701:1.28
	cgen-snapshot-20100701:1.28
	sid-snapshot-20100601:1.28
	cgen-snapshot-20100601:1.28
	sid-snapshot-20100501:1.28
	cgen-snapshot-20100501:1.28
	sid-snapshot-20100401:1.28
	cgen-snapshot-20100401:1.28
	sid-snapshot-20100301:1.28
	cgen-snapshot-20100301:1.28
	sid-snapshot-20100201:1.27
	cgen-snapshot-20100201:1.27
	sid-snapshot-20100101:1.25
	cgen-snapshot-20100101:1.25
	sid-snapshot-20091201:1.25
	cgen-snapshot-20091201:1.25
	sid-snapshot-20091101:1.23
	cgen-snapshot-20091101:1.23
	sid-snapshot-20091001:1.21
	cgen-snapshot-20091001:1.21
	arc-sim-20090309:1.10
	sid-snapshot-20090901:1.15
	cgen-snapshot-20090901:1.15
	sid-snapshot-20090801:1.12
	cgen-snapshot-20090801:1.12
	sid-snapshot-20090701:1.11
	cgen-snapshot-20090701:1.11
	dje-cgen-play1-branch:1.11.0.2
	dje-cgen-play1-branchpoint:1.11
	cgen-1_1-branch:1.10.0.6
	cgen-1_1-branchpoint:1.10
	sid-snapshot-20090601:1.10
	cgen-snapshot-20090601:1.10
	sid-snapshot-20090501:1.10
	cgen-snapshot-20090501:1.10
	sid-snapshot-20090401:1.10
	cgen-snapshot-20090401:1.10
	arc-insight_6_8-branch:1.10.0.4
	arc-insight_6_8-branchpoint:1.10
	sid-snapshot-20090301:1.10
	cgen-snapshot-20090301:1.10
	sid-snapshot-20090201:1.10
	cgen-snapshot-20090201:1.10
	sid-snapshot-20090101:1.10
	cgen-snapshot-20090101:1.10
	sid-snapshot-20081201:1.10
	cgen-snapshot-20081201:1.10
	sid-snapshot-20081101:1.10
	cgen-snapshot-20081101:1.10
	sid-snapshot-20081001:1.10
	cgen-snapshot-20081001:1.10
	sid-snapshot-20080901:1.10
	cgen-snapshot-20080901:1.10
	sid-snapshot-20080801:1.10
	cgen-snapshot-20080801:1.10
	sid-snapshot-20080701:1.10
	cgen-snapshot-20080701:1.10
	sid-snapshot-20080601:1.10
	cgen-snapshot-20080601:1.10
	sid-snapshot-20080501:1.10
	cgen-snapshot-20080501:1.10
	sid-snapshot-20080403:1.10
	sid-snapshot-20080401:1.10
	cgen-snapshot-20080401:1.10
	sid-snapshot-20080301:1.10
	cgen-snapshot-20080301:1.10
	sid-snapshot-20080201:1.10
	cgen-snapshot-20080201:1.10
	sid-snapshot-20080101:1.10
	cgen-snapshot-20080101:1.10
	sid-snapshot-20071201:1.10
	cgen-snapshot-20071201:1.10
	sid-snapshot-20071101:1.10
	cgen-snapshot-20071101:1.10
	sid-snapshot-20071001:1.10
	cgen-snapshot-20071001:1.10
	msnyder-fork-checkpoint-branch:1.10.0.2
	msnyder-fork-checkpoint-branchpoint:1.10
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	cygnus_cvs_20020108_pre:1.2
	cgen-1-1-branch:1.2.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.28
date	2010.02.13.03.39.15;	author devans;	state Exp;
branches;
next	1.27;

1.27
date	2010.01.29.02.28.40;	author devans;	state Exp;
branches;
next	1.26;

1.26
date	2010.01.28.05.29.04;	author devans;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.23.00.59.57;	author devans;	state Exp;
branches;
next	1.24;

1.24
date	2009.11.03.16.24.01;	author devans;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.26.00.56.34;	author devans;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.24.18.03.22;	author devans;	state Exp;
branches;
next	1.21;

1.21
date	2009.09.23.22.30.19;	author devans;	state Exp;
branches;
next	1.20;

1.20
date	2009.09.09.20.43.04;	author devans;	state Exp;
branches;
next	1.19;

1.19
date	2009.09.09.17.06.19;	author devans;	state Exp;
branches;
next	1.18;

1.18
date	2009.09.09.08.00.16;	author devans;	state Exp;
branches;
next	1.17;

1.17
date	2009.09.08.06.51.44;	author devans;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.07.22.17.34;	author devans;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.22.23.16.01;	author devans;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.12.22.33.37;	author devans;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.06.16.40.43;	author devans;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.18.20.44.58;	author devans;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2005.10.28.19.30.02;	author brolley;	state Exp;
branches
	1.10.6.1;
next	1.9;

1.9
date	2005.06.15.21.28.18;	author brolley;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.09.20.49.24;	author jimb;	state Exp;
branches;
next	1.7;

1.7
date	2003.07.16.05.35.47;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.20.05.17.50;	author devans;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.10.21.22.02;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.04.20.22.49;	author devans;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.15.07.25.02;	author devans;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.12.02.32.25;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.10.6.1
date	2009.06.24.14.57.45;	author devans;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.28
log
@update copyright year
@
text
@;; CPU architecture description.
;; Copyright (C) 2000, 2003, 2009, 2010 Red Hat, Inc.
;; This file is part of CGEN.
;; See file COPYING.CGEN for details.

;; Top level class that records everything about a cpu.
;; FIXME: Rename this to something else and rename <arch-data> to <arch>
;; for consistency with other classes (define-foo -> <foo> object).

(define <arch>
  (class-make '<arch>
	      nil
	      '(
		;; An object of type <arch-data>.
		data

		;; ??? All should really be assumed to be a black-box table.
		(attr-list . (() . ()))
		(enum-list . ())
		(kw-list . ())
		(isa-list . ())
		(cpu-list . ())
		(mach-list . ())
		(model-list . ())
		(ifld-table . ())
		(hw-list . ())
		(op-table . ())
		(ifmt-list . ())
		(sfmt-list . ())
		(insn-table . ())
		(minsn-table . ())
		(subr-list . ())

		(insn-extract . #f) ;; FIXME: wip (and move elsewhere)
		(insn-execute . #f) ;; FIXME: wip (and move elsewhere)

		;; standard values derived from the input data
		derived

		;; #t if multi-insns have been instantiated
		(multi-insns-instantiated? . #f)
		;; #t if instructions have been analyzed
		(insns-analyzed? . #f)
		;; #t if semantics were included in the analysis
		(semantics-analyzed? . #f)
		;; #t if alias insns were included in the analysis
		(aliases-analyzed? . #f)

		;; ordinal of next object that needs one
		(next-ordinal . 0)
		)
	      nil)
)

;; Accessors.
;; Each getter is arch-foo.
;; Each setter is arch-set-foo!.

(define-getters <arch> arch
  (data
   attr-list enum-list kw-list
   isa-list cpu-list mach-list model-list
   ifld-table hw-list op-table ifmt-list sfmt-list
   insn-table minsn-table subr-list
   derived
   multi-insns-instantiated?
   insns-analyzed? semantics-analyzed? aliases-analyzed?
   next-ordinal
   )
)

(define-setters <arch> arch 
  (data
   attr-list enum-list kw-list
   isa-list cpu-list mach-list model-list
   ifld-table hw-list op-table ifmt-list sfmt-list
   insn-table minsn-table subr-list
   derived
   multi-insns-instantiated?
   insns-analyzed? semantics-analyzed? aliases-analyzed?
   next-ordinal
   )
)

;; For elements recorded as a table, return a sorted list.
;; ??? All elements should really be assumed to be a black-box table.

(define (arch-ifld-list arch)
  (/ident-object-table->list (arch-ifld-table arch))
)

(define (arch-op-list arch)
  (/ident-object-table->list (arch-op-table arch))
)

(define (arch-insn-list arch)
  (/ident-object-table->list (arch-insn-table arch))
)

(define (arch-minsn-list arch)
  (/ident-object-table->list (arch-minsn-table arch))
)

;; Get the next ordinal and increment it for the next time.

(define (/get-next-ordinal! arch)
  (let ((ordinal (arch-next-ordinal arch)))
    (arch-set-next-ordinal! arch (+ ordinal 1))
    ordinal)
)

;; FIXME: temp hack for current-ifld-lookup, current-op-lookup.
;; Return the element of list L with the lowest ordinal.

(define (/get-lowest-ordinal l)
  (let ((lowest-obj #f)
	(lowest-ord (/get-next-ordinal! CURRENT-ARCH)))
    (for-each (lambda (elm)
		(if (< (obj-ordinal elm) lowest-ord)
		    (begin
		      (set! lowest-obj elm)
		      (set! lowest-ord (obj-ordinal elm)))))
	      l)
    lowest-obj)
)

;; Table of <source-ident> objects with two access styles:
;; hash lookup, ordered list.
;; The main table is the hash table, the list is lazily created and cached.
;; The table is recorded as (hash-table . list).
;; The list is #f if it needs to be computed.
;; Each entry in the hash table is a list, multiple objects can have the same
;; key (e.g. insns from different isas can have the same name).
;;
;; This relies on the ordinal element of <source-ident> objects to build the
;; ordered list.

(define (/make-ident-object-table hash-size)
  (cons (make-hash-table hash-size) #f)
)

;; Return ordered list.
;;
;; To allow splicing in new objects we recognize two kinds of ordinal numbers:
;; integer and (integer . integer) where the latter is a pair of
;; major-ordinal-number and minor-ordinal-number.

(define (/ident-object-table->list iot)
  (if (cdr iot)
      (cdr iot)
      (let ((unsorted (hash-fold (lambda (key value prior)
				   ;; NOTE: {value} usually contains just
				   ;; one element.
				   (append value prior))
				 '()
				 (car iot))))
	(set-cdr! iot
		  (sort unsorted (lambda (a b)
				   ;; Ordinals are either an integer or
				   ;; (major . minor).
				   (let ((oa (obj-ordinal a))
					 (ob (obj-ordinal b)))
				     ;; Quick test for common case.
				     (if (and (number? oa) (number? ob))
					 (< oa ob)
					 (let ((maj-a (if (pair? oa) (car oa) oa))
					       (maj-b (if (pair? ob) (car ob) ob))
					       (min-a (if (pair? oa) (cdr oa) 0))
					       (min-b (if (pair? ob) (cdr ob) 0)))
					   (cond ((< maj-a maj-b) #t)
						 ((= maj-a maj-b) (< min-a min-b))
						 (else #f))))))))
	(cdr iot)))
)

;; Add an entry to an ident-object-table.

(define (/ident-object-table-add! arch iot key object)
  ;; Give OBJECT an ordinal if it doesn't have one already.
  (if (not (obj-ordinal object))
      (obj-set-ordinal! object (/get-next-ordinal! arch)))

  ;; Remember: Elements in the hash table are lists of objects, this is because
  ;; multiple objects can have the same key if they come from different isas.
  (let ((elm (hashq-ref (car iot) key)))
    (if elm
	(hashq-set! (car iot) key (cons object elm))
	(hashq-set! (car iot) key (cons object nil))))

  ;; Need to recompute the sorted list.
  (set-cdr! iot #f)

  *UNSPECIFIED*
)

;; Look up KEY in an ident-object-table.

(define (/ident-object-table-lookup iot key)
  (hashq-ref iot key)
)

;; Class for recording things specified in `define-arch'.
;; This simplifies define-arch as the global arch object CURRENT-ARCH
;; must exist before loading the .cpu file.

(define <arch-data>
  (class-make '<arch-data>
	      '(<ident>)
	      '(
		;; Default alignment of memory operations.
		;; One of aligned, unaligned, forced.
		default-alignment

		;; Orientation of insn bit numbering (#f->msb=0, #t->lsb=0).
		insn-lsb0?

		;; List of all machs.
		;; Each element is pair of (mach-name . sanitize-key)
		;; where sanitize-key is #f if there is none.
		;; blah blah blah ... ooohhh, evil sanitize key, blah blah blah
		machs

		;; List of all isas (instruction set architecture).
		;; Each element is a pair of (isa-name . sanitize-key)
		;; where sanitize-key is #f if there is none.
		;; There is usually just one.  ARM has two (arm, thumb).
		;; blah blah blah ... ooohhh, evil sanitize key, blah blah blah
		isas

		;; ??? Defaults for other things should be here.
		)
	      nil)
)

(define-getters <arch-data> adata
  (default-alignment insn-lsb0? machs isas)
)

;; Add, list, lookup accessors for <arch>.
;;
;; For the lookup routines, the result is the object or #f if not found.
;; For some, if X is already an object, return that.

(define (current-arch-name) (obj:name (arch-data CURRENT-ARCH)))

(define (current-arch-comment) (obj:comment (arch-data CURRENT-ARCH)))

(define (current-arch-atlist) (obj-atlist (arch-data CURRENT-ARCH)))

(define (current-arch-default-alignment)
  (adata-default-alignment (arch-data CURRENT-ARCH)))

(define (current-arch-insn-lsb0?)
  (adata-insn-lsb0? (arch-data CURRENT-ARCH)))

(define (current-arch-mach-name-list)
  (map car (adata-machs (arch-data CURRENT-ARCH)))
)

(define (current-arch-isa-name-list)
  (map car (adata-isas (arch-data CURRENT-ARCH)))
)

;; Attributes.
;; Recorded as a pair of lists.
;; The car is a list of <attribute> objects.
;; The cdr is an associative list of (name . <attribute>) elements, for lookup.
;; Could use a hash table except that there currently aren't that many.

(define (current-attr-list) (car (arch-attr-list CURRENT-ARCH)))

(define (current-attr-add! a)
  ;; NOTE: While putting this test in define-attr feels better, having it here
  ;; is more robust, internal calls get checked too.  Thus it's here.
  ;; Ditto for all the other such tests in this file.
  (if (current-attr-lookup (obj:name a))
      (parse-error (make-current-context "define-attr")
		   "attribute already defined" (obj:name a)))
  (let ((adata (arch-attr-list CURRENT-ARCH)))
    ;; Build list in normal order so we don't have to reverse it at the end
    ;; (since our format is non-trivial).
    (if (null? (car adata))
	(arch-set-attr-list! CURRENT-ARCH
			     (cons (cons a nil)
				   (acons (obj:name a) a nil)))
	(begin
	  (append! (car adata) (cons a nil))
	  (append! (cdr adata) (acons (obj:name a) a nil)))))
  *UNSPECIFIED*
)

(define (current-attr-lookup attr-name)
  (assq-ref (cdr (arch-attr-list CURRENT-ARCH)) attr-name)
)

;; Enums.

(define (current-enum-list) (arch-enum-list CURRENT-ARCH))

(define (current-enum-add! e)
  (if (current-enum-lookup (obj:name e))
      (parse-error (make-current-context "define-enum")
		   "enum already defined" (obj:name e)))
  (arch-set-enum-list! CURRENT-ARCH (cons e (arch-enum-list CURRENT-ARCH)))
  *UNSPECIFIED*
)

(define (current-enum-lookup enum-name)
  (object-assq enum-name (current-enum-list))
)

;; Keywords.

(define (current-kw-list) (arch-kw-list CURRENT-ARCH))

(define (current-kw-add! kw)
  (if (current-kw-lookup (obj:name kw))
      (parse-error (make-current-context "define-keyword")
		   "keyword already defined" (obj:name kw)))
  (arch-set-kw-list! CURRENT-ARCH (cons kw (arch-kw-list CURRENT-ARCH)))
  *UNSPECIFIED*
)

(define (current-kw-lookup kw-name)
  (object-assq kw-name (current-kw-list))
)

;; Instruction sets.

(define (current-isa-list) (arch-isa-list CURRENT-ARCH))

(define (current-isa-add! i)
  (if (current-isa-lookup (obj:name i))
      (parse-error (make-current-context "define-isa")
		   "isa already defined" (obj:name i)))
  (arch-set-isa-list! CURRENT-ARCH (cons i (arch-isa-list CURRENT-ARCH)))
  *UNSPECIFIED*
)

(define (current-isa-lookup isa-name)
  (object-assq isa-name (current-isa-list))
)

;; Given a list of objects OBJ-LIST, return those objects that are from the
;; ISA(s) in ISA-NAME-LIST.
;; ISA-NAME-LIST may be (all) or #f (which also means (all)).

(define (obj-filter-by-isa obj-list isa-name-list)
  (if (or (eq? isa-name-list #f)
	  (memq 'all isa-name-list))
      obj-list
      (find (lambda (obj)
	      (let ((obj-isas (obj-attr-value obj 'ISA)))
		(non-null-intersection? obj-isas isa-name-list)))
	    obj-list))
)

;; Cpu families.

(define (current-cpu-list) (arch-cpu-list CURRENT-ARCH))

(define (current-cpu-add! c)
  (if (current-cpu-lookup (obj:name c))
      (parse-error (make-current-context "define-cpu")
		   "cpu already defined" (obj:name c)))
  (arch-set-cpu-list! CURRENT-ARCH (cons c (arch-cpu-list CURRENT-ARCH)))
  *UNSPECIFIED*
)

(define (current-cpu-lookup cpu-name)
  (object-assq cpu-name (current-cpu-list))
)

;; Machines.

(define (current-mach-list) (arch-mach-list CURRENT-ARCH))

(define (current-mach-add! m)
  (if (current-mach-lookup (obj:name m))
      (parse-error (make-current-context "define-mach")
		   "mach already defined" (obj:name m)))
  (arch-set-mach-list! CURRENT-ARCH (cons m (arch-mach-list CURRENT-ARCH)))
  *UNSPECIFIED*
)

(define (current-mach-lookup mach-name)
  (object-assq mach-name (current-mach-list))
)

;; Models.

(define (current-model-list) (arch-model-list CURRENT-ARCH))

(define (current-model-add! m)
  (if (current-model-lookup (obj:name m))
      (parse-error (make-current-context "define-model")
		   "model already defined" (obj:name m)))
  (arch-set-model-list! CURRENT-ARCH (cons m (arch-model-list CURRENT-ARCH)))
  *UNSPECIFIED*
)

(define (current-model-lookup model-name)
  (object-assq model-name (current-model-list))
)

;; Hardware elements.
;;
;; NOTE: Hardware elements must be uniquely named across all machs and isas.

(define (current-hw-list) (arch-hw-list CURRENT-ARCH))

(define (current-hw-add! hw)
  (if (current-hw-lookup (obj:name hw))
      (parse-error (make-current-context "define-hardware")
		   "hardware already defined" (obj:name hw)))
  (arch-set-hw-list! CURRENT-ARCH (cons hw (arch-hw-list CURRENT-ARCH)))
  *UNSPECIFIED*
)

(define (current-hw-lookup hw)
  (if (object? hw)
      hw
      ;; This doesn't use object-assq on purpose.  Hardware objects handle
      ;; get-name specially.
      (find-first (lambda (hw-obj) (eq? (send hw-obj 'get-name) hw))
		  (current-hw-list)))
)

;; Instruction fields.
;;
;; NOTE: Instruction fields must be uniquely named across all machs,
;; but isas may share ifields with the same name.

(define (current-ifld-list)
  (/ident-object-table->list (arch-ifld-table CURRENT-ARCH))
)

(define (current-ifld-add! f)
  (if (/ifld-already-defined? f)
      (parse-error (make-obj-context f "define-ifield")
		   "ifield already defined" (obj:name f)))
  (/ident-object-table-add! CURRENT-ARCH (arch-ifld-table CURRENT-ARCH)
			    (obj:name f) f)
  *UNSPECIFIED*
)

;; Look up ifield X in the current architecture.
;; Returns the <ifield> object or #f if not found.
;; If there is an ambiguity (i.e. the ifield is in multiple ISAs and
;; MAYBE-ISA-NAME-LIST doesn't disambiguate the choice) an error is signalled.
;;
;; If X is an <ifield> object, just return it.
;; This is to handle ???
;; Otherwise X is the name of the ifield to look up.
;; If MAYBE-ISA-NAME-LIST is provided, the car is a list of ISAs to look in.
;; If the specified isa list is #f, look in all ISAs.

(define (current-ifld-lookup x . maybe-isa-name-list)
  (if (ifield? x)
      x
      (let ((f-list (/ident-object-table-lookup (car (arch-ifld-table CURRENT-ARCH))
						x)))
	(if f-list
	    (let* ((isas (if (not (null? maybe-isa-name-list)) (car maybe-isa-name-list) #f))
		   (filtered-f-list (obj-filter-by-isa f-list isas)))
	      (case (length filtered-f-list)
		((0) (error "Ifield not in specified ISA:" x))
		((1) (car filtered-f-list))
		(else (error "Ambiguous ifield lookup:" x))))
	    #f)))
)

;; Return a boolean indicating if <ifield> F is currently defined.
;; This is slightly complicated because multiple isas can have different
;; ifields with the same name.

(define (/ifld-already-defined? f)
  (let ((iflds (/ident-object-table-lookup (car (arch-ifld-table CURRENT-ARCH))
					   (obj:name f))))
    ;; We've got all the ifields with the same name,
    ;; now see if any have the same ISA as F.
    (if iflds
	(let ((result #f)
	      (f-isas (obj-isa-list f)))
	  (for-each (lambda (ff)
		      (if (non-null-intersection? f-isas (obj-isa-list ff))
			  (set! result #t)))
		    iflds)
	  result)
	#f))
)

;; Operands.
;;
;; NOTE: Operands must be uniquely named across all machs,
;; but isas may share operands with the same name.

(define (current-op-list)
  (/ident-object-table->list (arch-op-table CURRENT-ARCH))
)

(define (current-op-add! op)
  (if (/op-already-defined? op)
      (parse-error (make-obj-context op "define-operand")
		   "operand already defined" (obj:name op)))
  (/ident-object-table-add! CURRENT-ARCH (arch-op-table CURRENT-ARCH)
			    (obj:name op) op)
  *UNSPECIFIED*
)

;; Look up operand NAME in the current architecture.
;; Returns the <operand> object or #f if not found.
;; If there is an ambiguity (i.e. the operand is in multiple ISAs and
;; MAYBE-ISA-NAME-LIST doesn't disambiguate the choice) an error is signalled.
;;
;; If MAYBE-ISA-NAME-LIST is provided, the car is a list of ISAs to look in.
;; If the specified isa list is #f, look in all ISAs.

(define (current-op-lookup name . maybe-isa-name-list)
  (let ((op-list (/ident-object-table-lookup (car (arch-op-table CURRENT-ARCH))
					     name)))
    (if op-list
	(let* ((isas (if (not (null? maybe-isa-name-list)) (car maybe-isa-name-list) #f))
	       (filtered-o-list (obj-filter-by-isa op-list isas)))
	  (case (length filtered-o-list)
	    ((0) (error "Operand not in specified ISA:" name))
	    ((1) (car filtered-o-list))
	    (else (error "Ambiguous operand lookup:" name))))
	#f))
)

;; Return a boolean indicating if <operand> OP is currently defined.
;; This is slightly complicated because multiple isas can have different
;; operands with the same name.

(define (/op-already-defined? op)
  (let ((ops (/ident-object-table-lookup (car (arch-op-table CURRENT-ARCH))
					 (obj:name op))))
    ;; We've got all the operands with the same name,
    ;; now see if any have the same ISA as OP.
    (if ops
	(let ((result #f)
	      (op-isas (obj-isa-list op)))
	  (for-each (lambda (o)
		      (if (non-null-intersection? op-isas (obj-isa-list o))
			  (set! result #t)))
		    ops)
	  result)
	#f))
)

;; Instruction field formats.

(define (current-ifmt-list) (arch-ifmt-list CURRENT-ARCH))

;; Semantic formats (akin to ifmt's, except includes semantics to distinguish
;; insns).

(define (current-sfmt-list) (arch-sfmt-list CURRENT-ARCH))

;; Instructions.
;;
;; NOTE: Instructions must be uniquely named across all machs,
;; but isas may share instructions with the same name.

(define (current-insn-list)
  (/ident-object-table->list (arch-insn-table CURRENT-ARCH))
)

(define (current-insn-add! i)
  (if (/insn-already-defined? i)
      (parse-error (make-obj-context i "define-insn")
		   "insn already defined" (obj:name i)))
  (/ident-object-table-add! CURRENT-ARCH (arch-insn-table CURRENT-ARCH)
			    (obj:name i) i)
  *UNSPECIFIED*
)

;; Look up insn NAME in the current architecture.
;; Returns the <insn> object or #f if not found.
;; If there is an ambiguity (i.e. the insn is in multiple ISAs and
;; ISA-NAME-LIST doesn't disambiguate the choice) an error is signalled.
;; If the specified isa list is #f, look in all ISAs.

(define (current-insn-lookup name isa-name-list)
  (let ((i-list (/ident-object-table-lookup (car (arch-insn-table CURRENT-ARCH))
					    name)))
    (if i-list
	(let ((filtered-i-list (obj-filter-by-isa i-list isa-name-list)))
	  (case (length filtered-i-list)
	    ((0) (error "Insn not in specified ISA:" name))
	    ((1) (car filtered-i-list))
	    (else (error "Ambiguous insn lookup:" name))))
	#f))
)

;; Return a boolean indicating if <insn> INSN is currently defined.
;; This is slightly complicated because multiple isas can have different
;; insns with the same name.

(define (/insn-already-defined? insn)
  (let ((insns (/ident-object-table-lookup (car (arch-insn-table CURRENT-ARCH))
					   (obj:name insn))))
    ;; We've got all the insns with the same name,
    ;; now see if any have the same ISA as INSN.
    (if insns
	(let ((result #f)
	      (insn-isas (obj-isa-list insn)))
	  (for-each (lambda (i)
		      (if (non-null-intersection? insn-isas (obj-isa-list i))
			  (set! result #t)))
		    insns)
	  result)
	#f))
)

;; Macro instructions.
;;
;; NOTE: Instructions must be uniquely named across all machs,
;; but isas may share instructions with the same name.

(define (current-minsn-list)
  (/ident-object-table->list (arch-minsn-table CURRENT-ARCH))
)

(define (current-minsn-add! m)
  (if (/minsn-already-defined? m)
      (parse-error (make-obj-context m "define-minsn")
		   "macro-insn already defined" (obj:name m)))
  (/ident-object-table-add! CURRENT-ARCH (arch-minsn-table CURRENT-ARCH)
			    (obj:name m) m)
  *UNSPECIFIED*
)

;; Look up minsn NAME in the current architecture.
;; Returns the <macro-insn> object or #f if not found.
;; If there is an ambiguity (i.e. the minsn is in multiple ISAs and
;; ISA-NAME-LIST doesn't disambiguate the choice) an error is signalled.
;; If the specified isa list is #f, look in all ISAs.

(define (current-minsn-lookup name isa-name-list)
  (let ((m-list (/ident-object-table-lookup (car (arch-minsn-table CURRENT-ARCH))
					    name)))
    (if m-list
	(let ((filtered-m-list (obj-filter-by-isa m-list isa-name-list)))
	  (case (length filtered-m-list)
	    ((0) (error "Macro-insn not in specified ISA:" name))
	    ((1) (car filtered-m-list))
	    (else (error "Ambiguous macro-insn lookup:" name))))
	#f))
)

;; Return a boolean indicating if <macro-insn> MINSN is currently defined.
;; This is slightly complicated because multiple isas can have different
;; macro-insns with the same name.

(define (/minsn-already-defined? m)
  (let ((minsns (/ident-object-table-lookup (car (arch-minsn-table CURRENT-ARCH))
					    (obj:name m))))
    ;; We've got all the macro-insns with the same name,
    ;; now see if any have the same ISA as M.
    (if minsns
	(let ((result #f)
	      (m-isas (obj-isa-list m)))
	  (for-each (lambda (mm)
		      (if (non-null-intersection? m-isas (obj-isa-list mm))
			  (set! result #t)))
		    minsns)
	  result)
	#f))
)

;; rtx subroutines.

(define (current-subr-list) (map cdr (arch-subr-list CURRENT-ARCH)))

(define (current-subr-add! s)
  (if (current-subr-lookup (obj:name s))
      (parse-error (make-current-context "define-subr")
		   "subroutine already defined" (obj:name s)))
  (arch-set-subr-list! CURRENT-ARCH
		       (acons (obj:name s) s (arch-subr-list CURRENT-ARCH)))
  *UNSPECIFIED*
)

(define (current-subr-lookup name)
  (assq-ref (arch-subr-list CURRENT-ARCH) name)
)

;; Arch parsing support.

;; Parse an alignment spec.

(define (/arch-parse-alignment context alignment)
  (if (memq alignment '(aligned unaligned forced))
      alignment
      (parse-error context "invalid alignment" alignment))
)

;; Parse an arch mach spec.
;; The value is a list of mach names or (mach-name sanitize-key) elements.
;; The result is a list of (mach-name . sanitize-key) elements.

(define (/arch-parse-machs context machs)
  (for-each (lambda (m)
	      (if (or (symbol? m)
		      (and (list? m) (= (length m) 2)
			   (symbol? (car m)) (symbol? (cadr m))))
		  #t ;; ok
		  (parse-error context "bad arch mach spec" m)))
	    machs)
  (map (lambda (m)
	 (if (symbol? m)
	     (cons m #f)
	     (cons (car m) (cadr m))))
       machs)
)

;; Parse an arch isa spec.
;; The value is a list of isa names or (isa-name sanitize-key) elements.
;; The result is a list of (isa-name . sanitize-key) elements.

(define (/arch-parse-isas context isas)
  (for-each (lambda (m)
	      (if (or (symbol? m)
		      (and (list? m) (= (length m) 2)
			   (symbol? (car m)) (symbol? (cadr m))))
		  #t ;; ok
		  (parse-error context "bad arch isa spec" m)))
	    isas)
  (map (lambda (m)
	 (if (symbol? m)
	     (cons m #f)
	     (cons (car m) (cadr m))))
       isas)
)

;; Parse an architecture description
;; This is the main routine for building an arch object from a cpu
;; description in the .cpu file.
;; All arguments are in raw (non-evaluated) form.

(define (/arch-parse context name comment attrs
		     default-alignment insn-lsb0?
		     machs isas)
  (logit 2 "Processing arch " name " ...\n")
  (make <arch-data>
    (parse-name context name)
    (parse-comment context comment)
    (atlist-parse context attrs "arch")
    (/arch-parse-alignment context default-alignment)
    (parse-boolean context insn-lsb0?)
    (/arch-parse-machs context machs)
    (/arch-parse-isas context isas))
)

;; Read an architecture description.
;; This is the main routine for analyzing an arch description in the .cpu file.
;; ARG-LIST is an associative list of field name and field value.
;; parse-arch is invoked to create the `arch' object.

(define /arch-read
  (lambda arg-list
    (let ((context "arch-read")
	  ;; <arch-data> object members and default values
	  (name "unknown")
	  (comment "")
	  (attrs nil)
	  (default-alignment 'aligned)
	  (insn-lsb0? #f)
	  (machs #f)
	  (isas #f)
	  )
      ;; Loop over each element in ARG-LIST, recording what's found.
      (let loop ((arg-list arg-list))
	(if (null? arg-list)
	    nil
	    (let ((arg (car arg-list))
		  (elm-name (caar arg-list)))
	      (case elm-name
		((name) (set! name (cadr arg)))
      		((comment) (set! comment (cadr arg)))
		((attrs) (set! attrs (cdr arg)))
      		((default-alignment) (set! default-alignment (cadr arg)))
      		((insn-lsb0?) (set! insn-lsb0? (cadr arg)))
      		((machs) (set! machs (cdr arg)))
      		((isas) (set! isas (cdr arg)))
		(else (parse-error context "invalid arch arg" arg)))
	      (loop (cdr arg-list)))))
      ;; Ensure required fields are present.
      (if (not machs)
	  (parse-error context "missing machs spec"))
      (if (not isas)
	  (parse-error context "missing isas spec"))
      ;; Now that we've identified the elements, build the object.
      (/arch-parse context name comment attrs default-alignment insn-lsb0?
		   machs isas)
      )
    )
)

;; Define an arch object, name/value pair list version.

(define define-arch
  (lambda arg-list
    (let ((a (apply /arch-read arg-list)))
      (arch-set-data! CURRENT-ARCH a)
      (def-mach-attr! (adata-machs a))
      (keep-mach-validate!)
      (def-isa-attr! (adata-isas a))
      (keep-isa-validate!)
      ;; Install the builtin objects now that we have an arch, and now that
      ;; attributes MACH and ISA exist, and now that we know the rtl version.
      (reader-install-builtin!)
      a))
)

;; Mach/isa processing.

;; Create the MACH attribute.
;; MACHS is the canonicalized machs spec to define-arch: (name . sanitize-key).

(define (def-mach-attr! machs)
  (let ((mach-enums (append
		     '((base))
		     (map (lambda (mach)
			    (cons (car mach)
				  (cons '-
					(if (cdr mach)
					    (list (cons 'sanitize (cdr mach)))
					    nil))))
			  machs)
		     '((max)))))
    (define-attr '(type bitset) '(name MACH)
      '(comment "machine type selection")
      '(default base) (cons 'values mach-enums))
    )

  *UNSPECIFIED*
)

;; Return #t if MACH is supported by OBJ.
;; This is done by looking for the MACH attribute in OBJ.
;; By definition, objects that support the default (base) mach support
;; all machs.

(define (mach-supports? mach obj)
  (let ((machs (obj-attr-value obj 'MACH))
	(name (obj:name mach)))
    (or (memq name machs)
	(memq 'base machs)))
	;;(let ((deflt (attr-lookup-default 'MACH obj)))
	;;  (any-true? (map (lambda (m) (memq m deflt)) machs)))))
)

;; Create the ISA attribute.
;; ISAS is the canonicalized isas spec to define-arch: (name . sanitize-key).
;; ISAS is a list of isa names.

(define (def-isa-attr! isas)
  (let ((isa-enums (append
		    (map (lambda (isa)
			   (cons (car isa)
				 (cons '-
				       (if (cdr isa)
					   (list (cons 'sanitize (cdr isa)))
					   nil))))
			 isas)
		    '((max)))))
    (define-attr '(type bitset) '(name ISA)
      '(comment "instruction set selection")
      ;; If there's only one isa, don't (yet) pollute the tables with a value
      ;; for it.
      (if (= (length isas) 1)
	  '(for)
	  '(for ifield operand insn hardware))
      (cons 'default (list (caar isa-enums)))
      (cons 'values isa-enums))
    )

  *UNSPECIFIED*
)

;; Return the bitset attr value for all isas.

(define (all-isas-attr-value)
  (current-arch-isa-name-list)
)

;; Return an ISA attribute of all isas.
;; This is useful for things like f-nil which exist across all isas.

(define (all-isas-attr)
  (bitset-attr-make 'ISA (all-isas-attr-value))
)

;; Return list of ISA names specified by attribute object ATLIST.

(define (attr-isa-list atlist)
  (atlist-attr-value atlist 'ISA #f)
)

;; Return list of ISA names specified by OBJ.

(define (obj-isa-list obj)
  (obj-attr-value obj 'ISA)
)

;; Return #t if <isa> ISA is supported by OBJ.
;; This is done by looking for the ISA attribute in OBJ.

(define (isa-supports? isa obj)
  (let ((isas (obj-isa-list obj))
	(name (obj:name isa)))
    (->bool (memq name isas)))
)

;; The fetch/decode/execute process.
;; "extract" is a fancy word for fetch/decode.
;; FIXME: wip, not currently used.
;; FIXME: move to inside define-isa, and maybe elsewhere.
;;
;(defmacro
;;  define-extract (code)
;;  ;;(arch-set-insn-extract! CURRENT-ARCH code)
;;  *UNSPECIFIED*
;)
;;
;(defmacro
;;  define-execute (code)
;;  ;;(arch-set-insn-execute! CURRENT-ARCH code)
;;  *UNSPECIFIED*
;;)

;; ISA specification.
;; Each architecture is generally one isa, but in the case of ARM (and a few
;; others) there is more than one.
;;
;; ??? "ISA" has a very well defined meaning, and our usage of it one might
;; want to quibble over.  A better name would be welcome.

;; Associated with an instruction set is its framing.
;; This refers to how instructions are laid out at the liw level (where several
;; insns are framed together and executed sequentially or in parallel).
;; ??? If one defines the term "format" as being how an individual instruction
;; is laid out then formatting can be thought of as being different from
;; framing.  However, it's possible for a particular ISA to intertwine the two.
;; Thus this will need to evolve.
;; ??? Not used yet, wip.

(define <iframe> ;; pronounced I-frame
  (class-make '<iframe> '(<ident>)
	      '(
		;; list of <itype> objects that make up the frame
		insns

		;; assembler syntax
		syntax

		;; list of (length value) elements that make up the format
		;; Length is in bits.  Value is either a number or a $number
		;; symbol refering to the insn specified in `insns'.
		value

		;; Initial bitnumbers to decode insns by.
		;; ??? At present the rest of the decoding is determined
		;; algorithmically.  May wish to give the user more control
		;; [like psim].
		decode-assist

		;; rtl that executes instructions in `value'
		;; Fields specified in `value' can be used here.
		action
		)
	      nil)
)

;; Accessors.

(define-getters <iframe> iframe (insns syntax value decode-assist action))

;; Instruction types, recorded in <iframe>.
;; ??? Not used yet, wip.

(define <itype>
  (class-make '<itype> '(<ident>)
	      '(
		;; length in bits, or initial part if variable length (wip)
		length

		;; constraint specifying which insns are included
		constraint

		;; Initial bitnumbers to decode insns by.
		;; ??? At present the rest of the decoding is determined
		;; algorithmically.  May wish to give the user more control
		;; [like psim].
		decode-assist
		)
	      nil)
)

;; Accessors.

(define-getters <itype> itype (length constraint decode-assist))

;; Simulator instruction decode splitting.
;; FIXME: Should live in simulator specific code.  Requires class handling
;; cleanup first.
;;
;; Instructions can be split by particular values for an ifield.
;; The ARM port uses this to split insns into those that set the pc and
;; those that don't.

(define <decode-split>
  (class-make '<decode-split> '()
	      '(
		;; Name of ifield to split on.
		name

		;; Constraint.  Only insns satifying this constraint are
		;; split.  #f if no constraint.
		constraint

		;; List of ifield splits.
		;; Each element is one of (name value) or (name (values)).
		values
		)
	      nil
	      )
)

;; Accessors.

(define-getters <decode-split> decode-split (name constraint values))

;; Parse a decode-split spec.
;; SPEC is (ifield-name constraint value-list).
;; CONSTRAINT is an rtl expression.  Only insns satifying the constraint
;; are split.
;; Each element of VALUE-LIST is one of (name value) or (name (values)).
;; FIXME: All possible values must be specified.  Need an `else' clause.
;; Ranges would also be useful.

(define (/isa-parse-decode-split context spec)
  (if (!= (length spec) 3)
      (parse-error context "decode-split spec is (ifield-name constraint value-list)" spec))

  (let ((name (parse-name (car spec) context))
	(constraint (cadr spec))
	(value-list (caddr spec)))

    ;; FIXME: more error checking.

    (make <decode-split>
      name
      (if (null? constraint) #f constraint)
      value-list))
)

;; Parse a list of decode-split specs.

(define (/isa-parse-decode-splits context spec-list)
  (map (lambda (spec)
	 (/isa-parse-decode-split context spec))
       spec-list)
)

;; Top level class to describe an isa.

(define <isa>
  (class-make '<isa> '(<ident>)
	      '(
		;; Default length to record in ifields.
		;; This is used in calculations involving bit numbers.
		default-insn-word-bitsize

		;; Length of an unknown instruction.  Used by disassembly
		;; and by the simulator's invalid insn handler.
		default-insn-bitsize

		;; Number of bytes of insn that can be initially fetched.
		;; In non-LIW isas this would be the length of the smallest
		;; insn.  For LIW isas it depends - only one LIW isa is
		;; currently supported (m32r).
		base-insn-bitsize

		;; Initial bitnumbers to decode insns by.
		;; ??? At present the rest of the decoding is determined
		;; algorithmically.  May wish to give the user more control
		;; [like psim].
		decode-assist

		;; Number of instructions that can be fetched at a time
		;; [e.g. 2 on m32r].
		liw-insns

		;; Maximum number of instructions the cpu can execute in
		;; parallel.
		;; FIXME: Rename to max-parallel-insns.
		parallel-insns

		;; List of <iframe> objects.
		;frames

		;; Condition tested before execution of any instruction or
		;; #f if there is none.  For architectures like ARM, ARC.
		;; If specified it is a pair of
		;; (condition-field-name . rtl-for-condition)
		(condition . #f)

		;; Code to execute after CONDITION and prior to SEMANTICS.
		;; This is rtl in source form or #f if there is none.
		;; This is generally unused.  It is used on the ARM to set
		;; R15 to the correct value.
		;; The reason it's not specified with SEMANTICS is that it is
		;; believed some applications won't need/want this.
		;; ??? It is a bit of a hack though, as it is used to aid
		;; implementation of apps (e.g. simulator).  Arguably something
		;; that doesn't belong here.  Maybe as more architectures are
		;; ported that have the PC as a general register, a better way
		;; to do this will arise.
		(setup-semantics . #f)

		;; list of simulator instruction splits
		;; FIXME: should live in simulator file (needs class cleanup).
		(decode-splits . ())

		;; ??? More may need to migrate here.
		)
	      nil)
)

;; Accessors.

(define-getters <isa> isa
  (base-insn-bitsize default-insn-bitsize default-insn-word-bitsize
   decode-assist liw-insns parallel-insns condition
   setup-semantics decode-splits)
)

(define-setters <isa> isa
  (decode-splits)
)

(define (isa-enum isa) (string-append "ISA_" (string-upcase (gen-sym isa))))

;; Return minimum/maximum size in bits of all insns in the isa.

(define (isa-min-insn-bitsize isa)
  ;; add `65535' in case list is nil (avoids crash)
  ;; [a language with infinite precision can't have min-reduce-iota-0 :-)]
  (apply min (cons 65535
		   (map insn-length (find (lambda (insn)
					    (and (not (has-attr? insn 'ALIAS))
						 (isa-supports? isa insn)))
					  (non-multi-insns (current-insn-list))))))
)

(define (isa-max-insn-bitsize isa)
  ;; add `0' in case list is nil (avoids crash)
  ;; [a language with infinite precision can't have max-reduce-iota-0 :-)]
  (apply max (cons 0
		   (map insn-length (find (lambda (insn)
					    (and (not (has-attr? insn 'ALIAS))
						 (isa-supports? isa insn)))
					  (non-multi-insns (current-insn-list))))))
)

;; Return a boolean indicating if instructions in ISA can be kept in a
;; portable int.

(define (isa-integral-insn? isa)
  (<= (isa-max-insn-bitsize isa) 32)
)

;; Parse an isa decode-assist spec.

(define (/isa-parse-decode-assist context spec)
  (if (not (all-true? (map non-negative-integer? spec)))
      (parse-error context
		   "spec must consist of non-negative-integers"
		   spec))
  (if (not (= (length spec) (length (nub spec identity))))
      (parse-error context
		   "duplicate elements"
		   spec))
  spec
)

;; Parse an isa condition spec.
;; `condition' here refers to the condition performed by architectures like
;; ARM and ARC before each insn.

(define (/isa-parse-condition context spec)
  (if (null? spec)
      #f
      (begin
	(if (or (!= (length spec) 2)
		(not (symbol? (car spec)))
		(not (form? (cadr spec))))
	    (parse-error context
			 "condition spec not `(ifield-name rtl-code)'" spec))
	spec))
)

;; Parse a setup-semantics spec.

(define (/isa-parse-setup-semantics context spec)
  (if (not (null? spec))
      spec
      #f)
)

;; Parse an isa spec.
;; The result is the <isa> object.
;; All arguments are in raw (non-evaluated) form.

(define (/isa-parse context name comment attrs
		    base-insn-bitsize default-insn-bitsize default-insn-word-bitsize
		    decode-assist liw-insns parallel-insns condition
		    setup-semantics decode-splits)
  (logit 2 "Processing isa " name " ...\n")

  ;; Pick out name first to augment the error context.
  (let* ((name (parse-name context name))
	 (context (context-append-name context name)))

    (if (not (memq name (current-arch-isa-name-list)))
	(parse-error context "isa name is not present in `define-arch'" name))

    ;; Isa's are always kept - we need them to validate later uses, even if
    ;; the then resulting object won't be kept.  All isas are also needed to
    ;; compute a proper value for the isas-cache member of <hardware-base>
    ;; for builtin objects.
    (make <isa>
      name
      (parse-comment context comment)
      (atlist-parse context attrs "isa")
      (parse-number (context-append context
				    ": default-insn-word-bitsize")
		    default-insn-word-bitsize '(8 . 128))
      (parse-number (context-append context
				    ": default-insn-bitsize")
		    default-insn-bitsize '(8 . 128))
      (parse-number (context-append context
				    ": base-insn-bitsize")
		    base-insn-bitsize '(8 . 128))
      (/isa-parse-decode-assist (context-append context
						": decode-assist")
				decode-assist)
      liw-insns
      parallel-insns
      (/isa-parse-condition context condition)
      (/isa-parse-setup-semantics context setup-semantics)
      (/isa-parse-decode-splits context decode-splits)
      ))
)

;; Read an isa entry.
;; ARG-LIST is an associative list of field name and field value.

(define (/isa-read context . arg-list)
  (let (
	(name #f)
	(attrs nil)
	(comment "")
	(base-insn-bitsize #f)
	(default-insn-bitsize #f)
	(default-insn-word-bitsize #f)
	(decode-assist nil)
	(liw-insns 1)
	;; FIXME: Hobbit computes the wrong symbol for `parallel-insns'
	;; in the `case' expression below because there is a local var
	;; of the same name ("__1" gets appended to the symbol name).
	(parallel-insns- 1)
	(condition nil)
	(setup-semantics nil)
	(decode-splits nil)
	)

    (let loop ((arg-list arg-list))
      (if (null? arg-list)
	  nil
	  (let ((arg (car arg-list))
		(elm-name (caar arg-list)))
	    (case elm-name
	      ((name) (set! name (cadr arg)))
	      ((comment) (set! comment (cadr arg)))
	      ((attrs) (set! attrs (cdr arg)))
	      ((default-insn-word-bitsize)
	       (set! default-insn-word-bitsize (cadr arg)))
	      ((default-insn-bitsize) (set! default-insn-bitsize (cadr arg)))
	      ((base-insn-bitsize) (set! base-insn-bitsize (cadr arg)))
	      ((decode-assist) (set! decode-assist (cadr arg)))
	      ((liw-insns) (set! liw-insns (cadr arg)))
	      ((parallel-insns) (set! parallel-insns- (cadr arg)))
	      ((condition) (set! condition (cdr arg)))
	      ((setup-semantics) (set! setup-semantics (cadr arg)))
	      ((decode-splits) (set! decode-splits (cdr arg)))
	      ((insn-types) #t) ;; ignore for now
	      ((frame) #t) ;; ignore for now
	      (else (parse-error context "invalid isa arg" arg)))
	    (loop (cdr arg-list)))))

    ;; Now that we've identified the elements, build the object.
    (/isa-parse context name comment attrs
		base-insn-bitsize
		(if default-insn-word-bitsize
		    default-insn-word-bitsize
		    base-insn-bitsize)
		(if default-insn-bitsize
		    default-insn-bitsize
		    base-insn-bitsize)
		decode-assist liw-insns parallel-insns- condition
		setup-semantics decode-splits))
)

;; Define a <isa> object, name/value pair list version.

(define define-isa
  (lambda arg-list
    (let ((i (apply /isa-read (cons (make-current-context "define-isa")
				    arg-list))))
      (if i
	  (current-isa-add! i))
      i))
)

;; Subroutine of modify-isa to process one add-decode-split spec.

(define (/isa-add-decode-split! context isa spec)
  (let ((decode-split (/isa-parse-decode-split context spec)))
    (isa-set-decode-splits! (cons decode-split (isa-decode-splits isa)))
    *UNSPECIFIED*)
)

;; Main routine for modifying existing isa definitions

(define modify-isa
  (lambda arg-list
    (let ((context (make-current-context "modify-isa"))
	  (isa-spec (assq 'name arg-list)))
      (if (not isa-spec)
	  (parse-error context "isa name not specified"))

      (let ((isa (current-isa-lookup (arg-list-symbol-arg context isa-spec))))
	(if (not isa)
	    (parse-error context "undefined isa" isa-spec))

	(let loop ((args arg-list))
	  (if (null? args)
	      #f ;; done
	      (let ((arg-spec (car args)))
		(case (car arg-spec)
		  ((name) #f) ;; ignore, already processed
		  ((add-decode-split)
		   (/isa-add-decode-split! context isa (cdr arg-spec)))
		  (else
		   (parse-error context "invalid/unsupported option" (car arg-spec))))
		(loop (cdr args)))))))

    *UNSPECIFIED*)
)

;; Return boolean indicating if ISA supports parallel execution.

(define (isa-parallel-exec? isa) (> (isa-parallel-insns isa) 1))

;; Return a boolean indicating if ISA supports conditional execution
;; of all instructions.

(define (isa-conditional-exec? isa) (->bool (isa-condition isa)))

;; The `<cpu>' object collects together various details about a particular
;; subset of the architecture (e.g. perhaps all 32 bit variants of the sparc
;; architecture).
;; This is called a "cpu-family".
;; ??? May be renamed to <family> (both internally and in the .cpu file).
;; ??? Another way to do this would be to discard the family notion and allow
;; machs to inherit from other machs, as well as use isas to distinguish
;; sufficiently dissimilar machs.  This would remove a fuzzy illspecified
;; notion with a concrete one.
;; ??? Maybe a better way to organize sparc32 vs sparc64 is via an isa.

(define <cpu>
  (class-make '<cpu>
	      '(<ident>)
	      '(
		;; one of big/little/either/#f.
		;; If #f, then {insn,data,float}-endian are used.
		;; Otherwise they're ignored.
		endian

		;; one of big/little/either.
		insn-endian

		;; one of big/little/either/big-words/little-words.
		;; If big-words then each word is little-endian.
		;; If little-words then each word is big-endian.
		data-endian

		;; one of big/little/either/big-words/little-words.
		float-endian

		;; number of bits in a word.
		word-bitsize

		;; number of bits in a chunk of an instruction word, for
		;; endianness conversion purposes; 0 = no chunking
		insn-chunk-bitsize

		;; Transformation to use in generated files should one be
		;; needed.  At present the only supported value is a string
		;; which is the file suffix.
		;; ??? A dubious element of the description language, but given
		;; the quantity of generated files, some machine generated
		;; headers may need to #include other machine generated headers
		;; (e.g. cpuall.h).
		file-transform

		;; Allow a cpu family to override the isa parallel-insns spec.
		;; ??? Concession to the m32r port which can go away, in time.
		parallel-insns

		;; Computed: maximum number of insns which may pass before there
		;; an insn writes back its output operands.
		max-delay

		)
	      nil)
)

;; Accessors.

(define-getters <cpu> cpu (word-bitsize insn-chunk-bitsize file-transform parallel-insns max-delay))
(define-setters <cpu> cpu (max-delay))

;; Return endianness of instructions.

(define (cpu-insn-endian cpu)
  (let ((endian (elm-xget cpu 'endian)))
    (if endian
	endian
	(elm-xget cpu 'insn-endian)))
)

;; Return endianness of data.

(define (cpu-data-endian cpu)
  (let ((endian (elm-xget cpu 'endian)))
    (if endian
	endian
	(elm-xget cpu 'data-endian)))
)

;; Return endianness of floats.

(define (cpu-float-endian cpu)
  (let ((endian (elm-xget cpu 'endian)))
    (if endian
	endian
	(elm-xget cpu 'float-endian)))
)

;; Parse a cpu family description
;; This is the main routine for building a <cpu> object from a cpu
;; description in the .cpu file.
;; All arguments are in raw (non-evaluated) form.

(define (/cpu-parse context name comment attrs
		    endian insn-endian data-endian float-endian
		    word-bitsize insn-chunk-bitsize file-transform parallel-insns)
  (logit 2 "Processing cpu family " name " ...\n")

  ;; Pick out name first to augment the error context.
  (let* ((name (parse-name context name))
	 (context (context-append-name context name)))

    (if (keep-cpu? name)
	(make <cpu>
	      name
	      (parse-comment context comment)
	      (atlist-parse context attrs "cpu")
	      endian insn-endian data-endian float-endian
	      word-bitsize
	      insn-chunk-bitsize
	      file-transform
	      parallel-insns
	      0 ;; default max-delay. will compute correct value
	      )
	(begin
	  (logit 2 "Ignoring " name ".\n")
	  #f))) ;; cpu is not to be kept
)

;; Read a cpu family description
;; This is the main routine for analyzing a cpu description in the .cpu file.
;; CONTEXT is a <context> object for error messages.
;; ARG-LIST is an associative list of field name and field value.
;; /cpu-parse is invoked to create the <cpu> object.

(define (/cpu-read context . arg-list)
  (let (
	(name nil)
	(comment nil)
	(attrs nil)
	(endian #f)
	(insn-endian #f)
	(data-endian #f)
	(float-endian #f)
	(word-bitsize #f)
	(insn-chunk-bitsize 0)
	(file-transform "")
	;; FIXME: Hobbit computes the wrong symbol for `parallel-insns'
	;; in the `case' expression below because there is a local var
	;; of the same name ("__1" gets appended to the symbol name).
	(parallel-insns- #f)
	)

    ;; Loop over each element in ARG-LIST, recording what's found.
    (let loop ((arg-list arg-list))
      (if (null? arg-list)
	  nil
	  (let ((arg (car arg-list))
		(elm-name (caar arg-list)))
	    (case elm-name
	      ((name) (set! name (cadr arg)))
	      ((comment) (set! comment (cadr arg)))
	      ((attrs) (set! attrs (cdr arg)))
	      ((endian) (set! endian (cadr arg)))
	      ((insn-endian) (set! insn-endian (cadr arg)))
	      ((data-endian) (set! data-endian (cadr arg)))
	      ((float-endian) (set! float-endian (cadr arg)))
	      ((word-bitsize) (set! word-bitsize (cadr arg)))
	      ((insn-chunk-bitsize) (set! insn-chunk-bitsize (cadr arg)))
	      ((file-transform) (set! file-transform (cadr arg)))
	      ((parallel-insns) (set! parallel-insns- (cadr arg)))
	      (else (parse-error context "invalid cpu arg" arg)))
	    (loop (cdr arg-list)))))

    ;; Now that we've identified the elements, build the object.
    (/cpu-parse context name comment attrs
		endian insn-endian data-endian float-endian
		word-bitsize insn-chunk-bitsize file-transform parallel-insns-))
)

;; Define a cpu family object, name/value pair list version.

(define define-cpu
  (lambda arg-list
    (let ((c (apply /cpu-read (cons (make-current-context "define-cpu")
				    arg-list))))
      (if c
	  (begin
	    (current-cpu-add! c)
	    (mode-set-word-modes! (cpu-word-bitsize c))
	    (hw-update-word-modes!)
	    ))
      c))
)

;; The `<mach>' object describes one member of a `cpu' family.

(define <mach>
  (class-make '<mach> '(<ident>)
	      '(
		;; cpu family this mach is a member of
		cpu
		;; bfd name of mach
		bfd-name
		;; list of <isa> objects
		isas
		)
	      nil)
)

;; Accessors.

(define-getters <mach> mach (cpu bfd-name isas))

(define (mach-enum obj)
  (string-append "MACH_" (string-upcase (gen-sym obj)))
)

(define (mach-number obj) (mach-enum obj))

(define (machs-for-cpu cpu)
  (let ((cpu-name (obj:name cpu)))
    (find (lambda (mach)
	    (eq? (obj:name (mach-cpu mach)) cpu-name))
	  (current-mach-list)))
)

;; Parse a machine entry.
;; The result is a <mach> object or #f if the mach isn't to be kept.
;; All arguments are in raw (non-evaluated) form.

(define (/mach-parse context name comment attrs cpu bfd-name isas)
  (logit 2 "Processing mach " name " ...\n")

  ;; Pick out name first to augment the error context.
  (let* ((name (parse-name context name))
	 (context (context-append-name context name)))

    (if (not (list? isas))
	(parse-error context "isa spec not a list" isas))
    (let ((cpu-obj (current-cpu-lookup cpu))
	  (isa-list (map current-isa-lookup isas)))
      (if (not (memq name (current-arch-mach-name-list)))
	  (parse-error context "mach name is not present in `define-arch'" name))
      (if (null? cpu)
	  (parse-error context "missing cpu spec" cpu))
      (if (not cpu-obj)
	  (parse-error context "unknown cpu" cpu))
      (if (null? isas)
	  (parse-error context "missing isas spec" isas))
      (if (not (all-true? isa-list))
	  (parse-error context "unknown isa in" isas))
      (if (not (string? bfd-name))
	  (parse-error context "bfd-name not a string" bfd-name))

      (if (keep-mach? (list name))

	  (make <mach>
		name
		(parse-comment context comment)
		(atlist-parse context attrs "mach")
		cpu-obj
		bfd-name
		isa-list)

	  (begin
	    (logit 2 "Ignoring " name ".\n")
	    #f)))) ;; mach is not to be kept
)

;; Read a mach entry.
;; CONTEXT is a <context> object for error messages.
;; ARG-LIST is an associative list of field name and field value.

(define (/mach-read context . arg-list)
  (let (
	(name nil)
	(attrs nil)
	(comment nil)
	(cpu nil)
	(bfd-name #f)
	(isas #f)
	)

    (let loop ((arg-list arg-list))
      (if (null? arg-list)
	  nil
	  (let ((arg (car arg-list))
		(elm-name (caar arg-list)))
	    (case elm-name
	      ((name) (set! name (cadr arg)))
	      ((comment) (set! comment (cadr arg)))
	      ((attrs) (set! attrs (cdr arg)))
	      ((cpu) (set! cpu (cadr arg)))
	      ((bfd-name) (set! bfd-name (cadr arg)))
	      ((isas) (set! isas (cdr arg)))
	      (else (parse-error context "invalid mach arg" arg)))
	    (loop (cdr arg-list)))))

    ;; Now that we've identified the elements, build the object.
    (/mach-parse context name comment attrs cpu
		 ;; Default bfd-name is same as object's name.
		 (if bfd-name bfd-name (symbol->string name))
		 ;; Default isa is the first one.
		 (if isas isas (list (obj:name (car (current-isa-list)))))))
)

;; Define a <mach> object, name/value pair list version.

(define define-mach
  (lambda arg-list
    (let ((m (apply /mach-read (cons (make-current-context "define-mach")
				     arg-list))))
      (if m
	  (current-mach-add! m))
      m))
)

;; Miscellaneous state derived from the input data.
;; FIXME: being redone

;; Size of a word in bits.
;; All selected cpu families must have same value or error.
;; Ergo, don't use this if multiple word-bitsize values are expected.
;; E.g. opcodes support for architectures with both 32 and 64 variants.

(define (state-word-bitsize)
  (let* ((wb-list (map cpu-word-bitsize (current-cpu-list)))
	 (result (car wb-list)))
    (for-each (lambda (wb)
		(if (!= result wb)
		    (error "multiple word-bitsize values" wb-list)))
	      wb-list)
    result)
)

;; Return maximum word bitsize.

(define (state-max-word-bitsize)
  (apply max (map cpu-word-bitsize (current-cpu-list)))
)

;; Size of normal instruction.
;; All selected isas must have same value or error.

(define (state-default-insn-bitsize)
  (let ((dib (map isa-default-insn-bitsize (current-isa-list))))
    ;; FIXME: ensure all have same value.
    (car dib))
)

;; Number of bytes of insn we can initially fetch.
;; All selected isas must have same value or error.

(define (state-base-insn-bitsize)
  (let ((bib (map isa-base-insn-bitsize (current-isa-list))))
    ;; FIXME: ensure all have same value.
    (car bib))
)

;; Return parallel-insns spec.

(define (state-parallel-insns)
  ;; Assert only one cpu family has been selected.
  (assert-keep-one)

  (let ((par-insns (map isa-parallel-insns (current-isa-list)))
	(cpu-par-insns (cpu-parallel-insns (current-cpu))))
    ;; ??? The m32r does have parallel execution, but to keep support for the
    ;; base mach simpler, a cpu family is allowed to override the isa spec.
    (or cpu-par-insns
	;; FIXME: ensure all have same value.
	(car par-insns)))
)

;; Return boolean indicating if parallel execution support is required.

(define (state-parallel-exec?)
  (> (state-parallel-insns) 1)
)

;; Return liw-insns spec.

(define (state-liw-insns)
  (let ((liw-insns (map isa-liw-insns (current-isa-list))))
    ;; FIXME: ensure all have same value.
    (car liw-insns))
)

;; Return decode-assist spec.

(define (state-decode-assist)
  (isa-decode-assist (current-isa))
)

;; Return boolean indicating if current isa conditionally executes all insn.

(define (state-conditional-exec?)
  (isa-conditional-exec? (current-isa))
)

;; Architecture or cpu wide values derived from other data.

(define <derived-arch-data>
  (class-make '<derived-arch-data>
	      nil
	      '(
		;; whether all insns can be recorded in a host int
		integral-insn?

		;; whether a large int is needed for insns
		large-insn-word?
		)
	      nil)
)

;; Called after the .cpu file has been read in to prime derived value
;; computation.
;; Often this data isn't needed so we only computed it if we have to.
;; The computation can require a single selected ISA; if we don't require
;; the data don't unnecessarily flag an error.

(define (/adata-set-derived! arch)
  ;; Don't compute this data unless we need to.
  (arch-set-derived!
   arch
   (make <derived-arch-data>
     ;; integral-insn?
     (delay (isa-integral-insn? (current-isa)))
     ;; insn-word-bitsize
     (> (apply max (map isa-base-insn-bitsize (current-isa-list))) 32)
     ))
)

;; Accessors.

(define (adata-integral-insn? arch)
  (force (elm-xget (arch-derived arch) 'integral-insn?))
)

(define (adata-large-insn-word? arch)
  (elm-xget (arch-derived arch) 'large-insn-word?)
)

;; Instruction analysis control.

;; The maximum number of virtual insns.
;; They can be recorded with negative ordinals, and multi-insns are currently
;; also recorded as negative numbers, so leave enough space.
(define MAX-VIRTUAL-INSNS 100)

;; Subroutine of arch-analyze-insns! to simplify it.
;; Sanity check the instruction set.

(define (/sanity-check-insns arch)
  (let ((insn-list (arch-insn-list arch)))

    ;; Ensure instruction base values agree with their masks.
    ;; Errors can come from bad .cpu files, bugs, or both.
    ;; It's better to catch such errors early.
    ;; If it is an error in the .cpu file, we don't want to crash
    ;; on a Guile error.

    (for-each

     (lambda (insn)

       (let ((base-len (insn-base-mask-length insn))
	     (base-mask (insn-base-mask insn))
	     (base-value (insn-base-value insn)))
	 (if (not (= (cg-logand (cg-logxor base-mask (mask base-len))
				base-value)
		     0))
	     (context-owner-error
	      #f insn
	      "While performing sanity checks"
	      (string-append "Instruction has opcode bits outside of its mask.\n"
			     "This usually means some kind of error in the instruction's ifield list.\n"
			     "base mask: 0x" (number->hex base-mask)
			     ", base value: 0x" (number->hex base-value)
			     "\nfield list:"
			     (string-map (lambda (f)
					   (string-append " "
							  (ifld-pretty-print f)))
					 (insn-iflds insn))
			     )))

	 ;; Insert more checks here.

	 ))

     (non-multi-insns (non-alias-insns insn-list))))

  *UNSPECIFIED*
)

;; Instantiate the multi-insns of ARCH (if there are any).

(define (/instantiate-multi-insns! arch)
  ;; Skip if already done, we don't want to create duplicates.

  (if (not (arch-multi-insns-instantiated? arch))
      (begin

	(if (any-true? (map multi-insn? (arch-insn-list arch)))

	    (begin
	      ;; Instantiate sub-insns of all multi-insns.
	      (logit 1 "Instantiating multi-insns ...\n")

	      ;; FIXME: Hack to remove differences in generated code when we
	      ;; switched to recording insns in hash tables.
	      ;; Multi-insn got instantiated after the list of insns had been
	      ;; reversed and they got added to the front of the list, in
	      ;; reverse order.  Blech!
	      ;; Eventually remove this, have a flag day, and check in the
	      ;; updated files.
	      ;; NOTE: This causes major diffs to opcodes/m32c-*.[ch].
	      (let ((orig-ord (arch-next-ordinal arch)))
		(arch-set-next-ordinal! arch (- MAX-VIRTUAL-INSNS))
		(for-each (lambda (insn)
			    (multi-insn-instantiate! insn))
			  (multi-insns (arch-insn-list arch)))
		(arch-set-next-ordinal! arch orig-ord))

	      (logit 1 "Done instantiating multi-insns.\n")
	      ))

	(arch-set-multi-insns-instantiated?! arch #t)
	))
)

;; Subroutine of arch-analyze-insns! to simplify it.
;; Canonicalize INSNS of ARCH.

(define (/canonicalize-insns! arch insn-list)
  (logit 1 "Canonicalizing instruction semantics ...\n")

  (for-each (lambda (insn)
	      (cond ((insn-canonical-semantics insn)
		     #t) ;; already done
		    ((insn-semantics insn)
		     (logit 2 "Canonicalizing semantics for " (obj:name insn) " ...\n")
		     (let ((canon-sem
			    (rtx-canonicalize
			     (make-obj-context insn
					       (string-append "canonicalizing semantics of "
							      (obj:str-name insn)))
			     'VOID (obj-isa-list insn) nil
			     (insn-semantics insn))))
		       (insn-set-canonical-semantics! insn canon-sem)))
		    (else
		     (logit 2 "Skipping instruction " (obj:name insn) ", no semantics ...\n"))))
	    insn-list)

  (logit 1 "Done canonicalization.\n")
)

;; Analyze the instruction set.
;; The name is explicitly vague because it's intended that all insn analysis
;; would be controlled here.
;; If the instruction set has already been sufficiently analyzed, do nothing.
;; INCLUDE-ALIASES? is #t if alias insns are to be included.
;; ANALYZE-SEMANTICS? is #t if insn semantics are to be analyzed.
;;
;; This is a very expensive operation, so we only do it as necessary.
;; There are (currently) two different kinds of users: assemblers and
;; simulators.  Assembler style apps don't always need to analyze the semantics.
;; Simulator style apps don't want to include the alias insns.

(define (arch-analyze-insns! arch include-aliases? analyze-semantics?)
  ;; Catch apps that haven't set word sizes yet.
  (mode-ensure-word-sizes-defined)

  (if (or (not (arch-insns-analyzed? arch))
	  (not (eq? analyze-semantics? (arch-semantics-analyzed? arch)))
	  (not (eq? include-aliases? (arch-aliases-analyzed? arch))))

      (begin

	(/instantiate-multi-insns! arch)

	(let ((insn-list (non-multi-insns
			  (if include-aliases?
			      (arch-insn-list arch)
			      (non-alias-insns (arch-insn-list arch))))))

	  ;; Compile each insns semantics, traversers/evaluators require it.
	  (/canonicalize-insns! arch insn-list)

	  ;; This is expensive so indicate start/finish.
	  (logit 1 "Analyzing instruction set ...\n")

	  (let ((fmt-lists
		 (ifmt-compute! insn-list
				analyze-semantics?)))

	    (arch-set-ifmt-list! arch (car fmt-lists))
	    (arch-set-sfmt-list! arch (cadr fmt-lists))
	    (arch-set-insns-analyzed?! arch #t)
	    (arch-set-semantics-analyzed?! arch analyze-semantics?)
	    (arch-set-aliases-analyzed?! arch include-aliases?)

	    ;; Now that the instruction formats are computed,
	    ;; do some sanity checks.
	    (logit 1 "Performing sanity checks ...\n")
	    (/sanity-check-insns arch)

	    (logit 1 "Done analysis.\n")
	    ))
	))

  *UNSPECIFIED*
)

;; Called before a .cpu file is read in.

(define (arch-init!)

  (reader-add-command! 'define-arch
		       "\
Define an architecture, name/value pair list version.
"
		       nil 'arg-list define-arch)

  (reader-add-command! 'define-isa
		       "\
Define an instruction set architecture, name/value pair list version.
"
		       nil 'arg-list define-isa)
  (reader-add-command! 'modify-isa
		       "\
Modify an isa, name/value pair list version.
"
		       nil 'arg-list modify-isa)

  (reader-add-command! 'define-cpu
		       "\
Define a cpu family, name/value pair list version.
"
		       nil 'arg-list define-cpu)

  *UNSPECIFIED*
)

;; Called before a .cpu file is read in.

(define (mach-init!)
  (let ((arch CURRENT-ARCH))
    (arch-set-ifld-table! arch (/make-ident-object-table 127))
    (arch-set-op-table! arch (/make-ident-object-table 127))
    (arch-set-insn-table! arch (/make-ident-object-table 509))
    (arch-set-minsn-table! arch (/make-ident-object-table 127))
    )

  (reader-add-command! 'define-mach
		       "\
Define a machine, name/value pair list version.
"
		       nil 'arg-list define-mach)

  *UNSPECIFIED*
)

;; Called after .cpu file is read in.

(define (arch-finish!)
  (let ((arch CURRENT-ARCH))

    ;; Lists are constructed in the reverse order they appear in the file
    ;; [for simplicity and efficiency].  Restore them to file order for the
    ;; human reader/debugger.
    ;; We don't need to do this for ifld, op, insn, minsn lists because
    ;; they are handled differently.
    (arch-set-enum-list! arch (reverse (arch-enum-list arch)))
    (arch-set-kw-list! arch (reverse (arch-kw-list arch)))
    (arch-set-isa-list! arch (reverse (arch-isa-list arch)))
    (arch-set-cpu-list! arch (reverse (arch-cpu-list arch)))
    (arch-set-mach-list! arch (reverse (arch-mach-list arch)))
    (arch-set-model-list! arch (reverse (arch-model-list arch)))
    (arch-set-hw-list! arch (reverse (arch-hw-list arch)))
    (arch-set-subr-list! arch (reverse (arch-subr-list arch)))
    )

  *UNSPECIFIED*
)

;; Called after .cpu file is read in.

(define (mach-finish!)
  (/adata-set-derived! CURRENT-ARCH)

  *UNSPECIFIED*
)
@


1.27
log
@tweak comment
@
text
@d2 1
a2 1
;; Copyright (C) 2000, 2003, 2009 Red Hat, Inc.
@


1.26
log
@	* mach.scm: Follow commenting convention.
@
text
@d813 1
a813 1
      ;; attributes MACH and ISA exist.
@


1.25
log
@	* mach.scm (<derived-arch-data>): New member large-insn-word?.
	(/adata-set-derived!): Set it.
	(adata-large-insn-word?): New function.
	* sim-arch.scm (/gen-cpuall-includes): Don't #include cgen-engine.h
	here.
	* sim-cpu.scm (cgen-cpu.h): #include it here.
	(/gen-cpu-defines): Define CGEN_INSN_WORD.
	(/gen-no-scache-semantic-fn): Use CGEN_INSN_WORD instead of
	CGEN_INSN_INT.
	* sim-decode.scm (/gen-idesc-decls): Ditto.
	(/gen-extract-case, /gen-decode-fn): Ditto.
	* sim-model.scm (/gen-model-insn-fn): Ditto.
	* sim.scm (gen-argbuf-type): Ditto.
@
text
@d1 8
a8 8
; CPU architecture description.
; Copyright (C) 2000, 2003, 2009 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.

; Top level class that records everything about a cpu.
; FIXME: Rename this to something else and rename <arch-data> to <arch>
; for consistency with other classes (define-foo -> <foo> object).
d14 1
a14 1
		; An object of type <arch-data>.
d34 2
a35 2
		(insn-extract . #f) ; FIXME: wip (and move elsewhere)
		(insn-execute . #f) ; FIXME: wip (and move elsewhere)
d37 1
a37 1
		; standard values derived from the input data
d40 1
a40 1
		; #t if multi-insns have been instantiated
d42 1
a42 1
		; #t if instructions have been analyzed
d44 1
a44 1
		; #t if semantics were included in the analysis
d46 1
a46 1
		; #t if alias insns were included in the analysis
d49 1
a49 1
		; ordinal of next object that needs one
d55 3
a57 3
; Accessors.
; Each getter is arch-foo.
; Each setter is arch-set-foo!.
d85 2
a86 2
; For elements recorded as a table, return a sorted list.
; ??? All elements should really be assumed to be a black-box table.
d202 3
a204 3
; Class for recording things specified in `define-arch'.
; This simplifies define-arch as the global arch object CURRENT-ARCH
; must exist before loading the .cpu file.
d210 2
a211 2
		; Default alignment of memory operations.
		; One of aligned, unaligned, forced.
d214 1
a214 1
		; Orientation of insn bit numbering (#f->msb=0, #t->lsb=0).
d217 4
a220 4
		; List of all machs.
		; Each element is pair of (mach-name . sanitize-key)
		; where sanitize-key is #f if there is none.
		; blah blah blah ... ooohhh, evil sanitize key, blah blah blah
d223 5
a227 5
		; List of all isas (instruction set architecture).
		; Each element is a pair of (isa-name . sanitize-key)
		; where sanitize-key is #f if there is none.
		; There is usually just one.  ARM has two (arm, thumb).
		; blah blah blah ... ooohhh, evil sanitize key, blah blah blah
d230 1
a230 1
		; ??? Defaults for other things should be here.
d239 4
a242 4
; Add, list, lookup accessors for <arch>.
;
; For the lookup routines, the result is the object or #f if not found.
; For some, if X is already an object, return that.
d264 5
a268 5
; Attributes.
; Recorded as a pair of lists.
; The car is a list of <attribute> objects.
; The cdr is an associative list of (name . <attribute>) elements, for lookup.
; Could use a hash table except that there currently aren't that many.
d273 3
a275 3
  ; NOTE: While putting this test in define-attr feels better, having it here
  ; is more robust, internal calls get checked too.  Thus it's here.
  ; Ditto for all the other such tests in this file.
d280 2
a281 2
    ; Build list in normal order so we don't have to reverse it at the end
    ; (since our format is non-trivial).
d296 1
a296 1
; Enums.
d312 1
a312 1
; Keywords.
d328 1
a328 1
; Instruction sets.
d358 1
a358 1
; Cpu families.
d374 1
a374 1
; Machines.
d390 1
a390 1
; Models.
d423 2
a424 2
      ; This doesn't use object-assq on purpose.  Hardware objects handle
      ; get-name specially.
d473 3
a475 3
; Return a boolean indicating if <ifield> F is currently defined.
; This is slightly complicated because multiple isas can have different
; ifields with the same name.
d480 2
a481 2
    ; We've got all the ifields with the same name,
    ; now see if any have the same ISA as F.
d532 3
a534 3
; Return a boolean indicating if <operand> OP is currently defined.
; This is slightly complicated because multiple isas can have different
; operands with the same name.
d539 2
a540 2
    ; We've got all the operands with the same name,
    ; now see if any have the same ISA as OP.
d552 1
a552 1
; Instruction field formats.
d556 2
a557 2
; Semantic formats (akin to ifmt's, except includes semantics to distinguish
; insns).
d597 3
a599 3
; Return a boolean indicating if <insn> INSN is currently defined.
; This is slightly complicated because multiple isas can have different
; insns with the same name.
d604 2
a605 2
    ; We've got all the insns with the same name,
    ; now see if any have the same ISA as INSN.
d653 3
a655 3
; Return a boolean indicating if <macro-insn> MINSN is currently defined.
; This is slightly complicated because multiple isas can have different
; macro-insns with the same name.
d660 2
a661 2
    ; We've got all the macro-insns with the same name,
    ; now see if any have the same ISA as M.
d673 1
a673 1
; rtx subroutines.
d690 1
a690 1
; Arch parsing support.
d692 1
a692 1
; Parse an alignment spec.
d700 3
a702 3
; Parse an arch mach spec.
; The value is a list of mach names or (mach-name sanitize-key) elements.
; The result is a list of (mach-name . sanitize-key) elements.
d709 1
a709 1
		  #t ; ok
d719 3
a721 3
; Parse an arch isa spec.
; The value is a list of isa names or (isa-name sanitize-key) elements.
; The result is a list of (isa-name . sanitize-key) elements.
d728 1
a728 1
		  #t ; ok
d738 4
a741 4
; Parse an architecture description
; This is the main routine for building an arch object from a cpu
; description in the .cpu file.
; All arguments are in raw (non-evaluated) form.
d757 4
a760 4
; Read an architecture description.
; This is the main routine for analyzing an arch description in the .cpu file.
; ARG-LIST is an associative list of field name and field value.
; parse-arch is invoked to create the `arch' object.
d765 1
a765 1
	  ; <arch-data> object members and default values
d774 1
a774 1
      ; Loop over each element in ARG-LIST, recording what's found.
d790 1
a790 1
      ; Ensure required fields are present.
d795 1
a795 1
      ; Now that we've identified the elements, build the object.
d802 1
a802 1
; Define an arch object, name/value pair list version.
d812 2
a813 2
      ; Install the builtin objects now that we have an arch, and now that
      ; attributes MACH and ISA exist.
d818 1
a818 1
; Mach/isa processing.
d820 2
a821 2
; Create the MACH attribute.
; MACHS is the canonicalized machs spec to define-arch: (name . sanitize-key).
d842 4
a845 4
; Return #t if MACH is supported by OBJ.
; This is done by looking for the MACH attribute in OBJ.
; By definition, objects that support the default (base) mach support
; all machs.
d852 2
a853 2
	;(let ((deflt (attr-lookup-default 'MACH obj)))
	;  (any-true? (map (lambda (m) (memq m deflt)) machs)))))
d856 3
a858 3
; Create the ISA attribute.
; ISAS is the canonicalized isas spec to define-arch: (name . sanitize-key).
; ISAS is a list of isa names.
d872 2
a873 2
      ; If there's only one isa, don't (yet) pollute the tables with a value
      ; for it.
d884 1
a884 1
; Return the bitset attr value for all isas.
d890 2
a891 2
; Return an ISA attribute of all isas.
; This is useful for things like f-nil which exist across all isas.
d897 1
a897 1
; Return list of ISA names specified by attribute object ATLIST.
d903 1
a903 1
; Return list of ISA names specified by OBJ.
d909 2
a910 2
; Return #t if <isa> ISA is supported by OBJ.
; This is done by looking for the ISA attribute in OBJ.
d918 5
a922 5
; The fetch/decode/execute process.
; "extract" is a fancy word for fetch/decode.
; FIXME: wip, not currently used.
; FIXME: move to inside define-isa, and maybe elsewhere.
;
d924 3
a926 3
;  define-extract (code)
;  ;(arch-set-insn-extract! CURRENT-ARCH code)
;  *UNSPECIFIED*
d928 1
a928 1
;
d930 4
a933 4
;  define-execute (code)
;  ;(arch-set-insn-execute! CURRENT-ARCH code)
;  *UNSPECIFIED*
;)
d935 15
a949 15
; ISA specification.
; Each architecture is generally one isa, but in the case of ARM (and a few
; others) there is more than one.
;
; ??? "ISA" has a very well defined meaning, and our usage of it one might
; want to quibble over.  A better name would be welcome.

; Associated with an instruction set is its framing.
; This refers to how instructions are laid out at the liw level (where several
; insns are framed together and executed sequentially or in parallel).
; ??? If one defines the term "format" as being how an individual instruction
; is laid out then formatting can be thought of as being different from
; framing.  However, it's possible for a particular ISA to intertwine the two.
; Thus this will need to evolve.
; ??? Not used yet, wip.
d951 1
a951 1
(define <iframe> ; pronounced I-frame
d954 1
a954 1
		; list of <itype> objects that make up the frame
d957 1
a957 1
		; assembler syntax
d960 3
a962 3
		; list of (length value) elements that make up the format
		; Length is in bits.  Value is either a number or a $number
		; symbol refering to the insn specified in `insns'.
d965 4
a968 4
		; Initial bitnumbers to decode insns by.
		; ??? At present the rest of the decoding is determined
		; algorithmically.  May wish to give the user more control
		; [like psim].
d971 2
a972 2
		; rtl that executes instructions in `value'
		; Fields specified in `value' can be used here.
d978 1
a978 1
; Accessors.
d982 2
a983 2
; Instruction types, recorded in <iframe>.
; ??? Not used yet, wip.
d988 1
a988 1
		; length in bits, or initial part if variable length (wip)
d991 1
a991 1
		; constraint specifying which insns are included
d994 4
a997 4
		; Initial bitnumbers to decode insns by.
		; ??? At present the rest of the decoding is determined
		; algorithmically.  May wish to give the user more control
		; [like psim].
d1003 1
a1003 1
; Accessors.
d1007 7
a1013 7
; Simulator instruction decode splitting.
; FIXME: Should live in simulator specific code.  Requires class handling
; cleanup first.
;
; Instructions can be split by particular values for an ifield.
; The ARM port uses this to split insns into those that set the pc and
; those that don't.
d1018 1
a1018 1
		; Name of ifield to split on.
d1021 2
a1022 2
		; Constraint.  Only insns satifying this constraint are
		; split.  #f if no constraint.
d1025 2
a1026 2
		; List of ifield splits.
		; Each element is one of (name value) or (name (values)).
d1033 1
a1033 1
; Accessors.
d1037 7
a1043 7
; Parse a decode-split spec.
; SPEC is (ifield-name constraint value-list).
; CONSTRAINT is an rtl expression.  Only insns satifying the constraint
; are split.
; Each element of VALUE-LIST is one of (name value) or (name (values)).
; FIXME: All possible values must be specified.  Need an `else' clause.
; Ranges would also be useful.
d1053 1
a1053 1
    ; FIXME: more error checking.
d1061 1
a1061 1
; Parse a list of decode-split specs.
d1069 1
a1069 1
; Top level class to describe an isa.
d1074 2
a1075 2
		; Default length to record in ifields.
		; This is used in calculations involving bit numbers.
d1078 2
a1079 2
		; Length of an unknown instruction.  Used by disassembly
		; and by the simulator's invalid insn handler.
d1082 4
a1085 4
		; Number of bytes of insn that can be initially fetched.
		; In non-LIW isas this would be the length of the smallest
		; insn.  For LIW isas it depends - only one LIW isa is
		; currently supported (m32r).
d1088 4
a1091 4
		; Initial bitnumbers to decode insns by.
		; ??? At present the rest of the decoding is determined
		; algorithmically.  May wish to give the user more control
		; [like psim].
d1094 2
a1095 2
		; Number of instructions that can be fetched at a time
		; [e.g. 2 on m32r].
d1098 3
a1100 3
		; Maximum number of instructions the cpu can execute in
		; parallel.
		; FIXME: Rename to max-parallel-insns.
d1103 1
a1103 1
		; List of <iframe> objects.
d1106 4
a1109 4
		; Condition tested before execution of any instruction or
		; #f if there is none.  For architectures like ARM, ARC.
		; If specified it is a pair of
		; (condition-field-name . rtl-for-condition)
d1112 11
a1122 11
		; Code to execute after CONDITION and prior to SEMANTICS.
		; This is rtl in source form or #f if there is none.
		; This is generally unused.  It is used on the ARM to set
		; R15 to the correct value.
		; The reason it's not specified with SEMANTICS is that it is
		; believed some applications won't need/want this.
		; ??? It is a bit of a hack though, as it is used to aid
		; implementation of apps (e.g. simulator).  Arguably something
		; that doesn't belong here.  Maybe as more architectures are
		; ported that have the PC as a general register, a better way
		; to do this will arise.
d1125 2
a1126 2
		; list of simulator instruction splits
		; FIXME: should live in simulator file (needs class cleanup).
d1129 1
a1129 1
		; ??? More may need to migrate here.
d1134 1
a1134 1
; Accessors.
d1148 1
a1148 1
; Return minimum/maximum size in bits of all insns in the isa.
d1151 2
a1152 2
  ; add `65535' in case list is nil (avoids crash)
  ; [a language with infinite precision can't have min-reduce-iota-0 :-)]
d1161 2
a1162 2
  ; add `0' in case list is nil (avoids crash)
  ; [a language with infinite precision can't have max-reduce-iota-0 :-)]
d1170 2
a1171 2
; Return a boolean indicating if instructions in ISA can be kept in a
; portable int.
d1191 3
a1193 3
; Parse an isa condition spec.
; `condition' here refers to the condition performed by architectures like
; ARM and ARC before each insn.
d1207 1
a1207 1
; Parse a setup-semantics spec.
d1215 3
a1217 3
; Parse an isa spec.
; The result is the <isa> object.
; All arguments are in raw (non-evaluated) form.
d1232 4
a1235 4
    ; Isa's are always kept - we need them to validate later uses, even if
    ; the then resulting object won't be kept.  All isas are also needed to
    ; compute a proper value for the isas-cache member of <hardware-base>
    ; for builtin objects.
d1260 2
a1261 2
; Read an isa entry.
; ARG-LIST is an associative list of field name and field value.
d1301 2
a1302 2
	      ((insn-types) #t) ; ignore for now
	      ((frame) #t) ; ignore for now
d1319 1
a1319 1
; Define a <isa> object, name/value pair list version.
d1330 1
a1330 1
; Subroutine of modify-isa to process one add-decode-split spec.
d1338 1
a1338 1
; Main routine for modifying existing isa definitions
d1353 1
a1353 1
	      #f ; done
d1356 1
a1356 1
		  ((name) #f) ; ignore, already processed
d1366 1
a1366 1
; Return boolean indicating if ISA supports parallel execution.
d1370 2
a1371 2
; Return a boolean indicating if ISA supports conditional execution
; of all instructions.
d1375 10
a1384 10
; The `<cpu>' object collects together various details about a particular
; subset of the architecture (e.g. perhaps all 32 bit variants of the sparc
; architecture).
; This is called a "cpu-family".
; ??? May be renamed to <family> (both internally and in the .cpu file).
; ??? Another way to do this would be to discard the family notion and allow
; machs to inherit from other machs, as well as use isas to distinguish
; sufficiently dissimilar machs.  This would remove a fuzzy illspecified
; notion with a concrete one.
; ??? Maybe a better way to organize sparc32 vs sparc64 is via an isa.
d1390 3
a1392 3
		; one of big/little/either/#f.
		; If #f, then {insn,data,float}-endian are used.
		; Otherwise they're ignored.
d1395 1
a1395 1
		; one of big/little/either.
d1398 3
a1400 3
		; one of big/little/either/big-words/little-words.
		; If big-words then each word is little-endian.
		; If little-words then each word is big-endian.
d1403 1
a1403 1
		; one of big/little/either/big-words/little-words.
d1406 1
a1406 1
		; number of bits in a word.
d1409 2
a1410 2
		; number of bits in a chunk of an instruction word, for
		; endianness conversion purposes; 0 = no chunking
d1413 7
a1419 7
		; Transformation to use in generated files should one be
		; needed.  At present the only supported value is a string
		; which is the file suffix.
		; ??? A dubious element of the description language, but given
		; the quantity of generated files, some machine generated
		; headers may need to #include other machine generated headers
		; (e.g. cpuall.h).
d1422 2
a1423 2
		; Allow a cpu family to override the isa parallel-insns spec.
		; ??? Concession to the m32r port which can go away, in time.
d1426 2
a1427 2
		; Computed: maximum number of insns which may pass before there
		; an insn writes back its output operands.
d1434 1
a1434 1
; Accessors.
d1439 1
a1439 1
; Return endianness of instructions.
d1448 1
a1448 1
; Return endianness of data.
d1457 1
a1457 1
; Return endianness of floats.
d1466 4
a1469 4
; Parse a cpu family description
; This is the main routine for building a <cpu> object from a cpu
; description in the .cpu file.
; All arguments are in raw (non-evaluated) form.
d1490 1
a1490 1
	      0 ; default max-delay. will compute correct value
d1494 1
a1494 1
	  #f))) ; cpu is not to be kept
d1497 5
a1501 5
; Read a cpu family description
; This is the main routine for analyzing a cpu description in the .cpu file.
; CONTEXT is a <context> object for error messages.
; ARG-LIST is an associative list of field name and field value.
; /cpu-parse is invoked to create the <cpu> object.
d1548 1
a1548 1
; Define a cpu family object, name/value pair list version.
d1563 1
a1563 1
; The `<mach>' object describes one member of a `cpu' family.
d1568 1
a1568 1
		; cpu family this mach is a member of
d1570 1
a1570 1
		; bfd name of mach
d1572 1
a1572 1
		; list of <isa> objects
d1578 1
a1578 1
; Accessors.
d1595 3
a1597 3
; Parse a machine entry.
; The result is a <mach> object or #f if the mach isn't to be kept.
; All arguments are in raw (non-evaluated) form.
d1635 1
a1635 1
	    #f)))) ; mach is not to be kept
d1638 3
a1640 3
; Read a mach entry.
; CONTEXT is a <context> object for error messages.
; ARG-LIST is an associative list of field name and field value.
d1675 1
a1675 1
; Define a <mach> object, name/value pair list version.
d1686 2
a1687 2
; Miscellaneous state derived from the input data.
; FIXME: being redone
d1689 4
a1692 4
; Size of a word in bits.
; All selected cpu families must have same value or error.
; Ergo, don't use this if multiple word-bitsize values are expected.
; E.g. opcodes support for architectures with both 32 and 64 variants.
d1704 1
a1704 1
; Return maximum word bitsize.
d1710 2
a1711 2
; Size of normal instruction.
; All selected isas must have same value or error.
d1715 1
a1715 1
    ; FIXME: ensure all have same value.
d1719 2
a1720 2
; Number of bytes of insn we can initially fetch.
; All selected isas must have same value or error.
d1724 1
a1724 1
    ; FIXME: ensure all have same value.
d1728 1
a1728 1
; Return parallel-insns spec.
d1731 1
a1731 1
  ; Assert only one cpu family has been selected.
d1736 2
a1737 2
    ; ??? The m32r does have parallel execution, but to keep support for the
    ; base mach simpler, a cpu family is allowed to override the isa spec.
d1739 1
a1739 1
	; FIXME: ensure all have same value.
d1743 1
a1743 1
; Return boolean indicating if parallel execution support is required.
d1749 1
a1749 1
; Return liw-insns spec.
d1753 1
a1753 1
    ; FIXME: ensure all have same value.
d1757 1
a1757 1
; Return decode-assist spec.
d1763 1
a1763 1
; Return boolean indicating if current isa conditionally executes all insn.
d1769 1
a1769 1
; Architecture or cpu wide values derived from other data.
d1775 1
a1775 1
		; whether all insns can be recorded in a host int
d1778 1
a1778 1
		; whether a large int is needed for insns
d1802 1
a1802 1
; Accessors.
d1812 1
a1812 1
; Instruction analysis control.
d1875 1
a1875 1
	      ; Instantiate sub-insns of all multi-insns.
d1926 11
a1936 11
; Analyze the instruction set.
; The name is explicitly vague because it's intended that all insn analysis
; would be controlled here.
; If the instruction set has already been sufficiently analyzed, do nothing.
; INCLUDE-ALIASES? is #t if alias insns are to be included.
; ANALYZE-SEMANTICS? is #t if insn semantics are to be analyzed.
;
; This is a very expensive operation, so we only do it as necessary.
; There are (currently) two different kinds of users: assemblers and
; simulators.  Assembler style apps don't always need to analyze the semantics.
; Simulator style apps don't want to include the alias insns.
d1939 1
a1939 1
  ; Catch apps that haven't set word sizes yet.
d1983 1
a1983 1
; Called before a .cpu file is read in.
d2013 1
a2013 1
; Called before a .cpu file is read in.
d2032 1
a2032 1
; Called after .cpu file is read in.
d2037 5
a2041 5
    ; Lists are constructed in the reverse order they appear in the file
    ; [for simplicity and efficiency].  Restore them to file order for the
    ; human reader/debugger.
    ; We don't need to do this for ifld, op, insn, minsn lists because
    ; they are handled differently.
d2055 1
a2055 1
; Called after .cpu file is read in.
@


1.24
log
@	Specify isa(s) when doing ifield, operand, insn lookups.
	ACU = all callers updated.
	* attr.scm (/attr-eval): Call rtx-value instead of rtx-eval-with-estate.
	* enum.scm (define-full-insn-enum): Pass isa-name-list to
	current-ifld-lookup.
	* html.scm (get-insn-properties): Pass isa-name-list to
	current-op-lookup.
	* ifield.scm (/ifld-parse-follows): New arg isas, ACU.
	* insn.scm (/parse-insn-format-symbol): New arg isa-name-list, ACU.
	(/parse-insn-format-list, /parse-insn-iformat-iflds): Ditto.
	(/parse-insn-format, syntax-break-out): Ditto.
	* mach.scm (obj-filter-by-isa): New function.
	(current-ifld-lookup): New optional arg maybe-isa-name-list.
	(/ifld-already-defined?, /op-already-defined?): Simplify.
	(current-op-lookup): New optional arg maybe-isa-name-list.
	(current-insn-lookup): New arg isa-name-list, ACU.
	(/insn-already-defined?, /minsn-already-defined?): Simplify.
	(current-minsn-lookup): New arg isa-name-list, ACU.
	* minsn.scm (/minsn-compute-iflds): Pass isa-name-list to
	current-op-lookup.
	* opc-itab.scm (compute-syntax): New arg isa-name-list, ACU.
	(gen-syntax-entry): Ditto.
	* operand.scm (/operand-parse): Pass isa-name-list to
	current-ifld-lookup.
	(/derived-parse-encoding): New arg isa-name-list, ACU.
	(/derived-parse-ifield-assertion): Ditto.
	(/derived-operand-parse): Pass isa-name-list to current-op-lookup.
	(/anyof-parse-choice): Ditto.
	(anyof-satisfies-assertions?): Pass context to rtx-solve.
	(/anyof-merge-syntax): New arg container, ACU.
	(operand-builtin!): Add pc to all isas.
	* rtl-c.scm (estate-make-for-rtl-c): Delete arg extra-vars-alist, ACU.
	(estate-make-for-rtl-c++, rtl-c-expr-parsed): Ditto.
	(rtl-c-parsed, rtl-c++-parsed): Ditto.
	(rtl-c): New arg isa-name-list, ACU.
	(rtl-c-expr, rtl-c++): Ditto.
	(closure): New arg isa-name-list, ACU.
	* rtl-traverse.scm (/make-cstate): New arg isa-name-list, ACU.
	(/cstate-isas): New function.
	(/rtx-canon-symbol-list): New function.
	(/rtx-canon-env-stack): Renamed from /rtx-canon-env, ACU.
	updated.
	(/rtx-make-canon-table): Rename ENV to ENVSTACK, new entry SYMBOLLIST.
	(/rtx-canon-rtx-operand): Pass isa list to current-op-lookup.
	(/rtx-canon-rtx-ref, /rtx-canon): Ditto.
	(rtx-canonicalize): New arg isa-name-list, ACU.
	(rtx-canonicalize-stmt): Delete.
	(tstate-make): New arg isas, ACU.
	(tstate-isas, tstate--set-isas!): New functions.
	(tstate-env-stack): Renamed from tstate-env, ACU.
	(tstate-set-env-stack!): Renamed from tstate-set-env!, ACU.
	(tstate-make-closure): Renamed from tstate-new-env, new arg
	isa-name-list, ACU.
	(/rtx-traverse-env): Delete.
	(/rtx-make-traverser-table): Rename ENV to ENVSTACK, new entry
	SUMBOLLIST.
	(/rtx-traverse): Include conditional flag in dump output.
	Update isa,envstack for closures.  Pass isa list to current-op-lookup.
	(<eval-state>): New member isas.  Rename env to env-stack.
	(<eval-state> vmake!): Handle #:isas.  #:env renamed to #:env-stack.
	(<eval-state>): New getter/setter for isas.  Rename env getter/setter
	to env-stack.
	(estate-make-for-eval): Provide #:isas.
	(estate-make-closure): Renamed from estate-new-env.  New arg
	isa-name-list, ACU.
	* rtl-xform.scm (/rtx-simplify-expr-fn): Handle closures.
	(/rtx-trim-args): ENV renamed to ENVSTACK.  Ad ITERATION, SYMBOLLIST.
	(/rtx-trim-for-doc): Handle closures.
	* rtl.scm (/rtx-valid-types): Rename ENV to ENVSTACK.  Add ITERATION,
	SYMBOLLIST.
	(rtx-env-var-list): Delete.
	(rtx-env-make): Handle already-compiled environments.
	(rtx-var-alist-to-env): New function.
	(rtx-var-alist-to-closure-env-stack, rtx-make-env-stack): New functions.
	(rtx-env-stack-dump): Renamed from rtx-env-dump, ACU.
	(rtx-operand-obj): New arg isa-name-list, ACU.
	(rtx-closure-isas, rtx-closure-env-stack, rtx-closure-expr): New
	functions.
	* rtx-funcs.scm (closure): New arg isa-name-list, reorder args, ACU.
	* sem-frags.scm (<sfrag>): Delete member compiled-semantics.
	(/frag-compute-desired-frags): Minor simplification.
	(/frag-pick-best): Ditto.
	* sid-cpu.scm (gen-semantic-code): Require canonical rtl.
	(/gen-sfrag-code): Update.
	* sim-cpu.scm (gen-semantic-code): Require canonical rtl.
	* utils-cgen.scm (sanitize): New arg isa-name-list, ACU.
	* utils.scm (non-null-intersection?): New function.
@
text
@d1777 3
d1784 5
a1788 3
; Called after the .cpu file has been read in to prime derived value
; computation.
; Often this data isn't needed so we only computed it if we have to.
d1791 1
a1791 1
  ; Don't compute this data unless we need to.
d1795 1
a1795 1
     ; integral-insn?
d1797 2
d1807 4
@


1.23
log
@	Record bitset attributes internally as a list.
	Record rtx attribute values internally as ((rtx-expr)).
	* attr.scm (bitset-attr?): Delete, unused.
	(<bitset-attribute> parse-value): Rewrite.
	(/attr-parse): Rewrite bitset default value processing.
	(/attr-read): Pick out values of scalar attributes to distinguish
	them from bitset values which are a list.
	Fix spelling errors for processing of default values.
	Handle string attributes.
	(bitset-attr->list): Delete, all callers updated.
	(/bitset-attr->charmask): Renamed from bitset-attr->charmask.
	All callers updated.
	(atlist-source-form): Rewrite.
	* hardware.scm (<hardware-base> 'get-isas): Update recognition
	of all isas.
	(hardware-builtin!): Update spec of ISA attribute, (ISA foo,bar)
	-> (ISA foo bar).
	* intrinsics.scm (target:belongs-to-group?): Update, bitset attribute
	values are now lists.
	* mach.scm (def-isa-attr!): Update, bitset attribute values,
	including the default, are now lists.
	(all-isas-attr-value): Result is now a list.
	* doc/rtl.texi: Clean up pass over attribute docs.
@
text
@d344 14
d448 3
d455 2
a456 3
;;
;; ??? This doesn't work if there are multiple operands with the same name
;; for different isas.
d458 1
a458 1
(define (current-ifld-lookup x)
d464 6
a469 6
	    (if (= (length f-list) 1)
		(car f-list)
		;; FIXME: For now just return the first one,
		;; same behaviour as before.
		;; Here "first one" means "first defined".
		(/get-lowest-ordinal f-list))
d486 1
a486 1
		      (if (not (null? (intersection f-isas (obj-isa-list ff))))
d511 7
a517 2
; ??? This doesn't work if there are multiple operands with the same name
; for different isas.
d519 1
a519 1
(define (current-op-lookup name)
d523 6
a528 5
	(if (= (length op-list) 1)
	    (car op-list)
	    ;; FIXME: For now just return the first one, same behaviour as before.
	    ;; Here "first one" means "first defined".
	    (/get-lowest-ordinal op-list))
d545 1
a545 1
		      (if (not (null? (intersection op-isas (obj-isa-list o))))
d579 15
a593 13
; ??? This doesn't work if there are multiple insns with the same name
; for different isas.

(define (current-insn-lookup name)
  (let ((i (/ident-object-table-lookup (car (arch-insn-table CURRENT-ARCH))
				       name)))
    (if i
	(begin
	  (if (= (length i) 1)
	      (car i)
	      ;; FIXME: For now just flag an error.
	      ;; Later add an isa-list arg to distinguish.
	      (error "multiple insns with name:" name)))
d610 1
a610 1
		      (if (not (null? (intersection insn-isas (obj-isa-list i))))
d635 15
a649 13
; ??? This doesn't work if there are multiple minsns with the same name
; for different isas.

(define (current-minsn-lookup name)
  (let ((m (/ident-object-table-lookup (car (arch-minsn-table CURRENT-ARCH))
				       name)))
    (if m
	(begin
	  (if (= (length m) 1)
	      (car m)
	      ;; FIXME: For now just flag an error.
	      ;; Later add an isa-list arg to distinguish.
	      (error "multiple macro-insns with name:" name)))
d666 1
a666 1
		      (if (not (null? (intersection m-isas (obj-isa-list mm))))
a869 4
    ; Using a bitset attribute here implies something could be used by two
    ; separate isas.  This seems highly unlikely but we don't [as yet]
    ; preclude it.  The other thing to consider is whether the cpu table
    ; would ever want to be opened for multiple isas.
d1905 2
a1906 1
			     'VOID (insn-semantics insn) nil)))
@


1.22
log
@add some comments noting that ifields, operands, insns, minsns
may occur multiple times with the same name in different isas
@
text
@d822 1
a822 1
  (let ((machs (bitset-attr->list (obj-attr-value obj 'MACH)))
d855 1
d865 1
a865 1
  (stringize (current-arch-isa-name-list) ",")
d878 1
a878 1
  (bitset-attr->list (atlist-attr-value atlist 'ISA #f))
d884 1
a884 1
  (bitset-attr->list (obj-attr-value obj 'ISA))
@


1.21
log
@	* xc16x.cpu (h-cr): New hardware.
	(muls): Comment out parts that won't compile, add fixme.
	(mulu, divl, divlu, jmpabs, jmpa-, jmprel, jbc, jnbs, callr): Ditto.
	(scxti, scxtmg, scxtm, bclear, bclr18, bset19, bitset, bmov): Ditto.
	(bmovn, band, bor, bxor, bcmp, bfldl, bfldh): Ditto.

	Rewrite rtl processing to require it to be "canonicalized" first,
	and write a full canonicalizer / expression checker.
	Remove all appearances of DFLT in canonical rtl.
	* attr.scm (/attr-eval atval owner): Call rtx-canonicalize,
	then rtx-simplify.
	* iformat.scm (ifmt-analyze) Use canonical semantics.
	* insn (<insn>): New member canonical-semantics.
	* mach.scm (<arch>): New member multi-insns-instantiated?.
	(/instantiate-multi-insns!): New function.
	(/canonicalize-insns!): New function.
	(arch-analyze-insns!): Canonicalize insn semantics before processing
	them.
	* mode.scm (/mode-set-word-params!): New function.
	(mode-void?): New function.
	(mode-compatible?): VOID is compatible with VOID.
	(/mode-word-sizes-defined?): New global.
	(mode-set-word-modes!): Use/set it.
	(mode-ensure-word-sizes-defined): Update.
	(mode-builtin!): New builtin "modes" SYM, INSN, MACH.
	Redo WI/UWI/AI/IAI handling.
	(op:new-mode): No longer accept DFLT.
	(<derived-operand> constructor): Ensure all fields are initialized.
	(<anyof-operand> constructor): Ditto.
	(/derived-parse-ifield-assertion): Delete arg `args'.
	All callers updated.
	* rtl-c.scm (<rtl-c-eval-state>): New member `for-insn?'.
	(rtl-c): Call rtx-canonicalize instead of rtx-compile.
	(rtl-c-expr, rtl-c++): Ditto.
	(/rtl-c-get): Use mode of operand, not containing expression.
	(rtl-c-set-quiet, rtl-c-set-trace): Remove DFLT support.
	(/rtx-use-sem-fn?): Don't check for (insn? owner), check
	estate-for-insn? instead.
	(s-unop): Use mode of expression, not first operand.
	(s-binop, s-binop-with-bit, s-shop, s-cmpop): Ditto.
	(s-sequence): Remove DFLT support.
	(ifield): Use mode of expression, not UINT.
	(pc): Comment out, unused.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	(set, set-quiet): Pass src to rtl-c-set-{trace,quiet} for expansion.
	* rtl-traverse.scm (/rtx-canon-debug?): New global.
	(/make-cstate): New function.
	(/cstate-context, /cstate-outer-expr): New functions.
	(/rtx-canon-error): New function.
	(/rtx-lookup-hw, /rtx-pick-mode, /rtx-pick-mode3, /rtx-pick-op-mode,
	/rtx-get-last-cond-case-rtx): New functions.
	(/rtx-canon-*): New functions.
	(/rtx-canner-table, /rtx-operand-canoners): New globals.
	(/rtx-make-canon-table, /rtx-special-expr-canoners): New functions.
	(/rtx-option, /rtx-option-list?): Rewrite.
	(rtx-munge-mode&options): Replaces /rtx-munge-mode&options.
	Rewritten, all callers updated.
	(/rtx-canon-expr, /rtx-canon): New functions.
	(rtx-canonicalize): Move here from rtl-xform.scm and rewrite.
	(rtx-canonicalize-stmt): New function.
	(tstate-make): Remove arg `set?'.  All callers updated.
	(tstate-new-set?): Delete.
	(/rtx-traverse-options, /rtx-traverse-*mode): Delete,
	moved to /rtx-canon-*.
	(/rtx-traverse-normal-operand): New function.
	(/rtx-traverse-rtx-list): Delete arg `mode', all callers updated.
	(/rtx-traverse-rtx, /rtx-traverse-setrtx,, /rtx-traverse-testrtx,
	/rtx-traverse-condrtx, /rtx-traverse-casertx, /rtx-traverse-locals,
	/rtx-traverse-iteration, /rtx-traverse-env, /rtx-traverse-attrs):
	Ditto.
	(/rtx-traverse-symbol, /rtx-traverse-string, /rtx-traverse-number,
	/rtx-traverse-symornum, /rtx-traverse-object): Delete.
	(/rtx-make-traverser-table): Update.
	(/rtx-traverse-operands): Remove mode processing, now done during
	canonicalization.
	(/rtx-traverse-expr): Delete arg `mode', all callers updated.
	(/rtx-traverse): Ditto.
	(rtx-init-traverser-tables!): New function.
	* rtl-xform (/rtx-verify-no-dflt-modes-expr-fn): New function.
	(rtx-verify-no-dflt-modes): New function.
	(/rtx-simplify-expr-fn): Update, `arg' mode deleted.
	(rtx-simplify-insn): Use insn-canonical-semantics.
	(rtx-canonicalize): Moved to rtl-traverse.scm.
	(/compile-expr-fn, rtx-compile): Delete.
	(/rtx-trim-rtx-list): New function.
	(/rtx-trim-for-doc): Handle set, if.
	* rtl.scm (<rtx-func>): New members result-mode, matchexpr-index.
	(/rtx-valid-mode-types): Update.
	(/rtx-valid-matches): Update.
	(/rtx-find-matchexpr-index): New function.
	(rtx-lookup): Require rtx-kind to be the rtx name.
	(def-rtx-node): New arg result-mode, all callers updated.
	(def-rtx-syntax-node, def-rtx-operand-node): Ditto.
	(rtx-lazy-sem-mode): Delete.
	(/rtx-closure-make): New arg `mode', all callers updated.
	(rtx-make-ifield, rtx-make-operand, rtx-make-local): Ditto.
	(rtx-operand-obj): Rewrite.
	(rtx-make-xop): New functions.
	(/hw): Renamed from `hw', all callers updated.
	Use the correct mode instead of DFLT for the index.
	(rtl-builtin!): Call rtx-init-traversal-tables!.
	(rtl-finish!): Update.
	* rtx-funcs.scm (all rtx functions): New parameter: result-mode.
	Update mode arg-type.
	(pc): Comment out.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	* sem-frags.scm (/frag-hash-compute!): Update, mode arg deleted.
	(/frag-cost-compute!): Ditto.
	* semantics.scm (/build-operand!): Delete args op-name, op.
	New arg op-expr.  All callers updated.
	(/build-mem-operand!): Remove DFLT support.
	(semantic-compile): Update process-expr!, mode arg deleted.
	* sid-cpu.scm (gen-semantic-code): Specify #:for-insn? in
	rtl-c++ calls.
	(/gen-sem-case, /gen-sfrag-code): Ditto.
	* sid.scm (/op-gen-set-trace1): Renamed from /op-gen-set-trace.
	(/op-gen-set-trace): New function.  If not doing profiling,
	call /op-gen-set-quiet.
	* sim-cpu.scm (gen-semantic-code): Specify #:for-insn? in rtl-c calls.
	* utils-gen.scm (/gen-ifld-extract-base): Update call to rtl-c.
	(/gen-ifld-extract-beyond, gen-multi-ifld-extract): Ditto.
	* utils.scm (find-first-index): New function.
	* doc/rtl.texi: Delete docs for `attr'.  Add `int-attr'.
@
text
@d392 3
a394 1
; Hardware elements.
d415 4
a418 1
; Instruction fields.
d477 4
a480 1
; Operands.
d539 4
a542 1
; Instructions.
d593 4
a596 1
; Macro instructions.
@


1.20
log
@	Add support for controlling warnings/errors.
	Add tests for iformat description errors.
	* dev.scm (cload): New option #:diag.
	* read.scm (<reader>): New member verify-iformat?.
	(/parse-diagnostic, parse-warning): New functions.
	(parse-error): Guts moved to /parse-diagnostic.
	(/set-diagnostic-options!): New function.
	(cpu-load): New arg diagnostic-options, all callers updated.
	Recognize -w diagnostic-option-list.
	* ifield.scm (ifields-base-ifields): Move here from iformat.scm.
	(ifld-simple-ifields, ifields-simple-ifields): New function.
	* insn.scm (/parse-insn-format-iflds): New function.
	(/parse-insn-format): Guts moved to /parse-insn-format-iflds.
	New arg isa, all callers updated.  Do some basic validation of the
	ifield list if requested.
	* mach.scm (/sanity-check-insns): Improve error message text.
	* doc/running.text: Document -w option.

	* ifield.scm (/multi-ifield-parse): Initialize bitrange.
@
text
@d40 2
d66 1
d79 1
d1816 1
a1816 15
; Analyze the instruction set.
; The name is explicitly vague because it's intended that all insn analysis
; would be controlled here.
; If the instruction set has already been sufficiently analyzed, do nothing.
; INCLUDE-ALIASES? is #t if alias insns are to be included.
; ANALYZE-SEMANTICS? is #t if insn semantics are to be analyzed.
;
; This is a very expensive operation, so we only do it as necessary.
; There are (currently) two different kinds of users: assemblers and
; simulators.  Assembler style apps don't always need to analyze the semantics.
; Simulator style apps don't want to include the alias insns.

(define (arch-analyze-insns! arch include-aliases? analyze-semantics?)
  ; Catch apps that haven't set word sizes yet.
  (mode-ensure-word-sizes-defined)
d1818 2
a1819 3
  (if (or (not (arch-insns-analyzed? arch))
	  (not (eq? analyze-semantics? (arch-semantics-analyzed? arch)))
	  (not (eq? include-aliases? (arch-aliases-analyzed? arch))))
d1821 1
d1824 2
a1825 5
	;; FIXME: This shouldn't be calling current-insn-list,
	;; it should use (arch-insn-list arch).
	;; Then again various subroutines assume arch == CURRENT-ARCH.
	;; Still, something needs to be cleaned up.
	(if (any-true? (map multi-insn? (current-insn-list)))
d1842 1
a1842 1
			  (multi-insns (current-insn-list)))
d1844 2
d1848 40
a1887 2
	; This is expensive so indicate start/finish.
	(logit 1 "Analyzing instruction set ...\n")
d1889 7
a1895 17
	(let ((fmt-lists
	       (ifmt-compute! (non-multi-insns 
			       (if include-aliases?
				   (arch-insn-list arch)
				   (non-alias-insns (arch-insn-list arch))))
			      analyze-semantics?)))

	  (arch-set-ifmt-list! arch (car fmt-lists))
	  (arch-set-sfmt-list! arch (cadr fmt-lists))
	  (arch-set-insns-analyzed?! arch #t)
	  (arch-set-semantics-analyzed?! arch analyze-semantics?)
	  (arch-set-aliases-analyzed?! arch include-aliases?)

	  ;; Now that the instruction formats are computed,
	  ;; do some sanity checks.
	  (logit 1 "Performing sanity checks ...\n")
	  (/sanity-check-insns arch)
d1897 33
a1929 3
	  (logit 1 "Done analysis.\n")
	  ))
      )
@


1.19
log
@	* dev.scm (*): Change default verbosity level to 2.

	* ifield.scm (<ifield> pretty-print): New method.
	(ifld-pretty-print): New function.
	(<multi-ifield> pretty-print): New method.

	* ifield.scm (<ifield> field-start): Delete word-len arg.
	All callers updated.
	(ifld-start): Ditto.
	(<multi-ifield> field-start): Ditto.
	* operand.scm (<hw-index> field-start): Ditto.
@
text
@d1776 2
d1796 5
@


1.18
log
@	* ifield.scm (ifld-beyond-base?): Remove args base-bitsize,
	total-bitsize.  All callers updated.
	* insn.scm (<insn>): Rename member ifld-values to /insn-value.
	New member /insn-base-value.
	(insn-base-value): New function.
	* mach.scm (/sanity-check-insns): New function.
	(arch-analyze-insns!): Call it.
@
text
@d1774 2
a1775 17
    ;; ??? It's not clear where errors can come in.  From bad .cpu files,
    ;; bugs, or both.  But it's better to catch such errors early.
    (for-each (lambda (insn)
		(let ((base-len (insn-base-mask-length insn))
		      (base-mask (insn-base-mask insn))
		      (base-value (insn-base-value insn)))
		  (if (not (= (cg-logand (cg-logxor base-mask (mask base-len))
					 base-value)
			      0))
		      (context-owner-error #f insn
					   "While performing sanity checks"
					   (string-append "Instruction has opcode bits outside of its mask.\n"
							  "This usually means some kind of error in the instruction's ifield list.\n"
							  "base mask: 0x" (number->hex base-mask)
							  ", base value: 0x" (number->hex base-value))))
		  ))
	      (non-multi-insns (non-alias-insns insn-list)))
d1777 26
a1802 1
    *UNSPECIFIED*)
@


1.17
log
@	* types.scm (<struct>): Delete.

	* pmacros.scm (/pmacro-env-make): New argument `loc', all callers
	updated.
	(/pmacro-loc-error): New function.

	* mach.scm (/isa-parse-decode-assist): New function.
	(/isa-parse): Call it.

	* decode.scm (/get-subopcode-value): New function.
	(/opcode-slots): Call it.
	(/fill-slot!): Add logging message.
@
text
@d1767 28
d1858 5
@


1.16
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d1136 14
d1208 3
a1210 1
      decode-assist
@


1.15
log
@	* mach.scm (current-*-add!): Update calls to parse-error.
	* operand.scm (op:new-mode): Update call to parse-error.
	* utils-cgen.scm (make-obj-context): New function.
@
text
@d85 1
a85 1
  (-ident-object-table->list (arch-ifld-table arch))
d89 1
a89 1
  (-ident-object-table->list (arch-op-table arch))
d93 1
a93 1
  (-ident-object-table->list (arch-insn-table arch))
d97 1
a97 1
  (-ident-object-table->list (arch-minsn-table arch))
d102 1
a102 1
(define (-get-next-ordinal! arch)
d111 1
a111 1
(define (-get-lowest-ordinal l)
d113 1
a113 1
	(lowest-ord (-get-next-ordinal! CURRENT-ARCH)))
d134 1
a134 1
(define (-make-ident-object-table hash-size)
d144 1
a144 1
(define (-ident-object-table->list iot)
d174 1
a174 1
(define (-ident-object-table-add! arch iot key object)
d177 1
a177 1
      (obj-set-ordinal! object (-get-next-ordinal! arch)))
d194 1
a194 1
(define (-ident-object-table-lookup iot key)
d412 1
a412 1
  (-ident-object-table->list (arch-ifld-table CURRENT-ARCH))
d416 1
a416 1
  (if (-ifld-already-defined? f)
d419 1
a419 1
  (-ident-object-table-add! CURRENT-ARCH (arch-ifld-table CURRENT-ARCH)
d436 1
a436 1
      (let ((f-list (-ident-object-table-lookup (car (arch-ifld-table CURRENT-ARCH))
d444 1
a444 1
		(-get-lowest-ordinal f-list))
d452 2
a453 2
(define (-ifld-already-defined? f)
  (let ((iflds (-ident-object-table-lookup (car (arch-ifld-table CURRENT-ARCH))
d471 1
a471 1
  (-ident-object-table->list (arch-op-table CURRENT-ARCH))
d475 1
a475 1
  (if (-op-already-defined? op)
d478 1
a478 1
  (-ident-object-table-add! CURRENT-ARCH (arch-op-table CURRENT-ARCH)
d487 1
a487 1
  (let ((op-list (-ident-object-table-lookup (car (arch-op-table CURRENT-ARCH))
d494 1
a494 1
	    (-get-lowest-ordinal op-list))
d502 2
a503 2
(define (-op-already-defined? op)
  (let ((ops (-ident-object-table-lookup (car (arch-op-table CURRENT-ARCH))
d530 1
a530 1
  (-ident-object-table->list (arch-insn-table CURRENT-ARCH))
d534 1
a534 1
  (if (-insn-already-defined? i)
d537 1
a537 1
  (-ident-object-table-add! CURRENT-ARCH (arch-insn-table CURRENT-ARCH)
d546 1
a546 1
  (let ((i (-ident-object-table-lookup (car (arch-insn-table CURRENT-ARCH))
d562 2
a563 2
(define (-insn-already-defined? insn)
  (let ((insns (-ident-object-table-lookup (car (arch-insn-table CURRENT-ARCH))
d581 1
a581 1
  (-ident-object-table->list (arch-minsn-table CURRENT-ARCH))
d585 1
a585 1
  (if (-minsn-already-defined? m)
d588 1
a588 1
  (-ident-object-table-add! CURRENT-ARCH (arch-minsn-table CURRENT-ARCH)
d597 1
a597 1
  (let ((m (-ident-object-table-lookup (car (arch-minsn-table CURRENT-ARCH))
d613 2
a614 2
(define (-minsn-already-defined? m)
  (let ((minsns (-ident-object-table-lookup (car (arch-minsn-table CURRENT-ARCH))
d650 1
a650 1
(define (-arch-parse-alignment context alignment)
d660 1
a660 1
(define (-arch-parse-machs context machs)
d679 1
a679 1
(define (-arch-parse-isas context isas)
d699 1
a699 1
(define (-arch-parse context name comment attrs
d707 1
a707 1
    (-arch-parse-alignment context default-alignment)
d709 2
a710 2
    (-arch-parse-machs context machs)
    (-arch-parse-isas context isas))
d718 1
a718 1
(define -arch-read
d752 1
a752 1
      (-arch-parse context name comment attrs default-alignment insn-lsb0?
d762 1
a762 1
    (let ((a (apply -arch-read arg-list)))
d1004 1
a1004 1
(define (-isa-parse-decode-split context spec)
d1022 1
a1022 1
(define (-isa-parse-decode-splits context spec-list)
d1024 1
a1024 1
	 (-isa-parse-decode-split context spec))
d1140 1
a1140 1
(define (-isa-parse-condition context spec)
d1154 1
a1154 1
(define (-isa-parse-setup-semantics context spec)
d1164 1
a1164 1
(define (-isa-parse context name comment attrs
d1197 3
a1199 3
      (-isa-parse-condition context condition)
      (-isa-parse-setup-semantics context setup-semantics)
      (-isa-parse-decode-splits context decode-splits)
d1206 1
a1206 1
(define (-isa-read context . arg-list)
d1250 1
a1250 1
    (-isa-parse context name comment attrs
d1266 1
a1266 1
    (let ((i (apply -isa-read (cons (make-current-context "define-isa")
d1275 2
a1276 2
(define (-isa-add-decode-split! context isa spec)
  (let ((decode-split (-isa-parse-decode-split context spec)))
d1301 1
a1301 1
		   (-isa-add-decode-split! context isa (cdr arg-spec)))
d1414 1
a1414 1
(define (-cpu-parse context name comment attrs
d1444 1
a1444 1
; -cpu-parse is invoked to create the <cpu> object.
d1446 1
a1446 1
(define (-cpu-read context . arg-list)
d1486 1
a1486 1
    (-cpu-parse context name comment attrs
d1495 1
a1495 1
    (let ((c (apply -cpu-read (cons (make-current-context "define-cpu")
d1542 1
a1542 1
(define (-mach-parse context name comment attrs cpu bfd-name isas)
d1585 1
a1585 1
(define (-mach-read context . arg-list)
d1611 1
a1611 1
    (-mach-parse context name comment attrs cpu
d1622 1
a1622 1
    (let ((m (apply -mach-read (cons (make-current-context "define-mach")
d1728 1
a1728 1
(define (-adata-set-derived! arch)
d1855 4
a1858 4
    (arch-set-ifld-table! arch (-make-ident-object-table 127))
    (arch-set-op-table! arch (-make-ident-object-table 127))
    (arch-set-insn-table! arch (-make-ident-object-table 509))
    (arch-set-minsn-table! arch (-make-ident-object-table 127))
d1896 1
a1896 1
  (-adata-set-derived! CURRENT-ARCH)
@


1.14
log
@	Clean up cpu file parsing, pass context consistently instead of the
	old "errtxt" argument.
	NOTE: ACU == "All Callers Updated".
	* attr.scm (-parse-simple-attribute): Renamed from
	parse-simple-attribute, ACU.
	(-attr-parse): Change errtxt argument to context, ACU.
	(-attr-read): Ditto.
	(atlist-parse): Ditto.  Put context arg first.
	(attr-parse): Use parse-error instead of context-error.
	* enum.scm (parse-enum-vals): Change errtxt argument to context, ACU.
	(-enum-parse-prefix, -enum-parse, -enum-read): Ditto.
	* hardware.scm (-keyword-parse): Renamed from keyword-parse.
	`context' arg is now a <context> object.  ACU.
	(-keyword-read): `context' arg is now a <context> object.  ACU.
	(-hw-parse-indices): Change errtxt argument to context, ACU.
	(-hw-parse-values, -hw-parse-handlers): Ditto.
	(-hw-parse-getter, -hw-parse-setter, -hw-parse, -hw-read): Ditto.
	(-hw-validate-layout, -hw-create-getter-from-layout,
	-hw-create-setter-from-layout): Ditto.
	(<hw-register>:parse!, <hw-pc>:parse!): Ditto.
	(<hw-memory>:parse!, <hw-immediate>:parse!): Ditto.
	(<hw-address>:parse!): Ditto.
	* ifield.scm (-ifield-parse, ifield-read): Ditto.
	(-ifld-parse-follows, -ifld-parse-encode-decode): Ditto.
	(-ifld-parse-encode, -ifld-parse-decode): Ditto.
	(-multi-ifield-parse, -multi-ifield-read): Ditto.
	* insn.scm (-insn-parse, -insn-read): Ditto.
	(parse-syntax): Ditto.  Put context arg first.
	(-parse-insn-format-symbol): Change errtxt argument to context, ACU.
	(-parse-insn-format-ifield-spec, -parse-insn-format-list): Ditto.
	(-parse-insn-format): Ditto.
	* mach.scm (-arch-parse-alignment, -arch-parse-machs): Ditto.
	(-arch-parse-isas): Ditto.
	(-isa-read): Add context arg, ACU.
	(-cpu-parse, -cpu-read, -mach-read): Ditto.
	* minsn.scm (-minsn-parse-expansion): Change errtxt argument to
	context, ACU.
	(-minsn-parse, -minsn-read, -minsn-compute-iflds): Ditto.
	(minsn-make-alias): Ditto.
	* mode.scm (-mode-parse): Ditto.
	(parse-mode-name): Ditto.  Put context arg first.
	* model.scm (-prefetch-parse, -retire-parse, -pipeline-parse): Change
	errtxt argument to context, ACU.
	(-unit-parse, -model-parse, -model-read): Ditto.
	* operand.scm (-operand-parse-getter): Use parse-error instead of
	context-error.
	(-operand-parse-setter): Ditto.
	(-operand-parse): Change errtxt argument to context, ACU.
	(-operand-read, -derived-operand-parse, -derived-operand-read): Ditto.
	(-anyof-operand-parse, -anyof-operand-read): Ditto.
	* read.scm (reader-error): Delete.  Use parse-error instead.
	(parse-error): Change errtxt argument to context, ACU.  Split args
	argument into expr and maybe-help-text.
	(-reader-process-expanded-1!): Reorganize.
	* rtl.scm (-subr-read): Change errtxt argument to context, ACU.
	* types.scm (parse-type): Ditto.
	* utils-cgen.scm (single-location->simple-string): New function.
	(<context>): Replace members file,lineno with location.
	(make-prefix-context): Renamed from context-make-prefix, ACU.
	(make-current-context): New function.
	(context-append, context-append-name): New functions.
	(context-make-reader): Delete.
	(parse-name): Change errtxt argument to context, ACU.
	Put context arg first.
	(parse-comment): Ditto.
	(parse-number): Change errtxt argument to context, ACU.
	(arg-list-validate-name, arg-list-check-no-args,
	arg-list-symbol-arg): Ditto.

	* read.scm (-cmd-if): Don't assume test is a list.

	* html.scm (get-insn-properties): Delete errtxt, unused.
@
text
@d273 2
a274 1
      (parse-error "define-attr" "attribute already defined" (obj:name a)))
d298 2
a299 1
      (parse-error "define-enum" "enum already defined" (obj:name e)))
d314 2
a315 1
      (parse-error "define-keyword" "keyword already defined" (obj:name kw)))
d330 2
a331 1
      (parse-error "define-isa" "isa already defined" (obj:name i)))
d346 2
a347 1
      (parse-error "define-cpu" "cpu already defined" (obj:name c)))
d362 2
a363 1
      (parse-error "define-mach" "mach already defined" (obj:name m)))
d378 2
a379 1
      (parse-error "define-model" "model already defined" (obj:name m)))
d394 2
a395 1
      (parse-error "define-hardware" "hardware already defined" (obj:name hw)))
d417 2
a418 1
      (parse-error "define-ifield" "ifield already defined" (obj:name f)))
d476 2
a477 1
      (parse-error "define-operand" "operand already defined" (obj:name op)))
d535 2
a536 1
      (parse-error "define-insn" "insn already defined" (obj:name i)))
d586 2
a587 1
      (parse-error "define-minsn" "macro-insn already defined" (obj:name m)))
d635 2
a636 1
      (parse-error "define-subr" "subroutine already defined" (obj:name s)))
@


1.13
log
@	Track source location better, for better error messages.
	* pmacros.scm (-pmacro-eval): Delete, unused.
	(pmacro-expand, -pmacro-expand): New arg `loc', all callers updated.
	(-pmacro-expand-expr-list, -smacro-apply): Ditto.
	(scan-list, scan): Ditto.
	(-pmacro-builtin-pmacro, -pmacro-builtin-let, -pmacro-builtin-if,
	-pmacro-builtin-case, -pmacro-builtin-cond, -pmacro-builtin-begin,
	-pmacro-builtin-andif, -pmacro-builtin-orif): Ditto.
	(scan-list1): New function.
	(-pmacro-build-lambda): New arg `loc', all callers updated.  Rewrite.
	* read.scm (<reader>): New member `location'.
	(-reader-lookup-command): Renamed from reader-lookup-command,
	all callers updated.
	(reader-error): Rewrite to produce better source location info.
	(current-reader-location): New function.
	(-reader-process-expanded-1!): Renamed from -reader-process-expanded-1.
	All callers updated.  Record source location of expression.
	(reader-process-expanded!): Renamed from reader-process-expanded.
	All callers updated.
	(-reader-process!): Renamed from reader-process.  New arg `loc'.
	All callers updated.  Record source location of define-pmacro.
	* utils-cgen.scm (<location>): New class.
	(single-location): New (pseudo) class.
	(pretty-print-single-location, pretty-print-location): New functions.
	(location-top, location-push-single, location-push): New functions.
	(unspecified-location, current-input-location): New functions.
	(location-property): New object property.
	(location-property-set!): New function.
	(<source-ident>): Renamed from <ordered-ident>.  New member `location'.
	All uses updated.
	* testsuite/location-1.test: New testcase.
	* testsuite/run-tests.sh: Fix fail count handling.
	* testsuite/test-utils.sh.in (run_cgen): New option `-f'.  Allow tests
	to expect cgen to fail.

	* pmacros.scm (*): Use "pmacro" instead of "macro" more consistently.

	* read.scm (-cmd-include): Renamed from include.  All callers updated.
	(-cmd-if): Renamed from cmd-if.  All callers updated.
	Use reader-process-expanded! on then/else clauses instead of eval1.
@
text
@d637 1
a637 1
(define (-arch-parse-alignment errtxt alignment)
d640 1
a640 1
      (parse-error errtxt "invalid alignment" alignment))
d647 1
a647 1
(define (-arch-parse-machs errtxt machs)
d653 1
a653 1
		  (parse-error errtxt "bad arch mach spec" m)))
d666 1
a666 1
(define (-arch-parse-isas errtxt isas)
d672 1
a672 1
		  (parse-error errtxt "bad arch isa spec" m)))
d691 3
a693 3
    (parse-name name context)
    (parse-comment comment context)
    (atlist-parse attrs "arch" context)
d1157 4
a1160 1
  (let ((name (parse-name name context)))
d1170 4
a1173 4
      (parse-comment comment context)
      (atlist-parse attrs "isa" context)
      (parse-number (string-append context
				   ": default-insn-word-bitsize")
d1175 2
a1176 2
      (parse-number (string-append context
				   ": default-insn-bitsize")
d1178 2
a1179 2
      (parse-number (string-append context
				   ": base-insn-bitsize")
d1193 54
a1246 56
(define -isa-read
  (lambda arg-list
    (let ((context "isa-read")
	  ; <isa> object members and default values
	  (name #f)
	  (attrs nil)
	  (comment "")
	  (base-insn-bitsize #f)
	  (default-insn-bitsize #f)
	  (default-insn-word-bitsize #f)
	  (decode-assist nil)
	  (liw-insns 1)
	  ; FIXME: Hobbit computes the wrong symbol for `parallel-insns'
	  ; in the `case' expression below because there is a local var
	  ; of the same name ("__1" gets appended to the symbol name).
	  (parallel-insns- 1)
	  (condition nil)
	  (setup-semantics nil)
	  (decode-splits nil)
	  )
      (let loop ((arg-list arg-list))
	(if (null? arg-list)
	    nil
	    (let ((arg (car arg-list))
		  (elm-name (caar arg-list)))
	      (case elm-name
		((name) (set! name (cadr arg)))
		((comment) (set! comment (cadr arg)))
		((attrs) (set! attrs (cdr arg)))
		((default-insn-word-bitsize)
		 (set! default-insn-word-bitsize (cadr arg)))
		((default-insn-bitsize) (set! default-insn-bitsize (cadr arg)))
		((base-insn-bitsize) (set! base-insn-bitsize (cadr arg)))
		((decode-assist) (set! decode-assist (cadr arg)))
		((liw-insns) (set! liw-insns (cadr arg)))
		((parallel-insns) (set! parallel-insns- (cadr arg)))
		((condition) (set! condition (cdr arg)))
		((setup-semantics) (set! setup-semantics (cadr arg)))
		((decode-splits) (set! decode-splits (cdr arg)))
		((insn-types) #t) ; ignore for now
		((frame) #t) ; ignore for now
		(else (parse-error context "invalid isa arg" arg)))
	      (loop (cdr arg-list)))))
      ; Now that we've identified the elements, build the object.
      (-isa-parse context name comment attrs
		  base-insn-bitsize
		  (if default-insn-word-bitsize
		      default-insn-word-bitsize
		      base-insn-bitsize)
		  (if default-insn-bitsize
		      default-insn-bitsize
		      base-insn-bitsize)
		  decode-assist liw-insns parallel-insns- condition
		  setup-semantics decode-splits)
      )
    )
d1253 2
a1254 1
    (let ((i (apply -isa-read arg-list)))
d1272 1
a1272 1
    (let ((errtxt "modify-isa")
d1275 1
a1275 1
	  (parse-error errtxt "isa name not specified"))
d1277 1
a1277 1
      (let ((isa (current-isa-lookup (arg-list-symbol-arg errtxt isa-spec))))
d1279 1
a1279 1
	    (parse-error errtxt "undefined isa" isa-spec))
d1288 1
a1288 1
		   (-isa-add-decode-split! errtxt isa (cdr arg-spec)))
d1290 1
a1290 1
		   (parse-error errtxt "invalid/unsupported option" (car arg-spec))))
d1401 1
a1401 1
(define (-cpu-parse name comment attrs
d1405 5
a1409 3
  ; Pick out name first 'cus we need it as a string(/symbol).
  (let* ((name (parse-name name "cpu"))
	 (errtxt (stringsym-append "cpu " name)))
d1413 2
a1414 2
	      (parse-comment comment errtxt)
	      (atlist-parse attrs "cpu" errtxt)
d1429 1
d1433 43
a1475 45
(define -cpu-read
  (lambda arg-list
    (let ((errtxt "cpu-read")
	  ; <cpu> object members and default values
	  (name nil)
	  (comment nil)
	  (attrs nil)
	  (endian #f)
	  (insn-endian #f)
	  (data-endian #f)
	  (float-endian #f)
	  (word-bitsize #f)
	  (insn-chunk-bitsize 0)
	  (file-transform "")
	  ; FIXME: Hobbit computes the wrong symbol for `parallel-insns'
	  ; in the `case' expression below because there is a local var
	  ; of the same name ("__1" gets appended to the symbol name).
	  (parallel-insns- #f)
	  )
      ; Loop over each element in ARG-LIST, recording what's found.
      (let loop ((arg-list arg-list))
	(if (null? arg-list)
	    nil
	    (let ((arg (car arg-list))
		  (elm-name (caar arg-list)))
	      (case elm-name
		((name) (set! name (cadr arg)))
		((comment) (set! comment (cadr arg)))
		((attrs) (set! attrs (cdr arg)))
		((endian) (set! endian (cadr arg)))
		((insn-endian) (set! insn-endian (cadr arg)))
		((data-endian) (set! data-endian (cadr arg)))
		((float-endian) (set! float-endian (cadr arg)))
		((word-bitsize) (set! word-bitsize (cadr arg)))
		((insn-chunk-bitsize) (set! insn-chunk-bitsize (cadr arg)))
		((file-transform) (set! file-transform (cadr arg)))
		((parallel-insns) (set! parallel-insns- (cadr arg)))
		(else (parse-error errtxt "invalid cpu arg" arg)))
	      (loop (cdr arg-list)))))
      ; Now that we've identified the elements, build the object.
      (-cpu-parse name comment attrs
		  endian insn-endian data-endian float-endian
		  word-bitsize insn-chunk-bitsize file-transform parallel-insns-)
      )
    )
d1482 2
a1483 1
    (let ((c (apply -cpu-read arg-list)))
d1532 4
a1535 1
  (let ((name (parse-name name context)))
d1552 1
d1554 1
d1557 2
a1558 2
		(parse-comment comment context)
		(atlist-parse attrs "mach" context)
d1562 1
d1569 1
d1572 31
a1602 32
(define -mach-read
  (lambda arg-list
    (let ((context "mach-read")
	  (name nil)
	  (attrs nil)
	  (comment nil)
	  (cpu nil)
	  (bfd-name #f)
	  (isas #f)
	  )
      (let loop ((arg-list arg-list))
	(if (null? arg-list)
	    nil
	    (let ((arg (car arg-list))
		  (elm-name (caar arg-list)))
	      (case elm-name
		((name) (set! name (cadr arg)))
		((comment) (set! comment (cadr arg)))
		((attrs) (set! attrs (cdr arg)))
		((cpu) (set! cpu (cadr arg)))
		((bfd-name) (set! bfd-name (cadr arg)))
		((isas) (set! isas (cdr arg)))
		(else (parse-error context "invalid mach arg" arg)))
	      (loop (cdr arg-list)))))
      ; Now that we've identified the elements, build the object.
      (-mach-parse context name comment attrs cpu
		   ; Default bfd-name is same as object's name.
		   (if bfd-name bfd-name (symbol->string name))
		   ; Default isa is the first one.
		   (if isas isas (list (obj:name (car (current-isa-list))))))
      )
    )
d1609 2
a1610 1
    (let ((m (apply -mach-read arg-list)))
@


1.12
log
@	Use hash tables to record ifields, operands, insns, macro-insns.
	* attr.scm (attr-builtin!): Tweak some comments.
	* hardware.scm (hardware-builtin!): Call all-isas-attr-value.
	* ifield.scm (<ifield>): Subclass from <ordered-ident> instead of
	<ident>.
	(<multi-ifield>): New constructor.
	(ifield-builtin!): Add isa attr to f-nil, f-anyof.
	* insn.scm (<insn>): Subclass from <ordered-ident> instead of
	<ident>.
	(-sub-insn-make!): Add hack to avoid differences in generated code.
	(multi-insn-instantiate!): Add total number of multi-insns to
	logging message.
	* mach.scm (<arch>): Rename members ifld-list, op-list, insn-list,
	minsn-list to foo-table.  New member next-ordinal.
	Update getters/setters.
	(arch-ifld-list, arch-op-list, arch-insn-list, arch-minsn-list):
	New functions.
	(-get-next-ordinal!, -get-lowest-ordinal): New function.
	(-make-ident-object-table, -ident-object-table->list,
	-ident-object-table-add!, -ident-object-table-lookup): New functions.
	(current-ifld-list, current-ifld-add! current-ifld-lookup,
	-ifld-already-defined?): Rewrite.
	(current-op-list, current-op-add! current-op-lookup,
	-op-already-defined?): Rewrite.
	(current-raw-insn-list, insn-list-car, insn-list-splice!): Delete.
	(current-insn-list, current-insn-add! current-insn-lookup,
	-insn-already-defined?): Rewrite.
	(current-minsn-list, current-minsn-add! current-minsn-lookup,
	-minsn-already-defined?): Rewrite.
	(all-isas-attr-value, all-isas-attr, attr-isa-list): New functions.
	(MAX-VIRTUAL-INSNS): Define.
	(arch-analyze-insns!): Add hack to avoid differences in generated code.
	Update use of arch-insn-list.
	(mach-init!): Initialize ifld-table, op-table, insn-table, minsn-table.
	(arch-finish!): Delete references to ifld-table, op-table, insn-table,
	minsn-table.
	* minsn.scm (<macro-insn>): Subclass from <ordered-ident> instead of
	<ident>.  New constructor.
	* operand.scm (<operand>): Subclass from <ordered-ident> instead of
	<ident>.
	* sid.scm (-virtual-insn-add!): New function.
	(-create-virtual-insns!): Call it.
	(-fill-sim-insn-list!): Rewrite.
	* sim.scm (-virtual-insn-add!, -create-virtual-insns!): New functions.
	(sim-finish!): Move contents to -create-virtual-insns!, and call it.
	* utils-cgen.scm (<ordered-ident>): New class.
	(obj-ordinal, obj-set-ordinal!): New functions.
	(add-ident-methods!): Delete.

	* model.scm (parse-insn-timing): Change logging message to level 3.
@
text
@d123 1
a123 1
;; Table of <ordered-ident> objects with two access styles:
d131 1
a131 1
;; This relies on the ordinal element of <ordered-ident> objects to build the
@


1.11
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d16 2
d25 1
a25 1
		(ifld-list . ())
d27 1
a27 1
		(op-list . ())
d30 2
a31 2
		(insn-list . ())
		(minsn-list . ())
d33 1
d46 3
d61 2
a62 2
   ifld-list hw-list op-list ifmt-list sfmt-list
   insn-list minsn-list subr-list
d65 1
d73 2
a74 2
   ifld-list hw-list op-list ifmt-list sfmt-list
   insn-list minsn-list subr-list
d77 1
d81 117
d403 3
a405 1
(define (current-ifld-list) (map cdr (arch-ifld-list CURRENT-ARCH)))
d410 2
a411 2
  (arch-set-ifld-list! CURRENT-ARCH
		       (acons (obj:name f) f (arch-ifld-list CURRENT-ARCH)))
d415 9
d427 10
a436 1
      (assq-ref (arch-ifld-list CURRENT-ARCH) x))
d444 2
a445 2
  (let ((iflds (find (lambda (ff) (eq? (obj:name f) (car ff)))
		     (arch-ifld-list CURRENT-ARCH))))
d448 9
a456 7
    (let ((result #f)
	  (f-isas (obj-isa-list f)))
      (for-each (lambda (ff)
		  (if (not (null? (intersection f-isas (obj-isa-list (cdr ff)))))
		      (set! result #t)))
		iflds)
      result))
d461 3
a463 1
(define (current-op-list) (map cdr (arch-op-list CURRENT-ARCH)))
d468 2
a469 2
  (arch-set-op-list! CURRENT-ARCH
		     (acons (obj:name op) op (arch-op-list CURRENT-ARCH)))
d473 3
d477 9
a485 1
  (assq-ref (arch-op-list CURRENT-ARCH) name)
d493 2
a494 2
  (let ((ops (find (lambda (o) (eq? (obj:name op) (car o)))
		     (arch-op-list CURRENT-ARCH))))
d497 9
a505 7
    (let ((result #f)
	  (op-isas (obj-isa-list op)))
      (for-each (lambda (o)
		  (if (not (null? (intersection op-isas (obj-isa-list (cdr o)))))
		      (set! result #t)))
		ops)
      result))
d519 3
a521 3
(define (current-raw-insn-list) (arch-insn-list CURRENT-ARCH))

(define (current-insn-list) (map cdr (arch-insn-list CURRENT-ARCH)))
d526 2
a527 2
  (arch-set-insn-list! CURRENT-ARCH
		       (acons (obj:name i) i (arch-insn-list CURRENT-ARCH)))
d531 3
d535 10
a544 1
  (assq-ref (arch-insn-list CURRENT-ARCH) name)
d552 2
a553 2
  (let ((insns (find (lambda (i) (eq? (obj:name insn) (car i)))
		     (arch-insn-list CURRENT-ARCH))))
d556 9
a564 21
    (let ((result #f)
	  (insn-isas (obj-isa-list insn)))
      (for-each (lambda (i)
		  (if (not (null? (intersection insn-isas (obj-isa-list (cdr i)))))
		      (set! result #t)))
		insns)
      result))
)

; Return the insn in the `car' position of INSN-LIST.

(define insn-list-car cdar)

; Splice INSN into INSN-LIST after (car INSN-LIST).
; This is useful when creating machine generating insns - it's useful to
; keep them close to their progenitor.
; The result is the same list, but beginning at the spliced-in insn.

(define (insn-list-splice! insn-list insn)
  (set-cdr! insn-list (acons (obj:name insn) insn (cdr insn-list)))
  (cdr insn-list)
d569 3
a571 1
(define (current-minsn-list) (map cdr (arch-minsn-list CURRENT-ARCH)))
d576 2
a577 2
  (arch-set-minsn-list! CURRENT-ARCH
			(acons (obj:name m) m (arch-minsn-list CURRENT-ARCH)))
d581 3
d585 10
a594 1
  (assq-ref (arch-minsn-list CURRENT-ARCH) name)
d602 2
a603 2
  (let ((minsns (find (lambda (mm) (eq? (obj:name m) (car mm)))
		      (arch-minsn-list CURRENT-ARCH))))
d606 9
a614 7
    (let ((result #f)
	  (m-isas (obj-isa-list m)))
      (for-each (lambda (mm)
		  (if (not (null? (intersection m-isas (obj-isa-list (cdr mm)))))
		      (set! result #t)))
		minsns)
      result))
d830 19
d1722 5
d1748 5
d1757 15
a1771 3
	      (for-each (lambda (insn)
			  (multi-insn-instantiate! insn))
			(multi-insns (current-insn-list)))
d1780 2
a1781 2
				   (map cdr (arch-insn-list arch))
				   (non-alias-insns (map cdr (arch-insn-list arch)))))
d1830 6
d1854 2
a1861 1
    (arch-set-ifld-list! arch (reverse (arch-ifld-list arch)))
a1862 3
    (arch-set-op-list! arch (reverse (arch-op-list arch)))
    (arch-set-insn-list! arch (reverse (arch-insn-list arch)))
    (arch-set-minsn-list! arch (reverse (arch-minsn-list arch)))
@


1.10
log
@2005-10-28  Dave Brolley  <brolley@@redhat.com>

        Contribute the following changes:
        2005-09-19  Dave Brolley  <brolley@@redhat.com>

        * attr.scm (gen-value-for-defn-raw): New methods.
        (gen-value-for-defn): Don't test for 'SID-SIMULATOR. Call
        gen-value-for-defn-raw.
        * sid.scm (gen-obj-attr-sid-defn): Call gen-value-for-defn-raw.

        2002-12-13  Dave Brolley  <brolley@@redhat.com>

        * utils-cgen.scm (gen-attr-type): Moved from sid.scm.
        (-gen-attr-accessors): New function.
        (gen-obj-attr-defn): Update terminating initializer.
        (gen-obj-attr-end-defn): New function.
        * sid.scm (gen-attr-type): Moved to utils-cgen.scm.
        * sid-cpu.scm (cgen-desc.h): Generate code to include
        "opcode/cgen-bitset.h"
        * intrinsics.scm (kept-insn-isas): Correct the extraction of the isa
        name.
        * desc.scm ('gen-defn): Update terminating initializer.
        * desc-cpu.scm (gen-ifld-decls): Call -gen-attr-accessors. Update
        terminatinig initializer.
        (gen-hw-decls): Ditto.
        (gen-operand-decls): Ditto.
        (gen-insn-decls): Ditto.
        (-gen-hash-defines): Generate code to include "opcde/cgen-bitset.h"
        (gen-insn-table): Update terminating initializer.
        (-gen-cpu-open): Update generation of @@arch@@_cgen_rebuild_tables,
        @@arch@@_cgen_cpu_open, @@arch@@_cgen_cpu_close.
        * attr.scm (charmask-bytes): New function.
        (bitset-attr->charmask): New function.
        (<bitset-attribute>): Handle isa-attributes specially. Also handle
        differences for SID-SIMULATOR.
        (<integer-attribute>): Handle differences for SID-SIMULATOR.
        (<enum-attribute>): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2003 Red Hat, Inc.
@


1.10.6.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2003, 2009 Red Hat, Inc.
@


1.9
log
@2005-06-15  Dave Brolley  <brolley@@redhat.com>

        * sid-cpu.scm (-gen-hw-stream-and-destream-fns): New function.
        (cgen-cpu.h): Call it.

        Contributed on behalf of Graydon Hoare
        2001-06-05  graydon hoare  <graydon@@redhat.com>

        * utils.scm (foldl): Define.
        (foldr): Define.
        (filter): Define.
        (union): Define.
        (intersection): Simplify.
        * sid.scm : Set APPLICATION to SID-SIMULATOR.
        (-op-gen-delayed-set-maybe-trace): Define.
        (<operand> 'gen-set-{quiet,trace}): Delegate to
        op-gen-delayed-set-quiet etc. Note: this is still a little tangled
        up and needs cleaning.
        (-with-parallel?): Hardwire with-parallel to #t.
        (<operand> 'cxmake-get): Replace with lookahead-aware code
        * sid-decode.scm: Remove per-insn writeback fns.
        (-gen-idesc-decls): Redefine sem_fn type.
        * sid-cpu.scm (gen-write-stack-structure): Replace parexec stuff
        with write stack stuff.
        (cgen-write.cxx): Replace per-insn writebacks with single write
        stack writeback. Add write stack reset function.
        (-gen-scache-semantic-fn insn): Replace parexec stuff with write
        stack stuff.
        * rtl-c.scm (xop): Clone operand into delayed operand if #:delayed
        estate attribute set.
        (delay): Set #:delayed attribute to calculated delay, update
        maximum delay of cpu, check (delay ...) usage.
        * operand.scm (<operand>): Add delayed slot to <operand>.
        * mach.scm (<cpu>): Add max-delay slot to <cpu>.
        * dev.scm (load-sid): Set APPLICATION to SID-SIMULATOR.
        * doc/rtl.texi (Expressions): Add section on (delay ...).
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
d905 1
a905 2
						 (eq? (obj-attr-value insn 'ISA)
						      (obj:name isa))))
d915 1
a915 2
						 (eq? (obj-attr-value insn 'ISA)
						      (obj:name isa))))
@


1.8
log
@* mach.scm (def-isa-attr!): hardware can have ISA attributes, too.
@
text
@d1158 5
d1169 2
a1170 1
(define-getters <cpu> cpu (word-bitsize insn-chunk-bitsize file-transform parallel-insns))
d1220 3
a1222 1
	      parallel-insns)
@


1.7
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@d645 1
a645 1
	  '(for ifield operand insn))
@


1.6
log
@	* mach.scm (-ifld-already-defined?): New proc.
	(current-ifld-add!): Use it.
	(-op-already-defined?): New proc.
	(current-op-add!): Use it.
	(-insn-already-defined?): New proc.
	(current-insn-add!): Use it.
	(-minsn-already-defined?): New proc.
	(current-minsn-add!): Use it.
	(obj-isa-list): New proc.
	(isa-supports?): Use it.
@
text
@d1204 1
a1204 1
	 (errtxt (string-append "cpu " name)))
@


1.5
log
@	* mach.scm (current-*-add!): Disallow redefinition.  Make result
	"unspecified".
	* insn.scm (insn-builtin!): Don't define relaxable here, now defined in
	operand.scm.
	* operand.scm (operand-builtin!): Define RELAXABLE for insns too.
	* cpu/m32r.cpu (disp8,disp24): RELAX renamed to RELAXABLE.

	* gen-all-doc: Split arm and frv docs up a bit.

	* cpu/arm.cpu: Add IDOC attribute.
	* cpu/frv.cpu: Ditto.
	* cpu/i960.cpu: Ditto.
	* cpu/openrisc.cpu: Ditto.
	* cpu/xstormy16.cpu: Ditto.
	* cpu/m32r.cpu: Ditto.
	(all insns): Explicitly specify IDOC attribute.

	* Makefile.am (MACH,ISAS,INSN_FILE_NAME): New vars.
	(desc,opcodes,sim-arch,sim-cpu,gas-test,sim-test): Use MACH,ISAS.
	(html): Use MACH,ISAS,INSN_FILE_NAME.  Generate insn.html separately.
	* Makefile.in: Regenerate.
	* attr.scm (<integer-attribute>:parse-value-def): Implement.
	(-attr-read): Defer computing default value until we know the type.
	(attr-has-attr?): Delete, move contents to <attr-list>:has-attr?.
	(<attr-list>:attr-present?): New method.
	(atlist-attr-present?,obj-attr-present?): New fns.
	(obj-has-attr-value?,obj-has-attr-value-no-default?): New fns.
	(attr-builtin!): New insn attr IDOC.
	* cgen-doc.scm (doc-arguments): New args -I,-N.
	* enum.scm (parse-enum-vals): New arg errtxt, all callers updated.
	Support comment as fourth element of enum value.
	(enum-val-name,enum-val-value,enum-val-attrs,enum-val-comment): New fns.
	* html.scm (gen-html-header): New arg kind, all callers updated.
	(gen-table-of-contents): New arg insn-file, all callers updated.
	(gen-list-entry,gen-doc-header): New fn.
	(get-operands): Delete.
	(gen-iformat-table): Rewrite.
	(gen-insn-doc-1): Print constant-folded and trimmed semantics.
	(gen-insn-doc-list): New args name, comment, insns.  All callers updated.
	(get-insn-properties,guess-insn-idoc-attr!): New fn.
	(insn-sets-pc?,insn-refs-mem?,insn-uses-fpu?): New fns.
	(get-insns-for-category,gen-categories-insn-lists): New fns.
	(gen-insn-docs): Simplify each insn's semantics first.
	Print insn tables sorted by IDOC categories.
	(*insn-html-file-name*): New global.
	(cgen-insn.html): New fn.
	(cgen-all): Update.
	* insn.scm (<insn>): Create a setter for the `tmp' member.
	* semantics.scm (insn-build-known-values): Renamed from
	-build-known-values.  All callers updated.

	* rtl.scm: Move traveral/evaluation support to ...
	* rtl-traverse.scm: New file.
	* read.scm: Maybe-load rtl-traverse.scm.

	* rtl.scm (-rtx-valid-types): Add SETRTX.

	* rtx-funcs.scm (nop,parallel): Fix mode.

	* utils.scm (eqv-lookup-index): New fn.
	(assq-lookup-index): Renamed from lookup-index.  All callers updated.

	* dev.scm (load-doc): Set APPLICATION.
@
text
@d281 1
a281 1
  (if (current-ifld-lookup (obj:name f))
d294 18
d317 1
a317 1
  (if (current-op-lookup (obj:name op))
d328 18
d362 1
a362 1
  (if (current-insn-lookup (obj:name i))
d373 18
d410 1
a410 1
  (if (current-minsn-lookup (obj:name m))
d421 18
d652 6
d662 1
a662 1
  (let ((isas (bitset-attr->list (obj-attr-value obj 'ISA)))
@


1.4
log
@	Better handling of 64 bit and mixed 32/64 bit architectures.
	* hardware.scm (hw-update-word-modes!): New fn.
	* mach.scm (define-cpu)): Call mode-set-word-modes!,
	hw-update-word-modes!.
	(state-word-bitsize): Replace FIXME with requested check.
	(arch-analyze-insns!): Call mode-ensure-word-sizes-defined.
	* mode.scm (mode-find): Ignore INT,UINT.
	(-mode-word-sizes-kind): New global.
	(mode-set-word-modes!,mode-set-identical-word-bitsizes!,
	mode-set-biggest-word-bitsizes!,mode-ensure-word-sizes-defined): New fns.
	(mode-init!): Initialize -mode-word-sizes-kind.  Move initialization
	of mode-list to ...
	(mode-builtin!): ... here.  Initialize WI/UWI/AI/IAI to something
	unusable, correct values set later.
	(mode-finish!): Remove cruft.
	* html.scm (doc-init!): Call mode-set-biggest-word-bitsizes!.
	* opcodes.scm (opcodes-init!): Ditto.
	* rtx-funcs.scm (annul): Fix mode of pc.
	* cpu/ia64.cpu: Remove cruft that sets word modes.
	* cpu/xstormy16.cpu (define-cpu): Set word-bitsize.
@
text
@d61 1
d142 1
d144 5
d161 1
d169 1
d171 2
d174 1
d176 1
d184 1
d186 2
d189 1
d191 1
d199 1
d201 2
d204 1
d206 1
d214 1
d216 2
d219 1
d221 1
d229 1
d231 2
d234 1
d236 1
d244 1
d246 2
d249 1
d251 1
d259 1
d261 2
d264 1
d266 1
d279 1
d281 2
d285 1
d287 1
d297 1
d299 2
d303 1
d305 1
d322 1
d324 1
d326 2
d330 1
d332 1
d354 1
d356 2
d360 1
d362 1
d370 4
a373 1
(define (current-subr-add! m)
d375 2
a376 1
		       (acons (obj:name m) m (arch-subr-list CURRENT-ARCH)))
d378 1
@


1.3
log
@	* Makefile.am (srcroot): New var.
	(html): New rule.
	* Makefile.in: Regenerate.
	* cgen-doc.scm: New file.
	* html.scm: New file.
	* gen-all-doc: New file.
	* dev.scm (cload): Handle DOC application.
	(load-doc): New fn.
	* machs.scm (machs-for-cpu): New fn.
	* model.scm (models-for-cpu): New fn.
	* utils.scm (gen-c-copyright): Renamed from gen-copyright.
	All uses updated.
	(iota): Rewrite to be identical to pmacro version.  All uses updated.
	* utils-cgen.scm (alpha-sort-obj-list): New fn.
@
text
@d1089 1
a1089 1
	  (word-bitsize nil)
d1131 5
a1135 1
	  (current-cpu-add! c))
d1260 2
a1261 1
; FIXME: Only user is opcodes.scm and we don't want this restriction there.
d1264 7
a1270 3
  (let ((wb (map cpu-word-bitsize (current-cpu-list))))
    ; FIXME: ensure all have same value.
    (car wb))
d1385 3
@


1.2
log
@* some support for funny-endian 16/32-bit insn sets

[cgen/ChangeLog]
2001-07-11  Frank Ch. Eigler  <fche@@redhat.com>

        * desc-cpu.scm (-gen-mach-table-defns): Emit fourth field: the
        mach->cpu insn-chunk-bitsize.
        (-gen-cpu-open): In @@arch@@_cgen_rebuild_tables, process above new
        field toward CGEN_CPU_TABLE->insn_chunk_bitsize.
        * mach.scm (<cpu>): New field insn-chunk-bitsize.
        (-cpu-parse, -cpu-read): Parse/initialize it.
        * doc/rtl.texi (define-cpu): Document it.

[opcodes/ChangeLog]
2001-07-11  Frank Ch. Eigler  <fche@@redhat.com>

        * cgen-dis.in (print_insn): Use cgen_get_insn_value instead of
        bfd_get_bits.
        * cgen-opc.c (cgen_get_insn_value, cgen_put_insn_value): Respect
        non-zero CGEN_CPU_DESC->insn_chunk_bitsize.

[include/opcode/ChangeLog]
2001-07-11  Frank Ch. Eigler  <fche@@redhat.com>

        * cgen.h (CGEN_MACH): Add insn_chunk_bitsize field.
        (cgen_cpu_desc): Ditto.
@
text
@d1160 7
@


1.1
log
@Initial revision
@
text
@d995 4
d1017 1
a1017 1
(define-getters <cpu> cpu (word-bitsize file-transform parallel-insns))
d1053 1
a1053 1
		    word-bitsize file-transform parallel-insns)
d1065 1
d1090 1
d1112 1
d1120 1
a1120 1
		  word-bitsize file-transform parallel-insns-)
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
