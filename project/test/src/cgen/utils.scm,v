head	1.42;
access;
symbols
	sid-snapshot-20180601:1.41
	cgen-snapshot-20180601:1.41
	sid-snapshot-20180501:1.41
	cgen-snapshot-20180501:1.41
	sid-snapshot-20180401:1.41
	cgen-snapshot-20180401:1.41
	sid-snapshot-20180301:1.40
	cgen-snapshot-20180301:1.40
	sid-snapshot-20180201:1.40
	cgen-snapshot-20180201:1.40
	sid-snapshot-20180101:1.40
	cgen-snapshot-20180101:1.40
	sid-snapshot-20171201:1.40
	cgen-snapshot-20171201:1.40
	sid-snapshot-20171101:1.40
	cgen-snapshot-20171101:1.40
	sid-snapshot-20171001:1.40
	cgen-snapshot-20171001:1.40
	sid-snapshot-20170901:1.40
	cgen-snapshot-20170901:1.40
	sid-snapshot-20170801:1.40
	cgen-snapshot-20170801:1.40
	sid-snapshot-20170701:1.40
	cgen-snapshot-20170701:1.40
	sid-snapshot-20170601:1.40
	cgen-snapshot-20170601:1.40
	sid-snapshot-20170501:1.40
	cgen-snapshot-20170501:1.40
	sid-snapshot-20170401:1.39
	cgen-snapshot-20170401:1.39
	sid-snapshot-20170301:1.39
	cgen-snapshot-20170301:1.39
	sid-snapshot-20170201:1.39
	cgen-snapshot-20170201:1.39
	sid-snapshot-20170101:1.39
	cgen-snapshot-20170101:1.39
	sid-snapshot-20161201:1.39
	cgen-snapshot-20161201:1.39
	sid-snapshot-20161101:1.39
	cgen-snapshot-20161101:1.39
	sid-snapshot-20160901:1.39
	cgen-snapshot-20160901:1.39
	sid-snapshot-20160801:1.39
	cgen-snapshot-20160801:1.39
	sid-snapshot-20160701:1.39
	cgen-snapshot-20160701:1.39
	sid-snapshot-20160601:1.39
	cgen-snapshot-20160601:1.39
	sid-snapshot-20160501:1.39
	cgen-snapshot-20160501:1.39
	sid-snapshot-20160401:1.38
	cgen-snapshot-20160401:1.38
	sid-snapshot-20160301:1.38
	cgen-snapshot-20160301:1.38
	sid-snapshot-20160201:1.38
	cgen-snapshot-20160201:1.38
	sid-snapshot-20160101:1.38
	cgen-snapshot-20160101:1.38
	sid-snapshot-20151201:1.38
	cgen-snapshot-20151201:1.38
	sid-snapshot-20151101:1.38
	cgen-snapshot-20151101:1.38
	sid-snapshot-20151001:1.38
	cgen-snapshot-20151001:1.38
	sid-snapshot-20150901:1.38
	cgen-snapshot-20150901:1.38
	sid-snapshot-20150801:1.38
	cgen-snapshot-20150801:1.38
	sid-snapshot-20150701:1.38
	cgen-snapshot-20150701:1.38
	sid-snapshot-20150601:1.38
	cgen-snapshot-20150601:1.38
	sid-snapshot-20150501:1.38
	cgen-snapshot-20150501:1.38
	sid-snapshot-20150401:1.38
	cgen-snapshot-20150401:1.38
	sid-snapshot-20150301:1.38
	cgen-snapshot-20150301:1.38
	sid-snapshot-20150201:1.38
	cgen-snapshot-20150201:1.38
	sid-snapshot-20150101:1.38
	cgen-snapshot-20150101:1.38
	sid-snapshot-20141201:1.38
	cgen-snapshot-20141201:1.38
	sid-snapshot-20141101:1.38
	cgen-snapshot-20141101:1.38
	sid-snapshot-20141001:1.38
	cgen-snapshot-20141001:1.38
	sid-snapshot-20140901:1.38
	cgen-snapshot-20140901:1.38
	sid-snapshot-20140801:1.38
	cgen-snapshot-20140801:1.38
	sid-snapshot-20140701:1.38
	cgen-snapshot-20140701:1.38
	sid-snapshot-20140601:1.38
	cgen-snapshot-20140601:1.38
	sid-snapshot-20140501:1.38
	cgen-snapshot-20140501:1.38
	sid-snapshot-20140401:1.38
	cgen-snapshot-20140401:1.38
	sid-snapshot-20140301:1.38
	cgen-snapshot-20140301:1.38
	sid-snapshot-20140201:1.38
	cgen-snapshot-20140201:1.38
	sid-snapshot-20140101:1.38
	cgen-snapshot-20140101:1.38
	sid-snapshot-20131201:1.38
	cgen-snapshot-20131201:1.38
	sid-snapshot-20131101:1.38
	cgen-snapshot-20131101:1.38
	sid-snapshot-20131001:1.38
	cgen-snapshot-20131001:1.38
	sid-snapshot-20130901:1.38
	cgen-snapshot-20130901:1.38
	sid-snapshot-20130801:1.38
	cgen-snapshot-20130801:1.38
	sid-snapshot-20130701:1.38
	cgen-snapshot-20130701:1.38
	sid-snapshot-20130601:1.38
	cgen-snapshot-20130601:1.38
	sid-snapshot-20130501:1.38
	cgen-snapshot-20130501:1.38
	sid-snapshot-20130401:1.38
	cgen-snapshot-20130401:1.38
	sid-snapshot-20130301:1.38
	cgen-snapshot-20130301:1.38
	sid-snapshot-20130201:1.38
	cgen-snapshot-20130201:1.38
	sid-snapshot-20130101:1.38
	cgen-snapshot-20130101:1.38
	sid-snapshot-20121201:1.38
	cgen-snapshot-20121201:1.38
	sid-snapshot-20121101:1.38
	cgen-snapshot-20121101:1.38
	sid-snapshot-20121001:1.38
	cgen-snapshot-20121001:1.38
	sid-snapshot-20120901:1.38
	cgen-snapshot-20120901:1.38
	sid-snapshot-20120801:1.38
	cgen-snapshot-20120801:1.38
	sid-snapshot-20120701:1.38
	cgen-snapshot-20120701:1.38
	sid-snapshot-20120601:1.38
	cgen-snapshot-20120601:1.38
	sid-snapshot-20120501:1.38
	cgen-snapshot-20120501:1.38
	sid-snapshot-20120401:1.38
	cgen-snapshot-20120401:1.38
	sid-snapshot-20120301:1.38
	cgen-snapshot-20120301:1.38
	sid-snapshot-20120201:1.38
	cgen-snapshot-20120201:1.38
	sid-snapshot-20120101:1.38
	cgen-snapshot-20120101:1.38
	sid-snapshot-20111201:1.38
	cgen-snapshot-20111201:1.38
	sid-snapshot-20111101:1.38
	cgen-snapshot-20111101:1.38
	sid-snapshot-20111001:1.38
	cgen-snapshot-20111001:1.38
	sid-snapshot-20110901:1.38
	cgen-snapshot-20110901:1.38
	sid-snapshot-20110801:1.38
	cgen-snapshot-20110801:1.38
	sid-snapshot-20110701:1.38
	cgen-snapshot-20110701:1.38
	sid-snapshot-20110601:1.38
	cgen-snapshot-20110601:1.38
	sid-snapshot-20110501:1.38
	cgen-snapshot-20110501:1.38
	sid-snapshot-20110401:1.38
	cgen-snapshot-20110401:1.38
	sid-snapshot-20110301:1.38
	cgen-snapshot-20110301:1.38
	sid-snapshot-20110201:1.38
	cgen-snapshot-20110201:1.38
	sid-snapshot-20110101:1.38
	cgen-snapshot-20110101:1.38
	sid-snapshot-20101201:1.38
	cgen-snapshot-20101201:1.38
	sid-snapshot-20101101:1.38
	cgen-snapshot-20101101:1.38
	sid-snapshot-20101001:1.38
	cgen-snapshot-20101001:1.38
	sid-snapshot-20100901:1.38
	cgen-snapshot-20100901:1.38
	sid-snapshot-20100801:1.38
	cgen-snapshot-20100801:1.38
	sid-snapshot-20100701:1.38
	cgen-snapshot-20100701:1.38
	sid-snapshot-20100601:1.38
	cgen-snapshot-20100601:1.38
	sid-snapshot-20100501:1.38
	cgen-snapshot-20100501:1.38
	sid-snapshot-20100401:1.38
	cgen-snapshot-20100401:1.38
	sid-snapshot-20100301:1.38
	cgen-snapshot-20100301:1.38
	sid-snapshot-20100201:1.38
	cgen-snapshot-20100201:1.38
	sid-snapshot-20100101:1.37
	cgen-snapshot-20100101:1.37
	sid-snapshot-20091201:1.37
	cgen-snapshot-20091201:1.37
	sid-snapshot-20091101:1.33
	cgen-snapshot-20091101:1.33
	sid-snapshot-20091001:1.32
	cgen-snapshot-20091001:1.32
	arc-sim-20090309:1.21
	sid-snapshot-20090901:1.29
	cgen-snapshot-20090901:1.29
	sid-snapshot-20090801:1.26
	cgen-snapshot-20090801:1.26
	sid-snapshot-20090701:1.22
	cgen-snapshot-20090701:1.22
	dje-cgen-play1-branch:1.22.0.2
	dje-cgen-play1-branchpoint:1.22
	cgen-1_1-branch:1.21.0.4
	cgen-1_1-branchpoint:1.21
	sid-snapshot-20090601:1.21
	cgen-snapshot-20090601:1.21
	sid-snapshot-20090501:1.21
	cgen-snapshot-20090501:1.21
	sid-snapshot-20090401:1.21
	cgen-snapshot-20090401:1.21
	arc-insight_6_8-branch:1.21.0.2
	arc-insight_6_8-branchpoint:1.21
	sid-snapshot-20090301:1.21
	cgen-snapshot-20090301:1.21
	sid-snapshot-20090201:1.21
	cgen-snapshot-20090201:1.21
	sid-snapshot-20090101:1.21
	cgen-snapshot-20090101:1.21
	sid-snapshot-20081201:1.21
	cgen-snapshot-20081201:1.21
	sid-snapshot-20081101:1.21
	cgen-snapshot-20081101:1.21
	sid-snapshot-20081001:1.21
	cgen-snapshot-20081001:1.21
	sid-snapshot-20080901:1.21
	cgen-snapshot-20080901:1.21
	sid-snapshot-20080801:1.21
	cgen-snapshot-20080801:1.21
	sid-snapshot-20080701:1.21
	cgen-snapshot-20080701:1.21
	sid-snapshot-20080601:1.21
	cgen-snapshot-20080601:1.21
	sid-snapshot-20080501:1.21
	cgen-snapshot-20080501:1.21
	sid-snapshot-20080403:1.21
	sid-snapshot-20080401:1.21
	cgen-snapshot-20080401:1.21
	sid-snapshot-20080301:1.21
	cgen-snapshot-20080301:1.21
	sid-snapshot-20080201:1.21
	cgen-snapshot-20080201:1.21
	sid-snapshot-20080101:1.21
	cgen-snapshot-20080101:1.21
	sid-snapshot-20071201:1.21
	cgen-snapshot-20071201:1.21
	sid-snapshot-20071101:1.21
	cgen-snapshot-20071101:1.21
	sid-snapshot-20071001:1.21
	cgen-snapshot-20071001:1.21
	msnyder-fork-checkpoint-branch:1.18.0.2
	msnyder-fork-checkpoint-branchpoint:1.18
	sid-20020905-branchpoint:1.7
	sid-20020905-branch:1.7.0.4
	cagney_regbuf-20020515-branch:1.7.0.2
	cagney_regbuf-20020515-branchpoint:1.7
	cygnus_cvs_20020108_pre:1.7
	cgen-1-1-branch:1.5.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.42
date	2019.01.01.11.51.25;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2018.03.03.01.31.31;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2017.04.07.22.38.16;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2016.04.22.02.03.49;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2010.01.02.17.53.10;	author devans;	state Exp;
branches;
next	1.37;

1.37
date	2009.11.24.16.39.21;	author devans;	state Exp;
branches;
next	1.36;

1.36
date	2009.11.23.09.03.01;	author devans;	state Exp;
branches;
next	1.35;

1.35
date	2009.11.05.16.55.33;	author devans;	state Exp;
branches;
next	1.34;

1.34
date	2009.11.03.16.24.02;	author devans;	state Exp;
branches;
next	1.33;

1.33
date	2009.10.24.00.01.26;	author devans;	state Exp;
branches;
next	1.32;

1.32
date	2009.09.23.22.30.19;	author devans;	state Exp;
branches;
next	1.31;

1.31
date	2009.09.09.08.00.16;	author devans;	state Exp;
branches;
next	1.30;

1.30
date	2009.09.07.22.17.34;	author devans;	state Exp;
branches;
next	1.29;

1.29
date	2009.08.20.17.03.29;	author devans;	state Exp;
branches;
next	1.28;

1.28
date	2009.08.07.21.29.20;	author devans;	state Exp;
branches;
next	1.27;

1.27
date	2009.08.06.21.52.08;	author devans;	state Exp;
branches;
next	1.26;

1.26
date	2009.07.22.18.30.59;	author devans;	state Exp;
branches;
next	1.25;

1.25
date	2009.07.21.04.23.59;	author devans;	state Exp;
branches;
next	1.24;

1.24
date	2009.07.13.20.55.21;	author devans;	state Exp;
branches;
next	1.23;

1.23
date	2009.07.10.03.20.14;	author devans;	state Exp;
branches;
next	1.22;

1.22
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2007.07.05.09.49.03;	author nickc;	state Exp;
branches
	1.21.4.1;
next	1.20;

1.20
date	2006.05.10.16.24.53;	author brolley;	state Exp;
branches;
next	1.19;

1.19
date	2006.05.09.18.24.22;	author brolley;	state Exp;
branches;
next	1.18;

1.18
date	2005.06.15.21.28.19;	author brolley;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.10.10.21.02;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.16.21.52.33;	author brolley;	state Exp;
branches;
next	1.15;

1.15
date	2005.01.27.20.31.12;	author jimb;	state Exp;
branches;
next	1.14;

1.14
date	2005.01.20.22.57.10;	author jimb;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.16.21.23.13;	author jimb;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.22.20.44.16;	author brolley;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.16.05.35.48;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.10.21.22.03;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.15.07.25.03;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.16.18.09.06;	author brolley;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.07.08.23.59;	author bje;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.07.07.05.05;	author bje;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.24.00.16.36;	author bje;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.15.17.42.29;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.21.04.08.30;	author bje;	state Exp;
branches;
next	1.2;

1.2
date	2000.11.10.16.43.21;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.22.2.1
date	2009.07.14.16.08.50;	author devans;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2009.07.14.16.19.51;	author devans;	state Exp;
branches;
next	;

1.21.4.1
date	2009.06.24.14.57.46;	author devans;	state Exp;
branches;
next	1.21.4.2;

1.21.4.2
date	2009.07.10.03.16.07;	author devans;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.42
log
@	* utils.scm: Update emitted copyright dates.
@
text
@; Generic Utilities.
; Copyright (C) 2000, 2005, 2006, 2007, 2009, 2010 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.

; These utilities are neither object nor cgen centric.
; They're generic, non application-specific utilities.
; There are a few exceptions, keep them to a minimum.
;
; Conventions:
; - the prefix "gen-" comes from cgen's convention that procs that return C
;   code, and only those procs, are prefixed with "gen-"

(define nil '())

; Hobbit support code; for when not using hobbit.
; FIXME: eliminate this stuff ASAP.

(defmacro /fastcall-make (proc) proc)

(defmacro fastcall4 (proc arg1 arg2 arg3 arg4)
  (list proc arg1 arg2 arg3 arg4)
)

(defmacro fastcall5 (proc arg1 arg2 arg3 arg4 arg5)
  (list proc arg1 arg2 arg3 arg4 arg5)
)

(defmacro fastcall6 (proc arg1 arg2 arg3 arg4 arg5 arg6)
  (list proc arg1 arg2 arg3 arg4 arg5 arg6)
)

(defmacro fastcall7 (proc arg1 arg2 arg3 arg4 arg5 arg6 arg7)
  (list proc arg1 arg2 arg3 arg4 arg5 arg6 arg7)
)

; Value doesn't matter too much here, just ensure it's portable.
(define *UNSPECIFIED* (if #f 1))

(define assert-fail-msg "assertion failure:")

(defmacro assert (expr)
  `(if (not ,expr)
       (error assert-fail-msg ',expr))
)

(define verbose-level 0)

(define (verbose-inc!)
  (set! verbose-level (+ verbose-level 1))
)

(define (verbose? level) (>= verbose-level level))

; Print to stderr, takes an arbitrary number of objects, possibly nested.
; ??? Audit callers, can we maybe just use "display" here (except that
; we still might want some control over the output).

(define message
  (lambda args
    (for-each (lambda (str)
		(if (pair? str)
		    (if (list? str)
			;; ??? Incorrect for improper lists, later.
			(begin
			  (message "(")
			  (for-each (lambda (s) (message s " ")) str)
			  (message ")"))
			(message "(" (car str) " . " (cdr str) ")"))
		    (display str (current-error-port))))
	      args))
)

; Print a message if the verbosity level calls for it.
; This is a macro as a bit of cpu may be spent computing args,
; and we only want to spend it if the result will be printed.

(defmacro logit (level . args)
  `(if (>= verbose-level ,level) (message ,@@args))
)

; Return a string of N spaces.

(define (spaces n) (make-string n #\space))

; Write N spaces to PORT, or the current output port if elided.

(define (write-spaces n . port)
  (let ((port (if (null? port) (current-output-port) (car port))))
    (write (spaces n) port))
)

; Concatenate all the arguments and make a string.  Symbols are
; converted to strings.
(define (string/symbol-append . sequences)
  (define (sequence->string o) (if (symbol? o) (symbol->string o) o))
  (apply string-append (map sequence->string sequences)))

; Often used idiom.

(define (string-map fn . args) (apply string-append (apply map (cons fn args))))

; Collect a flat list of returned sublists from the lambda fn applied over args.

(define (collect fn . args) (apply append (apply map (cons fn args))))

; Map over value entries in an alist.
; 'twould be nice if this were a primitive.

(define (amap fn args)
  (map fn (map cdr args))
)

; Like map but accept a proper or improper list.
; An improper list is (a b c . d).
; FN must be a proc of one argument.

(define (map1-improper fn l)
  (let ((result nil))
    (let loop ((last #f) (l l))
      (cond ((null? l)
	     result)
	    ((pair? l)
	     (if last
		 (begin
		   (set-cdr! last (cons (fn (car l)) nil))
		   (loop (cdr last) (cdr l)))
		 (begin
		   (set! result (cons (fn (car l)) nil))
		   (loop result (cdr l)))))
	    (else
	     (if last
		 (begin
		   (set-cdr! last (fn l))
		   result)
		 (fn l))))))
)

; Turn string or symbol STR into a proper C symbol.
; The result is a string.
; We assume STR has no leading digits.
; All invalid characters are turned into '_'.
; FIXME: Turn trailing "?" into "_p".

(define (gen-c-symbol str)
  (if (not (or (string? str) (symbol? str)))
      (error "gen-c-symbol: not symbol or string:" str))
  (map-over-string (lambda (c) (if (id-char? c) c #\_))
		   (->string str))
)

; Turn string or symbol STR into a proper file name, which is
; defined to be the same as gen-c-symbol except use -'s instead of _'s.
; The result is a string.

(define (gen-file-name str)
  (if (not (or (string? str) (symbol? str)))
      (error "gen-file-name: not symbol or string:" str))
  (map-over-string (lambda (c) (if (id-char? c) c #\-))
		   (->string str))
)

; Turn STR into lowercase.

(define (string-downcase str)
  (map-over-string (lambda (c) (char-downcase c)) str)
)

; Turn STR into uppercase.

(define (string-upcase str)
  (map-over-string (lambda (c) (char-upcase c)) str)
)

; Turn SYM into lowercase.

(define (symbol-downcase sym)
  (string->symbol (string-downcase (symbol->string sym)))
)

; Turn SYM into uppercase.

(define (symbol-upcase sym)
  (string->symbol (string-upcase (symbol->string sym)))
)

; Symbol sorter.

(define (symbol<? a b)
  (string<? (symbol->string a) (symbol->string b))
)

; Drop N chars from string S.
; If N is negative, drop chars from the end.
; It is ok to drop more characters than are in the string, the result is "".

(define (string-drop n s)
  (cond ((>= n (string-length s)) "")
	((< n 0) (substring s 0 (+ (string-length s) n)))
	(else (substring s n (string-length s))))
)

; Drop the leading char from string S (assumed to have at least 1 char).

(define (string-drop1 s)
  (string-drop 1 s)
)

; Return the leading N chars from string STR.
; This has APL semantics:
; N > length: FILLER chars are appended
; N < 0: take from the end of the string and prepend FILLER if necessary

(define (string-take-with-filler n str filler)
  (let ((len (string-length str)))
    (if (< n 0)
	(let ((n (- n)))
	  (string-append (if (> n len)
			     (make-string (- n len) filler)
			     "")
			 (substring str (max 0 (- len n)) len)))
	(string-append (substring str 0 (min len n))
		       (if (> n len)
			   (make-string (- n len) filler)
			   ""))))
)

(define (string-take n str)
  (string-take-with-filler n str #\space)
)

; Return the leading char from string S (assumed to have at least 1 char).

(define (string-take1 s)
  (substring s 0 1)
)

; Return the index of char C in string S or #f if not found.

(define (string-index s c)
  (let loop ((i 0))
    (cond ((= i (string-length s)) #f)
	  ((char=? c (string-ref s i)) i)
	  (else (loop (1+ i)))))
)

; Cut string S into a list of strings using delimiter DELIM (a character).

(define (string-cut s delim)
  (let loop ((start 0)
	     (end 0)
	     (length (string-length s))
	     (result nil))
    (cond ((= end length)
	   (if (> end start)
	       (reverse! (cons (substring s start end) result))
	       (reverse! result)))
	  ((char=? (string-ref s end) delim)
	   (loop (1+ end) (1+ end) length (cons (substring s start end) result)))
	  (else (loop start (1+ end) length result))))
)

; Convert a list of elements to a string, inserting DELIM (a string)
; between elements.
; L can also be a string or a number.

(define (stringize l delim)
  (cond ((string? l) l)
	((number? l) (number->string l))
	((symbol? l) (symbol->string l))
	((list? l)
	 (string-drop
	  (string-length delim)
	  (string-map (lambda (elm)
			(string-append delim
				       (stringize elm delim)))
		      l)))
	(else (error "stringize: can't handle:" l)))
)

; Same as string-append, but accepts symbols too.
; PERF: This implementation may be unacceptably slow.  Revisit.

(define stringsym-append
  (lambda args
    (apply string-append
	   (map (lambda (s)
		  (if (symbol? s)
		      (symbol->string s)
		      s))
		args)))
)

; Same as symbol-append, but accepts strings too.

(define symbolstr-append
  (lambda args
    (string->symbol (apply stringsym-append args)))
)

; Given a symbol or a string, return the string form.

(define (->string s)
  (if (symbol? s)
      (symbol->string s)
      s)
)

; Given a symbol or a string, return the symbol form.

(define (->symbol s)
  (if (string? s)
      (string->symbol s)
      s)
)

; Output routines.

;; Given some state that has a setter function (SETTER NEW-VALUE) and
;; a getter function (GETTER), call THUNK with the state set to VALUE,
;; and restore the original value when THUNK returns.  Ensure that the
;; original value is restored whether THUNK returns normally, throws
;; an exception, or invokes a continuation that leaves the call's
;; dynamic scope.

(define (setter-getter-fluid-let setter getter value thunk)
  (let ((swap (lambda ()
		(let ((temp (getter)))
		  (setter value)
		  (set! value temp)))))
    (dynamic-wind swap thunk swap)))
      

;; Call THUNK with the current input and output ports set to PORT, and
;; then restore the current ports to their original values.
;; 
;; This ensures the current ports get restored whether THUNK exits
;; normally, throws an exception, or leaves the call's dynamic scope
;; by applying a continuation.

(define (with-input-and-output-to port thunk)
  (setter-getter-fluid-let
   set-current-input-port current-input-port port
   (lambda ()
     (setter-getter-fluid-let
      set-current-output-port current-output-port port
      thunk))))


; Extension to the current-output-port.
; Only valid inside string-write.

(define /current-print-state #f)

; Create a print-state object.
; This is written in portable Scheme so we don't use COS objects, etc.

(define (make-print-state)
  (vector 'print-state 0)
)

; print-state accessors.

(define (pstate-indent pstate) (vector-ref pstate 1))
(define (pstate-set-indent! pstate indent) (vector-set! pstate 1 indent))

; Special print commands (embedded in args).

(define (pstate-cmd? x) (and (vector? x) (eq? (vector-ref x 0) 'pstate)))

;(define /endl (vector 'pstate '/endl)) ; ??? needed?
(define /indent (vector 'pstate '/indent))
(define (/indent-set n) (vector 'pstate '/indent-set n))
(define (/indent-add n) (vector 'pstate '/indent-add n))

; Process a pstate command.

(define (pstate-cmd-do pstate cmd)
  (assert (pstate-cmd? cmd))
  (case (vector-ref cmd 1)
    ((/endl)
     "\n")
    ((/indent)
     (let ((indent (pstate-indent pstate)))
       (string-append (make-string (quotient indent 8) #\tab)
		      (make-string (remainder indent 8) #\space))))
    ((/indent-set)
     (pstate-set-indent! pstate (vector-ref cmd 2))
     "")
    ((/indent-add)
     (pstate-set-indent! pstate (+ (pstate-indent pstate)
				   (vector-ref cmd 2)))
     "")
    (else
     (error "unknown pstate command" (vector-ref cmd 1))))
)

; Write STRINGS to current-output-port.
; STRINGS is a list of things to write.  Supported types are strings, symbols,
; lists, procedures.  Lists are printed by applying string-write recursively.
; Procedures are thunks that return the string to write.
;
; The result is the empty string.  This is for debugging where this
; procedure is modified to return its args, rather than write them out.

(define string-write
  (lambda strings
    (let ((pstate (make-print-state)))
      (set! /current-print-state pstate)
      (for-each (lambda (elm) (/string-write pstate elm))
		strings)
      (set! /current-print-state #f)
      ""))
)

; Subroutine of string-write and string-write-map.

(define (/string-write pstate expr)
  (cond ((string? expr) (display expr)) ; not write, we want raw text
	((symbol? expr) (display expr))
	((procedure? expr) (/string-write pstate (expr)))
	((pstate-cmd? expr) (display (pstate-cmd-do pstate expr)))
	((list? expr) (for-each (lambda (x) (/string-write pstate x)) expr))
	(else (error "string-write: bad arg:" expr)))
  *UNSPECIFIED*
)

; Combination of string-map and string-write.

(define (string-write-map proc arglist)
  (let ((pstate /current-print-state))
    (for-each (lambda (arg) (/string-write pstate (proc arg)))
	      arglist))
  ""
)

; Build up an argument for string-write.

(define string-list list)
(define string-list-map map)

; Subroutine of string-list->string.  Does same thing /string-write does.

(define (/string-list-flatten pstate strlist)
  (cond ((string? strlist) strlist)
	((symbol? strlist) strlist)
	((procedure? strlist) (/string-list-flatten pstate (strlist)))
	((pstate-cmd? strlist) (pstate-cmd-do pstate strlist))
	((list? strlist) (apply string-append
				(map (lambda (str)
				       (/string-list-flatten pstate str))
				     strlist)))
	(else (error "string-list->string: bad arg:" strlist)))
)

; Flatten out a string list.

(define (string-list->string strlist)
  (/string-list-flatten (make-print-state) strlist)
)

; Prefix CHARS, a string of characters, with backslash in STR.
; STR is either a string or list of strings (to any depth).
; ??? Quick-n-dirty implementation.

(define (backslash chars str)
  (if (string? str)
      ; quick check for any work to do
      (if (any-true? (map (lambda (c)
			    (string-index str c))
			  (string->list chars)))
	  (let loop ((result "") (str str))
	    (if (= (string-length str) 0)
		result
		(loop (string-append result
				     (if (string-index chars (string-ref str 0))
					 "\\"
					 "")
				     (substring str 0 1))
		      (substring str 1 (string-length str)))))
	  str)
      ; must be a list
      (if (null? str)
	  nil
	  (cons (backslash chars (car str))
		(backslash chars (cdr str)))))
)

; Return a boolean indicating if S is bound to a value.
;(define old-symbol-bound? symbol-bound?)
;(define (symbol-bound? s) (old-symbol-bound? #f s))

; Return a boolean indicating if S is a symbol and is bound to a value.

(define (bound-symbol? s)
  (and (symbol? s)
       (or (symbol-bound? #f s)
	   ;(module-bound? cgen-module s)
	   ))
)

; Return X.

(define (identity x) x)

; Test whether X is a `form' (non-empty list).
; ??? Is `form' the right word to use here?
; One can argue we should also test for a valid car.  If so, it's the
; name that's wrong not the code (because the code is what I want).

(define (form? x) (and (not (null? x)) (list? x)))

; Return the number of arguments to ARG-SPEC, a valid argument list
; of `lambda'.
; The result is a pair: number of fixed arguments, varargs indicator (#f/#t).

(define (num-args arg-spec)
  (if (symbol? arg-spec)
      '(0 . #t)
      (let loop ((count 0) (arg-spec arg-spec))
	(cond ((null? arg-spec) (cons count #f))
	      ((null? (cdr arg-spec)) (cons (+ count 1) #f))
	      ((pair? (cdr arg-spec)) (loop (+ count 1) (cdr arg-spec)))
	      (else (cons (+ count 1) #t)))))
)

; Return a boolean indicating if N args is ok to pass to a proc with
; an argument specification of ARG-SPEC (a valid argument list of `lambda').

(define (num-args-ok? n arg-spec)
  (let ((processed-spec (num-args arg-spec)))
    (and
     ; Ensure enough fixed arguments.
     (>= n (car processed-spec))
     ; If more args than fixed args, ensure varargs.
     (or (= n (car processed-spec))
	 (cdr processed-spec))))
)

; Take N elements from list L.
; If N is negative, take elements from the end.
; If N is larger than the length, the extra elements are NIL.
; FIXME: incomplete
; FIXME: list-tail has args reversed (we should conform)

(define (list-take n l)
  (let ((len (length l)))
    (if (< n 0)
	(list-tail l (+ len n))
	(let loop ((result nil) (l l) (i 0))
	  (if (= i n)
	      (reverse! result)
	      (loop (cons (car l) result) (cdr l) (+ i 1))))))
)

; Drop N elements from list L.
; FIXME: list-tail has args reversed (we should conform)

(define (list-drop n l)
  (let loop ((n n) (l l))
    (if (> n 0)
	(loop (- n 1) (cdr l))
	l))
)

; Drop N elements from the end of L.
; FIXME: list-tail has args reversed (we should conform)

(define (list-tail-drop n l)
  (reverse! (list-drop n (reverse l)))
)

;; left fold

(define (foldl kons accum lis) 
  (if (null? lis) accum 
      (foldl kons (kons accum (car lis)) (cdr lis))))

;; right fold

(define (foldr kons knil lis) 
  (if (null? lis) knil 
      (kons (car lis) (foldr kons knil (cdr lis)))))

;; filter list on predicate

(define (filter p ls)
  (foldr (lambda (x a) (if (p x) (cons x a) a)) 
	 '() ls))

; APL's +\ operation on a vector of numbers.

(define (plus-scan l)
  (letrec ((-plus-scan (lambda (l result)
			 (if (null? l)
			     result
			     (-plus-scan (cdr l)
					 (cons (if (null? result)
						   (car l)
						   (+ (car l) (car result)))
					       result))))))
    (reverse! (-plus-scan l nil)))
)

; Remove duplicate elements from sorted list L.
; Currently supported elements are symbols (a b c) and lists ((a) (b) (c)).
; NOTE: Uses equal? for comparisons.

(define (remove-duplicates l)
  (let loop ((l l) (result nil))
    (cond ((null? l) (reverse! result))
	  ((null? result) (loop (cdr l) (cons (car l) result)))
	  ((equal? (car l) (car result)) (loop (cdr l) result))
	  (else (loop (cdr l) (cons (car l) result)))
	  )
    )
)

; Return a boolean indicating if each element of list satisfies its
; corresponding predicates.  The length of L must be equal to the length
; of PREDS.

(define (list-elements-ok? l preds)
  (and (list? l)
       (= (length l) (length preds))
       (all-true? (map (lambda (pred elm) (pred elm)) preds l)))
)

; Remove duplicates from unsorted list L.
; KEY-GENERATOR is a lambda that takes a list element as input and returns
; an equal? key to use to determine duplicates.
; The first instance in a set of duplicates is always used.
; This is not intended to be applied to large lists with an expected large
; result (where sorting the list first would be faster), though one could
; add such support later.
;
; ??? Rename to follow memq/memv/member naming convention.

(define (nub l key-generator)
  (let loop ((l l) (keys (map key-generator l)) (result nil))
    (if (null? l)
	(reverse! (map cdr result))
	(if (assv (car keys) result)
	    (loop (cdr l) (cdr keys) result)
	    (loop (cdr l) (cdr keys) (acons (car keys) (car l)
					     result)))))
)

; Return a boolean indicating if list L1 is a subset of L2.
; Uses memq.

(define (subset? l1 l2)
  (let loop ((l1 l1))
    (if (null? l1)
	#t
	(if (memq (car l1) l2)
	    (loop (cdr l1))
	    #f)))
)

; Return intersection of two lists.

(define (intersection a b) 
  (foldl (lambda (l e) (if (memq e a) (cons e l) l)) '() b))

; Return #t if the intersection of A and B is non-null.

(define (non-null-intersection? a b)
  (let loop ((todo a))
    (cond ((null? todo)
	   #f)
	  ((memq (car todo) b)
	   #t)
	  (else
	   (loop (cdr todo)))))
)

; Return union of two lists.

(define (union a b) 
  (foldl (lambda (l e) (if (memq e l) l (cons e l))) a b))

; Return a count of the number of elements of list L1 that are in list L2.
; Uses memq.

(define (count-common l1 l2)
  (let loop ((result 0) (l1 l1))
    (if (null? l1)
	result
	(if (memq (car l1) l2)
	    (loop (+ result 1) (cdr l1))
	    (loop result (cdr l1)))))
)

; Remove duplicate elements from sorted alist L.
; L must be sorted by name.

(define (alist-nub l)
  (let loop ((l l) (result nil))
    (cond ((null? l) (reverse! result))
	  ((null? result) (loop (cdr l) (cons (car l) result)))
	  ((eq? (caar l) (caar result)) (loop (cdr l) result))
	  (else (loop (cdr l) (cons (car l) result)))
	  )
    )
)

; Return a copy of alist L.

(define (alist-copy l)
  ; (map cons (map car l) (map cdr l)) ; simple way
  ; presumably more efficient way (less cons cells created)
  (map (lambda (elm)
	 (cons (car elm) (cdr elm)))
       l)
)

; Return the order in which to select elements of L sorted by SORT-FN.
; The result is origin 0.

(define (sort-grade l sort-fn)
  (let ((sorted (sort (map cons (iota (length l)) l)
		      (lambda (a b) (sort-fn (cdr a) (cdr b))))))
    (map car sorted))
)

; Return ALIST sorted on the name in ascending order.

(define (alist-sort alist)
  (sort alist
	(lambda (a b)
	  (string<? (symbol->string (car a))
		    (symbol->string (car b)))))
)

; Return a boolean indicating if C is a leading id char.
; '@@' is treated as an id-char as it's used to delimit something that
; sed will alter.

(define (leading-id-char? c)
  (or (char-alphabetic? c)
      (char=? c #\_)
      (char=? c #\@@))
)

; Return a boolean indicating if C is an id char.
; '@@' is treated as an id-char as it's used to delimit something that
; sed will alter.

(define (id-char? c)
  (or (leading-id-char? c)
      (char-numeric? c))
)

; Return the length of the identifier that begins S.
; Identifiers are any of letter, digit, _, @@.
; The first character must not be a digit.
; ??? The convention is to use "-" between cgen symbols, not "_".
; Try to handle "-" here as well.

(define (id-len s)
  (if (leading-id-char? (string-ref s 0))
      (let ((len (string-length s)))
	(let loop ((n 0))
	  (if (and (< n len)
		   (id-char? (string-ref s n)))
	      (loop (1+ n))
	      n)))
      0)
)

; Return number of characters in STRING until DELIMITER.
; Returns #f if DELIMITER not present.
; FIXME: Doesn't yet support \-prefixed delimiter (doesn't terminate scan).

(define (chars-until-delimiter string delimiter)
  (let loop ((str string) (result 0))
    (cond ((= (string-length str) 0)
	   #f)
	  ((char=? (string-ref str 0) delimiter)
	   result)
	  (else (loop (string-drop1 str) (1+ result)))))
)

; Apply FN to each char of STR.

(define (map-over-string fn str)
  (do ((tmp (string-copy (if (symbol? str) (symbol->string str) str)))
       (i (- (string-length str) 1) (- i 1)))
      ((< i 0) tmp)
    (string-set! tmp i (fn (string-ref tmp i)))
    )
)

; Return a range.
; It must be distinguishable from a list of numbers.

(define (minmax min max) (cons min max))

; Move VALUE of LENGTH bits to position START in a word of SIZE bits.
; LSB0? is non-#f if bit numbering goes LSB->MSB.
; Otherwise it goes MSB->LSB.
; START-LSB? is non-#f if START denotes the least significant bit.
; Otherwise START denotes the most significant bit.
; N is assumed to fit in the field.

(define (word-value start length size lsb0? start-lsb? value)
  (if lsb0?
      (if start-lsb?
	  (logsll value start)
	  (logsll value (+ (- start length) 1)))
      (if start-lsb?
	  (logsll value (- size start 1))
	  (logsll value (- size (+ start length)))))
)

; Return a bit mask of LENGTH bits in a word of SIZE bits starting at START.
; LSB0? is non-#f if bit numbering goes LSB->MSB.
; Otherwise it goes MSB->LSB.
; START-LSB? is non-#f if START denotes the least significant bit.
; Otherwise START denotes the most significant bit.

(define (word-mask start length size lsb0? start-lsb?)
  (if lsb0?
      (if start-lsb?
	  (logsll (mask length) start)
	  (logsll (mask length) (+ (- start length) 1)))
      (if start-lsb?
	  (logsll (mask length) (- size start 1))
	  (logsll (mask length) (- size (+ start length)))))
)

; Extract LENGTH bits at bit number START in a word of SIZE bits from VALUE.
; LSB0? is non-#f if bit numbering goes LSB->MSB.
; Otherwise it goes MSB->LSB.
; START-LSB? is non-#f if START denotes the least significant bit.
; Otherwise START denotes the most significant bit.
;
; ??? bit-extract takes a big-number argument but still uses logand
; which doesn't so we don't use it

(define (word-extract start length size lsb0? start-lsb? value)
  (if lsb0?
      (if start-lsb?
	  (remainder (logslr value start) (integer-expt 2 length))
	  (remainder (logslr value (+ (- start length) 1)) (integer-expt 2 length)))
      (if start-lsb?
	  (remainder (logslr value (- size start 1)) (integer-expt 2 length))
	  (remainder (logslr value (- size (+ start length))) (integer-expt 2 length))))
)

; Return numeric value of bit N in a word of size WORD-BITSIZE.

(define (word-bit-value bitnum word-bitsize lsb0?)
  (assert (< bitnum word-bitsize))
  (if lsb0?
      (ash 1 bitnum)
      (ash 1 (- word-bitsize bitnum 1)))
)

; Return a bit mask of size SIZE beginning at the LSB.

(define (mask size)
  (- (logsll 1 size) 1)
)

; Split VAL into pieces of bit size LENGTHS.
; e.g. (split-bits '(8 2) 997) -> (229 3)
; There are as many elements in the result as there are in LENGTHS.
; Note that this can result in a loss of information.

(define (split-bits lengths val)
  (letrec ((split1
	    (lambda (lengths val result)
	      (if (null? lengths)
		  result
		  (split1 (cdr lengths)
			  (quotient val (integer-expt 2 (car lengths)))
			  (cons (remainder val (integer-expt 2 (car lengths)))
				result))))))
    (reverse! (split1 lengths val nil)))
)

; Generalized version of split-bits.
; e.g. (split-value '(10 10 10) 1234) -> (4 3 2 1) ; ??? -> (1 2 3 4) ?
; (split-value '(10 10) 1234) -> (4 3)
; There are as many elements in the result as there are in BASES.
; Note that this can result in a loss of information.

(define (split-value bases val)
  (letrec ((split1
	    (lambda (bases val result)
	      (if (null? bases)
		  result
		  (split1 (cdr bases)
			  (quotient val (car bases))
			  (cons (remainder val (car bases))
				result))))))
    (reverse! (split1 bases val nil)))
)

; Convert bits to bytes.

(define (bits->bytes bits) (quotient (+ 7 bits) 8))

; Convert bytes to bits.

(define (bytes->bits bytes) (* bytes 8))

; Return a list of integers.
; Usage:
; (.iota count)            ; start=0, incr=1
; (.iota count start)      ; incr=1
; (.iota count start incr)

(define (iota count . start-incr)
  (if (> (length start-incr) 2)
      (error "iota: wrong number of arguments:" start-incr))
  (if (< count 0)
      (error "iota: count must be non-negative:" n))
  (let ((start (if (pair? start-incr) (car start-incr) 0))
	(incr (if (= (length start-incr) 2) (cadr start-incr) 1)))
    (let loop ((i start) (count count) (result '()))
      (if (= count 0)
	  (reverse! result)
	  (loop (+ i incr) (- count 1) (cons i result)))))
)

; Return a list of the first N powers of 2.

(define (powers-of-2 n)
  (cond ((= n 0) nil)
	(else (cons (integer-expt 2 (1- n)) (powers-of-2 (1- n))))
	)
  ; Another way: (map (lambda (n) (ash 1 n)) (iota n))
)

; I'm tired of writing (not (= foo bar)).

(define (!= a b) (not (= a b)))

; Return #t if BIT-NUM (which is starting from LSB), is set in the binary
; representation of non-negative integer N.

(define (bit-set? n bit-num)
  ; ??? Quick hack to work around missing bignum support.
  ;(= 1 (cg-logand (logslr n bit-num) 1))
  (if (>= n #x20000000)
      (if (>= bit-num 16)
	  (logbit? (- bit-num 16) (logslr n 16))
	  (logbit? bit-num (remainder n 65536)))
      (logbit? bit-num n))
)

; Return #t if each element of bools is #t.  Since Scheme considers any
; non-#f value as #t we do too.
; (all-true? '()) is #t since that is the identity element.

(define (all-true? bools)
  (cond ((null? bools) #t)
	((car bools) (all-true? (cdr bools)))
	(else #f))
)

; Return #t if any element of BOOLS is #t.
; If BOOLS is empty, return #f.

(define (any-true? bools)
  (cond ((null? bools) #f)
	((car bools) #t)
	(else (any-true? (cdr bools))))
)

; Return count of true values.

(define (count-true flags)
  (let loop ((result 0) (flags flags))
    (if (null? flags)
	result
	(loop (+ result (if (car flags) 1 0))
	      (cdr flags))))
)

; Return count of all ones in BITS.

(define (count-bits bits)
  (let loop ((result 0) (bits bits))
    (if (= bits 0)
	result
	(loop (+ result (remainder bits 2)) (quotient bits 2))))
)

; Convert bits in N #f/#t.
; LENGTH is the length of N in bits.

(define (bits->bools n length)
  (do ((result (make-list length #f))
       (i 0 (+ i 1)))
      ((= i length) (reverse! result))
    (list-set! result i (if (bit-set? n i) #t #f))
    )
)

; Print a C integer.

(define (gen-integer val)
  (cond ((and (<= #x-80000000 val) (> #x80000000 val))
	 (number->string val))
	((and (<= #x80000000 val) (>= #xffffffff val))
	 ; ??? GCC complains if not affixed with "U" but that's not k&r.
	 ;(string-append (number->string val) "U"))
	 (string-append "0x" (number->string val 16)))
	(else (error "Number too large for gen-integer:" val)))
)

; Return higher/lower part of double word integer.

(define (high-part val)
  (logslr val 32)
)
(define (low-part val)
  (remainder val #x100000000)
)

; Logical operations.

(define (logslr val shift) (ash val (- shift)))
(define logsll ash) ; (logsll val shift) (ash val shift))

; logand, logior, logxor defined by guile so we don't need to
; (define (logand a b) ...)
; (define (logxor a b) ...)
; (define (logior a b) ...)
;
; On the other hand they didn't support bignums, so the cgen-binary
; defines cg-log* that does.  These are just a quick hack that only
; handle what currently needs handling.

(define (cg-logand a b)
  (if (or (>= a #x20000000)
	  (>= b #x20000000))
      (+ (logsll (logand (logslr a 16) (logslr b 16)) 16)
	 (logand (remainder a 65536) (remainder b 65536)))
      (logand a b))
)

(define (cg-logxor a b)
  (if (or (>= a #x20000000)
	  (>= b #x20000000))
      (+ (logsll (logxor (logslr a 16) (logslr b 16)) 16)
	 (logxor (remainder a 65536) (remainder b 65536)))
      (logxor a b))
)

; Return list of bit values for the 1's in X.

(define (bit-vals x)
  (let loop ((result nil) (mask 65536))
    (cond ((= mask 0) result)
	  ((> (logand x mask) 0) (loop (cons mask result) (logslr mask 1)))
	  (else (loop result (logslr mask 1)))))
)

; Return bit representation of N in LEN bits.
; e.g. (bit-rep 6 3) -> (1 1 0)

(define (bit-rep n len)
  (cond ((= len 0) nil)
	((> (logand n (logsll 1 (- len 1))) 0)
	 (cons 1 (bit-rep n (- len 1))))
	(else (cons 0 (bit-rep n (- len 1))))))

; Return list of all bit values from 0 to N.
; e.g. (bit-patterns 3) -> ((0 0 0) (0 0 1) (0 1 0) ... (1 1 1))

(define (bit-patterns len)
  (map (lambda (x) (bit-rep x len)) (iota (logsll 1 len)))
)

; Compute the list of all indices from bits missing in MASK.
; e.g. (missing-bit-indices #xff00 #xffff) -> (0 1 2 3 ... 255)

(define (missing-bit-indices mask full-mask)
  (let* ((bitvals (bit-vals (logxor mask full-mask)))
	 (selectors (bit-patterns (length bitvals)))
	 (map-star (lambda (sel) (map * sel bitvals)))
	 (compute-indices (lambda (sel) (apply + (map-star sel)))))
    (map compute-indices selectors))
)

; Return #t if n is a non-negative integer.

(define (non-negative-integer? n)
  (and (integer? n)
       (>= n 0))
)

; Convert a list of numbers to a string, separated by SEP.
; The result is prefixed by SEP too.

(define (numbers->string nums sep)
  (string-map (lambda (elm) (string-append sep (number->string elm))) nums)
)

; Convert a number to a hex string.

(define (number->hex num)
  (number->string num 16)
)

; Convert a number to a hex C constant,
; taking care to handle large numbers.
; If NUM won't fit in a portable int (32-bits), cast it to BIG-NUM-TYPE.

(define (gen-c-hex-constant num big-num-type)
  (cond ((< num (- (ash 1 31)))
	 ;; Skip outputting -ve numbers in hex for now.
	 (string-append "((" big-num-type ") " (number->string num) "LL)"))
	((> num (- (ash 1 32) 1))
	 (string-append "((" big-num-type ") 0x" (number->string num 16) "LL)"))
	(else
	 (string-append "0x" (number->string num 16))))
)

; Given a list of numbers NUMS, generate text to pass them as arguments to a
; C function.  We assume they're not the first argument and thus have a
; leading comma.

(define (gen-int-args nums)
  (numbers->string nums ", ")
)

; Given a C expression or a list of C expressions, return a comma separated
; list of them.
; In the case of more than 0 elements the leading ", " is present so that
; there is no edge case in the case of 0 elements when the caller is appending
; the result to an initial set of arguments (the number of commas equals the
; number of elements).  The caller is responsible for dropping the leading
; ", " if necessary.  Note that `string-drop' can handle the case where more
; characters are dropped than are present.

(define (gen-c-args exprs)
  (cond ((null? exprs) "")
	((pair? exprs) (string-map (lambda (elm) (string-append ", " elm))
				   exprs))
	((equal? exprs "") "")
	(else (string-append ", " exprs)))
)

; Return a list of N macro argument names.

(define (macro-args n)
  (map (lambda (i) (string-append "a" (number->string i)))
       (map 1+ (iota n)))
)

; Return C code for N macro argument names.
; (gen-macro-args 4) -> ", a1, a2, a3, a4"

(define (gen-macro-args n)
  (gen-c-args (macro-args n))
)

; Return a string to reference an array.
; INDICES is either a (possibly empty) list of indices or a single index.
; The values can either be numbers or strings (/symbols).

(define (gen-array-ref indices)
  (let ((gen-index (lambda (idx)
		     (string-append "["
				    (cond ((number? idx) (number->string idx))
					  (else idx))
				    "]"))))
    (cond ((null? indices) "")
	  ((pair? indices) ; list of indices?
	   (string-map gen-index indices))
	  (else (gen-index indices))))
)

; Return list element N or #f if list L is too short.

(define (list-maybe-ref l n)
  (if (> (length l) n)
      (list-ref l n)
      #f)
)

; Return list of index numbers of elements in list L that satisfy PRED.
; I is added to each index, it's usually 0.

(define (find-index i pred l)
  (define (find1 i pred l result)
    (cond ((null? l) result)
	  ((pred (car l)) (find1 (+ 1 i) pred (cdr l) (cons i result)))
	  (else (find1 (+ 1 i) pred (cdr l) result))))
  (reverse! (find1 i pred l nil))
)

; Return index number of first element in list L that satisfy PRED.
; Returns #f if not present.
; I is added to the result, it's usually 0.

(define (find-first-index i pred l)
  (cond ((null? l) #f)
	((pred (car l)) i)
	(else (find-first-index (+ 1 i) pred (cdr l))))
)

; Return list of elements of L that satisfy PRED.

(define (find pred l)
  (define (find1 pred l result)
    (cond ((null? l) result)
	  ((pred (car l)) (find1 pred (cdr l) (cons (car l) result)))
	  (else (find1 pred (cdr l) result))))
  (reverse! (find1 pred l nil))
)

; Return first element of L that satisfies PRED or #f if there is none.

(define (find-first pred l)
  (cond ((null? l) #f)
	((pred (car l)) (car l))
	(else (find-first pred (cdr l))))
)

; Return list of FN applied to elements of L that satisfy PRED.

(define (find-apply fn pred l)
  (cond ((null? l) nil)
	((pred (car l)) (cons (fn (car l)) (find-apply fn pred (cdr l))))
	(else (find-apply fn pred (cdr l))))
)

; Given a list L, look up element ELM and return its index.
; If not found, return #f.
; I is added to the result.
; (Yes, in one sense I is present to simplify the implementation.  Sue me.)

(define (eqv-lookup-index elm l i)
  (cond ((null? l) #f)
	((eqv? elm (car l)) i)
	(else (eqv-lookup-index elm (cdr l) (1+ i))))
)

; Given an associative list L, look up entry for symbol S and return its index.
; If not found, return #f.
; Eg: (lookup 'element2 '((element1 1) (element2 2)))
; I is added to the result.
; (Yes, in one sense I is present to simplify the implementation.  Sue me.)
; NOTE: Uses eq? for comparisons.

(define (assq-lookup-index s l i)
  (cond ((null? l) #f)
	((eqv? s (caar l)) i)
	(else (assq-lookup-index s (cdr l) (1+ i))))
)

; Return the index of element ELM in list L or #f if not found.
; If found, I is added to the result.
; (Yes, in one sense I is present to simplify the implementation.  Sue me.)
; NOTE: Uses equal? for comparisons.

(define (element-lookup-index elm l i)
  (cond ((null? l) #f)
	((equal? elm (car l)) i)
	(else (element-lookup-index elm (cdr l) (1+ i))))
)

; Return #t if ELM is in ELM-LIST.
; NOTE: Uses equal? for comparisons (via `member').

(define (element? elm elm-list)
  (->bool (member elm elm-list))
)

; Return the set of all possible combinations of elements in list L
; according to the following rules:
; - each element of L is either an atom (non-list) or a list
; - each list element is (recursively) interpreted as a set of choices
; - the result is a list of all possible combinations of elements
;
; Example: (list-expand '(a b (1 2 (3 4)) c (5 6)))
; --> ((a b 1 c d 5)
;      (a b 1 c d 6)
;      (a b 2 c d 5)
;      (a b 2 c d 6)
;      (a b 3 c d 5)
;      (a b 3 c d 6)
;      (a b 4 c d 5)
;      (a b 4 c d 6))

(define (list-expand l)
  (error "wip")
)

; If OBJ has a dump method call it, otherwise return OBJ untouched.

(define (dump obj)
  (if (method-present? obj 'dump)
      (send obj 'dump)
      obj)
)

; Copyright messages.

; Pair of header,trailer parts of copyright.

(define copyright-fsf
  (cons "\
THIS FILE IS MACHINE GENERATED WITH CGEN.

Copyright (C) 1996-2019 Free Software Foundation, Inc.
"
	"\
   This file is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License along
   with this program; if not, write to the Free Software Foundation, Inc.,
   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
"
))

; Pair of header,trailer parts of copyright.

(define copyright-red-hat
  (cons "\
THIS FILE IS MACHINE GENERATED WITH CGEN.

Copyright (C) 2000-2019 Red Hat, Inc.
"
	"\
"))

; Set this to one of copyright-fsf, copyright-red-hat.

(define CURRENT-COPYRIGHT copyright-fsf)

; Packages.

(define package-gnu-binutils-gdb "\
This file is part of the GNU Binutils and/or GDB, the GNU debugger.
")

(define package-gnu-simulators "\
This file is part of the GNU simulators.
")

(define package-red-hat-simulators "\
This file is part of the Red Hat simulators.
")

(define package-cgen "\
This file is part of CGEN.
")

; Return COPYRIGHT, with FILE-DESC as the first line
; and PACKAGE as the name of the package which the file belongs in.
; COPYRIGHT is a pair of (header . trailer).

(define (gen-c-copyright file-desc copyright package)
  (string-append "/* " file-desc "\n\n"
		 (car copyright)
		 "\n" package "\n"
		 (cdr copyright)
		 "\n*/\n\n")
)

; File operations.

; Delete FILE, handling the case where it doesn't exist.

(define (delete-file-noerr file)
  ; This could also use file-exists?, but it's nice to have a few examples
  ; of how to use `catch' lying around.
  (catch 'system-error (lambda () (delete-file file))
	 (lambda args #f))
)

; Create FILE, point current-output-port to it, and call WRITE-FN.
; FILE is always overwritten.
; GEN-FN either writes output to stdout or returns the text to write,
; the last thing we do is write the text returned by WRITE-FN to FILE.

(define (file-write file write-fn)
  (delete-file-noerr file)
  (let ((left-over-text (with-output-to-file file write-fn)))
    (let ((port (open-file file "a")))
      (display left-over-text port)
      (close-port port))
    #t)
)

; Return the size in bytes of FILE.

(define (file-size file)
  (let ((stat (%stat file)))
    (if stat
	(vector-ref (%stat file) 7)
	-1))
)

; Time operations.

; Return the current time.
; The result is a black box understood only by time-elapsed.

(define (time-current) (gettimeofday))

; Return the elapsed time in milliseconds since START.

(define (time-elapsed start)
  (let ((now (gettimeofday)))
    (+ (* (- (car now) (car start)) 1000)
       (quotient (- (cdr now) (cdr start)) 1000)))
)

; Run PROC and return the number of milliseconds it took to execute it N times.

(define (time-proc n proc)
  (let ((now (time-current)))
    (do ((i 0 (+ i 1))) ((= i n) (time-elapsed now))
      (proc)))
)

;; Debugging repls.

; Record of arguments passed to debug-repl, so they can be accessed in
; the repl loop.

(define debug-env #f)

; Return list of recorded variables for debugging.

(define (debug-var-names) (map car debug-env))

; Return value of recorded var NAME.

(define (debug-var name) (assq-ref debug-env name))

; A handle on /dev/tty, so we can be sure we're talking with the user.
; We open this the first time we actually need it.

(define debug-tty #f)

; Return the port we should use for interacting with the user,
; opening it if necessary.

(define (debug-tty-port)
  (if (not debug-tty)
      (set! debug-tty (open-file "/dev/tty" "r+")))
  debug-tty)

; Enter a repl loop for debugging purposes.
; Use (quit) to exit cgen completely.
; Use (debug-quit) or (quit 0) to exit the debugging session and
; resume argument processing.
;
; ENV-ALIST can be anything, but it is intended to be an alist of values
; the caller will want to be able to access in the repl loop.
; It is stored in global `debug-env'.

(define (debug-repl env-alist)
  (with-input-and-output-to
   (debug-tty-port)
   (lambda ()
     (set! debug-env env-alist)
     (let loop ()
       (let ((rc (top-repl)))
	 (if (null? rc)
	     (quit 1))			; indicate error to `make'
	 (if (not (equal? rc '(0)))
	     (loop))))))
)

; Utility for debug-repl.

(define (debug-quit)
  ; Keep around for later debugging.
  ;(set! debug-env #f)

  (quit 0)
)

; Macro to simplify calling debug-repl.
; Usage: (debug-repl-env var-name1 var-name2 ...)
;
; This is for debugging cgen itself, and is inserted into code at the point
; where one wants to start a repl.

(defmacro debug-repl-env var-names
  (let ((env (map (lambda (var-name)
		    (list 'cons (list 'quote var-name) var-name))
		  var-names)))
    (list 'debug-repl (cons 'list env)))
)
@


1.41
log
@binutils opcodes error messages

This patch is aimed at making binutils/opcodes files comply with the
GNU coding standard regarding error messages, that is, they should
start with the program name followed by a colon, then a lower case
message.  Accomplished by calling opcodes_error_handler to output the
program name (and final '\n'), rather than calling fprintf.

	* desc-cpu.scm (opcodes_error_handler): Define.
	(@@arch@@_cgen_rebuild_tables): Use opcodes_error_handler.
	(@@arch@@_cgen_cpu_open): Likewise.
	* opc-asmdis.scm (@@arch@@_cgen_parse_operand): Likewise.
	(@@arch@@_cgen_print_operand): Likewise.
	* opc-ibld.scm (@@arch@@_cgen_get_int_operand): Likewise.
	(@@arch@@_cgen_get_vma_operand): Likewise.
	(@@arch@@_cgen_set_int_operand): Likewise.
	(@@arch@@_cgen_set_vma_operand): Likewise.
	(@@arch@@_cgen_insert_operand): Likewise.
	(@@arch@@_cgen_extract_operand): Likewise.
	* utils.scm: Update emitted copyright dates.
@
text
@d1313 1
a1313 1
Copyright (C) 1996-2018 Free Software Foundation, Inc.
d1338 1
a1338 1
Copyright (C) 2000-2018 Red Hat, Inc.
@


1.40
log
@	* utils.scm: Update emitted copyright dates.
@
text
@d1313 1
a1313 1
Copyright (C) 1996-2017 Free Software Foundation, Inc.
d1338 1
a1338 1
Copyright (C) 2000-2017 Red Hat, Inc.
@


1.39
log
@Update emitted copyright notice dates

	* utils.scm: Update emitted copyright dates.
@
text
@d1313 1
a1313 1
Copyright (C) 1996-2016 Free Software Foundation, Inc.
d1338 1
a1338 1
Copyright (C) 2000-2016 Red Hat, Inc.
@


1.38
log
@	* utils.scm (copyright-fsf, copyright-red-hat): Update copyright year.
@
text
@d1313 1
a1313 1
Copyright 1996-2010 Free Software Foundation, Inc.
d1338 1
a1338 1
Copyright (C) 2000-2010 Red Hat, Inc.
@


1.37
log
@(list-expand): Flag wip better.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2005, 2006, 2007, 2009 Red Hat, Inc.
d1313 1
a1313 1
Copyright 1996-2009 Free Software Foundation, Inc.
d1338 1
a1338 1
Copyright (C) 2000-2009 Red Hat, Inc.
@


1.36
log
@	* hardware.scm (hw-pc?): New function.
	* ifield.scm (ifld-signed?): New function.
	* iformat.scm (ifmt-analyze): Call insn-cti-attr? instead of insn-cti?.
	* insn.scm (insn-cti-attr?): Renamed from insn-ctl?.
	(insn-cti?): New function.
	* rtl.scm (/hw): Create <pc> object for pcs.
	* semantics.scm (/build-reg-operand!): New args ref-type, sem-attrs.
	All callers updated.  Watch for sets to the pc.
	(semantic-attrs): Watch for sets to the pc.
	* sid.scm (<pc> cxmake-get): Handle raw-reg.
	* sim.scm (<pc> cxmake-get): Handle raw-reg.
	(<operand> cxmake-get): Add debugging printf.
	* utils-gen.scm (/gen-ifld-extract-base): Emit calls to
	EXTRACT_[LM]SB0_LG[SU]INT for values > 32 bits.
	(/gen-extract-word): Ditto.

	* utils.scm (gen-c-hex-constant): New function.
	* utils-sim.scm (/gen-decode-insn-entry): Call it.
@
text
@d1294 1
a1294 1
  #f ; ??? wip
@


1.35
log
@	* utils.scm (reduce): Delete.

	* rtl-traverse.scm (/rtx-canon-rtx-enum): Tweak local name.

	* enum.scm (gen-enum-sym): Make consistent with gen-enum-decl
	regarding PREFIX attribute handling.

	* operand.scm (<hw-index>): Add enum to possible types, all uses
	updated.
	(hw-index-constant?, hw-index-constant-value): New functions.
	(make-enum-hw-index, hw-index-enum-name, hw-index-enum-value,
	hw-index-enum-obj): New functions.
	(/operand-parse): Handle enum indices.
	* intrinsics.scm (md-operand:fixed-register): Use hw-index-constant?,
	hw-index-constant-value.
	* rtl.scm (rtx-constant-value): Fix handling of enums.
	* rtx-funcs.scm (enum): Ditto.
	* sid.scm (<hardware-base> cxmake-get): Only ifield indices are
	currently supported here.
@
text
@d1111 14
@


1.34
log
@	Specify isa(s) when doing ifield, operand, insn lookups.
	ACU = all callers updated.
	* attr.scm (/attr-eval): Call rtx-value instead of rtx-eval-with-estate.
	* enum.scm (define-full-insn-enum): Pass isa-name-list to
	current-ifld-lookup.
	* html.scm (get-insn-properties): Pass isa-name-list to
	current-op-lookup.
	* ifield.scm (/ifld-parse-follows): New arg isas, ACU.
	* insn.scm (/parse-insn-format-symbol): New arg isa-name-list, ACU.
	(/parse-insn-format-list, /parse-insn-iformat-iflds): Ditto.
	(/parse-insn-format, syntax-break-out): Ditto.
	* mach.scm (obj-filter-by-isa): New function.
	(current-ifld-lookup): New optional arg maybe-isa-name-list.
	(/ifld-already-defined?, /op-already-defined?): Simplify.
	(current-op-lookup): New optional arg maybe-isa-name-list.
	(current-insn-lookup): New arg isa-name-list, ACU.
	(/insn-already-defined?, /minsn-already-defined?): Simplify.
	(current-minsn-lookup): New arg isa-name-list, ACU.
	* minsn.scm (/minsn-compute-iflds): Pass isa-name-list to
	current-op-lookup.
	* opc-itab.scm (compute-syntax): New arg isa-name-list, ACU.
	(gen-syntax-entry): Ditto.
	* operand.scm (/operand-parse): Pass isa-name-list to
	current-ifld-lookup.
	(/derived-parse-encoding): New arg isa-name-list, ACU.
	(/derived-parse-ifield-assertion): Ditto.
	(/derived-operand-parse): Pass isa-name-list to current-op-lookup.
	(/anyof-parse-choice): Ditto.
	(anyof-satisfies-assertions?): Pass context to rtx-solve.
	(/anyof-merge-syntax): New arg container, ACU.
	(operand-builtin!): Add pc to all isas.
	* rtl-c.scm (estate-make-for-rtl-c): Delete arg extra-vars-alist, ACU.
	(estate-make-for-rtl-c++, rtl-c-expr-parsed): Ditto.
	(rtl-c-parsed, rtl-c++-parsed): Ditto.
	(rtl-c): New arg isa-name-list, ACU.
	(rtl-c-expr, rtl-c++): Ditto.
	(closure): New arg isa-name-list, ACU.
	* rtl-traverse.scm (/make-cstate): New arg isa-name-list, ACU.
	(/cstate-isas): New function.
	(/rtx-canon-symbol-list): New function.
	(/rtx-canon-env-stack): Renamed from /rtx-canon-env, ACU.
	updated.
	(/rtx-make-canon-table): Rename ENV to ENVSTACK, new entry SYMBOLLIST.
	(/rtx-canon-rtx-operand): Pass isa list to current-op-lookup.
	(/rtx-canon-rtx-ref, /rtx-canon): Ditto.
	(rtx-canonicalize): New arg isa-name-list, ACU.
	(rtx-canonicalize-stmt): Delete.
	(tstate-make): New arg isas, ACU.
	(tstate-isas, tstate--set-isas!): New functions.
	(tstate-env-stack): Renamed from tstate-env, ACU.
	(tstate-set-env-stack!): Renamed from tstate-set-env!, ACU.
	(tstate-make-closure): Renamed from tstate-new-env, new arg
	isa-name-list, ACU.
	(/rtx-traverse-env): Delete.
	(/rtx-make-traverser-table): Rename ENV to ENVSTACK, new entry
	SUMBOLLIST.
	(/rtx-traverse): Include conditional flag in dump output.
	Update isa,envstack for closures.  Pass isa list to current-op-lookup.
	(<eval-state>): New member isas.  Rename env to env-stack.
	(<eval-state> vmake!): Handle #:isas.  #:env renamed to #:env-stack.
	(<eval-state>): New getter/setter for isas.  Rename env getter/setter
	to env-stack.
	(estate-make-for-eval): Provide #:isas.
	(estate-make-closure): Renamed from estate-new-env.  New arg
	isa-name-list, ACU.
	* rtl-xform.scm (/rtx-simplify-expr-fn): Handle closures.
	(/rtx-trim-args): ENV renamed to ENVSTACK.  Ad ITERATION, SYMBOLLIST.
	(/rtx-trim-for-doc): Handle closures.
	* rtl.scm (/rtx-valid-types): Rename ENV to ENVSTACK.  Add ITERATION,
	SYMBOLLIST.
	(rtx-env-var-list): Delete.
	(rtx-env-make): Handle already-compiled environments.
	(rtx-var-alist-to-env): New function.
	(rtx-var-alist-to-closure-env-stack, rtx-make-env-stack): New functions.
	(rtx-env-stack-dump): Renamed from rtx-env-dump, ACU.
	(rtx-operand-obj): New arg isa-name-list, ACU.
	(rtx-closure-isas, rtx-closure-env-stack, rtx-closure-expr): New
	functions.
	* rtx-funcs.scm (closure): New arg isa-name-list, reorder args, ACU.
	* sem-frags.scm (<sfrag>): Delete member compiled-semantics.
	(/frag-compute-desired-frags): Minor simplification.
	(/frag-pick-best): Ditto.
	* sid-cpu.scm (gen-semantic-code): Require canonical rtl.
	(/gen-sfrag-code): Update.
	* sim-cpu.scm (gen-semantic-code): Require canonical rtl.
	* utils-cgen.scm (sanitize): New arg isa-name-list, ACU.
	* utils.scm (non-null-intersection?): New function.
@
text
@a1282 20
; Given X, a number or symbol, reduce it to a constant if possible.
; Numbers always reduce to themselves.
; Symbols are reduced to a number if they're defined as such,
; or to an enum constant if one exists; otherwise X is returned unchanged.
; Requires: symbol-bound? enum-lookup-val

(define (reduce x)
  (if (number? x)
      x
      ; A symbol bound to a number?
      (if (and (symbol? x) (symbol-bound? #f x) (number? (eval1 x)))
	  (eval1 x)
	  ; An enum value that has a known numeric value?
	  (let ((e (enum-lookup-val x)))
	    (if (number? (car e))
		(car e)
		; Otherwise return X unchanged.
		x))))
)

@


1.33
log
@	* decode.scm: Tweak various comments.
	(/opcode-slots): Add FIXME.
	(/build-decode-table-guts): Add assert.
	* utils-sim.scm (/gen-set-itype-and-extract): New function.
	(/gen-bracketed-set-itype-and-extract): New function.
	(/gen-decode-default-entry): Rewrite.
	(/table-guts-to-mask, /all-opcode-bits-used?): New functions.
	(/gen-decode-insn-entry): New arg table-guts-thus-far, all callers
	updated.  Don't unnecessarily emit check for whether all opcode bits
	have been examined.
	(/gen-decode-expr-set-itype): Delete.
	(/gen-decode-expr-entry): Update.
	(/gen-decode-table-entry): New arg table-guts-thus-far, all callers
	updated.  Keep track of decoder tables used thus far.
	(/gen-decoder-switch): Ditto.
	* utils.scm (word-bit-value): New function.
@
text
@d666 12
@


1.32
log
@	* xc16x.cpu (h-cr): New hardware.
	(muls): Comment out parts that won't compile, add fixme.
	(mulu, divl, divlu, jmpabs, jmpa-, jmprel, jbc, jnbs, callr): Ditto.
	(scxti, scxtmg, scxtm, bclear, bclr18, bset19, bitset, bmov): Ditto.
	(bmovn, band, bor, bxor, bcmp, bfldl, bfldh): Ditto.

	Rewrite rtl processing to require it to be "canonicalized" first,
	and write a full canonicalizer / expression checker.
	Remove all appearances of DFLT in canonical rtl.
	* attr.scm (/attr-eval atval owner): Call rtx-canonicalize,
	then rtx-simplify.
	* iformat.scm (ifmt-analyze) Use canonical semantics.
	* insn (<insn>): New member canonical-semantics.
	* mach.scm (<arch>): New member multi-insns-instantiated?.
	(/instantiate-multi-insns!): New function.
	(/canonicalize-insns!): New function.
	(arch-analyze-insns!): Canonicalize insn semantics before processing
	them.
	* mode.scm (/mode-set-word-params!): New function.
	(mode-void?): New function.
	(mode-compatible?): VOID is compatible with VOID.
	(/mode-word-sizes-defined?): New global.
	(mode-set-word-modes!): Use/set it.
	(mode-ensure-word-sizes-defined): Update.
	(mode-builtin!): New builtin "modes" SYM, INSN, MACH.
	Redo WI/UWI/AI/IAI handling.
	(op:new-mode): No longer accept DFLT.
	(<derived-operand> constructor): Ensure all fields are initialized.
	(<anyof-operand> constructor): Ditto.
	(/derived-parse-ifield-assertion): Delete arg `args'.
	All callers updated.
	* rtl-c.scm (<rtl-c-eval-state>): New member `for-insn?'.
	(rtl-c): Call rtx-canonicalize instead of rtx-compile.
	(rtl-c-expr, rtl-c++): Ditto.
	(/rtl-c-get): Use mode of operand, not containing expression.
	(rtl-c-set-quiet, rtl-c-set-trace): Remove DFLT support.
	(/rtx-use-sem-fn?): Don't check for (insn? owner), check
	estate-for-insn? instead.
	(s-unop): Use mode of expression, not first operand.
	(s-binop, s-binop-with-bit, s-shop, s-cmpop): Ditto.
	(s-sequence): Remove DFLT support.
	(ifield): Use mode of expression, not UINT.
	(pc): Comment out, unused.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	(set, set-quiet): Pass src to rtl-c-set-{trace,quiet} for expansion.
	* rtl-traverse.scm (/rtx-canon-debug?): New global.
	(/make-cstate): New function.
	(/cstate-context, /cstate-outer-expr): New functions.
	(/rtx-canon-error): New function.
	(/rtx-lookup-hw, /rtx-pick-mode, /rtx-pick-mode3, /rtx-pick-op-mode,
	/rtx-get-last-cond-case-rtx): New functions.
	(/rtx-canon-*): New functions.
	(/rtx-canner-table, /rtx-operand-canoners): New globals.
	(/rtx-make-canon-table, /rtx-special-expr-canoners): New functions.
	(/rtx-option, /rtx-option-list?): Rewrite.
	(rtx-munge-mode&options): Replaces /rtx-munge-mode&options.
	Rewritten, all callers updated.
	(/rtx-canon-expr, /rtx-canon): New functions.
	(rtx-canonicalize): Move here from rtl-xform.scm and rewrite.
	(rtx-canonicalize-stmt): New function.
	(tstate-make): Remove arg `set?'.  All callers updated.
	(tstate-new-set?): Delete.
	(/rtx-traverse-options, /rtx-traverse-*mode): Delete,
	moved to /rtx-canon-*.
	(/rtx-traverse-normal-operand): New function.
	(/rtx-traverse-rtx-list): Delete arg `mode', all callers updated.
	(/rtx-traverse-rtx, /rtx-traverse-setrtx,, /rtx-traverse-testrtx,
	/rtx-traverse-condrtx, /rtx-traverse-casertx, /rtx-traverse-locals,
	/rtx-traverse-iteration, /rtx-traverse-env, /rtx-traverse-attrs):
	Ditto.
	(/rtx-traverse-symbol, /rtx-traverse-string, /rtx-traverse-number,
	/rtx-traverse-symornum, /rtx-traverse-object): Delete.
	(/rtx-make-traverser-table): Update.
	(/rtx-traverse-operands): Remove mode processing, now done during
	canonicalization.
	(/rtx-traverse-expr): Delete arg `mode', all callers updated.
	(/rtx-traverse): Ditto.
	(rtx-init-traverser-tables!): New function.
	* rtl-xform (/rtx-verify-no-dflt-modes-expr-fn): New function.
	(rtx-verify-no-dflt-modes): New function.
	(/rtx-simplify-expr-fn): Update, `arg' mode deleted.
	(rtx-simplify-insn): Use insn-canonical-semantics.
	(rtx-canonicalize): Moved to rtl-traverse.scm.
	(/compile-expr-fn, rtx-compile): Delete.
	(/rtx-trim-rtx-list): New function.
	(/rtx-trim-for-doc): Handle set, if.
	* rtl.scm (<rtx-func>): New members result-mode, matchexpr-index.
	(/rtx-valid-mode-types): Update.
	(/rtx-valid-matches): Update.
	(/rtx-find-matchexpr-index): New function.
	(rtx-lookup): Require rtx-kind to be the rtx name.
	(def-rtx-node): New arg result-mode, all callers updated.
	(def-rtx-syntax-node, def-rtx-operand-node): Ditto.
	(rtx-lazy-sem-mode): Delete.
	(/rtx-closure-make): New arg `mode', all callers updated.
	(rtx-make-ifield, rtx-make-operand, rtx-make-local): Ditto.
	(rtx-operand-obj): Rewrite.
	(rtx-make-xop): New functions.
	(/hw): Renamed from `hw', all callers updated.
	Use the correct mode instead of DFLT for the index.
	(rtl-builtin!): Call rtx-init-traversal-tables!.
	(rtl-finish!): Update.
	* rtx-funcs.scm (all rtx functions): New parameter: result-mode.
	Update mode arg-type.
	(pc): Comment out.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	* sem-frags.scm (/frag-hash-compute!): Update, mode arg deleted.
	(/frag-cost-compute!): Ditto.
	* semantics.scm (/build-operand!): Delete args op-name, op.
	New arg op-expr.  All callers updated.
	(/build-mem-operand!): Remove DFLT support.
	(semantic-compile): Update process-expr!, mode arg deleted.
	* sid-cpu.scm (gen-semantic-code): Specify #:for-insn? in
	rtl-c++ calls.
	(/gen-sem-case, /gen-sfrag-code): Ditto.
	* sid.scm (/op-gen-set-trace1): Renamed from /op-gen-set-trace.
	(/op-gen-set-trace): New function.  If not doing profiling,
	call /op-gen-set-quiet.
	* sim-cpu.scm (gen-semantic-code): Specify #:for-insn? in rtl-c calls.
	* utils-gen.scm (/gen-ifld-extract-base): Update call to rtl-c.
	(/gen-ifld-extract-beyond, gen-multi-ifld-extract): Ditto.
	* utils.scm (find-first-index): New function.
	* doc/rtl.texi: Delete docs for `attr'.  Add `int-attr'.
@
text
@d840 9
@


1.31
log
@	* ifield.scm (ifld-beyond-base?): Remove args base-bitsize,
	total-bitsize.  All callers updated.
	* insn.scm (<insn>): Rename member ifld-values to /insn-value.
	New member /insn-base-value.
	(insn-base-value): New function.
	* mach.scm (/sanity-check-insns): New function.
	(arch-analyze-insns!): Call it.
@
text
@d1154 1
a1154 1
; I is usually 0.
d1164 10
@


1.30
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d1008 1
@


1.29
log
@	* gas-test.scm (<keyword> test-data): Catch invalid requests,
	flag a warning and compensate.
	(<hw-address test-data): Tweak for readability.
	(<hw-iaddress test-data): Ditto.
	(cgen-build.sh): Convert symbols to strings before passing to
	string-append.
	(cgen-allinsn.exp): Ditto.
@
text
@d353 1
a353 1
(define -current-print-state #f)
d409 2
a410 2
      (set! -current-print-state pstate)
      (for-each (lambda (elm) (-string-write pstate elm))
d412 1
a412 1
      (set! -current-print-state #f)
d418 1
a418 1
(define (-string-write pstate expr)
d421 1
a421 1
	((procedure? expr) (-string-write pstate (expr)))
d423 1
a423 1
	((list? expr) (for-each (lambda (x) (-string-write pstate x)) expr))
d431 2
a432 2
  (let ((pstate -current-print-state))
    (for-each (lambda (arg) (-string-write pstate (proc arg)))
d442 1
a442 1
; Subroutine of string-list->string.  Does same thing -string-write does.
d444 1
a444 1
(define (-string-list-flatten pstate strlist)
d447 1
a447 1
	((procedure? strlist) (-string-list-flatten pstate (strlist)))
d451 1
a451 1
				       (-string-list-flatten pstate str))
d459 1
a459 1
  (-string-list-flatten (make-print-state) strlist)
@


1.28
log
@	Add -t option for tracing things like commands, pmacro expansion.
	* dev.scm (cload): New arg #:trace.
	* pmacros.scm (-pmacro-expand): Rewrite pmacro tracing.
	(pmacro-trace): New arg `loc'.  Rewrite pmacro tracing.
	(pmacro-debug): Call pmacro-trace instead of -pmacro-expand.
	* read.scm (<reader>): New members trace-commands?, trace-pmacros?.
	(-reader-process-expanded-1!): Trace commands if requested.
	(-reader-process!): Call pmacro-trace of pmacro tracing requested.
	(-set-trace-options!): New function.
	(-init-reader!): New function.
	(cpu-load): New arg trace-options, all callers updated.
	Call -init-reader! and -set-trace-options!.
	(cgen-usage): Improve output formatting.
	(common-arguments): New option -t.
	(-cgen): Process -t.
	* utils-cgen.scm (single-location->string): Renamed from
	pretty-print-single-location.  All callers updated.
	(location->string): Renamed from pretty-print-location.
	All callers updated.
	(source-properties-location->string): New function.
	* doc/running.texi: Document -t.
@
text
@d55 3
a57 2
; Print to stderr, takes an arbitrary number of strings, possibly nested.
; ??? Audit callers, can we maybe just use "display" here.
@


1.27
log
@	* read.scm (debug-env, debug-var-names, debug-var, debug-tty,
	debug-tty-port, debug-repl, debug-quit, debug-repl-env): Move to ...
	* utils.scm: ... here.
@
text
@d63 1
@


1.26
log
@	* modes.scm (TI,OI): New modes.
	* types.scm (parse-type): Improve error checking.  Don't hardwire
	mode names here.
	* utils.scm (non-negative-integer?): New function.
@
text
@d1405 72
@


1.25
log
@	* model.scm (parse-insn-timing): Tweak logging message.
	* operand.scm: Comment and whitespace tweaks.
	(op:type): Tweak error message.
	(op-ifield): Tweak logging message.
	(-derived-operand-parse, anyof-merge-semantics): Ditto.
	* read.scm: Whitespace cleanup.
	* utils.scm: Whitespace cleanup.
@
text
@d1067 7
@


1.24
log
@	Extend pmacro language, add testsuite.
	* Makefile.am (SUBDIRS): Add testsuite.
	* Makefile.in: Regenerate.
	* configure.in (AC_OUTPUT): Create testsuite/Makefile,
	testsuite/test-utils.sh.
	* configure: Regenerate.
	* dev.scm (cload): Handle testsuite app.
	(load-testsuite): New function.
	* pmacros.scm: (-pmacro-debug?): New global.
	(-smacro-table): New global.
	(-smacro-lookup, -smacro-set!): New functions.
	(-pmacro-make): New argument `syntactic-form?', all callers updated.
	(-pmacro-syntactic-form?): New function.
	(-pmacro-expected-number, -pmacro-verify-number): New functions.
	(-pmacro-expected-integer, -pmacro-verify-integer): New functions.
	(-pmacro-expected-non-negative-integer): New function.
	(-pmacro-verify-non-negative-integer): New function.
	(-pmacro-expand-expr-list): New function.
	(-pmacro-process-args-1): Renamed from -pmacro-process-args.
	(-pmacro-process-args): Renamed from -pmacro-invoke.
	(-pmacro-apply, -smacro-apply): New functions.
	(-pmacro-expand): Rewrite syntactic form processing.
	(-pmacro-build-lambda): Reformat.
	(define-pmacro): Watch for more errors in definition.
	(pmacro-debug): New function.
	(pmacro-trace): Set/reset -pmacro-debug?.
	(all existing builtin pmacro helpers): Rename to -pmacro-builtin-foo.
	(-pmacro-builtin-substring): Fix.  Add support for `end' marker.
	(-pmacro-builtin-for-each, et.al.): New helpers for .for-each, .let,
	.if, .case, .cond, .begin, .print, .dump, .error, .list, .ref,
	.length, .replicate, .equals, .and, .or, .not, .eq, .ne, .lt, .gt,
	.le, .ge, .add, .sub, .mul, .div, .rem, .sll, .srl, .sra, .bitand,
	.bitor, .bitxor, bitinv, .car, .cdr, .caar, .cadr, .cdar, .cddr.
	(pmacros-init!): Initialize -smacro-table.
	Rewrite pmacro initialization.
	* read.scm (reader-process-expanded): Renamed from
	-reader-process-expanded.  All callers updated.
	Recognize () as a no-op.
	(cpu-load): Tweak logging messages.
	* utils.scm (message): Add comment.
	* cpu/play.cpu: Add some instructions to play with .let.
	* doc/cgenint.texi: Move some debugging related docs to here from
	cgen.texi.
	* doc/pmacros.texi: Reorganize.  Add docs for new builtin pmacros.
	* testsuite/Makefile.am: New file.
	* testsuite/Makefile.in: New file.
	* testsuite/test-utils.sh.in: New file.
	* testsuite/run-tests.sh: New file.
	* testsuite/testsuite.cpu: New file.
	* testsuite/pmacros-1.test: New file.
@
text
@d323 1
d338 1
d572 1
d578 1
d584 1
a588 1

@


1.23
log
@	* utils.scm (message): Handle pairs.
@
text
@d56 1
@


1.22
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d61 6
a66 4
		    (begin 
		      (message "(")
		      (for-each (lambda (s) (message s " ")) str)
		      (message ")"))
@


1.22.2.1
log
@Copy over from trunk.
	Extend pmacro language, add testsuite.
	* Makefile.am (SUBDIRS): Add testsuite.
	* Makefile.in: Regenerate.
	* configure.in (AC_OUTPUT): Create testsuite/Makefile,
	testsuite/test-utils.sh.
	* configure: Regenerate.
	* dev.scm (cload): Handle testsuite app.
	(load-testsuite): New function.
	* pmacros.scm: (-pmacro-debug?): New global.
	(-smacro-table): New global.
	(-smacro-lookup, -smacro-set!): New functions.
	(-pmacro-make): New argument `syntactic-form?', all callers updated.
	(-pmacro-syntactic-form?): New function.
	(-pmacro-expected-number, -pmacro-verify-number): New functions.
	(-pmacro-expected-integer, -pmacro-verify-integer): New functions.
	(-pmacro-expected-non-negative-integer): New function.
	(-pmacro-verify-non-negative-integer): New function.
	(-pmacro-expand-expr-list): New function.
	(-pmacro-process-args-1): Renamed from -pmacro-process-args.
	(-pmacro-process-args): Renamed from -pmacro-invoke.
	(-pmacro-apply, -smacro-apply): New functions.
	(-pmacro-expand): Rewrite syntactic form processing.
	(-pmacro-build-lambda): Reformat.
	(define-pmacro): Watch for more errors in definition.
	(pmacro-debug): New function.
	(pmacro-trace): Set/reset -pmacro-debug?.
	(all existing builtin pmacro helpers): Rename to -pmacro-builtin-foo.
	(-pmacro-builtin-substring): Fix.  Add support for `end' marker.
	(-pmacro-builtin-for-each, et.al.): New helpers for .for-each, .let,
	.if, .case, .cond, .begin, .print, .dump, .error, .list, .ref,
	.length, .replicate, .equals, .and, .or, .not, .eq, .ne, .lt, .gt,
	.le, .ge, .add, .sub, .mul, .div, .rem, .sll, .srl, .sra, .bitand,
	.bitor, .bitxor, bitinv, .car, .cdr, .caar, .cadr, .cdar, .cddr.
	(pmacros-init!): Initialize -smacro-table.
	Rewrite pmacro initialization.
	* read.scm (reader-process-expanded): Renamed from
	-reader-process-expanded.  All callers updated.
	Recognize () as a no-op.
	(cpu-load): Tweak logging messages.
	* utils.scm (message): Add comment.
	* cpu/play.cpu: Add some instructions to play with .let.
	* doc/cgenint.texi: Move some debugging related docs to here from
	cgen.texi.
	* doc/pmacros.texi: Reorganize.  Add docs for new builtin pmacros.
	* testsuite/Makefile.am: New file.
	* testsuite/Makefile.in: New file.
	* testsuite/test-utils.sh.in: New file.
	* testsuite/run-tests.sh: New file.
	* testsuite/testsuite.cpu: New file.
	* testsuite/pmacros-1.test: New file.
@
text
@a55 1
; ??? Audit callers, can we maybe just use "display" here.
@


1.22.2.2
log
@Bring over various patches from the trunk.
@
text
@d62 4
a65 6
		    (if (list? str)
			(begin
			  (message "(")
			  (for-each (lambda (s) (message s " ")) str)
			  (message ")"))
			(message "(" (car str) " . " (cdr str) ")"))
@


1.21
log
@Change source files over to GPLv3.
@
text
@d2 1
a2 1
; Copyright (C) 2000-2005, 2006, 2007 Red Hat, Inc.
d1271 1
a1271 1
Copyright 1996-2007 Free Software Foundation, Inc.
d1296 1
a1296 1
Copyright (C) 2000-2007 Red Hat, Inc.
@


1.21.4.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2005, 2006, 2007, 2009 Red Hat, Inc.
d1271 1
a1271 1
Copyright 1996-2009 Free Software Foundation, Inc.
d1296 1
a1296 1
Copyright (C) 2000-2009 Red Hat, Inc.
@


1.21.4.2
log
@	* utils.scm (message): Handle pairs.
@
text
@d61 4
a64 6
		    (if (list? str)
			(begin
			  (message "(")
			  (for-each (lambda (s) (message s " ")) str)
			  (message ")"))
			(message "(" (car str) " . " (cdr str) ")"))
@


1.20
log
@2006-05-10  Dave Brolley  <brolley@@redhat.com>

        * read.scm (-cgen): Add trailing "/" to arch-path.
        * utils.scm (dirname): Removed. dirname is a primitive function.
@
text
@d2 1
a2 1
; Copyright (C) 2000-2005, 2006 Red Hat, Inc.
d1271 1
a1271 1
Copyright 1996-2005 Free Software Foundation, Inc.
d1274 13
a1286 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
d1296 1
a1296 1
Copyright (C) 2000-2005 Red Hat, Inc.
@


1.19
log
@2006-05-09  Dave Brolley  <brolley@@redhat.com>

        * utils.scm (dirname): New function.
@
text
@a157 9
; Return the directory name of the given file name

(define (dirname s)
  (let loop ((i (string-length s)))
    (cond ((= i 0) "")
	  ((char=? #\/ (string-ref s (- i 1))) (substring s 0 i))
	  (else (loop (- i 1)))))
)

@


1.18
log
@2005-06-15  Dave Brolley  <brolley@@redhat.com>

        * sid-cpu.scm (-gen-hw-stream-and-destream-fns): New function.
        (cgen-cpu.h): Call it.

        Contributed on behalf of Graydon Hoare
        2001-06-05  graydon hoare  <graydon@@redhat.com>

        * utils.scm (foldl): Define.
        (foldr): Define.
        (filter): Define.
        (union): Define.
        (intersection): Simplify.
        * sid.scm : Set APPLICATION to SID-SIMULATOR.
        (-op-gen-delayed-set-maybe-trace): Define.
        (<operand> 'gen-set-{quiet,trace}): Delegate to
        op-gen-delayed-set-quiet etc. Note: this is still a little tangled
        up and needs cleaning.
        (-with-parallel?): Hardwire with-parallel to #t.
        (<operand> 'cxmake-get): Replace with lookahead-aware code
        * sid-decode.scm: Remove per-insn writeback fns.
        (-gen-idesc-decls): Redefine sem_fn type.
        * sid-cpu.scm (gen-write-stack-structure): Replace parexec stuff
        with write stack stuff.
        (cgen-write.cxx): Replace per-insn writebacks with single write
        stack writeback. Add write stack reset function.
        (-gen-scache-semantic-fn insn): Replace parexec stuff with write
        stack stuff.
        * rtl-c.scm (xop): Clone operand into delayed operand if #:delayed
        estate attribute set.
        (delay): Set #:delayed attribute to calculated delay, update
        maximum delay of cpu, check (delay ...) usage.
        * operand.scm (<operand>): Add delayed slot to <operand>.
        * mach.scm (<cpu>): Add max-delay slot to <cpu>.
        * dev.scm (load-sid): Set APPLICATION to SID-SIMULATOR.
        * doc/rtl.texi (Expressions): Add section on (delay ...).
@
text
@d2 1
a2 1
; Copyright (C) 2000-2005 Red Hat, Inc.
d158 9
@


1.17
log
@Update the address and phone number of the FSF organization
@
text
@d566 16
d654 7
a660 6
(define (intersection l1 l2)
  (cond ((null? l1) l1)
	((null? l2) l2)
	((memq (car l1) l2) (cons (car l1) (intersection (cdr l1) l2)))
	(else (intersection (cdr l1) l2)))
)
@


1.16
log
@2005-02-16  Dave Brolley  <brolley@@redhat.com>

        * utils.scm: Update copyright years.
        * utils-gen.scm (gen-ifld-extract): Pass base-length to -gen-ifld-extrac
t-base.
        * sid.scm (gen-ifetch): Handle the case where bitsize == 24.
@
text
@d1269 1
a1269 1
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
@


1.15
log
@* utils.scm (string/symbol->append): Renamed from 'concat'.
* opcodes.scm (gen-switch): Use new name.
* insn.scm (-sub-insn-make!): Same.
* rtl.scm (rtx-dump): Same.
* semantics.scm (semantic-compile): Same.
@
text
@d2 1
a2 1
; Copyright (C) 2000-2004 Red Hat, Inc.
d1254 1
a1254 1
Copyright 1996-2004 Free Software Foundation, Inc.
d1279 1
a1279 1
Copyright (C) 2000-2004 Red Hat, Inc.
@


1.14
log
@* utils.scm (concat): New function.
* insn.scm (-sub-insn-make!): Use concat instead of string-map.
* rtl.scm (rtx-dump): Same.
* semantics.scm (semantic-compile): Same.
@
text
@d90 1
a90 1
(define (concat . sequences)
@


1.13
log
@* read.scm (debug-repl): Temporarily redirect input and output to
/dev/tty while we debug, so we don't interfere with whatever CGEN
is reading or writing.
* utils.scm (setter-getter-fluid-let, with-input-and-output-to):
New functions.
@
text
@d88 6
@


1.12
log
@2004-03-22  Dave Brolley  <brolley@@redhat.com>

        * utils.scm (copyright-fsf): Update copyright years.
        (copyright-red-hat): Ditto.
        * sid.scm (-op-gen-set-trace): Generate trace code before semantic
        code.
        (-op-gen-set-trace-parallel): Ditto.
@
text
@d308 29
@


1.11
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2002, 2003 Red Hat, Inc.
d1219 1
a1219 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d1244 1
a1244 1
Copyright (C) 2000, 2001, 2002, 2003 Red Hat, Inc.
@


1.10
log
@	* mach.scm (current-*-add!): Disallow redefinition.  Make result
	"unspecified".
	* insn.scm (insn-builtin!): Don't define relaxable here, now defined in
	operand.scm.
	* operand.scm (operand-builtin!): Define RELAXABLE for insns too.
	* cpu/m32r.cpu (disp8,disp24): RELAX renamed to RELAXABLE.

	* gen-all-doc: Split arm and frv docs up a bit.

	* cpu/arm.cpu: Add IDOC attribute.
	* cpu/frv.cpu: Ditto.
	* cpu/i960.cpu: Ditto.
	* cpu/openrisc.cpu: Ditto.
	* cpu/xstormy16.cpu: Ditto.
	* cpu/m32r.cpu: Ditto.
	(all insns): Explicitly specify IDOC attribute.

	* Makefile.am (MACH,ISAS,INSN_FILE_NAME): New vars.
	(desc,opcodes,sim-arch,sim-cpu,gas-test,sim-test): Use MACH,ISAS.
	(html): Use MACH,ISAS,INSN_FILE_NAME.  Generate insn.html separately.
	* Makefile.in: Regenerate.
	* attr.scm (<integer-attribute>:parse-value-def): Implement.
	(-attr-read): Defer computing default value until we know the type.
	(attr-has-attr?): Delete, move contents to <attr-list>:has-attr?.
	(<attr-list>:attr-present?): New method.
	(atlist-attr-present?,obj-attr-present?): New fns.
	(obj-has-attr-value?,obj-has-attr-value-no-default?): New fns.
	(attr-builtin!): New insn attr IDOC.
	* cgen-doc.scm (doc-arguments): New args -I,-N.
	* enum.scm (parse-enum-vals): New arg errtxt, all callers updated.
	Support comment as fourth element of enum value.
	(enum-val-name,enum-val-value,enum-val-attrs,enum-val-comment): New fns.
	* html.scm (gen-html-header): New arg kind, all callers updated.
	(gen-table-of-contents): New arg insn-file, all callers updated.
	(gen-list-entry,gen-doc-header): New fn.
	(get-operands): Delete.
	(gen-iformat-table): Rewrite.
	(gen-insn-doc-1): Print constant-folded and trimmed semantics.
	(gen-insn-doc-list): New args name, comment, insns.  All callers updated.
	(get-insn-properties,guess-insn-idoc-attr!): New fn.
	(insn-sets-pc?,insn-refs-mem?,insn-uses-fpu?): New fns.
	(get-insns-for-category,gen-categories-insn-lists): New fns.
	(gen-insn-docs): Simplify each insn's semantics first.
	Print insn tables sorted by IDOC categories.
	(*insn-html-file-name*): New global.
	(cgen-insn.html): New fn.
	(cgen-all): Update.
	* insn.scm (<insn>): Create a setter for the `tmp' member.
	* semantics.scm (insn-build-known-values): Renamed from
	-build-known-values.  All callers updated.

	* rtl.scm: Move traveral/evaluation support to ...
	* rtl-traverse.scm: New file.
	* read.scm: Maybe-load rtl-traverse.scm.

	* rtl.scm (-rtx-valid-types): Add SETRTX.

	* rtx-funcs.scm (nop,parallel): Fix mode.

	* utils.scm (eqv-lookup-index): New fn.
	(assq-lookup-index): Renamed from lookup-index.  All callers updated.

	* dev.scm (load-doc): Set APPLICATION.
@
text
@a95 1

d128 2
a129 1
; Turn STR into a proper C symbol.
d137 2
a138 1
  (map-over-string (lambda (c) (if (id-char? c) c #\_)) str)
d141 3
a143 2
; Turn STR into a proper file name, which is defined to be the same
; as gen-c-symbol except use -'s instead of _'s.
d148 2
a149 1
  (map-over-string (lambda (c) (if (id-char? c) c #\-)) str)
d164 18
d269 36
d875 1
a875 1
; (all-true? ()) is #t since that is the identity element.
d1193 2
a1194 2
      (if (and (symbol? x) (symbol-bound? #f x) (number? (eval x)))
	  (eval x)
@


1.9
log
@	* Makefile.am (srcroot): New var.
	(html): New rule.
	* Makefile.in: Regenerate.
	* cgen-doc.scm: New file.
	* html.scm: New file.
	* gen-all-doc: New file.
	* dev.scm (cload): Handle DOC application.
	(load-doc): New fn.
	* machs.scm (machs-for-cpu): New fn.
	* model.scm (models-for-cpu): New fn.
	* utils.scm (gen-c-copyright): Renamed from gen-copyright.
	All uses updated.
	(iota): Rewrite to be identical to pmacro version.  All uses updated.
	* utils-cgen.scm (alpha-sort-obj-list): New fn.
@
text
@d490 1
d519 2
d1064 13
a1076 3
; Given a list of lists L such that the first element in each list names the
; entry, look up symbol S in that and return its index.  If not found,
; return #f.
a1077 2
; Granted, linear searching isn't efficient.  If it ever becomes a problem we
; can do something about it then.
d1079 2
d1082 1
a1082 1
(define (lookup-index s l i)
d1085 1
a1085 1
	(else (lookup-index s (cdr l) (1+ i))))
d1091 1
d1100 1
@


1.8
log
@2003-04-16  Dave Brolley  <brolley@@redhat.com>

        * doc/rtl.texi (Iiming): Correct example to use 'model-name'.
        * utils.scm (copyright-fsf): Update generate copyright years.
        (copyright-cygnus): Ditto.
        * sid.scm (-op-gen-set-trace): Generate code to fill in bitmask of modified
        operands.
        (-gen-arch-model-decls): Don't generate unit enum declaration or MAX_UNITS
        here.
        (<operand>'gen-profile-code): New parameter 'when'.
        (<iunit>'gen-profile-code): Ditto.
        (<insn>'gen-profile-code): Ditto.
        (<unit>'gen-profile-code): Ditto. Only generate 'referenced' and
        'insn_reference' for the 'after' function.
        * model.scm (unit:enum): Moved to sim-model.scm.
        * sim-model.scm (unit:enum): Moved from model.scm.
        * sid-decode.scm (-gen-scache-decls): Generate the 'written' field.
        * cgen-sid.scm (sim-arguments): Document the generation of model.h.
        * sid-model.scm (unit:enum): New version for sid.
        (gen-model-class-name): New function.
        (gen-model-unit-fn-decl): New function.
        (gen-model-fn-decls): Call gen-model-unit-fn-decl.
        (gen-model-unit-fn-name): New parameter 'when'.
        (-gen-model-insn-fn-name): Ditto.
        (-gen-model-insn-qualified-fn-name): New function.
        (-gen-model-insn-fn-decl): New function.
        (-gen-model-insn-fn-decls): New function.
        (-gen-model-insn-fn): New parameter 'when'. Call
        -gen-model-insn-qualified-fn-name.
        (-gen-model-insn-fns): Generate the constructor for the model. Generate
        functions for modelling insn before and after execution.
        (-gen-model-class-decls): New function.
        (" (gen-model-class-name model) "): New function.
        (gen-model-classes): New function.
        (-gen-insn-timing): Generate functions for modelling insn before and after
        execution.
        (-gen-insn-unit-timing): Generate class-qualified names.
        (-gen-model-timing-table): Ditto.
        (cgen-model.cxx): Generate #include for @@cpu@@.h. Omit generation of code
        not needed (yet) by sid.
        (cgen-model.h): New function.
@
text
@d769 16
a784 13
; ARGS is either a list of one integer (N) meaning return a list from 0 to N-1,
; or a list of two integers (START N) meaning return a list from START to
; START+N-1.
; FIXME: change to (iota n . start).

(define (iota . args)
  (case (length args)
    ((1) (let loop ((n (car args)) (z nil))
	   (if (<= n 0) z (loop (1- n) (cons (1- n) z)))))
    ((2) (let ((start (car args)))
	   (let loop ((n (cadr args)) (z nil))
	     (if (<= n 0) z (loop (1- n) (cons (+ start (1- n)) z))))))
    (else (error "iota: wrong number of arguments:" args)))
d1195 4
d1203 1
a1203 1
(define (gen-copyright file-desc copyright package)
@


1.7
log
@2002-01-07  Ben Elliston  <bje@@redhat.com>

	* utils.scm (package-cygnus-simulators): Rename from this ..
	(package-red-hat-simulators): .. to this.
	* opcodes.scm (option-set!): Use package-red-hat-simulators.
	* sid-cpu.scm (cgen-desc.h): Likewise.
	(cgen-cpu.h): Likewise.
	(cgen-defs.h): Likewise.
	(cgen-write.cxx): Likewise.
	(cgen-semantics.cxx): Likewise.
	(cgen-sem-switch.cxx): Likewise.
	* sid-decode.scm (cgen-decode.h): Likewise.
	(cgen-decode.cxx): Likewise.
	* sid-model.scm (cgen-model.cxx): Likewise.
	* sid.scm (option-set!): Likewise.
	* sim.scm (option-set!): Likewise.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2002 Red Hat, Inc.
d1144 1
a1144 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d1169 1
a1169 1
Copyright (C) 2000, 2001, 2002 Red Hat, Inc.
@


1.6
log
@2002-01-07  Ben Elliston  <bje@@redhat.com>

	* utils.scm (copyright-fsf): Add 2002.
	(copyright-cygnus): Rename to copyright-red-hat.
	(copyright-red-hat): Add 2002.
	(CURRENT-COPYRIGHT): Update comment.
	* opcodes.scm (option-set!): Update callers.
	* sid-model.scm (cgen-model.cxx): Likewise.
	* sid-cpu.scm: Likewise.
	* sid-decode.scm: Likewise.
	* sid.scm (option-set!): Handle "redhat" as an option for
	"copyright"; use copyright-red-hat.
	* sim.scm (option-set!): Likewise.
@
text
@d1188 1
a1188 1
(define package-cygnus-simulators "\
@


1.5
log
@2001-03-24  Ben Elliston  <bje@@redhat.com>

	* utils.scm: Remove comments about the Hobbit compiler.
	(copyright-cygnus): Add 2001.
	(package-cygnus-simulators): Replace "Cygnus" with "Red Hat".
	(package-gnu-simulators): Tidy.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
d1144 1
a1144 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d1165 1
a1165 1
(define copyright-cygnus
d1169 1
a1169 1
Copyright (C) 2000, 2001 Red Hat, Inc.
d1174 1
a1174 1
; Set this to one of copyright-fsf, copyright-cygnus.
@


1.4
log
@Fix copyright notice in generated files
@
text
@d37 1
a37 2
; ??? value doesn't matter too much here, just check if portable
; Name was `UNSPECIFIED' but that conflicts with hobbit.
a39 1
; Define as global to avoid multiple copies in hobbit generated code.
a71 2
; Macro's can't be used in hobbit-compiled code, so instead there use:
; (if (verbose? level) (message ...)).
a935 8
;
; Hobbit emits two functions named `missing_bit_indices_fn31' for this.
;(define (missing-bit-indices mask full-mask)
;  (let* ((bitvals (bit-vals (logxor mask full-mask)))
;	 (selectors (bit-patterns (length bitvals))))
;    (map (lambda (sel) (apply + (map * sel bitvals))) selectors))
;)
; So it's rewritten to this ...
d1169 1
a1169 1
Copyright (C) 2000 Red Hat, Inc.
d1185 1
a1185 1
This file is part of the GNU Simulators.
d1189 1
a1189 1
This file is part of the Cygnus Simulators.
@


1.3
log
@2000-11-21  Ben Elliston  <bje@@redhat.com>

	* utils.scm (copyright-fsf): Add the year 2000.
@
text
@d1156 1
a1156 1
Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
@


1.2
log
@* major sim decoder improvement
* minor diagnostic tweaks

2000-11-10  Frank Ch. Eigler  <fche@@redhat.com>

	* decode.scm (-distinguishing-bit-population): Significantly
	improve popularity heuristic.  Renamed from
	(-mask-bit-population): Gone.
	(-population-above-threshold): Sort new bit numbers in order of
	popularity.
	(-population-top-few): Allow up to three more bits to be selected
	than requested.  Correct selection order to prefer better bits.
	Correct bug in fewer-than-requested case.  Keep threshold as
	floating-point.
	(decode-best-get-bits): Pass also the insn-values.

	* utils-sim.scm (-gen-decoder-switch): Add comment suggesting a
	future optimization.

	* utils.scm (message): Format nested lists better.
@
text
@d1156 1
a1156 1
Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
@


1.1
log
@Initial revision
@
text
@d63 4
a66 1
		    (apply message str)
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
