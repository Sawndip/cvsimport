head	1.11;
access;
symbols
	sid-snapshot-20180601:1.11
	cgen-snapshot-20180601:1.11
	sid-snapshot-20180501:1.11
	cgen-snapshot-20180501:1.11
	sid-snapshot-20180401:1.11
	cgen-snapshot-20180401:1.11
	sid-snapshot-20180301:1.11
	cgen-snapshot-20180301:1.11
	sid-snapshot-20180201:1.11
	cgen-snapshot-20180201:1.11
	sid-snapshot-20180101:1.11
	cgen-snapshot-20180101:1.11
	sid-snapshot-20171201:1.11
	cgen-snapshot-20171201:1.11
	sid-snapshot-20171101:1.11
	cgen-snapshot-20171101:1.11
	sid-snapshot-20171001:1.11
	cgen-snapshot-20171001:1.11
	sid-snapshot-20170901:1.11
	cgen-snapshot-20170901:1.11
	sid-snapshot-20170801:1.11
	cgen-snapshot-20170801:1.11
	sid-snapshot-20170701:1.11
	cgen-snapshot-20170701:1.11
	sid-snapshot-20170601:1.11
	cgen-snapshot-20170601:1.11
	sid-snapshot-20170501:1.11
	cgen-snapshot-20170501:1.11
	sid-snapshot-20170401:1.11
	cgen-snapshot-20170401:1.11
	sid-snapshot-20170301:1.11
	cgen-snapshot-20170301:1.11
	sid-snapshot-20170201:1.11
	cgen-snapshot-20170201:1.11
	sid-snapshot-20170101:1.11
	cgen-snapshot-20170101:1.11
	sid-snapshot-20161201:1.11
	cgen-snapshot-20161201:1.11
	sid-snapshot-20161101:1.11
	cgen-snapshot-20161101:1.11
	sid-snapshot-20160901:1.11
	cgen-snapshot-20160901:1.11
	sid-snapshot-20160801:1.11
	cgen-snapshot-20160801:1.11
	sid-snapshot-20160701:1.11
	cgen-snapshot-20160701:1.11
	sid-snapshot-20160601:1.11
	cgen-snapshot-20160601:1.11
	sid-snapshot-20160501:1.11
	cgen-snapshot-20160501:1.11
	sid-snapshot-20160401:1.11
	cgen-snapshot-20160401:1.11
	sid-snapshot-20160301:1.11
	cgen-snapshot-20160301:1.11
	sid-snapshot-20160201:1.11
	cgen-snapshot-20160201:1.11
	sid-snapshot-20160101:1.11
	cgen-snapshot-20160101:1.11
	sid-snapshot-20151201:1.11
	cgen-snapshot-20151201:1.11
	sid-snapshot-20151101:1.11
	cgen-snapshot-20151101:1.11
	sid-snapshot-20151001:1.11
	cgen-snapshot-20151001:1.11
	sid-snapshot-20150901:1.11
	cgen-snapshot-20150901:1.11
	sid-snapshot-20150801:1.11
	cgen-snapshot-20150801:1.11
	sid-snapshot-20150701:1.11
	cgen-snapshot-20150701:1.11
	sid-snapshot-20150601:1.11
	cgen-snapshot-20150601:1.11
	sid-snapshot-20150501:1.11
	cgen-snapshot-20150501:1.11
	sid-snapshot-20150401:1.11
	cgen-snapshot-20150401:1.11
	sid-snapshot-20150301:1.11
	cgen-snapshot-20150301:1.11
	sid-snapshot-20150201:1.11
	cgen-snapshot-20150201:1.11
	sid-snapshot-20150101:1.11
	cgen-snapshot-20150101:1.11
	sid-snapshot-20141201:1.11
	cgen-snapshot-20141201:1.11
	sid-snapshot-20141101:1.11
	cgen-snapshot-20141101:1.11
	sid-snapshot-20141001:1.11
	cgen-snapshot-20141001:1.11
	sid-snapshot-20140901:1.11
	cgen-snapshot-20140901:1.11
	sid-snapshot-20140801:1.11
	cgen-snapshot-20140801:1.11
	sid-snapshot-20140701:1.11
	cgen-snapshot-20140701:1.11
	sid-snapshot-20140601:1.11
	cgen-snapshot-20140601:1.11
	sid-snapshot-20140501:1.11
	cgen-snapshot-20140501:1.11
	sid-snapshot-20140401:1.11
	cgen-snapshot-20140401:1.11
	sid-snapshot-20140301:1.11
	cgen-snapshot-20140301:1.11
	sid-snapshot-20140201:1.11
	cgen-snapshot-20140201:1.11
	sid-snapshot-20140101:1.11
	cgen-snapshot-20140101:1.11
	sid-snapshot-20131201:1.11
	cgen-snapshot-20131201:1.11
	sid-snapshot-20131101:1.11
	cgen-snapshot-20131101:1.11
	sid-snapshot-20131001:1.11
	cgen-snapshot-20131001:1.11
	sid-snapshot-20130901:1.11
	cgen-snapshot-20130901:1.11
	sid-snapshot-20130801:1.11
	cgen-snapshot-20130801:1.11
	sid-snapshot-20130701:1.11
	cgen-snapshot-20130701:1.11
	sid-snapshot-20130601:1.11
	cgen-snapshot-20130601:1.11
	sid-snapshot-20130501:1.11
	cgen-snapshot-20130501:1.11
	sid-snapshot-20130401:1.11
	cgen-snapshot-20130401:1.11
	sid-snapshot-20130301:1.11
	cgen-snapshot-20130301:1.11
	sid-snapshot-20130201:1.11
	cgen-snapshot-20130201:1.11
	sid-snapshot-20130101:1.11
	cgen-snapshot-20130101:1.11
	sid-snapshot-20121201:1.11
	cgen-snapshot-20121201:1.11
	sid-snapshot-20121101:1.11
	cgen-snapshot-20121101:1.11
	sid-snapshot-20121001:1.11
	cgen-snapshot-20121001:1.11
	sid-snapshot-20120901:1.11
	cgen-snapshot-20120901:1.11
	sid-snapshot-20120801:1.11
	cgen-snapshot-20120801:1.11
	sid-snapshot-20120701:1.11
	cgen-snapshot-20120701:1.11
	sid-snapshot-20120601:1.11
	cgen-snapshot-20120601:1.11
	sid-snapshot-20120501:1.11
	cgen-snapshot-20120501:1.11
	sid-snapshot-20120401:1.11
	cgen-snapshot-20120401:1.11
	sid-snapshot-20120301:1.11
	cgen-snapshot-20120301:1.11
	sid-snapshot-20120201:1.11
	cgen-snapshot-20120201:1.11
	sid-snapshot-20120101:1.11
	cgen-snapshot-20120101:1.11
	sid-snapshot-20111201:1.11
	cgen-snapshot-20111201:1.11
	sid-snapshot-20111101:1.11
	cgen-snapshot-20111101:1.11
	sid-snapshot-20111001:1.11
	cgen-snapshot-20111001:1.11
	sid-snapshot-20110901:1.11
	cgen-snapshot-20110901:1.11
	sid-snapshot-20110801:1.11
	cgen-snapshot-20110801:1.11
	sid-snapshot-20110701:1.11
	cgen-snapshot-20110701:1.11
	sid-snapshot-20110601:1.11
	cgen-snapshot-20110601:1.11
	sid-snapshot-20110501:1.11
	cgen-snapshot-20110501:1.11
	sid-snapshot-20110401:1.11
	cgen-snapshot-20110401:1.11
	sid-snapshot-20110301:1.11
	cgen-snapshot-20110301:1.11
	sid-snapshot-20110201:1.11
	cgen-snapshot-20110201:1.11
	sid-snapshot-20110101:1.11
	cgen-snapshot-20110101:1.11
	sid-snapshot-20101201:1.11
	cgen-snapshot-20101201:1.11
	sid-snapshot-20101101:1.11
	cgen-snapshot-20101101:1.11
	sid-snapshot-20101001:1.11
	cgen-snapshot-20101001:1.11
	sid-snapshot-20100901:1.11
	cgen-snapshot-20100901:1.11
	sid-snapshot-20100801:1.11
	cgen-snapshot-20100801:1.11
	sid-snapshot-20100701:1.11
	cgen-snapshot-20100701:1.11
	sid-snapshot-20100601:1.11
	cgen-snapshot-20100601:1.11
	sid-snapshot-20100501:1.11
	cgen-snapshot-20100501:1.11
	sid-snapshot-20100401:1.11
	cgen-snapshot-20100401:1.11
	sid-snapshot-20100301:1.11
	cgen-snapshot-20100301:1.11
	sid-snapshot-20100201:1.11
	cgen-snapshot-20100201:1.11
	sid-snapshot-20100101:1.9
	cgen-snapshot-20100101:1.9
	sid-snapshot-20091201:1.9
	cgen-snapshot-20091201:1.9
	sid-snapshot-20091101:1.9
	cgen-snapshot-20091101:1.9
	sid-snapshot-20091001:1.9
	cgen-snapshot-20091001:1.9
	sid-snapshot-20090901:1.8
	cgen-snapshot-20090901:1.8
	sid-snapshot-20090801:1.4
	cgen-snapshot-20090801:1.4
	dje-cgen-play1-branch:1.1.0.2;
locks; strict;
comment	@# @;


1.11
date	2010.01.29.02.59.01;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2010.01.20.06.22.19;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.01.16.31.27;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2009.08.20.05.33.14;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2009.08.19.17.04.28;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	2009.08.17.15.27.56;	author devans;	state Exp;
branches;
next	1.5;

1.5
date	2009.08.13.17.57.51;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	2009.07.22.17.32.27;	author devans;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.20.01.06.06;	author devans;	state Exp;
branches;
next	1.2;

1.2
date	2009.07.19.16.57.53;	author devans;	state Exp;
branches;
next	1.1;

1.1
date	2009.07.13.20.55.21;	author devans;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2009.07.14.16.08.51;	author devans;	state Exp;
branches;
next	;


desc
@@


1.11
log
@	* pmacros.scm (pmacros-init!): New arg rtl-version, all callers
	updated.  Use %-prefix if rtl-version >= 0.9.
	* read.scm (/supported-rtl-versions): Add (0 9).
	(/rtl-version-valid?): New function.
	(/cmd-define-rtl-version): If new rtl version, reinvoke pmacros-init!.
	(/reader-expr): New function.
	(reader-process): New function.
	(/reader-process-with-loc!): Renamed from /reader-process!.
	Don't pre-expand `if' commands.
	(/cmd-if): Simplify.  Pmacro-expand test, then, else clauses here.
	Handle rtl-version-equal?, rtl-version-at-least?.
	* testsuite/Makefile.am (clean-test-files): Remove *.test.cpu*.
	* testsuite/Makefile.in: Regenerate.
	* testsuite/pmacros-1.test: Test both . and % as prefixes.
	* testsuite/testsuite.cpu (/begin, /print, /dump): New pmacros.
	(newline, print-match, print-expr, print-thunk): Use them.
	(internal-verify): Update definition.
	* doc/rtl.texi (define-rtl-version): Document rtl version 0.9.
	(Top level conditionals): New node.
@
text
@# pmacro testcase #1 -*- shell-script -*-

gen_cpu_file() {
    rtl_version=$1
    prefix=$2

    cat > ${cpu_file} <<EOF
(define-rtl-version ${rtl_version})
(include "${srcdir}/../cpu/simplify.inc")
(include "${srcdir}/testsuite.cpu")

(define-pmacro sym-const name1)
(define-pmacro str-const "string1")
(define-pmacro int-const 1)

(define-pmacro list-const
  (
   (name1 "string1" 1)
   (name2 "string2" 2)
   (name3 "string3" 3)
   )
)
(${prefix}print list-const "\n")

(test-name "${prefix}ref, ${prefix}car")
(${prefix}if (${prefix}not (${prefix}equal? (${prefix}ref (${prefix}car list-const) 2) 1))
     (${prefix}print "FAIL (${prefix}not (${prefix}equal? (${prefix}ref (${prefix}car list-const) 2) 1))\n"))

(test-name "${prefix}for-each, nested ${prefix}pmacros")
(print-match "adgbehcfi")
(print-thunk (${prefix}pmacro ()
               (${prefix}begin
                 (${prefix}for-each (${prefix}pmacro (x y z)
		              (${prefix}print x y z))
                            (a b c) (d e f) (g h i)))))
(test-name "nested ${prefix}pmacros with bindings")
(print-match "(+ 4 3)")
(print-thunk (${prefix}pmacro ()
               (${prefix}dump ((${prefix}pmacro (arg1 arg2)
                         ((${prefix}pmacro (bar) (+ arg2 bar)) arg1))
                       3 4))))

(test-name "${prefix}dump")
(print-match "(name1 \"string1\" 1)(name2 \"string2\" 2)(name3 \"string3\" 3)\n")
(${prefix}print "EXPR: ")
(${prefix}for-each (${prefix}pmacro (a) (${prefix}dump a)) list-const)
(newline)

(test-name "${prefix}sym")
(print-match "abc\n")
(print-expr (${prefix}sym a "b" c))

(test-name "${prefix}str")
(print-match "\"def\"\n")
(print-expr (${prefix}str d "e" f))

(test-name "${prefix}hex")
(print-match "\"2a\"")
(print-expr (${prefix}hex 42))

(test-name "${prefix}upcase")
(print-match "\"UPPER\"")
(print-expr (${prefix}upcase "upper"))
(print-match "UPPER")
(print-expr (${prefix}upcase upper))

(test-name "${prefix}downcase")
(print-match "\"downer\"")
(print-expr (${prefix}downcase "DOWNER"))
(print-match "downer")
(print-expr (${prefix}downcase DOWNER))

(test-name "${prefix}substring")
(print-match "\"zz\"")
(print-expr (${prefix}substring "xyzzy" 2 4))
(print-match "zz")
(print-expr (${prefix}substring xyzzy 2 4))

(test-name "${prefix}splice1")
(print-match "(now is the time)")
(print-expr (${prefix}splice now (${prefix}unsplice (is the time))))

;; Arguments to ${prefix}splice/${prefix}unsplice are evaluated.
(test-name "${prefix}splice2")
(print-match "(now is the time)")
(define-pmacro splice2-piece now)
(print-expr (${prefix}splice splice2-piece (${prefix}unsplice (is the time))))

;; Arguments to ${prefix}splice/${prefix}unsplice are evaluated.
(test-name "${prefix}splice3")
(print-match "(now is the time)")
(define-pmacro splice3-piece the)
(print-expr (${prefix}splice now (${prefix}unsplice (is splice3-piece time))))

(test-name "${prefix}iota")
(print-match "(0 1 2 3)")
(print-expr (${prefix}iota 4))
(print-match "(1 2 3 4)")
(print-expr (${prefix}iota 4 1))
(print-match "(2 4 6 8)")
(print-expr (${prefix}iota 4 2 2))

(test-name "${prefix}map")
(print-match "(\"a\" \"b\" \"c\")")
(print-expr (${prefix}map ${prefix}hex (10 11 12)))
(print-match "(\"a\" \"b\" \"c\")")
(print-expr (${prefix}map (${prefix}pmacro (x) (${prefix}hex x)) (10 11 12)))

(test-name "${prefix}apply")
(print-match "ABC")
(print-expr (${prefix}apply ${prefix}upcase (abc)))

(test-name "${prefix}pmacro?")
(print-match "#t")
(print-expr (${prefix}pmacro? ${prefix}pmacro?))
(print-match "#t")
(print-expr (${prefix}pmacro? test-name))
(print-match "#t")
(print-expr (${prefix}pmacro? (${prefix}pmacro (a) (add a 1))))
(print-match "#f")
(print-expr (${prefix}pmacro? 42))

(test-name "${prefix}eval")
(print-match "(explicitly-undefined 42)")
(define-pmacro (eval-test1 a) (explicitly-undefined a))
(print-expr (${prefix}eval (${prefix}splice eval-test1 (${prefix}unsplice (42)))))

(test-name "${prefix}let")
(print-match "xyzzy")
(print-expr (${prefix}let ((x xyzzy)) x))
;; FIXME: This is the currently defined behaviour, but it's somewhat
;; unintuitive.
;; pmacro expansion re-evaluates the result if it's also a pmacro,
;; so x -> y -> x and y -> x -> y.
(print-match "(x y)")
(print-expr (${prefix}let ((x y) (y x)) (${prefix}list x y)))

(test-name "${prefix}let*")
(print-match "(1 2)")
(print-expr (${prefix}let* ((x 1) (y (${prefix}add x 1))) (${prefix}list x y)))

(test-name "${prefix}if")
(print-match "then")
(print-expr (${prefix}if #t then else))
(print-match "else")
(print-expr (${prefix}if #f then else))

(test-name "${prefix}case")
(print-match "123")
(print-expr (${prefix}case seba ((seba beach) 123) (else 456)))
(print-match "123")
(print-expr (${prefix}case beach ((seba beach) 123) (else 456)))
(print-match "456")
(print-expr (${prefix}case 0 ((seba beach) 123) (else 456)))

(test-name "${prefix}cond")
(print-match "yep")
(print-expr (${prefix}cond ((${prefix}eq 1 1) yep) (else nope)))
(print-match "nope")
(print-expr (${prefix}cond ((${prefix}eq 1 2) yep) (else nope)))

(test-name "${prefix}begin")
(print-match "xyz")
(print-thunk (${prefix}pmacro () (${prefix}begin (${prefix}print "x") (${prefix}print "y") (${prefix}print "z"))))

(test-name "${prefix}list, ${prefix}ref")
(print-match "grief")
(print-expr (${prefix}ref (${prefix}list good grief) 1))

(test-name "${prefix}length")
(print-match "6")
(print-expr (${prefix}length snoopy))
(print-match "9")
(print-expr (${prefix}length "woodstock"))
(print-match "4")
(print-expr (${prefix}length (good grief charlie brown)))

(test-name "${prefix}replicate")
(print-match "(no no no no)")
(print-expr (${prefix}replicate 4 no))

(test-name "${prefix}find")
(print-match "(0 1)")
(print-expr (${prefix}find (${prefix}pmacro (n) (${prefix}lt n 2)) (${prefix}iota 4)))

(test-name "${prefix}equal?")
(print-match "#t")
(print-expr (${prefix}equal? (yo yo) (yo yo)))
(print-match "#f")
(print-expr (${prefix}equal? (yo yo) (yo x)))

(test-name "${prefix}andif")
(print-match "andif")
(print-expr (${prefix}andif 1 #t andif))
(print-match "#f")
(print-expr (${prefix}andif 1 #f andif))
(print-match "#t")
(print-expr (${prefix}andif))

(test-name "${prefix}orif")
(print-match "orif")
(print-expr (${prefix}orif #f orif))
(print-match "#f")
(print-expr (${prefix}orif #f #f))
(print-match "#f")
(print-expr (${prefix}orif))

(test-name "${prefix}not")
(print-match "yep")
(print-expr (${prefix}if (${prefix}not #f) yep nope))
(print-match "nope")
(print-expr (${prefix}if (${prefix}not #t) yep nope))

(test-name "${prefix}eq")
(print-match "eq")
(print-expr (${prefix}if (${prefix}eq foo foo) eq ne))
(print-match "eq2")
(print-expr (${prefix}if (${prefix}eq 1 1) eq2 ne2))

(test-name "${prefix}ne")
(print-match "ne")
(print-expr (${prefix}if (${prefix}ne foo bar) ne eq))
(print-match "ne2")
(print-expr (${prefix}if (${prefix}ne 1 2) ne2 eq2))

(test-name "${prefix}lt")
(print-match "lt")
(print-expr (${prefix}if (${prefix}lt 1 2) lt nope))

(test-name "${prefix}gt")
(print-match "gt")
(print-expr (${prefix}if (${prefix}gt 1 0) gt nope))

(test-name "${prefix}le")
(print-match "le1")
(print-expr (${prefix}if (${prefix}le 1 1) le1 nope))
(print-match "le2")
(print-expr (${prefix}if (${prefix}le 1 2) le2 nope))

(test-name "${prefix}ge")
(print-match "ge1")
(print-expr (${prefix}if (${prefix}ge 1 1) ge1 nope))
(print-match "ge2")
(print-expr (${prefix}if (${prefix}ge 1 0) ge2 nope))

(test-name "${prefix}add")
(print-match "3")
(print-expr (${prefix}add 1 2))

(test-name "${prefix}sub")
(print-match "-1")
(print-expr (${prefix}sub 1 2))

(test-name "${prefix}mul")
(print-match "6")
(print-expr (${prefix}mul 2 3))

(test-name "${prefix}div")
(print-match "4")
(print-expr (${prefix}div 8 2))

(test-name "${prefix}rem")
(print-match "0")
(print-expr (${prefix}rem 8 2))

(test-name "${prefix}sll")
(print-match "8")
(print-expr (${prefix}sll 1 3))
(print-match "4")
(print-expr (${prefix}sll 4 0))

(test-name "${prefix}srl")
(print-match "1")
(print-expr (${prefix}srl 8 3))
(print-match "4")
(print-expr (${prefix}srl 4 0))

(test-name "${prefix}sra")
(print-match "-1")
(print-expr (${prefix}sra -1 0))
(print-match "-1")
(print-expr (${prefix}sra -1 1))
(print-match "-2")
(print-expr (${prefix}sra -3 1))

(test-name "${prefix}and")
(print-match "8")
(print-expr (${prefix}and 15 8))

(test-name "${prefix}or")
(print-match "15")
(print-expr (${prefix}or 15 8))

(test-name "${prefix}xor")
(print-match "7")
(print-expr (${prefix}xor 15 8))

(test-name "${prefix}inv")
(print-match "-6")
(print-expr (${prefix}inv 5))

(test-name "${prefix}car")
(print-match "car")
(print-expr (${prefix}car (car cdr)))

(test-name "${prefix}cdr")
(print-match "(cdr)")
(print-expr (${prefix}cdr (car cdr)))

(test-name "${prefix}caar")
(print-match "caar")
(print-expr (${prefix}caar ((caar cdar) cadr cddr)))

(test-name "${prefix}cadr")
(print-match "cadr")
(print-expr (${prefix}cadr ((caar cdar) cadr cddr)))

(test-name "${prefix}cdar")
(print-match "(cdar)")
(print-expr (${prefix}cdar ((caar cdar) cadr cddr)))

(test-name "${prefix}cddr")
(print-match "(cddr)")
(print-expr (${prefix}cddr ((caar cdar) cadr cddr)))

EOF
}

# Run the test twice, once for each kind of prefix.

for iter in dot percent
do
    test="pmacros-1-${iter}"

    source ./test-utils.sh

    cpu_file=${test}.test.cpu
    rm -f ${cpu_file}

    case ${iter} in
    dot) gen_cpu_file "0 8" "." ;;
    percent) gen_cpu_file "0 9" "%" ;;
    esac

    run_cgen ${cpu_file}

    post_process
done

finish
@


1.10
log
@	* testsuite/pmacros-1.test: Add more .splice tests.
@
text
@d3 3
a5 1
test=pmacros-1
d7 2
a8 6
source ./test-utils.sh

cpu_file=${test}.test.cpu
rm -f ${cpu_file}

cat > ${cpu_file} <<EOF
d23 1
a23 1
(.print list-const "\n")
d25 3
a27 3
(test-name ".ref, .car")
(.if (.not (.equal? (.ref (.car list-const) 2) 1))
     (.print "FAIL (.not (.equal? (.ref (.car list-const) 2) 1))\n"))
d29 1
a29 1
(test-name ".for-each, nested .pmacros")
d31 4
a34 4
(print-thunk (.pmacro ()
               (.begin
                 (.for-each (.pmacro (x y z)
		              (.print x y z))
d36 1
a36 1
(test-name "nested .pmacros with bindings")
d38 3
a40 3
(print-thunk (.pmacro ()
               (.dump ((.pmacro (arg1 arg2)
                         ((.pmacro (bar) (+ arg2 bar)) arg1))
d43 1
a43 1
(test-name ".dump")
d45 2
a46 2
(.print "EXPR: ")
(.for-each (.pmacro (a) (.dump a)) list-const)
d49 1
a49 1
(test-name ".sym")
d51 1
a51 1
(print-expr (.sym a "b" c))
d53 1
a53 1
(test-name ".str")
d55 1
a55 1
(print-expr (.str d "e" f))
d57 1
a57 1
(test-name ".hex")
d59 1
a59 1
(print-expr (.hex 42))
d61 1
a61 1
(test-name ".upcase")
d63 1
a63 1
(print-expr (.upcase "upper"))
d65 1
a65 1
(print-expr (.upcase upper))
d67 1
a67 1
(test-name ".downcase")
d69 1
a69 1
(print-expr (.downcase "DOWNER"))
d71 1
a71 1
(print-expr (.downcase DOWNER))
d73 1
a73 1
(test-name ".substring")
d75 1
a75 1
(print-expr (.substring "xyzzy" 2 4))
d77 1
a77 1
(print-expr (.substring xyzzy 2 4))
d79 1
a79 1
(test-name ".splice1")
d81 1
a81 1
(print-expr (.splice now (.unsplice (is the time))))
d83 2
a84 2
;; Arguments to .splice/.unsplice are evaluated.
(test-name ".splice2")
d87 1
a87 1
(print-expr (.splice splice2-piece (.unsplice (is the time))))
d89 2
a90 2
;; Arguments to .splice/.unsplice are evaluated.
(test-name ".splice3")
d93 1
a93 1
(print-expr (.splice now (.unsplice (is splice3-piece time))))
d95 1
a95 1
(test-name ".iota")
d97 1
a97 1
(print-expr (.iota 4))
d99 1
a99 1
(print-expr (.iota 4 1))
d101 1
a101 1
(print-expr (.iota 4 2 2))
d103 1
a103 1
(test-name ".map")
d105 1
a105 1
(print-expr (.map .hex (10 11 12)))
d107 1
a107 1
(print-expr (.map (.pmacro (x) (.hex x)) (10 11 12)))
d109 1
a109 1
(test-name ".apply")
d111 1
a111 1
(print-expr (.apply .upcase (abc)))
d113 1
a113 1
(test-name ".pmacro?")
d115 1
a115 1
(print-expr (.pmacro? .pmacro?))
d117 1
a117 1
(print-expr (.pmacro? test-name))
d119 1
a119 1
(print-expr (.pmacro? (.pmacro (a) (add a 1))))
d121 1
a121 1
(print-expr (.pmacro? 42))
d123 1
a123 1
(test-name ".eval")
d126 1
a126 1
(print-expr (.eval (.splice eval-test1 (.unsplice (42)))))
d128 1
a128 1
(test-name ".let")
d130 1
a130 1
(print-expr (.let ((x xyzzy)) x))
d136 1
a136 1
(print-expr (.let ((x y) (y x)) (.list x y)))
d138 1
a138 1
(test-name ".let*")
d140 1
a140 1
(print-expr (.let* ((x 1) (y (.add x 1))) (.list x y)))
d142 1
a142 1
(test-name ".if")
d144 1
a144 1
(print-expr (.if #t then else))
d146 1
a146 1
(print-expr (.if #f then else))
d148 1
a148 1
(test-name ".case")
d150 1
a150 1
(print-expr (.case seba ((seba beach) 123) (else 456)))
d152 1
a152 1
(print-expr (.case beach ((seba beach) 123) (else 456)))
d154 1
a154 1
(print-expr (.case 0 ((seba beach) 123) (else 456)))
d156 1
a156 1
(test-name ".cond")
d158 1
a158 1
(print-expr (.cond ((.eq 1 1) yep) (else nope)))
d160 1
a160 1
(print-expr (.cond ((.eq 1 2) yep) (else nope)))
d162 1
a162 1
(test-name ".begin")
d164 1
a164 1
(print-thunk (.pmacro () (.begin (.print "x") (.print "y") (.print "z"))))
d166 1
a166 1
(test-name ".list, .ref")
d168 1
a168 1
(print-expr (.ref (.list good grief) 1))
d170 1
a170 1
(test-name ".length")
d172 1
a172 1
(print-expr (.length snoopy))
d174 1
a174 1
(print-expr (.length "woodstock"))
d176 1
a176 1
(print-expr (.length (good grief charlie brown)))
d178 1
a178 1
(test-name ".replicate")
d180 1
a180 1
(print-expr (.replicate 4 no))
d182 1
a182 1
(test-name ".find")
d184 1
a184 1
(print-expr (.find (.pmacro (n) (.lt n 2)) (.iota 4)))
d186 1
a186 1
(test-name ".equal?")
d188 1
a188 1
(print-expr (.equal? (yo yo) (yo yo)))
d190 1
a190 1
(print-expr (.equal? (yo yo) (yo x)))
d192 1
a192 1
(test-name ".andif")
d194 1
a194 1
(print-expr (.andif 1 #t andif))
d196 1
a196 1
(print-expr (.andif 1 #f andif))
d198 1
a198 1
(print-expr (.andif))
d200 1
a200 1
(test-name ".orif")
d202 1
a202 1
(print-expr (.orif #f orif))
d204 1
a204 1
(print-expr (.orif #f #f))
d206 1
a206 1
(print-expr (.orif))
d208 1
a208 1
(test-name ".not")
d210 1
a210 1
(print-expr (.if (.not #f) yep nope))
d212 1
a212 1
(print-expr (.if (.not #t) yep nope))
d214 1
a214 1
(test-name ".eq")
d216 1
a216 1
(print-expr (.if (.eq foo foo) eq ne))
d218 1
a218 1
(print-expr (.if (.eq 1 1) eq2 ne2))
d220 1
a220 1
(test-name ".ne")
d222 1
a222 1
(print-expr (.if (.ne foo bar) ne eq))
d224 1
a224 1
(print-expr (.if (.ne 1 2) ne2 eq2))
d226 1
a226 1
(test-name ".lt")
d228 1
a228 1
(print-expr (.if (.lt 1 2) lt nope))
d230 1
a230 1
(test-name ".gt")
d232 1
a232 1
(print-expr (.if (.gt 1 0) gt nope))
d234 1
a234 1
(test-name ".le")
d236 1
a236 1
(print-expr (.if (.le 1 1) le1 nope))
d238 1
a238 1
(print-expr (.if (.le 1 2) le2 nope))
d240 1
a240 1
(test-name ".ge")
d242 1
a242 1
(print-expr (.if (.ge 1 1) ge1 nope))
d244 1
a244 1
(print-expr (.if (.ge 1 0) ge2 nope))
d246 1
a246 1
(test-name ".add")
d248 1
a248 1
(print-expr (.add 1 2))
d250 1
a250 1
(test-name ".sub")
d252 1
a252 1
(print-expr (.sub 1 2))
d254 1
a254 1
(test-name ".mul")
d256 1
a256 1
(print-expr (.mul 2 3))
d258 1
a258 1
(test-name ".div")
d260 1
a260 1
(print-expr (.div 8 2))
d262 1
a262 1
(test-name ".rem")
d264 1
a264 1
(print-expr (.rem 8 2))
d266 1
a266 1
(test-name ".sll")
d268 1
a268 1
(print-expr (.sll 1 3))
d270 1
a270 1
(print-expr (.sll 4 0))
d272 1
a272 1
(test-name ".srl")
d274 1
a274 1
(print-expr (.srl 8 3))
d276 1
a276 1
(print-expr (.srl 4 0))
d278 1
a278 1
(test-name ".sra")
d280 1
a280 1
(print-expr (.sra -1 0))
d282 1
a282 1
(print-expr (.sra -1 1))
d284 1
a284 1
(print-expr (.sra -3 1))
d286 1
a286 1
(test-name ".and")
d288 1
a288 1
(print-expr (.and 15 8))
d290 1
a290 1
(test-name ".or")
d292 1
a292 1
(print-expr (.or 15 8))
d294 1
a294 1
(test-name ".xor")
d296 1
a296 1
(print-expr (.xor 15 8))
d298 1
a298 1
(test-name ".inv")
d300 1
a300 1
(print-expr (.inv 5))
d302 1
a302 1
(test-name ".car")
d304 1
a304 1
(print-expr (.car (car cdr)))
d306 1
a306 1
(test-name ".cdr")
d308 1
a308 1
(print-expr (.cdr (car cdr)))
d310 1
a310 1
(test-name ".caar")
d312 1
a312 1
(print-expr (.caar ((caar cdar) cadr cddr)))
d314 1
a314 1
(test-name ".cadr")
d316 1
a316 1
(print-expr (.cadr ((caar cdar) cadr cddr)))
d318 1
a318 1
(test-name ".cdar")
d320 1
a320 1
(print-expr (.cdar ((caar cdar) cadr cddr)))
d322 1
a322 1
(test-name ".cddr")
d324 1
a324 1
(print-expr (.cddr ((caar cdar) cadr cddr)))
d327 17
d345 1
a345 1
run_cgen ${cpu_file}
d347 2
a348 1
post_process
@


1.9
log
@	Pmacro .equals -> .equal?
	* pmacros.scm (-pmacro-builtin-equal?): Renamed from
	-pmacro-builtin-equals.  All callers updated.
	(pmacros-init!): Rename .equals to .equal?.
	* doc/pmacros.texi: Update.
	* testsuite/pmacros-1.test: Update.
@
text
@d81 1
a81 1
(test-name ".splice")
d85 12
@


1.8
log
@	New builtin .pmacro?.
	* pmacros.scm (-pmacro-builtin-pmacro?): New function.
	(pmacros-init!): Add .pmacro?.
	* doc/pmacros.text: Document .pmacro?.
	* testsuite/pmacros-1.test: Test .pmacro?.
@
text
@d28 2
a29 2
(.if (.not (.equals (.ref (.car list-const) 2) 1))
     (.print "FAIL (.not (.equals (.ref (.car list-const) 2) 1))\n"))
d176 1
a176 1
(test-name ".equals")
d178 1
a178 1
(print-expr (.equals (yo yo) (yo yo)))
d180 1
a180 1
(print-expr (.equals (yo yo) (yo x)))
@


1.7
log
@	* pmacros.scm (.sll, .srl, .sra): Fix thinko.
	* testsuite/pmacros-1.test: Ditto.  Add better tests.
@
text
@d103 10
@


1.6
log
@	Rename .eval -> .exec.  Add new .eval.
	* pmacros.scm (-pmacro-built-exec): Renamed from -pmacro-builtin-eval.
	(-pmacro-builtin-eval): New function.
	(pmacros-init!): Add .exec.
	* doc/pmacros.texi: Update, .exec -> .eval.  Document new .eval.
	* testsuite/location-1.test: Update.
	* testsuite/pmacros-1.test: Add test for .eval.
@
text
@d247 2
a248 2
(print-match "4")
(print-expr (.sll 1 2))
d254 1
a254 1
(print-expr (.srl 4 2))
d263 1
a263 1
(print-match "-1")
@


1.5
log
@	Add .let* pmacro builtin.
	* pmacros.scm (-pmacro-builtin-let*): New function.
	(pmacros-init!): Add .let*.
	* doc/pmacros.texi: Document .let*.
	* testsuite/pmacros-1.test: Test .let*.
@
text
@d103 5
@


1.4
log
@	* pmacros.scm (-pmacro-builtin-find): New predicate.
	(pmacros-init!): Add .find.
	* doc/pmacros.tex: Document .find.
	* testsuite/pmacros-1.test: Test .find.
@
text
@d106 10
@


1.3
log
@Add testcase for nested pmacros with bindings.
@
text
@d147 4
@


1.2
log
@	* doc/pmacros.texi (.not): Emphasize (.not 0) is not 1.

	Rename builtin boolean pmacros, for consistency with rtl.
	* pmacros.scm: .and -> .andif, .or -> .orif, .bitand -> .and,
	.bitor -> .or, .bitxor -> .xor, .bitinv -> .inv.
	* doc/pmacros.texi: Update.
	* testsuite/pmacros-1.test: Update.
@
text
@d38 6
@


1.1
log
@	Extend pmacro language, add testsuite.
	* Makefile.am (SUBDIRS): Add testsuite.
	* Makefile.in: Regenerate.
	* configure.in (AC_OUTPUT): Create testsuite/Makefile,
	testsuite/test-utils.sh.
	* configure: Regenerate.
	* dev.scm (cload): Handle testsuite app.
	(load-testsuite): New function.
	* pmacros.scm: (-pmacro-debug?): New global.
	(-smacro-table): New global.
	(-smacro-lookup, -smacro-set!): New functions.
	(-pmacro-make): New argument `syntactic-form?', all callers updated.
	(-pmacro-syntactic-form?): New function.
	(-pmacro-expected-number, -pmacro-verify-number): New functions.
	(-pmacro-expected-integer, -pmacro-verify-integer): New functions.
	(-pmacro-expected-non-negative-integer): New function.
	(-pmacro-verify-non-negative-integer): New function.
	(-pmacro-expand-expr-list): New function.
	(-pmacro-process-args-1): Renamed from -pmacro-process-args.
	(-pmacro-process-args): Renamed from -pmacro-invoke.
	(-pmacro-apply, -smacro-apply): New functions.
	(-pmacro-expand): Rewrite syntactic form processing.
	(-pmacro-build-lambda): Reformat.
	(define-pmacro): Watch for more errors in definition.
	(pmacro-debug): New function.
	(pmacro-trace): Set/reset -pmacro-debug?.
	(all existing builtin pmacro helpers): Rename to -pmacro-builtin-foo.
	(-pmacro-builtin-substring): Fix.  Add support for `end' marker.
	(-pmacro-builtin-for-each, et.al.): New helpers for .for-each, .let,
	.if, .case, .cond, .begin, .print, .dump, .error, .list, .ref,
	.length, .replicate, .equals, .and, .or, .not, .eq, .ne, .lt, .gt,
	.le, .ge, .add, .sub, .mul, .div, .rem, .sll, .srl, .sra, .bitand,
	.bitor, .bitxor, bitinv, .car, .cdr, .caar, .cadr, .cdar, .cddr.
	(pmacros-init!): Initialize -smacro-table.
	Rewrite pmacro initialization.
	* read.scm (reader-process-expanded): Renamed from
	-reader-process-expanded.  All callers updated.
	Recognize () as a no-op.
	(cpu-load): Tweak logging messages.
	* utils.scm (message): Add comment.
	* cpu/play.cpu: Add some instructions to play with .let.
	* doc/cgenint.texi: Move some debugging related docs to here from
	cgen.texi.
	* doc/pmacros.texi: Reorganize.  Add docs for new builtin pmacros.
	* testsuite/Makefile.am: New file.
	* testsuite/Makefile.in: New file.
	* testsuite/test-utils.sh.in: New file.
	* testsuite/run-tests.sh: New file.
	* testsuite/testsuite.cpu: New file.
	* testsuite/pmacros-1.test: New file.
@
text
@d147 3
a149 3
(test-name ".and")
(print-match "and")
(print-expr (.and 1 #t and))
d151 1
a151 1
(print-expr (.and 1 #f and))
d153 1
a153 1
(print-expr (.and))
d155 3
a157 3
(test-name ".or")
(print-match "or")
(print-expr (.or #f or))
d159 1
a159 1
(print-expr (.or #f #f))
d161 1
a161 1
(print-expr (.or))
d241 1
a241 1
(test-name ".bitand")
d243 1
a243 1
(print-expr (.bitand 15 8))
d245 1
a245 1
(test-name ".bitor")
d247 1
a247 1
(print-expr (.bitor 15 8))
d249 1
a249 1
(test-name ".bitxor")
d251 1
a251 1
(print-expr (.bitxor 15 8))
d253 1
a253 1
(test-name ".bitinv")
d255 1
a255 1
(print-expr (.bitinv 5))
@


1.1.2.1
log
@Copy over from trunk.
	Extend pmacro language, add testsuite.
	* Makefile.am (SUBDIRS): Add testsuite.
	* Makefile.in: Regenerate.
	* configure.in (AC_OUTPUT): Create testsuite/Makefile,
	testsuite/test-utils.sh.
	* configure: Regenerate.
	* dev.scm (cload): Handle testsuite app.
	(load-testsuite): New function.
	* pmacros.scm: (-pmacro-debug?): New global.
	(-smacro-table): New global.
	(-smacro-lookup, -smacro-set!): New functions.
	(-pmacro-make): New argument `syntactic-form?', all callers updated.
	(-pmacro-syntactic-form?): New function.
	(-pmacro-expected-number, -pmacro-verify-number): New functions.
	(-pmacro-expected-integer, -pmacro-verify-integer): New functions.
	(-pmacro-expected-non-negative-integer): New function.
	(-pmacro-verify-non-negative-integer): New function.
	(-pmacro-expand-expr-list): New function.
	(-pmacro-process-args-1): Renamed from -pmacro-process-args.
	(-pmacro-process-args): Renamed from -pmacro-invoke.
	(-pmacro-apply, -smacro-apply): New functions.
	(-pmacro-expand): Rewrite syntactic form processing.
	(-pmacro-build-lambda): Reformat.
	(define-pmacro): Watch for more errors in definition.
	(pmacro-debug): New function.
	(pmacro-trace): Set/reset -pmacro-debug?.
	(all existing builtin pmacro helpers): Rename to -pmacro-builtin-foo.
	(-pmacro-builtin-substring): Fix.  Add support for `end' marker.
	(-pmacro-builtin-for-each, et.al.): New helpers for .for-each, .let,
	.if, .case, .cond, .begin, .print, .dump, .error, .list, .ref,
	.length, .replicate, .equals, .and, .or, .not, .eq, .ne, .lt, .gt,
	.le, .ge, .add, .sub, .mul, .div, .rem, .sll, .srl, .sra, .bitand,
	.bitor, .bitxor, bitinv, .car, .cdr, .caar, .cadr, .cdar, .cddr.
	(pmacros-init!): Initialize -smacro-table.
	Rewrite pmacro initialization.
	* read.scm (reader-process-expanded): Renamed from
	-reader-process-expanded.  All callers updated.
	Recognize () as a no-op.
	(cpu-load): Tweak logging messages.
	* utils.scm (message): Add comment.
	* cpu/play.cpu: Add some instructions to play with .let.
	* doc/cgenint.texi: Move some debugging related docs to here from
	cgen.texi.
	* doc/pmacros.texi: Reorganize.  Add docs for new builtin pmacros.
	* testsuite/Makefile.am: New file.
	* testsuite/Makefile.in: New file.
	* testsuite/test-utils.sh.in: New file.
	* testsuite/run-tests.sh: New file.
	* testsuite/testsuite.cpu: New file.
	* testsuite/pmacros-1.test: New file.
@
text
@@

