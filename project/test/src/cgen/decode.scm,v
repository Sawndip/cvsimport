head	1.16;
access;
symbols
	sid-snapshot-20180601:1.16
	cgen-snapshot-20180601:1.16
	sid-snapshot-20180501:1.16
	cgen-snapshot-20180501:1.16
	sid-snapshot-20180401:1.16
	cgen-snapshot-20180401:1.16
	sid-snapshot-20180301:1.16
	cgen-snapshot-20180301:1.16
	sid-snapshot-20180201:1.16
	cgen-snapshot-20180201:1.16
	sid-snapshot-20180101:1.16
	cgen-snapshot-20180101:1.16
	sid-snapshot-20171201:1.16
	cgen-snapshot-20171201:1.16
	sid-snapshot-20171101:1.16
	cgen-snapshot-20171101:1.16
	sid-snapshot-20171001:1.16
	cgen-snapshot-20171001:1.16
	sid-snapshot-20170901:1.16
	cgen-snapshot-20170901:1.16
	sid-snapshot-20170801:1.16
	cgen-snapshot-20170801:1.16
	sid-snapshot-20170701:1.16
	cgen-snapshot-20170701:1.16
	sid-snapshot-20170601:1.16
	cgen-snapshot-20170601:1.16
	sid-snapshot-20170501:1.16
	cgen-snapshot-20170501:1.16
	sid-snapshot-20170401:1.16
	cgen-snapshot-20170401:1.16
	sid-snapshot-20170301:1.16
	cgen-snapshot-20170301:1.16
	sid-snapshot-20170201:1.16
	cgen-snapshot-20170201:1.16
	sid-snapshot-20170101:1.16
	cgen-snapshot-20170101:1.16
	sid-snapshot-20161201:1.16
	cgen-snapshot-20161201:1.16
	sid-snapshot-20161101:1.16
	cgen-snapshot-20161101:1.16
	sid-snapshot-20160901:1.16
	cgen-snapshot-20160901:1.16
	sid-snapshot-20160801:1.16
	cgen-snapshot-20160801:1.16
	sid-snapshot-20160701:1.16
	cgen-snapshot-20160701:1.16
	sid-snapshot-20160601:1.16
	cgen-snapshot-20160601:1.16
	sid-snapshot-20160501:1.16
	cgen-snapshot-20160501:1.16
	sid-snapshot-20160401:1.16
	cgen-snapshot-20160401:1.16
	sid-snapshot-20160301:1.16
	cgen-snapshot-20160301:1.16
	sid-snapshot-20160201:1.16
	cgen-snapshot-20160201:1.16
	sid-snapshot-20160101:1.16
	cgen-snapshot-20160101:1.16
	sid-snapshot-20151201:1.16
	cgen-snapshot-20151201:1.16
	sid-snapshot-20151101:1.16
	cgen-snapshot-20151101:1.16
	sid-snapshot-20151001:1.16
	cgen-snapshot-20151001:1.16
	sid-snapshot-20150901:1.16
	cgen-snapshot-20150901:1.16
	sid-snapshot-20150801:1.16
	cgen-snapshot-20150801:1.16
	sid-snapshot-20150701:1.16
	cgen-snapshot-20150701:1.16
	sid-snapshot-20150601:1.16
	cgen-snapshot-20150601:1.16
	sid-snapshot-20150501:1.16
	cgen-snapshot-20150501:1.16
	sid-snapshot-20150401:1.16
	cgen-snapshot-20150401:1.16
	sid-snapshot-20150301:1.16
	cgen-snapshot-20150301:1.16
	sid-snapshot-20150201:1.16
	cgen-snapshot-20150201:1.16
	sid-snapshot-20150101:1.16
	cgen-snapshot-20150101:1.16
	sid-snapshot-20141201:1.16
	cgen-snapshot-20141201:1.16
	sid-snapshot-20141101:1.16
	cgen-snapshot-20141101:1.16
	sid-snapshot-20141001:1.16
	cgen-snapshot-20141001:1.16
	sid-snapshot-20140901:1.16
	cgen-snapshot-20140901:1.16
	sid-snapshot-20140801:1.16
	cgen-snapshot-20140801:1.16
	sid-snapshot-20140701:1.16
	cgen-snapshot-20140701:1.16
	sid-snapshot-20140601:1.16
	cgen-snapshot-20140601:1.16
	sid-snapshot-20140501:1.16
	cgen-snapshot-20140501:1.16
	sid-snapshot-20140401:1.16
	cgen-snapshot-20140401:1.16
	sid-snapshot-20140301:1.16
	cgen-snapshot-20140301:1.16
	sid-snapshot-20140201:1.16
	cgen-snapshot-20140201:1.16
	sid-snapshot-20140101:1.16
	cgen-snapshot-20140101:1.16
	sid-snapshot-20131201:1.16
	cgen-snapshot-20131201:1.16
	sid-snapshot-20131101:1.16
	cgen-snapshot-20131101:1.16
	sid-snapshot-20131001:1.16
	cgen-snapshot-20131001:1.16
	sid-snapshot-20130901:1.16
	cgen-snapshot-20130901:1.16
	sid-snapshot-20130801:1.16
	cgen-snapshot-20130801:1.16
	sid-snapshot-20130701:1.16
	cgen-snapshot-20130701:1.16
	sid-snapshot-20130601:1.16
	cgen-snapshot-20130601:1.16
	sid-snapshot-20130501:1.16
	cgen-snapshot-20130501:1.16
	sid-snapshot-20130401:1.16
	cgen-snapshot-20130401:1.16
	sid-snapshot-20130301:1.16
	cgen-snapshot-20130301:1.16
	sid-snapshot-20130201:1.16
	cgen-snapshot-20130201:1.16
	sid-snapshot-20130101:1.16
	cgen-snapshot-20130101:1.16
	sid-snapshot-20121201:1.16
	cgen-snapshot-20121201:1.16
	sid-snapshot-20121101:1.16
	cgen-snapshot-20121101:1.16
	sid-snapshot-20121001:1.16
	cgen-snapshot-20121001:1.16
	sid-snapshot-20120901:1.16
	cgen-snapshot-20120901:1.16
	sid-snapshot-20120801:1.16
	cgen-snapshot-20120801:1.16
	sid-snapshot-20120701:1.16
	cgen-snapshot-20120701:1.16
	sid-snapshot-20120601:1.16
	cgen-snapshot-20120601:1.16
	sid-snapshot-20120501:1.16
	cgen-snapshot-20120501:1.16
	sid-snapshot-20120401:1.16
	cgen-snapshot-20120401:1.16
	sid-snapshot-20120301:1.16
	cgen-snapshot-20120301:1.16
	sid-snapshot-20120201:1.16
	cgen-snapshot-20120201:1.16
	sid-snapshot-20120101:1.16
	cgen-snapshot-20120101:1.16
	sid-snapshot-20111201:1.16
	cgen-snapshot-20111201:1.16
	sid-snapshot-20111101:1.16
	cgen-snapshot-20111101:1.16
	sid-snapshot-20111001:1.16
	cgen-snapshot-20111001:1.16
	sid-snapshot-20110901:1.16
	cgen-snapshot-20110901:1.16
	sid-snapshot-20110801:1.16
	cgen-snapshot-20110801:1.16
	sid-snapshot-20110701:1.16
	cgen-snapshot-20110701:1.16
	sid-snapshot-20110601:1.16
	cgen-snapshot-20110601:1.16
	sid-snapshot-20110501:1.16
	cgen-snapshot-20110501:1.16
	sid-snapshot-20110401:1.16
	cgen-snapshot-20110401:1.16
	sid-snapshot-20110301:1.16
	cgen-snapshot-20110301:1.16
	sid-snapshot-20110201:1.16
	cgen-snapshot-20110201:1.16
	sid-snapshot-20110101:1.16
	cgen-snapshot-20110101:1.16
	sid-snapshot-20101201:1.16
	cgen-snapshot-20101201:1.16
	sid-snapshot-20101101:1.16
	cgen-snapshot-20101101:1.16
	sid-snapshot-20101001:1.16
	cgen-snapshot-20101001:1.16
	sid-snapshot-20100901:1.16
	cgen-snapshot-20100901:1.16
	sid-snapshot-20100801:1.16
	cgen-snapshot-20100801:1.16
	sid-snapshot-20100701:1.16
	cgen-snapshot-20100701:1.16
	sid-snapshot-20100601:1.16
	cgen-snapshot-20100601:1.16
	sid-snapshot-20100501:1.16
	cgen-snapshot-20100501:1.16
	sid-snapshot-20100401:1.16
	cgen-snapshot-20100401:1.16
	sid-snapshot-20100301:1.16
	cgen-snapshot-20100301:1.16
	sid-snapshot-20100201:1.16
	cgen-snapshot-20100201:1.16
	sid-snapshot-20100101:1.16
	cgen-snapshot-20100101:1.16
	sid-snapshot-20091201:1.15
	cgen-snapshot-20091201:1.15
	sid-snapshot-20091101:1.15
	cgen-snapshot-20091101:1.15
	sid-snapshot-20091001:1.14
	cgen-snapshot-20091001:1.14
	arc-sim-20090309:1.10
	sid-snapshot-20090901:1.12
	cgen-snapshot-20090901:1.12
	sid-snapshot-20090801:1.12
	cgen-snapshot-20090801:1.12
	sid-snapshot-20090701:1.11
	cgen-snapshot-20090701:1.11
	dje-cgen-play1-branch:1.11.0.2
	dje-cgen-play1-branchpoint:1.11
	cgen-1_1-branch:1.10.0.6
	cgen-1_1-branchpoint:1.10
	sid-snapshot-20090601:1.10
	cgen-snapshot-20090601:1.10
	sid-snapshot-20090501:1.10
	cgen-snapshot-20090501:1.10
	sid-snapshot-20090401:1.10
	cgen-snapshot-20090401:1.10
	arc-insight_6_8-branch:1.10.0.4
	arc-insight_6_8-branchpoint:1.10
	sid-snapshot-20090301:1.10
	cgen-snapshot-20090301:1.10
	sid-snapshot-20090201:1.10
	cgen-snapshot-20090201:1.10
	sid-snapshot-20090101:1.10
	cgen-snapshot-20090101:1.10
	sid-snapshot-20081201:1.10
	cgen-snapshot-20081201:1.10
	sid-snapshot-20081101:1.10
	cgen-snapshot-20081101:1.10
	sid-snapshot-20081001:1.10
	cgen-snapshot-20081001:1.10
	sid-snapshot-20080901:1.10
	cgen-snapshot-20080901:1.10
	sid-snapshot-20080801:1.10
	cgen-snapshot-20080801:1.10
	sid-snapshot-20080701:1.10
	cgen-snapshot-20080701:1.10
	sid-snapshot-20080601:1.10
	cgen-snapshot-20080601:1.10
	sid-snapshot-20080501:1.10
	cgen-snapshot-20080501:1.10
	sid-snapshot-20080403:1.10
	sid-snapshot-20080401:1.10
	cgen-snapshot-20080401:1.10
	sid-snapshot-20080301:1.10
	cgen-snapshot-20080301:1.10
	sid-snapshot-20080201:1.10
	cgen-snapshot-20080201:1.10
	sid-snapshot-20080101:1.10
	cgen-snapshot-20080101:1.10
	sid-snapshot-20071201:1.10
	cgen-snapshot-20071201:1.10
	sid-snapshot-20071101:1.10
	cgen-snapshot-20071101:1.10
	sid-snapshot-20071001:1.10
	cgen-snapshot-20071001:1.10
	msnyder-fork-checkpoint-branch:1.10.0.2
	msnyder-fork-checkpoint-branchpoint:1.10
	sid-20020905-branchpoint:1.5
	sid-20020905-branch:1.5.0.2
	cagney_regbuf-20020515-branch:1.4.0.2
	cagney_regbuf-20020515-branchpoint:1.4
	cygnus_cvs_20020108_pre:1.4
	cgen-1-1-branch:1.3.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.16
date	2009.12.03.03.03.17;	author devans;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.24.00.01.26;	author devans;	state Exp;
branches;
next	1.14;

1.14
date	2009.09.08.06.51.44;	author devans;	state Exp;
branches;
next	1.13;

1.13
date	2009.09.07.22.17.33;	author devans;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.13.15.56.04;	author devans;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2004.01.29.20.20.48;	author brolley;	state Exp;
branches
	1.10.6.1;
next	1.9;

1.9
date	2003.10.21.16.42.00;	author brolley;	state Exp;
branches;
next	1.8;

1.8
date	2003.07.17.06.19.35;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2003.07.16.05.35.47;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	2003.07.08.16.19.35;	author devans;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.22.18.43.32;	author brolley;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.03.18.30.26;	author brolley;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2000.11.10.16.43.21;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.08.15.25.04;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.11.2.1
date	2009.07.14.16.19.51;	author devans;	state Exp;
branches;
next	;

1.10.6.1
date	2009.06.24.14.57.45;	author devans;	state Exp;
branches;
next	;

1.4.2.1
date	2002.06.15.16.42.47;	author cagney;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.16
log
@tweak comment
@
text
@; Application independent decoder support.
; Copyright (C) 2000, 2004, 2009 Red Hat, Inc.
; This file is part of CGEN.
;
; This file provides utilities for building instruction set decoders.
; At present its rather limited, and is geared towards the simulator
; where the goal is hyper-efficiency [not that there isn't room for much
; improvement, but rather that that's what the current focus is].
;
; The CPU description file provides the first pass's bit mask with the
; `decode-assist' spec.  This gives the decoder a head start on how to
; efficiently decode the instruction set.  The rest of the decoder is
; determined algorithmically.
; ??? Need to say more here.
;
; The main entry point is decode-build-table.
;
; Main procedure call tree:
; decode-build-table
;     /build-slots
;     /build-decode-table-guts
;         /build-decode-table-entry
;             /build-slots
;             /build-decode-table-guts
;
; /build-slots//build-decode-table-guts are recursively called to construct a
; tree of "table-guts" elements, and then the application recurses on the
; result.  For example see sim-decode.scm.
;
; The decoder exits when insns are unambiguously determined, even if there are
; more opcode bits to examine, leaving it to the caller to validate any
; remaining bits.
;
; FIXME: Don't create more than 3 shifts (i.e. no more than 3 groups).

; Decoder data structures and accessors.
; The set of instruction is internally recorded as a tree of two data
; structures: "table-guts" and "table-entry".
; [The choice of "table-guts" is historical, a better name will come to mind
; eventually.]

; Decoded tables data structure, termed "dtable-guts".
; A simple data structure of 4 elements:
; bitnums:  list of bits that have been used thus far to decode the insn
; startbit: bit offset in instruction of value in C local variable `insn'
;           (note that this is independent of LSB0?)
; bitsize:  size of value in C local variable `insn'
; entries:  list of insns that match the decoding thus far,
;           each entry in the list is a `dtable-entry' record

(define (dtable-guts-make bitnums startbit bitsize entries)
  (vector bitnums startbit bitsize entries)
)

; Accessors.
(define (dtable-guts-bitnums tg) (vector-ref tg 0))
(define (dtable-guts-startbit tg) (vector-ref tg 1))
(define (dtable-guts-bitsize tg) (vector-ref tg 2))
(define (dtable-guts-entries tg) (vector-ref tg 3))

; A decoded subtable.
; A simple data structure of 3 elements:
; key: name to distinguish this subtable from others, used for lookup
; table: a table-guts element
; name: name of C variable containing the table
;
; The implementation uses a list so the lookup can use assv.

(define (subdtable-make key table name)
  (list key table name)
)

; Accessors.
(define (subdtable-key st) (car st))
(define (subdtable-table st) (cadr st))
(define (subdtable-name st) (caddr st))

; List of decode subtables.
(define /decode-subtables nil)

(define (subdtable-lookup key) (assv key /decode-subtables))

; Add SUBTABLE-GUTS to the subtables list if not already present.
; Result is the subtable entry already present, or new entry.
; The key is computed so as to make comparisons possible with assv.

(define (subdtable-add subtable-guts name)
  (let* ((key (string->symbol
	       (string-append
		(numbers->string (dtable-guts-bitnums subtable-guts) " ")
		" " (number->string (dtable-guts-bitsize subtable-guts))
		(string-map
		 (lambda (elm)
		   (case (dtable-entry-type elm)
		     ((insn)
		      (stringsym-append " " (obj:name (dtable-entry-value elm))))
		     ((table)
		      (stringsym-append " " (subdtable-name (dtable-entry-value elm))))
		     ((expr)
		      (stringsym-append " " (exprtable-name (dtable-entry-value elm))))
		     (else (error "bad dtable entry type:"
				  (dtable-entry-type elm)))))
		 (dtable-guts-entries subtable-guts)))))
	 (entry (subdtable-lookup key)))
    (if (not entry)
	(begin
	  (set! /decode-subtables (cons (subdtable-make key subtable-guts name)
					/decode-subtables))
	  (car /decode-subtables))
	entry))
)

; An instruction and predicate for final matching.

(define (exprtable-entry-make insn expr)
  (vector insn expr (rtl-find-ifields expr))
)

; Accessors.

(define (exprtable-entry-insn entry) (vector-ref entry 0))
(define (exprtable-entry-expr entry) (vector-ref entry 1))
(define (exprtable-entry-iflds entry) (vector-ref entry 2))

; Return a pseudo-cost of processing exprentry X.

(define (exprentry-cost x)
  (let ((expr (exprtable-entry-expr x)))
    (case (rtx-name expr)
      ((member) (length (rtx-member-set expr)))
      (else 4)))
)

; Sort an exprtable, optimum choices first.
; Basically an optimum choice is a cheaper choice.

(define (exprtable-sort expr-list)
  (sort expr-list
	(lambda (a b)
	  (let ((costa (exprentry-cost a))
		(costb (exprentry-cost b)))
	    (< costa costb))))
)

; Return the name of the expr table for INSN-EXPRS,
; which is a list of exprtable-entry elements.

(define (/gen-exprtable-name insn-exprs)
  (string-map (lambda (x)
		(string-append (obj:str-name (exprtable-entry-insn x))
			       "-"
			       (rtx-strdump (exprtable-entry-expr x))))
	      insn-exprs)
)

; A set of instructions that need expressions to distinguish.
; Typically the expressions are ifield-assertion specs.
; INSN-EXPRS is a sorted list of exprtable-entry elements.
; The list is considered sorted in the sense that the first insn to satisfy
; its predicate is chosen.

(define (exprtable-make name insn-exprs)
  (vector name insn-exprs)
)

; Accessors.

(define (exprtable-name etable) (vector-ref etable 0))
(define (exprtable-insns etable) (vector-ref etable 1))

; Decoded table entry data structure.
; A simple data structure of 3 elements:
; index: index in the parent table
; entry type indicator: 'insn or 'table or 'expr
; value: the insn or subtable or exprtable

(define (dtable-entry-make index type value)
  (assert value)
  (vector index type value)
)

; Accessors.
(define (dtable-entry-index te) (vector-ref te 0))
(define (dtable-entry-type te) (vector-ref te 1))
(define (dtable-entry-value te) (vector-ref te 2))

; Return #t if BITNUM is a good bit to use for decoding.
; MASKS is a list of opcode masks.
; MASK-LENS is a list of lengths of each value in MASKS.
; BITNUM is the number of the bit to test.  It's value depends on LSB0?.
; It can be no larger than the smallest element in MASKS.
; E.g. If MASK-LENS consists of 16 and 32 and LSB0? is #f, BITNUM must
; be from 0 to 15.
; FIXME: This isn't quite right.  What if LSB0? = #t?  Need decode-bitsize.
; LSB0? is non-#f if bit number 0 is the least significant bit.
;
; FIXME: This is just a first cut, but the governing intent is to not require
; targets to specify decode tables, hints, or algorithms.
; Certainly as it becomes useful they can supply such information.
; The point is to avoid having to as much as possible.
;
; FIXME: Bit numbers shouldn't be considered in isolation.
; It would be better to compute use counts of all of them and then see
; if there's a cluster of high use counts.

(define (/usable-decode-bit? masks mask-lens bitnum lsb0?)
  (let* ((has-bit (map (lambda (msk len)
			 (bit-set? msk (if lsb0? bitnum (- len bitnum 1))))
		       masks mask-lens)))
    (or (all-true? has-bit)
	; If half or more insns use the bit, it's a good one.
	; FIXME: An empirical guess at best.
	(>= (count-true has-bit) (quotient (length has-bit) 2))
	))
)

; Compute population counts for each bit.  Return it as a vector indexed by bit
; number.  Rather than computing raw popularity, attempt to compute
; "disinguishing value" or inverse-entropy for each bit.  The idea is that the
; larger the number for any particular bit slot, the more instructions it can
; be used to distinguish.  Raw mask popularity is not enough -- popular masks
; may include useless "reserved" fields whose values don't change, and thus are
; useless in distinguishing.
;
; NOTE: mask-lens are not necessarily all the same value.
; E.g. for the m32r it can consist of both 16 and 32.
; But all masks must exist in the window specified by STARTBIT,DECODE-BITSIZE,
; and all bits in the result must live in that window.
; If no distinguishing bit fits in the window, return an empty vector.

(define (/distinguishing-bit-population masks mask-lens values lsb0?)
  (let* ((max-length (apply max mask-lens))
	 (0-population (make-vector max-length 0))
	 (1-population (make-vector max-length 0))
	 (num-insns (length masks)))
    ; Compute the 1- and 0-population vectors
    (for-each (lambda (mask len value)
		(logit 5 " population count mask=" (number->hex mask) " len=" len "\n")
		(for-each (lambda (bitno)
			    (let ((lsb-bitno (if lsb0? bitno (- len bitno 1))))
			      ; ignore this bit if it's not set in the mask
			      (if (bit-set? mask lsb-bitno)
				(let ((chosen-pop-vector (if (bit-set? value lsb-bitno)
							     1-population 0-population)))
				  (vector-set! chosen-pop-vector bitno
					       (+ 1 (vector-ref chosen-pop-vector bitno)))))))
			  (/range len)))
	      masks mask-lens values)
    ; Compute an aggregate "distinguishing value" for each bit.
    (list->vector
     (map (lambda (p0 p1)
	    (logit 4 p0 "/" p1 " ")
	    ; The most useful bits for decoding are those with counts in both
	    ; p0 and p1. These are the bits which distinguish one insn from
	    ; another. Assign these bits a high value (greater than num-insns).
	    ;
	    ; The next most useful bits are those with counts in either p0
	    ; or p1.  These bits represent specializations of other insns.
	    ; Assign these bits a value between 0 and (num-insns - 1). Note that
	    ; p0 + p1 is guaranteed to be <= num-insns. The value 0 is assigned
	    ; to bits for which p0 or p1 is equal to num_insns. These are bits
	    ; which are always 1 or always 0 in the ISA and are useless for
	    ; decoding purposes.
	    ;
	    ; Bits with no count in either p0 or p1 are useless for decoding
	    ; and should never be considered. Assigning these bits a value of
	    ; 0 ensures this.
	    (cond
	     ((= (+ p0 p1) 0) 0)
	     ((= (* p0 p1) 0) (- num-insns (+ p0 p1)))
	     (else (+ num-insns (sqrt (* p0 p1))))))
	  (vector->list 0-population) (vector->list 1-population))))
)

; Return a list (0 ... LIMIT-1).

(define (/range limit)
  (let loop ((i 0)
	     (indices (list)))
    (if (= i limit)
	(reverse! indices)
	(loop (+ i 1) (cons i indices))))
)

; Return a list (BASE ... BASE+SIZE-1).

(define (/range2 base size)
  (let loop ((i base)
	     (indices (list)))
    (if (= i (+ base size))
	(reverse! indices)
	(loop (+ i 1) (cons i indices))))
)

; Return a copy of VECTOR, with all entries with given INDICES set
; to VALUE.

(define (/vector-copy-set-all vector indices value)
  (let ((new-vector (make-vector (vector-length vector))))
    (for-each (lambda (index)
		(vector-set! new-vector index (if (memq index indices)
						  value
						  (vector-ref vector index))))
	      (/range (vector-length vector)))
    new-vector)
)

; Return a list of indices whose counts in the given vector exceed the given
; threshold.
; Sort them in decreasing order of popularity.

(define (/population-above-threshold population threshold)
  (let* ((unsorted
	  (find (lambda (index) (if (vector-ref population index)
				    (>= (vector-ref population index) threshold)
				    #f))
		(/range (vector-length population))))
	 (sorted
	  (sort unsorted (lambda (i1 i2) (> (vector-ref population i1)
					    (vector-ref population i2))))))
    sorted)
)

; Return the top few most popular indices in the population vector,
; ignoring any that are already used (marked by #f).  Don't exceed
; `size' unless the clustering is just too good to pass up.

(define (/population-top-few population size)
  (let loop ((old-picks (list))
	     (remaining-population population)
	     (count-threshold (apply max (map (lambda (value) (or value 0))
					      (vector->list population)))))
      (let* ((new-picks (/population-above-threshold remaining-population count-threshold)))
	(logit 4 "/population-top-few"
	       " desired=" size
	       " picks=(" old-picks ") pop=(" remaining-population ")"
	       " threshold=" count-threshold " new-picks=(" new-picks ")\n")
	(cond
	 ; No point picking bits with population count of zero.  This leads to
	 ; the generation of layers of subtables which resolve nothing.  Generating
	 ; these tables can slow the build by several orders of magnitude.
	 ((= 0 count-threshold)
	  (logit 2 "/population-top-few: count-threshold is zero!\n")
	  old-picks)
	 ; No new matches?
	 ((null? new-picks)
	  (if (null? old-picks)
	      (logit 2 "/population-top-few: No bits left to pick from!\n"))
	  old-picks)
	 ; Way too many matches?
	 ((> (+ (length new-picks) (length old-picks)) (+ size 3))
	  (list-take (+ 3 size) (append old-picks new-picks))) ; prefer old-picks
	 ; About right number of matches?
	 ((> (+ (length new-picks) (length old-picks)) (- size 1))
	  (append old-picks new-picks))
	 ; Not enough?  Lower the threshold a bit and try to add some more.
	 (else
	  (loop (append old-picks new-picks)
		(/vector-copy-set-all remaining-population new-picks #f)
		; Notice magic clustering decay parameter
		;  vvvv
		(* 0.75 count-threshold))))))
)

; Given list of insns, return list of bit numbers of constant bits in opcode
; that they all share (or mostly share), up to MAX elements.
; ALREADY-USED is a list of bitnums we can't use.
; STARTBIT is the bit offset of the instruction value that C variable `insn'
; holds (note that this is independent of LSB0?).
; DECODE-BITSIZE is the number of bits of the insn that `insn' holds.
; LSB0? is non-#f if bit number 0 is the least significant bit.
;
; Nil is returned if there are none, meaning that there is an ambiguity in
; the specification up to the current word as defined by startbit,
; decode-bitsize, and more bytes need to be fetched.
;
; We assume INSN-LIST matches all opcode bits before STARTBIT (if any).
; FIXME: Revisit, as a more optimal decoder is sometimes achieved by doing
; a cluster of opcode bits that appear later in the insn, and then coming
; back to earlier ones.
;
; All insns are assumed to start at the same address so we handle insns of
; varying lengths - we only analyze the common bits in all of them.
;
; Note that if we get called again to compute further opcode bits, we
; start looking at STARTBIT again (rather than keeping track of how far in
; the insn word we've progressed).  We could do this as an optimization, but
; we also have to handle the case where the initial set of decode bits misses
; some and thus we have to go back and look at them.  It may also turn out
; that an opcode bit is skipped over because it doesn't contribute much
; information to the decoding process (see /usable-decode-bit?).  As the
; possible insn list gets wittled down, the bit will become significant.  Thus
; the optimization is left for later.
; Also, see preceding FIXME: We can't proceed past startbit + decode-bitsize
; until we've processed all bits up to startbit + decode-bitsize.

(define (decode-get-best-bits insn-list already-used startbit max decode-bitsize lsb0?)
  (let* ((raw-population (/distinguishing-bit-population (map insn-base-mask insn-list)
							 (map insn-base-mask-length insn-list)
							 (map insn-value insn-list)
							 lsb0?))
	 ;; (undecoded (if lsb0?
	 ;; 		(/range2 startbit (+ startbit decode-bitsize))
	 ;;		(/range2 (- startbit decode-bitsize) startbit)))
	 (used+undecoded already-used) ; (append already-used undecoded))
	 (filtered-population (/vector-copy-set-all raw-population used+undecoded #f))
	 (favorite-indices (/population-top-few filtered-population max))
	 (sorted-indices (sort favorite-indices (lambda (a b) 
						  (if lsb0? (> a b) (< a b))))))
    (logit 3
	   "Best decode bits (prev=" already-used " start=" startbit " decode=" decode-bitsize ")"
	   "=>"
	   "(" sorted-indices ")\n")
    sorted-indices)
)

(define (OLDdecode-get-best-bits insn-list already-used startbit max decode-bitsize lsb0?)
  (let ((masks (map insn-base-mask insn-list))
	; ??? We assume mask lengths are repeatedly used for insns longer
	; than the base insn size.
	(mask-lens (map insn-base-mask-length insn-list))
	(endbit (if lsb0?
		    -1 ; FIXME: for now (gets sparc port going)
		    (+ startbit decode-bitsize)))
	(incr (if lsb0? -1 1)))
    (let loop ((result nil)
	       (bitnum (if lsb0?
			   (+ startbit (- decode-bitsize 1))
			   startbit)))
      (if (or (= (length result) max) (= bitnum endbit))
	  (reverse! result)
	  (if (and (not (memq bitnum already-used))
		   (/usable-decode-bit? masks mask-lens bitnum lsb0?))
	      (loop (cons bitnum result) (+ bitnum incr))
	      (loop result (+ bitnum incr))))
      ))
)

;; Subroutine of /opcode-slots to simplify it.
;; Compute either the opcode value or mask for the bits in BITNUMS.
;; DEFAULT is 0 when computing the opcode value, 1 for the mask value.
;; DECODE-LEN is (length BITNUMS).

(define (/get-subopcode-value value insn-len decode-len bitnums default lsb0?)
  ;;(display (list val insn-len decode-len bl)) (newline)
  ;; Oh My God.  This isn't tail recursive.
  (letrec ((compute
	    ;; BNS is the remaining elements of BITNUMS to examine.
	    ;; THIS-BN ranges from (length bitnums), ..., 3, 2, 1.
	    (lambda (bns this-bn)
	      (if (null? bns)
		  0
		  (let ((bn (car bns)))
		    (+ (if (or (and (>= bn insn-len) (= default 1))
			       (and (< bn insn-len)
				    (bit-set? value
					      (if lsb0?
						  bn
						  (- insn-len bn 1)))))
			   (integer-expt 2 (- this-bn 1))
			   0)
		       (compute (cdr bns) (- this-bn 1))))))))
    (compute bitnums decode-len))
)

; Return list of decode table entry numbers for INSN's opcode bits BITNUMS.
; This is the indices into the decode table that match the instruction.
; LSB0? is non-#f if bit number 0 is the least significant bit.
;
; Example: If BITNUMS is (0 1 2 3 4 5), and the constant (i.e. opcode) part of
; the those bits of INSN is #b1100xx (where 'x' indicates a non-constant
; part), then the result is (#b110000 #b110001 #b110010 #b110011).

(define (/opcode-slots insn bitnums lsb0?)
  (let ((opcode (insn-value insn)) ;; FIXME: unused, overridden below
	(insn-len (insn-base-mask-length insn))
	(decode-len (length bitnums)))
    (let* ((opcode (/get-subopcode-value (insn-value insn) insn-len decode-len bitnums 0 lsb0?))
	   (opcode-mask (/get-subopcode-value (insn-base-mask insn) insn-len decode-len bitnums 1 lsb0?))
	   (indices (missing-bit-indices opcode-mask (- (integer-expt 2 decode-len) 1))))
      (logit 3 "insn =" (obj:name insn)
	     " insn-value=" (number->hex (insn-value insn))
	     " insn-base-mask=" (number->hex (insn-base-mask insn))
	     " insn-len=" insn-len
	     " decode-len=" decode-len
	     " opcode=" (number->hex opcode)
	     " opcode-mask=" (number->hex opcode-mask)
	     " indices=" indices "\n")
      (map (lambda (index) (+ opcode index)) indices)))
)

; Subroutine of /build-slots.
; Fill slot in INSN-VEC that INSN goes into.
; BITNUMS is the list of opcode bits.
; LSB0? is non-#f if bit number 0 is the least significant bit.
;
; Example: If BITNUMS is (0 1 2 3 4 5) and the constant (i.e. opcode) part of
; the first six bits of INSN is #b1100xx (where 'x' indicates a non-constant
; part), then elements 48 49 50 51 of INSN-VEC are cons'd with INSN.
; Each "slot" is a list of matching instructions.

(define (/fill-slot! insn-vec insn bitnums lsb0?)
  (logit 3 "Filling slots for " (obj:str-name insn)
	 ", bitnums " bitnums "\n")
  (let ((slot-nums (/opcode-slots insn bitnums lsb0?)))
    ;(display (list "Filling slot(s)" slot-nums "...")) (newline)
    (for-each (lambda (slot-num)
		(vector-set! insn-vec slot-num
			     (cons insn (vector-ref insn-vec slot-num))))
	      slot-nums)
    *UNSPECIFIED*
    )
)

; Given a list of constant bitnums (ones that are predominantly, though perhaps
; not always, in the opcode), record each insn in INSN-LIST in the proper slot.
; LSB0? is non-#f if bit number 0 is the least significant bit.
; The result is a vector of insn lists.  Each slot is a list of insns
; that go in that slot.

(define (/build-slots insn-list bitnums lsb0?)
  (let ((result (make-vector (integer-expt 2 (length bitnums)) nil)))
    ; Loop over each element, filling RESULT.
    (for-each (lambda (insn)
		(/fill-slot! result insn bitnums lsb0?))
	      insn-list)
    result)
)

; Compute the name of a decode table, prefixed with PREFIX.
; INDEX-LIST is a list of pairs: list of bitnums, table entry number,
; in reverse order of traversal (since they're built with cons).
; INDEX-LIST may be empty.

(define (/gen-decode-table-name prefix index-list)
  (set! index-list (reverse index-list))
  (string-append
   prefix
   "table"
   (string-map (lambda (elm) (string-append "_" (number->string elm)))
		; CDR of each element is the table index.
	       (map cdr index-list)))
)

; Generate one decode table entry for INSN-VEC at INDEX.
; INSN-VEC is a vector of slots where each slot is a list of instructions that
; map to that slot (opcode value).  If a slot is nil, no insn has that opcode
; value so the decoder marks it as being invalid.
; STARTBIT is the bit offset of the instruction value that C variable `insn'
; holds (note that this is independent of LSB0?).
; DECODE-BITSIZE is the number of bits of the insn that `insn' holds.
; INDEX-LIST is a list of pairs: list of bitnums, table entry number.
; LSB0? is non-#f if bit number 0 is the least significant bit.
; INVALID-INSN is an <insn> object to use for invalid insns.
; The result is a dtable-entry element (or "slot").

; ??? For debugging.
(define /build-decode-table-entry-args #f)

(define (/build-decode-table-entry insn-vec startbit decode-bitsize index index-list lsb0? invalid-insn)
  (let ((slot (vector-ref insn-vec index)))
    (logit 2 "Processing decode entry "
	   (number->string index)
	   " in "
	   (/gen-decode-table-name "decode_" index-list)
	   ", "
	   (cond ((null? slot) "invalid")
		 ((= 1 (length slot)) (insn-syntax (car slot)))
		 (else "subtable"))
	   " ...\n")

    (cond
     ; If no insns map to this value, mark it as invalid.
     ((null? slot) (dtable-entry-make index 'insn invalid-insn))

     ; If only one insn maps to this value, that's it for this insn.
     ((= 1 (length slot))
      ; FIXME: Incomplete: need to check further opcode bits.
      (dtable-entry-make index 'insn (car slot)))

     ; Otherwise more than one insn maps to this value and we need to look at
     ; further opcode bits.
     (else
      (logit 3 "Building subtable at index " (number->string index)
	     ", decode-bitsize = " (number->string decode-bitsize)
	     ", indices used thus far:"
	     (string-map (lambda (i) (string-append " " (number->string i)))
			 (apply append (map car index-list)))
	     "\n")

      (let ((bitnums (decode-get-best-bits slot
					   (apply append (map car index-list))
					   startbit 4
					   decode-bitsize lsb0?)))

	; If bitnums is nil, either there is an ambiguity or we need to read
	; more of the instruction in order to distinguish insns in SLOT.
	(if (and (null? bitnums)
		 (< startbit (apply min (map insn-length slot))))
	    (begin
	      ; We might be able to resolve the ambiguity by reading more bits.
	      ; We know from the < test that there are, indeed, more bits to
	      ; be read.
	      ; FIXME: It's technically possible that the next
	      ; startbit+decode-bitsize chunk has no usable bits and we have to
	      ; iterate, but rather unlikely.
	      ; The calculation of the new startbit, decode-bitsize will
	      ; undoubtedly need refinement.
	      (set! startbit (+ startbit decode-bitsize))
	      (set! decode-bitsize
		    (min decode-bitsize
			 (- (apply min (map insn-length slot))
			    startbit)))
	      (set! bitnums (decode-get-best-bits slot
						  ;nil ; FIXME: what to put here?
						  (apply append (map car index-list))
						  startbit 4
						  decode-bitsize lsb0?))))

	; If bitnums is still nil there is an ambiguity.
	(if (null? bitnums)
	    (begin
	      ; Try filtering out insns which are more general cases of
	      ; other insns in the slot.  The filtered insns will appear
	      ; in other slots as appropriate.
	      (set! slot (filter-non-specialized-ambiguous-insns slot))

	      (if (= 1 (length slot))
		  ; Only 1 insn left in the slot, so take it.
		  (dtable-entry-make index 'insn (car slot))
		  ; There is still more than one insn in 'slot',
		  ; so there is still an ambiguity.
		  (begin
		    ; If all insns are marked as DECODE-SPLIT, don't warn.
		    (if (not (all-true? (map (lambda (insn)
					       (obj-has-attr? insn 'DECODE-SPLIT))
					     slot)))
			(message "WARNING: Decoder ambiguity detected: "
				 (string-drop1 ; drop leading comma
				  (string-map (lambda (insn)
						(string-append ", " (obj:str-name insn)))
					      slot))
				 "\n"))
			; Things aren't entirely hopeless.  We've warned about
		        ; the ambiguity.  Now, if there are any identical insns,
		        ; filter them out.  If only one remains, then use it.
		    (set! slot (filter-identical-ambiguous-insns slot))
		    (if (= 1 (length slot))
			; Only 1 insn left in the slot, so take it.
			(dtable-entry-make index 'insn (car slot))
		        ; Otherwise, see if any ifield-assertion
			; specs are present.
			; FIXME: For now we assume that if they all have an
			; ifield-assertion spec, then there is no ambiguity (it's left
			; to the programmer to get it right).  This can be made more
			; clever later.
			; FIXME: May need to back up startbit if we've tried to read
			; more of the instruction.  We currently require that
			; all bits get used before advancing startbit, so this
			; shouldn't be necessary.  Verify.
			(let ((assertions (map insn-ifield-assertion slot)))
			  (if (not (all-true? assertions))
			      (begin
				; Save arguments for debugging purposes.
				(set! /build-decode-table-entry-args
				      (list insn-vec startbit decode-bitsize index index-list lsb0? invalid-insn))
				(error "Unable to resolve ambiguity (maybe need some ifield-assertion specs?)")))
				; FIXME: Punt on even simple cleverness for now.
			  (let ((exprtable-entries
				 (exprtable-sort (map exprtable-entry-make
						      slot
						      assertions))))
			    (dtable-entry-make index 'expr
					       (exprtable-make
						(/gen-exprtable-name exprtable-entries)
						exprtable-entries))))))))

	    ; There is no ambiguity so generate the subtable.
	    ; Need to build `subtable' separately because we
	    ; may be appending to /decode-subtables recursively.
	    (let* ((insn-vec (/build-slots slot bitnums lsb0?))
		   (subtable
		    (/build-decode-table-guts insn-vec bitnums startbit
					      decode-bitsize index-list lsb0?
					      invalid-insn)))
	      (dtable-entry-make index 'table
				 (subdtable-add subtable
						(/gen-decode-table-name "" index-list)))))))
     )
    )
)

; Given a vector of insn slots INSN-VEC, generate the guts of the decode table,
; recorded as a "dtable-guts" data structure.
;
; BITNUMS is the list of bit numbers used to build the slot table.
; I.e., (= (vector-length insn-vec) (ash 1 (length bitnums))).
; STARTBIT is the bit offset of the instruction value that C variable `insn'
; holds (note that this is independent of LSB0?).
; For example, it is initially zero.  If DECODE-BITSIZE is 16 and after
; scanning the first fetched piece of the instruction, more decoding is
; needed, another piece will be fetched and STARTBIT will then be 16.
; DECODE-BITSIZE is the number of bits of the insn that `insn' holds.
; INDEX-LIST is a list of pairs: list of bitnums, table entry number.
; Decode tables consist of entries of two types: actual insns and
; pointers to other tables.
; LSB0? is non-#f if bit number 0 is the least significant bit.
; INVALID-INSN is an <insn> object representing invalid insns.
;
; BITNUMS is recorded with the guts so that tables whose contents are
; identical but are accessed by different bitnums are treated as separate in
; /decode-subtables.  Not sure this will ever happen, but play it safe.

(define (/build-decode-table-guts insn-vec bitnums startbit decode-bitsize index-list lsb0? invalid-insn)
  (logit 2 "Processing decoder for bits"
	 (numbers->string bitnums " ")
	 ", startbit " startbit
	 ", decode-bitsize " decode-bitsize
	 ", index-list " index-list
	 " ...\n")
  (assert (= (vector-length insn-vec) (ash 1 (length bitnums))))

  (dtable-guts-make
   bitnums startbit decode-bitsize
   (map (lambda (index)
	  (/build-decode-table-entry insn-vec startbit decode-bitsize index
				     (cons (cons bitnums index)
					   index-list)
				     lsb0? invalid-insn))
	(iota (vector-length insn-vec))))
)

; Entry point.
; Return a table that efficiently decodes INSN-LIST.
; The table is a "dtable-guts" data structure, see dtable-guts-make.
;
; BITNUMS is the set of bits to initially key off of.
; DECODE-BITSIZE is the number of bits of the instruction that `insn' holds.
; LSB0? is non-#f if bit number 0 is the least significant bit.
; INVALID-INSN is an <insn> object representing the `invalid' insn (for
; instructions values that don't decode to any entry in INSN-LIST).

(define (decode-build-table insn-list bitnums decode-bitsize lsb0? invalid-insn)
  ; Initialize the list of subtables computed.
  (set! /decode-subtables nil)

  ; ??? Another way to handle simple forms of ifield-assertions (like those
  ; created by insn specialization) is to record a copy of the insn for each
  ; possible value of the ifield and modify its ifield list with the ifield's
  ; value.  This would then let the decoder table builder handle it normally.
  ; I wouldn't create N insns, but would rather create an intermediary record
  ; that recorded the necessary bits (insn, ifield-list, remaining
  ; ifield-assertions).

  (let ((insn-vec (/build-slots insn-list bitnums lsb0?)))
    (let ((table-guts (/build-decode-table-guts insn-vec bitnums
						0 decode-bitsize
						nil lsb0?
						invalid-insn)))
      table-guts))
)
@


1.15
log
@	* decode.scm: Tweak various comments.
	(/opcode-slots): Add FIXME.
	(/build-decode-table-guts): Add assert.
	* utils-sim.scm (/gen-set-itype-and-extract): New function.
	(/gen-bracketed-set-itype-and-extract): New function.
	(/gen-decode-default-entry): Rewrite.
	(/table-guts-to-mask, /all-opcode-bits-used?): New functions.
	(/gen-decode-insn-entry): New arg table-guts-thus-far, all callers
	updated.  Don't unnecessarily emit check for whether all opcode bits
	have been examined.
	(/gen-decode-expr-set-itype): Delete.
	(/gen-decode-expr-entry): Update.
	(/gen-decode-table-entry): New arg table-guts-thus-far, all callers
	updated.  Keep track of decoder tables used thus far.
	(/gen-decoder-switch): Ditto.
	* utils.scm (word-bit-value): New function.
@
text
@d30 4
a34 2
; FIXME: Exits when insns are unambiguously determined, even if there are more
; opcode bits to examine.
@


1.14
log
@	* types.scm (<struct>): Delete.

	* pmacros.scm (/pmacro-env-make): New argument `loc', all callers
	updated.
	(/pmacro-loc-error): New function.

	* mach.scm (/isa-parse-decode-assist): New function.
	(/isa-parse): Call it.

	* decode.scm (/get-subopcode-value): New function.
	(/opcode-slots): Call it.
	(/fill-slot!): Add logging message.
@
text
@d40 1
a40 1
; Decoded tables data structure, termed "table guts".
d44 2
a45 2
; bitsize:  size of value in C local variable `insn', the number
;           of bits of the instruction read thus far
d473 1
a473 1
  (let ((opcode (insn-value insn))
d691 2
a692 5
; Given vector of insn slots, generate the guts of the decode table, recorded
; as a list of 3 elements: bitnums, decode-bitsize, and list of entries.
; Bitnums is recorded with the guts so that tables whose contents are
; identical but are accessed by different bitnums are treated as separate in
; /decode-subtables.  Not sure this will ever happen, but play it safe.
d695 1
d707 4
d719 1
d733 2
@


1.13
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d437 27
d473 5
a477 19
  (letrec ((opcode (insn-value insn))
	   (insn-len (insn-base-mask-length insn))
	   (decode-len (length bitnums))
	   (compute (lambda (val insn-len decode-len bl default)
		      ;(display (list val insn-len decode-len bl)) (newline)
		      ; Oh My God.  This isn't tail recursive.
		      (if (null? bl)
			  0
			  (+ (if (or (and (>= (car bl) insn-len) (= default 1))
				     (and (< (car bl) insn-len)
					  (bit-set? val
						    (if lsb0?
							(car bl)
							(- insn-len (car bl) 1)))))
				 (integer-expt 2 (- (length bl) 1))
				 0)
			     (compute val insn-len decode-len (cdr bl) default))))))
    (let* ((opcode (compute (insn-value insn) insn-len decode-len bitnums 0))
	   (opcode-mask (compute (insn-base-mask insn) insn-len decode-len bitnums 1))
d501 2
a502 1
  ;(display (string-append "fill-slot!: " (obj:str-name insn) " ")) (display bitnums) (newline)
@


1.12
log
@	* decode.scm: Comment and formatting tweaks.
	(-build-decode-table-guts): Add more data to logging message.
@
text
@d20 5
a24 5
;     -build-slots
;     -build-decode-table-guts
;         -build-decode-table-entry
;             -build-slots
;             -build-decode-table-guts
d26 1
a26 1
; -build-slots/-build-decode-table-guts are recursively called to construct a
d77 1
a77 1
(define -decode-subtables nil)
d79 1
a79 1
(define (subdtable-lookup key) (assv key -decode-subtables))
d105 3
a107 3
	  (set! -decode-subtables (cons (subdtable-make key subtable-guts name)
					-decode-subtables))
	  (car -decode-subtables))
d146 1
a146 1
(define (-gen-exprtable-name insn-exprs)
d204 1
a204 1
(define (-usable-decode-bit? masks mask-lens bitnum lsb0?)
d229 1
a229 1
(define (-distinguishing-bit-population masks mask-lens values lsb0?)
d245 1
a245 1
			  (-range len)))
d275 1
a275 1
(define (-range limit)
d285 1
a285 1
(define (-range2 base size)
d296 1
a296 1
(define (-vector-copy-set-all vector indices value)
d302 1
a302 1
	      (-range (vector-length vector)))
d310 1
a310 1
(define (-population-above-threshold population threshold)
d315 1
a315 1
		(-range (vector-length population))))
d326 1
a326 1
(define (-population-top-few population size)
d331 2
a332 2
      (let* ((new-picks (-population-above-threshold remaining-population count-threshold)))
	(logit 4 "-population-top-few"
d341 1
a341 1
	  (logit 2 "-population-top-few: count-threshold is zero!\n")
d346 1
a346 1
	      (logit 2 "-population-top-few: No bits left to pick from!\n"))
d357 1
a357 1
		(-vector-copy-set-all remaining-population new-picks #f)
d389 1
a389 1
; information to the decoding process (see -usable-decode-bit?).  As the
d396 1
a396 1
  (let* ((raw-population (-distinguishing-bit-population (map insn-base-mask insn-list)
d401 2
a402 2
	 ;; 		(-range2 startbit (+ startbit decode-bitsize))
	 ;;		(-range2 (- startbit decode-bitsize) startbit)))
d404 2
a405 2
	 (filtered-population (-vector-copy-set-all raw-population used+undecoded #f))
	 (favorite-indices (-population-top-few filtered-population max))
d431 1
a431 1
		   (-usable-decode-bit? masks mask-lens bitnum lsb0?))
d445 1
a445 1
(define (-opcode-slots insn bitnums lsb0?)
d477 1
a477 1
; Subroutine of -build-slots.
d487 1
a487 1
(define (-fill-slot! insn-vec insn bitnums lsb0?)
d489 1
a489 1
  (let ((slot-nums (-opcode-slots insn bitnums lsb0?)))
d505 1
a505 1
(define (-build-slots insn-list bitnums lsb0?)
d509 1
a509 1
		(-fill-slot! result insn bitnums lsb0?))
d519 1
a519 1
(define (-gen-decode-table-name prefix index-list)
d542 1
a542 1
(define -build-decode-table-entry-args #f)
d544 1
a544 1
(define (-build-decode-table-entry insn-vec startbit decode-bitsize index index-list lsb0? invalid-insn)
d549 1
a549 1
	   (-gen-decode-table-name "decode_" index-list)
d649 1
a649 1
				(set! -build-decode-table-entry-args
d659 1
a659 1
						(-gen-exprtable-name exprtable-entries)
d664 2
a665 2
	    ; may be appending to -decode-subtables recursively.
	    (let* ((insn-vec (-build-slots slot bitnums lsb0?))
d667 1
a667 1
		    (-build-decode-table-guts insn-vec bitnums startbit
d672 1
a672 1
						(-gen-decode-table-name "" index-list)))))))
d681 1
a681 1
; -decode-subtables.  Not sure this will ever happen, but play it safe.
d696 1
a696 1
(define (-build-decode-table-guts insn-vec bitnums startbit decode-bitsize index-list lsb0? invalid-insn)
d707 1
a707 1
	  (-build-decode-table-entry insn-vec startbit decode-bitsize index
d724 1
a724 1
  (set! -decode-subtables nil)
d734 2
a735 2
  (let ((insn-vec (-build-slots insn-list bitnums lsb0?)))
    (let ((table-guts (-build-decode-table-guts insn-vec bitnums
@


1.11
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d222 6
d243 2
a244 2
				  (vector-set! chosen-pop-vector bitno 
					     (+ 1 (vector-ref chosen-pop-vector bitno)))))))
d273 1
a273 1
; Return a list (0 ... limit-1)
d278 3
a280 1
    (if (= i limit) (reverse indices) (loop (+ i 1) (cons i indices))))
d283 1
a283 1
; Return a list (base ... base+size-1)
d288 3
a290 1
    (if (= i (+ base size)) (reverse indices) (loop (+ i 1) (cons i indices))))
d293 2
a294 2
; Return a copy of given vector, with all entries with given indices set
; to `value'
d308 1
a308 1
; Sort them in decreasing order of populatority.
d312 1
a312 1
	  (find (lambda (index) (if (vector-ref population index) 
d329 1
a329 1
	     (count-threshold (apply max (map (lambda (value) (if value value 0))
d336 1
a336 1
	(cond 
d372 2
a373 1
; the specification up to the current word.
d375 1
a375 1
; We assume INSN-LIST matches all opcode bits before STARTBIT.
d391 3
a393 1
; the optimization is left for later.  Also, see preceding FIXME.
d400 3
a402 3
	 ; (undecoded (if lsb0?
	; 		(-range2 startbit (+ startbit decode-bitsize))
		;	(-range2 (- startbit decode-bitsize) startbit)))
d408 1
a408 1
    (logit 3 
d588 5
a593 2
	      ; FIXME: The calculation of the new decode-bitsize will
	      ; undoubtedly need refinement.
d642 3
a644 1
			; more of the instruction.
d699 3
@


1.11.2.1
log
@Bring over various patches from the trunk.
@
text
@a221 6
;
; NOTE: mask-lens are not necessarily all the same value.
; E.g. for the m32r it can consist of both 16 and 32.
; But all masks must exist in the window specified by STARTBIT,DECODE-BITSIZE,
; and all bits in the result must live in that window.
; If no distinguishing bit fits in the window, return an empty vector.
d237 2
a238 2
				  (vector-set! chosen-pop-vector bitno
					       (+ 1 (vector-ref chosen-pop-vector bitno)))))))
d267 1
a267 1
; Return a list (0 ... LIMIT-1).
d272 1
a272 3
    (if (= i limit)
	(reverse! indices)
	(loop (+ i 1) (cons i indices))))
d275 1
a275 1
; Return a list (BASE ... BASE+SIZE-1).
d280 1
a280 3
    (if (= i (+ base size))
	(reverse! indices)
	(loop (+ i 1) (cons i indices))))
d283 2
a284 2
; Return a copy of VECTOR, with all entries with given INDICES set
; to VALUE.
d298 1
a298 1
; Sort them in decreasing order of popularity.
d302 1
a302 1
	  (find (lambda (index) (if (vector-ref population index)
d319 1
a319 1
	     (count-threshold (apply max (map (lambda (value) (or value 0))
d326 1
a326 1
	(cond
d362 1
a362 2
; the specification up to the current word as defined by startbit,
; decode-bitsize, and more bytes need to be fetched.
d364 1
a364 1
; We assume INSN-LIST matches all opcode bits before STARTBIT (if any).
d380 1
a380 3
; the optimization is left for later.
; Also, see preceding FIXME: We can't proceed past startbit + decode-bitsize
; until we've processed all bits up to startbit + decode-bitsize.
d387 3
a389 3
	 ;; (undecoded (if lsb0?
	 ;; 		(-range2 startbit (+ startbit decode-bitsize))
	 ;;		(-range2 (- startbit decode-bitsize) startbit)))
d395 1
a395 1
    (logit 3
d575 2
a576 4
	      ; FIXME: It's technically possible that the next
	      ; startbit+decode-bitsize chunk has no usable bits and we have to
	      ; iterate, but rather unlikely.
	      ; The calculation of the new startbit, decode-bitsize will
a577 1
	      (set! startbit (+ startbit decode-bitsize))
d626 1
a626 3
			; more of the instruction.  We currently require that
			; all bits get used before advancing startbit, so this
			; shouldn't be necessary.  Verify.
a680 3
	 ", startbit " startbit
	 ", decode-bitsize " decode-bitsize
	 ", index-list " index-list
@


1.10
log
@2004-01-29  Dave Brolley  <brolley@@redhat.com>

        * decode.scm (-opcode-slots): For short insns, generate 'opcode' with
        zeroes in the extra bit positions and generate 'opcode-mask' with ones
        in the extra bit positions.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2004 Red Hat, Inc.
@


1.10.6.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2004, 2009 Red Hat, Inc.
@


1.9
log
@2003-10-21  Dave Brolley  <brolley@@redhat.com>

        * sid-model.scm (-gen-model-class-decls): Generate MAX_UNITS as
        a static const int.
        * decode.scm (-opcode-slots): Correct typo in logit call.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
d436 1
a436 1
	   (compute (lambda (val insn-len decode-len bl)
d441 11
a451 11
			  (+ (if (> (car bl) insn-len)
				 0
				 (if (bit-set? val
					       (if lsb0?
						   (car bl)
						   (- insn-len (car bl) 1)))
				     (integer-expt 2 (- (length bl) 1))
				     0))
			     (compute val insn-len decode-len (cdr bl)))))))
    (let* ((opcode (compute (insn-value insn) insn-len decode-len bitnums))
	   (opcode-mask (compute (insn-base-mask insn) insn-len decode-len bitnums))
d454 2
a455 2
	     " insn-value=" (insn-value insn)
	     " insn-base-mask=" (insn-base-mask insn)
d458 2
a459 2
	     " opcode=" opcode
	     " opcode-mask=" opcode-mask
@


1.8
log
@format some code and comments to 80 char width
@
text
@d454 1
a454 1
	     " insn-base-value=" (insn-base-value insn)
@


1.7
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@d215 7
a221 6
; Compute population counts for each bit.  Return it as a vector indexed by bit number.
; Rather than computing raw popularity, attempt to compute "disinguishing value" or
; inverse-entropy for each bit.  The idea is that the larger the number for any particular
; bit slot, the more instructions it can be used to distinguish.  Raw mask popularity
; is not enough -- popular masks may include useless "reserved" fields whose values
; don't change, and thus are useless in distinguishing.
d453 8
a460 1
      (logit 3 "insn =" (obj:name insn) " insn-value=" (insn-value insn) " insn-base-mask=" (insn-base-mask insn) " insn-len=" insn-len " decode-len=" decode-len " opcode=" opcode " opcode-mask=" opcode-mask " indices=" indices "\n")
d599 2
a600 1
		  ; There is still more than one insn in 'slot', so there is still an ambiguity.
d612 3
a614 3
			; Things aren't entirely hopeless.  We've warned about the ambiguity.
		        ; Now, if there are any identical insns, filter them out.  If only one
		        ; remains, then use it.
d630 1
a630 1
					; Save arguments for debugging purposes.
d634 1
a634 1
					; FIXME: Punt on even simple cleverness for now.
@


1.6
log
@misc. whitespace and comment cleanup
@
text
@d94 1
a94 1
		      (string-append " " (obj:name (dtable-entry-value elm))))
d96 1
a96 1
		      (string-append " " (subdtable-name (dtable-entry-value elm))))
d98 1
a98 1
		      (string-append " " (exprtable-name (dtable-entry-value elm))))
d148 1
a148 1
		(string-append (obj:name (exprtable-entry-insn x))
d467 1
a467 1
  ;(display (string-append "fill-slot!: " (obj:name insn) " ")) (display bitnums) (newline)
d600 1
a600 1
						(string-append ", " (obj:name insn)))
@


1.5
log
@2002-05-21  Dave Brolley  <brolley@@redhat.com>

	* decode.scm (-opcode-slots): Don't consider bits beyond the length of
	the insn.
@
text
@a214 1

d221 1
d266 1
a267 1
; Return a list (0 ... limit-1)
d275 1
d282 2
a284 1
; Return a copy of given vector, with all entries with given indices set to `value'
d295 3
a298 2
; Return a list of indices whose counts in the given vector exceed the given threshold.
; Sort them in decreasing order of populatority.
a310 1

d314 1
a351 2


a399 1

@


1.4
log
@2002-01-03  Dave Brolley  <brolley@@redhat.com>

	* decode.scm (-distinguishing-bit-population): Compute num-insns, the
	number of insns in the list.  Update the population count function to
	identify and prioritize 3 catgories of useful bits.
	(-population-top-few): Don't consider bits with a population count of
	zero.
	(-build-decode-table-entry): Don't call
	filter-harmlessly-ambiguous-insns.  Filter out non-specialized and
	identical insns at the next tree level.
	* insn.scm (filter-harmlessly-ambiguous-insns): Note in a comment that
	this function is no longer used.
	(filter-non-specialized-ambiguous-insns): New function.
	(filter-identical-ambiguous-insns): New function.
	(find-identical-insn): New function.
	(filter-harmlessly-ambiguous-insns): Removed.
@
text
@d440 8
a447 6
			  (+ (if (bit-set? val
					   (if lsb0?
					       (car bl)
					       (- insn-len (car bl) 1)))
				 (integer-expt 2 (- (length bl) 1))
				 0)
d452 1
a452 1
      (logit 3 "insn =" (obj:name insn) " opcode=" opcode " indices=" indices "\n")
@


1.4.2.1
log
@merge from trunk
@
text
@d440 6
a445 8
			  (+ (if (> (car bl) insn-len)
				 0
				 (if (bit-set? val
					       (if lsb0?
						   (car bl)
						   (- insn-len (car bl) 1)))
				     (integer-expt 2 (- (length bl) 1))
				     0))
d450 1
a450 1
      (logit 3 "insn =" (obj:name insn) " insn-value=" (insn-value insn) " insn-base-mask=" (insn-base-mask insn) " insn-len=" insn-len " decode-len=" decode-len " opcode=" opcode " opcode-mask=" opcode-mask " indices=" indices "\n")
@


1.3
log
@* major sim decoder improvement
* minor diagnostic tweaks

2000-11-10  Frank Ch. Eigler  <fche@@redhat.com>

	* decode.scm (-distinguishing-bit-population): Significantly
	improve popularity heuristic.  Renamed from
	(-mask-bit-population): Gone.
	(-population-above-threshold): Sort new bit numbers in order of
	popularity.
	(-population-top-few): Allow up to three more bits to be selected
	than requested.  Correct selection order to prefer better bits.
	Correct bug in fewer-than-requested case.  Keep threshold as
	floating-point.
	(decode-best-get-bits): Pass also the insn-values.

	* utils-sim.scm (-gen-decoder-switch): Add comment suggesting a
	future optimization.

	* utils.scm (message): Format nested lists better.
@
text
@d225 2
a226 1
	 (1-population (make-vector max-length 0)))
d244 19
a262 2
	    ; (sqrt (+ p0 p1 (* p0 p1))) ; funny function - nice curve
	    (sqrt (* p0 p1))) ; geometric mean
d323 6
d332 1
a332 1
	      (logit 1 "-population-top-few: No bits left to pick from!\n"))
d522 1
a522 1
  (let ((slot (filter-harmlessly-ambiguous-insns (vector-ref insn-vec index))))
a579 1

d581 51
a631 34
	      ; If all insns are marked as DECODE-SPLIT, don't warn.
	      (if (not (all-true? (map (lambda (insn)
					 (obj-has-attr? insn 'DECODE-SPLIT))
				       slot)))
		  (message "WARNING: Decoder ambiguity detected: "
			   (string-drop1 ; drop leading comma
			    (string-map (lambda (insn)
					  (string-append ", " (obj:name insn)))
					slot))
			   "\n"))
	      ; Things aren't entirely hopeless.  See if any ifield-assertion
	      ; specs are present.
	      ; FIXME: For now we assume that if they all have an
	      ; ifield-assertion spec, then there is no ambiguity (it's left
	      ; to the programmer to get it right).  This can be made more
	      ; clever later.
	      ; FIXME: May need to back up startbit if we've tried to read
	      ; more of the instruction.
	      (let ((assertions (map insn-ifield-assertion slot)))
		(if (not (all-true? assertions))
		    (begin
		      ; Save arguments for debugging purposes.
		      (set! -build-decode-table-entry-args
			    (list insn-vec startbit decode-bitsize index index-list lsb0? invalid-insn))
		      (error "Unable to resolve ambiguity (maybe need some ifield-assertion specs?)")))
		; FIXME: Punt on even simple cleverness for now.
		(let ((exprtable-entries
		       (exprtable-sort (map exprtable-entry-make
					    slot
					    assertions))))
		  (dtable-entry-make index 'expr
				     (exprtable-make
				      (-gen-exprtable-name exprtable-entries)
				      exprtable-entries)))))
@


1.2
log
@* error handling fix

2000-09-08  Frank Ch. Eigler  <fche@@redhat.com>

	* decode.scm (-population-top-few): Signal error gracefully if
	decoding is about to become ambiguous.
@
text
@d217 6
a222 1
(define (-mask-bit-population masks mask-lens lsb0?)
d224 4
a227 2
	 (population (make-vector max-length 0)))
    (for-each (lambda (mask len)
d230 7
a236 3
			    (if (bit-set? mask (if lsb0? bitno (- len bitno 1)))
				(vector-set! population bitno 
					     (+ 1 (vector-ref population bitno)))))
d238 8
a245 2
	      masks mask-lens)
    population)
d277 1
d279 9
a287 4
  (find (lambda (index) (if (vector-ref population index) 
			    (>= (vector-ref population index) threshold)
			    #f))
	(-range (vector-length population)))
d291 3
a293 3
; Return the top few most popular indices in the population vector, ignoring any
; that are already used (marked by negative count).  Don't exceed `size' unless
; the clustering is just too good to pass up.
d301 1
d311 2
a312 2
	 ((> (+ (length new-picks) (length old-picks)) (+ 2 size))
	  (list-take (+ 2 size) (append new-picks old-picks)))
d314 1
a314 1
	 ((> (+ (length new-picks) (length old-picks)) (- 1 size))
d320 3
a322 1
		(truncate (* 0.8 count-threshold)))))))
d357 4
a360 3
  (let* ((raw-population (-mask-bit-population (map insn-base-mask insn-list)
					       (map insn-base-mask-length insn-list)
					       lsb0?))
@


1.1
log
@Initial revision
@
text
@d283 3
a285 2
	  (begin (assert (not (null? old-picks)))
		 old-picks))
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
