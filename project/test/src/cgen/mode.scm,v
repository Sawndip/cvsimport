head	1.13;
access;
symbols
	sid-snapshot-20180601:1.13
	cgen-snapshot-20180601:1.13
	sid-snapshot-20180501:1.13
	cgen-snapshot-20180501:1.13
	sid-snapshot-20180401:1.13
	cgen-snapshot-20180401:1.13
	sid-snapshot-20180301:1.13
	cgen-snapshot-20180301:1.13
	sid-snapshot-20180201:1.13
	cgen-snapshot-20180201:1.13
	sid-snapshot-20180101:1.13
	cgen-snapshot-20180101:1.13
	sid-snapshot-20171201:1.13
	cgen-snapshot-20171201:1.13
	sid-snapshot-20171101:1.13
	cgen-snapshot-20171101:1.13
	sid-snapshot-20171001:1.13
	cgen-snapshot-20171001:1.13
	sid-snapshot-20170901:1.13
	cgen-snapshot-20170901:1.13
	sid-snapshot-20170801:1.13
	cgen-snapshot-20170801:1.13
	sid-snapshot-20170701:1.13
	cgen-snapshot-20170701:1.13
	sid-snapshot-20170601:1.13
	cgen-snapshot-20170601:1.13
	sid-snapshot-20170501:1.13
	cgen-snapshot-20170501:1.13
	sid-snapshot-20170401:1.13
	cgen-snapshot-20170401:1.13
	sid-snapshot-20170301:1.13
	cgen-snapshot-20170301:1.13
	sid-snapshot-20170201:1.13
	cgen-snapshot-20170201:1.13
	sid-snapshot-20170101:1.13
	cgen-snapshot-20170101:1.13
	sid-snapshot-20161201:1.13
	cgen-snapshot-20161201:1.13
	sid-snapshot-20161101:1.13
	cgen-snapshot-20161101:1.13
	sid-snapshot-20160901:1.13
	cgen-snapshot-20160901:1.13
	sid-snapshot-20160801:1.13
	cgen-snapshot-20160801:1.13
	sid-snapshot-20160701:1.13
	cgen-snapshot-20160701:1.13
	sid-snapshot-20160601:1.13
	cgen-snapshot-20160601:1.13
	sid-snapshot-20160501:1.13
	cgen-snapshot-20160501:1.13
	sid-snapshot-20160401:1.13
	cgen-snapshot-20160401:1.13
	sid-snapshot-20160301:1.13
	cgen-snapshot-20160301:1.13
	sid-snapshot-20160201:1.13
	cgen-snapshot-20160201:1.13
	sid-snapshot-20160101:1.13
	cgen-snapshot-20160101:1.13
	sid-snapshot-20151201:1.13
	cgen-snapshot-20151201:1.13
	sid-snapshot-20151101:1.13
	cgen-snapshot-20151101:1.13
	sid-snapshot-20151001:1.13
	cgen-snapshot-20151001:1.13
	sid-snapshot-20150901:1.13
	cgen-snapshot-20150901:1.13
	sid-snapshot-20150801:1.13
	cgen-snapshot-20150801:1.13
	sid-snapshot-20150701:1.13
	cgen-snapshot-20150701:1.13
	sid-snapshot-20150601:1.13
	cgen-snapshot-20150601:1.13
	sid-snapshot-20150501:1.13
	cgen-snapshot-20150501:1.13
	sid-snapshot-20150401:1.13
	cgen-snapshot-20150401:1.13
	sid-snapshot-20150301:1.13
	cgen-snapshot-20150301:1.13
	sid-snapshot-20150201:1.13
	cgen-snapshot-20150201:1.13
	sid-snapshot-20150101:1.13
	cgen-snapshot-20150101:1.13
	sid-snapshot-20141201:1.13
	cgen-snapshot-20141201:1.13
	sid-snapshot-20141101:1.13
	cgen-snapshot-20141101:1.13
	sid-snapshot-20141001:1.13
	cgen-snapshot-20141001:1.13
	sid-snapshot-20140901:1.13
	cgen-snapshot-20140901:1.13
	sid-snapshot-20140801:1.13
	cgen-snapshot-20140801:1.13
	sid-snapshot-20140701:1.13
	cgen-snapshot-20140701:1.13
	sid-snapshot-20140601:1.13
	cgen-snapshot-20140601:1.13
	sid-snapshot-20140501:1.13
	cgen-snapshot-20140501:1.13
	sid-snapshot-20140401:1.13
	cgen-snapshot-20140401:1.13
	sid-snapshot-20140301:1.13
	cgen-snapshot-20140301:1.13
	sid-snapshot-20140201:1.13
	cgen-snapshot-20140201:1.13
	sid-snapshot-20140101:1.13
	cgen-snapshot-20140101:1.13
	sid-snapshot-20131201:1.13
	cgen-snapshot-20131201:1.13
	sid-snapshot-20131101:1.13
	cgen-snapshot-20131101:1.13
	sid-snapshot-20131001:1.13
	cgen-snapshot-20131001:1.13
	sid-snapshot-20130901:1.13
	cgen-snapshot-20130901:1.13
	sid-snapshot-20130801:1.13
	cgen-snapshot-20130801:1.13
	sid-snapshot-20130701:1.13
	cgen-snapshot-20130701:1.13
	sid-snapshot-20130601:1.13
	cgen-snapshot-20130601:1.13
	sid-snapshot-20130501:1.13
	cgen-snapshot-20130501:1.13
	sid-snapshot-20130401:1.13
	cgen-snapshot-20130401:1.13
	sid-snapshot-20130301:1.13
	cgen-snapshot-20130301:1.13
	sid-snapshot-20130201:1.13
	cgen-snapshot-20130201:1.13
	sid-snapshot-20130101:1.13
	cgen-snapshot-20130101:1.13
	sid-snapshot-20121201:1.13
	cgen-snapshot-20121201:1.13
	sid-snapshot-20121101:1.13
	cgen-snapshot-20121101:1.13
	sid-snapshot-20121001:1.13
	cgen-snapshot-20121001:1.13
	sid-snapshot-20120901:1.13
	cgen-snapshot-20120901:1.13
	sid-snapshot-20120801:1.13
	cgen-snapshot-20120801:1.13
	sid-snapshot-20120701:1.13
	cgen-snapshot-20120701:1.13
	sid-snapshot-20120601:1.13
	cgen-snapshot-20120601:1.13
	sid-snapshot-20120501:1.13
	cgen-snapshot-20120501:1.13
	sid-snapshot-20120401:1.13
	cgen-snapshot-20120401:1.13
	sid-snapshot-20120301:1.13
	cgen-snapshot-20120301:1.13
	sid-snapshot-20120201:1.13
	cgen-snapshot-20120201:1.13
	sid-snapshot-20120101:1.13
	cgen-snapshot-20120101:1.13
	sid-snapshot-20111201:1.13
	cgen-snapshot-20111201:1.13
	sid-snapshot-20111101:1.13
	cgen-snapshot-20111101:1.13
	sid-snapshot-20111001:1.13
	cgen-snapshot-20111001:1.13
	sid-snapshot-20110901:1.13
	cgen-snapshot-20110901:1.13
	sid-snapshot-20110801:1.13
	cgen-snapshot-20110801:1.13
	sid-snapshot-20110701:1.13
	cgen-snapshot-20110701:1.13
	sid-snapshot-20110601:1.13
	cgen-snapshot-20110601:1.13
	sid-snapshot-20110501:1.13
	cgen-snapshot-20110501:1.13
	sid-snapshot-20110401:1.13
	cgen-snapshot-20110401:1.13
	sid-snapshot-20110301:1.13
	cgen-snapshot-20110301:1.13
	sid-snapshot-20110201:1.13
	cgen-snapshot-20110201:1.13
	sid-snapshot-20110101:1.13
	cgen-snapshot-20110101:1.13
	sid-snapshot-20101201:1.13
	cgen-snapshot-20101201:1.13
	sid-snapshot-20101101:1.13
	cgen-snapshot-20101101:1.13
	sid-snapshot-20101001:1.13
	cgen-snapshot-20101001:1.13
	sid-snapshot-20100901:1.13
	cgen-snapshot-20100901:1.13
	sid-snapshot-20100801:1.13
	cgen-snapshot-20100801:1.13
	sid-snapshot-20100701:1.13
	cgen-snapshot-20100701:1.13
	sid-snapshot-20100601:1.13
	cgen-snapshot-20100601:1.13
	sid-snapshot-20100501:1.13
	cgen-snapshot-20100501:1.13
	sid-snapshot-20100401:1.13
	cgen-snapshot-20100401:1.13
	sid-snapshot-20100301:1.13
	cgen-snapshot-20100301:1.13
	sid-snapshot-20100201:1.13
	cgen-snapshot-20100201:1.13
	sid-snapshot-20100101:1.11
	cgen-snapshot-20100101:1.11
	sid-snapshot-20091201:1.11
	cgen-snapshot-20091201:1.11
	sid-snapshot-20091101:1.11
	cgen-snapshot-20091101:1.11
	sid-snapshot-20091001:1.10
	cgen-snapshot-20091001:1.10
	arc-sim-20090309:1.4
	sid-snapshot-20090901:1.7
	cgen-snapshot-20090901:1.7
	sid-snapshot-20090801:1.6
	cgen-snapshot-20090801:1.6
	sid-snapshot-20090701:1.5
	cgen-snapshot-20090701:1.5
	dje-cgen-play1-branch:1.5.0.2
	dje-cgen-play1-branchpoint:1.5
	cgen-1_1-branch:1.4.0.6
	cgen-1_1-branchpoint:1.4
	sid-snapshot-20090601:1.4
	cgen-snapshot-20090601:1.4
	sid-snapshot-20090501:1.4
	cgen-snapshot-20090501:1.4
	sid-snapshot-20090401:1.4
	cgen-snapshot-20090401:1.4
	arc-insight_6_8-branch:1.4.0.4
	arc-insight_6_8-branchpoint:1.4
	sid-snapshot-20090301:1.4
	cgen-snapshot-20090301:1.4
	sid-snapshot-20090201:1.4
	cgen-snapshot-20090201:1.4
	sid-snapshot-20090101:1.4
	cgen-snapshot-20090101:1.4
	sid-snapshot-20081201:1.4
	cgen-snapshot-20081201:1.4
	sid-snapshot-20081101:1.4
	cgen-snapshot-20081101:1.4
	sid-snapshot-20081001:1.4
	cgen-snapshot-20081001:1.4
	sid-snapshot-20080901:1.4
	cgen-snapshot-20080901:1.4
	sid-snapshot-20080801:1.4
	cgen-snapshot-20080801:1.4
	sid-snapshot-20080701:1.4
	cgen-snapshot-20080701:1.4
	sid-snapshot-20080601:1.4
	cgen-snapshot-20080601:1.4
	sid-snapshot-20080501:1.4
	cgen-snapshot-20080501:1.4
	sid-snapshot-20080403:1.4
	sid-snapshot-20080401:1.4
	cgen-snapshot-20080401:1.4
	sid-snapshot-20080301:1.4
	cgen-snapshot-20080301:1.4
	sid-snapshot-20080201:1.4
	cgen-snapshot-20080201:1.4
	sid-snapshot-20080101:1.4
	cgen-snapshot-20080101:1.4
	sid-snapshot-20071201:1.4
	cgen-snapshot-20071201:1.4
	sid-snapshot-20071101:1.4
	cgen-snapshot-20071101:1.4
	sid-snapshot-20071001:1.4
	cgen-snapshot-20071001:1.4
	msnyder-fork-checkpoint-branch:1.4.0.2
	msnyder-fork-checkpoint-branchpoint:1.4
	sid-20020905-branchpoint:1.1.1.1
	sid-20020905-branch:1.1.1.1.0.6
	cagney_regbuf-20020515-branch:1.1.1.1.0.4
	cagney_regbuf-20020515-branchpoint:1.1.1.1
	cygnus_cvs_20020108_pre:1.1.1.1
	cgen-1-1-branch:1.1.1.1.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.13
date	2010.01.25.00.40.29;	author devans;	state Exp;
branches;
next	1.12;

1.12
date	2010.01.06.05.05.13;	author devans;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.28.16.37.33;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2009.09.23.22.30.19;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.12.17.34.15;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2009.09.07.22.17.34;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2009.08.12.22.33.37;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	2009.07.22.18.30.59;	author devans;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.16.05.35.47;	author devans;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	2003.06.04.20.22.49;	author devans;	state Exp;
branches;
next	1.2;

1.2
date	2002.12.20.06.39.04;	author devans;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.4.6.1
date	2009.06.24.14.57.45;	author devans;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.13
log
@	* utils-cgen.scm (<location>): Define using new define-class.
	(<ident>, <source-ident>, <context>): Ditto.

	* cos.scm (/object-string): New function.
	(/object-error): Use it.
	(/object-count-true): New function
	(object-copy-top): Delete.  All callers changed to call object-copy.
	(/parse-member-list, /build-getter-defs, /build-setter-defs): New fns.
	(define-class, define-interface, define-method): New macros.
	(define-getters, define-setters, vmake): Moved here ...
	* utils-cgen.scm: ... from here.
@
text
@; Mode objects.
; Copyright (C) 2000, 2009, 2010 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.

; FIXME: Later allow target to add new modes.

(define <mode>
  (class-make '<mode>
	      '(<ident>)
	      '(
		; One of RANDOM, INT, UINT, FLOAT.
		class

		; size in bits
		bits

		; size in bytes
		bytes

		; The C type to use or #f if there is no such C type.
		; This is generally the name of the mode.
		c-type

		; PRINTF-TYPE is the %<letter> arg to printf-like functions,
		; however we define our own extensions for non-portable modes.
		; Values not understood by printf aren't intended to be used
		; with printf.
		;
		; Possible values:
		; %x - as always
		; %D - DI mode (8 bytes)
		; %T - TI mode (16 bytes)
		; %O - OI mode (32 bytes)
		; %f - SF,DF modes
		; %F - XF,TF modes
		printf-type

		; SEM-MODE is the mode to use for semantic operations.
		; Unsigned modes are not part of the semantic language proper,
		; but they can be used in hardware descriptions.  This maps
		; unusable -> usable modes.  It is #f if the mode is usable by
		; itself.  This prevents circular data structures and makes it
		; easy to define since the object doesn't exist before it's
		; defined.
		; ??? May wish to later remove SEM-MODE (e.g. mips signed add
		; is different than mips unsigned add).  However for now it keeps
		; things simpler, and prevents being wildly dissimilar from
		; GCC-RTL.  And the mips case needn't be handled with different
		; adds anyway.
		sem-mode

		; PTR-TO, if non-#f, is the mode being pointed to.
		ptr-to

		; HOST? is non-#f if the mode is a portable int for hosts,
		; or other host-related value.
		; This is used for things like register numbers and small
		; odd-sized immediates and registers.
		; ??? Not my favorite word choice here, but it's close.
		host?
		)
	      nil)
)

; Accessor fns

(define mode:class (elm-make-getter <mode> 'class))
(define mode:bits (elm-make-getter <mode> 'bits))
(define mode:bytes (elm-make-getter <mode> 'bytes))
(define mode:c-type (elm-make-getter <mode> 'c-type))
(define mode:printf-type (elm-make-getter <mode> 'printf-type))
(define mode:sem-mode (elm-make-getter <mode> 'sem-mode))
; ptr-to is currently private so there is no accessor.
(define mode:host? (elm-make-getter <mode> 'host?))

;; Utility to set the parameters of WI/UWI/AI/IAI modes.

(define (/mode-set-word-params! dst src)
  (assert (mode? dst))
  (assert (mode? src))
  (object-assign! dst src)
  *UNSPECIFIED*
)

; CM is short for "concat mode".  It is a list of modes of the elements
; of a `concat'.
; ??? Experiment.  Not currently used.

(define <concat-mode>
  (class-make '<concat-mode> '(<mode>)
	      '(
		; List of element modes
		elm-modes
		)
	      nil)
)

; Accessors.

(define cmode-elm-modes (elm-make-getter <concat-mode> 'elm-modes))

;; Table of all modes.
(define /mode-table nil)

;; This exists to simplify mode-find.
(define /mode-class-table nil)

; Return list of real mode objects (no aliases).

(define (mode-list-non-alias-values)
  (hash-fold (lambda (key value prior)
	       (if (eq? key (obj:name value))
		   (append value prior)
		   prior))
	     '()
	     /mode-table)
)

; Return a boolean indicating if X is a <mode> object.

(define (mode? x) (class-instance? <mode> x))

; Return enum cgen_mode_types value for M.

(define (mode:enum m)
  (gen-c-symbol (string-append "MODE_" (string-upcase (obj:str-name m))))
)

; Return a boolean indicating if MODE1 is equal to MODE2
; Either may be the name of a mode or a <mode> object.
; Aliases are handled by refering to their real name.
; ??? Might be useful to restrict this to <mode> objects only.

(define (mode:eq? mode1 mode2)
  (let ((mode1-name (mode-real-name (mode-maybe-lookup mode1)))
	(mode2-name (mode-real-name (mode-maybe-lookup mode2))))
    (eq? mode1-name mode2-name))
)

; Return a boolean indicating if CLASS is one of INT/UINT.

(define (mode-class-integral? class) (memq class '(INT UINT)))
(define (mode-class-signed? class) (eq? class 'INT))
(define (mode-class-unsigned? class) (eq? class 'UINT))

; Return a boolean indicating if CLASS is floating point.

(define (mode-class-float? class) (memq class '(FLOAT)))

; Return a boolean indicating if CLASS is numeric.

(define (mode-class-numeric? class) (memq class '(INT UINT FLOAT)))

; Return a boolean indicating if <mode> MODE has an integral mode class.
; Similarily for signed/unsigned.

(define (mode-integral? mode) (mode-class-integral? (mode:class mode)))
(define (mode-signed? mode) (mode-class-signed? (mode:class mode)))
(define (mode-unsigned? mode) (mode-class-unsigned? (mode:class mode)))

; Return a boolean indicating if <mode> MODE has a floating point mode class.

(define (mode-float? mode) (mode-class-float? (mode:class mode)))

; Return a boolean indicating if <mode> MODE has a numeric mode class.

(define (mode-numeric? mode) (mode-class-numeric? (mode:class mode))) 

;; Return a boolean indicating if <mode> MODE is VOID.

(define (mode-void? mode)
  (eq? mode VOID)
)

; Return a boolean indicating if MODE1 is compatible with MODE2.
; MODE[12] are either names or <mode> objects.
; HOW is a symbol indicating how the test is performed:
; strict: modes must have same name
; samesize: modes must be both float, or both integer (int or uint),
;           or both VOID and have same size
; sameclass: modes must be both float, or both integer (int or uint),
;            or both VOID
; numeric: modes must be both numeric

(define (mode-compatible? how mode1 mode2)
  (let ((m1 (mode-maybe-lookup mode1))
	(m2 (mode-maybe-lookup mode2)))
    (case how
      ((strict)
       (eq? (obj:name m1) (obj:name m2)))
      ((samesize)
       (cond ((mode-integral? m1)
	      (and (mode-integral? m2)
		   (= (mode:bits m1) (mode:bits m2))))
	     ((mode-float? m1)
	      (and (mode-float? m2)
		   (= (mode:bits m1) (mode:bits m2))))
	     ((mode-void? m1)
	      (mode-void? m2))
	     (else #f)))
      ((sameclass)
       (cond ((mode-integral? m1) (mode-integral? m2))
	     ((mode-float? m1) (mode-float? m2))
	     ((mode-void? m1) (mode-void? m2))
	     (else #f)))
      ((numeric)
       (and (mode-numeric? m1) (mode-numeric? m2)))
      (else (error "bad `how' arg to mode-compatible?" how))))
)

; Add MODE named NAME to the table of recognized modes.
; If NAME is already present, replace it with MODE.
; MODE is a mode object.
; NAME exists to allow aliases of modes [e.g. WI, UWI, AI, IAI].
;
; No attempt to preserve any particular order of entries is done here.
; That is up to the caller.

(define (mode:add! name mode)
  (hashq-set! /mode-table name mode)

  ;; Add the mode to its mode class.
  ;; There's no point in building this list in any particular order,
  ;; if the user adds some they could be of any size.
  ;; So build the list the simple way (in reverse).
  ;; The list is sorted in mode-finish!.
  (let ((class (mode:class mode)))
    (hashq-set! /mode-class-table class
		(cons mode (hashq-ref /mode-class-table class))))

  *UNSPECIFIED*
)

; Parse a mode.
; This is the main routine for building a mode object.
; All arguments are in raw (non-evaluated) form.

(define (/mode-parse context name comment attrs class bits bytes
		     c-type printf-type sem-mode ptr-to host?)
  (logit 2 "Processing mode " name " ...\n")

  ;; Pick out name first to augment the error context.
  (let* ((name (parse-name context name))
	 (context (context-append-name context name)))

    (make <mode>
      name
      (parse-comment context comment)
      (atlist-parse context attrs "mode")
      class bits bytes c-type printf-type
      sem-mode ptr-to host?))
)

; ??? At present there is no define-mode that takes an associative list
; of arguments.

; Define a mode object, all arguments specified.

(define (define-full-mode name comment attrs class bits bytes
	  c-type printf-type sem-mode ptr-to host?)
  (let ((m (/mode-parse (make-current-context "define-full-mode")
			name comment attrs
			class bits bytes
			c-type printf-type sem-mode ptr-to host?)))
    ; Add it to the list of insn modes.
    (mode:add! name m)
    m)
)

; Lookup the mode named X.
; Return the found object or #f.
; If X is already a mode object, return that.

(define (mode:lookup mode-name)
;  (if (mode? x)
;      x
;      (let ((result (assq x mode-list)))
;	(if result
;	    (cdr result)
;	    #f)))
  (hashq-ref /mode-table mode-name)
)

;; Same as mode:lookup except MODE is either the mode name or a <mode> object.

(define (mode-maybe-lookup mode)
  (if (symbol? mode)
      (hashq-ref /mode-table mode)
      mode)
)

; Return a boolean indicating if X is a valid mode name.

(define (mode-name? x)
  (and (symbol? x)
       (->bool (mode:lookup x)))
)

; Return the name of the real mode of MODE, a <mode> object.
; This is a no-op unless M is an alias in which case we return the
; real mode of the alias.

(define (mode-real-name mode)
  (obj:name mode)
)

; Return the real mode of MODE, a <mode> object.
; This is a no-op unless M is an alias in which case we return the
; real mode of the alias.

(define (mode-real-mode mode)
  ;; Lookups of aliases return its real mode, so this function is a no-op.
  ;; But that's an implementation detail, so I'm not ready to delete this
  ;; function.
  mode
)

; Return the version of MODE to use in semantic expressions.
; MODE is a <mode> object.
; This (essentially) converts aliases to their real value and then uses
; mode:sem-mode.  The implementation is the opposite but the effect is the
; same.
; ??? Less efficient than it should be.  One improvement would be to
; disallow unsigned modes from being aliased and set sem-mode for aliased
; modes.

(define (mode-sem-mode mode)
  (let ((sm (mode:sem-mode mode)))
    (if sm
	sm
	(mode-real-mode mode)))
)

; Return #t if mode M1 is bigger than mode M2.
; Both are <mode> objects.

(define (mode-bigger? m1 m2)
  (> (mode:bits m1)
     (mode:bits m2))
)

; Return a mode in mode class CLASS wide enough to hold BITS.
; This ignores "host" modes (e.g. INT,UINT).

(define (mode-find bits class)
  (let* ((class-modes (hashq-ref /mode-class-table class))
	 (modes (find (lambda (mode) (not (mode:host? mode)))
		      (or class-modes nil))))		     
    (if (null? modes)
	(error "invalid mode class" class))
    (let loop ((modes modes))
      (cond ((null? modes) (error "no modes for bits" bits))
	    ((<= bits (mode:bits (car modes))) (car modes))
	    (else (loop (cdr modes))))))
)

; Parse MODE-NAME and return the mode object.
; CONTEXT is a <context> object for error messages.
; An error is signalled if MODE isn't valid.

(define (parse-mode-name context mode-name)
  (let ((m (mode:lookup mode-name)))
    (if (not m)
	(parse-error context "not a valid mode" mode-name))
    m)
)

; Make a new INT/UINT mode.
; These have a variable number of bits (1-64).

(define (mode-make-int bits)
  (if (or (<= bits 0) (> bits 64))
      (error "unsupported number of bits" bits))
  (let ((result (object-copy INT)))
    (elm-xset! result 'bits bits)
    (elm-xset! result 'bytes (bits->bytes bits))
    result)
)

(define (mode-make-uint bits)
  (if (or (<= bits 0) (> bits 64))
      (error "unsupported number of bits" bits))
  (let ((result (object-copy UINT)))
    (elm-xset! result 'bits bits)
    (elm-xset! result 'bytes (bits->bytes bits))
    result)
)

; WI/UWI/AI/IAI modes
; These are aliases for other modes, e.g. SI,DI.
; Final values are defered until all cpu family definitions have been
; read in so that we know the word size, etc.
;
; NOTE: We currently assume WI/AI/IAI all have the same size: cpu:word-bitsize.
; If we ever add an architecture that needs different modes for WI/AI/IAI,
; we can add the support then.

; This is defined by the target in define-cpu:word-bitsize.
(define WI #f)
(define UWI #f)

; An "address int".  This is recorded in addition to a "word int" because it
; is believed that some target will need it.  It also stays consistent with
; what BFD does.  It also allows one to write rtl without having to care
; what the real mode actually is.
; ??? These are currently set from define-cpu:word-bitsize but that's just
; laziness.  If an architecture comes along that has different values,
; add the support then.
(define AI #f)
(define IAI #f)

; Kind of word size handling wanted.
; BIGGEST: pick the largest word size
; IDENTICAL: all word sizes must be identical
(define /mode-word-sizes-kind #f)

;; Set to true if mode-set-word-modes! has been called.
(define /mode-word-sizes-defined? #f)

; Called when a cpu-family is read in to set the word sizes.

(define (mode-set-word-modes! bitsize)
  (let ((current-word-bitsize (mode:bits WI))
	(word-mode (mode-find bitsize 'INT))
	(uword-mode (mode-find bitsize 'UINT))
	(ignore? #f))

    ; Ensure we found a precise match.
    (if (!= bitsize (mode:bits word-mode))
	(error "unable to find precise mode to match cpu word-bitsize" bitsize))

    ; Enforce word size kind.
    (if /mode-word-sizes-defined?
	(case /mode-word-sizes-kind
	  ((IDENTICAL)
	   (if (!= current-word-bitsize (mode:bits word-mode))
	       (error "app requires all selected cpu families to have same word size"))
	   (set! ignore? #t))
	  ((BIGGEST)
	   (if (>= current-word-bitsize (mode:bits word-mode))
	       (set! ignore? #t)))
	  ))

    (if (not ignore?)
	(begin
	  (/mode-set-word-params! WI word-mode)
	  (/mode-set-word-params! UWI uword-mode)
	  (/mode-set-word-params! AI uword-mode)
	  (/mode-set-word-params! IAI uword-mode)
	  ))
    )

  (set! /mode-word-sizes-defined? #t)
)

; Called by apps to indicate cpu:word-bitsize always has one value.
; It is an error to call this if the selected cpu families have
; different word sizes.
; Must be called before loading .cpu files.

(define (mode-set-identical-word-bitsizes!)
  (set! /mode-word-sizes-kind 'IDENTICAL)
)

; Called by apps to indicate using the biggest cpu:word-bitsize of all
; selected cpu families.
; Must be called before loading .cpu files.

(define (mode-set-biggest-word-bitsizes!)
  (set! /mode-word-sizes-kind 'BIGGEST)
)

; Ensure word sizes have been defined.
; This must be called after all cpu families have been defined
; and before any ifields, hardware, operand or insns have been read.
; FIXME: sparc.cpu breaks this

(define (mode-ensure-word-sizes-defined)
  (if (not /mode-word-sizes-defined?)
      (error "word sizes must be defined"))
)

; Initialization.

; Some modes are refered to by the Scheme code.
; These have global bindings, but we try not to make this the general rule.
; [Actually I don't think this is all that bad, but it seems reasonable to
; not create global bindings that we don't have to.]

(define VOID #f)
(define DFLT #f)

; Variable sized portable ints.
(define INT #f)
(define UINT #f)

;; Sort the modes for each class.

(define (/sort-mode-classes!)
  (for-each (lambda (class-name)
	      (hashq-set! /mode-class-table class-name
			  (sort (hashq-ref /mode-class-table class-name)
				(lambda (a b)
				  (< (mode:bits a)
				     (mode:bits b))))))
	    '(RANDOM INT UINT FLOAT))

  *UNSPECIFIED*
)

(define (mode-init!)
  (set! /mode-word-sizes-kind 'IDENTICAL)
  (set! /mode-word-sizes-defined? #f)

  (reader-add-command! 'define-full-mode
		       "\
Define a mode, all arguments specified.
"
		       nil '(name commment attrs class bits bytes
			     non-c-mode-type printf-type sem-mode ptr-to host?)
		       define-full-mode)

  *UNSPECIFIED*
)

; Called before a . cpu file is read in to install any builtins.

(define (mode-builtin!)
  ; FN-SUPPORT: In sem-ops.h file, include prototypes as well as macros.
  ;             Elsewhere, functions are defined to perform the operation.
  (define-attr '(for mode) '(type boolean) '(name FN-SUPPORT))

  (set! /mode-class-table (make-hash-table 7))
  (hashq-set! /mode-class-table 'RANDOM '())
  (hashq-set! /mode-class-table 'INT '())
  (hashq-set! /mode-class-table 'UINT '())
  (hashq-set! /mode-class-table 'FLOAT '())

  (set! /mode-table (make-hash-table 41))

  (let ((dfm define-full-mode))
    ; This list must be defined in order of increasing size among each type.
    ; FIXME: still true?

    (dfm 'VOID "void" '() 'RANDOM 0 0 "void" "" #f #f #f) ; VOIDmode

    ; Special marker to indicate "use the default mode".
    (dfm 'DFLT "default mode" '() 'RANDOM 0 0 #f "" #f #f #f)

    ; Mode used in `symbol' rtxs.
    (dfm 'SYM "symbol" '() 'RANDOM 0 0 #f "" #f #f #f)

    ; Mode used in `current-insn' rtxs.
    (dfm 'INSN "insn" '() 'RANDOM 0 0 #f "" #f #f #f)

    ; Mode used in `current-mach' rtxs.
    (dfm 'MACH "mach" '() 'RANDOM 0 0 #f "" #f #f #f)

    ; Not UINT on purpose.
    (dfm 'BI "one bit (0,1 not 0,-1)" '() 'INT 1 1 "BI" "'x'" #f #f #f)

    (dfm 'QI "8 bit byte" '() 'INT 8 1 "QI" "'x'" #f #f #f)
    (dfm 'HI "16 bit int" '() 'INT 16 2 "HI" "'x'" #f #f #f)
    (dfm 'SI "32 bit int" '() 'INT 32 4 "SI" "'x'" #f #f #f)
    (dfm 'DI "64 bit int" '(FN-SUPPORT) 'INT 64 8 "DI" "'D'" #f #f #f)

    ; No unsigned versions on purpose for now.
    (dfm 'TI "128 bit int" '(FN-SUPPORT) 'INT 128 16 "TI" "'T'" #f #f #f)
    (dfm 'OI "256 bit int" '(FN-SUPPORT) 'INT 256 32 "OI" "'O'" #f #f #f)

    (dfm 'UQI "8 bit unsigned byte" '() 'UINT
	 8 1 "UQI" "'x'" (mode:lookup 'QI) #f #f)
    (dfm 'UHI "16 bit unsigned int" '() 'UINT
	 16 2 "UHI" "'x'" (mode:lookup 'HI) #f #f)
    (dfm 'USI "32 bit unsigned int" '() 'UINT
	 32 4 "USI" "'x'" (mode:lookup 'SI) #f #f)
    (dfm 'UDI "64 bit unsigned int" '(FN-SUPPORT) 'UINT
	 64 8 "UDI" "'D'" (mode:lookup 'DI) #f #f)

    ; Floating point values.
    (dfm 'SF "32 bit float" '(FN-SUPPORT) 'FLOAT
	 32 4 "SF" "'f'" #f #f #f)
    (dfm 'DF "64 bit float" '(FN-SUPPORT) 'FLOAT
	 64 8 "DF" "'f'" #f #f #f)
    (dfm 'XF "80/96 bit float" '(FN-SUPPORT) 'FLOAT
	 96 12 "XF" "'F'" #f #f #f)
    (dfm 'TF "128 bit float" '(FN-SUPPORT) 'FLOAT
	 128 16 "TF" "'F'" #f #f #f)

    ; These are useful modes that represent host values.
    ; For INT/UINT the sizes indicate maximum portable values.
    ; These are also used for random width hardware elements (e.g. immediates
    ; and registers).
    ; FIXME: Can't be used to represent both host and target values.
    ; Either remove the distinction or add new modes with the distinction.
    ; FIXME: IWBN to specify #f for sem-mode, but that means we'd need
    ; TRUNCINTQI,etc.
    (dfm 'INT "portable int" '() 'INT 32 4 "INT" "'x'"
	 (mode:lookup 'SI) #f #t)
    (dfm 'UINT "portable unsigned int" '() 'UINT 32 4 "UINT" "'x'"
	 (mode:lookup 'SI) #f #t)

    ; ??? Experimental.
    (dfm 'PTR "host pointer" '() 'RANDOM 0 0 "void*" "'x'"
	 #f (mode:lookup 'VOID) #t)
    )

  (set! VOID (mode:lookup 'VOID))
  (set! DFLT (mode:lookup 'DFLT))

  (set! INT (mode:lookup 'INT))
  (set! UINT (mode:lookup 'UINT))

  ;; While setting the real values of WI/UWI/AI/IAI is defered to
  ;; mode-set-word-modes!, create usable entries in the table.
  ;; The entries must be usable as h/w elements may be defined that use them.
  (set! WI (object-copy (mode:lookup 'SI)))
  (set! UWI (object-copy (mode:lookup 'USI)))
  (set! AI (object-copy (mode:lookup 'USI)))
  (set! IAI (object-copy (mode:lookup 'USI)))
  (mode:add! 'WI WI)
  (mode:add! 'UWI UWI)
  (mode:add! 'AI AI)
  (mode:add! 'IAI IAI)

  ;; Need to have usable mode classes at this point as define-cpu
  ;; calls mode-set-word-modes!.
  (/sort-mode-classes!)

  *UNSPECIFIED*
)

(define (mode-finish!)
  ;; FIXME: mode:add! should keep the class sorted.
  ;; It's a cleaner way to handle modes from the .cpu file.
  (/sort-mode-classes!)

  *UNSPECIFIED*
)
@


1.12
log
@	* mode.scm (<mode>) Rename member non-mode-c-type to c-type.
	All uses updated.
	(mode:non-mode-c-type): Delete.
	(mode:c-type): Update.
	* rtl-c.scm (s-shop): Fix casting of DI mode values.
@
text
@d375 1
a375 1
  (let ((result (object-copy-top INT)))
d384 1
a384 1
  (let ((result (object-copy-top UINT)))
d618 4
a621 4
  (set! WI (object-copy-top (mode:lookup 'SI)))
  (set! UWI (object-copy-top (mode:lookup 'USI)))
  (set! AI (object-copy-top (mode:lookup 'USI)))
  (set! IAI (object-copy-top (mode:lookup 'USI)))
@


1.11
log
@	* cos.scm (object-assign!): New function.
	* mode.scm (/mode-set-word-params!): Call it.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2009 Red Hat, Inc.
d21 3
a23 7
		; NON-MODE-C-TYPE is the C type to use in situations where
		; modes aren't available.  A somewhat dubious feature, but at
		; the moment the opcodes tables use it.  It is either the C
		; type as a string (e.g. "int") or #f for non-portable modes
		; (??? could use other typedefs for #f, e.g. int64 for DI).
		; Use of GCC can't be assumed though.
		non-mode-c-type
d71 1
a71 1
(define mode:non-mode-c-type (elm-make-getter <mode> 'non-mode-c-type))
a85 9
; Return string C type to use for values of mode M.

(define (mode:c-type m)
  (let ((ptr-to (elm-xget m 'ptr-to)))
    (if ptr-to
	(string-append (mode:c-type ptr-to) " *")
	(obj:str-name m)))
)

d240 1
a240 1
		     non-mode-c-type printf-type sem-mode ptr-to host?)
d251 1
a251 1
      class bits bytes non-mode-c-type printf-type
d261 1
a261 1
	  non-mode-c-type printf-type sem-mode ptr-to host?)
d265 1
a265 1
			non-mode-c-type printf-type sem-mode ptr-to host?)))
d549 1
a549 1
    (dfm 'DFLT "default mode" '() 'RANDOM 0 0 "" "" #f #f #f)
d552 1
a552 1
    (dfm 'SYM "symbol" '() 'RANDOM 0 0 "" "" #f #f #f)
d555 1
a555 1
    (dfm 'INSN "insn" '() 'RANDOM 0 0 "" "" #f #f #f)
d558 1
a558 1
    (dfm 'MACH "mach" '() 'RANDOM 0 0 "" "" #f #f #f)
d561 1
a561 1
    (dfm 'BI "one bit (0,1 not 0,-1)" '() 'INT 1 1 "int" "'x'" #f #f #f)
d563 4
a566 4
    (dfm 'QI "8 bit byte" '() 'INT 8 1 "int" "'x'" #f #f #f)
    (dfm 'HI "16 bit int" '() 'INT 16 2 "int" "'x'" #f #f #f)
    (dfm 'SI "32 bit int" '() 'INT 32 4 "int" "'x'" #f #f #f)
    (dfm 'DI "64 bit int" '(FN-SUPPORT) 'INT 64 8 "" "'D'" #f #f #f)
d569 2
a570 2
    (dfm 'TI "128 bit int" '(FN-SUPPORT) 'INT 128 16 "" "'T'" #f #f #f)
    (dfm 'OI "256 bit int" '(FN-SUPPORT) 'INT 256 32 "" "'O'" #f #f #f)
d573 1
a573 1
	 8 1 "unsigned int" "'x'" (mode:lookup 'QI) #f #f)
d575 1
a575 1
	 16 2 "unsigned int" "'x'" (mode:lookup 'HI) #f #f)
d577 1
a577 1
	 32 4 "unsigned int" "'x'" (mode:lookup 'SI) #f #f)
d579 1
a579 1
	 64 8 "" "'D'" (mode:lookup 'DI) #f #f)
d583 1
a583 1
	 32 4 "" "'f'" #f #f #f)
d585 1
a585 1
	 64 8 "" "'f'" #f #f #f)
d587 1
a587 1
	 96 12 "" "'F'" #f #f #f)
d589 1
a589 1
	 128 16 "" "'F'" #f #f #f)
d597 3
a599 1
    (dfm 'INT "portable int" '() 'INT 32 4 "int" "'x'"
d601 1
a601 1
    (dfm 'UINT "portable unsigned int" '() 'UINT 32 4 "unsigned int" "'x'"
d605 1
a605 1
    (dfm 'PTR "host pointer" '() 'RANDOM 0 0 "PTR" "'x'"
@


1.10
log
@	* xc16x.cpu (h-cr): New hardware.
	(muls): Comment out parts that won't compile, add fixme.
	(mulu, divl, divlu, jmpabs, jmpa-, jmprel, jbc, jnbs, callr): Ditto.
	(scxti, scxtmg, scxtm, bclear, bclr18, bset19, bitset, bmov): Ditto.
	(bmovn, band, bor, bxor, bcmp, bfldl, bfldh): Ditto.

	Rewrite rtl processing to require it to be "canonicalized" first,
	and write a full canonicalizer / expression checker.
	Remove all appearances of DFLT in canonical rtl.
	* attr.scm (/attr-eval atval owner): Call rtx-canonicalize,
	then rtx-simplify.
	* iformat.scm (ifmt-analyze) Use canonical semantics.
	* insn (<insn>): New member canonical-semantics.
	* mach.scm (<arch>): New member multi-insns-instantiated?.
	(/instantiate-multi-insns!): New function.
	(/canonicalize-insns!): New function.
	(arch-analyze-insns!): Canonicalize insn semantics before processing
	them.
	* mode.scm (/mode-set-word-params!): New function.
	(mode-void?): New function.
	(mode-compatible?): VOID is compatible with VOID.
	(/mode-word-sizes-defined?): New global.
	(mode-set-word-modes!): Use/set it.
	(mode-ensure-word-sizes-defined): Update.
	(mode-builtin!): New builtin "modes" SYM, INSN, MACH.
	Redo WI/UWI/AI/IAI handling.
	(op:new-mode): No longer accept DFLT.
	(<derived-operand> constructor): Ensure all fields are initialized.
	(<anyof-operand> constructor): Ditto.
	(/derived-parse-ifield-assertion): Delete arg `args'.
	All callers updated.
	* rtl-c.scm (<rtl-c-eval-state>): New member `for-insn?'.
	(rtl-c): Call rtx-canonicalize instead of rtx-compile.
	(rtl-c-expr, rtl-c++): Ditto.
	(/rtl-c-get): Use mode of operand, not containing expression.
	(rtl-c-set-quiet, rtl-c-set-trace): Remove DFLT support.
	(/rtx-use-sem-fn?): Don't check for (insn? owner), check
	estate-for-insn? instead.
	(s-unop): Use mode of expression, not first operand.
	(s-binop, s-binop-with-bit, s-shop, s-cmpop): Ditto.
	(s-sequence): Remove DFLT support.
	(ifield): Use mode of expression, not UINT.
	(pc): Comment out, unused.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	(set, set-quiet): Pass src to rtl-c-set-{trace,quiet} for expansion.
	* rtl-traverse.scm (/rtx-canon-debug?): New global.
	(/make-cstate): New function.
	(/cstate-context, /cstate-outer-expr): New functions.
	(/rtx-canon-error): New function.
	(/rtx-lookup-hw, /rtx-pick-mode, /rtx-pick-mode3, /rtx-pick-op-mode,
	/rtx-get-last-cond-case-rtx): New functions.
	(/rtx-canon-*): New functions.
	(/rtx-canner-table, /rtx-operand-canoners): New globals.
	(/rtx-make-canon-table, /rtx-special-expr-canoners): New functions.
	(/rtx-option, /rtx-option-list?): Rewrite.
	(rtx-munge-mode&options): Replaces /rtx-munge-mode&options.
	Rewritten, all callers updated.
	(/rtx-canon-expr, /rtx-canon): New functions.
	(rtx-canonicalize): Move here from rtl-xform.scm and rewrite.
	(rtx-canonicalize-stmt): New function.
	(tstate-make): Remove arg `set?'.  All callers updated.
	(tstate-new-set?): Delete.
	(/rtx-traverse-options, /rtx-traverse-*mode): Delete,
	moved to /rtx-canon-*.
	(/rtx-traverse-normal-operand): New function.
	(/rtx-traverse-rtx-list): Delete arg `mode', all callers updated.
	(/rtx-traverse-rtx, /rtx-traverse-setrtx,, /rtx-traverse-testrtx,
	/rtx-traverse-condrtx, /rtx-traverse-casertx, /rtx-traverse-locals,
	/rtx-traverse-iteration, /rtx-traverse-env, /rtx-traverse-attrs):
	Ditto.
	(/rtx-traverse-symbol, /rtx-traverse-string, /rtx-traverse-number,
	/rtx-traverse-symornum, /rtx-traverse-object): Delete.
	(/rtx-make-traverser-table): Update.
	(/rtx-traverse-operands): Remove mode processing, now done during
	canonicalization.
	(/rtx-traverse-expr): Delete arg `mode', all callers updated.
	(/rtx-traverse): Ditto.
	(rtx-init-traverser-tables!): New function.
	* rtl-xform (/rtx-verify-no-dflt-modes-expr-fn): New function.
	(rtx-verify-no-dflt-modes): New function.
	(/rtx-simplify-expr-fn): Update, `arg' mode deleted.
	(rtx-simplify-insn): Use insn-canonical-semantics.
	(rtx-canonicalize): Moved to rtl-traverse.scm.
	(/compile-expr-fn, rtx-compile): Delete.
	(/rtx-trim-rtx-list): New function.
	(/rtx-trim-for-doc): Handle set, if.
	* rtl.scm (<rtx-func>): New members result-mode, matchexpr-index.
	(/rtx-valid-mode-types): Update.
	(/rtx-valid-matches): Update.
	(/rtx-find-matchexpr-index): New function.
	(rtx-lookup): Require rtx-kind to be the rtx name.
	(def-rtx-node): New arg result-mode, all callers updated.
	(def-rtx-syntax-node, def-rtx-operand-node): Ditto.
	(rtx-lazy-sem-mode): Delete.
	(/rtx-closure-make): New arg `mode', all callers updated.
	(rtx-make-ifield, rtx-make-operand, rtx-make-local): Ditto.
	(rtx-operand-obj): Rewrite.
	(rtx-make-xop): New functions.
	(/hw): Renamed from `hw', all callers updated.
	Use the correct mode instead of DFLT for the index.
	(rtl-builtin!): Call rtx-init-traversal-tables!.
	(rtl-finish!): Update.
	* rtx-funcs.scm (all rtx functions): New parameter: result-mode.
	Update mode arg-type.
	(pc): Comment out.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	* sem-frags.scm (/frag-hash-compute!): Update, mode arg deleted.
	(/frag-cost-compute!): Ditto.
	* semantics.scm (/build-operand!): Delete args op-name, op.
	New arg op-expr.  All callers updated.
	(/build-mem-operand!): Remove DFLT support.
	(semantic-compile): Update process-expr!, mode arg deleted.
	* sid-cpu.scm (gen-semantic-code): Specify #:for-insn? in
	rtl-c++ calls.
	(/gen-sem-case, /gen-sfrag-code): Ditto.
	* sid.scm (/op-gen-set-trace1): Renamed from /op-gen-set-trace.
	(/op-gen-set-trace): New function.  If not doing profiling,
	call /op-gen-set-quiet.
	* sim-cpu.scm (gen-semantic-code): Specify #:for-insn? in rtl-c calls.
	* utils-gen.scm (/gen-ifld-extract-base): Update call to rtl-c.
	(/gen-ifld-extract-beyond, gen-multi-ifld-extract): Ditto.
	* utils.scm (find-first-index): New function.
	* doc/rtl.texi: Delete docs for `attr'.  Add `int-attr'.
@
text
@d86 1
a86 5
  (elm-xset! dst 'bits (elm-xget src 'bits))
  (elm-xset! dst 'bytes (elm-xget src 'bytes))
  (elm-xset! dst 'non-mode-c-type (elm-xget src 'non-mode-c-type))
  (elm-xset! dst 'printf-type (elm-xget src 'printf-type))
  (elm-xset! dst 'sem-mode (elm-xget src 'sem-mode))
@


1.9
log
@	Clean up pass of mode handling.
	Make use of mode name vs <mode> object more consistent and clear.
	* hardware.scm (/keyword-read): Default mode to the mode name,
	not the <mode> object.
	(/hw-parse-indices): Parse mode name and pass mode object to
	<hw-asm> constructor.
	(/hw-parse-values): Ditto.
	(<hw-register> parse!): Pass mode name to /hw-parse-indices
	and /hw-parse-values.
	(<hw-memory> parse!): Ditto.
	(<hw-address> parse!): Ditto.
	* mode.scm (/mode-table): New global, replaces mode-list.
	Modes stored in hashtable instead of list.
	(/mode-class-table): New global.
	(mode-list-non-alias-values): Update.
	(mode:eq?, mode-compatible?, mode:add!): Update.
	(mode:lookup): Restrict arg to the mode's name.  All callers updated.
	(mode-maybe-lookup): New function.
	(mode-real-name): Restrict arg to a <mode> object.  All callers updated.
	(mode-real-mode, mode-sem-mode, mode-bigger?): Ditto.
	(mode-find, mode-set-word-modes!): Update
	(mode-ensure-word-sizes-defined): Update.
	(/sort-mode-classes!): New function.
	(mode-builtin!): Update.  Sort mode classes here.
	(mode-finish!): Sort mode classes here too.
	* rtl-c.scm (/rtl-c-get): Restrict mode arg to a <mode> object.
	All callers updated.
	(rtl-c-set-quiet): Allow mode to be name of object.
	(rtl-c-set-trace): Ditto.
	* rtl-traverse.scm (rtl-eval-with-estate): Restrict mode arg to
	<mode> object.  All callers updated.
	* rtl.scm (rtx-sem-mode): Restrict arg to <mode> object.
	(rtx-lazy-sem-mode): Ditto.
	(<rtx-temp> make!): Assert mode arg is a <mode> object.
	(rtx-env-make): Allow var-list modes to be name or object.
	* sem-frags.scm (/frag-expr-assq-locals): New function.
	(/frag-compute-locals!): Call it.
	(/sfrag-create-cse-mapping): Renamed from sfrag-create-cse-mapping.
	All callers updated.
	* semantics.scm (/build-mem-operand!): Handle mode aliases.
@
text
@d81 13
d172 1
a172 1
; Return a boolean indicating if MODE has an integral mode class.
d179 1
a179 1
; Return a boolean indicating if MODE has a floating point mode class.
d183 1
a183 1
; Return a boolean indicating if MODE has a numeric mode class.
d187 6
d197 4
a200 3
; samesize: modes must be both float or both integer (int or uint) and have
;           same size
; sameclass: modes must be both float or both integer (int or uint)
d216 2
d222 1
d435 3
d451 1
a451 2
    (if (!= current-word-bitsize 0)
	; word size already set
d464 4
a467 8
	  (set! WI word-mode)
	  (set! UWI uword-mode)
	  (set! AI uword-mode)
	  (set! IAI uword-mode)
	  (hashq-set! /mode-table 'WI word-mode)
	  (hashq-set! /mode-table 'UWI uword-mode)
	  (hashq-set! /mode-table 'AI uword-mode)
	  (hashq-set! /mode-table 'IAI uword-mode)
d470 2
d494 1
d497 1
a497 1
  (if (eq? (obj:name WI) 'VOID)
d531 1
d561 1
a565 1
    ; ??? Not yet used everywhere it should be.
d568 9
d630 11
a640 10
  ; While setting the real values of WI/UWI/AI/IAI is defered to
  ; mode-set-word-modes!, create entries in the table.
  (set! WI VOID)
  (set! UWI VOID)
  (set! AI VOID)
  (set! IAI VOID)
  (mode:add! 'WI VOID)
  (mode:add! 'UWI VOID)
  (mode:add! 'AI VOID)
  (mode:add! 'IAI VOID)
@


1.8
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d107 2
a108 1
; List of all modes.
d110 2
a111 6
(define mode-list nil)

; Return list of mode objects.
; Hides the fact that its stored as an alist from caller.

(define (mode-list-values) (map cdr mode-list))
d116 6
a121 3
  (map cdr
       (find (lambda (m) (eq? (car m) (obj:name (cdr m))))
	     mode-list))
d137 1
d140 2
a141 2
  (let ((mode1-name (mode-real-name mode1))
	(mode2-name (mode-real-name mode2)))
d184 2
a185 2
  (let ((m1 (mode:lookup mode1))
	(m2 (mode:lookup mode2)))
d206 1
a206 1
; Add MODE named NAME to the list of recognized modes.
d215 12
a226 5
  (let ((entry (assq name mode-list)))
    (if entry
	(set-cdr! entry mode)
	(set! mode-list (acons name mode mode-list)))
    mode)
d269 16
a284 7
(define (mode:lookup x)
  (if (mode? x)
      x
      (let ((result (assq x mode-list)))
	(if result
	    (cdr result)
	    #f)))
d291 1
a291 2
       ; FIXME: Time to make `mode-list' a hash table.
       (->bool (assq x mode-list)))
d294 1
a294 1
; Return the name of the real mode of M.
d298 2
a299 2
(define (mode-real-name m)
  (obj:name (mode:lookup m))
d302 1
a302 1
; Return the real mode of M.
d306 5
a310 2
(define (mode-real-mode m)
  (mode:lookup (mode-real-name m))
d314 1
d322 2
a323 3
(define (mode-sem-mode m)
  (let* ((m1 (mode:lookup m))
	 (sm (mode:sem-mode m1)))
d326 1
a326 1
	(mode-real-mode m1)))
d329 2
a330 1
; Return #t if mode M1-NAME is bigger than mode M2-NAME.
d332 3
a334 3
(define (mode-bigger? m1-name m2-name)
  (> (mode:bits (mode:lookup m1-name))
     (mode:bits (mode:lookup m2-name)))
d341 3
a343 4
  (let ((modes (find (lambda (mode)
		       (and (eq? (mode:class (cdr mode)) class)
			    (not (mode:host? (cdr mode)))))
		     mode-list)))
d348 1
a348 1
	    ((<= bits (mode:bits (cdar modes))) (cdar modes))
d443 4
a446 4
	  (assq-set! mode-list 'WI word-mode)
	  (assq-set! mode-list 'UWI uword-mode)
	  (assq-set! mode-list 'AI uword-mode)
	  (assq-set! mode-list 'IAI uword-mode)
d473 1
a473 1
  (if (eq? (mode-real-name WI) 'VOID)
d491 14
d526 7
a532 1
  (set! mode-list nil)
d597 13
a609 8
  ; mode-set-word-modes!, create entries in the list.
  (set! WI (mode:add! 'WI (mode:lookup 'VOID)))
  (set! UWI (mode:add! 'UWI (mode:lookup 'VOID)))
  (set! AI (mode:add! 'AI (mode:lookup 'VOID)))
  (set! IAI (mode:add! 'IAI (mode:lookup 'VOID)))

  ; Keep the fields sorted for mode-find.
  (set! mode-list (reverse mode-list))
d615 4
@


1.7
log
@	Clean up cpu file parsing, pass context consistently instead of the
	old "errtxt" argument.
	NOTE: ACU == "All Callers Updated".
	* attr.scm (-parse-simple-attribute): Renamed from
	parse-simple-attribute, ACU.
	(-attr-parse): Change errtxt argument to context, ACU.
	(-attr-read): Ditto.
	(atlist-parse): Ditto.  Put context arg first.
	(attr-parse): Use parse-error instead of context-error.
	* enum.scm (parse-enum-vals): Change errtxt argument to context, ACU.
	(-enum-parse-prefix, -enum-parse, -enum-read): Ditto.
	* hardware.scm (-keyword-parse): Renamed from keyword-parse.
	`context' arg is now a <context> object.  ACU.
	(-keyword-read): `context' arg is now a <context> object.  ACU.
	(-hw-parse-indices): Change errtxt argument to context, ACU.
	(-hw-parse-values, -hw-parse-handlers): Ditto.
	(-hw-parse-getter, -hw-parse-setter, -hw-parse, -hw-read): Ditto.
	(-hw-validate-layout, -hw-create-getter-from-layout,
	-hw-create-setter-from-layout): Ditto.
	(<hw-register>:parse!, <hw-pc>:parse!): Ditto.
	(<hw-memory>:parse!, <hw-immediate>:parse!): Ditto.
	(<hw-address>:parse!): Ditto.
	* ifield.scm (-ifield-parse, ifield-read): Ditto.
	(-ifld-parse-follows, -ifld-parse-encode-decode): Ditto.
	(-ifld-parse-encode, -ifld-parse-decode): Ditto.
	(-multi-ifield-parse, -multi-ifield-read): Ditto.
	* insn.scm (-insn-parse, -insn-read): Ditto.
	(parse-syntax): Ditto.  Put context arg first.
	(-parse-insn-format-symbol): Change errtxt argument to context, ACU.
	(-parse-insn-format-ifield-spec, -parse-insn-format-list): Ditto.
	(-parse-insn-format): Ditto.
	* mach.scm (-arch-parse-alignment, -arch-parse-machs): Ditto.
	(-arch-parse-isas): Ditto.
	(-isa-read): Add context arg, ACU.
	(-cpu-parse, -cpu-read, -mach-read): Ditto.
	* minsn.scm (-minsn-parse-expansion): Change errtxt argument to
	context, ACU.
	(-minsn-parse, -minsn-read, -minsn-compute-iflds): Ditto.
	(minsn-make-alias): Ditto.
	* mode.scm (-mode-parse): Ditto.
	(parse-mode-name): Ditto.  Put context arg first.
	* model.scm (-prefetch-parse, -retire-parse, -pipeline-parse): Change
	errtxt argument to context, ACU.
	(-unit-parse, -model-parse, -model-read): Ditto.
	* operand.scm (-operand-parse-getter): Use parse-error instead of
	context-error.
	(-operand-parse-setter): Ditto.
	(-operand-parse): Change errtxt argument to context, ACU.
	(-operand-read, -derived-operand-parse, -derived-operand-read): Ditto.
	(-anyof-operand-parse, -anyof-operand-read): Ditto.
	* read.scm (reader-error): Delete.  Use parse-error instead.
	(parse-error): Change errtxt argument to context, ACU.  Split args
	argument into expr and maybe-help-text.
	(-reader-process-expanded-1!): Reorganize.
	* rtl.scm (-subr-read): Change errtxt argument to context, ACU.
	* types.scm (parse-type): Ditto.
	* utils-cgen.scm (single-location->simple-string): New function.
	(<context>): Replace members file,lineno with location.
	(make-prefix-context): Renamed from context-make-prefix, ACU.
	(make-current-context): New function.
	(context-append, context-append-name): New functions.
	(context-make-reader): Delete.
	(parse-name): Change errtxt argument to context, ACU.
	Put context arg first.
	(parse-comment): Ditto.
	(parse-number): Change errtxt argument to context, ACU.
	(arg-list-validate-name, arg-list-check-no-args,
	arg-list-symbol-arg): Ditto.

	* read.scm (-cmd-if): Don't assume test is a list.

	* html.scm (get-insn-properties): Delete errtxt, unused.
@
text
@d225 1
a225 1
(define (-mode-parse context name comment attrs class bits bytes
d248 1
a248 1
  (let ((m (-mode-parse (make-current-context "define-full-mode")
d391 1
a391 1
(define -mode-word-sizes-kind #f)
d408 1
a408 1
	(case -mode-word-sizes-kind
d438 1
a438 1
  (set! -mode-word-sizes-kind 'IDENTICAL)
d446 1
a446 1
  (set! -mode-word-sizes-kind 'BIGGEST)
d473 1
a473 1
  (set! -mode-word-sizes-kind 'IDENTICAL)
@


1.6
log
@	* modes.scm (TI,OI): New modes.
	* types.scm (parse-type): Improve error checking.  Don't hardwire
	mode names here.
	* utils.scm (non-negative-integer?): New function.
@
text
@d225 2
a226 2
(define (-mode-parse errtxt name comment attrs class bits bytes
		    non-mode-c-type printf-type sem-mode ptr-to host?)
d228 11
a238 9
  (let* ((name (parse-name name errtxt))
	 (errtxt (stringsym-append errtxt " " name))
	 (result (make <mode>
		       name
		       (parse-comment comment errtxt)
		       (atlist-parse attrs "mode" errtxt)
		       class bits bytes non-mode-c-type printf-type
		       sem-mode ptr-to host?)))
    result)
d248 2
a249 1
  (let ((m (-mode-parse "define-full-mode" name comment attrs
d334 1
d337 1
a337 1
(define (parse-mode-name mode-name errtxt)
d339 2
a340 1
    (if (not m) (parse-error errtxt "not a valid mode" mode-name))
@


1.5
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d36 3
a38 1
		; %D - DI mode
d507 4
@


1.4
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
@


1.4.6.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2009 Red Hat, Inc.
@


1.3
log
@	Better handling of 64 bit and mixed 32/64 bit architectures.
	* hardware.scm (hw-update-word-modes!): New fn.
	* mach.scm (define-cpu)): Call mode-set-word-modes!,
	hw-update-word-modes!.
	(state-word-bitsize): Replace FIXME with requested check.
	(arch-analyze-insns!): Call mode-ensure-word-sizes-defined.
	* mode.scm (mode-find): Ignore INT,UINT.
	(-mode-word-sizes-kind): New global.
	(mode-set-word-modes!,mode-set-identical-word-bitsizes!,
	mode-set-biggest-word-bitsizes!,mode-ensure-word-sizes-defined): New fns.
	(mode-init!): Initialize -mode-word-sizes-kind.  Move initialization
	of mode-list to ...
	(mode-builtin!): ... here.  Initialize WI/UWI/AI/IAI to something
	unusable, correct values set later.
	(mode-finish!): Remove cruft.
	* html.scm (doc-init!): Call mode-set-biggest-word-bitsizes!.
	* opcodes.scm (opcodes-init!): Ditto.
	* rtx-funcs.scm (annul): Fix mode of pc.
	* cpu/ia64.cpu: Remove cruft that sets word modes.
	* cpu/xstormy16.cpu (define-cpu): Set word-bitsize.
@
text
@d79 1
a79 1
; Return C type to use for values of mode M.
d85 1
a85 1
	(obj:name m)))
d129 1
a129 1
  (gen-c-symbol (string-append "MODE_" (string-upcase (obj:name m))))
d227 1
a227 1
	 (errtxt (string-append errtxt " " name))
@


1.2
log
@	* mode.scm (mode-sem-mode): New fn.
	* operand.scm (op:new-mode): Update. mode-name.
	(op-natural-mode?) New fn.
	* rtl.scm (hw): Set hw-name,mode-name.
plus some comment tweaks
@
text
@d49 2
a50 2
		; is different than mips unsigned add) however for now it keeps
		; things simpler (and prevents being wildly dissimilar from
d206 1
a206 1
; NAME exists to allow aliases of modes [e.g. WI, UWI, AI].
d313 1
d316 3
a318 1
  (let ((modes (find (lambda (mode) (eq? (mode:class (cdr mode)) class))
d338 1
a338 1
; These have a variable number of bits (1-32).
d358 93
a460 11
; This is defined by the target.  We provide a default def'n.
(define WI #f)
(define UWI #f)

; An "address int".  This is recorded in addition to a "word int" because it
; is believed that some target will need it.  It also stays consistent with
; what BFD does.
; This can also be defined by the target.  We provide a default.
(define AI #f)
(define IAI #f)

d466 1
a466 1
  (set! mode-list nil)
d486 2
d546 9
a554 5
  ; To redefine these, use mode:add! again.
  (set! WI (mode:add! 'WI (mode:lookup 'SI)))
  (set! UWI (mode:add! 'UWI (mode:lookup 'USI)))
  (set! AI (mode:add! 'AI (mode:lookup 'USI)))
  (set! IAI (mode:add! 'IAI (mode:lookup 'USI)))
a559 17
  ; Keep the fields sorted for mode-find.
  (set! mode-list (reverse mode-list))

  (if #f
  ; ???: Something like this would be nice if it was timed appropriately
  ; redefine WI/UWI/AI/IAI for this target
      (case (cpu-word-bitsize (current-cpu))
	((32) (begin
		(display "Recognized 32-bit cpu.\n")))
	((64) (begin
		(display "Recognized 64-bit cpu.\n")
		(set! WI (mode:add! 'WI (mode:lookup 'DI)))
		(set! UWI (mode:add! 'UWI (mode:lookup 'UDI)))
		(set! AI (mode:add! 'AI (mode:lookup 'UDI)))
		(set! IAI (mode:add! 'IAI (mode:lookup 'UDI)))))
	(else (error "Unknown word-bitsize for WI/UWI/AI/IAI mode!"))))

@


1.1
log
@Initial revision
@
text
@d289 16
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
