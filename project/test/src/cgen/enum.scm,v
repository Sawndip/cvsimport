head	1.14;
access;
symbols
	sid-snapshot-20180601:1.14
	cgen-snapshot-20180601:1.14
	sid-snapshot-20180501:1.14
	cgen-snapshot-20180501:1.14
	sid-snapshot-20180401:1.14
	cgen-snapshot-20180401:1.14
	sid-snapshot-20180301:1.14
	cgen-snapshot-20180301:1.14
	sid-snapshot-20180201:1.14
	cgen-snapshot-20180201:1.14
	sid-snapshot-20180101:1.14
	cgen-snapshot-20180101:1.14
	sid-snapshot-20171201:1.14
	cgen-snapshot-20171201:1.14
	sid-snapshot-20171101:1.14
	cgen-snapshot-20171101:1.14
	sid-snapshot-20171001:1.14
	cgen-snapshot-20171001:1.14
	sid-snapshot-20170901:1.14
	cgen-snapshot-20170901:1.14
	sid-snapshot-20170801:1.14
	cgen-snapshot-20170801:1.14
	sid-snapshot-20170701:1.14
	cgen-snapshot-20170701:1.14
	sid-snapshot-20170601:1.14
	cgen-snapshot-20170601:1.14
	sid-snapshot-20170501:1.14
	cgen-snapshot-20170501:1.14
	sid-snapshot-20170401:1.14
	cgen-snapshot-20170401:1.14
	sid-snapshot-20170301:1.14
	cgen-snapshot-20170301:1.14
	sid-snapshot-20170201:1.14
	cgen-snapshot-20170201:1.14
	sid-snapshot-20170101:1.14
	cgen-snapshot-20170101:1.14
	sid-snapshot-20161201:1.14
	cgen-snapshot-20161201:1.14
	sid-snapshot-20161101:1.14
	cgen-snapshot-20161101:1.14
	sid-snapshot-20160901:1.14
	cgen-snapshot-20160901:1.14
	sid-snapshot-20160801:1.14
	cgen-snapshot-20160801:1.14
	sid-snapshot-20160701:1.14
	cgen-snapshot-20160701:1.14
	sid-snapshot-20160601:1.14
	cgen-snapshot-20160601:1.14
	sid-snapshot-20160501:1.14
	cgen-snapshot-20160501:1.14
	sid-snapshot-20160401:1.14
	cgen-snapshot-20160401:1.14
	sid-snapshot-20160301:1.13
	cgen-snapshot-20160301:1.13
	sid-snapshot-20160201:1.13
	cgen-snapshot-20160201:1.13
	sid-snapshot-20160101:1.13
	cgen-snapshot-20160101:1.13
	sid-snapshot-20151201:1.13
	cgen-snapshot-20151201:1.13
	sid-snapshot-20151101:1.13
	cgen-snapshot-20151101:1.13
	sid-snapshot-20151001:1.13
	cgen-snapshot-20151001:1.13
	sid-snapshot-20150901:1.13
	cgen-snapshot-20150901:1.13
	sid-snapshot-20150801:1.13
	cgen-snapshot-20150801:1.13
	sid-snapshot-20150701:1.13
	cgen-snapshot-20150701:1.13
	sid-snapshot-20150601:1.13
	cgen-snapshot-20150601:1.13
	sid-snapshot-20150501:1.13
	cgen-snapshot-20150501:1.13
	sid-snapshot-20150401:1.13
	cgen-snapshot-20150401:1.13
	sid-snapshot-20150301:1.13
	cgen-snapshot-20150301:1.13
	sid-snapshot-20150201:1.13
	cgen-snapshot-20150201:1.13
	sid-snapshot-20150101:1.13
	cgen-snapshot-20150101:1.13
	sid-snapshot-20141201:1.13
	cgen-snapshot-20141201:1.13
	sid-snapshot-20141101:1.13
	cgen-snapshot-20141101:1.13
	sid-snapshot-20141001:1.13
	cgen-snapshot-20141001:1.13
	sid-snapshot-20140901:1.13
	cgen-snapshot-20140901:1.13
	sid-snapshot-20140801:1.13
	cgen-snapshot-20140801:1.13
	sid-snapshot-20140701:1.13
	cgen-snapshot-20140701:1.13
	sid-snapshot-20140601:1.13
	cgen-snapshot-20140601:1.13
	sid-snapshot-20140501:1.13
	cgen-snapshot-20140501:1.13
	sid-snapshot-20140401:1.13
	cgen-snapshot-20140401:1.13
	sid-snapshot-20140301:1.13
	cgen-snapshot-20140301:1.13
	sid-snapshot-20140201:1.13
	cgen-snapshot-20140201:1.13
	sid-snapshot-20140101:1.13
	cgen-snapshot-20140101:1.13
	sid-snapshot-20131201:1.13
	cgen-snapshot-20131201:1.13
	sid-snapshot-20131101:1.13
	cgen-snapshot-20131101:1.13
	sid-snapshot-20131001:1.13
	cgen-snapshot-20131001:1.13
	sid-snapshot-20130901:1.13
	cgen-snapshot-20130901:1.13
	sid-snapshot-20130801:1.13
	cgen-snapshot-20130801:1.13
	sid-snapshot-20130701:1.13
	cgen-snapshot-20130701:1.13
	sid-snapshot-20130601:1.13
	cgen-snapshot-20130601:1.13
	sid-snapshot-20130501:1.13
	cgen-snapshot-20130501:1.13
	sid-snapshot-20130401:1.13
	cgen-snapshot-20130401:1.13
	sid-snapshot-20130301:1.13
	cgen-snapshot-20130301:1.13
	sid-snapshot-20130201:1.13
	cgen-snapshot-20130201:1.13
	sid-snapshot-20130101:1.13
	cgen-snapshot-20130101:1.13
	sid-snapshot-20121201:1.13
	cgen-snapshot-20121201:1.13
	sid-snapshot-20121101:1.13
	cgen-snapshot-20121101:1.13
	sid-snapshot-20121001:1.13
	cgen-snapshot-20121001:1.13
	sid-snapshot-20120901:1.13
	cgen-snapshot-20120901:1.13
	sid-snapshot-20120801:1.13
	cgen-snapshot-20120801:1.13
	sid-snapshot-20120701:1.13
	cgen-snapshot-20120701:1.13
	sid-snapshot-20120601:1.13
	cgen-snapshot-20120601:1.13
	sid-snapshot-20120501:1.13
	cgen-snapshot-20120501:1.13
	sid-snapshot-20120401:1.13
	cgen-snapshot-20120401:1.13
	sid-snapshot-20120301:1.13
	cgen-snapshot-20120301:1.13
	sid-snapshot-20120201:1.13
	cgen-snapshot-20120201:1.13
	sid-snapshot-20120101:1.13
	cgen-snapshot-20120101:1.13
	sid-snapshot-20111201:1.13
	cgen-snapshot-20111201:1.13
	sid-snapshot-20111101:1.13
	cgen-snapshot-20111101:1.13
	sid-snapshot-20111001:1.13
	cgen-snapshot-20111001:1.13
	sid-snapshot-20110901:1.13
	cgen-snapshot-20110901:1.13
	sid-snapshot-20110801:1.13
	cgen-snapshot-20110801:1.13
	sid-snapshot-20110701:1.13
	cgen-snapshot-20110701:1.13
	sid-snapshot-20110601:1.13
	cgen-snapshot-20110601:1.13
	sid-snapshot-20110501:1.13
	cgen-snapshot-20110501:1.13
	sid-snapshot-20110401:1.13
	cgen-snapshot-20110401:1.13
	sid-snapshot-20110301:1.13
	cgen-snapshot-20110301:1.13
	sid-snapshot-20110201:1.13
	cgen-snapshot-20110201:1.13
	sid-snapshot-20110101:1.13
	cgen-snapshot-20110101:1.13
	sid-snapshot-20101201:1.13
	cgen-snapshot-20101201:1.13
	sid-snapshot-20101101:1.13
	cgen-snapshot-20101101:1.13
	sid-snapshot-20101001:1.13
	cgen-snapshot-20101001:1.13
	sid-snapshot-20100901:1.13
	cgen-snapshot-20100901:1.13
	sid-snapshot-20100801:1.13
	cgen-snapshot-20100801:1.13
	sid-snapshot-20100701:1.13
	cgen-snapshot-20100701:1.13
	sid-snapshot-20100601:1.13
	cgen-snapshot-20100601:1.13
	sid-snapshot-20100501:1.13
	cgen-snapshot-20100501:1.13
	sid-snapshot-20100401:1.13
	cgen-snapshot-20100401:1.13
	sid-snapshot-20100301:1.13
	cgen-snapshot-20100301:1.13
	sid-snapshot-20100201:1.12
	cgen-snapshot-20100201:1.12
	sid-snapshot-20100101:1.11
	cgen-snapshot-20100101:1.11
	sid-snapshot-20091201:1.11
	cgen-snapshot-20091201:1.11
	sid-snapshot-20091101:1.9
	cgen-snapshot-20091101:1.9
	sid-snapshot-20091001:1.9
	cgen-snapshot-20091001:1.9
	arc-sim-20090309:1.4
	sid-snapshot-20090901:1.7
	cgen-snapshot-20090901:1.7
	sid-snapshot-20090801:1.6
	cgen-snapshot-20090801:1.6
	sid-snapshot-20090701:1.6
	cgen-snapshot-20090701:1.6
	dje-cgen-play1-branch:1.6.0.2
	dje-cgen-play1-branchpoint:1.6
	cgen-1_1-branch:1.5.0.2
	cgen-1_1-branchpoint:1.5
	sid-snapshot-20090601:1.4
	cgen-snapshot-20090601:1.4
	sid-snapshot-20090501:1.4
	cgen-snapshot-20090501:1.4
	sid-snapshot-20090401:1.4
	cgen-snapshot-20090401:1.4
	arc-insight_6_8-branch:1.4.0.4
	arc-insight_6_8-branchpoint:1.4
	sid-snapshot-20090301:1.4
	cgen-snapshot-20090301:1.4
	sid-snapshot-20090201:1.4
	cgen-snapshot-20090201:1.4
	sid-snapshot-20090101:1.4
	cgen-snapshot-20090101:1.4
	sid-snapshot-20081201:1.4
	cgen-snapshot-20081201:1.4
	sid-snapshot-20081101:1.4
	cgen-snapshot-20081101:1.4
	sid-snapshot-20081001:1.4
	cgen-snapshot-20081001:1.4
	sid-snapshot-20080901:1.4
	cgen-snapshot-20080901:1.4
	sid-snapshot-20080801:1.4
	cgen-snapshot-20080801:1.4
	sid-snapshot-20080701:1.4
	cgen-snapshot-20080701:1.4
	sid-snapshot-20080601:1.4
	cgen-snapshot-20080601:1.4
	sid-snapshot-20080501:1.4
	cgen-snapshot-20080501:1.4
	sid-snapshot-20080403:1.4
	sid-snapshot-20080401:1.4
	cgen-snapshot-20080401:1.4
	sid-snapshot-20080301:1.4
	cgen-snapshot-20080301:1.4
	sid-snapshot-20080201:1.4
	cgen-snapshot-20080201:1.4
	sid-snapshot-20080101:1.4
	cgen-snapshot-20080101:1.4
	sid-snapshot-20071201:1.4
	cgen-snapshot-20071201:1.4
	sid-snapshot-20071101:1.4
	cgen-snapshot-20071101:1.4
	sid-snapshot-20071001:1.4
	cgen-snapshot-20071001:1.4
	msnyder-fork-checkpoint-branch:1.4.0.2
	msnyder-fork-checkpoint-branchpoint:1.4
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	cygnus_cvs_20020108_pre:1.2
	cgen-1-1-branch:1.2.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.14
date	2016.03.02.12.23.31;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2010.02.13.03.39.15;	author devans;	state Exp;
branches;
next	1.12;

1.12
date	2010.01.25.03.50.43;	author devans;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.05.16.55.33;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.03.16.24.01;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.28.02.40.49;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2009.09.07.22.17.33;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2009.08.12.22.33.37;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.14.17.09.56;	author devans;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2003.07.16.05.35.47;	author devans;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.10.21.22.02;	author devans;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.15.15.01.20;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.5.2.1
date	2009.06.24.14.57.45;	author devans;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Make large enum constants hex

	* enum.scm (gen-enum-decl): Emit large numbers as hex.  Tidy
	start-sanitize.  Upcase just the identifiers.
@
text
@; Enums.
; Copyright (C) 2000, 2009, 2010 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.

; Enums having attribute PREFIX have their symbols prepended with
; the enum class' name + "_" in generated code.  FIXME: deprecated
;
; Member PREFIX is prepended to the symbol names when the object is defined.
;
; Enum values are looked up with `enum-lookup-val'.  The value to search for
; must already have PREFIX prepended.
;
; Enums always have mode INT.

(define <enum>
  (class-make '<enum>
	      '(<ident>)
	      '(prefix vals)
	      nil)
)

; FIXME: this make! method is required by <insn-enum> for some reason.

(method-make!
 <enum> 'make!
 (lambda (self name comment attrs prefix vals)
   (elm-set! self 'name name)
   (elm-set! self 'comment comment)
   (elm-set! self 'attrs attrs)
   (elm-set! self 'prefix prefix)
   (elm-set! self 'vals vals)
   self)
)

(define enum-prefix (elm-make-getter <enum> 'prefix))

(method-make! <enum> 'enum-values (lambda (self) (elm-get self 'vals)))

; Parse a list of enum name/value entries.
; PREFIX is prepended to each name.
; Elements are any of: symbol, (symbol), (symbol value)
; (symbol - attrs), (symbol value attrs), (symbol - attrs comment),
; (symbol value attrs comment).
; The - or #f means "use the next value".
; SYMBOL may be - which means "skip this value".
; The result is the same list, except values are filled in where missing,
; and each symbol is prepended with `prefix'.

(define (parse-enum-vals context prefix vals)
  ; Scan the value list, building up RESULT as we go.
  ; Each element's value is 1+ the previous, unless there's an explicit value.
  (let loop ((result nil) (last -1) (remaining vals))
    (if (null? remaining)
	(reverse! result)
	(let
	    ; Compute the numeric value the next entry will have.
	    ((val (if (and (pair? (car remaining))
			   (not (null? (cdar remaining))))
		      (if (eq? '- (cadar remaining))
			  (+ last 1)
			  (cadar remaining))
		      (+ last 1))))
	  (if (eq? (car remaining) '-)
	      (loop result val (cdr remaining))
	      (let ((name (symbolstr-append prefix
					    (if (pair? (car remaining))
						(caar remaining)
						(car remaining))))
		    (attrs (if (and (pair? (car remaining))
				    (pair? (cdar remaining))
				    (pair? (cddar remaining)))
			       (caddar remaining)
			       nil))
		    (comment (if (and (pair? (car remaining))
				      (pair? (cdar remaining))
				      (pair? (cddar remaining))
				      (pair? (cdddar remaining)))
				 (car (cdddar remaining))
				 "")))
		(loop (cons (list name val attrs comment) result)
		      val
		      (cdr remaining)))))))
)

; Accessors for the various elements of an enum val.

(define (enum-val-name ev) (list-ref ev 0))
(define (enum-val-value ev) (list-ref ev 1))
(define (enum-val-attrs ev) (list-ref ev 2))
(define (enum-val-comment ev) (list-ref ev 3))

; Convert the names in the result of parse-enum-vals to uppercase.

(define (enum-vals-upcase vals)
  (map (lambda (elm)
	 (cons (symbol-upcase (car elm)) (cdr elm)))
       vals)
)

; Parse an enum definition.

; Utility of /enum-parse to parse the prefix.

(define (/enum-parse-prefix context prefix)
  (if (symbol? prefix)
      (set! prefix (symbol->string prefix)))

  (if (not (string? prefix))
      (parse-error context "prefix is not a string" prefix))

  ; Prefix must not contain lowercase chars (enforced style rule, sue me).
  (if (any-true? (map char-lower-case? (string->list prefix)))
      (parse-error context "prefix must be uppercase" prefix))

  prefix
)

; This is the main routine for building an enum object from a
; description in the .cpu file.
; All arguments are in raw (non-evaluated) form.

(define (/enum-parse context name comment attrs prefix vals)
  (logit 2 "Processing enum " name " ...\n")

  ;; Pick out name first to augment the error context.
  (let* ((name (parse-name context name))
	 (context (context-append-name context name)))

    (make <enum>
	  name
	  (parse-comment context comment)
	  (atlist-parse context attrs "enum")
	  (/enum-parse-prefix context prefix)
	  (parse-enum-vals context prefix vals)))
)

;; Read an enum description
;; This is the main routine for analyzing enums in the .cpu file.
;; CONTEXT is a <context> object for error messages.
;; ARG-LIST is an associative list of field name and field value.
;; /enum-parse is invoked to create the `enum' object.
;;
;; FIXME: Change (values ((foo 42) (bar 43))) to (values (foo 42) (bar 43)).

(define (/enum-read context . arg-list)
  (let (
	(name #f)
	(comment "")
	(attrs nil)
	(prefix "")
	(values nil)
	)

    ; Loop over each element in ARG-LIST, recording what's found.
    (let loop ((arg-list arg-list))
      (if (null? arg-list)
	  nil
	  (let ((arg (car arg-list))
		(elm-name (caar arg-list)))
	    (case elm-name
	      ((name) (set! name (cadr arg)))
	      ((comment) (set! comment (cadr arg)))
	      ((attrs) (set! attrs (cdr arg)))
	      ((prefix) (set! prefix (cadr arg)))
	      ((values) (set! values (cadr arg)))
	      (else (parse-error context "invalid enum arg" arg)))
	    (loop (cdr arg-list)))))

    ; Now that we've identified the elements, build the object.
    (/enum-parse context name comment attrs prefix values))
)

; Define an enum object, name/value pair list version.

(define define-enum
  (lambda arg-list
    (let ((e (apply /enum-read (cons (make-current-context "define-enum")
				     arg-list))))
      (current-enum-add! e)
      e))
)

; Define an enum object, all arguments specified.

(define (define-full-enum name comment attrs prefix vals)
  (let ((e (/enum-parse (make-current-context "define-full-enum")
			name comment attrs prefix vals)))
    (current-enum-add! e)
    e)
)

; Lookup SYM in all recorded enums.
; The result is (value . enum-obj) or #f if not found.

(define (enum-lookup-val name)
  (let loop ((elist (current-enum-list)))
    (if (null? elist)
	#f
	(let ((e (assq name (send (car elist) 'enum-values))))
	  ;(display e) (newline)
	  (if e
	      (begin
		; sanity check, ensure the enum has a value
		(if (null? (cdr e)) (error "enum-lookup-val: enum missing value: " (car e)))
		(cons (cadr e) (car elist)))
	      (loop (cdr elist)))
	  )
	)
    )
)

; Enums support code.

; Return #t if VALS is a sequential list of enum values.
; VALS is a list of enums.  e.g. ((sym1) (sym2 3) (sym3 - attr1 (attr2 4)))
; FIXME: Doesn't handle gaps in specified values.
; e.g. (sym1 val1) sym2 (sym3 val3)

(define (enum-sequential? vals)
  (let loop ((last -1) (remaining vals))
    (if (null? remaining)
	#t
	(let ((val (if (and (pair? (car remaining))
			    (not (null? (cdar remaining))))
		       (cadar remaining)
		       (+ last 1))))
	  (if (eq? val '-)
	      (loop (+ last 1) (cdr remaining))
	      (if (not (= val (+ last 1)))
		  #f
		  (loop val (cdr remaining)))))))
)

; Return C code to declare enum SYM with values VALS.
; COMMENT is inserted in "/* Enum declaration for <...>.  */".
; PREFIX is added to each element of VALS (uppercased).
; All enum symbols are uppercase.
; If the list of vals is sequential beginning at 0, don't output them.
; This simplifies the output and is necessary for sanitized values where
; some values may be cut out.
; VALS may have '- for the value, signifying use the next value as in C.

(define (gen-enum-decl name comment prefix vals)
  (logit 2 "Generating enum decl for " name " ...\n")
  ; Build result up as a list and then flatten it into a string.
  ; We could just return a string-list but that seems like too much to ask
  ; of callers.
  (string-list->string
   (append!
    (string-list
     "/* Enum declaration for " comment ".  */\n"
     "typedef enum "
     (string-downcase (gen-c-symbol name))
     " {")
    (let loop ((n 0) ; `n' is used to track the number of entries per line only
	       (sequential? (enum-sequential? vals))
	       (vals vals)
	       (result (list "")))
      (if (null? vals)
	  result
	  (let* ((e (car vals))
		 (attrs (if (null? (cdr e)) nil (cddr e)))
		 (san-code (attr-value attrs 'sanitize #f))
		 (san? (and san-code (not (eq? san-code 'none)))))
	    (loop
	     (if san?
		 4 ; reset to beginning of line (but != 0)
		 (+ n 1))
	     sequential?
	     (cdr vals)
	     (append!
	      result
	      (string-list
	       (if (and san? include-sanitize-marker?)
		   ; split string to avoid removal
		   (string-append "\n/* start-"
				  "sanitize-"
				  san-code " */")
		   "")
	       (if (or san? (=? (remainder n 4) 0))
		   "\n "
		   "")
	       (if (= n 0)
		   " "
		   ", ")
	       (string-upcase (gen-c-symbol prefix))
	       (string-upcase (gen-c-symbol (car e)))
	       (if (or sequential?
		       (null? (cdr e))
		       (eq? '- (cadr e)))
		   ""
		   (string-append " = "
				  (if (number? (cadr e))
				      (if (>= (cadr e) #x80000000)
					  (string-append "0x"
						(number->string (cadr e) 16))
					  (number->string (cadr e)))
				      (string-upcase (cadr e)))))
	       (if (and san? include-sanitize-marker?)
		   ; split string to avoid removal
		   (string-append "\n/* end-"
				  "sanitize-" san-code " */")
		   "")))))))
    (string-list
     "\n} "
     (string-upcase (gen-c-symbol name))
     ";\n\n")
    ))
)

; Return a list of enum value definitions for gen-enum-decl.
; OBJ-LIST is a list of objects that support obj:name, obj-atlist.

(define (gen-obj-list-enums obj-list)
  (map (lambda (o)
	 (cons (obj:name o) (cons '- (atlist-attrs (obj-atlist o)))))
       obj-list)
)

; Return C code that declares[/defines] an enum.

(method-make!
 <enum> 'gen-decl
 (lambda (self)
   (gen-enum-decl (elm-get self 'name)
		  (elm-get self 'comment)
		  (if (has-attr? self 'PREFIX)
		      (string-append (elm-get self 'name) "_")
		      "")
		  (elm-get self 'vals)))
)

;; Return the C symbol of an enum value named VAL.
;; ENUM-OBJ is the <enum> object containing VAL.

(define (gen-enum-sym enum-obj val)
  (string-upcase
   (string-append (if (has-attr? enum-obj 'PREFIX)
		      (string-append (elm-xget enum-obj 'name) "_")
		      "")
		  (gen-c-symbol val)))
)

; Instruction code enums.
; These associate an enum with an instruction field so that the enum values
; can be used in instruction field lists.

(define <insn-enum> (class-make '<insn-enum> '(<enum>) '(fld) nil))

(method-make!
 <insn-enum> 'make!
 (lambda (self name comment attrs prefix fld vals)
   (send-next self '<insn-enum> 'make! name comment attrs prefix vals)
   (elm-set! self 'fld fld)
   self
   )
)

(define ienum:fld (elm-make-getter <insn-enum> 'fld))

; Same as enum-lookup-val except returned enum must be an insn-enum.

(define (ienum-lookup-val name)
  (let ((result (enum-lookup-val name)))
    (if (and result (eq? (object-class-name (cdr result)) '<insn-enum>))
	result
	#f))
)

; Define an insn enum, all arguments specified.

(define (define-full-insn-enum name comment attrs prefix fld vals)
  (let* ((context (make-current-context "define-full-insn-enum"))
	 (atlist-obj (atlist-parse context attrs "insn-enum"))
	 (isa-name-list (atlist-attr-value atlist-obj 'ISA #f))
	 (fld-obj (current-ifld-lookup fld isa-name-list)))

    (if (keep-isa-atlist? atlist-obj #f)
	(begin
	  (if (not fld-obj)
	      (parse-error context "unknown insn field" fld))
	  ; Create enum object and add it to the list of enums.
	  (let ((e (make <insn-enum>
		     (parse-name context name)
		     (parse-comment context comment)
		     atlist-obj
		     (/enum-parse-prefix context prefix)
		     fld-obj
		     (parse-enum-vals context prefix vals))))
	    (current-enum-add! e)
	    e))))
)

(define (enum-init!)

  (reader-add-command! 'define-enum
		       "\
Define an enum, name/value pair list version.
"
		       nil 'arg-list define-enum)
  (reader-add-command! 'define-full-enum
		       "\
Define an enum, all arguments specified.
"
		       nil '(name comment attrs prefix vals) define-full-enum)
  (reader-add-command! 'define-full-insn-enum
		       "\
Define an instruction opcode enum, all arguments specified.
"
		       nil '(name comment attrs prefix ifld vals)
		       define-full-insn-enum)

  *UNSPECIFIED*
)

(define (enum-builtin!)
  ;; Provide FPCONV-DEFAULT == 0 as an enum constant to use as the `how'
  ;; parameter to the floating point conversion functions.
  ;; ??? Add standard IEEE rounding modes?
  (define-enum '(name fpconv-kind)
    '(comment "builtin floating point conversion kinds")
    '(attrs VIRTUAL) ;; let app provide def'n instead of each cpu's desc.h
    '(prefix FPCONV-)
    '(values ((DEFAULT 0)
	      (TIES-TO-EVEN 1)
	      (TIES-TO-AWAY 2)
	      (TOWARD-ZERO 3)
	      (TOWARD-POSITIVE 4)
	      (TOWARD-NEGATIVE 5))))

  *UNSPECIFIED*
)

(define (enum-finish!)
  *UNSPECIFIED*
)
@


1.13
log
@update copyright year
@
text
@d275 8
a282 9
	       (if san?
		   (string-append "\n"
				  (if include-sanitize-marker?
				      ; split string to avoid removal
				      (string-append "/* start-"
						     "sanitize-"
						     san-code " */\n")
				      "")
				  " ")
d284 16
a299 19
	       (string-upcase
		(string-append
		 (if (and (not san?) (=? (remainder n 4) 0))
		     "\n "
		     "")
		 (if (= n 0)
		     " "
		     ", ")
		 (gen-c-symbol prefix)
		 (gen-c-symbol (car e))
		 (if (or sequential?
			 (null? (cdr e))
			 (eq? '- (cadr e)))
		     ""
		     (string-append " = "
				    (if (number? (cadr e))
					(number->string (cadr e))
					(cadr e))))
		 ))
@


1.12
log
@	* desc-cpu.scm (cgen-desc.h): Don't print virtual enums.
	* sid-cpu.scm (cgen-desc.h): Ditto.
	* enum.scm (enum-builtin!): New function.
	* read.scm (reader-install-builtin!): Call it.
	* rtl-c.scm (s-convop): Delete, replaced with ...
	(s-int-convop, s-float-convop): ... new fns.
	(ext, zext, trunc): Update.
	(fext, ftrunc, float, ufloat, fix, ufix): Update.
	* rtx-funcs.scm (fext, ftrunc, float, ufloat, fix, ufix): New parameter
	`how'.
	* cpu/mep-fmax.cpu (fcvtsw): Update.
	* cpu/sh.cpu (h-fsd, h-fmov): Update.
	* doc/rtl.texi (float-convop): Update.

	* frv.cpu (floating-point-conversion): Update call to fp conv op.
	(floating-point-dual-conversion, ne-floating-point-dual-conversion,
	conditional-floating-point-conversion, ne-floating-point-conversion,
	float-parallel-mul-add-double-semantics): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2009 Red Hat, Inc.
@


1.11
log
@	* utils.scm (reduce): Delete.

	* rtl-traverse.scm (/rtx-canon-rtx-enum): Tweak local name.

	* enum.scm (gen-enum-sym): Make consistent with gen-enum-decl
	regarding PREFIX attribute handling.

	* operand.scm (<hw-index>): Add enum to possible types, all uses
	updated.
	(hw-index-constant?, hw-index-constant-value): New functions.
	(make-enum-hw-index, hw-index-enum-name, hw-index-enum-value,
	hw-index-enum-obj): New functions.
	(/operand-parse): Handle enum indices.
	* intrinsics.scm (md-operand:fixed-register): Use hw-index-constant?,
	hw-index-constant-value.
	* rtl.scm (rtx-constant-value): Fix handling of enums.
	* rtx-funcs.scm (enum): Ditto.
	* sid.scm (<hardware-base> cxmake-get): Only ifield indices are
	currently supported here.
@
text
@d138 7
a144 5
; Read an enum description
; This is the main routine for analyzing enums in the .cpu file.
; CONTEXT is a <context> object for error messages.
; ARG-LIST is an associative list of field name and field value.
; /enum-parse is invoked to create the `enum' object.
d421 18
@


1.10
log
@	Specify isa(s) when doing ifield, operand, insn lookups.
	ACU = all callers updated.
	* attr.scm (/attr-eval): Call rtx-value instead of rtx-eval-with-estate.
	* enum.scm (define-full-insn-enum): Pass isa-name-list to
	current-ifld-lookup.
	* html.scm (get-insn-properties): Pass isa-name-list to
	current-op-lookup.
	* ifield.scm (/ifld-parse-follows): New arg isas, ACU.
	* insn.scm (/parse-insn-format-symbol): New arg isa-name-list, ACU.
	(/parse-insn-format-list, /parse-insn-iformat-iflds): Ditto.
	(/parse-insn-format, syntax-break-out): Ditto.
	* mach.scm (obj-filter-by-isa): New function.
	(current-ifld-lookup): New optional arg maybe-isa-name-list.
	(/ifld-already-defined?, /op-already-defined?): Simplify.
	(current-op-lookup): New optional arg maybe-isa-name-list.
	(current-insn-lookup): New arg isa-name-list, ACU.
	(/insn-already-defined?, /minsn-already-defined?): Simplify.
	(current-minsn-lookup): New arg isa-name-list, ACU.
	* minsn.scm (/minsn-compute-iflds): Pass isa-name-list to
	current-op-lookup.
	* opc-itab.scm (compute-syntax): New arg isa-name-list, ACU.
	(gen-syntax-entry): Ditto.
	* operand.scm (/operand-parse): Pass isa-name-list to
	current-ifld-lookup.
	(/derived-parse-encoding): New arg isa-name-list, ACU.
	(/derived-parse-ifield-assertion): Ditto.
	(/derived-operand-parse): Pass isa-name-list to current-op-lookup.
	(/anyof-parse-choice): Ditto.
	(anyof-satisfies-assertions?): Pass context to rtx-solve.
	(/anyof-merge-syntax): New arg container, ACU.
	(operand-builtin!): Add pc to all isas.
	* rtl-c.scm (estate-make-for-rtl-c): Delete arg extra-vars-alist, ACU.
	(estate-make-for-rtl-c++, rtl-c-expr-parsed): Ditto.
	(rtl-c-parsed, rtl-c++-parsed): Ditto.
	(rtl-c): New arg isa-name-list, ACU.
	(rtl-c-expr, rtl-c++): Ditto.
	(closure): New arg isa-name-list, ACU.
	* rtl-traverse.scm (/make-cstate): New arg isa-name-list, ACU.
	(/cstate-isas): New function.
	(/rtx-canon-symbol-list): New function.
	(/rtx-canon-env-stack): Renamed from /rtx-canon-env, ACU.
	updated.
	(/rtx-make-canon-table): Rename ENV to ENVSTACK, new entry SYMBOLLIST.
	(/rtx-canon-rtx-operand): Pass isa list to current-op-lookup.
	(/rtx-canon-rtx-ref, /rtx-canon): Ditto.
	(rtx-canonicalize): New arg isa-name-list, ACU.
	(rtx-canonicalize-stmt): Delete.
	(tstate-make): New arg isas, ACU.
	(tstate-isas, tstate--set-isas!): New functions.
	(tstate-env-stack): Renamed from tstate-env, ACU.
	(tstate-set-env-stack!): Renamed from tstate-set-env!, ACU.
	(tstate-make-closure): Renamed from tstate-new-env, new arg
	isa-name-list, ACU.
	(/rtx-traverse-env): Delete.
	(/rtx-make-traverser-table): Rename ENV to ENVSTACK, new entry
	SUMBOLLIST.
	(/rtx-traverse): Include conditional flag in dump output.
	Update isa,envstack for closures.  Pass isa list to current-op-lookup.
	(<eval-state>): New member isas.  Rename env to env-stack.
	(<eval-state> vmake!): Handle #:isas.  #:env renamed to #:env-stack.
	(<eval-state>): New getter/setter for isas.  Rename env getter/setter
	to env-stack.
	(estate-make-for-eval): Provide #:isas.
	(estate-make-closure): Renamed from estate-new-env.  New arg
	isa-name-list, ACU.
	* rtl-xform.scm (/rtx-simplify-expr-fn): Handle closures.
	(/rtx-trim-args): ENV renamed to ENVSTACK.  Ad ITERATION, SYMBOLLIST.
	(/rtx-trim-for-doc): Handle closures.
	* rtl.scm (/rtx-valid-types): Rename ENV to ENVSTACK.  Add ITERATION,
	SYMBOLLIST.
	(rtx-env-var-list): Delete.
	(rtx-env-make): Handle already-compiled environments.
	(rtx-var-alist-to-env): New function.
	(rtx-var-alist-to-closure-env-stack, rtx-make-env-stack): New functions.
	(rtx-env-stack-dump): Renamed from rtx-env-dump, ACU.
	(rtx-operand-obj): New arg isa-name-list, ACU.
	(rtx-closure-isas, rtx-closure-env-stack, rtx-closure-expr): New
	functions.
	* rtx-funcs.scm (closure): New arg isa-name-list, reorder args, ACU.
	* sem-frags.scm (<sfrag>): Delete member compiled-semantics.
	(/frag-compute-desired-frags): Minor simplification.
	(/frag-pick-best): Ditto.
	* sid-cpu.scm (gen-semantic-code): Require canonical rtl.
	(/gen-sfrag-code): Update.
	* sim-cpu.scm (gen-semantic-code): Require canonical rtl.
	* utils-cgen.scm (sanitize): New arg isa-name-list, ACU.
	* utils.scm (non-null-intersection?): New function.
@
text
@d7 3
a9 2
; the enum class' name.
; Member PREFIX is always prepended to the symbol names.
d12 1
a12 1
; has PREFIX prepended.
d235 1
a235 1
; PREFIX is added to each element of VALS.
d336 2
a337 1
; Return the C symbol of an enum value named VAL.
d340 5
a344 1
  (string-upcase (gen-c-symbol (string-append (enum-prefix enum-obj) val)))
@


1.9
log
@	* cos.scm (/class-table): New global.
	(/class-uid, /class-set-uid!): New functions.
	(/class-parent-name): Renamed from /class-parents.
	(/class-make!): Change parents arg to parent-name, all callers updated.
	Assign uid to class.
	(/class-lookup-uid): New function.
	(/class-parent-classes): Rewrite.
	(/class-mi?): Delete.
	(/class-desc-mi?, /class-desc-offset-case, /class-desc-offset-case):
	Delete.
	(/class-desc-offset, /class-desc-child, /class-desc-parents): Update.
	(/class-compute-class-desc, class-desc-dump): Update.
	(/object-make!): Update.
	(/object-make-with-values!): Delete arg class-desc, all callers
	updated.
	(/object-copy): Delete arg top?, all callers updated.
	(/object-specialize): Delete.
	(/object-elements, /object-top-class): Delete.
	(/object-class-name, /object-class-desc): Update.
	(/object-class-uid): New function.
	(/object-elm-get, /object-elm-set!, object?, /class-check-init!,
	class-make, /class-subclass? /class-lookup-element,
	Update.
	(/elm-delta, elm-list): Delete.
	(/elm-make-method-getter, elm-get, elm-xget): Update.
	(/elm-make-method-setter, elm-set!, elm-xset!): Update.
	(elm-make-getter, elm-make-setter): Update.
	(/method-lookup-next): Update.
	(send): Don't specialize class passed to method.
	(send-next): New arg class-name, all callers updated.
	(/class-parent, /class-parent-via-path, object-parent): Delete.
	(class-cons-parent!, class-append-parent!): Delete.
	(object-reset!): Init /class-table.
@
text
@d371 3
a373 2
	 (atlist (atlist-parse context attrs "insn-enum"))
	 (fld-obj (current-ifld-lookup fld)))
d375 1
a375 1
    (if (keep-isa-atlist? atlist #f)
d383 1
a383 1
		     atlist
@


1.8
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d350 1
a350 1
   (send (object-parent self <enum>) 'make! name comment attrs prefix vals)
@


1.7
log
@	Clean up cpu file parsing, pass context consistently instead of the
	old "errtxt" argument.
	NOTE: ACU == "All Callers Updated".
	* attr.scm (-parse-simple-attribute): Renamed from
	parse-simple-attribute, ACU.
	(-attr-parse): Change errtxt argument to context, ACU.
	(-attr-read): Ditto.
	(atlist-parse): Ditto.  Put context arg first.
	(attr-parse): Use parse-error instead of context-error.
	* enum.scm (parse-enum-vals): Change errtxt argument to context, ACU.
	(-enum-parse-prefix, -enum-parse, -enum-read): Ditto.
	* hardware.scm (-keyword-parse): Renamed from keyword-parse.
	`context' arg is now a <context> object.  ACU.
	(-keyword-read): `context' arg is now a <context> object.  ACU.
	(-hw-parse-indices): Change errtxt argument to context, ACU.
	(-hw-parse-values, -hw-parse-handlers): Ditto.
	(-hw-parse-getter, -hw-parse-setter, -hw-parse, -hw-read): Ditto.
	(-hw-validate-layout, -hw-create-getter-from-layout,
	-hw-create-setter-from-layout): Ditto.
	(<hw-register>:parse!, <hw-pc>:parse!): Ditto.
	(<hw-memory>:parse!, <hw-immediate>:parse!): Ditto.
	(<hw-address>:parse!): Ditto.
	* ifield.scm (-ifield-parse, ifield-read): Ditto.
	(-ifld-parse-follows, -ifld-parse-encode-decode): Ditto.
	(-ifld-parse-encode, -ifld-parse-decode): Ditto.
	(-multi-ifield-parse, -multi-ifield-read): Ditto.
	* insn.scm (-insn-parse, -insn-read): Ditto.
	(parse-syntax): Ditto.  Put context arg first.
	(-parse-insn-format-symbol): Change errtxt argument to context, ACU.
	(-parse-insn-format-ifield-spec, -parse-insn-format-list): Ditto.
	(-parse-insn-format): Ditto.
	* mach.scm (-arch-parse-alignment, -arch-parse-machs): Ditto.
	(-arch-parse-isas): Ditto.
	(-isa-read): Add context arg, ACU.
	(-cpu-parse, -cpu-read, -mach-read): Ditto.
	* minsn.scm (-minsn-parse-expansion): Change errtxt argument to
	context, ACU.
	(-minsn-parse, -minsn-read, -minsn-compute-iflds): Ditto.
	(minsn-make-alias): Ditto.
	* mode.scm (-mode-parse): Ditto.
	(parse-mode-name): Ditto.  Put context arg first.
	* model.scm (-prefetch-parse, -retire-parse, -pipeline-parse): Change
	errtxt argument to context, ACU.
	(-unit-parse, -model-parse, -model-read): Ditto.
	* operand.scm (-operand-parse-getter): Use parse-error instead of
	context-error.
	(-operand-parse-setter): Ditto.
	(-operand-parse): Change errtxt argument to context, ACU.
	(-operand-read, -derived-operand-parse, -derived-operand-read): Ditto.
	(-anyof-operand-parse, -anyof-operand-read): Ditto.
	* read.scm (reader-error): Delete.  Use parse-error instead.
	(parse-error): Change errtxt argument to context, ACU.  Split args
	argument into expr and maybe-help-text.
	(-reader-process-expanded-1!): Reorganize.
	* rtl.scm (-subr-read): Change errtxt argument to context, ACU.
	* types.scm (parse-type): Ditto.
	* utils-cgen.scm (single-location->simple-string): New function.
	(<context>): Replace members file,lineno with location.
	(make-prefix-context): Renamed from context-make-prefix, ACU.
	(make-current-context): New function.
	(context-append, context-append-name): New functions.
	(context-make-reader): Delete.
	(parse-name): Change errtxt argument to context, ACU.
	Put context arg first.
	(parse-comment): Ditto.
	(parse-number): Change errtxt argument to context, ACU.
	(arg-list-validate-name, arg-list-check-no-args,
	arg-list-symbol-arg): Ditto.

	* read.scm (-cmd-if): Don't assume test is a list.

	* html.scm (get-insn-properties): Delete errtxt, unused.
@
text
@d102 1
a102 1
; Utility of -enum-parse to parse the prefix.
d104 1
a104 1
(define (-enum-parse-prefix context prefix)
d122 1
a122 1
(define (-enum-parse context name comment attrs prefix vals)
d133 1
a133 1
	  (-enum-parse-prefix context prefix)
d141 1
a141 1
; -enum-parse is invoked to create the `enum' object.
d143 1
a143 1
(define (-enum-read context . arg-list)
d168 1
a168 1
    (-enum-parse context name comment attrs prefix values))
d175 1
a175 1
    (let ((e (apply -enum-read (cons (make-current-context "define-enum")
d184 1
a184 1
  (let ((e (-enum-parse (make-current-context "define-full-enum")
d383 1
a383 1
		     (-enum-parse-prefix context prefix)
@


1.6
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d49 1
a49 1
(define (parse-enum-vals errtxt prefix vals)
d104 1
a104 1
(define (-enum-parse-prefix errtxt prefix)
d109 1
a109 1
      (parse-error errtxt "prefix is not a string" prefix))
d113 1
a113 1
      (parse-error errtxt "prefix must be uppercase" prefix))
d122 1
a122 1
(define (-enum-parse errtxt name comment attrs prefix vals)
d125 3
a127 2
  (let* ((name (parse-name name errtxt))
	 (errtxt (stringsym-append errtxt " " name)))
d131 4
a134 4
	  (parse-comment comment errtxt)
	  (atlist-parse attrs "enum" errtxt)
	  (-enum-parse-prefix errtxt prefix)
	  (parse-enum-vals errtxt prefix vals)))
d139 1
a139 1
; ERRTXT is prepended to error messages to provide context.
d143 7
a149 7
(define (-enum-read errtxt . arg-list)
  (let (; Current enum elements:
	(name nil)    ; name of field
	(comment "")  ; description of field
	(attrs nil)   ; attributes
	(prefix "")   ; prepended to each element's name
	(values nil)  ; enum values
d151 1
d164 1
a164 1
	      (else (parse-error errtxt "invalid enum arg" arg)))
d166 1
d168 1
a168 2
    (-enum-parse errtxt name comment attrs prefix values)
    )
d175 2
a176 1
    (let ((e (apply -enum-read (cons "define-enum" arg-list))))
d184 2
a185 1
  (let ((e (-enum-parse "define-full-enum" name comment attrs prefix vals)))
d370 2
a371 2
  (let* ((errtxt "define-full-insn-enum")
	 (atlist (atlist-parse attrs "insn_enum" errtxt))
d377 1
a377 1
	      (parse-error errtxt "unknown insn field" fld))
d380 4
a383 4
		     (parse-name name errtxt)
		     (parse-comment comment errtxt)
		     (atlist-parse attrs "insn-enum" errtxt)
		     (-enum-parse-prefix errtxt prefix)
d385 1
a385 1
		     (parse-enum-vals errtxt prefix vals))))
d388 1
a388 1
  )
@


1.5
log
@	* attr.scm: Removing trailing whitespace.
	* cgen-intrinsics.scm: Ditto.
	* cgen-sim.scm: Ditto.
	* cos.scm: Ditto.
	* enum.scm: Ditto.
	* guile.scm: Ditto.
	* sim.scm: Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
@


1.5.2.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2009 Red Hat, Inc.
@


1.4
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@d22 2
a23 1
; FIXME: this make! method is required by <insn-enum> for some reason. 
d374 1
a374 2
	  
					; Create enum object and add it to the list of enums.
@


1.3
log
@	* mach.scm (current-*-add!): Disallow redefinition.  Make result
	"unspecified".
	* insn.scm (insn-builtin!): Don't define relaxable here, now defined in
	operand.scm.
	* operand.scm (operand-builtin!): Define RELAXABLE for insns too.
	* cpu/m32r.cpu (disp8,disp24): RELAX renamed to RELAXABLE.

	* gen-all-doc: Split arm and frv docs up a bit.

	* cpu/arm.cpu: Add IDOC attribute.
	* cpu/frv.cpu: Ditto.
	* cpu/i960.cpu: Ditto.
	* cpu/openrisc.cpu: Ditto.
	* cpu/xstormy16.cpu: Ditto.
	* cpu/m32r.cpu: Ditto.
	(all insns): Explicitly specify IDOC attribute.

	* Makefile.am (MACH,ISAS,INSN_FILE_NAME): New vars.
	(desc,opcodes,sim-arch,sim-cpu,gas-test,sim-test): Use MACH,ISAS.
	(html): Use MACH,ISAS,INSN_FILE_NAME.  Generate insn.html separately.
	* Makefile.in: Regenerate.
	* attr.scm (<integer-attribute>:parse-value-def): Implement.
	(-attr-read): Defer computing default value until we know the type.
	(attr-has-attr?): Delete, move contents to <attr-list>:has-attr?.
	(<attr-list>:attr-present?): New method.
	(atlist-attr-present?,obj-attr-present?): New fns.
	(obj-has-attr-value?,obj-has-attr-value-no-default?): New fns.
	(attr-builtin!): New insn attr IDOC.
	* cgen-doc.scm (doc-arguments): New args -I,-N.
	* enum.scm (parse-enum-vals): New arg errtxt, all callers updated.
	Support comment as fourth element of enum value.
	(enum-val-name,enum-val-value,enum-val-attrs,enum-val-comment): New fns.
	* html.scm (gen-html-header): New arg kind, all callers updated.
	(gen-table-of-contents): New arg insn-file, all callers updated.
	(gen-list-entry,gen-doc-header): New fn.
	(get-operands): Delete.
	(gen-iformat-table): Rewrite.
	(gen-insn-doc-1): Print constant-folded and trimmed semantics.
	(gen-insn-doc-list): New args name, comment, insns.  All callers updated.
	(get-insn-properties,guess-insn-idoc-attr!): New fn.
	(insn-sets-pc?,insn-refs-mem?,insn-uses-fpu?): New fns.
	(get-insns-for-category,gen-categories-insn-lists): New fns.
	(gen-insn-docs): Simplify each insn's semantics first.
	Print insn tables sorted by IDOC categories.
	(*insn-html-file-name*): New global.
	(cgen-insn.html): New fn.
	(cgen-all): Update.
	* insn.scm (<insn>): Create a setter for the `tmp' member.
	* semantics.scm (insn-build-known-values): Renamed from
	-build-known-values.  All callers updated.

	* rtl.scm: Move traveral/evaluation support to ...
	* rtl-traverse.scm: New file.
	* read.scm: Maybe-load rtl-traverse.scm.

	* rtl.scm (-rtx-valid-types): Add SETRTX.

	* rtx-funcs.scm (nop,parallel): Fix mode.

	* utils.scm (eqv-lookup-index): New fn.
	(assq-lookup-index): Renamed from lookup-index.  All callers updated.

	* dev.scm (load-doc): Set APPLICATION.
@
text
@d64 4
a67 4
	      (let ((name (symbol-append prefix
					 (if (pair? (car remaining))
					     (caar remaining)
					     (car remaining))))
d95 1
a95 1
	 (cons (string->symbol (string-upcase (car elm))) (cdr elm)))
d125 1
a125 1
	 (errtxt (string-append errtxt " " name)))
@


1.2
log
@* consistency improvement for isa-filtering in *ifield parsers

2000-09-15  Frank Ch. Eigler  <fche@@redhat.com>

	* enum.scm (define-full-insn-enum): Filter with keep-isa predicate.
	* ifield.scm (-ifield-parse, -multi-ifield-parse): No longer assert
	single-isa predicate, but support keep-isa filtering.
@
text
@d41 4
a44 2
; (symbol - attrs), (symbol value attrs).
; The `-' means use the next value.
d48 2
a49 2
(define (parse-enum-vals prefix vals)
  ; Scan the value list, building up RES-VALS as we go.
d64 26
a89 14
	      (loop (cons (cons (symbol-append prefix
					       (if (pair? (car remaining))
						   (caar remaining)
						   (car remaining)))
				(cons val
				      ; Pass any attributes through unchanged.
				      (if (and (pair? (car remaining))
					       (pair? (cdar remaining)))
					  (cddar remaining)
					  nil)))
			  result)
		    val
		    (cdr remaining))))))
)
d117 1
a117 1
; This is the main routine for building an ifield object from a
d132 1
a132 1
	  (parse-enum-vals prefix vals)))
d208 1
a208 1
; VALS is a list of enums.  e.g. ((sym1) (sym2 3) (sym3 '- attr1 (attr2 4)))
d287 3
a289 1
		 (if (or sequential? (null? (cdr e)) (eq? '- (cadr e)))
d381 1
a381 1
		     (parse-enum-vals prefix vals))))
@


1.1
log
@Initial revision
@
text
@d349 3
a351 2
  (let ((errtxt "define-full-insn-enum")
	(fld-obj (current-ifld-lookup fld)))
d353 16
a368 14
    (if (not fld-obj)
	(parse-error errtxt "unknown insn field" fld))

    ; Create enum object and add it to the list of enums.
    (let ((e (make <insn-enum>
	       (parse-name name errtxt)
	       (parse-comment comment errtxt)
	       (atlist-parse attrs "insn-enum" errtxt)
	       (-enum-parse-prefix errtxt prefix)
	       fld-obj
	       (parse-enum-vals prefix vals))))
      (current-enum-add! e)
      e))
)
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
