head	1.33;
access;
symbols
	sid-snapshot-20180601:1.33
	cgen-snapshot-20180601:1.33
	sid-snapshot-20180501:1.33
	cgen-snapshot-20180501:1.33
	sid-snapshot-20180401:1.33
	cgen-snapshot-20180401:1.33
	sid-snapshot-20180301:1.33
	cgen-snapshot-20180301:1.33
	sid-snapshot-20180201:1.33
	cgen-snapshot-20180201:1.33
	sid-snapshot-20180101:1.33
	cgen-snapshot-20180101:1.33
	sid-snapshot-20171201:1.33
	cgen-snapshot-20171201:1.33
	sid-snapshot-20171101:1.33
	cgen-snapshot-20171101:1.33
	sid-snapshot-20171001:1.33
	cgen-snapshot-20171001:1.33
	sid-snapshot-20170901:1.33
	cgen-snapshot-20170901:1.33
	sid-snapshot-20170801:1.33
	cgen-snapshot-20170801:1.33
	sid-snapshot-20170701:1.33
	cgen-snapshot-20170701:1.33
	sid-snapshot-20170601:1.33
	cgen-snapshot-20170601:1.33
	sid-snapshot-20170501:1.33
	cgen-snapshot-20170501:1.33
	sid-snapshot-20170401:1.33
	cgen-snapshot-20170401:1.33
	sid-snapshot-20170301:1.33
	cgen-snapshot-20170301:1.33
	sid-snapshot-20170201:1.33
	cgen-snapshot-20170201:1.33
	sid-snapshot-20170101:1.33
	cgen-snapshot-20170101:1.33
	sid-snapshot-20161201:1.33
	cgen-snapshot-20161201:1.33
	sid-snapshot-20161101:1.33
	cgen-snapshot-20161101:1.33
	sid-snapshot-20160901:1.33
	cgen-snapshot-20160901:1.33
	sid-snapshot-20160801:1.33
	cgen-snapshot-20160801:1.33
	sid-snapshot-20160701:1.33
	cgen-snapshot-20160701:1.33
	sid-snapshot-20160601:1.33
	cgen-snapshot-20160601:1.33
	sid-snapshot-20160501:1.33
	cgen-snapshot-20160501:1.33
	sid-snapshot-20160401:1.33
	cgen-snapshot-20160401:1.33
	sid-snapshot-20160301:1.33
	cgen-snapshot-20160301:1.33
	sid-snapshot-20160201:1.33
	cgen-snapshot-20160201:1.33
	sid-snapshot-20160101:1.33
	cgen-snapshot-20160101:1.33
	sid-snapshot-20151201:1.33
	cgen-snapshot-20151201:1.33
	sid-snapshot-20151101:1.33
	cgen-snapshot-20151101:1.33
	sid-snapshot-20151001:1.33
	cgen-snapshot-20151001:1.33
	sid-snapshot-20150901:1.33
	cgen-snapshot-20150901:1.33
	sid-snapshot-20150801:1.33
	cgen-snapshot-20150801:1.33
	sid-snapshot-20150701:1.33
	cgen-snapshot-20150701:1.33
	sid-snapshot-20150601:1.33
	cgen-snapshot-20150601:1.33
	sid-snapshot-20150501:1.33
	cgen-snapshot-20150501:1.33
	sid-snapshot-20150401:1.33
	cgen-snapshot-20150401:1.33
	sid-snapshot-20150301:1.33
	cgen-snapshot-20150301:1.33
	sid-snapshot-20150201:1.33
	cgen-snapshot-20150201:1.33
	sid-snapshot-20150101:1.33
	cgen-snapshot-20150101:1.33
	sid-snapshot-20141201:1.33
	cgen-snapshot-20141201:1.33
	sid-snapshot-20141101:1.33
	cgen-snapshot-20141101:1.33
	sid-snapshot-20141001:1.33
	cgen-snapshot-20141001:1.33
	sid-snapshot-20140901:1.33
	cgen-snapshot-20140901:1.33
	sid-snapshot-20140801:1.33
	cgen-snapshot-20140801:1.33
	sid-snapshot-20140701:1.33
	cgen-snapshot-20140701:1.33
	sid-snapshot-20140601:1.33
	cgen-snapshot-20140601:1.33
	sid-snapshot-20140501:1.32
	cgen-snapshot-20140501:1.32
	sid-snapshot-20140401:1.32
	cgen-snapshot-20140401:1.32
	sid-snapshot-20140301:1.32
	cgen-snapshot-20140301:1.32
	sid-snapshot-20140201:1.32
	cgen-snapshot-20140201:1.32
	sid-snapshot-20140101:1.32
	cgen-snapshot-20140101:1.32
	sid-snapshot-20131201:1.32
	cgen-snapshot-20131201:1.32
	sid-snapshot-20131101:1.32
	cgen-snapshot-20131101:1.32
	sid-snapshot-20131001:1.32
	cgen-snapshot-20131001:1.32
	sid-snapshot-20130901:1.32
	cgen-snapshot-20130901:1.32
	sid-snapshot-20130801:1.32
	cgen-snapshot-20130801:1.32
	sid-snapshot-20130701:1.32
	cgen-snapshot-20130701:1.32
	sid-snapshot-20130601:1.32
	cgen-snapshot-20130601:1.32
	sid-snapshot-20130501:1.32
	cgen-snapshot-20130501:1.32
	sid-snapshot-20130401:1.32
	cgen-snapshot-20130401:1.32
	sid-snapshot-20130301:1.32
	cgen-snapshot-20130301:1.32
	sid-snapshot-20130201:1.32
	cgen-snapshot-20130201:1.32
	sid-snapshot-20130101:1.32
	cgen-snapshot-20130101:1.32
	sid-snapshot-20121201:1.32
	cgen-snapshot-20121201:1.32
	sid-snapshot-20121101:1.32
	cgen-snapshot-20121101:1.32
	sid-snapshot-20121001:1.32
	cgen-snapshot-20121001:1.32
	sid-snapshot-20120901:1.32
	cgen-snapshot-20120901:1.32
	sid-snapshot-20120801:1.32
	cgen-snapshot-20120801:1.32
	sid-snapshot-20120701:1.32
	cgen-snapshot-20120701:1.32
	sid-snapshot-20120601:1.32
	cgen-snapshot-20120601:1.32
	sid-snapshot-20120501:1.32
	cgen-snapshot-20120501:1.32
	sid-snapshot-20120401:1.32
	cgen-snapshot-20120401:1.32
	sid-snapshot-20120301:1.32
	cgen-snapshot-20120301:1.32
	sid-snapshot-20120201:1.32
	cgen-snapshot-20120201:1.32
	sid-snapshot-20120101:1.32
	cgen-snapshot-20120101:1.32
	sid-snapshot-20111201:1.32
	cgen-snapshot-20111201:1.32
	sid-snapshot-20111101:1.32
	cgen-snapshot-20111101:1.32
	sid-snapshot-20111001:1.32
	cgen-snapshot-20111001:1.32
	sid-snapshot-20110901:1.32
	cgen-snapshot-20110901:1.32
	sid-snapshot-20110801:1.32
	cgen-snapshot-20110801:1.32
	sid-snapshot-20110701:1.32
	cgen-snapshot-20110701:1.32
	sid-snapshot-20110601:1.32
	cgen-snapshot-20110601:1.32
	sid-snapshot-20110501:1.32
	cgen-snapshot-20110501:1.32
	sid-snapshot-20110401:1.32
	cgen-snapshot-20110401:1.32
	sid-snapshot-20110301:1.32
	cgen-snapshot-20110301:1.32
	sid-snapshot-20110201:1.32
	cgen-snapshot-20110201:1.32
	sid-snapshot-20110101:1.32
	cgen-snapshot-20110101:1.32
	sid-snapshot-20101201:1.32
	cgen-snapshot-20101201:1.32
	sid-snapshot-20101101:1.32
	cgen-snapshot-20101101:1.32
	sid-snapshot-20101001:1.32
	cgen-snapshot-20101001:1.32
	sid-snapshot-20100901:1.32
	cgen-snapshot-20100901:1.32
	sid-snapshot-20100801:1.31
	cgen-snapshot-20100801:1.31
	sid-snapshot-20100701:1.31
	cgen-snapshot-20100701:1.31
	sid-snapshot-20100601:1.31
	cgen-snapshot-20100601:1.31
	sid-snapshot-20100501:1.31
	cgen-snapshot-20100501:1.31
	sid-snapshot-20100401:1.31
	cgen-snapshot-20100401:1.31
	sid-snapshot-20100301:1.31
	cgen-snapshot-20100301:1.31
	sid-snapshot-20100201:1.31
	cgen-snapshot-20100201:1.31
	sid-snapshot-20100101:1.28
	cgen-snapshot-20100101:1.28
	sid-snapshot-20091201:1.28
	cgen-snapshot-20091201:1.28
	sid-snapshot-20091101:1.24
	cgen-snapshot-20091101:1.24
	sid-snapshot-20091001:1.24
	cgen-snapshot-20091001:1.24
	arc-sim-20090309:1.8
	sid-snapshot-20090901:1.16
	cgen-snapshot-20090901:1.16
	sid-snapshot-20090801:1.11
	cgen-snapshot-20090801:1.11
	sid-snapshot-20090701:1.10
	cgen-snapshot-20090701:1.10
	dje-cgen-play1-branch:1.10.0.2
	dje-cgen-play1-branchpoint:1.10
	cgen-1_1-branch:1.8.0.4
	cgen-1_1-branchpoint:1.8
	sid-snapshot-20090601:1.8
	cgen-snapshot-20090601:1.8
	sid-snapshot-20090501:1.8
	cgen-snapshot-20090501:1.8
	sid-snapshot-20090401:1.8
	cgen-snapshot-20090401:1.8
	arc-insight_6_8-branch:1.8.0.2
	arc-insight_6_8-branchpoint:1.8
	sid-snapshot-20090301:1.8
	cgen-snapshot-20090301:1.8
	sid-snapshot-20090201:1.8
	cgen-snapshot-20090201:1.8
	sid-snapshot-20090101:1.8
	cgen-snapshot-20090101:1.8
	sid-snapshot-20081201:1.8
	cgen-snapshot-20081201:1.8
	sid-snapshot-20081101:1.8
	cgen-snapshot-20081101:1.8
	sid-snapshot-20081001:1.8
	cgen-snapshot-20081001:1.8
	sid-snapshot-20080901:1.8
	cgen-snapshot-20080901:1.8
	sid-snapshot-20080801:1.8
	cgen-snapshot-20080801:1.8
	sid-snapshot-20080701:1.8
	cgen-snapshot-20080701:1.8
	sid-snapshot-20080601:1.8
	cgen-snapshot-20080601:1.8
	sid-snapshot-20080501:1.8
	cgen-snapshot-20080501:1.8
	sid-snapshot-20080403:1.8
	sid-snapshot-20080401:1.8
	cgen-snapshot-20080401:1.8
	sid-snapshot-20080301:1.8
	cgen-snapshot-20080301:1.8
	sid-snapshot-20080201:1.8
	cgen-snapshot-20080201:1.8
	sid-snapshot-20080101:1.8
	cgen-snapshot-20080101:1.8
	sid-snapshot-20071201:1.8
	cgen-snapshot-20071201:1.8
	sid-snapshot-20071101:1.8
	cgen-snapshot-20071101:1.8
	sid-snapshot-20071001:1.8
	cgen-snapshot-20071001:1.8
	msnyder-fork-checkpoint-branch:1.7.0.2
	msnyder-fork-checkpoint-branchpoint:1.7
	sid-20020905-branchpoint:1.4
	sid-20020905-branch:1.4.0.6
	cagney_regbuf-20020515-branch:1.4.0.4
	cagney_regbuf-20020515-branchpoint:1.4
	cygnus_cvs_20020108_pre:1.4
	cgen-1-1-branch:1.4.0.2
	cgen-1-0:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.33
date	2014.05.19.01.24.00;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2010.08.30.16.51.27;	author devans;	state Exp;
branches;
next	1.31;

1.31
date	2010.01.25.03.50.43;	author devans;	state Exp;
branches;
next	1.30;

1.30
date	2010.01.21.07.56.41;	author devans;	state Exp;
branches;
next	1.29;

1.29
date	2010.01.06.05.05.13;	author devans;	state Exp;
branches;
next	1.28;

1.28
date	2009.11.23.00.44.48;	author devans;	state Exp;
branches;
next	1.27;

1.27
date	2009.11.21.17.39.14;	author devans;	state Exp;
branches;
next	1.26;

1.26
date	2009.11.12.16.05.29;	author devans;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.03.16.24.02;	author devans;	state Exp;
branches;
next	1.24;

1.24
date	2009.09.28.02.40.49;	author devans;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.25.19.40.08;	author devans;	state Exp;
branches;
next	1.22;

1.22
date	2009.09.23.22.30.19;	author devans;	state Exp;
branches;
next	1.21;

1.21
date	2009.09.22.03.06.27;	author devans;	state Exp;
branches;
next	1.20;

1.20
date	2009.09.22.02.37.30;	author devans;	state Exp;
branches;
next	1.19;

1.19
date	2009.09.12.17.34.15;	author devans;	state Exp;
branches;
next	1.18;

1.18
date	2009.09.08.07.26.50;	author devans;	state Exp;
branches;
next	1.17;

1.17
date	2009.09.07.22.17.34;	author devans;	state Exp;
branches;
next	1.16;

1.16
date	2009.08.28.06.20.28;	author devans;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.27.21.28.48;	author devans;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.27.05.47.12;	author devans;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.27.04.22.56;	author devans;	state Exp;
branches;
next	1.12;

1.12
date	2009.08.12.22.33.37;	author devans;	state Exp;
branches;
next	1.11;

1.11
date	2009.07.19.19.19.42;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.24.15.03.09;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.21.17.41.47;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2007.08.21.19.37.43;	author brolley;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2005.08.02.19.30.10;	author brolley;	state Exp;
branches;
next	1.6;

1.6
date	2005.06.15.21.28.18;	author brolley;	state Exp;
branches;
next	1.5;

1.5
date	2003.07.16.05.35.47;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.08.22.18.37;	author fche;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.24.15.35.47;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.20.22.52.32;	author devans;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches
	1.1.1.1;
next	;

1.8.4.1
date	2009.06.24.14.57.46;	author devans;	state Exp;
branches;
next	;

1.1.1.1
date	2000.07.28.04.11.52;	author bje;	state Exp;
branches;
next	;


desc
@@


1.33
log
@or1k support
        * sim-arch.scm (WI, UWI, AI, IAI): Define.
        * rtl-c.scm (mul-o1flag, mul-o2flag, rem): New.
        * rtx-funcs.scn (mul-o1flag, mul-o2flag, rem): New.
@
text
@; RTL->C translation support.
; Copyright (C) 2000, 2005, 2009, 2010, 2014 Red Hat, Inc.
; This file is part of CGEN.
; See file COPYING.CGEN for details.

; Generating C from RTL
; ---------------------
; The main way to generate C code from an RTL expression is:
;
; (rtl-c-parsed mode isa-name-list nil '(func mode ...))
;
; E.g.
; (rtl-c-parsed SI (all) nil '(add () SI (const () SI 1) (const () SI 2)))
; -->
; "ADDSI (1, 2)"
;
; The expression is in source form and must be already canonicalized (with
; rtx-canonicalize).  There is also rtl-c for the occasions where the rtl
; isn't already canonicalized.
;
; The `set' rtx needs to be handled a little carefully.
; Both the dest and src are processed first, and then code to perform the
; assignment is computed.  However, the dest may require more than a simple
; C assignment.  Therefore set dests are converted to the specified object
; (e.g. a hardware operand) and then a message is sent to this object to
; perform the actual code generation.
;
; All interesting operands (e.g. regs, mem) are `operand' objects.
; The following messages must be supported by operand objects.
; - get-mode      - return mode of operand
; - cxmake-get    - return <c-expr> object containing operand's value
; - gen-set-quiet - return string of C code to set operand's value (no tracing)
; - gen-set-trace - return string of C code to set operand's value
;
; Instruction fields are refered to by name.
; Instruction ifields must have these methods:
; - get-mode
; - cxmake-get
;
; Conventions used in this file:
; - see rtl.scm

; The <c-expr> object.
; This is a fully translated expression (i.e. C code).

(define <c-expr>
  (class-make '<c-expr> nil
	      '(
		; The mode of C-CODE.
		mode
		; The translated C code.
		c-code
		; The source expression, for debugging.
		expr
		; Attributes of the expression.
		atlist
		; List of temporaries required to compute the expression.
		; ??? wip.  These would be combined as the expression is
		; built up.  Then in sets and other statements, the temporaries
		; would be declared.
		;(tmps . nil)
		)
	      nil)
)

(method-make!
 <c-expr> 'make!
 (lambda (self mode c-code atlist)
   ; FIXME: Extend COS to allow specifying member predicates.
   (assert (mode? mode))
   (assert (string? c-code))
   ;(assert (atlist? atlist)) ; FIXME: What should this be?
   (elm-set! self 'mode mode)
   (elm-set! self 'c-code c-code)
   (elm-set! self 'atlist atlist)
   self)
)

; Accessor fns

(define cx:mode (elm-make-getter <c-expr> 'mode))
(define cx:c-code (elm-make-getter <c-expr> 'c-code))
(define cx:expr (elm-make-getter <c-expr> 'expr))
(define cx:atlist (elm-make-getter <c-expr> 'atlist))
;(define cx:tmps (elm-make-getter <c-expr> 'tmps))

; Any object with attributes requires the get-atlist method.

(method-make! <c-expr> 'get-atlist (lambda (self) (elm-get self 'atlist)))

; Respond to 'get-mode messages.

(method-make! <c-expr> 'get-mode (lambda (self) (elm-get self 'mode)))

; Respond to 'get-name messages for rtx-dump.

(method-make!
 <c-expr> 'get-name
 (lambda (self)
   (string-append "(" (obj:str-name (elm-get self 'mode)) ") "
		  (cx:c self)))
)

; Return C code to perform an assignment.
; NEWVAL is a <c-expr> object of the value to be assigned to SELF.

(method-make! <c-expr> 'gen-set-quiet
	      (lambda (self estate mode indx selector newval)
		(string-append "  " (cx:c self) " = " (cx:c newval) ";\n"))
)

(method-make! <c-expr> 'gen-set-trace
	      (lambda (self estate mode indx selector newval)
		(string-append "  " (cx:c self) " = " (cx:c newval) ";\n"))
)

; Return the C code of CX.
; ??? This used to handle lazy evaluation of the expression.
; Maybe it will again, so it's left in, as a cover fn to cx:c-code.

(define (cx:c cx)
  (cx:c-code cx)
)

; Main routine to create a <c-expr> node object.
; MODE is either the mode's symbol (e.g. 'QI) or a <mode> object.
; CODE is a string of C code.

(define (cx:make mode code)
  (make <c-expr> (mode-maybe-lookup mode) code nil)
)

; Make copy of CX in new mode MODE.
; MODE must be a <mode> object.

(define (cx-new-mode mode cx)
  (make <c-expr> mode (cx:c cx) (cx:atlist cx))
)

; Same as cx:make except with attributes.

(define (cx:make-with-atlist mode code atlist)
  (make <c-expr> (mode-maybe-lookup mode) code atlist)
)

; Return a boolean indicated if X is a <c-expr> object.

(define (c-expr? x) (class-instance? <c-expr> x))

; RTX environment support.

(method-make!
 <rtx-temp> 'cxmake-get
 (lambda (self estate mode indx selector)
   (cx:make mode (rtx-temp-value self)))
)

(method-make!
 <rtx-temp> 'gen-set-quiet
 (lambda (self estate mode indx selector src)
   (string-append "  " (rtx-temp-value self) " = " (cx:c src) ";\n"))
)

(method-make!
 <rtx-temp> 'gen-set-trace
 (lambda (self estate mode indx selector src)
   (string-append "  " (rtx-temp-value self) " = " (cx:c src) ";\n"))
)

(define (gen-temp-defs estate env)
  (string-map (lambda (temp)
		(let ((temp-obj (cdr temp)))
		  (string-append "  " (mode:c-type (rtx-temp-mode temp-obj))
				 " " (rtx-temp-value temp-obj) ";\n")))
	      env)
)

; Top level routines to handle rtl->c translation.

; rtl->c configuration parameters

; #t -> emit calls to rtl cover fns, otherwise emit plain C where possible.
(define /rtl-c-rtl-cover-fns? #f)

; Called before emitting code to configure the generator.
; ??? I think this can go away now (since cover-fn specification is also
; done at each call to rtl-c).

(define (rtl-c-config! . args)
  (set! /rtl-c-rtl-cover-fns? #f)
  (let loop ((args args))
    (if (null? args)
	#f ; done
	(begin
	  (case (car args)
	    ((#:rtl-cover-fns?)
	     (set! /rtl-c-rtl-cover-fns? (cadr args)))
	    (else (error "rtl-c-config: unknown option:" (car args))))
	  (loop (cddr args)))))
  *UNSPECIFIED*
)

; Subclass of <eval-state> to record additional things needed for rtl->c.

(define <rtl-c-eval-state>
  (class-make '<rtl-c-eval-state> '(<eval-state>)
	      '(
		; #t -> emit calls to rtl cover fns.
		(rtl-cover-fns? . #f)

		; name of output language, "c" or "c++"
		(output-language . "c")

		; #t if generating code for a macro.
		; Each newline is then preceeded with '\\'.
		(macro? . #f)

		; Boolean indicating if evaluation is for an instruction.
		; It's not always possible to look at OWNER, e.g. when we're
		; processing semantic fragments.
		(for-insn? . #f)

		; #f -> reference ifield values using FLD macro.
		; #t -> use C variables.
		; ??? This is only needed to get correct ifield references
		; in opcodes, decoder, and semantics.  Maybe a better way to
		; go would be to specify the caller's name so there'd be just
		; one of these, rather than an increasing number.  However,
		; for now either way is the same.
		; An alternative is to specify a callback to try first.
		(ifield-var? . #f)
		)
	      nil)
)

; FIXME: involves upcasting.
(define-getters <rtl-c-eval-state> estate
  (rtl-cover-fns? output-language macro? for-insn? ifield-var?)
)

; Return booleans indicating if output language is C/C++.

(define (estate-output-language-c? estate)
  (string=? (estate-output-language estate) "c")
)
(define (estate-output-language-c++? estate)
  (string=? (estate-output-language estate) "c++")
)

(method-make!
 <rtl-c-eval-state> 'vmake!
 (lambda (self args)
   ; Initialize parent class first.
   (let loop ((args (send-next self '<rtl-c-eval-state> 'vmake! args))
	      (unrecognized nil))
     (if (null? args)
	 (reverse! unrecognized) ; ??? Could invoke method to initialize here.
	 (begin
	   (case (car args)
	     ((#:rtl-cover-fns?)
	      (elm-set! self 'rtl-cover-fns? (cadr args)))
	     ((#:output-language)
	      (elm-set! self 'output-language (cadr args)))
	     ((#:macro?)
	      (elm-set! self 'macro? (cadr args)))
	     ((#:for-insn?)
	      (elm-set! self 'for-insn? (cadr args)))
	     ((#:ifield-var?)
	      (elm-set! self 'ifield-var? (cadr args)))
	     (else
	      ; Build in reverse order, as we reverse it back when we're done.
	      (set! unrecognized
		    (cons (cadr args) (cons (car args) unrecognized)))))
	   (loop (cddr args) unrecognized)))))
)

;; Build an estate for use in generating C.
;; OVERRIDES is a #:keyword/value list of parameters to apply last.

(define (estate-make-for-rtl-c overrides)
  (apply vmake
	 (append!
	  (list
	   <rtl-c-eval-state>
	   #:expr-fn (lambda (rtx-obj expr mode estate)
		       (rtl-c-generator rtx-obj))
	   #:rtl-cover-fns? /rtl-c-rtl-cover-fns?)
	  overrides))
)

; Translate RTL expression EXPR to C.
; ESTATE is the current rtx evaluation state.
; MODE is a <mode> object.

(define (rtl-c-with-estate estate mode expr)
  (cx:c (rtl-c-get estate mode (rtx-eval-with-estate expr mode estate)))
)

; Translate parsed RTL expression X to a string of C code.
; EXPR must have already been fed through rtx-canonicalize.
; MODE is the desired mode of the value or DFLT for "natural mode".
; MODE is a <mode> object.
; OVERRIDES is a #:keyword/value list of arguments to build the eval state
; with.

(define (rtl-c-parsed mode expr . overrides)
  ;; ??? If we're passed insn-compiled-semantics the output of xops is
  ;; confusing.  Fix by subclassing <operand> -> <xoperand>, and
  ;; have <xoperand> provide original source expr.
  (let ((estate (estate-make-for-rtl-c (cons #:outer-expr
					     (cons expr overrides)))))
    (rtl-c-with-estate estate mode expr))
)

; Same as rtl-c-parsed but EXPR is unparsed.
; ISA-NAME-LIST is the list of ISA(s) in which to evaluate EXPR.
; EXTRA-VARS-ALIST is an association list of extra (symbol <mode> value)
; elements to be used during value lookup.
; MODE is a <mode> object.

(define (rtl-c mode isa-name-list extra-vars-alist expr . overrides)
  (let* ((canonical-rtl (rtx-canonicalize #f (obj:name mode)
					  isa-name-list extra-vars-alist expr))
	 (estate (estate-make-for-rtl-c (cons #:outer-expr
					      (cons canonical-rtl overrides)))))
    (rtl-c-with-estate estate mode canonical-rtl))
)

; Same as rtl-c-with-estate except return a <c-expr> object.
; MODE is a <mode> object.

(define (rtl-c-expr-with-estate estate mode expr)
  (rtl-c-get estate mode (rtx-eval-with-estate expr mode estate))
)

; Same as rtl-c-parsed except return a <c-expr> object.
; MODE is a <mode> object.

(define (rtl-c-expr-parsed mode expr . overrides)
  ;; ??? If we're passed insn-compiled-semantics the output of xops is
  ;; confusing.  Fix by subclassing <operand> -> <xoperand>, and
  ;; have <xoperand> provide original source expr.
  (let ((estate (estate-make-for-rtl-c (cons #:outer-expr
					     (cons expr overrides)))))
    (rtl-c-expr-with-estate estate mode expr))
)

; Same as rtl-c-expr-parsed but EXPR is unparsed.
; MODE is a <mode> object.

(define (rtl-c-expr mode isa-name-list extra-vars-alist expr . overrides)
  (let* ((canonical-rtl (rtx-canonicalize #f (obj:name mode)
					  isa-name-list extra-vars-alist expr))
	 (estate (estate-make-for-rtl-c (cons #:outer-expr
					      (cons canonical-rtl overrides)))))
    (rtl-c-expr-with-estate estate mode canonical-rtl))
)

; C++ versions of rtl-c routines.

; Build an estate for use in generating C++.
; OVERRIDES is a #:keyword/value list of parameters to apply last.

(define (estate-make-for-rtl-c++ overrides)
  (estate-make-for-rtl-c (cons #:output-language (cons "c++" overrides)))
)

; Translate parsed RTL expression X to a string of C++ code.
; EXPR must have already been fed through rtx-canonicalize.
; MODE is the desired mode of the value or DFLT for "natural mode".
; MODE is a <mode> object.
; OVERRIDES is a #:keyword/value list of arguments to build the eval state
; with.

(define (rtl-c++-parsed mode expr . overrides)
  ;; ??? If we're passed insn-compiled-semantics the output of xops is
  ;; confusing.  Fix by subclassing <operand> -> <xoperand>, and
  ;; have <xoperand> provide original source expr.
  (let ((estate (estate-make-for-rtl-c++ (cons #:outer-expr
					       (cons expr overrides)))))
    (rtl-c-with-estate estate mode expr))
)

; Same as rtl-c++-parsed but EXPR is unparsed.
; MODE is a <mode> object.

(define (rtl-c++ mode isa-name-list extra-vars-alist expr . overrides)
  (let* ((canonical-rtl (rtx-canonicalize #f (obj:name mode)
					  isa-name-list extra-vars-alist expr))
	 (estate (estate-make-for-rtl-c++ (cons #:outer-expr
						(cons canonical-rtl overrides)))))
    (rtl-c-with-estate estate mode canonical-rtl))
)

; Top level routines for getting/setting values.

; Return a <c-expr> node to get the value of SRC in mode MODE.
; ESTATE is the current rtl evaluation state.
; MODE is a <mode> object.
; SRC is one of:
; - <c-expr> node
; - rtl expression (e.g. '(add WI dr sr))
; - sequence's local variable name
; - sequence's local variable object
; - operand name
; - operand object
; - an integer
; - a string of C code
; FIXME: Reduce acceptable values of SRC.
; The result has mode MODE, unless MODE is the "default mode indicator"
; (DFLT) in which case the mode of the result is derived from SRC.
;
; ??? mode compatibility checks are wip

(define (/rtl-c-get estate mode src)
  (let ((mode mode)) ;;(mode:lookup mode)))

    (cond ((c-expr? src)
	   (cond ((or (mode:eq? 'VOID mode)
		      (mode:eq? 'DFLT mode)
		      (mode:eq? (cx:mode src) mode))
		  src)
		 ((rtx-mode-compatible? mode (cx:mode src))
		  (cx-new-mode mode src))
		 (else
		  (estate-error
		   estate
		   (string-append "incompatible mode: "
				  "(" (obj:str-name (cx:mode src)) " vs "
				  (obj:str-name mode) ") in "
				  "\"" (cx:c src) "\"")
		   (obj:name mode)))))

	  ; The recursive call to /rtl-c-get is in case the result of rtx-eval
	  ; is a hardware object, rtx-func object, or another rtl expression.
	  ; FIXME: simplify
	  ((rtx? src)
	   (let ((evald-src (rtx-eval-with-estate src mode estate)))
	     ; There must have been some change, otherwise we'll loop forever.
	     (assert (not (eq? src evald-src)))
	     (/rtl-c-get estate mode evald-src)))

	  ;; FIXME: Can we ever get a symbol here?
	  ((or (and (symbol? src) (current-op-lookup src))
	       (operand? src))
	   (begin
	     (if (symbol? src)
		 (set! src (current-op-lookup src)))
	     (cond ((mode:eq? 'DFLT mode)
		    ; FIXME: Can we get called with 'DFLT anymore?
		    ; FIXME: If we fetch the mode here, operands can assume
		    ; they never get called with "default mode".
		    (send src 'cxmake-get estate mode #f #f))
		   ((rtx-mode-compatible? mode (op:mode src))
		    (let ((mode (op:mode src))) ;; FIXME: (rtx-sem-mode mode)))
		      (send src 'cxmake-get estate mode #f #f)))
		   (else
		    ;; FIXME: canonicalization should have already caught this
		    (estate-error
		     estate
		     (string-append "operand " (obj:str-name src)
				    " referenced in incompatible mode")
		     (obj:name mode))))))

	  ;; FIXME: Can we ever get a symbol here?
	  ((or (and (symbol? src) (rtx-temp-lookup (estate-env-stack estate) src))
	       (rtx-temp? src))
	   (begin
	     (if (symbol? src)
		 (set! src (rtx-temp-lookup (estate-env-stack estate) src)))
	     (cond ((mode:eq? 'DFLT mode)
		    (send src 'cxmake-get estate (rtx-temp-mode src) #f #f))
		   ((rtx-mode-compatible? mode (rtx-temp-mode src))
		    (let ((mode (rtx-temp-mode src))) ;; FIXME: (rtx-sem-mode mode)))
		      (send src 'cxmake-get estate mode #f #f)))
		   (else
		    ;; FIXME: canonicalization should have already caught this
		    (estate-error
		     estate
		     (string-append "sequence temp " (rtx-temp-name src)
				    " referenced in incompatible mode")
		     (obj:name mode))))))

	  ((integer? src)
	   ; Default mode of integer argument is INT.
	   (if (or (mode:eq? 'DFLT mode) (mode:eq? 'VOID mode))
	       (cx:make INT (number->string src))
	       (cx:make mode (number->string src))))

	  ((string? src)
	   ; Default mode of string argument is INT.
	   (if (or (mode:eq? 'DFLT mode) (mode:eq? 'VOID mode))
	       (cx:make INT src)
	       (cx:make mode src)))

	  (else (estate-error estate "/rtl-c-get: invalid argument" src))))
)

;; MODE is either a <mode> object or the mode name.

(define (rtl-c-get estate mode src)
  (let ((mode (mode-maybe-lookup mode)))
    (logit 4 (spaces (estate-depth estate))
	   "(rtl-c-get " (mode-real-name mode) " " (rtx-strdump src) ")\n")
    (let ((result (/rtl-c-get estate mode src)))
      (logit 4 (spaces (estate-depth estate))
	     "(rtl-c-get " (mode-real-name mode) " " (rtx-strdump src) ") => "
	     (cx:c result) "\n")
      result))
)

; Return a <c-expr> object to set the value of DEST to SRC.
; ESTATE is the current rtl evaluation state.
; MODE is the mode of DEST or DFLT which means fetch the real mode from DEST.
; MODE is either a <mode> object or the mode name.
; DEST is one of:
; - <c-expr> node
; - rtl expression (e.g. '(mem QI dr))
; SRC is an RTX expression.  It is important that we evaluate it, instead of
; our caller, because only we know the mode of DEST (which we need to pass
; when evaluating SRC if MODE is DFLT).  ??? Can no longer get DFLT, but
; it feels right to continue to evaluate SRC here.
; The mode of the result is always VOID (void).
;
; ??? One possible optimization is to pass the address of the result
; to the computation of SRC.  Seems dodgey though.

(define (rtl-c-set-quiet estate mode dest src)
  ;(display (list 'rtl-c-set-quiet mode dest src)) (newline)
  (let* ((mode (mode-maybe-lookup mode))
	 (xdest (cond ((c-expr? dest)
		       dest)
		      ((rtx? dest)
		       (rtx-eval-with-estate dest mode estate))
		      (else
		       (estate-error estate
				     "rtl-c-set-quiet: invalid dest"
				     dest)))))
    (assert (mode? mode))
    (if (not (object? xdest))
	(estate-error estate "rtl-c-set-quiet: invalid dest" dest))
    (cx:make VOID (send xdest 'gen-set-quiet
			estate mode #f #f
			(rtl-c-get estate mode src))))
)

; Same as rtl-c-set-quiet except also print TRACE_RESULT message.
; MODE is either a <mode> object or the mode name.
; ??? One possible change is to defer the (rtl-c-get src) call to dest's
; set handler.  Such sources would be marked accordingly and rtl-c-get
; would recognize them.  This would allow, for example, passing the address
; of the result to the computation.

(define (rtl-c-set-trace estate mode dest src)
  ;(display (list 'rtl-c-set-trace mode dest src)) (newline)
  (let* ((mode (mode-maybe-lookup mode))
	 (xdest (cond ((c-expr? dest)
		       dest)
		      ((rtx? dest)
		       (rtx-eval-with-estate dest mode estate))
		      (else
		       (estate-error estate
				     "rtl-c-set-trace: invalid dest"
				     dest)))))
    (assert (mode? mode))
    (if (not (object? xdest))
	(estate-error estate "rtl-c-set-trace: invalid dest" dest))
    (cx:make VOID (send xdest 'gen-set-trace
			estate mode #f #f
			(rtl-c-get estate mode src))))
)

; Emit C code for each rtx function.

; Table mapping rtx function to C generator.

(define /rtl-c-gen-table #f)

; Return the C generator for <rtx-func> F.

(define (rtl-c-generator f)
  (vector-ref /rtl-c-gen-table (rtx-num f))
)

; Support for explicit C/C++ code.
; MODE is the mode name.
; ??? Actually, "support for explicit foreign language code".
; s-c-call needs a better name but "unspec" seems like obfuscation.
; ??? Need to distinguish owner of call (cpu, ???).

(define (s-c-call estate mode name . args)
  (cx:make mode
	   (string-append
	    (if (estate-output-language-c++? estate)
		(string-append "current_cpu->" name " (")
		; FIXME: Prepend @@cpu@@_ to name here, and delete @@cpu@@_ from
		; description file.
		(string-append name " (current_cpu"))
	    (let ((c-args
		   (string-map (lambda (arg)
				 (string-append
				  ", "
				  (cx:c (rtl-c-get estate DFLT arg))))
			       args)))
	      (if (estate-output-language-c++? estate)
		  (string-drop 2 c-args)
		  c-args))
	    ; If the mode is VOID, this is a statement.
	    ; Otherwise it's an expression.
	    ; ??? Bad assumption!  VOID expressions may be used
	    ; within sequences without local vars, which are translated
	    ; to comma-expressions.
	    (if (or (mode:eq? 'DFLT mode) ;; FIXME: can't get DFLT anymore
		    (mode:eq? 'VOID mode))
		");\n"
		")")
	    ))
)

; Same as c-call except there is no particular owner of the call.
; In general this means making a call to a non-member function,
; whereas c-call makes calls to member functions (in C++ parlance).
; MODE is the mode name.

(define (s-c-raw-call estate mode name . args)
  (cx:make mode
	   (string-append
	    name " ("
	    (string-drop 2
			 (string-map (lambda (elm)
				       (string-append
					", " (cx:c (rtl-c-get estate DFLT elm))))
				     args))
	    ; If the mode is VOID, this is a statement.
	    ; Otherwise it's an expression.
	    ; ??? Bad assumption!  VOID expressions may be used
	    ; within sequences without local vars, which are translated
	    ; to comma-expressions.
	    (if (or (mode:eq? 'DFLT mode) ;; FIXME: can't get DFLT anymore
		    (mode:eq? 'VOID mode))
		");\n"
		")")
	    ))
)

; Standard arithmetic operations.

; Return a boolean indicating if a cover function/macro should be emitted
; to perform an operation.
; C-OP is a string containing the C operation or #f if there is none.
; MODE is the mode of the operation.

(define (/rtx-use-sem-fn? estate c-op mode)
  ; If no C operation has been provided, use a macro, or
  ; if this is the simulator and MODE is not a host mode, use a macro.
;  (or (not c-op)
;      (and (estate-rtl-cover-fns? estate)
;	   (not (mode:host? mode))))
  ; FIXME: The current definition is a temporary hack while host/target-ness
  ; of INT/UINT is unresolved.
  (and (not (obj-has-attr? mode 'FORCE-C))
       (or (not c-op)
	   (and (estate-rtl-cover-fns? estate)
		;; NOTE: We can't check (insn? (estate-owner estate)) here.
		;; It's not necessarily present for semantic fragments.
		(or (estate-for-insn? estate)
		    (not (mode:host? mode))))))
)

; One operand referenced, result is in same mode.
; MODE is the mode name.

(define (s-unop estate name c-op mode src)
  (let* ((val (rtl-c-get estate mode src))
	 ; Refetch mode in case it was DFLT and ensure unsigned->signed.
	 (mode (mode:lookup mode)) ;;(cx:mode val)) ;; FIXME: can't get DFLT anymore
	 (sem-mode (rtx-sem-mode mode)))
    ; FIXME: Argument checking.

    (if (/rtx-use-sem-fn? estate c-op mode)
	(if (mode-float? mode)
	    (cx:make sem-mode
		     (string-append "CGEN_CPU_FPU (current_cpu)->ops->"
				    (string-downcase name)
				    (string-downcase (obj:str-name sem-mode))
				    " (CGEN_CPU_FPU (current_cpu), "
				    (cx:c val) ")"))
	    (cx:make sem-mode
		     (string-append name (obj:str-name sem-mode)
				    " (" (cx:c val) ")")))
	(cx:make mode ; not sem-mode on purpose
		 (string-append "(" c-op " ("
				(cx:c val) "))"))))
)

; Two operands referenced in the same mode producing a result in the same mode.
; MODE is the mode name.
;
; ??? Will eventually want to handle floating point modes specially.  Since
; bigger modes may get clumsily passed (there is no pass by reference in C) and
; since we want to eventually handle lazy transformation, FP values could be
; passed by reference.  This is easy in C++.  C requires more work and is
; defered until it's warranted.
; Implementing this should probably be via a new cxmake-get-ref method,
; rather then complicating cxmake-get.  Ditto for rtl-c-get-ref/rtl-c-get.

(define (s-binop estate name c-op mode src1 src2)
  ;(display (list "binop " name ", mode " mode)) (newline)
  (let* ((val1 (rtl-c-get estate mode src1))
	 ; Refetch mode in case it was DFLT and ensure unsigned->signed.
	 (mode (mode:lookup mode)) ;;(cx:mode val1)) ;; FIXME: can't get DFLT anymore
	 (sem-mode (rtx-sem-mode mode))
	 (val2 (rtl-c-get estate mode src2)))
    ; FIXME: Argument checking.

    (if (/rtx-use-sem-fn? estate c-op mode)
	(if (mode-float? mode)
	    (cx:make sem-mode
		     (string-append "CGEN_CPU_FPU (current_cpu)->ops->"
				    (string-downcase name)
				    (string-downcase (obj:str-name sem-mode))
				    " (CGEN_CPU_FPU (current_cpu), "
				    (cx:c val1) ", "
				    (cx:c val2) ")"))
	    (cx:make sem-mode
		     (string-append name (obj:str-name sem-mode)
				    " (" (cx:c val1) ", "
				    (cx:c val2) ")")))
	(cx:make mode ; not sem-mode on purpose
		 (string-append "(("
				(cx:c val1)
				") " c-op " ("
				(cx:c val2)
				"))"))))
)

; Same as s-binop except there's a third argument which is always one bit.
; MODE is the mode name.

(define (s-binop-with-bit estate name mode src1 src2 src3)
  (let* ((val1 (rtl-c-get estate mode src1))
	 ; Refetch mode in case it was DFLT and ensure unsigned->signed.
	 (mode (mode:lookup mode)) ;;(cx:mode val1)) ;; FIXME: can't get DFLT anymore
	 (sem-mode (rtx-sem-mode mode))
	 (val2 (rtl-c-get estate mode src2))
	 (val3 (rtl-c-get estate 'BI src3)))
    ; FIXME: Argument checking.

    (cx:make mode
	  (string-append name (obj:str-name sem-mode)
			 " ("
			 (cx:c val1) ", "
			 (cx:c val2) ", "
			 (cx:c val3)
			 ")")))
)

; Shift operations are slightly different than binary operations:
; the mode of src2 is any integral mode.
; MODE is the mode name.
; ??? Note that some cpus have a signed shift left that is semantically
; different from a logical one.  May need to create `sla' some day.  Later.

(define (s-shop estate name c-op mode src1 src2)
  ;(display (list "shop " name ", mode " mode)) (newline)
  (let* ((val1 (rtl-c-get estate mode src1))
	 ; Refetch mode in case it was DFLT and ensure unsigned->signed
	 ; [sign of operation is determined from operation name, not mode].
	 (mode (mode:lookup mode)) ;;(cx:mode val1)) ;; FIXME: can't get DFLT anymore
	 (sem-mode (rtx-sem-mode mode))
	 (val2 (rtl-c-get estate mode src2)))
    ; FIXME: Argument checking.

    (if (/rtx-use-sem-fn? estate c-op mode)
	(cx:make sem-mode
		 (string-append name (obj:str-name sem-mode)
				" (" (cx:c val1) ", "
				(cx:c val2) ")"))
	(cx:make mode ; not sem-mode on purpose
		 (string-append "("
				;; Ensure correct sign of shift.
				(cond ((equal? name "SRL")
				       (string-append
					"("
					(cond ((mode-unsigned? mode) (mode:c-type mode))
					      ((mode:eq? mode 'INT) (mode:c-type UINT))
					      (else (mode:c-type (mode-find (mode:bits mode) 'UINT))))
					") "))
				      ((equal? name "SRA")
				       (string-append
					"("
					(cond ((mode-signed? mode) (mode:c-type mode))
					      ((mode:eq? mode 'UINT) (mode:c-type INT))
					      (else (mode:c-type (mode-find (mode:bits mode) 'INT))))
					") "))
				      ;; May wish to make this unsigned if not
				      ;; already.  Later.
				      (else ""))
				"(" (cx:c val1) ") "
				c-op
				" (" (cx:c val2) "))"))))
)

; Process andif, orif.
; SRC1 and SRC2 have any arithmetic mode.
; MODE is the mode name.
; The result has mode BI.
; ??? May want to use INT as BI may introduce some slowness
; in the generated code.

(define (s-boolifop estate name c-op src1 src2)
  (let* ((val1 (rtl-c-get estate DFLT src1))
	 (val2 (rtl-c-get estate DFLT src2)))
    ; FIXME: Argument checking.

    ; If this is the simulator and MODE is not a host mode, use a macro.
    ; ??? MODE here being the mode of SRC1.  Maybe later.
    (if (estate-rtl-cover-fns? estate)
	(cx:make (mode:lookup 'BI)
		 (string-append name ; "BI", leave off mode, no need for it
				" (" (cx:c val1) ", "
				(cx:c val2) ")"))
	(cx:make (mode:lookup 'BI)
		 (string-append "(("
				(cx:c val1)
				") " c-op " ("
				(cx:c val2)
				"))"))))
)

;; Process fp predicates, e.g. nan, qnan, snan.
;; SRC-MODE is the mode name of SRC.
;; The result has mode BI.

(define (s-float-predop estate name src-mode src)
  (let* ((val (rtl-c-get estate src-mode src))
	 (mode (cx:mode val))
	 (sem-mode (rtx-sem-mode mode)))
    ;; FIXME: Argument checking.

    (if (not (mode-float? mode))
	(estate-error estate "non floating-point mode" src-mode))

    (cx:make (mode:lookup 'BI)
	     (string-append "CGEN_CPU_FPU (current_cpu)->ops->"
			    (string-downcase name)
			    (string-downcase (obj:str-name sem-mode))
			    " (CGEN_CPU_FPU (current_cpu), "
			    (cx:c val) ")")))
)

;; Integer mode conversions.
;; MODE is the mode name.

(define (s-int-convop estate name mode s1)
  ;; Get S1 in its normal mode, then convert.
  (let ((s (rtl-c-get estate DFLT s1))
	(mode (mode:lookup mode)))
    (if (and (not (estate-rtl-cover-fns? estate))
	     (mode:host? (cx:mode s)))
	(cx:make mode
		 (string-append "((" (obj:str-name mode) ")"
				" (" (obj:str-name (cx:mode s)) ")"
				" (" (cx:c s) "))"))
	(cx:make mode
		 (string-append name
				(obj:str-name (rtx-sem-mode (cx:mode s)))
				(obj:str-name (rtx-sem-mode mode))
				" (" (cx:c s) ")"))))
)

;; Floating point mode conversions.
;; MODE is the mode name.

(define (s-float-convop estate name mode how1 s1)
  ;; Get S1 in its normal mode, then convert.
  (let ((s (rtl-c-get estate DFLT s1))
	(mode (mode:lookup mode))
	(how (rtl-c-get estate DFLT how1)))
    (if (and (not (estate-rtl-cover-fns? estate))
	     (mode:host? (cx:mode s)))
	(cx:make mode
		 (string-append "((" (obj:str-name mode) ")"
				" (" (obj:str-name (cx:mode s)) ")"
				" (" (cx:c s) "))"))
	(cx:make mode
		 (string-append "CGEN_CPU_FPU (current_cpu)->ops->"
				(string-downcase name)
				(string-downcase (obj:str-name (rtx-sem-mode (cx:mode s))))
				(string-downcase (obj:str-name (rtx-sem-mode mode)))
				" (CGEN_CPU_FPU (current_cpu), "
				(cx:c how) ", "
				(cx:c s) ")"))))
)

; Compare SRC1 and SRC2 in mode MODE.
; NAME is one of eq,ne,lt,le,gt,ge,ltu,leu,gtu,geu.
; MODE is the mode name.
; The result has mode BI.
; ??? May want a host int mode result as BI may introduce some slowness
; in the generated code.

(define (s-cmpop estate name c-op mode src1 src2)
  (let* ((val1 (rtl-c-get estate mode src1))
	 ; Refetch mode in case it was DFLT.
	 (mode (mode:lookup mode)) ;;(cx:mode val1)) ;; FIXME: can't get DFLT anymore
	 (val2 (rtl-c-get estate mode src2)))
    ; FIXME: Argument checking.

    ; If no C operation has been provided, use a macro, or
    ; if this is the simulator and MODE is not a host mode, use a macro.
    (if (/rtx-use-sem-fn? estate c-op mode)
	(if (mode-float? mode)
	    (cx:make (mode:lookup 'BI)
		     (string-append "CGEN_CPU_FPU (current_cpu)->ops->"
				    (string-downcase (symbol->string name))
				    (string-downcase (obj:str-name (rtx-sem-mode mode)))
				    " (CGEN_CPU_FPU (current_cpu), "
				    (cx:c val1) ", "
				    (cx:c val2) ")"))
	    (cx:make (mode:lookup 'BI)
		     (string-append (string-upcase (symbol->string name))
				    (if (memq name '(eq ne))
					(obj:str-name (rtx-sem-mode mode))
					(obj:str-name mode))
				    " (" (cx:c val1) ", "
				    (cx:c val2) ")")))
	(cx:make (mode:lookup 'BI)
		 (string-append "(("
				(cx:c val1)
				") " c-op " ("
				(cx:c val2)
				"))"))))
)

; Conditional execution.

; `if' in RTL has a result, like ?: in C.
; We support both: one with a result (non VOID mode), and one without (VOID mode).
; The non-VOID case must have an else part.
; MODE is the mode of the result, not the comparison.
; MODE is the mode name.
; The comparison is expected to return a zero/non-zero value.
; ??? Perhaps this should be a syntax-expr.  Later.

(define (s-if estate mode cond then . else)
  (if (> (length else) 1)
      (estate-error estate "if: too many elements in `else' part" else))
  (let ()
    (if (or (mode:eq? 'DFLT mode) ;; FIXME: can't get DFLT anymore
	    (mode:eq? 'VOID mode))
	(cx:make mode
		 (string-append "if (" (cx:c (rtl-c-get estate DFLT cond)) ")"
				" {\n" (cx:c (rtl-c-get estate mode then)) "}"
				(if (not (null? else))
				    (string-append " else {\n"
						   (cx:c (rtl-c-get estate mode (car else)))
						   "}\n")
				    "\n")
				))
	(if (= (length else) 1)
	    (cx:make mode
		     (string-append "(("
				    (cx:c (rtl-c-get estate DFLT cond))
				    ") ? ("
				    (cx:c (rtl-c-get estate mode then))
				    ") : ("
				    (cx:c (rtl-c-get estate mode (car else)))
				    "))"))
	    (estate-error estate "non-void-mode `if' must have `else' part"))))
)

; A multiway `if'.
; MODE is the mode name.
; If MODE is VOID emit a series of if/else's.
; If MODE is not VOID, emit a series of ?:'s.
; COND-CODE-LIST is a list of lists, each sublist is a list of two elements:
; condition, code.  The condition part must return a zero/non-zero value, and
; the code part is treated as a `sequence'.
; This defer argument evaluation, the syntax
; ((... condition ...) ... action ...)
; needs special parsing.
; FIXME: Need more error checking of arguments.

(define (s-cond estate mode . cond-code-list)
  ;; FIXME: can't get DFLT anymore
  (let ((vm? (or (mode:eq? 'DFLT mode) (mode:eq? 'VOID mode))))
    (if (null? cond-code-list)
	(estate-error estate "empty `cond'"))
    (let ((if-part (if vm?  "if (" "("))
	  (then-part (if vm? ") " ") ? "))
	  (elseif-part (if vm? " else if (" " : ("))
	  (else-part (if vm? " else " " : "))
	  (fi-part (if vm? "" ")")))
      (let loop ((result
		  (string-append
		   if-part
		   (cx:c (rtl-c-get estate DFLT (caar cond-code-list)))
		   then-part
		   (cx:c (apply s-sequence
				(cons estate
				      (cons mode
					    (cons nil
						  (cdar cond-code-list))))))))
		 (ccl (cdr cond-code-list)))
	(cond ((null? ccl) (cx:make mode result))
	      ((eq? (caar ccl) 'else)
	       (cx:make mode
			(string-append
			 result
			 else-part
			 (cx:c (apply s-sequence
				      (cons estate
					    (cons mode
						  (cons nil
							(cdar ccl)))))))))
	      (else (loop (string-append
			   result
			   elseif-part
			   (cx:c (rtl-c-get estate DFLT (caar ccl)))
			   then-part
			   (cx:c (apply s-sequence
					(cons estate
					      (cons mode
						    (cons nil
							  (cdar ccl)))))))
			  (cdr ccl)))))))
)

; Utility of s-case to print a case prefix (for lack of a better term).

(define (/gen-case-prefix val)
  (string-append "  case "
		 (cond ((number? val)
			(number->string val))
		       ((symbol? val)
			(string-upcase (gen-c-symbol val))) ; yes, upcase
		       ((string? val) val)
		       (else
			(parse-error (make-prefix-context "case:")
				     "bad case" val)))
		 " : ")
)

; Utility of s-case to handle a void result.

(define (s-case-vm estate test case-list)
  (cx:make
   VOID
   (string-append
    "  switch ("
    (cx:c (rtl-c-get estate DFLT test))
    ")\n"
    "  {\n"
    (string-map (lambda (case-entry)
		  (let ((caseval (car case-entry))
			(code (cdr case-entry)))
		    (string-append
		     (cond ((list? caseval)
			    (string-map /gen-case-prefix caseval))
			   ((eq? 'else caseval)
			    (string-append "  default : "))
			   (else
			    (/gen-case-prefix caseval)))
		     (cx:c (apply s-sequence
				  (cons estate (cons VOID (cons nil code)))))
		     "    break;\n")))
		case-list)
    "  }\n"))
)

; Utility of s-case-non-vm to generate code to perform the test.
; MODE is the mode name.

(define (/gen-non-vm-case-test estate mode test cases)
  (assert (not (null? cases)))
  (let loop ((result "") (cases cases))
    (if (null? cases)
	result
	(let ((case (cond ((number? (car cases))
			   (car cases))
			  ((symbol? (car cases))
			   (if (enum-lookup-val (car cases))
			       (rtx-make 'enum mode (car cases))
			       (estate-error estate
					     "symbol not an enum"
					     (car cases))))
			  (else
			   (estate-error estate "invalid case" (car cases))))))
	  (loop (string-append
		 result
		 (if (= (string-length result) 0)
		     ""
		     " || ")
		 (cx:c (rtl-c-get estate mode test))
		 " == "
		 (cx:c (rtl-c-get estate mode case)))
		(cdr cases)))))
)

; Utility of s-case to handle a non-void result.
; This is expanded as a series of ?:'s.
; MODE is the mode name.

(define (s-case-non-vm estate mode test case-list)
  (let ((if-part "(")
	(then-part ") ? ")
	(elseif-part " : (")
	(else-part " : ")
	(fi-part ")"))
    (let loop ((result
		(string-append
		 if-part
		 (/gen-non-vm-case-test estate mode test (caar case-list))
		 then-part
		 (cx:c (apply s-sequence
			      (cons estate
				    (cons mode
					  (cons nil
						(cdar case-list))))))))
	       (cl (cdr case-list)))
      (cond ((null? cl) (cx:make mode result))
	    ((eq? (caar cl) 'else)
	     (cx:make mode
		      (string-append
		       result
		       else-part
		       (cx:c (apply s-sequence
				    (cons estate
					  (cons mode
						(cons nil
						      (cdar cl)))))))))
	    (else (loop (string-append
			 result
			 elseif-part
			 (/gen-non-vm-case-test estate mode test (caar cl))
			 then-part
			 (cx:c (apply s-sequence
				      (cons estate
					    (cons mode
						  (cons nil
							(cdar cl)))))))
			(cdr cl))))))
)

; C switch statement
; To follow convention, MODE is the first arg.
; MODE is the mode name.
; FIXME: What to allow for case choices is wip.

(define (s-case estate mode test . case-list)
  ;; FIXME: can't get DFLT anymore
  (if (or (mode:eq? 'DFLT mode) (mode:eq? 'VOID mode))
      (s-case-vm estate test case-list)
      (s-case-non-vm estate mode test case-list))
)

; Parallels and Sequences

; Temps for `parallel' are recorded differently than for `sequence'.
; ??? I believe this is because there was an interaction between the two.

(define /par-temp-list nil)

; Record a temporary needed for a parallel in mode MODE.
; We just need to record the mode with a unique name so we use a <c-expr>
; object where the "expression" is the variable's name.

(define (/par-new-temp! mode)
  (set! /par-temp-list
	(cons (cx:make mode (string-append "temp"
					   (number->string
					    (length /par-temp-list))))
	      /par-temp-list))
  (car /par-temp-list)
)

; Return the next temp from the list, and leave the list pointing to the
; next one.

(define (/par-next-temp!)
  (let ((result (car /par-temp-list)))
    (set! /par-temp-list (cdr /par-temp-list))
    result)
)

(define (/gen-par-temp-defns temp-list)
  ;(display temp-list) (newline)
  (string-append
   "  "
   ; ??? mode:c-type
   (string-map (lambda (temp) (string-append (obj:str-name (cx:mode temp))
					     " " (cx:c temp) ";"))
	       temp-list)
   "\n")
)

;; Parallels are handled by converting them into two sequences.  The first has
;; all set destinations replaced with temps, and the second has all set sources
;; replaced with those temps.

;; rtl-traverse expr-fn to replace the dest of sets with the parallel temp.

(define (/par-replace-set-dest-expr-fn rtx-obj expr parent-expr op-pos
				       tstate appstuff)
  (case (car expr)
    ((set set-quiet)
     (let ((name (rtx-name expr))
	   (options (rtx-options expr))
	   (mode (rtx-mode expr))
	   (dest (rtx-set-dest expr))
	   (src (rtx-set-src expr)))
       (list name options mode (/par-new-temp! mode) src)))
    (else #f))
)

;; rtl-traverse expr-fn to replace the src of sets with the parallel temp.
;; This must process expressions in the same order as /par-replace-set-dests.

(define (/par-replace-set-src-expr-fn rtx-obj expr parent-expr op-pos
				      tstate appstuff)
  (case (car expr)
    ((set set-quiet)
     (let ((name (rtx-name expr))
	   (options (rtx-options expr))
	   (mode (rtx-mode expr))
	   (dest (rtx-set-dest expr))
	   (src (rtx-set-src expr)))
       (list name options mode dest (/par-next-temp!))))
    (else #f))
)

;; Return a <c-expr> node for a `parallel'.

(define (s-parallel estate . exprs)
  (begin

    ;; Initialize /par-temp-list for /par-replace-set-dests.
    (set! /par-temp-list nil)

    (let* ((set-dest-exprs
	    ;; Use map-in-order because we need temp creation and usage to
	    ;; follow the same order.
	    (map-in-order (lambda (expr)
			    (rtx-traverse (estate-context estate)
					  (estate-owner estate)
					  expr
					  /par-replace-set-dest-expr-fn
					  #f))
			  exprs))
	   (set-dests (string-map (lambda (expr)
				    (rtl-c-with-estate estate VOID expr))
				  set-dest-exprs))
	   (temps (reverse! /par-temp-list)))

      ;; Initialize /par-temp-list for /par-replace-set-srcs.
      (set! /par-temp-list temps)

      (let* ((set-src-exprs
	      ;; Use map-in-order because we need temp creation and usage to
	      ;; follow the same order.
	      (map-in-order (lambda (expr)
			      (rtx-traverse (estate-context estate)
					    (estate-owner estate)
					    expr
					    /par-replace-set-src-expr-fn
					    #f))
			    exprs))
	     (set-srcs (string-map (lambda (expr)
				     (rtl-c-with-estate estate VOID expr))
				    set-src-exprs)))

	(cx:make VOID
		 (string-append
		  ;; ??? do {} while (0); doesn't get "optimized out"
		  ;; internally by gcc, meaning two labels and a loop are
		  ;; created for it to have to process.  We can generate pretty
		  ;; big files and can cause gcc to require *lots* of memory.
		  ;; So let's try just {} ...
		  "{\n"
		  (/gen-par-temp-defns temps)
		  set-dests
		  set-srcs
		  "}\n")
		 ))))
)

;; Subroutine of s-sequence to simplify it.
;; Return a boolean indicating if GCC's "statement expression" extension
;; is necessary to implement (sequence MODE ENV EXPR-LIST).
;; Only use GCC "statement expression" extension if necessary.
;;
;; Avoid using statement expressions for
;; (sequence non-VOID-mode (error "mumble") expr).
;; Some targets, e.g. cris, use this.

(define (/use-gcc-stmt-expr? mode env expr-list)
  (if (not (rtx-env-empty? env))
      #t
      (case (length expr-list)
	((1) #f)
	((2) (if (eq? (rtx-name (car expr-list)) 'error)
		 #f
		 #t))
	(else #t)))
)

;; Return a <c-expr> node for a `sequence'.
;; MODE is the mode name.

(define (s-sequence estate mode env . exprs)
  (let* ((env (rtx-env-make-locals env)) ;; compile env
	 (estate (estate-push-env estate env)))

    (if (or (mode:eq? 'DFLT mode) ;; FIXME: DFLT can't appear anymore
	    (mode:eq? 'VOID mode))

	(cx:make VOID
		 (string-append 
		  ;; ??? do {} while (0); doesn't get "optimized out"
		  ;; internally by gcc, meaning two labels and a loop are
		  ;; created for it to have to process.  We can generate pretty
		  ;; big files and can cause gcc to require *lots* of memory.
		  ;; So let's try just {} ...
		  "{\n"
		  (gen-temp-defs estate env)
		  (string-map (lambda (e)
				(rtl-c-with-estate estate VOID e))
			      exprs)
		  "}\n"))

	(let ((use-stmt-expr? (/use-gcc-stmt-expr? mode env exprs)))
	  (cx:make mode
		   (string-append
		    (if use-stmt-expr? "({ " "(")
		    (gen-temp-defs estate env)
		    (string-drop 2
				 (string-map
				  (lambda (e)
				    (string-append
				     (if use-stmt-expr? "; " ", ")
				     ;; Strip off gratuitous ";\n" at end of expressions that
				     ;; misguessed themselves to be in statement context.
				     ;; See s-c-call, s-c-call-raw above.
				     (let ((substmt (rtl-c-with-estate estate DFLT e)))
				       (if (and (not use-stmt-expr?)
						(string=? (string-take -2 substmt) ";\n"))
					   (string-drop -2 substmt)
					   substmt))))
				  exprs))
		    (if use-stmt-expr? "; })" ")"))))))
)

; Return a <c-expr> node for a `do-count'.

(define (s-do-count estate iter-var nr-times . exprs)
  (let* ((limit-var (rtx-make-iteration-limit-var iter-var))
	 (env (rtx-env-make-iteration-locals iter-var))
	 (estate (estate-push-env estate env))
	 (temp-iter (rtx-temp-lookup (estate-env-stack estate) iter-var))
	 (temp-limit (rtx-temp-lookup (estate-env-stack estate) limit-var))
	 (c-iter-var (rtx-temp-value temp-iter))
	 (c-limit-var (rtx-temp-value temp-limit)))
    (cx:make VOID
	     (string-append
	      "{\n"
	      (gen-temp-defs estate env)
	      "  " c-limit-var " = "
	      (cx:c (rtl-c-get estate (rtx-temp-mode temp-limit) nr-times))
	      ";\n"
	      "  for (" c-iter-var " = 0;\n"
	      "       " c-iter-var " < " c-limit-var ";\n"
	      "       ++" c-iter-var ")\n"
	      "  {\n"
	      (string-map (lambda (e)
			    (rtl-c-with-estate estate VOID e))
			  exprs)
	      "  }\n"
	      "}\n"))
    )
)

; *****************************************************************************
;
; RTL->C generators for each rtx function.

; Return code to set FN as the generator for RTX.

(defmacro define-fn (rtx args expr . rest)
  `(begin
     (assert (rtx-lookup (quote ,rtx)))
     (vector-set! table (rtx-num (rtx-lookup (quote ,rtx)))
		  (lambda ,args ,@@(cons expr rest))))
)

(define (rtl-c-init!)
  (set! /rtl-c-gen-table (/rtl-c-build-table))
  *UNSPECIFIED*
)

; The rest of this file is one big function to return the rtl->c lookup table.
; For each of these functions, MODE is the name of the mode.

(define (/rtl-c-build-table)
  (let ((table (make-vector (rtx-max-num) #f)))

; Error generation

(define-fn error (*estate* options mode message)
  (let ((c-call (s-c-call *estate* mode "cgen_rtx_error"
			  (string-append "\""
					 (backslash "\"" message)
					 "\""))))
    (if (mode:eq? mode VOID)
	c-call
	(cx:make mode (string-append "(" (cx:c c-call) ", 0)"))))
)

; Enum support

(define-fn enum (*estate* options mode name)
  (cx:make mode (string-upcase (gen-c-symbol name)))
)

; Instruction field support.
; ??? This should build an operand object like -build-ifield-operand! does
; in semantics.scm.

(define-fn ifield (*estate* options mode ifld-name)
  (if (estate-ifield-var? *estate*)
      (cx:make mode (gen-c-symbol ifld-name))
      (cx:make mode (string-append "FLD (" (gen-c-symbol ifld-name) ")")))
;  (let ((f (current-ifld-lookup ifld-name)))
;    (make <operand> (obj-location f) ifld-name ifld-name
;	  (atlist-cons (bool-attr-make 'SEM-ONLY #t)
;		       (obj-atlist f))
;	  (obj:name (ifld-hw-type f))
;	  (obj:name (ifld-mode f))
;	  (make <hw-index> 'anonymous
;		'ifield (ifld-mode f) f)
;	  nil #f #f))
)

;; Operand support.

(define-fn operand (*estate* options mode object-or-name)
  (cond ((operand? object-or-name)
	 ;; FIXME: <operand> objects is what xop is for
	 ;; mode checking to be done during canonicalization
	 object-or-name)
	((symbol? object-or-name)
	 (let ((object (current-op-lookup object-or-name)))
	   (if (not object)
	       (estate-error *estate* "undefined operand" object-or-name))
	   ;; mode checking to be done during canonicalization
	   object))
	(else
	 (estate-error *estate* "bad arg to `operand'" object-or-name)))
)

(define-fn xop (*estate* options mode object)
  (let ((delayed (assoc '#:delay (estate-modifiers *estate*))))
    (if (and delayed
	     (equal? APPLICATION 'SID-SIMULATOR)
	     (operand? object))
	;; if we're looking at an operand inside a (delay ...) rtx, then we
	;; are talking about a _delayed_ operand, which is a different
	;; beast.  rather than try to work out what context we were
	;; constructed within, we just clone the operand instance and set
	;; the new one to have a delayed value. the setters and getters
	;; will work it out.
	(let ((obj (object-copy object))
	      (amount (cadr delayed)))
	  (op:set-delay! obj amount)
	  obj)
	;; else return the normal object
	object)))

(define-fn local (*estate* options mode object-or-name)
  (cond ((rtx-temp? object-or-name)
	 object-or-name)
	((symbol? object-or-name)
	 (let ((object (rtx-temp-lookup (estate-env-stack *estate*) object-or-name)))
	   (if (not object)
	       (estate-error *estate* "undefined local" object-or-name))
	   object))
	(else
	 (estate-error *estate* "bad arg to `local'" object-or-name)))
)

(define-fn reg (*estate* options mode hw-elm . indx-sel)
  (let ((indx (or (list-maybe-ref indx-sel 0) 0))
	(sel (or (list-maybe-ref indx-sel 1) hw-selector-default)))
    (s-hw *estate* mode hw-elm indx sel))
)

(define-fn raw-reg (*estate* options mode hw-elm . indx-sel)
  (let ((indx (or (list-maybe-ref indx-sel 0) 0))
	(sel (or (list-maybe-ref indx-sel 1) hw-selector-default)))
    (let ((result (s-hw *estate* mode hw-elm indx sel)))
      (obj-cons-attr! result (bool-attr-make 'RAW #t))
      result))
)

(define-fn mem (*estate* options mode addr . sel)
  (s-hw *estate* mode 'h-memory addr
	(if (pair? sel) (car sel) hw-selector-default))
)

; ??? Hmmm... needed?  The pc is usually specified as `pc' which is shorthand
; for (operand pc).
;(define-fn pc (*estate* options mode)
;  s-pc
;)

(define-fn ref (*estate* options mode name)
  (if (not (insn? (estate-owner *estate*)))
      (estate-error *estate* "ref: not processing an insn"
		    (obj:name (estate-owner *estate*))))
  (cx:make 'UINT
	   (string-append
	    "(referenced & (1 << "
	    (number->string
	     (op:num (insn-lookup-op (estate-owner *estate*) name)))
	    "))"))
)

; ??? Maybe this should return an operand object.
(define-fn index-of (*estate* options mode op)
  (send (op:index (rtx-eval-with-estate op DFLT *estate*))
	'cxmake-get *estate* (mode:lookup mode))
)

(define-fn clobber (*estate* options mode object)
  (cx:make VOID "; /*clobber*/\n")
)

(define-fn delay (*estate* options mode num-node rtx)
  ;; FIXME: Try to move SID stuff into sid-foo.scm.
  (case APPLICATION
    ((SID-SIMULATOR)
     (let* ((n (cadddr num-node))
	    (old-delay (let ((old (assoc '#:delay (estate-modifiers *estate*))))
			 (if old (cadr old) 0)))
	    (new-delay (+ n old-delay)))    
       (begin
	 ;; check for proper usage
     	 (if (let* ((hw (case (car rtx) 
			  ((operand) (op:type (current-op-lookup (rtx-arg1 rtx))))
			  ((xop) (op:type (rtx-xop-obj rtx)))
			  (else #f))))		    	       
	       (not (and hw (or (pc? hw) (memory? hw) (register? hw)))))
	     (estate-error 
	      *estate*
	      "(delay ...) rtx applied to wrong type of operand, should be pc, register or memory"
	       (car rtx)))
	 ;; signal an error if we're delayed and not in a "parallel-insns" CPU
	 (if (not (with-parallel?)) 
	     (estate-error *estate* "delayed operand in a non-parallel cpu"
			   (car rtx)))
	 ;; update cpu-global pipeline bound
	 (cpu-set-max-delay! (current-cpu) (max (cpu-max-delay (current-cpu)) new-delay))      
	 ;; pass along new delay to embedded rtx
	 (rtx-eval-with-estate rtx (mode:lookup mode)
			       (estate-with-modifiers *estate* `((#:delay ,new-delay)))))))

    ;; not in sid-land
    (else (s-sequence (estate-with-modifiers *estate* '((#:delay))) VOID '() rtx)))
)

; Gets expanded as a macro.
;(define-fn annul (*estate* yes?)
;  (s-c-call *estate* 'VOID "SEM_ANNUL_INSN" "pc" yes?)
;)

(define-fn skip (*estate* options mode yes?)
  (send pc 'cxmake-skip *estate* yes?)
  ;(s-c-call *estate* 'VOID "SEM_SKIP_INSN" "pc" yes?)
)

(define-fn eq-attr (*estate* options mode obj attr-name value)
  (cx:make 'INT
	   (string-append "(GET_ATTR ("
			  (gen-c-symbol attr-name)
			  ") == "
			  (gen-c-symbol value)
			  ")"))
)

(define-fn int-attr (*estate* options mode owner attr-name)
  (cond ((or (equal? owner '(current-insn () DFLT)) ;; FIXME: delete in time
	     (equal? owner '(current-insn () INSN)))
	 (s-c-raw-call *estate* 'INT "GET_ATTR"
		       (string-upcase (gen-c-symbol attr-name))))
	(else
	 (estate-error *estate* "attr: unsupported object type" owner)))
)

(define-fn const (*estate* options mode c)
  (assert (not (mode:eq? 'VOID mode)))
  (if (mode:eq? 'DFLT mode) ;; FIXME: can't get DFLT anymore
      (set! mode 'INT))
  (let ((mode (mode:lookup mode)))
    (cx:make mode
	     (cond ((or (mode:eq? 'DI mode)
			(mode:eq? 'UDI mode)
			(< #xffffffff c)
			(> #x-80000000 c))
		    (string-append "MAKEDI ("
				   (gen-integer (high-part c)) ", "
				   (gen-integer (low-part c))
				   ")"))
		   ((and (<= #x-80000000 c) (> #x80000000 c))
		    (number->string c))
		   ((and (<= #x80000000 c) (>= #xffffffff c))
		    ; ??? GCC complains if not affixed with "U" but that's not k&r.
		    ;(string-append (number->string val) "U"))
		    (string-append "0x" (number->string c 16)))
		   ; Else punt.
		   (else (number->string c)))))
)

(define-fn join (*estate* options out-mode in-mode arg1 . arg-rest)
  ; FIXME: Endianness issues undecided.
  ; FIXME: Ensure correct number of args for in/out modes.
  ; Ensure compatible modes.
  (apply s-c-raw-call (cons *estate*
			    (cons out-mode
				  (cons (stringsym-append "JOIN"
							  in-mode
							  out-mode)
					(cons arg1 arg-rest)))))
)

(define-fn subword (*estate* options mode value word-num)
  (let* ((mode (mode:lookup mode))
	 (val (rtl-c-get *estate* DFLT value))
	 (val-mode (cx:mode val)))
    (cx:make mode
	     (string-append "SUBWORD"
			    (obj:str-name val-mode) (obj:str-name mode)
			    " (" (cx:c val)
			    (if (mode-bigger? val-mode mode)
				(string-append
				 ", "
				 (if (number? word-num)
				     (number->string word-num)
				     (cx:c (rtl-c-get *estate* DFLT word-num))))
				"")
			    ")")))
)

(define-fn c-code (*estate* options mode text)
  (cx:make mode text)
)

(define-fn c-call (*estate* options mode name . args)
  (apply s-c-call (cons *estate* (cons mode (cons name args))))
)

(define-fn c-raw-call (*estate* options mode name . args)
  (apply s-c-raw-call (cons *estate* (cons mode (cons name args))))
)

(define-fn nop (*estate* options mode)
  (cx:make VOID "((void) 0); /*nop*/\n")
)

(define-fn set (*estate* options mode dst src)
  (if (estate-for-insn? *estate*)
      (rtl-c-set-trace *estate* mode dst src)
      (rtl-c-set-quiet *estate* mode dst src))
)

(define-fn set-quiet (*estate* options mode dst src)
  (rtl-c-set-quiet *estate* mode dst src)
)

(define-fn neg (*estate* options mode s1)
  (s-unop *estate* "NEG" "-" mode s1)
)

(define-fn abs (*estate* options mode s1)
  (s-unop *estate* "ABS" #f mode s1)
)

(define-fn inv (*estate* options mode s1)
  (s-unop *estate* "INV" "~" mode s1)
)

(define-fn not (*estate* options mode s1)
  (s-unop *estate* "NOT" "!" mode s1)
)

(define-fn add (*estate* options mode s1 s2)
  (s-binop *estate* "ADD" "+" mode s1 s2)
)
(define-fn sub (*estate* options mode s1 s2)
  (s-binop *estate* "SUB" "-" mode s1 s2)
)

(define-fn addc (*estate* options mode s1 s2 s3)
  (s-binop-with-bit *estate* "ADDC" mode s1 s2 s3)
)
;; ??? Whether to rename ADDCF/ADDOF -> ADDCCF/ADDCOF is debatable.
(define-fn addc-cflag (*estate* options mode s1 s2 s3)
  (s-binop-with-bit *estate* "ADDCF" mode s1 s2 s3)
)
(define-fn addc-oflag (*estate* options mode s1 s2 s3)
  (s-binop-with-bit *estate* "ADDOF" mode s1 s2 s3)
)

(define-fn subc (*estate* options mode s1 s2 s3)
  (s-binop-with-bit *estate* "SUBC" mode s1 s2 s3)
)
;; ??? Whether to rename SUBCF/SUBOF -> SUBCCF/SUBCOF is debatable.
(define-fn subc-cflag (*estate* options mode s1 s2 s3)
  (s-binop-with-bit *estate* "SUBCF" mode s1 s2 s3)
)
(define-fn subc-oflag (*estate* options mode s1 s2 s3)
  (s-binop-with-bit *estate* "SUBOF" mode s1 s2 s3)
)

;; ??? These are deprecated.  Delete in time.
(define-fn add-cflag (*estate* options mode s1 s2 s3)
  (s-binop-with-bit *estate* "ADDCF" mode s1 s2 s3)
)
(define-fn add-oflag (*estate* options mode s1 s2 s3)
  (s-binop-with-bit *estate* "ADDOF" mode s1 s2 s3)
)
(define-fn sub-cflag (*estate* options mode s1 s2 s3)
  (s-binop-with-bit *estate* "SUBCF" mode s1 s2 s3)
)
(define-fn sub-oflag (*estate* options mode s1 s2 s3)
  (s-binop-with-bit *estate* "SUBOF" mode s1 s2 s3)
)

;(define-fn zflag (*estate* options mode value)
;  (list 'eq mode value (list 'const mode 0))
;)

;(define-fn nflag (*estate* options mode value)
;  (list 'lt mode value (list 'const mode 0))
;)

(define-fn mul (*estate* options mode s1 s2)
  (s-binop *estate* "MUL" "*" mode s1 s2)
)
; 1's complement overflow
(define-fn mul-o1flag (*estate* options mode s1 s2)
  (s-binop *estate* "MUL1OF" #f mode s1 s2)
)
; 2's complement overflow
(define-fn mul-o2flag (*estate* options mode s1 s2)
  (s-binop *estate* "MUL2OF" #f mode s1 s2)
)
(define-fn div (*estate* options mode s1 s2)
  (s-binop *estate* "DIV" "/" mode s1 s2)
)
(define-fn udiv (*estate* options mode s1 s2)
  (s-binop *estate* "UDIV" "/" mode s1 s2)
)
(define-fn mod (*estate* options mode s1 s2)
  (s-binop *estate* "MOD" "%" mode s1 s2)
)
(define-fn umod (*estate* options mode s1 s2)
  (s-binop *estate* "UMOD" "%" mode s1 s2)
)
(define-fn rem (*estate* options mode s1 s2)
  (s-binop *estate* "REM" #f mode s1 s2)
)

(define-fn sqrt (*estate* options mode s1)
  (s-unop *estate* "SQRT" #f mode s1)
)
(define-fn cos (*estate* options mode s1)
  (s-unop *estate* "COS" #f mode s1)
)
(define-fn sin (*estate* options mode s1)
  (s-unop *estate* "SIN" #f mode s1)
)

(define-fn nan (*estate* options mode s1)
  (s-float-predop *estate* "NAN" mode s1)
)
(define-fn qnan (*estate* options mode s1)
  (s-float-predop *estate* "QNAN" mode s1)
)
(define-fn snan (*estate* options mode s1)
  (s-float-predop *estate* "SNAN" mode s1)
)

(define-fn min (*estate* options mode s1 s2)
  (s-binop *estate* "MIN" #f mode s1 s2)
)
(define-fn max (*estate* options mode s1 s2)
  (s-binop *estate* "MAX" #f mode s1 s2)
)
(define-fn umin (*estate* options mode s1 s2)
  (s-binop *estate* "UMIN" #f mode s1 s2)
)
(define-fn umax (*estate* options mode s1 s2)
  (s-binop *estate* "UMAX" #f mode s1 s2)
)

(define-fn and (*estate* options mode s1 s2)
  (s-binop *estate* "AND" "&" mode s1 s2)
)
(define-fn or (*estate* options mode s1 s2)
  (s-binop *estate* "OR" "|" mode s1 s2)
)
(define-fn xor (*estate* options mode s1 s2)
  (s-binop *estate* "XOR" "^" mode s1 s2)
)

(define-fn sll (*estate* options mode s1 s2)
  (s-shop *estate* "SLL" "<<" mode s1 s2)
)
(define-fn srl (*estate* options mode s1 s2)
  (s-shop *estate* "SRL" ">>" mode s1 s2)
)
(define-fn sra (*estate* options mode s1 s2)
  (s-shop *estate* "SRA" ">>" mode s1 s2)
)
(define-fn ror (*estate* options mode s1 s2)
  (s-shop *estate* "ROR" #f mode s1 s2)
)
(define-fn rol (*estate* options mode s1 s2)
  (s-shop *estate* "ROL" #f mode s1 s2)
)

(define-fn andif (*estate* options mode s1 s2)
  (s-boolifop *estate* "ANDIF" "&&" s1 s2)
)
(define-fn orif (*estate* options mode s1 s2)
  (s-boolifop *estate* "ORIF" "||" s1 s2)
)

(define-fn ext (*estate* options mode s1)
  (s-int-convop *estate* "EXT" mode s1)
)
(define-fn zext (*estate* options mode s1)
  (s-int-convop *estate* "ZEXT" mode s1)
)
(define-fn trunc (*estate* options mode s1)
  (s-int-convop *estate* "TRUNC" mode s1)
)

(define-fn fext (*estate* options mode how s1)
  (s-float-convop *estate* "FEXT" mode how s1)
)
(define-fn ftrunc (*estate* options mode how s1)
  (s-float-convop *estate* "FTRUNC" mode how s1)
)
(define-fn float (*estate* options mode how s1)
  (s-float-convop *estate* "FLOAT" mode how s1)
)
(define-fn ufloat (*estate* options mode how s1)
  (s-float-convop *estate* "UFLOAT" mode how s1)
)
(define-fn fix (*estate* options mode how s1)
  (s-float-convop *estate* "FIX" mode how s1)
)
(define-fn ufix (*estate* options mode how s1)
  (s-float-convop *estate* "UFIX" mode how s1)
)

(define-fn eq (*estate* options mode s1 s2)
  (s-cmpop *estate* 'eq "==" mode s1 s2)
)
(define-fn ne (*estate* options mode s1 s2)
  (s-cmpop *estate* 'ne "!=" mode s1 s2)
)

(define-fn lt (*estate* options mode s1 s2)
  (s-cmpop *estate* 'lt "<" mode s1 s2)
)
(define-fn le (*estate* options mode s1 s2)
  (s-cmpop *estate* 'le "<=" mode s1 s2)
)
(define-fn gt (*estate* options mode s1 s2)
  (s-cmpop *estate* 'gt ">" mode s1 s2)
)
(define-fn ge (*estate* options mode s1 s2)
  (s-cmpop *estate* 'ge ">=" mode s1 s2)
)

(define-fn ltu (*estate* options mode s1 s2)
  (s-cmpop *estate* 'ltu "<" mode s1 s2)
)
(define-fn leu (*estate* options mode s1 s2)
  (s-cmpop *estate* 'leu "<=" mode s1 s2)
)
(define-fn gtu (*estate* options mode s1 s2)
  (s-cmpop *estate* 'gtu ">" mode s1 s2)
)
(define-fn geu (*estate* options mode s1 s2)
  (s-cmpop *estate* 'geu ">=" mode s1 s2)
)

(define-fn member (*estate* options mode value set)
  ;; NOTE: There are multiple evalutions of VALUE in the generated code.
  ;; It's probably ok, this comment is more for completeness sake.
  (let ((c-value (rtl-c-get *estate* mode value))
	(set (rtx-number-list-values set)))
    (let loop ((set (cdr set))
	       (code (string-append "(" (cx:c c-value)
				    " == "
				    (gen-integer (car set))
				    ")")))
      (if (null? set)
	  (cx:make (mode:lookup 'BI) (string-append "(" code ")"))
	  (loop (cdr set)
		(string-append code
			       " || ("
			       (cx:c c-value)
			       " == "
			       (gen-integer (car set))
			       ")")))))
)

(define-fn if (*estate* options mode cond then . else)
  (apply s-if (append! (list *estate* mode cond then) else))
)

(define-fn cond (*estate* options mode . cond-code-list)
  (apply s-cond (cons *estate* (cons mode cond-code-list)))
)

(define-fn case (*estate* options mode test . case-list)
  (apply s-case (cons *estate* (cons mode (cons test case-list))))
)

(define-fn parallel (*estate* options mode ignore expr . exprs)
  (apply s-parallel (cons *estate* (cons expr exprs)))
)

(define-fn sequence (*estate* options mode locals expr . exprs)
  (apply s-sequence
	 (cons *estate* (cons mode (cons locals (cons expr exprs)))))
)

(define-fn do-count (*estate* options mode iter-var nr-times expr . exprs)
  (apply s-do-count
	 (cons *estate* (cons iter-var (cons nr-times (cons expr exprs)))))
)

(define-fn closure (*estate* options mode isa-name-list env-stack expr)
  (rtl-c-with-estate (estate-make-closure *estate* isa-name-list
					  (rtx-make-env-stack env-stack))
		     (mode:lookup mode) expr)
)

;; The result is the rtl->c generator table.
;; FIXME: verify all elements are filled

table

)) ;; End of /rtl-c-build-table
@


1.32
log
@	* rtl-c.scm (s-float-predop): New function.
	(nan, qnan, snan): Call it.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2005, 2009, 2010 Red Hat, Inc.
d1749 8
d1769 3
@


1.31
log
@	* desc-cpu.scm (cgen-desc.h): Don't print virtual enums.
	* sid-cpu.scm (cgen-desc.h): Ditto.
	* enum.scm (enum-builtin!): New function.
	* read.scm (reader-install-builtin!): Call it.
	* rtl-c.scm (s-convop): Delete, replaced with ...
	(s-int-convop, s-float-convop): ... new fns.
	(ext, zext, trunc): Update.
	(fext, ftrunc, float, ufloat, fix, ufix): Update.
	* rtx-funcs.scm (fext, ftrunc, float, ufloat, fix, ufix): New parameter
	`how'.
	* cpu/mep-fmax.cpu (fcvtsw): Update.
	* cpu/sh.cpu (h-fsd, h-fmov): Update.
	* doc/rtl.texi (float-convop): Update.

	* frv.cpu (floating-point-conversion): Update call to fp conv op.
	(floating-point-dual-conversion, ne-floating-point-dual-conversion,
	conditional-floating-point-conversion, ne-floating-point-conversion,
	float-parallel-mul-add-double-semantics): Ditto.
@
text
@d831 21
d1773 1
a1773 1
  (s-unop *estate* "NAN" #f mode s1)
d1776 1
a1776 1
  (s-unop *estate* "QNAN" #f mode s1)
d1779 1
a1779 1
  (s-unop *estate* "SNAN" #f mode s1)
@


1.30
log
@	* rtx-funcs.scm (nan,qnan,snan): New rtl functions.
	* rtl-c.scm (nan,qnan,snan): New rtl functions.
	* doc/rtl.texi (Expressions): Add docs for them.
@
text
@d831 2
a832 2
; Mode conversions.
; MODE is the mode name.
d834 2
a835 2
(define (s-convop estate name mode s1)
  ; Get S1 in its normal mode, then convert.
d844 29
a872 14
	(if (or (mode-float? mode)
		(mode-float? (cx:mode s)))
	    (cx:make mode
		     (string-append "CGEN_CPU_FPU (current_cpu)->ops->"
				    (string-downcase name)
				    (string-downcase (obj:str-name (rtx-sem-mode (cx:mode s))))
				    (string-downcase (obj:str-name (rtx-sem-mode mode)))
				    " (CGEN_CPU_FPU (current_cpu), "
				    (cx:c s) ")"))
	    (cx:make mode
		     (string-append name
				    (obj:str-name (rtx-sem-mode (cx:mode s)))
				    (obj:str-name (rtx-sem-mode mode))
				    " (" (cx:c s) ")")))))
d1808 1
a1808 1
  (s-convop *estate* "EXT" mode s1)
d1811 1
a1811 1
  (s-convop *estate* "ZEXT" mode s1)
d1814 1
a1814 1
  (s-convop *estate* "TRUNC" mode s1)
d1816 3
a1818 2
(define-fn fext (*estate* options mode s1)
  (s-convop *estate* "FEXT" mode s1)
d1820 2
a1821 2
(define-fn ftrunc (*estate* options mode s1)
  (s-convop *estate* "FTRUNC" mode s1)
d1823 2
a1824 2
(define-fn float (*estate* options mode s1)
  (s-convop *estate* "FLOAT" mode s1)
d1826 2
a1827 2
(define-fn ufloat (*estate* options mode s1)
  (s-convop *estate* "UFLOAT" mode s1)
d1829 2
a1830 2
(define-fn fix (*estate* options mode s1)
  (s-convop *estate* "FIX" mode s1)
d1832 2
a1833 2
(define-fn ufix (*estate* options mode s1)
  (s-convop *estate* "UFIX" mode s1)
@


1.29
log
@	* mode.scm (<mode>) Rename member non-mode-c-type to c-type.
	All uses updated.
	(mode:non-mode-c-type): Delete.
	(mode:c-type): Update.
	* rtl-c.scm (s-shop): Fix casting of DI mode values.
@
text
@d1736 10
@


1.28
log
@	* rtl-c.scm (/use-gcc-stmt-expr?): New function.
	(s-sequence): Call it.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2005, 2009 Red Hat, Inc.
d781 1
a781 1
				; Ensure correct sign of shift.
d783 6
a788 6
				       (string-append "("
						      (if (eq? (mode:class mode) 'UINT)
							  ""
							  "unsigned ")
						      (mode:non-mode-c-type mode)
						      ") "))
d790 8
a797 3
				       (string-append "("
						      (mode:non-mode-c-type mode)
						      ") "))
@


1.27
log
@	* rtl-c.scm (s-sequence): Use gcc's statement expressions for
	non-VOID-mode expressions with multiple statements.
@
text
@d1247 20
d1291 1
a1291 5
	(let (
	      ;; Don't use GCC extension unless necessary.
	      (use-stmt-expr? (or (not (rtx-env-empty? env))
				  (> (length exprs) 1)))
	      )
@


1.26
log
@	* rtl-c.scm (s-parallel): Use map-in-order instead of map.
	* rtl-xform.scm (/rtx-trim-for-doc): Handle set-quiet, nop,
	eq, ne, lt, le, gt, ge, ltu, leu, gtu, geu, index-of.
@
text
@d1247 2
a1248 2
; Return a <c-expr> node for a `sequence'.
; MODE is the mode name.
d1251 1
a1251 1
  (let* ((env (rtx-env-make-locals env)) ; compile env
d1253 1
d1256 1
d1259 5
a1263 5
		  ; ??? do {} while (0); doesn't get "optimized out"
		  ; internally by gcc, meaning two labels and a loop are
		  ; created for it to have to process.  We can generate pretty
		  ; big files and can cause gcc to require *lots* of memory.
		  ; So let's try just {} ...
d1270 25
a1294 20
	(cx:make mode
		 (string-append
		  ; Don't use GCC extension unless necessary.
		  (if (rtx-env-empty? env) "(" "({ ")
		  (gen-temp-defs estate env)
		  (string-drop 2
			       (string-map
				(lambda (e)
				  (string-append
				   (if (rtx-env-empty? env) ", " "; ")
				   ; Strip off gratuitous ";\n" at end of expressions that
				   ; misguessed themselves to be in statement context.
				   ; See s-c-call, s-c-call-raw above.
				   (let ((substmt (rtl-c-with-estate estate DFLT e)))
				     (if (and (rtx-env-empty? env)
					      (string=? (string-take -2 substmt) ";\n"))
					 (string-drop -2 substmt)
					 substmt))))
				exprs))
		  (if (rtx-env-empty? env) ")" "; })")))))
@


1.25
log
@	Specify isa(s) when doing ifield, operand, insn lookups.
	ACU = all callers updated.
	* attr.scm (/attr-eval): Call rtx-value instead of rtx-eval-with-estate.
	* enum.scm (define-full-insn-enum): Pass isa-name-list to
	current-ifld-lookup.
	* html.scm (get-insn-properties): Pass isa-name-list to
	current-op-lookup.
	* ifield.scm (/ifld-parse-follows): New arg isas, ACU.
	* insn.scm (/parse-insn-format-symbol): New arg isa-name-list, ACU.
	(/parse-insn-format-list, /parse-insn-iformat-iflds): Ditto.
	(/parse-insn-format, syntax-break-out): Ditto.
	* mach.scm (obj-filter-by-isa): New function.
	(current-ifld-lookup): New optional arg maybe-isa-name-list.
	(/ifld-already-defined?, /op-already-defined?): Simplify.
	(current-op-lookup): New optional arg maybe-isa-name-list.
	(current-insn-lookup): New arg isa-name-list, ACU.
	(/insn-already-defined?, /minsn-already-defined?): Simplify.
	(current-minsn-lookup): New arg isa-name-list, ACU.
	* minsn.scm (/minsn-compute-iflds): Pass isa-name-list to
	current-op-lookup.
	* opc-itab.scm (compute-syntax): New arg isa-name-list, ACU.
	(gen-syntax-entry): Ditto.
	* operand.scm (/operand-parse): Pass isa-name-list to
	current-ifld-lookup.
	(/derived-parse-encoding): New arg isa-name-list, ACU.
	(/derived-parse-ifield-assertion): Ditto.
	(/derived-operand-parse): Pass isa-name-list to current-op-lookup.
	(/anyof-parse-choice): Ditto.
	(anyof-satisfies-assertions?): Pass context to rtx-solve.
	(/anyof-merge-syntax): New arg container, ACU.
	(operand-builtin!): Add pc to all isas.
	* rtl-c.scm (estate-make-for-rtl-c): Delete arg extra-vars-alist, ACU.
	(estate-make-for-rtl-c++, rtl-c-expr-parsed): Ditto.
	(rtl-c-parsed, rtl-c++-parsed): Ditto.
	(rtl-c): New arg isa-name-list, ACU.
	(rtl-c-expr, rtl-c++): Ditto.
	(closure): New arg isa-name-list, ACU.
	* rtl-traverse.scm (/make-cstate): New arg isa-name-list, ACU.
	(/cstate-isas): New function.
	(/rtx-canon-symbol-list): New function.
	(/rtx-canon-env-stack): Renamed from /rtx-canon-env, ACU.
	updated.
	(/rtx-make-canon-table): Rename ENV to ENVSTACK, new entry SYMBOLLIST.
	(/rtx-canon-rtx-operand): Pass isa list to current-op-lookup.
	(/rtx-canon-rtx-ref, /rtx-canon): Ditto.
	(rtx-canonicalize): New arg isa-name-list, ACU.
	(rtx-canonicalize-stmt): Delete.
	(tstate-make): New arg isas, ACU.
	(tstate-isas, tstate--set-isas!): New functions.
	(tstate-env-stack): Renamed from tstate-env, ACU.
	(tstate-set-env-stack!): Renamed from tstate-set-env!, ACU.
	(tstate-make-closure): Renamed from tstate-new-env, new arg
	isa-name-list, ACU.
	(/rtx-traverse-env): Delete.
	(/rtx-make-traverser-table): Rename ENV to ENVSTACK, new entry
	SUMBOLLIST.
	(/rtx-traverse): Include conditional flag in dump output.
	Update isa,envstack for closures.  Pass isa list to current-op-lookup.
	(<eval-state>): New member isas.  Rename env to env-stack.
	(<eval-state> vmake!): Handle #:isas.  #:env renamed to #:env-stack.
	(<eval-state>): New getter/setter for isas.  Rename env getter/setter
	to env-stack.
	(estate-make-for-eval): Provide #:isas.
	(estate-make-closure): Renamed from estate-new-env.  New arg
	isa-name-list, ACU.
	* rtl-xform.scm (/rtx-simplify-expr-fn): Handle closures.
	(/rtx-trim-args): ENV renamed to ENVSTACK.  Ad ITERATION, SYMBOLLIST.
	(/rtx-trim-for-doc): Handle closures.
	* rtl.scm (/rtx-valid-types): Rename ENV to ENVSTACK.  Add ITERATION,
	SYMBOLLIST.
	(rtx-env-var-list): Delete.
	(rtx-env-make): Handle already-compiled environments.
	(rtx-var-alist-to-env): New function.
	(rtx-var-alist-to-closure-env-stack, rtx-make-env-stack): New functions.
	(rtx-env-stack-dump): Renamed from rtx-env-dump, ACU.
	(rtx-operand-obj): New arg isa-name-list, ACU.
	(rtx-closure-isas, rtx-closure-env-stack, rtx-closure-expr): New
	functions.
	* rtx-funcs.scm (closure): New arg isa-name-list, reorder args, ACU.
	* sem-frags.scm (<sfrag>): Delete member compiled-semantics.
	(/frag-compute-desired-frags): Minor simplification.
	(/frag-pick-best): Ditto.
	* sid-cpu.scm (gen-semantic-code): Require canonical rtl.
	(/gen-sfrag-code): Update.
	* sim-cpu.scm (gen-semantic-code): Require canonical rtl.
	* utils-cgen.scm (sanitize): New arg isa-name-list, ACU.
	* utils.scm (non-null-intersection?): New function.
@
text
@d1201 9
a1209 7
	    (map (lambda (expr)
		   (rtx-traverse (estate-context estate)
				 (estate-owner estate)
				 expr
				 /par-replace-set-dest-expr-fn
				 #f))
		 exprs))
d1219 9
a1227 7
	      (map (lambda (expr)
		     (rtx-traverse (estate-context estate)
				   (estate-owner estate)
				   expr
				   /par-replace-set-src-expr-fn
				   #f))
		   exprs))
@


1.24
log
@	* cos.scm (/class-table): New global.
	(/class-uid, /class-set-uid!): New functions.
	(/class-parent-name): Renamed from /class-parents.
	(/class-make!): Change parents arg to parent-name, all callers updated.
	Assign uid to class.
	(/class-lookup-uid): New function.
	(/class-parent-classes): Rewrite.
	(/class-mi?): Delete.
	(/class-desc-mi?, /class-desc-offset-case, /class-desc-offset-case):
	Delete.
	(/class-desc-offset, /class-desc-child, /class-desc-parents): Update.
	(/class-compute-class-desc, class-desc-dump): Update.
	(/object-make!): Update.
	(/object-make-with-values!): Delete arg class-desc, all callers
	updated.
	(/object-copy): Delete arg top?, all callers updated.
	(/object-specialize): Delete.
	(/object-elements, /object-top-class): Delete.
	(/object-class-name, /object-class-desc): Update.
	(/object-class-uid): New function.
	(/object-elm-get, /object-elm-set!, object?, /class-check-init!,
	class-make, /class-subclass? /class-lookup-element,
	Update.
	(/elm-delta, elm-list): Delete.
	(/elm-make-method-getter, elm-get, elm-xget): Update.
	(/elm-make-method-setter, elm-set!, elm-xset!): Update.
	(elm-make-getter, elm-make-setter): Update.
	(/method-lookup-next): Update.
	(send): Don't specialize class passed to method.
	(send-next): New arg class-name, all callers updated.
	(/class-parent, /class-parent-via-path, object-parent): Delete.
	(class-cons-parent!, class-append-parent!): Delete.
	(object-reset!): Init /class-table.
@
text
@d10 1
a10 1
; (rtl-c mode '(func mode ...) nil)
d13 1
a13 1
; (rtl-c SI '(add () SI (const () SI 1) (const () SI 2)) nil)
d18 2
a19 1
; rtx-canonicalize).
a277 2
;; EXTRA-VARS-ALIST is an association list of
;; (symbol <mode>-or-mode-name value) elements to be used during value lookup.
a278 3
;;
;; ??? Move EXTRA-VARS-ALIST into OVERRIDES (caller would have to call
;; rtx-env-init-stack1)?
d280 1
a280 1
(define (estate-make-for-rtl-c extra-vars-alist overrides)
a286 1
	   #:env (rtx-env-init-stack1 extra-vars-alist)
d300 1
a300 1
; X must have already been fed through rtx-canonicalize.
a302 2
; EXTRA-VARS-ALIST is an association list of extra
; (symbol <mode>-or-mode-name value) elements to be used during value lookup.
d306 1
a306 1
(define (rtl-c-parsed mode x extra-vars-alist . overrides)
d310 3
a312 4
  (let ((estate (estate-make-for-rtl-c extra-vars-alist
				       (cons #:outer-expr
					     (cons x overrides)))))
    (rtl-c-with-estate estate mode x))
d315 4
a318 1
; Same as rtl-c-parsed but X is unparsed.
d321 6
a326 8
(define (rtl-c mode x extra-vars-alist . overrides)
  ;; This doesn't pass the canonicalized expr for #outer-expr on purpose,
  ;; to keep it closer to what the user wrote.
  (let ((estate (estate-make-for-rtl-c extra-vars-alist
				       (cons #:outer-expr
					     (cons x overrides)))))
    (rtl-c-with-estate estate mode (rtx-canonicalize #f (obj:name mode) x
						     extra-vars-alist)))
d339 1
a339 1
(define (rtl-c-expr-parsed mode x extra-vars-alist . overrides)
d343 3
a345 4
  (let ((estate (estate-make-for-rtl-c extra-vars-alist
				       (cons #:outer-expr
					     (cons x overrides)))))
    (rtl-c-expr-with-estate estate mode x))
d348 1
a348 1
; Same as rtl-c-expr-parsed but X is unparsed.
d351 6
a356 8
(define (rtl-c-expr mode x extra-vars-alist . overrides)
  ;; This doesn't pass the canonicalized expr for #outer-expr on purpose,
  ;; to keep it closer to what the user wrote.
  (let ((estate (estate-make-for-rtl-c extra-vars-alist
				       (cons #:outer-expr
					     (cons x overrides)))))
    (rtl-c-expr-with-estate estate mode (rtx-canonicalize #f (obj:name mode) x
							  extra-vars-alist)))
a361 2
; EXTRA-VARS-ALIST is an association list of (symbol <mode> value)
; elements to be used during value lookup.
d364 2
a365 3
(define (estate-make-for-rtl-c++ extra-vars-alist overrides)
  (estate-make-for-rtl-c extra-vars-alist
			 (cons #:output-language (cons "c++" overrides)))
d369 1
a369 1
; X must have already been fed through rtx-canonicalize.
a371 2
; EXTRA-VARS-ALIST is an association list of extra (symbol <mode> value)
; elements to be used during value lookup.
d375 1
a375 1
(define (rtl-c++-parsed mode x extra-vars-alist . overrides)
d379 3
a381 4
  (let ((estate (estate-make-for-rtl-c++ extra-vars-alist
					 (cons #:outer-expr
					       (cons x overrides)))))
    (rtl-c-with-estate estate mode x))
d384 1
a384 1
; Same as rtl-c++-parsed but X is unparsed.
d387 6
a392 8
(define (rtl-c++ mode x extra-vars-alist . overrides)
  ;; This doesn't pass the canonicalized expr for #outer-expr on purpose,
  ;; to keep it closer to what the user wrote.
  (let ((estate (estate-make-for-rtl-c++ extra-vars-alist
					 (cons #:outer-expr
					       (cons x overrides)))))
    (rtl-c-with-estate estate mode (rtx-canonicalize #f (obj:name mode) x
						     extra-vars-alist)))
d466 1
a466 1
	  ((or (and (symbol? src) (rtx-temp-lookup (estate-env estate) src))
d470 1
a470 1
		 (set! src (rtx-temp-lookup (estate-env estate) src)))
d1292 2
a1293 2
	 (temp-iter (rtx-temp-lookup (estate-env estate) iter-var))
	 (temp-limit (rtx-temp-lookup (estate-env estate) limit-var))
d1415 1
a1415 1
	 (let ((object (rtx-temp-lookup (estate-env *estate*) object-or-name)))
d1858 4
a1861 3
(define-fn closure (*estate* options mode expr env)
  ; ??? estate-push-env?
  (rtl-c-with-estate (estate-new-env *estate* env) (mode:lookup mode) expr)
@


1.23
log
@	* operand.scm (/anyof-merge-setter): Handle set-quiet.

	* rtl-c.scm (estate-make-for-rtl-c): Delete args context, owner,
	rtl-cover-fns?, macro?.  All callers updated.
	(estate-make-for-normal-rtl-c): Delete, have all callers call
	estate-make-for-rtl-c directly.
	(rtl-c-parsed): Pass #:outer-expr to estate-make-for-rtl-c.
	(rtl-c, rtl-c-expr-parsed, rtl-c-expr, rtl-c++-parsed, rtl-c++): Ditto.

	* rtl-c.scm (/par-replace-set-dest-expr-fn): New function,
	replaces /par-replace-set-dests.
	(/par-replace-set-src-expr-fn): New function, replaces
	/par-replace-set-srcs.
	(s-parallel): Rewrite.

	* rtl.scm (rtx-pretty-strdump): New function.
	* rtl-traverse.scm (/rtx-canon-error): Use it.
	(<eval-state>): New member outer-expr.
	(estate-error): Include outer expression in error message if present.

	* rtl.scm (rtx-single-set?): Handle set-quiet.
@
text
@d253 2
a254 1
   (let loop ((args (send-next self 'vmake! args)) (unrecognized nil))
@


1.22
log
@	* xc16x.cpu (h-cr): New hardware.
	(muls): Comment out parts that won't compile, add fixme.
	(mulu, divl, divlu, jmpabs, jmpa-, jmprel, jbc, jnbs, callr): Ditto.
	(scxti, scxtmg, scxtm, bclear, bclr18, bset19, bitset, bmov): Ditto.
	(bmovn, band, bor, bxor, bcmp, bfldl, bfldh): Ditto.

	Rewrite rtl processing to require it to be "canonicalized" first,
	and write a full canonicalizer / expression checker.
	Remove all appearances of DFLT in canonical rtl.
	* attr.scm (/attr-eval atval owner): Call rtx-canonicalize,
	then rtx-simplify.
	* iformat.scm (ifmt-analyze) Use canonical semantics.
	* insn (<insn>): New member canonical-semantics.
	* mach.scm (<arch>): New member multi-insns-instantiated?.
	(/instantiate-multi-insns!): New function.
	(/canonicalize-insns!): New function.
	(arch-analyze-insns!): Canonicalize insn semantics before processing
	them.
	* mode.scm (/mode-set-word-params!): New function.
	(mode-void?): New function.
	(mode-compatible?): VOID is compatible with VOID.
	(/mode-word-sizes-defined?): New global.
	(mode-set-word-modes!): Use/set it.
	(mode-ensure-word-sizes-defined): Update.
	(mode-builtin!): New builtin "modes" SYM, INSN, MACH.
	Redo WI/UWI/AI/IAI handling.
	(op:new-mode): No longer accept DFLT.
	(<derived-operand> constructor): Ensure all fields are initialized.
	(<anyof-operand> constructor): Ditto.
	(/derived-parse-ifield-assertion): Delete arg `args'.
	All callers updated.
	* rtl-c.scm (<rtl-c-eval-state>): New member `for-insn?'.
	(rtl-c): Call rtx-canonicalize instead of rtx-compile.
	(rtl-c-expr, rtl-c++): Ditto.
	(/rtl-c-get): Use mode of operand, not containing expression.
	(rtl-c-set-quiet, rtl-c-set-trace): Remove DFLT support.
	(/rtx-use-sem-fn?): Don't check for (insn? owner), check
	estate-for-insn? instead.
	(s-unop): Use mode of expression, not first operand.
	(s-binop, s-binop-with-bit, s-shop, s-cmpop): Ditto.
	(s-sequence): Remove DFLT support.
	(ifield): Use mode of expression, not UINT.
	(pc): Comment out, unused.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	(set, set-quiet): Pass src to rtl-c-set-{trace,quiet} for expansion.
	* rtl-traverse.scm (/rtx-canon-debug?): New global.
	(/make-cstate): New function.
	(/cstate-context, /cstate-outer-expr): New functions.
	(/rtx-canon-error): New function.
	(/rtx-lookup-hw, /rtx-pick-mode, /rtx-pick-mode3, /rtx-pick-op-mode,
	/rtx-get-last-cond-case-rtx): New functions.
	(/rtx-canon-*): New functions.
	(/rtx-canner-table, /rtx-operand-canoners): New globals.
	(/rtx-make-canon-table, /rtx-special-expr-canoners): New functions.
	(/rtx-option, /rtx-option-list?): Rewrite.
	(rtx-munge-mode&options): Replaces /rtx-munge-mode&options.
	Rewritten, all callers updated.
	(/rtx-canon-expr, /rtx-canon): New functions.
	(rtx-canonicalize): Move here from rtl-xform.scm and rewrite.
	(rtx-canonicalize-stmt): New function.
	(tstate-make): Remove arg `set?'.  All callers updated.
	(tstate-new-set?): Delete.
	(/rtx-traverse-options, /rtx-traverse-*mode): Delete,
	moved to /rtx-canon-*.
	(/rtx-traverse-normal-operand): New function.
	(/rtx-traverse-rtx-list): Delete arg `mode', all callers updated.
	(/rtx-traverse-rtx, /rtx-traverse-setrtx,, /rtx-traverse-testrtx,
	/rtx-traverse-condrtx, /rtx-traverse-casertx, /rtx-traverse-locals,
	/rtx-traverse-iteration, /rtx-traverse-env, /rtx-traverse-attrs):
	Ditto.
	(/rtx-traverse-symbol, /rtx-traverse-string, /rtx-traverse-number,
	/rtx-traverse-symornum, /rtx-traverse-object): Delete.
	(/rtx-make-traverser-table): Update.
	(/rtx-traverse-operands): Remove mode processing, now done during
	canonicalization.
	(/rtx-traverse-expr): Delete arg `mode', all callers updated.
	(/rtx-traverse): Ditto.
	(rtx-init-traverser-tables!): New function.
	* rtl-xform (/rtx-verify-no-dflt-modes-expr-fn): New function.
	(rtx-verify-no-dflt-modes): New function.
	(/rtx-simplify-expr-fn): Update, `arg' mode deleted.
	(rtx-simplify-insn): Use insn-canonical-semantics.
	(rtx-canonicalize): Moved to rtl-traverse.scm.
	(/compile-expr-fn, rtx-compile): Delete.
	(/rtx-trim-rtx-list): New function.
	(/rtx-trim-for-doc): Handle set, if.
	* rtl.scm (<rtx-func>): New members result-mode, matchexpr-index.
	(/rtx-valid-mode-types): Update.
	(/rtx-valid-matches): Update.
	(/rtx-find-matchexpr-index): New function.
	(rtx-lookup): Require rtx-kind to be the rtx name.
	(def-rtx-node): New arg result-mode, all callers updated.
	(def-rtx-syntax-node, def-rtx-operand-node): Ditto.
	(rtx-lazy-sem-mode): Delete.
	(/rtx-closure-make): New arg `mode', all callers updated.
	(rtx-make-ifield, rtx-make-operand, rtx-make-local): Ditto.
	(rtx-operand-obj): Rewrite.
	(rtx-make-xop): New functions.
	(/hw): Renamed from `hw', all callers updated.
	Use the correct mode instead of DFLT for the index.
	(rtl-builtin!): Call rtx-init-traversal-tables!.
	(rtl-finish!): Update.
	* rtx-funcs.scm (all rtx functions): New parameter: result-mode.
	Update mode arg-type.
	(pc): Comment out.
	(int-attr): New rtx kind.
	(attr): Deprecate.
	* sem-frags.scm (/frag-hash-compute!): Update, mode arg deleted.
	(/frag-cost-compute!): Ditto.
	* semantics.scm (/build-operand!): Delete args op-name, op.
	New arg op-expr.  All callers updated.
	(/build-mem-operand!): Remove DFLT support.
	(semantic-compile): Update process-expr!, mode arg deleted.
	* sid-cpu.scm (gen-semantic-code): Specify #:for-insn? in
	rtl-c++ calls.
	(/gen-sem-case, /gen-sfrag-code): Ditto.
	* sid.scm (/op-gen-set-trace1): Renamed from /op-gen-set-trace.
	(/op-gen-set-trace): New function.  If not doing profiling,
	call /op-gen-set-quiet.
	* sim-cpu.scm (gen-semantic-code): Specify #:for-insn? in rtl-c calls.
	* utils-gen.scm (/gen-ifld-extract-base): Update call to rtl-c.
	(/gen-ifld-extract-beyond, gen-multi-ifld-extract): Ditto.
	* utils.scm (find-first-index): New function.
	* doc/rtl.texi: Delete docs for `attr'.  Add `int-attr'.
@
text
@d275 7
a281 6
; Build an estate for use in generating C.
; CONTEXT is a <context> object or #f if there is none.
; OWNER is the owner of the expression or #f if there is none.
; EXTRA-VARS-ALIST is an association list of
; (symbol <mode>-or-mode-name value) elements to be used during value lookup.
; OVERRIDES is a #:keyword/value list of parameters to apply last.
d283 1
a283 2
(define (estate-make-for-rtl-c context owner extra-vars-alist
			       rtl-cover-fns? macro? overrides)
a287 2
	   #:context context
	   #:owner owner
d291 2
a292 13
	   #:rtl-cover-fns? rtl-cover-fns?
	   #:macro? macro?)
	   overrides))
)

(define (estate-make-for-normal-rtl-c extra-vars-alist overrides)
  (estate-make-for-rtl-c
   #f ; FIXME: context
   #f ; FIXME: owner
   extra-vars-alist
   /rtl-c-rtl-cover-fns?
   #f ; macro?
   overrides)
d313 6
a318 1
  (let ((estate (estate-make-for-normal-rtl-c extra-vars-alist overrides)))
d326 5
a330 1
  (let ((estate (estate-make-for-normal-rtl-c extra-vars-alist overrides)))
d346 6
a351 1
  (let ((estate (estate-make-for-normal-rtl-c extra-vars-alist overrides)))
d359 5
a363 1
  (let ((estate (estate-make-for-normal-rtl-c extra-vars-alist overrides)))
d375 3
a377 8
(define (estate-make-for-normal-rtl-c++ extra-vars-alist overrides)
  (estate-make-for-rtl-c
   #f ; FIXME: context
   #f ; FIXME: owner
   extra-vars-alist
   /rtl-c-rtl-cover-fns?
   #f ; macro?
   (cons #:output-language (cons "c++" overrides)))
d390 6
a395 1
  (let ((estate (estate-make-for-normal-rtl-c++ extra-vars-alist overrides)))
d403 5
a407 1
  (let ((estate (estate-make-for-normal-rtl-c++ extra-vars-alist overrides)))
d1174 33
a1206 54
; Parallels are handled by converting them into two sequences.  The first has
; all set destinations replaced with temps, and the second has all set sources
; replaced with those temps.
; ??? Revisit later to see if (if ...) and (set pc ...) is ok.
; How about disallowing if's and jump's inside parallels?
; One can still put a parallel inside an `if' however.

(define (/par-replace-set-dests estate exprs)
  ;(display exprs) (newline)
  (let ((sets (list 'set 'set-quiet
		    (rtx-lookup 'set) (rtx-lookup 'set-quiet))))
    (letrec ((replace
	      (lambda (expr)
		;(display expr) (newline)
		(let ((name (car expr))
		      (options (rtx-options expr))
		      (mode (rtx-mode expr)))
		  (if (memq name sets)
		      (list name
			    options
			    mode
			    (/par-new-temp! ; replace dest with temp
			     (if (mode:eq? 'DFLT mode) ;; FIXME: can't get DFLT anymore
				 (rtx-lvalue-mode-name estate (rtx-set-dest expr))
				 mode))
			    (rtx-set-src expr))
		      (cons name
			    (cons options
				  (cons mode (replace (rtx-args expr)))))))))
	     )
      (map replace exprs)))
)

; This must process expressions in the same order as /par-replace-set-dests!

(define (/par-replace-set-srcs estate exprs)
  (let ((sets (list 'set 'set-quiet
		    (rtx-lookup 'set) (rtx-lookup 'set-quiet))))
    (letrec ((replace
	      (lambda (expr)
		(let ((name (car expr))
		      (options (rtx-options expr))
		      (mode (rtx-mode expr)))
		  (if (memq name sets)
		      (list name
			    options
			    mode
			    (rtx-set-dest expr)
			    (/par-next-temp!)) ; the source's temp
		      (cons name
			    (cons options
				  (cons mode (replace (cddr expr)))))))))
	     )
      (map replace exprs)))
d1209 1
a1209 1
; Return a <c-expr> node for a `parallel'.
d1213 2
a1214 1
    ; Initialize /par-temp-list for /par-replace-set-dests.
d1216 12
a1227 3
    (let* ((set-dests (string-map (lambda (e)
				    (rtl-c-with-estate estate VOID e))
				  (/par-replace-set-dests estate exprs)))
d1229 2
a1230 1
      ; Initialize /par-temp-list for /par-replace-set-srcs.
d1232 26
a1257 15
      (cx:make VOID
	       (string-append
		; FIXME: do {} while (0); doesn't get "optimized out"
		; internally by gcc, meaning two labels and a loop are
		; created for it to have to process.  We can generate pretty
		; big files and can cause gcc to require *lots* of memory.
		; So let's try just {} ...
		"{\n"
		(/gen-par-temp-defns temps)
		set-dests
		(string-map (lambda (e)
			      (rtl-c-with-estate estate VOID e))
			    (/par-replace-set-srcs estate exprs))
		"}\n")
	       )))
d1270 1
a1270 1
		  ; FIXME: do {} while (0); doesn't get "optimized out"
d1393 1
a1393 1
; Operand support
d1397 1
d1410 1
a1410 1
(define-fn xop (*estate* options mode object) 
@


1.21
log
@* rtl-c.scm (all rtx functions): Rename local estate to *estate*.  It's an
artificial argument added to the rtx, so make it stand out.
@
text
@d13 1
a13 1
; (rtl-c DFLT '(add SI (const SI 1) (const SI 2)) nil)
a15 1
; Mode `DFLT' (DEFAULTmode) means "use the default/natural mode".
d17 2
a18 2
; The expression is in source form or may be already compiled (with
; rtx-compile).
a34 1
; (estate-owner estate) must be an instruction that has the field.
d125 1
a125 1
; MODE is either the mode's symbol (e.g. 'QI) or a mode object.
d217 5
d237 1
a237 1
  (rtl-cover-fns? output-language macro? ifield-var?)
d264 2
d317 1
a317 1
; X must have already been fed through rtx-parse/rtx-compile.
a323 1
; ??? Maybe EXTRA-VARS-ALIST should be handled this way.
a333 2
  ; ??? rtx-compile could return a closure, then we wouldn't have to
  ; pass EXTRA-VARS-ALIST to two routines here.
d335 2
a336 1
    (rtl-c-with-estate estate mode (rtx-compile #f x extra-vars-alist)))
a357 2
  ; ??? rtx-compile could return a closure, then we wouldn't have to
  ; pass EXTRA-VARS-ALIST to two routines here.
d359 2
a360 1
    (rtl-c-expr-with-estate estate mode (rtx-compile #f x extra-vars-alist)))
d381 1
a381 1
; X must have already been fed through rtx-parse/rtx-compile.
a387 1
; ??? Maybe EXTRA-VARS-ALIST should be handled this way.
d394 1
a394 1
; Same as rtl-c-parsed but X is unparsed.
a397 2
  ; ??? rtx-compile could return a closure, then we wouldn't have to
  ; pass EXTRA-VARS-ALIST to two routines here.
d399 2
a400 1
    (rtl-c-with-estate estate mode (rtx-compile #f x extra-vars-alist)))
d415 1
a419 1
; If SRC is a string, MODE can't be VOID or DFLT.
d444 1
d451 1
d458 1
d463 1
a463 1
		    (let ((mode (rtx-lazy-sem-mode mode)))
d466 1
d473 1
d482 1
a482 1
		    (let ((mode (rtx-lazy-sem-mode mode)))
d484 7
a490 5
		   (else (estate-error
			  estate
			  (string-append "sequence temp " (rtx-temp-name src)
					 " referenced in incompatible mode")
			  (obj:name mode))))))
d493 1
a493 1
	   ; Default mode of string argument is INT.
d522 1
d527 4
a530 1
; SRC is a <c-expr> object.
d532 3
d547 1
d550 1
a550 5
    (let ((mode (if (mode:eq? 'DFLT mode)
		    (rtx-obj-mode xdest)
		    (rtx-lazy-sem-mode mode))))
      (assert (mode? mode))
      (cx:make VOID (send xdest 'gen-set-quiet
d552 1
a552 1
			(rtl-c-get estate mode src)))))
d573 1
d576 1
a576 5
    (let ((mode (if (mode:eq? 'DFLT mode)
		    (rtx-obj-mode xdest)
		    (rtx-lazy-sem-mode mode))))
      (assert (mode? mode))
      (cx:make VOID (send xdest 'gen-set-trace
d578 1
a578 1
			(rtl-c-get estate mode src)))))
d621 1
a621 1
	    (if (or (mode:eq? 'DFLT mode)
d647 1
a647 1
	    (if (or (mode:eq? 'DFLT mode)
d672 3
a674 1
		(or (insn? (estate-owner estate))
d684 1
a684 1
	 (mode (cx:mode val))
a705 1
; If MODE is DFLT, use the mode of SRC1.
d716 1
d719 1
a719 1
	 (mode (cx:mode val1))
d751 2
a752 1
	 (mode (rtx-sem-mode (cx:mode val1)))
d756 1
d758 1
a758 1
	  (string-append name (obj:str-name mode)
d773 1
d777 1
a777 1
	 (mode (cx:mode val1))
d818 1
d873 1
a873 1
	 (mode (cx:mode val1))
d917 1
a917 1
    (if (or (mode:eq? 'DFLT mode)
d953 1
d1119 1
d1173 1
d1178 1
d1187 1
a1187 1
			     (if (mode:eq? 'DFLT mode)
d1256 1
a1256 1
    (if (or (mode:eq? 'DFLT mode)
d1258 1
a1258 1
	(cx:make mode
d1268 1
a1268 1
				(rtl-c-with-estate estate DFLT e))
d1315 1
a1315 1
			    (rtl-c-with-estate estate DFLT e))
d1353 1
a1353 1
    (if (or (mode:eq? 'DFLT mode) (mode:eq? 'VOID mode))
a1366 1
; ??? Mode support is wip.
d1370 2
a1371 2
      (cx:make 'UINT (gen-c-symbol ifld-name))
      (cx:make 'UINT (string-append "FLD (" (gen-c-symbol ifld-name) ")")))
d1387 1
d1393 1
d1448 5
a1452 3
(define-fn pc (*estate* options mode)
  s-pc
)
d1468 2
a1469 1
  (send (op:index (rtx-eval-with-estate op DFLT *estate*)) 'cxmake-get *estate* 'DFLT)
d1487 1
a1487 1
			  ((operand) (op:type (rtx-operand-obj rtx)))
d1528 3
a1530 2
(define-fn attr (*estate* options mode owner attr-name)
  (cond ((equal? owner '(current-insn () DFLT))
d1539 1
a1539 1
  (if (mode:eq? 'DFLT mode)
a1575 1
	 ; Refetch mode in case it was DFLT.
d1608 3
a1610 3
  (if (insn? (estate-owner *estate*))
      (rtl-c-set-trace *estate* mode dst (rtl-c-get *estate* mode src))
      (rtl-c-set-quiet *estate* mode dst (rtl-c-get *estate* mode src)))
d1614 1
a1614 1
  (rtl-c-set-quiet *estate* mode dst (rtl-c-get *estate* mode src))
d1818 3
a1820 2
  ; FIXME: Multiple evalutions of VALUE.
  (let ((c-value (rtl-c-get *estate* 'DFLT value))
d1866 1
a1866 1
  (rtl-c-with-estate (estate-new-env *estate* env) DFLT expr)
@


1.20
log
@	* rtl-c.scm (/rtl-c-build-table): Renamed from rtl-c-build-table.
	All callers updated.  Add FIXME.
@
text
@d1330 2
a1331 2
(define-fn error (estate options mode message)
  (let ((c-call (s-c-call estate mode "cgen_rtx_error"
d1342 1
a1342 1
(define-fn enum (estate options mode name)
d1351 2
a1352 2
(define-fn ifield (estate options mode ifld-name)
  (if (estate-ifield-var? estate)
d1368 1
a1368 1
(define-fn operand (estate options mode object-or-name)
d1374 1
a1374 1
	       (estate-error estate "undefined operand" object-or-name))
d1377 1
a1377 1
	 (estate-error estate "bad arg to `operand'" object-or-name)))
d1380 2
a1381 2
(define-fn xop (estate options mode object) 
  (let ((delayed (assoc '#:delay (estate-modifiers estate))))
d1398 1
a1398 1
(define-fn local (estate options mode object-or-name)
d1402 1
a1402 1
	 (let ((object (rtx-temp-lookup (estate-env estate) object-or-name)))
d1404 1
a1404 1
	       (estate-error estate "undefined local" object-or-name))
d1407 1
a1407 1
	 (estate-error estate "bad arg to `local'" object-or-name)))
d1410 1
a1410 1
(define-fn reg (estate options mode hw-elm . indx-sel)
d1413 1
a1413 1
    (s-hw estate mode hw-elm indx sel))
d1416 1
a1416 1
(define-fn raw-reg (estate options mode hw-elm . indx-sel)
d1419 1
a1419 1
    (let ((result (s-hw estate mode hw-elm indx sel)))
d1424 2
a1425 2
(define-fn mem (estate options mode addr . sel)
  (s-hw estate mode 'h-memory addr
d1429 1
a1429 1
(define-fn pc (estate options mode)
d1433 4
a1436 4
(define-fn ref (estate options mode name)
  (if (not (insn? (estate-owner estate)))
      (estate-error estate "ref: not processing an insn"
		    (obj:name (estate-owner estate))))
d1441 1
a1441 1
	     (op:num (insn-lookup-op (estate-owner estate) name)))
d1446 2
a1447 2
(define-fn index-of (estate options mode op)
  (send (op:index (rtx-eval-with-estate op DFLT estate)) 'cxmake-get estate 'DFLT)
d1450 1
a1450 1
(define-fn clobber (estate options mode object)
d1454 1
a1454 1
(define-fn delay (estate options mode num-node rtx)
d1459 1
a1459 1
	    (old-delay (let ((old (assoc '#:delay (estate-modifiers estate))))
d1470 1
a1470 1
	      estate
d1475 1
a1475 1
	     (estate-error estate "delayed operand in a non-parallel cpu"
d1481 1
a1481 1
			       (estate-with-modifiers estate `((#:delay ,new-delay)))))))
d1484 1
a1484 1
    (else (s-sequence (estate-with-modifiers estate '((#:delay))) VOID '() rtx)))
d1488 2
a1489 2
;(define-fn annul (estate yes?)
;  (s-c-call estate 'VOID "SEM_ANNUL_INSN" "pc" yes?)
d1492 3
a1494 3
(define-fn skip (estate options mode yes?)
  (send pc 'cxmake-skip estate yes?)
  ;(s-c-call estate 'VOID "SEM_SKIP_INSN" "pc" yes?)
d1497 1
a1497 1
(define-fn eq-attr (estate options mode obj attr-name value)
d1506 1
a1506 1
(define-fn attr (estate options mode owner attr-name)
d1508 1
a1508 1
	 (s-c-raw-call estate 'INT "GET_ATTR"
d1511 1
a1511 1
	 (estate-error estate "attr: unsupported object type" owner)))
d1514 1
a1514 1
(define-fn const (estate options mode c)
d1538 1
a1538 1
(define-fn join (estate options out-mode in-mode arg1 . arg-rest)
d1542 1
a1542 1
  (apply s-c-raw-call (cons estate
d1550 1
a1550 1
(define-fn subword (estate options mode value word-num)
d1552 1
a1552 1
	 (val (rtl-c-get estate DFLT value))
d1564 1
a1564 1
				     (cx:c (rtl-c-get estate DFLT word-num))))
d1569 1
a1569 1
(define-fn c-code (estate options mode text)
d1573 2
a1574 2
(define-fn c-call (estate options mode name . args)
  (apply s-c-call (cons estate (cons mode (cons name args))))
d1577 2
a1578 2
(define-fn c-raw-call (estate options mode name . args)
  (apply s-c-raw-call (cons estate (cons mode (cons name args))))
d1581 1
a1581 1
(define-fn nop (estate options mode)
d1585 4
a1588 4
(define-fn set (estate options mode dst src)
  (if (insn? (estate-owner estate))
      (rtl-c-set-trace estate mode dst (rtl-c-get estate mode src))
      (rtl-c-set-quiet estate mode dst (rtl-c-get estate mode src)))
d1591 2
a1592 2
(define-fn set-quiet (estate options mode dst src)
  (rtl-c-set-quiet estate mode dst (rtl-c-get estate mode src))
d1595 2
a1596 2
(define-fn neg (estate options mode s1)
  (s-unop estate "NEG" "-" mode s1)
d1599 2
a1600 2
(define-fn abs (estate options mode s1)
  (s-unop estate "ABS" #f mode s1)
d1603 2
a1604 2
(define-fn inv (estate options mode s1)
  (s-unop estate "INV" "~" mode s1)
d1607 2
a1608 2
(define-fn not (estate options mode s1)
  (s-unop estate "NOT" "!" mode s1)
d1611 2
a1612 2
(define-fn add (estate options mode s1 s2)
  (s-binop estate "ADD" "+" mode s1 s2)
d1614 2
a1615 2
(define-fn sub (estate options mode s1 s2)
  (s-binop estate "SUB" "-" mode s1 s2)
d1618 2
a1619 2
(define-fn addc (estate options mode s1 s2 s3)
  (s-binop-with-bit estate "ADDC" mode s1 s2 s3)
d1622 2
a1623 2
(define-fn addc-cflag (estate options mode s1 s2 s3)
  (s-binop-with-bit estate "ADDCF" mode s1 s2 s3)
d1625 2
a1626 2
(define-fn addc-oflag (estate options mode s1 s2 s3)
  (s-binop-with-bit estate "ADDOF" mode s1 s2 s3)
d1629 2
a1630 2
(define-fn subc (estate options mode s1 s2 s3)
  (s-binop-with-bit estate "SUBC" mode s1 s2 s3)
d1633 2
a1634 2
(define-fn subc-cflag (estate options mode s1 s2 s3)
  (s-binop-with-bit estate "SUBCF" mode s1 s2 s3)
d1636 2
a1637 2
(define-fn subc-oflag (estate options mode s1 s2 s3)
  (s-binop-with-bit estate "SUBOF" mode s1 s2 s3)
d1641 2
a1642 2
(define-fn add-cflag (estate options mode s1 s2 s3)
  (s-binop-with-bit estate "ADDCF" mode s1 s2 s3)
d1644 2
a1645 2
(define-fn add-oflag (estate options mode s1 s2 s3)
  (s-binop-with-bit estate "ADDOF" mode s1 s2 s3)
d1647 2
a1648 2
(define-fn sub-cflag (estate options mode s1 s2 s3)
  (s-binop-with-bit estate "SUBCF" mode s1 s2 s3)
d1650 2
a1651 2
(define-fn sub-oflag (estate options mode s1 s2 s3)
  (s-binop-with-bit estate "SUBOF" mode s1 s2 s3)
d1654 1
a1654 1
;(define-fn zflag (estate options mode value)
d1658 1
a1658 1
;(define-fn nflag (estate options mode value)
d1662 2
a1663 2
(define-fn mul (estate options mode s1 s2)
  (s-binop estate "MUL" "*" mode s1 s2)
d1665 2
a1666 2
(define-fn div (estate options mode s1 s2)
  (s-binop estate "DIV" "/" mode s1 s2)
d1668 2
a1669 2
(define-fn udiv (estate options mode s1 s2)
  (s-binop estate "UDIV" "/" mode s1 s2)
d1671 2
a1672 2
(define-fn mod (estate options mode s1 s2)
  (s-binop estate "MOD" "%" mode s1 s2)
d1674 2
a1675 2
(define-fn umod (estate options mode s1 s2)
  (s-binop estate "UMOD" "%" mode s1 s2)
d1678 2
a1679 2
(define-fn sqrt (estate options mode s1)
  (s-unop estate "SQRT" #f mode s1)
d1681 2
a1682 2
(define-fn cos (estate options mode s1)
  (s-unop estate "COS" #f mode s1)
d1684 2
a1685 2
(define-fn sin (estate options mode s1)
  (s-unop estate "SIN" #f mode s1)
d1688 2
a1689 2
(define-fn min (estate options mode s1 s2)
  (s-binop estate "MIN" #f mode s1 s2)
d1691 2
a1692 2
(define-fn max (estate options mode s1 s2)
  (s-binop estate "MAX" #f mode s1 s2)
d1694 2
a1695 2
(define-fn umin (estate options mode s1 s2)
  (s-binop estate "UMIN" #f mode s1 s2)
d1697 2
a1698 2
(define-fn umax (estate options mode s1 s2)
  (s-binop estate "UMAX" #f mode s1 s2)
d1701 2
a1702 2
(define-fn and (estate options mode s1 s2)
  (s-binop estate "AND" "&" mode s1 s2)
d1704 2
a1705 2
(define-fn or (estate options mode s1 s2)
  (s-binop estate "OR" "|" mode s1 s2)
d1707 2
a1708 2
(define-fn xor (estate options mode s1 s2)
  (s-binop estate "XOR" "^" mode s1 s2)
d1711 2
a1712 2
(define-fn sll (estate options mode s1 s2)
  (s-shop estate "SLL" "<<" mode s1 s2)
d1714 2
a1715 2
(define-fn srl (estate options mode s1 s2)
  (s-shop estate "SRL" ">>" mode s1 s2)
d1717 2
a1718 2
(define-fn sra (estate options mode s1 s2)
  (s-shop estate "SRA" ">>" mode s1 s2)
d1720 2
a1721 2
(define-fn ror (estate options mode s1 s2)
  (s-shop estate "ROR" #f mode s1 s2)
d1723 2
a1724 2
(define-fn rol (estate options mode s1 s2)
  (s-shop estate "ROL" #f mode s1 s2)
d1727 2
a1728 2
(define-fn andif (estate options mode s1 s2)
  (s-boolifop estate "ANDIF" "&&" s1 s2)
d1730 2
a1731 2
(define-fn orif (estate options mode s1 s2)
  (s-boolifop estate "ORIF" "||" s1 s2)
d1734 2
a1735 2
(define-fn ext (estate options mode s1)
  (s-convop estate "EXT" mode s1)
d1737 2
a1738 2
(define-fn zext (estate options mode s1)
  (s-convop estate "ZEXT" mode s1)
d1740 2
a1741 2
(define-fn trunc (estate options mode s1)
  (s-convop estate "TRUNC" mode s1)
d1743 2
a1744 2
(define-fn fext (estate options mode s1)
  (s-convop estate "FEXT" mode s1)
d1746 2
a1747 2
(define-fn ftrunc (estate options mode s1)
  (s-convop estate "FTRUNC" mode s1)
d1749 2
a1750 2
(define-fn float (estate options mode s1)
  (s-convop estate "FLOAT" mode s1)
d1752 2
a1753 2
(define-fn ufloat (estate options mode s1)
  (s-convop estate "UFLOAT" mode s1)
d1755 2
a1756 2
(define-fn fix (estate options mode s1)
  (s-convop estate "FIX" mode s1)
d1758 2
a1759 2
(define-fn ufix (estate options mode s1)
  (s-convop estate "UFIX" mode s1)
d1762 2
a1763 2
(define-fn eq (estate options mode s1 s2)
  (s-cmpop estate 'eq "==" mode s1 s2)
d1765 2
a1766 2
(define-fn ne (estate options mode s1 s2)
  (s-cmpop estate 'ne "!=" mode s1 s2)
d1769 2
a1770 2
(define-fn lt (estate options mode s1 s2)
  (s-cmpop estate 'lt "<" mode s1 s2)
d1772 2
a1773 2
(define-fn le (estate options mode s1 s2)
  (s-cmpop estate 'le "<=" mode s1 s2)
d1775 2
a1776 2
(define-fn gt (estate options mode s1 s2)
  (s-cmpop estate 'gt ">" mode s1 s2)
d1778 2
a1779 2
(define-fn ge (estate options mode s1 s2)
  (s-cmpop estate 'ge ">=" mode s1 s2)
d1782 2
a1783 2
(define-fn ltu (estate options mode s1 s2)
  (s-cmpop estate 'ltu "<" mode s1 s2)
d1785 2
a1786 2
(define-fn leu (estate options mode s1 s2)
  (s-cmpop estate 'leu "<=" mode s1 s2)
d1788 2
a1789 2
(define-fn gtu (estate options mode s1 s2)
  (s-cmpop estate 'gtu ">" mode s1 s2)
d1791 2
a1792 2
(define-fn geu (estate options mode s1 s2)
  (s-cmpop estate 'geu ">=" mode s1 s2)
d1795 1
a1795 1
(define-fn member (estate options mode value set)
d1797 1
a1797 1
  (let ((c-value (rtl-c-get estate 'DFLT value))
d1815 2
a1816 2
(define-fn if (estate options mode cond then . else)
  (apply s-if (append! (list estate mode cond then) else))
d1819 2
a1820 2
(define-fn cond (estate options mode . cond-code-list)
  (apply s-cond (cons estate (cons mode cond-code-list)))
d1823 2
a1824 2
(define-fn case (estate options mode test . case-list)
  (apply s-case (cons estate (cons mode (cons test case-list))))
d1827 2
a1828 2
(define-fn parallel (estate options mode ignore expr . exprs)
  (apply s-parallel (cons estate (cons expr exprs)))
d1831 1
a1831 1
(define-fn sequence (estate options mode locals expr . exprs)
d1833 1
a1833 1
	 (cons estate (cons mode (cons locals (cons expr exprs)))))
d1836 1
a1836 1
(define-fn do-count (estate options mode iter-var nr-times expr . exprs)
d1838 1
a1838 1
	 (cons estate (cons iter-var (cons nr-times (cons expr exprs)))))
d1841 1
a1841 1
(define-fn closure (estate options mode expr env)
d1843 1
a1843 1
  (rtl-c-with-estate (estate-new-env estate env) DFLT expr)
@


1.19
log
@	Clean up pass of mode handling.
	Make use of mode name vs <mode> object more consistent and clear.
	* hardware.scm (/keyword-read): Default mode to the mode name,
	not the <mode> object.
	(/hw-parse-indices): Parse mode name and pass mode object to
	<hw-asm> constructor.
	(/hw-parse-values): Ditto.
	(<hw-register> parse!): Pass mode name to /hw-parse-indices
	and /hw-parse-values.
	(<hw-memory> parse!): Ditto.
	(<hw-address> parse!): Ditto.
	* mode.scm (/mode-table): New global, replaces mode-list.
	Modes stored in hashtable instead of list.
	(/mode-class-table): New global.
	(mode-list-non-alias-values): Update.
	(mode:eq?, mode-compatible?, mode:add!): Update.
	(mode:lookup): Restrict arg to the mode's name.  All callers updated.
	(mode-maybe-lookup): New function.
	(mode-real-name): Restrict arg to a <mode> object.  All callers updated.
	(mode-real-mode, mode-sem-mode, mode-bigger?): Ditto.
	(mode-find, mode-set-word-modes!): Update
	(mode-ensure-word-sizes-defined): Update.
	(/sort-mode-classes!): New function.
	(mode-builtin!): Update.  Sort mode classes here.
	(mode-finish!): Sort mode classes here too.
	* rtl-c.scm (/rtl-c-get): Restrict mode arg to a <mode> object.
	All callers updated.
	(rtl-c-set-quiet): Allow mode to be name of object.
	(rtl-c-set-trace): Ditto.
	* rtl-traverse.scm (rtl-eval-with-estate): Restrict mode arg to
	<mode> object.  All callers updated.
	* rtl.scm (rtx-sem-mode): Restrict arg to <mode> object.
	(rtx-lazy-sem-mode): Ditto.
	(<rtx-temp> make!): Assert mode arg is a <mode> object.
	(rtx-env-make): Allow var-list modes to be name or object.
	* sem-frags.scm (/frag-expr-assq-locals): New function.
	(/frag-compute-locals!): Call it.
	(/sfrag-create-cse-mapping): Renamed from sfrag-create-cse-mapping.
	All callers updated.
	* semantics.scm (/build-mem-operand!): Handle mode aliases.
@
text
@d1318 1
a1318 1
  (set! /rtl-c-gen-table (rtl-c-build-table))
d1325 1
a1325 1
(define (rtl-c-build-table)
d1846 2
a1847 1
; The result is the rtl->c generator table.
d1851 1
a1851 1
)) ; End of rtl-c-build-table
@


1.18
log
@	* rtl-c.scm (/rtl-c-get): Convert symbols to strings before passing
	to string-append.
	(*): Remove trailing ":" from error messages passed to estate-error.
@
text
@d131 1
a131 1
  (make <c-expr> (mode:lookup mode) code nil)
d144 1
a144 1
  (make <c-expr> (mode:lookup mode) code atlist)
d273 2
a274 2
; EXTRA-VARS-ALIST is an association list of (symbol <mode> value)
; elements to be used during value lookup.
d305 1
d314 3
a316 2
; EXTRA-VARS-ALIST is an association list of extra (symbol <mode> value)
; elements to be used during value lookup.
d327 1
d337 1
d344 1
d352 1
d381 1
d394 1
d407 1
d424 1
a424 1
  (let ((mode (mode:lookup mode)))
d500 2
d503 1
a503 3
  (logit 4 (spaces (estate-depth estate))
	 "(rtl-c-get " (mode-real-name mode) " " (rtx-strdump src) ")\n")
  (let ((result (/rtl-c-get estate mode src)))
d505 6
a510 3
	   "(rtl-c-get " (mode-real-name mode) " " (rtx-strdump src) ") => "
	   (cx:c result) "\n")
    result)
d515 1
d524 9
a532 8
  (let ((xdest (cond ((c-expr? dest)
		      dest)
		     ((rtx? dest)
		      (rtx-eval-with-estate dest mode estate))
		     (else
		      (estate-error estate
				    "rtl-c-set-quiet: invalid dest"
				    dest)))))
d545 1
d553 9
a561 8
  (let ((xdest (cond ((c-expr? dest)
		      dest)
		     ((rtx? dest)
		      (rtx-eval-with-estate dest mode estate))
		     (else
		      (estate-error estate
				    "rtl-c-set-trace: invalid dest"
				    dest)))))
d586 1
d623 1
d669 1
d695 1
d736 1
d756 1
d796 1
d821 1
d849 1
a849 1
; Compare SRC1 and SRC2 in mode MODE.  The result has mode BI.
d851 2
d895 1
d927 1
d1025 1
d1055 1
d1100 1
d1233 1
d1323 1
d1447 1
a1447 1
  (send (op:index (rtx-eval-with-estate op 'DFLT estate)) 'cxmake-get estate 'DFLT)
d1480 2
a1481 1
	 (rtx-eval-with-estate rtx mode (estate-with-modifiers estate `((#:delay ,new-delay)))))))
@


1.17
log
@	* read.scm (rtl-version-equal?): New function.
	(rtl-version-at-least?, rtl-version-older?): New functions.

	* *.scm: Use / to prefix "local" vars/fns, for r6rs compliance.
	* pmacros.scm (/pmacro-builtin-splice): Refer to $unsplice for
	rtl versions >= 0.9.
	(pmacros-init!): Tweak to prepare for $<pmacro> for builtin pmacros.
@
text
@d427 4
a430 5
		   (string-append "incompatible mode for "
				  "(" (obj:name (cx:mode src)) " vs "
				  (obj:name mode) ") in "
				  "\"" (cx:c src) "\""
				  ": ")
d457 1
a457 1
				    " referenced in incompatible mode: ")
d473 1
a473 1
					 " referenced in incompatible mode: ")
d488 1
a488 1
	  (else (estate-error estate "/rtl-c-get: invalid argument:" src))))
d517 1
a517 1
				    "rtl-c-set-quiet: invalid dest:"
d520 1
a520 1
	(estate-error estate "rtl-c-set-quiet: invalid dest:" dest))
d544 1
a544 1
				    "rtl-c-set-trace: invalid dest:"
d547 1
a547 1
	(estate-error estate "rtl-c-set-trace: invalid dest:" dest))
d1477 1
a1477 1
	 (estate-error estate "attr: unsupported object type:" owner)))
@


1.16
log
@Rework do-count to take an expression for the iteration count,
and swap the iteration-variable/#iterations arguments.
@
text
@d184 1
a184 1
(define -rtl-c-rtl-cover-fns? #f)
d191 1
a191 1
  (set! -rtl-c-rtl-cover-fns? #f)
d198 1
a198 1
	     (set! -rtl-c-rtl-cover-fns? (cadr args)))
d298 1
a298 1
   -rtl-c-rtl-cover-fns?
d367 1
a367 1
   -rtl-c-rtl-cover-fns?
d414 1
a414 1
(define (-rtl-c-get estate mode src)
d422 1
a422 1
		 ((-rtx-mode-compatible? mode (cx:mode src))
d434 1
a434 1
	  ; The recursive call to -rtl-c-get is in case the result of rtx-eval
d440 1
a440 1
	     (-rtl-c-get estate mode evald-src)))
d451 2
a452 2
		   ((-rtx-mode-compatible? mode (op:mode src))
		    (let ((mode (-rtx-lazy-sem-mode mode)))
d468 2
a469 2
		   ((-rtx-mode-compatible? mode (rtx-temp-mode src))
		    (let ((mode (-rtx-lazy-sem-mode mode)))
d489 1
a489 1
	  (else (estate-error estate "-rtl-c-get: invalid argument:" src))))
d495 1
a495 1
  (let ((result (-rtl-c-get estate mode src)))
d523 2
a524 2
		    (-rtx-obj-mode xdest)
		    (-rtx-lazy-sem-mode mode))))
d550 2
a551 2
		    (-rtx-obj-mode xdest) ; FIXME: internal routines
		    (-rtx-lazy-sem-mode mode))))
d562 1
a562 1
(define -rtl-c-gen-table #f)
d567 1
a567 1
  (vector-ref -rtl-c-gen-table (rtx-num f))
d636 1
a636 1
(define (-rtx-use-sem-fn? estate c-op mode)
d657 1
a657 1
	 (sem-mode (-rtx-sem-mode mode)))
d660 1
a660 1
    (if (-rtx-use-sem-fn? estate c-op mode)
d691 1
a691 1
	 (sem-mode (-rtx-sem-mode mode))
d695 1
a695 1
    (if (-rtx-use-sem-fn? estate c-op mode)
d721 1
a721 1
	 (mode (-rtx-sem-mode (cx:mode val1)))
d744 1
a744 1
	 (sem-mode (-rtx-sem-mode mode))
d748 1
a748 1
    (if (-rtx-use-sem-fn? estate c-op mode)
d815 2
a816 2
				    (string-downcase (obj:str-name (-rtx-sem-mode (cx:mode s))))
				    (string-downcase (obj:str-name (-rtx-sem-mode mode)))
d821 2
a822 2
				    (obj:str-name (-rtx-sem-mode (cx:mode s)))
				    (obj:str-name (-rtx-sem-mode mode))
d840 1
a840 1
    (if (-rtx-use-sem-fn? estate c-op mode)
d845 1
a845 1
				    (string-downcase (obj:str-name (-rtx-sem-mode mode)))
d852 1
a852 1
					(obj:str-name (-rtx-sem-mode mode))
d957 1
a957 1
(define (-gen-case-prefix val)
d985 1
a985 1
			    (string-map -gen-case-prefix caseval))
d989 1
a989 1
			    (-gen-case-prefix caseval)))
d999 1
a999 1
(define (-gen-non-vm-case-test estate mode test cases)
d1037 1
a1037 1
		 (-gen-non-vm-case-test estate mode test (caar case-list))
d1059 1
a1059 1
			 (-gen-non-vm-case-test estate mode test (caar cl))
d1084 1
a1084 1
(define -par-temp-list nil)
d1090 2
a1091 2
(define (-par-new-temp! mode)
  (set! -par-temp-list
d1094 3
a1096 3
					    (length -par-temp-list))))
	      -par-temp-list))
  (car -par-temp-list)
d1102 3
a1104 3
(define (-par-next-temp!)
  (let ((result (car -par-temp-list)))
    (set! -par-temp-list (cdr -par-temp-list))
d1108 1
a1108 1
(define (-gen-par-temp-defns temp-list)
d1126 1
a1126 1
(define (-par-replace-set-dests estate exprs)
d1138 1
a1138 1
			    (-par-new-temp! ; replace dest with temp
d1150 1
a1150 1
; This must process expressions in the same order as -par-replace-set-dests!
d1152 1
a1152 1
(define (-par-replace-set-srcs estate exprs)
d1165 1
a1165 1
			    (-par-next-temp!)) ; the source's temp
d1177 2
a1178 2
    ; Initialize -par-temp-list for -par-replace-set-dests.
    (set! -par-temp-list nil)
d1181 4
a1184 4
				  (-par-replace-set-dests estate exprs)))
	   (temps (reverse! -par-temp-list)))
      ; Initialize -par-temp-list for -par-replace-set-srcs.
      (set! -par-temp-list temps)
d1193 1
a1193 1
		(-gen-par-temp-defns temps)
d1197 1
a1197 1
			    (-par-replace-set-srcs estate exprs))
d1287 1
a1287 1
  (set! -rtl-c-gen-table (rtl-c-build-table))
@


1.15
log
@	Add do-count rtl function.
	* rtl-c.scm (s-do-count): New function.
	(do-count): New rtl handler.
	* rtl-traverse.scm (-rtx-traverse-iteration): New function.
	(-rtx-make-traverser-table): Add ITERATION.
	* rtl.scm (rtx-env-make-iteration-locals): New function.
	* rtx-funcs.scm (do-count): New rtl function.
	* cpu/play.cpu: Add do-count-test insn.
	* doc/rtl.texi: Add docs on do-count.
@
text
@d1246 3
a1248 2
(define (s-do-count estate nr-times iter-var . exprs)
  (let* ((env (rtx-env-make-iteration-locals iter-var))
d1250 4
a1253 1
	 (c-iter-var (rtx-temp-value (rtx-temp-lookup (estate-env estate) iter-var))))
d1258 3
d1262 1
a1262 1
	      "       " c-iter-var " < " (number->string nr-times) ";\n"
d1803 1
a1803 1
(define-fn do-count (estate options mode nr-times iter-var expr . exprs)
d1805 1
a1805 1
	 (cons estate (cons nr-times (cons iter-var (cons expr exprs)))))
@


1.14
log
@	* read.scm (parse-error): Change error message output format
	to match context-owner-error.
	* rtl-c.scm (-rtl-c-get): Call estate-error instead of error.
	(rtl-c-set-quiet, rtl-c-set-trace): Ditto.
	(s-if, s-cond, -gen-non-vm-case-test): Ditto.
	(operand): Call estate-error instead of context-error.
	(local, delay): Ditto.
	(ref, attr): Call estate-error instead of error.
	* rtl-traverse.scm (tstate-error): New function.
	(-rtx-traverse-error): Call tstate-error instead of context-error.
	(-rtx-traverse-operands, -rtx-traverse): Ditto.
	(estate-error): New function.
	* rtl.scm (rtx-lvalue-mode-name): Handle locals.  Call estate-error
	instead of error.
	(e-if): Call estate-error instead of error.
	* rtx-funcs.scm (error): Call estate-error instead of context-error.
	(member): Ditto.
	* utils-cgen.scm (context-error): New arg `intro', all callers updated.
	Rewrite to call context-owner-error.
	(context-owner-error): New function.
@
text
@d1243 22
d1796 5
@


1.13
log
@	* ifield.scm (<ifield> constructor): New arg `location',
	all callers updated.
	* insn.scm (<insn> constructor): Ditto.
	(<multi-insn> constructor): Ditto.
	* minsn.scm (<macro-insn> constructor): Ditto.
	* operand.scm (<operand> constructor): Ditto.
	* utils-cgen.scm (builtin-location): New function.
	(<source-ident>): Fix default value of member `location'.
	(source-ident?): New function.
@
text
@d425 8
a432 5
		  (error (string-append "incompatible mode for "
					"(" (obj:name (cx:mode src)) " vs " (obj:name mode) ") in "
					"\"" (cx:c src) "\""
					": ")
			 (obj:name mode)))))
d455 5
a459 3
		    (error (string-append "operand " (obj:str-name src)
					  " referenced in incompatible mode: ")
			   (obj:name mode))))))
d471 5
a475 3
		   (else (error (string-append "sequence temp " (rtx-temp-name src)
					       " referenced in incompatible mode: ")
				(obj:name mode))))))
d489 1
a489 1
	  (else (error "-rtl-c-get: invalid argument:" src))))
d517 3
a519 1
		      (error "rtl-c-set-quiet: invalid dest:" dest)))))
d521 1
a521 1
	(error "rtl-c-set-quiet: invalid dest:" dest))
d544 3
a546 1
		      (error "rtl-c-set-trace: invalid dest:" dest)))))
d548 1
a548 1
	(error "rtl-c-set-trace: invalid dest:" dest))
d875 1
a875 1
      (error "if: too many elements in `else' part" else))
d897 1
a897 1
	    (error "non-VoidMode `if' must have `else' part"))))
d914 1
a914 1
	(error "empty `cond'"))
d1009 5
a1013 4
			       (context-error (estate-context estate)
					      "symbol not an enum"
					      (car cases))))
			  (else (error "invalid case" (car cases))))))
d1313 1
a1313 2
	       (context-error (estate-context estate)
			      "undefined operand" object-or-name))
d1316 1
a1316 2
	 (context-error (estate-context estate)
			"bad arg to `operand'" object-or-name)))
d1343 1
a1343 2
	       (context-error (estate-context estate)
			      "undefined local" object-or-name))
d1346 1
a1346 2
	 (context-error (estate-context estate)
			"bad arg to `local'" object-or-name)))
d1374 2
a1375 1
      (error "ref: not processing an insn"))
d1408 4
a1411 4
	     (context-error 
	      (estate-context estate) 
	      (string-append 
	       "(delay ...) rtx applied to wrong type of operand '" (car rtx) "'. should be pc, register or memory")))
d1414 2
a1415 3
	     (context-error 	      
	      (estate-context estate) 
	      "delayed operand in a non-parallel cpu"))
d1448 2
a1449 1
	(else (error "attr: unsupported object type:" owner)))
d1780 1
d1782 1
@


1.12
log
@	Clean up cpu file parsing, pass context consistently instead of the
	old "errtxt" argument.
	NOTE: ACU == "All Callers Updated".
	* attr.scm (-parse-simple-attribute): Renamed from
	parse-simple-attribute, ACU.
	(-attr-parse): Change errtxt argument to context, ACU.
	(-attr-read): Ditto.
	(atlist-parse): Ditto.  Put context arg first.
	(attr-parse): Use parse-error instead of context-error.
	* enum.scm (parse-enum-vals): Change errtxt argument to context, ACU.
	(-enum-parse-prefix, -enum-parse, -enum-read): Ditto.
	* hardware.scm (-keyword-parse): Renamed from keyword-parse.
	`context' arg is now a <context> object.  ACU.
	(-keyword-read): `context' arg is now a <context> object.  ACU.
	(-hw-parse-indices): Change errtxt argument to context, ACU.
	(-hw-parse-values, -hw-parse-handlers): Ditto.
	(-hw-parse-getter, -hw-parse-setter, -hw-parse, -hw-read): Ditto.
	(-hw-validate-layout, -hw-create-getter-from-layout,
	-hw-create-setter-from-layout): Ditto.
	(<hw-register>:parse!, <hw-pc>:parse!): Ditto.
	(<hw-memory>:parse!, <hw-immediate>:parse!): Ditto.
	(<hw-address>:parse!): Ditto.
	* ifield.scm (-ifield-parse, ifield-read): Ditto.
	(-ifld-parse-follows, -ifld-parse-encode-decode): Ditto.
	(-ifld-parse-encode, -ifld-parse-decode): Ditto.
	(-multi-ifield-parse, -multi-ifield-read): Ditto.
	* insn.scm (-insn-parse, -insn-read): Ditto.
	(parse-syntax): Ditto.  Put context arg first.
	(-parse-insn-format-symbol): Change errtxt argument to context, ACU.
	(-parse-insn-format-ifield-spec, -parse-insn-format-list): Ditto.
	(-parse-insn-format): Ditto.
	* mach.scm (-arch-parse-alignment, -arch-parse-machs): Ditto.
	(-arch-parse-isas): Ditto.
	(-isa-read): Add context arg, ACU.
	(-cpu-parse, -cpu-read, -mach-read): Ditto.
	* minsn.scm (-minsn-parse-expansion): Change errtxt argument to
	context, ACU.
	(-minsn-parse, -minsn-read, -minsn-compute-iflds): Ditto.
	(minsn-make-alias): Ditto.
	* mode.scm (-mode-parse): Ditto.
	(parse-mode-name): Ditto.  Put context arg first.
	* model.scm (-prefetch-parse, -retire-parse, -pipeline-parse): Change
	errtxt argument to context, ACU.
	(-unit-parse, -model-parse, -model-read): Ditto.
	* operand.scm (-operand-parse-getter): Use parse-error instead of
	context-error.
	(-operand-parse-setter): Ditto.
	(-operand-parse): Change errtxt argument to context, ACU.
	(-operand-read, -derived-operand-parse, -derived-operand-read): Ditto.
	(-anyof-operand-parse, -anyof-operand-read): Ditto.
	* read.scm (reader-error): Delete.  Use parse-error instead.
	(parse-error): Change errtxt argument to context, ACU.  Split args
	argument into expr and maybe-help-text.
	(-reader-process-expanded-1!): Reorganize.
	* rtl.scm (-subr-read): Change errtxt argument to context, ACU.
	* types.scm (parse-type): Ditto.
	* utils-cgen.scm (single-location->simple-string): New function.
	(<context>): Replace members file,lineno with location.
	(make-prefix-context): Renamed from context-make-prefix, ACU.
	(make-current-context): New function.
	(context-append, context-append-name): New functions.
	(context-make-reader): Delete.
	(parse-name): Change errtxt argument to context, ACU.
	Put context arg first.
	(parse-comment): Ditto.
	(parse-number): Change errtxt argument to context, ACU.
	(arg-list-validate-name, arg-list-check-no-args,
	arg-list-symbol-arg): Ditto.

	* read.scm (-cmd-if): Don't assume test is a list.

	* html.scm (get-insn-properties): Delete errtxt, unused.
@
text
@d1283 1
a1283 1
;    (make <operand> ifld-name ifld-name
@


1.11
log
@	* rtl-c.scm (addc-cflag, addc-oflag, subc-cflag, subc-oflag): Define.
	(add-cflag, add-oflag, sub-cflag, sub-oflag): Deprecate.
	* rtx-funcs.scm (addc-cflag, addc-oflag, subc-cflag, subc-oflag):
	Define.
	(add-cflag, add-oflag, sub-cflag, sub-oflag): Deprecate.
	* doc/rtl.texi: Update.
@
text
@d954 2
a955 1
			(parse-error "case:" "bad case" val)))
@


1.10
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d1549 2
a1550 1
(define-fn add-cflag (estate options mode s1 s2 s3)
d1553 1
a1553 1
(define-fn add-oflag (estate options mode s1 s2 s3)
d1556 1
d1560 15
@


1.9
log
@	* rtl-c.scm (delay): Add FIXME, tweak formatting.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2005 Red Hat, Inc.
@


1.8
log
@2007-08-21  Dave Brolley  <brolley@@redhat.com>

        * rtl-c.scm (const): Generate call to MAKEDI for integers larger
        than 32 bits.
@
text
@a1382 1

d1384 1
d1413 2
a1414 2
    (else (s-sequence (estate-with-modifiers estate '((#:delay))) VOID '() rtx))))

@


1.8.4.1
log
@	* All *.scm files: Update copyright year.
	* utils.scm (copyright-fsf, copyright-redhat): Ditto.
@
text
@d2 1
a2 1
; Copyright (C) 2000, 2005, 2009 Red Hat, Inc.
@


1.7
log
@2005-08-02  Dave Brolley  <brolley@@redhat.com>

        * rtl-c.scm (s-unop): Don't dereference
        CGEN_CPU_FPU (current_cpu)->ops->xxxxx in the generated code.
        (s-binop, s-convop, s-cmpop): Likewise.
@
text
@d1449 3
a1451 1
			(mode:eq? 'UDI mode))
@


1.6
log
@2005-06-15  Dave Brolley  <brolley@@redhat.com>

        * sid-cpu.scm (-gen-hw-stream-and-destream-fns): New function.
        (cgen-cpu.h): Call it.

        Contributed on behalf of Graydon Hoare
        2001-06-05  graydon hoare  <graydon@@redhat.com>

        * utils.scm (foldl): Define.
        (foldr): Define.
        (filter): Define.
        (union): Define.
        (intersection): Simplify.
        * sid.scm : Set APPLICATION to SID-SIMULATOR.
        (-op-gen-delayed-set-maybe-trace): Define.
        (<operand> 'gen-set-{quiet,trace}): Delegate to
        op-gen-delayed-set-quiet etc. Note: this is still a little tangled
        up and needs cleaning.
        (-with-parallel?): Hardwire with-parallel to #t.
        (<operand> 'cxmake-get): Replace with lookahead-aware code
        * sid-decode.scm: Remove per-insn writeback fns.
        (-gen-idesc-decls): Redefine sem_fn type.
        * sid-cpu.scm (gen-write-stack-structure): Replace parexec stuff
        with write stack stuff.
        (cgen-write.cxx): Replace per-insn writebacks with single write
        stack writeback. Add write stack reset function.
        (-gen-scache-semantic-fn insn): Replace parexec stuff with write
        stack stuff.
        * rtl-c.scm (xop): Clone operand into delayed operand if #:delayed
        estate attribute set.
        (delay): Set #:delayed attribute to calculated delay, update
        maximum delay of cpu, check (delay ...) usage.
        * operand.scm (<operand>): Add delayed slot to <operand>.
        * mach.scm (<cpu>): Add max-delay slot to <cpu>.
        * dev.scm (load-sid): Set APPLICATION to SID-SIMULATOR.
        * doc/rtl.texi (Expressions): Add section on (delay ...).
@
text
@d2 1
a2 1
; Copyright (C) 2000 Red Hat, Inc.
d652 1
a652 1
		     (string-append "(* CGEN_CPU_FPU (current_cpu)->ops->"
d655 1
a655 1
				    ") (CGEN_CPU_FPU (current_cpu), "
d687 1
a687 1
		     (string-append "(* CGEN_CPU_FPU (current_cpu)->ops->"
d690 1
a690 1
				    ") (CGEN_CPU_FPU (current_cpu), "
d802 1
a802 1
		     (string-append "(* CGEN_CPU_FPU (current_cpu)->ops->"
d806 1
a806 1
				    ") (CGEN_CPU_FPU (current_cpu), "
d832 1
a832 1
		     (string-append "(* CGEN_CPU_FPU (current_cpu)->ops->"
d835 1
a835 1
				    ") (CGEN_CPU_FPU (current_cpu), "
@


1.5
log
@	Add guile 1.6.4 support.
	- empty list must be quoted
	- string functions have stricter type checking
	- eval now takes a second argument
	- symbol-bound? is deprecated
	* attr.scm (-attr-parse): Use stringsym-append to build errtxt.
	(bitset-attr->list): Ensure arg to string-cut is a string.
	(attr-parse): Ensure args to string-ref and string-drop1 are strings.
	(<enum-attribute>,gen-value-for-defn): Fetch string name of self.
	* cos.scm (-class-list): Must quote empty list.
	(-class-parent-classes,-class-compute-class-desc): Ditto.
	(class-make,make,object-reset!): Ditto.
	(method-make-make!): Call eval1 instead of eval.
	(method-make-forward!,method-make-virtual-forward!): Ditto.
	* decode.scm (subdtable-add): Use stringsym-append instead of
	string-append.
	(-gen-exprtable-name): Fetch string name of exprtable-entry-insn.
	(-build-decode-table-entry): Fetch string name of insn.
	* desc-cpu.scm (-gen-isa-table-defns): Fetch string name of isa.
	(-gen-mach-table-defns): Ditto for mach.
	(gen-ifld-defns): Ditto for ifld.
	(gen-hw-table-defns): Ditto for hw.
	(gen-operand-table): Ditto for op.
	(gen-insn-table-entry): Ditto for insn.
	* desc.scm (gen-attr-table-defn): Ditto for attr.
	(<keyword>,gen-defn): Don't pass symbols to string-append.
	* enum.scm (parse-enum-vals): Use symbolstr-append instead of
	symbol-append.
	(enum-vals-upcase): Use symbol-upcase to build result.
	(-enum-parse): Use stringsym-append to build errtxt.
	* fixup.scm (*guile-major-version*,*guile-minor-version*): New globals.
	(eval1): New function.
	(symbol-bound?): Provide own version if >= guile 1.6.
	* hardware.scm (define-keyword): Use string-append instead of
	symbol-append.
	* html.scm (gen-html-header,gen-table-of-contents,gen-arch-intro,
	cgen.html,cgen-insn.html): Convert current-arch-name to a string
	before using.
	(gen-list-entry): Handle either symbol or string `name' arg.
	(gen-obj-doc-header): Fetch string name of `o' arg.
	(define-cpu-intro): Ditto for cpu.
	(gen-mach-intro): Ditto for mach.
	(gen-model-intro): Ditto for model.
	(gen-isa-intro): Ditto for isa.
	(gen-machine-doc-1): Ditto for isa.
	(gen-reg-doc-1): Convert mach to string first.
	(gen-insn-doc-1): Ditto.  Convert model/unit names to strings first.
	(gen-insn-doc-list): Fetch string name of mach.  Convert insn name
	to string first.
	(gen-insn-categories): Fetch string name of mach.  Convert
	enum-val-name to string first.
	(gen-insn-docs): Fetch string name of mach.
	* ifield.scm (ifld-ilk): Result is a string.
	* iformat.scm (-ifmt-search-key): Convert attr value to string first.
	Fetch string name of ifld.
	(-sfmt-search-key): Similarily for ifld and op.
	* insn.scm (syntax-make): Fetch string name of syntax element.
	* mach.scm (-cpu-parse): Use stringsym-append to build errtxt.
	* minsn.scm (minsn-make-alias): Fetch string name of minsn.
	* mode.scm (mode:c-type): Result is a string.
	(mode:enum): Fetch string name of mode.
	(-mode-parse): Use stringsym-append to build errtxt.
	* model.scm (model:enum): Fetch string name of model.
	(-model-parse): Use stringsym-append to build errtxt.
	(parse-insn-timing): Must quote empty list.
	* opc-itab.scm (-gen-minsn-table-entry): Fetch string name of minsn.
	(-gen-minsn-opcode-entry): Ditto.
	* opcodes.scm (<operand>,gen-function-name): `what' arg is a symbol,
	convert to string.
	(read-cpu.opc): Convert current-arch-name to a string before using.
	* operand.scm (<operand>,gen-pretty-name): Ensure `name' is a string.
	(<derived-operand>): Must quote empty list.
	(op-sort): Simplify, call alpha-sort-obj-list to do sort.
	* pgmr-tools.scm (pgmr-pretty-print-insn-value): Fetch string name
	of ifld.
	* pmacros.scm (-pmacro-build-lambda): Use eval1 instead of eval.
	(-pmacro-sym): Must convert symbols to strings before passing to
	string-append.
	(-pmacro-str): Ditto.
	(pmacros-init!): Use eval1 instead of eval.
	* read.scm (keep-mach-atlist?): Simplify, use bitset-attr->list.
	(keep-isa-atlist?): Ditto.
	(cmd-if): Use eval1 instead of eval.
	* rtl-c.scm (<c-expr>,get-name): Fetch string name of self.
	(-rtl-c-get): Fetch string name of src.
	(s-unop): Ditto for mode.
	(s-binop,s-binop-with-bit,s-shop,s-convop,s-cmpop): Ditto.
	(-gen-par-temp-defns,subword): Ditto.
	(join): Use stringsym-append instead of string-append.
	* rtl-traverse.scm (rtx-option?): Convert option to string first.
	(rtx-traverse-debug): Fetch string name of rtx-obj.
	* rtl.scm (def-rtx-node): Use eval1 instead of eval.
	(def-rtx-syntax-node,def-rtx-operand-node,def-rtx-macro-node): Ditto.
	(rtx-pretty-name): Result is a string.
	(-rtx-hw-name): Use symbolstr-append instead of symbol-append.
	* semantics.scm (semantic-compile): Simplify, use alpha-sort-obj-list.
	* sid-cpu.scm (cgen-write.cxx): Convert current-arch-name to a string
	before using.
	(-gen-sfrag-case): Fetch string name of user.
	* sid-model.scm (unit:enum): Fetch string name of unit.
	* sid.scm (<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Convert current-arch-name to a string before using.
	* sim-cpu.scm (-gen-scache-semantic-fn): Fetch string name of insn.
	(-gen-no-scache-semantic-fn): Ditto.
	(cgen-defs.h): Fetch string name of isa.
	(cgen-read.c): Convert current-arch-name to a string before using.
	(cgen-write.c): Ditto.
	* sim-model.scm (unit:enum): Fetch string name of unit.
	(gen-model-fn-decls): Use stringsym-append instead of string-append.
	(-gen-model-timing-table): Fetch string name of model.
	(-gen-mach-model-table): Ditto.
	(-gen-mach-defns): Fetch string name of mach.
	* sim.scm (gen-reg-access-defn): Fetch string name of hw.
	(<hw-memory>,cxmake-get): Fetch string name of mode.
	(<hw-memory>,gen-set-quiet): Ditto.
	(gen-mode-defs): Ditto.
	(sim-finish!): Must quote empty list.
	* utils-cgen.scm (<ident>): Must quote empty list.
	(obj:str-name): New fn.
	(parse-comment): Result is a string.
	(parse-symbol): Result is a symbol.
	(parse-string): Result is a string.
	(keyword-list?): Convert arg to string before calling string-ref.
	(keyword-list->arg-list): Ditto.
	(gen-attr-name): Convert attr-name to string first.
	(alpha-sort-obj-list): Use symbol<? instead of string<?.
	* utils-gen.scm (attr-gen-decl): Fetch string name of attr.
	(gen-define-ifmt-ifields): Ditto for fld.
	* utils.scm (gen-c-symbol): Ensure str is a string before calling
	map-over-string.
	(gen-file-name): Ditto.
	(symbol-downcase,symbol-upcase,symbol<?): New fns.
	(stringsym-append,symbolstr-append,->string,->symbol): New fns.
	(reduce): Call eval1 instead of eval.
	* cpu/m32r.cpu (addi): Don't use `#.'.
@
text
@d1308 17
a1324 1
(define-fn xop (estate options mode object) object)
d1383 32
a1414 3
(define-fn delay (estate options mode n rtx)
  (s-sequence (estate-with-modifiers estate '((#:delay))) VOID '() rtx) ; wip!
)
@


1.4
log
@* bug fix

2000-09-08  Frank Ch. Eigler  <fche@@redhat.com>

	* rtl-c.scm (s-sequence): Handle nested c-calls in both
	statement-expression and comma-expression contexts.
	(s-c-call, s-c-raw-call): Add warning comment about bad assumption.
@
text
@d101 1
a101 1
   (string-append "(" (obj:name (elm-get self 'mode)) ") "
d452 1
a452 1
		    (error (string-append "operand " (obj:name src)
d654 1
a654 1
				    (string-downcase (obj:name sem-mode))
d658 1
a658 1
		     (string-append name (obj:name sem-mode)
d689 1
a689 1
				    (string-downcase (obj:name sem-mode))
d694 1
a694 1
		     (string-append name (obj:name sem-mode)
d715 1
a715 1
	  (string-append name (obj:name mode)
d739 1
a739 1
		 (string-append name (obj:name sem-mode)
d796 2
a797 2
		 (string-append "((" (obj:name mode) ")"
				" (" (obj:name (cx:mode s)) ")"
d804 2
a805 2
				    (string-downcase (obj:name (-rtx-sem-mode (cx:mode s))))
				    (string-downcase (obj:name (-rtx-sem-mode mode)))
d810 2
a811 2
				    (obj:name (-rtx-sem-mode (cx:mode s)))
				    (obj:name (-rtx-sem-mode mode))
d833 2
a834 2
				    (string-downcase name)
				    (string-downcase (obj:name (-rtx-sem-mode mode)))
d839 1
a839 1
		     (string-append (string-upcase name)
d841 2
a842 2
					(obj:name (-rtx-sem-mode mode))
					(obj:name mode))
d1100 2
a1101 1
   (string-map (lambda (temp) (string-append (obj:name (cx:mode temp)) " " (cx:c temp) ";"))
d1425 3
a1427 3
				  (cons (string-append "JOIN"
						       in-mode
						       out-mode)
d1437 2
a1438 1
	     (string-append "SUBWORD" (obj:name val-mode) (obj:name mode)
@


1.3
log
@2000-08-24  Frank Ch. Eigler  <fche@@redhat.com>

	* hardware.scm (<hw-immediate> get-index-mode): Define method.
	* operand.scm (<operand> gen-pretty-name): Tolerate no op:sem-name.
	* rtl-c.scm (-c-rtl-get): Improve an error message.
	* sim.scm (-op-gen-set-trace): Support <derived-operand> lvalues.
@
text
@d583 3
d608 3
d1217 9
a1225 2
				   ", "
				   (rtl-c-with-estate estate DFLT e)))
@


1.2
log
@	* rtl-c.scm (rtl-c-expr-with-estate): New fn.
	(rtl-c-expr-parsed,rtl-c-expr): New fns.
	(-rtl-c-get): Rename from rtl-c-get.
	(rtl-c-get): New fn for getter logging.
@
text
@d426 1
a426 1
					"(" (obj:name (cx:mode src)) ") "
@


1.1
log
@Initial revision
@
text
@d332 22
d414 1
a414 3
(define (rtl-c-get estate mode src)
  (logit 4 "(rtl-c-get " (mode-real-name mode) " " (rtx-strdump src) ")\n")

d431 1
a431 1
	  ; The recursive call to rtl-c-get is in case the result of rtx-eval
d437 1
a437 1
	     (rtl-c-get estate mode evald-src)))
d482 11
a492 1
	  (else (error "rtl-c-get: invalid argument:" src))))
@


1.1.1.1
log
@CGEN 1.0 import
@
text
@@
