head	1.17;
access;
symbols
	sid-snapshot-20180601:1.17
	sid-snapshot-20180501:1.17
	sid-snapshot-20180401:1.17
	sid-snapshot-20180301:1.17
	sid-snapshot-20180201:1.17
	sid-snapshot-20180101:1.17
	sid-snapshot-20171201:1.17
	sid-snapshot-20171101:1.17
	sid-snapshot-20171001:1.17
	sid-snapshot-20170901:1.17
	sid-snapshot-20170801:1.17
	sid-snapshot-20170701:1.17
	sid-snapshot-20170601:1.17
	sid-snapshot-20170501:1.17
	sid-snapshot-20170401:1.17
	sid-snapshot-20170301:1.17
	sid-snapshot-20170201:1.17
	sid-snapshot-20170101:1.17
	sid-snapshot-20161201:1.17
	sid-snapshot-20161101:1.17
	sid-snapshot-20160901:1.17
	sid-snapshot-20160801:1.17
	sid-snapshot-20160701:1.17
	sid-snapshot-20160601:1.17
	sid-snapshot-20160501:1.17
	sid-snapshot-20160401:1.17
	sid-snapshot-20160301:1.17
	sid-snapshot-20160201:1.17
	sid-snapshot-20160101:1.17
	sid-snapshot-20151201:1.17
	sid-snapshot-20151101:1.17
	sid-snapshot-20151001:1.17
	sid-snapshot-20150901:1.17
	sid-snapshot-20150801:1.17
	sid-snapshot-20150701:1.17
	sid-snapshot-20150601:1.17
	sid-snapshot-20150501:1.17
	sid-snapshot-20150401:1.17
	sid-snapshot-20150301:1.17
	sid-snapshot-20150201:1.17
	sid-snapshot-20150101:1.17
	sid-snapshot-20141201:1.17
	sid-snapshot-20141101:1.17
	sid-snapshot-20141001:1.17
	sid-snapshot-20140901:1.17
	sid-snapshot-20140801:1.17
	sid-snapshot-20140701:1.17
	sid-snapshot-20140601:1.17
	sid-snapshot-20140501:1.17
	sid-snapshot-20140401:1.17
	sid-snapshot-20140301:1.17
	sid-snapshot-20140201:1.17
	sid-snapshot-20140101:1.17
	sid-snapshot-20131201:1.17
	sid-snapshot-20131101:1.17
	sid-snapshot-20131001:1.17
	binutils-2_24-branch:1.17.0.52
	binutils-2_24-branchpoint:1.17
	binutils-2_21_1:1.17
	sid-snapshot-20130901:1.17
	gdb_7_6_1-2013-08-30-release:1.17
	sid-snapshot-20130801:1.17
	sid-snapshot-20130701:1.17
	sid-snapshot-20130601:1.17
	sid-snapshot-20130501:1.17
	gdb_7_6-2013-04-26-release:1.17
	sid-snapshot-20130401:1.17
	binutils-2_23_2:1.17
	gdb_7_6-branch:1.17.0.50
	gdb_7_6-2013-03-12-branchpoint:1.17
	sid-snapshot-20130301:1.17
	sid-snapshot-20130201:1.17
	sid-snapshot-20130101:1.17
	sid-snapshot-20121201:1.17
	gdb_7_5_1-2012-11-29-release:1.17
	binutils-2_23_1:1.17
	sid-snapshot-20121101:1.17
	binutils-2_23:1.17
	sid-snapshot-20121001:1.17
	sid-snapshot-20120901:1.17
	gdb_7_5-2012-08-17-release:1.17
	sid-snapshot-20120801:1.17
	binutils-2_23-branch:1.17.0.48
	binutils-2_23-branchpoint:1.17
	gdb_7_5-branch:1.17.0.46
	gdb_7_5-2012-07-18-branchpoint:1.17
	sid-snapshot-20120701:1.17
	sid-snapshot-20120601:1.17
	sid-snapshot-20120501:1.17
	binutils-2_22_branch:1.17.0.44
	gdb_7_4_1-2012-04-26-release:1.17
	sid-snapshot-20120401:1.17
	sid-snapshot-20120301:1.17
	sid-snapshot-20120201:1.17
	gdb_7_4-2012-01-24-release:1.17
	sid-snapshot-20120101:1.17
	gdb_7_4-branch:1.17.0.42
	gdb_7_4-2011-12-13-branchpoint:1.17
	sid-snapshot-20111201:1.17
	binutils-2_22:1.17
	sid-snapshot-20111101:1.17
	sid-snapshot-20111001:1.17
	binutils-2_22-branch:1.17.0.40
	binutils-2_22-branchpoint:1.17
	gdb_7_3_1-2011-09-04-release:1.17
	sid-snapshot-20110901:1.17
	sid-snapshot-20110801:1.17
	gdb_7_3-2011-07-26-release:1.17
	sid-snapshot-20110701:1.17
	sid-snapshot-20110601:1.17
	sid-snapshot-20110501:1.17
	gdb_7_3-branch:1.17.0.38
	gdb_7_3-2011-04-01-branchpoint:1.17
	sid-snapshot-20110401:1.17
	sid-snapshot-20110301:1.17
	sid-snapshot-20110201:1.17
	sid-snapshot-20110101:1.17
	binutils-2_21:1.17
	sid-snapshot-20101201:1.17
	binutils-2_21-branch:1.17.0.36
	binutils-2_21-branchpoint:1.17
	sid-snapshot-20101101:1.17
	sid-snapshot-20101001:1.17
	binutils-2_20_1:1.17
	gdb_7_2-2010-09-02-release:1.17
	sid-snapshot-20100901:1.17
	sid-snapshot-20100801:1.17
	gdb_7_2-branch:1.17.0.34
	gdb_7_2-2010-07-07-branchpoint:1.17
	sid-snapshot-20100701:1.17
	sid-snapshot-20100601:1.17
	sid-snapshot-20100501:1.17
	sid-snapshot-20100401:1.17
	gdb_7_1-2010-03-18-release:1.17
	sid-snapshot-20100301:1.17
	gdb_7_1-branch:1.17.0.32
	gdb_7_1-2010-02-18-branchpoint:1.17
	sid-snapshot-20100201:1.17
	sid-snapshot-20100101:1.17
	gdb_7_0_1-2009-12-22-release:1.17
	sid-snapshot-20091201:1.17
	sid-snapshot-20091101:1.17
	binutils-2_20:1.17
	gdb_7_0-2009-10-06-release:1.17
	sid-snapshot-20091001:1.17
	gdb_7_0-branch:1.17.0.30
	gdb_7_0-2009-09-16-branchpoint:1.17
	arc-sim-20090309:1.17.18.1
	binutils-arc-20081103-branch:1.17.0.28
	binutils-arc-20081103-branchpoint:1.17
	binutils-2_20-branch:1.17.0.26
	binutils-2_20-branchpoint:1.17
	sid-snapshot-20090901:1.17
	sid-snapshot-20090801:1.17
	msnyder-checkpoint-072509-branch:1.17.0.24
	msnyder-checkpoint-072509-branchpoint:1.17
	sid-snapshot-20090701:1.17
	dje-cgen-play1-branch:1.17.0.22
	dje-cgen-play1-branchpoint:1.17
	sid-snapshot-20090601:1.17
	sid-snapshot-20090501:1.17
	sid-snapshot-20090401:1.17
	arc-20081103-branch:1.17.0.20
	arc-20081103-branchpoint:1.17
	arc-insight_6_8-branch:1.17.0.18
	arc-insight_6_8-branchpoint:1.17
	insight_6_8-branch:1.17.0.16
	insight_6_8-branchpoint:1.17
	sid-snapshot-20090301:1.17
	binutils-2_19_1:1.17
	sid-snapshot-20090201:1.17
	sid-snapshot-20090101:1.17
	reverse-20081226-branch:1.17.0.14
	reverse-20081226-branchpoint:1.17
	sid-snapshot-20081201:1.17
	multiprocess-20081120-branch:1.17.0.12
	multiprocess-20081120-branchpoint:1.17
	sid-snapshot-20081101:1.17
	binutils-2_19:1.17
	sid-snapshot-20081001:1.17
	reverse-20080930-branch:1.17.0.10
	reverse-20080930-branchpoint:1.17
	binutils-2_19-branch:1.17.0.8
	binutils-2_19-branchpoint:1.17
	sid-snapshot-20080901:1.17
	sid-snapshot-20080801:1.17
	reverse-20080717-branch:1.17.0.6
	reverse-20080717-branchpoint:1.17
	sid-snapshot-20080701:1.17
	msnyder-reverse-20080609-branch:1.17.0.4
	msnyder-reverse-20080609-branchpoint:1.17
	drow-reverse-20070409-branch:1.15.0.32
	drow-reverse-20070409-branchpoint:1.15
	sid-snapshot-20080601:1.17
	sid-snapshot-20080501:1.17
	sid-snapshot-20080403:1.17
	sid-snapshot-20080401:1.17
	gdb_6_8-2008-03-27-release:1.17
	sid-snapshot-20080301:1.17
	gdb_6_8-branch:1.17.0.2
	gdb_6_8-2008-02-26-branchpoint:1.17
	sid-snapshot-20080201:1.17
	sid-snapshot-20080101:1.17
	sid-snapshot-20071201:1.17
	sid-snapshot-20071101:1.17
	gdb_6_7_1-2007-10-29-release:1.16
	gdb_6_7-2007-10-10-release:1.16
	sid-snapshot-20071001:1.16
	gdb_6_7-branch:1.16.0.4
	gdb_6_7-2007-09-07-branchpoint:1.16
	binutils-2_18:1.16
	binutils-2_18-branch:1.16.0.2
	binutils-2_18-branchpoint:1.16
	insight_6_6-20070208-release:1.15
	binutils-csl-coldfire-4_1-32:1.15
	binutils-csl-sourcerygxx-4_1-32:1.15
	gdb_6_6-2006-12-18-release:1.15
	binutils-csl-innovasic-fido-3_4_4-33:1.15
	binutils-csl-sourcerygxx-3_4_4-32:1.13
	binutils-csl-coldfire-4_1-30:1.15
	binutils-csl-sourcerygxx-4_1-30:1.15
	binutils-csl-coldfire-4_1-28:1.15
	binutils-csl-sourcerygxx-4_1-29:1.15
	binutils-csl-sourcerygxx-4_1-28:1.15
	gdb_6_6-branch:1.15.0.30
	gdb_6_6-2006-11-15-branchpoint:1.15
	binutils-csl-arm-2006q3-27:1.15
	binutils-csl-sourcerygxx-4_1-27:1.15
	binutils-csl-arm-2006q3-26:1.15
	binutils-csl-sourcerygxx-4_1-26:1.15
	binutils-csl-sourcerygxx-4_1-25:1.15
	binutils-csl-sourcerygxx-4_1-24:1.15
	binutils-csl-sourcerygxx-4_1-23:1.15
	insight_6_5-20061003-release:1.15
	gdb-csl-symbian-6_4_50_20060226-12:1.15
	binutils-csl-sourcerygxx-4_1-21:1.15
	binutils-csl-arm-2006q3-21:1.15
	binutils-csl-sourcerygxx-4_1-22:1.15
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.15
	binutils-csl-sourcerygxx-4_1-20:1.15
	binutils-csl-arm-2006q3-19:1.15
	binutils-csl-sourcerygxx-4_1-19:1.15
	binutils-csl-sourcerygxx-4_1-18:1.15
	binutils-csl-renesas-4_1-9:1.15
	gdb-csl-sourcerygxx-3_4_4-25:1.15
	binutils-csl-sourcerygxx-3_4_4-25:1.13
	nickrob-async-20060828-mergepoint:1.15
	gdb-csl-symbian-6_4_50_20060226-11:1.15
	binutils-csl-renesas-4_1-8:1.15
	binutils-csl-renesas-4_1-7:1.15
	binutils-csl-renesas-4_1-6:1.15
	gdb-csl-sourcerygxx-4_1-17:1.15
	binutils-csl-sourcerygxx-4_1-17:1.15
	gdb-csl-20060226-branch-local-2:1.15
	gdb-csl-sourcerygxx-4_1-14:1.15
	binutils-csl-sourcerygxx-4_1-14:1.15
	binutils-csl-sourcerygxx-4_1-15:1.15
	gdb-csl-sourcerygxx-4_1-13:1.15
	binutils-csl-sourcerygxx-4_1-13:1.15
	binutils-2_17:1.15
	gdb-csl-sourcerygxx-4_1-12:1.15
	binutils-csl-sourcerygxx-4_1-12:1.15
	gdb-csl-sourcerygxx-3_4_4-21:1.15
	binutils-csl-sourcerygxx-3_4_4-21:1.15
	gdb_6_5-20060621-release:1.15
	binutils-csl-wrs-linux-3_4_4-24:1.13
	binutils-csl-wrs-linux-3_4_4-23:1.13
	gdb-csl-sourcerygxx-4_1-9:1.15
	binutils-csl-sourcerygxx-4_1-9:1.15
	gdb-csl-sourcerygxx-4_1-8:1.15
	binutils-csl-sourcerygxx-4_1-8:1.15
	gdb-csl-sourcerygxx-4_1-7:1.15
	binutils-csl-sourcerygxx-4_1-7:1.15
	gdb-csl-arm-2006q1-6:1.15
	binutils-csl-arm-2006q1-6:1.15
	gdb-csl-sourcerygxx-4_1-6:1.15
	binutils-csl-sourcerygxx-4_1-6:1.15
	binutils-csl-wrs-linux-3_4_4-22:1.13
	gdb-csl-symbian-6_4_50_20060226-10:1.15
	gdb-csl-symbian-6_4_50_20060226-9:1.15
	gdb-csl-symbian-6_4_50_20060226-8:1.15
	gdb-csl-coldfire-4_1-11:1.15
	binutils-csl-coldfire-4_1-11:1.15
	gdb-csl-sourcerygxx-3_4_4-19:1.15
	binutils-csl-sourcerygxx-3_4_4-19:1.15
	gdb-csl-coldfire-4_1-10:1.15
	gdb_6_5-branch:1.15.0.28
	gdb_6_5-2006-05-14-branchpoint:1.15
	binutils-csl-coldfire-4_1-10:1.15
	gdb-csl-sourcerygxx-4_1-5:1.15
	binutils-csl-sourcerygxx-4_1-5:1.15
	nickrob-async-20060513-branch:1.15.0.26
	nickrob-async-20060513-branchpoint:1.15
	gdb-csl-sourcerygxx-4_1-4:1.15
	binutils-csl-sourcerygxx-4_1-4:1.15
	msnyder-reverse-20060502-branch:1.15.0.24
	msnyder-reverse-20060502-branchpoint:1.15
	binutils-csl-wrs-linux-3_4_4-21:1.13
	gdb-csl-morpho-4_1-4:1.15
	binutils-csl-morpho-4_1-4:1.15
	gdb-csl-sourcerygxx-3_4_4-17:1.15
	binutils-csl-sourcerygxx-3_4_4-17:1.15
	binutils-csl-wrs-linux-3_4_4-20:1.13
	readline_5_1-import-branch:1.15.0.22
	readline_5_1-import-branchpoint:1.15
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.15
	binutils-2_17-branch:1.15.0.20
	binutils-2_17-branchpoint:1.15
	gdb-csl-symbian-20060226-branch:1.15.0.18
	gdb-csl-symbian-20060226-branchpoint:1.15
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.15
	msnyder-reverse-20060331-branch:1.15.0.16
	msnyder-reverse-20060331-branchpoint:1.15
	binutils-csl-2_17-branch:1.15.0.14
	binutils-csl-2_17-branchpoint:1.15
	gdb-csl-available-20060303-branch:1.15.0.12
	gdb-csl-available-20060303-branchpoint:1.15
	gdb-csl-20060226-branch:1.15.0.10
	gdb-csl-20060226-branchpoint:1.15
	gdb_6_4-20051202-release:1.15
	msnyder-fork-checkpoint-branch:1.15.0.8
	msnyder-fork-checkpoint-branchpoint:1.15
	gdb-csl-gxxpro-6_3-branch:1.15.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.15
	gdb_6_4-branch:1.15.0.4
	gdb_6_4-2005-11-01-branchpoint:1.15
	gdb-csl-arm-20051020-branch:1.15.0.2
	gdb-csl-arm-20051020-branchpoint:1.15
	binutils-csl-gxxpro-3_4-branch:1.13.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.13
	binutils-2_16_1:1.13
	msnyder-tracepoint-checkpoint-branch:1.14.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.14
	gdb-csl-arm-20050325-2005-q1b:1.13
	binutils-csl-arm-2005q1b:1.13
	binutils-2_16:1.13
	gdb-csl-arm-20050325-2005-q1a:1.13
	binutils-csl-arm-2005q1a:1.13
	csl-arm-20050325-branch:1.13.0.6
	csl-arm-20050325-branchpoint:1.13
	binutils-csl-arm-2005q1-branch:1.13.0.4
	binutils-csl-arm-2005q1-branchpoint:1.13
	binutils-2_16-branch:1.13.0.2
	binutils-2_16-branchpoint:1.13
	csl-arm-2004-q3d:1.11
	gdb_6_3-20041109-release:1.11
	gdb_6_3-branch:1.11.0.60
	gdb_6_3-20041019-branchpoint:1.11
	csl-arm-2004-q3:1.11
	drow_intercu-merge-20040921:1.11
	drow_intercu-merge-20040915:1.11
	jimb-gdb_6_2-e500-branch:1.11.0.62
	jimb-gdb_6_2-e500-branchpoint:1.11
	gdb_6_2-20040730-release:1.11
	gdb_6_2-branch:1.11.0.58
	gdb_6_2-2004-07-10-gmt-branchpoint:1.11
	gdb_6_1_1-20040616-release:1.11
	binutils-2_15:1.11
	binutils-2_15-branchpoint:1.11
	csl-arm-2004-q1a:1.11
	csl-arm-2004-q1:1.11
	gdb_6_1-2004-04-05-release:1.11
	drow_intercu-merge-20040402:1.11
	drow_intercu-merge-20040327:1.11
	ezannoni_pie-20040323-branch:1.11.0.56
	ezannoni_pie-20040323-branchpoint:1.11
	cagney_tramp-20040321-mergepoint:1.11
	cagney_tramp-20040309-branch:1.11.0.54
	cagney_tramp-20040309-branchpoint:1.11
	gdb_6_1-branch:1.11.0.52
	gdb_6_1-2004-03-01-gmt-branchpoint:1.11
	drow_intercu-20040221-branch:1.11.0.50
	drow_intercu-20040221-branchpoint:1.11
	binutils-2_15-branch:1.11.0.48
	cagney_bfdfile-20040213-branch:1.11.0.46
	cagney_bfdfile-20040213-branchpoint:1.11
	drow-cplus-merge-20040208:1.11
	carlton_dictionary-20040126-merge:1.11
	cagney_bigcore-20040122-branch:1.11.0.44
	cagney_bigcore-20040122-branchpoint:1.11
	drow-cplus-merge-20040113:1.11
	csl-arm-2003-q4:1.11
	drow-cplus-merge-20031224:1.11
	drow-cplus-merge-20031220:1.11
	carlton_dictionary-20031215-merge:1.11
	drow-cplus-merge-20031214:1.11
	carlton-dictionary-20031111-merge:1.11
	gdb_6_0-2003-10-04-release:1.11
	kettenis_sparc-20030918-branch:1.11.0.42
	kettenis_sparc-20030918-branchpoint:1.11
	carlton_dictionary-20030917-merge:1.11
	ezannoni_pie-20030916-branchpoint:1.11
	ezannoni_pie-20030916-branch:1.11.0.40
	cagney_x86i386-20030821-branch:1.11.0.38
	cagney_x86i386-20030821-branchpoint:1.11
	carlton_dictionary-20030805-merge:1.11
	carlton_dictionary-20030627-merge:1.11
	gdb_6_0-branch:1.11.0.36
	gdb_6_0-2003-06-23-branchpoint:1.11
	jimb-ppc64-linux-20030613-branch:1.11.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.11
	binutils-2_14:1.11
	cagney_convert-20030606-branch:1.11.0.32
	cagney_convert-20030606-branchpoint:1.11
	cagney_writestrings-20030508-branch:1.11.0.30
	cagney_writestrings-20030508-branchpoint:1.11
	jimb-ppc64-linux-20030528-branch:1.11.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.11
	carlton_dictionary-20030523-merge:1.11
	cagney_fileio-20030521-branch:1.11.0.26
	cagney_fileio-20030521-branchpoint:1.11
	kettenis_i386newframe-20030517-mergepoint:1.11
	jimb-ppc64-linux-20030509-branch:1.11.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.11
	kettenis_i386newframe-20030504-mergepoint:1.11
	carlton_dictionary-20030430-merge:1.11
	binutils-2_14-branch:1.11.0.22
	binutils-2_14-branchpoint:1.11
	kettenis_i386newframe-20030419-branch:1.11.0.20
	kettenis_i386newframe-20030419-branchpoint:1.11
	carlton_dictionary-20030416-merge:1.11
	cagney_frameaddr-20030409-mergepoint:1.11
	kettenis_i386newframe-20030406-branch:1.11.0.18
	kettenis_i386newframe-20030406-branchpoint:1.11
	cagney_frameaddr-20030403-branchpoint:1.11
	cagney_frameaddr-20030403-branch:1.11.0.16
	cagney_framebase-20030330-mergepoint:1.11
	cagney_framebase-20030326-branch:1.11.0.14
	cagney_framebase-20030326-branchpoint:1.11
	cagney_lazyid-20030317-branch:1.11.0.12
	cagney_lazyid-20030317-branchpoint:1.11
	kettenis-i386newframe-20030316-mergepoint:1.11
	offbyone-20030313-branch:1.11.0.10
	offbyone-20030313-branchpoint:1.11
	kettenis-i386newframe-20030308-branch:1.11.0.8
	kettenis-i386newframe-20030308-branchpoint:1.11
	carlton_dictionary-20030305-merge:1.11
	cagney_offbyone-20030303-branch:1.11.0.6
	cagney_offbyone-20030303-branchpoint:1.11
	carlton_dictionary-20030207-merge:1.11
	interps-20030202-branch:1.11.0.4
	interps-20030202-branchpoint:1.11
	cagney-unwind-20030108-branch:1.11.0.2
	cagney-unwind-20030108-branchpoint:1.11
	binutils-2_13_2_1:1.9
	binutils-2_13_2:1.9
	carlton_dictionary-20021223-merge:1.11
	gdb_5_3-2002-12-12-release:1.10
	carlton_dictionary-20021115-merge:1.10
	binutils-2_13_1:1.9
	kseitz_interps-20021105-merge:1.10
	kseitz_interps-20021103-merge:1.10
	drow-cplus-merge-20021020:1.10
	drow-cplus-merge-20021025:1.10
	carlton_dictionary-20021025-merge:1.10
	carlton_dictionary-20021011-merge:1.10
	drow-cplus-branch:1.10.0.8
	drow-cplus-branchpoint:1.10
	kseitz_interps-20020930-merge:1.10
	carlton_dictionary-20020927-merge:1.10
	carlton_dictionary-branch:1.10.0.6
	carlton_dictionary-20020920-branchpoint:1.10
	sid-20020905-branchpoint:1.10
	sid-20020905-branch:1.10.0.4
	gdb_5_3-branch:1.10.0.2
	gdb_5_3-2002-09-04-branchpoint:1.10
	kseitz_interps-20020829-merge:1.9
	cagney_sysregs-20020825-branch:1.9.0.16
	cagney_sysregs-20020825-branchpoint:1.9
	readline_4_3-import-branch:1.9.0.14
	readline_4_3-import-branchpoint:1.9
	binutils-2_13:1.9
	gdb_5_2_1-2002-07-23-release:1.9
	binutils-2_13-branchpoint:1.9
	binutils-2_13-branch:1.9.0.12
	kseitz_interps-20020528-branch:1.9.0.10
	kseitz_interps-20020528-branchpoint:1.9
	cagney_regbuf-20020515-branch:1.9.0.8
	cagney_regbuf-20020515-branchpoint:1.9
	binutils-2_12_1:1.9
	jimb-macro-020506-branch:1.9.0.6
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.9
	binutils-2_12:1.9
	gdb_5_2-branch:1.9.0.4
	gdb_5_2-2002-03-03-branchpoint:1.9
	binutils-2_12-branch:1.9.0.2
	binutils-2_12-branchpoint:1.9
	gdb_5_1_1-2002-01-24-release:1.8
	gdb_5_1_0_1-2002-01-03-release:1.8
	cygnus_cvs_20020108_pre:1.9
	gdb_5_1_0_1-2002-01-03-branch:1.8.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.8
	gdb_5_1-2001-11-21-release:1.8
	gdb_s390-2001-09-26-branch:1.8.0.4
	gdb_s390-2001-09-26-branchpoint:1.8
	gdb_5_1-2001-07-29-branch:1.8.0.2
	gdb_5_1-2001-07-29-branchpoint:1.8
	binutils-2_11_2:1.3.2.1
	binutils-2_11_1:1.3.2.1
	binutils-2_11:1.3
	x86_64versiong3:1.3
	binutils-2_11-branch:1.3.0.2
	insight-precleanup-2001-01-01:1.2
	binutils-2_10_1:1.1.1.1.2.1
	binutils-2_10:1.1.1.1.2.1
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.17
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2007.10.04.13.43.16;	author nickc;	state Exp;
branches
	1.17.18.1
	1.17.28.1;
next	1.16;

1.16
date	2007.07.05.09.49.00;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.01.11.16.31;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.07.07.34.26;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.03.11.49.47;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.22.17.43.59;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.18.16.50.03;	author kdienes;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.02.06.00.05;	author amodra;	state Exp;
branches
	1.10.6.1
	1.10.8.1;
next	1.9;

1.9
date	2001.08.31.20.05.24;	author aj;	state Exp;
branches
	1.9.10.1;
next	1.8;

1.8
date	2001.06.22.08.55.05;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.23.03.25.03;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.23.03.12.14;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.12.15.14.53;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.13.22.58.34;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.11.21.20.19;	author nickc;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.04.14.04.16.58;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.59;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.17.18.1
date	2009.03.09.20.36.11;	author amylaar;	state Exp;
branches;
next	1.17.18.2;

1.17.18.2
date	2009.09.11.04.45.54;	author amylaar;	state Exp;
branches;
next	;

1.17.28.1
date	2009.09.10.15.09.45;	author amylaar;	state Exp;
branches;
next	;

1.10.6.1
date	2002.12.23.19.39.29;	author carlton;	state Exp;
branches;
next	;

1.10.8.1
date	2003.12.14.20.28.04;	author drow;	state Exp;
branches;
next	;

1.9.10.1
date	2002.10.01.00.46.44;	author kseitz;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.23.03.41.11;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.59;	author rth;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	2000.05.06.14.49.26;	author pb;	state Exp;
branches;
next	;


desc
@@


1.17
log
@PR gas/5100
* arc-opc.c (insert_offset): Fix spelling mistake in error message.
@
text
@/* Opcode table for the ARC.
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2004, 2005, 2007
   Free Software Foundation, Inc.
   Contributed by Doug Evans (dje@@cygnus.com).

   This file is part of libopcodes.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */

#include "sysdep.h"
#include <stdio.h>
#include "ansidecl.h"
#include "bfd.h"
#include "opcode/arc.h"
#include "opintl.h"

enum operand {OP_NONE,OP_REG,OP_SHIMM,OP_LIMM};

#define OPERANDS 3

enum operand ls_operand[OPERANDS];

struct arc_opcode *arc_ext_opcodes;
struct arc_ext_operand_value *arc_ext_operands;

#define LS_VALUE  0
#define LS_DEST   0
#define LS_BASE   1
#define LS_OFFSET 2

/* Given a format letter, yields the index into `arc_operands'.
   eg: arc_operand_map['a'] = REGA.  */
unsigned char arc_operand_map[256];

/* Nonzero if we've seen an 'f' suffix (in certain insns).  */
static int flag_p;

/* Nonzero if we've finished processing the 'f' suffix.  */
static int flagshimm_handled_p;

/* Nonzero if we've seen a 'a' suffix (address writeback).  */
static int addrwb_p;

/* Nonzero if we've seen a 'q' suffix (condition code).  */
static int cond_p;

/* Nonzero if we've inserted a nullify condition.  */
static int nullify_p;

/* The value of the a nullify condition we inserted.  */
static int nullify;

/* Nonzero if we've inserted jumpflags.  */
static int jumpflags_p;

/* Nonzero if we've inserted a shimm.  */
static int shimm_p;

/* The value of the shimm we inserted (each insn only gets one but it can
   appear multiple times).  */
static int shimm;

/* Nonzero if we've inserted a limm (during assembly) or seen a limm
   (during disassembly).  */
static int limm_p;

/* The value of the limm we inserted.  Each insn only gets one but it can
   appear multiple times.  */
static long limm;

#define INSERT_FN(fn) \
static arc_insn fn (arc_insn, const struct arc_operand *, \
		    int, const struct arc_operand_value *, long, \
		    const char **)

#define EXTRACT_FN(fn) \
static long fn (arc_insn *, const struct arc_operand *, \
		int, const struct arc_operand_value **, int *)

INSERT_FN (insert_reg);
INSERT_FN (insert_shimmfinish);
INSERT_FN (insert_limmfinish);
INSERT_FN (insert_offset);
INSERT_FN (insert_base);
INSERT_FN (insert_st_syntax);
INSERT_FN (insert_ld_syntax);
INSERT_FN (insert_addr_wb);
INSERT_FN (insert_flag);
INSERT_FN (insert_nullify);
INSERT_FN (insert_flagfinish);
INSERT_FN (insert_cond);
INSERT_FN (insert_forcelimm);
INSERT_FN (insert_reladdr);
INSERT_FN (insert_absaddr);
INSERT_FN (insert_jumpflags);
INSERT_FN (insert_unopmacro);

EXTRACT_FN (extract_reg);
EXTRACT_FN (extract_ld_offset);
EXTRACT_FN (extract_ld_syntax);
EXTRACT_FN (extract_st_offset);
EXTRACT_FN (extract_st_syntax);
EXTRACT_FN (extract_flag);
EXTRACT_FN (extract_cond);
EXTRACT_FN (extract_reladdr);
EXTRACT_FN (extract_jumpflags);
EXTRACT_FN (extract_unopmacro);

/* Various types of ARC operands, including insn suffixes.  */

/* Insn format values:

   'a'	REGA		register A field
   'b'	REGB		register B field
   'c'	REGC		register C field
   'S'	SHIMMFINISH	finish inserting a shimm value
   'L'	LIMMFINISH	finish inserting a limm value
   'o'	OFFSET		offset in st insns
   'O'	OFFSET		offset in ld insns
   '0'	SYNTAX_ST_NE	enforce store insn syntax, no errors
   '1'	SYNTAX_LD_NE	enforce load insn syntax, no errors
   '2'  SYNTAX_ST       enforce store insn syntax, errors, last pattern only
   '3'  SYNTAX_LD       enforce load insn syntax, errors, last pattern only
   's'  BASE            base in st insn
   'f'	FLAG		F flag
   'F'	FLAGFINISH	finish inserting the F flag
   'G'	FLAGINSN	insert F flag in "flag" insn
   'n'	DELAY		N field (nullify field)
   'q'	COND		condition code field
   'Q'	FORCELIMM	set `cond_p' to 1 to ensure a constant is a limm
   'B'	BRANCH		branch address (22 bit pc relative)
   'J'	JUMP		jump address (26 bit absolute)
   'j'  JUMPFLAGS       optional high order bits of 'J'
   'z'	SIZE1		size field in ld a,[b,c]
   'Z'	SIZE10		size field in ld a,[b,shimm]
   'y'	SIZE22		size field in st c,[b,shimm]
   'x'	SIGN0		sign extend field ld a,[b,c]
   'X'	SIGN9		sign extend field ld a,[b,shimm]
   'w'	ADDRESS3	write-back field in ld a,[b,c]
   'W'	ADDRESS12	write-back field in ld a,[b,shimm]
   'v'	ADDRESS24	write-back field in st c,[b,shimm]
   'e'	CACHEBYPASS5	cache bypass in ld a,[b,c]
   'E'	CACHEBYPASS14	cache bypass in ld a,[b,shimm]
   'D'	CACHEBYPASS26	cache bypass in st c,[b,shimm]
   'U'	UNOPMACRO	fake operand to copy REGB to REGC for unop macros

   The following modifiers may appear between the % and char (eg: %.f):

   '.'	MODDOT		'.' prefix must be present
   'r'	REG		generic register value, for register table
   'A'	AUXREG		auxiliary register in lr a,[b], sr c,[b]

   Fields are:

   CHAR BITS SHIFT FLAGS INSERT_FN EXTRACT_FN  */

const struct arc_operand arc_operands[] =
{
/* Place holder (??? not sure if needed).  */
#define UNUSED 0
  { 0, 0, 0, 0, 0, 0 },

/* Register A or shimm/limm indicator.  */
#define REGA (UNUSED + 1)
  { 'a', 6, ARC_SHIFT_REGA, ARC_OPERAND_SIGNED | ARC_OPERAND_ERROR, insert_reg, extract_reg },

/* Register B or shimm/limm indicator.  */
#define REGB (REGA + 1)
  { 'b', 6, ARC_SHIFT_REGB, ARC_OPERAND_SIGNED | ARC_OPERAND_ERROR, insert_reg, extract_reg },

/* Register C or shimm/limm indicator.  */
#define REGC (REGB + 1)
  { 'c', 6, ARC_SHIFT_REGC, ARC_OPERAND_SIGNED | ARC_OPERAND_ERROR, insert_reg, extract_reg },

/* Fake operand used to insert shimm value into most instructions.  */
#define SHIMMFINISH (REGC + 1)
  { 'S', 9, 0, ARC_OPERAND_SIGNED + ARC_OPERAND_FAKE, insert_shimmfinish, 0 },

/* Fake operand used to insert limm value into most instructions.  */
#define LIMMFINISH (SHIMMFINISH + 1)
  { 'L', 32, 32, ARC_OPERAND_ADDRESS + ARC_OPERAND_LIMM + ARC_OPERAND_FAKE, insert_limmfinish, 0 },

/* Shimm operand when there is no reg indicator (st).  */
#define ST_OFFSET (LIMMFINISH + 1)
  { 'o', 9, 0, ARC_OPERAND_LIMM | ARC_OPERAND_SIGNED | ARC_OPERAND_STORE, insert_offset, extract_st_offset },

/* Shimm operand when there is no reg indicator (ld).  */
#define LD_OFFSET (ST_OFFSET + 1)
  { 'O', 9, 0,ARC_OPERAND_LIMM | ARC_OPERAND_SIGNED | ARC_OPERAND_LOAD, insert_offset, extract_ld_offset },

/* Operand for base.  */
#define BASE (LD_OFFSET + 1)
  { 's', 6, ARC_SHIFT_REGB, ARC_OPERAND_LIMM | ARC_OPERAND_SIGNED, insert_base, extract_reg},

/* 0 enforce syntax for st insns.  */
#define SYNTAX_ST_NE (BASE + 1)
  { '0', 9, 0, ARC_OPERAND_FAKE, insert_st_syntax, extract_st_syntax },

/* 1 enforce syntax for ld insns.  */
#define SYNTAX_LD_NE (SYNTAX_ST_NE + 1)
  { '1', 9, 0, ARC_OPERAND_FAKE, insert_ld_syntax, extract_ld_syntax },

/* 0 enforce syntax for st insns.  */
#define SYNTAX_ST (SYNTAX_LD_NE + 1)
  { '2', 9, 0, ARC_OPERAND_FAKE | ARC_OPERAND_ERROR, insert_st_syntax, extract_st_syntax },

/* 0 enforce syntax for ld insns.  */
#define SYNTAX_LD (SYNTAX_ST + 1)
  { '3', 9, 0, ARC_OPERAND_FAKE | ARC_OPERAND_ERROR, insert_ld_syntax, extract_ld_syntax },

/* Flag update bit (insertion is defered until we know how).  */
#define FLAG (SYNTAX_LD + 1)
  { 'f', 1, 8, ARC_OPERAND_SUFFIX, insert_flag, extract_flag },

/* Fake utility operand to finish 'f' suffix handling.  */
#define FLAGFINISH (FLAG + 1)
  { 'F', 1, 8, ARC_OPERAND_FAKE, insert_flagfinish, 0 },

/* Fake utility operand to set the 'f' flag for the "flag" insn.  */
#define FLAGINSN (FLAGFINISH + 1)
  { 'G', 1, 8, ARC_OPERAND_FAKE, insert_flag, 0 },

/* Branch delay types.  */
#define DELAY (FLAGINSN + 1)
  { 'n', 2, 5, ARC_OPERAND_SUFFIX , insert_nullify, 0 },

/* Conditions.  */
#define COND (DELAY + 1)
  { 'q', 5, 0, ARC_OPERAND_SUFFIX, insert_cond, extract_cond },

/* Set `cond_p' to 1 to ensure a constant is treated as a limm.  */
#define FORCELIMM (COND + 1)
  { 'Q', 0, 0, ARC_OPERAND_FAKE, insert_forcelimm, 0 },

/* Branch address; b, bl, and lp insns.  */
#define BRANCH (FORCELIMM + 1)
  { 'B', 20, 7, (ARC_OPERAND_RELATIVE_BRANCH + ARC_OPERAND_SIGNED) | ARC_OPERAND_ERROR, insert_reladdr, extract_reladdr },

/* Jump address; j insn (this is basically the same as 'L' except that the
   value is right shifted by 2).  */
#define JUMP (BRANCH + 1)
  { 'J', 24, 32, ARC_OPERAND_ERROR | (ARC_OPERAND_ABSOLUTE_BRANCH + ARC_OPERAND_LIMM + ARC_OPERAND_FAKE), insert_absaddr, 0 },

/* Jump flags; j{,l} insn value or'ed into 'J' addr for flag values.  */
#define JUMPFLAGS (JUMP + 1)
  { 'j', 6, 26, ARC_OPERAND_JUMPFLAGS | ARC_OPERAND_ERROR, insert_jumpflags, extract_jumpflags },

/* Size field, stored in bit 1,2.  */
#define SIZE1 (JUMPFLAGS + 1)
  { 'z', 2, 1, ARC_OPERAND_SUFFIX, 0, 0 },

/* Size field, stored in bit 10,11.  */
#define SIZE10 (SIZE1 + 1)
  { 'Z', 2, 10, ARC_OPERAND_SUFFIX, 0, 0 },

/* Size field, stored in bit 22,23.  */
#define SIZE22 (SIZE10 + 1)
  { 'y', 2, 22, ARC_OPERAND_SUFFIX, 0, 0 },

/* Sign extend field, stored in bit 0.  */
#define SIGN0 (SIZE22 + 1)
  { 'x', 1, 0, ARC_OPERAND_SUFFIX, 0, 0 },

/* Sign extend field, stored in bit 9.  */
#define SIGN9 (SIGN0 + 1)
  { 'X', 1, 9, ARC_OPERAND_SUFFIX, 0, 0 },

/* Address write back, stored in bit 3.  */
#define ADDRESS3 (SIGN9 + 1)
  { 'w', 1, 3, ARC_OPERAND_SUFFIX, insert_addr_wb, 0},

/* Address write back, stored in bit 12.  */
#define ADDRESS12 (ADDRESS3 + 1)
  { 'W', 1, 12, ARC_OPERAND_SUFFIX, insert_addr_wb, 0},

/* Address write back, stored in bit 24.  */
#define ADDRESS24 (ADDRESS12 + 1)
  { 'v', 1, 24, ARC_OPERAND_SUFFIX, insert_addr_wb, 0},

/* Cache bypass, stored in bit 5.  */
#define CACHEBYPASS5 (ADDRESS24 + 1)
  { 'e', 1, 5, ARC_OPERAND_SUFFIX, 0, 0 },

/* Cache bypass, stored in bit 14.  */
#define CACHEBYPASS14 (CACHEBYPASS5 + 1)
  { 'E', 1, 14, ARC_OPERAND_SUFFIX, 0, 0 },

/* Cache bypass, stored in bit 26.  */
#define CACHEBYPASS26 (CACHEBYPASS14 + 1)
  { 'D', 1, 26, ARC_OPERAND_SUFFIX, 0, 0 },

/* Unop macro, used to copy REGB to REGC.  */
#define UNOPMACRO (CACHEBYPASS26 + 1)
  { 'U', 6, ARC_SHIFT_REGC, ARC_OPERAND_FAKE, insert_unopmacro, extract_unopmacro },

/* '.' modifier ('.' required).  */
#define MODDOT (UNOPMACRO + 1)
  { '.', 1, 0, ARC_MOD_DOT, 0, 0 },

/* Dummy 'r' modifier for the register table.
   It's called a "dummy" because there's no point in inserting an 'r' into all
   the %a/%b/%c occurrences in the insn table.  */
#define REG (MODDOT + 1)
  { 'r', 6, 0, ARC_MOD_REG, 0, 0 },

/* Known auxiliary register modifier (stored in shimm field).  */
#define AUXREG (REG + 1)
  { 'A', 9, 0, ARC_MOD_AUXREG, 0, 0 },

/* End of list place holder.  */
  { 0, 0, 0, 0, 0, 0 }
};

/* Insert a value into a register field.
   If REG is NULL, then this is actually a constant.

   We must also handle auxiliary registers for lr/sr insns.  */

static arc_insn
insert_reg (arc_insn insn,
	    const struct arc_operand *operand,
	    int mods,
	    const struct arc_operand_value *reg,
	    long value,
	    const char **errmsg)
{
  static char buf[100];
  enum operand op_type = OP_NONE;

  if (reg == NULL)
    {
      /* We have a constant that also requires a value stored in a register
	 field.  Handle these by updating the register field and saving the
	 value for later handling by either %S (shimm) or %L (limm).  */

      /* Try to use a shimm value before a limm one.  */
      if (ARC_SHIMM_CONST_P (value)
	  /* If we've seen a conditional suffix we have to use a limm.  */
	  && !cond_p
	  /* If we already have a shimm value that is different than ours
	     we have to use a limm.  */
	  && (!shimm_p || shimm == value))
	{
	  int marker;

	  op_type = OP_SHIMM;
	  /* Forget about shimm as dest mlm.  */

	  if ('a' != operand->fmt)
	    {
	      shimm_p = 1;
	      shimm = value;
	      flagshimm_handled_p = 1;
	      marker = flag_p ? ARC_REG_SHIMM_UPDATE : ARC_REG_SHIMM;
	    }
	  else
	    {
	      /* Don't request flag setting on shimm as dest.  */
	      marker = ARC_REG_SHIMM;
	    }
	  insn |= marker << operand->shift;
	  /* insn |= value & 511; - done later.  */
	}
      /* We have to use a limm.  If we've already seen one they must match.  */
      else if (!limm_p || limm == value)
	{
	  op_type = OP_LIMM;
	  limm_p = 1;
	  limm = value;
	  insn |= ARC_REG_LIMM << operand->shift;
	  /* The constant is stored later.  */
	}
      else
	*errmsg = _("unable to fit different valued constants into instruction");
    }
  else
    {
      /* We have to handle both normal and auxiliary registers.  */

      if (reg->type == AUXREG)
	{
	  if (!(mods & ARC_MOD_AUXREG))
	    *errmsg = _("auxiliary register not allowed here");
	  else
	    {
	      if ((insn & I(-1)) == I(2)) /* Check for use validity.  */
		{
		  if (reg->flags & ARC_REGISTER_READONLY)
		    *errmsg = _("attempt to set readonly register");
		}
	      else
		{
		  if (reg->flags & ARC_REGISTER_WRITEONLY)
		    *errmsg = _("attempt to read writeonly register");
		}
	      insn |= ARC_REG_SHIMM << operand->shift;
	      insn |= reg->value << arc_operands[reg->type].shift;
	    }
	}
      else
	{
	  /* check for use validity.  */
	  if ('a' == operand->fmt || ((insn & I(-1)) < I(2)))
	    {
	      if (reg->flags & ARC_REGISTER_READONLY)
		*errmsg = _("attempt to set readonly register");
	    }
	  if ('a' != operand->fmt)
	    {
	      if (reg->flags & ARC_REGISTER_WRITEONLY)
		*errmsg = _("attempt to read writeonly register");
	    }
	  /* We should never get an invalid register number here.  */
	  if ((unsigned int) reg->value > 60)
	    {
	      sprintf (buf, _("invalid register number `%d'"), reg->value);
	      *errmsg = buf;
	    }
	  insn |= reg->value << operand->shift;
	  op_type = OP_REG;
	}
    }

  switch (operand->fmt)
    {
    case 'a':
      ls_operand[LS_DEST] = op_type;
      break;
    case 's':
      ls_operand[LS_BASE] = op_type;
      break;
    case 'c':
      if ((insn & I(-1)) == I(2))
	ls_operand[LS_VALUE] = op_type;
      else
	ls_operand[LS_OFFSET] = op_type;
      break;
    case 'o': case 'O':
      ls_operand[LS_OFFSET] = op_type;
      break;
    }

  return insn;
}

/* Called when we see an 'f' flag.  */

static arc_insn
insert_flag (arc_insn insn,
	     const struct arc_operand *operand ATTRIBUTE_UNUSED,
	     int mods ATTRIBUTE_UNUSED,
	     const struct arc_operand_value *reg ATTRIBUTE_UNUSED,
	     long value ATTRIBUTE_UNUSED,
	     const char **errmsg ATTRIBUTE_UNUSED)
{
  /* We can't store anything in the insn until we've parsed the registers.
     Just record the fact that we've got this flag.  `insert_reg' will use it
     to store the correct value (ARC_REG_SHIMM_UPDATE or bit 0x100).  */
  flag_p = 1;
  return insn;
}

/* Called when we see an nullify condition.  */

static arc_insn
insert_nullify (arc_insn insn,
		const struct arc_operand *operand,
		int mods ATTRIBUTE_UNUSED,
		const struct arc_operand_value *reg ATTRIBUTE_UNUSED,
		long value,
		const char **errmsg ATTRIBUTE_UNUSED)
{
  nullify_p = 1;
  insn |= (value & ((1 << operand->bits) - 1)) << operand->shift;
  nullify = value;
  return insn;
}

/* Called after completely building an insn to ensure the 'f' flag gets set
   properly.  This is needed because we don't know how to set this flag until
   we've parsed the registers.  */

static arc_insn
insert_flagfinish (arc_insn insn,
		   const struct arc_operand *operand,
		   int mods ATTRIBUTE_UNUSED,
		   const struct arc_operand_value *reg ATTRIBUTE_UNUSED,
		   long value ATTRIBUTE_UNUSED,
		   const char **errmsg ATTRIBUTE_UNUSED)
{
  if (flag_p && !flagshimm_handled_p)
    {
      if (shimm_p)
	abort ();
      flagshimm_handled_p = 1;
      insn |= (1 << operand->shift);
    }
  return insn;
}

/* Called when we see a conditional flag (eg: .eq).  */

static arc_insn
insert_cond (arc_insn insn,
	     const struct arc_operand *operand,
	     int mods ATTRIBUTE_UNUSED,
	     const struct arc_operand_value *reg ATTRIBUTE_UNUSED,
	     long value,
	     const char **errmsg ATTRIBUTE_UNUSED)
{
  cond_p = 1;
  insn |= (value & ((1 << operand->bits) - 1)) << operand->shift;
  return insn;
}

/* Used in the "j" instruction to prevent constants from being interpreted as
   shimm values (which the jump insn doesn't accept).  This can also be used
   to force the use of limm values in other situations (eg: ld r0,[foo] uses
   this).
   ??? The mechanism is sound.  Access to it is a bit klunky right now.  */

static arc_insn
insert_forcelimm (arc_insn insn,
		  const struct arc_operand *operand ATTRIBUTE_UNUSED,
		  int mods ATTRIBUTE_UNUSED,
		  const struct arc_operand_value *reg ATTRIBUTE_UNUSED,
		  long value ATTRIBUTE_UNUSED,
		  const char **errmsg ATTRIBUTE_UNUSED)
{
  cond_p = 1;
  return insn;
}

static arc_insn
insert_addr_wb (arc_insn insn,
		const struct arc_operand *operand,
		int mods ATTRIBUTE_UNUSED,
		const struct arc_operand_value *reg ATTRIBUTE_UNUSED,
		long value ATTRIBUTE_UNUSED,
		const char **errmsg ATTRIBUTE_UNUSED)
{
  addrwb_p = 1 << operand->shift;
  return insn;
}

static arc_insn
insert_base (arc_insn insn,
	     const struct arc_operand *operand,
	     int mods,
	     const struct arc_operand_value *reg,
	     long value,
	     const char **errmsg)
{
  if (reg != NULL)
    {
      arc_insn myinsn;
      myinsn = insert_reg (0, operand,mods, reg, value, errmsg) >> operand->shift;
      insn |= B(myinsn);
      ls_operand[LS_BASE] = OP_REG;
    }
  else if (ARC_SHIMM_CONST_P (value) && !cond_p)
    {
      if (shimm_p && value != shimm)
	{
	  /* Convert the previous shimm operand to a limm.  */
	  limm_p = 1;
	  limm = shimm;
	  insn &= ~C(-1); /* We know where the value is in insn.  */
	  insn |= C(ARC_REG_LIMM);
	  ls_operand[LS_VALUE] = OP_LIMM;
	}
      insn |= ARC_REG_SHIMM << operand->shift;
      shimm_p = 1;
      shimm = value;
      ls_operand[LS_BASE] = OP_SHIMM;
      ls_operand[LS_OFFSET] = OP_SHIMM;
    }
  else
    {
      if (limm_p && value != limm)
	{
	  *errmsg = _("too many long constants");
	  return insn;
	}
      limm_p = 1;
      limm = value;
      insn |= B(ARC_REG_LIMM);
      ls_operand[LS_BASE] = OP_LIMM;
    }

  return insn;
}

/* Used in ld/st insns to handle the offset field. We don't try to
   match operand syntax here. we catch bad combinations later.  */

static arc_insn
insert_offset (arc_insn insn,
	       const struct arc_operand *operand,
	       int mods,
	       const struct arc_operand_value *reg,
	       long value,
	       const char **errmsg)
{
  long minval, maxval;

  if (reg != NULL)
    {
      arc_insn myinsn;
      myinsn = insert_reg (0,operand,mods,reg,value,errmsg) >> operand->shift;
      ls_operand[LS_OFFSET] = OP_REG;
      if (operand->flags & ARC_OPERAND_LOAD) /* Not if store, catch it later.  */
	if ((insn & I(-1)) != I(1)) /* Not if opcode == 1, catch it later.  */
	  insn |= C (myinsn);
    }
  else
    {
      /* This is *way* more general than necessary, but maybe some day it'll
	 be useful.  */
      if (operand->flags & ARC_OPERAND_SIGNED)
	{
	  minval = -(1 << (operand->bits - 1));
	  maxval = (1 << (operand->bits - 1)) - 1;
	}
      else
	{
	  minval = 0;
	  maxval = (1 << operand->bits) - 1;
	}
      if ((cond_p && !limm_p) || (value < minval || value > maxval))
	{
	  if (limm_p && value != limm)
	    *errmsg = _("too many long constants");

	  else
	    {
	      limm_p = 1;
	      limm = value;
	      if (operand->flags & ARC_OPERAND_STORE)
		insn |= B(ARC_REG_LIMM);
	      if (operand->flags & ARC_OPERAND_LOAD)
		insn |= C(ARC_REG_LIMM);
	      ls_operand[LS_OFFSET] = OP_LIMM;
	    }
	}
      else
	{
	  if ((value < minval || value > maxval))
	    *errmsg = "need too many limms";
	  else if (shimm_p && value != shimm)
	    {
	      /* Check for bad operand combinations
		 before we lose info about them.  */
	      if ((insn & I(-1)) == I(1))
		{
		  *errmsg = _("too many shimms in load");
		  goto out;
		}
	      if (limm_p && operand->flags & ARC_OPERAND_LOAD)
		{
		  *errmsg = _("too many long constants");
		  goto out;
		}
	      /* Convert what we thought was a shimm to a limm.  */
	      limm_p = 1;
	      limm = shimm;
	      if (ls_operand[LS_VALUE] == OP_SHIMM
		  && operand->flags & ARC_OPERAND_STORE)
		{
		  insn &= ~C(-1);
		  insn |= C(ARC_REG_LIMM);
		  ls_operand[LS_VALUE] = OP_LIMM;
		}
	      if (ls_operand[LS_BASE] == OP_SHIMM
		  && operand->flags & ARC_OPERAND_STORE)
		{
		  insn &= ~B(-1);
		  insn |= B(ARC_REG_LIMM);
		  ls_operand[LS_BASE] = OP_LIMM;
		}
	    }
	  shimm = value;
	  shimm_p = 1;
	  ls_operand[LS_OFFSET] = OP_SHIMM;
	}
    }
 out:
  return insn;
}

/* Used in st insns to do final disasemble syntax check.  */

static long
extract_st_syntax (arc_insn *insn,
		   const struct arc_operand *operand ATTRIBUTE_UNUSED,
		   int mods ATTRIBUTE_UNUSED,
		   const struct arc_operand_value **opval ATTRIBUTE_UNUSED,
		   int *invalid)
{
#define ST_SYNTAX(V,B,O) \
((ls_operand[LS_VALUE]  == (V) && \
  ls_operand[LS_BASE]   == (B) && \
  ls_operand[LS_OFFSET] == (O)))

  if (!((ST_SYNTAX(OP_REG,OP_REG,OP_NONE) && (insn[0] & 511) == 0)
	|| ST_SYNTAX(OP_REG,OP_LIMM,OP_NONE)
	|| (ST_SYNTAX(OP_SHIMM,OP_REG,OP_NONE) && (insn[0] & 511) == 0)
	|| (ST_SYNTAX(OP_SHIMM,OP_SHIMM,OP_NONE) && (insn[0] & 511) == 0)
	|| ST_SYNTAX(OP_SHIMM,OP_LIMM,OP_NONE)
	|| ST_SYNTAX(OP_SHIMM,OP_LIMM,OP_SHIMM)
	|| ST_SYNTAX(OP_SHIMM,OP_SHIMM,OP_SHIMM)
	|| (ST_SYNTAX(OP_LIMM,OP_REG,OP_NONE) && (insn[0] & 511) == 0)
	|| ST_SYNTAX(OP_REG,OP_REG,OP_SHIMM)
	|| ST_SYNTAX(OP_REG,OP_SHIMM,OP_SHIMM)
	|| ST_SYNTAX(OP_SHIMM,OP_REG,OP_SHIMM)
	|| ST_SYNTAX(OP_LIMM,OP_SHIMM,OP_SHIMM)
	|| ST_SYNTAX(OP_LIMM,OP_SHIMM,OP_NONE)
	|| ST_SYNTAX(OP_LIMM,OP_REG,OP_SHIMM)))
    *invalid = 1;
  return 0;
}

int
arc_limm_fixup_adjust (arc_insn insn)
{
  int retval = 0;

  /* Check for st shimm,[limm].  */
  if ((insn & (I(-1) | C(-1) | B(-1))) ==
      (I(2) | C(ARC_REG_SHIMM) | B(ARC_REG_LIMM)))
    {
      retval = insn & 0x1ff;
      if (retval & 0x100) /* Sign extend 9 bit offset.  */
	retval |= ~0x1ff;
    }
  return -retval; /* Negate offset for return.  */
}

/* Used in st insns to do final syntax check.  */

static arc_insn
insert_st_syntax (arc_insn insn,
		  const struct arc_operand *operand ATTRIBUTE_UNUSED,
		  int mods ATTRIBUTE_UNUSED,
		  const struct arc_operand_value *reg ATTRIBUTE_UNUSED,
		  long value ATTRIBUTE_UNUSED,
		  const char **errmsg)
{
  if (ST_SYNTAX (OP_SHIMM,OP_REG,OP_NONE) && shimm != 0)
    {
      /* Change an illegal insn into a legal one, it's easier to
	 do it here than to try to handle it during operand scan.  */
      limm_p = 1;
      limm = shimm;
      shimm_p = 0;
      shimm = 0;
      insn = insn & ~(C(-1) | 511);
      insn |= ARC_REG_LIMM << ARC_SHIFT_REGC;
      ls_operand[LS_VALUE] = OP_LIMM;
    }

  if (ST_SYNTAX (OP_REG, OP_SHIMM, OP_NONE)
      || ST_SYNTAX (OP_LIMM, OP_SHIMM, OP_NONE))
    {
      /* Try to salvage this syntax.  */
      if (shimm & 0x1) /* Odd shimms won't work.  */
	{
	  if (limm_p) /* Do we have a limm already?  */
	    *errmsg = _("impossible store");

	  limm_p = 1;
	  limm = shimm;
	  shimm = 0;
	  shimm_p = 0;
	  insn = insn & ~(B(-1) | 511);
	  insn |= B(ARC_REG_LIMM);
	  ls_operand[LS_BASE] = OP_LIMM;
	}
      else
	{
	  shimm >>= 1;
	  insn = insn & ~511;
	  insn |= shimm;
	  ls_operand[LS_OFFSET] = OP_SHIMM;
	}
    }
  if (ST_SYNTAX(OP_SHIMM,OP_LIMM,OP_NONE))
    limm += arc_limm_fixup_adjust(insn);

  if (!   (ST_SYNTAX (OP_REG,OP_REG,OP_NONE)
	|| ST_SYNTAX (OP_REG,OP_LIMM,OP_NONE)
	|| ST_SYNTAX (OP_REG,OP_REG,OP_SHIMM)
	|| ST_SYNTAX (OP_REG,OP_SHIMM,OP_SHIMM)
	|| (ST_SYNTAX (OP_SHIMM,OP_SHIMM,OP_NONE) && (shimm == 0))
	|| ST_SYNTAX (OP_SHIMM,OP_LIMM,OP_NONE)
	|| ST_SYNTAX (OP_SHIMM,OP_REG,OP_NONE)
	|| ST_SYNTAX (OP_SHIMM,OP_REG,OP_SHIMM)
	|| ST_SYNTAX (OP_SHIMM,OP_SHIMM,OP_SHIMM)
	|| ST_SYNTAX (OP_LIMM,OP_SHIMM,OP_SHIMM)
	|| ST_SYNTAX (OP_LIMM,OP_REG,OP_NONE)
	|| ST_SYNTAX (OP_LIMM,OP_REG,OP_SHIMM)))
    *errmsg = _("st operand error");
  if (addrwb_p)
    {
      if (ls_operand[LS_BASE] != OP_REG)
	*errmsg = _("address writeback not allowed");
      insn |= addrwb_p;
    }
  if (ST_SYNTAX(OP_SHIMM,OP_REG,OP_NONE) && shimm)
    *errmsg = _("store value must be zero");
  return insn;
}

/* Used in ld insns to do final syntax check.  */

static arc_insn
insert_ld_syntax (arc_insn insn,
		  const struct arc_operand *operand ATTRIBUTE_UNUSED,
		  int mods ATTRIBUTE_UNUSED,
		  const struct arc_operand_value *reg ATTRIBUTE_UNUSED,
		  long value ATTRIBUTE_UNUSED,
		  const char **errmsg)
{
#define LD_SYNTAX(D, B, O) \
  (   (ls_operand[LS_DEST]   == (D) \
    && ls_operand[LS_BASE]   == (B) \
    && ls_operand[LS_OFFSET] == (O)))

  int test = insn & I (-1);

  if (!(test == I (1)))
    {
      if ((ls_operand[LS_DEST] == OP_SHIMM || ls_operand[LS_BASE] == OP_SHIMM
	   || ls_operand[LS_OFFSET] == OP_SHIMM))
	*errmsg = _("invalid load/shimm insn");
    }
  if (!(LD_SYNTAX(OP_REG,OP_REG,OP_NONE)
	|| LD_SYNTAX(OP_REG,OP_REG,OP_REG)
	|| LD_SYNTAX(OP_REG,OP_REG,OP_SHIMM)
	|| (LD_SYNTAX(OP_REG,OP_LIMM,OP_REG) && !(test == I(1)))
	|| (LD_SYNTAX(OP_REG,OP_REG,OP_LIMM) && !(test == I(1)))
	|| LD_SYNTAX(OP_REG,OP_SHIMM,OP_SHIMM)
	|| (LD_SYNTAX(OP_REG,OP_LIMM,OP_NONE) && (test == I(1)))))
    *errmsg = _("ld operand error");
  if (addrwb_p)
    {
      if (ls_operand[LS_BASE] != OP_REG)
	*errmsg = _("address writeback not allowed");
      insn |= addrwb_p;
    }
  return insn;
}

/* Used in ld insns to do final syntax check.  */

static long
extract_ld_syntax (arc_insn *insn,
		   const struct arc_operand *operand ATTRIBUTE_UNUSED,
		   int mods ATTRIBUTE_UNUSED,
		   const struct arc_operand_value **opval ATTRIBUTE_UNUSED,
		   int *invalid)
{
  int test = insn[0] & I(-1);

  if (!(test == I(1)))
    {
      if ((ls_operand[LS_DEST] == OP_SHIMM || ls_operand[LS_BASE] == OP_SHIMM
	   || ls_operand[LS_OFFSET] == OP_SHIMM))
	*invalid = 1;
    }
  if (!(   (LD_SYNTAX (OP_REG, OP_REG, OP_NONE) && (test == I(1)))
	||  LD_SYNTAX (OP_REG, OP_REG, OP_REG)
	||  LD_SYNTAX (OP_REG, OP_REG, OP_SHIMM)
	|| (LD_SYNTAX (OP_REG, OP_REG, OP_LIMM) && !(test == I(1)))
	|| (LD_SYNTAX (OP_REG, OP_LIMM, OP_REG) && !(test == I(1)))
	|| (LD_SYNTAX (OP_REG, OP_SHIMM, OP_NONE) && (shimm == 0))
	||  LD_SYNTAX (OP_REG, OP_SHIMM, OP_SHIMM)
	|| (LD_SYNTAX (OP_REG, OP_LIMM, OP_NONE) && (test == I(1)))))
    *invalid = 1;
  return 0;
}

/* Called at the end of processing normal insns (eg: add) to insert a shimm
   value (if present) into the insn.  */

static arc_insn
insert_shimmfinish (arc_insn insn,
		    const struct arc_operand *operand,
		    int mods ATTRIBUTE_UNUSED,
		    const struct arc_operand_value *reg ATTRIBUTE_UNUSED,
		    long value ATTRIBUTE_UNUSED,
		    const char **errmsg ATTRIBUTE_UNUSED)
{
  if (shimm_p)
    insn |= (shimm & ((1 << operand->bits) - 1)) << operand->shift;
  return insn;
}

/* Called at the end of processing normal insns (eg: add) to insert a limm
   value (if present) into the insn.

   Note that this function is only intended to handle instructions (with 4 byte
   immediate operands).  It is not intended to handle data.  */

/* ??? Actually, there's nothing for us to do as we can't call frag_more, the
   caller must do that.  The extract fns take a pointer to two words.  The
   insert fns could be converted and then we could do something useful, but
   then the reloc handlers would have to know to work on the second word of
   a 2 word quantity.  That's too much so we don't handle them.  */

static arc_insn
insert_limmfinish (arc_insn insn,
		   const struct arc_operand *operand ATTRIBUTE_UNUSED,
		   int mods ATTRIBUTE_UNUSED,
		   const struct arc_operand_value *reg ATTRIBUTE_UNUSED,
		   long value ATTRIBUTE_UNUSED,
		   const char **errmsg ATTRIBUTE_UNUSED)
{
  return insn;
}

static arc_insn
insert_jumpflags (arc_insn insn,
		  const struct arc_operand *operand,
		  int mods ATTRIBUTE_UNUSED,
		  const struct arc_operand_value *reg ATTRIBUTE_UNUSED,
		  long value,
		  const char **errmsg)
{
  if (!flag_p)
    *errmsg = _("jump flags, but no .f seen");

  else if (!limm_p)
    *errmsg = _("jump flags, but no limm addr");

  else if (limm & 0xfc000000)
    *errmsg = _("flag bits of jump address limm lost");

  else if (limm & 0x03000000)
    *errmsg = _("attempt to set HR bits");

  else if ((value & ((1 << operand->bits) - 1)) != value)
    *errmsg = _("bad jump flags value");

  jumpflags_p = 1;
  limm = ((limm & ((1 << operand->shift) - 1))
	  | ((value & ((1 << operand->bits) - 1)) << operand->shift));
  return insn;
}

/* Called at the end of unary operand macros to copy the B field to C.  */

static arc_insn
insert_unopmacro (arc_insn insn,
		  const struct arc_operand *operand,
		  int mods ATTRIBUTE_UNUSED,
		  const struct arc_operand_value *reg ATTRIBUTE_UNUSED,
		  long value ATTRIBUTE_UNUSED,
		  const char **errmsg ATTRIBUTE_UNUSED)
{
  insn |= ((insn >> ARC_SHIFT_REGB) & ARC_MASK_REG) << operand->shift;
  return insn;
}

/* Insert a relative address for a branch insn (b, bl, or lp).  */

static arc_insn
insert_reladdr (arc_insn insn,
		const struct arc_operand *operand,
		int mods ATTRIBUTE_UNUSED,
		const struct arc_operand_value *reg ATTRIBUTE_UNUSED,
		long value,
		const char **errmsg)
{
  if (value & 3)
    *errmsg = _("branch address not on 4 byte boundary");
  insn |= ((value >> 2) & ((1 << operand->bits) - 1)) << operand->shift;
  return insn;
}

/* Insert a limm value as a 26 bit address right shifted 2 into the insn.

   Note that this function is only intended to handle instructions (with 4 byte
   immediate operands).  It is not intended to handle data.  */

/* ??? Actually, there's little for us to do as we can't call frag_more, the
   caller must do that.  The extract fns take a pointer to two words.  The
   insert fns could be converted and then we could do something useful, but
   then the reloc handlers would have to know to work on the second word of
   a 2 word quantity.  That's too much so we don't handle them.

   We do check for correct usage of the nullify suffix, or we
   set the default correctly, though.  */

static arc_insn
insert_absaddr (arc_insn insn,
		const struct arc_operand *operand ATTRIBUTE_UNUSED,
		int mods ATTRIBUTE_UNUSED,
		const struct arc_operand_value *reg ATTRIBUTE_UNUSED,
		long value ATTRIBUTE_UNUSED,
		const char **errmsg)
{
  if (limm_p)
    {
      /* If it is a jump and link, .jd must be specified.  */
      if (insn & R (-1, 9, 1))
	{
	  if (!nullify_p)
	    insn |=  0x02 << 5;  /* Default nullify to .jd.  */

	  else if (nullify != 0x02)
	    *errmsg = _("must specify .jd or no nullify suffix");
	}
    }
  return insn;
}

/* Extraction functions.

   The suffix extraction functions' return value is redundant since it can be
   obtained from (*OPVAL)->value.  However, the boolean suffixes don't have
   a suffix table entry for the "false" case, so values of zero must be
   obtained from the return value (*OPVAL == NULL).  */

/* Called by the disassembler before printing an instruction.  */

void
arc_opcode_init_extract (void)
{
  arc_opcode_init_insert ();
}

static const struct arc_operand_value *
lookup_register (int type, long regno)
{
  const struct arc_operand_value *r,*end;
  struct arc_ext_operand_value *ext_oper = arc_ext_operands;

  while (ext_oper)
    {
      if (ext_oper->operand.type == type && ext_oper->operand.value == regno)
	return (&ext_oper->operand);
      ext_oper = ext_oper->next;
    }

  if (type == REG)
    return &arc_reg_names[regno];

  /* ??? This is a little slow and can be speeded up.  */
  for (r = arc_reg_names, end = arc_reg_names + arc_reg_names_count;
       r < end; ++r)
    if (type == r->type	&& regno == r->value)
      return r;
  return 0;
}

/* As we're extracting registers, keep an eye out for the 'f' indicator
   (ARC_REG_SHIMM_UPDATE).  If we find a register (not a constant marker,
   like ARC_REG_SHIMM), set OPVAL so our caller will know this is a register.

   We must also handle auxiliary registers for lr/sr insns.  They are just
   constants with special names.  */

static long
extract_reg (arc_insn *insn,
	     const struct arc_operand *operand,
	     int mods,
	     const struct arc_operand_value **opval,
	     int *invalid ATTRIBUTE_UNUSED)
{
  int regno;
  long value;
  enum operand op_type;

  /* Get the register number.  */
  regno = (*insn >> operand->shift) & ((1 << operand->bits) - 1);

  /* Is it a constant marker?  */
  if (regno == ARC_REG_SHIMM)
    {
      op_type = OP_SHIMM;
      /* Always return zero if dest is a shimm  mlm.  */

      if ('a' != operand->fmt)
	{
	  value = *insn & 511;
	  if ((operand->flags & ARC_OPERAND_SIGNED)
	      && (value & 256))
	    value -= 512;
	  if (!flagshimm_handled_p)
	    flag_p = 0;
	  flagshimm_handled_p = 1;
	}
      else
	value = 0;
    }
  else if (regno == ARC_REG_SHIMM_UPDATE)
    {
      op_type = OP_SHIMM;

      /* Always return zero if dest is a shimm  mlm.  */
      if ('a' != operand->fmt)
	{
	  value = *insn & 511;
	  if ((operand->flags & ARC_OPERAND_SIGNED) && (value & 256))
	    value -= 512;
	}
      else
	value = 0;

      flag_p = 1;
      flagshimm_handled_p = 1;
    }
  else if (regno == ARC_REG_LIMM)
    {
      op_type = OP_LIMM;
      value = insn[1];
      limm_p = 1;

      /* If this is a jump instruction (j,jl), show new pc correctly.  */
      if (0x07 == ((*insn & I(-1)) >> 27))
	value = (value & 0xffffff);
    }

  /* It's a register, set OPVAL (that's the only way we distinguish registers
     from constants here).  */
  else
    {
      const struct arc_operand_value *reg = lookup_register (REG, regno);

      op_type = OP_REG;

      if (reg == NULL)
	abort ();
      if (opval != NULL)
	*opval = reg;
      value = regno;
    }

  /* If this field takes an auxiliary register, see if it's a known one.  */
  if ((mods & ARC_MOD_AUXREG)
      && ARC_REG_CONSTANT_P (regno))
    {
      const struct arc_operand_value *reg = lookup_register (AUXREG, value);

      /* This is really a constant, but tell the caller it has a special
	 name.  */
      if (reg != NULL && opval != NULL)
	*opval = reg;
    }

  switch(operand->fmt)
    {
    case 'a':
      ls_operand[LS_DEST] = op_type;
      break;
    case 's':
      ls_operand[LS_BASE] = op_type;
      break;
    case 'c':
      if ((insn[0]& I(-1)) == I(2))
	ls_operand[LS_VALUE] = op_type;
      else
	ls_operand[LS_OFFSET] = op_type;
      break;
    case 'o': case 'O':
      ls_operand[LS_OFFSET] = op_type;
      break;
    }

  return value;
}

/* Return the value of the "flag update" field for shimm insns.
   This value is actually stored in the register field.  */

static long
extract_flag (arc_insn *insn,
	      const struct arc_operand *operand,
	      int mods ATTRIBUTE_UNUSED,
	      const struct arc_operand_value **opval,
	      int *invalid ATTRIBUTE_UNUSED)
{
  int f;
  const struct arc_operand_value *val;

  if (flagshimm_handled_p)
    f = flag_p != 0;
  else
    f = (*insn & (1 << operand->shift)) != 0;

  /* There is no text for zero values.  */
  if (f == 0)
    return 0;
  flag_p = 1;
  val = arc_opcode_lookup_suffix (operand, 1);
  if (opval != NULL && val != NULL)
    *opval = val;
  return val->value;
}

/* Extract the condition code (if it exists).
   If we've seen a shimm value in this insn (meaning that the insn can't have
   a condition code field), then we don't store anything in OPVAL and return
   zero.  */

static long
extract_cond (arc_insn *insn,
	      const struct arc_operand *operand,
	      int mods ATTRIBUTE_UNUSED,
	      const struct arc_operand_value **opval,
	      int *invalid ATTRIBUTE_UNUSED)
{
  long cond;
  const struct arc_operand_value *val;

  if (flagshimm_handled_p)
    return 0;

  cond = (*insn >> operand->shift) & ((1 << operand->bits) - 1);
  val = arc_opcode_lookup_suffix (operand, cond);

  /* Ignore NULL values of `val'.  Several condition code values are
     reserved for extensions.  */
  if (opval != NULL && val != NULL)
    *opval = val;
  return cond;
}

/* Extract a branch address.
   We return the value as a real address (not right shifted by 2).  */

static long
extract_reladdr (arc_insn *insn,
		 const struct arc_operand *operand,
		 int mods ATTRIBUTE_UNUSED,
		 const struct arc_operand_value **opval ATTRIBUTE_UNUSED,
		 int *invalid ATTRIBUTE_UNUSED)
{
  long addr;

  addr = (*insn >> operand->shift) & ((1 << operand->bits) - 1);
  if ((operand->flags & ARC_OPERAND_SIGNED)
      && (addr & (1 << (operand->bits - 1))))
    addr -= 1 << operand->bits;
  return addr << 2;
}

/* Extract the flags bits from a j or jl long immediate.  */

static long
extract_jumpflags (arc_insn *insn,
		   const struct arc_operand *operand,
		   int mods ATTRIBUTE_UNUSED,
		   const struct arc_operand_value **opval ATTRIBUTE_UNUSED,
		   int *invalid)
{
  if (!flag_p || !limm_p)
    *invalid = 1;
  return ((flag_p && limm_p)
	  ? (insn[1] >> operand->shift) & ((1 << operand->bits) -1): 0);
}

/* Extract st insn's offset.  */

static long
extract_st_offset (arc_insn *insn,
		   const struct arc_operand *operand,
		   int mods ATTRIBUTE_UNUSED,
		   const struct arc_operand_value **opval ATTRIBUTE_UNUSED,
		   int *invalid)
{
  int value = 0;

  if (ls_operand[LS_VALUE] != OP_SHIMM || ls_operand[LS_BASE] != OP_LIMM)
    {
      value = insn[0] & 511;
      if ((operand->flags & ARC_OPERAND_SIGNED) && (value & 256))
	value -= 512;
      if (value)
	ls_operand[LS_OFFSET] = OP_SHIMM;
    }
  else
    *invalid = 1;

  return value;
}

/* Extract ld insn's offset.  */

static long
extract_ld_offset (arc_insn *insn,
		   const struct arc_operand *operand,
		   int mods,
		   const struct arc_operand_value **opval,
		   int *invalid)
{
  int test = insn[0] & I(-1);
  int value;

  if (test)
    {
      value = insn[0] & 511;
      if ((operand->flags & ARC_OPERAND_SIGNED) && (value & 256))
	value -= 512;
      if (value)
	ls_operand[LS_OFFSET] = OP_SHIMM;

      return value;
    }
  /* If it isn't in the insn, it's concealed behind reg 'c'.  */
  return extract_reg (insn, &arc_operands[arc_operand_map['c']],
		      mods, opval, invalid);
}

/* The only thing this does is set the `invalid' flag if B != C.
   This is needed because the "mov" macro appears before it's real insn "and"
   and we don't want the disassembler to confuse them.  */

static long
extract_unopmacro (arc_insn *insn,
		   const struct arc_operand *operand ATTRIBUTE_UNUSED,
		   int mods ATTRIBUTE_UNUSED,
		   const struct arc_operand_value **opval ATTRIBUTE_UNUSED,
		   int *invalid)
{
  /* This misses the case where B == ARC_REG_SHIMM_UPDATE &&
     C == ARC_REG_SHIMM (or vice versa).  No big deal.  Those insns will get
     printed as "and"s.  */
  if (((*insn >> ARC_SHIFT_REGB) & ARC_MASK_REG)
      != ((*insn >> ARC_SHIFT_REGC) & ARC_MASK_REG))
    if (invalid != NULL)
      *invalid = 1;
  return 0;
}

/* ARC instructions.

   Longer versions of insns must appear before shorter ones (if gas sees
   "lsr r2,r3,1" when it's parsing "lsr %a,%b" it will think the ",1" is
   junk).  This isn't necessary for `ld' because of the trailing ']'.

   Instructions that are really macros based on other insns must appear
   before the real insn so they're chosen when disassembling.  Eg: The `mov'
   insn is really the `and' insn.  */

struct arc_opcode arc_opcodes[] =
{
  /* Base case instruction set (core versions 5-8).  */

  /* "mov" is really an "and".  */
  { "mov%.q%.f %a,%b%F%S%L%U", I(-1), I(12), ARC_MACH_5, 0, 0 },
  /* "asl" is really an "add".  */
  { "asl%.q%.f %a,%b%F%S%L%U", I(-1), I(8), ARC_MACH_5, 0, 0 },
  /* "lsl" is really an "add".  */
  { "lsl%.q%.f %a,%b%F%S%L%U", I(-1), I(8), ARC_MACH_5, 0, 0 },
  /* "nop" is really an "xor".  */
  { "nop", 0x7fffffff, 0x7fffffff, ARC_MACH_5, 0, 0 },
  /* "rlc" is really an "adc".  */
  { "rlc%.q%.f %a,%b%F%S%L%U", I(-1), I(9), ARC_MACH_5, 0, 0 },
  { "adc%.q%.f %a,%b,%c%F%S%L", I(-1), I(9), ARC_MACH_5, 0, 0 },
  { "add%.q%.f %a,%b,%c%F%S%L", I(-1), I(8), ARC_MACH_5, 0, 0 },
  { "and%.q%.f %a,%b,%c%F%S%L", I(-1), I(12), ARC_MACH_5, 0, 0 },
  { "asr%.q%.f %a,%b%F%S%L", I(-1)|C(-1), I(3)|C(1), ARC_MACH_5, 0, 0 },
  { "bic%.q%.f %a,%b,%c%F%S%L",	I(-1), I(14), ARC_MACH_5, 0, 0 },
  { "b%q%.n %B", I(-1), I(4), ARC_MACH_5 | ARC_OPCODE_COND_BRANCH, 0, 0 },
  { "bl%q%.n %B", I(-1), I(5), ARC_MACH_5 | ARC_OPCODE_COND_BRANCH, 0, 0 },
  { "extb%.q%.f %a,%b%F%S%L", I(-1)|C(-1), I(3)|C(7), ARC_MACH_5, 0, 0 },
  { "extw%.q%.f %a,%b%F%S%L", I(-1)|C(-1), I(3)|C(8), ARC_MACH_5, 0, 0 },
  { "flag%.q %b%G%S%L", I(-1)|A(-1)|C(-1), I(3)|A(ARC_REG_SHIMM_UPDATE)|C(0), ARC_MACH_5, 0, 0 },
  { "brk", 0x1ffffe00, 0x1ffffe00, ARC_MACH_7, 0, 0 },
  { "sleep", 0x1ffffe01, 0x1ffffe01, ARC_MACH_7, 0, 0 },
  { "swi", 0x1ffffe02, 0x1ffffe02, ARC_MACH_8, 0, 0 },
  /* %Q: force cond_p=1 -> no shimm values. This insn allows an
     optional flags spec.  */
  { "j%q%Q%.n%.f %b%F%J,%j", I(-1)|A(-1)|C(-1)|R(-1,7,1), I(7)|A(0)|C(0)|R(0,7,1), ARC_MACH_5 | ARC_OPCODE_COND_BRANCH, 0, 0 },
  { "j%q%Q%.n%.f %b%F%J", I(-1)|A(-1)|C(-1)|R(-1,7,1), I(7)|A(0)|C(0)|R(0,7,1), ARC_MACH_5 | ARC_OPCODE_COND_BRANCH, 0, 0 },
  /* This insn allows an optional flags spec.  */
  { "jl%q%Q%.n%.f %b%F%J,%j", I(-1)|A(-1)|C(-1)|R(-1,7,1)|R(-1,9,1), I(7)|A(0)|C(0)|R(0,7,1)|R(1,9,1), ARC_MACH_6 | ARC_OPCODE_COND_BRANCH, 0, 0 },
  { "jl%q%Q%.n%.f %b%F%J", I(-1)|A(-1)|C(-1)|R(-1,7,1)|R(-1,9,1), I(7)|A(0)|C(0)|R(0,7,1)|R(1,9,1), ARC_MACH_6 | ARC_OPCODE_COND_BRANCH, 0, 0 },
  /* Put opcode 1 ld insns first so shimm gets prefered over limm.
     "[%b]" is before "[%b,%o]" so 0 offsets don't get printed.  */
  { "ld%Z%.X%.W%.E %a,[%s]%S%L%1", I(-1)|R(-1,13,1)|R(-1,0,511), I(1)|R(0,13,1)|R(0,0,511), ARC_MACH_5, 0, 0 },
  { "ld%z%.x%.w%.e %a,[%s]%S%L%1", I(-1)|R(-1,4,1)|R(-1,6,7), I(0)|R(0,4,1)|R(0,6,7), ARC_MACH_5, 0, 0 },
  { "ld%z%.x%.w%.e %a,[%s,%O]%S%L%1", I(-1)|R(-1,4,1)|R(-1,6,7), I(0)|R(0,4,1)|R(0,6,7), ARC_MACH_5, 0, 0 },
  { "ld%Z%.X%.W%.E %a,[%s,%O]%S%L%3", I(-1)|R(-1,13,1),	I(1)|R(0,13,1), ARC_MACH_5, 0, 0 },
  { "lp%q%.n %B", I(-1), I(6), ARC_MACH_5, 0, 0 },
  { "lr %a,[%Ab]%S%L", I(-1)|C(-1), I(1)|C(0x10), ARC_MACH_5, 0, 0 },
  { "lsr%.q%.f %a,%b%F%S%L", I(-1)|C(-1), I(3)|C(2), ARC_MACH_5, 0, 0 },
  { "or%.q%.f %a,%b,%c%F%S%L", I(-1), I(13), ARC_MACH_5, 0, 0 },
  { "ror%.q%.f %a,%b%F%S%L", I(-1)|C(-1), I(3)|C(3), ARC_MACH_5, 0, 0 },
  { "rrc%.q%.f %a,%b%F%S%L", I(-1)|C(-1), I(3)|C(4), ARC_MACH_5, 0, 0 },
  { "sbc%.q%.f %a,%b,%c%F%S%L",	I(-1), I(11), ARC_MACH_5, 0, 0 },
  { "sexb%.q%.f %a,%b%F%S%L", I(-1)|C(-1), I(3)|C(5), ARC_MACH_5, 0, 0 },
  { "sexw%.q%.f %a,%b%F%S%L", I(-1)|C(-1), I(3)|C(6), ARC_MACH_5, 0, 0 },
  { "sr %c,[%Ab]%S%L", I(-1)|A(-1), I(2)|A(0x10), ARC_MACH_5, 0, 0 },
  /* "[%b]" is before "[%b,%o]" so 0 offsets don't get printed.  */
  { "st%y%.v%.D %c,[%s]%L%S%0", I(-1)|R(-1,25,1)|R(-1,21,1), I(2)|R(0,25,1)|R(0,21,1), ARC_MACH_5, 0, 0 },
  { "st%y%.v%.D %c,[%s,%o]%S%L%2", I(-1)|R(-1,25,1)|R(-1,21,1), I(2)|R(0,25,1)|R(0,21,1), ARC_MACH_5, 0, 0 },
  { "sub%.q%.f %a,%b,%c%F%S%L",	I(-1), I(10), ARC_MACH_5, 0, 0 },
  { "xor%.q%.f %a,%b,%c%F%S%L",	I(-1), I(15), ARC_MACH_5, 0, 0 }
};

const int arc_opcodes_count = sizeof (arc_opcodes) / sizeof (arc_opcodes[0]);

const struct arc_operand_value arc_reg_names[] =
{
  /* Core register set r0-r63.  */

  /* r0-r28 - general purpose registers.  */
  { "r0", 0, REG, 0 }, { "r1", 1, REG, 0 }, { "r2", 2, REG, 0 },
  { "r3", 3, REG, 0 }, { "r4", 4, REG, 0 }, { "r5", 5, REG, 0 },
  { "r6", 6, REG, 0 }, { "r7", 7, REG, 0 }, { "r8", 8, REG, 0 },
  { "r9", 9, REG, 0 }, { "r10", 10, REG, 0 }, { "r11", 11, REG, 0 },
  { "r12", 12, REG, 0 }, { "r13", 13, REG, 0 }, { "r14", 14, REG, 0 },
  { "r15", 15, REG, 0 }, { "r16", 16, REG, 0 }, { "r17", 17, REG, 0 },
  { "r18", 18, REG, 0 }, { "r19", 19, REG, 0 }, { "r20", 20, REG, 0 },
  { "r21", 21, REG, 0 }, { "r22", 22, REG, 0 }, { "r23", 23, REG, 0 },
  { "r24", 24, REG, 0 }, { "r25", 25, REG, 0 }, { "r26", 26, REG, 0 },
  { "r27", 27, REG, 0 }, { "r28", 28, REG, 0 },
  /* Maskable interrupt link register.  */
  { "ilink1", 29, REG, 0 },
  /* Maskable interrupt link register.  */
  { "ilink2", 30, REG, 0 },
  /* Branch-link register.  */
  { "blink", 31, REG, 0 },

  /* r32-r59 reserved for extensions.  */
  { "r32", 32, REG, 0 }, { "r33", 33, REG, 0 }, { "r34", 34, REG, 0 },
  { "r35", 35, REG, 0 }, { "r36", 36, REG, 0 }, { "r37", 37, REG, 0 },
  { "r38", 38, REG, 0 }, { "r39", 39, REG, 0 }, { "r40", 40, REG, 0 },
  { "r41", 41, REG, 0 }, { "r42", 42, REG, 0 }, { "r43", 43, REG, 0 },
  { "r44", 44, REG, 0 }, { "r45", 45, REG, 0 }, { "r46", 46, REG, 0 },
  { "r47", 47, REG, 0 }, { "r48", 48, REG, 0 }, { "r49", 49, REG, 0 },
  { "r50", 50, REG, 0 }, { "r51", 51, REG, 0 }, { "r52", 52, REG, 0 },
  { "r53", 53, REG, 0 }, { "r54", 54, REG, 0 }, { "r55", 55, REG, 0 },
  { "r56", 56, REG, 0 }, { "r57", 57, REG, 0 }, { "r58", 58, REG, 0 },
  { "r59", 59, REG, 0 },

  /* Loop count register (24 bits).  */
  { "lp_count", 60, REG, 0 },
  /* Short immediate data indicator setting flags.  */
  { "r61", 61, REG, ARC_REGISTER_READONLY },
  /* Long immediate data indicator setting flags.  */
  { "r62", 62, REG, ARC_REGISTER_READONLY },
  /* Short immediate data indicator not setting flags.  */
  { "r63", 63, REG, ARC_REGISTER_READONLY },

  /* Small-data base register.  */
  { "gp", 26, REG, 0 },
  /* Frame pointer.  */
  { "fp", 27, REG, 0 },
  /* Stack pointer.  */
  { "sp", 28, REG, 0 },

  { "r29", 29, REG, 0 },
  { "r30", 30, REG, 0 },
  { "r31", 31, REG, 0 },
  { "r60", 60, REG, 0 },

  /* Auxiliary register set.  */

  /* Auxiliary register address map:
     0xffffffff-0xffffff00 (-1..-256) - customer shimm allocation
     0xfffffeff-0x80000000 - customer limm allocation
     0x7fffffff-0x00000100 - ARC limm allocation
     0x000000ff-0x00000000 - ARC shimm allocation  */

  /* Base case auxiliary registers (shimm address).  */
  { "status",         0x00, AUXREG, 0 },
  { "semaphore",      0x01, AUXREG, 0 },
  { "lp_start",       0x02, AUXREG, 0 },
  { "lp_end",         0x03, AUXREG, 0 },
  { "identity",       0x04, AUXREG, ARC_REGISTER_READONLY },
  { "debug",          0x05, AUXREG, 0 },
};

const int arc_reg_names_count =
  sizeof (arc_reg_names) / sizeof (arc_reg_names[0]);

/* The suffix table.
   Operands with the same name must be stored together.  */

const struct arc_operand_value arc_suffixes[] =
{
  /* Entry 0 is special, default values aren't printed by the disassembler.  */
  { "", 0, -1, 0 },

  /* Base case condition codes.  */
  { "al", 0, COND, 0 },
  { "ra", 0, COND, 0 },
  { "eq", 1, COND, 0 },
  { "z", 1, COND, 0 },
  { "ne", 2, COND, 0 },
  { "nz", 2, COND, 0 },
  { "pl", 3, COND, 0 },
  { "p", 3, COND, 0 },
  { "mi", 4, COND, 0 },
  { "n", 4, COND, 0 },
  { "cs", 5, COND, 0 },
  { "c", 5, COND, 0 },
  { "lo", 5, COND, 0 },
  { "cc", 6, COND, 0 },
  { "nc", 6, COND, 0 },
  { "hs", 6, COND, 0 },
  { "vs", 7, COND, 0 },
  { "v", 7, COND, 0 },
  { "vc", 8, COND, 0 },
  { "nv", 8, COND, 0 },
  { "gt", 9, COND, 0 },
  { "ge", 10, COND, 0 },
  { "lt", 11, COND, 0 },
  { "le", 12, COND, 0 },
  { "hi", 13, COND, 0 },
  { "ls", 14, COND, 0 },
  { "pnz", 15, COND, 0 },

  /* Condition codes 16-31 reserved for extensions.  */

  { "f", 1, FLAG, 0 },

  { "nd", ARC_DELAY_NONE, DELAY, 0 },
  { "d", ARC_DELAY_NORMAL, DELAY, 0 },
  { "jd", ARC_DELAY_JUMP, DELAY, 0 },

  { "b", 1, SIZE1, 0 },
  { "b", 1, SIZE10, 0 },
  { "b", 1, SIZE22, 0 },
  { "w", 2, SIZE1, 0 },
  { "w", 2, SIZE10, 0 },
  { "w", 2, SIZE22, 0 },
  { "x", 1, SIGN0, 0 },
  { "x", 1, SIGN9, 0 },
  { "a", 1, ADDRESS3, 0 },
  { "a", 1, ADDRESS12, 0 },
  { "a", 1, ADDRESS24, 0 },

  { "di", 1, CACHEBYPASS5, 0 },
  { "di", 1, CACHEBYPASS14, 0 },
  { "di", 1, CACHEBYPASS26, 0 },
};

const int arc_suffixes_count =
  sizeof (arc_suffixes) / sizeof (arc_suffixes[0]);

/* Indexed by first letter of opcode.  Points to chain of opcodes with same
   first letter.  */
static struct arc_opcode *opcode_map[26 + 1];

/* Indexed by insn code.  Points to chain of opcodes with same insn code.  */
static struct arc_opcode *icode_map[32];

/* Configuration flags.  */

/* Various ARC_HAVE_XXX bits.  */
static int cpu_type;

/* Translate a bfd_mach_arc_xxx value to a ARC_MACH_XXX value.  */

int
arc_get_opcode_mach (int bfd_mach, int big_p)
{
  static int mach_type_map[] =
  {
    ARC_MACH_5,
    ARC_MACH_6,
    ARC_MACH_7,
    ARC_MACH_8
  };
  return mach_type_map[bfd_mach - bfd_mach_arc_5] | (big_p ? ARC_MACH_BIG : 0);
}

/* Initialize any tables that need it.
   Must be called once at start up (or when first needed).

   FLAGS is a set of bits that say what version of the cpu we have,
   and in particular at least (one of) ARC_MACH_XXX.  */

void
arc_opcode_init_tables (int flags)
{
  static int init_p = 0;

  cpu_type = flags;

  /* We may be intentionally called more than once (for example gdb will call
     us each time the user switches cpu).  These tables only need to be init'd
     once though.  */
  if (!init_p)
    {
      int i,n;

      memset (arc_operand_map, 0, sizeof (arc_operand_map));
      n = sizeof (arc_operands) / sizeof (arc_operands[0]);
      for (i = 0; i < n; ++i)
	arc_operand_map[arc_operands[i].fmt] = i;

      memset (opcode_map, 0, sizeof (opcode_map));
      memset (icode_map, 0, sizeof (icode_map));
      /* Scan the table backwards so macros appear at the front.  */
      for (i = arc_opcodes_count - 1; i >= 0; --i)
	{
	  int opcode_hash = ARC_HASH_OPCODE (arc_opcodes[i].syntax);
	  int icode_hash = ARC_HASH_ICODE (arc_opcodes[i].value);

	  arc_opcodes[i].next_asm = opcode_map[opcode_hash];
	  opcode_map[opcode_hash] = &arc_opcodes[i];

	  arc_opcodes[i].next_dis = icode_map[icode_hash];
	  icode_map[icode_hash] = &arc_opcodes[i];
	}

      init_p = 1;
    }
}

/* Return non-zero if OPCODE is supported on the specified cpu.
   Cpu selection is made when calling `arc_opcode_init_tables'.  */

int
arc_opcode_supported (const struct arc_opcode *opcode)
{
  if (ARC_OPCODE_CPU (opcode->flags) <= cpu_type)
    return 1;
  return 0;
}

/* Return the first insn in the chain for assembling INSN.  */

const struct arc_opcode *
arc_opcode_lookup_asm (const char *insn)
{
  return opcode_map[ARC_HASH_OPCODE (insn)];
}

/* Return the first insn in the chain for disassembling INSN.  */

const struct arc_opcode *
arc_opcode_lookup_dis (unsigned int insn)
{
  return icode_map[ARC_HASH_ICODE (insn)];
}

/* Called by the assembler before parsing an instruction.  */

void
arc_opcode_init_insert (void)
{
  int i;

  for(i = 0; i < OPERANDS; i++)
    ls_operand[i] = OP_NONE;

  flag_p = 0;
  flagshimm_handled_p = 0;
  cond_p = 0;
  addrwb_p = 0;
  shimm_p = 0;
  limm_p = 0;
  jumpflags_p = 0;
  nullify_p = 0;
  nullify = 0; /* The default is important.  */
}

/* Called by the assembler to see if the insn has a limm operand.
   Also called by the disassembler to see if the insn contains a limm.  */

int
arc_opcode_limm_p (long *limmp)
{
  if (limmp)
    *limmp = limm;
  return limm_p;
}

/* Utility for the extraction functions to return the index into
   `arc_suffixes'.  */

const struct arc_operand_value *
arc_opcode_lookup_suffix (const struct arc_operand *type, int value)
{
  const struct arc_operand_value *v,*end;
  struct arc_ext_operand_value *ext_oper = arc_ext_operands;

  while (ext_oper)
    {
      if (type == &arc_operands[ext_oper->operand.type]
	  && value == ext_oper->operand.value)
	return (&ext_oper->operand);
      ext_oper = ext_oper->next;
    }

  /* ??? This is a little slow and can be speeded up.  */
  for (v = arc_suffixes, end = arc_suffixes + arc_suffixes_count; v < end; ++v)
    if (type == &arc_operands[v->type]
	&& value == v->value)
      return v;
  return 0;
}

int
arc_insn_is_j (arc_insn insn)
{
  return (insn & (I(-1))) == I(0x7);
}

int
arc_insn_not_jl (arc_insn insn)
{
  return ((insn & (I(-1)|A(-1)|C(-1)|R(-1,7,1)|R(-1,9,1)))
	  != (I(0x7) | R(-1,9,1)));
}

int
arc_operand_type (int opertype)
{
  switch (opertype)
    {
    case 0:
      return COND;
      break;
    case 1:
      return REG;
      break;
    case 2:
      return AUXREG;
      break;
    }
  return -1;
}

struct arc_operand_value *
get_ext_suffix (char *s)
{
  struct arc_ext_operand_value *suffix = arc_ext_operands;

  while (suffix)
    {
      if ((COND == suffix->operand.type)
	  && !strcmp(s,suffix->operand.name))
	return(&suffix->operand);
      suffix = suffix->next;
    }
  return NULL;
}

int
arc_get_noshortcut_flag (void)
{
  return ARC_REGISTER_NOSHORT_CUT;
}
@


1.17.28.1
log
@Commit patches for ARCompact support to binutils-arc-20081103-branch .
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2004, 2005, 2009
d25 1
d29 20
d50 5
a54 3
/* -------------------------------------------------------------------------- */
/*                                  local types                               */
/* -------------------------------------------------------------------------- */
d56 2
a57 1
enum operand {OP_NONE,OP_REG,OP_SHIMM,OP_LIMM};
d59 2
d62 2
a63 3
/* -------------------------------------------------------------------------- */
/*                                 local macros                               */
/* -------------------------------------------------------------------------- */
d65 2
a66 1
#define ELEMENTS_IN(arr)    (sizeof (arr) / sizeof ((arr)[0]))
d68 2
d71 3
a73 3
/* -------------------------------------------------------------------------- */
/*                      forward declarations of functions                     */
/* -------------------------------------------------------------------------- */
d75 3
a77 1
int arc_get_noshortcut_flag (void);
d79 4
d84 1
a84 1
static arc_insn fn (arc_insn, long *, const struct arc_operand *, \
a91 7
INSERT_FN (insert_u8);
INSERT_FN (insert_u16);
INSERT_FN (insert_uu16);
INSERT_FN (insert_ul16);
INSERT_FN (insert_null);
INSERT_FN (insert_s12);
INSERT_FN (insert_s15);
a98 1
INSERT_FN (insert_ex_syntax);
a120 56

/* -------------------------------------------------------------------------- */
/*                               local data                                   */
/* -------------------------------------------------------------------------- */

/* Nonzero if we've seen an 'f' suffix (in certain insns).  */
static int flag_p;

/* Nonzero if we've finished processing the 'f' suffix.  */
static int flagshimm_handled_p;

/* Nonzero if we've seen a 'a' suffix (address writeback).  */
static int addrwb_p;

/* Nonzero if we've inserted a nullify condition.  */
static int nullify_p;

/* The value of the a nullify condition we inserted.  */
static int nullify;

/* Nonzero if we've inserted jumpflags.  */
static int jumpflags_p;

/* Nonzero if we've inserted a shimm.  */
static int shimm_p;

/* The value of the shimm we inserted (each insn only gets one but it can
   appear multiple times).  */
static int shimm;

/* Nonzero if we've inserted a limm (during assembly) or seen a limm
   (during disassembly).  */
static int limm_p;

/* The value of the limm we inserted.  Each insn only gets one but it can
   appear multiple times.  */
static long limm;


/* Configuration flags.  */

/* Various ARC_HAVE_XXX bits.  */
static int cpu_type;


/* Given a format letter, yields the index into `arc_operands'.
   eg: arc_operand_map['a'] = REGA, for ARCtangent-A4.  */
static unsigned char arc_operand_map_a4[256];
static unsigned char arc_operand_map_ac[256];


#define OPERANDS 3

static enum operand ls_operand[OPERANDS];


d142 1
a142 1
   'Q'	FORCELIMM	set `arc_cond_p' to 1 to ensure a constant is a limm
d169 1
a169 3
/* Operand table used for ARCtangent-A4 instructions */

static const struct arc_operand arc_operands_a4[] =
d243 1
a243 1
/* Set `arc_cond_p' to 1 to ensure a constant is treated as a limm.  */
d249 1
a249 1
  { 'B', 20, 7, ARC_OPERAND_RELATIVE_BRANCH + (ARC_OPERAND_SIGNED | ARC_OPERAND_ERROR), insert_reladdr, extract_reladdr },
d254 1
a254 1
  { 'J', 24, 32, (ARC_OPERAND_ERROR | ARC_OPERAND_ABSOLUTE_BRANCH) + ARC_OPERAND_LIMM + ARC_OPERAND_FAKE, insert_absaddr, 0 },
d325 1
a325 725


/* Various types of ARCompact operands, including insn suffixes */

/* Operand format values:

   'A'	REGA_AC            register A field for ARCompact 32-bit insns
   'B'	REGB_SOURCE_AC     register B (as a source) field for ARCompact 32-bit insns
   '#'	REGB_DEST_AC       register B (as a destination) field for ARCompact 32-bit insns
   'C'	REGC_AC            register C field for ARCompact 32-bit insns
   'u'	UIMM6_AC           6-bit unsigned immediate
   'K'	SIMM12_AC          12-bit signed immediate
   'L'	LIMM_AC            32-bit long immediate
   'F'	FLAGFINISH_AC      finish inserting the F flag for ARCompact insns
   'n'	DELAY_AC           N field (nullify field)
   'N'	JUMP_DELAY_AC      nullify field for "j" and "jl" insns
   'o'	OFFSET_AC          9-bit Offset in ARCompact 32-bit 'ld' insns
   'd'	SIMM9_AC           9-bit signed immediate value for 'bbit' insns
   'z'	SIZE1_AC           size field in ARCompact "st" insns
   't'	SIZE7_AC           size field in ARCompact "ld" insns
   'T'	SIZE17_AC          size field in ARCompact "ld" insns
   'x'	SIGN6_AC           sign extend field in ARCompact "ld" insns
   'X'	SIGN16_AC          sign extend field in ARCompact "ld" insns
   'w'	ADDRESS3_AC        write-back field in ld a,[b,c]
   'p'	ADDRESS9_AC        write-back field in ARCompact "ld a,[b,s9]" insns
   'P'	ADDRESS22_AC       write-back field in ARCompact "ld a,[b,c]" insns

   '&'	ADDRESS22S_AC      scaling field in ARCompact "ld a,[limm,c]" insns
   'D'	CACHEBYPASS5_AC    cache bypass in ARCompact "st" insns
   'v'	CACHEBYPASS11_AC   cache bypass in ARCompact "ld a,[b,s9]" insns
   'V'	CACHEBYPASS15_AC   cache bypass in ARCompact "ld a,[b,c]" insns and
                           A700 Atomic Exchange (ex.<di> b,[c] and ex.<di> b,[limm]
   'g'	BASE_AC            base in ARCompact "st" insns
   'h'	BLINK_AC           branch address (21-bit pc-relative) in
                           conditional 'bl' (BLcc) insns
   'H'	UNCOND_BLINK_AC    branch address (25-bit pc-relative) in
                           unconditional 'bl' (BL) insns
   'i'	BRANCH_AC          branch address (21-bit pc-relative) in
                           conditional 'b' (Bcc) insns
   'I'	UNCOND_BRANCH_AC   branch address (25-bit pc-relative) in
                           unconditional 'b' (B) insns
   'y'	UIMM7BY2_AC        7-bit unsigned immediate operand used in ARCompact
                           'lp' insns
   'Y'	SIMM13BY2_AC       13-bit signed immediate operand used in ARCompact
                           'lp' insns
   'q'	COND_AC            condition code field
   'f'	FLAG_AC            F flag in ARCompact insns
   'Q'	FORCELIMM_AC       set `arc_cond_p' to 1 to ensure a constant is a limm
   '0'	SYNTAX_ST_NE_AC    enforce store insn syntax, no errors
   '1'	SYNTAX_LD_NE_AC    enforce load insn syntax, no errors
   '2'  SYNTAX_ST_AC       enforce store insn syntax, errors, last pattern only
   '3'  SYNTAX_LD_AC       enforce load insn syntax, errors, last pattern only
   '7'	ILINK1             'ilink1' register indicator
   '8'	ILINK2             'ilink2' register indicator

   The following modifiers may appear between the % and char (eg: %.f):

   '.'	MODDOT_AC          '.' prefix must be present
   'r'	REG_AC             generic register value, for register table
   'G'	AUXREG_AC          auxiliary register in "lr" and "sr" insns

   The following operands are used specific to 16-bit insns

   'a'	REGA_AC16          register A field for ARCompact 16-bit insns
   'b'	REGB_AC16          register B field for ARCompact 16-bit insns
   'c'	REGC_AC16          register C field for ARCompact 16-bit insns
   'U'	REGH_AC16          high register H field for ARCompact 16-bit insns


   'e'	UIMM3_AC16         3-bit unsigned immediate
   'E'	UIMM5_AC16         5-bit unsigned immediate
   'j'	UIMM7_AC16         7-bit unsigned immediate
   'J'	UIMM8_AC16         8-bit unsigned immediate
   'k'	UIMM6BY2_AC16      6-bit unsigned immediate, stored in bits 0-4
   'l'	UIMM7BY4_AC16      7-bit unsigned immediate, stored in bits 0-4
   'm'	UIMM10BY4_AC16     10-bit unsigned immediate, stored in bits 0-7
   's'	COND_BRANCH_AC16   branch address (7-bit pc-relative) for 16-bit
                           conditional branch insns (ex: bgt_s)
   'S'	CMP_BRANCH_AC16    branch address (8-bit pc-relative) for 16-bit
                           compare and branch insns (ex: breq_s, brne_s)
   'Z'	UNCOND_BRANCH_AC16 branch address (10-bit pc-relative) for 16-bit
                           branch insns (b_s, beq_s, bne_s)
   'W'	BLINK_AC16         branch address (11-bit pc-relative) for 16-bit
                           branch and link insns (bl_s)
   'M'	SIMM9_AC16         9-bit offset, used in "ldb_s" insn
   'O'	SIMM10BY2_AC16     10-bit offset(2-byte aligned), used in "ldw_s" insn
   'R'	SIMM11BY4_AC16     11-bit offset(4-byte aligned), used in "ld_s" insn
   '4'	REG_R0             'r0' register indicator
   '5'	REG_GP             'gp' register indicator
   '6'	REG_SP             'sp' register indicator
   '9'	REG_BLINK          'blink' register indicator
   '!'	REG_PCL            'pcl' register indicator
   '@@'  UIMM6_A700_16         6-bit unsigned immediate in A700

   The following operands are used specific to the Aurora SIMD insns

   '*' SIMD_VR_DEST        'vr' registers as the destination in the A field
   '(' SIMD_VR_REGB        'vr' registers in the field B
   ')' SIMD_VR_REGC        'vr' registers in the field C

   '{' SIMD_I_REGB         'I'  registers in the field B
   '}' SIMD_I_REGC         'I'  registers in the field C

   '<' SIMD_DR_REGB        'DR' registers in the field B
   '>' SIMD_DR_REGC        'DR' registers in the field C
   '?' SIMD_U8_CONSTANT     A unsigned 8 bit constant
 '\13' SIMD_I_REGA         'I'  registers in the field A
 '\14' SIMD_I_S12          signed 12 bit in simd instruction
 '\15' SIMD_I_K_REGA       'K'  registers in the field A
 '\16' SIMD_I_K_REGB       'K'  registers in the field B
 '\17' SIMD_I_K_REGC       'K'  registers in the field C
 '\20' SIMD_I_U16          unsigned 16 bit in simd
 '\21' SIMD_I_UU16         high order 8 of 16 bit unsigned
 '\22' SIMD_I_UL16         low order 8 of 16 bit unsigned
 '\23' SIMD_DISCARDED      value not used
 '\24' SIMD_I_S15          simd 15 big signed field 
   


   Fields are:

   CHAR BITS SHIFT FLAGS INSERT_FN EXTRACT_FN
*/

/* Operand table used for ARCompact instructions */

static const struct arc_operand arc_operands_ac[] =
{
/* place holder (??? not sure if needed) */
#define UNUSED_AC 0
  { 0, 0, 0, 0, 0, 0 },

/* register A used for ARCompact 32-bit insns */
#define REGA_AC (UNUSED_AC + 1)
  { 'A', 6, ARC_SHIFT_REGA_AC, ARC_OPERAND_SIGNED | ARC_OPERAND_ERROR, insert_reg, extract_reg },

/* register B used for ARCompact 32-bit insns as a source */
#define REGB_SOURCE_AC (REGA_AC + 1)
  { 'B', 6, ARC_SHIFT_REGB_LOW_AC, ARC_OPERAND_SIGNED | ARC_OPERAND_ERROR, insert_reg, extract_reg },

/* register B used for ARCompact 32-bit insns as a destination */
#define REGB_DEST_AC (REGB_SOURCE_AC + 1)
  { '#', 6, ARC_SHIFT_REGB_LOW_AC, ARC_OPERAND_SIGNED | ARC_OPERAND_ERROR, insert_reg, extract_reg },

/* register C used for ARCompact 32-bit insns */
#define REGC_AC (REGB_DEST_AC + 1)
  { 'C', 6, ARC_SHIFT_REGC_AC, ARC_OPERAND_SIGNED | ARC_OPERAND_ERROR, insert_reg, extract_reg },

/* 6-bit unsigned immediate value, used in ARCompact 32-bit insns */
#define UIMM6_AC (REGC_AC + 1)
  { 'u', 6, 6, ARC_OPERAND_UNSIGNED, 0, 0 },

/* 12-bit signed immediate value, used in ARCompact 32-bit insns */
#define SIMM12_AC (UIMM6_AC + 1)
  { 'K', 12, 6, ARC_OPERAND_SIGNED, 0, 0 },

/* 32-bit long immediate value, used in ARCompact insns */
#define LIMM_AC (SIMM12_AC + 1)
  { 'L', 32, 32, ARC_OPERAND_ADDRESS | ARC_OPERAND_LIMM, insert_reg, 0 },

/* set `arc_cond_p' to 1 to ensure a constant is treated as a limm */
#define FORCELIMM_AC (LIMM_AC + 1)
  { 'Q', 0, 0, ARC_OPERAND_FAKE, insert_forcelimm, 0 },

/* conditional code indicator, used in ARCompact insns */
#define COND_AC (FORCELIMM_AC + 1)
  { 'q', 5, 0, ARC_OPERAND_SUFFIX, insert_cond, extract_cond },

/* flag update bit (insertion is defered until we know how) */
#define FLAG_AC (COND_AC + 1)
  { 'f', 1, 15, ARC_OPERAND_SUFFIX, insert_flag, extract_flag },

/* fake utility operand to finish 'f' suffix handling for ARCompact inst */
#define FLAGFINISH_AC (FLAG_AC + 1)
  { 'F', 1, 15, ARC_OPERAND_FAKE, insert_flagfinish, 0 },

/* branch delay types for ARCompact 32-bit insns */
#define DELAY_AC (FLAGFINISH_AC + 1)
  { 'n', 1, 5, ARC_OPERAND_SUFFIX, insert_nullify, 0 },

/* delay types for ARCompact 32-bit "j"/"jl" insns */
#define JUMP_DELAY_AC (DELAY_AC + 1)
  { 'N', 1, 16, ARC_OPERAND_SUFFIX, insert_nullify, 0 },

/* size field, stored in bit 1,2 */
#define SIZE1_AC (JUMP_DELAY_AC + 1)
  { 'z', 2, 1, ARC_OPERAND_SUFFIX, 0, 0 },

/* size field, stored in bit 7,8 */
#define SIZE7_AC (SIZE1_AC + 1)
  { 't', 2, 7, ARC_OPERAND_SUFFIX, 0, 0 },

/* size field, stored in bit 17,18 */
#define SIZE17_AC (SIZE7_AC + 1)
  { 'T', 2, 17, ARC_OPERAND_SUFFIX, 0, 0 },

/* sign extend field, stored in bit 6 */
#define SIGN6_AC (SIZE17_AC + 1)
  { 'x', 1, 6, ARC_OPERAND_SUFFIX, 0, 0 },

/* sign extend field, stored in bit 16 */
#define SIGN16_AC (SIGN6_AC + 1)
  { 'X', 1, 16, ARC_OPERAND_SUFFIX, 0, 0 },

/* address write back field, stored in bit 3,4 */
#define ADDRESS3_AC (SIGN16_AC + 1)
  { 'w', 2, 3, ARC_OPERAND_SUFFIX, insert_addr_wb, 0 },

/* address write back field, stored in bit 9, 10 */
#define ADDRESS9_AC (ADDRESS3_AC + 1)
  { 'p', 2, 9, ARC_OPERAND_SUFFIX, insert_addr_wb, 0 },

/* address write back field, stored in bit 22 */
#define ADDRESS22_AC (ADDRESS9_AC + 1)
  { 'P', 2, 22, ARC_OPERAND_SUFFIX, insert_addr_wb, 0 },

/* address scaling field, stored in bit 22 */
#define ADDRESS22S_AC (ADDRESS22_AC + 1)
  { '&', 2, 22, ARC_OPERAND_SUFFIX, insert_addr_wb, 0 },

/* cache bypass field, stored in bit 5 */
#define CACHEBYPASS5_AC (ADDRESS22S_AC + 1)
  { 'D', 1, 5, ARC_OPERAND_SUFFIX, 0, 0 },

/* cache bypass field, stored in bit 11 */
#define CACHEBYPASS11_AC (CACHEBYPASS5_AC + 1)
  { 'v', 1, 11, ARC_OPERAND_SUFFIX, 0, 0 },

/* cache bypass field, stored in bit 15 */
#define CACHEBYPASS15_AC (CACHEBYPASS11_AC + 1)
  { 'V', 1, 15, ARC_OPERAND_SUFFIX, 0, 0 },

/* base register for ARCompact 32-bit "ld"/"st" insns */
#define BASE_AC (CACHEBYPASS15_AC + 1)
  { 'g', 6, ARC_SHIFT_REGB_LOW_AC, ARC_OPERAND_LIMM |ARC_OPERAND_SIGNED, insert_base, extract_reg },

/* 9-bit signed immediate offset, used in ARCompact 32-bit "ld" insn */
#define OFFSET_AC (BASE_AC + 1)
  { 'o', 9, 16, ARC_OPERAND_LIMM | ARC_OPERAND_SIGNED | ARC_OPERAND_LOAD, insert_offset, extract_ld_offset },

/* branch address(9-bit, pc-relative, 2-byte aligned), used for
  "bbit0"/"bbit1" insns */
#define SIMM9_AC (OFFSET_AC + 1)
  { 'd', 8, 17, ARC_OPERAND_RELATIVE_BRANCH | ARC_OPERAND_SIGNED | ARC_OPERAND_2BYTE_ALIGNED | ARC_OPERAND_ERROR, insert_reladdr, extract_reladdr  },

/* branch address(21-bit, pc-relative, 4-byte aligned), used for
   ARCompact 32-bit conditional 'bl' insns */
#define BLINK_AC (SIMM9_AC + 1)
  { 'h', 19, 18, ARC_OPERAND_RELATIVE_BRANCH | ARC_OPERAND_SIGNED | ARC_OPERAND_4BYTE_ALIGNED | ARC_OPERAND_ERROR, insert_reladdr, extract_reladdr },

/* branch address(25-bit, pc-relative, 4-byte aligned), used for
   ARCompact 32-bit unconditional 'bl' insns */
#define UNCOND_BLINK_AC (BLINK_AC + 1)
  { 'H', 23, 18, ARC_OPERAND_RELATIVE_BRANCH | ARC_OPERAND_SIGNED | ARC_OPERAND_4BYTE_ALIGNED | ARC_OPERAND_ERROR, insert_reladdr, extract_reladdr },

/* branch address(21-bit, pc-relative, 2-byte aligned), used for
   ARCompact 32-bit conditional 'b' insns */
#define BRANCH_AC (UNCOND_BLINK_AC + 1)
  { 'i', 20, 17, ARC_OPERAND_RELATIVE_BRANCH | ARC_OPERAND_SIGNED | ARC_OPERAND_2BYTE_ALIGNED | ARC_OPERAND_ERROR, insert_reladdr, extract_reladdr },

/* branch address(25-bit, pc-relative, 2-byte aligned), used for
   ARCompact 32-bit unconditional 'b' insns */
#define UNCOND_BRANCH_AC (BRANCH_AC + 1)
  { 'I', 24, 17, ARC_OPERAND_RELATIVE_BRANCH | ARC_OPERAND_SIGNED | ARC_OPERAND_2BYTE_ALIGNED | ARC_OPERAND_ERROR, insert_reladdr, extract_reladdr },

/* branch address (7-bit, unsigned pc-relative, 2-byte aligned), used for
   ARCompact 32-bit conditional 'lp' insns */
#define UIMM7BY2_AC (UNCOND_BRANCH_AC + 1)
  { 'y', 6, 6, ARC_OPERAND_RELATIVE_BRANCH | ARC_OPERAND_2BYTE_ALIGNED | ARC_OPERAND_ERROR, insert_reladdr, extract_reladdr  },

/* branch address (13-bit, pc-relative, 2-byte aligned), used for
   ARCompact 32-bit uncoditional 'lp' insns */
#define SIMM13BY2_AC (UIMM7BY2_AC + 1)
  { 'Y', 12, 6, ARC_OPERAND_RELATIVE_BRANCH | ARC_OPERAND_SIGNED | ARC_OPERAND_2BYTE_ALIGNED | ARC_OPERAND_ERROR, insert_reladdr, extract_reladdr },

/* enforce syntax for st insns */
#define SYNTAX_ST_NE_AC (SIMM13BY2_AC + 1)
  { '0', 9, 0, ARC_OPERAND_FAKE, insert_st_syntax, extract_st_syntax },

/* enforce syntax for ld insns */
#define SYNTAX_LD_NE_AC (SYNTAX_ST_NE_AC + 1)
  { '1', 9, 0, ARC_OPERAND_FAKE, insert_ld_syntax, extract_ld_syntax },

/* enforce syntax for st insns */
#define SYNTAX_ST_AC (SYNTAX_LD_NE_AC + 1)
  { '2', 9, 0, ARC_OPERAND_FAKE | ARC_OPERAND_ERROR, insert_st_syntax, extract_st_syntax },

/* enforce syntax for ld insns */
#define SYNTAX_LD_AC (SYNTAX_ST_AC + 1)
  { '3', 9, 0, ARC_OPERAND_FAKE | ARC_OPERAND_ERROR, insert_ld_syntax, extract_ld_syntax },

/* enforce syntax for ex insns */
#define SYNTAX_EX_AT (SYNTAX_LD_AC + 1)
  { '^', 9, 0, ARC_OPERAND_FAKE | ARC_OPERAND_ERROR, insert_ex_syntax, 0 },

/* 'ilink1' register indicator, used for ARCompact 'j' insn */
#define ILINK1 (SYNTAX_EX_AT + 1)
  { '7', 0, 0, 0, 0, 0 },

/* 'ilink2' register indicator, used for ARCompact 'j' insn */
#define ILINK2 (ILINK1 + 1)
  { '8', 0, 0, 0, 0, 0 },

/* '.' modifier ('.' required).  */
#define MODDOT_AC (ILINK2 + 1)
  { '.', 1, 0, ARC_MOD_DOT, 0, 0 },

/* Dummy 'r' modifier for the register table. */
#define REG_AC (MODDOT_AC + 1)
  { 'r', 6, 0, ARC_MOD_REG, 0, 0 },

/* Known auxiliary register modifier */
#define AUXREG_AC (REG_AC + 1)
  { 'G', 9, 0, ARC_MOD_AUXREG, 0, 0 },

/* Operands used specific to ARCompact 16-bit insns */

/* register A indicator, for ARCompact 16-bit insns */
#define REGA_AC16 (AUXREG_AC + 1)
  { 'a', 3, 0, ARC_OPERAND_SIGNED | ARC_OPERAND_ERROR, insert_reg, extract_reg },

/* register B indicator, for ARCompact 16-bit insns */
#define REGB_AC16 (REGA_AC16 + 1)
  { 'b', 3, 8, ARC_OPERAND_SIGNED | ARC_OPERAND_ERROR, insert_reg, extract_reg },

/* register C indicator, for ARCompact 16-bit insns */
#define REGC_AC16 (REGB_AC16 + 1)
  { 'c', 3, 5, ARC_OPERAND_SIGNED | ARC_OPERAND_ERROR, insert_reg, extract_reg },

/* high register(r0-r63) indicator, for ARCompact 16-bit insns */
#define REGH_AC16 (REGC_AC16 + 1)
  { 'U', 6, 5, ARC_OPERAND_SIGNED | ARC_OPERAND_ERROR, insert_reg, extract_reg },

/* 3-bit unsigned immediate, stored in bits 0-2 */
#define UIMM3_AC16 (REGH_AC16 + 1)
  { 'e', 3, 0, ARC_OPERAND_UNSIGNED, 0, 0 },

/* 5-bit unsigned immediate, stored in bits 0-4 */
#define UIMM5_AC16 (UIMM3_AC16 + 1)
  { 'E', 5, 0, ARC_OPERAND_UNSIGNED, 0, 0 },

/* 7-bit unsigned immediate, stored in bits 0-6 */
#define UIMM7_AC16 (UIMM5_AC16 + 1)
  { 'j', 7, 0, ARC_OPERAND_UNSIGNED, 0, 0 },

/* 8-bit unsigned immediate, stored in bits 0-7 */
#define UIMM8_AC16 (UIMM7_AC16 + 1)
  { 'J', 8, 0, ARC_OPERAND_UNSIGNED, 0, 0 },

/* 6-bit unsigned immediate, stored in bits 0-4, used in 16-bit ld insns */
#define UIMM6BY2_AC16 (UIMM8_AC16 + 1)
  { 'k', 5, 0, ARC_OPERAND_UNSIGNED | ARC_OPERAND_LOAD | ARC_OPERAND_2BYTE_ALIGNED , insert_offset, extract_ld_offset },

/* 7-bit unsigned immediate, stored in bits 0-4, used in 16-bit
   add/sub/ld/st insns */
#define UIMM7BY4_AC16 (UIMM6BY2_AC16 + 1)
  { 'l', 5, 0, ARC_OPERAND_UNSIGNED | ARC_OPERAND_4BYTE_ALIGNED, 0, 0 },

/* 10-bit unsigned immediate, stored in bits 0-7, used in "ld_s" insn */
#define UIMM10BY4_AC16 (UIMM7BY4_AC16 + 1)
  { 'm', 8, 0, ARC_OPERAND_UNSIGNED | ARC_OPERAND_LOAD | ARC_OPERAND_4BYTE_ALIGNED , insert_offset, extract_ld_offset },

/* branch address(7-bit, pc-relative, 2-byte aligned), used for
   ARCompact 16-bit conditional branch insns */
#define COND_BRANCH_AC16 (UIMM10BY4_AC16 + 1)
  { 's', 6, 0, ARC_OPERAND_RELATIVE_BRANCH | ARC_OPERAND_SIGNED | ARC_OPERAND_2BYTE_ALIGNED | ARC_OPERAND_ERROR, insert_reladdr, extract_reladdr },

/* branch address(8-bit, pc-relative, 2-byte aligned), used for
   ARCompact 16-bit compare and branch insns */
#define CMP_BRANCH_AC16 (COND_BRANCH_AC16 + 1)
  { 'S', 7, 0, ARC_OPERAND_RELATIVE_BRANCH | ARC_OPERAND_SIGNED | ARC_OPERAND_2BYTE_ALIGNED | ARC_OPERAND_ERROR, insert_reladdr, extract_reladdr },

/* branch address(10-bit, pc-relative, 2-byte aligned), used for
   ARCompact 16-bit branch insns */
#define UNCOND_BRANCH_AC16 (CMP_BRANCH_AC16 + 1)
  { 'Z', 9, 0, ARC_OPERAND_RELATIVE_BRANCH | ARC_OPERAND_SIGNED | ARC_OPERAND_2BYTE_ALIGNED | ARC_OPERAND_ERROR, insert_reladdr, extract_reladdr },

/* branch address(13-bit, pc-relative), used for ARCompact 16-bit
   branch and link insns */
#define BLINK_AC16 (UNCOND_BRANCH_AC16 + 1)
  { 'W', 11, 0, ARC_OPERAND_RELATIVE_BRANCH | ARC_OPERAND_SIGNED | ARC_OPERAND_4BYTE_ALIGNED | ARC_OPERAND_ERROR, insert_reladdr, extract_reladdr },

/* 9-bit signed immediate offset, used in "ldb_s" insn */
#define SIMM9_AC16 (BLINK_AC16 + 1)
  { 'M', 9, 0, ARC_OPERAND_LIMM | ARC_OPERAND_SIGNED | ARC_OPERAND_LOAD, insert_offset, extract_ld_offset },

/* 10-bit signed immediate offset(2-byte aligned), used in "ldw_s" insn */
#define SIMM10BY2_AC16 (SIMM9_AC16 + 1)
  { 'O', 9, 0, ARC_OPERAND_LIMM | ARC_OPERAND_SIGNED | ARC_OPERAND_LOAD | ARC_OPERAND_2BYTE_ALIGNED , insert_offset, extract_ld_offset },

/* 11-bit signed immediate offset(4-byte aligned), used in "ld_s" insn */
#define SIMM11BY4_AC16 (SIMM10BY2_AC16 + 1)
  { 'R', 9, 0, ARC_OPERAND_LIMM | ARC_OPERAND_SIGNED | ARC_OPERAND_LOAD | ARC_OPERAND_4BYTE_ALIGNED , insert_offset, extract_ld_offset },

/* 'r0' register indicator */
#define REG_R0 (SIMM11BY4_AC16 + 1)
  { '4', 0, 0, 0, 0, 0 },

/* 'gp' register indicator */
#define REG_GP (REG_R0 + 1)
  { '5', 0, 0, 0, 0, 0 },

/* 'sp' register indicator */
#define REG_SP (REG_GP + 1)
  { '6', 0, 0, 0, 0, 0 },

/* 'blink' register indicator */
#define REG_BLINK (REG_SP + 1)
  { '9', 0, 0, 0, 0, 0 },

/* 'pcl' register indicator */
#define REG_PCL (REG_BLINK + 1)
  { '!', 0, 0, 0, 0, 0 },

  /* 'd'  UIMM6_A700_16         6-bit unsigned immediate in A700 */
#define UIMM6_A700_16 (REG_PCL + 1)
  { '@@', 6 ,5, ARC_OPERAND_UNSIGNED, 0 , 0},

 /***** Here are the operands exclusively used in the Aurora SIMD instructions  *******/

  /* '*' For a 128 bit vr  register for the Aurora platform in field A*/
#define SIMD_VR_DEST (UIMM6_A700_16 + 1)
  { '*', 6, ARC_SHIFT_REGA_AC     , ARC_OPERAND_SIGNED | ARC_OPERAND_ERROR, insert_reg, 0},

  /* '(' For a 128 bit vr  register for the Aurora platform in field B*/
#define SIMD_VR_REGB   (SIMD_VR_DEST + 1)
  { '(', 6, ARC_SHIFT_REGB_LOW_AC , ARC_OPERAND_SIGNED | ARC_OPERAND_ERROR, insert_reg, 0},

  /*')' For a 128 bit vr register for the Aurora platform in field C*/
#define SIMD_VR_REGC (SIMD_VR_REGB + 1)
  { ')', 6, ARC_SHIFT_REGC_AC     , ARC_OPERAND_SIGNED | ARC_OPERAND_ERROR, insert_reg, 0},

  /*'?' For a 8 bit unsigned constant */
#define SIMD_U8_CONSTANT (SIMD_VR_REGC + 1)
  { '?', 8, 6 , ARC_OPERAND_UNSIGNED , insert_u8, 0},

  /* '{' For  the I registers inserted into field B*/
#define SIMD_I_REGB (SIMD_U8_CONSTANT + 1)
  { '{', 6 , ARC_SHIFT_REGB_LOW_AC, ARC_OPERAND_SIGNED | ARC_OPERAND_ERROR, insert_reg, 0},

  /* '}' For the I  registers inserted into field C*/
#define SIMD_I_REGC (SIMD_I_REGB + 1)
  { '}', 6 , ARC_SHIFT_REGC_AC    , ARC_OPERAND_SIGNED | ARC_OPERAND_ERROR, insert_reg, 0},

  /* '<' For the DR registers inserted into field B */
#define SIMD_DR_REGB (SIMD_I_REGC + 1)
  { '<', 6 , ARC_SHIFT_REGB_LOW_AC, ARC_OPERAND_SIGNED | ARC_OPERAND_ERROR, insert_reg, 0},

  /* '>' For the DR registers inserted into field C*/
#define SIMD_DR_REGC (SIMD_DR_REGB + 1)
  { '>', 6 , ARC_SHIFT_REGC_AC    , ARC_OPERAND_SIGNED | ARC_OPERAND_ERROR, insert_reg, 0},

  /* small data symbol */
#define SDASYM (SIMD_DR_REGC + 1)
  { '[', 0, 0, ARC_MOD_SDASYM, 0, 0 },

/* simd const lanemask */
#define SIMD_LANEMASK (SDASYM+1)
  { ']', 0, 15, ARC_OPERAND_SUFFIX,0,0},

#define THROW_AC (SIMD_LANEMASK + 1)
  { '\07', 6, 0, ARC_OPERAND_UNSIGNED, 0, 0 },

#define SIMD_I_REGA (THROW_AC + 1)
  { '\13', 6, ARC_SHIFT_REGA_AC, ARC_OPERAND_SIGNED|ARC_OPERAND_ERROR, insert_reg, 0 },
#define SIMD_I_S12  (SIMD_I_REGA+1)
  { '\14', 6, ARC_SHIFT_REGC_AC, ARC_OPERAND_SIGNED|ARC_OPERAND_ERROR, insert_s12, 0 },
#define SIMD_K_A  (SIMD_I_S12+1)
  { '\15', 6, ARC_SHIFT_REGA_AC, ARC_OPERAND_SIGNED|ARC_OPERAND_ERROR, insert_reg, 0 },
#define SIMD_K_B  (SIMD_K_A+1)
  { '\16', 6, ARC_SHIFT_REGB_LOW_AC, ARC_OPERAND_SIGNED|ARC_OPERAND_ERROR, insert_reg, 0 },
#define SIMD_K_C  (SIMD_K_B+1)
  { '\17', 6, ARC_SHIFT_REGC_AC, ARC_OPERAND_SIGNED|ARC_OPERAND_ERROR, insert_reg, 0 },
#define SIMD_I_U16  (SIMD_K_C+1)
  { '\20', 6, ARC_SHIFT_REGC_AC, ARC_OPERAND_SIGNED|ARC_OPERAND_ERROR, insert_u16, 0 },
#define SIMD_I_UU16  (SIMD_I_U16+1)
  { '\21', 6, ARC_SHIFT_REGC_AC, ARC_OPERAND_SIGNED|ARC_OPERAND_ERROR, insert_uu16, 0 },
#define SIMD_I_UL16  (SIMD_I_UU16+1)
  { '\22', 6, ARC_SHIFT_REGC_AC, ARC_OPERAND_SIGNED|ARC_OPERAND_ERROR, insert_ul16, 0 },
#define SIMD_DISCARDED  (SIMD_I_UL16+1)
  { '\23', 6, ARC_SHIFT_REGC_AC, ARC_OPERAND_SIGNED|ARC_OPERAND_ERROR, insert_null, 0 },
#define SIMD_I_S15   (SIMD_DISCARDED+1)
  { '\24', 6, ARC_SHIFT_REGC_AC, ARC_OPERAND_SIGNED|ARC_OPERAND_ERROR, insert_s15, 0 },
/* end of list place holder */
  { 0, 0, 0, 0, 0, 0 }
};


/* -------------------------------------------------------------------------- */
/*                            externally visible data                         */
/* -------------------------------------------------------------------------- */

/* Nonzero if we've seen a 'q' suffix (condition code).  */
int arc_cond_p;

/* Non-zero, for ARCtangent-A4 */
int arc_mach_a4;

/* For ARC700, no extension registers nor LP_COUNT may be the target of
   LD or EX instructions, the only allowed encoding above 32 is 62,
   which is used for prefetch.  The initial setting of arc_ld_ext_mask
   reflects these constraints.

   For ARC500 / ARC600, LP_COUNT is also forbidden for loads, but extension
   registers might allow loads.  */
unsigned long arc_ld_ext_mask = 1 << (62 - 32);

int arc_user_mode_only = 0;

struct arc_ext_operand_value *arc_ext_operands;

#define LS_VALUE  0
#define LS_DEST   0
#define LS_BASE   1
#define LS_OFFSET 2

/* By default, the pointer 'arc_operand_map' points to the operand map table
   used for ARCtangent-A4 (i.e arc_operand_map_a4[]) .  */
unsigned char *arc_operand_map = arc_operand_map_a4;

/* By default, the pointer 'arc_operands' points to the operand table
   used for 32-bit instructions (i.e arc_operands_a4[]) */
const struct arc_operand *arc_operands = arc_operands_a4;


/* -------------------------------------------------------------------------- */
/*                               local functions                              */
/* -------------------------------------------------------------------------- */

/* Insertion functions.  */

/********Insertion function for some SIMD operands***************/
static arc_insn
insert_u8  (arc_insn insn, long * insn2 ATTRIBUTE_UNUSED,
            const struct arc_operand *operand,
            int mods ATTRIBUTE_UNUSED,
            const struct arc_operand_value *reg ATTRIBUTE_UNUSED,
            long value ATTRIBUTE_UNUSED,
            const char **errmsg ATTRIBUTE_UNUSED
           )
{

  long msb2;
  long lsb6;

  msb2 = value >> 6;
  msb2 = msb2  << 15;

  lsb6 = value & 0x3f ;

  insn |= msb2;
  insn |= (lsb6 << operand->shift);
  return insn;
}
/* Insert a signed twelve bit number into a 64 bit instruction.
 * insn is top 32 bits of instruction and gets the least significant six
 * bits in the C operand position.  The most significant six bits go to the
 * bottom of ex.  
 * insn    Top half of instruction.
 * insn2   Bottom half of instruction.
 * operand unused.
 * reg     irrevent, only used for register operands.
 * value   Signed twelve bit number.
 * errmsg  error message.
 */
static arc_insn
insert_s12  (arc_insn insn, long *ex ATTRIBUTE_UNUSED,
            const struct arc_operand *operand ATTRIBUTE_UNUSED,
            int mods ATTRIBUTE_UNUSED,
            const struct arc_operand_value *reg ATTRIBUTE_UNUSED,
            long value ATTRIBUTE_UNUSED,
            const char **errmsg ATTRIBUTE_UNUSED
           )
{

  long msb6;
  long lsb6;

  msb6 = (value >> 6) & 0x3f;
  lsb6 = (value & 0x3f) << 6 ;

  insn |= lsb6;
  if(ex)
      *ex |= msb6;
  return insn;
}
/* Insert an unsigned sixteen bit number into a 64 bit instruction.
 * insn is top 32 bits of instruction and gets the least significant six
 * bits in the C operand position.  The most significant six bits go to the
 * bottom of ex.  
 * insn    Top half of instruction.
 * insn2   Bottom half of instruction.
 * operand unused.
 * reg     irrevent, only used for register operands.
 * value   Signed twelve bit number.
 * errmsg  error message.
 */
static arc_insn
insert_u16  (arc_insn insn, long *ex ATTRIBUTE_UNUSED,
            const struct arc_operand *operand ATTRIBUTE_UNUSED,
            int mods ATTRIBUTE_UNUSED,
            const struct arc_operand_value *reg ATTRIBUTE_UNUSED,
            long value ATTRIBUTE_UNUSED,
            const char **errmsg ATTRIBUTE_UNUSED
           )
{

  long msb6;
  long lsb6;

  msb6 = (value >> 6) & 0x3ff;
  lsb6 = (value & 0x3f) << 6 ;

  insn |= lsb6;
  if(ex)
      *ex |= msb6;
  return insn;
}
/* Insert upper half of unsigned sixteen bit number into a 64 bit instruction.
 * insn is top 32 bits of instruction and gets the least significant six
 * bits in the C operand position.  The most significant six bits go to the
 * bottom of ex.  
 * insn    Top half of instruction.
 * insn2   Bottom half of instruction.
 * operand unused.
 * reg     irrevent, only used for register operands.
 * value   Signed twelve bit number.
 * errmsg  error message.
 */
static arc_insn
insert_uu16  (arc_insn insn, long *ex ATTRIBUTE_UNUSED,
            const struct arc_operand *operand ATTRIBUTE_UNUSED,
            int mods ATTRIBUTE_UNUSED,
            const struct arc_operand_value *reg ATTRIBUTE_UNUSED,
            long value ATTRIBUTE_UNUSED,
            const char **errmsg ATTRIBUTE_UNUSED
           )
{

  long msb8;

  msb8 = (value & 0xff) << 2;
  if(ex)
      *ex |= msb8;
  return insn;
}
/* Insert lower eight bits of unsigned sixteen bit number into a 64 bit 
 * instruction.
 * insn is top 32 bits of instruction and gets the least significant six
 * bits in the C operand position.  The most significant six bits go to the
 * bottom of ex.  
 * insn    Top half of instruction.
 * insn2   Bottom half of instruction.
 * operand unused.
 * reg     irrevent, only used for register operands.
 * value   Signed twelve bit number.
 * errmsg  error message.
 */
static arc_insn
insert_ul16  (arc_insn insn, long *ex ATTRIBUTE_UNUSED,
            const struct arc_operand *operand ATTRIBUTE_UNUSED,
            int mods ATTRIBUTE_UNUSED,
            const struct arc_operand_value *reg ATTRIBUTE_UNUSED,
            long value ATTRIBUTE_UNUSED,
            const char **errmsg ATTRIBUTE_UNUSED
           )
{

  long msb2;
  long lsb6;

  msb2 = (value >> 6) & 0x3;
  lsb6 = (value & 0x3f) << 6 ;

  insn |= lsb6;
  if(ex)
      *ex |= msb2;
  return insn;
}
/* Insert 15 bits of signed number into a 64 bit instruction.
 * insn is top 32 bits of instruction and is unchanged.
 * insn    Top half of instruction.
 * insn2   Bottom half of instruction, receives value in lower 15 bits.
 * operand unused.
 * reg     irrevent, only used for register operands.
 * value   Signed twelve bit number.
 * errmsg  error message.
 */
static arc_insn
insert_s15  (arc_insn insn, long *ex ATTRIBUTE_UNUSED,
            const struct arc_operand *operand ATTRIBUTE_UNUSED,
            int mods ATTRIBUTE_UNUSED,
            const struct arc_operand_value *reg ATTRIBUTE_UNUSED,
            long value ATTRIBUTE_UNUSED,
            const char **errmsg ATTRIBUTE_UNUSED
           )
{

  if(ex)
      *ex |= (value & 0x7fff);
  return insn;
}
/* Discarded field.
 * insn is top 32 bits of instruction and gets the least significant six
 * bits in the C operand position.  The most significant six bits go to the
 * bottom of ex.  
 * insn    Top half of instruction.
 * insn2   Bottom half of instruction.
 * operand unused.
 * reg     irrevent, only used for register operands.
 * value   Signed twelve bit number.
 * errmsg  error message.
 */
static arc_insn
insert_null  (arc_insn insn, long *ex ATTRIBUTE_UNUSED,
            const struct arc_operand *operand ATTRIBUTE_UNUSED,
            int mods ATTRIBUTE_UNUSED,
            const struct arc_operand_value *reg ATTRIBUTE_UNUSED,
            long value ATTRIBUTE_UNUSED,
            const char **errmsg ATTRIBUTE_UNUSED
           )
{
  return insn;
}

d332 1
a332 1
insert_reg (arc_insn insn,long *ex ATTRIBUTE_UNUSED,
d341 1
d349 1
a349 1
      if (arc_mach_a4 && ARC_SHIMM_CONST_P (value)
d351 1
a351 1
	  && !arc_cond_p
a375 26
      else if ((mods & ARC_MOD_SDASYM) && !ac_add_reg_sdasym_insn (insn))
	{
	  /* If it is an ld/ldw/st/stw insn without any .aa suffixes, then
	     make it a scaled instruction, i.e. set .aa field to 3 */
	  if (addrwb_p == 0)
	    {
	      /* Check for ld with .aa=0 */
	      if ((insn & 0xf8000000) == 0x10000000)
		{
		  /* if an ld/ldw insn */
		  if ((((insn >> 7) & 3) == 0) ||
		      (((insn >> 7) & 3) == 2))
		    /* Set .aa to 3 */
		    addrwb_p =  0x600;
		}
	      /* Check for st with .aa=0 */
	      else if ((insn & 0xf8000001) == 0x18000000)
		{
		  /* if an st/stw insn */
		  if ((((insn >> 1) & 3) == 0) ||
		  (((insn >> 1) & 3) == 2))
		    /* Set .aa to 3 */
		    addrwb_p = 0x18;
		}
	    } /* addrwb_p == 0 */
	}
d379 5
a383 15
	    if ('a' != operand->fmt)
	      {
		op_type = OP_LIMM;
		limm_p = 1;
		limm = value;
		if (arc_mach_a4)
		  insn |= ARC_REG_LIMM << operand->shift;
		/* The constant is stored later.  */
	      }
	    else
	      {
		if (arc_mach_a4)
		  insn |= ARC_REG_SHIMM << operand->shift;
		/* insn |= value & 511; - done later.  */
	      }
d385 1
a385 1
      else{
a386 1
          }
d392 1
a392 1
      if ((reg->type == AUXREG) || (reg->type == AUXREG_AC))
d396 1
a396 1
	  else if (arc_mach_a4)
a410 12
	  else /* Insert auxiliary register value for ARCompact ISA.  */
	    {
	      /* TODO: Check for validity of using ARCompact auxiliary regs.  */

	      //	      insn |= reg->value << operand->shift;
	      /* Replace this later with the corresponding function to do
		 the insertion of signed 12 bit immediates .
		 This is because the auxillary registers used as a mnemonic
		 would be stored in this fashion.  */

	      insn |= (((reg->value & 0x3f) << 6) | ((reg->value & 0xffffffc0) >> 6));
	    }
d414 3
a416 4
          /* Check for use validity.  */
          if (('a' == operand->fmt) || (arc_mach_a4 && ((insn & I(-1)) < I(2))) ||
              (!arc_mach_a4 && (('A' == operand->fmt)||('#' == operand->fmt))))
            {
d419 3
a421 3
            }
          if ('a' != operand->fmt || (!arc_mach_a4 && ('A' != operand->fmt)))
            {
d426 1
a426 6
	  if (arc_mach_a4 && ((unsigned int) reg->value > 60))
	    {
	      sprintf (buf, _("invalid register number `%d'"), reg->value);
	      *errmsg = buf;
	    }
	  if (!arc_mach_a4 && ((unsigned int) reg->value > 63))
d431 2
a432 25
          if (!arc_mach_a4 && (   ('B' == operand->fmt) || ('#' == operand->fmt)
			   || ('g' == operand->fmt) || ('(' == operand->fmt)
			   || ('{' == operand->fmt) || ('<' == operand->fmt)))
	    {
	      insn |= (reg->value & 0x7) << operand->shift;
	      insn |= (reg->value >> 3) << ARC_SHIFT_REGB_HIGH_AC;
	    }
          else if (!arc_mach_a4 && ('U' == operand->fmt))
            {
	      insn |= (reg->value & 0x7) << operand->shift;
	      insn |= reg->value >> 3;

	      /* Ravi: Quoting from the ARC Programmer reference:
		 The program counter (PCL) is not permitted to be the
		 destination of an instruction.  A value of in 0x03 in the
		 sub opcode field, i, and a value of 0x3F in destination
		 register field, H, will raise an Instruction Error
		 exception.
		 This should solve the mov_s pcl, whatever bug.  */
	      if ((insn & 0xFF) == 0xFF)
		*errmsg = _("attempt to set readonly register");
            }
          else
	    insn |= reg->value << operand->shift;
          op_type = OP_REG;
d436 1
a436 1
  if (arc_mach_a4)
d438 15
a452 39
      switch (operand->fmt)
        {
	case 'a':
	  ls_operand[LS_DEST] = op_type;
	  break;
	case 's':
	  ls_operand[LS_BASE] = op_type;
	  break;
	case 'c':
	  if ((insn & I(-1)) == I(2))
	    ls_operand[LS_VALUE] = op_type;
	  else
	    ls_operand[LS_OFFSET] = op_type;
	  break;
	case 'o': case 'O':
	  ls_operand[LS_OFFSET] = op_type;
	  break;
	}
    }
  else
    {
      switch (operand->fmt)
        {
        case 'a':
        case 'A':
        case '#':
        case '*':
          ls_operand[LS_DEST] = op_type;
          break;
        case 'C':
        case ')':
        case '}':
        case '>':
          if ((insn & I(-1)) == I(3))
            ls_operand[LS_VALUE] = op_type;
          else
            ls_operand[LS_OFFSET] = op_type;
          break;
        }
d454 1
d461 1
a461 1
insert_flag (arc_insn insn, long *ex ATTRIBUTE_UNUSED,
d478 1
a478 1
insert_nullify (arc_insn insn,long *ex ATTRIBUTE_UNUSED,
d496 1
a496 1
insert_flagfinish (arc_insn insn,long *ex ATTRIBUTE_UNUSED,
d516 1
a516 1
insert_cond (arc_insn insn,long *ex ATTRIBUTE_UNUSED,
d523 1
a523 2
  arc_cond_p = 1;

d535 1
a535 1
insert_forcelimm (arc_insn insn,long *ex ATTRIBUTE_UNUSED,
d542 1
a542 1
  arc_cond_p = 1;
d547 1
a547 1
insert_addr_wb (arc_insn insn,long *ex ATTRIBUTE_UNUSED,
d554 2
a555 12
    /* Ravi: added the 'w' to handle the st.ab st.as instructions after
     * adding suport for it in the arc_suffixes_ac by defining aw, ab and as
     * to be ADDRESS3_AC also */

    if (!arc_mach_a4 && (('p' == operand->fmt)
		      || ('P' == operand->fmt)
		      || ('w' == operand->fmt)
		      || ('&' == operand->fmt)))
      addrwb_p = value << operand->shift;
    else
      addrwb_p = 1 << operand->shift;
    return insn;
d559 1
a559 1
insert_base (arc_insn insn,long *ex ATTRIBUTE_UNUSED,
d569 2
a570 8
      if (!arc_mach_a4 && ('g' == operand->fmt))
        insn |= insert_reg (0, ex, operand,mods, reg, value, errmsg);
      else
	{
	  myinsn = (insert_reg (0, ex, operand,mods, reg, value, errmsg)
		    >> operand->shift);
	  insn |= B (myinsn);
	}
d573 1
a573 1
  else if (arc_mach_a4 && ARC_SHIMM_CONST_P (value) && !arc_cond_p)
d590 1
a590 1
  else if (arc_mach_a4)
d607 1
a607 1
   match operand syntax here.  We catch bad combinations later.  */
d610 1
a610 1
insert_offset (arc_insn insn,long *ex ATTRIBUTE_UNUSED,
d621 2
a622 14
      if (arc_mach_a4)
        {
	  arc_insn myinsn
	    = (insert_reg (0, ex, operand, mods, reg, value, errmsg)
	       >> operand->shift);

	  /* Not if store, catch it later.  */
	  if (operand->flags & ARC_OPERAND_LOAD)
	    /* Not if opcode == 1, catch it later.  */
	    if ((insn & I(-1)) != I(1))
	      insn |= C(myinsn);
        }
      else
        insn |= insert_reg (0, ex, operand, mods, reg, value, errmsg);
d624 3
a629 9
      int bits;

      if (operand->flags & ARC_OPERAND_2BYTE_ALIGNED)
	bits = operand->bits + 1;
      else if (operand->flags & ARC_OPERAND_4BYTE_ALIGNED)
	bits = operand->bits + 2;
      else
	bits = operand->bits;

d634 2
a635 2
	  minval = -(1 << (bits - 1));
	  maxval = (1 << (bits - 1)) - 1;
d640 1
a640 1
	  maxval = (1 << bits) - 1;
d642 1
a642 1
      if (arc_mach_a4 && ((arc_cond_p && !limm_p) || value < minval || value > maxval))
d646 1
d661 2
a662 2
	    *errmsg = _("need too many limms");
	  else if (arc_mach_a4 && shimm_p && value != shimm)
d668 1
a668 1
		  *errmsg = _("to many shimms in load");
a693 25
	  if (!arc_mach_a4)
	    {
	      switch (operand->fmt)
		{
		case 'o':
		  insn |= ((value & 0xff) << operand->shift);
		  insn |= (((value & 0x100) >> 8) << 15);
		  break;
		case 'k':
		  insn |= ((value >> 1) & 0x1f) << operand->shift;
		  break;
		case 'm':
		  insn |= ((value >> 2) & 0xff) << operand->shift;
		  break;
		case 'M':
		  insn |= (value & 0x1ff) << operand->shift;
		  break;
		case 'O':
		  insn |= ((value >> 1) & 0x1ff) << operand->shift;
		  break;
		case 'R':
		  insn |= ((value >> 2) & 0x1ff) << operand->shift;
		  break;
		}
	    }
a740 1

d754 1
a754 1
insert_st_syntax (arc_insn insn,long *ex ATTRIBUTE_UNUSED,
d761 1
a761 16
  /* do syntax check for ARCompact 'st' insn */
  if (!arc_mach_a4)
    {
      /* TODO - check for validity of operands for ARCompact store insn */

      if (addrwb_p)
        {
          if (ls_operand[LS_BASE] != OP_REG)
            *errmsg = _("address writeback not allowed");
          insn |= addrwb_p;
        }
      return insn;
    }

  /* Do syntax check for ARCtangent-A4 'st' insn.  */
  if (ST_SYNTAX (OP_SHIMM, OP_REG, OP_NONE) && shimm != 0)
d769 1
a769 1
      insn= insn & ~(C(-1) | 511);
d782 1
d799 4
a802 11
  if (ST_SYNTAX (OP_SHIMM, OP_LIMM, OP_NONE))
    limm += arc_limm_fixup_adjust (insn);
  if (ST_SYNTAX (OP_LIMM, OP_SHIMM, OP_SHIMM) && (shimm * 2 == limm))
    {
      insn &= ~C (-1);
      limm_p = 0;
      limm = 0;
      insn |= C (ARC_REG_SHIMM);
      ls_operand[LS_VALUE] = OP_SHIMM;
    }
  if (!(   ST_SYNTAX (OP_REG,OP_REG,OP_NONE)
d829 1
a829 1
insert_ld_syntax (arc_insn insn,long *ex ATTRIBUTE_UNUSED,
a840 1
#define X(x,b,m) ((unsigned)((x)&(((1<<m)-1)<<b))>>b)
a842 41
  /* do syntax check for ARCompact 'ld' insn */
  if (!arc_mach_a4)
    {
      /* TODO - check for validity of operands for ARCompact load insn */

      /* Extract operand 6 bits of the A field from insn starting at bit
         position 0.  */
      unsigned char ac_reg_num = X(insn,0,6);

      if (addrwb_p)
	{
	  if (ls_operand[LS_BASE] != OP_REG
	      /* .as is not actually an address write-back.  */
	      && addrwb_p != 0xc00000)
	    *errmsg = _("address writeback not allowed");
	  insn |= addrwb_p;
	}

      /* Fixme: We should hash define register names to their respective
         numbers and not use them as 29, 30, 31,....  */

      if (0x20 <= ac_reg_num && ac_reg_num <= 0x3F)
	{
	  if (!((arc_ld_ext_mask >> (ac_reg_num - 32)) & 1))
	    *errmsg = _("ld operand error: Instruction Error exception");
	}

      /* Ravi: operand validity checks for the ARC700 */
      if (cpu_type == ARC_MACH_ARC7 && arc_user_mode_only)
      /* if (arc_get_opcode_mach (arc_mach_type, 0) == ARC_MACH_ARC7) */
	{
	  if (ac_reg_num == 29 || ac_reg_num == 30)
	    {
	      *errmsg = _("ld operand error: Privilege Violation exception");
	    }
	}

      return insn;
    }

  /* do syntax check for ARCtangent-A4 'ld' insn */
d883 1
a883 1
  if (!(   (LD_SYNTAX (OP_REG, OP_REG, OP_NONE) && test == I (1))
d886 3
a888 3
	|| (LD_SYNTAX (OP_REG, OP_REG, OP_LIMM) && test != I (1))
	|| (LD_SYNTAX (OP_REG, OP_LIMM, OP_REG) && test != I (1))
	|| (LD_SYNTAX (OP_REG, OP_SHIMM, OP_NONE) && shimm == 0)
d890 2
a891 2
	|| (LD_SYNTAX (OP_REG, OP_LIMM, OP_NONE) && test == I (1))))
       *invalid = 1;
a894 26
static arc_insn
insert_ex_syntax (arc_insn insn,long *ex ATTRIBUTE_UNUSED,
		  const struct arc_operand *operand ATTRIBUTE_UNUSED,
		  int mods ATTRIBUTE_UNUSED,
		  const struct arc_operand_value *reg ATTRIBUTE_UNUSED,
		  long value ATTRIBUTE_UNUSED,
		  const char **errmsg)
{
  /* Ravi: operand validity checks for the ARC700 */
  if (cpu_type == ARC_MACH_ARC7)
  /* if (arc_get_opcode_mach (arc_mach_type, 0) == ARC_MACH_ARC7) */
    {
      unsigned ac_reg_hi = X (insn, 12, 3);
      unsigned ac_reg_lo = X (insn, 24, 3);
      unsigned ac_reg_num = (ac_reg_hi << 3) | ac_reg_lo;

      if (arc_user_mode_only && (ac_reg_num == 29 || ac_reg_num == 30))
	*errmsg = _("ex operand error: Privilege Violation exception");
      if (0x20 <= ac_reg_num && ac_reg_num <= 0x3F
	  && !((arc_ld_ext_mask >> (ac_reg_num - 32)) & 1))
	*errmsg = _("ld operand error: Instruction Error exception");
    }
  return insn;
}


d899 1
a899 1
insert_shimmfinish (arc_insn insn,long *ex ATTRIBUTE_UNUSED,
d924 1
a924 1
insert_limmfinish (arc_insn insn,long *ex ATTRIBUTE_UNUSED,
d935 1
a935 1
insert_jumpflags (arc_insn insn,long *ex ATTRIBUTE_UNUSED,
d966 1
a966 1
insert_unopmacro (arc_insn insn,long *ex ATTRIBUTE_UNUSED,
d980 1
a980 1
insert_reladdr (arc_insn insn,long *ex ATTRIBUTE_UNUSED,
d987 3
a989 88
  if (!arc_mach_a4 && ('h' == operand->fmt))
    {
      if (value & 3)
	*errmsg = _("branch address not on 4 byte boundary");

      value = value >> 2;
      /* Insert least significant 9-bits.  */
      insn |= (value & 0x1ff) << operand->shift;
      /* Insert most significant 10-bits.  */
      insn |= ((value >> 9) & 0x3ff) << 6;
    }
  else if (!arc_mach_a4 && ('H' == operand->fmt))
    {
      if (value & 3)
	*errmsg = _("branch address not on 4 byte boundary");

      value = value >> 2;
      /* Insert least significant 9-bits.  */
      insn |= (value & 0x1ff) << operand->shift;
      /* Insert next least significant 10-bits.  */
      insn |= ((value >> 9) & 0x3ff) << 6;
      /* Insert most significant 4-bits.  */
      insn |= (value >> 19) & 0xf;
    }
  else if (!arc_mach_a4 && ('i' == operand->fmt))
    {
      if (value & 1)
	*errmsg = _("branch address not on 2 byte boundary");

      value = value >> 1;
      /* Insert least significant 10-bits.  */
      insn |= (value & 0x3ff) << operand->shift;
      /* Insert most significant 10-bits.  */
      insn |= ((value >> 10) & 0x3ff) << 6;
    }
  else if (!arc_mach_a4 && ('I' == operand->fmt))
    {
      if (value & 1)
	*errmsg = _("branch address not on 2 byte boundary");

      value = value >> 1;
      /* Insert least significant 10-bits.  */
      insn |= (value & 0x3ff) << operand->shift;
      /* Insert next least significant 10-bits.  */
      insn |= ((value >> 10) & 0x3ff) << 6;
      /* Insert most significant 4-bits.  */
      insn |= (value >> 20) & 0xf;
    }
  else if (!arc_mach_a4 && ('d' == operand->fmt))
    {
      /* Insert least significant 7-bits.  */
      insn |= ((value >> 1) & 0x7f) << operand->shift;
      /* Insert most significant bit.  */
      insn |= (((value >> 1) & 0x80) >> 7) << 15;
    }
  else if (!arc_mach_a4 && ('y' == operand->fmt))
    {
      /* Insert most significant 6-bits of 7-bit unsigned immediate value.  */
      insn |= ((value >> 1) & 0x3f) << operand->shift;
    }
  else if (!arc_mach_a4 && ('Y' == operand->fmt))
    {
      /* Insert bit-1 to bit-6 of 13-bit signed immediate value.  */
      insn |= ((value >> 1) & 0x3f) << operand->shift;
      /* Insert bit-7 to bit-13 of 13-bit signed immediate value.  */
      insn |= ((value >> 1) & 0xfc0) >> 6;
    }
  else if (!arc_mach_a4 && (('s' == operand->fmt) || ('S' == operand->fmt)
			|| ('Z' == operand->fmt)))
    {
      if (value & 1)
	*errmsg = _("branch address not on 2 byte boundary");
      insn |= ((value >> 1) & ((1 << operand->bits) - 1)) << operand->shift;
    }
  else if (!arc_mach_a4 && ('W' == operand->fmt))
    {
      if (value & 3)
	*errmsg = _("branch address not on 4 byte boundary");
      insn |= ((value >> 2) & ((1 << operand->bits) - 1)) << operand->shift;
    }
  else
    {
      /* for ARCtangent-A4 */

      if (value & 3)
	*errmsg = _("branch address not on 4 byte boundary");
      insn |= ((value >> 2) & ((1 << operand->bits) - 1)) << operand->shift;
    }
d1008 1
a1008 1
insert_absaddr (arc_insn insn,long *ex ATTRIBUTE_UNUSED,
d1022 1
d1058 1
a1058 1
  if (type == REG || type == REG_AC)
d1164 1
a1164 1
  switch (operand->fmt)
a1257 1

d1311 1
a1311 1
  int value = 0;
a1345 1

d1357 1
a1357 1
   insn is really the `and' insn.
d1359 3
a1361 16
   This table is best viewed on a wide screen (161 columns).  I'd prefer to
   keep it this way.  The rest of the file, however, should be viewable on an
   80 column terminal.  */

/* ??? This table also includes macros: asl, lsl, and mov.  The ppc port has
   a more general facility for dealing with macros which could be used if
   we need to.  */

/* This table can't be `const' because members `next_asm' and `next_dis' are
   computed at run-time.  We could split this into two, but that doesn't seem
   worth it.  */

static struct arc_opcode arc_opcodes[] = {

  /* Base case instruction set (ARC4, ARC5, ARC6, ARC7).  */
  /* Macros appear first.  */
d1364 1
a1364 1
  { "mov%.q%.f %a,%b%F%S%L%U", I(-1), I(12), ARC_MACH_ARC4, 0, 0 ,0,0},
d1366 1
a1366 1
  { "asl%.q%.f %a,%b%F%S%L%U", I(-1), I(8), ARC_MACH_ARC4, 0, 0 ,0,0},
d1368 1
a1368 1
  { "lsl%.q%.f %a,%b%F%S%L%U", I(-1), I(8), ARC_MACH_ARC4, 0, 0 ,0,0},
d1370 1
a1370 1
  { "nop", 0xffffffff, 0x7fffffff, ARC_MACH_ARC4, 0, 0 ,0,0},
d1372 18
a1389 19
  { "rlc%.q%.f %a,%b%F%S%L%U", I(-1), I(9), ARC_MACH_ARC4, 0, 0 ,0,0},

  /* The rest of these needn't be sorted, but it helps to find them if they are.  */
  { "adc%.q%.f %a,%b,%c%F%S%L", I(-1), I(9), ARC_MACH_ARC4, 0, 0 ,0,0},
  { "add%.q%.f %a,%b,%c%F%S%L",	I(-1), I(8), ARC_MACH_ARC4, 0, 0 ,0,0},
  { "and%.q%.f %a,%b,%c%F%S%L",	I(-1), I(12), ARC_MACH_ARC4, 0, 0 ,0,0},
  { "asr%.q%.f %a,%b%F%S%L", I(-1)|C(-1), I(3)|C(1), ARC_MACH_ARC4, 0, 0 ,0,0},
  { "bic%.q%.f %a,%b,%c%F%S%L",	I(-1), I(14), ARC_MACH_ARC4, 0, 0 ,0,0},
  { "b%q%.n %B", I(-1),	I(4), ARC_MACH_ARC4 | ARC_OPCODE_COND_BRANCH, 0, 0 ,0,0},
  { "bl%q%.n %B", I(-1), I(5), ARC_MACH_ARC4 | ARC_OPCODE_COND_BRANCH, 0, 0 ,0,0},
  { "brk", 0x1ffffe00, 0x1ffffe00, ARC_MACH_ARC4, 0, 0 ,0,0},
  { "extb%.q%.f %a,%b%F%S%L", I(-1)|C(-1), I(3)|C(7), ARC_MACH_ARC4, 0, 0 ,0,0},
  { "extw%.q%.f %a,%b%F%S%L", I(-1)|C(-1), I(3)|C(8), ARC_MACH_ARC4, 0, 0 ,0,0},
  { "flag%.q %b%G%S%L",	I(-1)|A(-1)|C(-1), I(3)|A(ARC_REG_SHIMM_UPDATE)|C(0), ARC_MACH_ARC4, 0, 0 ,0,0},

  /* %Q: force arc_cond_p=1 --> no shimm values */
  /* This insn allows an optional flags spec.  */
  { "j%q%Q%.n%.f %b%F%J,%j", I(-1)|A(-1)|C(-1)|R(-1,7,1), I(7)|A(0)|C(0)|R(0,7,1), ARC_MACH_ARC4 | ARC_OPCODE_COND_BRANCH, 0, 0 ,0,0},
  { "j%.q%Q%.n%.f %b%F%J", I(-1)|A(-1)|C(-1)|R(-1,7,1), I(7)|A(0)|C(0)|R(0,7,1), ARC_MACH_ARC4 | ARC_OPCODE_COND_BRANCH, 0, 0 ,0,0},
d1391 18
a1408 19
  { "jl%q%Q%.n%.f %b%F%J,%j", I(-1)|A(-1)|C(-1)|R(-1,7,1)|R(-1,9,1), I(7)|A(0)|C(0)|R(0,7,1)|R(1,9,1), ARC_MACH_ARC4 | ARC_OPCODE_COND_BRANCH, 0, 0 ,0,0},
  { "jl%q%Q%.n%.f %b%F%J", I(-1)|A(-1)|C(-1)|R(-1,7,1)|R(-1,9,1), I(7)|A(0)|C(0)|R(0,7,1)|R(1,9,1), ARC_MACH_ARC4 | ARC_OPCODE_COND_BRANCH, 0, 0 ,0,0},
  /* Put opcode 1 ld insns first so shimm gets prefered over limm.  */
  /* "[%b]" is before "[%b,%o]" so 0 offsets don't get printed.  */
  { "ld%Z%.X%.W%.E %a,[%s]%S%L%1", I(-1)|R(-1,13,1)|R(-1,0,511), I(1)|R(0,13,1)|R(0,0,511), ARC_MACH_ARC4, 0, 0 ,0,0},
  { "ld%z%.x%.w%.e %a,[%s]%S%L%1", I(-1)|R(-1,4,1)|R(-1,6,7), I(0)|R(0,4,1)|R(0,6,7), ARC_MACH_ARC4, 0, 0 ,0,0},
  { "ld%z%.x%.w%.e %a,[%s,%O]%S%L%1", I(-1)|R(-1,4,1)|R(-1,6,7), I(0)|R(0,4,1)|R(0,6,7), ARC_MACH_ARC4, 0, 0 ,0,0},
  { "ld%Z%.X%.W%.E %a,[%s,%O]%S%L%3", I(-1)|R(-1,13,1),	I(1)|R(0,13,1), ARC_MACH_ARC4, 0, 0 ,0,0},
  { "lp%q%.n %B", I(-1), I(6), ARC_MACH_ARC4, 0, 0 ,0,0},
  { "lr %a,[%Ab]%S%L", I(-1)|C(-1), I(1)|C(0x10), ARC_MACH_ARC4, 0, 0 ,0,0},
  { "lsr%.q%.f %a,%b%F%S%L", I(-1)|C(-1), I(3)|C(2), ARC_MACH_ARC4, 0, 0 ,0,0},
  { "or%.q%.f %a,%b,%c%F%S%L", I(-1), I(13), ARC_MACH_ARC4, 0, 0 ,0,0},
  { "ror%.q%.f %a,%b%F%S%L", I(-1)|C(-1), I(3)|C(3), ARC_MACH_ARC4, 0, 0 ,0,0},
  { "rrc%.q%.f %a,%b%F%S%L", I(-1)|C(-1), I(3)|C(4), ARC_MACH_ARC4, 0, 0 ,0,0},
  { "sbc%.q%.f %a,%b,%c%F%S%L", I(-1), I(11), ARC_MACH_ARC4, 0, 0 ,0,0},
  { "sexb%.q%.f %a,%b%F%S%L", I(-1)|C(-1), I(3)|C(5), ARC_MACH_ARC4, 0, 0 ,0,0},
  { "sexw%.q%.f %a,%b%F%S%L", I(-1)|C(-1), I(3)|C(6), ARC_MACH_ARC4, 0, 0 ,0,0},
  { "sleep", 0x1ffffe01, 0x1ffffe01, ARC_MACH_ARC4, 0, 0 ,0,0},
  { "sr %c,[%Ab]%S%L", I(-1)|A(-1), I(2)|A(0x10), ARC_MACH_ARC4, 0, 0 ,0,0},
d1410 4
a1413 1149
  { "st%y%.v%.D %c,[%s]%L%S%0", I(-1)|R(-1,25,1)|R(-1,21,1), I(2)|R(0,25,1)|R(0,21,1), ARC_MACH_ARC4, 0, 0 ,0,0},
  { "st%y%.v%.D %c,[%s,%o]%S%L%2", I(-1)|R(-1,25,1)|R(-1,21,1),	I(2)|R(0,25,1)|R(0,21,1), ARC_MACH_ARC4, 0, 0 ,0,0},
  { "sub%.q%.f %a,%b,%c%F%S%L",	I(-1), I(10), ARC_MACH_ARC4, 0, 0 ,0,0},
  { "swi", 0x1ffffe02, 0x1ffffe02, ARC_MACH_ARC4, 0, 0 ,0,0},
  { "xor%.q%.f %a,%b,%c%F%S%L",	I(-1), I(15), ARC_MACH_ARC4, 0, 0 ,0,0},

  /* ARCompact Instruction Set */

  { "abs%.f %#,%C%F", 0xf8ff003f, 0x202f0009, ARCOMPACT, 0, 0 ,0,0},
  { "abs%.f %#,%u%F", 0xf8ff003f, 0x206f0009, ARCOMPACT, 0, 0 ,0,0},
  { "abs%.f%Q %#,%L%F", 0xf8ff0fff, 0x202f0f89, ARCOMPACT, 0, 0 ,0,0},
  { "abs%.f 0,%C%F", 0xffff703f, 0x262f7009, ARCOMPACT, 0, 0 ,0,0},
  { "abs%.f 0,%u%F", 0xf8ff003f, 0x266f7009, ARCOMPACT, 0, 0 ,0,0},
  { "abs%.f%Q 0,%L%F", 0xffff7fff, 0x262f7f89, ARCOMPACT, 0, 0 ,0,0},

  { "adc%.f %A,%B,%C%F", 0xf8ff0000, 0x20010000, ARCOMPACT, 0, 0 ,0,0},
  { "adc%.f %A,%B,%u%F", 0xf8ff0000, 0x20410000, ARCOMPACT, 0, 0 ,0,0},
  { "adc%.f %#,%B,%K%F", 0xf8ff0000, 0x20810000, ARCOMPACT, 0, 0 ,0,0},
  { "adc%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x20010f80, ARCOMPACT, 0, 0 ,0,0},
  { "adc%.f%Q %A,%L,%C%F", 0xffff7000, 0x26017000, ARCOMPACT, 0, 0 ,0,0},
  { "adc%.f%Q %A,%L,%u%F", 0xffff7000, 0x26417000, ARCOMPACT, 0, 0 ,0,0},
  { "adc%.f%Q %A,%L,%L%F", 0xffff7fc0, 0x26017f80, ARCOMPACT, 0, 0 ,0,0},
  { "adc%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x20c10000, ARCOMPACT, 0, 0 ,0,0},
  { "adc%.q%.f %#,%B,%u%F", 0xf8ff00f0, 0x20c10020, ARCOMPACT, 0, 0 ,0,0},
  { "adc%.q%.f%Q %#,%B,%L%F", 0xf8ff0ff0, 0x20c10f80, ARCOMPACT, 0, 0 ,0,0},
  { "adc%.f 0,%B,%C%F", 0xf8ff00ff, 0x2001003e, ARCOMPACT, 0, 0 ,0,0},
  { "adc%.f 0,%B,%u%F", 0xf8ff003f, 0x2041003e, ARCOMPACT, 0, 0 ,0,0},
  { "adc%.f%Q 0,%B,%L%F", 0xf8ff0fff, 0x20010fbe, ARCOMPACT, 0, 0 ,0,0},
  { "adc%.f%Q 0,%L,%C%F", 0xffff703f, 0x2601703e, ARCOMPACT, 0, 0 ,0,0},
  { "adc%.f%Q 0,%L,%u%F", 0xffff703f, 0x2641703e, ARCOMPACT, 0, 0 ,0,0},
  { "adc%.f%Q 0,%L,%L%F", 0xffff7fff, 0x26017fbe, ARCOMPACT, 0, 0, 0, 0},
  { "adc%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x26c17000, ARCOMPACT, 0, 0 ,0,0},
  { "adc%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x26c17020, ARCOMPACT, 0, 0 ,0,0},
  { "adc%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x26c17f80, ARCOMPACT, 0, 0, 0, 0 },
  { "add%.f %A,%B,%C%F", 0xf8ff0000, 0x20000000, ARCOMPACT, 0, 0 ,0,0},
  { "add%.f %A,%B,%u%F", 0xf8ff0000, 0x20400000, ARCOMPACT, 0, 0 ,0,0},
  { "add%.f %#,%B,%K%F", 0xf8ff0000, 0x20800000, ARCOMPACT, 0, 0 ,0,0},
  { "add%.f%Q %A,%B,%[L%F", 0xf8ff0fc0, 0x20000f80, ARCOMPACT, 0, 0 ,0,0},
  { "add%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x20000f80, ARCOMPACT, 0, 0 ,0,0},
  { "add%.f%Q %A,%L,%C%F", 0xffff7000, 0x26007000, ARCOMPACT, 0, 0 ,0,0},
  { "add%.f%Q %A,%L,%u%F", 0xffff7000, 0x26407000, ARCOMPACT, 0, 0 ,0,0},
  { "add%.f%Q %A,%L,%L%F", 0xffff7fc0, 0x26007f80, ARCOMPACT, 0, 0 ,0,0},
  { "add%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x20c00000, ARCOMPACT, 0, 0 ,0,0},
  { "add%.q%.f %#,%B,%u%F", 0xf8ff00f0, 0x20c00020, ARCOMPACT, 0, 0 ,0,0},
  { "add%.q%.f%Q %#,%B,%L%F", 0xf8ff0fe0, 0x20c00f80, ARCOMPACT, 0, 0 ,0,0},
  { "add%.f 0,%B,%C%F", 0xf8ff003f, 0x2000003e, ARCOMPACT, 0, 0 ,0,0},
  { "add%.f 0,%B,%u%F", 0xf8ff003f, 0x2040003e, ARCOMPACT, 0, 0 ,0,0},
  { "add%.f%Q 0,%B,%L%F", 0xf8ff0fff, 0x20000fbe, ARCOMPACT, 0, 0 ,0,0},
  { "add%.f%Q 0,%L,%C%F", 0xffff703f, 0x2600703e, ARCOMPACT, 0, 0 ,0,0},
  { "add%.f%Q 0,%L,%u%F", 0xffff703f, 0x2640703e, ARCOMPACT, 0, 0 ,0,0},
  { "add%.f%Q 0,%L,%L%F", 0xffff7fff, 0x26007fbe, ARCOMPACT, 0, 0, 0, 0 },
  { "add%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x26c07000, ARCOMPACT, 0, 0 ,0,0},
  { "add%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x26c07020, ARCOMPACT, 0, 0 ,0,0},
  { "add%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x26c07f80, ARCOMPACT, 0, 0 ,0,0},
  { "add1%.f %A,%B,%C%F", 0xf8ff0000, 0x20140000, ARCOMPACT, 0, 0 ,0,0},
  { "add1%.f %A,%B,%u%F", 0xf8ff0000, 0x20540000, ARCOMPACT, 0, 0 ,0,0},
  { "add1%.f %#,%B,%K%F", 0xf8ff0000, 0x20940000, ARCOMPACT, 0, 0 ,0,0},
  { "add1%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x20140f80, ARCOMPACT, 0, 0 ,0,0},
  { "add1%.f%Q %A,%L,%C%F", 0xffff7000, 0x26147000, ARCOMPACT, 0, 0 ,0,0},
  { "add1%.f%Q %A,%L,%u%F", 0xffff7000, 0x26547000, ARCOMPACT, 0, 0 ,0,0},
  { "add1%.f%Q %A,%L,%L%F", 0xffff7fc0, 0x26147f80, ARCOMPACT, 0, 0 ,0,0},
  { "add1%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x20d40000, ARCOMPACT, 0, 0 ,0,0},
  { "add1%.q%.f %#,%B,%u%F", 0xf8ff00f0, 0x20d40020, ARCOMPACT, 0, 0 ,0,0},
  { "add1%.q%.f%Q %#,%B,%L%F", 0xf8ff0ff0, 0x20d40f80, ARCOMPACT, 0, 0 ,0,0},
  { "add1%.f 0,%B,%C%F", 0xf8ff003f, 0x2014003e, ARCOMPACT, 0, 0 ,0,0},
  { "add1%.f 0,%B,%u%F", 0xf8ff003f, 0x2054003e, ARCOMPACT, 0, 0 ,0,0},
  { "add1%.f%Q 0,%B,%L%F", 0xf8ff0fff, 0x20140fbe, ARCOMPACT, 0, 0 ,0,0},
  { "add1%.f%Q 0,%L,%C%F", 0xffff703f, 0x2614703e, ARCOMPACT, 0, 0 ,0,0},
  { "add1%.f%Q 0,%L,%u%F", 0xffff703f, 0x2654703e, ARCOMPACT, 0, 0 ,0,0},
  { "add1%.f%Q 0,%L,%L%F", 0xffff7fff, 0x26147fbe, ARCOMPACT, 0, 0 ,0,0},
  { "add1%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x26d47000, ARCOMPACT, 0, 0 ,0,0},
  { "add1%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x26d47020, ARCOMPACT, 0, 0 ,0,0},
  { "add1%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x26d47f80, ARCOMPACT, 0, 0 ,0,0},
  { "add2%.f %A,%B,%C%F", 0xf8ff0000, 0x20150000, ARCOMPACT, 0, 0 ,0,0},
  { "add2%.f %A,%B,%u%F", 0xf8ff0000, 0x20550000, ARCOMPACT, 0, 0 ,0,0},
  { "add2%.f %#,%B,%K%F", 0xf8ff0000, 0x20950000, ARCOMPACT, 0, 0 ,0,0},
  { "add2%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x20150f80, ARCOMPACT, 0, 0 ,0,0},
  { "add2%.f%Q %A,%L,%C%F", 0xffff7000, 0x26157000, ARCOMPACT, 0, 0 ,0,0},
  { "add2%.f%Q %A,%L,%u%F", 0xffff7000, 0x26557000, ARCOMPACT, 0, 0 ,0,0},
  { "add2%.f%Q %A,%L,%L%F", 0xffff7fc0, 0x26157f80, ARCOMPACT, 0, 0 ,0,0},
  { "add2%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x20d50000, ARCOMPACT, 0, 0 ,0,0},
  { "add2%.q%.f %#,%B,%u%F", 0xf8ff00f0, 0x20d50020, ARCOMPACT, 0, 0 ,0,0},
  { "add2%.q%.f%Q %#,%B,%L%F", 0xf8ff0ff0, 0x20d50f80, ARCOMPACT, 0, 0 ,0,0},
  { "add2%.f 0,%B,%C%F", 0xf8ff003f, 0x2015003e, ARCOMPACT, 0, 0 ,0,0},
  { "add2%.f 0,%B,%u%F", 0xf8ff003f, 0x2055003e, ARCOMPACT, 0, 0 ,0,0},
  { "add2%.f%Q 0,%B,%L%F", 0xf8ff0fff, 0x20150fbe, ARCOMPACT, 0, 0 ,0,0},
  { "add2%.f%Q 0,%L,%C%F", 0xffff703f, 0x2615703e, ARCOMPACT, 0, 0 ,0,0},
  { "add2%.f%Q 0,%L,%u%F", 0xffff703f, 0x2655703e, ARCOMPACT, 0, 0 ,0,0},
  { "add2%.f%Q 0,%L,%L%F", 0xffff7fff, 0x26157fbe, ARCOMPACT, 0, 0 ,0,0},
  { "add2%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x26d57000, ARCOMPACT, 0, 0 ,0,0},
  { "add2%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x26d57020, ARCOMPACT, 0, 0 ,0,0},
  { "add2%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x26d57f80, ARCOMPACT, 0, 0 ,0,0},
  { "add3%.f %A,%B,%C%F", 0xf8ff0000, 0x20160000, ARCOMPACT, 0, 0 ,0,0},
  { "add3%.f %A,%B,%u%F", 0xf8ff0000, 0x20560000, ARCOMPACT, 0, 0 ,0,0},
  { "add3%.f %#,%B,%K%F", 0xf8ff0000, 0x20960000, ARCOMPACT, 0, 0 ,0,0},
  { "add3%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x20160f80, ARCOMPACT, 0, 0 ,0,0},
  { "add3%.f%Q %A,%L,%C%F", 0xffff7000, 0x26167000, ARCOMPACT, 0, 0 ,0,0},
  { "add3%.f%Q %A,%L,%u%F", 0xffff7000, 0x26567000, ARCOMPACT, 0, 0 ,0,0},
  { "add3%.f%Q %A,%L,%L%F", 0xffff7fc0, 0x26167f80, ARCOMPACT, 0, 0 ,0,0},
  { "add3%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x20d60000, ARCOMPACT, 0, 0 ,0,0},
  { "add3%.q%.f %#,%B,%u%F", 0xf8ff00f0, 0x20d60020, ARCOMPACT, 0, 0 ,0,0},
  { "add3%.q%.f%Q %#,%B,%L%F", 0xf8ff0ff0, 0x20d60f80, ARCOMPACT, 0, 0 ,0,0},
  { "add3%.f 0,%B,%C%F", 0xf8ff003f, 0x2016003e, ARCOMPACT, 0, 0 ,0,0},
  { "add3%.f 0,%B,%u%F", 0xf8ff003f, 0x2056003e, ARCOMPACT, 0, 0 ,0,0},
  { "add3%.f%Q 0,%B,%L%F", 0xf8ff0fff, 0x20160fbe, ARCOMPACT, 0, 0 ,0,0},
  { "add3%.f%Q 0,%L,%C%F", 0xffff703f, 0x2616703e, ARCOMPACT, 0, 0 ,0,0},
  { "add3%.f%Q 0,%L,%u%F", 0xffff703f, 0x2656703e, ARCOMPACT, 0, 0 ,0,0},
  { "add3%.f%Q 0,%L,%L%F", 0xffff7fff, 0x26167fbe, ARCOMPACT, 0, 0 ,0,0},
  { "add3%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x26d67000, ARCOMPACT, 0, 0 ,0,0},
  { "add3%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x26d67020, ARCOMPACT, 0, 0 ,0,0},
  { "add3%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x26d67f80, ARCOMPACT, 0, 0 ,0,0},

  { "and%.f %A,%B,%C%F", 0xf8ff0000, 0x20040000, ARCOMPACT, 0, 0 ,0,0},
  { "and%.f %A,%B,%u%F", 0xf8ff0000, 0x20440000, ARCOMPACT, 0, 0 ,0,0},
  { "and%.f %#,%B,%K%F", 0xf8ff0000, 0x20840000, ARCOMPACT, 0, 0 ,0,0},
  { "and%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x20040f80, ARCOMPACT, 0, 0 ,0,0},
  { "and%.f%Q %A,%L,%C%F", 0xffff7000, 0x26047000, ARCOMPACT, 0, 0 ,0,0},
  { "and%.f%Q %A,%L,%u%F", 0xffff7000, 0x26447000, ARCOMPACT, 0, 0 ,0,0},
  { "and%.f%Q %A,%L,%L%F", 0xffff7fc0, 0x26047f80, ARCOMPACT, 0, 0 ,0,0},
  { "and%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x20c40000, ARCOMPACT, 0, 0 ,0,0},
  { "and%.q%.f %#,%B,%u%F", 0xf8ff00f0, 0x20c40020, ARCOMPACT, 0, 0 ,0,0},
  { "and%.q%.f%Q %#,%B,%L%F", 0xf8ff0fe0, 0x20c40f80, ARCOMPACT, 0, 0 ,0,0},
  { "and%.f 0,%B,%C%F", 0xf8ff003f, 0x2004003e, ARCOMPACT, 0, 0 ,0,0},
  { "and%.f 0,%B,%u%F", 0xf8ff003f, 0x2044003e, ARCOMPACT, 0, 0 ,0,0},
  { "and%.f%Q 0,%B,%L%F", 0xf8ff0fff, 0x20040fbe, ARCOMPACT, 0, 0 ,0,0},
  { "and%.f%Q 0,%L,%C%F", 0xffff703f, 0x2604703e, ARCOMPACT, 0, 0 ,0,0},
  { "and%.f%Q 0,%L,%u%F", 0xffff703f, 0x2644703e, ARCOMPACT, 0, 0 ,0,0},
  { "and%.f%Q 0,%L,%L%F", 0xffff7fff, 0x26047fbe, ARCOMPACT, 0, 0 ,0,0},
  { "and%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x26c47000, ARCOMPACT, 0, 0 ,0,0},
  { "and%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x26c47020, ARCOMPACT, 0, 0 ,0,0},
  { "and%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x26c47f80, ARCOMPACT, 0, 0 ,0,0},

  { "asl%.f %A,%B,%C%F", 0xf8ff0000, 0x28000000, ARCOMPACT, 0, 0 ,0,0},
  { "asl%.f %A,%B,%u%F", 0xf8ff0000, 0x28400000, ARCOMPACT, 0, 0 ,0,0},
  { "asl%.f %#,%B,%K%F", 0xf8ff0000, 0x28800000, ARCOMPACT, 0, 0 ,0,0},
  { "asl%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x28000f80, ARCOMPACT, 0, 0 ,0,0},
  { "asl%.f%Q %A,%L,%C%F", 0xffff7000, 0x2e007000, ARCOMPACT, 0, 0 ,0,0},
  { "asl%.f%Q %A,%L,%u%F", 0xffff7000, 0x2e407000, ARCOMPACT, 0, 0 ,0,0},
  { "asl%.f%Q %A,%L,%L%F", 0xffff7fc0, 0x2e007f80, ARCOMPACT, 0, 0 ,0,0},
  { "asl%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x28c00000, ARCOMPACT, 0, 0 ,0,0},
  { "asl%.q%.f %#,%B,%u%F", 0xf8ff0020, 0x28c00020, ARCOMPACT, 0, 0 ,0,0},
  { "asl%.q%.f%Q %#,%B,%L%F", 0xf8ff0fe0, 0x28c00f80, ARCOMPACT, 0, 0 ,0,0},
  { "asl%.f 0,%B,%C%F", 0xf8ff003f, 0x2800003e, ARCOMPACT, 0, 0 ,0,0},
  { "asl%.f 0,%B,%u%F", 0xf8ff003f, 0x2840003e, ARCOMPACT, 0, 0 ,0,0},
  { "asl%.f%Q 0,%B,%L%F", 0xf8ff0fff, 0x28000fbe, ARCOMPACT, 0, 0 ,0,0},
  { "asl%.f%Q 0,%L,%C%F", 0xffff703f, 0x2e00703e, ARCOMPACT, 0, 0 ,0,0},
  { "asl%.f%Q 0,%L,%u%F", 0xffff703f, 0x2e40703e, ARCOMPACT, 0, 0 ,0,0},
  { "asl%.f%Q 0,%L,%L%F", 0xffff7fff, 0x2e007fbe, ARCOMPACT, 0, 0 ,0,0},
  { "asl%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x2ec07000, ARCOMPACT, 0, 0 ,0,0},
  { "asl%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x2ec07020, ARCOMPACT, 0, 0 ,0,0},
  { "asl%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x2ec07f80, ARCOMPACT, 0, 0 ,0,0},
  { "asl%.f %#,%C%F", 0xf8ff003f, 0x202f0000, ARCOMPACT, 0, 0 ,0,0},
  { "asl%.f %#,%u%F", 0xf8ff003f, 0x206f0000, ARCOMPACT, 0, 0 ,0,0},
  { "asl%.f%Q %#,%L%F", 0xf8ff0fff, 0x202f0f80, ARCOMPACT, 0, 0 ,0,0},
  { "asl%.f 0,%C%F", 0xffff703f, 0x262f7000, ARCOMPACT, 0, 0 ,0,0},
  { "asl%.f 0,%u%F", 0xffff703f, 0x266f7000, ARCOMPACT, 0, 0 ,0,0},
  { "asl%.f%Q 0,%L%F", 0xffff7fff, 0x262f7f80, ARCOMPACT, 0, 0 ,0,0},

  { "asr%.f %A,%B,%C%F", 0xf8ff0000, 0x28020000, ARCOMPACT, 0, 0 ,0,0},
  { "asr%.f %A,%B,%u%F", 0xf8ff0000, 0x28420000, ARCOMPACT, 0, 0 ,0,0},
  { "asr%.f %#,%B,%K%F", 0xf8ff0000, 0x28820000, ARCOMPACT, 0, 0 ,0,0},
  { "asr%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x28020f80, ARCOMPACT, 0, 0 ,0,0},
  { "asr%.f%Q %A,%L,%C%F", 0xffff7000, 0x2e027000, ARCOMPACT, 0, 0 ,0,0},
  { "asr%.f%Q %A,%L,%u%F", 0xffff7000, 0x2e427000, ARCOMPACT, 0, 0 ,0,0},
  { "asr%.f%Q %A,%L,%L%F", 0xffff7fc0, 0x2e027f80, ARCOMPACT, 0, 0 ,0,0},
  { "asr%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x28c20000, ARCOMPACT, 0, 0 ,0,0},
  { "asr%.q%.f %#,%B,%u%F", 0xf8ff0020, 0x28c20020, ARCOMPACT, 0, 0 ,0,0},
  { "asr%.q%.f%Q %#,%B,%L%F", 0xf8ff0fe0, 0x28c20f80, ARCOMPACT, 0, 0 ,0,0},
  { "asr%.f 0,%B,%C%F", 0xf8ff003f, 0x2802003e, ARCOMPACT, 0, 0 ,0,0},
  { "asr%.f 0,%B,%u%F", 0xf8ff003f, 0x2842003e, ARCOMPACT, 0, 0 ,0,0},
  { "asr%.f%Q 0,%B,%L%F", 0xf8ff0fff, 0x28020fbe, ARCOMPACT, 0, 0 ,0,0},
  { "asr%.f%Q 0,%L,%C%F", 0xffff703f, 0x2e02703e, ARCOMPACT, 0, 0 ,0,0},
  { "asr%.f%Q 0,%L,%u%F", 0xffff703f, 0x2e42703e, ARCOMPACT, 0, 0 ,0,0},
  { "asr%.f%Q 0,%L,%L%F", 0xffff7fff, 0x2e027fbe, ARCOMPACT, 0, 0 ,0,0},
  { "asr%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x2ec27000, ARCOMPACT, 0, 0 ,0,0},
  { "asr%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x2ec27020, ARCOMPACT, 0, 0 ,0,0},
  { "asr%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x2ec27f80, ARCOMPACT, 0, 0 ,0,0},
  { "asr%.f %#,%C%F", 0xf8ff003f, 0x202f0001, ARCOMPACT, 0, 0 ,0,0},
  { "asr%.f %#,%u%F", 0xf8ff003f, 0x206f0001, ARCOMPACT, 0, 0 ,0,0},
  { "asr%.f%Q %#,%L%F", 0xf8ff0fff, 0x202f0f81, ARCOMPACT, 0, 0 ,0,0},
  { "asr%.f 0,%C%F", 0xffff703f, 0x262f7001, ARCOMPACT, 0, 0 ,0,0},
  { "asr%.f 0,%u%F", 0xffff703f, 0x266f7001, ARCOMPACT, 0, 0 ,0,0},
  { "asr%.f%Q 0,%L%F", 0xffff7fff, 0x262f7f81, ARCOMPACT, 0, 0 ,0,0},
  { "bbit0%.n %B,%C,%d", 0xf801001f, 0x0801000e, ARCOMPACT, 0, 0 ,0,0},
  { "bbit0%.n %B,%u,%d", 0xf801001f, 0x0801001e, ARCOMPACT, 0, 0 ,0,0},
  { "bbit0%Q %B,%L,%d", 0xf8010fff, 0x08010f8e, ARCOMPACT, 0, 0 ,0,0},
  { "bbit0%Q %L,%C,%d", 0xff01703f, 0x0e01700e, ARCOMPACT, 0, 0 ,0,0},
  { "bbit1%.n %B,%C,%d", 0xf801001f, 0x0801000f, ARCOMPACT, 0, 0 ,0,0},
  { "bbit1%.n %B,%u,%d", 0xf801001f, 0x0801001f, ARCOMPACT, 0, 0 ,0,0},
  { "bbit1%Q %B,%L,%d", 0xf8010fff, 0x08010f8f, ARCOMPACT, 0, 0 ,0,0},
  { "bbit1%Q %L,%C,%d", 0xff01703f, 0x0e01700f, ARCOMPACT, 0, 0 ,0,0},
  { "b%.n %I", 0xf8010010, 0x00010000, ARCOMPACT, 0, 0 ,0,0},
  { "b%q%.n %i", 0xf8010000, 0x00000000, ARCOMPACT, 0, 0 ,0,0},
  { "b%.q%.n %i", 0xf8010000, 0x00000000, ARCOMPACT, 0, 0 ,0,0},
  { "bclr%.f %A,%B,%C%F", 0xf8ff0000, 0x20100000, ARCOMPACT, 0, 0 ,0,0},
  { "bclr%.f %A,%B,%u%F", 0xf8ff0000, 0x20500000, ARCOMPACT, 0, 0 ,0,0},
  { "bclr%.f %#,%B,%K%F", 0xf8ff0000, 0x20900000, ARCOMPACT, 0, 0 ,0,0},
  { "bclr%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x20100f80, ARCOMPACT, 0, 0 ,0,0},
  { "bclr%.f%Q %A,%L,%C%F", 0xffff7000, 0x26107000, ARCOMPACT, 0, 0 ,0,0},
  { "bclr%.f%Q %A,%L,%u%F", 0xffff7000, 0x26507000, ARCOMPACT, 0, 0 ,0,0},
  { "bclr%.f%Q %A,%L,%L%F", 0xffff7fc0, 0x26107f80, ARCOMPACT, 0, 0 ,0,0},
  { "bclr%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x20d00000, ARCOMPACT, 0, 0 ,0,0},
  { "bclr%.q%.f %#,%B,%u%F", 0xf8ff0020, 0x20d00020, ARCOMPACT, 0, 0 ,0,0},
  { "bclr%.q%.f%Q %#,%B,%L%F", 0xf8ff0fe0, 0x20d00f80, ARCOMPACT, 0, 0 ,0,0},
  { "bclr%.f 0,%B,%C%F", 0xf8ff003f, 0x2010003e, ARCOMPACT, 0, 0 ,0,0},
  { "bclr%.f 0,%B,%u%F", 0xf8ff003f, 0x2050003e, ARCOMPACT, 0, 0 ,0,0},
  { "bclr%.f%Q 0,%B,%L%F", 0xf8ff0fff, 0x20100fbe, ARCOMPACT, 0, 0 ,0,0},
  { "bclr%.f%Q 0,%L,%C%F", 0xffff703f, 0x2610703e, ARCOMPACT, 0, 0 ,0,0},
  { "bclr%.f%Q 0,%L,%u%F", 0xffff703f, 0x2650703e, ARCOMPACT, 0, 0 ,0,0},
  { "bclr%.f%Q 0,%L,%L%F", 0xffff7fff, 0x26107fbe, ARCOMPACT, 0, 0 ,0,0},
  { "bclr%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x26d07000, ARCOMPACT, 0, 0 ,0,0},
  { "bclr%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x26d07020, ARCOMPACT, 0, 0 ,0,0},
  { "bclr%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x26d07f80, ARCOMPACT, 0, 0 ,0,0},
  { "bic%.f %A,%B,%C%F", 0xf8ff0000, 0x20060000, ARCOMPACT, 0, 0 ,0,0},
  { "bic%.f %A,%B,%u%F", 0xf8ff0000, 0x20460000, ARCOMPACT, 0, 0 ,0,0},
  { "bic%.f %#,%B,%K%F", 0xf8ff0000, 0x20860000, ARCOMPACT, 0, 0 ,0,0},
  { "bic%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x20060f80, ARCOMPACT, 0, 0 ,0,0},
  { "bic%.f%Q %A,%L,%C%F", 0xffff7000, 0x26067000, ARCOMPACT, 0, 0 ,0,0},
  { "bic%.f%Q %A,%L,%u%F", 0xffff7000, 0x26467000, ARCOMPACT, 0, 0 ,0,0},
  { "bic%.f%Q %A,%L,%L%F", 0xffff7fc0, 0x26067f80, ARCOMPACT, 0, 0 ,0,0},
  { "bic%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x20c60000, ARCOMPACT, 0, 0 ,0,0},
  { "bic%.q%.f %#,%B,%u%F", 0xf8ff0020, 0x20c60020, ARCOMPACT, 0, 0 ,0,0},
  { "bic%.q%.f%Q %#,%B,%L%F", 0xf8ff0fe0, 0x20c60f80, ARCOMPACT, 0, 0 ,0,0},
  { "bic%.f 0,%B,%C%F", 0xf8ff003f, 0x2006003e, ARCOMPACT, 0, 0 ,0,0},
  { "bic%.f 0,%B,%u%F", 0xf8ff003f, 0x2046003e, ARCOMPACT, 0, 0 ,0,0},
  { "bic%.f%Q 0,%B,%L%F", 0xf8ff0fff, 0x20060fbe, ARCOMPACT, 0, 0 ,0,0},
  { "bic%.f%Q 0,%L,%C%F", 0xffff703f, 0x2606703e, ARCOMPACT, 0, 0 ,0,0},
  { "bic%.f%Q 0,%L,%u%F", 0xffff703f, 0x2646703e, ARCOMPACT, 0, 0 ,0,0},
  { "bic%.f%Q 0,%L,%L%F", 0xffff7fff, 0x26067fbe, ARCOMPACT, 0, 0 ,0,0},
  { "bic%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x26c67000, ARCOMPACT, 0, 0 ,0,0},
  { "bic%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x26c67020, ARCOMPACT, 0, 0 ,0,0},
  { "bic%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x26c67f80, ARCOMPACT, 0, 0 ,0,0},
  { "bl%.n %H", 0xf8030030, 0x08020000, ARCOMPACT, 0, 0 ,0,0},
  { "bl%q%.n %h", 0xf803003f, 0x08000000, ARCOMPACT, 0, 0 ,0,0},
  { "bmsk%.f %A,%B,%C%F", 0xf8ff0000, 0x20130000, ARCOMPACT, 0, 0 ,0,0},
  { "bmsk%.f %A,%B,%u%F", 0xf8ff0000, 0x20530000, ARCOMPACT, 0, 0 ,0,0},
  { "bmsk%.f %#,%B,%K%F", 0xf8ff0000, 0x20930000, ARCOMPACT, 0, 0 ,0,0},
  { "bmsk%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x20130f80, ARCOMPACT, 0, 0 ,0,0},
  { "bmsk%.f%Q %A,%L,%C%F", 0xffff7000, 0x26137000, ARCOMPACT, 0, 0 ,0,0},
  { "bmsk%.f%Q %A,%L,%u%F", 0xffff7000, 0x26537000, ARCOMPACT, 0, 0 ,0,0},
  { "bmsk%.f%Q %A,%L,%L%F", 0xffff7fc0, 0x26137f80, ARCOMPACT, 0, 0 ,0,0},
  { "bmsk%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x20d30000, ARCOMPACT, 0, 0 ,0,0},
  { "bmsk%.q%.f %#,%B,%u%F", 0xf8ff0020, 0x20d30020, ARCOMPACT, 0, 0 ,0,0},
  { "bmsk%.q%.f%Q %#,%B,%L%F", 0xf8ff0fe0, 0x20d30f80, ARCOMPACT, 0, 0 ,0,0},
  { "bmsk%.f 0,%B,%C%F", 0xf8ff003f, 0x2013003e, ARCOMPACT, 0, 0 ,0,0},
  { "bmsk%.f 0,%B,%u%F", 0xf8ff003f, 0x2053003e, ARCOMPACT, 0, 0 ,0,0},
  { "bmsk%.f%Q 0,%B,%L%F", 0xf8ff0fff, 0x20130fbe, ARCOMPACT, 0, 0 ,0,0},
  { "bmsk%.f%Q 0,%L,%C%F", 0xffff703f, 0x2613703e, ARCOMPACT, 0, 0 ,0,0},
  { "bmsk%.f%Q 0,%L,%u%F", 0xffff703f, 0x2653703e, ARCOMPACT, 0, 0 ,0,0},
  { "bmsk%.f%Q 0,%L,%L%F", 0xffff7fff, 0x26137fbe, ARCOMPACT, 0, 0 ,0,0},
  { "bmsk%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x26d37000, ARCOMPACT, 0, 0 ,0,0},
  { "bmsk%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x26d37020, ARCOMPACT, 0, 0 ,0,0},
  { "bmsk%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x26d37f80, ARCOMPACT, 0, 0 ,0,0},
  { "breq%.n %B,%C,%d", 0xf801003f, 0x08010000, ARCOMPACT, 0, 0 ,0,0},
  { "breq%.n %B,%u,%d", 0xf801003f, 0x08010010, ARCOMPACT, 0, 0 ,0,0},
  { "breq%Q %B,%L,%d", 0xf8010fff, 0x08010f80, ARCOMPACT, 0, 0 ,0,0},
  { "breq%Q %L,%C,%d", 0xff01703f, 0x0e017000, ARCOMPACT, 0, 0 ,0,0},
  { "brne%.n %B,%C,%d", 0xf801003f, 0x08010001, ARCOMPACT, 0, 0 ,0,0},
  { "brne%.n %B,%u,%d", 0xf801003f, 0x08010011, ARCOMPACT, 0, 0 ,0,0},
  { "brne%Q %B,%L,%d", 0xf8010fff, 0x08010f81, ARCOMPACT, 0, 0 ,0,0},
  { "brne%Q %L,%C,%d", 0xff01703f, 0x0e017001, ARCOMPACT, 0, 0 ,0,0},

  /*Pseudo mnemonics for BRcc instruction*/
  { "brgt%.n %C,%B,%d", 0xf801003f, 0x08010002, ARCOMPACT, 0, 0 ,0,0},
  { "brgt%.n %B,%u,%d", 0xf801003f, 0x08010013, ARCOMPACT|ARC_INCR_U6, 0, 0 ,0,0},
  { "brgt%Q %L,%B,%d", 0xf8010fff, 0x08010f82, ARCOMPACT, 0, 0 ,0,0},
  { "brgt%Q %C,%L,%d", 0xff01703f, 0x0e017002, ARCOMPACT, 0, 0 ,0,0},

  { "brle%.n %C,%B,%d", 0xf801003f, 0x08010003, ARCOMPACT, 0, 0 ,0,0},
  { "brle%.n %B,%u,%d", 0xf801003f, 0x08010012, ARCOMPACT|ARC_INCR_U6, 0, 0 ,0,0},
  { "brle%Q %L,%B,%d", 0xf8010fff, 0x08010f83, ARCOMPACT, 0, 0 ,0,0},
  { "brle%Q %C,%L,%d", 0xff01703f, 0x0e017003, ARCOMPACT, 0, 0 ,0,0},

  { "brhi%.n %C,%B,%d", 0xf801003f, 0x08010004, ARCOMPACT, 0, 0 ,0,0},
  { "brhi%.n %B,%u,%d", 0xf801003f, 0x08010015, ARCOMPACT|ARC_INCR_U6, 0, 0 ,0,0},
  { "brhi%Q %L,%B,%d", 0xf8010fff, 0x08010f84, ARCOMPACT, 0, 0 ,0,0},
  { "brhi%Q %C,%L,%d", 0xff01703f, 0x0e017004, ARCOMPACT, 0, 0 ,0,0},


  { "brls%.n %C,%B,%d", 0xf801003f, 0x08010005, ARCOMPACT, 0, 0 ,0,0},
  { "brls%.n %B,%u,%d", 0xf801003f, 0x08010014, ARCOMPACT|ARC_INCR_U6, 0, 0 ,0,0},
  { "brls%Q %L,%B,%d", 0xf8010fff, 0x08010f85, ARCOMPACT, 0, 0 ,0,0},
  { "brls%Q %C,%L,%d", 0xff01703f, 0x0e017005, ARCOMPACT, 0, 0 ,0,0},

  { "brcc%.n %B,%C,%d", 0xff01003f, 0x08010005, ARCOMPACT, 0, 0 ,0,0},
  { "brcc%.n %B,%u,%d", 0xff01003f, 0x08010015, ARCOMPACT, 0, 0 ,0,0},
  { "brcc%Q %B,%L,%d", 0xf8010fff, 0x08010f85, ARCOMPACT, 0, 0 ,0,0},
  { "brcc%Q %L,%C,%d", 0xf801003f, 0x0e017005, ARCOMPACT, 0, 0 ,0,0},

  { "brcs%.n %B,%C,%d", 0xff01003f, 0x08010004, ARCOMPACT, 0, 0 ,0,0},
  { "brcs%.n %B,%u,%d", 0xff01003f, 0x08010014, ARCOMPACT, 0, 0 ,0,0},
  { "brcs%Q %B,%L,%d", 0xf8010fff, 0x08010f84, ARCOMPACT, 0, 0 ,0,0},
  { "brcs%Q %L,%C,%d", 0xf801003f, 0x0e017004, ARCOMPACT, 0, 0 ,0,0},
  /*Pseudo Mnemonics definition ends*/

  { "brlt%.n %B,%C,%d", 0xf801003f, 0x08010002, ARCOMPACT, 0, 0 ,0,0},
  { "brlt%.n %B,%u,%d", 0xf801003f, 0x08010012, ARCOMPACT, 0, 0 ,0,0},
  { "brlt%Q %B,%L,%d", 0xf8010fff, 0x08010f82, ARCOMPACT, 0, 0 ,0,0},
  { "brlt%Q %L,%C,%d", 0xff01703f, 0x0e017002, ARCOMPACT, 0, 0 ,0,0},
  { "brk",             0xffffffff, 0x256F003F, ARCOMPACT, 0, 0 ,0,0},
  { "brge%.n %B,%C,%d", 0xf801003f, 0x08010003, ARCOMPACT, 0, 0 ,0,0},
  { "brge%.n %B,%u,%d", 0xf801003f, 0x08010013, ARCOMPACT, 0, 0 ,0,0},
  { "brge%Q %B,%L,%d", 0xf8010fff, 0x08010f83, ARCOMPACT, 0, 0 ,0,0},
  { "brge%Q %L,%C,%d", 0xff01703f, 0x0e017003, ARCOMPACT, 0, 0 ,0,0},
  { "brlo%.n %B,%C,%d", 0xf801003f, 0x08010004, ARCOMPACT, 0, 0 ,0,0},
  { "brlo%.n %B,%u,%d", 0xf801003f, 0x08010014, ARCOMPACT, 0, 0 ,0,0},
  { "brlo%Q %B,%L,%d", 0xf8010fff, 0x08010f84, ARCOMPACT, 0, 0 ,0,0},
  { "brlo%Q %L,%C,%d", 0xff01703f, 0x0e017004, ARCOMPACT, 0, 0 ,0,0},
  { "brhs%.n %B,%C,%d", 0xf801003f, 0x08010005, ARCOMPACT, 0, 0 ,0,0},
  { "brhs%.n %B,%u,%d", 0xf801003f, 0x08010015, ARCOMPACT, 0, 0 ,0,0},
  { "brhs%Q %B,%L,%d", 0xf8010fff, 0x08010f85, ARCOMPACT, 0, 0 ,0,0},
  { "brhs%Q %L,%C,%d", 0xff01703f, 0x0e017005, ARCOMPACT, 0, 0 ,0,0},
  { "bset%.f %A,%B,%C%F", 0xf8ff0000, 0x200f0000, ARCOMPACT, 0, 0 ,0,0},
  { "bset%.f %A,%B,%u%F", 0xf8ff0000, 0x204f0000, ARCOMPACT, 0, 0 ,0,0},
  { "bset%.f %#,%B,%K%F", 0xf8ff0000, 0x208f0000, ARCOMPACT, 0, 0 ,0,0},
  { "bset%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x200f0f80, ARCOMPACT, 0, 0 ,0,0},
  { "bset%.f%Q %A,%L,%C%F", 0xffff7000, 0x260f7000, ARCOMPACT, 0, 0 ,0,0},
  { "bset%.f%Q %A,%L,%u%F", 0xffff7000, 0x264f7000, ARCOMPACT, 0, 0 ,0,0},
  { "bset%.f%Q %A,%L,%L%F", 0xffff7fc0, 0x260f7f80, ARCOMPACT, 0, 0 ,0,0},
  { "bset%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x20cf0000, ARCOMPACT, 0, 0 ,0,0},
  { "bset%.q%.f %#,%B,%u%F", 0xf8ff0020, 0x20cf0020, ARCOMPACT, 0, 0 ,0,0},
  { "bset%.q%.f%Q %#,%B,%L%F", 0xf8ff0fe0, 0x20cf0f80, ARCOMPACT, 0, 0 ,0,0},
  { "bset%.f 0,%B,%C%F", 0xf8ff003f, 0x200f003e, ARCOMPACT, 0, 0 ,0,0},
  { "bset%.f 0,%B,%u%F", 0xf8ff003f, 0x204f003e, ARCOMPACT, 0, 0 ,0,0},
  { "bset%.f%Q 0,%B,%L%F", 0xf8ff0fff, 0x200f0fbe, ARCOMPACT, 0, 0 ,0,0},
  { "bset%.f%Q 0,%L,%C%F", 0xffff703f, 0x260f703e, ARCOMPACT, 0, 0 ,0,0},
  { "bset%.f%Q 0,%L,%u%F", 0xffff703f, 0x264f703e, ARCOMPACT, 0, 0 ,0,0},
  { "bset%.f%Q 0,%L,%L%F", 0xffff7fff, 0x260f7fbe, ARCOMPACT, 0, 0 ,0,0},
  { "bset%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x26cf7000, ARCOMPACT, 0, 0 ,0,0},
  { "bset%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x26cf7020, ARCOMPACT, 0, 0 ,0,0},
  { "bset%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x26cf7f80, ARCOMPACT, 0, 0 ,0,0},
  { "btst %B,%C", 0xf8ff803f, 0x20118000, ARCOMPACT, 0, 0 ,0,0},
  { "btst %B,%u", 0xf8ff803f, 0x20518000, ARCOMPACT, 0, 0 ,0,0},
  { "btst %B,%K", 0xf8ff8000, 0x20918000, ARCOMPACT, 0, 0 ,0,0},
  { "btst%Q %B,%L", 0xf8ff8000, 0x20118f80, ARCOMPACT, 0, 0 ,0,0},
  { "btst%Q %L,%C", 0xfffff03f, 0x2611f000, ARCOMPACT, 0, 0 ,0,0},
  { "btst%Q %L,%u", 0xfffff03f, 0x2651f000, ARCOMPACT, 0, 0 ,0,0},
  { "btst%Q %L,%L", 0xffffffff, 0x2611ff80, ARCOMPACT, 0, 0 ,0,0},
  { "btst%.q %B,%C", 0xf8ff8020, 0x20d18000, ARCOMPACT, 0, 0 ,0,0},
  { "btst%.q %B,%u", 0xf8ff8020, 0x20d18020, ARCOMPACT, 0, 0 ,0,0},
  { "btst%.q%Q %B,%L", 0xf8ff8fe0, 0x20d18f80, ARCOMPACT, 0, 0 ,0,0},
  { "btst%.q%Q %L,%C", 0xfffff020, 0x26d1f000, ARCOMPACT, 0, 0 ,0,0},
  { "btst%.q%Q %L,%u", 0xfffff020, 0x26d1f020, ARCOMPACT, 0, 0 ,0,0},
  { "btst%.q%Q %L,%L", 0xffffffe0, 0x26d1ff80, ARCOMPACT, 0, 0 ,0,0},
  { "bxor%.f %A,%B,%C%F", 0xf8ff0000, 0x20120000, ARCOMPACT, 0, 0 ,0,0},
  { "bxor%.f %A,%B,%u%F", 0xf8ff0000, 0x20520000, ARCOMPACT, 0, 0 ,0,0},
  { "bxor%.f %#,%B,%K%F", 0xf8ff0000, 0x20920000, ARCOMPACT, 0, 0 ,0,0},
  { "bxor%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x20120f80, ARCOMPACT, 0, 0 ,0,0},
  { "bxor%.f%Q %A,%L,%C%F", 0xffff7000, 0x26127000, ARCOMPACT, 0, 0 ,0,0},
  { "bxor%.f%Q %A,%L,%u%F", 0xffff7000, 0x26527000, ARCOMPACT, 0, 0 ,0,0},
  { "bxor%.f%Q %A,%L,%L%F", 0xffff7fc0, 0x26127f80, ARCOMPACT, 0, 0 ,0,0},
  { "bxor%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x20d20000, ARCOMPACT, 0, 0 ,0,0},
  { "bxor%.q%.f %#,%B,%u%F", 0xf8ff0020, 0x20d20020, ARCOMPACT, 0, 0 ,0,0},
  { "bxor%.q%.f%Q %#,%B,%L%F", 0xf8ff0fe0, 0x20d20f80, ARCOMPACT, 0, 0 ,0,0},
  { "bxor%.f 0,%B,%C%F", 0xf8ff003f, 0x2012003e, ARCOMPACT, 0, 0 ,0,0},
  { "bxor%.f 0,%B,%u%F", 0xf8ff003f, 0x2052003e, ARCOMPACT, 0, 0 ,0,0},
  { "bxor%.f%Q 0,%B,%L%F", 0xf8ff0fff, 0x20120fbe, ARCOMPACT, 0, 0 ,0,0},
  { "bxor%.f%Q 0,%L,%C%F", 0xffff703f, 0x2612703e, ARCOMPACT, 0, 0 ,0,0},
  { "bxor%.f%Q 0,%L,%u%F", 0xffff703f, 0x2652703e, ARCOMPACT, 0, 0 ,0,0},
  { "bxor%.f%Q 0,%L,%L%F", 0xffff7fff, 0x26127fbe, ARCOMPACT, 0, 0 ,0,0},
  { "bxor%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x26d27000, ARCOMPACT, 0, 0 ,0,0},
  { "bxor%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x26d27020, ARCOMPACT, 0, 0 ,0,0},
  { "bxor%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x26d27f80, ARCOMPACT, 0, 0 ,0,0},
  { "cmp %B,%C", 0xf8ff803f, 0x200c8000, ARCOMPACT, 0, 0 ,0,0},
  { "cmp %B,%u", 0xf8ff803f, 0x204c8000, ARCOMPACT, 0, 0 ,0,0},
  { "cmp %B,%K", 0xf8ff8000, 0x208c8000, ARCOMPACT, 0, 0 ,0,0},
  { "cmp%Q %B,%L", 0xf8ff8000, 0x200c8f80, ARCOMPACT, 0, 0 ,0,0},
  { "cmp%Q %L,%C", 0xfffff03f, 0x260cf000, ARCOMPACT, 0, 0 ,0,0},
  { "cmp%Q %L,%u", 0xfffff03f, 0x264cf000, ARCOMPACT, 0, 0 ,0,0},
  { "cmp%Q %L,%L", 0xffffffff, 0x260cff80, ARCOMPACT, 0, 0 ,0,0},
  { "cmp%.q %B,%C", 0xf8ff8020, 0x20cc8000, ARCOMPACT, 0, 0 ,0,0},
  { "cmp%.q %B,%u", 0xf8ff8020, 0x20cc8020, ARCOMPACT, 0, 0 ,0,0},
  { "cmp%.q%Q %B,%L", 0xf8ff8fe0, 0x20cc8f80, ARCOMPACT, 0, 0 ,0,0},
  { "cmp%.q%Q %L,%C", 0xfffff020, 0x26ccf000, ARCOMPACT, 0, 0 ,0,0},
  { "cmp%.q%Q %L,%u", 0xfffff020, 0x26ccf020, ARCOMPACT, 0, 0 ,0,0},
  { "cmp%.q%Q %L,%L", 0xffffffe0, 0x26ccff80, ARCOMPACT, 0, 0 ,0,0},

  /* ARC A700 extension for Atomic Exchange */
  { "ex%.V %#,[%C]%^",0xf8ff003f,0x202f000C,ARC_MACH_ARC7,0,0,0,0},
  { "ex%.V %#,[%u]%^",0xf8ff003f,0x206f000C,ARC_MACH_ARC7,0,0,0,0},
  { "ex%.V %#,[%L]%^",0xf8ff0fff,0x202f0f8c,ARC_MACH_ARC7,0,0,0,0},

  { "extb%.f %#,%C%F", 0xf8ff003f, 0x202f0007, ARCOMPACT, 0, 0 ,0,0},
  { "extb%.f %#,%u%F", 0xf8ff003f, 0x206f0007, ARCOMPACT, 0, 0 ,0,0},
  { "extb%.f%Q %#,%L%F", 0xf8ff0fff, 0x202f0f87, ARCOMPACT, 0, 0 ,0,0},
  { "extb%.f 0,%C%F", 0xffff703f, 0x262f7007, ARCOMPACT, 0, 0 ,0,0},
  { "extb%.f 0,%u%F", 0xffff703f, 0x266f7007, ARCOMPACT, 0, 0 ,0,0},
  { "extb%.f%Q 0,%L%F", 0xffff7fff, 0x262f7f87, ARCOMPACT, 0, 0 ,0,0},
  { "extw%.f %#,%C%F", 0xf8ff003f, 0x202f0008, ARCOMPACT, 0, 0 ,0,0},
  { "extw%.f %#,%u%F", 0xf8ff003f, 0x206f0008, ARCOMPACT, 0, 0 ,0,0},
  { "extw%.f%Q %#,%L%F", 0xf8ff0fff, 0x202f0f88, ARCOMPACT, 0, 0 ,0,0},
  { "extw%.f 0,%C%F", 0xffff703f, 0x262f7008, ARCOMPACT, 0, 0 ,0,0},
  { "extw%.f 0,%u%F", 0xffff703f, 0x266f7008, ARCOMPACT, 0, 0 ,0,0},
  { "extw%.f%Q 0,%L%F", 0xffff7fff, 0x262f7f88, ARCOMPACT, 0, 0 ,0,0},

  /* The flag pattern for arcompact have to be changed */
#if 0
  { "flag %C", 0xfffff03f, 0x20290000, ARCOMPACT, 0, 0 },
  { "flag %u", 0xfffff03f, 0x20690000, ARCOMPACT, 0, 0 },
  { "flag %K", 0xfffff000, 0x20a90000, ARCOMPACT, 0, 0 },
  { "flag%Q %L", 0xffffffff, 0x20290f80, ARCOMPACT, 0, 0 },
  { "flag%.q %C", 0xfffff020, 0x20e90000, ARCOMPACT, 0, 0 },
  { "flag%.q %u", 0xfffff020, 0x20e90020, ARCOMPACT, 0, 0 },
  { "flag%.q%Q %L", 0xffffffe0, 0x20e90f80, ARCOMPACT, 0, 0 },
#endif
  { "flag%.q %C", 0xfffff020, 0x20e90000, ARCOMPACT, 0, 0, 0, 0 },
  { "flag%.q %u", 0xfffff020, 0x20e90020, ARCOMPACT, 0, 0, 0, 0 },
  { "flag %K", 0xfffff000, 0x20a90000, ARCOMPACT, 0, 0, 0, 0 },
  { "flag%.q%Q %L", 0xffffffe0, 0x20e90f80, ARCOMPACT, 0, 0, 0, 0 },

  { "j%.N [%C]", 0xfffef03f, 0x20200000, ARCOMPACT, 0, 0 ,0,0},
  { "j%.N %u", 0xfffef03f, 0x20600000, ARCOMPACT, 0, 0 ,0,0},
  { "j%.N %K", 0xfffef000, 0x20a00000, ARCOMPACT, 0, 0 ,0,0},
  { "j%Q %L", 0xffffffff, 0x20200f80, ARCOMPACT, 0, 0 ,0,0},
  { "j%.f [%7]", 0xffffffff, 0x20208740, ARCOMPACT, 0, 0 ,0,0},
  { "j%.f [%8]", 0xffffffff, 0x20208780, ARCOMPACT, 0, 0 ,0,0},
  { "j%q%.N [%C]", 0xfffef020, 0x20e00000, ARCOMPACT, 0, 0 ,0,0},
  { "j%q%.N %u", 0xfffef020, 0x20e00020, ARCOMPACT, 0, 0 ,0,0},
  { "j%q%Q %L", 0xffffffe0, 0x20e00f80, ARCOMPACT, 0, 0 ,0,0},
  { "j%q%.f [%7]", 0xffffffe0, 0x20e08740, ARCOMPACT, 0, 0 ,0,0},
  { "j%q%.f [%8]", 0xffffffe0, 0x20e08780, ARCOMPACT, 0, 0 ,0,0},
  { "jl%.N [%C]", 0xfffef03f, 0x20220000, ARCOMPACT, 0, 0 ,0,0},
  { "jl%.N %u", 0xfffef03f, 0x20620000, ARCOMPACT, 0, 0 ,0,0},
  { "jl%.N %K", 0xfffef000, 0x20a20000, ARCOMPACT, 0, 0 ,0,0},
  { "jl%Q %L", 0xffffffff, 0x20220f80, ARCOMPACT, 0, 0 ,0,0},
  { "jl%q%.N [%C]", 0xfffef020, 0x20e20000, ARCOMPACT, 0, 0 ,0,0},
  { "jl%q%.N %u", 0xfffef020, 0x20e20020, ARCOMPACT, 0, 0 ,0,0},
  { "jl%q%Q %L", 0xffffffe0, 0x20e20f80, ARCOMPACT, 0, 0 ,0,0},

  /* Prefetch equivalent with ld<.aa> 0,[b,s9] / [b,limm] / [limm]
     / [b,c] / [limm,c]
     This is valid only in the A700
  */

  { "ld%.p 0,[%g,%o]%3", 0xf80009ff, 0x1000003e, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "prefetch%.p [%g,%o]%3",0xf80009ff, 0x1000003e, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "pf%.p [%g,%o]%3",0xf80009ff, 0x1000003e, ARC_MACH_ARC7, 0, 0 ,0,0},

  { "ld 0,[%L]%3", 0xff0079ff, 0x1600703e, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "prefetch [%L]%3", 0xff0079ff, 0x1600703e, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "pf [%L]%3", 0xff0079ff, 0x1600703e, ARC_MACH_ARC7, 0, 0 ,0,0},


  { "ld%.p 0,[%g,%C]%1", 0xf83f803f, 0x2030003e, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "prefetch%.p [%g,%C]%1", 0xf83f803f, 0x2030003e, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "pf%.p [%g,%C]%1", 0xf83f803f, 0x2030003e, ARC_MACH_ARC7, 0, 0 ,0,0},


  { "ld%.p 0,[%g,%L]%1", 0xf83f8fff, 0x20300fbe, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "prefetch%.p [%g,%L]%1", 0xf83f8fff, 0x20300fbe, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "pf%.p [%g,%L]%1", 0xf83f8fff, 0x20300fbe, ARC_MACH_ARC7, 0, 0 ,0,0},

  { "ld 0,[%L,%C]%1", 0xff3ff03f, 0x2630703e, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "prefetch [%L,%C]%1", 0xff3ff03f, 0x2630703e, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "pf [%L,%C]%1", 0xff3ff03f, 0x2630703e, ARC_MACH_ARC7, 0, 0 ,0,0},

  /* load instruction opcodes */
  { "ld%T%.X%.P%.V %A,[%g,%C]%1", 0xf8380000, 0x20300000, ARCOMPACT, 0, 0 ,0,0},
  { "ld%t%.x%.p%.v %A,[%g]%1", 0xf8ff8000, 0x10000000, ARCOMPACT, 0, 0 ,0,0},
  { "ld%t%.x%.p%.v %A,[%g,%o]%1", 0xf8000000, 0x10000000, ARCOMPACT, 0, 0 ,0,0},
  { "ld%t%.x%.p%.v %A,[%g,%[L]%1", 0xf8000000, 0x10000000, ARCOMPACT, 0, 0 ,0,0},
  { "ld%T%.X%.P%.V%Q %A,[%g,%L]%1", 0xf8380fc0, 0x20300f80, ARCOMPACT, 0, 0 ,0,0},
  { "ld%T%.X%.&%.V%Q %A,[%L,%C]%1", 0xfff87000, 0x26307000, ARCOMPACT, 0, 0 ,0,0},
  { "ld%t%.x%.v%Q %A,[%L,%o]%1", 0xfff87000, 0x16007000, ARCOMPACT, 0, 0 ,0,0},
  { "ld%T%.X%.V%Q %A,[%L,%L]%1", 0xfff87fc0, 0x26307f80, ARCOMPACT, 0, 0 ,0,0},
  { "ld%t%.x%.v%Q %A,[%L]%3", 0xfffff600, 0x16007000, ARCOMPACT, 0, 0 ,0,0},



  { "lp %Y", 0xfffff000, 0x20a80000, ARCOMPACT, 0, 0 ,0,0},
  { "lp%q %y", 0xfffff020, 0x20e80020, ARCOMPACT, 0, 0 ,0,0},

  { "lr %#,[%C]", 0xf8ff803f, 0x202a0000, ARCOMPACT, 0, 0 ,0,0},
  { "lr %#,[%GC]", 0xf8ff8000, 0x20aa0000, ARCOMPACT, 0, 0 ,0,0},
  { "lr %#,[%K]", 0xf8ff8000, 0x20aa0000, ARCOMPACT, 0, 0 ,0,0},
  { "lr%Q %#,[%L]", 0xf8ff8fff, 0x202a0f80, ARCOMPACT, 0, 0 ,0,0},

  { "lsl%.f %A,%B,%C%F", 0xf8ff0000, 0x28000000, ARCOMPACT, 0, 0 ,0,0},
  { "lsl%.f %A,%B,%u%F", 0xf8ff0000, 0x28400000, ARCOMPACT, 0, 0 ,0,0},
  { "lsl%.f %#,%B,%K%F", 0xf8ff0000, 0x28800000, ARCOMPACT, 0, 0 ,0,0},
  { "lsl%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x28000f80, ARCOMPACT, 0, 0 ,0,0},
  { "lsl%.f%Q %A,%L,%C%F", 0xffff7000, 0x2e007000, ARCOMPACT, 0, 0 ,0,0},
  { "lsl%.f%Q %A,%L,%u%F", 0xffff7000, 0x2e407000, ARCOMPACT, 0, 0 ,0,0},
  { "lsl%.f%Q %A,%L,%L%F", 0xffff7fc0, 0x2e007f80, ARCOMPACT, 0, 0 ,0,0},
  { "lsl%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x28c00000, ARCOMPACT, 0, 0 ,0,0},
  { "lsl%.q%.f %#,%B,%u%F", 0xf8ff0020, 0x28c00020, ARCOMPACT, 0, 0 ,0,0},
  { "lsl%.q%.f%Q %#,%B,%L%F", 0xf8ff0fe0, 0x28c00f80, ARCOMPACT, 0, 0 ,0,0},
  { "lsl%.f 0,%B,%C%F", 0xf8ff003f, 0x2800003e, ARCOMPACT, 0, 0 ,0,0},
  { "lsl%.f 0,%B,%u%F", 0xf8ff003f, 0x2840003e, ARCOMPACT, 0, 0 ,0,0},
  { "lsl%.f%Q 0,%B,%L%F", 0xf8ff0fff, 0x28000fbe, ARCOMPACT, 0, 0 ,0,0},
  { "lsl%.f%Q 0,%L,%C%F", 0xffff703f, 0x2e00703e, ARCOMPACT, 0, 0 ,0,0},
  { "lsl%.f%Q 0,%L,%u%F", 0xffff703f, 0x2e40703e, ARCOMPACT, 0, 0 ,0,0},
  { "lsl%.f%Q 0,%L,%L%F", 0xffff7fff, 0x2e007fbe, ARCOMPACT, 0, 0 ,0,0},
  { "lsl%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x2ec07000, ARCOMPACT, 0, 0 ,0,0},
  { "lsl%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x2ec07020, ARCOMPACT, 0, 0 ,0,0},
  { "lsl%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x2ec07f80, ARCOMPACT, 0, 0 ,0,0},
  { "lsl%.f %#,%C%F", 0xf8ff003f, 0x202f0000, ARCOMPACT, 0, 0 ,0,0},
  { "lsl%.f %#,%u%F", 0xf8ff003f, 0x206f0000, ARCOMPACT, 0, 0 ,0,0},
  { "lsl%.f%Q %#,%L%F", 0xf8ff0fff, 0x202f0f80, ARCOMPACT, 0, 0 ,0,0},
  { "lsl%.f 0,%C%F", 0xffff703f, 0x262f7000, ARCOMPACT, 0, 0 ,0,0},
  { "lsl%.f 0,%u%F", 0xffff703f, 0x266f7000, ARCOMPACT, 0, 0 ,0,0},
  { "lsl%.f%Q 0,%L%F", 0xffff7fff, 0x262f7f80, ARCOMPACT, 0, 0 ,0,0},

  { "lsr%.f %A,%B,%C%F", 0xf8ff0000, 0x28010000, ARCOMPACT, 0, 0 ,0,0},
  { "lsr%.f %A,%B,%u%F", 0xf8ff0000, 0x28410000, ARCOMPACT, 0, 0 ,0,0},
  { "lsr%.f %#,%B,%K%F", 0xf8ff0000, 0x28810000, ARCOMPACT, 0, 0 ,0,0},
  { "lsr%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x28010f80, ARCOMPACT, 0, 0 ,0,0},
  { "lsr%.f%Q %A,%L,%C%F", 0xffff7000, 0x2e017000, ARCOMPACT, 0, 0 ,0,0},
  { "lsr%.f%Q %A,%L,%u%F", 0xffff7000, 0x2e417000, ARCOMPACT, 0, 0 ,0,0},
  { "lsr%.f%Q %A,%L,%L%F", 0xffff7fc0, 0x2e017f80, ARCOMPACT, 0, 0 ,0,0},
  { "lsr%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x28c10000, ARCOMPACT, 0, 0 ,0,0},
  { "lsr%.q%.f %#,%B,%u%F", 0xf8ff0020, 0x28c10020, ARCOMPACT, 0, 0 ,0,0},
  { "lsr%.q%.f%Q %#,%B,%L%F", 0xf8ff0fe0, 0x28c10f80, ARCOMPACT, 0, 0 ,0,0},
  { "lsr%.f 0,%B,%C%F", 0xf8ff003f, 0x2801003e, ARCOMPACT, 0, 0 ,0,0},
  { "lsr%.f 0,%B,%u%F", 0xf8ff003f, 0x2841003e, ARCOMPACT, 0, 0 ,0,0},
  { "lsr%.f%Q 0,%B,%L%F", 0xf8ff0fff, 0x28010fbe, ARCOMPACT, 0, 0 ,0,0},
  { "lsr%.f%Q 0,%L,%C%F", 0xffff703f, 0x2e01703e, ARCOMPACT, 0, 0 ,0,0},
  { "lsr%.f%Q 0,%L,%u%F", 0xffff703f, 0x2e41703e, ARCOMPACT, 0, 0 ,0,0},
  { "lsr%.f%Q 0,%L,%L%F", 0xffff7fff, 0x2e017fbe, ARCOMPACT, 0, 0 ,0,0},
  { "lsr%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x2ec17000, ARCOMPACT, 0, 0 ,0,0},
  { "lsr%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x2ec17020, ARCOMPACT, 0, 0 ,0,0},
  { "lsr%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x2ec17f80, ARCOMPACT, 0, 0 ,0,0},
  { "lsr%.f %#,%C%F", 0xf8ff003f, 0x202f0002, ARCOMPACT, 0, 0 ,0,0},
  { "lsr%.f %#,%u%F", 0xf8ff003f, 0x206f0002, ARCOMPACT, 0, 0 ,0,0},
  { "lsr%.f%Q %#,%L%F", 0xf8ff0fff, 0x202f0f82, ARCOMPACT, 0, 0 ,0,0},
  { "lsr%.f 0,%C%F", 0xffff703f, 0x262f7002, ARCOMPACT, 0, 0 ,0,0},
  { "lsr%.f 0,%u%F", 0xffff703f, 0x266f7002, ARCOMPACT, 0, 0 ,0,0},
  { "lsr%.f%Q 0,%L%F", 0xffff7fff, 0x262f7f82, ARCOMPACT, 0, 0 ,0,0},
  { "max%.f %A,%B,%C%F", 0xf8ff0000, 0x20080000, ARCOMPACT, 0, 0 ,0,0},
  { "max%.f %A,%B,%u%F", 0xf8ff0000, 0x20480000, ARCOMPACT, 0, 0 ,0,0},
  { "max%.f %#,%B,%K%F", 0xf8ff0000, 0x20880000, ARCOMPACT, 0, 0 ,0,0},
  { "max%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x20080f80, ARCOMPACT, 0, 0 ,0,0},
  { "max%.f%Q %A,%L,%C%F", 0xffff7000, 0x26087000, ARCOMPACT, 0, 0 ,0,0},
  { "max%.f%Q %A,%L,%u%F", 0xffff7000, 0x26487000, ARCOMPACT, 0, 0 ,0,0},
  { "max%.f%Q %A,%L,%L%F", 0xffff7fc0, 0x26087f80, ARCOMPACT, 0, 0 ,0,0},
  { "max%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x20c80000, ARCOMPACT, 0, 0 ,0,0},
  { "max%.q%.f %#,%B,%u%F", 0xf8ff0020, 0x20c80020, ARCOMPACT, 0, 0 ,0,0},
  { "max%.q%.f%Q %#,%B,%L%F", 0xf8ff0fe0, 0x20c80f80, ARCOMPACT, 0, 0 ,0,0},
  { "max%.f 0,%B,%C%F", 0xf8ff003f, 0x2008003e, ARCOMPACT, 0, 0 ,0,0},
  { "max%.f 0,%B,%u%F", 0xf8ff003f, 0x2048003e, ARCOMPACT, 0, 0 ,0,0},
  { "max%.f%Q 0,%B,%L%F", 0xf8ff0fff, 0x20080fbe, ARCOMPACT, 0, 0 ,0,0},
  { "max%.f%Q 0,%L,%C%F", 0xffff703f, 0x2608703e, ARCOMPACT, 0, 0 ,0,0},
  { "max%.f%Q 0,%L,%u%F", 0xffff703f, 0x2648703e, ARCOMPACT, 0, 0 ,0,0},
  { "max%.f%Q 0,%L,%L%F", 0xffff7fff, 0x26087fbe, ARCOMPACT, 0, 0 ,0,0},
  { "max%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x26c87000, ARCOMPACT, 0, 0 ,0,0},
  { "max%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x26c87020, ARCOMPACT, 0, 0 ,0,0},
  { "max%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x26c87f80, ARCOMPACT, 0, 0 ,0,0},
  { "min%.f %A,%B,%C%F", 0xf8ff0000, 0x20090000, ARCOMPACT, 0, 0 ,0,0},
  { "min%.f %A,%B,%u%F", 0xf8ff0000, 0x20490000, ARCOMPACT, 0, 0 ,0,0},
  { "min%.f %#,%B,%K%F", 0xf8ff0000, 0x20890000, ARCOMPACT, 0, 0 ,0,0},
  { "min%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x20090f80, ARCOMPACT, 0, 0 ,0,0},
  { "min%.f%Q %A,%L,%C%F", 0xffff7000, 0x26097000, ARCOMPACT, 0, 0 ,0,0},
  { "min%.f%Q %A,%L,%u%F", 0xffff7000, 0x26497000, ARCOMPACT, 0, 0 ,0,0},
  { "min%.f%Q %A,%L,%L%F", 0xffff7fc0, 0x26097f80, ARCOMPACT, 0, 0 ,0,0},
  { "min%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x20c90000, ARCOMPACT, 0, 0 ,0,0},
  { "min%.q%.f %#,%B,%u%F", 0xf8ff0020, 0x20c90020, ARCOMPACT, 0, 0 ,0,0},
  { "min%.q%.f%Q %#,%B,%L%F", 0xf8ff0fe0, 0x20c90f80, ARCOMPACT, 0, 0 ,0,0},
  { "min%.f 0,%B,%C%F", 0xf8ff003f, 0x2009003e, ARCOMPACT, 0, 0 ,0,0},
  { "min%.f 0,%B,%u%F", 0xf8ff003f, 0x2049003e, ARCOMPACT, 0, 0 ,0,0},
  { "min%.f%Q 0,%B,%L%F", 0xf8ff0fff, 0x20090fbe, ARCOMPACT, 0, 0 ,0,0},
  { "min%.f%Q 0,%L,%C%F", 0xffff703f, 0x2609703e, ARCOMPACT, 0, 0 ,0,0},
  { "min%.f%Q 0,%L,%u%F", 0xffff703f, 0x2649703e, ARCOMPACT, 0, 0 ,0,0},
  { "min%.f%Q 0,%L,%L%F", 0xffff7fff, 0x26097fbe, ARCOMPACT, 0, 0 ,0,0},
  { "min%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x26c97000, ARCOMPACT, 0, 0 ,0,0},
  { "min%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x26c97020, ARCOMPACT, 0, 0 ,0,0},
  { "min%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x26c97f80, ARCOMPACT, 0, 0 ,0,0},

  { "mov%.f %#,%C%F", 0xf8ff003f, 0x200A0000, ARCOMPACT, 0, 0 ,0,0},
  { "mov%.f %#,%u%F", 0xf8ff003f, 0x204a0000, ARCOMPACT, 0, 0 ,0,0},
  { "mov%.f %#,%K%F", 0xf8ff0000, 0x208a0000, ARCOMPACT, 0, 0 ,0,0},
  { "mov%.f%Q %#,%L%F", 0xf8ff0fff, 0x200a0f80, ARCOMPACT, 0, 0 ,0,0},
  { "mov%.q%.f %#,%C%F", 0xf8ff0020, 0x20ca0000, ARCOMPACT, 0, 0 ,0,0},
  { "mov%.q%.f %#,%u%F", 0xf8ff0020, 0x20ca0020, ARCOMPACT, 0, 0 ,0,0},
  { "mov%.q%.f%Q %#,%L%F", 0xf8ff0fe0, 0x20ca0f80, ARCOMPACT, 0, 0 ,0,0},
  { "mov%.f 0,%C%F", 0xffff703f, 0x260a7000, ARCOMPACT, 0, 0 ,0,0},
  { "mov%.f 0,%u%F", 0xffff703f, 0x264a7000, ARCOMPACT, 0, 0 ,0,0},
  { "mov%.f 0,%K%F", 0xffff7000, 0x268a7000, ARCOMPACT, 0, 0 ,0,0},
  { "mov%.f%Q 0,%L%F", 0xffff7fff, 0x260a7f80, ARCOMPACT, 0, 0 ,0,0},
  { "mov%.q%.f 0,%C%F", 0xffff7020, 0x26ca7000, ARCOMPACT, 0, 0 ,0,0},
  { "mov%.q%.f 0,%u%F", 0xffff7020, 0x26ca7020, ARCOMPACT, 0, 0 ,0,0},
  { "mov%.q%.f%Q 0,%L%F", 0xffff7fe0, 0x26ca7f80, ARCOMPACT, 0, 0 ,0,0},

  { "neg%.f %A,%B%F", 0xf8ff0000, 0x204e0000, ARCOMPACT, 0, 0 ,0,0},
  { "neg%.q%.f %#,%B%F", 0xf8ff0020, 0x20ce0020, ARCOMPACT, 0, 0 ,0,0},

  { "norm%.f %#,%C%F", 0xf8ff003f, 0x282f0001, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "norm%.f %#,%u%F", 0xf8ff003f, 0x286f0001, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "norm%.f%Q %#,%L%F", 0xf8ff0fff, 0x282f0f81, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "norm%.f 0,%C%F", 0xffff703f, 0x2e2f7001, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "norm%.f 0,%u%F", 0xffff703f, 0x2e6f7001, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "norm%.f%Q 0,%L%F", 0xffff7fff, 0x2e2f7f81, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "normw%.f %#,%C%F", 0xf8ff003f, 0x282f0008, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "normw%.f %#,%u%F", 0xf8ff003f, 0x286f0008, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "normw%.f%Q %#,%L%F", 0xf8ff0fff, 0x282f0f88, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "normw%.f 0,%C%F", 0xffff703f, 0x2e2f7008, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "normw%.f 0,%u%F", 0xffff703f, 0x2e6f7008, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "normw%.f%Q 0,%L%F", 0xffff7fff, 0x2e2f7f88, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "not%.f %#,%C%F", 0xf8ff003f, 0x202f000a, ARCOMPACT, 0, 0 ,0,0},
  { "not%.f %#,%u%F", 0xf8ff003f, 0x206f000a, ARCOMPACT, 0, 0 ,0,0},
  { "not%.f%Q %#,%L%F", 0xf8ff0fff, 0x202f0f8a, ARCOMPACT, 0, 0 ,0,0},
  { "not%.f 0,%C%F", 0xffff703f, 0x262f700a, ARCOMPACT, 0, 0 ,0,0},
  { "not%.f 0,%u%F", 0xffff703f, 0x266f700a, ARCOMPACT, 0, 0 ,0,0},
  { "not%.f%Q 0,%L%F", 0xffff7fff, 0x262f7f8a, ARCOMPACT, 0, 0 ,0,0},
  { "or%.f %A,%B,%C%F", 0xf8ff0000, 0x20050000, ARCOMPACT, 0, 0 ,0,0},
  { "or%.f %A,%B,%u%F", 0xf8ff0000, 0x20450000, ARCOMPACT, 0, 0 ,0,0},
  { "or%.f %#,%B,%K%F", 0xf8ff0000, 0x20850000, ARCOMPACT, 0, 0 ,0,0},
  { "or%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x20050f80, ARCOMPACT, 0, 0 ,0,0},
  { "or%.f%Q %A,%L,%C%F", 0xffff7000, 0x26057000, ARCOMPACT, 0, 0 ,0,0},
  { "or%.f%Q %A,%L,%u%F", 0xffff7000, 0x26457000, ARCOMPACT, 0, 0 ,0,0},
  { "or%.f%Q %A,%L,%L%F", 0xffff7fc0, 0x26057f80, ARCOMPACT, 0, 0 ,0,0},
  { "or%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x20c50000, ARCOMPACT, 0, 0 ,0,0},
  { "or%.q%.f %#,%B,%u%F", 0xf8ff0020, 0x20c50020, ARCOMPACT, 0, 0 ,0,0},
  { "or%.q%.f%Q %#,%B,%L%F", 0xf8ff0fe0, 0x20c50f80, ARCOMPACT, 0, 0 ,0,0},
  { "or%.f 0,%B,%C%F", 0xf8ff003f, 0x2005003e, ARCOMPACT, 0, 0 ,0,0},
  { "or%.f 0,%B,%u%F", 0xf8ff003f, 0x2045003e, ARCOMPACT, 0, 0 ,0,0},
  { "or%.f%Q 0,%B,%L%F", 0xf8ff8fff, 0x20050fbe, ARCOMPACT, 0, 0 ,0,0},
  { "or%.f%Q 0,%L,%C%F", 0xffff703f, 0x2605703e, ARCOMPACT, 0, 0 ,0,0},
  { "or%.f%Q 0,%L,%u%F", 0xffff703f, 0x2645703e, ARCOMPACT, 0, 0 ,0,0},
  { "or%.f%Q 0,%L,%L%F", 0xffff7fff, 0x26057fbe, ARCOMPACT, 0, 0 ,0,0},
  { "or%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x26c57000, ARCOMPACT, 0, 0 ,0,0},
  { "or%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x26c57020, ARCOMPACT, 0, 0 ,0,0},
  { "or%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x26c57f80, ARCOMPACT, 0, 0 ,0,0},
  { "rcmp %B,%C", 0xf8ff803f, 0x200d8000, ARCOMPACT, 0, 0 ,0,0},
  { "rcmp %B,%u", 0xf8ff803f, 0x204d8000, ARCOMPACT, 0, 0 ,0,0},
  { "rcmp %B,%K", 0xf8ff8000, 0x208d8000, ARCOMPACT, 0, 0 ,0,0},
  { "rcmp%Q %B,%L", 0xf8ff8000, 0x200d8f80, ARCOMPACT, 0, 0 ,0,0},
  { "rcmp%Q %L,%C", 0xfffff03f, 0x260df000, ARCOMPACT, 0, 0 ,0,0},
  { "rcmp%Q %L,%u", 0xfffff03f, 0x264df000, ARCOMPACT, 0, 0 ,0,0},
  { "rcmp%Q %L,%L", 0xffffffff, 0x260dff80, ARCOMPACT, 0, 0 ,0,0},
  { "rcmp%.q %B,%C", 0xf8ff8020, 0x20cd8000, ARCOMPACT, 0, 0 ,0,0},
  { "rcmp%.q %B,%u", 0xf8ff8020, 0x20cd8020, ARCOMPACT, 0, 0 ,0,0},
  { "rcmp%.q%Q %B,%L", 0xf8ff8fe0, 0x20cd8f80, ARCOMPACT, 0, 0 ,0,0},
  { "rcmp%.q%Q %L,%C", 0xfffff020, 0x26cdf000, ARCOMPACT, 0, 0 ,0,0},
  { "rcmp%.q%Q %L,%u", 0xfffff020, 0x26cdf020, ARCOMPACT, 0, 0 ,0,0},
  { "rcmp%.q%Q %L,%L", 0xffffffff, 0x26cdff80, ARCOMPACT, 0, 0 ,0,0},

  { "rlc%.f %#,%C%F", 0xf8ff003f, 0x202f000b, ARCOMPACT, 0, 0 ,0,0},
  { "rlc%.f %#,%u%F", 0xf8ff003f, 0x206f000b, ARCOMPACT, 0, 0 ,0,0},
  { "rlc%.f%Q %#,%L%F", 0xf8ff0fff, 0x202f0f8b, ARCOMPACT, 0, 0 ,0,0},
  { "rlc%.f 0,%C%F", 0xffff703f, 0x262f700b, ARCOMPACT, 0, 0 ,0,0},
  { "rlc%.f 0,%u%F", 0xffff703f, 0x266f700b, ARCOMPACT, 0, 0 ,0,0},
  { "rlc%.f%Q 0,%L%F", 0xffff7fff, 0x262f7f8b, ARCOMPACT, 0, 0 ,0,0},
  { "ror%.f %A,%B,%C%F", 0xf8ff0000, 0x28030000, ARCOMPACT, 0, 0 ,0,0},
  { "ror%.f %A,%B,%u%F", 0xf8ff0000, 0x28430000, ARCOMPACT, 0, 0 ,0,0},
  { "ror%.f %#,%B,%K%F", 0xf8ff0000, 0x28830000, ARCOMPACT, 0, 0 ,0,0},
  { "ror%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x28030f80, ARCOMPACT, 0, 0 ,0,0},
  { "ror%.f%Q %A,%L,%C%F", 0xffff7000, 0x2e037000, ARCOMPACT, 0, 0 ,0,0},
  { "ror%.f%Q %A,%L,%u%F", 0xffff7000, 0x2e437000, ARCOMPACT, 0, 0 ,0,0},
  { "ror%.f%Q %A,%L,%L%F", 0xffff7fc0, 0x2e037f80, ARCOMPACT, 0, 0 ,0,0},
  { "ror%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x28c30000, ARCOMPACT, 0, 0 ,0,0},
  { "ror%.q%.f %#,%B,%u%F", 0xf8ff0020, 0x28c30020, ARCOMPACT, 0, 0 ,0,0},
  { "ror%.q%.f%Q %#,%B,%L%F", 0xf8ff0fe0, 0x28c30f80, ARCOMPACT, 0, 0 ,0,0},
  { "ror%.f 0,%B,%C%F", 0xf8ff003f, 0x2803003e, ARCOMPACT, 0, 0 ,0,0},
  { "ror%.f 0,%B,%u%F", 0xf8ff003f, 0x2843003e, ARCOMPACT, 0, 0 ,0,0},
  { "ror%.f%Q 0,%B,%L%F", 0xf8ff0fff, 0x28030fbe, ARCOMPACT, 0, 0 ,0,0},
  { "ror%.f%Q 0,%L,%C%F", 0xffff703f, 0x2e03703e, ARCOMPACT, 0, 0 ,0,0},
  { "ror%.f%Q 0,%L,%u%F", 0xffff703f, 0x2e43703e, ARCOMPACT, 0, 0 ,0,0},
  { "ror%.f%Q 0,%L,%L%F", 0xffff7fff, 0x2e037fbe, ARCOMPACT, 0, 0 ,0,0},
  { "ror%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x2ec37000, ARCOMPACT, 0, 0 ,0,0},
  { "ror%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x2ec37020, ARCOMPACT, 0, 0 ,0,0},
  { "ror%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x2ec37f80, ARCOMPACT, 0, 0 ,0,0},
  { "ror%.f %#,%C%F", 0xf8ff003f, 0x202f0003, ARCOMPACT, 0, 0 ,0,0},
  { "ror%.f %#,%u%F", 0xf8ff003f, 0x206f0003, ARCOMPACT, 0, 0 ,0,0},
  { "ror%.f%Q %#,%L%F", 0xf8ff0fff, 0x202f0f83, ARCOMPACT, 0, 0 ,0,0},
  { "ror%.f 0,%C%F", 0xffff703f, 0x262f7003, ARCOMPACT, 0, 0 ,0,0},
  { "ror%.f 0,%u%F", 0xffff703f, 0x266f7003, ARCOMPACT, 0, 0 ,0,0},
  { "ror%.f%Q 0,%L%F", 0xffff7fff, 0x262f7f83, ARCOMPACT, 0, 0 ,0,0},
  { "rrc%.f %#,%C%F", 0xf8ff003f, 0x202f0004, ARCOMPACT, 0, 0 ,0,0},
  { "rrc%.f %#,%u%F", 0xf8ff003f, 0x206f0004, ARCOMPACT, 0, 0 ,0,0},
  { "rrc%.f%Q %#,%L%F", 0xf8ff0fff, 0x202f0f84, ARCOMPACT, 0, 0 ,0,0},
  { "rrc%.f 0,%C%F", 0xffff703f, 0x262f7004, ARCOMPACT, 0, 0 ,0,0},
  { "rrc%.f 0,%u%F", 0xffff703f, 0x266f7004, ARCOMPACT, 0, 0 ,0,0},
  { "rrc%.f%Q 0,%L%F", 0xffff7fff, 0x262f7f84, ARCOMPACT, 0, 0 ,0,0},
  { "rsub%.f %A,%B,%C%F", 0xf8ff0000, 0x200e0000, ARCOMPACT, 0, 0 ,0,0},
  { "rsub%.f %A,%B,%u%F", 0xf8ff0000, 0x204e0000, ARCOMPACT, 0, 0 ,0,0},
  { "rsub%.f %#,%B,%K%F", 0xf8ff0000, 0x208e0000, ARCOMPACT, 0, 0 ,0,0},
  { "rsub%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x200e0f80, ARCOMPACT, 0, 0 ,0,0},
  { "rsub%.f%Q %A,%L,%C%F", 0xffff7000, 0x260e7000, ARCOMPACT, 0, 0 ,0,0},
  { "rsub%.f%Q %A,%L,%u%F", 0xffff7000, 0x264e7000, ARCOMPACT, 0, 0 ,0,0},
  { "rsub%.f%Q %A,%L,%L%F", 0xffff7000, 0x260e7f80, ARCOMPACT, 0, 0 ,0,0},
  { "rsub%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x20ce0000, ARCOMPACT, 0, 0 ,0,0},
  { "rsub%.q%.f %#,%B,%u%F", 0xf8ff0020, 0x20ce0020, ARCOMPACT, 0, 0 ,0,0},
  { "rsub%.q%.f%Q %#,%B,%L%F", 0xf8ff0fe0, 0x20ce0f80, ARCOMPACT, 0, 0 ,0,0},
  { "rsub%.f 0,%B,%C%F", 0xf8ff003f, 0x200e003e, ARCOMPACT, 0, 0 ,0,0},
  { "rsub%.f 0,%B,%u%F", 0xf8ff003f, 0x204e003e, ARCOMPACT, 0, 0 ,0,0},
  { "rsub%.f%Q 0,%B,%L%F", 0xf8ff0fff, 0x200e0fbe, ARCOMPACT, 0, 0 ,0,0},
  { "rsub%.f%Q 0,%L,%C%F", 0xffff703f, 0x260e703e, ARCOMPACT, 0, 0 ,0,0},
  { "rsub%.f%Q 0,%L,%u%F", 0xffff703f, 0x264e703e, ARCOMPACT, 0, 0 ,0,0},
  { "rsub%.f%Q 0,%L,%L%F", 0xffff7fff, 0x260e7fbe, ARCOMPACT, 0, 0 ,0,0},
  { "rsub%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x26ce7000, ARCOMPACT, 0, 0 ,0,0},
  { "rsub%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x26ce7020, ARCOMPACT, 0, 0 ,0,0},
  { "rsub%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x26ce7f80, ARCOMPACT, 0, 0 ,0,0},

  /* Return from Interrupt or Exception  .New A700 instruction */
  { "rtie",0xffffffff,0x242F003F,ARC_MACH_ARC7,0,0,0,0},

  { "sbc%.f %A,%B,%C%F", 0xf8ff0000, 0x20030000, ARCOMPACT, 0, 0 ,0,0},
  { "sbc%.f %A,%B,%u%F", 0xf8ff0000, 0x20430000, ARCOMPACT, 0, 0 ,0,0},
  { "sbc%.f %#,%B,%K%F", 0xf8ff0000, 0x20830000, ARCOMPACT, 0, 0 ,0,0},
  { "sbc%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x20030f80, ARCOMPACT, 0, 0 ,0,0},
  { "sbc%.f%Q %A,%L,%C%F", 0xffff7000, 0x26037000, ARCOMPACT, 0, 0 ,0,0},
  { "sbc%.f%Q %A,%L,%u%F", 0xffff7000, 0x26437000, ARCOMPACT, 0, 0 ,0,0},
  { "sbc%.f%Q %A,%L,%L%F", 0xffff7000, 0x26037f80, ARCOMPACT, 0, 0 ,0,0},
  { "sbc%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x20c30000, ARCOMPACT, 0, 0 ,0,0},
  { "sbc%.q%.f %#,%B,%u%F", 0xf8ff0020, 0x20c30020, ARCOMPACT, 0, 0 ,0,0},
  { "sbc%.q%.f%Q %#,%B,%L%F", 0xf8ff0fe0, 0x20c30f80, ARCOMPACT, 0, 0 ,0,0},
  { "sbc%.f 0,%B,%C%F", 0xf8ff003f, 0x2003003e, ARCOMPACT, 0, 0 ,0,0},
  { "sbc%.f 0,%B,%u%F", 0xf8ff003f, 0x2043003e, ARCOMPACT, 0, 0 ,0,0},
  { "sbc%.f%Q 0,%B,%L%F", 0xf8ff0fff, 0x20030fbe, ARCOMPACT, 0, 0 ,0,0},
  { "sbc%.f%Q 0,%L,%C%F", 0xffff703f, 0x2603703e, ARCOMPACT, 0, 0 ,0,0},
  { "sbc%.f%Q 0,%L,%u%F", 0xffff703f, 0x2643703e, ARCOMPACT, 0, 0 ,0,0},
  { "sbc%.f%Q 0,%L,%L%F", 0xffff7fff, 0x26037fbe, ARCOMPACT, 0, 0 ,0,0},
  { "sbc%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x26c37000, ARCOMPACT, 0, 0 ,0,0},
  { "sbc%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x26c37020, ARCOMPACT, 0, 0 ,0,0},
  { "sbc%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x26c37f80, ARCOMPACT, 0, 0 ,0,0},
  { "sexb%.f %#,%C%F", 0xf8ff003f, 0x202f0005, ARCOMPACT, 0, 0 ,0,0},
  { "sexb%.f %#,%u%F", 0xf8ff003f, 0x206f0005, ARCOMPACT, 0, 0 ,0,0},
  { "sexb%.f%Q %#,%L%F", 0xf8ff0fff, 0x202f0f85, ARCOMPACT, 0, 0 ,0,0},
  { "sexb%.f 0,%C%F", 0xffff703f, 0x262f7005, ARCOMPACT, 0, 0 ,0,0},
  { "sexb%.f 0,%u%F", 0xffff703f, 0x266f7005, ARCOMPACT, 0, 0 ,0,0},
  { "sexb%.f%Q 0,%L%F", 0xffff7fff, 0x262f7f85, ARCOMPACT, 0, 0 ,0,0},
  { "sexw%.f %#,%C%F", 0xf8ff003f, 0x202f0006, ARCOMPACT, 0, 0 ,0,0},
  { "sexw%.f %#,%u%F", 0xf8ff003f, 0x206f0006, ARCOMPACT, 0, 0 ,0,0},
  { "sexw%.f%Q %#,%L%F", 0xf8ff0fff, 0x202f0f86, ARCOMPACT, 0, 0 ,0,0},
  { "sexw%.f 0,%C%F", 0xffff703f, 0x262f7006, ARCOMPACT, 0, 0 ,0,0},
  { "sexw%.f 0,%u%F", 0xffff703f, 0x266f7006, ARCOMPACT, 0, 0 ,0,0},
  { "sexw%.f%Q 0,%L%F", 0xffff7fff, 0x262f7f86, ARCOMPACT, 0, 0 ,0,0},

  /* ARC700 sleep instruction */
  { "sleep %u", 0xfffff03f, 0x216f003f, ARC_MACH_ARC7, 0, 0,0,0},
  { "sleep %C", 0xfffff03f, 0x212f003f, ARC_MACH_ARC5 | ARC_MACH_ARC6, 0, 0 ,0,0},
  { "sleep %u", 0xfffff03f, 0x216f003f, ARC_MACH_ARC5 | ARC_MACH_ARC6, 0, 0 ,0,0},
  { "sleep %L", 0xffffffff, 0x212f0fbf, ARC_MACH_ARC5 | ARC_MACH_ARC6, 0, 0 ,0,0},
  { "sleep", 0xffffffff, 0x216f003f, ARCOMPACT, 0, 0 ,0,0},

  { "sr %B,[%C]", 0xf8ff803f, 0x202b0000, ARCOMPACT, 0, 0 ,0,0},
  { "sr %B,[%GC]", 0xf8ff8000, 0x20ab0000, ARCOMPACT, 0, 0 ,0,0},
  { "sr %B,[%K]", 0xf8ff8000, 0x20ab0000, ARCOMPACT, 0, 0 ,0,0},
  { "sr%Q %B,[%L]", 0xf8ff8fff, 0x202b0f80, ARCOMPACT, 0, 0 ,0,0},
  { "sr%Q %L,[%C]", 0xfffff03f, 0x262b7000, ARCOMPACT, 0, 0 ,0,0},
  { "sr%Q %L,[%GC]", 0xfffff000, 0x26ab7000, ARCOMPACT, 0, 0 ,0,0},
  { "sr%Q %L,[%K]", 0xfffff000, 0x26ab7000, ARCOMPACT, 0, 0 ,0,0},
  { "sr%Q %L,[%L]", 0xffffffff, 0x262b7f80, ARCOMPACT, 0, 0 ,0,0},
  { "st%z%.w%.D %C,[%g]%0", 0xf8ff8001, 0x18000000, ARCOMPACT, 0, 0 ,0,0},
  { "st%z%.w%.D %C,[%g,%[L]%0", 0xf8000001, 0x18000000, ARCOMPACT, 0, 0 ,0,0},
  { "st%z%.w%.D %C,[%g,%o]%0", 0xf8000001, 0x18000000, ARCOMPACT, 0, 0 ,0,0},
  { "st%z%.D%Q %C,[%L,%o]%0", 0xff007001, 0x1e007000, ARCOMPACT, 0, 0 ,0,0},
  { "st%z%.D%Q %C,[%L]%0", 0xfffff001, 0x1e007000, ARCOMPACT, 0, 0 ,0,0},
  { "st%z%.w%.D%Q %L,[%g]%0", 0xf8ff8fc1, 0x18000f80, ARCOMPACT, 0, 0 ,0,0},
  { "st%z%.w%.D%Q %L,[%g,%o]%0", 0xf8000fc1, 0x18000f80, ARCOMPACT, 0, 0 ,0,0},
  { "st%z%.D%Q %L,[%L,%o]%0", 0xff007fc1, 0x1e007f80, ARCOMPACT, 0, 0 ,0,0},
  { "sub%.f %A,%B,%C%F", 0xf8ff0000, 0x20020000, ARCOMPACT, 0, 0 ,0,0},
  { "sub%.f %A,%B,%u%F", 0xf8ff0000, 0x20420000, ARCOMPACT, 0, 0 ,0,0},
  { "sub%.f %#,%B,%K%F", 0xf8ff0000, 0x20820000, ARCOMPACT, 0, 0 ,0,0},
  { "sub%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x20020f80, ARCOMPACT, 0, 0 ,0,0},
  { "sub%.f%Q %A,%L,%C%F", 0xffff7000, 0x26027000, ARCOMPACT, 0, 0 ,0,0},
  { "sub%.f%Q %A,%L,%u%F", 0xffff7000, 0x26427000, ARCOMPACT, 0, 0 ,0,0},
  { "sub%.f%Q %A,%L,%L%F", 0xffff7000, 0x26027f80, ARCOMPACT, 0, 0 ,0,0},
  { "sub%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x20c20000, ARCOMPACT, 0, 0 ,0,0},
  { "sub%.q%.f %#,%B,%u%F", 0xf8ff0020, 0x20c20020, ARCOMPACT, 0, 0 ,0,0},
  { "sub%.q%.f%Q %#,%B,%L%F", 0xf8ff0fe0, 0x20c20f80, ARCOMPACT, 0, 0 ,0,0},
  { "sub%.f 0,%B,%C%F", 0xf8ff003f, 0x2002003e, ARCOMPACT, 0, 0 ,0,0},
  { "sub%.f 0,%B,%u%F", 0xf8ff003f, 0x2042003e, ARCOMPACT, 0, 0 ,0,0},
  { "sub%.f%Q 0,%B,%L%F", 0xf8ff0fff, 0x20020fbe, ARCOMPACT, 0, 0 ,0,0},
  { "sub%.f%Q 0,%L,%C%F", 0xffff703f, 0x2602703e, ARCOMPACT, 0, 0 ,0,0},
  { "sub%.f%Q 0,%L,%u%F", 0xffff703f, 0x2642703e, ARCOMPACT, 0, 0 ,0,0},
  { "sub%.f%Q 0,%L,%L%F", 0xffff7fff, 0x26027fbe, ARCOMPACT, 0, 0 ,0,0},
  { "sub%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x26c27000, ARCOMPACT, 0, 0 ,0,0},
  { "sub%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x26c27020, ARCOMPACT, 0, 0 ,0,0},
  { "sub%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x26c27f80, ARCOMPACT, 0, 0 ,0,0},

  { "sub1%.f %A,%B,%C%F", 0xf8ff0000, 0x20170000, ARCOMPACT, 0, 0 ,0,0},
  { "sub1%.f %A,%B,%u%F", 0xf8ff0000, 0x20570000, ARCOMPACT, 0, 0 ,0,0},
  { "sub1%.f %#,%B,%K%F", 0xf8ff0000, 0x20970000, ARCOMPACT, 0, 0 ,0,0},
  { "sub1%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x20170f80, ARCOMPACT, 0, 0 ,0,0},
  { "sub1%.f%Q %A,%L,%C%F", 0xffff7000, 0x26177000, ARCOMPACT, 0, 0 ,0,0},
  { "sub1%.f%Q %A,%L,%u%F", 0xffff7000, 0x26577000, ARCOMPACT, 0, 0 ,0,0},
  { "sub1%.f%Q %A,%L,%L%F", 0xffff7000, 0x26177f80, ARCOMPACT, 0, 0 ,0,0},
  { "sub1%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x20d70000, ARCOMPACT, 0, 0 ,0,0},
  { "sub1%.q%.f %#,%B,%u%F", 0xf8ff0020, 0x20d70020, ARCOMPACT, 0, 0 ,0,0},
  { "sub1%.q%.f%Q %#,%B,%L%F", 0xf8ff0fe0, 0x20d70f80, ARCOMPACT, 0, 0 ,0,0},
  { "sub1%.f 0,%B,%C%F", 0xf8ff003f, 0x2017003e, ARCOMPACT, 0, 0 ,0,0},
  { "sub1%.f 0,%B,%u%F", 0xf8ff003f, 0x2057003e, ARCOMPACT, 0, 0 ,0,0},
  { "sub1%.f%Q 0,%B,%L%F", 0xf8ff0fff, 0x20170fbe, ARCOMPACT, 0, 0 ,0,0},
  { "sub1%.f%Q 0,%L,%C%F", 0xffff703f, 0x2617703e, ARCOMPACT, 0, 0 ,0,0},
  { "sub1%.f%Q 0,%L,%u%F", 0xffff703f, 0x2657703e, ARCOMPACT, 0, 0 ,0,0},
  { "sub1%.f%Q 0,%L,%L%F", 0xffff7fff, 0x26177fbe, ARCOMPACT, 0, 0, 0, 0},
  { "sub1%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x26d77000, ARCOMPACT, 0, 0 ,0,0},
  { "sub1%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x26d77020, ARCOMPACT, 0, 0 ,0,0},
  { "sub1%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x26d77f80, ARCOMPACT, 0, 0 ,0 ,0},
  { "sub2%.f %A,%B,%C%F", 0xf8ff0000, 0x20180000, ARCOMPACT, 0, 0 ,0,0},
  { "sub2%.f %A,%B,%u%F", 0xf8ff0000, 0x20580000, ARCOMPACT, 0, 0 ,0,0},
  { "sub2%.f %#,%B,%K%F", 0xf8ff0000, 0x20980000, ARCOMPACT, 0, 0 ,0,0},
  { "sub2%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x20180f80, ARCOMPACT, 0, 0 ,0,0},
  { "sub2%.f%Q %A,%L,%C%F", 0xffff7000, 0x26187000, ARCOMPACT, 0, 0 ,0,0},
  { "sub2%.f%Q %A,%L,%u%F", 0xffff7000, 0x26587000, ARCOMPACT, 0, 0 ,0,0},
  { "sub2%.f%Q %A,%L,%L%F", 0xffff7000, 0x26187f80, ARCOMPACT, 0, 0 ,0,0},
  { "sub2%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x20d80000, ARCOMPACT, 0, 0 ,0,0},
  { "sub2%.q%.f %#,%B,%u%F", 0xf8ff0020, 0x20d80020, ARCOMPACT, 0, 0 ,0,0},
  { "sub2%.q%.f%Q %#,%B,%L%F", 0xf8ff0fe0, 0x20d80f80, ARCOMPACT, 0, 0 ,0,0},
  { "sub2%.f 0,%B,%C%F", 0xf8ff003f, 0x2018003e, ARCOMPACT, 0, 0 ,0,0},
  { "sub2%.f 0,%B,%u%F", 0xf8ff003f, 0x2058003e, ARCOMPACT, 0, 0 ,0,0},
  { "sub2%.f%Q 0,%B,%L%F", 0xf8ff0fff, 0x20180fbe, ARCOMPACT, 0, 0 ,0,0},
  { "sub2%.f%Q 0,%L,%C%F", 0xffff703f, 0x2618703e, ARCOMPACT, 0, 0 ,0,0},
  { "sub2%.f%Q 0,%L,%u%F", 0xffff703f, 0x2658703e, ARCOMPACT, 0, 0 ,0,0},
  { "sub2%.f%Q 0,%L,%L%F", 0xffff7fff, 0x26187fbe, ARCOMPACT, 0, 0 ,0,0},
  { "sub2%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x26d87000, ARCOMPACT, 0, 0 ,0,0},
  { "sub2%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x26d87020, ARCOMPACT, 0, 0 ,0,0},
  { "sub2%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x26d87f80, ARCOMPACT, 0, 0 ,0,0},
  { "sub3%.f %A,%B,%C%F", 0xf8ff0000, 0x20190000, ARCOMPACT, 0, 0 ,0,0},
  { "sub3%.f %A,%B,%u%F", 0xf8ff0000, 0x20590000, ARCOMPACT, 0, 0 ,0,0},
  { "sub3%.f %#,%B,%K%F", 0xf8ff0000, 0x20990000, ARCOMPACT, 0, 0 ,0,0},
  { "sub3%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x20190f80, ARCOMPACT, 0, 0 ,0,0},
  { "sub3%.f%Q %A,%L,%C%F", 0xffff7000, 0x26197000, ARCOMPACT, 0, 0 ,0,0},
  { "sub3%.f%Q %A,%L,%u%F", 0xffff7000, 0x26597000, ARCOMPACT, 0, 0 ,0,0},
  { "sub3%.f%Q %A,%L,%L%F", 0xffff7000, 0x26197f80, ARCOMPACT, 0, 0 ,0 ,0},
  { "sub3%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x20d90000, ARCOMPACT, 0, 0 ,0,0},
  { "sub3%.q%.f %#,%B,%u%F", 0xf8ff0020, 0x20d90020, ARCOMPACT, 0, 0 ,0,0},
  { "sub3%.q%.f%Q %#,%B,%L%F", 0xf8ff0fe0, 0x20d90f80, ARCOMPACT, 0, 0 ,0,0},
  { "sub3%.f 0,%B,%C%F", 0xf8ff003f, 0x2019003e, ARCOMPACT, 0, 0 ,0 ,0},
  { "sub3%.f 0,%B,%u%F", 0xf8ff003f, 0x2059003e, ARCOMPACT, 0, 0 ,0 ,0},
  { "sub3%.f%Q 0,%B,%L%F", 0xf8ff0fff, 0x20190fbe, ARCOMPACT, 0, 0 ,0 ,0},
  { "sub3%.f%Q 0,%L,%C%F", 0xffff703f, 0x2619703e, ARCOMPACT, 0, 0 ,0 ,0},
  { "sub3%.f%Q 0,%L,%u%F", 0xffff703f, 0x2659703e, ARCOMPACT, 0, 0 ,0 ,0},
  { "sub3%.f%Q 0,%L,%L%F", 0xffff7fff, 0x26197fbe, ARCOMPACT, 0, 0 ,0 ,0},
  { "sub3%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x26d97000, ARCOMPACT, 0, 0 ,0,0},
  { "sub3%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x26d97020, ARCOMPACT, 0, 0 ,0,0},
  { "sub3%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x26d97f80, ARCOMPACT, 0, 0 ,0 ,0},
  { "swap%.f %#,%C%F", 0xf8ff003f, 0x282f0000, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "swap%.f %#,%u%F", 0xf8ff003f, 0x286f0000, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "swap%.f%Q %#,%L%F", 0xf8ff0fff, 0x282f0f80, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "swap%.f 0,%C%F", 0xffff703f, 0x2e2f7000, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "swap%.f 0,%u%F", 0xffff703f, 0x2e6f7000, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "swap%.f%Q 0,%L%F", 0xffff7fff, 0x2e2f7f80, ARC_MACH_ARC7, 0, 0 ,0,0},
  { "swi", 0xffffffff, 0x226f003f, (ARC_MACH_ARC5 | ARC_MACH_ARC6), 0, 0 ,0,0},

  /* New A700 Instructions */
  { "sync", 0xffffffff, 0x236f003f,ARC_MACH_ARC7,0,0,0,0},
  { "trap0", 0xffffffff, 0x226f003f, ARC_MACH_ARC7, 0, 0 ,0,0},

  { "tst %B,%C%F", 0xf8ff803f, 0x200b8000, ARCOMPACT, 0, 0 ,0,0},
  { "tst %B,%u%F", 0xf8ff803f, 0x204b8000, ARCOMPACT, 0, 0 ,0,0},
  { "tst %B,%K%F", 0xf8ff8000, 0x208b8000, ARCOMPACT, 0, 0 ,0,0},
  { "tst %B,%L%F", 0xf8ff8fff, 0x200b8f80, ARCOMPACT, 0, 0 ,0,0},
  { "tst%Q %L,%C", 0xfffff03f, 0x260bf000, ARCOMPACT, 0, 0 ,0,0},
  { "tst%Q %L,%u", 0xfffff03f, 0x264bf000, ARCOMPACT, 0, 0 ,0,0},
  { "tst%Q %L,%L", 0xffffffff, 0x260bff80, ARCOMPACT, 0, 0 ,0,0},
  { "tst%.q %B,%C", 0xf8ff8020, 0x20cb8000, ARCOMPACT, 0, 0 ,0,0},
  { "tst%.q %B,%u", 0xf8ff8020, 0x20cb8020, ARCOMPACT, 0, 0 ,0,0},
  { "tst%.q%Q %B,%L", 0xf8ff8fe0, 0x20cb8f80, ARCOMPACT, 0, 0 ,0,0},
  { "tst%.q%Q %L,%C", 0xfffff020, 0x26cbf000, ARCOMPACT, 0, 0 ,0,0},
  { "tst%.q%Q %L,%u", 0xfffff020, 0x26cbf020, ARCOMPACT, 0, 0 ,0,0},
  { "tst%.q%Q %L,%L", 0xffffffe0, 0x26cbff80, ARCOMPACT, 0, 0 ,0,0},
  { "xor%.f %A,%B,%C%F", 0xf8ff0000, 0x20070000, ARCOMPACT, 0, 0 ,0,0},
  { "xor%.f %A,%B,%u%F", 0xf8ff0000, 0x20470000, ARCOMPACT, 0, 0 ,0,0},
  { "xor%.f %#,%B,%K%F", 0xf8ff0000, 0x20870000, ARCOMPACT, 0, 0 ,0,0},
  { "xor%.f%Q %A,%B,%L%F", 0xf8ff0fc0, 0x20070f80, ARCOMPACT, 0, 0 ,0,0},
  { "xor%.f%Q %A,%L,%C%F", 0xffff7000, 0x26077000, ARCOMPACT, 0, 0 ,0,0},
  { "xor%.f%Q %A,%L,%u%F", 0xffff7000, 0x26477000, ARCOMPACT, 0, 0 ,0,0},
  { "xor%.f%Q %A,%L,%L%F", 0xffff7fc0, 0x26077f80, ARCOMPACT, 0, 0 ,0,0},
  { "xor%.q%.f %#,%B,%C%F", 0xf8ff0020, 0x20c70000, ARCOMPACT, 0, 0 ,0,0},
  { "xor%.q%.f %#,%B,%u%F", 0xf8ff0020, 0x20c70020, ARCOMPACT, 0, 0 ,0,0},
  { "xor%.q%.f%Q %#,%B,%L%F", 0xf8ff0fe0, 0x20c70f80, ARCOMPACT, 0, 0 ,0,0},
  { "xor%.f 0,%B,%C%F", 0xf8ff003f, 0x2007003e, ARCOMPACT, 0, 0 ,0,0},
  { "xor%.f 0,%B,%u%F", 0xf8ff003f, 0x2047003e, ARCOMPACT, 0, 0 ,0,0},
  { "xor%.f%Q 0,%B,%L%F", 0xf8ff0fff, 0x20070fbe, ARCOMPACT, 0, 0 ,0,0},
  { "xor%.f%Q 0,%L,%C%F", 0xffff703f, 0x2607703e, ARCOMPACT, 0, 0 ,0,0},
  { "xor%.f%Q 0,%L,%u%F", 0xffff703f, 0x2647703e, ARCOMPACT, 0, 0 ,0,0},
  { "xor%.f%Q 0,%L,%L%F", 0xffff7fff, 0x26077fbe, ARCOMPACT, 0, 0 ,0 ,0},
  { "xor%.q%.f%Q 0,%L,%C%F", 0xffff7020, 0x26c77000, ARCOMPACT, 0, 0 ,0,0},
  { "xor%.q%.f%Q 0,%L,%u%F", 0xffff7020, 0x26c77020, ARCOMPACT, 0, 0 ,0,0},
  { "xor%.q%.f%Q 0,%L,%L%F", 0xffff7fe0, 0x26c77f80, ARCOMPACT, 0, 0 ,0 ,0},

  /* ARCompact 16-bit instructions */

/* abs_s b,c;                   01111 bbb ccc 10001 */
  { "abs_s %b,%c", 0xf81f, 0x7811, ARCOMPACT, 0, 0 ,0,0},

/* add_s a,b,c;                 01100 bbb ccc 11 aaa */
  { "add_s %a,%b,%c", 0xf818, 0x6018, ARCOMPACT, 0, 0 ,0,0},
/* add_s b,b,h;                 01110 bbb hhh 00 hhh */
  { "add_s %b,%b,%U", 0xf818, 0x7000, ARCOMPACT, 0, 0 ,0,0},
/* add_s c,b,u3;                01101 bbb ccc 00 uuu */
  { "add_s %c,%b,%e", 0xf818, 0x6800, ARCOMPACT, 0, 0 ,0,0},
/* add_s b,b,u7;                11100 bbb 0 uuuuuuu */
  { "add_s %b,%b,%j", 0xf880, 0xe000, ARCOMPACT, 0, 0 ,0,0},
/* add_s b,b,limm;              01110 bbb 110 00 111 [L] */
  { "add_s%Q %b,%b,%L", 0xf8ff, 0x70c7, ARCOMPACT, 0, 0 ,0,0},
/* add_s b,sp,u7;               11000 bbb 100 uuuuu */
  { "add_s %b,%6,%l", 0xf8e0, 0xc080, ARCOMPACT, 0, 0 ,0,0},
/* add_s sp,sp,u7;              11000 000 101 uuuuu */
  { "add_s %6,%6,%l", 0xffe0, 0xc0a0, ARCOMPACT, 0, 0 ,0,0},
/* add_s r0,gp,s11;             11001 11 sssssssss */
  { "add_s %4,%5,%R", 0xfe00, 0xce00, ARCOMPACT, 0, 0 ,0,0},
  //  { "add_s %4,%5,%[L", 0xfe00, 0xce00, ARCOMPACT, 0, 0 ,0,0},

/* add1_s b,b,c;                01111 bbb ccc 10100 */
  { "add1_s %b,%b,%c", 0xf81f, 0x7814, ARCOMPACT, 0, 0 ,0,0},

/* add2_s b,b,c;                01111 bbb ccc 10101 */
  { "add2_s %b,%b,%c", 0xf81f, 0x7815, ARCOMPACT, 0, 0 ,0,0},

/* add3_s b,b,c;                01111 bbb ccc 10110 */
  { "add3_s %b,%b,%c", 0xf81f, 0x7816, ARCOMPACT, 0, 0 ,0,0},

/* and_s b,b,c;                 01111 bbb ccc 00100 */
  { "and_s %b,%b,%c", 0xf81f, 0x7804, ARCOMPACT, 0, 0 ,0,0},

/* asl_s b,b,c;                 01111 bbb ccc 11000 */
  { "asl_s %b,%b,%c", 0xf81f, 0x7818, ARCOMPACT, 0, 0 ,0,0},
/* asl_s c,b,u3;                01101 bbb ccc 10 uuu */
  { "asl_s %c,%b,%e", 0xf818, 0x6810, ARCOMPACT, 0, 0 ,0,0},
/* asl_s b,b,u5;                10111 bbb 000 uuuuu */
  { "asl_s %b,%b,%E", 0xf8e0, 0xb800, ARCOMPACT, 0, 0 ,0,0},
/* asl_s b,c;                   01111 bbb ccc 11011 */
  { "asl_s %b,%c", 0xf81f, 0x781b, ARCOMPACT, 0, 0 ,0,0},

/* asr_s b,b,c;                 01111 bbb ccc 11010 */
  { "asr_s %b,%b,%c", 0xf81f, 0x781a, ARCOMPACT, 0, 0 ,0,0},
/* asr_s c,b,u3;                01101 bbb ccc 11 uuu */
  { "asr_s %c,%b,%e", 0xf818, 0x6818, ARCOMPACT, 0, 0 ,0,0},
/* asr_s b,b,u5;                10111 bbb 010 uuuuu */
  { "asr_s %b,%b,%E", 0xf8e0, 0xb840, ARCOMPACT, 0, 0 ,0,0},
/* asr_s b,c;                   01111 bbb ccc 11100 */
  { "asr_s %b,%c", 0xf81f, 0x781c, ARCOMPACT, 0, 0 ,0,0},

/* b_s d10;                     11110 00 sssssssss */
  { "b_s %Z", 0xfe00, 0xf000, ARCOMPACT, 0, 0 ,0,0},
/* beq_s d10;                   11110 01 sssssssss */
  { "beq_s %Z", 0xfe00, 0xf200, ARCOMPACT, 0, 0 ,0,0},
/* bne_s d10;                   11110 10 sssssssss */
  { "bne_s %Z", 0xfe00, 0xf400, ARCOMPACT, 0, 0 ,0,0},
/* bgt_s d7;                    11110 11 000 ssssss */
  { "bgt_s %s", 0xffc0, 0xf600, ARCOMPACT, 0, 0 ,0,0},
/* bge_s d7;                    11110 11 001 ssssss */
  { "bge_s %s", 0xffc0, 0xf640, ARCOMPACT, 0, 0 ,0,0},
/* blt_s d7;                    11110 11 010 ssssss */
  { "blt_s %s", 0xffc0, 0xf680, ARCOMPACT, 0, 0 ,0,0},
/* ble_s d7;                    11110 11 011 ssssss */
  { "ble_s %s", 0xffc0, 0xf6c0, ARCOMPACT, 0, 0 ,0,0},
/* bhi_s d7;                    11110 11 100 ssssss */
  { "bhi_s %s", 0xffc0, 0xf700, ARCOMPACT, 0, 0 ,0,0},
/* bhs_s d7;                    11110 11 101 ssssss */
  { "bhs_s %s", 0xffc0, 0xf740, ARCOMPACT, 0, 0 ,0,0},
/* blo_s d7;                    11110 11 110 ssssss */
  { "blo_s %s", 0xffc0, 0xf780, ARCOMPACT, 0, 0 ,0,0},
/* bls_s d7;                    11110 11 111 ssssss */
  { "bls_s %s", 0xffc0, 0xf7c0, ARCOMPACT, 0, 0 ,0,0},

/* bclr_s b,b,u5;               10111 bbb 101 uuuuu */
  { "bclr_s %b,%b,%E", 0xf8e0, 0xb8a0, ARCOMPACT, 0, 0 ,0,0},

/* bic_s b,b,c;                 01111 bbb ccc 00110 */
  { "bic_s %b,%b,%c", 0xf81f, 0x7806, ARCOMPACT, 0, 0 ,0,0},

/* bl_s d11;                    11111 sssssssssss */
  { "bl_s %W", 0xf800, 0xf800, ARCOMPACT, 0, 0 ,0,0},

/* bmsk_s b,b,u5;               10111 bbb 110 uuuuu */
  { "bmsk_s %b,%b,%E", 0xf8e0, 0xb8c0, ARCOMPACT, 0, 0 ,0,0},

/* breq_s b,0,d8;               11101 bbb 0 sssssss */
  { "breq_s %b,0,%S", 0xf880, 0xe800, ARCOMPACT, 0, 0 ,0,0},
/* brne_s b,0,d8;               11101 bbb 1 sssssss */
  { "brne_s %b,0,%S", 0xf880, 0xe880, ARCOMPACT, 0, 0 ,0,0},

/* brk_s ;                      01111 111 111 11111 */
  { "brk_s", 0xffff, 0x7fff, ARCOMPACT, 0, 0 ,0,0},

/* bset_s b,b,u5;               10111 bbb 100 uuuuu */
  { "bset_s %b,%b,%E", 0xf8e0, 0xb880, ARCOMPACT, 0, 0 ,0,0},

/* btst_s b,u5;                 10111 bbb 111 uuuuu */
  { "btst_s %b,%E", 0xf8e0, 0xb8e0, ARCOMPACT, 0, 0 ,0,0},

/* cmp_s b,h;                   01110 bbb hhh 10 hhh */
  { "cmp_s %b,%U", 0xf818, 0x7010, ARCOMPACT, 0, 0 ,0,0},
/* cmp_s b,u7;                  11100 bbb 1 uuuuuuu */
  { "cmp_s %b,%j", 0xf880, 0xe080, ARCOMPACT, 0, 0 ,0,0},
/* cmp_s b,limm;                01110 bbb 110 10 111 [L] */
  { "cmp_s%Q %b,%L", 0xf8ff, 0x70d7, ARCOMPACT, 0, 0 ,0,0},

/* extb_s b,c;                  01111 bbb ccc 01111 */
  { "extb_s %b,%c", 0xf81f, 0x780f, ARCOMPACT, 0, 0 ,0,0},

/* extw_s b,c;                  01111 bbb ccc 10000 */
  { "extw_s %b,%c", 0xf81f, 0x7810, ARCOMPACT, 0, 0 ,0,0},

/* j_s [b];                     01111 bbb 000 00000 */
  { "j_s [%b]", 0xf8ff, 0x7800, ARCOMPACT, 0, 0 ,0,0},
  { "j_s.nd [%b]", 0xf8ff, 0x7800, ARCOMPACT, 0, 0 ,0,0},
/* j_s.d [b];                   01111 bbb 001 00000 */
  { "j_s.d [%b]", 0xf8ff, 0x7820, ARCOMPACT, 0, 0 ,0,0},
/* j_s [blink];                 01111 110 111 00000 */
  { "j_s [%9]", 0xffff, 0x7ee0, ARCOMPACT, 0, 0 ,0,0},
  { "j_s.nd [%9]", 0xffff, 0x7ee0, ARCOMPACT, 0, 0 ,0,0},
/* j_s.d [blink];               01111 111 111 00000 */
  { "j_s.d [%9]", 0xffff, 0x7fe0, ARCOMPACT, 0, 0 ,0,0},
/* jeq_s [blink];               01111 100 111 00000 */
  { "jeq_s [%9]", 0xffff, 0x7ce0, ARCOMPACT, 0, 0 ,0,0},
/* jne_s [blink];               01111 101 111 00000 */
  { "jne_s [%9]", 0xffff, 0x7de0, ARCOMPACT, 0, 0 ,0,0},

/* jl_s [b];                    01111 bbb 010 00000 */
  { "jl_s [%b]", 0xf8ff, 0x7840, ARCOMPACT, 0, 0 ,0,0},
  { "jl_s.nd [%b]", 0xf8ff, 0x7840, ARCOMPACT, 0, 0 ,0,0},
/* jl_s.d [b];                  01111 bbb 011 00000 */
  { "jl_s.d [%b]", 0xf8ff, 0x7860, ARCOMPACT, 0, 0 ,0,0},

/* ld_s a,[b,c];                01100 bbb ccc 00 aaa */
  { "ld_s %a,[%b,%c]", 0xf818, 0x6000, ARCOMPACT, 0, 0 ,0,0},
/* ldb_s a,[b,c];               01100 bbb ccc 01 aaa */
  { "ldb_s %a,[%b,%c]", 0xf818, 0x6008, ARCOMPACT, 0, 0 ,0,0},
/* ldw_s a,[b,c];               01100 bbb ccc 10 aaa */
  { "ldw_s %a,[%b,%c]", 0xf818, 0x6010, ARCOMPACT, 0, 0 ,0,0},
/* ld_s c,[b,u7];               10000 bbb ccc uuuuu */
  { "ld_s %c,[%b,%l]", 0xf800, 0x8000, ARCOMPACT, 0, 0 ,0,0},
  { "ld_s %c,[%b]", 0xf800, 0x8000, ARCOMPACT, 0, 0 ,0,0},
/* ldb_s c,[b,u5];              10001 bbb ccc uuuuu */
  { "ldb_s %c,[%b,%E]", 0xf800, 0x8800, ARCOMPACT, 0, 0 ,0,0},
  { "ldb_s %c,[%b]", 0xf800, 0x8800, ARCOMPACT, 0, 0 ,0,0},
/* ldw_s c,[b,u6];              10010 bbb ccc uuuuu */
  { "ldw_s %c,[%b,%k]", 0xf800, 0x9000, ARCOMPACT, 0, 0 ,0,0},
  { "ldw_s %c,[%b]", 0xf800, 0x9000, ARCOMPACT, 0, 0 ,0,0},
/* ldw_s.x c,[b,u6];            10011 bbb ccc uuuuu */
  { "ldw_s.x %c,[%b,%k]", 0xf800, 0x9800, ARCOMPACT, 0, 0 ,0,0},
  { "ldw_s.x %c,[%b]", 0xf800, 0x9800, ARCOMPACT, 0, 0 ,0,0},
/* ld_s b,[sp,u7];              11000 bbb 000 uuuuu */
  { "ld_s %b,[%6,%l]", 0xf8e0, 0xc000, ARCOMPACT, 0, 0 ,0,0},
  { "ld_s %b,[%6]", 0xf8e0, 0xc000, ARCOMPACT, 0, 0 ,0,0},
/* ldb_s b,[sp,u7];             11000 bbb 001 uuuuu */
  { "ldb_s %b,[%6,%l]", 0xf8e0, 0xc020, ARCOMPACT, 0, 0 ,0,0},
  { "ldb_s %b,[%6]", 0xf8e0, 0xc020, ARCOMPACT, 0, 0 ,0,0},
/* ld_s r0,[gp,s11];            11001 00 sssssssss */
  { "ld_s %4,[%5,%[L]", 0xfe00, 0xc800, ARCOMPACT, 0, 0 ,0,0},
  { "ld_s %4,[%5,%R]", 0xfe00, 0xc800, ARCOMPACT, 0, 0 ,0,0},
  { "ld_s %4,[%5]", 0xfe00, 0xc800, ARCOMPACT, 0, 0 ,0,0},
/* ldb_s r0,[gp,s9];            11001 01 sssssssss */
  { "ldb_s %4,[%5,%[L]", 0xfe00, 0xca00, ARCOMPACT, 0, 0 ,0,0},
  { "ldb_s %4,[%5,%M]", 0xfe00, 0xca00, ARCOMPACT, 0, 0 ,0,0},
  { "ldb_s %4,[%5]", 0xfe00, 0xca00, ARCOMPACT, 0, 0 ,0,0},
/* ldw_s r0,[gp,s10];           11001 10 sssssssss */
  { "ldw_s %4,[%5,%[L]", 0xfe00, 0xcc00, ARCOMPACT, 0, 0 ,0,0},
  { "ldw_s %4,[%5,%O]", 0xfe00, 0xcc00, ARCOMPACT, 0, 0 ,0,0},
  { "ldw_s %4,[%5]", 0xfe00, 0xcc00, ARCOMPACT, 0, 0 ,0,0},
/* ld_s b,[pcl,u10];            11010 bbb uuuuuuuu */
  { "ld_s %b,[%!,%m]", 0xf800, 0xd000, ARCOMPACT, 0, 0 ,0,0},
  { "ld_s %b,[%!]", 0xf800, 0xd000, ARCOMPACT, 0, 0 ,0,0},

/* lsl_s b,b,c;                 01111 bbb ccc 11000 */
  { "lsl_s %b,%b,%c", 0xf81f, 0x7818, ARCOMPACT, 0, 0 ,0,0},
/* lsl_s c,b,u3;                01101 bbb ccc 10 uuu */
  { "lsl_s %c,%b,%e", 0xf818, 0x6810, ARCOMPACT, 0, 0 ,0,0},
/* lsl_s b,b,u5;                10111 bbb 000 uuuuu */
  { "lsl_s %b,%b,%E", 0xf8e0, 0xb800, ARCOMPACT, 0, 0 ,0,0},
/* lsl_s b,c;                   01111 bbb ccc 11011 */
  { "lsl_s %b,%c", 0xf81f, 0x781b, ARCOMPACT, 0, 0 ,0,0},

/* lsr_s b,b,c;                 01111 bbb ccc 11001 */
  { "lsr_s %b,%b,%c", 0xf81f, 0x7819, ARCOMPACT, 0, 0 ,0,0},
/* lsr_s b,b,u5;                10111 bbb 001 uuuuu */
  { "lsr_s %b,%b,%E", 0xf8e0, 0xb820, ARCOMPACT, 0, 0 ,0,0},
/* lsr_s b,c;                   01111 bbb ccc 11101 */
  { "lsr_s %b,%c", 0xf81f, 0x781d, ARCOMPACT, 0, 0 ,0,0},

/* mov_s b,h;                   01110 bbb hhh 01 hhh */
  { "mov_s %b,%U", 0xf818, 0x7008, ARCOMPACT, 0, 0 ,0,0},
/* mov_s b,u8;                  11011 bbb uuuuuuuu */
  { "mov_s %b,%J", 0xf800, 0xd800, ARCOMPACT, 0, 0 ,0,0},
/* mov_s b,limm;                01110 bbb 110 01 111 [L] */
  { "mov_s%Q %b,%L", 0xf8ff, 0x70cf, ARCOMPACT, 0, 0 ,0,0},
/* mov_s h,b;                   01110 bbb hhh 11 hhh */
  { "mov_s %U,%b", 0xf818, 0x7018, ARCOMPACT, 0, 0 ,0,0},
/* mov_s 0,b;                   01110 bbb 110 11 111 */
  { "mov_s 0,%b", 0xf8ff, 0x70df, ARCOMPACT, 0, 0 ,0,0},

/* mul64_s 0,b,c;               01111 bbb ccc 01100 */
  { "mul64_s 0,%b,%c", 0xf81f, 0x780c, ARCOMPACT, 0, 0 ,0,0},

/* neg_s b,c;                   01111 bbb ccc 10011 */
  { "neg_s %b,%c", 0xf81f, 0x7813, ARCOMPACT, 0, 0 ,0,0},

/* not_s b,c;                   01111 bbb ccc 10010 */
  { "not_s %b,%c", 0xf81f, 0x7812, ARCOMPACT, 0, 0 ,0,0},

/* nop_s ;                      01111 000 111 00000 */
  { "nop_s", 0xffff, 0x78e0, ARCOMPACT, 0, 0 ,0,0},

/* unimp_s ;                    01111 001 111 00000 */
/* ARC700 addition */
  { "unimp_s", 0xffff, 0x79e0, ARC_MACH_ARC7, 0, 0 ,0,0},

/* or_s b,b,c;                  01111 bbb ccc 00101 */
  { "or_s %b,%b,%c", 0xf81f, 0x7805, ARCOMPACT, 0, 0 ,0,0},

/* pop_s b;                     11000 bbb 110 00001 */
  { "pop_s %b", 0xf8ff, 0xc0c1, ARCOMPACT, 0, 0 ,0,0},
/* pop_s blink;                 11000 rrr 110 10001 */
  { "pop_s %9", 0xffff, 0xc0d1, ARCOMPACT, 0, 0 ,0,0},

/* push_s b;                    11000 bbb 111 00001 */
  { "push_s %b", 0xf8ff, 0xc0e1, ARCOMPACT, 0, 0 ,0,0},
/* push_s blink;                11000 rrr 111 10001 */
  { "push_s %9", 0xffff, 0xc0f1, ARCOMPACT, 0, 0 ,0,0},

/* sexb_s b,c;                  01111 bbb ccc 01101 */
  { "sexb_s %b,%c", 0xf81f, 0x780d, ARCOMPACT, 0, 0 ,0,0},

/* sexw_s b,c;                  01111 bbb ccc 01110 */
  { "sexw_s %b,%c", 0xf81f, 0x780e, ARCOMPACT, 0, 0 ,0,0},

/* st_s b,[sp,u7];                  11000 bbb 010 uuuuu */
  { "st_s %b,[%6,%l]", 0xf8e0, 0xc040, ARCOMPACT, 0, 0 ,0,0},
  { "st_s %b,[%6]", 0xf8e0, 0xc040, ARCOMPACT, 0, 0 ,0,0},
/* stb_s b,[sp,u7];                  11000 bbb 011 uuuuu */
  { "stb_s %b,[%6,%l]", 0xf8e0, 0xc060, ARCOMPACT, 0, 0 ,0,0},
  { "stb_s %b,[%6]", 0xf8e0, 0xc060, ARCOMPACT, 0, 0 ,0,0},
/* st_s c,[b,u7];                  10100 bbb ccc uuuuu */
  { "st_s %c,[%b,%l]", 0xf800, 0xa000, ARCOMPACT, 0, 0 ,0,0},
  { "st_s %c,[%b]", 0xf800, 0xa000, ARCOMPACT, 0, 0 ,0,0},
/* stb_s c,[b,u5];                  10101 bbb ccc uuuuu */
  { "stb_s %c,[%b,%E]", 0xf800, 0xa800, ARCOMPACT, 0, 0 ,0,0},
  { "stb_s %c,[%b]", 0xf800, 0xa800, ARCOMPACT, 0, 0 ,0,0},
/* stw_s c,[b,u6];                  10110 bbb ccc uuuuu */
  { "stw_s %c,[%b,%k]", 0xf800, 0xb000, ARCOMPACT, 0, 0 ,0,0},
  { "stw_s %c,[%b]", 0xf800, 0xb000, ARCOMPACT, 0, 0 ,0,0},

/* sub_s b,b,c;                 01111 bbb ccc 00010 */
  { "sub_s %b,%b,%c", 0xf81f, 0x7802, ARCOMPACT, 0, 0 ,0,0},
/* sub_s c,b,u3;                01101 bbb ccc 01 uuu */
  { "sub_s %c,%b,%e", 0xf818, 0x6808, ARCOMPACT, 0, 0 ,0,0},
/* sub_s b,b,u5;                10111 bbb 011 uuuuu */
  { "sub_s %b,%b,%E", 0xf8e0, 0xb860, ARCOMPACT, 0, 0 ,0,0},
/* sub_s sp,sp,u7;              11000 001 101 uuuuu */
  { "sub_s %6,%6,%l", 0xffe0, 0xc1a0, ARCOMPACT, 0, 0 ,0,0},
/* sub_s.ne b,b,b;              01111 bbb 110 00000 */
  { "sub_s.ne %b,%b,%b", 0xf8ff, 0x78c0, ARCOMPACT, 0, 0 ,0,0},

/* trap_s unsigned 6 ;   ARC A700 new instruction    01111 1uuuuuu 11110*/
  { "trap_s %@@", 0xffff, 0x781E, ARC_MACH_ARC7, 0, 0 ,0,0},

/* tst_s b,c;                   01111 bbb ccc 01011 */
  { "tst_s %b,%c", 0xf81f, 0x780b, ARCOMPACT, 0, 0 ,0,0},

/* xor_s b,b,c;                 01111 bbb ccc 00111 */
  { "xor_s %b,%b,%c", 0xf81f, 0x7807, ARCOMPACT, 0, 0 ,0,0},

  { "nop", 0xffffffff, 0x264a7000, ARCOMPACT, 0, 0 ,0,0},

d1416 1
d1418 1
a1418 3
/* Register names table for ARCtangent-A4 */

static const struct arc_operand_value arc_reg_names_a4[] =
d1420 1
a1420 2
  /* Sort this so that the first 61 entries are sequential.
     IE: For each i (i<61), arc_reg_names[i].value == i.  */
d1422 1
d1426 44
a1469 8
  { "r9", 9, REG, 0 },
  { "r10", 10, REG, 0 }, { "r11", 11, REG, 0 }, { "r12", 12, REG, 0 },
  { "r13", 13, REG, 0 }, { "r14", 14, REG, 0 }, { "r15", 15, REG, 0 },
  { "r16", 16, REG, 0 }, { "r17", 17, REG, 0 }, { "r18", 18, REG, 0 },
  { "r19", 19, REG, 0 }, { "r20", 20, REG, 0 }, { "r21", 21, REG, 0 },
  { "r22", 22, REG, 0 }, { "r23", 23, REG, 0 }, { "r24", 24, REG, 0 },
  { "r25", 25, REG, 0 }, { "r26", 26, REG, 0 }, { "r27", 27, REG, 0 },
  { "r28", 28, REG, 0 }, { "r29", 29, REG, 0 }, { "r30", 30, REG, 0 },
a1471 3
  { "fp", 27, REG, 0 }, { "sp", 28, REG, 0 },
  { "ilink1", 29, REG, 0 }, { "ilink2", 30, REG, 0 }, { "blink", 31, REG, 0 },
  { "lp_count", 60, REG, 0 },
d1473 10
a1482 2
    /* Standard auxiliary registers.  */
  { "status",         0x00, AUXREG, ARC_REGISTER_READONLY },
a1487 242
    /* Extension auxilary registers */
  { "ivic",           0x10, AUXREG, ARC_REGISTER_WRITEONLY },
  { "ch_mode_ctl",    0x11, AUXREG, 0 },
  { "lockline",       0x13, AUXREG, 0 },
  { "code_ram",       0x14, AUXREG, 0 },
  { "tag_addr_mask",  0x15, AUXREG, 0 },
  { "tag_data_mask",  0x16, AUXREG, 0 },
  { "line_length_mask",       0x17, AUXREG, 0 },
  { "local_ram",      0x18, AUXREG, 0 },
  { "unlockline",     0x19, AUXREG, 0 },
  { "sram_seq",       0x20, AUXREG, 0 },
  { "timer",          0x21, AUXREG, 0 },
  { "tcontrol",       0x22, AUXREG, 0 },
  { "hint",           0x23, AUXREG, ARC_REGISTER_WRITEONLY },
  { "pcport",         0x24, AUXREG, ARC_REGISTER_WRITEONLY },
  { "sp1_ctrl",       0x30, AUXREG, 0 },
  { "sp1_val",        0x31, AUXREG, 0 },
  { "sp2_ctrl",       0x32, AUXREG, 0 },
  { "sp2_val",        0x33, AUXREG, 0 },
  { "sp3_ctrl",       0x34, AUXREG, 0 },
  { "sp3_val",        0x35, AUXREG, 0 },
  { "burst_size",     0x38, AUXREG, 0 },
  { "scratch_a",      0x39, AUXREG, 0 },
  { "load_a",         0x3A, AUXREG, 0 },
  { "store_a",        0x3B, AUXREG, 0 },
  { "bm_status",      0x3C, AUXREG, ARC_REGISTER_READONLY },
  { "xtp_newval",     0x40, AUXREG, 0 },
  { "macmode",        0x41, AUXREG, 0 },
  { "lsp_newval",     0x42, AUXREG, 0 },
  { "status32",       0xa, AUXREG, ARC_REGISTER_READONLY },
  { "status32_l1",    0xb, AUXREG, 0 },
  { "status32_l2",    0xc, AUXREG, 0 },
  { "int_vector_base",0x25, AUXREG, 0 }
};


/* Register names table for ARC A500 and A600*/
static const struct arc_operand_value arc_reg_names_a500600[] =
{
  /* Sort this so that the first 61 entries are sequential.
     IE: For each i (i<61), arc_reg_names[i].value == i.  */

  { "r0", 0, REG_AC, 0 }, { "r1", 1, REG_AC, 0 }, { "r2", 2, REG_AC, 0 },
  { "r3", 3, REG_AC, 0 }, { "r4", 4, REG_AC, 0 }, { "r5", 5, REG_AC, 0 },
  { "r6", 6, REG_AC, 0 }, { "r7", 7, REG_AC, 0 }, { "r8", 8, REG_AC, 0 },
  { "r9", 9, REG_AC, 0 },
  { "r10", 10, REG_AC, 0 }, { "r11", 11, REG_AC, 0 }, { "r12", 12, REG_AC, 0 },
  { "r13", 13, REG_AC, 0 }, { "r14", 14, REG_AC, 0 }, { "r15", 15, REG_AC, 0 },
  { "r16", 16, REG_AC, 0 }, { "r17", 17, REG_AC, 0 }, { "r18", 18, REG_AC, 0 },
  { "r19", 19, REG_AC, 0 }, { "r20", 20, REG_AC, 0 }, { "r21", 21, REG_AC, 0 },
  { "r22", 22, REG_AC, 0 }, { "r23", 23, REG_AC, 0 }, { "r24", 24, REG_AC, 0 },
  { "r25", 25, REG_AC, 0 }, { "r26", 26, REG_AC, 0 }, { "r27", 27, REG_AC, 0 },
  { "r28", 28, REG_AC, 0 }, { "r29", 29, REG_AC, 0 }, { "r30", 30, REG_AC, 0 },
  { "r31", 31, REG_AC, 0 },
  { "gp", 26, REG_AC, 0 },  { "fp", 27, REG_AC, 0 },  { "sp", 28, REG_AC, 0 },
  { "ilink1", 29, REG_AC, 0 },
  { "ilink2", 30, REG_AC, 0 },
  { "blink", 31, REG_AC, 0 },
  { "lp_count", 60, REG_AC, 0 }, { "r60", 60, REG_AC, 0 },
  { "pcl", 63, REG_AC, ARC_REGISTER_READONLY },
  { "r63", 63, REG_AC, ARC_REGISTER_READONLY },

  /* General Purpose Registers for ARCompact 16-bit insns */

  { "r0", 0, REG_AC, ARC_REGISTER_16 }, { "r1", 1, REG_AC, ARC_REGISTER_16 },
  { "r2", 2, REG_AC, ARC_REGISTER_16 }, { "r3", 3, REG_AC, ARC_REGISTER_16 },
  { "r12", 4, REG_AC, ARC_REGISTER_16 }, { "r13", 5, REG_AC, ARC_REGISTER_16 },
  { "r14", 6, REG_AC, ARC_REGISTER_16 }, { "r15", 7, REG_AC, ARC_REGISTER_16 },

    /* Standard auxiliary registers.  */
  { "status",         0x00, AUXREG_AC, ARC_REGISTER_READONLY },
  { "semaphore",      0x01, AUXREG_AC, 0 },
  { "lp_start",       0x02, AUXREG_AC, 0 },
  { "lp_end",         0x03, AUXREG_AC, 0 },
  { "identity",       0x04, AUXREG_AC, ARC_REGISTER_READONLY },
  { "debug",          0x05, AUXREG_AC, ARC_REGISTER_READONLY },
  { "pc",             0x06, AUXREG_AC, ARC_REGISTER_READONLY },
  { "status32",       0xa, AUXREG_AC, ARC_REGISTER_READONLY },
  { "status32_l1",    0xb, AUXREG_AC, 0 },
  { "status32_l2",    0xc, AUXREG_AC, 0 },
  { "int_vector_base",0x25, AUXREG_AC, 0 },
  /* Optional extension auxiliary registers */
  { "multiply_build", 0x7b, AUXREG_AC, ARC_REGISTER_READONLY },
  { "swap_build",     0x7c, AUXREG_AC, ARC_REGISTER_READONLY },
  { "norm_build",     0x7d, AUXREG_AC, ARC_REGISTER_READONLY },
  { "barrel_build",   0x7f, AUXREG_AC, ARC_REGISTER_READONLY },
};


/* Register names table for ARC 700 */
static const struct arc_operand_value arc_reg_names_a700[] =
{
  /* Sort this so that the first 61 entries are sequential.
     IE: For each i (i<61), arc_reg_names[i].value == i.  */

  { "r0", 0, REG_AC, 0 }, { "r1", 1, REG_AC, 0 }, { "r2", 2, REG_AC, 0 },
  { "r3", 3, REG_AC, 0 }, { "r4", 4, REG_AC, 0 }, { "r5", 5, REG_AC, 0 },
  { "r6", 6, REG_AC, 0 }, { "r7", 7, REG_AC, 0 }, { "r8", 8, REG_AC, 0 },
  { "r9", 9, REG_AC, 0 },
  { "r10", 10, REG_AC, 0 }, { "r11", 11, REG_AC, 0 }, { "r12", 12, REG_AC, 0 },
  { "r13", 13, REG_AC, 0 }, { "r14", 14, REG_AC, 0 }, { "r15", 15, REG_AC, 0 },
  { "r16", 16, REG_AC, 0 }, { "r17", 17, REG_AC, 0 }, { "r18", 18, REG_AC, 0 },
  { "r19", 19, REG_AC, 0 }, { "r20", 20, REG_AC, 0 }, { "r21", 21, REG_AC, 0 },
  { "r22", 22, REG_AC, 0 }, { "r23", 23, REG_AC, 0 }, { "r24", 24, REG_AC, 0 },
  { "r25", 25, REG_AC, 0 }, { "r26", 26, REG_AC, 0 }, { "r27", 27, REG_AC, 0 },
  { "r28", 28, REG_AC, 0 }, { "r29", 29, REG_AC, 0 }, { "r30", 30, REG_AC, 0 },
  { "r31", 31, REG_AC, 0 },
  { "gp", 26, REG_AC, 0 }, { "fp", 27, REG_AC, 0 }, { "sp", 28, REG_AC, 0 },
  { "ilink1", 29, REG_AC, 0 },
  { "ilink2", 30, REG_AC, 0 },
  { "blink", 31, REG_AC, 0 },
  { "lp_count", 60, REG_AC, 0 }, { "r60", 60, REG_AC, 0 },
  { "pcl", 63, REG_AC, ARC_REGISTER_READONLY },
  { "r63", 63, REG_AC, ARC_REGISTER_READONLY },

  /* General Purpose Registers for ARCompact 16-bit insns */

  { "r0", 0, REG_AC, ARC_REGISTER_16 }, { "r1", 1, REG_AC, ARC_REGISTER_16 },
  { "r2", 2, REG_AC, ARC_REGISTER_16 }, { "r3", 3, REG_AC, ARC_REGISTER_16 },
  { "r12", 4, REG_AC, ARC_REGISTER_16 }, { "r13", 5, REG_AC, ARC_REGISTER_16 },
  { "r14", 6, REG_AC, ARC_REGISTER_16 }, { "r15", 7, REG_AC, ARC_REGISTER_16 },


    /* Standard auxiliary registers.  */
  { "status",         0x00, AUXREG_AC, ARC_REGISTER_READONLY },
  { "semaphore",      0x01, AUXREG_AC, 0 },
  { "lp_start",       0x02, AUXREG_AC, 0  },
  { "lp_end",         0x03, AUXREG_AC, 0 },
  { "identity",       0x04, AUXREG_AC, ARC_REGISTER_READONLY },
  { "debug",          0x05, AUXREG_AC, ARC_REGISTER_READONLY },
  { "pc",             0x06, AUXREG_AC, ARC_REGISTER_READONLY },
  { "status32",       0xa, AUXREG_AC, ARC_REGISTER_READONLY },
  { "status32_l1",    0xb, AUXREG_AC, 0 },
  { "status32_l2",    0xc, AUXREG_AC, 0 },
  { "int_vector_base",0x25, AUXREG_AC, 0 },
  { "aux_irq_lv12" ,  0x43, AUXREG_AC, 0 },
  /* Optional extension auxiliary registers */
  { "multiply_build", 0x7b, AUXREG_AC, ARC_REGISTER_READONLY },
  { "swap_build",     0x7c, AUXREG_AC, ARC_REGISTER_READONLY },
  { "norm_build",     0x7d, AUXREG_AC, ARC_REGISTER_READONLY },
  { "barrel_build",   0x7f, AUXREG_AC, ARC_REGISTER_READONLY },
  { "aux_irq_lev", 0x200,AUXREG_AC,0 },
  { "aux_irq_hint",0x201,AUXREG_AC, 0 },
  /* Some Tazer specific auxillary registers */
  { "eret",   0x400, AUXREG_AC, 0 }, /* Exception Return Address */
  { "erbta",  0x401, AUXREG_AC, 0}, /* Exception Return Branch Target Address */
  { "erstatus", 0x402,AUXREG_AC, 0},/* Exception Return Status */
  { "ecr" , 0x403, AUXREG_AC, 0 } , /* Exception Cause Register */
  { "efa" , 0x404, AUXREG_AC, 0 } , /* Exception Fault Address */
  /* Level 1 Interrupt Cause */
  { "icause1", 0x40A, AUXREG_AC, ARC_REGISTER_READONLY } ,
  /* Level 2 Interrupt Cause */
  { "icause2", 0x40B, AUXREG_AC, ARC_REGISTER_READONLY } ,

  { "auxienable",0x40C, AUXREG_AC, 0 } , /* Interrupt Mask Programming */
  { "auxitrigger",0x40D, AUXREG_AC, 0} , /* Interrupt Sensitivity Programming */
  { "xpu" , 0x410, AUXREG_AC, 0 } , /* User Mode Extension Enables */
  { "xpk" , 0x411, AUXREG_AC, 0 } , /* Kernel Mode Extension Enables */
  { "bta_l1" , 0x413, AUXREG_AC, 0} , /* Level 1 Return Branch Target */
  { "bta_l2" ,0x414, AUXREG_AC, 0 } , /* Level 2 Return Branch Target */
  /* Interrupt Edge Cancel */
  { "aux_irq_edge_cancel",0x415,AUXREG_AC,  ARC_REGISTER_WRITEONLY } ,
  /* Interrupt Pending Cancel */
  { "aux_irq_pending" , 0x416,AUXREG_AC, ARC_REGISTER_READONLY},

  /* Build Control Registers */
  /* DCCM BCR */
  { "dccm_base_build_bcr", 0x61, AUXREG_AC, ARC_REGISTER_READONLY},
  { "DCCM_BASE_BUILD_BCR", 0x61, AUXREG_AC, ARC_REGISTER_READONLY},
  /* CRC Build BCR */
  { "crc_build_bcr", 0x62, AUXREG_AC, ARC_REGISTER_READONLY},
  { "CRC_BUILD_BCR", 0x62, AUXREG_AC, ARC_REGISTER_READONLY},
  /* BTA Build BCR Signifies the presence of BTA_L1/ L2 registers */
  { "bta_link_build", 0x63,AUXREG_AC, ARC_REGISTER_READONLY},
  { "BTA_LINK_BUILD", 0x63,AUXREG_AC, ARC_REGISTER_READONLY},
  /* Dual Viterbi Butterfly BCR . Signifies presence of that instruction*/
  { "DVBF_BUILD",0x64,AUXREG_AC, ARC_REGISTER_READONLY},
  { "dvbf_build",0x64,AUXREG_AC, ARC_REGISTER_READONLY},
  /* Extended Arithmetic Instructions are present */
  { "tel_instr_build",0x65,AUXREG_AC, ARC_REGISTER_READONLY},
  { "TEL_INSTR_BUILD",0x65,AUXREG_AC, ARC_REGISTER_READONLY},
  /* Memory Subsystem BCR Information regarding the endian-ness etc. */
  { "memsubsys",0x67,AUXREG_AC, ARC_REGISTER_READONLY},
  { "MEMSUBSYS",0x67,AUXREG_AC, ARC_REGISTER_READONLY},
  /* Interrupt vector base register */
  {"vecbase_ac_build",0x68,AUXREG_AC, ARC_REGISTER_READONLY},
  {"VECBASE_AC_BUILD",0x68,AUXREG_AC, ARC_REGISTER_READONLY},
  /* Peripheral base address register */
  { "p_base_addr",0x69,AUXREG_AC, ARC_REGISTER_READONLY},
  { "P_BASE_ADDR",0x69,AUXREG_AC, ARC_REGISTER_READONLY},
  /* MMU BCR . Specifies the associativity of the TLB etc. */
  {"mmu_build",0x6F,AUXREG_AC, ARC_REGISTER_READONLY},
  {"MMU_BUILD",0x6F,AUXREG_AC, ARC_REGISTER_READONLY},
  /* ARC Angel BCR . Specifies the version of the ARC Angel Dev. Board */
  { "arcangel_build",0x70,AUXREG_AC, ARC_REGISTER_READONLY},
  { "ARCANGEL_BUILD",0x70,AUXREG_AC, ARC_REGISTER_READONLY},
  /* Data Cache BCR . Associativity/Line Size/ size of the Data Cache etc. */
  {"dcache_build",0x72,AUXREG_AC, ARC_REGISTER_READONLY},
  {"DCACHE_BUILD",0x72,AUXREG_AC, ARC_REGISTER_READONLY},
  /* Information regarding multiple arc debug interfaces */
  {"madi_build",0x73,AUXREG_AC, ARC_REGISTER_READONLY},
  {"MADI_BUILD",0x73,AUXREG_AC, ARC_REGISTER_READONLY},
  /* BCR for data closely coupled memory */
  {"dccm_build",0x74,AUXREG_AC, ARC_REGISTER_READONLY},
  {"DCCM_BUILD",0x74,AUXREG_AC, ARC_REGISTER_READONLY},
  /* BCR for timers */
  {"timer_build",0x75,AUXREG_AC, ARC_REGISTER_READONLY},
  {"TIMER_BUILD",0x75,AUXREG_AC, ARC_REGISTER_READONLY},
  /* Actionpoints build */
  {"ap_build",0x76,AUXREG_AC, ARC_REGISTER_READONLY},
  {"AP_BUILD",0x76,AUXREG_AC, ARC_REGISTER_READONLY},
  /* Instruction Cache BCR */
  {"icache_build",0x77,AUXREG_AC, ARC_REGISTER_READONLY},
  {"ICACHE_BUILD",0x77,AUXREG_AC, ARC_REGISTER_READONLY},
  /* BCR for Instruction Closely Coupled Memory.
     Used to be BCR for Saturated ADD/SUB.
  */
  {"iccm_build",0x78,AUXREG_AC, ARC_REGISTER_READONLY},
  {"ICCM_BUILD",0x78,AUXREG_AC, ARC_REGISTER_READONLY},
  /* BCR for X/Y Memory */
  {"dspram_build",0x79,AUXREG_AC, ARC_REGISTER_READONLY},
  {"DSPRAM_BUILD",0x79,AUXREG_AC, ARC_REGISTER_READONLY},
  /* BCR for MAC / MUL */
  {"mac_build",0x7A,AUXREG_AC, ARC_REGISTER_READONLY},
  {"MAC_BUILD",0x7A,AUXREG_AC, ARC_REGISTER_READONLY},
  /* BCR for old 32 * 32 Multiply */
  {"multiply_build",0x7B,AUXREG_AC, ARC_REGISTER_READONLY},
  {"MULTIPLY_BUILD",0x7B,AUXREG_AC, ARC_REGISTER_READONLY},

  /* BCR for swap */
  {"swap_build",0x7C,AUXREG_AC, ARC_REGISTER_READONLY},
  {"SWAP_BUILD",0x7C,AUXREG_AC, ARC_REGISTER_READONLY},
  /* BCR For Norm */
  {"norm_build",0x7D,AUXREG_AC, ARC_REGISTER_READONLY},
  {"NORM_BUILD",0x7D,AUXREG_AC, ARC_REGISTER_READONLY},
  /* BCR for Min  / Max instructions */
  {"minmax_build",0x7E,AUXREG_AC, ARC_REGISTER_READONLY},
  {"MINMAX_BUILD",0x7E,AUXREG_AC, ARC_REGISTER_READONLY},
  /* BCR for barrel shifter */
  {"barrel_build",0x7F,AUXREG_AC, ARC_REGISTER_READONLY},
  {"BARREL_BUILD",0x7F,AUXREG_AC, ARC_REGISTER_READONLY}

d1490 2
d1493 1
a1493 7

const struct arc_operand_value *arc_reg_names = arc_reg_names_a4;
int arc_reg_names_count;



/* The suffix table for ARCtangent-A4.
d1496 1
a1496 1
static const struct arc_operand_value arc_suffixes_a4[] =
d1500 2
d1508 1
d1510 1
a1510 1
  { "pl", 3, COND, 0 },
d1512 1
a1512 1
  { "mi", 4, COND, 0 },
a1513 1
  { "cs", 5, COND, 0 },
d1515 1
a1516 1
  { "cc", 6, COND, 0 },
d1518 1
d1520 1
a1520 1
  { "vs", 7, COND, 0 },
a1521 1
  { "vc", 8, COND, 0 },
d1529 3
d1533 1
d1537 1
a1537 2
/*{ "b", 7, SIZEEXT },*/
/*{ "b", 5, SIZESEX },*/
a1540 2
/*{ "w", 8, SIZEEXT },*/
/*{ "w", 6, SIZESEX },*/
d1549 1
a1549 32
  { "cc16", 16, COND, 0 },
  { "16", 16, COND, 0 },
  { "cc17", 17, COND, 0 },
  { "17", 17, COND, 0 },
  { "cc18", 18, COND, 0 },
  { "18", 18, COND, 0 },
  { "cc19", 19, COND, 0 },
  { "19", 19, COND, 0 },
  { "cc20", 20, COND, 0 },
  { "20", 20, COND, 0 },
  { "cc21", 21, COND, 0 },
  { "21", 21, COND, 0 },
  { "cc22", 22, COND, 0 },
  { "22", 22, COND, 0 },
  { "cc23", 23, COND, 0 },
  { "23", 23, COND, 0 },
  { "cc24", 24, COND, 0 },
  { "24", 24, COND, 0 },
  { "cc25", 25, COND, 0 },
  { "25", 25, COND, 0 },
  { "cc26", 26, COND, 0 },
  { "26", 26, COND, 0 },
  { "cc27", 27, COND, 0 },
  { "27", 27, COND, 0 },
  { "cc28", 28, COND, 0 },
  { "28", 28, COND, 0 },
  { "cc29", 29, COND, 0 },
  { "29", 29, COND, 0 },
  { "cc30", 30, COND, 0 },
  { "30", 30, COND, 0 },
  { "cc31", 31, COND, 0 },
  { "31", 31, COND, 0 },
d1555 2
a1556 71

/* The suffix table for ARCompact.
   Operands with the same name must be stored together.  */

static const struct arc_operand_value arc_suffixes_ac[] =
{
  /* Entry 0 is special, default values aren't printed by the disassembler.  */
  { "", 0, -1, 0 },
  { "al", 0, COND_AC, 0 },
  { "ra", 0, COND_AC, 0 },
  { "eq", 1, COND_AC, 0 },
  { "z", 1, COND_AC, 0 },
  { "ne", 2, COND_AC, 0 },
  { "nz", 2, COND_AC, 0 },
  { "p", 3, COND_AC, 0 },
  { "pl", 3, COND_AC, 0 },
  { "n", 4, COND_AC, 0 },
  { "mi", 4, COND_AC, 0 },
  { "c", 5, COND_AC, 0 },
  { "cs", 5, COND_AC, 0 },
  { "lo", 5, COND_AC, 0 },
  { "nc", 6, COND_AC, 0 },
  { "cc", 6, COND_AC, 0 },
  { "hs", 6, COND_AC, 0 },
  { "v", 7, COND_AC, 0 },
  { "vs", 7, COND_AC, 0 },
  { "nv", 8, COND_AC, 0 },
  { "vc", 8, COND_AC, 0 },
  { "gt", 9, COND_AC, 0 },
  { "ge", 10, COND_AC, 0 },
  { "lt", 11, COND_AC, 0 },
  { "le", 12, COND_AC, 0 },
  { "hi", 13, COND_AC, 0 },
  { "ls", 14, COND_AC, 0 },
  { "pnz", 15, COND_AC, 0 },
  { "ss" , 16, COND_AC, 0 },
  { "sc" , 17, COND_AC, 0 },
  { "f", 1, FLAG_AC, 0 },
  { "nd", ARC_DELAY_NONE, DELAY_AC, 0 },
  { "nd", ARC_DELAY_NONE, JUMP_DELAY_AC, 0 },
  { "d", ARC_DELAY_NORMAL, DELAY_AC, 0 },
  { "d", ARC_DELAY_NORMAL, JUMP_DELAY_AC, 0 },
  { "b", 1, SIZE1_AC, 0 },
  { "b", 1, SIZE7_AC, 0 },
  { "b", 1, SIZE17_AC, 0 },
  { "w", 2, SIZE1_AC, 0 },
  { "w", 2, SIZE7_AC, 0 },
  { "w", 2, SIZE17_AC, 0 },
  { "x", 1, SIGN6_AC, 0 },
  { "x", 1, SIGN16_AC, 0 },
  { "a", 1, ADDRESS3_AC, 0 },
  { "a", 1, ADDRESS9_AC, 0 },
  { "a", 1, ADDRESS22_AC, 0 },
  { "aw", 1, ADDRESS3_AC, 0 },	/* This is to handle the st instr */
  { "aw", 1, ADDRESS9_AC, 0 },
  { "aw", 1, ADDRESS22_AC, 0 },
  { "ab", 2, ADDRESS3_AC, 0 },
  { "ab", 2, ADDRESS9_AC, 0 },
  { "ab", 2, ADDRESS22_AC, 0 },
  { "as", 3, ADDRESS3_AC, 0 },
  { "as", 3, ADDRESS9_AC, 0 },
  { "as", 3, ADDRESS22_AC, 0 },
  { "as", 3, ADDRESS22S_AC, 0 },
  { "di", 1, CACHEBYPASS5_AC, 0 },
  { "di", 1, CACHEBYPASS11_AC, 0 },
  { "di", 1, CACHEBYPASS15_AC, 0 }
};


const struct arc_operand_value *arc_suffixes = arc_suffixes_a4;
int arc_suffixes_count;
d1564 2
d1567 2
a1568 4

/* -------------------------------------------------------------------------- */
/*                            externally visible functions                    */
/* -------------------------------------------------------------------------- */
d1576 7
a1582 8
    {
      ARC_MACH_ARC4,
      ARC_MACH_ARC5,
      ARC_MACH_ARC6,
      ARC_MACH_ARC7
    };

  return mach_type_map[bfd_mach] | (big_p ? ARC_MACH_BIG : 0);
a1584 1

a1595 6
  /* If initialization was already done but current cpu type is different
     from the one for which initialization was done earlier, then do
     initialization again */
  if (init_p && cpu_type != flags)
    init_p = 0;

a1600 2
  /* ??? We can remove the need for arc_opcode_supported by taking it into
     account here, but I'm not sure I want to do that yet (if ever).  */
d1603 1
a1603 1
      int i;
d1605 4
a1608 46
      if (arc_mach_a4)
        {
          /* Initialize operand map table for ARCtanget-A4 */
          memset (arc_operand_map_a4, 0, sizeof (arc_operand_map_a4));

          for (i = 0; i < (int) ELEMENTS_IN (arc_operands_a4); ++i)
	    arc_operand_map_a4[arc_operands_a4[i].fmt] = i;

          /* Set the pointers to operand table, operand map table */
          arc_operands        = arc_operands_a4;
          arc_operand_map     = arc_operand_map_a4;
          arc_reg_names       = arc_reg_names_a4;
          arc_reg_names_count = ELEMENTS_IN(arc_reg_names_a4);
          arc_suffixes        = arc_suffixes_a4;
          arc_suffixes_count  = ELEMENTS_IN(arc_suffixes_a4);
        }
      else
        {
          /* Initialize operand map table for ARCompact */
          memset (arc_operand_map_ac, 0, sizeof (arc_operand_map_ac));

          for (i = 0; i < (int) ELEMENTS_IN (arc_operands_ac); ++i)
	    arc_operand_map_ac[arc_operands_ac[i].fmt] = i;

          /* Set the pointers to operand table, operand map table */
          arc_operands = arc_operands_ac;
          arc_operand_map = arc_operand_map_ac;

	  /* Codito :: Ideally all the checking should be on this
	     basis and not on flags shared across the libraries as seems
	     to be the case for A4. Would have to check that and test
	     it at some point in time.
	  */
	  if (ARC_OPCODE_CPU(flags) == ARC_MACH_ARC7)
	    {
	      arc_reg_names       = arc_reg_names_a700;
	      arc_reg_names_count = ELEMENTS_IN(arc_reg_names_a700);
	    }
	  else
	    {
	      arc_reg_names       = arc_reg_names_a500600;
	      arc_reg_names_count = ELEMENTS_IN(arc_reg_names_a500600);
	    }
          arc_suffixes       = arc_suffixes_ac;
          arc_suffixes_count = ELEMENTS_IN(arc_suffixes_ac);
        }
d1611 1
a1611 2
      memset (icode_map,  0, sizeof (icode_map));

d1613 1
a1613 1
      for (i = ELEMENTS_IN(arc_opcodes) - 1; i >= 0; --i)
a1628 1

d1635 1
a1635 3
  if (ARC_OPCODE_CPU (opcode->flags) == 0)
    return 1;
  if (ARC_OPCODE_CPU (opcode->flags) & ARC_HAVE_CPU (cpu_type))
a1639 18

/* Return non-zero if OPVAL is supported on the specified cpu.
   Cpu selection is made when calling `arc_opcode_init_tables'.  */

int
arc_opval_supported (const struct arc_operand_value *opval ATTRIBUTE_UNUSED)
{
#if 0 /* I'm leaving this is a place holder, we don't discrimnate */
  if (ARC_OPVAL_CPU (opval->flags) == 0)
    return 1;
  if (ARC_OPVAL_CPU (opval->flags) & ARC_HAVE_CPU (cpu_type))
    return 1;
  return 0;
#endif
  return(1);
}


a1647 1

a1655 1

d1668 1
a1668 1
  arc_cond_p = 0;
a1676 1

a1687 1

d1696 1
d1699 4
a1702 4
    if (type == &arc_operands[ext_oper->operand.type]
         && value == ext_oper->operand.value)
      return (&ext_oper->operand);
    ext_oper = ext_oper->next;
a1712 16


/* Ravi:  warning: function declaration isn't a prototype */
int arc_insn_is_j(arc_insn);
int ac_lpcc_insn(arc_insn insn);
int ac_add_reg_sdasym_insn(arc_insn);
int ac_get_load_sdasym_insn_type(arc_insn, int);
int ac_get_store_sdasym_insn_type(arc_insn, int);
int arc_insn_not_jl(arc_insn insn);
int arc_insn_is_j(arc_insn insn);
int a4_brk_insn(arc_insn insn);
int ac_brk_s_insn(arc_insn insn);
int ac_branch_or_jump_insn(arc_insn insn, int compact_insn_16);
int ARC700_rtie_insn(arc_insn insn);


a1718 1

a1725 305

/* Returns true if insn being encoded is a brk insn
   It can be used only for A4 architecture */
int
a4_brk_insn(arc_insn insn)

{
  return insn == 0x1ffffe00;
}


/* Returns true if insn being encoded is a brk_s insn
   It can be used only for ARCompact architecture */
int
ac_brk_s_insn(arc_insn insn)
{
  return insn == 0x7fff;
}


/* Returns 1 if insn being encoded is either branch or jump insn.
   It can be used only for ARCompact architecture */

int
ac_branch_or_jump_insn(arc_insn insn, int compact_insn_16)
{

  return ((!compact_insn_16 && ((insn & I(-1)) == I(0x4)) &&
			       (((insn >> 18) & 0xf) == 0x8)) ||
	  (compact_insn_16 && ((insn & I(-1)) == I(0xf))) ||
	  (!compact_insn_16 && ((insn & I(-1)) == I(0x1))) ||
	  (compact_insn_16 && ((insn & I(-1)) == I(0x1f))) ||
	  (!compact_insn_16 && ((insn & I(-1)) == I(0x0))) ||
	  (compact_insn_16 && ((insn & I(-1)) == I(0x1e))));
}


/* This function returns true if insn being encoded is an lpcc insn.
   Ideally, we should be doing this and the other checks using the opcode
   tables. */
int
ac_lpcc_insn(arc_insn insn)
{
    return ( ((insn & 0xfffff000) == 0x20a80000) ||
	     ((insn & 0xfffff020) == 0x20a80020));
}


/* This function returns true if insn being encoded is an add a,b,var@@sda insn */
int
ac_add_reg_sdasym_insn (arc_insn insn)
{
  return ((insn & 0xf8ff0fc0) == 0x20000f80);
}


/* This function returns true if insn being encoded is an rtie insn. */
int
ARC700_rtie_insn (arc_insn insn)
{
  return insn == 0x242f003f;
}


/* This function returns the following values for the given insns
           Insn                 Returns
           ----                 -------
    ld.as r0, [gp, var@@sda]       0
    ld/ldb/ldw r0, [gp, var@@sda]  1
    ldw.as  r0, [gp, var@@sda]     2

    ld_s r0, [gp, var@@sda]        10
    ldb_ r0,  [gp, var@@sda]       11
    ldw_s  r0, [gp, var@@sda]      12

    Any other insn                -1

    compact_insn_16 => insn is a 16-bit ARCompact insn
*/
int
ac_get_load_sdasym_insn_type (arc_insn insn, int compact_insn_16)
{
  int load_type = -1;

  /* ld[b/w]_s */
  if (compact_insn_16)
    {
      switch (insn & 0xfe00)
	{
	  /* ld_s */
	case 0xc800:
	  load_type = 10;
	  break;

	  /* ldb_s */
	case 0xca00:
	  load_type = 11;
	  break;

	  /* ldw_s */
	case 0xcc00:
	  load_type = 12;
	  break;
	}
    }
  else
    {
      /* ld/ldw/ldb */
      switch (insn & 0xf8000180)
	{
	  /* ld */
	case 0x10000000:
	  if (((insn>>9) & 3) == 3)
	    load_type = 0;
	  else
	    load_type = 1;
	  break;

	  /* ldw */
	case 0x10000100:
	  if (((insn>>9) & 3) == 3)
	    load_type = 2;
	  else
	    load_type = 1;
	  break;

	  /* ldb */
	case 0x10000080:
	  load_type = 1;
	  break;

	}
    }

  return load_type;
}


/* This function returns the following values for the given insns
           Insn                 Returns
           ----                 -------
    st.as r0, [gp, var@@sda]       0
    st/stb/stw r0, [gp, var@@sda]  1
    stw.as  r0, [gp, var@@sda]     2

    Any other insn                -1

     compact_insn_16 => insn is a 16-bit ARCompact insn
*/
int
ac_get_store_sdasym_insn_type (arc_insn insn,
			       int compact_insn_16 ATTRIBUTE_UNUSED)
{
  int store_type = -1;

  /* st/stw/stb */
  switch (insn & 0xf8000007)
    {
      /* st */
    case 0x18000000:
      if (((insn>>3) & 3) == 3)
	store_type = 0;
      else
	store_type = 1;
      break;

      /* stw */
    case 0x18000004:
      if (((insn>>3) & 3) == 3)
	store_type = 2;
      else
	store_type = 1;
      break;

      /* stb */
    case 0x18000002:
      store_type = 1;
      break;

    }

  return store_type;
}


/* Returns 1 if the given operand is a valid constant operand for
   ARCompact ISA. It can be used only for ARCompact architecture */
int
ac_constant_operand (const struct arc_operand *op)
{
  switch (op->fmt)
    {
    case '@@': /* This is valid only for A700 . The checks in the instruction patterns would take care of other checks.*/

      case 'u':
      case 'K':
      case 'L':
      case 'o':
      case 'e':
      case 'E':
      case 'j':
      case 'J':
      case 'k':
      case 'l':
      case 'm':
      case 'M':
      case 'O':
      case 'R':
	/* Operands for the Aurora SIMD ISA*/
      case '?':
      case '\14':
      case '\20':
      case '\21':
      case '\22':
      case '\23':
      case '\24':

        return 1;
    }
    return 0;
}


/* Returns non-zero if the given operand is a valid register operand for
   the Aurora SIMD operand.  */
int
ARC700_register_simd_operand (char fmt)
{
  switch (fmt)
    {
    case '*':
    case '(':
    case ')':
      return 1; /*If the operand belongs to  the Vector register(Vrxx) set*/
    case '<':
    case '>':
      return 2; /*If the operand belongs to the DMA registers (DRxx) set*/
    case '\13':
    case '{':
    case '}':
      return 3; /*If the operand belongs to the Scalar register (Ixx) set*/
    case '\15':
    case '\16':
    case '\17':
      return 4; /*If the operand belongs to the Scalar register (Kxx) set*/
    }
  return 0;
}


/* Returns 1 if the given operand is a valid register operand for
   ARCompact ISA. It can be used only for ARCompact architecture */
int
ac_register_operand (const struct arc_operand *op)
{
  switch (op->fmt)
    {
      case 'a':
      case 'b':
      case 'c':
      case 'A':
      case 'B':
      case '#':
      case 'C':
      case 'U':
      case 'g':
      case 'G':
      case 'r':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '!':
        return 1;
    }
    return 0;
}


/* Returns 1 if the given operand is a valid symbol operand for ARCompact ISA */
int
ac_symbol_operand (const struct arc_operand *op)
{
  switch (op->fmt)
    {
      case 'L':
      case 'd':
      case 'h':
      case 'H':
      case 'i':
      case 'I':
      case 'y':
      case 'Y':
      case 's':
      case 'S':
      case 'Z':
      case 'W':
        return 1;
    }
  return 0;
}


d1732 2
a1733 1
      return (arc_mach_a4 ? COND : COND_AC);
d1735 2
a1736 1
      return (arc_mach_a4 ? REG : REG_AC);
d1738 2
a1739 3
      return (arc_mach_a4 ? AUXREG : AUXREG_AC);
    default:
      abort();
d1741 1
a1743 1

d1745 1
a1745 1
get_ext_suffix (char *s, char field)
a1747 1
  char ctype;
d1749 4
a1752 71
  ctype = 0;
  switch(field){
  case 'e' : 
      ctype = arc_mach_a4 ? CACHEBYPASS5 : 0;
      break;
  case 'f' : 
      ctype = arc_mach_a4 ? FLAG : FLAG_AC;
      break;
  case 'j' : 
      ctype = arc_mach_a4 ? JUMPFLAGS : 0;
      break;
  case 'p' : 
      ctype = arc_mach_a4 ? 0 : ADDRESS9_AC;
      break;
  case 'q' : 
      ctype = arc_mach_a4 ? COND : COND_AC;
      break;
  case 't' : 
      ctype = arc_mach_a4 ? 0 : SIZE7_AC;
      break;
  case 'v' : 
      ctype = arc_mach_a4 ? ADDRESS24 : CACHEBYPASS11_AC;
      break;
  case 'w' : 
      ctype = arc_mach_a4 ? ADDRESS3 : ADDRESS3_AC;
      break;
  case 'x' : 
      ctype = arc_mach_a4 ? SIGN0 : SIGN6_AC;
      break;
  case 'y' : 
      ctype = arc_mach_a4 ? SIZE22 : 0;
      break;
  case 'z' : 
      ctype = arc_mach_a4 ? SIZE1 : SIZE1_AC;
      break;
  case 'D' : 
      ctype = arc_mach_a4 ? CACHEBYPASS26 : CACHEBYPASS5_AC;
      break;
  case 'E' : 
      ctype = arc_mach_a4 ? CACHEBYPASS14 : 0;
      break;
  case 'P' : 
      ctype = arc_mach_a4 ? 0 : ADDRESS22_AC;
      break;
  case 'T' : 
      ctype = arc_mach_a4 ? 0 : SIZE17_AC;
      break;
  case 'V' : 
      ctype = arc_mach_a4 ? 0 : CACHEBYPASS15_AC;
      break;
  case 'W' : 
      ctype = arc_mach_a4 ? ADDRESS12 : 0;
      break;
  case 'X' : 
      ctype = arc_mach_a4 ? SIGN9 : SIGN16_AC;
      break;
  case 'Z' : 
      ctype = arc_mach_a4 ? SIZE10 : 0;
      break;
  case '&' : 
      ctype = arc_mach_a4 ? 0 : ADDRESS22S_AC;
      break;
  default : 
      ctype = arc_mach_a4 ? COND : COND_AC;
      break;
      } /* end switch(field) */
  if(ctype == 0)
      ctype = arc_mach_a4 ? COND : COND_AC;
  while (suffix){
    if ((suffix->operand.type == ctype)
        && !strcmp(s,suffix->operand.name)){
a1753 1
      }
d1755 1
a1755 2
  } /* end while(suffix) */

a1758 1

a1763 16


char *
arc_aux_reg_name (int regVal)
{
  int i;

  for (i= arc_reg_names_count ; i > 0  ; i--)
    {
      if ((arc_reg_names[i].type == AUXREG_AC)
	  && (arc_reg_names[i].value == regVal ))
	return arc_reg_names[i].name;
    }

  return NULL;
}
@


1.17.18.1
log
@Check in ARCompact simulator.  A valid configuration is arc-elf.
This is not quite finished and has most likely a few files that are
obsolete & not used, but it's good enough to run gcc regression tests.
@
text
@d1 4
a4 1
/* Instruction opcode table for arc.
d6 1
a6 1
THIS FILE IS MACHINE GENERATED WITH CGEN.
d8 1
a8 5
Copyright 1996-2007 Free Software Foundation, Inc.

This file is part of the GNU Binutils and/or GDB, the GNU debugger.

   This file is free software; you can redistribute it and/or modify
d18 3
a20 5
   You should have received a copy of the GNU General Public License along
   with this program; if not, write to the Free Software Foundation, Inc.,
   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.

*/
d23 1
d26 539
a564 8
#include "symcat.h"
#include "arc-desc.h"
#include "arc-opc.h"
#include "libiberty.h"

/* -- opc.c */
unsigned int
arc_cgen_dis_hash (const char * buf, int big_p)
d566 52
a617 2
  const unsigned char *ubuf = (unsigned const char *) buf;
  int b0 = ubuf[0], b1 = ubuf[1], w;
d619 9
a627 2
  if (big_p)
    w = (b0 << 8) + b1;
d629 144
a772 1
    w = (b1 << 8) + b0;
d774 2
a775 1
  switch (w >> 11)
d777 21
a797 22
    case 0x01: /* branches */
      return ((w >> 6) | w);
    case 0x04: /* general operations */
    case 0x05: case 0x06: case 0x07: /* 32 bit extension instructions */
      return ((w >> 3) & 768) | (w & 255);
    case 0x0c: /* .s load/add register-register */
    case 0x0d: /* .s add/sub/shift register-immediate */
    case 0x0e: /* .s mov/cmp/add with high register */
      return ((w >> 6) & 992) | (w & 24);
    case 0x0f: /* 16 bit general operations */
      return ((w >> 6) & 992) | (w & 31);
    case 0x17: /* .s shift/subtract/bit immediate */
    case 0x18: /* .s stack-pointer based */
      return ((w >> 6) & 992) | ((w >> 5) & 7);
    case 0x19: /* load/add GP-relative */
    case 0x1e: /* branch conditionally */
      return ((w >> 6) & (992 | 24));
    case 0x1c: /* add/cmp immediate */
    case 0x1d: /* branch on compare register with zero */
      return ((w >> 6) & (992 | 2));
    default:
      return ((w >> 6) & 992);
d799 65
d866 10
a875 19
/* -- */
/* The hash functions are recorded here to help keep assembler code out of
   the disassembler and vice versa.  */

static int asm_hash_insn_p        (const CGEN_INSN *);
static unsigned int asm_hash_insn (const char *);
static int dis_hash_insn_p        (const CGEN_INSN *);
static unsigned int dis_hash_insn (const char *, CGEN_INSN_INT, int);

/* Instruction formats.  */

#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
#define F(f) & arc_cgen_ifld_table[ARC_##f]
#else
#define F(f) & arc_cgen_ifld_table[ARC_/**/f]
#endif
static const CGEN_IFMT ifmt_empty ATTRIBUTE_UNUSED = {
  0, 0, 0x0, { { 0 } }
};
d877 17
a893 3
static const CGEN_IFMT ifmt_b_s ATTRIBUTE_UNUSED = {
  32, 32, 0xf8000000, { { F (F_OPM) }, { F (F_COND_I2) }, { F (F_REL10) }, { F (F_DUMMY) }, { 0 } }
};
d895 2
a896 3
static const CGEN_IFMT ifmt_bcc_s ATTRIBUTE_UNUSED = {
  32, 32, 0xfe000000, { { F (F_OPM) }, { F (F_COND_I2) }, { F (F_COND_I3) }, { F (F_REL7) }, { F (F_DUMMY) }, { 0 } }
};
d898 12
a909 3
static const CGEN_IFMT ifmt_brcc_s ATTRIBUTE_UNUSED = {
  32, 32, 0xf8000000, { { F (F_OPM) }, { F (F_OP__B) }, { F (F_BRSCOND) }, { F (F_REL8) }, { F (F_DUMMY) }, { 0 } }
};
d911 2
a912 3
static const CGEN_IFMT ifmt_bcc_l ATTRIBUTE_UNUSED = {
  32, 32, 0xf8010020, { { F (F_OPM) }, { F (F_REL21) }, { F (F_BUF) }, { F (F_DELAY_N) }, { F (F_COND_Q) }, { 0 } }
};
d914 2
a915 3
static const CGEN_IFMT ifmt_b_l ATTRIBUTE_UNUSED = {
  32, 32, 0xf8010030, { { F (F_OPM) }, { F (F_REL25) }, { F (F_BUF) }, { F (F_DELAY_N) }, { F (F_RES27) }, { 0 } }
};
d917 16
a932 3
static const CGEN_IFMT ifmt_brcc_RC ATTRIBUTE_UNUSED = {
  32, 32, 0xf8010030, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_REL9) }, { F (F_BUF) }, { F (F_OP_C) }, { F (F_DELAY_N) }, { F (F_BR) }, { F (F_BRCOND) }, { 0 } }
};
d934 10
a943 3
static const CGEN_IFMT ifmt_brcc_U6 ATTRIBUTE_UNUSED = {
  32, 32, 0xf8010030, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_REL9) }, { F (F_BUF) }, { F (F_U6) }, { F (F_DELAY_N) }, { F (F_BR) }, { F (F_BRCOND) }, { 0 } }
};
d945 2
a946 3
static const CGEN_IFMT ifmt_bl_s ATTRIBUTE_UNUSED = {
  32, 32, 0xf8000000, { { F (F_OPM) }, { F (F_REL13BL) }, { F (F_DUMMY) }, { 0 } }
};
d948 2
a949 3
static const CGEN_IFMT ifmt_blcc ATTRIBUTE_UNUSED = {
  32, 32, 0xf8030020, { { F (F_OPM) }, { F (F_REL21BL) }, { F (F_BLUF) }, { F (F_BUF) }, { F (F_DELAY_N) }, { F (F_COND_Q) }, { 0 } }
};
d951 2
a952 3
static const CGEN_IFMT ifmt_bl ATTRIBUTE_UNUSED = {
  32, 32, 0xf8030030, { { F (F_OPM) }, { F (F_REL25BL) }, { F (F_BLUF) }, { F (F_BUF) }, { F (F_DELAY_N) }, { F (F_RES27) }, { 0 } }
};
d954 2
a955 3
static const CGEN_IFMT ifmt_ld_abs ATTRIBUTE_UNUSED = {
  32, 32, 0xf80007c0, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_S9) }, { F (F_LDODI) }, { F (F_LDOAA) }, { F (F_LDOZZX) }, { F (F_OP_A) }, { 0 } }
};
d957 5
a961 3
static const CGEN_IFMT ifmt_ld_abc ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0000, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_LDRAA) }, { F (F_LDR6ZZX) }, { F (F_LDRDI) }, { F (F_OP_C) }, { F (F_OP_A) }, { 0 } }
};
d963 1
a963 3
static const CGEN_IFMT ifmt_ld_s_abc ATTRIBUTE_UNUSED = {
  32, 32, 0xf8180000, { { F (F_OPM) }, { F (F_OP__B) }, { F (F_OP__C) }, { F (F_I16_43) }, { F (F_OP__A) }, { F (F_DUMMY) }, { 0 } }
};
d965 11
a975 3
static const CGEN_IFMT ifmt_ld_s_abu ATTRIBUTE_UNUSED = {
  32, 32, 0xf8000000, { { F (F_OPM) }, { F (F_OP__B) }, { F (F_OP__C) }, { F (F_U5X4) }, { F (F_DUMMY) }, { 0 } }
};
d977 1
a977 3
static const CGEN_IFMT ifmt_ld_s_absp ATTRIBUTE_UNUSED = {
  32, 32, 0xf8e00000, { { F (F_OPM) }, { F (F_OP__B) }, { F (F_OP__C) }, { F (F_U5X4) }, { F (F_DUMMY) }, { 0 } }
};
d979 13
a991 3
static const CGEN_IFMT ifmt_ld_s_gprel ATTRIBUTE_UNUSED = {
  32, 32, 0xfe000000, { { F (F_OPM) }, { F (F_I16_GP_TYPE) }, { F (F_S9X4) }, { F (F_DUMMY) }, { 0 } }
};
d993 1
a993 3
static const CGEN_IFMT ifmt_ld_s_pcrel ATTRIBUTE_UNUSED = {
  32, 32, 0xf8000000, { { F (F_OPM) }, { F (F_OP__B) }, { F (F_U8X4) }, { F (F_DUMMY) }, { 0 } }
};
d995 2
a996 3
static const CGEN_IFMT ifmt_ldb_s_abu ATTRIBUTE_UNUSED = {
  32, 32, 0xf8000000, { { F (F_OPM) }, { F (F_OP__B) }, { F (F_OP__C) }, { F (F_U5) }, { F (F_DUMMY) }, { 0 } }
};
d998 33
a1030 3
static const CGEN_IFMT ifmt_ldb_s_gprel ATTRIBUTE_UNUSED = {
  32, 32, 0xfe000000, { { F (F_OPM) }, { F (F_I16_GP_TYPE) }, { F (F_S9X1) }, { F (F_DUMMY) }, { 0 } }
};
d1032 4
a1035 3
static const CGEN_IFMT ifmt_ldw_s_abu ATTRIBUTE_UNUSED = {
  32, 32, 0xf8000000, { { F (F_OPM) }, { F (F_OP__B) }, { F (F_OP__C) }, { F (F_U5X2) }, { F (F_DUMMY) }, { 0 } }
};
d1037 1
a1037 3
static const CGEN_IFMT ifmt_ldw_s_gprel ATTRIBUTE_UNUSED = {
  32, 32, 0xfe000000, { { F (F_OPM) }, { F (F_I16_GP_TYPE) }, { F (F_S9X2) }, { F (F_DUMMY) }, { 0 } }
};
d1039 5
a1043 3
static const CGEN_IFMT ifmt_st_abs ATTRIBUTE_UNUSED = {
  32, 32, 0xf800001f, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_S9) }, { F (F_LDODI) }, { F (F_OP_C) }, { F (F_STOAA) }, { F (F_STOZZR) }, { 0 } }
};
d1045 5
a1049 3
static const CGEN_IFMT ifmt_add_L_s12__RA_ ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0000, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_S12) }, { 0 } }
};
d1051 6
a1056 3
static const CGEN_IFMT ifmt_add_ccu6__RA_ ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0020, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_U6) }, { F (F_GO_CC_TYPE) }, { F (F_COND_Q) }, { 0 } }
};
d1058 2
a1059 3
static const CGEN_IFMT ifmt_add_L_u6__RA_ ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0000, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_U6) }, { F (F_OP_A) }, { 0 } }
};
d1061 7
a1067 3
static const CGEN_IFMT ifmt_add_L_r_r__RA__RC ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0000, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_OP_C) }, { F (F_OP_A) }, { 0 } }
};
d1069 17
a1085 3
static const CGEN_IFMT ifmt_add_cc__RA__RC ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0020, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_OP_C) }, { F (F_GO_CC_TYPE) }, { F (F_COND_Q) }, { 0 } }
};
d1087 2
a1088 3
static const CGEN_IFMT ifmt_add_s_cbu3 ATTRIBUTE_UNUSED = {
  32, 32, 0xf8180000, { { F (F_OPM) }, { F (F_OP__B) }, { F (F_OP__C) }, { F (F_I16_43) }, { F (F_U3) }, { F (F_DUMMY) }, { 0 } }
};
d1090 5
a1094 3
static const CGEN_IFMT ifmt_add_s_mcah ATTRIBUTE_UNUSED = {
  32, 32, 0xf8180000, { { F (F_OPM) }, { F (F_OP__B) }, { F (F_OP_H) }, { F (F_I16_43) }, { F (F_DUMMY) }, { 0 } }
};
d1096 16
a1111 3
static const CGEN_IFMT ifmt_add_s_asspsp ATTRIBUTE_UNUSED = {
  32, 32, 0xffe00000, { { F (F_OPM) }, { F (F_OP__B) }, { F (F_OP__C) }, { F (F_U5X4) }, { F (F_DUMMY) }, { 0 } }
};
d1113 9
a1121 3
static const CGEN_IFMT ifmt_add_s_gp ATTRIBUTE_UNUSED = {
  32, 32, 0xfe000000, { { F (F_OPM) }, { F (F_I16_GP_TYPE) }, { F (F_S9X4) }, { F (F_DUMMY) }, { 0 } }
};
d1123 13
a1135 3
static const CGEN_IFMT ifmt_add_s_r_u7 ATTRIBUTE_UNUSED = {
  32, 32, 0xf8800000, { { F (F_OPM) }, { F (F_OP__B) }, { F (F_I16ADDCMPU7_TYPE) }, { F (F_U7) }, { F (F_DUMMY) }, { 0 } }
};
d1137 5
a1141 3
static const CGEN_IFMT ifmt_I16_GO_SUB_s_go ATTRIBUTE_UNUSED = {
  32, 32, 0xf81f0000, { { F (F_OPM) }, { F (F_OP__B) }, { F (F_OP__C) }, { F (F_I16_GO) }, { F (F_DUMMY) }, { 0 } }
};
d1143 1
a1143 3
static const CGEN_IFMT ifmt_sub_s_go_sub_ne ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0000, { { F (F_OPM) }, { F (F_OP__B) }, { F (F_OP__C) }, { F (F_I16_GO) }, { F (F_DUMMY) }, { 0 } }
};
d1145 6
a1150 3
static const CGEN_IFMT ifmt_sub_s_ssb ATTRIBUTE_UNUSED = {
  32, 32, 0xf8e00000, { { F (F_OPM) }, { F (F_OP__B) }, { F (F_OP__C) }, { F (F_U5) }, { F (F_DUMMY) }, { 0 } }
};
d1152 5
a1156 3
static const CGEN_IFMT ifmt_mov_L_u6_ ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0000, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_U6) }, { F (F_OP_A) }, { 0 } }
};
d1158 5
a1162 3
static const CGEN_IFMT ifmt_mov_L_r_r__RC ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0000, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_OP_C) }, { F (F_OP_A) }, { 0 } }
};
d1164 18
a1181 3
static const CGEN_IFMT ifmt_mov_s_r_u7 ATTRIBUTE_UNUSED = {
  32, 32, 0xf8000000, { { F (F_OPM) }, { F (F_OP__B) }, { F (F_U8) }, { F (F_DUMMY) }, { 0 } }
};
d1183 2
a1184 3
static const CGEN_IFMT ifmt_tst_L_s12_ ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0000, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_S12) }, { 0 } }
};
d1186 2
a1187 3
static const CGEN_IFMT ifmt_tst_ccu6_ ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0020, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_U6) }, { F (F_GO_CC_TYPE) }, { F (F_COND_Q) }, { 0 } }
};
d1189 9
a1197 3
static const CGEN_IFMT ifmt_tst_L_u6_ ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0000, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_U6) }, { F (F_OP_A) }, { 0 } }
};
d1199 4
a1202 3
static const CGEN_IFMT ifmt_tst_L_r_r__RC ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0000, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_OP_C) }, { F (F_OP_A) }, { 0 } }
};
d1204 9
a1212 3
static const CGEN_IFMT ifmt_tst_cc__RC ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0020, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_OP_C) }, { F (F_GO_CC_TYPE) }, { F (F_COND_Q) }, { 0 } }
};
d1214 14
a1227 3
static const CGEN_IFMT ifmt_j_L_r_r___RC_noilink_ ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0000, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_OP_CJ) }, { F (F_OP_A) }, { 0 } }
};
d1229 2
a1230 3
static const CGEN_IFMT ifmt_j_cc___RC_noilink_ ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0020, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_OP_CJ) }, { F (F_GO_CC_TYPE) }, { F (F_COND_Q) }, { 0 } }
};
d1232 2
a1233 3
static const CGEN_IFMT ifmt_j_L_r_r___RC_ilink_ ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0000, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_OP_CJ) }, { F (F_OP_A) }, { 0 } }
};
d1235 6
a1240 3
static const CGEN_IFMT ifmt_j_cc___RC_ilink_ ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0020, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_OP_CJ) }, { F (F_GO_CC_TYPE) }, { F (F_COND_Q) }, { 0 } }
};
d1242 2
a1243 3
static const CGEN_IFMT ifmt_j_L_s12_ ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0000, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_S12) }, { 0 } }
};
d1245 8
a1252 3
static const CGEN_IFMT ifmt_j_ccu6_ ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0020, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_U6) }, { F (F_GO_CC_TYPE) }, { F (F_COND_Q) }, { 0 } }
};
d1254 6
a1259 3
static const CGEN_IFMT ifmt_j_L_u6_ ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0000, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_U6) }, { F (F_OP_A) }, { 0 } }
};
d1261 1
a1261 3
static const CGEN_IFMT ifmt_j_s__S ATTRIBUTE_UNUSED = {
  32, 32, 0xffff0000, { { F (F_OPM) }, { F (F_OP__B) }, { F (F_OP__C) }, { F (F_I16_GO) }, { F (F_DUMMY) }, { 0 } }
};
d1263 12
a1274 3
static const CGEN_IFMT ifmt_j_L_r_r_d___RC_ ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0000, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_OP_C) }, { F (F_OP_A) }, { 0 } }
};
d1276 1
a1276 3
static const CGEN_IFMT ifmt_j_cc_d___RC_ ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0020, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_OP_C) }, { F (F_GO_CC_TYPE) }, { F (F_COND_Q) }, { 0 } }
};
d1278 8
a1285 3
static const CGEN_IFMT ifmt_lp_L_s12_ ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0000, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_S12X2) }, { 0 } }
};
d1287 10
a1296 3
static const CGEN_IFMT ifmt_lpcc_ccu6 ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0020, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_U6X2) }, { F (F_GO_CC_TYPE) }, { F (F_COND_Q) }, { 0 } }
};
d1298 2
a1299 3
static const CGEN_IFMT ifmt_lr_L_r_r___RC_ ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0000, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_OP_C) }, { F (F_OP_A) }, { 0 } }
};
d1301 1
a1301 3
static const CGEN_IFMT ifmt_lr_L_s12_ ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0000, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_S12) }, { 0 } }
};
d1303 9
a1311 3
static const CGEN_IFMT ifmt_lr_L_u6_ ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0000, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_U6) }, { F (F_OP_A) }, { 0 } }
};
d1313 7
a1319 3
static const CGEN_IFMT ifmt_asl_L_r_r__RC ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff003f, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_OP_C) }, { F (F_OP_A) }, { 0 } }
};
d1321 6
a1326 3
static const CGEN_IFMT ifmt_asl_L_u6_ ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff003f, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_U6) }, { F (F_OP_A) }, { 0 } }
};
d1328 22
a1349 3
static const CGEN_IFMT ifmt_ex_L_r_r__RC ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff003f, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_OP_C) }, { F (F_OP_A) }, { 0 } }
};
d1351 7
a1357 3
static const CGEN_IFMT ifmt_ex_L_u6_ ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff003f, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_U6) }, { F (F_OP_A) }, { 0 } }
};
d1359 3
a1361 3
static const CGEN_IFMT ifmt_swi ATTRIBUTE_UNUSED = {
  32, 32, 0xffff7fff, { { F (F_OPM) }, { F (F_OP__B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_B_5_3) }, { F (F_OP_C) }, { F (F_OP_A) }, { 0 } }
};
d1363 51
a1413 2
static const CGEN_IFMT ifmt_trap_s ATTRIBUTE_UNUSED = {
  32, 32, 0xf81f0000, { { F (F_OPM) }, { F (F_TRAPNUM) }, { F (F_I16_GO) }, { F (F_DUMMY) }, { 0 } }
d1416 1
a1416 3
static const CGEN_IFMT ifmt_brk_s ATTRIBUTE_UNUSED = {
  32, 32, 0xffff0000, { { F (F_OPM) }, { F (F_TRAPNUM) }, { F (F_I16_GO) }, { F (F_DUMMY) }, { 0 } }
};
d1418 3
a1420 3
static const CGEN_IFMT ifmt_divaw_ccu6__RA_ ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0020, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_U6) }, { F (F_GO_CC_TYPE) }, { F (F_COND_Q) }, { 0 } }
};
d1422 66
a1487 2
static const CGEN_IFMT ifmt_divaw_L_u6__RA_ ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0000, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_U6) }, { F (F_OP_A) }, { 0 } }
d1490 2
a1491 3
static const CGEN_IFMT ifmt_divaw_L_r_r__RA__RC ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0000, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_OP_C) }, { F (F_OP_A) }, { 0 } }
};
d1493 2
a1494 3
static const CGEN_IFMT ifmt_divaw_cc__RA__RC ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0020, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_OP_C) }, { F (F_GO_CC_TYPE) }, { F (F_COND_Q) }, { 0 } }
};
d1496 4
a1499 3
static const CGEN_IFMT ifmt_pop_s_b ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff0000, { { F (F_OPM) }, { F (F_OP__B) }, { F (F_OP__C) }, { F (F_U5) }, { F (F_DUMMY) }, { 0 } }
};
d1501 65
a1565 3
static const CGEN_IFMT ifmt_pop_s_blink ATTRIBUTE_UNUSED = {
  32, 32, 0xffff0000, { { F (F_OPM) }, { F (F_OP__B) }, { F (F_OP__C) }, { F (F_U5) }, { F (F_DUMMY) }, { 0 } }
};
d1567 2
a1568 3
static const CGEN_IFMT ifmt_current_loop_end ATTRIBUTE_UNUSED = {
  32, 32, 0xf8ff003f, { { F (F_OPM) }, { F (F_OP_B) }, { F (F_GO_TYPE) }, { F (F_GO_OP) }, { F (F_F) }, { F (F_OP_C) }, { F (F_OP_A) }, { 0 } }
};
d1570 1
a1570 1
#undef F
d1572 4
a1575 22
#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
#define A(a) (1 << CGEN_INSN_##a)
#else
#define A(a) (1 << CGEN_INSN_/**/a)
#endif
#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
#define OPERAND(op) ARC_OPERAND_##op
#else
#define OPERAND(op) ARC_OPERAND_/**/op
#endif
#define MNEM CGEN_SYNTAX_MNEMONIC /* syntax value for mnemonic */
#define OP(field) CGEN_SYNTAX_MAKE_FIELD (OPERAND (field))

/* The instruction table.  */

static const CGEN_OPCODE arc_cgen_insn_opcode_table[MAX_INSNS] =
{
  /* Special null first entry.
     A `num' value of zero is thus invalid.
     Also, the special `invalid' insn resides here.  */
  { { 0, 0, 0, 0 }, {{0}}, 0, {0}},
/* b$i2cond $label10 */
d1577 78
a1654 2831
    { 0, 0, 0, 0 },
    { { MNEM, OP (I2COND), ' ', OP (LABEL10), 0 } },
    & ifmt_b_s, { 0xf0000000 }
  },
/* b$i3cond$_S $label7 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (I3COND), OP (_S), ' ', OP (LABEL7), 0 } },
    & ifmt_bcc_s, { 0xf6000000 }
  },
/* br$RccS$_S $R_b,0,$label8 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (RCCS), OP (_S), ' ', OP (R_B), ',', '0', ',', OP (LABEL8), 0 } },
    & ifmt_brcc_s, { 0xe8000000 }
  },
/* b$Qcondb$_L $label21 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDB), OP (_L), ' ', OP (LABEL21), 0 } },
    & ifmt_bcc_l, { 0x0 }
  },
/* b$Qcondb$_L.d $label21 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDB), OP (_L), '.', 'd', ' ', OP (LABEL21), 0 } },
    & ifmt_bcc_l, { 0x20 }
  },
/* b$uncondb$_L $label25 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (UNCONDB), OP (_L), ' ', OP (LABEL25), 0 } },
    & ifmt_b_l, { 0x10000 }
  },
/* b$uncondb$_L.d $label25 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (UNCONDB), OP (_L), '.', 'd', ' ', OP (LABEL25), 0 } },
    & ifmt_b_l, { 0x10020 }
  },
/* b$Rcc $RB,$RC,$label9 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (RCC), ' ', OP (RB), ',', OP (RC), ',', OP (LABEL9), 0 } },
    & ifmt_brcc_RC, { 0x8010000 }
  },
/* b$Rcc.d $RB,$RC,$label9 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (RCC), '.', 'd', ' ', OP (RB), ',', OP (RC), ',', OP (LABEL9), 0 } },
    & ifmt_brcc_RC, { 0x8010020 }
  },
/* b$Rcc $RB,$U6,$label9 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (RCC), ' ', OP (RB), ',', OP (U6), ',', OP (LABEL9), 0 } },
    & ifmt_brcc_U6, { 0x8010010 }
  },
/* b$Rcc.d $RB,$U6,$label9 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (RCC), '.', 'd', ' ', OP (RB), ',', OP (U6), ',', OP (LABEL9), 0 } },
    & ifmt_brcc_U6, { 0x8010030 }
  },
/* bl$uncondj$_S $label13a */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (UNCONDJ), OP (_S), ' ', OP (LABEL13A), 0 } },
    & ifmt_bl_s, { 0xf8000000 }
  },
/* bl$Qcondj$_L $label21 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDJ), OP (_L), ' ', OP (LABEL21), 0 } },
    & ifmt_blcc, { 0x8000000 }
  },
/* bl$Qcondj$_L.d $label21 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDJ), OP (_L), '.', 'd', ' ', OP (LABEL21), 0 } },
    & ifmt_blcc, { 0x8000020 }
  },
/* bl$uncondj$_L $label25a */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (UNCONDJ), OP (_L), ' ', OP (LABEL25A), 0 } },
    & ifmt_bl, { 0x8020000 }
  },
/* bl$uncondj$_L.d $label25a */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (UNCONDJ), OP (_L), '.', 'd', ' ', OP (LABEL25A), 0 } },
    & ifmt_bl, { 0x8020020 }
  },
/* ld$LDODi $RA,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDODI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_ld_abs, { 0x10000000 }
  },
/* ld$_AW$LDODi $RA,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_AW), OP (LDODI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_ld_abs, { 0x10000200 }
  },
/* ld.ab$LDODi $RA,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDODI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_ld_abs, { 0x10000400 }
  },
/* ld.as$LDODi $RA,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDODI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_ld_abs, { 0x10000600 }
  },
/* ld$LDRDi $RA,[$RB,$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDRDI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (RC), ']', 0 } },
    & ifmt_ld_abc, { 0x20300000 }
  },
/* ld$_AW$LDRDi $RA,[$RB,$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_AW), OP (LDRDI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (RC), ']', 0 } },
    & ifmt_ld_abc, { 0x20700000 }
  },
/* ld.ab$LDRDi $RA,[$RB,$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDRDI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (RC), ']', 0 } },
    & ifmt_ld_abc, { 0x20b00000 }
  },
/* ld.as$LDRDi $RA,[$RB,$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDRDI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (RC), ']', 0 } },
    & ifmt_ld_abc, { 0x20f00000 }
  },
/* ld$_S $R_a,[$R_b,$R_c] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_A), ',', '[', OP (R_B), ',', OP (R_C), ']', 0 } },
    & ifmt_ld_s_abc, { 0x60000000 }
  },
/* ld$_S $R_c,[$R_b,$sc_u5_] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_C), ',', '[', OP (R_B), ',', OP (SC_U5_), ']', 0 } },
    & ifmt_ld_s_abu, { 0x80000000 }
  },
/* ld$_S $R_b,[$SP,$u5x4] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', '[', OP (SP), ',', OP (U5X4), ']', 0 } },
    & ifmt_ld_s_absp, { 0xc0000000 }
  },
/* ld$_S $R_b,[$GP,$sc_s9_] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', '[', OP (GP), ',', OP (SC_S9_), ']', 0 } },
    & ifmt_ld_s_gprel, { 0xc8000000 }
  },
/* ld$_S $R_b,[$PCL,$u8x4] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', '[', OP (PCL), ',', OP (U8X4), ']', 0 } },
    & ifmt_ld_s_pcrel, { 0xd0000000 }
  },
/* ldb$LDODi $RA,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDODI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_ld_abs, { 0x10000080 }
  },
/* ldb$_AW$LDODi $RA,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_AW), OP (LDODI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_ld_abs, { 0x10000280 }
  },
/* ldb.ab$LDODi $RA,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDODI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_ld_abs, { 0x10000480 }
  },
/* ldb.as$LDODi $RA,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDODI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_ld_abs, { 0x10000680 }
  },
/* ldb$LDRDi $RA,[$RB,$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDRDI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (RC), ']', 0 } },
    & ifmt_ld_abc, { 0x20320000 }
  },
/* ldb$_AW$LDRDi $RA,[$RB,$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_AW), OP (LDRDI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (RC), ']', 0 } },
    & ifmt_ld_abc, { 0x20720000 }
  },
/* ldb.ab$LDRDi $RA,[$RB,$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDRDI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (RC), ']', 0 } },
    & ifmt_ld_abc, { 0x20b20000 }
  },
/* ldb.as$LDRDi $RA,[$RB,$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDRDI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (RC), ']', 0 } },
    & ifmt_ld_abc, { 0x20f20000 }
  },
/* ldb$_S $R_a,[$R_b,$R_c] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_A), ',', '[', OP (R_B), ',', OP (R_C), ']', 0 } },
    & ifmt_ld_s_abc, { 0x60080000 }
  },
/* ldb$_S $R_c,[$R_b,$sc_u5b] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_C), ',', '[', OP (R_B), ',', OP (SC_U5B), ']', 0 } },
    & ifmt_ldb_s_abu, { 0x88000000 }
  },
/* ldb$_S $R_b,[$SP,$u5x4] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', '[', OP (SP), ',', OP (U5X4), ']', 0 } },
    & ifmt_ld_s_absp, { 0xc0200000 }
  },
/* ldb$_S $R_b,[$GP,$sc_s9b] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', '[', OP (GP), ',', OP (SC_S9B), ']', 0 } },
    & ifmt_ldb_s_gprel, { 0xca000000 }
  },
/* ldb.x$LDODi $RA,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDODI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_ld_abs, { 0x100000c0 }
  },
/* ldb$_AW.x$LDODi $RA,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_AW), '.', 'x', OP (LDODI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_ld_abs, { 0x100002c0 }
  },
/* ldb.ab.x$LDODi $RA,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDODI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_ld_abs, { 0x100004c0 }
  },
/* ldb.as.x$LDODi $RA,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDODI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_ld_abs, { 0x100006c0 }
  },
/* ldb.x$LDRDi $RA,[$RB,$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDRDI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (RC), ']', 0 } },
    & ifmt_ld_abc, { 0x20330000 }
  },
/* ldb$_AW.x$LDRDi $RA,[$RB,$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_AW), '.', 'x', OP (LDRDI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (RC), ']', 0 } },
    & ifmt_ld_abc, { 0x20730000 }
  },
/* ldb.ab.x$LDRDi $RA,[$RB,$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDRDI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (RC), ']', 0 } },
    & ifmt_ld_abc, { 0x20b30000 }
  },
/* ldb.as.x$LDRDi $RA,[$RB,$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDRDI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (RC), ']', 0 } },
    & ifmt_ld_abc, { 0x20f30000 }
  },
/* ldw$LDODi $RA,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDODI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_ld_abs, { 0x10000100 }
  },
/* ldw$_AW$LDODi $RA,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_AW), OP (LDODI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_ld_abs, { 0x10000300 }
  },
/* ldw.ab$LDODi $RA,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDODI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_ld_abs, { 0x10000500 }
  },
/* ldw.as$LDODi $RA,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDODI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_ld_abs, { 0x10000700 }
  },
/* ldw$LDRDi $RA,[$RB,$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDRDI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (RC), ']', 0 } },
    & ifmt_ld_abc, { 0x20340000 }
  },
/* ldw$_AW$LDRDi $RA,[$RB,$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_AW), OP (LDRDI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (RC), ']', 0 } },
    & ifmt_ld_abc, { 0x20740000 }
  },
/* ldw.ab$LDRDi $RA,[$RB,$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDRDI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (RC), ']', 0 } },
    & ifmt_ld_abc, { 0x20b40000 }
  },
/* ldw.as$LDRDi $RA,[$RB,$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDRDI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (RC), ']', 0 } },
    & ifmt_ld_abc, { 0x20f40000 }
  },
/* ldw$_S $R_a,[$R_b,$R_c] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_A), ',', '[', OP (R_B), ',', OP (R_C), ']', 0 } },
    & ifmt_ld_s_abc, { 0x60100000 }
  },
/* ldw$_S $R_c,[$R_b,$sc_u5w] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_C), ',', '[', OP (R_B), ',', OP (SC_U5W), ']', 0 } },
    & ifmt_ldw_s_abu, { 0x90000000 }
  },
/* ldw$_S $R_b,[$GP,$sc_s9w] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', '[', OP (GP), ',', OP (SC_S9W), ']', 0 } },
    & ifmt_ldw_s_gprel, { 0xcc000000 }
  },
/* ldw.x$LDODi $RA,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDODI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_ld_abs, { 0x10000140 }
  },
/* ldw$_AW.x$LDODi $RA,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_AW), '.', 'x', OP (LDODI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_ld_abs, { 0x10000340 }
  },
/* ldw.ab.x$LDODi $RA,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDODI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_ld_abs, { 0x10000540 }
  },
/* ldw.as.x$LDODi $RA,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDODI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_ld_abs, { 0x10000740 }
  },
/* ldw.x$LDRDi $RA,[$RB,$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDRDI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (RC), ']', 0 } },
    & ifmt_ld_abc, { 0x20350000 }
  },
/* ldw$_AW.x$LDRDi $RA,[$RB,$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_AW), '.', 'x', OP (LDRDI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (RC), ']', 0 } },
    & ifmt_ld_abc, { 0x20750000 }
  },
/* ldw.ab.x$LDRDi $RA,[$RB,$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDRDI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (RC), ']', 0 } },
    & ifmt_ld_abc, { 0x20b50000 }
  },
/* ldw.as.x$LDRDi $RA,[$RB,$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (LDRDI), ' ', OP (RA), ',', '[', OP (RB), ',', OP (RC), ']', 0 } },
    & ifmt_ld_abc, { 0x20f50000 }
  },
/* ldw$_S.x $R_c,[$R_b,$sc_u5w] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), '.', 'x', ' ', OP (R_C), ',', '[', OP (R_B), ',', OP (SC_U5W), ']', 0 } },
    & ifmt_ldw_s_abu, { 0x98000000 }
  },
/* st$STODi $RC,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (STODI), ' ', OP (RC), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_st_abs, { 0x18000000 }
  },
/* st$_AW$STODi $RC,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_AW), OP (STODI), ' ', OP (RC), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_st_abs, { 0x18000008 }
  },
/* st.ab$STODi $RC,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (STODI), ' ', OP (RC), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_st_abs, { 0x18000010 }
  },
/* st.as$STODi $RC,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (STODI), ' ', OP (RC), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_st_abs, { 0x18000018 }
  },
/* st$_S $R_c,[$R_b,$sc_u5_] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_C), ',', '[', OP (R_B), ',', OP (SC_U5_), ']', 0 } },
    & ifmt_ld_s_abu, { 0xa0000000 }
  },
/* st$_S $R_b,[$SP,$u5x4] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', '[', OP (SP), ',', OP (U5X4), ']', 0 } },
    & ifmt_ld_s_absp, { 0xc0400000 }
  },
/* stb$STODi $RC,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (STODI), ' ', OP (RC), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_st_abs, { 0x18000002 }
  },
/* stb$_AW$STODi $RC,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_AW), OP (STODI), ' ', OP (RC), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_st_abs, { 0x1800000a }
  },
/* stb.ab$STODi $RC,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (STODI), ' ', OP (RC), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_st_abs, { 0x18000012 }
  },
/* stb.as$STODi $RC,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (STODI), ' ', OP (RC), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_st_abs, { 0x1800001a }
  },
/* stb$_S $R_c,[$R_b,$sc_u5b] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_C), ',', '[', OP (R_B), ',', OP (SC_U5B), ']', 0 } },
    & ifmt_ldb_s_abu, { 0xa8000000 }
  },
/* stb$_S $R_b,[$SP,$u5x4] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', '[', OP (SP), ',', OP (U5X4), ']', 0 } },
    & ifmt_ld_s_absp, { 0xc0600000 }
  },
/* stw$STODi $RC,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (STODI), ' ', OP (RC), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_st_abs, { 0x18000004 }
  },
/* stw$_AW$STODi $RC,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_AW), OP (STODI), ' ', OP (RC), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_st_abs, { 0x1800000c }
  },
/* stw.ab$STODi $RC,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (STODI), ' ', OP (RC), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_st_abs, { 0x18000014 }
  },
/* stw.as$STODi $RC,[$RB,$s9] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (STODI), ' ', OP (RC), ',', '[', OP (RB), ',', OP (S9), ']', 0 } },
    & ifmt_st_abs, { 0x1800001c }
  },
/* stw$_S $R_c,[$R_b,$sc_u5w] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_C), ',', '[', OP (R_B), ',', OP (SC_U5W), ']', 0 } },
    & ifmt_ldw_s_abu, { 0xb0000000 }
  },
/* add$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x20800000 }
  },
/* add$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20c00020 }
  },
/* add$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x20400000 }
  },
/* add$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x20000000 }
  },
/* add$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20c00000 }
  },
/* add$_S $R_a,$R_b,$R_c */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_A), ',', OP (R_B), ',', OP (R_C), 0 } },
    & ifmt_ld_s_abc, { 0x60180000 }
  },
/* add$_S $R_c,$R_b,$u3 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_C), ',', OP (R_B), ',', OP (U3), 0 } },
    & ifmt_add_s_cbu3, { 0x68000000 }
  },
/* add$_S $R_b,$R_b,$Rh */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (RH), 0 } },
    & ifmt_add_s_mcah, { 0x70000000 }
  },
/* add$_S $R_b,$SP,$u5x4 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (SP), ',', OP (U5X4), 0 } },
    & ifmt_ld_s_absp, { 0xc0800000 }
  },
/* add$_S $SP,$SP,$u5x4 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (SP), ',', OP (SP), ',', OP (U5X4), 0 } },
    & ifmt_add_s_asspsp, { 0xc0a00000 }
  },
/* add$_S $R0,$GP,$s9x4 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R0), ',', OP (GP), ',', OP (S9X4), 0 } },
    & ifmt_add_s_gp, { 0xce000000 }
  },
/* add$_S $R_b,$R_b,$u7 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (U7), 0 } },
    & ifmt_add_s_r_u7, { 0xe0000000 }
  },
/* adc$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x20810000 }
  },
/* adc$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20c10020 }
  },
/* adc$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x20410000 }
  },
/* adc$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x20010000 }
  },
/* adc$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20c10000 }
  },
/* sub$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x20820000 }
  },
/* sub$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20c20020 }
  },
/* sub$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x20420000 }
  },
/* sub$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x20020000 }
  },
/* sub$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20c20000 }
  },
/* sub$_S $R_c,$R_b,$u3 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_C), ',', OP (R_B), ',', OP (U3), 0 } },
    & ifmt_add_s_cbu3, { 0x68080000 }
  },
/* sub$_S $R_b,$R_b,$R_c */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (R_C), 0 } },
    & ifmt_I16_GO_SUB_s_go, { 0x78020000 }
  },
/* sub$_S $NE$R_b,$R_b,$R_b */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (NE), OP (R_B), ',', OP (R_B), ',', OP (R_B), 0 } },
    & ifmt_sub_s_go_sub_ne, { 0x78c00000 }
  },
/* sub$_S $R_b,$R_b,$u5 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (U5), 0 } },
    & ifmt_sub_s_ssb, { 0xb8600000 }
  },
/* sub$_S $SP,$SP,$u5x4 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (SP), ',', OP (SP), ',', OP (U5X4), 0 } },
    & ifmt_add_s_asspsp, { 0xc1a00000 }
  },
/* sbc$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x20830000 }
  },
/* sbc$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20c30020 }
  },
/* sbc$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x20430000 }
  },
/* sbc$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x20030000 }
  },
/* sbc$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20c30000 }
  },
/* and$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x20840000 }
  },
/* and$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20c40020 }
  },
/* and$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x20440000 }
  },
/* and$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x20040000 }
  },
/* and$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20c40000 }
  },
/* and$_S $R_b,$R_b,$R_c */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (R_C), 0 } },
    & ifmt_I16_GO_SUB_s_go, { 0x78040000 }
  },
/* or$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x20850000 }
  },
/* or$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20c50020 }
  },
/* or$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x20450000 }
  },
/* or$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x20050000 }
  },
/* or$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20c50000 }
  },
/* or$_S $R_b,$R_b,$R_c */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (R_C), 0 } },
    & ifmt_I16_GO_SUB_s_go, { 0x78050000 }
  },
/* bic$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x20860000 }
  },
/* bic$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20c60020 }
  },
/* bic$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x20460000 }
  },
/* bic$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x20060000 }
  },
/* bic$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20c60000 }
  },
/* bic$_S $R_b,$R_b,$R_c */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (R_C), 0 } },
    & ifmt_I16_GO_SUB_s_go, { 0x78060000 }
  },
/* xor$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x20870000 }
  },
/* xor$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20c70020 }
  },
/* xor$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x20470000 }
  },
/* xor$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x20070000 }
  },
/* xor$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20c70000 }
  },
/* xor$_S $R_b,$R_b,$R_c */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (R_C), 0 } },
    & ifmt_I16_GO_SUB_s_go, { 0x78070000 }
  },
/* max$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x20880000 }
  },
/* max$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20c80020 }
  },
/* max$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x20480000 }
  },
/* max$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x20080000 }
  },
/* max$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20c80000 }
  },
/* min$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x20890000 }
  },
/* min$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20c90020 }
  },
/* min$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x20490000 }
  },
/* min$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x20090000 }
  },
/* min$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20c90000 }
  },
/* mov$_L$F $RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x208a0000 }
  },
/* mov$Qcondi$F $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20ca0020 }
  },
/* mov$_L$F $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_mov_L_u6_, { 0x204a0000 }
  },
/* mov$_L$F $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_mov_L_r_r__RC, { 0x200a0000 }
  },
/* mov$Qcondi$F $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20ca0000 }
  },
/* mov$_S $R_b,$Rh */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (RH), 0 } },
    & ifmt_add_s_mcah, { 0x70080000 }
  },
/* mov$_S $Rh,$R_b */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (RH), ',', OP (R_B), 0 } },
    & ifmt_add_s_mcah, { 0x70180000 }
  },
/* mov$_S $R_b,$u7 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (U7), 0 } },
    & ifmt_mov_s_r_u7, { 0xd8000000 }
  },
/* tst$_L$F1 $RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F1), ' ', OP (RB), ',', OP (S12), 0 } },
    & ifmt_tst_L_s12_, { 0x208b0000 }
  },
/* tst$Qcondi$F1 $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F1), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_tst_ccu6_, { 0x20cb0020 }
  },
/* tst$_L$F1 $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F1), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_tst_L_u6_, { 0x204b0000 }
  },
/* tst$_L$F1 $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F1), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_tst_L_r_r__RC, { 0x200b0000 }
  },
/* tst$Qcondi$F1 $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F1), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_tst_cc__RC, { 0x20cb0000 }
  },
/* tst$_S $R_b,$R_c */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_C), 0 } },
    & ifmt_I16_GO_SUB_s_go, { 0x780b0000 }
  },
/* cmp$_L$F1 $RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F1), ' ', OP (RB), ',', OP (S12), 0 } },
    & ifmt_tst_L_s12_, { 0x208c0000 }
  },
/* cmp$Qcondi$F1 $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F1), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_tst_ccu6_, { 0x20cc0020 }
  },
/* cmp$_L$F1 $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F1), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_tst_L_u6_, { 0x204c0000 }
  },
/* cmp$_L$F1 $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F1), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_tst_L_r_r__RC, { 0x200c0000 }
  },
/* cmp$Qcondi$F1 $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F1), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_tst_cc__RC, { 0x20cc0000 }
  },
/* cmp$_S $R_b,$Rh */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (RH), 0 } },
    & ifmt_add_s_mcah, { 0x70100000 }
  },
/* cmp$_S $R_b,$u7 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (U7), 0 } },
    & ifmt_add_s_r_u7, { 0xe0800000 }
  },
/* rcmp$_L$F1 $RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F1), ' ', OP (RB), ',', OP (S12), 0 } },
    & ifmt_tst_L_s12_, { 0x208d0000 }
  },
/* rcmp$Qcondi$F1 $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F1), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_tst_ccu6_, { 0x20cd0020 }
  },
/* rcmp$_L$F1 $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F1), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_tst_L_u6_, { 0x204d0000 }
  },
/* rcmp$_L$F1 $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F1), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_tst_L_r_r__RC, { 0x200d0000 }
  },
/* rcmp$Qcondi$F1 $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F1), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_tst_cc__RC, { 0x20cd0000 }
  },
/* rsub$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x208e0000 }
  },
/* rsub$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20ce0020 }
  },
/* rsub$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x204e0000 }
  },
/* rsub$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x200e0000 }
  },
/* rsub$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20ce0000 }
  },
/* bset$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x208f0000 }
  },
/* bset$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20cf0020 }
  },
/* bset$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x204f0000 }
  },
/* bset$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x200f0000 }
  },
/* bset$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20cf0000 }
  },
/* bset$_S $R_b,$R_b,$u5 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (U5), 0 } },
    & ifmt_sub_s_ssb, { 0xb8800000 }
  },
/* bclr$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x20900000 }
  },
/* bclr$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20d00020 }
  },
/* bclr$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x20500000 }
  },
/* bclr$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x20100000 }
  },
/* bclr$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20d00000 }
  },
/* bclr$_S $R_b,$R_b,$u5 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (U5), 0 } },
    & ifmt_sub_s_ssb, { 0xb8a00000 }
  },
/* btst$_L$F1 $RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F1), ' ', OP (RB), ',', OP (S12), 0 } },
    & ifmt_tst_L_s12_, { 0x20910000 }
  },
/* btst$Qcondi$F1 $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F1), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_tst_ccu6_, { 0x20d10020 }
  },
/* btst$_L$F1 $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F1), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_tst_L_u6_, { 0x20510000 }
  },
/* btst$_L$F1 $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F1), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_tst_L_r_r__RC, { 0x20110000 }
  },
/* btst$Qcondi$F1 $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F1), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_tst_cc__RC, { 0x20d10000 }
  },
/* btst$_S $R_b,$u5 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (U5), 0 } },
    & ifmt_sub_s_ssb, { 0xb8e00000 }
  },
/* bxor$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x20920000 }
  },
/* bxor$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20d20020 }
  },
/* bxor$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x20520000 }
  },
/* bxor$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x20120000 }
  },
/* bxor$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20d20000 }
  },
/* bmsk$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x20930000 }
  },
/* bmsk$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20d30020 }
  },
/* bmsk$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x20530000 }
  },
/* bmsk$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x20130000 }
  },
/* bmsk$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20d30000 }
  },
/* bmsk$_S $R_b,$R_b,$u5 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (U5), 0 } },
    & ifmt_sub_s_ssb, { 0xb8c00000 }
  },
/* add1$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x20940000 }
  },
/* add1$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20d40020 }
  },
/* add1$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x20540000 }
  },
/* add1$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x20140000 }
  },
/* add1$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20d40000 }
  },
/* add1$_S $R_b,$R_b,$R_c */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (R_C), 0 } },
    & ifmt_I16_GO_SUB_s_go, { 0x78140000 }
  },
/* add2$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x20950000 }
  },
/* add2$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20d50020 }
  },
/* add2$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x20550000 }
  },
/* add2$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x20150000 }
  },
/* add2$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20d50000 }
  },
/* add2$_S $R_b,$R_b,$R_c */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (R_C), 0 } },
    & ifmt_I16_GO_SUB_s_go, { 0x78150000 }
  },
/* add3$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x20960000 }
  },
/* add3$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20d60020 }
  },
/* add3$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x20560000 }
  },
/* add3$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x20160000 }
  },
/* add3$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20d60000 }
  },
/* add3$_S $R_b,$R_b,$R_c */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (R_C), 0 } },
    & ifmt_I16_GO_SUB_s_go, { 0x78160000 }
  },
/* sub1$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x20970000 }
  },
/* sub1$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20d70020 }
  },
/* sub1$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x20570000 }
  },
/* sub1$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x20170000 }
  },
/* sub1$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20d70000 }
  },
/* sub2$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x20980000 }
  },
/* sub2$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20d80020 }
  },
/* sub2$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x20580000 }
  },
/* sub2$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x20180000 }
  },
/* sub2$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20d80000 }
  },
/* sub3$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x20990000 }
  },
/* sub3$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20d90020 }
  },
/* sub3$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x20590000 }
  },
/* sub3$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x20190000 }
  },
/* sub3$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20d90000 }
  },
/* mpy$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x209a0000 }
  },
/* mpy$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20da0020 }
  },
/* mpy$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x205a0000 }
  },
/* mpy$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x201a0000 }
  },
/* mpy$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20da0000 }
  },
/* mpyh$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x209b0000 }
  },
/* mpyh$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20db0020 }
  },
/* mpyh$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x205b0000 }
  },
/* mpyh$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x201b0000 }
  },
/* mpyh$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20db0000 }
  },
/* mpyhu$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x209c0000 }
  },
/* mpyhu$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20dc0020 }
  },
/* mpyhu$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x205c0000 }
  },
/* mpyhu$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x201c0000 }
  },
/* mpyhu$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20dc0000 }
  },
/* mpyu$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x209d0000 }
  },
/* mpyu$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x20dd0020 }
  },
/* mpyu$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x205d0000 }
  },
/* mpyu$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x201d0000 }
  },
/* mpyu$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x20dd0000 }
  },
/* j$_L$F0 [$RC_noilink] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F0), ' ', '[', OP (RC_NOILINK), ']', 0 } },
    & ifmt_j_L_r_r___RC_noilink_, { 0x20200000 }
  },
/* j$Qcondi$F0 [$RC_noilink] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F0), ' ', '[', OP (RC_NOILINK), ']', 0 } },
    & ifmt_j_cc___RC_noilink_, { 0x20e00000 }
  },
/* j$_L$F1F [$RC_ilink] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F1F), ' ', '[', OP (RC_ILINK), ']', 0 } },
    & ifmt_j_L_r_r___RC_ilink_, { 0x20200000 }
  },
/* j$Qcondi$F1F [$RC_ilink] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F1F), ' ', '[', OP (RC_ILINK), ']', 0 } },
    & ifmt_j_cc___RC_ilink_, { 0x20e00000 }
  },
/* j$_L$F0 $s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F0), ' ', OP (S12), 0 } },
    & ifmt_j_L_s12_, { 0x20a00000 }
  },
/* j$Qcondi$F0 $U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F0), ' ', OP (U6), 0 } },
    & ifmt_j_ccu6_, { 0x20e00020 }
  },
/* j$_L$F0 $U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F0), ' ', OP (U6), 0 } },
    & ifmt_j_L_u6_, { 0x20600000 }
  },
/* j$_S [$R_b] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', '[', OP (R_B), ']', 0 } },
    & ifmt_sub_s_go_sub_ne, { 0x78000000 }
  },
/* j$_S [$R31] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', '[', OP (R31), ']', 0 } },
    & ifmt_j_s__S, { 0x7ee00000 }
  },
/* jeq$_S [$R31] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', '[', OP (R31), ']', 0 } },
    & ifmt_j_s__S, { 0x7ce00000 }
  },
/* jne$_S [$R31] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', '[', OP (R31), ']', 0 } },
    & ifmt_j_s__S, { 0x7de00000 }
  },
/* j$_L$F0.d $s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F0), '.', 'd', ' ', OP (S12), 0 } },
    & ifmt_j_L_s12_, { 0x20a10000 }
  },
/* j$Qcondi$F0.d $U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F0), '.', 'd', ' ', OP (U6), 0 } },
    & ifmt_j_ccu6_, { 0x20e10020 }
  },
/* j$_L$F0.d $U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F0), '.', 'd', ' ', OP (U6), 0 } },
    & ifmt_j_L_u6_, { 0x20610000 }
  },
/* j$_L$F0.d [$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F0), '.', 'd', ' ', '[', OP (RC), ']', 0 } },
    & ifmt_j_L_r_r_d___RC_, { 0x20210000 }
  },
/* j$Qcondi$F0.d [$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F0), '.', 'd', ' ', '[', OP (RC), ']', 0 } },
    & ifmt_j_cc_d___RC_, { 0x20e10000 }
  },
/* j$_S.d [$R_b] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), '.', 'd', ' ', '[', OP (R_B), ']', 0 } },
    & ifmt_sub_s_go_sub_ne, { 0x78200000 }
  },
/* j$_S.d [$R31] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), '.', 'd', ' ', '[', OP (R31), ']', 0 } },
    & ifmt_j_s__S, { 0x7fe00000 }
  },
/* jl$_L$F0 $s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F0), ' ', OP (S12), 0 } },
    & ifmt_j_L_s12_, { 0x20a20000 }
  },
/* jl$Qcondi$F0 $U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F0), ' ', OP (U6), 0 } },
    & ifmt_j_ccu6_, { 0x20e20020 }
  },
/* jl$_L$F0 $U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F0), ' ', OP (U6), 0 } },
    & ifmt_j_L_u6_, { 0x20620000 }
  },
/* jl$_S [$R_b] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', '[', OP (R_B), ']', 0 } },
    & ifmt_sub_s_go_sub_ne, { 0x78400000 }
  },
/* jl$_L$F0 [$RC_noilink] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F0), ' ', '[', OP (RC_NOILINK), ']', 0 } },
    & ifmt_j_L_r_r___RC_noilink_, { 0x20220000 }
  },
/* jl$Qcondi$F0 [$RC_noilink] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F0), ' ', '[', OP (RC_NOILINK), ']', 0 } },
    & ifmt_j_cc___RC_noilink_, { 0x20e20000 }
  },
/* jl$_L$F0.d $s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F0), '.', 'd', ' ', OP (S12), 0 } },
    & ifmt_j_L_s12_, { 0x20a30000 }
  },
/* jl$Qcondi$F0.d $U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F0), '.', 'd', ' ', OP (U6), 0 } },
    & ifmt_j_ccu6_, { 0x20e30020 }
  },
/* jl$_L$F0.d $U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F0), '.', 'd', ' ', OP (U6), 0 } },
    & ifmt_j_L_u6_, { 0x20630000 }
  },
/* jl$_L$F0.d [$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F0), '.', 'd', ' ', '[', OP (RC), ']', 0 } },
    & ifmt_j_L_r_r_d___RC_, { 0x20230000 }
  },
/* jl$Qcondi$F0.d [$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F0), '.', 'd', ' ', '[', OP (RC), ']', 0 } },
    & ifmt_j_cc_d___RC_, { 0x20e30000 }
  },
/* jl$_S.d [$R_b] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), '.', 'd', ' ', '[', OP (R_B), ']', 0 } },
    & ifmt_sub_s_go_sub_ne, { 0x78600000 }
  },
/* lp$_L$F0 $s12x2 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F0), ' ', OP (S12X2), 0 } },
    & ifmt_lp_L_s12_, { 0x20a80000 }
  },
/* lp$Qcondi$F0 $U6x2 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F0), ' ', OP (U6X2), 0 } },
    & ifmt_lpcc_ccu6, { 0x20e80020 }
  },
/* flag$_L$F0 $s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F0), ' ', OP (S12), 0 } },
    & ifmt_j_L_s12_, { 0x20a90000 }
  },
/* flag$Qcondi$F0 $U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F0), ' ', OP (U6), 0 } },
    & ifmt_j_ccu6_, { 0x20e90020 }
  },
/* flag$_L$F0 $U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F0), ' ', OP (U6), 0 } },
    & ifmt_j_L_u6_, { 0x20690000 }
  },
/* flag$_L$F0 $RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F0), ' ', OP (RC), 0 } },
    & ifmt_j_L_r_r_d___RC_, { 0x20290000 }
  },
/* flag$Qcondi$F0 $RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F0), ' ', OP (RC), 0 } },
    & ifmt_j_cc_d___RC_, { 0x20e90000 }
  },
/* lr$_L$F0 $RB,[$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F0), ' ', OP (RB), ',', '[', OP (RC), ']', 0 } },
    & ifmt_lr_L_r_r___RC_, { 0x202a0000 }
  },
/* lr$_L$F0 $RB,[$s12] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F0), ' ', OP (RB), ',', '[', OP (S12), ']', 0 } },
    & ifmt_lr_L_s12_, { 0x20aa0000 }
  },
/* lr$_L$F0 $RB,[$U6] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F0), ' ', OP (RB), ',', '[', OP (U6), ']', 0 } },
    & ifmt_lr_L_u6_, { 0x206a0000 }
  },
/* sr$_L$F0 $RB,[$RC] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F0), ' ', OP (RB), ',', '[', OP (RC), ']', 0 } },
    & ifmt_lr_L_r_r___RC_, { 0x202b0000 }
  },
/* sr$_L$F0 $RB,[$s12] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F0), ' ', OP (RB), ',', '[', OP (S12), ']', 0 } },
    & ifmt_lr_L_s12_, { 0x20ab0000 }
  },
/* sr$_L$F0 $RB,[$U6] */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F0), ' ', OP (RB), ',', '[', OP (U6), ']', 0 } },
    & ifmt_lr_L_u6_, { 0x206b0000 }
  },
/* asl$_L$F $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_asl_L_r_r__RC, { 0x202f0000 }
  },
/* asl$_L$F $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_asl_L_u6_, { 0x206f0000 }
  },
/* asl$_S $R_b,$R_b,$R_c */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (R_C), 0 } },
    & ifmt_I16_GO_SUB_s_go, { 0x781b0000 }
  },
/* asr$_L$F $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_asl_L_r_r__RC, { 0x202f0001 }
  },
/* asr$_L$F $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_asl_L_u6_, { 0x206f0001 }
  },
/* asr$_S $R_b,$R_b,$R_c */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (R_C), 0 } },
    & ifmt_I16_GO_SUB_s_go, { 0x781c0000 }
  },
/* lsr$_L$F $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_asl_L_r_r__RC, { 0x202f0002 }
  },
/* lsr$_L$F $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_asl_L_u6_, { 0x206f0002 }
  },
/* lsr$_S $R_b,$R_b,$R_c */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (R_C), 0 } },
    & ifmt_I16_GO_SUB_s_go, { 0x781d0000 }
  },
/* ror$_L$F $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_asl_L_r_r__RC, { 0x202f0003 }
  },
/* ror$_L$F $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_asl_L_u6_, { 0x206f0003 }
  },
/* rrc$_L$F $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_asl_L_r_r__RC, { 0x202f0004 }
  },
/* rrc$_L$F $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_asl_L_u6_, { 0x206f0004 }
  },
/* sexb$_L$F $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_asl_L_r_r__RC, { 0x202f0005 }
  },
/* sexb$_L$F $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_asl_L_u6_, { 0x206f0005 }
  },
/* sexb$_S $R_b,$R_b,$R_c */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (R_C), 0 } },
    & ifmt_I16_GO_SUB_s_go, { 0x780d0000 }
  },
/* sexw$_L$F $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_asl_L_r_r__RC, { 0x202f0006 }
  },
/* sexw$_L$F $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_asl_L_u6_, { 0x206f0006 }
  },
/* sexw$_S $R_b,$R_b,$R_c */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (R_C), 0 } },
    & ifmt_I16_GO_SUB_s_go, { 0x780e0000 }
  },
/* extb$_L$F $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_asl_L_r_r__RC, { 0x202f0007 }
  },
/* extb$_L$F $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_asl_L_u6_, { 0x206f0007 }
  },
/* extb$_S $R_b,$R_b,$R_c */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (R_C), 0 } },
    & ifmt_I16_GO_SUB_s_go, { 0x780f0000 }
  },
/* extw$_L$F $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_asl_L_r_r__RC, { 0x202f0008 }
  },
/* extw$_L$F $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_asl_L_u6_, { 0x206f0008 }
  },
/* extw$_S $R_b,$R_b,$R_c */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (R_C), 0 } },
    & ifmt_I16_GO_SUB_s_go, { 0x78100000 }
  },
/* abs$_L$F $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_asl_L_r_r__RC, { 0x202f0009 }
  },
/* abs$_L$F $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_asl_L_u6_, { 0x206f0009 }
  },
/* abs$_S $R_b,$R_b,$R_c */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (R_C), 0 } },
    & ifmt_I16_GO_SUB_s_go, { 0x78110000 }
  },
/* not$_L$F $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_asl_L_r_r__RC, { 0x202f000a }
  },
/* not$_L$F $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_asl_L_u6_, { 0x206f000a }
  },
/* not$_S $R_b,$R_b,$R_c */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (R_C), 0 } },
    & ifmt_I16_GO_SUB_s_go, { 0x78120000 }
  },
/* rlc$_L$F $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_asl_L_r_r__RC, { 0x202f000b }
  },
/* rlc$_L$F $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_asl_L_u6_, { 0x206f000b }
  },
/* ex$_L$EXDi $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (EXDI), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_ex_L_r_r__RC, { 0x202f000c }
  },
/* ex$_L$EXDi $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (EXDI), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_ex_L_u6_, { 0x206f000c }
  },
/* neg$_S $R_b,$R_b,$R_c */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (R_C), 0 } },
    & ifmt_I16_GO_SUB_s_go, { 0x78130000 }
  },
/* swi */
  {
    { 0, 0, 0, 0 },
    { { MNEM, 0 } },
    & ifmt_swi, { 0x226f003f }
  },
/* trap$_S $trapnum */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (TRAPNUM), 0 } },
    & ifmt_trap_s, { 0x781e0000 }
  },
/* brk */
  {
    { 0, 0, 0, 0 },
    { { MNEM, 0 } },
    & ifmt_swi, { 0x256f003f }
  },
/* brk_s */
  {
    { 0, 0, 0, 0 },
    { { MNEM, 0 } },
    & ifmt_brk_s, { 0x7fff0000 }
  },
/* asl$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x28800000 }
  },
/* asl$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x28c00020 }
  },
/* asl$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x28400000 }
  },
/* asl$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x28000000 }
  },
/* asl$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x28c00000 }
  },
/* asl$_S $R_c,$R_b,$u3 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_C), ',', OP (R_B), ',', OP (U3), 0 } },
    & ifmt_add_s_cbu3, { 0x68100000 }
  },
/* asl$_S $R_b,$R_b,$u5 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (U5), 0 } },
    & ifmt_sub_s_ssb, { 0xb8000000 }
  },
/* asl$_S $R_b,$R_b,$R_c */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (R_C), 0 } },
    & ifmt_I16_GO_SUB_s_go, { 0x78180000 }
  },
/* lsr$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x28810000 }
  },
/* lsr$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x28c10020 }
  },
/* lsr$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x28410000 }
  },
/* lsr$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x28010000 }
  },
/* lsr$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x28c10000 }
  },
/* lsr$_S $R_b,$R_b,$u5 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (U5), 0 } },
    & ifmt_sub_s_ssb, { 0xb8200000 }
  },
/* lsr$_S $R_b,$R_b,$R_c */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (R_C), 0 } },
    & ifmt_I16_GO_SUB_s_go, { 0x78190000 }
  },
/* asr$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x28820000 }
  },
/* asr$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x28c20020 }
  },
/* asr$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x28420000 }
  },
/* asr$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x28020000 }
  },
/* asr$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x28c20000 }
  },
/* asr$_S $R_c,$R_b,$u3 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_C), ',', OP (R_B), ',', OP (U3), 0 } },
    & ifmt_add_s_cbu3, { 0x68180000 }
  },
/* asr$_S $R_b,$R_b,$u5 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (U5), 0 } },
    & ifmt_sub_s_ssb, { 0xb8400000 }
  },
/* asr$_S $R_b,$R_b,$R_c */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_B), ',', OP (R_C), 0 } },
    & ifmt_I16_GO_SUB_s_go, { 0x781a0000 }
  },
/* ror$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x28830000 }
  },
/* ror$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x28c30020 }
  },
/* ror$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x28430000 }
  },
/* ror$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x28030000 }
  },
/* ror$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x28c30000 }
  },
/* mul64$_L$F1 $RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F1), ' ', OP (RB), ',', OP (S12), 0 } },
    & ifmt_tst_L_s12_, { 0x28840000 }
  },
/* mul64$Qcondi$F1 $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F1), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_tst_ccu6_, { 0x28c40020 }
  },
/* mul64$_L$F1 $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F1), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_tst_L_u6_, { 0x28440000 }
  },
/* mul64$_L$F1 $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F1), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_tst_L_r_r__RC, { 0x28040000 }
  },
/* mul64$Qcondi$F1 $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F1), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_tst_cc__RC, { 0x28c40000 }
  },
/* mul64$_S $R_b,$R_c */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), ',', OP (R_C), 0 } },
    & ifmt_I16_GO_SUB_s_go, { 0x780c0000 }
  },
/* mulu64$_L$F1 $RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F1), ' ', OP (RB), ',', OP (S12), 0 } },
    & ifmt_tst_L_s12_, { 0x28850000 }
  },
/* mulu64$Qcondi$F1 $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F1), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_tst_ccu6_, { 0x28c50020 }
  },
/* mulu64$_L$F1 $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F1), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_tst_L_u6_, { 0x28450000 }
  },
/* mulu64$_L$F1 $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F1), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_tst_L_r_r__RC, { 0x28050000 }
  },
/* mulu64$Qcondi$F1 $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F1), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_tst_cc__RC, { 0x28c50000 }
  },
/* adds$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x28860000 }
  },
/* adds$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x28c60020 }
  },
/* adds$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x28460000 }
  },
/* adds$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x28060000 }
  },
/* adds$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x28c60000 }
  },
/* subs$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x28870000 }
  },
/* subs$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x28c70020 }
  },
/* subs$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x28470000 }
  },
/* subs$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x28070000 }
  },
/* subs$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x28c70000 }
  },
/* divaw$_L$F0 $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F0), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_lr_L_s12_, { 0x28880000 }
  },
/* divaw$Qcondi$F0 $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F0), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_divaw_ccu6__RA_, { 0x28c80020 }
  },
/* divaw$_L$F0 $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F0), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_divaw_L_u6__RA_, { 0x28480000 }
  },
/* divaw$_L$F0 $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F0), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_divaw_L_r_r__RA__RC, { 0x28080000 }
  },
/* divaw$Qcondi$F0 $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F0), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_divaw_cc__RA__RC, { 0x28c80000 }
  },
/* asls$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x288a0000 }
  },
/* asls$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x28ca0020 }
  },
/* asls$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x284a0000 }
  },
/* asls$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x280a0000 }
  },
/* asls$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x28ca0000 }
  },
/* asrs$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x288b0000 }
  },
/* asrs$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x28cb0020 }
  },
/* asrs$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x284b0000 }
  },
/* asrs$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x280b0000 }
  },
/* asrs$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x28cb0000 }
  },
/* addsdw$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x28a80000 }
  },
/* addsdw$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x28e80020 }
  },
/* addsdw$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x28680000 }
  },
/* addsdw$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x28280000 }
  },
/* addsdw$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x28e80000 }
  },
/* subsdw$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x28a90000 }
  },
/* subsdw$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x28e90020 }
  },
/* subsdw$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x28690000 }
  },
/* subsdw$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x28290000 }
  },
/* subsdw$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x28e90000 }
  },
/* swap$_L$F $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_asl_L_r_r__RC, { 0x282f0000 }
  },
/* swap$_L$F $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_asl_L_u6_, { 0x286f0000 }
  },
/* norm$_L$F $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_asl_L_r_r__RC, { 0x282f0001 }
  },
/* norm$_L$F $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_asl_L_u6_, { 0x286f0001 }
  },
/* rnd16$_L$F $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_asl_L_r_r__RC, { 0x282f0003 }
  },
/* rnd16$_L$F $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_asl_L_u6_, { 0x286f0003 }
  },
/* abssw$_L$F $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_asl_L_r_r__RC, { 0x282f0004 }
  },
/* abssw$_L$F $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_asl_L_u6_, { 0x286f0004 }
  },
/* abss$_L$F $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_asl_L_r_r__RC, { 0x282f0005 }
  },
/* abss$_L$F $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_asl_L_u6_, { 0x286f0005 }
  },
/* negsw$_L$F $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_asl_L_r_r__RC, { 0x282f0006 }
  },
/* negsw$_L$F $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_asl_L_u6_, { 0x286f0006 }
  },
/* negs$_L$F $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_asl_L_r_r__RC, { 0x282f0007 }
  },
/* negs$_L$F $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_asl_L_u6_, { 0x286f0007 }
  },
/* normw$_L$F $RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RC), 0 } },
    & ifmt_asl_L_r_r__RC, { 0x282f0008 }
  },
/* normw$_L$F $RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (U6), 0 } },
    & ifmt_asl_L_u6_, { 0x286f0008 }
  },
/* nop_s */
  {
    { 0, 0, 0, 0 },
    { { MNEM, 0 } },
    & ifmt_j_s__S, { 0x78e00000 }
  },
/* unimp_s */
  {
    { 0, 0, 0, 0 },
    { { MNEM, 0 } },
    & ifmt_j_s__S, { 0x79e00000 }
  },
/* pop$_S $R_b */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), 0 } },
    & ifmt_pop_s_b, { 0xc0c10000 }
  },
/* pop$_S $R31 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R31), 0 } },
    & ifmt_pop_s_blink, { 0xc0d10000 }
  },
/* push$_S $R_b */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R_B), 0 } },
    & ifmt_pop_s_b, { 0xc0e10000 }
  },
/* push$_S $R31 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_S), ' ', OP (R31), 0 } },
    & ifmt_pop_s_blink, { 0xc0f10000 }
  },
/* mullw$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x28b10000 }
  },
/* mullw$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x28f10020 }
  },
/* mullw$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x28710000 }
  },
/* mullw$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x28310000 }
  },
/* mullw$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x28f10000 }
  },
/* maclw$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x28b30000 }
  },
/* maclw$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x28f30020 }
  },
/* maclw$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x28730000 }
  },
/* maclw$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x28330000 }
  },
/* maclw$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x28f30000 }
  },
/* machlw$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x28b60000 }
  },
/* machlw$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x28f60020 }
  },
/* machlw$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x28760000 }
  },
/* machlw$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x28360000 }
  },
/* machlw$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x28f60000 }
  },
/* mululw$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x28b00000 }
  },
/* mululw$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x28f00020 }
  },
/* mululw$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x28700000 }
  },
/* mululw$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x28300000 }
  },
/* mululw$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x28f00000 }
  },
/* machulw$_L$F $RB,$RB,$s12 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (S12), 0 } },
    & ifmt_add_L_s12__RA_, { 0x28b50000 }
  },
/* machulw$Qcondi$F $RB,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_ccu6__RA_, { 0x28f50020 }
  },
/* machulw$_L$F $RA,$RB,$U6 */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (U6), 0 } },
    & ifmt_add_L_u6__RA_, { 0x28750000 }
  },
/* machulw$_L$F $RA,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (_L), OP (F), ' ', OP (RA), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_L_r_r__RA__RC, { 0x28350000 }
  },
/* machulw$Qcondi$F $RB,$RB,$RC */
  {
    { 0, 0, 0, 0 },
    { { MNEM, OP (QCONDI), OP (F), ' ', OP (RB), ',', OP (RB), ',', OP (RC), 0 } },
    & ifmt_add_cc__RA__RC, { 0x28f50000 }
  },
/*  */
  {
    { 0, 0, 0, 0 },
    { { MNEM, 0 } },
    & ifmt_current_loop_end, { 0x202f003e }
  },
/*  */
  {
    { 0, 0, 0, 0 },
    { { MNEM, 0 } },
    & ifmt_current_loop_end, { 0x202f003e }
  },
/*  */
  {
    { 0, 0, 0, 0 },
    { { MNEM, 0 } },
    & ifmt_current_loop_end, { 0x202f003e }
  },
};
d1656 1
a1656 28
#undef A
#undef OPERAND
#undef MNEM
#undef OP

/* Formats for ALIAS macro-insns.  */

#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
#define F(f) & arc_cgen_ifld_table[ARC_##f]
#else
#define F(f) & arc_cgen_ifld_table[ARC_/**/f]
#endif
#undef F

/* Each non-simple macro entry points to an array of expansion possibilities.  */

#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
#define A(a) (1 << CGEN_INSN_##a)
#else
#define A(a) (1 << CGEN_INSN_/**/a)
#endif
#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
#define OPERAND(op) ARC_OPERAND_##op
#else
#define OPERAND(op) ARC_OPERAND_/**/op
#endif
#define MNEM CGEN_SYNTAX_MNEMONIC /* syntax value for mnemonic */
#define OP(field) CGEN_SYNTAX_MAKE_FIELD (OPERAND (field))
d1658 2
a1659 3
/* The macro instruction table.  */

static const CGEN_IBASE arc_cgen_macro_insn_table[] =
d1661 1
a1661 1
};
d1663 2
a1664 1
/* The macro instruction opcode table.  */
d1666 10
a1675 12
static const CGEN_OPCODE arc_cgen_macro_insn_opcode_table[] =
{
};

#undef A
#undef OPERAND
#undef MNEM
#undef OP

#ifndef CGEN_ASM_HASH_P
#define CGEN_ASM_HASH_P(insn) 1
#endif
d1677 2
a1678 3
#ifndef CGEN_DIS_HASH_P
#define CGEN_DIS_HASH_P(insn) 1
#endif
d1680 2
a1681 6
/* Return non-zero if INSN is to be added to the hash table.
   Targets are free to override CGEN_{ASM,DIS}_HASH_P in the .opc file.  */

static int
asm_hash_insn_p (insn)
     const CGEN_INSN *insn ATTRIBUTE_UNUSED;
d1683 3
a1685 1
  return CGEN_ASM_HASH_P (insn);
d1688 5
a1692 3
static int
dis_hash_insn_p (insn)
     const CGEN_INSN *insn;
d1694 2
a1695 6
  /* If building the hash table and the NO-DIS attribute is present,
     ignore.  */
  if (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_NO_DIS))
    return 0;
  return CGEN_DIS_HASH_P (insn);
}
d1697 7
a1703 8
#ifndef CGEN_ASM_HASH
#define CGEN_ASM_HASH_SIZE 127
#ifdef CGEN_MNEMONIC_OPERANDS
#define CGEN_ASM_HASH(mnem) (*(unsigned char *) (mnem) % CGEN_ASM_HASH_SIZE)
#else
#define CGEN_ASM_HASH(mnem) (*(unsigned char *) (mnem) % CGEN_ASM_HASH_SIZE) /*FIXME*/
#endif
#endif
d1705 7
a1711 9
/* It doesn't make much sense to provide a default here,
   but while this is under development we do.
   BUFFER is a pointer to the bytes of the insn, target order.
   VALUE is the first base_insn_bitsize bits as an int in host order.  */

#ifndef CGEN_DIS_HASH
#define CGEN_DIS_HASH_SIZE 256
#define CGEN_DIS_HASH(buf, value, big_p) (*(unsigned char *) (buf))
#endif
d1713 2
a1714 6
/* The result is the hash value of the insn.
   Targets are free to override CGEN_{ASM,DIS}_HASH in the .opc file.  */

static unsigned int
asm_hash_insn (mnem)
     const char * mnem;
d1716 1
a1716 1
  return CGEN_ASM_HASH (mnem);
d1719 2
a1720 8
/* BUF is a pointer to the bytes of the insn, target order.
   VALUE is the first base_insn_bitsize bits as an int in host order.  */

static unsigned int
dis_hash_insn (buf, value, big_p)
     const char * buf ATTRIBUTE_UNUSED;
     CGEN_INSN_INT value ATTRIBUTE_UNUSED;
     int big_p ATTRIBUTE_UNUSED;
d1722 2
a1723 1
  return CGEN_DIS_HASH (buf, value, big_p);
d1726 2
a1727 4
/* Set the recorded length of the insn in the CGEN_FIELDS struct.  */

static void
set_fields_bitsize (CGEN_FIELDS *fields, int size)
d1729 13
a1741 1
  CGEN_FIELDS_BITSIZE (fields) = size;
d1744 2
a1745 5
/* Function to call before using the operand instance table.
   This plugs the opcode entries and macro instructions into the cpu table.  */

void
arc_cgen_init_opcode_table (CGEN_CPU_DESC cd)
d1747 1
a1747 6
  int i;
  int num_macros = (sizeof (arc_cgen_macro_insn_table) /
		    sizeof (arc_cgen_macro_insn_table[0]));
  const CGEN_IBASE *ib = & arc_cgen_macro_insn_table[0];
  const CGEN_OPCODE *oc = & arc_cgen_macro_insn_opcode_table[0];
  CGEN_INSN *insns = xmalloc (num_macros * sizeof (CGEN_INSN));
d1749 1
a1749 2
  memset (insns, 0, num_macros * sizeof (CGEN_INSN));
  for (i = 0; i < num_macros; ++i)
d1751 4
a1754 3
      insns[i].base = &ib[i];
      insns[i].opcode = &oc[i];
      arc_cgen_build_insn_regex (& insns[i]);
d1756 2
a1757 3
  cd->macro_insn_table.init_entries = insns;
  cd->macro_insn_table.entry_size = sizeof (CGEN_IBASE);
  cd->macro_insn_table.num_init_entries = num_macros;
d1759 4
a1762 18
  oc = & arc_cgen_insn_opcode_table[0];
  insns = (CGEN_INSN *) cd->insn_table.init_entries;
  for (i = 0; i < MAX_INSNS; ++i)
    {
      insns[i].opcode = &oc[i];
      arc_cgen_build_insn_regex (& insns[i]);
    }

  cd->sizeof_fields = sizeof (CGEN_FIELDS);
  cd->set_fields_bitsize = set_fields_bitsize;

  cd->asm_hash_p = asm_hash_insn_p;
  cd->asm_hash = asm_hash_insn;
  cd->asm_hash_size = CGEN_ASM_HASH_SIZE;

  cd->dis_hash_p = dis_hash_insn_p;
  cd->dis_hash = dis_hash_insn;
  cd->dis_hash_size = CGEN_DIS_HASH_SIZE;
@


1.17.18.2
log
@gdb/insight for ARCompact (from Richard Stuckey)
@
text
@d5 1
a5 1
Copyright 1996-2005 Free Software Foundation, Inc.
d9 13
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
@


1.16
log
@Change source files over to GPLv3.
@
text
@d668 1
a668 1
		  *errmsg = _("to many shimms in load");
@


1.15
log
@Update function declarations to ISO C90 formatting
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2004, 2005
d6 3
a8 1
   This program is free software; you can redistribute it and/or modify
d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
d13 4
a16 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
@


1.14
log
@Update the address and phone number of the FSF
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2004
d25 1
d27 54
d82 4
a85 3
static arc_insn fn PARAMS ((arc_insn, const struct arc_operand *, \
			    int, const struct arc_operand_value *, long, \
			    const char **))
d87 2
a88 2
static long fn PARAMS ((arc_insn *, const struct arc_operand *, \
			int, const struct arc_operand_value **, int *))
a118 14
enum operand {OP_NONE,OP_REG,OP_SHIMM,OP_LIMM};

#define OPERANDS 3

enum operand ls_operand[OPERANDS];

struct arc_opcode *arc_ext_opcodes;
struct arc_ext_operand_value *arc_ext_operands;

#define LS_VALUE  0
#define LS_DEST   0
#define LS_BASE   1
#define LS_OFFSET 2

d169 1
a169 1
/* place holder (??? not sure if needed).  */
d173 1
a173 1
/* register A or shimm/limm indicator.  */
d177 1
a177 1
/* register B or shimm/limm indicator.  */
d181 1
a181 1
/* register C or shimm/limm indicator.  */
d185 1
a185 1
/* fake operand used to insert shimm value into most instructions.  */
d189 1
a189 1
/* fake operand used to insert limm value into most instructions.  */
d193 1
a193 1
/* shimm operand when there is no reg indicator (st).  */
d197 1
a197 1
/* shimm operand when there is no reg indicator (ld).  */
d201 1
a201 1
/* operand for base.  */
d221 1
a221 1
/* flag update bit (insertion is defered until we know how).  */
d225 1
a225 1
/* fake utility operand to finish 'f' suffix handling.  */
d229 1
a229 1
/* fake utility operand to set the 'f' flag for the "flag" insn.  */
d233 1
a233 1
/* branch delay types.  */
d237 1
a237 1
/* conditions.  */
d241 1
a241 1
/* set `cond_p' to 1 to ensure a constant is treated as a limm.  */
d245 1
a245 1
/* branch address; b, bl, and lp insns.  */
d249 1
a249 1
/* jump address; j insn (this is basically the same as 'L' except that the
d254 1
a254 1
/* jump flags; j{,l} insn value or'ed into 'J' addr for flag values.  */
d258 1
a258 1
/* size field, stored in bit 1,2.  */
d262 1
a262 1
/* size field, stored in bit 10,11.  */
d266 1
a266 1
/* size field, stored in bit 22,23.  */
d270 1
a270 1
/* sign extend field, stored in bit 0.  */
d274 1
a274 1
/* sign extend field, stored in bit 9.  */
d278 1
a278 1
/* address write back, stored in bit 3.  */
d282 1
a282 1
/* address write back, stored in bit 12.  */
d286 1
a286 1
/* address write back, stored in bit 24.  */
d290 1
a290 1
/* cache bypass, stored in bit 5.  */
d294 1
a294 1
/* cache bypass, stored in bit 14.  */
d298 1
a298 1
/* cache bypass, stored in bit 26.  */
d302 1
a302 1
/* unop macro, used to copy REGB to REGC.  */
d320 1
a320 1
/* end of list place holder.  */
d324 31
a354 3
/* Given a format letter, yields the index into `arc_operands'.
   eg: arc_operand_map['a'] = REGA.  */
unsigned char arc_operand_map[256];
d356 2
a357 1
/* ARC instructions.
d359 30
a388 3
   Longer versions of insns must appear before shorter ones (if gas sees
   "lsr r2,r3,1" when it's parsing "lsr %a,%b" it will think the ",1" is
   junk).  This isn't necessary for `ld' because of the trailing ']'.
d390 43
a432 3
   Instructions that are really macros based on other insns must appear
   before the real insn so they're chosen when disassembling.  Eg: The `mov'
   insn is really the `and' insn.  */
d434 18
a451 3
struct arc_opcode arc_opcodes[] =
{
  /* Base case instruction set (core versions 5-8)  */
d453 2
a454 52
  /* "mov" is really an "and".  */
  { "mov%.q%.f %a,%b%F%S%L%U", I(-1), I(12), ARC_MACH_5, 0, 0 },
  /* "asl" is really an "add".  */
  { "asl%.q%.f %a,%b%F%S%L%U", I(-1), I(8), ARC_MACH_5, 0, 0 },
  /* "lsl" is really an "add".  */
  { "lsl%.q%.f %a,%b%F%S%L%U", I(-1), I(8), ARC_MACH_5, 0, 0 },
  /* "nop" is really an "xor".  */
  { "nop", 0x7fffffff, 0x7fffffff, ARC_MACH_5, 0, 0 },
  /* "rlc" is really an "adc".  */
  { "rlc%.q%.f %a,%b%F%S%L%U", I(-1), I(9), ARC_MACH_5, 0, 0 },
  { "adc%.q%.f %a,%b,%c%F%S%L", I(-1), I(9), ARC_MACH_5, 0, 0 },
  { "add%.q%.f %a,%b,%c%F%S%L", I(-1), I(8), ARC_MACH_5, 0, 0 },
  { "and%.q%.f %a,%b,%c%F%S%L", I(-1), I(12), ARC_MACH_5, 0, 0 },
  { "asr%.q%.f %a,%b%F%S%L", I(-1)|C(-1), I(3)|C(1), ARC_MACH_5, 0, 0 },
  { "bic%.q%.f %a,%b,%c%F%S%L",	I(-1), I(14), ARC_MACH_5, 0, 0 },
  { "b%q%.n %B", I(-1), I(4), ARC_MACH_5 | ARC_OPCODE_COND_BRANCH, 0, 0 },
  { "bl%q%.n %B", I(-1), I(5), ARC_MACH_5 | ARC_OPCODE_COND_BRANCH, 0, 0 },
  { "extb%.q%.f %a,%b%F%S%L", I(-1)|C(-1), I(3)|C(7), ARC_MACH_5, 0, 0 },
  { "extw%.q%.f %a,%b%F%S%L", I(-1)|C(-1), I(3)|C(8), ARC_MACH_5, 0, 0 },
  { "flag%.q %b%G%S%L", I(-1)|A(-1)|C(-1), I(3)|A(ARC_REG_SHIMM_UPDATE)|C(0), ARC_MACH_5, 0, 0 },
  { "brk", 0x1ffffe00, 0x1ffffe00, ARC_MACH_7, 0, 0 },
  { "sleep", 0x1ffffe01, 0x1ffffe01, ARC_MACH_7, 0, 0 },
  { "swi", 0x1ffffe02, 0x1ffffe02, ARC_MACH_8, 0, 0 },
  /* %Q: force cond_p=1 -> no shimm values. This insn allows an
     optional flags spec.  */
  { "j%q%Q%.n%.f %b%F%J,%j", I(-1)|A(-1)|C(-1)|R(-1,7,1), I(7)|A(0)|C(0)|R(0,7,1), ARC_MACH_5 | ARC_OPCODE_COND_BRANCH, 0, 0 },
  { "j%q%Q%.n%.f %b%F%J", I(-1)|A(-1)|C(-1)|R(-1,7,1), I(7)|A(0)|C(0)|R(0,7,1), ARC_MACH_5 | ARC_OPCODE_COND_BRANCH, 0, 0 },
  /* This insn allows an optional flags spec.  */
  { "jl%q%Q%.n%.f %b%F%J,%j", I(-1)|A(-1)|C(-1)|R(-1,7,1)|R(-1,9,1), I(7)|A(0)|C(0)|R(0,7,1)|R(1,9,1), ARC_MACH_6 | ARC_OPCODE_COND_BRANCH, 0, 0 },
  { "jl%q%Q%.n%.f %b%F%J", I(-1)|A(-1)|C(-1)|R(-1,7,1)|R(-1,9,1), I(7)|A(0)|C(0)|R(0,7,1)|R(1,9,1), ARC_MACH_6 | ARC_OPCODE_COND_BRANCH, 0, 0 },
  /* Put opcode 1 ld insns first so shimm gets prefered over limm.
     "[%b]" is before "[%b,%o]" so 0 offsets don't get printed.  */
  { "ld%Z%.X%.W%.E %a,[%s]%S%L%1", I(-1)|R(-1,13,1)|R(-1,0,511), I(1)|R(0,13,1)|R(0,0,511), ARC_MACH_5, 0, 0 },
  { "ld%z%.x%.w%.e %a,[%s]%S%L%1", I(-1)|R(-1,4,1)|R(-1,6,7), I(0)|R(0,4,1)|R(0,6,7), ARC_MACH_5, 0, 0 },
  { "ld%z%.x%.w%.e %a,[%s,%O]%S%L%1", I(-1)|R(-1,4,1)|R(-1,6,7), I(0)|R(0,4,1)|R(0,6,7), ARC_MACH_5, 0, 0 },
  { "ld%Z%.X%.W%.E %a,[%s,%O]%S%L%3", I(-1)|R(-1,13,1),	I(1)|R(0,13,1), ARC_MACH_5, 0, 0 },
  { "lp%q%.n %B", I(-1), I(6), ARC_MACH_5, 0, 0 },
  { "lr %a,[%Ab]%S%L", I(-1)|C(-1), I(1)|C(0x10), ARC_MACH_5, 0, 0 },
  { "lsr%.q%.f %a,%b%F%S%L", I(-1)|C(-1), I(3)|C(2), ARC_MACH_5, 0, 0 },
  { "or%.q%.f %a,%b,%c%F%S%L", I(-1), I(13), ARC_MACH_5, 0, 0 },
  { "ror%.q%.f %a,%b%F%S%L", I(-1)|C(-1), I(3)|C(3), ARC_MACH_5, 0, 0 },
  { "rrc%.q%.f %a,%b%F%S%L", I(-1)|C(-1), I(3)|C(4), ARC_MACH_5, 0, 0 },
  { "sbc%.q%.f %a,%b,%c%F%S%L",	I(-1), I(11), ARC_MACH_5, 0, 0 },
  { "sexb%.q%.f %a,%b%F%S%L", I(-1)|C(-1), I(3)|C(5), ARC_MACH_5, 0, 0 },
  { "sexw%.q%.f %a,%b%F%S%L", I(-1)|C(-1), I(3)|C(6), ARC_MACH_5, 0, 0 },
  { "sr %c,[%Ab]%S%L", I(-1)|A(-1), I(2)|A(0x10), ARC_MACH_5, 0, 0 },
  /* "[%b]" is before "[%b,%o]" so 0 offsets don't get printed.  */
  { "st%y%.v%.D %c,[%s]%L%S%0", I(-1)|R(-1,25,1)|R(-1,21,1), I(2)|R(0,25,1)|R(0,21,1), ARC_MACH_5, 0, 0 },
  { "st%y%.v%.D %c,[%s,%o]%S%L%2", I(-1)|R(-1,25,1)|R(-1,21,1), I(2)|R(0,25,1)|R(0,21,1), ARC_MACH_5, 0, 0 },
  { "sub%.q%.f %a,%b,%c%F%S%L",	I(-1), I(10), ARC_MACH_5, 0, 0 },
  { "xor%.q%.f %a,%b,%c%F%S%L",	I(-1), I(15), ARC_MACH_5, 0, 0 }
};
d456 1
a456 1
const int arc_opcodes_count = sizeof (arc_opcodes) / sizeof (arc_opcodes[0]);
d458 7
a464 1
const struct arc_operand_value arc_reg_names[] =
d466 8
a473 1
  /* Core register set r0-r63.  */
d475 13
a487 17
  /* r0-r28 - general purpose registers.  */
  { "r0", 0, REG, 0 }, { "r1", 1, REG, 0 }, { "r2", 2, REG, 0 },
  { "r3", 3, REG, 0 }, { "r4", 4, REG, 0 }, { "r5", 5, REG, 0 },
  { "r6", 6, REG, 0 }, { "r7", 7, REG, 0 }, { "r8", 8, REG, 0 },
  { "r9", 9, REG, 0 }, { "r10", 10, REG, 0 }, { "r11", 11, REG, 0 },
  { "r12", 12, REG, 0 }, { "r13", 13, REG, 0 }, { "r14", 14, REG, 0 },
  { "r15", 15, REG, 0 }, { "r16", 16, REG, 0 }, { "r17", 17, REG, 0 },
  { "r18", 18, REG, 0 }, { "r19", 19, REG, 0 }, { "r20", 20, REG, 0 },
  { "r21", 21, REG, 0 }, { "r22", 22, REG, 0 }, { "r23", 23, REG, 0 },
  { "r24", 24, REG, 0 }, { "r25", 25, REG, 0 }, { "r26", 26, REG, 0 },
  { "r27", 27, REG, 0 }, { "r28", 28, REG, 0 },
  /* Maskable interrupt link register.  */
  { "ilink1", 29, REG, 0 },
  /* Maskable interrupt link register.  */
  { "ilink2", 30, REG, 0 },
  /* Branch-link register.  */
  { "blink", 31, REG, 0 },
d489 3
a491 11
  /* r32-r59 reserved for extensions.  */
  { "r32", 32, REG, 0 }, { "r33", 33, REG, 0 }, { "r34", 34, REG, 0 },
  { "r35", 35, REG, 0 }, { "r36", 36, REG, 0 }, { "r37", 37, REG, 0 },
  { "r38", 38, REG, 0 }, { "r39", 39, REG, 0 }, { "r40", 40, REG, 0 },
  { "r41", 41, REG, 0 }, { "r42", 42, REG, 0 }, { "r43", 43, REG, 0 },
  { "r44", 44, REG, 0 }, { "r45", 45, REG, 0 }, { "r46", 46, REG, 0 },
  { "r47", 47, REG, 0 }, { "r48", 48, REG, 0 }, { "r49", 49, REG, 0 },
  { "r50", 50, REG, 0 }, { "r51", 51, REG, 0 }, { "r52", 52, REG, 0 },
  { "r53", 53, REG, 0 }, { "r54", 54, REG, 0 }, { "r55", 55, REG, 0 },
  { "r56", 56, REG, 0 }, { "r57", 57, REG, 0 }, { "r58", 58, REG, 0 },
  { "r59", 59, REG, 0 },
d493 17
a509 8
  /* Loop count register (24 bits).  */
  { "lp_count", 60, REG, 0 },
  /* Short immediate data indicator setting flags.  */
  { "r61", 61, REG, ARC_REGISTER_READONLY },
  /* Long immediate data indicator setting flags.  */
  { "r62", 62, REG, ARC_REGISTER_READONLY },
  /* Short immediate data indicator not setting flags.  */
  { "r63", 63, REG, ARC_REGISTER_READONLY },
d511 1
a511 6
  /* Small-data base register.  */
  { "gp", 26, REG, 0 },
  /* Frame pointer.  */
  { "fp", 27, REG, 0 },
  /* Stack pointer.  */
  { "sp", 28, REG, 0 },
d513 12
a524 4
  { "r29", 29, REG, 0 },
  { "r30", 30, REG, 0 },
  { "r31", 31, REG, 0 },
  { "r60", 60, REG, 0 },
d526 5
a530 1
  /* Auxiliary register set.  */
d532 11
a542 5
  /* Auxiliary register address map:
     0xffffffff-0xffffff00 (-1..-256) - customer shimm allocation
     0xfffffeff-0x80000000 - customer limm allocation
     0x7fffffff-0x00000100 - ARC limm allocation
     0x000000ff-0x00000000 - ARC shimm allocation  */
d544 11
a554 8
  /* Base case auxiliary registers (shimm address).  */
  { "status",         0x00, AUXREG, 0 },
  { "semaphore",      0x01, AUXREG, 0 },
  { "lp_start",       0x02, AUXREG, 0 },
  { "lp_end",         0x03, AUXREG, 0 },
  { "identity",       0x04, AUXREG, ARC_REGISTER_READONLY },
  { "debug",          0x05, AUXREG, 0 },
};
d556 7
a562 7
const int arc_reg_names_count =
  sizeof (arc_reg_names) / sizeof (arc_reg_names[0]);

/* The suffix table.
   Operands with the same name must be stored together.  */

const struct arc_operand_value arc_suffixes[] =
d564 36
a599 2
  /* Entry 0 is special, default values aren't printed by the disassembler.  */
  { "", 0, -1, 0 },
d601 1
a601 83
  /* Base case condition codes.  */
  { "al", 0, COND, 0 },
  { "ra", 0, COND, 0 },
  { "eq", 1, COND, 0 },
  { "z", 1, COND, 0 },
  { "ne", 2, COND, 0 },
  { "nz", 2, COND, 0 },
  { "pl", 3, COND, 0 },
  { "p", 3, COND, 0 },
  { "mi", 4, COND, 0 },
  { "n", 4, COND, 0 },
  { "cs", 5, COND, 0 },
  { "c", 5, COND, 0 },
  { "lo", 5, COND, 0 },
  { "cc", 6, COND, 0 },
  { "nc", 6, COND, 0 },
  { "hs", 6, COND, 0 },
  { "vs", 7, COND, 0 },
  { "v", 7, COND, 0 },
  { "vc", 8, COND, 0 },
  { "nv", 8, COND, 0 },
  { "gt", 9, COND, 0 },
  { "ge", 10, COND, 0 },
  { "lt", 11, COND, 0 },
  { "le", 12, COND, 0 },
  { "hi", 13, COND, 0 },
  { "ls", 14, COND, 0 },
  { "pnz", 15, COND, 0 },

  /* Condition codes 16-31 reserved for extensions.  */

  { "f", 1, FLAG, 0 },

  { "nd", ARC_DELAY_NONE, DELAY, 0 },
  { "d", ARC_DELAY_NORMAL, DELAY, 0 },
  { "jd", ARC_DELAY_JUMP, DELAY, 0 },

  { "b", 1, SIZE1, 0 },
  { "b", 1, SIZE10, 0 },
  { "b", 1, SIZE22, 0 },
  { "w", 2, SIZE1, 0 },
  { "w", 2, SIZE10, 0 },
  { "w", 2, SIZE22, 0 },
  { "x", 1, SIGN0, 0 },
  { "x", 1, SIGN9, 0 },
  { "a", 1, ADDRESS3, 0 },
  { "a", 1, ADDRESS12, 0 },
  { "a", 1, ADDRESS24, 0 },

  { "di", 1, CACHEBYPASS5, 0 },
  { "di", 1, CACHEBYPASS14, 0 },
  { "di", 1, CACHEBYPASS26, 0 },
};

const int arc_suffixes_count =
  sizeof (arc_suffixes) / sizeof (arc_suffixes[0]);

/* Indexed by first letter of opcode.  Points to chain of opcodes with same
   first letter.  */
static struct arc_opcode *opcode_map[26 + 1];

/* Indexed by insn code.  Points to chain of opcodes with same insn code.  */
static struct arc_opcode *icode_map[32];

/* Configuration flags.  */

/* Various ARC_HAVE_XXX bits.  */
static int cpu_type;

/* Translate a bfd_mach_arc_xxx value to a ARC_MACH_XXX value.  */

int
arc_get_opcode_mach (bfd_mach, big_p)
     int bfd_mach, big_p;
{
  static int mach_type_map[] =
  {
    ARC_MACH_5,
    ARC_MACH_6,
    ARC_MACH_7,
    ARC_MACH_8
  };
  return mach_type_map[bfd_mach - bfd_mach_arc_5] | (big_p ? ARC_MACH_BIG : 0);
d604 2
a605 2
/* Initialize any tables that need it.
   Must be called once at start up (or when first needed).
d607 7
a613 6
   FLAGS is a set of bits that say what version of the cpu we have,
   and in particular at least (one of) ARC_MACH_XXX.  */

void
arc_opcode_init_tables (flags)
     int flags;
d615 1
a615 1
  static int init_p = 0;
d617 10
a626 6
  cpu_type = flags;

  /* We may be intentionally called more than once (for example gdb will call
     us each time the user switches cpu).  These tables only need to be init'd
     once though.  */
  if (!init_p)
d628 16
a643 1
      register int i,n;
d645 12
a656 9
      memset (arc_operand_map, 0, sizeof (arc_operand_map));
      n = sizeof (arc_operands) / sizeof (arc_operands[0]);
      for (i = 0; i < n; ++i)
	arc_operand_map[arc_operands[i].fmt] = i;

      memset (opcode_map, 0, sizeof (opcode_map));
      memset (icode_map, 0, sizeof (icode_map));
      /* Scan the table backwards so macros appear at the front.  */
      for (i = arc_opcodes_count - 1; i >= 0; --i)
d658 37
a694 8
	  int opcode_hash = ARC_HASH_OPCODE (arc_opcodes[i].syntax);
	  int icode_hash = ARC_HASH_ICODE (arc_opcodes[i].value);

	  arc_opcodes[i].next_asm = opcode_map[opcode_hash];
	  opcode_map[opcode_hash] = &arc_opcodes[i];

	  arc_opcodes[i].next_dis = icode_map[icode_hash];
	  icode_map[icode_hash] = &arc_opcodes[i];
a695 2

      init_p = 1;
d697 2
d701 1
a701 2
/* Return non-zero if OPCODE is supported on the specified cpu.
   Cpu selection is made when calling `arc_opcode_init_tables'.  */
d703 6
a708 3
int
arc_opcode_supported (opcode)
     const struct arc_opcode *opcode;
d710 20
a729 2
  if (ARC_OPCODE_CPU (opcode->flags) <= cpu_type)
    return 1;
d733 4
a736 1
/* Return the first insn in the chain for assembling INSN.  */
d738 9
a746 5
const struct arc_opcode *
arc_opcode_lookup_asm (insn)
     const char *insn;
{
  return opcode_map[ARC_HASH_OPCODE (insn)];
d749 1
a749 1
/* Return the first insn in the chain for disassembling INSN.  */
d751 7
a757 3
const struct arc_opcode *
arc_opcode_lookup_dis (insn)
     unsigned int insn;
d759 12
a770 14
  return icode_map[ARC_HASH_ICODE (insn)];
}

/* Nonzero if we've seen an 'f' suffix (in certain insns).  */
static int flag_p;

/* Nonzero if we've finished processing the 'f' suffix.  */
static int flagshimm_handled_p;

/* Nonzero if we've seen a 'a' suffix (address writeback).  */
static int addrwb_p;

/* Nonzero if we've seen a 'q' suffix (condition code).  */
static int cond_p;
d772 8
a779 2
/* Nonzero if we've inserted a nullify condition.  */
static int nullify_p;
d781 18
a798 2
/* The value of the a nullify condition we inserted.  */
static int nullify;
d800 23
a822 2
/* Nonzero if we've inserted jumpflags.  */
static int jumpflags_p;
d824 1
a824 2
/* Nonzero if we've inserted a shimm.  */
static int shimm_p;
d826 12
a837 3
/* The value of the shimm we inserted (each insn only gets one but it can
   appear multiple times).  */
static int shimm;
d839 1
a839 3
/* Nonzero if we've inserted a limm (during assembly) or seen a limm
   (during disassembly).  */
static int limm_p;
d841 22
a862 5
/* The value of the limm we inserted.  Each insn only gets one but it can
   appear multiple times.  */
static long limm;

/* Insertion functions.  */
d864 1
a864 1
/* Called by the assembler before parsing an instruction.  */
d866 6
a871 2
void
arc_opcode_init_insert ()
d873 1
a873 1
  int i;
d875 16
a890 12
  for(i = 0; i < OPERANDS; i++)
    ls_operand[i] = OP_NONE;

  flag_p = 0;
  flagshimm_handled_p = 0;
  cond_p = 0;
  addrwb_p = 0;
  shimm_p = 0;
  limm_p = 0;
  jumpflags_p = 0;
  nullify_p = 0;
  nullify = 0; /* the default is important.  */
d893 2
a894 2
/* Called by the assembler to see if the insn has a limm operand.
   Also called by the disassembler to see if the insn contains a limm.  */
d896 7
a902 3
int
arc_opcode_limm_p (limmp)
     long *limmp;
d904 3
a906 3
  if (limmp)
    *limmp = limm;
  return limm_p;
d909 5
a913 2
/* Insert a value into a register field.
   If REG is NULL, then this is actually a constant.
d915 5
a919 1
   We must also handle auxiliary registers for lr/sr insns.  */
d922 6
a927 7
insert_reg (insn, operand, mods, reg, value, errmsg)
     arc_insn insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value *reg;
     long value;
     const char **errmsg;
d929 2
a930 2
  static char buf[100];
  enum operand op_type = OP_NONE;
d932 10
a941 15
  if (reg == NULL)
    {
      /* We have a constant that also requires a value stored in a register
	 field.  Handle these by updating the register field and saving the
	 value for later handling by either %S (shimm) or %L (limm).  */

      /* Try to use a shimm value before a limm one.  */
      if (ARC_SHIMM_CONST_P (value)
	  /* If we've seen a conditional suffix we have to use a limm.  */
	  && !cond_p
	  /* If we already have a shimm value that is different than ours
	     we have to use a limm.  */
	  && (!shimm_p || shimm == value))
	{
	  int marker;
d943 2
a944 2
	  op_type = OP_SHIMM;
	  /* forget about shimm as dest mlm.  */
d946 2
a947 32
	  if ('a' != operand->fmt)
	    {
	      shimm_p = 1;
	      shimm = value;
	      flagshimm_handled_p = 1;
	      marker = flag_p ? ARC_REG_SHIMM_UPDATE : ARC_REG_SHIMM;
	    }
	  else
	    {
	      /* don't request flag setting on shimm as dest.  */
	      marker = ARC_REG_SHIMM;
	    }
	  insn |= marker << operand->shift;
	  /* insn |= value & 511; - done later.  */
	}
      /* We have to use a limm.  If we've already seen one they must match.  */
      else if (!limm_p || limm == value)
	{
	  op_type = OP_LIMM;
	  limm_p = 1;
	  limm = value;
	  insn |= ARC_REG_LIMM << operand->shift;
	  /* The constant is stored later.  */
	}
      else
	{
	  *errmsg = "unable to fit different valued constants into instruction";
	}
    }
  else
    {
      /* We have to handle both normal and auxiliary registers.  */
d949 2
a950 43
      if (reg->type == AUXREG)
	{
	  if (!(mods & ARC_MOD_AUXREG))
	    *errmsg = "auxiliary register not allowed here";
	  else
	    {
	      if ((insn & I(-1)) == I(2)) /* check for use validity.  */
		{
		  if (reg->flags & ARC_REGISTER_READONLY)
		    *errmsg = "attempt to set readonly register";
		}
	      else
		{
		  if (reg->flags & ARC_REGISTER_WRITEONLY)
		    *errmsg = "attempt to read writeonly register";
		}
	      insn |= ARC_REG_SHIMM << operand->shift;
	      insn |= reg->value << arc_operands[reg->type].shift;
	    }
	}
      else
	{
	  /* check for use validity.  */
	  if ('a' == operand->fmt || ((insn & I(-1)) < I(2)))
	    {
	      if (reg->flags & ARC_REGISTER_READONLY)
		*errmsg = "attempt to set readonly register";
	    }
	  if ('a' != operand->fmt)
	    {
	      if (reg->flags & ARC_REGISTER_WRITEONLY)
		*errmsg = "attempt to read writeonly register";
	    }
	  /* We should never get an invalid register number here.  */
	  if ((unsigned int) reg->value > 60)
	    {
	      sprintf (buf, "invalid register number `%d'", reg->value);
	      *errmsg = buf;
	    }
	  insn |= reg->value << operand->shift;
	  op_type = OP_REG;
	}
    }
d952 2
a953 18
  switch (operand->fmt)
    {
    case 'a':
      ls_operand[LS_DEST] = op_type;
      break;
    case 's':
      ls_operand[LS_BASE] = op_type;
      break;
    case 'c':
      if ((insn & I(-1)) == I(2))
	ls_operand[LS_VALUE] = op_type;
      else
	ls_operand[LS_OFFSET] = op_type;
      break;
    case 'o': case 'O':
      ls_operand[LS_OFFSET] = op_type;
      break;
    }
d955 3
d961 1
a961 1
/* Called when we see an 'f' flag.  */
d964 6
a969 7
insert_flag (insn, operand, mods, reg, value, errmsg)
     arc_insn insn;
     const struct arc_operand *operand ATTRIBUTE_UNUSED;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value ATTRIBUTE_UNUSED;
     const char **errmsg ATTRIBUTE_UNUSED;
d971 1
a971 4
  /* We can't store anything in the insn until we've parsed the registers.
     Just record the fact that we've got this flag.  `insert_reg' will use it
     to store the correct value (ARC_REG_SHIMM_UPDATE or bit 0x100).  */
  flag_p = 1;
d975 1
a975 1
/* Called when we see an nullify condition.  */
d978 6
a983 7
insert_nullify (insn, operand, mods, reg, value, errmsg)
     arc_insn insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value;
     const char **errmsg ATTRIBUTE_UNUSED;
d985 3
a987 3
  nullify_p = 1;
  insn |= (value & ((1 << operand->bits) - 1)) << operand->shift;
  nullify = value;
d991 13
a1003 3
/* Called after completely building an insn to ensure the 'f' flag gets set
   properly.  This is needed because we don't know how to set this flag until
   we've parsed the registers.  */
d1006 6
a1011 7
insert_flagfinish (insn, operand, mods, reg, value, errmsg)
     arc_insn insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value ATTRIBUTE_UNUSED;
     const char **errmsg ATTRIBUTE_UNUSED;
d1013 1
a1013 1
  if (flag_p && !flagshimm_handled_p)
d1015 9
a1023 4
      if (shimm_p)
	abort ();
      flagshimm_handled_p = 1;
      insn |= (1 << operand->shift);
d1027 7
d1035 1
a1035 1
/* Called when we see a conditional flag (eg: .eq).  */
d1037 2
a1038 8
static arc_insn
insert_cond (insn, operand, mods, reg, value, errmsg)
     arc_insn insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value;
     const char **errmsg ATTRIBUTE_UNUSED;
d1040 1
a1040 3
  cond_p = 1;
  insn |= (value & ((1 << operand->bits) - 1)) << operand->shift;
  return insn;
d1043 15
a1057 5
/* Used in the "j" instruction to prevent constants from being interpreted as
   shimm values (which the jump insn doesn't accept).  This can also be used
   to force the use of limm values in other situations (eg: ld r0,[foo] uses
   this).
   ??? The mechanism is sound.  Access to it is a bit klunky right now.  */
d1059 6
a1064 11
static arc_insn
insert_forcelimm (insn, operand, mods, reg, value, errmsg)
     arc_insn insn;
     const struct arc_operand *operand ATTRIBUTE_UNUSED;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value ATTRIBUTE_UNUSED;
     const char **errmsg ATTRIBUTE_UNUSED;
{
  cond_p = 1;
  return insn;
d1067 13
a1079 8
static arc_insn
insert_addr_wb (insn, operand, mods, reg, value, errmsg)
     arc_insn insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value ATTRIBUTE_UNUSED;
     const char **errmsg ATTRIBUTE_UNUSED;
d1081 6
a1086 3
  addrwb_p = 1 << operand->shift;
  return insn;
}
d1088 2
a1089 10
static arc_insn
insert_base (insn, operand, mods, reg, value, errmsg)
     arc_insn insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value *reg;
     long value;
     const char **errmsg;
{
  if (reg != NULL)
d1091 15
a1105 4
      arc_insn myinsn;
      myinsn = insert_reg (0, operand,mods, reg, value, errmsg) >> operand->shift;
      insn |= B(myinsn);
      ls_operand[LS_BASE] = OP_REG;
d1107 1
a1107 1
  else if (ARC_SHIMM_CONST_P (value) && !cond_p)
d1109 4
a1112 1
      if (shimm_p && value != shimm)
d1114 3
a1116 6
	  /* convert the previous shimm operand to a limm.  */
	  limm_p = 1;
	  limm = shimm;
	  insn &= ~C(-1); /* we know where the value is in insn.  */
	  insn |= C(ARC_REG_LIMM);
	  ls_operand[LS_VALUE] = OP_LIMM;
d1118 5
a1122 5
      insn |= ARC_REG_SHIMM << operand->shift;
      shimm_p = 1;
      shimm = value;
      ls_operand[LS_BASE] = OP_SHIMM;
      ls_operand[LS_OFFSET] = OP_SHIMM;
d1124 1
a1124 1
  else
d1126 2
a1127 5
      if (limm_p && value != limm)
	{
	  *errmsg = "too many long constants";
	  return insn;
	}
d1129 4
a1132 3
      limm = value;
      insn |= B(ARC_REG_LIMM);
      ls_operand[LS_BASE] = OP_LIMM;
d1135 5
a1139 2
  return insn;
}
d1141 1
a1141 2
/* Used in ld/st insns to handle the offset field. We don't try to
   match operand syntax here. we catch bad combinations later.  */
d1143 6
a1148 10
static arc_insn
insert_offset (insn, operand, mods, reg, value, errmsg)
     arc_insn insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value *reg;
     long value;
     const char **errmsg;
{
  long minval, maxval;
d1150 3
a1152 1
  if (reg != NULL)
d1154 6
a1159 6
      arc_insn myinsn;
      myinsn = insert_reg (0,operand,mods,reg,value,errmsg) >> operand->shift;
      ls_operand[LS_OFFSET] = OP_REG;
      if (operand->flags & ARC_OPERAND_LOAD) /* not if store, catch it later.  */
	if ((insn & I(-1)) != I(1)) /* not if opcode == 1, catch it later.  */
	  insn |= C(myinsn);
d1161 2
a1162 1
  else
d1164 9
a1172 7
      /* This is *way* more general than necessary, but maybe some day it'll
	 be useful.  */
      if (operand->flags & ARC_OPERAND_SIGNED)
	{
	  minval = -(1 << (operand->bits - 1));
	  maxval = (1 << (operand->bits - 1)) - 1;
	}
d1174 36
a1209 61
	{
	  minval = 0;
	  maxval = (1 << operand->bits) - 1;
	}
      if ((cond_p && !limm_p) || (value < minval || value > maxval))
	{
	  if (limm_p && value != limm)
	    {
	      *errmsg = "too many long constants";
	    }
	  else
	    {
	      limm_p = 1;
	      limm = value;
	      if (operand->flags & ARC_OPERAND_STORE)
		insn |= B(ARC_REG_LIMM);
	      if (operand->flags & ARC_OPERAND_LOAD)
		insn |= C(ARC_REG_LIMM);
	      ls_operand[LS_OFFSET] = OP_LIMM;
	    }
	}
      else
	{
	  if ((value < minval || value > maxval))
	    *errmsg = "need too many limms";
	  else if (shimm_p && value != shimm)
	    {
	      /* check for bad operand combinations before we lose info about them.  */
	      if ((insn & I(-1)) == I(1))
		{
		  *errmsg = "to many shimms in load";
		  goto out;
		}
	      if (limm_p && operand->flags & ARC_OPERAND_LOAD)
		{
		  *errmsg = "too many long constants";
		  goto out;
		}
	      /* convert what we thought was a shimm to a limm.  */
	      limm_p = 1;
	      limm = shimm;
	      if (ls_operand[LS_VALUE] == OP_SHIMM && operand->flags & ARC_OPERAND_STORE)
		{
		  insn &= ~C(-1);
		  insn |= C(ARC_REG_LIMM);
		  ls_operand[LS_VALUE] = OP_LIMM;
		}
	      if (ls_operand[LS_BASE] == OP_SHIMM && operand->flags & ARC_OPERAND_STORE)
		{
		  insn &= ~B(-1);
		  insn |= B(ARC_REG_LIMM);
		  ls_operand[LS_BASE] = OP_LIMM;
		}
	    }
	  shimm = value;
	  shimm_p = 1;
	  ls_operand[LS_OFFSET] = OP_SHIMM;
	}
    }
 out:
  return insn;
d1212 4
a1215 1
/* Used in st insns to do final disasemble syntax check.  */
d1218 5
a1222 6
extract_st_syntax (insn, operand, mods, opval, invalid)
     arc_insn *insn;
     const struct arc_operand *operand ATTRIBUTE_UNUSED;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value **opval ATTRIBUTE_UNUSED;
     int *invalid;
d1224 8
a1231 4
#define ST_SYNTAX(V,B,O) \
((ls_operand[LS_VALUE]  == (V) && \
  ls_operand[LS_BASE]   == (B) && \
  ls_operand[LS_OFFSET] == (O)))
d1233 5
a1237 16
  if (!((ST_SYNTAX(OP_REG,OP_REG,OP_NONE) && (insn[0] & 511) == 0)
	|| ST_SYNTAX(OP_REG,OP_LIMM,OP_NONE)
	|| (ST_SYNTAX(OP_SHIMM,OP_REG,OP_NONE) && (insn[0] & 511) == 0)
	|| (ST_SYNTAX(OP_SHIMM,OP_SHIMM,OP_NONE) && (insn[0] & 511) == 0)
	|| ST_SYNTAX(OP_SHIMM,OP_LIMM,OP_NONE)
	|| ST_SYNTAX(OP_SHIMM,OP_LIMM,OP_SHIMM)
	|| ST_SYNTAX(OP_SHIMM,OP_SHIMM,OP_SHIMM)
	|| (ST_SYNTAX(OP_LIMM,OP_REG,OP_NONE) && (insn[0] & 511) == 0)
	|| ST_SYNTAX(OP_REG,OP_REG,OP_SHIMM)
	|| ST_SYNTAX(OP_REG,OP_SHIMM,OP_SHIMM)
	|| ST_SYNTAX(OP_SHIMM,OP_REG,OP_SHIMM)
	|| ST_SYNTAX(OP_LIMM,OP_SHIMM,OP_SHIMM)
	|| ST_SYNTAX(OP_LIMM,OP_SHIMM,OP_NONE)
	|| ST_SYNTAX(OP_LIMM,OP_REG,OP_SHIMM)))
    *invalid = 1;
  return 0;
d1240 9
a1248 3
int
arc_limm_fixup_adjust(insn)
     arc_insn insn;
d1250 10
a1259 1
  int retval = 0;
d1261 11
a1271 9
  /* check for st shimm,[limm].  */
  if ((insn & (I(-1) | C(-1) | B(-1))) ==
      (I(2) | C(ARC_REG_SHIMM) | B(ARC_REG_LIMM)))
    {
      retval = insn & 0x1ff;
      if (retval & 0x100) /* sign extend 9 bit offset.  */
	retval |= ~0x1ff;
    }
  return -retval; /* negate offset for return.  */
d1274 1
a1274 1
/* Used in st insns to do final syntax check.  */
d1276 6
a1281 8
static arc_insn
insert_st_syntax (insn, operand, mods, reg, value, errmsg)
     arc_insn insn;
     const struct arc_operand *operand ATTRIBUTE_UNUSED;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value ATTRIBUTE_UNUSED;
     const char **errmsg;
d1283 3
a1285 1
  if (ST_SYNTAX(OP_SHIMM,OP_REG,OP_NONE) && shimm != 0)
d1287 5
a1291 9
      /* change an illegal insn into a legal one, it's easier to
	 do it here than to try to handle it during operand scan.  */
      limm_p = 1;
      limm = shimm;
      shimm_p = 0;
      shimm = 0;
      insn = insn & ~(C(-1) | 511);
      insn |= ARC_REG_LIMM << ARC_SHIFT_REGC;
      ls_operand[LS_VALUE] = OP_LIMM;
d1293 2
d1296 1
a1296 51
  if (ST_SYNTAX(OP_REG,OP_SHIMM,OP_NONE) || ST_SYNTAX(OP_LIMM,OP_SHIMM,OP_NONE))
    {
      /* try to salvage this syntax.  */
      if (shimm & 0x1) /* odd shimms won't work.  */
	{
	  if (limm_p) /* do we have a limm already?  */
	    {
	      *errmsg = "impossible store";
	    }
	  limm_p = 1;
	  limm = shimm;
	  shimm = 0;
	  shimm_p = 0;
	  insn = insn & ~(B(-1) | 511);
	  insn |= B(ARC_REG_LIMM);
	  ls_operand[LS_BASE] = OP_LIMM;
	}
      else
	{
	  shimm >>= 1;
	  insn = insn & ~511;
	  insn |= shimm;
	  ls_operand[LS_OFFSET] = OP_SHIMM;
	}
    }
  if (ST_SYNTAX(OP_SHIMM,OP_LIMM,OP_NONE))
    {
      limm += arc_limm_fixup_adjust(insn);
    }
  if (!(ST_SYNTAX(OP_REG,OP_REG,OP_NONE)
	|| ST_SYNTAX(OP_REG,OP_LIMM,OP_NONE)
	|| ST_SYNTAX(OP_REG,OP_REG,OP_SHIMM)
	|| ST_SYNTAX(OP_REG,OP_SHIMM,OP_SHIMM)
	|| (ST_SYNTAX(OP_SHIMM,OP_SHIMM,OP_NONE) && (shimm == 0))
	|| ST_SYNTAX(OP_SHIMM,OP_LIMM,OP_NONE)
	|| ST_SYNTAX(OP_SHIMM,OP_REG,OP_NONE)
	|| ST_SYNTAX(OP_SHIMM,OP_REG,OP_SHIMM)
	|| ST_SYNTAX(OP_SHIMM,OP_SHIMM,OP_SHIMM)
	|| ST_SYNTAX(OP_LIMM,OP_SHIMM,OP_SHIMM)
	|| ST_SYNTAX(OP_LIMM,OP_REG,OP_NONE)
	|| ST_SYNTAX(OP_LIMM,OP_REG,OP_SHIMM)))
    *errmsg = "st operand error";
  if (addrwb_p)
    {
      if (ls_operand[LS_BASE] != OP_REG)
	*errmsg = "address writeback not allowed";
      insn |= addrwb_p;
    }
  if (ST_SYNTAX(OP_SHIMM,OP_REG,OP_NONE) && shimm)
    *errmsg = "store value must be zero";
  return insn;
d1299 1
a1299 1
/* Used in ld insns to do final syntax check.  */
d1301 6
a1306 8
static arc_insn
insert_ld_syntax (insn, operand, mods, reg, value, errmsg)
     arc_insn insn;
     const struct arc_operand *operand ATTRIBUTE_UNUSED;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value ATTRIBUTE_UNUSED;
     const char **errmsg;
d1308 2
a1309 4
#define LD_SYNTAX(D,B,O) \
((ls_operand[LS_DEST]  == (D) && \
  ls_operand[LS_BASE]   == (B) && \
  ls_operand[LS_OFFSET] == (O)))
d1311 7
a1317 1
  int test = insn & I(-1);
d1319 1
a1319 5
  if (!(test == I(1)))
    {
      if ((ls_operand[LS_DEST] == OP_SHIMM || ls_operand[LS_BASE] == OP_SHIMM
	   || ls_operand[LS_OFFSET] == OP_SHIMM))
	*errmsg = "invalid load/shimm insn";
d1321 3
a1323 15
  if (!(LD_SYNTAX(OP_REG,OP_REG,OP_NONE)
	|| LD_SYNTAX(OP_REG,OP_REG,OP_REG)
	|| LD_SYNTAX(OP_REG,OP_REG,OP_SHIMM)
	|| (LD_SYNTAX(OP_REG,OP_LIMM,OP_REG) && !(test == I(1)))
	|| (LD_SYNTAX(OP_REG,OP_REG,OP_LIMM) && !(test == I(1)))
	|| LD_SYNTAX(OP_REG,OP_SHIMM,OP_SHIMM)
	|| (LD_SYNTAX(OP_REG,OP_LIMM,OP_NONE) && (test == I(1)))))
    *errmsg = "ld operand error";
  if (addrwb_p)
    {
      if (ls_operand[LS_BASE] != OP_REG)
	*errmsg = "address writeback not allowed";
      insn |= addrwb_p;
    }
  return insn;
d1326 3
a1328 1
/* Used in ld insns to do final syntax check.  */
d1331 27
a1357 6
extract_ld_syntax (insn, operand, mods, opval, invalid)
     arc_insn *insn;
     const struct arc_operand *operand ATTRIBUTE_UNUSED;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value **opval ATTRIBUTE_UNUSED;
     int *invalid;
d1359 1
a1359 1
  int test = insn[0] & I(-1);
d1361 52
a1412 17
  if (!(test == I(1)))
    {
      if ((ls_operand[LS_DEST] == OP_SHIMM || ls_operand[LS_BASE] == OP_SHIMM
	   || ls_operand[LS_OFFSET] == OP_SHIMM))
	*invalid = 1;
    }
  if (!((LD_SYNTAX(OP_REG,OP_REG,OP_NONE) && (test == I(1)))
	|| LD_SYNTAX(OP_REG,OP_REG,OP_REG)
	|| LD_SYNTAX(OP_REG,OP_REG,OP_SHIMM)
	|| (LD_SYNTAX(OP_REG,OP_REG,OP_LIMM) && !(test == I(1)))
	|| (LD_SYNTAX(OP_REG,OP_LIMM,OP_REG) && !(test == I(1)))
	|| (LD_SYNTAX(OP_REG,OP_SHIMM,OP_NONE) && (shimm == 0))
	|| LD_SYNTAX(OP_REG,OP_SHIMM,OP_SHIMM)
	|| (LD_SYNTAX(OP_REG,OP_LIMM,OP_NONE) && (test == I(1)))))
    *invalid = 1;
  return 0;
}
d1414 1
a1414 2
/* Called at the end of processing normal insns (eg: add) to insert a shimm
   value (if present) into the insn.  */
d1416 1
a1416 8
static arc_insn
insert_shimmfinish (insn, operand, mods, reg, value, errmsg)
     arc_insn insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value ATTRIBUTE_UNUSED;
     const char **errmsg ATTRIBUTE_UNUSED;
d1418 1
a1418 4
  if (shimm_p)
    insn |= (shimm & ((1 << operand->bits) - 1)) << operand->shift;
  return insn;
}
d1420 17
a1436 2
/* Called at the end of processing normal insns (eg: add) to insert a limm
   value (if present) into the insn.
d1438 11
a1448 2
   Note that this function is only intended to handle instructions (with 4 byte
   immediate operands).  It is not intended to handle data.  */
d1450 8
a1457 5
/* ??? Actually, there's nothing for us to do as we can't call frag_more, the
   caller must do that.  The extract fns take a pointer to two words.  The
   insert fns could be converted and then we could do something useful, but
   then the reloc handlers would have to know to work on the second word of
   a 2 word quantity.  That's too much so we don't handle them.  */
d1459 6
a1464 15
static arc_insn
insert_limmfinish (insn, operand, mods, reg, value, errmsg)
     arc_insn insn;
     const struct arc_operand *operand ATTRIBUTE_UNUSED;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value ATTRIBUTE_UNUSED;
     const char **errmsg ATTRIBUTE_UNUSED;
{
#if 0
  if (limm_p)
    ; /* nothing to do, gas does it.  */
#endif
  return insn;
}
d1466 4
a1469 34
static arc_insn
insert_jumpflags (insn, operand, mods, reg, value, errmsg)
     arc_insn insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value;
     const char **errmsg;
{
  if (!flag_p)
    {
      *errmsg = "jump flags, but no .f seen";
    }
  if (!limm_p)
    {
      *errmsg = "jump flags, but no limm addr";
    }
  if (limm & 0xfc000000)
    {
      *errmsg = "flag bits of jump address limm lost";
    }
  if (limm & 0x03000000)
    {
      *errmsg = "attempt to set HR bits";
    }
  if ((value & ((1 << operand->bits) - 1)) != value)
    {
      *errmsg = "bad jump flags value";
    }
  jumpflags_p = 1;
  limm = ((limm & ((1 << operand->shift) - 1))
	  | ((value & ((1 << operand->bits) - 1)) << operand->shift));
  return insn;
}
d1471 1
a1471 1
/* Called at the end of unary operand macros to copy the B field to C.  */
d1473 5
a1477 12
static arc_insn
insert_unopmacro (insn, operand, mods, reg, value, errmsg)
     arc_insn insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value ATTRIBUTE_UNUSED;
     const char **errmsg ATTRIBUTE_UNUSED;
{
  insn |= ((insn >> ARC_SHIFT_REGB) & ARC_MASK_REG) << operand->shift;
  return insn;
}
d1479 8
a1486 1
/* Insert a relative address for a branch insn (b, bl, or lp).  */
d1488 2
a1489 14
static arc_insn
insert_reladdr (insn, operand, mods, reg, value, errmsg)
     arc_insn insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value;
     const char **errmsg;
{
  if (value & 3)
    *errmsg = "branch address not on 4 byte boundary";
  insn |= ((value >> 2) & ((1 << operand->bits) - 1)) << operand->shift;
  return insn;
}
d1491 2
a1492 1
/* Insert a limm value as a 26 bit address right shifted 2 into the insn.
d1494 1
a1494 20
   Note that this function is only intended to handle instructions (with 4 byte
   immediate operands).  It is not intended to handle data.  */

/* ??? Actually, there's little for us to do as we can't call frag_more, the
   caller must do that.  The extract fns take a pointer to two words.  The
   insert fns could be converted and then we could do something useful, but
   then the reloc handlers would have to know to work on the second word of
   a 2 word quantity.  That's too much so we don't handle them.

   We do check for correct usage of the nullify suffix, or we
   set the default correctly, though.  */

static arc_insn
insert_absaddr (insn, operand, mods, reg, value, errmsg)
     arc_insn insn;
     const struct arc_operand *operand ATTRIBUTE_UNUSED;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value ATTRIBUTE_UNUSED;
     const char **errmsg;
d1496 2
a1497 22
  if (limm_p)
    {
      /* if it is a jump and link, .jd must be specified.  */
      if (insn & R(-1,9,1))
	{
	  if (!nullify_p)
	    {
	      insn |=  0x02 << 5;  /* default nullify to .jd.  */
	    }
	  else
	    {
	      if (nullify != 0x02)
		{
		  *errmsg = "must specify .jd or no nullify suffix";
		}
	    }
	}
    }
  return insn;
}

/* Extraction functions.
d1499 28
a1526 4
   The suffix extraction functions' return value is redundant since it can be
   obtained from (*OPVAL)->value.  However, the boolean suffixes don't have
   a suffix table entry for the "false" case, so values of zero must be
   obtained from the return value (*OPVAL == NULL).  */
d1528 1
a1528 1
static const struct arc_operand_value *lookup_register (int type, long regno);
d1530 1
a1530 1
/* Called by the disassembler before printing an instruction.  */
d1532 3
a1534 5
void
arc_opcode_init_extract ()
{
  arc_opcode_init_insert();
}
d1536 11
a1546 3
/* As we're extracting registers, keep an eye out for the 'f' indicator
   (ARC_REG_SHIMM_UPDATE).  If we find a register (not a constant marker,
   like ARC_REG_SHIMM), set OPVAL so our caller will know this is a register.
d1548 4
a1551 2
   We must also handle auxiliary registers for lr/sr insns.  They are just
   constants with special names.  */
d1553 2
a1554 11
static long
extract_reg (insn, operand, mods, opval, invalid)
     arc_insn *insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value **opval;
     int *invalid ATTRIBUTE_UNUSED;
{
  int regno;
  long value;
  enum operand op_type;
d1556 3
a1558 60
  /* Get the register number.  */
  regno = (*insn >> operand->shift) & ((1 << operand->bits) - 1);

  /* Is it a constant marker?  */
  if (regno == ARC_REG_SHIMM)
    {
      op_type = OP_SHIMM;
      /* always return zero if dest is a shimm  mlm.  */

      if ('a' != operand->fmt)
	{
	  value = *insn & 511;
	  if ((operand->flags & ARC_OPERAND_SIGNED)
	      && (value & 256))
	    value -= 512;
	  if (!flagshimm_handled_p)
	    flag_p = 0;
	  flagshimm_handled_p = 1;
	}
      else
	{
	  value = 0;
	}
    }
  else if (regno == ARC_REG_SHIMM_UPDATE)
    {
      op_type = OP_SHIMM;

      /* always return zero if dest is a shimm  mlm.  */

      if ('a' != operand->fmt)
	{
	  value = *insn & 511;
	  if ((operand->flags & ARC_OPERAND_SIGNED) && (value & 256))
	    value -= 512;
	}
      else
	{
	  value = 0;
	}
      flag_p = 1;
      flagshimm_handled_p = 1;
    }
  else if (regno == ARC_REG_LIMM)
    {
      op_type = OP_LIMM;
      value = insn[1];
      limm_p = 1;
      /* if this is a jump instruction (j,jl), show new pc correctly.  */
      if (0x07 == ((*insn & I(-1)) >> 27))
	{
	  value = (value & 0xffffff);
	}
    }
  /* It's a register, set OPVAL (that's the only way we distinguish registers
     from constants here).  */
  else
    {
      const struct arc_operand_value *reg = lookup_register (REG, regno);
      op_type = OP_REG;
d1560 4
a1563 6
      if (reg == NULL)
	abort ();
      if (opval != NULL)
	*opval = reg;
      value = regno;
    }
d1565 2
a1566 5
  /* If this field takes an auxiliary register, see if it's a known one.  */
  if ((mods & ARC_MOD_AUXREG)
      && ARC_REG_CONSTANT_P (regno))
    {
      const struct arc_operand_value *reg = lookup_register (AUXREG, value);
d1568 1
a1568 23
      /* This is really a constant, but tell the caller it has a special
	 name.  */
      if (reg != NULL && opval != NULL)
	*opval = reg;
    }
  switch(operand->fmt)
    {
    case 'a':
      ls_operand[LS_DEST] = op_type;
      break;
    case 's':
      ls_operand[LS_BASE] = op_type;
      break;
    case 'c':
      if ((insn[0]& I(-1)) == I(2))
	ls_operand[LS_VALUE] = op_type;
      else
	ls_operand[LS_OFFSET] = op_type;
      break;
    case 'o': case 'O':
      ls_operand[LS_OFFSET] = op_type;
      break;
    }
d1570 11
a1580 1
  return value;
d1583 5
a1587 2
/* Return the value of the "flag update" field for shimm insns.
   This value is actually stored in the register field.  */
d1589 2
a1590 7
static long
extract_flag (insn, operand, mods, opval, invalid)
     arc_insn *insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value **opval;
     int *invalid ATTRIBUTE_UNUSED;
d1592 1
a1592 2
  int f;
  const struct arc_operand_value *val;
d1594 1
a1594 4
  if (flagshimm_handled_p)
    f = flag_p != 0;
  else
    f = (*insn & (1 << operand->shift)) != 0;
d1596 6
a1601 9
  /* There is no text for zero values.  */
  if (f == 0)
    return 0;
  flag_p = 1;
  val = arc_opcode_lookup_suffix (operand, 1);
  if (opval != NULL && val != NULL)
    *opval = val;
  return val->value;
}
d1603 4
a1606 4
/* Extract the condition code (if it exists).
   If we've seen a shimm value in this insn (meaning that the insn can't have
   a condition code field), then we don't store anything in OPVAL and return
   zero.  */
d1608 7
a1614 10
static long
extract_cond (insn, operand, mods, opval, invalid)
     arc_insn *insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value **opval;
     int *invalid ATTRIBUTE_UNUSED;
{
  long cond;
  const struct arc_operand_value *val;
d1616 2
a1617 2
  if (flagshimm_handled_p)
    return 0;
d1619 3
a1621 2
  cond = (*insn >> operand->shift) & ((1 << operand->bits) - 1);
  val = arc_opcode_lookup_suffix (operand, cond);
d1623 2
a1624 5
  /* Ignore NULL values of `val'.  Several condition code values are
     reserved for extensions.  */
  if (opval != NULL && val != NULL)
    *opval = val;
  return cond;
d1627 2
a1628 2
/* Extract a branch address.
   We return the value as a real address (not right shifted by 2).  */
d1630 2
a1631 7
static long
extract_reladdr (insn, operand, mods, opval, invalid)
     arc_insn *insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value **opval ATTRIBUTE_UNUSED;
     int *invalid ATTRIBUTE_UNUSED;
d1633 4
a1636 1
  long addr;
d1638 1
a1638 6
  addr = (*insn >> operand->shift) & ((1 << operand->bits) - 1);
  if ((operand->flags & ARC_OPERAND_SIGNED)
      && (addr & (1 << (operand->bits - 1))))
    addr -= 1 << operand->bits;
  return addr << 2;
}
d1640 2
a1641 8
/* extract the flags bits from a j or jl long immediate.  */
static long
extract_jumpflags(insn, operand, mods, opval, invalid)
     arc_insn *insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value **opval ATTRIBUTE_UNUSED;
     int *invalid;
d1643 1
a1643 4
  if (!flag_p || !limm_p)
    *invalid = 1;
  return ((flag_p && limm_p)
	  ? (insn[1] >> operand->shift) & ((1 << operand->bits) -1): 0);
d1646 1
a1646 1
/* extract st insn's offset.  */
d1648 2
a1649 7
static long
extract_st_offset (insn, operand, mods, opval, invalid)
     arc_insn *insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value **opval ATTRIBUTE_UNUSED;
     int *invalid;
d1651 1
a1651 15
  int value = 0;

  if (ls_operand[LS_VALUE] != OP_SHIMM || ls_operand[LS_BASE] != OP_LIMM)
    {
      value = insn[0] & 511;
      if ((operand->flags & ARC_OPERAND_SIGNED) && (value & 256))
	value -= 512;
      if (value)
	ls_operand[LS_OFFSET] = OP_SHIMM;
    }
  else
    {
      *invalid = 1;
    }
  return(value);
d1654 1
a1654 1
/* extract ld insn's offset.  */
d1656 2
a1657 7
static long
extract_ld_offset (insn, operand, mods, opval, invalid)
     arc_insn *insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value **opval;
     int *invalid;
d1659 4
a1662 2
  int test = insn[0] & I(-1);
  int value;
d1664 9
a1672 12
  if (test)
    {
      value = insn[0] & 511;
      if ((operand->flags & ARC_OPERAND_SIGNED) && (value & 256))
	value -= 512;
      if (value)
	ls_operand[LS_OFFSET] = OP_SHIMM;
      return(value);
    }
  /* if it isn't in the insn, it's concealed behind reg 'c'.  */
  return extract_reg (insn, &arc_operands[arc_operand_map['c']],
		      mods, opval, invalid);
d1675 2
a1676 3
/* The only thing this does is set the `invalid' flag if B != C.
   This is needed because the "mov" macro appears before it's real insn "and"
   and we don't want the disassembler to confuse them.  */
d1678 2
a1679 7
static long
extract_unopmacro (insn, operand, mods, opval, invalid)
     arc_insn *insn;
     const struct arc_operand *operand ATTRIBUTE_UNUSED;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value **opval ATTRIBUTE_UNUSED;
     int *invalid;
d1681 3
a1683 8
  /* This misses the case where B == ARC_REG_SHIMM_UPDATE &&
     C == ARC_REG_SHIMM (or vice versa).  No big deal.  Those insns will get
     printed as "and"s.  */
  if (((*insn >> ARC_SHIFT_REGB) & ARC_MASK_REG)
      != ((*insn >> ARC_SHIFT_REGC) & ARC_MASK_REG))
    if (invalid != NULL)
      *invalid = 1;
  return 0;
d1690 1
a1690 3
arc_opcode_lookup_suffix (type, value)
     const struct arc_operand *type;
     int value;
d1692 1
a1692 1
  register const struct arc_operand_value *v,*end;
a1703 1

a1710 27
static const struct arc_operand_value *
lookup_register (type, regno)
     int type;
     long regno;
{
  register const struct arc_operand_value *r,*end;
  struct arc_ext_operand_value *ext_oper = arc_ext_operands;

  while (ext_oper)
    {
      if (ext_oper->operand.type == type && ext_oper->operand.value == regno)
	return (&ext_oper->operand);
      ext_oper = ext_oper->next;
    }

  if (type == REG)
    return &arc_reg_names[regno];

  /* ??? This is a little slow and can be speeded up.  */

  for (r = arc_reg_names, end = arc_reg_names + arc_reg_names_count;
       r < end; ++r)
    if (type == r->type	&& regno == r->value)
      return r;
  return 0;
}

d1712 1
a1712 2
arc_insn_is_j(insn)
     arc_insn insn;
d1718 1
a1718 2
arc_insn_not_jl(insn)
     arc_insn insn;
d1725 1
a1725 1
arc_operand_type(int opertype)
d1730 1
a1730 1
      return(COND);
d1733 1
a1733 1
      return(REG);
d1736 1
a1736 1
      return(AUXREG);
d1743 1
a1743 2
get_ext_suffix(s)
     char *s;
d1758 1
a1758 1
arc_get_noshortcut_flag()
@


1.13
log
@update copyright dates
@
text
@d18 1
a18 1
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.12
log
@* opcode/arc-opc.c (insert_base): Modify ls_operand[LS_OFFSET] to reflect the
  change to the short immediate syntax.
* gas/arc/ld.s: Add check of load of a long immediate.
* gas/arc/ld.d: Add expected disassembly.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 2000, 2001
@


1.11
log
@2002-11-18  Klee Dienes  <kdienes@@apple.com>

	* arc.h (arc_ext_opcodes): Declare as extern.
	(arc_ext_operands): Declare as extern.
	* i860.h (i860_opcodes): Declare as const.

2002-11-18  Klee Dienes  <kdienes@@apple.com>

	* arc-opc.c (arc_ext_opcodes): Define.
	(arc_ext_operands): Define.
	* i386-dis.c (Suffix3DNow): Declare as const.
	* arm-opc.h (arm_opcodes): Declare as const.
	(thumb_opcodes): Declare as const.
	* h8500-opc.h (h8500_table): Declare as const.
	(h8500_table): Use a NULL for the opcode in the terminator, so
	that code testing (opcode->name) behaves correctly.
	* mcore-opc.h (mcore_table): Declare as const.
	* sh-opc.h (sh_table): Declare as const.
	* w65-opc.h (optable): Declare as const.
	* z8k-opc.h (z8k_table): Declare as const.
@
text
@d941 1
@


1.10
log
@	* arc-opc.c: Include bfd.h.
	(arc_get_opcode_mach): Subtract off base bfd_mach value.
@
text
@d69 3
@


1.10.8.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a68 3
struct arc_opcode *arc_ext_opcodes;
struct arc_ext_operand_value *arc_ext_operands;

@


1.10.6.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a68 3
struct arc_opcode *arc_ext_opcodes;
struct arc_ext_operand_value *arc_ext_operands;

@


1.9
log
@
	* tic54x-opc.c: Add default initializers to avoid warnings.

	* arc-opc.c: Include "sysdep.h" to get stdio.h as include file.
	* arc-ext.c: Likewise.
@
text
@d23 1
d517 1
a517 1
  return mach_type_map[bfd_mach] | (big_p ? ARC_MACH_BIG : 0);
@


1.9.10.1
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a22 1
#include "bfd.h"
d516 1
a516 1
  return mach_type_map[bfd_mach - bfd_mach_arc_5] | (big_p ? ARC_MACH_BIG : 0);
@


1.8
log
@Fix over-optimisation of ST instruction.
@
text
@d20 1
@


1.7
log
@More whitespace fixes.
@
text
@a1151 8
  if (ST_SYNTAX(OP_LIMM,OP_SHIMM,OP_SHIMM) && (shimm * 2 == limm))
    {
      insn &= ~C(-1);
      limm_p = 0;
      limm = 0;
      insn |= C(ARC_REG_SHIMM);
      ls_operand[LS_VALUE] = OP_SHIMM;
    }
@


1.6
log
@	* arc-opc.c: Whitespace changes.
@
text
@d657 1
a657 1
  long *limmp;
d671 6
a676 6
  arc_insn insn;
  const struct arc_operand *operand;
  int mods;
  const struct arc_operand_value *reg;
  long value;
  const char **errmsg;
d803 6
a808 6
  arc_insn insn;
  const struct arc_operand *operand ATTRIBUTE_UNUSED;
  int mods ATTRIBUTE_UNUSED;
  const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
  long value ATTRIBUTE_UNUSED;
  const char **errmsg ATTRIBUTE_UNUSED;
d821 6
a826 6
  arc_insn insn;
  const struct arc_operand *operand;
  int mods ATTRIBUTE_UNUSED;
  const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
  long value;
  const char **errmsg ATTRIBUTE_UNUSED;
d840 6
a845 6
  arc_insn insn;
  const struct arc_operand *operand;
  int mods ATTRIBUTE_UNUSED;
  const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
  long value ATTRIBUTE_UNUSED;
  const char **errmsg ATTRIBUTE_UNUSED;
d861 6
a866 6
  arc_insn insn;
  const struct arc_operand *operand;
  int mods ATTRIBUTE_UNUSED;
  const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
  long value;
  const char **errmsg ATTRIBUTE_UNUSED;
d881 6
a886 6
  arc_insn insn;
  const struct arc_operand *operand ATTRIBUTE_UNUSED;
  int mods ATTRIBUTE_UNUSED;
  const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
  long value ATTRIBUTE_UNUSED;
  const char **errmsg ATTRIBUTE_UNUSED;
d894 6
a899 6
  arc_insn insn;
  const struct arc_operand *operand;
  int mods ATTRIBUTE_UNUSED;
  const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
  long value ATTRIBUTE_UNUSED;
  const char **errmsg ATTRIBUTE_UNUSED;
d907 6
a912 6
  arc_insn insn;
  const struct arc_operand *operand;
  int mods;
  const struct arc_operand_value *reg;
  long value;
  const char **errmsg;
d958 6
a963 6
  arc_insn insn;
  const struct arc_operand *operand;
  int mods;
  const struct arc_operand_value *reg;
  long value;
  const char **errmsg;
d1053 5
a1057 5
  arc_insn *insn;
  const struct arc_operand *operand ATTRIBUTE_UNUSED;
  int mods ATTRIBUTE_UNUSED;
  const struct arc_operand_value **opval ATTRIBUTE_UNUSED;
  int *invalid;
d1084 1
a1084 1
  arc_insn insn;
d1103 6
a1108 6
  arc_insn insn;
  const struct arc_operand *operand ATTRIBUTE_UNUSED;
  int mods ATTRIBUTE_UNUSED;
  const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
  long value ATTRIBUTE_UNUSED;
  const char **errmsg;
d1188 6
a1193 6
  arc_insn insn;
  const struct arc_operand *operand ATTRIBUTE_UNUSED;
  int mods ATTRIBUTE_UNUSED;
  const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
  long value ATTRIBUTE_UNUSED;
  const char **errmsg;
d1229 5
a1233 5
  arc_insn *insn;
  const struct arc_operand *operand ATTRIBUTE_UNUSED;
  int mods ATTRIBUTE_UNUSED;
  const struct arc_operand_value **opval ATTRIBUTE_UNUSED;
  int *invalid;
d1260 6
a1265 6
  arc_insn insn;
  const struct arc_operand *operand;
  int mods ATTRIBUTE_UNUSED;
  const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
  long value ATTRIBUTE_UNUSED;
  const char **errmsg ATTRIBUTE_UNUSED;
d1286 6
a1291 6
  arc_insn insn;
  const struct arc_operand *operand ATTRIBUTE_UNUSED;
  int mods ATTRIBUTE_UNUSED;
  const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
  long value ATTRIBUTE_UNUSED;
  const char **errmsg ATTRIBUTE_UNUSED;
d1302 6
a1307 6
  arc_insn insn;
  const struct arc_operand *operand;
  int mods ATTRIBUTE_UNUSED;
  const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
  long value;
  const char **errmsg;
d1437 5
a1441 5
  arc_insn *insn;
  const struct arc_operand *operand;
  int mods;
  const struct arc_operand_value **opval;
  int *invalid ATTRIBUTE_UNUSED;
d1553 5
a1557 5
  arc_insn *insn;
  const struct arc_operand *operand;
  int mods ATTRIBUTE_UNUSED;
  const struct arc_operand_value **opval;
  int *invalid ATTRIBUTE_UNUSED;
d1584 5
a1588 5
  arc_insn *insn;
  const struct arc_operand *operand;
  int mods ATTRIBUTE_UNUSED;
  const struct arc_operand_value **opval;
  int *invalid ATTRIBUTE_UNUSED;
d1611 5
a1615 5
  arc_insn *insn;
  const struct arc_operand *operand;
  int mods ATTRIBUTE_UNUSED;
  const struct arc_operand_value **opval ATTRIBUTE_UNUSED;
  int *invalid ATTRIBUTE_UNUSED;
d1629 5
a1633 5
  arc_insn *insn;
  const struct arc_operand *operand;
  int mods ATTRIBUTE_UNUSED;
  const struct arc_operand_value **opval ATTRIBUTE_UNUSED;
  int *invalid;
d1645 5
a1649 5
  arc_insn *insn;
  const struct arc_operand *operand;
  int mods ATTRIBUTE_UNUSED;
  const struct arc_operand_value **opval ATTRIBUTE_UNUSED;
  int *invalid;
d1672 5
a1676 5
  arc_insn *insn;
  const struct arc_operand *operand;
  int mods;
  const struct arc_operand_value **opval;
  int *invalid;
d1701 5
a1705 5
  arc_insn *insn;
  const struct arc_operand *operand ATTRIBUTE_UNUSED;
  int mods ATTRIBUTE_UNUSED;
  const struct arc_operand_value **opval ATTRIBUTE_UNUSED;
  int *invalid;
d1722 2
a1723 2
  const struct arc_operand *type;
  int value;
d1747 2
a1748 2
  int type;
  long regno;
d1774 1
a1774 1
  arc_insn insn;
d1781 1
a1781 1
  arc_insn insn;
d1807 1
a1807 1
  char *s;
@


1.5
log
@Peter Targett's backwards compatibility and other arc fixes.
@
text
@d1339 6
a1344 6
  arc_insn insn;
  const struct arc_operand *operand;
  int mods ATTRIBUTE_UNUSED;
  const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
  long value ATTRIBUTE_UNUSED;
  const char **errmsg ATTRIBUTE_UNUSED;
d1354 6
a1359 6
  arc_insn insn;
  const struct arc_operand *operand;
  int mods ATTRIBUTE_UNUSED;
  const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
  long value;
  const char **errmsg;
d1383 6
a1388 6
  arc_insn insn;
  const struct arc_operand *operand ATTRIBUTE_UNUSED;
  int mods ATTRIBUTE_UNUSED;
  const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
  long value ATTRIBUTE_UNUSED;
  const char **errmsg;
@


1.4
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d5 1
a5 1
   
d385 1
a385 1
  { "lp_count", 60, REG, ARC_REGISTER_READONLY },
d697 2
a698 2
          op_type = OP_SHIMM;
	 /* forget about shimm as dest mlm.  */
d700 1
a700 1
	  if('a' != operand->fmt)
d707 2
a708 2
          else
            {
d711 1
a711 1
            }
d739 10
a748 10
              if((insn & I(-1)) == I(2)) /* check for use validity.  */
                 {
		   if(reg->flags & ARC_REGISTER_READONLY)
		     *errmsg = "attempt to set readonly register";
                 }
               else
                 {
		   if(reg->flags & ARC_REGISTER_WRITEONLY)
		     *errmsg = "attempt to read writeonly register";
                 }
d755 4
a758 4
      /* check for use validity.  */
          if('a' == operand->fmt || ((insn & I(-1)) < I(2)))
            {
	      if(reg->flags & ARC_REGISTER_READONLY)
d760 4
a763 4
            }
          if('a' != operand->fmt)
            {
	      if(reg->flags & ARC_REGISTER_WRITEONLY)
d765 1
a765 1
            }
d773 1
a773 1
          op_type = OP_REG;
d780 1
a780 1
      ls_operand[LS_DEST] = op_type; 
d783 1
a783 1
      ls_operand[LS_BASE] = op_type; 
d787 1
a787 1
          ls_operand[LS_VALUE] = op_type; 
d789 1
a789 1
          ls_operand[LS_OFFSET] = op_type;
d919 1
a919 1
      ls_operand[LS_BASE] = OP_REG; 
d924 8
a931 8
        {
          /* convert the previous shimm operand to a limm.  */
          limm_p = 1;
          limm = shimm;
          insn &= ~C(-1); /* we know where the value is in insn.  */
          insn |= C(ARC_REG_LIMM);
          ls_operand[LS_VALUE] = OP_LIMM;
        }
d940 4
a943 4
        {
          *errmsg = "too many long constants";
          return insn;
        }
d973 2
a974 2
          if ((insn & I(-1)) != I(1)) /* not if opcode == 1, catch it later.  */
              insn |= C(myinsn);
d992 14
a1005 14
        if (limm_p && value != limm)
          {
	    *errmsg = "too many long constants";
          }
        else
          {
	    limm_p = 1;
	    limm = value;
	    if (operand->flags & ARC_OPERAND_STORE)
	      insn |= B(ARC_REG_LIMM);
	    if (operand->flags & ARC_OPERAND_LOAD)
	      insn |= C(ARC_REG_LIMM);
	    ls_operand[LS_OFFSET] = OP_LIMM;
          }
d1008 1
a1008 1
        {
d1011 1
a1011 1
	  else if (shimm_p && value != shimm) 
d1043 1
a1043 1
        }
d1063 2
a1064 1
  if (!((ST_SYNTAX(OP_REG,OP_REG,OP_NONE)   && (insn[0] & 511) == 0)
d1071 1
a1071 1
	|| (ST_SYNTAX(OP_LIMM,OP_REG,OP_NONE)  && (insn[0] & 511) == 0)
d1090 1
a1090 1
     (I(2) | C(ARC_REG_SHIMM) | B(ARC_REG_LIMM)))
d1096 1
a1096 1
  return(-retval); /* negate offset for return.  */
d1126 21
a1146 21
    if (shimm & 0x1) /* odd shimms won't work.  */
      {
	if (limm_p) /* do we have a limm already?  */
	  {
	    *errmsg = "impossible store";
	  }
	limm_p = 1;
	limm = shimm;
	shimm = 0;
	shimm_p = 0;
	insn = insn & ~(B(-1) | 511);
	insn |= B(ARC_REG_LIMM);
	ls_operand[LS_BASE] = OP_LIMM;
      }
    else
      {
	shimm >>= 1;
	insn = insn & ~511;
	insn |= shimm;
	ls_operand[LS_OFFSET] = OP_SHIMM;
      }
d1170 1
a1170 1
	|| ST_SYNTAX(OP_LIMM,OP_REG,OP_NONE) 
d1203 5
a1207 5
   {
     if ((ls_operand[LS_DEST] == OP_SHIMM || ls_operand[LS_BASE] == OP_SHIMM
	  || ls_operand[LS_OFFSET] == OP_SHIMM))
       *errmsg = "invalid load/shimm insn";
   }
d1213 1
a1213 1
	|| LD_SYNTAX(OP_REG,OP_SHIMM,OP_SHIMM) 
d1215 1
a1215 1
      *errmsg = "ld operand error";
d1239 2
a1240 2
      if((ls_operand[LS_DEST] == OP_SHIMM || ls_operand[LS_BASE] == OP_SHIMM
	  || ls_operand[LS_OFFSET] == OP_SHIMM))
d1330 2
a1331 2
  limm = (limm & ((1 << operand->shift) - 1))
    | ((value & ((1 << operand->bits) - 1)) << operand->shift); 
d1401 1
a1401 1
	      if(nullify != 0x02)
d1454 1
a1454 1
    /* always return zero if dest is a shimm  mlm.  */
d1496 2
a1497 2
      if(0x07 == ((*insn & I(-1)) >> 27))
        {
d1499 1
a1499 1
        }
d1527 17
a1543 17
   {
   case 'a':
     ls_operand[LS_DEST] = op_type; 
     break;
   case 's':
     ls_operand[LS_BASE] = op_type; 
     break;
   case 'c':
     if((insn[0]& I(-1)) == I(2))
       ls_operand[LS_VALUE] = op_type; 
     else
       ls_operand[LS_OFFSET] = op_type;
     break;
   case 'o': case 'O':
     ls_operand[LS_OFFSET] = op_type;
     break;
   }
d1637 2
a1638 2
  return((flag_p && limm_p)
         ? (insn[1] >> operand->shift) & ((1 << operand->bits) -1): 0);
d1658 1
a1658 1
      if(value)
d1690 3
a1692 3
/* if it isn't in the insn, it's concealed behind reg 'c'.  */
  return extract_reg(insn,
                     &arc_operands[arc_operand_map['c']], mods, opval, invalid);
d1783 2
a1784 2
  return (insn & (I(-1)|A(-1)|C(-1)|R(-1,7,1)|R(-1,9,1))) !=
    (I(0x7) | R(-1,9,1));
d1818 1
a1818 1
  return(NULL);
d1824 1
a1824 1
  return(ARC_REGISTER_NOSHORT_CUT);
@


1.3
log
@Updated ARC assembler from arccores.com
@
text
@d2 2
a3 1
   Copyright 1994, 1995, 1997, 1998, 2000 Free Software Foundation, Inc.
@


1.3.2.1
log
@Merge from mainline.
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 1997, 1998, 2000, 2001
   Free Software Foundation, Inc.
d4 1
a4 1

d384 1
a384 1
  { "lp_count", 60, REG, 0 },
d656 1
a656 1
     long *limmp;
d670 6
a675 6
     arc_insn insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value *reg;
     long value;
     const char **errmsg;
d696 2
a697 2
	  op_type = OP_SHIMM;
	  /* forget about shimm as dest mlm.  */
d699 1
a699 1
	  if ('a' != operand->fmt)
d706 2
a707 2
	  else
	    {
d710 1
a710 1
	    }
d738 10
a747 10
	      if ((insn & I(-1)) == I(2)) /* check for use validity.  */
		{
		  if (reg->flags & ARC_REGISTER_READONLY)
		    *errmsg = "attempt to set readonly register";
		}
	      else
		{
		  if (reg->flags & ARC_REGISTER_WRITEONLY)
		    *errmsg = "attempt to read writeonly register";
		}
d754 4
a757 4
	  /* check for use validity.  */
	  if ('a' == operand->fmt || ((insn & I(-1)) < I(2)))
	    {
	      if (reg->flags & ARC_REGISTER_READONLY)
d759 4
a762 4
	    }
	  if ('a' != operand->fmt)
	    {
	      if (reg->flags & ARC_REGISTER_WRITEONLY)
d764 1
a764 1
	    }
d772 1
a772 1
	  op_type = OP_REG;
d779 1
a779 1
      ls_operand[LS_DEST] = op_type;
d782 1
a782 1
      ls_operand[LS_BASE] = op_type;
d786 1
a786 1
	ls_operand[LS_VALUE] = op_type;
d788 1
a788 1
	ls_operand[LS_OFFSET] = op_type;
d802 6
a807 6
     arc_insn insn;
     const struct arc_operand *operand ATTRIBUTE_UNUSED;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value ATTRIBUTE_UNUSED;
     const char **errmsg ATTRIBUTE_UNUSED;
d820 6
a825 6
     arc_insn insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value;
     const char **errmsg ATTRIBUTE_UNUSED;
d839 6
a844 6
     arc_insn insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value ATTRIBUTE_UNUSED;
     const char **errmsg ATTRIBUTE_UNUSED;
d860 6
a865 6
     arc_insn insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value;
     const char **errmsg ATTRIBUTE_UNUSED;
d880 6
a885 6
     arc_insn insn;
     const struct arc_operand *operand ATTRIBUTE_UNUSED;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value ATTRIBUTE_UNUSED;
     const char **errmsg ATTRIBUTE_UNUSED;
d893 6
a898 6
     arc_insn insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value ATTRIBUTE_UNUSED;
     const char **errmsg ATTRIBUTE_UNUSED;
d906 6
a911 6
     arc_insn insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value *reg;
     long value;
     const char **errmsg;
d918 1
a918 1
      ls_operand[LS_BASE] = OP_REG;
d923 8
a930 8
	{
	  /* convert the previous shimm operand to a limm.  */
	  limm_p = 1;
	  limm = shimm;
	  insn &= ~C(-1); /* we know where the value is in insn.  */
	  insn |= C(ARC_REG_LIMM);
	  ls_operand[LS_VALUE] = OP_LIMM;
	}
d939 4
a942 4
	{
	  *errmsg = "too many long constants";
	  return insn;
	}
d957 6
a962 6
     arc_insn insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value *reg;
     long value;
     const char **errmsg;
d972 2
a973 2
	if ((insn & I(-1)) != I(1)) /* not if opcode == 1, catch it later.  */
	  insn |= C(myinsn);
d991 14
a1004 14
	  if (limm_p && value != limm)
	    {
	      *errmsg = "too many long constants";
	    }
	  else
	    {
	      limm_p = 1;
	      limm = value;
	      if (operand->flags & ARC_OPERAND_STORE)
		insn |= B(ARC_REG_LIMM);
	      if (operand->flags & ARC_OPERAND_LOAD)
		insn |= C(ARC_REG_LIMM);
	      ls_operand[LS_OFFSET] = OP_LIMM;
	    }
d1007 1
a1007 1
	{
d1010 1
a1010 1
	  else if (shimm_p && value != shimm)
d1042 1
a1042 1
	}
d1052 5
a1056 5
     arc_insn *insn;
     const struct arc_operand *operand ATTRIBUTE_UNUSED;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value **opval ATTRIBUTE_UNUSED;
     int *invalid;
d1062 1
a1062 2

  if (!((ST_SYNTAX(OP_REG,OP_REG,OP_NONE) && (insn[0] & 511) == 0)
d1069 1
a1069 1
	|| (ST_SYNTAX(OP_LIMM,OP_REG,OP_NONE) && (insn[0] & 511) == 0)
d1082 1
a1082 1
     arc_insn insn;
d1088 1
a1088 1
      (I(2) | C(ARC_REG_SHIMM) | B(ARC_REG_LIMM)))
d1094 1
a1094 1
  return -retval; /* negate offset for return.  */
d1101 6
a1106 6
     arc_insn insn;
     const struct arc_operand *operand ATTRIBUTE_UNUSED;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value ATTRIBUTE_UNUSED;
     const char **errmsg;
d1124 21
a1144 21
      if (shimm & 0x1) /* odd shimms won't work.  */
	{
	  if (limm_p) /* do we have a limm already?  */
	    {
	      *errmsg = "impossible store";
	    }
	  limm_p = 1;
	  limm = shimm;
	  shimm = 0;
	  shimm_p = 0;
	  insn = insn & ~(B(-1) | 511);
	  insn |= B(ARC_REG_LIMM);
	  ls_operand[LS_BASE] = OP_LIMM;
	}
      else
	{
	  shimm >>= 1;
	  insn = insn & ~511;
	  insn |= shimm;
	  ls_operand[LS_OFFSET] = OP_SHIMM;
	}
d1168 1
a1168 1
	|| ST_SYNTAX(OP_LIMM,OP_REG,OP_NONE)
d1186 6
a1191 6
     arc_insn insn;
     const struct arc_operand *operand ATTRIBUTE_UNUSED;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value ATTRIBUTE_UNUSED;
     const char **errmsg;
d1201 5
a1205 5
    {
      if ((ls_operand[LS_DEST] == OP_SHIMM || ls_operand[LS_BASE] == OP_SHIMM
	   || ls_operand[LS_OFFSET] == OP_SHIMM))
	*errmsg = "invalid load/shimm insn";
    }
d1211 1
a1211 1
	|| LD_SYNTAX(OP_REG,OP_SHIMM,OP_SHIMM)
d1213 1
a1213 1
    *errmsg = "ld operand error";
d1227 5
a1231 5
     arc_insn *insn;
     const struct arc_operand *operand ATTRIBUTE_UNUSED;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value **opval ATTRIBUTE_UNUSED;
     int *invalid;
d1237 2
a1238 2
      if ((ls_operand[LS_DEST] == OP_SHIMM || ls_operand[LS_BASE] == OP_SHIMM
	   || ls_operand[LS_OFFSET] == OP_SHIMM))
d1258 6
a1263 6
     arc_insn insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value ATTRIBUTE_UNUSED;
     const char **errmsg ATTRIBUTE_UNUSED;
d1284 6
a1289 6
     arc_insn insn;
     const struct arc_operand *operand ATTRIBUTE_UNUSED;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value ATTRIBUTE_UNUSED;
     const char **errmsg ATTRIBUTE_UNUSED;
d1300 6
a1305 6
     arc_insn insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value;
     const char **errmsg;
d1328 2
a1329 2
  limm = ((limm & ((1 << operand->shift) - 1))
	  | ((value & ((1 << operand->bits) - 1)) << operand->shift));
d1337 6
a1342 6
     arc_insn insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value ATTRIBUTE_UNUSED;
     const char **errmsg ATTRIBUTE_UNUSED;
d1352 6
a1357 6
     arc_insn insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value;
     const char **errmsg;
d1381 6
a1386 6
     arc_insn insn;
     const struct arc_operand *operand ATTRIBUTE_UNUSED;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value *reg ATTRIBUTE_UNUSED;
     long value ATTRIBUTE_UNUSED;
     const char **errmsg;
d1399 1
a1399 1
	      if (nullify != 0x02)
d1435 5
a1439 5
     arc_insn *insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value **opval;
     int *invalid ATTRIBUTE_UNUSED;
d1452 1
a1452 1
      /* always return zero if dest is a shimm  mlm.  */
d1494 2
a1495 2
      if (0x07 == ((*insn & I(-1)) >> 27))
	{
d1497 1
a1497 1
	}
d1525 17
a1541 17
    {
    case 'a':
      ls_operand[LS_DEST] = op_type;
      break;
    case 's':
      ls_operand[LS_BASE] = op_type;
      break;
    case 'c':
      if ((insn[0]& I(-1)) == I(2))
	ls_operand[LS_VALUE] = op_type;
      else
	ls_operand[LS_OFFSET] = op_type;
      break;
    case 'o': case 'O':
      ls_operand[LS_OFFSET] = op_type;
      break;
    }
d1551 5
a1555 5
     arc_insn *insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value **opval;
     int *invalid ATTRIBUTE_UNUSED;
d1582 5
a1586 5
     arc_insn *insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value **opval;
     int *invalid ATTRIBUTE_UNUSED;
d1609 5
a1613 5
     arc_insn *insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value **opval ATTRIBUTE_UNUSED;
     int *invalid ATTRIBUTE_UNUSED;
d1627 5
a1631 5
     arc_insn *insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value **opval ATTRIBUTE_UNUSED;
     int *invalid;
d1635 2
a1636 2
  return ((flag_p && limm_p)
	  ? (insn[1] >> operand->shift) & ((1 << operand->bits) -1): 0);
d1643 5
a1647 5
     arc_insn *insn;
     const struct arc_operand *operand;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value **opval ATTRIBUTE_UNUSED;
     int *invalid;
d1656 1
a1656 1
      if (value)
d1670 5
a1674 5
     arc_insn *insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value **opval;
     int *invalid;
d1688 3
a1690 3
  /* if it isn't in the insn, it's concealed behind reg 'c'.  */
  return extract_reg (insn, &arc_operands[arc_operand_map['c']],
		      mods, opval, invalid);
d1699 5
a1703 5
     arc_insn *insn;
     const struct arc_operand *operand ATTRIBUTE_UNUSED;
     int mods ATTRIBUTE_UNUSED;
     const struct arc_operand_value **opval ATTRIBUTE_UNUSED;
     int *invalid;
d1720 2
a1721 2
     const struct arc_operand *type;
     int value;
d1745 2
a1746 2
     int type;
     long regno;
d1772 1
a1772 1
     arc_insn insn;
d1779 1
a1779 1
     arc_insn insn;
d1781 2
a1782 2
  return ((insn & (I(-1)|A(-1)|C(-1)|R(-1,7,1)|R(-1,9,1)))
	  != (I(0x7) | R(-1,9,1)));
d1805 1
a1805 1
     char *s;
d1816 1
a1816 1
  return NULL;
d1822 1
a1822 1
  return ARC_REGISTER_NOSHORT_CUT;
@


1.2
log
@More portability patches.  Include sysdep.h everywhere.
@
text
@d2 1
a2 1
   Copyright (c) 1994, 1995, 1997, 1998 Free Software Foundation, Inc.
d16 2
a17 2
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d20 1
a20 1
#include "sysdep.h"
a21 5
#include "opintl.h"

#ifndef NULL
#define NULL 0
#endif
d34 5
a38 2
INSERT_FN (insert_shimmoffset);
INSERT_FN (insert_shimmzero);
d40 1
d46 1
d50 4
d57 1
d60 11
d80 7
a86 2
   'd'	SHIMMOFFSET	shimm offset in ld,st insns
   '0'	SHIMMZERO	0 shimm value in ld,st insns
d95 1
d117 1
a117 2
   CHAR BITS SHIFT FLAGS INSERT_FN EXTRACT_FN
*/
d121 1
a121 1
/* place holder (??? not sure if needed) */
d123 1
a123 1
  { 0 },
d125 1
a125 1
/* register A or shimm/limm indicator */
d127 1
a127 1
  { 'a', 6, ARC_SHIFT_REGA, ARC_OPERAND_SIGNED, insert_reg, extract_reg },
d129 1
a129 1
/* register B or shimm/limm indicator */
d131 1
a131 1
  { 'b', 6, ARC_SHIFT_REGB, ARC_OPERAND_SIGNED, insert_reg, extract_reg },
d133 1
a133 1
/* register C or shimm/limm indicator */
d135 1
a135 1
  { 'c', 6, ARC_SHIFT_REGC, ARC_OPERAND_SIGNED, insert_reg, extract_reg },
d137 1
a137 1
/* fake operand used to insert shimm value into most instructions */
d145 27
a171 7
/* shimm operand when there is no reg indicator (ld,st) */
#define SHIMMOFFSET (LIMMFINISH + 1)
  { 'd', 9, 0, ARC_OPERAND_SIGNED, insert_shimmoffset, 0 },

/* 0 shimm operand for ld,st insns */
#define SHIMMZERO (SHIMMOFFSET + 1)
  { '0', 9, 0, ARC_OPERAND_FAKE, insert_shimmzero, 0 },
d173 2
a174 2
/* flag update bit (insertion is defered until we know how) */
#define FLAG (SHIMMZERO + 1)
d177 1
a177 1
/* fake utility operand to finish 'f' suffix handling */
d181 1
a181 1
/* fake utility operand to set the 'f' flag for the "flag" insn */
d185 1
a185 1
/* branch delay types */
d187 1
a187 1
  { 'n', 2, 5, ARC_OPERAND_SUFFIX },
d189 1
a189 1
/* conditions */
d193 1
a193 1
/* set `cond_p' to 1 to ensure a constant is treated as a limm */
d195 1
a195 1
  { 'Q', 0, 0, ARC_OPERAND_FAKE, insert_forcelimm },
d197 1
a197 1
/* branch address; b, bl, and lp insns */
d199 1
a199 1
  { 'B', 20, 7, ARC_OPERAND_RELATIVE_BRANCH + ARC_OPERAND_SIGNED, insert_reladdr, extract_reladdr },
d202 1
a202 1
   value is right shifted by 2) */
d204 1
a204 1
  { 'J', 24, 32, ARC_OPERAND_ABSOLUTE_BRANCH + ARC_OPERAND_LIMM + ARC_OPERAND_FAKE, insert_absaddr },
d206 3
a208 3
/* size field, stored in bit 1,2 */
#define SIZE1 (JUMP + 1)
  { 'z', 2, 1, ARC_OPERAND_SUFFIX },
d210 5
a214 1
/* size field, stored in bit 10,11 */
d216 1
a216 1
  { 'Z', 2, 10, ARC_OPERAND_SUFFIX, },
d218 1
a218 1
/* size field, stored in bit 22,23 */
d220 1
a220 1
  { 'y', 2, 22, ARC_OPERAND_SUFFIX, },
d222 1
a222 1
/* sign extend field, stored in bit 0 */
d224 1
a224 1
  { 'x', 1, 0, ARC_OPERAND_SUFFIX },
d226 1
a226 1
/* sign extend field, stored in bit 9 */
d228 1
a228 1
  { 'X', 1, 9, ARC_OPERAND_SUFFIX },
d230 1
a230 1
/* address write back, stored in bit 3 */
d232 1
a232 1
  { 'w', 1, 3, ARC_OPERAND_SUFFIX },
d234 1
a234 1
/* address write back, stored in bit 12 */
d236 1
a236 1
  { 'W', 1, 12, ARC_OPERAND_SUFFIX },
d238 1
a238 1
/* address write back, stored in bit 24 */
d240 1
a240 1
  { 'v', 1, 24, ARC_OPERAND_SUFFIX },
d242 1
a242 1
/* cache bypass, stored in bit 5 */
d244 1
a244 1
  { 'e', 1, 5, ARC_OPERAND_SUFFIX },
d246 1
a246 1
/* cache bypass, stored in bit 14 */
d248 1
a248 1
  { 'E', 1, 14, ARC_OPERAND_SUFFIX },
d250 1
a250 1
/* cache bypass, stored in bit 26 */
d252 1
a252 1
  { 'D', 1, 26, ARC_OPERAND_SUFFIX },
d254 1
a254 1
/* unop macro, used to copy REGB to REGC */
d260 1
a260 1
  { '.', 1, 0, ARC_MOD_DOT },
d266 1
a266 1
  { 'r', 6, 0, ARC_MOD_REG },
d270 1
a270 1
  { 'A', 9, 0, ARC_MOD_AUXREG },
d272 2
a273 2
/* end of list place holder */
  { 0 }
a279 6
#define I(x) (((x) & 31) << 27)
#define A(x) (((x) & ARC_MASK_REG) << ARC_SHIFT_REGA)
#define B(x) (((x) & ARC_MASK_REG) << ARC_SHIFT_REGB)
#define C(x) (((x) & ARC_MASK_REG) << ARC_SHIFT_REGC)
#define R(x,b,m) (((x) & (m)) << (b))	/* value X, mask M, at bit B */

d288 1
a288 1
   insn is really the `and' insn.
d290 3
a292 13
   This table is best viewed on a wide screen (161 columns).  I'd prefer to
   keep it this way.  The rest of the file, however, should be viewable on an
   80 column terminal.  */

/* ??? This table also includes macros: asl, lsl, and mov.  The ppc port has
   a more general facility for dealing with macros which could be used if
   we need to.  */

/* This table can't be `const' because members `next_asm' and `next_dis' are
   computed at run-time.  We could split this into two, but that doesn't seem
   worth it.  */

struct arc_opcode arc_opcodes[] = {
a293 1
  /* Macros appear first.  */
d295 1
a295 1
  { "mov%.q%.f %a,%b%F%S%L%U",		I(-1),		I(12) },
d297 1
a297 1
  { "asl%.q%.f %a,%b%F%S%L%U",		I(-1),		I(8) },
d299 1
a299 1
  { "lsl%.q%.f %a,%b%F%S%L%U",		I(-1),		I(8) },
d301 1
a301 1
  { "nop",				0xffffffff,	0x7fffffff },
d303 43
a345 1
  { "rlc%.q%.f %a,%b%F%S%L%U",		I(-1),		I(9) },
a346 35
  /* The rest of these needn't be sorted, but it helps to find them if they are.  */
  { "adc%.q%.f %a,%b,%c%F%S%L",		I(-1),		I(9) },
  { "add%.q%.f %a,%b,%c%F%S%L",		I(-1),		I(8) },
  { "and%.q%.f %a,%b,%c%F%S%L",		I(-1),		I(12) },
  { "asr%.q%.f %a,%b%F%S%L",		I(-1)+C(-1),	I(3)+C(1) },
  { "bic%.q%.f %a,%b,%c%F%S%L",		I(-1),		I(14) },
  { "b%q%.n %B",			I(-1),		I(4),		ARC_OPCODE_COND_BRANCH },
  { "bl%q%.n %B",			I(-1),		I(5),		ARC_OPCODE_COND_BRANCH },
  { "extb%.q%.f %a,%b%F%S%L",		I(-1)+C(-1),	I(3)+C(7) },
  { "extw%.q%.f %a,%b%F%S%L",		I(-1)+C(-1),	I(3)+C(8) },
  { "flag%.q %b%G%S%L",			I(-1)+A(-1)+C(-1),		I(3)+A(ARC_REG_SHIMM_UPDATE)+C(0) },
  /* %Q: force cond_p=1 --> no shimm values */
  /* ??? This insn allows an optional flags spec.  */
  { "j%q%Q%.n%.f %b%J",			I(-1)+A(-1)+C(-1)+R(-1,7,1),	I(7)+A(0)+C(0)+R(0,7,1) },
  /* Put opcode 1 ld insns first so shimm gets prefered over limm.  */
  /* "[%b]" is before "[%b,%d]" so 0 offsets don't get printed.  */
  { "ld%Z%.X%.W%.E %0%a,[%b]%L",	I(-1)+R(-1,13,1)+R(-1,0,511),	I(1)+R(0,13,1)+R(0,0,511) },
  { "ld%Z%.X%.W%.E %a,[%b,%d]%S%L",	I(-1)+R(-1,13,1),		I(1)+R(0,13,1) },
  { "ld%z%.x%.w%.e%Q %a,[%b,%c]%L",	I(-1)+R(-1,4,1)+R(-1,6,7),	I(0)+R(0,4,1)+R(0,6,7) },
  { "lp%q%.n %B",			I(-1),		I(6), },
  { "lr %a,[%Ab]%S%L",			I(-1)+C(-1),	I(1)+C(0x10) },
  { "lsr%.q%.f %a,%b%F%S%L",		I(-1)+C(-1),	I(3)+C(2) },
  { "or%.q%.f %a,%b,%c%F%S%L",		I(-1),		I(13) },
  { "ror%.q%.f %a,%b%F%S%L",		I(-1)+C(-1),	I(3)+C(3) },
  { "rrc%.q%.f %a,%b%F%S%L",		I(-1)+C(-1),	I(3)+C(4) },
  { "sbc%.q%.f %a,%b,%c%F%S%L",		I(-1),		I(11) },
  { "sexb%.q%.f %a,%b%F%S%L",		I(-1)+C(-1),	I(3)+C(5) },
  { "sexw%.q%.f %a,%b%F%S%L",		I(-1)+C(-1),	I(3)+C(6) },
  { "sr %c,[%Ab]%S%L",			I(-1)+A(-1),	I(2)+A(0x10) },
  /* "[%b]" is before "[%b,%d]" so 0 offsets don't get printed.  */
  { "st%y%.v%.D%Q %0%c,[%b]%L",		I(-1)+R(-1,25,1)+R(-1,21,1)+R(-1,0,511),	I(2)+R(0,25,1)+R(0,21,1)+R(0,0,511) },
  { "st%y%.v%.D %c,[%b,%d]%S%L",	I(-1)+R(-1,25,1)+R(-1,21,1),			I(2)+R(0,25,1)+R(0,21,1) },
  { "sub%.q%.f %a,%b,%c%F%S%L",		I(-1),		I(10) },
  { "xor%.q%.f %a,%b,%c%F%S%L",		I(-1),		I(15) }
};
d351 1
a351 2
  /* Sort this so that the first 61 entries are sequential.
     IE: For each i (i<61), arc_reg_names[i].value == i.  */
d353 66
a418 32
  { "r0", 0, REG }, { "r1", 1, REG }, { "r2", 2, REG }, { "r3", 3, REG },
  { "r4", 4, REG }, { "r5", 5, REG }, { "r6", 6, REG }, { "r7", 7, REG },
  { "r8", 8, REG }, { "r9", 9, REG }, { "r10", 10, REG }, { "r11", 11, REG },
  { "r12", 12, REG }, { "r13", 13, REG }, { "r14", 14, REG }, { "r15", 15, REG },
  { "r16", 16, REG }, { "r17", 17, REG }, { "r18", 18, REG }, { "r19", 19, REG },
  { "r20", 20, REG }, { "r21", 21, REG }, { "r22", 22, REG }, { "r23", 23, REG },
  { "r24", 24, REG }, { "r25", 25, REG }, { "r26", 26, REG }, { "fp", 27, REG },
  { "sp", 28, REG }, { "ilink1", 29, REG }, { "ilink2", 30, REG }, { "blink", 31, REG },
  { "r32", 32, REG }, { "r33", 33, REG }, { "r34", 34, REG }, { "r35", 35, REG },
  { "r36", 36, REG }, { "r37", 37, REG }, { "r38", 38, REG }, { "r39", 39, REG },
  { "r40", 40, REG }, { "r41", 41, REG }, { "r42", 42, REG }, { "r43", 43, REG },
  { "r44", 44, REG }, { "r45", 45, REG }, { "r46", 46, REG }, { "r47", 47, REG },
  { "r48", 48, REG }, { "r49", 49, REG }, { "r50", 50, REG }, { "r51", 51, REG },
  { "r52", 52, REG }, { "r53", 53, REG }, { "r54", 54, REG }, { "r55", 55, REG },
  { "r56", 56, REG }, { "r57", 57, REG }, { "r58", 58, REG }, { "r59", 59, REG },
  { "lp_count", 60, REG },

  /* I'd prefer to output these as "fp" and "sp" by default, but we still need
     to recognize the canonical values.  */
  { "r27", 27, REG }, { "r28", 28, REG },

  /* Someone may wish to refer to these in this way, and it's probably a
     good idea to reserve them as such anyway.  */
  { "r29", 29, REG }, { "r30", 30, REG }, { "r31", 31, REG }, { "r60", 60, REG },

  /* Standard auxiliary registers.  */
  { "status",	0, AUXREG },
  { "semaphore", 1, AUXREG },
  { "lp_start",	2, AUXREG },
  { "lp_end",	3, AUXREG },
  { "identity",	4, AUXREG },
  { "debug",	5, AUXREG },
d420 3
a422 1
const int arc_reg_names_count = sizeof (arc_reg_names) / sizeof (arc_reg_names[0]);
d430 54
a483 50
  { "", 0, -1 },
  { "al", 0, COND },
  { "ra", 0, COND },
  { "eq", 1, COND },
  { "z", 1, COND },
  { "ne", 2, COND },
  { "nz", 2, COND },
  { "p", 3, COND },
  { "pl", 3, COND },
  { "n", 4, COND },
  { "mi", 4, COND },
  { "c", 5, COND },
  { "cs", 5, COND },
  { "lo", 5, COND },
  { "nc", 6, COND },
  { "cc", 6, COND },
  { "hs", 6, COND },
  { "v", 7, COND },
  { "vs", 7, COND },
  { "nv", 8, COND },
  { "vc", 8, COND },
  { "gt", 9, COND },
  { "ge", 10, COND },
  { "lt", 11, COND },
  { "le", 12, COND },
  { "hi", 13, COND },
  { "ls", 14, COND },
  { "pnz", 15, COND },
  { "f", 1, FLAG },
  { "nd", ARC_DELAY_NONE, DELAY },
  { "d", ARC_DELAY_NORMAL, DELAY },
  { "jd", ARC_DELAY_JUMP, DELAY },
/*{ "b", 7, SIZEEXT },*/
/*{ "b", 5, SIZESEX },*/
  { "b", 1, SIZE1 },
  { "b", 1, SIZE10 },
  { "b", 1, SIZE22 },
/*{ "w", 8, SIZEEXT },*/
/*{ "w", 6, SIZESEX },*/
  { "w", 2, SIZE1 },
  { "w", 2, SIZE10 },
  { "w", 2, SIZE22 },
  { "x", 1, SIGN0 },
  { "x", 1, SIGN9 },
  { "a", 1, ADDRESS3 },
  { "a", 1, ADDRESS12 },
  { "a", 1, ADDRESS24 },
  { "di", 1, CACHEBYPASS5 },
  { "di", 1, CACHEBYPASS14 },
  { "di", 1, CACHEBYPASS26 },
d485 3
a487 1
const int arc_suffixes_count = sizeof (arc_suffixes) / sizeof (arc_suffixes[0]);
d508 6
a513 4
    {
      ARC_MACH_BASE
    };

a533 2
  /* ??? We can remove the need for arc_opcode_supported by taking it into
     account here, but I'm not sure I want to do that yet (if ever).  */
d569 1
a569 17
  if (ARC_OPCODE_CPU (opcode->flags) == 0)
    return 1;
  if (ARC_OPCODE_CPU (opcode->flags) & ARC_HAVE_CPU (cpu_type))
    return 1;
  return 0;
}

/* Return non-zero if OPVAL is supported on the specified cpu.
   Cpu selection is made when calling `arc_opcode_init_tables'.  */

int
arc_opval_supported (opval)
     const struct arc_operand_value *opval;
{
  if (ARC_OPVAL_CPU (opval->flags) == 0)
    return 1;
  if (ARC_OPVAL_CPU (opval->flags) & ARC_HAVE_CPU (cpu_type))
d598 3
d604 9
d617 1
a617 1
   appear multiple times.  */
d635 5
d643 1
d646 3
d656 1
a656 1
     long *limmp;
d670 6
a675 6
     arc_insn insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value *reg;
     long value;
     const char **errmsg;
d678 1
d694 17
a710 4
	  int marker = flag_p ? ARC_REG_SHIMM_UPDATE : ARC_REG_SHIMM;
	  flagshimm_handled_p = 1;
	  shimm_p = 1;
	  shimm = value;
d712 1
a712 1
	  /* insn |= value & 511; - done later */
d717 1
d725 1
a725 1
	  *errmsg = _("unable to fit different valued constants into instruction");
d735 1
a735 1
	    *errmsg = _("auxiliary register not allowed here");
d738 10
d754 11
d768 1
a768 2
	      /* xgettext:c-format */
	      sprintf (buf, _("invalid register number `%d'"), reg->value);
d771 2
a772 2
	  else
	    insn |= reg->value << operand->shift;
d776 19
d802 6
a807 6
     arc_insn insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value *reg;
     long value;
     const char **errmsg;
d813 2
d816 14
d839 6
a844 6
     arc_insn insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value *reg;
     long value;
     const char **errmsg;
d860 6
a865 6
     arc_insn insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value *reg;
     long value;
     const char **errmsg;
d880 6
a885 6
     arc_insn insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value *reg;
     long value;
     const char **errmsg;
d891 63
a953 1
/* Used in ld/st insns to handle the shimm offset field.  */
d956 7
a962 7
insert_shimmoffset (insn, operand, mods, reg, value, errmsg)
     arc_insn insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value *reg;
     long value;
     const char **errmsg;
a964 1
  static char buf[100];
d968 6
a973 1
      *errmsg = "register appears where shimm value expected";
d989 1
a989 1
      if (value < minval || value > maxval)
d991 14
a1004 4
	  /* xgettext:c-format */
	  sprintf (buf, _("value won't fit in range %ld - %ld"),
		   minval, maxval);
	  *errmsg = buf;
d1007 36
a1042 1
	insn |= (value & ((1 << operand->bits) - 1)) << operand->shift;
d1044 1
d1048 50
a1097 1
/* Used in ld/st insns when the shimm offset is 0.  */
d1100 7
a1106 7
insert_shimmzero (insn, operand, mods, reg, value, errmsg)
     arc_insn insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value *reg;
     long value;
     const char **errmsg;
d1108 112
a1219 2
  shimm_p = 1;
  shimm = 0;
d1223 30
d1258 6
a1263 6
     arc_insn insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value *reg;
     long value;
     const char **errmsg;
d1284 6
a1289 6
     arc_insn insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value *reg;
     long value;
     const char **errmsg;
d1291 1
d1293 37
a1329 1
    ; /* nothing to do, gas does it */
d1337 6
a1342 6
     arc_insn insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value *reg;
     long value;
     const char **errmsg;
d1352 6
a1357 6
     arc_insn insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value *reg;
     long value;
     const char **errmsg;
d1360 1
a1360 1
    *errmsg = _("branch address not on 4 byte boundary");
d1370 1
a1370 1
/* ??? Actually, there's nothing for us to do as we can't call frag_more, the
d1374 4
a1377 1
   a 2 word quantity.  That's too much so we don't handle them.  */
d1381 6
a1386 6
     arc_insn insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value *reg;
     long value;
     const char **errmsg;
d1389 17
a1405 1
    ; /* nothing to do */
d1423 1
a1423 4
  flag_p = 0;
  flagshimm_handled_p = 0;
  shimm_p = 0;
  limm_p = 0;
d1435 5
a1439 5
     arc_insn *insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value **opval;
     int *invalid;
d1443 1
d1446 1
a1446 1
  regno = (insn[0] >> operand->shift) & ((1 << operand->bits) - 1);
d1451 17
a1467 5
      value = insn[0] & 511;
      if ((operand->flags & ARC_OPERAND_SIGNED)
	  && (value & 256))
	value -= 512;
      flagshimm_handled_p = 1;
d1471 14
a1484 4
      value = insn[0] & 511;
      if ((operand->flags & ARC_OPERAND_SIGNED)
	  && (value & 256))
	value -= 512;
d1490 1
d1493 5
d1504 1
d1524 18
d1551 5
a1555 5
     arc_insn *insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value **opval;
     int *invalid;
d1563 1
a1563 1
    f = (insn[0] & (1 << operand->shift)) != 0;
d1568 1
a1568 1

d1582 5
a1586 5
     arc_insn *insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value **opval;
     int *invalid;
d1594 1
a1594 1
  cond = (insn[0] >> operand->shift) & ((1 << operand->bits) - 1);
d1609 5
a1613 5
     arc_insn *insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value **opval;
     int *invalid;
d1617 1
a1617 1
  addr = (insn[0] >> operand->shift) & ((1 << operand->bits) - 1);
d1621 57
d1679 12
a1690 1
  return addr << 2;
d1699 5
a1703 5
     arc_insn *insn;
     const struct arc_operand *operand;
     int mods;
     const struct arc_operand_value **opval;
     int *invalid;
d1708 2
a1709 2
  if (((insn[0] >> ARC_SHIFT_REGB) & ARC_MASK_REG)
      != ((insn[0] >> ARC_SHIFT_REGC) & ARC_MASK_REG))
a1711 1

d1720 2
a1721 2
     const struct arc_operand *type;
     int value;
d1724 9
d1745 2
a1746 2
     int type;
     long regno;
d1749 8
d1768 55
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
#include "ansidecl.h"
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@


1.1.1.1.2.1
log
@2000-04-13  Michael Sokolov  <msokolov@@ivan.Harhan.ORG>

	* a29k-dis.c, alpha-dis.c, alpha-opc.c, arc-dis.c, arc-opc.c,
	avr-dis.c, d10v-dis.c, d10v-opc.c, d30v-dis.c, d30v-opc.c,
	disassemble.c, h8300-dis.c, h8500-dis.c, hppa-dis.c, i370-dis.c,
	i370-opc.c, i960-dis.c, m10200-dis.c, m10200-opc.c, m10300-dis.c,
	m10300-opc.c, m68k-dis.c, m68k-opc.c, m88k-dis.c, mcore-dis.c,
	mips-dis.c, mips-opc.c, mips16-opc.c, pj-dis.c, pj-opc.c, ppc-dis.c,
	ppc-opc.c, sh-dis.c, sparc-dis.c, sparc-opc.c, tic80-dis.c,
	tic80-opc.c, v850-dis.c, v850-opc.c, vax-dis.c, w65-dis.c, z8k-dis.c,
	z8kgen.c: Everyone includes sysdep.h. Remove ansidecl.h as sysdep.h
	includes it.
@
text
@d20 1
a20 1
#include "sysdep.h"
@


