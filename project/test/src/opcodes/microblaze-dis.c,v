head	1.8;
access;
symbols
	sid-snapshot-20180601:1.8
	sid-snapshot-20180501:1.8
	sid-snapshot-20180401:1.8
	sid-snapshot-20180301:1.8
	sid-snapshot-20180201:1.8
	sid-snapshot-20180101:1.8
	sid-snapshot-20171201:1.8
	sid-snapshot-20171101:1.8
	sid-snapshot-20171001:1.8
	sid-snapshot-20170901:1.8
	sid-snapshot-20170801:1.8
	sid-snapshot-20170701:1.8
	sid-snapshot-20170601:1.8
	sid-snapshot-20170501:1.8
	sid-snapshot-20170401:1.8
	sid-snapshot-20170301:1.8
	sid-snapshot-20170201:1.8
	sid-snapshot-20170101:1.8
	sid-snapshot-20161201:1.8
	sid-snapshot-20161101:1.8
	sid-snapshot-20160901:1.8
	sid-snapshot-20160801:1.8
	sid-snapshot-20160701:1.8
	sid-snapshot-20160601:1.8
	sid-snapshot-20160501:1.8
	sid-snapshot-20160401:1.8
	sid-snapshot-20160301:1.8
	sid-snapshot-20160201:1.8
	sid-snapshot-20160101:1.8
	sid-snapshot-20151201:1.8
	sid-snapshot-20151101:1.8
	sid-snapshot-20151001:1.8
	sid-snapshot-20150901:1.8
	sid-snapshot-20150801:1.8
	sid-snapshot-20150701:1.8
	sid-snapshot-20150601:1.8
	sid-snapshot-20150501:1.8
	sid-snapshot-20150401:1.8
	sid-snapshot-20150301:1.8
	sid-snapshot-20150201:1.8
	sid-snapshot-20150101:1.8
	sid-snapshot-20141201:1.8
	sid-snapshot-20141101:1.8
	sid-snapshot-20141001:1.8
	sid-snapshot-20140901:1.8
	sid-snapshot-20140801:1.8
	sid-snapshot-20140701:1.8
	sid-snapshot-20140601:1.8
	sid-snapshot-20140501:1.8
	sid-snapshot-20140401:1.8
	sid-snapshot-20140301:1.8
	sid-snapshot-20140201:1.8
	sid-snapshot-20140101:1.8
	sid-snapshot-20131201:1.8
	sid-snapshot-20131101:1.8
	sid-snapshot-20131001:1.8
	binutils-2_24-branch:1.8.0.4
	binutils-2_24-branchpoint:1.8
	binutils-2_21_1:1.4
	sid-snapshot-20130901:1.8
	gdb_7_6_1-2013-08-30-release:1.8
	sid-snapshot-20130801:1.8
	sid-snapshot-20130701:1.8
	sid-snapshot-20130601:1.8
	sid-snapshot-20130501:1.8
	gdb_7_6-2013-04-26-release:1.8
	sid-snapshot-20130401:1.8
	binutils-2_23_2:1.5
	gdb_7_6-branch:1.8.0.2
	gdb_7_6-2013-03-12-branchpoint:1.8
	sid-snapshot-20130301:1.8
	sid-snapshot-20130201:1.8
	sid-snapshot-20130101:1.8
	sid-snapshot-20121201:1.8
	gdb_7_5_1-2012-11-29-release:1.4
	binutils-2_23_1:1.5
	sid-snapshot-20121101:1.5
	binutils-2_23:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-2012-08-17-release:1.4
	sid-snapshot-20120801:1.5
	binutils-2_23-branch:1.5.0.2
	binutils-2_23-branchpoint:1.5
	gdb_7_5-branch:1.4.0.16
	gdb_7_5-2012-07-18-branchpoint:1.4
	sid-snapshot-20120701:1.4
	sid-snapshot-20120601:1.4
	sid-snapshot-20120501:1.4
	binutils-2_22_branch:1.4.0.14
	gdb_7_4_1-2012-04-26-release:1.4
	sid-snapshot-20120401:1.4
	sid-snapshot-20120301:1.4
	sid-snapshot-20120201:1.4
	gdb_7_4-2012-01-24-release:1.4
	sid-snapshot-20120101:1.4
	gdb_7_4-branch:1.4.0.12
	gdb_7_4-2011-12-13-branchpoint:1.4
	sid-snapshot-20111201:1.4
	binutils-2_22:1.4
	sid-snapshot-20111101:1.4
	sid-snapshot-20111001:1.4
	binutils-2_22-branch:1.4.0.10
	binutils-2_22-branchpoint:1.4
	gdb_7_3_1-2011-09-04-release:1.4
	sid-snapshot-20110901:1.4
	sid-snapshot-20110801:1.4
	gdb_7_3-2011-07-26-release:1.4
	sid-snapshot-20110701:1.4
	sid-snapshot-20110601:1.4
	sid-snapshot-20110501:1.4
	gdb_7_3-branch:1.4.0.8
	gdb_7_3-2011-04-01-branchpoint:1.4
	sid-snapshot-20110401:1.4
	sid-snapshot-20110301:1.4
	sid-snapshot-20110201:1.4
	sid-snapshot-20110101:1.4
	binutils-2_21:1.4
	sid-snapshot-20101201:1.4
	binutils-2_21-branch:1.4.0.6
	binutils-2_21-branchpoint:1.4
	sid-snapshot-20101101:1.4
	sid-snapshot-20101001:1.4
	binutils-2_20_1:1.1
	gdb_7_2-2010-09-02-release:1.4
	sid-snapshot-20100901:1.4
	sid-snapshot-20100801:1.4
	gdb_7_2-branch:1.4.0.4
	gdb_7_2-2010-07-07-branchpoint:1.4
	sid-snapshot-20100701:1.4
	sid-snapshot-20100601:1.4
	sid-snapshot-20100501:1.4
	sid-snapshot-20100401:1.4
	gdb_7_1-2010-03-18-release:1.4
	sid-snapshot-20100301:1.4
	gdb_7_1-branch:1.4.0.2
	gdb_7_1-2010-02-18-branchpoint:1.4
	sid-snapshot-20100201:1.4
	sid-snapshot-20100101:1.4
	gdb_7_0_1-2009-12-22-release:1.1
	sid-snapshot-20091201:1.3
	sid-snapshot-20091101:1.3
	binutils-2_20:1.1
	gdb_7_0-2009-10-06-release:1.1
	sid-snapshot-20091001:1.2
	gdb_7_0-branch:1.1.0.4
	gdb_7_0-2009-09-16-branchpoint:1.1
	binutils-2_20-branch:1.1.0.2
	binutils-2_20-branchpoint:1.1
	sid-snapshot-20090901:1.1
	binutils_latest_snapshot:1.8;
locks; strict;
comment	@ * @;


1.8
date	2012.11.29.21.09.01;	author eager;	state Exp;
branches;
next	1.7;

1.7
date	2012.11.21.17.34.14;	author eager;	state Exp;
branches;
next	1.6;

1.6
date	2012.11.14.17.05.24;	author eager;	state Exp;
branches;
next	1.5;

1.5
date	2012.07.24.12.56.47;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2009.12.11.13.42.17;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2009.10.07.15.40.17;	author eager;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.25.19.59.51;	author eager;	state Exp;
branches;
next	1.1;

1.1
date	2009.08.06.17.38.04;	author nickc;	state Exp;
branches;
next	;


desc
@@


1.8
log
@opcodes/Changelog:
	* microblaze-opc.h: Rename INST_TYPE_RD_R1_SPECIAL to
	INST_TYPE_R1_R2_SPECIAL
	* microblaze-dis.c (print_insn_microblaze): Same.
gas/Changelog
	* gas/config/tc-microblaze.c: Rename INST_TYPE_RD_R1_SPECIAL to
	INST_TYPE_R1_R2_SPECIAL, don't set RD for wic.
@
text
@/* Disassemble Xilinx microblaze instructions.

   Copyright 2009, 2012 Free Software Foundation, Inc.

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this file; see the file COPYING.  If not, write to the
   Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


#include "sysdep.h"
#define STATIC_TABLE
#define DEFINE_TABLE

#include "dis-asm.h"
#include <strings.h>
#include "microblaze-opc.h"
#include "microblaze-dis.h"

#define get_field_rd(instr)        get_field (instr, RD_MASK, RD_LOW)
#define get_field_r1(instr)        get_field (instr, RA_MASK, RA_LOW)
#define get_field_r2(instr)        get_field (instr, RB_MASK, RB_LOW)
#define get_int_field_imm(instr)   ((instr & IMM_MASK) >> IMM_LOW)
#define get_int_field_r1(instr)    ((instr & RA_MASK) >> RA_LOW)



static char *
get_field (long instr, long mask, unsigned short low)
{
  char tmpstr[25];

  sprintf (tmpstr, "%s%d", register_prefix, (int)((instr & mask) >> low));
  return (strdup (tmpstr));
}

static char *
get_field_imm (long instr)
{
  char tmpstr[25];

  sprintf (tmpstr, "%d", (short)((instr & IMM_MASK) >> IMM_LOW));
  return (strdup (tmpstr));
}

static char *
get_field_imm5 (long instr)
{
  char tmpstr[25];

  sprintf (tmpstr, "%d", (short)((instr & IMM5_MASK) >> IMM_LOW));
  return (strdup (tmpstr));
}

static char *
get_field_imm5_mbar (long instr)
{
  char tmpstr[25];

  sprintf(tmpstr, "%d", (short)((instr & IMM5_MBAR_MASK) >> IMM_MBAR));
  return(strdup(tmpstr));
}

static char *
get_field_rfsl (long instr)
{
  char tmpstr[25];

  sprintf (tmpstr, "%s%d", fsl_register_prefix,
	   (short)((instr & RFSL_MASK) >> IMM_LOW));
  return (strdup (tmpstr));
}

static char *
get_field_imm15 (long instr)
{
  char tmpstr[25];

  sprintf (tmpstr, "%d", (short)((instr & IMM15_MASK) >> IMM_LOW));
  return (strdup (tmpstr));
}

static char *
get_field_special (long instr, struct op_code_struct * op)
{
  char tmpstr[25];
  char spr[6];

  switch ((((instr & IMM_MASK) >> IMM_LOW) ^ op->immval_mask))
    {
    case REG_MSR_MASK :
      strcpy (spr, "msr");
      break;
    case REG_PC_MASK :
      strcpy (spr, "pc");
      break;
    case REG_EAR_MASK :
      strcpy (spr, "ear");
      break;
    case REG_ESR_MASK :
      strcpy (spr, "esr");
      break;
    case REG_FSR_MASK :
      strcpy (spr, "fsr");
      break;
    case REG_BTR_MASK :
      strcpy (spr, "btr");
      break;
    case REG_EDR_MASK :
      strcpy (spr, "edr");
      break;
    case REG_PID_MASK :
      strcpy (spr, "pid");
      break;
    case REG_ZPR_MASK :
      strcpy (spr, "zpr");
      break;
    case REG_TLBX_MASK :
      strcpy (spr, "tlbx");
      break;
    case REG_TLBLO_MASK :
      strcpy (spr, "tlblo");
      break;
    case REG_TLBHI_MASK :
      strcpy (spr, "tlbhi");
      break;
    case REG_TLBSX_MASK :
      strcpy (spr, "tlbsx");
      break;
    case REG_SHR_MASK :
      strcpy (spr, "shr");
      break;
    case REG_SLR_MASK :
      strcpy (spr, "slr");
      break;
    default :
      if (((((instr & IMM_MASK) >> IMM_LOW) ^ op->immval_mask) & 0xE000)
          == REG_PVR_MASK)
        {
	  sprintf (tmpstr, "%spvr%d", register_prefix,
		   (unsigned short)(((instr & IMM_MASK) >> IMM_LOW)
                                    ^ op->immval_mask) ^ REG_PVR_MASK);
	  return (strdup (tmpstr));
        }
      else
        strcpy (spr, "pc");
      break;
    }

   sprintf (tmpstr, "%s%s", register_prefix, spr);
   return (strdup (tmpstr));
}

static unsigned long
read_insn_microblaze (bfd_vma memaddr,
		      struct disassemble_info *info,
		      struct op_code_struct **opr)
{
  unsigned char       ibytes[4];
  int                 status;
  struct op_code_struct * op;
  unsigned long inst;

  status = info->read_memory_func (memaddr, ibytes, 4, info);

  if (status != 0)
    {
      info->memory_error_func (status, memaddr, info);
      return 0;
    }

  if (info->endian == BFD_ENDIAN_BIG)
    inst = (ibytes[0] << 24) | (ibytes[1] << 16) | (ibytes[2] << 8) | ibytes[3];
  else if (info->endian == BFD_ENDIAN_LITTLE)
    inst = (ibytes[3] << 24) | (ibytes[2] << 16) | (ibytes[1] << 8) | ibytes[0];
  else
    abort ();

  /* Just a linear search of the table.  */
  for (op = opcodes; op->name != 0; op ++)
    if (op->bit_sequence == (inst & op->opcode_mask))
      break;

  *opr = op;
  return inst;
}


int
print_insn_microblaze (bfd_vma memaddr, struct disassemble_info * info)
{
  fprintf_ftype       print_func = info->fprintf_func;
  void *              stream = info->stream;
  unsigned long       inst, prev_inst;
  struct op_code_struct * op, *pop;
  int                 immval = 0;
  bfd_boolean         immfound = FALSE;
  static bfd_vma      prev_insn_addr = -1; /* Init the prev insn addr.  */
  static int          prev_insn_vma = -1;  /* Init the prev insn vma.  */
  int                 curr_insn_vma = info->buffer_vma;

  info->bytes_per_chunk = 4;

  inst = read_insn_microblaze (memaddr, info, &op);
  if (inst == 0)
    return -1;

  if (prev_insn_vma == curr_insn_vma)
    {
      if (memaddr-(info->bytes_per_chunk) == prev_insn_addr)
        {
          prev_inst = read_insn_microblaze (prev_insn_addr, info, &pop);
	  if (prev_inst == 0)
	    return -1;
	  if (pop->instr == imm)
	    {
	      immval = (get_int_field_imm (prev_inst) << 16) & 0xffff0000;
	      immfound = TRUE;
	    }
	  else
	    {
	      immval = 0;
	      immfound = FALSE;
	    }
	}
    }

  /* Make curr insn as prev insn.  */
  prev_insn_addr = memaddr;
  prev_insn_vma = curr_insn_vma;

  if (op->name == NULL)
    print_func (stream, ".short 0x%04x", (unsigned int) inst);
  else
    {
      print_func (stream, "%s", op->name);

      switch (op->inst_type)
	{
        case INST_TYPE_RD_R1_R2:
          print_func (stream, "\t%s, %s, %s", get_field_rd (inst),
		   get_field_r1(inst), get_field_r2 (inst));
          break;
        case INST_TYPE_RD_R1_IMM:
	  print_func (stream, "\t%s, %s, %s", get_field_rd (inst),
		   get_field_r1(inst), get_field_imm (inst));
	  if (info->print_address_func && get_int_field_r1 (inst) == 0
	      && info->symbol_at_address_func)
	    {
	      if (immfound)
	        immval |= (get_int_field_imm (inst) & 0x0000ffff);
	      else
		{
	          immval = get_int_field_imm (inst);
	          if (immval & 0x8000)
		    immval |= 0xFFFF0000;
	        }
	      if (immval > 0 && info->symbol_at_address_func (immval, info))
		{
	          print_func (stream, "\t// ");
	          info->print_address_func (immval, info);
	        }
	    }
	  break;
	case INST_TYPE_RD_R1_IMM5:
	  print_func (stream, "\t%s, %s, %s", get_field_rd (inst),
	           get_field_r1(inst), get_field_imm5 (inst));
	  break;
	case INST_TYPE_RD_RFSL:
	  print_func (stream, "\t%s, %s", get_field_rd (inst), get_field_rfsl (inst));
	  break;
	case INST_TYPE_R1_RFSL:
	  print_func (stream, "\t%s, %s", get_field_r1 (inst), get_field_rfsl (inst));
	  break;
	case INST_TYPE_RD_SPECIAL:
	  print_func (stream, "\t%s, %s", get_field_rd (inst),
		   get_field_special (inst, op));
	  break;
	case INST_TYPE_SPECIAL_R1:
	  print_func (stream, "\t%s, %s", get_field_special (inst, op),
		   get_field_r1(inst));
	  break;
	case INST_TYPE_RD_R1:
	  print_func (stream, "\t%s, %s", get_field_rd (inst), get_field_r1 (inst));
	  break;
	case INST_TYPE_R1_R2:
	  print_func (stream, "\t%s, %s", get_field_r1 (inst), get_field_r2 (inst));
	  break;
	case INST_TYPE_R1_IMM:
	  print_func (stream, "\t%s, %s", get_field_r1 (inst), get_field_imm (inst));
	  /* The non-pc relative instructions are returns, which shouldn't
	     have a label printed.  */
	  if (info->print_address_func && op->inst_offset_type == INST_PC_OFFSET
	      && info->symbol_at_address_func)
	    {
	      if (immfound)
	        immval |= (get_int_field_imm (inst) & 0x0000ffff);
	      else
		{
	          immval = get_int_field_imm (inst);
	          if (immval & 0x8000)
		    immval |= 0xFFFF0000;
	        }
	      immval += memaddr;
	      if (immval > 0 && info->symbol_at_address_func (immval, info))
		{
	          print_func (stream, "\t// ");
	          info->print_address_func (immval, info);
	        }
	      else
		{
	          print_func (stream, "\t\t// ");
	          print_func (stream, "%x", immval);
	        }
	    }
	  break;
        case INST_TYPE_RD_IMM:
	  print_func (stream, "\t%s, %s", get_field_rd (inst), get_field_imm (inst));
	  if (info->print_address_func && info->symbol_at_address_func)
	    {
	    if (immfound)
	      immval |= (get_int_field_imm (inst) & 0x0000ffff);
	    else
	      {
	        immval = get_int_field_imm (inst);
	        if (immval & 0x8000)
		  immval |= 0xFFFF0000;
	      }
	    if (op->inst_offset_type == INST_PC_OFFSET)
	      immval += (int) memaddr;
	    if (info->symbol_at_address_func (immval, info))
	      {
	        print_func (stream, "\t// ");
	        info->print_address_func (immval, info);
	      }
	    }
	  break;
        case INST_TYPE_IMM:
	  print_func (stream, "\t%s", get_field_imm (inst));
	  if (info->print_address_func && info->symbol_at_address_func
	      && op->instr != imm)
	    {
	      if (immfound)
	        immval |= (get_int_field_imm (inst) & 0x0000ffff);
	      else
		{
	          immval = get_int_field_imm (inst);
	          if (immval & 0x8000)
		    immval |= 0xFFFF0000;
	        }
	      if (op->inst_offset_type == INST_PC_OFFSET)
	        immval += (int) memaddr;
	      if (immval > 0 && info->symbol_at_address_func (immval, info))
		{
	          print_func (stream, "\t// ");
	          info->print_address_func (immval, info);
	        }
	      else if (op->inst_offset_type == INST_PC_OFFSET)
		{
	          print_func (stream, "\t\t// ");
	          print_func (stream, "%x", immval);
	        }
	    }
	  break;
        case INST_TYPE_RD_R2:
	  print_func (stream, "\t%s, %s", get_field_rd (inst), get_field_r2 (inst));
	  break;
	case INST_TYPE_R2:
	  print_func (stream, "\t%s", get_field_r2 (inst));
	  break;
	case INST_TYPE_R1:
	  print_func (stream, "\t%s", get_field_r1 (inst));
	  break;
	case INST_TYPE_R1_R2_SPECIAL:
	  print_func (stream, "\t%s, %s", get_field_r1 (inst), get_field_r2 (inst));
	  break;
	case INST_TYPE_RD_IMM15:
	  print_func (stream, "\t%s, %s", get_field_rd (inst), get_field_imm15 (inst));
	  break;
        /* For mbar insn.  */
        case INST_TYPE_IMM5:
          print_func (stream, "\t%s", get_field_imm5_mbar (inst));
          break;
        /* For mbar 16 or sleep insn.  */
        case INST_TYPE_NONE:
          break;
	/* For tuqula instruction */
	case INST_TYPE_RD:
	  print_func (stream, "\t%s", get_field_rd (inst));
	  break;
	case INST_TYPE_RFSL:
	  print_func (stream, "\t%s", get_field_rfsl (inst));
	  break;
	default:
	  /* If the disassembler lags the instruction set.  */
	  print_func (stream, "\tundecoded operands, inst is 0x%04x", (unsigned int) inst);
	  break;
	}
    }

  /* Say how many bytes we consumed.  */
  return 4;
}

enum microblaze_instr
get_insn_microblaze (long inst,
  		     bfd_boolean *isunsignedimm,
  		     enum microblaze_instr_type *insn_type,
  		     short *delay_slots)
{
  struct op_code_struct * op;
  *isunsignedimm = FALSE;

  /* Just a linear search of the table.  */
  for (op = opcodes; op->name != 0; op ++)
    if (op->bit_sequence == (inst & op->opcode_mask))
      break;

  if (op->name == 0)
    return invalid_inst;
  else
    {
      *isunsignedimm = (op->inst_type == INST_TYPE_RD_R1_UNSIGNED_IMM);
      *insn_type = op->instr_type;
      *delay_slots = op->delay_slots;
      return op->instr;
    }
}

enum microblaze_instr
microblaze_decode_insn (long insn, int *rd, int *ra, int *rb, int *immed)
{
  enum microblaze_instr op;
  bfd_boolean t1;
  enum microblaze_instr_type t2;
  short t3;

  op = get_insn_microblaze (insn, &t1, &t2, &t3);
  *rd = (insn & RD_MASK) >> RD_LOW;
  *ra = (insn & RA_MASK) >> RA_LOW;
  *rb = (insn & RB_MASK) >> RB_LOW;
  t3 = (insn & IMM_MASK) >> IMM_LOW;
  *immed = (int) t3;
  return (op);
}

unsigned long
microblaze_get_target_address (long inst, bfd_boolean immfound, int immval,
			       long pcval, long r1val, long r2val,
			       bfd_boolean *targetvalid,
			       bfd_boolean *unconditionalbranch)
{
  struct op_code_struct * op;
  long targetaddr = 0;

  *unconditionalbranch = FALSE;
  /* Just a linear search of the table.  */
  for (op = opcodes; op->name != 0; op ++)
    if (op->bit_sequence == (inst & op->opcode_mask))
      break;

  if (op->name == 0)
    {
      *targetvalid = FALSE;
    }
  else if (op->instr_type == branch_inst)
    {
      switch (op->inst_type)
	{
        case INST_TYPE_R2:
          *unconditionalbranch = TRUE;
        /* Fall through.  */
        case INST_TYPE_RD_R2:
        case INST_TYPE_R1_R2:
          targetaddr = r2val;
          *targetvalid = TRUE;
          if (op->inst_offset_type == INST_PC_OFFSET)
	    targetaddr += pcval;
          break;
        case INST_TYPE_IMM:
          *unconditionalbranch = TRUE;
        /* Fall through.  */
        case INST_TYPE_RD_IMM:
        case INST_TYPE_R1_IMM:
          if (immfound)
	    {
	      targetaddr = (immval << 16) & 0xffff0000;
	      targetaddr |= (get_int_field_imm (inst) & 0x0000ffff);
	    }
	  else
	    {
	      targetaddr = get_int_field_imm (inst);
	      if (targetaddr & 0x8000)
	        targetaddr |= 0xFFFF0000;
            }
          if (op->inst_offset_type == INST_PC_OFFSET)
	    targetaddr += pcval;
          *targetvalid = TRUE;
          break;
	default:
	  *targetvalid = FALSE;
	  break;
        }
    }
  else if (op->instr_type == return_inst)
    {
      if (immfound)
	{
	  targetaddr = (immval << 16) & 0xffff0000;
	  targetaddr |= (get_int_field_imm (inst) & 0x0000ffff);
	}
      else
	{
	  targetaddr = get_int_field_imm (inst);
	  if (targetaddr & 0x8000)
	    targetaddr |= 0xFFFF0000;
	}
      targetaddr += r1val;
      *targetvalid = TRUE;
    }
  else
    *targetvalid = FALSE;
  return targetaddr;
}
@


1.7
log
@
Add stack high register and stack low register for MicroBlaze
hardware assisted stack protection, stores stack low / stack high limits
for detecting stack overflow / underflow

binutils/opcodes
          * microblaze-opcm.h: Add REG_SLR_MASK, REG_SHR_MASK, REG_SHR and REG_SLR
          * microblaze-dis.c (get_field_special): Handle REG_SLR_MASK and REG_SHR_MASK
binutils/gas
          * config/tc-microblaze.c (parse_reg): Parse REG_SLR, REG_SHR
binutils/gas
          * gas/microblaze/allinsn.s: Test use of SHR, SLR
          * gas/microblaze/allinsn.d: Likewise
@
text
@d386 2
a387 2
	case INST_TYPE_RD_R1_SPECIAL:
	  print_func (stream, "\t%s, %s", get_field_rd (inst), get_field_r2 (inst));
@


1.6
log
@opcodes/
	* microblaze-opc.h: Define new instruction type INST_TYPE_IMM5,
	update OPCODE_MASK_H13S, add OPCODE_MASK_HN, define MIN_IMM5 / MAX_IMM5,
	and increase MAX_OPCODES.
	(op_code_struct):  add mbar and sleep
	* microblaze-opcm.h (microblaze_instr): add mbar
	Define IMM_MBAR and IMM5_MBAR_MASK
	* microblaze-dis.c: Add get_field_imm5_mbar
	(print_insn_microblaze): Add support for INST_TYPE_IMM5 and INST_TYPE_NONE

gas/
	* config/tc-microblaze.c (md_assemble): Add support for INST_TYPE_IMM5

gas/testsuite/
	* gas/microblaze/allinsn.s: Add mbar and sleep
	* gas/microblaze/allinsn.d: Likewise
@
text
@d142 6
@


1.5
log
@	PR binutils/13135
	* arm-dis.c: Add necessary casts for printing integer values.
	Use %s when printing string values.
	* hppa-dis.c: Likewise.
	* m68k-dis.c: Likewise.
	* microblaze-dis.c: Likewise.
	* mips-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* sparc-dis.c: Likewise.

	* dis-asm.h (fprintf_ftype): Add ATTRIBUTE_FPTR_PRINTF_2.
@
text
@d68 9
d386 7
@


1.4
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 1
a3 1
   Copyright 2009 Free Software Foundation, Inc.
d230 1
a230 1
    print_func (stream, ".short 0x%04x", inst);
d386 1
a386 1
	  print_func (stream, "\tundecoded operands, inst is 0x%04x", inst);
@


1.3
log
@* opcodes/microblaze-dis.c: Add include for microblaze-dis.h,
eliminate local extern decls.
* opcodes/microblaze-dis.h: New.
@
text
@d189 1
a189 1
  fprintf_ftype       fprintf = info->fprintf_func;
d230 1
a230 1
    fprintf (stream, ".short 0x%04x", inst);
d233 1
a233 1
      fprintf (stream, "%s", op->name);
d238 1
a238 1
          fprintf (stream, "\t%s, %s, %s", get_field_rd (inst),
d242 1
a242 1
	  fprintf (stream, "\t%s, %s, %s", get_field_rd (inst),
d257 1
a257 1
	          fprintf (stream, "\t// ");
d263 1
a263 1
	  fprintf (stream, "\t%s, %s, %s", get_field_rd (inst),
d267 1
a267 1
	  fprintf (stream, "\t%s, %s", get_field_rd (inst), get_field_rfsl (inst));
d270 1
a270 1
	  fprintf (stream, "\t%s, %s", get_field_r1 (inst), get_field_rfsl (inst));
d273 1
a273 1
	  fprintf (stream, "\t%s, %s", get_field_rd (inst),
d277 1
a277 1
	  fprintf (stream, "\t%s, %s", get_field_special (inst, op),
d281 1
a281 1
	  fprintf (stream, "\t%s, %s", get_field_rd (inst), get_field_r1 (inst));
d284 1
a284 1
	  fprintf (stream, "\t%s, %s", get_field_r1 (inst), get_field_r2 (inst));
d287 1
a287 1
	  fprintf (stream, "\t%s, %s", get_field_r1 (inst), get_field_imm (inst));
d304 1
a304 1
	          fprintf (stream, "\t// ");
d309 2
a310 2
	          fprintf (stream, "\t\t// ");
	          fprintf (stream, "%x", immval);
d315 1
a315 1
	  fprintf (stream, "\t%s, %s", get_field_rd (inst), get_field_imm (inst));
d330 1
a330 1
	        fprintf (stream, "\t// ");
d336 1
a336 1
	  fprintf (stream, "\t%s", get_field_imm (inst));
d352 1
a352 1
	          fprintf (stream, "\t// ");
d357 2
a358 2
	          fprintf (stream, "\t\t// ");
	          fprintf (stream, "%x", immval);
d363 1
a363 1
	  fprintf (stream, "\t%s, %s", get_field_rd (inst), get_field_r2 (inst));
d366 1
a366 1
	  fprintf (stream, "\t%s", get_field_r2 (inst));
d369 1
a369 1
	  fprintf (stream, "\t%s", get_field_r1 (inst));
d372 1
a372 1
	  fprintf (stream, "\t%s, %s", get_field_rd (inst), get_field_r2 (inst));
d375 1
a375 1
	  fprintf (stream, "\t%s, %s", get_field_rd (inst), get_field_imm15 (inst));
d379 1
a379 1
	  fprintf (stream, "\t%s", get_field_rd (inst));
d382 1
a382 1
	  fprintf (stream, "\t%s", get_field_rfsl (inst));
d386 1
a386 1
	  fprintf (stream, "\tundecoded operands, inst is 0x%04x", inst);
d421 1
a421 1
microblaze_decode_insn (long insn, int *rd, int *ra, int *rb, int *imm)
d433 1
a433 1
  *imm = (int) t3;
@


1.2
log
@2009-09-25  Michael Eager  <eager@@eagercon.com>

	* microblaze-dis.c (get_insn_microblaze, microblaze_get_target_address,
	microblaze_decode_insn): Add declarations.
	(get_delay_slots_microblaze): Remove.
@
text
@a26 1
#include "microblaze-opc.h"
d29 2
a38 5
enum microblaze_instr get_insn_microblaze (long, bfd_boolean *, 
					   enum microblaze_instr_type *, short *);
unsigned long microblaze_get_target_address (long, bfd_boolean, int, long, long,
					     long, bfd_boolean *, bfd_boolean *);
enum microblaze_instr microblaze_decode_insn (long insn, int *rd, int *ra, int *rb, int *imm);
@


1.1
log
@        Add support for Xilinx MicroBlaze processor.

        * bfd/Makefile.am: Add cpu-microblaze.{lo,c}, elf32-microblaze.{lo,c}.
        * bfd/Makefile.in: Same.
        * bfd/archures.c: Add bfd_arch_microblaze.
        * bfd/bfd-in2.h: Regenerate.
        * bfd/config.bfd: Add microblaze target.
        * bfd/configure: Add bfd_elf32_microblaze_vec target.
        * bfd/configure.in: Same.
        * bfd/cpu-microblaze.c: New.
        * bfd/elf32-microblaze.c: New.
        * bfd/libbfd-in.h: Add prototype _bfd_dwarf2_fixup_section_debug_loc().
        * bfd/libbfd.h: Regenerate.
        * bfd/reloc.c: Add MICROBLAZE relocations.
        * bfd/section.c: Add struct relax_table and relax_count to section.
        * bfd/targets.c: Add bfd_elf32_microblaze_vec.
        * binutils/MAINTAINERS: Add self as maintainer.
        * binutils/readelf.c: Include elf/microblaze.h, add EM_MICROBLAZE &
        EM_MICROBLAZE_OLD to guess_is_rela(), dump_relocations(),
        get_machine_name().
        * config.sub: Add microblaze target.
        * configure: Same.
        * configure.ac: Same.
        * gas/Makefile.am: add microblaze to CPU_TYPES, config/tc-microblaze.c to
        TARGET_CPU_CFILES, config/tc-microblaze.h to TARGET_CPU_HFILES, add
        DEP_microblaze_elf target.
        * gas/Makefile.in: Same.
        * gas/config/tc-microblaze.c: Add MicroBlaze assembler.
        * gas/config/tc-microblaze.h: Add header for tc-microblaze.c.
        * gas/configure: Add microblaze target.
        * gas/configure.in: Same.
        * gas/configure.tgt: Same.
        * gas/doc/Makefile.am: Add c-microblaze.texi to CPU_DOCS.
        * gas/doc/Makefile.in: Same.
        * gas/doc/all.texi: Set MICROBLAZE.
        * gas/doc/as.texinfo: Add MicroBlaze doc links.
        * gas/doc/c-microblaze.texi: New MicroBlaze docs.
        * include/dis-asm.h: Decl print_insn_microblaze().
        * include/elf/common.h: Define EM_MICROBLAZE & EM_MICROBLAZE_OLD.
        * include/elf/microblaze.h: New reloc definitions.
        * ld/Makefile.am: Add eelf32mb_linux.o, eelf32microblaze.o to
        ALL_EMULATIONS, targets.
        * ld/Makefile.in: Same.
        * ld/configure.tgt: Add microblaze*-linux*, microblaze* targets.
        * ld/emulparams/elf32mb_linux.sh: New.
        * ld/emulparams/elf32microblaze.sh. New.
        * ld/scripttempl/elfmicroblaze.sc: New.
        * opcodes/Makefile.am: Add microblaze-opc.h to HFILES, microblaze-dis.c to
        CFILES, microblaze-dis.lo to ALL_MACHINES, targets.
        * opcodes/Makefile.in: Same.
        * opcodes/configure: Add bfd_microblaze_arch target.
        * opcodes/configure.in: Same.
        * opcodes/disassemble.c: Define ARCH_microblaze, return
        print_insn_microblaze().
        * opcodes/microblaze-dis.c: New MicroBlaze disassembler.
        * opcodes/microblaze-opc.h: New MicroBlaze opcode definitions.
        * opcodes/microblaze-opcm.h: New MicroBlaze opcode types.
@
text
@d37 7
d398 2
a399 2
#if 0
static enum microblaze_instr
a423 15
short
get_delay_slots_microblaze (long inst)
{
  bfd_boolean isunsignedimm;
  enum microblaze_instr_type insn_type;
  enum microblaze_instr op;
  short delay_slots;

  op = get_insn_microblaze (inst, &isunsignedimm, &insn_type, &delay_slots);
  if (op == invalid_inst)
    return 0;
  else
    return delay_slots;
}

a518 1
#endif
@

