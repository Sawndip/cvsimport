head	1.11;
access;
symbols
	sid-snapshot-20180601:1.11
	sid-snapshot-20180501:1.11
	sid-snapshot-20180401:1.11
	sid-snapshot-20180301:1.11
	sid-snapshot-20180201:1.11
	sid-snapshot-20180101:1.11
	sid-snapshot-20171201:1.11
	sid-snapshot-20171101:1.11
	sid-snapshot-20171001:1.11
	sid-snapshot-20170901:1.11
	sid-snapshot-20170801:1.11
	sid-snapshot-20170701:1.11
	sid-snapshot-20170601:1.11
	sid-snapshot-20170501:1.11
	sid-snapshot-20170401:1.11
	sid-snapshot-20170301:1.11
	sid-snapshot-20170201:1.11
	sid-snapshot-20170101:1.11
	sid-snapshot-20161201:1.11
	sid-snapshot-20161101:1.11
	sid-snapshot-20160901:1.11
	sid-snapshot-20160801:1.11
	sid-snapshot-20160701:1.11
	sid-snapshot-20160601:1.11
	sid-snapshot-20160501:1.11
	sid-snapshot-20160401:1.11
	sid-snapshot-20160301:1.11
	sid-snapshot-20160201:1.11
	sid-snapshot-20160101:1.11
	sid-snapshot-20151201:1.11
	sid-snapshot-20151101:1.11
	sid-snapshot-20151001:1.11
	sid-snapshot-20150901:1.11
	sid-snapshot-20150801:1.11
	sid-snapshot-20150701:1.11
	sid-snapshot-20150601:1.11
	sid-snapshot-20150501:1.11
	sid-snapshot-20150401:1.11
	sid-snapshot-20150301:1.11
	sid-snapshot-20150201:1.11
	sid-snapshot-20150101:1.11
	sid-snapshot-20141201:1.11
	sid-snapshot-20141101:1.11
	sid-snapshot-20141001:1.11
	sid-snapshot-20140901:1.11
	sid-snapshot-20140801:1.11
	sid-snapshot-20140701:1.11
	sid-snapshot-20140601:1.11
	sid-snapshot-20140501:1.11
	sid-snapshot-20140401:1.11
	sid-snapshot-20140301:1.11
	sid-snapshot-20140201:1.11
	sid-snapshot-20140101:1.11
	sid-snapshot-20131201:1.11
	sid-snapshot-20131101:1.11
	sid-snapshot-20131001:1.11
	binutils-2_24-branch:1.11.0.2
	binutils-2_24-branchpoint:1.11
	binutils-2_21_1:1.5
	sid-snapshot-20130901:1.11
	gdb_7_6_1-2013-08-30-release:1.9
	sid-snapshot-20130801:1.11
	sid-snapshot-20130701:1.11
	sid-snapshot-20130601:1.9
	sid-snapshot-20130501:1.9
	gdb_7_6-2013-04-26-release:1.9
	sid-snapshot-20130401:1.9
	binutils-2_23_2:1.8
	gdb_7_6-branch:1.9.0.2
	gdb_7_6-2013-03-12-branchpoint:1.9
	sid-snapshot-20130301:1.9
	sid-snapshot-20130201:1.9
	sid-snapshot-20130101:1.9
	sid-snapshot-20121201:1.8
	gdb_7_5_1-2012-11-29-release:1.8
	binutils-2_23_1:1.8
	sid-snapshot-20121101:1.8
	binutils-2_23:1.8
	sid-snapshot-20121001:1.8
	sid-snapshot-20120901:1.8
	gdb_7_5-2012-08-17-release:1.8
	sid-snapshot-20120801:1.8
	binutils-2_23-branch:1.8.0.4
	binutils-2_23-branchpoint:1.8
	gdb_7_5-branch:1.8.0.2
	gdb_7_5-2012-07-18-branchpoint:1.8
	sid-snapshot-20120701:1.8
	sid-snapshot-20120601:1.8
	sid-snapshot-20120501:1.7
	binutils-2_22_branch:1.6.0.6
	gdb_7_4_1-2012-04-26-release:1.6
	sid-snapshot-20120401:1.6
	sid-snapshot-20120301:1.6
	sid-snapshot-20120201:1.6
	gdb_7_4-2012-01-24-release:1.6
	sid-snapshot-20120101:1.6
	gdb_7_4-branch:1.6.0.4
	gdb_7_4-2011-12-13-branchpoint:1.6
	sid-snapshot-20111201:1.6
	binutils-2_22:1.6
	sid-snapshot-20111101:1.6
	sid-snapshot-20111001:1.6
	binutils-2_22-branch:1.6.0.2
	binutils-2_22-branchpoint:1.6
	gdb_7_3_1-2011-09-04-release:1.5
	sid-snapshot-20110901:1.6
	sid-snapshot-20110801:1.6
	gdb_7_3-2011-07-26-release:1.5
	sid-snapshot-20110701:1.6
	sid-snapshot-20110601:1.6
	sid-snapshot-20110501:1.6
	gdb_7_3-branch:1.5.0.4
	gdb_7_3-2011-04-01-branchpoint:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	binutils-2_21:1.5
	sid-snapshot-20101201:1.5
	binutils-2_21-branch:1.5.0.2
	binutils-2_21-branchpoint:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	gdb_7_2-2010-09-02-release:1.3
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	gdb_7_2-branch:1.3.0.4
	gdb_7_2-2010-07-07-branchpoint:1.3
	sid-snapshot-20100701:1.3
	sid-snapshot-20100601:1.3
	sid-snapshot-20100501:1.3
	sid-snapshot-20100401:1.3
	gdb_7_1-2010-03-18-release:1.3
	sid-snapshot-20100301:1.3
	gdb_7_1-branch:1.3.0.2
	gdb_7_1-2010-02-18-branchpoint:1.3
	sid-snapshot-20100201:1.3
	sid-snapshot-20100101:1.3
	sid-snapshot-20091201:1.3
	sid-snapshot-20091101:1.2
	sid-snapshot-20091001:1.1
	binutils_latest_snapshot:1.11;
locks; strict;
comment	@# @;


1.11
date	2013.06.26.10.31.38;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2013.06.14.19.57.10;	author dj;	state Exp;
branches;
next	1.9;

1.9
date	2012.12.17.16.56.12;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2012.05.17.15.13.25;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2012.04.30.22.04.22;	author dj;	state Exp;
branches;
next	1.6;

1.6
date	2011.04.21.05.48.06;	author dj;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.29.18.41.27;	author dj;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.28.00.36.46;	author dj;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.05.00.38.44;	author dj;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.23.01.11.52;	author dj;	state Exp;
branches;
next	1.1;

1.1
date	2009.09.29.14.17.19;	author nickc;	state Exp;
branches;
next	;


desc
@@


1.11
log
@	* rx-decode.opc (rx_decode_opcode): Check sd field as well as ss
	field when checking for type 2 nop.
	* rx-decode.c: Regenerate.
@
text
@/* -*- c -*- */
/* Copyright 2012 Free Software Foundation, Inc.
   Contributed by Red Hat.
   Written by DJ Delorie.

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "ansidecl.h"
#include "opcode/rx.h"

#define RX_OPCODE_BIG_ENDIAN 0

typedef struct
{
  RX_Opcode_Decoded * rx;
  int (* getbyte)(void *);
  void * ptr;
  unsigned char * op;
} LocalData;

static int trace = 0;

#define BSIZE 0
#define WSIZE 1
#define LSIZE 2

/* These are for when the upper bits are "don't care" or "undefined".  */
static int bwl[] =
{
  RX_Byte,
  RX_Word,
  RX_Long
};

static int sbwl[] =
{
  RX_SByte,
  RX_SWord,
  RX_Long
};

static int ubwl[] =
{
  RX_UByte,
  RX_UWord,
  RX_Long
};

static int memex[] =
{
  RX_SByte,
  RX_SWord,
  RX_Long,
  RX_UWord
};

#define ID(x) rx->id = RXO_##x
#define OP(n,t,r,a) (rx->op[n].type = t, \
		     rx->op[n].reg = r,	     \
		     rx->op[n].addend = a )
#define OPs(n,t,r,a,s) (OP (n,t,r,a), \
			rx->op[n].size = s )

/* This is for the BWL and BW bitfields.  */
static int SCALE[] = { 1, 2, 4 };
/* This is for the prefix size enum.  */
static int PSCALE[] = { 4, 1, 1, 1, 2, 2, 2, 3, 4 };

static int flagmap[] = {0, 1, 2, 3, 0, 0, 0, 0,
		       16, 17, 0, 0, 0, 0, 0, 0 };

static int dsp3map[] = { 8, 9, 10, 3, 4, 5, 6, 7 };

/*
 *C	a constant (immediate) c
 *R	A register
 *I	Register indirect, no offset
 *Is	Register indirect, with offset
 *D	standard displacement: type (r,[r],dsp8,dsp16 code), register, BWL code
 *P	standard displacement: type (r,[r]), reg, assumes UByte
 *Pm	memex displacement: type (r,[r]), reg, memex code
 *cc	condition code.  */

#define DC(c)       OP (0, RX_Operand_Immediate, 0, c)
#define DR(r)       OP (0, RX_Operand_Register,  r, 0)
#define DI(r,a)     OP (0, RX_Operand_Indirect,  r, a)
#define DIs(r,a,s)  OP (0, RX_Operand_Indirect,  r, (a) * SCALE[s])
#define DD(t,r,s)   rx_disp (0, t, r, bwl[s], ld);
#define DF(r)       OP (0, RX_Operand_Flag,  flagmap[r], 0)

#define SC(i)       OP (1, RX_Operand_Immediate, 0, i)
#define SR(r)       OP (1, RX_Operand_Register,  r, 0)
#define SRR(r)      OP (1, RX_Operand_TwoReg,  r, 0)
#define SI(r,a)     OP (1, RX_Operand_Indirect,  r, a)
#define SIs(r,a,s)  OP (1, RX_Operand_Indirect,  r, (a) * SCALE[s])
#define SD(t,r,s)   rx_disp (1, t, r, bwl[s], ld);
#define SP(t,r)     rx_disp (1, t, r, (t!=3) ? RX_UByte : RX_Long, ld); P(t, 1);
#define SPm(t,r,m)  rx_disp (1, t, r, memex[m], ld); rx->op[1].size = memex[m];
#define Scc(cc)     OP (1, RX_Operand_Condition,  cc, 0)

#define S2C(i)      OP (2, RX_Operand_Immediate, 0, i)
#define S2R(r)      OP (2, RX_Operand_Register,  r, 0)
#define S2I(r,a)    OP (2, RX_Operand_Indirect,  r, a)
#define S2Is(r,a,s) OP (2, RX_Operand_Indirect,  r, (a) * SCALE[s])
#define S2D(t,r,s)  rx_disp (2, t, r, bwl[s], ld);
#define S2P(t,r)    rx_disp (2, t, r, (t!=3) ? RX_UByte : RX_Long, ld); P(t, 2);
#define S2Pm(t,r,m) rx_disp (2, t, r, memex[m], ld); rx->op[2].size = memex[m];
#define S2cc(cc)    OP (2, RX_Operand_Condition,  cc, 0)

#define BWL(sz)     rx->op[0].size = rx->op[1].size = rx->op[2].size = rx->size = bwl[sz]
#define sBWL(sz)    rx->op[0].size = rx->op[1].size = rx->op[2].size = rx->size = sbwl[sz]
#define uBWL(sz)    rx->op[0].size = rx->op[1].size = rx->op[2].size = rx->size = ubwl[sz]
#define P(t, n)	    rx->op[n].size = (t!=3) ? RX_UByte : RX_Long;

#define F(f) store_flags(rx, f)

#define AU ATTRIBUTE_UNUSED
#define GETBYTE() (ld->op [ld->rx->n_bytes++] = ld->getbyte (ld->ptr))

#define SYNTAX(x) rx->syntax = x

#define UNSUPPORTED() \
  rx->syntax = "*unknown*"

#define IMM(sf)   immediate (sf, 0, ld)
#define IMMex(sf) immediate (sf, 1, ld)

static int
immediate (int sfield, int ex, LocalData * ld)
{
  unsigned long i = 0, j;

  switch (sfield)
    {
#define B ((unsigned long) GETBYTE())
    case 0:
#if RX_OPCODE_BIG_ENDIAN
      i  = B;
      if (ex && (i & 0x80))
	i -= 0x100;
      i <<= 24;
      i |= B << 16;
      i |= B << 8;
      i |= B;
#else
      i = B;
      i |= B << 8;
      i |= B << 16;
      j = B;
      if (ex && (j & 0x80))
	j -= 0x100;
      i |= j << 24;
#endif
      break;
    case 3:
#if RX_OPCODE_BIG_ENDIAN
      i  = B << 16;
      i |= B << 8;
      i |= B;
#else
      i  = B;
      i |= B << 8;
      i |= B << 16;
#endif
      if (ex && (i & 0x800000))
	i -= 0x1000000;
      break;
    case 2:
#if RX_OPCODE_BIG_ENDIAN
      i |= B << 8;
      i |= B;
#else
      i |= B;
      i |= B << 8;
#endif
      if (ex && (i & 0x8000))
	i -= 0x10000;
      break;
    case 1:
      i |= B;
      if (ex && (i & 0x80))
	i -= 0x100;
      break;
    default:
      abort();
    }
  return i;
}

static void
rx_disp (int n, int type, int reg, int size, LocalData * ld)
{
  int disp;

  ld->rx->op[n].reg = reg;
  switch (type)
    {
    case 3:
      ld->rx->op[n].type = RX_Operand_Register;
      break;
    case 0:
      ld->rx->op[n].type = RX_Operand_Indirect;
      ld->rx->op[n].addend = 0;
      break;
    case 1:
      ld->rx->op[n].type = RX_Operand_Indirect;
      disp = GETBYTE ();
      ld->rx->op[n].addend = disp * PSCALE[size];
      break;
    case 2:
      ld->rx->op[n].type = RX_Operand_Indirect;
      disp = GETBYTE ();
#if RX_OPCODE_BIG_ENDIAN
      disp = disp * 256 + GETBYTE ();
#else
      disp = disp + GETBYTE () * 256;
#endif
      ld->rx->op[n].addend = disp * PSCALE[size];
      break;
    default:
      abort ();
    }
}

#define xO 8
#define xS 4
#define xZ 2
#define xC 1

#define F_____ 
#define F___ZC rx->flags_0 = rx->flags_s = xZ|xC;
#define F__SZ_ rx->flags_0 = rx->flags_s = xS|xZ;
#define F__SZC rx->flags_0 = rx->flags_s = xS|xZ|xC;
#define F_0SZC rx->flags_0 = xO|xS|xZ|xC; rx->flags_s = xS|xZ|xC;
#define F_O___ rx->flags_0 = rx->flags_s = xO;
#define F_OS__ rx->flags_0 = rx->flags_s = xO|xS;
#define F_OSZ_ rx->flags_0 = rx->flags_s = xO|xS|xZ;
#define F_OSZC rx->flags_0 = rx->flags_s = xO|xS|xZ|xC;

int
rx_decode_opcode (unsigned long pc AU,
		  RX_Opcode_Decoded * rx,
		  int (* getbyte)(void *),
		  void * ptr)
{
  LocalData lds, * ld = &lds;
  unsigned char op[20] = {0};

  lds.rx = rx;
  lds.getbyte = getbyte;
  lds.ptr = ptr;
  lds.op = op;

  memset (rx, 0, sizeof (*rx));
  BWL(LSIZE);

/** VARY sz 00 01 10 */

/*----------------------------------------------------------------------*/
/* MOV									*/

/** 0111 0101 0100 rdst		mov%s	#%1, %0 */
  ID(mov); DR(rdst); SC(IMM (1)); F_____;

/** 1111 10sd rdst im sz	mov%s	#%1, %0 */
  ID(mov); DD(sd, rdst, sz);
  if ((im == 1 && sz == 0)
      || (im == 2 && sz == 1)
      || (im == 0 && sz == 2))
    {
      BWL (sz);
      SC(IMM(im));
    }
  else
    {
      sBWL (sz);
      SC(IMMex(im));
    }
   F_____;

/** 0110 0110 immm rdst		mov%s	#%1, %0 */
  ID(mov); DR(rdst); SC(immm); F_____;

/** 0011 11sz d dst sppp		mov%s	#%1, %0 */
  ID(mov); sBWL (sz); DIs(dst, d*16+sppp, sz); SC(IMM(1)); F_____;

/** 11sz sd ss rsrc rdst	mov%s	%1, %0 */
  if (sd == 3 && ss == 3 && sz == 2 && rsrc == 0 && rdst == 0)
    {
      ID(nop2);
      rx->syntax = "nop";
    }
  else
    {
      ID(mov); sBWL(sz); F_____;
      if ((ss == 3) && (sd != 3))
	{
	  SD(ss, rdst, sz); DD(sd, rsrc, sz);
	}
      else
	{
	  SD(ss, rsrc, sz); DD(sd, rdst, sz);
	}
    }

/** 10sz 1dsp a src b dst	mov%s	%1, %0 */
  ID(mov); sBWL(sz); DR(dst); SIs(src, dsp*4+a*2+b, sz); F_____;

/** 10sz 0dsp a dst b src	mov%s	%1, %0 */
  ID(mov); sBWL(sz); DIs(dst, dsp*4+a*2+b, sz); SR(src); F_____;

/** 1111 1110 01sz isrc bsrc rdst	mov%s	[%1, %2], %0 */
  ID(movbi); sBWL(sz); DR(rdst); SRR(isrc); S2R(bsrc); F_____;

/** 1111 1110 00sz isrc bsrc rdst	mov%s	%0, [%1, %2] */
  ID(movbir); sBWL(sz); DR(rdst); SRR(isrc); S2R(bsrc); F_____;

/** 1111 1110 11sz isrc bsrc rdst	movu%s	[%1, %2], %0 */
  ID(movbi); uBWL(sz); DR(rdst); SRR(isrc); S2R(bsrc); F_____;

/** 1111 1101 0010 0p sz rdst rsrc	mov%s	%1, %0 */
  ID(mov); sBWL (sz); SR(rsrc); F_____;
  OP(0, p ? RX_Operand_Predec : RX_Operand_Postinc, rdst, 0);

/** 1111 1101 0010 1p sz rsrc rdst	mov%s	%1, %0 */
  ID(mov); sBWL (sz); DR(rdst); F_____;
  OP(1, p ? RX_Operand_Predec : RX_Operand_Postinc, rsrc, 0);

/** 1011 w dsp a src b dst	movu%s	%1, %0 */
  ID(mov); uBWL(w); DR(dst); SIs(src, dsp*4+a*2+b, w); F_____;

/** 0101 1 s ss rsrc rdst	movu%s	%1, %0 */
  ID(mov); uBWL(s); SD(ss, rsrc, s); DR(rdst); F_____;

/** 1111 1101 0011 1p sz rsrc rdst	movu%s	%1, %0 */
  ID(mov); uBWL (sz); DR(rdst); F_____;
   OP(1, p ? RX_Operand_Predec : RX_Operand_Postinc, rsrc, 0);

/*----------------------------------------------------------------------*/
/* PUSH/POP								*/

/** 0110 1111 dsta dstb		popm	%1-%2 */
  ID(popm); SR(dsta); S2R(dstb); F_____;

/** 0110 1110 dsta dstb		pushm	%1-%2 */
  ID(pushm); SR(dsta); S2R(dstb); F_____;
  
/** 0111 1110 1011 rdst		pop	%0 */
  ID(mov); OP(1, RX_Operand_Postinc, 0, 0); DR(rdst); F_____;
  
/** 0111 1110 10sz rsrc		push%s	%1 */
  ID(mov); BWL(sz); OP(0, RX_Operand_Predec, 0, 0); SR(rsrc); F_____;

/** 1111 01ss rsrc 10sz		push%s	%1 */
  ID(mov); BWL(sz); OP(0, RX_Operand_Predec, 0, 0); SD(ss, rsrc, sz); F_____;

/*----------------------------------------------------------------------*/
/* XCHG									*/

/** 1111 1100 0100 00ss rsrc rdst	xchg	%1%S1, %0 */
  ID(xchg); DR(rdst); SP(ss, rsrc);

/** 0000 0110 mx10 00ss 0001 0000 rsrc rdst	xchg	%1%S1, %0 */
  ID(xchg); DR(rdst); SPm(ss, rsrc, mx);

/*----------------------------------------------------------------------*/
/* STZ/STNZ								*/

/** 1111 1101 0111 im00 1110rdst	stz	#%1, %0 */
  ID(stcc); SC(IMMex(im)); DR(rdst); S2cc(RXC_z);

/** 1111 1101 0111 im00 1111rdst	stnz	#%1, %0 */
  ID(stcc); SC(IMMex(im)); DR(rdst); S2cc(RXC_nz);

/*----------------------------------------------------------------------*/
/* RTSD									*/

/** 0110 0111			rtsd	#%1 */
  ID(rtsd); SC(IMM(1) * 4);

/** 0011 1111 rega regb		rtsd	#%1, %2-%0 */
  ID(rtsd); SC(IMM(1) * 4); S2R(rega); DR(regb);

/*----------------------------------------------------------------------*/
/* AND									*/

/** 0110 0100 immm rdst			and	#%1, %0 */
  ID(and); SC(immm); DR(rdst); F__SZ_;

/** 0111 01im 0010 rdst			and	#%1, %0 */
  ID(and); SC(IMMex(im)); DR(rdst); F__SZ_;

/** 0101 00ss rsrc rdst			and	%1%S1, %0 */
  ID(and); SP(ss, rsrc); DR(rdst); F__SZ_;

/** 0000 0110 mx01 00ss rsrc rdst	and	%1%S1, %0 */
  ID(and); SPm(ss, rsrc, mx); DR(rdst); F__SZ_;

/** 1111 1111 0100 rdst srca srcb	and	%2, %1, %0 */
  ID(and); DR(rdst); SR(srcb); S2R(srca); F__SZ_;

/*----------------------------------------------------------------------*/
/* OR									*/

/** 0110 0101 immm rdst			or	#%1, %0 */
  ID(or); SC(immm); DR(rdst); F__SZ_;

/** 0111 01im 0011 rdst			or	#%1, %0 */
  ID(or); SC(IMMex(im)); DR(rdst); F__SZ_;

/** 0101 01ss rsrc rdst			or	%1%S1, %0 */
  ID(or); SP(ss, rsrc); DR(rdst); F__SZ_;

/** 0000 0110 mx01 01ss rsrc rdst			or	%1%S1, %0 */
  ID(or); SPm(ss, rsrc, mx); DR(rdst); F__SZ_;

/** 1111 1111 0101 rdst srca srcb	or	%2, %1, %0 */
  ID(or); DR(rdst); SR(srcb); S2R(srca); F__SZ_;

/*----------------------------------------------------------------------*/
/* XOR									*/

/** 1111 1101 0111 im00 1101rdst	xor	#%1, %0 */
  ID(xor); SC(IMMex(im)); DR(rdst); F__SZ_;

/** 1111 1100 0011 01ss rsrc rdst	xor	%1%S1, %0 */
  ID(xor); SP(ss, rsrc); DR(rdst); F__SZ_;

/** 0000 0110 mx10 00ss 0000 1101 rsrc rdst	xor	%1%S1, %0 */
  ID(xor); SPm(ss, rsrc, mx); DR(rdst); F__SZ_;

/*----------------------------------------------------------------------*/
/* NOT									*/

/** 0111 1110 0000 rdst			not	%0 */
  ID(xor); DR(rdst); SR(rdst); S2C(~0); F__SZ_;

/** 1111 1100 0011 1011 rsrc rdst	not	%1, %0 */
  ID(xor); DR(rdst); SR(rsrc); S2C(~0); F__SZ_;

/*----------------------------------------------------------------------*/
/* TST									*/

/** 1111 1101 0111 im00 1100rdst	tst	#%1, %2 */
  ID(and); SC(IMMex(im)); S2R(rdst); F__SZ_;

/** 1111 1100 0011 00ss rsrc rdst	tst	%1%S1, %2 */
  ID(and); SP(ss, rsrc); S2R(rdst); F__SZ_;

/** 0000 0110 mx10 00ss 0000 1100 rsrc rdst	tst	%1%S1, %2 */
  ID(and); SPm(ss, rsrc, mx); S2R(rdst); F__SZ_;

/*----------------------------------------------------------------------*/
/* NEG									*/

/** 0111 1110 0001 rdst			neg	%0 */
  ID(sub); DR(rdst); SC(0); S2R(rdst); F_OSZC;

/** 1111 1100 0000 0111 rsrc rdst	neg	%2, %0 */
  ID(sub); DR(rdst); SC(0); S2R(rsrc); F_OSZC;

/*----------------------------------------------------------------------*/
/* ADC									*/

/** 1111 1101 0111 im00 0010rdst	adc	#%1, %0 */
  ID(adc); SC(IMMex(im)); DR(rdst); F_OSZC;

/** 1111 1100 0000 1011 rsrc rdst	adc	%1, %0 */
  ID(adc); SR(rsrc); DR(rdst); F_OSZC;

/** 0000 0110 1010 00ss 0000 0010 rsrc rdst	adc	%1%S1, %0 */
  ID(adc); SPm(ss, rsrc, 2); DR(rdst); F_OSZC;

/*----------------------------------------------------------------------*/
/* ADD									*/

/** 0110 0010 immm rdst			add	#%1, %0 */
  ID(add); SC(immm); DR(rdst); F_OSZC;

/** 0100 10ss rsrc rdst			add	%1%S1, %0 */
  ID(add); SP(ss, rsrc); DR(rdst); F_OSZC;

/** 0000 0110 mx00 10ss rsrc rdst	add	%1%S1, %0 */
  ID(add); SPm(ss, rsrc, mx); DR(rdst); F_OSZC;

/** 0111 00im rsrc rdst			add	#%1, %2, %0 */
  ID(add); SC(IMMex(im)); S2R(rsrc); DR(rdst); F_OSZC;

/** 1111 1111 0010 rdst srca srcb	add	%2, %1, %0 */
  ID(add); DR(rdst); SR(srcb); S2R(srca); F_OSZC;

/*----------------------------------------------------------------------*/
/* CMP									*/

/** 0110 0001 immm rdst			cmp	#%2, %1 */
  ID(sub); S2C(immm); SR(rdst); F_OSZC;

/** 0111 01im 0000 rsrc		cmp	#%2, %1%S1 */
  ID(sub); SR(rsrc); S2C(IMMex(im)); F_OSZC;

/** 0111 0101 0101 rsrc			cmp	#%2, %1 */
  ID(sub); SR(rsrc); S2C(IMM(1)); F_OSZC;

/** 0100 01ss rsrc rdst		cmp	%2%S2, %1 */
  ID(sub); S2P(ss, rsrc); SR(rdst); F_OSZC;

/** 0000 0110 mx00 01ss rsrc rdst		cmp	%2%S2, %1 */
  ID(sub); S2Pm(ss, rsrc, mx); SR(rdst); F_OSZC;

/*----------------------------------------------------------------------*/
/* SUB									*/

/** 0110 0000 immm rdst			sub	#%2, %0 */
  ID(sub); S2C(immm); SR(rdst); DR(rdst); F_OSZC;

/** 0100 00ss rsrc rdst			sub	%2%S2, %1 */
  ID(sub); S2P(ss, rsrc); SR(rdst); DR(rdst); F_OSZC;

/** 0000 0110 mx00 00ss rsrc rdst			sub	%2%S2, %1 */
  ID(sub); S2Pm(ss, rsrc, mx); SR(rdst); DR(rdst); F_OSZC;

/** 1111 1111 0000 rdst srca srcb	sub	%2, %1, %0 */
  ID(sub); DR(rdst); SR(srcb); S2R(srca); F_OSZC;

/*----------------------------------------------------------------------*/
/* SBB									*/

/** 1111 1100 0000 0011 rsrc rdst	sbb	%1, %0 */
  ID(sbb); SR (rsrc); DR(rdst); F_OSZC;

  /* FIXME: only supports .L */
/** 0000 0110 mx10 00sp 0000 0000 rsrc rdst	sbb	%1%S1, %0 */
  ID(sbb); SPm(sp, rsrc, mx); DR(rdst); F_OSZC;

/*----------------------------------------------------------------------*/
/* ABS									*/

/** 0111 1110 0010 rdst			abs	%0 */
  ID(abs); DR(rdst); SR(rdst); F_OSZ_;

/** 1111 1100 0000 1111 rsrc rdst	abs	%1, %0 */
  ID(abs); DR(rdst); SR(rsrc); F_OSZ_;

/*----------------------------------------------------------------------*/
/* MAX									*/

/** 1111 1101 0111 im00 0100rdst	max	#%1, %0 */
  ID(max); DR(rdst); SC(IMMex(im));

/** 1111 1100 0001 00ss rsrc rdst	max	%1%S1, %0 */
  if (ss == 3 && rsrc == 0 && rdst == 0)
    {
      ID(nop3);
      rx->syntax = "nop";
    }
  else
    {
      ID(max); SP(ss, rsrc); DR(rdst);
    }

/** 0000 0110 mx10 00ss 0000 0100 rsrc rdst	max	%1%S1, %0 */
  ID(max); SPm(ss, rsrc, mx); DR(rdst);

/*----------------------------------------------------------------------*/
/* MIN									*/

/** 1111 1101 0111 im00 0101rdst	min	#%1, %0 */
  ID(min); DR(rdst); SC(IMMex(im));

/** 1111 1100 0001 01ss rsrc rdst	min	%1%S1, %0 */
  ID(min); SP(ss, rsrc); DR(rdst);

/** 0000 0110 mx10 00ss 0000 0101 rsrc rdst	min	%1%S1, %0 */
  ID(min); SPm(ss, rsrc, mx); DR(rdst);

/*----------------------------------------------------------------------*/
/* MUL									*/

/** 0110 0011 immm rdst			mul	#%1, %0 */
  ID(mul); DR(rdst); SC(immm); F_____;

/** 0111 01im 0001rdst			mul	#%1, %0 */
  ID(mul); DR(rdst); SC(IMMex(im)); F_____;

/** 0100 11ss rsrc rdst			mul	%1%S1, %0 */
  ID(mul); SP(ss, rsrc); DR(rdst); F_____;

/** 0000 0110 mx00 11ss rsrc rdst	mul	%1%S1, %0 */
  ID(mul); SPm(ss, rsrc, mx); DR(rdst); F_____;

/** 1111 1111 0011 rdst srca srcb	mul 	%2, %1, %0 */
  ID(mul); DR(rdst); SR(srcb); S2R(srca); F_____;

/*----------------------------------------------------------------------*/
/* EMUL									*/

/** 1111 1101 0111 im00 0110rdst	emul	#%1, %0 */
  ID(emul); DR(rdst); SC(IMMex(im));

/** 1111 1100 0001 10ss rsrc rdst	emul	%1%S1, %0 */
  ID(emul); SP(ss, rsrc); DR(rdst);

/** 0000 0110 mx10 00ss 0000 0110 rsrc rdst	emul	%1%S1, %0 */
  ID(emul); SPm(ss, rsrc, mx); DR(rdst);

/*----------------------------------------------------------------------*/
/* EMULU									*/

/** 1111 1101 0111 im00 0111rdst	emulu	#%1, %0 */
  ID(emulu); DR(rdst); SC(IMMex(im));

/** 1111 1100 0001 11ss rsrc rdst	emulu	%1%S1, %0 */
  ID(emulu); SP(ss, rsrc); DR(rdst);

/** 0000 0110 mx10 00ss 0000 0111 rsrc rdst	emulu	%1%S1, %0 */
  ID(emulu); SPm(ss, rsrc, mx); DR(rdst);

/*----------------------------------------------------------------------*/
/* DIV									*/

/** 1111 1101 0111 im00 1000rdst	div	#%1, %0 */
  ID(div); DR(rdst); SC(IMMex(im)); F_O___;

/** 1111 1100 0010 00ss rsrc rdst	div	%1%S1, %0 */
  ID(div); SP(ss, rsrc); DR(rdst); F_O___;

/** 0000 0110 mx10 00ss 0000 1000 rsrc rdst	div	%1%S1, %0 */
  ID(div); SPm(ss, rsrc, mx); DR(rdst); F_O___;

/*----------------------------------------------------------------------*/
/* DIVU									*/

/** 1111 1101 0111 im00 1001rdst	divu	#%1, %0 */
  ID(divu); DR(rdst); SC(IMMex(im)); F_O___;

/** 1111 1100 0010 01ss rsrc rdst	divu	%1%S1, %0 */
  ID(divu); SP(ss, rsrc); DR(rdst); F_O___;

/** 0000 0110 mx10 00ss 0000 1001 rsrc rdst	divu	%1%S1, %0 */
  ID(divu); SPm(ss, rsrc, mx); DR(rdst); F_O___;

/*----------------------------------------------------------------------*/
/* SHIFT								*/

/** 0110 110i mmmm rdst			shll	#%2, %0 */
  ID(shll); S2C(i*16+mmmm); SR(rdst); DR(rdst); F_OSZC;

/** 1111 1101 0110 0010 rsrc rdst	shll	%2, %0 */
  ID(shll); S2R(rsrc); SR(rdst); DR(rdst); F_OSZC;

/** 1111 1101 110immmm rsrc rdst	shll	#%2, %1, %0 */
  ID(shll); S2C(immmm); SR(rsrc); DR(rdst); F_OSZC;


/** 0110 101i mmmm rdst			shar	#%2, %0 */
  ID(shar); S2C(i*16+mmmm); SR(rdst); DR(rdst); F_0SZC;

/** 1111 1101 0110 0001 rsrc rdst	shar	%2, %0 */
  ID(shar); S2R(rsrc); SR(rdst); DR(rdst); F_0SZC;

/** 1111 1101 101immmm rsrc rdst	shar	#%2, %1, %0 */
  ID(shar); S2C(immmm); SR(rsrc); DR(rdst); F_0SZC;


/** 0110 100i mmmm rdst			shlr	#%2, %0 */
  ID(shlr); S2C(i*16+mmmm); SR(rdst); DR(rdst); F__SZC;

/** 1111 1101 0110 0000 rsrc rdst	shlr	%2, %0 */
  ID(shlr); S2R(rsrc); SR(rdst); DR(rdst); F__SZC;

/** 1111 1101 100immmm rsrc rdst	shlr	#%2, %1, %0 */
  ID(shlr); S2C(immmm); SR(rsrc); DR(rdst); F__SZC;

/*----------------------------------------------------------------------*/
/* ROTATE								*/

/** 0111 1110 0101 rdst			rolc	%0 */
  ID(rolc); DR(rdst); F__SZC;

/** 0111 1110 0100 rdst			rorc	%0 */
  ID(rorc); DR(rdst); F__SZC;

/** 1111 1101 0110 111i mmmm rdst	rotl	#%1, %0 */
  ID(rotl); SC(i*16+mmmm); DR(rdst); F__SZC;

/** 1111 1101 0110 0110 rsrc rdst	rotl	%1, %0 */
  ID(rotl); SR(rsrc); DR(rdst); F__SZC;

/** 1111 1101 0110 110i mmmm rdst	rotr	#%1, %0 */
  ID(rotr); SC(i*16+mmmm); DR(rdst); F__SZC;

/** 1111 1101 0110 0100 rsrc rdst	rotr	%1, %0 */
  ID(rotr); SR(rsrc); DR(rdst); F__SZC;

/** 1111 1101 0110 0101 rsrc rdst	revw	%1, %0 */
  ID(revw); SR(rsrc); DR(rdst);

/** 1111 1101 0110 0111 rsrc rdst	revl	%1, %0 */
  ID(revl); SR(rsrc); DR(rdst);

/*----------------------------------------------------------------------*/
/* BRANCH								*/

/** 0001 n dsp			b%1.s	%a0 */
  ID(branch); Scc(n); DC(pc + dsp3map[dsp]);

/** 0010 cond			b%1.b	%a0 */
  ID(branch); Scc(cond); DC(pc + IMMex (1));

/** 0011 101c			b%1.w	%a0 */
  ID(branch); Scc(c); DC(pc + IMMex (2));


/** 0000 1dsp			bra.s	%a0 */
  ID(branch); DC(pc + dsp3map[dsp]);

/** 0010 1110			bra.b	%a0 */
  ID(branch); DC(pc + IMMex(1));

/** 0011 1000			bra.w	%a0 */
  ID(branch); DC(pc + IMMex(2));

/** 0000 0100			bra.a	%a0 */
  ID(branch); DC(pc + IMMex(3));

/** 0111 1111 0100 rsrc		bra.l	%0 */
  ID(branchrel); DR(rsrc);


/** 0111 1111 0000 rsrc		jmp	%0 */
  ID(branch); DR(rsrc);

/** 0111 1111 0001 rsrc		jsr	%0 */
  ID(jsr); DR(rsrc);

/** 0011 1001			bsr.w	%a0 */
  ID(jsr); DC(pc + IMMex(2));

/** 0000 0101			bsr.a	%a0 */
  ID(jsr); DC(pc + IMMex(3));

/** 0111 1111 0101 rsrc		bsr.l	%0 */
  ID(jsrrel); DR(rsrc);

/** 0000 0010			rts */
  ID(rts);

/*----------------------------------------------------------------------*/
/* NOP								*/

/** 0000 0011			nop */
  ID(nop);

/*----------------------------------------------------------------------*/
/* STRING FUNCTIONS							*/

/** 0111 1111 1000 0011		scmpu */
  ID(scmpu); F___ZC;

/** 0111 1111 1000 0111		smovu */
  ID(smovu);

/** 0111 1111 1000 1011		smovb */
  ID(smovb);

/** 0111 1111 1000 00sz		suntil%s */
  ID(suntil); BWL(sz); F___ZC;

/** 0111 1111 1000 01sz		swhile%s */
  ID(swhile); BWL(sz); F___ZC;

/** 0111 1111 1000 1111		smovf */
  ID(smovf);

/** 0111 1111 1000 10sz		sstr%s */
  ID(sstr); BWL(sz);

/*----------------------------------------------------------------------*/
/* RMPA									*/

/** 0111 1111 1000 11sz		rmpa%s */
  ID(rmpa); BWL(sz); F_OS__;

/*----------------------------------------------------------------------*/
/* HI/LO stuff								*/

/** 1111 1101 0000 0000 srca srcb	mulhi	%1, %2 */
  ID(mulhi); SR(srca); S2R(srcb); F_____;

/** 1111 1101 0000 0001 srca srcb	mullo	%1, %2 */
  ID(mullo); SR(srca); S2R(srcb); F_____;

/** 1111 1101 0000 0100 srca srcb	machi	%1, %2 */
  ID(machi); SR(srca); S2R(srcb); F_____;

/** 1111 1101 0000 0101 srca srcb	maclo	%1, %2 */
  ID(maclo); SR(srca); S2R(srcb); F_____;

/** 1111 1101 0001 0111 0000 rsrc	mvtachi	%1 */
  ID(mvtachi); SR(rsrc); F_____;

/** 1111 1101 0001 0111 0001 rsrc	mvtaclo	%1 */
  ID(mvtaclo); SR(rsrc); F_____;

/** 1111 1101 0001 1111 0000 rdst	mvfachi	%0 */
  ID(mvfachi); DR(rdst); F_____;

/** 1111 1101 0001 1111 0010 rdst	mvfacmi	%0 */
  ID(mvfacmi); DR(rdst); F_____;

/** 1111 1101 0001 1111 0001 rdst	mvfaclo	%0 */
  ID(mvfaclo); DR(rdst); F_____;

/** 1111 1101 0001 1000 000i 0000	racw	#%1 */
  ID(racw); SC(i+1); F_____;

/*----------------------------------------------------------------------*/
/* SAT									*/

/** 0111 1110 0011 rdst		sat	%0 */
  ID(sat); DR (rdst);

/** 0111 1111 1001 0011		satr */
  ID(satr);

/*----------------------------------------------------------------------*/
/* FLOAT								*/

/** 1111 1101 0111 0010 0010 rdst	fadd	#%1, %0 */
  ID(fadd); DR(rdst); SC(IMM(0)); F__SZ_;

/** 1111 1100 1000 10sd rsrc rdst	fadd	%1%S1, %0 */
  ID(fadd); DR(rdst); SD(sd, rsrc, LSIZE); F__SZ_;

/** 1111 1101 0111 0010 0001 rdst	fcmp	#%1, %0 */
  ID(fcmp); DR(rdst); SC(IMM(0)); F_OSZ_;

/** 1111 1100 1000 01sd rsrc rdst	fcmp	%1%S1, %0 */
  ID(fcmp); DR(rdst); SD(sd, rsrc, LSIZE); F_OSZ_;

/** 1111 1101 0111 0010 0000 rdst	fsub	#%1, %0 */
  ID(fsub); DR(rdst); SC(IMM(0)); F__SZ_;

/** 1111 1100 1000 00sd rsrc rdst	fsub	%1%S1, %0 */
  ID(fsub); DR(rdst); SD(sd, rsrc, LSIZE); F__SZ_;

/** 1111 1100 1001 01sd rsrc rdst	ftoi	%1%S1, %0 */
  ID(ftoi); DR(rdst); SD(sd, rsrc, LSIZE); F__SZ_;

/** 1111 1101 0111 0010 0011 rdst	fmul	#%1, %0 */
  ID(fmul); DR(rdst); SC(IMM(0)); F__SZ_;

/** 1111 1100 1000 11sd rsrc rdst	fmul	%1%S1, %0 */
  ID(fmul); DR(rdst); SD(sd, rsrc, LSIZE); F__SZ_;

/** 1111 1101 0111 0010 0100 rdst	fdiv	#%1, %0 */
  ID(fdiv); DR(rdst); SC(IMM(0)); F__SZ_;

/** 1111 1100 1001 00sd rsrc rdst	fdiv	%1%S1, %0 */
  ID(fdiv); DR(rdst); SD(sd, rsrc, LSIZE); F__SZ_;

/** 1111 1100 1001 10sd rsrc rdst	round	%1%S1, %0 */
  ID(round); DR(rdst); SD(sd, rsrc, LSIZE); F__SZ_;

/** 1111 1100 0100 01sd rsrc rdst	itof	%1%S1, %0 */
  ID(itof); DR (rdst); SP(sd, rsrc); F__SZ_;

/** 0000 0110 mx10 00sd 0001 0001 rsrc rdst	itof	%1%S1, %0 */
  ID(itof); DR (rdst); SPm(sd, rsrc, mx); F__SZ_;

/*----------------------------------------------------------------------*/
/* BIT OPS								*/

/** 1111 00sd rdst 0bit			bset	#%1, %0%S0 */
  ID(bset); BWL(BSIZE); SC(bit); DD(sd, rdst, BSIZE); F_____;

/** 1111 1100 0110 00sd rdst rsrc	bset	%1, %0%S0 */
  ID(bset); BWL(BSIZE); SR(rsrc); DD(sd, rdst, BSIZE); F_____;
  if (sd == 3) /* bset reg,reg */
    BWL(LSIZE);

/** 0111 100b ittt rdst			bset	#%1, %0 */
  ID(bset); BWL(LSIZE); SC(b*16+ittt); DR(rdst); F_____;


/** 1111 00sd rdst 1bit			bclr	#%1, %0%S0 */
  ID(bclr); BWL(BSIZE); SC(bit); DD(sd, rdst, BSIZE); F_____;

/** 1111 1100 0110 01sd rdst rsrc	bclr	%1, %0%S0 */
  ID(bclr); BWL(BSIZE); SR(rsrc); DD(sd, rdst, BSIZE); F_____;
  if (sd == 3) /* bset reg,reg */
    BWL(LSIZE);

/** 0111 101b ittt rdst			bclr	#%1, %0 */
  ID(bclr); BWL(LSIZE); SC(b*16+ittt); DR(rdst); F_____;


/** 1111 01sd rdst 0bit			btst	#%2, %1%S1 */
  ID(btst); BWL(BSIZE); S2C(bit); SD(sd, rdst, BSIZE); F___ZC;

/** 1111 1100 0110 10sd rdst rsrc	btst	%2, %1%S1 */
  ID(btst); BWL(BSIZE); S2R(rsrc); SD(sd, rdst, BSIZE); F___ZC;
  if (sd == 3) /* bset reg,reg */
    BWL(LSIZE);

/** 0111 110b ittt rdst			btst	#%2, %1 */
  ID(btst); BWL(LSIZE); S2C(b*16+ittt); SR(rdst); F___ZC;


/** 1111 1100 111bit sd rdst 1111	bnot	#%1, %0%S0 */
  ID(bnot); BWL(BSIZE); SC(bit); DD(sd, rdst, BSIZE);

/** 1111 1100 0110 11sd rdst rsrc	bnot	%1, %0%S0 */
  ID(bnot); BWL(BSIZE); SR(rsrc); DD(sd, rdst, BSIZE);
  if (sd == 3) /* bset reg,reg */
    BWL(LSIZE);

/** 1111 1101 111bittt 1111 rdst	bnot	#%1, %0 */
  ID(bnot); BWL(LSIZE); SC(bittt); DR(rdst);


/** 1111 1100 111bit sd rdst cond	bm%2	#%1, %0%S0 */
  ID(bmcc); BWL(BSIZE); S2cc(cond); SC(bit); DD(sd, rdst, BSIZE);

/** 1111 1101 111 bittt cond rdst	bm%2	#%1, %0%S0 */
  ID(bmcc); BWL(LSIZE); S2cc(cond); SC(bittt); DR(rdst);

/*----------------------------------------------------------------------*/
/* CONTROL REGISTERS							*/

/** 0111 1111 1011 rdst			clrpsw	%0 */
  ID(clrpsw); DF(rdst);

/** 0111 1111 1010 rdst			setpsw	%0 */
  ID(setpsw); DF(rdst);

/** 0111 0101 0111 0000 0000 immm	mvtipl	#%1 */
  ID(mvtipl); SC(immm);

/** 0111 1110 111 crdst			popc	%0 */
  ID(mov); OP(1, RX_Operand_Postinc, 0, 0); DR(crdst + 16);

/** 0111 1110 110 crsrc			pushc	%1 */
  ID(mov); OP(0, RX_Operand_Predec, 0, 0); SR(crsrc + 16);

/** 1111 1101 0111 im11 000crdst	mvtc	#%1, %0 */
  ID(mov); SC(IMMex(im)); DR(crdst + 16);

/** 1111 1101 0110 100c rsrc rdst	mvtc	%1, %0 */
  ID(mov); SR(rsrc); DR(c*16+rdst + 16);

/** 1111 1101 0110 101s rsrc rdst	mvfc	%1, %0 */
  ID(mov); SR((s*16+rsrc) + 16); DR(rdst);

/*----------------------------------------------------------------------*/
/* INTERRUPTS								*/

/** 0111 1111 1001 0100		rtfi */
  ID(rtfi);

/** 0111 1111 1001 0101		rte */
  ID(rte);

/** 0000 0000			brk */
  ID(brk);

/** 0000 0001			dbt */
  ID(dbt);

/** 0111 0101 0110 0000		int #%1 */
  ID(int); SC(IMM(1));

/** 0111 1111 1001 0110		wait */
  ID(wait);

/*----------------------------------------------------------------------*/
/* SCcnd								*/

/** 1111 1100 1101 sz sd rdst cond	sc%1%s	%0 */
  ID(sccnd); BWL(sz); DD (sd, rdst, sz); Scc(cond);

/** */

  return rx->n_bytes;
}
@


1.10
log
@* rx-decode.opc (rx_decode_opcode): Bit operations on
registers are 32-bit operations, not 8-bit operations.
* rx-decode.c: Regenerate.
@
text
@d307 1
a307 1
  if (ss == 3 && sz == 2 && rsrc == 0 && rdst == 0)
@


1.9
log
@Add copyright notices
@
text
@d898 2
d910 2
d922 2
d934 2
@


1.8
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@d2 21
@


1.7
log
@* rx-decode.opc (MOV): Do not sign-extend immediates which are
already the maximum bit size.
* rx-decode.c: Regenerate.
@
text
@d2 1
a5 2

#include "config.h"
@


1.6
log
@* rx-decode.opc (rx_decode_opcode): Set the syntax for multi-byte NOPs.
* rx-decode.c: Regenerate.
@
text
@d265 14
a278 1
  ID(mov); sBWL (sz); DD(sd, rdst, sz); SC(IMMex(im)); F_____;
@


1.5
log
@[include/opcode]

* rx.h (RX_Operand_Type): Add TwoReg.
(RX_Opcode_ID): Remove ediv and ediv2.

[opcodes]

* rx-decode.opc (SRR): New.
(rx_decode_opcode): Use it for movbi and movbir.  Decode NOP2 (mov
r0,r0) and NOP3 (max r0,r0) special cases.
* rx-decode.c: Regenerate.

[sim/rx]

* rx.c (decode_cache_base): New.
(id_names): Remove ediv and edivu.
(optype_names): Add TwoReg.
(maybe_get_mem_page): New.
(rx_get_byte): Call it.
(get_op): Add TwoReg support.
(put_op): Likewise.
(PD, PS, PS2, GD, GS, GS2, DSZ, SSZ, S2SZ, US1, US2, OM): "opcode"
is a pointer now.
(DO_RETURN): New.  We use longjmp to return an exception result.
(decode_opcode): Make opcode a pointer to the decode cache.  Save
decoded opcode information and re-use.  Call DO_RETURN instead of
return throughout.  Remove ediv and edivu.
* mem.c (ptdc): New.  Adds decode cache.
(rx_mem_ptr): Support it.
(rx_mem_decode_cache): New.
* mem.h (enum mem_ptr_action): add MPA_DECODE_CACHE.
(rx_mem_decode_cache): Declare.
* gdb-if.c (sim_resume): Add decode_opcode's setjmp logic here...
* main.c (main): ...and here.  Use a fast loop if neither trace
nor disassemble is given.
* cpu.h (RX_MAKE_STEPPED, RX_MAKE_HIT_BREAK, RX_MAKE_EXITED,
RX_MAKE_STOPPED, RX_EXITED, RX_STOPPED): Adjust so that 0 is not a
valid code for anything.
@
text
@d277 1
d540 1
@


1.4
log
@* rx-decode.opc (store_flags): Remove, replace with F_* macros.
(rx_decode_opcode): Likewise.
* rx-decode.c: Regenerate.
@
text
@d92 1
d274 1
a274 2
  ID(mov); sBWL(sz); F_____;
  if ((ss == 3) && (sd != 3))
d276 1
a276 1
      SD(ss, rdst, sz); DD(sd, rsrc, sz);
d280 9
a288 1
      SD(ss, rsrc, sz); DD(sd, rdst, sz);
d298 1
a298 1
  ID(movbi); sBWL(sz); DR(rdst); SR(isrc); S2R(bsrc); F_____;
d301 1
a301 1
  ID(movbir); sBWL(sz); DR(rdst); SR(isrc); S2R(bsrc); F_____;
d304 1
a304 1
  ID(movbi); uBWL(sz); DR(rdst); SR(isrc); S2R(bsrc); F_____;
d536 8
a543 1
  ID(max); SP(ss, rsrc); DR(rdst);
d699 1
a699 1
  ID(branch); Scc(RXC_always); DC(pc + dsp3map[dsp]);
d702 1
a702 1
  ID(branch); Scc(RXC_always); DC(pc + IMMex(1));
d705 1
a705 1
  ID(branch); Scc(RXC_always); DC(pc + IMMex(2));
d708 1
a708 1
  ID(branch); Scc(RXC_always); DC(pc + IMMex(3));
d711 1
a711 1
  ID(branchrel); Scc(RXC_always); DR(rsrc);
d715 1
a715 1
  ID(branch); Scc(RXC_always); DR(rsrc);
@


1.3
log
@[opcodes]
	* rx-decode.opc (rx_decode_opcode) (mvtipl): Add.
	(mvtcp, mvfcp, opecp): Remove.
	* rx-decode.c: Regenerate.
	* rx-dis.c (cpen): Remove.

[gas]
	* config/rx-parse.y (MVTIPL): Update bit pattern.
	(cpen): Remove.

[include/opcode]
	* rx.h (rx_decode_opcode) (mvtipl): Add.
	(mvtcp, mvfcp, opecp): Remove.
@
text
@d223 14
a236 39
/* The syntax is "OSZC" where each character is one of the following:
   - = flag unchanged
   0 = flag cleared
   1 = flag set
   ? = flag undefined
   x = flag set (any letter will do, use it for hints :).  */

static void
store_flags (RX_Opcode_Decoded * rx, char * str)
{
  int i, mask;
  rx->flags_0 = 0;
  rx->flags_1 = 0;
  rx->flags_s = 0;
  
  for (i = 0; i < 4; i++)
    {
      mask = 8 >> i;
      switch (str[i])
	{
	case 0:
	  abort ();
	case '-':
	  break;
	case '0':
	  rx->flags_0 |= mask;
	  break;
	case '1':
	  rx->flags_1 |= mask;
	  break;
	case '?':
	  break;
	default:
	  rx->flags_0 |= mask;
	  rx->flags_s |= mask;
	  break;
	}
    }
}
d261 1
a261 1
  ID(mov); DR(rdst); SC(IMM (1)); F("----");
d264 1
a264 1
  ID(mov); sBWL (sz); DD(sd, rdst, sz); SC(IMMex(im)); F("----");
d267 1
a267 1
  ID(mov); DR(rdst); SC(immm); F("----");
d270 1
a270 1
  ID(mov); sBWL (sz); DIs(dst, d*16+sppp, sz); SC(IMM(1)); F("----");
d273 1
a273 1
  ID(mov); sBWL(sz); F("----");
d284 1
a284 1
  ID(mov); sBWL(sz); DR(dst); SIs(src, dsp*4+a*2+b, sz); F("----");
d287 1
a287 1
  ID(mov); sBWL(sz); DIs(dst, dsp*4+a*2+b, sz); SR(src); F("----");
d290 1
a290 1
  ID(movbi); sBWL(sz); DR(rdst); SR(isrc); S2R(bsrc); F("----");
d293 1
a293 1
  ID(movbir); sBWL(sz); DR(rdst); SR(isrc); S2R(bsrc); F("----");
d296 1
a296 1
  ID(movbi); uBWL(sz); DR(rdst); SR(isrc); S2R(bsrc); F("----");
d299 1
a299 1
  ID(mov); sBWL (sz); SR(rsrc); F("----");
d303 1
a303 1
  ID(mov); sBWL (sz); DR(rdst); F("----");
d307 1
a307 1
  ID(mov); uBWL(w); DR(dst); SIs(src, dsp*4+a*2+b, w); F("----");
d310 1
a310 1
  ID(mov); uBWL(s); SD(ss, rsrc, s); DR(rdst); F("----");
d313 1
a313 1
  ID(mov); uBWL (sz); DR(rdst); F("----");
d320 1
a320 1
  ID(popm); SR(dsta); S2R(dstb); F("----");
d323 1
a323 1
  ID(pushm); SR(dsta); S2R(dstb); F("----");
d326 1
a326 1
  ID(mov); OP(1, RX_Operand_Postinc, 0, 0); DR(rdst); F("----");
d329 1
a329 1
  ID(mov); BWL(sz); OP(0, RX_Operand_Predec, 0, 0); SR(rsrc); F("----");
d332 1
a332 1
  ID(mov); BWL(sz); OP(0, RX_Operand_Predec, 0, 0); SD(ss, rsrc, sz); F("----");
d365 1
a365 1
  ID(and); SC(immm); DR(rdst); F("-SZ-");
d368 1
a368 1
  ID(and); SC(IMMex(im)); DR(rdst); F("-SZ-");
d371 1
a371 1
  ID(and); SP(ss, rsrc); DR(rdst); F("-SZ-");
d374 1
a374 1
  ID(and); SPm(ss, rsrc, mx); DR(rdst); F("-SZ-");
d377 1
a377 1
  ID(and); DR(rdst); SR(srcb); S2R(srca); F("-SZ-");
d383 1
a383 1
  ID(or); SC(immm); DR(rdst); F("-SZ-");
d386 1
a386 1
  ID(or); SC(IMMex(im)); DR(rdst); F("-SZ-");
d389 1
a389 1
  ID(or); SP(ss, rsrc); DR(rdst); F("-SZ-");
d392 1
a392 1
  ID(or); SPm(ss, rsrc, mx); DR(rdst); F("-SZ-");
d395 1
a395 1
  ID(or); DR(rdst); SR(srcb); S2R(srca); F("-SZ-");
d401 1
a401 1
  ID(xor); SC(IMMex(im)); DR(rdst); F("-SZ-");
d404 1
a404 1
  ID(xor); SP(ss, rsrc); DR(rdst); F("-SZ-");
d407 1
a407 1
  ID(xor); SPm(ss, rsrc, mx); DR(rdst); F("-SZ-");
d413 1
a413 1
  ID(xor); DR(rdst); SR(rdst); S2C(~0); F("-SZ-");
d416 1
a416 1
  ID(xor); DR(rdst); SR(rsrc); S2C(~0); F("-SZ-");
d422 1
a422 1
  ID(and); SC(IMMex(im)); S2R(rdst); F("-SZ-");
d425 1
a425 1
  ID(and); SP(ss, rsrc); S2R(rdst); F("-SZ-");
d428 1
a428 1
  ID(and); SPm(ss, rsrc, mx); S2R(rdst); F("-SZ-");
d434 1
a434 1
  ID(sub); DR(rdst); SC(0); S2R(rdst); F("OSZC");
d437 1
a437 1
  ID(sub); DR(rdst); SC(0); S2R(rsrc); F("OSZC");
d443 1
a443 1
  ID(adc); SC(IMMex(im)); DR(rdst); F("OSZC");
d446 1
a446 1
  ID(adc); SR(rsrc); DR(rdst); F("OSZC");
d449 1
a449 1
  ID(adc); SPm(ss, rsrc, 2); DR(rdst); F("OSZC");
d455 1
a455 1
  ID(add); SC(immm); DR(rdst); F("OSZC");
d458 1
a458 1
  ID(add); SP(ss, rsrc); DR(rdst); F("OSZC");
d461 1
a461 1
  ID(add); SPm(ss, rsrc, mx); DR(rdst); F("OSZC");
d464 1
a464 1
  ID(add); SC(IMMex(im)); S2R(rsrc); DR(rdst); F("OSZC");
d467 1
a467 1
  ID(add); DR(rdst); SR(srcb); S2R(srca); F("OSZC");
d473 1
a473 1
  ID(sub); S2C(immm); SR(rdst); F("OSZC");
d476 1
a476 1
  ID(sub); SR(rsrc); S2C(IMMex(im)); F("OSZC");
d479 1
a479 1
  ID(sub); SR(rsrc); S2C(IMM(1)); F("OSZC");
d482 1
a482 1
  ID(sub); S2P(ss, rsrc); SR(rdst); F("OSZC");
d485 1
a485 1
  ID(sub); S2Pm(ss, rsrc, mx); SR(rdst); F("OSZC");
d491 1
a491 1
  ID(sub); S2C(immm); SR(rdst); DR(rdst); F("OSZC");
d494 1
a494 1
  ID(sub); S2P(ss, rsrc); SR(rdst); DR(rdst); F("OSZC");
d497 1
a497 1
  ID(sub); S2Pm(ss, rsrc, mx); SR(rdst); DR(rdst); F("OSZC");
d500 1
a500 1
  ID(sub); DR(rdst); SR(srcb); S2R(srca); F("OSZC");
d506 1
a506 1
  ID(sbb); SR (rsrc); DR(rdst); F("OSZC");
d510 1
a510 1
  ID(sbb); SPm(sp, rsrc, mx); DR(rdst); F("OSZC");
d516 1
a516 1
  ID(abs); DR(rdst); SR(rdst); F("OSZ-");
d519 1
a519 1
  ID(abs); DR(rdst); SR(rsrc); F("OSZ-");
d549 1
a549 1
  ID(mul); DR(rdst); SC(immm); F("----");
d552 1
a552 1
  ID(mul); DR(rdst); SC(IMMex(im)); F("----");
d555 1
a555 1
  ID(mul); SP(ss, rsrc); DR(rdst); F("----");
d558 1
a558 1
  ID(mul); SPm(ss, rsrc, mx); DR(rdst); F("----");
d561 1
a561 1
  ID(mul); DR(rdst); SR(srcb); S2R(srca); F("----");
d591 1
a591 1
  ID(div); DR(rdst); SC(IMMex(im)); F("O---");
d594 1
a594 1
  ID(div); SP(ss, rsrc); DR(rdst); F("O---");
d597 1
a597 1
  ID(div); SPm(ss, rsrc, mx); DR(rdst); F("O---");
d603 1
a603 1
  ID(divu); DR(rdst); SC(IMMex(im)); F("O---");
d606 1
a606 1
  ID(divu); SP(ss, rsrc); DR(rdst); F("O---");
d609 1
a609 1
  ID(divu); SPm(ss, rsrc, mx); DR(rdst); F("O---");
d615 1
a615 1
  ID(shll); S2C(i*16+mmmm); SR(rdst); DR(rdst); F("OSZC");
d618 1
a618 1
  ID(shll); S2R(rsrc); SR(rdst); DR(rdst); F("OSZC");
d621 1
a621 1
  ID(shll); S2C(immmm); SR(rsrc); DR(rdst); F("OSZC");
d625 1
a625 1
  ID(shar); S2C(i*16+mmmm); SR(rdst); DR(rdst); F("0SZC");
d628 1
a628 1
  ID(shar); S2R(rsrc); SR(rdst); DR(rdst); F("0SZC");
d631 1
a631 1
  ID(shar); S2C(immmm); SR(rsrc); DR(rdst); F("0SZC");
d635 1
a635 1
  ID(shlr); S2C(i*16+mmmm); SR(rdst); DR(rdst); F("-SZC");
d638 1
a638 1
  ID(shlr); S2R(rsrc); SR(rdst); DR(rdst); F("-SZC");
d641 1
a641 1
  ID(shlr); S2C(immmm); SR(rsrc); DR(rdst); F("-SZC");
d647 1
a647 1
  ID(rolc); DR(rdst); F("-SZC");
d650 1
a650 1
  ID(rorc); DR(rdst); F("-SZC");
d653 1
a653 1
  ID(rotl); SC(i*16+mmmm); DR(rdst); F("-SZC");
d656 1
a656 1
  ID(rotl); SR(rsrc); DR(rdst); F("-SZC");
d659 1
a659 1
  ID(rotr); SC(i*16+mmmm); DR(rdst); F("-SZC");
d662 1
a662 1
  ID(rotr); SR(rsrc); DR(rdst); F("-SZC");
d727 1
a727 1
  ID(scmpu); F("--ZC");
d736 1
a736 1
  ID(suntil); BWL(sz); F("--ZC");
d739 1
a739 1
  ID(swhile); BWL(sz); F("--ZC");
d751 1
a751 1
  ID(rmpa); BWL(sz); F("OS--");
d757 1
a757 1
  ID(mulhi); SR(srca); S2R(srcb); F("----");
d760 1
a760 1
  ID(mullo); SR(srca); S2R(srcb); F("----");
d763 1
a763 1
  ID(machi); SR(srca); S2R(srcb); F("----");
d766 1
a766 1
  ID(maclo); SR(srca); S2R(srcb); F("----");
d769 1
a769 1
  ID(mvtachi); SR(rsrc); F("----");
d772 1
a772 1
  ID(mvtaclo); SR(rsrc); F("----");
d775 1
a775 1
  ID(mvfachi); DR(rdst); F("----");
d778 1
a778 1
  ID(mvfacmi); DR(rdst); F("----");
d781 1
a781 1
  ID(mvfaclo); DR(rdst); F("----");
d784 1
a784 1
  ID(racw); SC(i+1); F("----");
d799 1
a799 1
  ID(fadd); DR(rdst); SC(IMM(0)); F("-SZ-");
d802 1
a802 1
  ID(fadd); DR(rdst); SD(sd, rsrc, LSIZE); F("-SZ-");
d805 1
a805 1
  ID(fcmp); DR(rdst); SC(IMM(0)); F("OSZ-");
d808 1
a808 1
  ID(fcmp); DR(rdst); SD(sd, rsrc, LSIZE); F("OSZ-");
d811 1
a811 1
  ID(fsub); DR(rdst); SC(IMM(0)); F("-SZ-");
d814 1
a814 1
  ID(fsub); DR(rdst); SD(sd, rsrc, LSIZE); F("-SZ-");
d817 1
a817 1
  ID(ftoi); DR(rdst); SD(sd, rsrc, LSIZE); F("-SZ-");
d820 1
a820 1
  ID(fmul); DR(rdst); SC(IMM(0)); F("-SZ-");
d823 1
a823 1
  ID(fmul); DR(rdst); SD(sd, rsrc, LSIZE); F("-SZ-");
d826 1
a826 1
  ID(fdiv); DR(rdst); SC(IMM(0)); F("-SZ-");
d829 1
a829 1
  ID(fdiv); DR(rdst); SD(sd, rsrc, LSIZE); F("-SZ-");
d832 1
a832 1
  ID(round); DR(rdst); SD(sd, rsrc, LSIZE); F("-SZ-");
d835 1
a835 1
  ID(itof); DR (rdst); SP(sd, rsrc); F("-SZ-");
d838 1
a838 1
  ID(itof); DR (rdst); SPm(sd, rsrc, mx); F("-SZ-");
d844 1
a844 1
  ID(bset); BWL(BSIZE); SC(bit); DD(sd, rdst, BSIZE); F("----");
d847 1
a847 1
  ID(bset); BWL(BSIZE); SR(rsrc); DD(sd, rdst, BSIZE); F("----");
d850 1
a850 1
  ID(bset); BWL(LSIZE); SC(b*16+ittt); DR(rdst); F("----");
d854 1
a854 1
  ID(bclr); BWL(BSIZE); SC(bit); DD(sd, rdst, BSIZE); F("----");
d857 1
a857 1
  ID(bclr); BWL(BSIZE); SR(rsrc); DD(sd, rdst, BSIZE); F("----");
d860 1
a860 1
  ID(bclr); BWL(LSIZE); SC(b*16+ittt); DR(rdst); F("----");
d864 1
a864 1
  ID(btst); BWL(BSIZE); S2C(bit); SD(sd, rdst, BSIZE); F("--ZC");
d867 1
a867 1
  ID(btst); BWL(BSIZE); S2R(rsrc); SD(sd, rdst, BSIZE); F("--ZC");
d870 1
a870 1
  ID(btst); BWL(LSIZE); S2C(b*16+ittt); SR(rdst); F("--ZC");
@


1.2
log
@* rx-decode.opc (decode_opcode): Fix flags for MUL, SUNTIL, and SWHILE.
* rx-decode.c: Regenerated.
@
text
@d923 3
a940 9
/*?* 1111 1101 1111 1010 01cp rsrc	mvtcp	#%2, %1, #%0 */
  ID(mvtcp); S2C(cp); SR(rsrc); DC (IMM (WSIZE));

/*?* 1111 1101 1111 1011 01cp rdst	mvfcp	#%2, %0, #%1 */
  ID(mvfcp); S2C(cp); DR(rdst); SC (IMM (WSIZE));

/*?* 1111 1101 1111 1001 01cp 0000	opecp	#%2, #%1 */
  ID(opecp); S2C(cp); SC (IMM (WSIZE));

@


1.1
log
@bfd
        * Makefile.am (ALL_MACHINES): Add cpu-rx.lo.
        (ALL_MACHINES_CFILES): Add cpu-rx.c.
        (BFD32_BACKENDS): Add elf32-rx.lo.
        (BFD32_BACKENDS_CFILES): Add elf32-rx.c.
        * archures.c (bfd_architecture): Add bfd_arch_rx and bfd_mach_rx.
        Export bfd_rx_arch.
        (bfd_archures_list): Add bfd_rx_arch.
        * config.bfd: Add entry for rx-*-elf.
        * configure.in: Add entries for bfd_elf32_rx_le_vec and
        bfd_elf32_rx_be_vec.
        * reloc.c: Add RX relocations.
        * targets.c: Add RX target vectors.
        * Makefile.in: Regenerate.
        * bfd-in2.h: Regenerate.
        * configure: Regenerate.
        * libbfd.h: Regenerate.
        * cpu-rx.c: New file.
        * elf32-rx.c: New file.

binutils
        * readelf.c: Add support for RX target.
        * MAINTAINERS: Add DJ and NickC as maintainers for RX.

gas
        * Makefile.am: Add RX target.
        * configure.in: Likewise.
        * configure.tgt: Likewise.
        * read.c (do_repeat_with_expander): New function.
        * read.h: Provide a prototype for do_repeat_with_expander.
        * doc/Makefile.am: Add RX target documentation.
        * doc/all.texi: Likewise.
        * doc/as.texinfo: Likewise.
        * Makefile.in: Regenerate.
        * NEWS: Mention support for RX architecture.
        * configure: Regenerate.
        * doc/Makefile.in: Regenerate.
        * config/rx-defs.h: New file.
        * config/rx-parse.y: New file.
        * config/tc-rx.h: New file.
        * config/tc-rx.c: New file.
        * doc/c-rx.texi: New file.

gas/testsuite
        * gas/rx: New directory.
        * gas/rx/*: New set of test cases.
        * gas/elf/section2.e-rx: New expected output file.
        * gas/all/gas.exp: Add support for RX target.
        * gas/elf/elf.exp: Likewise.
        * gas/lns/lns.exp: Likewise.
        * gas/macros/macros.exp: Likewise.

include
        * dis-asm.h: Add prototype for print_insn_rx.

include/elf
        * rx.h: New file.

include/opcode
        * rx.h: New file.

ld
        * Makefile.am: Add rules to build RX emulation.
        * configure.tgt: Likewise.
        * NEWS: Mention support for RX architecture.
        * Makefile.in: Regenerate.
        * emulparams/elf32rx.sh: New file.
        * emultempl/rxelf.em: New file.

opcodes
        * Makefile.am: Add RX files.
        * configure.in: Add support for RX target.
        * disassemble.c: Likewise.
        * Makefile.in: Regenerate.
        * configure: Regenerate.
        * opc2c.c: New file.
        * rx-decode.c: New file.
        * rx-decode.opc: New file.
        * rx-dis.c: New file.
@
text
@d574 1
a574 1
  ID(mul); DR(rdst); SC(immm); F("O---");
d577 1
a577 1
  ID(mul); DR(rdst); SC(IMMex(im)); F("O---");
d580 1
a580 1
  ID(mul); SP(ss, rsrc); DR(rdst); F("O---");
d583 1
a583 1
  ID(mul); SPm(ss, rsrc, mx); DR(rdst); F("O---");
d586 1
a586 1
  ID(mul); DR(rdst); SR(srcb); S2R(srca); F("O---");
d761 1
a761 1
  ID(suntil); BWL(sz); F("OSZC");
d764 1
a764 1
  ID(swhile); BWL(sz); F("OSZC");
@

