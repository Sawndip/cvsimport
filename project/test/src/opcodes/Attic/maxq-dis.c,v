head	1.9;
access;
symbols
	binutils-2_20_1:1.6
	sid-snapshot-20100601:1.7
	sid-snapshot-20100501:1.7
	sid-snapshot-20100401:1.7
	gdb_7_1-2010-03-18-release:1.7
	sid-snapshot-20100301:1.7
	gdb_7_1-branch:1.7.0.2
	gdb_7_1-2010-02-18-branchpoint:1.7
	sid-snapshot-20100201:1.7
	sid-snapshot-20100101:1.7
	gdb_7_0_1-2009-12-22-release:1.6
	sid-snapshot-20091201:1.6
	sid-snapshot-20091101:1.6
	binutils-2_20:1.6
	gdb_7_0-2009-10-06-release:1.6
	sid-snapshot-20091001:1.6
	gdb_7_0-branch:1.6.0.34
	gdb_7_0-2009-09-16-branchpoint:1.6
	arc-sim-20090309:1.6
	binutils-arc-20081103-branch:1.6.0.32
	binutils-arc-20081103-branchpoint:1.6
	binutils-2_20-branch:1.6.0.30
	binutils-2_20-branchpoint:1.6
	sid-snapshot-20090901:1.6
	sid-snapshot-20090801:1.6
	msnyder-checkpoint-072509-branch:1.6.0.28
	msnyder-checkpoint-072509-branchpoint:1.6
	sid-snapshot-20090701:1.6
	dje-cgen-play1-branch:1.6.0.26
	dje-cgen-play1-branchpoint:1.6
	sid-snapshot-20090601:1.6
	sid-snapshot-20090501:1.6
	sid-snapshot-20090401:1.6
	arc-20081103-branch:1.6.0.24
	arc-20081103-branchpoint:1.6
	arc-insight_6_8-branch:1.6.0.22
	arc-insight_6_8-branchpoint:1.6
	insight_6_8-branch:1.6.0.20
	insight_6_8-branchpoint:1.6
	sid-snapshot-20090301:1.6
	binutils-2_19_1:1.6
	sid-snapshot-20090201:1.6
	sid-snapshot-20090101:1.6
	reverse-20081226-branch:1.6.0.18
	reverse-20081226-branchpoint:1.6
	sid-snapshot-20081201:1.6
	multiprocess-20081120-branch:1.6.0.16
	multiprocess-20081120-branchpoint:1.6
	sid-snapshot-20081101:1.6
	binutils-2_19:1.6
	sid-snapshot-20081001:1.6
	reverse-20080930-branch:1.6.0.14
	reverse-20080930-branchpoint:1.6
	binutils-2_19-branch:1.6.0.12
	binutils-2_19-branchpoint:1.6
	sid-snapshot-20080901:1.6
	sid-snapshot-20080801:1.6
	reverse-20080717-branch:1.6.0.10
	reverse-20080717-branchpoint:1.6
	sid-snapshot-20080701:1.6
	msnyder-reverse-20080609-branch:1.6.0.8
	msnyder-reverse-20080609-branchpoint:1.6
	drow-reverse-20070409-branch:1.4.0.34
	drow-reverse-20070409-branchpoint:1.4
	sid-snapshot-20080601:1.6
	sid-snapshot-20080501:1.6
	sid-snapshot-20080403:1.6
	sid-snapshot-20080401:1.6
	gdb_6_8-2008-03-27-release:1.6
	sid-snapshot-20080301:1.6
	gdb_6_8-branch:1.6.0.6
	gdb_6_8-2008-02-26-branchpoint:1.6
	sid-snapshot-20080201:1.6
	sid-snapshot-20080101:1.6
	sid-snapshot-20071201:1.6
	sid-snapshot-20071101:1.6
	gdb_6_7_1-2007-10-29-release:1.6
	gdb_6_7-2007-10-10-release:1.6
	sid-snapshot-20071001:1.6
	gdb_6_7-branch:1.6.0.4
	gdb_6_7-2007-09-07-branchpoint:1.6
	binutils-2_18:1.6
	binutils-2_18-branch:1.6.0.2
	binutils-2_18-branchpoint:1.6
	insight_6_6-20070208-release:1.4
	binutils-csl-coldfire-4_1-32:1.4
	binutils-csl-sourcerygxx-4_1-32:1.4
	gdb_6_6-2006-12-18-release:1.4
	binutils-csl-innovasic-fido-3_4_4-33:1.4
	binutils-csl-sourcerygxx-3_4_4-32:1.3
	binutils-csl-coldfire-4_1-30:1.4
	binutils-csl-sourcerygxx-4_1-30:1.4
	binutils-csl-coldfire-4_1-28:1.4
	binutils-csl-sourcerygxx-4_1-29:1.4
	binutils-csl-sourcerygxx-4_1-28:1.4
	gdb_6_6-branch:1.4.0.32
	gdb_6_6-2006-11-15-branchpoint:1.4
	binutils-csl-arm-2006q3-27:1.4
	binutils-csl-sourcerygxx-4_1-27:1.4
	binutils-csl-arm-2006q3-26:1.4
	binutils-csl-sourcerygxx-4_1-26:1.4
	binutils-csl-sourcerygxx-4_1-25:1.4
	binutils-csl-sourcerygxx-4_1-24:1.4
	binutils-csl-sourcerygxx-4_1-23:1.4
	insight_6_5-20061003-release:1.4
	gdb-csl-symbian-6_4_50_20060226-12:1.4
	binutils-csl-sourcerygxx-4_1-21:1.4
	binutils-csl-arm-2006q3-21:1.4
	binutils-csl-sourcerygxx-4_1-22:1.4
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.4
	binutils-csl-sourcerygxx-4_1-20:1.4
	binutils-csl-arm-2006q3-19:1.4
	binutils-csl-sourcerygxx-4_1-19:1.4
	binutils-csl-sourcerygxx-4_1-18:1.4
	binutils-csl-renesas-4_1-9:1.4
	gdb-csl-sourcerygxx-3_4_4-25:1.4
	binutils-csl-sourcerygxx-3_4_4-25:1.3
	nickrob-async-20060828-mergepoint:1.4
	gdb-csl-symbian-6_4_50_20060226-11:1.4
	binutils-csl-renesas-4_1-8:1.4
	binutils-csl-renesas-4_1-7:1.4
	binutils-csl-renesas-4_1-6:1.4
	gdb-csl-sourcerygxx-4_1-17:1.4
	binutils-csl-sourcerygxx-4_1-17:1.4
	gdb-csl-20060226-branch-local-2:1.4
	gdb-csl-sourcerygxx-4_1-14:1.4
	binutils-csl-sourcerygxx-4_1-14:1.4
	binutils-csl-sourcerygxx-4_1-15:1.4
	gdb-csl-sourcerygxx-4_1-13:1.4
	binutils-csl-sourcerygxx-4_1-13:1.4
	binutils-2_17:1.4
	gdb-csl-sourcerygxx-4_1-12:1.4
	binutils-csl-sourcerygxx-4_1-12:1.4
	gdb-csl-sourcerygxx-3_4_4-21:1.4
	binutils-csl-sourcerygxx-3_4_4-21:1.4
	gdb_6_5-20060621-release:1.4
	binutils-csl-wrs-linux-3_4_4-24:1.3
	binutils-csl-wrs-linux-3_4_4-23:1.3
	gdb-csl-sourcerygxx-4_1-9:1.4
	binutils-csl-sourcerygxx-4_1-9:1.4
	gdb-csl-sourcerygxx-4_1-8:1.4
	binutils-csl-sourcerygxx-4_1-8:1.4
	gdb-csl-sourcerygxx-4_1-7:1.4
	binutils-csl-sourcerygxx-4_1-7:1.4
	gdb-csl-arm-2006q1-6:1.4
	binutils-csl-arm-2006q1-6:1.4
	gdb-csl-sourcerygxx-4_1-6:1.4
	binutils-csl-sourcerygxx-4_1-6:1.4
	binutils-csl-wrs-linux-3_4_4-22:1.3
	gdb-csl-symbian-6_4_50_20060226-10:1.4
	gdb-csl-symbian-6_4_50_20060226-9:1.4
	gdb-csl-symbian-6_4_50_20060226-8:1.4
	gdb-csl-coldfire-4_1-11:1.4
	binutils-csl-coldfire-4_1-11:1.4
	gdb-csl-sourcerygxx-3_4_4-19:1.4
	binutils-csl-sourcerygxx-3_4_4-19:1.4
	gdb-csl-coldfire-4_1-10:1.4
	gdb_6_5-branch:1.4.0.30
	gdb_6_5-2006-05-14-branchpoint:1.4
	binutils-csl-coldfire-4_1-10:1.4
	gdb-csl-sourcerygxx-4_1-5:1.4
	binutils-csl-sourcerygxx-4_1-5:1.4
	nickrob-async-20060513-branch:1.4.0.28
	nickrob-async-20060513-branchpoint:1.4
	gdb-csl-sourcerygxx-4_1-4:1.4
	binutils-csl-sourcerygxx-4_1-4:1.4
	msnyder-reverse-20060502-branch:1.4.0.26
	msnyder-reverse-20060502-branchpoint:1.4
	binutils-csl-wrs-linux-3_4_4-21:1.3
	gdb-csl-morpho-4_1-4:1.4
	binutils-csl-morpho-4_1-4:1.4
	gdb-csl-sourcerygxx-3_4_4-17:1.4
	binutils-csl-sourcerygxx-3_4_4-17:1.4
	binutils-csl-wrs-linux-3_4_4-20:1.3
	readline_5_1-import-branch:1.4.0.24
	readline_5_1-import-branchpoint:1.4
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.4
	binutils-2_17-branch:1.4.0.22
	binutils-2_17-branchpoint:1.4
	gdb-csl-symbian-20060226-branch:1.4.0.20
	gdb-csl-symbian-20060226-branchpoint:1.4
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.4
	msnyder-reverse-20060331-branch:1.4.0.18
	msnyder-reverse-20060331-branchpoint:1.4
	binutils-csl-2_17-branch:1.4.0.16
	binutils-csl-2_17-branchpoint:1.4
	gdb-csl-available-20060303-branch:1.4.0.14
	gdb-csl-available-20060303-branchpoint:1.4
	gdb-csl-20060226-branch:1.4.0.12
	gdb-csl-20060226-branchpoint:1.4
	gdb_6_4-20051202-release:1.4
	msnyder-fork-checkpoint-branch:1.4.0.10
	msnyder-fork-checkpoint-branchpoint:1.4
	gdb-csl-gxxpro-6_3-branch:1.4.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.4
	gdb_6_4-branch:1.4.0.6
	gdb_6_4-2005-11-01-branchpoint:1.4
	gdb-csl-arm-20051020-branch:1.4.0.4
	gdb-csl-arm-20051020-branchpoint:1.4
	binutils-csl-gxxpro-3_4-branch:1.3.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.3
	binutils-2_16_1:1.3
	msnyder-tracepoint-checkpoint-branch:1.4.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.4
	gdb-csl-arm-20050325-2005-q1b:1.3
	binutils-csl-arm-2005q1b:1.3
	binutils-2_16:1.3
	gdb-csl-arm-20050325-2005-q1a:1.3
	binutils-csl-arm-2005q1a:1.3
	csl-arm-20050325-branch:1.3.0.6
	csl-arm-20050325-branchpoint:1.3
	binutils-csl-arm-2005q1-branch:1.3.0.4
	binutils-csl-arm-2005q1-branchpoint:1.3
	binutils-2_16-branch:1.3.0.2
	binutils-2_16-branchpoint:1.3
	binutils_latest_snapshot:1.8;
locks; strict;
comment	@ * @;


1.9
date	2010.06.29.04.17.33;	author amodra;	state dead;
branches;
next	1.8;

1.8
date	2010.06.27.04.07.55;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2009.12.11.13.42.17;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2007.07.19.16.23.47;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2007.07.05.09.49.02;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.07.07.34.30;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.22.13.01.53;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.19.12.34.13;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	2004.11.08.13.17.37;	author nickc;	state Exp;
branches;
next	;


desc
@@


1.9
log
@remove maxq-coff port
@
text
@/* Instruction printing code for the MAXQ

   Copyright 2004, 2005, 2007, 2009, 2010 Free Software Foundation, Inc.

   Written by Vineet Sharma(vineets@@noida.hcltech.com) Inderpreet
   S.(inderpreetb@@noida.hcltech.com)

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License along
   with this program; if not, write to the Free Software Foundation, Inc., 
   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */

#include "sysdep.h"
#include "dis-asm.h"
#include "opcode/maxq.h"

struct _group_info
{
  unsigned char group_no;
  unsigned char sub_opcode;
  unsigned char src;
  unsigned char dst;
  unsigned char fbit;
  unsigned char bit_no;
  unsigned char flag;

};

typedef struct _group_info group_info;

#define SRC	0x01
#define DST	0x02
#define FORMAT	0x04
#define BIT_NO	0x08
#define SUB_OP	0x10

#define MASK_LOW_BYTE 0x0f
#define MASK_HIGH_BYTE 0xf0

/* Flags for retrieving the bits from the op-code.  */
#define _DECODE_LOWNIB_LOWBYTE  0x000f
#define _DECODE_HIGHNIB_LOWBYTE 0x00f0
#define _DECODE_LOWNIB_HIGHBYTE 0x0f00
#define _DECODE_HIGHNIB_HIGHBYTE 0xf000
#define _DECODE_HIGHBYTE 0xff00
#define _DECODE_LOWBYTE  0x00ff
#define _DECODE_4TO6_HIGHBYTE 0x7000
#define _DECODE_4TO6_LOWBYTE 0x0070
#define _DECODE_0TO6_HIGHBYTE 0x7f00
#define _DECODE_0TO2_HIGHBYTE 0x0700
#define _DECODE_GET_F_HIGHBYTE 0x8000
#define _DECODE_BIT7_HIGHBYTE 0x8000
#define _DECODE_BIT7_LOWBYTE 0x0080
#define _DECODE_GET_CARRY 0x10000
#define _DECODE_BIT0_LOWBYTE 0x1
#define _DECODE_BIT6AND7_HIGHBYTE 0xc000

/* Module and Register Indexed of System Registers.  */
#define _CURR_ACC_MODINDEX 0xa
#define _CURR_ACC_REGINDEX 0x0
#define _PSF_REG_MODINDEX  0x8
#define _PSF_REG_REGINDEX  0x4
#define _PFX_REG_MODINDEX  0xb
#define _PFX0_REG_REGINDEX 0x0
#define _PFX2_REG_REGINDEX 0x2
#define _DP_REG_MODINDEX   0xf
#define _DP0_REG_REGINDEX  0x3
#define _DP1_REG_REGINDEX  0x7
#define _IP_REG_MODINDEX   0xc
#define _IP_REG_REGINDEX   0x0
#define _IIR_REG_MODINDEX  0x8
#define _IIR_REG_REGINDEX  0xb
#define _SP_REG_MODINDEX   0xd
#define _SP_REG_REGINDEX   0x1
#define _IC_REG_MODINDEX   0x8
#define _IC_REG_REGINDEX   0x5
#define _LC_REG_MODINDEX   0xe
#define _LC0_REG_REGINDEX  0x0
#define _LC1_REG_REGINDEX  0x1
#define _LC2_REG_REGINDEX  0x2
#define _LC3_REG_REGINDEX  0x3

/* Flags for finding the bits in PSF Register.  */
#define SIM_ALU_DECODE_CARRY_BIT_POS  0x2
#define SIM_ALU_DECODE_SIGN_BIT_POS   0x40
#define SIM_ALU_DECODE_ZERO_BIT_POS   0x80
#define SIM_ALU_DECODE_EQUAL_BIT_POS  0x1
#define SIM_ALU_DECODE_IGE_BIT_POS    0x1

/* Number Of Op-code Groups.  */
unsigned char const SIM_ALU_DECODE_OPCODE_GROUPS = 11;

/* Op-code Groups.  */
unsigned char const SIM_ALU_DECODE_LOGICAL_XCHG_OP_GROUP = 1;

/* Group1: AND/OR/XOR/ADD/SUB Operations: fxxx 1010 ssss ssss.  */
unsigned char const SIM_ALU_DECODE_AND_OR_ADD_SUB_OP_GROUP = 2;

/* Group2: Logical Operations: 1000 1010 xxxx 1010.  */
unsigned char const SIM_ALU_DECODE_BIT_OP_GROUP = 3;

/* XCHG/Bit Operations: 1xxx 1010 xxxx 1010.  */
unsigned char const SIM_ALU_DECODE_SET_DEST_BIT_GROUP = 4;

/* Move value in bit of destination register: 1ddd dddd xbbb 0111.  */
unsigned char const SIM_ALU_DECODE_JUMP_OP_GROUP = 5;

#define JUMP_CHECK(insn)   \
   (   ((insn & _DECODE_4TO6_HIGHBYTE) == 0x0000) \
    || ((insn & _DECODE_4TO6_HIGHBYTE) == 0x2000) \
    || ((insn & _DECODE_4TO6_HIGHBYTE) == 0x6000) \
    || ((insn & _DECODE_4TO6_HIGHBYTE) == 0x1000) \
    || ((insn & _DECODE_4TO6_HIGHBYTE) == 0x5000) \
    || ((insn & _DECODE_4TO6_HIGHBYTE) == 0x3000) \
    || ((insn & _DECODE_4TO6_HIGHBYTE) == 0x7000) \
    || ((insn & _DECODE_4TO6_HIGHBYTE) == 0x4000) )

/* JUMP operations: fxxx 1100 ssss ssss */
unsigned char const SIM_ALU_DECODE_RET_OP_GROUP = 6;

/* RET Operations: 1xxx 1100 0000 1101 */
unsigned char const SIM_ALU_DECODE_MOVE_SRC_DST_GROUP = 7;

/* Move src into dest register: fddd dddd ssss ssss */
unsigned char const SIM_ALU_DECODE_SET_SRC_BIT_GROUP = 8;

/* Move value in bit of source register: fbbb 0111 ssss ssss */
unsigned char const SIM_ALU_DECODE_DJNZ_CALL_PUSH_OP_GROUP = 9;

/* PUSH, DJNZ and CALL operations: fxxx 1101 ssss ssss */
unsigned char const SIM_ALU_DECODE_POP_OP_GROUP = 10;

/* POP operation: 1ddd dddd 0000 1101 */
unsigned char const SIM_ALU_DECODE_CMP_SRC_OP_GROUP = 11;

/* GLOBAL */
char unres_reg_name[20];

static char *
get_reg_name (unsigned char reg_code, type1 arg_pos)
{
  unsigned char module;
  unsigned char r_index;
  int ix = 0;
  reg_entry const *reg_x;
  mem_access_syntax const *syntax;
  mem_access *mem_acc;

  module = 0;
  r_index = 0;
  module = (reg_code & MASK_LOW_BYTE);
  r_index = (reg_code & MASK_HIGH_BYTE);
  r_index = r_index >> 4;

  /* Search the system register table.  */
  for (reg_x = &system_reg_table[0]; reg_x->reg_name != NULL; ++reg_x)
    if ((reg_x->Mod_name == module) && (reg_x->Mod_index == r_index))
      return reg_x->reg_name;

  /* Serch pheripheral table.  */
  for (ix = 0; ix < num_of_reg; ix++)
    {
      reg_x = &new_reg_table[ix];

      if ((reg_x->Mod_name == module) && (reg_x->Mod_index == r_index))
	return reg_x->reg_name;
    }

  for (mem_acc = &mem_table[0]; mem_acc->name != NULL || !mem_acc; ++mem_acc)
    {
      if (reg_code == mem_acc->opcode)
	{
	  for (syntax = mem_access_syntax_table;
	       syntax != NULL && syntax->name;
	       ++syntax)
	    if (!strcmp (mem_acc->name, syntax->name))
	      {
		if ((arg_pos == syntax->type) || (syntax->type == BOTH))
		  return mem_acc->name;

		break;
	      }
	}
    }

  memset (unres_reg_name, 0, 20);
  sprintf (unres_reg_name, "%01x%01xh", r_index, module);

  return unres_reg_name;
}

static bfd_boolean
check_move (unsigned char insn0, unsigned char insn8)
{
  bfd_boolean first = FALSE;
  bfd_boolean second = FALSE;
  reg_entry const *reg_x;
  const unsigned char module1 = insn0 & MASK_LOW_BYTE;
  const unsigned char index1 = ((insn0 & 0x70) >> 4);
  const unsigned char module2 = insn8 & MASK_LOW_BYTE;
  const unsigned char index2 = ((insn8 & MASK_HIGH_BYTE) >> 4);

  /* DST */
  if (((insn0 & MASK_LOW_BYTE) == MASK_LOW_BYTE)
      && ((index1 == 0) || (index1 == 1) || (index1 == 2) || (index1 == 5)
	  || (index1 == 4) || (index1 == 6)))
    first = TRUE;

  else if (((insn0 & MASK_LOW_BYTE) == 0x0D) && (index1 == 0))
    first = TRUE;

  else if ((module1 == 0x0E)
	   && ((index1 == 0) || (index1 == 1) || (index1 == 2)))
    first = TRUE;

  else
    {
      for (reg_x = &system_reg_table[0]; reg_x->reg_name != NULL && reg_x;
	   ++reg_x)
	{
	  if ((reg_x->Mod_name == module1) && (reg_x->Mod_index == index1)
	      && ((reg_x->rtype == Reg_16W) || (reg_x->rtype == Reg_8W)))
	    {
	      /* IP not allowed.  */
	      if ((reg_x->Mod_name == 0x0C) && (reg_x->Mod_index == 0x00))
		continue;

	      /* A[AP] not allowed.  */
	      if ((reg_x->Mod_name == 0x0A) && (reg_x->Mod_index == 0x01))
		continue;
	      first = TRUE;
	      break;
	    }
	}
    }

  if (!first)
    /* No need to check further.  */
    return FALSE;

  if (insn0 & 0x80)
    {
      /* SRC */
      if (((insn8 & MASK_LOW_BYTE) == MASK_LOW_BYTE)
	  && ((index2 == 0) || (index2 == 1) || (index2 == 2) || (index2 == 4)
	      || (index2 == 5) || (index2 == 6)))
	second = TRUE;

      else if (((insn8 & MASK_LOW_BYTE) == 0x0D) && (index2 == 0))
	second = TRUE;

      else if ((module2 == 0x0E)
	       && ((index2 == 0) || (index2 == 1) || (index2 == 2)))
	second = TRUE;

      else
	{
	  for (reg_x = &system_reg_table[0];
	       reg_x->reg_name != NULL && reg_x;
	       ++reg_x)
	    {
	      if ((reg_x->Mod_name == (insn8 & MASK_LOW_BYTE))
		  && (reg_x->Mod_index == (((insn8 & 0xf0) >> 4))))
		{
		  second = TRUE;
		  break;
		}
	    }
	}	

      if (second)
	{
	  if ((module1 == 0x0A && index1 == 0x0)
	      && (module2 == 0x0A && index2 == 0x01))
	    return FALSE;

	  return TRUE;
	}

      return FALSE;
    }

  return first;
}

static void
maxq_print_arg (MAX_ARG_TYPE              arg,
		struct disassemble_info * info,
		group_info                grp)
{
  switch (arg)
    {
    case FLAG_C:
      info->fprintf_func (info->stream, "C");
      break;
    case FLAG_NC:
      info->fprintf_func (info->stream, "NC");
      break;

    case FLAG_Z:
      info->fprintf_func (info->stream, "Z");
      break;

    case FLAG_NZ:
      info->fprintf_func (info->stream, "NZ");
      break;

    case FLAG_S:
      info->fprintf_func (info->stream, "S");
      break;

    case FLAG_E:
      info->fprintf_func (info->stream, "E");
      break;

    case FLAG_NE:
      info->fprintf_func (info->stream, "NE");
      break;

    case ACC_BIT:
      info->fprintf_func (info->stream, "Acc");
      if ((grp.flag & BIT_NO) == BIT_NO)
	info->fprintf_func (info->stream, ".%d", grp.bit_no);
      break;

    case A_BIT_0:
      info->fprintf_func (info->stream, "#0");
      break;
    case A_BIT_1:
      info->fprintf_func (info->stream, "#1");
      break;

    default:
      break;
    }
}

static unsigned char
get_group (const unsigned int insn)
{
  if (check_move ((insn >> 8), (insn & _DECODE_LOWBYTE)))
    return 8;

  if ((insn & _DECODE_LOWNIB_HIGHBYTE) == 0x0A00)
    {
      /* && condition with sec part added on 26 May for resolving 2 & 3 grp
	 conflict.  */
      if (((insn & _DECODE_LOWNIB_LOWBYTE) == 0x000A)
	  && ((insn & _DECODE_GET_F_HIGHBYTE) == 0x8000))
	{
	  if ((insn & _DECODE_HIGHNIB_HIGHBYTE) == 0x8000)
	    return 2;
	  else
	    return 3;
	}

      return 1;
    }
  else if ((insn & _DECODE_LOWNIB_HIGHBYTE) == 0x0C00)
    {
      if (((insn & _DECODE_LOWBYTE) == 0x000D) && JUMP_CHECK (insn)
	  && ((insn & _DECODE_GET_F_HIGHBYTE) == 0x8000))
	return 6;
      else if ((insn & _DECODE_LOWBYTE) == 0x008D)
	return 7;

      return 5;
    }
  else if (((insn & _DECODE_LOWNIB_HIGHBYTE) == 0x0D00)
	   && (((insn & _DECODE_4TO6_HIGHBYTE) == 0x3000)
	       || ((insn & _DECODE_4TO6_HIGHBYTE) == 0x4000)
	       || ((insn & _DECODE_4TO6_HIGHBYTE) == 0x5000)
	       || ((insn & _DECODE_4TO6_HIGHBYTE) == 0x0000)))
    return 10;

  else if ((insn & _DECODE_LOWBYTE) == 0x000D)
    return 11;

  else if ((insn & _DECODE_LOWBYTE) == 0x008D)
    return 12;

  else if ((insn & _DECODE_0TO6_HIGHBYTE) == 0x7800)
    return 13;

  else if ((insn & _DECODE_LOWNIB_HIGHBYTE) == 0x0700)
    return 9;

  else if (((insn & _DECODE_LOWNIB_LOWBYTE) == 0x0007)
	   && ((insn & _DECODE_GET_F_HIGHBYTE) == 0x8000))
    return 4;

  return 8;
}

static void
get_insn_opcode (const unsigned int insn, group_info *i)
{
  static unsigned char pfx_flag = 0;
  static unsigned char count_for_pfx = 0;

  i->flag ^= i->flag;
  i->bit_no ^= i->bit_no;
  i->dst ^= i->dst;
  i->fbit ^= i->fbit;
  i->group_no ^= i->group_no;
  i->src ^= i->src;
  i->sub_opcode ^= i->sub_opcode;

  if (count_for_pfx > 0)
    count_for_pfx++;

  if (((insn >> 8) == 0x0b) || ((insn >> 8) == 0x2b))
    {
      pfx_flag = 1;
      count_for_pfx = 1;
    }

  i->group_no = get_group (insn);

  if (pfx_flag && (i->group_no == 0x0D) && (count_for_pfx == 2)
      && ((insn & _DECODE_0TO6_HIGHBYTE) == 0x7800))
    {
      i->group_no = 0x08;
      count_for_pfx = 0;
      pfx_flag ^= pfx_flag;
    }

  switch (i->group_no)
    {
    case 1:
      i->sub_opcode = ((insn & _DECODE_4TO6_HIGHBYTE) >> 12);
      i->flag |= SUB_OP;
      i->src = ((insn & _DECODE_LOWBYTE));
      i->flag |= SRC;
      i->fbit = ((insn & _DECODE_GET_F_HIGHBYTE) >> 15);
      i->flag |= FORMAT;
      break;

    case 2:
      i->sub_opcode = ((insn & _DECODE_HIGHNIB_LOWBYTE) >> 4);
      i->flag |= SUB_OP;
      break;

    case 3:
      i->sub_opcode = ((insn & _DECODE_HIGHNIB_HIGHBYTE) >> 12);
      i->flag |= SUB_OP;
      i->bit_no = ((insn & _DECODE_HIGHNIB_LOWBYTE) >> 4);
      i->flag |= BIT_NO;
      break;

    case 4:
      i->sub_opcode = ((insn & _DECODE_BIT7_LOWBYTE) >> 7);
      i->flag |= SUB_OP;
      i->dst = ((insn & _DECODE_0TO6_HIGHBYTE) >> 8);
      i->flag |= DST;
      i->bit_no = ((insn & _DECODE_4TO6_LOWBYTE) >> 4);
      i->flag |= BIT_NO;
      break;

    case 5:
      i->sub_opcode = ((insn & _DECODE_4TO6_HIGHBYTE) >> 12);
      i->flag |= SUB_OP;
      i->src = ((insn & _DECODE_LOWBYTE));
      i->flag |= SRC;
      i->fbit = ((insn & _DECODE_GET_F_HIGHBYTE) >> 15);
      i->flag |= FORMAT;
      break;

    case 6:
      i->sub_opcode = ((insn & _DECODE_HIGHNIB_HIGHBYTE) >> 12);
      i->flag |= SUB_OP;
      break;

    case 7:
      i->sub_opcode = ((insn & _DECODE_HIGHNIB_HIGHBYTE) >> 12);
      i->flag |= SUB_OP;
      break;

    case 8:
      i->dst = ((insn & _DECODE_0TO6_HIGHBYTE) >> 8);
      i->flag |= DST;
      i->src = ((insn & _DECODE_LOWBYTE));
      i->flag |= SRC;
      i->fbit = ((insn & _DECODE_GET_F_HIGHBYTE) >> 15);
      i->flag |= FORMAT;
      break;

    case 9:
      i->sub_opcode = ((insn & _DECODE_0TO2_HIGHBYTE) >> 8);
      i->flag |= SUB_OP;
      i->bit_no = ((insn & _DECODE_4TO6_HIGHBYTE) >> 12);
      i->flag |= BIT_NO;
      i->fbit = ((insn & _DECODE_GET_F_HIGHBYTE) >> 15);
      i->flag |= FORMAT;
      i->src = ((insn & _DECODE_LOWBYTE));
      i->flag |= SRC;
      break;

    case 10:
      i->sub_opcode = ((insn & _DECODE_4TO6_HIGHBYTE) >> 12);
      i->flag |= SUB_OP;
      i->src = ((insn & _DECODE_LOWBYTE));
      i->flag |= SRC;
      i->fbit = ((insn & _DECODE_GET_F_HIGHBYTE) >> 15);
      i->flag |= FORMAT;
      break;

    case 11:
      i->dst = ((insn & _DECODE_0TO6_HIGHBYTE) >> 8);
      i->flag |= DST;
      break;

    case 12:
      i->dst = ((insn & _DECODE_0TO6_HIGHBYTE) >> 8);
      i->flag |= DST;
      break;

    case 13:
      i->sub_opcode = ((insn & _DECODE_4TO6_HIGHBYTE) >> 12);
      i->flag |= SUB_OP;
      i->src = ((insn & _DECODE_LOWBYTE));
      i->flag |= SRC;
      i->fbit = ((insn & _DECODE_GET_F_HIGHBYTE) >> 15);
      i->flag |= FORMAT;
      break;

    }
  return;
}


/* Print one instruction from MEMADDR on INFO->STREAM. Return the size of the 
   instruction (always 2 on MAXQ20).  */

static int
print_insn (bfd_vma memaddr, struct disassemble_info *info,
	    enum bfd_endian endianess)
{
  /* The raw instruction.  */
  unsigned char insn[2], derived_code;
  unsigned int format;
  unsigned int actual_operands;
  unsigned int i;
  /* The group_info collected/decoded.  */
  group_info grp;
  MAXQ20_OPCODE_INFO const *opcode;
  int status;

  format = 0;

  status = info->read_memory_func (memaddr, (bfd_byte *) & insn[0], 2, info);

  if (status != 0)
    {
      info->memory_error_func (status, memaddr, info);
      return -1;
    }

  /* FIXME: Endianness always little.  */
  if (endianess == BFD_ENDIAN_BIG)
    get_insn_opcode (((insn[0] << 8) | (insn[1])), &grp);
  else
    get_insn_opcode (((insn[1] << 8) | (insn[0])), &grp);

  derived_code = ((grp.group_no << 4) | grp.sub_opcode);

  if (insn[0] == 0 && insn[1] == 0)
    {
      info->fprintf_func (info->stream, "00 00");
      return 2;
    }

  /* The opcode is always in insn[0].  */
  for (opcode = &op_table[0]; opcode->name != NULL; ++opcode)
    {
      if (opcode->instr_id == derived_code)
	{
	  if (opcode->instr_id == 0x3D)
	    {
	      if ((grp.bit_no == 0) && (opcode->arg[1] != A_BIT_0))
		continue;
	      if ((grp.bit_no == 1) && (opcode->arg[1] != A_BIT_1))
		continue;
	      if ((grp.bit_no == 3) && (opcode->arg[0] != 0))
		continue;
	    }

	  info->fprintf_func (info->stream, "%s ", opcode->name);

	  actual_operands = 0;

	  if ((grp.flag & SRC) == SRC)
	    actual_operands++;

	  if ((grp.flag & DST) == DST)
	    actual_operands++;

	  /* If Implict FLAG in the Instruction.  */
	  if ((opcode->op_number > actual_operands)
	      && !((grp.flag & SRC) == SRC) && !((grp.flag & DST) == DST))
	    {
	      for (i = 0; i < opcode->op_number; i++)
		{
		  if (i == 1 && (opcode->arg[1] != NO_ARG))
		    info->fprintf_func (info->stream, ",");
		  maxq_print_arg (opcode->arg[i], info, grp);
		}
	    }

	  /* DST is ABSENT in the grp.  */
	  if ((opcode->op_number > actual_operands)
	      && ((grp.flag & SRC) == SRC))
	    {
	      maxq_print_arg (opcode->arg[0], info, grp);
	      info->fprintf_func (info->stream, " ");

	      if (opcode->instr_id == 0xA4)
		info->fprintf_func (info->stream, "LC[0]");

	      if (opcode->instr_id == 0xA5)
		info->fprintf_func (info->stream, "LC[1]");

	      if ((grp.flag & SRC) == SRC)
		info->fprintf_func (info->stream, ",");
	    }

	  if ((grp.flag & DST) == DST)
	    {
	      if ((grp.flag & BIT_NO) == BIT_NO)
		{
		  info->fprintf_func (info->stream, " %s.%d",
				      get_reg_name (grp.dst,
						    (type1) 0 /*DST*/),
				      grp.bit_no);
		}
	      else
		info->fprintf_func (info->stream, " %s",
				    get_reg_name (grp.dst, (type1) 0));
	    }

	  /* SRC is ABSENT in the grp.  */
	  if ((opcode->op_number > actual_operands)
	      && ((grp.flag & DST) == DST))
	    {
	      info->fprintf_func (info->stream, ",");
	      maxq_print_arg (opcode->arg[1], info, grp);
	      info->fprintf_func (info->stream, " ");
	    }

	  if ((grp.flag & SRC) == SRC)
	    {
	      if ((grp.flag & DST) == DST)
		info->fprintf_func (info->stream, ",");

	      if ((grp.flag & BIT_NO) == BIT_NO)
		{
		  format = opcode->format;

		  if ((grp.flag & FORMAT) == FORMAT)
		    format = grp.fbit;
		  if (format == 1)
		    info->fprintf_func (info->stream, " %s.%d",
					get_reg_name (grp.src,
						      (type1) 1 /*SRC*/),
					grp.bit_no);
		  if (format == 0)
		    info->fprintf_func (info->stream, " #%02xh.%d",
					grp.src, grp.bit_no);
		}
	      else
		{
		  format = opcode->format;

		  if ((grp.flag & FORMAT) == FORMAT)
		    format = grp.fbit;
		  if (format == 1)
		    info->fprintf_func (info->stream, " %s",
					get_reg_name (grp.src,
						      (type1) 1 /*SRC*/));
		  if (format == 0)
		    info->fprintf_func (info->stream, " #%02xh",
					(grp.src));
		}
	    }

	  return 2;
	}
    }

  info->fprintf_func (info->stream, "Unable to Decode :  %02x %02x",
		      insn[0], insn[1]);
  return 2;			
}

int
print_insn_maxq_little (bfd_vma memaddr, struct disassemble_info *info)
{
  return print_insn (memaddr, info, BFD_ENDIAN_LITTLE);
}
@


1.8
log
@fix set but unused variable warnings
@
text
@@


1.7
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 1
a3 1
   Copyright 2004, 2005, 2007, 2009 Free Software Foundation, Inc.
a207 2
  char *first_reg;
  char *second_reg;
a241 1
	      first_reg = reg_x->reg_name;
a276 1
		  second_reg = reg_x->reg_name;
d551 1
a551 1
  unsigned char insn[2], insn0, insn8, derived_code;
a569 3
  insn8 = insn[1];
  insn0 = insn[0];

d584 1
a584 1
  /* The opcode is always in insn0.  */
@


1.6
log
@PR binutils/4801
* maxq-dis.c (get_reg_name): Fix the scan of the mem_access_syntax_table.
@
text
@d3 1
a3 1
   Copyright 2004, 2005, 2007 Free Software Foundation, Inc.
d154 1
a154 1
  unsigned char index;
d161 1
a161 1
  index = 0;
d163 2
a164 2
  index = (reg_code & MASK_HIGH_BYTE);
  index = index >> 4;
d168 1
a168 1
    if ((reg_x->Mod_name == module) && (reg_x->Mod_index == index))
d176 1
a176 1
      if ((reg_x->Mod_name == module) && (reg_x->Mod_index == index))
d198 1
a198 1
  sprintf (unres_reg_name, "%01x%01xh", index, module);
@


1.5
log
@Change source files over to GPLv3.
@
text
@d185 1
a185 1
	       mem_access_syntax_table != NULL || mem_access_syntax_table->name;
@


1.4
log
@Update the address and phone number of the FSF
@
text
@d3 1
a3 1
   Copyright 2004, 2005 Free Software Foundation, Inc.
d8 1
a8 1
   This file is part of GDB.
d10 3
a12 3
   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the Free 
   Software Foundation; either version 2 of the License, or (at your option)
d15 4
a18 4
   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   for more details.
@


1.3
log
@	* arc-ext.c: Warning fixes.
	* arc-ext.h: Likewise.
	* cgen-opc.c: Likewise.
	* ia64-gen.c: Likewise.
	* maxq-dis.c: Likewise.
	* ns32k-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* ia64-asmtab.c: Regenerate.
@
text
@d21 2
a22 2
   with this program; if not, write to the Free Software Foundation, Inc., 59 
   Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.2
log
@	* maxq-dis.c: Formatting.
	(print_insn): Warning fix.
@
text
@d3 1
a3 1
   Copyright 2004 Free Software Foundation, Inc.
d148 1
a148 1
unsigned char unres_reg_name[20];
d150 1
a150 1
static unsigned char *
@


1.1
log
@Add support fpr MAXQ processor
@
text
@d361 2
a362 2
      /* && condition with sec part added on 26 May for resoveing 2 & 3 grp
         conflict.  */
d655 2
a656 1
		info->fprintf_func (info->stream, " %s", get_reg_name (grp.dst, (type1) 0));
d686 1
a686 1
					(grp.src, SRC), grp.bit_no);
d696 2
a697 2
					   get_reg_name (grp.src,
							 (type1) 1 /*SRC*/));
d700 1
a700 1
					   (grp.src));
d709 1
a709 1
			 insn[0], insn[1]);
a717 1

@

