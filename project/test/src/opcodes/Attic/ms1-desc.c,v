head	1.5;
access;
symbols
	gdb-csl-sourcerygxx-3_4_4-25:1.4
	gdb_6_4-20051202-release:1.3
	msnyder-fork-checkpoint-branch:1.4.0.4
	msnyder-fork-checkpoint-branchpoint:1.4
	gdb-csl-gxxpro-6_3-branch:1.4.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.4
	gdb_6_4-branch:1.3.0.2
	gdb_6_4-2005-11-01-branchpoint:1.3
	gdb-csl-arm-20051020-branch:1.2.0.2
	gdb-csl-arm-20051020-branchpoint:1.2
	binutils_latest_snapshot:1.4;
locks; strict;
comment	@ * @;


1.5
date	2005.12.16.10.23.12;	author nathan;	state dead;
branches;
next	1.4;

1.4
date	2005.11.08.11.15.13;	author nathan;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.28.19.49.22;	author brolley;	state Exp;
branches;
next	1.2;

1.2
date	2005.07.01.11.16.32;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2005.06.15.16.23.54;	author brolley;	state Exp;
branches;
next	;


desc
@@


1.5
log
@	Second part of ms1 to mt renaming.
	* bfd/archures.c (bfd_arch_mt): Renamed.
	(bfd_mt_arch): Renamed.
	(bfd_archures_list): Adjusted.
	* bfd/bfd-in2.h: Rebuilt.
	* bfd/config.bfd (mt): Remove special case targ_archs.
	(mt-*-elf): Rename bfd_elf32_mt_vec.
	* bfd/configure: Rebuilt.
	* bfd/configure.in (bfd_elf32_mt_vec): Renamed.
	(selarchs) Remove mt special case.
	* bfd/cpu-mt.c (arch_info_struct): Adjust.
	(bfd_mt_arch): Renamed, adjust.
	* bfd/elf32-mt.c (mt_reloc_type_lookup, mt_info_to_howto_rela,
	mt_elf_relocate_hi16, mt_final_link_relocate, mt_relocate_section,
	mt_elf_howto_table): Renamed, adjusted.
	(mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook, mt_elf_check_relocs,
	elf32_mt_machine, mt_elf_object_p, mt_elf_set_private_flags,
	mt_elf_copy_private_bfd_data, mt_elf_merge_private_bfd_data,
	mt_elf_print_private_bfd_data): Renamed, adjusted.
	(TARGET_BIG_SYM, TARGET_BIG_NAME, ELF_ARCH, ELF_MACHINE_CODE,
	ELF_MAXPAGESIZE, elf_info_to_howto, elf_backend_relocate_section,
	bfd_elf32_bfd_reloc_type_lookup, elf_backend_gc_mark_hook,
	elf_backend_gc_sweep_hook, elf_backend_check_relocs,
	eld_backend_object_p, bfd_elf32_bfd_set_private_flags,
	bfd_elf32_bfd_copy_private_bfd_data,
	bfd_elf32_bfd_merge_private_bfd_data,
	bfd_elf32_bfd_print_private_bfd_data): Adjusted.
	* bfd/libbfd.h: Regenerated.
	* bfd/reloc.c (BFD_RELOC_MT_PC16, BFD_RELOC_MT_HI16,
	BFD_RELOC_MT_LO16, BFD_RELOC_MT_GNU_VTINHERIT,
	BFD_RELOC_MT_GNU_VTENTRY, BFD_RELOC_MT_PCINSN8): Renamed.
	* bfd/targets.c (bfd_elf32_mt_vec): Renamed.
	(_bfd_target_vector): Adjusted.
	* binutils/readelf.c (guess_is_rela): Use EM_MT.
	(dump_relocations, get_machine_name): Adjust.

	* cpu/mt.cpu (define-arch, define-isa): Set name to mt.
	(define-mach): Adjust.
	* cpu/mt.opc (CGEN_ASM_HASH): Update.
	(mt_asm_hash, mt_cgen_insn_supported): Renamed.
	(parse_loopsize, parse_imm16): Adjust.

	* gas/configure: Rebuilt.
	* gas/configure.in (mt): Remove special case.
	* gas/config/tc-mt.c (opcodes/mt-desc.h, opcodes/mt-opc.h): Change
	#includes.
	(mt_insn, mt_mach, mt_mach_bitmask, mt_flags, mt_architectures):
	Rename, adjust.
	(md_parse_option, md_show_usage, md_begin, md_assemble,
	md_cgen_lookup_reloc, md_atof): Adjust.
	(mt_force_relocation, mt_apply_fix, mt_fix_adjustable): Rename, adjust.
	* gas/config/tc-mt.h (TC_MT): Rename.
	(LISTING_HEADER, TARGET_ARCH, TARGET_FORMAT): Adjust.
	(md_apply_fix): Adjust.
	(mt_apply_fix, mt_fix_adjustable, mt_force_relocation): Rename.
	(TC_FORCE_RELOCATION, tc_fix_adjustable): Adjust.

	* gdb/mt-tdep.c (mt_arch_constants, mt_gdb_regnums): Rename, adjust.
	(mt_register_name, mt_register_type, mt_register_reggroup_p,
	mt_return_value, mt_skip_prologue, mt_breapoint_from_pc,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_frame_align,
	mt_registers_info, mt_push_dummy_call, mt_unwind_cache,
	mt_frame_unwind_cache, mt_unwind_pc, mt_unwind_dummy_id,
	mt_frame_this_id, mt_frame_prev_register, mt_frame_base_address,
	mt_frame_unwind, mt_frame_sniffer, mt_frame_base, mt_gdbarch_init,
	_initialize_mt_tdep): Rename & adjust.

	* include/dis-asm.h (print_insn_mt): Renamed.

	* include/elf/common.h (EM_MT): Renamed.
	* include/elf/mt.h: Rename relocs, cpu & other defines.

	* ld/emulparams/elf32mt.sh (ARCH, OUTPUT_FORMAT): Adjust.

	* opcodes/Makefile.am (HFILES, CFILES, ALL_MACHINES): Adjust.
	(stamp-mt): Adjust rule.
	(mt-asm.lo, mt-desc.lo, mt-dis.lo, mt-ibld.lo, mt-opc.lo): Rename &
	adjust.
	* opcodes/Makefile.in: Rebuilt.
	* opcodes/configure: Rebuilt.
	* opcodes/configure.in (bfd_mt_arch): Rename & adjust.
	* opcodes/disassemble.c (ARCH_mt): Renamed.
	(disassembler): Adjust.
	* opcodes/mt-asm.c: Renamed, rebuilt.
	* opcodes/mt-desc.c: Renamed, rebuilt.
	* opcodes/mt-desc.h: Renamed, rebuilt.
	* opcodes/mt-dis.c: Renamed, rebuilt.
	* opcodes/mt-ibld.c: Renamed, rebuilt.
	* opcodes/mt-opc.c: Renamed, rebuilt.
	* opcodes/mt-opc.h: Renamed, rebuilt.

	* sid/Makefile.in: Rebuilt.
	* sid/aclocal.m4: Rebuilt.
	* sid/configure: Rebuilt.
	* sid/sid.spec: Adjust.
	* sid/bsp/Makefile.am: Adjust.
	* sid/bsp/Makefile.in: Rebuilt.
	* sid/bsp/aclocal.m4: Rebuilt.
	* sid/bsp/configrun-sid.in: Adjust.
	* sid/bsp/pregen/Makefile.in: Rebuilt.
	* sid/bsp/pregen/mt-gdb.conf: Renamed & rebuilt.
	* sid/bsp/pregen/mt-gloss.conf: Renamed & rebuilt.
	* sid/bsp/pregen/pregen-configs.in: Adjust.
	* sid/component/aclocal.m4: Rebuilt.
	* sid/component/configure: Rebuilt.
	* sid/component/tconfig.in: Adjust.
	* sid/component/bochs/aclocal.m4: Rebuilt.
	* sid/component/cache/Makefile.in: Rebuilt.
	* sid/component/cgen-cpu/Makefile.in: Rebuilt.
	* sid/component/cgen-cpu/aclocal.m4: Rebuilt.
	* sid/component/cgen-cpu/compCGEN.cxx: Adjust.
	* sid/component/cgen-cpu/configure: Rebuilt.
	* sid/component/cgen-cpu/configure.in: Rebult.
	* sid/component/cgen-cpu/mt/Makefile.am: Adjust.
	* sid/component/cgen-cpu/mt/Makefile.in: Rebuilt.
	* sid/component/cgen-cpu/mt/hw-cpu-mt.txt: Adjust.
	* sid/component/cgen-cpu/mt/mt-cpu.h: Rebuilt.
	* sid/component/cgen-cpu/mt/mt-decode.cxx: Rebuilt.
	* sid/component/cgen-cpu/mt/mt-decode.h: Rebuilt.
	* sid/component/cgen-cpu/mt/mt-defs.h: Rebuilt.
	* sid/component/cgen-cpu/mt/mt-desc.h: Rebuilt.
	* sid/component/cgen-cpu/mt/mt-sem.cxx: Rebuilt.
	* sid/component/cgen-cpu/mt/mt-write.cxx: Rebuilt.
	* sid/component/cgen-cpu/mt/mt.cxx: Adjust.
	* sid/component/cgen-cpu/mt/mt.h: Adjust.
	* sid/component/consoles/Makefile.in: Rebuilt.
	* sid/component/families/aclocal.m4: Rebuilt.
	* sid/component/families/configure: Rebuilt.
	* sid/component/gdb/Makefile.in: Rebuilt.
	* sid/component/gloss/Makefile.in: Rebuilt.
	* sid/component/glue/Makefile.in: Rebuilt.
	* sid/component/ide/Makefile.in: Rebuilt.
	* sid/component/interrupt/Makefile.in: Rebuilt.
	* sid/component/lcd/Makefile.in: Rebuilt.
	* sid/component/lcd/testsuite/Makefile.in: Rebuilt.
	* sid/component/loader/Makefile.am: Rebuilt.
	* sid/component/loader/Makefile.in: Rebuilt.
	* sid/component/mapper/Makefile.in: Rebuilt.
	* sid/component/mapper/testsuite/Makefile.in: Rebuilt.
	* sid/component/memory/Makefile.in: Rebuilt.
	* sid/component/mmu/Makefile.in: Rebuilt.
	* sid/component/parport/Makefile.in: Rebuilt.
	* sid/component/profiling/Makefile.in: Rebuilt.
	* sid/component/rtc/Makefile.in: Rebuilt.
	* sid/component/sched/Makefile.in: Rebuilt.
	* sid/component/testsuite/Makefile.in: Rebuilt.
	* sid/component/timers/aclocal.m4: Rebuilt.
	* sid/component/timers/configure: Rebuilt.
	* sid/component/uart/Makefile.in: Rebuilt.
	* sid/component/uart/testsuite/Makefile.in: Rebuilt.
	* sid/config/config.sub: Adjust.
	* sid/config/info.tcl.in: Adjust.
	* sid/config/sidtargets.m4: Adjust.
	* sid/doc/Makefile.in: Rebuilt.
	* sid/main/dynamic/Makefile.am: Rebuilt.
	* sid/main/dynamic/Makefile.in: Rebuilt.
	* sid/main/dynamic/aclocal.m4: Rebuilt.
	* sid/main/dynamic/configure: Rebuilt.
@
text
@/* CPU data for ms1.

THIS FILE IS MACHINE GENERATED WITH CGEN.

Copyright 1996-2005 Free Software Foundation, Inc.

This file is part of the GNU Binutils and/or GDB, the GNU debugger.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.

*/

#include "sysdep.h"
#include <stdio.h>
#include <stdarg.h>
#include "ansidecl.h"
#include "bfd.h"
#include "symcat.h"
#include "ms1-desc.h"
#include "ms1-opc.h"
#include "opintl.h"
#include "libiberty.h"
#include "xregex.h"

/* Attributes.  */

static const CGEN_ATTR_ENTRY bool_attr[] =
{
  { "#f", 0 },
  { "#t", 1 },
  { 0, 0 }
};

static const CGEN_ATTR_ENTRY MACH_attr[] ATTRIBUTE_UNUSED =
{
  { "base", MACH_BASE },
  { "ms1", MACH_MS1 },
  { "ms1_003", MACH_MS1_003 },
  { "ms2", MACH_MS2 },
  { "max", MACH_MAX },
  { 0, 0 }
};

static const CGEN_ATTR_ENTRY ISA_attr[] ATTRIBUTE_UNUSED =
{
  { "ms1", ISA_MS1 },
  { "max", ISA_MAX },
  { 0, 0 }
};

const CGEN_ATTR_TABLE ms1_cgen_ifield_attr_table[] =
{
  { "MACH", & MACH_attr[0], & MACH_attr[0] },
  { "VIRTUAL", &bool_attr[0], &bool_attr[0] },
  { "PCREL-ADDR", &bool_attr[0], &bool_attr[0] },
  { "ABS-ADDR", &bool_attr[0], &bool_attr[0] },
  { "RESERVED", &bool_attr[0], &bool_attr[0] },
  { "SIGN-OPT", &bool_attr[0], &bool_attr[0] },
  { "SIGNED", &bool_attr[0], &bool_attr[0] },
  { 0, 0, 0 }
};

const CGEN_ATTR_TABLE ms1_cgen_hardware_attr_table[] =
{
  { "MACH", & MACH_attr[0], & MACH_attr[0] },
  { "VIRTUAL", &bool_attr[0], &bool_attr[0] },
  { "CACHE-ADDR", &bool_attr[0], &bool_attr[0] },
  { "PC", &bool_attr[0], &bool_attr[0] },
  { "PROFILE", &bool_attr[0], &bool_attr[0] },
  { 0, 0, 0 }
};

const CGEN_ATTR_TABLE ms1_cgen_operand_attr_table[] =
{
  { "MACH", & MACH_attr[0], & MACH_attr[0] },
  { "VIRTUAL", &bool_attr[0], &bool_attr[0] },
  { "PCREL-ADDR", &bool_attr[0], &bool_attr[0] },
  { "ABS-ADDR", &bool_attr[0], &bool_attr[0] },
  { "SIGN-OPT", &bool_attr[0], &bool_attr[0] },
  { "SIGNED", &bool_attr[0], &bool_attr[0] },
  { "NEGATIVE", &bool_attr[0], &bool_attr[0] },
  { "RELAX", &bool_attr[0], &bool_attr[0] },
  { "SEM-ONLY", &bool_attr[0], &bool_attr[0] },
  { 0, 0, 0 }
};

const CGEN_ATTR_TABLE ms1_cgen_insn_attr_table[] =
{
  { "MACH", & MACH_attr[0], & MACH_attr[0] },
  { "ALIAS", &bool_attr[0], &bool_attr[0] },
  { "VIRTUAL", &bool_attr[0], &bool_attr[0] },
  { "UNCOND-CTI", &bool_attr[0], &bool_attr[0] },
  { "COND-CTI", &bool_attr[0], &bool_attr[0] },
  { "SKIP-CTI", &bool_attr[0], &bool_attr[0] },
  { "DELAY-SLOT", &bool_attr[0], &bool_attr[0] },
  { "RELAXABLE", &bool_attr[0], &bool_attr[0] },
  { "RELAXED", &bool_attr[0], &bool_attr[0] },
  { "NO-DIS", &bool_attr[0], &bool_attr[0] },
  { "PBB", &bool_attr[0], &bool_attr[0] },
  { "LOAD-DELAY", &bool_attr[0], &bool_attr[0] },
  { "MEMORY-ACCESS", &bool_attr[0], &bool_attr[0] },
  { "AL-INSN", &bool_attr[0], &bool_attr[0] },
  { "IO-INSN", &bool_attr[0], &bool_attr[0] },
  { "BR-INSN", &bool_attr[0], &bool_attr[0] },
  { "JAL-HAZARD", &bool_attr[0], &bool_attr[0] },
  { "USES-FRDR", &bool_attr[0], &bool_attr[0] },
  { "USES-FRDRRR", &bool_attr[0], &bool_attr[0] },
  { "USES-FRSR1", &bool_attr[0], &bool_attr[0] },
  { "USES-FRSR2", &bool_attr[0], &bool_attr[0] },
  { "SKIPA", &bool_attr[0], &bool_attr[0] },
  { 0, 0, 0 }
};

/* Instruction set variants.  */

static const CGEN_ISA ms1_cgen_isa_table[] = {
  { "ms1", 32, 32, 32, 32 },
  { 0, 0, 0, 0, 0 }
};

/* Machine variants.  */

static const CGEN_MACH ms1_cgen_mach_table[] = {
  { "ms1", "ms1", MACH_MS1, 0 },
  { "ms1-003", "ms1-003", MACH_MS1_003, 0 },
  { "ms2", "ms2", MACH_MS2, 0 },
  { 0, 0, 0, 0 }
};

static CGEN_KEYWORD_ENTRY ms1_cgen_opval_msys_syms_entries[] =
{
  { "DUP", 1, {0, {{{0, 0}}}}, 0, 0 },
  { "XX", 0, {0, {{{0, 0}}}}, 0, 0 }
};

CGEN_KEYWORD ms1_cgen_opval_msys_syms =
{
  & ms1_cgen_opval_msys_syms_entries[0],
  2,
  0, 0, 0, 0, ""
};

static CGEN_KEYWORD_ENTRY ms1_cgen_opval_h_spr_entries[] =
{
  { "R0", 0, {0, {{{0, 0}}}}, 0, 0 },
  { "R1", 1, {0, {{{0, 0}}}}, 0, 0 },
  { "R2", 2, {0, {{{0, 0}}}}, 0, 0 },
  { "R3", 3, {0, {{{0, 0}}}}, 0, 0 },
  { "R4", 4, {0, {{{0, 0}}}}, 0, 0 },
  { "R5", 5, {0, {{{0, 0}}}}, 0, 0 },
  { "R6", 6, {0, {{{0, 0}}}}, 0, 0 },
  { "R7", 7, {0, {{{0, 0}}}}, 0, 0 },
  { "R8", 8, {0, {{{0, 0}}}}, 0, 0 },
  { "R9", 9, {0, {{{0, 0}}}}, 0, 0 },
  { "R10", 10, {0, {{{0, 0}}}}, 0, 0 },
  { "R11", 11, {0, {{{0, 0}}}}, 0, 0 },
  { "R12", 12, {0, {{{0, 0}}}}, 0, 0 },
  { "fp", 12, {0, {{{0, 0}}}}, 0, 0 },
  { "R13", 13, {0, {{{0, 0}}}}, 0, 0 },
  { "sp", 13, {0, {{{0, 0}}}}, 0, 0 },
  { "R14", 14, {0, {{{0, 0}}}}, 0, 0 },
  { "ra", 14, {0, {{{0, 0}}}}, 0, 0 },
  { "R15", 15, {0, {{{0, 0}}}}, 0, 0 },
  { "ira", 15, {0, {{{0, 0}}}}, 0, 0 }
};

CGEN_KEYWORD ms1_cgen_opval_h_spr =
{
  & ms1_cgen_opval_h_spr_entries[0],
  20,
  0, 0, 0, 0, ""
};


/* The hardware table.  */

#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
#define A(a) (1 << CGEN_HW_##a)
#else
#define A(a) (1 << CGEN_HW_/**/a)
#endif

const CGEN_HW_ENTRY ms1_cgen_hw_table[] =
{
  { "h-memory", HW_H_MEMORY, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
  { "h-sint", HW_H_SINT, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
  { "h-uint", HW_H_UINT, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
  { "h-addr", HW_H_ADDR, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
  { "h-iaddr", HW_H_IADDR, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
  { "h-spr", HW_H_SPR, CGEN_ASM_KEYWORD, (PTR) & ms1_cgen_opval_h_spr, { 0, { { { (1<<MACH_BASE), 0 } } } } },
  { "h-pc", HW_H_PC, CGEN_ASM_NONE, 0, { 0|A(PROFILE)|A(PC), { { { (1<<MACH_BASE), 0 } } } } },
  { 0, 0, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } }
};

#undef A


/* The instruction field table.  */

#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
#define A(a) (1 << CGEN_IFLD_##a)
#else
#define A(a) (1 << CGEN_IFLD_/**/a)
#endif

const CGEN_IFLD ms1_cgen_ifld_table[] =
{
  { MS1_F_NIL, "f-nil", 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_ANYOF, "f-anyof", 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_MSYS, "f-msys", 0, 32, 31, 1, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_OPC, "f-opc", 0, 32, 30, 6, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_IMM, "f-imm", 0, 32, 24, 1, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_UU24, "f-uu24", 0, 32, 23, 24, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_SR1, "f-sr1", 0, 32, 23, 4, { 0|A(ABS_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_SR2, "f-sr2", 0, 32, 19, 4, { 0|A(ABS_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_DR, "f-dr", 0, 32, 19, 4, { 0|A(ABS_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_DRRR, "f-drrr", 0, 32, 15, 4, { 0|A(ABS_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_IMM16U, "f-imm16u", 0, 32, 15, 16, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_IMM16S, "f-imm16s", 0, 32, 15, 16, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_IMM16A, "f-imm16a", 0, 32, 15, 16, { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_UU4A, "f-uu4a", 0, 32, 19, 4, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_UU4B, "f-uu4b", 0, 32, 23, 4, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_UU12, "f-uu12", 0, 32, 11, 12, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_UU8, "f-uu8", 0, 32, 15, 8, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_UU16, "f-uu16", 0, 32, 15, 16, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_UU1, "f-uu1", 0, 32, 7, 1, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_MSOPC, "f-msopc", 0, 32, 30, 5, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_UU_26_25, "f-uu-26-25", 0, 32, 25, 26, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_MASK, "f-mask", 0, 32, 25, 16, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_BANKADDR, "f-bankaddr", 0, 32, 25, 13, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_RDA, "f-rda", 0, 32, 25, 1, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_UU_2_25, "f-uu-2-25", 0, 32, 25, 2, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_RBBC, "f-rbbc", 0, 32, 25, 2, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_PERM, "f-perm", 0, 32, 25, 2, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_MODE, "f-mode", 0, 32, 25, 2, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_UU_1_24, "f-uu-1-24", 0, 32, 24, 1, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_WR, "f-wr", 0, 32, 24, 1, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_FBINCR, "f-fbincr", 0, 32, 23, 4, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_UU_2_23, "f-uu-2-23", 0, 32, 23, 2, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_XMODE, "f-xmode", 0, 32, 23, 1, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_A23, "f-a23", 0, 32, 23, 1, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_MASK1, "f-mask1", 0, 32, 22, 3, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_CR, "f-cr", 0, 32, 22, 3, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_TYPE, "f-type", 0, 32, 21, 2, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_INCAMT, "f-incamt", 0, 32, 19, 8, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_CBS, "f-cbs", 0, 32, 19, 2, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_UU_1_19, "f-uu-1-19", 0, 32, 19, 1, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_BALL, "f-ball", 0, 32, 19, 1, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_COLNUM, "f-colnum", 0, 32, 18, 3, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_BRC, "f-brc", 0, 32, 18, 3, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_INCR, "f-incr", 0, 32, 17, 6, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_FBDISP, "f-fbdisp", 0, 32, 15, 6, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_UU_4_15, "f-uu-4-15", 0, 32, 15, 4, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_LENGTH, "f-length", 0, 32, 15, 3, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_UU_1_15, "f-uu-1-15", 0, 32, 15, 1, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_RC, "f-rc", 0, 32, 15, 1, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_RCNUM, "f-rcnum", 0, 32, 14, 3, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_ROWNUM, "f-rownum", 0, 32, 14, 3, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_CBX, "f-cbx", 0, 32, 14, 3, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_ID, "f-id", 0, 32, 14, 1, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_SIZE, "f-size", 0, 32, 13, 14, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_ROWNUM1, "f-rownum1", 0, 32, 12, 3, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_UU_3_11, "f-uu-3-11", 0, 32, 11, 3, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_RC1, "f-rc1", 0, 32, 11, 1, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_CCB, "f-ccb", 0, 32, 11, 1, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_CBRB, "f-cbrb", 0, 32, 10, 1, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_CDB, "f-cdb", 0, 32, 10, 1, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_ROWNUM2, "f-rownum2", 0, 32, 9, 3, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_CELL, "f-cell", 0, 32, 9, 3, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_UU_3_9, "f-uu-3-9", 0, 32, 9, 3, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_CONTNUM, "f-contnum", 0, 32, 8, 9, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_UU_1_6, "f-uu-1-6", 0, 32, 6, 1, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_DUP, "f-dup", 0, 32, 6, 1, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_RC2, "f-rc2", 0, 32, 6, 1, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_CTXDISP, "f-ctxdisp", 0, 32, 5, 6, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_IMM16L, "f-imm16l", 0, 32, 23, 16, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_LOOPO, "f-loopo", 0, 32, 7, 8, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_CB1SEL, "f-cb1sel", 0, 32, 25, 3, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_CB2SEL, "f-cb2sel", 0, 32, 22, 3, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_CB1INCR, "f-cb1incr", 0, 32, 19, 6, { 0|A(SIGNED), { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_CB2INCR, "f-cb2incr", 0, 32, 13, 6, { 0|A(SIGNED), { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_RC3, "f-rc3", 0, 32, 7, 1, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_MSYSFRSR2, "f-msysfrsr2", 0, 32, 19, 4, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_BRC2, "f-brc2", 0, 32, 14, 3, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { MS1_F_BALL2, "f-ball2", 0, 32, 15, 1, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
  { 0, 0, 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } }
};

#undef A



/* multi ifield declarations */



/* multi ifield definitions */


/* The operand table.  */

#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
#define A(a) (1 << CGEN_OPERAND_##a)
#else
#define A(a) (1 << CGEN_OPERAND_/**/a)
#endif
#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
#define OPERAND(op) MS1_OPERAND_##op
#else
#define OPERAND(op) MS1_OPERAND_/**/op
#endif

const CGEN_OPERAND ms1_cgen_operand_table[] =
{
/* pc: program counter */
  { "pc", MS1_OPERAND_PC, HW_H_PC, 0, 0,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_NIL] } }, 
    { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
/* frsr1: register */
  { "frsr1", MS1_OPERAND_FRSR1, HW_H_SPR, 23, 4,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_SR1] } }, 
    { 0|A(ABS_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
/* frsr2: register */
  { "frsr2", MS1_OPERAND_FRSR2, HW_H_SPR, 19, 4,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_SR2] } }, 
    { 0|A(ABS_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
/* frdr: register */
  { "frdr", MS1_OPERAND_FRDR, HW_H_SPR, 19, 4,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_DR] } }, 
    { 0|A(ABS_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
/* frdrrr: register */
  { "frdrrr", MS1_OPERAND_FRDRRR, HW_H_SPR, 15, 4,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_DRRR] } }, 
    { 0|A(ABS_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
/* imm16: immediate value - sign extd */
  { "imm16", MS1_OPERAND_IMM16, HW_H_SINT, 15, 16,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_IMM16S] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* imm16z: immediate value - zero extd */
  { "imm16z", MS1_OPERAND_IMM16Z, HW_H_UINT, 15, 16,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_IMM16U] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* imm16o: immediate value */
  { "imm16o", MS1_OPERAND_IMM16O, HW_H_UINT, 15, 16,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_IMM16S] } }, 
    { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
/* rc: rc */
  { "rc", MS1_OPERAND_RC, HW_H_UINT, 15, 1,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_RC] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* rcnum: rcnum */
  { "rcnum", MS1_OPERAND_RCNUM, HW_H_UINT, 14, 3,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_RCNUM] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* contnum: context number */
  { "contnum", MS1_OPERAND_CONTNUM, HW_H_UINT, 8, 9,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_CONTNUM] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* rbbc: omega network configuration */
  { "rbbc", MS1_OPERAND_RBBC, HW_H_UINT, 25, 2,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_RBBC] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* colnum: column number */
  { "colnum", MS1_OPERAND_COLNUM, HW_H_UINT, 18, 3,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_COLNUM] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* rownum: row number */
  { "rownum", MS1_OPERAND_ROWNUM, HW_H_UINT, 14, 3,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_ROWNUM] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* rownum1: row number */
  { "rownum1", MS1_OPERAND_ROWNUM1, HW_H_UINT, 12, 3,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_ROWNUM1] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* rownum2: row number */
  { "rownum2", MS1_OPERAND_ROWNUM2, HW_H_UINT, 9, 3,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_ROWNUM2] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* rc1: rc1 */
  { "rc1", MS1_OPERAND_RC1, HW_H_UINT, 11, 1,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_RC1] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* rc2: rc2 */
  { "rc2", MS1_OPERAND_RC2, HW_H_UINT, 6, 1,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_RC2] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* cbrb: data-bus orientation */
  { "cbrb", MS1_OPERAND_CBRB, HW_H_UINT, 10, 1,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_CBRB] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* cell: cell */
  { "cell", MS1_OPERAND_CELL, HW_H_UINT, 9, 3,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_CELL] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* dup: dup */
  { "dup", MS1_OPERAND_DUP, HW_H_UINT, 6, 1,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_DUP] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* ctxdisp: context displacement */
  { "ctxdisp", MS1_OPERAND_CTXDISP, HW_H_UINT, 5, 6,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_CTXDISP] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* fbdisp: frame buffer displacement */
  { "fbdisp", MS1_OPERAND_FBDISP, HW_H_UINT, 15, 6,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_FBDISP] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* type: type */
  { "type", MS1_OPERAND_TYPE, HW_H_UINT, 21, 2,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_TYPE] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* mask: mask */
  { "mask", MS1_OPERAND_MASK, HW_H_UINT, 25, 16,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_MASK] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* bankaddr: bank address */
  { "bankaddr", MS1_OPERAND_BANKADDR, HW_H_UINT, 25, 13,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_BANKADDR] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* incamt: increment amount */
  { "incamt", MS1_OPERAND_INCAMT, HW_H_UINT, 19, 8,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_INCAMT] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* xmode: xmode */
  { "xmode", MS1_OPERAND_XMODE, HW_H_UINT, 23, 1,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_XMODE] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* mask1: mask1 */
  { "mask1", MS1_OPERAND_MASK1, HW_H_UINT, 22, 3,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_MASK1] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* ball: b_all */
  { "ball", MS1_OPERAND_BALL, HW_H_UINT, 19, 1,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_BALL] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* brc: b_r_c */
  { "brc", MS1_OPERAND_BRC, HW_H_UINT, 18, 3,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_BRC] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* rda: rd */
  { "rda", MS1_OPERAND_RDA, HW_H_UINT, 25, 1,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_RDA] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* wr: wr */
  { "wr", MS1_OPERAND_WR, HW_H_UINT, 24, 1,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_WR] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* ball2: b_all2 */
  { "ball2", MS1_OPERAND_BALL2, HW_H_UINT, 15, 1,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_BALL2] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* brc2: b_r_c2 */
  { "brc2", MS1_OPERAND_BRC2, HW_H_UINT, 14, 3,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_BRC2] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* perm: perm */
  { "perm", MS1_OPERAND_PERM, HW_H_UINT, 25, 2,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_PERM] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* a23: a23 */
  { "a23", MS1_OPERAND_A23, HW_H_UINT, 23, 1,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_A23] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* cr: c-r */
  { "cr", MS1_OPERAND_CR, HW_H_UINT, 22, 3,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_CR] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* cbs: cbs */
  { "cbs", MS1_OPERAND_CBS, HW_H_UINT, 19, 2,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_CBS] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* incr: incr */
  { "incr", MS1_OPERAND_INCR, HW_H_UINT, 17, 6,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_INCR] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* length: length */
  { "length", MS1_OPERAND_LENGTH, HW_H_UINT, 15, 3,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_LENGTH] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* cbx: cbx */
  { "cbx", MS1_OPERAND_CBX, HW_H_UINT, 14, 3,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_CBX] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* ccb: ccb */
  { "ccb", MS1_OPERAND_CCB, HW_H_UINT, 11, 1,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_CCB] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* cdb: cdb */
  { "cdb", MS1_OPERAND_CDB, HW_H_UINT, 10, 1,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_CDB] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* mode: mode */
  { "mode", MS1_OPERAND_MODE, HW_H_UINT, 25, 2,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_MODE] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* id: i/d */
  { "id", MS1_OPERAND_ID, HW_H_UINT, 14, 1,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_ID] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* size: size */
  { "size", MS1_OPERAND_SIZE, HW_H_UINT, 13, 14,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_SIZE] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* fbincr: fb incr */
  { "fbincr", MS1_OPERAND_FBINCR, HW_H_UINT, 23, 4,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_FBINCR] } }, 
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
/* loopsize: immediate value */
  { "loopsize", MS1_OPERAND_LOOPSIZE, HW_H_UINT, 7, 8,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_LOOPO] } }, 
    { 0|A(PCREL_ADDR), { { { (1<<MACH_MS2), 0 } } } }  },
/* imm16l: immediate value */
  { "imm16l", MS1_OPERAND_IMM16L, HW_H_UINT, 23, 16,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_IMM16L] } }, 
    { 0, { { { (1<<MACH_MS2), 0 } } } }  },
/* rc3: rc3 */
  { "rc3", MS1_OPERAND_RC3, HW_H_UINT, 7, 1,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_RC3] } }, 
    { 0, { { { (1<<MACH_MS2), 0 } } } }  },
/* cb1sel: cb1sel */
  { "cb1sel", MS1_OPERAND_CB1SEL, HW_H_UINT, 25, 3,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_CB1SEL] } }, 
    { 0, { { { (1<<MACH_MS2), 0 } } } }  },
/* cb2sel: cb2sel */
  { "cb2sel", MS1_OPERAND_CB2SEL, HW_H_UINT, 22, 3,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_CB2SEL] } }, 
    { 0, { { { (1<<MACH_MS2), 0 } } } }  },
/* cb1incr: cb1incr */
  { "cb1incr", MS1_OPERAND_CB1INCR, HW_H_SINT, 19, 6,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_CB1INCR] } }, 
    { 0|A(SIGNED), { { { (1<<MACH_MS2), 0 } } } }  },
/* cb2incr: cb2incr */
  { "cb2incr", MS1_OPERAND_CB2INCR, HW_H_SINT, 13, 6,
    { 0, { (const PTR) &ms1_cgen_ifld_table[MS1_F_CB2INCR] } }, 
    { 0|A(SIGNED), { { { (1<<MACH_MS2), 0 } } } }  },
/* sentinel */
  { 0, 0, 0, 0, 0,
    { 0, { (const PTR) 0 } },
    { 0, { { { (1<<MACH_BASE), 0 } } } } }
};

#undef A


/* The instruction table.  */

#define OP(field) CGEN_SYNTAX_MAKE_FIELD (OPERAND (field))
#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
#define A(a) (1 << CGEN_INSN_##a)
#else
#define A(a) (1 << CGEN_INSN_/**/a)
#endif

static const CGEN_IBASE ms1_cgen_insn_table[MAX_INSNS] =
{
  /* Special null first entry.
     A `num' value of zero is thus invalid.
     Also, the special `invalid' insn resides here.  */
  { 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
/* add $frdrrr,$frsr1,$frsr2 */
  {
    MS1_INSN_ADD, "add", "add", 32,
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR)|A(AL_INSN), { { { (1<<MACH_BASE), 0 } } } }
  },
/* addu $frdrrr,$frsr1,$frsr2 */
  {
    MS1_INSN_ADDU, "addu", "addu", 32,
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR)|A(AL_INSN), { { { (1<<MACH_BASE), 0 } } } }
  },
/* addi $frdr,$frsr1,#$imm16 */
  {
    MS1_INSN_ADDI, "addi", "addi", 32,
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(AL_INSN), { { { (1<<MACH_BASE), 0 } } } }
  },
/* addui $frdr,$frsr1,#$imm16z */
  {
    MS1_INSN_ADDUI, "addui", "addui", 32,
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(AL_INSN), { { { (1<<MACH_BASE), 0 } } } }
  },
/* sub $frdrrr,$frsr1,$frsr2 */
  {
    MS1_INSN_SUB, "sub", "sub", 32,
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR)|A(AL_INSN), { { { (1<<MACH_BASE), 0 } } } }
  },
/* subu $frdrrr,$frsr1,$frsr2 */
  {
    MS1_INSN_SUBU, "subu", "subu", 32,
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR)|A(AL_INSN), { { { (1<<MACH_BASE), 0 } } } }
  },
/* subi $frdr,$frsr1,#$imm16 */
  {
    MS1_INSN_SUBI, "subi", "subi", 32,
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(AL_INSN), { { { (1<<MACH_BASE), 0 } } } }
  },
/* subui $frdr,$frsr1,#$imm16z */
  {
    MS1_INSN_SUBUI, "subui", "subui", 32,
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(AL_INSN), { { { (1<<MACH_BASE), 0 } } } }
  },
/* mul $frdrrr,$frsr1,$frsr2 */
  {
    MS1_INSN_MUL, "mul", "mul", 32,
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR)|A(AL_INSN), { { { (1<<MACH_MS1_003)|(1<<MACH_MS2), 0 } } } }
  },
/* muli $frdr,$frsr1,#$imm16 */
  {
    MS1_INSN_MULI, "muli", "muli", 32,
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(AL_INSN), { { { (1<<MACH_MS1_003)|(1<<MACH_MS2), 0 } } } }
  },
/* and $frdrrr,$frsr1,$frsr2 */
  {
    MS1_INSN_AND, "and", "and", 32,
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR)|A(AL_INSN), { { { (1<<MACH_BASE), 0 } } } }
  },
/* andi $frdr,$frsr1,#$imm16z */
  {
    MS1_INSN_ANDI, "andi", "andi", 32,
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(AL_INSN), { { { (1<<MACH_BASE), 0 } } } }
  },
/* or $frdrrr,$frsr1,$frsr2 */
  {
    MS1_INSN_OR, "or", "or", 32,
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR)|A(AL_INSN), { { { (1<<MACH_BASE), 0 } } } }
  },
/* nop */
  {
    MS1_INSN_NOP, "nop", "nop", 32,
    { 0, { { { (1<<MACH_BASE), 0 } } } }
  },
/* ori $frdr,$frsr1,#$imm16z */
  {
    MS1_INSN_ORI, "ori", "ori", 32,
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(AL_INSN), { { { (1<<MACH_BASE), 0 } } } }
  },
/* xor $frdrrr,$frsr1,$frsr2 */
  {
    MS1_INSN_XOR, "xor", "xor", 32,
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR)|A(AL_INSN), { { { (1<<MACH_BASE), 0 } } } }
  },
/* xori $frdr,$frsr1,#$imm16z */
  {
    MS1_INSN_XORI, "xori", "xori", 32,
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(AL_INSN), { { { (1<<MACH_BASE), 0 } } } }
  },
/* nand $frdrrr,$frsr1,$frsr2 */
  {
    MS1_INSN_NAND, "nand", "nand", 32,
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR)|A(AL_INSN), { { { (1<<MACH_BASE), 0 } } } }
  },
/* nandi $frdr,$frsr1,#$imm16z */
  {
    MS1_INSN_NANDI, "nandi", "nandi", 32,
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(AL_INSN), { { { (1<<MACH_BASE), 0 } } } }
  },
/* nor $frdrrr,$frsr1,$frsr2 */
  {
    MS1_INSN_NOR, "nor", "nor", 32,
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR)|A(AL_INSN), { { { (1<<MACH_BASE), 0 } } } }
  },
/* nori $frdr,$frsr1,#$imm16z */
  {
    MS1_INSN_NORI, "nori", "nori", 32,
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(AL_INSN), { { { (1<<MACH_BASE), 0 } } } }
  },
/* xnor $frdrrr,$frsr1,$frsr2 */
  {
    MS1_INSN_XNOR, "xnor", "xnor", 32,
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR)|A(AL_INSN), { { { (1<<MACH_BASE), 0 } } } }
  },
/* xnori $frdr,$frsr1,#$imm16z */
  {
    MS1_INSN_XNORI, "xnori", "xnori", 32,
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(AL_INSN), { { { (1<<MACH_BASE), 0 } } } }
  },
/* ldui $frdr,#$imm16z */
  {
    MS1_INSN_LDUI, "ldui", "ldui", 32,
    { 0|A(USES_FRDR)|A(AL_INSN), { { { (1<<MACH_BASE), 0 } } } }
  },
/* lsl $frdrrr,$frsr1,$frsr2 */
  {
    MS1_INSN_LSL, "lsl", "lsl", 32,
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR), { { { (1<<MACH_BASE), 0 } } } }
  },
/* lsli $frdr,$frsr1,#$imm16 */
  {
    MS1_INSN_LSLI, "lsli", "lsli", 32,
    { 0|A(USES_FRSR1)|A(USES_FRDR), { { { (1<<MACH_BASE), 0 } } } }
  },
/* lsr $frdrrr,$frsr1,$frsr2 */
  {
    MS1_INSN_LSR, "lsr", "lsr", 32,
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR), { { { (1<<MACH_BASE), 0 } } } }
  },
/* lsri $frdr,$frsr1,#$imm16 */
  {
    MS1_INSN_LSRI, "lsri", "lsri", 32,
    { 0|A(USES_FRSR1)|A(USES_FRDR), { { { (1<<MACH_BASE), 0 } } } }
  },
/* asr $frdrrr,$frsr1,$frsr2 */
  {
    MS1_INSN_ASR, "asr", "asr", 32,
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR), { { { (1<<MACH_BASE), 0 } } } }
  },
/* asri $frdr,$frsr1,#$imm16 */
  {
    MS1_INSN_ASRI, "asri", "asri", 32,
    { 0|A(USES_FRSR1)|A(USES_FRDR), { { { (1<<MACH_BASE), 0 } } } }
  },
/* brlt $frsr1,$frsr2,$imm16o */
  {
    MS1_INSN_BRLT, "brlt", "brlt", 32,
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR)|A(DELAY_SLOT)|A(BR_INSN), { { { (1<<MACH_BASE), 0 } } } }
  },
/* brle $frsr1,$frsr2,$imm16o */
  {
    MS1_INSN_BRLE, "brle", "brle", 32,
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(DELAY_SLOT)|A(BR_INSN), { { { (1<<MACH_BASE), 0 } } } }
  },
/* breq $frsr1,$frsr2,$imm16o */
  {
    MS1_INSN_BREQ, "breq", "breq", 32,
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(DELAY_SLOT)|A(BR_INSN), { { { (1<<MACH_BASE), 0 } } } }
  },
/* brne $frsr1,$frsr2,$imm16o */
  {
    MS1_INSN_BRNE, "brne", "brne", 32,
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(DELAY_SLOT)|A(BR_INSN), { { { (1<<MACH_BASE), 0 } } } }
  },
/* jmp $imm16o */
  {
    MS1_INSN_JMP, "jmp", "jmp", 32,
    { 0|A(BR_INSN)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
  },
/* jal $frdrrr,$frsr1 */
  {
    MS1_INSN_JAL, "jal", "jal", 32,
    { 0|A(JAL_HAZARD)|A(USES_FRSR1)|A(USES_FRDR)|A(BR_INSN)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
  },
/* dbnz $frsr1,$imm16o */
  {
    MS1_INSN_DBNZ, "dbnz", "dbnz", 32,
    { 0|A(USES_FRSR1)|A(DELAY_SLOT)|A(BR_INSN), { { { (1<<MACH_MS1_003)|(1<<MACH_MS2), 0 } } } }
  },
/* ei */
  {
    MS1_INSN_EI, "ei", "ei", 32,
    { 0, { { { (1<<MACH_BASE), 0 } } } }
  },
/* di */
  {
    MS1_INSN_DI, "di", "di", 32,
    { 0, { { { (1<<MACH_BASE), 0 } } } }
  },
/* si $frdrrr */
  {
    MS1_INSN_SI, "si", "si", 32,
    { 0|A(USES_FRDR)|A(BR_INSN)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
  },
/* reti $frsr1 */
  {
    MS1_INSN_RETI, "reti", "reti", 32,
    { 0|A(JAL_HAZARD)|A(USES_FRSR1)|A(BR_INSN)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
  },
/* ldw $frdr,$frsr1,#$imm16 */
  {
    MS1_INSN_LDW, "ldw", "ldw", 32,
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(MEMORY_ACCESS)|A(LOAD_DELAY), { { { (1<<MACH_BASE), 0 } } } }
  },
/* stw $frsr2,$frsr1,#$imm16 */
  {
    MS1_INSN_STW, "stw", "stw", 32,
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(MEMORY_ACCESS), { { { (1<<MACH_BASE), 0 } } } }
  },
/* break */
  {
    MS1_INSN_BREAK, "break", "break", 32,
    { 0, { { { (1<<MACH_BASE), 0 } } } }
  },
/* iflush */
  {
    MS1_INSN_IFLUSH, "iflush", "iflush", 32,
    { 0, { { { (1<<MACH_MS1_003)|(1<<MACH_MS2), 0 } } } }
  },
/* ldctxt $frsr1,$frsr2,#$rc,#$rcnum,#$contnum */
  {
    MS1_INSN_LDCTXT, "ldctxt", "ldctxt", 32,
    { 0, { { { (1<<MACH_MS1), 0 } } } }
  },
/* ldfb $frsr1,$frsr2,#$imm16z */
  {
    MS1_INSN_LDFB, "ldfb", "ldfb", 32,
    { 0, { { { (1<<MACH_MS1), 0 } } } }
  },
/* stfb $frsr1,$frsr2,#$imm16z */
  {
    MS1_INSN_STFB, "stfb", "stfb", 32,
    { 0, { { { (1<<MACH_MS1), 0 } } } }
  },
/* fbcb $frsr1,#$rbbc,#$ball,#$brc,#$rc1,#$cbrb,#$cell,#$dup,#$ctxdisp */
  {
    MS1_INSN_FBCB, "fbcb", "fbcb", 32,
    { 0, { { { (1<<MACH_MS1)|(1<<MACH_MS1_003), 0 } } } }
  },
/* mfbcb $frsr1,#$rbbc,$frsr2,#$rc1,#$cbrb,#$cell,#$dup,#$ctxdisp */
  {
    MS1_INSN_MFBCB, "mfbcb", "mfbcb", 32,
    { 0, { { { (1<<MACH_BASE), 0 } } } }
  },
/* fbcci $frsr1,#$rbbc,#$ball,#$brc,#$fbdisp,#$cell,#$dup,#$ctxdisp */
  {
    MS1_INSN_FBCCI, "fbcci", "fbcci", 32,
    { 0, { { { (1<<MACH_BASE), 0 } } } }
  },
/* fbrci $frsr1,#$rbbc,#$ball,#$brc,#$fbdisp,#$cell,#$dup,#$ctxdisp */
  {
    MS1_INSN_FBRCI, "fbrci", "fbrci", 32,
    { 0, { { { (1<<MACH_BASE), 0 } } } }
  },
/* fbcri $frsr1,#$rbbc,#$ball,#$brc,#$fbdisp,#$cell,#$dup,#$ctxdisp */
  {
    MS1_INSN_FBCRI, "fbcri", "fbcri", 32,
    { 0, { { { (1<<MACH_BASE), 0 } } } }
  },
/* fbrri $frsr1,#$rbbc,#$ball,#$brc,#$fbdisp,#$cell,#$dup,#$ctxdisp */
  {
    MS1_INSN_FBRRI, "fbrri", "fbrri", 32,
    { 0, { { { (1<<MACH_BASE), 0 } } } }
  },
/* mfbcci $frsr1,#$rbbc,$frsr2,#$fbdisp,#$cell,#$dup,#$ctxdisp */
  {
    MS1_INSN_MFBCCI, "mfbcci", "mfbcci", 32,
    { 0, { { { (1<<MACH_BASE), 0 } } } }
  },
/* mfbrci $frsr1,#$rbbc,$frsr2,#$fbdisp,#$cell,#$dup,#$ctxdisp */
  {
    MS1_INSN_MFBRCI, "mfbrci", "mfbrci", 32,
    { 0, { { { (1<<MACH_BASE), 0 } } } }
  },
/* mfbcri $frsr1,#$rbbc,$frsr2,#$fbdisp,#$cell,#$dup,#$ctxdisp */
  {
    MS1_INSN_MFBCRI, "mfbcri", "mfbcri", 32,
    { 0, { { { (1<<MACH_BASE), 0 } } } }
  },
/* mfbrri $frsr1,#$rbbc,$frsr2,#$fbdisp,#$cell,#$dup,#$ctxdisp */
  {
    MS1_INSN_MFBRRI, "mfbrri", "mfbrri", 32,
    { 0, { { { (1<<MACH_BASE), 0 } } } }
  },
/* fbcbdr $frsr1,#$rbbc,$frsr2,#$ball2,#$brc2,#$rc1,#$cbrb,#$cell,#$dup,#$ctxdisp */
  {
    MS1_INSN_FBCBDR, "fbcbdr", "fbcbdr", 32,
    { 0, { { { (1<<MACH_BASE), 0 } } } }
  },
/* rcfbcb #$rbbc,#$type,#$ball,#$brc,#$rownum,#$rc1,#$cbrb,#$cell,#$dup,#$ctxdisp */
  {
    MS1_INSN_RCFBCB, "rcfbcb", "rcfbcb", 32,
    { 0, { { { (1<<MACH_BASE), 0 } } } }
  },
/* mrcfbcb $frsr2,#$rbbc,#$type,#$rownum,#$rc1,#$cbrb,#$cell,#$dup,#$ctxdisp */
  {
    MS1_INSN_MRCFBCB, "mrcfbcb", "mrcfbcb", 32,
    { 0, { { { (1<<MACH_BASE), 0 } } } }
  },
/* cbcast #$mask,#$rc2,#$ctxdisp */
  {
    MS1_INSN_CBCAST, "cbcast", "cbcast", 32,
    { 0, { { { (1<<MACH_BASE), 0 } } } }
  },
/* dupcbcast #$mask,#$cell,#$rc2,#$ctxdisp */
  {
    MS1_INSN_DUPCBCAST, "dupcbcast", "dupcbcast", 32,
    { 0, { { { (1<<MACH_BASE), 0 } } } }
  },
/* wfbi #$bankaddr,#$rownum1,#$cell,#$dup,#$ctxdisp */
  {
    MS1_INSN_WFBI, "wfbi", "wfbi", 32,
    { 0, { { { (1<<MACH_BASE), 0 } } } }
  },
/* wfb $frsr1,$frsr2,#$fbdisp,#$rownum2,#$ctxdisp */
  {
    MS1_INSN_WFB, "wfb", "wfb", 32,
    { 0, { { { (1<<MACH_BASE), 0 } } } }
  },
/* rcrisc $frdrrr,#$rbbc,$frsr1,#$colnum,#$rc1,#$cbrb,#$cell,#$dup,#$ctxdisp */
  {
    MS1_INSN_RCRISC, "rcrisc", "rcrisc", 32,
    { 0, { { { (1<<MACH_BASE), 0 } } } }
  },
/* fbcbinc $frsr1,#$rbbc,#$incamt,#$rc1,#$cbrb,#$cell,#$dup,#$ctxdisp */
  {
    MS1_INSN_FBCBINC, "fbcbinc", "fbcbinc", 32,
    { 0, { { { (1<<MACH_BASE), 0 } } } }
  },
/* rcxmode $frsr2,#$rda,#$wr,#$xmode,#$mask1,#$fbdisp,#$rownum2,#$rc2,#$ctxdisp */
  {
    MS1_INSN_RCXMODE, "rcxmode", "rcxmode", 32,
    { 0, { { { (1<<MACH_BASE), 0 } } } }
  },
/* intlvr $frsr1,#$mode,$frsr2,#$id,#$size */
  {
    MS1_INSN_INTERLEAVER, "interleaver", "intlvr", 32,
    { 0, { { { (1<<MACH_BASE), 0 } } } }
  },
/* wfbinc #$rda,#$wr,#$fbincr,#$ball,#$colnum,#$length,#$rownum1,#$rownum2,#$dup,#$ctxdisp */
  {
    MS1_INSN_WFBINC, "wfbinc", "wfbinc", 32,
    { 0, { { { (1<<MACH_MS1_003)|(1<<MACH_MS2), 0 } } } }
  },
/* mwfbinc $frsr2,#$rda,#$wr,#$fbincr,#$length,#$rownum1,#$rownum2,#$dup,#$ctxdisp */
  {
    MS1_INSN_MWFBINC, "mwfbinc", "mwfbinc", 32,
    { 0, { { { (1<<MACH_MS1_003)|(1<<MACH_MS2), 0 } } } }
  },
/* wfbincr $frsr1,#$rda,#$wr,#$ball,#$colnum,#$length,#$rownum1,#$rownum2,#$dup,#$ctxdisp */
  {
    MS1_INSN_WFBINCR, "wfbincr", "wfbincr", 32,
    { 0, { { { (1<<MACH_MS1_003)|(1<<MACH_MS2), 0 } } } }
  },
/* mwfbincr $frsr1,$frsr2,#$rda,#$wr,#$length,#$rownum1,#$rownum2,#$dup,#$ctxdisp */
  {
    MS1_INSN_MWFBINCR, "mwfbincr", "mwfbincr", 32,
    { 0, { { { (1<<MACH_MS1_003)|(1<<MACH_MS2), 0 } } } }
  },
/* fbcbincs #$perm,#$a23,#$cr,#$cbs,#$incr,#$ccb,#$cdb,#$rownum2,#$dup,#$ctxdisp */
  {
    MS1_INSN_FBCBINCS, "fbcbincs", "fbcbincs", 32,
    { 0, { { { (1<<MACH_MS1_003)|(1<<MACH_MS2), 0 } } } }
  },
/* mfbcbincs $frsr1,#$perm,#$cbs,#$incr,#$ccb,#$cdb,#$rownum2,#$dup,#$ctxdisp */
  {
    MS1_INSN_MFBCBINCS, "mfbcbincs", "mfbcbincs", 32,
    { 0, { { { (1<<MACH_MS1_003)|(1<<MACH_MS2), 0 } } } }
  },
/* fbcbincrs $frsr1,#$perm,#$ball,#$colnum,#$cbx,#$ccb,#$cdb,#$rownum2,#$dup,#$ctxdisp */
  {
    MS1_INSN_FBCBINCRS, "fbcbincrs", "fbcbincrs", 32,
    { 0, { { { (1<<MACH_MS1_003)|(1<<MACH_MS2), 0 } } } }
  },
/* mfbcbincrs $frsr1,$frsr2,#$perm,#$cbx,#$ccb,#$cdb,#$rownum2,#$dup,#$ctxdisp */
  {
    MS1_INSN_MFBCBINCRS, "mfbcbincrs", "mfbcbincrs", 32,
    { 0, { { { (1<<MACH_MS1_003)|(1<<MACH_MS2), 0 } } } }
  },
/* loop $frsr1,$loopsize */
  {
    MS1_INSN_LOOP, "loop", "loop", 32,
    { 0|A(USES_FRSR1)|A(DELAY_SLOT), { { { (1<<MACH_MS2), 0 } } } }
  },
/* loopi #$imm16l,$loopsize */
  {
    MS1_INSN_LOOPI, "loopi", "loopi", 32,
    { 0|A(DELAY_SLOT), { { { (1<<MACH_MS2), 0 } } } }
  },
/* dfbc #$cb1sel,#$cb2sel,#$cb1incr,#$cb2incr,#$rc3,#$rc2,#$ctxdisp */
  {
    MS1_INSN_DFBC, "dfbc", "dfbc", 32,
    { 0, { { { (1<<MACH_MS2), 0 } } } }
  },
/* dwfb #$cb1sel,#$cb2sel,#$cb1incr,#$cb2incr,#$rc2,#$ctxdisp */
  {
    MS1_INSN_DWFB, "dwfb", "dwfb", 32,
    { 0, { { { (1<<MACH_MS2), 0 } } } }
  },
/* fbwfb #$cb1sel,#$cb2sel,#$cb1incr,#$cb2incr,#$rc3,#$rc2,#$ctxdisp */
  {
    MS1_INSN_FBWFB, "fbwfb", "fbwfb", 32,
    { 0, { { { (1<<MACH_MS2), 0 } } } }
  },
/* dfbr #$cb1sel,#$cb2sel,$frsr2,#$length,#$rownum1,#$rownum2,#$rc2,#$ctxdisp */
  {
    MS1_INSN_DFBR, "dfbr", "dfbr", 32,
    { 0|A(USES_FRSR2), { { { (1<<MACH_MS2), 0 } } } }
  },
};

#undef OP
#undef A

/* Initialize anything needed to be done once, before any cpu_open call.  */

static void
init_tables (void)
{
}

static const CGEN_MACH * lookup_mach_via_bfd_name (const CGEN_MACH *, const char *);
static void build_hw_table      (CGEN_CPU_TABLE *);
static void build_ifield_table  (CGEN_CPU_TABLE *);
static void build_operand_table (CGEN_CPU_TABLE *);
static void build_insn_table    (CGEN_CPU_TABLE *);
static void ms1_cgen_rebuild_tables (CGEN_CPU_TABLE *);

/* Subroutine of ms1_cgen_cpu_open to look up a mach via its bfd name.  */

static const CGEN_MACH *
lookup_mach_via_bfd_name (const CGEN_MACH *table, const char *name)
{
  while (table->name)
    {
      if (strcmp (name, table->bfd_name) == 0)
	return table;
      ++table;
    }
  abort ();
}

/* Subroutine of ms1_cgen_cpu_open to build the hardware table.  */

static void
build_hw_table (CGEN_CPU_TABLE *cd)
{
  int i;
  int machs = cd->machs;
  const CGEN_HW_ENTRY *init = & ms1_cgen_hw_table[0];
  /* MAX_HW is only an upper bound on the number of selected entries.
     However each entry is indexed by it's enum so there can be holes in
     the table.  */
  const CGEN_HW_ENTRY **selected =
    (const CGEN_HW_ENTRY **) xmalloc (MAX_HW * sizeof (CGEN_HW_ENTRY *));

  cd->hw_table.init_entries = init;
  cd->hw_table.entry_size = sizeof (CGEN_HW_ENTRY);
  memset (selected, 0, MAX_HW * sizeof (CGEN_HW_ENTRY *));
  /* ??? For now we just use machs to determine which ones we want.  */
  for (i = 0; init[i].name != NULL; ++i)
    if (CGEN_HW_ATTR_VALUE (&init[i], CGEN_HW_MACH)
	& machs)
      selected[init[i].type] = &init[i];
  cd->hw_table.entries = selected;
  cd->hw_table.num_entries = MAX_HW;
}

/* Subroutine of ms1_cgen_cpu_open to build the hardware table.  */

static void
build_ifield_table (CGEN_CPU_TABLE *cd)
{
  cd->ifld_table = & ms1_cgen_ifld_table[0];
}

/* Subroutine of ms1_cgen_cpu_open to build the hardware table.  */

static void
build_operand_table (CGEN_CPU_TABLE *cd)
{
  int i;
  int machs = cd->machs;
  const CGEN_OPERAND *init = & ms1_cgen_operand_table[0];
  /* MAX_OPERANDS is only an upper bound on the number of selected entries.
     However each entry is indexed by it's enum so there can be holes in
     the table.  */
  const CGEN_OPERAND **selected = xmalloc (MAX_OPERANDS * sizeof (* selected));

  cd->operand_table.init_entries = init;
  cd->operand_table.entry_size = sizeof (CGEN_OPERAND);
  memset (selected, 0, MAX_OPERANDS * sizeof (CGEN_OPERAND *));
  /* ??? For now we just use mach to determine which ones we want.  */
  for (i = 0; init[i].name != NULL; ++i)
    if (CGEN_OPERAND_ATTR_VALUE (&init[i], CGEN_OPERAND_MACH)
	& machs)
      selected[init[i].type] = &init[i];
  cd->operand_table.entries = selected;
  cd->operand_table.num_entries = MAX_OPERANDS;
}

/* Subroutine of ms1_cgen_cpu_open to build the hardware table.
   ??? This could leave out insns not supported by the specified mach/isa,
   but that would cause errors like "foo only supported by bar" to become
   "unknown insn", so for now we include all insns and require the app to
   do the checking later.
   ??? On the other hand, parsing of such insns may require their hardware or
   operand elements to be in the table [which they mightn't be].  */

static void
build_insn_table (CGEN_CPU_TABLE *cd)
{
  int i;
  const CGEN_IBASE *ib = & ms1_cgen_insn_table[0];
  CGEN_INSN *insns = xmalloc (MAX_INSNS * sizeof (CGEN_INSN));

  memset (insns, 0, MAX_INSNS * sizeof (CGEN_INSN));
  for (i = 0; i < MAX_INSNS; ++i)
    insns[i].base = &ib[i];
  cd->insn_table.init_entries = insns;
  cd->insn_table.entry_size = sizeof (CGEN_IBASE);
  cd->insn_table.num_init_entries = MAX_INSNS;
}

/* Subroutine of ms1_cgen_cpu_open to rebuild the tables.  */

static void
ms1_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
{
  int i;
  CGEN_BITSET *isas = cd->isas;
  unsigned int machs = cd->machs;

  cd->int_insn_p = CGEN_INT_INSN_P;

  /* Data derived from the isa spec.  */
#define UNSET (CGEN_SIZE_UNKNOWN + 1)
  cd->default_insn_bitsize = UNSET;
  cd->base_insn_bitsize = UNSET;
  cd->min_insn_bitsize = 65535; /* Some ridiculously big number.  */
  cd->max_insn_bitsize = 0;
  for (i = 0; i < MAX_ISAS; ++i)
    if (cgen_bitset_contains (isas, i))
      {
	const CGEN_ISA *isa = & ms1_cgen_isa_table[i];

	/* Default insn sizes of all selected isas must be
	   equal or we set the result to 0, meaning "unknown".  */
	if (cd->default_insn_bitsize == UNSET)
	  cd->default_insn_bitsize = isa->default_insn_bitsize;
	else if (isa->default_insn_bitsize == cd->default_insn_bitsize)
	  ; /* This is ok.  */
	else
	  cd->default_insn_bitsize = CGEN_SIZE_UNKNOWN;

	/* Base insn sizes of all selected isas must be equal
	   or we set the result to 0, meaning "unknown".  */
	if (cd->base_insn_bitsize == UNSET)
	  cd->base_insn_bitsize = isa->base_insn_bitsize;
	else if (isa->base_insn_bitsize == cd->base_insn_bitsize)
	  ; /* This is ok.  */
	else
	  cd->base_insn_bitsize = CGEN_SIZE_UNKNOWN;

	/* Set min,max insn sizes.  */
	if (isa->min_insn_bitsize < cd->min_insn_bitsize)
	  cd->min_insn_bitsize = isa->min_insn_bitsize;
	if (isa->max_insn_bitsize > cd->max_insn_bitsize)
	  cd->max_insn_bitsize = isa->max_insn_bitsize;
      }

  /* Data derived from the mach spec.  */
  for (i = 0; i < MAX_MACHS; ++i)
    if (((1 << i) & machs) != 0)
      {
	const CGEN_MACH *mach = & ms1_cgen_mach_table[i];

	if (mach->insn_chunk_bitsize != 0)
	{
	  if (cd->insn_chunk_bitsize != 0 && cd->insn_chunk_bitsize != mach->insn_chunk_bitsize)
	    {
	      fprintf (stderr, "ms1_cgen_rebuild_tables: conflicting insn-chunk-bitsize values: `%d' vs. `%d'\n",
		       cd->insn_chunk_bitsize, mach->insn_chunk_bitsize);
	      abort ();
	    }

 	  cd->insn_chunk_bitsize = mach->insn_chunk_bitsize;
	}
      }

  /* Determine which hw elements are used by MACH.  */
  build_hw_table (cd);

  /* Build the ifield table.  */
  build_ifield_table (cd);

  /* Determine which operands are used by MACH/ISA.  */
  build_operand_table (cd);

  /* Build the instruction table.  */
  build_insn_table (cd);
}

/* Initialize a cpu table and return a descriptor.
   It's much like opening a file, and must be the first function called.
   The arguments are a set of (type/value) pairs, terminated with
   CGEN_CPU_OPEN_END.

   Currently supported values:
   CGEN_CPU_OPEN_ISAS:    bitmap of values in enum isa_attr
   CGEN_CPU_OPEN_MACHS:   bitmap of values in enum mach_attr
   CGEN_CPU_OPEN_BFDMACH: specify 1 mach using bfd name
   CGEN_CPU_OPEN_ENDIAN:  specify endian choice
   CGEN_CPU_OPEN_END:     terminates arguments

   ??? Simultaneous multiple isas might not make sense, but it's not (yet)
   precluded.

   ??? We only support ISO C stdargs here, not K&R.
   Laziness, plus experiment to see if anything requires K&R - eventually
   K&R will no longer be supported - e.g. GDB is currently trying this.  */

CGEN_CPU_DESC
ms1_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
{
  CGEN_CPU_TABLE *cd = (CGEN_CPU_TABLE *) xmalloc (sizeof (CGEN_CPU_TABLE));
  static int init_p;
  CGEN_BITSET *isas = 0;  /* 0 = "unspecified" */
  unsigned int machs = 0; /* 0 = "unspecified" */
  enum cgen_endian endian = CGEN_ENDIAN_UNKNOWN;
  va_list ap;

  if (! init_p)
    {
      init_tables ();
      init_p = 1;
    }

  memset (cd, 0, sizeof (*cd));

  va_start (ap, arg_type);
  while (arg_type != CGEN_CPU_OPEN_END)
    {
      switch (arg_type)
	{
	case CGEN_CPU_OPEN_ISAS :
	  isas = va_arg (ap, CGEN_BITSET *);
	  break;
	case CGEN_CPU_OPEN_MACHS :
	  machs = va_arg (ap, unsigned int);
	  break;
	case CGEN_CPU_OPEN_BFDMACH :
	  {
	    const char *name = va_arg (ap, const char *);
	    const CGEN_MACH *mach =
	      lookup_mach_via_bfd_name (ms1_cgen_mach_table, name);

	    machs |= 1 << mach->num;
	    break;
	  }
	case CGEN_CPU_OPEN_ENDIAN :
	  endian = va_arg (ap, enum cgen_endian);
	  break;
	default :
	  fprintf (stderr, "ms1_cgen_cpu_open: unsupported argument `%d'\n",
		   arg_type);
	  abort (); /* ??? return NULL? */
	}
      arg_type = va_arg (ap, enum cgen_cpu_open_arg);
    }
  va_end (ap);

  /* Mach unspecified means "all".  */
  if (machs == 0)
    machs = (1 << MAX_MACHS) - 1;
  /* Base mach is always selected.  */
  machs |= 1;
  if (endian == CGEN_ENDIAN_UNKNOWN)
    {
      /* ??? If target has only one, could have a default.  */
      fprintf (stderr, "ms1_cgen_cpu_open: no endianness specified\n");
      abort ();
    }

  cd->isas = cgen_bitset_copy (isas);
  cd->machs = machs;
  cd->endian = endian;
  /* FIXME: for the sparc case we can determine insn-endianness statically.
     The worry here is where both data and insn endian can be independently
     chosen, in which case this function will need another argument.
     Actually, will want to allow for more arguments in the future anyway.  */
  cd->insn_endian = endian;

  /* Table (re)builder.  */
  cd->rebuild_tables = ms1_cgen_rebuild_tables;
  ms1_cgen_rebuild_tables (cd);

  /* Default to not allowing signed overflow.  */
  cd->signed_overflow_ok_p = 0;
  
  return (CGEN_CPU_DESC) cd;
}

/* Cover fn to ms1_cgen_cpu_open to handle the simple case of 1 isa, 1 mach.
   MACH_NAME is the bfd name of the mach.  */

CGEN_CPU_DESC
ms1_cgen_cpu_open_1 (const char *mach_name, enum cgen_endian endian)
{
  return ms1_cgen_cpu_open (CGEN_CPU_OPEN_BFDMACH, mach_name,
			       CGEN_CPU_OPEN_ENDIAN, endian,
			       CGEN_CPU_OPEN_END);
}

/* Close a cpu table.
   ??? This can live in a machine independent file, but there's currently
   no place to put this file (there's no libcgen).  libopcodes is the wrong
   place as some simulator ports use this but they don't use libopcodes.  */

void
ms1_cgen_cpu_close (CGEN_CPU_DESC cd)
{
  unsigned int i;
  const CGEN_INSN *insns;

  if (cd->macro_insn_table.init_entries)
    {
      insns = cd->macro_insn_table.init_entries;
      for (i = 0; i < cd->macro_insn_table.num_init_entries; ++i, ++insns)
	if (CGEN_INSN_RX ((insns)))
	  regfree (CGEN_INSN_RX (insns));
    }

  if (cd->insn_table.init_entries)
    {
      insns = cd->insn_table.init_entries;
      for (i = 0; i < cd->insn_table.num_init_entries; ++i, ++insns)
	if (CGEN_INSN_RX (insns))
	  regfree (CGEN_INSN_RX (insns));
    }  

  if (cd->macro_insn_table.init_entries)
    free ((CGEN_INSN *) cd->macro_insn_table.init_entries);

  if (cd->insn_table.init_entries)
    free ((CGEN_INSN *) cd->insn_table.init_entries);

  if (cd->hw_table.entries)
    free ((CGEN_HW_ENTRY *) cd->hw_table.entries);

  if (cd->operand_table.entries)
    free ((CGEN_HW_ENTRY *) cd->operand_table.entries);

  free (cd);
}

@


1.4
log
@bfd:
	Add ms2.
	* archures.c (bfd_mach_ms2): Define.
	* cpu-ms1.c (arch_info_struct): Add ms2 stanza.
	* elf32-ms1.c (elf32_ms1_machine): Add ms2 case.
	(ms1_elf_merge_private_bfd_data): Remove unused variables.  Add
	correct merging logic, with workaround.
	(ms1_elf_print_private_bfd_data): Add ms2 case.
	* reloc.c (BFD_RELOC_MS1_PCINSN8): Add ms2 specific reloc.
	* libbfd.h: Regenerated.
	* bfd-in2.h: Regenerated.

cpu:
	Add ms2
	* ms1.cpu (ms2, ms2bf): New architecture variant, cpu, machine and
	model.
	(f-uu8, f-uu1, f-imm16l, f-loopo, f-cb1sel, f-cb2sel, f-cb1incr,
	f-cb2incr, f-rc3): New fields.
	(LOOP): New instruction.
	(JAL-HAZARD): New hazard.
	(imm16o, loopsize, imm16l, rc3, cb1sel, cb2sel, cb1incr, cb2incr):
	New operands.
	(mul, muli, dbnz, iflush): Enable for ms2
	(jal, reti): Has JAL-HAZARD.
	(ldctxt, ldfb, stfb): Only ms1.
	(fbcb): Only ms1,ms1-003.
	(wfbinc, mefbinc, wfbincr, mwfbincr, fbcbincs, mfbcbincs,
	fbcbincrs, mfbcbincrs): Enable for ms2.
	(loop, loopu, dfbc, dwfb, fbwfb, dfbr): New ms2 insns.
	* ms1.opc (parse_loopsize): New.
	(parse_imm16): hi16/lo16 relocs are applicable to IMM16L.
	(print_pcrel): New.

gas:
	Add ms2.
	* config/tc-ms1.c (ms1_mach_bitmask): Initialize to MS1.
	(ms1_architectures): Add ms2.
	(md_parse_option): Add ms2.
	(md_show_usage): Add ms2.
	(md_assemble): Add JAL_HAZARD detection logic.
	(md_cgen_lookup_reloc): Add MS1_OPERAND_LOOPSIZE case.
	* doc/c-ms1.texi: New.
	* doc/all.texi: Add MS1.
	* doc/Makefile.am (CPU_DOCS): Add c-ms1.texi.
	* doc/Makefile.in: Rebuilt.
	* doc/Makefile: Rebuilt.

gas/testsuite:
	Add ms2.
	* gas/ms1/allinsn.d: Adjust pcrel disassembly.
	* gas/ms1/errors.exp: Fix target triplet.
	* gas/ms1/ms1-16-003.d: Adjust pcrel disassembly.
	* gas/ms1/ms1-16-003.s: Tweak label.
	* gas/ms1/ms1.exp: Adjust target triplet.  Add ms2 test.
	* gas/ms1/ms2.d, gas/ms1/ms2.s: New.
	* gas/ms1/relocs.d: Adjust expected machine name and pcrel
	disassembly.
	* gas/ms1/relocs.exp: Adjust target triplet.

include:
	Add ms2.
	* elf/ms1.h (EF_MS1_CPU_MS2): New.


opcodes:
	Add ms2.
	* ms1-asm.c, ms1-desc.c, ms1-desc.h, ms1-dis.c, ms1-ibld.c,
	ms1-opc.c, ms1-opc.h: Regenerated.
@
text
@@


1.3
log
@2005-10-28  Dave Brolley  <brolley@@redhat.com>

        * All CGEN-generated sources: Regenerate.

        Contribute the following changes:
        2005-09-19  Dave Brolley  <brolley@@redhat.com>

        * disassemble.c (disassemble_init_for_target): Add 'break' to case for
        bfd_arch_tic4x. Use cgen_bitset_create and cgen_bitset_set for
        bfd_arch_m32c case.

        2005-02-16  Dave Brolley  <brolley@@redhat.com>

        * cgen-dis.in: Rename CGEN_ISA_MASK to CGEN_BITSET. Rename
        cgen_isa_mask_* to cgen_bitset_*.
        * cgen-opc.c: Likewise.

        2003-11-28  Richard Sandiford  <rsandifo@@redhat.com>

        * cgen-dis.in (print_insn_@@arch@@): Fix comparison with cached isas.
        * *-dis.c: Regenerate.

        2003-06-05  DJ Delorie  <dj@@redhat.com>

        * cgen-dis.in (print_insn_@@arch@@): Copy prev_isas, don't assign
        it, as it may point to a reused buffer. Set prev_isas when we
        change cpus.

        2002-12-13  Dave Brolley  <brolley@@redhat.com>

        * cgen-opc.c (cgen_isa_mask_create): New support function for
        CGEN_ISA_MASK.
        (cgen_isa_mask_init): Ditto.
        (cgen_isa_mask_clear): Ditto.
        (cgen_isa_mask_add): Ditto.
        (cgen_isa_mask_set): Ditto.
        (cgen_isa_supported): Ditto.
        (cgen_isa_mask_compare): Ditto.
        (cgen_isa_mask_intersection): Ditto.
        (cgen_isa_mask_copy): Ditto.
        (cgen_isa_mask_combine): Ditto.
        * cgen-dis.in (libiberty.h): #include it.
        (isas): Renamed from 'isa' and now (CGEN_ISA_MASK *).
        (print_insn_@@arch@@): Use CGEN_ISA_MASK and support functions.
        * Makefile.am (CGENDEPS): Add utils-cgen.scm and attrs.scm.
        * Makefile.in: Regenerated.
@
text
@d51 1
d117 1
d138 1
d236 1
d238 1
d288 7
d358 1
a358 1
    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
d519 28
d614 1
a614 1
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR)|A(AL_INSN), { { { (1<<MACH_MS1_003), 0 } } } }
d619 1
a619 1
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(AL_INSN), { { { (1<<MACH_MS1_003), 0 } } } }
d749 1
a749 1
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(BR_INSN)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
d754 1
a754 1
    { 0|A(USES_FRSR1)|A(DELAY_SLOT)|A(BR_INSN), { { { (1<<MACH_MS1_003), 0 } } } }
d774 1
a774 1
    { 0|A(USES_FRSR1)|A(BR_INSN)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
d794 1
a794 1
    { 0, { { { (1<<MACH_MS1_003), 0 } } } }
d799 1
a799 1
    { 0, { { { (1<<MACH_BASE), 0 } } } }
d804 1
a804 1
    { 0, { { { (1<<MACH_BASE), 0 } } } }
d809 1
a809 1
    { 0, { { { (1<<MACH_BASE), 0 } } } }
d814 1
a814 1
    { 0, { { { (1<<MACH_BASE), 0 } } } }
d919 1
a919 1
    { 0, { { { (1<<MACH_MS1_003), 0 } } } }
d924 1
a924 1
    { 0, { { { (1<<MACH_MS1_003), 0 } } } }
d929 1
a929 1
    { 0, { { { (1<<MACH_MS1_003), 0 } } } }
d934 1
a934 1
    { 0, { { { (1<<MACH_MS1_003), 0 } } } }
d939 1
a939 1
    { 0, { { { (1<<MACH_MS1_003), 0 } } } }
d944 1
a944 1
    { 0, { { { (1<<MACH_MS1_003), 0 } } } }
d949 1
a949 1
    { 0, { { { (1<<MACH_MS1_003), 0 } } } }
d954 31
a984 1
    { 0, { { { (1<<MACH_MS1_003), 0 } } } }
@


1.2
log
@Update function declarations to ISO C90 formatting
@
text
@d141 2
a142 2
  { "DUP", 1, {0, {0}}, 0, 0 },
  { "XX", 0, {0, {0}}, 0, 0 }
d154 20
a173 20
  { "R0", 0, {0, {0}}, 0, 0 },
  { "R1", 1, {0, {0}}, 0, 0 },
  { "R2", 2, {0, {0}}, 0, 0 },
  { "R3", 3, {0, {0}}, 0, 0 },
  { "R4", 4, {0, {0}}, 0, 0 },
  { "R5", 5, {0, {0}}, 0, 0 },
  { "R6", 6, {0, {0}}, 0, 0 },
  { "R7", 7, {0, {0}}, 0, 0 },
  { "R8", 8, {0, {0}}, 0, 0 },
  { "R9", 9, {0, {0}}, 0, 0 },
  { "R10", 10, {0, {0}}, 0, 0 },
  { "R11", 11, {0, {0}}, 0, 0 },
  { "R12", 12, {0, {0}}, 0, 0 },
  { "fp", 12, {0, {0}}, 0, 0 },
  { "R13", 13, {0, {0}}, 0, 0 },
  { "sp", 13, {0, {0}}, 0, 0 },
  { "R14", 14, {0, {0}}, 0, 0 },
  { "ra", 14, {0, {0}}, 0, 0 },
  { "R15", 15, {0, {0}}, 0, 0 },
  { "ira", 15, {0, {0}}, 0, 0 }
d194 8
a201 8
  { "h-memory", HW_H_MEMORY, CGEN_ASM_NONE, 0, { 0, { (1<<MACH_BASE) } } },
  { "h-sint", HW_H_SINT, CGEN_ASM_NONE, 0, { 0, { (1<<MACH_BASE) } } },
  { "h-uint", HW_H_UINT, CGEN_ASM_NONE, 0, { 0, { (1<<MACH_BASE) } } },
  { "h-addr", HW_H_ADDR, CGEN_ASM_NONE, 0, { 0, { (1<<MACH_BASE) } } },
  { "h-iaddr", HW_H_IADDR, CGEN_ASM_NONE, 0, { 0, { (1<<MACH_BASE) } } },
  { "h-spr", HW_H_SPR, CGEN_ASM_KEYWORD, (PTR) & ms1_cgen_opval_h_spr, { 0, { (1<<MACH_BASE) } } },
  { "h-pc", HW_H_PC, CGEN_ASM_NONE, 0, { 0|A(PROFILE)|A(PC), { (1<<MACH_BASE) } } },
  { 0, 0, CGEN_ASM_NONE, 0, {0, {0}} }
d217 70
a286 70
  { MS1_F_NIL, "f-nil", 0, 0, 0, 0, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_ANYOF, "f-anyof", 0, 0, 0, 0, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_MSYS, "f-msys", 0, 32, 31, 1, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_OPC, "f-opc", 0, 32, 30, 6, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_IMM, "f-imm", 0, 32, 24, 1, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_UU24, "f-uu24", 0, 32, 23, 24, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_SR1, "f-sr1", 0, 32, 23, 4, { 0|A(ABS_ADDR), { (1<<MACH_BASE) } }  },
  { MS1_F_SR2, "f-sr2", 0, 32, 19, 4, { 0|A(ABS_ADDR), { (1<<MACH_BASE) } }  },
  { MS1_F_DR, "f-dr", 0, 32, 19, 4, { 0|A(ABS_ADDR), { (1<<MACH_BASE) } }  },
  { MS1_F_DRRR, "f-drrr", 0, 32, 15, 4, { 0|A(ABS_ADDR), { (1<<MACH_BASE) } }  },
  { MS1_F_IMM16U, "f-imm16u", 0, 32, 15, 16, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_IMM16S, "f-imm16s", 0, 32, 15, 16, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_IMM16A, "f-imm16a", 0, 32, 15, 16, { 0|A(PCREL_ADDR), { (1<<MACH_BASE) } }  },
  { MS1_F_UU4A, "f-uu4a", 0, 32, 19, 4, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_UU4B, "f-uu4b", 0, 32, 23, 4, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_UU12, "f-uu12", 0, 32, 11, 12, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_UU16, "f-uu16", 0, 32, 15, 16, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_MSOPC, "f-msopc", 0, 32, 30, 5, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_UU_26_25, "f-uu-26-25", 0, 32, 25, 26, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_MASK, "f-mask", 0, 32, 25, 16, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_BANKADDR, "f-bankaddr", 0, 32, 25, 13, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_RDA, "f-rda", 0, 32, 25, 1, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_UU_2_25, "f-uu-2-25", 0, 32, 25, 2, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_RBBC, "f-rbbc", 0, 32, 25, 2, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_PERM, "f-perm", 0, 32, 25, 2, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_MODE, "f-mode", 0, 32, 25, 2, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_UU_1_24, "f-uu-1-24", 0, 32, 24, 1, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_WR, "f-wr", 0, 32, 24, 1, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_FBINCR, "f-fbincr", 0, 32, 23, 4, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_UU_2_23, "f-uu-2-23", 0, 32, 23, 2, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_XMODE, "f-xmode", 0, 32, 23, 1, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_A23, "f-a23", 0, 32, 23, 1, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_MASK1, "f-mask1", 0, 32, 22, 3, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_CR, "f-cr", 0, 32, 22, 3, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_TYPE, "f-type", 0, 32, 21, 2, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_INCAMT, "f-incamt", 0, 32, 19, 8, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_CBS, "f-cbs", 0, 32, 19, 2, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_UU_1_19, "f-uu-1-19", 0, 32, 19, 1, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_BALL, "f-ball", 0, 32, 19, 1, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_COLNUM, "f-colnum", 0, 32, 18, 3, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_BRC, "f-brc", 0, 32, 18, 3, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_INCR, "f-incr", 0, 32, 17, 6, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_FBDISP, "f-fbdisp", 0, 32, 15, 6, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_UU_4_15, "f-uu-4-15", 0, 32, 15, 4, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_LENGTH, "f-length", 0, 32, 15, 3, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_UU_1_15, "f-uu-1-15", 0, 32, 15, 1, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_RC, "f-rc", 0, 32, 15, 1, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_RCNUM, "f-rcnum", 0, 32, 14, 3, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_ROWNUM, "f-rownum", 0, 32, 14, 3, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_CBX, "f-cbx", 0, 32, 14, 3, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_ID, "f-id", 0, 32, 14, 1, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_SIZE, "f-size", 0, 32, 13, 14, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_ROWNUM1, "f-rownum1", 0, 32, 12, 3, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_UU_3_11, "f-uu-3-11", 0, 32, 11, 3, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_RC1, "f-rc1", 0, 32, 11, 1, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_CCB, "f-ccb", 0, 32, 11, 1, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_CBRB, "f-cbrb", 0, 32, 10, 1, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_CDB, "f-cdb", 0, 32, 10, 1, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_ROWNUM2, "f-rownum2", 0, 32, 9, 3, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_CELL, "f-cell", 0, 32, 9, 3, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_UU_3_9, "f-uu-3-9", 0, 32, 9, 3, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_CONTNUM, "f-contnum", 0, 32, 8, 9, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_UU_1_6, "f-uu-1-6", 0, 32, 6, 1, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_DUP, "f-dup", 0, 32, 6, 1, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_RC2, "f-rc2", 0, 32, 6, 1, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_CTXDISP, "f-ctxdisp", 0, 32, 5, 6, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_MSYSFRSR2, "f-msysfrsr2", 0, 32, 19, 4, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_BRC2, "f-brc2", 0, 32, 14, 3, { 0, { (1<<MACH_BASE) } }  },
  { MS1_F_BALL2, "f-ball2", 0, 32, 15, 1, { 0, { (1<<MACH_BASE) } }  },
  { 0, 0, 0, 0, 0, 0, {0, {0}} }
d318 1
a318 1
    { 0|A(SEM_ONLY), { (1<<MACH_BASE) } }  },
d322 1
a322 1
    { 0|A(ABS_ADDR), { (1<<MACH_BASE) } }  },
d326 1
a326 1
    { 0|A(ABS_ADDR), { (1<<MACH_BASE) } }  },
d330 1
a330 1
    { 0|A(ABS_ADDR), { (1<<MACH_BASE) } }  },
d334 1
a334 1
    { 0|A(ABS_ADDR), { (1<<MACH_BASE) } }  },
d338 1
a338 1
    { 0, { (1<<MACH_BASE) } }  },
d342 1
a342 1
    { 0, { (1<<MACH_BASE) } }  },
d346 1
a346 1
    { 0, { (1<<MACH_BASE) } }  },
d350 1
a350 1
    { 0, { (1<<MACH_BASE) } }  },
d354 1
a354 1
    { 0, { (1<<MACH_BASE) } }  },
d358 1
a358 1
    { 0, { (1<<MACH_BASE) } }  },
d362 1
a362 1
    { 0, { (1<<MACH_BASE) } }  },
d366 1
a366 1
    { 0, { (1<<MACH_BASE) } }  },
d370 1
a370 1
    { 0, { (1<<MACH_BASE) } }  },
d374 1
a374 1
    { 0, { (1<<MACH_BASE) } }  },
d378 1
a378 1
    { 0, { (1<<MACH_BASE) } }  },
d382 1
a382 1
    { 0, { (1<<MACH_BASE) } }  },
d386 1
a386 1
    { 0, { (1<<MACH_BASE) } }  },
d390 1
a390 1
    { 0, { (1<<MACH_BASE) } }  },
d394 1
a394 1
    { 0, { (1<<MACH_BASE) } }  },
d398 1
a398 1
    { 0, { (1<<MACH_BASE) } }  },
d402 1
a402 1
    { 0, { (1<<MACH_BASE) } }  },
d406 1
a406 1
    { 0, { (1<<MACH_BASE) } }  },
d410 1
a410 1
    { 0, { (1<<MACH_BASE) } }  },
d414 1
a414 1
    { 0, { (1<<MACH_BASE) } }  },
d418 1
a418 1
    { 0, { (1<<MACH_BASE) } }  },
d422 1
a422 1
    { 0, { (1<<MACH_BASE) } }  },
d426 1
a426 1
    { 0, { (1<<MACH_BASE) } }  },
d430 1
a430 1
    { 0, { (1<<MACH_BASE) } }  },
d434 1
a434 1
    { 0, { (1<<MACH_BASE) } }  },
d438 1
a438 1
    { 0, { (1<<MACH_BASE) } }  },
d442 1
a442 1
    { 0, { (1<<MACH_BASE) } }  },
d446 1
a446 1
    { 0, { (1<<MACH_BASE) } }  },
d450 1
a450 1
    { 0, { (1<<MACH_BASE) } }  },
d454 1
a454 1
    { 0, { (1<<MACH_BASE) } }  },
d458 1
a458 1
    { 0, { (1<<MACH_BASE) } }  },
d462 1
a462 1
    { 0, { (1<<MACH_BASE) } }  },
d466 1
a466 1
    { 0, { (1<<MACH_BASE) } }  },
d470 1
a470 1
    { 0, { (1<<MACH_BASE) } }  },
d474 1
a474 1
    { 0, { (1<<MACH_BASE) } }  },
d478 1
a478 1
    { 0, { (1<<MACH_BASE) } }  },
d482 1
a482 1
    { 0, { (1<<MACH_BASE) } }  },
d486 1
a486 1
    { 0, { (1<<MACH_BASE) } }  },
d490 1
a490 1
    { 0, { (1<<MACH_BASE) } }  },
d494 1
a494 1
    { 0, { (1<<MACH_BASE) } }  },
d498 1
a498 1
    { 0, { (1<<MACH_BASE) } }  },
d502 1
a502 1
    { 0, { (1<<MACH_BASE) } }  },
d506 1
a506 1
    { 0, { (1<<MACH_BASE) } }  },
d510 1
a510 1
    { 0, { 0 } } }
d530 1
a530 1
  { 0, 0, 0, 0, {0, {0}} },
d534 1
a534 1
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR)|A(AL_INSN), { (1<<MACH_BASE) } }
d539 1
a539 1
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR)|A(AL_INSN), { (1<<MACH_BASE) } }
d544 1
a544 1
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(AL_INSN), { (1<<MACH_BASE) } }
d549 1
a549 1
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(AL_INSN), { (1<<MACH_BASE) } }
d554 1
a554 1
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR)|A(AL_INSN), { (1<<MACH_BASE) } }
d559 1
a559 1
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR)|A(AL_INSN), { (1<<MACH_BASE) } }
d564 1
a564 1
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(AL_INSN), { (1<<MACH_BASE) } }
d569 1
a569 1
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(AL_INSN), { (1<<MACH_BASE) } }
d574 1
a574 1
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR)|A(AL_INSN), { (1<<MACH_MS1_003) } }
d579 1
a579 1
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(AL_INSN), { (1<<MACH_MS1_003) } }
d584 1
a584 1
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR)|A(AL_INSN), { (1<<MACH_BASE) } }
d589 1
a589 1
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(AL_INSN), { (1<<MACH_BASE) } }
d594 1
a594 1
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR)|A(AL_INSN), { (1<<MACH_BASE) } }
d599 1
a599 1
    { 0, { (1<<MACH_BASE) } }
d604 1
a604 1
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(AL_INSN), { (1<<MACH_BASE) } }
d609 1
a609 1
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR)|A(AL_INSN), { (1<<MACH_BASE) } }
d614 1
a614 1
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(AL_INSN), { (1<<MACH_BASE) } }
d619 1
a619 1
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR)|A(AL_INSN), { (1<<MACH_BASE) } }
d624 1
a624 1
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(AL_INSN), { (1<<MACH_BASE) } }
d629 1
a629 1
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR)|A(AL_INSN), { (1<<MACH_BASE) } }
d634 1
a634 1
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(AL_INSN), { (1<<MACH_BASE) } }
d639 1
a639 1
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR)|A(AL_INSN), { (1<<MACH_BASE) } }
d644 1
a644 1
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(AL_INSN), { (1<<MACH_BASE) } }
d649 1
a649 1
    { 0|A(USES_FRDR)|A(AL_INSN), { (1<<MACH_BASE) } }
d654 1
a654 1
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR), { (1<<MACH_BASE) } }
d659 1
a659 1
    { 0|A(USES_FRSR1)|A(USES_FRDR), { (1<<MACH_BASE) } }
d664 1
a664 1
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR), { (1<<MACH_BASE) } }
d669 1
a669 1
    { 0|A(USES_FRSR1)|A(USES_FRDR), { (1<<MACH_BASE) } }
d674 1
a674 1
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR), { (1<<MACH_BASE) } }
d679 1
a679 1
    { 0|A(USES_FRSR1)|A(USES_FRDR), { (1<<MACH_BASE) } }
d684 1
a684 1
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(USES_FRDRRR)|A(DELAY_SLOT)|A(BR_INSN), { (1<<MACH_BASE) } }
d689 1
a689 1
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(DELAY_SLOT)|A(BR_INSN), { (1<<MACH_BASE) } }
d694 1
a694 1
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(DELAY_SLOT)|A(BR_INSN), { (1<<MACH_BASE) } }
d699 1
a699 1
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(DELAY_SLOT)|A(BR_INSN), { (1<<MACH_BASE) } }
d704 1
a704 1
    { 0|A(BR_INSN)|A(DELAY_SLOT), { (1<<MACH_BASE) } }
d709 1
a709 1
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(BR_INSN)|A(DELAY_SLOT), { (1<<MACH_BASE) } }
d714 1
a714 1
    { 0|A(USES_FRSR1)|A(DELAY_SLOT)|A(BR_INSN), { (1<<MACH_MS1_003) } }
d719 1
a719 1
    { 0, { (1<<MACH_BASE) } }
d724 1
a724 1
    { 0, { (1<<MACH_BASE) } }
d729 1
a729 1
    { 0|A(USES_FRDR)|A(BR_INSN)|A(DELAY_SLOT), { (1<<MACH_BASE) } }
d734 1
a734 1
    { 0|A(USES_FRSR1)|A(BR_INSN)|A(DELAY_SLOT), { (1<<MACH_BASE) } }
d739 1
a739 1
    { 0|A(USES_FRSR1)|A(USES_FRDR)|A(MEMORY_ACCESS)|A(LOAD_DELAY), { (1<<MACH_BASE) } }
d744 1
a744 1
    { 0|A(USES_FRSR2)|A(USES_FRSR1)|A(MEMORY_ACCESS), { (1<<MACH_BASE) } }
d749 1
a749 1
    { 0, { (1<<MACH_BASE) } }
d754 1
a754 1
    { 0, { (1<<MACH_MS1_003) } }
d759 1
a759 1
    { 0, { (1<<MACH_BASE) } }
d764 1
a764 1
    { 0, { (1<<MACH_BASE) } }
d769 1
a769 1
    { 0, { (1<<MACH_BASE) } }
d774 1
a774 1
    { 0, { (1<<MACH_BASE) } }
d779 1
a779 1
    { 0, { (1<<MACH_BASE) } }
d784 1
a784 1
    { 0, { (1<<MACH_BASE) } }
d789 1
a789 1
    { 0, { (1<<MACH_BASE) } }
d794 1
a794 1
    { 0, { (1<<MACH_BASE) } }
d799 1
a799 1
    { 0, { (1<<MACH_BASE) } }
d804 1
a804 1
    { 0, { (1<<MACH_BASE) } }
d809 1
a809 1
    { 0, { (1<<MACH_BASE) } }
d814 1
a814 1
    { 0, { (1<<MACH_BASE) } }
d819 1
a819 1
    { 0, { (1<<MACH_BASE) } }
d824 1
a824 1
    { 0, { (1<<MACH_BASE) } }
d829 1
a829 1
    { 0, { (1<<MACH_BASE) } }
d834 1
a834 1
    { 0, { (1<<MACH_BASE) } }
d839 1
a839 1
    { 0, { (1<<MACH_BASE) } }
d844 1
a844 1
    { 0, { (1<<MACH_BASE) } }
d849 1
a849 1
    { 0, { (1<<MACH_BASE) } }
d854 1
a854 1
    { 0, { (1<<MACH_BASE) } }
d859 1
a859 1
    { 0, { (1<<MACH_BASE) } }
d864 1
a864 1
    { 0, { (1<<MACH_BASE) } }
d869 1
a869 1
    { 0, { (1<<MACH_BASE) } }
d874 1
a874 1
    { 0, { (1<<MACH_BASE) } }
d879 1
a879 1
    { 0, { (1<<MACH_MS1_003) } }
d884 1
a884 1
    { 0, { (1<<MACH_MS1_003) } }
d889 1
a889 1
    { 0, { (1<<MACH_MS1_003) } }
d894 1
a894 1
    { 0, { (1<<MACH_MS1_003) } }
d899 1
a899 1
    { 0, { (1<<MACH_MS1_003) } }
d904 1
a904 1
    { 0, { (1<<MACH_MS1_003) } }
d909 1
a909 1
    { 0, { (1<<MACH_MS1_003) } }
d914 1
a914 1
    { 0, { (1<<MACH_MS1_003) } }
d1037 1
a1037 1
  unsigned int isas = cd->isas;
d1049 1
a1049 1
    if (((1 << i) & isas) != 0)
d1134 1
a1134 1
  unsigned int isas = 0;  /* 0 = "unspecified" */
d1153 1
a1153 1
	  isas = va_arg (ap, unsigned int);
a1183 3
  /* ISA unspecified means "all".  */
  if (isas == 0)
    isas = (1 << MAX_ISAS) - 1;
d1191 1
a1191 1
  cd->isas = isas;
@


1.1
log
@2005-06-15  Dave Brolley  <brolley@@redhat.com>

        Contribute Morpho ms1 on behalf of Red Hat
        * ms1-asm.c, ms1-desc.c, ms1-dis.c, ms1-ibld.c, ms1-opc.c,
        ms1-opc.h: New files, Morpho ms1 target.

        2004-05-14  Stan Cox  <scox@@redhat.com>

        * disassemble.c (ARCH_ms1): Define.
        (disassembler): Handle bfd_arch_ms1

        2004-05-13  Michael Snyder  <msnyder@@redhat.com>

        * Makefile.am, Makefile.in: Add ms1 target.
        * configure.in: Ditto.
@
text
@a921 1
static void init_tables PARAMS ((void));
d924 1
a924 1
init_tables ()
d928 6
a933 7
static const CGEN_MACH * lookup_mach_via_bfd_name
  PARAMS ((const CGEN_MACH *, const char *));
static void build_hw_table  PARAMS ((CGEN_CPU_TABLE *));
static void build_ifield_table  PARAMS ((CGEN_CPU_TABLE *));
static void build_operand_table PARAMS ((CGEN_CPU_TABLE *));
static void build_insn_table    PARAMS ((CGEN_CPU_TABLE *));
static void ms1_cgen_rebuild_tables PARAMS ((CGEN_CPU_TABLE *));
d938 1
a938 3
lookup_mach_via_bfd_name (table, name)
     const CGEN_MACH *table;
     const char *name;
d952 1
a952 2
build_hw_table (cd)
     CGEN_CPU_TABLE *cd;
d978 1
a978 2
build_ifield_table (cd)
     CGEN_CPU_TABLE *cd;
d986 1
a986 2
build_operand_table (cd)
     CGEN_CPU_TABLE *cd;
d994 1
a994 2
  const CGEN_OPERAND **selected =
    (const CGEN_OPERAND **) xmalloc (MAX_OPERANDS * sizeof (CGEN_OPERAND *));
d1017 1
a1017 2
build_insn_table (cd)
     CGEN_CPU_TABLE *cd;
d1021 1
a1021 1
  CGEN_INSN *insns = (CGEN_INSN *) xmalloc (MAX_INSNS * sizeof (CGEN_INSN));
d1034 1
a1034 2
ms1_cgen_rebuild_tables (cd)
     CGEN_CPU_TABLE *cd;
d1046 1
a1046 1
  cd->min_insn_bitsize = 65535; /* some ridiculously big number */
d1058 1
a1058 1
	  ; /* this is ok */
d1067 1
a1067 1
	  ; /* this is ok */
d1179 1
a1179 1
  /* mach unspecified means "all" */
d1182 1
a1182 1
  /* base mach is always selected */
d1184 1
a1184 1
  /* isa unspecified means "all" */
d1217 1
a1217 3
ms1_cgen_cpu_open_1 (mach_name, endian)
     const char *mach_name;
     enum cgen_endian endian;
d1230 1
a1230 2
ms1_cgen_cpu_close (cd)
     CGEN_CPU_DESC cd;
d1239 2
a1240 4
	{
	  if (CGEN_INSN_RX ((insns)))
	    regfree (CGEN_INSN_RX (insns));
	}
d1247 3
a1249 7
	{
	  if (CGEN_INSN_RX (insns))
	    regfree (CGEN_INSN_RX (insns));
	}
    }

  
@

