head	1.15;
access;
symbols
	sid-snapshot-20180601:1.15
	sid-snapshot-20180501:1.15
	sid-snapshot-20180401:1.15
	sid-snapshot-20180301:1.15
	sid-snapshot-20180201:1.15
	sid-snapshot-20180101:1.15
	sid-snapshot-20171201:1.15
	sid-snapshot-20171101:1.15
	sid-snapshot-20171001:1.15
	sid-snapshot-20170901:1.15
	sid-snapshot-20170801:1.15
	sid-snapshot-20170701:1.15
	sid-snapshot-20170601:1.15
	sid-snapshot-20170501:1.15
	sid-snapshot-20170401:1.15
	sid-snapshot-20170301:1.15
	sid-snapshot-20170201:1.15
	sid-snapshot-20170101:1.15
	sid-snapshot-20161201:1.15
	sid-snapshot-20161101:1.15
	sid-snapshot-20160901:1.15
	sid-snapshot-20160801:1.15
	sid-snapshot-20160701:1.15
	sid-snapshot-20160601:1.15
	sid-snapshot-20160501:1.15
	sid-snapshot-20160401:1.15
	sid-snapshot-20160301:1.15
	sid-snapshot-20160201:1.15
	sid-snapshot-20160101:1.15
	sid-snapshot-20151201:1.15
	sid-snapshot-20151101:1.15
	sid-snapshot-20151001:1.15
	sid-snapshot-20150901:1.15
	sid-snapshot-20150801:1.15
	sid-snapshot-20150701:1.15
	sid-snapshot-20150601:1.15
	sid-snapshot-20150501:1.15
	sid-snapshot-20150401:1.15
	sid-snapshot-20150301:1.15
	sid-snapshot-20150201:1.15
	sid-snapshot-20150101:1.15
	sid-snapshot-20141201:1.15
	sid-snapshot-20141101:1.15
	sid-snapshot-20141001:1.15
	sid-snapshot-20140901:1.15
	sid-snapshot-20140801:1.15
	sid-snapshot-20140701:1.15
	sid-snapshot-20140601:1.15
	sid-snapshot-20140501:1.15
	sid-snapshot-20140401:1.15
	sid-snapshot-20140301:1.15
	sid-snapshot-20140201:1.15
	sid-snapshot-20140101:1.15
	sid-snapshot-20131201:1.15
	sid-snapshot-20131101:1.15
	sid-snapshot-20131001:1.15
	binutils-2_24-branch:1.15.0.8
	binutils-2_24-branchpoint:1.15
	binutils-2_21_1:1.13
	sid-snapshot-20130901:1.15
	gdb_7_6_1-2013-08-30-release:1.15
	sid-snapshot-20130801:1.15
	sid-snapshot-20130701:1.15
	sid-snapshot-20130601:1.15
	sid-snapshot-20130501:1.15
	gdb_7_6-2013-04-26-release:1.15
	sid-snapshot-20130401:1.15
	binutils-2_23_2:1.15
	gdb_7_6-branch:1.15.0.6
	gdb_7_6-2013-03-12-branchpoint:1.15
	sid-snapshot-20130301:1.15
	sid-snapshot-20130201:1.15
	sid-snapshot-20130101:1.15
	sid-snapshot-20121201:1.15
	gdb_7_5_1-2012-11-29-release:1.15
	binutils-2_23_1:1.15
	sid-snapshot-20121101:1.15
	binutils-2_23:1.15
	sid-snapshot-20121001:1.15
	sid-snapshot-20120901:1.15
	gdb_7_5-2012-08-17-release:1.15
	sid-snapshot-20120801:1.15
	binutils-2_23-branch:1.15.0.4
	binutils-2_23-branchpoint:1.15
	gdb_7_5-branch:1.15.0.2
	gdb_7_5-2012-07-18-branchpoint:1.15
	sid-snapshot-20120701:1.15
	sid-snapshot-20120601:1.15
	sid-snapshot-20120501:1.13
	binutils-2_22_branch:1.13.0.18
	gdb_7_4_1-2012-04-26-release:1.13
	sid-snapshot-20120401:1.13
	sid-snapshot-20120301:1.13
	sid-snapshot-20120201:1.13
	gdb_7_4-2012-01-24-release:1.13
	sid-snapshot-20120101:1.13
	gdb_7_4-branch:1.13.0.16
	gdb_7_4-2011-12-13-branchpoint:1.13
	sid-snapshot-20111201:1.13
	binutils-2_22:1.13
	sid-snapshot-20111101:1.13
	sid-snapshot-20111001:1.13
	binutils-2_22-branch:1.13.0.14
	binutils-2_22-branchpoint:1.13
	gdb_7_3_1-2011-09-04-release:1.13
	sid-snapshot-20110901:1.13
	sid-snapshot-20110801:1.13
	gdb_7_3-2011-07-26-release:1.13
	sid-snapshot-20110701:1.13
	sid-snapshot-20110601:1.13
	sid-snapshot-20110501:1.13
	gdb_7_3-branch:1.13.0.12
	gdb_7_3-2011-04-01-branchpoint:1.13
	sid-snapshot-20110401:1.13
	sid-snapshot-20110301:1.13
	sid-snapshot-20110201:1.13
	sid-snapshot-20110101:1.13
	binutils-2_21:1.13
	sid-snapshot-20101201:1.13
	binutils-2_21-branch:1.13.0.10
	binutils-2_21-branchpoint:1.13
	sid-snapshot-20101101:1.13
	sid-snapshot-20101001:1.13
	binutils-2_20_1:1.13
	gdb_7_2-2010-09-02-release:1.13
	sid-snapshot-20100901:1.13
	sid-snapshot-20100801:1.13
	gdb_7_2-branch:1.13.0.8
	gdb_7_2-2010-07-07-branchpoint:1.13
	sid-snapshot-20100701:1.13
	sid-snapshot-20100601:1.13
	sid-snapshot-20100501:1.13
	sid-snapshot-20100401:1.13
	gdb_7_1-2010-03-18-release:1.13
	sid-snapshot-20100301:1.13
	gdb_7_1-branch:1.13.0.6
	gdb_7_1-2010-02-18-branchpoint:1.13
	sid-snapshot-20100201:1.13
	sid-snapshot-20100101:1.13
	gdb_7_0_1-2009-12-22-release:1.13
	sid-snapshot-20091201:1.13
	sid-snapshot-20091101:1.13
	binutils-2_20:1.13
	gdb_7_0-2009-10-06-release:1.13
	sid-snapshot-20091001:1.13
	gdb_7_0-branch:1.13.0.4
	gdb_7_0-2009-09-16-branchpoint:1.13
	arc-sim-20090309:1.12
	binutils-arc-20081103-branch:1.12.0.30
	binutils-arc-20081103-branchpoint:1.12
	binutils-2_20-branch:1.13.0.2
	binutils-2_20-branchpoint:1.13
	sid-snapshot-20090901:1.12
	sid-snapshot-20090801:1.12
	msnyder-checkpoint-072509-branch:1.12.0.28
	msnyder-checkpoint-072509-branchpoint:1.12
	sid-snapshot-20090701:1.12
	dje-cgen-play1-branch:1.12.0.26
	dje-cgen-play1-branchpoint:1.12
	sid-snapshot-20090601:1.12
	sid-snapshot-20090501:1.12
	sid-snapshot-20090401:1.12
	arc-20081103-branch:1.12.0.24
	arc-20081103-branchpoint:1.12
	arc-insight_6_8-branch:1.12.0.22
	arc-insight_6_8-branchpoint:1.12
	insight_6_8-branch:1.12.0.20
	insight_6_8-branchpoint:1.12
	sid-snapshot-20090301:1.12
	binutils-2_19_1:1.12
	sid-snapshot-20090201:1.12
	sid-snapshot-20090101:1.12
	reverse-20081226-branch:1.12.0.18
	reverse-20081226-branchpoint:1.12
	sid-snapshot-20081201:1.12
	multiprocess-20081120-branch:1.12.0.16
	multiprocess-20081120-branchpoint:1.12
	sid-snapshot-20081101:1.12
	binutils-2_19:1.12
	sid-snapshot-20081001:1.12
	reverse-20080930-branch:1.12.0.14
	reverse-20080930-branchpoint:1.12
	binutils-2_19-branch:1.12.0.12
	binutils-2_19-branchpoint:1.12
	sid-snapshot-20080901:1.12
	sid-snapshot-20080801:1.12
	reverse-20080717-branch:1.12.0.10
	reverse-20080717-branchpoint:1.12
	sid-snapshot-20080701:1.12
	msnyder-reverse-20080609-branch:1.12.0.8
	msnyder-reverse-20080609-branchpoint:1.12
	drow-reverse-20070409-branch:1.11.0.4
	drow-reverse-20070409-branchpoint:1.11
	sid-snapshot-20080601:1.12
	sid-snapshot-20080501:1.12
	sid-snapshot-20080403:1.12
	sid-snapshot-20080401:1.12
	gdb_6_8-2008-03-27-release:1.12
	sid-snapshot-20080301:1.12
	gdb_6_8-branch:1.12.0.6
	gdb_6_8-2008-02-26-branchpoint:1.12
	sid-snapshot-20080201:1.12
	sid-snapshot-20080101:1.12
	sid-snapshot-20071201:1.12
	sid-snapshot-20071101:1.12
	gdb_6_7_1-2007-10-29-release:1.12
	gdb_6_7-2007-10-10-release:1.12
	sid-snapshot-20071001:1.12
	gdb_6_7-branch:1.12.0.4
	gdb_6_7-2007-09-07-branchpoint:1.12
	binutils-2_18:1.12
	binutils-2_18-branch:1.12.0.2
	binutils-2_18-branchpoint:1.12
	insight_6_6-20070208-release:1.11
	binutils-csl-coldfire-4_1-32:1.10
	binutils-csl-sourcerygxx-4_1-32:1.10
	gdb_6_6-2006-12-18-release:1.11
	binutils-csl-innovasic-fido-3_4_4-33:1.10
	binutils-csl-sourcerygxx-3_4_4-32:1.9
	binutils-csl-coldfire-4_1-30:1.10
	binutils-csl-sourcerygxx-4_1-30:1.10
	binutils-csl-coldfire-4_1-28:1.10
	binutils-csl-sourcerygxx-4_1-29:1.10
	binutils-csl-sourcerygxx-4_1-28:1.10
	gdb_6_6-branch:1.11.0.2
	gdb_6_6-2006-11-15-branchpoint:1.11
	binutils-csl-arm-2006q3-27:1.10
	binutils-csl-sourcerygxx-4_1-27:1.10
	binutils-csl-arm-2006q3-26:1.10
	binutils-csl-sourcerygxx-4_1-26:1.10
	binutils-csl-sourcerygxx-4_1-25:1.10
	binutils-csl-sourcerygxx-4_1-24:1.10
	binutils-csl-sourcerygxx-4_1-23:1.10
	insight_6_5-20061003-release:1.10
	gdb-csl-symbian-6_4_50_20060226-12:1.10
	binutils-csl-sourcerygxx-4_1-21:1.10
	binutils-csl-arm-2006q3-21:1.10
	binutils-csl-sourcerygxx-4_1-22:1.10
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.10
	binutils-csl-sourcerygxx-4_1-20:1.10
	binutils-csl-arm-2006q3-19:1.10
	binutils-csl-sourcerygxx-4_1-19:1.10
	binutils-csl-sourcerygxx-4_1-18:1.10
	binutils-csl-renesas-4_1-9:1.10
	gdb-csl-sourcerygxx-3_4_4-25:1.10
	binutils-csl-sourcerygxx-3_4_4-25:1.9
	nickrob-async-20060828-mergepoint:1.11
	gdb-csl-symbian-6_4_50_20060226-11:1.10
	binutils-csl-renesas-4_1-8:1.10
	binutils-csl-renesas-4_1-7:1.10
	binutils-csl-renesas-4_1-6:1.10
	gdb-csl-sourcerygxx-4_1-17:1.10
	binutils-csl-sourcerygxx-4_1-17:1.10
	gdb-csl-20060226-branch-local-2:1.10
	gdb-csl-sourcerygxx-4_1-14:1.10
	binutils-csl-sourcerygxx-4_1-14:1.10
	binutils-csl-sourcerygxx-4_1-15:1.10
	gdb-csl-sourcerygxx-4_1-13:1.10
	binutils-csl-sourcerygxx-4_1-13:1.10
	binutils-2_17:1.10
	gdb-csl-sourcerygxx-4_1-12:1.10
	binutils-csl-sourcerygxx-4_1-12:1.10
	gdb-csl-sourcerygxx-3_4_4-21:1.10
	binutils-csl-sourcerygxx-3_4_4-21:1.10
	gdb_6_5-20060621-release:1.10
	binutils-csl-wrs-linux-3_4_4-24:1.9
	binutils-csl-wrs-linux-3_4_4-23:1.9
	gdb-csl-sourcerygxx-4_1-9:1.10
	binutils-csl-sourcerygxx-4_1-9:1.10
	gdb-csl-sourcerygxx-4_1-8:1.10
	binutils-csl-sourcerygxx-4_1-8:1.10
	gdb-csl-sourcerygxx-4_1-7:1.10
	binutils-csl-sourcerygxx-4_1-7:1.10
	gdb-csl-arm-2006q1-6:1.10
	binutils-csl-arm-2006q1-6:1.10
	gdb-csl-sourcerygxx-4_1-6:1.10
	binutils-csl-sourcerygxx-4_1-6:1.10
	binutils-csl-wrs-linux-3_4_4-22:1.9
	gdb-csl-symbian-6_4_50_20060226-10:1.10
	gdb-csl-symbian-6_4_50_20060226-9:1.10
	gdb-csl-symbian-6_4_50_20060226-8:1.10
	gdb-csl-coldfire-4_1-11:1.10
	binutils-csl-coldfire-4_1-11:1.10
	gdb-csl-sourcerygxx-3_4_4-19:1.10
	binutils-csl-sourcerygxx-3_4_4-19:1.10
	gdb-csl-coldfire-4_1-10:1.10
	gdb_6_5-branch:1.10.0.30
	gdb_6_5-2006-05-14-branchpoint:1.10
	binutils-csl-coldfire-4_1-10:1.10
	gdb-csl-sourcerygxx-4_1-5:1.10
	binutils-csl-sourcerygxx-4_1-5:1.10
	nickrob-async-20060513-branch:1.10.0.28
	nickrob-async-20060513-branchpoint:1.10
	gdb-csl-sourcerygxx-4_1-4:1.10
	binutils-csl-sourcerygxx-4_1-4:1.10
	msnyder-reverse-20060502-branch:1.10.0.26
	msnyder-reverse-20060502-branchpoint:1.10
	binutils-csl-wrs-linux-3_4_4-21:1.9
	gdb-csl-morpho-4_1-4:1.10
	binutils-csl-morpho-4_1-4:1.10
	gdb-csl-sourcerygxx-3_4_4-17:1.10
	binutils-csl-sourcerygxx-3_4_4-17:1.10
	binutils-csl-wrs-linux-3_4_4-20:1.9
	readline_5_1-import-branch:1.10.0.24
	readline_5_1-import-branchpoint:1.10
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.10
	binutils-2_17-branch:1.10.0.22
	binutils-2_17-branchpoint:1.10
	gdb-csl-symbian-20060226-branch:1.10.0.20
	gdb-csl-symbian-20060226-branchpoint:1.10
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.10
	msnyder-reverse-20060331-branch:1.10.0.18
	msnyder-reverse-20060331-branchpoint:1.10
	binutils-csl-2_17-branch:1.10.0.16
	binutils-csl-2_17-branchpoint:1.10
	gdb-csl-available-20060303-branch:1.10.0.14
	gdb-csl-available-20060303-branchpoint:1.10
	gdb-csl-20060226-branch:1.10.0.12
	gdb-csl-20060226-branchpoint:1.10
	gdb_6_4-20051202-release:1.10
	msnyder-fork-checkpoint-branch:1.10.0.10
	msnyder-fork-checkpoint-branchpoint:1.10
	gdb-csl-gxxpro-6_3-branch:1.10.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.10
	gdb_6_4-branch:1.10.0.6
	gdb_6_4-2005-11-01-branchpoint:1.10
	gdb-csl-arm-20051020-branch:1.10.0.4
	gdb-csl-arm-20051020-branchpoint:1.10
	binutils-csl-gxxpro-3_4-branch:1.9.0.28
	binutils-csl-gxxpro-3_4-branchpoint:1.9
	binutils-2_16_1:1.9
	msnyder-tracepoint-checkpoint-branch:1.10.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.10
	gdb-csl-arm-20050325-2005-q1b:1.9
	binutils-csl-arm-2005q1b:1.9
	binutils-2_16:1.9
	gdb-csl-arm-20050325-2005-q1a:1.9
	binutils-csl-arm-2005q1a:1.9
	csl-arm-20050325-branch:1.9.0.26
	csl-arm-20050325-branchpoint:1.9
	binutils-csl-arm-2005q1-branch:1.9.0.24
	binutils-csl-arm-2005q1-branchpoint:1.9
	binutils-2_16-branch:1.9.0.22
	binutils-2_16-branchpoint:1.9
	csl-arm-2004-q3d:1.9
	gdb_6_3-20041109-release:1.9
	gdb_6_3-branch:1.9.0.18
	gdb_6_3-20041019-branchpoint:1.9
	csl-arm-2004-q3:1.9
	drow_intercu-merge-20040921:1.9
	drow_intercu-merge-20040915:1.9
	jimb-gdb_6_2-e500-branch:1.9.0.20
	jimb-gdb_6_2-e500-branchpoint:1.9
	gdb_6_2-20040730-release:1.9
	gdb_6_2-branch:1.9.0.16
	gdb_6_2-2004-07-10-gmt-branchpoint:1.9
	gdb_6_1_1-20040616-release:1.9
	binutils-2_15:1.9
	binutils-2_15-branchpoint:1.9
	csl-arm-2004-q1a:1.9
	csl-arm-2004-q1:1.9
	gdb_6_1-2004-04-05-release:1.9
	drow_intercu-merge-20040402:1.9
	drow_intercu-merge-20040327:1.9
	ezannoni_pie-20040323-branch:1.9.0.14
	ezannoni_pie-20040323-branchpoint:1.9
	cagney_tramp-20040321-mergepoint:1.9
	cagney_tramp-20040309-branch:1.9.0.12
	cagney_tramp-20040309-branchpoint:1.9
	gdb_6_1-branch:1.9.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.9
	drow_intercu-20040221-branch:1.9.0.8
	drow_intercu-20040221-branchpoint:1.9
	binutils-2_15-branch:1.9.0.6
	cagney_bfdfile-20040213-branch:1.9.0.4
	cagney_bfdfile-20040213-branchpoint:1.9
	drow-cplus-merge-20040208:1.9
	carlton_dictionary-20040126-merge:1.9
	cagney_bigcore-20040122-branch:1.9.0.2
	cagney_bigcore-20040122-branchpoint:1.9
	drow-cplus-merge-20040113:1.9
	csl-arm-2003-q4:1.9
	drow-cplus-merge-20031224:1.9
	drow-cplus-merge-20031220:1.9
	carlton_dictionary-20031215-merge:1.9
	drow-cplus-merge-20031214:1.9
	carlton-dictionary-20031111-merge:1.9
	gdb_6_0-2003-10-04-release:1.8
	kettenis_sparc-20030918-branch:1.8.0.42
	kettenis_sparc-20030918-branchpoint:1.8
	carlton_dictionary-20030917-merge:1.8
	ezannoni_pie-20030916-branchpoint:1.8
	ezannoni_pie-20030916-branch:1.8.0.40
	cagney_x86i386-20030821-branch:1.8.0.38
	cagney_x86i386-20030821-branchpoint:1.8
	carlton_dictionary-20030805-merge:1.8
	carlton_dictionary-20030627-merge:1.8
	gdb_6_0-branch:1.8.0.36
	gdb_6_0-2003-06-23-branchpoint:1.8
	jimb-ppc64-linux-20030613-branch:1.8.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.8
	binutils-2_14:1.8
	cagney_convert-20030606-branch:1.8.0.32
	cagney_convert-20030606-branchpoint:1.8
	cagney_writestrings-20030508-branch:1.8.0.30
	cagney_writestrings-20030508-branchpoint:1.8
	jimb-ppc64-linux-20030528-branch:1.8.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.8
	carlton_dictionary-20030523-merge:1.8
	cagney_fileio-20030521-branch:1.8.0.26
	cagney_fileio-20030521-branchpoint:1.8
	kettenis_i386newframe-20030517-mergepoint:1.8
	jimb-ppc64-linux-20030509-branch:1.8.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.8
	kettenis_i386newframe-20030504-mergepoint:1.8
	carlton_dictionary-20030430-merge:1.8
	binutils-2_14-branch:1.8.0.22
	binutils-2_14-branchpoint:1.8
	kettenis_i386newframe-20030419-branch:1.8.0.20
	kettenis_i386newframe-20030419-branchpoint:1.8
	carlton_dictionary-20030416-merge:1.8
	cagney_frameaddr-20030409-mergepoint:1.8
	kettenis_i386newframe-20030406-branch:1.8.0.18
	kettenis_i386newframe-20030406-branchpoint:1.8
	cagney_frameaddr-20030403-branchpoint:1.8
	cagney_frameaddr-20030403-branch:1.8.0.16
	cagney_framebase-20030330-mergepoint:1.8
	cagney_framebase-20030326-branch:1.8.0.14
	cagney_framebase-20030326-branchpoint:1.8
	cagney_lazyid-20030317-branch:1.8.0.12
	cagney_lazyid-20030317-branchpoint:1.8
	kettenis-i386newframe-20030316-mergepoint:1.8
	offbyone-20030313-branch:1.8.0.10
	offbyone-20030313-branchpoint:1.8
	kettenis-i386newframe-20030308-branch:1.8.0.8
	kettenis-i386newframe-20030308-branchpoint:1.8
	carlton_dictionary-20030305-merge:1.8
	cagney_offbyone-20030303-branch:1.8.0.6
	cagney_offbyone-20030303-branchpoint:1.8
	carlton_dictionary-20030207-merge:1.8
	interps-20030202-branch:1.8.0.4
	interps-20030202-branchpoint:1.8
	cagney-unwind-20030108-branch:1.8.0.2
	cagney-unwind-20030108-branchpoint:1.8
	binutils-2_13_2_1:1.4
	binutils-2_13_2:1.4
	carlton_dictionary-20021223-merge:1.8
	gdb_5_3-2002-12-12-release:1.5.6.1
	carlton_dictionary-20021115-merge:1.6
	binutils-2_13_1:1.4
	kseitz_interps-20021105-merge:1.6
	kseitz_interps-20021103-merge:1.6
	drow-cplus-merge-20021020:1.6
	drow-cplus-merge-20021025:1.6
	carlton_dictionary-20021025-merge:1.6
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.12
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.10
	carlton_dictionary-20020920-branchpoint:1.5
	sid-20020905-branchpoint:1.5
	sid-20020905-branch:1.5.0.8
	gdb_5_3-branch:1.5.0.6
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.5
	cagney_sysregs-20020825-branch:1.5.0.4
	cagney_sysregs-20020825-branchpoint:1.5
	readline_4_3-import-branch:1.5.0.2
	readline_4_3-import-branchpoint:1.5
	binutils-2_13:1.4
	gdb_5_2_1-2002-07-23-release:1.4
	binutils-2_13-branchpoint:1.4
	binutils-2_13-branch:1.4.0.12
	kseitz_interps-20020528-branch:1.4.0.10
	kseitz_interps-20020528-branchpoint:1.4
	cagney_regbuf-20020515-branch:1.4.0.8
	cagney_regbuf-20020515-branchpoint:1.4
	binutils-2_12_1:1.4
	jimb-macro-020506-branch:1.4.0.6
	jimb-macro-020506-branchpoint:1.4
	gdb_5_2-2002-04-29-release:1.4
	binutils-2_12:1.4
	gdb_5_2-branch:1.4.0.4
	gdb_5_2-2002-03-03-branchpoint:1.4
	binutils-2_12-branch:1.4.0.2
	binutils-2_12-branchpoint:1.4
	gdb_5_1_1-2002-01-24-release:1.2
	gdb_5_1_0_1-2002-01-03-release:1.2
	cygnus_cvs_20020108_pre:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.2.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2
	gdb_5_1-2001-11-21-release:1.2
	gdb_s390-2001-09-26-branch:1.2.0.4
	gdb_s390-2001-09-26-branchpoint:1.2
	gdb_5_1-2001-07-29-branch:1.2.0.2
	gdb_5_1-2001-07-29-branchpoint:1.2
	binutils-2_11_2:1.1.2.1
	binutils-2_11_1:1.1.2.1
	binutils-2_11:1.1
	x86_64versiong3:1.1
	binutils-2_11-branch:1.1.0.2
	insight-precleanup-2001-01-01:1.1
	binutils_latest_snapshot:1.15;
locks; strict;
comment	@ * @;


1.15
date	2012.05.18.01.59.38;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2012.05.15.12.55.51;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2009.09.02.07.20.30;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2007.07.05.09.49.02;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2006.06.06.02.48.34;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.07.07.34.29;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.27.09.26.13;	author ciceron;	state Exp;
branches;
next	1.8;

1.8
date	2002.12.08.20.53.19;	author ciceron;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.01.09.53.21;	author ciceron;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.13.09.01.54;	author ciceron;	state Exp;
branches;
next	1.5;

1.5
date	2002.08.13.19.01.25;	author ciceron;	state Exp;
branches
	1.5.6.1
	1.5.10.1
	1.5.12.1;
next	1.4;

1.4
date	2001.11.01.09.48.57;	author ciceron;	state Exp;
branches
	1.4.10.1;
next	1.3;

1.3
date	2001.08.28.16.27.55;	author aj;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.13.22.58.36;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.19.01.22.43;	author nickc;	state Exp;
branches
	1.1.2.1;
next	;

1.5.6.1
date	2002.10.13.09.04.43;	author ciceron;	state Exp;
branches;
next	;

1.5.10.1
date	2002.10.25.23.50.00;	author carlton;	state Exp;
branches;
next	1.5.10.2;

1.5.10.2
date	2002.12.23.19.39.36;	author carlton;	state Exp;
branches;
next	1.5.10.3;

1.5.10.3
date	2003.11.11.23.51.17;	author carlton;	state Exp;
branches;
next	;

1.5.12.1
date	2002.10.26.17.12.30;	author drow;	state Exp;
branches;
next	1.5.12.2;

1.5.12.2
date	2003.12.14.20.28.07;	author drow;	state Exp;
branches;
next	;

1.4.10.1
date	2002.08.30.22.52.54;	author kseitz;	state Exp;
branches;
next	1.4.10.2;

1.4.10.2
date	2002.11.03.21.50.36;	author ezannoni;	state Exp;
branches;
next	;

1.1.2.1
date	2001.06.07.03.18.35;	author amodra;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.11.01.09.49.31;	author ciceron;	state Exp;
branches;
next	;


desc
@@


1.15
log
@	* arc-dis.c: Include sysdep.h first, remove some redundant includes.
	* bfin-dis.c: Likewise.
	* i860-dis.c: Likewise.
	* ia64-dis.c: Likewise.
	* ia64-gen.c: Likewise.
	* m68hc11-dis.c: Likewise.
	* mmix-dis.c: Likewise.
	* msp430-dis.c: Likewise.
	* or32-dis.c: Likewise.
	* rl78-dis.c: Likewise.
	* rx-dis.c: Likewise.
	* tic4x-dis.c: Likewise.
	* tilegx-opc.c: Likewise.
	* tilepro-opc.c: Likewise.
	* rx-decode.c: Regenerate.
@
text
@/* m68hc11-dis.c -- Motorola 68HC11 & 68HC12 disassembly
   Copyright 1999, 2000, 2001, 2002, 2003, 2005, 2006, 2007, 2012
   Free Software Foundation, Inc.
   Written by Stephane Carrez (stcarrez@@nerim.fr)
   XGATE and S12X added by James Murray (jsm@@jsm-net.demon.co.uk)

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include <stdio.h>

#include "opcode/m68hc11.h"
#include "dis-asm.h"

#define PC_REGNUM 3

static const char *const reg_name[] =
{
  "X", "Y", "SP", "PC"
};

static const char *const reg_src_table[] =
{
  "A", "B", "CCR", "TMP3", "D", "X", "Y", "SP"
};

static const char *const reg_dst_table[] =
{
  "A", "B", "CCR", "TMP2", "D", "X", "Y", "SP"
};

#define OP_PAGE_MASK (M6811_OP_PAGE2|M6811_OP_PAGE3|M6811_OP_PAGE4)

/* Prototypes for local functions.  */
static int read_memory (bfd_vma, bfd_byte *, int, struct disassemble_info *);
static int print_indexed_operand (bfd_vma, struct disassemble_info *,
                                  int*, int, int, bfd_vma, int);
static int print_insn (bfd_vma, struct disassemble_info *, int);

static int
read_memory (bfd_vma memaddr, bfd_byte* buffer, int size,
             struct disassemble_info* info)
{
  int status;

  /* Get first byte.  Only one at a time because we don't know the
     size of the insn.  */
  status = (*info->read_memory_func) (memaddr, buffer, size, info);
  if (status != 0)
    {
      (*info->memory_error_func) (status, memaddr, info);
      return -1;
    }
  return 0;
}


/* Read the 68HC12 indexed operand byte and print the corresponding mode.
   Returns the number of bytes read or -1 if failure.  */
static int
print_indexed_operand (bfd_vma memaddr, struct disassemble_info* info,
                       int* indirect, int mov_insn, int pc_offset,
                       bfd_vma endaddr, int arch)
{
  bfd_byte buffer[4];
  int reg;
  int status;
  short sval;
  int pos = 1;

  if (indirect)
    *indirect = 0;

  status = read_memory (memaddr, &buffer[0], 1, info);
  if (status != 0)
    {
      return status;
    }

  /* n,r with 5-bits signed constant.  */
  if ((buffer[0] & 0x20) == 0)
    {
      reg = (buffer[0] >> 6) & 3;
      sval = (buffer[0] & 0x1f);
      if (sval & 0x10)
	sval |= 0xfff0;
      /* 68HC12 requires an adjustment for movb/movw pc relative modes.  */
      if (reg == PC_REGNUM && info->mach == bfd_mach_m6812 && mov_insn)
        sval += pc_offset;
      (*info->fprintf_func) (info->stream, "0x%x,%s",
			     (unsigned short) sval, reg_name[reg]);

      if (reg == PC_REGNUM)
        {
          (* info->fprintf_func) (info->stream, " {");
	      if (info->symtab_size > 0) /* Avoid duplicate 0x from core binutils. */
	        (*info->fprintf_func) (info->stream, "0x");
          (* info->print_address_func) (endaddr + sval, info);
          (* info->fprintf_func) (info->stream, "}");
        }
    }

  /* Auto pre/post increment/decrement.  */
  else if ((buffer[0] & 0xc0) != 0xc0)
    {
      const char *mode;

      reg = (buffer[0] >> 6) & 3;
      sval = (buffer[0] & 0x0f);
      if (sval & 0x8)
	{
	  sval |= 0xfff0;
	  sval = -sval;
	  mode = "-";
	}
      else
	{
	  sval = sval + 1;
	  mode = "+";
	}
      (*info->fprintf_func) (info->stream, "%d,%s%s%s",
			     (unsigned short) sval,
			     (buffer[0] & 0x10 ? "" : mode),
			     reg_name[reg], (buffer[0] & 0x10 ? mode : ""));
    }

  /* [n,r] 16-bits offset indexed indirect.  */
  else if ((buffer[0] & 0x07) == 3)
    {
      if ((mov_insn) && (!(arch & cpu9s12x)))
      	{
      	  (*info->fprintf_func) (info->stream, "<invalid op: 0x%x>",
    				 buffer[0] & 0x0ff);
      	  return 0;
      	}
      reg = (buffer[0] >> 3) & 0x03;
      status = read_memory (memaddr + pos, &buffer[0], 2, info);
      if (status != 0)
	{
	  return status;
	}

      pos += 2;
      sval = ((buffer[0] << 8) | (buffer[1] & 0x0FF));
      (*info->fprintf_func) (info->stream, "[0x%x,%s]",
			     sval & 0x0ffff, reg_name[reg]);
      if (indirect)
        *indirect = 1;
    }

  /* n,r with 9 and 16 bit signed constant.  */
  else if ((buffer[0] & 0x4) == 0)
    {
      if ((mov_insn) && (!(arch & cpu9s12x)))
      	{
      	  (*info->fprintf_func) (info->stream, "<invalid op: 0x%x>",
    				 buffer[0] & 0x0ff);
      	  return 0;
      	}

      reg = (buffer[0] >> 3) & 0x03;
      status = read_memory (memaddr + pos,
			    &buffer[1], (buffer[0] & 0x2 ? 2 : 1), info);
      if (status != 0)
	{
	  return status;
	}
      if (buffer[0] & 2)
	{
	  sval = ((buffer[1] << 8) | (buffer[2] & 0x0FF));
	  sval &= 0x0FFFF;
	  pos += 2;
          endaddr += 2;
	}
      else
	{
	  sval = buffer[1] & 0x00ff;
	  if (buffer[0] & 0x01)
	    sval |= 0xff00;
	  pos++;
          endaddr++;
	}
      (*info->fprintf_func) (info->stream, "0x%x,%s",
			     (unsigned short) sval, reg_name[reg]);
      if (reg == PC_REGNUM)
        {
          (* info->fprintf_func) (info->stream, " {0x");
          (* info->print_address_func) (endaddr + sval, info);
          (* info->fprintf_func) (info->stream, "}");
        }
    }
  else
    {
      reg = (buffer[0] >> 3) & 0x03;
      switch (buffer[0] & 3)
	{
	case 0:
	  (*info->fprintf_func) (info->stream, "A,%s", reg_name[reg]);
	  break;
	case 1:
	  (*info->fprintf_func) (info->stream, "B,%s", reg_name[reg]);
	  break;
	case 2:
	  (*info->fprintf_func) (info->stream, "D,%s", reg_name[reg]);
	  break;
	case 3:
	default:
	  (*info->fprintf_func) (info->stream, "[D,%s]", reg_name[reg]);
          if (indirect)
            *indirect = 1;
	  break;
	}
    }

  return pos;
}

/* Disassemble one instruction at address 'memaddr'.  Returns the number
   of bytes used by that instruction.  */
static int
print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)
{
  int status;
  bfd_byte buffer[4];
  unsigned int code;
  long format, pos, i;
  short sval;
  const struct m68hc11_opcode *opcode;

  if (arch & cpuxgate)
    {
      int val;
      /* Get two bytes as all XGATE instructions are 16bit.  */
      status = read_memory (memaddr, buffer, 2, info);
      if (status != 0)
	return status;

      format = 0;
      code = (buffer[0] << 8) + buffer[1];

      /* Scan the opcode table until we find the opcode
	 with the corresponding page.  */
      opcode = m68hc11_opcodes;
      for (i = 0; i < m68hc11_num_opcodes; i++, opcode++)
	{
	  if ((opcode->opcode != (code & opcode->xg_mask)) || (opcode->arch != cpuxgate))
  	    continue;
	  /* We have found the opcode.  Extract the operand and print it.  */
	  (*info->fprintf_func) (info->stream, "%s", opcode->name);
	  format = opcode->format;
	  if (format & (M68XG_OP_NONE))
	    {
	      /* Nothing to print.  */
	    }
	  else if (format & M68XG_OP_IMM3)
	    (*info->fprintf_func) (info->stream, " #0x%x", (code >> 8) & 0x7);
	  else if (format & M68XG_OP_R_R)
	    (*info->fprintf_func) (info->stream, " R%x, R%x",
				   (code >> 8) & 0x7, (code >> 5) & 0x7);
	  else if (format & M68XG_OP_R_R_R)
	    (*info->fprintf_func) (info->stream, " R%x, R%x, R%x",
				   (code >> 8) & 0x7, (code >> 5) & 0x7, (code >> 2) & 0x7);
	  else if (format & M68XG_OP_RD_RB_RI)
	    (*info->fprintf_func) (info->stream, " R%x, (R%x, R%x)",
				   (code >> 8) & 0x7, (code >> 5) & 0x7, (code >> 2) & 0x7);
	  else if (format & M68XG_OP_RD_RB_RIp)
	    (*info->fprintf_func) (info->stream, " R%x, (R%x, R%x+)",
				   (code >> 8) & 0x7, (code >> 5) & 0x7, (code >> 2) & 0x7);
	  else if (format & M68XG_OP_RD_RB_mRI)
	    (*info->fprintf_func) (info->stream, " R%x, (R%x, -R%x)",
				   (code >> 8) & 0x7, (code >> 5) & 0x7, (code >> 2) & 0x7);
	  else if (format & M68XG_OP_R_R_OFFS5)
	    (*info->fprintf_func) (info->stream, " R%x, (R%x, #0x%x)",
				   (code >> 8) & 0x7, (code >> 5) & 0x7, code & 0x1f);
	  else if (format & M68XG_OP_R_IMM8)
	    (*info->fprintf_func) (info->stream, " R%x, #0x%02x",
				   (code >> 8) & 0x7, code & 0xff);
	  else if (format & M68XG_OP_R_IMM4)
	    (*info->fprintf_func) (info->stream, " R%x, #0x%x",
				   (code >> 8) & 0x7, (code & 0xf0) >> 4);
	  else if (format & M68XG_OP_REL9)
	    {
	      (*info->fprintf_func) (info->stream, " 0x");
	      val = (buffer[0] & 0x1) ? buffer[1] | 0xFFFFFF00 : buffer[1];
	      (*info->print_address_func) (memaddr + (val << 1) + 2, info);
	    }
	  else if (format & M68XG_OP_REL10)
	    {
	      (*info->fprintf_func) (info->stream, " 0x");
	      val = (buffer[0] << 8) | (unsigned int) buffer[1];
	      if (val & 0x200)
		val |= 0xfffffc00;
	      else
		val &= 0x000001ff;
	      (*info->print_address_func) (memaddr + (val << 1) + 2, info);
	    }
	  else if ((code & 0x00ff) == 0x00f8)
  	    (*info->fprintf_func) (info->stream, " R%x, CCR", (code >> 8) & 0x7);
	  else if ((code & 0x00ff) == 0x00f9)
  	    (*info->fprintf_func) (info->stream, " CCR, R%x", (code >> 8) & 0x7);
	  else if ((code & 0x00ff) == 0x0)
  	    (*info->fprintf_func) (info->stream, " R%x, PC", (code >> 8) & 0x7);
	  else if (format & M68XG_OP_R)
  	    {
	      /* Special cases for TFR.  */
	      if ((code & 0xf8ff) == 0x00f8)
		(*info->fprintf_func) (info->stream, " R%x, CCR", (code >> 8) & 0x7);
	      else if ((code & 0xf8ff) == 0x00f9)
		(*info->fprintf_func) (info->stream, " CCR, R%x", (code >> 8) & 0x7);
	      else if ((code & 0xf8ff) == 0x00fa)
		(*info->fprintf_func) (info->stream, " R%x, PC",  (code >> 8) & 0x7);
	      else
		(*info->fprintf_func) (info->stream, " R%x", (code >> 8) & 0x7);
	    }
	  else
	    /* Opcode not recognized.  */
	    (*info->fprintf_func) (info->stream, "Not yet handled TEST .byte\t0x%04x", code);
	  return 2;
	}

      /* Opcode not recognized.  */
      (*info->fprintf_func) (info->stream, ".byte\t0x%04x", code);
      return 2; /* Everything is two bytes.  */
    }

  /* HC11 and HC12.  */

  /* Get first byte.  Only one at a time because we don't know the
     size of the insn.  */
  status = read_memory (memaddr, buffer, 1, info);
  if (status != 0)
    return status;

  format = 0;
  code = buffer[0];
  pos = 0;

  /* Look for page2,3,4 opcodes.  */
  if (code == M6811_OPCODE_PAGE2)
    {
      pos++;
      format = M6811_OP_PAGE2;
    }
  else if (code == M6811_OPCODE_PAGE3 && arch == cpu6811)
    {
      pos++;
      format = M6811_OP_PAGE3;
    }
  else if (code == M6811_OPCODE_PAGE4 && arch == cpu6811)
    {
      pos++;
      format = M6811_OP_PAGE4;
    }

  /* We are in page2,3,4; get the real opcode.  */
  if (pos == 1)
    {
      status = read_memory (memaddr + pos, &buffer[1], 1, info);
      if (status != 0)
	return status;

      code = buffer[1];
    }

  /* Look first for a 68HC12 alias.  All of them are 2-bytes long and
     in page 1.  There is no operand to print.  We read the second byte
     only when we have a possible match.  */
  if ((arch & cpu6812) && format == 0)
    {
      int must_read = 1;

      /* Walk the alias table to find a code1+code2 match.  */
      for (i = 0; i < m68hc12_num_alias; i++)
	{
	  if (m68hc12_alias[i].code1 == code)
	    {
	      if (must_read)
		{
		  status = read_memory (memaddr + pos + 1,
					&buffer[1], 1, info);
		  if (status != 0)
		    break;

		  must_read = 1;
		}
	      if (m68hc12_alias[i].code2 == (unsigned char) buffer[1])
		{
		  (*info->fprintf_func) (info->stream, "%s",
					 m68hc12_alias[i].name);
		  return 2;
		}
	    }
	}
    }

  pos++;

  /* Scan the opcode table until we find the opcode
     with the corresponding page.  */
  opcode = m68hc11_opcodes;
  for (i = 0; i < m68hc11_num_opcodes; i++, opcode++)
    {
      int offset;
      int pc_src_offset;
      int pc_dst_offset = 0;

      if ((opcode->arch & arch) == 0)
	continue;
      if (opcode->opcode != code)
	continue;
      if ((opcode->format & OP_PAGE_MASK) != format)
	continue;

      if (opcode->format & M6812_OP_REG)
	{
	  int j;
	  int is_jump;

	  if (opcode->format & M6811_OP_JUMP_REL)
	    is_jump = 1;
	  else
	    is_jump = 0;

	  status = read_memory (memaddr + pos, &buffer[0], 1, info);
	  if (status != 0)
	    {
	      return status;
	    }
	  for (j = 0; i + j < m68hc11_num_opcodes; j++)
	    {
	      if ((opcode[j].arch & arch) == 0)
		continue;
	      if (opcode[j].opcode != code)
		continue;
	      if (is_jump)
		{
		  if (!(opcode[j].format & M6811_OP_JUMP_REL))
		    continue;

		  if ((opcode[j].format & M6812_OP_IBCC_MARKER)
		      && (buffer[0] & 0xc0) != 0x80)
		    continue;
		  if ((opcode[j].format & M6812_OP_TBCC_MARKER)
		      && (buffer[0] & 0xc0) != 0x40)
		    continue;
		  if ((opcode[j].format & M6812_OP_DBCC_MARKER)
		      && (buffer[0] & 0xc0) != 0)
		    continue;
		  if ((opcode[j].format & M6812_OP_EQ_MARKER)
		      && (buffer[0] & 0x20) == 0)
		    break;
		  if (!(opcode[j].format & M6812_OP_EQ_MARKER)
		      && (buffer[0] & 0x20) != 0)
		    break;
		  continue;
		}
	      if (opcode[j].format & M6812_OP_EXG_MARKER && buffer[0] & 0x80)
		break;
	      if ((opcode[j].format & M6812_OP_SEX_MARKER)
		  && (((buffer[0] & 0x07) >= 3 && (buffer[0] & 7) <= 7))
		  && ((buffer[0] & 0x0f0) <= 0x20))
		break;
	      if ((opcode[j].format & M6812_OP_SEX_MARKER)
		  && (arch & cpu9s12x)
		  && ((buffer[0] == 0x4d) || (buffer[0] == 0x4e)))
		break;
	      if (opcode[j].format & M6812_OP_TFR_MARKER
		  && !(buffer[0] & 0x80))
		break;
	    }
	  if (i + j < m68hc11_num_opcodes)
	    opcode = &opcode[j];
	}

      /* We have found the opcode.  Extract the operand and print it.  */
      (*info->fprintf_func) (info->stream, "%s", opcode->name);

      format = opcode->format;
      if (format & (M6811_OP_MASK | M6811_OP_BITMASK
		    | M6811_OP_JUMP_REL | M6812_OP_JUMP_REL16))
	{
	  (*info->fprintf_func) (info->stream, "\t");
	}

      /* The movb and movw must be handled in a special way...
	 The source constant 'ii' is not always at the same place.
	 This is the same for the destination for the post-indexed byte.
	 The 'offset' is used to do the appropriate correction.

	 offset          offset
	 for constant     for destination
	 movb   18 OB ii hh ll       0          0
	 18 08 xb ii          1          -1
	 18 08 xb ff ii       2          1  9 bit
	 18 08 xb ee ff ii    3          1  16 bit
	 18 0C hh ll hh ll    0          0
	 18 09 xb hh ll       1          -1
	 18 0D xb hh ll       0          0
	 18 0A xb xb          0          0

	 movw   18 03 jj kk hh ll    0          0
	 18 00 xb jj kk       1          -1
	 18 04 hh ll hh ll    0          0
	 18 01 xb hh ll       1          -1
	 18 05 xb hh ll       0          0
	 18 02 xb xb          0          0

	 After the source operand is read, the position 'pos' is incremented
	 this explains the negative offset for destination.

	 movb/movw above are the only instructions with this matching
	 format.  */
      offset = ((format & M6812_OP_IDX_P2)
		&& (format & (M6811_OP_IMM8 | M6811_OP_IMM16 |
			      M6811_OP_IND16)));

      if (offset)
	{
	  /* Check xb to see position of data.  */
	  status = read_memory (memaddr + pos, &buffer[0], 1, info);
	  if (status != 0)
	    {
	      return status;
	    }

	  if (((buffer[0] & 0xe0) == 0xe0) && ((buffer[0] & 0x04) == 0))
	    {
	      /* 9 or 16 bit.  */
	      if ((buffer[0] & 0x02) == 0)
		{
		  /* 9 bit.  */
		  offset = 2;
		}
	      else
		{
		  /* 16 bit.  */
		  offset = 3;
		}
	    }
	}

      /* Operand with one more byte: - immediate, offset,
	 direct-low address.  */
      if (format &
	  (M6811_OP_IMM8 | M6811_OP_IX | M6811_OP_IY | M6811_OP_DIRECT))
	{
	  status = read_memory (memaddr + pos + offset, &buffer[0], 1, info);
	  if (status != 0)
	    return status;

	  /* This movb/movw is special (see above).  */
	  if (offset < 2)
	    {
	      offset = -offset;
	      pc_dst_offset = 2;
	    }
	  else
	    {
	      offset = -1;
	      pc_dst_offset = 5;
	    }
	  pos++;

	  if (format & M6811_OP_IMM8)
	    {
	      (*info->fprintf_func) (info->stream, "#0x%x", (int) buffer[0]);
	      format &= ~M6811_OP_IMM8;
	      /* Set PC destination offset.  */
	      pc_dst_offset = 1;
	    }
	  else if (format & M6811_OP_IX)
	    {
	      /* Offsets are in range 0..255, print them unsigned.  */
	      (*info->fprintf_func) (info->stream, "0x%x,x", buffer[0] & 0x0FF);
	      format &= ~M6811_OP_IX;
	    }
	  else if (format & M6811_OP_IY)
	    {
	      (*info->fprintf_func) (info->stream, "0x%x,y", buffer[0] & 0x0FF);
	      format &= ~M6811_OP_IY;
	    }
	  else if (format & M6811_OP_DIRECT)
	    {
	      (*info->fprintf_func) (info->stream, "*");
	      if (info->symtab_size > 0) /* Avoid duplicate 0x. */
		(*info->fprintf_func) (info->stream, "0x");
	      (*info->print_address_func) (buffer[0] & 0x0FF, info);
	      format &= ~M6811_OP_DIRECT;
	    }
	}

#define M6812_DST_MOVE  (M6812_OP_IND16_P2 | M6812_OP_IDX_P2)
#define M6812_INDEXED_FLAGS (M6812_OP_IDX|M6812_OP_IDX_1|M6812_OP_IDX_2)
      /* Analyze the 68HC12 indexed byte.  */
      if (format & M6812_INDEXED_FLAGS)
	{
	  int indirect;
	  bfd_vma endaddr;

	  endaddr = memaddr + pos + 1;
	  if (format & M6811_OP_IND16)
	    endaddr += 2;
	  pc_src_offset = -1;
	  pc_dst_offset = 1;
	  status = print_indexed_operand (memaddr + pos, info, &indirect,
					  (format & M6812_DST_MOVE),
					  pc_src_offset, endaddr, arch);
	  if (status < 0)
	    return status;

	  pos += status;

	  /* The indirect addressing mode of the call instruction does
	     not need the page code.  */
	  if ((format & M6812_OP_PAGE) && indirect)
	    format &= ~M6812_OP_PAGE;
	}

      /* 68HC12 dbcc/ibcc/tbcc operands.  */
      if ((format & M6812_OP_REG) && (format & M6811_OP_JUMP_REL))
	{
	  status = read_memory (memaddr + pos, &buffer[0], 2, info);
	  if (status != 0)
	    return status;

	  (*info->fprintf_func) (info->stream, "%s,",
				 reg_src_table[buffer[0] & 0x07]);
	  sval = buffer[1] & 0x0ff;
	  if (buffer[0] & 0x10)
	    sval |= 0xff00;

	  pos += 2;
	  (*info->fprintf_func) (info->stream, "0x");
	  (*info->print_address_func) (memaddr + pos + sval, info);
	  format &= ~(M6812_OP_REG | M6811_OP_JUMP_REL);
	}
      else if (format & (M6812_OP_REG | M6812_OP_REG_2))
	{
	  status = read_memory (memaddr + pos, &buffer[0], 1, info);
	  if (status != 0)
	    return status;

	  pos++;
	  (*info->fprintf_func) (info->stream, "%s,%s",
				 reg_src_table[(buffer[0] >> 4) & 7],
				 reg_dst_table[(buffer[0] & 7)]);
	}

      if (format & (M6811_OP_IMM16 | M6811_OP_IND16))
	{
	  int val;
	  bfd_vma addr;
	  unsigned page = 0;

	  status = read_memory (memaddr + pos + offset, &buffer[0], 2, info);
	  if (status != 0)
	    return status;

	  if (format & M6812_OP_IDX_P2)
	    offset = -2;
	  else
	    offset = 0;
	  pos += 2;

	  val = ((buffer[0] << 8) | (buffer[1] & 0x0FF));
	  val &= 0x0FFFF;
	  addr = val;
	  pc_dst_offset = 2;
	  if (format & M6812_OP_PAGE)
	    {
	      status = read_memory (memaddr + pos + offset, buffer, 1, info);
	      if (status != 0)
		return status;

	      page = (unsigned) buffer[0];
	      if (addr >= M68HC12_BANK_BASE && addr < 0x0c000)
		addr = ((val - M68HC12_BANK_BASE)
			| (page << M68HC12_BANK_SHIFT))
		  + M68HC12_BANK_VIRT;
	    }
	  else if ((arch & cpu6812)
		   && addr >= M68HC12_BANK_BASE && addr < 0x0c000)
	    {
	      int cur_page;
	      bfd_vma vaddr;
                
	      if (memaddr >= M68HC12_BANK_VIRT)
		cur_page = ((memaddr - M68HC12_BANK_VIRT)
			    >> M68HC12_BANK_SHIFT);
	      else
		cur_page = 0;

	      vaddr = ((addr - M68HC12_BANK_BASE)
		       + (cur_page << M68HC12_BANK_SHIFT))
		+ M68HC12_BANK_VIRT;
	      if (!info->symbol_at_address_func (addr, info)
		  && info->symbol_at_address_func (vaddr, info))
		addr = vaddr;
	    }
	  if (format & M6811_OP_IMM16)
	    {
	      format &= ~M6811_OP_IMM16;
	      (*info->fprintf_func) (info->stream, "#");
	    }
	  else
	    {
	      format &= ~M6811_OP_IND16;
	    }

	  if (info->symtab_size > 0) /* Avoid duplicate 0x from core binutils. */
	    (*info->fprintf_func) (info->stream, "0x");

	  (*info->print_address_func) (addr, info);
	  if (format & M6812_OP_PAGE)
	    {
	      (* info->fprintf_func) (info->stream, " {");
	      if (info->symtab_size > 0) /* Avoid duplicate 0x from core binutils. */
		(*info->fprintf_func) (info->stream, "0x");
	      (* info->print_address_func) (val, info);
	      (* info->fprintf_func) (info->stream, ", 0x%x}", page);
	      format &= ~M6812_OP_PAGE;
	      pos += 1;
	    }
	}

      if (format & M6812_OP_IDX_P2)
	{
	  (*info->fprintf_func) (info->stream, ", ");
	  status = print_indexed_operand (memaddr + pos + offset, info,
					  0, 1, pc_dst_offset,
					  memaddr + pos + offset + 1, arch);
	  if (status < 0)
	    return status;
	  pos += status;
	}

      if (format & M6812_OP_IND16_P2)
	{
	  int val;

	  (*info->fprintf_func) (info->stream, ", ");

	  status = read_memory (memaddr + pos + offset, &buffer[0], 2, info);
	  if (status != 0)
	    return status;

	  pos += 2;

	  val = ((buffer[0] << 8) | (buffer[1] & 0x0FF));
	  val &= 0x0FFFF;
	  if (info->symtab_size > 0) /* Avoid duplicate 0x from core binutils. */
	    (*info->fprintf_func) (info->stream, "0x");
	  (*info->print_address_func) (val, info);
	}

      /* M6811_OP_BITMASK and M6811_OP_JUMP_REL must be treated separately
	 and in that order.  The brset/brclr insn have a bitmask and then
	 a relative branch offset.  */
      if (format & M6811_OP_BITMASK)
	{
	  status = read_memory (memaddr + pos, &buffer[0], 1, info);
	  if (status != 0)
	    return status;

	  pos++;
	  (*info->fprintf_func) (info->stream, ", #0x%02x%s",
				 buffer[0] & 0x0FF,
				 (format & M6811_OP_JUMP_REL ? ", " : ""));
	  format &= ~M6811_OP_BITMASK;
	}
      if (format & M6811_OP_JUMP_REL)
	{
	  int val;

	  status = read_memory (memaddr + pos, &buffer[0], 1, info);
	  if (status != 0)
	    return status;

	  (*info->fprintf_func) (info->stream, "0x");
	  pos++;
	  val = (buffer[0] & 0x80) ? buffer[0] | 0xFFFFFF00 : buffer[0];
	  (*info->print_address_func) (memaddr + pos + val, info);
	  format &= ~M6811_OP_JUMP_REL;
	}
      else if (format & M6812_OP_JUMP_REL16)
	{
	  int val;

	  status = read_memory (memaddr + pos, &buffer[0], 2, info);
	  if (status != 0)
	    return status;

	  pos += 2;
	  val = ((buffer[0] << 8) | (buffer[1] & 0x0FF));
	  if (val & 0x8000)
	    val |= 0xffff0000;

	  (*info->fprintf_func) (info->stream, "0x");
	  (*info->print_address_func) (memaddr + pos + val, info);
	  format &= ~M6812_OP_JUMP_REL16;
	}

      if (format & M6812_OP_PAGE)
	{
	  int val;

	  status = read_memory (memaddr + pos + offset, &buffer[0], 1, info);
	  if (status != 0)
	    return status;

	  pos += 1;

	  val = buffer[0] & 0x0ff;
	  (*info->fprintf_func) (info->stream, ", 0x%x", val);
	}
      
#ifdef DEBUG
      /* Consistency check.  'format' must be 0, so that we have handled
	 all formats; and the computed size of the insn must match the
	 opcode table content.  */
      if (format & ~(M6811_OP_PAGE4 | M6811_OP_PAGE3 | M6811_OP_PAGE2))
	(*info->fprintf_func) (info->stream, "; Error, format: %lx", format);

      if (pos != opcode->size)
	(*info->fprintf_func) (info->stream, "; Error, size: %ld expect %d",
			       pos, opcode->size);
#endif
      return pos;
    }

  /* Opcode not recognized.  */
  if (format == M6811_OP_PAGE2 && arch & cpu6812
      && ((code >= 0x30 && code <= 0x39) || (code >= 0x40)))
    (*info->fprintf_func) (info->stream, "trap\t#0x%02x", code & 0x0ff);

  else if (format == M6811_OP_PAGE2)
    (*info->fprintf_func) (info->stream, ".byte\t0x%02x, 0x%02x",
			   M6811_OPCODE_PAGE2, code);
  else if (format == M6811_OP_PAGE3)
    (*info->fprintf_func) (info->stream, ".byte\t0x%02x, 0x%02x",
			   M6811_OPCODE_PAGE3, code);
  else if (format == M6811_OP_PAGE4)
    (*info->fprintf_func) (info->stream, ".byte\t0x%02x, 0x%02x",
			   M6811_OPCODE_PAGE4, code);
  else
    (*info->fprintf_func) (info->stream, ".byte\t0x%02x", code);

  return pos;
}

/* Disassemble one instruction at address 'memaddr'.  Returns the number
   of bytes used by that instruction.  */
int
print_insn_m68hc11 (bfd_vma memaddr, struct disassemble_info* info)
{
  return print_insn (memaddr, info, cpu6811);
}

int
print_insn_m68hc12 (bfd_vma memaddr, struct disassemble_info* info)
{
  return print_insn (memaddr, info, cpu6812);
}

int
print_insn_m9s12x (bfd_vma memaddr, struct disassemble_info* info)
{
  return print_insn (memaddr, info, cpu6812|cpu9s12x);
}

int
print_insn_m9s12xg (bfd_vma memaddr, struct disassemble_info* info)
{
  return print_insn (memaddr, info, cpuxgate);
}
@


1.14
log
@	* config/tc-m68hc11.c: Add S12X and XGATE co-processor support.
	Add option to offset S12 addresses into XGATE memory space.
	Tweak target flags to match other tools. (i.e. -m m68hc11).
	* doc/as.texinfo: Mention new options.
	* doc/c-m68hc11.texi: Document new options.
	* NEWS: Mention new support.

	* archures.c: Add bfd_arch_m9s12x and bfd_arch_m9s12xg.
	* config.bfd: Likewise.
	* cpu-m9s12x.c: New.
	* cpu-m9s12xg.c: New.
	* elf32-m68hc12.c: Add S12X and XGATE co-processor support.
	Add option to offset S12 addresses into XGATE memory space.
	Fix carry bug in IMM16 (IMM8 low/high) relocate.
	* Makefile.am (ALL_MACHINES): Add cpu-m9s12x and cpu-m9s12xg.
	(ALL_MACHINES_CFILES): Likewise.
	* reloc.c: Add S12X relocs.
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

	* gas/m68hc11/insns9s12x.s: New
	* gas/m68hc11/insns9s12x.d: New
	* gas/m68hc11/hexprefix.s: New
	* gas/m68hc11/hexprefix.d: New
	* gas/m68hc11/9s12x-exg-sex-tfr.s: New
	* gas/m68hc11/9s12x-exg-sex-tfr.d: New
	* gas/m68hc11/insns9s12xg.s: New
	* gas/m68hc11/insns9s12xg.d: New
	* gas/m68hc11/9s12x-mov.s: New
	* gas/m68hc11/9s12x-mov.d: New
	* gas/m68hc11/m68hc11.exp: Updated
	* gas/m68hc11/*.d: Brought in line with changed objdump output.
	* gas/all/gas.exp: XFAIL all hc11/12 targets for redef2,3.
	* gas/elf/elf.exp: XFAIL all hc11/12 targets for redef.
	* gas/elf/dwarf2-1.d: Skip for hc11/12 targets.
	* gas/elf/dwarf2-2.d: Likewise.

	* ld-m68hc11/xgate-link.s: New.
	* ld-m68hc11/xgate-link.d: New.
	* ld-m68hc11/xgate-offset.s: New.
	* ld-m68hc11/xgate-offset.d: New.
	* ld-m68hc11/xgate1.s: New.
	* ld-m68hc11/xgate1.d: New.
	* ld-m68hc11/xgate2.s: New.
	* ld-m68hc11/m68hc11.exp: Updated.
	* ld-m68hc11/*.d: Brought in line with changed objdump output.
	* ld-gc/gc.exp: Update CFLAGS for m68hc11.
	* ld-plugin/plugin.exp: Likewise.
	* ld-srec/srec.exp: XFAIL for m68hc11 and m68hc12.

	* configure.in: Add S12X and XGATE co-processor support to m68hc11
	target.
	* disassemble.c: Likewise.
	* configure: Regenerate.
	* m68hc11-dis.c: Make objdump output more consistent, use hex
	instead of decimal and use 0x prefix for hex.
	* m68hc11-opc.c: Add S12X and XGATE opcodes.
	* dis-asm.h (print_insn_m9s12x): Prototype.
	(print_insn_m9s12xg): Prototype.

	* m68hc11.h (R_M68HC12_16B, R_M68HC12_PCREL_9, R_M68HC12_PCREL_10)
	R_M68HC12_HI8XG, R_M68HC12_LO8XG): New relocations.
	(E_M68HC11_XGATE_RAMOFFSET): Define.

	* m68hc11.h: Add XGate definitions.
	(struct m68hc11_opcode): Add xg_mask field.
@
text
@d24 1
a26 1
#include "ansidecl.h"
@


1.13
log
@update copyright dates
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2005, 2006, 2007
d5 1
d32 2
a33 1
static const char *const reg_name[] = {
d37 2
a38 1
static const char *const reg_src_table[] = {
d42 2
a43 1
static const char *const reg_dst_table[] = {
d52 1
a52 1
                                  int*, int, int, bfd_vma);
d78 1
a78 1
                       bfd_vma endaddr)
d105 2
a106 2
      (*info->fprintf_func) (info->stream, "%d,%s",
			     (int) sval, reg_name[reg]);
d111 2
d137 1
a137 1
			     (int) sval,
d145 6
a150 6
      if (mov_insn)
	{
	  (*info->fprintf_func) (info->stream, "<invalid op: 0x%x>",
				 buffer[0] & 0x0ff);
	  return 0;
	}
d160 1
a160 1
      (*info->fprintf_func) (info->stream, "[%u,%s]",
d169 7
a175 6
      if (mov_insn)
	{
	  (*info->fprintf_func) (info->stream, "<invalid op: 0x%x>",
				 buffer[0] & 0x0ff);
	  return 0;
	}
d198 2
a199 2
      (*info->fprintf_func) (info->stream, "%d,%s",
			     (int) sval, reg_name[reg]);
d202 1
a202 1
          (* info->fprintf_func) (info->stream, " {");
d240 1
a240 1
  unsigned char code;
d245 98
d347 1
a347 3
    {
      return status;
    }
d375 2
a376 3
	{
	  return status;
	}
a379 1

d478 4
d501 21
a521 19
         The source constant 'ii' is not always at the same place.
         This is the same for the destination for the post-indexed byte.
         The 'offset' is used to do the appropriate correction.

                                   offset          offset
                              for constant     for destination
         movb   18 OB ii hh ll       0          0
                18 08 xb ii          1          -1
                18 0C hh ll hh ll    0          0
                18 09 xb hh ll       1          -1
                18 0D xb hh ll       0          0
                18 0A xb xb          0          0

         movw   18 03 jj kk hh ll    0          0
                18 00 xb jj kk       1          -1
                18 04 hh ll hh ll    0          0
                18 01 xb hh ll       1          -1
                18 05 xb hh ll       0          0
                18 02 xb xb          0          0
d523 2
a524 2
         After the source operand is read, the position 'pos' is incremented
         this explains the negative offset for destination.
d526 2
a527 2
         movb/movw above are the only instructions with this matching
         format.  */
d529 27
a555 2
                && (format & (M6811_OP_IMM8 | M6811_OP_IMM16 |
                              M6811_OP_IND16)));
d558 1
a558 1
         direct-low address.  */
d564 4
d569 7
a575 1
	      return status;
a576 1

a578 4
          /* This movb/movw is special (see above).  */
          offset = -offset;

          pc_dst_offset = 2;
d581 1
a581 1
	      (*info->fprintf_func) (info->stream, "#%d", (int) buffer[0]);
d583 2
a584 2
              /* Set PC destination offset.  */
              pc_dst_offset = 1;
d589 1
a589 1
	      (*info->fprintf_func) (info->stream, "%u,x", buffer[0] & 0x0FF);
d594 1
a594 1
	      (*info->fprintf_func) (info->stream, "%u,y", buffer[0] & 0x0FF);
d600 2
d612 2
a613 2
          int indirect;
          bfd_vma endaddr;
d615 5
a619 5
          endaddr = memaddr + pos + 1;
          if (format & M6811_OP_IND16)
            endaddr += 2;
          pc_src_offset = -1;
          pc_dst_offset = 1;
d621 2
a622 2
                                          (format & M6812_DST_MOVE),
                                          pc_src_offset, endaddr);
d624 2
a625 3
	    {
	      return status;
	    }
d628 4
a631 4
          /* The indirect addressing mode of the call instruction does
             not need the page code.  */
          if ((format & M6812_OP_PAGE) && indirect)
            format &= ~M6812_OP_PAGE;
d639 2
a640 3
	    {
	      return status;
	    }
d648 1
d656 1
a656 3
	    {
	      return status;
	    }
d667 2
a668 2
          bfd_vma addr;
          unsigned page = 0;
d672 2
a673 3
	    {
	      return status;
	    }
d682 19
a700 19
          addr = val;
          pc_dst_offset = 2;
          if (format & M6812_OP_PAGE)
            {
              status = read_memory (memaddr + pos + offset, buffer, 1, info);
              if (status != 0)
                return status;

              page = (unsigned) buffer[0];
              if (addr >= M68HC12_BANK_BASE && addr < 0x0c000)
                addr = ((val - M68HC12_BANK_BASE)
                        | (page << M68HC12_BANK_SHIFT))
                   + M68HC12_BANK_VIRT;
            }
          else if ((arch & cpu6812)
                   && addr >= M68HC12_BANK_BASE && addr < 0x0c000)
             {
                int cur_page;
                bfd_vma vaddr;
d702 13
a714 13
                if (memaddr >= M68HC12_BANK_VIRT)
                   cur_page = ((memaddr - M68HC12_BANK_VIRT)
                               >> M68HC12_BANK_SHIFT);
                else
                   cur_page = 0;

                vaddr = ((addr - M68HC12_BANK_BASE)
                         + (cur_page << M68HC12_BANK_SHIFT))
                   + M68HC12_BANK_VIRT;
                if (!info->symbol_at_address_func (addr, info)
                    && info->symbol_at_address_func (vaddr, info))
                   addr = vaddr;
             }
d721 6
a726 1
	    format &= ~M6811_OP_IND16;
d729 10
a738 8
          if (format & M6812_OP_PAGE)
            {
              (* info->fprintf_func) (info->stream, " {");
              (* info->print_address_func) (val, info);
              (* info->fprintf_func) (info->stream, ", %d}", page);
              format &= ~M6812_OP_PAGE;
              pos += 1;
            }
d745 2
a746 2
                                          0, 1, pc_dst_offset,
                                          memaddr + pos + offset + 1);
d760 2
a761 3
	    {
	      return status;
	    }
d766 2
d772 2
a773 2
         and in that order.  The brset/brclr insn have a bitmask and then
         a relative branch offset.  */
d778 2
a779 3
	    {
	      return status;
	    }
d781 1
a781 1
	  (*info->fprintf_func) (info->stream, " #$%02x%s",
d783 1
a783 1
				 (format & M6811_OP_JUMP_REL ? " " : ""));
d792 1
a792 3
	    {
	      return status;
	    }
d794 1
d806 1
a806 3
	    {
	      return status;
	    }
d813 1
d824 2
a825 3
	    {
	      return status;
	    }
d829 1
a829 1
	  (*info->fprintf_func) (info->stream, ", %d", val);
d834 2
a835 2
         all formats; and the computed size of the insn must match the
         opcode table content.  */
d837 2
a838 3
	{
	  (*info->fprintf_func) (info->stream, "; Error, format: %lx", format);
	}
d840 2
a841 4
	{
	  (*info->fprintf_func) (info->stream, "; Error, size: %ld expect %d",
				 pos, opcode->size);
	}
d849 1
a849 1
    (*info->fprintf_func) (info->stream, "trap\t#%d", code & 0x0ff);
d879 12
@


1.12
log
@Change source files over to GPLv3.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2006, 2007
@


1.11
log
@	* m68hc11-dis.c (print_insn): Warning fix.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2006
d6 16
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.10
log
@Update the address and phone number of the FSF
@
text
@d2 2
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d696 1
a696 1
	  (*info->fprintf_func) (info->stream, "; Error, format: %x", format);
d700 1
a700 1
	  (*info->fprintf_func) (info->stream, "; Error, size: %d expect %d",
@


1.9
log
@	* m68hc11-dis.c: Convert to ISO C90 prototypes.
@
text
@d17 1
a17 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.8
log
@	* m68hc11-dis.c (print_indexed_operand): Fix PC-relative address
	for 9 and 16-bit PC-relative addressing mode.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d42 4
a45 6
static int read_memory
  PARAMS ((bfd_vma, bfd_byte *, int, struct disassemble_info *));
static int print_indexed_operand
  PARAMS ((bfd_vma, struct disassemble_info *, int*, int, int, bfd_vma));
static int print_insn
  PARAMS ((bfd_vma, struct disassemble_info *, int));
d48 2
a49 5
read_memory (memaddr, buffer, size, info)
     bfd_vma memaddr;
     bfd_byte *buffer;
     int size;
     struct disassemble_info *info;
d68 3
a70 7
print_indexed_operand (memaddr, info, indirect, mov_insn, pc_offset, endaddr)
     bfd_vma memaddr;
     struct disassemble_info *info;
     int *indirect;
     int mov_insn;
     int pc_offset;
     bfd_vma endaddr;
d225 1
a225 4
print_insn (memaddr, info, arch)
     bfd_vma memaddr;
     struct disassemble_info *info;
     int arch;
d315 1
a315 1
      int pc_dst_offset;
d708 1
a708 1
      && ((code >= 0x30 && code <= 0x39) || (code >= 0x40 && code <= 0xff)))
d729 1
a729 3
print_insn_m68hc11 (memaddr, info)
     bfd_vma memaddr;
     struct disassemble_info *info;
d735 1
a735 3
print_insn_m68hc12 (memaddr, info)
     bfd_vma memaddr;
     struct disassemble_info *info;
@


1.7
log
@	* m68hc11-dis.c (PC_REGNUM): Define.
	(print_indexed_operand): Need an adjustment for some PC-relative
	operand modes; print the final address of PC-relative modes.
	(print_insn): Take into account movw/movb to adjust the PC-relative
	operand addresses.
@
text
@d186 1
d194 1
@


1.6
log
@	* m68hc11-dis.c (print_insn): Treat bitmask and branch operands
	at the end.
@
text
@d25 2
d45 1
a45 1
  PARAMS ((bfd_vma, struct disassemble_info *, int*, int));
d73 1
a73 1
print_indexed_operand (memaddr, info, indirect, mov_insn)
d78 2
d103 3
d108 7
d164 2
d196 6
d324 2
d447 1
d452 2
d474 1
d480 1
d482 8
a489 1
	  status = print_indexed_operand (memaddr + pos, info, &indirect, 0);
d554 1
d608 3
a610 1
	  status = print_indexed_operand (memaddr + pos + offset, info, 0, 1);
@


1.5
log
@	* m68hc11-dis.c (print_insn): Take into account 68HC12 memory
	banks and fix disassembling of call instruction.
	(print_indexed_operand): New param to tell whether
	it was an indirect addressing operand (for disassembling call).
@
text
@a497 49
      /* M6811_OP_BITMASK and M6811_OP_JUMP_REL must be treated separately
         and in that order.  The brset/brclr insn have a bitmask and then
         a relative branch offset.  */
      if (format & M6811_OP_BITMASK)
	{
	  status = read_memory (memaddr + pos, &buffer[0], 1, info);
	  if (status != 0)
	    {
	      return status;
	    }
	  pos++;
	  (*info->fprintf_func) (info->stream, " #$%02x%s",
				 buffer[0] & 0x0FF,
				 (format & M6811_OP_JUMP_REL ? " " : ""));
	  format &= ~M6811_OP_BITMASK;
	}
      if (format & M6811_OP_JUMP_REL)
	{
	  int val;

	  status = read_memory (memaddr + pos, &buffer[0], 1, info);
	  if (status != 0)
	    {
	      return status;
	    }

	  pos++;
	  val = (buffer[0] & 0x80) ? buffer[0] | 0xFFFFFF00 : buffer[0];
	  (*info->print_address_func) (memaddr + pos + val, info);
	  format &= ~M6811_OP_JUMP_REL;
	}
      else if (format & M6812_OP_JUMP_REL16)
	{
	  int val;

	  status = read_memory (memaddr + pos, &buffer[0], 2, info);
	  if (status != 0)
	    {
	      return status;
	    }

	  pos += 2;
	  val = ((buffer[0] << 8) | (buffer[1] & 0x0FF));
	  if (val & 0x8000)
	    val |= 0xffff0000;

	  (*info->print_address_func) (memaddr + pos + val, info);
	  format &= ~M6812_OP_JUMP_REL16;
	}
d593 50
@


1.5.12.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d498 49
a641 50
	}

      /* M6811_OP_BITMASK and M6811_OP_JUMP_REL must be treated separately
         and in that order.  The brset/brclr insn have a bitmask and then
         a relative branch offset.  */
      if (format & M6811_OP_BITMASK)
	{
	  status = read_memory (memaddr + pos, &buffer[0], 1, info);
	  if (status != 0)
	    {
	      return status;
	    }
	  pos++;
	  (*info->fprintf_func) (info->stream, " #$%02x%s",
				 buffer[0] & 0x0FF,
				 (format & M6811_OP_JUMP_REL ? " " : ""));
	  format &= ~M6811_OP_BITMASK;
	}
      if (format & M6811_OP_JUMP_REL)
	{
	  int val;

	  status = read_memory (memaddr + pos, &buffer[0], 1, info);
	  if (status != 0)
	    {
	      return status;
	    }

	  pos++;
	  val = (buffer[0] & 0x80) ? buffer[0] | 0xFFFFFF00 : buffer[0];
	  (*info->print_address_func) (memaddr + pos + val, info);
	  format &= ~M6811_OP_JUMP_REL;
	}
      else if (format & M6812_OP_JUMP_REL16)
	{
	  int val;

	  status = read_memory (memaddr + pos, &buffer[0], 2, info);
	  if (status != 0)
	    {
	      return status;
	    }

	  pos += 2;
	  val = ((buffer[0] << 8) | (buffer[1] & 0x0FF));
	  if (val & 0x8000)
	    val |= 0xffff0000;

	  (*info->print_address_func) (memaddr + pos + val, info);
	  format &= ~M6812_OP_JUMP_REL16;
@


1.5.12.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a24 2
#define PC_REGNUM 3

d40 6
a45 4
static int read_memory (bfd_vma, bfd_byte *, int, struct disassemble_info *);
static int print_indexed_operand (bfd_vma, struct disassemble_info *,
                                  int*, int, int, bfd_vma);
static int print_insn (bfd_vma, struct disassemble_info *, int);
d48 5
a52 2
read_memory (bfd_vma memaddr, bfd_byte* buffer, int size,
             struct disassemble_info* info)
d71 5
a75 3
print_indexed_operand (bfd_vma memaddr, struct disassemble_info* info,
                       int* indirect, int mov_insn, int pc_offset,
                       bfd_vma endaddr)
a98 3
      /* 68HC12 requires an adjustment for movb/movw pc relative modes.  */
      if (reg == PC_REGNUM && info->mach == bfd_mach_m6812 && mov_insn)
        sval += pc_offset;
a100 7

      if (reg == PC_REGNUM)
        {
          (* info->fprintf_func) (info->stream, " {");
          (* info->print_address_func) (endaddr + sval, info);
          (* info->fprintf_func) (info->stream, "}");
        }
a149 2

  /* n,r with 9 and 16 bit signed constant.  */
a169 1
          endaddr += 2;
a176 1
          endaddr++;
a179 6
      if (reg == PC_REGNUM)
        {
          (* info->fprintf_func) (info->stream, " {");
          (* info->print_address_func) (endaddr + sval, info);
          (* info->fprintf_func) (info->stream, "}");
        }
d210 4
a213 1
print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)
a301 2
      int pc_src_offset;
      int pc_dst_offset = 0;
a422 1
          pc_dst_offset = 2;
a426 2
              /* Set PC destination offset.  */
              pc_dst_offset = 1;
a446 1
#define M6812_DST_MOVE  (M6812_OP_IND16_P2 | M6812_OP_IDX_P2)
a451 1
          bfd_vma endaddr;
d453 1
a453 8
          endaddr = memaddr + pos + 1;
          if (format & M6811_OP_IND16)
            endaddr += 2;
          pc_src_offset = -1;
          pc_dst_offset = 1;
	  status = print_indexed_operand (memaddr + pos, info, &indirect,
                                          (format & M6812_DST_MOVE),
                                          pc_src_offset, endaddr);
a517 1
          pc_dst_offset = 2;
d571 1
a571 3
	  status = print_indexed_operand (memaddr + pos + offset, info,
                                          0, 1, pc_dst_offset,
                                          memaddr + pos + offset + 1);
d679 1
a679 1
      && ((code >= 0x30 && code <= 0x39) || (code >= 0x40)))
d700 3
a702 1
print_insn_m68hc11 (bfd_vma memaddr, struct disassemble_info* info)
d708 3
a710 1
print_insn_m68hc12 (bfd_vma memaddr, struct disassemble_info* info)
@


1.5.10.1
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d498 49
a641 50
	}

      /* M6811_OP_BITMASK and M6811_OP_JUMP_REL must be treated separately
         and in that order.  The brset/brclr insn have a bitmask and then
         a relative branch offset.  */
      if (format & M6811_OP_BITMASK)
	{
	  status = read_memory (memaddr + pos, &buffer[0], 1, info);
	  if (status != 0)
	    {
	      return status;
	    }
	  pos++;
	  (*info->fprintf_func) (info->stream, " #$%02x%s",
				 buffer[0] & 0x0FF,
				 (format & M6811_OP_JUMP_REL ? " " : ""));
	  format &= ~M6811_OP_BITMASK;
	}
      if (format & M6811_OP_JUMP_REL)
	{
	  int val;

	  status = read_memory (memaddr + pos, &buffer[0], 1, info);
	  if (status != 0)
	    {
	      return status;
	    }

	  pos++;
	  val = (buffer[0] & 0x80) ? buffer[0] | 0xFFFFFF00 : buffer[0];
	  (*info->print_address_func) (memaddr + pos + val, info);
	  format &= ~M6811_OP_JUMP_REL;
	}
      else if (format & M6812_OP_JUMP_REL16)
	{
	  int val;

	  status = read_memory (memaddr + pos, &buffer[0], 2, info);
	  if (status != 0)
	    {
	      return status;
	    }

	  pos += 2;
	  val = ((buffer[0] << 8) | (buffer[1] & 0x0FF));
	  if (val & 0x8000)
	    val |= 0xffff0000;

	  (*info->print_address_func) (memaddr + pos + val, info);
	  format &= ~M6812_OP_JUMP_REL16;
@


1.5.10.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a24 2
#define PC_REGNUM 3

d43 1
a43 1
  PARAMS ((bfd_vma, struct disassemble_info *, int*, int, int, bfd_vma));
d71 1
a71 1
print_indexed_operand (memaddr, info, indirect, mov_insn, pc_offset, endaddr)
a75 2
     int pc_offset;
     bfd_vma endaddr;
a98 3
      /* 68HC12 requires an adjustment for movb/movw pc relative modes.  */
      if (reg == PC_REGNUM && info->mach == bfd_mach_m6812 && mov_insn)
        sval += pc_offset;
a100 7

      if (reg == PC_REGNUM)
        {
          (* info->fprintf_func) (info->stream, " {");
          (* info->print_address_func) (endaddr + sval, info);
          (* info->fprintf_func) (info->stream, "}");
        }
a149 2

  /* n,r with 9 and 16 bit signed constant.  */
a169 1
          endaddr += 2;
a176 1
          endaddr++;
a179 6
      if (reg == PC_REGNUM)
        {
          (* info->fprintf_func) (info->stream, " {");
          (* info->print_address_func) (endaddr + sval, info);
          (* info->fprintf_func) (info->stream, "}");
        }
a301 2
      int pc_src_offset;
      int pc_dst_offset;
a422 1
          pc_dst_offset = 2;
a426 2
              /* Set PC destination offset.  */
              pc_dst_offset = 1;
a446 1
#define M6812_DST_MOVE  (M6812_OP_IND16_P2 | M6812_OP_IDX_P2)
a451 1
          bfd_vma endaddr;
d453 1
a453 8
          endaddr = memaddr + pos + 1;
          if (format & M6811_OP_IND16)
            endaddr += 2;
          pc_src_offset = -1;
          pc_dst_offset = 1;
	  status = print_indexed_operand (memaddr + pos, info, &indirect,
                                          (format & M6812_DST_MOVE),
                                          pc_src_offset, endaddr);
a517 1
          pc_dst_offset = 2;
d571 1
a571 3
	  status = print_indexed_operand (memaddr + pos + offset, info,
                                          0, 1, pc_dst_offset,
                                          memaddr + pos + offset + 1);
@


1.5.10.3
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d42 6
a47 4
static int read_memory (bfd_vma, bfd_byte *, int, struct disassemble_info *);
static int print_indexed_operand (bfd_vma, struct disassemble_info *,
                                  int*, int, int, bfd_vma);
static int print_insn (bfd_vma, struct disassemble_info *, int);
d50 5
a54 2
read_memory (bfd_vma memaddr, bfd_byte* buffer, int size,
             struct disassemble_info* info)
d73 7
a79 3
print_indexed_operand (bfd_vma memaddr, struct disassemble_info* info,
                       int* indirect, int mov_insn, int pc_offset,
                       bfd_vma endaddr)
d234 4
a237 1
print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)
d327 1
a327 1
      int pc_dst_offset = 0;
d720 1
a720 1
      && ((code >= 0x30 && code <= 0x39) || (code >= 0x40)))
d741 3
a743 1
print_insn_m68hc11 (bfd_vma memaddr, struct disassemble_info* info)
d749 3
a751 1
print_insn_m68hc12 (bfd_vma memaddr, struct disassemble_info* info)
@


1.5.6.1
log
@	* m68hc11-dis.c (print_insn): Treat bitmask and branch operands
	at the end.
@
text
@d498 49
a641 50
	}

      /* M6811_OP_BITMASK and M6811_OP_JUMP_REL must be treated separately
         and in that order.  The brset/brclr insn have a bitmask and then
         a relative branch offset.  */
      if (format & M6811_OP_BITMASK)
	{
	  status = read_memory (memaddr + pos, &buffer[0], 1, info);
	  if (status != 0)
	    {
	      return status;
	    }
	  pos++;
	  (*info->fprintf_func) (info->stream, " #$%02x%s",
				 buffer[0] & 0x0FF,
				 (format & M6811_OP_JUMP_REL ? " " : ""));
	  format &= ~M6811_OP_BITMASK;
	}
      if (format & M6811_OP_JUMP_REL)
	{
	  int val;

	  status = read_memory (memaddr + pos, &buffer[0], 1, info);
	  if (status != 0)
	    {
	      return status;
	    }

	  pos++;
	  val = (buffer[0] & 0x80) ? buffer[0] | 0xFFFFFF00 : buffer[0];
	  (*info->print_address_func) (memaddr + pos + val, info);
	  format &= ~M6811_OP_JUMP_REL;
	}
      else if (format & M6812_OP_JUMP_REL16)
	{
	  int val;

	  status = read_memory (memaddr + pos, &buffer[0], 2, info);
	  if (status != 0)
	    {
	      return status;
	    }

	  pos += 2;
	  val = ((buffer[0] << 8) | (buffer[1] & 0x0FF));
	  if (val & 0x8000)
	    val |= 0xffff0000;

	  (*info->print_address_func) (memaddr + pos + val, info);
	  format &= ~M6812_OP_JUMP_REL16;
@


1.4
log
@	* m68hc11-dis.c (print_insn): Fix disassembly of movb with a
	constant as source.
@
text
@d2 2
a3 2
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
   Written by Stephane Carrez (stcarrez@@worldnet.fr)
d43 1
a43 1
  PARAMS ((bfd_vma, struct disassemble_info *, int));
d71 1
a71 1
print_indexed_operand (memaddr, info, mov_insn)
d74 1
d83 3
d147 2
d198 2
d451 3
a453 1
	  status = print_indexed_operand (memaddr + pos, info, 0);
d459 5
d550 2
d566 32
d606 9
a614 1
	  (*info->print_address_func) (val, info);
d620 1
a620 1
	  status = print_indexed_operand (memaddr + pos + offset, info, 1);
d644 15
@


1.4.10.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d2 2
a3 2
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
   Written by Stephane Carrez (stcarrez@@nerim.fr)
d43 1
a43 1
  PARAMS ((bfd_vma, struct disassemble_info *, int*, int));
d71 1
a71 1
print_indexed_operand (memaddr, info, indirect, mov_insn)
a73 1
     int *indirect;
a81 3
  if (indirect)
    *indirect = 0;

a142 2
      if (indirect)
        *indirect = 1;
a191 2
          if (indirect)
            *indirect = 1;
d443 1
a443 3
          int indirect;

	  status = print_indexed_operand (memaddr + pos, info, &indirect, 0);
a448 5

          /* The indirect addressing mode of the call instruction does
             not need the page code.  */
          if ((format & M6812_OP_PAGE) && indirect)
            format &= ~M6812_OP_PAGE;
a534 2
          bfd_vma addr;
          unsigned page = 0;
a548 32
          addr = val;
          if (format & M6812_OP_PAGE)
            {
              status = read_memory (memaddr + pos + offset, buffer, 1, info);
              if (status != 0)
                return status;

              page = (unsigned) buffer[0];
              if (addr >= M68HC12_BANK_BASE && addr < 0x0c000)
                addr = ((val - M68HC12_BANK_BASE)
                        | (page << M68HC12_BANK_SHIFT))
                   + M68HC12_BANK_VIRT;
            }
          else if ((arch & cpu6812)
                   && addr >= M68HC12_BANK_BASE && addr < 0x0c000)
             {
                int cur_page;
                bfd_vma vaddr;
                
                if (memaddr >= M68HC12_BANK_VIRT)
                   cur_page = ((memaddr - M68HC12_BANK_VIRT)
                               >> M68HC12_BANK_SHIFT);
                else
                   cur_page = 0;

                vaddr = ((addr - M68HC12_BANK_BASE)
                         + (cur_page << M68HC12_BANK_SHIFT))
                   + M68HC12_BANK_VIRT;
                if (!info->symbol_at_address_func (addr, info)
                    && info->symbol_at_address_func (vaddr, info))
                   addr = vaddr;
             }
d557 1
a557 9
	  (*info->print_address_func) (addr, info);
          if (format & M6812_OP_PAGE)
            {
              (* info->fprintf_func) (info->stream, " {");
              (* info->print_address_func) (val, info);
              (* info->fprintf_func) (info->stream, ", %d}", page);
              format &= ~M6812_OP_PAGE;
              pos += 1;
            }
d563 1
a563 1
	  status = print_indexed_operand (memaddr + pos + offset, info, 0, 1);
a586 15
      if (format & M6812_OP_PAGE)
	{
	  int val;

	  status = read_memory (memaddr + pos + offset, &buffer[0], 1, info);
	  if (status != 0)
	    {
	      return status;
	    }
	  pos += 1;

	  val = buffer[0] & 0x0ff;
	  (*info->fprintf_func) (info->stream, ", %d", val);
	}
      
@


1.4.10.2
log
@merge from mainline
@
text
@d498 49
a641 50
	}

      /* M6811_OP_BITMASK and M6811_OP_JUMP_REL must be treated separately
         and in that order.  The brset/brclr insn have a bitmask and then
         a relative branch offset.  */
      if (format & M6811_OP_BITMASK)
	{
	  status = read_memory (memaddr + pos, &buffer[0], 1, info);
	  if (status != 0)
	    {
	      return status;
	    }
	  pos++;
	  (*info->fprintf_func) (info->stream, " #$%02x%s",
				 buffer[0] & 0x0FF,
				 (format & M6811_OP_JUMP_REL ? " " : ""));
	  format &= ~M6811_OP_BITMASK;
	}
      if (format & M6811_OP_JUMP_REL)
	{
	  int val;

	  status = read_memory (memaddr + pos, &buffer[0], 1, info);
	  if (status != 0)
	    {
	      return status;
	    }

	  pos++;
	  val = (buffer[0] & 0x80) ? buffer[0] | 0xFFFFFF00 : buffer[0];
	  (*info->print_address_func) (memaddr + pos + val, info);
	  format &= ~M6811_OP_JUMP_REL;
	}
      else if (format & M6812_OP_JUMP_REL16)
	{
	  int val;

	  status = read_memory (memaddr + pos, &buffer[0], 2, info);
	  if (status != 0)
	    {
	      return status;
	    }

	  pos += 2;
	  val = ((buffer[0] << 8) | (buffer[1] & 0x0FF));
	  if (val & 0x8000)
	    val |= 0xffff0000;

	  (*info->print_address_func) (memaddr + pos + val, info);
	  format &= ~M6812_OP_JUMP_REL16;
@


1.3
log
@	* m68hc11-dis.c: Add missing prototypes.
(forgotten in last checkin)
@
text
@d369 29
a397 8
      /* The movb and movw must be handled in a special way...  */
      offset = 0;
      if (format & (M6812_OP_IDX_P2 | M6812_OP_IND16_P2))
	{
	  if ((format & M6812_OP_IDX_P2)
	      && (format & (M6811_OP_IMM8 | M6811_OP_IMM16 | M6811_OP_IND16)))
	    offset = 1;
	}
d411 4
a414 1
	  offset = -1;
@


1.2
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d2 1
a2 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
d38 8
@


1.1
log
@Applied Stephane Carrez <Stephane.Carrez@@worldnet.fr> patches to add support
for m68hc11 and m68hc12 processors.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000 Free Software Foundation, Inc.
@


1.1.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
@


1.1.2.2
log
@	* m68hc11-dis.c (print_insn): Fix disassembly of movb with a
	constant as source.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
d361 8
a368 29
      /* The movb and movw must be handled in a special way...
         The source constant 'ii' is not always at the same place.
         This is the same for the destination for the post-indexed byte.
         The 'offset' is used to do the appropriate correction.

                                   offset          offset
                              for constant     for destination
         movb   18 OB ii hh ll       0          0
                18 08 xb ii          1          -1
                18 0C hh ll hh ll    0          0
                18 09 xb hh ll       1          -1
                18 0D xb hh ll       0          0
                18 0A xb xb          0          0

         movw   18 03 jj kk hh ll    0          0
                18 00 xb jj kk       1          -1
                18 04 hh ll hh ll    0          0
                18 01 xb hh ll       1          -1
                18 05 xb hh ll       0          0
                18 02 xb xb          0          0

         After the source operand is read, the position 'pos' is incremented
         this explains the negative offset for destination.

         movb/movw above are the only instructions with this matching
         format.  */
      offset = ((format & M6812_OP_IDX_P2)
                && (format & (M6811_OP_IMM8 | M6811_OP_IMM16 |
                              M6811_OP_IND16)));
d382 1
a382 4

          /* This movb/movw is special (see above).  */
          offset = -offset;

@


