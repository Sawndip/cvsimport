head	1.18;
access;
symbols
	sid-snapshot-20180601:1.18
	sid-snapshot-20180501:1.18
	sid-snapshot-20180401:1.18
	sid-snapshot-20180301:1.18
	sid-snapshot-20180201:1.18
	sid-snapshot-20180101:1.18
	sid-snapshot-20171201:1.18
	sid-snapshot-20171101:1.18
	sid-snapshot-20171001:1.18
	sid-snapshot-20170901:1.18
	sid-snapshot-20170801:1.18
	sid-snapshot-20170701:1.18
	sid-snapshot-20170601:1.18
	sid-snapshot-20170501:1.18
	sid-snapshot-20170401:1.18
	sid-snapshot-20170301:1.18
	sid-snapshot-20170201:1.18
	sid-snapshot-20170101:1.18
	sid-snapshot-20161201:1.18
	sid-snapshot-20161101:1.18
	sid-snapshot-20160901:1.18
	sid-snapshot-20160801:1.18
	sid-snapshot-20160701:1.18
	sid-snapshot-20160601:1.18
	sid-snapshot-20160501:1.18
	sid-snapshot-20160401:1.18
	sid-snapshot-20160301:1.18
	sid-snapshot-20160201:1.18
	sid-snapshot-20160101:1.18
	sid-snapshot-20151201:1.18
	sid-snapshot-20151101:1.18
	sid-snapshot-20151001:1.18
	sid-snapshot-20150901:1.18
	sid-snapshot-20150801:1.18
	sid-snapshot-20150701:1.18
	sid-snapshot-20150601:1.18
	sid-snapshot-20150501:1.18
	sid-snapshot-20150401:1.18
	sid-snapshot-20150301:1.18
	sid-snapshot-20150201:1.18
	sid-snapshot-20150101:1.18
	sid-snapshot-20141201:1.18
	sid-snapshot-20141101:1.18
	sid-snapshot-20141001:1.18
	sid-snapshot-20140901:1.18
	sid-snapshot-20140801:1.18
	sid-snapshot-20140701:1.18
	sid-snapshot-20140601:1.18
	sid-snapshot-20140501:1.18
	sid-snapshot-20140401:1.18
	sid-snapshot-20140301:1.18
	sid-snapshot-20140201:1.18
	sid-snapshot-20140101:1.18
	sid-snapshot-20131201:1.18
	sid-snapshot-20131101:1.18
	sid-snapshot-20131001:1.18
	binutils-2_24-branch:1.18.0.2
	binutils-2_24-branchpoint:1.18
	binutils-2_21_1:1.12
	sid-snapshot-20130901:1.18
	gdb_7_6_1-2013-08-30-release:1.17
	sid-snapshot-20130801:1.18
	sid-snapshot-20130701:1.18
	sid-snapshot-20130601:1.18
	sid-snapshot-20130501:1.18
	gdb_7_6-2013-04-26-release:1.17
	sid-snapshot-20130401:1.17
	binutils-2_23_2:1.15
	gdb_7_6-branch:1.17.0.2
	gdb_7_6-2013-03-12-branchpoint:1.17
	sid-snapshot-20130301:1.17
	sid-snapshot-20130201:1.17
	sid-snapshot-20130101:1.15
	sid-snapshot-20121201:1.15
	gdb_7_5_1-2012-11-29-release:1.15
	binutils-2_23_1:1.15
	sid-snapshot-20121101:1.15
	binutils-2_23:1.15
	sid-snapshot-20121001:1.15
	sid-snapshot-20120901:1.15
	gdb_7_5-2012-08-17-release:1.15
	sid-snapshot-20120801:1.15
	binutils-2_23-branch:1.15.0.4
	binutils-2_23-branchpoint:1.15
	gdb_7_5-branch:1.15.0.2
	gdb_7_5-2012-07-18-branchpoint:1.15
	sid-snapshot-20120701:1.15
	sid-snapshot-20120601:1.15
	sid-snapshot-20120501:1.14
	binutils-2_22_branch:1.13.0.6
	gdb_7_4_1-2012-04-26-release:1.13
	sid-snapshot-20120401:1.14
	sid-snapshot-20120301:1.14
	sid-snapshot-20120201:1.13
	gdb_7_4-2012-01-24-release:1.13
	sid-snapshot-20120101:1.13
	gdb_7_4-branch:1.13.0.4
	gdb_7_4-2011-12-13-branchpoint:1.13
	sid-snapshot-20111201:1.13
	binutils-2_22:1.13
	sid-snapshot-20111101:1.13
	sid-snapshot-20111001:1.13
	binutils-2_22-branch:1.13.0.2
	binutils-2_22-branchpoint:1.13
	gdb_7_3_1-2011-09-04-release:1.12
	sid-snapshot-20110901:1.13
	sid-snapshot-20110801:1.13
	gdb_7_3-2011-07-26-release:1.12
	sid-snapshot-20110701:1.13
	sid-snapshot-20110601:1.13
	sid-snapshot-20110501:1.12
	gdb_7_3-branch:1.12.0.4
	gdb_7_3-2011-04-01-branchpoint:1.12
	sid-snapshot-20110401:1.12
	sid-snapshot-20110301:1.12
	sid-snapshot-20110201:1.12
	sid-snapshot-20110101:1.12
	binutils-2_21:1.12
	sid-snapshot-20101201:1.12
	binutils-2_21-branch:1.12.0.2
	binutils-2_21-branchpoint:1.12
	sid-snapshot-20101101:1.12
	sid-snapshot-20101001:1.12
	binutils-2_20_1:1.11
	gdb_7_2-2010-09-02-release:1.11
	sid-snapshot-20100901:1.12
	sid-snapshot-20100801:1.12
	gdb_7_2-branch:1.11.0.38
	gdb_7_2-2010-07-07-branchpoint:1.11
	sid-snapshot-20100701:1.11
	sid-snapshot-20100601:1.11
	sid-snapshot-20100501:1.11
	sid-snapshot-20100401:1.11
	gdb_7_1-2010-03-18-release:1.11
	sid-snapshot-20100301:1.11
	gdb_7_1-branch:1.11.0.36
	gdb_7_1-2010-02-18-branchpoint:1.11
	sid-snapshot-20100201:1.11
	sid-snapshot-20100101:1.11
	gdb_7_0_1-2009-12-22-release:1.11
	sid-snapshot-20091201:1.11
	sid-snapshot-20091101:1.11
	binutils-2_20:1.11
	gdb_7_0-2009-10-06-release:1.11
	sid-snapshot-20091001:1.11
	gdb_7_0-branch:1.11.0.34
	gdb_7_0-2009-09-16-branchpoint:1.11
	arc-sim-20090309:1.11
	binutils-arc-20081103-branch:1.11.0.32
	binutils-arc-20081103-branchpoint:1.11
	binutils-2_20-branch:1.11.0.30
	binutils-2_20-branchpoint:1.11
	sid-snapshot-20090901:1.11
	sid-snapshot-20090801:1.11
	msnyder-checkpoint-072509-branch:1.11.0.28
	msnyder-checkpoint-072509-branchpoint:1.11
	sid-snapshot-20090701:1.11
	dje-cgen-play1-branch:1.11.0.26
	dje-cgen-play1-branchpoint:1.11
	sid-snapshot-20090601:1.11
	sid-snapshot-20090501:1.11
	sid-snapshot-20090401:1.11
	arc-20081103-branch:1.11.0.24
	arc-20081103-branchpoint:1.11
	arc-insight_6_8-branch:1.11.0.22
	arc-insight_6_8-branchpoint:1.11
	insight_6_8-branch:1.11.0.20
	insight_6_8-branchpoint:1.11
	sid-snapshot-20090301:1.11
	binutils-2_19_1:1.11
	sid-snapshot-20090201:1.11
	sid-snapshot-20090101:1.11
	reverse-20081226-branch:1.11.0.18
	reverse-20081226-branchpoint:1.11
	sid-snapshot-20081201:1.11
	multiprocess-20081120-branch:1.11.0.16
	multiprocess-20081120-branchpoint:1.11
	sid-snapshot-20081101:1.11
	binutils-2_19:1.11
	sid-snapshot-20081001:1.11
	reverse-20080930-branch:1.11.0.14
	reverse-20080930-branchpoint:1.11
	binutils-2_19-branch:1.11.0.12
	binutils-2_19-branchpoint:1.11
	sid-snapshot-20080901:1.11
	sid-snapshot-20080801:1.11
	reverse-20080717-branch:1.11.0.10
	reverse-20080717-branchpoint:1.11
	sid-snapshot-20080701:1.11
	msnyder-reverse-20080609-branch:1.11.0.8
	msnyder-reverse-20080609-branchpoint:1.11
	drow-reverse-20070409-branch:1.10.0.32
	drow-reverse-20070409-branchpoint:1.10
	sid-snapshot-20080601:1.11
	sid-snapshot-20080501:1.11
	sid-snapshot-20080403:1.11
	sid-snapshot-20080401:1.11
	gdb_6_8-2008-03-27-release:1.11
	sid-snapshot-20080301:1.11
	gdb_6_8-branch:1.11.0.6
	gdb_6_8-2008-02-26-branchpoint:1.11
	sid-snapshot-20080201:1.11
	sid-snapshot-20080101:1.11
	sid-snapshot-20071201:1.11
	sid-snapshot-20071101:1.11
	gdb_6_7_1-2007-10-29-release:1.11
	gdb_6_7-2007-10-10-release:1.11
	sid-snapshot-20071001:1.11
	gdb_6_7-branch:1.11.0.4
	gdb_6_7-2007-09-07-branchpoint:1.11
	binutils-2_18:1.11
	binutils-2_18-branch:1.11.0.2
	binutils-2_18-branchpoint:1.11
	insight_6_6-20070208-release:1.10
	binutils-csl-coldfire-4_1-32:1.10
	binutils-csl-sourcerygxx-4_1-32:1.10
	gdb_6_6-2006-12-18-release:1.10
	binutils-csl-innovasic-fido-3_4_4-33:1.10
	binutils-csl-sourcerygxx-3_4_4-32:1.8
	binutils-csl-coldfire-4_1-30:1.10
	binutils-csl-sourcerygxx-4_1-30:1.10
	binutils-csl-coldfire-4_1-28:1.10
	binutils-csl-sourcerygxx-4_1-29:1.10
	binutils-csl-sourcerygxx-4_1-28:1.10
	gdb_6_6-branch:1.10.0.30
	gdb_6_6-2006-11-15-branchpoint:1.10
	binutils-csl-arm-2006q3-27:1.10
	binutils-csl-sourcerygxx-4_1-27:1.10
	binutils-csl-arm-2006q3-26:1.10
	binutils-csl-sourcerygxx-4_1-26:1.10
	binutils-csl-sourcerygxx-4_1-25:1.10
	binutils-csl-sourcerygxx-4_1-24:1.10
	binutils-csl-sourcerygxx-4_1-23:1.10
	insight_6_5-20061003-release:1.10
	gdb-csl-symbian-6_4_50_20060226-12:1.10
	binutils-csl-sourcerygxx-4_1-21:1.10
	binutils-csl-arm-2006q3-21:1.10
	binutils-csl-sourcerygxx-4_1-22:1.10
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.10
	binutils-csl-sourcerygxx-4_1-20:1.10
	binutils-csl-arm-2006q3-19:1.10
	binutils-csl-sourcerygxx-4_1-19:1.10
	binutils-csl-sourcerygxx-4_1-18:1.10
	binutils-csl-renesas-4_1-9:1.10
	gdb-csl-sourcerygxx-3_4_4-25:1.10
	binutils-csl-sourcerygxx-3_4_4-25:1.8
	nickrob-async-20060828-mergepoint:1.10
	gdb-csl-symbian-6_4_50_20060226-11:1.10
	binutils-csl-renesas-4_1-8:1.10
	binutils-csl-renesas-4_1-7:1.10
	binutils-csl-renesas-4_1-6:1.10
	gdb-csl-sourcerygxx-4_1-17:1.10
	binutils-csl-sourcerygxx-4_1-17:1.10
	gdb-csl-20060226-branch-local-2:1.10
	gdb-csl-sourcerygxx-4_1-14:1.10
	binutils-csl-sourcerygxx-4_1-14:1.10
	binutils-csl-sourcerygxx-4_1-15:1.10
	gdb-csl-sourcerygxx-4_1-13:1.10
	binutils-csl-sourcerygxx-4_1-13:1.10
	binutils-2_17:1.10
	gdb-csl-sourcerygxx-4_1-12:1.10
	binutils-csl-sourcerygxx-4_1-12:1.10
	gdb-csl-sourcerygxx-3_4_4-21:1.10
	binutils-csl-sourcerygxx-3_4_4-21:1.10
	gdb_6_5-20060621-release:1.10
	binutils-csl-wrs-linux-3_4_4-24:1.8
	binutils-csl-wrs-linux-3_4_4-23:1.8
	gdb-csl-sourcerygxx-4_1-9:1.10
	binutils-csl-sourcerygxx-4_1-9:1.10
	gdb-csl-sourcerygxx-4_1-8:1.10
	binutils-csl-sourcerygxx-4_1-8:1.10
	gdb-csl-sourcerygxx-4_1-7:1.10
	binutils-csl-sourcerygxx-4_1-7:1.10
	gdb-csl-arm-2006q1-6:1.10
	binutils-csl-arm-2006q1-6:1.10
	gdb-csl-sourcerygxx-4_1-6:1.10
	binutils-csl-sourcerygxx-4_1-6:1.10
	binutils-csl-wrs-linux-3_4_4-22:1.8
	gdb-csl-symbian-6_4_50_20060226-10:1.10
	gdb-csl-symbian-6_4_50_20060226-9:1.10
	gdb-csl-symbian-6_4_50_20060226-8:1.10
	gdb-csl-coldfire-4_1-11:1.10
	binutils-csl-coldfire-4_1-11:1.10
	gdb-csl-sourcerygxx-3_4_4-19:1.10
	binutils-csl-sourcerygxx-3_4_4-19:1.10
	gdb-csl-coldfire-4_1-10:1.10
	gdb_6_5-branch:1.10.0.28
	gdb_6_5-2006-05-14-branchpoint:1.10
	binutils-csl-coldfire-4_1-10:1.10
	gdb-csl-sourcerygxx-4_1-5:1.10
	binutils-csl-sourcerygxx-4_1-5:1.10
	nickrob-async-20060513-branch:1.10.0.26
	nickrob-async-20060513-branchpoint:1.10
	gdb-csl-sourcerygxx-4_1-4:1.10
	binutils-csl-sourcerygxx-4_1-4:1.10
	msnyder-reverse-20060502-branch:1.10.0.24
	msnyder-reverse-20060502-branchpoint:1.10
	binutils-csl-wrs-linux-3_4_4-21:1.8
	gdb-csl-morpho-4_1-4:1.10
	binutils-csl-morpho-4_1-4:1.10
	gdb-csl-sourcerygxx-3_4_4-17:1.10
	binutils-csl-sourcerygxx-3_4_4-17:1.10
	binutils-csl-wrs-linux-3_4_4-20:1.8
	readline_5_1-import-branch:1.10.0.22
	readline_5_1-import-branchpoint:1.10
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.10
	binutils-2_17-branch:1.10.0.20
	binutils-2_17-branchpoint:1.10
	gdb-csl-symbian-20060226-branch:1.10.0.18
	gdb-csl-symbian-20060226-branchpoint:1.10
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.10
	msnyder-reverse-20060331-branch:1.10.0.16
	msnyder-reverse-20060331-branchpoint:1.10
	binutils-csl-2_17-branch:1.10.0.14
	binutils-csl-2_17-branchpoint:1.10
	gdb-csl-available-20060303-branch:1.10.0.12
	gdb-csl-available-20060303-branchpoint:1.10
	gdb-csl-20060226-branch:1.10.0.10
	gdb-csl-20060226-branchpoint:1.10
	gdb_6_4-20051202-release:1.10
	msnyder-fork-checkpoint-branch:1.10.0.8
	msnyder-fork-checkpoint-branchpoint:1.10
	gdb-csl-gxxpro-6_3-branch:1.10.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.10
	gdb_6_4-branch:1.10.0.4
	gdb_6_4-2005-11-01-branchpoint:1.10
	gdb-csl-arm-20051020-branch:1.10.0.2
	gdb-csl-arm-20051020-branchpoint:1.10
	binutils-csl-gxxpro-3_4-branch:1.8.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.8
	binutils-2_16_1:1.8
	msnyder-tracepoint-checkpoint-branch:1.9.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.9
	gdb-csl-arm-20050325-2005-q1b:1.8
	binutils-csl-arm-2005q1b:1.8
	binutils-2_16:1.8
	gdb-csl-arm-20050325-2005-q1a:1.8
	binutils-csl-arm-2005q1a:1.8
	csl-arm-20050325-branch:1.8.0.6
	csl-arm-20050325-branchpoint:1.8
	binutils-csl-arm-2005q1-branch:1.8.0.4
	binutils-csl-arm-2005q1-branchpoint:1.8
	binutils-2_16-branch:1.8.0.2
	binutils-2_16-branchpoint:1.8
	csl-arm-2004-q3d:1.7
	gdb_6_3-20041109-release:1.7
	gdb_6_3-branch:1.7.0.22
	gdb_6_3-20041019-branchpoint:1.7
	csl-arm-2004-q3:1.7
	drow_intercu-merge-20040921:1.7
	drow_intercu-merge-20040915:1.7
	jimb-gdb_6_2-e500-branch:1.7.0.24
	jimb-gdb_6_2-e500-branchpoint:1.7
	gdb_6_2-20040730-release:1.7
	gdb_6_2-branch:1.7.0.20
	gdb_6_2-2004-07-10-gmt-branchpoint:1.7
	gdb_6_1_1-20040616-release:1.7
	binutils-2_15:1.7
	binutils-2_15-branchpoint:1.7
	csl-arm-2004-q1a:1.7
	csl-arm-2004-q1:1.7
	gdb_6_1-2004-04-05-release:1.7
	drow_intercu-merge-20040402:1.7
	drow_intercu-merge-20040327:1.7
	ezannoni_pie-20040323-branch:1.7.0.18
	ezannoni_pie-20040323-branchpoint:1.7
	cagney_tramp-20040321-mergepoint:1.7
	cagney_tramp-20040309-branch:1.7.0.16
	cagney_tramp-20040309-branchpoint:1.7
	gdb_6_1-branch:1.7.0.14
	gdb_6_1-2004-03-01-gmt-branchpoint:1.7
	drow_intercu-20040221-branch:1.7.0.12
	drow_intercu-20040221-branchpoint:1.7
	binutils-2_15-branch:1.7.0.10
	cagney_bfdfile-20040213-branch:1.7.0.8
	cagney_bfdfile-20040213-branchpoint:1.7
	drow-cplus-merge-20040208:1.7
	carlton_dictionary-20040126-merge:1.7
	cagney_bigcore-20040122-branch:1.7.0.6
	cagney_bigcore-20040122-branchpoint:1.7
	drow-cplus-merge-20040113:1.7
	csl-arm-2003-q4:1.7
	drow-cplus-merge-20031224:1.7
	drow-cplus-merge-20031220:1.7
	carlton_dictionary-20031215-merge:1.7
	drow-cplus-merge-20031214:1.7
	carlton-dictionary-20031111-merge:1.7
	gdb_6_0-2003-10-04-release:1.6
	kettenis_sparc-20030918-branch:1.7.0.4
	kettenis_sparc-20030918-branchpoint:1.7
	carlton_dictionary-20030917-merge:1.7
	ezannoni_pie-20030916-branchpoint:1.7
	ezannoni_pie-20030916-branch:1.7.0.2
	cagney_x86i386-20030821-branch:1.6.0.46
	cagney_x86i386-20030821-branchpoint:1.6
	carlton_dictionary-20030805-merge:1.6
	carlton_dictionary-20030627-merge:1.6
	gdb_6_0-branch:1.6.0.44
	gdb_6_0-2003-06-23-branchpoint:1.6
	jimb-ppc64-linux-20030613-branch:1.6.0.42
	jimb-ppc64-linux-20030613-branchpoint:1.6
	binutils-2_14:1.6
	cagney_convert-20030606-branch:1.6.0.40
	cagney_convert-20030606-branchpoint:1.6
	cagney_writestrings-20030508-branch:1.6.0.38
	cagney_writestrings-20030508-branchpoint:1.6
	jimb-ppc64-linux-20030528-branch:1.6.0.36
	jimb-ppc64-linux-20030528-branchpoint:1.6
	carlton_dictionary-20030523-merge:1.6
	cagney_fileio-20030521-branch:1.6.0.34
	cagney_fileio-20030521-branchpoint:1.6
	kettenis_i386newframe-20030517-mergepoint:1.6
	jimb-ppc64-linux-20030509-branch:1.6.0.32
	jimb-ppc64-linux-20030509-branchpoint:1.6
	kettenis_i386newframe-20030504-mergepoint:1.6
	carlton_dictionary-20030430-merge:1.6
	binutils-2_14-branch:1.6.0.30
	binutils-2_14-branchpoint:1.6
	kettenis_i386newframe-20030419-branch:1.6.0.28
	kettenis_i386newframe-20030419-branchpoint:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.6
	kettenis_i386newframe-20030406-branch:1.6.0.26
	kettenis_i386newframe-20030406-branchpoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.24
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.22
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.20
	cagney_lazyid-20030317-branchpoint:1.6
	kettenis-i386newframe-20030316-mergepoint:1.6
	offbyone-20030313-branch:1.6.0.18
	offbyone-20030313-branchpoint:1.6
	kettenis-i386newframe-20030308-branch:1.6.0.16
	kettenis-i386newframe-20030308-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.14
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.6
	interps-20030202-branch:1.6.0.12
	interps-20030202-branchpoint:1.6
	cagney-unwind-20030108-branch:1.6.0.10
	cagney-unwind-20030108-branchpoint:1.6
	binutils-2_13_2_1:1.5
	binutils-2_13_2:1.5
	carlton_dictionary-20021223-merge:1.6
	gdb_5_3-2002-12-12-release:1.6
	carlton_dictionary-20021115-merge:1.6
	binutils-2_13_1:1.5
	kseitz_interps-20021105-merge:1.6
	kseitz_interps-20021103-merge:1.6
	drow-cplus-merge-20021020:1.6
	drow-cplus-merge-20021025:1.6
	carlton_dictionary-20021025-merge:1.6
	carlton_dictionary-20021011-merge:1.6
	drow-cplus-branch:1.6.0.8
	drow-cplus-branchpoint:1.6
	kseitz_interps-20020930-merge:1.6
	carlton_dictionary-20020927-merge:1.6
	carlton_dictionary-branch:1.6.0.6
	carlton_dictionary-20020920-branchpoint:1.6
	sid-20020905-branchpoint:1.6
	sid-20020905-branch:1.6.0.4
	gdb_5_3-branch:1.6.0.2
	gdb_5_3-2002-09-04-branchpoint:1.6
	kseitz_interps-20020829-merge:1.5
	cagney_sysregs-20020825-branch:1.5.0.16
	cagney_sysregs-20020825-branchpoint:1.5
	readline_4_3-import-branch:1.5.0.14
	readline_4_3-import-branchpoint:1.5
	binutils-2_13:1.5
	gdb_5_2_1-2002-07-23-release:1.5
	binutils-2_13-branchpoint:1.5
	binutils-2_13-branch:1.5.0.12
	kseitz_interps-20020528-branch:1.5.0.10
	kseitz_interps-20020528-branchpoint:1.5
	cagney_regbuf-20020515-branch:1.5.0.8
	cagney_regbuf-20020515-branchpoint:1.5
	binutils-2_12_1:1.5
	jimb-macro-020506-branch:1.5.0.6
	jimb-macro-020506-branchpoint:1.5
	gdb_5_2-2002-04-29-release:1.5
	binutils-2_12:1.5
	gdb_5_2-branch:1.5.0.4
	gdb_5_2-2002-03-03-branchpoint:1.5
	binutils-2_12-branch:1.5.0.2
	binutils-2_12-branchpoint:1.5
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	cygnus_cvs_20020108_pre:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.4
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.2
	gdb_5_1-2001-07-29-branchpoint:1.3
	binutils-2_11_2:1.2.4.1
	binutils-2_11_1:1.2.4.1
	binutils-2_11:1.2
	x86_64versiong3:1.2
	binutils-2_11-branch:1.2.0.4
	insight-precleanup-2001-01-01:1.2
	binutils-2_10_1:1.1.1.1.2.1
	binutils-2_10:1.1.1.1.2.1
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.18
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2013.04.03.14.42.10;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2013.01.24.11.14.05;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2013.01.15.08.45.45;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2012.05.17.15.13.26;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2012.02.27.06.55.39;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2011.05.19.11.10.59;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2010.07.23.14.52.54;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2007.07.05.09.49.02;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2005.07.01.11.16.33;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.07.07.34.31;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.03.11.49.50;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.04.11.04.38;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.02.11.44.39;	author nickc;	state Exp;
branches
	1.6.6.1
	1.6.8.1;
next	1.5;

1.5
date	2001.09.20.15.28.25;	author nickc;	state Exp;
branches
	1.5.10.1;
next	1.4;

1.4
date	2001.08.26.11.47.38;	author aj;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.13.22.58.37;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.14.04.16.58;	author amodra;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	99.05.03.07.29.00;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.6.6.1
date	2003.09.17.21.29.00;	author carlton;	state Exp;
branches;
next	;

1.6.8.1
date	2003.12.14.20.28.10;	author drow;	state Exp;
branches;
next	;

1.5.10.1
date	2002.10.01.00.46.45;	author kseitz;	state Exp;
branches;
next	;

1.2.4.1
date	2001.06.07.03.18.37;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.00;	author rth;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	2000.05.06.14.49.26;	author pb;	state Exp;
branches;
next	;


desc
@@


1.18
log
@	* elf32-v850.c (v850_elf_is_target_special_symbol): New function.
	(bfd_elf32_bfd_is_target_special_symbol): Define.

	* v850.h (V850_INVERSE_PCREL): Define.

	* v850-dis.c (print_value): With V850_INVERSE_PCREL compute the
	destination address by subtracting the operand from the current
	address.
	* v850-opc.c (insert_u16_loop): Disallow negative offsets.  Store
	a positive value in the insn.
	(extract_u16_loop): Do not negate the returned value.
	(D16_LOOP): Add V850_INVERSE_PCREL flag.

	(ceilf.sw): Remove duplicate entry.
	(cvtf.hs): New entry.
	(cvtf.sh): Likewise.
	(fmaf.s): Likewise.
	(fmsf.s): Likewise.
	(fnmaf.s): Likewise.
	(fnmsf.s): Likewise.
	(maddf.s): Restrict to E3V5 architectures.
	(msubf.s): Likewise.
	(nmaddf.s): Likewise.
	(nmsubf.s): Likewise.
@
text
@/* Assemble V850 instructions.
   Copyright 1996-2013 Free Software Foundation, Inc.

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include <stdio.h>
#include "opcode/v850.h"
#include "bfd.h"
#include "opintl.h"

/* Regular opcodes.  */
#define OP(x)		((x & 0x3f) << 5)
#define OP_MASK		OP (0x3f)

/* Conditional branch opcodes (Format III).  */
#define BOP(x)		((0x58 << 4) | (x & 0x0f))
#define BOP_MASK	((0x78 << 4) | 0x0f)

/* Conditional branch opcodes (Format VII).  */
#define BOP7(x)		(0x107e0 | (x & 0xf))
#define BOP7_MASK	(0x1ffe0 | 0xf)

/* One-word opcodes.  */
#define one(x)		((unsigned int) (x))

/* Two-word opcodes.  */
#define two(x,y)	((unsigned int) (x) | ((unsigned int) (y) << 16))


/* The functions used to insert and extract complicated operands.  */

/* Note: There is a conspiracy between these functions and
   v850_insert_operand() in gas/config/tc-v850.c.  Error messages
   containing the string 'out of range' will be ignored unless a
   specific command line option is given to GAS.  */

static const char * not_valid    = N_ ("displacement value is not in range and is not aligned");
static const char * out_of_range = N_ ("displacement value is out of range");
static const char * not_aligned  = N_ ("displacement value is not aligned");

static const char * immediate_out_of_range = N_ ("immediate value is out of range");
static const char * branch_out_of_range = N_ ("branch value out of range");
static const char * branch_out_of_range_and_odd_offset = N_ ("branch value not in range and to odd offset");
static const char * branch_to_odd_offset = N_ ("branch to odd offset");
static const char * pos_out_of_range = N_ ("position value is out of range");
static const char * width_out_of_range = N_ ("width value is out of range");
static const char * selid_out_of_range = N_ ("SelID is out of range");
static const char * vector8_out_of_range = N_ ("vector8 is out of range");
static const char * vector5_out_of_range = N_ ("vector5 is out of range");
static const char * imm10_out_of_range = N_ ("imm10 is out of range");
static const char * sr_selid_out_of_range = N_ ("SR/SelID is out of range");

int
v850_msg_is_out_of_range (const char* msg)
{
  return msg == out_of_range
    || msg == immediate_out_of_range
    || msg == branch_out_of_range;
}

static unsigned long
insert_i5div1 (unsigned long insn, long value, const char ** errmsg)
{
  if (value > 30 || value < 2)
    {
      if (value & 1)
	* errmsg = _(not_valid);
      else
	* errmsg = _(out_of_range);
    }
  else if (value & 1)
    * errmsg = _(not_aligned);

  value = (32 - value)/2;

  return (insn | ((value << (2+16)) & 0x3c0000));
}

static unsigned long
extract_i5div1 (unsigned long insn, int * invalid)
{
  unsigned long ret = (insn & 0x003c0000) >> (16+2);
  ret = 32 - (ret * 2);

  if (invalid != 0)
    *invalid = (ret > 30 || ret < 2) ? 1 : 0;
  return ret;
}

static unsigned long
insert_i5div2 (unsigned long insn, long value, const char ** errmsg)
{
  if (value > 30 || value < 4)
    {
      if (value & 1)
	* errmsg = _(not_valid);
      else
	* errmsg = _(out_of_range);
    }
  else if (value & 1)
    * errmsg = _(not_aligned);

  value = (32 - value)/2;

  return insn | ((value << (2 + 16)) & 0x3c0000);
}

static unsigned long
extract_i5div2 (unsigned long insn, int * invalid)
{
  unsigned long ret = (insn & 0x003c0000) >> (16+2);
  ret = 32 - (ret * 2);

  if (invalid != 0)
    *invalid = (ret > 30 || ret < 4) ? 1 : 0;
  return ret;
}

static unsigned long
insert_i5div3 (unsigned long insn, long value, const char ** errmsg)
{
  if (value > 32 || value < 2)
    {
      if (value & 1)
	* errmsg = _(not_valid);
      else
	* errmsg = _(out_of_range);
    }
  else if (value & 1)
    * errmsg = _(not_aligned);

  value = (32 - value)/2;

  return insn | ((value << (2+16)) & 0x3c0000);
}

static unsigned long
extract_i5div3 (unsigned long insn, int * invalid)
{
  unsigned long ret = (insn & 0x003c0000) >> (16+2);
  ret = 32 - (ret * 2);

  if (invalid != 0)
    *invalid = (ret > 32 || ret < 2) ? 1 : 0;
  return ret;
}

static unsigned long
insert_d5_4 (unsigned long insn, long value, const char ** errmsg)
{
  if (value > 0x1f || value < 0)
    {
      if (value & 1)
	* errmsg = _(not_valid);
      else
	* errmsg = _(out_of_range);
    }
  else if (value & 1)
    * errmsg = _(not_aligned);

  value >>= 1;

  return insn | (value & 0x0f);
}

static unsigned long
extract_d5_4 (unsigned long insn, int * invalid)
{
  unsigned long ret = (insn & 0x0f);

  ret <<= 1;

  if (invalid != 0)
    *invalid = 0;
  return ret;
}

static unsigned long
insert_d8_6 (unsigned long insn, long value, const char ** errmsg)
{
  if (value > 0xff || value < 0)
    {
      if ((value % 4) != 0)
	* errmsg = _(not_valid);
      else
	* errmsg = _(out_of_range);
    }
  else if ((value % 4) != 0)
    * errmsg = _(not_aligned);

  value >>= 1;

  return insn | (value & 0x7e);
}

static unsigned long
extract_d8_6 (unsigned long insn, int * invalid)
{
  unsigned long ret = (insn & 0x7e);

  ret <<= 1;

  if (invalid != 0)
    *invalid = 0;
  return ret;
}

static unsigned long
insert_d8_7 (unsigned long insn, long value, const char ** errmsg)
{
  if (value > 0xff || value < 0)
    {
      if ((value % 2) != 0)
	* errmsg = _(not_valid);
      else
	* errmsg = _(out_of_range);
    }
  else if ((value % 2) != 0)
    * errmsg = _(not_aligned);

  value >>= 1;

  return insn | (value & 0x7f);
}

static unsigned long
extract_d8_7 (unsigned long insn, int * invalid)
{
  unsigned long ret = (insn & 0x7f);

  ret <<= 1;

  if (invalid != 0)
    *invalid = 0;
  return ret;
}

static unsigned long
insert_v8 (unsigned long insn, long value, const char ** errmsg)
{
  if (value > 0xff || value < 0)
    * errmsg = _(immediate_out_of_range);

  return insn | (value & 0x1f) | ((value & 0xe0) << (27-5));
}

static unsigned long
extract_v8 (unsigned long insn, int * invalid)
{
  unsigned long ret = (insn & 0x1f) | ((insn >> (27-5)) & 0xe0);

  if (invalid != 0)
    *invalid = 0;
  return ret;
}

static unsigned long
insert_d9 (unsigned long insn, long value, const char ** errmsg)
{
  if (value > 0xff || value < -0x100)
    {
      if ((value % 2) != 0)
	* errmsg = branch_out_of_range_and_odd_offset;
      else
	* errmsg = branch_out_of_range;
    }
  else if ((value % 2) != 0)
    * errmsg = branch_to_odd_offset;

  return insn | ((value & 0x1f0) << 7) | ((value & 0x0e) << 3);
}

static unsigned long
extract_d9 (unsigned long insn, int * invalid)
{
  signed long ret = ((insn >> 7) & 0x1f0) | ((insn >> 3) & 0x0e);

  ret = (ret ^ 0x100) - 0x100;

  if (invalid != 0)
    *invalid = 0;
  return ret;
}

static unsigned long
insert_u16_loop (unsigned long insn, long value, const char ** errmsg)
{
  /* Loop displacement is encoded as a positive value,
     even though the instruction branches backwards.  */
  if (value < 0 || value > 0xffff)
    {
      if ((value % 2) != 0)
	* errmsg = branch_out_of_range_and_odd_offset;
      else
	* errmsg = branch_out_of_range;
    }
  else if ((value % 2) != 0)
    * errmsg = branch_to_odd_offset;

  return insn | ((value & 0xfffe) << 16);
}

static unsigned long
extract_u16_loop (unsigned long insn, int * invalid)
{
  long ret = (insn >> 16) & 0xfffe;

  if (invalid != 0)
    *invalid = 0;
  return ret;
}

static unsigned long
insert_d16_15 (unsigned long insn, long value, const char ** errmsg)
{
  if (value > 0x7fff || value < -0x8000)
    {
      if ((value % 2) != 0)
	* errmsg = _(not_valid);
      else
	* errmsg = _(out_of_range);
    }
  else if ((value % 2) != 0)
    * errmsg = _(not_aligned);

  return insn | ((value & 0xfffe) << 16);
}

static unsigned long
extract_d16_15 (unsigned long insn, int * invalid)
{
  signed long ret = (insn >> 16) & 0xfffe;

  ret = (ret ^ 0x8000) - 0x8000;

  if (invalid != 0)
    *invalid = 0;
  return ret;
}

static unsigned long
insert_d16_16 (unsigned long insn, signed long value, const char ** errmsg)
{
  if (value > 0x7fff || value < -0x8000)
    * errmsg = _(out_of_range);

  return insn | ((value & 0xfffe) << 16) | ((value & 1) << 5);
}

static unsigned long
extract_d16_16 (unsigned long insn, int * invalid)
{
  signed long ret = ((insn >> 16) & 0xfffe) | ((insn >> 5) & 1);

  ret = (ret ^ 0x8000) - 0x8000;

  if (invalid != 0)
    *invalid = 0;
  return ret;
}

static unsigned long
insert_d17_16 (unsigned long insn, long value, const char ** errmsg)
{
  if (value > 0xffff || value < -0x10000)
    * errmsg = _(out_of_range);

  return insn | ((value & 0xfffe) << 16) | ((value & 0x10000) >> (16 - 4));
}

static unsigned long
extract_d17_16 (unsigned long insn, int * invalid)
{
  signed long ret = ((insn >> 16) & 0xfffe) | ((insn << (16 - 4)) & 0x10000);

  ret = (ret ^ 0x10000) - 0x10000;

  if (invalid != 0)
    *invalid = 0;
  return (unsigned long)ret;
}

static unsigned long
insert_d22 (unsigned long insn, long value, const char ** errmsg)
{
  if (value > 0x1fffff || value < -0x200000)
    {
      if ((value % 2) != 0)
	* errmsg = branch_out_of_range_and_odd_offset;
      else
	* errmsg = branch_out_of_range;
    }
  else if ((value % 2) != 0)
    * errmsg = branch_to_odd_offset;

  return insn | ((value & 0xfffe) << 16) | ((value & 0x3f0000) >> 16);
}

static unsigned long
extract_d22 (unsigned long insn, int * invalid)
{
  signed long ret = ((insn >> 16) & 0xfffe) | ((insn << 16) & 0x3f0000);

  ret = (ret ^ 0x200000) - 0x200000;

  if (invalid != 0)
    *invalid = 0;
  return (unsigned long) ret;
}

static unsigned long
insert_d23 (unsigned long insn, long value, const char ** errmsg)
{
  if (value > 0x3fffff || value < -0x400000)
    * errmsg = out_of_range;

  return insn | ((value & 0x7f) << 4) | ((value & 0x7fff80) << (16-7));
}

static unsigned long
insert_d23_align1 (unsigned long insn, long value, const char ** errmsg)
{
  if (value > 0x3fffff || value < -0x400000)
    {
      if (value & 0x1)
	* errmsg = _(not_valid);
      else
	* errmsg = _(out_of_range);
    }
  else if (value & 0x1)
    * errmsg = _(not_aligned);

  return insn | ((value & 0x7e) << 4) | ((value & 0x7fff80) << (16 - 7));
}

static unsigned long
extract_d23 (unsigned long insn, int * invalid)
{
  signed long ret = ((insn >> 4) & 0x7f) | ((insn >> (16-7)) & 0x7fff80);

  ret = (ret ^ 0x400000) - 0x400000;

  if (invalid != 0)
    *invalid = 0;
  return (unsigned long) ret;
}

static unsigned long
insert_i9 (unsigned long insn, signed long value, const char ** errmsg)
{
  if (value > 0xff || value < -0x100)
    * errmsg = _(immediate_out_of_range);

  return insn | ((value & 0x1e0) << 13) | (value & 0x1f);
}

static unsigned long
extract_i9 (unsigned long insn, int * invalid)
{
  signed long ret = ((insn >> 13) & 0x1e0) | (insn & 0x1f);

  ret = (ret ^ 0x100) - 0x100;

  if (invalid != 0)
    *invalid = 0;
  return ret;
}

static unsigned long
insert_u9 (unsigned long insn, long v, const char ** errmsg)
{
  unsigned long value = (unsigned long) v;

  if (value > 0x1ff)
    * errmsg = _(immediate_out_of_range);

  return insn | ((value & 0x1e0) << 13) | (value & 0x1f);
}

static unsigned long
extract_u9 (unsigned long insn, int * invalid)
{
  unsigned long ret = ((insn >> 13) & 0x1e0) | (insn & 0x1f);

  if (invalid != 0)
    *invalid = 0;
  return ret;
}

static unsigned long
insert_spe (unsigned long insn, long v, const char ** errmsg)
{
  unsigned long value = (unsigned long) v;

  if (value != 3)
    * errmsg = _("invalid register for stack adjustment");

  return insn & ~0x180000;
}

static unsigned long
extract_spe (unsigned long insn ATTRIBUTE_UNUSED, int * invalid)
{
  if (invalid != 0)
    *invalid = 0;

  return 3;
}

static unsigned long
insert_r4 (unsigned long insn, long v, const char ** errmsg)
{
  unsigned long value = (unsigned long) v;

  if (value >= 32)
    * errmsg = _("invalid register name");

  return insn | ((value & 0x01) << 23) | ((value & 0x1e) << 16);
}

static unsigned long
extract_r4 (unsigned long insn, int * invalid)
{
  unsigned long r4;
  unsigned long insn2;

  insn2 = insn >> 16;
  r4 = (((insn2 & 0x0080) >> 7) | (insn2 & 0x001e));

  if (invalid != 0)
    *invalid = 0;

  return r4;
}

static unsigned long G_pos;

static unsigned long
insert_POS (unsigned long insn, long pos, const char ** errmsg)
{
  if (pos > 0x1f || pos < 0)
    * errmsg = _(pos_out_of_range);

  G_pos = (unsigned long) pos;

  return insn; /* Not an oparaton until WIDTH.  */
}

static unsigned long
extract_POS_U (unsigned long insn, int * invalid)
{
  unsigned long pos,lsb;
  unsigned long insn2;
  insn2 = insn >> 16;

  lsb = ((insn2 & 0x0800) >>  8)
      | ((insn2 & 0x000e) >>  1);
  lsb += 16;
  pos = lsb;

  if (invalid != 0)
    *invalid = 0;

  return pos;
}

static unsigned long
extract_POS_L (unsigned long insn, int * invalid)
{
  unsigned long pos,lsb;
  unsigned long insn2;
  insn2 = insn >> 16;

  lsb = ((insn2 & 0x0800) >>  8)
      | ((insn2 & 0x000e) >>  1);
  pos = lsb;

  if (invalid != 0)
    *invalid = 0;

  return pos;
}

static unsigned long
insert_WIDTH (unsigned long insn, long width, const char ** errmsg)
{
  unsigned long msb, lsb, opc, ret;
  unsigned long msb_expand, lsb_expand;

  msb = (unsigned long)width + G_pos - 1;
  lsb = G_pos;
  opc = 0;
  G_pos = 0;

  if (width > 0x20 || width < 0)
    * errmsg = _(width_out_of_range);

  if ((msb >= 16) && (lsb >= 16))
    opc = 0x0090;
  else if ((msb >= 16) && (lsb < 16))
    opc = 0x00b0;
  else if ((msb < 16) && (lsb < 16))
    opc = 0x00d0;
  else
    * errmsg = _(width_out_of_range);

  msb &= 0x0f;
  msb_expand = msb << 12;
  lsb &= 0x0f;
  lsb_expand = ((lsb & 0x8) << 8)|((lsb & 0x7) << 1);

  ret = (insn & 0x0000ffff) | ((opc | msb_expand | lsb_expand) << 16);

  return ret;
}

static unsigned long
extract_WIDTH_U (unsigned long insn, int * invalid)
{
  unsigned long width, msb, lsb;
  unsigned long insn2;
  insn2 = insn >> 16;

  msb = ((insn2 & 0xf000) >> 12);
  msb += 16;
  lsb = ((insn2 & 0x0800) >>  8)
      | ((insn2 & 0x000e) >>  1);
  lsb += 16;

  if (invalid != 0)
    *invalid = 0;

  width = msb - lsb + 1;

  return width;
}

static unsigned long
extract_WIDTH_M (unsigned long insn, int * invalid)
{
  unsigned long width, msb, lsb;
  unsigned long insn2;
  insn2 = insn >> 16;

  msb = ((insn2 & 0xf000) >> 12) ;
  msb += 16;
  lsb = ((insn2 & 0x0800) >>  8)
      | ((insn2 & 0x000e) >>  1);

  if (invalid != 0)
    *invalid = 0;

  width = msb - lsb + 1;

  return width;
}

static unsigned long
extract_WIDTH_L (unsigned long insn, int * invalid)
{
  unsigned long width, msb, lsb;
  unsigned long insn2;
  insn2 = insn >> 16;

  msb = ((insn2 & 0xf000) >> 12) ;
  lsb = ((insn2 & 0x0800) >>  8)
      | ((insn2 & 0x000e) >>  1);

  if (invalid != 0)
    *invalid = 0;

  width = msb - lsb + 1;

  return width;
}

static unsigned long
insert_SELID (unsigned long insn, long selid, const char ** errmsg)
{
  unsigned long ret;

  if (selid > 0x1f || selid < 0)
    * errmsg = _(selid_out_of_range);

  ret = (insn | ((selid & 0x1f) << 27));

  return ret;
}

static unsigned long
extract_SELID (unsigned long insn, int * invalid)
{
  unsigned long selid;
  unsigned long insn2;

  insn2 = insn >> 16;

  selid = ((insn2 & 0xf800) >> 11);

  if (invalid != 0)
    *invalid = 0;

  return selid;
}

static unsigned long
insert_VECTOR8 (unsigned long insn, long vector8, const char ** errmsg)
{
  unsigned long ret;
  unsigned long VVV,vvvvv;

  if (vector8 > 0xff || vector8 < 0)
    * errmsg = _(vector8_out_of_range);

  VVV   = (vector8 & 0xe0) >> 5;
  vvvvv = (vector8 & 0x1f);

  ret = (insn | (VVV << 27) | vvvvv);

  return ret;
}

static unsigned long
extract_VECTOR8 (unsigned long insn, int * invalid)
{
  unsigned long vector8;
  unsigned long VVV,vvvvv;
  unsigned long insn2;

  insn2   = insn >> 16;
  VVV     = ((insn2 & 0x3800) >> 11);
  vvvvv   = (insn & 0x001f);
  vector8 = VVV << 5 | vvvvv;

  if (invalid != 0)
    *invalid = 0;

  return vector8;
}

static unsigned long
insert_VECTOR5 (unsigned long insn, long vector5, const char ** errmsg)
{
  unsigned long ret;
  unsigned long vvvvv;

  if (vector5 > 0x1f || vector5 < 0)
    * errmsg = _(vector5_out_of_range);

  vvvvv = (vector5 & 0x1f);

  ret = (insn | vvvvv);

  return ret;
}

static unsigned long
extract_VECTOR5 (unsigned long insn, int * invalid)
{
  unsigned long vector5;

  vector5 = (insn & 0x001f);

  if (invalid != 0)
    *invalid = 0;

  return vector5;
}

static unsigned long
insert_CACHEOP (unsigned long insn, long cacheop, const char ** errmsg ATTRIBUTE_UNUSED)
{
  unsigned long ret;
  unsigned long pp,PPPPP;

  pp    = (cacheop & 0x60) >> 5;
  PPPPP = (cacheop & 0x1f);

  ret = insn | (pp << 11) | (PPPPP << 27);

  return ret;
}

static unsigned long
extract_CACHEOP (unsigned long insn, int * invalid)
{
  unsigned long ret;
  unsigned long pp,PPPPP;
  unsigned long insn2;

  insn2 = insn >> 16;

  PPPPP = ((insn2 & 0xf800) >> 11);
  pp    = ((insn  & 0x1800) >> 11);

  ret   = (pp << 5) | PPPPP;

  if (invalid != 0)
    *invalid = 0;

  return ret;
}

static unsigned long
insert_PREFOP (unsigned long insn, long prefop, const char ** errmsg ATTRIBUTE_UNUSED)
{
  unsigned long ret;
  unsigned long PPPPP;

  PPPPP = (prefop & 0x1f);

  ret = insn | (PPPPP << 27);

  return ret;
}

static unsigned long
extract_PREFOP (unsigned long insn, int * invalid)
{
  unsigned long ret;
  unsigned long PPPPP;
  unsigned long insn2;

  insn2 = insn >> 16;

  PPPPP = (insn2 & 0xf800) >> 11;

  ret   = PPPPP;

  if (invalid != 0)
    *invalid = 0;

  return ret;
}

static unsigned long
insert_IMM10U (unsigned long insn, long value, const char ** errmsg)
{
  unsigned long imm10, ret;
  unsigned long iiiii,IIIII;

  if (value > 0x3ff || value < 0)
    * errmsg = _(imm10_out_of_range);

  imm10 = ((unsigned long) value) & 0x3ff;
  IIIII = (imm10 >> 5) & 0x1f;
  iiiii =  imm10       & 0x1f;

  ret = insn | IIIII << 27 | iiiii;

  return ret;
}

static unsigned long
extract_IMM10U (unsigned long insn, int * invalid)
{
  unsigned long ret;
  unsigned long iiiii,IIIII;
  unsigned long insn2;
  insn2 = insn >> 16;

  IIIII = ((insn2 & 0xf800) >> 11);
  iiiii = (insn   & 0x001f);

  ret = (IIIII << 5) | iiiii;

  if (invalid != 0)
    *invalid = 0;

  return ret;
}

static unsigned long
insert_SRSEL1 (unsigned long insn, long value, const char ** errmsg)
{
  unsigned long imm10, ret;
  unsigned long sr,selid;

  if (value > 0x3ff || value < 0)
    * errmsg = _(sr_selid_out_of_range);

  imm10 = (unsigned long) value;
  selid = (imm10 & 0x3e0) >> 5;
  sr    =  imm10 & 0x1f;

  ret   = insn | selid << 27 | sr;

  return ret;
}

static unsigned long
extract_SRSEL1 (unsigned long insn, int * invalid)
{
  unsigned long ret;
  unsigned long sr, selid;
  unsigned long insn2;

  insn2 = insn >> 16;

  selid = ((insn2 & 0xf800) >> 11);
  sr    = (insn  & 0x001f);

  ret   = (selid << 5) | sr;

  if (invalid != 0)
    *invalid = 0;

  return ret;
}

static unsigned long
insert_SRSEL2 (unsigned long insn, long value, const char ** errmsg)
{
  unsigned long imm10, ret;
  unsigned long sr, selid;

  if (value > 0x3ff || value < 0)
    * errmsg = _(sr_selid_out_of_range);

  imm10 = (unsigned long) value;
  selid = (imm10 & 0x3e0) >> 5;
  sr    =  imm10 & 0x1f;

  ret   = insn | selid << 27 | sr << 11;

  return ret;
}

static unsigned long
extract_SRSEL2 (unsigned long insn, int * invalid)
{
  unsigned long ret;
  unsigned long sr, selid;
  unsigned long insn2;

  insn2 = insn >> 16;

  selid = ((insn2 & 0xf800) >> 11);
  sr    = ((insn  & 0xf800) >> 11);

  ret   = (selid << 5) | sr;

  if (invalid != 0)
    *invalid = 0;

  return ret;
}

/* Warning: code in gas/config/tc-v850.c examines the contents of this array.
   If you change any of the values here, be sure to look for side effects in
   that code.  */
const struct v850_operand v850_operands[] =
{
#define UNUSED	0
  { 0, 0, NULL, NULL, 0, BFD_RELOC_NONE },

/* The R1 field in a format 1, 6, 7, 9, C insn.  */
#define R1	(UNUSED + 1)
  { 5, 0, NULL, NULL, V850_OPERAND_REG, BFD_RELOC_NONE },

/* As above, but register 0 is not allowed.  */
#define R1_NOTR0 (R1 + 1)
  { 5, 0, NULL, NULL, V850_OPERAND_REG | V850_NOT_R0, BFD_RELOC_NONE },

/* Even register is allowed.  */
#define R1_EVEN (R1_NOTR0 + 1)
  { 4, 1, NULL, NULL, V850_OPERAND_REG | V850_REG_EVEN, BFD_RELOC_NONE },

/* Bang (bit reverse).  */
#define R1_BANG (R1_EVEN + 1)
  { 5, 0, NULL, NULL, V850_OPERAND_REG | V850_OPERAND_BANG, BFD_RELOC_NONE },

/* Percent (modulo).  */
#define R1_PERCENT (R1_BANG + 1)
  { 5, 0, NULL, NULL, V850_OPERAND_REG | V850_OPERAND_PERCENT, BFD_RELOC_NONE },

/* The R2 field in a format 1, 2, 4, 5, 6, 7, 9, C insn.  */
#define R2 (R1_PERCENT + 1)
  { 5, 11, NULL, NULL, V850_OPERAND_REG, BFD_RELOC_NONE },

/* As above, but register 0 is not allowed.  */
#define R2_NOTR0 (R2 + 1)
  { 5, 11, NULL, NULL, V850_OPERAND_REG | V850_NOT_R0, BFD_RELOC_NONE },

/* Even register is allowed.  */
#define R2_EVEN (R2_NOTR0 + 1)
  { 4, 12, NULL, NULL, V850_OPERAND_REG | V850_REG_EVEN, BFD_RELOC_NONE },

/* Reg2 in dispose instruction.  */
#define R2_DISPOSE	(R2_EVEN + 1)
  { 5, 16, NULL, NULL, V850_OPERAND_REG | V850_NOT_R0, BFD_RELOC_NONE },

/* The R3 field in a format 11, 12, C insn.  */
#define R3	(R2_DISPOSE + 1)
  { 5, 27, NULL, NULL, V850_OPERAND_REG, BFD_RELOC_NONE },

/* As above, but register 0 is not allowed.  */
#define R3_NOTR0	(R3 + 1)
  { 5, 27, NULL, NULL, V850_OPERAND_REG | V850_NOT_R0, BFD_RELOC_NONE },

/* As above, but odd number registers are not allowed.  */
#define R3_EVEN	(R3_NOTR0 + 1)
  { 4, 28, NULL, NULL, V850_OPERAND_REG | V850_REG_EVEN, BFD_RELOC_NONE },

/* As above, but register 0 is not allowed.  */
#define R3_EVEN_NOTR0	(R3_EVEN + 1)
  { 4, 28, NULL, NULL, V850_OPERAND_REG | V850_REG_EVEN | V850_NOT_R0, BFD_RELOC_NONE },

/* Forth register in FPU Instruction.  */
#define R4	(R3_EVEN_NOTR0 + 1)
  { 5, 0, insert_r4, extract_r4, V850_OPERAND_REG, BFD_RELOC_NONE },

/* As above, but odd number registers are not allowed.  */
#define R4_EVEN	(R4 + 1)
  { 4, 17, NULL, NULL, V850_OPERAND_REG | V850_REG_EVEN, BFD_RELOC_NONE },

/* Stack pointer in prepare instruction.  */
#define SP	(R4_EVEN + 1)
  { 2, 0, insert_spe, extract_spe, V850_OPERAND_REG, BFD_RELOC_NONE },

/* EP Register.  */
#define EP	(SP + 1)
  { 0, 0, NULL, NULL, V850_OPERAND_EP, BFD_RELOC_NONE },

/* A list of registers in a prepare/dispose instruction.  */
#define LIST12	(EP + 1)
  { -1, 0xffe00001, NULL, NULL, V850E_OPERAND_REG_LIST, BFD_RELOC_NONE },

/* System register operands.  */
#define OLDSR1	(LIST12 + 1)
  { 5, 0, NULL, NULL, V850_OPERAND_SRG, BFD_RELOC_NONE },

#define SR1	(OLDSR1 + 1)
  { 0, 0, insert_SRSEL1, extract_SRSEL1, V850_OPERAND_SRG, BFD_RELOC_NONE },

/* The R2 field as a system register.  */
#define OLDSR2	(SR1 + 1)
  { 5, 11, NULL, NULL, V850_OPERAND_SRG, BFD_RELOC_NONE },

#define SR2	(OLDSR2 + 1)
  { 0, 0, insert_SRSEL2, extract_SRSEL2, V850_OPERAND_SRG, BFD_RELOC_NONE },

/* FPU CC bit position.  */
#define FFF (SR2 + 1)
  { 3, 17, NULL, NULL, 0, BFD_RELOC_NONE },

/* The 4 bit condition code in a setf instruction.  */
#define CCCC	(FFF + 1)
  { 4, 0, NULL, NULL, V850_OPERAND_CC, BFD_RELOC_NONE },

/* Condition code in adf,sdf.  */
#define CCCC_NOTSA	(CCCC + 1)
  { 4, 17, NULL, NULL, V850_OPERAND_CC|V850_NOT_SA, BFD_RELOC_NONE },

/* Condition code in conditional moves.  */
#define MOVCC	(CCCC_NOTSA + 1)
  { 4, 17, NULL, NULL, V850_OPERAND_CC, BFD_RELOC_NONE },

/* Condition code in FPU.  */
#define FLOAT_CCCC	(MOVCC + 1)
  { 4, 27, NULL, NULL, V850_OPERAND_FLOAT_CC, BFD_RELOC_NONE },

/* The 1 bit immediate field in format C insn.  */
#define VI1	(FLOAT_CCCC + 1)
  { 1, 3, NULL, NULL, 0, BFD_RELOC_NONE },

/* The 1 bit immediate field in format C insn.  */
#define VC1	(VI1 + 1)
  { 1, 0, NULL, NULL, 0, BFD_RELOC_NONE },

/* The 2 bit immediate field in format C insn.  */
#define DI2	(VC1 + 1)
  { 2, 17, NULL, NULL, 0, BFD_RELOC_NONE },

/* The 2 bit immediate field in format C insn.  */
#define VI2	(DI2 + 1)
  { 2, 0, NULL, NULL, 0, BFD_RELOC_NONE },

/* The 2 bit immediate field in format C - DUP insn.  */
#define VI2DUP	(VI2 + 1)
  { 2, 2, NULL, NULL, 0, BFD_RELOC_NONE },

/* The 3 bit immediate field in format 8 insn.  */
#define B3	(VI2DUP + 1)
  { 3, 11, NULL, NULL, 0, BFD_RELOC_NONE },

/* The 3 bit immediate field in format C insn.  */
#define DI3	(B3 + 1)
  { 3, 17, NULL, NULL, 0, BFD_RELOC_NONE },

/* The 3 bit immediate field in format C insn.  */
#define I3U	(DI3 + 1)
  { 3, 0, NULL, NULL, 0, BFD_RELOC_NONE },

/* The 4 bit immediate field in format C insn.  */
#define I4U	(I3U + 1)
  { 4, 0, NULL, NULL, 0, BFD_RELOC_NONE },

/* The 4 bit immediate field in fetrap.  */
#define I4U_NOTIMM0	(I4U + 1)
  { 4, 11, NULL, NULL, V850_NOT_IMM0, BFD_RELOC_NONE },

/* The unsigned disp4 field in a sld.bu.  */
#define D4U	(I4U_NOTIMM0 + 1)
  { 4, 0, NULL, NULL, V850_OPERAND_DISP, BFD_RELOC_V850_TDA_4_4_OFFSET },

/* The imm5 field in a format 2 insn.  */
#define I5	(D4U + 1)
  { 5, 0, NULL, NULL, V850_OPERAND_SIGNED, BFD_RELOC_NONE },

/* The imm5 field in a format 11 insn.  */
#define I5DIV1	(I5 + 1)
  { 5, 0, insert_i5div1, extract_i5div1, 0, BFD_RELOC_NONE },

#define I5DIV2	(I5DIV1 + 1)
  { 5, 0, insert_i5div2, extract_i5div2, 0, BFD_RELOC_NONE },

#define I5DIV3	(I5DIV2 + 1)
  { 5, 0, insert_i5div3, extract_i5div3, 0, BFD_RELOC_NONE },

/* The unsigned imm5 field in a format 2 insn.  */
#define I5U	(I5DIV3 + 1)
  { 5, 0, NULL, NULL, 0, BFD_RELOC_NONE },

/* The imm5 field in a prepare/dispose instruction.  */
#define IMM5	(I5U + 1)
  { 5, 1, NULL, NULL, 0, BFD_RELOC_NONE },

/* The unsigned disp5 field in a sld.hu.  */
#define D5_4U	(IMM5 + 1)
  { 5, 0, insert_d5_4, extract_d5_4, V850_OPERAND_DISP, BFD_RELOC_V850_TDA_4_5_OFFSET },

/* The IMM6 field in a callt instruction.  */
#define IMM6	(D5_4U + 1)
  { 6, 0, NULL, NULL, 0, BFD_RELOC_V850_CALLT_6_7_OFFSET },

/* The signed disp7 field in a format 4 insn.  */
#define D7U	(IMM6 + 1)
  { 7, 0, NULL, NULL, V850_OPERAND_DISP, BFD_RELOC_V850_TDA_7_7_OFFSET },

/* The unsigned DISP8 field in a format 4 insn.  */
#define D8_7U	(D7U + 1)
  { 8, 0, insert_d8_7, extract_d8_7, V850_OPERAND_DISP, BFD_RELOC_V850_TDA_7_8_OFFSET },

/* The unsigned DISP8 field in a format 4 insn.  */
#define D8_6U	(D8_7U + 1)
  { 8, 0, insert_d8_6, extract_d8_6, V850_OPERAND_DISP, BFD_RELOC_V850_TDA_6_8_OFFSET },

/* The unsigned DISP8 field in a format 4 insn.  */
#define V8	(D8_6U + 1)
  { 8, 0, insert_v8, extract_v8, 0, BFD_RELOC_NONE },

/* The imm9 field in a multiply word.  */
#define I9	(V8 + 1)
  { 9, 0, insert_i9, extract_i9, V850_OPERAND_SIGNED, BFD_RELOC_NONE },

/* The unsigned imm9 field in a multiply word.  */
#define U9	(I9 + 1)
  { 9, 0, insert_u9, extract_u9, 0, BFD_RELOC_NONE },

/* The DISP9 field in a format 3 insn.  */
#define D9	(U9 + 1)
  { 9, 0, insert_d9, extract_d9, V850_OPERAND_SIGNED | V850_OPERAND_DISP | V850_PCREL, BFD_RELOC_V850_9_PCREL },

/* The DISP9 field in a format 3 insn, relaxable.  */
#define D9_RELAX	(D9 + 1)
  { 9, 0, insert_d9, extract_d9, V850_OPERAND_RELAX | V850_OPERAND_SIGNED | V850_OPERAND_DISP | V850_PCREL, BFD_RELOC_V850_9_PCREL },

/* The imm16 field in a format 6 insn.  */
#define I16	(D9_RELAX + 1)
  { 16, 16, NULL, NULL, V850_OPERAND_SIGNED, BFD_RELOC_16 },

/* The signed 16 bit immediate following a prepare instruction.  */
#define IMM16LO	(I16 + 1)
  { 16, 32, NULL, NULL, V850E_IMMEDIATE16 | V850_OPERAND_SIGNED, BFD_RELOC_LO16 },

/* The hi 16 bit immediate following a 32 bit instruction.  */
#define IMM16HI	(IMM16LO + 1)
  { 16, 16, NULL, NULL, V850E_IMMEDIATE16HI, BFD_RELOC_HI16 },

/* The unsigned imm16 in a format 6 insn.  */
#define I16U	(IMM16HI + 1)
  { 16, 16, NULL, NULL, 0, BFD_RELOC_16 },

/* The disp16 field in a format 8 insn.  */
#define D16	(I16U + 1)
  { 16, 16, NULL, NULL, V850_OPERAND_SIGNED | V850_OPERAND_DISP, BFD_RELOC_16 },

/* The disp16 field in an format 7 unsigned byte load insn.  */
#define D16_16	(D16 + 1)
  { 16, 0, insert_d16_16, extract_d16_16, V850_OPERAND_SIGNED | V850_OPERAND_DISP, BFD_RELOC_V850_16_SPLIT_OFFSET },

/* The disp16 field in a format 6 insn.  */
#define D16_15	(D16_16 + 1)
  { 16, 0, insert_d16_15, extract_d16_15, V850_OPERAND_SIGNED | V850_OPERAND_DISP , BFD_RELOC_V850_16_S1 },

/* The unsigned DISP16 field in a format 7 insn.  */
#define D16_LOOP	(D16_15 + 1)
  { 16, 0, insert_u16_loop, extract_u16_loop, V850_OPERAND_RELAX | V850_OPERAND_DISP | V850_PCREL | V850_INVERSE_PCREL, BFD_RELOC_V850_16_PCREL },

/* The DISP17 field in a format 7 insn.  */
#define D17_16	(D16_LOOP + 1)
  { 17, 0, insert_d17_16, extract_d17_16, V850_OPERAND_SIGNED | V850_OPERAND_DISP | V850_PCREL, BFD_RELOC_V850_17_PCREL },

/* The DISP22 field in a format 4 insn, relaxable.
   This _must_ follow D9_RELAX; the assembler assumes that the longer
   version immediately follows the shorter version for relaxing.  */
#define D22	(D17_16 + 1)
  { 22, 0, insert_d22, extract_d22, V850_OPERAND_SIGNED | V850_OPERAND_DISP | V850_PCREL, BFD_RELOC_V850_22_PCREL },

#define D23	(D22 + 1)
  { 23, 0, insert_d23, extract_d23, V850E_IMMEDIATE23 | V850_OPERAND_SIGNED | V850_OPERAND_DISP, BFD_RELOC_V850_23 },

#define D23_ALIGN1	(D23 + 1)
  { 23, 0, insert_d23_align1, extract_d23, V850E_IMMEDIATE23 | V850_OPERAND_SIGNED | V850_OPERAND_DISP, BFD_RELOC_V850_23 },

/* The 32 bit immediate following a 32 bit instruction.  */
#define IMM32	(D23_ALIGN1 + 1)
  { 32, 32, NULL, NULL, V850E_IMMEDIATE32, BFD_RELOC_32 },

#define D32_31	(IMM32 + 1)
  { 32, 32, NULL, NULL, V850E_IMMEDIATE32 | V850_OPERAND_SIGNED | V850_OPERAND_DISP, BFD_RELOC_V850_32_ABS },

#define D32_31_PCREL	(D32_31 + 1)
  { 32, 32, NULL, NULL, V850E_IMMEDIATE32 | V850_OPERAND_SIGNED | V850_OPERAND_DISP | V850_PCREL, BFD_RELOC_V850_32_PCREL },

#define POS_U	(D32_31_PCREL + 1)
  { 0, 0, insert_POS, extract_POS_U, 0, BFD_RELOC_NONE },

#define POS_M	(POS_U + 1)
  { 0, 0, insert_POS, extract_POS_L, 0, BFD_RELOC_NONE },

#define POS_L	(POS_M + 1)
  { 0, 0, insert_POS, extract_POS_L, 0, BFD_RELOC_NONE },

#define WIDTH_U	(POS_L + 1)
  { 0, 0, insert_WIDTH, extract_WIDTH_U, 0, BFD_RELOC_NONE },

#define WIDTH_M	(WIDTH_U + 1)
  { 0, 0, insert_WIDTH, extract_WIDTH_M, 0, BFD_RELOC_NONE },

#define WIDTH_L	(WIDTH_M + 1)
  { 0, 0, insert_WIDTH, extract_WIDTH_L, 0, BFD_RELOC_NONE },

#define SELID	(WIDTH_L + 1)
  { 5, 27, insert_SELID, extract_SELID, 0, BFD_RELOC_NONE },

#define RIE_IMM5	(SELID + 1)
  { 5, 11, NULL, NULL, 0, BFD_RELOC_NONE },

#define RIE_IMM4	(RIE_IMM5 + 1)
  { 4, 0, NULL, NULL, 0, BFD_RELOC_NONE },

#define VECTOR8	(RIE_IMM4 + 1)
  { 0, 0, insert_VECTOR8, extract_VECTOR8, 0, BFD_RELOC_NONE },

#define VECTOR5	(VECTOR8 + 1)
  { 0, 0, insert_VECTOR5, extract_VECTOR5, 0, BFD_RELOC_NONE },

#define VR1	(VECTOR5 + 1)
  { 5, 0, NULL, NULL, V850_OPERAND_VREG, BFD_RELOC_NONE },

#define VR2	(VR1 + 1)
  { 5, 11, NULL, NULL, V850_OPERAND_VREG, BFD_RELOC_NONE },

#define CACHEOP	(VR2 + 1)
  { 0, 0, insert_CACHEOP, extract_CACHEOP, V850_OPERAND_CACHEOP, BFD_RELOC_NONE },

#define PREFOP	(CACHEOP + 1)
  { 0, 0, insert_PREFOP, extract_PREFOP, V850_OPERAND_PREFOP, BFD_RELOC_NONE },

#define IMM10U	(PREFOP + 1)
  { 0, 0, insert_IMM10U, extract_IMM10U, 0, BFD_RELOC_NONE },
};


/* Reg - Reg instruction format (Format I).  */
#define IF1	{R1, R2}

/* Imm - Reg instruction format (Format II).  */
#define IF2	{I5, R2}

/* Conditional branch instruction format (Format III).  */
#define IF3	{D9_RELAX}

/* 3 operand instruction (Format VI).  */
#define IF6	{I16, R1, R2}

/* 3 operand instruction (Format VI).  */
#define IF6U	{I16U, R1, R2}

/* Conditional branch instruction format (Format VII).  */
#define IF7	{D17_16}


/* The opcode table.

   The format of the opcode table is:

   NAME		OPCODE			MASK		       { OPERANDS }	   MEMOP    PROCESSOR

   NAME is the name of the instruction.
   OPCODE is the instruction opcode.
   MASK is the opcode mask; this is used to tell the disassembler
     which bits in the actual opcode must match OPCODE.
   OPERANDS is the list of operands.
   MEMOP specifies which operand (if any) is a memory operand.
   PROCESSORS specifies which CPU(s) support the opcode.

   The disassembler reads the table in order and prints the first
   instruction which matches, so this table is sorted to put more
   specific instructions before more general instructions.  It is also
   sorted by major opcode.

   The table is also sorted by name.  This is used by the assembler.
   When parsing an instruction the assembler finds the first occurance
   of the name of the instruciton in this table and then attempts to
   match the instruction's arguments with description of the operands
   associated with the entry it has just found in this table.  If the
   match fails the assembler looks at the next entry in this table.
   If that entry has the same name as the previous entry, then it
   tries to match the instruction against that entry and so on.  This
   is how the assembler copes with multiple, different formats of the
   same instruction.  */

const struct v850_opcode v850_opcodes[] =
{
/* Standard instructions.  */
{ "add",	OP  (0x0e),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },
{ "add",	OP  (0x12),		OP_MASK,		IF2, 			0, PROCESSOR_ALL },

{ "addi",	OP  (0x30),		OP_MASK,		IF6, 			0, PROCESSOR_ALL },

{ "adf",	two (0x07e0, 0x03a0),	two (0x07e0, 0x07e1),	{CCCC_NOTSA, R1, R2, R3},    	0, PROCESSOR_V850E2_UP },

{ "and",	OP (0x0a),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },

{ "andi",	OP (0x36),		OP_MASK,		IF6U, 			0, PROCESSOR_ALL },

	/* Signed integer.  */
{ "bge",	BOP (0xe),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "bgt",	BOP (0xf),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "ble",	BOP (0x7),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "blt",	BOP (0x6),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
	/* Unsigned integer.  */
{ "bh",		BOP (0xb),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "bl",		BOP (0x1),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "bnh",	BOP (0x3),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "bnl",	BOP (0x9),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
	/* Common.  */
{ "be",		BOP (0x2),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "bne",	BOP (0xa),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
	/* Others.  */
{ "bc",		BOP (0x1),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "bf",		BOP (0xa),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "bn",		BOP (0x4),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "bnc",	BOP (0x9),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "bnv",	BOP (0x8),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "bnz",	BOP (0xa),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "bp",		BOP (0xc),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "br",		BOP (0x5),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "bsa",	BOP (0xd),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "bt",		BOP (0x2),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "bv",		BOP (0x0),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "bz",		BOP (0x2),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },

/* Signed integer.  */
{ "bge",  two (0x07ee, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
{ "bgt",  two (0x07ef, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
{ "ble",  two (0x07e7, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
{ "blt",  two (0x07e6, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
/* Unsigned integer.  */			      	 
{ "bh",   two (0x07eb, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
{ "bl",   two (0x07e1, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
{ "bnh",  two (0x07e3, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
{ "bnl",  two (0x07e9, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
/* Common.  */					      	 
{ "be",   two (0x07e2, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
{ "bne",  two (0x07ea, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
/* Others.  */					      	 
{ "bc",   two (0x07e1, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
{ "bf",   two (0x07ea, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
{ "bn",   two (0x07e4, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
{ "bnc",  two (0x07e9, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
{ "bnv",  two (0x07e8, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
{ "bnz",  two (0x07ea, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
{ "bp",   two (0x07ec, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
{ "br",   two (0x07e5, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
{ "bsa",  two (0x07ed, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
{ "bt",   two (0x07e2, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
{ "bv",   two (0x07e0, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
{ "bz",   two (0x07e2, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP },
/* Bcond disp17 Gas local alias(not defined in spec).  */

/* Signed integer.  */
{ "bge17",  two (0x07ee, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },
{ "bgt17",  two (0x07ef, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },
{ "ble17",  two (0x07e7, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },
{ "blt17",  two (0x07e6, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },
/* Unsigned integer.  */
{ "bh17",   two (0x07eb, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },
{ "bl17",   two (0x07e1, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },
{ "bnh17",  two (0x07e3, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },
{ "bnl17",  two (0x07e9, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },
/* Common.  */
{ "be17",   two (0x07e2, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },
{ "bne17",  two (0x07ea, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },
/* Others.  */
{ "bc17",   two (0x07e1, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },
{ "bf17",   two (0x07ea, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },
{ "bn17",   two (0x07e4, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },
{ "bnc17",  two (0x07e9, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },
{ "bnv17",  two (0x07e8, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },
{ "bnz17",  two (0x07ea, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },
{ "bp17",   two (0x07ec, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },
{ "br17",   two (0x07e5, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },
{ "bsa17",  two (0x07ed, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },
{ "bt17",   two (0x07e2, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },
{ "bv17",   two (0x07e0, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },
{ "bz17",   two (0x07e2, 0x0001), two (0xffef, 0x0001), IF7, 0, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },

{ "bsh",	two (0x07e0, 0x0342),	two (0x07ff, 0x07ff), 	{R2, R3}, 		0, PROCESSOR_NOT_V850 },

{ "bsw",	two (0x07e0, 0x0340),	two (0x07ff, 0x07ff), 	{R2, R3}, 		0, PROCESSOR_NOT_V850 },

/* v850e3v5 bitfield instructions.  */
{ "bins",	two (0x07e0, 0x0090),	two (0x07e0, 0x07f1), {R1, POS_U, WIDTH_U, R2}, 		0, PROCESSOR_V850E3V5_UP },
{ "bins",	two (0x07e0, 0x00b0),	two (0x07e0, 0x07f1), {R1, POS_M, WIDTH_M, R2}, 		0, PROCESSOR_V850E3V5_UP },
{ "bins",	two (0x07e0, 0x00d0),	two (0x07e0, 0x07f1), {R1, POS_L, WIDTH_L, R2}, 		0, PROCESSOR_V850E3V5_UP },
/* Gas local alias(not defined in spec).  */
{ "binsu",two (0x07e0, 0x0090),	two (0x07e0, 0x07f1), {R1, POS_U, WIDTH_U, R2},			0, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },
{ "binsm",two (0x07e0, 0x00b0),	two (0x07e0, 0x07f1), {R1, POS_M, WIDTH_M, R2}, 		0, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },
{ "binsl",two (0x07e0, 0x00d0),	two (0x07e0, 0x07f1), {R1, POS_L, WIDTH_L, R2}, 		0, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },

{ "cache",	two (0xe7e0, 0x0160),	two (0xe7e0, 0x07ff),	{CACHEOP, R1}, 		2, PROCESSOR_V850E3V5_UP },

{ "callt",	one (0x0200),		one (0xffc0), 	      	{IMM6},			0, PROCESSOR_NOT_V850 },

{ "caxi",	two (0x07e0, 0x00ee),	two (0x07e0, 0x07ff),	{R1, R2, R3},		1, PROCESSOR_V850E2_UP },

{ "clr1",	two (0x87c0, 0x0000),	two (0xc7e0, 0x0000),	{B3, D16, R1}, 		3, PROCESSOR_ALL },
{ "clr1",	two (0x07e0, 0x00e4),	two (0x07e0, 0xffff),   {R2, R1},    		3, PROCESSOR_NOT_V850 },

{ "cmov",	two (0x07e0, 0x0320),	two (0x07e0, 0x07e1), 	{MOVCC, R1, R2, R3}, 	0, PROCESSOR_NOT_V850 },
{ "cmov",	two (0x07e0, 0x0300),	two (0x07e0, 0x07e1), 	{MOVCC, I5, R2, R3}, 	0, PROCESSOR_NOT_V850 },

{ "cmp",	OP  (0x0f),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },
{ "cmp",	OP  (0x13),		OP_MASK,		IF2, 			0, PROCESSOR_ALL },

{ "ctret", 	two (0x07e0, 0x0144),	two (0xffff, 0xffff), 	{0}, 			0, PROCESSOR_NOT_V850 },

{ "dbcp",	one (0xe840),		one (0xffff),		{0},			0, PROCESSOR_V850E3V5_UP },

{ "dbhvtrap",	one (0xe040),		one (0xffff),		{0},			0, PROCESSOR_V850E3V5_UP },

{ "dbpush",	two (0x5fe0, 0x0160),	two (0xffe0, 0x07ff),	{R1, R3}, 		0, PROCESSOR_V850E3V5_UP },

{ "dbret",	two (0x07e0, 0x0146),	two (0xffff, 0xffff),	{0},			0, PROCESSOR_NOT_V850 },

{ "dbtag",	two (0xcfe0, 0x0160),	two (0xffe0, 0x07ff),	{IMM10U},		0, PROCESSOR_V850E3V5_UP },

{ "dbtrap",	one (0xf840),		one (0xffff),		{0},			0, PROCESSOR_NOT_V850 },

{ "di",		two (0x07e0, 0x0160),	two (0xffff, 0xffff),	{0}, 			0, PROCESSOR_ALL },

{ "dispose",	two (0x0640, 0x0000),   two (0xffc0, 0x0000),   {IMM5, LIST12, R2_DISPOSE},3, PROCESSOR_NOT_V850 },
{ "dispose",	two (0x0640, 0x0000),   two (0xffc0, 0x001f), 	{IMM5, LIST12}, 	0, PROCESSOR_NOT_V850 },

{ "div",	two (0x07e0, 0x02c0),	two (0x07e0, 0x07ff), 	{R1, R2, R3}, 		0, PROCESSOR_NOT_V850 },

{ "divh",	two (0x07e0, 0x0280),   two (0x07e0, 0x07ff), 	{R1, R2, R3}, 		0, PROCESSOR_NOT_V850 },
{ "divh",	OP  (0x02),		OP_MASK,		{R1_NOTR0, R2_NOTR0},	0, PROCESSOR_ALL },

{ "divhn",	two (0x07e0, 0x0280),	two (0x07e0, 0x07c3), 	{I5DIV1, R1, R2, R3},	0, PROCESSOR_NOT_V850 | PROCESSOR_OPTION_EXTENSION },

{ "divhu",	two (0x07e0, 0x0282),   two (0x07e0, 0x07ff), 	{R1, R2, R3}, 		0, PROCESSOR_NOT_V850 },

{ "divhun",	two (0x07e0, 0x0282),	two (0x07e0, 0x07c3), 	{I5DIV1, R1, R2, R3}, 	0, PROCESSOR_NOT_V850 | PROCESSOR_OPTION_EXTENSION },
{ "divn",	two (0x07e0, 0x02c0),	two (0x07e0, 0x07c3), 	{I5DIV2, R1, R2, R3}, 	0, PROCESSOR_NOT_V850 | PROCESSOR_OPTION_EXTENSION },

{ "divq",	two (0x07e0, 0x02fc),   two (0x07e0, 0x07ff), 	{R1, R2, R3},		0, PROCESSOR_V850E2_UP },

{ "divqu",	two (0x07e0, 0x02fe),   two (0x07e0, 0x07ff), 	{R1, R2, R3},		0, PROCESSOR_V850E2_UP },

{ "divu",	two (0x07e0, 0x02c2),	two (0x07e0, 0x07ff), 	{R1, R2, R3}, 		0, PROCESSOR_NOT_V850 },

{ "divun",	two (0x07e0, 0x02c2),	two (0x07e0, 0x07c3), 	{I5DIV2, R1, R2, R3}, 	0, PROCESSOR_NOT_V850 | PROCESSOR_OPTION_EXTENSION },

{ "dst",	two (0x07e0, 0x0134),	two (0xfffff, 0xffff),	{0}, 		0, PROCESSOR_V850E3V5_UP },

{ "ei",		two (0x87e0, 0x0160),	two (0xffff, 0xffff),	{0}, 			0, PROCESSOR_ALL },

{ "eiret",	two (0x07e0, 0x0148),	two (0xffff, 0xffff),	{0},			0, PROCESSOR_V850E2_UP },

{ "est",	two (0x07e0, 0x0132),	two (0xfffff, 0xffff),	{0}, 		0, PROCESSOR_V850E3V5_UP },

{ "feret",	two (0x07e0, 0x014a),	two (0xffff, 0xffff),	{0},			0, PROCESSOR_V850E2_UP },

{ "fetrap",	one (0x0040),		one (0x87ff),		{I4U_NOTIMM0},		0, PROCESSOR_V850E2_UP },

{ "halt",	two (0x07e0, 0x0120),	two (0xffff, 0xffff),	{0}, 			0, PROCESSOR_ALL },

{ "hsh",	two (0x07e0, 0x0346),	two (0x07ff, 0x07ff), 	{R2, R3}, 		0, PROCESSOR_V850E2_UP },

{ "hsw",	two (0x07e0, 0x0344),	two (0x07ff, 0x07ff), 	{R2, R3}, 		0, PROCESSOR_NOT_V850 },

{ "hvcall",	two (0xd7e0, 0x4160),	two (0xffe0, 0x41ff),	{VECTOR8}, 		0, PROCESSOR_V850E3V5_UP },
{ "hvtrap",	two (0x07e0, 0x0110),	two (0xffe0, 0xffff),	{VECTOR5}, 		0, PROCESSOR_V850E3V5_UP },
  
{ "jarl",	two (0xc7e0, 0x0160),	two (0xffe0, 0x07ff),	{R1, R3_NOTR0},   	1, PROCESSOR_V850E3V5_UP},
{ "jarl",	two (0x0780, 0x0000),	two (0x07c0, 0x0001),	{D22, R2_NOTR0}, 	0, PROCESSOR_ALL},
{ "jarl",	one (0x02e0),		one (0xffe0),		{D32_31_PCREL, R1_NOTR0}, 	0, PROCESSOR_V850E2_UP },
/* Gas local alias (not defined in spec).  */
{ "jarlr", two (0xc7e0, 0x0160),	two (0xffe0, 0x07ff),	{R1, R3_NOTR0}, 1, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS},
/* Gas local alias of jarl imm22 (not defined in spec).  */
{ "jarl22",	two (0x0780, 0x0000),	two (0x07c0, 0x0001),	{D22, R2_NOTR0}, 	0, PROCESSOR_ALL | PROCESSOR_OPTION_ALIAS},
/* Gas local alias of jarl imm32 (not defined in spec).  */
{ "jarl32",	one (0x02e0),		one (0xffe0),		{D32_31_PCREL, R1_NOTR0}, 	0, PROCESSOR_V850E2_UP | PROCESSOR_OPTION_ALIAS },
{ "jarlw",	one (0x02e0),		one (0xffe0),		{D32_31_PCREL, R1_NOTR0}, 	0, PROCESSOR_V850E2_UP | PROCESSOR_OPTION_ALIAS },

{ "jmp",	two (0x06e0, 0x0000),	two (0xffe0, 0x0001),	{D32_31, R1}, 		2, PROCESSOR_V850E3V5_UP },
{ "jmp",	one (0x06e0),		one (0xffe0),		{D32_31, R1}, 		2, PROCESSOR_V850E2 | PROCESSOR_V850E2V3 },
{ "jmp",	one (0x0060),		one (0xffe0),	      	{R1}, 			1, PROCESSOR_ALL },
/* Gas local alias of jmp disp22(not defined in spec).  */
{ "jmp22",	one (0x0060),		one (0xffe0),	      	{R1}, 			1, PROCESSOR_ALL | PROCESSOR_OPTION_ALIAS },
/* Gas local alias of jmp disp32(not defined in spec).  */
{ "jmp32",	one (0x06e0),		one (0xffe0),		{D32_31, R1}, 		2, PROCESSOR_V850E2_UP | PROCESSOR_OPTION_ALIAS },
{ "jmpw",	one (0x06e0),		one (0xffe0),		{D32_31, R1}, 		2, PROCESSOR_V850E2_UP | PROCESSOR_OPTION_ALIAS },

{ "jr",		two (0x0780, 0x0000),	two (0xffc0, 0x0001),	{D22}, 			0, PROCESSOR_ALL },
{ "jr",		one (0x02e0),		one (0xffff),		{D32_31_PCREL},		0, PROCESSOR_V850E2_UP },
/* Gas local alias of mov imm22(not defined in spec).  */
{ "jr22",	two (0x0780, 0x0000),	two (0xffc0, 0x0001),	{D22}, 			0, PROCESSOR_ALL | PROCESSOR_OPTION_ALIAS },
/* Gas local alias of mov imm32(not defined in spec).  */
{ "jr32",	one (0x02e0),		one (0xffff),		{D32_31_PCREL},		0, PROCESSOR_V850E2_UP | PROCESSOR_OPTION_ALIAS },

/* Alias of bcond (same as CA850).  */
{ "jgt",	BOP (0xf),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "jge",	BOP (0xe),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "jlt",	BOP (0x6),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "jle",	BOP (0x7),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
	/* Unsigned integer.  */
{ "jh",		BOP (0xb),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "jnh",	BOP (0x3),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "jl",		BOP (0x1),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "jnl",	BOP (0x9),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
	/* Common.  */
{ "je",		BOP (0x2),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "jne",	BOP (0xa),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
	/* Others.  */
{ "jv",		BOP (0x0),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "jnv",	BOP (0x8),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "jn",		BOP (0x4),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "jp",		BOP (0xc),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "jc",		BOP (0x1),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "jnc",	BOP (0x9),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "jz",		BOP (0x2),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "jnz",	BOP (0xa),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "jbr",	BOP (0x5),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },


{ "ldacc",	two (0x07e0, 0x0bc4),	two (0x07e0, 0xffff),	{R1, R2},		0, PROCESSOR_V850E2_UP | PROCESSOR_OPTION_EXTENSION },

{ "ld.b",	two (0x0700, 0x0000),	two (0x07e0, 0x0000), 	{D16, R1, R2}, 		2, PROCESSOR_ALL },
{ "ld.b",	two (0x0780, 0x0005),	two (0x07e0, 0x000f), 	{D23, R1, R3}, 		2, PROCESSOR_V850E2_UP },
{ "ld.b23",	two (0x0780, 0x0005),	two (0x07e0, 0x000f), 	{D23, R1, R3}, 		2, PROCESSOR_V850E2_UP | PROCESSOR_OPTION_ALIAS },

{ "ld.bu",	two (0x0780, 0x0001),   two (0x07c0, 0x0001), 	{D16_16, R1, R2_NOTR0},	2, PROCESSOR_NOT_V850 },
{ "ld.bu",	two (0x07a0, 0x0005),	two (0x07e0, 0x000f), 	{D23, R1, R3}, 		2, PROCESSOR_V850E2_UP },
{ "ld.bu23",	two (0x07a0, 0x0005),	two (0x07e0, 0x000f), 	{D23, R1, R3}, 		2, PROCESSOR_V850E2_UP | PROCESSOR_OPTION_ALIAS },

{ "ld.dw",   	two (0x07a0, 0x0009), 	two (0xffe0, 0x001f), {D23_ALIGN1, R1, R3_EVEN}, 2, PROCESSOR_V850E3V5_UP },
{ "ld.dw23", 	two (0x07a0, 0x0009), 	two (0xffe0, 0x001f), {D23_ALIGN1, R1, R3_EVEN}, 2, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },

{ "ld.h",	two (0x0720, 0x0000),	two (0x07e0, 0x0001), 	{D16_15, R1, R2}, 	2, PROCESSOR_ALL },
{ "ld.h",	two (0x0780, 0x0007),	two (0x07e0, 0x000f), 	{D23_ALIGN1, R1, R3}, 	2, PROCESSOR_V850E2_UP },
{ "ld.h23",	two (0x0780, 0x0007),	two (0x07e0, 0x000f), 	{D23_ALIGN1, R1, R3}, 	2, PROCESSOR_V850E2_UP | PROCESSOR_OPTION_ALIAS },

{ "ld.hu",	two (0x07e0, 0x0001),   two (0x07e0, 0x0001), 	{D16_15, R1, R2_NOTR0},	2, PROCESSOR_NOT_V850 },
{ "ld.hu",	two (0x07a0, 0x0007),	two (0x07e0, 0x000f), 	{D23_ALIGN1, R1, R3}, 	2, PROCESSOR_V850E2_UP },
{ "ld.hu23",	two (0x07a0, 0x0007),	two (0x07e0, 0x000f), 	{D23_ALIGN1, R1, R3}, 	2, PROCESSOR_V850E2_UP | PROCESSOR_OPTION_ALIAS },

{ "ld.w",	two (0x0720, 0x0001),	two (0x07e0, 0x0001), 	{D16_15, R1, R2}, 	2, PROCESSOR_ALL },
{ "ld.w",	two (0x0780, 0x0009),	two (0xffe0, 0x001f), 	{D23_ALIGN1, R1, R3}, 	2, PROCESSOR_V850E2_UP },
{ "ld.w23",	two (0x0780, 0x0009),	two (0x07e0, 0x001f), 	{D23_ALIGN1, R1, R3}, 	2, PROCESSOR_V850E2_UP | PROCESSOR_OPTION_ALIAS },

{ "ldl.w",	two (0x07e0, 0x0378),	two (0xffe0, 0x07ff),	{R1, R3}, 		1, PROCESSOR_V850E3V5_UP },

{ "ldsr",	two (0x07e0, 0x0020),	two (0x07e0, 0x07ff),	{R1, SR2, SELID}, 	0, PROCESSOR_V850E3V5_UP },
{ "ldsr",	two (0x07e0, 0x0020),	two (0x07e0, 0x07ff),	{R1, SR2}, 		0, PROCESSOR_V850E3V5_UP },
{ "ldsr",	two (0x07e0, 0x0020),	two (0x07e0, 0x07ff),	{R1, OLDSR2}, 		0, (PROCESSOR_ALL & (~ PROCESSOR_V850E3V5_UP)) },

{ "ldtc.gr",	two (0x07e0, 0x0032),	two (0x07e0, 0xffff),	{R1, R2}, 		0, PROCESSOR_V850E3V5_UP },
{ "ldtc.sr",	two (0x07e0, 0x0030),	two (0x07e0, 0x07ff),	{R1, SR2, SELID}, 	0, PROCESSOR_V850E3V5_UP },
{ "ldtc.sr",	two (0x07e0, 0x0030),	two (0x07e0, 0x07ff),	{R1, SR2},	 	0, PROCESSOR_V850E3V5_UP },

{ "ldtc.vr",	two (0x07e0, 0x0832),	two (0x07e0, 0xffff),	{R1, VR2}, 		0, PROCESSOR_V850E3V5_UP },
{ "ldtc.pc",	two (0x07e0, 0xf832),	two (0x07e0, 0xffff),	{R1}, 			0, PROCESSOR_V850E3V5_UP },

{ "ldvc.sr",	two (0x07e0, 0x0034),	two (0x07e0, 0x07ff),	{R1, SR2, SELID}, 	0, PROCESSOR_V850E3V5_UP },
{ "ldvc.sr",	two (0x07e0, 0x0034),	two (0x07e0, 0x07ff),	{R1, SR2},	 	0, PROCESSOR_V850E3V5_UP },

{ "loop",	two (0x06e0, 0x0001),	two (0xffe0, 0x0001), 	{R1, D16_LOOP}, 	0, PROCESSOR_V850E3V5_UP },

{ "macacc",	two (0x07e0, 0x0bc0),	two (0x07e0, 0xffff),	{R1, R2},		0, PROCESSOR_V850E2_UP | PROCESSOR_OPTION_EXTENSION },

{ "mac",	two (0x07e0, 0x03c0),	two (0x07e0, 0x0fe1),	{R1, R2, R3_EVEN, R4_EVEN},    	0, PROCESSOR_V850E2_UP },

{ "macu",	two (0x07e0, 0x03e0),	two (0x07e0, 0x0fe1),	{R1, R2, R3_EVEN, R4_EVEN},  	0, PROCESSOR_V850E2_UP },

{ "macuacc",	two (0x07e0, 0x0bc2),	two (0x07e0, 0xffff),	{R1, R2},		0, PROCESSOR_V850E2_UP | PROCESSOR_OPTION_EXTENSION },

{ "mov",        OP  (0x00),		OP_MASK,		{R1, R2_NOTR0},		0, PROCESSOR_ALL },
{ "mov",	OP  (0x10),		OP_MASK,		{I5, R2_NOTR0},		0, PROCESSOR_ALL },
{ "mov",	one (0x0620),		one (0xffe0),		{IMM32, R1},		0, PROCESSOR_NOT_V850 },
/* Gas local alias of mov imm32(not defined in spec).  */
{ "movl",	one (0x0620),		one (0xffe0),		{IMM32, R1},		0, PROCESSOR_NOT_V850 | PROCESSOR_OPTION_ALIAS },

{ "movea",	OP  (0x31),		OP_MASK,		{I16, R1, R2_NOTR0},	0, PROCESSOR_ALL },

{ "movhi",	OP  (0x32),		OP_MASK,		{I16, R1, R2_NOTR0},	0, PROCESSOR_ALL },

{ "mul",	two (0x07e0, 0x0220),	two (0x07e0, 0x07ff), 	{R1, R2, R3}, 		0, PROCESSOR_NOT_V850 },
{ "mul",	two (0x07e0, 0x0240),	two (0x07e0, 0x07c3), 	{I9, R2, R3}, 		0, PROCESSOR_NOT_V850 },

{ "mulh",	OP  (0x17),		OP_MASK,		{I5, R2_NOTR0},		0, PROCESSOR_ALL },
{ "mulh",	OP  (0x07),		OP_MASK,		{R1, R2_NOTR0},		0, PROCESSOR_ALL },

{ "mulhi",	OP  (0x37),		OP_MASK,		{I16, R1, R2_NOTR0},	0, PROCESSOR_ALL },

{ "mulu",	two (0x07e0, 0x0222),	two (0x07e0, 0x07ff), 	{R1, R2, R3}, 		0, PROCESSOR_NOT_V850 },
{ "mulu",	two (0x07e0, 0x0242),	two (0x07e0, 0x07c3), 	{U9, R2, R3}, 		0, PROCESSOR_NOT_V850 },

{ "nop",	one (0x00),		one (0xffff),		{0}, 			0, PROCESSOR_ALL },

{ "not",	OP (0x01),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },

{ "not1",	two (0x47c0, 0x0000),	two (0xc7e0, 0x0000),	{B3, D16, R1}, 		3, PROCESSOR_ALL },
{ "not1",	two (0x07e0, 0x00e2),	two (0x07e0, 0xffff),	{R2, R1},    		3, PROCESSOR_NOT_V850 },

{ "or",		OP (0x08),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },

{ "ori",	OP (0x34),		OP_MASK,		IF6U, 			0, PROCESSOR_ALL },

{ "popsp",	two (0x67e0, 0x0160),	two (0xffe0, 0x07ff),	{R1, R3}, 		0, PROCESSOR_V850E3V5_UP },

{ "pref",	two (0xdfe0, 0x0160),	two (0xffe0, 0x07ff),	{PREFOP, R1}, 		2, PROCESSOR_V850E3V5_UP },

{ "prepare",    two (0x0780, 0x0003),	two (0xffc0, 0x001f), 	{LIST12, IMM5, SP}, 	0, PROCESSOR_NOT_V850 },
{ "prepare",    two (0x0780, 0x000b),	two (0xffc0, 0x001f), 	{LIST12, IMM5, IMM16LO},0, PROCESSOR_NOT_V850 },
{ "prepare",    two (0x0780, 0x0013),	two (0xffc0, 0x001f), 	{LIST12, IMM5, IMM16HI},0, PROCESSOR_NOT_V850 },
{ "prepare",    two (0x0780, 0x001b),	two (0xffc0, 0x001f), 	{LIST12, IMM5, IMM32}, 	0, PROCESSOR_NOT_V850 },
{ "prepare",    two (0x0780, 0x0001),	two (0xffc0, 0x001f), 	{LIST12, IMM5}, 	0, PROCESSOR_NOT_V850 },

{ "pushsp",	two (0x47e0, 0x0160),	two (0xffe0, 0x07ff),	{R1, R3}, 		0, PROCESSOR_V850E3V5_UP },

{ "rotl",	two (0x07e0, 0x00c6),	two (0x07e0, 0x07ff), 	{R1, R2, R3}, 		0, PROCESSOR_V850E3V5_UP },
{ "rotl",	two (0x07e0, 0x00c4),	two (0x07e0, 0x07ff), 	{I5U, R2, R3}, 		0, PROCESSOR_V850E3V5_UP },

{ "reti",	two (0x07e0, 0x0140),	two (0xffff, 0xffff),	{0}, 			0, PROCESSOR_ALL },

{ "sar",	two (0x07e0, 0x00a2),	two (0x07e0, 0x07ff), 	{R1, R2, R3}, 		0, PROCESSOR_V850E2_UP },
{ "sar",	OP (0x15),		OP_MASK,		{I5U, R2}, 		0, PROCESSOR_ALL },
{ "sar",	two (0x07e0, 0x00a0),	two (0x07e0, 0xffff), 	{R1,  R2}, 		0, PROCESSOR_ALL },

{ "sasf",       two (0x07e0, 0x0200),	two (0x07f0, 0xffff), 	{CCCC, R2}, 		0, PROCESSOR_NOT_V850 },

{ "satadd",	two (0x07e0, 0x03ba),	two (0x07e0, 0x07ff), 	{R1, R2, R3},		0, PROCESSOR_V850E2_UP },
{ "satadd",	OP (0x11),		OP_MASK,		{I5, R2_NOTR0},		0, PROCESSOR_ALL },
{ "satadd",	OP (0x06),		OP_MASK,		{R1, R2_NOTR0},		0, PROCESSOR_ALL },

{ "satsub",	two (0x07e0, 0x039a),	two (0x07e0, 0x07ff), 	{R1, R2, R3},		0, PROCESSOR_V850E2_UP },
{ "satsub",	OP (0x05),		OP_MASK,		{R1, R2_NOTR0},		0, PROCESSOR_ALL },

{ "satsubi",	OP (0x33),		OP_MASK,		{I16, R1, R2_NOTR0},	0, PROCESSOR_ALL },

{ "satsubr",	OP (0x04),		OP_MASK,		{R1, R2_NOTR0},		0, PROCESSOR_ALL },

{ "sbf",	two (0x07e0, 0x0380),	two (0x07e0, 0x07e1),	{CCCC_NOTSA, R1, R2, R3},    	0, PROCESSOR_V850E2_UP },

{ "sch0l",	two (0x07e0, 0x0364),	two (0x07ff, 0x07ff), 	{R2, R3}, 		0, PROCESSOR_V850E2_UP },

{ "sch0r",	two (0x07e0, 0x0360),	two (0x07ff, 0x07ff), 	{R2, R3}, 		0, PROCESSOR_V850E2_UP },

{ "sch1l",	two (0x07e0, 0x0366),	two (0x07ff, 0x07ff), 	{R2, R3}, 		0, PROCESSOR_V850E2_UP },

{ "sch1r",	two (0x07e0, 0x0362),	two (0x07ff, 0x07ff), 	{R2, R3}, 		0, PROCESSOR_V850E2_UP },

{ "sdivhn",	two (0x07e0, 0x0180),	two (0x07e0, 0x07c3), 	{I5DIV3, R1, R2, R3}, 	0, PROCESSOR_NOT_V850 | PROCESSOR_OPTION_EXTENSION },
{ "sdivhun",	two (0x07e0, 0x0182),	two (0x07e0, 0x07c3), 	{I5DIV3, R1, R2, R3}, 	0, PROCESSOR_NOT_V850 | PROCESSOR_OPTION_EXTENSION },
{ "sdivn",	two (0x07e0, 0x01c0),	two (0x07e0, 0x07c3), 	{I5DIV3, R1, R2, R3}, 	0, PROCESSOR_NOT_V850 | PROCESSOR_OPTION_EXTENSION },
{ "sdivun",	two (0x07e0, 0x01c2),	two (0x07e0, 0x07c3), 	{I5DIV3, R1, R2, R3}, 	0, PROCESSOR_NOT_V850 | PROCESSOR_OPTION_EXTENSION },

{ "set1",	two (0x07c0, 0x0000),	two (0xc7e0, 0x0000),	{B3, D16, R1}, 		3, PROCESSOR_ALL },
{ "set1",	two (0x07e0, 0x00e0),	two (0x07e0, 0xffff),	{R2, R1},    		3, PROCESSOR_NOT_V850 },

{ "setf",	two (0x07e0, 0x0000),	two (0x07f0, 0xffff), 	{CCCC, R2}, 		0, PROCESSOR_ALL },

{ "shl",	two (0x07e0, 0x00c2),	two (0x07e0, 0x07ff), 	{R1, R2, R3}, 		0, PROCESSOR_V850E2_UP },
{ "shl",	OP  (0x16),		OP_MASK,	      	{I5U, R2}, 		0, PROCESSOR_ALL },
{ "shl",	two (0x07e0, 0x00c0),	two (0x07e0, 0xffff), 	{R1,  R2}, 		0, PROCESSOR_ALL },

{ "shr",	two (0x07e0, 0x0082),	two (0x07e0, 0x07ff), 	{R1, R2, R3}, 		0, PROCESSOR_V850E2_UP },
{ "shr",	OP  (0x14),		OP_MASK,	      	{I5U, R2}, 		0, PROCESSOR_ALL },
{ "shr",	two (0x07e0, 0x0080),	two (0x07e0, 0xffff), 	{R1,  R2}, 		0, PROCESSOR_ALL },

{ "sld.b",	one (0x0300),		one (0x0780),	      	{D7U,  EP,   R2},	2, PROCESSOR_ALL },

{ "sld.bu",     one (0x0060),		one (0x07f0),         	{D4U,  EP,   R2_NOTR0},	2, PROCESSOR_NOT_V850 },

{ "sld.h",	one (0x0400),		one (0x0780),	      	{D8_7U,EP,   R2}, 	2, PROCESSOR_ALL },

{ "sld.hu",     one (0x0070),		one (0x07f0),         	{D5_4U,EP,   R2_NOTR0},	2, PROCESSOR_NOT_V850 },

{ "sld.w",	one (0x0500),		one (0x0781),	      	{D8_6U,EP,   R2}, 	2, PROCESSOR_ALL },

{ "snooze",	two (0x0fe0, 0x0120),	two (0xffff, 0xffff),	{0},	 		0, PROCESSOR_V850E3V5_UP },

{ "sst.b",	one (0x0380),		one (0x0780),	      	{R2,   D7U,  EP}, 	3, PROCESSOR_ALL },

{ "sst.h",	one (0x0480),		one (0x0780),	      	{R2,   D8_7U,EP}, 	3, PROCESSOR_ALL },

{ "sst.w",	one (0x0501),		one (0x0781),	      	{R2,   D8_6U,EP}, 	3, PROCESSOR_ALL },

{ "stacch",	two (0x07e0, 0x0bca),	two (0x07ff, 0xffff),	{R2},			0, PROCESSOR_V850E2_UP | PROCESSOR_OPTION_EXTENSION },
{ "staccl",	two (0x07e0, 0x0bc8),	two (0x07ff, 0xffff),	{R2},			0, PROCESSOR_V850E2_UP | PROCESSOR_OPTION_EXTENSION },

{ "st.b",	two (0x0740, 0x0000),	two (0x07e0, 0x0000), 	{R2, D16, R1}, 		3, PROCESSOR_ALL },
{ "st.b",	two (0x0780, 0x000d),	two (0x07e0, 0x000f), 	{R3, D23, R1}, 		3, PROCESSOR_V850E2_UP },
{ "st.b23",	two (0x0780, 0x000d),	two (0x07e0, 0x000f), 	{R3, D23, R1}, 		3, PROCESSOR_V850E2_UP | PROCESSOR_OPTION_ALIAS },

{ "st.dw",   	two (0x07a0, 0x000f), 	two (0xffe0, 0x001f), {R3_EVEN, D23_ALIGN1, R1}, 3, PROCESSOR_V850E3V5_UP },
{ "st.dw23", 	two (0x07a0, 0x000f), 	two (0xffe0, 0x001f), {R3_EVEN, D23_ALIGN1, R1}, 3, PROCESSOR_V850E3V5_UP | PROCESSOR_OPTION_ALIAS },

{ "st.h",	two (0x0760, 0x0000),	two (0x07e0, 0x0001), 	{R2, D16_15, R1}, 	3, PROCESSOR_ALL },
{ "st.h",	two (0x07a0, 0x000d),	two (0x07e0, 0x000f), 	{R3, D23_ALIGN1, R1}, 	3, PROCESSOR_V850E2_UP },
{ "st.h23",	two (0x07a0, 0x000d),	two (0x07e0, 0x000f), 	{R3, D23_ALIGN1, R1}, 	3, PROCESSOR_V850E2_UP | PROCESSOR_OPTION_ALIAS },

{ "st.w",	two (0x0760, 0x0001),	two (0x07e0, 0x0001), 	{R2, D16_15, R1}, 	3, PROCESSOR_ALL },
{ "st.w",	two (0x0780, 0x000f),	two (0x07e0, 0x000f), 	{R3, D23_ALIGN1, R1}, 	3, PROCESSOR_V850E2_UP },
{ "st.w23",	two (0x0780, 0x000f),	two (0x07e0, 0x000f), 	{R3, D23_ALIGN1, R1}, 	3, PROCESSOR_V850E2_UP | PROCESSOR_OPTION_ALIAS },

{ "stc.w",	two (0x07e0, 0x037a),	two (0xffe0, 0x07ff),	{R3, R1},		2, PROCESSOR_V850E3V5_UP },

{ "stsr",	two (0x07e0, 0x0040),	two (0x07e0, 0x07ff),	{SR1, R2, SELID}, 	0, PROCESSOR_V850E3V5_UP },
{ "stsr",	two (0x07e0, 0x0040),	two (0x07e0, 0x07ff),	{SR1, R2}, 		0, PROCESSOR_V850E3V5_UP },
{ "stsr",	two (0x07e0, 0x0040),	two (0x07e0, 0x07ff),	{OLDSR1, R2}, 		0, (PROCESSOR_ALL & (~ PROCESSOR_V850E3V5_UP)) },

{ "sttc.gr",	two (0x07e0, 0x0052),	two (0x07e0, 0xffff),	{R1, R2}, 		0, PROCESSOR_V850E3V5_UP },
{ "sttc.sr",	two (0x07e0, 0x0050),	two (0x07e0, 0x07ff),	{SR1, R2, SELID}, 	0, PROCESSOR_V850E3V5_UP },
{ "sttc.sr",	two (0x07e0, 0x0050),	two (0x07e0, 0x07ff),	{SR1, R2},	 	0, PROCESSOR_V850E3V5_UP },
{ "sttc.vr",	two (0x07e0, 0x0852),	two (0x07e0, 0xffff),	{VR1, R2}, 		0, PROCESSOR_V850E3V5_UP },
{ "sttc.pc",	two (0x07e0, 0xf852),	two (0x07e0, 0xffff),	{R2}, 			0, PROCESSOR_V850E3V5_UP },

{ "stvc.sr",	two (0x07e0, 0x0054),	two (0x07e0, 0x07ff),	{SR1, R2, SELID}, 	0, PROCESSOR_V850E3V5_UP },
{ "stvc.sr",	two (0x07e0, 0x0054),	two (0x07e0, 0x07ff),	{SR1, R2},	 	0, PROCESSOR_V850E3V5_UP },

{ "sub",	OP  (0x0d),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },

{ "subr", 	OP  (0x0c),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },

{ "switch",	one (0x0040),		one (0xffe0), 	      	{R1_NOTR0}, 		0, PROCESSOR_NOT_V850 },

{ "sxb",	one (0x00a0),		one (0xffe0), 	      	{R1},			0, PROCESSOR_NOT_V850 },

{ "sxh",	one (0x00e0),		one (0xffe0),	      	{R1},			0, PROCESSOR_NOT_V850 },

{ "tlbai",	two (0x87e0, 0x8960),	two (0xffff, 0xffff),	{0},	 		0, PROCESSOR_V850E3V5_UP },
{ "tlbr",	two (0x87e0, 0xe960),	two (0xffff, 0xffff),	{0},	 		0, PROCESSOR_V850E3V5_UP },
{ "tlbs",	two (0x87e0, 0xc160),	two (0xffff, 0xffff),	{0},	 		0, PROCESSOR_V850E3V5_UP },
{ "tlbvi",	two (0x87e0, 0x8160),	two (0xffff, 0xffff),	{0},	 		0, PROCESSOR_V850E3V5_UP },
{ "tlbw",	two (0x87e0, 0xe160),	two (0xffff, 0xffff),	{0},	 		0, PROCESSOR_V850E3V5_UP },

{ "trap",	two (0x07e0, 0x0100),	two (0xffe0, 0xffff),	{I5U}, 			0, PROCESSOR_ALL },

{ "tst",	OP (0x0b),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },

{ "tst1",	two (0xc7c0, 0x0000),	two (0xc7e0, 0x0000),	{B3, D16, R1}, 		3, PROCESSOR_ALL },
{ "tst1",	two (0x07e0, 0x00e6),	two (0x07e0, 0xffff),	{R2, R1},    		3, PROCESSOR_NOT_V850 },

{ "xor",	OP (0x09),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },

{ "xori",	OP (0x35),		OP_MASK,		IF6U, 			0, PROCESSOR_ALL },

{ "zxb",	one (0x0080),		one (0xffe0), 	      	{R1},			0, PROCESSOR_NOT_V850 },

{ "zxh",	one (0x00c0),		one (0xffe0), 	      	{R1},			0, PROCESSOR_NOT_V850 },

/* Floating point operation.  */
{ "absf.d",	two (0x07e0, 0x0458),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3_UP },
{ "absf.s",	two (0x07e0, 0x0448),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3_UP },
{ "addf.d",	two (0x07e0, 0x0470),	two (0x0fe1, 0x0fff),	{R1_EVEN, R2_EVEN, R3_EVEN},		0, PROCESSOR_V850E2V3_UP },
{ "addf.s",	two (0x07e0, 0x0460),	two (0x07e0, 0x07ff),	{R1, R2, R3},				0, PROCESSOR_V850E2V3_UP },
{ "ceilf.dl",	two (0x07e2, 0x0454),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3_UP },
{ "ceilf.dul",	two (0x07f2, 0x0454),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3_UP },
{ "ceilf.duw",	two (0x07f2, 0x0450),	two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3_UP },
{ "ceilf.dw",	two (0x07e2, 0x0450),	two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3_UP },
{ "ceilf.sl",	two (0x07e2, 0x0444),	two (0x07ff, 0x0fff),	{R2, R3_EVEN},				0, PROCESSOR_V850E2V3_UP },
{ "ceilf.sul",	two (0x07f2, 0x0444),	two (0x07ff, 0x0fff),	{R2, R3_EVEN},				0, PROCESSOR_V850E2V3_UP },
{ "ceilf.suw",	two (0x07f2, 0x0440),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3_UP },
{ "ceilf.sw",	two (0x07e2, 0x0440),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3_UP },
{ "cmovf.d",	two (0x07e0, 0x0410),	two (0x0fe1, 0x0ff1),	{FFF, R1_EVEN, R2_EVEN, R3_EVEN_NOTR0},	0, PROCESSOR_V850E2V3_UP },
/* Default value for FFF is 0(not defined in spec).  */
{ "cmovf.d",	two (0x07e0, 0x0410),	two (0x0fe1, 0x0fff),	{R1_EVEN, R2_EVEN, R3_EVEN_NOTR0},	0, PROCESSOR_V850E2V3_UP },
{ "cmovf.s",	two (0x07e0, 0x0400),	two (0x07e0, 0x07f1),	{FFF, R1, R2, R3_NOTR0},		0, PROCESSOR_V850E2V3_UP },
/* Default value for FFF is 0(not defined in spec).  */
{ "cmovf.s",	two (0x07e0, 0x0400),	two (0x07e0, 0x07ff),	{R1, R2, R3_NOTR0},			0, PROCESSOR_V850E2V3_UP },
{ "cmpf.d",	two (0x07e0, 0x0430),	two (0x0fe1, 0x87f1),	{FLOAT_CCCC, R2_EVEN, R1_EVEN, FFF},	0, PROCESSOR_V850E2V3_UP },
{ "cmpf.d",	two (0x07e0, 0x0430),	two (0x0fe1, 0x87ff),	{FLOAT_CCCC, R2_EVEN, R1_EVEN},		0, PROCESSOR_V850E2V3_UP },
{ "cmpf.s",	two (0x07e0, 0x0420),	two (0x07e0, 0x87f1),	{FLOAT_CCCC, R2, R1, FFF},		0, PROCESSOR_V850E2V3_UP },
{ "cmpf.s",	two (0x07e0, 0x0420),	two (0x07e0, 0x87ff),	{FLOAT_CCCC, R2, R1},			0, PROCESSOR_V850E2V3_UP },
{ "cvtf.dl",	two (0x07e4, 0x0454),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3_UP },
{ "cvtf.ds",	two (0x07e3, 0x0452),	two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3_UP },
{ "cvtf.dul",	two (0x07f4, 0x0454),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3_UP },
{ "cvtf.duw",	two (0x07f4, 0x0450),	two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3_UP },
{ "cvtf.dw",	two (0x07e4, 0x0450),	two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3_UP },
{ "cvtf.hs",	two (0x07e2, 0x0442),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E3V5_UP },
{ "cvtf.ld",	two (0x07e1, 0x0452),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3_UP },
{ "cvtf.ls",	two (0x07e1, 0x0442),	two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3_UP },
{ "cvtf.sd",	two (0x07e2, 0x0452),	two (0x07ff, 0x0fff),	{R2, R3_EVEN},				0, PROCESSOR_V850E2V3_UP },
{ "cvtf.sl",	two (0x07e4, 0x0444),	two (0x07ff, 0x0fff),	{R2, R3_EVEN},				0, PROCESSOR_V850E2V3_UP },
{ "cvtf.sh",	two (0x07e3, 0x0442),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E3V5_UP },
{ "cvtf.sul",	two (0x07f4, 0x0444),	two (0x07ff, 0x0fff),	{R2, R3_EVEN},				0, PROCESSOR_V850E2V3_UP },
{ "cvtf.suw",	two (0x07f4, 0x0440),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3_UP },
{ "cvtf.sw",	two (0x07e4, 0x0440),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3_UP },
{ "cvtf.uld",	two (0x07f1, 0x0452),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3_UP },
{ "cvtf.uls",	two (0x07f1, 0x0442),	two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3_UP },
{ "cvtf.uwd",	two (0x07f0, 0x0452),	two (0x07ff, 0x0fff),	{R2, R3_EVEN},				0, PROCESSOR_V850E2V3_UP },
{ "cvtf.uws",	two (0x07f0, 0x0442),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3_UP },
{ "cvtf.wd",	two (0x07e0, 0x0452),	two (0x07ff, 0x0fff),	{R2, R3_EVEN},				0, PROCESSOR_V850E2V3_UP },
{ "cvtf.ws",	two (0x07e0, 0x0442),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3_UP },
{ "divf.d",	two (0x07e0, 0x047e),	two (0x0fe1, 0x0fff),	{R1_EVEN, R2_EVEN, R3_EVEN},		0, PROCESSOR_V850E2V3_UP },
{ "divf.s",	two (0x07e0, 0x046e),	two (0x07e0, 0x07ff),	{R1_NOTR0, R2, R3},			0, PROCESSOR_V850E2V3_UP },
{ "floorf.dl",	two (0x07e3, 0x0454),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3_UP },
{ "floorf.dul",	two (0x07f3, 0x0454),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3_UP },
{ "floorf.duw",	two (0x07f3, 0x0450),	two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3_UP },
{ "floorf.dw",	two (0x07e3, 0x0450),	two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3_UP },
{ "floorf.sl",	two (0x07e3, 0x0444),	two (0x07ff, 0x0fff),	{R2, R3_EVEN},				0, PROCESSOR_V850E2V3_UP },
{ "floorf.sul",	two (0x07f3, 0x0444),	two (0x07ff, 0x0fff),	{R2, R3_EVEN},				0, PROCESSOR_V850E2V3_UP },
{ "floorf.suw",	two (0x07f3, 0x0440),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3_UP },
{ "floorf.sw",	two (0x07e3, 0x0440),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3_UP },
{ "maddf.s",	two (0x07e0, 0x0500),	two (0x07e0, 0x0761),	{R1, R2, R3, R4},			0, PROCESSOR_V850E2V3 },
{ "fmaf.s",	two (0x07e0, 0x04e0),	two (0x07e0, 0x07ff),	{R1, R2, R3},				0, PROCESSOR_V850E3V5_UP },
{ "maxf.d",	two (0x07e0, 0x0478),	two (0x0fe1, 0x0fff),	{R1_EVEN, R2_EVEN, R3_EVEN},		0, PROCESSOR_V850E2V3_UP },
{ "maxf.s",	two (0x07e0, 0x0468),	two (0x07e0, 0x07ff),	{R1, R2, R3},				0, PROCESSOR_V850E2V3_UP },
{ "minf.d",	two (0x07e0, 0x047a),	two (0x0fe1, 0x0fff),	{R1_EVEN, R2_EVEN, R3_EVEN},		0, PROCESSOR_V850E2V3_UP },
{ "minf.s",	two (0x07e0, 0x046a),	two (0x07e0, 0x07ff),	{R1, R2, R3},				0, PROCESSOR_V850E2V3_UP },
{ "msubf.s",	two (0x07e0, 0x0520),	two (0x07e0, 0x0761),	{R1, R2, R3, R4},			0, PROCESSOR_V850E2V3 },
{ "fmsf.s",	two (0x07e0, 0x04e2),	two (0x07e0, 0x07ff),	{R1, R2, R3},				0, PROCESSOR_V850E3V5_UP },
{ "mulf.d",	two (0x07e0, 0x0474),	two (0x0fe1, 0x0fff),	{R1_EVEN, R2_EVEN, R3_EVEN},		0, PROCESSOR_V850E2V3_UP },
{ "mulf.s",	two (0x07e0, 0x0464),	two (0x07e0, 0x07ff),	{R1, R2, R3},				0, PROCESSOR_V850E2V3_UP },
{ "negf.d",	two (0x07e1, 0x0458),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3_UP },
{ "negf.s",	two (0x07e1, 0x0448),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3_UP },
{ "nmaddf.s",	two (0x07e0, 0x0540),	two (0x07e0, 0x0761),	{R1, R2, R3, R4},			0, PROCESSOR_V850E2V3 },
{ "fnmaf.s",	two (0x07e0, 0x04e4),	two (0x07e0, 0x07ff),	{R1, R2, R3},				0, PROCESSOR_V850E3V5_UP },
{ "nmsubf.s",	two (0x07e0, 0x0560),	two (0x07e0, 0x0761),	{R1, R2, R3, R4},			0, PROCESSOR_V850E2V3 },
{ "fnmsf.s",	two (0x07e0, 0x04e6),	two (0x07e0, 0x07ff),	{R1, R2, R3},				0, PROCESSOR_V850E3V5_UP },
{ "recipf.d",	two (0x07e1, 0x045e),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3_UP },
{ "recipf.s",	two (0x07e1, 0x044e),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3_UP },

{ "roundf.dl",	two (0x07e0, 0x0454),   two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3_UP | PROCESSOR_OPTION_EXTENSION },
{ "roundf.dul",	two (0x07f0, 0x0454),   two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3_UP | PROCESSOR_OPTION_EXTENSION },
{ "roundf.duw",	two (0x07f0, 0x0450),   two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3_UP | PROCESSOR_OPTION_EXTENSION },
{ "roundf.dw",	two (0x07e0, 0x0450),   two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3_UP | PROCESSOR_OPTION_EXTENSION },
{ "roundf.sl",	two (0x07e0, 0x0444),   two (0x07ff, 0x0fff),	{R2, R3_EVEN},				0, PROCESSOR_V850E2V3_UP | PROCESSOR_OPTION_EXTENSION },
{ "roundf.sul",	two (0x07f0, 0x0444),   two (0x07ff, 0x0fff),	{R2, R3_EVEN},				0, PROCESSOR_V850E2V3_UP | PROCESSOR_OPTION_EXTENSION },
{ "roundf.suw",	two (0x07f0, 0x0440),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3_UP | PROCESSOR_OPTION_EXTENSION },
{ "roundf.sw",	two (0x07e0, 0x0440),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3_UP | PROCESSOR_OPTION_EXTENSION },

{ "rsqrtf.d",	two (0x07e2, 0x045e),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3_UP },
{ "rsqrtf.s",	two (0x07e2, 0x044e),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3_UP },
{ "sqrtf.d",	two (0x07e0, 0x045e),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3_UP },
{ "sqrtf.s",	two (0x07e0, 0x044e),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3_UP },
{ "subf.d",	two (0x07e0, 0x0472),	two (0x0fe1, 0x0fff),	{R1_EVEN, R2_EVEN, R3_EVEN},		0, PROCESSOR_V850E2V3_UP },
{ "subf.s",	two (0x07e0, 0x0462),	two (0x07e0, 0x07ff),	{R1, R2, R3},				0, PROCESSOR_V850E2V3_UP },
{ "trfsr",	two (0x07e0, 0x0400),	two (0xffff, 0xfff1),	{FFF},					0, PROCESSOR_V850E2V3_UP },
{ "trfsr",	two (0x07e0, 0x0400),	two (0xffff, 0xffff),	{0},					0, PROCESSOR_V850E2V3_UP },
{ "trncf.dl",	two (0x07e1, 0x0454),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3_UP },
{ "trncf.dul",	two (0x07f1, 0x0454),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3_UP },
{ "trncf.duw",	two (0x07f1, 0x0450),	two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3_UP },
{ "trncf.dw",	two (0x07e1, 0x0450),	two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3_UP },
{ "trncf.sl",	two (0x07e1, 0x0444),	two (0x07ff, 0x0fff),	{R2, R3_EVEN},				0, PROCESSOR_V850E2V3_UP },
{ "trncf.sul",	two (0x07f1, 0x0444),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3_UP },
{ "trncf.suw",	two (0x07f1, 0x0440),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3_UP },
{ "trncf.sw",	two (0x07e1, 0x0440),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3_UP },

  /* Special instruction (from gdb) mov 1, r0.  */
{ "breakpoint",	one (0x0001),		one (0xffff),		{UNUSED},				0, PROCESSOR_ALL },

{ "synci",	one (0x001c),		one (0xffff),		{0},					0, PROCESSOR_V850E3V5_UP },

{ "synce",	one (0x001d),		one (0xffff),		{0},					0, PROCESSOR_V850E2V3_UP },
{ "syncm",	one (0x001e),		one (0xffff),		{0},					0, PROCESSOR_V850E2V3_UP },
{ "syncp",	one (0x001f),		one (0xffff),		{0},					0, PROCESSOR_V850E2V3_UP },
{ "syscall",	two (0xd7e0, 0x0160),	two (0xffe0, 0xc7ff),	{V8},					0, PROCESSOR_V850E2V3_UP },
  /* Alias of syncp.  */
{ "sync",	one (0x001f),		one (0xffff),		{0},					0, PROCESSOR_V850E2V3_UP | PROCESSOR_OPTION_ALIAS },
{ "rmtrap",	one (0xf040),		one (0xffff),		{0},					0, PROCESSOR_V850E2V3_UP },
{ "rie",	one (0x0040),		one (0xffff),		{0},					0, PROCESSOR_V850E2V3_UP },
{ "rie",	two (0x07f0, 0x0000),	two (0x07f0, 0xffff),	{RIE_IMM5,RIE_IMM4},			0, PROCESSOR_V850E2V3_UP },

{ 0, 0, 0, {0}, 0, 0 },
} ;

const int v850_num_opcodes =
  sizeof (v850_opcodes) / sizeof (v850_opcodes[0]);
@


1.17
log
@Add support for V850E3V5 architecture
@
text
@d304 3
a306 1
  if (value < -0xffff || value > 0)
d316 1
a316 1
  return insn | ((-value & 0xfffe) << 16);
a322 1
  ret = -ret;
d1215 1
a1215 1
  { 16, 0, insert_u16_loop, extract_u16_loop, V850_OPERAND_RELAX | V850_OPERAND_DISP | V850_PCREL, BFD_RELOC_V850_16_PCREL },
a1817 1
{ "ceilf.sw",	two (0x07e2, 0x0440),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3_UP },
d1833 1
d1838 1
d1858 2
a1859 1
{ "maddf.s",	two (0x07e0, 0x0500),	two (0x07e0, 0x0761),	{R1, R2, R3, R4},			0, PROCESSOR_V850E2V3_UP },
d1864 2
a1865 1
{ "msubf.s",	two (0x07e0, 0x0520),	two (0x07e0, 0x0761),	{R1, R2, R3, R4},			0, PROCESSOR_V850E2V3_UP },
d1870 4
a1873 2
{ "nmaddf.s",	two (0x07e0, 0x0540),	two (0x07e0, 0x0761),	{R1, R2, R3, R4},			0, PROCESSOR_V850E2V3_UP },
{ "nmsubf.s",	two (0x07e0, 0x0560),	two (0x07e0, 0x0761),	{R1, R2, R3, R4},			0, PROCESSOR_V850E2V3_UP },
@


1.16
log
@	* config/tc-v850.c (md_assemble): Allow signed values for
	V850E_IMMEDIATE.

	* gas/v850/basic.exp: Allow for variations in reloc names.
	* gas/v850/split-lo16.d: Likewise.

	* gas/v850/v850e1.s: Add more tests of the PREPARE insn.
	* gas/v850/v850e1.d: Update expected disassembly.

	* v850-dis.c (get_operand_value): Sign extend V850E_IMMEDIATE
	values.
	* v850-opc.c (IMM16LO): Add V850_OPERAND_SIGNED attribute.
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2005, 2007, 2010,
   2012 Free Software Foundation, Inc.
a26 1

d61 7
a67 1

d121 1
a121 1
  return (insn | ((value << (2+16)) & 0x3c0000));
d150 1
a150 1
  return (insn | ((value << (2+16)) & 0x3c0000));
d436 16
d531 1
a531 3
    {
      * errmsg = _("invalid register name");
    }
d533 1
a533 1
  return insn | ((value & 0x10) << (23-4)) | ((value & 0x0f) << (17));
d539 125
a663 1
  unsigned long ret = ((insn >> (23-4)) & 0x10) | ((insn >> 17) & 0x0f);
d667 294
d1045 1
a1045 1
#define SR1	(LIST12 + 1)
d1048 3
d1052 1
a1052 1
#define SR2	(SR1 + 1)
d1055 3
a1187 4
/* The 16 bit immediate following a 32 bit instruction.  */
#define IMM16	(I16 + 1)
  { 16, 32, NULL, NULL, V850E_IMMEDIATE16, BFD_RELOC_16 },

d1189 1
a1189 1
#define IMM16LO	(IMM16 + 1)
d1214 1
a1214 1
  { 16, 0, insert_u16_loop, extract_u16_loop, V850_OPERAND_DISP | V850_PCREL, BFD_RELOC_V850_16_PCREL },
d1229 3
d1233 1
a1233 1
#define IMM32	(D23 + 1)
d1242 47
d1349 1
a1349 1
{ "adf",	two (0x07e0, 0x03a0),	two (0x07e0, 0x07e1),	{CCCC_NOTSA, R1, R2, R3},    	0, PROCESSOR_V850E2_ALL },
d1382 55
d1441 11
d1454 1
a1454 1
{ "caxi",	two (0x07e0, 0x00ee),	two (0x07e0, 0x07ff),	{R1, R2, R3},		1, PROCESSOR_V850E2_ALL },
d1467 6
d1475 2
d1496 1
a1496 1
{ "divq",	two (0x07e0, 0x02fc),   two (0x07e0, 0x07ff), 	{R1, R2, R3},		0, PROCESSOR_V850E2_ALL },
d1498 1
a1498 1
{ "divqu",	two (0x07e0, 0x02fe),   two (0x07e0, 0x07ff), 	{R1, R2, R3},		0, PROCESSOR_V850E2_ALL },
d1504 2
d1508 1
a1508 1
{ "eiret",	two (0x07e0, 0x0148),	two (0xffff, 0xffff),	{0},			0, PROCESSOR_V850E2_ALL },
d1510 1
a1510 1
{ "feret",	two (0x07e0, 0x014a),	two (0xffff, 0xffff),	{0},			0, PROCESSOR_V850E2_ALL },
d1512 3
a1514 1
{ "fetrap",	one (0x0040),		one (0x87ff),		{I4U_NOTIMM0},		0, PROCESSOR_V850E2_ALL },
d1518 1
a1518 1
{ "hsh",	two (0x07e0, 0x0346),	two (0x07ff, 0x07ff), 	{R2, R3}, 		0, PROCESSOR_V850E2_ALL },
d1522 4
d1527 4
a1530 2
{ "jarl",	one (0x02e0),		one (0xffe0),		{D32_31_PCREL, R1_NOTR0}, 	0, PROCESSOR_V850E2_ALL },
/* Gas local alias of mov imm22(not defined in spec).  */
d1532 3
a1534 3
/* Gas local alias of mov imm32(not defined in spec).  */
{ "jarl32",	one (0x02e0),		one (0xffe0),		{D32_31_PCREL, R1_NOTR0}, 	0, PROCESSOR_V850E2_ALL | PROCESSOR_OPTION_ALIAS },
{ "jarlw",	one (0x02e0),		one (0xffe0),		{D32_31_PCREL, R1_NOTR0}, 	0, PROCESSOR_V850E2_ALL | PROCESSOR_OPTION_ALIAS },
d1536 2
a1537 1
{ "jmp",	one (0x06e0),		one (0xffe0),		{D32_31, R1}, 		2, PROCESSOR_V850E2_ALL },
d1542 2
a1543 2
{ "jmp32",	one (0x06e0),		one (0xffe0),		{D32_31, R1}, 		2, PROCESSOR_V850E2_ALL | PROCESSOR_OPTION_ALIAS },
{ "jmpw",	one (0x06e0),		one (0xffe0),		{D32_31, R1}, 		2, PROCESSOR_V850E2_ALL | PROCESSOR_OPTION_ALIAS },
d1546 1
a1546 1
{ "jr",		one (0x02e0),		one (0xffff),		{D32_31_PCREL},		0, PROCESSOR_V850E2_ALL },
d1550 1
a1550 1
{ "jr32",	one (0x02e0),		one (0xffff),		{D32_31_PCREL},		0, PROCESSOR_V850E2_ALL | PROCESSOR_OPTION_ALIAS },
d1577 1
a1577 1
{ "ldacc",	two (0x07e0, 0x0bc4),	two (0x07e0, 0xffff),	{R1, R2},		0, PROCESSOR_V850E2_ALL | PROCESSOR_OPTION_EXTENSION },
d1580 2
a1581 2
{ "ld.b",	two (0x0780, 0x0005),	two (0x07e0, 0x000f), 	{D23, R1, R3}, 		2, PROCESSOR_V850E2_ALL },
{ "ld.b23",	two (0x0780, 0x0005),	two (0x07e0, 0x000f), 	{D23, R1, R3}, 		2, PROCESSOR_V850E2_ALL | PROCESSOR_OPTION_ALIAS },
d1584 5
a1588 2
{ "ld.bu",	two (0x07a0, 0x0005),	two (0x07e0, 0x000f), 	{D23, R1, R3}, 		2, PROCESSOR_V850E2_ALL },
{ "ld.bu23",	two (0x07a0, 0x0005),	two (0x07e0, 0x000f), 	{D23, R1, R3}, 		2, PROCESSOR_V850E2_ALL | PROCESSOR_OPTION_ALIAS },
d1591 2
a1592 2
{ "ld.h",	two (0x0780, 0x0007),	two (0x07e0, 0x000f), 	{D23, R1, R3}, 		2, PROCESSOR_V850E2_ALL },
{ "ld.h23",	two (0x0780, 0x0007),	two (0x07e0, 0x000f), 	{D23, R1, R3}, 		2, PROCESSOR_V850E2_ALL | PROCESSOR_OPTION_ALIAS },
d1595 2
a1596 2
{ "ld.hu",	two (0x07a0, 0x0007),	two (0x07e0, 0x000f), 	{D23, R1, R3}, 		2, PROCESSOR_V850E2_ALL },
{ "ld.hu23",	two (0x07a0, 0x0007),	two (0x07e0, 0x000f), 	{D23, R1, R3}, 		2, PROCESSOR_V850E2_ALL | PROCESSOR_OPTION_ALIAS },
d1598 16
d1615 2
a1616 3
{ "ld.w",	two (0x0720, 0x0001),	two (0x07e0, 0x0001), 	{D16_15, R1, R2}, 	2, PROCESSOR_ALL },
{ "ld.w",	two (0x0780, 0x0009),	two (0x07e0, 0x000f), 	{D23, R1, R3}, 		2, PROCESSOR_V850E2_ALL },
{ "ld.w23",	two (0x0780, 0x0009),	two (0x07e0, 0x000f), 	{D23, R1, R3}, 		2, PROCESSOR_V850E2_ALL | PROCESSOR_OPTION_ALIAS },
d1618 1
a1618 1
{ "ldsr",	two (0x07e0, 0x0020),	two (0x07e0, 0xffff),	{R1, SR2}, 		0, PROCESSOR_ALL },
d1620 1
a1620 1
{ "macacc",	two (0x07e0, 0x0bc0),	two (0x07e0, 0xffff),	{R1, R2},		0, PROCESSOR_V850E2_ALL | PROCESSOR_OPTION_EXTENSION },
d1622 1
a1622 1
{ "mac",	two (0x07e0, 0x03c0),	two (0x07e0, 0x0fe1),	{R1, R2, R3_EVEN, R4_EVEN},    	0, PROCESSOR_V850E2_ALL },
d1624 1
a1624 1
{ "macu",	two (0x07e0, 0x03e0),	two (0x07e0, 0x0fe1),	{R1, R2, R3_EVEN, R4_EVEN},  	0, PROCESSOR_V850E2_ALL },
d1626 1
a1626 1
{ "macuacc",	two (0x07e0, 0x0bc2),	two (0x07e0, 0xffff),	{R1, R2},		0, PROCESSOR_V850E2_ALL | PROCESSOR_OPTION_EXTENSION },
d1660 4
d1670 5
d1677 1
a1677 1
{ "sar",	two (0x07e0, 0x00a2),	two (0x07e0, 0x07ff), 	{R1, R2, R3}, 		0, PROCESSOR_V850E2_ALL },
d1683 1
a1683 1
{ "satadd",	two (0x07e0, 0x03ba),	two (0x07e0, 0x07ff), 	{R1, R2, R3},		0, PROCESSOR_V850E2_ALL },
d1687 1
a1687 1
{ "satsub",	two (0x07e0, 0x039a),	two (0x07e0, 0x07ff), 	{R1, R2, R3},		0, PROCESSOR_V850E2_ALL },
d1694 1
a1694 1
{ "sbf",	two (0x07e0, 0x0380),	two (0x07e0, 0x07e1),	{CCCC_NOTSA, R1, R2, R3},    	0, PROCESSOR_V850E2_ALL },
d1696 1
a1696 1
{ "sch0l",	two (0x07e0, 0x0364),	two (0x07ff, 0x07ff), 	{R2, R3}, 		0, PROCESSOR_V850E2_ALL },
d1698 1
a1698 1
{ "sch0r",	two (0x07e0, 0x0360),	two (0x07ff, 0x07ff), 	{R2, R3}, 		0, PROCESSOR_V850E2_ALL },
d1700 1
a1700 1
{ "sch1l",	two (0x07e0, 0x0366),	two (0x07ff, 0x07ff), 	{R2, R3}, 		0, PROCESSOR_V850E2_ALL },
d1702 1
a1702 1
{ "sch1r",	two (0x07e0, 0x0362),	two (0x07ff, 0x07ff), 	{R2, R3}, 		0, PROCESSOR_V850E2_ALL },
d1714 1
a1714 1
{ "shl",	two (0x07e0, 0x00c2),	two (0x07e0, 0x07ff), 	{R1, R2, R3}, 		0, PROCESSOR_V850E2_ALL },
d1718 1
a1718 1
{ "shr",	two (0x07e0, 0x0082),	two (0x07e0, 0x07ff), 	{R1, R2, R3}, 		0, PROCESSOR_V850E2_ALL },
d1732 2
d1740 2
a1741 2
{ "stacch",	two (0x07e0, 0x0bca),	two (0x07ff, 0xffff),	{R2},			0, PROCESSOR_V850E2_ALL | PROCESSOR_OPTION_EXTENSION },
{ "staccl",	two (0x07e0, 0x0bc8),	two (0x07ff, 0xffff),	{R2},			0, PROCESSOR_V850E2_ALL | PROCESSOR_OPTION_EXTENSION },
d1744 5
a1748 2
{ "st.b",	two (0x0780, 0x000d),	two (0x07e0, 0x000f), 	{R3, D23, R1}, 		3, PROCESSOR_V850E2_ALL },
{ "st.b23",	two (0x0780, 0x000d),	two (0x07e0, 0x000f), 	{R3, D23, R1}, 		3, PROCESSOR_V850E2_ALL | PROCESSOR_OPTION_ALIAS },
d1751 2
a1752 2
{ "st.h",	two (0x07a0, 0x000d),	two (0x07e0, 0x000f), 	{R3, D23, R1}, 		3, PROCESSOR_V850E2_ALL },
{ "st.h23",	two (0x07a0, 0x000d),	two (0x07e0, 0x000f), 	{R3, D23, R1}, 		3, PROCESSOR_V850E2_ALL | PROCESSOR_OPTION_ALIAS },
d1755 14
a1768 2
{ "st.w",	two (0x0780, 0x000f),	two (0x07e0, 0x000f), 	{R3, D23, R1}, 		3, PROCESSOR_V850E2_ALL },
{ "st.w23",	two (0x0780, 0x000f),	two (0x07e0, 0x000f), 	{R3, D23, R1}, 		3, PROCESSOR_V850E2_ALL | PROCESSOR_OPTION_ALIAS },
d1770 2
a1771 1
{ "stsr",	two (0x07e0, 0x0040),	two (0x07e0, 0xffff),	{SR1, R2}, 		0, PROCESSOR_ALL },
d1783 6
d1805 14
a1818 14
{ "absf.d",	two (0x07e0, 0x0458),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3 },
{ "absf.s",	two (0x07e0, 0x0448),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3 },
{ "addf.d",	two (0x07e0, 0x0470),	two (0x0fe1, 0x0fff),	{R1_EVEN, R2_EVEN, R3_EVEN},		0, PROCESSOR_V850E2V3 },
{ "addf.s",	two (0x07e0, 0x0460),	two (0x07e0, 0x07ff),	{R1, R2, R3},				0, PROCESSOR_V850E2V3 },
{ "ceilf.dl",	two (0x07e2, 0x0454),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3 },
{ "ceilf.dul",	two (0x07f2, 0x0454),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3 },
{ "ceilf.duw",	two (0x07f2, 0x0450),	two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3 },
{ "ceilf.dw",	two (0x07e2, 0x0450),	two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3 },
{ "ceilf.sl",	two (0x07e2, 0x0444),	two (0x07ff, 0x0fff),	{R2, R3_EVEN},				0, PROCESSOR_V850E2V3 },
{ "ceilf.sul",	two (0x07f2, 0x0444),	two (0x07ff, 0x0fff),	{R2, R3_EVEN},				0, PROCESSOR_V850E2V3 },
{ "ceilf.suw",	two (0x07f2, 0x0440),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3 },
{ "ceilf.sw",	two (0x07e2, 0x0440),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3 },
{ "ceilf.sw",	two (0x07e2, 0x0440),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3 },
{ "cmovf.d",	two (0x07e0, 0x0410),	two (0x0fe1, 0x0ff1),	{FFF, R1_EVEN, R2_EVEN, R3_EVEN_NOTR0},	0, PROCESSOR_V850E2V3 },
d1820 2
a1821 2
{ "cmovf.d",	two (0x07e0, 0x0410),	two (0x0fe1, 0x0fff),	{R1_EVEN, R2_EVEN, R3_EVEN_NOTR0},	0, PROCESSOR_V850E2V3 },
{ "cmovf.s",	two (0x07e0, 0x0400),	two (0x07e0, 0x07f1),	{FFF, R1, R2, R3_NOTR0},		0, PROCESSOR_V850E2V3 },
d1823 73
a1895 73
{ "cmovf.s",	two (0x07e0, 0x0400),	two (0x07e0, 0x07ff),	{R1, R2, R3_NOTR0},			0, PROCESSOR_V850E2V3 },
{ "cmpf.d",	two (0x07e0, 0x0430),	two (0x0fe1, 0x87f1),	{FLOAT_CCCC, R2_EVEN, R1_EVEN, FFF},	0, PROCESSOR_V850E2V3 },
{ "cmpf.d",	two (0x07e0, 0x0430),	two (0x0fe1, 0x87ff),	{FLOAT_CCCC, R2_EVEN, R1_EVEN},		0, PROCESSOR_V850E2V3 },
{ "cmpf.s",	two (0x07e0, 0x0420),	two (0x07e0, 0x87f1),	{FLOAT_CCCC, R2, R1, FFF},		0, PROCESSOR_V850E2V3 },
{ "cmpf.s",	two (0x07e0, 0x0420),	two (0x07e0, 0x87ff),	{FLOAT_CCCC, R2, R1},			0, PROCESSOR_V850E2V3 },
{ "cvtf.dl",	two (0x07e4, 0x0454),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3 },
{ "cvtf.ds",	two (0x07e3, 0x0452),	two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3 },
{ "cvtf.dul",	two (0x07f4, 0x0454),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3 },
{ "cvtf.duw",	two (0x07f4, 0x0450),	two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3 },
{ "cvtf.dw",	two (0x07e4, 0x0450),	two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3 },
{ "cvtf.ld",	two (0x07e1, 0x0452),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3 },
{ "cvtf.ls",	two (0x07e1, 0x0442),	two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3 },
{ "cvtf.sd",	two (0x07e2, 0x0452),	two (0x07ff, 0x0fff),	{R2, R3_EVEN},				0, PROCESSOR_V850E2V3 },
{ "cvtf.sl",	two (0x07e4, 0x0444),	two (0x07ff, 0x0fff),	{R2, R3_EVEN},				0, PROCESSOR_V850E2V3 },
{ "cvtf.sul",	two (0x07f4, 0x0444),	two (0x07ff, 0x0fff),	{R2, R3_EVEN},				0, PROCESSOR_V850E2V3 },
{ "cvtf.suw",	two (0x07f4, 0x0440),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3 },
{ "cvtf.sw",	two (0x07e4, 0x0440),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3 },
{ "cvtf.uld",	two (0x07f1, 0x0452),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3 },
{ "cvtf.uls",	two (0x07f1, 0x0442),	two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3 },
{ "cvtf.uwd",	two (0x07f0, 0x0452),	two (0x07ff, 0x0fff),	{R2, R3_EVEN},				0, PROCESSOR_V850E2V3 },
{ "cvtf.uws",	two (0x07f0, 0x0442),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3 },
{ "cvtf.wd",	two (0x07e0, 0x0452),	two (0x07ff, 0x0fff),	{R2, R3_EVEN},				0, PROCESSOR_V850E2V3 },
{ "cvtf.ws",	two (0x07e0, 0x0442),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3 },
{ "divf.d",	two (0x07e0, 0x047e),	two (0x0fe1, 0x0fff),	{R1_EVEN, R2_EVEN, R3_EVEN},		0, PROCESSOR_V850E2V3 },
{ "divf.s",	two (0x07e0, 0x046e),	two (0x07e0, 0x07ff),	{R1_NOTR0, R2, R3},			0, PROCESSOR_V850E2V3 },
{ "floorf.dl",	two (0x07e3, 0x0454),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3 },
{ "floorf.dul",	two (0x07f3, 0x0454),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3 },
{ "floorf.duw",	two (0x07f3, 0x0450),	two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3 },
{ "floorf.dw",	two (0x07e3, 0x0450),	two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3 },
{ "floorf.sl",	two (0x07e3, 0x0444),	two (0x07ff, 0x0fff),	{R2, R3_EVEN},				0, PROCESSOR_V850E2V3 },
{ "floorf.sul",	two (0x07f3, 0x0444),	two (0x07ff, 0x0fff),	{R2, R3_EVEN},				0, PROCESSOR_V850E2V3 },
{ "floorf.suw",	two (0x07f3, 0x0440),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3 },
{ "floorf.sw",	two (0x07e3, 0x0440),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3 },
{ "maddf.s",	two (0x07e0, 0x0500),	two (0x07e0, 0x0761),	{R1, R2, R3, R4},			0, PROCESSOR_V850E2V3 },
{ "maxf.d",	two (0x07e0, 0x0478),	two (0x0fe1, 0x0fff),	{R1_EVEN, R2_EVEN, R3_EVEN},		0, PROCESSOR_V850E2V3 },
{ "maxf.s",	two (0x07e0, 0x0468),	two (0x07e0, 0x07ff),	{R1, R2, R3},				0, PROCESSOR_V850E2V3 },
{ "minf.d",	two (0x07e0, 0x047a),	two (0x0fe1, 0x0fff),	{R1_EVEN, R2_EVEN, R3_EVEN},		0, PROCESSOR_V850E2V3 },
{ "minf.s",	two (0x07e0, 0x046a),	two (0x07e0, 0x07ff),	{R1, R2, R3},				0, PROCESSOR_V850E2V3 },
{ "msubf.s",	two (0x07e0, 0x0520),	two (0x07e0, 0x0761),	{R1, R2, R3, R4},			0, PROCESSOR_V850E2V3 },
{ "mulf.d",	two (0x07e0, 0x0474),	two (0x0fe1, 0x0fff),	{R1_EVEN, R2_EVEN, R3_EVEN},		0, PROCESSOR_V850E2V3 },
{ "mulf.s",	two (0x07e0, 0x0464),	two (0x07e0, 0x07ff),	{R1, R2, R3},				0, PROCESSOR_V850E2V3 },
{ "negf.d",	two (0x07e1, 0x0458),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3 },
{ "negf.s",	two (0x07e1, 0x0448),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3 },
{ "nmaddf.s",	two (0x07e0, 0x0540),	two (0x07e0, 0x0761),	{R1, R2, R3, R4},			0, PROCESSOR_V850E2V3 },
{ "nmsubf.s",	two (0x07e0, 0x0560),	two (0x07e0, 0x0761),	{R1, R2, R3, R4},			0, PROCESSOR_V850E2V3 },
{ "recipf.d",	two (0x07e1, 0x045e),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3 },
{ "recipf.s",	two (0x07e1, 0x044e),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3 },

{ "roundf.dl",	two (0x07e0, 0x0454),   two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3 | PROCESSOR_OPTION_EXTENSION },
{ "roundf.dul",	two (0x07f0, 0x0454),   two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3 | PROCESSOR_OPTION_EXTENSION },
{ "roundf.duw",	two (0x07f0, 0x0450),   two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3 | PROCESSOR_OPTION_EXTENSION },
{ "roundf.dw",	two (0x07e0, 0x0450),   two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3 | PROCESSOR_OPTION_EXTENSION },
{ "roundf.sl",	two (0x07e0, 0x0444),   two (0x07ff, 0x0fff),	{R2, R3_EVEN},				0, PROCESSOR_V850E2V3 | PROCESSOR_OPTION_EXTENSION },
{ "roundf.sul",	two (0x07f0, 0x0444),   two (0x07ff, 0x0fff),	{R2, R3_EVEN},				0, PROCESSOR_V850E2V3 | PROCESSOR_OPTION_EXTENSION },
{ "roundf.suw",	two (0x07f0, 0x0440),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3 | PROCESSOR_OPTION_EXTENSION },
{ "roundf.sw",	two (0x07e0, 0x0440),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3 | PROCESSOR_OPTION_EXTENSION },

{ "rsqrtf.d",	two (0x07e2, 0x045e),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3 },
{ "rsqrtf.s",	two (0x07e2, 0x044e),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3 },
{ "sqrtf.d",	two (0x07e0, 0x045e),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3 },
{ "sqrtf.s",	two (0x07e0, 0x044e),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3 },
{ "subf.d",	two (0x07e0, 0x0472),	two (0x0fe1, 0x0fff),	{R1_EVEN, R2_EVEN, R3_EVEN},		0, PROCESSOR_V850E2V3 },
{ "subf.s",	two (0x07e0, 0x0462),	two (0x07e0, 0x07ff),	{R1, R2, R3},				0, PROCESSOR_V850E2V3 },
{ "trfsr",	two (0x07e0, 0x0400),	two (0xffff, 0xfff1),	{FFF},					0, PROCESSOR_V850E2V3 },
{ "trfsr",	two (0x07e0, 0x0400),	two (0xffff, 0xffff),	{0},					0, PROCESSOR_V850E2V3 },
{ "trncf.dl",	two (0x07e1, 0x0454),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3 },
{ "trncf.dul",	two (0x07f1, 0x0454),	two (0x0fff, 0x0fff),	{R2_EVEN, R3_EVEN},			0, PROCESSOR_V850E2V3 },
{ "trncf.duw",	two (0x07f1, 0x0450),	two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3 },
{ "trncf.dw",	two (0x07e1, 0x0450),	two (0x0fff, 0x07ff),	{R2_EVEN, R3},				0, PROCESSOR_V850E2V3 },
{ "trncf.sl",	two (0x07e1, 0x0444),	two (0x07ff, 0x0fff),	{R2, R3_EVEN},				0, PROCESSOR_V850E2V3 },
{ "trncf.sul",	two (0x07f1, 0x0444),	two (0x07ff, 0x07ff),	{R2, R3},			0, PROCESSOR_V850E2V3 },
{ "trncf.suw",	two (0x07f1, 0x0440),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3 },
{ "trncf.sw",	two (0x07e1, 0x0440),	two (0x07ff, 0x07ff),	{R2, R3},				0, PROCESSOR_V850E2V3 },
d1900 6
a1905 5
  /* V850e2-v3.  */
{ "synce",	one (0x001d),		one (0xffff),		{0},					0, PROCESSOR_V850E2V3 },
{ "syncm",	one (0x001e),		one (0xffff),		{0},					0, PROCESSOR_V850E2V3 },
{ "syncp",	one (0x001f),		one (0xffff),		{0},					0, PROCESSOR_V850E2V3 },
{ "syscall",	two (0xd7e0, 0x0160),	two (0xffe0, 0xc7ff),	{V8},					0, PROCESSOR_V850E2V3 },
d1907 4
a1910 6
{ "sync",	one (0x001f),		one (0xffff),		{0},					0, PROCESSOR_V850E2V3 | PROCESSOR_OPTION_ALIAS },
{ "rmtrap",	one (0xf040),		one (0xffff),		{0},					0, PROCESSOR_V850E2V3 },


{ "rie",	one (0x0040),		one (0xffff),		{0},					0, PROCESSOR_V850E2V3 },
{ "rie",	two (0x07f0, 0x0000),	two (0x07f0, 0xffff),	{0},					0, PROCESSOR_V850E2V3 },
@


1.15
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@d750 1
a750 1
/* The 16 bit immediate following a 32 bit instruction.  */
d752 1
a752 1
  { 16, 32, NULL, NULL, V850E_IMMEDIATE16, BFD_RELOC_LO16 },
@


1.14
log
@	* v850-opc.c (extract_v8): Rearrange to make it obvious this
	is the inverse of corresponding insert function.
	(extract_d22, extract_u9, extract_r4): Likewise.
	(extract_d9): Correct sign extension.
	(extract_d16_15): Don't assume "long" is 32 bits, and don't
	rely on implementation defined behaviour for shift right of
	signed types.
	(extract_d16_16, extract_d17_16, extract_i9): Likewise.
	(extract_d23): Likewise, and correct mask.
@
text
@d22 1
a23 1
#include "sysdep.h"
@


1.13
log
@	* v850-opc.c (cmpf.[sd]): Reverse the order of the reg1 and reg2
	operands.
@
text
@d2 2
a3 2
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2005, 2007, 2010
   Free Software Foundation, Inc.
d262 1
a262 1
  unsigned long ret = (insn & 0x1f) | ((insn & 0x38000000) >> (27-5));
d288 1
a288 1
  unsigned long ret = ((insn & 0xf800) >> 7) | ((insn & 0x0070) >> 3);
d290 1
a290 2
  if ((insn & 0x8000) != 0)
    ret -= 0x0200;
d343 3
a345 2
  signed long ret = (insn & 0xfffe0000);
  ret >>= 16;
d364 3
a366 3
  signed long ret = insn & 0xfffe0000;
  ret >>= 16;
  ret |= ((insn & 0x20) >> 5);
d385 3
a387 3
  signed long ret = (insn >> 16) & 0xfffe;
  ret |= (insn << (16 - 4)) & 0x10000;
  ret = (ret << ((sizeof ret)*8 - 17)) >> ((sizeof ret)*8 - 17);
d413 1
a413 1
  signed long ret = ((insn & 0xfffe0000) >> 16) | ((insn & 0x3f) << 16);
d415 1
a415 1
  ret = (ret << ((sizeof ret)*8 - 22)) >> ((sizeof ret)*8 - 22);
d426 1
a426 1
	* errmsg = out_of_range;
d434 1
a434 1
  signed long ret = ((insn >> 4) & 0x7f) | ((insn >> (16-7)) & 0x7fffff80);
d436 1
a436 1
  ret = ((ret << ((sizeof ret)*8 - 23)) >> ((sizeof ret)*8 - 23));
d455 1
a455 1
  signed long ret = insn & 0x003c0000;
d457 1
a457 3
  ret <<= 10;
  ret >>= 23;
  ret |= (insn & 0x1f);
d478 1
a478 5
  unsigned long ret = insn & 0x003c0000;

  ret >>= 13;

  ret |= (insn & 0x1f);
d493 1
a493 1
  return insn & (~ 0x180000);
d521 1
a521 3
  unsigned long ret;
  ret = (insn >> 17) & 0xf;
  ret |= (insn >> (23-4)) & 0x10;
@


1.12
log
@Add support for v850E2 and v850E2V3
@
text
@d1208 4
a1211 4
{ "cmpf.d",	two (0x07e0, 0x0430),	two (0x0fe1, 0x87f1),	{FLOAT_CCCC, R1_EVEN, R2_EVEN, FFF},	0, PROCESSOR_V850E2V3 },
{ "cmpf.d",	two (0x07e0, 0x0430),	two (0x0fe1, 0x87ff),	{FLOAT_CCCC, R1_EVEN, R2_EVEN},		0, PROCESSOR_V850E2V3 },
{ "cmpf.s",	two (0x07e0, 0x0420),	two (0x07e0, 0x87f1),	{FLOAT_CCCC, R1, R2, FFF},		0, PROCESSOR_V850E2V3 },
{ "cmpf.s",	two (0x07e0, 0x0420),	two (0x07e0, 0x87ff),	{FLOAT_CCCC, R1, R2},			0, PROCESSOR_V850E2V3 },
@


1.11
log
@Change source files over to GPLv3.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2005, 2007
d22 1
d25 1
a25 1
#include <stdio.h>
d28 1
d33 7
a39 3
/* Conditional branch opcodes.  */
#define BOP(x)		((0x0b << 7) | (x & 0x0f))
#define BOP_MASK	((0x0f << 7) | 0x0f)
d46 1
d60 12
d74 1
a74 1
insert_d9 (unsigned long insn, long value, const char ** errmsg)
d76 1
a76 1
  if (value > 0xff || value < -0x100)
d78 2
a79 2
      if ((value % 2) != 0)
	* errmsg = _("branch value not in range and to odd offset");
d81 1
a81 1
	* errmsg = _("branch value out of range");
d83 4
a86 2
  else if ((value % 2) != 0)
    * errmsg = _("branch to odd offset");
d88 1
a88 1
  return insn | ((value & 0x1f0) << 7) | ((value & 0x0e) << 3);
d92 1
a92 1
extract_d9 (unsigned long insn, int * invalid ATTRIBUTE_UNUSED)
d94 2
a95 4
  unsigned long ret = ((insn & 0xf800) >> 7) | ((insn & 0x0070) >> 3);

  if ((insn & 0x8000) != 0)
    ret -= 0x0200;
d97 2
d103 1
a103 1
insert_d22 (unsigned long insn, long value, const char ** errmsg)
d105 1
a105 1
  if (value > 0x1fffff || value < -0x200000)
d107 2
a108 2
      if ((value % 2) != 0)
	* errmsg = _("branch value not in range and to an odd offset");
d110 1
a110 1
	* errmsg = _("branch value out of range");
d112 4
a115 2
  else if ((value % 2) != 0)
    * errmsg = _("branch to odd offset");
d117 1
a117 1
  return insn | ((value & 0xfffe) << 16) | ((value & 0x3f0000) >> 16);
d121 1
a121 1
extract_d22 (unsigned long insn, int * invalid ATTRIBUTE_UNUSED)
d123 2
a124 1
  signed long ret = ((insn & 0xfffe0000) >> 16) | ((insn & 0x3f) << 16);
d126 3
a128 1
  return (unsigned long) ((ret << 10) >> 10);
d132 1
a132 1
insert_d16_15 (unsigned long insn, long value, const char ** errmsg)
d134 1
a134 1
  if (value > 0x7fff || value < -0x8000)
d136 1
a136 1
      if ((value % 2) != 0)
d141 1
a141 1
  else if ((value % 2) != 0)
d144 3
a146 1
  return insn | ((value & 0xfffe) << 16);
d150 1
a150 1
extract_d16_15 (unsigned long insn, int * invalid ATTRIBUTE_UNUSED)
d152 2
a153 1
  signed long ret = (insn & 0xfffe0000);
d155 3
a157 1
  return ret >> 16;
d161 1
a161 1
insert_d8_7 (unsigned long insn, long value, const char ** errmsg)
d163 1
a163 1
  if (value > 0xff || value < 0)
d165 1
a165 1
      if ((value % 2) != 0)
d170 1
a170 1
  else if ((value % 2) != 0)
d175 1
a175 1
  return insn | (value & 0x7f);
d179 1
a179 1
extract_d8_7 (unsigned long insn, int * invalid ATTRIBUTE_UNUSED)
d181 3
a183 1
  unsigned long ret = (insn & 0x7f);
d185 3
a187 1
  return ret << 1;
d196 1
a196 1
	*errmsg = _(not_valid);
d209 1
a209 1
extract_d8_6 (unsigned long insn, int * invalid ATTRIBUTE_UNUSED)
d213 5
a217 1
  return ret << 1;
d221 1
a221 1
insert_d5_4 (unsigned long insn, long value, const char ** errmsg)
d223 1
a223 1
  if (value > 0x1f || value < 0)
d225 1
a225 1
      if (value & 1)
d228 1
a228 1
	*errmsg = _(out_of_range);
d230 1
a230 1
  else if (value & 1)
d235 104
a338 1
  return insn | (value & 0x0f);
d342 1
a342 1
extract_d5_4 (unsigned long insn, int * invalid ATTRIBUTE_UNUSED)
d344 2
a345 1
  unsigned long ret = (insn & 0x0f);
d347 3
a349 1
  return ret << 1;
d362 1
a362 1
extract_d16_16 (unsigned long insn, int * invalid ATTRIBUTE_UNUSED)
a364 1

a365 1

d368 2
d374 70
d453 1
a453 1
extract_i9 (unsigned long insn, int * invalid ATTRIBUTE_UNUSED)
a458 1

d461 2
d478 1
a478 1
extract_u9 (unsigned long insn, int * invalid ATTRIBUTE_UNUSED)
d486 2
d503 1
a503 2
extract_spe (unsigned long insn ATTRIBUTE_UNUSED,
	     int * invalid ATTRIBUTE_UNUSED)
d505 3
d512 1
a512 1
insert_i5div (unsigned long insn, long v, const char ** errmsg)
d516 1
a516 1
  if (value > 0x1ff)
d518 1
a518 4
      if (value & 1)
	* errmsg = _("immediate value not in range and not even");
      else
	* errmsg = _(immediate_out_of_range);
a519 4
  else if (value & 1)
    * errmsg = _("immediate value must be even");

  value = 32 - value;
d521 1
a521 1
  return insn | ((value & 0x1e) << 17);
d525 1
a525 1
extract_i5div (unsigned long insn, int * invalid ATTRIBUTE_UNUSED)
d527 3
a529 5
  unsigned long ret = insn & 0x3c0000;

  ret >>= 17;

  ret = 32 - ret;
d531 2
a534 1

d542 1
a542 1
  { 0, 0, NULL, NULL, 0 },
d544 1
a544 1
/* The R1 field in a format 1, 6, 7, or 9 insn.  */
d546 1
a546 1
  { 5, 0, NULL, NULL, V850_OPERAND_REG },
d550 1
a550 1
  { 5, 0, NULL, NULL, V850_OPERAND_REG | V850_NOT_R0 },
d552 15
a566 3
/* The R2 field in a format 1, 2, 4, 5, 6, 7, 9 insn.  */
#define R2	(R1_NOTR0 + 1)
  { 5, 11, NULL, NULL, V850_OPERAND_REG },
d570 5
a574 1
  { 5, 11, NULL, NULL, V850_OPERAND_REG | V850_NOT_R0 },
d576 3
a578 3
/* The imm5 field in a format 2 insn.  */
#define I5	(R2_NOTR0 + 1)
  { 5, 0, NULL, NULL, V850_OPERAND_SIGNED },
d580 3
a582 3
/* The unsigned imm5 field in a format 2 insn.  */
#define I5U	(I5 + 1)
  { 5, 0, NULL, NULL, 0 },
d584 3
a586 3
/* The imm16 field in a format 6 insn.  */
#define I16	(I5U + 1)
  { 16, 16, NULL, NULL, V850_OPERAND_SIGNED },
d588 3
a590 3
/* The signed disp7 field in a format 4 insn.  */
#define D7	(I16 + 1)
  { 7, 0, NULL, NULL, 0},
d592 3
a594 3
/* The disp16 field in a format 6 insn.  */
#define D16_15	(D7 + 1)
  { 15, 17, insert_d16_15, extract_d16_15, V850_OPERAND_SIGNED },
d596 7
a602 3
/* The 3 bit immediate field in format 8 insn.  */
#define B3	(D16_15 + 1)
  { 3, 11, NULL, NULL, 0 },
d604 3
a606 3
/* The 4 bit condition code in a setf instruction */
#define CCCC	(B3 + 1)
  { 4, 0, NULL, NULL, V850_OPERAND_CC },
d608 3
a610 3
/* The unsigned DISP8 field in a format 4 insn.  */
#define D8_7	(CCCC + 1)
  { 7, 0, insert_d8_7, extract_d8_7, 0 },
d612 3
a614 3
/* The unsigned DISP8 field in a format 4 insn.  */
#define D8_6	(D8_7 + 1)
  { 6, 1, insert_d8_6, extract_d8_6, 0 },
d617 46
a662 2
#define SR1	(D8_6 + 1)
  { 5, 0, NULL, NULL, V850_OPERAND_SRG },
d664 27
a690 3
/* EP Register.  */
#define EP	(SR1 + 1)
  { 0, 0, NULL, NULL, V850_OPERAND_EP },
d692 3
a694 3
/* The imm16 field (unsigned) in a format 6 insn.  */
#define I16U	(EP + 1)
  { 16, 16, NULL, NULL, 0},
d696 2
a697 3
/* The R2 field as a system register.  */
#define SR2	(I16U + 1)
  { 5, 11, NULL, NULL, V850_OPERAND_SRG },
d699 2
a700 3
/* The disp16 field in a format 8 insn.  */
#define D16	(SR2 + 1)
  { 16, 16, NULL, NULL, V850_OPERAND_SIGNED },
d702 3
a704 3
/* The DISP9 field in a format 3 insn, relaxable.  */
#define D9_RELAX	(D16 + 1)
  { 9, 0, insert_d9, extract_d9, V850_OPERAND_RELAX | V850_OPERAND_SIGNED | V850_OPERAND_DISP },
d706 11
a716 5
/* The DISP22 field in a format 4 insn, relaxable.
   This _must_ follow D9_RELAX; the assembler assumes that the longer
   version immediately follows the shorter version for relaxing.  */
#define D22	(D9_RELAX + 1)
  { 22, 0, insert_d22, extract_d22, V850_OPERAND_SIGNED | V850_OPERAND_DISP },
d718 3
a720 7
/* The signed disp4 field in a format 4 insn.  */
#define D4	(D22 + 1)
  { 4, 0, NULL, NULL, 0},

/* The unsigned disp5 field in a format 4 insn.  */
#define D5_4	(D4 + 1)
  { 4, 0, insert_d5_4, extract_d5_4, 0 },
d722 3
a724 3
/* The disp16 field in an format 7 unsigned byte load insn.  */
#define D16_16	(D5_4 + 1)
  { -1, 0xfffe0020, insert_d16_16, extract_d16_16, 0 },
d726 3
a728 3
/* Third register in conditional moves.  */
#define R3	(D16_16 + 1)
  { 5, 27, NULL, NULL, V850_OPERAND_REG },
d730 3
a732 3
/* Condition code in conditional moves.  */
#define MOVCC	(R3 + 1)
  { 4, 17, NULL, NULL, V850_OPERAND_CC },
d735 2
a736 2
#define I9	(MOVCC + 1)
  { 9, 0, insert_i9, extract_i9, V850_OPERAND_SIGNED },
d740 1
a740 1
  { 9, 0, insert_u9, extract_u9, 0 },
d742 7
a748 3
/* A list of registers in a prepare/dispose instruction.  */
#define LIST12	(U9 + 1)
  { -1, 0xffe00001, NULL, NULL, V850E_PUSH_POP },
d750 3
a752 3
/* The IMM6 field in a call instruction.  */
#define I6	(LIST12 + 1)
  { 6, 0, NULL, NULL, 0 },
d755 43
a797 2
#define IMM16	(I6 + 1)
  { 16, 16, NULL, NULL, V850_OPERAND_SIGNED | V850E_IMMEDIATE16 },
d800 2
a801 2
#define IMM32	(IMM16 + 1)
  { 0, 0, NULL, NULL, V850E_IMMEDIATE32 },
d803 2
a804 7
/* The imm5 field in a push/pop instruction.  */
#define IMM5	(IMM32 + 1)
  { 5, 1, NULL, NULL, 0 },

/* Reg2 in dispose instruction.  */
#define R2DISPOSE	(IMM5 + 1)
  { 5, 16, NULL, NULL, V850_OPERAND_REG | V850_NOT_R0 },
d806 2
a807 3
/* Stack pointer in prepare instruction.  */
#define SP	(R2DISPOSE + 1)
  { 2, 19, insert_spe, extract_spe, V850_OPERAND_REG },
a808 12
/* The IMM5 field in a divide N step instruction.  */
#define I5DIV	(SP + 1)
  { 9, 0, insert_i5div, extract_i5div, V850_OPERAND_SIGNED },

  /* The list of registers in a PUSHMH/POPMH instruction.  */
#define LIST18_H (I5DIV + 1)
  { -1, 0xfff8000f, NULL, NULL, V850E_PUSH_POP },

  /* The list of registers in a PUSHML/POPML instruction.  */
#define LIST18_L (LIST18_H + 1)
  /* The setting of the 4th bit is a flag to disassmble() in v850-dis.c.  */
  { -1, 0xfff8001f, NULL, NULL, V850E_PUSH_POP },
d827 2
d863 1
a863 77
{ "breakpoint",	0xffff,			0xffff,		      	{UNUSED},   		0, PROCESSOR_ALL },
{ "dbtrap",	one (0xf840),		one (0xffff),		{UNUSED},   		0, PROCESSOR_V850E1 },

{ "jmp",	one (0x0060),		one (0xffe0),	      	{R1}, 			1, PROCESSOR_ALL },

/* Load/store instructions.  */
{ "sld.bu",     one (0x0060),		one (0x07f0),         	{D4,   EP,   R2_NOTR0},	1, PROCESSOR_V850E1 },
{ "sld.bu",     one (0x0060),		one (0x07f0),         	{D4,   EP,   R2_NOTR0},	1, PROCESSOR_V850E },

{ "sld.hu",     one (0x0070),		one (0x07f0),         	{D5_4, EP,   R2_NOTR0},	1, PROCESSOR_V850E1 },
{ "sld.hu",     one (0x0070),		one (0x07f0),         	{D5_4, EP,   R2_NOTR0},	1, PROCESSOR_V850E },

{ "sld.b",	one (0x0300),		one (0x0780),	      	{D7,   EP,   R2},	1, PROCESSOR_V850E1 },
{ "sld.b",	one (0x0300),		one (0x0780),	      	{D7,   EP,   R2},	1, PROCESSOR_V850E },
{ "sld.b",	one (0x0300),		one (0x0780),	      	{D7,   EP,   R2},	1, PROCESSOR_V850 },

{ "sld.h",	one (0x0400),		one (0x0780),	      	{D8_7, EP,   R2}, 	1, PROCESSOR_V850E1 },
{ "sld.h",	one (0x0400),		one (0x0780),	      	{D8_7, EP,   R2}, 	1, PROCESSOR_V850E },
{ "sld.h",	one (0x0400),		one (0x0780),	      	{D8_7, EP,   R2}, 	1, PROCESSOR_V850 },
{ "sld.w",	one (0x0500),		one (0x0781),	      	{D8_6, EP,   R2}, 	1, PROCESSOR_ALL },
{ "sst.b",	one (0x0380),		one (0x0780),	      	{R2,   D7,   EP}, 	2, PROCESSOR_ALL },
{ "sst.h",	one (0x0480),		one (0x0780),	      	{R2,   D8_7, EP}, 	2, PROCESSOR_ALL },
{ "sst.w",	one (0x0501),		one (0x0781),	      	{R2,   D8_6, EP}, 	2, PROCESSOR_ALL },

{ "prepare",    two (0x0780, 0x0003),	two (0xffc0, 0x001f), 	{LIST12, IMM5, SP}, 	0, PROCESSOR_NOT_V850 },
{ "prepare",    two (0x0780, 0x000b),	two (0xffc0, 0x001f), 	{LIST12, IMM5, IMM16}, 	0, PROCESSOR_NOT_V850 },
{ "prepare",    two (0x0780, 0x0013),	two (0xffc0, 0x001f), 	{LIST12, IMM5, IMM16}, 	0, PROCESSOR_NOT_V850 },
{ "prepare",    two (0x0780, 0x001b),	two (0xffc0, 0x001f), 	{LIST12, IMM5, IMM32}, 	0, PROCESSOR_NOT_V850 },
{ "prepare",    two (0x0780, 0x0001),	two (0xffc0, 0x001f), 	{LIST12, IMM5}, 	0, PROCESSOR_NOT_V850 },
{ "dispose",	one (0x0640),           one (0xffc0),         	{IMM5, LIST12, R2DISPOSE},0, PROCESSOR_NOT_V850 },
{ "dispose",	two (0x0640, 0x0000),   two (0xffc0, 0x001f), 	{IMM5, LIST12}, 	0, PROCESSOR_NOT_V850 },

{ "ld.b",	two (0x0700, 0x0000),	two (0x07e0, 0x0000), 	{D16, R1, R2}, 		1, PROCESSOR_ALL },
{ "ld.h",	two (0x0720, 0x0000),	two (0x07e0, 0x0001), 	{D16_15, R1, R2}, 	1, PROCESSOR_ALL },
{ "ld.w",	two (0x0720, 0x0001),	two (0x07e0, 0x0001), 	{D16_15, R1, R2}, 	1, PROCESSOR_ALL },
{ "ld.bu",	two (0x0780, 0x0001),   two (0x07c0, 0x0001), 	{D16_16, R1, R2_NOTR0},	1, PROCESSOR_NOT_V850 },
{ "ld.hu",	two (0x07e0, 0x0001),   two (0x07e0, 0x0001), 	{D16_15, R1, R2_NOTR0},	1, PROCESSOR_NOT_V850 },
{ "st.b",	two (0x0740, 0x0000),	two (0x07e0, 0x0000), 	{R2, D16, R1}, 		2, PROCESSOR_ALL },
{ "st.h",	two (0x0760, 0x0000),	two (0x07e0, 0x0001), 	{R2, D16_15, R1}, 	2, PROCESSOR_ALL },
{ "st.w",	two (0x0760, 0x0001),	two (0x07e0, 0x0001), 	{R2, D16_15, R1}, 	2, PROCESSOR_ALL },

/* Byte swap/extend instructions.  */
{ "zxb",	one (0x0080),		one (0xffe0), 	      	{R1_NOTR0},		0, PROCESSOR_NOT_V850 },
{ "zxh",	one (0x00c0),		one (0xffe0), 	      	{R1_NOTR0}, 		0, PROCESSOR_NOT_V850 },
{ "sxb",	one (0x00a0),		one (0xffe0), 	      	{R1_NOTR0},		0, PROCESSOR_NOT_V850 },
{ "sxh",	one (0x00e0),		one (0xffe0),	      	{R1_NOTR0},		0, PROCESSOR_NOT_V850 },
{ "bsh",	two (0x07e0, 0x0342),	two (0x07ff, 0x07ff), 	{R2, R3}, 		0, PROCESSOR_NOT_V850 },
{ "bsw",	two (0x07e0, 0x0340),	two (0x07ff, 0x07ff), 	{R2, R3}, 		0, PROCESSOR_NOT_V850 },
{ "hsw",	two (0x07e0, 0x0344),	two (0x07ff, 0x07ff), 	{R2, R3}, 		0, PROCESSOR_NOT_V850 },

/* Jump table instructions.  */
{ "switch",	one (0x0040),		one (0xffe0), 	      	{R1}, 			1, PROCESSOR_NOT_V850 },
{ "callt",	one (0x0200),		one (0xffc0), 	      	{I6}, 			0, PROCESSOR_NOT_V850 },
{ "ctret", 	two (0x07e0, 0x0144),	two (0xffff, 0xffff), 	{0}, 			0, PROCESSOR_NOT_V850 },

/* Arithmetic operation instructions.  */
{ "setf",	two (0x07e0, 0x0000),	two (0x07f0, 0xffff), 	{CCCC, R2}, 		0, PROCESSOR_ALL },
{ "cmov",	two (0x07e0, 0x0320),	two (0x07e0, 0x07e1), 	{MOVCC, R1, R2, R3}, 	0, PROCESSOR_NOT_V850 },
{ "cmov",	two (0x07e0, 0x0300),	two (0x07e0, 0x07e1), 	{MOVCC, I5, R2, R3}, 	0, PROCESSOR_NOT_V850 },

{ "mul",	two (0x07e0, 0x0220),	two (0x07e0, 0x07ff), 	{R1, R2, R3}, 		0, PROCESSOR_NOT_V850 },
{ "mul",	two (0x07e0, 0x0240),	two (0x07e0, 0x07c3), 	{I9, R2, R3}, 		0, PROCESSOR_NOT_V850 },
{ "mulu",	two (0x07e0, 0x0222),	two (0x07e0, 0x07ff), 	{R1, R2, R3}, 		0, PROCESSOR_NOT_V850 },
{ "mulu",	two (0x07e0, 0x0242),	two (0x07e0, 0x07c3), 	{U9, R2, R3}, 		0, PROCESSOR_NOT_V850 },

{ "div",	two (0x07e0, 0x02c0),	two (0x07e0, 0x07ff), 	{R1, R2, R3}, 		0, PROCESSOR_NOT_V850 },
{ "divu",	two (0x07e0, 0x02c2),	two (0x07e0, 0x07ff), 	{R1, R2, R3}, 		0, PROCESSOR_NOT_V850 },
{ "divhu",	two (0x07e0, 0x0282),   two (0x07e0, 0x07ff), 	{R1, R2, R3}, 		0, PROCESSOR_NOT_V850 },
{ "divh",	two (0x07e0, 0x0280),   two (0x07e0, 0x07ff), 	{R1, R2, R3}, 		0, PROCESSOR_NOT_V850 },
{ "divh",	OP  (0x02),		OP_MASK,		{R1, R2_NOTR0},		0, PROCESSOR_ALL },

{ "nop",	one (0x00),		one (0xffff),		{0}, 			0, PROCESSOR_ALL },
{ "mov",	OP  (0x10),		OP_MASK,		{I5, R2_NOTR0},		0, PROCESSOR_ALL },
{ "mov",	one (0x0620),		one (0xffe0),		{IMM32, R1_NOTR0},	0, PROCESSOR_NOT_V850 },
{ "mov",        OP  (0x00),		OP_MASK,		{R1, R2_NOTR0},		0, PROCESSOR_ALL },
{ "movea",	OP  (0x31),		OP_MASK,		{I16, R1, R2_NOTR0},	0, PROCESSOR_ALL },
{ "movhi",	OP  (0x32),		OP_MASK,		{I16U, R1, R2_NOTR0},	0, PROCESSOR_ALL },
d866 1
a867 7
{ "sub",	OP  (0x0d),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },
{ "subr", 	OP  (0x0c),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },
{ "mulh",	OP  (0x17),		OP_MASK,		{I5, R2_NOTR0},		0, PROCESSOR_ALL },
{ "mulh",	OP  (0x07),		OP_MASK,		{R1, R2_NOTR0},		0, PROCESSOR_ALL },
{ "mulhi",	OP  (0x37),		OP_MASK,		{I16, R1, R2_NOTR0},	0, PROCESSOR_ALL },
{ "cmp",	OP  (0x0f),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },
{ "cmp",	OP  (0x13),		OP_MASK,		IF2, 			0, PROCESSOR_ALL },
d869 1
a869 6
/* Saturated operation instructions.  */
{ "satadd",	OP (0x11),		OP_MASK,		{I5, R2_NOTR0},		0, PROCESSOR_ALL },
{ "satadd",	OP (0x06),		OP_MASK,		{R1, R2_NOTR0},		0, PROCESSOR_ALL },
{ "satsub",	OP (0x05),		OP_MASK,		{R1, R2_NOTR0},		0, PROCESSOR_ALL },
{ "satsubi",	OP (0x33),		OP_MASK,		{I16, R1, R2_NOTR0},	0, PROCESSOR_ALL },
{ "satsubr",	OP (0x04),		OP_MASK,		{R1, R2_NOTR0},		0, PROCESSOR_ALL },
a870 4
/* Logical operation instructions.  */
{ "tst",	OP (0x0b),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },
{ "or",		OP (0x08),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },
{ "ori",	OP (0x34),		OP_MASK,		IF6U, 			0, PROCESSOR_ALL },
d872 1
a873 10
{ "xor",	OP (0x09),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },
{ "xori",	OP (0x35),		OP_MASK,		IF6U, 			0, PROCESSOR_ALL },
{ "not",	OP (0x01),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },
{ "sar",	OP (0x15),		OP_MASK,		{I5U, R2}, 		0, PROCESSOR_ALL },
{ "sar",	two (0x07e0, 0x00a0),	two (0x07e0, 0xffff), 	{R1,  R2}, 		0, PROCESSOR_ALL },
{ "shl",	OP  (0x16),		OP_MASK,	      	{I5U, R2}, 		0, PROCESSOR_ALL },
{ "shl",	two (0x07e0, 0x00c0),	two (0x07e0, 0xffff), 	{R1,  R2}, 		0, PROCESSOR_ALL },
{ "shr",	OP  (0x14),		OP_MASK,	      	{I5U, R2}, 		0, PROCESSOR_ALL },
{ "shr",	two (0x07e0, 0x0080),	two (0x07e0, 0xffff), 	{R1,  R2}, 		0, PROCESSOR_ALL },
{ "sasf",       two (0x07e0, 0x0200),	two (0x07f0, 0xffff), 	{CCCC, R2}, 		0, PROCESSOR_NOT_V850 },
a874 1
/* Branch instructions.  */
d876 1
d878 1
a878 1
{ "bge",	BOP (0xe),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
a879 1
{ "ble",	BOP (0x7),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
d882 1
a883 1
{ "bl",		BOP (0x1),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
d889 2
a890 2
{ "bv",		BOP (0x0),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "bnv",	BOP (0x8),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
a891 2
{ "bp",		BOP (0xc),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
{ "bc",		BOP (0x1),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
d893 1
a893 1
{ "bz",		BOP (0x2),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
d895 1
d898 3
d902 1
a902 1
/* Branch macros.
d904 1
a904 2
   We use the short form in the opcode/mask fields.  The assembler
   will twiddle bits as necessary if the long form is needed.  */
d906 82
a987 1
	/* Signed integer.  */
a1008 1
{ "jsa",	BOP (0xd),		BOP_MASK,		IF3, 			0, PROCESSOR_ALL },
a1010 2
{ "jr",		one (0x0780),		two (0xffc0, 0x0001),	{D22}, 			0, PROCESSOR_ALL },
{ "jarl",	one (0x0780),		two (0x07c0, 0x0001),	{D22, R2}, 		0, PROCESSOR_ALL },
d1012 70
a1081 9
/* Bit manipulation instructions.  */
{ "set1",	two (0x07c0, 0x0000),	two (0xc7e0, 0x0000),	{B3, D16, R1}, 		2, PROCESSOR_ALL },
{ "set1",	two (0x07e0, 0x00e0),	two (0x07e0, 0xffff),	{R2, R1},    		2, PROCESSOR_NOT_V850 },
{ "not1",	two (0x47c0, 0x0000),	two (0xc7e0, 0x0000),	{B3, D16, R1}, 		2, PROCESSOR_ALL },
{ "not1",	two (0x07e0, 0x00e2),	two (0x07e0, 0xffff),	{R2, R1},    		2, PROCESSOR_NOT_V850 },
{ "clr1",	two (0x87c0, 0x0000),	two (0xc7e0, 0x0000),	{B3, D16, R1}, 		2, PROCESSOR_ALL },
{ "clr1",	two (0x07e0, 0x00e4),	two (0x07e0, 0xffff),   {R2, R1},    		2, PROCESSOR_NOT_V850 },
{ "tst1",	two (0xc7c0, 0x0000),	two (0xc7e0, 0x0000),	{B3, D16, R1}, 		2, PROCESSOR_ALL },
{ "tst1",	two (0x07e0, 0x00e6),	two (0x07e0, 0xffff),	{R2, R1},    		2, PROCESSOR_NOT_V850 },
a1082 4
/* Special instructions.  */
{ "di",		two (0x07e0, 0x0160),	two (0xffff, 0xffff),	{0}, 			0, PROCESSOR_ALL },
{ "ei",		two (0x87e0, 0x0160),	two (0xffff, 0xffff),	{0}, 			0, PROCESSOR_ALL },
{ "halt",	two (0x07e0, 0x0120),	two (0xffff, 0xffff),	{0}, 			0, PROCESSOR_ALL },
d1084 89
d1174 123
a1296 3
{ "ldsr",	two (0x07e0, 0x0020),	two (0x07e0, 0xffff),	{R1, SR2}, 		0, PROCESSOR_ALL },
{ "stsr",	two (0x07e0, 0x0040),	two (0x07e0, 0xffff),	{SR1, R2}, 		0, PROCESSOR_ALL },
{ "dbret",	two (0x07e0, 0x0146),	two (0xffff, 0xffff),	{UNUSED},   		0, PROCESSOR_V850E1 },
a1297 1

@


1.10
log
@Update function declarations to ISO C90 formatting
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2005
d5 3
a7 1
   This program is free software; you can redistribute it and/or modify
d9 2
a10 2
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d12 4
a15 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
@


1.9
log
@Update the address and phone number of the FSF
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003
d17 2
a18 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
a37 24

static long unsigned insert_d9      PARAMS ((long unsigned, long, const char **));
static long unsigned extract_d9     PARAMS ((long unsigned, int *));
static long unsigned insert_d22     PARAMS ((long unsigned, long, const char **));
static long unsigned extract_d22    PARAMS ((long unsigned, int *));
static long unsigned insert_d16_15  PARAMS ((long unsigned, long, const char **));
static long unsigned extract_d16_15 PARAMS ((long unsigned, int *));
static long unsigned insert_d8_7    PARAMS ((long unsigned, long, const char **));
static long unsigned extract_d8_7   PARAMS ((long unsigned, int *));
static long unsigned insert_d8_6    PARAMS ((long unsigned, long, const char **));
static long unsigned extract_d8_6   PARAMS ((long unsigned, int *));
static long unsigned insert_d5_4    PARAMS ((long unsigned, long, const char **));
static long unsigned extract_d5_4   PARAMS ((long unsigned, int *));
static long unsigned insert_d16_16  PARAMS ((long unsigned, long, const char **));
static long unsigned extract_d16_16 PARAMS ((long unsigned, int *));
static long unsigned insert_i9      PARAMS ((long unsigned, long, const char **));
static long unsigned extract_i9     PARAMS ((long unsigned, int *));
static long unsigned insert_u9      PARAMS ((long unsigned, long, const char **));
static long unsigned extract_u9     PARAMS ((long unsigned, int *));
static long unsigned insert_spe     PARAMS ((long unsigned, long, const char **));
static long unsigned extract_spe    PARAMS ((long unsigned, int *));
static long unsigned insert_i5div   PARAMS ((long unsigned, long, const char **));
static long unsigned extract_i5div  PARAMS ((long unsigned, int *));

d53 1
a53 4
insert_d9 (insn, value, errmsg)
     unsigned long insn;
     long          value;
     const char ** errmsg;
d65 1
a65 1
  return (insn | ((value & 0x1f0) << 7) | ((value & 0x0e) << 3));
d69 1
a69 3
extract_d9 (insn, invalid)
     unsigned long insn;
     int *         invalid ATTRIBUTE_UNUSED;
d80 1
a80 4
insert_d22 (insn, value, errmsg)
     unsigned long insn;
     long          value;
     const char ** errmsg;
d92 1
a92 1
  return (insn | ((value & 0xfffe) << 16) | ((value & 0x3f0000) >> 16));
d96 1
a96 3
extract_d22 (insn, invalid)
     unsigned long insn;
     int *         invalid ATTRIBUTE_UNUSED;
d104 1
a104 4
insert_d16_15 (insn, value, errmsg)
     unsigned long insn;
     long          value;
     const char ** errmsg;
d120 1
a120 3
extract_d16_15 (insn, invalid)
     unsigned long insn;
     int *         invalid ATTRIBUTE_UNUSED;
d128 1
a128 4
insert_d8_7 (insn, value, errmsg)
     unsigned long insn;
     long          value;
     const char ** errmsg;
d142 1
a142 1
  return (insn | (value & 0x7f));
d146 1
a146 3
extract_d8_7 (insn, invalid)
     unsigned long insn;
     int *         invalid ATTRIBUTE_UNUSED;
d154 1
a154 4
insert_d8_6 (insn, value, errmsg)
     unsigned long insn;
     long          value;
     const char ** errmsg;
d168 1
a168 1
  return (insn | (value & 0x7e));
d172 1
a172 3
extract_d8_6 (insn, invalid)
     unsigned long insn;
     int *         invalid ATTRIBUTE_UNUSED;
d180 1
a180 4
insert_d5_4 (insn, value, errmsg)
     unsigned long insn;
     long          value;
     const char ** errmsg;
d194 1
a194 1
  return (insn | (value & 0x0f));
d198 1
a198 3
extract_d5_4 (insn, invalid)
     unsigned long insn;
     int *         invalid ATTRIBUTE_UNUSED;
d206 1
a206 4
insert_d16_16 (insn, value, errmsg)
     unsigned long insn;
     signed long   value;
     const char ** errmsg;
d211 1
a211 1
  return (insn | ((value & 0xfffe) << 16) | ((value & 1) << 5));
d215 1
a215 3
extract_d16_16 (insn, invalid)
     unsigned long insn;
     int *         invalid ATTRIBUTE_UNUSED;
d222 1
a222 1
  
d227 1
a227 4
insert_i9 (insn, value, errmsg)
     unsigned long insn;
     signed long   value;
     const char ** errmsg;
d236 1
a236 3
extract_i9 (insn, invalid)
     unsigned long insn;
     int *         invalid ATTRIBUTE_UNUSED;
d244 1
a244 1
  
d249 1
a249 4
insert_u9 (insn, v, errmsg)
     unsigned long insn;
     long v;
     const char ** errmsg;
d252 1
d260 1
a260 3
extract_u9 (insn, invalid)
     unsigned long insn;
     int *         invalid ATTRIBUTE_UNUSED;
d267 1
a267 1
  
d272 1
a272 4
insert_spe (insn, v, errmsg)
     unsigned long insn;
     long v;
     const char ** errmsg;
d283 2
a284 3
extract_spe (insn, invalid)
     unsigned long insn ATTRIBUTE_UNUSED;
     int *         invalid ATTRIBUTE_UNUSED;
d290 1
a290 4
insert_i5div (insn, v, errmsg)
     unsigned long insn;
     long v;
     const char ** errmsg;
d305 1
a305 1
  
d310 1
a310 3
extract_i5div (insn, invalid)
     unsigned long insn;
     int *         invalid ATTRIBUTE_UNUSED;
d317 1
a317 1
  
d328 1
a328 1
  { 0, 0, NULL, NULL, 0 }, 
d332 1
a332 1
  { 5, 0, NULL, NULL, V850_OPERAND_REG }, 
d348 1
a348 1
  { 5, 0, NULL, NULL, V850_OPERAND_SIGNED }, 
d356 1
a356 1
  { 16, 16, NULL, NULL, V850_OPERAND_SIGNED }, 
d364 1
a364 1
  { 15, 17, insert_d16_15, extract_d16_15, V850_OPERAND_SIGNED }, 
d392 1
a392 1
  { 16, 16, NULL, NULL, 0}, 
d400 1
a400 1
  { 16, 16, NULL, NULL, V850_OPERAND_SIGNED }, 
d422 1
a422 1
  { -1, 0xfffe0020, insert_d16_16, extract_d16_16, 0 }, 
d434 1
a434 1
  { 9, 0, insert_i9, extract_i9, V850_OPERAND_SIGNED }, 
d438 1
a438 1
  { 9, 0, insert_u9, extract_u9, 0 }, 
d442 1
a442 1
  { -1, 0xffe00001, NULL, NULL, V850E_PUSH_POP }, 
d446 1
a446 1
  { 6, 0, NULL, NULL, 0 }, 
d450 1
a450 1
  { 16, 16, NULL, NULL, V850_OPERAND_SIGNED | V850E_IMMEDIATE16 }, 
d454 1
a454 1
  { 0, 0, NULL, NULL, V850E_IMMEDIATE32 }, 
d458 1
a458 1
  { 5, 1, NULL, NULL, 0 }, 
d470 1
a470 1
  { 9, 0, insert_i5div, extract_i5div, V850_OPERAND_SIGNED }, 
d474 1
a474 1
  { -1, 0xfff8000f, NULL, NULL, V850E_PUSH_POP }, 
d480 1
a480 1
} ; 
d513 1
a513 1
   
d536 1
a536 1
  
d568 1
a568 1
{ "ld.hu",	two (0x07e0, 0x0001),   two (0x07e0, 0x0001), 	{D16_15, R1, R2_NOTR0},	1, PROCESSOR_NOT_V850 },  
d602 1
a602 1
  
d619 1
a619 1
  
d699 1
a699 1
  
d701 1
a701 1
{ "jarl",	one (0x0780),		two (0x07c0, 0x0001),	{D22, R2}, 		0, PROCESSOR_ALL}, 
@


1.8
log
@update copyright dates
@
text
@d17 1
a17 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.7
log
@Add binutils support for v850e1 processor
@
text
@d2 2
a3 1
   Copyright 1996, 1997, 1998, 2000, 2001, 2003 Free Software Foundation, Inc.
@


1.6
log
@Remove redundant references to V850EA architecture.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 2000, 2001 Free Software Foundation, Inc.
d4 13
a16 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d23 1
a23 1
/* regular opcode */
d27 1
a27 1
/* conditional branch opcode */
d31 1
a31 1
/* one-word opcodes */
d34 1
a34 1
/* two-word opcodes */
d405 1
a405 1
/* The R1 field in a format 1, 6, 7, or 9 insn. */
d411 1
a411 1
  { 5, 0, NULL, NULL, V850_OPERAND_REG | V850_NOT_R0 }, 
d413 1
a413 1
/* The R2 field in a format 1, 2, 4, 5, 6, 7, 9 insn. */
d421 1
a421 1
/* The imm5 field in a format 2 insn. */
d425 1
a425 1
/* The unsigned imm5 field in a format 2 insn. */
d429 1
a429 1
/* The imm16 field in a format 6 insn. */
d433 1
a433 1
/* The signed disp7 field in a format 4 insn. */
d437 1
a437 1
/* The disp16 field in a format 6 insn. */
d449 1
a449 1
/* The unsigned DISP8 field in a format 4 insn. */
d453 1
a453 1
/* The unsigned DISP8 field in a format 4 insn. */
d465 1
a465 1
/* The imm16 field (unsigned) in a format 6 insn. */
d473 1
a473 1
/* The disp16 field in a format 8 insn. */
d477 1
a477 1
/* The DISP9 field in a format 3 insn, relaxable. */
d487 1
a487 1
/* The signed disp4 field in a format 4 insn. */
d491 1
a491 1
/* The unsigned disp5 field in a format 4 insn. */
d495 1
a495 1
/* The disp16 field in an format 7 unsigned byte load insn. */
d499 1
a499 1
/* Third register in conditional moves. */
d507 1
a507 1
/* The imm9 field in a multiply word. */
d511 1
a511 1
/* The unsigned imm9 field in a multiply word. */
d519 1
a519 1
/* The IMM6 field in a call instruction. */
d531 1
a531 1
/* The imm5 field in a push/pop instruction. */
d535 1
a535 1
/* Reg2 in dispose instruction. */
d539 1
a539 1
/* Stack pointer in prepare instruction. */
d543 1
a543 1
/* The IMM5 field in a divide N step instruction. */
d553 2
a554 1
  { -1, 0xfff8001f, NULL, NULL, V850E_PUSH_POP }, /* The setting of the 4th bit is a flag to disassmble() in v850-dis.c */
d558 1
a558 1
/* reg-reg instruction format (Format I) */
d561 1
a561 1
/* imm-reg instruction format (Format II) */
d564 1
a564 1
/* conditional branch instruction format (Format III) */
d567 1
a567 1
/* 3 operand instruction (Format VI) */
d570 1
a570 1
/* 3 operand instruction (Format VI) */
d608 1
d612 2
a613 1
/* load/store instructions */
d616 1
d619 1
d623 1
d648 1
a648 1
/* byte swap/extend instructions */
d657 1
a657 1
/* jump table instructions */
d662 1
a662 1
/* arithmetic operation instructions */
d695 1
a695 1
/* saturated operation instructions */
d702 1
a702 1
/* logical operation instructions */
d719 2
a720 2
/* branch instructions */
	/* signed integer */
d725 1
a725 1
	/* unsigned integer */
d730 1
a730 1
	/* common */
d733 1
a733 1
	/* others */
d750 1
a750 1
	/* signed integer */
d755 1
a755 1
	/* unsigned integer */
d760 1
a760 1
	/* common */
d763 1
a763 1
	/* others */
d778 1
a778 1
/* bit manipulation instructions */
d788 1
a788 1
/* special instructions */
d796 1
a802 1

@


1.6.8.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 2000, 2001, 2003 Free Software Foundation, Inc.
d4 13
a16 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d23 1
a23 1
/* Regular opcodes.  */
d27 1
a27 1
/* Conditional branch opcodes.  */
d31 1
a31 1
/* One-word opcodes.  */
d34 1
a34 1
/* Two-word opcodes.  */
d405 1
a405 1
/* The R1 field in a format 1, 6, 7, or 9 insn.  */
d411 1
a411 1
  { 5, 0, NULL, NULL, V850_OPERAND_REG | V850_NOT_R0 },
d413 1
a413 1
/* The R2 field in a format 1, 2, 4, 5, 6, 7, 9 insn.  */
d421 1
a421 1
/* The imm5 field in a format 2 insn.  */
d425 1
a425 1
/* The unsigned imm5 field in a format 2 insn.  */
d429 1
a429 1
/* The imm16 field in a format 6 insn.  */
d433 1
a433 1
/* The signed disp7 field in a format 4 insn.  */
d437 1
a437 1
/* The disp16 field in a format 6 insn.  */
d449 1
a449 1
/* The unsigned DISP8 field in a format 4 insn.  */
d453 1
a453 1
/* The unsigned DISP8 field in a format 4 insn.  */
d465 1
a465 1
/* The imm16 field (unsigned) in a format 6 insn.  */
d473 1
a473 1
/* The disp16 field in a format 8 insn.  */
d477 1
a477 1
/* The DISP9 field in a format 3 insn, relaxable.  */
d487 1
a487 1
/* The signed disp4 field in a format 4 insn.  */
d491 1
a491 1
/* The unsigned disp5 field in a format 4 insn.  */
d495 1
a495 1
/* The disp16 field in an format 7 unsigned byte load insn.  */
d499 1
a499 1
/* Third register in conditional moves.  */
d507 1
a507 1
/* The imm9 field in a multiply word.  */
d511 1
a511 1
/* The unsigned imm9 field in a multiply word.  */
d519 1
a519 1
/* The IMM6 field in a call instruction.  */
d531 1
a531 1
/* The imm5 field in a push/pop instruction.  */
d535 1
a535 1
/* Reg2 in dispose instruction.  */
d539 1
a539 1
/* Stack pointer in prepare instruction.  */
d543 1
a543 1
/* The IMM5 field in a divide N step instruction.  */
d553 1
a553 2
  /* The setting of the 4th bit is a flag to disassmble() in v850-dis.c.  */
  { -1, 0xfff8001f, NULL, NULL, V850E_PUSH_POP },
d557 1
a557 1
/* Reg - Reg instruction format (Format I).  */
d560 1
a560 1
/* Imm - Reg instruction format (Format II).  */
d563 1
a563 1
/* Conditional branch instruction format (Format III).  */
d566 1
a566 1
/* 3 operand instruction (Format VI).  */
d569 1
a569 1
/* 3 operand instruction (Format VI).  */
a606 1
{ "dbtrap",	one (0xf840),		one (0xffff),		{UNUSED},   		0, PROCESSOR_V850E1 },
d610 1
a610 2
/* Load/store instructions.  */
{ "sld.bu",     one (0x0060),		one (0x07f0),         	{D4,   EP,   R2_NOTR0},	1, PROCESSOR_V850E1 },
a612 1
{ "sld.hu",     one (0x0070),		one (0x07f0),         	{D5_4, EP,   R2_NOTR0},	1, PROCESSOR_V850E1 },
a614 1
{ "sld.b",	one (0x0300),		one (0x0780),	      	{D7,   EP,   R2},	1, PROCESSOR_V850E1 },
a617 1
{ "sld.h",	one (0x0400),		one (0x0780),	      	{D8_7, EP,   R2}, 	1, PROCESSOR_V850E1 },
d642 1
a642 1
/* Byte swap/extend instructions.  */
d651 1
a651 1
/* Jump table instructions.  */
d656 1
a656 1
/* Arithmetic operation instructions.  */
d689 1
a689 1
/* Saturated operation instructions.  */
d696 1
a696 1
/* Logical operation instructions.  */
d713 2
a714 2
/* Branch instructions.  */
	/* Signed integer.  */
d719 1
a719 1
	/* Unsigned integer.  */
d724 1
a724 1
	/* Common.  */
d727 1
a727 1
	/* Others.  */
d744 1
a744 1
	/* Signed integer.  */
d749 1
a749 1
	/* Unsigned integer.  */
d754 1
a754 1
	/* Common.  */
d757 1
a757 1
	/* Others.  */
d772 1
a772 1
/* Bit manipulation instructions.  */
d782 1
a782 1
/* Special instructions.  */
a789 1
{ "dbret",	two (0x07e0, 0x0146),	two (0xffff, 0xffff),	{UNUSED},   		0, PROCESSOR_V850E1 },
d796 1
@


1.6.6.1
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 2000, 2001, 2003 Free Software Foundation, Inc.
d4 13
a16 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d23 1
a23 1
/* Regular opcodes.  */
d27 1
a27 1
/* Conditional branch opcodes.  */
d31 1
a31 1
/* One-word opcodes.  */
d34 1
a34 1
/* Two-word opcodes.  */
d405 1
a405 1
/* The R1 field in a format 1, 6, 7, or 9 insn.  */
d411 1
a411 1
  { 5, 0, NULL, NULL, V850_OPERAND_REG | V850_NOT_R0 },
d413 1
a413 1
/* The R2 field in a format 1, 2, 4, 5, 6, 7, 9 insn.  */
d421 1
a421 1
/* The imm5 field in a format 2 insn.  */
d425 1
a425 1
/* The unsigned imm5 field in a format 2 insn.  */
d429 1
a429 1
/* The imm16 field in a format 6 insn.  */
d433 1
a433 1
/* The signed disp7 field in a format 4 insn.  */
d437 1
a437 1
/* The disp16 field in a format 6 insn.  */
d449 1
a449 1
/* The unsigned DISP8 field in a format 4 insn.  */
d453 1
a453 1
/* The unsigned DISP8 field in a format 4 insn.  */
d465 1
a465 1
/* The imm16 field (unsigned) in a format 6 insn.  */
d473 1
a473 1
/* The disp16 field in a format 8 insn.  */
d477 1
a477 1
/* The DISP9 field in a format 3 insn, relaxable.  */
d487 1
a487 1
/* The signed disp4 field in a format 4 insn.  */
d491 1
a491 1
/* The unsigned disp5 field in a format 4 insn.  */
d495 1
a495 1
/* The disp16 field in an format 7 unsigned byte load insn.  */
d499 1
a499 1
/* Third register in conditional moves.  */
d507 1
a507 1
/* The imm9 field in a multiply word.  */
d511 1
a511 1
/* The unsigned imm9 field in a multiply word.  */
d519 1
a519 1
/* The IMM6 field in a call instruction.  */
d531 1
a531 1
/* The imm5 field in a push/pop instruction.  */
d535 1
a535 1
/* Reg2 in dispose instruction.  */
d539 1
a539 1
/* Stack pointer in prepare instruction.  */
d543 1
a543 1
/* The IMM5 field in a divide N step instruction.  */
d553 1
a553 2
  /* The setting of the 4th bit is a flag to disassmble() in v850-dis.c.  */
  { -1, 0xfff8001f, NULL, NULL, V850E_PUSH_POP },
d557 1
a557 1
/* Reg - Reg instruction format (Format I).  */
d560 1
a560 1
/* Imm - Reg instruction format (Format II).  */
d563 1
a563 1
/* Conditional branch instruction format (Format III).  */
d566 1
a566 1
/* 3 operand instruction (Format VI).  */
d569 1
a569 1
/* 3 operand instruction (Format VI).  */
a606 1
{ "dbtrap",	one (0xf840),		one (0xffff),		{UNUSED},   		0, PROCESSOR_V850E1 },
d610 1
a610 2
/* Load/store instructions.  */
{ "sld.bu",     one (0x0060),		one (0x07f0),         	{D4,   EP,   R2_NOTR0},	1, PROCESSOR_V850E1 },
a612 1
{ "sld.hu",     one (0x0070),		one (0x07f0),         	{D5_4, EP,   R2_NOTR0},	1, PROCESSOR_V850E1 },
a614 1
{ "sld.b",	one (0x0300),		one (0x0780),	      	{D7,   EP,   R2},	1, PROCESSOR_V850E1 },
a617 1
{ "sld.h",	one (0x0400),		one (0x0780),	      	{D8_7, EP,   R2}, 	1, PROCESSOR_V850E1 },
d642 1
a642 1
/* Byte swap/extend instructions.  */
d651 1
a651 1
/* Jump table instructions.  */
d656 1
a656 1
/* Arithmetic operation instructions.  */
d689 1
a689 1
/* Saturated operation instructions.  */
d696 1
a696 1
/* Logical operation instructions.  */
d713 2
a714 2
/* Branch instructions.  */
	/* Signed integer.  */
d719 1
a719 1
	/* Unsigned integer.  */
d724 1
a724 1
	/* Common.  */
d727 1
a727 1
	/* Others.  */
d744 1
a744 1
	/* Signed integer.  */
d749 1
a749 1
	/* Unsigned integer.  */
d754 1
a754 1
	/* Common.  */
d757 1
a757 1
	/* Others.  */
d772 1
a772 1
/* Bit manipulation instructions.  */
d782 1
a782 1
/* Special instructions.  */
a789 1
{ "dbret",	two (0x07e0, 0x0146),	two (0xffff, 0xffff),	{UNUSED},   		0, PROCESSOR_V850E1 },
d796 1
@


1.5
log
@Fix compile time warnings
@
text
@a610 1
{ "sld.bu",	one (0x0300),		one (0x0780),	      	{D7,   EP,   R2_NOTR0},	1, PROCESSOR_V850EA },
a612 1
{ "sld.hu",	one (0x0400),		one (0x0780),	      	{D8_7, EP,   R2_NOTR0},	1, PROCESSOR_V850EA },
a614 1
{ "sld.b",      one (0x0060),		one (0x07f0),         	{D4,   EP,   R2}, 	1, PROCESSOR_V850EA },
a617 1
{ "sld.h",      one (0x0070),		one (0x07f0),         	{D5_4, EP,   R2}, 	1, PROCESSOR_V850EA },
a624 4
{ "pushml",	two (0x07e0, 0x0001),	two (0xfff0, 0x0007), 	{LIST18_L}, 		0, PROCESSOR_V850EA },
{ "pushmh",	two (0x07e0, 0x0003),	two (0xfff0, 0x0007), 	{LIST18_H}, 		0, PROCESSOR_V850EA },
{ "popml",	two (0x07f0, 0x0001),	two (0xfff0, 0x0007), 	{LIST18_L}, 		0, PROCESSOR_V850EA },
{ "popmh",	two (0x07f0, 0x0003),	two (0xfff0, 0x0007), 	{LIST18_H}, 		0, PROCESSOR_V850EA },
a670 9
  
{ "divhn",	two (0x07e0, 0x0280),   two (0x07e0, 0x07c3), 	{I5DIV, R1, R2, R3}, 	0, PROCESSOR_V850EA },
{ "divhun",	two (0x07e0, 0x0282),   two (0x07e0, 0x07c3), 	{I5DIV, R1, R2, R3}, 	0, PROCESSOR_V850EA },
{ "divn",	two (0x07e0, 0x02c0),   two (0x07e0, 0x07c3), 	{I5DIV, R1, R2, R3}, 	0, PROCESSOR_V850EA },
{ "divun",	two (0x07e0, 0x02c2),   two (0x07e0, 0x07c3), 	{I5DIV, R1, R2, R3}, 	0, PROCESSOR_V850EA },
{ "sdivhn",	two (0x07e0, 0x0180),   two (0x07e0, 0x07c3), 	{I5DIV, R1, R2, R3}, 	0, PROCESSOR_V850EA },
{ "sdivhun",	two (0x07e0, 0x0182),   two (0x07e0, 0x07c3), 	{I5DIV, R1, R2, R3}, 	0, PROCESSOR_V850EA },
{ "sdivn",	two (0x07e0, 0x01c0),   two (0x07e0, 0x07c3), 	{I5DIV, R1, R2, R3}, 	0, PROCESSOR_V850EA },
{ "sdivun",	two (0x07e0, 0x01c2),   two (0x07e0, 0x07c3), 	{I5DIV, R1, R2, R3}, 	0, PROCESSOR_V850EA },
@


1.5.10.1
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d611 1
d614 1
d617 1
d621 1
d629 4
d679 9
@


1.4
log
@For include/opcode:
	* d30v.h: Fix declaration of reg_name_cnt.

	* d10v.h: Fix declaration of d10v_reg_name_cnt.

	* arc.h: Add prototypes from opcodes/arc-opc.c.

For opcodes:
	* tic54x-dis.c: Add unused attributes where needed.

	* z8k-dis.c (output_instr): Add unused attribute.

	* h8300-dis.c: Add missing prototypes.
	(bfd_h8_disassemble): Make static.

	* cris-dis.c: Add missing prototype.
	* h8500-dis.c: Likewise.
	* m68hc11-dis.c: Likewise.
	* pj-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* z8k-dis.c: Likewise.

	* d10v-dis.c: Add missing prototype.
	(dis_long): Remove unused variable.
	(dis_2_short): Likewise.

	* sh-dis.c: Add missing prototypes.
	* v850-opc.c: Likewise.
	Add unused attributes where needed.

	* ns32k-dis.c: Add missing prototypes.
	(bit_extract_simple): Remove unused variable.
@
text
@d37 22
a58 36
static long unsigned int insert_d9
  PARAMS ((long unsigned int, long int, const char **));
static long unsigned int extract_d9
  PARAMS ((long unsigned int, int *));
static long unsigned int insert_d22
  PARAMS ((long unsigned int, long int, const char **));
static long unsigned int extract_d22
  PARAMS ((long unsigned int, int *));
static long unsigned int insert_d16_15
  PARAMS ((long unsigned int, long int, const char **));
static long unsigned int extract_d16_15
  PARAMS ((long unsigned int, int *));
static long unsigned int insert_d8_7
  PARAMS ((long unsigned int, long int, const char **));
static long unsigned int extract_d8_7 PARAMS ((long unsigned int, int *));
static long unsigned int insert_d8_6
  PARAMS ((long unsigned int, long int, const char **));
static long unsigned int extract_d8_6 PARAMS ((long unsigned int, int *));
static long unsigned int insert_d5_4
  PARAMS ((long unsigned int, long int, const char **));
static long unsigned int extract_d5_4 PARAMS ((long unsigned int, int *));
static long unsigned int insert_d16_16
  PARAMS ((long unsigned int, long int, const char **));
static long unsigned int extract_d16_16 PARAMS ((long unsigned int, int *));
static long unsigned int insert_i9
  PARAMS ((long unsigned int, long int, const char **));
static long unsigned int extract_i9 PARAMS ((long unsigned int, int *));
static long unsigned int insert_u9
  PARAMS ((long unsigned int, long unsigned int, const char **));
static long unsigned int extract_u9 PARAMS ((long unsigned int, int *));
static long unsigned int insert_spe
  PARAMS ((long unsigned int, long unsigned int, const char **));
static long unsigned int extract_spe PARAMS ((long unsigned int, int *));
static long unsigned int insert_i5div
  PARAMS ((long unsigned int, long unsigned int, const char **));
static long unsigned int extract_i5div PARAMS ((long unsigned int, int *));
d311 1
a311 1
insert_u9 (insn, value, errmsg)
d313 1
a313 1
     unsigned long value;
d316 1
d338 1
a338 1
insert_spe (insn, value, errmsg)
d340 1
a340 1
     unsigned long value;
d343 2
d360 1
a360 1
insert_i5div (insn, value, errmsg)
d362 1
a362 1
     unsigned long value;
d365 2
d399 1
a399 1
   that code. */
@


1.3
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
d37 36
d110 1
a110 1
     int *         invalid;
d142 1
a142 1
     int *         invalid;
d171 1
a171 1
     int *         invalid;
d202 1
a202 1
     int *         invalid;
d233 1
a233 1
     int *         invalid;
d264 1
a264 1
     int *         invalid;
d286 1
a286 1
     int *         invalid;
d312 1
a312 1
     int *         invalid;
d339 1
a339 1
     int *         invalid;
d364 2
a365 2
     unsigned long insn;
     int *         invalid;
d394 1
a394 1
     int *         invalid;
@


1.2
log
@More portability patches.  Include sysdep.h everywhere.
@
text
@d2 1
a2 1
   Copyright (C) 1996 Free Software Foundation, Inc.
@


1.2.4.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
#include "ansidecl.h"
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@


1.1.1.1.2.1
log
@2000-04-13  Michael Sokolov  <msokolov@@ivan.Harhan.ORG>

	* a29k-dis.c, alpha-dis.c, alpha-opc.c, arc-dis.c, arc-opc.c,
	avr-dis.c, d10v-dis.c, d10v-opc.c, d30v-dis.c, d30v-opc.c,
	disassemble.c, h8300-dis.c, h8500-dis.c, hppa-dis.c, i370-dis.c,
	i370-opc.c, i960-dis.c, m10200-dis.c, m10200-opc.c, m10300-dis.c,
	m10300-opc.c, m68k-dis.c, m68k-opc.c, m88k-dis.c, mcore-dis.c,
	mips-dis.c, mips-opc.c, mips16-opc.c, pj-dis.c, pj-opc.c, ppc-dis.c,
	ppc-opc.c, sh-dis.c, sparc-dis.c, sparc-opc.c, tic80-dis.c,
	tic80-opc.c, v850-dis.c, v850-opc.c, vax-dis.c, w65-dis.c, z8k-dis.c,
	z8kgen.c: Everyone includes sysdep.h. Remove ansidecl.h as sysdep.h
	includes it.
@
text
@d18 1
a18 1
#include "sysdep.h"
@


