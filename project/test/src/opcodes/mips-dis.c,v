head	1.117;
access;
symbols
	sid-snapshot-20180601:1.117
	sid-snapshot-20180501:1.117
	sid-snapshot-20180401:1.117
	sid-snapshot-20180301:1.117
	sid-snapshot-20180201:1.117
	sid-snapshot-20180101:1.117
	sid-snapshot-20171201:1.117
	sid-snapshot-20171101:1.117
	sid-snapshot-20171001:1.117
	sid-snapshot-20170901:1.117
	sid-snapshot-20170801:1.117
	sid-snapshot-20170701:1.117
	sid-snapshot-20170601:1.117
	sid-snapshot-20170501:1.117
	sid-snapshot-20170401:1.117
	sid-snapshot-20170301:1.117
	sid-snapshot-20170201:1.117
	sid-snapshot-20170101:1.117
	sid-snapshot-20161201:1.117
	sid-snapshot-20161101:1.117
	sid-snapshot-20160901:1.117
	sid-snapshot-20160801:1.117
	sid-snapshot-20160701:1.117
	sid-snapshot-20160601:1.117
	sid-snapshot-20160501:1.117
	sid-snapshot-20160401:1.117
	sid-snapshot-20160301:1.117
	sid-snapshot-20160201:1.117
	sid-snapshot-20160101:1.117
	sid-snapshot-20151201:1.117
	sid-snapshot-20151101:1.117
	sid-snapshot-20151001:1.117
	sid-snapshot-20150901:1.117
	sid-snapshot-20150801:1.117
	sid-snapshot-20150701:1.117
	sid-snapshot-20150601:1.117
	sid-snapshot-20150501:1.117
	sid-snapshot-20150401:1.117
	sid-snapshot-20150301:1.117
	sid-snapshot-20150201:1.117
	sid-snapshot-20150101:1.117
	sid-snapshot-20141201:1.117
	sid-snapshot-20141101:1.117
	sid-snapshot-20141001:1.117
	sid-snapshot-20140901:1.117
	sid-snapshot-20140801:1.117
	sid-snapshot-20140701:1.117
	sid-snapshot-20140601:1.117
	sid-snapshot-20140501:1.117
	sid-snapshot-20140401:1.117
	sid-snapshot-20140301:1.117
	sid-snapshot-20140201:1.117
	sid-snapshot-20140101:1.117
	sid-snapshot-20131201:1.117
	sid-snapshot-20131101:1.117
	sid-snapshot-20131001:1.116
	binutils-2_24-branch:1.116.0.2
	binutils-2_24-branchpoint:1.116
	binutils-2_21_1:1.81
	sid-snapshot-20130901:1.116
	gdb_7_6_1-2013-08-30-release:1.99
	sid-snapshot-20130801:1.112
	sid-snapshot-20130701:1.104
	sid-snapshot-20130601:1.100
	sid-snapshot-20130501:1.99
	gdb_7_6-2013-04-26-release:1.99
	sid-snapshot-20130401:1.99
	binutils-2_23_2:1.92.2.2
	gdb_7_6-branch:1.99.0.2
	gdb_7_6-2013-03-12-branchpoint:1.99
	sid-snapshot-20130301:1.98
	sid-snapshot-20130201:1.97
	sid-snapshot-20130101:1.96
	sid-snapshot-20121201:1.96
	gdb_7_5_1-2012-11-29-release:1.91
	binutils-2_23_1:1.92.2.2
	sid-snapshot-20121101:1.96
	binutils-2_23:1.92.2.2
	sid-snapshot-20121001:1.96
	sid-snapshot-20120901:1.96
	gdb_7_5-2012-08-17-release:1.91
	sid-snapshot-20120801:1.94
	binutils-2_23-branch:1.92.0.2
	binutils-2_23-branchpoint:1.92
	gdb_7_5-branch:1.91.0.2
	gdb_7_5-2012-07-18-branchpoint:1.91
	sid-snapshot-20120701:1.90
	sid-snapshot-20120601:1.90
	sid-snapshot-20120501:1.90
	binutils-2_22_branch:1.86.0.4
	gdb_7_4_1-2012-04-26-release:1.89
	sid-snapshot-20120401:1.90
	sid-snapshot-20120301:1.89
	sid-snapshot-20120201:1.89
	gdb_7_4-2012-01-24-release:1.89
	sid-snapshot-20120101:1.89
	gdb_7_4-branch:1.89.0.2
	gdb_7_4-2011-12-13-branchpoint:1.89
	sid-snapshot-20111201:1.88
	binutils-2_22:1.86
	sid-snapshot-20111101:1.86
	sid-snapshot-20111001:1.86
	binutils-2_22-branch:1.86.0.2
	binutils-2_22-branchpoint:1.86
	gdb_7_3_1-2011-09-04-release:1.84
	sid-snapshot-20110901:1.86
	sid-snapshot-20110801:1.85
	gdb_7_3-2011-07-26-release:1.84
	sid-snapshot-20110701:1.84
	sid-snapshot-20110601:1.84
	sid-snapshot-20110501:1.84
	gdb_7_3-branch:1.84.0.2
	gdb_7_3-2011-04-01-branchpoint:1.84
	sid-snapshot-20110401:1.84
	sid-snapshot-20110301:1.84
	sid-snapshot-20110201:1.84
	sid-snapshot-20110101:1.83
	binutils-2_21:1.81
	sid-snapshot-20101201:1.82
	binutils-2_21-branch:1.81.0.4
	binutils-2_21-branchpoint:1.81
	sid-snapshot-20101101:1.81
	sid-snapshot-20101001:1.81
	binutils-2_20_1:1.78
	gdb_7_2-2010-09-02-release:1.81
	sid-snapshot-20100901:1.81
	sid-snapshot-20100801:1.81
	gdb_7_2-branch:1.81.0.2
	gdb_7_2-2010-07-07-branchpoint:1.81
	sid-snapshot-20100701:1.79
	sid-snapshot-20100601:1.79
	sid-snapshot-20100501:1.78
	sid-snapshot-20100401:1.78
	gdb_7_1-2010-03-18-release:1.78
	sid-snapshot-20100301:1.78
	gdb_7_1-branch:1.78.0.6
	gdb_7_1-2010-02-18-branchpoint:1.78
	sid-snapshot-20100201:1.78
	sid-snapshot-20100101:1.78
	gdb_7_0_1-2009-12-22-release:1.78
	sid-snapshot-20091201:1.78
	sid-snapshot-20091101:1.78
	binutils-2_20:1.78
	gdb_7_0-2009-10-06-release:1.78
	sid-snapshot-20091001:1.78
	gdb_7_0-branch:1.78.0.4
	gdb_7_0-2009-09-16-branchpoint:1.78
	arc-sim-20090309:1.70
	binutils-arc-20081103-branch:1.74.0.10
	binutils-arc-20081103-branchpoint:1.74
	binutils-2_20-branch:1.78.0.2
	binutils-2_20-branchpoint:1.78
	sid-snapshot-20090901:1.77
	sid-snapshot-20090801:1.77
	msnyder-checkpoint-072509-branch:1.77.0.4
	msnyder-checkpoint-072509-branchpoint:1.77
	sid-snapshot-20090701:1.77
	dje-cgen-play1-branch:1.77.0.2
	dje-cgen-play1-branchpoint:1.77
	sid-snapshot-20090601:1.77
	sid-snapshot-20090501:1.77
	sid-snapshot-20090401:1.77
	arc-20081103-branch:1.74.0.8
	arc-20081103-branchpoint:1.74
	arc-insight_6_8-branch:1.70.0.8
	arc-insight_6_8-branchpoint:1.70
	insight_6_8-branch:1.70.0.6
	insight_6_8-branchpoint:1.70
	sid-snapshot-20090301:1.77
	binutils-2_19_1:1.74
	sid-snapshot-20090201:1.76
	sid-snapshot-20090101:1.76
	reverse-20081226-branch:1.76.0.2
	reverse-20081226-branchpoint:1.76
	sid-snapshot-20081201:1.76
	multiprocess-20081120-branch:1.75.0.2
	multiprocess-20081120-branchpoint:1.75
	sid-snapshot-20081101:1.74
	binutils-2_19:1.74
	sid-snapshot-20081001:1.74
	reverse-20080930-branch:1.74.0.6
	reverse-20080930-branchpoint:1.74
	binutils-2_19-branch:1.74.0.4
	binutils-2_19-branchpoint:1.74
	sid-snapshot-20080901:1.74
	sid-snapshot-20080801:1.74
	reverse-20080717-branch:1.74.0.2
	reverse-20080717-branchpoint:1.74
	sid-snapshot-20080701:1.73
	msnyder-reverse-20080609-branch:1.70.0.4
	msnyder-reverse-20080609-branchpoint:1.70
	drow-reverse-20070409-branch:1.65.0.2
	drow-reverse-20070409-branchpoint:1.65
	sid-snapshot-20080601:1.70
	sid-snapshot-20080501:1.70
	sid-snapshot-20080403:1.70
	sid-snapshot-20080401:1.70
	gdb_6_8-2008-03-27-release:1.70
	sid-snapshot-20080301:1.70
	gdb_6_8-branch:1.70.0.2
	gdb_6_8-2008-02-26-branchpoint:1.70
	sid-snapshot-20080201:1.69
	sid-snapshot-20080101:1.69
	sid-snapshot-20071201:1.69
	sid-snapshot-20071101:1.68
	gdb_6_7_1-2007-10-29-release:1.66
	gdb_6_7-2007-10-10-release:1.66
	sid-snapshot-20071001:1.67
	gdb_6_7-branch:1.66.0.4
	gdb_6_7-2007-09-07-branchpoint:1.66
	binutils-2_18:1.66
	binutils-2_18-branch:1.66.0.2
	binutils-2_18-branchpoint:1.66
	insight_6_6-20070208-release:1.64
	binutils-csl-coldfire-4_1-32:1.55
	binutils-csl-sourcerygxx-4_1-32:1.55
	gdb_6_6-2006-12-18-release:1.64
	binutils-csl-innovasic-fido-3_4_4-33:1.55
	binutils-csl-sourcerygxx-3_4_4-32:1.49
	binutils-csl-coldfire-4_1-30:1.55
	binutils-csl-sourcerygxx-4_1-30:1.55
	binutils-csl-coldfire-4_1-28:1.55
	binutils-csl-sourcerygxx-4_1-29:1.55
	binutils-csl-sourcerygxx-4_1-28:1.55
	gdb_6_6-branch:1.64.0.2
	gdb_6_6-2006-11-15-branchpoint:1.64
	binutils-csl-arm-2006q3-27:1.55
	binutils-csl-sourcerygxx-4_1-27:1.55
	binutils-csl-arm-2006q3-26:1.55
	binutils-csl-sourcerygxx-4_1-26:1.55
	binutils-csl-sourcerygxx-4_1-25:1.55
	binutils-csl-sourcerygxx-4_1-24:1.55
	binutils-csl-sourcerygxx-4_1-23:1.55
	insight_6_5-20061003-release:1.62
	gdb-csl-symbian-6_4_50_20060226-12:1.55
	binutils-csl-sourcerygxx-4_1-21:1.55
	binutils-csl-arm-2006q3-21:1.55
	binutils-csl-sourcerygxx-4_1-22:1.55
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.55
	binutils-csl-sourcerygxx-4_1-20:1.55
	binutils-csl-arm-2006q3-19:1.55
	binutils-csl-sourcerygxx-4_1-19:1.55
	binutils-csl-sourcerygxx-4_1-18:1.55
	binutils-csl-renesas-4_1-9:1.55
	gdb-csl-sourcerygxx-3_4_4-25:1.55
	binutils-csl-sourcerygxx-3_4_4-25:1.49
	nickrob-async-20060828-mergepoint:1.63
	gdb-csl-symbian-6_4_50_20060226-11:1.55
	binutils-csl-renesas-4_1-8:1.55
	binutils-csl-renesas-4_1-7:1.55
	binutils-csl-renesas-4_1-6:1.55
	gdb-csl-sourcerygxx-4_1-17:1.55
	binutils-csl-sourcerygxx-4_1-17:1.55
	gdb-csl-20060226-branch-local-2:1.55
	gdb-csl-sourcerygxx-4_1-14:1.55
	binutils-csl-sourcerygxx-4_1-14:1.55
	binutils-csl-sourcerygxx-4_1-15:1.55
	gdb-csl-sourcerygxx-4_1-13:1.55
	binutils-csl-sourcerygxx-4_1-13:1.55
	binutils-2_17:1.55
	gdb-csl-sourcerygxx-4_1-12:1.55
	binutils-csl-sourcerygxx-4_1-12:1.55
	gdb-csl-sourcerygxx-3_4_4-21:1.55
	binutils-csl-sourcerygxx-3_4_4-21:1.55
	gdb_6_5-20060621-release:1.62
	binutils-csl-wrs-linux-3_4_4-24:1.49
	binutils-csl-wrs-linux-3_4_4-23:1.49
	gdb-csl-sourcerygxx-4_1-9:1.55
	binutils-csl-sourcerygxx-4_1-9:1.55
	gdb-csl-sourcerygxx-4_1-8:1.55
	binutils-csl-sourcerygxx-4_1-8:1.55
	gdb-csl-sourcerygxx-4_1-7:1.55
	binutils-csl-sourcerygxx-4_1-7:1.55
	gdb-csl-arm-2006q1-6:1.55
	binutils-csl-arm-2006q1-6:1.55
	gdb-csl-sourcerygxx-4_1-6:1.55
	binutils-csl-sourcerygxx-4_1-6:1.55
	binutils-csl-wrs-linux-3_4_4-22:1.49
	gdb-csl-symbian-6_4_50_20060226-10:1.55
	gdb-csl-symbian-6_4_50_20060226-9:1.55
	gdb-csl-symbian-6_4_50_20060226-8:1.55
	gdb-csl-coldfire-4_1-11:1.55
	binutils-csl-coldfire-4_1-11:1.55
	gdb-csl-sourcerygxx-3_4_4-19:1.55
	binutils-csl-sourcerygxx-3_4_4-19:1.55
	gdb-csl-coldfire-4_1-10:1.55
	gdb_6_5-branch:1.62.0.4
	gdb_6_5-2006-05-14-branchpoint:1.62
	binutils-csl-coldfire-4_1-10:1.55
	gdb-csl-sourcerygxx-4_1-5:1.55
	binutils-csl-sourcerygxx-4_1-5:1.55
	nickrob-async-20060513-branch:1.62.0.2
	nickrob-async-20060513-branchpoint:1.62
	gdb-csl-sourcerygxx-4_1-4:1.55
	binutils-csl-sourcerygxx-4_1-4:1.55
	msnyder-reverse-20060502-branch:1.60.0.2
	msnyder-reverse-20060502-branchpoint:1.60
	binutils-csl-wrs-linux-3_4_4-21:1.49
	gdb-csl-morpho-4_1-4:1.55
	binutils-csl-morpho-4_1-4:1.55
	gdb-csl-sourcerygxx-3_4_4-17:1.55
	binutils-csl-sourcerygxx-3_4_4-17:1.55
	binutils-csl-wrs-linux-3_4_4-20:1.49
	readline_5_1-import-branch:1.55.0.18
	readline_5_1-import-branchpoint:1.55
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.55
	binutils-2_17-branch:1.55.0.16
	binutils-2_17-branchpoint:1.55
	gdb-csl-symbian-20060226-branch:1.55.0.14
	gdb-csl-symbian-20060226-branchpoint:1.55
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.55
	msnyder-reverse-20060331-branch:1.55.0.12
	msnyder-reverse-20060331-branchpoint:1.55
	binutils-csl-2_17-branch:1.55.0.10
	binutils-csl-2_17-branchpoint:1.55
	gdb-csl-available-20060303-branch:1.55.0.8
	gdb-csl-available-20060303-branchpoint:1.55
	gdb-csl-20060226-branch:1.55.0.6
	gdb-csl-20060226-branchpoint:1.55
	gdb_6_4-20051202-release:1.54
	msnyder-fork-checkpoint-branch:1.55.0.4
	msnyder-fork-checkpoint-branchpoint:1.55
	gdb-csl-gxxpro-6_3-branch:1.55.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.55
	gdb_6_4-branch:1.54.0.4
	gdb_6_4-2005-11-01-branchpoint:1.54
	gdb-csl-arm-20051020-branch:1.54.0.2
	gdb-csl-arm-20051020-branchpoint:1.54
	binutils-csl-gxxpro-3_4-branch:1.49.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.49
	binutils-2_16_1:1.49
	msnyder-tracepoint-checkpoint-branch:1.50.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.50
	gdb-csl-arm-20050325-2005-q1b:1.49
	binutils-csl-arm-2005q1b:1.49
	binutils-2_16:1.49
	gdb-csl-arm-20050325-2005-q1a:1.49
	binutils-csl-arm-2005q1a:1.49
	csl-arm-20050325-branch:1.49.0.6
	csl-arm-20050325-branchpoint:1.49
	binutils-csl-arm-2005q1-branch:1.49.0.4
	binutils-csl-arm-2005q1-branchpoint:1.49
	binutils-2_16-branch:1.49.0.2
	binutils-2_16-branchpoint:1.49
	csl-arm-2004-q3d:1.46
	gdb_6_3-20041109-release:1.46
	gdb_6_3-branch:1.46.0.18
	gdb_6_3-20041019-branchpoint:1.46
	csl-arm-2004-q3:1.46
	drow_intercu-merge-20040921:1.46
	drow_intercu-merge-20040915:1.46
	jimb-gdb_6_2-e500-branch:1.46.0.20
	jimb-gdb_6_2-e500-branchpoint:1.46
	gdb_6_2-20040730-release:1.46
	gdb_6_2-branch:1.46.0.16
	gdb_6_2-2004-07-10-gmt-branchpoint:1.46
	gdb_6_1_1-20040616-release:1.46
	binutils-2_15:1.46
	binutils-2_15-branchpoint:1.46
	csl-arm-2004-q1a:1.46
	csl-arm-2004-q1:1.46
	gdb_6_1-2004-04-05-release:1.46
	drow_intercu-merge-20040402:1.46
	drow_intercu-merge-20040327:1.46
	ezannoni_pie-20040323-branch:1.46.0.14
	ezannoni_pie-20040323-branchpoint:1.46
	cagney_tramp-20040321-mergepoint:1.46
	cagney_tramp-20040309-branch:1.46.0.12
	cagney_tramp-20040309-branchpoint:1.46
	gdb_6_1-branch:1.46.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.46
	drow_intercu-20040221-branch:1.46.0.8
	drow_intercu-20040221-branchpoint:1.46
	binutils-2_15-branch:1.46.0.6
	cagney_bfdfile-20040213-branch:1.46.0.4
	cagney_bfdfile-20040213-branchpoint:1.46
	drow-cplus-merge-20040208:1.46
	carlton_dictionary-20040126-merge:1.46
	cagney_bigcore-20040122-branch:1.46.0.2
	cagney_bigcore-20040122-branchpoint:1.46
	drow-cplus-merge-20040113:1.46
	csl-arm-2003-q4:1.46
	drow-cplus-merge-20031224:1.46
	drow-cplus-merge-20031220:1.46
	carlton_dictionary-20031215-merge:1.46
	drow-cplus-merge-20031214:1.46
	carlton-dictionary-20031111-merge:1.46
	gdb_6_0-2003-10-04-release:1.43
	kettenis_sparc-20030918-branch:1.45.0.6
	kettenis_sparc-20030918-branchpoint:1.45
	carlton_dictionary-20030917-merge:1.45
	ezannoni_pie-20030916-branchpoint:1.45
	ezannoni_pie-20030916-branch:1.45.0.4
	cagney_x86i386-20030821-branch:1.45.0.2
	cagney_x86i386-20030821-branchpoint:1.45
	carlton_dictionary-20030805-merge:1.45
	carlton_dictionary-20030627-merge:1.43
	gdb_6_0-branch:1.43.0.18
	gdb_6_0-2003-06-23-branchpoint:1.43
	jimb-ppc64-linux-20030613-branch:1.43.0.16
	jimb-ppc64-linux-20030613-branchpoint:1.43
	binutils-2_14:1.43
	cagney_convert-20030606-branch:1.43.0.14
	cagney_convert-20030606-branchpoint:1.43
	cagney_writestrings-20030508-branch:1.43.0.12
	cagney_writestrings-20030508-branchpoint:1.43
	jimb-ppc64-linux-20030528-branch:1.43.0.10
	jimb-ppc64-linux-20030528-branchpoint:1.43
	carlton_dictionary-20030523-merge:1.43
	cagney_fileio-20030521-branch:1.43.0.8
	cagney_fileio-20030521-branchpoint:1.43
	kettenis_i386newframe-20030517-mergepoint:1.43
	jimb-ppc64-linux-20030509-branch:1.43.0.6
	jimb-ppc64-linux-20030509-branchpoint:1.43
	kettenis_i386newframe-20030504-mergepoint:1.43
	carlton_dictionary-20030430-merge:1.43
	binutils-2_14-branch:1.43.0.4
	binutils-2_14-branchpoint:1.43
	kettenis_i386newframe-20030419-branch:1.43.0.2
	kettenis_i386newframe-20030419-branchpoint:1.43
	carlton_dictionary-20030416-merge:1.43
	cagney_frameaddr-20030409-mergepoint:1.43
	kettenis_i386newframe-20030406-branch:1.41.0.14
	kettenis_i386newframe-20030406-branchpoint:1.41
	cagney_frameaddr-20030403-branchpoint:1.41
	cagney_frameaddr-20030403-branch:1.41.0.12
	cagney_framebase-20030330-mergepoint:1.41
	cagney_framebase-20030326-branch:1.41.0.10
	cagney_framebase-20030326-branchpoint:1.41
	cagney_lazyid-20030317-branch:1.41.0.8
	cagney_lazyid-20030317-branchpoint:1.41
	kettenis-i386newframe-20030316-mergepoint:1.41
	offbyone-20030313-branch:1.41.0.6
	offbyone-20030313-branchpoint:1.41
	kettenis-i386newframe-20030308-branch:1.41.0.4
	kettenis-i386newframe-20030308-branchpoint:1.41
	carlton_dictionary-20030305-merge:1.41
	cagney_offbyone-20030303-branch:1.41.0.2
	cagney_offbyone-20030303-branchpoint:1.41
	carlton_dictionary-20030207-merge:1.40
	interps-20030202-branch:1.40.0.4
	interps-20030202-branchpoint:1.40
	cagney-unwind-20030108-branch:1.40.0.2
	cagney-unwind-20030108-branchpoint:1.40
	binutils-2_13_2_1:1.31
	binutils-2_13_2:1.31
	carlton_dictionary-20021223-merge:1.35
	gdb_5_3-2002-12-12-release:1.32
	carlton_dictionary-20021115-merge:1.34
	binutils-2_13_1:1.31
	kseitz_interps-20021105-merge:1.34
	kseitz_interps-20021103-merge:1.34
	drow-cplus-merge-20021020:1.34
	drow-cplus-merge-20021025:1.34
	carlton_dictionary-20021025-merge:1.34
	carlton_dictionary-20021011-merge:1.34
	drow-cplus-branch:1.34.0.2
	drow-cplus-branchpoint:1.34
	kseitz_interps-20020930-merge:1.34
	carlton_dictionary-20020927-merge:1.33
	carlton_dictionary-branch:1.32.0.6
	carlton_dictionary-20020920-branchpoint:1.32
	sid-20020905-branchpoint:1.32
	sid-20020905-branch:1.32.0.4
	gdb_5_3-branch:1.32.0.2
	gdb_5_3-2002-09-04-branchpoint:1.32
	kseitz_interps-20020829-merge:1.31
	cagney_sysregs-20020825-branch:1.31.0.6
	cagney_sysregs-20020825-branchpoint:1.31
	readline_4_3-import-branch:1.31.0.4
	readline_4_3-import-branchpoint:1.31
	binutils-2_13:1.31
	gdb_5_2_1-2002-07-23-release:1.24.4.1
	binutils-2_13-branchpoint:1.31
	binutils-2_13-branch:1.31.0.2
	kseitz_interps-20020528-branch:1.29.0.2
	kseitz_interps-20020528-branchpoint:1.29
	cagney_regbuf-20020515-branch:1.28.0.4
	cagney_regbuf-20020515-branchpoint:1.28
	binutils-2_12_1:1.24.2.1
	jimb-macro-020506-branch:1.28.0.2
	jimb-macro-020506-branchpoint:1.28
	gdb_5_2-2002-04-29-release:1.24.4.1
	binutils-2_12:1.24
	gdb_5_2-branch:1.24.0.4
	gdb_5_2-2002-03-03-branchpoint:1.24
	binutils-2_12-branch:1.24.0.2
	binutils-2_12-branchpoint:1.24
	gdb_5_1_1-2002-01-24-release:1.16
	gdb_5_1_0_1-2002-01-03-release:1.16
	cygnus_cvs_20020108_pre:1.24
	gdb_5_1_0_1-2002-01-03-branch:1.16.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.16
	gdb_5_1-2001-11-21-release:1.16
	gdb_s390-2001-09-26-branch:1.16.0.4
	gdb_s390-2001-09-26-branchpoint:1.16
	gdb_5_1-2001-07-29-branch:1.16.0.2
	gdb_5_1-2001-07-29-branchpoint:1.16
	binutils-2_11_2:1.11.2.2
	binutils-2_11_1:1.11.2.2
	binutils-2_11:1.11
	x86_64versiong3:1.12
	binutils-2_11-branch:1.11.0.2
	insight-precleanup-2001-01-01:1.11
	binutils-2_10_1:1.3.2.1
	binutils-2_10:1.3.2.1
	gdb-premipsmulti-2000-06-06-branch:1.6.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.6
	gdb_5_0-2000-05-19-release:1.3
	gdb_4_18_2-2000-05-18-release:1.3
	gdb_4_95_1-2000-05-11-snapshot:1.3
	gdb_4_95_0-2000-04-27-snapshot:1.3
	gdb_5_0-2000-04-10-branch:1.3.0.4
	gdb_5_0-2000-04-10-branchpoint:1.3
	binutils-2_10-branch:1.3.0.2
	binutils-2_10-branchpoint:1.3
	binutils_latest_snapshot:1.117
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.117
date	2013.10.14.18.58.15;	author chaoyingfu;	state Exp;
branches;
next	1.116;

1.116
date	2013.08.19.18.56.59;	author rsandifo;	state Exp;
branches;
next	1.115;

1.115
date	2013.08.04.07.31.38;	author rsandifo;	state Exp;
branches;
next	1.114;

1.114
date	2013.08.01.20.55.24;	author rsandifo;	state Exp;
branches;
next	1.113;

1.113
date	2013.08.01.20.40.23;	author rsandifo;	state Exp;
branches;
next	1.112;

1.112
date	2013.08.01.07.13.21;	author rsandifo;	state Exp;
branches;
next	1.111;

1.111
date	2013.07.14.13.36.51;	author rsandifo;	state Exp;
branches;
next	1.110;

1.110
date	2013.07.14.13.28.56;	author rsandifo;	state Exp;
branches;
next	1.109;

1.109
date	2013.07.07.10.15.08;	author rsandifo;	state Exp;
branches;
next	1.108;

1.108
date	2013.07.07.10.00.43;	author rsandifo;	state Exp;
branches;
next	1.107;

1.107
date	2013.07.07.09.50.42;	author rsandifo;	state Exp;
branches;
next	1.106;

1.106
date	2013.07.07.09.41.03;	author rsandifo;	state Exp;
branches;
next	1.105;

1.105
date	2013.07.07.09.32.55;	author rsandifo;	state Exp;
branches;
next	1.104;

1.104
date	2013.06.24.23.55.46;	author macro;	state Exp;
branches;
next	1.103;

1.103
date	2013.06.17.22.59.10;	author clm;	state Exp;
branches;
next	1.102;

1.102
date	2013.06.13.21.01.44;	author chaoyingfu;	state Exp;
branches;
next	1.101;

1.101
date	2013.06.08.10.22.55;	author rsandifo;	state Exp;
branches;
next	1.100;

1.100
date	2013.05.10.01.08.48;	author pinskia;	state Exp;
branches;
next	1.99;

1.99
date	2013.03.12.15.19.23;	author eager;	state Exp;
branches;
next	1.98;

1.98
date	2013.02.13.17.09.09;	author macro;	state Exp;
branches;
next	1.97;

1.97
date	2013.01.04.17.22.53;	author nickc;	state Exp;
branches;
next	1.96;

1.96
date	2012.08.14.22.00.05;	author macro;	state Exp;
branches;
next	1.95;

1.95
date	2012.08.13.14.26.14;	author macro;	state Exp;
branches;
next	1.94;

1.94
date	2012.08.01.00.41.35;	author amodra;	state Exp;
branches;
next	1.93;

1.93
date	2012.07.31.21.38.54;	author macro;	state Exp;
branches;
next	1.92;

1.92
date	2012.07.24.12.56.47;	author nickc;	state Exp;
branches
	1.92.2.1;
next	1.91;

1.91
date	2012.07.05.08.18.43;	author tschwinge;	state Exp;
branches;
next	1.90;

1.90
date	2012.03.24.01.09.28;	author mkuvyrkov;	state Exp;
branches;
next	1.89;

1.89
date	2011.12.08.20.47.27;	author pinskia;	state Exp;
branches;
next	1.88;

1.88
date	2011.11.29.20.28.55;	author pinskia;	state Exp;
branches;
next	1.87;

1.87
date	2011.11.25.15.21.29;	author muller;	state Exp;
branches;
next	1.86;

1.86
date	2011.08.09.15.20.03;	author macro;	state Exp;
branches
	1.86.2.1;
next	1.85;

1.85
date	2011.07.24.14.20.13;	author rsandifo;	state Exp;
branches;
next	1.84;

1.84
date	2011.01.11.07.22.09;	author xmj;	state Exp;
branches;
next	1.83;

1.83
date	2010.12.18.11.14.13;	author rsandifo;	state Exp;
branches;
next	1.82;

1.82
date	2010.11.11.10.23.39;	author nickc;	state Exp;
branches;
next	1.81;

1.81
date	2010.07.06.00.06.04;	author macro;	state Exp;
branches;
next	1.80;

1.80
date	2010.07.06.00.02.46;	author macro;	state Exp;
branches;
next	1.79;

1.79
date	2010.05.26.12.59.56;	author clm;	state Exp;
branches;
next	1.78;

1.78
date	2009.09.02.07.20.30;	author amodra;	state Exp;
branches;
next	1.77;

1.77
date	2009.02.03.18.16.04;	author jsm28;	state Exp;
branches;
next	1.76;

1.76
date	2008.11.28.18.02.17;	author ths;	state Exp;
branches;
next	1.75;

1.75
date	2008.11.06.19.40.10;	author chaoyingfu;	state Exp;
branches;
next	1.74;

1.74
date	2008.07.10.19.05.28;	author rsandifo;	state Exp;
branches;
next	1.73;

1.73
date	2008.06.30.20.51.57;	author rsandifo;	state Exp;
branches;
next	1.72;

1.72
date	2008.06.12.21.44.54;	author nickc;	state Exp;
branches;
next	1.71;

1.71
date	2008.06.12.16.14.52;	author nickc;	state Exp;
branches;
next	1.70;

1.70
date	2008.02.04.19.26.11;	author nemet;	state Exp;
branches;
next	1.69;

1.69
date	2007.11.29.12.23.44;	author shinwell;	state Exp;
branches;
next	1.68;

1.68
date	2007.10.08.16.41.35;	author macro;	state Exp;
branches;
next	1.67;

1.67
date	2007.09.26.16.07.18;	author nickc;	state Exp;
branches;
next	1.66;

1.66
date	2007.07.05.09.49.02;	author nickc;	state Exp;
branches;
next	1.65;

1.65
date	2007.02.20.13.28.55;	author ths;	state Exp;
branches;
next	1.64;

1.64
date	2006.09.16.18.12.17;	author nickc;	state Exp;
branches;
next	1.63;

1.63
date	2006.06.06.10.49.48;	author ths;	state Exp;
branches;
next	1.62;

1.62
date	2006.05.04.10.47.05;	author ths;	state Exp;
branches;
next	1.61;

1.61
date	2006.05.02.11.12.41;	author ths;	state Exp;
branches;
next	1.60;

1.60
date	2006.04.30.18.34.39;	author ths;	state Exp;
branches;
next	1.59;

1.59
date	2006.04.28.13.16.59;	author ths;	state Exp;
branches;
next	1.58;

1.58
date	2006.04.28.12.59.30;	author ths;	state Exp;
branches;
next	1.57;

1.57
date	2006.04.28.12.19.31;	author ths;	state Exp;
branches;
next	1.56;

1.56
date	2006.04.28.11.42.28;	author ths;	state Exp;
branches;
next	1.55;

1.55
date	2005.11.14.02.25.39;	author ths;	state Exp;
branches;
next	1.54;

1.54
date	2005.09.06.18.46.57;	author chaoyingfu;	state Exp;
branches;
next	1.53;

1.53
date	2005.08.25.18.12.44;	author chaoyingfu;	state Exp;
branches;
next	1.52;

1.52
date	2005.07.07.19.27.51;	author wilson;	state Exp;
branches;
next	1.51;

1.51
date	2005.07.01.11.16.32;	author nickc;	state Exp;
branches;
next	1.50;

1.50
date	2005.05.07.07.34.30;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	2005.03.03.11.49.50;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2005.01.21.19.43.04;	author fnf;	state Exp;
branches;
next	1.47;

1.47
date	2005.01.19.23.31.15;	author fnf;	state Exp;
branches;
next	1.46;

1.46
date	2003.09.30.16.17.15;	author cgd;	state Exp;
branches;
next	1.45;

1.45
date	2003.07.15.07.50.38;	author rsandifo;	state Exp;
branches;
next	1.44;

1.44
date	2003.07.09.22.53.52;	author cgd;	state Exp;
branches;
next	1.43;

1.43
date	2003.04.08.07.14.47;	author aoliva;	state Exp;
branches;
next	1.42;

1.42
date	2003.04.08.00.39.16;	author aoliva;	state Exp;
branches;
next	1.41;

1.41
date	2003.02.23.19.52.49;	author cgd;	state Exp;
branches;
next	1.40;

1.40
date	2003.01.02.22.04.55;	author cgd;	state Exp;
branches;
next	1.39;

1.39
date	2003.01.02.21.07.00;	author cgd;	state Exp;
branches;
next	1.38;

1.38
date	2002.12.31.08.11.18;	author cgd;	state Exp;
branches;
next	1.37;

1.37
date	2002.12.31.07.29.29;	author cgd;	state Exp;
branches;
next	1.36;

1.36
date	2002.12.27.08.00.31;	author cgd;	state Exp;
branches;
next	1.35;

1.35
date	2002.11.30.08.39.46;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2002.09.30.11.58.10;	author rsandifo;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2002.09.26.09.56.35;	author ths;	state Exp;
branches;
next	1.32;

1.32
date	2002.08.30.08.28.08;	author amodra;	state Exp;
branches
	1.32.6.1;
next	1.31;

1.31
date	2002.07.09.14.21.40;	author ths;	state Exp;
branches;
next	1.30;

1.30
date	2002.05.31.01.17.18;	author cgd;	state Exp;
branches;
next	1.29;

1.29
date	2002.05.14.23.34.00;	author ths;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2002.03.16.03.12.07;	author cgd;	state Exp;
branches
	1.28.4.1;
next	1.27;

1.27
date	2002.03.16.03.09.19;	author cgd;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.15.17.32.05;	author cgd;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.15.06.01.08;	author cgd;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.05.03.07.51;	author cgd;	state Exp;
branches
	1.24.2.1
	1.24.4.1;
next	1.23;

1.23
date	2001.10.23.19.20.27;	author cgd;	state Exp;
branches;
next	1.22;

1.22
date	2001.10.18.01.42.16;	author cgd;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.31.21.12.34;	author echristo;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.21.08.42.28;	author aj;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.13.08.09.58;	author kazu;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.10.16.22.08;	author rsandifo;	state Exp;
branches;
next	1.17;

1.17
date	2001.08.07.12.36.13;	author ths;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.23.17.26.40;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.15.12.11.12;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.24.00.40.22;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.13.22.58.36;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.11.23.11.40;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.02.01.10.33;	author nickc;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2000.12.02.00.52.56;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.01.21.35.38;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.01.20.05.32;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2000.09.14.01.47.38;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.24.15.24.56;	author dnovillo;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.11.07.10.19;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.14.04.16.58;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.22.14.41.46;	author aph;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.11.01.19.29.55;	author gavin;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.59;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.92.2.1
date	2012.09.04.14.01.41;	author gingold;	state Exp;
branches;
next	1.92.2.2;

1.92.2.2
date	2012.09.04.14.38.06;	author gingold;	state Exp;
branches;
next	;

1.86.2.1
date	2011.11.25.16.57.33;	author muller;	state Exp;
branches;
next	;

1.34.2.1
date	2003.12.14.20.28.07;	author drow;	state Exp;
branches;
next	;

1.32.6.1
date	2002.09.27.20.03.27;	author carlton;	state Exp;
branches;
next	1.32.6.2;

1.32.6.2
date	2002.10.11.22.23.07;	author carlton;	state Exp;
branches;
next	1.32.6.3;

1.32.6.3
date	2002.12.23.19.39.36;	author carlton;	state Exp;
branches;
next	1.32.6.4;

1.32.6.4
date	2003.02.07.19.18.04;	author carlton;	state Exp;
branches;
next	1.32.6.5;

1.32.6.5
date	2003.03.06.00.56.39;	author carlton;	state Exp;
branches;
next	1.32.6.6;

1.32.6.6
date	2003.08.05.17.13.30;	author carlton;	state Exp;
branches;
next	1.32.6.7;

1.32.6.7
date	2003.11.11.23.51.17;	author carlton;	state Exp;
branches;
next	;

1.29.2.1
date	2002.06.20.01.38.29;	author kseitz;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2002.07.22.21.47.19;	author kseitz;	state Exp;
branches;
next	1.29.2.3;

1.29.2.3
date	2002.10.01.00.46.44;	author kseitz;	state Exp;
branches;
next	;

1.28.4.1
date	2002.06.15.16.43.20;	author cagney;	state Exp;
branches;
next	;

1.24.2.1
date	2002.04.30.21.41.47;	author cgd;	state Exp;
branches;
next	;

1.24.4.1
date	2002.04.07.21.31.49;	author cagney;	state Exp;
branches;
next	;

1.11.2.1
date	2001.06.07.03.18.36;	author amodra;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2001.06.11.10.05.19;	author amodra;	state Exp;
branches;
next	;

1.3.2.1
date	2000.05.06.14.49.26;	author pb;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.59;	author rth;	state Exp;
branches;
next	;


desc
@@


1.117
log
@2013-10-14  Chao-ying Fu  <Chao-ying.Fu@@imgtec.com>

	* micromips-opc.c (decode_micromips_operand): Add +T, +U, +V, +W,
	+d, +e, +h, +k, +l, +n, +o, +u, +v, +w, +x,
	+~, +!, +@@, +#, +$, +%, +^, +&, +*, +|.
	(MSA): New define.
	(MSA64): New define.
	(micromips_opcodes): Add MSA instructions.
	* mips-dis.c (msa_control_names): New array.
	(mips_abi_choice): Add ASE_MSA to mips32r2.
	Remove ASE_MDMX from mips64r2.
	Add ASE_MSA and ASE_MSA64 to mips64r2.
	(parse_mips_dis_option): Handle -Mmsa.
	(print_reg): Handle cases for OP_REG_MSA and OP_REG_MSA_CTRL.
	(print_insn_arg): Handle cases for OP_IMM_INDEX and OP_REG_INDEX.
	(print_mips_disassembler_options): Print -Mmsa.
	* mips-opc.c (decode_mips_operand): Add +T, +U, +V, +W, +d, +e, +h, +k,
	+l, +n, +o, +u, +v, +w, +~, +!, +@@, +#, +$, +%, +^, +&, +*, +|.
	(MSA): New define.
	(MSA64): New define.
	(mips_builtin_op): Add MSA instructions.
@
text
@/* Print mips instructions for GDB, the GNU debugger, or for objdump.
   Copyright 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009, 2012
   Free Software Foundation, Inc.
   Contributed by Nobuyuki Hikichi(hikichi@@sra.co.jp).

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "dis-asm.h"
#include "libiberty.h"
#include "opcode/mips.h"
#include "opintl.h"

/* FIXME: These are needed to figure out if the code is mips16 or
   not. The low bit of the address is often a good indicator.  No
   symbol table is available when this code runs out in an embedded
   system as when it is used for disassembler support in a monitor.  */

#if !defined(EMBEDDED_ENV)
#define SYMTAB_AVAILABLE 1
#include "elf-bfd.h"
#include "elf/mips.h"
#endif

/* Mips instructions are at maximum this many bytes long.  */
#define INSNLEN 4


/* FIXME: These should be shared with gdb somehow.  */

struct mips_cp0sel_name
{
  unsigned int cp0reg;
  unsigned int sel;
  const char * const name;
};

static const char * const mips_gpr_names_numeric[32] =
{
  "$0",   "$1",   "$2",   "$3",   "$4",   "$5",   "$6",   "$7",
  "$8",   "$9",   "$10",  "$11",  "$12",  "$13",  "$14",  "$15",
  "$16",  "$17",  "$18",  "$19",  "$20",  "$21",  "$22",  "$23",
  "$24",  "$25",  "$26",  "$27",  "$28",  "$29",  "$30",  "$31"
};

static const char * const mips_gpr_names_oldabi[32] =
{
  "zero", "at",   "v0",   "v1",   "a0",   "a1",   "a2",   "a3",
  "t0",   "t1",   "t2",   "t3",   "t4",   "t5",   "t6",   "t7",
  "s0",   "s1",   "s2",   "s3",   "s4",   "s5",   "s6",   "s7",
  "t8",   "t9",   "k0",   "k1",   "gp",   "sp",   "s8",   "ra"
};

static const char * const mips_gpr_names_newabi[32] =
{
  "zero", "at",   "v0",   "v1",   "a0",   "a1",   "a2",   "a3",
  "a4",   "a5",   "a6",   "a7",   "t0",   "t1",   "t2",   "t3",
  "s0",   "s1",   "s2",   "s3",   "s4",   "s5",   "s6",   "s7",
  "t8",   "t9",   "k0",   "k1",   "gp",   "sp",   "s8",   "ra"
};

static const char * const mips_fpr_names_numeric[32] =
{
  "$f0",  "$f1",  "$f2",  "$f3",  "$f4",  "$f5",  "$f6",  "$f7",
  "$f8",  "$f9",  "$f10", "$f11", "$f12", "$f13", "$f14", "$f15",
  "$f16", "$f17", "$f18", "$f19", "$f20", "$f21", "$f22", "$f23",
  "$f24", "$f25", "$f26", "$f27", "$f28", "$f29", "$f30", "$f31"
};

static const char * const mips_fpr_names_32[32] =
{
  "fv0",  "fv0f", "fv1",  "fv1f", "ft0",  "ft0f", "ft1",  "ft1f",
  "ft2",  "ft2f", "ft3",  "ft3f", "fa0",  "fa0f", "fa1",  "fa1f",
  "ft4",  "ft4f", "ft5",  "ft5f", "fs0",  "fs0f", "fs1",  "fs1f",
  "fs2",  "fs2f", "fs3",  "fs3f", "fs4",  "fs4f", "fs5",  "fs5f"
};

static const char * const mips_fpr_names_n32[32] =
{
  "fv0",  "ft14", "fv1",  "ft15", "ft0",  "ft1",  "ft2",  "ft3",
  "ft4",  "ft5",  "ft6",  "ft7",  "fa0",  "fa1",  "fa2",  "fa3",
  "fa4",  "fa5",  "fa6",  "fa7",  "fs0",  "ft8",  "fs1",  "ft9",
  "fs2",  "ft10", "fs3",  "ft11", "fs4",  "ft12", "fs5",  "ft13"
};

static const char * const mips_fpr_names_64[32] =
{
  "fv0",  "ft12", "fv1",  "ft13", "ft0",  "ft1",  "ft2",  "ft3",
  "ft4",  "ft5",  "ft6",  "ft7",  "fa0",  "fa1",  "fa2",  "fa3",
  "fa4",  "fa5",  "fa6",  "fa7",  "ft8",  "ft9",  "ft10", "ft11",
  "fs0",  "fs1",  "fs2",  "fs3",  "fs4",  "fs5",  "fs6",  "fs7"
};

static const char * const mips_cp0_names_numeric[32] =
{
  "$0",   "$1",   "$2",   "$3",   "$4",   "$5",   "$6",   "$7",
  "$8",   "$9",   "$10",  "$11",  "$12",  "$13",  "$14",  "$15",
  "$16",  "$17",  "$18",  "$19",  "$20",  "$21",  "$22",  "$23",
  "$24",  "$25",  "$26",  "$27",  "$28",  "$29",  "$30",  "$31"
};

static const char * const mips_cp0_names_r3000[32] =
{
  "c0_index",     "c0_random",    "c0_entrylo",   "$3",
  "c0_context",   "$5",           "$6",           "$7",
  "c0_badvaddr",  "$9",           "c0_entryhi",   "$11",
  "c0_sr",        "c0_cause",     "c0_epc",       "c0_prid",
  "$16",          "$17",          "$18",          "$19",
  "$20",          "$21",          "$22",          "$23",
  "$24",          "$25",          "$26",          "$27",
  "$28",          "$29",          "$30",          "$31",
};

static const char * const mips_cp0_names_r4000[32] =
{
  "c0_index",     "c0_random",    "c0_entrylo0",  "c0_entrylo1",
  "c0_context",   "c0_pagemask",  "c0_wired",     "$7",
  "c0_badvaddr",  "c0_count",     "c0_entryhi",   "c0_compare",
  "c0_sr",        "c0_cause",     "c0_epc",       "c0_prid",
  "c0_config",    "c0_lladdr",    "c0_watchlo",   "c0_watchhi",
  "c0_xcontext",  "$21",          "$22",          "$23",
  "$24",          "$25",          "c0_ecc",       "c0_cacheerr",
  "c0_taglo",     "c0_taghi",     "c0_errorepc",  "$31",
};

static const char * const mips_cp0_names_r5900[32] =
{
  "c0_index",     "c0_random",    "c0_entrylo0",  "c0_entrylo1",
  "c0_context",   "c0_pagemask",  "c0_wired",     "$7",
  "c0_badvaddr",  "c0_count",     "c0_entryhi",   "c0_compare",
  "c0_sr",        "c0_cause",     "c0_epc",       "c0_prid",
  "c0_config",    "$17",          "$18",          "$19",
  "$20",          "$21",          "$22",          "c0_badpaddr",
  "c0_depc",      "c0_perfcnt",   "$26",          "$27",
  "c0_taglo",     "c0_taghi",     "c0_errorepc",  "$31"
};

static const struct mips_cp0sel_name mips_cp0sel_names_mipsr5900[] =
{
  { 24, 2, "c0_iab"			},
  { 24, 3, "c0_iabm"		},
  { 24, 4, "c0_dab"			},
  { 24, 5, "c0_dabm"		},
  { 24, 6, "c0_dvb"			},
  { 24, 7, "c0_dvbm"		},
  { 25, 1, "c0_perfcnt,1"	},
  { 25, 2, "c0_perfcnt,2"	}
};

static const char * const mips_cp0_names_mips3264[32] =
{
  "c0_index",     "c0_random",    "c0_entrylo0",  "c0_entrylo1",
  "c0_context",   "c0_pagemask",  "c0_wired",     "$7",
  "c0_badvaddr",  "c0_count",     "c0_entryhi",   "c0_compare",
  "c0_status",    "c0_cause",     "c0_epc",       "c0_prid",
  "c0_config",    "c0_lladdr",    "c0_watchlo",   "c0_watchhi",
  "c0_xcontext",  "$21",          "$22",          "c0_debug",
  "c0_depc",      "c0_perfcnt",   "c0_errctl",    "c0_cacheerr",
  "c0_taglo",     "c0_taghi",     "c0_errorepc",  "c0_desave",
};

static const struct mips_cp0sel_name mips_cp0sel_names_mips3264[] =
{
  { 16, 1, "c0_config1"		},
  { 16, 2, "c0_config2"		},
  { 16, 3, "c0_config3"		},
  { 18, 1, "c0_watchlo,1"	},
  { 18, 2, "c0_watchlo,2"	},
  { 18, 3, "c0_watchlo,3"	},
  { 18, 4, "c0_watchlo,4"	},
  { 18, 5, "c0_watchlo,5"	},
  { 18, 6, "c0_watchlo,6"	},
  { 18, 7, "c0_watchlo,7"	},
  { 19, 1, "c0_watchhi,1"	},
  { 19, 2, "c0_watchhi,2"	},
  { 19, 3, "c0_watchhi,3"	},
  { 19, 4, "c0_watchhi,4"	},
  { 19, 5, "c0_watchhi,5"	},
  { 19, 6, "c0_watchhi,6"	},
  { 19, 7, "c0_watchhi,7"	},
  { 25, 1, "c0_perfcnt,1"	},
  { 25, 2, "c0_perfcnt,2"	},
  { 25, 3, "c0_perfcnt,3"	},
  { 25, 4, "c0_perfcnt,4"	},
  { 25, 5, "c0_perfcnt,5"	},
  { 25, 6, "c0_perfcnt,6"	},
  { 25, 7, "c0_perfcnt,7"	},
  { 27, 1, "c0_cacheerr,1"	},
  { 27, 2, "c0_cacheerr,2"	},
  { 27, 3, "c0_cacheerr,3"	},
  { 28, 1, "c0_datalo"		},
  { 29, 1, "c0_datahi"		}
};

static const char * const mips_cp0_names_mips3264r2[32] =
{
  "c0_index",     "c0_random",    "c0_entrylo0",  "c0_entrylo1",
  "c0_context",   "c0_pagemask",  "c0_wired",     "c0_hwrena",
  "c0_badvaddr",  "c0_count",     "c0_entryhi",   "c0_compare",
  "c0_status",    "c0_cause",     "c0_epc",       "c0_prid",
  "c0_config",    "c0_lladdr",    "c0_watchlo",   "c0_watchhi",
  "c0_xcontext",  "$21",          "$22",          "c0_debug",
  "c0_depc",      "c0_perfcnt",   "c0_errctl",    "c0_cacheerr",
  "c0_taglo",     "c0_taghi",     "c0_errorepc",  "c0_desave",
};

static const struct mips_cp0sel_name mips_cp0sel_names_mips3264r2[] =
{
  {  4, 1, "c0_contextconfig"	},
  {  0, 1, "c0_mvpcontrol"	},
  {  0, 2, "c0_mvpconf0"	},
  {  0, 3, "c0_mvpconf1"	},
  {  1, 1, "c0_vpecontrol"	},
  {  1, 2, "c0_vpeconf0"	},
  {  1, 3, "c0_vpeconf1"	},
  {  1, 4, "c0_yqmask"		},
  {  1, 5, "c0_vpeschedule"	},
  {  1, 6, "c0_vpeschefback"	},
  {  2, 1, "c0_tcstatus"	},
  {  2, 2, "c0_tcbind"		},
  {  2, 3, "c0_tcrestart"	},
  {  2, 4, "c0_tchalt"		},
  {  2, 5, "c0_tccontext"	},
  {  2, 6, "c0_tcschedule"	},
  {  2, 7, "c0_tcschefback"	},
  {  5, 1, "c0_pagegrain"	},
  {  6, 1, "c0_srsconf0"	},
  {  6, 2, "c0_srsconf1"	},
  {  6, 3, "c0_srsconf2"	},
  {  6, 4, "c0_srsconf3"	},
  {  6, 5, "c0_srsconf4"	},
  { 12, 1, "c0_intctl"		},
  { 12, 2, "c0_srsctl"		},
  { 12, 3, "c0_srsmap"		},
  { 15, 1, "c0_ebase"		},
  { 16, 1, "c0_config1"		},
  { 16, 2, "c0_config2"		},
  { 16, 3, "c0_config3"		},
  { 18, 1, "c0_watchlo,1"	},
  { 18, 2, "c0_watchlo,2"	},
  { 18, 3, "c0_watchlo,3"	},
  { 18, 4, "c0_watchlo,4"	},
  { 18, 5, "c0_watchlo,5"	},
  { 18, 6, "c0_watchlo,6"	},
  { 18, 7, "c0_watchlo,7"	},
  { 19, 1, "c0_watchhi,1"	},
  { 19, 2, "c0_watchhi,2"	},
  { 19, 3, "c0_watchhi,3"	},
  { 19, 4, "c0_watchhi,4"	},
  { 19, 5, "c0_watchhi,5"	},
  { 19, 6, "c0_watchhi,6"	},
  { 19, 7, "c0_watchhi,7"	},
  { 23, 1, "c0_tracecontrol"	},
  { 23, 2, "c0_tracecontrol2"	},
  { 23, 3, "c0_usertracedata"	},
  { 23, 4, "c0_tracebpc"	},
  { 25, 1, "c0_perfcnt,1"	},
  { 25, 2, "c0_perfcnt,2"	},
  { 25, 3, "c0_perfcnt,3"	},
  { 25, 4, "c0_perfcnt,4"	},
  { 25, 5, "c0_perfcnt,5"	},
  { 25, 6, "c0_perfcnt,6"	},
  { 25, 7, "c0_perfcnt,7"	},
  { 27, 1, "c0_cacheerr,1"	},
  { 27, 2, "c0_cacheerr,2"	},
  { 27, 3, "c0_cacheerr,3"	},
  { 28, 1, "c0_datalo"		},
  { 28, 2, "c0_taglo1"		},
  { 28, 3, "c0_datalo1"		},
  { 28, 4, "c0_taglo2"		},
  { 28, 5, "c0_datalo2"		},
  { 28, 6, "c0_taglo3"		},
  { 28, 7, "c0_datalo3"		},
  { 29, 1, "c0_datahi"		},
  { 29, 2, "c0_taghi1"		},
  { 29, 3, "c0_datahi1"		},
  { 29, 4, "c0_taghi2"		},
  { 29, 5, "c0_datahi2"		},
  { 29, 6, "c0_taghi3"		},
  { 29, 7, "c0_datahi3"		},
};

/* SB-1: MIPS64 (mips_cp0_names_mips3264) with minor mods.  */
static const char * const mips_cp0_names_sb1[32] =
{
  "c0_index",     "c0_random",    "c0_entrylo0",  "c0_entrylo1",
  "c0_context",   "c0_pagemask",  "c0_wired",     "$7",
  "c0_badvaddr",  "c0_count",     "c0_entryhi",   "c0_compare",
  "c0_status",    "c0_cause",     "c0_epc",       "c0_prid",
  "c0_config",    "c0_lladdr",    "c0_watchlo",   "c0_watchhi",
  "c0_xcontext",  "$21",          "$22",          "c0_debug",
  "c0_depc",      "c0_perfcnt",   "c0_errctl",    "c0_cacheerr_i",
  "c0_taglo_i",   "c0_taghi_i",   "c0_errorepc",  "c0_desave",
};

static const struct mips_cp0sel_name mips_cp0sel_names_sb1[] =
{
  { 16, 1, "c0_config1"		},
  { 18, 1, "c0_watchlo,1"	},
  { 19, 1, "c0_watchhi,1"	},
  { 22, 0, "c0_perftrace"	},
  { 23, 3, "c0_edebug"		},
  { 25, 1, "c0_perfcnt,1"	},
  { 25, 2, "c0_perfcnt,2"	},
  { 25, 3, "c0_perfcnt,3"	},
  { 25, 4, "c0_perfcnt,4"	},
  { 25, 5, "c0_perfcnt,5"	},
  { 25, 6, "c0_perfcnt,6"	},
  { 25, 7, "c0_perfcnt,7"	},
  { 26, 1, "c0_buserr_pa"	},
  { 27, 1, "c0_cacheerr_d"	},
  { 27, 3, "c0_cacheerr_d_pa"	},
  { 28, 1, "c0_datalo_i"	},
  { 28, 2, "c0_taglo_d"		},
  { 28, 3, "c0_datalo_d"	},
  { 29, 1, "c0_datahi_i"	},
  { 29, 2, "c0_taghi_d"		},
  { 29, 3, "c0_datahi_d"	},
};

/* Xlr cop0 register names.  */
static const char * const mips_cp0_names_xlr[32] = {
  "c0_index",     "c0_random",    "c0_entrylo0",  "c0_entrylo1",
  "c0_context",   "c0_pagemask",  "c0_wired",     "$7",
  "c0_badvaddr",  "c0_count",     "c0_entryhi",   "c0_compare",
  "c0_status",    "c0_cause",     "c0_epc",       "c0_prid",
  "c0_config",    "c0_lladdr",    "c0_watchlo",   "c0_watchhi",
  "c0_xcontext",  "$21",          "$22",          "c0_debug",
  "c0_depc",      "c0_perfcnt",   "c0_errctl",    "c0_cacheerr_i",
  "c0_taglo_i",   "c0_taghi_i",   "c0_errorepc",  "c0_desave",
};

/* XLR's CP0 Select Registers.  */

static const struct mips_cp0sel_name mips_cp0sel_names_xlr[] = {
  {  9, 6, "c0_extintreq"       },
  {  9, 7, "c0_extintmask"      },
  { 15, 1, "c0_ebase"           },
  { 16, 1, "c0_config1"         },
  { 16, 2, "c0_config2"         },
  { 16, 3, "c0_config3"         },
  { 16, 7, "c0_procid2"         },
  { 18, 1, "c0_watchlo,1"       },
  { 18, 2, "c0_watchlo,2"       },
  { 18, 3, "c0_watchlo,3"       },
  { 18, 4, "c0_watchlo,4"       },
  { 18, 5, "c0_watchlo,5"       },
  { 18, 6, "c0_watchlo,6"       },
  { 18, 7, "c0_watchlo,7"       },
  { 19, 1, "c0_watchhi,1"       },
  { 19, 2, "c0_watchhi,2"       },
  { 19, 3, "c0_watchhi,3"       },
  { 19, 4, "c0_watchhi,4"       },
  { 19, 5, "c0_watchhi,5"       },
  { 19, 6, "c0_watchhi,6"       },
  { 19, 7, "c0_watchhi,7"       },
  { 25, 1, "c0_perfcnt,1"       },
  { 25, 2, "c0_perfcnt,2"       },
  { 25, 3, "c0_perfcnt,3"       },
  { 25, 4, "c0_perfcnt,4"       },
  { 25, 5, "c0_perfcnt,5"       },
  { 25, 6, "c0_perfcnt,6"       },
  { 25, 7, "c0_perfcnt,7"       },
  { 27, 1, "c0_cacheerr,1"      },
  { 27, 2, "c0_cacheerr,2"      },
  { 27, 3, "c0_cacheerr,3"      },
  { 28, 1, "c0_datalo"          },
  { 29, 1, "c0_datahi"          }
};

static const char * const mips_hwr_names_numeric[32] =
{
  "$0",   "$1",   "$2",   "$3",   "$4",   "$5",   "$6",   "$7",
  "$8",   "$9",   "$10",  "$11",  "$12",  "$13",  "$14",  "$15",
  "$16",  "$17",  "$18",  "$19",  "$20",  "$21",  "$22",  "$23",
  "$24",  "$25",  "$26",  "$27",  "$28",  "$29",  "$30",  "$31"
};

static const char * const mips_hwr_names_mips3264r2[32] =
{
  "hwr_cpunum",   "hwr_synci_step", "hwr_cc",     "hwr_ccres",
  "$4",          "$5",            "$6",           "$7",
  "$8",   "$9",   "$10",  "$11",  "$12",  "$13",  "$14",  "$15",
  "$16",  "$17",  "$18",  "$19",  "$20",  "$21",  "$22",  "$23",
  "$24",  "$25",  "$26",  "$27",  "$28",  "$29",  "$30",  "$31"
};

static const char * const msa_control_names[32] =
{
  "msa_ir",	"msa_csr",	"msa_access",	"msa_save",
  "msa_modify",	"msa_request",	"msa_map",	"msa_unmap",
  "$8",   "$9",   "$10",  "$11",  "$12",  "$13",  "$14",  "$15",
  "$16",  "$17",  "$18",  "$19",  "$20",  "$21",  "$22",  "$23",
  "$24",  "$25",  "$26",  "$27",  "$28",  "$29",  "$30",  "$31"
};

struct mips_abi_choice
{
  const char * name;
  const char * const *gpr_names;
  const char * const *fpr_names;
};

struct mips_abi_choice mips_abi_choices[] =
{
  { "numeric", mips_gpr_names_numeric, mips_fpr_names_numeric },
  { "32", mips_gpr_names_oldabi, mips_fpr_names_32 },
  { "n32", mips_gpr_names_newabi, mips_fpr_names_n32 },
  { "64", mips_gpr_names_newabi, mips_fpr_names_64 },
};

struct mips_arch_choice
{
  const char *name;
  int bfd_mach_valid;
  unsigned long bfd_mach;
  int processor;
  int isa;
  int ase;
  const char * const *cp0_names;
  const struct mips_cp0sel_name *cp0sel_names;
  unsigned int cp0sel_names_len;
  const char * const *hwr_names;
};

const struct mips_arch_choice mips_arch_choices[] =
{
  { "numeric",	0, 0, 0, 0, 0,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },

  { "r3000",	1, bfd_mach_mips3000, CPU_R3000, ISA_MIPS1, 0,
    mips_cp0_names_r3000, NULL, 0, mips_hwr_names_numeric },
  { "r3900",	1, bfd_mach_mips3900, CPU_R3900, ISA_MIPS1, 0,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r4000",	1, bfd_mach_mips4000, CPU_R4000, ISA_MIPS3, 0,
    mips_cp0_names_r4000, NULL, 0, mips_hwr_names_numeric },
  { "r4010",	1, bfd_mach_mips4010, CPU_R4010, ISA_MIPS2, 0,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "vr4100",	1, bfd_mach_mips4100, CPU_VR4100, ISA_MIPS3, 0,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "vr4111",	1, bfd_mach_mips4111, CPU_R4111, ISA_MIPS3, 0,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "vr4120",	1, bfd_mach_mips4120, CPU_VR4120, ISA_MIPS3, 0,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r4300",	1, bfd_mach_mips4300, CPU_R4300, ISA_MIPS3, 0,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r4400",	1, bfd_mach_mips4400, CPU_R4400, ISA_MIPS3, 0,
    mips_cp0_names_r4000, NULL, 0, mips_hwr_names_numeric },
  { "r4600",	1, bfd_mach_mips4600, CPU_R4600, ISA_MIPS3, 0,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r4650",	1, bfd_mach_mips4650, CPU_R4650, ISA_MIPS3, 0,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r5000",	1, bfd_mach_mips5000, CPU_R5000, ISA_MIPS4, 0,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "vr5400",	1, bfd_mach_mips5400, CPU_VR5400, ISA_MIPS4, 0,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "vr5500",	1, bfd_mach_mips5500, CPU_VR5500, ISA_MIPS4, 0,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r5900",	1, bfd_mach_mips5900, CPU_R5900, ISA_MIPS3, 0,
    mips_cp0_names_r5900, NULL, 0, mips_hwr_names_numeric },
  { "r6000",	1, bfd_mach_mips6000, CPU_R6000, ISA_MIPS2, 0,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "rm7000",	1, bfd_mach_mips7000, CPU_RM7000, ISA_MIPS4, 0,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "rm9000",	1, bfd_mach_mips7000, CPU_RM7000, ISA_MIPS4, 0,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r8000",	1, bfd_mach_mips8000, CPU_R8000, ISA_MIPS4, 0,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r10000",	1, bfd_mach_mips10000, CPU_R10000, ISA_MIPS4, 0,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r12000",	1, bfd_mach_mips12000, CPU_R12000, ISA_MIPS4, 0,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r14000",	1, bfd_mach_mips14000, CPU_R14000, ISA_MIPS4, 0,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r16000",	1, bfd_mach_mips16000, CPU_R16000, ISA_MIPS4, 0,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "mips5",	1, bfd_mach_mips5, CPU_MIPS5, ISA_MIPS5, 0,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },

  /* For stock MIPS32, disassemble all applicable MIPS-specified ASEs.
     Note that MIPS-3D and MDMX are not applicable to MIPS32.  (See
     _MIPS32 Architecture For Programmers Volume I: Introduction to the
     MIPS32 Architecture_ (MIPS Document Number MD00082, Revision 0.95),
     page 1.  */
  { "mips32",	1, bfd_mach_mipsisa32, CPU_MIPS32,
    ISA_MIPS32,  ASE_SMARTMIPS,
    mips_cp0_names_mips3264,
    mips_cp0sel_names_mips3264, ARRAY_SIZE (mips_cp0sel_names_mips3264),
    mips_hwr_names_numeric },

  { "mips32r2",	1, bfd_mach_mipsisa32r2, CPU_MIPS32R2,
    ISA_MIPS32R2,
    (ASE_SMARTMIPS | ASE_DSP | ASE_DSPR2 | ASE_EVA | ASE_MIPS3D
     | ASE_MT | ASE_MCU | ASE_VIRT | ASE_MSA),
    mips_cp0_names_mips3264r2,
    mips_cp0sel_names_mips3264r2, ARRAY_SIZE (mips_cp0sel_names_mips3264r2),
    mips_hwr_names_mips3264r2 },

  /* For stock MIPS64, disassemble all applicable MIPS-specified ASEs.  */
  { "mips64",	1, bfd_mach_mipsisa64, CPU_MIPS64,
    ISA_MIPS64,  ASE_MIPS3D | ASE_MDMX,
    mips_cp0_names_mips3264,
    mips_cp0sel_names_mips3264, ARRAY_SIZE (mips_cp0sel_names_mips3264),
    mips_hwr_names_numeric },

  { "mips64r2",	1, bfd_mach_mipsisa64r2, CPU_MIPS64R2,
    ISA_MIPS64R2,
    (ASE_MIPS3D | ASE_DSP | ASE_DSPR2 | ASE_DSP64 | ASE_EVA | ASE_MT
     | ASE_MCU | ASE_VIRT | ASE_VIRT64 | ASE_MSA | ASE_MSA64),
    mips_cp0_names_mips3264r2,
    mips_cp0sel_names_mips3264r2, ARRAY_SIZE (mips_cp0sel_names_mips3264r2),
    mips_hwr_names_mips3264r2 },

  { "sb1",	1, bfd_mach_mips_sb1, CPU_SB1,
    ISA_MIPS64 | INSN_SB1,  ASE_MIPS3D,
    mips_cp0_names_sb1,
    mips_cp0sel_names_sb1, ARRAY_SIZE (mips_cp0sel_names_sb1),
    mips_hwr_names_numeric },

  { "loongson2e",   1, bfd_mach_mips_loongson_2e, CPU_LOONGSON_2E,
    ISA_MIPS3 | INSN_LOONGSON_2E, 0, mips_cp0_names_numeric,
    NULL, 0, mips_hwr_names_numeric },

  { "loongson2f",   1, bfd_mach_mips_loongson_2f, CPU_LOONGSON_2F,
    ISA_MIPS3 | INSN_LOONGSON_2F, 0, mips_cp0_names_numeric,
    NULL, 0, mips_hwr_names_numeric },

  { "loongson3a",   1, bfd_mach_mips_loongson_3a, CPU_LOONGSON_3A,
    ISA_MIPS64 | INSN_LOONGSON_3A, 0, mips_cp0_names_numeric,
    NULL, 0, mips_hwr_names_numeric },

  { "octeon",   1, bfd_mach_mips_octeon, CPU_OCTEON,
    ISA_MIPS64R2 | INSN_OCTEON, 0, mips_cp0_names_numeric, NULL, 0,
    mips_hwr_names_numeric },

  { "octeon+",   1, bfd_mach_mips_octeonp, CPU_OCTEONP,
    ISA_MIPS64R2 | INSN_OCTEONP, 0, mips_cp0_names_numeric,
    NULL, 0, mips_hwr_names_numeric },

  { "octeon2",   1, bfd_mach_mips_octeon2, CPU_OCTEON2,
    ISA_MIPS64R2 | INSN_OCTEON2, 0, mips_cp0_names_numeric,
    NULL, 0, mips_hwr_names_numeric },

  { "xlr", 1, bfd_mach_mips_xlr, CPU_XLR,
    ISA_MIPS64 | INSN_XLR, 0,
    mips_cp0_names_xlr,
    mips_cp0sel_names_xlr, ARRAY_SIZE (mips_cp0sel_names_xlr),
    mips_hwr_names_numeric },

  /* XLP is mostly like XLR, with the prominent exception it is being
     MIPS64R2.  */
  { "xlp", 1, bfd_mach_mips_xlr, CPU_XLR,
    ISA_MIPS64R2 | INSN_XLR, 0,
    mips_cp0_names_xlr,
    mips_cp0sel_names_xlr, ARRAY_SIZE (mips_cp0sel_names_xlr),
    mips_hwr_names_numeric },

  /* This entry, mips16, is here only for ISA/processor selection; do
     not print its name.  */
  { "",		1, bfd_mach_mips16, CPU_MIPS16, ISA_MIPS3, 0,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
};

/* ISA and processor type to disassemble for, and register names to use.
   set_default_mips_dis_options and parse_mips_dis_options fill in these
   values.  */
static int mips_processor;
static int mips_isa;
static int mips_ase;
static int micromips_ase;
static const char * const *mips_gpr_names;
static const char * const *mips_fpr_names;
static const char * const *mips_cp0_names;
static const struct mips_cp0sel_name *mips_cp0sel_names;
static int mips_cp0sel_names_len;
static const char * const *mips_hwr_names;

/* Other options */
static int no_aliases;	/* If set disassemble as most general inst.  */

static const struct mips_abi_choice *
choose_abi_by_name (const char *name, unsigned int namelen)
{
  const struct mips_abi_choice *c;
  unsigned int i;

  for (i = 0, c = NULL; i < ARRAY_SIZE (mips_abi_choices) && c == NULL; i++)
    if (strncmp (mips_abi_choices[i].name, name, namelen) == 0
	&& strlen (mips_abi_choices[i].name) == namelen)
      c = &mips_abi_choices[i];

  return c;
}

static const struct mips_arch_choice *
choose_arch_by_name (const char *name, unsigned int namelen)
{
  const struct mips_arch_choice *c = NULL;
  unsigned int i;

  for (i = 0, c = NULL; i < ARRAY_SIZE (mips_arch_choices) && c == NULL; i++)
    if (strncmp (mips_arch_choices[i].name, name, namelen) == 0
	&& strlen (mips_arch_choices[i].name) == namelen)
      c = &mips_arch_choices[i];

  return c;
}

static const struct mips_arch_choice *
choose_arch_by_number (unsigned long mach)
{
  static unsigned long hint_bfd_mach;
  static const struct mips_arch_choice *hint_arch_choice;
  const struct mips_arch_choice *c;
  unsigned int i;

  /* We optimize this because even if the user specifies no
     flags, this will be done for every instruction!  */
  if (hint_bfd_mach == mach
      && hint_arch_choice != NULL
      && hint_arch_choice->bfd_mach == hint_bfd_mach)
    return hint_arch_choice;

  for (i = 0, c = NULL; i < ARRAY_SIZE (mips_arch_choices) && c == NULL; i++)
    {
      if (mips_arch_choices[i].bfd_mach_valid
	  && mips_arch_choices[i].bfd_mach == mach)
	{
	  c = &mips_arch_choices[i];
	  hint_bfd_mach = mach;
	  hint_arch_choice = c;
	}
    }
  return c;
}

/* Check if the object uses NewABI conventions.  */

static int
is_newabi (Elf_Internal_Ehdr *header)
{
  /* There are no old-style ABIs which use 64-bit ELF.  */
  if (header->e_ident[EI_CLASS] == ELFCLASS64)
    return 1;

  /* If a 32-bit ELF file, n32 is a new-style ABI.  */
  if ((header->e_flags & EF_MIPS_ABI2) != 0)
    return 1;

  return 0;
}

/* Check if the object has microMIPS ASE code.  */

static int
is_micromips (Elf_Internal_Ehdr *header)
{
  if ((header->e_flags & EF_MIPS_ARCH_ASE_MICROMIPS) != 0)
    return 1;

  return 0;
}

static void
set_default_mips_dis_options (struct disassemble_info *info)
{
  const struct mips_arch_choice *chosen_arch;

  /* Defaults: mipsIII/r3000 (?!), no microMIPS ASE (any compressed code
     is MIPS16 ASE) (o)32-style ("oldabi") GPR names, and numeric FPR,
     CP0 register, and HWR names.  */
  mips_isa = ISA_MIPS3;
  mips_processor = CPU_R3000;
  micromips_ase = 0;
  mips_ase = 0;
  mips_gpr_names = mips_gpr_names_oldabi;
  mips_fpr_names = mips_fpr_names_numeric;
  mips_cp0_names = mips_cp0_names_numeric;
  mips_cp0sel_names = NULL;
  mips_cp0sel_names_len = 0;
  mips_hwr_names = mips_hwr_names_numeric;
  no_aliases = 0;

  /* Update settings according to the ELF file header flags.  */
  if (info->flavour == bfd_target_elf_flavour && info->section != NULL)
    {
      Elf_Internal_Ehdr *header;

      header = elf_elfheader (info->section->owner);
      /* If an ELF "newabi" binary, use the n32/(n)64 GPR names.  */
      if (is_newabi (header))
	mips_gpr_names = mips_gpr_names_newabi;
      /* If a microMIPS binary, then don't use MIPS16 bindings.  */
      micromips_ase = is_micromips (header);
    }

  /* Set ISA, architecture, and cp0 register names as best we can.  */
#if ! SYMTAB_AVAILABLE
  /* This is running out on a target machine, not in a host tool.
     FIXME: Where does mips_target_info come from?  */
  target_processor = mips_target_info.processor;
  mips_isa = mips_target_info.isa;
  mips_ase = mips_target_info.ase;
#else
  chosen_arch = choose_arch_by_number (info->mach);
  if (chosen_arch != NULL)
    {
      mips_processor = chosen_arch->processor;
      mips_isa = chosen_arch->isa;
      mips_ase = chosen_arch->ase;
      mips_cp0_names = chosen_arch->cp0_names;
      mips_cp0sel_names = chosen_arch->cp0sel_names;
      mips_cp0sel_names_len = chosen_arch->cp0sel_names_len;
      mips_hwr_names = chosen_arch->hwr_names;
    }
#endif
}

static void
parse_mips_dis_option (const char *option, unsigned int len)
{
  unsigned int i, optionlen, vallen;
  const char *val;
  const struct mips_abi_choice *chosen_abi;
  const struct mips_arch_choice *chosen_arch;

  /* Try to match options that are simple flags */
  if (CONST_STRNEQ (option, "no-aliases"))
    {
      no_aliases = 1;
      return;
    }

  if (CONST_STRNEQ (option, "msa"))
    {
      mips_ase |= ASE_MSA;
      if ((mips_isa & INSN_ISA_MASK) == ISA_MIPS64R2)
	  mips_ase |= ASE_MSA64;
      return;
    }

  if (CONST_STRNEQ (option, "virt"))
    {
      mips_ase |= ASE_VIRT;
      if (mips_isa & ISA_MIPS64R2)
	mips_ase |= ASE_VIRT64;
      return;
    }
  
  /* Look for the = that delimits the end of the option name.  */
  for (i = 0; i < len; i++)
    if (option[i] == '=')
      break;

  if (i == 0)		/* Invalid option: no name before '='.  */
    return;
  if (i == len)		/* Invalid option: no '='.  */
    return;
  if (i == (len - 1))	/* Invalid option: no value after '='.  */
    return;

  optionlen = i;
  val = option + (optionlen + 1);
  vallen = len - (optionlen + 1);

  if (strncmp ("gpr-names", option, optionlen) == 0
      && strlen ("gpr-names") == optionlen)
    {
      chosen_abi = choose_abi_by_name (val, vallen);
      if (chosen_abi != NULL)
	mips_gpr_names = chosen_abi->gpr_names;
      return;
    }

  if (strncmp ("fpr-names", option, optionlen) == 0
      && strlen ("fpr-names") == optionlen)
    {
      chosen_abi = choose_abi_by_name (val, vallen);
      if (chosen_abi != NULL)
	mips_fpr_names = chosen_abi->fpr_names;
      return;
    }

  if (strncmp ("cp0-names", option, optionlen) == 0
      && strlen ("cp0-names") == optionlen)
    {
      chosen_arch = choose_arch_by_name (val, vallen);
      if (chosen_arch != NULL)
	{
	  mips_cp0_names = chosen_arch->cp0_names;
	  mips_cp0sel_names = chosen_arch->cp0sel_names;
	  mips_cp0sel_names_len = chosen_arch->cp0sel_names_len;
	}
      return;
    }

  if (strncmp ("hwr-names", option, optionlen) == 0
      && strlen ("hwr-names") == optionlen)
    {
      chosen_arch = choose_arch_by_name (val, vallen);
      if (chosen_arch != NULL)
	mips_hwr_names = chosen_arch->hwr_names;
      return;
    }

  if (strncmp ("reg-names", option, optionlen) == 0
      && strlen ("reg-names") == optionlen)
    {
      /* We check both ABI and ARCH here unconditionally, so
	 that "numeric" will do the desirable thing: select
	 numeric register names for all registers.  Other than
	 that, a given name probably won't match both.  */
      chosen_abi = choose_abi_by_name (val, vallen);
      if (chosen_abi != NULL)
	{
	  mips_gpr_names = chosen_abi->gpr_names;
	  mips_fpr_names = chosen_abi->fpr_names;
	}
      chosen_arch = choose_arch_by_name (val, vallen);
      if (chosen_arch != NULL)
	{
	  mips_cp0_names = chosen_arch->cp0_names;
	  mips_cp0sel_names = chosen_arch->cp0sel_names;
	  mips_cp0sel_names_len = chosen_arch->cp0sel_names_len;
	  mips_hwr_names = chosen_arch->hwr_names;
	}
      return;
    }

  /* Invalid option.  */
}

static void
parse_mips_dis_options (const char *options)
{
  const char *option_end;

  if (options == NULL)
    return;

  while (*options != '\0')
    {
      /* Skip empty options.  */
      if (*options == ',')
	{
	  options++;
	  continue;
	}

      /* We know that *options is neither NUL or a comma.  */
      option_end = options + 1;
      while (*option_end != ',' && *option_end != '\0')
	option_end++;

      parse_mips_dis_option (options, option_end - options);

      /* Go on to the next one.  If option_end points to a comma, it
	 will be skipped above.  */
      options = option_end;
    }
}

static const struct mips_cp0sel_name *
lookup_mips_cp0sel_name (const struct mips_cp0sel_name *names,
			 unsigned int len,
			 unsigned int cp0reg,
			 unsigned int sel)
{
  unsigned int i;

  for (i = 0; i < len; i++)
    if (names[i].cp0reg == cp0reg && names[i].sel == sel)
      return &names[i];
  return NULL;
}

/* Print register REGNO, of type TYPE, for instruction OPCODE.  */

static void
print_reg (struct disassemble_info *info, const struct mips_opcode *opcode,
	   enum mips_reg_operand_type type, int regno)
{
  switch (type)
    {
    case OP_REG_GP:
      info->fprintf_func (info->stream, "%s", mips_gpr_names[regno]);
      break;

    case OP_REG_FP:
      info->fprintf_func (info->stream, "%s", mips_fpr_names[regno]);
      break;

    case OP_REG_CCC:
      if (opcode->pinfo & (FP_D | FP_S))
	info->fprintf_func (info->stream, "$fcc%d", regno);
      else
	info->fprintf_func (info->stream, "$cc%d", regno);
      break;

    case OP_REG_VEC:
      if (opcode->membership & INSN_5400)
	info->fprintf_func (info->stream, "$f%d", regno);
      else
	info->fprintf_func (info->stream, "$v%d", regno);
      break;

    case OP_REG_ACC:
      info->fprintf_func (info->stream, "$ac%d", regno);
      break;

    case OP_REG_COPRO:
      if (opcode->name[strlen (opcode->name) - 1] == '0')
	info->fprintf_func (info->stream, "%s", mips_cp0_names[regno]);
      else
	info->fprintf_func (info->stream, "$%d", regno);
      break;

    case OP_REG_HW:
      info->fprintf_func (info->stream, "%s", mips_hwr_names[regno]);
      break;

    case OP_REG_VF:
      info->fprintf_func (info->stream, "$vf%d", regno);
      break;

    case OP_REG_VI:
      info->fprintf_func (info->stream, "$vi%d", regno);
      break;

    case OP_REG_R5900_I:
      info->fprintf_func (info->stream, "$I");
      break;

    case OP_REG_R5900_Q:
      info->fprintf_func (info->stream, "$Q");
      break;

    case OP_REG_R5900_R:
      info->fprintf_func (info->stream, "$R");
      break;

    case OP_REG_R5900_ACC:
      info->fprintf_func (info->stream, "$ACC");
      break;

    case OP_REG_MSA:
      info->fprintf_func (info->stream, "$w%d", regno);
      break;

    case OP_REG_MSA_CTRL:
      info->fprintf_func (info->stream, "%s", msa_control_names[regno]);
      break;

    }
}

/* Used to track the state carried over from previous operands in
   an instruction.  */
struct mips_print_arg_state {
  /* The value of the last OP_INT seen.  We only use this for OP_MSB,
     where the value is known to be unsigned and small.  */
  unsigned int last_int;

  /* The type and number of the last OP_REG seen.  We only use this for
     OP_REPEAT_DEST_REG and OP_REPEAT_PREV_REG.  */
  enum mips_reg_operand_type last_reg_type;
  unsigned int last_regno;
};

/* Initialize STATE for the start of an instruction.  */

static inline void
init_print_arg_state (struct mips_print_arg_state *state)
{
  memset (state, 0, sizeof (*state));
}

/* Print OP_VU0_SUFFIX or OP_VU0_MATCH_SUFFIX operand OPERAND,
   whose value is given by UVAL.  */

static void
print_vu0_channel (struct disassemble_info *info,
		   const struct mips_operand *operand, unsigned int uval)
{
  if (operand->size == 4)
    info->fprintf_func (info->stream, "%s%s%s%s",
			uval & 8 ? "x" : "",
			uval & 4 ? "y" : "",
			uval & 2 ? "z" : "",
			uval & 1 ? "w" : "");
  else if (operand->size == 2)
    info->fprintf_func (info->stream, "%c", "xyzw"[uval]);
  else
    abort ();
}

/* Print operand OPERAND of OPCODE, using STATE to track inter-operand state.
   UVAL is the encoding of the operand (shifted into bit 0) and BASE_PC is
   the base address for OP_PCREL operands.  */

static void
print_insn_arg (struct disassemble_info *info,
		struct mips_print_arg_state *state,
		const struct mips_opcode *opcode,
		const struct mips_operand *operand,
		bfd_vma base_pc,
		unsigned int uval)
{
  const fprintf_ftype infprintf = info->fprintf_func;
  void *is = info->stream;

  switch (operand->type)
    {
    case OP_INT:
      {
	const struct mips_int_operand *int_op;

	int_op = (const struct mips_int_operand *) operand;
	uval = mips_decode_int_operand (int_op, uval);
	state->last_int = uval;
	if (int_op->print_hex)
	  infprintf (is, "0x%x", uval);
	else
	  infprintf (is, "%d", uval);
      }
      break;

    case OP_MAPPED_INT:
      {
	const struct mips_mapped_int_operand *mint_op;

	mint_op = (const struct mips_mapped_int_operand *) operand;
	uval = mint_op->int_map[uval];
	state->last_int = uval;
	if (mint_op->print_hex)
	  infprintf (is, "0x%x", uval);
	else
	  infprintf (is, "%d", uval);
      }
      break;

    case OP_MSB:
      {
	const struct mips_msb_operand *msb_op;

	msb_op = (const struct mips_msb_operand *) operand;
	uval += msb_op->bias;
	if (msb_op->add_lsb)
	  uval -= state->last_int;
	infprintf (is, "0x%x", uval);
      }
      break;

    case OP_REG:
    case OP_OPTIONAL_REG:
      {
	const struct mips_reg_operand *reg_op;

	reg_op = (const struct mips_reg_operand *) operand;
	uval = mips_decode_reg_operand (reg_op, uval);
	print_reg (info, opcode, reg_op->reg_type, uval);

	state->last_reg_type = reg_op->reg_type;
	state->last_regno = uval;
      }
      break;

    case OP_REG_PAIR:
      {
	const struct mips_reg_pair_operand *pair_op;

	pair_op = (const struct mips_reg_pair_operand *) operand;
	print_reg (info, opcode, pair_op->reg_type,
		   pair_op->reg1_map[uval]);
	infprintf (is, ",");
	print_reg (info, opcode, pair_op->reg_type,
		   pair_op->reg2_map[uval]);
      }
      break;

    case OP_PCREL:
      {
	const struct mips_pcrel_operand *pcrel_op;

	pcrel_op = (const struct mips_pcrel_operand *) operand;
	info->target = mips_decode_pcrel_operand (pcrel_op, base_pc, uval);

	/* Preserve the ISA bit for the GDB disassembler,
	   otherwise clear it.  */
	if (info->flavour != bfd_target_unknown_flavour)
	  info->target &= -2;

	(*info->print_address_func) (info->target, info);
      }
      break;

    case OP_PERF_REG:
      infprintf (is, "%d", uval);
      break;

    case OP_ADDIUSP_INT:
      {
	int sval;

	sval = mips_signed_operand (operand, uval) * 4;
	if (sval >= -8 && sval < 8)
	  sval ^= 0x400;
	infprintf (is, "%d", sval);
	break;
      }

    case OP_CLO_CLZ_DEST:
      {
	unsigned int reg1, reg2;

	reg1 = uval & 31;
	reg2 = uval >> 5;
	/* If one is zero use the other.  */
	if (reg1 == reg2 || reg2 == 0)
	  infprintf (is, "%s", mips_gpr_names[reg1]);
	else if (reg1 == 0)
	  infprintf (is, "%s", mips_gpr_names[reg2]);
	else
	  /* Bogus, result depends on processor.  */
	  infprintf (is, "%s or %s", mips_gpr_names[reg1],
		     mips_gpr_names[reg2]);
      }
      break;

    case OP_LWM_SWM_LIST:
      if (operand->size == 2)
	{
	  if (uval == 0)
	    infprintf (is, "%s,%s",
		       mips_gpr_names[16],
		       mips_gpr_names[31]);
	  else
	    infprintf (is, "%s-%s,%s",
		       mips_gpr_names[16],
		       mips_gpr_names[16 + uval],
		       mips_gpr_names[31]);
	}
      else
	{
	  int s_reg_encode;

	  s_reg_encode = uval & 0xf;
	  if (s_reg_encode != 0)
	    {
	      if (s_reg_encode == 1)
		infprintf (is, "%s", mips_gpr_names[16]);
	      else if (s_reg_encode < 9)
		infprintf (is, "%s-%s",
			   mips_gpr_names[16],
			   mips_gpr_names[15 + s_reg_encode]);
	      else if (s_reg_encode == 9)
		infprintf (is, "%s-%s,%s",
			   mips_gpr_names[16],
			   mips_gpr_names[23],
			   mips_gpr_names[30]);
	      else
		infprintf (is, "UNKNOWN");
	    }

	  if (uval & 0x10) /* For ra.  */
	    {
	      if (s_reg_encode == 0)
		infprintf (is, "%s", mips_gpr_names[31]);
	      else
		infprintf (is, ",%s", mips_gpr_names[31]);
	    }
	}
      break;

    case OP_ENTRY_EXIT_LIST:
      {
	const char *sep;
	unsigned int amask, smask;

	sep = "";
	amask = (uval >> 3) & 7;
	if (amask > 0 && amask < 5)
	  {
	    infprintf (is, "%s", mips_gpr_names[4]);
	    if (amask > 1)
	      infprintf (is, "-%s", mips_gpr_names[amask + 3]);
	    sep = ",";
	  }

	smask = (uval >> 1) & 3;
	if (smask == 3)
	  {
	    infprintf (is, "%s??", sep);
	    sep = ",";
	  }
	else if (smask > 0)
	  {
	    infprintf (is, "%s%s", sep, mips_gpr_names[16]);
	    if (smask > 1)
	      infprintf (is, "-%s", mips_gpr_names[smask + 15]);
	    sep = ",";
	  }

	if (uval & 1)
	  {
	    infprintf (is, "%s%s", sep, mips_gpr_names[31]);
	    sep = ",";
	  }

	if (amask == 5 || amask == 6)
	  {
	    infprintf (is, "%s%s", sep, mips_fpr_names[0]);
	    if (amask == 6)
	      infprintf (is, "-%s", mips_fpr_names[1]);
	  }
      }
      break;

    case OP_SAVE_RESTORE_LIST:
      /* Should be handled by the caller due to extend behavior.  */
      abort ();

    case OP_MDMX_IMM_REG:
      {
	unsigned int vsel;

	vsel = uval >> 5;
	uval &= 31;
	if ((vsel & 0x10) == 0)
	  {
	    int fmt;

	    vsel &= 0x0f;
	    for (fmt = 0; fmt < 3; fmt++, vsel >>= 1)
	      if ((vsel & 1) == 0)
		break;
	    print_reg (info, opcode, OP_REG_VEC, uval);
	    infprintf (is, "[%d]", vsel >> 1);
	  }
	else if ((vsel & 0x08) == 0)
	  print_reg (info, opcode, OP_REG_VEC, uval);
	else
	  infprintf (is, "0x%x", uval);
      }
      break;

    case OP_REPEAT_PREV_REG:
      print_reg (info, opcode, state->last_reg_type, state->last_regno);
      break;

    case OP_REPEAT_DEST_REG:
      /* Should always match OP_REPEAT_PREV_REG first.  */
      abort ();

    case OP_PC:
      infprintf (is, "$pc");
      break;

    case OP_VU0_SUFFIX:
    case OP_VU0_MATCH_SUFFIX:
      print_vu0_channel (info, operand, uval);
      break;

    case OP_IMM_INDEX:
      infprintf (is, "[%d]", uval);
      break;

    case OP_REG_INDEX:
      infprintf (is, "[");
      print_reg (info, opcode, OP_REG_GP, uval);
      infprintf (is, "]");
      break;
    }
}

/* Print the arguments for INSN, which is described by OPCODE.
   Use DECODE_OPERAND to get the encoding of each operand.  Use BASE_PC
   as the base of OP_PCREL operands.  */

static void
print_insn_args (struct disassemble_info *info,
		 const struct mips_opcode *opcode,
		 const struct mips_operand *(*decode_operand) (const char *),
		 unsigned int insn, bfd_vma base_pc)
{
  const fprintf_ftype infprintf = info->fprintf_func;
  void *is = info->stream;
  struct mips_print_arg_state state;
  const struct mips_operand *operand;
  const char *s;

  init_print_arg_state (&state);
  for (s = opcode->args; *s; ++s)
    {
      switch (*s)
	{
	case ',':
	case '(':
	case ')':
	  infprintf (is, "%c", *s);
	  break;

	case '#':
	  ++s;
	  infprintf (is, "%c%c", *s, *s);
	  break;

	default:
	  operand = decode_operand (s);
	  if (!operand)
	    {
	      /* xgettext:c-format */
	      infprintf (is,
			 _("# internal error, undefined operand in `%s %s'"),
			 opcode->name, opcode->args);
	      return;
	    }
	  if (operand->type == OP_REG
	      && s[1] == ','
	      && s[2] == 'H'
	      && opcode->name[strlen (opcode->name) - 1] == '0')
	    {
	      /* Coprocessor register 0 with sel field (MT ASE).  */
	      const struct mips_cp0sel_name *n;
	      unsigned int reg, sel;

	      reg = mips_extract_operand (operand, insn);
	      s += 2;
	      operand = decode_operand (s);
	      sel = mips_extract_operand (operand, insn);

	      /* CP0 register including 'sel' code for mftc0, to be
		 printed textually if known.  If not known, print both
		 CP0 register name and sel numerically since CP0 register
		 with sel 0 may have a name unrelated to register being
		 printed.  */
	      n = lookup_mips_cp0sel_name (mips_cp0sel_names,
					   mips_cp0sel_names_len,
					   reg, sel);
	      if (n != NULL)
		infprintf (is, "%s", n->name);
	      else
		infprintf (is, "$%d,%d", reg, sel);
	    }
	  else
	    print_insn_arg (info, &state, opcode, operand, base_pc,
			    mips_extract_operand (operand, insn));
	  if (*s == 'm' || *s == '+')
	    ++s;
	  break;
	}
    }
}

/* Print the mips instruction at address MEMADDR in debugged memory,
   on using INFO.  Returns length of the instruction, in bytes, which is
   always INSNLEN.  BIGENDIAN must be 1 if this is big-endian code, 0 if
   this is little-endian code.  */

static int
print_insn_mips (bfd_vma memaddr,
		 int word,
		 struct disassemble_info *info)
{
#define GET_OP(insn, field)			\
  (((insn) >> OP_SH_##field) & OP_MASK_##field)
  static const struct mips_opcode *mips_hash[OP_MASK_OP + 1];
  const fprintf_ftype infprintf = info->fprintf_func;
  const struct mips_opcode *op;
  static bfd_boolean init = 0;
  void *is = info->stream;

  /* Build a hash table to shorten the search time.  */
  if (! init)
    {
      unsigned int i;

      for (i = 0; i <= OP_MASK_OP; i++)
	{
	  for (op = mips_opcodes; op < &mips_opcodes[NUMOPCODES]; op++)
	    {
	      if (op->pinfo == INSN_MACRO
		  || (no_aliases && (op->pinfo2 & INSN2_ALIAS)))
		continue;
	      if (i == GET_OP (op->match, OP))
		{
		  mips_hash[i] = op;
		  break;
		}
	    }
	}

      init = 1;
    }

  info->bytes_per_chunk = INSNLEN;
  info->display_endian = info->endian;
  info->insn_info_valid = 1;
  info->branch_delay_insns = 0;
  info->data_size = 0;
  info->insn_type = dis_nonbranch;
  info->target = 0;
  info->target2 = 0;

  op = mips_hash[GET_OP (word, OP)];
  if (op != NULL)
    {
      for (; op < &mips_opcodes[NUMOPCODES]; op++)
	{
	  if (op->pinfo != INSN_MACRO 
	      && !(no_aliases && (op->pinfo2 & INSN2_ALIAS))
	      && (word & op->mask) == op->match)
	    {
	      /* We always allow to disassemble the jalx instruction.  */
	      if (!opcode_is_member (op, mips_isa, mips_ase, mips_processor)
		  && strcmp (op->name, "jalx"))
		continue;

	      /* Figure out instruction type and branch delay information.  */
	      if ((op->pinfo & INSN_UNCOND_BRANCH_DELAY) != 0)
	        {
		  if ((op->pinfo & (INSN_WRITE_GPR_31 | INSN_WRITE_1)) != 0)
		    info->insn_type = dis_jsr;
		  else
		    info->insn_type = dis_branch;
		  info->branch_delay_insns = 1;
		}
	      else if ((op->pinfo & (INSN_COND_BRANCH_DELAY
				     | INSN_COND_BRANCH_LIKELY)) != 0)
		{
		  if ((op->pinfo & INSN_WRITE_GPR_31) != 0)
		    info->insn_type = dis_condjsr;
		  else
		    info->insn_type = dis_condbranch;
		  info->branch_delay_insns = 1;
		}
	      else if ((op->pinfo & (INSN_STORE_MEMORY
				     | INSN_LOAD_MEMORY_DELAY)) != 0)
		info->insn_type = dis_dref;

	      infprintf (is, "%s", op->name);
	      if (op->pinfo2 & INSN2_VU0_CHANNEL_SUFFIX)
		{
		  unsigned int uval;

		  infprintf (is, ".");
		  uval = mips_extract_operand (&mips_vu0_channel_mask, word);
		  print_vu0_channel (info, &mips_vu0_channel_mask, uval);
		}

	      if (op->args[0])
		{
		  infprintf (is, "\t");
		  print_insn_args (info, op, decode_mips_operand, word,
				   memaddr + 4);
		}

	      return INSNLEN;
	    }
	}
    }
#undef GET_OP

  /* Handle undefined instructions.  */
  info->insn_type = dis_noninsn;
  infprintf (is, "0x%x", word);
  return INSNLEN;
}

/* Disassemble an operand for a mips16 instruction.  */

static void
print_mips16_insn_arg (struct disassemble_info *info,
		       struct mips_print_arg_state *state,
		       const struct mips_opcode *opcode,
		       char type, bfd_vma memaddr,
		       unsigned insn, bfd_boolean use_extend,
		       unsigned extend, bfd_boolean is_offset)
{
  const fprintf_ftype infprintf = info->fprintf_func;
  void *is = info->stream;
  const struct mips_operand *operand, *ext_operand;
  unsigned int uval;
  bfd_vma baseaddr;

  if (!use_extend)
    extend = 0;

  switch (type)
    {
    case ',':
    case '(':
    case ')':
      infprintf (is, "%c", type);
      break;

    default:
      operand = decode_mips16_operand (type, FALSE);
      if (!operand)
	{
	  /* xgettext:c-format */
	  infprintf (is, _("# internal error, undefined operand in `%s %s'"),
		     opcode->name, opcode->args);
	  return;
	}

      if (operand->type == OP_SAVE_RESTORE_LIST)
	{
	  /* Handle this case here because of the complex interation
	     with the EXTEND opcode.  */
	  unsigned int amask, nargs, nstatics, nsreg, smask, frame_size, i, j;
	  const char *sep;

	  amask = extend & 0xf;
	  if (amask == MIPS16_ALL_ARGS)
	    {
	      nargs = 4;
	      nstatics = 0;
	    }
	  else if (amask == MIPS16_ALL_STATICS)
	    {
	      nargs = 0;
	      nstatics = 4;
	    }
	  else
	    {
	      nargs = amask >> 2;
	      nstatics = amask & 3;
	    }

	  sep = "";
	  if (nargs > 0)
	    {
	      infprintf (is, "%s", mips_gpr_names[4]);
	      if (nargs > 1)
		infprintf (is, "-%s", mips_gpr_names[4 + nargs - 1]);
	      sep = ",";
	    }

	  frame_size = ((extend & 0xf0) | (insn & 0x0f)) * 8;
	  if (frame_size == 0 && !use_extend)
	    frame_size = 128;
	  infprintf (is, "%s%d", sep, frame_size);

	  if (insn & 0x40)		/* $ra */
	    infprintf (is, ",%s", mips_gpr_names[31]);

	  nsreg = (extend >> 8) & 0x7;
	  smask = 0;
	  if (insn & 0x20)		/* $s0 */
	    smask |= 1 << 0;
	  if (insn & 0x10)		/* $s1 */
	    smask |= 1 << 1;
	  if (nsreg > 0)		/* $s2-$s8 */
	    smask |= ((1 << nsreg) - 1) << 2;

	  for (i = 0; i < 9; i++)
	    if (smask & (1 << i))
	      {
		infprintf (is, ",%s", mips_gpr_names[i == 8 ? 30 : (16 + i)]);
		/* Skip over string of set bits.  */
		for (j = i; smask & (2 << j); j++)
		  continue;
		if (j > i)
		  infprintf (is, "-%s", mips_gpr_names[j == 8 ? 30 : (16 + j)]);
		i = j + 1;
	      }
	  /* Statics $ax - $a3.  */
	  if (nstatics == 1)
	    infprintf (is, ",%s", mips_gpr_names[7]);
	  else if (nstatics > 0)
	    infprintf (is, ",%s-%s",
		       mips_gpr_names[7 - nstatics + 1],
		       mips_gpr_names[7]);
	  break;
	}

      if (is_offset && operand->type == OP_INT)
	{
	  const struct mips_int_operand *int_op;

	  int_op = (const struct mips_int_operand *) operand;
	  info->insn_type = dis_dref;
	  info->data_size = 1 << int_op->shift;
	}

      if (operand->size == 26)
	/* In this case INSN is the first two bytes of the instruction
	   and EXTEND is the second two bytes.  */
	uval = ((insn & 0x1f) << 21) | ((insn & 0x3e0) << 11) | extend;
      else
	{
	  /* Calculate the full field value.  */
	  uval = mips_extract_operand (operand, insn);
	  if (use_extend)
	    {
	      ext_operand = decode_mips16_operand (type, TRUE);
	      if (ext_operand != operand)
		{
		  operand = ext_operand;
		  if (operand->size == 16)
		    uval |= ((extend & 0x1f) << 11) | (extend & 0x7e0);
		  else if (operand->size == 15)
		    uval |= ((extend & 0xf) << 11) | (extend & 0x7f0);
		  else
		    uval = ((extend >> 6) & 0x1f) | (extend & 0x20);
		}
	    }
	}

      baseaddr = memaddr + 2;
      if (operand->type == OP_PCREL)
	{
	  const struct mips_pcrel_operand *pcrel_op;

	  pcrel_op = (const struct mips_pcrel_operand *) operand;
	  if (!pcrel_op->include_isa_bit && use_extend)
	    baseaddr = memaddr - 2;
	  else if (!pcrel_op->include_isa_bit)
	     {
	       bfd_byte buffer[2];

	       /* If this instruction is in the delay slot of a JR
		  instruction, the base address is the address of the
		  JR instruction.  If it is in the delay slot of a JALR
		  instruction, the base address is the address of the
		  JALR instruction.  This test is unreliable: we have
		  no way of knowing whether the previous word is
		  instruction or data.  */
	       if (info->read_memory_func (memaddr - 4, buffer, 2, info) == 0
		   && (((info->endian == BFD_ENDIAN_BIG
			 ? bfd_getb16 (buffer)
			 : bfd_getl16 (buffer))
			& 0xf800) == 0x1800))
		 baseaddr = memaddr - 4;
	       else if (info->read_memory_func (memaddr - 2, buffer, 2,
						info) == 0
			&& (((info->endian == BFD_ENDIAN_BIG
			      ? bfd_getb16 (buffer)
			      : bfd_getl16 (buffer))
			     & 0xf81f) == 0xe800))
		 baseaddr = memaddr - 2;
	       else
		 baseaddr = memaddr;
	     }
	}

      print_insn_arg (info, state, opcode, operand, baseaddr + 1, uval);
      break;
    }
}


/* Check if the given address is the last word of a MIPS16 PLT entry.
   This word is data and depending on the value it may interfere with
   disassembly of further PLT entries.  We make use of the fact PLT
   symbols are marked BSF_SYNTHETIC.  */
static bfd_boolean
is_mips16_plt_tail (struct disassemble_info *info, bfd_vma addr)
{
  if (info->symbols
      && info->symbols[0]
      && (info->symbols[0]->flags & BSF_SYNTHETIC)
      && addr == bfd_asymbol_value (info->symbols[0]) + 12)
    return TRUE;

  return FALSE;
}

/* Disassemble mips16 instructions.  */

static int
print_insn_mips16 (bfd_vma memaddr, struct disassemble_info *info)
{
  const fprintf_ftype infprintf = info->fprintf_func;
  int status;
  bfd_byte buffer[4];
  int length;
  int insn;
  bfd_boolean use_extend;
  int extend = 0;
  const struct mips_opcode *op, *opend;
  struct mips_print_arg_state state;
  void *is = info->stream;

  info->bytes_per_chunk = 2;
  info->display_endian = info->endian;
  info->insn_info_valid = 1;
  info->branch_delay_insns = 0;
  info->data_size = 0;
  info->target = 0;
  info->target2 = 0;

#define GET_OP(insn, field) \
  (((insn) >> MIPS16OP_SH_##field) & MIPS16OP_MASK_##field)
  /* Decode PLT entry's GOT slot address word.  */
  if (is_mips16_plt_tail (info, memaddr))
    {
      info->insn_type = dis_noninsn;
      status = (*info->read_memory_func) (memaddr, buffer, 4, info);
      if (status == 0)
	{
	  unsigned int gotslot;

	  if (info->endian == BFD_ENDIAN_BIG)
	    gotslot = bfd_getb32 (buffer);
	  else
	    gotslot = bfd_getl32 (buffer);
	  infprintf (is, ".word\t0x%x", gotslot);

	  return 4;
	}
    }
  else
    {
      info->insn_type = dis_nonbranch;
      status = (*info->read_memory_func) (memaddr, buffer, 2, info);
    }
  if (status != 0)
    {
      (*info->memory_error_func) (status, memaddr, info);
      return -1;
    }

  length = 2;

  if (info->endian == BFD_ENDIAN_BIG)
    insn = bfd_getb16 (buffer);
  else
    insn = bfd_getl16 (buffer);

  /* Handle the extend opcode specially.  */
  use_extend = FALSE;
  if ((insn & 0xf800) == 0xf000)
    {
      use_extend = TRUE;
      extend = insn & 0x7ff;

      memaddr += 2;

      status = (*info->read_memory_func) (memaddr, buffer, 2, info);
      if (status != 0)
	{
	  infprintf (is, "extend 0x%x", (unsigned int) extend);
	  (*info->memory_error_func) (status, memaddr, info);
	  return -1;
	}

      if (info->endian == BFD_ENDIAN_BIG)
	insn = bfd_getb16 (buffer);
      else
	insn = bfd_getl16 (buffer);

      /* Check for an extend opcode followed by an extend opcode.  */
      if ((insn & 0xf800) == 0xf000)
	{
	  infprintf (is, "extend 0x%x", (unsigned int) extend);
	  info->insn_type = dis_noninsn;
	  return length;
	}

      length += 2;
    }

  /* FIXME: Should probably use a hash table on the major opcode here.  */

  opend = mips16_opcodes + bfd_mips16_num_opcodes;
  for (op = mips16_opcodes; op < opend; op++)
    {
      if (op->pinfo != INSN_MACRO
	  && !(no_aliases && (op->pinfo2 & INSN2_ALIAS))
	  && (insn & op->mask) == op->match)
	{
	  const char *s;

	  if (op->args[0] == 'a' || op->args[0] == 'i')
	    {
	      if (use_extend)
		{
		  infprintf (is, "extend 0x%x", (unsigned int) extend);
		  info->insn_type = dis_noninsn;
		  return length - 2;
		}

	      use_extend = FALSE;

	      memaddr += 2;

	      status = (*info->read_memory_func) (memaddr, buffer, 2,
						  info);
	      if (status == 0)
		{
		  use_extend = TRUE;
		  if (info->endian == BFD_ENDIAN_BIG)
		    extend = bfd_getb16 (buffer);
		  else
		    extend = bfd_getl16 (buffer);
		  length += 2;
		}
	    }

	  infprintf (is, "%s", op->name);
	  if (op->args[0] != '\0')
	    infprintf (is, "\t");

	  init_print_arg_state (&state);
	  for (s = op->args; *s != '\0'; s++)
	    {
	      if (*s == ','
		  && s[1] == 'w'
		  && GET_OP (insn, RX) == GET_OP (insn, RY))
		{
		  /* Skip the register and the comma.  */
		  ++s;
		  continue;
		}
	      if (*s == ','
		  && s[1] == 'v'
		  && GET_OP (insn, RZ) == GET_OP (insn, RX))
		{
		  /* Skip the register and the comma.  */
		  ++s;
		  continue;
		}
	      print_mips16_insn_arg (info, &state, op, *s, memaddr, insn,
				     use_extend, extend, s[1] == '(');
	    }

	  /* Figure out branch instruction type and delay slot information.  */
	  if ((op->pinfo & INSN_UNCOND_BRANCH_DELAY) != 0)
	    info->branch_delay_insns = 1;
	  if ((op->pinfo & INSN_UNCOND_BRANCH_DELAY) != 0
	      || (op->pinfo2 & INSN2_UNCOND_BRANCH) != 0)
	    {
	      if ((op->pinfo & INSN_WRITE_GPR_31) != 0)
		info->insn_type = dis_jsr;
	      else
		info->insn_type = dis_branch;
	    }
	  else if ((op->pinfo2 & INSN2_COND_BRANCH) != 0)
	    info->insn_type = dis_condbranch;

	  return length;
	}
    }
#undef GET_OP

  if (use_extend)
    infprintf (is, "0x%x", extend | 0xf000);
  infprintf (is, "0x%x", insn);
  info->insn_type = dis_noninsn;

  return length;
}

/* Disassemble microMIPS instructions.  */

static int
print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
{
  const fprintf_ftype infprintf = info->fprintf_func;
  const struct mips_opcode *op, *opend;
  void *is = info->stream;
  bfd_byte buffer[2];
  unsigned int higher;
  unsigned int length;
  int status;
  unsigned int insn;

  info->bytes_per_chunk = 2;
  info->display_endian = info->endian;
  info->insn_info_valid = 1;
  info->branch_delay_insns = 0;
  info->data_size = 0;
  info->insn_type = dis_nonbranch;
  info->target = 0;
  info->target2 = 0;

  status = (*info->read_memory_func) (memaddr, buffer, 2, info);
  if (status != 0)
    {
      (*info->memory_error_func) (status, memaddr, info);
      return -1;
    }

  length = 2;

  if (info->endian == BFD_ENDIAN_BIG)
    insn = bfd_getb16 (buffer);
  else
    insn = bfd_getl16 (buffer);

  if ((insn & 0xfc00) == 0x7c00)
    {
      /* This is a 48-bit microMIPS instruction.  */
      higher = insn;

      status = (*info->read_memory_func) (memaddr + 2, buffer, 2, info);
      if (status != 0)
	{
	  infprintf (is, "micromips 0x%x", higher);
	  (*info->memory_error_func) (status, memaddr + 2, info);
	  return -1;
	}
      if (info->endian == BFD_ENDIAN_BIG)
	insn = bfd_getb16 (buffer);
      else
	insn = bfd_getl16 (buffer);
      higher = (higher << 16) | insn;

      status = (*info->read_memory_func) (memaddr + 4, buffer, 2, info);
      if (status != 0)
	{
	  infprintf (is, "micromips 0x%x", higher);
	  (*info->memory_error_func) (status, memaddr + 4, info);
	  return -1;
	}
      if (info->endian == BFD_ENDIAN_BIG)
	insn = bfd_getb16 (buffer);
      else
	insn = bfd_getl16 (buffer);
      infprintf (is, "0x%x%04x (48-bit insn)", higher, insn);

      info->insn_type = dis_noninsn;
      return 6;
    }
  else if ((insn & 0x1c00) == 0x0000 || (insn & 0x1000) == 0x1000)
    {
      /* This is a 32-bit microMIPS instruction.  */
      higher = insn;

      status = (*info->read_memory_func) (memaddr + 2, buffer, 2, info);
      if (status != 0)
	{
	  infprintf (is, "micromips 0x%x", higher);
	  (*info->memory_error_func) (status, memaddr + 2, info);
	  return -1;
	}

      if (info->endian == BFD_ENDIAN_BIG)
	insn = bfd_getb16 (buffer);
      else
	insn = bfd_getl16 (buffer);

      insn = insn | (higher << 16);

      length += 2;
    }

  /* FIXME: Should probably use a hash table on the major opcode here.  */

  opend = micromips_opcodes + bfd_micromips_num_opcodes;
  for (op = micromips_opcodes; op < opend; op++)
    {
      if (op->pinfo != INSN_MACRO
	  && !(no_aliases && (op->pinfo2 & INSN2_ALIAS))
	  && (insn & op->mask) == op->match
	  && ((length == 2 && (op->mask & 0xffff0000) == 0)
	      || (length == 4 && (op->mask & 0xffff0000) != 0)))
	{
	  infprintf (is, "%s", op->name);

	  if (op->args[0])
	    {
	      infprintf (is, "\t");
	      print_insn_args (info, op, decode_micromips_operand, insn,
			       memaddr + length + 1);
	    }

	  /* Figure out instruction type and branch delay information.  */
	  if ((op->pinfo
	       & (INSN_UNCOND_BRANCH_DELAY | INSN_COND_BRANCH_DELAY)) != 0)
	    info->branch_delay_insns = 1;
	  if (((op->pinfo & INSN_UNCOND_BRANCH_DELAY)
	       | (op->pinfo2 & INSN2_UNCOND_BRANCH)) != 0)
	    {
	      if ((op->pinfo & (INSN_WRITE_GPR_31 | INSN_WRITE_1)) != 0)
		info->insn_type = dis_jsr;
	      else
		info->insn_type = dis_branch;
	    }
	  else if (((op->pinfo & INSN_COND_BRANCH_DELAY)
		    | (op->pinfo2 & INSN2_COND_BRANCH)) != 0)
	    {
	      if ((op->pinfo & INSN_WRITE_GPR_31) != 0)
		info->insn_type = dis_condjsr;
	      else
		info->insn_type = dis_condbranch;
	    }
	  else if ((op->pinfo
		    & (INSN_STORE_MEMORY | INSN_LOAD_MEMORY_DELAY)) != 0)
	    info->insn_type = dis_dref;

	  return length;
	}
    }

  infprintf (is, "0x%x", insn);
  info->insn_type = dis_noninsn;

  return length;
}

/* Return 1 if a symbol associated with the location being disassembled
   indicates a compressed (MIPS16 or microMIPS) mode.  We iterate over
   all the symbols at the address being considered assuming if at least
   one of them indicates code compression, then such code has been
   genuinely produced here (other symbols could have been derived from
   function symbols defined elsewhere or could define data).  Otherwise,
   return 0.  */

static bfd_boolean
is_compressed_mode_p (struct disassemble_info *info)
{
  int i;
  int l;

  for (i = info->symtab_pos, l = i + info->num_symbols; i < l; i++)
    if (((info->symtab[i])->flags & BSF_SYNTHETIC) != 0
	&& ((!micromips_ase
	     && ELF_ST_IS_MIPS16 ((*info->symbols)->udata.i))
	    || (micromips_ase
		&& ELF_ST_IS_MICROMIPS ((*info->symbols)->udata.i))))
      return 1;
    else if (bfd_asymbol_flavour (info->symtab[i]) == bfd_target_elf_flavour
	      && info->symtab[i]->section == info->section)
      {
	elf_symbol_type *symbol = (elf_symbol_type *) info->symtab[i];
	if ((!micromips_ase
	     && ELF_ST_IS_MIPS16 (symbol->internal_elf_sym.st_other))
	    || (micromips_ase
		&& ELF_ST_IS_MICROMIPS (symbol->internal_elf_sym.st_other)))
	  return 1;
      }

  return 0;
}

/* In an environment where we do not know the symbol type of the
   instruction we are forced to assume that the low order bit of the
   instructions' address may mark it as a mips16 instruction.  If we
   are single stepping, or the pc is within the disassembled function,
   this works.  Otherwise, we need a clue.  Sometimes.  */

static int
_print_insn_mips (bfd_vma memaddr,
		  struct disassemble_info *info,
		  enum bfd_endian endianness)
{
  int (*print_insn_compr) (bfd_vma, struct disassemble_info *);
  bfd_byte buffer[INSNLEN];
  int status;

  set_default_mips_dis_options (info);
  parse_mips_dis_options (info->disassembler_options);

  if (info->mach == bfd_mach_mips16)
    return print_insn_mips16 (memaddr, info);
  if (info->mach == bfd_mach_mips_micromips)
    return print_insn_micromips (memaddr, info);

  print_insn_compr = !micromips_ase ? print_insn_mips16 : print_insn_micromips;

#if 1
  /* FIXME: If odd address, this is CLEARLY a compressed instruction.  */
  /* Only a few tools will work this way.  */
  if (memaddr & 0x01)
    return print_insn_compr (memaddr, info);
#endif

#if SYMTAB_AVAILABLE
  if (is_compressed_mode_p (info))
    return print_insn_compr (memaddr, info);
#endif

  status = (*info->read_memory_func) (memaddr, buffer, INSNLEN, info);
  if (status == 0)
    {
      int insn;

      if (endianness == BFD_ENDIAN_BIG)
	insn = bfd_getb32 (buffer);
      else
	insn = bfd_getl32 (buffer);

      return print_insn_mips (memaddr, insn, info);
    }
  else
    {
      (*info->memory_error_func) (status, memaddr, info);
      return -1;
    }
}

int
print_insn_big_mips (bfd_vma memaddr, struct disassemble_info *info)
{
  return _print_insn_mips (memaddr, info, BFD_ENDIAN_BIG);
}

int
print_insn_little_mips (bfd_vma memaddr, struct disassemble_info *info)
{
  return _print_insn_mips (memaddr, info, BFD_ENDIAN_LITTLE);
}

void
print_mips_disassembler_options (FILE *stream)
{
  unsigned int i;

  fprintf (stream, _("\n\
The following MIPS specific disassembler options are supported for use\n\
with the -M switch (multiple options should be separated by commas):\n"));

  fprintf (stream, _("\n\
  msa             Recognize MSA instructions.\n"));

  fprintf (stream, _("\n\
  virt            Recognize the virtualization ASE instructions.\n"));

  fprintf (stream, _("\n\
  gpr-names=ABI            Print GPR names according to  specified ABI.\n\
                           Default: based on binary being disassembled.\n"));

  fprintf (stream, _("\n\
  fpr-names=ABI            Print FPR names according to specified ABI.\n\
                           Default: numeric.\n"));

  fprintf (stream, _("\n\
  cp0-names=ARCH           Print CP0 register names according to\n\
                           specified architecture.\n\
                           Default: based on binary being disassembled.\n"));

  fprintf (stream, _("\n\
  hwr-names=ARCH           Print HWR names according to specified \n\
			   architecture.\n\
                           Default: based on binary being disassembled.\n"));

  fprintf (stream, _("\n\
  reg-names=ABI            Print GPR and FPR names according to\n\
                           specified ABI.\n"));

  fprintf (stream, _("\n\
  reg-names=ARCH           Print CP0 register and HWR names according to\n\
                           specified architecture.\n"));

  fprintf (stream, _("\n\
  For the options above, the following values are supported for \"ABI\":\n\
   "));
  for (i = 0; i < ARRAY_SIZE (mips_abi_choices); i++)
    fprintf (stream, " %s", mips_abi_choices[i].name);
  fprintf (stream, _("\n"));

  fprintf (stream, _("\n\
  For the options above, The following values are supported for \"ARCH\":\n\
   "));
  for (i = 0; i < ARRAY_SIZE (mips_arch_choices); i++)
    if (*mips_arch_choices[i].name != '\0')
      fprintf (stream, " %s", mips_arch_choices[i].name);
  fprintf (stream, _("\n"));

  fprintf (stream, _("\n"));
}
@


1.116
log
@include/opcode/
	* mips.h (OP_OPTIONAL_REG): New mips_operand_type.
	(mips_optional_operand_p): New function.

opcodes/
	* mips-formats.h (OPTIONAL_REG, OPTIONAL_MAPPED_REG): New macros.
	* micromips-opc.c (decode_micromips_operand): Use OPTIONAL_REG
	and OPTIONAL_MAPPED_REG.
	* mips-opc.c (decode_mips_operand): Likewise.
	* mips16-opc.c (decode_mips16_operand): Likewise.
	* mips-dis.c (print_insn_arg): Handle OP_OPTIONAL_REG.

gas/
	* config/tc-mips.c (operand_reg_mask, match_operand): Handle
	OP_OPTIONAL_REG.
	(mips_ip, mips16_ip): Use mips_optional_operand_p to check
	for optional operands.
@
text
@d404 9
d510 1
a510 1
     | ASE_MT | ASE_MCU | ASE_VIRT),
d525 1
a525 1
     | ASE_MDMX | ASE_MCU | ASE_VIRT | ASE_VIRT64),
d750 8
d961 9
d1279 10
d2133 3
@


1.115
log
@include/opcode/
2013-08-04  Jürgen Urban  <JuergenUrban@@gmx.de>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* mips.h: Document new VU0 operand characters.
	(OP_VU0_SUFFIX, OP_VU0_MATCH_SUFFIX): New mips_operand_types.
	(OP_REG_VF, OP_REG_VI, OP_REG_R5900_I, OP_REG_R5900_Q, OP_REG_R5900_R)
	(OP_REG_R5900_ACC): New mips_reg_operand_types.
	(INSN2_VU0_CHANNEL_SUFFIX): New macro.
	(mips_vu0_channel_mask): Declare.

opcodes/
2013-08-04  Jürgen Urban  <JuergenUrban@@gmx.de>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* mips-dis.c (print_reg): Handle OP_REG_VI, OP_REG_VF, OP_REG_R5900_I,
	OP_REG_R5900_Q, OP_REG_R5900_R and OP_REG_R5900_ACC.
	(print_vu0_channel): New function.
	(print_insn_arg): Handle OP_VU0_SUFFIX and OP_VU0_MATCH_SUFFIX.
	(print_insn_args): Handle '#'.
	(print_insn_mips): Handle INSN2_VU0_CHANNEL_SUFFIX.
	* mips-opc.c (mips_vu0_channel_mask): New constant.
	(decode_mips_operand): Handle new VU0 operand types.
	(VU0, VU0CH): New macros.
	(mips_builtin_opcodes): Add VU0 opcodes.  Use "+7" rather than "E"
	for LQC2 and SQC2.  Use "+9" rather than "G" for EE CFC2 and CTC2.
	Use "+6" rather than "G" for QMFC2 and QMTC2.

gas/
2013-08-04  Jürgen Urban  <JuergenUrban@@gmx.de>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* config/tc-mips.c (MAX_OPERANDS): Bump to 6.
	(RWARN): Bump to 0x8000000.
	(RTYPE_VI, RTYPE_VF, RTYPE_R5900_I, RTYPE_R5900_Q, RTYPE_R5900_R)
	(RTYPE_R5900_ACC): New register types.
	(RTYPE_MASK): Include them.
	(R5900_I_NAMES, R5900_Q_NAMES, R5900_R_NAMES, R5900_ACC_NAMES): New
	macros.
	(reg_names): Include them.
	(mips_parse_register_1): New function, split out from...
	(mips_parse_register): ...here.  Add a channels_ptr parameter.
	Look for VU0 channel suffixes when nonnull.
	(reg_lookup): Update the call to mips_parse_register.
	(mips_parse_vu0_channels): New function.
	(OT_CHANNELS, OT_DOUBLE_CHAR): New mips_operand_token_types.
	(mips_operand_token): Add a "channels" field to the union.
	Extend the comment above "ch" to OT_DOUBLE_CHAR.
	(mips_parse_base_start): Match -- and ++.  Handle channel suffixes.
	(mips_parse_argument_token): Handle channel suffixes here too.
	(validate_mips_insn): Handle INSN2_VU0_CHANNEL_SUFFIX.
	Ignore OP_VU0_MATCH_SUFFIX when calculating the used bits.
	Handle '#' formats.
	(md_begin): Register $vfN and $vfI registers.
	(operand_reg_mask): Handle OP_VU0_SUFFIX and OP_VU0_MATCH_SUFFIX.
	(convert_reg_type): Handle OP_REG_VI, OP_REG_VF, OP_REG_R5900_I,
	OP_REG_R5900_Q, OP_REG_R5900_R and OP_REG_R5900_ACC.
	(match_vu0_suffix_operand): New function.
	(match_operand): Handle OP_VU0_SUFFIX and OP_VU0_MATCH_SUFFIX.
	(macro): Use "+7" rather than "E" for LDQ2 and STQ2.
	(mips_lookup_insn): New function.
	(mips_ip): Use it.  Allow "+K" operands to be elided at the end
	of an instruction.  Handle '#' sequences.

gas/testsuite/
2013-08-04  Jürgen Urban  <JuergenUrban@@gmx.de>

	* gas/mips/r5900-vu0.d: Expect $vfN and $viN instead of numeric
	coprocessor registers.
	* gas/mips/r5900-all-vu0.s, gas/mips/r5900-all-vu0.d,
	gas/mips/r5900-full-vu0.s, gas/mips/r5900-full-vu0.d,
	gas/mips/r5900-error-vu0.s, gas/mips/r5900-error-vu0.l: New tests.
	* gas/mips/mips.exp: Run them.
@
text
@d1045 1
@


1.114
log
@include/opcode/
	* mips.h (mips_decode_reg_operand): New function.
	(INSN_WRITE_SHIFT, INSN_WRITE_1, INSN_WRITE_2, INSN_WRITE_ALL)
	(INSN_READ_SHIFT, INSN_READ_1, INSN_READ_2, INSN_READ_3, INSN_READ_4)
	(INSN_READ_ALL, INSN_READ_GPR_24, INSN_WRITE_GPR_24, INSN_UDI):
	New macros.
	(INSN_WRITE_GPR_D, INSN_WRITE_GPR_T, INSN_WRITE_FPR_D)
	(INSN_WRITE_FPR_S, INSN_WRITE_FPR_T, INSN_READ_GPR_S, INSN_READ_GPR_T)
	(INSN_READ_FPR_S, INSN_READ_FPR_T, INSN_READ_FPR_R, INSN_WRITE_GPR_S)
	(INSN2_WRITE_GPR_Z, INSN2_WRITE_FPR_Z, INSN2_READ_GPR_Z)
	(INSN2_READ_FPR_Z, INSN2_READ_GPR_D, INSN2_READ_FPR_D)
	(INSN2_WRITE_GPR_MB, INSN2_READ_GPR_MC, INSN2_MOD_GPR_MD)
	(INSN2_READ_GPR_ME, INSN2_MOD_GPR_MF, INSN2_READ_GPR_MG)
	(INSN2_READ_GPR_MJ, INSN2_WRITE_GPR_MJ, INSN2_READ_GPR_MP)
	(INSN2_WRITE_GPR_MP, INSN2_READ_GPR_MQ, INSN2_READ_GP)
	(INSN2_WRITE_GPR_MH, INSN2_READ_GPR_MMN): Delete.  Renumber other
	macros to cover the gaps.
	(INSN2_MOD_SP): Replace with...
	(INSN2_WRITE_SP, INSN2_READ_SP): ...these new macros.
	(MIPS16_INSN_WRITE_X, MIPS16_INSN_WRITE_Y, MIPS16_INSN_WRITE_Z)
	(MIPS16_INSN_WRITE_T, MIPS16_INSN_WRITE_31, MIPS16_INSN_WRITE_GPR_Y)
	(MIPS16_INSN_READ_X, MIPS16_INSN_READ_Y, MIPS16_INSN_READ_Z)
	(MIPS16_INSN_READ_T, MIPS16_INSN_READ_SP, MIPS16_INSN_READ_GPR_X):
	Delete.

opcodes/
	* mips-opc.c (WR_1, WR_2, RD_1, RD_2, RD_3, RD_4, MOD_1, MOD_2, UDI):
	New macros.
	(WR_d, WR_t, WR_D, WR_T, WR_S, RD_s, RD_b, RD_t, RD_S, RD_T, RD_R)
	(WR_z, WR_Z, RD_z, RD_Z, RD_d): Delete.
	(mips_builtin_opcodes): Use the new position-based read-write flags
	instead of field-based ones.  Use UDI for "udi..." instructions.
	* mips16-opc.c (WR_1, WR_2, RD_1, RD_2, RD_3, RD_4, MOD_1, MOD_2):
	New macros.
	(WR_x, WR_y, WR_z, WR_Y, RD_x, RD_y, RD_Z, RD_X): Delete.
	(RD_T, WR_T, WR_31): Redefine using generic INSN_* flags.
	(WR_SP, RD_16): New macros.
	(RD_SP): Redefine as an INSN2_* flag.
	(MOD_SP): Redefine in terms of RD_SP and WR_SP.
	(mips16_opcodes): Use the new position-based read-write flags
	instead of field-based ones.  Use RD_16 for "nop".  Move RD_SP to
	pinfo2 field.
	* micromips-opc.c (WR_1, WR_2, RD_1, RD_2, RD_3, RD_4, MOD_1, MOD_2):
	New macros.
	(WR_mb, RD_mc, RD_md, WR_md, RD_me, RD_mf, WR_mf, RD_mg, WR_mh, RD_mj)
	(WR_mj, RD_ml, RD_mmn, RD_mp, WR_mp, RD_mq, RD_gp, WR_d, WR_t, WR_D)
	(WR_T, WR_S, RD_s, RD_b, RD_t, RD_T, RD_S, RD_R, RD_D): Delete.
	(RD_sp, WR_sp): Redefine to INSN2_READ_SP and INSN2_WRITE_SP.
	(micromips_opcodes): Use the new position-based read-write flags
	instead of field-based ones.
	* mips-dis.c (print_insn_arg): Use mips_decode_reg_operand.
	(print_insn_mips, print_insn_micromips): Use INSN_WRITE_1 instead
	of field-based flags.

gas/
	* config/tc-mips.c (MAX_OPERANDS): New macro.
	(mips_operand_array): New structure.
	(mips_operands, mips16_operands, micromips_operands): New arrays.
	(micromips_to_32_reg_b_map, micromips_to_32_reg_c_map)
	(micromips_to_32_reg_e_map, micromips_to_32_reg_f_map)
	(micromips_to_32_reg_g_map, micromips_to_32_reg_l_map)
	(micromips_to_32_reg_q_map): Delete.
	(insn_operands, insn_opno, insn_extract_operand): New functions.
	(validate_mips_insn): Take a mips_operand_array as argument and
	use it to build up a list of operands.  Extend to handle INSN_MACRO
	and MIPS16.
	(validate_mips16_insn): New function.
	(validate_micromips_insn): Take a mips_operand_array as argument.
	Handle INSN_MACRO.
	(md_begin): Initialize mips_operands, mips16_operands and
	micromips_operands.  Call validate_mips_insn and
	validate_micromips_insn for macro instructions too.
	Call validate_mips16_insn for MIPS16 instructions.
	(insn_read_mask, insn_write_mask, operand_reg_mask, insn_reg_mask):
	New functions.
	(gpr_read_mask, gpr_write_mask, fpr_read_mask, fpr_write_mask): Use
	them.  Handle INSN_UDI.
	(get_append_method): Use gpr_read_mask.
@
text
@d920 24
d968 19
d1247 5
d1282 5
d1421 8
@


1.113
log
@include/opcode/
	* mips.h (MIPS16_INSN_WRITE_SP, MIPS16_INSN_READ_31)
	(MIPS16_INSN_READ_PC, MIPS16_INSN_UNCOND_BRANCH)
	(MIPS16_INSN_COND_BRANCH): Delete.

opcodes/
	* mips16-opc.c (UBR, CBR, RD_31, RD_PC): Redefine as INSN2_* flags.
	(WR_SP): Replace with...
	(MOD_SP): ...this.
	(mips16_opcodes): Update accordingly.
	* mips-dis.c (print_insn_mips16): Likewise.

gas/
	* config/tc-mips.c (compact_branch_p, uncond_branch_p): Use the same
	flags for MIPS16 and non-MIPS16 instructions.
	(gpr_mod_mask): Move the INSN2_MOD_SP case outside the micromips block.
	(gpr_read_mask): Use INSN2_READ_GPR_31 for MIPS16 instructions too.
	(gpr_write_mask): Remove MIPS16_INSN_WRITE_SP handling.
	(can_swap_branch_p, get_append_method): Use the same flags for MIPS16
	and non-MIPS16 instructions.  Fix formatting.
@
text
@d1006 1
a1006 2
	if (reg_op->reg_map)
	  uval = reg_op->reg_map[uval];
d1348 1
a1348 2
		  if ((op->pinfo & (INSN_WRITE_GPR_31
				    | INSN_WRITE_GPR_D)) != 0)
d1895 1
a1895 1
	      if ((op->pinfo & (INSN_WRITE_GPR_31 | INSN_WRITE_GPR_T)) != 0)
@


1.112
log
@opcodes/
	* mips-dis.c (print_mips16_insn_arg): Include ISA bit in base address.
@
text
@d1752 2
a1753 2
	  if ((op->pinfo & (INSN_UNCOND_BRANCH_DELAY
			    | MIPS16_INSN_UNCOND_BRANCH)) != 0)
d1760 1
a1760 1
	  else if ((op->pinfo & MIPS16_INSN_COND_BRANCH) != 0)
@


1.111
log
@include/opcode/
	* mips.h (mips_operand_type): Add OP_ENTRY_EXIT_LIST and
	OP_SAVE_RESTORE_LIST.
	(decode_mips16_operand): Declare.

opcodes/
	* mips16-opc.c: Include mips-formats.h.
	(reg_0_map, reg_29_map, reg_31_map, reg_m16_map, reg32r_map): New
	static arrays.
	(decode_mips16_operand): New function.
	* mips-dis.c (mips16_to_32_reg_map, mips16_reg_names): Delete.
	(print_insn_arg): Handle OP_ENTRY_EXIT list.
	Abort for OP_SAVE_RESTORE_LIST.
	(print_mips16_insn_arg): Change interface.  Use mips_operand
	structures.  Delete GET_OP_S.  Move GET_OP definition to...
	(print_insn_mips16): ...here.  Call init_print_arg_state.
	Update the call to print_mips16_insn_arg.
@
text
@d1568 1
a1568 1
      print_insn_arg (info, state, opcode, operand, baseaddr, uval);
@


1.110
log
@include/opcode/
	* mips.h (mips_operand_type, mips_reg_operand_type): New enums.
	(mips_operand, mips_int_operand, mips_mapped_int_operand)
	(mips_msb_operand, mips_reg_operand, mips_reg_pair_operand)
	(mips_pcrel_operand): New structures.
	(mips_insert_operand, mips_extract_operand, mips_signed_operand)
	(mips_decode_int_operand, mips_decode_pcrel_operand): New functions.
	(decode_mips_operand, decode_micromips_operand): Declare.

opcodes/
	* mips-formats.h: New file.
	* mips-opc.c: Include mips-formats.h.
	(reg_0_map): New static array.
	(decode_mips_operand): New function.
	* micromips-opc.c: Remove <stdio.h> include.  Include mips-formats.h.
	(reg_0_map, reg_28_map, reg_29_map, reg_31_map, reg_m16_map)
	(reg_mn_map, reg_q_map, reg_h_map1, reg_h_map2, int_b_map)
	(int_c_map): New static arrays.
	(decode_micromips_operand): New function.
	* mips-dis.c (micromips_to_32_reg_b_map, micromips_to_32_reg_c_map)
	(micromips_to_32_reg_d_map, micromips_to_32_reg_e_map)
	(micromips_to_32_reg_f_map, micromips_to_32_reg_g_map)
	(micromips_to_32_reg_h_map1, micromips_to_32_reg_h_map2)
	(micromips_to_32_reg_l_map, micromips_to_32_reg_m_map)
	(micromips_to_32_reg_n_map, micromips_to_32_reg_q_map)
	(micromips_imm_b_map, micromips_imm_c_map): Delete.
	(print_reg): New function.
	(mips_print_arg_state): New structure.
	(init_print_arg_state, print_insn_arg): New functions.
	(print_insn_args): Change interface and use mips_operand structures.
	Delete GET_OP_S.  Move GET_OP definition to...
	(print_insn_mips): ...here.  Update the call to print_insn_args.
	(print_insn_micromips): Use print_insn_args.

gas/
	* config/tc-mips.c (validate_mips_insn): Move further up file.
	Add insn_bits and decode_operand arguments.  Use the mips_operand
	fields to work out which bits an operand occupies.  Detect double
	definitions.
	(validate_micromips_insn): Move further up file.  Call into
	validate_mips_insn.
@
text
@a53 9
/* The mips16 registers.  */
static const unsigned int mips16_to_32_reg_map[] =
{
  16, 17, 2, 3, 4, 5, 6, 7
};

#define mips16_reg_names(rn)	mips_gpr_names[mips16_to_32_reg_map[rn]]


d1122 48
d1393 6
a1398 7
print_mips16_insn_arg (char type,
		       const struct mips_opcode *op,
		       int l,
		       bfd_boolean use_extend,
		       int extend,
		       bfd_vma memaddr,
		       struct disassemble_info *info)
d1402 6
a1408 5
#define GET_OP(insn, field) \
  (((insn) >> MIPS16OP_SH_##field) & MIPS16OP_MASK_##field)
#define GET_OP_S(insn, field) \
  ((GET_OP (insn, field) ^ ((MIPS16OP_MASK_##field >> 1) + 1)) \
   - ((MIPS16OP_MASK_##field >> 1) + 1))
d1417 9
a1425 4
    case 'y':
    case 'w':
      infprintf (is, "%s", mips16_reg_names (GET_OP (l, RY)));
      break;
d1427 6
a1432 4
    case 'x':
    case 'v':
      infprintf (is, "%s", mips16_reg_names (GET_OP (l, RX)));
      break;
d1434 16
a1449 3
    case 'z':
      infprintf (is, "%s", mips16_reg_names (GET_OP (l, RZ)));
      break;
d1451 8
a1458 7
    case 'Z':
      infprintf (is, "%s", mips16_reg_names (GET_OP (l, MOVE32Z)));
      break;

    case '0':
      infprintf (is, "%s", mips_gpr_names[0]);
      break;
d1460 16
a1475 44
    case 'S':
      infprintf (is, "%s", mips_gpr_names[29]);
      break;

    case 'P':
      infprintf (is, "$pc");
      break;

    case 'R':
      infprintf (is, "%s", mips_gpr_names[31]);
      break;

    case 'X':
      infprintf (is, "%s", mips_gpr_names[GET_OP (l, REGR32)]);
      break;

    case 'Y':
      infprintf (is, "%s", mips_gpr_names[MIPS16OP_EXTRACT_REG32R (l)]);
      break;

    case '<':
    case '>':
    case '[':
    case ']':
    case '4':
    case '5':
    case 'H':
    case 'W':
    case 'D':
    case 'j':
    case '6':
    case '8':
    case 'V':
    case 'C':
    case 'U':
    case 'k':
    case 'K':
    case 'p':
    case 'q':
    case 'A':
    case 'B':
    case 'E':
      {
	int immed, nbits, shift, signedp, extbits, pcrel, extu, branch;
d1477 2
a1478 57
	shift = 0;
	signedp = 0;
	extbits = 16;
	pcrel = 0;
	extu = 0;
	branch = 0;
	switch (type)
	  {
	  case '<':
	    nbits = 3;
	    immed = GET_OP (l, RZ);
	    extbits = 5;
	    extu = 1;
	    break;
	  case '>':
	    nbits = 3;
	    immed = GET_OP (l, RX);
	    extbits = 5;
	    extu = 1;
	    break;
	  case '[':
	    nbits = 3;
	    immed = GET_OP (l, RZ);
	    extbits = 6;
	    extu = 1;
	    break;
	  case ']':
	    nbits = 3;
	    immed = GET_OP (l, RX);
	    extbits = 6;
	    extu = 1;
	    break;
	  case '4':
	    nbits = 4;
	    immed = GET_OP (l, IMM4);
	    signedp = 1;
	    extbits = 15;
	    break;
	  case '5':
	    nbits = 5;
	    immed = GET_OP (l, IMM5);
	    info->insn_type = dis_dref;
	    info->data_size = 1;
	    break;
	  case 'H':
	    nbits = 5;
	    shift = 1;
	    immed = GET_OP (l, IMM5);
	    info->insn_type = dis_dref;
	    info->data_size = 2;
	    break;
	  case 'W':
	    nbits = 5;
	    shift = 2;
	    immed = GET_OP (l, IMM5);
	    if ((op->pinfo & MIPS16_INSN_READ_PC) == 0
		&& (op->pinfo & MIPS16_INSN_READ_SP) == 0)
d1480 7
a1486 2
		info->insn_type = dis_dref;
		info->data_size = 4;
d1488 9
a1496 93
	    break;
	  case 'D':
	    nbits = 5;
	    shift = 3;
	    immed = GET_OP (l, IMM5);
	    info->insn_type = dis_dref;
	    info->data_size = 8;
	    break;
	  case 'j':
	    nbits = 5;
	    immed = GET_OP (l, IMM5);
	    signedp = 1;
	    break;
	  case '6':
	    nbits = 6;
	    immed = GET_OP (l, IMM6);
	    break;
	  case '8':
	    nbits = 8;
	    immed = GET_OP (l, IMM8);
	    break;
	  case 'V':
	    nbits = 8;
	    shift = 2;
	    immed = GET_OP (l, IMM8);
	    /* FIXME: This might be lw, or it might be addiu to $sp or
               $pc.  We assume it's load.  */
	    info->insn_type = dis_dref;
	    info->data_size = 4;
	    break;
	  case 'C':
	    nbits = 8;
	    shift = 3;
	    immed = GET_OP (l, IMM8);
	    info->insn_type = dis_dref;
	    info->data_size = 8;
	    break;
	  case 'U':
	    nbits = 8;
	    immed = GET_OP (l, IMM8);
	    extu = 1;
	    break;
	  case 'k':
	    nbits = 8;
	    immed = GET_OP (l, IMM8);
	    signedp = 1;
	    break;
	  case 'K':
	    nbits = 8;
	    shift = 3;
	    immed = GET_OP (l, IMM8);
	    signedp = 1;
	    break;
	  case 'p':
	    nbits = 8;
	    immed = GET_OP (l, IMM8);
	    signedp = 1;
	    pcrel = 1;
	    branch = 1;
	    break;
	  case 'q':
	    nbits = 11;
	    immed = GET_OP (l, IMM11);
	    signedp = 1;
	    pcrel = 1;
	    branch = 1;
	    break;
	  case 'A':
	    nbits = 8;
	    shift = 2;
	    immed = GET_OP (l, IMM8);
	    pcrel = 1;
	    /* FIXME: This can be lw or la.  We assume it is lw.  */
	    info->insn_type = dis_dref;
	    info->data_size = 4;
	    break;
	  case 'B':
	    nbits = 5;
	    shift = 3;
	    immed = GET_OP (l, IMM5);
	    pcrel = 1;
	    info->insn_type = dis_dref;
	    info->data_size = 8;
	    break;
	  case 'E':
	    nbits = 5;
	    shift = 2;
	    immed = GET_OP (l, IMM5);
	    pcrel = 1;
	    break;
	  default:
	    abort ();
	  }
d1498 3
a1500 21
	if (! use_extend)
	  {
	    if (signedp && immed >= (1 << (nbits - 1)))
	      immed -= 1 << nbits;
	    immed <<= shift;
	    if ((type == '<' || type == '>' || type == '[' || type == ']')
		&& immed == 0)
	      immed = 8;
	  }
	else
	  {
	    if (extbits == 16)
	      immed |= ((extend & 0x1f) << 11) | (extend & 0x7e0);
	    else if (extbits == 15)
	      immed |= ((extend & 0xf) << 11) | (extend & 0x7f0);
	    else
	      immed = ((extend >> 6) & 0x1f) | (extend & 0x20);
	    immed &= (1 << extbits) - 1;
	    if (! extu && immed >= (1 << (extbits - 1)))
	      immed -= 1 << extbits;
	  }
d1502 4
a1505 5
	if (! pcrel)
	  infprintf (is, "%d", immed);
	else
	  {
	    bfd_vma baseaddr;
d1507 23
a1529 11
	    if (branch)
	      {
		immed *= 2;
		baseaddr = memaddr + 2;
	      }
	    else if (use_extend)
	      baseaddr = memaddr - 2;
	    else
	      {
		int status;
		bfd_byte buffer[2];
d1531 4
a1534 1
		baseaddr = memaddr;
d1536 22
a1557 20
		/* If this instruction is in the delay slot of a jr
                   instruction, the base address is the address of the
                   jr instruction.  If it is in the delay slot of jalr
                   instruction, the base address is the address of the
                   jalr instruction.  This test is unreliable: we have
                   no way of knowing whether the previous word is
                   instruction or data.  */
		status = (*info->read_memory_func) (memaddr - 4, buffer, 2,
						    info);
		if (status == 0
		    && (((info->endian == BFD_ENDIAN_BIG
			  ? bfd_getb16 (buffer)
			  : bfd_getl16 (buffer))
			 & 0xf800) == 0x1800))
		  baseaddr = memaddr - 4;
		else
		  {
		    status = (*info->read_memory_func) (memaddr - 2, buffer,
							2, info);
		    if (status == 0
d1562 5
a1566 35
		      baseaddr = memaddr - 2;
		  }
	      }
	    info->target = (baseaddr & ~((1 << shift) - 1)) + immed;
	    if (pcrel && branch
		&& info->flavour == bfd_target_unknown_flavour)
	      /* For gdb disassembler, maintain odd address.  */
	      info->target |= 1;
	    (*info->print_address_func) (info->target, info);
	  }
      }
      break;

    case 'a':
    case 'i':
      {
	if (! use_extend)
	  extend = 0;
	l = ((l & 0x1f) << 23) | ((l & 0x3e0) << 13) | (extend << 2);
	if (type == 'a' && info->flavour == bfd_target_unknown_flavour)
	  /* For gdb disassembler, maintain odd address.  */
	  l |= 1;
      }
      info->target = ((memaddr + 4) & ~(bfd_vma) 0x0fffffff) | l;
      (*info->print_address_func) (info->target, info);
      break;

    case 'l':
    case 'L':
      {
	int need_comma, amask, smask;

	need_comma = 0;

	l = GET_OP (l, IMM6);
d1568 1
a1568 37
	amask = (l >> 3) & 7;

	if (amask > 0 && amask < 5)
	  {
	    infprintf (is, "%s", mips_gpr_names[4]);
	    if (amask > 1)
	      infprintf (is, "-%s", mips_gpr_names[amask + 3]);
	    need_comma = 1;
	  }

	smask = (l >> 1) & 3;
	if (smask == 3)
	  {
	    infprintf (is, "%s??", need_comma ? "," : "");
	    need_comma = 1;
	  }
	else if (smask > 0)
	  {
	    infprintf (is, "%s%s", need_comma ? "," : "", mips_gpr_names[16]);
	    if (smask > 1)
	      infprintf (is, "-%s", mips_gpr_names[smask + 15]);
	    need_comma = 1;
	  }

	if (l & 1)
	  {
	    infprintf (is, "%s%s", need_comma ? "," : "", mips_gpr_names[31]);
	    need_comma = 1;
	  }

	if (amask == 5 || amask == 6)
	  {
	    infprintf (is, "%s$f0", need_comma ? "," : "");
	    if (amask == 6)
	      infprintf (is, "-$f1");
	  }
      }
a1569 89

    case 'm':
    case 'M':
      /* MIPS16e save/restore.  */
      {
      int need_comma = 0;
      int amask, args, statics;
      int nsreg, smask;
      int framesz;
      int i, j;

      l = l & 0x7f;
      if (use_extend)
        l |= extend << 16;

      amask = (l >> 16) & 0xf;
      if (amask == MIPS16_ALL_ARGS)
        {
          args = 4;
          statics = 0;
        }
      else if (amask == MIPS16_ALL_STATICS)
        {
          args = 0;
          statics = 4;
        }
      else
        {
          args = amask >> 2;
          statics = amask & 3;
        }

      if (args > 0) {
	  infprintf (is, "%s", mips_gpr_names[4]);
          if (args > 1)
	    infprintf (is, "-%s", mips_gpr_names[4 + args - 1]);
          need_comma = 1;
      }

      framesz = (((l >> 16) & 0xf0) | (l & 0x0f)) * 8;
      if (framesz == 0 && !use_extend)
        framesz = 128;

      infprintf (is, "%s%d", need_comma ? "," : "", framesz);

      if (l & 0x40)                   /* $ra */
	infprintf (is, ",%s", mips_gpr_names[31]);

      nsreg = (l >> 24) & 0x7;
      smask = 0;
      if (l & 0x20)                   /* $s0 */
        smask |= 1 << 0;
      if (l & 0x10)                   /* $s1 */
        smask |= 1 << 1;
      if (nsreg > 0)                  /* $s2-$s8 */
        smask |= ((1 << nsreg) - 1) << 2;

      /* Find first set static reg bit.  */
      for (i = 0; i < 9; i++)
        {
          if (smask & (1 << i))
            {
	      infprintf (is, ",%s", mips_gpr_names[i == 8 ? 30 : (16 + i)]);
              /* Skip over string of set bits.  */
              for (j = i; smask & (2 << j); j++)
                continue;
              if (j > i)
		infprintf (is, "-%s", mips_gpr_names[j == 8 ? 30 : (16 + j)]);
              i = j + 1;
            }
        }

      /* Statics $ax - $a3.  */
      if (statics == 1)
	infprintf (is, ",%s", mips_gpr_names[7]);
      else if (statics > 0) 
	infprintf (is, ",%s-%s",
		   mips_gpr_names[7 - statics + 1],
		   mips_gpr_names[7]);
      }
      break;

    default:
      /* xgettext:c-format */
      infprintf (is,
		 _("# internal disassembler error, "
		   "unrecognised modifier (%c)"),
		 type);
      abort ();
d1603 1
d1614 2
d1726 1
d1745 2
a1746 2
	      print_mips16_insn_arg (*s, op, insn, use_extend, extend, memaddr,
				     info);
a1765 1
#undef GET_OP_S
@


1.109
log
@include/opcode/
	* mips.h: Remove documentation of "[" and "]".  Update documentation
	of "k" and the MDMX formats.

opcodes/
	* mips-opc.c (mips_builtin_opcodes): Use "Q" for the INSN_5400
	MDMX-like instructions.
	* mips-dis.c (print_insn_arg): Use "$f" rather than "$v" when
	printing "Q" operands for INSN_5400 instructions.

gas/
	* config/tc-mips.c (validate_mips_insn): Remove "[" and "]" handling.
	(mips_ip): Likewise.  Do not set is_mdmx for INSN_5400 instructions.
	Check constraints on the VR5400 RZU.OB, SLL.OB and SRL.OB instructions.

gas/testsuite/
	* gas/mips/vr5400-ill.s, gas/mips/vr5400-ill.l: New test.
	* gas/mips/mips.exp: Run it.
@
text
@a59 83
/* The microMIPS registers with type b.  */
#define micromips_to_32_reg_b_map	mips16_to_32_reg_map

/* The microMIPS registers with type c.  */
#define micromips_to_32_reg_c_map	mips16_to_32_reg_map

/* The microMIPS registers with type d.  */
#define micromips_to_32_reg_d_map	mips16_to_32_reg_map

/* The microMIPS registers with type e.  */
#define micromips_to_32_reg_e_map	mips16_to_32_reg_map

/* The microMIPS registers with type f.  */
#define micromips_to_32_reg_f_map	mips16_to_32_reg_map

/* The microMIPS registers with type g.  */
#define micromips_to_32_reg_g_map	mips16_to_32_reg_map

/* The microMIPS registers with type h.  */
static const unsigned int micromips_to_32_reg_h_map1[] =
{
  5, 5, 6, 4, 4, 4, 4, 4
};
static const unsigned int micromips_to_32_reg_h_map2[] =
{
  6, 7, 7, 21, 22, 5, 6, 7
};

/* The microMIPS registers with type j: 32 registers.  */

/* The microMIPS registers with type l.  */
#define micromips_to_32_reg_l_map	mips16_to_32_reg_map

/* The microMIPS registers with type m.  */
static const unsigned int micromips_to_32_reg_m_map[] =
{
  0, 17, 2, 3, 16, 18, 19, 20
};

/* The microMIPS registers with type n.  */
#define micromips_to_32_reg_n_map      micromips_to_32_reg_m_map

/* The microMIPS registers with type p: 32 registers.  */

/* The microMIPS registers with type q.  */
static const unsigned int micromips_to_32_reg_q_map[] =
{
  0, 17, 2, 3, 4, 5, 6, 7
};

/* reg type s is $29.  */

/* reg type t is the same as the last register.  */

/* reg type y is $31.  */

/* reg type z is $0.  */

/* micromips imm B type.  */
static const int micromips_imm_b_map[8] =
{
  1, 4, 8, 12, 16, 20, 24, -1
};

/* micromips imm C type.  */
static const int micromips_imm_c_map[16] =
{
  128, 1, 2, 3, 4, 7, 8, 15, 16, 31, 32, 63, 64, 255, 32768, 65535
};

/* micromips imm D type: (-512..511)<<1.  */
/* micromips imm E type: (-64..63)<<1.  */
/* micromips imm F type: (0..63).  */
/* micromips imm G type: (-1..14).  */
/* micromips imm H type: (0..15)<<1.  */
/* micromips imm I type: (-1..126).  */
/* micromips imm J type: (0..15)<<2.  */
/* micromips imm L type: (0..15).  */
/* micromips imm M type: (1..8).  */
/* micromips imm W type: (0..63)<<2.  */
/* micromips imm X type: (-8..7).  */
/* micromips imm Y type: (-258..-3, 2..257)<<2.  */

d884 2
a885 2

/* Print insn arguments for 32/64-bit code.  */
d888 2
a889 5
print_insn_args (const char *d,
		 int l,
		 bfd_vma pc,
		 struct disassemble_info *info,
		 const struct mips_opcode *opp)
d891 1
a891 12
  const fprintf_ftype infprintf = info->fprintf_func;
  unsigned int lsb, msb, msbd, cpreg;
  void *is = info->stream;

  lsb = 0;

#define GET_OP(insn, field) \
  (((insn) >> OP_SH_##field) & OP_MASK_##field)
#define GET_OP_S(insn, field) \
  ((GET_OP (insn, field) ^ ((OP_MASK_##field >> 1) + 1)) \
   - ((OP_MASK_##field >> 1) + 1))
  for (; *d != '\0'; d++)
d893 3
a895 7
      switch (*d)
	{
	case ',':
	case '(':
	case ')':
	  infprintf (is, "%c", *d);
	  break;
d897 3
a899 11
	case '+':
	  /* Extension character; switch for second char.  */
	  d++;
	  switch (*d)
	    {
	    case '\0':
	      /* xgettext:c-format */
	      infprintf (is,
			 _("# internal error, "
			   "incomplete extension sequence (+)"));
	      return;
d901 6
a906 105
	    case 'A':
	      lsb = GET_OP (l, SHAMT);
	      infprintf (is, "0x%x", lsb);
	      break;
	
	    case 'B':
	      msb = GET_OP (l, INSMSB);
	      infprintf (is, "0x%x", msb - lsb + 1);
	      break;

	    case '1':
	      infprintf (is, "0x%x", GET_OP (l, UDI1));
	      break;
	      
	    case '2':
	      infprintf (is, "0x%x", GET_OP (l, UDI2));
	      break;
	      
	    case '3':
	      infprintf (is, "0x%x", GET_OP (l, UDI3));
	      break;
      
	    case '4':
	      infprintf (is, "0x%x", GET_OP (l, UDI4));
	      break;
	      
	    case 'C':
	    case 'H':
	      msbd = GET_OP (l, EXTMSBD);
	      infprintf (is, "0x%x", msbd + 1);
	      break;

	    case 'E':
	      lsb = GET_OP (l, SHAMT) + 32;
	      infprintf (is, "0x%x", lsb);
	      break;
	
	    case 'F':
	      msb = GET_OP (l, INSMSB) + 32;
	      infprintf (is, "0x%x", msb - lsb + 1);
	      break;

	    case 'G':
	      msbd = GET_OP (l, EXTMSBD) + 32;
	      infprintf (is, "0x%x", msbd + 1);
	      break;

	    case 'J':		/* hypcall operand */
	      infprintf (is, "0x%x", GET_OP (l, CODE10));
	      break;

	    case 't': /* Coprocessor 0 reg name */
	      infprintf (is, "%s", mips_cp0_names[GET_OP (l, RT)]);
	      break;

	    case 'x':		/* bbit bit index */
	      infprintf (is, "0x%x", GET_OP (l, BBITIND));
	      break;

	    case 'p':		/* cins, cins32, exts and exts32 position */
	      infprintf (is, "0x%x", GET_OP (l, CINSPOS));
	      break;

	    case 's':		/* cins32 and exts32 length-minus-one */
	    case 'S':		/* cins and exts length-minus-one field */
	      infprintf (is, "0x%x", GET_OP (l, CINSLM1));
	      break;

	    case 'Q':		/* seqi/snei immediate field */
	      infprintf (is, "%d", GET_OP_S (l, SEQI));
	      break;

	    case 'a':		/* 8-bit signed offset in bit 6 */
	      infprintf (is, "%d", GET_OP_S (l, OFFSET_A));
	      break;

	    case 'b':		/* 8-bit signed offset in bit 3 */
	      infprintf (is, "%d", GET_OP_S (l, OFFSET_B));
	      break;

	    case 'c':		/* 9-bit signed offset in bit 6 */
	      /* Left shift 4 bits to print the real offset.  */
	      infprintf (is, "%d", GET_OP_S (l, OFFSET_C) << 4);
	      break;

	    case 'z':
	      infprintf (is, "%s", mips_gpr_names[GET_OP (l, RZ)]);
	      break;

	    case 'Z':
	      infprintf (is, "%s", mips_fpr_names[GET_OP (l, FZ)]);
	      break;

	    case 'i': /* JALX destination */
	      info->target = (((pc + 4) & ~(bfd_vma) 0x0fffffff)
			      | (GET_OP (l, TARGET) << 2));
	      /* For gdb disassembler, force odd address on jalx.  */
	      if (info->flavour == bfd_target_unknown_flavour)
		info->target |= 1;
	      (*info->print_address_func) (info->target, info);
	      break;

	    case 'j':	/* 9-bit signed offset in bit 7.  */
	      infprintf (is, "%d", GET_OP_S (l, EVAOFFSET));
	      break;
d908 6
a913 9
	    default:
	      /* xgettext:c-format */
	      infprintf (is,
			 _("# internal error, "
			   "undefined extension sequence (+%c)"),
			 *d);
	      return;
	    }
	  break;
d915 3
a917 3
	case '2':
	  infprintf (is, "0x%x", GET_OP (l, BP));
	  break;
d919 6
a924 3
	case '3':
	  infprintf (is, "0x%x", GET_OP (l, SA3));
	  break;
d926 12
a937 3
	case '4':
	  infprintf (is, "0x%x", GET_OP (l, SA4));
	  break;
d939 5
a943 3
	case '5':
	  infprintf (is, "0x%x", GET_OP (l, IMM8));
	  break;
d945 1
a945 3
	case '6':
	  infprintf (is, "0x%x", GET_OP (l, RS));
	  break;
d947 5
a951 3
	case '7':
	  infprintf (is, "$ac%d", GET_OP (l, DSPACC));
	  break;
d953 3
a955 3
	case '8':
	  infprintf (is, "0x%x", GET_OP (l, WRDSP));
	  break;
d957 10
a966 3
	case '9':
	  infprintf (is, "$ac%d", GET_OP (l, DSPACC_S));
	  break;
d968 5
a972 3
	case '0': /* dsp 6-bit signed immediate in bit 20 */
	  infprintf (is, "%d", GET_OP_S (l, DSPSFT));
	  break;
d974 9
a982 3
	case ':': /* dsp 7-bit signed immediate in bit 19 */
	  infprintf (is, "%d", GET_OP_S (l, DSPSFT_7));
	  break;
d984 3
a986 3
	case '~':
	  infprintf (is, "%d", GET_OP_S (l, OFFSET12));
	  break;
d988 9
a996 3
	case '\\':
	  infprintf (is, "0x%x", GET_OP (l, 3BITPOS));
	  break;
d998 3
a1000 3
	case '\'':
	  infprintf (is, "0x%x", GET_OP (l, RDDSP));
	  break;
d1002 7
a1008 3
	case '@@': /* dsp 10-bit signed immediate in bit 16 */
	  infprintf (is, "%d", GET_OP_S (l, IMM10));
	  break;
d1010 3
a1012 3
	case '!':
	  infprintf (is, "%d", GET_OP (l, MT_U));
	  break;
d1014 4
a1017 3
	case '$':
	  infprintf (is, "%d", GET_OP (l, MT_H));
	  break;
d1019 4
a1022 3
	case '*':
	  infprintf (is, "$ac%d", GET_OP (l, MTACC_T));
	  break;
d1024 3
a1026 3
	case '&':
	  infprintf (is, "$ac%d", GET_OP (l, MTACC_D));
	  break;
d1028 8
a1035 4
	case 'g':
	  /* Coprocessor register for CTTC1, MTTC2, MTHC2, CTTC2.  */
	  infprintf (is, "$%d", GET_OP (l, RD));
	  break;
d1037 3
a1039 6
	case 's':
	case 'b':
	case 'r':
	case 'v':
	  infprintf (is, "%s", mips_gpr_names[GET_OP (l, RS)]);
	  break;
d1041 2
a1042 4
	case 't':
	case 'w':
	  infprintf (is, "%s", mips_gpr_names[GET_OP (l, RT)]);
	  break;
d1044 4
a1047 4
	case 'i':
	case 'u':
	  infprintf (is, "0x%x", GET_OP (l, IMMEDIATE));
	  break;
d1049 3
a1051 4
	case 'j': /* Same as i, but sign-extended.  */
	case 'o':
	  infprintf (is, "%d", GET_OP_S (l, DELTA));
	  break;
d1053 3
a1055 3
	case 'h':
	  infprintf (is, "0x%x", GET_OP (l, PREFX));
	  break;
d1057 3
a1059 3
	case 'k':
	  infprintf (is, "0x%x", GET_OP (l, CACHE));
	  break;
d1061 6
a1066 5
	case 'a':
	  info->target = (((pc + 4) & ~(bfd_vma) 0x0fffffff)
			  | (GET_OP (l, TARGET) << 2));
	  (*info->print_address_func) (info->target, info);
	  break;
d1068 3
a1070 5
	case 'p':
	  /* Sign extend the displacement.  */
	  info->target = (GET_OP_S (l, DELTA) << 2) + pc + INSNLEN;
	  (*info->print_address_func) (info->target, info);
	  break;
d1072 13
a1084 3
	case 'd':
	  infprintf (is, "%s", mips_gpr_names[GET_OP (l, RD)]);
	  break;
d1086 16
a1101 4
	case 'U':
	  {
	    /* First check for both rd and rt being equal.  */
	    unsigned int reg;
d1103 17
a1119 17
	    reg = GET_OP (l, RD);
	    if (reg == GET_OP (l, RT))
	      infprintf (is, "%s", mips_gpr_names[reg]);
	    else
	      {
		/* If one is zero use the other.  */
		if (reg == 0)
		  infprintf (is, "%s", mips_gpr_names[GET_OP (l, RT)]);
		else if (GET_OP (l, RT) == 0)
		  infprintf (is, "%s", mips_gpr_names[reg]);
		else /* Bogus, result depends on processor.  */
		  infprintf (is, "%s or %s",
			     mips_gpr_names[reg],
			     mips_gpr_names[GET_OP (l, RT)]);
	      }
	  }
	  break;
d1121 9
a1129 3
	case 'z':
	  infprintf (is, "%s", mips_gpr_names[0]);
	  break;
d1131 3
a1133 4
	case '<':
	case '1':
	  infprintf (is, "0x%x", GET_OP (l, SHAMT));
	  break;
d1135 5
a1139 3
	case 'c':
	  infprintf (is, "0x%x", GET_OP (l, CODE));
	  break;
d1141 13
a1153 3
	case 'q':
	  infprintf (is, "0x%x", GET_OP (l, CODE2));
	  break;
d1155 3
a1157 3
	case 'C':
	  infprintf (is, "0x%x", GET_OP (l, COPZ));
	  break;
d1159 3
a1161 3
	case 'B':
	  infprintf (is, "0x%x", GET_OP (l, CODE20));
	  break;
d1163 5
a1167 8
	case 'J':
	  infprintf (is, "0x%x", GET_OP (l, CODE19));
	  break;

	case 'S':
	case 'V':
	  infprintf (is, "%s", mips_fpr_names[GET_OP (l, FS)]);
	  break;
d1169 3
a1171 4
	case 'T':
	case 'W':
	  infprintf (is, "%s", mips_fpr_names[GET_OP (l, FT)]);
	  break;
d1173 11
a1183 3
	case 'D':
	  infprintf (is, "%s", mips_fpr_names[GET_OP (l, FD)]);
	  break;
d1185 9
a1193 2
	case 'R':
	  infprintf (is, "%s", mips_fpr_names[GET_OP (l, FR)]);
d1196 3
a1198 12
	case 'E':
	  cpreg = GET_OP (l, RT);
	  goto copro;

	case 'G':
	  cpreg = GET_OP (l, RD);
	copro:
	  /* Coprocessor register for mtcN instructions, et al.  Note
	     that FPU (cp1) instructions disassemble this field using
	     'S' format.  Therefore, we only need to worry about cp0,
	     cp2, and cp3.  */
	  if (opp->name[strlen (opp->name) - 1] == '0')
d1200 30
a1229 21
	      if (d[1] == ',' && d[2] == 'H')
		{
		  const struct mips_cp0sel_name *n;
		  unsigned int sel;

		  sel = GET_OP (l, SEL);

		  /* CP0 register including 'sel' code for mtcN (et al.), to be
		     printed textually if known.  If not known, print both
		     CP0 register name and sel numerically since CP0 register
		     with sel 0 may have a name unrelated to register being
		     printed.  */
		  n = lookup_mips_cp0sel_name (mips_cp0sel_names,
					       mips_cp0sel_names_len,
					       cpreg, sel);
		  if (n != NULL)
		    infprintf (is, "%s", n->name);
		  else
		    infprintf (is, "$%d,%d", cpreg, sel);
		  d += 2;
		}
d1231 1
a1231 1
		infprintf (is, "%s", mips_cp0_names[cpreg]);
d1234 4
a1237 66
	    infprintf (is, "$%d", cpreg);
	  break;

	case 'K':
	  infprintf (is, "%s", mips_hwr_names[GET_OP (l, RD)]);
	  break;

	case 'N':
	  infprintf (is,
		     (opp->pinfo & (FP_D | FP_S)) != 0 ? "$fcc%d" : "$cc%d",
		     GET_OP (l, BCC));
	  break;

	case 'M':
	  infprintf (is, "$fcc%d", GET_OP (l, CCC));
	  break;

	case 'P':
	  infprintf (is, "%d", GET_OP (l, PERFREG));
	  break;

	case 'e':
	  infprintf (is, "%d", GET_OP (l, VECBYTE));
	  break;

	case '%':
	  infprintf (is, "%d", GET_OP (l, VECALIGN));
	  break;

	case 'H':
	  infprintf (is, "%d", GET_OP (l, SEL));
	  break;

	case 'O':
	  infprintf (is, "%d", GET_OP (l, ALN));
	  break;

	case 'Q':
	  {
	    unsigned int vsel = GET_OP (l, VSEL);
	    char prefix;

	    prefix = opp->membership & INSN_5400 ? 'f' : 'v';
	    if ((vsel & 0x10) == 0)
	      {
		int fmt;

		vsel &= 0x0f;
		for (fmt = 0; fmt < 3; fmt++, vsel >>= 1)
		  if ((vsel & 1) == 0)
		    break;
		infprintf (is, "$%c%d[%d]", prefix, GET_OP (l, FT), vsel >> 1);
	      }
	    else if ((vsel & 0x08) == 0)
	      {
		infprintf (is, "$%c%d", prefix, GET_OP (l, FT));
	      }
	    else
	      {
		infprintf (is, "0x%x", GET_OP (l, FT));
	      }
	  }
	  break;

	case 'X':
	  infprintf (is, "$v%d", GET_OP (l, FD));
a1238 13

	case 'Y':
	  infprintf (is, "$v%d", GET_OP (l, FS));
	  break;

	case 'Z':
	  infprintf (is, "$v%d", GET_OP (l, FT));
	  break;

	default:
	  /* xgettext:c-format */
	  infprintf (is, _("# internal error, undefined modifier (%c)"), *d);
	  return;
d1253 2
a1301 2
	      const char *d;

d1332 1
a1332 2
	      d = op->args;
	      if (d != NULL && *d != '\0')
d1335 2
a1336 1
		  print_insn_args (d, word, memaddr, info, op);
a1342 1
#undef GET_OP_S
a2038 1
  unsigned int lsb, msbd, msb;
a2039 1
  unsigned int regno;
d2041 2
a2042 3
  int lastregno = 0;
  int higher;
  int length;
d2044 1
a2044 5
  int delta;
  int immed;
  int insn;

  lsb = 0;
a2127 5
#define GET_OP(insn, field) \
  (((insn) >> MICROMIPSOP_SH_##field) & MICROMIPSOP_MASK_##field)
#define GET_OP_S(insn, field) \
  ((GET_OP (insn, field) ^ ((MICROMIPSOP_MASK_##field >> 1) + 1)) \
   - ((MICROMIPSOP_MASK_##field >> 1) + 1))
a2136 2
	  const char *s;

a2137 2
	  if (op->args[0] != '\0')
	    infprintf (is, "\t");
d2139 1
a2139 1
	  for (s = op->args; *s != '\0'; s++)
d2141 3
a2143 555
	      switch (*s)
		{
		case ',':
		case '(':
		case ')':
		  infprintf (is, "%c", *s);
		  break;

		case '.':
		  infprintf (is, "%d", GET_OP_S (insn, OFFSET10));
		  break;

		case '1':
		  infprintf (is, "0x%x", GET_OP (insn, STYPE));
		  break;

		case '2':
		  infprintf (is, "0x%x", GET_OP (insn, BP));
		  break;

		case '3':
		  infprintf (is, "0x%x", GET_OP (insn, SA3));
		  break;

		case '4':
		  infprintf (is, "0x%x", GET_OP (insn, SA4));
		  break;

		case '5':
		  infprintf (is, "0x%x", GET_OP (insn, IMM8));
		  break;

		case '6':
		  infprintf (is, "0x%x", GET_OP (insn, RS));
		  break;

		case '7':
		  infprintf (is, "$ac%d", GET_OP (insn, DSPACC));
		  break;

		case '8':
		  infprintf (is, "0x%x", GET_OP (insn, WRDSP));
		  break;

		case '0': /* DSP 6-bit signed immediate in bit 16.  */
		  delta = (GET_OP (insn, DSPSFT) ^ 0x20) - 0x20;
		  infprintf (is, "%d", delta);
		  break;

		case '<':
		  infprintf (is, "0x%x", GET_OP (insn, SHAMT));
		  break;

		case '\\':
		  infprintf (is, "0x%x", GET_OP (insn, 3BITPOS));
		  break;

		case '^':
		  infprintf (is, "0x%x", GET_OP (insn, RD));
		  break;

		case '|':
		  infprintf (is, "0x%x", GET_OP (insn, TRAP));
		  break;

		case '~':
		  infprintf (is, "%d", GET_OP_S (insn, OFFSET12));
		  break;

		case 'a':
		  info->target = (((memaddr + 4) & ~(bfd_vma) 0x07ffffff)
				  | (GET_OP (insn, TARGET) << 1));
		  /* For gdb disassembler, maintain odd address.  */
		  if (info->flavour == bfd_target_unknown_flavour)
		    info->target |= 1;
		  (*info->print_address_func) (info->target, info);
		  break;

		case 'b':
		case 'r':
		case 's':
		case 'v':
		  infprintf (is, "%s", mips_gpr_names[GET_OP (insn, RS)]);
		  break;

		case 'c':
		  infprintf (is, "0x%x", GET_OP (insn, CODE));
		  break;

		case 'd':
		  infprintf (is, "%s", mips_gpr_names[GET_OP (insn, RD)]);
		  break;

		case 'h':
		  infprintf (is, "0x%x", GET_OP (insn, PREFX));
		  break;

		case 'i':
		case 'u':
		  infprintf (is, "0x%x", GET_OP (insn, IMMEDIATE));
		  break;

		case 'j': /* Same as i, but sign-extended.  */
		case 'o':
		  infprintf (is, "%d", GET_OP_S (insn, DELTA));
		  break;

		case 'k':
		  infprintf (is, "0x%x", GET_OP (insn, CACHE));
		  break;

		case 'n':
		  {
		    int s_reg_encode;

		    immed = GET_OP (insn, RT);
		    s_reg_encode = immed & 0xf;
		    if (s_reg_encode != 0)
		      {
			if (s_reg_encode == 1)
			  infprintf (is, "%s", mips_gpr_names[16]);
			else if (s_reg_encode < 9)
			  infprintf (is, "%s-%s",
				   mips_gpr_names[16],
				   mips_gpr_names[15 + s_reg_encode]);
			else if (s_reg_encode == 9)
			  infprintf (is, "%s-%s,%s",
				   mips_gpr_names[16],
				   mips_gpr_names[23],
				   mips_gpr_names[30]);
			else
			  infprintf (is, "UNKNOWN");
		      }

		    if (immed & 0x10) /* For ra.  */
		      {
			if (s_reg_encode == 0)
			  infprintf (is, "%s", mips_gpr_names[31]);
			else
			  infprintf (is, ",%s", mips_gpr_names[31]);
		      }
		    break;
		  }

		case 'p':
		  /* Sign-extend the displacement.  */
		  delta = GET_OP_S (insn, DELTA);
		  info->target = (delta << 1) + memaddr + length;
		  (*info->print_address_func) (info->target, info);
		  break;

		case 'q':
		  infprintf (is, "0x%x", GET_OP (insn, CODE2));
		  break;

		case 't':
		case 'w':
		  infprintf (is, "%s", mips_gpr_names[GET_OP (insn, RT)]);
		  break;

		case 'y':
		  infprintf (is, "%s", mips_gpr_names[GET_OP (insn, RS3)]);
		  break;

		case 'z':
		  infprintf (is, "%s", mips_gpr_names[0]);
		  break;

		case '@@': /* DSP 10-bit signed immediate in bit 16.  */
		  delta = (GET_OP (insn, IMM10) ^ 0x200) - 0x200;
		  infprintf (is, "%d", delta);
		  break;

		case 'B':
		  infprintf (is, "0x%x", GET_OP (insn, CODE10));
		  break;

		case 'C':
		  infprintf (is, "0x%x", GET_OP (insn, COPZ));
		  break;

		case 'D':
		  infprintf (is, "%s", mips_fpr_names[GET_OP (insn, FD)]);
		  break;

		case 'E':
		  /* Coprocessor register for lwcN instructions, et al.

		    Note that there is no load/store cp0 instructions, and
		    that FPU (cp1) instructions disassemble this field using
		    'T' format.  Therefore, until we gain understanding of
		    cp2 register names, we can simply print the register
		    numbers.  */
		  infprintf (is, "$%d", GET_OP (insn, RT));
		  break;

		case 'G':
		  /* Coprocessor register for mtcN instructions, et al.  Note
		     that FPU (cp1) instructions disassemble this field using
		     'S' format.  Therefore, we only need to worry about cp0,
		     cp2, and cp3.  */
		  if (op->name[strlen (op->name) - 1] == '0')
		    {
		      if (s[1] == ',' && s[2] == 'H')
			{
			  const struct mips_cp0sel_name *n;
			  unsigned int cp0reg, sel;

			  cp0reg = GET_OP (insn, RS);
			  sel = GET_OP (insn, SEL);

			  /* CP0 register including 'sel' code for mtcN
			     (et al.), to be printed textually if known.
			     If not known, print both CP0 register name and
			     sel numerically since CP0 register with sel 0 may
			     have a name unrelated to register being
			     printed.  */
			  n = lookup_mips_cp0sel_name (mips_cp0sel_names,
						       mips_cp0sel_names_len,
						       cp0reg, sel);
			  if (n != NULL)
			    infprintf (is, "%s", n->name);
			  else
			    infprintf (is, "$%d,%d", cp0reg, sel);
			  s += 2;
			}
		      else
			infprintf (is, "%s", mips_cp0_names[GET_OP (insn, RS)]);
		    }
		  else
		    infprintf (is, "$%d", GET_OP (insn, RS));
		  break;

		case 'H':
		  infprintf (is, "%d", GET_OP (insn, SEL));
		  break;

		case 'K':
		  infprintf (is, "%s", mips_hwr_names[GET_OP (insn, RS)]);
		  break;

		case 'M':
		  infprintf (is, "$fcc%d", GET_OP (insn, CCC));
		  break;

		case 'N':
		  infprintf (is,
			   (op->pinfo & (FP_D | FP_S)) != 0
			   ? "$fcc%d" : "$cc%d",
			   GET_OP (insn, BCC));
		  break;

		case 'R':
		  infprintf (is, "%s", mips_fpr_names[GET_OP (insn, FR)]);
		  break;

		case 'S':
		case 'V':
		  infprintf (is, "%s", mips_fpr_names[GET_OP (insn, FS)]);
		  break;

		case 'T':
		  infprintf (is, "%s", mips_fpr_names[GET_OP (insn, FT)]);
		  break;

		case '+':
		  /* Extension character; switch for second char.  */
		  s++;
		  switch (*s)
		    {
		    case 'A':
		      lsb = GET_OP (insn, EXTLSB);
		      infprintf (is, "0x%x", lsb);
		      break;

		    case 'B':
		      msb = GET_OP (insn, INSMSB);
		      infprintf (is, "0x%x", msb - lsb + 1);
		      break;

		    case 'C':
		    case 'H':
		      msbd = GET_OP (insn, EXTMSBD);
		      infprintf (is, "0x%x", msbd + 1);
		      break;

		    case 'E':
		      lsb = GET_OP (insn, EXTLSB) + 32;
		      infprintf (is, "0x%x", lsb);
		      break;

		    case 'F':
		      msb = GET_OP (insn, INSMSB) + 32;
		      infprintf (is, "0x%x", msb - lsb + 1);
		      break;

		    case 'G':
		      msbd = GET_OP (insn, EXTMSBD) + 32;
		      infprintf (is, "0x%x", msbd + 1);
		      break;

		    case 'i':
		      info->target = (((memaddr + 4) & ~(bfd_vma) 0x0fffffff)
				      | (GET_OP (insn, TARGET) << 2));
		      (*info->print_address_func) (info->target, info);
		      break;

		    case 'j':   /* 9-bit signed offset in bit 0. */
		      delta = GET_OP_S (insn, EVAOFFSET);
		      infprintf (is, "%d", delta);
		      break;

		    default:
		      /* xgettext:c-format */
		      infprintf (is,
			       _("# internal disassembler error, "
				 "unrecognized modifier (+%c)"),
			       *s);
		      abort ();
		    }
		  break;

		case 'm':
		  /* Extension character; switch for second char.  */
		  s++;
		  switch (*s)
		    {
		    case 'a':	/* global pointer.  */
		      infprintf (is, "%s", mips_gpr_names[28]);
		      break;

		    case 'b':
		      regno = micromips_to_32_reg_b_map[GET_OP (insn, MB)];
		      infprintf (is, "%s", mips_gpr_names[regno]);
		      break;

		    case 'c':
		      regno = micromips_to_32_reg_c_map[GET_OP (insn, MC)];
		      infprintf (is, "%s", mips_gpr_names[regno]);
		      break;

		    case 'd':
		      regno = micromips_to_32_reg_d_map[GET_OP (insn, MD)];
		      infprintf (is, "%s", mips_gpr_names[regno]);
		      break;

		    case 'e':
		      regno = micromips_to_32_reg_e_map[GET_OP (insn, ME)];
		      infprintf (is, "%s", mips_gpr_names[regno]);
		      break;

		    case 'f':
		      /* Save lastregno for "mt" to print out later.  */
		      lastregno = micromips_to_32_reg_f_map[GET_OP (insn, MF)];
		      infprintf (is, "%s", mips_gpr_names[lastregno]);
		      break;

		    case 'g':
		      regno = micromips_to_32_reg_g_map[GET_OP (insn, MG)];
		      infprintf (is, "%s", mips_gpr_names[regno]);
		      break;

		    case 'h':
		      regno = micromips_to_32_reg_h_map1[GET_OP (insn, MH)];
		      infprintf (is, "%s", mips_gpr_names[regno]);
		      regno = micromips_to_32_reg_h_map2[GET_OP (insn, MH)];
		      infprintf (is, ",%s", mips_gpr_names[regno]);
		      break;

		    case 'j':
		      infprintf (is, "%s", mips_gpr_names[GET_OP (insn, MJ)]);
		      break;

		    case 'l':
		      regno = micromips_to_32_reg_l_map[GET_OP (insn, ML)];
		      infprintf (is, "%s", mips_gpr_names[regno]);
		      break;

		    case 'm':
		      regno = micromips_to_32_reg_m_map[GET_OP (insn, MM)];
		      infprintf (is, "%s", mips_gpr_names[regno]);
		      break;

		    case 'n':
		      regno = micromips_to_32_reg_n_map[GET_OP (insn, MN)];
		      infprintf (is, "%s", mips_gpr_names[regno]);
		      break;

		    case 'p':
		      /* Save lastregno for "mt" to print out later.  */
		      lastregno = GET_OP (insn, MP);
		      infprintf (is, "%s", mips_gpr_names[lastregno]);
		      break;

		    case 'q':
		      regno = micromips_to_32_reg_q_map[GET_OP (insn, MQ)];
		      infprintf (is, "%s", mips_gpr_names[regno]);
		      break;

		    case 'r':	/* program counter.  */
		      infprintf (is, "$pc");
		      break;

		    case 's':	/* stack pointer.  */
		      lastregno = 29;
		      infprintf (is, "%s", mips_gpr_names[29]);
		      break;

		    case 't':
		      infprintf (is, "%s", mips_gpr_names[lastregno]);
		      break;

		    case 'z':	/* $0.  */
		      infprintf (is, "%s", mips_gpr_names[0]);
		      break;

		    case 'A':
		      /* Sign-extend the immediate.  */
		      immed = GET_OP_S (insn, IMMA) << 2;
		      infprintf (is, "%d", immed);
		      break;

		    case 'B':
		      immed = micromips_imm_b_map[GET_OP (insn, IMMB)];
		      infprintf (is, "%d", immed);
		      break;

		    case 'C':
		      immed = micromips_imm_c_map[GET_OP (insn, IMMC)];
		      infprintf (is, "0x%x", immed);
		      break;

		    case 'D':
		      /* Sign-extend the displacement.  */
		      delta = GET_OP_S (insn, IMMD);
		      info->target = (delta << 1) + memaddr + length;
		      (*info->print_address_func) (info->target, info);
		      break;

		    case 'E':
		      /* Sign-extend the displacement.  */
		      delta = GET_OP_S (insn, IMME);
		      info->target = (delta << 1) + memaddr + length;
		      (*info->print_address_func) (info->target, info);
		      break;

		    case 'F':
		      immed = GET_OP (insn, IMMF);
		      infprintf (is, "0x%x", immed);
		      break;

		    case 'G':
		      immed = (insn >> MICROMIPSOP_SH_IMMG) + 1;
		      immed = (immed & MICROMIPSOP_MASK_IMMG) - 1;
		      infprintf (is, "%d", immed);
		      break;

		    case 'H':
		      immed = GET_OP (insn, IMMH) << 1;
		      infprintf (is, "%d", immed);
		      break;

		    case 'I':
		      immed = (insn >> MICROMIPSOP_SH_IMMI) + 1;
		      immed = (immed & MICROMIPSOP_MASK_IMMI) - 1;
		      infprintf (is, "%d", immed);
		      break;

		    case 'J':
		      immed = GET_OP (insn, IMMJ) << 2;
		      infprintf (is, "%d", immed);
		      break;

		    case 'L':
		      immed = GET_OP (insn, IMML);
		      infprintf (is, "%d", immed);
		      break;

		    case 'M':
		      immed = (insn >> MICROMIPSOP_SH_IMMM) - 1;
		      immed = (immed & MICROMIPSOP_MASK_IMMM) + 1;
		      infprintf (is, "%d", immed);
		      break;

		    case 'N':
		      immed = GET_OP (insn, IMMN);
		      if (immed == 0)
			infprintf (is, "%s,%s",
				 mips_gpr_names[16],
				 mips_gpr_names[31]);
		      else
			infprintf (is, "%s-%s,%s",
				 mips_gpr_names[16],
				 mips_gpr_names[16 + immed],
				 mips_gpr_names[31]);
		      break;

		    case 'O':
		      immed = GET_OP (insn, IMMO);
		      infprintf (is, "0x%x", immed);
		      break;

		    case 'P':
		      immed = GET_OP (insn, IMMP) << 2;
		      infprintf (is, "%d", immed);
		      break;

		    case 'Q':
		      /* Sign-extend the immediate.  */
		      immed = GET_OP_S (insn, IMMQ) << 2;
		      infprintf (is, "%d", immed);
		      break;

		    case 'U':
		      immed = GET_OP (insn, IMMU) << 2;
		      infprintf (is, "%d", immed);
		      break;

		    case 'W':
		      immed = GET_OP (insn, IMMW) << 2;
		      infprintf (is, "%d", immed);
		      break;

		    case 'X':
		      /* Sign-extend the immediate.  */
		      immed = GET_OP_S (insn, IMMX);
		      infprintf (is, "%d", immed);
		      break;

		    case 'Y':
		      /* Sign-extend the immediate.  */
		      immed = GET_OP_S (insn, IMMY) << 2;
		      if ((unsigned int) (immed + 8) < 16)
			immed ^= 0x400;
		      infprintf (is, "%d", immed);
		      break;

		    default:
		      /* xgettext:c-format */
		      infprintf (is,
			       _("# internal disassembler error, "
				 "unrecognized modifier (m%c)"),
			       *s);
		      abort ();
		    }
		  break;

		default:
		  /* xgettext:c-format */
		  infprintf (is,
			   _("# internal disassembler error, "
			     "unrecognized modifier (%c)"),
			   *s);
		  abort ();
		}
a2172 2
#undef GET_OP_S
#undef GET_OP
@


1.108
log
@include/opcode/
	* mips.h: Update documentation of "+s" and "+S".

opcodes/
	* mips-opc.c (mips_builtin_opcodes): Use "+s" for "cins32" and
	"+S" for "cins".
	* mips-dis.c (print_mips_arg): Update "+s" and "+S" comments.
	Combine cases.

gas/
	* config/tc-mips.c (mips_ip): Preserve the real bit number for "+p".
	Require the msb to be <= 31 for "+s".  Check that the size is <= 31
	for both "+s" and "+S".
@
text
@a994 2
	case '[':
	case ']':
d1397 1
d1399 1
d1408 1
a1408 1
		infprintf (is, "$v%d[%d]", GET_OP (l, FT), vsel >> 1);
d1412 1
a1412 1
		infprintf (is, "$v%d", GET_OP (l, FT));
@


1.107
log
@include/opcode/
	* mips.h: Document "+i".

opcodes/
	* mips-opc.c (mips_builtin_opcodes): Use "+i" rather than "a" for
	"jalx".
	* mips16-opc.c (mips16_opcodes): Likewise.
	* micromips-opc.c (micromips_opcodes): Likewise.
	* mips-dis.c (print_insn_args, print_mips16_insn_arg)
	(print_insn_mips16): Handle "+i".
	(print_insn_micromips): Likewise.  Conditionally preserve the
	ISA bit for "a" but not for "+i".

gas/
	* config/tc-mips.c (validate_mips_insn, validate_micromips_insn):
	(mips_ip, mips16_ip): Handle "+i".
@
text
@d1075 2
a1076 5
	    case 's':		/* cins and exts length-minus-one */
	      infprintf (is, "0x%x", GET_OP (l, CINSLM1));
	      break;

	    case 'S':		/* cins32 and exts32 length-minus-one field */
@


1.106
log
@include/opcode/
	* mips.h: Remove "mi" documentation.  Update "mh" documentation.
	(OP_MASK_MI, OP_SH_MI, MICROMIPSOP_MASK_MI, MICROMIPSOP_MASK_MI):
	Delete.
	(INSN2_WRITE_GPR_MHI): Rename to...
	(INSN2_WRITE_GPR_MH): ...this.

opcodes/
	* micromips-opc.c (WR_mhi): Rename to..
	(WR_mh): ...this.
	(micromips_opcodes): Update "movep" entry accordingly.  Replace
	"mh,mi" with "mh".
	* mips-dis.c (micromips_to_32_reg_h_map): Rename to...
	(micromips_to_32_reg_h_map1): ...this.
	(micromips_to_32_reg_i_map): Rename to...
	(micromips_to_32_reg_h_map2): ...this.
	(print_micromips_insn): Remove "mi" case.  Print both registers
	in the pair for "mh".

gas/
	* config/tc-mips.c (mips32_to_micromips_reg_h_map): Delete.
	(micromips_to_32_reg_h_map): Rename to...
	(micromips_to_32_reg_h_map1): ...this.
	(micromips_to_32_reg_i_map): Rename to...
	(micromips_to_32_reg_h_map2): ...this.
	(mips_lookup_reg_pair): New function.
	(gpr_write_mask, macro): Adjust after above renaming.
	(validate_micromips_insn): Remove "mi" handling.
	(mips_ip): Likewise.  Parse both registers in a pair for "mh".
@
text
@d1108 9
a1240 4
	  /* For gdb disassembler, force odd address on jalx.  */
	  if (info->flavour == bfd_target_unknown_flavour
	      && strcmp (opp->name, "jalx") == 0)
	    info->target |= 1;
d1882 1
a1883 2
	int jalx = l & 0x400;

d1887 1
a1887 1
	if (!jalx && info->flavour == bfd_target_unknown_flavour)
d2154 1
a2154 1
	  if (strchr (op->args, 'a') != NULL)
d2429 4
a2432 9
		  if (strcmp (op->name, "jalx") == 0)
		    info->target = (((memaddr + 4) & ~(bfd_vma) 0x0fffffff)
				    | (GET_OP (insn, TARGET) << 2));
		  else
		    info->target = (((memaddr + 4) & ~(bfd_vma) 0x07ffffff)
				    | (GET_OP (insn, TARGET) << 1));
		  /* For gdb disassembler, force odd address on jalx.  */
		  if (info->flavour == bfd_target_unknown_flavour
		      && strcmp (op->name, "jalx") == 0)
d2660 6
@


1.105
log
@include/opcode/
	* mips.h: Remove documentation of "+D" and "+T".

opcodes/
	* mips-opc.c (mips_builtin_opcodes): Remove "+D" and "+T" entries.
	* micromips-opc.c (micromips_opcodes): Likewise.
	* mips-dis.c (print_insn_args, print_insn_micromips): Remove "+D"
	and "+T" handling.  Check for a "0" suffix when deciding whether to
	use coprocessor 0 names.  In that case, also check for ",H" selectors.

gas/
	* config/tc-mips.c (validate_mips_insn, validate_micromips_insn)
	(mips_ip): Remove "+D" and "+T" handling.

gas/testsuite/
	* gas/mips/lb.d, gas/mips/sb.d: Use coprocessor register names
	for LWC0 and SWC0.
@
text
@d79 1
a79 1
static const unsigned int micromips_to_32_reg_h_map[] =
d83 1
a83 3

/* The microMIPS registers with type i.  */
static const unsigned int micromips_to_32_reg_i_map[] =
d2717 1
a2717 6
		      regno = micromips_to_32_reg_h_map[GET_OP (insn, MH)];
		      infprintf (is, "%s", mips_gpr_names[regno]);
		      break;

		    case 'i':
		      regno = micromips_to_32_reg_i_map[GET_OP (insn, MI)];
d2719 2
@


1.104
log
@	bfd/
	* elfxx-mips.h (_bfd_mips_elf_get_synthetic_symtab): New
	prototype.
	* elf32-mips.c (elf_backend_plt_sym_val): Remove macro.
	(bfd_elf32_get_synthetic_symtab): New macro.
	* elfxx-mips.c (plt_entry): New structure.
	(mips_elf_link_hash_entry): Add use_plt_entry member.
	(mips_elf_link_hash_table): Rename plt_entry_size member to
	plt_mips_entry_size.  Add plt_comp_entry_size, plt_mips_offset,
	plt_comp_offset, plt_got_index entries and plt_header_is_comp
	members.
	(STUB_LW_MICROMIPS, STUB_MOVE_MICROMIPS): New macros.
	(STUB_LUI_MICROMIPS, STUB_JALR_MICROMIPS): Likewise.
	(STUB_ORI_MICROMIPS, STUB_LI16U_MICROMIPS): Likewise.
	(STUB_LI16S_MICROMIPS): Likewise.
	(MICROMIPS_FUNCTION_STUB_NORMAL_SIZE): Likewise.
	(MICROMIPS_FUNCTION_STUB_BIG_SIZE): Likewise.
	(micromips_o32_exec_plt0_entry): New variable.
	(mips16_o32_exec_plt_entry): Likewise.
	(micromips_o32_exec_plt_entry): Likewise.
	(mips_elf_link_hash_newfunc): Initialize use_plt_entry.
	(mips_elf_output_extsym): Update to use gotplt_union's plist
	member rather than offset.
	(mips_elf_gotplt_index): Likewise.  Remove the VxWorks
	restriction.  Use MIPS_ELF_GOT_SIZE to calculate GOT address.
	(mips_elf_count_got_symbols): Update to use gotplt_union's plist
	member rather than offset.
	(mips_elf_calculate_relocation): Handle MIPS16/microMIPS PLT
	entries.
	(_bfd_mips_elf_create_dynamic_sections): Don't set PLT sizes
	here.
	(mips_elf_make_plt_record): New function.
	(_bfd_mips_elf_check_relocs): Update comment.  Record occurences
	of JAL relocations that might need a PLT entry.
	(_bfd_mips_elf_adjust_dynamic_symbol): Update to use
	gotplt_union's plist member rather than offset.  Set individual
	PLT entry sizes here.  Handle MIPS16/microMIPS PLT entries.
	Don't set the symbol's value in the symbol table for PLT
	references here.  Don't set the PLT or PLT GOT section sizes
	here.
	(mips_elf_estimate_stub_size): Handle microMIPS stubs.
	(mips_elf_allocate_lazy_stub): Likewise.
	(mips_elf_lay_out_lazy_stubs): Likewise.  Define a _MIPS_STUBS_
	magic symbol.
	(mips_elf_set_plt_sym_value): New function.
	(_bfd_mips_elf_size_dynamic_sections): Set PLT header size and
	PLT and PLT GOT section sizes here.  Set the symbol values in
	the symbol table for PLT references here.  Handle microMIPS
	annotation of the _PROCEDURE_LINKAGE_TABLE_ magic symbol.
	(_bfd_mips_elf_finish_dynamic_symbol): Update to use
	gotplt_union's plist member rather than offset.  Handle
	MIPS16/microMIPS PLT entries.  Handle microMIPS stubs.
	(_bfd_mips_vxworks_finish_dynamic_symbol): Update to use
	gotplt_union's plist member rather than offset.  Use
	MIPS_ELF_GOT_SIZE to calculate GOT address.
	(mips_finish_exec_plt): Handle microMIPS PLT.  Return status.
	(_bfd_mips_elf_finish_dynamic_sections): Handle result from
	mips_finish_exec_plt.
	(_bfd_mips_elf_link_hash_table_create): Update to use
	gotplt_union's plist member rather than offset.
	(_bfd_mips_elf_get_synthetic_symtab): New function.

	include/elf/
	* mips.h (ELF_ST_IS_MIPS_PLT): Respect STO_MIPS16 setting.
	(ELF_ST_SET_MIPS_PLT): Likewise.

	gdb/
	* mips-tdep.c (mips_elf_make_msymbol_special): Handle MIPS16 and
	microMIPS synthetic symbols.

	ld/
	* emulparams/elf32btsmip.sh: Arrange for .got.plt to be placed
	as close to .plt as possible.
	* scripttempl/elf.sc: Handle $INITIAL_READWRITE_SECTIONS and
	$PLT_NEXT_DATA variables.

	ld/testsuite/
	* ld-mips-elf/jalx-2.dd: Update for microMIPS PLT support.
	* ld-mips-elf/pic-and-nonpic-3a.dd: Update for the _MIPS_STUBS_
	magic symbol.
	* ld-mips-elf/pic-and-nonpic-3b.dd: Likewise.
	* ld-mips-elf/pic-and-nonpic-6-n32.dd: Likewise.
	* ld-mips-elf/pic-and-nonpic-6-n64.dd: Likewise.
	* ld-mips-elf/pic-and-nonpic-6-o32.dd: Likewise.
	* ld-mips-elf/stub-dynsym-1-10000.d: Likewise.
	* ld-mips-elf/stub-dynsym-1-2fe80.d: Likewise.
	* ld-mips-elf/stub-dynsym-1-7fff.d: Likewise.
	* ld-mips-elf/stub-dynsym-1-8000.d: Likewise.
	* ld-mips-elf/stub-dynsym-1-fff0.d: Likewise.
	* ld-mips-elf/tlslib-o32.d: Likewise.

	opcodes/
	* mips-dis.c (is_mips16_plt_tail): New function.
	(print_insn_mips16): Handle MIPS16 PLT entry's GOT slot address
	word.
	(is_compressed_mode_p): Handle MIPS16/microMIPS PLT entries.
@
text
@d980 1
a980 1
  unsigned int lsb, msb, msbd;
a981 1
  int op;
a1045 22
	    case 'D':
	      {
		const struct mips_cp0sel_name *n;
		unsigned int cp0reg, sel;

		cp0reg = GET_OP (l, RD);
		sel = GET_OP (l, SEL);

		/* CP0 register including 'sel' code for mtcN (et al.), to be
		   printed textually if known.  If not known, print both
		   CP0 register name and sel numerically since CP0 register
		   with sel 0 may have a name unrelated to register being
		   printed.  */
		n = lookup_mips_cp0sel_name(mips_cp0sel_names,
					    mips_cp0sel_names_len, cp0reg, sel);
		if (n != NULL)
		  infprintf (is, "%s", n->name);
		else
		  infprintf (is, "$%d,%d", cp0reg, sel);
		break;
	      }

a1068 22
	    case 'T': /* Coprocessor 0 reg name */
	      {
		const struct mips_cp0sel_name *n;
		unsigned int cp0reg, sel;

		cp0reg = GET_OP (l, RT);
		sel = GET_OP (l, SEL);

		/* CP0 register including 'sel' code for mftc0, to be
		   printed textually if known.  If not known, print both
		   CP0 register name and sel numerically since CP0 register
		   with sel 0 may have a name unrelated to register being
		   printed.  */
		n = lookup_mips_cp0sel_name(mips_cp0sel_names,
					    mips_cp0sel_names_len, cp0reg, sel);
		if (n != NULL)
		  infprintf (is, "%s", n->name);
		else
		  infprintf (is, "$%d,%d", cp0reg, sel);
		break;
	      }

d1322 2
a1323 9
	  /* Coprocessor register for lwcN instructions, et al.

	     Note that there is no load/store cp0 instructions, and
	     that FPU (cp1) instructions disassemble this field using
	     'T' format.  Therefore, until we gain understanding of
	     cp2 register names, we can simply print the register
	     numbers.  */
	  infprintf (is, "$%d", GET_OP (l, RT));
	  break;
d1326 2
d1332 26
a1357 3
	  op = GET_OP (l, OP);
	  if (op == OP_OP_COP0)
	    infprintf (is, "%s", mips_cp0_names[GET_OP (l, RD)]);
d1359 1
a1359 1
	    infprintf (is, "$%d", GET_OP (l, RD));
d2562 2
a2563 7
		     cp2, and cp3.
		     The microMIPS encoding does not have a coprocessor
		     identifier field as such, so we must work out the
		     coprocessor number by looking at the opcode.  */
		  switch (insn
			  & ~((MICROMIPSOP_MASK_RT << MICROMIPSOP_SH_RT)
			      | (MICROMIPSOP_MASK_RS << MICROMIPSOP_SH_RS)))
d2565 25
a2589 13
		    case 0x000000fc:				/* mfc0  */
		    case 0x000002fc:				/* mtc0  */
		    case 0x000004fc:				/* mfgc0  */
		    case 0x000006fc:				/* mtgc0  */
		    case 0x580000fc:				/* dmfc0 */
		    case 0x580002fc:				/* dmtc0 */
		    case 0x580000e7:				/* dmfgc0 */
		    case 0x580002e7:				/* dmtgc0 */
		      infprintf (is, "%s", mips_cp0_names[GET_OP (insn, RS)]);
		      break;
		    default:
		      infprintf (is, "$%d", GET_OP (insn, RS));
		      break;
d2591 2
a2647 23
		    case 'D':
		      {
			const struct mips_cp0sel_name *n;
			unsigned int cp0reg, sel;

			cp0reg = GET_OP (insn, RS);
			sel = GET_OP (insn, SEL);

			/* CP0 register including 'sel' code for mtcN
			   (et al.), to be printed textually if known.
			   If not known, print both CP0 register name and
			   sel numerically since CP0 register with sel 0 may
			   have a name unrelated to register being printed.  */
			n = lookup_mips_cp0sel_name (mips_cp0sel_names,
						     mips_cp0sel_names_len,
						     cp0reg, sel);
			if (n != NULL)
			  infprintf (is, "%s", n->name);
			else
			  infprintf (is, "$%d,%d", cp0reg, sel);
			break;
		      }

@


1.103
log
@2013-06-17  Catherine Moore  <clm@@codesourcery.com>
	    Maciej W. Rozycki  <macro@@codesourcery.com>
	    Chao-Ying Fu  <fu@@mips.com>

	gas/testsuite/
	* gas/mips/mips.exp: Run new tests.
	* gas/mips/eva.d: New.
	* gas/mips/eva.s: New.
	* gas/mips/micromips@@eva.d: New.

	gas/
	* config/tc-mips.c (mips_set_options): Add ase_eva.
	(mips_set_options mips_opts): Add ase_eva.
	(file_ase_eva): Declare.
	(ISA_SUPPORTS_EVA_ASE): Define.
	(IS_SEXT_9BIT_NUM): Define.
	(MIPS_CPU_ASE_EVA): Define.
	(is_opcode_valid): Add support for ase_eva.
	(macro_build): Likewise.
	(macro): Likewise.
	(validate_mips_insn): Likewise.
	(validate_micromips_insn): Likewise.
	(mips_ip): Likewise.
	(options): Add OPTION_EVA and OPTION_NO_EVA.
	(md_longopts): Add -meva and -mno-eva.
	(md_parse_option): Process new options.
	(mips_after_parse_args): Check for valid EVA combinations.
	(s_mipsset): Likewise.

	include/
	* opcode/mips.h (OP_SH_EVAOFFSET): Define.
	(OP_MASK_EVAOFFSET): Define.
	(INSN_ASE_MASK): Delete.
	(ASE_EVA): Define.
	(M_CACHEE_AB, M_CACHEE_OB): New.
	(M_LBE_OB, M_LBE_AB): New.
	(M_LBUE_OB, M_LBUE_AB): New.
	(M_LHE_OB, M_LHE_AB): New.
	(M_LHUE_OB, M_LHUE_AB): New.
	(M_LLE_AB, M_LLE_OB): New.
	(M_LWE_OB, M_LWE_AB): New.
	(M_LWLE_AB, M_LWLE_OB): New.
	(M_LWRE_AB, M_LWRE_OB): New.
	(M_PREFE_AB, M_PREFE_OB): New.
	(M_SCE_AB, M_SCE_OB): New.
	(M_SBE_OB, M_SBE_AB): New.
	(M_SHE_OB, M_SHE_AB): New.
	(M_SWE_OB, M_SWE_AB): New.
	(M_SWLE_AB, M_SWLE_OB): New.
	(M_SWRE_AB, M_SWRE_OB): New.
	(MICROMIPSOP_SH_EVAOFFSET): Define.
	(MICROMIPSOP_MASK_EVAOFFSET): Define.

	opcodes/
	* micromips-opc.c (EVA): Define.
	(TLBINV): Define.
	(micromips_opcodes): Add EVA opcodes.
	* mips-dis.c (mips_arch_choices): Update for ASE_EVA.
	(print_insn_args): Handle EVA offsets.
	(print_insn_micromips): Likewise.
	* mips-opc.c (EVA): Define.
	(TLBINV): Define.
	(mips_builtin_opcodes): Add EVA opcodes.
@
text
@d2059 17
d2083 1
a2083 1
  bfd_byte buffer[2];
a2095 1
  info->insn_type = dis_nonbranch;
d2099 23
a2121 1
  status = (*info->read_memory_func) (memaddr, buffer, 2, info);
a3003 2
  elf_symbol_type *symbol;
  int pos;
d3005 1
d3007 17
a3023 17
  for (i = 0; i < info->num_symbols; i++)
    {
      pos = info->symtab_pos + i;

      if (bfd_asymbol_flavour (info->symtab[pos]) != bfd_target_elf_flavour)
	continue;

      if (info->symtab[pos]->section != info->section)
	continue;

      symbol = (elf_symbol_type *) info->symtab[pos];
      if ((!micromips_ase
	   && ELF_ST_IS_MIPS16 (symbol->internal_elf_sym.st_other))
	  || (micromips_ase
	      && ELF_ST_IS_MICROMIPS (symbol->internal_elf_sym.st_other)))
	    return 1;
    }
@


1.102
log
@2013-06-13  Chao-ying Fu  <Chao-ying.Fu@@imgtec.com>

	* micromips-opc.c (IVIRT): New define.
	(IVIRT64): New define.
	(micromips_opcodes): Add dmfgc0, dmtgc0, hypcall, mfgc0, mtgc0,
	tlbginv, tlbginvf, tlbgp, tlbgr, tlbgwi, tlbgwr VIRT instructions.

	* mips-dis.c (print_insn_micromips): Handle mfgc0, mtgc0, dmfgc0,
	dmtgc0 to print cp0 names.
@
text
@d594 2
a595 2
    (ASE_SMARTMIPS | ASE_DSP | ASE_DSPR2 | ASE_MIPS3D | ASE_MT
     | ASE_MCU | ASE_VIRT),
d609 2
a610 2
    (ASE_MIPS3D | ASE_DSP | ASE_DSPR2 | ASE_DSP64 | ASE_MT | ASE_MDMX
     | ASE_MCU | ASE_VIRT | ASE_VIRT64),
d1155 4
d2666 5
@


1.101
log
@gas/
2013-06-08  Catherine Moore  <clm@@codesourcery.com>

	* config/tc-mips.c (is_opcode_valid):  Build ASE mask.
	(is_opcode_valid_16): Pass ase value to opcode_is_member.
	(append_insn): Change INSN_xxxx to ASE_xxxx.

include/
2013-06-08  Catherine Moore  <clm@@codesourcery.com>

	* opcode/mips.h (mips_opcode): Add ase field.
	(INSN_ASE_MASK): Delete.
	(INSN_DSP): Rename to ASE_DSP.  Provide new value.
	(INSN_DSPR2): Rename to ASE_DSPR2.  Provide new value.
	(INSN_MCU): Rename to ASE_MCU.  Provide new value.
	(INSN_MDMX): Rename to ASE_MDMX.  Provide new value.
	(INSN_MIPS3d): Rename to ASE_MIPS3D.  Provide new value.
	(INSN_MT): Rename to ASE_MT.  Provide new value.
	(INSN_SMARTMIPS): Rename to ASE_SMARTMIPS.  Provide new value.
	(INSN_VIRT): Rename to ASE_VIRT.  Provide new value.
	(INSN_VIRT64): Rename to ASE_VIRT64.  Provide new value.
	(opcode_is_member): Add ase argument.  Check ase.

opcodes/
2013-06-08  Catherine Moore  <clm@@codesourcery.com>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* micromips-opc.c (D32, D33, MC): Update definitions.
 	(micromips_opcodes):  Initialize ase field.
	* mips-dis.c (mips_arch_choice): Add ase field.
	(mips_arch_choices): Initialize ase field.
	(set_default_mips_dis_options): Declare and setup mips_ase.
	* mips-opc.c (M3D, SMT, MX, IVIRT, IVIRT64, D32, D33, D64,
	MT32, MC): Update definitions.
	(mips_builtin_opcodes): Initialize ase field.
@
text
@d2557 2
d2561 2
@


1.100
log
@
binutils/ChangeLog:
* doc/binutils.texi: Document -Mvirt disassembler option.

gas/ChangeLog:
* config/tc-mips.c (struct mips_set_options): New ase_virt field.
(mips_opts): Update for the new field.
(file_ase_virt): New variable.
(ISA_SUPPORTS_VIRT_ASE): New macro.
(ISA_SUPPORTS_VIRT64_ASE): New macro.
(MIPS_CPU_ASE_VIRT): New define.
(is_opcode_valid): Handle ase_virt.
(macro_build): Handle "+J".
(validate_mips_insn): Likewise.
(mips_ip): Likewise.
(enum options): Add OPTION_VIRT and OPTION_NO_VIRT.
(md_longopts): Add mvirt and mnovirt
(md_parse_option): Handle OPTION_VIRT and OPTION_NO_VIRT.
(mips_after_parse_args): Handle ase_virt field.
(s_mipsset): Handle "virt" and "novirt".
(mips_elf_final_processing): Add a comment about virt ASE might need a new flag.
(md_show_usage): Print out the usage of -mvirt and mno-virt options.
* doc/c-mips.texi: Document -mvirt and -mno-virt.
Document ".set virt" and ".set novirt".

gas/testsuite/ChangeLog:
* gas/mips/mips.exp: Run virt and virt64 testcases.
* gas/mips/virt.d: New file.
* gas/mips/virt.s: New file.
* gas/mips/virt64.d: New file.
* gas/mips/virt64.s: New file.

include/opcode/ChangeLog:
* mips.h (OP_MASK_CODE10): Correct definition.
(OP_SH_CODE10): Likewise.
Add a comment that "+J" is used now for OP_*CODE10.
(INSN_ASE_MASK): Update.
(INSN_VIRT): New macro.
(INSN_VIRT64): New macro

opcodes/ChangeLog:
* mips-dis.c (mips_arch_choices): Add INSN_VIRT to mips32r2 .
Add INSN_VIRT and INSN_VIRT64 to mips64r2.
(parse_mips_dis_option): Handle the virt option.
(print_insn_args): Handle "+J".
(print_mips_disassembler_options): Print out message about virt64.
* mips-opc.c (IVIRT): New define.
(IVIRT64): New define.
(mips_builtin_opcodes): Add dmfgc0, dmtgc0, hypcall, mfgc0, mtgc0,
tlbgr, tlbgwi, tlbginv, tlbginvf, tlbgwr, tlbgp VIRT instructions.
Move rfe to the bottom as it conflicts with tlbgp.
@
text
@d520 1
d529 1
a529 1
  { "numeric",	0, 0, 0, 0,
d532 1
a532 1
  { "r3000",	1, bfd_mach_mips3000, CPU_R3000, ISA_MIPS1,
d534 1
a534 1
  { "r3900",	1, bfd_mach_mips3900, CPU_R3900, ISA_MIPS1,
d536 1
a536 1
  { "r4000",	1, bfd_mach_mips4000, CPU_R4000, ISA_MIPS3,
d538 1
a538 1
  { "r4010",	1, bfd_mach_mips4010, CPU_R4010, ISA_MIPS2,
d540 1
a540 1
  { "vr4100",	1, bfd_mach_mips4100, CPU_VR4100, ISA_MIPS3,
d542 1
a542 1
  { "vr4111",	1, bfd_mach_mips4111, CPU_R4111, ISA_MIPS3,
d544 1
a544 1
  { "vr4120",	1, bfd_mach_mips4120, CPU_VR4120, ISA_MIPS3,
d546 1
a546 1
  { "r4300",	1, bfd_mach_mips4300, CPU_R4300, ISA_MIPS3,
d548 1
a548 1
  { "r4400",	1, bfd_mach_mips4400, CPU_R4400, ISA_MIPS3,
d550 1
a550 1
  { "r4600",	1, bfd_mach_mips4600, CPU_R4600, ISA_MIPS3,
d552 1
a552 1
  { "r4650",	1, bfd_mach_mips4650, CPU_R4650, ISA_MIPS3,
d554 1
a554 1
  { "r5000",	1, bfd_mach_mips5000, CPU_R5000, ISA_MIPS4,
d556 1
a556 1
  { "vr5400",	1, bfd_mach_mips5400, CPU_VR5400, ISA_MIPS4,
d558 1
a558 1
  { "vr5500",	1, bfd_mach_mips5500, CPU_VR5500, ISA_MIPS4,
d560 1
a560 1
  { "r5900",	1, bfd_mach_mips5900, CPU_R5900, ISA_MIPS3,
d562 1
a562 1
  { "r6000",	1, bfd_mach_mips6000, CPU_R6000, ISA_MIPS2,
d564 1
a564 1
  { "rm7000",	1, bfd_mach_mips7000, CPU_RM7000, ISA_MIPS4,
d566 1
a566 1
  { "rm9000",	1, bfd_mach_mips7000, CPU_RM7000, ISA_MIPS4,
d568 1
a568 1
  { "r8000",	1, bfd_mach_mips8000, CPU_R8000, ISA_MIPS4,
d570 1
a570 1
  { "r10000",	1, bfd_mach_mips10000, CPU_R10000, ISA_MIPS4,
d572 1
a572 1
  { "r12000",	1, bfd_mach_mips12000, CPU_R12000, ISA_MIPS4,
d574 1
a574 1
  { "r14000",	1, bfd_mach_mips14000, CPU_R14000, ISA_MIPS4,
d576 1
a576 1
  { "r16000",	1, bfd_mach_mips16000, CPU_R16000, ISA_MIPS4,
d578 1
a578 1
  { "mips5",	1, bfd_mach_mips5, CPU_MIPS5, ISA_MIPS5,
d587 1
a587 1
    ISA_MIPS32 | INSN_SMARTMIPS,
d593 3
a595 2
    (ISA_MIPS32R2 | INSN_SMARTMIPS | INSN_DSP | INSN_DSPR2
     | INSN_MIPS3D | INSN_MT | INSN_MCU | INSN_VIRT),
d602 1
a602 1
    ISA_MIPS64 | INSN_MIPS3D | INSN_MDMX,
d608 3
a610 2
    (ISA_MIPS64R2 | INSN_MIPS3D | INSN_DSP | INSN_DSPR2
     | INSN_DSP64 | INSN_MT | INSN_MDMX | INSN_MCU | INSN_VIRT | INSN_VIRT64),
d616 1
a616 1
    ISA_MIPS64 | INSN_MIPS3D | INSN_SB1,
d622 1
a622 1
    ISA_MIPS3 | INSN_LOONGSON_2E, mips_cp0_names_numeric, 
d626 1
a626 1
    ISA_MIPS3 | INSN_LOONGSON_2F, mips_cp0_names_numeric, 
d630 1
a630 1
    ISA_MIPS64 | INSN_LOONGSON_3A, mips_cp0_names_numeric, 
d634 1
a634 1
    ISA_MIPS64R2 | INSN_OCTEON, mips_cp0_names_numeric, NULL, 0,
d638 1
a638 1
    ISA_MIPS64R2 | INSN_OCTEONP, mips_cp0_names_numeric,
d642 1
a642 1
    ISA_MIPS64R2 | INSN_OCTEON2, mips_cp0_names_numeric,
d646 1
a646 1
    ISA_MIPS64 | INSN_XLR,
d654 1
a654 1
    ISA_MIPS64R2 | INSN_XLR,
d661 1
a661 1
  { "",		1, bfd_mach_mips16, CPU_MIPS16, ISA_MIPS3,
d670 1
d776 1
d804 1
d811 1
d837 1
a837 1
      mips_isa |= INSN_VIRT;
d839 1
a839 1
	mips_isa |= INSN_VIRT64;
d1524 1
a1524 1
	      if (!opcode_is_member (op, mips_isa, mips_processor)
@


1.99
log
@Eliminate warning message.

	* opcodes/mips-dis.c (print_insn_args): Modify def of reg.
@
text
@d593 1
a593 1
     | INSN_MIPS3D | INSN_MT | INSN_MCU),
d607 1
a607 1
     | INSN_DSP64 | INSN_MT | INSN_MDMX | INSN_MCU),
d827 8
d1077 4
d3049 3
@


1.98
log
@	opcodes/
	* mips-dis.c (is_compressed_mode_p): Only match symbols from the
	section disassembled.

	binutils/testsuite/
	* binutils-all/mips/mixed-micromips.d: New test.
	* binutils-all/mips/mixed-mips16.d: New test.
	* binutils-all/mips/mixed-micromips.s: New test source.
	* binutils-all/mips/mixed-mips16.s: New test source.
	* binutils-all/mips/mips.exp: New file.
@
text
@d1276 3
a1278 1
	    unsigned int reg = GET_OP (l, RD);
@


1.97
log
@	* archures.c: Add support for MIPS r5900
	* bfd-in2.h: Add support for MIPS r5900
	* config.bfd: Add support for Sony Playstation 2
	* cpu-mips.c: Add support for MIPS r5900
	* elfxx-mips.c: Add support for MIPS r5900 (extension of r4000)

	* config/tc-mips.c: Add support for MIPS r5900
	Add M_LQ_AB and M_SQ_AB to support large values for instructions lq and sq.
	* config/tc-mips.c (can_swap_branch_p, get_append_method): Detect some conditional short loops to fix a bug on the r5900 by NOP in the branch delay slot.
	* config/tc-mips.c (M_MUL): Support 3 operands in multu on r5900.
	* config/tc-mips.c (M_TRUNCWS): Support trunc.w.s on r5900 in MIPS ISA I.
	* config/tc-mips.c (s_mipsset): Force 32 bit floating point on r5900.
	* configure.in: Detect CPU type when target string contains r5900 (e.g. mips64r5900el-linux-gnu).

	* config/tc-mips.c (mips_ip): Check parameter range of instructions mfps and mtps on r5900.

	* elf/mips.h: Add MIPS machine variant number for r5900 which is compatible with old Playstation 2 software.
	* opcode/mips.h: Add support for r5900 instructions including lq and sq.

	* configure.tgt: Support ELF files for Sony Playstation 2 (for ps2dev and ps2sdk).
	* emulparams/elf32lr5900n32.sh: Create linker script for Sony Playstation 2 ELF files using MIPS ABI n32.
	* emulparams/elf32lr5900.sh: Create linker script for Sony Playstation 2 ELF files using MIPS ABI o32.
	* Makefile.am: Add linker scripts for Sony Playstation 2 ELF files.

	* opcodes/mips-dis.c: Add names for CP0 registers of r5900.
	* opcodes/mips-opc.c: Add M_SQ_AB and M_LQ_AB to support larger range for instructions sq and lq.

	* opcodes/mips-opc.c: Add support for MIPS r5900 CPU.
	Add support for 128 bit MMI (Multimedia Instructions).
	Add support for EE instructions (Emotion Engine).
	Disable unsupported floating point instructions (64 bit and undefined compare operations).
	Enable instructions of MIPS ISA IV which are supported by r5900.
	Disable 64 bit co processor instructions.
	Disable 64 bit multiplication and division instructions.
	Disable instructions for co-processor 2 and 3, because these are not supported (preparation for later VU0 support (Vector Unit)).
	Disable cvt.w.s because this behaves like trunc.w.s and the correct execution can't be ensured on r5900.
	Add trunc.w.s using the opcode encoding of cvt.w.s on r5900. This will confuse less developers and compilers.
@
text
@d2943 3
@


1.96
log
@	* mips-dis.c (print_insn_args): Add GET_OP and GET_OP_S local
	macros, use local variables for info struct member accesses,
	update the type of the variable used to hold the instruction
	word.
	(print_insn_mips, print_mips16_insn_arg): Likewise.
	(print_insn_mips16): Add GET_OP and GET_OP_S local macros, use
	local variables for info struct member accesses.
	(print_insn_micromips): Add GET_OP_S local macro.
	(_print_insn_mips): Update the type of the variable used to hold
	the instruction word.
@
text
@d236 24
d559 2
@


1.95
log
@	include/opcode/
	* mips.h (mips_opcode): Add the exclusions field.
	(OPCODE_IS_MEMBER): Remove macro.
	(cpu_is_member): New inline function.
	(opcode_is_member): Likewise.

	opcodes/
	* micromips-opc.c (micromips_opcodes): Update comment.
	* mips-opc.c (mips_builtin_opcodes): Likewise.  Mark coprocessor
	instructions for IOCT as appropriate.
	* mips-dis.c (print_insn_mips): Replace OPCODE_IS_MEMBER with
	opcode_is_member.
	* configure.in: Substitute NO_WMISSING_FIELD_INITIALIZERS with
	the result of a check for the -Wno-missing-field-initializers
	GCC option.
	* Makefile.am (NO_WMISSING_FIELD_INITIALIZERS): New variable.
	(mips-opc.lo): Pass $(NO_WMISSING_FIELD_INITIALIZERS) to
	compilation.
	(mips16-opc.lo): Likewise.
	(micromips-opc.lo): Likewise.
	* aclocal.m4: Regenerate.
	* configure: Regenerate.
	* Makefile.in: Regenerate.

	gas/
	* config/tc-mips.c (NO_ISA_COP, COP_INSN): Remove macros.
	(is_opcode_valid): Remove coprocessor instruction exclusions.
	Replace OPCODE_IS_MEMBER with opcode_is_member.
	(is_opcode_valid_16): Replace OPCODE_IS_MEMBER with
	opcode_is_member.
	(macro): Remove coprocessor instruction exclusions.
@
text
@d933 1
a933 1
		 register unsigned long int l,
d938 1
a938 1
  int op, delta;
d940 2
d945 5
d959 1
a959 1
	  (*info->fprintf_func) (info->stream, "%c", *d);
d969 3
a971 2
	      (*info->fprintf_func) (info->stream,
				     _("# internal error, incomplete extension sequence (+)"));
d975 2
a976 2
	      lsb = (l >> OP_SH_SHAMT) & OP_MASK_SHAMT;
	      (*info->fprintf_func) (info->stream, "0x%x", lsb);
d980 2
a981 2
	      msb = (l >> OP_SH_INSMSB) & OP_MASK_INSMSB;
	      (*info->fprintf_func) (info->stream, "0x%x", msb - lsb + 1);
d985 1
a985 2
	      (*info->fprintf_func) (info->stream, "0x%lx",
				     (l >> OP_SH_UDI1) & OP_MASK_UDI1);
d989 1
a989 2
	      (*info->fprintf_func) (info->stream, "0x%lx",
				     (l >> OP_SH_UDI2) & OP_MASK_UDI2);
d993 1
a993 2
	      (*info->fprintf_func) (info->stream, "0x%lx",
				     (l >> OP_SH_UDI3) & OP_MASK_UDI3);
d997 1
a997 2
	      (*info->fprintf_func) (info->stream, "0x%lx",
				     (l >> OP_SH_UDI4) & OP_MASK_UDI4);
d1002 2
a1003 2
	      msbd = (l >> OP_SH_EXTMSBD) & OP_MASK_EXTMSBD;
	      (*info->fprintf_func) (info->stream, "0x%x", msbd + 1);
d1011 2
a1012 2
		cp0reg = (l >> OP_SH_RD) & OP_MASK_RD;
		sel = (l >> OP_SH_SEL) & OP_MASK_SEL;
d1022 1
a1022 1
		  (*info->fprintf_func) (info->stream, "%s", n->name);
d1024 1
a1024 1
		  (*info->fprintf_func) (info->stream, "$%d,%d", cp0reg, sel);
d1029 2
a1030 2
	      lsb = ((l >> OP_SH_SHAMT) & OP_MASK_SHAMT) + 32;
	      (*info->fprintf_func) (info->stream, "0x%x", lsb);
d1034 2
a1035 2
	      msb = ((l >> OP_SH_INSMSB) & OP_MASK_INSMSB) + 32;
	      (*info->fprintf_func) (info->stream, "0x%x", msb - lsb + 1);
d1039 2
a1040 2
	      msbd = ((l >> OP_SH_EXTMSBD) & OP_MASK_EXTMSBD) + 32;
	      (*info->fprintf_func) (info->stream, "0x%x", msbd + 1);
d1044 1
a1044 3
	      (*info->fprintf_func) (info->stream, "%s",
				     mips_cp0_names[(l >> OP_SH_RT) &
						     OP_MASK_RT]);
d1052 2
a1053 2
		cp0reg = (l >> OP_SH_RT) & OP_MASK_RT;
		sel = (l >> OP_SH_SEL) & OP_MASK_SEL;
d1063 1
a1063 1
		  (*info->fprintf_func) (info->stream, "%s", n->name);
d1065 1
a1065 1
		  (*info->fprintf_func) (info->stream, "$%d,%d", cp0reg, sel);
d1070 1
a1070 2
	      (*info->fprintf_func) (info->stream, "0x%lx",
				     (l >> OP_SH_BBITIND) & OP_MASK_BBITIND);
d1074 1
a1074 2
	      (*info->fprintf_func) (info->stream, "0x%lx",
				     (l >> OP_SH_CINSPOS) & OP_MASK_CINSPOS);
d1078 1
a1078 2
	      (*info->fprintf_func) (info->stream, "0x%lx",
				     (l >> OP_SH_CINSLM1) & OP_MASK_CINSLM1);
d1082 1
a1082 2
	      (*info->fprintf_func) (info->stream, "0x%lx",
				     (l >> OP_SH_CINSLM1) & OP_MASK_CINSLM1);
d1086 1
a1086 4
	      op = (l >> OP_SH_SEQI) & OP_MASK_SEQI;
	      /* Sign-extend it.  */
	      op = (op ^ 512) - 512;
	      (*info->fprintf_func) (info->stream, "%d", op);
d1090 1
a1090 4
	      delta = (l >> OP_SH_OFFSET_A) & OP_MASK_OFFSET_A;
	      if (delta & 0x80)
		delta |= ~OP_MASK_OFFSET_A;
	      (*info->fprintf_func) (info->stream, "%d", delta);
d1094 1
a1094 4
	      delta = (l >> OP_SH_OFFSET_B) & OP_MASK_OFFSET_B;
	      if (delta & 0x80)
		delta |= ~OP_MASK_OFFSET_B;
	      (*info->fprintf_func) (info->stream, "%d", delta);
a1097 3
	      delta = (l >> OP_SH_OFFSET_C) & OP_MASK_OFFSET_C;
	      if (delta & 0x100)
		delta |= ~OP_MASK_OFFSET_C;
d1099 1
a1099 1
	      (*info->fprintf_func) (info->stream, "%d", delta << 4);
d1103 1
a1103 2
	      (*info->fprintf_func) (info->stream, "%s",
				     mips_gpr_names[(l >> OP_SH_RZ) & OP_MASK_RZ]);
d1107 1
a1107 2
	      (*info->fprintf_func) (info->stream, "%s",
				     mips_fpr_names[(l >> OP_SH_FZ) & OP_MASK_FZ]);
d1112 4
a1115 3
	      (*info->fprintf_func) (info->stream,
				     _("# internal error, undefined extension sequence (+%c)"),
				     *d);
d1121 1
a1121 2
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_BP) & OP_MASK_BP);
d1125 1
a1125 2
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_SA3) & OP_MASK_SA3);
d1129 1
a1129 2
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_SA4) & OP_MASK_SA4);
d1133 1
a1133 2
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_IMM8) & OP_MASK_IMM8);
d1137 1
a1137 2
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_RS) & OP_MASK_RS);
d1141 1
a1141 2
	  (*info->fprintf_func) (info->stream, "$ac%ld",
				 (l >> OP_SH_DSPACC) & OP_MASK_DSPACC);
d1145 1
a1145 2
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_WRDSP) & OP_MASK_WRDSP);
d1149 1
a1149 2
	  (*info->fprintf_func) (info->stream, "$ac%ld",
				 (l >> OP_SH_DSPACC_S) & OP_MASK_DSPACC_S);
d1153 1
a1153 4
	  delta = ((l >> OP_SH_DSPSFT) & OP_MASK_DSPSFT);
	  if (delta & 0x20) /* test sign bit */
	    delta |= ~OP_MASK_DSPSFT;
	  (*info->fprintf_func) (info->stream, "%d", delta);
d1157 1
a1157 4
	  delta = ((l >> OP_SH_DSPSFT_7) & OP_MASK_DSPSFT_7);
	  if (delta & 0x40) /* test sign bit */
	    delta |= ~OP_MASK_DSPSFT_7;
	  (*info->fprintf_func) (info->stream, "%d", delta);
d1161 1
a1161 4
	  delta = (l >> OP_SH_OFFSET12) & OP_MASK_OFFSET12;
	  if (delta & 0x800)
	    delta |= ~0x7ff;
	  (*info->fprintf_func) (info->stream, "%d", delta);
d1165 1
a1165 2
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_3BITPOS) & OP_MASK_3BITPOS);
d1169 1
a1169 2
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_RDDSP) & OP_MASK_RDDSP);
d1173 1
a1173 4
	  delta = ((l >> OP_SH_IMM10) & OP_MASK_IMM10);
	  if (delta & 0x200) /* test sign bit */
	    delta |= ~OP_MASK_IMM10;
	  (*info->fprintf_func) (info->stream, "%d", delta);
d1177 1
a1177 2
	  (*info->fprintf_func) (info->stream, "%ld",
				 (l >> OP_SH_MT_U) & OP_MASK_MT_U);
d1181 1
a1181 2
	  (*info->fprintf_func) (info->stream, "%ld",
				 (l >> OP_SH_MT_H) & OP_MASK_MT_H);
d1185 1
a1185 2
	  (*info->fprintf_func) (info->stream, "$ac%ld",
				 (l >> OP_SH_MTACC_T) & OP_MASK_MTACC_T);
d1189 1
a1189 2
	  (*info->fprintf_func) (info->stream, "$ac%ld",
				 (l >> OP_SH_MTACC_D) & OP_MASK_MTACC_D);
d1194 1
a1194 2
	  (*info->fprintf_func) (info->stream, "$%ld",
				 (l >> OP_SH_RD) & OP_MASK_RD);
d1201 1
a1201 2
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_gpr_names[(l >> OP_SH_RS) & OP_MASK_RS]);
d1206 1
a1206 2
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_gpr_names[(l >> OP_SH_RT) & OP_MASK_RT]);
d1211 1
a1211 2
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_IMMEDIATE) & OP_MASK_IMMEDIATE);
d1216 1
a1216 5
	  delta = (l >> OP_SH_DELTA) & OP_MASK_DELTA;
	  if (delta & 0x8000)
	    delta |= ~0xffff;
	  (*info->fprintf_func) (info->stream, "%d",
				 delta);
d1220 1
a1220 3
	  (*info->fprintf_func) (info->stream, "0x%x",
				 (unsigned int) ((l >> OP_SH_PREFX)
						 & OP_MASK_PREFX));
d1224 1
a1224 3
	  (*info->fprintf_func) (info->stream, "0x%x",
				 (unsigned int) ((l >> OP_SH_CACHE)
						 & OP_MASK_CACHE));
d1229 1
a1229 1
			  | (((l >> OP_SH_TARGET) & OP_MASK_TARGET) << 2));
d1239 1
a1239 4
	  delta = (l >> OP_SH_DELTA) & OP_MASK_DELTA;
	  if (delta & 0x8000)
	    delta |= ~0xffff;
	  info->target = (delta << 2) + pc + INSNLEN;
d1244 1
a1244 2
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_gpr_names[(l >> OP_SH_RD) & OP_MASK_RD]);
d1250 3
a1252 4
	    unsigned int reg = (l >> OP_SH_RD) & OP_MASK_RD;
	    if (reg == ((l >> OP_SH_RT) & OP_MASK_RT))
	      (*info->fprintf_func) (info->stream, "%s",
				     mips_gpr_names[reg]);
d1257 3
a1259 5
		  (*info->fprintf_func) (info->stream, "%s",
					 mips_gpr_names[(l >> OP_SH_RT) & OP_MASK_RT]);
		else if (((l >> OP_SH_RT) & OP_MASK_RT) == 0)
		  (*info->fprintf_func) (info->stream, "%s",
					 mips_gpr_names[reg]);
d1261 3
a1263 3
		  (*info->fprintf_func) (info->stream, "%s or %s",
					 mips_gpr_names[reg],
					 mips_gpr_names[(l >> OP_SH_RT) & OP_MASK_RT]);
d1269 1
a1269 1
	  (*info->fprintf_func) (info->stream, "%s", mips_gpr_names[0]);
d1274 1
a1274 2
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_SHAMT) & OP_MASK_SHAMT);
d1278 1
a1278 2
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_CODE) & OP_MASK_CODE);
d1282 1
a1282 2
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_CODE2) & OP_MASK_CODE2);
d1286 1
a1286 2
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_COPZ) & OP_MASK_COPZ);
d1290 1
a1290 2
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_CODE20) & OP_MASK_CODE20);
d1294 1
a1294 2
	  (*info->fprintf_func) (info->stream, "0x%lx",
				 (l >> OP_SH_CODE19) & OP_MASK_CODE19);
d1299 1
a1299 2
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_fpr_names[(l >> OP_SH_FS) & OP_MASK_FS]);
d1304 1
a1304 2
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_fpr_names[(l >> OP_SH_FT) & OP_MASK_FT]);
d1308 1
a1308 2
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_fpr_names[(l >> OP_SH_FD) & OP_MASK_FD]);
d1312 1
a1312 2
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_fpr_names[(l >> OP_SH_FR) & OP_MASK_FR]);
d1323 1
a1323 2
	  (*info->fprintf_func) (info->stream, "$%ld",
				 (l >> OP_SH_RT) & OP_MASK_RT);
d1331 1
a1331 1
	  op = (l >> OP_SH_OP) & OP_MASK_OP;
d1333 1
a1333 2
	    (*info->fprintf_func) (info->stream, "%s",
				   mips_cp0_names[(l >> OP_SH_RD) & OP_MASK_RD]);
d1335 1
a1335 2
	    (*info->fprintf_func) (info->stream, "$%ld",
				   (l >> OP_SH_RD) & OP_MASK_RD);
d1339 1
a1339 2
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_hwr_names[(l >> OP_SH_RD) & OP_MASK_RD]);
d1343 3
a1345 4
	  (*info->fprintf_func) (info->stream,
				 ((opp->pinfo & (FP_D | FP_S)) != 0
				  ? "$fcc%ld" : "$cc%ld"),
				 (l >> OP_SH_BCC) & OP_MASK_BCC);
d1349 1
a1349 2
	  (*info->fprintf_func) (info->stream, "$fcc%ld",
				 (l >> OP_SH_CCC) & OP_MASK_CCC);
d1353 1
a1353 2
	  (*info->fprintf_func) (info->stream, "%ld",
				 (l >> OP_SH_PERFREG) & OP_MASK_PERFREG);
d1357 1
a1357 2
	  (*info->fprintf_func) (info->stream, "%ld",
				 (l >> OP_SH_VECBYTE) & OP_MASK_VECBYTE);
d1361 1
a1361 2
	  (*info->fprintf_func) (info->stream, "%ld",
				 (l >> OP_SH_VECALIGN) & OP_MASK_VECALIGN);
d1365 1
a1365 2
	  (*info->fprintf_func) (info->stream, "%ld",
				 (l >> OP_SH_SEL) & OP_MASK_SEL);
d1369 1
a1369 2
	  (*info->fprintf_func) (info->stream, "%ld",
				 (l >> OP_SH_ALN) & OP_MASK_ALN);
d1374 1
a1374 1
	    unsigned int vsel = (l >> OP_SH_VSEL) & OP_MASK_VSEL;
d1384 1
a1384 3
		(*info->fprintf_func) (info->stream, "$v%ld[%d]",
				       (l >> OP_SH_FT) & OP_MASK_FT,
				       vsel >> 1);
d1388 1
a1388 2
		(*info->fprintf_func) (info->stream, "$v%ld",
				       (l >> OP_SH_FT) & OP_MASK_FT);
d1392 1
a1392 2
		(*info->fprintf_func) (info->stream, "0x%lx",
				       (l >> OP_SH_FT) & OP_MASK_FT);
d1398 1
a1398 2
	  (*info->fprintf_func) (info->stream, "$v%ld",
				 (l >> OP_SH_FD) & OP_MASK_FD);
d1402 1
a1402 2
	  (*info->fprintf_func) (info->stream, "$v%ld",
				 (l >> OP_SH_FS) & OP_MASK_FS);
d1406 1
a1406 2
	  (*info->fprintf_func) (info->stream, "$v%ld",
				 (l >> OP_SH_FT) & OP_MASK_FT);
d1411 1
a1411 3
	  (*info->fprintf_func) (info->stream,
				 _("# internal error, undefined modifier (%c)"),
				 *d);
d1424 1
a1424 1
		 unsigned long int word,
d1427 2
d1431 1
a1431 1
  static const struct mips_opcode *mips_hash[OP_MASK_OP + 1];
d1445 1
a1445 1
	      if (i == ((op->match >> OP_SH_OP) & OP_MASK_OP))
d1465 1
a1465 1
  op = mips_hash[(word >> OP_SH_OP) & OP_MASK_OP];
d1504 1
a1504 1
	      (*info->fprintf_func) (info->stream, "%s", op->name);
d1509 1
a1509 1
		  (*info->fprintf_func) (info->stream, "\t");
d1517 2
d1522 1
a1522 1
  (*info->fprintf_func) (info->stream, "0x%lx", word);
d1537 8
d1550 1
a1550 1
      (*info->fprintf_func) (info->stream, "%c", type);
d1555 1
a1555 3
      (*info->fprintf_func) (info->stream, "%s",
			     mips16_reg_names(((l >> MIPS16OP_SH_RY)
					       & MIPS16OP_MASK_RY)));
d1560 1
a1560 3
      (*info->fprintf_func) (info->stream, "%s",
			     mips16_reg_names(((l >> MIPS16OP_SH_RX)
					       & MIPS16OP_MASK_RX)));
d1564 1
a1564 3
      (*info->fprintf_func) (info->stream, "%s",
			     mips16_reg_names(((l >> MIPS16OP_SH_RZ)
					       & MIPS16OP_MASK_RZ)));
d1568 1
a1568 3
      (*info->fprintf_func) (info->stream, "%s",
			     mips16_reg_names(((l >> MIPS16OP_SH_MOVE32Z)
					       & MIPS16OP_MASK_MOVE32Z)));
d1572 1
a1572 1
      (*info->fprintf_func) (info->stream, "%s", mips_gpr_names[0]);
d1576 1
a1576 1
      (*info->fprintf_func) (info->stream, "%s", mips_gpr_names[29]);
d1580 1
a1580 1
      (*info->fprintf_func) (info->stream, "$pc");
d1584 1
a1584 1
      (*info->fprintf_func) (info->stream, "%s", mips_gpr_names[31]);
d1588 1
a1588 3
      (*info->fprintf_func) (info->stream, "%s",
			     mips_gpr_names[((l >> MIPS16OP_SH_REGR32)
					    & MIPS16OP_MASK_REGR32)]);
d1592 1
a1592 2
      (*info->fprintf_func) (info->stream, "%s",
			     mips_gpr_names[MIPS16OP_EXTRACT_REG32R (l)]);
d1630 1
a1630 1
	    immed = (l >> MIPS16OP_SH_RZ) & MIPS16OP_MASK_RZ;
d1636 1
a1636 1
	    immed = (l >> MIPS16OP_SH_RX) & MIPS16OP_MASK_RX;
d1642 1
a1642 1
	    immed = (l >> MIPS16OP_SH_RZ) & MIPS16OP_MASK_RZ;
d1648 1
a1648 1
	    immed = (l >> MIPS16OP_SH_RX) & MIPS16OP_MASK_RX;
d1654 1
a1654 1
	    immed = (l >> MIPS16OP_SH_IMM4) & MIPS16OP_MASK_IMM4;
d1660 1
a1660 1
	    immed = (l >> MIPS16OP_SH_IMM5) & MIPS16OP_MASK_IMM5;
d1667 1
a1667 1
	    immed = (l >> MIPS16OP_SH_IMM5) & MIPS16OP_MASK_IMM5;
d1674 1
a1674 1
	    immed = (l >> MIPS16OP_SH_IMM5) & MIPS16OP_MASK_IMM5;
d1685 1
a1685 1
	    immed = (l >> MIPS16OP_SH_IMM5) & MIPS16OP_MASK_IMM5;
d1691 1
a1691 1
	    immed = (l >> MIPS16OP_SH_IMM5) & MIPS16OP_MASK_IMM5;
d1696 1
a1696 1
	    immed = (l >> MIPS16OP_SH_IMM6) & MIPS16OP_MASK_IMM6;
d1700 1
a1700 1
	    immed = (l >> MIPS16OP_SH_IMM8) & MIPS16OP_MASK_IMM8;
d1705 1
a1705 1
	    immed = (l >> MIPS16OP_SH_IMM8) & MIPS16OP_MASK_IMM8;
d1714 1
a1714 1
	    immed = (l >> MIPS16OP_SH_IMM8) & MIPS16OP_MASK_IMM8;
d1720 1
a1720 1
	    immed = (l >> MIPS16OP_SH_IMM8) & MIPS16OP_MASK_IMM8;
d1725 1
a1725 1
	    immed = (l >> MIPS16OP_SH_IMM8) & MIPS16OP_MASK_IMM8;
d1731 1
a1731 1
	    immed = (l >> MIPS16OP_SH_IMM8) & MIPS16OP_MASK_IMM8;
d1736 1
a1736 1
	    immed = (l >> MIPS16OP_SH_IMM8) & MIPS16OP_MASK_IMM8;
d1743 1
a1743 1
	    immed = (l >> MIPS16OP_SH_IMM11) & MIPS16OP_MASK_IMM11;
d1751 1
a1751 1
	    immed = (l >> MIPS16OP_SH_IMM8) & MIPS16OP_MASK_IMM8;
d1760 1
a1760 1
	    immed = (l >> MIPS16OP_SH_IMM5) & MIPS16OP_MASK_IMM5;
d1768 1
a1768 1
	    immed = (l >> MIPS16OP_SH_IMM5) & MIPS16OP_MASK_IMM5;
d1798 1
a1798 1
	  (*info->fprintf_func) (info->stream, "%d", immed);
d1876 1
a1876 1
	l = (l >> MIPS16OP_SH_IMM6) & MIPS16OP_MASK_IMM6;
d1882 1
a1882 1
	    (*info->fprintf_func) (info->stream, "%s", mips_gpr_names[4]);
d1884 1
a1884 2
	      (*info->fprintf_func) (info->stream, "-%s",
				     mips_gpr_names[amask + 3]);
d1891 1
a1891 2
	    (*info->fprintf_func) (info->stream, "%s??",
				   need_comma ? "," : "");
d1896 1
a1896 3
	    (*info->fprintf_func) (info->stream, "%s%s",
				   need_comma ? "," : "",
				   mips_gpr_names[16]);
d1898 1
a1898 2
	      (*info->fprintf_func) (info->stream, "-%s",
				     mips_gpr_names[smask + 15]);
d1904 1
a1904 3
	    (*info->fprintf_func) (info->stream, "%s%s",
				   need_comma ? "," : "",
				   mips_gpr_names[31]);
d1910 1
a1910 2
	    (*info->fprintf_func) (info->stream, "%s$f0",
				   need_comma ? "," : "");
d1912 1
a1912 1
	      (*info->fprintf_func) (info->stream, "-$f1");
d1949 1
a1949 1
          (*info->fprintf_func) (info->stream, "%s", mips_gpr_names[4]);
d1951 1
a1951 2
            (*info->fprintf_func) (info->stream, "-%s",
                                   mips_gpr_names[4 + args - 1]);
d1959 1
a1959 3
      (*info->fprintf_func) (info->stream, "%s%d", 
                             need_comma ? "," : "",
                             framesz);
d1962 1
a1962 1
        (*info->fprintf_func) (info->stream, ",%s", mips_gpr_names[31]);
d1978 1
a1978 2
              (*info->fprintf_func) (info->stream, ",%s",
                                     mips_gpr_names[i == 8 ? 30 : (16 + i)]);
d1983 1
a1983 2
                (*info->fprintf_func) (info->stream, "-%s",
                                       mips_gpr_names[j == 8 ? 30 : (16 + j)]);
d1990 1
a1990 1
        (*info->fprintf_func) (info->stream, ",%s", mips_gpr_names[7]);
d1992 3
a1994 3
        (*info->fprintf_func) (info->stream, ",%s-%s", 
                               mips_gpr_names[7 - statics + 1],
                               mips_gpr_names[7]);
d2000 4
a2003 4
      (*info->fprintf_func)
	(info->stream,
	 _("# internal disassembler error, unrecognised modifier (%c)"),
	 type);
d2013 1
d2021 1
d2058 1
a2058 2
	  (*info->fprintf_func) (info->stream, "extend 0x%x",
				 (unsigned int) extend);
d2071 1
a2071 2
	  (*info->fprintf_func) (info->stream, "extend 0x%x",
				 (unsigned int) extend);
d2094 1
a2094 2
		  (*info->fprintf_func) (info->stream, "extend 0x%x",
					 (unsigned int) extend);
d2116 1
a2116 1
	  (*info->fprintf_func) (info->stream, "%s", op->name);
d2118 1
a2118 1
	    (*info->fprintf_func) (info->stream, "\t");
d2124 1
a2124 2
		  && (((insn >> MIPS16OP_SH_RX) & MIPS16OP_MASK_RX)
		      == ((insn >> MIPS16OP_SH_RY) & MIPS16OP_MASK_RY)))
d2132 1
a2132 2
		  && (((insn >> MIPS16OP_SH_RZ) & MIPS16OP_MASK_RZ)
		      == ((insn >> MIPS16OP_SH_RX) & MIPS16OP_MASK_RX)))
d2159 2
d2163 2
a2164 2
    (*info->fprintf_func) (info->stream, "0x%x", extend | 0xf000);
  (*info->fprintf_func) (info->stream, "0x%x", insn);
d2275 3
d2304 1
a2304 4
		  delta = GET_OP (insn, OFFSET10);
		  if (delta & 0x200)
		    delta |= ~0x3ff;
		  infprintf (is, "%d", delta);
d2361 1
a2361 4
		  delta = GET_OP (insn, OFFSET12);
		  if (delta & 0x800)
		    delta |= ~0x7ff;
		  infprintf (is, "%d", delta);
d2370 1
a2370 1
				    | ((GET_OP (insn, TARGET)) << 1));
d2404 1
a2404 2
		  delta = (GET_OP (insn, DELTA) ^ 0x8000) - 0x8000;
		  infprintf (is, "%d", delta);
d2446 1
a2446 1
		  delta = (GET_OP (insn, DELTA) ^ 0x8000) - 0x8000;
d2720 1
a2720 1
		      immed = ((GET_OP (insn, IMMA) ^ 0x40) - 0x40) << 2;
d2736 1
a2736 1
		      delta = (GET_OP (insn, IMMD) ^ 0x200) - 0x200;
d2743 1
a2743 1
		      delta = (GET_OP (insn, IMME) ^ 0x40) - 0x40;
d2811 1
a2811 2
		      immed = (GET_OP (insn, IMMQ) ^ 0x400000) - 0x400000;
		      immed <<= 2;
d2827 1
a2827 1
		      immed = (GET_OP (insn, IMMX) ^ 0x8) - 0x8;
d2833 3
a2835 4
		      immed = (GET_OP (insn, IMMY) ^ 0x100) - 0x100;
		      if (immed >= -2 && immed <= 1)
			immed ^= 0x100;
		      immed = immed << 2;
d2886 1
d2968 1
a2968 1
      unsigned long insn;
d2971 1
a2971 1
	insn = (unsigned long) bfd_getb32 (buffer);
d2973 1
a2973 1
	insn = (unsigned long) bfd_getl32 (buffer);
@


1.94
log
@	* h8300-dis.c: Fix printf arg warnings.
	* i960-dis.c: Likewise.
	* mips-dis.c: Likewise.
	* pdp11-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* configure.in: Formatting.
	* configure: Regenerate.
	* rl78-decode.c: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d1565 1
a1565 1
	      if (! OPCODE_IS_MEMBER (op, mips_isa, mips_processor)
@


1.93
log
@	include/opcode/
	* mips.h: Document microMIPS DSP ASE usage.
	(MICROMIPSOP_MASK_DSPACC, MICROMIPSOP_SH_DSPACC): Update for
	microMIPS DSP ASE support.
	(MICROMIPSOP_MASK_DSPSFT, MICROMIPSOP_SH_DSPSFT): Likewise.
	(MICROMIPSOP_MASK_SA3, MICROMIPSOP_SH_SA3): Likewise.
	(MICROMIPSOP_MASK_SA4, MICROMIPSOP_SH_SA4): Likewise.
	(MICROMIPSOP_MASK_IMM8, MICROMIPSOP_SH_IMM8): Likewise.
	(MICROMIPSOP_MASK_IMM10, MICROMIPSOP_SH_IMM10): Likewise.
	(MICROMIPSOP_MASK_WRDSP, MICROMIPSOP_SH_WRDSP): Likewise.
	(MICROMIPSOP_MASK_BP, MICROMIPSOP_SH_BP): Likewise.

	gas/
	* config/tc-mips.c (macro_build) <'2'>: Handle microMIPS.
	(macro) <M_BALIGN>: Update error handling.
	(validate_micromips_insn) <'2', '3', '4', '5', '6'>: New cases.
	<'7', '8', '0', '@@', '^'>: Likewise.
	(mips_ip) <'2', '3', '4', '5', '6', '7', '8'>: Handle microMIPS.
	<'9'>: Fix formatting.
	<'0', '@@'>: Handle microMIPS.
	<'^'>: New case.

	gas/testsuite/
	* gas/mips/micromips@@mips32-dsp.d: New.
	* gas/mips/micromips@@mips32-dspr2.d: New.
	* gas/mips/mips32-dsp.d: Remove -mips32r2.
	* gas/mips/mips32-dspr2.d: Likewise.
	* gas/mips/mips.exp: (mips_create_arch): Use -mips64r2
	for micromips.  Use run_dump_test_arches to run dsp tests.

	opcodes/
	* micromips-opc.c (WR_a, RD_a, MOD_a): New macros.
	(DSP_VOLA): Likewise.
	(D32, D33): Likewise.
	(micromips_opcodes): Add DSP ASE instructions.
	* micromips-dis.c (print_insn_micromips) <'2', '3'>: New cases.
	<'4', '5', '6', '7', '8', '0', '^', '@@'>: Likewise.
@
text
@d2415 1
a2415 1
		  infprintf (is, "0x%lx", GET_OP (insn, BP));
d2419 1
a2419 1
		  infprintf (is, "0x%lx", GET_OP (insn, SA3));
d2423 1
a2423 1
		  infprintf (is, "0x%lx", GET_OP (insn, SA4));
d2427 1
a2427 1
		  infprintf (is, "0x%lx", GET_OP (insn, IMM8));
d2431 1
a2431 1
		  infprintf (is, "0x%lx", GET_OP (insn, RS));
d2435 1
a2435 1
		  infprintf (is, "$ac%ld", GET_OP (insn, DSPACC));
d2439 1
a2439 1
		  infprintf (is, "0x%lx", GET_OP (insn, WRDSP));
d2456 1
a2456 1
		  infprintf (is, "0x%lx", GET_OP (insn, RD));
@


1.92
log
@	PR binutils/13135
	* arm-dis.c: Add necessary casts for printing integer values.
	Use %s when printing string values.
	* hppa-dis.c: Likewise.
	* m68k-dis.c: Likewise.
	* microblaze-dis.c: Likewise.
	* mips-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* sparc-dis.c: Likewise.

	* dis-asm.h (fprintf_ftype): Add ATTRIBUTE_FPTR_PRINTF_2.
@
text
@d2414 33
d2455 4
d2575 5
@


1.92.2.1
log
@gas/
	* config/tc-mips.c (ISA_SUPPORTS_DSP_ASE): Also set if microMIPS
	mode.
	(ISA_SUPPORTS_DSPR2_ASE): Likewise.
	(macro_build) <'2'>: Handle microMIPS.
2012-07-31  Maciej W. Rozycki  <macro@@codesourcery.com>
            Chao-Ying Fu  <fu@@mips.com>
            Catherine Moore  <clm@@codesourcery.com>

gas/
	* gas/mips/micromips@@mips32-dsp.d: New test.
	* gas/mips/micromips@@mips32-dspr2.d: New test.
	* gas/mips/mips32-dsp.s: Update padding.
	* gas/mips/mips32-dspr2.s: Likewise.
	* gas/mips/mips.exp: Use run_dump_test_arches to run MIPS32 DSP
	tests.
2012-07-31  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

include/
2012-07-31  Chao-Ying Fu  <fu@@mips.com>
            Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

opcodes/
2012-08-01  Alan Modra  <amodra@@gmail.com>

	* h8300-dis.c: Fix printf arg warnings.
	* i960-dis.c: Likewise.
	* mips-dis.c: Likewise.
	* pdp11-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* configure.in: Formatting.
	* configure: Regenerate.
	* rl78-decode.c: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@a2413 33
		case '2':
		  infprintf (is, "0x%x", GET_OP (insn, BP));
		  break;

		case '3':
		  infprintf (is, "0x%x", GET_OP (insn, SA3));
		  break;

		case '4':
		  infprintf (is, "0x%x", GET_OP (insn, SA4));
		  break;

		case '5':
		  infprintf (is, "0x%x", GET_OP (insn, IMM8));
		  break;

		case '6':
		  infprintf (is, "0x%x", GET_OP (insn, RS));
		  break;

		case '7':
		  infprintf (is, "$ac%d", GET_OP (insn, DSPACC));
		  break;

		case '8':
		  infprintf (is, "0x%x", GET_OP (insn, WRDSP));
		  break;

		case '0': /* DSP 6-bit signed immediate in bit 16.  */
		  delta = (GET_OP (insn, DSPSFT) ^ 0x20) - 0x20;
		  infprintf (is, "%d", delta);
		  break;

a2421 4
		case '^':
		  infprintf (is, "0x%x", GET_OP (insn, RD));
		  break;

a2537 5
		case '@@': /* DSP 10-bit signed immediate in bit 16.  */
		  delta = (GET_OP (insn, IMM10) ^ 0x200) - 0x200;
		  infprintf (is, "%d", delta);
		  break;

@


1.92.2.2
log
@bfd/
2012-08-09  Maciej W. Rozycki  <macro@@codesourcery.com>

	* elfxx-mips.c (LA25_LUI_MICROMIPS_1, LA25_LUI_MICROMIPS_2):
	Remove macros, folding them into...
	(LA25_LUI_MICROMIPS): ... this new macro.
	(LA25_J_MICROMIPS_1, LA25_J_MICROMIPS_2): Likewise into...
	(LA25_J_MICROMIPS): ... this new macro.
	(LA25_ADDIU_MICROMIPS_1, LA25_ADDIU_MICROMIPS_2): Likewise
	into...
	(LA25_ADDIU_MICROMIPS): ... this new macro.
	(bfd_put_micromips_32, bfd_get_micromips_32): New functions.
	(mips_elf_create_la25_stub): Use them.
	(check_br32_dslot, check_br32, check_relocated_bzc): Likewise.
	(_bfd_mips_elf_relax_section): Likewise.

gas/
	* config/tc-mips.c (NO_ISA_COP, COP_INSN): Remove macros.
	(is_opcode_valid): Remove coprocessor instruction exclusions.
	Replace OPCODE_IS_MEMBER with opcode_is_member.
	(is_opcode_valid_16): Replace OPCODE_IS_MEMBER with
	opcode_is_member.
	(macro): Remove coprocessor instruction exclusions.

gas/
	* gas/mips/mips.exp: Set has_newabi for all Linux targets.
	* gas/mips/cfi-n64-1.d: Adjust for targets that do not infer the
	ISA from the ABI.
	* gas/mips/elf-rel-got-n32.d: Likewise.
	* gas/mips/elf-rel-got-n64.d: Likewise.
	* gas/mips/elf-rel-xgot-n32.d: Likewise.
	* gas/mips/elf-rel-xgot-n64.d: Likewise.
	* gas/mips/elf-rel18.d: Likewise.
	* gas/mips/elf-rel28-n32.d: Likewise.
	* gas/mips/elf-rel28-n64.d: Likewise.
	* gas/mips/jal-newabi.d: Likewise.
	* gas/mips/ldstla-n64-shared.d: Likewise.
	* gas/mips/ldstla-n64-sym32.d: Likewise.
	* gas/mips/ldstla-n64.d: Likewise.
	* gas/mips/macro-warn-1-n32.d: Likewise.
	* gas/mips/macro-warn-2-n32.d: Likewise.
	* gas/mips/n32-consec.d: Likewise.

include/
2012-08-13  Richard Sandiford  <rdsandiford@@googlemail.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (mips_opcode): Add the exclusions field.
	(OPCODE_IS_MEMBER): Remove macro.
	(cpu_is_member): New inline function.
	(opcode_is_member): Likewise.

ld/
	* emulparams/elf32bmip.sh: Make _gp hidden.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32mipswindiss.sh: Likewise.
	* scripttempl/mips.sc: Likewise.

ld/
2012-08-28  Maciej W. Rozycki  <macro@@codesourcery.com>

	* ld-elf/export-class.sd: New test.
	* ld-elf/export-class.vd: New test.
	* ld-elf/export-class-def.s: New test source.
	* ld-elf/export-class-dep.s: New test source.
	* ld-elf/export-class-lib.s: New test source.
	* ld-elf/export-class-ref.s: New test source.
	* ld-elf/export-class-lib.ver: New test version script.
	* ld-elf/export-class.exp: New test script.
	* ld-arm/arm-export-class.rd: New test.
	* ld-arm/arm-export-class.xd: New test.
	* ld-arm/export-class.exp: New test script.
	* ld-i386/i386-export-class.rd: New test.
	* ld-i386/i386-export-class.xd: New test.
	* ld-i386/export-class.exp: New test script.
	* ld-mips-elf/mips-32-export-class.rd: New test.
	* ld-mips-elf/mips-32-export-class.xd: New test.
	* ld-mips-elf/mips-64-export-class.rd: New test.
	* ld-mips-elf/mips-64-export-class.xd: New test.
	* ld-mips-elf/export-class.exp: New test script.
	* ld-powerpc/powerpc-32-export-class.rd: New test.
	* ld-powerpc/powerpc-32-export-class.xd: New test.
	* ld-powerpc/powerpc-64-export-class.rd: New test.
	* ld-powerpc/powerpc-64-export-class.xd: New test.
	* ld-powerpc/export-class.exp: New test script.
	* ld-x86-64/x86-64-64-export-class.rd: New test.
	* ld-x86-64/x86-64-x32-export-class.rd: New test.
	* ld-x86-64/export-class.exp: New test script.

opcodes/
2012-08-14  Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips-dis.c (print_insn_args): Add GET_OP and GET_OP_S local
	macros, use local variables for info struct member accesses,
	update the type of the variable used to hold the instruction
	word.
	(print_insn_mips, print_mips16_insn_arg): Likewise.
	(print_insn_mips16): Add GET_OP and GET_OP_S local macros, use
	local variables for info struct member accesses.
	(print_insn_micromips): Add GET_OP_S local macro.
	(_print_insn_mips): Update the type of the variable used to hold
	the instruction word.
@
text
@d933 1
a933 1
		 int l,
d938 1
a938 1
  const fprintf_ftype infprintf = info->fprintf_func;
a939 2
  void *is = info->stream;
  int op;
a942 5
#define GET_OP(insn, field) \
  (((insn) >> OP_SH_##field) & OP_MASK_##field)
#define GET_OP_S(insn, field) \
  ((GET_OP (insn, field) ^ ((OP_MASK_##field >> 1) + 1)) \
   - ((OP_MASK_##field >> 1) + 1))
d952 1
a952 1
	  infprintf (is, "%c", *d);
d962 2
a963 3
	      infprintf (is,
			 _("# internal error, "
			   "incomplete extension sequence (+)"));
d967 2
a968 2
	      lsb = GET_OP (l, SHAMT);
	      infprintf (is, "0x%x", lsb);
d972 2
a973 2
	      msb = GET_OP (l, INSMSB);
	      infprintf (is, "0x%x", msb - lsb + 1);
d977 2
a978 1
	      infprintf (is, "0x%x", GET_OP (l, UDI1));
d982 2
a983 1
	      infprintf (is, "0x%x", GET_OP (l, UDI2));
d987 2
a988 1
	      infprintf (is, "0x%x", GET_OP (l, UDI3));
d992 2
a993 1
	      infprintf (is, "0x%x", GET_OP (l, UDI4));
d998 2
a999 2
	      msbd = GET_OP (l, EXTMSBD);
	      infprintf (is, "0x%x", msbd + 1);
d1007 2
a1008 2
		cp0reg = GET_OP (l, RD);
		sel = GET_OP (l, SEL);
d1018 1
a1018 1
		  infprintf (is, "%s", n->name);
d1020 1
a1020 1
		  infprintf (is, "$%d,%d", cp0reg, sel);
d1025 2
a1026 2
	      lsb = GET_OP (l, SHAMT) + 32;
	      infprintf (is, "0x%x", lsb);
d1030 2
a1031 2
	      msb = GET_OP (l, INSMSB) + 32;
	      infprintf (is, "0x%x", msb - lsb + 1);
d1035 2
a1036 2
	      msbd = GET_OP (l, EXTMSBD) + 32;
	      infprintf (is, "0x%x", msbd + 1);
d1040 3
a1042 1
	      infprintf (is, "%s", mips_cp0_names[GET_OP (l, RT)]);
d1050 2
a1051 2
		cp0reg = GET_OP (l, RT);
		sel = GET_OP (l, SEL);
d1061 1
a1061 1
		  infprintf (is, "%s", n->name);
d1063 1
a1063 1
		  infprintf (is, "$%d,%d", cp0reg, sel);
d1068 2
a1069 1
	      infprintf (is, "0x%x", GET_OP (l, BBITIND));
d1073 2
a1074 1
	      infprintf (is, "0x%x", GET_OP (l, CINSPOS));
d1078 2
a1079 1
	      infprintf (is, "0x%x", GET_OP (l, CINSLM1));
d1083 2
a1084 1
	      infprintf (is, "0x%x", GET_OP (l, CINSLM1));
d1088 4
a1091 1
	      infprintf (is, "%d", GET_OP_S (l, SEQI));
d1095 4
a1098 1
	      infprintf (is, "%d", GET_OP_S (l, OFFSET_A));
d1102 4
a1105 1
	      infprintf (is, "%d", GET_OP_S (l, OFFSET_B));
d1109 3
d1113 1
a1113 1
	      infprintf (is, "%d", GET_OP_S (l, OFFSET_C) << 4);
d1117 2
a1118 1
	      infprintf (is, "%s", mips_gpr_names[GET_OP (l, RZ)]);
d1122 2
a1123 1
	      infprintf (is, "%s", mips_fpr_names[GET_OP (l, FZ)]);
d1128 3
a1130 4
	      infprintf (is,
			 _("# internal error, "
			   "undefined extension sequence (+%c)"),
			 *d);
d1136 2
a1137 1
	  infprintf (is, "0x%x", GET_OP (l, BP));
d1141 2
a1142 1
	  infprintf (is, "0x%x", GET_OP (l, SA3));
d1146 2
a1147 1
	  infprintf (is, "0x%x", GET_OP (l, SA4));
d1151 2
a1152 1
	  infprintf (is, "0x%x", GET_OP (l, IMM8));
d1156 2
a1157 1
	  infprintf (is, "0x%x", GET_OP (l, RS));
d1161 2
a1162 1
	  infprintf (is, "$ac%d", GET_OP (l, DSPACC));
d1166 2
a1167 1
	  infprintf (is, "0x%x", GET_OP (l, WRDSP));
d1171 2
a1172 1
	  infprintf (is, "$ac%d", GET_OP (l, DSPACC_S));
d1176 4
a1179 1
	  infprintf (is, "%d", GET_OP_S (l, DSPSFT));
d1183 4
a1186 1
	  infprintf (is, "%d", GET_OP_S (l, DSPSFT_7));
d1190 4
a1193 1
	  infprintf (is, "%d", GET_OP_S (l, OFFSET12));
d1197 2
a1198 1
	  infprintf (is, "0x%x", GET_OP (l, 3BITPOS));
d1202 2
a1203 1
	  infprintf (is, "0x%x", GET_OP (l, RDDSP));
d1207 4
a1210 1
	  infprintf (is, "%d", GET_OP_S (l, IMM10));
d1214 2
a1215 1
	  infprintf (is, "%d", GET_OP (l, MT_U));
d1219 2
a1220 1
	  infprintf (is, "%d", GET_OP (l, MT_H));
d1224 2
a1225 1
	  infprintf (is, "$ac%d", GET_OP (l, MTACC_T));
d1229 2
a1230 1
	  infprintf (is, "$ac%d", GET_OP (l, MTACC_D));
d1235 2
a1236 1
	  infprintf (is, "$%d", GET_OP (l, RD));
d1243 2
a1244 1
	  infprintf (is, "%s", mips_gpr_names[GET_OP (l, RS)]);
d1249 2
a1250 1
	  infprintf (is, "%s", mips_gpr_names[GET_OP (l, RT)]);
d1255 2
a1256 1
	  infprintf (is, "0x%x", GET_OP (l, IMMEDIATE));
d1261 5
a1265 1
	  infprintf (is, "%d", GET_OP_S (l, DELTA));
d1269 3
a1271 1
	  infprintf (is, "0x%x", GET_OP (l, PREFX));
d1275 3
a1277 1
	  infprintf (is, "0x%x", GET_OP (l, CACHE));
d1282 1
a1282 1
			  | (GET_OP (l, TARGET) << 2));
d1292 4
a1295 1
	  info->target = (GET_OP_S (l, DELTA) << 2) + pc + INSNLEN;
d1300 2
a1301 1
	  infprintf (is, "%s", mips_gpr_names[GET_OP (l, RD)]);
d1307 4
a1310 3
	    unsigned int reg = GET_OP (l, RD);
	    if (reg == GET_OP (l, RT))
	      infprintf (is, "%s", mips_gpr_names[reg]);
d1315 5
a1319 3
		  infprintf (is, "%s", mips_gpr_names[GET_OP (l, RT)]);
		else if (GET_OP (l, RT) == 0)
		  infprintf (is, "%s", mips_gpr_names[reg]);
d1321 3
a1323 3
		  infprintf (is, "%s or %s",
			     mips_gpr_names[reg],
			     mips_gpr_names[GET_OP (l, RT)]);
d1329 1
a1329 1
	  infprintf (is, "%s", mips_gpr_names[0]);
d1334 2
a1335 1
	  infprintf (is, "0x%x", GET_OP (l, SHAMT));
d1339 2
a1340 1
	  infprintf (is, "0x%x", GET_OP (l, CODE));
d1344 2
a1345 1
	  infprintf (is, "0x%x", GET_OP (l, CODE2));
d1349 2
a1350 1
	  infprintf (is, "0x%x", GET_OP (l, COPZ));
d1354 2
a1355 1
	  infprintf (is, "0x%x", GET_OP (l, CODE20));
d1359 2
a1360 1
	  infprintf (is, "0x%x", GET_OP (l, CODE19));
d1365 2
a1366 1
	  infprintf (is, "%s", mips_fpr_names[GET_OP (l, FS)]);
d1371 2
a1372 1
	  infprintf (is, "%s", mips_fpr_names[GET_OP (l, FT)]);
d1376 2
a1377 1
	  infprintf (is, "%s", mips_fpr_names[GET_OP (l, FD)]);
d1381 2
a1382 1
	  infprintf (is, "%s", mips_fpr_names[GET_OP (l, FR)]);
d1393 2
a1394 1
	  infprintf (is, "$%d", GET_OP (l, RT));
d1402 1
a1402 1
	  op = GET_OP (l, OP);
d1404 2
a1405 1
	    infprintf (is, "%s", mips_cp0_names[GET_OP (l, RD)]);
d1407 2
a1408 1
	    infprintf (is, "$%d", GET_OP (l, RD));
d1412 2
a1413 1
	  infprintf (is, "%s", mips_hwr_names[GET_OP (l, RD)]);
d1417 4
a1420 3
	  infprintf (is,
		     (opp->pinfo & (FP_D | FP_S)) != 0 ? "$fcc%d" : "$cc%d",
		     GET_OP (l, BCC));
d1424 2
a1425 1
	  infprintf (is, "$fcc%d", GET_OP (l, CCC));
d1429 2
a1430 1
	  infprintf (is, "%d", GET_OP (l, PERFREG));
d1434 2
a1435 1
	  infprintf (is, "%d", GET_OP (l, VECBYTE));
d1439 2
a1440 1
	  infprintf (is, "%d", GET_OP (l, VECALIGN));
d1444 2
a1445 1
	  infprintf (is, "%d", GET_OP (l, SEL));
d1449 2
a1450 1
	  infprintf (is, "%d", GET_OP (l, ALN));
d1455 1
a1455 1
	    unsigned int vsel = GET_OP (l, VSEL);
d1465 3
a1467 1
		infprintf (is, "$v%d[%d]", GET_OP (l, FT), vsel >> 1);
d1471 2
a1472 1
		infprintf (is, "$v%d", GET_OP (l, FT));
d1476 2
a1477 1
		infprintf (is, "0x%x", GET_OP (l, FT));
d1483 2
a1484 1
	  infprintf (is, "$v%d", GET_OP (l, FD));
d1488 2
a1489 1
	  infprintf (is, "$v%d", GET_OP (l, FS));
d1493 2
a1494 1
	  infprintf (is, "$v%d", GET_OP (l, FT));
d1499 3
a1501 1
	  infprintf (is, _("# internal error, undefined modifier (%c)"), *d);
d1514 1
a1514 1
		 int word,
a1516 2
  static const struct mips_opcode *mips_hash[OP_MASK_OP + 1];
  const fprintf_ftype infprintf = info->fprintf_func;
d1519 1
a1519 1
  void *is = info->stream;
d1533 1
a1533 1
	      if (i == GET_OP (op->match, OP))
d1553 1
a1553 1
  op = mips_hash[GET_OP (word, OP)];
d1565 1
a1565 1
	      if (!opcode_is_member (op, mips_isa, mips_processor)
d1592 1
a1592 1
	      infprintf (is, "%s", op->name);
d1597 1
a1597 1
		  infprintf (is, "\t");
a1604 2
#undef GET_OP_S
#undef GET_OP
d1608 1
a1608 1
  infprintf (is, "0x%x", word);
a1622 8
  const fprintf_ftype infprintf = info->fprintf_func;
  void *is = info->stream;

#define GET_OP(insn, field) \
  (((insn) >> MIPS16OP_SH_##field) & MIPS16OP_MASK_##field)
#define GET_OP_S(insn, field) \
  ((GET_OP (insn, field) ^ ((MIPS16OP_MASK_##field >> 1) + 1)) \
   - ((MIPS16OP_MASK_##field >> 1) + 1))
d1628 1
a1628 1
      infprintf (is, "%c", type);
d1633 3
a1635 1
      infprintf (is, "%s", mips16_reg_names (GET_OP (l, RY)));
d1640 3
a1642 1
      infprintf (is, "%s", mips16_reg_names (GET_OP (l, RX)));
d1646 3
a1648 1
      infprintf (is, "%s", mips16_reg_names (GET_OP (l, RZ)));
d1652 3
a1654 1
      infprintf (is, "%s", mips16_reg_names (GET_OP (l, MOVE32Z)));
d1658 1
a1658 1
      infprintf (is, "%s", mips_gpr_names[0]);
d1662 1
a1662 1
      infprintf (is, "%s", mips_gpr_names[29]);
d1666 1
a1666 1
      infprintf (is, "$pc");
d1670 1
a1670 1
      infprintf (is, "%s", mips_gpr_names[31]);
d1674 3
a1676 1
      infprintf (is, "%s", mips_gpr_names[GET_OP (l, REGR32)]);
d1680 2
a1681 1
      infprintf (is, "%s", mips_gpr_names[MIPS16OP_EXTRACT_REG32R (l)]);
d1719 1
a1719 1
	    immed = GET_OP (l, RZ);
d1725 1
a1725 1
	    immed = GET_OP (l, RX);
d1731 1
a1731 1
	    immed = GET_OP (l, RZ);
d1737 1
a1737 1
	    immed = GET_OP (l, RX);
d1743 1
a1743 1
	    immed = GET_OP (l, IMM4);
d1749 1
a1749 1
	    immed = GET_OP (l, IMM5);
d1756 1
a1756 1
	    immed = GET_OP (l, IMM5);
d1763 1
a1763 1
	    immed = GET_OP (l, IMM5);
d1774 1
a1774 1
	    immed = GET_OP (l, IMM5);
d1780 1
a1780 1
	    immed = GET_OP (l, IMM5);
d1785 1
a1785 1
	    immed = GET_OP (l, IMM6);
d1789 1
a1789 1
	    immed = GET_OP (l, IMM8);
d1794 1
a1794 1
	    immed = GET_OP (l, IMM8);
d1803 1
a1803 1
	    immed = GET_OP (l, IMM8);
d1809 1
a1809 1
	    immed = GET_OP (l, IMM8);
d1814 1
a1814 1
	    immed = GET_OP (l, IMM8);
d1820 1
a1820 1
	    immed = GET_OP (l, IMM8);
d1825 1
a1825 1
	    immed = GET_OP (l, IMM8);
d1832 1
a1832 1
	    immed = GET_OP (l, IMM11);
d1840 1
a1840 1
	    immed = GET_OP (l, IMM8);
d1849 1
a1849 1
	    immed = GET_OP (l, IMM5);
d1857 1
a1857 1
	    immed = GET_OP (l, IMM5);
d1887 1
a1887 1
	  infprintf (is, "%d", immed);
d1965 1
a1965 1
	l = GET_OP (l, IMM6);
d1971 1
a1971 1
	    infprintf (is, "%s", mips_gpr_names[4]);
d1973 2
a1974 1
	      infprintf (is, "-%s", mips_gpr_names[amask + 3]);
d1981 2
a1982 1
	    infprintf (is, "%s??", need_comma ? "," : "");
d1987 3
a1989 1
	    infprintf (is, "%s%s", need_comma ? "," : "", mips_gpr_names[16]);
d1991 2
a1992 1
	      infprintf (is, "-%s", mips_gpr_names[smask + 15]);
d1998 3
a2000 1
	    infprintf (is, "%s%s", need_comma ? "," : "", mips_gpr_names[31]);
d2006 2
a2007 1
	    infprintf (is, "%s$f0", need_comma ? "," : "");
d2009 1
a2009 1
	      infprintf (is, "-$f1");
d2046 1
a2046 1
	  infprintf (is, "%s", mips_gpr_names[4]);
d2048 2
a2049 1
	    infprintf (is, "-%s", mips_gpr_names[4 + args - 1]);
d2057 3
a2059 1
      infprintf (is, "%s%d", need_comma ? "," : "", framesz);
d2062 1
a2062 1
	infprintf (is, ",%s", mips_gpr_names[31]);
d2078 2
a2079 1
	      infprintf (is, ",%s", mips_gpr_names[i == 8 ? 30 : (16 + i)]);
d2084 2
a2085 1
		infprintf (is, "-%s", mips_gpr_names[j == 8 ? 30 : (16 + j)]);
d2092 1
a2092 1
	infprintf (is, ",%s", mips_gpr_names[7]);
d2094 3
a2096 3
	infprintf (is, ",%s-%s",
		   mips_gpr_names[7 - statics + 1],
		   mips_gpr_names[7]);
d2102 4
a2105 4
      infprintf (is,
		 _("# internal disassembler error, "
		   "unrecognised modifier (%c)"),
		 type);
a2114 1
  const fprintf_ftype infprintf = info->fprintf_func;
a2121 1
  void *is = info->stream;
d2158 2
a2159 1
	  infprintf (is, "extend 0x%x", (unsigned int) extend);
d2172 2
a2173 1
	  infprintf (is, "extend 0x%x", (unsigned int) extend);
d2196 2
a2197 1
		  infprintf (is, "extend 0x%x", (unsigned int) extend);
d2219 1
a2219 1
	  infprintf (is, "%s", op->name);
d2221 1
a2221 1
	    infprintf (is, "\t");
d2227 2
a2228 1
		  && GET_OP (insn, RX) == GET_OP (insn, RY))
d2236 2
a2237 1
		  && GET_OP (insn, RZ) == GET_OP (insn, RX))
a2263 2
#undef GET_OP_S
#undef GET_OP
d2266 2
a2267 2
    infprintf (is, "0x%x", extend | 0xf000);
  infprintf (is, "0x%x", insn);
a2377 3
#define GET_OP_S(insn, field) \
  ((GET_OP (insn, field) ^ ((MICROMIPSOP_MASK_##field >> 1) + 1)) \
   - ((MICROMIPSOP_MASK_##field >> 1) + 1))
d2404 4
a2407 1
		  infprintf (is, "%d", GET_OP_S (insn, OFFSET10));
d2464 4
a2467 1
		  infprintf (is, "%d", GET_OP_S (insn, OFFSET12));
d2476 1
a2476 1
				    | (GET_OP (insn, TARGET) << 1));
d2510 2
a2511 1
		  infprintf (is, "%d", GET_OP_S (insn, DELTA));
d2553 1
a2553 1
		  delta = GET_OP_S (insn, DELTA);
d2827 1
a2827 1
		      immed = GET_OP_S (insn, IMMA) << 2;
d2843 1
a2843 1
		      delta = GET_OP_S (insn, IMMD);
d2850 1
a2850 1
		      delta = GET_OP_S (insn, IMME);
d2918 2
a2919 1
		      immed = GET_OP_S (insn, IMMQ) << 2;
d2935 1
a2935 1
		      immed = GET_OP_S (insn, IMMX);
d2941 4
a2944 3
		      immed = GET_OP_S (insn, IMMY) << 2;
		      if ((unsigned int) (immed + 8) < 16)
			immed ^= 0x400;
a2994 1
#undef GET_OP_S
d3076 1
a3076 1
      int insn;
d3079 1
a3079 1
	insn = bfd_getb32 (buffer);
d3081 1
a3081 1
	insn = bfd_getl32 (buffer);
@


1.91
log
@opcodes/
	* mips-dis: Remove gratuitous newline.
@
text
@d2411 1
a2411 1
		  infprintf (is, "0x%lx", GET_OP (insn, STYPE));
d2415 1
a2415 1
		  infprintf (is, "0x%lx", GET_OP (insn, SHAMT));
d2419 1
a2419 1
		  infprintf (is, "0x%lx", GET_OP (insn, 3BITPOS));
d2423 1
a2423 1
		  infprintf (is, "0x%lx", GET_OP (insn, TRAP));
d2455 1
a2455 1
		  infprintf (is, "0x%lx", GET_OP (insn, CODE));
d2463 1
a2463 1
		  infprintf (is, "0x%lx", GET_OP (insn, PREFX));
d2468 1
a2468 1
		  infprintf (is, "0x%lx", GET_OP (insn, IMMEDIATE));
d2522 1
a2522 1
		  infprintf (is, "0x%lx", GET_OP (insn, CODE2));
d2539 1
a2539 1
		  infprintf (is, "0x%lx", GET_OP (insn, CODE10));
d2543 1
a2543 1
		  infprintf (is, "0x%lx", GET_OP (insn, COPZ));
d2558 1
a2558 1
		  infprintf (is, "$%ld", GET_OP (insn, RT));
d2580 1
a2580 1
		      infprintf (is, "$%ld", GET_OP (insn, RS));
d2586 1
a2586 1
		  infprintf (is, "%ld", GET_OP (insn, SEL));
d2594 1
a2594 1
		  infprintf (is, "$fcc%ld", GET_OP (insn, CCC));
d2600 1
a2600 1
			   ? "$fcc%ld" : "$cc%ld",
d2796 1
a2796 1
		      infprintf (is, "0x%lx", immed);
@


1.90
log
@	gas/
	* config/tc-mips.c (mips_cpu_info_table): Add entry for Broadcom XLP.
	* doc/c-mips.texi: Mention XLP.

	opcodes/
	* mips-dis.c (mips_arch_choices): Add entry for Broadcom XLP.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009
a1354 1

@


1.89
log
@bfd:
2011-12-08  Andrew Pinski  <apinski@@cavium.com>
            Adam Nemet  <anemet@@caviumnetworks.com>

	* archures.c (bfd_mach_mips_octeon2): New macro
	* bfd-in2.h: Regenerate.
	* cpu-mips.c (I_mipsocteon2): New enum value.
	(arch_info_struct): Add bfd_mach_mips_octeon2.
	* elfxx-mips.c (_bfd_elf_mips_mach): Support E_MIPS_MACH_OCTEON2.
	(mips_set_isa_flags): Add bfd_mach_mips_octeon2.
	(mips_mach_extensions): Add bfd_mach_mips_octeon2.

gas:
2011-12-08  Andrew Pinski  <apinski@@cavium.com>
            Adam Nemet  <anemet@@caviumnetworks.com>

        * tc-mips.c (CPU_IS_OCTEON): Add Octeon2.
        (mips_cpu_info_table): Add Octeon2.
        * doc/c-mips.texi: Document octeon2 as an acceptable value for -march=.

gas/testsuite:
2011-12-08  Andrew Pinski  <apinski@@cavium.com>
            Adam Nemet  <anemet@@caviumnetworks.com>

        * gas/mips/mips.exp: Add Octeon2 for an architecture.
        Run octeon2 test.
        * gas/mips/octeon2.d: New file.
        * gas/mips/octeon2.s: New file.

include/opcode:
2011-12-08  Andrew Pinski  <apinski@@cavium.com>
            Adam Nemet  <anemet@@caviumnetworks.com>

        * mips.h (INSN_CHIP_MASK): Update according to INSN_OCTEON2.
        (INSN_OCTEON2): New macro.
        (CPU_OCTEON2): New macro.
        (OPCODE_IS_MEMBER): Add Octeon2.

opcodes:
2011-12-08  Andrew Pinski  <apinski@@cavium.com>
            Adam Nemet  <anemet@@caviumnetworks.com>

	* mips-dis.c (mips_arch_choices): Add Octeon2.
	For "octeon+", just include OcteonP for the insn.
	* mips-opc.c (IOCT): Include Octeon2.
	(IOCTP): Include Octeon2.
	(IOCT2): New macro.
	(mips_builtin_opcodes): Add "laa", "laad", "lac", "lacd", "lad",
	"ladd", "lai", "laid", "las", "lasd", "law", "lawd".
	Move "lbux", "ldx", "lhx", "lwx", and "lwux" up to where the standard
	loads are, and add IOCT2 to them.
	Add "lbx" and "lhux".
	Add "qmac.00", "qmac.01", "qmac.02", "qmac.03", "qmacs.00",
	"qmacs.01", "qmacs.01", "qmacs.02" and "qmacs.03".
	Add "zcb" and "zcbt".
@
text
@d622 8
@


1.88
log
@opcode/
2011-11-29  Andrew Pinski  <apinski@@cavium.com>

        * mips-dis.c (mips_arch_choices): Add Octeon+.
        * mips-opc.c (IOCT): Include Octeon+.
        (IOCTP): New macro.
        (mips_builtin_opcodes): Add "saa" and "saad".
bfd/
2011-11-29  Andrew Pinski  <apinski@@cavium.com>

        * archures.c (bfd_mach_mips_octeonp): New macro.
        * bfd-in2.h: Regenerate.
        * bfd/cpu-mips.c (I_mipsocteonp): New enum value.
        (arch_info_struct): Add bfd_mach_mips_octeonp.
        * elfxx-mips.c (mips_set_isa_flags): Add bfd_mach_mips_octeonp.
        (mips_mach_extensions): Add bfd_mach_mips_octeonp.
include/opcodes/
2011-11-29  Andrew Pinski  <apinski@@cavium.com>

        * mips.h (INSN_CHIP_MASK): Update according to INSN_OCTEONP.
        (INSN_OCTEONP): New macro.
        (CPU_OCTEONP): New macro.
        (OPCODE_IS_MEMBER): Add Octeon+.
        (M_SAA_AB, M_SAAD_AB, M_SAA_OB, M_SAAD_OB): New enum values.
gas/
2011-11-29  Andrew Pinski  <apinski@@cavium.com>

        * config/tc-mips.c (CPU_IS_OCTEON): New macro function.
        (CPU_HAS_SEQ): Change to use CPU_IS_OCTEON.
        (NO_ISA_COP): Likewise.
        (macro) <ld_st>: Add support when off0 is true.
        Add support for M_SAA_AB, M_SAA_OB, M_SAAD_OB and M_SAAD_AB.
        (mips_cpu_info_table): Add octeon+.
        * doc/c-mips.texi: Document octeon+ as an acceptable value for -march=.
gas/testsuite/
2011-11-29  Andrew Pinski  <apinski@@cavium.com>

        * gas/mips/mips.exp: Add octeon+ for an architecture.
        Run octeon-saa-saad test.
        (run_dump_test_arch): For Octeon architectures, also try octeon@@.
        * gas/mips/octeon-pref.d: Remove -march=octeon from command line.
        * gas/mips/octeon.d: Likewise.
        * gas/mips/octeon-saa-saad.d: New file.
        * gas/mips/octeon-saa-saad.s: New file
@
text
@d609 5
a613 1
    ISA_MIPS64R2 | INSN_OCTEON | INSN_OCTEONP, mips_cp0_names_numeric,
@


1.87
log
@	* mips-dis.c (print_insn_micromips): Rename local variable iprintf
	to infprintf to avoid shadow warning.
@
text
@d608 4
@


1.86
log
@	gas/
	* config/tc-mips.c (mips_set_options): Add ase_mcu.
	(mips_opts): Initialise ase_mcu to -1.
	(ISA_SUPPORTS_MCU_ASE): New macro.
	(MIPS_CPU_ASE_MCU): Likewise.
	(is_opcode_valid): Handle MCU.
	(macro_build, macro): Likewise.
	(validate_mips_insn, validate_micromips_insn): Likewise.
	(mips_ip): Likewise.
	(options): Add OPTION_MCU and OPTION_NO_MCU.
	(md_longopts): Add mmcu and mno-mcu.
	(md_parse_option): Handle OPTION_MCU and OPTION_NO_MCU.
	(mips_after_parse_args): Handle MCU.
	(s_mipsset): Likewise.
	(md_show_usage): Handle MCU options.

	* doc/as.texinfo: Document -mmcu and -mno-mcu options.
	* doc/c-mips.texi: Likewise, and document ".set mcu" and
	".set nomcu" directives.

	gas/testsuite/
	* gas/mips/micromips@@mcu.d: New test.
	* gas/mips/mcu.d: Likewise.
	* gas/mips/mcu.s: New test source.
	* gas/mips/mips.exp: Run the new tests.

	include/opcode/
	* mips.h (OP_MASK_3BITPOS, OP_SH_3BITPOS): New macros.
	(OP_MASK_OFFSET12, OP_SH_OFFSET12): Redefine.
	(INSN_ASE_MASK): Add the MCU bit.
	(INSN_MCU): New macro.
	(M_ACLR_AB, M_ACLR_OB, M_ASET_AB, M_ASET_OB): New enum values.
	(MICROMIPSOP_MASK_3BITPOS, MICROMIPSOP_SH_3BITPOS): New macros.

	opcodes/
	* mips-dis.c (mips_arch_choices): Enable MCU for "mips32r2"
	and "mips64r2".
	(print_insn_args, print_insn_micromips): Handle MCU.
	* micromips-opc.c (MC): New macro.
	(micromips_opcodes): Add "aclr", "aset" and "iret".
	* mips-opc.c (MC): New macro.
	(mips_builtin_opcodes): Add "aclr", "aset" and "iret".
@
text
@d2263 1
a2263 1
  const fprintf_ftype iprintf = info->fprintf_func;
d2310 1
a2310 1
	  iprintf (is, "micromips 0x%x", higher);
d2323 1
a2323 1
	  iprintf (is, "micromips 0x%x", higher);
d2331 1
a2331 1
      iprintf (is, "0x%x%04x (48-bit insn)", higher, insn);
d2344 1
a2344 1
	  iprintf (is, "micromips 0x%x", higher);
d2374 1
a2374 1
	  iprintf (is, "%s", op->name);
d2376 1
a2376 1
	    iprintf (is, "\t");
d2385 1
a2385 1
		  iprintf (is, "%c", *s);
d2392 1
a2392 1
		  iprintf (is, "%d", delta);
d2396 1
a2396 1
		  iprintf (is, "0x%lx", GET_OP (insn, STYPE));
d2400 1
a2400 1
		  iprintf (is, "0x%lx", GET_OP (insn, SHAMT));
d2404 1
a2404 1
		  iprintf (is, "0x%lx", GET_OP (insn, 3BITPOS));
d2408 1
a2408 1
		  iprintf (is, "0x%lx", GET_OP (insn, TRAP));
d2415 1
a2415 1
		  iprintf (is, "%d", delta);
d2436 1
a2436 1
		  iprintf (is, "%s", mips_gpr_names[GET_OP (insn, RS)]);
d2440 1
a2440 1
		  iprintf (is, "0x%lx", GET_OP (insn, CODE));
d2444 1
a2444 1
		  iprintf (is, "%s", mips_gpr_names[GET_OP (insn, RD)]);
d2448 1
a2448 1
		  iprintf (is, "0x%lx", GET_OP (insn, PREFX));
d2453 1
a2453 1
		  iprintf (is, "0x%lx", GET_OP (insn, IMMEDIATE));
d2459 1
a2459 1
		  iprintf (is, "%d", delta);
d2463 1
a2463 1
		  iprintf (is, "0x%x", GET_OP (insn, CACHE));
d2475 1
a2475 1
			  iprintf (is, "%s", mips_gpr_names[16]);
d2477 1
a2477 1
			  iprintf (is, "%s-%s",
d2481 1
a2481 1
			  iprintf (is, "%s-%s,%s",
d2486 1
a2486 1
			  iprintf (is, "UNKNOWN");
d2492 1
a2492 1
			  iprintf (is, "%s", mips_gpr_names[31]);
d2494 1
a2494 1
			  iprintf (is, ",%s", mips_gpr_names[31]);
d2507 1
a2507 1
		  iprintf (is, "0x%lx", GET_OP (insn, CODE2));
d2512 1
a2512 1
		  iprintf (is, "%s", mips_gpr_names[GET_OP (insn, RT)]);
d2516 1
a2516 1
		  iprintf (is, "%s", mips_gpr_names[GET_OP (insn, RS3)]);
d2520 1
a2520 1
		  iprintf (is, "%s", mips_gpr_names[0]);
d2524 1
a2524 1
		  iprintf (is, "0x%lx", GET_OP (insn, CODE10));
d2528 1
a2528 1
		  iprintf (is, "0x%lx", GET_OP (insn, COPZ));
d2532 1
a2532 1
		  iprintf (is, "%s", mips_fpr_names[GET_OP (insn, FD)]);
d2543 1
a2543 1
		  iprintf (is, "$%ld", GET_OP (insn, RT));
d2562 1
a2562 1
		      iprintf (is, "%s", mips_cp0_names[GET_OP (insn, RS)]);
d2565 1
a2565 1
		      iprintf (is, "$%ld", GET_OP (insn, RS));
d2571 1
a2571 1
		  iprintf (is, "%ld", GET_OP (insn, SEL));
d2575 1
a2575 1
		  iprintf (is, "%s", mips_hwr_names[GET_OP (insn, RS)]);
d2579 1
a2579 1
		  iprintf (is, "$fcc%ld", GET_OP (insn, CCC));
d2583 1
a2583 1
		  iprintf (is,
d2590 1
a2590 1
		  iprintf (is, "%s", mips_fpr_names[GET_OP (insn, FR)]);
d2595 1
a2595 1
		  iprintf (is, "%s", mips_fpr_names[GET_OP (insn, FS)]);
d2599 1
a2599 1
		  iprintf (is, "%s", mips_fpr_names[GET_OP (insn, FT)]);
d2609 1
a2609 1
		      iprintf (is, "0x%x", lsb);
d2614 1
a2614 1
		      iprintf (is, "0x%x", msb - lsb + 1);
d2620 1
a2620 1
		      iprintf (is, "0x%x", msbd + 1);
d2640 1
a2640 1
			  iprintf (is, "%s", n->name);
d2642 1
a2642 1
			  iprintf (is, "$%d,%d", cp0reg, sel);
d2648 1
a2648 1
		      iprintf (is, "0x%x", lsb);
d2653 1
a2653 1
		      iprintf (is, "0x%x", msb - lsb + 1);
d2658 1
a2658 1
		      iprintf (is, "0x%x", msbd + 1);
d2663 1
a2663 1
		      iprintf (is,
d2677 1
a2677 1
		      iprintf (is, "%s", mips_gpr_names[28]);
d2682 1
a2682 1
		      iprintf (is, "%s", mips_gpr_names[regno]);
d2687 1
a2687 1
		      iprintf (is, "%s", mips_gpr_names[regno]);
d2692 1
a2692 1
		      iprintf (is, "%s", mips_gpr_names[regno]);
d2697 1
a2697 1
		      iprintf (is, "%s", mips_gpr_names[regno]);
d2703 1
a2703 1
		      iprintf (is, "%s", mips_gpr_names[lastregno]);
d2708 1
a2708 1
		      iprintf (is, "%s", mips_gpr_names[regno]);
d2713 1
a2713 1
		      iprintf (is, "%s", mips_gpr_names[regno]);
d2718 1
a2718 1
		      iprintf (is, "%s", mips_gpr_names[regno]);
d2722 1
a2722 1
		      iprintf (is, "%s", mips_gpr_names[GET_OP (insn, MJ)]);
d2727 1
a2727 1
		      iprintf (is, "%s", mips_gpr_names[regno]);
d2732 1
a2732 1
		      iprintf (is, "%s", mips_gpr_names[regno]);
d2737 1
a2737 1
		      iprintf (is, "%s", mips_gpr_names[regno]);
d2743 1
a2743 1
		      iprintf (is, "%s", mips_gpr_names[lastregno]);
d2748 1
a2748 1
		      iprintf (is, "%s", mips_gpr_names[regno]);
d2752 1
a2752 1
		      iprintf (is, "$pc");
d2757 1
a2757 1
		      iprintf (is, "%s", mips_gpr_names[29]);
d2761 1
a2761 1
		      iprintf (is, "%s", mips_gpr_names[lastregno]);
d2765 1
a2765 1
		      iprintf (is, "%s", mips_gpr_names[0]);
d2771 1
a2771 1
		      iprintf (is, "%d", immed);
d2776 1
a2776 1
		      iprintf (is, "%d", immed);
d2781 1
a2781 1
		      iprintf (is, "0x%lx", immed);
d2800 1
a2800 1
		      iprintf (is, "0x%x", immed);
d2806 1
a2806 1
		      iprintf (is, "%d", immed);
d2811 1
a2811 1
		      iprintf (is, "%d", immed);
d2817 1
a2817 1
		      iprintf (is, "%d", immed);
d2822 1
a2822 1
		      iprintf (is, "%d", immed);
d2827 1
a2827 1
		      iprintf (is, "%d", immed);
d2833 1
a2833 1
		      iprintf (is, "%d", immed);
d2839 1
a2839 1
			iprintf (is, "%s,%s",
d2843 1
a2843 1
			iprintf (is, "%s-%s,%s",
d2851 1
a2851 1
		      iprintf (is, "0x%x", immed);
d2856 1
a2856 1
		      iprintf (is, "%d", immed);
d2863 1
a2863 1
		      iprintf (is, "%d", immed);
d2868 1
a2868 1
		      iprintf (is, "%d", immed);
d2873 1
a2873 1
		      iprintf (is, "%d", immed);
d2879 1
a2879 1
		      iprintf (is, "%d", immed);
d2888 1
a2888 1
		      iprintf (is, "%d", immed);
d2893 1
a2893 1
		      iprintf (is,
d2903 1
a2903 1
		  iprintf (is,
d2940 1
a2940 1
  iprintf (is, "0x%x", insn);
@


1.86.2.1
log
@	* mips-dis.c (print_insn_micromips): Rename local variable iprintf
	to infprintf to avoid shadow warning.
@
text
@d2263 1
a2263 1
  const fprintf_ftype infprintf = info->fprintf_func;
d2310 1
a2310 1
	  infprintf (is, "micromips 0x%x", higher);
d2323 1
a2323 1
	  infprintf (is, "micromips 0x%x", higher);
d2331 1
a2331 1
      infprintf (is, "0x%x%04x (48-bit insn)", higher, insn);
d2344 1
a2344 1
	  infprintf (is, "micromips 0x%x", higher);
d2374 1
a2374 1
	  infprintf (is, "%s", op->name);
d2376 1
a2376 1
	    infprintf (is, "\t");
d2385 1
a2385 1
		  infprintf (is, "%c", *s);
d2392 1
a2392 1
		  infprintf (is, "%d", delta);
d2396 1
a2396 1
		  infprintf (is, "0x%lx", GET_OP (insn, STYPE));
d2400 1
a2400 1
		  infprintf (is, "0x%lx", GET_OP (insn, SHAMT));
d2404 1
a2404 1
		  infprintf (is, "0x%lx", GET_OP (insn, 3BITPOS));
d2408 1
a2408 1
		  infprintf (is, "0x%lx", GET_OP (insn, TRAP));
d2415 1
a2415 1
		  infprintf (is, "%d", delta);
d2436 1
a2436 1
		  infprintf (is, "%s", mips_gpr_names[GET_OP (insn, RS)]);
d2440 1
a2440 1
		  infprintf (is, "0x%lx", GET_OP (insn, CODE));
d2444 1
a2444 1
		  infprintf (is, "%s", mips_gpr_names[GET_OP (insn, RD)]);
d2448 1
a2448 1
		  infprintf (is, "0x%lx", GET_OP (insn, PREFX));
d2453 1
a2453 1
		  infprintf (is, "0x%lx", GET_OP (insn, IMMEDIATE));
d2459 1
a2459 1
		  infprintf (is, "%d", delta);
d2463 1
a2463 1
		  infprintf (is, "0x%x", GET_OP (insn, CACHE));
d2475 1
a2475 1
			  infprintf (is, "%s", mips_gpr_names[16]);
d2477 1
a2477 1
			  infprintf (is, "%s-%s",
d2481 1
a2481 1
			  infprintf (is, "%s-%s,%s",
d2486 1
a2486 1
			  infprintf (is, "UNKNOWN");
d2492 1
a2492 1
			  infprintf (is, "%s", mips_gpr_names[31]);
d2494 1
a2494 1
			  infprintf (is, ",%s", mips_gpr_names[31]);
d2507 1
a2507 1
		  infprintf (is, "0x%lx", GET_OP (insn, CODE2));
d2512 1
a2512 1
		  infprintf (is, "%s", mips_gpr_names[GET_OP (insn, RT)]);
d2516 1
a2516 1
		  infprintf (is, "%s", mips_gpr_names[GET_OP (insn, RS3)]);
d2520 1
a2520 1
		  infprintf (is, "%s", mips_gpr_names[0]);
d2524 1
a2524 1
		  infprintf (is, "0x%lx", GET_OP (insn, CODE10));
d2528 1
a2528 1
		  infprintf (is, "0x%lx", GET_OP (insn, COPZ));
d2532 1
a2532 1
		  infprintf (is, "%s", mips_fpr_names[GET_OP (insn, FD)]);
d2543 1
a2543 1
		  infprintf (is, "$%ld", GET_OP (insn, RT));
d2562 1
a2562 1
		      infprintf (is, "%s", mips_cp0_names[GET_OP (insn, RS)]);
d2565 1
a2565 1
		      infprintf (is, "$%ld", GET_OP (insn, RS));
d2571 1
a2571 1
		  infprintf (is, "%ld", GET_OP (insn, SEL));
d2575 1
a2575 1
		  infprintf (is, "%s", mips_hwr_names[GET_OP (insn, RS)]);
d2579 1
a2579 1
		  infprintf (is, "$fcc%ld", GET_OP (insn, CCC));
d2583 1
a2583 1
		  infprintf (is,
d2590 1
a2590 1
		  infprintf (is, "%s", mips_fpr_names[GET_OP (insn, FR)]);
d2595 1
a2595 1
		  infprintf (is, "%s", mips_fpr_names[GET_OP (insn, FS)]);
d2599 1
a2599 1
		  infprintf (is, "%s", mips_fpr_names[GET_OP (insn, FT)]);
d2609 1
a2609 1
		      infprintf (is, "0x%x", lsb);
d2614 1
a2614 1
		      infprintf (is, "0x%x", msb - lsb + 1);
d2620 1
a2620 1
		      infprintf (is, "0x%x", msbd + 1);
d2640 1
a2640 1
			  infprintf (is, "%s", n->name);
d2642 1
a2642 1
			  infprintf (is, "$%d,%d", cp0reg, sel);
d2648 1
a2648 1
		      infprintf (is, "0x%x", lsb);
d2653 1
a2653 1
		      infprintf (is, "0x%x", msb - lsb + 1);
d2658 1
a2658 1
		      infprintf (is, "0x%x", msbd + 1);
d2663 1
a2663 1
		      infprintf (is,
d2677 1
a2677 1
		      infprintf (is, "%s", mips_gpr_names[28]);
d2682 1
a2682 1
		      infprintf (is, "%s", mips_gpr_names[regno]);
d2687 1
a2687 1
		      infprintf (is, "%s", mips_gpr_names[regno]);
d2692 1
a2692 1
		      infprintf (is, "%s", mips_gpr_names[regno]);
d2697 1
a2697 1
		      infprintf (is, "%s", mips_gpr_names[regno]);
d2703 1
a2703 1
		      infprintf (is, "%s", mips_gpr_names[lastregno]);
d2708 1
a2708 1
		      infprintf (is, "%s", mips_gpr_names[regno]);
d2713 1
a2713 1
		      infprintf (is, "%s", mips_gpr_names[regno]);
d2718 1
a2718 1
		      infprintf (is, "%s", mips_gpr_names[regno]);
d2722 1
a2722 1
		      infprintf (is, "%s", mips_gpr_names[GET_OP (insn, MJ)]);
d2727 1
a2727 1
		      infprintf (is, "%s", mips_gpr_names[regno]);
d2732 1
a2732 1
		      infprintf (is, "%s", mips_gpr_names[regno]);
d2737 1
a2737 1
		      infprintf (is, "%s", mips_gpr_names[regno]);
d2743 1
a2743 1
		      infprintf (is, "%s", mips_gpr_names[lastregno]);
d2748 1
a2748 1
		      infprintf (is, "%s", mips_gpr_names[regno]);
d2752 1
a2752 1
		      infprintf (is, "$pc");
d2757 1
a2757 1
		      infprintf (is, "%s", mips_gpr_names[29]);
d2761 1
a2761 1
		      infprintf (is, "%s", mips_gpr_names[lastregno]);
d2765 1
a2765 1
		      infprintf (is, "%s", mips_gpr_names[0]);
d2771 1
a2771 1
		      infprintf (is, "%d", immed);
d2776 1
a2776 1
		      infprintf (is, "%d", immed);
d2781 1
a2781 1
		      infprintf (is, "0x%lx", immed);
d2800 1
a2800 1
		      infprintf (is, "0x%x", immed);
d2806 1
a2806 1
		      infprintf (is, "%d", immed);
d2811 1
a2811 1
		      infprintf (is, "%d", immed);
d2817 1
a2817 1
		      infprintf (is, "%d", immed);
d2822 1
a2822 1
		      infprintf (is, "%d", immed);
d2827 1
a2827 1
		      infprintf (is, "%d", immed);
d2833 1
a2833 1
		      infprintf (is, "%d", immed);
d2839 1
a2839 1
			infprintf (is, "%s,%s",
d2843 1
a2843 1
			infprintf (is, "%s-%s,%s",
d2851 1
a2851 1
		      infprintf (is, "0x%x", immed);
d2856 1
a2856 1
		      infprintf (is, "%d", immed);
d2863 1
a2863 1
		      infprintf (is, "%d", immed);
d2868 1
a2868 1
		      infprintf (is, "%d", immed);
d2873 1
a2873 1
		      infprintf (is, "%d", immed);
d2879 1
a2879 1
		      infprintf (is, "%d", immed);
d2888 1
a2888 1
		      infprintf (is, "%d", immed);
d2893 1
a2893 1
		      infprintf (is,
d2903 1
a2903 1
		  infprintf (is,
d2940 1
a2940 1
  infprintf (is, "0x%x", insn);
@


1.85
log
@bfd/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Ilie Garbacea  <ilie@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>
            Catherine Moore  <clm@@codesourcery.com>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* archures.c (bfd_mach_mips_micromips): New macro.
	* cpu-mips.c (I_micromips): New enum value.
	(arch_info_struct): Add bfd_mach_mips_micromips.
	* elfxx-mips.h (_bfd_mips_elf_is_target_special_symbol): New
	prototype.
	(_bfd_mips_elf_relax_section): Likewise.
	(_bfd_mips16_elf_reloc_unshuffle): Rename to...
	(_bfd_mips_elf_reloc_unshuffle): ... this.  Handle microMIPS
	ASE.
	(_bfd_mips16_elf_reloc_shuffle): Rename to...
	(_bfd_mips_elf_reloc_shuffle): ... this.  Handle microMIPS ASE.
	(gprel16_reloc_p): Handle microMIPS ASE.
	(literal_reloc_p): New function.
	* elf32-mips.c (elf_micromips_howto_table_rel): New variable.
	(_bfd_mips_elf32_gprel16_reloc): Handle microMIPS ASE.
	(mips16_gprel_reloc): Update for _bfd_mips_elf_reloc_unshuffle
	and _bfd_mips_elf_reloc_shuffle changes.
	(mips_elf_gprel32_reloc): Update comment.
	(micromips_reloc_map): New variable.
	(bfd_elf32_bfd_reloc_type_lookup): Handle microMIPS ASE.
	(mips_elf32_rtype_to_howto): Likewise.
	(mips_info_to_howto_rel): Likewise.
	(bfd_elf32_bfd_is_target_special_symbol): Define.
	(bfd_elf32_bfd_relax_section): Likewise.
	* elf64-mips.c (micromips_elf64_howto_table_rel): New variable.
	(micromips_elf64_howto_table_rela): Likewise.
	(mips16_gprel_reloc): Update for _bfd_mips_elf_reloc_unshuffle
	and _bfd_mips_elf_reloc_shuffle changes.
	(micromips_reloc_map): Likewise.
	(bfd_elf64_bfd_reloc_type_lookup): Handle microMIPS ASE.
	(bfd_elf64_bfd_reloc_name_lookup): Likewise.
	(mips_elf64_rtype_to_howto): Likewise.
	(bfd_elf64_bfd_is_target_special_symbol): Define.
	* elfn32-mips.c (elf_micromips_howto_table_rel): New variable.
	(elf_micromips_howto_table_rela): Likewise.
	(mips16_gprel_reloc): Update for _bfd_mips_elf_reloc_unshuffle
	and _bfd_mips_elf_reloc_shuffle changes.
	(micromips_reloc_map): Likewise.
	(bfd_elf32_bfd_reloc_type_lookup): Handle microMIPS ASE.
	(bfd_elf32_bfd_reloc_name_lookup): Likewise.
	(mips_elf_n32_rtype_to_howto): Likewise.
	(bfd_elf32_bfd_is_target_special_symbol): Define.
	* elfxx-mips.c (LA25_LUI_MICROMIPS_1): New macro.
	(LA25_LUI_MICROMIPS_2): Likewise.
	(LA25_J_MICROMIPS_1, LA25_J_MICROMIPS_2): Likewise.
	(LA25_ADDIU_MICROMIPS_1, LA25_ADDIU_MICROMIPS_2): Likewise.
	(TLS_RELOC_P): Handle microMIPS ASE.
	(mips_elf_create_stub_symbol): Adjust value of stub symbol if
	target is a microMIPS function.
	(micromips_reloc_p): New function.
	(micromips_reloc_shuffle_p): Likewise.
	(got16_reloc_p, call16_reloc_p): Handle microMIPS ASE.
	(got_disp_reloc_p, got_page_reloc_p): New functions.
	(got_ofst_reloc_p): Likewise.
	(got_hi16_reloc_p, got_lo16_reloc_p): Likewise.
	(call_hi16_reloc_p, call_lo16_reloc_p): Likewise.
	(hi16_reloc_p, lo16_reloc_p, jal_reloc_p): Handle microMIPS ASE.
	(micromips_branch_reloc_p): New function.
	(tls_gd_reloc_p, tls_ldm_reloc_p): Likewise.
	(tls_gottprel_reloc_p): Likewise.
	(_bfd_mips16_elf_reloc_unshuffle): Rename to...
	(_bfd_mips_elf_reloc_unshuffle): ... this.  Handle microMIPS
	ASE.
	(_bfd_mips16_elf_reloc_shuffle): Rename to...
	(_bfd_mips_elf_reloc_shuffle): ... this.  Handle microMIPS ASE.
	(_bfd_mips_elf_lo16_reloc): Handle microMIPS ASE.
	(mips_tls_got_index, mips_elf_got_page): Likewise.
	(mips_elf_create_local_got_entry): Likewise.
	(mips_elf_relocation_needs_la25_stub): Likewise.
	(mips_elf_calculate_relocation): Likewise.
	(mips_elf_perform_relocation): Likewise.
	(_bfd_mips_elf_symbol_processing): Likewise.
	(_bfd_mips_elf_add_symbol_hook): Likewise.
	(_bfd_mips_elf_link_output_symbol_hook): Likewise.
	(mips_elf_add_lo16_rel_addend): Likewise.
	(_bfd_mips_elf_check_relocs): Likewise.
	(mips_elf_adjust_addend): Likewise.
	(_bfd_mips_elf_relocate_section): Likewise.
	(mips_elf_create_la25_stub): Likewise.
	(_bfd_mips_vxworks_finish_dynamic_symbol): Likewise.
	(_bfd_mips_elf_gc_sweep_hook): Likewise.
	(_bfd_mips_elf_is_target_special_symbol): New function.
	(mips_elf_relax_delete_bytes): Likewise.
	(opcode_descriptor): New structure.
	(RA): New macro.
	(OP32_SREG, OP32_TREG, OP16_VALID_REG): Likewise.
	(b_insns_32, bc_insn_32, bz_insn_32, bzal_insn_32): New variables.
	(beq_insn_32): Likewise.
	(b_insn_16, bz_insn_16): New variables.
	(BZC32_REG_FIELD): New macro.
	(bz_rs_insns_32, bz_rt_insns_32): New variables.
	(bzc_insns_32, bz_insns_16):Likewise.
	(BZ16_REG, BZ16_REG_FIELD): New macros.
	(jal_insn_32_bd16, jal_insn_32_bd32): New variables.
	(jal_x_insn_32_bd32): Likewise.
	(j_insn_32, jalr_insn_32): Likewise.
	(ds_insns_32_bd16, ds_insns_32_bd32): Likewise.
	(jalr_insn_16_bd16, jalr_insn_16_bd32, jr_insn_16): Likewise.
	(JR16_REG): New macro.
	(ds_insns_16_bd16): New variable.
	(lui_insn): Likewise.
	(addiu_insn, addiupc_insn): Likewise.
	(ADDIUPC_REG_FIELD): New macro.
	(MOVE32_RD, MOVE32_RS): Likewise.
	(MOVE16_RD_FIELD, MOVE16_RS_FIELD): Likewise.
	(move_insns_32, move_insns_16): New variables.
	(nop_insn_32, nop_insn_16): Likewise.
	(MATCH): New macro.
	(find_match): New function.
	(check_br16_dslot, check_br32_dslot): Likewise.
	(check_br16, check_br32): Likewise.
	(IS_BITSIZE): New macro.
	(check_4byte_branch): New function.
	(_bfd_mips_elf_relax_section): Likewise.
	(_bfd_mips_elf_merge_private_bfd_data): Disallow linking MIPS16
	and microMIPS modules together.
	(_bfd_mips_elf_print_private_bfd_data):	Handle microMIPS ASE.
	* reloc.c (BFD_RELOC_MICROMIPS_7_PCREL_S1): New relocation.
	(BFD_RELOC_MICROMIPS_10_PCREL_S1): Likewise.
	(BFD_RELOC_MICROMIPS_16_PCREL_S1): Likewise.
	(BFD_RELOC_MICROMIPS_GPREL16): Likewise.
	(BFD_RELOC_MICROMIPS_JMP, BFD_RELOC_MICROMIPS_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_HI16_S): Likewise.
	(BFD_RELOC_MICROMIPS_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_LITERAL): Likewise.
	(BFD_RELOC_MICROMIPS_GOT16): Likewise.
	(BFD_RELOC_MICROMIPS_CALL16): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_CALL_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_CALL_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_SUB): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_PAGE): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_OFST): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_DISP): Likewise.
	(BFD_RELOC_MICROMIPS_HIGHEST): Likewise.
	(BFD_RELOC_MICROMIPS_HIGHER): Likewise.
	(BFD_RELOC_MICROMIPS_SCN_DISP): Likewise.
	(BFD_RELOC_MICROMIPS_JALR): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_GD): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_LDM): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_DTPREL_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_DTPREL_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_GOTTPREL): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_TPREL_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_TPREL_LO16): Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

binutils/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* readelf.c (get_machine_flags): Handle microMIPS ASE.
	(get_mips_symbol_other): Likewise.

gas/
2011-02-25  Maciej W. Rozycki  <macro@@codesourcery.com>
            Chao-ying Fu  <fu@@mips.com>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* config/tc-mips.h (mips_segment_info): Add one bit for
	microMIPS.
	(TC_LABEL_IS_LOCAL): New macro.
	(mips_label_is_local): New prototype.
	* config/tc-mips.c (S0, S7): New macros.
	(emit_branch_likely_macro): New variable.
	(mips_set_options): Add micromips.
	(mips_opts): Initialise micromips to -1.
	(file_ase_micromips): New variable.
	(CPU_HAS_MICROMIPS): New macro.
	(hilo_interlocks): Set for microMIPS too.
	(gpr_interlocks): Likewise.
	(cop_interlocks): Likewise.
	(cop_mem_interlocks): Likewise.
	(HAVE_CODE_COMPRESSION): New macro.
	(micromips_op_hash): New variable.
	(micromips_nop16_insn, micromips_nop32_insn): New variables.
	(NOP_INSN): Handle microMIPS ASE.
	(mips32_to_micromips_reg_b_map): New macro.
	(mips32_to_micromips_reg_c_map): Likewise.
	(mips32_to_micromips_reg_d_map): Likewise.
	(mips32_to_micromips_reg_e_map): Likewise.
	(mips32_to_micromips_reg_f_map): Likewise.
	(mips32_to_micromips_reg_g_map): Likewise.
	(mips32_to_micromips_reg_l_map): Likewise.
	(mips32_to_micromips_reg_n_map): Likewise.
	(mips32_to_micromips_reg_h_map): New variable.
	(mips32_to_micromips_reg_m_map): Likewise.
	(mips32_to_micromips_reg_q_map): Likewise.
	(micromips_to_32_reg_h_map): New variable.
	(micromips_to_32_reg_i_map): Likewise.
	(micromips_to_32_reg_m_map): Likewise.
	(micromips_to_32_reg_q_map): Likewise.
	(micromips_to_32_reg_b_map): New macro.
	(micromips_to_32_reg_c_map): Likewise.
	(micromips_to_32_reg_d_map): Likewise.
	(micromips_to_32_reg_e_map): Likewise.
	(micromips_to_32_reg_f_map): Likewise.
	(micromips_to_32_reg_g_map): Likewise.
	(micromips_to_32_reg_l_map): Likewise.
	(micromips_to_32_reg_n_map): Likewise.
	(micromips_imm_b_map, micromips_imm_c_map): New macros.
	(RELAX_DELAY_SLOT_16BIT): New macro.
	(RELAX_DELAY_SLOT_SIZE_FIRST): Likewise.
	(RELAX_DELAY_SLOT_SIZE_SECOND): Likewise.
	(RELAX_MICROMIPS_ENCODE, RELAX_MICROMIPS_P): New macros.
	(RELAX_MICROMIPS_TYPE, RELAX_MICROMIPS_AT): Likewise.
	(RELAX_MICROMIPS_U16BIT, RELAX_MICROMIPS_UNCOND): Likewise.
	(RELAX_MICROMIPS_COMPACT, RELAX_MICROMIPS_LINK): Likewise.
	(RELAX_MICROMIPS_RELAX32, RELAX_MICROMIPS_TOOFAR16): Likewise.
	(RELAX_MICROMIPS_MARK_TOOFAR16): Likewise.
	(RELAX_MICROMIPS_CLEAR_TOOFAR16): Likewise.
	(RELAX_MICROMIPS_TOOFAR32): Likewise.
	(RELAX_MICROMIPS_MARK_TOOFAR32): Likewise.
	(RELAX_MICROMIPS_CLEAR_TOOFAR32): Likewise.
	(INSERT_OPERAND, EXTRACT_OPERAND): Handle microMIPS ASE.
	(mips_macro_warning): Add delay_slot_16bit_p, delay_slot_32bit_p,
	fsize and insns.
	(mips_mark_labels): New function.
	(mips16_small, mips16_ext): Remove variables, replacing with...
	(forced_insn_size): ... this.
	(append_insn, mips16_ip): Update accordingly.
	(micromips_insn_length): New function.
	(insn_length): Return the length of microMIPS instructions.
	(mips_record_mips16_mode): Rename to...
	(mips_record_compressed_mode): ... this.  Handle microMIPS ASE.
	(install_insn): Handle microMIPS ASE.
	(reglist_lookup): New function.
	(is_size_valid, is_delay_slot_valid): Likewise.
	(md_begin): Handle microMIPS ASE.
	(md_assemble): Likewise.  Update for append_insn interface change.
	(micromips_reloc_p): New function.
	(got16_reloc_p): Handle microMIPS ASE.
	(hi16_reloc_p): Likewise.
	(lo16_reloc_p): Likewise.
	(jmp_reloc_p): New function.
	(jalr_reloc_p): Likewise.
	(matching_lo_reloc): Handle microMIPS ASE.
	(insn_uses_reg, reg_needs_delay): Likewise.
	(mips_move_labels): Likewise.
	(mips16_mark_labels): Rename to...
	(mips_compressed_mark_labels): ... this.  Handle microMIPS ASE.
	(gpr_mod_mask): New function.
	(gpr_read_mask, gpr_write_mask): Handle microMIPS ASE.
	(fpr_read_mask, fpr_write_mask): Likewise.
	(insns_between, nops_for_vr4130, nops_for_insn): Likewise.
	(fix_loongson2f_nop, fix_loongson2f_jump): Likewise.
	(MICROMIPS_LABEL_CHAR): New macro.
	(micromips_target_label, micromips_target_name): New variables.
	(micromips_label_name, micromips_label_expr): New functions.
	(micromips_label_inc, micromips_add_label): Likewise.
	(mips_label_is_local): Likewise.
	(micromips_map_reloc): Likewise.
	(can_swap_branch_p): Handle microMIPS ASE.
	(append_insn): Add expansionp argument.  Handle microMIPS ASE.
	(start_noreorder, end_noreorder): Handle microMIPS ASE.
	(macro_start, macro_warning, macro_end): Likewise.
	(brk_fmt, cop12_fmt, jalr_fmt, lui_fmt): New variables.
	(mem12_fmt, mfhl_fmt, shft_fmt, trap_fmt): Likewise.
	(BRK_FMT, COP12_FMT, JALR_FMT, LUI_FMT): New macros.
	(MEM12_FMT, MFHL_FMT, SHFT_FMT, TRAP_FMT): Likewise.
	(macro_build): Handle microMIPS ASE.  Update for append_insn
	interface change.
	(mips16_macro_build): Update for append_insn interface change.
	(macro_build_jalr): Handle microMIPS ASE.
	(macro_build_lui): Likewise.  Simplify.
	(load_register): Handle microMIPS ASE.
	(load_address): Likewise.
	(move_register): Likewise.
	(macro_build_branch_likely): New function.
	(macro_build_branch_ccl): Likewise.
	(macro_build_branch_rs): Likewise.
	(macro_build_branch_rsrt): Likewise.
	(macro): Handle microMIPS ASE.
	(validate_micromips_insn): New function.
	(expr_const_in_range): Likewise.
	(mips_ip): Handle microMIPS ASE.
	(options): Add OPTION_MICROMIPS and OPTION_NO_MICROMIPS.
	(md_longopts): Add mmicromips and mno-micromips.
	(md_parse_option): Handle OPTION_MICROMIPS and
	OPTION_NO_MICROMIPS.
	(mips_after_parse_args): Handle microMIPS ASE.
	(md_pcrel_from): Handle microMIPS relocations.
	(mips_force_relocation): Likewise.
	(md_apply_fix): Likewise.
	(mips_align): Handle microMIPS ASE.
	(s_mipsset): Likewise.
	(s_cpload, s_cpsetup, s_cpreturn): Use relocation wrappers.
	(s_dtprel_internal): Likewise.
	(s_gpword, s_gpdword): Likewise.
	(s_insn): Handle microMIPS ASE.
	(s_mips_stab): Likewise.
	(relaxed_micromips_32bit_branch_length): New function.
	(relaxed_micromips_16bit_branch_length): New function.
	(md_estimate_size_before_relax): Handle microMIPS ASE.
	(mips_fix_adjustable): Likewise.
	(tc_gen_reloc): Handle microMIPS relocations.
	(mips_relax_frag): Handle microMIPS ASE.
	(md_convert_frag): Likewise.
	(mips_frob_file_after_relocs): Likewise.
	(mips_elf_final_processing): Likewise.
	(mips_nop_opcode): Likewise.
	(mips_handle_align): Likewise.
	(md_show_usage): Handle microMIPS options.
	* symbols.c (TC_LABEL_IS_LOCAL): New macro.
	(S_IS_LOCAL): Add a TC_LABEL_IS_LOCAL check.

	* doc/as.texinfo (Target MIPS options): Add -mmicromips and
	-mno-micromips.
	(-mmicromips, -mno-micromips): New options.
	* doc/c-mips.texi (-mmicromips, -mno-micromips): New options.
	(MIPS ISA): Document .set micromips and .set nomicromips.
	(MIPS insn): Update for microMIPS support.

gas/testsuite/
2011-02-25  Maciej W. Rozycki  <macro@@codesourcery.com>
            Chao-ying Fu  <fu@@mips.com>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* gas/mips/micromips.d: New test.
	* gas/mips/micromips-branch-delay.d: Likewise.
	* gas/mips/micromips-branch-relax.d: Likewise.
	* gas/mips/micromips-branch-relax-pic.d: Likewise.
	* gas/mips/micromips-size-1.d: Likewise.
	* gas/mips/micromips-trap.d: Likewise.
	* gas/mips/micromips.l: New stderr output.
	* gas/mips/micromips-branch-delay.l: Likewise.
	* gas/mips/micromips-branch-relax.l: Likewise.
	* gas/mips/micromips-branch-relax-pic.l: Likewise.
	* gas/mips/micromips-size-0.l: New list test.
	* gas/mips/micromips-size-1.l: New stderr output.
	* gas/mips/micromips.s: New test source.
	* gas/mips/micromips-branch-delay.s: Likewise.
	* gas/mips/micromips-branch-relax.s: Likewise.
	* gas/mips/micromips-size-0.s: Likewise.
	* gas/mips/micromips-size-1.s: Likewise.
	* gas/mips/mips.exp: Run the new tests.

	* gas/mips/dli.s: Use .p2align.
	* gas/mips/elf_ase_micromips.d: New test.
	* gas/mips/elf_ase_micromips-2.d: Likewise.
	* gas/mips/micromips@@abs.d: Likewise.
	* gas/mips/micromips@@add.d: Likewise.
	* gas/mips/micromips@@alnv_ps-swap.d: Likewise.
	* gas/mips/micromips@@and.d: Likewise.
	* gas/mips/micromips@@beq.d: Likewise.
	* gas/mips/micromips@@bge.d: Likewise.
	* gas/mips/micromips@@bgeu.d: Likewise.
	* gas/mips/micromips@@blt.d: Likewise.
	* gas/mips/micromips@@bltu.d: Likewise.
	* gas/mips/micromips@@branch-likely.d: Likewise.
	* gas/mips/micromips@@branch-misc-1.d: Likewise.
	* gas/mips/micromips@@branch-misc-2-64.d: Likewise.
	* gas/mips/micromips@@branch-misc-2.d: Likewise.
	* gas/mips/micromips@@branch-misc-2pic-64.d: Likewise.
	* gas/mips/micromips@@branch-misc-2pic.d: Likewise.
	* gas/mips/micromips@@branch-misc-4-64.d: Likewise.
	* gas/mips/micromips@@branch-misc-4.d: Likewise.
	* gas/mips/micromips@@branch-self.d: Likewise.
	* gas/mips/micromips@@cache.d: Likewise.
	* gas/mips/micromips@@daddi.d: Likewise.
	* gas/mips/micromips@@dli.d: Likewise.
	* gas/mips/micromips@@elf-jal.d: Likewise.
	* gas/mips/micromips@@elf-rel2.d: Likewise.
	* gas/mips/micromips@@elfel-rel2.d: Likewise.
	* gas/mips/micromips@@elf-rel4.d: Likewise.
	* gas/mips/micromips@@jal-svr4pic.d: Likewise.
	* gas/mips/micromips@@jal-svr4pic-noreorder.d: Likewise.
	* gas/mips/micromips@@lb-svr4pic-ilocks.d: Likewise.
	* gas/mips/micromips@@li.d: Likewise.
	* gas/mips/micromips@@loc-swap-dis.d: Likewise.
	* gas/mips/micromips@@loc-swap.d: Likewise.
	* gas/mips/micromips@@mips1-fp.d: Likewise.
	* gas/mips/micromips@@mips32-cp2.d: Likewise.
	* gas/mips/micromips@@mips32-imm.d: Likewise.
	* gas/mips/micromips@@mips32-sf32.d: Likewise.
	* gas/mips/micromips@@mips32.d: Likewise.
	* gas/mips/micromips@@mips32r2-cp2.d: Likewise.
	* gas/mips/micromips@@mips32r2-fp32.d: Likewise.
	* gas/mips/micromips@@mips32r2-sync.d: Likewise.
	* gas/mips/micromips@@mips32r2.d: Likewise.
	* gas/mips/micromips@@mips4-branch-likely.d: Likewise.
	* gas/mips/micromips@@mips4-fp.d: Likewise.
	* gas/mips/micromips@@mips4.d: Likewise.
	* gas/mips/micromips@@mips5.d: Likewise.
	* gas/mips/micromips@@mips64-cp2.d: Likewise.
	* gas/mips/micromips@@mips64.d: Likewise.
	* gas/mips/micromips@@mips64r2.d: Likewise.
	* gas/mips/micromips@@pref.d: Likewise.
	* gas/mips/micromips@@relax-at.d: Likewise.
	* gas/mips/micromips@@relax.d: Likewise.
	* gas/mips/micromips@@rol-hw.d: Likewise.
	* gas/mips/micromips@@uld2-eb.d: Likewise.
	* gas/mips/micromips@@uld2-el.d: Likewise.
	* gas/mips/micromips@@ulh2-eb.d: Likewise.
	* gas/mips/micromips@@ulh2-el.d: Likewise.
	* gas/mips/micromips@@ulw2-eb-ilocks.d: Likewise.
	* gas/mips/micromips@@ulw2-el-ilocks.d: Likewise.
	* gas/mips/cache.d: Likewise.
	* gas/mips/daddi.d: Likewise.
	* gas/mips/mips32-imm.d: Likewise.
	* gas/mips/pref.d: Likewise.
	* gas/mips/elf-rel27.d: Handle microMIPS ASE.
	* gas/mips/l_d.d: Likewise.
	* gas/mips/l_d-n32.d: Likewise.
	* gas/mips/l_d-n64.d: Likewise.
	* gas/mips/ld.d: Likewise.
	* gas/mips/ld-n32.d: Likewise.
	* gas/mips/ld-n64.d: Likewise.
	* gas/mips/s_d.d: Likewise.
	* gas/mips/s_d-n32.d: Likewise.
	* gas/mips/s_d-n64.d: Likewise.
	* gas/mips/sd.d: Likewise.
	* gas/mips/sd-n32.d: Likewise.
	* gas/mips/sd-n64.d: Likewise.
	* gas/mips/mips32.d: Update immediates.
	* gas/mips/micromips@@mips32-cp2.s: New test source.
	* gas/mips/micromips@@mips32-imm.s: Likewise.
	* gas/mips/micromips@@mips32r2-cp2.s: Likewise.
	* gas/mips/micromips@@mips64-cp2.s: Likewise.
	* gas/mips/cache.s: Likewise.
	* gas/mips/daddi.s: Likewise.
	* gas/mips/mips32-imm.s: Likewise.
	* gas/mips/elf-rel4.s: Handle microMIPS ASE.
	* gas/mips/lb-pic.s: Likewise.
	* gas/mips/ld.s: Likewise.
	* gas/mips/mips32.s: Likewise.
	* gas/mips/mips.exp: Add the micromips arch.  Exclude mips16e
	from micromips.  Run mips32-imm.

	* gas/mips/jal-mask-11.d: New test.
	* gas/mips/jal-mask-12.d: Likewise.
	* gas/mips/micromips@@jal-mask-11.d: Likewise.
	* gas/mips/jal-mask-1.s: Source for the new tests.
	* gas/mips/jal-mask-21.d: New test.
	* gas/mips/jal-mask-22.d: Likewise.
	* gas/mips/micromips@@jal-mask-12.d: Likewise.
	* gas/mips/jal-mask-2.s: Source for the new tests.
	* gas/mips/mips.exp: Run the new tests.

	* gas/mips/mips16-e.d: Add --special-syms to `objdump'.
	* gas/mips/tmips16-e.d: Likewise.
	* gas/mips/mipsel16-e.d: Likewise.
	* gas/mips/tmipsel16-e.d: Likewise.

	* gas/mips/and.s: Adjust padding.
	* gas/mips/beq.s: Likewise.
	* gas/mips/bge.s: Likewise.
	* gas/mips/bgeu.s: Likewise.
	* gas/mips/blt.s: Likewise.
	* gas/mips/bltu.s: Likewise.
	* gas/mips/branch-misc-2.s: Likewise.
	* gas/mips/jal.s: Likewise.
	* gas/mips/li.s: Likewise.
	* gas/mips/mips4.s: Likewise.
	* gas/mips/mips4-fp.s: Likewise.
	* gas/mips/relax.s: Likewise.
	* gas/mips/and.d: Update accordingly.
	* gas/mips/elf-jal.d: Likewise.
	* gas/mips/jal.d: Likewise.
	* gas/mips/li.d: Likewise.
	* gas/mips/relax-at.d: Likewise.
	* gas/mips/relax.d: Likewise.

include/elf/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (R_MICROMIPS_min): New relocations.
	(R_MICROMIPS_26_S1): Likewise.
	(R_MICROMIPS_HI16, R_MICROMIPS_LO16): Likewise.
	(R_MICROMIPS_GPREL16, R_MICROMIPS_LITERAL): Likewise.
	(R_MICROMIPS_GOT16, R_MICROMIPS_PC7_S1): Likewise.
	(R_MICROMIPS_PC10_S1, R_MICROMIPS_PC16_S1): Likewise.
	(R_MICROMIPS_CALL16, R_MICROMIPS_GOT_DISP): Likewise.
	(R_MICROMIPS_GOT_PAGE, R_MICROMIPS_GOT_OFST): Likewise.
	(R_MICROMIPS_GOT_HI16, R_MICROMIPS_GOT_LO16): Likewise.
	(R_MICROMIPS_SUB, R_MICROMIPS_HIGHER): Likewise.
	(R_MICROMIPS_HIGHEST, R_MICROMIPS_CALL_HI16): Likewise.
	(R_MICROMIPS_CALL_LO16, R_MICROMIPS_SCN_DISP): Likewise.
	(R_MICROMIPS_JALR, R_MICROMIPS_HI0_LO16): Likewise.
	(R_MICROMIPS_TLS_GD, R_MICROMIPS_TLS_LDM): Likewise.
	(R_MICROMIPS_TLS_DTPREL_HI, R_MICROMIPS_TLS_DTPREL_LO): Likewise.
	(R_MICROMIPS_TLS_GOTTPREL): Likewise.
	(R_MICROMIPS_TLS_TPREL_HI16): Likewise.
	(R_MICROMIPS_TLS_TPREL_LO16): Likewise.
	(R_MICROMIPS_GPREL7_S2, R_MICROMIPS_PC23_S2): Likewise.
	(R_MICROMIPS_max): Likewise.
	(EF_MIPS_ARCH_ASE_MICROMIPS): New macro.
	(STO_MIPS_ISA, STO_MIPS_FLAGS): Likewise.
	(ELF_ST_IS_MIPS_PLT, ELF_ST_SET_MIPS_PLT): Likewise.
	(STO_MICROMIPS): Likewise.
	(ELF_ST_IS_MICROMIPS, ELF_ST_SET_MICROMIPS): Likewise.
	(ELF_ST_IS_COMPRESSED): Likewise.
	(STO_MIPS_PLT, STO_MIPS_PIC): Rework.
	(ELF_ST_IS_MIPS_PIC, ELF_ST_SET_MIPS_PIC): Likewise.
	(STO_MIPS16, ELF_ST_IS_MIPS16, ELF_ST_SET_MIPS16): Likewise.

include/opcode/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (OP_MASK_EXTLSB, OP_SH_EXTLSB): New macros.
	(OP_MASK_STYPE, OP_SH_STYPE): Likewise.
	(OP_MASK_CODE10, OP_SH_CODE10): Likewise.
	(OP_MASK_TRAP, OP_SH_TRAP): Likewise.
	(OP_MASK_OFFSET12, OP_SH_OFFSET12): Likewise.
	(OP_MASK_OFFSET10, OP_SH_OFFSET10): Likewise.
	(OP_MASK_RS3, OP_SH_RS3): Likewise.
	(OP_MASK_MB, OP_SH_MB, OP_MASK_MC, OP_SH_MC): Likewise.
	(OP_MASK_MD, OP_SH_MD, OP_MASK_ME, OP_SH_ME): Likewise.
	(OP_MASK_MF, OP_SH_MF, OP_MASK_MG, OP_SH_MG): Likewise.
	(OP_MASK_MJ, OP_SH_MJ, OP_MASK_ML, OP_SH_ML): Likewise.
	(OP_MASK_MP, OP_SH_MP, OP_MASK_MQ, OP_SH_MQ): Likewise.
	(OP_MASK_IMMA, OP_SH_IMMA, OP_MASK_IMMB, OP_SH_IMMB): Likewise.
	(OP_MASK_IMMC, OP_SH_IMMC, OP_MASK_IMMF, OP_SH_IMMF): Likewise.
	(OP_MASK_IMMG, OP_SH_IMMG, OP_MASK_IMMH, OP_SH_IMMH): Likewise.
	(OP_MASK_IMMI, OP_SH_IMMI, OP_MASK_IMMJ, OP_SH_IMMJ): Likewise.
	(OP_MASK_IMML, OP_SH_IMML, OP_MASK_IMMM, OP_SH_IMMM): Likewise.
	(OP_MASK_IMMN, OP_SH_IMMN, OP_MASK_IMMO, OP_SH_IMMO): Likewise.
	(OP_MASK_IMMP, OP_SH_IMMP, OP_MASK_IMMQ, OP_SH_IMMQ): Likewise.
	(OP_MASK_IMMU, OP_SH_IMMU, OP_MASK_IMMW, OP_SH_IMMW): Likewise.
	(OP_MASK_IMMX, OP_SH_IMMX, OP_MASK_IMMY, OP_SH_IMMY): Likewise.
	(INSN_WRITE_GPR_S): New macro.
	(INSN2_BRANCH_DELAY_16BIT, INSN2_BRANCH_DELAY_32BIT): Likewise.
	(INSN2_READ_FPR_D): Likewise.
	(INSN2_MOD_GPR_MB, INSN2_MOD_GPR_MC): Likewise.
	(INSN2_MOD_GPR_MD, INSN2_MOD_GPR_ME): Likewise.
	(INSN2_MOD_GPR_MF, INSN2_MOD_GPR_MG): Likewise.
	(INSN2_MOD_GPR_MJ, INSN2_MOD_GPR_MP): Likewise.
	(INSN2_MOD_GPR_MQ, INSN2_MOD_SP): Likewise.
	(INSN2_READ_GPR_31, INSN2_READ_GP, INSN2_READ_PC): Likewise.
	(INSN2_UNCOND_BRANCH, INSN2_COND_BRANCH): Likewise.
	(INSN2_MOD_GPR_MHI, INSN2_MOD_GPR_MM, INSN2_MOD_GPR_MN): Likewise.
	(CPU_MICROMIPS): New macro.
	(M_BC1FL, M_BC1TL, M_BC2FL, M_BC2TL): New enum values.
	(M_BEQL, M_BGEZ, M_BGEZL, M_BGEZALL, M_BGTZ, M_BGTZL): Likewise.
	(M_BLEZ, M_BLEZL, M_BLTZ, M_BLTZL, M_BLTZALL, M_BNEL): Likewise.
	(M_CACHE_OB, M_JALS_1, M_JALS_2, M_JALS_A): Likewise.
	(M_LDC2_OB, M_LDL_OB, M_LDM_AB, M_LDM_OB): Likewise.
	(M_LDP_AB, M_LDP_OB, M_LDR_OB, M_LL_OB, M_LLD_OB): Likewise.
	(M_LWC2_OB, M_LWL_OB, M_LWM_AB, M_LWM_OB): Likewise.
	(M_LWP_AB, M_LWP_OB, M_LWR_OB): Likewise.
	(M_LWU_OB, M_PREF_OB, M_SC_OB, M_SCD_OB): Likewise.
	(M_SDC2_OB, M_SDL_OB, M_SDM_AB, M_SDM_OB): Likewise.
	(M_SDP_AB, M_SDP_OB, M_SDR_OB): Likewise.
	(M_SWC2_OB, M_SWL_OB, M_SWM_AB, M_SWM_OB): Likewise.
	(M_SWP_AB, M_SWP_OB, M_SWR_OB): Likewise.
	(MICROMIPSOP_MASK_MAJOR, MICROMIPSOP_SH_MAJOR): New macros.
	(MICROMIPSOP_MASK_IMMEDIATE, MICROMIPSOP_SH_IMMEDIATE): Likewise.
	(MICROMIPSOP_MASK_DELTA, MICROMIPSOP_SH_DELTA): Likewise.
	(MICROMIPSOP_MASK_CODE10, MICROMIPSOP_SH_CODE10): Likewise.
	(MICROMIPSOP_MASK_TRAP, MICROMIPSOP_SH_TRAP): Likewise.
	(MICROMIPSOP_MASK_SHAMT, MICROMIPSOP_SH_SHAMT): Likewise.
	(MICROMIPSOP_MASK_TARGET, MICROMIPSOP_SH_TARGET): Likewise.
	(MICROMIPSOP_MASK_EXTLSB, MICROMIPSOP_SH_EXTLSB): Likewise.
	(MICROMIPSOP_MASK_EXTMSBD, MICROMIPSOP_SH_EXTMSBD): Likewise.
	(MICROMIPSOP_MASK_INSMSB, MICROMIPSOP_SH_INSMSB): Likewise.
	(MICROMIPSOP_MASK_CODE, MICROMIPSOP_SH_CODE): Likewise.
	(MICROMIPSOP_MASK_CODE2, MICROMIPSOP_SH_CODE2): Likewise.
	(MICROMIPSOP_MASK_CACHE, MICROMIPSOP_SH_CACHE): Likewise.
	(MICROMIPSOP_MASK_SEL, MICROMIPSOP_SH_SEL): Likewise.
	(MICROMIPSOP_MASK_OFFSET12, MICROMIPSOP_SH_OFFSET12): Likewise.
	(MICROMIPSOP_MASK_3BITPOS, MICROMIPSOP_SH_3BITPOS): Likewise.
	(MICROMIPSOP_MASK_STYPE, MICROMIPSOP_SH_STYPE): Likewise.
	(MICROMIPSOP_MASK_OFFSET10, MICROMIPSOP_SH_OFFSET10): Likewise.
	(MICROMIPSOP_MASK_RS, MICROMIPSOP_SH_RS): Likewise.
	(MICROMIPSOP_MASK_RT, MICROMIPSOP_SH_RT): Likewise.
	(MICROMIPSOP_MASK_RD, MICROMIPSOP_SH_RD): Likewise.
	(MICROMIPSOP_MASK_FS, MICROMIPSOP_SH_FS): Likewise.
	(MICROMIPSOP_MASK_FT, MICROMIPSOP_SH_FT): Likewise.
	(MICROMIPSOP_MASK_FD, MICROMIPSOP_SH_FD): Likewise.
	(MICROMIPSOP_MASK_FR, MICROMIPSOP_SH_FR): Likewise.
	(MICROMIPSOP_MASK_RS3, MICROMIPSOP_SH_RS3): Likewise.
	(MICROMIPSOP_MASK_PREFX, MICROMIPSOP_SH_PREFX): Likewise.
	(MICROMIPSOP_MASK_BCC, MICROMIPSOP_SH_BCC): Likewise.
	(MICROMIPSOP_MASK_CCC, MICROMIPSOP_SH_CCC): Likewise.
	(MICROMIPSOP_MASK_COPZ, MICROMIPSOP_SH_COPZ): Likewise.
	(MICROMIPSOP_MASK_MB, MICROMIPSOP_SH_MB): Likewise.
	(MICROMIPSOP_MASK_MC, MICROMIPSOP_SH_MC): Likewise.
	(MICROMIPSOP_MASK_MD, MICROMIPSOP_SH_MD): Likewise.
	(MICROMIPSOP_MASK_ME, MICROMIPSOP_SH_ME): Likewise.
	(MICROMIPSOP_MASK_MF, MICROMIPSOP_SH_MF): Likewise.
	(MICROMIPSOP_MASK_MG, MICROMIPSOP_SH_MG): Likewise.
	(MICROMIPSOP_MASK_MH, MICROMIPSOP_SH_MH): Likewise.
	(MICROMIPSOP_MASK_MI, MICROMIPSOP_SH_MI): Likewise.
	(MICROMIPSOP_MASK_MJ, MICROMIPSOP_SH_MJ): Likewise.
	(MICROMIPSOP_MASK_ML, MICROMIPSOP_SH_ML): Likewise.
	(MICROMIPSOP_MASK_MM, MICROMIPSOP_SH_MM): Likewise.
	(MICROMIPSOP_MASK_MN, MICROMIPSOP_SH_MN): Likewise.
	(MICROMIPSOP_MASK_MP, MICROMIPSOP_SH_MP): Likewise.
	(MICROMIPSOP_MASK_MQ, MICROMIPSOP_SH_MQ): Likewise.
	(MICROMIPSOP_MASK_IMMA, MICROMIPSOP_SH_IMMA): Likewise.
	(MICROMIPSOP_MASK_IMMB, MICROMIPSOP_SH_IMMB): Likewise.
	(MICROMIPSOP_MASK_IMMC, MICROMIPSOP_SH_IMMC): Likewise.
	(MICROMIPSOP_MASK_IMMD, MICROMIPSOP_SH_IMMD): Likewise.
	(MICROMIPSOP_MASK_IMME, MICROMIPSOP_SH_IMME): Likewise.
	(MICROMIPSOP_MASK_IMMF, MICROMIPSOP_SH_IMMF): Likewise.
	(MICROMIPSOP_MASK_IMMG, MICROMIPSOP_SH_IMMG): Likewise.
	(MICROMIPSOP_MASK_IMMH, MICROMIPSOP_SH_IMMH): Likewise.
	(MICROMIPSOP_MASK_IMMI, MICROMIPSOP_SH_IMMI): Likewise.
	(MICROMIPSOP_MASK_IMMJ, MICROMIPSOP_SH_IMMJ): Likewise.
	(MICROMIPSOP_MASK_IMML, MICROMIPSOP_SH_IMML): Likewise.
	(MICROMIPSOP_MASK_IMMM, MICROMIPSOP_SH_IMMM): Likewise.
	(MICROMIPSOP_MASK_IMMN, MICROMIPSOP_SH_IMMN): Likewise.
	(MICROMIPSOP_MASK_IMMO, MICROMIPSOP_SH_IMMO): Likewise.
	(MICROMIPSOP_MASK_IMMP, MICROMIPSOP_SH_IMMP): Likewise.
	(MICROMIPSOP_MASK_IMMQ, MICROMIPSOP_SH_IMMQ): Likewise.
	(MICROMIPSOP_MASK_IMMU, MICROMIPSOP_SH_IMMU): Likewise.
	(MICROMIPSOP_MASK_IMMW, MICROMIPSOP_SH_IMMW): Likewise.
	(MICROMIPSOP_MASK_IMMX, MICROMIPSOP_SH_IMMX): Likewise.
	(MICROMIPSOP_MASK_IMMY, MICROMIPSOP_SH_IMMY): Likewise.
	(MICROMIPSOP_MASK_CODE, MICROMIPSOP_SH_CODE): Likewise.
	(MICROMIPSOP_MASK_CODE2, MICROMIPSOP_SH_CODE2): Likewise.
	(MICROMIPSOP_MASK_CACHE, MICROMIPSOP_SH_CACHE): Likewise.
	(MICROMIPSOP_MASK_CODE20, MICROMIPSOP_SH_CODE20): Likewise.
	(MICROMIPSOP_MASK_PERFREG, MICROMIPSOP_SH_PERFREG): Likewise.
	(MICROMIPSOP_MASK_CODE19, MICROMIPSOP_SH_CODE19): Likewise.
	(MICROMIPSOP_MASK_ALN, MICROMIPSOP_SH_ALN): Likewise.
	(MICROMIPSOP_MASK_VECBYTE, MICROMIPSOP_SH_VECBYTE): Likewise.
	(MICROMIPSOP_MASK_VECALIGN, MICROMIPSOP_SH_VECALIGN): Likewise.
	(MICROMIPSOP_MASK_DSPACC, MICROMIPSOP_SH_DSPACC): Likewise.
	(MICROMIPSOP_MASK_DSPACC_S, MICROMIPSOP_SH_DSPACC_S): Likewise.
	(MICROMIPSOP_MASK_DSPSFT, MICROMIPSOP_SH_DSPSFT): Likewise.
	(MICROMIPSOP_MASK_DSPSFT_7, MICROMIPSOP_SH_DSPSFT_7): Likewise.
	(MICROMIPSOP_MASK_SA3, MICROMIPSOP_SH_SA3): Likewise.
	(MICROMIPSOP_MASK_SA4, MICROMIPSOP_SH_SA4): Likewise.
	(MICROMIPSOP_MASK_IMM8, MICROMIPSOP_SH_IMM8): Likewise.
	(MICROMIPSOP_MASK_IMM10, MICROMIPSOP_SH_IMM10): Likewise.
	(MICROMIPSOP_MASK_WRDSP, MICROMIPSOP_SH_WRDSP): Likewise.
	(MICROMIPSOP_MASK_RDDSP, MICROMIPSOP_SH_RDDSP): Likewise.
	(MICROMIPSOP_MASK_BP, MICROMIPSOP_SH_BP): Likewise.
	(MICROMIPSOP_MASK_MT_U, MICROMIPSOP_SH_MT_U): Likewise.
	(MICROMIPSOP_MASK_MT_H, MICROMIPSOP_SH_MT_H): Likewise.
	(MICROMIPSOP_MASK_MTACC_T, MICROMIPSOP_SH_MTACC_T): Likewise.
	(MICROMIPSOP_MASK_MTACC_D, MICROMIPSOP_SH_MTACC_D): Likewise.
	(MICROMIPSOP_MASK_BBITIND, MICROMIPSOP_SH_BBITIND): Likewise.
	(MICROMIPSOP_MASK_CINSPOS, MICROMIPSOP_SH_CINSPOS): Likewise.
	(MICROMIPSOP_MASK_CINSLM1, MICROMIPSOP_SH_CINSLM1): Likewise.
	(MICROMIPSOP_MASK_SEQI, MICROMIPSOP_SH_SEQI): Likewise.
	(micromips_opcodes): New declaration.
	(bfd_micromips_num_opcodes): Likewise.

ld/testsuite/
2011-02-25  Catherine Moore  <clm@@codesourcery.com>
            Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* lib/ld-lib.exp (run_dump_test): Support distinct assembler
	flags for the same source named multiple times.
	* ld-mips-elf/jalx-1.s: New test source.
	* ld-mips-elf/jalx-1.d: New test output.
	* ld-mips-elf/jalx-1.ld: New test linker script.
	* ld-mips-elf/jalx-2-main.s: New test source.
	* ld-mips-elf/jalx-2-ex.s: Likewise.
	* ld-mips-elf/jalx-2-printf.s: Likewise.
	* ld-mips-elf/jalx-2.dd: New test output.
	* ld-mips-elf/jalx-2.ld: New test linker script.
	* ld-mips-elf/mips16-and-micromips.d: New test.
	* ld-mips-elf/mips-elf.exp: Run the new tests

opcodes/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* micromips-opc.c: New file.
	* mips-dis.c (micromips_to_32_reg_b_map): New array.
	(micromips_to_32_reg_c_map, micromips_to_32_reg_d_map): Likewise.
	(micromips_to_32_reg_e_map, micromips_to_32_reg_f_map): Likewise.
	(micromips_to_32_reg_g_map, micromips_to_32_reg_l_map): Likewise.
	(micromips_to_32_reg_q_map): Likewise.
	(micromips_imm_b_map, micromips_imm_c_map): Likewise.
	(micromips_ase): New variable.
	(is_micromips): New function.
	(set_default_mips_dis_options): Handle microMIPS ASE.
	(print_insn_micromips): New function.
	(is_compressed_mode_p): Likewise.
	(_print_insn_mips): Handle microMIPS instructions.
	* Makefile.am (CFILES): Add micromips-opc.c.
	* configure.in (bfd_mips_arch): Add micromips-opc.lo.
	* Makefile.in: Regenerate.
	* configure: Regenerate.

	* mips-dis.c (micromips_to_32_reg_h_map): New variable.
	(micromips_to_32_reg_i_map): Likewise.
	(micromips_to_32_reg_m_map): Likewise.
	(micromips_to_32_reg_n_map): New macro.
@
text
@d567 1
a567 1
     | INSN_MIPS3D | INSN_MT),
d581 1
a581 1
     | INSN_DSP64 | INSN_MT | INSN_MDMX),
d1173 12
d2403 4
@


1.84
log
@Take unadjusted offset for loongson3a specific instructions.
@
text
@d60 85
d625 1
d708 11
d724 3
a726 2
  /* Defaults: mipsIII/r3000 (?!), (o)32-style ("oldabi") GPR names,
     and numeric FPR, CP0 register, and HWR names.  */
d728 2
a729 1
  mips_processor =  CPU_R3000;
d738 1
a738 1
  /* If an ELF "newabi" binary, use the n32/(n)64 GPR names.  */
d744 1
d747 2
d2246 717
d2974 1
d2981 7
d2989 1
a2989 1
  /* FIXME: If odd address, this is CLEARLY a mips 16 instruction.  */
d2992 1
a2992 1
    return print_insn_mips16 (memaddr, info);
d2996 2
a2997 6
  if (info->mach == bfd_mach_mips16
      || (info->symbols != NULL
	  && bfd_asymbol_flavour (*info->symbols) == bfd_target_elf_flavour
	  && ELF_ST_IS_MIPS16 ((*(elf_symbol_type **) info->symbols)
			       ->internal_elf_sym.st_other)))
    return print_insn_mips16 (memaddr, info);
@


1.83
log
@include/opcode/
2010-12-14  Mingjie Xing  <mingjie.xing@@gmail.com>

	* mips.h (OP_*_OFFSET_A, OP_*_OFFSET_B, OP_*_OFFSET_C)
	(OP_*_RZ, OP_*_FZ, INSN2_M_FP_D, INSN2_WRITE_GPR_Z, INSN2_WRITE_FPR_Z)
	(INSN2_READ_GPR_Z, INSN2_READ_FPR_Z, INSN2_READ_GPR_D): Define.

opcodes/
2010-12-14  Mingjie Xing  <mingjie.xing@@gmail.com>

	* mips-opc.c (WR_z, WR_Z, RD_z, RD_Z, RD_d): Define.
	(mips_builtin_opcodes): Add loongson3a specific instructions.
	* mips-dis.c (print_insn_args): Handle the new arguments +a|b|c|z|Z.

gas/
2010-12-14  Mingjie Xing  <mingjie.xing@@gmail.com>

	* config/tc-mips.c (insn_uses_reg): Handle the new flags
	INSN2_READ_FPR_Z, INSN2_READ_GPR_D and INSN2_READ_GPR_Z.
	(append_insn): Handle delay-slot filling for the new flags.
	(validate_mips_insn): Handle the new arguments +a|b|c|z|Z.
	(mips_ip): Handle the new arguments +a|b|c|z|Z.

gas/testsuite/
2010-12-14  Mingjie Xing  <mingjie.xing@@gmail.com>

	* gas/mips/loongson-3a-2.s, gas/mips/loongson-3a-2.d,
	gas/mips/loongson-3a-3.s, gas/mips/loongson-3a-3.d: New tests.
	* gas/mips/mips.exp: Run them.
@
text
@d994 2
a995 1
	      (*info->fprintf_func) (info->stream, "%d", delta);
@


1.82
log
@	bfd/
	* archures.c (bfd_mach_mips_loongson_3a): Defined.
	* bfd-in2.h (bfd_mach_mips_loongson_3a): Defined.
	* cpu-mips.c (I_loongson_3a): New add.
	(arch_info_struct): Add loongson_3a.
	* elfxx-mips.c (_bfd_elf_mips_mach): Add loongson_3a.
	(mips_set_isa_flags): Add loongson_3a.
	(mips_mach_extensions): Add loongson_3a in MIPS64 extensions.

	binutils/
	* readelf.c (get_machine_flags): Add loongson-3a.

	gas/
	* config/tc-mips.c (mips_cpu_info_table): Add loongson3a in MIPS 64.
	* doc/c-mips.texi (MIPS cpu): Add loongson3a.

	include/
	* elf/mips.h (E_MIPS_MACH_LS3A): Defined.
	* opcode/mips.h (INSN_LOONGSON_3A): Defined.
	(CPU_LOONGSON_3A): Defined.
	(OPCODE_IS_MEMBER): Add LOONGSON_3A.

	opcodes/
	* mips-dis.c (mips_arch_choices): Add loongson3a.
	* mips-opc.c (IL3A): Defined as INSN_LOONGSON_3A.
	(mips_builtin_opcodes): Modify some instructions' membership from
	IL2F to IL2F|IL3A, since these instructions are supported by Loongson_3A.
@
text
@d976 31
@


1.81
log
@	* mips-dis.c (print_insn_mips): Correct branch instruction type
	determination.
@
text
@d515 4
@


1.80
log
@	gas/
	* config/tc-mips.c (nops_for_insn_or_target): Replace
	MIPS16_INSN_BRANCH with MIPS16_INSN_UNCOND_BRANCH and
	MIPS16_INSN_COND_BRANCH.

	include/opcode/
	* mips.h (MIPS16_INSN_UNCOND_BRANCH): New macro.
	(MIPS16_INSN_BRANCH): Rename to...
	(MIPS16_INSN_COND_BRANCH): ... this.

	opcodes/
	* mips-dis.c (print_mips16_insn_arg): Remove branch instruction
	type and delay slot determination.
	(print_insn_mips16): Extend branch instruction type and delay
	slot determination to cover all instructions.
	* mips16-opc.c (BR): Remove macro.
	(UBR, CBR): New macros.
	(mips16_opcodes): Update branch annotation for "b", "beqz",
	"bnez", "bteqz" and "btnez".  Add branch annotation for "jalrc"
	and "jrc".
@
text
@d1407 2
a1408 1
		  if ((info->insn_type & INSN_WRITE_GPR_31) != 0)
d1417 1
a1417 1
		  if ((info->insn_type & INSN_WRITE_GPR_31) != 0)
@


1.79
log
@	gas/
	* config/tc-mips.c (is_opcode_valid): Remove expansionp.
	(macro_build): Change invocation of is_opcode_valid.
	(mips_ip): Likewise.

	gas/testsuite/
	* gas/mips/mips-no-jalx.l: Delete.
	* gas/mips/mips-no-jalx.s: Delete.
	* gas/mips/mips-jalx-2.d: New.
	* gas/mips/mips-jalx-2.s: New.
	* gas/mips/mips.exp (mips-jalx-2): Run new test.
	(mips-no-jalx): Remove deleted test.

	include/
	* opcode/mips.h (INSN_MIPS16): Remove.

	opcodes/
	* mips-dis.c (mips_arch): Remove INSN_MIPS16.
	* mips-opc.c (I16): Remove.
	(mips_builtin_op): Reclassify jalx.
@
text
@a1662 1
	    info->insn_type = dis_condbranch;
a1669 1
	    info->insn_type = dis_branch;
a1789 2
      info->insn_type = dis_jsr;
      info->branch_delay_insns = 1;
d2081 1
d2083 3
d2087 3
a2089 2
	      info->branch_delay_insns = 1;
	      if (info->insn_type != dis_jsr)
d2092 2
@


1.78
log
@update copyright dates
@
text
@d475 1
a475 1
    ISA_MIPS32 | INSN_MIPS16 | INSN_SMARTMIPS,
d481 1
a481 1
    (ISA_MIPS32R2 | INSN_MIPS16 | INSN_SMARTMIPS | INSN_DSP | INSN_DSPR2
d489 1
a489 1
    ISA_MIPS64 | INSN_MIPS16 | INSN_MIPS3D | INSN_MDMX,
d495 1
a495 1
    (ISA_MIPS64R2 | INSN_MIPS16 | INSN_MIPS3D | INSN_DSP | INSN_DSPR2
d527 1
a527 1
  { "",		1, bfd_mach_mips16, CPU_MIPS16, ISA_MIPS3 | INSN_MIPS16,
@


1.77
log
@bfd:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* aoutx.h (NAME (aout, machine_type)): Handle bfd_mach_mips_xlr.
	* archures.c (bfd_mach_mips_xlr): Define.
	* bfd-in2.h: Regenerate.
	* cpu-mips.c (I_xlr): Define.
	(arch_info_struct): Add XLR entry.
	* elfxx-mips.c (_bfd_elf_mips_mach): Handle E_MIPS_MACH_XLR.
	(mips_set_isa_flags): Handle bfd_mach_mips_xlr
	(mips_mach_extensions): Add XLR entry.

binutils:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* readelf.c (get_machine_flags): Handle E_MIPS_MACH_XLR.

gas:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* config/tc-mips.c (macro): Handle M_MSGSND, M_MSGLD, M_MSGLD_T,
	M_MSGWAIT and M_MSGWAIT_T.
	(mips_cpu_info_table): Add XLR entry.
	* doc/c-mips.texi (-march): Document xlr.

gas/testsuite:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* gas/mips/mips.exp (xlr): New architecture.
	(xlr-ext): Run test.
	* gas/mips/xlr-ext.d, gas/mips/xlr-ext.s: New.

include/elf:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* mips.h (E_MIPS_MACH_XLR): Define.

include/opcode:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* mips.h (INSN_XLR): Define.
	(INSN_CHIP_MASK): Update.
	(CPU_XLR): Define.
	(OPCODE_IS_MEMBER): Update.
	(M_MSGSND, M_MSGLD, M_MSGLD_T, M_MSGWAIT, M_MSGWAIT_T): Define.

opcodes:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* mips-dis.c (mips_cp0_names_xlr, mips_cp0sel_names_xlr): Define.
	(mips_arch_choices): Add XLR entry.
	* mips-opc.c (XLR): Define.
	(mips_builtin_opcodes): Add XLR instructions.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2005, 2007, 2008
@


1.76
log
@	* aoutx.h (NAME): Add case statements for bfd_mach_mips14000,
	bfd_mach_mips16000.
	* archures.c (bfd_architecture): Add .#defines for bfd_mach_mips14000,
	bfd_mach_mips16000.
	* bfd-in2.h: Regenerate.
	* cpu-mips.c: Add enums I_mips14000, I_mips16000.
	(arch_info_struct): Add refs to R14000, R16000.
	* elfxx-mips.c (mips_set_isa_flags): Handle bfd_mach_mips14000,
	bfd_mach_mips16000.
	(mips_mach_extensions): Map R14000, R16000 to R10000.

	* config/tc-mips.c (hilo_interlocks): Handle CPU_R14000, CPU_R16000.
	(mips_cpu_info_table): Add r14000, r16000.
	* doc/c-mips.texi: Add entries for 14000, 16000.

	* mips-dis.c (mips_arch_choices): Add r14000, r16000.

	* mips.h: Define CPU_R14000, CPU_R16000.
        (OPCODE_IS_MEMBER): Include R14000, R16000 in test.
@
text
@d322 50
d519 6
@


1.75
log
@2008-11-06  Chao-ying Fu  <fu@@mips.com>

	* mips-opc.c (synciobdma, syncs, syncw, syncws): Move these
	before sync.
	(sync): New instruction with 5-bit sync type.
	* mips-dis.c (print_insn_args: Add case '1' to print 5-bit values.
@
text
@d412 4
@


1.74
log
@include/elf/
	* mips.h (ELF_ST_IS_MIPS16, ELF_ST_SET_MIPS16): New macros.

bfd/
	* elfxx-mips.c (mips_elf_check_mips16_stubs): Use ELF_ST_IS_MIPS16.
	(mips_elf_calculate_relocation): Likewise.
	(_bfd_mips_elf_add_symbol_hook): Likewise.
	(_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	(_bfd_mips_vxworks_finish_dynamic_symbol): Likewise.

opcodes/
	* mips-dis.c (_print_insn_mips): Use ELF_ST_IS_MIPS16.

gas/
	* config/tc-mips.c (mips16_mark_labels): Use ELF_ST_SET_MIPS16.
	(mips_fix_adjustable): Likewise.
	(mips_frob_file_after_relocs): Likewise.

gas/testsuite/
	* gas/mips/mips16-vis-1.d, gas/mips/mips16-vis-1.s: New tests.
	* gas/mips/mips.exp: Run them.
@
text
@d1107 1
@


1.73
log
@bfd/
	* syms.c (BSF_SYNTHETIC): New flag.
	* elf.c (_bfd_elf_get_synthetic_symtab): Set it.
	* elf32-ppc.c (ppc_elf_get_synthetic_symtab): Likewise.
	* elf64-ppc.c (ppc64_elf_get_synthetic_symtab): Likewise.
	* bfd-in.h (bfd_asymbol_flavour): Return bfd_target_unknown_flavour
	for synthetic symbols.
	* bfd-in2.h: Regenerate.

opcodes/
	* mips-dis.c (_print_insn_mips): Use bfd_asymbol_flavour to check
	for ELF symbols.
@
text
@d2071 2
a2072 2
	  && ((*(elf_symbol_type **) info->symbols)->internal_elf_sym.st_other
	      == STO_MIPS16)))
@


1.72
log
@        * mips.h: Document new field descriptors +Q.
        (OP_SH_SEQI, OP_MASK_SEQI): New bit mask and shift count for SEQI.

opcodes/

        * mips-dis.c (print_insn_args): Handle field descriptor +Q.
        * mips-opc.c (mips_builtin_opcodes): Add Octeon instructions seq,
        seqi, sne and snei.

gas/

        * config/tc-mips.c (validate_mips_insn): Handle field descriptor +Q.
        (mips_ip): Likewise.
        (macro_build): Likewise.
        (CPU_HAS_SEQ): New macro.
        (macro2) <M_SEQ_I, M_SNE_I>: Use it.  Emit seq/sne and seqi/snei.

gas/testsuite/

        * gas/mips/octeon.s, gas/mips/octeon.d: Add tests for seq* and sne*.
        * gas/mips/octeon-ill.s, gas/mips/octeon-ill.s: Add tests for seqi
        and snei.
@
text
@d2069 2
a2070 2
      || (info->flavour == bfd_target_elf_flavour
	  && info->symbols != NULL
@


1.71
log
@include/opcode/

        * mips.h: Document new field descriptors +x, +X, +p, +P, +s, +S.
        Update comment before MIPS16 field descriptors to mention MIPS16.
        (OP_SH_BBITIND, OP_MASK_BBITIND): New bit mask and shift count for
        BBIT.
        (OP_SH_CINSPOS, OP_MASK_CINSPOS, OP_SH_CINSLM1, OP_MASK_CINSLM1):
        New bit masks and shift counts for cins and exts.

gas/

        * config/tc-mips.c (validate_mips_insn): Handle field descriptors
        +x, +X, +p, +P, +s, +S.
        (mips_ip): Likewise.

opcodes/

        * mips-dis.c (print_insn_args): Handle field descriptors +x, +p,
        +s, +S.
        * mips-opc.c (mips_builtin_opcodes): Add Octeon instructions
        baddu, bbit*, cins*, dmul, pop, dpop, exts*, mtm*, mtp*, syncs,
        syncw, syncws, vm3mulu, vm0 and vmulu.

gas/testsuite/

        * gas/mips/octeon.s, gas/mips/octeon.d: Add tests for baddu,
        bbit*, cins*, dmul, pop, dpop, exts*, mtm*, mtp*, syncs, syncw,
        syncws, vm3mulu, vm0 and vmulu.
        * gas/mips/octeon-ill.s, gas/mips/octeon-ill.s: New test.
        * gas/mips/mips.exp: Run it.  Run octeon test with
        run_dump_test_arches.
@
text
@d905 7
@


1.70
log
@	* mips-dis.c: Update copyright.
	(mips_arch_choices): Add Octeon.
	* mips-opc.c: Update copyright.
	(IOCT): New macro.
	(mips_builtin_opcodes): Add Octeon instruction synciobdma.
@
text
@d885 20
@


1.69
log
@	bfd/
	* archures.c (bfd_mach_mips_loongson_2e): New.
	(bfd_mach_mips_loongson_2f): New.
	* bfd-in2.h (bfd_mach_mips_loongson_2e): New.
	(bfd_mach_mips_loongson_2f): New.
	* cpu-mips.c: Add I_loongson_2e and I_loongson_2f to
	anonymous enum.
	(arch_info_struct): Add Loongson-2E and Loongson-2F entries.
	* elfxx-mips.c (_bfd_elf_mips_mach): Handle Loongson-2E
	and Loongson-2F flags.
	(mips_set_isa_flags): Likewise.
	(mips_mach_extensions): Add Loongson-2E and Loongson-2F
	entries.

	binutils/
	* readelf.c (get_machine_flags): Handle Loongson-2E and -2F
	flags.

	gas/
	* config/tc-mips.c (mips_cpu_info_table): Add loongson2e
	and loongson2f entries.
	* doc/c-mips.texi: Document -march=loongson{2e,2f} options.

	gas/testsuite/
	* gas/mips/mips.exp: Add loongson-2e and -2f tests.
	* gas/mips/loongson-2e.d: New.
	* gas/mips/loongson-2e.s: New.
	* gas/mips/loongson-2f.d: New.
	* gas/mips/loongson-2f.s: New.

	include/elf/
	* mips.h (E_MIPS_MACH_LS2E): New.
	(E_MIPS_MACH_LS2F): New.

	include/opcode/
	* mips.h (INSN_LOONGSON_2E): New.
	(INSN_LOONGSON_2F): New.
	(CPU_LOONGSON_2E): New.
	(CPU_LOONGSON_2F): New.
	(OPCODE_IS_MEMBER): Update for Loongson-2E and -2F flags.

	opcodes/
	* mips-dis.c (mips_arch_choices): Add Loongson-2E and -2F
	entries.
	* mips-opc.c (IL2E): New.
	(IL2F): New.
	(mips_builtin_opcodes): Add Loongson-2E and -2F instructions.
	Allow movz and movn for Loongson-2E and -2F.  Add movnz entry.
	Move coprocessor encodings to the end of the table.  Allow
	certain MIPS V .ps instructions on the Loongson-2E and -2F.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2005, 2007
d461 4
@


1.68
log
@opcodes/:
* opcodes/mips-dis.c (mips_cp0_names_r3000): New definition.
(mips_cp0_names_r4000): Likewise.
(mips_arch_choices): Link to the above as appropriate.

gas/testsuite/:
* gas/mips/cp0-names-r3000.d: New test for R3000 CP0 symbolic
disassembly.
* gas/mips/cp0-names-r4000.d: New test for R4000/R4400 symbolic
CP0 disassembly.
* mips/mips.exp: Run the new tests.
@
text
@d453 8
@


1.67
log
@* mt-asm.c (parse_imm16): Reword error message in order to allow it to be translated properly.
* ia64-gen.c (print_dependency_table): Likewise.
* mips-dis.c (print_insn_args): Likewise.
@
text
@d127 24
d373 1
a373 1
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
d377 1
a377 1
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
d389 1
a389 1
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
@


1.66
log
@Change source files over to GPLv3.
@
text
@d1211 1
a1211 1
				 _("# internal error, undefined modifier(%c)"),
@


1.65
log
@	[ gas/ChangeLog ]
	* config/tc-mips.c (mips_set_options, mips_opts, file_ase_dspr2,
	ISA_SUPPORTS_DSPR2_ASE, MIPS_CPU_ASE_DSPR2): Add DSP R2 ASE support.
	(macro_build): Add case '2'.
	(macro): Expand M_BALIGN to nop, packrl.ph or balign.
	(validate_mips_insn): Add support for balign instruction.
	(mips_ip): Handle DSP R2 instructions. Support balign instruction.
	(OPTION_DSPR2, OPTION_NO_DSPR2, OPTION_COMPAT_ARCH_BASE,
	md_parse_option, mips_after_parse_args): Add -mdspr2 and -mno-dspr2
	command line options.
	(s_mipsset): Add support for .set dspr2 and .set nodspr2 directives.
	(md_show_usage): Add -mdspr2 and -mno-dspr2 help output.
	* doc/c-mips.texi, doc/as.texinfo: Document -mdspr2, -mno-dspr2,
	.set dspr2, .set nodspr2.

	[ gas/testsuite/ChangeLog ]
	* gas/mips/mips32-dspr2.s, gas/mips/mips32-dspr2.d: New test for
	DSP R2.
	* gas/mips/mips.exp: Run new test.

	[ include/opcode/Changelog ]
	* mips.h (OP_SH_BP, OP_MASK_BP): Add support for balign instruction.
	(INSN_DSPR2): Add flag for DSP R2 instructions.
	(M_BALIGN): New macro.

	[ opcodes/ChangeLog ]
	* mips-dis.c (mips_arch_choices): Add DSP R2 support.
	(print_insn_args): Add support for balign instruction.
	* mips-opc.c (D33): New shortcut for DSP R2 instructions.
	(mips_builtin_opcodes): Add DSP R2 instructions.

	[ sim/mips/ChangeLog ]
	* Makefile.in (IGEN_INCLUDE): Add dsp2.igen.
	* configure.ac (mips*-sde-elf*, mipsisa32r2*-*-*, mipsisa64r2*-*-*):
	Add dsp2 to sim_igen_machine.
	* configure: Regenerate.
	* dsp.igen (do_ph_op): Add MUL support when op = 2.
	(do_ph_mulq): New function to support mulq_rs.ph and mulq_s.ph.
	(mulq_rs.ph): Use do_ph_mulq.
	(MFHI, MFLO, MTHI, MTLO): Move these instructions to mips.igen.
	* mips.igen: Add dsp2 model and include dsp2.igen.
	(MFHI, MFLO, MTHI, MTLO): Extend these instructions for
	for *mips32r2, *mips64r2, *dsp.
	(MADD, MADDU, MSUB, MSUBU, MULT, MULTU): Extend these instructions
	for *mips32r2, *mips64r2, *dsp2.
	* dsp2.igen: New file for MIPS DSP REV 2 ASE.

	[ sim/testsuite/sim/mips/ChangeLog ]
	* basic.exp: Run the dsp2 test.
	* utils-dsp.inc (dspckacc_astio, dspck_tsimm): New macro.
	* mips32-dsp2.s: New test.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2005
d7 1
a7 1
   This file is part of GDB, GAS, and the GNU binutils.
d9 1
a9 1
   This program is free software; you can redistribute it and/or modify
d11 2
a12 2
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d14 4
a17 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
@


1.64
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d403 2
a404 2
    (ISA_MIPS32R2 | INSN_MIPS16 | INSN_SMARTMIPS | INSN_DSP | INSN_MIPS3D
     | INSN_MT),
d417 2
a418 2
    (ISA_MIPS64R2 | INSN_MIPS16 | INSN_MIPS3D | INSN_DSP | INSN_DSP64
     | INSN_MT | INSN_MDMX),
d858 5
@


1.63
log
@	[ gas/ChangeLog ]
	* config/tc-mips.c (ISA_SUPPORTS_DSP64): New macro.
	(CPU_HAS_MIPS3D, CPU_HAS_MDMX, CPU_HAS_DSP, CPU_HAS_MT): Delete.
	(macro_build): Update comment.
	(mips_ip): Allow DSP64 instructions for MIPS64R2.
	(mips_after_parse_args): Remove uses of CPU_HAS_MIPS3D and
	CPU_HAS_MDMX.
	(mips_cpu_info): Fix formatting. Add MIPS_CPU_ASE_MIPS3D and
	MIPS_CPU_ASE_MDMX flags for sb1.

	[ gas/testsuite/ChangeLog ]
	* gas/mips/mips64-dsp.s, gas/mips/mips64-dsp.d: New DSP64 tests.
	* gas/mips/mips.exp: Run DSP64 tests.

	[ opcodes/ChangeLog ]
	* mips-dis.c: Disassemble DSP64 instructions for MIPS64R2.
	* mips-opc.c: Add DSP64 instructions.
@
text
@d578 1
a578 1
  if (strncmp (option, "no-aliases", 10) == 0)
@


1.62
log
@[ gas/testsuite/ChangeLog ]
2006-05-04  Thiemo Seufer  <ths@@mips.com>
            Nigel Stephens  <nigel@@mips.com>

        * gas/mips/mips.exp: Run mips32-dsp tests only for mips32r2.
        * gas/mips/set-arch.d: Adjust according to opcode table changes.

[ include/opcode/ChangeLog ]
2006-05-04  Thiemo Seufer  <ths@@mips.com>
            Nigel Stephens  <nigel@@mips.com>
            David Ung  <davidu@@mips.com>

        * mips.h: Add INSN_SMARTMIPS define.

[ opcodes/ChangeLog ]
2006-05-04  Thiemo Seufer  <ths@@mips.com>
            Nigel Stephens  <nigel@@mips.com>
            David Ung  <davidu@@mips.com>

        * mips-dis.c (mips_arch_choices): Add smartmips instruction
        decoding to MIPS32 and MIPS32R2.  Limit DSP decoding to release
        2 ISAs.  Add MIPS3D decoding to MIPS32R2.  Add MT decoding to
        MIPS64R2.
        * mips-opc.c: fix random typos in comments.
        (INSN_SMARTMIPS): New defines.
        (mips_builtin_opcodes): Add paired single support for MIPS32R2.
        Move bc3f, bc3fl, bc3t, bc3tl downwards.  Move flushi, flushd,
        flushid, wb upwards.  Move cfc3, ctc3 downwards.  Rework the
        FP_S and FP_D flags to denote single and double register
        accesses separately.  Move dmfc3, dmtc3, mfc3, mtc3 downwards.
        Allow jr.hb and jalr.hb for release 1 ISAs.  Allow luxc1, suxc1
        for MIPS32R2.  Add SmartMIPS instructions.  Add two-argument
        variants of bc2f, bc2fl, bc2t, bc2tl.  Add mfhc2, mthc2 to
        release 2 ISAs.
        * mips16-opc.c (mips16_opcodes): Add sdbbp instruction.
@
text
@d417 1
a417 1
    (ISA_MIPS64R2 | INSN_MIPS16 | INSN_MIPS3D | INSN_DSP
@


1.61
log
@	* mips-dis.c (print_insn_args): Force mips16 to odd addresses.
	(print_mips16_insn_arg): Force mips16 to odd addresses.
@
text
@d397 1
a397 1
    ISA_MIPS32 | INSN_MIPS16 | INSN_DSP,
d403 2
a404 1
    ISA_MIPS32R2 | INSN_MIPS16 | INSN_DSP | INSN_MT,
d411 1
a411 1
    ISA_MIPS64 | INSN_MIPS16 | INSN_MIPS3D | INSN_MDMX | INSN_DSP,
d417 2
a418 1
    ISA_MIPS64R2 | INSN_MIPS16 | INSN_MIPS3D | INSN_MDMX | INSN_DSP,
@


1.60
log
@[ gas/ChangeLog ]
2006-04-30  Thiemo Seufer  <ths@@mips.com>
            David Ung  <davidu@@mips.com>

        * config/tc-mips.c (validate_mips_insn): Handling of udi cases.
        (mips_immed): New table that records various handling of udi
        instruction patterns.
        (mips_ip): Adds udi handling.

[ include/opcode/ChangeLog ]
2006-04-30  Thiemo Seufer  <ths@@mips.com>
            David Ung  <davidu@@mips.com>

        * mips.h: Defines udi bits and masks.  Add description of
        characters which may appear in the args field of udi
        instructions.

[ opcodes/ChangeLog ]
2006-04-30  Thiemo Seufer  <ths@@mips.com>
            David Ung  <davidu@@mips.com>

        * mips-opc.c (mips_builtin_opcodes): Add udi instructions
        "udi0" to "udi15".
        * mips-dis.c (print_insn_args): Adds udi argument handling.
@
text
@d987 4
d1639 4
d1649 10
a1658 3
      if (! use_extend)
	extend = 0;
      l = ((l & 0x1f) << 23) | ((l & 0x3e0) << 13) | (extend << 2);
@


1.59
log
@[ opcodes/ChangeLog ]
2006-04-28  Thiemo Seufer  <ths@@mips.com>
            David Ung  <davidu@@mips.com>
            Nigel Stevens  <nigel@@mips.com>

	* mips-dis.c (mips_cp0sel_names_mips3264r2): Add MT register
        names.

[ gas/testsuite/ChangeLog ]
2006-04-28  Thiemo Seufer  <ths@@mips.com>
            David Ung  <davidu@@mips.com>
            Nigel Stevens  <nigel@@mips.com>

	* gas/mips/cp0sel-names-mips32r2.d,
	gas/mips/cp0sel-names-mips64r2.d: Update for MT register names.
@
text
@d756 20
@


1.58
log
@	* mips-dis.c (print_insn_args): Add mips_opcode argument.
	(print_insn_mips):  Adjust print_insn_args call.
@
text
@d187 16
d204 5
@


1.57
log
@	* mips-dis.c (print_insn_args): Print $fcc only for FP
	instructions, use $cc elsewise.
@
text
@d694 2
a695 1
		 struct disassemble_info *info)
d1256 1
a1256 1
		  print_insn_args (d, word, memaddr, info);
@


1.56
log
@	* opcodes/mips-dis.c (mips16_to_32_reg_map, mips16_reg_names):
	Map MIPS16 registers to O32 names.
	(print_mips16_insn_arg): Use mips16_reg_names.
@
text
@d1075 3
a1077 1
	  (*info->fprintf_func) (info->stream, "$fcc%ld",
@


1.55
log
@        * mips.h: Assign 'm'/'M' codes to MIPS16e save/restore
        instructions.  Define MIPS16_ALL_ARGS and MIPS16_ALL_STATICS for
        save/restore encoding of the args field.

        * mips16-opc.c: Add MIPS16e save/restore opcodes.
        * mips-dis.c (print_mips16_insn_arg): Handle printing of 'm'/'M'
        codes for save/restore.

        * config/tc-mips.c (mips16_ip): Add handling of 'm' and 'M' codes
        for the MIPS16e save/restore instructions.

        * gas/mips/mips.exp: Run new save/restore tests.
        * gas/testsuite/gas/mips/mips16e-save.s: New test for generating
        different styles of save/restore instructions.
        * gas/testsuite/gas/mips/mips16e-save.d: New.
@
text
@d54 2
a55 2
/* The mips16 register names.  */
static const char * const mips16_reg_names[] =
d57 1
a57 1
  "s0", "s1", "v0", "v1", "a0", "a1", "a2", "a3"
d60 3
d1289 2
a1290 2
			     mips16_reg_names[((l >> MIPS16OP_SH_RY)
					       & MIPS16OP_MASK_RY)]);
d1296 2
a1297 2
			     mips16_reg_names[((l >> MIPS16OP_SH_RX)
					       & MIPS16OP_MASK_RX)]);
d1302 2
a1303 2
			     mips16_reg_names[((l >> MIPS16OP_SH_RZ)
					       & MIPS16OP_MASK_RZ)]);
d1308 2
a1309 2
			     mips16_reg_names[((l >> MIPS16OP_SH_MOVE32Z)
					       & MIPS16OP_MASK_MOVE32Z)]);
@


1.54
log
@* mips-opc.c (MT32): New define.
(mips_builtin_opcodes): Move "bc0f", "bc0fl", "bc0t", "bc0tl" to the
bottom to avoid opcode collision with "mftr" and "mttr".
Add MT instructions.
* mips-dis.c (mips_arch_choices): Enable INSN_MT for mips32r2.
(print_insn_args): Add supports for +t, +T, !, $, *, &, g operand
formats.
@
text
@d1659 86
@


1.53
log
@* mips-opc.c (WR_a, RD_a, MOD_a, DSP_VOLA, D32): New define.
(mips_builtin_opcodes): Add DSP instructions.
* mips-dis.c (mips_arch_choices): Enable INSN_DSP for mips32, mips32r2,
mips64, mips64r2.
(print_insn_args): Add supports for 3, 4, 5, 6, 7, 8, 9, 0, :, ', @@
operand formats.
@
text
@d379 1
a379 1
    ISA_MIPS32R2 | INSN_MIPS16 | INSN_DSP,
d774 28
d872 26
@


1.52
log
@Kaveh Ghazi's printf format attribute checking patch.
bfd:
	* elf32-xtensa.c (vsprint_msg): Add format attribute.  Fix
	format bugs.
	* vms.h (_bfd_vms_debug): Add format attribute.
	(_bfd_vms_debug, _bfd_hexdump): Fix typos.

binutils:
	* bucomm.h (report): Add format attribute.
	* dlltool.c (inform): Likewise.
	* dllwrap.c (display, inform, warn): Likewise.
	* objdump.c (objdump_sprintf): Likewise.
	* readelf.c (error, warn): Likewise.  Fix format bugs.

gas:
	* config/tc-tic30.c (debug): Add format attribute.  Fix format
	bugs.

include:
	* dis-asm.h (fprintf_ftype): Add format attribute.

opcodes:
	* arc-dis.c, arm-dis.c, cris-dis.c, crx-dis.c, d10v-dis.c,
	d30v-dis.c, fr30-dis.c, h8300-dis.c, h8500-dis.c, i860-dis.c,
	ia64-dis.c, ip2k-dis.c, m10200-dis.c, m10300-dis.c,
	m88k-dis.c, mcore-dis.c, mips-dis.c, ms1-dis.c, or32-dis.c,
	ppc-dis.c, sh64-dis.c, sparc-dis.c, tic4x-dis.c, tic80-dis.c,
	v850-dis.c: Fix format bugs.
	* ia64-gen.c (fail, warn): Add format attribute.
	* or32-opc.c (debug): Likewise.
@
text
@d373 1
a373 1
    ISA_MIPS32 | INSN_MIPS16,
d379 1
a379 1
    ISA_MIPS32R2 | INSN_MIPS16,
d386 1
a386 1
    ISA_MIPS64 | INSN_MIPS16 | INSN_MIPS3D | INSN_MDMX,
d392 1
a392 1
    ISA_MIPS64R2 | INSN_MIPS16 | INSN_MIPS3D | INSN_MDMX,
d783 61
@


1.51
log
@Update function declarations to ISO C90 formatting
@
text
@d799 1
a799 1
	  (*info->fprintf_func) (info->stream, "0x%x",
d873 1
a873 1
	  (*info->fprintf_func) (info->stream, "0x%x",
d878 1
a878 1
	  (*info->fprintf_func) (info->stream, "0x%x",
d883 1
a883 1
	  (*info->fprintf_func) (info->stream, "0x%x",
d888 1
a888 1
	  (*info->fprintf_func) (info->stream, "0x%x",
d893 2
a894 1
	  (*info->fprintf_func) (info->stream, "0x%x",
d899 1
a899 1
	  (*info->fprintf_func) (info->stream, "0x%x",
d933 1
a933 1
	  (*info->fprintf_func) (info->stream, "$%d",
d947 1
a947 1
	    (*info->fprintf_func) (info->stream, "$%d",
d957 1
a957 1
	  (*info->fprintf_func) (info->stream, "$fcc%d",
d962 1
a962 1
	  (*info->fprintf_func) (info->stream, "$fcc%d",
d967 1
a967 1
	  (*info->fprintf_func) (info->stream, "%d",
d972 1
a972 1
	  (*info->fprintf_func) (info->stream, "%d",
d977 1
a977 1
	  (*info->fprintf_func) (info->stream, "%d",
d982 1
a982 1
	  (*info->fprintf_func) (info->stream, "%d",
d987 1
a987 1
	  (*info->fprintf_func) (info->stream, "%d",
d1003 1
a1003 1
		(*info->fprintf_func) (info->stream, "$v%d[%d]",
d1009 1
a1009 1
		(*info->fprintf_func) (info->stream, "$v%d",
d1014 1
a1014 1
		(*info->fprintf_func) (info->stream, "0x%x",
d1021 1
a1021 1
	  (*info->fprintf_func) (info->stream, "$v%d",
d1026 1
a1026 1
	  (*info->fprintf_func) (info->stream, "$v%d",
d1031 1
a1031 1
	  (*info->fprintf_func) (info->stream, "$v%d",
d1145 1
a1145 1
  (*info->fprintf_func) (info->stream, "0x%x", word);
@


1.50
log
@Update the address and phone number of the FSF
@
text
@d7 1
a7 1
This file is part of GDB, GAS, and the GNU binutils.
d9 14
a22 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
a43 19
static void set_default_mips_dis_options
  PARAMS ((struct disassemble_info *));
static void parse_mips_dis_option
  PARAMS ((const char *, unsigned int));
static void parse_mips_dis_options
  PARAMS ((const char *));
static int _print_insn_mips
  PARAMS ((bfd_vma, struct disassemble_info *, enum bfd_endian));
static int print_insn_mips
  PARAMS ((bfd_vma, unsigned long int, struct disassemble_info *));
static void print_insn_args
  PARAMS ((const char *, unsigned long, bfd_vma, struct disassemble_info *));
static int print_insn_mips16
  PARAMS ((bfd_vma, struct disassemble_info *));
static int is_newabi
  PARAMS ((Elf_Internal_Ehdr *));
static void print_mips16_insn_arg
  PARAMS ((int, const struct mips_opcode *, int, bfd_boolean, int, bfd_vma,
	   struct disassemble_info *));
d47 5
a51 4
struct mips_cp0sel_name {
	unsigned int cp0reg;
	unsigned int sel;
	const char * const name;
d55 2
a56 1
static const char * const mips16_reg_names[] = {
d60 2
a61 1
static const char * const mips_gpr_names_numeric[32] = {
d68 2
a69 1
static const char * const mips_gpr_names_oldabi[32] = {
d76 2
a77 1
static const char * const mips_gpr_names_newabi[32] = {
d84 2
a85 1
static const char * const mips_fpr_names_numeric[32] = {
d92 2
a93 1
static const char * const mips_fpr_names_32[32] = {
d100 2
a101 1
static const char * const mips_fpr_names_n32[32] = {
d108 2
a109 1
static const char * const mips_fpr_names_64[32] = {
d116 2
a117 1
static const char * const mips_cp0_names_numeric[32] = {
d124 2
a125 1
static const char * const mips_cp0_names_mips3264[32] = {
d136 2
a137 1
static const struct mips_cp0sel_name mips_cp0sel_names_mips3264[] = {
d169 2
a170 1
static const char * const mips_cp0_names_mips3264r2[32] = {
d181 2
a182 1
static const struct mips_cp0sel_name mips_cp0sel_names_mips3264r2[] = {
d237 2
a238 1
static const char * const mips_cp0_names_sb1[32] = {
d249 2
a250 1
static const struct mips_cp0sel_name mips_cp0sel_names_sb1[] = {
d274 2
a275 1
static const char * const mips_hwr_names_numeric[32] = {
d282 2
a283 1
static const char * const mips_hwr_names_mips3264r2[32] = {
d291 3
a293 2
struct mips_abi_choice {
  const char *name;
d298 2
a299 1
struct mips_abi_choice mips_abi_choices[] = {
d306 2
a307 1
struct mips_arch_choice {
d319 2
a320 1
const struct mips_arch_choice mips_arch_choices[] = {
d422 1
a422 11
static int no_aliases;	/* If set disassemble as most general inst. */

static const struct mips_abi_choice *choose_abi_by_name
  PARAMS ((const char *, unsigned int));
static const struct mips_arch_choice *choose_arch_by_name
  PARAMS ((const char *, unsigned int));
static const struct mips_arch_choice *choose_arch_by_number
  PARAMS ((unsigned long));
static const struct mips_cp0sel_name *lookup_mips_cp0sel_name
  PARAMS ((const struct mips_cp0sel_name *, unsigned int, unsigned int,
	   unsigned int));
d425 1
a425 3
choose_abi_by_name (name, namelen)
     const char *name;
     unsigned int namelen;
d431 4
a434 5
    {
      if (strncmp (mips_abi_choices[i].name, name, namelen) == 0
	  && strlen (mips_abi_choices[i].name) == namelen)
	c = &mips_abi_choices[i];
    }
d439 1
a439 3
choose_arch_by_name (name, namelen)
     const char *name;
     unsigned int namelen;
d445 4
a448 5
    {
      if (strncmp (mips_arch_choices[i].name, name, namelen) == 0
	  && strlen (mips_arch_choices[i].name) == namelen)
	c = &mips_arch_choices[i];
    }
d453 1
a453 2
choose_arch_by_number (mach)
     unsigned long mach;
d480 18
a497 3
void
set_default_mips_dis_options (info)
     struct disassemble_info *info;
d543 2
a544 4
void
parse_mips_dis_option (option, len)
     const char *option;
     unsigned int len;
d560 3
a562 4
    {
      if (option[i] == '=')
	break;
    }
d574 2
a575 2
  if (strncmp("gpr-names", option, optionlen) == 0
      && strlen("gpr-names") == optionlen)
d583 2
a584 2
  if (strncmp("fpr-names", option, optionlen) == 0
      && strlen("fpr-names") == optionlen)
d592 2
a593 2
  if (strncmp("cp0-names", option, optionlen) == 0
      && strlen("cp0-names") == optionlen)
d605 2
a606 2
  if (strncmp("hwr-names", option, optionlen) == 0
      && strlen("hwr-names") == optionlen)
d614 2
a615 2
  if (strncmp("reg-names", option, optionlen) == 0
      && strlen("reg-names") == optionlen)
d641 2
a642 3
void
parse_mips_dis_options (options)
     const char *options;
d672 4
a675 3
lookup_mips_cp0sel_name(names, len, cp0reg, sel)
	const struct mips_cp0sel_name *names;
	unsigned int len, cp0reg, sel;
d688 4
a691 5
print_insn_args (d, l, pc, info)
     const char *d;
     register unsigned long int l;
     bfd_vma pc;
     struct disassemble_info *info;
d993 1
d997 1
a1043 17
/* Check if the object uses NewABI conventions.  */

static int
is_newabi (header)
     Elf_Internal_Ehdr *header;
{
  /* There are no old-style ABIs which use 64-bit ELF.  */
  if (header->e_ident[EI_CLASS] == ELFCLASS64)
    return 1;

  /* If a 32-bit ELF file, n32 is a new-style ABI.  */
  if ((header->e_flags & EF_MIPS_ABI2) != 0)
    return 1;

  return 0;
}

d1050 3
a1052 4
print_insn_mips (memaddr, word, info)
     bfd_vma memaddr;
     unsigned long int word;
     struct disassemble_info *info;
d1054 1
a1054 1
  register const struct mips_opcode *op;
d1099 1
a1099 1
	      register const char *d;
a1147 227
/* In an environment where we do not know the symbol type of the
   instruction we are forced to assume that the low order bit of the
   instructions' address may mark it as a mips16 instruction.  If we
   are single stepping, or the pc is within the disassembled function,
   this works.  Otherwise, we need a clue.  Sometimes.  */

static int
_print_insn_mips (memaddr, info, endianness)
     bfd_vma memaddr;
     struct disassemble_info *info;
     enum bfd_endian endianness;
{
  bfd_byte buffer[INSNLEN];
  int status;

  set_default_mips_dis_options (info);
  parse_mips_dis_options (info->disassembler_options);

#if 1
  /* FIXME: If odd address, this is CLEARLY a mips 16 instruction.  */
  /* Only a few tools will work this way.  */
  if (memaddr & 0x01)
    return print_insn_mips16 (memaddr, info);
#endif

#if SYMTAB_AVAILABLE
  if (info->mach == bfd_mach_mips16
      || (info->flavour == bfd_target_elf_flavour
	  && info->symbols != NULL
	  && ((*(elf_symbol_type **) info->symbols)->internal_elf_sym.st_other
	      == STO_MIPS16)))
    return print_insn_mips16 (memaddr, info);
#endif

  status = (*info->read_memory_func) (memaddr, buffer, INSNLEN, info);
  if (status == 0)
    {
      unsigned long insn;

      if (endianness == BFD_ENDIAN_BIG)
	insn = (unsigned long) bfd_getb32 (buffer);
      else
	insn = (unsigned long) bfd_getl32 (buffer);

      return print_insn_mips (memaddr, insn, info);
    }
  else
    {
      (*info->memory_error_func) (status, memaddr, info);
      return -1;
    }
}

int
print_insn_big_mips (memaddr, info)
     bfd_vma memaddr;
     struct disassemble_info *info;
{
  return _print_insn_mips (memaddr, info, BFD_ENDIAN_BIG);
}

int
print_insn_little_mips (memaddr, info)
     bfd_vma memaddr;
     struct disassemble_info *info;
{
  return _print_insn_mips (memaddr, info, BFD_ENDIAN_LITTLE);
}

/* Disassemble mips16 instructions.  */

static int
print_insn_mips16 (memaddr, info)
     bfd_vma memaddr;
     struct disassemble_info *info;
{
  int status;
  bfd_byte buffer[2];
  int length;
  int insn;
  bfd_boolean use_extend;
  int extend = 0;
  const struct mips_opcode *op, *opend;

  info->bytes_per_chunk = 2;
  info->display_endian = info->endian;
  info->insn_info_valid = 1;
  info->branch_delay_insns = 0;
  info->data_size = 0;
  info->insn_type = dis_nonbranch;
  info->target = 0;
  info->target2 = 0;

  status = (*info->read_memory_func) (memaddr, buffer, 2, info);
  if (status != 0)
    {
      (*info->memory_error_func) (status, memaddr, info);
      return -1;
    }

  length = 2;

  if (info->endian == BFD_ENDIAN_BIG)
    insn = bfd_getb16 (buffer);
  else
    insn = bfd_getl16 (buffer);

  /* Handle the extend opcode specially.  */
  use_extend = FALSE;
  if ((insn & 0xf800) == 0xf000)
    {
      use_extend = TRUE;
      extend = insn & 0x7ff;

      memaddr += 2;

      status = (*info->read_memory_func) (memaddr, buffer, 2, info);
      if (status != 0)
	{
	  (*info->fprintf_func) (info->stream, "extend 0x%x",
				 (unsigned int) extend);
	  (*info->memory_error_func) (status, memaddr, info);
	  return -1;
	}

      if (info->endian == BFD_ENDIAN_BIG)
	insn = bfd_getb16 (buffer);
      else
	insn = bfd_getl16 (buffer);

      /* Check for an extend opcode followed by an extend opcode.  */
      if ((insn & 0xf800) == 0xf000)
	{
	  (*info->fprintf_func) (info->stream, "extend 0x%x",
				 (unsigned int) extend);
	  info->insn_type = dis_noninsn;
	  return length;
	}

      length += 2;
    }

  /* FIXME: Should probably use a hash table on the major opcode here.  */

  opend = mips16_opcodes + bfd_mips16_num_opcodes;
  for (op = mips16_opcodes; op < opend; op++)
    {
      if (op->pinfo != INSN_MACRO
	  && !(no_aliases && (op->pinfo2 & INSN2_ALIAS))
	  && (insn & op->mask) == op->match)
	{
	  const char *s;

	  if (strchr (op->args, 'a') != NULL)
	    {
	      if (use_extend)
		{
		  (*info->fprintf_func) (info->stream, "extend 0x%x",
					 (unsigned int) extend);
		  info->insn_type = dis_noninsn;
		  return length - 2;
		}

	      use_extend = FALSE;

	      memaddr += 2;

	      status = (*info->read_memory_func) (memaddr, buffer, 2,
						  info);
	      if (status == 0)
		{
		  use_extend = TRUE;
		  if (info->endian == BFD_ENDIAN_BIG)
		    extend = bfd_getb16 (buffer);
		  else
		    extend = bfd_getl16 (buffer);
		  length += 2;
		}
	    }

	  (*info->fprintf_func) (info->stream, "%s", op->name);
	  if (op->args[0] != '\0')
	    (*info->fprintf_func) (info->stream, "\t");

	  for (s = op->args; *s != '\0'; s++)
	    {
	      if (*s == ','
		  && s[1] == 'w'
		  && (((insn >> MIPS16OP_SH_RX) & MIPS16OP_MASK_RX)
		      == ((insn >> MIPS16OP_SH_RY) & MIPS16OP_MASK_RY)))
		{
		  /* Skip the register and the comma.  */
		  ++s;
		  continue;
		}
	      if (*s == ','
		  && s[1] == 'v'
		  && (((insn >> MIPS16OP_SH_RZ) & MIPS16OP_MASK_RZ)
		      == ((insn >> MIPS16OP_SH_RX) & MIPS16OP_MASK_RX)))
		{
		  /* Skip the register and the comma.  */
		  ++s;
		  continue;
		}
	      print_mips16_insn_arg (*s, op, insn, use_extend, extend, memaddr,
				     info);
	    }

	  if ((op->pinfo & INSN_UNCOND_BRANCH_DELAY) != 0)
	    {
	      info->branch_delay_insns = 1;
	      if (info->insn_type != dis_jsr)
		info->insn_type = dis_branch;
	    }

	  return length;
	}
    }

  if (use_extend)
    (*info->fprintf_func) (info->stream, "0x%x", extend | 0xf000);
  (*info->fprintf_func) (info->stream, "0x%x", insn);
  info->insn_type = dis_noninsn;

  return length;
}

d1151 7
a1157 8
print_mips16_insn_arg (type, op, l, use_extend, extend, memaddr, info)
     char type;
     const struct mips_opcode *op;
     int l;
     bfd_boolean use_extend;
     int extend;
     bfd_vma memaddr;
     struct disassemble_info *info;
d1553 220
d1774 1
a1774 2
print_mips_disassembler_options (stream)
     FILE *stream;
@


1.49
log
@update copyright dates
@
text
@d21 1
a21 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.48
log
@	2005-01-21  Fred Fish  <fnf@@specifixinc.com>
	* mips-opc.c:  Change INSN_ALIAS to INSN2_ALIAS.
	Change INSN_WRITE_MDMX_ACC to INSN2_WRITE_MDMX_ACC.
	Change INSN_READ_MDMX_ACC to INSN2_READ_MDMX_ACC.
	* mips-dis.c: Ditto.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
@


1.47
log
@	2005-01-19  Fred Fish  <fnf@@specifixinc.com>
	* mips-dis.c (no_aliases): New disassembly option flag.
	(set_default_mips_dis_options): Init no_aliases to zero.
	(parse_mips_dis_option): Handle no-aliases option.
	(print_insn_mips): Ignore table entries that are aliases
	if no_aliases is set.
	(print_insn_mips16): Ditto.
	* mips-opc.c (mips_builtin_opcodes): Add initializer column for
	new pinfo2 member and add INSN_ALIAS initializers as needed.  Also
	move WR_MACC and RD_MACC initializers from pinfo to pinfo2.
	* mips16-opc.c (mips16_opcodes): Ditto.
@
text
@d1086 1
a1086 1
		  || (no_aliases && (op->pinfo2 & INSN_ALIAS)))
d1114 1
a1114 1
	      && !(no_aliases && (op->pinfo2 & INSN_ALIAS))
d1314 1
a1314 1
	  && !(no_aliases && (op->pinfo2 & INSN_ALIAS))
@


1.46
log
@[ bfd/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* archures.c (bfd_mach_mipsisa64r2): New define.
	* bfd-in2.h: Regenerate.
	* aoutx.h (NAME(aout,machine_type)): Handle bfd_mach_mipsisa64r2.
	* cpu-mips.c (I_mipsisa64r2): New enum value.
	(arch_info_struct): Add entry for I_mipsisa64r2.
	* elfxx-mips.c (_bfd_elf_mips_mach)
	(_bfd_mips_elf_print_private_bfd_data): Handle E_MIPS_ARCH_64R2.
	(mips_set_isa_flags): Add bfd_mach_mipsisa64r2 case.
	(mips_mach_extensions): Add entry for bfd_mach_mipsisa64r2.

[ binutils/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* readelf.c (get_machine_flags): Handle E_MIPS_ARCH_64R2.

[ gas/Changelog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* configure.in (mipsisa64r2, mipsisa64r2el, mipsisa64r2*): New CPUs.
	* configure: Regenerate.
	* config/tc-mips.c (imm2_expr): New variable.
	(md_assemble, mips16_ip): Initialize imm2_expr.
	(ISA_HAS_64BIT_REGS, ISA_HAS_DROR, ISA_HAS_ROR): Add ISA_MIPS64R2.
	(macro_build): Handle +A, +B, +C, +E, +F, +G, and +H format operands.
	(macro): Handle M_DEXT and M_DINS.
	(validate_mips_insn): Handle +E, +F, +G, +H, and +I format operands.
	(mips_ip): Likewise.
	(OPTION_MIPS64R2): New define.
	(md_longopts): New entry for -mips64r2 (OPTION_MIPS64R2).
	OPTION_ASE_BASE): Increase to compensate for OPTION_MIPS64R2.
	(md_parse_option): Handle OPTION_MIPS64R2.
	(s_mipsset): Handle setting "mips64r2" ISA.
	(mips_cpu_info_table): Add mips64r2.
	(md_show_usage): Document -mips64r2 option.
	* doc/as.texinfo: Docuemnt -mips64r2 option.
	* doc/c-mips.texi: Likewise.

[ gas/testsuite/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* gas/mips/cp0-names-mips64r2.d: New file.
	* gas/mips/cp0sel-names-mips64r2.d: New file.
	* gas/mips/elf_arch_mips64r2.d: New file.
	* gas/mips/hwr-names-mips64r2.d: New file.
	* gas/mips/mips32r2-ill-fp64.l: New file.
	* gas/mips/mips32r2-ill-fp64.s: New file.
	* gas/mips/mips64r2-ill.l: New file.
	* gas/mips/mips64r2-ill.s: New file.
	* gas/mips/mips64r2.d: New file.
	* gas/mips/mips64r2.s: New file.
	* gas/mips/mips.exp: Define "mips64r2" arch, and run new tests.

[ include/elf/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips.h (E_MIPS_ARCH_64R2): New define.

[ include/opcode/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips.h: Document +E, +F, +G, +H, and +I operand types.
	Update documentation of I, +B and +C operand types.
	(INSN_ISA64R2, ISA_MIPS64R2, CPU_MIPS64R2): New defines.
	(M_DEXT, M_DINS): New enum values.

[ ld/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* ldmain.c (get_emulation): Ignore "-mips64r2".

[ ld/testsuite/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* ld-mips-elf/mips-elf-flags.exp: Add tests for combinations
	with MIPS64r2.

[ opcodes/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips-dis.c (mips_arch_choices): Add entry for "mips64r2"
	(print_insn_args): Add handing for +E, +F, +G, and +H.
	* mips-opc.c (I65): New define for MIPS64r2.
	(mips_builtin_opcodes): Add "dext", "dextm", "dextu", "dins",
	"dinsm", "dinsu", "drotl", "drotr", "drotr32", "drotrv", "dsbh",
	and "dshd" for MIPS64r2.  Adjust "dror", "dror32", and "drorv" to
	be supported on MIPS64r2.
@
text
@d417 3
d509 1
d551 7
d1085 2
a1086 1
	      if (op->pinfo == INSN_MACRO)
d1113 3
a1115 1
	  if (op->pinfo != INSN_MACRO && (word & op->mask) == op->match)
d1313 3
a1315 1
      if (op->pinfo != INSN_MACRO && (insn & op->mask) == op->match)
@


1.45
log
@include/opcode/
	* mips.h (CPU_RM7000): New macro.
	(OPCODE_IS_MEMBER): Match CPU_RM7000 against 4650 insns.

bfd/
	* archures.c (bfd_mach_mips7000): New.
	* bfd-in2.h: Regenerated.
	* cpu-mips.c (arch_info_struct): Add an entry for mips:7000.
	* elfxx-mips.c (mips_set_isa_flags): Handle bfd_mach_mips7000.
	(mips_mach_extensions): Add an entry for it.

opcodes/
	* mips-dis.c (mips_arch_choices): Add rm7000 and rm9000 entries.

gas/
	* config/tc-mips.c (hilo_interlocks): True for CPU_RM7000.
	(mips_cpu_info_table): Add rm7000 and rm9000 entries.

gas/testsuite/
	* gas/mips/rm7000.[sd]: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d387 6
d723 1
d749 15
@


1.44
log
@2003-07-09  Chris Demetriou  <cgd@@broadcom.com>

        * mips-dis.c (set_default_mips_dis_options): Get BFD from
        the disassembler_info's section, rather than from the
        disassembler_info's symbols pointer.
@
text
@d350 4
@


1.43
log
@* mips-dis.c (mips_gpr_names_newabi): Reverted previous patch.
@
text
@d498 1
a498 1
  if (info->flavour == bfd_target_elf_flavour && info->symbols != NULL)
d502 1
a502 1
      header = elf_elfheader (bfd_asymbol_bfd (*(info->symbols)));
@


1.42
log
@* mips-dis.c (mips_gpr_names_newabi): $12-$15 are named $t4-$t7.
@
text
@d92 1
a92 1
  "a4",   "a5",   "a6",   "a7",   "t4",   "t5",   "t6",   "t7",
@


1.41
log
@2003-02-23  Elias Athanasopoulos  <elathan@@phys.uoa.gr>

        * mips-dis.c (print_mips_disassembler_options): Make 'i' unsigned,
        use ARRAY_SIZE in loops.
@
text
@d92 1
a92 1
  "a4",   "a5",   "a6",   "a7",   "t0",   "t1",   "t2",   "t3",
@


1.40
log
@2003-01-02  Chris Demetriou  <cgd@@broadcom.com>

        * mips-dis.c (print_insn_args): Use position extracted by "+A"
        to calculate size for "+B".  Redo code for "+C" so it shares
        the same style as "+A" and "+B" now do.
@
text
@d1761 1
a1761 1
  int i;
d1796 1
a1796 1
  for (i = 0; mips_abi_choices[i].name != NULL; i++)
d1803 1
a1803 1
  for (i = 0; mips_arch_choices[i].name != NULL; i++)
@


1.39
log
@2003-01-02  Chris Demetriou  <cgd@@broadcom.com>

        * mips-dis.c: Update copyright years.
        (print_insn_arg): Rename to...
        (print_insn_args): This, returning void.  Process the whole
        string of args rather than a single one.  Reindent.
        (print_insn_mips): Update to match the above.
@
text
@d675 3
d703 2
a704 2
	      (*info->fprintf_func) (info->stream, "0x%x",
				     (l >> OP_SH_SHAMT) & OP_MASK_SHAMT);
d708 2
a709 4
	      (*info->fprintf_func) (info->stream, "0x%x",
				     (((l >> OP_SH_INSMSB) & OP_MASK_INSMSB)
				      - ((l >> OP_SH_SHAMT) & OP_MASK_SHAMT)
				      + 1));
d713 2
a714 3
	      (*info->fprintf_func) (info->stream, "0x%x",
				     (((l >> OP_SH_EXTMSBD) & OP_MASK_EXTMSBD)
				      + 1));
@


1.38
log
@[ gas/ChangeLog ]
2002-12-31  Chris Demetriou  <cgd@@broadcom.com>

	* config/tc-mips.c (validate_mips_insn, mips_ip): Recognize
	the "+D" operand, which will be used only by the disassembler.

[ gas/testsuite/ChangeLog ]
2002-12-31  Chris Demetriou  <cgd@@broadcom.com>

	* gas/mips/cp0sel-names-mips32.d: New test.
	* gas/mips/cp0sel-names-mips32r2.d: New test.
	* gas/mips/cp0sel-names-mips64.d: New test.
	* gas/mips/cp0sel-names-numeric.d: New test.
	* gas/mips/cp0sel-names-sb1.d: New test.
	* gas/mips/cp0sel-names.s: New test source file.
	* gas/mips/mips.exp: Run new tests.

[ include/opcode/ChangeLog ]
2002-12-31  Chris Demetriou  <cgd@@broadcom.com>

	* mips.h: Note that the "+D" operand type name is now used.

[ opcodes/ChangeLog ]
2002-12-31  Chris Demetriou  <cgd@@broadcom.com>

	* mips-dis.c (mips_cp0sel_name): New structure.
	(mips_cp0sel_names_mips3264, mips_cp0sel_names_mips3264r2)
	(mips_cp0sel_names_sb1): New arrays.
	(mips_arch_choice): New structure members "cp0sel_names" and
	"cp0sel_names_len".
	(mips_arch_choices): Add references to new cp0sel_names arrays
	as appropriate, and make all existing entries reference
	appropriate mips_XXX_names_numeric arrays rather than simply
	using NULL.
	(mips_cp0sel_names, mips_cp0sel_names_len): New variables.
	(lookup_mips_cp0sel_name): New function.
	(set_default_mips_dis_options): Set mips_cp0sel_names and
	mips_cp0sel_names_len as appropriate.  Remove now-unnecessary
	checks for NULL register name arrays.
	(parse_mips_dis_option): Likewise.
	(print_insn_arg): Handle "+D" operand type.
	* mips-opc.c (mips_builtin_opcodes): Add new "+D" variants
	of mfc0, mtc0, dmfc0, and dmtc0 to print CP0+sel register
	names symbolically.
@
text
@d3 1
a3 1
   2000, 2001, 2002
d53 1
a53 1
static int print_insn_arg
d667 2
a668 2
static int
print_insn_arg (d, l, pc, info)
d674 1
a674 1
  int op, delta, consumed;
d676 1
a676 2
  consumed = 1;
  switch (*d)
a677 12
    case ',':
    case '(':
    case ')':
    case '[':
    case ']':
      (*info->fprintf_func) (info->stream, "%c", *d);
      break;

    case '+':
      /* Extension character; switch for second char.  */
      d++;
      consumed++;
d680 158
a837 1
	case 'A':
d841 16
a856 1
	
d859 1
a859 3
				 (((l >> OP_SH_INSMSB) & OP_MASK_INSMSB)
				   - ((l >> OP_SH_SHAMT) & OP_MASK_SHAMT)
				  + 1));
d862 1
a862 1
	case 'C':
d864 13
a876 2
				 (((l >> OP_SH_EXTMSBD) & OP_MASK_EXTMSBD)
				  + 1));
d880 69
a948 3
	  {
	    const struct mips_cp0sel_name *n;
	    unsigned int cp0reg, sel;
d950 4
a953 2
	    cp0reg = (l >> OP_SH_RD) & OP_MASK_RD;
	    sel = (l >> OP_SH_SEL) & OP_MASK_SEL;
d955 19
a973 9
	    /* CP0 register including 'sel' code for mtcN (et al.), to be
	       printed textually if known.  If not known, print both
	       CP0 register name and sel numerically since CP0 register
	       with sel 0 may have a name unrelated to register being
	       printed.  */
	    n = lookup_mips_cp0sel_name(mips_cp0sel_names,
					mips_cp0sel_names_len, cp0reg, sel);
	    if (n != NULL)
	      (*info->fprintf_func) (info->stream, "%s", n->name);
d975 4
a978 2
	      (*info->fprintf_func) (info->stream, "$%d,%d", cp0reg, sel);
	    break;
d980 16
d1000 1
a1000 1
				 _("# internal error, undefined extension sequence (+%c)"),
d1002 1
a1002 4
	  /* Do not eat the trailing newline.  */
	  if (*d == '\0')
	    consumed--;
	  break;
a1003 257
      break;

    case 's':
    case 'b':
    case 'r':
    case 'v':
      (*info->fprintf_func) (info->stream, "%s",
			     mips_gpr_names[(l >> OP_SH_RS) & OP_MASK_RS]);
      break;

    case 't':
    case 'w':
      (*info->fprintf_func) (info->stream, "%s",
			     mips_gpr_names[(l >> OP_SH_RT) & OP_MASK_RT]);
      break;

    case 'i':
    case 'u':
      (*info->fprintf_func) (info->stream, "0x%x",
			     (l >> OP_SH_IMMEDIATE) & OP_MASK_IMMEDIATE);
      break;

    case 'j': /* Same as i, but sign-extended.  */
    case 'o':
      delta = (l >> OP_SH_DELTA) & OP_MASK_DELTA;
      if (delta & 0x8000)
	delta |= ~0xffff;
      (*info->fprintf_func) (info->stream, "%d",
			     delta);
      break;

    case 'h':
      (*info->fprintf_func) (info->stream, "0x%x",
			     (unsigned int) ((l >> OP_SH_PREFX)
					     & OP_MASK_PREFX));
      break;

    case 'k':
      (*info->fprintf_func) (info->stream, "0x%x",
			     (unsigned int) ((l >> OP_SH_CACHE)
					     & OP_MASK_CACHE));
      break;

    case 'a':
      info->target = (((pc + 4) & ~(bfd_vma) 0x0fffffff)
		      | (((l >> OP_SH_TARGET) & OP_MASK_TARGET) << 2));
      (*info->print_address_func) (info->target, info);
      break;

    case 'p':
      /* Sign extend the displacement.  */
      delta = (l >> OP_SH_DELTA) & OP_MASK_DELTA;
      if (delta & 0x8000)
	delta |= ~0xffff;
      info->target = (delta << 2) + pc + INSNLEN;
      (*info->print_address_func) (info->target, info);
      break;

    case 'd':
      (*info->fprintf_func) (info->stream, "%s",
			     mips_gpr_names[(l >> OP_SH_RD) & OP_MASK_RD]);
      break;

    case 'U':
      {
	/* First check for both rd and rt being equal.  */
	unsigned int reg = (l >> OP_SH_RD) & OP_MASK_RD;
	if (reg == ((l >> OP_SH_RT) & OP_MASK_RT))
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_gpr_names[reg]);
	else
	  {
	    /* If one is zero use the other.  */
	    if (reg == 0)
	      (*info->fprintf_func) (info->stream, "%s",
				     mips_gpr_names[(l >> OP_SH_RT) & OP_MASK_RT]);
	    else if (((l >> OP_SH_RT) & OP_MASK_RT) == 0)
	      (*info->fprintf_func) (info->stream, "%s",
				     mips_gpr_names[reg]);
	    else /* Bogus, result depends on processor.  */
	      (*info->fprintf_func) (info->stream, "%s or %s",
				     mips_gpr_names[reg],
				     mips_gpr_names[(l >> OP_SH_RT) & OP_MASK_RT]);
	  }
      }
      break;

    case 'z':
      (*info->fprintf_func) (info->stream, "%s", mips_gpr_names[0]);
      break;

    case '<':
      (*info->fprintf_func) (info->stream, "0x%x",
			     (l >> OP_SH_SHAMT) & OP_MASK_SHAMT);
      break;

    case 'c':
      (*info->fprintf_func) (info->stream, "0x%x",
			     (l >> OP_SH_CODE) & OP_MASK_CODE);
      break;

    case 'q':
      (*info->fprintf_func) (info->stream, "0x%x",
			     (l >> OP_SH_CODE2) & OP_MASK_CODE2);
      break;

    case 'C':
      (*info->fprintf_func) (info->stream, "0x%x",
			     (l >> OP_SH_COPZ) & OP_MASK_COPZ);
      break;

    case 'B':
      (*info->fprintf_func) (info->stream, "0x%x",
			     (l >> OP_SH_CODE20) & OP_MASK_CODE20);
      break;

    case 'J':
      (*info->fprintf_func) (info->stream, "0x%x",
			     (l >> OP_SH_CODE19) & OP_MASK_CODE19);
      break;

    case 'S':
    case 'V':
      (*info->fprintf_func) (info->stream, "%s",
			     mips_fpr_names[(l >> OP_SH_FS) & OP_MASK_FS]);
      break;

    case 'T':
    case 'W':
      (*info->fprintf_func) (info->stream, "%s",
			     mips_fpr_names[(l >> OP_SH_FT) & OP_MASK_FT]);
      break;

    case 'D':
      (*info->fprintf_func) (info->stream, "%s",
			     mips_fpr_names[(l >> OP_SH_FD) & OP_MASK_FD]);
      break;

    case 'R':
      (*info->fprintf_func) (info->stream, "%s",
			     mips_fpr_names[(l >> OP_SH_FR) & OP_MASK_FR]);
      break;

    case 'E':
      /* Coprocessor register for lwcN instructions, et al.

	 Note that there is no load/store cp0 instructions, and
	 that FPU (cp1) instructions disassemble this field using
	 'T' format.  Therefore, until we gain understanding of
	 cp2 register names,
	 we can simply print the register numbers.  */
      (*info->fprintf_func) (info->stream, "$%d",
			     (l >> OP_SH_RT) & OP_MASK_RT);
      break;

    case 'G':
      /* Coprocessor register for mtcN instructions, et al.
	 Note that FPU (cp1) instructions disassemble this field using
	 'S' format.  Therefore, we only need to worry about cp0, cp2,
	 and cp3.  */
      op = (l >> OP_SH_OP) & OP_MASK_OP;
      if (op == OP_OP_COP0)
        (*info->fprintf_func) (info->stream, "%s",
			       mips_cp0_names[(l >> OP_SH_RD) & OP_MASK_RD]);
      else
        (*info->fprintf_func) (info->stream, "$%d",
			       (l >> OP_SH_RD) & OP_MASK_RD);
      break;

    case 'K':
      (*info->fprintf_func) (info->stream, "%s",
			     mips_hwr_names[(l >> OP_SH_RD) & OP_MASK_RD]);
      break;

    case 'N':
      (*info->fprintf_func) (info->stream, "$fcc%d",
			     (l >> OP_SH_BCC) & OP_MASK_BCC);
      break;

    case 'M':
      (*info->fprintf_func) (info->stream, "$fcc%d",
			     (l >> OP_SH_CCC) & OP_MASK_CCC);
      break;

    case 'P':
      (*info->fprintf_func) (info->stream, "%d",
			     (l >> OP_SH_PERFREG) & OP_MASK_PERFREG);
      break;

    case 'e':
      (*info->fprintf_func) (info->stream, "%d",
			     (l >> OP_SH_VECBYTE) & OP_MASK_VECBYTE);
      break;

    case '%':
      (*info->fprintf_func) (info->stream, "%d",
			     (l >> OP_SH_VECALIGN) & OP_MASK_VECALIGN);
      break;

    case 'H':
      (*info->fprintf_func) (info->stream, "%d",
			     (l >> OP_SH_SEL) & OP_MASK_SEL);
      break;

    case 'O':
      (*info->fprintf_func) (info->stream, "%d",
			     (l >> OP_SH_ALN) & OP_MASK_ALN);
      break;

    case 'Q':
      {
	unsigned int vsel = (l >> OP_SH_VSEL) & OP_MASK_VSEL;
	if ((vsel & 0x10) == 0)
	  {
	    int fmt;
	    vsel &= 0x0f;
	    for (fmt = 0; fmt < 3; fmt++, vsel >>= 1)
	      if ((vsel & 1) == 0)
		break;
	    (*info->fprintf_func) (info->stream, "$v%d[%d]",
				   (l >> OP_SH_FT) & OP_MASK_FT,
				   vsel >> 1);
	  }
	else if ((vsel & 0x08) == 0)
	  {
	    (*info->fprintf_func) (info->stream, "$v%d",
				   (l >> OP_SH_FT) & OP_MASK_FT);
	  }
	else
	  {
	    (*info->fprintf_func) (info->stream, "0x%x",
				   (l >> OP_SH_FT) & OP_MASK_FT);
	  }
      }
      break;

    case 'X':
      (*info->fprintf_func) (info->stream, "$v%d",
			     (l >> OP_SH_FD) & OP_MASK_FD);
      break;

    case 'Y':
      (*info->fprintf_func) (info->stream, "$v%d",
			     (l >> OP_SH_FS) & OP_MASK_FS);
      break;

    case 'Z':
      (*info->fprintf_func) (info->stream, "$v%d",
			     (l >> OP_SH_FT) & OP_MASK_FT);
      break;

    default:
      /* xgettext:c-format */
      (*info->fprintf_func) (info->stream,
			     _("# internal error, undefined modifier(%c)"),
			     *d);
      break;
a1004 2

  return consumed;
a1110 2
		  int consumed;

d1112 1
a1112 7
		  while (*d != '\0')
		    {
		      /* print_insn_arg will not eat the trailing NUL
			 of (erroneous) multi-character strings.  */
		      consumed = print_insn_arg (d, word, memaddr, info);
		      d += consumed;
		    }
@


1.37
log
@[ bfd/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* aoutx.h (NAME(aout,machine_type)): Add bfd_mach_mipsisa32r2 case.
	* archures.c (bfd_mach_mipsisa32r2): New define.
	* bfd-in2.h: Regenerate.
	* cpu-mips.c (I_mipsisa32r2): New enum value.
	(arch_info_struct): Add entry for I_mipsisa32r2.
	* elfxx-mips.c (elf_mips_isa, _bfd_elf_mips_mach)
	(_bfd_mips_elf_print_private_bfd_data): Handle E_MIPS_ARCH_32R2.
	(_bfd_mips_elf_final_write_processing): Add
	bfd_mach_mipsisa32r2 case.
	(_bfd_mips_elf_merge_private_bfd_data): Handle merging of
	binaries marked as using MIPS32 Release 2.

[ binutils/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* doc/binutils.texi (objdump): Note MIPS HWR (Hardware Register)
	changes in MIPS -M options.

[ gas/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* configure.in: Recognize mipsisa32r2, mipsisa32r2el, and
	CPU variants.
	* configure: Regenerate.
	* config/tc-mips.c (ISA_HAS_DROR, ISA_HAS_ROR): New defines.
	(macro_build): Handle "K" operand.
	(macro2): Use ISA_HAS_DROR and ISA_HAS_ROR in the places where
	CPU_HAS_DROR and CPU_HAS_ROR are currently used.
	(mips_ip): New variable "lastpos", and implement "+A", "+B",
	and "+C" operands for MIPS32 Release 2 ins/ext instructions.
	Implement "K" operand for MIPS32 Release 2 rdhwr instruction.
	(validate_mips_insn): Implement "+" as a way to extend the
	allowed operands, and implement "K", "+A", "+B", and "+C"
	operands.
	(OPTION_MIPS32R2): New define.
	(md_longopts): Add entry for OPTION_MIPS32R2.
	(OPTION_ELF_BASE): Adjust to accomodate OPTIONS_MIPS32R2.
	(md_parse_option): Handle OPTION_MIPS32R2.
	(s_mipsset): Reimplement handling of ".set mipsN" options
	and add support for ".set mips32r2".
	(mips_cpu_info_table): Add entry for "mips32r2" (MIPS32 Release 2).
	(md_show_usage): Document "-mips32r2" option.
	* doc/as.texinfo: Document "-mips32r2" option.
	* doc/c-mips.texi: Likewise.

[ gas/testsuite/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* gas/mips/cp0-names-mips32r2.d: New test.
	* gas/mips/hwr-names-mips32r2.d: New test.
	* gas/mips/hwr-names-numeric.d: New test.
	* gas/mips/hwr-names.s: New test source file.
	* gas/mips/mips32r2.d: New test.
	* gas/mips/mips32r2.s: New test source file.
	* gas/mips/mips32r2-ill.l: New test.
	* gas/mips/mips32r2-ill.s: New test source file.
	* gas/mips/mips.exp: Add mips32r2 architecture data array
	entry.  Run new tests mentioned above.

[ include/elf/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips.h (E_MIPS_ARCH_32R2): New define.

[ include/opcode/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips.h: Document "+" as the start of two-character operand
	type names, and add new "K", "+A", "+B", and "+C" operand types.
	(OP_MASK_INSMSB, OP_SH_INSMSB, OP_MASK_EXTMSB)
	(OP_SH_EXTMSB, INSN_ISA32R2, ISA_MIPS32R2, CPU_MIPS32R2): New
	defines.

[ opcodes/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips-dis.c (mips_cp0_names_mips3264r2, mips_hwr_names_numeric)
	(mips_hwr_names_mips3264r2): New arrays.
	(mips_arch_choice): New "hwr_names" member.
	(mips_arch_choices): Adjust for structure change, and add a new
	entry for "mips32r2" ISA.
	(mips_hwr_names): New variable.
	(set_default_mips_dis_options): Set mips_hwr_names.
	(parse_mips_dis_option): New "hwr-names" option which sets
	mips_hwr_names, and adjust "reg-names=ARCH" to set mips_hwr_names.
	(print_insn_arg): Change return type to "int"
	and use that to indicate number of characters consumed.
	Add support for "+" operand extension character, "+A", "+B",
	"+C", and "K" operands.
	(print_insn_mips): Adjust for changes to print_insn_arg.
	(print_mips_disassembler_options): Adjust for "hwr-names"
	addition and "reg-names" change.
	* mips-opc (I33): New define (shorthand for INSN_ISA32R2).
	(mips_builtin_opcodes): Note that "nop" and "ssnop" are special
	forms of "sll".  Add new MIPS32 Release 2 instructions: ehb,
	di, ei, ext, ins, jr.hb, jalr.hb, mfhc1, mfhc2, mthc1, mthc2,
	rdhwr, rdpgpr, seb, seh, synci, wrpgpr, wsbh.
	Note that hardware rotate instructions (ror, rorv) can be
	used on MIPS32 Release 2, and add the official mnemonics
	for them (rotr, rotrv) and the similar "rotl" mnemonic for
	left-rotate.
@
text
@d65 6
d143 32
d186 54
d252 24
d311 2
d316 1
a316 1
struct mips_arch_choice mips_arch_choices[] = {
d318 2
a319 1
    mips_cp0_names_numeric, mips_hwr_names_numeric },
d321 1
a321 1
    NULL, NULL },
d323 1
a323 1
    NULL, NULL },
d325 1
a325 1
    NULL, NULL },
d327 1
a327 1
    NULL, NULL },
d329 1
a329 1
    NULL, NULL },
d331 1
a331 1
    NULL, NULL },
d333 1
a333 1
    NULL, NULL },
d335 1
a335 1
    NULL, NULL },
d337 1
a337 1
    NULL, NULL },
d339 1
a339 1
    NULL, NULL },
d341 1
a341 1
    NULL, NULL },
d343 1
a343 1
    NULL, NULL },
d345 1
a345 1
    NULL, NULL },
d347 1
a347 1
    NULL, NULL },
d349 1
a349 1
    NULL, NULL },
d351 1
a351 1
    NULL, NULL },
d353 1
a353 1
    NULL, NULL },
d355 1
a355 1
    NULL, NULL },
d357 2
a358 1
    NULL, NULL },
d366 4
a369 1
    mips_cp0_names_mips3264, NULL },
d372 4
a375 1
    mips_cp0_names_mips3264r2, mips_hwr_names_mips3264r2 },
d379 4
a382 1
    mips_cp0_names_mips3264, NULL },
d385 3
a387 1
    mips_cp0_names_sb1, NULL },
d392 1
a392 1
    NULL, NULL },
d403 2
d413 3
d493 2
d519 4
a522 4
      if (chosen_arch->cp0_names != NULL)
	mips_cp0_names = chosen_arch->cp0_names;
      if (chosen_arch->hwr_names != NULL)
	mips_hwr_names = chosen_arch->hwr_names;
d558 1
a558 1
      if (chosen_abi != NULL && chosen_abi->gpr_names != NULL)
d567 1
a567 1
      if (chosen_abi != NULL && chosen_abi->fpr_names != NULL)
d576 6
a581 2
      if (chosen_arch != NULL && chosen_arch->cp0_names != NULL)
	mips_cp0_names = chosen_arch->cp0_names;
d589 1
a589 1
      if (chosen_arch != NULL && chosen_arch->hwr_names != NULL)
d604 2
a605 4
	  if (chosen_abi->gpr_names != NULL)
	    mips_gpr_names = chosen_abi->gpr_names;
	  if (chosen_abi->fpr_names != NULL)
	    mips_fpr_names = chosen_abi->fpr_names;
d610 4
a613 4
	  if (chosen_arch->cp0_names != NULL)
	    mips_cp0_names = chosen_arch->cp0_names;
	  if (chosen_arch->hwr_names != NULL)
	    mips_hwr_names = chosen_arch->hwr_names;
d652 12
d710 22
@


1.36
log
@[ binutils/ChangeLog ]
2002-12-27  Chris Demetriou  <cgd@@broadcom.com>

        * doc/binutils.texi (objdump): Document MIPS -M options.

[ gas/testsuite/ChangeLog ]
2002-12-27  Chris Demetriou  <cgd@@broadcom.com>

        * gas/mips/cp0-names-mips32.d: New file.
        * gas/mips/cp0-names-mips64.d: New file.
        * gas/mips/cp0-names-numeric.d: New file.
        * gas/mips/cp0-names-sb1.d: New file.
        * gas/mips/cp0-names.s: New file.
        * gas/mips/fpr-names-32.d: New file.
        * gas/mips/fpr-names-64.d: New file.
        * gas/mips/fpr-names-n32.d: New file.
        * gas/mips/fpr-names-numeric.d: New file.
        * gas/mips/fpr-names.s: New file.
        * gas/mips/gpr-names-32.d: New file.
        * gas/mips/gpr-names-64.d: New file.
        * gas/mips/gpr-names-n32.d: New file.
        * gas/mips/gpr-names-numeric.d: New file.
        * gas/mips/gpr-names.s: New file.
        * gas/mips/mips.exp: Run new tests.

[ include/ChangeLog ]
2002-12-27  Chris Demetriou  <cgd@@broadcom.com>

        * dis-asm.h (print_mips_disassembler_options): Prototype.

[ include/opcode/ChangeLog ]
2002-12-19  Chris Demetriou  <cgd@@broadcom.com>

        * mips.h (OP_OP_COP0, OP_OP_COP1, OP_OP_COP2, OP_OP_COP3)
        (OP_OP_LWC1, OP_OP_LWC2, OP_OP_LWC3, OP_OP_LDC1, OP_OP_LDC2)
        (OP_OP_LDC3, OP_OP_SWC1, OP_OP_SWC2, OP_OP_SWC3, OP_OP_SDC1)
        (OP_OP_SDC2, OP_OP_SDC3): Define.

[ opcodes/ChangeLog ]
2002-12-27  Chris Demetriou  <cgd@@broadcom.com>

        * disassemble.c (disassembler_usage): Add invocation of
        print_mips_disassembler_options.
        * mips-dis.c (print_mips_disassembler_options)
        (set_default_mips_dis_options, parse_mips_dis_option)
        (parse_mips_dis_options, choose_abi_by_name, choose_arch_by_name)
        (choose_arch_by_number): New functions.
        (mips_abi_choice, mips_arch_choice): New structures.
        (mips32_reg_names, mips64_reg_names, reg_names): Remove.
        (mips_gpr_names_numeric, mips_gpr_names_oldabi)
        (mips_gpr_names_newabi, mips_fpr_names_numeric)
        (mips_fpr_names_32, mips_fpr_names_n32, mips_fpr_names_64)
        (mips_cp0_names_numeric, mips_cp0_names_mips3264)
        (mips_cp0_names_sb1, mips_abi_choices, mips_arch_choices)
        (mips_processor, mips_isa, mips_gpr_names, mips_fpr_names)
        (mips_cp0_names): New variables.
        (print_insn_args): Use new variables to print GPR, FPR, and CP0
        register names.
        (mips_isa_type): Remove.
        (print_insn_mips): Remove ISA and CPU setup since it is now done...
        (_print_insn_mips): Here.  Remove register setup code, and
        call set_default_mips_dis_options and parse_mips_dis_options
        instead.
        (print_mips16_insn_arg): Use mips_gpr_names instead of mips32_names.
@
text
@d53 1
a53 1
static void print_insn_arg
d137 11
d160 15
d195 1
d200 1
a200 1
    mips_cp0_names_numeric },
d202 1
a202 1
    NULL },
d204 1
a204 1
    NULL },
d206 1
a206 1
    NULL },
d208 1
a208 1
    NULL },
d210 1
a210 1
    NULL },
d212 1
a212 1
    NULL },
d214 1
a214 1
    NULL },
d216 1
a216 1
    NULL },
d218 1
a218 1
    NULL },
d220 1
a220 1
    NULL },
d222 1
a222 1
    NULL },
d224 1
a224 1
    NULL },
d226 1
a226 1
    NULL },
d228 1
a228 1
    NULL },
d230 1
a230 1
    NULL },
d232 1
a232 1
    NULL },
d234 1
a234 1
    NULL },
d236 1
a236 1
    NULL },
d238 1
a238 1
    NULL },
d246 4
a249 1
    mips_cp0_names_mips3264 },
d253 1
a253 1
    mips_cp0_names_mips3264 },
d256 1
a256 1
    mips_cp0_names_sb1 },
d261 1
a261 1
    NULL },
d272 1
d351 1
a351 1
     and numeric FPR and CP0 register names.  */
d357 1
d383 2
d443 9
d472 2
d515 1
a515 1
static void
d522 1
a522 1
  int op, delta;
d524 1
d535 36
d738 5
d827 2
d935 2
d938 7
a944 2
		  for (; *d != '\0'; d++)
		    print_insn_arg (d, word, memaddr, info);
d1613 5
d1622 1
a1622 1
  reg-names=ARCH           Print CP0 register names according to\n\
@


1.35
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d25 1
d43 6
a54 2
static void mips_isa_type
  PARAMS ((int, int *, int *));
d70 5
a74 12
static const char * const mips32_reg_names[] = {
  "zero", "at",	  "v0",	 "v1",	 "a0",	  "a1",	   "a2",   "a3",
  "t0",	  "t1",	  "t2",	 "t3",	 "t4",	  "t5",	   "t6",   "t7",
  "s0",	  "s1",	  "s2",	 "s3",	 "s4",	  "s5",	   "s6",   "s7",
  "t8",	  "t9",	  "k0",	 "k1",	 "gp",	  "sp",	   "s8",   "ra",
  "sr",	  "lo",	  "hi",	 "bad",	 "cause", "pc",
  "fv0",  "$f1",  "fv1", "$f3",  "ft0",   "$f5",   "ft1",  "$f7",
  "ft2",  "$f9",  "ft3", "$f11", "fa0",   "$f13",  "fa1",  "$f15",
  "ft4",  "f17",  "ft5", "f19",  "fs0",   "f21",   "fs1",  "f23",
  "fs2",  "$f25", "fs3", "$f27", "fs4",   "$f29",  "fs5",  "$f31",
  "fsr",  "fir",  "fp",  "inx",  "rand",  "tlblo", "ctxt", "tlbhi",
  "epc",  "prid"
d77 5
a81 12
static const char * const mips64_reg_names[] = {
  "zero", "at",	  "v0",	  "v1",	  "a0",	   "a1",    "a2",   "a3",
  "a4",	  "a5",	  "a6",   "a7",	  "t0",	   "t1",    "t2",   "t3",
  "s0",	  "s1",	  "s2",	  "s3",	  "s4",	   "s5",    "s6",   "s7",
  "t8",	  "t9",	  "k0",	  "k1",	  "gp",	   "sp",    "s8",   "ra",
  "sr",	  "lo",	  "hi",	  "bad",  "cause", "pc",
  "fv0",  "$f1",  "fv1",  "$f3",  "ft0",   "ft1",   "ft2",  "ft3",
  "ft4",  "ft5",  "ft6",  "ft7",  "fa0",   "fa1",   "fa2",  "fa3",
  "fa4",  "fa5",  "fa6",  "fa7",  "ft8",   "ft9",   "ft10", "ft11",
  "fs0",  "fs1",  "fs2",  "fs3",  "fs4",   "fs5",   "fs6",  "fs7",
  "fsr",  "fir",  "fp",   "inx",  "rand",  "tlblo", "ctxt", "tlbhi",
  "epc",  "prid"
d84 383
a466 3
/* Scalar register names. _print_insn_mips() decides which register name
   table to use.  */
static const char * const *reg_names = NULL;
d477 1
a477 1
  int delta;
d494 1
a494 1
			     reg_names[(l >> OP_SH_RS) & OP_MASK_RS]);
d500 1
a500 1
			     reg_names[(l >> OP_SH_RT) & OP_MASK_RT]);
d547 1
a547 1
			     reg_names[(l >> OP_SH_RD) & OP_MASK_RD]);
d556 1
a556 1
				 reg_names[reg]);
d562 1
a562 1
				     reg_names[(l >> OP_SH_RT) & OP_MASK_RT]);
d565 1
a565 1
				     reg_names[reg]);
d568 2
a569 2
				     reg_names[reg],
				     reg_names[(l >> OP_SH_RT) & OP_MASK_RT]);
d575 1
a575 1
      (*info->fprintf_func) (info->stream, "%s", reg_names[0]);
d610 2
a611 2
      (*info->fprintf_func) (info->stream, "$f%d",
			     (l >> OP_SH_FS) & OP_MASK_FS);
d616 2
a617 2
      (*info->fprintf_func) (info->stream, "$f%d",
			     (l >> OP_SH_FT) & OP_MASK_FT);
d621 2
a622 2
      (*info->fprintf_func) (info->stream, "$f%d",
			     (l >> OP_SH_FD) & OP_MASK_FD);
d626 2
a627 2
      (*info->fprintf_func) (info->stream, "$f%d",
			     (l >> OP_SH_FR) & OP_MASK_FR);
d631 7
d643 11
a653 2
      (*info->fprintf_func) (info->stream, "$%d",
			     (l >> OP_SH_RD) & OP_MASK_RD);
a741 116
/* Figure out the MIPS ISA and CPU based on the machine number.  */

static void
mips_isa_type (mach, isa, cputype)
     int mach;
     int *isa;
     int *cputype;
{
  switch (mach)
    {
    case bfd_mach_mips3000:
      *cputype = CPU_R3000;
      *isa = ISA_MIPS1;
      break;
    case bfd_mach_mips3900:
      *cputype = CPU_R3900;
      *isa = ISA_MIPS1;
      break;
    case bfd_mach_mips4000:
      *cputype = CPU_R4000;
      *isa = ISA_MIPS3;
      break;
    case bfd_mach_mips4010:
      *cputype = CPU_R4010;
      *isa = ISA_MIPS2;
      break;
    case bfd_mach_mips4100:
      *cputype = CPU_VR4100;
      *isa = ISA_MIPS3;
      break;
    case bfd_mach_mips4111:
      *cputype = CPU_R4111;
      *isa = ISA_MIPS3;
      break;
    case bfd_mach_mips4120:
      *cputype = CPU_VR4120;
      *isa = ISA_MIPS3;
      break;
    case bfd_mach_mips4300:
      *cputype = CPU_R4300;
      *isa = ISA_MIPS3;
      break;
    case bfd_mach_mips4400:
      *cputype = CPU_R4400;
      *isa = ISA_MIPS3;
      break;
    case bfd_mach_mips4600:
      *cputype = CPU_R4600;
      *isa = ISA_MIPS3;
      break;
    case bfd_mach_mips4650:
      *cputype = CPU_R4650;
      *isa = ISA_MIPS3;
      break;
    case bfd_mach_mips5000:
      *cputype = CPU_R5000;
      *isa = ISA_MIPS4;
      break;
    case bfd_mach_mips5400:
      *cputype = CPU_VR5400;
      *isa = ISA_MIPS4;
      break;
    case bfd_mach_mips5500:
      *cputype = CPU_VR5500;
      *isa = ISA_MIPS4;
      break;
    case bfd_mach_mips6000:
      *cputype = CPU_R6000;
      *isa = ISA_MIPS2;
      break;
    case bfd_mach_mips8000:
      *cputype = CPU_R8000;
      *isa = ISA_MIPS4;
      break;
    case bfd_mach_mips10000:
      *cputype = CPU_R10000;
      *isa = ISA_MIPS4;
      break;
    case bfd_mach_mips12000:
      *cputype = CPU_R12000;
      *isa = ISA_MIPS4;
      break;
    case bfd_mach_mips16:
      *cputype = CPU_MIPS16;
      *isa = ISA_MIPS3 | INSN_MIPS16;
      break;
    case bfd_mach_mips5:
      *cputype = CPU_MIPS5;
      *isa = ISA_MIPS5;
      break;
    case bfd_mach_mips_sb1:
      *cputype = CPU_SB1;
      *isa = ISA_MIPS64 | INSN_MIPS3D | INSN_SB1;
      break;
    case bfd_mach_mipsisa32:
      *cputype = CPU_MIPS32;
      /* For stock MIPS32, disassemble all applicable MIPS-specified ASEs.
	 Note that MIPS-3D and MDMX are not applicable to MIPS32.  (See
	 _MIPS32 Architecture For Programmers Volume I: Introduction to the
	 MIPS32 Architecture_ (MIPS Document Number MD00082, Revision 0.95),
	 page 1.  */
      *isa = ISA_MIPS32 | INSN_MIPS16;
      break;
    case bfd_mach_mipsisa64:
      *cputype = CPU_MIPS64;
      /* For stock MIPS64, disassemble all applicable MIPS-specified ASEs.  */
      *isa = ISA_MIPS64 | INSN_MIPS16 | INSN_MIPS3D | INSN_MDMX;
      break;

    default:
      *cputype = CPU_R3000;
      *isa = ISA_MIPS3;
      break;
    }
}

a770 1
  int target_processor, mips_isa;
a795 9
#if ! SYMTAB_AVAILABLE
  /* This is running out on a target machine, not in a host tool.
     FIXME: Where does mips_target_info come from?  */
  target_processor = mips_target_info.processor;
  mips_isa = mips_target_info.isa;
#else
  mips_isa_type (info->mach, &mips_isa, &target_processor);
#endif

d815 1
a815 1
	      if (! OPCODE_IS_MEMBER (op, mips_isa, target_processor)
d877 3
a895 12
  /* Use mips64_reg_names for new ABI.  */
  reg_names = mips32_reg_names;

  if (info->flavour == bfd_target_elf_flavour && info->symbols != NULL)
    {
      Elf_Internal_Ehdr *header;

      header = elf_elfheader (bfd_asymbol_bfd (*(info->symbols)));
      if (is_newabi (header))
	reg_names = mips64_reg_names;
    }

d1134 1
a1134 1
      (*info->fprintf_func) (info->stream, "%s", mips32_reg_names[0]);
d1138 1
a1138 1
      (*info->fprintf_func) (info->stream, "%s", mips32_reg_names[29]);
d1146 1
a1146 1
      (*info->fprintf_func) (info->stream, "%s", mips32_reg_names[31]);
d1151 2
a1152 2
			     mips32_reg_names[((l >> MIPS16OP_SH_REGR32)
					       & MIPS16OP_MASK_REGR32)]);
d1157 1
a1157 1
			     mips32_reg_names[MIPS16OP_EXTRACT_REG32R (l)]);
d1440 1
a1440 1
	    (*info->fprintf_func) (info->stream, "%s", mips32_reg_names[4]);
d1443 1
a1443 1
				     mips32_reg_names[amask + 3]);
d1458 1
a1458 1
				   mips32_reg_names[16]);
d1461 1
a1461 1
				     mips32_reg_names[smask + 15]);
d1469 1
a1469 1
				   mips32_reg_names[31]);
d1491 49
@


1.34
log
@[include/opcode/]
	* mips.h: Update comment for new opcodes.
	(OP_MASK_VECBYTE, OP_SH_VECBYTE): New.
	(OP_MASK_VECALIGN, OP_SH_VECALIGN): New.
	(INSN_4111, INSN_4120, INSN_5400, INSN_5500): New.
	(CPU_VR4120, CPU_VR5400, CPU_VR5500): New.
	(OPCODE_IS_MEMBER): Handle the new CPU_* values and INSN_* flags.
	Don't match CPU_R4111 with INSN_4100.

[opcodes/]
	* mips-dis.c (print_insn_arg): Handle '[', ']', 'e' and '%'.
	(mips_isa_type): Handle bfd_mach_mips4120, bfd_mach_mips5400
	and bfd_mach_mips5500.
	* mips-opc.c (V1): Include INSN_4111 and INSN_4120.
	(N411, N412, N5, N54, N55): New convenience defines.
	(mips_builtin_opcodes): Add vr4120, vr5400 and vr5500 opcodes.
	Change dmadd16 and madd16 from V1 to N411.
@
text
@d55 1
a55 1
  PARAMS ((int, const struct mips_opcode *, int, boolean, int, bfd_vma,
d315 1
a315 1
				   (l >> OP_SH_FT) & OP_MASK_FT, 
d501 1
a501 1
  static boolean init = 0;
d690 1
a690 1
  boolean use_extend;
d718 1
a718 1
  use_extend = false;
d721 1
a721 1
      use_extend = true;
d771 1
a771 1
	      use_extend = false;
d779 1
a779 1
		  use_extend = true;
d842 1
a842 1
     boolean use_extend;
@


1.34.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
a24 1
#include "libiberty.h"
a41 6
static void set_default_mips_dis_options
  PARAMS ((struct disassemble_info *));
static void parse_mips_dis_option
  PARAMS ((const char *, unsigned int));
static void parse_mips_dis_options
  PARAMS ((const char *));
d46 1
a46 1
static void print_insn_args
d48 2
d55 1
a55 1
  PARAMS ((int, const struct mips_opcode *, int, bfd_boolean, int, bfd_vma,
a59 6
struct mips_cp0sel_name {
	unsigned int cp0reg;
	unsigned int sel;
	const char * const name;
};

d65 33
a97 6
static const char * const mips_gpr_names_numeric[32] = {
  "$0",   "$1",   "$2",   "$3",   "$4",   "$5",   "$6",   "$7",
  "$8",   "$9",   "$10",  "$11",  "$12",  "$13",  "$14",  "$15",
  "$16",  "$17",  "$18",  "$19",  "$20",  "$21",  "$22",  "$23",
  "$24",  "$25",  "$26",  "$27",  "$28",  "$29",  "$30",  "$31"
};
d99 8
a106 6
static const char * const mips_gpr_names_oldabi[32] = {
  "zero", "at",   "v0",   "v1",   "a0",   "a1",   "a2",   "a3",
  "t0",   "t1",   "t2",   "t3",   "t4",   "t5",   "t6",   "t7",
  "s0",   "s1",   "s2",   "s3",   "s4",   "s5",   "s6",   "s7",
  "t8",   "t9",   "k0",   "k1",   "gp",   "sp",   "s8",   "ra"
};
d108 9
a116 6
static const char * const mips_gpr_names_newabi[32] = {
  "zero", "at",   "v0",   "v1",   "a0",   "a1",   "a2",   "a3",
  "a4",   "a5",   "a6",   "a7",   "t0",   "t1",   "t2",   "t3",
  "s0",   "s1",   "s2",   "s3",   "s4",   "s5",   "s6",   "s7",
  "t8",   "t9",   "k0",   "k1",   "gp",   "sp",   "s8",   "ra"
};
d118 7
a124 6
static const char * const mips_fpr_names_numeric[32] = {
  "$f0",  "$f1",  "$f2",  "$f3",  "$f4",  "$f5",  "$f6",  "$f7",
  "$f8",  "$f9",  "$f10", "$f11", "$f12", "$f13", "$f14", "$f15",
  "$f16", "$f17", "$f18", "$f19", "$f20", "$f21", "$f22", "$f23",
  "$f24", "$f25", "$f26", "$f27", "$f28", "$f29", "$f30", "$f31"
};
d126 5
a130 6
static const char * const mips_fpr_names_32[32] = {
  "fv0",  "fv0f", "fv1",  "fv1f", "ft0",  "ft0f", "ft1",  "ft1f",
  "ft2",  "ft2f", "ft3",  "ft3f", "fa0",  "fa0f", "fa1",  "fa1f",
  "ft4",  "ft4f", "ft5",  "ft5f", "fs0",  "fs0f", "fs1",  "fs1f",
  "fs2",  "fs2f", "fs3",  "fs3f", "fs4",  "fs4f", "fs5",  "fs5f"
};
d132 5
a136 6
static const char * const mips_fpr_names_n32[32] = {
  "fv0",  "ft14", "fv1",  "ft15", "ft0",  "ft1",  "ft2",  "ft3",
  "ft4",  "ft5",  "ft6",  "ft7",  "fa0",  "fa1",  "fa2",  "fa3",
  "fa4",  "fa5",  "fa6",  "fa7",  "fs0",  "ft8",  "fs1",  "ft9",
  "fs2",  "ft10", "fs3",  "ft11", "fs4",  "ft12", "fs5",  "ft13"
};
d138 8
a145 6
static const char * const mips_fpr_names_64[32] = {
  "fv0",  "ft12", "fv1",  "ft13", "ft0",  "ft1",  "ft2",  "ft3",
  "ft4",  "ft5",  "ft6",  "ft7",  "fa0",  "fa1",  "fa2",  "fa3",
  "fa4",  "fa5",  "fa6",  "fa7",  "ft8",  "ft9",  "ft10", "ft11",
  "fs0",  "fs1",  "fs2",  "fs3",  "fs4",  "fs5",  "fs6",  "fs7"
};
d147 5
a151 6
static const char * const mips_cp0_names_numeric[32] = {
  "$0",   "$1",   "$2",   "$3",   "$4",   "$5",   "$6",   "$7",
  "$8",   "$9",   "$10",  "$11",  "$12",  "$13",  "$14",  "$15",
  "$16",  "$17",  "$18",  "$19",  "$20",  "$21",  "$22",  "$23",
  "$24",  "$25",  "$26",  "$27",  "$28",  "$29",  "$30",  "$31"
};
d153 5
a157 10
static const char * const mips_cp0_names_mips3264[32] = {
  "c0_index",     "c0_random",    "c0_entrylo0",  "c0_entrylo1",
  "c0_context",   "c0_pagemask",  "c0_wired",     "$7",
  "c0_badvaddr",  "c0_count",     "c0_entryhi",   "c0_compare",
  "c0_status",    "c0_cause",     "c0_epc",       "c0_prid",
  "c0_config",    "c0_lladdr",    "c0_watchlo",   "c0_watchhi",
  "c0_xcontext",  "$21",          "$22",          "c0_debug",
  "c0_depc",      "c0_perfcnt",   "c0_errctl",    "c0_cacheerr",
  "c0_taglo",     "c0_taghi",     "c0_errorepc",  "c0_desave",
};
d159 5
a163 31
static const struct mips_cp0sel_name mips_cp0sel_names_mips3264[] = {
  { 16, 1, "c0_config1"		},
  { 16, 2, "c0_config2"		},
  { 16, 3, "c0_config3"		},
  { 18, 1, "c0_watchlo,1"	},
  { 18, 2, "c0_watchlo,2"	},
  { 18, 3, "c0_watchlo,3"	},
  { 18, 4, "c0_watchlo,4"	},
  { 18, 5, "c0_watchlo,5"	},
  { 18, 6, "c0_watchlo,6"	},
  { 18, 7, "c0_watchlo,7"	},
  { 19, 1, "c0_watchhi,1"	},
  { 19, 2, "c0_watchhi,2"	},
  { 19, 3, "c0_watchhi,3"	},
  { 19, 4, "c0_watchhi,4"	},
  { 19, 5, "c0_watchhi,5"	},
  { 19, 6, "c0_watchhi,6"	},
  { 19, 7, "c0_watchhi,7"	},
  { 25, 1, "c0_perfcnt,1"	},
  { 25, 2, "c0_perfcnt,2"	},
  { 25, 3, "c0_perfcnt,3"	},
  { 25, 4, "c0_perfcnt,4"	},
  { 25, 5, "c0_perfcnt,5"	},
  { 25, 6, "c0_perfcnt,6"	},
  { 25, 7, "c0_perfcnt,7"	},
  { 27, 1, "c0_cacheerr,1"	},
  { 27, 2, "c0_cacheerr,2"	},
  { 27, 3, "c0_cacheerr,3"	},
  { 28, 1, "c0_datalo"		},
  { 29, 1, "c0_datahi"		}
};
d165 8
a172 10
static const char * const mips_cp0_names_mips3264r2[32] = {
  "c0_index",     "c0_random",    "c0_entrylo0",  "c0_entrylo1",
  "c0_context",   "c0_pagemask",  "c0_wired",     "c0_hwrena",
  "c0_badvaddr",  "c0_count",     "c0_entryhi",   "c0_compare",
  "c0_status",    "c0_cause",     "c0_epc",       "c0_prid",
  "c0_config",    "c0_lladdr",    "c0_watchlo",   "c0_watchhi",
  "c0_xcontext",  "$21",          "$22",          "c0_debug",
  "c0_depc",      "c0_perfcnt",   "c0_errctl",    "c0_cacheerr",
  "c0_taglo",     "c0_taghi",     "c0_errorepc",  "c0_desave",
};
d174 4
a177 53
static const struct mips_cp0sel_name mips_cp0sel_names_mips3264r2[] = {
  {  4, 1, "c0_contextconfig"	},
  {  5, 1, "c0_pagegrain"	},
  { 12, 1, "c0_intctl"		},
  { 12, 2, "c0_srsctl"		},
  { 12, 3, "c0_srsmap"		},
  { 15, 1, "c0_ebase"		},
  { 16, 1, "c0_config1"		},
  { 16, 2, "c0_config2"		},
  { 16, 3, "c0_config3"		},
  { 18, 1, "c0_watchlo,1"	},
  { 18, 2, "c0_watchlo,2"	},
  { 18, 3, "c0_watchlo,3"	},
  { 18, 4, "c0_watchlo,4"	},
  { 18, 5, "c0_watchlo,5"	},
  { 18, 6, "c0_watchlo,6"	},
  { 18, 7, "c0_watchlo,7"	},
  { 19, 1, "c0_watchhi,1"	},
  { 19, 2, "c0_watchhi,2"	},
  { 19, 3, "c0_watchhi,3"	},
  { 19, 4, "c0_watchhi,4"	},
  { 19, 5, "c0_watchhi,5"	},
  { 19, 6, "c0_watchhi,6"	},
  { 19, 7, "c0_watchhi,7"	},
  { 23, 1, "c0_tracecontrol"	},
  { 23, 2, "c0_tracecontrol2"	},
  { 23, 3, "c0_usertracedata"	},
  { 23, 4, "c0_tracebpc"	},
  { 25, 1, "c0_perfcnt,1"	},
  { 25, 2, "c0_perfcnt,2"	},
  { 25, 3, "c0_perfcnt,3"	},
  { 25, 4, "c0_perfcnt,4"	},
  { 25, 5, "c0_perfcnt,5"	},
  { 25, 6, "c0_perfcnt,6"	},
  { 25, 7, "c0_perfcnt,7"	},
  { 27, 1, "c0_cacheerr,1"	},
  { 27, 2, "c0_cacheerr,2"	},
  { 27, 3, "c0_cacheerr,3"	},
  { 28, 1, "c0_datalo"		},
  { 28, 2, "c0_taglo1"		},
  { 28, 3, "c0_datalo1"		},
  { 28, 4, "c0_taglo2"		},
  { 28, 5, "c0_datalo2"		},
  { 28, 6, "c0_taglo3"		},
  { 28, 7, "c0_datalo3"		},
  { 29, 1, "c0_datahi"		},
  { 29, 2, "c0_taghi1"		},
  { 29, 3, "c0_datahi1"		},
  { 29, 4, "c0_taghi2"		},
  { 29, 5, "c0_datahi2"		},
  { 29, 6, "c0_taghi3"		},
  { 29, 7, "c0_datahi3"		},
};
d179 23
a201 11
/* SB-1: MIPS64 (mips_cp0_names_mips3264) with minor mods.  */
static const char * const mips_cp0_names_sb1[32] = {
  "c0_index",     "c0_random",    "c0_entrylo0",  "c0_entrylo1",
  "c0_context",   "c0_pagemask",  "c0_wired",     "$7",
  "c0_badvaddr",  "c0_count",     "c0_entryhi",   "c0_compare",
  "c0_status",    "c0_cause",     "c0_epc",       "c0_prid",
  "c0_config",    "c0_lladdr",    "c0_watchlo",   "c0_watchhi",
  "c0_xcontext",  "$21",          "$22",          "c0_debug",
  "c0_depc",      "c0_perfcnt",   "c0_errctl",    "c0_cacheerr_i",
  "c0_taglo_i",   "c0_taghi_i",   "c0_errorepc",  "c0_desave",
};
d203 3
a205 23
static const struct mips_cp0sel_name mips_cp0sel_names_sb1[] = {
  { 16, 1, "c0_config1"		},
  { 18, 1, "c0_watchlo,1"	},
  { 19, 1, "c0_watchhi,1"	},
  { 22, 0, "c0_perftrace"	},
  { 23, 3, "c0_edebug"		},
  { 25, 1, "c0_perfcnt,1"	},
  { 25, 2, "c0_perfcnt,2"	},
  { 25, 3, "c0_perfcnt,3"	},
  { 25, 4, "c0_perfcnt,4"	},
  { 25, 5, "c0_perfcnt,5"	},
  { 25, 6, "c0_perfcnt,6"	},
  { 25, 7, "c0_perfcnt,7"	},
  { 26, 1, "c0_buserr_pa"	},
  { 27, 1, "c0_cacheerr_d"	},
  { 27, 3, "c0_cacheerr_d_pa"	},
  { 28, 1, "c0_datalo_i"	},
  { 28, 2, "c0_taglo_d"		},
  { 28, 3, "c0_datalo_d"	},
  { 29, 1, "c0_datahi_i"	},
  { 29, 2, "c0_taghi_d"		},
  { 29, 3, "c0_datahi_d"	},
};
d207 4
a210 6
static const char * const mips_hwr_names_numeric[32] = {
  "$0",   "$1",   "$2",   "$3",   "$4",   "$5",   "$6",   "$7",
  "$8",   "$9",   "$10",  "$11",  "$12",  "$13",  "$14",  "$15",
  "$16",  "$17",  "$18",  "$19",  "$20",  "$21",  "$22",  "$23",
  "$24",  "$25",  "$26",  "$27",  "$28",  "$29",  "$30",  "$31"
};
d212 4
a215 7
static const char * const mips_hwr_names_mips3264r2[32] = {
  "hwr_cpunum",   "hwr_synci_step", "hwr_cc",     "hwr_ccres",
  "$4",          "$5",            "$6",           "$7",
  "$8",   "$9",   "$10",  "$11",  "$12",  "$13",  "$14",  "$15",
  "$16",  "$17",  "$18",  "$19",  "$20",  "$21",  "$22",  "$23",
  "$24",  "$25",  "$26",  "$27",  "$28",  "$29",  "$30",  "$31"
};
d217 4
a220 5
struct mips_abi_choice {
  const char *name;
  const char * const *gpr_names;
  const char * const *fpr_names;
};
d222 4
a225 6
struct mips_abi_choice mips_abi_choices[] = {
  { "numeric", mips_gpr_names_numeric, mips_fpr_names_numeric },
  { "32", mips_gpr_names_oldabi, mips_fpr_names_32 },
  { "n32", mips_gpr_names_newabi, mips_fpr_names_n32 },
  { "64", mips_gpr_names_newabi, mips_fpr_names_64 },
};
d227 4
a230 11
struct mips_arch_choice {
  const char *name;
  int bfd_mach_valid;
  unsigned long bfd_mach;
  int processor;
  int isa;
  const char * const *cp0_names;
  const struct mips_cp0sel_name *cp0sel_names;
  unsigned int cp0sel_names_len;
  const char * const *hwr_names;
};
d232 4
a235 88
const struct mips_arch_choice mips_arch_choices[] = {
  { "numeric",	0, 0, 0, 0,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },

  { "r3000",	1, bfd_mach_mips3000, CPU_R3000, ISA_MIPS1,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r3900",	1, bfd_mach_mips3900, CPU_R3900, ISA_MIPS1,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r4000",	1, bfd_mach_mips4000, CPU_R4000, ISA_MIPS3,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r4010",	1, bfd_mach_mips4010, CPU_R4010, ISA_MIPS2,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "vr4100",	1, bfd_mach_mips4100, CPU_VR4100, ISA_MIPS3,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "vr4111",	1, bfd_mach_mips4111, CPU_R4111, ISA_MIPS3,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "vr4120",	1, bfd_mach_mips4120, CPU_VR4120, ISA_MIPS3,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r4300",	1, bfd_mach_mips4300, CPU_R4300, ISA_MIPS3,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r4400",	1, bfd_mach_mips4400, CPU_R4400, ISA_MIPS3,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r4600",	1, bfd_mach_mips4600, CPU_R4600, ISA_MIPS3,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r4650",	1, bfd_mach_mips4650, CPU_R4650, ISA_MIPS3,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r5000",	1, bfd_mach_mips5000, CPU_R5000, ISA_MIPS4,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "vr5400",	1, bfd_mach_mips5400, CPU_VR5400, ISA_MIPS4,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "vr5500",	1, bfd_mach_mips5500, CPU_VR5500, ISA_MIPS4,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r6000",	1, bfd_mach_mips6000, CPU_R6000, ISA_MIPS2,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "rm7000",	1, bfd_mach_mips7000, CPU_RM7000, ISA_MIPS4,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "rm9000",	1, bfd_mach_mips7000, CPU_RM7000, ISA_MIPS4,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r8000",	1, bfd_mach_mips8000, CPU_R8000, ISA_MIPS4,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r10000",	1, bfd_mach_mips10000, CPU_R10000, ISA_MIPS4,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r12000",	1, bfd_mach_mips12000, CPU_R12000, ISA_MIPS4,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "mips5",	1, bfd_mach_mips5, CPU_MIPS5, ISA_MIPS5,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },

  /* For stock MIPS32, disassemble all applicable MIPS-specified ASEs.
     Note that MIPS-3D and MDMX are not applicable to MIPS32.  (See
     _MIPS32 Architecture For Programmers Volume I: Introduction to the
     MIPS32 Architecture_ (MIPS Document Number MD00082, Revision 0.95),
     page 1.  */
  { "mips32",	1, bfd_mach_mipsisa32, CPU_MIPS32,
    ISA_MIPS32 | INSN_MIPS16,
    mips_cp0_names_mips3264,
    mips_cp0sel_names_mips3264, ARRAY_SIZE (mips_cp0sel_names_mips3264),
    mips_hwr_names_numeric },

  { "mips32r2",	1, bfd_mach_mipsisa32r2, CPU_MIPS32R2,
    ISA_MIPS32R2 | INSN_MIPS16,
    mips_cp0_names_mips3264r2,
    mips_cp0sel_names_mips3264r2, ARRAY_SIZE (mips_cp0sel_names_mips3264r2),
    mips_hwr_names_mips3264r2 },

  /* For stock MIPS64, disassemble all applicable MIPS-specified ASEs.  */
  { "mips64",	1, bfd_mach_mipsisa64, CPU_MIPS64,
    ISA_MIPS64 | INSN_MIPS16 | INSN_MIPS3D | INSN_MDMX,
    mips_cp0_names_mips3264,
    mips_cp0sel_names_mips3264, ARRAY_SIZE (mips_cp0sel_names_mips3264),
    mips_hwr_names_numeric },

  { "mips64r2",	1, bfd_mach_mipsisa64r2, CPU_MIPS64R2,
    ISA_MIPS64R2 | INSN_MIPS16 | INSN_MIPS3D | INSN_MDMX,
    mips_cp0_names_mips3264r2,
    mips_cp0sel_names_mips3264r2, ARRAY_SIZE (mips_cp0sel_names_mips3264r2),
    mips_hwr_names_mips3264r2 },

  { "sb1",	1, bfd_mach_mips_sb1, CPU_SB1,
    ISA_MIPS64 | INSN_MIPS3D | INSN_SB1,
    mips_cp0_names_sb1,
    mips_cp0sel_names_sb1, ARRAY_SIZE (mips_cp0sel_names_sb1),
    mips_hwr_names_numeric },

  /* This entry, mips16, is here only for ISA/processor selection; do
     not print its name.  */
  { "",		1, bfd_mach_mips16, CPU_MIPS16, ISA_MIPS3 | INSN_MIPS16,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
};
d237 5
a241 29
/* ISA and processor type to disassemble for, and register names to use.
   set_default_mips_dis_options and parse_mips_dis_options fill in these
   values.  */
static int mips_processor;
static int mips_isa;
static const char * const *mips_gpr_names;
static const char * const *mips_fpr_names;
static const char * const *mips_cp0_names;
static const struct mips_cp0sel_name *mips_cp0sel_names;
static int mips_cp0sel_names_len;
static const char * const *mips_hwr_names;

static const struct mips_abi_choice *choose_abi_by_name
  PARAMS ((const char *, unsigned int));
static const struct mips_arch_choice *choose_arch_by_name
  PARAMS ((const char *, unsigned int));
static const struct mips_arch_choice *choose_arch_by_number
  PARAMS ((unsigned long));
static const struct mips_cp0sel_name *lookup_mips_cp0sel_name
  PARAMS ((const struct mips_cp0sel_name *, unsigned int, unsigned int,
	   unsigned int));

static const struct mips_abi_choice *
choose_abi_by_name (name, namelen)
     const char *name;
     unsigned int namelen;
{
  const struct mips_abi_choice *c;
  unsigned int i;
d243 5
a247 8
  for (i = 0, c = NULL; i < ARRAY_SIZE (mips_abi_choices) && c == NULL; i++)
    {
      if (strncmp (mips_abi_choices[i].name, name, namelen) == 0
	  && strlen (mips_abi_choices[i].name) == namelen)
	c = &mips_abi_choices[i];
    }
  return c;
}
d249 4
a252 7
static const struct mips_arch_choice *
choose_arch_by_name (name, namelen)
     const char *name;
     unsigned int namelen;
{
  const struct mips_arch_choice *c = NULL;
  unsigned int i;
d254 4
a257 8
  for (i = 0, c = NULL; i < ARRAY_SIZE (mips_arch_choices) && c == NULL; i++)
    {
      if (strncmp (mips_arch_choices[i].name, name, namelen) == 0
	  && strlen (mips_arch_choices[i].name) == namelen)
	c = &mips_arch_choices[i];
    }
  return c;
}
d259 4
a262 15
static const struct mips_arch_choice *
choose_arch_by_number (mach)
     unsigned long mach;
{
  static unsigned long hint_bfd_mach;
  static const struct mips_arch_choice *hint_arch_choice;
  const struct mips_arch_choice *c;
  unsigned int i;

  /* We optimize this because even if the user specifies no
     flags, this will be done for every instruction!  */
  if (hint_bfd_mach == mach
      && hint_arch_choice != NULL
      && hint_arch_choice->bfd_mach == hint_bfd_mach)
    return hint_arch_choice;
d264 4
a267 12
  for (i = 0, c = NULL; i < ARRAY_SIZE (mips_arch_choices) && c == NULL; i++)
    {
      if (mips_arch_choices[i].bfd_mach_valid
	  && mips_arch_choices[i].bfd_mach == mach)
	{
	  c = &mips_arch_choices[i];
	  hint_bfd_mach = mach;
	  hint_arch_choice = c;
	}
    }
  return c;
}
d269 4
a272 5
void
set_default_mips_dis_options (info)
     struct disassemble_info *info;
{
  const struct mips_arch_choice *chosen_arch;
d274 4
a277 10
  /* Defaults: mipsIII/r3000 (?!), (o)32-style ("oldabi") GPR names,
     and numeric FPR, CP0 register, and HWR names.  */
  mips_isa = ISA_MIPS3;
  mips_processor =  CPU_R3000;
  mips_gpr_names = mips_gpr_names_oldabi;
  mips_fpr_names = mips_fpr_names_numeric;
  mips_cp0_names = mips_cp0_names_numeric;
  mips_cp0sel_names = NULL;
  mips_cp0sel_names_len = 0;
  mips_hwr_names = mips_hwr_names_numeric;
d279 4
a282 4
  /* If an ELF "newabi" binary, use the n32/(n)64 GPR names.  */
  if (info->flavour == bfd_target_elf_flavour && info->section != NULL)
    {
      Elf_Internal_Ehdr *header;
d284 4
a287 4
      header = elf_elfheader (info->section->owner);
      if (is_newabi (header))
	mips_gpr_names = mips_gpr_names_newabi;
    }
d289 4
a292 19
  /* Set ISA, architecture, and cp0 register names as best we can.  */
#if ! SYMTAB_AVAILABLE
  /* This is running out on a target machine, not in a host tool.
     FIXME: Where does mips_target_info come from?  */
  target_processor = mips_target_info.processor;
  mips_isa = mips_target_info.isa;
#else
  chosen_arch = choose_arch_by_number (info->mach);
  if (chosen_arch != NULL)
    {
      mips_processor = chosen_arch->processor;
      mips_isa = chosen_arch->isa;
      mips_cp0_names = chosen_arch->cp0_names;
      mips_cp0sel_names = chosen_arch->cp0sel_names;
      mips_cp0sel_names_len = chosen_arch->cp0sel_names_len;
      mips_hwr_names = chosen_arch->hwr_names;
    }
#endif
}
d294 4
a297 9
void
parse_mips_dis_option (option, len)
     const char *option;
     unsigned int len;
{
  unsigned int i, optionlen, vallen;
  const char *val;
  const struct mips_abi_choice *chosen_abi;
  const struct mips_arch_choice *chosen_arch;
d299 4
a302 16
  /* Look for the = that delimits the end of the option name.  */
  for (i = 0; i < len; i++)
    {
      if (option[i] == '=')
	break;
    }
  if (i == 0)		/* Invalid option: no name before '='.  */
    return;
  if (i == len)		/* Invalid option: no '='.  */
    return;
  if (i == (len - 1))	/* Invalid option: no value after '='.  */
    return;

  optionlen = i;
  val = option + (optionlen + 1);
  vallen = len - (optionlen + 1);
d304 26
a329 8
  if (strncmp("gpr-names", option, optionlen) == 0
      && strlen("gpr-names") == optionlen)
    {
      chosen_abi = choose_abi_by_name (val, vallen);
      if (chosen_abi != NULL)
	mips_gpr_names = chosen_abi->gpr_names;
      return;
    }
d331 4
a334 8
  if (strncmp("fpr-names", option, optionlen) == 0
      && strlen("fpr-names") == optionlen)
    {
      chosen_abi = choose_abi_by_name (val, vallen);
      if (chosen_abi != NULL)
	mips_fpr_names = chosen_abi->fpr_names;
      return;
    }
d336 4
a339 12
  if (strncmp("cp0-names", option, optionlen) == 0
      && strlen("cp0-names") == optionlen)
    {
      chosen_arch = choose_arch_by_name (val, vallen);
      if (chosen_arch != NULL)
	{
	  mips_cp0_names = chosen_arch->cp0_names;
	  mips_cp0sel_names = chosen_arch->cp0sel_names;
	  mips_cp0sel_names_len = chosen_arch->cp0sel_names_len;
	}
      return;
    }
d341 4
a344 8
  if (strncmp("hwr-names", option, optionlen) == 0
      && strlen("hwr-names") == optionlen)
    {
      chosen_arch = choose_arch_by_name (val, vallen);
      if (chosen_arch != NULL)
	mips_hwr_names = chosen_arch->hwr_names;
      return;
    }
d346 6
a351 55
  if (strncmp("reg-names", option, optionlen) == 0
      && strlen("reg-names") == optionlen)
    {
      /* We check both ABI and ARCH here unconditionally, so
	 that "numeric" will do the desirable thing: select
	 numeric register names for all registers.  Other than
	 that, a given name probably won't match both.  */
      chosen_abi = choose_abi_by_name (val, vallen);
      if (chosen_abi != NULL)
	{
	  mips_gpr_names = chosen_abi->gpr_names;
	  mips_fpr_names = chosen_abi->fpr_names;
	}
      chosen_arch = choose_arch_by_name (val, vallen);
      if (chosen_arch != NULL)
	{
	  mips_cp0_names = chosen_arch->cp0_names;
	  mips_cp0sel_names = chosen_arch->cp0sel_names;
	  mips_cp0sel_names_len = chosen_arch->cp0sel_names_len;
	  mips_hwr_names = chosen_arch->hwr_names;
	}
      return;
    }

  /* Invalid option.  */
}

void
parse_mips_dis_options (options)
     const char *options;
{
  const char *option_end;

  if (options == NULL)
    return;

  while (*options != '\0')
    {
      /* Skip empty options.  */
      if (*options == ',')
	{
	  options++;
	  continue;
	}

      /* We know that *options is neither NUL or a comma.  */
      option_end = options + 1;
      while (*option_end != ',' && *option_end != '\0')
	option_end++;

      parse_mips_dis_option (options, option_end - options);

      /* Go on to the next one.  If option_end points to a comma, it
	 will be skipped above.  */
      options = option_end;
a353 13

static const struct mips_cp0sel_name *
lookup_mips_cp0sel_name(names, len, cp0reg, sel)
	const struct mips_cp0sel_name *names;
	unsigned int len, cp0reg, sel;
{
  unsigned int i;

  for (i = 0; i < len; i++)
    if (names[i].cp0reg == cp0reg && names[i].sel == sel)
      return &names[i];
  return NULL;
}
d355 1
a355 1
/* Print insn arguments for 32/64-bit code.  */
d358 4
a361 5
print_insn_args (d, l, pc, info)
     const char *d;
     register unsigned long int l;
     bfd_vma pc;
     struct disassemble_info *info;
d363 1
a363 6
  int op, delta;
  unsigned int lsb, msb, msbd;

  lsb = 0;

  for (; *d != '\0'; d++)
d365 98
a462 36
      switch (*d)
	{
	case ',':
	case '(':
	case ')':
	case '[':
	case ']':
	  (*info->fprintf_func) (info->stream, "%c", *d);
	  break;

	case '+':
	  /* Extension character; switch for second char.  */
	  d++;
	  switch (*d)
	    {
	    case '\0':
	      /* xgettext:c-format */
	      (*info->fprintf_func) (info->stream,
				     _("# internal error, incomplete extension sequence (+)"));
	      return;

	    case 'A':
	      lsb = (l >> OP_SH_SHAMT) & OP_MASK_SHAMT;
	      (*info->fprintf_func) (info->stream, "0x%x", lsb);
	      break;
	
	    case 'B':
	      msb = (l >> OP_SH_INSMSB) & OP_MASK_INSMSB;
	      (*info->fprintf_func) (info->stream, "0x%x", msb - lsb + 1);
	      break;

	    case 'C':
	    case 'H':
	      msbd = (l >> OP_SH_EXTMSBD) & OP_MASK_EXTMSBD;
	      (*info->fprintf_func) (info->stream, "0x%x", msbd + 1);
	      break;
d464 4
a467 302
	    case 'D':
	      {
		const struct mips_cp0sel_name *n;
		unsigned int cp0reg, sel;

		cp0reg = (l >> OP_SH_RD) & OP_MASK_RD;
		sel = (l >> OP_SH_SEL) & OP_MASK_SEL;

		/* CP0 register including 'sel' code for mtcN (et al.), to be
		   printed textually if known.  If not known, print both
		   CP0 register name and sel numerically since CP0 register
		   with sel 0 may have a name unrelated to register being
		   printed.  */
		n = lookup_mips_cp0sel_name(mips_cp0sel_names,
					    mips_cp0sel_names_len, cp0reg, sel);
		if (n != NULL)
		  (*info->fprintf_func) (info->stream, "%s", n->name);
		else
		  (*info->fprintf_func) (info->stream, "$%d,%d", cp0reg, sel);
		break;
	      }

	    case 'E':
	      lsb = ((l >> OP_SH_SHAMT) & OP_MASK_SHAMT) + 32;
	      (*info->fprintf_func) (info->stream, "0x%x", lsb);
	      break;
	
	    case 'F':
	      msb = ((l >> OP_SH_INSMSB) & OP_MASK_INSMSB) + 32;
	      (*info->fprintf_func) (info->stream, "0x%x", msb - lsb + 1);
	      break;

	    case 'G':
	      msbd = ((l >> OP_SH_EXTMSBD) & OP_MASK_EXTMSBD) + 32;
	      (*info->fprintf_func) (info->stream, "0x%x", msbd + 1);
	      break;

	    default:
	      /* xgettext:c-format */
	      (*info->fprintf_func) (info->stream,
				     _("# internal error, undefined extension sequence (+%c)"),
				     *d);
	      return;
	    }
	  break;

	case 's':
	case 'b':
	case 'r':
	case 'v':
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_gpr_names[(l >> OP_SH_RS) & OP_MASK_RS]);
	  break;

	case 't':
	case 'w':
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_gpr_names[(l >> OP_SH_RT) & OP_MASK_RT]);
	  break;

	case 'i':
	case 'u':
	  (*info->fprintf_func) (info->stream, "0x%x",
				 (l >> OP_SH_IMMEDIATE) & OP_MASK_IMMEDIATE);
	  break;

	case 'j': /* Same as i, but sign-extended.  */
	case 'o':
	  delta = (l >> OP_SH_DELTA) & OP_MASK_DELTA;
	  if (delta & 0x8000)
	    delta |= ~0xffff;
	  (*info->fprintf_func) (info->stream, "%d",
				 delta);
	  break;

	case 'h':
	  (*info->fprintf_func) (info->stream, "0x%x",
				 (unsigned int) ((l >> OP_SH_PREFX)
						 & OP_MASK_PREFX));
	  break;

	case 'k':
	  (*info->fprintf_func) (info->stream, "0x%x",
				 (unsigned int) ((l >> OP_SH_CACHE)
						 & OP_MASK_CACHE));
	  break;

	case 'a':
	  info->target = (((pc + 4) & ~(bfd_vma) 0x0fffffff)
			  | (((l >> OP_SH_TARGET) & OP_MASK_TARGET) << 2));
	  (*info->print_address_func) (info->target, info);
	  break;

	case 'p':
	  /* Sign extend the displacement.  */
	  delta = (l >> OP_SH_DELTA) & OP_MASK_DELTA;
	  if (delta & 0x8000)
	    delta |= ~0xffff;
	  info->target = (delta << 2) + pc + INSNLEN;
	  (*info->print_address_func) (info->target, info);
	  break;

	case 'd':
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_gpr_names[(l >> OP_SH_RD) & OP_MASK_RD]);
	  break;

	case 'U':
	  {
	    /* First check for both rd and rt being equal.  */
	    unsigned int reg = (l >> OP_SH_RD) & OP_MASK_RD;
	    if (reg == ((l >> OP_SH_RT) & OP_MASK_RT))
	      (*info->fprintf_func) (info->stream, "%s",
				     mips_gpr_names[reg]);
	    else
	      {
		/* If one is zero use the other.  */
		if (reg == 0)
		  (*info->fprintf_func) (info->stream, "%s",
					 mips_gpr_names[(l >> OP_SH_RT) & OP_MASK_RT]);
		else if (((l >> OP_SH_RT) & OP_MASK_RT) == 0)
		  (*info->fprintf_func) (info->stream, "%s",
					 mips_gpr_names[reg]);
		else /* Bogus, result depends on processor.  */
		  (*info->fprintf_func) (info->stream, "%s or %s",
					 mips_gpr_names[reg],
					 mips_gpr_names[(l >> OP_SH_RT) & OP_MASK_RT]);
	      }
	  }
	  break;

	case 'z':
	  (*info->fprintf_func) (info->stream, "%s", mips_gpr_names[0]);
	  break;

	case '<':
	  (*info->fprintf_func) (info->stream, "0x%x",
				 (l >> OP_SH_SHAMT) & OP_MASK_SHAMT);
	  break;

	case 'c':
	  (*info->fprintf_func) (info->stream, "0x%x",
				 (l >> OP_SH_CODE) & OP_MASK_CODE);
	  break;

	case 'q':
	  (*info->fprintf_func) (info->stream, "0x%x",
				 (l >> OP_SH_CODE2) & OP_MASK_CODE2);
	  break;

	case 'C':
	  (*info->fprintf_func) (info->stream, "0x%x",
				 (l >> OP_SH_COPZ) & OP_MASK_COPZ);
	  break;

	case 'B':
	  (*info->fprintf_func) (info->stream, "0x%x",
				 (l >> OP_SH_CODE20) & OP_MASK_CODE20);
	  break;

	case 'J':
	  (*info->fprintf_func) (info->stream, "0x%x",
				 (l >> OP_SH_CODE19) & OP_MASK_CODE19);
	  break;

	case 'S':
	case 'V':
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_fpr_names[(l >> OP_SH_FS) & OP_MASK_FS]);
	  break;

	case 'T':
	case 'W':
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_fpr_names[(l >> OP_SH_FT) & OP_MASK_FT]);
	  break;

	case 'D':
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_fpr_names[(l >> OP_SH_FD) & OP_MASK_FD]);
	  break;

	case 'R':
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_fpr_names[(l >> OP_SH_FR) & OP_MASK_FR]);
	  break;

	case 'E':
	  /* Coprocessor register for lwcN instructions, et al.

	     Note that there is no load/store cp0 instructions, and
	     that FPU (cp1) instructions disassemble this field using
	     'T' format.  Therefore, until we gain understanding of
	     cp2 register names, we can simply print the register
	     numbers.  */
	  (*info->fprintf_func) (info->stream, "$%d",
				 (l >> OP_SH_RT) & OP_MASK_RT);
	  break;

	case 'G':
	  /* Coprocessor register for mtcN instructions, et al.  Note
	     that FPU (cp1) instructions disassemble this field using
	     'S' format.  Therefore, we only need to worry about cp0,
	     cp2, and cp3.  */
	  op = (l >> OP_SH_OP) & OP_MASK_OP;
	  if (op == OP_OP_COP0)
	    (*info->fprintf_func) (info->stream, "%s",
				   mips_cp0_names[(l >> OP_SH_RD) & OP_MASK_RD]);
	  else
	    (*info->fprintf_func) (info->stream, "$%d",
				   (l >> OP_SH_RD) & OP_MASK_RD);
	  break;

	case 'K':
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_hwr_names[(l >> OP_SH_RD) & OP_MASK_RD]);
	  break;

	case 'N':
	  (*info->fprintf_func) (info->stream, "$fcc%d",
				 (l >> OP_SH_BCC) & OP_MASK_BCC);
	  break;

	case 'M':
	  (*info->fprintf_func) (info->stream, "$fcc%d",
				 (l >> OP_SH_CCC) & OP_MASK_CCC);
	  break;

	case 'P':
	  (*info->fprintf_func) (info->stream, "%d",
				 (l >> OP_SH_PERFREG) & OP_MASK_PERFREG);
	  break;

	case 'e':
	  (*info->fprintf_func) (info->stream, "%d",
				 (l >> OP_SH_VECBYTE) & OP_MASK_VECBYTE);
	  break;

	case '%':
	  (*info->fprintf_func) (info->stream, "%d",
				 (l >> OP_SH_VECALIGN) & OP_MASK_VECALIGN);
	  break;

	case 'H':
	  (*info->fprintf_func) (info->stream, "%d",
				 (l >> OP_SH_SEL) & OP_MASK_SEL);
	  break;

	case 'O':
	  (*info->fprintf_func) (info->stream, "%d",
				 (l >> OP_SH_ALN) & OP_MASK_ALN);
	  break;

	case 'Q':
	  {
	    unsigned int vsel = (l >> OP_SH_VSEL) & OP_MASK_VSEL;
	    if ((vsel & 0x10) == 0)
	      {
		int fmt;
		vsel &= 0x0f;
		for (fmt = 0; fmt < 3; fmt++, vsel >>= 1)
		  if ((vsel & 1) == 0)
		    break;
		(*info->fprintf_func) (info->stream, "$v%d[%d]",
				       (l >> OP_SH_FT) & OP_MASK_FT,
				       vsel >> 1);
	      }
	    else if ((vsel & 0x08) == 0)
	      {
		(*info->fprintf_func) (info->stream, "$v%d",
				       (l >> OP_SH_FT) & OP_MASK_FT);
	      }
	    else
	      {
		(*info->fprintf_func) (info->stream, "0x%x",
				       (l >> OP_SH_FT) & OP_MASK_FT);
	      }
	  }
	  break;

	case 'X':
	  (*info->fprintf_func) (info->stream, "$v%d",
				 (l >> OP_SH_FD) & OP_MASK_FD);
	  break;

	case 'Y':
	  (*info->fprintf_func) (info->stream, "$v%d",
				 (l >> OP_SH_FS) & OP_MASK_FS);
	  break;

	case 'Z':
	  (*info->fprintf_func) (info->stream, "$v%d",
				 (l >> OP_SH_FT) & OP_MASK_FT);
	  break;

	default:
	  /* xgettext:c-format */
	  (*info->fprintf_func) (info->stream,
				 _("# internal error, undefined modifier(%c)"),
				 *d);
	  return;
	}
d470 1
a470 1

d500 2
a501 1
  static bfd_boolean init = 0;
d526 9
d554 1
a554 1
	      if (! OPCODE_IS_MEMBER (op, mips_isa, mips_processor)
d586 2
a587 1
		  print_insn_args (d, word, memaddr, info);
a615 3
  set_default_mips_dis_options (info);
  parse_mips_dis_options (info->disassembler_options);

d632 12
d690 1
a690 1
  bfd_boolean use_extend;
d718 1
a718 1
  use_extend = FALSE;
d721 1
a721 1
      use_extend = TRUE;
d771 1
a771 1
	      use_extend = FALSE;
d779 1
a779 1
		  use_extend = TRUE;
d842 1
a842 1
     bfd_boolean use_extend;
d882 1
a882 1
      (*info->fprintf_func) (info->stream, "%s", mips_gpr_names[0]);
d886 1
a886 1
      (*info->fprintf_func) (info->stream, "%s", mips_gpr_names[29]);
d894 1
a894 1
      (*info->fprintf_func) (info->stream, "%s", mips_gpr_names[31]);
d899 2
a900 2
			     mips_gpr_names[((l >> MIPS16OP_SH_REGR32)
					    & MIPS16OP_MASK_REGR32)]);
d905 1
a905 1
			     mips_gpr_names[MIPS16OP_EXTRACT_REG32R (l)]);
d1188 1
a1188 1
	    (*info->fprintf_func) (info->stream, "%s", mips_gpr_names[4]);
d1191 1
a1191 1
				     mips_gpr_names[amask + 3]);
d1206 1
a1206 1
				   mips_gpr_names[16]);
d1209 1
a1209 1
				     mips_gpr_names[smask + 15]);
d1217 1
a1217 1
				   mips_gpr_names[31]);
a1238 54
}

void
print_mips_disassembler_options (stream)
     FILE *stream;
{
  unsigned int i;

  fprintf (stream, _("\n\
The following MIPS specific disassembler options are supported for use\n\
with the -M switch (multiple options should be separated by commas):\n"));

  fprintf (stream, _("\n\
  gpr-names=ABI            Print GPR names according to  specified ABI.\n\
                           Default: based on binary being disassembled.\n"));

  fprintf (stream, _("\n\
  fpr-names=ABI            Print FPR names according to specified ABI.\n\
                           Default: numeric.\n"));

  fprintf (stream, _("\n\
  cp0-names=ARCH           Print CP0 register names according to\n\
                           specified architecture.\n\
                           Default: based on binary being disassembled.\n"));

  fprintf (stream, _("\n\
  hwr-names=ARCH           Print HWR names according to specified \n\
			   architecture.\n\
                           Default: based on binary being disassembled.\n"));

  fprintf (stream, _("\n\
  reg-names=ABI            Print GPR and FPR names according to\n\
                           specified ABI.\n"));

  fprintf (stream, _("\n\
  reg-names=ARCH           Print CP0 register and HWR names according to\n\
                           specified architecture.\n"));

  fprintf (stream, _("\n\
  For the options above, the following values are supported for \"ABI\":\n\
   "));
  for (i = 0; i < ARRAY_SIZE (mips_abi_choices); i++)
    fprintf (stream, " %s", mips_abi_choices[i].name);
  fprintf (stream, _("\n"));

  fprintf (stream, _("\n\
  For the options above, The following values are supported for \"ARCH\":\n\
   "));
  for (i = 0; i < ARRAY_SIZE (mips_arch_choices); i++)
    if (*mips_arch_choices[i].name != '\0')
      fprintf (stream, " %s", mips_arch_choices[i].name);
  fprintf (stream, _("\n"));

  fprintf (stream, _("\n"));
@


1.33
log
@	/gas/ChangeLog
	* config/tc-mips.c (CPU_HAS_MIPS16): Add mips-lsi-elf as MIPS16
	capable configuration.
	(macro_build): Check for MIPS16 capability, not for actual MIPS16 code
	generation.
	(mips_ip): Likewise.

	/gas/testsuite/ChangeLog
	* gas/mips/mips-jalx.d: New file, check jalx assembly.
	* gas/mips/mips-jalx.s: Likewise.
	* gas/mips/mips-no-jalx.l: Likewise.
	* gas/mips/mips-no-jalx.s: Likewise.
	* gas/mips/mips16-jalx.d: Likewise.
	* gas/mips/mips16-jalx.s: Likewise.
	* gas/mips/mips.exp: Add new tests.

	/opcodes/ChangeLog:
	* mips-dis.c (print_insn_mips): Always allow disassembly of
	32-bit jalx opcode.
@
text
@d113 2
d284 10
d389 4
d411 8
@


1.32
log
@	* v850-dis.c (disassemble): Remove bfd_mach_v850ea case.

	* mips-dis.c (_print_insn_mips): Don't use hard-coded mach constants.
@
text
@d529 3
a531 1
	      if (! OPCODE_IS_MEMBER (op, mips_isa, target_processor))
@


1.32.6.1
log
@Merge with mainline; tag is carlton_dictionary-20020927-merge
@
text
@d529 1
a529 3
	      /* We always allow to disassemble the jalx instruction.  */
	      if (! OPCODE_IS_MEMBER (op, mips_isa, target_processor)
		  && strcmp (op->name, "jalx"))
@


1.32.6.2
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@a112 2
    case '[':
    case ']':
a281 10
    case 'e':
      (*info->fprintf_func) (info->stream, "%d",
			     (l >> OP_SH_VECBYTE) & OP_MASK_VECBYTE);
      break;

    case '%':
      (*info->fprintf_func) (info->stream, "%d",
			     (l >> OP_SH_VECALIGN) & OP_MASK_VECALIGN);
      break;

a376 4
    case bfd_mach_mips4120:
      *cputype = CPU_VR4120;
      *isa = ISA_MIPS3;
      break;
a394 8
      *isa = ISA_MIPS4;
      break;
    case bfd_mach_mips5400:
      *cputype = CPU_VR5400;
      *isa = ISA_MIPS4;
      break;
    case bfd_mach_mips5500:
      *cputype = CPU_VR5500;
@


1.32.6.3
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d55 1
a55 1
  PARAMS ((int, const struct mips_opcode *, int, bfd_boolean, int, bfd_vma,
d315 1
a315 1
				   (l >> OP_SH_FT) & OP_MASK_FT,
d501 1
a501 1
  static bfd_boolean init = 0;
d690 1
a690 1
  bfd_boolean use_extend;
d718 1
a718 1
  use_extend = FALSE;
d721 1
a721 1
      use_extend = TRUE;
d771 1
a771 1
	      use_extend = FALSE;
d779 1
a779 1
		  use_extend = TRUE;
d842 1
a842 1
     bfd_boolean use_extend;
@


1.32.6.4
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
a24 1
#include "libiberty.h"
a41 6
static void set_default_mips_dis_options
  PARAMS ((struct disassemble_info *));
static void parse_mips_dis_option
  PARAMS ((const char *, unsigned int));
static void parse_mips_dis_options
  PARAMS ((const char *));
d46 1
a46 1
static void print_insn_args
d48 2
a59 6
struct mips_cp0sel_name {
	unsigned int cp0reg;
	unsigned int sel;
	const char * const name;
};

d65 33
a97 6
static const char * const mips_gpr_names_numeric[32] = {
  "$0",   "$1",   "$2",   "$3",   "$4",   "$5",   "$6",   "$7",
  "$8",   "$9",   "$10",  "$11",  "$12",  "$13",  "$14",  "$15",
  "$16",  "$17",  "$18",  "$19",  "$20",  "$21",  "$22",  "$23",
  "$24",  "$25",  "$26",  "$27",  "$28",  "$29",  "$30",  "$31"
};
d99 8
a106 6
static const char * const mips_gpr_names_oldabi[32] = {
  "zero", "at",   "v0",   "v1",   "a0",   "a1",   "a2",   "a3",
  "t0",   "t1",   "t2",   "t3",   "t4",   "t5",   "t6",   "t7",
  "s0",   "s1",   "s2",   "s3",   "s4",   "s5",   "s6",   "s7",
  "t8",   "t9",   "k0",   "k1",   "gp",   "sp",   "s8",   "ra"
};
d108 9
a116 6
static const char * const mips_gpr_names_newabi[32] = {
  "zero", "at",   "v0",   "v1",   "a0",   "a1",   "a2",   "a3",
  "a4",   "a5",   "a6",   "a7",   "t0",   "t1",   "t2",   "t3",
  "s0",   "s1",   "s2",   "s3",   "s4",   "s5",   "s6",   "s7",
  "t8",   "t9",   "k0",   "k1",   "gp",   "sp",   "s8",   "ra"
};
d118 7
a124 6
static const char * const mips_fpr_names_numeric[32] = {
  "$f0",  "$f1",  "$f2",  "$f3",  "$f4",  "$f5",  "$f6",  "$f7",
  "$f8",  "$f9",  "$f10", "$f11", "$f12", "$f13", "$f14", "$f15",
  "$f16", "$f17", "$f18", "$f19", "$f20", "$f21", "$f22", "$f23",
  "$f24", "$f25", "$f26", "$f27", "$f28", "$f29", "$f30", "$f31"
};
d126 5
a130 6
static const char * const mips_fpr_names_32[32] = {
  "fv0",  "fv0f", "fv1",  "fv1f", "ft0",  "ft0f", "ft1",  "ft1f",
  "ft2",  "ft2f", "ft3",  "ft3f", "fa0",  "fa0f", "fa1",  "fa1f",
  "ft4",  "ft4f", "ft5",  "ft5f", "fs0",  "fs0f", "fs1",  "fs1f",
  "fs2",  "fs2f", "fs3",  "fs3f", "fs4",  "fs4f", "fs5",  "fs5f"
};
d132 5
a136 6
static const char * const mips_fpr_names_n32[32] = {
  "fv0",  "ft14", "fv1",  "ft15", "ft0",  "ft1",  "ft2",  "ft3",
  "ft4",  "ft5",  "ft6",  "ft7",  "fa0",  "fa1",  "fa2",  "fa3",
  "fa4",  "fa5",  "fa6",  "fa7",  "fs0",  "ft8",  "fs1",  "ft9",
  "fs2",  "ft10", "fs3",  "ft11", "fs4",  "ft12", "fs5",  "ft13"
};
d138 8
a145 6
static const char * const mips_fpr_names_64[32] = {
  "fv0",  "ft12", "fv1",  "ft13", "ft0",  "ft1",  "ft2",  "ft3",
  "ft4",  "ft5",  "ft6",  "ft7",  "fa0",  "fa1",  "fa2",  "fa3",
  "fa4",  "fa5",  "fa6",  "fa7",  "ft8",  "ft9",  "ft10", "ft11",
  "fs0",  "fs1",  "fs2",  "fs3",  "fs4",  "fs5",  "fs6",  "fs7"
};
d147 5
a151 6
static const char * const mips_cp0_names_numeric[32] = {
  "$0",   "$1",   "$2",   "$3",   "$4",   "$5",   "$6",   "$7",
  "$8",   "$9",   "$10",  "$11",  "$12",  "$13",  "$14",  "$15",
  "$16",  "$17",  "$18",  "$19",  "$20",  "$21",  "$22",  "$23",
  "$24",  "$25",  "$26",  "$27",  "$28",  "$29",  "$30",  "$31"
};
d153 5
a157 10
static const char * const mips_cp0_names_mips3264[32] = {
  "c0_index",     "c0_random",    "c0_entrylo0",  "c0_entrylo1",
  "c0_context",   "c0_pagemask",  "c0_wired",     "$7",
  "c0_badvaddr",  "c0_count",     "c0_entryhi",   "c0_compare",
  "c0_status",    "c0_cause",     "c0_epc",       "c0_prid",
  "c0_config",    "c0_lladdr",    "c0_watchlo",   "c0_watchhi",
  "c0_xcontext",  "$21",          "$22",          "c0_debug",
  "c0_depc",      "c0_perfcnt",   "c0_errctl",    "c0_cacheerr",
  "c0_taglo",     "c0_taghi",     "c0_errorepc",  "c0_desave",
};
d159 5
a163 31
static const struct mips_cp0sel_name mips_cp0sel_names_mips3264[] = {
  { 16, 1, "c0_config1"		},
  { 16, 2, "c0_config2"		},
  { 16, 3, "c0_config3"		},
  { 18, 1, "c0_watchlo,1"	},
  { 18, 2, "c0_watchlo,2"	},
  { 18, 3, "c0_watchlo,3"	},
  { 18, 4, "c0_watchlo,4"	},
  { 18, 5, "c0_watchlo,5"	},
  { 18, 6, "c0_watchlo,6"	},
  { 18, 7, "c0_watchlo,7"	},
  { 19, 1, "c0_watchhi,1"	},
  { 19, 2, "c0_watchhi,2"	},
  { 19, 3, "c0_watchhi,3"	},
  { 19, 4, "c0_watchhi,4"	},
  { 19, 5, "c0_watchhi,5"	},
  { 19, 6, "c0_watchhi,6"	},
  { 19, 7, "c0_watchhi,7"	},
  { 25, 1, "c0_perfcnt,1"	},
  { 25, 2, "c0_perfcnt,2"	},
  { 25, 3, "c0_perfcnt,3"	},
  { 25, 4, "c0_perfcnt,4"	},
  { 25, 5, "c0_perfcnt,5"	},
  { 25, 6, "c0_perfcnt,6"	},
  { 25, 7, "c0_perfcnt,7"	},
  { 27, 1, "c0_cacheerr,1"	},
  { 27, 2, "c0_cacheerr,2"	},
  { 27, 3, "c0_cacheerr,3"	},
  { 28, 1, "c0_datalo"		},
  { 29, 1, "c0_datahi"		}
};
d165 8
a172 10
static const char * const mips_cp0_names_mips3264r2[32] = {
  "c0_index",     "c0_random",    "c0_entrylo0",  "c0_entrylo1",
  "c0_context",   "c0_pagemask",  "c0_wired",     "c0_hwrena",
  "c0_badvaddr",  "c0_count",     "c0_entryhi",   "c0_compare",
  "c0_status",    "c0_cause",     "c0_epc",       "c0_prid",
  "c0_config",    "c0_lladdr",    "c0_watchlo",   "c0_watchhi",
  "c0_xcontext",  "$21",          "$22",          "c0_debug",
  "c0_depc",      "c0_perfcnt",   "c0_errctl",    "c0_cacheerr",
  "c0_taglo",     "c0_taghi",     "c0_errorepc",  "c0_desave",
};
d174 4
a177 53
static const struct mips_cp0sel_name mips_cp0sel_names_mips3264r2[] = {
  {  4, 1, "c0_contextconfig"	},
  {  5, 1, "c0_pagegrain"	},
  { 12, 1, "c0_intctl"		},
  { 12, 2, "c0_srsctl"		},
  { 12, 3, "c0_srsmap"		},
  { 15, 1, "c0_ebase"		},
  { 16, 1, "c0_config1"		},
  { 16, 2, "c0_config2"		},
  { 16, 3, "c0_config3"		},
  { 18, 1, "c0_watchlo,1"	},
  { 18, 2, "c0_watchlo,2"	},
  { 18, 3, "c0_watchlo,3"	},
  { 18, 4, "c0_watchlo,4"	},
  { 18, 5, "c0_watchlo,5"	},
  { 18, 6, "c0_watchlo,6"	},
  { 18, 7, "c0_watchlo,7"	},
  { 19, 1, "c0_watchhi,1"	},
  { 19, 2, "c0_watchhi,2"	},
  { 19, 3, "c0_watchhi,3"	},
  { 19, 4, "c0_watchhi,4"	},
  { 19, 5, "c0_watchhi,5"	},
  { 19, 6, "c0_watchhi,6"	},
  { 19, 7, "c0_watchhi,7"	},
  { 23, 1, "c0_tracecontrol"	},
  { 23, 2, "c0_tracecontrol2"	},
  { 23, 3, "c0_usertracedata"	},
  { 23, 4, "c0_tracebpc"	},
  { 25, 1, "c0_perfcnt,1"	},
  { 25, 2, "c0_perfcnt,2"	},
  { 25, 3, "c0_perfcnt,3"	},
  { 25, 4, "c0_perfcnt,4"	},
  { 25, 5, "c0_perfcnt,5"	},
  { 25, 6, "c0_perfcnt,6"	},
  { 25, 7, "c0_perfcnt,7"	},
  { 27, 1, "c0_cacheerr,1"	},
  { 27, 2, "c0_cacheerr,2"	},
  { 27, 3, "c0_cacheerr,3"	},
  { 28, 1, "c0_datalo"		},
  { 28, 2, "c0_taglo1"		},
  { 28, 3, "c0_datalo1"		},
  { 28, 4, "c0_taglo2"		},
  { 28, 5, "c0_datalo2"		},
  { 28, 6, "c0_taglo3"		},
  { 28, 7, "c0_datalo3"		},
  { 29, 1, "c0_datahi"		},
  { 29, 2, "c0_taghi1"		},
  { 29, 3, "c0_datahi1"		},
  { 29, 4, "c0_taghi2"		},
  { 29, 5, "c0_datahi2"		},
  { 29, 6, "c0_taghi3"		},
  { 29, 7, "c0_datahi3"		},
};
d179 23
a201 11
/* SB-1: MIPS64 (mips_cp0_names_mips3264) with minor mods.  */
static const char * const mips_cp0_names_sb1[32] = {
  "c0_index",     "c0_random",    "c0_entrylo0",  "c0_entrylo1",
  "c0_context",   "c0_pagemask",  "c0_wired",     "$7",
  "c0_badvaddr",  "c0_count",     "c0_entryhi",   "c0_compare",
  "c0_status",    "c0_cause",     "c0_epc",       "c0_prid",
  "c0_config",    "c0_lladdr",    "c0_watchlo",   "c0_watchhi",
  "c0_xcontext",  "$21",          "$22",          "c0_debug",
  "c0_depc",      "c0_perfcnt",   "c0_errctl",    "c0_cacheerr_i",
  "c0_taglo_i",   "c0_taghi_i",   "c0_errorepc",  "c0_desave",
};
d203 3
a205 23
static const struct mips_cp0sel_name mips_cp0sel_names_sb1[] = {
  { 16, 1, "c0_config1"		},
  { 18, 1, "c0_watchlo,1"	},
  { 19, 1, "c0_watchhi,1"	},
  { 22, 0, "c0_perftrace"	},
  { 23, 3, "c0_edebug"		},
  { 25, 1, "c0_perfcnt,1"	},
  { 25, 2, "c0_perfcnt,2"	},
  { 25, 3, "c0_perfcnt,3"	},
  { 25, 4, "c0_perfcnt,4"	},
  { 25, 5, "c0_perfcnt,5"	},
  { 25, 6, "c0_perfcnt,6"	},
  { 25, 7, "c0_perfcnt,7"	},
  { 26, 1, "c0_buserr_pa"	},
  { 27, 1, "c0_cacheerr_d"	},
  { 27, 3, "c0_cacheerr_d_pa"	},
  { 28, 1, "c0_datalo_i"	},
  { 28, 2, "c0_taglo_d"		},
  { 28, 3, "c0_datalo_d"	},
  { 29, 1, "c0_datahi_i"	},
  { 29, 2, "c0_taghi_d"		},
  { 29, 3, "c0_datahi_d"	},
};
d207 4
a210 6
static const char * const mips_hwr_names_numeric[32] = {
  "$0",   "$1",   "$2",   "$3",   "$4",   "$5",   "$6",   "$7",
  "$8",   "$9",   "$10",  "$11",  "$12",  "$13",  "$14",  "$15",
  "$16",  "$17",  "$18",  "$19",  "$20",  "$21",  "$22",  "$23",
  "$24",  "$25",  "$26",  "$27",  "$28",  "$29",  "$30",  "$31"
};
d212 4
a215 7
static const char * const mips_hwr_names_mips3264r2[32] = {
  "hwr_cpunum",   "hwr_synci_step", "hwr_cc",     "hwr_ccres",
  "$4",          "$5",            "$6",           "$7",
  "$8",   "$9",   "$10",  "$11",  "$12",  "$13",  "$14",  "$15",
  "$16",  "$17",  "$18",  "$19",  "$20",  "$21",  "$22",  "$23",
  "$24",  "$25",  "$26",  "$27",  "$28",  "$29",  "$30",  "$31"
};
d217 4
a220 5
struct mips_abi_choice {
  const char *name;
  const char * const *gpr_names;
  const char * const *fpr_names;
};
d222 4
a225 6
struct mips_abi_choice mips_abi_choices[] = {
  { "numeric", mips_gpr_names_numeric, mips_fpr_names_numeric },
  { "32", mips_gpr_names_oldabi, mips_fpr_names_32 },
  { "n32", mips_gpr_names_newabi, mips_fpr_names_n32 },
  { "64", mips_gpr_names_newabi, mips_fpr_names_64 },
};
d227 4
a230 11
struct mips_arch_choice {
  const char *name;
  int bfd_mach_valid;
  unsigned long bfd_mach;
  int processor;
  int isa;
  const char * const *cp0_names;
  const struct mips_cp0sel_name *cp0sel_names;
  unsigned int cp0sel_names_len;
  const char * const *hwr_names;
};
d232 4
a235 78
const struct mips_arch_choice mips_arch_choices[] = {
  { "numeric",	0, 0, 0, 0,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },

  { "r3000",	1, bfd_mach_mips3000, CPU_R3000, ISA_MIPS1,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r3900",	1, bfd_mach_mips3900, CPU_R3900, ISA_MIPS1,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r4000",	1, bfd_mach_mips4000, CPU_R4000, ISA_MIPS3,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r4010",	1, bfd_mach_mips4010, CPU_R4010, ISA_MIPS2,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "vr4100",	1, bfd_mach_mips4100, CPU_VR4100, ISA_MIPS3,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "vr4111",	1, bfd_mach_mips4111, CPU_R4111, ISA_MIPS3,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "vr4120",	1, bfd_mach_mips4120, CPU_VR4120, ISA_MIPS3,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r4300",	1, bfd_mach_mips4300, CPU_R4300, ISA_MIPS3,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r4400",	1, bfd_mach_mips4400, CPU_R4400, ISA_MIPS3,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r4600",	1, bfd_mach_mips4600, CPU_R4600, ISA_MIPS3,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r4650",	1, bfd_mach_mips4650, CPU_R4650, ISA_MIPS3,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r5000",	1, bfd_mach_mips5000, CPU_R5000, ISA_MIPS4,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "vr5400",	1, bfd_mach_mips5400, CPU_VR5400, ISA_MIPS4,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "vr5500",	1, bfd_mach_mips5500, CPU_VR5500, ISA_MIPS4,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r6000",	1, bfd_mach_mips6000, CPU_R6000, ISA_MIPS2,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r8000",	1, bfd_mach_mips8000, CPU_R8000, ISA_MIPS4,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r10000",	1, bfd_mach_mips10000, CPU_R10000, ISA_MIPS4,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "r12000",	1, bfd_mach_mips12000, CPU_R12000, ISA_MIPS4,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "mips5",	1, bfd_mach_mips5, CPU_MIPS5, ISA_MIPS5,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },

  /* For stock MIPS32, disassemble all applicable MIPS-specified ASEs.
     Note that MIPS-3D and MDMX are not applicable to MIPS32.  (See
     _MIPS32 Architecture For Programmers Volume I: Introduction to the
     MIPS32 Architecture_ (MIPS Document Number MD00082, Revision 0.95),
     page 1.  */
  { "mips32",	1, bfd_mach_mipsisa32, CPU_MIPS32,
    ISA_MIPS32 | INSN_MIPS16,
    mips_cp0_names_mips3264,
    mips_cp0sel_names_mips3264, ARRAY_SIZE (mips_cp0sel_names_mips3264),
    mips_hwr_names_numeric },

  { "mips32r2",	1, bfd_mach_mipsisa32r2, CPU_MIPS32R2,
    ISA_MIPS32R2 | INSN_MIPS16,
    mips_cp0_names_mips3264r2,
    mips_cp0sel_names_mips3264r2, ARRAY_SIZE (mips_cp0sel_names_mips3264r2),
    mips_hwr_names_mips3264r2 },

  /* For stock MIPS64, disassemble all applicable MIPS-specified ASEs.  */
  { "mips64",	1, bfd_mach_mipsisa64, CPU_MIPS64,
    ISA_MIPS64 | INSN_MIPS16 | INSN_MIPS3D | INSN_MDMX,
    mips_cp0_names_mips3264,
    mips_cp0sel_names_mips3264, ARRAY_SIZE (mips_cp0sel_names_mips3264),
    mips_hwr_names_numeric },

  { "sb1",	1, bfd_mach_mips_sb1, CPU_SB1,
    ISA_MIPS64 | INSN_MIPS3D | INSN_SB1,
    mips_cp0_names_sb1,
    mips_cp0sel_names_sb1, ARRAY_SIZE (mips_cp0sel_names_sb1),
    mips_hwr_names_numeric },

  /* This entry, mips16, is here only for ISA/processor selection; do
     not print its name.  */
  { "",		1, bfd_mach_mips16, CPU_MIPS16, ISA_MIPS3 | INSN_MIPS16,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
};
d237 5
a241 29
/* ISA and processor type to disassemble for, and register names to use.
   set_default_mips_dis_options and parse_mips_dis_options fill in these
   values.  */
static int mips_processor;
static int mips_isa;
static const char * const *mips_gpr_names;
static const char * const *mips_fpr_names;
static const char * const *mips_cp0_names;
static const struct mips_cp0sel_name *mips_cp0sel_names;
static int mips_cp0sel_names_len;
static const char * const *mips_hwr_names;

static const struct mips_abi_choice *choose_abi_by_name
  PARAMS ((const char *, unsigned int));
static const struct mips_arch_choice *choose_arch_by_name
  PARAMS ((const char *, unsigned int));
static const struct mips_arch_choice *choose_arch_by_number
  PARAMS ((unsigned long));
static const struct mips_cp0sel_name *lookup_mips_cp0sel_name
  PARAMS ((const struct mips_cp0sel_name *, unsigned int, unsigned int,
	   unsigned int));

static const struct mips_abi_choice *
choose_abi_by_name (name, namelen)
     const char *name;
     unsigned int namelen;
{
  const struct mips_abi_choice *c;
  unsigned int i;
d243 5
a247 8
  for (i = 0, c = NULL; i < ARRAY_SIZE (mips_abi_choices) && c == NULL; i++)
    {
      if (strncmp (mips_abi_choices[i].name, name, namelen) == 0
	  && strlen (mips_abi_choices[i].name) == namelen)
	c = &mips_abi_choices[i];
    }
  return c;
}
d249 4
a252 7
static const struct mips_arch_choice *
choose_arch_by_name (name, namelen)
     const char *name;
     unsigned int namelen;
{
  const struct mips_arch_choice *c = NULL;
  unsigned int i;
d254 4
a257 8
  for (i = 0, c = NULL; i < ARRAY_SIZE (mips_arch_choices) && c == NULL; i++)
    {
      if (strncmp (mips_arch_choices[i].name, name, namelen) == 0
	  && strlen (mips_arch_choices[i].name) == namelen)
	c = &mips_arch_choices[i];
    }
  return c;
}
d259 4
a262 15
static const struct mips_arch_choice *
choose_arch_by_number (mach)
     unsigned long mach;
{
  static unsigned long hint_bfd_mach;
  static const struct mips_arch_choice *hint_arch_choice;
  const struct mips_arch_choice *c;
  unsigned int i;

  /* We optimize this because even if the user specifies no
     flags, this will be done for every instruction!  */
  if (hint_bfd_mach == mach
      && hint_arch_choice != NULL
      && hint_arch_choice->bfd_mach == hint_bfd_mach)
    return hint_arch_choice;
d264 4
a267 12
  for (i = 0, c = NULL; i < ARRAY_SIZE (mips_arch_choices) && c == NULL; i++)
    {
      if (mips_arch_choices[i].bfd_mach_valid
	  && mips_arch_choices[i].bfd_mach == mach)
	{
	  c = &mips_arch_choices[i];
	  hint_bfd_mach = mach;
	  hint_arch_choice = c;
	}
    }
  return c;
}
d269 4
a272 5
void
set_default_mips_dis_options (info)
     struct disassemble_info *info;
{
  const struct mips_arch_choice *chosen_arch;
d274 4
a277 10
  /* Defaults: mipsIII/r3000 (?!), (o)32-style ("oldabi") GPR names,
     and numeric FPR, CP0 register, and HWR names.  */
  mips_isa = ISA_MIPS3;
  mips_processor =  CPU_R3000;
  mips_gpr_names = mips_gpr_names_oldabi;
  mips_fpr_names = mips_fpr_names_numeric;
  mips_cp0_names = mips_cp0_names_numeric;
  mips_cp0sel_names = NULL;
  mips_cp0sel_names_len = 0;
  mips_hwr_names = mips_hwr_names_numeric;
d279 4
a282 4
  /* If an ELF "newabi" binary, use the n32/(n)64 GPR names.  */
  if (info->flavour == bfd_target_elf_flavour && info->symbols != NULL)
    {
      Elf_Internal_Ehdr *header;
d284 4
a287 4
      header = elf_elfheader (bfd_asymbol_bfd (*(info->symbols)));
      if (is_newabi (header))
	mips_gpr_names = mips_gpr_names_newabi;
    }
d289 4
a292 19
  /* Set ISA, architecture, and cp0 register names as best we can.  */
#if ! SYMTAB_AVAILABLE
  /* This is running out on a target machine, not in a host tool.
     FIXME: Where does mips_target_info come from?  */
  target_processor = mips_target_info.processor;
  mips_isa = mips_target_info.isa;
#else
  chosen_arch = choose_arch_by_number (info->mach);
  if (chosen_arch != NULL)
    {
      mips_processor = chosen_arch->processor;
      mips_isa = chosen_arch->isa;
      mips_cp0_names = chosen_arch->cp0_names;
      mips_cp0sel_names = chosen_arch->cp0sel_names;
      mips_cp0sel_names_len = chosen_arch->cp0sel_names_len;
      mips_hwr_names = chosen_arch->hwr_names;
    }
#endif
}
d294 4
a297 9
void
parse_mips_dis_option (option, len)
     const char *option;
     unsigned int len;
{
  unsigned int i, optionlen, vallen;
  const char *val;
  const struct mips_abi_choice *chosen_abi;
  const struct mips_arch_choice *chosen_arch;
d299 4
a302 16
  /* Look for the = that delimits the end of the option name.  */
  for (i = 0; i < len; i++)
    {
      if (option[i] == '=')
	break;
    }
  if (i == 0)		/* Invalid option: no name before '='.  */
    return;
  if (i == len)		/* Invalid option: no '='.  */
    return;
  if (i == (len - 1))	/* Invalid option: no value after '='.  */
    return;

  optionlen = i;
  val = option + (optionlen + 1);
  vallen = len - (optionlen + 1);
d304 26
a329 8
  if (strncmp("gpr-names", option, optionlen) == 0
      && strlen("gpr-names") == optionlen)
    {
      chosen_abi = choose_abi_by_name (val, vallen);
      if (chosen_abi != NULL)
	mips_gpr_names = chosen_abi->gpr_names;
      return;
    }
d331 4
a334 8
  if (strncmp("fpr-names", option, optionlen) == 0
      && strlen("fpr-names") == optionlen)
    {
      chosen_abi = choose_abi_by_name (val, vallen);
      if (chosen_abi != NULL)
	mips_fpr_names = chosen_abi->fpr_names;
      return;
    }
d336 4
a339 12
  if (strncmp("cp0-names", option, optionlen) == 0
      && strlen("cp0-names") == optionlen)
    {
      chosen_arch = choose_arch_by_name (val, vallen);
      if (chosen_arch != NULL)
	{
	  mips_cp0_names = chosen_arch->cp0_names;
	  mips_cp0sel_names = chosen_arch->cp0sel_names;
	  mips_cp0sel_names_len = chosen_arch->cp0sel_names_len;
	}
      return;
    }
d341 4
a344 8
  if (strncmp("hwr-names", option, optionlen) == 0
      && strlen("hwr-names") == optionlen)
    {
      chosen_arch = choose_arch_by_name (val, vallen);
      if (chosen_arch != NULL)
	mips_hwr_names = chosen_arch->hwr_names;
      return;
    }
d346 6
a351 55
  if (strncmp("reg-names", option, optionlen) == 0
      && strlen("reg-names") == optionlen)
    {
      /* We check both ABI and ARCH here unconditionally, so
	 that "numeric" will do the desirable thing: select
	 numeric register names for all registers.  Other than
	 that, a given name probably won't match both.  */
      chosen_abi = choose_abi_by_name (val, vallen);
      if (chosen_abi != NULL)
	{
	  mips_gpr_names = chosen_abi->gpr_names;
	  mips_fpr_names = chosen_abi->fpr_names;
	}
      chosen_arch = choose_arch_by_name (val, vallen);
      if (chosen_arch != NULL)
	{
	  mips_cp0_names = chosen_arch->cp0_names;
	  mips_cp0sel_names = chosen_arch->cp0sel_names;
	  mips_cp0sel_names_len = chosen_arch->cp0sel_names_len;
	  mips_hwr_names = chosen_arch->hwr_names;
	}
      return;
    }

  /* Invalid option.  */
}

void
parse_mips_dis_options (options)
     const char *options;
{
  const char *option_end;

  if (options == NULL)
    return;

  while (*options != '\0')
    {
      /* Skip empty options.  */
      if (*options == ',')
	{
	  options++;
	  continue;
	}

      /* We know that *options is neither NUL or a comma.  */
      option_end = options + 1;
      while (*option_end != ',' && *option_end != '\0')
	option_end++;

      parse_mips_dis_option (options, option_end - options);

      /* Go on to the next one.  If option_end points to a comma, it
	 will be skipped above.  */
      options = option_end;
a353 13

static const struct mips_cp0sel_name *
lookup_mips_cp0sel_name(names, len, cp0reg, sel)
	const struct mips_cp0sel_name *names;
	unsigned int len, cp0reg, sel;
{
  unsigned int i;

  for (i = 0; i < len; i++)
    if (names[i].cp0reg == cp0reg && names[i].sel == sel)
      return &names[i];
  return NULL;
}
d355 1
a355 1
/* Print insn arguments for 32/64-bit code.  */
d358 4
a361 5
print_insn_args (d, l, pc, info)
     const char *d;
     register unsigned long int l;
     bfd_vma pc;
     struct disassemble_info *info;
d363 1
a363 6
  int op, delta;
  unsigned int lsb, msb, msbd;

  lsb = 0;

  for (; *d != '\0'; d++)
d365 98
a462 35
      switch (*d)
	{
	case ',':
	case '(':
	case ')':
	case '[':
	case ']':
	  (*info->fprintf_func) (info->stream, "%c", *d);
	  break;

	case '+':
	  /* Extension character; switch for second char.  */
	  d++;
	  switch (*d)
	    {
	    case '\0':
	      /* xgettext:c-format */
	      (*info->fprintf_func) (info->stream,
				     _("# internal error, incomplete extension sequence (+)"));
	      return;

	    case 'A':
	      lsb = (l >> OP_SH_SHAMT) & OP_MASK_SHAMT;
	      (*info->fprintf_func) (info->stream, "0x%x", lsb);
	      break;
	
	    case 'B':
	      msb = (l >> OP_SH_INSMSB) & OP_MASK_INSMSB;
	      (*info->fprintf_func) (info->stream, "0x%x", msb - lsb + 1);
	      break;

	    case 'C':
	      msbd = (l >> OP_SH_EXTMSBD) & OP_MASK_EXTMSBD;
	      (*info->fprintf_func) (info->stream, "0x%x", msbd + 1);
	      break;
d464 4
a467 287
	    case 'D':
	      {
		const struct mips_cp0sel_name *n;
		unsigned int cp0reg, sel;

		cp0reg = (l >> OP_SH_RD) & OP_MASK_RD;
		sel = (l >> OP_SH_SEL) & OP_MASK_SEL;

		/* CP0 register including 'sel' code for mtcN (et al.), to be
		   printed textually if known.  If not known, print both
		   CP0 register name and sel numerically since CP0 register
		   with sel 0 may have a name unrelated to register being
		   printed.  */
		n = lookup_mips_cp0sel_name(mips_cp0sel_names,
					    mips_cp0sel_names_len, cp0reg, sel);
		if (n != NULL)
		  (*info->fprintf_func) (info->stream, "%s", n->name);
		else
		  (*info->fprintf_func) (info->stream, "$%d,%d", cp0reg, sel);
		break;
	      }

	    default:
	      /* xgettext:c-format */
	      (*info->fprintf_func) (info->stream,
				     _("# internal error, undefined extension sequence (+%c)"),
				     *d);
	      return;
	    }
	  break;

	case 's':
	case 'b':
	case 'r':
	case 'v':
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_gpr_names[(l >> OP_SH_RS) & OP_MASK_RS]);
	  break;

	case 't':
	case 'w':
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_gpr_names[(l >> OP_SH_RT) & OP_MASK_RT]);
	  break;

	case 'i':
	case 'u':
	  (*info->fprintf_func) (info->stream, "0x%x",
				 (l >> OP_SH_IMMEDIATE) & OP_MASK_IMMEDIATE);
	  break;

	case 'j': /* Same as i, but sign-extended.  */
	case 'o':
	  delta = (l >> OP_SH_DELTA) & OP_MASK_DELTA;
	  if (delta & 0x8000)
	    delta |= ~0xffff;
	  (*info->fprintf_func) (info->stream, "%d",
				 delta);
	  break;

	case 'h':
	  (*info->fprintf_func) (info->stream, "0x%x",
				 (unsigned int) ((l >> OP_SH_PREFX)
						 & OP_MASK_PREFX));
	  break;

	case 'k':
	  (*info->fprintf_func) (info->stream, "0x%x",
				 (unsigned int) ((l >> OP_SH_CACHE)
						 & OP_MASK_CACHE));
	  break;

	case 'a':
	  info->target = (((pc + 4) & ~(bfd_vma) 0x0fffffff)
			  | (((l >> OP_SH_TARGET) & OP_MASK_TARGET) << 2));
	  (*info->print_address_func) (info->target, info);
	  break;

	case 'p':
	  /* Sign extend the displacement.  */
	  delta = (l >> OP_SH_DELTA) & OP_MASK_DELTA;
	  if (delta & 0x8000)
	    delta |= ~0xffff;
	  info->target = (delta << 2) + pc + INSNLEN;
	  (*info->print_address_func) (info->target, info);
	  break;

	case 'd':
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_gpr_names[(l >> OP_SH_RD) & OP_MASK_RD]);
	  break;

	case 'U':
	  {
	    /* First check for both rd and rt being equal.  */
	    unsigned int reg = (l >> OP_SH_RD) & OP_MASK_RD;
	    if (reg == ((l >> OP_SH_RT) & OP_MASK_RT))
	      (*info->fprintf_func) (info->stream, "%s",
				     mips_gpr_names[reg]);
	    else
	      {
		/* If one is zero use the other.  */
		if (reg == 0)
		  (*info->fprintf_func) (info->stream, "%s",
					 mips_gpr_names[(l >> OP_SH_RT) & OP_MASK_RT]);
		else if (((l >> OP_SH_RT) & OP_MASK_RT) == 0)
		  (*info->fprintf_func) (info->stream, "%s",
					 mips_gpr_names[reg]);
		else /* Bogus, result depends on processor.  */
		  (*info->fprintf_func) (info->stream, "%s or %s",
					 mips_gpr_names[reg],
					 mips_gpr_names[(l >> OP_SH_RT) & OP_MASK_RT]);
	      }
	  }
	  break;

	case 'z':
	  (*info->fprintf_func) (info->stream, "%s", mips_gpr_names[0]);
	  break;

	case '<':
	  (*info->fprintf_func) (info->stream, "0x%x",
				 (l >> OP_SH_SHAMT) & OP_MASK_SHAMT);
	  break;

	case 'c':
	  (*info->fprintf_func) (info->stream, "0x%x",
				 (l >> OP_SH_CODE) & OP_MASK_CODE);
	  break;

	case 'q':
	  (*info->fprintf_func) (info->stream, "0x%x",
				 (l >> OP_SH_CODE2) & OP_MASK_CODE2);
	  break;

	case 'C':
	  (*info->fprintf_func) (info->stream, "0x%x",
				 (l >> OP_SH_COPZ) & OP_MASK_COPZ);
	  break;

	case 'B':
	  (*info->fprintf_func) (info->stream, "0x%x",
				 (l >> OP_SH_CODE20) & OP_MASK_CODE20);
	  break;

	case 'J':
	  (*info->fprintf_func) (info->stream, "0x%x",
				 (l >> OP_SH_CODE19) & OP_MASK_CODE19);
	  break;

	case 'S':
	case 'V':
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_fpr_names[(l >> OP_SH_FS) & OP_MASK_FS]);
	  break;

	case 'T':
	case 'W':
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_fpr_names[(l >> OP_SH_FT) & OP_MASK_FT]);
	  break;

	case 'D':
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_fpr_names[(l >> OP_SH_FD) & OP_MASK_FD]);
	  break;

	case 'R':
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_fpr_names[(l >> OP_SH_FR) & OP_MASK_FR]);
	  break;

	case 'E':
	  /* Coprocessor register for lwcN instructions, et al.

	     Note that there is no load/store cp0 instructions, and
	     that FPU (cp1) instructions disassemble this field using
	     'T' format.  Therefore, until we gain understanding of
	     cp2 register names, we can simply print the register
	     numbers.  */
	  (*info->fprintf_func) (info->stream, "$%d",
				 (l >> OP_SH_RT) & OP_MASK_RT);
	  break;

	case 'G':
	  /* Coprocessor register for mtcN instructions, et al.  Note
	     that FPU (cp1) instructions disassemble this field using
	     'S' format.  Therefore, we only need to worry about cp0,
	     cp2, and cp3.  */
	  op = (l >> OP_SH_OP) & OP_MASK_OP;
	  if (op == OP_OP_COP0)
	    (*info->fprintf_func) (info->stream, "%s",
				   mips_cp0_names[(l >> OP_SH_RD) & OP_MASK_RD]);
	  else
	    (*info->fprintf_func) (info->stream, "$%d",
				   (l >> OP_SH_RD) & OP_MASK_RD);
	  break;

	case 'K':
	  (*info->fprintf_func) (info->stream, "%s",
				 mips_hwr_names[(l >> OP_SH_RD) & OP_MASK_RD]);
	  break;

	case 'N':
	  (*info->fprintf_func) (info->stream, "$fcc%d",
				 (l >> OP_SH_BCC) & OP_MASK_BCC);
	  break;

	case 'M':
	  (*info->fprintf_func) (info->stream, "$fcc%d",
				 (l >> OP_SH_CCC) & OP_MASK_CCC);
	  break;

	case 'P':
	  (*info->fprintf_func) (info->stream, "%d",
				 (l >> OP_SH_PERFREG) & OP_MASK_PERFREG);
	  break;

	case 'e':
	  (*info->fprintf_func) (info->stream, "%d",
				 (l >> OP_SH_VECBYTE) & OP_MASK_VECBYTE);
	  break;

	case '%':
	  (*info->fprintf_func) (info->stream, "%d",
				 (l >> OP_SH_VECALIGN) & OP_MASK_VECALIGN);
	  break;

	case 'H':
	  (*info->fprintf_func) (info->stream, "%d",
				 (l >> OP_SH_SEL) & OP_MASK_SEL);
	  break;

	case 'O':
	  (*info->fprintf_func) (info->stream, "%d",
				 (l >> OP_SH_ALN) & OP_MASK_ALN);
	  break;

	case 'Q':
	  {
	    unsigned int vsel = (l >> OP_SH_VSEL) & OP_MASK_VSEL;
	    if ((vsel & 0x10) == 0)
	      {
		int fmt;
		vsel &= 0x0f;
		for (fmt = 0; fmt < 3; fmt++, vsel >>= 1)
		  if ((vsel & 1) == 0)
		    break;
		(*info->fprintf_func) (info->stream, "$v%d[%d]",
				       (l >> OP_SH_FT) & OP_MASK_FT,
				       vsel >> 1);
	      }
	    else if ((vsel & 0x08) == 0)
	      {
		(*info->fprintf_func) (info->stream, "$v%d",
				       (l >> OP_SH_FT) & OP_MASK_FT);
	      }
	    else
	      {
		(*info->fprintf_func) (info->stream, "0x%x",
				       (l >> OP_SH_FT) & OP_MASK_FT);
	      }
	  }
	  break;

	case 'X':
	  (*info->fprintf_func) (info->stream, "$v%d",
				 (l >> OP_SH_FD) & OP_MASK_FD);
	  break;

	case 'Y':
	  (*info->fprintf_func) (info->stream, "$v%d",
				 (l >> OP_SH_FS) & OP_MASK_FS);
	  break;

	case 'Z':
	  (*info->fprintf_func) (info->stream, "$v%d",
				 (l >> OP_SH_FT) & OP_MASK_FT);
	  break;

	default:
	  /* xgettext:c-format */
	  (*info->fprintf_func) (info->stream,
				 _("# internal error, undefined modifier(%c)"),
				 *d);
	  return;
	}
d470 1
a470 1

d500 1
d526 9
d554 1
a554 1
	      if (! OPCODE_IS_MEMBER (op, mips_isa, mips_processor)
d586 2
a587 1
		  print_insn_args (d, word, memaddr, info);
a615 3
  set_default_mips_dis_options (info);
  parse_mips_dis_options (info->disassembler_options);

d632 12
d882 1
a882 1
      (*info->fprintf_func) (info->stream, "%s", mips_gpr_names[0]);
d886 1
a886 1
      (*info->fprintf_func) (info->stream, "%s", mips_gpr_names[29]);
d894 1
a894 1
      (*info->fprintf_func) (info->stream, "%s", mips_gpr_names[31]);
d899 2
a900 2
			     mips_gpr_names[((l >> MIPS16OP_SH_REGR32)
					    & MIPS16OP_MASK_REGR32)]);
d905 1
a905 1
			     mips_gpr_names[MIPS16OP_EXTRACT_REG32R (l)]);
d1188 1
a1188 1
	    (*info->fprintf_func) (info->stream, "%s", mips_gpr_names[4]);
d1191 1
a1191 1
				     mips_gpr_names[amask + 3]);
d1206 1
a1206 1
				   mips_gpr_names[16]);
d1209 1
a1209 1
				     mips_gpr_names[smask + 15]);
d1217 1
a1217 1
				   mips_gpr_names[31]);
a1238 54
}

void
print_mips_disassembler_options (stream)
     FILE *stream;
{
  int i;

  fprintf (stream, _("\n\
The following MIPS specific disassembler options are supported for use\n\
with the -M switch (multiple options should be separated by commas):\n"));

  fprintf (stream, _("\n\
  gpr-names=ABI            Print GPR names according to  specified ABI.\n\
                           Default: based on binary being disassembled.\n"));

  fprintf (stream, _("\n\
  fpr-names=ABI            Print FPR names according to specified ABI.\n\
                           Default: numeric.\n"));

  fprintf (stream, _("\n\
  cp0-names=ARCH           Print CP0 register names according to\n\
                           specified architecture.\n\
                           Default: based on binary being disassembled.\n"));

  fprintf (stream, _("\n\
  hwr-names=ARCH           Print HWR names according to specified \n\
			   architecture.\n\
                           Default: based on binary being disassembled.\n"));

  fprintf (stream, _("\n\
  reg-names=ABI            Print GPR and FPR names according to\n\
                           specified ABI.\n"));

  fprintf (stream, _("\n\
  reg-names=ARCH           Print CP0 register and HWR names according to\n\
                           specified architecture.\n"));

  fprintf (stream, _("\n\
  For the options above, the following values are supported for \"ABI\":\n\
   "));
  for (i = 0; mips_abi_choices[i].name != NULL; i++)
    fprintf (stream, " %s", mips_abi_choices[i].name);
  fprintf (stream, _("\n"));

  fprintf (stream, _("\n\
  For the options above, The following values are supported for \"ARCH\":\n\
   "));
  for (i = 0; mips_arch_choices[i].name != NULL; i++)
    if (*mips_arch_choices[i].name != '\0')
      fprintf (stream, " %s", mips_arch_choices[i].name);
  fprintf (stream, _("\n"));

  fprintf (stream, _("\n"));
@


1.32.6.5
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d1761 1
a1761 1
  unsigned int i;
d1796 1
a1796 1
  for (i = 0; i < ARRAY_SIZE (mips_abi_choices); i++)
d1803 1
a1803 1
  for (i = 0; i < ARRAY_SIZE (mips_arch_choices); i++)
@


1.32.6.6
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a349 4
  { "rm7000",	1, bfd_mach_mips7000, CPU_RM7000, ISA_MIPS4,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
  { "rm9000",	1, bfd_mach_mips7000, CPU_RM7000, ISA_MIPS4,
    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
d498 1
a498 1
  if (info->flavour == bfd_target_elf_flavour && info->section != NULL)
d502 1
a502 1
      header = elf_elfheader (info->section->owner);
@


1.32.6.7
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a386 6
  { "mips64r2",	1, bfd_mach_mipsisa64r2, CPU_MIPS64R2,
    ISA_MIPS64R2 | INSN_MIPS16 | INSN_MIPS3D | INSN_MDMX,
    mips_cp0_names_mips3264r2,
    mips_cp0sel_names_mips3264r2, ARRAY_SIZE (mips_cp0sel_names_mips3264r2),
    mips_hwr_names_mips3264r2 },

a716 1
	    case 'H':
a741 15

	    case 'E':
	      lsb = ((l >> OP_SH_SHAMT) & OP_MASK_SHAMT) + 32;
	      (*info->fprintf_func) (info->stream, "0x%x", lsb);
	      break;
	
	    case 'F':
	      msb = ((l >> OP_SH_INSMSB) & OP_MASK_INSMSB) + 32;
	      (*info->fprintf_func) (info->stream, "0x%x", msb - lsb + 1);
	      break;

	    case 'G':
	      msbd = ((l >> OP_SH_EXTMSBD) & OP_MASK_EXTMSBD) + 32;
	      (*info->fprintf_func) (info->stream, "0x%x", msbd + 1);
	      break;
@


1.31
log
@	* config/tc-mips.c (macro_build): Handle MIPS16 insns.
	(mips_ip): Likewise.
	* mips.h (INSN_MIPS16): New define.
	* mips-dis.c (mips_isa_type): Add MIPS16 insn handling.
	* mips-opc.c (I16): New define.
	(mips_builtin_opcodes): Make jalx an I16 insn.
@
text
@d598 1
a598 1
  if (info->mach == 16
@


1.30
log
@[ gas/ChangeLog ]
2002-05-30  Chris G. Demetriou  <cgd@@broadcom.com>
            Ed Satterthwaite  <ehs@@broadcom.com>

	* config/tc-mips.c (mips_set_options): New "ase_mdmx" member.
	(mips_opts): Initialize "ase_mdmx" member.
	(file_ase_mdmx): New variable.
	(CPU_HAS_MDMX): New macro.
	(md_begin): Initialize mips_opts.ase_mdmx and file_ase_mdmx
	based on command line options and configuration defaults.
	(macro_build): Note in comment that use of MDMX in macros is
	not currently allowed.
	(validate_mips_insn): Add support for the "O", "Q", "X", "Y", and
	"Z" MDMX operand types.
	(mips_ip): Accept MDMX instructions if mips_opts.ase_mdmx is set,
	and add support for the "O", "Q", "X", "Y", and "Z" MDMX operand
	types.
	(OPTION_MDMX, OPTION_NO_MDMX, md_longopts, md_parse_option):
	Add support for "-mdmx" and "-no-mdmx" options.
	(OPTION_ELF_BASE): Move to accomodate new options.
	(s_mipsset): Support ".set mdmx" and ".set nomdmx".
	(mips_elf_final_processing): Set MDMX ASE ELF header flag if
	file_ase_mdmx was set.
	* doc/as.texinfo: Document -mdmx and -no-mdmx options.
	* doc/c-mips.texi: Likewise, and document ".set mdmx" and ".set
	nomdmx" directives.

[ gas/testsuite/ChangeLog ]
2002-05-30  Chris G. Demetriou  <cgd@@broadcom.com>

	* gas/mips/mips64-mdmx.s: New file.
	* gas/mips/mips64-mdmx.d: Likewise.
	* gas/mips/mips.exp: Run new "mips64-mdmx" test.

[ include/opcode/ChangeLog ]
2002-05-30  Chris G. Demetriou  <cgd@@broadcom.com>

	* mips.h (OP_SH_ALN, OP_MASK_ALN, OP_SH_VSEL, OP_MASK_VSEL)
	(MDMX_FMTSEL_IMM_QH, MDMX_FMTSEL_IMM_OB, MDMX_FMTSEL_VEC_QH)
	(MDMX_FMTSEL_VEC_OB, INSN_READ_MDMX_ACC, INSN_WRITE_MDMX_ACC)
	(INSN_MDMX): New constants, for MDMX support.
	(opcode character list): Add "O", "Q", "X", "Y", and "Z" for MDMX.

[ opcodes/ChangeLog ]
2002-05-30  Chris G. Demetriou  <cgd@@broadcom.com>
            Ed Satterthwaite  <ehs@@broadcom.com>

	* mips-dis.c (print_insn_arg): Add support for 'O', 'Q', 'X', 'Y',
	and 'Z' formats, for MDMX.
        (mips_isa_type): Add MDMX instructions to the ISA
	bit mask for bfd_mach_mipsisa64.
	* mips-opc.c: Add support for MDMX instructions.
	(MX): New definition.

	* mips-dis.c: Update copyright years to include 2002.
@
text
@d415 1
a415 1
      *isa = ISA_MIPS3;
d432 1
a432 1
      *isa = ISA_MIPS32;
d437 1
a437 1
      *isa = ISA_MIPS64 | INSN_MDMX | INSN_MIPS3D;
@


1.29
log
@	* mips-dis.c (is_newabi): EABI is not a NewABI.
@
text
@d287 47
d428 2
a429 2
	 Note that MIPS-3D is not applicable to MIPS32.  (See _MIPS32
	 Architecture For Programmers Volume I: Introduction to the
d437 1
a437 1
      *isa = ISA_MIPS64 | INSN_MIPS3D;
@


1.29.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@a286 47
    case 'O':
      (*info->fprintf_func) (info->stream, "%d",
			     (l >> OP_SH_ALN) & OP_MASK_ALN);
      break;

    case 'Q':
      {
	unsigned int vsel = (l >> OP_SH_VSEL) & OP_MASK_VSEL;
	if ((vsel & 0x10) == 0)
	  {
	    int fmt;
	    vsel &= 0x0f;
	    for (fmt = 0; fmt < 3; fmt++, vsel >>= 1)
	      if ((vsel & 1) == 0)
		break;
	    (*info->fprintf_func) (info->stream, "$v%d[%d]",
				   (l >> OP_SH_FT) & OP_MASK_FT, 
				   vsel >> 1);
	  }
	else if ((vsel & 0x08) == 0)
	  {
	    (*info->fprintf_func) (info->stream, "$v%d",
				   (l >> OP_SH_FT) & OP_MASK_FT);
	  }
	else
	  {
	    (*info->fprintf_func) (info->stream, "0x%x",
				   (l >> OP_SH_FT) & OP_MASK_FT);
	  }
      }
      break;

    case 'X':
      (*info->fprintf_func) (info->stream, "$v%d",
			     (l >> OP_SH_FD) & OP_MASK_FD);
      break;

    case 'Y':
      (*info->fprintf_func) (info->stream, "$v%d",
			     (l >> OP_SH_FS) & OP_MASK_FS);
      break;

    case 'Z':
      (*info->fprintf_func) (info->stream, "$v%d",
			     (l >> OP_SH_FT) & OP_MASK_FT);
      break;

d381 2
a382 2
	 Note that MIPS-3D and MDMX are not applicable to MIPS32.  (See
	 _MIPS32 Architecture For Programmers Volume I: Introduction to the
d390 1
a390 1
      *isa = ISA_MIPS64 | INSN_MDMX | INSN_MIPS3D;
@


1.29.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d415 1
a415 1
      *isa = ISA_MIPS3 | INSN_MIPS16;
d432 1
a432 1
      *isa = ISA_MIPS32 | INSN_MIPS16;
d437 1
a437 1
      *isa = ISA_MIPS64 | INSN_MIPS16 | INSN_MIPS3D | INSN_MDMX;
@


1.29.2.3
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a112 2
    case '[':
    case ']':
a281 10
    case 'e':
      (*info->fprintf_func) (info->stream, "%d",
			     (l >> OP_SH_VECBYTE) & OP_MASK_VECBYTE);
      break;

    case '%':
      (*info->fprintf_func) (info->stream, "%d",
			     (l >> OP_SH_VECALIGN) & OP_MASK_VECALIGN);
      break;

a376 4
    case bfd_mach_mips4120:
      *cputype = CPU_VR4120;
      *isa = ISA_MIPS3;
      break;
a396 8
    case bfd_mach_mips5400:
      *cputype = CPU_VR5400;
      *isa = ISA_MIPS4;
      break;
    case bfd_mach_mips5500:
      *cputype = CPU_VR5500;
      *isa = ISA_MIPS4;
      break;
d529 1
a529 3
	      /* We always allow to disassemble the jalx instruction.  */
	      if (! OPCODE_IS_MEMBER (op, mips_isa, target_processor)
		  && strcmp (op->name, "jalx"))
d598 1
a598 1
  if (info->mach == bfd_mach_mips16
@


1.28
log
@2002-03-15  Chris G. Demetriou  <cgd@@broadcom.com>

        * mips-dis.c: Update copyright years.
@
text
@d410 2
a411 4
  /* If a 32-bit ELF file, N32, EABI32, and EABI64 are new-style ABIs.  */
  if ((header->e_flags & EF_MIPS_ABI2) != 0
      || (header->e_flags & EF_MIPS_ABI) == E_MIPS_ABI_EABI32
      || (header->e_flags & EF_MIPS_ABI) == E_MIPS_ABI_EABI64)
@


1.28.4.1
log
@merge from trunk
@
text
@a286 47
    case 'O':
      (*info->fprintf_func) (info->stream, "%d",
			     (l >> OP_SH_ALN) & OP_MASK_ALN);
      break;

    case 'Q':
      {
	unsigned int vsel = (l >> OP_SH_VSEL) & OP_MASK_VSEL;
	if ((vsel & 0x10) == 0)
	  {
	    int fmt;
	    vsel &= 0x0f;
	    for (fmt = 0; fmt < 3; fmt++, vsel >>= 1)
	      if ((vsel & 1) == 0)
		break;
	    (*info->fprintf_func) (info->stream, "$v%d[%d]",
				   (l >> OP_SH_FT) & OP_MASK_FT, 
				   vsel >> 1);
	  }
	else if ((vsel & 0x08) == 0)
	  {
	    (*info->fprintf_func) (info->stream, "$v%d",
				   (l >> OP_SH_FT) & OP_MASK_FT);
	  }
	else
	  {
	    (*info->fprintf_func) (info->stream, "0x%x",
				   (l >> OP_SH_FT) & OP_MASK_FT);
	  }
      }
      break;

    case 'X':
      (*info->fprintf_func) (info->stream, "$v%d",
			     (l >> OP_SH_FD) & OP_MASK_FD);
      break;

    case 'Y':
      (*info->fprintf_func) (info->stream, "$v%d",
			     (l >> OP_SH_FS) & OP_MASK_FS);
      break;

    case 'Z':
      (*info->fprintf_func) (info->stream, "$v%d",
			     (l >> OP_SH_FT) & OP_MASK_FT);
      break;

d381 2
a382 2
	 Note that MIPS-3D and MDMX are not applicable to MIPS32.  (See
	 _MIPS32 Architecture For Programmers Volume I: Introduction to the
d390 1
a390 1
      *isa = ISA_MIPS64 | INSN_MDMX | INSN_MIPS3D;
d410 4
a413 2
  /* If a 32-bit ELF file, n32 is a new-style ABI.  */
  if ((header->e_flags & EF_MIPS_ABI2) != 0)
@


1.27
log
@[ gas/ChangeLog ]
2002-03-15  Chris G. Demetriou  <cgd@@broadcom.com>

	* config/tc-mips.c (mips_set_options): New "ase_mips3d" member.
	(mips_opts): Initialize "ase_mips3d" member.
	(file_ase_mips3d): New variable.
	(CPU_HAS_MIPS3D): New macro.
	(md_begin): Initialize mips_opts.ase_mips3d and file_ase_mips3d
	based on command line options and configuration defaults.
	(macro_build, mips_ip): Accept MIPS-3D instructions if
	mips_opts.ase_mips3d is set.
	(OPTION_MIPS3D, OPTION_NO_MIPS3D, md_longopts, md_parse_option):
	Add support for "-mips3d" and "-no-mips3d" options.
	(OPTION_ELF_BASE): Move to accomodate new options.
	(s_mipsset): Support ".set mips3d" and ".set nomips3d".
	(mips_elf_final_processing): Add a comment indicating that a
	MIPS-3D ASE ELF header flag should be set, when one exists.
	* doc/as.texinfo: Document -mips3d and -no-mips3d options.
	* doc/c-mips.texi: Likewise, and document ".set mips3d" and ".set
	nomips3d" directives.

[ gas/testsuite/ChangeLog ]
2002-03-15  Chris G. Demetriou  <cgd@@broadcom.com>

	* gas/mips/mips64-mips3d.s: New file.
	* gas/mips/mips64-mips3d.d: Likewise.
	* gas/mips/mips.exp: Run new "mips64-mips3d" test.

[ include/opcode/ChangeLog ]
2002-03-15  Chris G. Demetriou  <cgd@@broadcom.com>

	* mips.h (INSN_MIPS3D): New definition used to mark MIPS-3D
	instructions.
	(OPCODE_IS_MEMBER): Adjust comments to indicate that ASE bit masks
	may be passed along with the ISA bitmask.

[ opcodes/ChangeLog ]
2002-03-15  Chris G. Demetriou  <cgd@@broadcom.com>

	* mips-dis.c (mips_isa_type): Add MIPS3D instructions to the ISA
	bit masks for bfd_mach_mips_sb1 and bfd_mach_mipsisa64.  Add
	comments for bfd_mach_mipsisa32 and bfd_mach_mipsisa64 that
	indicate that they should dissassemble all applicable
	MIPS-specified ASEs.
	* mips-opc.c: Add support for MIPS-3D instructions.
	(M3D): New definition.

	* mips-opc.c: Update copyright years.
@
text
@d3 1
a3 1
   2000, 2001
@


1.26
log
@2002-03-15  Chris Demetriou  <cgd@@broadcom.com>

        * mips-dis.c (is_newabi): Fix ABI decoding.
@
text
@d376 1
a376 1
      *isa = ISA_MIPS64 | INSN_SB1;
d380 5
d389 2
a390 1
      *isa = ISA_MIPS64;
@


1.25
log
@2002-03-14  Chris G. Demetriou  <cgd@@broadcom.com>

        * mips-dis.c (mips_isa_type): Fix formatting of bfd_mach_mipsisa32
        and bfd_mach_mipsisa64 cases to match the rest.
@
text
@d400 8
a407 4
  if ((header->e_flags
       & (E_MIPS_ABI_EABI32 | E_MIPS_ABI_EABI64 | EF_MIPS_ABI2)) != 0
      || (header->e_ident[EI_CLASS] == ELFCLASS64
	  && (header->e_flags & E_MIPS_ABI_O64) == 0))
@


1.24
log
@2001-11-04  Chris Demetriou  <cgd@@broadcom.com>

        * mips-dis.c (print_insn_mips): Remove spaces at end of line.
@
text
@d379 2
a380 2
      * cputype = CPU_MIPS32;
      * isa = ISA_MIPS32;
d383 2
a384 2
      * cputype = CPU_MIPS64;
      * isa = ISA_MIPS64;
@


1.24.2.1
log
@2002-04-29  Chris Demetriou  <cgd@@broadcom.com>

        Merge from mainline:
        2002-03-06  Chris Demetriou  <cgd@@broadcom.com>
        * mips-opc.c (mips_builtin_opcodes): Mark "pref" as being
        present on I4.

        Merge from mainline:
        2002-03-06  Chris Demetriou  <cgd@@broadcom.com>
        * mips-opc.c (mips_builtin_opcodes): Add "movn.ps" and "movz.ps".

        Merge from mainline:
        2002-03-15  Chris Demetriou  <cgd@@broadcom.com>
        * mips-dis.c (is_newabi): Fix ABI decoding.
@
text
@d400 4
a403 8
  /* There are no old-style ABIs which use 64-bit ELF.  */
  if (header->e_ident[EI_CLASS] == ELFCLASS64)
    return 1;

  /* If a 32-bit ELF file, N32, EABI32, and EABI64 are new-style ABIs.  */
  if ((header->e_flags & EF_MIPS_ABI2) != 0
      || (header->e_flags & EF_MIPS_ABI) == E_MIPS_ABI_EABI32
      || (header->e_flags & EF_MIPS_ABI) == E_MIPS_ABI_EABI64)
@


1.24.4.1
log
@Import 2002-03-11 Chris Demetriou <cgd@@broadcom.com>
* mips-dis.c (is_newabi): Fix ABI decoding.
@
text
@d400 4
a403 8
  /* There are no old-style ABIs which use 64-bit ELF.  */
  if (header->e_ident[EI_CLASS] == ELFCLASS64)
    return 1;

  /* If a 32-bit ELF file, N32, EABI32, and EABI64 are new-style ABIs.  */
  if ((header->e_flags & EF_MIPS_ABI2) != 0
      || (header->e_flags & EF_MIPS_ABI) == E_MIPS_ABI_EABI32
      || (header->e_flags & EF_MIPS_ABI) == E_MIPS_ABI_EABI64)
@


1.23
log
@
[opcodes/ChangeLog]

2001-10-21  Chris Demetriou  <cgd@@broadcom.com>

        * mips-opc.c (mips_builtin_opcodes): Mark "bgezall" and
        "bltzall" as writing GPR 31 (since they do).

        * mips-dis.c (print_insn_arg): Calculate info->target
        where appropriate.
        (print_insn_mips): Fill in instruction info.
        (print_mips16_insn_arg): Remove unneded variable 'val'.
        Removed duplicated instruction target calculations,
        calculate once and print that result.  Use same idiom for
        masking the jump segment bits as is used in print_insn_arg.

[gas/testsuite/ChangeLog]

2001-10-21  Chris Demetriou  <cgd@@broadcom.com>

        * gas/mips/beq.s: Add zero words at end of instructions so
        that objdump will print "..." when disassembling.
        * gas/mips/beq.d: Update for disassembler changes which force
        branch delay-slot nops to be printed.
        * gas/mips/bge.d: Ditto.
        * gas/mips/bgeu.d: Ditto.
        * gas/mips/blt.d: Ditto.
        * gas/mips/bltu.d: Ditto.
        * gas/mips/jal-svr4pic.d: Ditto.
        * gas/mips/jal-xgot.d: Ditto.
@
text
@d460 1
a460 1
  info->data_size = 0;      
@


1.22
log
@[gas/testsuite/ChangeLog]
2001-10-17  Chris Demetriou  <cgd@@broadcom.com>

        * gas/mips/mips.exp (sb1-ext-ps): New test to test
        SB-1 core's paired-single extensions to the MIPS64 ISA.
        * gas/mips/sb1-ext-ps.d: New file.
        * gas/mips/sb1-ext-ps.s: New file.

[include/opcode/ChangeLog]
2001-10-17  Chris Demetriou  <cgd@@broadcom.com>

        * mips.h (INSN_SB1): New cpu-specific instruction bit.
        (OPCODE_IS_MEMBER): Allow instructions matching INSN_SB1
        if cpu is CPU_SB1.

[opcodes/ChangeLog]
2001-10-17  Chris Demetriou  <cgd@@broadcom.com>

        * mips-dis.c (mips_isa_type): Make the ISA used to disassemble
        SB-1 binaries include instructions specific to the SB-1.
        * mips-opc.c (SB1): New definition.
        (mips_builtin_opcodes): Add SB-1 extension opcodes "div.ps",
        "recip.ps", "rsqrt.ps", and "sqrt.ps".
@
text
@d158 3
a160 4
      (*info->print_address_func)
	((((pc + 4) & ~(bfd_vma) 0x0fffffff)
	  | (((l >> OP_SH_TARGET) & OP_MASK_TARGET) << 2)),
	 info);
d168 2
a169 3
      (*info->print_address_func)
	((delta << 2) + pc + INSNLEN,
	 info);
d458 6
d477 22
d515 1
a1035 1
	    bfd_vma val;
d1078 2
a1079 3
	    val = (baseaddr & ~((1 << shift) - 1)) + immed;
	    (*info->print_address_func) (val, info);
	    info->target = val;
d1088 2
a1089 1
      (*info->print_address_func) (((memaddr + 4) & 0xf0000000) | l, info);
a1090 1
      info->target = ((memaddr + 4) & 0xf0000000) | l;
@


1.21
log
@2001-08-31  Eric Christopher  <echristo@@redhat.com>
	    Jason Eckhardt    <jle@@redhat.com>

	* mips-dis.c: Add support for bfd_mach_mipsisa32 and
	bfd_mach_mipsisa64. Remove bfd_mach_mips32, bfd_mach_mips32_4k,
	bfd_mach_mips64.
@
text
@d378 1
a378 1
      *isa = ISA_MIPS64;
@


1.20
log
@	* i960-dis.c: Add parameters for prototypes
	(ctrl): Add unused attributes.
	(cobr): Likewise.
	(put_abs): Likewise.

	* mips-dis.c: Add missing prototypes.
	* a29k-dis.c: Likewise.
	* arc-dis.c: Likewise.
	* ia64-opc.c: Likewise.

	* s390-dis.c: Add missing prototypes.
	(init_disasm): Remove unused attribute since the parameter is
	used.
@
text
@a371 8
    case bfd_mach_mips32:
      *cputype = CPU_MIPS32;
      *isa = ISA_MIPS32;
      break;
    case bfd_mach_mips32_4k:
      *cputype = CPU_MIPS32_4K;
      *isa = ISA_MIPS32;
      break;
a375 4
    case bfd_mach_mips64:
      *cputype = CPU_MIPS64;
      *isa = ISA_MIPS64;
      break;
d380 9
@


1.19
log
@	* mcore-dis.c: Fix formatting.
	* mips-dis.c: Likewise.
	* pj-dis.c: Likewise.
	* z8k-dis.c: Likewise.
@
text
@d48 2
d52 2
@


1.18
log
@	* mips-dis.c (print_insn_mips): Remove OPCODE_IS_MEMBER's gp32
	argument.
	* mips-opc.c (G6): Undefine.
	(mips_builtin_opcodes): Remove gp32 entry for "move".  Add macro
	as the first "move" alternative.
@
text
@d31 1
a31 1
   system as when it is used for disassembler support in a monitor. */
d57 1
a57 2
static const char * const mips16_reg_names[] =
{
d61 1
a61 2
static const char * const mips32_reg_names[] =
{
d75 1
a75 2
static const char * const mips64_reg_names[] =
{
d93 1
a93 1
/* Print insn arguments for 32/64-bit code */
d129 1
a129 1
			(l >> OP_SH_IMMEDIATE) & OP_MASK_IMMEDIATE);
d132 1
a132 1
    case 'j': /* same as i, but sign-extended */
d155 1
a155 1
	((((pc + 4) & ~ (bfd_vma) 0x0fffffff)
d161 1
a161 1
      /* sign extend the displacement */
d177 19
a195 19
      /* First check for both rd and rt being equal. */
      unsigned int reg = (l >> OP_SH_RD) & OP_MASK_RD;
      if (reg == ((l >> OP_SH_RT) & OP_MASK_RT))
        (*info->fprintf_func) (info->stream, "%s",
                               reg_names[reg]);
      else
        {
          /* If one is zero use the other. */
          if (reg == 0)
            (*info->fprintf_func) (info->stream, "%s",
                                   reg_names[(l >> OP_SH_RT) & OP_MASK_RT]);
          else if (((l >> OP_SH_RT) & OP_MASK_RT) == 0)
            (*info->fprintf_func) (info->stream, "%s",
                                   reg_names[reg]);
          else /* Bogus, result depends on processor. */
            (*info->fprintf_func) (info->stream, "%s or %s",
                                   reg_names[reg],
                                   reg_names[(l >> OP_SH_RT) & OP_MASK_RT]);
          }
d294 1
a294 1
/* Figure out the MIPS ISA and CPU based on the machine number. */
d398 1
a398 1
is_newabi(header)
d443 1
a443 1
        }
d477 1
a477 1
		    (*info->fprintf_func) (info->stream, "\t");
d479 1
a479 1
		      print_insn_arg (d, word, memaddr, info);
d530 2
a531 2
      header = elf_elfheader(bfd_asymbol_bfd(*(info->symbols)));
      if (is_newabi(header))
d541 1
a541 1
        insn = (unsigned long) bfd_getb32 (buffer);
d791 1
a791 1
					& MIPS16OP_MASK_REGR32)]);
d1051 1
a1051 1
	    val = (baseaddr & ~ ((1 << shift) - 1)) + immed;
@


1.17
log
@
	* mips-dis.c (print_insn_arg): Don't use software integer registers
	for coprocessor registers.
	(_print_insn_mips): Get distinction between old ABI and new ABI right.
@
text
@d472 1
a472 1
	      if (! OPCODE_IS_MEMBER (op, mips_isa, target_processor, 0))
@


1.16
log
@Add MIPS r12k support
@
text
@d259 2
a260 2
      (*info->fprintf_func) (info->stream, "%s",
			     reg_names[(l >> OP_SH_RT) & OP_MASK_RT]);
d264 2
a265 2
      (*info->fprintf_func) (info->stream, "%s",
			     reg_names[(l >> OP_SH_RD) & OP_MASK_RD]);
d398 1
a398 1
/* Figure out ISA from disassemble_info data */
d401 2
a402 2
get_mips_isa (info)
     struct disassemble_info *info;
d404 5
a408 2
  int isa;
  int cpu;
d410 1
a410 2
  mips_isa_type (info->mach, &isa, &cpu);
  return isa;
d527 10
a536 8
  if (info->flavour == bfd_target_elf_flavour
      && info->symbols != NULL
      && (((get_mips_isa(info) | INSN_ISA_MASK) & ISA_MIPS2) != 0)
      && ((elf_elfheader (bfd_asymbol_bfd(*(info->symbols)))->e_flags
	   & EF_MIPS_ABI2) != 0))
    reg_names = mips64_reg_names;
  else
    reg_names = mips32_reg_names;
@


1.15
log
@Fix MIPS disassembler so that it produces reassemblable code.
@
text
@d363 4
@


1.14
log
@Remove extraneous whitespace
@
text
@d39 11
a49 1
static int print_insn_mips16 PARAMS ((bfd_vma, struct disassemble_info *));
a52 9

/* Mips instructions are never longer than this many bytes.  */
#define MAXLEN 4

static void print_insn_arg PARAMS ((const char *, unsigned long, bfd_vma,
				    struct disassemble_info *));
static int _print_insn_mips PARAMS ((bfd_vma, unsigned long int,
				     struct disassemble_info *));

d54 1
a54 16
/* FIXME: This should be shared with gdb somehow.  */
#define STD_REGISTER_NAMES 	\
    {	"zero",	"at",	"v0",	"v1",	"a0",	"a1",	"a2",	"a3", \
	"t0",	"t1",	"t2",	"t3",	"t4",	"t5",	"t6",	"t7", \
	"s0",	"s1",	"s2",	"s3",	"s4",	"s5",	"s6",	"s7", \
	"t8",	"t9",	"k0",	"k1",	"gp",	"sp",	"s8",	"ra", \
	"sr",	"lo",	"hi",	"bad",	"cause","pc",    \
	"f0",   "f1",   "f2",   "f3",   "f4",   "f5",   "f6",   "f7", \
	"f8",   "f9",   "f10",  "f11",  "f12",  "f13",  "f14",  "f15", \
	"f16",  "f17",  "f18",  "f19",  "f20",  "f21",  "f22",  "f23",\
	"f24",  "f25",  "f26",  "f27",  "f28",  "f29",  "f30",  "f31",\
	"fsr",  "fir",  "fp",   "inx",  "rand", "tlblo","ctxt", "tlbhi",\
	"epc",  "prid"\
    }

static CONST char * CONST std_reg_names[] = STD_REGISTER_NAMES;
d62 31
a92 1
/* Scalar register names. set_mips_isa_type() decides which register name
d94 1
a94 1
static CONST char * CONST *reg_names = NULL;
d96 2
a97 1
/* subroutine */
d119 1
a119 1
      (*info->fprintf_func) (info->stream, "$%s",
d125 1
a125 1
      (*info->fprintf_func) (info->stream, "$%s",
d169 1
a169 1
	((delta << 2) + pc + 4,
d174 1
a174 1
      (*info->fprintf_func) (info->stream, "$%s",
d181 1
a181 1
      int reg = (l >> OP_SH_RD) & OP_MASK_RD;
d183 1
a183 1
        (*info->fprintf_func) (info->stream, "$%s",
d189 1
a189 1
            (*info->fprintf_func) (info->stream, "$%s",
d192 1
a192 1
            (*info->fprintf_func) (info->stream, "$%s",
d195 1
a195 1
            (*info->fprintf_func) (info->stream, "$%s or $%s",
d203 1
a203 1
      (*info->fprintf_func) (info->stream, "$%s", reg_names[0]);
d259 2
a260 2
      (*info->fprintf_func) (info->stream, "$%d",
			     (l >> OP_SH_RT) & OP_MASK_RT);
d264 2
a265 2
      (*info->fprintf_func) (info->stream, "$%d",
			     (l >> OP_SH_RD) & OP_MASK_RD);
d297 1
a297 4
#if SYMTAB_AVAILABLE

/* Figure out the MIPS ISA and CPU based on the machine number.
   FIXME: What does this have to do with SYMTAB_AVAILABLE?  */
d300 1
a300 1
set_mips_isa_type (mach, isa, cputype)
a304 6
  int target_processor = CPU_UNKNOWN;
  int mips_isa = ISA_UNKNOWN;

  /* Use standard MIPS register names by default.  */
  reg_names = std_reg_names;

d308 2
a309 2
      target_processor = CPU_R3000;
      mips_isa = ISA_MIPS1;
d312 2
a313 2
      target_processor = CPU_R3900;
      mips_isa = ISA_MIPS1;
d316 2
a317 2
      target_processor = CPU_R4000;
      mips_isa = ISA_MIPS3;
d320 2
a321 2
      target_processor = CPU_R4010;
      mips_isa = ISA_MIPS2;
d324 2
a325 2
      target_processor = CPU_VR4100;
      mips_isa = ISA_MIPS3;
d328 2
a329 2
      target_processor = CPU_VR4100; /* FIXME: Shouldn't this be CPU_R4111 ??? */
      mips_isa = ISA_MIPS3;
d332 2
a333 2
      target_processor = CPU_R4300;
      mips_isa = ISA_MIPS3;
d336 2
a337 2
      target_processor = CPU_R4400;
      mips_isa = ISA_MIPS3;
d340 2
a341 2
      target_processor = CPU_R4600;
      mips_isa = ISA_MIPS3;
d344 2
a345 2
      target_processor = CPU_R4650;
      mips_isa = ISA_MIPS3;
d348 2
a349 2
      target_processor = CPU_R5000;
      mips_isa = ISA_MIPS4;
d352 2
a353 2
      target_processor = CPU_R6000;
      mips_isa = ISA_MIPS2;
d356 2
a357 2
      target_processor = CPU_R8000;
      mips_isa = ISA_MIPS4;
d360 2
a361 2
      target_processor = CPU_R10000;
      mips_isa = ISA_MIPS4;
d364 2
a365 2
      target_processor = CPU_MIPS16;
      mips_isa = ISA_MIPS3;
d368 2
a369 2
      target_processor = CPU_MIPS32;
      mips_isa = ISA_MIPS32;
d372 2
a373 2
      target_processor = CPU_MIPS32_4K;
      mips_isa = ISA_MIPS32;
d376 2
a377 2
      target_processor = CPU_MIPS5;
      mips_isa = ISA_MIPS5;
d380 2
a381 2
      target_processor = CPU_MIPS64;
      mips_isa = ISA_MIPS64;
d384 2
a385 2
      target_processor = CPU_SB1;
      mips_isa = ISA_MIPS64;
d388 2
a389 2
      target_processor = CPU_R3000;
      mips_isa = ISA_MIPS3;
a391 3

  *isa = mips_isa;
  *cputype = target_processor;
d394 1
a394 1
#endif /* SYMTAB_AVAILABLE */
d396 11
d409 1
a409 1
   always 4.  BIGENDIAN must be 1 if this is big-endian code, 0 if
d413 1
a413 1
_print_insn_mips (memaddr, word, info)
d451 1
a451 1
  set_mips_isa_type (info->mach, &mips_isa, &target_processor);
d454 1
a454 1
  info->bytes_per_chunk = 4;
d479 1
a479 1
	      return 4;
d486 1
a486 1
  return 4;
d488 1
a488 2


d495 2
a496 2
int
print_insn_big_mips (memaddr, info)
d499 1
d501 1
a501 1
  bfd_byte buffer[4];
d520 11
a530 1
  status = (*info->read_memory_func) (memaddr, buffer, 4, info);
d532 10
a541 2
    return _print_insn_mips (memaddr, (unsigned long) bfd_getb32 (buffer),
			     info);
d550 8
d562 1
a562 27
  bfd_byte buffer[4];
  int status;


#if 1
  if (memaddr & 0x01)
    return print_insn_mips16 (memaddr, info);
#endif

#if SYMTAB_AVAILABLE
  if (info->mach == 16
      || (info->flavour == bfd_target_elf_flavour
	  && info->symbols != NULL
	  && ((*(elf_symbol_type **) info->symbols)->internal_elf_sym.st_other
	      == STO_MIPS16)))
    return print_insn_mips16 (memaddr, info);
#endif

  status = (*info->read_memory_func) (memaddr, buffer, 4, info);
  if (status == 0)
    return _print_insn_mips (memaddr, (unsigned long) bfd_getl32 (buffer),
			     info);
  else
    {
      (*info->memory_error_func) (status, memaddr, info);
      return -1;
    }
a581 1

d725 1
a725 1
     int type;
d743 1
a743 1
      (*info->fprintf_func) (info->stream, "$%s",
d750 1
a750 1
      (*info->fprintf_func) (info->stream, "$%s",
d756 1
a756 1
      (*info->fprintf_func) (info->stream, "$%s",
d762 1
a762 1
      (*info->fprintf_func) (info->stream, "$%s",
d768 1
a768 1
      (*info->fprintf_func) (info->stream, "$%s", reg_names[0]);
d772 1
a772 1
      (*info->fprintf_func) (info->stream, "$%s", reg_names[29]);
d780 1
a780 1
      (*info->fprintf_func) (info->stream, "$%s", reg_names[31]);
d784 2
a785 2
      (*info->fprintf_func) (info->stream, "$%s",
			     reg_names[((l >> MIPS16OP_SH_REGR32)
d790 2
a791 2
      (*info->fprintf_func) (info->stream, "$%s",
			     reg_names[MIPS16OP_EXTRACT_REG32R (l)]);
d1076 1
a1076 1
	    (*info->fprintf_func) (info->stream, "$%s", reg_names[4]);
d1078 2
a1079 2
	      (*info->fprintf_func) (info->stream, "-$%s",
				     reg_names[amask + 3]);
d1092 1
a1092 1
	    (*info->fprintf_func) (info->stream, "%s$%s",
d1094 1
a1094 1
				   reg_names[16]);
d1096 2
a1097 2
	      (*info->fprintf_func) (info->stream, "-$%s",
				     reg_names[smask + 15]);
d1103 1
a1103 1
	    (*info->fprintf_func) (info->stream, "%s$%s",
d1105 1
a1105 1
				   reg_names[31]);
d1120 5
@


1.13
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d168 1
a168 1
      else                        
d267 1
a267 1
      (*info->fprintf_func) (info->stream, "%d", 
d434 1
a434 1
#else  
d436 1
a436 1
#endif  
d493 1
a493 1
#endif  
d502 1
a502 1
#endif  
d527 1
a527 1
#endif  
d536 1
a536 1
#endif  
@


1.12
log
@Apply several patches from Maciej W. Rozycki
@
text
@d2 2
a3 1
   Copyright (c) 1989, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
@


1.11
log
@Add MIPS SB1 machine
@
text
@d140 1
a140 1
	(((pc & ~ (bfd_vma) 0x0fffffff)
d1041 1
a1041 1
      (*info->print_address_func) ((memaddr & 0xf0000000) | l, info);
d1043 1
a1043 1
      info->target = (memaddr & 0xf0000000) | l;
@


1.11.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
@


1.11.2.2
log
@Merge from mainline.
@
text
@d39 1
a39 11
/* Mips instructions are at maximum this many bytes long.  */
#define INSNLEN 4

static int _print_insn_mips
  PARAMS ((bfd_vma, struct disassemble_info *, enum bfd_endian));
static int print_insn_mips
  PARAMS ((bfd_vma, unsigned long int, struct disassemble_info *));
static void print_insn_arg
  PARAMS ((const char *, unsigned long, bfd_vma, struct disassemble_info *));
static int print_insn_mips16
  PARAMS ((bfd_vma, struct disassemble_info *));
d43 9
d53 16
a68 1
/* FIXME: These should be shared with gdb somehow.  */
d76 1
a76 31
static const char * const mips32_reg_names[] =
{
  "zero", "at",	  "v0",	 "v1",	 "a0",	  "a1",	   "a2",   "a3",
  "t0",	  "t1",	  "t2",	 "t3",	 "t4",	  "t5",	   "t6",   "t7",
  "s0",	  "s1",	  "s2",	 "s3",	 "s4",	  "s5",	   "s6",   "s7",
  "t8",	  "t9",	  "k0",	 "k1",	 "gp",	  "sp",	   "s8",   "ra",
  "sr",	  "lo",	  "hi",	 "bad",	 "cause", "pc",
  "fv0",  "$f1",  "fv1", "$f3",  "ft0",   "$f5",   "ft1",  "$f7",
  "ft2",  "$f9",  "ft3", "$f11", "fa0",   "$f13",  "fa1",  "$f15",
  "ft4",  "f17",  "ft5", "f19",  "fs0",   "f21",   "fs1",  "f23",
  "fs2",  "$f25", "fs3", "$f27", "fs4",   "$f29",  "fs5",  "$f31",
  "fsr",  "fir",  "fp",  "inx",  "rand",  "tlblo", "ctxt", "tlbhi",
  "epc",  "prid"
};

static const char * const mips64_reg_names[] =
{
  "zero", "at",	  "v0",	  "v1",	  "a0",	   "a1",    "a2",   "a3",
  "a4",	  "a5",	  "a6",   "a7",	  "t0",	   "t1",    "t2",   "t3",
  "s0",	  "s1",	  "s2",	  "s3",	  "s4",	   "s5",    "s6",   "s7",
  "t8",	  "t9",	  "k0",	  "k1",	  "gp",	   "sp",    "s8",   "ra",
  "sr",	  "lo",	  "hi",	  "bad",  "cause", "pc",
  "fv0",  "$f1",  "fv1",  "$f3",  "ft0",   "ft1",   "ft2",  "ft3",
  "ft4",  "ft5",  "ft6",  "ft7",  "fa0",   "fa1",   "fa2",  "fa3",
  "fa4",  "fa5",  "fa6",  "fa7",  "ft8",   "ft9",   "ft10", "ft11",
  "fs0",  "fs1",  "fs2",  "fs3",  "fs4",   "fs5",   "fs6",  "fs7",
  "fsr",  "fir",  "fp",   "inx",  "rand",  "tlblo", "ctxt", "tlbhi",
  "epc",  "prid"
};

/* Scalar register names. _print_insn_mips() decides which register name
d78 1
a78 1
static const char * const *reg_names = NULL;
d80 1
a80 2
/* Print insn arguments for 32/64-bit code */

d102 1
a102 1
      (*info->fprintf_func) (info->stream, "%s",
d108 1
a108 1
      (*info->fprintf_func) (info->stream, "%s",
d141 1
a141 1
	((((pc + 4) & ~ (bfd_vma) 0x0fffffff)
d152 1
a152 1
	((delta << 2) + pc + INSNLEN,
d157 1
a157 1
      (*info->fprintf_func) (info->stream, "%s",
d164 1
a164 1
      unsigned int reg = (l >> OP_SH_RD) & OP_MASK_RD;
d166 1
a166 1
        (*info->fprintf_func) (info->stream, "%s",
d168 1
a168 1
      else
d172 1
a172 1
            (*info->fprintf_func) (info->stream, "%s",
d175 1
a175 1
            (*info->fprintf_func) (info->stream, "%s",
d178 1
a178 1
            (*info->fprintf_func) (info->stream, "%s or %s",
d186 1
a186 1
      (*info->fprintf_func) (info->stream, "%s", reg_names[0]);
d242 2
a243 2
      (*info->fprintf_func) (info->stream, "%s",
			     reg_names[(l >> OP_SH_RT) & OP_MASK_RT]);
d247 2
a248 2
      (*info->fprintf_func) (info->stream, "%s",
			     reg_names[(l >> OP_SH_RD) & OP_MASK_RD]);
d267 1
a267 1
      (*info->fprintf_func) (info->stream, "%d",
d280 4
a283 1
/* Figure out the MIPS ISA and CPU based on the machine number. */
d286 1
a286 1
mips_isa_type (mach, isa, cputype)
d291 6
d300 2
a301 2
      *cputype = CPU_R3000;
      *isa = ISA_MIPS1;
d304 2
a305 2
      *cputype = CPU_R3900;
      *isa = ISA_MIPS1;
d308 2
a309 2
      *cputype = CPU_R4000;
      *isa = ISA_MIPS3;
d312 2
a313 2
      *cputype = CPU_R4010;
      *isa = ISA_MIPS2;
d316 2
a317 2
      *cputype = CPU_VR4100;
      *isa = ISA_MIPS3;
d320 2
a321 2
      *cputype = CPU_R4111;
      *isa = ISA_MIPS3;
d324 2
a325 2
      *cputype = CPU_R4300;
      *isa = ISA_MIPS3;
d328 2
a329 2
      *cputype = CPU_R4400;
      *isa = ISA_MIPS3;
d332 2
a333 2
      *cputype = CPU_R4600;
      *isa = ISA_MIPS3;
d336 2
a337 2
      *cputype = CPU_R4650;
      *isa = ISA_MIPS3;
d340 2
a341 2
      *cputype = CPU_R5000;
      *isa = ISA_MIPS4;
d344 2
a345 2
      *cputype = CPU_R6000;
      *isa = ISA_MIPS2;
d348 2
a349 2
      *cputype = CPU_R8000;
      *isa = ISA_MIPS4;
d352 2
a353 6
      *cputype = CPU_R10000;
      *isa = ISA_MIPS4;
      break;
    case bfd_mach_mips12000:
      *cputype = CPU_R12000;
      *isa = ISA_MIPS4;
d356 2
a357 2
      *cputype = CPU_MIPS16;
      *isa = ISA_MIPS3;
d360 2
a361 2
      *cputype = CPU_MIPS32;
      *isa = ISA_MIPS32;
d364 2
a365 2
      *cputype = CPU_MIPS32_4K;
      *isa = ISA_MIPS32;
d368 2
a369 2
      *cputype = CPU_MIPS5;
      *isa = ISA_MIPS5;
d372 2
a373 2
      *cputype = CPU_MIPS64;
      *isa = ISA_MIPS64;
d376 2
a377 2
      *cputype = CPU_SB1;
      *isa = ISA_MIPS64;
d380 2
a381 2
      *cputype = CPU_R3000;
      *isa = ISA_MIPS3;
d384 3
d389 1
a389 8
/* Figure out ISA from disassemble_info data */

static int
get_mips_isa (info)
     struct disassemble_info *info;
{
  int isa;
  int cpu;
a390 4
  mips_isa_type (info->mach, &isa, &cpu);
  return isa;
}

d393 1
a393 1
   always INSNLEN.  BIGENDIAN must be 1 if this is big-endian code, 0 if
d397 1
a397 1
print_insn_mips (memaddr, word, info)
d434 3
a436 3
#else
  mips_isa_type (info->mach, &mips_isa, &target_processor);
#endif
d438 1
a438 1
  info->bytes_per_chunk = INSNLEN;
d463 1
a463 1
	      return INSNLEN;
d470 1
a470 1
  return INSNLEN;
d472 2
a473 1

d480 2
a481 2
static int
_print_insn_mips (memaddr, info, endianness)
a483 1
     enum bfd_endian endianness;
d485 1
a485 1
  bfd_byte buffer[INSNLEN];
d493 1
a493 1
#endif
d502 1
a502 11
#endif

  /* Use mips64_reg_names for new ABI.  */
  if (info->flavour == bfd_target_elf_flavour
      && info->symbols != NULL
      && (((get_mips_isa(info) | INSN_ISA_MASK) & ISA_MIPS2) != 0)
      && ((elf_elfheader (bfd_asymbol_bfd(*(info->symbols)))->e_flags
	   & EF_MIPS_ABI2) != 0))
    reg_names = mips64_reg_names;
  else
    reg_names = mips32_reg_names;
d504 1
a504 1
  status = (*info->read_memory_func) (memaddr, buffer, INSNLEN, info);
d506 2
a507 10
    {
      unsigned long insn;

      if (endianness == BFD_ENDIAN_BIG)
        insn = (unsigned long) bfd_getb32 (buffer);
      else
	insn = (unsigned long) bfd_getl32 (buffer);

      return print_insn_mips (memaddr, insn, info);
    }
d516 1
a516 1
print_insn_big_mips (memaddr, info)
d520 17
a536 2
  return _print_insn_mips (memaddr, info, BFD_ENDIAN_BIG);
}
d538 9
a546 6
int
print_insn_little_mips (memaddr, info)
     bfd_vma memaddr;
     struct disassemble_info *info;
{
  return _print_insn_mips (memaddr, info, BFD_ENDIAN_LITTLE);
d566 1
d710 1
a710 1
     char type;
d728 1
a728 1
      (*info->fprintf_func) (info->stream, "%s",
d735 1
a735 1
      (*info->fprintf_func) (info->stream, "%s",
d741 1
a741 1
      (*info->fprintf_func) (info->stream, "%s",
d747 1
a747 1
      (*info->fprintf_func) (info->stream, "%s",
d753 1
a753 1
      (*info->fprintf_func) (info->stream, "%s", mips32_reg_names[0]);
d757 1
a757 1
      (*info->fprintf_func) (info->stream, "%s", mips32_reg_names[29]);
d765 1
a765 1
      (*info->fprintf_func) (info->stream, "%s", mips32_reg_names[31]);
d769 2
a770 2
      (*info->fprintf_func) (info->stream, "%s",
			     mips32_reg_names[((l >> MIPS16OP_SH_REGR32)
d775 2
a776 2
      (*info->fprintf_func) (info->stream, "%s",
			     mips32_reg_names[MIPS16OP_EXTRACT_REG32R (l)]);
d1042 1
a1042 1
      (*info->print_address_func) (((memaddr + 4) & 0xf0000000) | l, info);
d1044 1
a1044 1
      info->target = ((memaddr + 4) & 0xf0000000) | l;
d1061 1
a1061 1
	    (*info->fprintf_func) (info->stream, "%s", mips32_reg_names[4]);
d1063 2
a1064 2
	      (*info->fprintf_func) (info->stream, "-%s",
				     mips32_reg_names[amask + 3]);
d1077 1
a1077 1
	    (*info->fprintf_func) (info->stream, "%s%s",
d1079 1
a1079 1
				   mips32_reg_names[16]);
d1081 2
a1082 2
	      (*info->fprintf_func) (info->stream, "-%s",
				     mips32_reg_names[smask + 15]);
d1088 1
a1088 1
	    (*info->fprintf_func) (info->stream, "%s%s",
d1090 1
a1090 1
				   mips32_reg_names[31]);
a1104 5
      /* xgettext:c-format */
      (*info->fprintf_func)
	(info->stream,
	 _("# internal disassembler error, unrecognised modifier (%c)"),
	 type);
@


1.10
log
@Add MIPS V and MIPS 64 machine numbers
@
text
@d374 4
@


1.9
log
@Add MIPS32 as a seperate MIPS architecture
@
text
@d366 8
@


1.8
log
@Improve MIPS32 support
@
text
@d290 2
a291 2
  int target_processor = 0;
  int mips_isa = 0;
d300 1
a300 1
      mips_isa = 1;
d304 1
a304 1
      mips_isa = 1;
d308 1
a308 1
      mips_isa = 3;
d312 1
a312 1
      mips_isa = 2;
d316 1
a316 1
      mips_isa = 3;
d320 1
a320 1
      mips_isa = 3;
d324 1
a324 1
      mips_isa = 3;
d328 1
a328 1
      mips_isa = 3;
d332 1
a332 1
      mips_isa = 3;
d336 1
a336 5
      mips_isa = 3;
      break;
    case bfd_mach_mips4K:
      target_processor = CPU_4K;
      mips_isa = 2;
d340 1
a340 1
      mips_isa = 4;
d344 1
a344 1
      mips_isa = 2;
d348 1
a348 1
      mips_isa = 4;
d352 1
a352 1
      mips_isa = 4;
d356 9
a364 1
      mips_isa = 3;
d368 1
a368 1
      mips_isa = 3;
@


1.7
log
@Add support for the MIPS32
@
text
@d160 24
a197 1

d203 1
a203 1
    case 'm':
d205 1
a205 1
			     (l >> OP_SH_CODE20) & OP_MASK_CODE20);
d208 1
a208 1
    case 'C':
d210 1
a210 1
			     (l >> OP_SH_COPZ) & OP_MASK_COPZ);
d213 1
a213 1
    case 'B':
d215 1
a215 1
			     (l >> OP_SH_SYSCALL) & OP_MASK_SYSCALL);
a222 1

@


1.6
log
@	* mips-dis.c (REGISTER_NAMES): Rename to STD_REGISTER_NAMES.
	(STD_REGISTER_NAMES): New name for REGISTER_NAMES.
	(reg_names): Rename to std_reg_names. Change it to a char **
	static variable.
	(std_reg_names): New name for reg_names.
	(set_mips_isa_type): Set reg_names to point to std_reg_names by
	default.
@
text
@d180 5
d243 4
d276 68
a343 65
      case bfd_mach_mips3000:
	target_processor = 3000;
	mips_isa = 1;
	break;
      case bfd_mach_mips3900:
	target_processor = 3900;
	mips_isa = 1;
	break;
      case bfd_mach_mips4000:
	target_processor = 4000;
	mips_isa = 3;
	break;
      case bfd_mach_mips4010:
	target_processor = 4010;
	mips_isa = 2;
	break;
      case bfd_mach_mips4100:
	target_processor = 4100;
	mips_isa = 3;
	break;
      case bfd_mach_mips4111:
	target_processor = 4100;
	mips_isa = 3;
	break;
      case bfd_mach_mips4300:
	target_processor = 4300;
	mips_isa = 3;
	break;
      case bfd_mach_mips4400:
	target_processor = 4400;
	mips_isa = 3;
	break;
      case bfd_mach_mips4600:
	target_processor = 4600;
	mips_isa = 3;
	break;
      case bfd_mach_mips4650:
	target_processor = 4650;
	mips_isa = 3;
	break;
      case bfd_mach_mips5000:
	target_processor = 5000;
	mips_isa = 4;
	break;
      case bfd_mach_mips6000:
	target_processor = 6000;
	mips_isa = 2;
	break;
      case bfd_mach_mips8000:
	target_processor = 8000;
	mips_isa = 4;
	break;
      case bfd_mach_mips10000:
	target_processor = 10000;
	mips_isa = 4;
	break;
      case bfd_mach_mips16:
	target_processor = 16;
	mips_isa = 3;
	break;
      default:
	target_processor = 3000;
	mips_isa = 3;
	break;

@


1.5
log
@Don't mask top 32 bits of 64-bit address.
@
text
@d53 1
a53 1
#define REGISTER_NAMES 	\
d67 1
a67 1
static CONST char * CONST reg_names[] = REGISTER_NAMES;
d74 4
d261 3
@


1.4
log
@More portability patches.  Include sysdep.h everywhere.
@
text
@d2 2
a3 1
   Copyright (c) 1989, 91-97, 1998 Free Software Foundation, Inc.
d136 2
a137 1
	(((pc & 0xF0000000) | (((l >> OP_SH_TARGET) & OP_MASK_TARGET) << 2)),
@


1.3
log
@1999-12-30  Andrew Haley  <aph@@cygnus.com>

	* mips-dis.c (_print_insn_mips): New arg for OPCODE_IS_MEMBER:
	force gp32 to zero.
	* mips-opc.c (G6): New define.
	(mips_builtin_op): Add "move" definition for -gp32.
@
text
@a20 1
#include <ansidecl.h>
@


1.3.2.1
log
@2000-04-13  Michael Sokolov  <msokolov@@ivan.Harhan.ORG>

	* a29k-dis.c, alpha-dis.c, alpha-opc.c, arc-dis.c, arc-opc.c,
	avr-dis.c, d10v-dis.c, d10v-opc.c, d30v-dis.c, d30v-opc.c,
	disassemble.c, h8300-dis.c, h8500-dis.c, hppa-dis.c, i370-dis.c,
	i370-opc.c, i960-dis.c, m10200-dis.c, m10200-opc.c, m10300-dis.c,
	m10300-opc.c, m68k-dis.c, m68k-opc.c, m88k-dis.c, mcore-dis.c,
	mips-dis.c, mips-opc.c, mips16-opc.c, pj-dis.c, pj-opc.c, ppc-dis.c,
	ppc-opc.c, sh-dis.c, sparc-dis.c, sparc-opc.c, tic80-dis.c,
	tic80-opc.c, v850-dis.c, v850-opc.c, vax-dis.c, w65-dis.c, z8k-dis.c,
	z8kgen.c: Everyone includes sysdep.h. Remove ansidecl.h as sysdep.h
	includes it.
@
text
@d21 1
@


1.2
log
@For include/opcode:

	* mips.h (OPCODE_IS_MEMBER): New.

For gas:

	* config/tc-mips.c (macro_build): Use OPCODE_IS_MEMBER.
	(mips_ip): Use OPCODE_IS_MEMBER.

For opcodes:

	* mips-dis.c (_print_insn_mips): Use OPCODE_IS_MEMBER.
@
text
@d391 1
a391 1
	      if (! OPCODE_IS_MEMBER (op, mips_isa, target_processor))
@


1.1
log
@Initial revision
@
text
@a389 1
	      int insn_isa;
d391 1
a391 20
	      if ((op->membership & INSN_ISA) == INSN_ISA1)
		insn_isa = 1;
	      else if ((op->membership & INSN_ISA) == INSN_ISA2)
		insn_isa = 2;
	      else if ((op->membership & INSN_ISA) == INSN_ISA3)
		insn_isa = 3;
	      else if ((op->membership & INSN_ISA) == INSN_ISA4)
		insn_isa = 4;
	      else
		insn_isa = 15;

	      if (insn_isa > mips_isa
		  && (target_processor == 4650
		      && op->membership & INSN_4650) == 0
		  && (target_processor == 4010
		      && op->membership & INSN_4010) == 0
		  && (target_processor == 4100
		      && op->membership & INSN_4100) == 0
		  && (target_processor == 3900
		      && op->membership & INSN_3900) == 0)
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

