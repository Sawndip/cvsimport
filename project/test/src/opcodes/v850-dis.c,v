head	1.20;
access;
symbols
	sid-snapshot-20180601:1.20
	sid-snapshot-20180501:1.20
	sid-snapshot-20180401:1.20
	sid-snapshot-20180301:1.20
	sid-snapshot-20180201:1.20
	sid-snapshot-20180101:1.20
	sid-snapshot-20171201:1.20
	sid-snapshot-20171101:1.20
	sid-snapshot-20171001:1.20
	sid-snapshot-20170901:1.20
	sid-snapshot-20170801:1.20
	sid-snapshot-20170701:1.20
	sid-snapshot-20170601:1.20
	sid-snapshot-20170501:1.20
	sid-snapshot-20170401:1.20
	sid-snapshot-20170301:1.20
	sid-snapshot-20170201:1.20
	sid-snapshot-20170101:1.20
	sid-snapshot-20161201:1.20
	sid-snapshot-20161101:1.20
	sid-snapshot-20160901:1.20
	sid-snapshot-20160801:1.20
	sid-snapshot-20160701:1.20
	sid-snapshot-20160601:1.20
	sid-snapshot-20160501:1.20
	sid-snapshot-20160401:1.20
	sid-snapshot-20160301:1.20
	sid-snapshot-20160201:1.20
	sid-snapshot-20160101:1.20
	sid-snapshot-20151201:1.20
	sid-snapshot-20151101:1.20
	sid-snapshot-20151001:1.20
	sid-snapshot-20150901:1.20
	sid-snapshot-20150801:1.20
	sid-snapshot-20150701:1.20
	sid-snapshot-20150601:1.20
	sid-snapshot-20150501:1.20
	sid-snapshot-20150401:1.20
	sid-snapshot-20150301:1.20
	sid-snapshot-20150201:1.20
	sid-snapshot-20150101:1.20
	sid-snapshot-20141201:1.20
	sid-snapshot-20141101:1.20
	sid-snapshot-20141001:1.20
	sid-snapshot-20140901:1.20
	sid-snapshot-20140801:1.20
	sid-snapshot-20140701:1.20
	sid-snapshot-20140601:1.20
	sid-snapshot-20140501:1.20
	sid-snapshot-20140401:1.20
	sid-snapshot-20140301:1.20
	sid-snapshot-20140201:1.20
	sid-snapshot-20140101:1.20
	sid-snapshot-20131201:1.20
	sid-snapshot-20131101:1.20
	sid-snapshot-20131001:1.19
	binutils-2_24-branch:1.19.0.2
	binutils-2_24-branchpoint:1.19
	binutils-2_21_1:1.12
	sid-snapshot-20130901:1.19
	gdb_7_6_1-2013-08-30-release:1.18
	sid-snapshot-20130801:1.19
	sid-snapshot-20130701:1.19
	sid-snapshot-20130601:1.19
	sid-snapshot-20130501:1.19
	gdb_7_6-2013-04-26-release:1.18
	sid-snapshot-20130401:1.18
	binutils-2_23_2:1.14.4.1
	gdb_7_6-branch:1.18.0.2
	gdb_7_6-2013-03-12-branchpoint:1.18
	sid-snapshot-20130301:1.18
	sid-snapshot-20130201:1.18
	sid-snapshot-20130101:1.16
	sid-snapshot-20121201:1.16
	gdb_7_5_1-2012-11-29-release:1.14
	binutils-2_23_1:1.14.4.1
	sid-snapshot-20121101:1.16
	binutils-2_23:1.14.4.1
	sid-snapshot-20121001:1.15
	sid-snapshot-20120901:1.15
	gdb_7_5-2012-08-17-release:1.14
	sid-snapshot-20120801:1.15
	binutils-2_23-branch:1.14.0.4
	binutils-2_23-branchpoint:1.14
	gdb_7_5-branch:1.14.0.2
	gdb_7_5-2012-07-18-branchpoint:1.14
	sid-snapshot-20120701:1.14
	sid-snapshot-20120601:1.14
	sid-snapshot-20120501:1.13
	binutils-2_22_branch:1.13.0.6
	gdb_7_4_1-2012-04-26-release:1.13
	sid-snapshot-20120401:1.13
	sid-snapshot-20120301:1.13
	sid-snapshot-20120201:1.13
	gdb_7_4-2012-01-24-release:1.13
	sid-snapshot-20120101:1.13
	gdb_7_4-branch:1.13.0.4
	gdb_7_4-2011-12-13-branchpoint:1.13
	sid-snapshot-20111201:1.13
	binutils-2_22:1.13
	sid-snapshot-20111101:1.13
	sid-snapshot-20111001:1.13
	binutils-2_22-branch:1.13.0.2
	binutils-2_22-branchpoint:1.13
	gdb_7_3_1-2011-09-04-release:1.12
	sid-snapshot-20110901:1.13
	sid-snapshot-20110801:1.13
	gdb_7_3-2011-07-26-release:1.12
	sid-snapshot-20110701:1.13
	sid-snapshot-20110601:1.13
	sid-snapshot-20110501:1.13
	gdb_7_3-branch:1.12.0.4
	gdb_7_3-2011-04-01-branchpoint:1.12
	sid-snapshot-20110401:1.12
	sid-snapshot-20110301:1.12
	sid-snapshot-20110201:1.12
	sid-snapshot-20110101:1.12
	binutils-2_21:1.12
	sid-snapshot-20101201:1.12
	binutils-2_21-branch:1.12.0.2
	binutils-2_21-branchpoint:1.12
	sid-snapshot-20101101:1.12
	sid-snapshot-20101001:1.12
	binutils-2_20_1:1.11
	gdb_7_2-2010-09-02-release:1.11
	sid-snapshot-20100901:1.12
	sid-snapshot-20100801:1.12
	gdb_7_2-branch:1.11.0.38
	gdb_7_2-2010-07-07-branchpoint:1.11
	sid-snapshot-20100701:1.11
	sid-snapshot-20100601:1.11
	sid-snapshot-20100501:1.11
	sid-snapshot-20100401:1.11
	gdb_7_1-2010-03-18-release:1.11
	sid-snapshot-20100301:1.11
	gdb_7_1-branch:1.11.0.36
	gdb_7_1-2010-02-18-branchpoint:1.11
	sid-snapshot-20100201:1.11
	sid-snapshot-20100101:1.11
	gdb_7_0_1-2009-12-22-release:1.11
	sid-snapshot-20091201:1.11
	sid-snapshot-20091101:1.11
	binutils-2_20:1.11
	gdb_7_0-2009-10-06-release:1.11
	sid-snapshot-20091001:1.11
	gdb_7_0-branch:1.11.0.34
	gdb_7_0-2009-09-16-branchpoint:1.11
	arc-sim-20090309:1.11
	binutils-arc-20081103-branch:1.11.0.32
	binutils-arc-20081103-branchpoint:1.11
	binutils-2_20-branch:1.11.0.30
	binutils-2_20-branchpoint:1.11
	sid-snapshot-20090901:1.11
	sid-snapshot-20090801:1.11
	msnyder-checkpoint-072509-branch:1.11.0.28
	msnyder-checkpoint-072509-branchpoint:1.11
	sid-snapshot-20090701:1.11
	dje-cgen-play1-branch:1.11.0.26
	dje-cgen-play1-branchpoint:1.11
	sid-snapshot-20090601:1.11
	sid-snapshot-20090501:1.11
	sid-snapshot-20090401:1.11
	arc-20081103-branch:1.11.0.24
	arc-20081103-branchpoint:1.11
	arc-insight_6_8-branch:1.11.0.22
	arc-insight_6_8-branchpoint:1.11
	insight_6_8-branch:1.11.0.20
	insight_6_8-branchpoint:1.11
	sid-snapshot-20090301:1.11
	binutils-2_19_1:1.11
	sid-snapshot-20090201:1.11
	sid-snapshot-20090101:1.11
	reverse-20081226-branch:1.11.0.18
	reverse-20081226-branchpoint:1.11
	sid-snapshot-20081201:1.11
	multiprocess-20081120-branch:1.11.0.16
	multiprocess-20081120-branchpoint:1.11
	sid-snapshot-20081101:1.11
	binutils-2_19:1.11
	sid-snapshot-20081001:1.11
	reverse-20080930-branch:1.11.0.14
	reverse-20080930-branchpoint:1.11
	binutils-2_19-branch:1.11.0.12
	binutils-2_19-branchpoint:1.11
	sid-snapshot-20080901:1.11
	sid-snapshot-20080801:1.11
	reverse-20080717-branch:1.11.0.10
	reverse-20080717-branchpoint:1.11
	sid-snapshot-20080701:1.11
	msnyder-reverse-20080609-branch:1.11.0.8
	msnyder-reverse-20080609-branchpoint:1.11
	drow-reverse-20070409-branch:1.10.0.32
	drow-reverse-20070409-branchpoint:1.10
	sid-snapshot-20080601:1.11
	sid-snapshot-20080501:1.11
	sid-snapshot-20080403:1.11
	sid-snapshot-20080401:1.11
	gdb_6_8-2008-03-27-release:1.11
	sid-snapshot-20080301:1.11
	gdb_6_8-branch:1.11.0.6
	gdb_6_8-2008-02-26-branchpoint:1.11
	sid-snapshot-20080201:1.11
	sid-snapshot-20080101:1.11
	sid-snapshot-20071201:1.11
	sid-snapshot-20071101:1.11
	gdb_6_7_1-2007-10-29-release:1.11
	gdb_6_7-2007-10-10-release:1.11
	sid-snapshot-20071001:1.11
	gdb_6_7-branch:1.11.0.4
	gdb_6_7-2007-09-07-branchpoint:1.11
	binutils-2_18:1.11
	binutils-2_18-branch:1.11.0.2
	binutils-2_18-branchpoint:1.11
	insight_6_6-20070208-release:1.10
	binutils-csl-coldfire-4_1-32:1.10
	binutils-csl-sourcerygxx-4_1-32:1.10
	gdb_6_6-2006-12-18-release:1.10
	binutils-csl-innovasic-fido-3_4_4-33:1.10
	binutils-csl-sourcerygxx-3_4_4-32:1.7
	binutils-csl-coldfire-4_1-30:1.10
	binutils-csl-sourcerygxx-4_1-30:1.10
	binutils-csl-coldfire-4_1-28:1.10
	binutils-csl-sourcerygxx-4_1-29:1.10
	binutils-csl-sourcerygxx-4_1-28:1.10
	gdb_6_6-branch:1.10.0.30
	gdb_6_6-2006-11-15-branchpoint:1.10
	binutils-csl-arm-2006q3-27:1.10
	binutils-csl-sourcerygxx-4_1-27:1.10
	binutils-csl-arm-2006q3-26:1.10
	binutils-csl-sourcerygxx-4_1-26:1.10
	binutils-csl-sourcerygxx-4_1-25:1.10
	binutils-csl-sourcerygxx-4_1-24:1.10
	binutils-csl-sourcerygxx-4_1-23:1.10
	insight_6_5-20061003-release:1.10
	gdb-csl-symbian-6_4_50_20060226-12:1.10
	binutils-csl-sourcerygxx-4_1-21:1.10
	binutils-csl-arm-2006q3-21:1.10
	binutils-csl-sourcerygxx-4_1-22:1.10
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.10
	binutils-csl-sourcerygxx-4_1-20:1.10
	binutils-csl-arm-2006q3-19:1.10
	binutils-csl-sourcerygxx-4_1-19:1.10
	binutils-csl-sourcerygxx-4_1-18:1.10
	binutils-csl-renesas-4_1-9:1.10
	gdb-csl-sourcerygxx-3_4_4-25:1.10
	binutils-csl-sourcerygxx-3_4_4-25:1.7
	nickrob-async-20060828-mergepoint:1.10
	gdb-csl-symbian-6_4_50_20060226-11:1.10
	binutils-csl-renesas-4_1-8:1.10
	binutils-csl-renesas-4_1-7:1.10
	binutils-csl-renesas-4_1-6:1.10
	gdb-csl-sourcerygxx-4_1-17:1.10
	binutils-csl-sourcerygxx-4_1-17:1.10
	gdb-csl-20060226-branch-local-2:1.10
	gdb-csl-sourcerygxx-4_1-14:1.10
	binutils-csl-sourcerygxx-4_1-14:1.10
	binutils-csl-sourcerygxx-4_1-15:1.10
	gdb-csl-sourcerygxx-4_1-13:1.10
	binutils-csl-sourcerygxx-4_1-13:1.10
	binutils-2_17:1.10
	gdb-csl-sourcerygxx-4_1-12:1.10
	binutils-csl-sourcerygxx-4_1-12:1.10
	gdb-csl-sourcerygxx-3_4_4-21:1.10
	binutils-csl-sourcerygxx-3_4_4-21:1.10
	gdb_6_5-20060621-release:1.10
	binutils-csl-wrs-linux-3_4_4-24:1.7
	binutils-csl-wrs-linux-3_4_4-23:1.7
	gdb-csl-sourcerygxx-4_1-9:1.10
	binutils-csl-sourcerygxx-4_1-9:1.10
	gdb-csl-sourcerygxx-4_1-8:1.10
	binutils-csl-sourcerygxx-4_1-8:1.10
	gdb-csl-sourcerygxx-4_1-7:1.10
	binutils-csl-sourcerygxx-4_1-7:1.10
	gdb-csl-arm-2006q1-6:1.10
	binutils-csl-arm-2006q1-6:1.10
	gdb-csl-sourcerygxx-4_1-6:1.10
	binutils-csl-sourcerygxx-4_1-6:1.10
	binutils-csl-wrs-linux-3_4_4-22:1.7
	gdb-csl-symbian-6_4_50_20060226-10:1.10
	gdb-csl-symbian-6_4_50_20060226-9:1.10
	gdb-csl-symbian-6_4_50_20060226-8:1.10
	gdb-csl-coldfire-4_1-11:1.10
	binutils-csl-coldfire-4_1-11:1.10
	gdb-csl-sourcerygxx-3_4_4-19:1.10
	binutils-csl-sourcerygxx-3_4_4-19:1.10
	gdb-csl-coldfire-4_1-10:1.10
	gdb_6_5-branch:1.10.0.28
	gdb_6_5-2006-05-14-branchpoint:1.10
	binutils-csl-coldfire-4_1-10:1.10
	gdb-csl-sourcerygxx-4_1-5:1.10
	binutils-csl-sourcerygxx-4_1-5:1.10
	nickrob-async-20060513-branch:1.10.0.26
	nickrob-async-20060513-branchpoint:1.10
	gdb-csl-sourcerygxx-4_1-4:1.10
	binutils-csl-sourcerygxx-4_1-4:1.10
	msnyder-reverse-20060502-branch:1.10.0.24
	msnyder-reverse-20060502-branchpoint:1.10
	binutils-csl-wrs-linux-3_4_4-21:1.7
	gdb-csl-morpho-4_1-4:1.10
	binutils-csl-morpho-4_1-4:1.10
	gdb-csl-sourcerygxx-3_4_4-17:1.10
	binutils-csl-sourcerygxx-3_4_4-17:1.10
	binutils-csl-wrs-linux-3_4_4-20:1.7
	readline_5_1-import-branch:1.10.0.22
	readline_5_1-import-branchpoint:1.10
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.10
	binutils-2_17-branch:1.10.0.20
	binutils-2_17-branchpoint:1.10
	gdb-csl-symbian-20060226-branch:1.10.0.18
	gdb-csl-symbian-20060226-branchpoint:1.10
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.10
	msnyder-reverse-20060331-branch:1.10.0.16
	msnyder-reverse-20060331-branchpoint:1.10
	binutils-csl-2_17-branch:1.10.0.14
	binutils-csl-2_17-branchpoint:1.10
	gdb-csl-available-20060303-branch:1.10.0.12
	gdb-csl-available-20060303-branchpoint:1.10
	gdb-csl-20060226-branch:1.10.0.10
	gdb-csl-20060226-branchpoint:1.10
	gdb_6_4-20051202-release:1.10
	msnyder-fork-checkpoint-branch:1.10.0.8
	msnyder-fork-checkpoint-branchpoint:1.10
	gdb-csl-gxxpro-6_3-branch:1.10.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.10
	gdb_6_4-branch:1.10.0.4
	gdb_6_4-2005-11-01-branchpoint:1.10
	gdb-csl-arm-20051020-branch:1.10.0.2
	gdb-csl-arm-20051020-branchpoint:1.10
	binutils-csl-gxxpro-3_4-branch:1.7.0.32
	binutils-csl-gxxpro-3_4-branchpoint:1.7
	binutils-2_16_1:1.7
	msnyder-tracepoint-checkpoint-branch:1.8.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.8
	gdb-csl-arm-20050325-2005-q1b:1.7
	binutils-csl-arm-2005q1b:1.7
	binutils-2_16:1.7
	gdb-csl-arm-20050325-2005-q1a:1.7
	binutils-csl-arm-2005q1a:1.7
	csl-arm-20050325-branch:1.7.0.30
	csl-arm-20050325-branchpoint:1.7
	binutils-csl-arm-2005q1-branch:1.7.0.28
	binutils-csl-arm-2005q1-branchpoint:1.7
	binutils-2_16-branch:1.7.0.26
	binutils-2_16-branchpoint:1.7
	csl-arm-2004-q3d:1.7
	gdb_6_3-20041109-release:1.7
	gdb_6_3-branch:1.7.0.22
	gdb_6_3-20041019-branchpoint:1.7
	csl-arm-2004-q3:1.7
	drow_intercu-merge-20040921:1.7
	drow_intercu-merge-20040915:1.7
	jimb-gdb_6_2-e500-branch:1.7.0.24
	jimb-gdb_6_2-e500-branchpoint:1.7
	gdb_6_2-20040730-release:1.7
	gdb_6_2-branch:1.7.0.20
	gdb_6_2-2004-07-10-gmt-branchpoint:1.7
	gdb_6_1_1-20040616-release:1.7
	binutils-2_15:1.7
	binutils-2_15-branchpoint:1.7
	csl-arm-2004-q1a:1.7
	csl-arm-2004-q1:1.7
	gdb_6_1-2004-04-05-release:1.7
	drow_intercu-merge-20040402:1.7
	drow_intercu-merge-20040327:1.7
	ezannoni_pie-20040323-branch:1.7.0.18
	ezannoni_pie-20040323-branchpoint:1.7
	cagney_tramp-20040321-mergepoint:1.7
	cagney_tramp-20040309-branch:1.7.0.16
	cagney_tramp-20040309-branchpoint:1.7
	gdb_6_1-branch:1.7.0.14
	gdb_6_1-2004-03-01-gmt-branchpoint:1.7
	drow_intercu-20040221-branch:1.7.0.12
	drow_intercu-20040221-branchpoint:1.7
	binutils-2_15-branch:1.7.0.10
	cagney_bfdfile-20040213-branch:1.7.0.8
	cagney_bfdfile-20040213-branchpoint:1.7
	drow-cplus-merge-20040208:1.7
	carlton_dictionary-20040126-merge:1.7
	cagney_bigcore-20040122-branch:1.7.0.6
	cagney_bigcore-20040122-branchpoint:1.7
	drow-cplus-merge-20040113:1.7
	csl-arm-2003-q4:1.7
	drow-cplus-merge-20031224:1.7
	drow-cplus-merge-20031220:1.7
	carlton_dictionary-20031215-merge:1.7
	drow-cplus-merge-20031214:1.7
	carlton-dictionary-20031111-merge:1.7
	gdb_6_0-2003-10-04-release:1.6
	kettenis_sparc-20030918-branch:1.7.0.4
	kettenis_sparc-20030918-branchpoint:1.7
	carlton_dictionary-20030917-merge:1.7
	ezannoni_pie-20030916-branchpoint:1.7
	ezannoni_pie-20030916-branch:1.7.0.2
	cagney_x86i386-20030821-branch:1.6.0.38
	cagney_x86i386-20030821-branchpoint:1.6
	carlton_dictionary-20030805-merge:1.6
	carlton_dictionary-20030627-merge:1.6
	gdb_6_0-branch:1.6.0.36
	gdb_6_0-2003-06-23-branchpoint:1.6
	jimb-ppc64-linux-20030613-branch:1.6.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.6
	binutils-2_14:1.6
	cagney_convert-20030606-branch:1.6.0.32
	cagney_convert-20030606-branchpoint:1.6
	cagney_writestrings-20030508-branch:1.6.0.30
	cagney_writestrings-20030508-branchpoint:1.6
	jimb-ppc64-linux-20030528-branch:1.6.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.6
	carlton_dictionary-20030523-merge:1.6
	cagney_fileio-20030521-branch:1.6.0.26
	cagney_fileio-20030521-branchpoint:1.6
	kettenis_i386newframe-20030517-mergepoint:1.6
	jimb-ppc64-linux-20030509-branch:1.6.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.6
	kettenis_i386newframe-20030504-mergepoint:1.6
	carlton_dictionary-20030430-merge:1.6
	binutils-2_14-branch:1.6.0.22
	binutils-2_14-branchpoint:1.6
	kettenis_i386newframe-20030419-branch:1.6.0.20
	kettenis_i386newframe-20030419-branchpoint:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.6
	kettenis_i386newframe-20030406-branch:1.6.0.18
	kettenis_i386newframe-20030406-branchpoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.16
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.14
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.12
	cagney_lazyid-20030317-branchpoint:1.6
	kettenis-i386newframe-20030316-mergepoint:1.6
	offbyone-20030313-branch:1.6.0.10
	offbyone-20030313-branchpoint:1.6
	kettenis-i386newframe-20030308-branch:1.6.0.8
	kettenis-i386newframe-20030308-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.6
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.6
	interps-20030202-branch:1.6.0.4
	interps-20030202-branchpoint:1.6
	cagney-unwind-20030108-branch:1.6.0.2
	cagney-unwind-20030108-branchpoint:1.6
	binutils-2_13_2_1:1.4
	binutils-2_13_2:1.4
	carlton_dictionary-20021223-merge:1.6
	gdb_5_3-2002-12-12-release:1.5
	carlton_dictionary-20021115-merge:1.5
	binutils-2_13_1:1.4
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.8
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.6
	carlton_dictionary-20020920-branchpoint:1.5
	sid-20020905-branchpoint:1.5
	sid-20020905-branch:1.5.0.4
	gdb_5_3-branch:1.5.0.2
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.4
	cagney_sysregs-20020825-branch:1.4.0.16
	cagney_sysregs-20020825-branchpoint:1.4
	readline_4_3-import-branch:1.4.0.14
	readline_4_3-import-branchpoint:1.4
	binutils-2_13:1.4
	gdb_5_2_1-2002-07-23-release:1.4
	binutils-2_13-branchpoint:1.4
	binutils-2_13-branch:1.4.0.12
	kseitz_interps-20020528-branch:1.4.0.10
	kseitz_interps-20020528-branchpoint:1.4
	cagney_regbuf-20020515-branch:1.4.0.8
	cagney_regbuf-20020515-branchpoint:1.4
	binutils-2_12_1:1.4
	jimb-macro-020506-branch:1.4.0.6
	jimb-macro-020506-branchpoint:1.4
	gdb_5_2-2002-04-29-release:1.4
	binutils-2_12:1.4
	gdb_5_2-branch:1.4.0.4
	gdb_5_2-2002-03-03-branchpoint:1.4
	binutils-2_12-branch:1.4.0.2
	binutils-2_12-branchpoint:1.4
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	cygnus_cvs_20020108_pre:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.4
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.2
	gdb_5_1-2001-07-29-branchpoint:1.3
	binutils-2_11_2:1.2.4.1
	binutils-2_11_1:1.2.4.1
	binutils-2_11:1.2
	x86_64versiong3:1.2
	binutils-2_11-branch:1.2.0.4
	insight-precleanup-2001-01-01:1.2
	binutils-2_10_1:1.1.1.1.2.1
	binutils-2_10:1.1.1.1.2.1
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.20
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2013.10.10.17.19.49;	author roland;	state Exp;
branches;
next	1.19;

1.19
date	2013.04.03.14.42.10;	author nickc;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2013.01.24.11.14.05;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2013.01.15.08.45.45;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2012.10.04.10.30.06;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2012.08.01.00.41.35;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2012.05.17.15.13.26;	author nickc;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	2011.04.13.13.20.21;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2010.07.23.14.52.54;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2007.07.05.09.49.02;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2005.07.07.19.27.52;	author wilson;	state Exp;
branches;
next	1.9;

1.9
date	2005.07.01.11.16.33;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.07.07.34.31;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.04.11.04.38;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.30.08.39.46;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2002.08.30.08.28.08;	author amodra;	state Exp;
branches
	1.5.6.1
	1.5.8.1;
next	1.4;

1.4
date	2001.08.26.11.47.39;	author aj;	state Exp;
branches
	1.4.10.1;
next	1.3;

1.3
date	2001.03.13.22.58.37;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.14.04.16.58;	author amodra;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	99.05.03.07.29.00;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.19.2.1
date	2013.10.10.17.20.21;	author roland;	state Exp;
branches;
next	;

1.14.4.1
date	2012.09.04.14.01.41;	author gingold;	state Exp;
branches;
next	;

1.5.6.1
date	2002.12.23.19.39.38;	author carlton;	state Exp;
branches;
next	1.5.6.2;

1.5.6.2
date	2003.09.17.21.29.00;	author carlton;	state Exp;
branches;
next	;

1.5.8.1
date	2003.12.14.20.28.10;	author drow;	state Exp;
branches;
next	;

1.4.10.1
date	2002.10.01.00.46.45;	author kseitz;	state Exp;
branches;
next	;

1.2.4.1
date	2001.06.07.03.18.37;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.00;	author rth;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	2000.05.06.14.49.26;	author pb;	state Exp;
branches;
next	;


desc
@@


1.20
log
@opcodes/
	* v850-dis.c (v850_cacheop_codes, v850_prefop_codes):
	Remove duplicate const qualifier.
@
text
@/* Disassemble V850 instructions.
   Copyright 1996-2013 Free Software Foundation, Inc.

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


#include "sysdep.h"
#include <stdio.h>
#include <string.h>
#include "opcode/v850.h"
#include "dis-asm.h"
#include "opintl.h"

static const char *const v850_reg_names[] =
{
  "r0", "r1", "r2", "sp", "gp", "r5", "r6", "r7",
  "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
  "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",
  "r24", "r25", "r26", "r27", "r28", "r29", "ep", "lp"
};

static const char *const v850_sreg_names[] =
{
  "eipc/vip/mpm", "eipsw/mpc", "fepc/tid", "fepsw/ppa", "ecr/vmecr", "psw/vmtid",
  "sr6/fpsr/vmadr/dcc", "sr7/fpepc/dc0",
  "sr8/fpst/vpecr/dcv1", "sr9/fpcc/vptid", "sr10/fpcfg/vpadr/spal", "sr11/spau",
  "sr12/vdecr/ipa0l", "eiic/vdtid/ipa0u", "feic/ipa1l", "dbic/ipa1u",
  "ctpc/ipa2l", "ctpsw/ipa2u", "dbpc/ipa3l", "dbpsw/ipa3u", "ctbp/dpa0l",
  "dir/dpa0u", "bpc/dpa0u", "asid/dpa1l",
  "bpav/dpa1u", "bpam/dpa2l", "bpdv/dpa2u", "bpdm/dpa3l", "eiwr/dpa3u",
  "fewr", "dbwr", "bsel"
};

static const char *const v850_cc_names[] =
{
  "v", "c/l", "z", "nh", "s/n", "t", "lt", "le",
  "nv", "nc/nl", "nz", "h", "ns/p", "sa", "ge", "gt"
};

static const char *const v850_float_cc_names[] =
{
  "f/t", "un/or", "eq/neq", "ueq/ogl", "olt/uge", "ult/oge", "ole/ugt", "ule/ogt",
  "sf/st", "ngle/gle", "seq/sne", "ngl/gl", "lt/nlt", "nge/ge", "le/nle", "ngt/gt"
};


static const char *const v850_vreg_names[] =
{
  "vr0", "vr1", "vr2", "vr3", "vr4", "vr5", "vr6", "vr7", "vr8", "vr9",
  "vr10", "vr11", "vr12", "vr13", "vr14", "vr15", "vr16", "vr17", "vr18",
  "vr19", "vr20", "vr21", "vr22", "vr23", "vr24", "vr25", "vr26", "vr27",
  "vr28", "vr29", "vr30", "vr31"
};

static const char *const v850_cacheop_names[] =
{
  "chbii", "cibii", "cfali", "cisti", "cildi", "chbid", "chbiwbd",
  "chbwbd", "cibid", "cibiwbd", "cibwbd", "cfald", "cistd", "cildd"
};

static const int v850_cacheop_codes[] =
{
  0x00, 0x20, 0x40, 0x60, 0x61, 0x04, 0x06,
  0x07, 0x24, 0x26, 0x27, 0x44, 0x64, 0x65, -1
};

static const char *const v850_prefop_names[] =
{ "prefi", "prefd" };

static const int v850_prefop_codes[] =
{ 0x00, 0x04, -1};

static void
print_value (int flags,
	     bfd_vma memaddr,
	     struct disassemble_info *info,
	     long value)
{
  if (flags & V850_PCREL)
    {
      bfd_vma addr = value + memaddr;

      if (flags & V850_INVERSE_PCREL)
	addr = memaddr - value;
      info->print_address_func (addr, info);
    }
  else if (flags & V850_OPERAND_DISP)
    {
      if (flags & V850_OPERAND_SIGNED)
        {
          info->fprintf_func (info->stream, "%ld", value);
        }
      else
        {
          info->fprintf_func (info->stream, "%lu", value);
        }
    }
  else if ((flags & V850E_IMMEDIATE32)
	   || (flags & V850E_IMMEDIATE16HI))
    {
      info->fprintf_func (info->stream, "0x%lx", value);
    }
  else
    {
      if (flags & V850_OPERAND_SIGNED)
	{
	  info->fprintf_func (info->stream, "%ld", value);
	}
      else
	{
	  info->fprintf_func (info->stream, "%lu", value);
	}
    }
}

static long
get_operand_value (const struct v850_operand *operand,
		   unsigned long insn,
		   int bytes_read,
		   bfd_vma memaddr,
		   struct disassemble_info * info,
		   bfd_boolean noerror,
		   int *invalid)
{
  long value;
  bfd_byte buffer[4];

  if ((operand->flags & V850E_IMMEDIATE16)
      || (operand->flags & V850E_IMMEDIATE16HI))
    {
      int status = info->read_memory_func (memaddr + bytes_read, buffer, 2, info);

      if (status == 0)
	{
	  value = bfd_getl16 (buffer);

	  if (operand->flags & V850E_IMMEDIATE16HI)
	    value <<= 16;
	  else if (value & 0x8000)
	    value |= (-1L << 16);

	  return value;
	}

      if (!noerror)
	info->memory_error_func (status, memaddr + bytes_read, info);

      return 0;
    }

  if (operand->flags & V850E_IMMEDIATE23)
    {
      int status = info->read_memory_func (memaddr + 2, buffer, 4, info);

      if (status == 0)
	{
	  value = bfd_getl32 (buffer);

	  value = (operand->extract) (value, invalid);

	  return value;
	}

      if (!noerror)
	info->memory_error_func (status, memaddr + bytes_read, info);

      return 0;
    }

  if (operand->flags & V850E_IMMEDIATE32)
    {
      int status = info->read_memory_func (memaddr + bytes_read, buffer, 4, info);

      if (status == 0)
	{
	  bytes_read += 4;
	  value = bfd_getl32 (buffer);

	  return value;
	}

      if (!noerror)
	info->memory_error_func (status, memaddr + bytes_read, info);

      return 0;
    }

  if (operand->extract)
    value = (operand->extract) (insn, invalid);
  else
    {
      if (operand->bits == -1)
	value = (insn & operand->shift);
      else
	value = (insn >> operand->shift) & ((1 << operand->bits) - 1);

      if (operand->flags & V850_OPERAND_SIGNED)
	value = ((long)(value << (sizeof (long)*8 - operand->bits))
		 >> (sizeof (long)*8 - operand->bits));
    }

  return value;
}


static int
disassemble (bfd_vma memaddr,
	     struct disassemble_info *info,
	     int bytes_read,
	     unsigned long insn)
{
  struct v850_opcode *op = (struct v850_opcode *) v850_opcodes;
  const struct v850_operand *operand;
  int match = 0;
  int target_processor;

  switch (info->mach)
    {
    case 0:
    default:
      target_processor = PROCESSOR_V850;
      break;

    case bfd_mach_v850e:
      target_processor = PROCESSOR_V850E;
      break;

    case bfd_mach_v850e1:
      target_processor = PROCESSOR_V850E;
      break;

    case bfd_mach_v850e2:
      target_processor = PROCESSOR_V850E2;
      break;

    case bfd_mach_v850e2v3:
      target_processor = PROCESSOR_V850E2V3;
      break;

    case bfd_mach_v850e3v5:
      target_processor = PROCESSOR_V850E3V5;
      break;
    }

  /* If this is a two byte insn, then mask off the high bits.  */
  if (bytes_read == 2)
    insn &= 0xffff;

  /* Find the opcode.  */
  while (op->name)
    {
      if ((op->mask & insn) == op->opcode
	  && (op->processors & target_processor)
	  && !(op->processors & PROCESSOR_OPTION_ALIAS))
	{
	  /* Code check start.  */
	  const unsigned char *opindex_ptr;
	  unsigned int opnum;
	  unsigned int memop;

	  for (opindex_ptr = op->operands, opnum = 1;
	       *opindex_ptr != 0;
	       opindex_ptr++, opnum++)
	    {
	      int invalid = 0;
	      long value;

	      operand = &v850_operands[*opindex_ptr];

	      value = get_operand_value (operand, insn, bytes_read, memaddr,
					 info, 1, &invalid);

	      if (invalid)
		goto next_opcode;

              if ((operand->flags & V850_NOT_R0) && value == 0 && (op->memop) <=2)
		goto next_opcode;

	      if ((operand->flags & V850_NOT_SA) && value == 0xd)
		goto next_opcode;

	      if ((operand->flags & V850_NOT_IMM0) && value == 0)
		goto next_opcode;
	    }

	  /* Code check end.  */

	  match = 1;
	  (*info->fprintf_func) (info->stream, "%s\t", op->name);
#if 0
	  fprintf (stderr, "match: insn: %lx, mask: %lx, opcode: %lx, name: %s\n",
		   insn, op->mask, op->opcode, op->name );
#endif

	  memop = op->memop;
	  /* Now print the operands.

	     MEMOP is the operand number at which a memory
	     address specification starts, or zero if this
	     instruction has no memory addresses.

	     A memory address is always two arguments.

	     This information allows us to determine when to
	     insert commas into the output stream as well as
	     when to insert disp[reg] expressions onto the
	     output stream.  */

	  for (opindex_ptr = op->operands, opnum = 1;
	       *opindex_ptr != 0;
	       opindex_ptr++, opnum++)
	    {
	      bfd_boolean square = FALSE;
	      long value;
	      int flag;
	      char *prefix;

	      operand = &v850_operands[*opindex_ptr];

	      value = get_operand_value (operand, insn, bytes_read, memaddr,
					 info, 0, 0);

	      /* The first operand is always output without any
		 special handling.

		 For the following arguments:

		   If memop && opnum == memop + 1, then we need '[' since
		   we're about to output the register used in a memory
		   reference.

		   If memop && opnum == memop + 2, then we need ']' since
		   we just finished the register in a memory reference.  We
		   also need a ',' before this operand.

		   Else we just need a comma.

		   We may need to output a trailing ']' if the last operand
		   in an instruction is the register for a memory address.

		   The exception (and there's always an exception) are the
		   "jmp" insn which needs square brackets around it's only
		   register argument, and the clr1/not1/set1/tst1 insns
		   which [...] around their second register argument.  */

	      prefix = "";
	      if (operand->flags & V850_OPERAND_BANG)
		{
		  prefix = "!";
		}
	      else if (operand->flags & V850_OPERAND_PERCENT)
		{
		  prefix = "%";
		}

	      if (opnum == 1 && opnum == memop)
		{
		  info->fprintf_func (info->stream, "%s[", prefix);
		  square = TRUE;
		}
	      else if (   (strcmp ("stc.w", op->name) == 0
			|| strcmp ("cache", op->name) == 0
			|| strcmp ("pref",  op->name) == 0)
		       && opnum == 2 && opnum == memop)
		{
		  info->fprintf_func (info->stream, ", [");
		  square = TRUE;
		}
	      else if (   (strcmp (op->name, "pushsp") == 0
			|| strcmp (op->name, "popsp") == 0
			|| strcmp (op->name, "dbpush" ) == 0)
		       && opnum == 2)
		{
		  info->fprintf_func (info->stream, "-");
		}
	      else if (opnum > 1
		       && (v850_operands[*(opindex_ptr - 1)].flags
			   & V850_OPERAND_DISP) != 0
		       && opnum == memop)
		{
		  info->fprintf_func (info->stream, "%s[", prefix);
		  square = TRUE;
		}
	      else if (opnum == 2
		       && (   op->opcode == 0x00e407e0 /* clr1 */
			   || op->opcode == 0x00e207e0 /* not1 */
			   || op->opcode == 0x00e007e0 /* set1 */
			   || op->opcode == 0x00e607e0 /* tst1 */
			   ))
		{
		  info->fprintf_func (info->stream, ", %s[", prefix);
		  square = TRUE;
		}
	      else if (opnum > 1)
		info->fprintf_func (info->stream, ", %s", prefix);

 	      /* Extract the flags, ignoring ones which do not
		 effect disassembly output.  */
	      flag = operand->flags & (V850_OPERAND_REG
				       | V850_REG_EVEN
				       | V850_OPERAND_EP
				       | V850_OPERAND_SRG
				       | V850E_OPERAND_REG_LIST
				       | V850_OPERAND_CC
				       | V850_OPERAND_VREG
				       | V850_OPERAND_CACHEOP
				       | V850_OPERAND_PREFOP
				       | V850_OPERAND_FLOAT_CC);

	      switch (flag)
		{
		case V850_OPERAND_REG:
		  info->fprintf_func (info->stream, "%s", v850_reg_names[value]);
		  break;
		case (V850_OPERAND_REG|V850_REG_EVEN):
		  info->fprintf_func (info->stream, "%s", v850_reg_names[value * 2]);
		  break;
		case V850_OPERAND_EP:
		  info->fprintf_func (info->stream, "ep");
		  break;
		case V850_OPERAND_SRG:
		  info->fprintf_func (info->stream, "%s", v850_sreg_names[value]);
		  break;
		case V850E_OPERAND_REG_LIST:
		  {
		    static int list12_regs[32]   = { 30, 0, 0, 0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
						     0,  0, 0, 0, 0, 31, 29, 28, 23, 22, 21, 20, 27, 26, 25, 24 };
		    int *regs;
		    int i;
		    unsigned long int mask = 0;
		    int pc = 0;

		    switch (operand->shift)
		      {
		      case 0xffe00001: regs = list12_regs; break;
		      default:
			/* xgettext:c-format */
			fprintf (stderr, _("unknown operand shift: %x\n"), operand->shift);
			abort ();
		      }

		    for (i = 0; i < 32; i++)
		      {
			if (value & (1 << i))
			  {
			    switch (regs[ i ])
			      {
			      default: mask |= (1 << regs[ i ]); break;
				/* xgettext:c-format */
			      case 0:  fprintf (stderr, _("unknown reg: %d\n"), i ); abort ();
			      case -1: pc = 1; break;
			      }
			  }
		      }

		    info->fprintf_func (info->stream, "{");

		    if (mask || pc)
		      {
			if (mask)
			  {
			    unsigned int bit;
			    int shown_one = 0;

			    for (bit = 0; bit < 32; bit++)
			      if (mask & (1 << bit))
				{
				  unsigned long int first = bit;
				  unsigned long int last;

				  if (shown_one)
				    info->fprintf_func (info->stream, ", ");
				  else
				    shown_one = 1;

				  info->fprintf_func (info->stream, "%s", v850_reg_names[first]);

				  for (bit++; bit < 32; bit++)
				    if ((mask & (1 << bit)) == 0)
				      break;

				  last = bit;

				  if (last > first + 1)
				    {
				      info->fprintf_func (info->stream, " - %s", v850_reg_names[ last - 1 ]);
				    }
				}
			  }

			if (pc)
			  info->fprintf_func (info->stream, "%sPC", mask ? ", " : "");
		      }

		    info->fprintf_func (info->stream, "}");
		  }
		  break;

		case V850_OPERAND_CC:
		  info->fprintf_func (info->stream, "%s", v850_cc_names[value]);
		  break;

		case V850_OPERAND_FLOAT_CC:
		  info->fprintf_func (info->stream, "%s", v850_float_cc_names[value]);
		  break;

		case V850_OPERAND_CACHEOP:
		  {
		    int idx;

		    for (idx = 0; v850_cacheop_codes[idx] != -1; idx++)
		      {
			if (value == v850_cacheop_codes[idx])
			  {
			    info->fprintf_func (info->stream, "%s",
						v850_cacheop_names[idx]);
			    goto MATCH_CACHEOP_CODE;
			  }
		      }
		    info->fprintf_func (info->stream, "%d", (int) value);
		  }
		MATCH_CACHEOP_CODE:
		  break;

		case V850_OPERAND_PREFOP:
		  {
		    int idx;

		    for (idx = 0; v850_prefop_codes[idx] != -1; idx++)
		      {
			if (value == v850_prefop_codes[idx])
			  {
			    info->fprintf_func (info->stream, "%s",
			      v850_prefop_names[idx]);
			    goto MATCH_PREFOP_CODE;
			  }
		      }
		    info->fprintf_func (info->stream, "%d", (int) value);
		  }
		MATCH_PREFOP_CODE:
		  break;

		case V850_OPERAND_VREG:
		  info->fprintf_func (info->stream, "%s", v850_vreg_names[value]);
		  break;

		default:
		  print_value (operand->flags, memaddr, info, value);
		  break;
		}

	      if (square)
		(*info->fprintf_func) (info->stream, "]");
	    }

	  /* All done. */
	  break;
	}
    next_opcode:
      op++;
    }

  return match;
}

int
print_insn_v850 (bfd_vma memaddr, struct disassemble_info * info)
{
  int status, status2, match;
  bfd_byte buffer[8];
  int length = 0, code_length = 0;
  unsigned long insn = 0, insn2 = 0;
  int target_processor;

  switch (info->mach)
    {
    case 0:
    default:
      target_processor = PROCESSOR_V850;
      break;

    case bfd_mach_v850e:
      target_processor = PROCESSOR_V850E;
      break;

    case bfd_mach_v850e1:
      target_processor = PROCESSOR_V850E;
      break;

    case bfd_mach_v850e2:
      target_processor = PROCESSOR_V850E2;
      break;

    case bfd_mach_v850e2v3:
      target_processor = PROCESSOR_V850E2V3;
      break;

    case bfd_mach_v850e3v5:
      target_processor = PROCESSOR_V850E3V5;
      break;
    }

  status = info->read_memory_func (memaddr, buffer, 2, info);

  if (status)
    {
      info->memory_error_func (status, memaddr, info);
      return -1;
    }

  insn = bfd_getl16 (buffer);

  status2 = info->read_memory_func (memaddr+2, buffer, 2 , info);

  if (!status2)
    {
      insn2 = bfd_getl16 (buffer);
      /* fprintf (stderr, "insn2 0x%08lx\n", insn2); */
    }

  /* Special case.  */
  if (length == 0
      && ((target_processor & PROCESSOR_V850E2_UP) != 0))
    {
      if ((insn & 0xffff) == 0x02e0		/* jr 32bit */
	  && !status2 && (insn2 & 0x1) == 0)
	{
	  length = 2;
	  code_length = 6;
	}
      else if ((insn & 0xffe0) == 0x02e0	/* jarl 32bit */
	       && !status2 && (insn2 & 0x1) == 0)
	{
	  length = 2;
	  code_length = 6;
	}
      else if ((insn & 0xffe0) == 0x06e0	/* jmp 32bit */
	       && !status2 && (insn2 & 0x1) == 0)
	{
	  length = 2;
	  code_length = 6;
	}
    }

  if (length == 0
      && ((target_processor & PROCESSOR_V850E3V5_UP) != 0))
    {
      if (   ((insn & 0xffe0) == 0x07a0		/* ld.dw 23bit (v850e3v5) */
	      && !status2 && (insn2 & 0x000f) == 0x0009)
	  || ((insn & 0xffe0) == 0x07a0		/* st.dw 23bit (v850e3v5) */
	      && !status2 && (insn2 & 0x000f) == 0x000f))
	{
	  length = 4;
	  code_length = 6;
	}
    }

  if (length == 0
      && ((target_processor & PROCESSOR_V850E2V3_UP) != 0))
    {
      if (((insn & 0xffe0) == 0x0780		/* ld.b 23bit */
	   && !status2 && (insn2 & 0x000f) == 0x0005)
	  || ((insn & 0xffe0) == 0x07a0		/* ld.bu 23bit */
	      && !status2 && (insn2 & 0x000f) == 0x0005)
	  || ((insn & 0xffe0) == 0x0780		/* ld.h 23bit */
	      && !status2 && (insn2 & 0x000f) == 0x0007)
	  || ((insn & 0xffe0) == 0x07a0		/* ld.hu 23bit */
	      && !status2 && (insn2 & 0x000f) == 0x0007)
	  || ((insn & 0xffe0) == 0x0780		/* ld.w 23bit */
	      && !status2 && (insn2 & 0x000f) == 0x0009))
	{
	  length = 4;
	  code_length = 6;
	}
      else if (((insn & 0xffe0) == 0x0780	/* st.b 23bit */
	       && !status2 && (insn2 & 0x000f) == 0x000d)
	      || ((insn & 0xffe0) == 0x07a0	/* st.h 23bit */
		  && !status2 && (insn2 & 0x000f) == 0x000d)
	      || ((insn & 0xffe0) == 0x0780	/* st.w 23bit */
		  && !status2 && (insn2 & 0x000f) == 0x000f))
	{
	  length = 4;
	  code_length = 6;
	}
    }

  if (length == 0
      && target_processor != PROCESSOR_V850)
    {
      if ((insn & 0xffe0) == 0x0620)		/* 32 bit MOV */
	{
	  length = 2;
	  code_length = 6;
	}
      else if ((insn & 0xffc0) == 0x0780	/* prepare {list}, imm5, imm16<<16 */
	       && !status2 && (insn2 & 0x001f) == 0x0013)
	{
	  length = 4;
	  code_length = 6;
	}
      else if ((insn & 0xffc0) == 0x0780	/* prepare {list}, imm5, imm16 */
	       && !status2 && (insn2 & 0x001f) == 0x000b)
	{
	  length = 4;
	  code_length = 6;
	}
      else if ((insn & 0xffc0) == 0x0780	/* prepare {list}, imm5, imm32 */
	       && !status2 && (insn2 & 0x001f) == 0x001b)
	{
	  length = 4;
	  code_length = 8;
	}
    }

  if (length == 4
      || (length == 0
	  && (insn & 0x0600) == 0x0600))
    {
      /* This is a 4 byte insn.  */
      status = info->read_memory_func (memaddr, buffer, 4, info);
      if (!status)
	{
	  insn = bfd_getl32 (buffer);

	  if (!length)
	    length = code_length = 4;
	}
    }

  if (code_length > length)
    {
      status = info->read_memory_func (memaddr + length, buffer, code_length - length, info);
      if (status)
	length = 0;
    }

  if (length == 0 && !status)
    length = code_length = 2;

  if (length == 2)
    insn &= 0xffff;

  /* when the last 2 bytes of section is 0xffff, length will be 0 and cause infinitive loop */
  if (length == 0)
    return -1;

  match = disassemble (memaddr, info, length, insn);

  if (!match)
    {
      int l = 0;

      status = info->read_memory_func (memaddr, buffer, code_length, info);

      while (l < code_length)
	{
	  if (code_length - l == 2)
	    {
	      insn = bfd_getl16 (buffer + l) & 0xffff;
	      info->fprintf_func (info->stream, ".short\t0x%04lx", insn);
	      l += 2;
	    }
	  else
	    {
	      insn = bfd_getl32 (buffer + l);
	      info->fprintf_func (info->stream, ".long\t0x%08lx", insn);
	      l += 4;
	    }
	}
    }

  return code_length;
}
@


1.19
log
@	* elf32-v850.c (v850_elf_is_target_special_symbol): New function.
	(bfd_elf32_bfd_is_target_special_symbol): Define.

	* v850.h (V850_INVERSE_PCREL): Define.

	* v850-dis.c (print_value): With V850_INVERSE_PCREL compute the
	destination address by subtracting the operand from the current
	address.
	* v850-opc.c (insert_u16_loop): Disallow negative offsets.  Store
	a positive value in the insn.
	(extract_u16_loop): Do not negate the returned value.
	(D16_LOOP): Add V850_INVERSE_PCREL flag.

	(ceilf.sw): Remove duplicate entry.
	(cvtf.hs): New entry.
	(cvtf.sh): Likewise.
	(fmaf.s): Likewise.
	(fmsf.s): Likewise.
	(fnmaf.s): Likewise.
	(fnmsf.s): Likewise.
	(maddf.s): Restrict to E3V5 architectures.
	(msubf.s): Likewise.
	(nmaddf.s): Likewise.
	(nmsubf.s): Likewise.
@
text
@d76 1
a76 1
static const int const v850_cacheop_codes[] =
d85 1
a85 1
static const int const v850_prefop_codes[] =
d408 1
a408 1
		}		
@


1.19.2.1
log
@opcodes/
	* v850-dis.c (v850_cacheop_codes, v850_prefop_codes):
	Remove duplicate const qualifier.
@
text
@d76 1
a76 1
static const int v850_cacheop_codes[] =
d85 1
a85 1
static const int v850_prefop_codes[] =
d408 1
a408 1
		}
@


1.18
log
@Add support for V850E3V5 architecture
@
text
@d97 3
@


1.17
log
@	* config/tc-v850.c (md_assemble): Allow signed values for
	V850E_IMMEDIATE.

	* gas/v850/basic.exp: Allow for variations in reloc names.
	* gas/v850/split-lo16.d: Likewise.

	* gas/v850/v850e1.s: Add more tests of the PREPARE insn.
	* gas/v850/v850e1.d: Update expected disassembly.

	* v850-dis.c (get_operand_value): Sign extend V850E_IMMEDIATE
	values.
	* v850-opc.c (IMM16LO): Add V850_OPERAND_SIGNED attribute.
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2005, 2007, 2010,
   2012  Free Software Foundation, Inc.
d24 1
d62 26
d89 4
a92 1
print_value (int flags, bfd_vma memaddr, struct disassemble_info *info, long value)
d110 2
a111 1
  else if (flags & V850E_IMMEDIATE32)
d219 4
a222 1
disassemble (bfd_vma memaddr, struct disassemble_info *info, int bytes_read, unsigned long insn)
d224 1
a224 1
  struct v850_opcode *op = (struct v850_opcode *)v850_opcodes;
d251 4
d282 2
a283 1
	      value = get_operand_value (operand, insn, bytes_read, memaddr, info, 1, &invalid);
d332 2
a333 1
	      value = get_operand_value (operand, insn, bytes_read, memaddr, info, 0, 0);
d373 15
d389 2
a390 1
		       && (v850_operands[*(opindex_ptr - 1)].flags & V850_OPERAND_DISP) != 0
d409 2
a410 1
 	      /* Extract the flags, ignoring ones which do not effect disassembly output.  */
d417 3
d424 12
a435 5
		case V850_OPERAND_REG:  info->fprintf_func (info->stream, "%s", v850_reg_names[value]); break;
		case (V850_OPERAND_REG|V850_REG_EVEN):  info->fprintf_func (info->stream, "%s", v850_reg_names[value*2]); break;
		case V850_OPERAND_EP:   info->fprintf_func (info->stream, "ep"); break;
		case V850_OPERAND_SRG:  info->fprintf_func (info->stream, "%s", v850_sreg_names[value]); break;

a444 1

d450 1
a450 1
			fprintf (stderr, _("unknown operand shift: %x\n"), operand->shift );
d511 47
a557 2
		case V850_OPERAND_CC:   info->fprintf_func (info->stream, "%s", v850_cc_names[value]); break;
		case V850_OPERAND_FLOAT_CC:   info->fprintf_func (info->stream, "%s", v850_float_cc_names[value]); break;
d609 4
d635 1
a635 2
      && (target_processor == PROCESSOR_V850E2
	  || target_processor == PROCESSOR_V850E2V3))
d658 14
a671 1
      && target_processor == PROCESSOR_V850E2V3)
d755 4
@


1.16
log
@	* v850-dis.c (disassemble): Place square parentheses around second
	register operand of clr1, not1, set1 and tst1 instructions.

	* config/tc-v850.c (v850_insert_operand): Use a static buffer for
	the error message.

	* gas/v850/v850e1.d: Fix expected disassembly of clr1, not1, set1
	and tst1 insns.
@
text
@d121 2
@


1.15
log
@	* h8300-dis.c: Fix printf arg warnings.
	* i960-dis.c: Likewise.
	* mips-dis.c: Likewise.
	* pdp11-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* configure.in: Formatting.
	* configure: Regenerate.
	* rl78-decode.c: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d312 1
a312 1
		   The exception (and there's always an exception) is the
d314 3
a316 1
		   register argument.  */
d339 10
@


1.14
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@d409 1
a409 1
				  info->fprintf_func (info->stream, v850_reg_names[first]);
@


1.14.4.1
log
@gas/
	* config/tc-mips.c (ISA_SUPPORTS_DSP_ASE): Also set if microMIPS
	mode.
	(ISA_SUPPORTS_DSPR2_ASE): Likewise.
	(macro_build) <'2'>: Handle microMIPS.
2012-07-31  Maciej W. Rozycki  <macro@@codesourcery.com>
            Chao-Ying Fu  <fu@@mips.com>
            Catherine Moore  <clm@@codesourcery.com>

gas/
	* gas/mips/micromips@@mips32-dsp.d: New test.
	* gas/mips/micromips@@mips32-dspr2.d: New test.
	* gas/mips/mips32-dsp.s: Update padding.
	* gas/mips/mips32-dspr2.s: Likewise.
	* gas/mips/mips.exp: Use run_dump_test_arches to run MIPS32 DSP
	tests.
2012-07-31  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

include/
2012-07-31  Chao-Ying Fu  <fu@@mips.com>
            Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

opcodes/
2012-08-01  Alan Modra  <amodra@@gmail.com>

	* h8300-dis.c: Fix printf arg warnings.
	* i960-dis.c: Likewise.
	* mips-dis.c: Likewise.
	* pdp11-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* configure.in: Formatting.
	* configure: Regenerate.
	* rl78-decode.c: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d409 1
a409 1
				  info->fprintf_func (info->stream, "%s", v850_reg_names[first]);
@


1.13
log
@	* v850-dis.c (disassemble): Always print a closing square brace if
	an opening square brace was printed.
@
text
@d2 2
a3 2
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2005, 2007, 2010
   Free Software Foundation, Inc.
d23 1
a24 2

#include "sysdep.h"
@


1.12
log
@Add support for v850E2 and v850E2V3
@
text
@d286 1
d327 4
a330 1
		info->fprintf_func (info->stream, "%s[", prefix);
d334 4
a337 1
		info->fprintf_func (info->stream, "%s[", prefix);
d441 1
a441 1
	      if (opnum == 2 && opnum == memop)
@


1.11
log
@Change source files over to GPLv3.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2005, 2007
d31 2
a32 1
{ "r0", "r1", "r2", "sp", "gp", "r5", "r6", "r7",
d35 2
a36 1
  "r24", "r25", "r26", "r27", "r28", "r29", "ep", "lp" };
d39 10
a48 6
{ "eipc", "eipsw", "fepc", "fepsw", "ecr", "psw", "sr6", "sr7",
  "sr8", "sr9", "sr10", "sr11", "sr12", "sr13", "sr14", "sr15",
  "ctpc", "ctpsw", "dbpc", "dbpsw", "ctbp", "sr21", "sr22", "sr23",
  "sr24", "sr25", "sr26", "sr27", "sr28", "sr29", "sr30", "sr31",
  "sr16", "sr17", "sr18", "sr19", "sr20", "sr21", "sr22", "sr23",
  "sr24", "sr25", "sr26", "sr27", "sr28", "sr29", "sr30", "sr31" };
d51 135
a185 2
{ "v", "c/l", "z", "nh", "s/n", "t", "lt", "le",
  "nv", "nc/nl", "nz", "h", "ns/p", "sa", "ge", "gt" };
d188 1
a188 3
disassemble (bfd_vma memaddr,
	     struct disassemble_info * info,
	     unsigned long insn)
d190 2
a191 2
  struct v850_opcode * op = (struct v850_opcode *) v850_opcodes;
  const struct v850_operand * operand;
a192 2
  int short_op = ((insn & 0x0600) != 0x0600);
  int bytes_read;
a194 10
  /* Special case: 32 bit MOV.  */
  if ((insn & 0xffe0) == 0x0620)
    short_op = 1;

  bytes_read = short_op ? 2 : 4;

  /* If this is a two byte insn, then mask off the high bits.  */
  if (short_op)
    insn &= 0xffff;

d207 9
a215 1
      target_processor = PROCESSOR_V850E1;
d219 4
d227 2
a228 1
	  && (op->processors & target_processor))
d230 1
d235 26
d263 4
d288 1
a288 2
	      int status;
	      bfd_byte buffer[4];
d292 1
a292 13
	      if (operand->extract)
		value = (operand->extract) (insn, 0);
	      else
		{
		  if (operand->bits == -1)
		    value = (insn & operand->shift);
		  else
		    value = (insn >> operand->shift) & ((1 << operand->bits) - 1);

		  if (operand->flags & V850_OPERAND_SIGNED)
		    value = ((long)(value << (32 - operand->bits))
			     >> (32 - operand->bits));
		}
d315 9
d325 17
a341 16
	           if (memop && opnum == memop + 1)
		     info->fprintf_func (info->stream, "[");
		   else if (memop && opnum == memop + 2)
		     info->fprintf_func (info->stream, "],");
		   else if (memop == 1 && opnum == 1
			    && (operand->flags & V850_OPERAND_REG))
		     info->fprintf_func (info->stream, "[");
		   else if (opnum > 1)
		     info->fprintf_func (info->stream, ", ");

	      /* Extract the flags, ignorng ones which
		 do not effect disassembly output. */
	      flag = operand->flags;
	      flag &= ~ V850_OPERAND_SIGNED;
	      flag &= ~ V850_OPERAND_RELAX;
	      flag &= - flag;
d345 4
a348 18
		case V850_OPERAND_REG:
		  info->fprintf_func (info->stream, "%s", v850_reg_names[value]);
		  break;
		case V850_OPERAND_SRG:
		  info->fprintf_func (info->stream, "%s", v850_sreg_names[value]);
		  break;
		case V850_OPERAND_CC:
		  info->fprintf_func (info->stream, "%s", v850_cc_names[value]);
		  break;
		case V850_OPERAND_EP:
		  info->fprintf_func (info->stream, "ep");
		  break;
		default:
		  info->fprintf_func (info->stream, "%ld", value);
		  break;
		case V850_OPERAND_DISP:
		  {
		    bfd_vma addr = value + memaddr;
d350 1
a350 21
		    /* On the v850 the top 8 bits of an address are used by an
		       overlay manager.  Thus it may happen that when we are
		       looking for a symbol to match against an address with
		       some of its top bits set, the search fails to turn up an
		       exact match.  In this case we try to find an exact match
		       against a symbol in the lower address space, and if we
		       find one, we use that address.   We only do this for
		       JARL instructions however, as we do not want to
		       misinterpret branch instructions.  */
		    if (operand->bits == 22)
		      {
			if ( ! info->symbol_at_address_func (addr, info)
			    && ((addr & 0xFF000000) != 0)
			    && info->symbol_at_address_func (addr & 0x00FFFFFF, info))
			  addr &= 0x00FFFFFF;
		      }
		    info->print_address_func (addr, info);
		    break;
		  }

		case V850E_PUSH_POP:
d352 2
a353 3
		    static int list12_regs[32]   = { 30,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0, 31, 29, 28, 23, 22, 21, 20, 27, 26, 25, 24 };
		    static int list18_h_regs[32] = { 19, 18, 17, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 30, 31, 29, 28, 23, 22, 21, 20, 27, 26, 25, 24 };
		    static int list18_l_regs[32] = {  3,  2,  1, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 14, 15, 13, 12,  7,  6,  5,  4, 11, 10,  9,  8 };
d358 1
a358 1
		    int sr = 0;
a362 5
		      case 0xfff8000f: regs = list18_h_regs; break;
		      case 0xfff8001f:
			regs = list18_l_regs;
			value &= ~0x10;  /* Do not include magic bit.  */
			  break;
d365 1
a365 2
			fprintf (stderr, _("unknown operand shift: %x\n"),
				 operand->shift);
d377 1
a377 3
			      case 0:
				fprintf (stderr, _("unknown pop reg: %d\n"), i );
				abort ();
a378 1
			      case -2: sr = 1; break;
d385 1
a385 1
		    if (mask || pc || sr)
d403 1
a403 2
				  info->fprintf_func (info->stream,
						      v850_reg_names[first]);
d412 3
a414 2
				    info->fprintf_func (info->stream, " - %s",
							v850_reg_names[last - 1]);
a419 2
			if (sr)
			  info->fprintf_func (info->stream, "%sSR", (mask || pc) ? ", " : "");
d424 1
a424 1
		break;
d426 2
a427 19
		case V850E_IMMEDIATE16:
		  status = info->read_memory_func (memaddr + bytes_read,
						   buffer, 2, info);
		  if (status == 0)
		    {
		      bytes_read += 2;
		      value = bfd_getl16 (buffer);

		      /* If this is a DISPOSE instruction with ff
			 set to 0x10, then shift value up by 16.  */
		      if ((insn & 0x001fffc0) == 0x00130780)
			value <<= 16;

		      info->fprintf_func (info->stream, "0x%lx", value);
		    }
		  else
		    info->memory_error_func (status, memaddr + bytes_read,
					     info);
		  break;
d429 2
a430 12
		case V850E_IMMEDIATE32:
		  status = info->read_memory_func (memaddr + bytes_read,
						   buffer, 4, info);
		  if (status == 0)
		    {
		      bytes_read += 4;
		      value = bfd_getl32 (buffer);
		      info->fprintf_func (info->stream, "0x%lx", value);
		    }
		  else
		    info->memory_error_func (status, memaddr + bytes_read,
					     info);
d434 1
a434 3
	      /* Handle jmp correctly.  */
	      if (memop == 1 && opnum == 1
		  && ((operand->flags & V850_OPERAND_REG) != 0))
a437 4
	  /* Close any square bracket we left open.  */
	  if (memop && opnum == memop + 2)
	    (*info->fprintf_func) (info->stream, "]");

d441 1
d445 1
a445 9
  if (!match)
    {
      if (short_op)
	info->fprintf_func (info->stream, ".short\t0x%04lx", insn);
      else
	info->fprintf_func (info->stream, ".long\t0x%08lx", insn);
    }

  return bytes_read;
d451 29
a479 3
  int status;
  bfd_byte buffer[4];
  unsigned long insn = 0;
a480 1
  /* First figure out how big the opcode is.  */
d482 2
a483 1
  if (status == 0)
d485 3
a487 1
      insn = bfd_getl16 (buffer);
d489 99
a587 2
      if (   (insn & 0x0600) == 0x0600
	  && (insn & 0xffe0) != 0x0620)
d589 1
a589 2
	  /* If this is a 4 byte insn, read 4 bytes of stuff.  */
	  status = info->read_memory_func (memaddr, buffer, 4, info);
d591 2
a592 2
	  if (status == 0)
	    insn = bfd_getl32 (buffer);
d596 16
a611 1
  if (status != 0)
d613 19
a631 2
      info->memory_error_func (status, memaddr, info);
      return -1;
d634 1
a634 2
  /* Make sure we tell our caller how many bytes we consumed.  */
  return disassemble (memaddr, info, insn);
@


1.10
log
@Kaveh Ghazi's printf format attribute checking patch.
bfd:
	* elf32-xtensa.c (vsprint_msg): Add format attribute.  Fix
	format bugs.
	* vms.h (_bfd_vms_debug): Add format attribute.
	(_bfd_vms_debug, _bfd_hexdump): Fix typos.

binutils:
	* bucomm.h (report): Add format attribute.
	* dlltool.c (inform): Likewise.
	* dllwrap.c (display, inform, warn): Likewise.
	* objdump.c (objdump_sprintf): Likewise.
	* readelf.c (error, warn): Likewise.  Fix format bugs.

gas:
	* config/tc-tic30.c (debug): Add format attribute.  Fix format
	bugs.

include:
	* dis-asm.h (fprintf_ftype): Add format attribute.

opcodes:
	* arc-dis.c, arm-dis.c, cris-dis.c, crx-dis.c, d10v-dis.c,
	d30v-dis.c, fr30-dis.c, h8300-dis.c, h8500-dis.c, i860-dis.c,
	ia64-dis.c, ip2k-dis.c, m10200-dis.c, m10300-dis.c,
	m88k-dis.c, mcore-dis.c, mips-dis.c, ms1-dis.c, or32-dis.c,
	ppc-dis.c, sh64-dis.c, sparc-dis.c, tic4x-dis.c, tic80-dis.c,
	v850-dis.c: Fix format bugs.
	* ia64-gen.c (fail, warn): Add format attribute.
	* or32-opc.c (debug): Likewise.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2005
d5 3
a7 1
   This program is free software; you can redistribute it and/or modify
d9 2
a10 2
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d12 4
a15 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
@


1.9
log
@Update function declarations to ISO C90 formatting
@
text
@d190 1
a190 1
		  info->fprintf_func (info->stream, "%d", value);
d317 1
a317 1
		      info->fprintf_func (info->stream, "0x%x", value);
d358 1
a358 1
	info->fprintf_func (info->stream, ".short\t0x%04x", insn);
d360 1
a360 1
	info->fprintf_func (info->stream, ".long\t0x%08x", insn);
@


1.8
log
@Update the address and phone number of the FSF
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003
d17 2
a18 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
d24 1
a24 1
#include "opcode/v850.h" 
d29 3
a31 3
{ "r0", "r1", "r2", "sp", "gp", "r5", "r6", "r7", 
  "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15", 
  "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23", 
d35 1
a35 1
{ "eipc", "eipsw", "fepc", "fepsw", "ecr", "psw", "sr6", "sr7", 
d37 1
a37 1
  "ctpc", "ctpsw", "dbpc", "dbpsw", "ctbp", "sr21", "sr22", "sr23", 
d39 1
a39 1
  "sr16", "sr17", "sr18", "sr19", "sr20", "sr21", "sr22", "sr23", 
d43 1
a43 1
{ "v", "c/l", "z", "nh", "s/n", "t", "lt", "le", 
a45 3
static int disassemble
  PARAMS ((bfd_vma, struct disassemble_info *, unsigned long));

d47 3
a49 4
disassemble (memaddr, info, insn)
     bfd_vma memaddr;
     struct disassemble_info *info;
     unsigned long insn;
d51 2
a52 2
  struct v850_opcode *op = (struct v850_opcode *)v850_opcodes;
  const struct v850_operand *operand;
d57 2
a58 2
  
  /* Special case: 32 bit MOV */
d61 1
a61 1
  
d63 2
a64 2
  
  /* If this is a two byte insn, then mask off the high bits. */
d83 1
a83 1
  
a95 1
/*fprintf (stderr, "match: mask: %x insn: %x, opcode: %x, name: %s\n", op->mask, insn, op->opcode, op->name );*/
d110 1
a110 1
	  
d119 1
a119 1
	      
d121 1
a121 1
	      
d152 1
a152 1
		   in an instruction is the register for a memory address. 
d158 9
a166 6
	           if (memop && opnum == memop + 1) info->fprintf_func (info->stream, "[");
	      else if (memop && opnum == memop + 2) info->fprintf_func (info->stream, "],");
	      else if (memop == 1 && opnum == 1
		       && (operand->flags & V850_OPERAND_REG))
		                                    info->fprintf_func (info->stream, "[");
	      else if (opnum > 1)	            info->fprintf_func (info->stream, ", ");
d168 2
a169 1
	      /* extract the flags, ignorng ones which do not effect disassembly output. */
d174 1
a174 1
	      
d177 15
a191 5
		case V850_OPERAND_REG:  info->fprintf_func (info->stream, "%s", v850_reg_names[value]); break;
		case V850_OPERAND_SRG:  info->fprintf_func (info->stream, "%s", v850_sreg_names[value]); break;
		case V850_OPERAND_CC:   info->fprintf_func (info->stream, "%s", v850_cc_names[value]); break;
		case V850_OPERAND_EP:   info->fprintf_func (info->stream, "ep"); break;
		default:                info->fprintf_func (info->stream, "%d", value); break;
d195 10
a204 8
		    
		    /* On the v850 the top 8 bits of an address are used by an overlay manager.
		       Thus it may happen that when we are looking for a symbol to match
		       against an address with some of its top bits set, the search fails to
		       turn up an exact match.  In this case we try to find an exact match
		       against a symbol in the lower address space, and if we find one, we
		       use that address.   We only do this for JARL instructions however, as
		       we do not want to misinterpret branch instructions.  */
d210 1
a210 3
			  {
			    addr &= 0x00FFFFFF;
			  }
d215 1
a215 1
		    
d226 1
a226 2
		    
		    
d231 4
a234 1
		      case 0xfff8001f: regs = list18_l_regs; value &= ~0x10; break;  /* Do not include magic bit */
d237 3
a239 2
			fprintf (stderr, _("unknown operand shift: %x\n"), operand->shift );
			abort();
d250 3
a252 1
			      case 0:  fprintf (stderr, _("unknown pop reg: %d\n"), i ); abort();
d260 1
a260 1
		    
d267 1
a267 1
			    
d278 4
a281 3
				  
				  info->fprintf_func (info->stream, v850_reg_names[first]);
				  
d289 2
a290 3
				    {
				      info->fprintf_func (info->stream, " - %s", v850_reg_names[ last - 1 ]);
				    }
d293 1
a293 1
			
d299 1
a299 1
		    
d303 1
a303 1
		  
d305 2
a306 1
		  status = info->read_memory_func (memaddr + bytes_read, buffer, 2, info);
d312 2
a313 1
		      /* If this is a DISPOSE instruction with ff set to 0x10, then shift value up by 16.  */
d320 2
a321 3
		    {
		      info->memory_error_func (status, memaddr + bytes_read, info);
		    }
d323 1
a323 1
		  
d325 2
a326 1
		  status = info->read_memory_func (memaddr + bytes_read, buffer, 4, info);
d334 2
a335 3
		    {
		      info->memory_error_func (status, memaddr + bytes_read, info);
		    }
d337 1
a337 1
		}		  
d366 2
a367 4
int 
print_insn_v850 (memaddr, info)
     bfd_vma memaddr;
     struct disassemble_info * info;
a373 1
  
d378 1
a378 1
      
d389 1
a389 1
  
@


1.7
log
@Add binutils support for v850e1 processor
@
text
@d17 1
a17 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.6
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 2000, 2001, 2002
d5 13
a17 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d80 4
@


1.5
log
@	* v850-dis.c (disassemble): Remove bfd_mach_v850ea case.

	* mips-dis.c (_print_insn_mips): Don't use hard-coded mach constants.
@
text
@d2 2
a3 1
   Copyright 1996, 1997, 1998, 2000, 2001 Free Software Foundation, Inc.
d54 6
a59 6
  struct v850_opcode *          op = (struct v850_opcode *)v850_opcodes;
  const struct v850_operand *   operand;
  int                           match = 0;
  int                         	short_op = ((insn & 0x0600) != 0x0600);
  int				bytes_read;
  int				target_processor;
d63 1
a63 1
    short_op = true;
d89 3
a91 3
	  const unsigned char * opindex_ptr;
	  unsigned int          opnum;
	  unsigned int          memop;
d115 4
a118 4
	      long 	value;
	      int  	flag;
	      int       status;
	      bfd_byte	buffer[ 4 ];
d207 2
a208 2
		    int *             regs;
		    int               i;
d210 2
a211 2
		    int               pc   = false;
		    int               sr   = false;
d234 2
a235 2
			      case -1: pc = true; break;
			      case -2: sr = true; break;
d247 1
a247 1
			    int          shown_one = false;
d258 1
a258 1
				    shown_one = true;
d351 2
a352 2
  int           status;
  bfd_byte      buffer[ 4 ];
@


1.5.8.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
d4 13
a16 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d53 6
a58 6
  struct v850_opcode *op = (struct v850_opcode *)v850_opcodes;
  const struct v850_operand *operand;
  int match = 0;
  int short_op = ((insn & 0x0600) != 0x0600);
  int bytes_read;
  int target_processor;
d62 1
a62 1
    short_op = 1;
a79 4

    case bfd_mach_v850e1:
      target_processor = PROCESSOR_V850E1;
      break;
d88 3
a90 3
	  const unsigned char *opindex_ptr;
	  unsigned int opnum;
	  unsigned int memop;
d114 4
a117 4
	      long value;
	      int flag;
	      int status;
	      bfd_byte buffer[4];
d206 2
a207 2
		    int *regs;
		    int i;
d209 2
a210 2
		    int pc = 0;
		    int sr = 0;
d233 2
a234 2
			      case -1: pc = 1; break;
			      case -2: sr = 1; break;
d246 1
a246 1
			    int shown_one = 0;
d257 1
a257 1
				    shown_one = 1;
d350 2
a351 2
  int status;
  bfd_byte buffer[4];
@


1.5.6.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 2000, 2001, 2002
   Free Software Foundation, Inc.
d53 6
a58 6
  struct v850_opcode *op = (struct v850_opcode *)v850_opcodes;
  const struct v850_operand *operand;
  int match = 0;
  int short_op = ((insn & 0x0600) != 0x0600);
  int bytes_read;
  int target_processor;
d62 1
a62 1
    short_op = 1;
d88 3
a90 3
	  const unsigned char *opindex_ptr;
	  unsigned int opnum;
	  unsigned int memop;
d114 4
a117 4
	      long value;
	      int flag;
	      int status;
	      bfd_byte buffer[4];
d206 2
a207 2
		    int *regs;
		    int i;
d209 2
a210 2
		    int pc = 0;
		    int sr = 0;
d233 2
a234 2
			      case -1: pc = 1; break;
			      case -2: sr = 1; break;
d246 1
a246 1
			    int shown_one = 0;
d257 1
a257 1
				    shown_one = 1;
d350 2
a351 2
  int status;
  bfd_byte buffer[4];
@


1.5.6.2
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003
d5 13
a17 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a79 4
      break;

    case bfd_mach_v850e1:
      target_processor = PROCESSOR_V850E1;
@


1.4
log
@For include/opcode:
	* d30v.h: Fix declaration of reg_name_cnt.

	* d10v.h: Fix declaration of d10v_reg_name_cnt.

	* arc.h: Add prototypes from opcodes/arc-opc.c.

For opcodes:
	* tic54x-dis.c: Add unused attributes where needed.

	* z8k-dis.c (output_instr): Add unused attribute.

	* h8300-dis.c: Add missing prototypes.
	(bfd_h8_disassemble): Make static.

	* cris-dis.c: Add missing prototype.
	* h8500-dis.c: Likewise.
	* m68hc11-dis.c: Likewise.
	* pj-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* z8k-dis.c: Likewise.

	* d10v-dis.c: Add missing prototype.
	(dis_long): Remove unused variable.
	(dis_2_short): Likewise.

	* sh-dis.c: Add missing prototypes.
	* v850-opc.c: Likewise.
	Add unused attributes where needed.

	* ns32k-dis.c: Add missing prototypes.
	(bit_extract_simple): Remove unused variable.
@
text
@a79 4

    case bfd_mach_v850ea: 
      target_processor = PROCESSOR_V850EA;
      break;
@


1.4.10.1
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d80 4
@


1.3
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
d43 3
@


1.2
log
@More portability patches.  Include sysdep.h everywhere.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
@


1.2.4.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
@


1.1
log
@Initial revision
@
text
@d21 1
a21 1
#include "ansidecl.h"
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@


1.1.1.1.2.1
log
@2000-04-13  Michael Sokolov  <msokolov@@ivan.Harhan.ORG>

	* a29k-dis.c, alpha-dis.c, alpha-opc.c, arc-dis.c, arc-opc.c,
	avr-dis.c, d10v-dis.c, d10v-opc.c, d30v-dis.c, d30v-opc.c,
	disassemble.c, h8300-dis.c, h8500-dis.c, hppa-dis.c, i370-dis.c,
	i370-opc.c, i960-dis.c, m10200-dis.c, m10200-opc.c, m10300-dis.c,
	m10300-opc.c, m68k-dis.c, m68k-opc.c, m88k-dis.c, mcore-dis.c,
	mips-dis.c, mips-opc.c, mips16-opc.c, pj-dis.c, pj-opc.c, ppc-dis.c,
	ppc-opc.c, sh-dis.c, sparc-dis.c, sparc-opc.c, tic80-dis.c,
	tic80-opc.c, v850-dis.c, v850-opc.c, vax-dis.c, w65-dis.c, z8k-dis.c,
	z8kgen.c: Everyone includes sysdep.h. Remove ansidecl.h as sysdep.h
	includes it.
@
text
@d21 1
a21 1
#include "sysdep.h"
@


