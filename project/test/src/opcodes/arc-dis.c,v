head	1.18;
access;
symbols
	sid-snapshot-20180601:1.18
	sid-snapshot-20180501:1.18
	sid-snapshot-20180401:1.18
	sid-snapshot-20180301:1.18
	sid-snapshot-20180201:1.18
	sid-snapshot-20180101:1.18
	sid-snapshot-20171201:1.18
	sid-snapshot-20171101:1.18
	sid-snapshot-20171001:1.18
	sid-snapshot-20170901:1.18
	sid-snapshot-20170801:1.18
	sid-snapshot-20170701:1.18
	sid-snapshot-20170601:1.18
	sid-snapshot-20170501:1.18
	sid-snapshot-20170401:1.18
	sid-snapshot-20170301:1.18
	sid-snapshot-20170201:1.18
	sid-snapshot-20170101:1.18
	sid-snapshot-20161201:1.18
	sid-snapshot-20161101:1.18
	sid-snapshot-20160901:1.18
	sid-snapshot-20160801:1.18
	sid-snapshot-20160701:1.18
	sid-snapshot-20160601:1.18
	sid-snapshot-20160501:1.18
	sid-snapshot-20160401:1.18
	sid-snapshot-20160301:1.18
	sid-snapshot-20160201:1.18
	sid-snapshot-20160101:1.18
	sid-snapshot-20151201:1.18
	sid-snapshot-20151101:1.18
	sid-snapshot-20151001:1.18
	sid-snapshot-20150901:1.18
	sid-snapshot-20150801:1.18
	sid-snapshot-20150701:1.18
	sid-snapshot-20150601:1.18
	sid-snapshot-20150501:1.18
	sid-snapshot-20150401:1.18
	sid-snapshot-20150301:1.18
	sid-snapshot-20150201:1.18
	sid-snapshot-20150101:1.18
	sid-snapshot-20141201:1.18
	sid-snapshot-20141101:1.18
	sid-snapshot-20141001:1.18
	sid-snapshot-20140901:1.18
	sid-snapshot-20140801:1.18
	sid-snapshot-20140701:1.18
	sid-snapshot-20140601:1.18
	sid-snapshot-20140501:1.18
	sid-snapshot-20140401:1.18
	sid-snapshot-20140301:1.18
	sid-snapshot-20140201:1.18
	sid-snapshot-20140101:1.18
	sid-snapshot-20131201:1.18
	sid-snapshot-20131101:1.18
	sid-snapshot-20131001:1.18
	binutils-2_24-branch:1.18.0.4
	binutils-2_24-branchpoint:1.18
	binutils-2_21_1:1.15
	sid-snapshot-20130901:1.18
	gdb_7_6_1-2013-08-30-release:1.18
	sid-snapshot-20130801:1.18
	sid-snapshot-20130701:1.18
	sid-snapshot-20130601:1.18
	sid-snapshot-20130501:1.18
	gdb_7_6-2013-04-26-release:1.18
	sid-snapshot-20130401:1.18
	binutils-2_23_2:1.17
	gdb_7_6-branch:1.18.0.2
	gdb_7_6-2013-03-12-branchpoint:1.18
	sid-snapshot-20130301:1.18
	sid-snapshot-20130201:1.18
	sid-snapshot-20130101:1.18
	sid-snapshot-20121201:1.18
	gdb_7_5_1-2012-11-29-release:1.17
	binutils-2_23_1:1.17
	sid-snapshot-20121101:1.18
	binutils-2_23:1.17
	sid-snapshot-20121001:1.17
	sid-snapshot-20120901:1.17
	gdb_7_5-2012-08-17-release:1.17
	sid-snapshot-20120801:1.17
	binutils-2_23-branch:1.17.0.4
	binutils-2_23-branchpoint:1.17
	gdb_7_5-branch:1.17.0.2
	gdb_7_5-2012-07-18-branchpoint:1.17
	sid-snapshot-20120701:1.17
	sid-snapshot-20120601:1.17
	sid-snapshot-20120501:1.16
	binutils-2_22_branch:1.15.0.12
	gdb_7_4_1-2012-04-26-release:1.15
	sid-snapshot-20120401:1.16
	sid-snapshot-20120301:1.16
	sid-snapshot-20120201:1.15
	gdb_7_4-2012-01-24-release:1.15
	sid-snapshot-20120101:1.15
	gdb_7_4-branch:1.15.0.10
	gdb_7_4-2011-12-13-branchpoint:1.15
	sid-snapshot-20111201:1.15
	binutils-2_22:1.15
	sid-snapshot-20111101:1.15
	sid-snapshot-20111001:1.15
	binutils-2_22-branch:1.15.0.8
	binutils-2_22-branchpoint:1.15
	gdb_7_3_1-2011-09-04-release:1.15
	sid-snapshot-20110901:1.15
	sid-snapshot-20110801:1.15
	gdb_7_3-2011-07-26-release:1.15
	sid-snapshot-20110701:1.15
	sid-snapshot-20110601:1.15
	sid-snapshot-20110501:1.15
	gdb_7_3-branch:1.15.0.6
	gdb_7_3-2011-04-01-branchpoint:1.15
	sid-snapshot-20110401:1.15
	sid-snapshot-20110301:1.15
	sid-snapshot-20110201:1.15
	sid-snapshot-20110101:1.15
	binutils-2_21:1.15
	sid-snapshot-20101201:1.15
	binutils-2_21-branch:1.15.0.4
	binutils-2_21-branchpoint:1.15
	sid-snapshot-20101101:1.15
	sid-snapshot-20101001:1.15
	binutils-2_20_1:1.13
	gdb_7_2-2010-09-02-release:1.15
	sid-snapshot-20100901:1.15
	sid-snapshot-20100801:1.15
	gdb_7_2-branch:1.15.0.2
	gdb_7_2-2010-07-07-branchpoint:1.15
	sid-snapshot-20100701:1.15
	sid-snapshot-20100601:1.14
	sid-snapshot-20100501:1.14
	sid-snapshot-20100401:1.14
	gdb_7_1-2010-03-18-release:1.14
	sid-snapshot-20100301:1.14
	gdb_7_1-branch:1.14.0.2
	gdb_7_1-2010-02-18-branchpoint:1.14
	sid-snapshot-20100201:1.14
	sid-snapshot-20100101:1.14
	gdb_7_0_1-2009-12-22-release:1.13
	sid-snapshot-20091201:1.14
	sid-snapshot-20091101:1.14
	binutils-2_20:1.13
	gdb_7_0-2009-10-06-release:1.13
	sid-snapshot-20091001:1.14
	gdb_7_0-branch:1.13.0.34
	gdb_7_0-2009-09-16-branchpoint:1.13
	arc-sim-20090309:1.13.22.1
	binutils-arc-20081103-branch:1.13.0.32
	binutils-arc-20081103-branchpoint:1.13
	binutils-2_20-branch:1.13.0.30
	binutils-2_20-branchpoint:1.13
	sid-snapshot-20090901:1.13
	sid-snapshot-20090801:1.13
	msnyder-checkpoint-072509-branch:1.13.0.28
	msnyder-checkpoint-072509-branchpoint:1.13
	sid-snapshot-20090701:1.13
	dje-cgen-play1-branch:1.13.0.26
	dje-cgen-play1-branchpoint:1.13
	sid-snapshot-20090601:1.13
	sid-snapshot-20090501:1.13
	sid-snapshot-20090401:1.13
	arc-20081103-branch:1.13.0.24
	arc-20081103-branchpoint:1.13
	arc-insight_6_8-branch:1.13.0.22
	arc-insight_6_8-branchpoint:1.13
	insight_6_8-branch:1.13.0.20
	insight_6_8-branchpoint:1.13
	sid-snapshot-20090301:1.13
	binutils-2_19_1:1.13
	sid-snapshot-20090201:1.13
	sid-snapshot-20090101:1.13
	reverse-20081226-branch:1.13.0.18
	reverse-20081226-branchpoint:1.13
	sid-snapshot-20081201:1.13
	multiprocess-20081120-branch:1.13.0.16
	multiprocess-20081120-branchpoint:1.13
	sid-snapshot-20081101:1.13
	binutils-2_19:1.13
	sid-snapshot-20081001:1.13
	reverse-20080930-branch:1.13.0.14
	reverse-20080930-branchpoint:1.13
	binutils-2_19-branch:1.13.0.12
	binutils-2_19-branchpoint:1.13
	sid-snapshot-20080901:1.13
	sid-snapshot-20080801:1.13
	reverse-20080717-branch:1.13.0.10
	reverse-20080717-branchpoint:1.13
	sid-snapshot-20080701:1.13
	msnyder-reverse-20080609-branch:1.13.0.8
	msnyder-reverse-20080609-branchpoint:1.13
	drow-reverse-20070409-branch:1.12.0.32
	drow-reverse-20070409-branchpoint:1.12
	sid-snapshot-20080601:1.13
	sid-snapshot-20080501:1.13
	sid-snapshot-20080403:1.13
	sid-snapshot-20080401:1.13
	gdb_6_8-2008-03-27-release:1.13
	sid-snapshot-20080301:1.13
	gdb_6_8-branch:1.13.0.6
	gdb_6_8-2008-02-26-branchpoint:1.13
	sid-snapshot-20080201:1.13
	sid-snapshot-20080101:1.13
	sid-snapshot-20071201:1.13
	sid-snapshot-20071101:1.13
	gdb_6_7_1-2007-10-29-release:1.13
	gdb_6_7-2007-10-10-release:1.13
	sid-snapshot-20071001:1.13
	gdb_6_7-branch:1.13.0.4
	gdb_6_7-2007-09-07-branchpoint:1.13
	binutils-2_18:1.13
	binutils-2_18-branch:1.13.0.2
	binutils-2_18-branchpoint:1.13
	insight_6_6-20070208-release:1.12
	binutils-csl-coldfire-4_1-32:1.12
	binutils-csl-sourcerygxx-4_1-32:1.12
	gdb_6_6-2006-12-18-release:1.12
	binutils-csl-innovasic-fido-3_4_4-33:1.12
	binutils-csl-sourcerygxx-3_4_4-32:1.9
	binutils-csl-coldfire-4_1-30:1.12
	binutils-csl-sourcerygxx-4_1-30:1.12
	binutils-csl-coldfire-4_1-28:1.12
	binutils-csl-sourcerygxx-4_1-29:1.12
	binutils-csl-sourcerygxx-4_1-28:1.12
	gdb_6_6-branch:1.12.0.30
	gdb_6_6-2006-11-15-branchpoint:1.12
	binutils-csl-arm-2006q3-27:1.12
	binutils-csl-sourcerygxx-4_1-27:1.12
	binutils-csl-arm-2006q3-26:1.12
	binutils-csl-sourcerygxx-4_1-26:1.12
	binutils-csl-sourcerygxx-4_1-25:1.12
	binutils-csl-sourcerygxx-4_1-24:1.12
	binutils-csl-sourcerygxx-4_1-23:1.12
	insight_6_5-20061003-release:1.12
	gdb-csl-symbian-6_4_50_20060226-12:1.12
	binutils-csl-sourcerygxx-4_1-21:1.12
	binutils-csl-arm-2006q3-21:1.12
	binutils-csl-sourcerygxx-4_1-22:1.12
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.12
	binutils-csl-sourcerygxx-4_1-20:1.12
	binutils-csl-arm-2006q3-19:1.12
	binutils-csl-sourcerygxx-4_1-19:1.12
	binutils-csl-sourcerygxx-4_1-18:1.12
	binutils-csl-renesas-4_1-9:1.12
	gdb-csl-sourcerygxx-3_4_4-25:1.12
	binutils-csl-sourcerygxx-3_4_4-25:1.9
	nickrob-async-20060828-mergepoint:1.12
	gdb-csl-symbian-6_4_50_20060226-11:1.12
	binutils-csl-renesas-4_1-8:1.12
	binutils-csl-renesas-4_1-7:1.12
	binutils-csl-renesas-4_1-6:1.12
	gdb-csl-sourcerygxx-4_1-17:1.12
	binutils-csl-sourcerygxx-4_1-17:1.12
	gdb-csl-20060226-branch-local-2:1.12
	gdb-csl-sourcerygxx-4_1-14:1.12
	binutils-csl-sourcerygxx-4_1-14:1.12
	binutils-csl-sourcerygxx-4_1-15:1.12
	gdb-csl-sourcerygxx-4_1-13:1.12
	binutils-csl-sourcerygxx-4_1-13:1.12
	binutils-2_17:1.12
	gdb-csl-sourcerygxx-4_1-12:1.12
	binutils-csl-sourcerygxx-4_1-12:1.12
	gdb-csl-sourcerygxx-3_4_4-21:1.12
	binutils-csl-sourcerygxx-3_4_4-21:1.12
	gdb_6_5-20060621-release:1.12
	binutils-csl-wrs-linux-3_4_4-24:1.9
	binutils-csl-wrs-linux-3_4_4-23:1.9
	gdb-csl-sourcerygxx-4_1-9:1.12
	binutils-csl-sourcerygxx-4_1-9:1.12
	gdb-csl-sourcerygxx-4_1-8:1.12
	binutils-csl-sourcerygxx-4_1-8:1.12
	gdb-csl-sourcerygxx-4_1-7:1.12
	binutils-csl-sourcerygxx-4_1-7:1.12
	gdb-csl-arm-2006q1-6:1.12
	binutils-csl-arm-2006q1-6:1.12
	gdb-csl-sourcerygxx-4_1-6:1.12
	binutils-csl-sourcerygxx-4_1-6:1.12
	binutils-csl-wrs-linux-3_4_4-22:1.9
	gdb-csl-symbian-6_4_50_20060226-10:1.12
	gdb-csl-symbian-6_4_50_20060226-9:1.12
	gdb-csl-symbian-6_4_50_20060226-8:1.12
	gdb-csl-coldfire-4_1-11:1.12
	binutils-csl-coldfire-4_1-11:1.12
	gdb-csl-sourcerygxx-3_4_4-19:1.12
	binutils-csl-sourcerygxx-3_4_4-19:1.12
	gdb-csl-coldfire-4_1-10:1.12
	gdb_6_5-branch:1.12.0.28
	gdb_6_5-2006-05-14-branchpoint:1.12
	binutils-csl-coldfire-4_1-10:1.12
	gdb-csl-sourcerygxx-4_1-5:1.12
	binutils-csl-sourcerygxx-4_1-5:1.12
	nickrob-async-20060513-branch:1.12.0.26
	nickrob-async-20060513-branchpoint:1.12
	gdb-csl-sourcerygxx-4_1-4:1.12
	binutils-csl-sourcerygxx-4_1-4:1.12
	msnyder-reverse-20060502-branch:1.12.0.24
	msnyder-reverse-20060502-branchpoint:1.12
	binutils-csl-wrs-linux-3_4_4-21:1.9
	gdb-csl-morpho-4_1-4:1.12
	binutils-csl-morpho-4_1-4:1.12
	gdb-csl-sourcerygxx-3_4_4-17:1.12
	binutils-csl-sourcerygxx-3_4_4-17:1.12
	binutils-csl-wrs-linux-3_4_4-20:1.9
	readline_5_1-import-branch:1.12.0.22
	readline_5_1-import-branchpoint:1.12
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.12
	binutils-2_17-branch:1.12.0.20
	binutils-2_17-branchpoint:1.12
	gdb-csl-symbian-20060226-branch:1.12.0.18
	gdb-csl-symbian-20060226-branchpoint:1.12
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.12
	msnyder-reverse-20060331-branch:1.12.0.16
	msnyder-reverse-20060331-branchpoint:1.12
	binutils-csl-2_17-branch:1.12.0.14
	binutils-csl-2_17-branchpoint:1.12
	gdb-csl-available-20060303-branch:1.12.0.12
	gdb-csl-available-20060303-branchpoint:1.12
	gdb-csl-20060226-branch:1.12.0.10
	gdb-csl-20060226-branchpoint:1.12
	gdb_6_4-20051202-release:1.12
	msnyder-fork-checkpoint-branch:1.12.0.8
	msnyder-fork-checkpoint-branchpoint:1.12
	gdb-csl-gxxpro-6_3-branch:1.12.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.12
	gdb_6_4-branch:1.12.0.4
	gdb_6_4-2005-11-01-branchpoint:1.12
	gdb-csl-arm-20051020-branch:1.12.0.2
	gdb-csl-arm-20051020-branchpoint:1.12
	binutils-csl-gxxpro-3_4-branch:1.9.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.9
	binutils-2_16_1:1.9
	msnyder-tracepoint-checkpoint-branch:1.10.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.10
	gdb-csl-arm-20050325-2005-q1b:1.9
	binutils-csl-arm-2005q1b:1.9
	binutils-2_16:1.9
	gdb-csl-arm-20050325-2005-q1a:1.9
	binutils-csl-arm-2005q1a:1.9
	csl-arm-20050325-branch:1.9.0.6
	csl-arm-20050325-branchpoint:1.9
	binutils-csl-arm-2005q1-branch:1.9.0.4
	binutils-csl-arm-2005q1-branchpoint:1.9
	binutils-2_16-branch:1.9.0.2
	binutils-2_16-branchpoint:1.9
	csl-arm-2004-q3d:1.8
	gdb_6_3-20041109-release:1.8
	gdb_6_3-branch:1.8.0.76
	gdb_6_3-20041019-branchpoint:1.8
	csl-arm-2004-q3:1.8
	drow_intercu-merge-20040921:1.8
	drow_intercu-merge-20040915:1.8
	jimb-gdb_6_2-e500-branch:1.8.0.78
	jimb-gdb_6_2-e500-branchpoint:1.8
	gdb_6_2-20040730-release:1.8
	gdb_6_2-branch:1.8.0.74
	gdb_6_2-2004-07-10-gmt-branchpoint:1.8
	gdb_6_1_1-20040616-release:1.8
	binutils-2_15:1.8
	binutils-2_15-branchpoint:1.8
	csl-arm-2004-q1a:1.8
	csl-arm-2004-q1:1.8
	gdb_6_1-2004-04-05-release:1.8
	drow_intercu-merge-20040402:1.8
	drow_intercu-merge-20040327:1.8
	ezannoni_pie-20040323-branch:1.8.0.72
	ezannoni_pie-20040323-branchpoint:1.8
	cagney_tramp-20040321-mergepoint:1.8
	cagney_tramp-20040309-branch:1.8.0.70
	cagney_tramp-20040309-branchpoint:1.8
	gdb_6_1-branch:1.8.0.68
	gdb_6_1-2004-03-01-gmt-branchpoint:1.8
	drow_intercu-20040221-branch:1.8.0.66
	drow_intercu-20040221-branchpoint:1.8
	binutils-2_15-branch:1.8.0.64
	cagney_bfdfile-20040213-branch:1.8.0.62
	cagney_bfdfile-20040213-branchpoint:1.8
	drow-cplus-merge-20040208:1.8
	carlton_dictionary-20040126-merge:1.8
	cagney_bigcore-20040122-branch:1.8.0.60
	cagney_bigcore-20040122-branchpoint:1.8
	drow-cplus-merge-20040113:1.8
	csl-arm-2003-q4:1.8
	drow-cplus-merge-20031224:1.8
	drow-cplus-merge-20031220:1.8
	carlton_dictionary-20031215-merge:1.8
	drow-cplus-merge-20031214:1.8
	carlton-dictionary-20031111-merge:1.8
	gdb_6_0-2003-10-04-release:1.8
	kettenis_sparc-20030918-branch:1.8.0.58
	kettenis_sparc-20030918-branchpoint:1.8
	carlton_dictionary-20030917-merge:1.8
	ezannoni_pie-20030916-branchpoint:1.8
	ezannoni_pie-20030916-branch:1.8.0.56
	cagney_x86i386-20030821-branch:1.8.0.54
	cagney_x86i386-20030821-branchpoint:1.8
	carlton_dictionary-20030805-merge:1.8
	carlton_dictionary-20030627-merge:1.8
	gdb_6_0-branch:1.8.0.52
	gdb_6_0-2003-06-23-branchpoint:1.8
	jimb-ppc64-linux-20030613-branch:1.8.0.50
	jimb-ppc64-linux-20030613-branchpoint:1.8
	binutils-2_14:1.8
	cagney_convert-20030606-branch:1.8.0.48
	cagney_convert-20030606-branchpoint:1.8
	cagney_writestrings-20030508-branch:1.8.0.46
	cagney_writestrings-20030508-branchpoint:1.8
	jimb-ppc64-linux-20030528-branch:1.8.0.44
	jimb-ppc64-linux-20030528-branchpoint:1.8
	carlton_dictionary-20030523-merge:1.8
	cagney_fileio-20030521-branch:1.8.0.42
	cagney_fileio-20030521-branchpoint:1.8
	kettenis_i386newframe-20030517-mergepoint:1.8
	jimb-ppc64-linux-20030509-branch:1.8.0.40
	jimb-ppc64-linux-20030509-branchpoint:1.8
	kettenis_i386newframe-20030504-mergepoint:1.8
	carlton_dictionary-20030430-merge:1.8
	binutils-2_14-branch:1.8.0.38
	binutils-2_14-branchpoint:1.8
	kettenis_i386newframe-20030419-branch:1.8.0.36
	kettenis_i386newframe-20030419-branchpoint:1.8
	carlton_dictionary-20030416-merge:1.8
	cagney_frameaddr-20030409-mergepoint:1.8
	kettenis_i386newframe-20030406-branch:1.8.0.34
	kettenis_i386newframe-20030406-branchpoint:1.8
	cagney_frameaddr-20030403-branchpoint:1.8
	cagney_frameaddr-20030403-branch:1.8.0.32
	cagney_framebase-20030330-mergepoint:1.8
	cagney_framebase-20030326-branch:1.8.0.30
	cagney_framebase-20030326-branchpoint:1.8
	cagney_lazyid-20030317-branch:1.8.0.28
	cagney_lazyid-20030317-branchpoint:1.8
	kettenis-i386newframe-20030316-mergepoint:1.8
	offbyone-20030313-branch:1.8.0.26
	offbyone-20030313-branchpoint:1.8
	kettenis-i386newframe-20030308-branch:1.8.0.24
	kettenis-i386newframe-20030308-branchpoint:1.8
	carlton_dictionary-20030305-merge:1.8
	cagney_offbyone-20030303-branch:1.8.0.22
	cagney_offbyone-20030303-branchpoint:1.8
	carlton_dictionary-20030207-merge:1.8
	interps-20030202-branch:1.8.0.20
	interps-20030202-branchpoint:1.8
	cagney-unwind-20030108-branch:1.8.0.18
	cagney-unwind-20030108-branchpoint:1.8
	binutils-2_13_2_1:1.8
	binutils-2_13_2:1.8
	carlton_dictionary-20021223-merge:1.8
	gdb_5_3-2002-12-12-release:1.8
	carlton_dictionary-20021115-merge:1.8
	binutils-2_13_1:1.8
	kseitz_interps-20021105-merge:1.8
	kseitz_interps-20021103-merge:1.8
	drow-cplus-merge-20021020:1.8
	drow-cplus-merge-20021025:1.8
	carlton_dictionary-20021025-merge:1.8
	carlton_dictionary-20021011-merge:1.8
	drow-cplus-branch:1.8.0.16
	drow-cplus-branchpoint:1.8
	kseitz_interps-20020930-merge:1.8
	carlton_dictionary-20020927-merge:1.8
	carlton_dictionary-branch:1.8.0.14
	carlton_dictionary-20020920-branchpoint:1.8
	sid-20020905-branchpoint:1.8
	sid-20020905-branch:1.8.0.12
	gdb_5_3-branch:1.8.0.10
	gdb_5_3-2002-09-04-branchpoint:1.8
	kseitz_interps-20020829-merge:1.8
	cagney_sysregs-20020825-branch:1.8.0.8
	cagney_sysregs-20020825-branchpoint:1.8
	readline_4_3-import-branch:1.8.0.6
	readline_4_3-import-branchpoint:1.8
	binutils-2_13:1.8
	gdb_5_2_1-2002-07-23-release:1.7
	binutils-2_13-branchpoint:1.8
	binutils-2_13-branch:1.8.0.4
	kseitz_interps-20020528-branch:1.8.0.2
	kseitz_interps-20020528-branchpoint:1.8
	cagney_regbuf-20020515-branch:1.7.0.8
	cagney_regbuf-20020515-branchpoint:1.7
	binutils-2_12_1:1.7
	jimb-macro-020506-branch:1.7.0.6
	jimb-macro-020506-branchpoint:1.7
	gdb_5_2-2002-04-29-release:1.7
	binutils-2_12:1.7
	gdb_5_2-branch:1.7.0.4
	gdb_5_2-2002-03-03-branchpoint:1.7
	binutils-2_12-branch:1.7.0.2
	binutils-2_12-branchpoint:1.7
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.7
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	binutils-2_11_2:1.3.2.1
	binutils-2_11_1:1.3.2.1
	binutils-2_11:1.3
	x86_64versiong3:1.3
	binutils-2_11-branch:1.3.0.2
	insight-precleanup-2001-01-01:1.2
	binutils-2_10_1:1.1.1.1.2.1
	binutils-2_10:1.1.1.1.2.1
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.18
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2012.10.18.06.53.16;	author ktietz;	state Exp;
branches;
next	1.17;

1.17
date	2012.05.18.01.59.38;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2012.02.27.06.31.57;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.27.04.07.55;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2009.09.25.19.13.27;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2007.07.05.09.49.00;	author nickc;	state Exp;
branches
	1.13.22.1
	1.13.32.1;
next	1.12;

1.12
date	2005.07.07.19.27.48;	author wilson;	state Exp;
branches;
next	1.11;

1.11
date	2005.07.01.11.16.31;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.07.07.34.26;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.03.15.42.05;	author ramana;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.25.12.55.19;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.26.01.54.07;	author amodra;	state Exp;
branches
	1.7.8.1;
next	1.6;

1.6
date	2001.09.21.12.36.56;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.21.08.51.12;	author aj;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.13.22.58.34;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.11.21.20.19;	author nickc;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.04.14.04.16.58;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.59;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.13.22.1
date	2009.03.09.20.36.11;	author amylaar;	state Exp;
branches;
next	1.13.22.2;

1.13.22.2
date	2009.09.11.04.45.54;	author amylaar;	state Exp;
branches;
next	;

1.13.32.1
date	2009.09.10.15.09.45;	author amylaar;	state Exp;
branches;
next	;

1.7.8.1
date	2002.06.15.16.43.20;	author cagney;	state Exp;
branches;
next	;

1.3.2.1
date	2001.06.07.03.18.33;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.59;	author rth;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	2000.05.06.14.49.26;	author pb;	state Exp;
branches;
next	;


desc
@@


1.18
log
@        * aarch64-asm.c (aarch64_ins_ldst_reglist): Initialize
        value with a default.
        (do_special_encoding): Likewise.
        (aarch64_ins_ldst_elemlist): Pre-initialize QSsize, and opcodeh2
        variables with default.
        * arc-dis.c (write_comments_): Don't use strncat due
        size of state->commentBuffer pointer isn't predictable.
@
text
@/* Instruction printing code for the ARC.
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2005, 2007, 2009,
   2010, 2012 Free Software Foundation, Inc.
   Contributed by Doug Evans (dje@@cygnus.com).

   This file is part of libopcodes.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "libiberty.h"
#include "dis-asm.h"
#include "opcode/arc.h"
#include "elf-bfd.h"
#include "elf/arc.h"
#include "opintl.h"

#include <stdarg.h>
#include "arc-dis.h"
#include "arc-ext.h"

#ifndef dbg
#define dbg (0)
#endif

/* Classification of the opcodes for the decoder to print 
   the instructions.  */

typedef enum
{
  CLASS_A4_ARITH,	     
  CLASS_A4_OP3_GENERAL,
  CLASS_A4_FLAG,
  /* All branches other than JC.  */
  CLASS_A4_BRANCH,
  CLASS_A4_JC ,
  /* All loads other than immediate 
     indexed loads.  */
  CLASS_A4_LD0,
  CLASS_A4_LD1,
  CLASS_A4_ST,
  CLASS_A4_SR,
  /* All single operand instructions.  */
  CLASS_A4_OP3_SUBOPC3F,
  CLASS_A4_LR
} a4_decoding_class;

#define BIT(word,n)	((word) & (1 << n))
#define BITS(word,s,e)  (((word) >> s) & ((1 << (e + 1 - s)) - 1))
#define OPCODE(word)	(BITS ((word), 27, 31))
#define FIELDA(word)	(BITS ((word), 21, 26))
#define FIELDB(word)	(BITS ((word), 15, 20))
#define FIELDC(word)	(BITS ((word),  9, 14))

/* FIELD D is signed.  */
#define FIELDD(word)	((BITS ((word), 0, 8) ^ 0x100) - 0x100)

#define PUT_NEXT_WORD_IN(a)						\
  do									\
    {									\
      if (is_limm == 1 && !NEXT_WORD (1))				\
        mwerror (state, _("Illegal limm reference in last instruction!\n")); \
      a = state->words[1];						\
    }									\
  while (0)

#define CHECK_FLAG_COND_NULLIFY()				\
  do								\
    {								\
      if (is_shimm == 0)					\
        {							\
          flag = BIT (state->words[0], 8);			\
          state->nullifyMode = BITS (state->words[0], 5, 6);	\
          cond = BITS (state->words[0], 0, 4);			\
        }							\
    }								\
  while (0)

#define CHECK_COND()				\
  do						\
    {						\
      if (is_shimm == 0)			\
        cond = BITS (state->words[0], 0, 4);	\
    }						\
  while (0)

#define CHECK_FIELD(field)			\
  do						\
    {						\
      if (field == 62)				\
        {					\
          is_limm++;				\
	  field##isReg = 0;			\
	  PUT_NEXT_WORD_IN (field);		\
	  limm_value = field;			\
	}					\
      else if (field > 60)			\
        {					\
	  field##isReg = 0;			\
	  is_shimm++;				\
	  flag = (field == 61);			\
	  field = FIELDD (state->words[0]);	\
	}					\
    }						\
  while (0)

#define CHECK_FIELD_A()				\
  do						\
    {						\
      fieldA = FIELDA (state->words[0]);	\
      if (fieldA > 60)				\
        {					\
	  fieldAisReg = 0;			\
	  fieldA = 0;				\
	}					\
    }						\
  while (0)

#define CHECK_FIELD_B()				\
  do						\
    {						\
      fieldB = FIELDB (state->words[0]);	\
      CHECK_FIELD (fieldB);			\
    }						\
  while (0)

#define CHECK_FIELD_C()				\
  do						\
    {						\
      fieldC = FIELDC (state->words[0]);	\
      CHECK_FIELD (fieldC);			\
    }						\
  while (0)

#define IS_SMALL(x)                 (((field##x) < 256) && ((field##x) > -257))
#define IS_REG(x)                    (field##x##isReg)
#define WRITE_FORMAT_LB_Rx_RB(x)     WRITE_FORMAT (x, "[","]","","")
#define WRITE_FORMAT_x_COMMA_LB(x)   WRITE_FORMAT (x, "",",[","",",[")
#define WRITE_FORMAT_COMMA_x_RB(x)   WRITE_FORMAT (x, ",","]",",","]")
#define WRITE_FORMAT_x_RB(x)         WRITE_FORMAT (x, "","]","","]")
#define WRITE_FORMAT_COMMA_x(x)      WRITE_FORMAT (x, ",","",",","")
#define WRITE_FORMAT_x_COMMA(x)      WRITE_FORMAT (x, "",",","",",")
#define WRITE_FORMAT_x(x)            WRITE_FORMAT (x, "","","","")
#define WRITE_FORMAT(x,cb1,ca1,cb,ca) strcat (formatString,		\
				     (IS_REG (x) ? cb1"%r"ca1 :		\
				      usesAuxReg ? cb"%a"ca :		\
				      IS_SMALL (x) ? cb"%d"ca : cb"%h"ca))
#define WRITE_FORMAT_RB()	strcat (formatString, "]")
#define WRITE_COMMENT(str)	(state->comm[state->commNum++] = (str))
#define WRITE_NOP_COMMENT()	if (!fieldAisReg && !flag) WRITE_COMMENT ("nop");

#define NEXT_WORD(x)	(offset += 4, state->words[x])

#define add_target(x)	(state->targets[state->tcnt++] = (x))

static char comment_prefix[] = "\t; ";

static const char *
core_reg_name (struct arcDisState * state, int val)
{
  if (state->coreRegName)
    return (*state->coreRegName)(state->_this, val);
  return 0;
}

static const char *
aux_reg_name (struct arcDisState * state, int val)
{
  if (state->auxRegName)
    return (*state->auxRegName)(state->_this, val);
  return 0;
}

static const char *
cond_code_name (struct arcDisState * state, int val)
{
  if (state->condCodeName)
    return (*state->condCodeName)(state->_this, val);
  return 0;
}

static const char *
instruction_name (struct arcDisState * state,
		  int    op1,
		  int    op2,
		  int *  flags)
{
  if (state->instName)
    return (*state->instName)(state->_this, op1, op2, flags);
  return 0;
}

static void
mwerror (struct arcDisState * state, const char * msg)
{
  if (state->err != 0)
    (*state->err)(state->_this, (msg));
}

static const char *
post_address (struct arcDisState * state, int addr)
{
  static char id[3 * ARRAY_SIZE (state->addresses)];
  int j, i = state->acnt;

  if (i < ((int) ARRAY_SIZE (state->addresses)))
    {
      state->addresses[i] = addr;
      ++state->acnt;
      j = i*3;
      id[j+0] = '@@';
      id[j+1] = '0'+i;
      id[j+2] = 0;

      return id + j;
    }
  return "";
}

static void
arc_sprintf (struct arcDisState *state, char *buf, const char *format, ...)
{
  char *bp;
  const char *p;
  int size, leading_zero, regMap[2];
  va_list ap;

  va_start (ap, format);

  bp = buf;
  *bp = 0;
  p = format;
  regMap[0] = 0;
  regMap[1] = 0;

  while (1)
    switch (*p++)
      {
      case 0:
	goto DOCOMM; /* (return)  */
      default:
	*bp++ = p[-1];
	break;
      case '%':
	size = 0;
	leading_zero = 0;
      RETRY: ;
	switch (*p++)
	  {
	  case '0':
	  case '1':
	  case '2':
	  case '3':
	  case '4':
	  case '5':
	  case '6':
	  case '7':
	  case '8':
	  case '9':
	    {
	      /* size.  */
	      size = p[-1] - '0';
	      if (size == 0)
		leading_zero = 1; /* e.g. %08x  */
	      while (*p >= '0' && *p <= '9')
		{
		  size = size * 10 + *p - '0';
		  p++;
		}
	      goto RETRY;
	    }
#define inc_bp() bp = bp + strlen (bp)

	  case 'h':
	    {
	      unsigned u = va_arg (ap, int);

	      /* Hex.  We can change the format to 0x%08x in
		 one place, here, if we wish.
		 We add underscores for easy reading.  */
	      if (u > 65536)
		sprintf (bp, "0x%x_%04x", u >> 16, u & 0xffff);
	      else
		sprintf (bp, "0x%x", u);
	      inc_bp ();
	    }
	    break;
	  case 'X': case 'x':
	    {
	      int val = va_arg (ap, int);

	      if (size != 0)
		if (leading_zero)
		  sprintf (bp, "%0*x", size, val);
		else
		  sprintf (bp, "%*x", size, val);
	      else
		sprintf (bp, "%x", val);
	      inc_bp ();
	    }
	    break;
	  case 'd':
	    {
	      int val = va_arg (ap, int);

	      if (size != 0)
		sprintf (bp, "%*d", size, val);
	      else
		sprintf (bp, "%d", val);
	      inc_bp ();
	    }
	    break;
	  case 'r':
	    {
	      /* Register.  */
	      int val = va_arg (ap, int);

#define REG2NAME(num, name) case num: sprintf (bp, ""name); \
  regMap[(num < 32) ? 0 : 1] |= 1 << (num - ((num < 32) ? 0 : 32)); break;

	      switch (val)
		{
		  REG2NAME (26, "gp");
		  REG2NAME (27, "fp");
		  REG2NAME (28, "sp");
		  REG2NAME (29, "ilink1");
		  REG2NAME (30, "ilink2");
		  REG2NAME (31, "blink");
		  REG2NAME (60, "lp_count");
		default:
		  {
		    const char * ext;

		    ext = core_reg_name (state, val);
		    if (ext)
		      sprintf (bp, "%s", ext);
		    else
		      sprintf (bp,"r%d",val);
		  }
		  break;
		}
	      inc_bp ();
	    } break;

	  case 'a':
	    {
	      /* Aux Register.  */
	      int val = va_arg (ap, int);

#define AUXREG2NAME(num, name) case num: sprintf (bp,name); break;

	      switch (val)
		{
		  AUXREG2NAME (0x0, "status");
		  AUXREG2NAME (0x1, "semaphore");
		  AUXREG2NAME (0x2, "lp_start");
		  AUXREG2NAME (0x3, "lp_end");
		  AUXREG2NAME (0x4, "identity");
		  AUXREG2NAME (0x5, "debug");
		default:
		  {
		    const char *ext;

		    ext = aux_reg_name (state, val);
		    if (ext)
		      sprintf (bp, "%s", ext);
		    else
		      arc_sprintf (state, bp, "%h", val);
		  }
		  break;
		}
	      inc_bp ();
	    }
	    break;

	  case 's':
	    {
	      sprintf (bp, "%s", va_arg (ap, char *));
	      inc_bp ();
	    }
	    break;

	  default:
	    fprintf (stderr, "?? format %c\n", p[-1]);
	    break;
	  }
      }

 DOCOMM: *bp = 0;
  va_end (ap);
}

static void
write_comments_(struct arcDisState * state,
		int shimm,
		int is_limm,
		long limm_value)
{
  if (state->commentBuffer != 0)
    {
      int i;

      if (is_limm)
	{
	  const char *name = post_address (state, limm_value + shimm);

	  if (*name != 0)
	    WRITE_COMMENT (name);
	}
      for (i = 0; i < state->commNum; i++)
	{
	  if (i == 0)
	    strcpy (state->commentBuffer, comment_prefix);
	  else
	    strcat (state->commentBuffer, ", ");
	  strcat (state->commentBuffer, state->comm[i]);
	}
    }
}

#define write_comments2(x) write_comments_ (state, x, is_limm, limm_value)
#define write_comments()   write_comments2 (0)

static const char *condName[] =
{
  /* 0..15.  */
  ""   , "z"  , "nz" , "p"  , "n"  , "c"  , "nc" , "v"  ,
  "nv" , "gt" , "ge" , "lt" , "le" , "hi" , "ls" , "pnz"
};

static void
write_instr_name_(struct arcDisState * state,
		  const char * instrName,
		  int cond,
		  int condCodeIsPartOfName,
		  int flag,
		  int signExtend,
		  int addrWriteBack,
		  int directMem)
{
  strcpy (state->instrBuffer, instrName);

  if (cond > 0)
    {
      const char *cc = 0;

      if (!condCodeIsPartOfName)
	strcat (state->instrBuffer, ".");

      if (cond < 16)
	cc = condName[cond];
      else
	cc = cond_code_name (state, cond);

      if (!cc)
	cc = "???";

      strcat (state->instrBuffer, cc);
    }

  if (flag)
    strcat (state->instrBuffer, ".f");

  switch (state->nullifyMode)
    {
    case BR_exec_always:
      strcat (state->instrBuffer, ".d");
      break;
    case BR_exec_when_jump:
      strcat (state->instrBuffer, ".jd");
      break;
    }

  if (signExtend)
    strcat (state->instrBuffer, ".x");

  if (addrWriteBack)
    strcat (state->instrBuffer, ".a");

  if (directMem)
    strcat (state->instrBuffer, ".di");
}

#define write_instr_name()						\
  do									\
    {									\
      write_instr_name_(state, instrName,cond, condCodeIsPartOfName,	\
			flag, signExtend, addrWriteBack, directMem);	\
      formatString[0] = '\0';						\
    }									\
  while (0)

enum
{
  op_LD0 = 0, op_LD1 = 1, op_ST  = 2, op_3   = 3,
  op_BC  = 4, op_BLC = 5, op_LPC = 6, op_JC  = 7,
  op_ADD = 8, op_ADC = 9, op_SUB = 10, op_SBC = 11,
  op_AND = 12, op_OR  = 13, op_BIC = 14, op_XOR = 15
};

extern disassemble_info tm_print_insn_info;

static int
dsmOneArcInst (bfd_vma addr, struct arcDisState * state)
{
  int condCodeIsPartOfName = 0;
  a4_decoding_class decodingClass;
  const char * instrName;
  int repeatsOp = 0;
  int fieldAisReg = 1;
  int fieldBisReg = 1;
  int fieldCisReg = 1;
  int fieldA;
  int fieldB;
  int fieldC = 0;
  int flag = 0;
  int cond = 0;
  int is_shimm = 0;
  int is_limm = 0;
  long limm_value = 0;
  int signExtend = 0;
  int addrWriteBack = 0;
  int directMem = 0;
  int is_linked = 0;
  int offset = 0;
  int usesAuxReg = 0;
  int flags;
  int ignoreFirstOpd;
  char formatString[60];

  state->instructionLen = 4;
  state->nullifyMode = BR_exec_when_no_jump;
  state->opWidth = 12;
  state->isBranch = 0;

  state->_mem_load = 0;
  state->_ea_present = 0;
  state->_load_len = 0;
  state->ea_reg1 = no_reg;
  state->ea_reg2 = no_reg;
  state->_offset = 0;

  if (! NEXT_WORD (0))
    return 0;

  state->_opcode = OPCODE (state->words[0]);
  instrName = 0;
  decodingClass = CLASS_A4_ARITH; /* default!  */
  repeatsOp = 0;
  condCodeIsPartOfName=0;
  state->commNum = 0;
  state->tcnt = 0;
  state->acnt = 0;
  state->flow = noflow;
  ignoreFirstOpd = 0;

  if (state->commentBuffer)
    state->commentBuffer[0] = '\0';

  switch (state->_opcode)
    {
    case op_LD0:
      switch (BITS (state->words[0],1,2))
	{
	case 0:
	  instrName = "ld";
	  state->_load_len = 4;
	  break;
	case 1:
	  instrName = "ldb";
	  state->_load_len = 1;
	  break;
	case 2:
	  instrName = "ldw";
	  state->_load_len = 2;
	  break;
	default:
	  instrName = "??? (0[3])";
	  state->flow = invalid_instr;
	  break;
	}
      decodingClass = CLASS_A4_LD0;
      break;

    case op_LD1:
      if (BIT (state->words[0],13))
	{
	  instrName = "lr";
	  decodingClass = CLASS_A4_LR;
	}
      else
	{
	  switch (BITS (state->words[0], 10, 11))
	    {
	    case 0:
	      instrName = "ld";
	      state->_load_len = 4;
	      break;
	    case 1:
	      instrName = "ldb";
	      state->_load_len = 1;
	      break;
	    case 2:
	      instrName = "ldw";
	      state->_load_len = 2;
	      break;
	    default:
	      instrName = "??? (1[3])";
	      state->flow = invalid_instr;
	      break;
	    }
	  decodingClass = CLASS_A4_LD1;
	}
      break;

    case op_ST:
      if (BIT (state->words[0], 25))
	{
	  instrName = "sr";
	  decodingClass = CLASS_A4_SR;
	}
      else
	{
	  switch (BITS (state->words[0], 22, 23))
	    {
	    case 0:
	      instrName = "st";
	      break;
	    case 1:
	      instrName = "stb";
	      break;
	    case 2:
	      instrName = "stw";
	      break;
	    default:
	      instrName = "??? (2[3])";
	      state->flow = invalid_instr;
	      break;
	    }
	  decodingClass = CLASS_A4_ST;
	}
      break;

    case op_3:
      decodingClass = CLASS_A4_OP3_GENERAL;  /* default for opcode 3...  */
      switch (FIELDC (state->words[0]))
	{
	case  0:
	  instrName = "flag";
	  decodingClass = CLASS_A4_FLAG;
	  break;
	case  1:
	  instrName = "asr";
	  break;
	case  2:
	  instrName = "lsr";
	  break;
	case  3:
	  instrName = "ror";
	  break;
	case  4:
	  instrName = "rrc";
	  break;
	case  5:
	  instrName = "sexb";
	  break;
	case  6:
	  instrName = "sexw";
	  break;
	case  7:
	  instrName = "extb";
	  break;
	case  8:
	  instrName = "extw";
	  break;
	case  0x3f:
	  {
	    decodingClass = CLASS_A4_OP3_SUBOPC3F;
	    switch (FIELDD (state->words[0]))
	      {
	      case 0:
		instrName = "brk";
		break;
	      case 1:
		instrName = "sleep";
		break;
	      case 2:
		instrName = "swi";
		break;
	      default:
		instrName = "???";
		state->flow=invalid_instr;
		break;
	      }
	  }
	  break;

	  /* ARC Extension Library Instructions
	     NOTE: We assume that extension codes are these instrs.  */
	default:
	  instrName = instruction_name (state,
					state->_opcode,
					FIELDC (state->words[0]),
					&flags);
	  if (!instrName)
	    {
	      instrName = "???";
	      state->flow = invalid_instr;
	    }
	  if (flags & IGNORE_FIRST_OPD)
	    ignoreFirstOpd = 1;
	  break;
	}
      break;

    case op_BC:
      instrName = "b";
    case op_BLC:
      if (!instrName)
	instrName = "bl";
    case op_LPC:
      if (!instrName)
	instrName = "lp";
    case op_JC:
      if (!instrName)
	{
	  if (BITS (state->words[0],9,9))
	    {
	      instrName = "jl";
	      is_linked = 1;
	    }
	  else
	    {
	      instrName = "j";
	      is_linked = 0;
	    }
	}
      condCodeIsPartOfName = 1;
      decodingClass = ((state->_opcode == op_JC) ? CLASS_A4_JC : CLASS_A4_BRANCH );
      state->isBranch = 1;
      break;

    case op_ADD:
    case op_ADC:
    case op_AND:
      repeatsOp = (FIELDC (state->words[0]) == FIELDB (state->words[0]));

      switch (state->_opcode)
	{
	case op_ADD:
	  instrName = (repeatsOp ? "asl" : "add");
	  break;
	case op_ADC:
	  instrName = (repeatsOp ? "rlc" : "adc");
	  break;
	case op_AND:
	  instrName = (repeatsOp ? "mov" : "and");
	  break;
	}
      break;

    case op_SUB: instrName = "sub";
      break;
    case op_SBC: instrName = "sbc";
      break;
    case op_OR:  instrName = "or";
      break;
    case op_BIC: instrName = "bic";
      break;

    case op_XOR:
      if (state->words[0] == 0x7fffffff)
	{
	  /* NOP encoded as xor -1, -1, -1.   */
	  instrName = "nop";
	  decodingClass = CLASS_A4_OP3_SUBOPC3F;
	}
      else
	instrName = "xor";
      break;

    default:
      instrName = instruction_name (state,state->_opcode,0,&flags);
      /* if (instrName) printf("FLAGS=0x%x\n", flags);  */
      if (!instrName)
	{
	  instrName = "???";
	  state->flow=invalid_instr;
	}
      if (flags & IGNORE_FIRST_OPD)
	ignoreFirstOpd = 1;
      break;
    }

  fieldAisReg = fieldBisReg = fieldCisReg = 1; /* Assume regs for now.  */
  flag = cond = is_shimm = is_limm = 0;
  state->nullifyMode = BR_exec_when_no_jump;	/* 0  */
  signExtend = addrWriteBack = directMem = 0;
  usesAuxReg = 0;

  switch (decodingClass)
    {
    case CLASS_A4_ARITH:
      CHECK_FIELD_A ();
      CHECK_FIELD_B ();
      if (!repeatsOp)
	CHECK_FIELD_C ();
      CHECK_FLAG_COND_NULLIFY ();

      write_instr_name ();
      if (!ignoreFirstOpd)
	{
	  WRITE_FORMAT_x (A);
	  WRITE_FORMAT_COMMA_x (B);
	  if (!repeatsOp)
	    WRITE_FORMAT_COMMA_x (C);
	  WRITE_NOP_COMMENT ();
	  arc_sprintf (state, state->operandBuffer, formatString,
		      fieldA, fieldB, fieldC);
	}
      else
	{
	  WRITE_FORMAT_x (B);
	  if (!repeatsOp)
	    WRITE_FORMAT_COMMA_x (C);
	  arc_sprintf (state, state->operandBuffer, formatString,
		      fieldB, fieldC);
	}
      write_comments ();
      break;

    case CLASS_A4_OP3_GENERAL:
      CHECK_FIELD_A ();
      CHECK_FIELD_B ();
      CHECK_FLAG_COND_NULLIFY ();

      write_instr_name ();
      if (!ignoreFirstOpd)
	{
	  WRITE_FORMAT_x (A);
	  WRITE_FORMAT_COMMA_x (B);
	  WRITE_NOP_COMMENT ();
	  arc_sprintf (state, state->operandBuffer, formatString,
		      fieldA, fieldB);
	}
      else
	{
	  WRITE_FORMAT_x (B);
	  arc_sprintf (state, state->operandBuffer, formatString, fieldB);
	}
      write_comments ();
      break;

    case CLASS_A4_FLAG:
      CHECK_FIELD_B ();
      CHECK_FLAG_COND_NULLIFY ();
      flag = 0; /* This is the FLAG instruction -- it's redundant.  */

      write_instr_name ();
      WRITE_FORMAT_x (B);
      arc_sprintf (state, state->operandBuffer, formatString, fieldB);
      write_comments ();
      break;

    case CLASS_A4_BRANCH:
      fieldA = BITS (state->words[0],7,26) << 2;
      fieldA = (fieldA << 10) >> 10; /* Make it signed.  */
      fieldA += addr + 4;
      CHECK_FLAG_COND_NULLIFY ();
      flag = 0;

      write_instr_name ();
      /* This address could be a label we know. Convert it.  */
      if (state->_opcode != op_LPC /* LP  */)
	{
	  add_target (fieldA); /* For debugger.  */
	  state->flow = state->_opcode == op_BLC /* BL  */
	    ? direct_call
	    : direct_jump;
	  /* indirect calls are achieved by "lr blink,[status];
	     lr dest<- func addr; j [dest]"  */
	}

      strcat (formatString, "%s"); /* Address/label name.  */
      arc_sprintf (state, state->operandBuffer, formatString,
		  post_address (state, fieldA));
      write_comments ();
      break;

    case CLASS_A4_JC:
      /* For op_JC -- jump to address specified.
	 Also covers jump and link--bit 9 of the instr. word
	 selects whether linked, thus "is_linked" is set above.  */
      fieldA = 0;
      CHECK_FIELD_B ();
      CHECK_FLAG_COND_NULLIFY ();

      if (!fieldBisReg)
	{
	  fieldAisReg = 0;
	  fieldA = (fieldB >> 25) & 0x7F; /* Flags.  */
	  fieldB = (fieldB & 0xFFFFFF) << 2;
	  state->flow = is_linked ? direct_call : direct_jump;
	  add_target (fieldB);
	  /* Screwy JLcc requires .jd mode to execute correctly
	     but we pretend it is .nd (no delay slot).  */
	  if (is_linked && state->nullifyMode == BR_exec_when_jump)
	    state->nullifyMode = BR_exec_when_no_jump;
	}
      else
	{
	  state->flow = is_linked ? indirect_call : indirect_jump;
	  /* We should also treat this as indirect call if NOT linked
	     but the preceding instruction was a "lr blink,[status]"
	     and we have a delay slot with "add blink,blink,2".
	     For now we can't detect such.  */
	  state->register_for_indirect_jump = fieldB;
	}

      write_instr_name ();
      strcat (formatString,
	      IS_REG (B) ? "[%r]" : "%s"); /* Address/label name.  */
      if (fieldA != 0)
	{
	  fieldAisReg = 0;
	  WRITE_FORMAT_COMMA_x (A);
	}
      if (IS_REG (B))
	arc_sprintf (state, state->operandBuffer, formatString, fieldB, fieldA);
      else
	arc_sprintf (state, state->operandBuffer, formatString,
		    post_address (state, fieldB), fieldA);
      write_comments ();
      break;

    case CLASS_A4_LD0:
      /* LD instruction.
	 B and C can be regs, or one (both?) can be limm.  */
      CHECK_FIELD_A ();
      CHECK_FIELD_B ();
      CHECK_FIELD_C ();
      if (dbg)
	printf ("5:b reg %d %d c reg %d %d  \n",
		fieldBisReg,fieldB,fieldCisReg,fieldC);
      state->_offset = 0;
      state->_ea_present = 1;
      if (fieldBisReg)
	state->ea_reg1 = fieldB;
      else
	state->_offset += fieldB;
      if (fieldCisReg)
	state->ea_reg2 = fieldC;
      else
	state->_offset += fieldC;
      state->_mem_load = 1;

      directMem     = BIT (state->words[0], 5);
      addrWriteBack = BIT (state->words[0], 3);
      signExtend    = BIT (state->words[0], 0);

      write_instr_name ();
      WRITE_FORMAT_x_COMMA_LB(A);
      if (fieldBisReg || fieldB != 0)
	WRITE_FORMAT_x_COMMA (B);
      else
	fieldB = fieldC;

      WRITE_FORMAT_x_RB (C);
      arc_sprintf (state, state->operandBuffer, formatString,
		  fieldA, fieldB, fieldC);
      write_comments ();
      break;

    case CLASS_A4_LD1:
      /* LD instruction.  */
      CHECK_FIELD_B ();
      CHECK_FIELD_A ();
      fieldC = FIELDD (state->words[0]);

      if (dbg)
	printf ("6:b reg %d %d c 0x%x  \n",
		fieldBisReg, fieldB, fieldC);
      state->_ea_present = 1;
      state->_offset = fieldC;
      state->_mem_load = 1;
      if (fieldBisReg)
	state->ea_reg1 = fieldB;
      /* Field B is either a shimm (same as fieldC) or limm (different!)
	 Say ea is not present, so only one of us will do the name lookup.  */
      else
	state->_offset += fieldB, state->_ea_present = 0;

      directMem     = BIT (state->words[0],14);
      addrWriteBack = BIT (state->words[0],12);
      signExtend    = BIT (state->words[0],9);

      write_instr_name ();
      WRITE_FORMAT_x_COMMA_LB (A);
      if (!fieldBisReg)
	{
	  fieldB = state->_offset;
	  WRITE_FORMAT_x_RB (B);
	}
      else
	{
	  WRITE_FORMAT_x (B);
	  if (fieldC != 0 && !BIT (state->words[0],13))
	    {
	      fieldCisReg = 0;
	      WRITE_FORMAT_COMMA_x_RB (C);
	    }
	  else
	    WRITE_FORMAT_RB ();
	}
      arc_sprintf (state, state->operandBuffer, formatString,
		  fieldA, fieldB, fieldC);
      write_comments ();
      break;

    case CLASS_A4_ST:
      /* ST instruction.  */
      CHECK_FIELD_B();
      CHECK_FIELD_C();
      fieldA = FIELDD(state->words[0]); /* shimm  */

      /* [B,A offset]  */
      if (dbg) printf("7:b reg %d %x off %x\n",
		      fieldBisReg,fieldB,fieldA);
      state->_ea_present = 1;
      state->_offset = fieldA;
      if (fieldBisReg)
	state->ea_reg1 = fieldB;
      /* Field B is either a shimm (same as fieldA) or limm (different!)
	 Say ea is not present, so only one of us will do the name lookup.
	 (for is_limm we do the name translation here).  */
      else
	state->_offset += fieldB, state->_ea_present = 0;

      directMem     = BIT (state->words[0], 26);
      addrWriteBack = BIT (state->words[0], 24);

      write_instr_name ();
      WRITE_FORMAT_x_COMMA_LB(C);

      if (!fieldBisReg)
	{
	  fieldB = state->_offset;
	  WRITE_FORMAT_x_RB (B);
	}
      else
	{
	  WRITE_FORMAT_x (B);
	  if (fieldBisReg && fieldA != 0)
	    {
	      fieldAisReg = 0;
	      WRITE_FORMAT_COMMA_x_RB(A);
	    }
	  else
	    WRITE_FORMAT_RB();
	}
      arc_sprintf (state, state->operandBuffer, formatString,
		  fieldC, fieldB, fieldA);
      write_comments2 (fieldA);
      break;

    case CLASS_A4_SR:
      /* SR instruction  */
      CHECK_FIELD_B();
      CHECK_FIELD_C();

      write_instr_name ();
      WRITE_FORMAT_x_COMMA_LB(C);
      /* Try to print B as an aux reg if it is not a core reg.  */
      usesAuxReg = 1;
      WRITE_FORMAT_x (B);
      WRITE_FORMAT_RB ();
      arc_sprintf (state, state->operandBuffer, formatString, fieldC, fieldB);
      write_comments ();
      break;

    case CLASS_A4_OP3_SUBOPC3F:
      write_instr_name ();
      state->operandBuffer[0] = '\0';
      break;

    case CLASS_A4_LR:
      /* LR instruction */
      CHECK_FIELD_A ();
      CHECK_FIELD_B ();

      write_instr_name ();
      WRITE_FORMAT_x_COMMA_LB (A);
      /* Try to print B as an aux reg if it is not a core reg. */
      usesAuxReg = 1;
      WRITE_FORMAT_x (B);
      WRITE_FORMAT_RB ();
      arc_sprintf (state, state->operandBuffer, formatString, fieldA, fieldB);
      write_comments ();
      break;

    default:
      mwerror (state, "Bad decoding class in ARC disassembler");
      break;
    }

  state->_cond = cond;
  return state->instructionLen = offset;
}


/* Returns the name the user specified core extension register.  */

static const char *
_coreRegName(void * arg ATTRIBUTE_UNUSED, int regval)
{
  return arcExtMap_coreRegName (regval);
}

/* Returns the name the user specified AUX extension register.  */

static const char *
_auxRegName(void *_this ATTRIBUTE_UNUSED, int regval)
{
  return arcExtMap_auxRegName(regval);
}

/* Returns the name the user specified condition code name.  */

static const char *
_condCodeName(void *_this ATTRIBUTE_UNUSED, int regval)
{
  return arcExtMap_condCodeName(regval);
}

/* Returns the name the user specified extension instruction.  */

static const char *
_instName (void *_this ATTRIBUTE_UNUSED, int majop, int minop, int *flags)
{
  return arcExtMap_instName(majop, minop, flags);
}

/* Decode an instruction returning the size of the instruction
   in bytes or zero if unrecognized.  */

static int
decodeInstr (bfd_vma            address, /* Address of this instruction.  */
	     disassemble_info * info)
{
  int status;
  bfd_byte buffer[4];
  struct arcDisState s;		/* ARC Disassembler state.  */
  void *stream = info->stream; 	/* Output stream.  */
  fprintf_ftype func = info->fprintf_func;

  memset (&s, 0, sizeof(struct arcDisState));

  /* read first instruction  */
  status = (*info->read_memory_func) (address, buffer, 4, info);
  if (status != 0)
    {
      (*info->memory_error_func) (status, address, info);
      return 0;
    }
  if (info->endian == BFD_ENDIAN_LITTLE)
    s.words[0] = bfd_getl32(buffer);
  else
    s.words[0] = bfd_getb32(buffer);
  /* Always read second word in case of limm.  */

  /* We ignore the result since last insn may not have a limm.  */
  status = (*info->read_memory_func) (address + 4, buffer, 4, info);
  if (info->endian == BFD_ENDIAN_LITTLE)
    s.words[1] = bfd_getl32(buffer);
  else
    s.words[1] = bfd_getb32(buffer);

  s._this = &s;
  s.coreRegName = _coreRegName;
  s.auxRegName = _auxRegName;
  s.condCodeName = _condCodeName;
  s.instName = _instName;

  /* Disassemble.  */
  dsmOneArcInst (address, & s);

  /* Display the disassembly instruction.  */
  (*func) (stream, "%08lx ", s.words[0]);
  (*func) (stream, "    ");
  (*func) (stream, "%-10s ", s.instrBuffer);

  if (__TRANSLATION_REQUIRED (s))
    {
      bfd_vma addr = s.addresses[s.operandBuffer[1] - '0'];

      (*info->print_address_func) ((bfd_vma) addr, info);
      (*func) (stream, "\n");
    }
  else
    (*func) (stream, "%s",s.operandBuffer);

  return s.instructionLen;
}

/* Return the print_insn function to use.
   Side effect: load (possibly empty) extension section  */

disassembler_ftype
arc_get_disassembler (void *ptr)
{
  if (ptr)
    build_ARC_extmap ((struct bfd *) ptr);
  return decodeInstr;
}
@


1.17
log
@	* arc-dis.c: Include sysdep.h first, remove some redundant includes.
	* bfin-dis.c: Likewise.
	* i860-dis.c: Likewise.
	* ia64-dis.c: Likewise.
	* ia64-gen.c: Likewise.
	* m68hc11-dis.c: Likewise.
	* mmix-dis.c: Likewise.
	* msp430-dis.c: Likewise.
	* or32-dis.c: Likewise.
	* rl78-dis.c: Likewise.
	* rx-dis.c: Likewise.
	* tic4x-dis.c: Likewise.
	* tilegx-opc.c: Likewise.
	* tilepro-opc.c: Likewise.
	* rx-decode.c: Regenerate.
@
text
@d429 1
a429 2
	  strncat (state->commentBuffer, state->comm[i],
		   sizeof (state->commentBuffer));
@


1.16
log
@	* arc-dis.c (BITS): Don't use shifts to mask off bits.
	(FIELDD): Sign extend with xor,sub.
@
text
@d23 1
a23 1
#include "ansidecl.h"
a28 1
#include <string.h>
@


1.15
log
@fix set but unused variable warnings
@
text
@d2 2
a3 2
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2005, 2007, 2009, 2010
   Free Software Foundation, Inc.
d63 1
a63 1
#define BITS(word,s,e)  (((word) << (31 - e)) >> (s + (31 - e)))
d69 2
a70 3
/* FIELD D is signed in all of its uses, so we make sure argument is
   treated as signed for bit shifting purposes:  */
#define FIELDD(word)	(BITS (((signed int)word), 0, 8))
@


1.14
log
@        Update soruces to make alpha, arc and arm targets compile cleanly
        with -Wc++-compat:
        * config/tc-alpha.c: Add casts.
        (extended_bfd_reloc_code_real_type): New type. Used to avoid
        enumeration conversion warnings.
        (struct alpha_fixup, void assemble_insn, assemble_insn)
        (assemble_tokens): Use new type.
        * ecoff.c: Add casts. (mark_stabs): Use enumeration names.
        * config/obj-elf.c: Add cast
        * config/tc-arc.c: Add casts.
        * config/obj-aout.h (text_section,data_section,bss_section):
        Make extern.
        * config/obj-elf.c: Add cast.
        * config/tc-arm.c: Add casts.
        (X, TxCE, TxCE, TxC3, TxC3w, TxCM_, TxCM, TUE, TUF, CE, CL, cCE)
        (cCL, C3E, xCM_, nUF, nCE_tag): Change input format to avoid the
        need for keywords as arguments.
        * ecoff.c: Add casts.
        * ecofflink.c: Add casts.
        * elf64-alpha.c: Add casts.
        (struct alpha_elf_got_entry, struct alpha_elf_reloc_entry): Move
        to top level.
        (SKIP_HOWTO): Use enum name.
        * elf32-arm.c: Add casts.
        (elf32_arm_vxworks_bed): Update code to avoid multiple
        declarations.
        (struct map_stub): Move to top level.
        * arc-dis.c Fix casts.
        * arc-ext.c: Add casts.
        * arm-dis.c (enum opcode_sentinel_enum): Gave name to anonymous
        enum.
        * emultempl/armelf.em: Add casts.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2005, 2007, 2009
a240 1
  long auxNum;
a247 1
  auxNum = -1;
a1170 1
  int bytes;
d1201 1
a1201 1
  bytes = dsmOneArcInst (address, & s);
@


1.13
log
@Change source files over to GPLv3.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2005, 2007
d1204 1
a1204 1
  bytes = dsmOneArcInst (address, (void *)& s);
d1231 1
a1231 1
    build_ARC_extmap (ptr);
@


1.13.32.1
log
@Commit patches for ARCompact support to binutils-arc-20081103-branch .
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2005, 2006, 2007, 2008, 2009
d23 1
a23 1
#include <ansidecl.h>
a34 8
#include "arcompact-dis.h"

#include <stdlib.h>
  /*
    warning: implicit declaration of function `printf_unfiltered'
    if dbg is 1 then this definition is required
  */
  void printf_unfiltered (const char *,...);
d77 1
a77 1
	mwerror (state, _("Illegal limm reference in last instruction!\n")); \
d86 5
a90 5
	{							\
	  flag = BIT (state->words[0], 8);			\
	  state->nullifyMode = BITS (state->words[0], 5, 6);	\
	  cond = BITS (state->words[0], 0, 4);			\
	}							\
d98 1
a98 1
	cond = BITS (state->words[0],0,4);	\
d106 2
a107 2
	{					\
	  is_limm++;				\
d113 1
a113 1
	{					\
d127 1
a127 1
	{					\
d219 1
a219 1
  unsigned int j, i = state->acnt;
d221 1
a221 1
  if (i < ARRAY_SIZE (state->addresses))
d257 1
a257 1
	goto DOCOMM; /* Return.  */
d281 1
a281 1
		leading_zero = 1; /* e.g. %08x */
d294 1
d296 2
a297 2
	         one place, here, if we wish.
	         We add underscores for easy reading.  */
d337 1
d349 1
a349 1
		    const char *ext;
d355 1
a355 1
		      sprintf (bp, "r%d", val);
d366 3
a368 1
#define AUXREG2NAME(num, name) case num: sprintf (bp,""name); break;
a376 1
		
d392 1
d399 1
d460 1
d467 1
d472 1
d475 1
d478 1
d481 1
a489 2
    case BR_exec_when_no_jump:
      break;
d491 1
d494 1
d497 1
d505 1
a505 1
      write_instr_name_(state, instrName, cond, condCodeIsPartOfName,	\
d526 1
a526 1
  const char *instrName;
d528 10
a537 3
  int fieldAisReg = 1, fieldBisReg = 1, fieldCisReg = 1;
  int fieldA, fieldB, fieldC = 0;
  int flag = 0, cond = 0, is_shimm = 0, is_limm = 0;
d539 3
a541 1
  int signExtend = 0, addrWriteBack = 0, directMem = 0;
d545 1
a547 1
  int flags = E_ARC_MACH_A4;
d613 16
a628 5
	    case 0: instrName = "ld";       state->_load_len = 4; break;
	    case 1: instrName = "ldb";      state->_load_len = 1; break;
	    case 2: instrName = "ldw";      state->_load_len = 2; break;
	    default: instrName = "??? (1[3])"; 
	      state->flow = invalid_instr; break;
d644 13
a656 5
	    case 0: instrName = "st";       break;
	    case 1: instrName = "stb";      break;
	    case 2: instrName = "stw";      break;
	    default: instrName = "??? (2[3])"; 
	      state->flow = invalid_instr; break;
a730 1
	  
d734 8
a741 3
    case op_BC:  instrName = "b";  
    case op_BLC: if (!instrName) instrName = "bl"; 
    case op_LPC: if (!instrName) instrName = "lp"; 
d765 1
d768 9
a776 3
	case op_ADD: instrName = (repeatsOp ? "asl" : "add"); break;
	case op_ADC: instrName = (repeatsOp ? "rlc" : "adc"); break;
	case op_AND: instrName = (repeatsOp ? "mov" : "and"); break;
d780 8
a787 5

    case op_SUB: instrName = "sub"; break;
    case op_SBC: instrName = "sbc"; break;
    case op_OR:  instrName = "or";  break;
    case op_BIC: instrName = "bic"; break;
d792 1
a792 3
	/*
	 * Official encoding for NOP (there are many possibilities
	   with ARC).  This encoding says: xor -1, -1, -1.  */
d802 1
a802 1
      /* if (instrName) printf ("FLAGS=0x%x\n", flags); */
d815 1
a815 1
  state->nullifyMode = BR_exec_when_no_jump;	/* 0 */
d889 1
a889 1
 
d891 2
a892 2
      /* This address could be a label we know.  Convert it.  */
      if (state->_opcode != op_LPC /* LP */)
d895 3
a897 2
	  state->flow
	    = state->_opcode == op_BLC /* BL */ ? direct_call : direct_jump;
d955 2
a956 1
      /* LD instruction.  B and C can be regs, or one (both?) can be limm.  */
d999 2
a1000 2
	printf_unfiltered ("6:b reg %d %d c 0x%x  \n",
			   fieldBisReg, fieldB, fieldC);
d1042 5
a1046 5
      fieldA = FIELDD(state->words[0]); /* shimm */
      
      /* [B,A offset] */
      if (dbg) printf_unfiltered("7:b reg %d %x off %x\n",
				 fieldBisReg,fieldB,fieldA);
d1085 1
a1085 1
      /* SR instruction */
d1129 1
a1129 2
/* Return the name of the user specified core extension register REGNUM.
   CPP_THIS is the C++ this pointer.  */
d1132 1
a1132 1
_coreRegName (void *cpp_this ATTRIBUTE_UNUSED, int regnum)
d1134 1
a1134 1
  return arcExtMap_coreRegName (regnum);
d1137 1
a1137 2
/* Return the name of the user specified AUX extension register REGNUM.
   CPP_THIS is the C++ this pointer.  */
d1140 1
a1140 1
_auxRegName (void *cpp_this ATTRIBUTE_UNUSED, int regnum)
d1142 1
a1142 1
  return arcExtMap_auxRegName (regnum);
d1145 1
a1145 2
/* Return the name of the user specified condition code with encoding NUM.
   CPP_THIS is the C++ this pointer.  */
d1148 1
a1148 1
_condCodeName (void *cpp_this ATTRIBUTE_UNUSED, int num)
d1150 1
a1150 1
  return arcExtMap_condCodeName (num);
d1153 1
a1153 4
/* Return the name of the user specified extension instruction
   with major opcode MAJOP and minor opcode MINOP.
   CPP_THIS is the C++ this pointer.
   FLAGS are the instruction flags.  */
d1158 1
a1158 1
  return arcExtMap_instName (majop, minop, flags);
d1161 2
a1162 3
/* Decode an ARCtangent instruction returning the size of the instruction
   in bytes or zero if unrecognized.
   ADDRESS is the address of this instruction.  */
d1165 2
a1166 1
ARCTangent_decodeInstr (bfd_vma address, disassemble_info *info)
d1177 1
a1177 1
  /* Read first instruction.  */
d1182 1
a1182 1
      return -1;
d1189 1
a1221 1

d1225 1
a1225 1
   Side effect: load (possibly empty) extension section.  */
d1228 1
a1228 1
arc_get_disassembler (bfd *abfd)
d1230 3
a1232 16
  unsigned short mach_abfd = elf_elfheader(abfd)->e_machine;
  build_ARC_extmap (abfd);

  switch(mach_abfd)
    {
    case EM_ARC:
      return ARCTangent_decodeInstr;
    case EM_ARCOMPACT:
      return ARCompact_decodeInstr;
    default:
      if (bfd_get_mach (abfd) ==  E_ARC_MACH_A4)
	return ARCTangent_decodeInstr;
      else 
	return ARCompact_decodeInstr;
      abort();			/* never reached */
    }
@


1.13.22.1
log
@Check in ARCompact simulator.  A valid configuration is arc-elf.
This is not quite finished and has most likely a few files that are
obsolete & not used, but it's good enough to run gcc regression tests.
@
text
@d1 2
a2 7
/* Disassembler interface for targets using CGEN. -*- C -*-
   CGEN: Cpu tools GENerator

   THIS FILE IS MACHINE GENERATED WITH CGEN.
   - the resultant file is machine generated, cgen-dis.in isn't

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2007
d4 1
d19 3
a21 5
   along with this program; if not, write to the Free Software Foundation, Inc.,
   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */

/* ??? Eventually more and more of this stuff can go to cpu-independent files.
   Keep that in mind.  */
a22 2
#include "sysdep.h"
#include <stdio.h>
d24 1
d26 4
a29 5
#include "bfd.h"
#include "symcat.h"
#include "libiberty.h"
#include "arc-desc.h"
#include "arc-opc.h"
d32 156
a187 2
/* Default text to print if an instruction isn't recognized.  */
#define UNKNOWN_INSN_MSG _("*unknown*")
d189 7
a195 17
static void print_normal
  (CGEN_CPU_DESC, void *, long, unsigned int, bfd_vma, int);
static void print_address
  (CGEN_CPU_DESC, void *, bfd_vma, unsigned int, bfd_vma, int) ATTRIBUTE_UNUSED;
static void print_keyword
  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long, unsigned int) ATTRIBUTE_UNUSED;
static void print_insn_normal
  (CGEN_CPU_DESC, void *, const CGEN_INSN *, CGEN_FIELDS *, bfd_vma, int);
static int print_insn
  (CGEN_CPU_DESC, bfd_vma,  disassemble_info *, bfd_byte *, unsigned);
static int default_print_insn
  (CGEN_CPU_DESC, bfd_vma, disassemble_info *) ATTRIBUTE_UNUSED;
static int read_insn
  (CGEN_CPU_DESC, bfd_vma, disassemble_info *, bfd_byte *, int, CGEN_EXTRACT_INFO *,
   unsigned long *);

/* -- disassembler routines inserted here.  */
d197 10
a206 2
/* -- dis.c */
char limm_str[11] = "0x";
a207 1
/* Read a long immediate and write it hexadecimally into limm_str.  */
d209 1
a209 1
read_limm (CGEN_EXTRACT_INFO *ex_info, bfd_vma pc)
d211 9
a219 4
  unsigned char buf[2];
  int i;
  char *limmp = limm_str + 2;
  disassemble_info *dis_info = (disassemble_info *) ex_info->dis_info;
d221 1
a221 1
  for (i = 0; i < 2; i++, limmp +=4, pc += 2)
d223 6
a228 1
      int status = (*dis_info->read_memory_func) (pc, buf, 2, dis_info);
d230 1
a230 5
      if (status != 0)
        (*dis_info->memory_error_func) (status, pc, dis_info);
      sprintf (limmp, "%.4x",
	       (unsigned) bfd_get_bits (buf, 16,
					dis_info->endian == BFD_ENDIAN_BIG));
d232 1
d235 2
a236 11
/* Return the actual instruction length, in bits, which depends on the size
   of the opcode - 2 or 4 bytes - and the absence or presence of a (4 byte)
   long immediate.
   Also, if a long immediate is present, put its hexadecimal representation
   into limm_str.
   ??? cgen-opc.c:cgen_lookup_insn has a 'sanity' check of the length
   that will fail if its input length differs from the result of
   CGEN_EXTRACT_FN.  Need to check when this could trigger.  */
int
arc_insn_length (unsigned long insn_value, const CGEN_INSN *insn,
		 CGEN_EXTRACT_INFO *info, bfd_vma pc)
d238 17
a254 5
  switch (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_LIMM))
    {
    case LIMM_NONE:
      return CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_SHORT_P) ? 16 : 32;
    case LIMM_H:
d256 38
a293 2
	/* This is a short insn; extract the actual opcode.  */
	unsigned high = insn_value >> 16;
d295 109
a403 4
        if ((high & 0xe7) != 0xc7)
	  return 16;
	read_limm (info, pc+2);
	return 48;
d405 31
a435 14
    case LIMM_B:
      if ((insn_value & 0x07007000) != 0x06007000)
	return 32;
      break;
    case LIMM_BC:
      if ((insn_value & 0x07007000) == 0x06007000)
	break;
      /* Fall through.  */
    case LIMM_C:
      if ((insn_value & 0x00000fc0) != 0x00000f80)
	return 32;
      break;
    default:
      abort ();
a436 2
  read_limm (info, pc+4);
  return 64;
d439 2
a440 1
/* -- */
d442 6
a447 2
void arc_cgen_print_operand
  (CGEN_CPU_DESC, int, PTR, CGEN_FIELDS *, void const *, bfd_vma, int);
d449 9
a457 23
/* Main entry point for printing operands.
   XINFO is a `void *' and not a `disassemble_info *' to not put a requirement
   of dis-asm.h on cgen.h.

   This function is basically just a big switch statement.  Earlier versions
   used tables to look up the function to use, but
   - if the table contains both assembler and disassembler functions then
     the disassembler contains much of the assembler and vice-versa,
   - there's a lot of inlining possibilities as things grow,
   - using a switch statement avoids the function call overhead.

   This function could be moved into `print_insn_normal', but keeping it
   separate makes clear the interface between `print_insn_normal' and each of
   the handlers.  */

void
arc_cgen_print_operand (CGEN_CPU_DESC cd,
			   int opindex,
			   void * xinfo,
			   CGEN_FIELDS *fields,
			   void const *attrs ATTRIBUTE_UNUSED,
			   bfd_vma pc,
			   int length)
d459 1
a459 1
  disassemble_info *info = (disassemble_info *) xinfo;
d461 1
a461 1
  switch (opindex)
d463 23
a485 2
    case ARC_OPERAND_EXDI :
      print_keyword (cd, info, & arc_cgen_opval_h_Di, fields->f_F, 0);
d487 2
a488 221
    case ARC_OPERAND_F :
      print_keyword (cd, info, & arc_cgen_opval_h_uflags, fields->f_F, 0);
      break;
    case ARC_OPERAND_F0 :
      print_keyword (cd, info, & arc_cgen_opval_h_nil, fields->f_F, 0);
      break;
    case ARC_OPERAND_F1 :
      print_keyword (cd, info, & arc_cgen_opval_h_auflags, fields->f_F, 0);
      break;
    case ARC_OPERAND_F1F :
      print_keyword (cd, info, & arc_cgen_opval_h_aufflags, fields->f_F, 0);
      break;
    case ARC_OPERAND_GP :
      print_keyword (cd, info, & arc_cgen_opval_h_gp, 0, 0);
      break;
    case ARC_OPERAND_LDODI :
      print_keyword (cd, info, & arc_cgen_opval_h_Di, fields->f_LDODi, 0);
      break;
    case ARC_OPERAND_LDRDI :
      print_keyword (cd, info, & arc_cgen_opval_h_Di, fields->f_LDRDi, 0);
      break;
    case ARC_OPERAND_NE :
      print_keyword (cd, info, & arc_cgen_opval_h_ne, 0, 0);
      break;
    case ARC_OPERAND_PCL :
      print_keyword (cd, info, & arc_cgen_opval_h_pcl, 0, 0);
      break;
    case ARC_OPERAND_QCONDB :
      print_keyword (cd, info, & arc_cgen_opval_h_Qcondb, fields->f_cond_Q, 0);
      break;
    case ARC_OPERAND_QCONDI :
      print_keyword (cd, info, & arc_cgen_opval_h_Qcondi, fields->f_cond_Q, 0);
      break;
    case ARC_OPERAND_QCONDJ :
      print_keyword (cd, info, & arc_cgen_opval_h_Qcondj, fields->f_cond_Q, 0);
      break;
    case ARC_OPERAND_R0 :
      print_keyword (cd, info, & arc_cgen_opval_h_r0, 0, 0);
      break;
    case ARC_OPERAND_R31 :
      print_keyword (cd, info, & arc_cgen_opval_h_r31, 0, 0);
      break;
    case ARC_OPERAND_RA :
      print_keyword (cd, info, & arc_cgen_opval_cr_names, fields->f_op_A, 0);
      break;
    case ARC_OPERAND_RA_0 :
      print_keyword (cd, info, & arc_cgen_opval_h_nil, fields->f_op_A, 0);
      break;
    case ARC_OPERAND_RB :
      print_keyword (cd, info, & arc_cgen_opval_cr_names, fields->f_op_B, 0|(1<<CGEN_OPERAND_VIRTUAL));
      break;
    case ARC_OPERAND_RB_0 :
      print_keyword (cd, info, & arc_cgen_opval_h_nil, fields->f_op_B, 0|(1<<CGEN_OPERAND_VIRTUAL));
      break;
    case ARC_OPERAND_RC :
      print_keyword (cd, info, & arc_cgen_opval_cr_names, fields->f_op_C, 0);
      break;
    case ARC_OPERAND_RC_ILINK :
      print_keyword (cd, info, & arc_cgen_opval_h_ilinkx, fields->f_op_Cj, 0);
      break;
    case ARC_OPERAND_RC_NOILINK :
      print_keyword (cd, info, & arc_cgen_opval_h_noilink, fields->f_op_Cj, 0);
      break;
    case ARC_OPERAND_R_A :
      print_keyword (cd, info, & arc_cgen_opval_h_cr16, fields->f_op__a, 0);
      break;
    case ARC_OPERAND_R_B :
      print_keyword (cd, info, & arc_cgen_opval_h_cr16, fields->f_op__b, 0);
      break;
    case ARC_OPERAND_R_C :
      print_keyword (cd, info, & arc_cgen_opval_h_cr16, fields->f_op__c, 0);
      break;
    case ARC_OPERAND_RCC :
      print_keyword (cd, info, & arc_cgen_opval_h_Rcc, fields->f_brcond, 0);
      break;
    case ARC_OPERAND_RCCS :
      print_keyword (cd, info, & arc_cgen_opval_h_RccS, fields->f_brscond, 0);
      break;
    case ARC_OPERAND_RH :
      print_keyword (cd, info, & arc_cgen_opval_cr_names, fields->f_op_h, 0|(1<<CGEN_OPERAND_VIRTUAL));
      break;
    case ARC_OPERAND_SP :
      print_keyword (cd, info, & arc_cgen_opval_h_sp, 0, 0);
      break;
    case ARC_OPERAND_STODI :
      print_keyword (cd, info, & arc_cgen_opval_h_Di, fields->f_STODi, 0);
      break;
    case ARC_OPERAND_U6 :
      print_normal (cd, info, fields->f_u6, 0, pc, length);
      break;
    case ARC_OPERAND_U6X2 :
      print_normal (cd, info, fields->f_u6x2, 0, pc, length);
      break;
    case ARC_OPERAND__AW :
      print_keyword (cd, info, & arc_cgen_opval_h__aw, 0, 0);
      break;
    case ARC_OPERAND__L :
      print_keyword (cd, info, & arc_cgen_opval_h_insn32, 0, 0);
      break;
    case ARC_OPERAND__S :
      print_keyword (cd, info, & arc_cgen_opval_h_insn16, 0, 0);
      break;
    case ARC_OPERAND_CBIT :
      print_normal (cd, info, 0, 0, pc, length);
      break;
    case ARC_OPERAND_DELAY_N :
      print_keyword (cd, info, & arc_cgen_opval_h_delay, fields->f_delay_N, 0);
      break;
    case ARC_OPERAND_DUMMY_OP :
      print_normal (cd, info, fields->f_dummy, 0, pc, length);
      break;
    case ARC_OPERAND_I2COND :
      print_keyword (cd, info, & arc_cgen_opval_h_i2cond, fields->f_cond_i2, 0);
      break;
    case ARC_OPERAND_I3COND :
      print_keyword (cd, info, & arc_cgen_opval_h_i3cond, fields->f_cond_i3, 0);
      break;
    case ARC_OPERAND_LABEL10 :
      print_address (cd, info, fields->f_rel10, 0|(1<<CGEN_OPERAND_PCREL_ADDR), pc, length);
      break;
    case ARC_OPERAND_LABEL13A :
      print_address (cd, info, fields->f_rel13bl, 0|(1<<CGEN_OPERAND_PCREL_ADDR), pc, length);
      break;
    case ARC_OPERAND_LABEL21 :
      print_address (cd, info, fields->f_rel21, 0|(1<<CGEN_OPERAND_PCREL_ADDR)|(1<<CGEN_OPERAND_VIRTUAL), pc, length);
      break;
    case ARC_OPERAND_LABEL21A :
      print_address (cd, info, fields->f_rel21bl, 0|(1<<CGEN_OPERAND_PCREL_ADDR)|(1<<CGEN_OPERAND_VIRTUAL), pc, length);
      break;
    case ARC_OPERAND_LABEL25 :
      print_address (cd, info, fields->f_rel25, 0|(1<<CGEN_OPERAND_PCREL_ADDR)|(1<<CGEN_OPERAND_VIRTUAL), pc, length);
      break;
    case ARC_OPERAND_LABEL25A :
      print_address (cd, info, fields->f_rel25bl, 0|(1<<CGEN_OPERAND_PCREL_ADDR)|(1<<CGEN_OPERAND_VIRTUAL), pc, length);
      break;
    case ARC_OPERAND_LABEL7 :
      print_address (cd, info, fields->f_rel7, 0|(1<<CGEN_OPERAND_PCREL_ADDR), pc, length);
      break;
    case ARC_OPERAND_LABEL8 :
      print_address (cd, info, fields->f_rel8, 0|(1<<CGEN_OPERAND_PCREL_ADDR), pc, length);
      break;
    case ARC_OPERAND_LABEL9 :
      print_address (cd, info, fields->f_rel9, 0|(1<<CGEN_OPERAND_PCREL_ADDR)|(1<<CGEN_OPERAND_VIRTUAL), pc, length);
      break;
    case ARC_OPERAND_LBIT :
      print_normal (cd, info, 0, 0, pc, length);
      break;
    case ARC_OPERAND_NBIT :
      print_normal (cd, info, 0, 0, pc, length);
      break;
    case ARC_OPERAND_S12 :
      print_normal (cd, info, fields->f_s12, 0|(1<<CGEN_OPERAND_SIGNED)|(1<<CGEN_OPERAND_VIRTUAL), pc, length);
      break;
    case ARC_OPERAND_S12X2 :
      print_normal (cd, info, fields->f_s12x2, 0|(1<<CGEN_OPERAND_SIGNED)|(1<<CGEN_OPERAND_VIRTUAL), pc, length);
      break;
    case ARC_OPERAND_S1BIT :
      print_normal (cd, info, 0, 0, pc, length);
      break;
    case ARC_OPERAND_S2BIT :
      print_normal (cd, info, 0, 0, pc, length);
      break;
    case ARC_OPERAND_S9 :
      print_normal (cd, info, fields->f_s9, 0|(1<<CGEN_OPERAND_SIGNED)|(1<<CGEN_OPERAND_VIRTUAL), pc, length);
      break;
    case ARC_OPERAND_S9X4 :
      print_normal (cd, info, fields->f_s9x4, 0, pc, length);
      break;
    case ARC_OPERAND_SC_S9_ :
      print_normal (cd, info, fields->f_s9x4, 0, pc, length);
      break;
    case ARC_OPERAND_SC_S9B :
      print_normal (cd, info, fields->f_s9x1, 0, pc, length);
      break;
    case ARC_OPERAND_SC_S9W :
      print_normal (cd, info, fields->f_s9x2, 0, pc, length);
      break;
    case ARC_OPERAND_SC_U5_ :
      print_normal (cd, info, fields->f_u5x4, 0, pc, length);
      break;
    case ARC_OPERAND_SC_U5B :
      print_normal (cd, info, fields->f_u5, 0, pc, length);
      break;
    case ARC_OPERAND_SC_U5W :
      print_normal (cd, info, fields->f_u5x2, 0, pc, length);
      break;
    case ARC_OPERAND_TRAPNUM :
      print_normal (cd, info, fields->f_trapnum, 0, pc, length);
      break;
    case ARC_OPERAND_U3 :
      print_normal (cd, info, fields->f_u3, 0, pc, length);
      break;
    case ARC_OPERAND_U5 :
      print_normal (cd, info, fields->f_u5, 0, pc, length);
      break;
    case ARC_OPERAND_U5X4 :
      print_normal (cd, info, fields->f_u5x4, 0, pc, length);
      break;
    case ARC_OPERAND_U7 :
      print_normal (cd, info, fields->f_u7, 0, pc, length);
      break;
    case ARC_OPERAND_U8 :
      print_normal (cd, info, fields->f_u8, 0, pc, length);
      break;
    case ARC_OPERAND_U8X4 :
      print_normal (cd, info, fields->f_u8x4, 0, pc, length);
      break;
    case ARC_OPERAND_UNCONDB :
      print_keyword (cd, info, & arc_cgen_opval_h_uncondb, 0, 0);
      break;
    case ARC_OPERAND_UNCONDI :
      print_keyword (cd, info, & arc_cgen_opval_h_uncondi, 0, 0);
      break;
    case ARC_OPERAND_UNCONDJ :
      print_keyword (cd, info, & arc_cgen_opval_h_uncondj, 0, 0);
      break;
    case ARC_OPERAND_VBIT :
      print_normal (cd, info, 0, 0, pc, length);
      break;
    case ARC_OPERAND_ZBIT :
      print_normal (cd, info, 0, 0, pc, length);
d490 7
d498 2
a499 6
    default :
      /* xgettext:c-format */
      fprintf (stderr, _("Unrecognized field %d while printing insn.\n"),
	       opindex);
    abort ();
  }
d502 10
a511 1
cgen_print_fn * const arc_cgen_print_handlers[] = 
d513 4
a516 1
  print_insn_normal,
d519 1
d521 2
a522 2
void
arc_cgen_init_dis (CGEN_CPU_DESC cd)
d524 50
a573 5
  arc_cgen_init_opcode_table (cd);
  arc_cgen_init_ibld_table (cd);
  cd->print_handlers = & arc_cgen_print_handlers[0];
  cd->print_operand = arc_cgen_print_operand;
}
d575 2
a576 2

/* Default print handler.  */
d578 24
a601 9
static void
print_normal (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	      void *dis_info,
	      long value,
	      unsigned int attrs,
	      bfd_vma pc ATTRIBUTE_UNUSED,
	      int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = (disassemble_info *) dis_info;
d603 30
a632 3
#ifdef CGEN_PRINT_NORMAL
  CGEN_PRINT_NORMAL (cd, info, value, attrs, pc, length);
#endif
d634 27
a660 8
  /* Print the operand as directed by the attributes.  */
  if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SEM_ONLY))
    ; /* nothing to do */
  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))
    (*info->fprintf_func) (info->stream, "%ld", value);
  else
    (*info->fprintf_func) (info->stream, "0x%lx", value);
}
d662 71
a732 1
/* Default address handler.  */
d734 26
a759 9
static void
print_address (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	       void *dis_info,
	       bfd_vma value,
	       unsigned int attrs,
	       bfd_vma pc ATTRIBUTE_UNUSED,
	       int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = (disassemble_info *) dis_info;
d761 4
a764 3
#ifdef CGEN_PRINT_ADDRESS
  CGEN_PRINT_ADDRESS (cd, info, value, attrs, pc, length);
#endif
d766 13
a778 12
  /* Print the operand as directed by the attributes.  */
  if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SEM_ONLY))
    ; /* Nothing to do.  */
  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_PCREL_ADDR))
    (*info->print_address_func) (value, info);
  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_ABS_ADDR))
    (*info->print_address_func) (value, info);
  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))
    (*info->fprintf_func) (info->stream, "%ld", (long) value);
  else
    (*info->fprintf_func) (info->stream, "0x%lx", (long) value);
}
d780 8
a787 1
/* Keyword print handler.  */
d789 10
a798 18
static void
print_keyword (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	       void *dis_info,
	       CGEN_KEYWORD *keyword_table,
	       long value,
	       unsigned int attrs ATTRIBUTE_UNUSED)
{
  disassemble_info *info = (disassemble_info *) dis_info;
  const CGEN_KEYWORD_ENTRY *ke;

  ke = cgen_keyword_lookup_value (keyword_table, value);
  if (ke != NULL)
    (*info->fprintf_func) (info->stream, "%s", ke->name);
  else
    (*info->fprintf_func) (info->stream, "???");
}

/* Default insn printer.
d800 12
a811 2
   DIS_INFO is defined as `void *' so the disassembler needn't know anything
   about disassemble_info.  */
d813 5
a817 11
static void
print_insn_normal (CGEN_CPU_DESC cd,
		   void *dis_info,
		   const CGEN_INSN *insn,
		   CGEN_FIELDS *fields,
		   bfd_vma pc,
		   int length)
{
  const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
  disassemble_info *info = (disassemble_info *) dis_info;
  const CGEN_SYNTAX_CHAR_TYPE *syn;
d819 8
a826 1
  CGEN_INIT_PRINT (cd);
d828 2
a829 3
  for (syn = CGEN_SYNTAX_STRING (syntax); *syn; ++syn)
    {
      if (CGEN_SYNTAX_MNEMONIC_P (*syn))
d831 7
a837 2
	  (*info->fprintf_func) (info->stream, "%s", CGEN_INSN_MNEMONIC (insn));
	  continue;
d839 1
a839 1
      if (CGEN_SYNTAX_CHAR_P (*syn))
d841 5
a845 2
	  (*info->fprintf_func) (info->stream, "%c", CGEN_SYNTAX_CHAR (*syn));
	  continue;
d847 2
d850 4
a853 9
      /* We have an operand.  */
      arc_cgen_print_operand (cd, CGEN_SYNTAX_FIELD (*syn), info,
				 fields, CGEN_INSN_ATTRS (insn), pc, length);
    }
}

/* Subroutine of print_insn. Reads an insn into the given buffers and updates
   the extract info.
   Returns 0 if all is well, non-zero otherwise.  */
d855 16
a870 10
static int
read_insn (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	   bfd_vma pc,
	   disassemble_info *info,
	   bfd_byte *buf,
	   int buflen,
	   CGEN_EXTRACT_INFO *ex_info,
	   unsigned long *insn_value)
{
  int status = (*info->read_memory_func) (pc, buf, buflen, info);
d872 29
a900 5
  if (status != 0)
    {
      (*info->memory_error_func) (status, pc, info);
      return -1;
    }
d902 5
a906 3
  ex_info->dis_info = info;
  ex_info->valid = (1 << buflen) - 1;
  ex_info->insn_bytes = buf;
d908 7
a914 3
  *insn_value = bfd_get_bits (buf, buflen * 8, info->endian == BFD_ENDIAN_BIG);
  return 0;
}
d916 21
a936 5
/* Utility to print an insn.
   BUF is the base part of the insn, target byte order, BUFLEN bytes long.
   The result is the size of the insn in bytes or zero for an unknown insn
   or -1 if an error occurs fetching data (memory_error_func will have
   been called).  */
d938 36
a973 24
static int
print_insn (CGEN_CPU_DESC cd,
	    bfd_vma pc,
	    disassemble_info *info,
	    bfd_byte *buf,
	    unsigned int buflen)
{
  CGEN_INSN_INT insn_value;
  const CGEN_INSN_LIST *insn_list;
  CGEN_EXTRACT_INFO ex_info;
  int basesize;

  /* Extract base part of instruction, just in case CGEN_DIS_* uses it. */
  basesize = cd->base_insn_bitsize < buflen * 8 ?
                                     cd->base_insn_bitsize : buflen * 8;
  insn_value = cgen_get_insn_value (cd, buf, basesize);


  /* Fill in ex_info fields like read_insn would.  Don't actually call
     read_insn, since the incoming buffer is already read (and possibly
     modified a la m32r).  */
  ex_info.valid = (1 << buflen) - 1;
  ex_info.dis_info = info;
  ex_info.insn_bytes = buf;
d975 10
a984 2
  /* The instructions are stored in hash lists.
     Pick the first one and keep trying until we find the right one.  */
d986 24
a1009 17
  insn_list = CGEN_DIS_LOOKUP_INSN (cd, (char *) buf, insn_value);
  while (insn_list != NULL)
    {
      const CGEN_INSN *insn = insn_list->insn;
      CGEN_FIELDS fields;
      int length;
      unsigned long insn_value_cropped;

#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
      /* Not needed as insn shouldn't be in hash lists if not supported.  */
      /* Supported by this cpu?  */
      if (! arc_cgen_insn_supported (cd, insn))
        {
          insn_list = CGEN_DIS_NEXT_INSN (insn_list);
	  continue;
        }
#endif
d1011 18
a1028 33
      /* Basic bit mask must be correct.  */
      /* ??? May wish to allow target to defer this check until the extract
	 handler.  */

      /* Base size may exceed this instruction's size.  Extract the
         relevant part from the buffer. */
      if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn), 
					   info->endian == BFD_ENDIAN_BIG);
      else
	insn_value_cropped = insn_value;

      if ((insn_value_cropped & CGEN_INSN_BASE_MASK (insn))
	  == CGEN_INSN_BASE_VALUE (insn))
	{
	  /* Printing is handled in two passes.  The first pass parses the
	     machine insn and extracts the fields.  The second pass prints
	     them.  */

	  /* Make sure the entire insn is loaded into insn_value, if it
	     can fit.  */
	  if (((unsigned) CGEN_INSN_BITSIZE (insn) > cd->base_insn_bitsize) &&
	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
	    {
	      unsigned long full_insn_value;
	      int rc = read_insn (cd, pc, info, buf,
				  CGEN_INSN_BITSIZE (insn) / 8,
				  & ex_info, & full_insn_value);
	      if (rc != 0)
		return rc;
	      length = CGEN_EXTRACT_FN (cd, insn)
		(cd, insn, &ex_info, full_insn_value, &fields, pc);
d1031 31
a1061 2
	    length = CGEN_EXTRACT_FN (cd, insn)
	      (cd, insn, &ex_info, insn_value_cropped, &fields, pc);
d1063 9
a1071 4
	  /* Length < 0 -> error.  */
	  if (length < 0)
	    return length;
	  if (length > 0)
d1073 2
a1074 3
	      CGEN_PRINT_FN (cd, insn) (cd, info, insn, &fields, pc, length);
	      /* Length is in bits, result is in bytes.  */
	      return length / 8;
d1076 2
d1079 39
d1119 3
a1121 1
      insn_list = CGEN_DIS_NEXT_INSN (insn_list);
d1124 27
a1150 1
  return 0;
d1153 7
a1159 3
/* Default value for CGEN_PRINT_INSN.
   The result is the size of the insn in bytes or zero for an unknown insn
   or -1 if an error occured fetching bytes.  */
d1161 2
a1162 3
#ifndef CGEN_PRINT_INSN
#define CGEN_PRINT_INSN default_print_insn
#endif
d1165 2
a1166 1
default_print_insn (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info)
a1167 2
  bfd_byte buf[CGEN_MAX_INSN_SIZE];
  int buflen;
d1169 5
d1175 1
a1175 10
  /* Attempt to read the base part of the insn.  */
  buflen = cd->base_insn_bitsize / 8;
  status = (*info->read_memory_func) (pc, buf, buflen, info);

  /* Try again with the minimum part, if min < base.  */
  if (status != 0 && (cd->min_insn_bitsize < cd->base_insn_bitsize))
    {
      buflen = cd->min_insn_bitsize / 8;
      status = (*info->read_memory_func) (pc, buf, buflen, info);
    }
d1177 2
d1181 2
a1182 2
      (*info->memory_error_func) (status, pc, info);
      return -1;
d1184 5
d1190 6
a1195 48
  return print_insn (cd, pc, info, buf, buflen);
}

/* Main entry point.
   Print one instruction from PC on INFO->STREAM.
   Return the size of the instruction (in bytes).  */

typedef struct cpu_desc_list
{
  struct cpu_desc_list *next;
  CGEN_BITSET *isa;
  int mach;
  int endian;
  CGEN_CPU_DESC cd;
} cpu_desc_list;

int
print_insn_arc (bfd_vma pc, disassemble_info *info)
{
  static cpu_desc_list *cd_list = 0;
  cpu_desc_list *cl = 0;
  static CGEN_CPU_DESC cd = 0;
  static CGEN_BITSET *prev_isa;
  static int prev_mach;
  static int prev_endian;
  int length;
  CGEN_BITSET *isa;
  int mach;
  int endian = (info->endian == BFD_ENDIAN_BIG
		? CGEN_ENDIAN_BIG
		: CGEN_ENDIAN_LITTLE);
  enum bfd_architecture arch;

  /* ??? gdb will set mach but leave the architecture as "unknown" */
#ifndef CGEN_BFD_ARCH
#define CGEN_BFD_ARCH bfd_arch_arc
#endif
  arch = info->arch;
  if (arch == bfd_arch_unknown)
    arch = CGEN_BFD_ARCH;
   
  /* There's no standard way to compute the machine or isa number
     so we leave it to the target.  */
#ifdef CGEN_COMPUTE_MACH
  mach = CGEN_COMPUTE_MACH (info);
#else
  mach = info->mach;
#endif
d1197 13
a1209 33
#ifdef CGEN_COMPUTE_ISA
  {
    static CGEN_BITSET *permanent_isa;

    if (!permanent_isa)
      permanent_isa = cgen_bitset_create (MAX_ISAS);
    isa = permanent_isa;
    cgen_bitset_clear (isa);
    cgen_bitset_add (isa, CGEN_COMPUTE_ISA (info));
  }
#else
  isa = info->insn_sets;
#endif

  /* If we've switched cpu's, try to find a handle we've used before */
  if (cd
      && (cgen_bitset_compare (isa, prev_isa) != 0
	  || mach != prev_mach
	  || endian != prev_endian))
    {
      cd = 0;
      for (cl = cd_list; cl; cl = cl->next)
	{
	  if (cgen_bitset_compare (cl->isa, isa) == 0 &&
	      cl->mach == mach &&
	      cl->endian == endian)
	    {
	      cd = cl->cd;
 	      prev_isa = cd->isas;
	      break;
	    }
	}
    } 
d1211 1
a1211 2
  /* If we haven't initialized yet, initialize the opcode table.  */
  if (! cd)
d1213 1
a1213 2
      const bfd_arch_info_type *arch_type = bfd_lookup_arch (arch, mach);
      const char *mach_name;
d1215 5
a1219 22
      if (!arch_type)
	abort ();
      mach_name = arch_type->printable_name;

      prev_isa = cgen_bitset_copy (isa);
      prev_mach = mach;
      prev_endian = endian;
      cd = arc_cgen_cpu_open (CGEN_CPU_OPEN_ISAS, prev_isa,
				 CGEN_CPU_OPEN_BFDMACH, mach_name,
				 CGEN_CPU_OPEN_ENDIAN, prev_endian,
				 CGEN_CPU_OPEN_END);
      if (!cd)
	abort ();

      /* Save this away for future reference.  */
      cl = xmalloc (sizeof (struct cpu_desc_list));
      cl->cd = cd;
      cl->isa = prev_isa;
      cl->mach = mach;
      cl->endian = endian;
      cl->next = cd_list;
      cd_list = cl;
d1221 2
a1222 2
      arc_cgen_init_dis (cd);
    }
d1224 2
a1225 10
  /* We try to have as much common code as possible.
     But at this point some targets need to take over.  */
  /* ??? Some targets may need a hook elsewhere.  Try to avoid this,
     but if not possible try to move this hook elsewhere rather than
     have two hooks.  */
  length = CGEN_PRINT_INSN (cd, pc, info);
  if (length > 0)
    return length;
  if (length < 0)
    return -1;
d1227 6
a1232 2
  (*info->fprintf_func) (info->stream, UNKNOWN_INSN_MSG);
  return cd->default_insn_bitsize / 8;
@


1.13.22.2
log
@gdb/insight for ARCompact (from Richard Stuckey)
@
text
@d1 7
a7 2
/* Instruction printing code for the ARC.
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2005, 2007
a8 1
   Contributed by Doug Evans (dje@@cygnus.com).
d23 5
a27 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */
d29 2
d32 3
d36 2
a37 5
#include "dis-asm.h"
#include "opcode/arc.h"
#include "elf-bfd.h"
#include "elf/arc.h"
#include <string.h>
d40 2
a41 156
#include <stdarg.h>
#include "arc-dis.h"
#include "arc-ext.h"

#ifndef dbg
#define dbg (0)
#endif

/* Classification of the opcodes for the decoder to print 
   the instructions.  */

typedef enum
{
  CLASS_A4_ARITH,	     
  CLASS_A4_OP3_GENERAL,
  CLASS_A4_FLAG,
  /* All branches other than JC.  */
  CLASS_A4_BRANCH,
  CLASS_A4_JC ,
  /* All loads other than immediate 
     indexed loads.  */
  CLASS_A4_LD0,
  CLASS_A4_LD1,
  CLASS_A4_ST,
  CLASS_A4_SR,
  /* All single operand instructions.  */
  CLASS_A4_OP3_SUBOPC3F,
  CLASS_A4_LR
} a4_decoding_class;

#define BIT(word,n)	((word) & (1 << n))
#define BITS(word,s,e)  (((word) << (31 - e)) >> (s + (31 - e)))
#define OPCODE(word)	(BITS ((word), 27, 31))
#define FIELDA(word)	(BITS ((word), 21, 26))
#define FIELDB(word)	(BITS ((word), 15, 20))
#define FIELDC(word)	(BITS ((word),  9, 14))

/* FIELD D is signed in all of its uses, so we make sure argument is
   treated as signed for bit shifting purposes:  */
#define FIELDD(word)	(BITS (((signed int)word), 0, 8))

#define PUT_NEXT_WORD_IN(a)						\
  do									\
    {									\
      if (is_limm == 1 && !NEXT_WORD (1))				\
        mwerror (state, _("Illegal limm reference in last instruction!\n")); \
      a = state->words[1];						\
    }									\
  while (0)

#define CHECK_FLAG_COND_NULLIFY()				\
  do								\
    {								\
      if (is_shimm == 0)					\
        {							\
          flag = BIT (state->words[0], 8);			\
          state->nullifyMode = BITS (state->words[0], 5, 6);	\
          cond = BITS (state->words[0], 0, 4);			\
        }							\
    }								\
  while (0)

#define CHECK_COND()				\
  do						\
    {						\
      if (is_shimm == 0)			\
        cond = BITS (state->words[0], 0, 4);	\
    }						\
  while (0)

#define CHECK_FIELD(field)			\
  do						\
    {						\
      if (field == 62)				\
        {					\
          is_limm++;				\
	  field##isReg = 0;			\
	  PUT_NEXT_WORD_IN (field);		\
	  limm_value = field;			\
	}					\
      else if (field > 60)			\
        {					\
	  field##isReg = 0;			\
	  is_shimm++;				\
	  flag = (field == 61);			\
	  field = FIELDD (state->words[0]);	\
	}					\
    }						\
  while (0)

#define CHECK_FIELD_A()				\
  do						\
    {						\
      fieldA = FIELDA (state->words[0]);	\
      if (fieldA > 60)				\
        {					\
	  fieldAisReg = 0;			\
	  fieldA = 0;				\
	}					\
    }						\
  while (0)

#define CHECK_FIELD_B()				\
  do						\
    {						\
      fieldB = FIELDB (state->words[0]);	\
      CHECK_FIELD (fieldB);			\
    }						\
  while (0)

#define CHECK_FIELD_C()				\
  do						\
    {						\
      fieldC = FIELDC (state->words[0]);	\
      CHECK_FIELD (fieldC);			\
    }						\
  while (0)

#define IS_SMALL(x)                 (((field##x) < 256) && ((field##x) > -257))
#define IS_REG(x)                    (field##x##isReg)
#define WRITE_FORMAT_LB_Rx_RB(x)     WRITE_FORMAT (x, "[","]","","")
#define WRITE_FORMAT_x_COMMA_LB(x)   WRITE_FORMAT (x, "",",[","",",[")
#define WRITE_FORMAT_COMMA_x_RB(x)   WRITE_FORMAT (x, ",","]",",","]")
#define WRITE_FORMAT_x_RB(x)         WRITE_FORMAT (x, "","]","","]")
#define WRITE_FORMAT_COMMA_x(x)      WRITE_FORMAT (x, ",","",",","")
#define WRITE_FORMAT_x_COMMA(x)      WRITE_FORMAT (x, "",",","",",")
#define WRITE_FORMAT_x(x)            WRITE_FORMAT (x, "","","","")
#define WRITE_FORMAT(x,cb1,ca1,cb,ca) strcat (formatString,		\
				     (IS_REG (x) ? cb1"%r"ca1 :		\
				      usesAuxReg ? cb"%a"ca :		\
				      IS_SMALL (x) ? cb"%d"ca : cb"%h"ca))
#define WRITE_FORMAT_RB()	strcat (formatString, "]")
#define WRITE_COMMENT(str)	(state->comm[state->commNum++] = (str))
#define WRITE_NOP_COMMENT()	if (!fieldAisReg && !flag) WRITE_COMMENT ("nop");

#define NEXT_WORD(x)	(offset += 4, state->words[x])

#define add_target(x)	(state->targets[state->tcnt++] = (x))

static char comment_prefix[] = "\t; ";

static const char *
core_reg_name (struct arcDisState * state, int val)
{
  if (state->coreRegName)
    return (*state->coreRegName)(state->_this, val);
  return 0;
}

static const char *
aux_reg_name (struct arcDisState * state, int val)
{
  if (state->auxRegName)
    return (*state->auxRegName)(state->_this, val);
  return 0;
}
d43 17
a59 7
static const char *
cond_code_name (struct arcDisState * state, int val)
{
  if (state->condCodeName)
    return (*state->condCodeName)(state->_this, val);
  return 0;
}
d61 2
a62 10
static const char *
instruction_name (struct arcDisState * state,
		  int    op1,
		  int    op2,
		  int *  flags)
{
  if (state->instName)
    return (*state->instName)(state->_this, op1, op2, flags);
  return 0;
}
d64 1
d66 1
a66 1
mwerror (struct arcDisState * state, const char * msg)
d68 4
a71 9
  if (state->err != 0)
    (*state->err)(state->_this, (msg));
}

static const char *
post_address (struct arcDisState * state, int addr)
{
  static char id[3 * ARRAY_SIZE (state->addresses)];
  int j, i = state->acnt;
d73 1
a73 1
  if (i < ((int) ARRAY_SIZE (state->addresses)))
d75 1
a75 6
      state->addresses[i] = addr;
      ++state->acnt;
      j = i*3;
      id[j+0] = '@@';
      id[j+1] = '0'+i;
      id[j+2] = 0;
d77 5
a81 1
      return id + j;
a82 1
  return "";
d85 11
a95 2
static void
arc_sprintf (struct arcDisState *state, char *buf, const char *format, ...)
d97 5
a101 17
  char *bp;
  const char *p;
  int size, leading_zero, regMap[2];
  long auxNum;
  va_list ap;

  va_start (ap, format);

  bp = buf;
  *bp = 0;
  p = format;
  auxNum = -1;
  regMap[0] = 0;
  regMap[1] = 0;

  while (1)
    switch (*p++)
d103 2
a104 38
      case 0:
	goto DOCOMM; /* (return)  */
      default:
	*bp++ = p[-1];
	break;
      case '%':
	size = 0;
	leading_zero = 0;
      RETRY: ;
	switch (*p++)
	  {
	  case '0':
	  case '1':
	  case '2':
	  case '3':
	  case '4':
	  case '5':
	  case '6':
	  case '7':
	  case '8':
	  case '9':
	    {
	      /* size.  */
	      size = p[-1] - '0';
	      if (size == 0)
		leading_zero = 1; /* e.g. %08x  */
	      while (*p >= '0' && *p <= '9')
		{
		  size = size * 10 + *p - '0';
		  p++;
		}
	      goto RETRY;
	    }
#define inc_bp() bp = bp + strlen (bp)

	  case 'h':
	    {
	      unsigned u = va_arg (ap, int);
d106 4
a109 109
	      /* Hex.  We can change the format to 0x%08x in
		 one place, here, if we wish.
		 We add underscores for easy reading.  */
	      if (u > 65536)
		sprintf (bp, "0x%x_%04x", u >> 16, u & 0xffff);
	      else
		sprintf (bp, "0x%x", u);
	      inc_bp ();
	    }
	    break;
	  case 'X': case 'x':
	    {
	      int val = va_arg (ap, int);

	      if (size != 0)
		if (leading_zero)
		  sprintf (bp, "%0*x", size, val);
		else
		  sprintf (bp, "%*x", size, val);
	      else
		sprintf (bp, "%x", val);
	      inc_bp ();
	    }
	    break;
	  case 'd':
	    {
	      int val = va_arg (ap, int);

	      if (size != 0)
		sprintf (bp, "%*d", size, val);
	      else
		sprintf (bp, "%d", val);
	      inc_bp ();
	    }
	    break;
	  case 'r':
	    {
	      /* Register.  */
	      int val = va_arg (ap, int);

#define REG2NAME(num, name) case num: sprintf (bp, ""name); \
  regMap[(num < 32) ? 0 : 1] |= 1 << (num - ((num < 32) ? 0 : 32)); break;

	      switch (val)
		{
		  REG2NAME (26, "gp");
		  REG2NAME (27, "fp");
		  REG2NAME (28, "sp");
		  REG2NAME (29, "ilink1");
		  REG2NAME (30, "ilink2");
		  REG2NAME (31, "blink");
		  REG2NAME (60, "lp_count");
		default:
		  {
		    const char * ext;

		    ext = core_reg_name (state, val);
		    if (ext)
		      sprintf (bp, "%s", ext);
		    else
		      sprintf (bp,"r%d",val);
		  }
		  break;
		}
	      inc_bp ();
	    } break;

	  case 'a':
	    {
	      /* Aux Register.  */
	      int val = va_arg (ap, int);

#define AUXREG2NAME(num, name) case num: sprintf (bp,name); break;

	      switch (val)
		{
		  AUXREG2NAME (0x0, "status");
		  AUXREG2NAME (0x1, "semaphore");
		  AUXREG2NAME (0x2, "lp_start");
		  AUXREG2NAME (0x3, "lp_end");
		  AUXREG2NAME (0x4, "identity");
		  AUXREG2NAME (0x5, "debug");
		default:
		  {
		    const char *ext;

		    ext = aux_reg_name (state, val);
		    if (ext)
		      sprintf (bp, "%s", ext);
		    else
		      arc_sprintf (state, bp, "%h", val);
		  }
		  break;
		}
	      inc_bp ();
	    }
	    break;

	  case 's':
	    {
	      sprintf (bp, "%s", va_arg (ap, char *));
	      inc_bp ();
	    }
	    break;

	  default:
	    fprintf (stderr, "?? format %c\n", p[-1]);
	    break;
	  }
d111 14
a124 31

 DOCOMM: *bp = 0;
  va_end (ap);
}

static void
write_comments_(struct arcDisState * state,
		int shimm,
		int is_limm,
		long limm_value)
{
  if (state->commentBuffer != 0)
    {
      int i;

      if (is_limm)
	{
	  const char *name = post_address (state, limm_value + shimm);

	  if (*name != 0)
	    WRITE_COMMENT (name);
	}
      for (i = 0; i < state->commNum; i++)
	{
	  if (i == 0)
	    strcpy (state->commentBuffer, comment_prefix);
	  else
	    strcat (state->commentBuffer, ", ");
	  strncat (state->commentBuffer, state->comm[i],
		   sizeof (state->commentBuffer));
	}
d126 2
d130 1
a130 2
#define write_comments2(x) write_comments_ (state, x, is_limm, limm_value)
#define write_comments()   write_comments2 (0)
d132 2
a133 6
static const char *condName[] =
{
  /* 0..15.  */
  ""   , "z"  , "nz" , "p"  , "n"  , "c"  , "nc" , "v"  ,
  "nv" , "gt" , "ge" , "lt" , "le" , "hi" , "ls" , "pnz"
};
d135 23
a157 9
static void
write_instr_name_(struct arcDisState * state,
		  const char * instrName,
		  int cond,
		  int condCodeIsPartOfName,
		  int flag,
		  int signExtend,
		  int addrWriteBack,
		  int directMem)
d159 1
a159 1
  strcpy (state->instrBuffer, instrName);
d161 1
a161 1
  if (cond > 0)
d163 221
a383 23
      const char *cc = 0;

      if (!condCodeIsPartOfName)
	strcat (state->instrBuffer, ".");

      if (cond < 16)
	cc = condName[cond];
      else
	cc = cond_code_name (state, cond);

      if (!cc)
	cc = "???";

      strcat (state->instrBuffer, cc);
    }

  if (flag)
    strcat (state->instrBuffer, ".f");

  switch (state->nullifyMode)
    {
    case BR_exec_always:
      strcat (state->instrBuffer, ".d");
d385 2
a386 2
    case BR_exec_when_jump:
      strcat (state->instrBuffer, ".jd");
a387 1
    }
d389 6
a394 8
  if (signExtend)
    strcat (state->instrBuffer, ".x");

  if (addrWriteBack)
    strcat (state->instrBuffer, ".a");

  if (directMem)
    strcat (state->instrBuffer, ".di");
d397 1
a397 10
#define write_instr_name()						\
  do									\
    {									\
      write_instr_name_(state, instrName,cond, condCodeIsPartOfName,	\
			flag, signExtend, addrWriteBack, directMem);	\
      formatString[0] = '\0';						\
    }									\
  while (0)

enum
d399 1
a399 4
  op_LD0 = 0, op_LD1 = 1, op_ST  = 2, op_3   = 3,
  op_BC  = 4, op_BLC = 5, op_LPC = 6, op_JC  = 7,
  op_ADD = 8, op_ADC = 9, op_SUB = 10, op_SBC = 11,
  op_AND = 12, op_OR  = 13, op_BIC = 14, op_XOR = 15
a401 1
extern disassemble_info tm_print_insn_info;
d403 2
a404 2
static int
dsmOneArcInst (bfd_vma addr, struct arcDisState * state)
d406 5
a410 50
  int condCodeIsPartOfName = 0;
  a4_decoding_class decodingClass;
  const char * instrName;
  int repeatsOp = 0;
  int fieldAisReg = 1;
  int fieldBisReg = 1;
  int fieldCisReg = 1;
  int fieldA;
  int fieldB;
  int fieldC = 0;
  int flag = 0;
  int cond = 0;
  int is_shimm = 0;
  int is_limm = 0;
  long limm_value = 0;
  int signExtend = 0;
  int addrWriteBack = 0;
  int directMem = 0;
  int is_linked = 0;
  int offset = 0;
  int usesAuxReg = 0;
  int flags;
  int ignoreFirstOpd;
  char formatString[60];

  state->instructionLen = 4;
  state->nullifyMode = BR_exec_when_no_jump;
  state->opWidth = 12;
  state->isBranch = 0;

  state->_mem_load = 0;
  state->_ea_present = 0;
  state->_load_len = 0;
  state->ea_reg1 = no_reg;
  state->ea_reg2 = no_reg;
  state->_offset = 0;

  if (! NEXT_WORD (0))
    return 0;

  state->_opcode = OPCODE (state->words[0]);
  instrName = 0;
  decodingClass = CLASS_A4_ARITH; /* default!  */
  repeatsOp = 0;
  condCodeIsPartOfName=0;
  state->commNum = 0;
  state->tcnt = 0;
  state->acnt = 0;
  state->flow = noflow;
  ignoreFirstOpd = 0;
d412 2
a413 2
  if (state->commentBuffer)
    state->commentBuffer[0] = '\0';
d415 13
a427 24
  switch (state->_opcode)
    {
    case op_LD0:
      switch (BITS (state->words[0],1,2))
	{
	case 0:
	  instrName = "ld";
	  state->_load_len = 4;
	  break;
	case 1:
	  instrName = "ldb";
	  state->_load_len = 1;
	  break;
	case 2:
	  instrName = "ldw";
	  state->_load_len = 2;
	  break;
	default:
	  instrName = "??? (0[3])";
	  state->flow = invalid_instr;
	  break;
	}
      decodingClass = CLASS_A4_LD0;
      break;
d429 8
a436 30
    case op_LD1:
      if (BIT (state->words[0],13))
	{
	  instrName = "lr";
	  decodingClass = CLASS_A4_LR;
	}
      else
	{
	  switch (BITS (state->words[0], 10, 11))
	    {
	    case 0:
	      instrName = "ld";
	      state->_load_len = 4;
	      break;
	    case 1:
	      instrName = "ldb";
	      state->_load_len = 1;
	      break;
	    case 2:
	      instrName = "ldw";
	      state->_load_len = 2;
	      break;
	    default:
	      instrName = "??? (1[3])";
	      state->flow = invalid_instr;
	      break;
	    }
	  decodingClass = CLASS_A4_LD1;
	}
      break;
d438 1
a438 27
    case op_ST:
      if (BIT (state->words[0], 25))
	{
	  instrName = "sr";
	  decodingClass = CLASS_A4_SR;
	}
      else
	{
	  switch (BITS (state->words[0], 22, 23))
	    {
	    case 0:
	      instrName = "st";
	      break;
	    case 1:
	      instrName = "stb";
	      break;
	    case 2:
	      instrName = "stw";
	      break;
	    default:
	      instrName = "??? (2[3])";
	      state->flow = invalid_instr;
	      break;
	    }
	  decodingClass = CLASS_A4_ST;
	}
      break;
d440 9
a448 71
    case op_3:
      decodingClass = CLASS_A4_OP3_GENERAL;  /* default for opcode 3...  */
      switch (FIELDC (state->words[0]))
	{
	case  0:
	  instrName = "flag";
	  decodingClass = CLASS_A4_FLAG;
	  break;
	case  1:
	  instrName = "asr";
	  break;
	case  2:
	  instrName = "lsr";
	  break;
	case  3:
	  instrName = "ror";
	  break;
	case  4:
	  instrName = "rrc";
	  break;
	case  5:
	  instrName = "sexb";
	  break;
	case  6:
	  instrName = "sexw";
	  break;
	case  7:
	  instrName = "extb";
	  break;
	case  8:
	  instrName = "extw";
	  break;
	case  0x3f:
	  {
	    decodingClass = CLASS_A4_OP3_SUBOPC3F;
	    switch (FIELDD (state->words[0]))
	      {
	      case 0:
		instrName = "brk";
		break;
	      case 1:
		instrName = "sleep";
		break;
	      case 2:
		instrName = "swi";
		break;
	      default:
		instrName = "???";
		state->flow=invalid_instr;
		break;
	      }
	  }
	  break;

	  /* ARC Extension Library Instructions
	     NOTE: We assume that extension codes are these instrs.  */
	default:
	  instrName = instruction_name (state,
					state->_opcode,
					FIELDC (state->words[0]),
					&flags);
	  if (!instrName)
	    {
	      instrName = "???";
	      state->flow = invalid_instr;
	    }
	  if (flags & IGNORE_FIRST_OPD)
	    ignoreFirstOpd = 1;
	  break;
	}
      break;
d450 3
a452 26
    case op_BC:
      instrName = "b";
    case op_BLC:
      if (!instrName)
	instrName = "bl";
    case op_LPC:
      if (!instrName)
	instrName = "lp";
    case op_JC:
      if (!instrName)
	{
	  if (BITS (state->words[0],9,9))
	    {
	      instrName = "jl";
	      is_linked = 1;
	    }
	  else
	    {
	      instrName = "j";
	      is_linked = 0;
	    }
	}
      condCodeIsPartOfName = 1;
      decodingClass = ((state->_opcode == op_JC) ? CLASS_A4_JC : CLASS_A4_BRANCH );
      state->isBranch = 1;
      break;
d454 12
a465 4
    case op_ADD:
    case op_ADC:
    case op_AND:
      repeatsOp = (FIELDC (state->words[0]) == FIELDB (state->words[0]));
d467 1
a467 13
      switch (state->_opcode)
	{
	case op_ADD:
	  instrName = (repeatsOp ? "asl" : "add");
	  break;
	case op_ADC:
	  instrName = (repeatsOp ? "rlc" : "adc");
	  break;
	case op_AND:
	  instrName = (repeatsOp ? "mov" : "and");
	  break;
	}
      break;
d469 18
a486 8
    case op_SUB: instrName = "sub";
      break;
    case op_SBC: instrName = "sbc";
      break;
    case op_OR:  instrName = "or";
      break;
    case op_BIC: instrName = "bic";
      break;
d488 2
a489 10
    case op_XOR:
      if (state->words[0] == 0x7fffffff)
	{
	  /* NOP encoded as xor -1, -1, -1.   */
	  instrName = "nop";
	  decodingClass = CLASS_A4_OP3_SUBOPC3F;
	}
      else
	instrName = "xor";
      break;
d491 11
a501 12
    default:
      instrName = instruction_name (state,state->_opcode,0,&flags);
      /* if (instrName) printf("FLAGS=0x%x\n", flags);  */
      if (!instrName)
	{
	  instrName = "???";
	  state->flow=invalid_instr;
	}
      if (flags & IGNORE_FIRST_OPD)
	ignoreFirstOpd = 1;
      break;
    }
d503 1
a503 5
  fieldAisReg = fieldBisReg = fieldCisReg = 1; /* Assume regs for now.  */
  flag = cond = is_shimm = is_limm = 0;
  state->nullifyMode = BR_exec_when_no_jump;	/* 0  */
  signExtend = addrWriteBack = directMem = 0;
  usesAuxReg = 0;
d505 1
a505 1
  switch (decodingClass)
d507 1
a507 9
    case CLASS_A4_ARITH:
      CHECK_FIELD_A ();
      CHECK_FIELD_B ();
      if (!repeatsOp)
	CHECK_FIELD_C ();
      CHECK_FLAG_COND_NULLIFY ();

      write_instr_name ();
      if (!ignoreFirstOpd)
d509 2
a510 7
	  WRITE_FORMAT_x (A);
	  WRITE_FORMAT_COMMA_x (B);
	  if (!repeatsOp)
	    WRITE_FORMAT_COMMA_x (C);
	  WRITE_NOP_COMMENT ();
	  arc_sprintf (state, state->operandBuffer, formatString,
		      fieldA, fieldB, fieldC);
d512 1
a512 1
      else
d514 2
a515 5
	  WRITE_FORMAT_x (B);
	  if (!repeatsOp)
	    WRITE_FORMAT_COMMA_x (C);
	  arc_sprintf (state, state->operandBuffer, formatString,
		      fieldB, fieldC);
a516 2
      write_comments ();
      break;
d518 9
a526 4
    case CLASS_A4_OP3_GENERAL:
      CHECK_FIELD_A ();
      CHECK_FIELD_B ();
      CHECK_FLAG_COND_NULLIFY ();
d528 10
a537 16
      write_instr_name ();
      if (!ignoreFirstOpd)
	{
	  WRITE_FORMAT_x (A);
	  WRITE_FORMAT_COMMA_x (B);
	  WRITE_NOP_COMMENT ();
	  arc_sprintf (state, state->operandBuffer, formatString,
		      fieldA, fieldB);
	}
      else
	{
	  WRITE_FORMAT_x (B);
	  arc_sprintf (state, state->operandBuffer, formatString, fieldB);
	}
      write_comments ();
      break;
d539 5
a543 29
    case CLASS_A4_FLAG:
      CHECK_FIELD_B ();
      CHECK_FLAG_COND_NULLIFY ();
      flag = 0; /* This is the FLAG instruction -- it's redundant.  */

      write_instr_name ();
      WRITE_FORMAT_x (B);
      arc_sprintf (state, state->operandBuffer, formatString, fieldB);
      write_comments ();
      break;

    case CLASS_A4_BRANCH:
      fieldA = BITS (state->words[0],7,26) << 2;
      fieldA = (fieldA << 10) >> 10; /* Make it signed.  */
      fieldA += addr + 4;
      CHECK_FLAG_COND_NULLIFY ();
      flag = 0;

      write_instr_name ();
      /* This address could be a label we know. Convert it.  */
      if (state->_opcode != op_LPC /* LP  */)
	{
	  add_target (fieldA); /* For debugger.  */
	  state->flow = state->_opcode == op_BLC /* BL  */
	    ? direct_call
	    : direct_jump;
	  /* indirect calls are achieved by "lr blink,[status];
	     lr dest<- func addr; j [dest]"  */
	}
d545 3
a547 5
      strcat (formatString, "%s"); /* Address/label name.  */
      arc_sprintf (state, state->operandBuffer, formatString,
		  post_address (state, fieldA));
      write_comments ();
      break;
d549 3
a551 7
    case CLASS_A4_JC:
      /* For op_JC -- jump to address specified.
	 Also covers jump and link--bit 9 of the instr. word
	 selects whether linked, thus "is_linked" is set above.  */
      fieldA = 0;
      CHECK_FIELD_B ();
      CHECK_FLAG_COND_NULLIFY ();
d553 5
a557 21
      if (!fieldBisReg)
	{
	  fieldAisReg = 0;
	  fieldA = (fieldB >> 25) & 0x7F; /* Flags.  */
	  fieldB = (fieldB & 0xFFFFFF) << 2;
	  state->flow = is_linked ? direct_call : direct_jump;
	  add_target (fieldB);
	  /* Screwy JLcc requires .jd mode to execute correctly
	     but we pretend it is .nd (no delay slot).  */
	  if (is_linked && state->nullifyMode == BR_exec_when_jump)
	    state->nullifyMode = BR_exec_when_no_jump;
	}
      else
	{
	  state->flow = is_linked ? indirect_call : indirect_jump;
	  /* We should also treat this as indirect call if NOT linked
	     but the preceding instruction was a "lr blink,[status]"
	     and we have a delay slot with "add blink,blink,2".
	     For now we can't detect such.  */
	  state->register_for_indirect_jump = fieldB;
	}
d559 24
a582 36
      write_instr_name ();
      strcat (formatString,
	      IS_REG (B) ? "[%r]" : "%s"); /* Address/label name.  */
      if (fieldA != 0)
	{
	  fieldAisReg = 0;
	  WRITE_FORMAT_COMMA_x (A);
	}
      if (IS_REG (B))
	arc_sprintf (state, state->operandBuffer, formatString, fieldB, fieldA);
      else
	arc_sprintf (state, state->operandBuffer, formatString,
		    post_address (state, fieldB), fieldA);
      write_comments ();
      break;

    case CLASS_A4_LD0:
      /* LD instruction.
	 B and C can be regs, or one (both?) can be limm.  */
      CHECK_FIELD_A ();
      CHECK_FIELD_B ();
      CHECK_FIELD_C ();
      if (dbg)
	printf ("5:b reg %d %d c reg %d %d  \n",
		fieldBisReg,fieldB,fieldCisReg,fieldC);
      state->_offset = 0;
      state->_ea_present = 1;
      if (fieldBisReg)
	state->ea_reg1 = fieldB;
      else
	state->_offset += fieldB;
      if (fieldCisReg)
	state->ea_reg2 = fieldC;
      else
	state->_offset += fieldC;
      state->_mem_load = 1;
d584 2
a585 10
      directMem     = BIT (state->words[0], 5);
      addrWriteBack = BIT (state->words[0], 3);
      signExtend    = BIT (state->words[0], 0);

      write_instr_name ();
      WRITE_FORMAT_x_COMMA_LB(A);
      if (fieldBisReg || fieldB != 0)
	WRITE_FORMAT_x_COMMA (B);
      else
	fieldB = fieldC;
d587 17
a603 24
      WRITE_FORMAT_x_RB (C);
      arc_sprintf (state, state->operandBuffer, formatString,
		  fieldA, fieldB, fieldC);
      write_comments ();
      break;

    case CLASS_A4_LD1:
      /* LD instruction.  */
      CHECK_FIELD_B ();
      CHECK_FIELD_A ();
      fieldC = FIELDD (state->words[0]);

      if (dbg)
	printf ("6:b reg %d %d c 0x%x  \n",
		fieldBisReg, fieldB, fieldC);
      state->_ea_present = 1;
      state->_offset = fieldC;
      state->_mem_load = 1;
      if (fieldBisReg)
	state->ea_reg1 = fieldB;
      /* Field B is either a shimm (same as fieldC) or limm (different!)
	 Say ea is not present, so only one of us will do the name lookup.  */
      else
	state->_offset += fieldB, state->_ea_present = 0;
d605 33
a637 18
      directMem     = BIT (state->words[0],14);
      addrWriteBack = BIT (state->words[0],12);
      signExtend    = BIT (state->words[0],9);

      write_instr_name ();
      WRITE_FORMAT_x_COMMA_LB (A);
      if (!fieldBisReg)
	{
	  fieldB = state->_offset;
	  WRITE_FORMAT_x_RB (B);
	}
      else
	{
	  WRITE_FORMAT_x (B);
	  if (fieldC != 0 && !BIT (state->words[0],13))
	    {
	      fieldCisReg = 0;
	      WRITE_FORMAT_COMMA_x_RB (C);
d640 2
a641 31
	    WRITE_FORMAT_RB ();
	}
      arc_sprintf (state, state->operandBuffer, formatString,
		  fieldA, fieldB, fieldC);
      write_comments ();
      break;

    case CLASS_A4_ST:
      /* ST instruction.  */
      CHECK_FIELD_B();
      CHECK_FIELD_C();
      fieldA = FIELDD(state->words[0]); /* shimm  */

      /* [B,A offset]  */
      if (dbg) printf("7:b reg %d %x off %x\n",
		      fieldBisReg,fieldB,fieldA);
      state->_ea_present = 1;
      state->_offset = fieldA;
      if (fieldBisReg)
	state->ea_reg1 = fieldB;
      /* Field B is either a shimm (same as fieldA) or limm (different!)
	 Say ea is not present, so only one of us will do the name lookup.
	 (for is_limm we do the name translation here).  */
      else
	state->_offset += fieldB, state->_ea_present = 0;

      directMem     = BIT (state->words[0], 26);
      addrWriteBack = BIT (state->words[0], 24);

      write_instr_name ();
      WRITE_FORMAT_x_COMMA_LB(C);
d643 4
a646 9
      if (!fieldBisReg)
	{
	  fieldB = state->_offset;
	  WRITE_FORMAT_x_RB (B);
	}
      else
	{
	  WRITE_FORMAT_x (B);
	  if (fieldBisReg && fieldA != 0)
d648 3
a650 2
	      fieldAisReg = 0;
	      WRITE_FORMAT_COMMA_x_RB(A);
a651 2
	  else
	    WRITE_FORMAT_RB();
a652 39
      arc_sprintf (state, state->operandBuffer, formatString,
		  fieldC, fieldB, fieldA);
      write_comments2 (fieldA);
      break;

    case CLASS_A4_SR:
      /* SR instruction  */
      CHECK_FIELD_B();
      CHECK_FIELD_C();

      write_instr_name ();
      WRITE_FORMAT_x_COMMA_LB(C);
      /* Try to print B as an aux reg if it is not a core reg.  */
      usesAuxReg = 1;
      WRITE_FORMAT_x (B);
      WRITE_FORMAT_RB ();
      arc_sprintf (state, state->operandBuffer, formatString, fieldC, fieldB);
      write_comments ();
      break;

    case CLASS_A4_OP3_SUBOPC3F:
      write_instr_name ();
      state->operandBuffer[0] = '\0';
      break;

    case CLASS_A4_LR:
      /* LR instruction */
      CHECK_FIELD_A ();
      CHECK_FIELD_B ();

      write_instr_name ();
      WRITE_FORMAT_x_COMMA_LB (A);
      /* Try to print B as an aux reg if it is not a core reg. */
      usesAuxReg = 1;
      WRITE_FORMAT_x (B);
      WRITE_FORMAT_RB ();
      arc_sprintf (state, state->operandBuffer, formatString, fieldA, fieldB);
      write_comments ();
      break;
d654 1
a654 3
    default:
      mwerror (state, "Bad decoding class in ARC disassembler");
      break;
d657 1
a657 2
  state->_cond = cond;
  return state->instructionLen = offset;
d660 3
d664 3
a666 1
/* Returns the name the user specified core extension register.  */
d668 2
a669 2
static const char *
_coreRegName(void * arg ATTRIBUTE_UNUSED, int regval)
d671 3
a673 2
  return arcExtMap_coreRegName (regval);
}
d675 3
a677 1
/* Returns the name the user specified AUX extension register.  */
d679 6
a684 5
static const char *
_auxRegName(void *_this ATTRIBUTE_UNUSED, int regval)
{
  return arcExtMap_auxRegName(regval);
}
d686 5
a690 1
/* Returns the name the user specified condition code name.  */
d692 1
a692 4
static const char *
_condCodeName(void *_this ATTRIBUTE_UNUSED, int regval)
{
  return arcExtMap_condCodeName(regval);
d695 45
a739 1
/* Returns the name the user specified extension instruction.  */
d741 13
a753 5
static const char *
_instName (void *_this ATTRIBUTE_UNUSED, int majop, int minop, int *flags)
{
  return arcExtMap_instName(majop, minop, flags);
}
d755 19
a773 13
/* Decode an instruction returning the size of the instruction
   in bytes or zero if unrecognized.  */

static int
decodeInstr (bfd_vma            address, /* Address of this instruction.  */
	     disassemble_info * info)
{
  int status;
  bfd_byte buffer[4];
  struct arcDisState s;		/* ARC Disassembler state.  */
  void *stream = info->stream; 	/* Output stream.  */
  fprintf_ftype func = info->fprintf_func;
  int bytes;
d775 2
a776 5
  memset (&s, 0, sizeof(struct arcDisState));

  /* read first instruction  */
  status = (*info->read_memory_func) (address, buffer, 4, info);
  if (status != 0)
d778 2
a779 29
      (*info->memory_error_func) (status, address, info);
      return 0;
    }
  if (info->endian == BFD_ENDIAN_LITTLE)
    s.words[0] = bfd_getl32(buffer);
  else
    s.words[0] = bfd_getb32(buffer);
  /* Always read second word in case of limm.  */

  /* We ignore the result since last insn may not have a limm.  */
  status = (*info->read_memory_func) (address + 4, buffer, 4, info);
  if (info->endian == BFD_ENDIAN_LITTLE)
    s.words[1] = bfd_getl32(buffer);
  else
    s.words[1] = bfd_getb32(buffer);

  s._this = &s;
  s.coreRegName = _coreRegName;
  s.auxRegName = _auxRegName;
  s.condCodeName = _condCodeName;
  s.instName = _instName;

  /* Disassemble.  */
  bytes = dsmOneArcInst (address, (void *)& s);

  /* Display the disassembly instruction.  */
  (*func) (stream, "%08lx ", s.words[0]);
  (*func) (stream, "    ");
  (*func) (stream, "%-10s ", s.instrBuffer);
d781 22
a802 3
  if (__TRANSLATION_REQUIRED (s))
    {
      bfd_vma addr = s.addresses[s.operandBuffer[1] - '0'];
d804 1
a804 2
      (*info->print_address_func) ((bfd_vma) addr, info);
      (*func) (stream, "\n");
a805 2
  else
    (*func) (stream, "%s",s.operandBuffer);
d807 10
a816 2
  return s.instructionLen;
}
d818 2
a819 9
/* Return the print_insn function to use.
   Side effect: load (possibly empty) extension section  */

disassembler_ftype
arc_get_disassembler (void *ptr)
{
  if (ptr)
    build_ARC_extmap (ptr);
  return decodeInstr;
@


1.12
log
@Kaveh Ghazi's printf format attribute checking patch.
bfd:
	* elf32-xtensa.c (vsprint_msg): Add format attribute.  Fix
	format bugs.
	* vms.h (_bfd_vms_debug): Add format attribute.
	(_bfd_vms_debug, _bfd_hexdump): Fix typos.

binutils:
	* bucomm.h (report): Add format attribute.
	* dlltool.c (inform): Likewise.
	* dllwrap.c (display, inform, warn): Likewise.
	* objdump.c (objdump_sprintf): Likewise.
	* readelf.c (error, warn): Likewise.  Fix format bugs.

gas:
	* config/tc-tic30.c (debug): Add format attribute.  Fix format
	bugs.

include:
	* dis-asm.h (fprintf_ftype): Add format attribute.

opcodes:
	* arc-dis.c, arm-dis.c, cris-dis.c, crx-dis.c, d10v-dis.c,
	d30v-dis.c, fr30-dis.c, h8300-dis.c, h8500-dis.c, i860-dis.c,
	ia64-dis.c, ip2k-dis.c, m10200-dis.c, m10300-dis.c,
	m88k-dis.c, mcore-dis.c, mips-dis.c, ms1-dis.c, or32-dis.c,
	ppc-dis.c, sh64-dis.c, sparc-dis.c, tic4x-dis.c, tic80-dis.c,
	v850-dis.c: Fix format bugs.
	* ia64-gen.c (fail, warn): Add format attribute.
	* or32-opc.c (debug): Likewise.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2005
d6 3
a8 1
   This program is free software; you can redistribute it and/or modify
d10 2
a11 2
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d13 4
a16 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
@


1.11
log
@Update function declarations to ISO C90 formatting
@
text
@d1205 1
a1205 1
  (*func) (stream, "%08x ", s.words[0]);
@


1.10
log
@Update the address and phone number of the FSF
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002
d18 2
a19 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
a37 1

d41 2
a42 1
typedef enum { 
a59 1

a66 1

d148 9
a156 9
#define IS_SMALL(x) (((field##x) < 256) && ((field##x) > -257))
#define IS_REG(x)   (field##x##isReg)
#define WRITE_FORMAT_LB_Rx_RB(x)     WRITE_FORMAT(x,"[","]","","")
#define WRITE_FORMAT_x_COMMA_LB(x)   WRITE_FORMAT(x,"",",[","",",[")
#define WRITE_FORMAT_COMMA_x_RB(x)   WRITE_FORMAT(x,",","]",",","]")
#define WRITE_FORMAT_x_RB(x)         WRITE_FORMAT(x,"","]","","]")
#define WRITE_FORMAT_COMMA_x(x)      WRITE_FORMAT(x,",","",",","")
#define WRITE_FORMAT_x_COMMA(x)      WRITE_FORMAT(x,"",",","",",")
#define WRITE_FORMAT_x(x)            WRITE_FORMAT(x,"","","","")
a170 15
static const char *core_reg_name PARAMS ((struct arcDisState *, int));
static const char *aux_reg_name PARAMS ((struct arcDisState *, int));
static const char *cond_code_name PARAMS ((struct arcDisState *, int));
static const char *instruction_name
  PARAMS ((struct arcDisState *, int, int, int *));
static void mwerror PARAMS ((struct arcDisState *, const char *));
static const char *post_address PARAMS ((struct arcDisState *, int));
static void write_comments_
  PARAMS ((struct arcDisState *, int, int, long int));
static void write_instr_name_
  PARAMS ((struct arcDisState *, const char *, int, int, int, int, int, int));
static int dsmOneArcInst PARAMS ((bfd_vma, struct arcDisState *));
static const char *_coreRegName PARAMS ((void *, int));
static int decodeInstr PARAMS ((bfd_vma, disassemble_info *));

d172 1
a172 3
core_reg_name (state, val)
     struct arcDisState * state;
     int                  val;
d180 1
a180 3
aux_reg_name (state, val)
     struct arcDisState * state;
     int                  val;
d188 1
a188 3
cond_code_name (state, val)
     struct arcDisState * state;
     int                  val;
d196 4
a199 5
instruction_name (state, op1, op2, flags)
     struct arcDisState * state;
     int    op1;
     int    op2;
     int *  flags;
d207 1
a207 3
mwerror (state, msg)
     struct arcDisState * state;
     const char * msg;
d214 1
a214 3
post_address (state, addr)
     struct arcDisState * state;
     int addr;
a232 3
static void my_sprintf PARAMS ((struct arcDisState *, char *, const char *,
				...));

d234 1
a234 2
my_sprintf VPARAMS ((struct arcDisState *state, char *buf, const char *format,
		     ...))
d240 1
d242 1
a242 4
  VA_OPEN (ap, format);
  VA_FIXEDARG (ap, struct arcDisState *, state);
  VA_FIXEDARG (ap, char *, buf);
  VA_FIXEDARG (ap, const char *, format);
d383 1
a383 1
		      my_sprintf (state, bp, "%h", val);
d405 1
a405 1
  VA_CLOSE (ap);
d409 4
a412 5
write_comments_(state, shimm, is_limm, limm_value)
     struct arcDisState * state;
     int shimm;
     int is_limm;
     long limm_value;
d437 2
a438 2
#define write_comments2(x) write_comments_(state, x, is_limm, limm_value)
#define write_comments() write_comments2(0)
d440 2
a441 1
static const char *condName[] = {
d448 8
a455 9
write_instr_name_(state, instrName, cond, condCodeIsPartOfName, flag, signExtend, addrWriteBack, directMem)
     struct arcDisState * state;
     const char * instrName;
     int cond;
     int condCodeIsPartOfName;
     int flag;
     int signExtend;
     int addrWriteBack;
     int directMem;
d509 2
a510 1
enum {
d520 1
a520 3
dsmOneArcInst (addr, state)
     bfd_vma              addr;
     struct arcDisState * state;
d609 1
a609 1
	  switch (BITS (state->words[0],10,11))
d633 1
a633 1
      if (BIT (state->words[0],25))
d640 1
a640 1
	  switch (BITS (state->words[0],22,23))
d695 1
a695 1
	    switch( FIELDD (state->words[0]) )
d790 1
a790 1
	  /* nop encoded as xor -1, -1, -1  */
d834 1
a834 1
	  my_sprintf (state, state->operandBuffer, formatString,
d842 1
a842 1
	  my_sprintf (state, state->operandBuffer, formatString,
d859 1
a859 1
	  my_sprintf (state, state->operandBuffer, formatString,
d865 1
a865 1
	  my_sprintf (state, state->operandBuffer, formatString, fieldB);
d873 1
a873 1
      flag = 0; /* this is the FLAG instruction -- it's redundant  */
d877 1
a877 1
      my_sprintf (state, state->operandBuffer, formatString, fieldB);
d883 1
a883 1
      fieldA = (fieldA << 10) >> 10; /* make it signed  */
d900 2
a901 2
      strcat (formatString, "%s"); /* address/label name */
      my_sprintf (state, state->operandBuffer, formatString,
d917 1
a917 1
	  fieldA = (fieldB >> 25) & 0x7F; /* flags */
d921 2
a922 2
	  /* screwy JLcc requires .jd mode to execute correctly
	   * but we pretend it is .nd (no delay slot).  */
d930 3
a932 3
	   * but the preceding instruction was a "lr blink,[status]"
	   * and we have a delay slot with "add blink,blink,2".
	   * For now we can't detect such.  */
d938 1
a938 1
	      IS_REG (B) ? "[%r]" : "%s"); /* address/label name  */
d945 1
a945 1
	my_sprintf (state, state->operandBuffer, formatString, fieldB, fieldA);
d947 1
a947 1
	my_sprintf (state, state->operandBuffer, formatString,
d973 3
a975 3
      directMem     = BIT (state->words[0],5);
      addrWriteBack = BIT (state->words[0],3);
      signExtend    = BIT (state->words[0],0);
d985 1
a985 1
      my_sprintf (state, state->operandBuffer, formatString,
d1004 1
a1004 1
      /* field B is either a shimm (same as fieldC) or limm (different!)
d1031 1
a1031 1
      my_sprintf (state, state->operandBuffer, formatString,
d1049 1
a1049 1
      /* field B is either a shimm (same as fieldA) or limm (different!)
d1055 2
a1056 2
      directMem     = BIT(state->words[0],26);
      addrWriteBack = BIT(state->words[0],24);
d1058 1
a1058 1
      write_instr_name();
d1064 1
a1064 1
	  WRITE_FORMAT_x_RB(B);
d1068 1
a1068 1
	  WRITE_FORMAT_x(B);
d1077 1
a1077 1
      my_sprintf (state, state->operandBuffer, formatString,
d1079 1
a1079 1
      write_comments2(fieldA);
d1087 1
a1087 1
      write_instr_name();
d1091 4
a1094 4
      WRITE_FORMAT_x(B);
      WRITE_FORMAT_RB();
      my_sprintf (state, state->operandBuffer, formatString, fieldC, fieldB);
      write_comments();
d1098 1
a1098 1
      write_instr_name();
d1104 2
a1105 2
      CHECK_FIELD_A();
      CHECK_FIELD_B();
d1107 2
a1108 2
      write_instr_name();
      WRITE_FORMAT_x_COMMA_LB(A);
d1111 4
a1114 4
      WRITE_FORMAT_x(B);
      WRITE_FORMAT_RB();
      my_sprintf (state, state->operandBuffer, formatString, fieldA, fieldB);
      write_comments();
a1116 1

d1128 1
d1130 1
a1130 3
_coreRegName(arg, regval)
     void * arg ATTRIBUTE_UNUSED;
     int regval;
d1136 1
d1143 1
a1144 1
/* Returns the name the user specified condition code name.  */
d1152 1
d1161 1
d1163 2
a1164 3
decodeInstr (address, info)
     bfd_vma            address; /* Address of this instruction.  */
     disassemble_info * info;
d1168 2
a1169 2
  struct arcDisState s;	/* ARC Disassembler state  */
  void *stream = info->stream; /* output stream  */
d1186 1
a1186 1
  /* always read second word in case of limm  */
d1188 1
a1188 1
  /* we ignore the result since last insn may not have a limm  */
d1201 2
a1202 2
  /* disassemble  */
  bytes = dsmOneArcInst(address, (void *)&s);
d1204 1
a1204 1
  /* display the disassembly instruction  */
a1206 1

d1209 1
a1209 1
  if (__TRANSLATION_REQUIRED(s))
d1212 1
d1218 1
@


1.9
log
@2005-03-03  Ramana Radhakrishnan  <ramana.radhakrishnan@@codito.com>

	* opcodes/arc-dis.c:Add enum a4_decoding_class.
	  (dsmOneArcInst): Use the enum values for the decoding class
	  Remove redundant case in the switch for decodingClass value 11
@
text
@d18 1
a18 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.8
log
@	* Makefile.am (sh-dis.lo): Don't put make commands in deps.
	* Makefile.in: Regenerate.
	* arc-dis.c: Use #include "" instead of <> for local header files.
	* m68k-dis.c: Likewise.
@
text
@d37 23
d67 1
d558 1
a558 1
  int decodingClass;
d599 1
a599 1
  decodingClass = 0; /* default!  */
d633 1
a633 1
      decodingClass = 5;
d640 1
a640 1
	  decodingClass = 10;
d663 1
a663 1
	  decodingClass = 6;
d671 1
a671 1
	  decodingClass = 8;
d691 1
a691 1
	  decodingClass = 7;
d696 1
a696 1
      decodingClass = 1;  /* default for opcode 3...  */
d701 1
a701 1
	  decodingClass = 2;
d729 1
a729 1
	    decodingClass = 9;
d790 1
a790 1
      decodingClass = ((state->_opcode == op_JC) ? 4 : 3);
a797 1
      decodingClass = 0;
d827 1
a827 1
	  decodingClass = 9;
d854 1
a854 1
    case 0:
d883 1
a883 1
    case 1:
d905 1
a905 1
    case 2:
d916 1
a916 1
    case 3:
d941 1
a941 1
    case 4:
d987 1
a987 1
    case 5:
d1025 1
a1025 1
    case 6:
d1071 1
a1071 1
    case 7:
d1116 2
a1117 1
    case 8:
d1132 1
a1132 1
    case 9:
d1137 1
a1137 1
    case 10:
a1151 5
    case 11:
      CHECK_COND();
      write_instr_name();
      state->operandBuffer[0] = '\0';
      break;
@


1.7
log
@	* arc-dis.c: Formatting fixes.
	(my_sprintf): Define using VPARAMS, VA_OPEN, VA_FIXEDARG, VA_CLOSE.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 2000, 2001
d20 2
a21 2
#include <ansidecl.h>
#include <libiberty.h>
@


1.7.8.1
log
@merge from trunk
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002
d20 2
a21 2
#include "ansidecl.h"
#include "libiberty.h"
@


1.6
log
@	* arc-dis.c: Don't include <ctype.h>.
	* openrisc-desc.c: Likewise.
	* openrisc-ibld.c: Likewise.
@
text
@d48 7
a54 7
#define PUT_NEXT_WORD_IN(a)							\
  do										\
    {										\
      if (is_limm == 1 && !NEXT_WORD (1))					\
        mwerror (state, _("Illegal limm reference in last instruction!\n"));	\
        a = state->words[1];							\
    }										\
d100 1
a100 1
      fieldA = FIELDA(state->words[0]);		\
d236 3
d240 2
a241 5
my_sprintf (
	    struct arcDisState * state,
	    char * buf,
	    const char * format,
	    ...)
a246 1
  va_list ap;
d248 4
a251 1
  va_start (ap, format);
d263 2
a264 2
    case 0:
      goto DOCOMM; /* (return)  */
d414 1
d441 2
a442 1
	  strncat (state->commentBuffer, state->comm[i], sizeof (state->commentBuffer));
d731 1
a731 1
					& flags);
d846 2
a847 1
	  my_sprintf (state, state->operandBuffer, formatString, fieldA, fieldB, fieldC);
d854 2
a855 1
	  my_sprintf (state, state->operandBuffer, formatString, fieldB, fieldC);
d871 2
a872 1
	  my_sprintf (state, state->operandBuffer, formatString, fieldA, fieldB);
d904 6
a909 6
	add_target (fieldA); /* For debugger.  */
	state->flow = state->_opcode == op_BLC /* BL  */
	  ? direct_call
	  : direct_jump;
	/* indirect calls are achieved by "lr blink,[status];
	   lr dest<- func addr; j [dest]"  */
d913 2
a914 1
      my_sprintf (state, state->operandBuffer, formatString, post_address (state, fieldA));
d997 2
a998 1
      my_sprintf (state, state->operandBuffer, formatString, fieldA, fieldB, fieldC);
d1043 2
a1044 1
      my_sprintf (state, state->operandBuffer, formatString, fieldA, fieldB, fieldC);
d1056 1
a1056 1
				 fieldBisReg,fieldB,fieldA);
d1089 2
a1090 1
      my_sprintf (state, state->operandBuffer, formatString, fieldC, fieldB, fieldA);
d1157 1
a1157 1
    return arcExtMap_auxRegName(regval);
d1165 1
a1165 1
    return arcExtMap_condCodeName(regval);
d1172 1
a1172 1
    return arcExtMap_instName(majop, minop, flags);
@


1.5
log
@	* mips-dis.c: Add missing prototypes.
	* a29k-dis.c: Likewise.
	* arc-dis.c: Likewise.
	* ia64-opc.c: Likewise.
@
text
@a28 1
#include <ctype.h>
@


1.4
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d38 6
a43 6
#define BIT(word,n) 	((word) & (1 << n))
#define BITS(word,s,e)  (((word) << (31 - e)) >> (s + (31 - e))) 
#define OPCODE(word) 	(BITS ((word), 27, 31))
#define FIELDA(word) 	(BITS ((word), 21, 26))
#define FIELDB(word) 	(BITS ((word), 15, 20))
#define FIELDC(word) 	(BITS ((word),  9, 14))
d47 1
a47 1
#define FIELDD(word) 	(BITS (((signed int)word), 0, 8))
d139 1
a139 1
#define WRITE_FORMAT_RB() 	strcat (formatString, "]")
d141 1
a141 1
#define WRITE_NOP_COMMENT() 	if (!fieldAisReg && !flag) WRITE_COMMENT ("nop");
d143 1
a143 1
#define NEXT_WORD(x) 	(offset += 4, state->words[x])
d145 1
a145 1
#define add_target(x) 	(state->targets[state->tcnt++] = (x))
d149 15
d167 1
a167 1
     int                  val; 
d177 1
a177 1
     int                  val; 
d187 1
a187 1
     int                  val; 
d199 1
a199 1
     int *  flags; 
d209 1
a209 1
     const char * msg; 
d218 1
a218 1
     int addr; 
d231 1
a231 1
      
d237 1
a237 1
static void 
d244 1
a244 1
  char *bp; 
d249 1
a249 1
  
d251 2
a252 2
  
  bp = buf; 
d258 2
a259 2
  
  while (1) 
d264 2
a265 2
      default: 
	*bp++ = p[-1]; 
d271 1
a271 1
	switch (*p++) 
d297 1
a297 1
	  case 'h': 
d304 1
a304 1
	      if (u > 65536) 
d306 1
a306 1
	      else 
d309 1
a309 1
	    } 
d311 1
a311 1
	  case 'X': case 'x': 
d315 1
a315 1
	      if (size != 0) 
d325 1
a325 1
	  case 'd': 
d328 1
a328 1
	    
d336 1
a336 1
	  case 'r': 
d340 1
a340 1
	    
d343 2
a344 2
	      
	      switch (val) 
d367 2
a368 2
	  
	  case 'a': 
d375 1
a375 1
	      switch (val) 
d398 2
a399 2
	    
	  case 's': 
d405 1
a405 1
	    
d415 1
a415 1
static void 
d422 1
a422 1
  if (state->commentBuffer != 0) 
d426 1
a426 1
      if (is_limm) 
d433 1
a433 1
      for (i = 0; i < state->commNum; i++) 
d438 1
a438 1
	    strcat (state->commentBuffer, ", ");	
d449 1
a449 1
  ""   , "z"  , "nz" , "p"  , "n"  , "c"  , "nc" , "v"  , 
d453 1
a453 1
static void 
d466 1
a466 1
  if (cond > 0) 
d487 1
a487 1
  switch (state->nullifyMode) 
d516 2
a517 2
enum { 
  op_LD0 = 0, op_LD1 = 1, op_ST  = 2, op_3   = 3, 
d519 1
a519 1
  op_ADD = 8, op_ADC = 9, op_SUB = 10, op_SBC = 11, 
d525 1
a525 1
static int 
d554 1
a554 1
  
d559 1
a559 1
  
d566 1
a566 1
  
d569 1
a569 1
  
d584 1
a584 1
  switch (state->_opcode) 
d586 2
a587 2
    case op_LD0: 
      switch (BITS (state->words[0],1,2)) 
d602 1
a602 1
	  instrName = "??? (0[3])"; 
d606 1
a606 1
      decodingClass = 5; 
d608 3
a610 3
    
    case op_LD1: 
      if (BIT (state->words[0],13)) 
d612 1
a612 1
	  instrName = "lr"; 
d615 1
a615 1
      else 
d617 1
a617 1
	  switch (BITS (state->words[0],10,11)) 
d632 1
a632 1
	      instrName = "??? (1[3])"; 
d639 1
a639 1
      
d641 1
a641 1
      if (BIT (state->words[0],25)) 
d646 1
a646 1
      else 
d648 1
a648 1
	  switch (BITS (state->words[0],22,23)) 
d660 1
a660 1
	      instrName = "??? (2[3])"; 
d667 1
a667 1
      
d670 1
a670 1
      switch (FIELDC (state->words[0])) 
d673 1
a673 1
	  instrName = "flag"; 
d700 1
a700 1
	case  0x3f: 
d703 1
a703 1
	    switch( FIELDD (state->words[0]) ) 
d721 1
a721 1
	  
d741 1
a741 1
      instrName = "b";  
d744 1
a744 1
	instrName = "bl"; 
d747 1
a747 1
	instrName = "lp"; 
d751 1
a751 1
	  if (BITS (state->words[0],9,9)) 
d753 1
a753 1
	      instrName = "jl";  
d756 1
a756 1
	  else 
d758 1
a758 1
	      instrName = "j";  
d766 1
a766 1
    
d773 1
a773 1
      switch (state->_opcode) 
d786 1
a786 1
      
d803 1
a803 1
      else 
d806 1
a806 1
      
d819 1
a819 1
  
d825 2
a826 2
  
  switch (decodingClass) 
d834 1
a834 1
      
d836 1
a836 1
      if (!ignoreFirstOpd) 
d845 1
a845 1
      else 
d854 1
a854 1
      
d859 1
a859 1
      
d861 1
a861 1
      if (!ignoreFirstOpd) 
d866 1
a866 1
	  my_sprintf (state, state->operandBuffer, formatString, fieldA, fieldB); 
d868 1
a868 1
      else 
d871 1
a871 1
	  my_sprintf (state, state->operandBuffer, formatString, fieldB); 
d875 1
a875 1
      
d880 1
a880 1
      
d886 1
a886 1
      
d893 1
a893 1
      
d896 1
a896 1
      if (state->_opcode != op_LPC /* LP  */) 
d904 2
a905 2
	}           		
      
d910 1
a910 1
      
d918 2
a919 2
      
      if (!fieldBisReg) 
d931 1
a931 1
      else 
d940 1
a940 1
      
d942 1
a942 1
      strcat (formatString, 
d944 1
a944 1
      if (fieldA != 0) 
d952 1
a952 1
	my_sprintf (state, state->operandBuffer, formatString, 
d956 1
a956 1
      
d977 1
a977 1
      
d981 1
a981 1
      
d988 1
a988 1
      
d993 1
a993 1
      
d999 1
a999 1
      
d1012 1
a1012 1
      
d1016 1
a1016 1
      
d1019 1
a1019 1
      if (!fieldBisReg) 
d1024 1
a1024 1
      else 
d1027 1
a1027 1
	  if (fieldC != 0 && !BIT (state->words[0],13)) 
d1038 1
a1038 1
      
d1044 1
a1044 1
      
d1052 1
a1052 1
      /* field B is either a shimm (same as fieldA) or limm (different!) 
d1055 1
a1055 1
      else 
d1057 1
a1057 1
      
d1060 1
a1060 1
      
d1063 2
a1064 2
	    
      if (!fieldBisReg) 
d1069 1
a1069 1
      else 
d1072 1
a1072 1
	  if (fieldBisReg && fieldA != 0) 
d1087 1
a1087 1
      
d1097 1
a1097 1
      
d1102 1
a1102 1
      
d1107 1
a1107 1
      
d1117 1
a1117 1
      
d1123 1
a1123 1
      
d1128 1
a1128 1
  
d1176 1
a1176 1
  fprintf_ftype func = info->fprintf_func; 
d1178 1
a1178 1
  
d1180 1
a1180 1
  
d1213 1
a1213 1
  
d1215 1
a1215 1
  
@


1.3
log
@Updated ARC assembler from arccores.com
@
text
@d2 2
a3 1
   Copyright (C) 1994, 1995, 1997, 1998, 2000, 2001 Free Software Foundation, Inc. 
@


1.3.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 1997, 1998, 2000, 2001
   Free Software Foundation, Inc.
@


1.2
log
@More portability patches.  Include sysdep.h everywhere.
@
text
@d2 1
a2 1
   Copyright (C) 1994, 1995, 1997, 1998 Free Software Foundation, Inc. 
d5 13
a17 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d19 2
a20 1
#include "sysdep.h"
d25 1
d28 161
a188 2
static int print_insn_arc_base_little PARAMS ((bfd_vma, disassemble_info *));
static int print_insn_arc_base_big PARAMS ((bfd_vma, disassemble_info *));
d190 16
a205 1
static int print_insn PARAMS ((bfd_vma, disassemble_info *, int, int));
d207 13
a219 2
/* Print one instruction from PC on INFO->STREAM.
   Return the size of the instruction (4 or 8 for the ARC). */
d221 226
a446 6
static int
print_insn (pc, info, mach, big_p)
     bfd_vma pc;
     disassemble_info *info;
     int mach;
     int big_p;
d448 1
a448 10
  const struct arc_opcode *opcode;
  bfd_byte buffer[4];
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;
  int status;
  /* First element is insn, second element is limm (if present).  */
  arc_insn insn[2];
  int got_limm_p = 0;
  static int initialized = 0;
  static int current_mach = 0;
d450 1
a450 1
  if (!initialized || mach != current_mach)
d452 14
a465 3
      initialized = 1;
      current_mach = arc_get_opcode_mach (mach, big_p);
      arc_opcode_init_tables (current_mach);
d468 4
a471 2
  status = (*info->read_memory_func) (pc, buffer, 4, info);
  if (status != 0)
d473 6
a478 2
      (*info->memory_error_func) (status, pc, info);
      return -1;
a479 4
  if (big_p)
    insn[0] = bfd_getb32 (buffer);
  else
    insn[0] = bfd_getl32 (buffer);
d481 83
a563 1
  (*func) (stream, "%08lx\t", insn[0]);
d565 2
a566 2
  /* The instructions are stored in lists hashed by the insn code
     (though we needn't care how they're hashed).  */
d568 1
a568 2
  opcode = arc_opcode_lookup_dis (insn[0]);
  for ( ; opcode != NULL; opcode = ARC_OPCODE_NEXT_DIS (opcode))
d570 30
a599 56
      char *syn;
      int mods,invalid;
      long value;
      const struct arc_operand *operand;
      const struct arc_operand_value *opval;

      /* Basic bit mask must be correct.  */
      if ((insn[0] & opcode->mask) != opcode->value)
	continue;

      /* Supported by this cpu?  */
      if (! arc_opcode_supported (opcode))
	continue;

      /* Make two passes over the operands.  First see if any of them
	 have extraction functions, and, if they do, make sure the
	 instruction is valid.  */

      arc_opcode_init_extract ();
      invalid = 0;

      /* ??? Granted, this is slower than the `ppc' way.  Maybe when this is
	 done it'll be clear what the right way to do this is.  */
      /* Instructions like "add.f r0,r1,1" are tricky because the ".f" gets
	 printed first, but we don't know how to print it until we've processed
	 the regs.  Since we're scanning all the args before printing the insn
	 anyways, it's actually quite easy.  */

      for (syn = opcode->syntax; *syn; ++syn)
	{
	  int c;

	  if (*syn != '%' || *++syn == '%')
	    continue;
	  mods = 0;
	  c = *syn;
	  while (ARC_MOD_P (arc_operands[arc_operand_map[c]].flags))
	    {
	      mods |= arc_operands[arc_operand_map[c]].flags & ARC_MOD_BITS;
	      ++syn;
	      c = *syn;
	    }
	  operand = arc_operands + arc_operand_map[c];
	  if (operand->extract)
	    (*operand->extract) (insn, operand, mods,
				 (const struct arc_operand_value **) NULL,
				 &invalid);
	}
      if (invalid)
	continue;

      /* The instruction is valid.  */

      /* If we have an insn with a limm, fetch it now.  Scanning the insns
	 twice lets us do this.  */
      if (arc_opcode_limm_p (NULL))
d601 1
a601 2
	  status = (*info->read_memory_func) (pc + 4, buffer, 4, info);
	  if (status != 0)
d603 16
a618 2
	      (*info->memory_error_func) (status, pc, info);
	      return -1;
d620 101
a720 5
	  if (big_p)
	    insn[1] = bfd_getb32 (buffer);
	  else
	    insn[1] = bfd_getl32 (buffer);
	  got_limm_p = 1;
d722 1
d724 10
a733 1
      for (syn = opcode->syntax; *syn; ++syn)
d735 1
a735 3
	  int c;

	  if (*syn != '%' || *++syn == '%')
d737 2
a738 2
	      (*func) (stream, "%c", *syn);
	      continue;
d740 1
a740 5

	  /* We have an operand.  Fetch any special modifiers.  */
	  mods = 0;
	  c = *syn;
	  while (ARC_MOD_P (arc_operands[arc_operand_map[c]].flags))
d742 2
a743 3
	      mods |= arc_operands[arc_operand_map[c]].flags & ARC_MOD_BITS;
	      ++syn;
	      c = *syn;
d745 11
a755 1
	  operand = arc_operands + arc_operand_map[c];
d757 255
a1011 3
	  /* Extract the value from the instruction.  */
	  opval = NULL;
	  if (operand->extract)
d1013 2
a1014 2
	      value = (*operand->extract) (insn, operand, mods,
					   &opval, (int *) NULL);
d1017 40
d1058 2
a1059 35
	      value = (insn[0] >> operand->shift) & ((1 << operand->bits) - 1);
	      if ((operand->flags & ARC_OPERAND_SIGNED)
		  && (value & (1 << (operand->bits - 1))))
		value -= 1 << operand->bits;

	      /* If this is a suffix operand, set `opval'.  */
	      if (operand->flags & ARC_OPERAND_SUFFIX)
		opval = arc_opcode_lookup_suffix (operand, value);
	    }

	  /* Print the operand as directed by the flags.  */
	  if (operand->flags & ARC_OPERAND_FAKE)
	    ; /* nothing to do (??? at least not yet) */
	  else if (operand->flags & ARC_OPERAND_SUFFIX)
	    {
	      /* Default suffixes aren't printed.  Fortunately, they all have
		 zero values.  Also, zero values for boolean suffixes are
		 represented by the absence of text.  */

	      if (value != 0)
		{
		  /* ??? OPVAL should have a value.  If it doesn't just cope
		     as we want disassembly to be reasonably robust.
		     Also remember that several condition code values (16-31)
		     aren't defined yet.  For these cases just print the
		     number suitably decorated.  */
		  if (opval)
		    (*func) (stream, "%s%s",
			     mods & ARC_MOD_DOT ? "." : "",
			     opval->name);
		  else
		    (*func) (stream, "%s%c%d",
			     mods & ARC_MOD_DOT ? "." : "",
			     operand->fmt, value);
		}
a1060 10
	  else if (operand->flags & ARC_OPERAND_RELATIVE_BRANCH)
	    (*info->print_address_func) (pc + 4 + value, info);
	  /* ??? Not all cases of this are currently caught.  */
	  else if (operand->flags & ARC_OPERAND_ABSOLUTE_BRANCH)
	    (*info->print_address_func) ((bfd_vma) value & 0xffffffff, info);
	  else if (operand->flags & ARC_OPERAND_ADDRESS)
	    (*info->print_address_func) ((bfd_vma) value & 0xffffffff, info);
	  else if (opval)
	    /* Note that this case catches both normal and auxiliary regs.  */
	    (*func) (stream, "%s", opval->name);
d1062 1
a1062 1
	    (*func) (stream, "%ld", value);
d1064 53
d1118 8
a1125 3
      /* We have found and printed an instruction; return.  */
      return got_limm_p ? 8 : 4;
    }
d1127 5
a1131 2
  (*func) (stream, _("*unknown*"));
  return 4;
a1133 4
/* Given MACH, one of bfd_mach_arc_xxx, return the print_insn function to use.
   This does things a non-standard way (the "standard" way would be to copy
   this code into disassemble.c).  Since there are more than a couple of
   variants, hiding all this crud here seems cleaner.  */
d1135 10
a1144 4
disassembler_ftype
arc_get_disassembler (mach, big_p)
     int mach;
     int big_p;
d1146 1
a1146 6
  switch (mach)
    {
    case bfd_mach_arc_base:
      return big_p ? print_insn_arc_base_big : print_insn_arc_base_little;
    }
  return print_insn_arc_base_little;
d1149 2
d1152 3
a1154 3
print_insn_arc_base_little (pc, info)
     bfd_vma pc;
     disassemble_info *info;
d1156 53
a1208 1
  return print_insn (pc, info, bfd_mach_arc_base, 0);
d1211 5
a1215 4
static int
print_insn_arc_base_big (pc, info)
     bfd_vma pc;
     disassemble_info *info;
d1217 3
a1219 1
  return print_insn (pc, info, bfd_mach_arc_base, 1);
@


1.1
log
@Initial revision
@
text
@d19 1
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@


1.1.1.1.2.1
log
@2000-04-13  Michael Sokolov  <msokolov@@ivan.Harhan.ORG>

	* a29k-dis.c, alpha-dis.c, alpha-opc.c, arc-dis.c, arc-opc.c,
	avr-dis.c, d10v-dis.c, d10v-opc.c, d30v-dis.c, d30v-opc.c,
	disassemble.c, h8300-dis.c, h8500-dis.c, hppa-dis.c, i370-dis.c,
	i370-opc.c, i960-dis.c, m10200-dis.c, m10200-opc.c, m10300-dis.c,
	m10300-opc.c, m68k-dis.c, m68k-opc.c, m88k-dis.c, mcore-dis.c,
	mips-dis.c, mips-opc.c, mips16-opc.c, pj-dis.c, pj-opc.c, ppc-dis.c,
	ppc-opc.c, sh-dis.c, sparc-dis.c, sparc-opc.c, tic80-dis.c,
	tic80-opc.c, v850-dis.c, v850-opc.c, vax-dis.c, w65-dis.c, z8k-dis.c,
	z8kgen.c: Everyone includes sysdep.h. Remove ansidecl.h as sysdep.h
	includes it.
@
text
@a18 1
#include "sysdep.h"
@


