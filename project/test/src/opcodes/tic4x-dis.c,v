head	1.10;
access;
symbols
	sid-snapshot-20180601:1.10
	sid-snapshot-20180501:1.10
	sid-snapshot-20180401:1.10
	sid-snapshot-20180301:1.10
	sid-snapshot-20180201:1.10
	sid-snapshot-20180101:1.10
	sid-snapshot-20171201:1.10
	sid-snapshot-20171101:1.10
	sid-snapshot-20171001:1.10
	sid-snapshot-20170901:1.10
	sid-snapshot-20170801:1.10
	sid-snapshot-20170701:1.10
	sid-snapshot-20170601:1.10
	sid-snapshot-20170501:1.10
	sid-snapshot-20170401:1.10
	sid-snapshot-20170301:1.10
	sid-snapshot-20170201:1.10
	sid-snapshot-20170101:1.10
	sid-snapshot-20161201:1.10
	sid-snapshot-20161101:1.10
	sid-snapshot-20160901:1.10
	sid-snapshot-20160801:1.10
	sid-snapshot-20160701:1.10
	sid-snapshot-20160601:1.10
	sid-snapshot-20160501:1.10
	sid-snapshot-20160401:1.10
	sid-snapshot-20160301:1.10
	sid-snapshot-20160201:1.10
	sid-snapshot-20160101:1.10
	sid-snapshot-20151201:1.10
	sid-snapshot-20151101:1.10
	sid-snapshot-20151001:1.10
	sid-snapshot-20150901:1.10
	sid-snapshot-20150801:1.10
	sid-snapshot-20150701:1.10
	sid-snapshot-20150601:1.10
	sid-snapshot-20150501:1.10
	sid-snapshot-20150401:1.10
	sid-snapshot-20150301:1.10
	sid-snapshot-20150201:1.10
	sid-snapshot-20150101:1.10
	sid-snapshot-20141201:1.10
	sid-snapshot-20141101:1.10
	sid-snapshot-20141001:1.10
	sid-snapshot-20140901:1.10
	sid-snapshot-20140801:1.10
	sid-snapshot-20140701:1.10
	sid-snapshot-20140601:1.10
	sid-snapshot-20140501:1.10
	sid-snapshot-20140401:1.10
	sid-snapshot-20140301:1.10
	sid-snapshot-20140201:1.10
	sid-snapshot-20140101:1.10
	sid-snapshot-20131201:1.10
	sid-snapshot-20131101:1.10
	sid-snapshot-20131001:1.10
	binutils-2_24-branch:1.10.0.8
	binutils-2_24-branchpoint:1.10
	binutils-2_21_1:1.9
	sid-snapshot-20130901:1.10
	gdb_7_6_1-2013-08-30-release:1.10
	sid-snapshot-20130801:1.10
	sid-snapshot-20130701:1.10
	sid-snapshot-20130601:1.10
	sid-snapshot-20130501:1.10
	gdb_7_6-2013-04-26-release:1.10
	sid-snapshot-20130401:1.10
	binutils-2_23_2:1.10
	gdb_7_6-branch:1.10.0.6
	gdb_7_6-2013-03-12-branchpoint:1.10
	sid-snapshot-20130301:1.10
	sid-snapshot-20130201:1.10
	sid-snapshot-20130101:1.10
	sid-snapshot-20121201:1.10
	gdb_7_5_1-2012-11-29-release:1.10
	binutils-2_23_1:1.10
	sid-snapshot-20121101:1.10
	binutils-2_23:1.10
	sid-snapshot-20121001:1.10
	sid-snapshot-20120901:1.10
	gdb_7_5-2012-08-17-release:1.10
	sid-snapshot-20120801:1.10
	binutils-2_23-branch:1.10.0.4
	binutils-2_23-branchpoint:1.10
	gdb_7_5-branch:1.10.0.2
	gdb_7_5-2012-07-18-branchpoint:1.10
	sid-snapshot-20120701:1.10
	sid-snapshot-20120601:1.10
	sid-snapshot-20120501:1.9
	binutils-2_22_branch:1.9.0.48
	gdb_7_4_1-2012-04-26-release:1.9
	sid-snapshot-20120401:1.9
	sid-snapshot-20120301:1.9
	sid-snapshot-20120201:1.9
	gdb_7_4-2012-01-24-release:1.9
	sid-snapshot-20120101:1.9
	gdb_7_4-branch:1.9.0.46
	gdb_7_4-2011-12-13-branchpoint:1.9
	sid-snapshot-20111201:1.9
	binutils-2_22:1.9
	sid-snapshot-20111101:1.9
	sid-snapshot-20111001:1.9
	binutils-2_22-branch:1.9.0.44
	binutils-2_22-branchpoint:1.9
	gdb_7_3_1-2011-09-04-release:1.9
	sid-snapshot-20110901:1.9
	sid-snapshot-20110801:1.9
	gdb_7_3-2011-07-26-release:1.9
	sid-snapshot-20110701:1.9
	sid-snapshot-20110601:1.9
	sid-snapshot-20110501:1.9
	gdb_7_3-branch:1.9.0.42
	gdb_7_3-2011-04-01-branchpoint:1.9
	sid-snapshot-20110401:1.9
	sid-snapshot-20110301:1.9
	sid-snapshot-20110201:1.9
	sid-snapshot-20110101:1.9
	binutils-2_21:1.9
	sid-snapshot-20101201:1.9
	binutils-2_21-branch:1.9.0.40
	binutils-2_21-branchpoint:1.9
	sid-snapshot-20101101:1.9
	sid-snapshot-20101001:1.9
	binutils-2_20_1:1.9
	gdb_7_2-2010-09-02-release:1.9
	sid-snapshot-20100901:1.9
	sid-snapshot-20100801:1.9
	gdb_7_2-branch:1.9.0.38
	gdb_7_2-2010-07-07-branchpoint:1.9
	sid-snapshot-20100701:1.9
	sid-snapshot-20100601:1.9
	sid-snapshot-20100501:1.9
	sid-snapshot-20100401:1.9
	gdb_7_1-2010-03-18-release:1.9
	sid-snapshot-20100301:1.9
	gdb_7_1-branch:1.9.0.36
	gdb_7_1-2010-02-18-branchpoint:1.9
	sid-snapshot-20100201:1.9
	sid-snapshot-20100101:1.9
	gdb_7_0_1-2009-12-22-release:1.9
	sid-snapshot-20091201:1.9
	sid-snapshot-20091101:1.9
	binutils-2_20:1.9
	gdb_7_0-2009-10-06-release:1.9
	sid-snapshot-20091001:1.9
	gdb_7_0-branch:1.9.0.34
	gdb_7_0-2009-09-16-branchpoint:1.9
	arc-sim-20090309:1.9
	binutils-arc-20081103-branch:1.9.0.32
	binutils-arc-20081103-branchpoint:1.9
	binutils-2_20-branch:1.9.0.30
	binutils-2_20-branchpoint:1.9
	sid-snapshot-20090901:1.9
	sid-snapshot-20090801:1.9
	msnyder-checkpoint-072509-branch:1.9.0.28
	msnyder-checkpoint-072509-branchpoint:1.9
	sid-snapshot-20090701:1.9
	dje-cgen-play1-branch:1.9.0.26
	dje-cgen-play1-branchpoint:1.9
	sid-snapshot-20090601:1.9
	sid-snapshot-20090501:1.9
	sid-snapshot-20090401:1.9
	arc-20081103-branch:1.9.0.24
	arc-20081103-branchpoint:1.9
	arc-insight_6_8-branch:1.9.0.22
	arc-insight_6_8-branchpoint:1.9
	insight_6_8-branch:1.9.0.20
	insight_6_8-branchpoint:1.9
	sid-snapshot-20090301:1.9
	binutils-2_19_1:1.9
	sid-snapshot-20090201:1.9
	sid-snapshot-20090101:1.9
	reverse-20081226-branch:1.9.0.18
	reverse-20081226-branchpoint:1.9
	sid-snapshot-20081201:1.9
	multiprocess-20081120-branch:1.9.0.16
	multiprocess-20081120-branchpoint:1.9
	sid-snapshot-20081101:1.9
	binutils-2_19:1.9
	sid-snapshot-20081001:1.9
	reverse-20080930-branch:1.9.0.14
	reverse-20080930-branchpoint:1.9
	binutils-2_19-branch:1.9.0.12
	binutils-2_19-branchpoint:1.9
	sid-snapshot-20080901:1.9
	sid-snapshot-20080801:1.9
	reverse-20080717-branch:1.9.0.10
	reverse-20080717-branchpoint:1.9
	sid-snapshot-20080701:1.9
	msnyder-reverse-20080609-branch:1.9.0.8
	msnyder-reverse-20080609-branchpoint:1.9
	drow-reverse-20070409-branch:1.8.0.32
	drow-reverse-20070409-branchpoint:1.8
	sid-snapshot-20080601:1.9
	sid-snapshot-20080501:1.9
	sid-snapshot-20080403:1.9
	sid-snapshot-20080401:1.9
	gdb_6_8-2008-03-27-release:1.9
	sid-snapshot-20080301:1.9
	gdb_6_8-branch:1.9.0.6
	gdb_6_8-2008-02-26-branchpoint:1.9
	sid-snapshot-20080201:1.9
	sid-snapshot-20080101:1.9
	sid-snapshot-20071201:1.9
	sid-snapshot-20071101:1.9
	gdb_6_7_1-2007-10-29-release:1.9
	gdb_6_7-2007-10-10-release:1.9
	sid-snapshot-20071001:1.9
	gdb_6_7-branch:1.9.0.4
	gdb_6_7-2007-09-07-branchpoint:1.9
	binutils-2_18:1.9
	binutils-2_18-branch:1.9.0.2
	binutils-2_18-branchpoint:1.9
	insight_6_6-20070208-release:1.8
	binutils-csl-coldfire-4_1-32:1.8
	binutils-csl-sourcerygxx-4_1-32:1.8
	gdb_6_6-2006-12-18-release:1.8
	binutils-csl-innovasic-fido-3_4_4-33:1.8
	binutils-csl-sourcerygxx-3_4_4-32:1.5
	binutils-csl-coldfire-4_1-30:1.8
	binutils-csl-sourcerygxx-4_1-30:1.8
	binutils-csl-coldfire-4_1-28:1.8
	binutils-csl-sourcerygxx-4_1-29:1.8
	binutils-csl-sourcerygxx-4_1-28:1.8
	gdb_6_6-branch:1.8.0.30
	gdb_6_6-2006-11-15-branchpoint:1.8
	binutils-csl-arm-2006q3-27:1.8
	binutils-csl-sourcerygxx-4_1-27:1.8
	binutils-csl-arm-2006q3-26:1.8
	binutils-csl-sourcerygxx-4_1-26:1.8
	binutils-csl-sourcerygxx-4_1-25:1.8
	binutils-csl-sourcerygxx-4_1-24:1.8
	binutils-csl-sourcerygxx-4_1-23:1.8
	insight_6_5-20061003-release:1.8
	gdb-csl-symbian-6_4_50_20060226-12:1.8
	binutils-csl-sourcerygxx-4_1-21:1.8
	binutils-csl-arm-2006q3-21:1.8
	binutils-csl-sourcerygxx-4_1-22:1.8
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.8
	binutils-csl-sourcerygxx-4_1-20:1.8
	binutils-csl-arm-2006q3-19:1.8
	binutils-csl-sourcerygxx-4_1-19:1.8
	binutils-csl-sourcerygxx-4_1-18:1.8
	binutils-csl-renesas-4_1-9:1.8
	gdb-csl-sourcerygxx-3_4_4-25:1.8
	binutils-csl-sourcerygxx-3_4_4-25:1.5
	nickrob-async-20060828-mergepoint:1.8
	gdb-csl-symbian-6_4_50_20060226-11:1.8
	binutils-csl-renesas-4_1-8:1.8
	binutils-csl-renesas-4_1-7:1.8
	binutils-csl-renesas-4_1-6:1.8
	gdb-csl-sourcerygxx-4_1-17:1.8
	binutils-csl-sourcerygxx-4_1-17:1.8
	gdb-csl-20060226-branch-local-2:1.8
	gdb-csl-sourcerygxx-4_1-14:1.8
	binutils-csl-sourcerygxx-4_1-14:1.8
	binutils-csl-sourcerygxx-4_1-15:1.8
	gdb-csl-sourcerygxx-4_1-13:1.8
	binutils-csl-sourcerygxx-4_1-13:1.8
	binutils-2_17:1.8
	gdb-csl-sourcerygxx-4_1-12:1.8
	binutils-csl-sourcerygxx-4_1-12:1.8
	gdb-csl-sourcerygxx-3_4_4-21:1.8
	binutils-csl-sourcerygxx-3_4_4-21:1.8
	gdb_6_5-20060621-release:1.8
	binutils-csl-wrs-linux-3_4_4-24:1.5
	binutils-csl-wrs-linux-3_4_4-23:1.5
	gdb-csl-sourcerygxx-4_1-9:1.8
	binutils-csl-sourcerygxx-4_1-9:1.8
	gdb-csl-sourcerygxx-4_1-8:1.8
	binutils-csl-sourcerygxx-4_1-8:1.8
	gdb-csl-sourcerygxx-4_1-7:1.8
	binutils-csl-sourcerygxx-4_1-7:1.8
	gdb-csl-arm-2006q1-6:1.8
	binutils-csl-arm-2006q1-6:1.8
	gdb-csl-sourcerygxx-4_1-6:1.8
	binutils-csl-sourcerygxx-4_1-6:1.8
	binutils-csl-wrs-linux-3_4_4-22:1.5
	gdb-csl-symbian-6_4_50_20060226-10:1.8
	gdb-csl-symbian-6_4_50_20060226-9:1.8
	gdb-csl-symbian-6_4_50_20060226-8:1.8
	gdb-csl-coldfire-4_1-11:1.8
	binutils-csl-coldfire-4_1-11:1.8
	gdb-csl-sourcerygxx-3_4_4-19:1.8
	binutils-csl-sourcerygxx-3_4_4-19:1.8
	gdb-csl-coldfire-4_1-10:1.8
	gdb_6_5-branch:1.8.0.28
	gdb_6_5-2006-05-14-branchpoint:1.8
	binutils-csl-coldfire-4_1-10:1.8
	gdb-csl-sourcerygxx-4_1-5:1.8
	binutils-csl-sourcerygxx-4_1-5:1.8
	nickrob-async-20060513-branch:1.8.0.26
	nickrob-async-20060513-branchpoint:1.8
	gdb-csl-sourcerygxx-4_1-4:1.8
	binutils-csl-sourcerygxx-4_1-4:1.8
	msnyder-reverse-20060502-branch:1.8.0.24
	msnyder-reverse-20060502-branchpoint:1.8
	binutils-csl-wrs-linux-3_4_4-21:1.5
	gdb-csl-morpho-4_1-4:1.8
	binutils-csl-morpho-4_1-4:1.8
	gdb-csl-sourcerygxx-3_4_4-17:1.8
	binutils-csl-sourcerygxx-3_4_4-17:1.8
	binutils-csl-wrs-linux-3_4_4-20:1.5
	readline_5_1-import-branch:1.8.0.22
	readline_5_1-import-branchpoint:1.8
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.8
	binutils-2_17-branch:1.8.0.20
	binutils-2_17-branchpoint:1.8
	gdb-csl-symbian-20060226-branch:1.8.0.18
	gdb-csl-symbian-20060226-branchpoint:1.8
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.8
	msnyder-reverse-20060331-branch:1.8.0.16
	msnyder-reverse-20060331-branchpoint:1.8
	binutils-csl-2_17-branch:1.8.0.14
	binutils-csl-2_17-branchpoint:1.8
	gdb-csl-available-20060303-branch:1.8.0.12
	gdb-csl-available-20060303-branchpoint:1.8
	gdb-csl-20060226-branch:1.8.0.10
	gdb-csl-20060226-branchpoint:1.8
	gdb_6_4-20051202-release:1.8
	msnyder-fork-checkpoint-branch:1.8.0.8
	msnyder-fork-checkpoint-branchpoint:1.8
	gdb-csl-gxxpro-6_3-branch:1.8.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.8
	gdb_6_4-branch:1.8.0.4
	gdb_6_4-2005-11-01-branchpoint:1.8
	gdb-csl-arm-20051020-branch:1.8.0.2
	gdb-csl-arm-20051020-branchpoint:1.8
	binutils-csl-gxxpro-3_4-branch:1.5.0.54
	binutils-csl-gxxpro-3_4-branchpoint:1.5
	binutils-2_16_1:1.5
	msnyder-tracepoint-checkpoint-branch:1.6.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.6
	gdb-csl-arm-20050325-2005-q1b:1.5
	binutils-csl-arm-2005q1b:1.5
	binutils-2_16:1.5
	gdb-csl-arm-20050325-2005-q1a:1.5
	binutils-csl-arm-2005q1a:1.5
	csl-arm-20050325-branch:1.5.0.52
	csl-arm-20050325-branchpoint:1.5
	binutils-csl-arm-2005q1-branch:1.5.0.50
	binutils-csl-arm-2005q1-branchpoint:1.5
	binutils-2_16-branch:1.5.0.48
	binutils-2_16-branchpoint:1.5
	csl-arm-2004-q3d:1.5
	gdb_6_3-20041109-release:1.5
	gdb_6_3-branch:1.5.0.44
	gdb_6_3-20041019-branchpoint:1.5
	csl-arm-2004-q3:1.5
	drow_intercu-merge-20040921:1.5
	drow_intercu-merge-20040915:1.5
	jimb-gdb_6_2-e500-branch:1.5.0.46
	jimb-gdb_6_2-e500-branchpoint:1.5
	gdb_6_2-20040730-release:1.5
	gdb_6_2-branch:1.5.0.42
	gdb_6_2-2004-07-10-gmt-branchpoint:1.5
	gdb_6_1_1-20040616-release:1.5
	binutils-2_15:1.5
	binutils-2_15-branchpoint:1.5
	csl-arm-2004-q1a:1.5
	csl-arm-2004-q1:1.5
	gdb_6_1-2004-04-05-release:1.5
	drow_intercu-merge-20040402:1.5
	drow_intercu-merge-20040327:1.5
	ezannoni_pie-20040323-branch:1.5.0.40
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.38
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.36
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow_intercu-20040221-branch:1.5.0.34
	drow_intercu-20040221-branchpoint:1.5
	binutils-2_15-branch:1.5.0.32
	cagney_bfdfile-20040213-branch:1.5.0.30
	cagney_bfdfile-20040213-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	cagney_bigcore-20040122-branch:1.5.0.28
	cagney_bigcore-20040122-branchpoint:1.5
	drow-cplus-merge-20040113:1.5
	csl-arm-2003-q4:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	kettenis_sparc-20030918-branch:1.5.0.26
	kettenis_sparc-20030918-branchpoint:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	jimb-ppc64-linux-20030613-branch:1.5.0.18
	jimb-ppc64-linux-20030613-branchpoint:1.5
	binutils-2_14:1.5
	cagney_convert-20030606-branch:1.5.0.16
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.14
	cagney_writestrings-20030508-branchpoint:1.5
	jimb-ppc64-linux-20030528-branch:1.5.0.12
	jimb-ppc64-linux-20030528-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.10
	cagney_fileio-20030521-branchpoint:1.5
	kettenis_i386newframe-20030517-mergepoint:1.5
	jimb-ppc64-linux-20030509-branch:1.5.0.8
	jimb-ppc64-linux-20030509-branchpoint:1.5
	kettenis_i386newframe-20030504-mergepoint:1.5
	carlton_dictionary-20030430-merge:1.5
	binutils-2_14-branch:1.5.0.6
	binutils-2_14-branchpoint:1.5
	kettenis_i386newframe-20030419-branch:1.5.0.4
	kettenis_i386newframe-20030419-branchpoint:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	kettenis_i386newframe-20030406-branch:1.5.0.2
	kettenis_i386newframe-20030406-branchpoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.4
	cagney_frameaddr-20030403-branch:1.4.0.16
	cagney_framebase-20030330-mergepoint:1.4
	cagney_framebase-20030326-branch:1.4.0.14
	cagney_framebase-20030326-branchpoint:1.4
	cagney_lazyid-20030317-branch:1.4.0.12
	cagney_lazyid-20030317-branchpoint:1.4
	kettenis-i386newframe-20030316-mergepoint:1.4
	offbyone-20030313-branch:1.4.0.10
	offbyone-20030313-branchpoint:1.4
	kettenis-i386newframe-20030308-branch:1.4.0.8
	kettenis-i386newframe-20030308-branchpoint:1.4
	carlton_dictionary-20030305-merge:1.4
	cagney_offbyone-20030303-branch:1.4.0.6
	cagney_offbyone-20030303-branchpoint:1.4
	carlton_dictionary-20030207-merge:1.4
	interps-20030202-branch:1.4.0.4
	interps-20030202-branchpoint:1.4
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.1
	carlton_dictionary-20021115-merge:1.2
	kseitz_interps-20021105-merge:1.2
	kseitz_interps-20021103-merge:1.2
	drow-cplus-merge-20021020:1.2
	drow-cplus-merge-20021025:1.2
	carlton_dictionary-20021025-merge:1.2
	carlton_dictionary-20021011-merge:1.2
	drow-cplus-branch:1.2.0.4
	drow-cplus-branchpoint:1.2
	kseitz_interps-20020930-merge:1.2
	carlton_dictionary-20020927-merge:1.2
	carlton_dictionary-branch:1.2.0.2
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.1
	sid-20020905-branch:1.1.0.6
	gdb_5_3-branch:1.1.0.4
	gdb_5_3-2002-09-04-branchpoint:1.1
	kseitz_interps-20020528-branch:1.1.0.2
	kseitz_interps-20020829-merge:1.1
	binutils_latest_snapshot:1.10;
locks; strict;
comment	@ * @;


1.10
date	2012.05.18.01.59.38;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2007.07.05.09.49.02;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2005.07.07.19.27.51;	author wilson;	state Exp;
branches;
next	1.7;

1.7
date	2005.07.01.11.16.33;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.07.07.34.31;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.04.08.15.15;	author sveinse;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.18.09.09.35;	author sveinse;	state Exp;
branches
	1.4.16.1;
next	1.3;

1.3
date	2002.11.16.12.23.22;	author sveinse;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.17.08.34.17;	author amodra;	state Exp;
branches
	1.2.2.1
	1.2.4.1;
next	1.1;

1.1
date	2002.08.28.10.38.51;	author nickc;	state Exp;
branches
	1.1.2.1;
next	;

1.4.16.1
date	2003.04.10.21.33.53;	author cagney;	state Exp;
branches;
next	;

1.2.2.1
date	2002.12.23.19.39.37;	author carlton;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2003.04.16.19.57.07;	author carlton;	state Exp;
branches;
next	;

1.2.4.1
date	2003.12.14.20.28.10;	author drow;	state Exp;
branches;
next	;

1.1.2.1
date	2002.08.30.22.52.54;	author kseitz;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.10.01.00.46.44;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.10
log
@	* arc-dis.c: Include sysdep.h first, remove some redundant includes.
	* bfin-dis.c: Likewise.
	* i860-dis.c: Likewise.
	* ia64-dis.c: Likewise.
	* ia64-gen.c: Likewise.
	* m68hc11-dis.c: Likewise.
	* mmix-dis.c: Likewise.
	* msp430-dis.c: Likewise.
	* or32-dis.c: Likewise.
	* rl78-dis.c: Likewise.
	* rx-dis.c: Likewise.
	* tic4x-dis.c: Likewise.
	* tilegx-opc.c: Likewise.
	* tilepro-opc.c: Likewise.
	* rx-decode.c: Regenerate.
@
text
@/* Print instructions for the Texas TMS320C[34]X, for GDB and GNU Binutils.

   Copyright 2002, 2003, 2005, 2007, 2012 Free Software Foundation, Inc.

   Contributed by Michael P. Hayes (m.hayes@@elec.canterbury.ac.nz)

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include <math.h>
#include "libiberty.h"
#include "dis-asm.h"
#include "opcode/tic4x.h"

#define TIC4X_DEBUG 0

#define TIC4X_HASH_SIZE   11   /* 11 (bits) and above should give unique entries.  */
#define TIC4X_SPESOP_SIZE 8    /* Max 8. ops for special instructions.  */

typedef enum
{
  IMMED_SINT,
  IMMED_SUINT,
  IMMED_SFLOAT,
  IMMED_INT,
  IMMED_UINT,
  IMMED_FLOAT
}
immed_t;

typedef enum
{
  INDIRECT_SHORT,
  INDIRECT_LONG,
  INDIRECT_TIC4X
}
indirect_t;

static int tic4x_version = 0;
static int tic4x_dp = 0;

static int
tic4x_pc_offset (unsigned int op)
{
  /* Determine the PC offset for a C[34]x instruction.
     This could be simplified using some boolean algebra
     but at the expense of readability.  */
  switch (op >> 24)
    {
    case 0x60:	/* br */
    case 0x62:	/* call  (C4x) */
    case 0x64:	/* rptb  (C4x) */
      return 1;
    case 0x61: 	/* brd */
    case 0x63: 	/* laj */
    case 0x65:	/* rptbd (C4x) */
      return 3;
    case 0x66: 	/* swi */
    case 0x67:
      return 0;
    default:
      break;
    }

  switch ((op & 0xffe00000) >> 20)
    {
    case 0x6a0:	/* bB */
    case 0x720: /* callB */
    case 0x740: /* trapB */
      return 1;

    case 0x6a2: /* bBd */
    case 0x6a6: /* bBat */
    case 0x6aa: /* bBaf */
    case 0x722:	/* lajB */
    case 0x748: /* latB */
    case 0x798: /* rptbd */
      return 3;

    default:
      break;
    }

  switch ((op & 0xfe200000) >> 20)
    {
    case 0x6e0:	/* dbB */
      return 1;

    case 0x6e2:	/* dbBd */
      return 3;

    default:
      break;
    }

  return 0;
}

static int
tic4x_print_char (struct disassemble_info * info, char ch)
{
  if (info != NULL)
    (*info->fprintf_func) (info->stream, "%c", ch);
  return 1;
}

static int
tic4x_print_str (struct disassemble_info *info, char *str)
{
  if (info != NULL)
    (*info->fprintf_func) (info->stream, "%s", str);
  return 1;
}

static int
tic4x_print_register (struct disassemble_info *info, unsigned long regno)
{
  static tic4x_register_t ** registertable = NULL;
  unsigned int i;

  if (registertable == NULL)
    {
      registertable = xmalloc (sizeof (tic4x_register_t *) * REG_TABLE_SIZE);
      for (i = 0; i < tic3x_num_registers; i++)
	registertable[tic3x_registers[i].regno] = (tic4x_register_t *) (tic3x_registers + i);
      if (IS_CPU_TIC4X (tic4x_version))
	{
	  /* Add C4x additional registers, overwriting
	     any C3x registers if necessary.  */
	  for (i = 0; i < tic4x_num_registers; i++)
	    registertable[tic4x_registers[i].regno] =
	      (tic4x_register_t *)(tic4x_registers + i);
	}
    }
  if ((int) regno > (IS_CPU_TIC4X (tic4x_version) ? TIC4X_REG_MAX : TIC3X_REG_MAX))
    return 0;
  if (info != NULL)
    (*info->fprintf_func) (info->stream, "%s", registertable[regno]->name);
  return 1;
}

static int
tic4x_print_addr (struct disassemble_info *info, unsigned long addr)
{
  if (info != NULL)
    (*info->print_address_func)(addr, info);
  return 1;
}

static int
tic4x_print_relative (struct disassemble_info *info,
		      unsigned long pc,
		      long offset,
		      unsigned long opcode)
{
  return tic4x_print_addr (info, pc + offset + tic4x_pc_offset (opcode));
}

static int
tic4x_print_direct (struct disassemble_info *info, unsigned long arg)
{
  if (info != NULL)
    {
      (*info->fprintf_func) (info->stream, "@@");
      tic4x_print_addr (info, arg + (tic4x_dp << 16));
    }
  return 1;
}
#if 0
/* FIXME: make the floating point stuff not rely on host
   floating point arithmetic.  */

static void
tic4x_print_ftoa (unsigned int val, FILE *stream, fprintf_ftype pfunc)
{
  int e;
  int s;
  int f;
  double num = 0.0;

  e = EXTRS (val, 31, 24);	/* Exponent.  */
  if (e != -128)
    {
      s = EXTRU (val, 23, 23);	/* Sign bit.  */
      f = EXTRU (val, 22, 0);	/* Mantissa.  */
      if (s)
	f += -2 * (1 << 23);
      else
	f += (1 << 23);
      num = f / (double)(1 << 23);
      num = ldexp (num, e);
    }
  (*pfunc)(stream, "%.9g", num);
}
#endif

static int
tic4x_print_immed (struct disassemble_info *info,
		   immed_t type,
		   unsigned long arg)
{
  int s;
  int f;
  int e;
  double num = 0.0;

  if (info == NULL)
    return 1;
  switch (type)
    {
    case IMMED_SINT:
    case IMMED_INT:
      (*info->fprintf_func) (info->stream, "%ld", (long) arg);
      break;

    case IMMED_SUINT:
    case IMMED_UINT:
      (*info->fprintf_func) (info->stream, "%lu", arg);
      break;

    case IMMED_SFLOAT:
      e = EXTRS (arg, 15, 12);
      if (e != -8)
	{
	  s = EXTRU (arg, 11, 11);
	  f = EXTRU (arg, 10, 0);
	  if (s)
	    f += -2 * (1 << 11);
	  else
	    f += (1 << 11);
	  num = f / (double)(1 << 11);
	  num = ldexp (num, e);
	}
      (*info->fprintf_func) (info->stream, "%f", num);
      break;
    case IMMED_FLOAT:
      e = EXTRS (arg, 31, 24);
      if (e != -128)
	{
	  s = EXTRU (arg, 23, 23);
	  f = EXTRU (arg, 22, 0);
	  if (s)
	    f += -2 * (1 << 23);
	  else
	    f += (1 << 23);
	  num = f / (double)(1 << 23);
	  num = ldexp (num, e);
	}
      (*info->fprintf_func) (info->stream, "%f", num);
      break;
    }
  return 1;
}

static int
tic4x_print_cond (struct disassemble_info *info, unsigned int cond)
{
  static tic4x_cond_t **condtable = NULL;
  unsigned int i;

  if (condtable == NULL)
    {
      condtable = xmalloc (sizeof (tic4x_cond_t *) * 32);
      for (i = 0; i < tic4x_num_conds; i++)
	condtable[tic4x_conds[i].cond] = (tic4x_cond_t *)(tic4x_conds + i);
    }
  if (cond > 31 || condtable[cond] == NULL)
    return 0;
  if (info != NULL)
    (*info->fprintf_func) (info->stream, "%s", condtable[cond]->name);
  return 1;
}

static int
tic4x_print_indirect (struct disassemble_info *info,
		      indirect_t type,
		      unsigned long arg)
{
  unsigned int aregno;
  unsigned int modn;
  unsigned int disp;
  char *a;

  aregno = 0;
  modn = 0;
  disp = 1;
  switch(type)
    {
    case INDIRECT_TIC4X:		/* *+ARn(disp) */
      disp = EXTRU (arg, 7, 3);
      aregno = EXTRU (arg, 2, 0) + REG_AR0;
      modn = 0;
      break;
    case INDIRECT_SHORT:
      disp = 1;
      aregno = EXTRU (arg, 2, 0) + REG_AR0;
      modn = EXTRU (arg, 7, 3);
      break;
    case INDIRECT_LONG:
      disp = EXTRU (arg, 7, 0);
      aregno = EXTRU (arg, 10, 8) + REG_AR0;
      modn = EXTRU (arg, 15, 11);
      if (modn > 7 && disp != 0)
	return 0;
      break;
    default:
        (*info->fprintf_func)(info->stream, "# internal error: Unknown indirect type %d", type);
        return 0;
    }
  if (modn > TIC3X_MODN_MAX)
    return 0;
  a = tic4x_indirects[modn].name;
  while (*a)
    {
      switch (*a)
	{
	case 'a':
	  tic4x_print_register (info, aregno);
	  break;
	case 'd':
	  tic4x_print_immed (info, IMMED_UINT, disp);
	  break;
	case 'y':
	  tic4x_print_str (info, "ir0");
	  break;
	case 'z':
	  tic4x_print_str (info, "ir1");
	  break;
	default:
	  tic4x_print_char (info, *a);
	  break;
	}
      a++;
    }
  return 1;
}

static int
tic4x_print_op (struct disassemble_info *info,
		unsigned long instruction,
		tic4x_inst_t *p,
		unsigned long pc)
{
  int val;
  char *s;
  char *parallel = NULL;

  /* Print instruction name.  */
  s = p->name;
  while (*s && parallel == NULL)
    {
      switch (*s)
	{
	case 'B':
	  if (! tic4x_print_cond (info, EXTRU (instruction, 20, 16)))
	    return 0;
	  break;
	case 'C':
	  if (! tic4x_print_cond (info, EXTRU (instruction, 27, 23)))
	    return 0;
	  break;
	case '_':
	  parallel = s + 1;	/* Skip past `_' in name.  */
	  break;
	default:
	  tic4x_print_char (info, *s);
	  break;
	}
      s++;
    }

  /* Print arguments.  */
  s = p->args;
  if (*s)
    tic4x_print_char (info, ' ');

  while (*s)
    {
      switch (*s)
	{
	case '*': /* Indirect 0--15.  */
	  if (! tic4x_print_indirect (info, INDIRECT_LONG,
				      EXTRU (instruction, 15, 0)))
	    return 0;
	  break;

	case '#': /* Only used for ldp, ldpk.  */
	  tic4x_print_immed (info, IMMED_UINT, EXTRU (instruction, 15, 0));
	  break;

	case '@@': /* Direct 0--15.  */
	  tic4x_print_direct (info, EXTRU (instruction, 15, 0));
	  break;

	case 'A': /* Address register 24--22.  */
	  if (! tic4x_print_register (info, EXTRU (instruction, 24, 22) +
				      REG_AR0))
	    return 0;
	  break;

	case 'B': /* 24-bit unsigned int immediate br(d)/call/rptb
		     address 0--23.  */
	  if (IS_CPU_TIC4X (tic4x_version))
	    tic4x_print_relative (info, pc, EXTRS (instruction, 23, 0),
				  p->opcode);
	  else
	    tic4x_print_addr (info, EXTRU (instruction, 23, 0));
	  break;

	case 'C': /* Indirect (short C4x) 0--7.  */
	  if (! IS_CPU_TIC4X (tic4x_version))
	    return 0;
	  if (! tic4x_print_indirect (info, INDIRECT_TIC4X,
				      EXTRU (instruction, 7, 0)))
	    return 0;
	  break;

	case 'D':
	  /* Cockup if get here...  */
	  break;

	case 'E': /* Register 0--7.  */
        case 'e':
	  if (! tic4x_print_register (info, EXTRU (instruction, 7, 0)))
	    return 0;
	  break;

	case 'F': /* 16-bit float immediate 0--15.  */
	  tic4x_print_immed (info, IMMED_SFLOAT,
			     EXTRU (instruction, 15, 0));
	  break;

        case 'i': /* Extended indirect 0--7.  */
          if (EXTRU (instruction, 7, 5) == 7)
            {
              if (!tic4x_print_register (info, EXTRU (instruction, 4, 0)))
                return 0;
              break;
            }
          /* Fallthrough */

	case 'I': /* Indirect (short) 0--7.  */
	  if (! tic4x_print_indirect (info, INDIRECT_SHORT,
				      EXTRU (instruction, 7, 0)))
	    return 0;
	  break;

        case 'j': /* Extended indirect 8--15 */
          if (EXTRU (instruction, 15, 13) == 7)
            {
              if (! tic4x_print_register (info, EXTRU (instruction, 12, 8)))
                return 0;
              break;
            }

	case 'J': /* Indirect (short) 8--15.  */
	  if (! tic4x_print_indirect (info, INDIRECT_SHORT,
				      EXTRU (instruction, 15, 8)))
	    return 0;
	  break;

	case 'G': /* Register 8--15.  */
        case 'g':
	  if (! tic4x_print_register (info, EXTRU (instruction, 15, 8)))
	    return 0;
	  break;

	case 'H': /* Register 16--18.  */
	  if (! tic4x_print_register (info, EXTRU (instruction, 18, 16)))
	    return 0;
	  break;

	case 'K': /* Register 19--21.  */
	  if (! tic4x_print_register (info, EXTRU (instruction, 21, 19)))
	    return 0;
	  break;

	case 'L': /* Register 22--24.  */
	  if (! tic4x_print_register (info, EXTRU (instruction, 24, 22)))
	    return 0;
	  break;

	case 'M': /* Register 22--22.  */
	  tic4x_print_register (info, EXTRU (instruction, 22, 22) + REG_R2);
	  break;

	case 'N': /* Register 23--23.  */
	  tic4x_print_register (info, EXTRU (instruction, 23, 23) + REG_R0);
	  break;

	case 'O': /* Indirect (short C4x) 8--15.  */
	  if (! IS_CPU_TIC4X (tic4x_version))
	    return 0;
	  if (! tic4x_print_indirect (info, INDIRECT_TIC4X,
				      EXTRU (instruction, 15, 8)))
	    return 0;
	  break;

	case 'P': /* Displacement 0--15 (used by Bcond and BcondD).  */
	  tic4x_print_relative (info, pc, EXTRS (instruction, 15, 0),
				p->opcode);
	  break;

	case 'Q': /* Register 0--15.  */
        case 'q':
	  if (! tic4x_print_register (info, EXTRU (instruction, 15, 0)))
	    return 0;
	  break;

	case 'R': /* Register 16--20.  */
        case 'r':
	  if (! tic4x_print_register (info, EXTRU (instruction, 20, 16)))
	    return 0;
	  break;

	case 'S': /* 16-bit signed immediate 0--15.  */
	  tic4x_print_immed (info, IMMED_SINT,
			     EXTRS (instruction, 15, 0));
	  break;

	case 'T': /* 5-bit signed immediate 16--20  (C4x stik).  */
	  if (! IS_CPU_TIC4X (tic4x_version))
	    return 0;
	  if (! tic4x_print_immed (info, IMMED_SUINT,
				   EXTRU (instruction, 20, 16)))
	    return 0;
	  break;

	case 'U': /* 16-bit unsigned int immediate 0--15.  */
	  tic4x_print_immed (info, IMMED_SUINT, EXTRU (instruction, 15, 0));
	  break;

	case 'V': /* 5/9-bit unsigned vector 0--4/8.  */
	  tic4x_print_immed (info, IMMED_SUINT,
			     IS_CPU_TIC4X (tic4x_version) ?
			     EXTRU (instruction, 8, 0) :
			     EXTRU (instruction, 4, 0) & ~0x20);
	  break;

	case 'W': /* 8-bit signed immediate 0--7.  */
	  if (! IS_CPU_TIC4X (tic4x_version))
	    return 0;
	  tic4x_print_immed (info, IMMED_SINT, EXTRS (instruction, 7, 0));
	  break;

	case 'X': /* Expansion register 4--0.  */
	  val = EXTRU (instruction, 4, 0) + REG_IVTP;
	  if (val < REG_IVTP || val > REG_TVTP)
	    return 0;
	  if (! tic4x_print_register (info, val))
	    return 0;
	  break;

	case 'Y': /* Address register 16--20.  */
	  val = EXTRU (instruction, 20, 16);
	  if (val < REG_AR0 || val > REG_SP)
	    return 0;
	  if (! tic4x_print_register (info, val))
	    return 0;
	  break;

	case 'Z': /* Expansion register 16--20.  */
	  val = EXTRU (instruction, 20, 16) + REG_IVTP;
	  if (val < REG_IVTP || val > REG_TVTP)
	    return 0;
	  if (! tic4x_print_register (info, val))
	    return 0;
	  break;

	case '|':	/* Parallel instruction.  */
	  tic4x_print_str (info, " || ");
	  tic4x_print_str (info, parallel);
	  tic4x_print_char (info, ' ');
	  break;

	case ';':
	  tic4x_print_char (info, ',');
	  break;

	default:
	  tic4x_print_char (info, *s);
	  break;
	}
      s++;
    }
  return 1;
}

static void
tic4x_hash_opcode_special (tic4x_inst_t **optable_special,
			   const tic4x_inst_t *inst)
{
  int i;

  for (i = 0;i < TIC4X_SPESOP_SIZE; i++)
    if (optable_special[i] != NULL
        && optable_special[i]->opcode == inst->opcode)
      {
        /* Collision (we have it already) - overwrite.  */
        optable_special[i] = (tic4x_inst_t *) inst;
        return;
      }

  for (i = 0; i < TIC4X_SPESOP_SIZE; i++)
    if (optable_special[i] == NULL)
      {
        /* Add the new opcode.  */
        optable_special[i] = (tic4x_inst_t *) inst;
        return;
      }

  /* This should never occur. This happens if the number of special
     instructions exceeds TIC4X_SPESOP_SIZE. Please increase the variable
     of this variable */
#if TIC4X_DEBUG
  printf ("optable_special[] is full, please increase TIC4X_SPESOP_SIZE!\n");
#endif
}

static void
tic4x_hash_opcode (tic4x_inst_t **optable,
		   tic4x_inst_t **optable_special,
		   const tic4x_inst_t *inst,
		   const unsigned long tic4x_oplevel)
{
  int j;
  int opcode = inst->opcode >> (32 - TIC4X_HASH_SIZE);
  int opmask = inst->opmask >> (32 - TIC4X_HASH_SIZE);

  /* Use a TIC4X_HASH_SIZE bit index as a hash index.  We should
     have unique entries so there's no point having a linked list
     for each entry?  */
  for (j = opcode; j < opmask; j++)
    if ((j & opmask) == opcode
         && inst->oplevel & tic4x_oplevel)
      {
#if TIC4X_DEBUG
	/* We should only have collisions for synonyms like
	   ldp for ldi.  */
	if (optable[j] != NULL)
	  printf ("Collision at index %d, %s and %s\n",
		  j, optable[j]->name, inst->name);
#endif
        /* Catch those ops that collide with others already inside the
           hash, and have a opmask greater than the one we use in the
           hash. Store them in a special-list, that will handle full
           32-bit INSN, not only the first 11-bit (or so). */
        if (optable[j] != NULL
	    && inst->opmask & ~(opmask << (32 - TIC4X_HASH_SIZE)))
          {
            /* Add the instruction already on the list.  */
            tic4x_hash_opcode_special (optable_special, optable[j]);

            /* Add the new instruction.  */
            tic4x_hash_opcode_special (optable_special, inst);
          }

        optable[j] = (tic4x_inst_t *) inst;
      }
}

/* Disassemble the instruction in 'instruction'.
   'pc' should be the address of this instruction, it will
   be used to print the target address if this is a relative jump or call
   the disassembled instruction is written to 'info'.
   The function returns the length of this instruction in words.  */

static int
tic4x_disassemble (unsigned long pc,
		   unsigned long instruction,
		   struct disassemble_info *info)
{
  static tic4x_inst_t **optable = NULL;
  static tic4x_inst_t **optable_special = NULL;
  tic4x_inst_t *p;
  int i;
  unsigned long tic4x_oplevel;

  tic4x_version = info->mach;

  tic4x_oplevel  = (IS_CPU_TIC4X (tic4x_version)) ? OP_C4X : 0;
  tic4x_oplevel |= OP_C3X | OP_LPWR | OP_IDLE2 | OP_ENH;

  if (optable == NULL)
    {
      optable = xcalloc (sizeof (tic4x_inst_t *), (1 << TIC4X_HASH_SIZE));

      optable_special = xcalloc (sizeof (tic4x_inst_t *), TIC4X_SPESOP_SIZE);

      /* Install opcodes in reverse order so that preferred
	 forms overwrite synonyms.  */
      for (i = tic4x_num_insts - 1; i >= 0; i--)
        tic4x_hash_opcode (optable, optable_special, &tic4x_insts[i],
			   tic4x_oplevel);

      /* We now need to remove the insn that are special from the
         "normal" optable, to make the disasm search this extra list
         for them.  */
      for (i = 0; i < TIC4X_SPESOP_SIZE; i++)
        if (optable_special[i] != NULL)
          optable[optable_special[i]->opcode >> (32 - TIC4X_HASH_SIZE)] = NULL;
    }

  /* See if we can pick up any loading of the DP register...  */
  if ((instruction >> 16) == 0x5070 || (instruction >> 16) == 0x1f70)
    tic4x_dp = EXTRU (instruction, 15, 0);

  p = optable[instruction >> (32 - TIC4X_HASH_SIZE)];
  if (p != NULL)
    {
      if (((instruction & p->opmask) == p->opcode)
           && tic4x_print_op (NULL, instruction, p, pc))
        tic4x_print_op (info, instruction, p, pc);
      else
        (*info->fprintf_func) (info->stream, "%08lx", instruction);
    }
  else
    {
      for (i = 0; i<TIC4X_SPESOP_SIZE; i++)
        if (optable_special[i] != NULL
            && optable_special[i]->opcode == instruction)
          {
            (*info->fprintf_func)(info->stream, "%s", optable_special[i]->name);
            break;
          }
      if (i == TIC4X_SPESOP_SIZE)
        (*info->fprintf_func) (info->stream, "%08lx", instruction);
    }

  /* Return size of insn in words.  */
  return 1;
}

/* The entry point from objdump and gdb.  */
int
print_insn_tic4x (bfd_vma memaddr, struct disassemble_info *info)
{
  int status;
  unsigned long pc;
  unsigned long op;
  bfd_byte buffer[4];

  status = (*info->read_memory_func) (memaddr, buffer, 4, info);
  if (status != 0)
    {
      (*info->memory_error_func) (status, memaddr, info);
      return -1;
    }

  pc = memaddr;
  op = bfd_getl32 (buffer);
  info->bytes_per_line = 4;
  info->bytes_per_chunk = 4;
  info->octets_per_byte = 4;
  info->display_endian = BFD_ENDIAN_LITTLE;
  return tic4x_disassemble (pc, op, info) * 4;
}
@


1.9
log
@Change source files over to GPLv3.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2005, 2007 Free Software Foundation, Inc.
d24 1
@


1.8
log
@Kaveh Ghazi's printf format attribute checking patch.
bfd:
	* elf32-xtensa.c (vsprint_msg): Add format attribute.  Fix
	format bugs.
	* vms.h (_bfd_vms_debug): Add format attribute.
	(_bfd_vms_debug, _bfd_hexdump): Fix typos.

binutils:
	* bucomm.h (report): Add format attribute.
	* dlltool.c (inform): Likewise.
	* dllwrap.c (display, inform, warn): Likewise.
	* objdump.c (objdump_sprintf): Likewise.
	* readelf.c (error, warn): Likewise.  Fix format bugs.

gas:
	* config/tc-tic30.c (debug): Add format attribute.  Fix format
	bugs.

include:
	* dis-asm.h (fprintf_ftype): Add format attribute.

opcodes:
	* arc-dis.c, arm-dis.c, cris-dis.c, crx-dis.c, d10v-dis.c,
	d30v-dis.c, fr30-dis.c, h8300-dis.c, h8500-dis.c, i860-dis.c,
	ia64-dis.c, ip2k-dis.c, m10200-dis.c, m10300-dis.c,
	m88k-dis.c, mcore-dis.c, mips-dis.c, ms1-dis.c, or32-dis.c,
	ppc-dis.c, sh64-dis.c, sparc-dis.c, tic4x-dis.c, tic80-dis.c,
	v850-dis.c: Fix format bugs.
	* ia64-gen.c (fail, warn): Add format attribute.
	* or32-opc.c (debug): Likewise.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2005 Free Software Foundation, Inc.
d7 3
a9 1
   This program is free software; you can redistribute it and/or modify
d11 2
a12 2
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d14 4
a17 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
@


1.7
log
@Update function declarations to ISO C90 formatting
@
text
@d225 1
a225 1
      (*info->fprintf_func) (info->stream, "%d", (long) arg);
d230 1
a230 1
      (*info->fprintf_func) (info->stream, "%u", arg);
d727 1
a727 1
        (*info->fprintf_func) (info->stream, "%08x", instruction);
d739 1
a739 1
        (*info->fprintf_func) (info->stream, "%08x", instruction);
@


1.6
log
@Update the address and phone number of the FSF
@
text
@d3 1
a3 1
   Copyright 2002, 2003 Free Software Foundation, Inc.
d6 1
a6 1
   
d19 2
a20 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
d30 1
a30 1
#define TIC4X_SPESOP_SIZE 8    /* Max 8. ops for special instructions */
d33 8
a40 8
  {
    IMMED_SINT,
    IMMED_SUINT,
    IMMED_SFLOAT,
    IMMED_INT,
    IMMED_UINT,
    IMMED_FLOAT
  }
d44 5
a48 5
  {
    INDIRECT_SHORT,
    INDIRECT_LONG,
    INDIRECT_TIC4X
  }
a53 34
static int tic4x_pc_offset
  PARAMS ((unsigned int));
static int tic4x_print_char
  PARAMS ((struct disassemble_info *, char));
static int tic4x_print_str
  PARAMS ((struct disassemble_info *, char *));
static int tic4x_print_register
  PARAMS ((struct disassemble_info *, unsigned long));
static int tic4x_print_addr
  PARAMS ((struct disassemble_info *, unsigned long));
static int tic4x_print_relative
  PARAMS ((struct disassemble_info *, unsigned long, long, unsigned long));
void tic4x_print_ftoa
  PARAMS ((unsigned int, FILE *, fprintf_ftype));
static int tic4x_print_direct
  PARAMS ((struct disassemble_info *, unsigned long));
static int tic4x_print_immed
  PARAMS ((struct disassemble_info *, immed_t, unsigned long));
static int tic4x_print_cond
  PARAMS ((struct disassemble_info *, unsigned int));
static int tic4x_print_indirect
  PARAMS ((struct disassemble_info *, indirect_t, unsigned long));
static int tic4x_print_op
  PARAMS ((struct disassemble_info *, unsigned long, tic4x_inst_t *, unsigned long));
static void tic4x_hash_opcode_special
  PARAMS ((tic4x_inst_t **, const tic4x_inst_t *));
static void tic4x_hash_opcode
  PARAMS ((tic4x_inst_t **, tic4x_inst_t **, const tic4x_inst_t *, unsigned long));
static int tic4x_disassemble
  PARAMS ((unsigned long, unsigned long, struct disassemble_info *));
int print_insn_tic4x
  PARAMS ((bfd_vma, struct disassemble_info *));


d55 1
a55 2
tic4x_pc_offset (op)
     unsigned int op;
d76 1
a76 1
  
d83 1
a83 1
      
d91 1
a91 1
      
d95 1
a95 1
  
d100 1
a100 1
      
d103 1
a103 1
      
d107 1
a107 1
  
d112 1
a112 3
tic4x_print_char (info, ch)
     struct disassemble_info * info;
     char ch;
d120 1
a120 3
tic4x_print_str (info, str)
     struct disassemble_info *info;
     char *str;
d128 1
a128 3
tic4x_print_register (info, regno)
     struct disassemble_info *info;
     unsigned long regno;
d130 1
a130 1
  static tic4x_register_t **registertable = NULL;
d132 1
a132 1
  
d135 1
a135 2
      registertable = (tic4x_register_t **)
	xmalloc (sizeof (tic4x_register_t *) * REG_TABLE_SIZE);
d137 1
a137 1
	registertable[tic3x_registers[i].regno] = (void *)&tic3x_registers[i];
d143 2
a144 1
	    registertable[tic4x_registers[i].regno] = (void *)&tic4x_registers[i];
d155 1
a155 3
tic4x_print_addr (info, addr)
     struct disassemble_info *info;
     unsigned long addr;
d163 4
a166 5
tic4x_print_relative (info, pc, offset, opcode)
     struct disassemble_info *info;
     unsigned long pc;
     long offset;
     unsigned long opcode;
d172 1
a172 3
tic4x_print_direct (info, arg)
     struct disassemble_info *info;
     unsigned long arg;
d181 1
a181 1

d184 3
a186 5
void
tic4x_print_ftoa (val, stream, pfunc)
     unsigned int val;
     FILE *stream;
     fprintf_ftype pfunc;
d192 2
a193 2
  
  e = EXTRS (val, 31, 24);	/* exponent */
d196 2
a197 2
      s = EXTRU (val, 23, 23);	/* sign bit */
      f = EXTRU (val, 22, 0);	/* mantissa */
d204 1
a204 1
    }    
d207 1
d210 3
a212 4
tic4x_print_immed (info, type, arg)
     struct disassemble_info *info;
     immed_t type;
     unsigned long arg;
d218 1
a218 1
  
d225 1
a225 1
      (*info->fprintf_func) (info->stream, "%d", (long)arg);
d227 1
a227 1
      
d232 1
a232 1
      
d268 1
a268 3
tic4x_print_cond (info, cond)
     struct disassemble_info *info;
     unsigned int cond;
d272 1
a272 1
  
d275 1
a275 1
      condtable = (tic4x_cond_t **)xmalloc (sizeof (tic4x_cond_t *) * 32);
d277 1
a277 1
	condtable[tic4x_conds[i].cond] = (void *)&tic4x_conds[i];
d287 3
a289 4
tic4x_print_indirect (info, type, arg)
     struct disassemble_info *info;
     indirect_t type;
     unsigned long arg;
d351 4
a354 5
tic4x_print_op (info, instruction, p, pc)
     struct disassemble_info *info;
     unsigned long instruction;
     tic4x_inst_t *p;
     unsigned long pc;
d375 1
a375 1
	  parallel = s + 1;	/* Skip past `_' in name */
d383 1
a383 1
  
d393 1
a393 1
	case '*': /* indirect 0--15 */
d395 1
a395 1
				    EXTRU (instruction, 15, 0)))
d399 1
a399 1
	case '#': /* only used for ldp, ldpk */
d403 1
a403 1
	case '@@': /* direct 0--15 */
d407 1
a407 1
	case 'A': /* address register 24--22 */
d409 1
a409 1
				    REG_AR0))
d417 1
a417 1
				p->opcode);
d422 1
a422 1
	case 'C': /* indirect (short C4x) 0--7 */
d426 1
a426 1
				    EXTRU (instruction, 7, 0)))
d434 1
a434 1
	case 'E': /* register 0--7 */
d440 1
a440 1
	case 'F': /* 16-bit float immediate 0--15 */
d442 1
a442 1
			   EXTRU (instruction, 15, 0));
d445 2
a446 2
        case 'i': /* Extended indirect 0--7 */
          if ( EXTRU (instruction, 7, 5) == 7 )
d448 1
a448 1
              if( !tic4x_print_register (info, EXTRU (instruction, 4, 0)) )
d454 1
a454 1
	case 'I': /* indirect (short) 0--7 */
d456 1
a456 1
				    EXTRU (instruction, 7, 0)))
d461 1
a461 1
          if ( EXTRU (instruction, 15, 13) == 7 )
d463 1
a463 1
              if( !tic4x_print_register (info, EXTRU (instruction, 12, 8)) )
d468 1
a468 1
	case 'J': /* indirect (short) 8--15 */
d470 1
a470 1
				    EXTRU (instruction, 15, 8)))
d474 1
a474 1
	case 'G': /* register 8--15 */
d480 1
a480 1
	case 'H': /* register 16--18 */
d485 1
a485 1
	case 'K': /* register 19--21 */
d490 1
a490 1
	case 'L': /* register 22--24 */
d495 1
a495 1
	case 'M': /* register 22--22 */
d499 1
a499 1
	case 'N': /* register 23--23 */
d503 1
a503 1
	case 'O': /* indirect (short C4x) 8--15 */
d507 1
a507 1
				    EXTRU (instruction, 15, 8)))
d511 1
a511 1
	case 'P': /* displacement 0--15 (used by Bcond and BcondD) */
d513 1
a513 1
			      p->opcode);
d516 1
a516 1
	case 'Q': /* register 0--15 */
d522 1
a522 1
	case 'R': /* register 16--20 */
d528 1
a528 1
	case 'S': /* 16-bit signed immediate 0--15 */
d530 1
a530 1
			   EXTRS (instruction, 15, 0));
d533 1
a533 1
	case 'T': /* 5-bit signed immediate 16--20  (C4x stik) */
d537 1
a537 1
				 EXTRU (instruction, 20, 16)))
d541 1
a541 1
	case 'U': /* 16-bit unsigned int immediate 0--15 */
d545 1
a545 1
	case 'V': /* 5/9-bit unsigned vector 0--4/8 */
d547 3
a549 3
			   IS_CPU_TIC4X (tic4x_version) ? 
			   EXTRU (instruction, 8, 0) :
			   EXTRU (instruction, 4, 0) & ~0x20);
d552 1
a552 1
	case 'W': /* 8-bit signed immediate 0--7 */
d558 1
a558 1
	case 'X': /* expansion register 4--0 */
d566 1
a566 1
	case 'Y': /* address register 16--20 */
d574 1
a574 1
	case 'Z': /* expansion register 16--20 */
d582 1
a582 1
	case '|':		/* Parallel instruction */
d602 2
a603 3
tic4x_hash_opcode_special (optable_special, inst)
     tic4x_inst_t **optable_special;
     const tic4x_inst_t *inst;
d607 3
a609 3
  for( i=0; i<TIC4X_SPESOP_SIZE; i++ )
    if( optable_special[i] != NULL
        && optable_special[i]->opcode == inst->opcode )
d611 2
a612 2
        /* Collision (we have it already) - overwrite */
        optable_special[i] = (void *)inst;
d616 2
a617 2
  for( i=0; i<TIC4X_SPESOP_SIZE; i++ )
    if( optable_special[i] == NULL )
d619 2
a620 2
        /* Add the new opcode */
        optable_special[i] = (void *)inst;
d628 1
a628 1
  printf("optable_special[] is full, please increase TIC4X_SPESOP_SIZE!\n");
d633 4
a636 5
tic4x_hash_opcode (optable, optable_special, inst, tic4x_oplevel)
     tic4x_inst_t **optable;
     tic4x_inst_t **optable_special;
     const tic4x_inst_t *inst;
     const unsigned long tic4x_oplevel;
d641 1
a641 1
  
d644 1
a644 1
     for each entry? */
d646 2
a647 2
    if ( (j & opmask) == opcode
         && inst->oplevel & tic4x_oplevel )
d653 2
a654 2
	  printf("Collision at index %d, %s and %s\n",
		 j, optable[j]->name, inst->name);
d660 2
a661 2
        if ( optable[j] != NULL
             && inst->opmask & ~(opmask << (32 - TIC4X_HASH_SIZE)) )
d663 2
a664 2
            /* Add the instruction already on the list */
            tic4x_hash_opcode_special(optable_special, optable[j]);
d666 2
a667 2
            /* Add the new instruction */
            tic4x_hash_opcode_special(optable_special, inst);
d670 1
a670 1
        optable[j] = (void *)inst;
d681 3
a683 4
tic4x_disassemble (pc, instruction, info)
     unsigned long pc;
     unsigned long instruction;
     struct disassemble_info *info;
d690 1
a690 1
  
d694 2
a695 2
  tic4x_oplevel |= OP_C3X|OP_LPWR|OP_IDLE2|OP_ENH;
  
d698 1
a698 2
      optable = (tic4x_inst_t **)
	xcalloc (sizeof (tic4x_inst_t *), (1 << TIC4X_HASH_SIZE));
d700 1
a700 2
      optable_special = (tic4x_inst_t **)
        xcalloc (sizeof (tic4x_inst_t *), TIC4X_SPESOP_SIZE );
d705 2
a706 1
        tic4x_hash_opcode (optable, optable_special, &tic4x_insts[i], tic4x_oplevel);
d710 3
a712 4
         for them.
      */
      for (i=0; i<TIC4X_SPESOP_SIZE; i++)
        if ( optable_special[i] != NULL )
d715 1
a715 1
  
d721 1
a721 1
  if ( p != NULL )
d723 2
a724 2
      if ( ((instruction & p->opmask) == p->opcode)
           && tic4x_print_op (NULL, instruction, p, pc) )
d733 1
a733 1
            && optable_special[i]->opcode == instruction )
d738 1
a738 1
      if (i==TIC4X_SPESOP_SIZE)
d743 1
a743 1
  return 1;	
d748 1
a748 3
print_insn_tic4x (memaddr, info)
     bfd_vma memaddr;
     struct disassemble_info *info;
d754 1
a754 1
  
d761 1
a761 1
  
@


1.5
log
@Namespace cleanup for the tic4x target. Replace s/c4x/tic4x/ and s/c3x/tic3x/. 2003 copyright update
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.4
log
@
	* gas/config/tc-tic4x.c: Fixed proper commandline
	parameters. Added support for new opcode-list format. General
	error message fixups.
	(c4x_inst_add): Reject insn not for our CPU
	(md_begin): Added matrix for setting the proper opcode-level &
	device-flags according to cpu type and revision. Rewrite the
	opcode hasher.
	(c4x_operand_parse): Fix opcode bug
	(c4x_operands_match): New function argument. Added dry-run
	mechanism, that is optional error generation. Added constraint 'i'
	and 'j'.
	(c4x_insn_check): Added new function for post-verification of the
	generated insn.
	(md_assemble): Check all opcodes before croaking because of an
	argument mismatch. Need this to be able to fully support
	ortogonally arguments.
	(md_parse_options): Revised commandprompt swicthes and added new
	ones.
	(md_show_usage): Complete rewrite of printout.
	* gas/testsuite/gas/tic4x/addressing.s: Fix bug in one insn
	* gas/testsuite/gas/tic4x/addressing_c3x.d: Update thereafter
	* gas/testsuite/gas/tic4x/addressing_c4x.d: Update thereafter
	* gas/testsuite/gas/tic4x/allopcodes.S: Add support for new
	opclass.h changes
	* gas/testsuite/gas/tic4x/opclasses.h: Added testsuites for
	the new enhanced opcodes.
	* gas/testsuite/gas/tic4x/opcodes.s: Regenerate
	* gas/testsuite/gas/tic4x/opcodes_c3x.d: Update from above
	* gas/testsuite/gas/tic4x/opcodes_c4x.d: Update from above
	* gas/testsuite/gas/tic4x/opcodes_new.d: Added new testsuite for
	the enhanced and special insns.
	* gas/testsuite/gas/tic4x/tic4x.exp: Added the opcodes_new testsuite
	* include/opcode/tic4x.h: File reordering. Added enhanced opcodes.
	* opcodes/tic4x-dis.c: Added support for enhanced and special
	insn.
	(c4x_print_op): Added insn class 'i' and 'j'
	(c4x_hash_opcode_special): Add to support special insn
	(c4x_hash_opcode): Update to support the new opcode-list
	format. Add support for the new special insns.
	(c4x_disassemble): New opcode-list support.
@
text
@d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d26 1
a26 1
#define C4X_DEBUG 0
d28 2
a29 2
#define C4X_HASH_SIZE   11   /* 11 (bits) and above should give unique entries.  */
#define C4X_SPESOP_SIZE 8    /* Max 8. ops for special instructions */
d46 1
a46 1
    INDIRECT_C4X
d50 2
a51 2
static int c4x_version = 0;
static int c4x_dp = 0;
d53 1
a53 1
static int c4x_pc_offset
d55 1
a55 1
static int c4x_print_char
d57 1
a57 1
static int c4x_print_str
d59 1
a59 1
static int c4x_print_register
d61 1
a61 1
static int c4x_print_addr
d63 1
a63 1
static int c4x_print_relative
d65 1
a65 1
void c4x_print_ftoa
d67 1
a67 1
static int c4x_print_direct
d69 1
a69 1
static int c4x_print_immed
d71 1
a71 1
static int c4x_print_cond
d73 1
a73 1
static int c4x_print_indirect
d75 7
a81 7
static int c4x_print_op
  PARAMS ((struct disassemble_info *, unsigned long, c4x_inst_t *, unsigned long));
static void c4x_hash_opcode_special
  PARAMS ((c4x_inst_t **, const c4x_inst_t *));
static void c4x_hash_opcode
  PARAMS ((c4x_inst_t **, c4x_inst_t **, const c4x_inst_t *, unsigned long));
static int c4x_disassemble
d88 1
a88 1
c4x_pc_offset (op)
d146 1
a146 1
c4x_print_char (info, ch)
d156 1
a156 1
c4x_print_str (info, str)
d166 1
a166 1
c4x_print_register (info, regno)
d170 1
a170 1
  static c4x_register_t **registertable = NULL;
d175 5
a179 5
      registertable = (c4x_register_t **)
	xmalloc (sizeof (c4x_register_t *) * REG_TABLE_SIZE);
      for (i = 0; i < c3x_num_registers; i++)
	registertable[c3x_registers[i].regno] = (void *)&c3x_registers[i];
      if (IS_CPU_C4X (c4x_version))
d183 2
a184 2
	  for (i = 0; i < c4x_num_registers; i++)
	    registertable[c4x_registers[i].regno] = (void *)&c4x_registers[i];
d187 1
a187 1
  if ((int) regno > (IS_CPU_C4X (c4x_version) ? C4X_REG_MAX : C3X_REG_MAX))
d195 1
a195 1
c4x_print_addr (info, addr)
d205 1
a205 1
c4x_print_relative (info, pc, offset, opcode)
d211 1
a211 1
  return c4x_print_addr (info, pc + offset + c4x_pc_offset (opcode));
d215 1
a215 1
c4x_print_direct (info, arg)
d222 1
a222 1
      c4x_print_addr (info, arg + (c4x_dp << 16));
d230 1
a230 1
c4x_print_ftoa (val, stream, pfunc)
d256 1
a256 1
c4x_print_immed (info, type, arg)
d315 1
a315 1
c4x_print_cond (info, cond)
d319 1
a319 1
  static c4x_cond_t **condtable = NULL;
d324 3
a326 3
      condtable = (c4x_cond_t **)xmalloc (sizeof (c4x_cond_t *) * 32);
      for (i = 0; i < num_conds; i++)
	condtable[c4x_conds[i].cond] = (void *)&c4x_conds[i];
d336 1
a336 1
c4x_print_indirect (info, type, arg)
d351 1
a351 1
    case INDIRECT_C4X:		/* *+ARn(disp) */
d369 2
a370 1
      abort ();
d372 1
a372 1
  if (modn > C3X_MODN_MAX)
d374 1
a374 1
  a = c4x_indirects[modn].name;
d380 1
a380 1
	  c4x_print_register (info, aregno);
d383 1
a383 1
	  c4x_print_immed (info, IMMED_UINT, disp);
d386 1
a386 1
	  c4x_print_str (info, "ir0");
d389 1
a389 1
	  c4x_print_str (info, "ir1");
d392 1
a392 1
	  c4x_print_char (info, *a);
d401 1
a401 1
c4x_print_op (info, instruction, p, pc)
d404 1
a404 1
     c4x_inst_t *p;
d418 1
a418 1
	  if (! c4x_print_cond (info, EXTRU (instruction, 20, 16)))
d422 1
a422 1
	  if (! c4x_print_cond (info, EXTRU (instruction, 27, 23)))
d429 1
a429 1
	  c4x_print_char (info, *s);
d438 1
a438 1
    c4x_print_char (info, ' ');
d445 1
a445 1
	  if (! c4x_print_indirect (info, INDIRECT_LONG,
d451 1
a451 1
	  c4x_print_immed (info, IMMED_UINT, EXTRU (instruction, 15, 0));
d455 1
a455 1
	  c4x_print_direct (info, EXTRU (instruction, 15, 0));
d459 1
a459 1
	  if (! c4x_print_register (info, EXTRU (instruction, 24, 22) +
d466 2
a467 2
	  if (IS_CPU_C4X (c4x_version))
	    c4x_print_relative (info, pc, EXTRS (instruction, 23, 0),
d470 1
a470 1
	    c4x_print_addr (info, EXTRU (instruction, 23, 0));
d474 1
a474 1
	  if (! IS_CPU_C4X (c4x_version))
d476 1
a476 1
	  if (! c4x_print_indirect (info, INDIRECT_C4X,
d487 1
a487 1
	  if (! c4x_print_register (info, EXTRU (instruction, 7, 0)))
d492 1
a492 1
	  c4x_print_immed (info, IMMED_SFLOAT,
d499 1
a499 1
              if( !c4x_print_register (info, EXTRU (instruction, 4, 0)) )
d506 1
a506 1
	  if (! c4x_print_indirect (info, INDIRECT_SHORT,
d514 1
a514 1
              if( !c4x_print_register (info, EXTRU (instruction, 12, 8)) )
d520 1
a520 1
	  if (! c4x_print_indirect (info, INDIRECT_SHORT,
d527 1
a527 1
	  if (! c4x_print_register (info, EXTRU (instruction, 15, 8)))
d532 1
a532 1
	  if (! c4x_print_register (info, EXTRU (instruction, 18, 16)))
d537 1
a537 1
	  if (! c4x_print_register (info, EXTRU (instruction, 21, 19)))
d542 1
a542 1
	  if (! c4x_print_register (info, EXTRU (instruction, 24, 22)))
d547 1
a547 1
	  c4x_print_register (info, EXTRU (instruction, 22, 22) + REG_R2);
d551 1
a551 1
	  c4x_print_register (info, EXTRU (instruction, 23, 23) + REG_R0);
d555 1
a555 1
	  if (! IS_CPU_C4X (c4x_version))
d557 1
a557 1
	  if (! c4x_print_indirect (info, INDIRECT_C4X,
d563 1
a563 1
	  c4x_print_relative (info, pc, EXTRS (instruction, 15, 0),
d569 1
a569 1
	  if (! c4x_print_register (info, EXTRU (instruction, 15, 0)))
d575 1
a575 1
	  if (! c4x_print_register (info, EXTRU (instruction, 20, 16)))
d580 1
a580 1
	  c4x_print_immed (info, IMMED_SINT,
d585 1
a585 1
	  if (! IS_CPU_C4X (c4x_version))
d587 1
a587 1
	  if (! c4x_print_immed (info, IMMED_SUINT,
d593 1
a593 1
	  c4x_print_immed (info, IMMED_SUINT, EXTRU (instruction, 15, 0));
d597 2
a598 2
	  c4x_print_immed (info, IMMED_SUINT,
			   IS_CPU_C4X (c4x_version) ? 
d604 1
a604 1
	  if (! IS_CPU_C4X (c4x_version))
d606 1
a606 1
	  c4x_print_immed (info, IMMED_SINT, EXTRS (instruction, 7, 0));
d613 1
a613 1
	  if (! c4x_print_register (info, val))
d621 1
a621 1
	  if (! c4x_print_register (info, val))
d629 1
a629 1
	  if (! c4x_print_register (info, val))
d634 3
a636 3
	  c4x_print_str (info, " || ");
	  c4x_print_str (info, parallel);
	  c4x_print_char (info, ' ');
d640 1
a640 1
	  c4x_print_char (info, ',');
d644 1
a644 1
	  c4x_print_char (info, *s);
d653 3
a655 3
c4x_hash_opcode_special (optable_special, inst)
     c4x_inst_t **optable_special;
     const c4x_inst_t *inst;
d659 1
a659 1
  for( i=0; i<C4X_SPESOP_SIZE; i++ )
d668 1
a668 1
  for( i=0; i<C4X_SPESOP_SIZE; i++ )
d677 1
a677 1
     instructions exceeds C4X_SPESOP_SIZE. Please increase the variable
d679 2
a680 2
#if C4X_DEBUG
  printf("optable_special[] is full, please increase C4X_SPESOP_SIZE!\n");
d685 5
a689 5
c4x_hash_opcode (optable, optable_special, inst, c4x_oplevel)
     c4x_inst_t **optable;
     c4x_inst_t **optable_special;
     const c4x_inst_t *inst;
     const unsigned long c4x_oplevel;
d692 2
a693 2
  int opcode = inst->opcode >> (32 - C4X_HASH_SIZE);
  int opmask = inst->opmask >> (32 - C4X_HASH_SIZE);
d695 1
a695 1
  /* Use a C4X_HASH_SIZE bit index as a hash index.  We should
d700 1
a700 1
         && inst->oplevel & c4x_oplevel )
d702 1
a702 1
#if C4X_DEBUG
d714 1
a714 1
             && inst->opmask & ~(opmask << (32 - C4X_HASH_SIZE)) )
d717 1
a717 1
            c4x_hash_opcode_special(optable_special, optable[j]);
d720 1
a720 1
            c4x_hash_opcode_special(optable_special, inst);
d734 1
a734 1
c4x_disassemble (pc, instruction, info)
d739 3
a741 3
  static c4x_inst_t **optable = NULL;
  static c4x_inst_t **optable_special = NULL;
  c4x_inst_t *p;
d743 1
a743 1
  unsigned long c4x_oplevel;
d745 1
a745 1
  c4x_version = info->mach;
d747 2
a748 2
  c4x_oplevel  = (IS_CPU_C4X (c4x_version)) ? OP_C4X : 0;
  c4x_oplevel |= OP_C3X|OP_LPWR|OP_IDLE2|OP_ENH;
d752 2
a753 2
      optable = (c4x_inst_t **)
	xcalloc (sizeof (c4x_inst_t *), (1 << C4X_HASH_SIZE));
d755 2
a756 2
      optable_special = (c4x_inst_t **)
        xcalloc (sizeof (c4x_inst_t *), C4X_SPESOP_SIZE );
d760 2
a761 2
      for (i = c4x_num_insts - 1; i >= 0; i--)
        c4x_hash_opcode (optable, optable_special, &c4x_insts[i], c4x_oplevel);
d767 1
a767 1
      for (i=0; i<C4X_SPESOP_SIZE; i++)
d769 1
a769 1
          optable[optable_special[i]->opcode >> (32 - C4X_HASH_SIZE)] = NULL;
d774 1
a774 1
    c4x_dp = EXTRU (instruction, 15, 0);
d776 1
a776 1
  p = optable[instruction >> (32 - C4X_HASH_SIZE)];
d780 2
a781 2
           && c4x_print_op (NULL, instruction, p, pc) )
        c4x_print_op (info, instruction, p, pc);
d787 1
a787 1
      for (i = 0; i<C4X_SPESOP_SIZE; i++)
d794 1
a794 1
      if (i==C4X_SPESOP_SIZE)
d826 1
a826 1
  return c4x_disassemble (pc, op, info) * 4;
@


1.4.16.1
log
@Merge with mainline.
@
text
@d3 1
a3 1
   Copyright 2002, 2003 Free Software Foundation, Inc.
d26 1
a26 1
#define TIC4X_DEBUG 0
d28 2
a29 2
#define TIC4X_HASH_SIZE   11   /* 11 (bits) and above should give unique entries.  */
#define TIC4X_SPESOP_SIZE 8    /* Max 8. ops for special instructions */
d46 1
a46 1
    INDIRECT_TIC4X
d50 2
a51 2
static int tic4x_version = 0;
static int tic4x_dp = 0;
d53 1
a53 1
static int tic4x_pc_offset
d55 1
a55 1
static int tic4x_print_char
d57 1
a57 1
static int tic4x_print_str
d59 1
a59 1
static int tic4x_print_register
d61 1
a61 1
static int tic4x_print_addr
d63 1
a63 1
static int tic4x_print_relative
d65 1
a65 1
void tic4x_print_ftoa
d67 1
a67 1
static int tic4x_print_direct
d69 1
a69 1
static int tic4x_print_immed
d71 1
a71 1
static int tic4x_print_cond
d73 1
a73 1
static int tic4x_print_indirect
d75 7
a81 7
static int tic4x_print_op
  PARAMS ((struct disassemble_info *, unsigned long, tic4x_inst_t *, unsigned long));
static void tic4x_hash_opcode_special
  PARAMS ((tic4x_inst_t **, const tic4x_inst_t *));
static void tic4x_hash_opcode
  PARAMS ((tic4x_inst_t **, tic4x_inst_t **, const tic4x_inst_t *, unsigned long));
static int tic4x_disassemble
d88 1
a88 1
tic4x_pc_offset (op)
d146 1
a146 1
tic4x_print_char (info, ch)
d156 1
a156 1
tic4x_print_str (info, str)
d166 1
a166 1
tic4x_print_register (info, regno)
d170 1
a170 1
  static tic4x_register_t **registertable = NULL;
d175 5
a179 5
      registertable = (tic4x_register_t **)
	xmalloc (sizeof (tic4x_register_t *) * REG_TABLE_SIZE);
      for (i = 0; i < tic3x_num_registers; i++)
	registertable[tic3x_registers[i].regno] = (void *)&tic3x_registers[i];
      if (IS_CPU_TIC4X (tic4x_version))
d183 2
a184 2
	  for (i = 0; i < tic4x_num_registers; i++)
	    registertable[tic4x_registers[i].regno] = (void *)&tic4x_registers[i];
d187 1
a187 1
  if ((int) regno > (IS_CPU_TIC4X (tic4x_version) ? TIC4X_REG_MAX : TIC3X_REG_MAX))
d195 1
a195 1
tic4x_print_addr (info, addr)
d205 1
a205 1
tic4x_print_relative (info, pc, offset, opcode)
d211 1
a211 1
  return tic4x_print_addr (info, pc + offset + tic4x_pc_offset (opcode));
d215 1
a215 1
tic4x_print_direct (info, arg)
d222 1
a222 1
      tic4x_print_addr (info, arg + (tic4x_dp << 16));
d230 1
a230 1
tic4x_print_ftoa (val, stream, pfunc)
d256 1
a256 1
tic4x_print_immed (info, type, arg)
d315 1
a315 1
tic4x_print_cond (info, cond)
d319 1
a319 1
  static tic4x_cond_t **condtable = NULL;
d324 3
a326 3
      condtable = (tic4x_cond_t **)xmalloc (sizeof (tic4x_cond_t *) * 32);
      for (i = 0; i < tic4x_num_conds; i++)
	condtable[tic4x_conds[i].cond] = (void *)&tic4x_conds[i];
d336 1
a336 1
tic4x_print_indirect (info, type, arg)
d351 1
a351 1
    case INDIRECT_TIC4X:		/* *+ARn(disp) */
d369 1
a369 2
        (*info->fprintf_func)(info->stream, "# internal error: Unknown indirect type %d", type);
        return 0;
d371 1
a371 1
  if (modn > TIC3X_MODN_MAX)
d373 1
a373 1
  a = tic4x_indirects[modn].name;
d379 1
a379 1
	  tic4x_print_register (info, aregno);
d382 1
a382 1
	  tic4x_print_immed (info, IMMED_UINT, disp);
d385 1
a385 1
	  tic4x_print_str (info, "ir0");
d388 1
a388 1
	  tic4x_print_str (info, "ir1");
d391 1
a391 1
	  tic4x_print_char (info, *a);
d400 1
a400 1
tic4x_print_op (info, instruction, p, pc)
d403 1
a403 1
     tic4x_inst_t *p;
d417 1
a417 1
	  if (! tic4x_print_cond (info, EXTRU (instruction, 20, 16)))
d421 1
a421 1
	  if (! tic4x_print_cond (info, EXTRU (instruction, 27, 23)))
d428 1
a428 1
	  tic4x_print_char (info, *s);
d437 1
a437 1
    tic4x_print_char (info, ' ');
d444 1
a444 1
	  if (! tic4x_print_indirect (info, INDIRECT_LONG,
d450 1
a450 1
	  tic4x_print_immed (info, IMMED_UINT, EXTRU (instruction, 15, 0));
d454 1
a454 1
	  tic4x_print_direct (info, EXTRU (instruction, 15, 0));
d458 1
a458 1
	  if (! tic4x_print_register (info, EXTRU (instruction, 24, 22) +
d465 2
a466 2
	  if (IS_CPU_TIC4X (tic4x_version))
	    tic4x_print_relative (info, pc, EXTRS (instruction, 23, 0),
d469 1
a469 1
	    tic4x_print_addr (info, EXTRU (instruction, 23, 0));
d473 1
a473 1
	  if (! IS_CPU_TIC4X (tic4x_version))
d475 1
a475 1
	  if (! tic4x_print_indirect (info, INDIRECT_TIC4X,
d486 1
a486 1
	  if (! tic4x_print_register (info, EXTRU (instruction, 7, 0)))
d491 1
a491 1
	  tic4x_print_immed (info, IMMED_SFLOAT,
d498 1
a498 1
              if( !tic4x_print_register (info, EXTRU (instruction, 4, 0)) )
d505 1
a505 1
	  if (! tic4x_print_indirect (info, INDIRECT_SHORT,
d513 1
a513 1
              if( !tic4x_print_register (info, EXTRU (instruction, 12, 8)) )
d519 1
a519 1
	  if (! tic4x_print_indirect (info, INDIRECT_SHORT,
d526 1
a526 1
	  if (! tic4x_print_register (info, EXTRU (instruction, 15, 8)))
d531 1
a531 1
	  if (! tic4x_print_register (info, EXTRU (instruction, 18, 16)))
d536 1
a536 1
	  if (! tic4x_print_register (info, EXTRU (instruction, 21, 19)))
d541 1
a541 1
	  if (! tic4x_print_register (info, EXTRU (instruction, 24, 22)))
d546 1
a546 1
	  tic4x_print_register (info, EXTRU (instruction, 22, 22) + REG_R2);
d550 1
a550 1
	  tic4x_print_register (info, EXTRU (instruction, 23, 23) + REG_R0);
d554 1
a554 1
	  if (! IS_CPU_TIC4X (tic4x_version))
d556 1
a556 1
	  if (! tic4x_print_indirect (info, INDIRECT_TIC4X,
d562 1
a562 1
	  tic4x_print_relative (info, pc, EXTRS (instruction, 15, 0),
d568 1
a568 1
	  if (! tic4x_print_register (info, EXTRU (instruction, 15, 0)))
d574 1
a574 1
	  if (! tic4x_print_register (info, EXTRU (instruction, 20, 16)))
d579 1
a579 1
	  tic4x_print_immed (info, IMMED_SINT,
d584 1
a584 1
	  if (! IS_CPU_TIC4X (tic4x_version))
d586 1
a586 1
	  if (! tic4x_print_immed (info, IMMED_SUINT,
d592 1
a592 1
	  tic4x_print_immed (info, IMMED_SUINT, EXTRU (instruction, 15, 0));
d596 2
a597 2
	  tic4x_print_immed (info, IMMED_SUINT,
			   IS_CPU_TIC4X (tic4x_version) ? 
d603 1
a603 1
	  if (! IS_CPU_TIC4X (tic4x_version))
d605 1
a605 1
	  tic4x_print_immed (info, IMMED_SINT, EXTRS (instruction, 7, 0));
d612 1
a612 1
	  if (! tic4x_print_register (info, val))
d620 1
a620 1
	  if (! tic4x_print_register (info, val))
d628 1
a628 1
	  if (! tic4x_print_register (info, val))
d633 3
a635 3
	  tic4x_print_str (info, " || ");
	  tic4x_print_str (info, parallel);
	  tic4x_print_char (info, ' ');
d639 1
a639 1
	  tic4x_print_char (info, ',');
d643 1
a643 1
	  tic4x_print_char (info, *s);
d652 3
a654 3
tic4x_hash_opcode_special (optable_special, inst)
     tic4x_inst_t **optable_special;
     const tic4x_inst_t *inst;
d658 1
a658 1
  for( i=0; i<TIC4X_SPESOP_SIZE; i++ )
d667 1
a667 1
  for( i=0; i<TIC4X_SPESOP_SIZE; i++ )
d676 1
a676 1
     instructions exceeds TIC4X_SPESOP_SIZE. Please increase the variable
d678 2
a679 2
#if TIC4X_DEBUG
  printf("optable_special[] is full, please increase TIC4X_SPESOP_SIZE!\n");
d684 5
a688 5
tic4x_hash_opcode (optable, optable_special, inst, tic4x_oplevel)
     tic4x_inst_t **optable;
     tic4x_inst_t **optable_special;
     const tic4x_inst_t *inst;
     const unsigned long tic4x_oplevel;
d691 2
a692 2
  int opcode = inst->opcode >> (32 - TIC4X_HASH_SIZE);
  int opmask = inst->opmask >> (32 - TIC4X_HASH_SIZE);
d694 1
a694 1
  /* Use a TIC4X_HASH_SIZE bit index as a hash index.  We should
d699 1
a699 1
         && inst->oplevel & tic4x_oplevel )
d701 1
a701 1
#if TIC4X_DEBUG
d713 1
a713 1
             && inst->opmask & ~(opmask << (32 - TIC4X_HASH_SIZE)) )
d716 1
a716 1
            tic4x_hash_opcode_special(optable_special, optable[j]);
d719 1
a719 1
            tic4x_hash_opcode_special(optable_special, inst);
d733 1
a733 1
tic4x_disassemble (pc, instruction, info)
d738 3
a740 3
  static tic4x_inst_t **optable = NULL;
  static tic4x_inst_t **optable_special = NULL;
  tic4x_inst_t *p;
d742 1
a742 1
  unsigned long tic4x_oplevel;
d744 1
a744 1
  tic4x_version = info->mach;
d746 2
a747 2
  tic4x_oplevel  = (IS_CPU_TIC4X (tic4x_version)) ? OP_C4X : 0;
  tic4x_oplevel |= OP_C3X|OP_LPWR|OP_IDLE2|OP_ENH;
d751 2
a752 2
      optable = (tic4x_inst_t **)
	xcalloc (sizeof (tic4x_inst_t *), (1 << TIC4X_HASH_SIZE));
d754 2
a755 2
      optable_special = (tic4x_inst_t **)
        xcalloc (sizeof (tic4x_inst_t *), TIC4X_SPESOP_SIZE );
d759 2
a760 2
      for (i = tic4x_num_insts - 1; i >= 0; i--)
        tic4x_hash_opcode (optable, optable_special, &tic4x_insts[i], tic4x_oplevel);
d766 1
a766 1
      for (i=0; i<TIC4X_SPESOP_SIZE; i++)
d768 1
a768 1
          optable[optable_special[i]->opcode >> (32 - TIC4X_HASH_SIZE)] = NULL;
d773 1
a773 1
    tic4x_dp = EXTRU (instruction, 15, 0);
d775 1
a775 1
  p = optable[instruction >> (32 - TIC4X_HASH_SIZE)];
d779 2
a780 2
           && tic4x_print_op (NULL, instruction, p, pc) )
        tic4x_print_op (info, instruction, p, pc);
d786 1
a786 1
      for (i = 0; i<TIC4X_SPESOP_SIZE; i++)
d793 1
a793 1
      if (i==TIC4X_SPESOP_SIZE)
d825 1
a825 1
  return tic4x_disassemble (pc, op, info) * 4;
@


1.3
log
@
	* gas/config/tc-tic4x.c: Remove c4x_pseudo_ignore function.
	  (c4x_operands_match): Added check for 8-bits LDF insn. Give
	  warning when using constant direct bigger than 2^16. Add the new
	  arguments.
	* include/opcode/tic4x.h: Major rewrite of entire file. Define
	  instruction classes, and put each instruction into a class.
	* opcodes/tic4x-dis.c: (c4x_print_op): Add support for the new
	  argument format. Fix bug in 'N' register printer.
@
text
@d28 2
a29 1
#define C4X_HASH_SIZE 11 /* 11 and above should give unique entries.  */
d54 1
a54 1
    PARAMS ((unsigned int));
d56 1
a56 1
    PARAMS ((struct disassemble_info *, char));
d58 1
a58 1
    PARAMS ((struct disassemble_info *, char *));
d60 1
a60 1
    PARAMS ((struct disassemble_info *, unsigned long));
d62 1
a62 1
    PARAMS ((struct disassemble_info *, unsigned long));
d64 1
a64 1
    PARAMS ((struct disassemble_info *, unsigned long, long, unsigned long));
d66 1
a66 1
    PARAMS ((unsigned int, FILE *, fprintf_ftype));
d68 1
a68 1
    PARAMS ((struct disassemble_info *, unsigned long));
d70 1
a70 1
    PARAMS ((struct disassemble_info *, immed_t, unsigned long));
d72 1
a72 1
    PARAMS ((struct disassemble_info *, unsigned int));
d74 1
a74 1
    PARAMS ((struct disassemble_info *, indirect_t, unsigned long));
d76 3
a78 1
    PARAMS ((struct disassemble_info *, unsigned long, c4x_inst_t *, unsigned long));
d80 1
a80 1
    PARAMS ((c4x_inst_t **, const c4x_inst_t *));
d82 1
a82 1
    PARAMS ((unsigned long, unsigned long, struct disassemble_info *));
d84 1
a84 1
    PARAMS ((bfd_vma, struct disassemble_info *));
d495 9
d510 8
d652 33
a684 1
c4x_hash_opcode (optable, inst)
d686 1
d688 1
d698 2
a699 1
    if ((j & opmask) == opcode)
d708 15
a722 1
	optable[j] = (void *)inst;
d739 1
d742 1
d745 3
d753 4
d759 10
a768 7
      for (i = c3x_num_insts - 1; i >= 0; i--)
	c4x_hash_opcode (optable, &c3x_insts[i]);
      if (IS_CPU_C4X (c4x_version))
	{
	  for (i = c4x_num_insts - 1; i >= 0; i--)
	    c4x_hash_opcode (optable, &c4x_insts[i]);
	}
d774 1
a774 1
  
d776 8
a783 3
  if (p != NULL && ((instruction & p->opmask) == p->opcode)
      && c4x_print_op (NULL, instruction, p, pc))
    c4x_print_op (info, instruction, p, pc);
d785 11
a795 1
    (*info->fprintf_func) (info->stream, "%08x", instruction);
@


1.2
log
@	* tic4x-dis.c: Add function declarations and ATTRIBUTE_UNUSED.
	Convert functions to K&R format.
@
text
@d482 1
d505 1
d530 1
a530 1
	  c4x_print_register (info, EXTRU (instruction, 22, 22) + REG_R0);
d547 1
d553 1
@


1.2.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   Copyright 2002, 2003 Free Software Foundation, Inc.
d26 1
a26 1
#define TIC4X_DEBUG 0
d28 1
a28 2
#define TIC4X_HASH_SIZE   11   /* 11 (bits) and above should give unique entries.  */
#define TIC4X_SPESOP_SIZE 8    /* Max 8. ops for special instructions */
d45 1
a45 1
    INDIRECT_TIC4X
d49 2
a50 2
static int tic4x_version = 0;
static int tic4x_dp = 0;
d52 28
a79 30
static int tic4x_pc_offset
  PARAMS ((unsigned int));
static int tic4x_print_char
  PARAMS ((struct disassemble_info *, char));
static int tic4x_print_str
  PARAMS ((struct disassemble_info *, char *));
static int tic4x_print_register
  PARAMS ((struct disassemble_info *, unsigned long));
static int tic4x_print_addr
  PARAMS ((struct disassemble_info *, unsigned long));
static int tic4x_print_relative
  PARAMS ((struct disassemble_info *, unsigned long, long, unsigned long));
void tic4x_print_ftoa
  PARAMS ((unsigned int, FILE *, fprintf_ftype));
static int tic4x_print_direct
  PARAMS ((struct disassemble_info *, unsigned long));
static int tic4x_print_immed
  PARAMS ((struct disassemble_info *, immed_t, unsigned long));
static int tic4x_print_cond
  PARAMS ((struct disassemble_info *, unsigned int));
static int tic4x_print_indirect
  PARAMS ((struct disassemble_info *, indirect_t, unsigned long));
static int tic4x_print_op
  PARAMS ((struct disassemble_info *, unsigned long, tic4x_inst_t *, unsigned long));
static void tic4x_hash_opcode_special
  PARAMS ((tic4x_inst_t **, const tic4x_inst_t *));
static void tic4x_hash_opcode
  PARAMS ((tic4x_inst_t **, tic4x_inst_t **, const tic4x_inst_t *, unsigned long));
static int tic4x_disassemble
  PARAMS ((unsigned long, unsigned long, struct disassemble_info *));
d81 1
a81 1
  PARAMS ((bfd_vma, struct disassemble_info *));
d85 1
a85 1
tic4x_pc_offset (op)
d143 1
a143 1
tic4x_print_char (info, ch)
d153 1
a153 1
tic4x_print_str (info, str)
d163 1
a163 1
tic4x_print_register (info, regno)
d167 1
a167 1
  static tic4x_register_t **registertable = NULL;
d172 5
a176 5
      registertable = (tic4x_register_t **)
	xmalloc (sizeof (tic4x_register_t *) * REG_TABLE_SIZE);
      for (i = 0; i < tic3x_num_registers; i++)
	registertable[tic3x_registers[i].regno] = (void *)&tic3x_registers[i];
      if (IS_CPU_TIC4X (tic4x_version))
d180 2
a181 2
	  for (i = 0; i < tic4x_num_registers; i++)
	    registertable[tic4x_registers[i].regno] = (void *)&tic4x_registers[i];
d184 1
a184 1
  if ((int) regno > (IS_CPU_TIC4X (tic4x_version) ? TIC4X_REG_MAX : TIC3X_REG_MAX))
d192 1
a192 1
tic4x_print_addr (info, addr)
d202 1
a202 1
tic4x_print_relative (info, pc, offset, opcode)
d208 1
a208 1
  return tic4x_print_addr (info, pc + offset + tic4x_pc_offset (opcode));
d212 1
a212 1
tic4x_print_direct (info, arg)
d219 1
a219 1
      tic4x_print_addr (info, arg + (tic4x_dp << 16));
d227 1
a227 1
tic4x_print_ftoa (val, stream, pfunc)
d253 1
a253 1
tic4x_print_immed (info, type, arg)
d312 1
a312 1
tic4x_print_cond (info, cond)
d316 1
a316 1
  static tic4x_cond_t **condtable = NULL;
d321 3
a323 3
      condtable = (tic4x_cond_t **)xmalloc (sizeof (tic4x_cond_t *) * 32);
      for (i = 0; i < tic4x_num_conds; i++)
	condtable[tic4x_conds[i].cond] = (void *)&tic4x_conds[i];
d333 1
a333 1
tic4x_print_indirect (info, type, arg)
d348 1
a348 1
    case INDIRECT_TIC4X:		/* *+ARn(disp) */
d366 1
a366 2
        (*info->fprintf_func)(info->stream, "# internal error: Unknown indirect type %d", type);
        return 0;
d368 1
a368 1
  if (modn > TIC3X_MODN_MAX)
d370 1
a370 1
  a = tic4x_indirects[modn].name;
d376 1
a376 1
	  tic4x_print_register (info, aregno);
d379 1
a379 1
	  tic4x_print_immed (info, IMMED_UINT, disp);
d382 1
a382 1
	  tic4x_print_str (info, "ir0");
d385 1
a385 1
	  tic4x_print_str (info, "ir1");
d388 1
a388 1
	  tic4x_print_char (info, *a);
d397 1
a397 1
tic4x_print_op (info, instruction, p, pc)
d400 1
a400 1
     tic4x_inst_t *p;
d414 1
a414 1
	  if (! tic4x_print_cond (info, EXTRU (instruction, 20, 16)))
d418 1
a418 1
	  if (! tic4x_print_cond (info, EXTRU (instruction, 27, 23)))
d425 1
a425 1
	  tic4x_print_char (info, *s);
d434 1
a434 1
    tic4x_print_char (info, ' ');
d441 1
a441 1
	  if (! tic4x_print_indirect (info, INDIRECT_LONG,
d447 1
a447 1
	  tic4x_print_immed (info, IMMED_UINT, EXTRU (instruction, 15, 0));
d451 1
a451 1
	  tic4x_print_direct (info, EXTRU (instruction, 15, 0));
d455 1
a455 1
	  if (! tic4x_print_register (info, EXTRU (instruction, 24, 22) +
d462 2
a463 2
	  if (IS_CPU_TIC4X (tic4x_version))
	    tic4x_print_relative (info, pc, EXTRS (instruction, 23, 0),
d466 1
a466 1
	    tic4x_print_addr (info, EXTRU (instruction, 23, 0));
d470 1
a470 1
	  if (! IS_CPU_TIC4X (tic4x_version))
d472 1
a472 1
	  if (! tic4x_print_indirect (info, INDIRECT_TIC4X,
d482 1
a482 2
        case 'e':
	  if (! tic4x_print_register (info, EXTRU (instruction, 7, 0)))
d487 1
a487 1
	  tic4x_print_immed (info, IMMED_SFLOAT,
a490 9
        case 'i': /* Extended indirect 0--7 */
          if ( EXTRU (instruction, 7, 5) == 7 )
            {
              if( !tic4x_print_register (info, EXTRU (instruction, 4, 0)) )
                return 0;
              break;
            }
          /* Fallthrough */

d492 1
a492 1
	  if (! tic4x_print_indirect (info, INDIRECT_SHORT,
a496 8
        case 'j': /* Extended indirect 8--15 */
          if ( EXTRU (instruction, 15, 13) == 7 )
            {
              if( !tic4x_print_register (info, EXTRU (instruction, 12, 8)) )
                return 0;
              break;
            }

d498 1
a498 1
	  if (! tic4x_print_indirect (info, INDIRECT_SHORT,
d504 1
a504 2
        case 'g':
	  if (! tic4x_print_register (info, EXTRU (instruction, 15, 8)))
d509 1
a509 1
	  if (! tic4x_print_register (info, EXTRU (instruction, 18, 16)))
d514 1
a514 1
	  if (! tic4x_print_register (info, EXTRU (instruction, 21, 19)))
d519 1
a519 1
	  if (! tic4x_print_register (info, EXTRU (instruction, 24, 22)))
d524 1
a524 1
	  tic4x_print_register (info, EXTRU (instruction, 22, 22) + REG_R2);
d528 1
a528 1
	  tic4x_print_register (info, EXTRU (instruction, 23, 23) + REG_R0);
d532 1
a532 1
	  if (! IS_CPU_TIC4X (tic4x_version))
d534 1
a534 1
	  if (! tic4x_print_indirect (info, INDIRECT_TIC4X,
d540 1
a540 1
	  tic4x_print_relative (info, pc, EXTRS (instruction, 15, 0),
d545 1
a545 2
        case 'q':
	  if (! tic4x_print_register (info, EXTRU (instruction, 15, 0)))
d550 1
a550 2
        case 'r':
	  if (! tic4x_print_register (info, EXTRU (instruction, 20, 16)))
d555 1
a555 1
	  tic4x_print_immed (info, IMMED_SINT,
d560 1
a560 1
	  if (! IS_CPU_TIC4X (tic4x_version))
d562 1
a562 1
	  if (! tic4x_print_immed (info, IMMED_SUINT,
d568 1
a568 1
	  tic4x_print_immed (info, IMMED_SUINT, EXTRU (instruction, 15, 0));
d572 2
a573 2
	  tic4x_print_immed (info, IMMED_SUINT,
			   IS_CPU_TIC4X (tic4x_version) ? 
d579 1
a579 1
	  if (! IS_CPU_TIC4X (tic4x_version))
d581 1
a581 1
	  tic4x_print_immed (info, IMMED_SINT, EXTRS (instruction, 7, 0));
d588 1
a588 1
	  if (! tic4x_print_register (info, val))
d596 1
a596 1
	  if (! tic4x_print_register (info, val))
d604 1
a604 1
	  if (! tic4x_print_register (info, val))
d609 3
a611 3
	  tic4x_print_str (info, " || ");
	  tic4x_print_str (info, parallel);
	  tic4x_print_char (info, ' ');
d615 1
a615 1
	  tic4x_print_char (info, ',');
d619 1
a619 1
	  tic4x_print_char (info, *s);
d628 3
a630 37
tic4x_hash_opcode_special (optable_special, inst)
     tic4x_inst_t **optable_special;
     const tic4x_inst_t *inst;
{
  int i;

  for( i=0; i<TIC4X_SPESOP_SIZE; i++ )
    if( optable_special[i] != NULL
        && optable_special[i]->opcode == inst->opcode )
      {
        /* Collision (we have it already) - overwrite */
        optable_special[i] = (void *)inst;
        return;
      }

  for( i=0; i<TIC4X_SPESOP_SIZE; i++ )
    if( optable_special[i] == NULL )
      {
        /* Add the new opcode */
        optable_special[i] = (void *)inst;
        return;
      }

  /* This should never occur. This happens if the number of special
     instructions exceeds TIC4X_SPESOP_SIZE. Please increase the variable
     of this variable */
#if TIC4X_DEBUG
  printf("optable_special[] is full, please increase TIC4X_SPESOP_SIZE!\n");
#endif
}

static void
tic4x_hash_opcode (optable, optable_special, inst, tic4x_oplevel)
     tic4x_inst_t **optable;
     tic4x_inst_t **optable_special;
     const tic4x_inst_t *inst;
     const unsigned long tic4x_oplevel;
d633 2
a634 2
  int opcode = inst->opcode >> (32 - TIC4X_HASH_SIZE);
  int opmask = inst->opmask >> (32 - TIC4X_HASH_SIZE);
d636 1
a636 1
  /* Use a TIC4X_HASH_SIZE bit index as a hash index.  We should
d640 1
a640 2
    if ( (j & opmask) == opcode
         && inst->oplevel & tic4x_oplevel )
d642 1
a642 1
#if TIC4X_DEBUG
d649 1
a649 15
        /* Catch those ops that collide with others already inside the
           hash, and have a opmask greater than the one we use in the
           hash. Store them in a special-list, that will handle full
           32-bit INSN, not only the first 11-bit (or so). */
        if ( optable[j] != NULL
             && inst->opmask & ~(opmask << (32 - TIC4X_HASH_SIZE)) )
          {
            /* Add the instruction already on the list */
            tic4x_hash_opcode_special(optable_special, optable[j]);

            /* Add the new instruction */
            tic4x_hash_opcode_special(optable_special, inst);
          }

        optable[j] = (void *)inst;
d660 1
a660 1
tic4x_disassemble (pc, instruction, info)
d665 2
a666 3
  static tic4x_inst_t **optable = NULL;
  static tic4x_inst_t **optable_special = NULL;
  tic4x_inst_t *p;
a667 1
  unsigned long tic4x_oplevel;
d669 1
a669 4
  tic4x_version = info->mach;

  tic4x_oplevel  = (IS_CPU_TIC4X (tic4x_version)) ? OP_C4X : 0;
  tic4x_oplevel |= OP_C3X|OP_LPWR|OP_IDLE2|OP_ENH;
d673 2
a674 6
      optable = (tic4x_inst_t **)
	xcalloc (sizeof (tic4x_inst_t *), (1 << TIC4X_HASH_SIZE));

      optable_special = (tic4x_inst_t **)
        xcalloc (sizeof (tic4x_inst_t *), TIC4X_SPESOP_SIZE );

d677 7
a683 10
      for (i = tic4x_num_insts - 1; i >= 0; i--)
        tic4x_hash_opcode (optable, optable_special, &tic4x_insts[i], tic4x_oplevel);

      /* We now need to remove the insn that are special from the
         "normal" optable, to make the disasm search this extra list
         for them.
      */
      for (i=0; i<TIC4X_SPESOP_SIZE; i++)
        if ( optable_special[i] != NULL )
          optable[optable_special[i]->opcode >> (32 - TIC4X_HASH_SIZE)] = NULL;
d688 6
a693 11
    tic4x_dp = EXTRU (instruction, 15, 0);

  p = optable[instruction >> (32 - TIC4X_HASH_SIZE)];
  if ( p != NULL )
    {
      if ( ((instruction & p->opmask) == p->opcode)
           && tic4x_print_op (NULL, instruction, p, pc) )
        tic4x_print_op (info, instruction, p, pc);
      else
        (*info->fprintf_func) (info->stream, "%08x", instruction);
    }
d695 1
a695 11
    {
      for (i = 0; i<TIC4X_SPESOP_SIZE; i++)
        if (optable_special[i] != NULL
            && optable_special[i]->opcode == instruction )
          {
            (*info->fprintf_func)(info->stream, "%s", optable_special[i]->name);
            break;
          }
      if (i==TIC4X_SPESOP_SIZE)
        (*info->fprintf_func) (info->stream, "%08x", instruction);
    }
d725 1
a725 1
  return tic4x_disassemble (pc, op, info) * 4;
@


1.2.2.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d28 1
a28 2
#define C4X_HASH_SIZE   11   /* 11 (bits) and above should give unique entries.  */
#define C4X_SPESOP_SIZE 8    /* Max 8. ops for special instructions */
d53 1
a53 1
  PARAMS ((unsigned int));
d55 1
a55 1
  PARAMS ((struct disassemble_info *, char));
d57 1
a57 1
  PARAMS ((struct disassemble_info *, char *));
d59 1
a59 1
  PARAMS ((struct disassemble_info *, unsigned long));
d61 1
a61 1
  PARAMS ((struct disassemble_info *, unsigned long));
d63 1
a63 1
  PARAMS ((struct disassemble_info *, unsigned long, long, unsigned long));
d65 1
a65 1
  PARAMS ((unsigned int, FILE *, fprintf_ftype));
d67 1
a67 1
  PARAMS ((struct disassemble_info *, unsigned long));
d69 1
a69 1
  PARAMS ((struct disassemble_info *, immed_t, unsigned long));
d71 1
a71 1
  PARAMS ((struct disassemble_info *, unsigned int));
d73 1
a73 1
  PARAMS ((struct disassemble_info *, indirect_t, unsigned long));
d75 1
a75 3
  PARAMS ((struct disassemble_info *, unsigned long, c4x_inst_t *, unsigned long));
static void c4x_hash_opcode_special
  PARAMS ((c4x_inst_t **, const c4x_inst_t *));
d77 1
a77 1
  PARAMS ((c4x_inst_t **, c4x_inst_t **, const c4x_inst_t *, unsigned long));
d79 1
a79 1
  PARAMS ((unsigned long, unsigned long, struct disassemble_info *));
d81 1
a81 1
  PARAMS ((bfd_vma, struct disassemble_info *));
a481 1
        case 'e':
a490 9
        case 'i': /* Extended indirect 0--7 */
          if ( EXTRU (instruction, 7, 5) == 7 )
            {
              if( !c4x_print_register (info, EXTRU (instruction, 4, 0)) )
                return 0;
              break;
            }
          /* Fallthrough */

a496 8
        case 'j': /* Extended indirect 8--15 */
          if ( EXTRU (instruction, 15, 13) == 7 )
            {
              if( !c4x_print_register (info, EXTRU (instruction, 12, 8)) )
                return 0;
              break;
            }

a503 1
        case 'g':
d528 1
a528 1
	  c4x_print_register (info, EXTRU (instruction, 23, 23) + REG_R0);
a544 1
        case 'q':
a549 1
        case 'r':
d628 1
a628 33
c4x_hash_opcode_special (optable_special, inst)
     c4x_inst_t **optable_special;
     const c4x_inst_t *inst;
{
  int i;

  for( i=0; i<C4X_SPESOP_SIZE; i++ )
    if( optable_special[i] != NULL
        && optable_special[i]->opcode == inst->opcode )
      {
        /* Collision (we have it already) - overwrite */
        optable_special[i] = (void *)inst;
        return;
      }

  for( i=0; i<C4X_SPESOP_SIZE; i++ )
    if( optable_special[i] == NULL )
      {
        /* Add the new opcode */
        optable_special[i] = (void *)inst;
        return;
      }

  /* This should never occur. This happens if the number of special
     instructions exceeds C4X_SPESOP_SIZE. Please increase the variable
     of this variable */
#if C4X_DEBUG
  printf("optable_special[] is full, please increase C4X_SPESOP_SIZE!\n");
#endif
}

static void
c4x_hash_opcode (optable, optable_special, inst, c4x_oplevel)
a629 1
     c4x_inst_t **optable_special;
a630 1
     const unsigned long c4x_oplevel;
d640 1
a640 2
    if ( (j & opmask) == opcode
         && inst->oplevel & c4x_oplevel )
d649 1
a649 15
        /* Catch those ops that collide with others already inside the
           hash, and have a opmask greater than the one we use in the
           hash. Store them in a special-list, that will handle full
           32-bit INSN, not only the first 11-bit (or so). */
        if ( optable[j] != NULL
             && inst->opmask & ~(opmask << (32 - C4X_HASH_SIZE)) )
          {
            /* Add the instruction already on the list */
            c4x_hash_opcode_special(optable_special, optable[j]);

            /* Add the new instruction */
            c4x_hash_opcode_special(optable_special, inst);
          }

        optable[j] = (void *)inst;
a665 1
  static c4x_inst_t **optable_special = NULL;
a667 1
  unsigned long c4x_oplevel;
a669 3

  c4x_oplevel  = (IS_CPU_C4X (c4x_version)) ? OP_C4X : 0;
  c4x_oplevel |= OP_C3X|OP_LPWR|OP_IDLE2|OP_ENH;
a674 4

      optable_special = (c4x_inst_t **)
        xcalloc (sizeof (c4x_inst_t *), C4X_SPESOP_SIZE );

d677 7
a683 10
      for (i = c4x_num_insts - 1; i >= 0; i--)
        c4x_hash_opcode (optable, optable_special, &c4x_insts[i], c4x_oplevel);

      /* We now need to remove the insn that are special from the
         "normal" optable, to make the disasm search this extra list
         for them.
      */
      for (i=0; i<C4X_SPESOP_SIZE; i++)
        if ( optable_special[i] != NULL )
          optable[optable_special[i]->opcode >> (32 - C4X_HASH_SIZE)] = NULL;
d689 1
a689 1

d691 3
a693 8
  if ( p != NULL )
    {
      if ( ((instruction & p->opmask) == p->opcode)
           && c4x_print_op (NULL, instruction, p, pc) )
        c4x_print_op (info, instruction, p, pc);
      else
        (*info->fprintf_func) (info->stream, "%08x", instruction);
    }
d695 1
a695 11
    {
      for (i = 0; i<C4X_SPESOP_SIZE; i++)
        if (optable_special[i] != NULL
            && optable_special[i]->opcode == instruction )
          {
            (*info->fprintf_func)(info->stream, "%s", optable_special[i]->name);
            break;
          }
      if (i==C4X_SPESOP_SIZE)
        (*info->fprintf_func) (info->stream, "%08x", instruction);
    }
@


1.2.2.2
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d3 1
a3 1
   Copyright 2002, 2003 Free Software Foundation, Inc.
d26 1
a26 1
#define TIC4X_DEBUG 0
d28 2
a29 2
#define TIC4X_HASH_SIZE   11   /* 11 (bits) and above should give unique entries.  */
#define TIC4X_SPESOP_SIZE 8    /* Max 8. ops for special instructions */
d46 1
a46 1
    INDIRECT_TIC4X
d50 2
a51 2
static int tic4x_version = 0;
static int tic4x_dp = 0;
d53 1
a53 1
static int tic4x_pc_offset
d55 1
a55 1
static int tic4x_print_char
d57 1
a57 1
static int tic4x_print_str
d59 1
a59 1
static int tic4x_print_register
d61 1
a61 1
static int tic4x_print_addr
d63 1
a63 1
static int tic4x_print_relative
d65 1
a65 1
void tic4x_print_ftoa
d67 1
a67 1
static int tic4x_print_direct
d69 1
a69 1
static int tic4x_print_immed
d71 1
a71 1
static int tic4x_print_cond
d73 1
a73 1
static int tic4x_print_indirect
d75 7
a81 7
static int tic4x_print_op
  PARAMS ((struct disassemble_info *, unsigned long, tic4x_inst_t *, unsigned long));
static void tic4x_hash_opcode_special
  PARAMS ((tic4x_inst_t **, const tic4x_inst_t *));
static void tic4x_hash_opcode
  PARAMS ((tic4x_inst_t **, tic4x_inst_t **, const tic4x_inst_t *, unsigned long));
static int tic4x_disassemble
d88 1
a88 1
tic4x_pc_offset (op)
d146 1
a146 1
tic4x_print_char (info, ch)
d156 1
a156 1
tic4x_print_str (info, str)
d166 1
a166 1
tic4x_print_register (info, regno)
d170 1
a170 1
  static tic4x_register_t **registertable = NULL;
d175 5
a179 5
      registertable = (tic4x_register_t **)
	xmalloc (sizeof (tic4x_register_t *) * REG_TABLE_SIZE);
      for (i = 0; i < tic3x_num_registers; i++)
	registertable[tic3x_registers[i].regno] = (void *)&tic3x_registers[i];
      if (IS_CPU_TIC4X (tic4x_version))
d183 2
a184 2
	  for (i = 0; i < tic4x_num_registers; i++)
	    registertable[tic4x_registers[i].regno] = (void *)&tic4x_registers[i];
d187 1
a187 1
  if ((int) regno > (IS_CPU_TIC4X (tic4x_version) ? TIC4X_REG_MAX : TIC3X_REG_MAX))
d195 1
a195 1
tic4x_print_addr (info, addr)
d205 1
a205 1
tic4x_print_relative (info, pc, offset, opcode)
d211 1
a211 1
  return tic4x_print_addr (info, pc + offset + tic4x_pc_offset (opcode));
d215 1
a215 1
tic4x_print_direct (info, arg)
d222 1
a222 1
      tic4x_print_addr (info, arg + (tic4x_dp << 16));
d230 1
a230 1
tic4x_print_ftoa (val, stream, pfunc)
d256 1
a256 1
tic4x_print_immed (info, type, arg)
d315 1
a315 1
tic4x_print_cond (info, cond)
d319 1
a319 1
  static tic4x_cond_t **condtable = NULL;
d324 3
a326 3
      condtable = (tic4x_cond_t **)xmalloc (sizeof (tic4x_cond_t *) * 32);
      for (i = 0; i < tic4x_num_conds; i++)
	condtable[tic4x_conds[i].cond] = (void *)&tic4x_conds[i];
d336 1
a336 1
tic4x_print_indirect (info, type, arg)
d351 1
a351 1
    case INDIRECT_TIC4X:		/* *+ARn(disp) */
d369 1
a369 2
        (*info->fprintf_func)(info->stream, "# internal error: Unknown indirect type %d", type);
        return 0;
d371 1
a371 1
  if (modn > TIC3X_MODN_MAX)
d373 1
a373 1
  a = tic4x_indirects[modn].name;
d379 1
a379 1
	  tic4x_print_register (info, aregno);
d382 1
a382 1
	  tic4x_print_immed (info, IMMED_UINT, disp);
d385 1
a385 1
	  tic4x_print_str (info, "ir0");
d388 1
a388 1
	  tic4x_print_str (info, "ir1");
d391 1
a391 1
	  tic4x_print_char (info, *a);
d400 1
a400 1
tic4x_print_op (info, instruction, p, pc)
d403 1
a403 1
     tic4x_inst_t *p;
d417 1
a417 1
	  if (! tic4x_print_cond (info, EXTRU (instruction, 20, 16)))
d421 1
a421 1
	  if (! tic4x_print_cond (info, EXTRU (instruction, 27, 23)))
d428 1
a428 1
	  tic4x_print_char (info, *s);
d437 1
a437 1
    tic4x_print_char (info, ' ');
d444 1
a444 1
	  if (! tic4x_print_indirect (info, INDIRECT_LONG,
d450 1
a450 1
	  tic4x_print_immed (info, IMMED_UINT, EXTRU (instruction, 15, 0));
d454 1
a454 1
	  tic4x_print_direct (info, EXTRU (instruction, 15, 0));
d458 1
a458 1
	  if (! tic4x_print_register (info, EXTRU (instruction, 24, 22) +
d465 2
a466 2
	  if (IS_CPU_TIC4X (tic4x_version))
	    tic4x_print_relative (info, pc, EXTRS (instruction, 23, 0),
d469 1
a469 1
	    tic4x_print_addr (info, EXTRU (instruction, 23, 0));
d473 1
a473 1
	  if (! IS_CPU_TIC4X (tic4x_version))
d475 1
a475 1
	  if (! tic4x_print_indirect (info, INDIRECT_TIC4X,
d486 1
a486 1
	  if (! tic4x_print_register (info, EXTRU (instruction, 7, 0)))
d491 1
a491 1
	  tic4x_print_immed (info, IMMED_SFLOAT,
d498 1
a498 1
              if( !tic4x_print_register (info, EXTRU (instruction, 4, 0)) )
d505 1
a505 1
	  if (! tic4x_print_indirect (info, INDIRECT_SHORT,
d513 1
a513 1
              if( !tic4x_print_register (info, EXTRU (instruction, 12, 8)) )
d519 1
a519 1
	  if (! tic4x_print_indirect (info, INDIRECT_SHORT,
d526 1
a526 1
	  if (! tic4x_print_register (info, EXTRU (instruction, 15, 8)))
d531 1
a531 1
	  if (! tic4x_print_register (info, EXTRU (instruction, 18, 16)))
d536 1
a536 1
	  if (! tic4x_print_register (info, EXTRU (instruction, 21, 19)))
d541 1
a541 1
	  if (! tic4x_print_register (info, EXTRU (instruction, 24, 22)))
d546 1
a546 1
	  tic4x_print_register (info, EXTRU (instruction, 22, 22) + REG_R2);
d550 1
a550 1
	  tic4x_print_register (info, EXTRU (instruction, 23, 23) + REG_R0);
d554 1
a554 1
	  if (! IS_CPU_TIC4X (tic4x_version))
d556 1
a556 1
	  if (! tic4x_print_indirect (info, INDIRECT_TIC4X,
d562 1
a562 1
	  tic4x_print_relative (info, pc, EXTRS (instruction, 15, 0),
d568 1
a568 1
	  if (! tic4x_print_register (info, EXTRU (instruction, 15, 0)))
d574 1
a574 1
	  if (! tic4x_print_register (info, EXTRU (instruction, 20, 16)))
d579 1
a579 1
	  tic4x_print_immed (info, IMMED_SINT,
d584 1
a584 1
	  if (! IS_CPU_TIC4X (tic4x_version))
d586 1
a586 1
	  if (! tic4x_print_immed (info, IMMED_SUINT,
d592 1
a592 1
	  tic4x_print_immed (info, IMMED_SUINT, EXTRU (instruction, 15, 0));
d596 2
a597 2
	  tic4x_print_immed (info, IMMED_SUINT,
			   IS_CPU_TIC4X (tic4x_version) ? 
d603 1
a603 1
	  if (! IS_CPU_TIC4X (tic4x_version))
d605 1
a605 1
	  tic4x_print_immed (info, IMMED_SINT, EXTRS (instruction, 7, 0));
d612 1
a612 1
	  if (! tic4x_print_register (info, val))
d620 1
a620 1
	  if (! tic4x_print_register (info, val))
d628 1
a628 1
	  if (! tic4x_print_register (info, val))
d633 3
a635 3
	  tic4x_print_str (info, " || ");
	  tic4x_print_str (info, parallel);
	  tic4x_print_char (info, ' ');
d639 1
a639 1
	  tic4x_print_char (info, ',');
d643 1
a643 1
	  tic4x_print_char (info, *s);
d652 3
a654 3
tic4x_hash_opcode_special (optable_special, inst)
     tic4x_inst_t **optable_special;
     const tic4x_inst_t *inst;
d658 1
a658 1
  for( i=0; i<TIC4X_SPESOP_SIZE; i++ )
d667 1
a667 1
  for( i=0; i<TIC4X_SPESOP_SIZE; i++ )
d676 1
a676 1
     instructions exceeds TIC4X_SPESOP_SIZE. Please increase the variable
d678 2
a679 2
#if TIC4X_DEBUG
  printf("optable_special[] is full, please increase TIC4X_SPESOP_SIZE!\n");
d684 5
a688 5
tic4x_hash_opcode (optable, optable_special, inst, tic4x_oplevel)
     tic4x_inst_t **optable;
     tic4x_inst_t **optable_special;
     const tic4x_inst_t *inst;
     const unsigned long tic4x_oplevel;
d691 2
a692 2
  int opcode = inst->opcode >> (32 - TIC4X_HASH_SIZE);
  int opmask = inst->opmask >> (32 - TIC4X_HASH_SIZE);
d694 1
a694 1
  /* Use a TIC4X_HASH_SIZE bit index as a hash index.  We should
d699 1
a699 1
         && inst->oplevel & tic4x_oplevel )
d701 1
a701 1
#if TIC4X_DEBUG
d713 1
a713 1
             && inst->opmask & ~(opmask << (32 - TIC4X_HASH_SIZE)) )
d716 1
a716 1
            tic4x_hash_opcode_special(optable_special, optable[j]);
d719 1
a719 1
            tic4x_hash_opcode_special(optable_special, inst);
d733 1
a733 1
tic4x_disassemble (pc, instruction, info)
d738 3
a740 3
  static tic4x_inst_t **optable = NULL;
  static tic4x_inst_t **optable_special = NULL;
  tic4x_inst_t *p;
d742 1
a742 1
  unsigned long tic4x_oplevel;
d744 1
a744 1
  tic4x_version = info->mach;
d746 2
a747 2
  tic4x_oplevel  = (IS_CPU_TIC4X (tic4x_version)) ? OP_C4X : 0;
  tic4x_oplevel |= OP_C3X|OP_LPWR|OP_IDLE2|OP_ENH;
d751 2
a752 2
      optable = (tic4x_inst_t **)
	xcalloc (sizeof (tic4x_inst_t *), (1 << TIC4X_HASH_SIZE));
d754 2
a755 2
      optable_special = (tic4x_inst_t **)
        xcalloc (sizeof (tic4x_inst_t *), TIC4X_SPESOP_SIZE );
d759 2
a760 2
      for (i = tic4x_num_insts - 1; i >= 0; i--)
        tic4x_hash_opcode (optable, optable_special, &tic4x_insts[i], tic4x_oplevel);
d766 1
a766 1
      for (i=0; i<TIC4X_SPESOP_SIZE; i++)
d768 1
a768 1
          optable[optable_special[i]->opcode >> (32 - TIC4X_HASH_SIZE)] = NULL;
d773 1
a773 1
    tic4x_dp = EXTRU (instruction, 15, 0);
d775 1
a775 1
  p = optable[instruction >> (32 - TIC4X_HASH_SIZE)];
d779 2
a780 2
           && tic4x_print_op (NULL, instruction, p, pc) )
        tic4x_print_op (info, instruction, p, pc);
d786 1
a786 1
      for (i = 0; i<TIC4X_SPESOP_SIZE; i++)
d793 1
a793 1
      if (i==TIC4X_SPESOP_SIZE)
d825 1
a825 1
  return tic4x_disassemble (pc, op, info) * 4;
@


1.1
log
@Add TMS320C4x support
@
text
@d52 32
d85 2
a86 1
c4x_pc_offset (unsigned int op)
d143 3
a145 1
c4x_print_char (struct disassemble_info * info, char ch)
d153 3
a155 1
c4x_print_str (struct disassemble_info *info, char *str)
d163 3
a165 2
c4x_print_register (struct disassemble_info *info,
		    unsigned long regno)
d192 3
a194 2
c4x_print_addr (struct disassemble_info *info,
		unsigned long addr)
d202 5
a206 4
c4x_print_relative (struct disassemble_info *info,
		    unsigned long pc,
		    long offset,
		    unsigned long opcode)
d212 3
a214 2
c4x_print_direct (struct disassemble_info *info,
		  unsigned long arg)
d227 4
a230 3
c4x_print_ftoa (unsigned int val,
		FILE *stream,
		int (*pfunc)())
d253 4
a256 3
c4x_print_immed (struct disassemble_info *info,
		 immed_t type,
		 unsigned long arg)
d312 3
a314 2
c4x_print_cond (struct disassemble_info *info,
		unsigned int cond)
d333 4
a336 3
c4x_print_indirect (struct disassemble_info *info,
		    indirect_t type,
		    unsigned long arg)
d397 5
a401 3
c4x_print_op (struct disassemble_info *info,
	      unsigned long instruction,
	      c4x_inst_t *p, unsigned long pc)
d628 3
a630 2
c4x_hash_opcode (c4x_inst_t **optable,
		 const c4x_inst_t *inst)
d660 4
a663 3
c4x_disassemble (unsigned long pc,
		 unsigned long instruction,
		 struct disassemble_info *info)
@


1.1.2.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@@


1.1.2.2
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a51 32
static int c4x_pc_offset
    PARAMS ((unsigned int));
static int c4x_print_char
    PARAMS ((struct disassemble_info *, char));
static int c4x_print_str
    PARAMS ((struct disassemble_info *, char *));
static int c4x_print_register
    PARAMS ((struct disassemble_info *, unsigned long));
static int c4x_print_addr
    PARAMS ((struct disassemble_info *, unsigned long));
static int c4x_print_relative
    PARAMS ((struct disassemble_info *, unsigned long, long, unsigned long));
void c4x_print_ftoa
    PARAMS ((unsigned int, FILE *, fprintf_ftype));
static int c4x_print_direct
    PARAMS ((struct disassemble_info *, unsigned long));
static int c4x_print_immed
    PARAMS ((struct disassemble_info *, immed_t, unsigned long));
static int c4x_print_cond
    PARAMS ((struct disassemble_info *, unsigned int));
static int c4x_print_indirect
    PARAMS ((struct disassemble_info *, indirect_t, unsigned long));
static int c4x_print_op
    PARAMS ((struct disassemble_info *, unsigned long, c4x_inst_t *, unsigned long));
static void c4x_hash_opcode
    PARAMS ((c4x_inst_t **, const c4x_inst_t *));
static int c4x_disassemble
    PARAMS ((unsigned long, unsigned long, struct disassemble_info *));
int print_insn_tic4x
    PARAMS ((bfd_vma, struct disassemble_info *));


d53 1
a53 2
c4x_pc_offset (op)
     unsigned int op;
d110 1
a110 3
c4x_print_char (info, ch)
     struct disassemble_info * info;
     char ch;
d118 1
a118 3
c4x_print_str (info, str)
     struct disassemble_info *info;
     char *str;
d126 2
a127 3
c4x_print_register (info, regno)
     struct disassemble_info *info;
     unsigned long regno;
d154 2
a155 3
c4x_print_addr (info, addr)
     struct disassemble_info *info;
     unsigned long addr;
d163 4
a166 5
c4x_print_relative (info, pc, offset, opcode)
     struct disassemble_info *info;
     unsigned long pc;
     long offset;
     unsigned long opcode;
d172 2
a173 3
c4x_print_direct (info, arg)
     struct disassemble_info *info;
     unsigned long arg;
d186 3
a188 4
c4x_print_ftoa (val, stream, pfunc)
     unsigned int val;
     FILE *stream;
     fprintf_ftype pfunc;
d211 3
a213 4
c4x_print_immed (info, type, arg)
     struct disassemble_info *info;
     immed_t type;
     unsigned long arg;
d269 2
a270 3
c4x_print_cond (info, cond)
     struct disassemble_info *info;
     unsigned int cond;
d289 3
a291 4
c4x_print_indirect (info, type, arg)
     struct disassemble_info *info;
     indirect_t type;
     unsigned long arg;
d352 3
a354 5
c4x_print_op (info, instruction, p, pc)
     struct disassemble_info *info;
     unsigned long instruction;
     c4x_inst_t *p;
     unsigned long pc;
d581 2
a582 3
c4x_hash_opcode (optable, inst)
     c4x_inst_t **optable;
     const c4x_inst_t *inst;
d612 3
a614 4
c4x_disassemble (pc, instruction, info)
     unsigned long pc;
     unsigned long instruction;
     struct disassemble_info *info;
@


